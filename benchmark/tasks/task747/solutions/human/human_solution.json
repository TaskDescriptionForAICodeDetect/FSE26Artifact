[
  {
    "language": "Crystal",
    "code": "MOD = 998244353i64\nn, m = read_line.split.map(&.to_i64)\n\ndef inv(v)\n  return pow(v, MOD.to_i32 - 2)\nend\n\ndef pow(v, p)\n  return 1i64 if p == 0\n  return v if p == 1\n  ret = pow(v, p / 2)\n  ret = ret * ret % MOD\n  if p % 2 == 1\n    ret = ret * v\n    ret %= MOD\n  end\n  return ret\nend\n\niv = Array.new({n + 1, 3 * m / 2 + 2}.max.to_i32) { |i| inv(i.to_i64) }\ncomb = Array.new(n + 1, 0i64)\ncomb[0] = 1i64\n1.upto(n) do |i|\n  comb[i] = comb[i - 1] * (n - i + 1) % MOD * iv[i] % MOD\nend\nans = 0i64\neven = 1i64\noveruse1 = 0i64 # more than 2 * m\noveruse2 = 0i64 # more than or equals to 2 * m\n0.upto(m * 3 / 2) do |i|\n  odd = m * 3 - 2i64 * i\n  if i == m\n    overuse2 = n\n  elsif i == m + 1\n    overuse1 = n\n    overuse2 = overuse2 * (n + (i - m) - 1) % MOD * iv[(i - m)] % MOD\n  elsif i > m + 1\n    overuse1 = overuse1 * (n + (i - m - 1) - 1) % MOD * iv[(i - m - 1)] % MOD\n    overuse2 = overuse2 * (n + (i - m) - 1) % MOD * iv[(i - m)] % MOD\n  end\n  # puts [i, even, odd, overuse1, overuse2]\n  if odd <= m\n    ans += (even + (MOD - overuse2)) * comb[odd]\n    if odd < n\n      maxuse = overuse2 + (MOD - overuse1)\n      ans += maxuse * comb[odd] % MOD * (n - odd) % MOD * iv[n]\n    end\n    ans %= MOD\n    # puts ans\n  end\n  even = even * (n + i) % MOD * iv[i + 1] % MOD\nend\nputs ans\n"
  },
  {
    "language": "Crystal",
    "code": "MOD = 998244353i64\nn, m = read_line.split.map(&.to_i64)\n\ndef inv(v)\n  return pow(v, MOD.to_i32 - 2)\nend\n\ndef pow(v, p)\n  return 1i64 if p == 0\n  return v if p == 1\n  ret = pow(v, p / 2)\n  ret = ret * ret % MOD\n  if p % 2 == 1\n    ret = ret * v\n    ret %= MOD\n  end\n  return ret\nend\n\niv = Array.new({n + 1, 3 * m / 2 + 2}.max.to_i32) { |i| inv(i.to_i64) }\ncomb = Array.new(n + 1, 0i64)\ncomb[0] = 1\n1.upto(n) do |i|\n  comb[i] = comb[i - 1] * (n - i + 1) % MOD * iv[i] % MOD\nend\nans = 0i64\neven = 1i64\noveruse1 = 0i64 # more than 2 * m\noveruse2 = 0i64 # more than or equals to 2 * m\n0.upto(3 * m / 2) do |i|\n  odd = 3 * m - i * 2\n  if i == m\n    overuse2 = n\n  elsif i == m + 1\n    overuse1 = n\n    overuse2 = overuse2 * (n + (i - m) - 1) % MOD * iv[(i - m)] % MOD\n  elsif i > m + 1\n    overuse1 = overuse1 * (n + (i - m - 1) - 1) % MOD * iv[(i - m - 1)] % MOD\n    overuse2 = overuse2 * (n + (i - m) - 1) % MOD * iv[(i - m)] % MOD\n  end\n  # puts [i, even, odd, overuse1, overuse2]\n  if odd <= m\n    ans += (even + (MOD - overuse2)) * comb[odd]\n    if odd < n\n      maxuse = overuse2 + (MOD - overuse1)\n      ans += maxuse * comb[odd] % MOD * (n - odd) % MOD * iv[n]\n    end\n    ans %= MOD\n    # puts ans\n  end\n  even = even * (n + i) % MOD * iv[i + 1] % MOD\nend\nputs ans\n"
  },
  {
    "language": "Crystal",
    "code": "MOD = 998244353i64\nn, m = read_line.split.map(&.to_i64)\n\ndef inv(v)\n  return pow(v, MOD.to_i32 - 2)\nend\n\ndef pow(v, p)\n  return 1i64 if p == 0\n  return v if p == 1\n  ret = pow(v, p / 2)\n  ret = ret * ret % MOD\n  if p % 2 == 1\n    ret = ret * v\n    ret %= MOD\n  end\n  return ret\nend\n\niv = Array.new({n + 1, 3 * m / 2 + 2}.max.to_i32) { |i| inv(i.to_i64) }\ncomb = Array.new({n + 1, m + 1}.max, 0i64)\ncomb[0] = 1i64\n1.upto(comb.size - 1) do |i|\n  comb[i] = comb[i - 1] * (n - i + 1) % MOD * iv[i] % MOD\nend\nans = 0i64\neven = 1i64\noveruse1 = 0i64 # more than 2 * m\noveruse2 = 0i64 # more than or equals to 2 * m\n0.upto(m * 3 / 2) do |i|\n  odd = m * 3 - 2i64 * i\n  if i == m\n    overuse2 = n\n  elsif i == m + 1\n    overuse1 = n\n    overuse2 = overuse2 * (n + (i - m) - 1) % MOD * iv[(i - m)] % MOD\n  elsif i > m + 1\n    overuse1 = overuse1 * (n + (i - m - 1) - 1) % MOD * iv[(i - m - 1)] % MOD\n    overuse2 = overuse2 * (n + (i - m) - 1) % MOD * iv[(i - m)] % MOD\n  end\n  # puts [i, even, odd, overuse1, overuse2]\n  if odd <= m\n    ans += (even + (MOD - overuse2)) * comb[odd]\n    if odd < n\n      maxuse = overuse2 + (MOD - overuse1)\n      ans += maxuse * comb[odd] % MOD * (n - odd) % MOD * iv[n]\n    end\n    ans %= MOD\n    # puts ans\n  end\n  even = even * (n + i) % MOD * iv[i + 1] % MOD\nend\nputs ans\n"
  },
  {
    "language": "Fortran",
    "code": "module modulo_util\n  implicit none\n  integer(8), parameter :: md = 998244353_8\n  integer(8), allocatable :: f(:), invf(:)\ncontains\n  subroutine init(n)\n    integer, intent(in) :: n\n    integer :: i\n    if (allocated(f)) deallocate(f)\n    if (allocated(invf)) deallocate(invf)\n    allocate(f(0:n),invf(0:n))\n    f = 0_8\n    invf = 0_8\n    f(0) = 1_8\n    do i = 1, n\n      f(i) = mod(f(i-1)*int(i,8),md)\n    end do\n    invf(n) = inv(f(n))\n    do i = n, 1, -1\n      invf(i-1) = mod(invf(i)*int(i,8),md)\n    end do\n  end\n  integer(8) function perm(n,k)\n    integer, intent(in) :: n, k\n    perm = 0_8\n    if (k > n .or. n < 0 .or. k < 0) return\n    perm = mod(f(n)*invf(n-k),md)\n  end\n  integer(8) function comb(n,k)\n    integer, intent(in) :: n, k\n    comb = mod(perm(n,k)*invf(k),md)\n  end\n  integer(8) function homo(n,k)\n    integer, intent(in) :: n, k\n    homo = 1_8\n    if (n == 0 .and. k == 0) return\n    homo = comb(n+k-1,k)\n  end\n  function inv(n) result(y)\n    integer(8), intent(in) :: n\n    integer(8) :: a, b, x, y, t, q\n    a = mod(n,md)\n    b = md\n    x = 0_8\n    y = 1_8\n    do while (b /= 0_8)\n      q = a/b\n      t = b\n      b = mod(a,b)\n      a = t\n      t = y\n      y = x\n      x = t-q*x\n    end do\n    y = mod(mod(y,md)+md,md)\n  end\n  function pow(a,b) result(r)\n    integer(8), intent(in) :: a\n    integer, intent(in) :: b\n    integer :: i\n    integer(8) :: r, p\n    r = 1_8\n    p = a\n    do i = 0, 32\n      if (btest(b,i)) r = mod(r*p,md)\n      p = mod(p*p,md)\n    end do\n  end\nend module modulo_util\nprogram gp2\n  use modulo_util\n  implicit none\n  integer :: n, m, i, d\n  integer(8) :: ans = 0_8\n  read(*,*) n, m\n  call init(3*max(n,m))\n  do i = mod(m,2), min(n,m), 2\n    d = (3*m-i)/2\n    ans = mod(ans+mod(comb(n,i)*modulo(homo(n,d)-int(i,8)*homo(n,d-m)-int(n-i,8)*homo(n,d-m-1),md),md),md)\n  end do\n  write(*,'(i0)') ans\nend program gp2"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <set>\n \nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 4000100;\nconst ll MOD = 998244353;\n\nint N, M;\nll ninv[MAXN];\nll fac[MAXN];\nll finv[MAXN];\nll npow[MAXN], mpow[MAXN];\n\nll rchoose (int x, int y)\n{\n    ll res = (fac[x] * finv[y]) % MOD;\n    return (res * finv[x-y]) % MOD;\n}\n\nll distro (int K)\n{\n    if (K < 0) return 0;\n    return rchoose (N + K - 1, K);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    ninv[1] = 1;\n    for (int i = 2; i < MAXN; i++)\n    {\n        int K = MOD % i;\n        ll r = ((ninv[K] * (K - MOD)) / i) % MOD + MOD;\n        ninv[i] = r % MOD;\n    }\n\n    fac[0] = finv[0] = npow[0] = mpow[0] = 1;\n    for (int i = 1; i < MAXN; i++)\n    {\n        fac[i] = (fac[i-1] * i) % MOD;\n        finv[i] = (finv[i-1] * ninv[i]) % MOD;\n    }\n    \n    cin >> N >> M;\n\n    ll ans = 0;\n    for (int i = 0; i <= N; i++)\n    {\n        int K = i;\n        if ((i + M) % 2 != 0) continue;\n        if (i > M) continue;\n        ll l = rchoose (N, i);\n        ll r = (distro ((3 * M - K) / 2) - (K * distro ((M - K) / 2)) % MOD - ((N - K) * distro ((M - K) / 2 - 1)) % MOD) % MOD;\n        ll v = (l * r) % MOD;\n        //cout << K << \" \" << l << \" \" << r << \" \" << v << \"\\n\";\n        ans = (ans + v) % MOD;\n    }\n    cout << ((ans % MOD + MOD) % MOD) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int INF=1e9;\n//const int MOD=1e9+7;\nconst int MOD=998244353;\nconst long long LINF=1e18;\nusing namespace std;\n#define int long long\n//template\nstd::vector<int> Factorial(5234567),Finverse(5234567);\nint pw(int n,int k){\n  if(k<0)return pw(n,k+MOD-1);\n  int res=1;\n  while(k){\n    if(k&1)res*=n;res%=MOD;\n    n*=n;n%=MOD;\n    k>>=1;\n  }\n  return res;\n}\nvoid Cinit(){\n  Factorial[0]=1;\n  for(int i=1;i<5234567;i++)Factorial[i]=Factorial[i-1]*i%MOD;\n  for(int i=0;i<5234567;i++)Finverse[i]=pw(Factorial[i],MOD-2);\n}\nint nCk(int n,int k){\n  if(n<k)return 1;if(k<0)return 0;\n  int res=Factorial[n];\n  res*=Finverse[k];res%=MOD;\n  res*=Finverse[n-k];res%=MOD;\n  return res;\n}\n//main\nsigned main(){\n  Cinit();\n  int N,M;cin>>N>>M;\n  int ans=nCk(3*M+(N-1),N-1);//cout<<ans<<endl;\n  int mi=N*nCk(M-1+N-1,N-1)%MOD;\n  ans-=mi;\n  ans+=MOD;ans%=MOD;\n  //cout<<ans<<endl;\n  for(int i=M+1;i<=min(N,3*M);i++){\n    if((i&1)!=((3*M)&1))continue;\n    int p=(3*M-i)/2;\n    int q=nCk(p+N-1,N-1);\n    int s=nCk(N,i);\n    int a=q*s%MOD;\n    ans-=a;\n    ans+=MOD;ans%=MOD;\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\t\n\tchar buf[bufl],*s=buf,*t=buf;\n\t\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\t\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 2500007 , mo = 998244353;\n\ninline lint powa(lint a,lint t)\n{\n\tlint b=1;\n\twhile(t){if(t&1)b=b*a%mo;a=a*a%mo,t>>=1;}\n\treturn b;\n}\n\ninline lint inva(lint a){return powa(a,mo-2);}\n\nlint jc[_],rjc[_];\n\ninline void fuck(int n=_-1)\n{\n\tjc[0]=jc[1]=rjc[0]=1;\n\tfor(int i=2;i<=n;i++)jc[i]=jc[i-1]*i%mo;\n\trjc[n]=inva(jc[n]);\n\tfor(int i=n-1;i>=1;i--)rjc[i]=rjc[i+1]*(1ll+i)%mo;\n}\n\ninline lint C(int n,int m)\n{\n\tif(n<m || n<0 || m<0)return 0;\n\treturn jc[n]*rjc[m]%mo*rjc[n-m]%mo;\n}\n\nint n,m;\n\nint main()\n{\n\tfuck();\n\n\tn=ty(),m=ty();\n\tlint ans=C(n-1+m+m+m,n-1);\n\tfor(int i=0;i<m;i++)ans=(ans-C(i+n-2,n-2)*n%mo+mo)%mo;\n\tfor(int i=m+1;i<=n;i++)if((m+m+m-i)%2==0)ans=(ans-C(n,i)*C((m+m+m-i)/2+n-1,n-1)%mo+mo)%mo;\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#include <fstream>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\n\n#define INF 1e9+7\n#define LLINF 1e18+7\n#define N 3000000\nll MOD=998244353;\n\nll inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=((-(MOD/i)*inv[MOD%i])%MOD+MOD)%MOD;\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=i*prd[i-1]%MOD;\n        invprd[i]=inv[i]*invprd[i-1]%MOD;\n    }\n    return ;\n}\nll cmb(ll a,ll b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return prd[a]*invprd[b]%MOD*invprd[a-b]%MOD;\n}\nll modpow(ll x,ll n){\n    if(n==0) return 1;\n    ll res=modpow(x*x%MOD,n/2);\n    if(n&1) res=res*x%MOD;\n    return res;\n}\n\nmain(){\n    calc_inv();\n    calc_product();\n    ll n=lin(),m=lin();\n    ll ans=0;\n    ans=cmb(m*3ll+n-1ll,n-1ll);\n    rep2(x,1,m){\n        ans=(ans+MOD-n*cmb(m+n-x-2ll,n-2ll)%MOD)%MOD;\n        if(cmb(m+n-x-2ll,n-2ll)<0)cout<<0000;\n        if(n*cmb(m+n-x-2ll,n-2ll)<0)cout<<000;\n        //cout<<ans<<endl;\n    }\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : C.cpp\n * Author  : Kazune Takahashi\n * Created : 7/21/2019, 10:28:37 PM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n#define maxs(x, y) (x = max(x, y))\n#define mins(x, y) (x = min(x, y))\nusing ll = long long;\nclass mint\n{\npublic:\n  static ll MOD;\n  ll x;\n  mint() : x(0) {}\n  mint(ll x) : x(x % MOD) {}\n  mint operator-() const { return x ? MOD - x : 0; }\n  mint &operator+=(const mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  mint &operator-=(const mint &a) { return *this += -a; }\n  mint &operator*=(const mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  mint &operator/=(const mint &a)\n  {\n    mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  mint operator+(const mint &a) const { return mint(*this) += a; }\n  mint operator-(const mint &a) const { return mint(*this) -= a; }\n  mint operator*(const mint &a) const { return mint(*this) *= a; }\n  mint operator/(const mint &a) const { return mint(*this) /= a; }\n  bool operator<(const mint &a) const { return x < a.x; }\n  bool operator==(const mint &a) const { return x == a.x; }\n  const mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\nll mint::MOD = 998244353;\nistream &operator>>(istream &stream, mint &a) { return stream >> a.x; }\nostream &operator<<(ostream &stream, const mint &a) { return stream << a.x; }\nclass combination\n{\npublic:\n  vector<mint> inv, fact, factinv;\n  static int MAX_SIZE;\n  combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[mint::MOD % i]) * (mint::MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1; i < MAX_SIZE; i++)\n    {\n      fact[i] = mint(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  mint operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n};\nint combination::MAX_SIZE = 2000010;\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\n// constexpr double epsilon = 1e-10;\n// constexpr ll infty = 1000000000000000LL;\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n\nll N, M;\n\nint main()\n{\n  cin >> N >> M;\n  combination C;\n  mint ans = C(3 * M + N - 1, N - 1);\n  for (auto K = 3 * M; K >= 2 * M + 1; K--)\n  {\n    ans -= C(3 * M - K + N - 2, N - 2) * N;\n  }\n  for (auto K = 0LL; K < M; K++)\n  {\n    assert(false);\n    ans -= C(N, 3 * M - 2 * K) * C(K + N - 1, N - 1);\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long ans,n,m,mod=998244353ll,fact[5000005],invfact[5000005],tmp;\n\nlong long fastp(long long base,long long exp){\n    if(exp==0)return 1ll;\n    long long tmp2=fastp(base,exp/2ll);\n    tmp2=(tmp2*tmp2)%mod;\n    if(exp%2==1)tmp2*=base;\n    return tmp2%mod;\n}\n\nlong long binom(long long a,long long b){\n    if(b>a)return 0ll;\n\n    return ((fact[a]*invfact[b])%mod*invfact[a-b])%mod;\n}\n\nint main(){\n\n\tcin>>n>>m;\n\t\n\tfact[0]=1;\n\tfor(long long i=1;i<5000005;i++)fact[i]=(fact[i-1]*i)%mod;\n\tinvfact[5000004]=fastp(fact[5000004],mod-2ll);\n    for(long long i=5000003;i>=0;i--)invfact[i]=(invfact[i+1]*(i+1ll))%mod;\n\n\n    \n    ans=binom(n+3ll*m-1ll,n-1ll);\n    \n \n    \n    for(int i=0;i<m;i++){\n        ans-=(fastp(n,i)*binom(n,m*3-2*i))%mod;\n        ans=(ans%mod+mod)%mod;\n    }\n    \n\n    for(int i=2*m+1;i<=(3*m);i++){\n        tmp+=binom(n-2+3*m-i,n-2);\n        tmp%=mod;\n    }\n\n    \n    ans-=(n*tmp)%mod;\n    ans=(ans%mod+mod)%mod;\n    \n    cout<<ans<<endl;\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n\nusing ll = long long;\n\nusing namespace std;\n\n#include <cassert>\n#define MOD (long)(998244353)\n#define MAX 2000000  // 階乗をいくつまで計算するか\n\nclass modlong {\n    long val;\n    static const long mod = MOD;\n    static long *invs, *facts, *finvs;\n\n    // 階乗, 逆元, 階乗の逆元をMAXまで求める\n    bool initModlong() {\n        invs[1] = \n        facts[0] = facts[1] =\n        finvs[0] = finvs[1] = 1;\n        for (int i=2; i<=MAX; i++) {\n            invs[i]  = -invs[MOD % i] * (MOD / i) % MOD;\n            facts[i] = facts[i - 1] * i % MOD;\n            finvs[i] = finvs[i - 1] * invs[i] % MOD;\n        }\n        return true;\n    }\n\npublic:\n    // 初期化 値を引数に与えなかった場合はval=0としておく\n    modlong(long init = 0) : val(init) {\n        static bool call_once = initModlong(); // static変数の性質により一度だけ呼ばれる\n        assert(call_once); // unusedの回避\n        if (val < 0 || val >= mod) val %= mod;\n        if (val < 0) val += mod;   // 0以上であることを保証\n    }\n\n    // longへのキャスト operator long()で定義すると modlong +\n    // longとかができなくなる\n    inline long tol() { return this->val; }\n\n    // 代入\n    void operator=(const modlong &r) { this->val = r.val; }\n    void operator=(const long &r) { *this = modlong(r); }\n\n    //比較\n    bool operator<(const modlong &r) { return this->val < r.val; }\n    bool operator>(const modlong &r) { return this->val > r.val; }\n    bool operator==(const modlong &r) { return this->val == r.val; }\n    bool operator!=(const modlong &r) { return !(*this == r); }\n    bool operator<=(const modlong &r) { return !(*this > r); }\n    bool operator>=(const modlong &r) { return !(*this < r); }\n\n    // 足し算; 符号反転; 引き算\n    modlong operator+(const modlong &r) {\n        long ans = this->val + r.val;\n        if (ans >= mod) ans -= mod;\n        return modlong(ans);\n    }\n    modlong operator-() {\n        long ans = mod - this->val;\n        return modlong(ans);\n    }\n    modlong operator-(const modlong &r) {\n        modlong rr = r;\n        return *this + (-rr);\n    }\n\n    //かけ算; 逆元; わり算\n    modlong operator*(const modlong &r) {\n        long ans = this->val * r.val;\n        return modlong(ans);\n    }\n    modlong inv() {\n        assert(*this != 0);\n        if (*this == 1) return modlong(1);\n\n        modlong p, q = *this, m(0), n(1), r, c;\n        p.val = mod;  // p=modとかくとp.val=mod%mod=0となってしまう\n        while (q > MAX) {\n            r = p.val % q.val;  // r.val=p.val % q.val\n                                // とかくよりもこのほうが代入時に%modされるので安全\n            c = m.val - n.val * (p.val / q.val);\n            p = q, q = r, m = n, n = c;\n        }\n        return n * invs[q.val];\n    }\n    modlong operator/(const modlong &r) { return *this * modlong(r).inv(); }\n\n    // ++ -- 前付きと後ろ付き\n    void operator++() { ++this->val; }\n    void operator++(int a) {\n        a = 0;\n        this->val++;\n    }  // a使ってなくねっていうwarningをsilenceするためにaをいじってる\n    void operator--() { --this->val; }\n    void operator--(int a) {\n        a = 0;\n        this->val--;\n    }\n\n    // 四則演算&代入\n    void operator+=(const modlong &r) { *this = *this + r; }\n    void operator-=(const modlong &r) { *this = *this - r; }\n    void operator*=(const modlong &r) { *this = *this * r; }\n    void operator/=(const modlong &r) { *this = *this / r; }\n\n    // べき乗\n    modlong pow(long n) {\n        if (n < 0)\n            return inv().pow(-n);  // 逆元の-n乗\n        else if (n == 0)\n            return modlong(1);\n\n        modlong half = pow(n / 2);\n        if (n % 2)\n            return *this * half * half;\n        else\n            return half * half;\n    }\n    modlong pow(modlong n) { return pow(n.val); }\n\n    // コンビネーション\n    modlong comb(modlong _k) {\n        assert(this->val <= MAX);\n        const long n = this->val, k = _k.val;\n        if (k < 0 || k > n) return 0;\n        if (k == 0 || k == n) return 1;\n        return modlong(facts[n]) * finvs[k] * finvs[n - k];\n    }\n\n    // 階乗\n    modlong fact() { \n        assert(this->val <= MAX);\n        return modlong(facts[this->val]);\n    }\n\n    friend ostream &operator<<(ostream &os, const modlong &out);\n    friend istream &operator>>(istream &is, modlong &out);\n};\n\n// cout、cerr、cin用の演算子たち\nostream &operator<<(ostream &os, const modlong &out) {\n    os << out.val;\n    return os;\n}\nistream &operator>>(istream &is, modlong &in) {\n    long inl;\n    is >> inl;\n    in.val = inl % MOD;\n    return is;\n}\n\n// コンビネーション\ninline modlong modComb(long n, long k) { return modlong(n).comb(k); }\n// 階乗\ninline modlong modFact(long n) { return modlong(n).fact(); }\n\n// static変数たち\nlong *modlong::invs  = new long[MAX+1],\n     *modlong::facts = new long[MAX+1],\n     *modlong::finvs = new long[MAX+1];\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    modlong ans = 0;\n    for (int i=m%2; i<=n && i<=m; i+=2) { // 最終的な{x}のうちi個が奇数\n        modlong twos = m + (m - i) / 2;\n        ans += (twos + n-1).comb(twos) * modlong(n).comb(i);\n    }\n    ans -= modlong(n) * modlong(m-1 + n-1).comb(m-1); // 2*mを超えるxiがいる場合を引く\n    cout << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=2000005,INF=1<<30;\n\nll inv[MAX],fac[MAX],finv[MAX];\n\nvoid make(){\n    \n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    \n    for(int i=2;i<MAX;i++){\n        inv[i]=mod-inv[mod%i]*(mod/i)%mod;\n        fac[i]=fac[i-1]*(ll)i%mod;\n        finv[i]=finv[i-1]*inv[i]%mod;\n    }\n    \n}\n\nll comb(ll a,ll b){\n    if(a<b) return 0;\n    return fac[a]*(finv[b]*finv[a-b]%mod)%mod;\n}\n\nint main(){\n    \n    make();\n    \n    int N,M;cin>>N>>M;\n    \n    ll sum=0;\n    \n    for(int i=M;i>=0;i-=2){\n        if(i>N) continue;\n        ll rem=(3*M-i)/2;\n        sum+=comb(rem+N-1,N-1)*comb(N,i);\n        sum%=mod;\n    }\n    \n    for(int i=M;i>=0;i-=2){\n        if(i>N) continue;\n        ll rem=(M-i)/2;\n        sum+=N*(mod-comb(rem+N-1,N-1))%mod*comb(N,i);\n        sum%=mod;\n    }\n    \n    for(int i=M;i>=0;i-=2){\n        if(i>N) continue;\n        ll rem=(M-i)/2;\n        sum+=N*(comb(rem+N-2,N-2))%mod*comb(N-1,i);\n        sum%=mod;\n    }\n    \n    cout<<sum<<endl;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define ll long long\nusing ull = unsigned long long;\nusing namespace std;\nconst int INF = 1ll << 50;\nconst int MOD = 998244353;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define bit(n, k) ((n >> k) & 1) /*nのk bit目*/\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\nvoid Yes(bool flag = true) {\n    if (flag)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n}\nvoid No(bool flag = true) {\n    Yes(!flag);\n}\nvoid YES(bool flag = true) {\n    if (flag)\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\nvoid NO(bool flag = true) {\n    YES(!flag);\n}\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define vi vector<int>\n//#define P pair<int, int>\n//#define V vector<int>\n//#define S set<int>\n#define itn int\nbool dbg = false;\ntemplate <uint MD>\nstruct ModInt {\n    using M = ModInt;\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(_v % MD + MD); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(ull(v) * r.v % MD); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1)\n                r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\nusing Mint = ModInt<MOD>;\n//Template by yosupo\nconst int MN = 1'501'000;\nMint fact[MN], iFac[MN];\n\nvoid first() {\n    fact[0] = Mint(1);\n    for (int i = 1; i < MN; i++)\n        fact[i] = fact[i - 1] * Mint(i);\n    iFac[MN - 1] = fact[MN - 1].inv();\n    for (int i = MN - 1; i >= 1; i--) {\n        iFac[i - 1] = iFac[i] * Mint(i);\n    }\n    assert(fact[2345] * iFac[2345] == Mint(1));\n}\nMint C(int n, int k) {\n    if (n < k || k < 0)\n        return Mint(0);\n    return fact[n] * iFac[k] * iFac[n - k];\n}\n\n\nint N, M;\n\nvoid solve() {\n    first();\n    Mint ans = 0;\n    for (int m = M % 2; m <= min(M, N); m += 2) {\n        Mint tmp = C(N, m);\n        int R = (M - m) / 2 + M;\n        tmp *= C(N + R - 1, N - 1);\n\n        Mint tmp2 = C(N + R - M - 1, N - 1) * m * C(N, m);\n        Mint tmp3 = C(N + R - M - 2, N - 1) * (N - m) * C(N, m);\n        //cerr << tmp << \" \" << tmp2 << \" \" << tmp3 << endl;\n        tmp -= tmp2 + tmp3;\n        ans += tmp;\n    }\n    cout << ans << endl;\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cin >> N >> M;\n\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1750000, P = 998244353;\nint n, m, fact[maxn], inv[maxn];\n\nint qp(int x, int y) {\n    int z = 1;\n    for (; y; y >>= 1, x = 1LL * x * x % P) {\n        if (y & 1) z = 1LL * z * x % P;\n    }\n    return z;\n}\n\nint C(int x, int y) {\n    return 1LL * fact[x] * inv[x - y] % P * inv[y] % P;\n}\n\nint S(int s) {\n    int ans = 0;\n    for (int i = s & 1; i <= min({n, m, s}); i += 2) {\n        ans = (ans + 1LL * C(n, i) * C((s - i) / 2 + n - 1, n - 1)) % P;\n    }\n    return ans;\n}\n\nint main() {\n    for (int i = fact[0] = inv[0] = 1; i < maxn; i++) {\n        inv[i] = qp(fact[i] = 1LL * i * fact[i - 1] % P, P - 2);\n    }\n    scanf(\"%d %d\", &n, &m);\n    printf(\"%d\\n\", (S(3 * m) - 1LL * n * S(m - 1) % P + P) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG\n \n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds; \nusing namespace std;\n \n#define F first\n#define S second \n#define pb push_back\n \n#define endl \"\\n\"\n \n#define IOS { ios :: sync_with_stdio(false); cin.tie(0); cout.tie(0); }\n \n#ifdef DEBUG\n    #define dbg(s) {s;}\n#endif\n \n#ifndef DEBUG\n    #define dbg(s)\n#endif\n \nusing namespace std;\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint grand(int x) { // from [0, x-1]\n    return uniform_int_distribution<int>(0, x - 1)(rng);\n}\n \n#define i32 int32_t\n#define int ll\n \n#define RBTTYPE int\n#define ordered_set tree<RBTTYPE, null_type, less<RBTTYPE>, rb_tree_tag,tree_order_statistics_node_update> \n \n#define all(v) (v).begin(),(v).end()\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair< int, int > pii;\ntypedef pair< ll, ll > pll;\n \nll gcd(ll x, ll y) {\n    if (x < y) return gcd(y, x);\n    if (y == 0) return x;\n    return gcd(y, x % y);\n} \n \nconst ll mod = 998244353;\n \nll modexp(ll x, ll ex) {\n    ll ans = 1ll;\n    while (ex > 0) {\n        if (ex & 1ll) ans = (ans * x) % mod;\n        ex >>= 1ll;\n        x = (x * x) % mod;\n    }\n    return ans;\n}\n \nconst int maxn = 3e6 + 7;\n \nconst ll inf = 1e9 + 7;\n\nll fact[maxn];\nll facti[maxn];\n\nvoid precalc()\n{\n    fact[1] = 1;\n    fact[0] = 1;\n    facti[1]=1;\n    facti[0] = 1;\n    for(ll i=2;i<maxn;i++)\n    {\n        fact[i] = (fact[i-1]*1ll*i)% mod;\n        facti[i] = modexp(fact[i],mod-2);\n    }\n}\n\nll C(ll n, ll k)\n{\n    if(k<0)\n        return 0;\n    if(n<k)\n        return 0;\n    ll ans = (((fact[n]*facti[n-k])%mod) *facti[k])%mod;\n    return ans;\n}\n\ni32 main() {\n    //freopen(\"<file>.in\", \"r\", stdin);\n    //freopen(\"<file>.out\", \"w\", stdout);\n \n    IOS; \n    precalc();\n    \n    ll n,m;\n    cin>>n>>m;\n    \n    ll total = C(m+m+m+n-1,n-1);\n    \n    ll part1 = 0;\n    ll u,v,sum;\n    for(ll k=m+m+1;k<=m+m+m;k++)\n    {\n        u = m+m+m-k;\n        v = C(u+n-2,n-2)*n%mod;\n        part1+=v;\n        part1%=mod;\n    }\n    \n    ll part2 = 0;\n    for(ll k=m+1;k<=n;k++)\n    {\n        u = C(n,k);\n        sum= m+m+m-k;\n        if(sum%2==1)\n            continue;\n        sum/=2;\n        v = C(sum+n-1,n-1);\n        part2 += (u*v)%mod;\n        part2%=mod;\n    }\n    \n    ll ans = total + mod - part1 + mod - part2;\n    ans%=mod;\n    \n    cout<<ans<<endl;\n    \n    \n}\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\n#define bit(n) (1LL<<(n))\n#define INT(n) int n; cin >> n;\n#define LL(n) ll n; cin >> n;\n#define DOUBLE(n) double n; cin >> n;\nusing namespace std;\n\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 998244353;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\n// solve\ntemplate <typename T>\nT power(T a, T n, T mod) {\n  T res = 1;\n  T tmp = n;\n  T curr = a;\n  while(tmp){\n    if(tmp % 2 == 1){\n      res = (T)(res * curr % mod);\n    }\n    curr = (T)(curr * curr % mod);\n    tmp >>= 1;\n  }\n\n  return res;\n}\n\ntemplate<typename T>\nT gcd(T a, T b) {\n  if(a > b)return gcd(b, a);\n  if(a == 0)return b;\n  return gcd(b % a, a);\n}\n\ntemplate<typename T>\nT extgcd(T a, T b, T &x, T &y){ \n  T d = a;\n  if(b != 0){\n    d = extgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  }else{\n    x = 1, y = 0;\n  }\n  return d;\n}\n\ntemplate <typename T>\nT modinv(T a, T m){\n  long long x = 0, y = 0;\n  extgcd<long long>(a, m, x, y);\n  x %= m;\n  if(x < 0)x += m;\n  return x;\n}\nstruct Factorial{\n  int n;\n  const int MOD = 998244353;\n  vector<long long> fac;\n  vector<long long> inv_;\n  Factorial(int n): n(n){\n    fac.resize(n + 1);\n    inv_.resize(n + 1);\n    calc_factorial();\n    calc_inv();\n  }\n  void calc_factorial(){\n    fac[0] = 1;\n    for(int i = 1; i <= n; i++){\n      fac[i] = i * fac[i-1] % MOD;\n    }\n  }\n  void calc_inv(){\n    inv_[n] = power<long long>(fac[n], MOD - 2, MOD);\n    for(int i = n - 1; i >= 0; i--){\n      inv_[i] = (i + 1) * inv_[i+1] % MOD;\n    }\n  }\n  long long& operator[](size_t i){\n    if(i < 0 || i > n){\n      cerr << \"list index out of range\" << endl;\n      abort();\n    }\n    return fac[i];\n  }\n  long long inv(size_t i){\n    if(i < 0 || i > n){\n      cerr << \"list index out of range\" << endl;\n      abort();\n    }\n    return inv_[i];\n  }\n  long long comb(int n, int k){\n    if(n < 0 || k < 0)return 0;\n    if(n < k)return 0;\n    long long res = fac[n];\n    res = res * inv_[n-k] % MOD;\n    res = res * inv_[k] % MOD;\n    return res;\n  }\n  long long perm(int n, int k){\n    if(n < k)return 0;\n    long long res = fac[n];\n    res = res * inv_[n-k] % MOD;\n    return res;\n  }\n  long long h(int n, int k){\n    if(n == 0 && k == 0)return 1;\n    return comb(n + k - 1, k);\n  }\n};\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(20);\n  INT(n); INT(m);\n  Factorial fac(3500010);\n  ll res = fac.h(n, 3 * m);\n  for(int i = 2 * m + 1; i <= 3 * m; i++){\n    int rem = 3 * m - i;\n    ll tmp = fac.h(n - 1, rem);\n    tmp = tmp * n % mod;\n    res = (res - tmp) % mod;\n    if(res < 0)res += mod;\n  }\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int int64_t\n#define rep(i, a, b) for(int i = a; i < b; ++i)\n\nint debug = 1;\n\nconst int N = 2e6 + 10;\nint mod = 998244353;\n\nint n, m;\nint fac[N], fre[N], c[3][N];\n\nint add(int a, int b) {\n    a += b;\n    while (a >= mod) a -= mod;\n    return a;\n}\n\nint sub(int a, int b) {\n    a -= b;\n    while (a < 0) a += mod;\n    return a;\n}\n\nint mul(int a, int b) {\n    return a * b % mod;\n}\n\nint pw(int x, int p) {\n    if (p == 0) return 1;\n    if (p % 2) return pw(x, p - 1) * x % mod;\n    int pp = pw(x, p / 2);\n    return pp * pp % mod;\n}\n\nint rev(int a) {\n    return pw(a, mod - 2);\n}\n\nvoid precalc() {\n    fac[0] = 1;\n    fre[0] = rev(fac[0]);\n    rep(i, 1, N) {\n        fac[i] = mul(fac[i - 1], i);\n        fre[i] = rev(fac[i]);\n    }\n}\n\nint C(int nn, int k) {\n    if (nn - k < 0) return 0;\n    return mul(fac[nn], mul(fre[k], fre[nn - k]));\n}\n\nint f(int s, int param) {\n    return C(n-param+s, n-param);\n}\n\nint g(int s, int param) {\n    int res = 0;\n    rep(a, 0, m + 1) {\n        if ((s - a) % 2 == 0 && (s - a) >= 0) {\n            res = add(res, mul(f((s - a) / 2, param), C(n+1-param, a)));\n        }\n    }\n    return res;\n}\n\nmain() {\n    cin >> n >> m;\n    precalc();\n    int ans = sub(g(3 * m, 1), mul(n, sub(g(m, 1), g(m, 2))));\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#define MOD 998244353\n#define mkp make_pair\ntypedef long long ll;\nusing namespace std;\n\n#define MAX_N 4000040\nll inv[MAX_N+10],fac[MAX_N+10],ifac[MAX_N+10];\n\nvoid setComb(){\n  inv[0]=1;inv[1]=1;fac[1]=1;ifac[1]=1;fac[0]=1;ifac[0]=1;\n  for(int i=2;i<MAX_N;i++){\n    inv[i]=(-MOD/i)*inv[MOD%i]%MOD;\n    fac[i]=fac[i-1]*i%MOD;\n    ifac[i]=ifac[i-1]*inv[i]%MOD;\n\n    inv[i]=(inv[i]+MOD)%MOD;\n    fac[i]=(fac[i]+MOD)%MOD;\n    ifac[i]=(ifac[i]+MOD)%MOD;\n  }\n  return;\n}\n\nll comb(ll n,ll k){\n  if(n<k||n<0||k<0) return 0;\n  else return ((fac[n]*ifac[k]%MOD*ifac[n-k]%MOD+MOD)%MOD);\n}\n\nll hcomb(ll n,ll r){\n  if(n==0&&r==0) return 1;\n  else if(n<0||r<0) return 0;\n  else return comb(n+r-1,r);\n}\n\nll mod_pow(ll x,ll n){\n  x%=MOD;\n  ll res=1;\n  while(n>0){\n    if(n&1) res=res*x%MOD;\n    x=x*x%MOD;\n    n>>=1;\n  }\n  return res;\n}\n\nvoid add(ll &a,ll b){\n  a=(a+b)%MOD;\n}\n\nvoid mul(ll &a,ll b){\n  a%=MOD;b%=MOD;\n  a=a*b%MOD;\n}\n\nint main(){\n  ll N,M;\n  cin>>N>>M;\n\n  setComb();\n\n  ll nans=0;\n  for(ll k=0;k<M;k++){\n    ll res=hcomb(N-1,k);\n    mul(res,N);\n    add(nans,res);\n  }\n\n  ll ans=0;\n  for(ll k=0;k<=min(N,M);k++){\n    if(k%2!=M%2) continue;\n    ll res=hcomb(N,(3*M-k)/2);\n    mul(res,comb(N,k));\n    add(ans,res);\n  }\n\n  add(ans,-nans+MOD);\n  cout<<ans<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAX_N = int(3e6) + 10;\n\nint n, m;\nint fac[MAX_N], inv[MAX_N];\n\nconst int mod = 998244353;\n\nint C(int n, int m) {\n\treturn 1LL * fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\n\nint mypow(int x, int y, int m) {\n\tint r = 1;\n\twhile (y) {\n\t\tif (y & 1)\n\t\t\tr = 1LL * r * x % m;\n\t\tx = 1LL * x * x % m;\n\t\ty >>= 1;\n\t}\n\treturn r;\n}\n\nint f(int n, int m, int odd) {\n\tint r = 0;\n\tfor (int i = 0; i <= n && i <= odd; ++i) {\n\t\tif (!(m - i & 1) && m >= i) {\n\t\t\tr = (r + 1LL * C(n, i) * C((m - i) / 2 + n - 1, n - 1) % mod) % mod;\n\t\t}\n\t}\n\t// printf(\"f(%d,%d,%d)=%d\\n\", n, m, odd, r);\n\treturn r;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfac[0] = inv[0] = 1;\n\tfor (int i = 1; i <= n + 3 * m; ++i) {\n\t\tfac[i] = 1LL * fac[i - 1] * i % mod;\n\t\tinv[i] = mypow(fac[i], mod - 2, mod);\n\t\t// printf(\"%d %d\\n\", fac[i], inv[i]);\n\t}\n\tint ans = (f(n, 3 * m, m) - 1LL * n * (f(n, m, m) - f(n - 1, m, m)) % mod) % mod;\n\tif (ans < 0) ans += mod;\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst double PI = 3.14159265358979323846;\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//typedef pair<ll, ll> P;\ntypedef pair<ll, ll> P;\nconst ll INF = 10e17;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n#define ret() return 0;\n\nstd::istream &operator>>(std::istream &in, set<int> &o) {\n    ll a;\n    in >> a;\n    o.insert(a);\n    return in;\n}\n\nstd::istream &operator>>(std::istream &in, queue<int> &o) {\n    ll a;\n    in >> a;\n    o.push(a);\n    return in;\n}\n\nbool contain(set<int> &s, int a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\n\n//const ll mod = 1e10;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ_ASK;\n\n\nstruct Edge {\n    int to, color;\n    ll cost;\n};\n\n\nll rec(vector<vector<Edge>> &g, int start, int now, int goal, int prev) {\n    if (goal == now) return 0;\n\n    for (Edge e : g[now]) {\n        if (e.to == prev) continue;\n        ll c = rec(g, start, e.to, goal, now);\n        if (c == -1) continue;\n        return c + e.cost;\n    }\n    return -1;\n}\n\nstruct Query {\n    int color;\n    ll cost;\n    int from, to;\n\n    // <edge, cost>\n    map<int, ll> costs;\n    map<int, ll> counts;\n};\n\nstd::istream &operator>>(std::istream &in, Query &o) {\n    cin >> o.color >> o.cost >> o.from >> o.to;\n    o.color--;\n    o.from--;\n    o.to--;\n    return in;\n}\n\nconst int mod = 998244353;\n\nstruct mint {\n    ll x; // typedef long long ll;\n    mint(ll x = 0) : x((x % mod + mod) % mod) {}\n\n    mint &operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    mint &operator-=(const mint a) {\n        if ((x += mod - a.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    mint &operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res += a;\n    }\n\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res -= a;\n    }\n\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res *= a;\n    }\n\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t >> 1);\n        a *= a;\n        if (t & 1) a *= *this;\n        return a;\n    }\n\n    // for prime mod\n    mint inv() const {\n        return pow(mod - 2);\n    }\n\n    mint &operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res /= a;\n    }\n\n    friend std::istream &operator>>(std::istream &in, mint &o) {\n        ll a;\n        in >> a;\n        o = a;\n        return in;\n    }\n\n    friend std::ostream &operator<<(std::ostream &out, const mint &o) {\n        out << o.x;\n        return out;\n    }\n\n};\n\nconst int vcmax = (1 << 21) + 10;\n\nstruct combination {\n    vector<mint> fact, ifact;\n\n    combination(int n) : fact(n + 1), ifact(n + 1) {\n        assert(n < mod);\n        fact[0] = 1;\n        for (int i = 1; i <= n; ++i) fact[i] = fact[i - 1] * i;\n        ifact[n] = fact[n].inv();\n        for (int i = n; i >= 1; --i) ifact[i - 1] = ifact[i] * i;\n    }\n\n    mint operator()(int n, int k) {\n        if (k < 0 || k > n) return 0;\n        return fact[n] * ifact[k] * ifact[n - k];\n    }\n} combination(vcmax);\n\nmint sub(int n, int a, int b) {\n    cmin(b, n);\n    mint ans = 0;\n    for (int i = a % 2; i <= min({n, a, b,}); i += 2) {\n        ans += combination((a - i) / 2 + n - 1, n - 1) * combination(n, i);\n    }\n    return ans;\n}\n\nint main() {\n\n    int n, m;\n    cin >> n >> m;\n\n    mint ans = sub(n, 3 * m, m);\n    ans -= (sub(n, m, m) - sub(n - 1, m, m)) * n;\n    cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod = 998244353;\ninline void upd(int &a,int b)\n{\n\ta += b;\n\tif(a >= mod) a -= mod;\n}\nint N,M;\nint fac[2000005],inq[2000005];\nint qpow(int x,int y)\n{\n\tint ans = 1;\n\twhile(y)\n\t{\n\t\tif(y&1) ans = 1ll*ans*x%mod;\n\t\tx = 1ll*x*x%mod;y >>= 1;\n\t}\n\treturn ans;\n}\nvoid init()\n{\n\tfac[0] = 1;\n\tfor(int i = 1;i <= 2000000;i ++)\n\t\tfac[i] = 1ll*i*fac[i-1]%mod;\n\tinq[2000000] = qpow(fac[2000000],mod-2);\n\tfor(int i = 1999999;i >= 0;i --)\n\t\tinq[i] = 1ll*inq[i+1]*(i+1)%mod;\n}\ninline int C(int x,int y) { return 1ll*fac[x]*inq[x-y]%mod*inq[y]%mod; }\nll solve(int sm)\n{\n\tif(sm <= 0)\n\t\treturn 0;\n\t//sum = sm, atmost M odd\n\tint r = min(min(N,M),sm);\n\tll ans = 0;\n\tfor(int i = sm&1;i <= r;i += 2)\n\t\tans = (ans+1ll*C(N,i)*C(N+((sm-i)>>1)-1,N-1))%mod;\n\treturn ans;\n}\nint main()\n{\n\tinit();\n\tscanf(\"%d%d\",&N,&M);\n\t//maxium <= 2m  sum = 3m atmost M odds\n\tprintf(\"%lld\\n\",(solve(3*M)-1ll*solve(M-1)*N%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n//#define int long long\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\nconst int MOD = 998244353;\nusing mint = Fp<MOD>;\nBiCoef<mint> bc;\n\nvoid solve() {\n\tint n, m; cin >> n >> m;\n    bc.init(30030000);\n    mint ans = bc.com(3 * m + n - 1, n - 1);\n    for(int i = 2 * m + 1; i <= 3 * m; ++i) {\n        ans -= (mint)n * bc.com(3 * m + n - i - 2, n - 2);\n    }\n    cout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\t//cout << \"finish\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <set>\n#include <chrono>\n#include <string>\n#include <assert.h>\n\nusing namespace std;\n\n#define endl '\\n'\n\nconst int maxn = 2000001;\nconst int mod = 998244353;\n\nint fak[maxn];\nint inv[maxn];\n\nint modpow(int a, int n)\n{\n    int b = 1;\n\n    while (n)\n    {\n        if (n & 1)\n        {\n            b = 1LL * a * b % mod;\n        }\n\n        n >>= 1;\n        a = 1LL * a * a % mod;\n    }\n\n    return b;\n}\n\nint inverse(int a)\n{\n    return modpow(a, mod - 2);\n}\n\nint pre()\n{\n    fak[0] = inv[0] = 1;\n\n    for (int i = 1; i < maxn; ++i)\n    {\n        fak[i] = 1LL * i * fak[i - 1] % mod;\n        inv[i] = inverse(fak[i]);\n    }\n}\n\nint comb(int n, int k)\n{\n    if (k > n || k < 0)\n        return 0;\n    return 1LL * fak[n] * inv[k] % mod * inv[n - k] % mod;\n}\n\nvoid add(int &a, int b)\n{\n    a += b;\n    if (a >= mod)\n        a -= mod;\n}\n\nvoid sub(int &a, int b)\n{\n    a -= b;\n    if (a < 0)\n        a += mod;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    pre();\n\n    int n, m;\n    cin >> n >> m;\n\n    int to_rem = 0;\n\n    for (int i = 0; i < m; ++i)\n    {\n        add(to_rem, comb(n - 2 + i, n - 2));\n    }\n\n    to_rem = 1LL * to_rem * n % mod;\n\n    int ans = 0;\n\n    for (int i = 0; i <= min(n, m); ++i)\n    {\n        if ((3 * m - i) % 2)\n            continue;\n\n        int t = (3 * m - i) / 2;\n\n        int cur = comb(n - 1 + t, t);\n        cur = 1LL * cur * comb(n, i) % mod;\n        add(ans, cur);\n    }\n\n    sub(ans, to_rem);\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_geneous = 0; ngtkana_is_geneous < n; ngtkana_is_geneous++)\n#define rep(i, begin, end) for(int i = begin; i < end; i++)\n\n#define LOCAL\nusing std::to_string;\nauto to_string(std::string s) -> std::string {\n  return '\"' + s + '\"';\n}\nauto to_string(char c) -> std::string {\n  return \"'\" + std::string{c} + \"'\";\n}\nauto to_string(const char* s) -> std::string {\n  return to_string((std::string) s);\n}\nauto to_string(bool b) -> std::string {\n  return (b ? \"true\" : \"false\");\n}\ntemplate <typename T, typename U>\nauto to_string(std::pair<T, U> p) -> std::string {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <size_t N>\nauto to_string(std::bitset<N> bs) -> std::string {\n  std::string res{};\n  for (size_t i = 0; i < N; i++)\n    res.insert(res.begin(), bs.test(i) ? '1' : '0');\n  return res;\n}\ntemplate <typename T>\nauto to_string(T v) -> std::string {\n  bool flg = false;\n  std::string res = \"{\";\n  for (auto const&x : v) {\n    if (flg) res += \", \";\n    else flg = true;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\nvoid debug_out() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  std::cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; std::swap(a, m);\n    u -= t * v; std::swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\ntemplate <typename T>\nclass modular {\n  private:\n    int value;\n  public:\n    constexpr modular() = default;\n    constexpr modular(const modular&) = default;\n    constexpr modular(modular&&) = default;\n    modular& operator=(const modular&) = default;\n    modular& operator=(modular&&) = default;\n\n    template <typename U>\n    modular (const U& x) {value = normalize(x);}\n\n    template <typename U>\n    static auto normalize(const U& x) {\n      int v = static_cast<int>(-mod() <= x && x < mod() ? x : x % mod());\n      if (v < 0) v += mod();\n      return v;\n    }\n\n    auto const& operator()() const { return value; }\n    template <typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static auto mod() { return T::value; }\n\n    auto& operator+=(const modular& other) {\n      if ((value += other.value) >= mod()) value -= mod();\n      return *this;\n    }\n    auto& operator-=(const modular& other) {\n      if ((value -= other.value) < 0) value += mod();\n      return *this;\n    }\n    template <typename U>\n    auto& operator+=(const U& other) {return *this += modular(other); }\n    template <typename U>\n    auto& operator-=(const U& other) {return *this -= modular(other); }\n    auto operator-() const { return modular(-value); }\n    auto& operator++() {return *this += 1;}\n    auto& operator--() {return *this -= 1;}\n    auto  operator++(int) {modular result(*this); operator++(); return result;}\n    auto  operator--(int) {modular result(*this); operator--(); return result;}\n\n    template <typename U = T>\n    auto& operator*=(const modular& rhs) {\n      value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n      return *this;\n    }\n    auto& operator/=(const modular& other) {\n      return *this *= modular(inverse(other.value, mod()));\n    }\n};\ntemplate <typename T> struct is_modular : std::false_type {};\ntemplate <typename T> struct is_modular <modular<T>> : std::true_type{};\ntemplate <typename T> constexpr bool is_modular_v = is_modular<T>::value;\n\ntemplate <typename T> bool operator==(const modular<T>& lhs, const modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const modular<T>& lhs, U rhs) { return lhs == modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const modular<T>& rhs) { return modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const modular<T>& lhs, const modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> modular<T> operator+(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> modular<T> operator+(const modular<T>& lhs, U rhs) { return modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> modular<T> operator+(U lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }\n\ntemplate <typename T> modular<T> operator-(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> modular<T> operator-(const modular<T>& lhs, U rhs) { return modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> modular<T> operator-(U lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> modular<T> operator*(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> modular<T> operator*(const modular<T>& lhs, U rhs) { return modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> modular<T> operator*(U lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> modular<T> operator/(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> modular<T> operator/(const modular<T>& lhs, U rhs) { return modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> modular<T> operator/(U lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nmodular<T> pow (const modular<T>& a, U b) {\n  assert(b >= 0);\n  modular<T> x = a, ret = 1;\n  for (; b > 0; b /= 2) {\n    if (b % 2 == 1) ret *= x;\n    x *= x;\n  }\n  return ret;\n}\n\ntemplate <typename T>\nstd::string to_string(const modular<T>& a) {\n  return std::to_string(a());\n}\ntemplate <typename T>\nauto operator<<(std::ostream& os, const T& a)\n  -> std::enable_if_t<is_modular_v<T>, std::ostream&>{\n    return os << a();\n  }\ntemplate <typename T>\nauto operator>>(std::istream& is, T& a)\n  -> std::enable_if_t<is_modular_v<T>, std::istream&> {\n  long long x; is >> x;\n  a = T(x);\n  return is;\n}\n\n\nusing mod_type = int;\n\nstruct voriable_mod { static mod_type value; };\nmod_type voriable_mod::value;\n// mod_type& md = voriable_mod::value;\n// using Mint = Modular<voriable_mod>;\n\n\nconstexpr int md = 998244353;\nusing mint = modular<std::integral_constant<std::decay_t<decltype(md)>, md>>;\n\nclass factorials\n{\n    std::vector<mint> fact, finv;\n\n  public:\n    factorials()=default;\n\n    void build(int n)\n    {\n      fact.resize(n), finv.resize(n);\n      fact.at(0) = 1;\n      for (int i = 1; i < n; i++) fact.at(i) = fact.at(i - 1) * mint(i);\n      finv.at(n - 1) = mint(1) / fact.at(n - 1);\n      for (int i = n - 2; i >= 0; i--) finv.at(i) = finv.at(i + 1) * mint(i + 1);\n    }\n\n    // Factorial.\n    auto operator()(int i) const {return fact.at(i);}\n\n    // Inverse of Facgorial.\n    auto inv       (int i) const {return finv.at(i);}\n\n    // Binominal Coefficient.\n    auto binom(int i, int j) const\n    {\n      assert(0 <= i);\n      if (j < 0 ||i < j) return mint(0);\n      return fact.at(i) * finv.at(j) * finv.at(i - j);\n    }\n\n    // Deal Apples.\n    auto deal(int i, int j) const\n    {\n      return binom(i + j - 1, j - 1);\n    }\n};\n\nint main()\n{\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n, m; std::cin >> n >> m;\n  auto fct = factorials{};\n  fct.build(3 * m + n + 1);\n  mint ret = 0;\n  ret += fct.deal(3 * m, n);\n  mint val_1 = 0;\n  for (int i = 0; i < m; i++)\n  {\n    val_1 += n * fct.deal(i, n - 1);\n  }\n  ret -= val_1;\n  mint val_2 = 0;\n  for (int i = n; i > m; i--)\n  {\n    if (i % 2 != m % 2) continue;\n    val_2 += fct.binom(n, i) * fct.deal((3 * m - i) / 2, n);\n  }\n  ret -= val_2;\n  std::cout << ret << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntemplate <long long mod>\nclass Combination\n{\n    std::vector<long long> fact, finv, inv;\npublic:\n    Combination(int sz)\n    {\n        fact.resize(sz);\n        finv.resize(sz);\n        inv.resize(sz);\n        fact[0] = 1;\n        for (int i = 1; i < sz; ++i)\n        {\n            fact[i] = fact[i - 1] * i % mod;\n        }\n        inv[0] = 0;\n        inv[1] = 1;\n        for (int i = 2; i < sz; ++i)\n        {\n            inv[i] = mod - inv[mod % i] * (mod / i) % mod;\n        }\n        finv[0] = 1;\n        for (int i = 1; i < sz; ++i)\n        {\n            finv[i] = finv[i - 1] * inv[i] % mod;\n        }\n    }\n    long long C(long long n, long long k)\n    {\n        if (n < k)\n            return 0;\n        if (n < 0 || k < 0)\n            return 0;\n        return (fact[n] * finv[k] % mod) * finv[n - k] % mod;\n    }\n    long long P(long long n, long long k)\n    {\n        if (n < k)\n            return 0;\n        if (n < 0 || k < 0)\n            return 0;\n        return fact[n] * finv[n - k] % mod;\n    }\n    long long H(long long n, long long k)\n    {\n        return this->C(n + k - 1, k);\n    }\n    long long getfact(int i)\n    {\n        return fact[i];\n    }\n    long long getinv(int i)\n    {\n        return inv[i];\n    }\n    long long getfinv(int i)\n    {\n        return finv[i];\n    }\n};\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst ll MOD = 998244353;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  int n, m; cin >> n >> m;\n  Combination<MOD> comb(1<<21);\n  ll tmp1 = 0, tmp2 = 0, tmp3 = 0;\n  for(int a=m%2;a<=min(n, m);a+=2) {\n    tmp1 += comb.C((3*m-a)/2+n-1, n-1) * comb.C(n, a) % MOD;\n    tmp1 %= MOD;\n  }\n  for(int a=m%2;a<=min(n, m);a+=2) {\n    tmp2 += comb.C((m-a)/2+n-1, n-1) * comb.C(n, a) % MOD;\n    tmp2 %= MOD;\n  }\n  for(int a=m%2;a<=min(n-1, m);a+=2) {\n    tmp3 += comb.C((m-a)/2+n-2, n-2) * comb.C(n-1, a) % MOD;\n    tmp3 %= MOD;\n  }\n  cout << (tmp1 - (tmp2 - tmp3 + MOD) % MOD * n % MOD + MOD) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <array>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\ntemplate <uint32_t Modulus>\nclass modular {\npublic:\n  using value_type = uint32_t;\n  using max_type = uint64_t;\n\n  static constexpr value_type mod = Modulus;\n  static constexpr value_type mod_min = 1;\n  static constexpr value_type mod_max = 2147483647;\n  static_assert(mod >= mod_min, \"invalid mod :: too small\");\n  static_assert(mod <= mod_max, \"invalid mod :: too big\");\n\n  template <class T>\n  static constexpr value_type normalize(T value_) {\n    if (value_ < 0) {\n      value_ = -value_;\n      value_ %= mod;\n      if (value_ == 0) return 0;\n      return mod - value_;\n    }\n    return value_ % mod;\n  }\n\nprivate:\n  value_type value;\n\npublic:\n  constexpr modular(): value(0) { }\n  template <class T>\n  explicit constexpr modular(T value_): value(normalize(value_)) { }\n  template <class T>\n  explicit constexpr operator T() { return static_cast<T>(value); }\n\n  constexpr value_type operator () () const { return value; }\n  constexpr modular operator - () const { return modular(mod - value); }\n  constexpr modular operator ~ () const { return inverse(); }\n\n  constexpr value_type &extract() { return value; }\n  constexpr modular inverse() const { return power(mod - 2); }\n  constexpr modular power(max_type exp) const {\n    modular res(1), mult(*this);\n    while (exp > 0) {\n      if (exp & 1) res *= mult;\n      mult *= mult;\n      exp >>= 1;\n    }\n    return res;\n  }\n\n  constexpr modular operator + (const modular &rhs) const { return modular(*this) += rhs; }\n  constexpr modular& operator += (const modular &rhs) { \n    if ((value += rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator - (const modular &rhs) const { return modular(*this) -= rhs; }\n  constexpr modular& operator -= (const modular &rhs) { \n    if ((value += mod - rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator * (const modular &rhs) const { return modular(*this) *= rhs; }\n  constexpr modular& operator *= (const modular &rhs) { \n    value = (max_type) value * rhs.value % mod;\n    return *this;\n  }\n\n  constexpr modular operator / (const modular &rhs) const { return modular(*this) /= rhs; }\n  constexpr modular& operator /= (const modular &rhs) { return (*this) *= rhs.inverse(); }\n\n  constexpr bool zero() const { return value == 0; }\n  constexpr bool operator == (const modular &rhs) const { return value == rhs.value; }\n  constexpr bool operator != (const modular &rhs) const { return value != rhs.value; }\n  friend std::ostream& operator << (std::ostream &stream, const modular &rhs) {\n    return stream << rhs.value;\n  }\n\n};\n\ntemplate <class T, std::size_t N>\nclass factorials {\npublic:\n  using value_type = T;\n  static constexpr std::size_t size = N;\n\npublic:\n  std::array<value_type, size + 1> fact{};\n  std::array<value_type, size + 1> fact_inv{};\n\n  factorials() {\n    fact.front() = value_type(1);\n    for (std::size_t i = 1; i <= size; ++i) {\n      fact[i] = fact[i - 1] * value_type(i);\n    }\n    fact_inv.back() = ~fact.back();\n    for (std::size_t i = size; i > 0; --i) {\n      fact_inv[i - 1] = fact_inv[i] * value_type(i);\n    }\n  }\n\n  value_type operator () (std::size_t n, std::size_t r) const {\n    return fact[n] * fact_inv[n - r] * fact_inv[r];\n  }\n\n};\n\nusing modint = modular<998244353>;\nfactorials<modint, 1500000> fact;\n\nmodint calc(int n, int k) {\n  if (n < 0 || k <= 0) {\n    return modint(0);\n  }\n  return fact(n + k - 1, n);\n}\n\nint main() {\n  int N, M;\n  std::cin >> N >> M;\n  modint ans;\n  for (int odd: range(0, std::min(N, M) + 1)) {\n    int sum = 3 * M - odd;\n    if (sum % 2 != 0) {\n      continue;\n    }\n    modint all;\n    all += calc(sum / 2, N);\n    all -= calc(sum / 2 - M, N) * modint(odd);\n    all -= calc(sum / 2 - M - 1, N) * modint(N - odd);\n    ans += all * fact(N, odd);\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint main(){\n    using namespace std;\n    constexpr unsigned long MOD = 998244353;\n    size_t N, M;\n    cin >> N >> M;\n    auto modpow = [&MOD](unsigned long a, unsigned long n, unsigned long b = 1) -> unsigned long{\n        auto ret = b % MOD;\n        a %= MOD;\n        while(n){\n            if(n & 1)(ret *= a) %= MOD;\n            (a *= a) %= MOD;\n            n >>= 1;\n        }\n        return ret;\n    };\n    auto modbinomial = [&MOD, &modpow](unsigned long n, unsigned long k) -> unsigned long{\n        unsigned long ret = 1, den = 1;\n        for(unsigned long i = 1; i <= k; ++i){\n            (ret *= (n - i + 1)) %= MOD;\n            (den *= i) %= MOD;\n        }\n        return modpow(den, MOD - 2, ret);\n    };\n    auto a = modbinomial(MOD - N, 3 * M) + N * modbinomial(MOD - N, M - 1);\n    a = M & 1 ? MOD - a % MOD : a % MOD;\n    if(M + 1 < N){\n        auto ub = min(N, 3 * M), lb = M, sz = (ub - lb) / 2;\n        vector<unsigned long> A(sz), B(sz);\n        {\n            auto k = M + 2;\n            auto nn = N, dd = k;\n            A[0] = modbinomial(nn, dd);\n            for(unsigned long i = 1; i < sz; ++i){\n                A[i] = modpow((dd + 1) * (dd + 2), MOD - 2, A[i - 1] * (nn - dd) % MOD * (nn - dd - 1));\n                dd += 2;\n            }\n        }\n        {\n            auto kk = ub;\n            if((ub ^ M) & 1)kk -= 1;\n            auto nn = N - 1 + (3 * M - kk) / 2, dd = N - 1;\n            B.back() = modbinomial(nn, dd);\n            for(unsigned long i = sz - 1; i--; ++nn)B[i] = modpow(nn - dd + 1, MOD - 2, B[i + 1] * (nn + 1));\n        }\n        a += MOD - inner_product(A.begin(), A.end(), B.begin(), 0UL, plus<>(), [&MOD](auto a, auto b){return a * b % MOD;}) % MOD;\n    }\n    cout << a % MOD << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iomanip>\nusing namespace std;\n#define reps(i,s,n) for(int i = s; i < n; i++)\n#define rep(i,n) reps(i,0,n)\n#define Rreps(i,n,e) for(int i = n - 1; i >= e; --i)\n#define Rrep(i,n) Rreps(i,n,0)\n#define ALL(a) a.begin(), a.end()\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nll N,M,H,W,K,Q,A,B;\nconst ll MOD = 998244353;\n//const ll MOD = (1e+9) + 7;\nconst ll INF = 1LL<<60;\ntypedef pair<ll, ll> P;\n\nconst int MAX_N = (1e+7)+10;\nvec nCm(MAX_N+1,0);\nvec fact(MAX_N+1,0),fact_inv(MAX_N+1,0);\n\nll fastpow(ll a, ll pw) {\n\tll res = 1;\n\twhile (pw) {\n\t\tif (pw & 1) res = res * a % MOD;\n\t\ta = a * a % MOD;\n\t\tpw >>= 1;\n\t}\n\treturn res;\n}\nvoid makefact(ll n){//MODは素数かつnより大きい\n    ll ans = 1;\n    fact.at(0) = ans;\n    fact_inv.at(0) = ans;\n    reps(i,1,n+1){\n        (ans *= i)%=MOD;\n        fact.at(i) = ans;\n        fact_inv.at(i) = fastpow(ans,MOD-2);\n    }\n    return;\n}\nvoid makenCm(ll n){\n    rep(i,n+1){\n        ll ans = fact.at(n);\n        (((ans*=fact_inv.at(n-i))%=MOD)*=fact_inv.at(i))%=MOD;\n        nCm.at(i) = ans;\n    }\n    return;\n}\n\nll ncm(ll n, ll m){\n    ll res = fact[n];\n    (res *= fact_inv[n - m])%=MOD;\n    (res *= fact_inv[m])%=MOD;\n    return res;\n}\n\nint main() {\n    cin>>N>>M;\n    makefact(5e+6);\n    ll ans = ncm(N + M * 3 - 1, M * 3), temp = 0;\n    rep(i, M){\n        ll tt = ncm(N + i - 2, i);\n        (temp += tt)%=MOD;\n    }\n    (temp *= N)%=MOD;\n    (ans += MOD - temp)%=MOD;\n    temp = 0;\n    for(ll k = M * 2 - 2; k >= 0 && k >= M * 3 - N; k -= 2){//kは奇数個割り振った後の余り\n        ll ball = k / 2, ball2 = M * 3 - k;\n        ll tt = ncm(N + ball - 1, ball);\n        (tt *= ncm(N, ball2))%=MOD;\n        (temp += tt)%=MOD;\n    }\n    (ans += MOD - temp)%=MOD;\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct advance_math{\n\tvector<int> _f, _fi;\n\tint max_n, _mod;\n\tint fp(int _x,int _y) {\n\t\tint _res = 1;\n\t\twhile(_y){\n\t\t\tif(_y&1) _res = _res*_x%_mod;\n\t\t\t_x = _x*_x%_mod;\n\t\t\t_y >>= 1;\n\t\t}\n\t\treturn _res;\n\t}\n\tint add(int _x, int _y){\n\t\tint _res = (_x + _y)%_mod;\n\t\treturn (_res < 0 ? _res + _mod : _res);\n\t}\n\tint inv(int _){\n\t\treturn fp(_, _mod - 2);\n\t}\n\tint mul(int _x, int _y){\n\t\tint _res = (_x * _y)%_mod;\n\t\treturn (_res < 0 ? _res + _mod : _res);\n\t}\n\tvoid setup(int _ = 100003,int _m = 1000000007){\n\t\t_mod = _m;\n\t\tmax_n = _;\n\t\t_f.assign(max_n + 1, 0);\n\t\t_fi.assign(max_n + 1, 0);\n\t\t_f[0] = 1;\n\t\tfor(int i = 1 ; i <= max_n ; i ++) _f[i] = (_f[i - 1] * i)%_mod;\n\t\t_fi[max_n] = inv(_f[max_n]);\n\t\tfor(int i = max_n - 1; i >= 0 ; i --) _fi[i] = (_fi[i + 1] * (i + 1))%_mod;\n\t}\n\tint C(int _x, int _y){\n\t\tif(_x > _y) return 0;\n\t\treturn mul(_f[_y], mul(_fi[_x], _fi[_y - _x]));\n\t}\n\tint P(int _x, int _y){\n\t\treturn mul(_f[_y], _fi[_y - _x]);\n\t}\n\tint CK(int _x, int _y){\n\t\treturn C(_y - 1, _x + _y - 1);\n\t}\n} mt;\nint n, m;\nsigned main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tcin >> n >> m;\n\tmt.setup(1000006, 998244353);\n\tint k = m*3;\n\tint ans = 0;\n\tfor(int i = (m&1) ; i <= min(n, m) ; i += 2)\n\t\tans = mt.add(ans, mt.CK(k - i, n));\n\tcout << ans;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong long modpow(long long a, long long b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (int i = 0; i < 31; i++) {\n\t\tif ((b / (1LL << i)) % 2 == 1) { p *= q; p %= m; }\n\t\tq *= q; q %= m;\n\t}\n\treturn p;\n}\n\nconst int MAX_N = 3000000;\nconst long long mod = 998244353LL;\nlong long fact[MAX_N + 9], factinv[MAX_N + 9];\n\nvoid init() {\n\tfact[0] = 1;\n\tfor (int i = 1; i <= MAX_N; i++) fact[i] = (1LL * i * fact[i - 1]) % mod;\n\tfor (int i = 0; i <= MAX_N; i++) factinv[i] = modpow(fact[i], mod - 2, mod);\n}\n\nlong long ncr(long long n, long long r) {\n\tif (r < 0 || n < r) return 0;\n\treturn (fact[n] * factinv[r] % mod) * factinv[n - r] % mod;\n}\n\nlong long N, M;\n\nlong long solve(long long even, long long odd) {\n\tif (odd > M) return 0;\n\tlong long sousa = (3LL * M - odd) / 2;\n\tlong long sousa2 = sousa - (M + 1LL);\n\tlong long sousa3 = sousa - (M);\n\n\tlong long A1 = ncr(N, even);\n\tlong long B1 = ncr(N + sousa - 1, sousa);\n\tlong long B2 = 1LL * even * ncr(N + sousa2 - 1, sousa2); B2 %= mod;\n\tlong long B3 = 1LL * odd * ncr(N + sousa3 - 1, sousa3); B3 %= mod;\n\n\tlong long S = A1 * (B1 - B2 - B3 + 2LL * mod) % mod;\n\treturn S;\n}\n\nint main() {\n\tcin >> N >> M;\n\tinit();\n\n\tlong long ans = 0;\n\tfor (int i = M; i >= 0; i -= 2) ans += solve(N - i, i);\n\tcout << ans % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1750000, P = 998244353;\nint n, m, fact[maxn], inv[maxn];\n\nint qp(int x, int y) {\n    int z = 1;\n    for (; y; y >>= 1, x = 1LL * x * x % P) {\n        if (y & 1) z = 1LL * z * x % P;\n    }\n    return z;\n}\n\nint C(int x, int y) {\n    return 1LL * fact[x] * inv[x - y] % P * inv[y] % P;\n}\n\nint S(int s) {\n    int ans = 0;\n    for (int i = s & 1; i <= min({n, m, s}); i += 2) {\n        ans = (ans + 1LL * C(n, i) * C((s - i) / 2 + n - 1, n - 1)) % P;\n    }\n    return ans;\n}\n\nint main() {\n    for (int i = fact[0] = inv[0] = 1; i < maxn; i++) {\n        inv[i] = qp(fact[i] = 1LL * i * fact[i - 1] % P, P - 2);\n    }\n    scanf(\"%d %d\", &n, &m);\n    printf(\"%d\\n\", (S(3 * m) - 1LL * n * S(m - 1) % P + P) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef vector<double> VD;\n#define MP make_pair\n#define PB push_back\n#define X first\n#define Y second\n \n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)\n#define ITER(it, a) for(__typeof(a.begin()) it = a.begin(); it != a.end(); ++it)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n#define FILL(a, value) memset(a, value, sizeof(a))\n#define debug(a) cout << #a << \" = \" << a << endl;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1e9 + 47;\nconst LL LINF = INF * INF;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int mod = 998244353;\n\ninline int add(int x, int y)\n{\n\tif (x + y < mod)\n\t\treturn x + y;\n\treturn x + y - mod;\n}\n\ninline int sub(int x, int y)\n{\n\tif (x >= y)\n\t\treturn x - y;\n\treturn x - y + mod;\n}\n\ninline int mult(int x, int y)\n{\n\treturn x * (LL) y % mod;\n}\n\ninline int power(int x, int y)\n{\n\tint r = 1;\n\twhile(y)\n\t{\n\t\tif (y & 1)\n\t\t\tr = mult(r, x);\n\t\tx = mult(x, x);\n\t\ty >>= 1;\n\t}\n\t\n\treturn r;\n}\n\ninline int inverse(int x)\n{\n\treturn power(x, mod - 2);\n}\n\nconst int N = 1 << 22;\nint f[N];\nint inv[N];\n\ninline int C(int n, int m)\n{\n\tint res = f[n];\n\tres = mult(res, inv[m]);\n\tres = mult(res, inv[n - m]);\n\treturn res;\n}\n\ninline int count(int n, int m)\n{\n\treturn C(n - 1 + m, m);\n}\n\nint jebu(int n, int odd, int m)\n{\n\treturn count(n, (3 * m - odd) / 2);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\t//freopen(\"In.txt\", \"w\", stdout);\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tf[0] = 1;\n\tFOR(i, 1, N)\n\t\tf[i] = mult(f[i - 1], i);\n\tFOR(i, 0, N)\n\t\tinv[i] = inverse(f[i]);\n\t\t\n\tint ans = count(n, 3 * m);\n\tint tut = 0;\n\tFOR(i, 2 * m + 1, 3 * m + 1)\n\t\ttut = add(tut, count(n - 1, 3 * m - i));\n\t\t\n\ttut = mult(tut, n);\t\n\tans = sub(ans, tut); \n\t\n\tint odd = 0;\n\tfor(int cnt = m + 2; cnt <= n && cnt <= 3 * m; cnt += 2)\n\t{\n\t\tint coef = C(n, cnt);\n\t\tint here = jebu(n, cnt, m);\t\n\t\todd = add(odd, mult(coef, here));\n\t}\n\t\n\tans = sub(ans, odd);\n\tcout << ans << endl;\n\t\t\n\tcerr << \"Time elapsed: \" << clock() / (double)CLOCKS_PER_SEC << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 998244353\n\nll mod_pow(ll a,ll n){\n  ll res=1;\n  while(n>0){\n    if(n&1)res=res*a%mod;\n    a=a*a%mod;\n    n>>=1;\n  }\n  return res;\n}\n\nll fac[3000010],finv[3000010];\n\nll comb(ll n,ll r){\n  if(n<0||r<0||n<r)return 0;\n  else return (fac[n]*finv[r]%mod)*finv[n-r]%mod;\n}\n\nll calcsumcomb(ll sum,ll n){\n  return comb(sum+n-1,n-1);\n}\n\nll N,M;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  fac[0]=1;\n  rep(i,3000000)fac[i+1]=fac[i]*(i+1)%mod;\n  rep(i,3000001)finv[i]=mod_pow(fac[i],mod-2);\n\n  cin>>N>>M;\n  ll res=0;\n  rep(X,M+1){\n    ll rest=M-X+2*M;\n    if(rest%2!=0)continue;\n    rest/=2;\n    ll add=0;\n    rep(i,2){\n      ll crtrest=rest-M*i;\n      ll crtn=N-i;\n      ll cnt=0;\n      rep(j,2){\n        ll sgn=(j%2==0?+1:mod-1);\n        (cnt+=(calcsumcomb(crtrest-j*M,crtn)*comb(crtn,j)%mod)*sgn%mod)%=mod;\n      }\n      (cnt*=comb(N,i))%=mod;\n      (add+=comb(N-i,X)*cnt%mod)%=mod;\n    }\n    (res+=add)%=mod;\n  }\n  cout<<res<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<queue>\n#include<cmath>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<stack>\n#include<cstdio>\n#include<cstring>\n#include<bitset>\n#include<unordered_map>\n#include<climits>\n#include<fstream>\n#include<time.h>\n#include<cassert>\n\nusing namespace std;\n#define ll long long\n#define ld long double\n#define int long long\n#define all(a) (a).begin(),(a).end()\n#define EPS (1e-13)\n#define fs first\n#define sc second\n#define xx first\n#define yy second.first\n#define zz second.second\n#define P pair<int, int>\n#define Q pair<int, pair<int, int>>\n#define rep(i,n) for(int (i) = 0 ; (i) < (n) ; (i)++)\n#define mkp make_pair\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define crdcomp(b) sort(all((b)));(b).erase(unique(all((b))),(b).end())\nconst int Mod = 1e9 + 7;\nconst int mod = 998244353;\nconst ll Inf = 3 * 1e18;\nconst int inf = 15 * 1e8;\nll read() {\n\tll u, k = scanf(\"%lld\", &u);\n\treturn u;\n}\nll gcd(ll i, ll j) {\n\tif (i > j) swap(i, j);\n\tif (i == 0) return j;\n\treturn gcd(j % i, i);\n}\nll mod_pow(ll x, ll n, ll p) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % p;\n\t\tx = x * x % p;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nll bcount(ll x) {\n\tint sum = 0;\n\tfor (int i = 0; i < 20; i++)\n\t\tif ((1ll << i) & x) sum++;\n\treturn sum;\n}\nconst int fn_ = 2000000;\nll fact_[fn_], comp_[fn_];\nll comb(ll x, ll y, ll mod = Mod) {\n\tif (!fact_[0]) {\n\t\tfact_[0] = 1; comp_[0] = 1;\n\t\tfor (int i = 1; i < fn_; i++) {\n\t\t\tfact_[i] = fact_[i - 1] * i % mod;\n\t\t\tcomp_[i] = mod_pow(fact_[i], mod - 2, mod);\n\t\t}\n\t}\n\tif (x < y) return 0;\n\treturn fact_[x] * comp_[x - y] % mod * comp_[y] % mod;\n}\n//---------------------------------------------------\nint n, m;\nint solve(int i, int n, int m) {\n\treturn comb((m - i) / 2 + m + n - 1, n - 1, mod) * comb(n, i, mod);\n}\nsigned main() {\n\tcin >> n >> m;\n\tint ans = 0;\n\tfor (int i = 0; i <= m && i <= n; i++) {\n\t\tif ((m - i) % 2) continue;\n\t\t(ans += solve(i, n, m)) %= mod;\n\t}\n\tfor (int i = 2 * m + 1; i <= 3 * m; i++) {\n\t\t(ans -= n * comb(3 * m - i + n - 2, n - 2, mod)) %= mod;\n\t}\n\tcout << (ans + mod) % mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\n#include<cstdio>\n#include<cstring>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\ntypedef vector<char> vc;\ntypedef string S;\ntypedef queue<int> qi;\ntypedef pair<ll,ll> P;\ntypedef vector<P> vp;\n//#define sort(a) sort(a.begin(),a.end())\n#define reverse(a) reverse(a.begin(),a.end())\n#define pb push_back\n#define elif else if\n#define unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mp make_pair\n#define fr(i,n)for(ll i=0;i<(n);i++)\n#define ifr(i,n)for(ll i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\nconst int MAX = 510000;\nconst int MOD = 998244353;\n\nll fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (ll i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nll COM(ll n, ll k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nint main() {\n    // 前処理\n    COMinit();\n    ll n,m;cin>>n>>m;\n    ll ans = COM(3*m+n-1,n-1);\n    fr(i,m){\n        ans -= COM(n-2+i,n-2)*n;\n        if (ans < 0){\n            while(ans < 0)ans +=MOD;\n        }\n    }\n    for(ll i = m+1;i<=min(3*m,n);i++){\n        if((3*m-i)%2==0){\n            ans -= COM(n,i)*COM((3*m-i)/2 + n -1,n-1);\n            if (ans < 0){\n                while(ans < 0)ans +=MOD;\n            }\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define int long long\n\nusing namespace std;\n\nconst int N = 1e6+1, M = 1e6+1, F = 6*N, mod = 998244353;\n\nll binpow(ll a, ll s){\n    ll ans = 1;\n    while(s){\n        if(s&1)\n            ans = ans*a%mod;\n        a = a*a%mod;\n        s >>= 1;\n    }\n    return ans;\n}\n\nll inv(ll a){\n    return binpow(a, mod-2);\n}\n\nint n, m;\nll f[F], invf[F];\nvoid init(){\n    f[0] = 1;\n    invf[0] = 1;\n    for(int i = 1; i < N; ++i){\n        f[i] = f[i-1]*i%mod;\n        invf[i] = inv(f[i]);\n    }\n}\n\nll C(int n, int k){\n    if(n < k || k < 0)\n        return 0ll;\n    return f[n]*invf[n-k]%mod*invf[k]%mod;\n}\n\nll C_(int n, int k){\n    return C(n+k-1, k);\n}\n\nmain(){\n    ios_base::sync_with_stdio(false);\n    cout.tie(0);\n    cin.tie(0);\n    init();\n    cin >> n >> m;\n    ll ans = 0;\n    for(int odd = m; odd >= 0; odd -= 2){\n        if(odd > n)\n            continue;\n        ll cnt2 = m+(m-odd)/2;\n        ll res = C(n, odd)*C_(n, cnt2)%mod;\n        res = (res - (C_(n, cnt2-m-1)*C(n-1, odd)%mod + C_(n, cnt2-m)*C(n-1, odd-1)%mod)*n%mod)%mod;\n        ans = (ans+res)%mod;\n    }\n    if(ans < 0) ans += mod;\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,s,t) for(int i=s;i<t;i++)\ntypedef long long ll;\n#define MAXNUM 2055555\nconst ll mod=998244353;\nll fact[MAXNUM],ifact[MAXNUM];\n\nll qpow(ll a, ll b)\n{\n    ll res = 1;\n    while (b)\n    {\n        if (b & 1)\n            res = res * a % mod;\n        a = a * a % mod, b >>= 1;\n    }\n    return res;\n}\nvoid sub(ll &a,ll b)\n{\n    a-=b;\n    if(a<0)a+=mod;\n}\nll getC(int a,int b)\n{\n    return fact[a]*ifact[b]%mod*ifact[a-b]%mod;\n}\nint main()\n{\n    int n,m;scanf(\"%d%d\",&n,&m);\n    fact[0]=ifact[0]=1;\n    rep(i,1,2*m+n+1)fact[i]=fact[i-1]*i%mod,ifact[i]=qpow(fact[i],mod-2);\n    ll res=0;\n    rep(i,0,min(n,m)+1)\n    {\n        if(3*m-i>=0&&(3*m-i)%2==0)\n            (res+=getC(n,i)*getC((3*m-i)/2+n-1,n-1))%=mod;\n        if(m-i>=0&&(m-i)%2==0){\n            sub(res,getC(n,i)*getC((m-i)/2+n-1,n-1)%mod*n%mod);\n            if(n!=i)(res+=getC(n-1,i)*getC((m-i)/2+n-2,n-2)%mod*n)%=mod;\n        }\n    }\n    printf(\"%lld\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\ntemplate<typename T>vector<T> & cset(vector<T> &A,T e=T()){for(auto &I:A){I=e;} return A;}\n\nclass comb{\nprivate:\n    ll mod;\n    ll mx;\n    vector<ll> F;\n    vector<ll> FR;\n    \npublic:\n    comb(ll mod=1000000007,ll mx=100000):mod(mod),mx(mx),F(mx+1,1),FR(mx+1,1){\n        mk_F();\n    }\n    \n    ll mod_pow(ll a,ll x){\n        a%=mod;\n        ll ans=1;\n        while(x>0){\n            if(x&1){ans*=a; ans%=mod;}\n            a*=a;\n            a%=mod;\n            x>>=1;\n        }\n        return ans;\n    }\n    \n    pll Ex_gcd(ll a,ll b){\n        if(b==0){return {1,0};}\n        pll ret=Ex_gcd(b,a%b);\n        ret.F-=a/b*ret.S;\n        return {ret.S,ret.F};\n    }\n    \n    ll prime_R(ll a){\n        return mod_pow(a,mod-2);\n    }\n    \n    ll R(ll a){\n        ll ret=Ex_gcd(a,mod).F;\n        ret%=mod;\n        if(ret<0){ret+=mod;}\n        return ret;\n    }\n    \n    void mk_F(){\n        for(ll i=1;i<=mx;i++){F[i]=F[i-1]*i%mod; FR[i]=R(F[i]);}\n    }\n    \n    ll c(ll n,ll k){\n        if(n<k || k<0 || n<0){return 0;}\n        if(n==k || k==0){return 1;}\n        return F[n]*FR[n-k]%mod*FR[k]%mod;\n    }\n    \n    ll h(ll n,ll k){return c(n+k-1,k-1);}\n    \n    //mod must be prime\n    ll Lucas_C(ll n,ll m){\n        ll ret=1;\n        while(n>0 || m>0){\n            ret*=c(n%mod,m%mod);\n            ret%=mod;\n            n/=mod; m/=mod;\n        }\n        return ret;\n    }\n    \n    ll Stirling(ll n,ll k){\n        ll ret=0;\n        for(ll i=1;i<=k;i++){\n            if((k-i)%2){ret-=c(k,i)*mod_pow(i,n)%mod;}\n            else{ret+=c(k,i)*mod_pow(i,n)%mod;}\n            ret%=mod;\n        }\n        ret*=R(F[k]);\n        ret%=mod;\n        if(ret<0){ret+=mod;}\n        return ret;\n    }\n    \n    ll Bell(ll n,ll k){\n        ll ret=0;\n        for(ll i=1;i<=k;i++){ret+=Stirling(n,i); ret%=mod;}\n        return ret;\n    }\n};\n\ncomb C(998244353,2000000);\n\nint main(){\n    const ll MOD=998244353;\n    ll n,m;\n    cin>>n>>m;\n    ll ans=0;\n    for(int i=0;i<=m;i++){\n        if((3*m-i)%2==0){\n            ans+=C.c(n,i)*C.h((3*m-i)/2,n)%MOD;\n            ans%=MOD;\n        }\n    }\n    for(int i=0;i<m;i++){\n        ll even=3*m-2*m-i-1;\n        if(even>=0 && even%2==0){\n            ans-=C.c(n-1,i)*C.h(even/2,n)%MOD*n%MOD;\n            ans%=MOD;\n        }\n    }\n    for(int i=0;i<=m;i++){\n        ll even=3*m-2*m-i-2;\n        if(even>=0 && even%2==0){\n            ans-=C.c(n-1,i)*C.h(even/2,n)%MOD*n%MOD;\n            ans%=MOD;\n        }\n    }\n    ans%=MOD;\n    if(ans<0){ans+=MOD;}\n    cout<<ans<<endl;\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int BASE = 998244353;\n\nlong long fact[3000300], invFact[3000300];\n\nlong long power(long long x, long long y)\n{\n  if (!y)\n    return 1;\n  long long res = power(x, y >> 1);\n  res = res * res % BASE;\n  if (y & 1)\n    res = res * x % BASE;\n  return res;\n}\n\nlong long c(int n, int k)\n{\n  if (k >= n)\n    return n == k;\n  return fact[n] * invFact[k] % BASE * invFact[n - k] % BASE;\n}\n\nint main()\n{\n  fact[0] = invFact[0] = 1;\n  for (int i = 1; i <= 2500000; i++)\n  {\n    fact[i] = fact[i - 1] * i % BASE;\n    invFact[i] = power(fact[i], BASE - 2);\n  }\n\n  int n, m;\n  cin >> n >> m;\n\n  long long bad = 0;\n  // greatest value <= 2m\n  for (int i = m * 2 + 1; i <= m * 3; i++)\n    bad = (bad + c(m * 3 - i + n - 2, n - 2)) % BASE;\n  bad = bad * n % BASE;\n\n  long long ans = 0;\n  for (int odd = 0; odd <= min(m, n); odd++)\n    if (odd % 2 == m % 2)\n    {\n      int rem = (m * 3 - odd) / 2;\n      ans = (ans + c(rem + n - 1, n - 1) * c(n, odd)) % BASE;\n    }\n\n  cout << (ans - bad + BASE) % BASE << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcount\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\nconst int N = 3e6 + 7;\n\nconst int MOD = 998244353;\nint mod(int n) {\n    n %= MOD;\n    if (n < 0) return n + MOD;\n    else return n;\n}   \nint fp(int a, int p) {\n    int ans = 1, c = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod(ans * c);\n        c = mod(c * c);\n    }   \n    return ans;\n}   \nint dv(int a, int b) { return mod(a * fp(b, MOD - 2)); }\nint f[N], inv[N];\nint C(int n, int k) {\n    return mod(f[n] * mod(inv[k] * inv[n - k]));\n}\nint comp(int n, int k) {\n    return C(n + k - 1, k - 1);\n}   \n\nint get(int sum, int n, int mx) {\n    int ans = 0;\n    for (int i = 0; i <= sum && i <= n && i <= mx; ++i) {\n        if ((i & 1) == (sum & 1)) {\n            ans = mod(ans + C(n, i) * comp((sum - i) / 2, n));\n        }\n    }   \n    return ans;\n}   \n\nint solve(int n, int m) {\n    if (n == 0)\n        return 0;\n    int all = get(3 * m, n, m);\n    int bad = mod(get(m, n, m) - comp(m, n - 1));\n    bad = mod(bad * n);\n    return mod(all - bad);\n}   \n\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n\n    f[0] = 1;\n    for (int i = 1; i < N; ++i)\n        f[i] = mod(f[i - 1] * i);\n    for (int i = 0; i < N; ++i)\n        inv[i] = fp(f[i], MOD - 2);\n\n    int n, m;        \n    cin >> n >> m;\n    cout << solve(n, m) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef _debug\n#define out(i) cout << #i << ' ' << i << ' '\n#else \n#define out(i) //\n#endif\nusing ll = long long;\nusing ull = unsigned long long;\nconst int maxn = 500001;\nconst int maxm = 1000001;\nconst int tomod = 998244353;\nll form(ll a){\n\tll v = a % tomod;\n\treturn v < 0 ? v + tomod : v;\n}\nll inv[maxm], fa[maxm];\nvoid init(){\n\tfa[0] = fa[1] = 1;\n\tinv[0] = inv[1] = 1;\n\tfor(int i = 2;i < maxm;++i){\n\t\tfa[i] = form(fa[i - 1] * (ll)i);\n\t\tinv[i] = form((tomod - tomod / i) * inv[tomod % i]);\n\t}\n\tfor(int i = 2;i < maxm;++i)inv[i] = form(inv[i] * inv[i - 1]);\n}\nll cof(int a, int b){\n\treturn form(fa[a] * form(inv[b] * inv[a - b]));\n} \nll solve(int n, int k, const int max_odd){\n\tll res = 0;\n\tfor(int o = k&1;o <= max_odd;o += 2){\n\t\t// if(((k-o)^1)&1){\n\t\t\tres = form(res + form(\n\t\t\t\tcof(n, o) * \n\t\t\t\tcof((k-o)/2+n-1, n-1)\n\t\t\t));\n\t\t// }\n\t}\n\treturn res;\n}\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tinit();\n\tll k, n;\n\tcin >> n >> k;\n\tll res = solve(n, k * 3, min(n, k));\n\tres -= form(n * solve(n, k, min(n, k)));\n\tres += form(n * solve(n - 1, k, min(n - 1, k)));\n\tcout << form(res) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nconst int MOD = 998244353;\nconst ll INF = 1e18;\nconst int MX = 2000005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    modular(const ll& v) { \n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    \n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n    friend bool operator<(const modular& a, const modular& b) { return a.val < b.val; }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular pow(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { \n        auto i = invGeneral(a.val,MOD); assert(i != -1);\n        return i;\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<int SZ> struct Combo {\n    mi smallInv[SZ], fac[SZ], ifac[SZ]; \n    vpi factors; vi cnt[SZ];\n\n    void genInv() {\n        if (sz(factors) == 1 && factors[0].s == 1) {\n            F0R(i,2) smallInv[i] = i;\n            FOR(i,2,SZ) { // use only O(SZ) operations for MOD a prime\n                int x = (MOD+i-1)/i;\n                smallInv[i] = smallInv[i*x-MOD]*x;\n            }\n        } else {\n            F0R(i,SZ) {\n                int x = invGeneral(i,MOD);\n                if (x == -1) smallInv[i] = 0;\n                else smallInv[i] = x;\n            }\n        }\n    }\n    \n    void init() {\n        // factors = factor(MOD); \n        factors = {{MOD,1}}; \n        genInv(); cnt[0] = vi(sz(factors)); fac[0] = ifac[0] = 1;\n        FOR(i,1,SZ) {\n            cnt[i] = cnt[i-1]; int I = i;\n            F0R(j,sz(factors)) while (I % factors[j].f == 0)\n                I /= factors[j].f, cnt[i][j] ++;\n            fac[i] = fac[i-1]*I; ifac[i] = ifac[i-1]*smallInv[I];\n        }\n    }\n\n    mi comb(int a, int b) {\n        if (a < b || b < 0) return 0;\n        auto tmp = fac[a]*ifac[b]*ifac[a-b];\n        F0R(i,sz(factors)) {\n            int t = cnt[a][i]-cnt[a-b][i]-cnt[b][i];\n            tmp *= pow(mi(factors[i].f),t);\n        }\n        return tmp;\n    }\n};\n\nint N,M;\nCombo<MX> C;\n\nmi solve(int a, int b) {\n\tmi res = 0;\n\tF0R(i,min(a,M)+1) if ((b-i)%2 == 0) {\n\t\tres += C.comb(a,i)*C.comb((b-i)/2+a-1,a-1);\t\n\t}\n\treturn res;\n}\n\nint main() {\n\tC.init();\n    setIO(); re(N,M);\n    // ps(\"HUH\",solve(N,3*M));\n    ps(solve(N,3*M)-N*(solve(N,M)-solve(N-1,M)));\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "/*Lucky_Glass*/\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\nconst int N=3e6;\nconst ll MOD=998244353;\n\nll Efac[N+3],Einv[N+3];\n\nll QPow(ll Va,ll Vb){\n\tll Rr=1;\n\twhile(Vb){\n\t\tif(Vb&1) Rr=Va*Rr%MOD;\n\t\tVa=Va*Va%MOD;\n\t\tVb>>=1;\n\t}\n\treturn Rr;\n}\nvoid Process(){\n\tEfac[0]=1;for(int i=1;i<=N;i++) Efac[i]=Efac[i-1]*i%MOD;\n\tEinv[N]=QPow(Efac[N],MOD-2);for(int i=N-1;i>=0;i--) Einv[i]=Einv[i+1]*(i+1)%MOD;\n}\nll fC(int Va,int Vb){return Efac[Vb]*Einv[Va]%MOD*Einv[Vb-Va]%MOD;}\nint main(){\n\tProcess();\n\tint n,m;scanf(\"%d%d\",&n,&m);\n\tll Vans=fC(n-1,3*m+n-1);\n\tVans=(Vans-fC(n-1,m+n-2)*n%MOD+MOD)%MOD;\n\tfor(int i=m+1;i<=n && i<=3*m;i++)\n\t\tif((3*m-i)%2==0){\n\t\t\tVans=(Vans-fC(i,n)*fC(n-1,(3*m-i)/2+n-1)%MOD+MOD)%MOD;\n\t\t}\n\tprintf(\"%lld\\n\",(Vans%MOD+MOD)%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define mit map<int,int>::iterator\n#define sit set<int>::iterator\n#define itrm(g,x) for(mit g=x.begin();g!=x.end();g++)\n#define itrs(g,x) for(sit g=x.begin();g!=x.end();g++)\n#define ltype int\n#define rep(i,j,k) for(ltype(i)=(j);(i)<=(k);(i)++)\n#define rap(i,j,k) for(ltype(i)=(j);(i)<(k);(i)++)\n#define per(i,j,k) for(ltype(i)=(j);(i)>=(k);(i)--)\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mpr make_pair\n#define pb push_back\n#define fastio ios::sync_with_stdio(false)\nconst int inf=0x3f3f3f3f,mod=998244353;\nconst double pi=3.1415926535897932,eps=1e-6;\nvoid chmax(int &x,int y){if(x < y) x = y;}\nvoid chmin(int &x,int y){if(x > y) x = y;}\nint n,m,lim;\nint fac[2500005],inv[2500005];\nint qpow(int x,int y){\n    int res = 1;\n    while(y){\n        if(y & 1) res = (ll)res * x % mod;\n        x = (ll)x * x % mod;\n        y >>= 1;\n    }\n    return res;\n}\nint C(int a,int b){\n    if(b < 0 || a < 0 || a < b) return 0;\n    return (ll)fac[a] * inv[b] % mod * inv[a - b] % mod;\n}\nint F(int a,int b){\n    return C(a + b - 1, a - 1);\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    lim = n + 3 * m;\n    fac[0] = 1;\n    rep(i,1,lim) fac[i] = (ll)fac[i - 1] * i % mod;\n    inv[lim] = qpow(fac[lim], mod - 2);\n    per(i,lim-1,0) inv[i] = (ll)inv[i + 1] * (i + 1) % mod;\n\n    int ans = F(n, 3 * m);\n    rep(x,m + m + 1, 3 * m) ans = (ans - (ll)F(n - 1,3 * m - x) * n % mod + mod) % mod;\n\n    rep(x,m + 1,n) if((3 * m - x) % 2 == 0) ans = (ans - (ll)F(n, (3 * m - x) / 2) * C(n,x) % mod + mod) % mod;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\nusing ll = int64_t;\n\nconstexpr ll MOD = 998244353;\n\nclass Combination {\npublic:\n    Combination(ll max_num) {\n        fact_.resize(max_num + 1, 1);\n        inv_fact_.resize(max_num + 1, 1);\n        for (ll i = 2; i <= max_num; i++) {\n            fact_[i] = i * fact_[i - 1] % MOD;\n            inv_fact_[i] = MODpow(fact_[i], MOD - 2);\n            assert(fact_[i] * inv_fact_[i] % MOD == 1);\n        }\n    }\n    ll operator()(ll n, ll m) const {\n        if (m < 0 || m > n) return 0;\n        return fact_[n] * inv_fact_[n - m] % MOD * inv_fact_[m] % MOD;\n    }\nprivate:\n    ll MODpow(ll n, ll m) const {\n        ll result = 1;\n        while (m) {\n            if (m % 2 == 1) {\n                result *= n;\n                result %= MOD;\n            }\n\n            m /= 2;\n            n *= n;\n            n %= MOD;\n        }\n\n        return result;\n    }\n\n    vector<ll> fact_, inv_fact_;\n} comb(3e6);\n\n//サイズがnの非負整数配列で総和がsであり奇数の要素がm個以下であるものの場合の数\nll f(ll n, ll s, ll m) {\n    ll result = 0;\n\n    //奇数の数を全探索\n    for (ll a = s % 1; a <= min(n, m); a += 2) {\n        //まず奇数になるところを決める\n        ll curr_num = comb(n, a);\n\n        //上で選んだ箇所に1を入れたとする\n        //残りs - aをn個の要素にそれぞれ偶数となるように分ければ良い\n        //そのような分け方は結局(s - a) / 2をn個に分ける\n        //要素と仕切りのやつ\n        (curr_num *= comb((s - a) / 2 + n - 1, n - 1)) %= MOD;\n\n        (result += curr_num) %= MOD;\n    }\n\n    return result;\n}\n\nint main() {\n    ll N, M;\n    cin >> N >> M;\n\n    //最大値が2Mを超えないという条件を無視した数\n    ll ans = f(N, 3 * M, M);\n\n    //最大値が2Mを超えるものの数を引く\n    //  2Mを超えるのは1箇所。その1箇所が左端として、そこから2Mを引いた配列を考える\n    //  その配列はN要素で合計がMで奇数がM個以下\n    //  しかし左端が0になってはいけないのでN - 1要素で合計Mで奇数がM個以下となるものを引く\n    ll illegal = (f(N, M, M) + MOD - f(N - 1, M, M)) % MOD;\n\n    //2Mを超えるものがどこに来るかはN通りあり得るのでN倍する\n    (ans += MOD - N * illegal % MOD) %= MOD;\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define MP make_pair\n#define test cout<<\"test\"<<endl;\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef long double ld;\n//const ll MOD = 1e9+7;\nconst ll MOD = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\nvoid chmin(ll &a,ll b){if(a>b)a=b;}\nvoid chmax(ll &a,ll b){if(a<b)a=b;}\nvoid pmod(ll &a,ll b){a=(a+b)%MOD;}\nvoid pmod(ll &a,ll b,ll c){a=(b+c)%MOD;}\nvoid qmod(ll &a,ll b){a=(a*b)%MOD;}\nvoid qmod(ll &a,ll b,ll c){a=(b*c)%MOD;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\nvoid ans(bool x,ll y,ll z){if(x)cout<<y<<endl;else cout<<z<<endl;}\nvoid ans(bool x,string y,string z){if(x)cout<<y<<endl;else cout<<z<<endl;}   \nvoid debug(vector<vector<ll>>v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j]<<\" \";cout<<endl;}};\nvoid debug(vector<string>v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\nll gcd(ll x,ll y){ll r;while((r=x%y)!=0){x=y;y=r;}return y;}\n//m.emplace(x,0).fi->second++;\n\nvector<ll> fac(3000001); //n!(mod MOD)\nvector<ll> ifac(3000001); //k!^{M-2} (mod MOD)\nll mpow(ll x, ll n){ //x^n(mod M)\n    ll ans = 1;\n    while(n != 0){\n        if(n&1) ans = ans*x % MOD;\n        x = x*x % MOD;\n        n = n >> 1;\n    }\n    return ans;\n}\n\nll comb(ll a, ll b){ //aCb%mod\n    if(a == 0 && b == 0)return 1;\n    if(a < b || a < 0)return 0;\n    ll tmp = ifac[a-b]* ifac[b] % MOD;\n    return tmp * fac[a] % MOD;\n}\n\nint main(){\n  ll i,j,o;\n  ll res=0,res1=INF,res2=-INF,buf=0;\n  bool judge = true;\n  ll n,m;cin>>n>>m;\n  fac[0] = 1;\n  ifac[0] = 1;\n  for(ll i = 0; i<3000001; i++){\n      fac[i+1] = fac[i]*(i+1) % MOD; // n!(mod MOD)\n      ifac[i+1] = ifac[i]*mpow(i+1, MOD-2) % MOD; // k!^{MOD-2} (mod MOD)\n  }\n  res=comb(n+3*m-1,3*m);\n  ll suml=0,sumr=0;\n  for(i=0;i<=m-1;i++){\n    pmod(suml,(n*(comb(n+i-2,i)))%MOD);\n  }\n  ll right=max(0ll,n-2*m);\n  for(i=0;i<right;i++){\n    pmod(sumr,(comb(n,i)*comb(3*m-1,3*m-n+i))%MOD);\n  }\n  //cout<<res spa suml spa sumr<<endl;\n  res-=suml;\n  if(res<0)res+=MOD;\n  res-=sumr;\n  if(res<0)res+=MOD;\n  cout<<res<<endl;\n\n\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int int64_t\n#define rep(i, a, b) for(int i = a; i < b; ++i)\n\nint debug = 1;\n\nconst int N = 2e6;\nint mod = 998244353;\n\nint n, m;\nint fac[N], c[3][N];\n\nint add(int &a, int b) {\n    a += b;\n    if (a >= mod) a -= mod;\n    return a;\n}\n\nint sub(int a, int b) {\n    a -= b;\n    if (a < 0) a += mod;\n    return a;\n}\n\nint mul(int a, int b) {\n    return a * b % mod;\n}\n\nint pw(int x, int p) {\n    if (p == 0) return 1;\n    if (p % 2) return pw(x, p - 1) * x % mod;\n    int pp = pw(x, p / 2);\n    return pp * pp % mod;\n}\n\nint rev(int a) {\n    return pw(a, mod - 2);\n}\n\nvoid precalc() {\n    fac[0] = 1;\n    rep(i, 1, N) {\n        fac[i] = mul(fac[i - 1], i);\n    }\n    rep(i, n - 2, N) {\n        if (i >= n - 1)\n            c[1][i] = mul(fac[i], mul(rev(fac[n - 1]), rev(fac[i - n + 1])));\n        c[2][i] = mul(fac[i], mul(rev(fac[n - 2]), rev(fac[i - n + 2])));\n    }\n}\n\nint C(int n, int k) {\n    return mul(fac[n], mul(rev(fac[k]), rev(fac[n - k])));\n}\n\nint f(int s, int param) {\n    return c[param][n - param + s];\n}\n\nint g(int s, int param) {\n    int res = 0;\n    rep(a, 0, m + 1) {\n        if ((s - a) % 2 == 0 && (s - a) >= 0) {\n            res = add(res, mul(f((s - a) / 2, param), C(n+1-param, a)));\n        }\n    }\n    return res;\n}\n\nmain() {\n    cin >> n >> m;\n    precalc();\n    int ans = sub(g(3 * m, 1), mul(n, sub(g(m, 1), g(m, 2))));\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region kyopro_template\n#include <bits/stdc++.h>\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define each(x, v) for (auto &x : v)\n#define all(v) (v).begin(), (v).end()\n#define sz(v) ((int)(v).size())\n#define mem(a, val) memset(a, val, sizeof(a))\n#define ini(...)   \\\n  int __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define inl(...)         \\\n  long long __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define ins(...)      \\\n  string __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define inc(...)    \\\n  char __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define in2(s, t)                           \\\n  for (int i = 0; i < (int)s.size(); i++) { \\\n    in(s[i], t[i]);                         \\\n  }\n#define in3(s, t, u)                        \\\n  for (int i = 0; i < (int)s.size(); i++) { \\\n    in(s[i], t[i], u[i]);                   \\\n  }\n#define in4(s, t, u, v)                     \\\n  for (int i = 0; i < (int)s.size(); i++) { \\\n    in(s[i], t[i], u[i], v[i]);             \\\n  }\n#define rep(i, N) for (long long i = 0; i < (long long)(N); i++)\n#define repr(i, N) for (long long i = (long long)(N)-1; i >= 0; i--)\n#define rep1(i, N) for (long long i = 1; i <= (long long)(N); i++)\n#define repr1(i, N) for (long long i = (N); (long long)(i) > 0; i--)\nusing namespace std;\nvoid solve();\nusing ll = long long;\ntemplate <class T = ll>\nusing V = vector<T>;\nusing vi = vector<int>;\nusing vl = vector<long long>;\nusing vvi = vector<vector<int>>;\nusing vd = V<double>;\nusing vs = V<string>;\nusing vvl = vector<vector<long long>>;\nusing P = pair<long long, long long>;\nusing vp = vector<P>;\nusing pii = pair<int, int>;\nusing vpi = vector<pair<int, int>>;\nconstexpr int inf = 1001001001;\nconstexpr long long infLL = (1LL << 61) - 1;\ntemplate <typename T, typename U>\ninline bool amin(T &x, U y) {\n  return (y < x) ? (x = y, true) : false;\n}\ntemplate <typename T, typename U>\ninline bool amax(T &x, U y) {\n  return (x < y) ? (x = y, true) : false;\n}\ntemplate <typename T, typename U>\nll ceil(T a, U b) {\n  return (a + b - 1) / b;\n}\nconstexpr ll TEN(int n) {\n  ll ret = 1, x = 10;\n  while (n) {\n    if (n & 1) ret *= x;\n    x *= x;\n    n >>= 1;\n  }\n  return ret;\n}\n\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\ntemplate <typename T, typename U>\nistream &operator>>(istream &is, pair<T, U> &p) {\n  is >> p.first >> p.second;\n  return is;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  int s = (int)v.size();\n  for (int i = 0; i < s; i++) os << (i ? \" \" : \"\") << v[i];\n  return os;\n}\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &v) {\n  for (auto &x : v) is >> x;\n  return is;\n}\nvoid in() {}\ntemplate <typename T, class... U>\nvoid in(T &t, U &... u) {\n  cin >> t;\n  in(u...);\n}\nvoid out() { cout << \"\\n\"; }\ntemplate <typename T, class... U>\nvoid out(const T &t, const U &... u) {\n  cout << t;\n  if (sizeof...(u)) cout << \" \";\n  out(u...);\n}\ntemplate <typename T>\nvoid die(T x) {\n  out(x);\n  exit(0);\n}\n\n#ifdef NyaanDebug\n#include \"NyaanDebug.h\"\n#define trc(...)                   \\\n  do {                             \\\n    cerr << #__VA_ARGS__ << \" = \"; \\\n    dbg_out(__VA_ARGS__);          \\\n  } while (0)\n#define trca(v, N)       \\\n  do {                   \\\n    cerr << #v << \" = \"; \\\n    array_out(v, N);     \\\n  } while (0)\n#define trcc(v)                             \\\n  do {                                      \\\n    cerr << #v << \" = {\";                   \\\n    each(x, v) { cerr << \" \" << x << \",\"; } \\\n    cerr << \"}\" << endl;                    \\\n  } while (0)\n#else\n#define trc(...)\n#define trca(...)\n#define trcc(...)\nint main() { solve(); }\n#endif\n\nstruct IoSetupNya {\n  IoSetupNya() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    cerr << fixed << setprecision(7);\n  }\n} iosetupnya;\n\ninline int popcnt(unsigned long long a) { return __builtin_popcountll(a); }\ninline int lsb(unsigned long long a) { return __builtin_ctzll(a); }\ninline int msb(unsigned long long a) { return 63 - __builtin_clzll(a); }\ntemplate <typename T>\ninline int getbit(T a, int i) {\n  return (a >> i) & 1;\n}\ntemplate <typename T>\ninline void setbit(T &a, int i) {\n  a |= (1LL << i);\n}\ntemplate <typename T>\ninline void delbit(T &a, int i) {\n  a &= ~(1LL << i);\n}\ntemplate <typename T>\nint lb(const vector<T> &v, const T &a) {\n  return lower_bound(begin(v), end(v), a) - begin(v);\n}\ntemplate <typename T>\nint ub(const vector<T> &v, const T &a) {\n  return upper_bound(begin(v), end(v), a) - begin(v);\n}\ntemplate <typename T>\nvector<T> mkrui(const vector<T> &v) {\n  vector<T> ret(v.size() + 1);\n  for (int i = 0; i < int(v.size()); i++) ret[i + 1] = ret[i] + v[i];\n  return ret;\n};\n\ntemplate <typename T>\nvector<T> mkuni(const vector<T> &v) {\n  vector<T> ret(v);\n  sort(ret.begin(), ret.end());\n  ret.erase(unique(ret.begin(), ret.end()), ret.end());\n  return ret;\n}\n\ntemplate <typename F>\nvector<int> mkord(int N, F f) {\n  vector<int> ord(N);\n  iota(begin(ord), end(ord), 0);\n  sort(begin(ord), end(ord), f);\n  return ord;\n}\n\n#pragma endregion\n\nconstexpr long long MOD = /** 1000000007;  //*/ 998244353;\n\ntemplate <int mod>\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if ((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if ((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int)(1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while (b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while (n > 0) {\n      if (n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) { return os << p.x; }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt<mod>(t);\n    return (is);\n  }\n\n  static constexpr int get_mod() { return mod; }\n};\nusing mint = ModInt<MOD>;\nusing vm = vector<mint>;\n\nvector<ll> fac, finv, inv;\nvoid cominit(int MAX) {\n  MAX++;\n  fac.resize(MAX, 0);\n  finv.resize(MAX, 0);\n  inv.resize(MAX, 0);\n  fac[0] = fac[1] = finv[0] = finv[1] = inv[1] = 1;\n  for (int i = 2; i < MAX; i++) {\n    fac[i] = fac[i - 1] * i % MOD;\n    inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n    finv[i] = finv[i - 1] * inv[i] % MOD;\n  }\n}\n// nCk combination\ninline long long COM(int n, int k) {\n  if (n < k || k < 0 || n < 0)\n    return 0;\n  else\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n// nPk permutation\ninline long long PER(int n, int k) {\n  if (n < k || k < 0 || n < 0)\n    return 0;\n  else\n    return (fac[n] * finv[n - k]) % MOD;\n}\n// nHk homogeneous polynomial\ninline long long HGP(int n, int k) {\n  if (n == 0 && k == 0)\n    return 1;  // depending on problem?\n  else if (n < 1 || k < 0)\n    return 0;\n  else\n    return fac[n + k - 1] * (finv[k] * finv[n - 1] % MOD) % MOD;\n}\n\nvoid solve() {\n  inl(N, M);\n  cominit(3030303);\n\n  mint ans = 0;\n  for (int l = 0; l <= M; l++) {\n    if (l % 2 != M % 2) continue;\n    if (l > N) break;\n    // 1を固定\n    // 2の個数\n    ll c2 = M + (M - l) / 2;\n    // 全部\n\n    mint cur = COM(c2 + N - 1, N - 1);\n    cur -= mint(l) * COM(c2 - M + N - 1, N - 1);\n    cur -= mint(N-l) * COM(c2 - M - 1 + N - 1, N - 1);\n    ans += cur * COM(N, l);\n  }\n  out(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <unordered_map>\n#include <numeric>\n#include <functional>\n#include <limits.h>\n#include <utility>\n#include <stack>\n\nusing namespace std;\n\n#define fs first\n#define sc second\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst ll mod = 998244353;\nll fact[5010200];\nll invfact[5010200];\n\ninline ll take_mod(ll a){\n    return (a % mod + mod) % mod;\n}\n\ninline ll add(ll a, ll b){\n    return take_mod(a+b);\n}\n\ninline ll sub(ll a, ll b){\n    return take_mod(a + mod -b);\n}\n\n\ninline ll mul(ll a, ll b){\n    return take_mod(a * b);\n}\n\ninline ll pow(ll x, ll n){\n    ll res = 1LL;\n    while(n > 0){\n        if(n & 1) res = mul(res, x);\n        x = mul(x, x);\n        n >>= 1;\n    }\n    return res;\n}\n\nll mod_inv(ll x){\n    return pow(x, mod-2);\n}\n\n// nは上限\nvoid make_fact(ll n){\n    fact[0] = 1;\n    ll res = 1;\n    for(int i = 1; i <= n; i++){\n        fact[i] = res;\n        res = mul(res, i+1);\n    }\n}\n\n// nは上限\nvoid make_invfact(ll n){\n    invfact[0] = 1;\n    invfact[n] = mod_inv(fact[n]);\n    for(int i = n-1; i >= 1; i--){\n        invfact[i] = mul(invfact[i + 1], i + 1);\n    }\n}\n\nll perm(ll n, ll k){\n    return mul(fact[n], invfact[n-k]);\n}\n\nll comb(ll n, ll k){\n    if(k == 0){\n        return 1;\n    }\n    return mul(mul(fact[n], invfact[n-k]), invfact[k]);\n}\n\n\nint main(){\n    ll N, M;\n    cin >> N >> M;\n    make_fact(5010000);\n    make_invfact(5010000);\n\n    ll res = 1;\n    res = mul(res, comb(3 * M + N - 1, N-1));\n\n    for(ll i = 2 * M + 1; i <= 3 * M; i++){\n        ll remain = 3 * M - i;\n        ll tmp = mul(N, comb(N + remain - 2, N-2));\n        res = sub(res, tmp);\n    }\n    for(ll x = M + 1; x <= N; x++){\n        if(3 * M - x < 0 || (3 * M - x) % 2 == 1){\n            continue;\n        }\n        if(x > N){\n            continue;\n        }\n        ll ball = (3 * M - x) / 2;\n\n        ll tmp = mul(comb(N, x), comb(ball + N - 1, N-1));\n        res = sub(res, tmp);\n    }\n\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n/*\n * Author       : YangDavid\n * Created Time : 2019年07月21日 星期日 21时41分16秒\n */\n\n#include<bits/stdc++.h>\n#define rep(i, n) for(int i = 1; i <= n; ++i)\n#define int ll\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int maxn = 7010101, MOD = 998244353;\nint muln(int x, int y) { return 1LL * x * y % MOD; }\nint qpow(int x, int y) {\n    int ret = 1;\n    for(; y; y >>= 1, x = muln(x, x))\n        if(y & 1) ret = muln(ret, x);\n    return ret;\n}\nint inv(int x) { return qpow(x, MOD - 2); }\nint mo(int x) {\n    if(x >= MOD) return x - MOD;\n    if(x < 0) return x + MOD;\n    return x;\n}\nint fac[maxn], ifac[maxn], n, m;\nint C(int x, int y) {\n    if(x < y) return 0;\n    return muln(fac[x], muln(ifac[y], ifac[x-y]));\n}\n\nsigned main() {\n    fac[0] = ifac[0] = 1;\n    for(int i = 1; i <= 6000020; ++i) {\n        fac[i] = muln(fac[i - 1], i);\n    }\n    ifac[6000020] = inv(fac[6000020]);\n    for(int i = 6000019; i >= 0; --i)\n        ifac[i] = muln(ifac[i + 1], i + 1);\n\n    scanf(\"%lld%lld\", &n, &m);\n    ll ans1 = C(3 * m + n - 1, n - 1);\n    ll ans2 = muln(n, C(n+m-2, n-1));\n    ll ans3 = 0, ans4 = 0;\n\n    for(int k = m + 1; k <= 3 * m; ++k) {\n        if((3 * m - k) & 1) continue;\n        if(k > n) break;\n        ans3 = mo(ans3 + muln(C(n, k), C((3*m-k)/2+n-1, n-1)));\n    }\n    ll ans = ans1 - ans2 - ans3 - ans4;\n    //printf(\"%lld %lld %lld %lld\\n\", ans1, ans2, ans3, ans4);\n    while(ans < 0) ans += MOD;\n    while(ans >= MOD) ans -= MOD;\n    printf(\"%lld\\n\", ans);\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define mp make_pair\n#define what_is(x) cerr << #x << \" is \" << x << endl;\n\ntypedef tree<\n        int,\n        null_type,\n        less<int>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\n\nconst int p = 998244353;\n\n\nint mul(int a, int b) {\n    return (1LL * a%p * b%p) % p;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    s = s%p;\n    if (s<0) s+=p;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a-b);\n    s = s%p;\n    if (s<0) s+=p;\n    return s;\n}\n\nint po(int a, int deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, p-2);\n}\n\nvector<int> Z(vector<int> s)\n{\n    int n = s.size();\n    vector<int> z(n);\n    int L = 0, R = 0;\n    for (int i = 1; i < n; i++) {\n        if (i > R) {\n            L = R = i;\n            while (R < n && s[R-L] == s[R]) R++;\n            z[i] = R-L; R--;\n        } else {\n            int k = i-L;\n            if (z[k] < R-i+1) z[i] = z[k];\n            else {\n                L = i;\n                while (R < n && s[R-L] == s[R]) R++;\n                z[i] = R-L; R--;\n            }\n        }\n    }\n    return z;\n}\n\nmt19937 rnd(time(0));\n/*\nstruct Line {\n    mutable ll k, m, p;\n    bool operator<(const Line& o) const { return k < o.k; }\n    bool operator<(ll x) const { return p < x; }\n};\n\nstruct CHT : multiset<Line, less<>> {\n    // (for doubles, use inf = 1/.0, div(a,b) = a/b)\n    const ll inf = LLONG_MAX;\n    ll div(ll a, ll b) { // floored division\n        return a / b - ((a ^ b) < 0 && a % b); }\n    bool isect(iterator x, iterator y) {\n        if (y == end()) { x->p = inf; return false; }\n        if (x->k == y->k) x->p = x->m > y->m ? inf : -inf;\n        else x->p = div(y->m - x->m, x->k - y->k);\n        return x->p >= y->p;\n    }\n    void add(ll k, ll m) {\n        auto z = insert({k, m, 0}), y = z++, x = y;\n        while (isect(y, z)) z = erase(z);\n        if (x != begin() && isect(--x, y)) isect(x, y = erase(y));\n        while ((y = x) != begin() && (--x)->p >= y->p)\n            isect(x, erase(y));\n    }\n    ll query(ll x) {\n        assert(!empty());\n        auto l = *lower_bound(x);\n        return l.k * x + l.m;\n    }\n};\n*/\n\nconst int N = 3000010;\n\nvector<int> facs(N);\nvector<int> invfacs(N);\n\nvoid init() {\n    facs[0] = 1;\n    for (int i = 1; i < N; i++) facs[i] = mul(facs[i - 1], i);\n    invfacs[N - 1] = inv(facs[N - 1]);\n    for (int i = N - 2; i >= 0; i--) invfacs[i] = mul(invfacs[i + 1], i + 1);\n}\n\n\nint C(int n, int k) {\n    return mul(facs[n], mul(invfacs[n-k], invfacs[k]));\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n\n    init();\n    int n, m;\n    cin>>n>>m;\n    int overall = 3*m;\n    int res = 0;\n    for (int odd = 0; odd<=min(m, n); odd++) if (odd%2 == overall%2)\n    {\n        res = add(res, mul(C(n, odd), C(n - 1 + (overall-odd)/2, n-1)));\n    }\n    overall = m-1;\n    for (int odd = 0; odd<=min(m-1, n-1); odd++) if (odd%2 == overall%2)\n    {\n        res = sub(res, mul(mul(C(n-1, odd), n), C(n - 2 + (overall-odd)/2, n-2)));\n    }\n    overall = m-2;\n    if (overall<0) {cout<<res; return 0;}\n    for (int odd = 0; odd<=min(m-2, n); odd++) if (odd%2 == overall%2)\n    {\n        res = sub(res, mul(mul(C(n, odd), n), C(n - 1 + (overall-odd)/2, n-1)));\n    }\n    cout<<res;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n - 1); i >= 0; i--)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) int(x.size())\n#define get_unique(x) x.erase(unique(all(x)), x.end());\ntypedef long long ll;\ntypedef complex<double> Complex;\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\nconst ll LINF = 1e18;\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\nvector<T> make_vec(size_t a) {\n    return vector<T>(a);\n}\ntemplate <class T, class... Ts>\nauto make_vec(size_t a, Ts... ts) {\n    return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, vector<T> v) {\n    for (int i = 0; i < sz(v); i++) {\n        os << v[i];\n        if (i < sz(v) - 1) os << \" \";\n    }\n    return os;\n}\nstruct NumberTheoreticTransform {\n    ll ext_gxd(ll a, ll b, ll& x, ll& y) {\n        if (b == 0) {\n            x = 1;\n            y = 0;\n            return a;\n        }\n        ll q = a / b;\n        ll g = ext_gxd(b, a - q * b, x, y);\n        ll z = x - q * y;\n        x = y;\n        y = z;\n        return g;\n    }\n\n    ll modinv(ll a, ll m) {\n        ll x, y;\n        ext_gxd(a, m, x, y);\n        x %= m;\n        if (x < 0) x += m;\n        return x;\n    }\n\n    ll modpow(ll a, ll n, ll m) {\n        ll ret = 1;\n        ll now = a;\n        while (n > 0) {\n            if (n % 2 == 1) ret = ret * now % m;\n            now = now * now % m;\n            n /= 2;\n        }\n        return ret;\n    }\n\n    void ntt(vector<ll>& a, ll mod, bool inv = 0) {\n        const int n = sz(a);\n        assert((n & (n - 1)) == 0);\n\n        const ll g = 3;\n        ll h = modpow(g, (mod - 1) / n, mod);\n        if (inv) h = modinv(h, mod);\n\n        int i = 0;\n        for (int j = 1; j < n - 1; j++) {\n            for (int k = n >> 1; k > (i ^= k); k >>= 1) {\n            };\n            if (j < i) swap(a[i], a[j]);\n        }\n\n        for (int m = 1; m < n; m *= 2) {\n            const int m2 = m * 2;\n            const ll base = modpow(h, n / m2, mod);\n            ll w = 1;\n            for (int x = 0; x < m; x++) {\n                for (int s = x; s < n; s += m2) {\n                    ll u = a[s];\n                    ll d = a[s + m] * w % mod;\n                    a[s] = u + d;\n                    if (a[s] >= mod) a[s] -= mod;\n                    a[s + m] = u - d;\n                    if (a[s + m] < 0) a[s + m] += mod;\n                }\n                w = w * base % mod;\n            }\n        }\n\n        for (auto& x : a) {\n            if (x < 0) x += mod;\n        }\n\n        if (inv) {\n            const int n_inv = modinv(n, mod);\n            for (auto& x : a) x = x * n_inv % mod;\n        }\n    }\n\n    vector<ll> convolution(const vector<ll>& a, vector<ll>& b, ll m,\n                           ll mod = 998244353) {\n        int ntt_size = 1;\n        while (ntt_size < sz(a) + sz(b)) ntt_size <<= 1;\n\n        vector<ll> _a = a, _b = b;\n        _a.resize(ntt_size);\n        _b.resize(ntt_size);\n\n        ntt(_a, mod);\n        ntt(_b, mod);\n\n        for (int i = 0; i < ntt_size; i++) {\n            _a[i] *= _b[i];\n            _a[i] %= mod;\n        }\n\n        ntt(_a, mod, 1);\n        if (sz(_a) > m) _a.resize(m);\n        return _a;\n    }\n    vector<ll> convpow(vector<ll>& a, int k, ll m) {\n        vector<ll> ret(sz(a));\n        ret[0] = 1;\n        auto now = a;\n        while (k) {\n            if (k & 1) ret = convolution(ret, now, m);\n            now = convolution(now, now, m);\n            k >>= 1;\n        }\n        return ret;\n    }\n} ntt;\nstruct modint {\n    ll x;\n    modint(ll x = 0) : x((x % MOD + MOD) % MOD) {\n    }\n    ll value() const {\n        return x;\n    }\n    modint operator-() const {\n        return modint(-x);\n    }\n    modint& operator+=(const modint a) {\n        if ((x += a.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    modint& operator-=(const modint a) {\n        if ((x += MOD - a.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    modint& operator*=(const modint a) {\n        (x *= a.x) %= MOD;\n        return *this;\n    }\n    modint operator+(const modint a) const {\n        modint res(*this);\n        return res += a;\n    }\n    modint operator-(const modint a) const {\n        modint res(*this);\n        return res -= a;\n    }\n    modint operator*(const modint a) const {\n        modint res(*this);\n        return res *= a;\n    }\n    modint pow(ll t) const {\n        if (t == 0) return 1;\n        modint a = pow(t >> 1);\n        a *= a;\n        if (t % 2 == 1) a *= *this;\n        return a;\n    }\n    modint inv() const {\n        return pow(MOD - 2);\n    }\n    modint& operator/=(const modint a) {\n        return (*this) *= a.inv();\n    }\n    modint operator/(const modint a) const {\n        modint res(*this);\n        return res /= a;\n    }\n};\nostream& operator<<(ostream& os, const modint& x) {\n    os << x.value();\n    return os;\n}\nstruct combination {\n    vector<modint> fact, ifact;\n    combination(int n) : fact(n + 1), ifact(n + 1) {\n        assert(n < MOD);\n        fact[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            fact[i] = fact[i - 1] * i;\n        }\n        ifact[n] = fact[n].inv();\n        for (int i = n; i >= 1; i--) {\n            ifact[i - 1] = ifact[i] * i;\n        }\n    }\n    modint operator()(int n, int k) {\n        if (n < k || k < 0) return 0;\n        return fact[n] * ifact[k] * ifact[n - k];\n    }\n    modint h(int n, int k) {\n        n += k - 1;\n        if (k < 0 || k > n) return 0;\n        return fact[n] * ifact[k] * ifact[n - k];\n    }\n} comb(2002002);\nint main() {\n    ll n, m;\n    cin >> n >> m;\n    modint ans = 0;\n    vector<ll> v(2 * m + 1, 1);\n    v[1] = 0;\n    auto now = ntt.convpow(v, n - min(n, m), 3 * m + 1);\n    for (ll i = min(n, m); i >= 0; i--) {\n        ans += comb(n, i) * now[3 * m - i];\n        now = ntt.convolution(now, v, 3 * m + 1);\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define pb push_back\n#define mp make_pair\n#define pii pair<int,int>\nusing namespace std;\ninline int read(){\n\tint v=0,f=1;\n\tchar c=getchar();\n\twhile (c<'0' || c>'9'){\n\t\tif (c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile (c>='0' && c<='9'){\n\t\tv=v*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn v*f;\n}\nconst int Maxn=2000005;\nconst int mod=998244353;\nint fact[Maxn],ivf[Maxn];\nint qp(int x,int p){\n\tint ret=1;\n\twhile (p){\n\t\tif (p&1) ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;\n\t\tp>>=1; \n\t}\n\treturn ret;\n}\nint inv(int x){\n\treturn qp(x,mod-2);\n}\nint C(int x,int y){\n\treturn 1ll*fact[x]*ivf[y]%mod*ivf[x-y]%mod;\n}\nvoid _init(){\n\tfact[0]=1;\n\tfor (int i=1;i<Maxn;i++){\n\t\tfact[i]=1ll*fact[i-1]*i%mod;\n\t\tivf[i]=inv(fact[i]);\n\t}\n\tivf[0]=1;\n}\nint main(){\n\t_init();\n\tint n,m;\n\tscanf(\"%d %d\",&n,&m);\n\tint ans=0;\n\tfor (int i=m;i>=0;i-=2){\n\t\tif (i>n) continue;\n\t\tint rem=(3*m-i)/2;\n\t\tans+=1ll*C(n,i)*C(rem+n-1,n-1)%mod;\n\t\tif (ans>=mod) ans-=mod;\n\t}\n//\tcout<<ans<<endl;\n\tfor (int i=m;i>=0;i-=2){\n\t\tif (i>n) continue;\n\t\tint rem=(3*m-i)/2;\n\t\trem-=m;\n\t\tans-=1ll*C(n,i)*C(rem+n-1,n-1)%mod*i%mod;\n\t\tif (ans<0) ans+=mod;\n\t}\n\tfor (int i=m;i>=0;i-=2){\n\t\tif (i>n) continue;\n\t\tint rem=(3*m-i)/2;\n\t\trem-=m+1;\n\t\tif (rem<0) continue;\n\t\tans-=1ll*C(n,i)*C(rem+n-1,n-1)%mod*(n-i)%mod;\n\t\tif (ans<0) ans+=mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n)  for(int i = (k);i < (n);++i)\n#define REP(i,n)    FOR(i,0,n)\n#define ALL(x)      begin(x),end(x)\n\nusing namespace std;\nusing vecint = vector<int>;\nusing ll = int64_t;\n//constexpr ll MOD = 1000000007;\nconstexpr ll MOD = 998244353;\n\nll fact[2500001];\nll factinv[2500001];\n\n// a^-1 mod p\nll inv(ll a,ll p){\n  return ( a == 1 ? 1 : (1 - p*inv(p%a,a)) / a + p );\n}\n\nvoid init() {\n  fact[0] = 1;\n  factinv[0] = 1;\n  REP(i,2500000) {\n    fact[i+1] = fact[i] * (i+1);\n    fact[i+1] %= MOD;\n    factinv[i+1] = inv(fact[i+1], MOD);\n  }\n}\n\nll comb(ll n, ll k) {\n  ll tmp = (fact[n] * factinv[k]) % MOD;\n  return (tmp * factinv[n-k]) % MOD;\n}\n\nint main()\n{\n  init();\n  ll n,m;\n  cin>>n>>m;\n  ll tmp = comb(3*m+n-1, n-1);\n  ll sub = 0;\n  FOR(i,2*m+1,3*m+1) {\n    sub += comb(3*m-i+n-2, n-2);\n    sub %= MOD;\n  }\n  sub *= n;\n  sub %= MOD;\n  ll mno = 0;\n  FOR(i,m+1,n+1) {\n    ll rem = 3*m-i;\n    if (rem < 0 || (rem%2) == 1) continue;\n    mno += comb(rem/2+n-1, n-1) * comb(n, i);\n    mno %= MOD;\n  }\n  ll res = (2*MOD + tmp - sub - mno) % MOD;\n  cout<<res<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*Lucky_Glass*/\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\nconst int N=2e6;\nconst ll MOD=998244353;\n\nll Efac[N+3],Einv[N+3];\n\nll QPow(ll Va,ll Vb){\n\tll Rr=1;\n\twhile(Vb){\n\t\tif(Vb&1) Rr=Va*Rr%MOD;\n\t\tVa=Va*Va%MOD;\n\t\tVb>>=1;\n\t}\n\treturn Rr;\n}\nvoid Process(){\n\tEfac[0]=1;for(int i=1;i<=N;i++) Efac[i]=Efac[i-1]*i%MOD;\n\tEinv[N]=QPow(Efac[N],MOD-2);for(int i=N-1;i>=0;i--) Einv[i]=Einv[i+1]*(i+1)%MOD;\n}\nll fC(int Va,int Vb){return Efac[Vb]*Einv[Va]%MOD*Einv[Vb-Va]%MOD;}\nint main(){\n\tProcess();\n\tint n,m;scanf(\"%d%d\",&n,&m);\n\tll Vans=fC(n-1,3*m+n-1);\n\tVans=(Vans-fC(n-1,m+n-2)*n%MOD+MOD)%MOD;\n\tfor(int i=m+1;i<=n && i<=3*m;i++)\n\t\tif((3*m-i)%2==0){\n\t\t\tVans=(Vans-fC(i,n)*fC(n-1,(3*m-i)/2+n-1)%MOD+MOD)%MOD;\n\t\t}\n\tprintf(\"%lld\\n\",(Vans%MOD+MOD)%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long; \nusing pii =  pair<int, int>;\nusing pll =  pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\n//constexpr long long MOD = 1000000007LL;\nconstexpr long long MOD = 998244353LL;\ntemplate<class T, class U> inline bool chmax(T &a, U b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T, class U> inline bool chmin(T &a, U b) { if (a > b) { a = b; return true;} return false; }\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\ntemplate <std::uint_fast64_t Modulus> \nstruct ModInt {\n    using u64 = std::uint_fast64_t;\n\n    u64 a;\n\n    constexpr ModInt(const long long x = 0) noexcept : a(x >= 0 ? x % Modulus : (Modulus - (-x) % Modulus) % Modulus) {}\n    constexpr u64 &value() noexcept { return a; }\n    constexpr const u64 &value() const noexcept { return a; }\n    constexpr ModInt operator+(const ModInt rhs) const noexcept {return ModInt(*this) += rhs;}\n    constexpr ModInt operator-(const ModInt rhs) const noexcept {return ModInt(*this) -= rhs;}\n    constexpr ModInt operator*(const ModInt rhs) const noexcept {return ModInt(*this) *= rhs;}\n    constexpr ModInt operator/(const ModInt rhs) const noexcept {return ModInt(*this) /= rhs;}\n    constexpr ModInt operator^(const long long rhs) const noexcept {return ModInt(*this) ^= rhs;}\n    constexpr ModInt &operator+=(const ModInt rhs) noexcept {\n        a += rhs.a;\n        if (a >= Modulus) {\n            a -= Modulus;\n        }\n        return *this;\n    }\n    constexpr ModInt &operator-=(const ModInt rhs) noexcept {\n        if (a < rhs.a) {\n            a += Modulus;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr ModInt &operator*=(const ModInt rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n    constexpr ModInt &operator/=(ModInt rhs) noexcept {\n        u64 exp = Modulus - 2;\n        while (exp) {\n            if (exp % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            exp /= 2;\n        }\n        return *this;\n    }\n    constexpr ModInt &operator^=(long long exp) noexcept {\n        ModInt b = a;\n        a = 1;\n        while (exp) {\n            if (exp&1) *this *= b;\n            exp >>= 1;\n            b *= b;\n        }\n        return *this;\n    }\n\n    bool operator==(const ModInt &p) const {return a == p.a;}\n    bool operator!=(const ModInt &p) const {return a != p.a;}\n\n};\n\nusing mint = ModInt<MOD>;\n\n\nstruct ModCombination {\n    vector<mint> Fac;\n    vector<mint> Facinv;\n\n    ModCombination(int x) {\n        Fac.resize(x+1);\n        Facinv.resize(x+1);\n        Fac[0] = 1;\n        for (int i = 0; i < x; ++i) Fac[i+1] = Fac[i]*(i+1);\n        Facinv[x] = Fac[0]/Fac[x];\n        for (int i = x; i > 0; --i) Facinv[i-1] = Facinv[i]*i;\n    }\n\n    mint get(int n, int k) {\n        if (k < 0 || k > n) return 0;\n        return Fac[n]*Facinv[k]*Facinv[n-k];\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int N,M; cin >> N >> M;\n    \n    ModCombination MC(2000000);\n    mint ans = 0;\n    for (int i = 0; i <= min(M,N); i++) {\n        if ((3*M-i)&1) continue;\n        int c = (3*M-i)/2;\n        mint val = MC.get(N+c-1,c)*MC.get(N,i);\n        c -= M;\n        val -= (MC.get(N+c-2,c-1)*MC.get(N-1,i) + MC.get(N+c-1,c)*MC.get(N-1,i-1))*N;\n        ans += val;\n    }\n\n    cout << ans.a << ln;\n}"
  },
  {
    "language": "C++",
    "code": "// ああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああああ\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nT pow(T a, long long n, T e = 1) {\n    T ret = e;\n    while (n) {\n        if (n & 1) ret *= a;\n        a *= a;\n        n >>= 1;\n    }\n    return ret;\n}\n\ntemplate<int mod>\nstruct ModInt {\n    int x;\n    ModInt() : x(0) {}\n    ModInt(long long x_) { if ((x = x_ % mod + mod) >= mod) x -= mod; }\n    ModInt& operator+=(ModInt rhs) { if ((x += rhs.x) >= mod) x -= mod; return *this; }\n    ModInt& operator-=(ModInt rhs) { if ((x -= rhs.x) < 0) x += mod; return *this; }\n    ModInt& operator*=(ModInt rhs) { x = (unsigned long long) x * rhs.x % mod; return *this; }\n    ModInt& operator/=(ModInt rhs) { x = (unsigned long long) x * rhs.inv().x % mod; return *this; }\n\n    ModInt operator-() const { return -x < 0 ? mod - x : -x; }\n    ModInt operator+(ModInt rhs) const { return ModInt(*this) += rhs; }\n    ModInt operator-(ModInt rhs) const { return ModInt(*this) -= rhs; }\n    ModInt operator*(ModInt rhs) const { return ModInt(*this) *= rhs; }\n    ModInt operator/(ModInt rhs) const { return ModInt(*this) /= rhs; }\n    bool operator==(ModInt rhs) const { return x == rhs.x; }\n    bool operator!=(ModInt rhs) const { return x != rhs.x; }\n    ModInt inv() const { return pow(*this, mod - 2); }\n\n    friend ostream& operator<<(ostream& s, ModInt<mod> a) { s << a.x; return s; }\n    friend istream& operator>>(istream& s, ModInt<mod>& a) { s >> a.x; return s; }\n};\n\nusing mint = ModInt<998244353>;\n\nmint fact[3030303];\nmint factinv[3030303];\n\nvoid init() {\n    fact[0] = 1;\n    for (int i = 1; i < 3030303; i++) {\n        fact[i] = fact[i - 1] * i;\n    }\n    factinv[3030303 - 1] = fact[3030303 - 1].inv();\n    for (int i = 3030303 - 2; i >= 0; i--) {\n        factinv[i] = factinv[i + 1] * (i + 1);\n    }\n    assert(factinv[0] == 1);\n}\n\nmint ncr(int n, int r) {\n    assert(n < 3030303);\n    assert(n - r >= 0);\n    return fact[n] * factinv[r] * factinv[n - r];\n}\n\nmint dfs(int empty, int sum, int nax) {\n    if (empty == 0) {\n        return sum == 0;\n    }\n    if (nax < 0) return 0;\n    mint ret = 0;\n    for (int i = 0; i <= empty; i++) {\n        if (i * nax > sum) break;\n        ret += dfs(empty - i, sum - i * nax, nax - 1) * ncr(empty, i);\n    }\n    return ret;\n}\n\nmint test(int n, int m) {\n    return dfs(n, 3 * m, 2 * m);\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    init();\n//\n//    int n, m;\n//    cin >> n >> m;\n//    cout << test(n, m) << endl;\n\n\n    int N, m;\n    cin >> N >> m;\n\n//    int N = n;\n    int K = 3 * m;\n    int M = 2 * m;\n\n    mint ans = 0;\n    K += N;\n    M++;\n\n    for (int i = 0; i <= min(N, (K - N) / M); i++) {\n        mint tmp = ncr(N, i) * ncr(K - i * M - 1, N - 1);\n        if (i & 1) {\n            ans -= tmp;\n        } else {\n            ans += tmp;\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\nconst int mod = 998244353;\nconst int N = 2e7 + 11;\nint fac[N], inv[N], n, m;\ninline LL A(LL x, LL y){\n    return x + y - (x + y >= mod ? mod : 0);\n}\nint C(int m, int n){\n    if(m > n)return 0;\n    return 1LL * fac[n] * inv[m] % mod * inv[n-m] % mod;\n}\nLL f(int n, int m, int k){\n    LL ans = 0;\n    for(int i = m % 2;i <= k; i += 2){\n        ans = A(ans, 1LL * C(i, n) * C(n - 1, (m - i) / 2 + n - 1) % mod);\n    }\n    return ans;\n}\nint main(){\n    cin>>n>>m;\n    inv[0] = inv[1] = fac[1] = fac[0] = 1;\n    for(int i = 2;i < N; i++){\n        fac[i] = 1LL * fac[i-1] * i % mod;\n        inv[i] = (mod - 1LL * (mod / i) * inv[mod%i] % mod) % mod;\n    }\n    for(int i = 2;i < N; i++){\n        inv[i] = 1LL * inv[i] * inv[i-1] % mod;\n    }\n    LL ans = A(f(n, 3 * m, m), mod - 1LL * n * (A(f(n, m, m), mod - f(n - 1, m, m))) % mod);\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n// cout << fixed << setprecision(20);\n\n//拡張ユークリッドの互除法\nint extgcd(int a, int b, int &x, int &y) {\n    int d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1;\n        y = 0;\n    }\n    return d;\n}\n\n// mod逆元\nint mod_inverse(int a, int m) {\n    int x, y;\n    extgcd(a, m, x, y);\n    return (m + x % m) % m;\n}\n\n// 階乗テーブル\nint fact[1800000];\n\nint mod_fact(int n, int m) {\n    fact[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i % m;\n    }\n}\n\nint N, M;\nint mod = 998244353;\n\nint mod_C(int n, int r, int m) {\n    return fact[n] * mod_inverse(fact[r], m) % m * mod_inverse(fact[n - r], m) % m;\n}\n\nint mod_H(int n, int r, int m) {\n    return mod_C(n + r - 1, r, m);\n}\n\nsigned main() {\n    mod_fact(170000, mod);\n    cin >> N >> M;\n    int ans = mod_H(N, 3 * M, mod);\n    for (int i = 0; i < M; i++) {\n        ans = (ans + mod - (mod_H(N - 1, i, mod) * N % mod)) % mod;\n    }\n    cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <chrono>\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define FOR(i,m,n) for(int i=(m);i<(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\nconst int INF = 0x3f3f3f3f;\nconst long long LINF = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-8;\nconst int MOD = 998244353;\nconst int dy[] = {1, 0, -1, 0}, dx[] = {0, -1, 0, 1};\n/*-------------------------------------------------*/\nlong long mod_inv(long long a, long long mod = MOD) {\n  a %= mod;\n  if (__gcd(a, mod) != 1) return -1;\n  long long b = mod, x = 1, y = 0;\n  while (b > 0) {\n    long long tmp = a / b;\n    a -= tmp * b;\n    swap(a, b);\n    x -= tmp * y;\n    swap(x, y);\n  }\n  x %= mod;\n  if (x < 0) x += mod;\n  return x;\n}\n\nconst int MAX = 10000000;\nlong long fact[MAX + 1], fact_inv[MAX + 1];\nvoid nCk_init(int val = MAX, long long mod = MOD) {\n  fact[0] = 1;\n  FOR(i, 1, val + 1) fact[i] = fact[i - 1] * i % mod;\n  fact_inv[val] = mod_inv(fact[val], mod);\n  for (int i = val; i > 0; --i) fact_inv[i - 1] = fact_inv[i] * i % mod;\n}\n\nlong long nCk(int n, int k, long long mod = MOD) {\n  if (n < 0 || n < k || k < 0) return 0;\n  return fact[n] * fact_inv[k] % mod * fact_inv[n - k] % mod;\n}\n\n// set<vector<int> > st;\n// int m;\n// void dfs(int cnt, vector<int> &v) {\n//   if (cnt == m) {\n//     st.emplace(v);\n//     return;\n//   }\n//   REP(i, v.size()) REP(j, v.size()) if (i != j) {\n//     v[i] += 1;\n//     v[j] += 2;\n//     dfs(cnt + 1, v);\n//     v[i] -= 1;\n//     v[j] -= 2;\n//   }\n// }\n\nint main() {\n  cin.tie(0); ios::sync_with_stdio(false);\n  // freopen(\"input.txt\", \"r\", stdin);\n\n  nCk_init();\n  // // vector<int> v(n, 0);\n  // // dfs(0, v);\n  // // cout << st.size() << '\\n';\n  // // for (vector<int> vec : st) {\n  // //   REP(i, vec.size()) cout << vec[i] << ' ';\n  // //   cout << '\\n';\n  // // }\n  int n, m; cin >> n >> m;\n  if (n % 2 == 0) assert(m < n / 2);\n  else assert(m <= (n + 1) / 2);\n  long long ans = nCk(3 * m + n - 1, n - 1), tmp = 0;\n  REP(i, m) (tmp += nCk(i + n - 2, n - 2)) %= MOD;\n  (tmp *= n) %= MOD;\n  ans -= tmp;\n  if (ans < 0) ans += MOD;\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing PII = pair<ll, ll>;\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\ntemplate<typename T> void chmin(T &a, const T &b) { a = min(a, b); }\ntemplate<typename T> void chmax(T &a, const T &b) { a = max(a, b); }\nstruct FastIO {FastIO() { cin.tie(0); ios::sync_with_stdio(0); }}fastiofastio;\n#ifdef DEBUG_ \n#include \"../program_contest_library/memo/dump.hpp\"\n#else\n#define dump(...)\n#endif\nconst ll INF = 1LL<<60;\n\ntemplate<ll MOD>\nstruct modint {\n    ll x;\n    modint(): x(0) {}\n    modint(ll y) : x(y>=0 ? y%MOD : y%MOD+MOD) {}\n    static constexpr ll mod() { return MOD; }\n    // e乗\n    modint pow(ll e) {\n        ll a = 1, p = x;\n        while(e > 0) {\n            if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n            else {a = (a*p) % MOD; e--;}\n        }\n        return modint(a);\n    }\n    modint inv() const {\n        ll a=x, b=MOD, u=1, y=1, v=0, z=0;\n        while(a) {\n            ll q = b/a;\n            swap(z -= q*u, u);\n            swap(y -= q*v, v);\n            swap(b -= q*a, a);\n        }\n        return z;\n    }\n    // Comparators\n    bool operator <(modint b) { return x < b.x; }\n    bool operator >(modint b) { return x > b.x; }\n    bool operator<=(modint b) { return x <= b.x; }\n    bool operator>=(modint b) { return x >= b.x; }\n    bool operator!=(modint b) { return x != b.x; }\n    bool operator==(modint b) { return x == b.x; }\n    // Basic Operations\n    modint operator+(modint r) const { return modint(*this) += r; }\n    modint operator-(modint r) const { return modint(*this) -= r; }\n    modint operator*(modint r) const { return modint(*this) *= r; }\n    modint operator/(modint r) const { return modint(*this) /= r; }\n    modint &operator+=(modint r) {\n        if((x += r.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    modint &operator-=(modint r) {\n        if((x -= r.x) < 0) x += MOD;\n        return *this;\n    }\n    modint &operator*=(modint r) {\n    #if !defined(_WIN32) || defined(_WIN64)\n        x = x * r.x % MOD; return *this;\n    #endif\n        unsigned long long y = x * r.x;\n        unsigned xh = (unsigned) (y >> 32), xl = (unsigned) y, d, m;\n        asm(\n            \"divl %4; \\n\\t\"\n            : \"=a\" (d), \"=d\" (m)\n            : \"d\" (xh), \"a\" (xl), \"r\" (MOD)\n        );\n        x = m;\n        return *this;\n    }\n    modint &operator/=(modint r) { return *this *= r.inv(); }\n    // increment, decrement\n    modint operator++() { x++; return *this; }\n    modint operator++(signed) { modint t = *this; x++; return t; }\n    modint operator--() { x--; return *this; }\n    modint operator--(signed) { modint t = *this; x--; return t; }\n    // 平方剰余のうち一つを返す なければ-1\n    friend modint sqrt(modint a) {\n        if(a == 0) return 0;\n        ll q = MOD-1, s = 0;\n        while((q&1)==0) q>>=1, s++;\n        modint z=2;\n        while(1) {\n            if(z.pow((MOD-1)/2) == MOD-1) break;\n            z++;\n        }\n        modint c = z.pow(q), r = a.pow((q+1)/2), t = a.pow(q);\n        ll m = s;\n        while(t.x>1) {\n            modint tp=t;\n            ll k=-1;\n            FOR(i, 1, m) {\n                tp *= tp;\n                if(tp == 1) { k=i; break; }\n            }\n            if(k==-1) return -1;\n            modint cp=c;\n            REP(i, m-k-1) cp *= cp;\n            c = cp*cp, t = c*t, r = cp*r, m = k;\n        }\n        return r.x;\n    }\n\n    template<class T>\n    friend modint operator*(T l, modint r) { return modint(l) *= r; }\n    template<class T>\n    friend modint operator+(T l, modint r) { return modint(l) += r; }\n    template<class T>\n    friend modint operator-(T l, modint r) { return modint(l) -= r; }\n    template<class T>\n    friend modint operator/(T l, modint r) { return modint(l) /= r; }\n    template<class T>\n    friend bool operator==(T l, modint r) { return modint(l) == r; }\n    template<class T>\n    friend bool operator!=(T l, modint r) { return modint(l) != r; }\n    // Input/Output\n    friend ostream &operator<<(ostream& os, modint a) { return os << a.x; }\n    friend istream &operator>>(istream& is, modint &a) { \n        is >> a.x;\n        a.x = ((a.x%MOD)+MOD)%MOD;\n        return is;\n    }\n    friend string to_frac(modint v) {\n        static map<ll, PII> mp;\n        if(mp.empty()) {\n            mp[0] = mp[MOD] = {0, 1};\n            FOR(i, 2, 1001) FOR(j, 1, i) if(__gcd(i, j) == 1) {\n                mp[(modint(i) / j).x] = {i, j};\n            }\n        }\n        auto itr = mp.lower_bound(v.x);\n        if(itr != mp.begin() && v.x - prev(itr)->first < itr->first - v.x) --itr;\n        string ret = to_string(itr->second.first + itr->second.second * ((int)v.x - itr->first));\n        if(itr->second.second > 1) {\n            ret += '/';\n            ret += to_string(itr->second.second);\n        }\n        return ret;\n    }\n};\nusing mint = modint<998244353>;\n\n// 前計算O(N) クエリO(1)\nmint combi(ll N, ll K) {\n    const int maxN=3e6; // !!!\n    static mint fact[maxN+1]={},factr[maxN+1]={};\n    if (fact[0]==0) {\n        fact[0] = factr[0] = 1;\n        FOR(i, 1, maxN+1) fact[i] = fact[i-1] * i;\n        factr[maxN] = fact[maxN].inv();\n        for(ll i=maxN-1; i>=0; --i) factr[i] = factr[i+1] * (i+1);\n    }\n    if(K<0 || K>N) return 0; // !!!\n    return factr[K]*fact[N]*factr[N-K];\n}\n\nint main(void) {\n    ll n, m;\n    cin >> n >> m;\n\n    auto f = [&](ll a, ll b, ll c) {\n        chmin(c, n);\n        mint ret = 0;\n        REP(i, c+1) {\n            if((b-i)%2) continue;\n            ret += combi(a, i) * combi((b-i)/2+a-1, a-1);\n        }\n        return ret;\n    };\n\n    // 合計3mで奇数がm個以下\n    mint ans = f(n, 3*m, m);\n    // max > 2m となるパターンを引く\n    // n * {(n要素で合計がmで奇数がm個以下) - (n-1要素で合計がmで奇数がm個以下)}\n    ans -= n * (f(n, m, m) - f(n-1, m, m));\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll,ll> pll;\ntypedef vector<bool> vb;\nconst ll oo = 0x3f3f3f3f3f3f3f3f;\nconst double eps = 1e-9;\n#define sz(c) ll((c).size())\n#define all(c) begin(c), end(c)\n#define FOR(i,a,b) for (ll i = (a); i < (b); i++)\n#define FORD(i,a,b) for (ll i = (b)-1; i >= (a); i--)\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define xx first\n#define yy second\n#define TR(X) ({ if(1) cerr << \"TR: \" << (#X) << \" = \" << (X) << endl; })\n\nconst ll N = 5e6 + 10, MOD = 998244353;\nll inv[N], fac[N], inv_fac[N];\n\nvoid precalc() {\n\tinv[1] = 1;\n\tFOR(n,2,N) inv[n] = -(MOD/n)*inv[MOD%n] % MOD;\n\n\tfac[0] = 1;\n\tFOR(n,1,N) fac[n] = n*fac[n-1] % MOD;\n\n\tinv_fac[0] = 1;\n\tFOR(n,1,N) inv_fac[n] = inv[n]*inv_fac[n-1] % MOD;\n}\n\nll binom(ll n, ll k) {\n\tif (k < 0 || k > n) return 0;\n\tll res = fac[n] * inv_fac[k] % MOD * inv_fac[n-k] % MOD;\n\tif (res < 0) res += MOD;\n\treturn res;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\t\n\tprecalc();\n\n\tll n, m;\n\tcin >> n >> m;\n\t\n\tll res = binom(3*m+n-1,n-1);\n\t\n\tFOR(hmax,2*m+1,3*m+1) {\n\t\tres = (res - n*binom(3*m-hmax+n-2,n-2)) % MOD;\n\t}\n\t\n\tFOR(codd,m+1,3*m+1) {\n\t\tif (codd%2 != (3*m)%2) continue;\n\t\tres = (res - binom(n,codd) * binom((3*m-codd)/2+n-1,n-1)) % MOD;\n\t}\n\t\n\tif (res < 0) res += MOD;\n\tcout << res << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define modulo 998244353\n#define mod(mod_x) ((((long long)mod_x)+modulo)%modulo)\n#define Inf 1000000000000\n\n//aのb乗\nint beki(int a,int b,int M = modulo){\n\tint x = 1;\n\twhile(b!=0){\n\t\tif(b&1){\n\t\t\tx=((long long)x*a)%M;\n\t\t}\n\t\ta=((long long)a*a)%M;\n\t\tb>>=1;\n\t}\n\treturn x;\n}\n\n\n//aの逆元\nint gyakugen(int a){\n\treturn beki(a,modulo-2);\n}\n\nstruct combi{\n\tdeque<int> kaijou;\n\tdeque<int> kaijou_;\n\t\n\tcombi(int n){\n\t\tkaijou.push_back(1);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tkaijou.push_back(mod(kaijou[i-1]*i));\n\t\t}\n\t\t\n\t\tint b=gyakugen(kaijou[n]);\n\t\t\n\t\tkaijou_.push_front(b);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint k=n+1-i;\n\t\t\tkaijou_.push_front(mod(kaijou_[0]*k));\n\t\t}\n\t}\n\t\n\tint combination(int n,int r){\n\t\tif(r>n)return 0;\n\t\tint a = mod(kaijou[n]*kaijou_[r]);\n\t\ta=mod(a*kaijou_[n-r]);\n\t\treturn a;\n\t}\n\t\n\tint junretsu(int a,int b){\n\t\tint x = mod(kaijou_[a]*kaijou_[b]);\n\t\tx=mod(x*kaijou[a+b]);\n\t\treturn x;\n\t}\n\t\n\tint catalan(int n){\n\t\treturn mod(combination(2*n,n)*gyakugen(n+1));\n\t}\n\t\n};\n\nint main() {\n\t\n\tint N,M;\n\tcin>>N>>M;\n\t\n\tcombi C(3000000);\n\t\n\tint ans = C.junretsu(3*M,N-1);\n\t\n\t{\n\t\tint temp = 0;\n\t\t\n\t\tfor(int i=2*M+1;i<=3*M;i++){\n\t\t\ttemp = mod(temp + C.junretsu(3*M-i,N-2));\n\t\t}\n\t\t\n\t\ttemp = mod(temp * N);\n\t\t\n\t\tans = mod(ans - temp);\n\t}\n\t\n\t{\n\t\tint temp = 0;\n\t\tfor(int i=M+1;i<=N;i++){\n\t\t\tif((3*M-i)%2==1)continue;\n\t\t\tint t = C.combination(N,i);\n\t\t\tt = mod(t * C.junretsu(N-1,(3*M-i)/2));\n\t\t\ttemp = mod(temp + t);\n\t\t}\n\t\t\n\t\tans = mod(ans - temp);\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\nvoid read(pp& x){ scanf(\"%d%d\",&x.first, &x.second); }\nvoid read(pll& x){ scanf(\"%lld%lld\",&x.first, &x.second); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\nvoid cppio(){ ios_base::sync_with_stdio(0); cin.tie(0); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define sz(x) (int)(x).size()\n\nint n, m;\n\nconst ll mod = 998244353;\nconst int maxn = 3e6;\n\nll fact[maxn];\nll finv[maxn];\n\nll ipow(ll b, ll e) {\n\tll ret = 1;\n\twhile(e) {\n\t\tif(e&1) (ret *= b) %= mod;\n\t\t(b *= b) %= mod; e /= 2;\n\t}\n\treturn ret;\n}\n\nll comb(ll n, ll r) {\n\tif(r < 0 || r > n) return 0;\n\treturn fact[n] * finv[r] % mod * finv[n-r] % mod;\n}\n\nll h(ll n, ll r) { return comb(n+r-1, r); }\n\nint main()\n{\n\tcppio(); cin >> n >> m;\n\n\tfact[0] = 1;\n\tint T = n + 3*m;\n\tfor(int i=1; i<=T; ++i)\n\t\tfact[i] = fact[i-1] * i % mod;\n\tfinv[T] = ipow(fact[T], mod-2);\n\n\tfor(int i=T; 1<=i; --i)\n\t\tfinv[i-1] = finv[i] * i % mod;\n\n\tll ans = 0;\n\tfor(int k=m%2; k <= m && k <= n; k+=2) {\n\t\tll shit = 2*m+1;\n\t\tll way = h(n, (3*m-k)/2);\n\n\t\tif(k) {\n\t\t\tll N = n - 1 + (3*m - shit-(k-1))/2;\n\t\t\tll R = (3*m - shit-(k-1))/2;\n\n\t\t\tway += mod - k * comb(N, R) % mod;\n\t\t\tway %= mod;\n\t\t}\n\n\t\t++shit;\n\t\tif(n > k)\n\t\t{\n\t\t\tll N = n - 1 + (3*m - shit - k) / 2;\n\t\t\tll R = (3*m - shit - k) / 2;\n\n\t\t\tway += mod - comb(N, R) * (n-k) % mod;\n\t\t\tway %= mod;\n\t\t}\n\n\t\t(ans += comb(n, k) * way) %= mod;\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 998244353;\n\nnamespace Problem {\nusing namespace std;\n\ntemplate <long long Mod = MOD>\nclass Modint {\n public:\n  long long v;\n\n  Modint(const Modint &x) { v = x.v; }\n  explicit Modint(int x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(long long x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(unsigned x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  explicit Modint(unsigned long long x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  template <typename T>\n  explicit Modint(T x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    v = x;\n  }\n  Modint() : v(0) {}\n  long long get() const { return v; }\n  Modint mpow(Modint &n) const { return mpow(n.v); }\n  Modint mpow(long long n) const {\n    long long i = 1, p = v;\n    Modint ret(1);\n    while (i <= n) {\n      if (i & n) ret *= p;\n      i = (i << 1);\n      p = (p * p) % Mod;\n    }\n    return ret;\n  }\n  Modint operator-() const { return (v ? Modint(Mod - v) : Modint(0)); }\n  explicit operator int() const { return v; }\n  explicit operator long long() const { return v; }\n  Modint &operator+=(const Modint &a) {\n    v = (v + a.v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  Modint &operator-=(const Modint &a) {\n    v = (v - a.v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  Modint &operator*=(const Modint &a) {\n    v = (v * a.v) % Mod;\n    return *this;\n  }\n  Modint &operator/=(const Modint &a) {\n    v = (v * a.mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator+=(const T &a) {\n    v = (v + Modint(a).v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator-=(const T &a) {\n    v = (v - Modint(a).v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator*=(const T &a) {\n    v = (v * Modint(a).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator/=(const T &a) {\n    v = (v * Modint(a).mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  friend Modint operator+(const Modint &a, const Modint &b) {\n    return Modint(a) += b;\n  }\n  friend Modint operator-(const Modint &a, const Modint &b) {\n    return Modint(a) -= b;\n  }\n  friend Modint operator*(const Modint &a, const Modint &b) {\n    return Modint(a) *= b;\n  }\n  friend Modint operator/(const Modint &a, const Modint &b) {\n    return Modint(a) /= b;\n  }\n  template <class T, class U>\n  friend Modint operator+(const T &a, const U &b) {\n    return Modint(a) += Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator-(const T &a, const U &b) {\n    return Modint(a) -= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator*(const T &a, const U &b) {\n    return Modint(a) *= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator/(const T &a, const U &b) {\n    return Modint(a) /= Modint(b);\n  }\n};\n\ntemplate <long long M>\nostream &operator<<(ostream &os, const Modint<M> m) {\n  return os << m.v;\n}\ntemplate <long long Mod = MOD>\nclass Factorial {\n private:\n  int n;\n\n public:\n  vector<long long> fac, inv;\n\n public:\n  Factorial(long long n) : n(n), fac(n + 1), inv(n + 1) {\n    fac[0] = 1;\n    for (int i = 0; i < n; ++i) fac[i + 1] = fac[i] * (i + 1) % Mod;\n    inv[n] = modpow(fac[n], Mod - 2);\n    for (int i = n - 1; i >= 0; --i) inv[i] = inv[i + 1] * (i + 1) % Mod;\n  };\n  long long modpow(long long a, long long n, long long mod = Mod) {\n    long long i = 1, ret = 1, p = a;\n    while (i <= n) {\n      if (i & n) {\n        ret = (ret * p) % mod;\n      }\n      i = (i << 1);\n      p = (p * p) % mod;\n    }\n    return ret;\n  }\n  long long C(int a, int b) {\n    return (fac[a] * inv[b] % Mod) * inv[a - b] % Mod;\n  }\n  long long P(int a, int b) {\n    return (fac[a]) * inv[a - b] % Mod;\n  }\n  long long H(int a, int b) {  //The number of multisets of length b on a symbols\n    return C(a + b - 1, b);\n  }\n};\nclass Solver2 {\n public:\n  LL n, m;\n  vector<Modint<>> Hsum;\n  Factorial<> fac;\n  Solver2(LL n, LL m) : n(n), m(m), Hsum(m + 5), fac(n * 3 + 2 * m){};\n\n  Modint<> calc(LL i) {\n    Modint<> sum(0);\n    LL rem = 3 * m - i;\n    LL paircnt = rem / 2;\n    Modint<> divcnt = Modint<>(fac.C(n, i));\n    DBG(paircnt, n)\n    sum = Modint<>(fac.C(paircnt + n - 1, n - 1));\n    DBG(sum)\n    if (paircnt - n - 1 >= 0)\n      sum -= Hsum[paircnt - n - 1] * (n - i);\n    DBG(sum)\n    if (paircnt - (n - 1)  >= 0)\n      sum -= Hsum[paircnt - (n - 1) ] * i;\n    DBG(divcnt)\n    DBG(i, sum * divcnt)\n    return sum * divcnt;\n  }\n\n  void solve() {\n    precalc();\n    DBG(Hsum)\n    Modint<> ans(0);\n    if (m % 2) {\n      for (int odd = 1; odd <= min(n, m); odd += 2) {\n        ans += calc(odd);\n      }\n    } else {\n      for (int odd = 0; odd <= min(n, m); odd += 2) {\n        ans += calc(odd);\n      }\n    }\n    cout << ans << endl;\n  }\n  void precalc() {\n    Hsum[0] = Modint<>(1);\n    for (int i = 1; i < Hsum.size(); ++i) {\n      Hsum[i] = Modint<>(fac.C(i + (n - 2), n - 2));\n    }\n    for (int i = 1; i < Hsum.size(); ++i) {\n      Hsum[i] += Hsum[i - 1];\n    }\n  }\n};\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  long long n = 0, m;\n  std::cin >> n >> m;\n\n  Problem::Solver2 sol(n, m);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define mod 998244353\nusing ll=long long;\nconst int INF=1000000000;\nconst ll LINF=1001002003004005006ll;\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n// ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return true;}return false;}\n \nstruct IOSetup{\n    IOSetup(){\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n        cout<<fixed<<setprecision(12);\n    }\n} iosetup;\n\ntemplate<typename T1,typename T2>\nostream &operator<<(ostream &os,const pair<T1,T2>&p){\n    os<<p.first<<\" \"<<p.second;\n    return os;\n}\n \ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T>&v){\n    for(int i=0;i<(int)v.size();i++) os<<v[i]<<(i+1==(int)v.size()?\"\":\" \");\n    return os;\n}\n\ntemplate<typename T1,typename T2>\nistream &operator>>(istream &is,pair<T1,T2>&p){\n    is>>p.first>>p.second;\n    return is;\n}\n\ntemplate<typename T>\nistream &operator>>(istream &is,vector<T>&v){\n    for(T &x:v)is>>x;\n    return is;\n}\n\ntemplate<ll Mod>\nstruct ModInt{\n    long long x;\n    ModInt():x(0){}\n    ModInt(long long y):x(y>=0?y%Mod:(Mod-(-y)%Mod)%Mod){}\n    ModInt &operator+=(const ModInt &p){\n        if((x+=p.x)>=Mod) x-=Mod;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &p){\n        if((x+=Mod-p.x)>=Mod)x-=Mod;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &p){\n        x=(int)(1ll*x*p.x%Mod);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &p){\n        (*this)*=p.inverse();\n        return *this;\n    }\n    ModInt operator-()const{return ModInt(x);}\n    ModInt operator+(const ModInt &p)const{return ModInt(*this)+=p;}\n    ModInt operator-(const ModInt &p)const{return ModInt(*this)-=p;}\n    ModInt operator*(const ModInt &p)const{return ModInt(*this)*=p;}\n    ModInt operator/(const ModInt &p)const{return ModInt(*this)/=p;}\n    ModInt operator==(const ModInt &p)const{return x==p.x;}\n    ModInt operator!=(const ModInt &p)const{return x!=p.x;}\n    ModInt inverse()const{\n        int a=x,b=Mod,u=1,v=0,t;\n        while(b>0){\n            t=a/b;\n            swap(a-=t*b,b);swap(u-=t*v,v);\n        }\n        return ModInt(u);\n    }\n    ModInt pow(long long n)const{\n        ModInt ret(1),mul(x);\n        while(n>0){\n            if(n&1) ret*=mul;\n            mul*=mul;n>>=1;\n        }\n        return ret;\n    }\n    friend ostream &operator<<(ostream &os,const ModInt &p){return os<<p.x;}\n    friend istream &operator>>(istream &is,ModInt &a){long long t;is>>t;a=ModInt<Mod>(t);return (is);}\n    static int get_mod(){return Mod;}\n};\nusing mint=ModInt<mod>;\n \ntemplate<int MAX>\nstruct comcalc{\n    vector<mint> fact,finv,inv;\n    comcalc():fact(MAX),finv(MAX),inv(MAX){\n        fact[0]=mint(1),fact[1]=mint(1),finv[0]=mint(1),finv[1]=mint(1),inv[1]=mint(1);\n        for(int i=2;i<MAX;i++){\n            fact[i]=fact[i-1]*mint(i);\n            inv[i]=mint(0)-inv[mod%i]*(mint(mod/i));\n            finv[i]=finv[i-1]*inv[i];\n        }\n    }\n    mint com(int n,int k){\n        if(n<k) return mint(0);\n        if(n<0 or k<0) return mint(0);\n        return fact[n]*(finv[k]*finv[n-k]);\n    }\n    mint fac(int n){\n        return fact[n];\n    }\n    // 重複組み合わせ:n種類の物から重複を許し，k個選ぶ\n    mint nHk(int n,int k){\n        return com(n+k-1,k);\n    }\n    // 玉n区別，箱k区別，各箱1個以上O(k)\n    mint F12_dis_dis_one(int n,int k){\n        if(n<k)return mint(0);\n        mint ret=0;\n        for(int i=0;i<=k;i++){\n            mint add=com(k,i)*(mint(i).pow(n));\n            if((k-i)%2) ret-=add;\n            else        ret+=add;\n        }\n        return ret;\n    }\n    /* sum combination(n+x, x), x=l to r\n       https://www.wolframalpha.com/input/?i=sum+combination%28n%2Bx+%2Cx%29%2C+x%3Dl+to+r&lang=ja \n       check n+x < [COM_PRECALC_MAX]    */\n    mint sum_of_comb(int n,int l,int r){\n        if(l>r)return mint(0);\n        mint ret=mint(r+1)*com(n+r+1,r+1)-mint(l)*com(l+n,l);\n        ret/=mint(n+1);\n        return ret;\n    }\n};\nmint pow_mod(mint x,ll n){\n    return x.pow(n);\n}\nmint inv_mod(mint x){\n    return x.inverse();\n}\n// O(n)\nmint fact_mod(ll n){\n    mint ret=1;\n    for(int i=2;i<=n;i++) ret*=mint(i);\n    return ret;\n}\n// O(r)\nmint comb_mod(ll n,ll r){\n    if(r>n-r) r=n-r;\n    if(r==0) return 1;\n    mint a=1,b=mint(fact_mod(r)).inverse();\n    for(int i=0;i<r;i++)a*=mint(n-i);\n    return a*b;\n}\n \nconst int COM_PRECALC_MAX=10010000;\nusing cominit=comcalc<COM_PRECALC_MAX>;\n\n\n\nsigned main(){\n    cominit F;\n\n    int n,m;cin>>n>>m;\n    mint res=F.com(3*m+n-1,n-1);\n    \n    {\n        mint mi=0;\n        for(int i=m+1;i<=3*m;i++){\n            int rem=3*m-i;\n            if(rem%2) continue;\n            rem/=2;\n            mi+=F.com(n,i)*F.com(rem+n-1,n-1);\n        }\n        res-=mi;\n    }\n\n    {\n        res-=mint(n)*F.com(m-1+n-1,n-1);\n    }\n\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n问题等价于求长为 n 的满足一下三个条件的数列的个数：\n\n1. 所有值的和为 s1 = 3m\n2. 奇数的个数不超过 s2 = m\n3. 最大的数不超过 s3 = 2m\n\n先考虑第一个限制，相当于把 s1 个球放进 n 个盒子，方案数为 f1(s1, n) = C(n + s1, s1)。\n\n再考虑第二个限制，设 f2(n, m, k) 为长度为 n ，和为 m ，奇数不超过 k 个的方案数，\n枚举奇数个数 i ，然后把这 i 个奇数减 1 弄成偶数，\n那么 i 的贡献就是 C(n, i) * f1((m - i) / 2, n - 1) 。\n\n最后考虑第三个限制，由于和为 3m ，超过 2m 的数最多只有一个，\n简单容斥，钦定一个数大于 2m ，那么贡献就是 - n * f2(n, m, m) ，\n但事实上这也算进去了该数恰好为 2m 的情况，继续容斥，贡献为 n * f2(n - 1, m, m) ，\n那么答案 f3(n, m) = f2(n, 3m, m) - n * (f2(n, m, m) - f2(n - 1, m, m)) 。\n#endif\n#include <cstdio>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long lolong;\n\ninline int input() { int x; scanf(\"%d\", &x); return x; }\n\nconst int maxn = 4000005, mod = 998244353;\nlolong fac[maxn];\nlolong inv[maxn];\nlolong ifac[maxn];\n\ninline lolong c(int n, int m) {\n\treturn fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nlolong f(int n, int m, int k) {\n\tlolong res = 0;\n\tfor(int i = 0; i <= k; i ++)\n\t\tif(!((m - i) & 1))\n\t\t\tres += c(n, i) * c((m - i) / 2 + n - 1, (m - i) >> 1) % mod;\n\treturn res % mod;\n}\n\nint main() {\n\tfac[0] = 1;\n\tfor(int i = 1; i < maxn; i ++)\n\t\tfac[i] = fac[i - 1] * i % mod;\n\n\tinv[1] = 1;\n\tfor(int i = 2; i < maxn; i ++)\n\t\tinv[i] = (mod - mod / i) * inv[mod % i] % mod;\n\n\tifac[0] = 1;\n\tfor(int i = 1; i < maxn; i ++)\n\t\tifac[i] = ifac[i - 1] * inv[i] % mod;\n\n\tint n = input(), m = input();\n\tprintf(\"%lld\\n\",\n\t\t\t(f(n, m * 3, m) + mod -\n\t\t\t n * (f(n, m, m) + mod -\n\t\t\t\t f(n - 1, m, m)) % mod) % mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\n#define mem(a,v) memset((a), (v), sizeof (a))\n#define enl printf(\"\\n\")\n#define case(t) printf(\"Case #%d: \", (t))\n#define ni(n) scanf(\"%d\", &(n))\n#define nl(n) scanf(\"%lld\", &(n))\n#define nai(a, n) for (int i = 0; i < (n); i++) ni(a[i])\n#define nal(a, n) for (int i = 0; i < (n); i++) nl(a[i])\n#define pri(n) printf(\"%d\\n\", (n))\n#define prl(n) printf(\"%lld\\n\", (n))\n#define pii pair<int, int>\n#define pil pair<int, long long>\n#define pll pair<long long, long long>\n#define vii vector<pii>\n#define vil vector<pil>\n#define vll vector<pll>\n#define vi vector<int>\n#define vl vector<long long>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef cc_hash_table<int,int,hash<int>> ht;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> oset;\nconst double pi = acos(-1);\nconst int MOD = 998244353;\nconst int INF = 1e9 + 7;\nconst int MAXN = 3e6 + 5;\nconst double eps = 1e-9;\nll fac[MAXN], ifac[MAXN];\n\nll pw(ll a, ll b) {\n\tll r = 1;\n\twhile (b) {\n\t\tif (b & 1)\n\t\t\tr = (r * a) % MOD, b--;\n\t\telse\n\t\t\ta = (a * a) % MOD, b /= 2;\n\t}\n\treturn r;\n}\n\nll ncr(int n, int k) {\n\treturn (fac[n] * ifac[k] % MOD) * ifac[n-k] % MOD;\n}\n\nint main() {\n\tfac[0] = 1;\n\tifac[0] = 1;\n\tfor (ll i = 1; i < MAXN; i++) {\n\t\tfac[i] = (fac[i-1] * i) % MOD;\n\t\tifac[i] = pw(fac[i], MOD - 2);\n\t}\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tif (n == 2)\n\t\treturn !pri(m+1);\n\tll ans = ncr(3*m+n-1, n-1);\n\tfor (int i = 2*m+1; i <= 3*m; i++)\n\t\tans = (ans - (ll)n * ncr(3*m-i+n-2, n-2) % MOD + MOD) % MOD;\n\tfor (int i = 0; i < m; i++)\n\t\tif (n >= 3*m-2*i)\n\t\t\tans = (ans - ncr(i+n-1,n-1) * ncr(n, 3*m-i*2) % MOD + MOD) % MOD;\n\tprl(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\nconstexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int ret = 1;\n\tlong long int by = x;\n\twhile (n) {\n\t\tif (n & 1) {\n\t\t\tret *= by;\n\t\t\tret %= M;\n\t\t}\n\t\tby *= by;\n\t\tby %= M;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tvector<long long int>by(N * 3 + M * 3 + 1, 1);\n\tvector<long long int>rev(N * 3 + M * 3 + 1, 1);\n\tfor (int i = 1; i <= (N + M) * 3; i++) {\n\t\tby[i] = by[i - 1] * i;\n\t\tby[i] %= MOD;\n\t\trev[i] = power(by[i], MOD - 2, MOD);\n\t}\n\tlong long int ans = by[M * 3 + N - 1];\n\tans *= rev[N - 1];\n\tans %= MOD;\n\tans *= rev[M * 3];\n\tans %= MOD;\n\t//cout << ans << endl;\n\tfor (int i = M * 3; i > M * 2; i--) {\n\t\tlong long int minus = N;\n\t\tminus *= by[M * 3 - i + N - 2];\n\t\tminus %= MOD;\n\t\tminus *= rev[N - 2];\n\t\tminus %= MOD;\n\t\tminus *= rev[M * 3 - i];\n\t\tminus %= MOD;\n\t\tans += MOD - minus;\n\t\tans %= MOD;\n\t}\n\t//cout << ans << endl;\n\tfor (int i = max(M * 3 - N, M + 1); i <= min(3 * M, N); i ++) {\n\t\tlong long int minus = by[N];\n\t\tminus *= rev[i];\n\t\tminus %= MOD;\n\t\tminus *= rev[N - i];\n\t\tminus %= MOD;\n\t\tlong long int num = M * 3 - i;\n\t\tif (num & 1)continue;\n\t\tnum /= 2;\n\t\tminus *= by[num + N - 1];\n\t\tminus %= MOD;\n\t\tminus *= rev[num];\n\t\tminus %= MOD;\n\t\tminus *= rev[N - 1];\n\t\tminus %= MOD;\n\t\tans += MOD - minus;\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 3000005;\nconst int MOD = 998244353;\n\nlong long fac[MAX]; //i!%MOD=fac[i]\nlong long finv[MAX]; //pow(i!,-1)%MOD=finv[i]\nlong long inv[MAX]; //pow(i,-1)%MOD=inv[i]\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nint main(int argc, char const *argv[])\n{\n\tCOMinit();\n\tint n,m;\n\tcin>>n>>m;\n\tlong long ans=COM(3*m+n-1,n-1);\n\tfor (int i = 2*m+1; i <= 3*m; ++i)\n\t{\n\t\tans-=(long long)n*COM(3*m+n-2-i,n-2)%MOD;\n\t\tans%=MOD;\n\t}\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tans-=COM(n-1+i,n-1)*COM(n,3*m-2*i)%MOD;\n\t\tans%=MOD;\n\t}\n\tans+=MOD;\n\tans%=MOD;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i, n, m) for(int i = n; i < (int)m; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define pb push_back\nusing namespace std;\nusing ll = std::int_fast64_t;\nusing P = pair<ll, ll>;\nconstexpr ll inf = 1000000000;\nconstexpr ll mod = 998244353;\nconstexpr long double eps = 1e-15;\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, pair<T1, T2> p) {\n    os << to_string(p.first) << \" \" << to_string(p.second);\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n    REP(i, v.size()) {\n        if(i) os << \" \";\n        os << to_string(v[i]);\n    }\n    return os;\n}\n\nstruct modint {\n    ll n;\npublic:\n    modint(const ll n = 0) : n((n % mod + mod) % mod) {}\n    static modint pow(modint a, int m) {\n        modint r = 1;\n        while(m > 0) {\n            if(m & 1) { r *= a; }\n            a = (a * a); m /= 2;\n        }\n        return r;\n    }\n    modint &operator++() { *this += 1; return *this; }\n    modint &operator--() { *this -= 1; return *this; }\n    modint operator++(int) { modint ret = *this; *this += 1; return ret; }\n    modint operator--(int) { modint ret = *this; *this -= 1; return ret; }\n    modint operator~() const { return (this -> pow(n, mod - 2)); } // inverse\n    friend bool operator==(const modint& lhs, const modint& rhs) {\n        return lhs.n == rhs.n;\n    }\n    friend bool operator<(const modint& lhs, const modint& rhs) {\n        return lhs.n < rhs.n;\n    }\n    friend bool operator>(const modint& lhs, const modint& rhs) {\n        return lhs.n > rhs.n;\n    }\n    friend modint &operator+=(modint& lhs, const modint& rhs) {\n        lhs.n += rhs.n;\n        if (lhs.n >= mod) lhs.n -= mod;\n        return lhs;\n    }\n    friend modint &operator-=(modint& lhs, const modint& rhs) {\n        lhs.n -= rhs.n;\n        if (lhs.n < 0) lhs.n += mod;\n        return lhs;\n    }\n    friend modint &operator*=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * rhs.n) % mod;\n        return lhs;\n    }\n    friend modint &operator/=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * (~rhs).n) % mod;\n        return lhs;\n    }\n    friend modint operator+(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n + rhs.n);\n    }\n    friend modint operator-(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n - rhs.n);\n    }\n    friend modint operator*(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * rhs.n);\n    }\n    friend modint operator/(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * (~rhs).n);\n    }\n};\nistream& operator>>(istream& is, modint m) { is >> m.n; return is; }\nostream& operator<<(ostream& os, modint m) { os << m.n; return os; }\n\n#define MAX_N 3030303\nlong long extgcd(long long a, long long b, long long& x, long long& y) {\n    long long d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1; y = 0;\n    }\n    return d;\n}\nlong long mod_inverse(long long a, long long m) {\n    long long x, y;\n    if(extgcd(a, m, x, y) == 1) return (m + x % m) % m;\n    else return -1;\n}\nvector<long long> fact(MAX_N+1, inf);\nlong long mod_fact(long long n, long long& e) {\n    if(fact[0] == inf) {\n        fact[0]=1;\n        if(MAX_N != 0) fact[1]=1;\n        for(ll i = 2; i <= MAX_N; ++i) {\n            fact[i] = (fact[i-1] * i) % mod;\n        }\n    }\n    e = 0;\n    if(n == 0) return 1;\n    long long res = mod_fact(n / mod, e);\n    e += n / mod;\n    if((n / mod) % 2 != 0) return (res * (mod - fact[n % mod])) % mod;\n    return (res * fact[n % mod]) % mod;\n}\n// return nCk\nlong long mod_comb(long long n, long long k) {\n    if(n < 0 || k < 0 || n < k) return 0;\n    long long e1, e2, e3;\n    long long a1 = mod_fact(n, e1), a2 = mod_fact(k, e2), a3 = mod_fact(n - k, e3);\n    if(e1 > e2 + e3) return 0;\n    return (a1 * mod_inverse((a2 * a3) % mod, mod)) % mod;\n}\nll n, m;\nset<vector<int>> s;\n\nvoid exp(vector<int>& v, int k) {\n    if(k == m) {\n        s.insert(v);\n    } else {\n        REP(i, n) REP(j, n) {\n            if(i == j) continue;\n            v[i] += 2;\n            v[j] ++;\n            exp(v, k + 1);\n            v[i] -= 2;\n            v[j]--;\n        }\n    }\n    return;\n}\n\nvoid exp2(vector<int>& v, int k) {\n    if(k == n) {\n        int sum = 0;\n        REP(i, n) sum += v[i];\n        if(sum == 3 * m && !s.count(v)) cout << v << endl;\n    } else {\n        REP(i, 2 * m + 1) {\n            v[k] = i;\n            exp2(v, k + 1);\n        }\n    }\n    return;\n}\n\nusing mi = modint;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n >> m;\n    mi ans = 0;\n    // 最大値は 2M 以下\n    // 正の山の数も 2M 以下\n    // 2 以上の山が M 個以上 (上を全部包含)、どうせ十分！ｗ\n    // ちがう\n    // vector<int> v(n, 0);\n    // exp(v, 0);\n    // exp2(v, 0);\n\n    for(ll i = m; 2 * i <= 3 * m; i++) {\n        mi tmp = mod_comb(i + n - 1, n - 1);\n        if(3 * m - 2 * i > n) continue;\n        tmp *= mod_comb(n, 3 * m - 2 * i);\n        ans += tmp;\n    }\n    for(ll i = 2 * m + 1; i <= 3 * m; i++) {\n        mi tmp = mod_comb(3 * m - i + n - 2, n - 2);\n        ans -= tmp * n;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n    x = 0; char c = getchar(); int f = 0;\n    for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n    for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n    if (f) x = -x;\n}\n\nnamespace {\n\tconst int mo = 998244353;\n\tinline int add(int x, int y) { x += y; return x >= mo ? x - mo : x; }\n\tinline int sub(int x, int y) { x -= y; return x < 0 ? x + mo : x; } \n\tinline int mul(int x, int y) { return (lo) x * y % mo; }\n\tinline int power(int a, int k = mo - 2) {\n\t\tint ans = 1;\n\t\tfor (; k; k >>= 1, a = mul(a, a))\n\t\t\tif (k & 1) ans = mul(ans, a);\n\t\treturn ans;\n\t}\n}\nconst int N = 3e6 + 233;\nint n, m;\nint fac[N], ifac[N];\n\ninline int C(int n, int m) {\n\tif (n < m) return 0;\n\telse if (m == 0 || m == n) return 1;\n\telse return mul(fac[n], mul(ifac[m], ifac[n - m]));\n}\n\ninline void prepare(int n) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i++) fac[i] = mul(fac[i - 1], i);\n\tifac[n] = power(fac[n]);\n\tfor (int i = n - 1; i >= 0; i--) ifac[i] = mul(ifac[i + 1], i + 1);\n}\n\nint main(void) {\n\tread(n); read(m);\n\tprepare(3e6);\n\tint ans = 0;\n\tfor (int d = 0; d <= min(m, n); d++) {\n\t\tif ((3 * m - d) % 2 == 0) {\n\t\t\tauto F = [] (int k, int n) {\n\t\t\t\treturn C(k / 2 + n - 1, n - 1);\n\t\t\t};\n\t\t\tans = add(ans, mul(C(n, d), F(3 * m - d, n)));\n\t\t\tans = sub(ans, mul(C(n, d), mul(n, F(m - d, n))));\n\t\t\tans = add(ans, mul(C(n, d), mul(n - d, F(m - d, n - 1))));\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 998244353;\n\nnamespace Problem {\nusing namespace std;\n\ntemplate <long long Mod = MOD>\nclass Modint {\n public:\n  long long v;\n\n  Modint(const Modint &x) { v = x.v; }\n  explicit Modint(int x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(long long x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(unsigned x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  explicit Modint(unsigned long long x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  template <typename T>\n  explicit Modint(T x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    v = x;\n  }\n  Modint() : v(0) {}\n  long long get() const { return v; }\n  Modint mpow(Modint &n) const { return mpow(n.v); }\n  Modint mpow(long long n) const {\n    long long i = 1, p = v;\n    Modint ret(1);\n    while (i <= n) {\n      if (i & n) ret *= p;\n      i = (i << 1);\n      p = (p * p) % Mod;\n    }\n    return ret;\n  }\n  Modint operator-() const { return (v ? Modint(Mod - v) : Modint(0)); }\n  explicit operator int() const { return v; }\n  explicit operator long long() const { return v; }\n  Modint &operator+=(const Modint &a) {\n    v = (v + a.v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  Modint &operator-=(const Modint &a) {\n    v = (v - a.v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  Modint &operator*=(const Modint &a) {\n    v = (v * a.v) % Mod;\n    return *this;\n  }\n  Modint &operator/=(const Modint &a) {\n    v = (v * a.mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator+=(const T &a) {\n    v = (v + Modint(a).v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator-=(const T &a) {\n    v = (v - Modint(a).v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator*=(const T &a) {\n    v = (v * Modint(a).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator/=(const T &a) {\n    v = (v * Modint(a).mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  friend Modint operator+(const Modint &a, const Modint &b) {\n    return Modint(a) += b;\n  }\n  friend Modint operator-(const Modint &a, const Modint &b) {\n    return Modint(a) -= b;\n  }\n  friend Modint operator*(const Modint &a, const Modint &b) {\n    return Modint(a) *= b;\n  }\n  friend Modint operator/(const Modint &a, const Modint &b) {\n    return Modint(a) /= b;\n  }\n  template <class T, class U>\n  friend Modint operator+(const T &a, const U &b) {\n    return Modint(a) += Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator-(const T &a, const U &b) {\n    return Modint(a) -= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator*(const T &a, const U &b) {\n    return Modint(a) *= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator/(const T &a, const U &b) {\n    return Modint(a) /= Modint(b);\n  }\n};\n\ntemplate <long long M>\nostream &operator<<(ostream &os, const Modint<M> m) {\n  return os << m.v;\n}\ntemplate <long long Mod = MOD>\nclass Factorial {\n private:\n  int n;\n\n public:\n  vector<long long> fac, inv;\n\n public:\n  Factorial(long long n) : n(n), fac(n + 1), inv(n + 1) {\n    fac[0] = 1;\n    for (int i = 0; i < n; ++i) fac[i + 1] = fac[i] * (i + 1) % Mod;\n    inv[n] = modpow(fac[n], Mod - 2);\n    for (int i = n - 1; i >= 0; --i) inv[i] = inv[i + 1] * (i + 1) % Mod;\n  };\n  long long modpow(long long a, long long n, long long mod = Mod) {\n    long long i = 1, ret = 1, p = a;\n    while (i <= n) {\n      if (i & n) {\n        ret = (ret * p) % mod;\n      }\n      i = (i << 1);\n      p = (p * p) % mod;\n    }\n    return ret;\n  }\n  long long C(int a, int b) {\n    return (fac[a] * inv[b] % Mod) * inv[a - b] % Mod;\n  }\n  long long P(int a, int b) {\n    return (fac[a]) * inv[a - b] % Mod;\n  }\n  long long H(int a, int b) {  //The number of multisets of length b on a symbols\n    return C(a + b - 1, b);\n  }\n};\nclass Solver2 {\n public:\n  LL n, m;\n  vector<Modint<>> Hsum;\n  Factorial<> fac;\n  Solver2(LL n, LL m) : n(n), m(m), Hsum(m + 5), fac(n * 3 + 2 * m){};\n\n  Modint<> calc(LL i) {\n    Modint<> sum(0);\n    LL rem = 3 * m - i;\n    LL paircnt = rem / 2;\n    Modint<> divcnt = Modint<>(fac.C(n, i));\n    DBG(paircnt, n)\n    sum = Modint<>(fac.C(paircnt + n - 1, n - 1));\n    DBG(sum)\n    if (paircnt - m - 1 >= 0)\n      sum -= Hsum[paircnt - m - 1] * (n - i);\n    DBG(sum)\n    if (paircnt - (m - 1) - 1 >= 0)\n      sum -= Hsum[paircnt - (m - 1) - 1] * i;\n    DBG(divcnt)\n    DBG(i, sum * divcnt)\n    return sum * divcnt;\n  }\n\n  void solve() {\n    precalc();\n    DBG(Hsum)\n    Modint<> ans(0);\n    if (m % 2) {\n      for (int odd = 1; odd <= min(n, m); odd += 2) {\n        ans += calc(odd);\n      }\n    } else {\n      for (int odd = 0; odd <= min(n, m); odd += 2) {\n        ans += calc(odd);\n      }\n    }\n    cout << ans << endl;\n  }\n  void precalc() {\n    Hsum[0] = Modint<>(1);\n    for (int i = 1; i < Hsum.size(); ++i) {\n      Hsum[i] = Modint<>(fac.C(i + (n - 2), n - 2));\n    }\n    for (int i = 1; i < Hsum.size(); ++i) {\n      Hsum[i] += Hsum[i - 1];\n    }\n  }\n};\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  long long n = 0, m;\n  std::cin >> n >> m;\n\n  Problem::Solver2 sol(n, m);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 1000000007;\nlong long modsub(long long a, long long b){\n\treturn (a % MOD - b % MOD + MOD) % MOD;\n}\nlong long modpow(long long a, long long b){\n\tlong long ans = 1;\n\twhile (b > 0){\n\t\tif (b % 2 == 1){\n\t\t\tans *= a;\n\t\t\tans %= MOD;\n\t\t}\n\t\ta *= a;\n\t\ta %= MOD;\n\t\tb /= 2;\n\t}\n\treturn ans;\n}\nlong long modinv(long long a){\n\treturn modpow(a, MOD - 2);\n}\nvector<long long> mf = {1};\nvector<long long> mfi = {1};\nlong long modfact(int n){\n\tif (mf.size() > n){\n\t\treturn mf[n];\n\t} else {\n\t\tfor (int i = mf.size(); i <= n; i++){\n\t\t\tlong long next = mf.back() * i % MOD;\n\t\t\tmf.push_back(next);\n\t\t\tmfi.push_back(modinv(next));\n\t\t}\n\t\treturn mf[n];\n\t}\n}\nlong long modfactinv(int n){\n\tif (mfi.size() > n){\n\t\treturn mfi[n];\n\t} else {\n\t\treturn modinv(modfact(n));\n\t}\n}\nlong long modbinom(int n, int k){\n\tif (n < 0 || k < 0 || k > n){\n\t\treturn 0;\n\t} else {\n\t\treturn modfact(n) * modfactinv(k) % MOD * modfactinv(n - k) % MOD;\n\t}\n}\nint main(){\n  int N, M;\n  cin >> N >> M;\n  long long ans = modbinom(M * 3 + N - 1, N - 1);\n  for (int i = M * 2 + 1; i <= M * 3; i++){\n    ans = modsub(ans, N * modbinom(M * 3 - i + N - 2, N - 2));\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#define MOD 998244353\n#define mkp make_pair\ntypedef long long ll;\nusing namespace std;\n\n#define MAX_N 1000010\nll inv[MAX_N+10],fac[MAX_N+10],ifac[MAX_N+10];\n\nvoid setComb(){\n  inv[0]=1;inv[1]=1;fac[1]=1;ifac[1]=1;fac[0]=1;ifac[0]=1;\n  for(int i=2;i<MAX_N;i++){\n    inv[i]=(-MOD/i)*inv[MOD%i]%MOD;\n    fac[i]=fac[i-1]*i%MOD;\n    ifac[i]=ifac[i-1]*inv[i]%MOD;\n\n    inv[i]=(inv[i]+MOD)%MOD;\n    fac[i]=(fac[i]+MOD)%MOD;\n    ifac[i]=(ifac[i]+MOD)%MOD;\n  }\n  return;\n}\n\nll comb(ll n,ll k){\n  if(n<k||n<0||k<0) return 0;\n  else return ((fac[n]*ifac[k]%MOD*ifac[n-k]%MOD+MOD)%MOD);\n}\n\nll hcomb(ll n,ll r){\n  if(n==0&&r==0) return 1;\n  else if(n<0||r<0) return 0;\n  else return comb(n+r-1,r);\n}\n\nll mod_pow(ll x,ll n){\n  x%=MOD;\n  ll res=1;\n  while(n>0){\n    if(n&1) res=res*x%MOD;\n    x=x*x%MOD;\n    n>>=1;\n  }\n  return res;\n}\n\nvoid add(ll &a,ll b){\n  a=(a+b)%MOD;\n}\n\nvoid mul(ll &a,ll b){\n  a%=MOD;b%=MOD;\n  a=a*b%MOD;\n}\n\nint main(){\n  ll N,M;\n  cin>>N>>M;\n\n  setComb();\n\n  ll nans=0;\n  for(ll k=0;k<M;k++){\n    ll res=hcomb(N-1,k);\n    mul(res,N);\n    add(nans,res);\n  }\n\n  ll ans=0;\n  for(ll k=0;k<=min(N,M);k++){\n    if(k%2!=M%2) continue;\n    ll res=hcomb(N,(3*M-k)/2);\n    mul(res,comb(N,k));\n    add(ans,res);\n  }\n\n  add(ans,-nans+MOD);\n  cout<<ans<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 3e6 + 5, djq = 998244353;\n\nint n, m, fac[N], inv[N], ans;\n\nint C(int n, int m)\n{\n\treturn 1ll * fac[n] * inv[m] % djq * inv[n - m] % djq;\n}\n\nint main()\n{\n\tstd::cin >> n >> m;\n\tfac[0] = inv[0] = inv[1] = 1;\n\tfor (int i = 1; i < N; i++) fac[i] = 1ll * fac[i - 1] * i % djq;\n\tfor (int i = 2; i < N; i++) inv[i] = 1ll * (djq - djq / i) * inv[djq % i] % djq;\n\tfor (int i = 2; i < N; i++) inv[i] = 1ll * inv[i] * inv[i - 1] % djq;\n\tfor (int i = 0; i <= m && i <= n; i++) if (!(m - i & 1))\n\t\tans = (1ll * C(n, i) * C((m * 3 - i >> 1) + n - 1, n - 1) + ans) % djq;\n\tans = (ans - 1ll * n * C(m + n - 2, n - 1) % djq + djq) % djq;\n\treturn std::cout << ans << std::endl, 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n// cout << fixed << setprecision(20);\n\n//拡張ユークリッドの互除法\nint extgcd(int a, int b, int &x, int &y) {\n    int d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1;\n        y = 0;\n    }\n    return d;\n}\n\n// mod逆元\nint mod_inverse(int a, int m) {\n    int x, y;\n    extgcd(a, m, x, y);\n    return (m + x % m) % m;\n}\n\n// 階乗テーブル\nint fact[2800000];\n\nint mod_fact(int n, int m) {\n    fact[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i % m;\n    }\n}\n\nint N, M;\nint mod = 998244353;\n\nint mod_C(int n, int r, int m) {\n    return fact[n] * mod_inverse(fact[r], m) % m * mod_inverse(fact[n - r], m) % m;\n}\n\nint mod_H(int n, int r, int m) {\n    return mod_C(n + r - 1, r, m);\n}\n\nsigned main() {\n    mod_fact(2700000, mod);\n    cin >> N >> M;\n    int ans = mod_H(N, 3 * M, mod);\n    for (int i = 0; i < M; i++) {\n        ans = (ans + mod - (mod_H(N - 1, i, mod) * N % mod)) % mod;\n    }\n    cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 998244353\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\nvector<ll> factmemo, factmemoInv;\nll factmemoMod = -1;\n\nll factorial(int n, int M){\n  if(n <= 1) return 1;\n  if(factmemoMod == M) return factmemo[n];\n\n  ll res = 1;\n  for(int i=1; i<=n; i++) res = res * i % M;\n  return res;\n}\n\nll power(int k, int n, int M){\n  if(n == 0) return 1;\n  if(n == 1) return (ll)k;\n\n  ll res = power(k, n/2, M);\n\n  res = res * res % M;\n  return n%2 == 1 ? res * k % M : res;\n}\n\nvoid initFactorial(int n, int M){\n  factmemo.assign(n+1, 0);\n  factmemoInv.assign(n+1, 0);\n  factmemoMod = M;\n  factmemo[0] = 1;\n  for(int i=1;i<=n;i++) factmemo[i] = factmemo[i-1] * i % M;\n  factmemoInv[n] = power(factmemo[n], M-2, M);\n  for(int i=n;i>0;i--) factmemoInv[i-1] = factmemoInv[i] * i % M;\n}\n\n//nCm nPm nHm (mod M)\n\n/*Combination*/\nll C(int n, int m, int M){\n  if(n < m) return 0;\n  if(m == 0 || n == m) return 1;\n\n  debug(n);\n\n  if(factmemoMod == M)\n    return factmemo[n] * factmemoInv[m] % M * factmemoInv[n-m] % M;\n\n  ll numer = factorial(n, M);\n  ll denom = factorial(m, M) * factorial(n-m, M) % M;\n\n  denom = power((int)denom, M-2, M);\n\n  return numer * denom % M;\n}\n/*Permutation*/\nll P(int n, int m, int M){\n  if(n < m) return 0;\n  if(m == 0) return 1;\n\n  if(factmemoMod == M)\n    return factmemo[n] * factmemoInv[n-m] % M;\n\n  ll numer = factorial(n, M);\n  ll denom = factorial(n-m, M);\n\n  denom = power((int)denom, M-2, M);\n\n  return numer * denom % M;\n}\n/*Combination with Repetitions*/\nll H(int n, int m, int M){\n  if(n == 0 && m == 0) return 1;\n  return C(n+m-1, m, M);\n}\n\n\n\nint main(){\n  int N, M;\n\n  cin >> N >> M;\n\n  ll all = 0;\n  ll minus = 0;\n\n  initFactorial(N*2 + M*2 + 1, mod);\n\n  for(int i=0; i<=N; i++) {\n    if (M%2 != i%2 || i > M) continue;\n\n    int P = i; // 1\n    int Q = (M - i)/2; // 1+1\n    int R = M; // 2\n\n    // P, Q + R\n\n    int S = Q + R;\n\n    debug(S);\n\n    all += C(N, P, mod) * C(N-1+S, N-1, mod) % mod;\n    minus += C(N, P, mod) * C(P, 1, mod) % mod * C((N-1)+(S-M), N-1, mod) % mod;\n    minus += C(N, P, mod) * C(N-P, 1, mod) % mod * C((N-1)+(S-(M+1)), N-1, mod) % mod;\n  }\n\n  all %= mod;\n  minus %= mod;\n\n  cout << (all + mod - minus) % mod << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//雪花飄飄北風嘯嘯\n//天地一片蒼茫\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n#define ll long long\n#define ii pair<ll,ll>\n#define iii pair<ii,ll>\n#define fi first\n#define se second\n#define endl '\\n'\n#define debug(x) cout << #x << \" is \" << x << endl;\n\n#define rep(x,start,end) for(auto x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n\nll MAX(ll a){return a;}\nll MIN(ll a){return a;}\ntemplate<typename... Args>\nll MAX(ll a,Args... args){return max(a,MAX(args...));}\ntemplate<typename... Args>\nll MIN(ll a,Args... args){return min(a,MIN(args...));}\n\n#define indexed_set tree<ll,null_type,less<ll>,rb_tree_tag,tree_order_statistics_node_update>\n\nmt19937 rng(chrono::system_clock::now().time_since_epoch().count());\n\nconst int MOD=1000000007;\n\nll qexp(ll b,ll p,int m){\n    ll res=1;\n    while (p){\n        if (p&1) res=(res*b)%m;\n        b=(b*b)%m;\n        p>>=1;\n    }\n    return res;\n}\n\nll inv(ll i){\n\treturn qexp(i,MOD-2,MOD);\n}\n\nll fac[2000005];\nll ifac[2000005];\n\nll nCk(int i,int j){\n\tif (i<j) return 0; //big bruh\t\n\t\n\treturn fac[i]*ifac[j]%MOD*ifac[i-j]%MOD;\n}\n\nll fix(ll i){\n\ti%=MOD;\n\t\n\tif (i<0) i+=MOD;\n\t\n\treturn i;\n}\n\nll dist(int i,int j){ //distribute j things among i ppl\n\treturn nCk(i+j-1,i-1);\n}\n\nint n,m;\n\nll comp[1000005];\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\t\n\tfac[0]=1;\n\trep(x,1,2000005) fac[x]=fac[x-1]*x%MOD;\n\trep(x,0,2000005) ifac[x]=inv(fac[x]);\n\t\n\tcin>>n>>m;\n\t\n\tcomp[0]=n*dist(n-1,0)%MOD;\n\trep(x,1,1000005) comp[x]=(comp[x-1]+n*dist(n-1,x))%MOD;\n\t\n\tll ans=0;\n\tfor (int x=m;x>=0;x-=2) if (x<=n){\n\t\tint k=(3*m-x)/2;\n\t\t//cout<<k<<\" \"<<x<<endl;\n\t\t\n\t\t//each number is form 2A+B\n\t\t\n\t\t//case 1: there exists a number with A=m\n\t\tans=fix(ans+n*dist(n-1,k-m)%MOD*nCk(n-1,x));\n\t\t\n\t\t//case 2: bigest number <2m\n\t\tans=fix(ans+(dist(n,k)-comp[k-m])*nCk(n,x));\n\t\n\t\t//cout<<ans<<endl;\n\t}\n\t\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll mod = 998244353;\nconst int nax = 4e6+10;\nll fac[nax], inv[nax], ifac[nax];\nll ncr(int n, int k) {\n  if (n < 0 || k < 0 || k > n) return 0;\n  return fac[n]*ifac[k]%mod*ifac[n-k]%mod;\n}\n\nint main() {\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  fac[0] = ifac[0] = 1;\n  for (int i = 1; i < nax; i++) {\n    fac[i] = fac[i-1]*i%mod;\n    inv[i] = i > 1 ? mod-(mod/i)*inv[mod%i]%mod : 1;\n    ifac[i] = ifac[i-1]*inv[i]%mod;\n    assert(fac[i]*ifac[i]%mod == 1);\n  }\n  ll ans = 0;\n  for (int k = 0; k <= m && k <= n; k++) {\n    if (k%2 != m%2) continue;\n    int s = (3*m-k)/2+n;\n    ll r = ncr(s-1,n-1);\n    (r -= k*ncr(s-1-m,n-1)) %= mod;\n    (r -= (n-k)*ncr(s-1-(m+1),n-1)) %= mod;\n    (ans += ncr(n,k)*r) %= mod;\n  }\n  cout << (ans+mod)%mod << endl;\n  return 0;\n\n  set<vector<int>> seen;\n  for (int i = 0; i < 3; i++)\n    for (int j = 0; j < 3; j++) {\n      if (i == j) continue;\n      for (int k = 0; k < 3; k++)\n\tfor (int l = 0; l < 3; l++) {\n\t  if (k == l) continue;\n\t  vector<int> v(3,0);\n\t  v[i] += 2;\n\t  v[j] += 1;\n\t  v[k] += 2;\n\t  v[l] += 1;\n\t  seen.insert(v);\n\t}\n    }\n  for (auto v : seen) {\n    if (v[0]%2 + v[1]%2 + v[2]%2 == 0) {\n      for (int i : v) cout << i << ' '; cout << endl;\n    }\n  }\n  cout << seen.size() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#define MOD 998244353\n#define mkp make_pair\ntypedef long long ll;\nusing namespace std;\n\n#define MAX_N 1000010\nll inv[MAX_N+10],fac[MAX_N+10],ifac[MAX_N+10];\n\nvoid setComb(){\n  inv[0]=1;inv[1]=1;fac[1]=1;ifac[1]=1;fac[0]=1;ifac[0]=1;\n  for(int i=2;i<MAX_N;i++){\n    inv[i]=(-MOD/i)*inv[MOD%i]%MOD;\n    fac[i]=fac[i-1]*i%MOD;\n    ifac[i]=ifac[i-1]*inv[i]%MOD;\n\n    inv[i]=(inv[i]+MOD)%MOD;\n    fac[i]=(fac[i]+MOD)%MOD;\n    ifac[i]=(ifac[i]+MOD)%MOD;\n  }\n  return;\n}\n\nll comb(ll n,ll k){\n  if(n<k||n<0||k<0) return 0;\n  else return ((fac[n]*ifac[k]%MOD*ifac[n-k]%MOD+MOD)%MOD);\n}\n\nll hcomb(ll n,ll r){\n  if(n==0&&r==0) return 1;\n  else if(n<0||r<0) return 0;\n  else return comb(n+r-1,r);\n}\n\nll mod_pow(ll x,ll n){\n  x%=MOD;\n  ll res=1;\n  while(n>0){\n    if(n&1) res=res*x%MOD;\n    x=x*x%MOD;\n    n>>=1;\n  }\n  return res;\n}\n\nvoid add(ll &a,ll b){\n  a=(a+b)%MOD;\n}\n\nvoid mul(ll &a,ll b){\n  a%=MOD;b%=MOD;\n  a=a*b%MOD;\n}\n\nint main(){\n  ll N,M;\n  cin>>N>>M;\n\n  setComb();\n\n  ll nans=0;\n  for(ll k=0;k<M;k++){\n    ll res=hcomb(N-1,k);\n    mul(res,N);\n    add(nans,res);\n  }\n\n  ll ans=0;\n  for(ll k=0;k<=min(N,M);k++){\n    if(k%2!=M%2) continue;\n    ll res=hcomb(N,(3*M-k)/2);\n    mul(res,comb(N,k));\n    add(ans,res);\n  }\n\n  add(ans,-nans+MOD);\n  add(ans,MOD);\n  cout<<ans<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n问题等价于求长为 n 的满足一下三个条件的数列的个数：\n\n1. 所有值的和为 s1 = 3m\n2. 奇数的个数不超过 s2 = m\n3. 最大的数不超过 s3 = 2m\n\n先考虑第一个限制，相当于把 s1 个球放进 n 个盒子，方案数为 f1(s1, n) = C(n + s1, s1)。\n\n再考虑第二个限制，设 f2(n, m, k) 为长度为 n ，和为 m ，奇数不超过 k 个的方案数，\n枚举奇数个数 i ，然后把这 i 个奇数减 1 弄成偶数，\n那么 i 的贡献就是 C(n, i) * f1((m - i) / 2, n - 1) 。\n\n最后考虑第三个限制，由于和为 3m ，超过 2m 的数最多只有一个，\n简单容斥，钦定一个数大于 2m ，那么贡献就是 - n * f2(n, m, m) ，\n但事实上这也算进去了该数恰好为 2m 的情况，继续容斥，贡献为 n * f2(n - 1, m, m) ，\n那么答案 f3(n, m) = f2(n, 3m, m) - n * (f2(n, m, m) - f2(n - 1, m, m)) 。\n#endif\n#include <cstdio>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long lolong;\n\ninline int input() { int x; scanf(\"%d\", &x); return x; }\n\nconst int maxn = 3000005, mod = 998244353;\nlolong fac[maxn];\nlolong inv[maxn];\nlolong ifac[maxn];\n\ninline lolong c(int n, int m) {\n\treturn fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nlolong f(int n, int m, int k) {\n\tlolong res = 0;\n\tfor(int i = 0; i <= k; i ++)\n\t\tif(!((m - i) & 1))\n\t\t\tres += c(n, i) * c((m - i) / 2 + n - 1, (m - i) >> 1) % mod;\n\treturn res % mod;\n}\n\nint main() {\n\tfac[0] = 1;\n\tfor(int i = 1; i < maxn; i ++)\n\t\tfac[i] = fac[i - 1] * i % mod;\n\n\tinv[1] = 1;\n\tfor(int i = 2; i < maxn; i ++)\n\t\tinv[i] = (mod - mod / i) * inv[mod % i] % mod;\n\n\tifac[0] = 1;\n\tfor(int i = 1; i < maxn; i ++)\n\t\tifac[i] = ifac[i - 1] * inv[i] % mod;\n\n\tint n = input(), m = input();\n\tprintf(\"%lld\\n\",\n\t\t\t(f(n, m * 3, m) + mod -\n\t\t\t n * (f(n, m, m) + mod -\n\t\t\t\t f(n - 1, m, m)) % mod) % mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e6+100,mod=998244353;\nll power(ll n,ll k){\n    if (k==0) return 1;\n    if (k%2==1){\n        ll x=power(n,k/2);\n        return x*x%mod*n%mod;\n    }\n    ll x=power(n,k/2);\n    return x*x%mod;\n}\nll fac[N],fm[N];\nll ent(ll k,ll n){\n    if (k<0 || k>n) return 0;\n    if (k==0 || k==n) return 1;\n    return fac[n]*fm[k]%mod*fm[n-k]%mod;\n}\nint32_t main(){\n    fac[0]=1;\n    for (int i=1;i<N;i++){\n        fac[i]=fac[i-1]*i%mod;\n        fm[i]=power(fac[i],mod-2);\n    }\n //   cout << ent(3,5) << endl;\n    ll ans=0;\n    ll n,m;\n    cin >> n >> m;\n    ll z=3*m;\n    for (int i=0;i<=min(n,m);i++){\n        ll t=z-i;\n        if (t%2==1) continue;\n        ans+=ent(i,n)*ent(n-1,n-1+t/2)%mod;\n    }\n    for (int i=2*m+1;i<=3*m;i++){\n        ll t=z-i;\n        ans-=n*ent(n-2,n-2+t)%mod;\n        ans+=mod;\n        ans%=mod;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong N,M,mod=998244353;\nlong F[1<<25],I[1<<25];\nlong power(long a,long b){return b?power(a*a%mod,b/2)*(b%2?a:1)%mod:1;}\nlong C(long a,long b)\n{\n\treturn a<b||a<0||b<0?0:F[a]*I[b]%mod*I[a-b]%mod;\n}\nlong H(long a,long b){return a<0?0:C(a+b-1,b-1);}\nmain()\n{\n\tcin>>N>>M;\n\tlong T=2*M+N;\n\tF[0]=1;\n\tfor(long i=1;i<T;i++)F[i]=F[i-1]*i%mod;\n\tI[T-1]=power(F[T-1],mod-2);\n\tfor(long i=T-1;i--;)I[i]=I[i+1]*(i+1)%mod;\n\tlong ans=0;\n\tfor(int i=0;i<=N&&i<=M;i++)\n\t{\n\t\tif((3*M-i)%2==1)continue;\n\t\t(ans+=C(N,i)*H((3*M-i)/2,N)%mod)%=mod;\n\t}\n\tlong ret=0;\n\tfor(int i=1;i<=N&&i<=M;i++)\n\t{\n\t\tif((M-i)%2==1)continue;\n\t\t(ret+=C(N-1,i-1)*H((M-i)/2,N)%mod)%=mod;\n\t}\n\tfor(int i=0;i<=N-1&&i<=M;i++)\n\t{\n\t\tif((M-i)%2==1)continue;\n\t\t(ret+=C(N-1,i)*H((M-i-2)/2,N)%mod)%=mod;\n\t}\n\tcout<<(ans-ret*N%mod+mod)%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nconstexpr double PI = 3.14159265358979323846;\nmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr ll mod17 = 1e9+7;\nconstexpr ll mod19 = 1e9+9;\nconstexpr ll mod9 = 998244353;\n\n// Mod int library\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\n\ntemplate<ll mod=mod17>\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\n\ntemplate<ll mod=mod17>\nistream& operator>>(istream&i,mint<mod>&a){i>>a.x;return i;}\n\ntemplate<ll mod=mod17>\nostream& operator<<(ostream&o,const mint<mod>&a){o<<a.x;return o;}\n\ntemplate<ll mod=mod17>\nmint<mod> mod_pow(mint<mod> a, ll x) {\n  mint<mod> res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\n\ntemplate<ll mod=mod17>\nclass combination {\n    // factorial\n    public: vector<mint<mod>> fact;\n    public: vector<mint<mod>> inv;\n\n    combination(int n) {\n      fact.resize(n + 1);\n      inv.resize(n + 1);\n      fact[0] = 1;\n      for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i;\n      inv[n] = mint<mod>(1) / fact[n];\n      for (int i = n - 1; i >= 0; i--) inv[i] = inv[i + 1] * (i + 1);\n    }\n\n    // nCr\n    public: mint<mod> get(int n, int r) {\n      if (n < r || n < 0 || r < 0) return 0;\n      return fact[n]*inv[r]*inv[n-r];\n    }\n    // nPr\n    public: mint<mod> p(int n, int r) {\n      if (n < r || n < 0) return 0;\n      return fact[n]*inv[n-r];\n    }\n};\n\n\nclass CGP2 {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      int n, m; cin >> n >> m;\n      combination<mod9> comb(3000000);\n      auto ans = comb.get(3*m+n-1, n-1);\n      for(int i=m-1; i>=0; i--) {\n        ans -= comb.get(i+n-2, n-2)*n;\n      }\n      for(int i=m+1; i<=n; i++) {\n        if ((3*m-i)%2!=0) continue;\n        int r = (3*m-i)/2;\n        if (r<0) continue;\n        ans -= comb.get(r+n-1, n-1)*comb.get(n, i);\n      }\n      cout << ans << endl;\n    }\n};\n\nsigned main() {\n  SPEED;\n  CGP2 solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = long long;\n\n#define fs first\n#define sc second\n\n\n\ntemplate<LL mod>\nstruct modint {\n    LL val;\n    modint(LL val=0) : val(((val % mod) + mod) % mod) {}\n\n    const modint operator+() const { return *this; }\n    const modint operator-() const { return (-val + mod) % mod; }\n    const modint inv() const { return pow(mod-2); }\n\n    modint& operator+=(const modint& rhs) {\n        (val += rhs.val) %= mod;\n        return *this;\n    }\n    modint& operator-=(const modint& rhs) {\n        return *this += -rhs;\n    }\n    modint& operator*=(const modint& rhs) {\n        (val *= rhs.val) %= mod;\n        return *this;\n    }\n    modint& operator/=(const modint& rhs) {\n        return *this *= rhs.inv();\n    }\n\n    const modint operator+(const modint& rhs) const {\n        return modint(*this) += rhs;\n    }\n    const modint operator-(const modint& rhs) const {\n        return modint(*this) -= rhs;\n    }\n    const modint operator*(const modint& rhs) const {\n        return modint(*this) *= rhs;\n    }\n    const modint operator/(const modint& rhs) const {\n        return modint(*this) /= rhs;\n    }\n\n    const modint pow(LL n) const {\n        modint ret = 1, tmp = val;\n        while (n > 0) {\n            if (n & 1) ret *= tmp;\n            tmp *= tmp; n >>= 1;\n        }\n        return ret;\n    }\n\n    bool operator==(const modint& rhs) const { return val == rhs.val; }\n    bool operator!=(const modint& rhs) const { return !(*this == rhs); }\n\n    friend const modint operator+(const LL& lhs, const modint& rhs) {\n        return modint(lhs) + rhs;\n    }\n    friend const modint operator-(const LL& lhs, const modint& rhs) {\n        return modint(lhs) - rhs;\n    }\n    friend const modint operator*(const LL& lhs, const modint& rhs) {\n        return modint(lhs) * rhs;\n    }\n    friend const modint operator/(const LL& lhs, const modint& rhs) {\n        return modint(lhs) / rhs;\n    }\n\n    friend bool operator==(const LL& lhs, const modint& rhs) {\n        return modint(lhs) == rhs;\n    }\n    friend bool operator!=(const LL& lhs, const modint& rhs) {\n        return modint(lhs) != rhs;\n    }\n\n    friend ostream& operator<<(ostream& os, const modint& a) {\n        return os << a.val;\n    }\n    friend istream& operator>>(istream& is, modint& a) {\n        LL tmp; is >> tmp;\n        a = tmp;\n        return is;\n    }\n};\n\n\n\ntemplate<typename Ring>\nstruct Fact {\n\n    vector<Ring> fact;\n\n    Fact(int n) {\n        fact.resize(n+1);\n        fact[0] = Ring{1};\n        for (int i = 1; i <= n; ++i) {\n            fact[i] = fact[i-1] * Ring{i};\n        }\n    }\n\n    Ring operator[](int i) {\n        return fact[i];\n    }\n};\n\n\ntemplate<typename Field>\nstruct Comb {\n    Fact<Field> fact;\n\n    Comb(int n) : fact(n) {}\n\n    Field operator()(int n, int r) {\n        if (n < 0 || n-r < 0 || r < 0) {\n            return Field{0};\n        }\n        return fact[n] / (fact[n-r] * fact[r]);\n    }\n};\n\nconst LL MOD = 998244353;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    LL N, M;\n    cin >> N >> M;\n\n    using Int = modint<MOD>;\n\n    auto comb = Comb<Int>(N+3*M);\n\n    Int ans = 0;\n\n    for (LL k = M % 2; k <= min(N,M); k += 2) {\n\n        ans += comb(N,k) * comb(N+(3*M-k)/2-1,N-1);\n\n        ans -= comb(N,k) * (\n                k * comb(N+((3*M-k)/2-M)-1,N-1) +\n                (N-k) * comb(N+((3*M-k)/2-(M+1))-1,N-1)\n                );\n    }\n\n    cout << ans << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\nll mod=998244353;\n\nll fac[3000010];\n \nll modinv(ll a){\n    ll b=mod,u=1,v=0;\n    while(b){\n        ll t=a/b;\n        a-=t*b; swap(a,b);\n        u-=t*v; swap(u,v);\n        }\n        u%=mod;\n        if(u<0) u+=mod;\n    return u;\n}\n \nvoid modfac(){\n    fac[0]=1;\n    for(ll i=1;i<3000010;i++){\n        fac[i]=(fac[i-1]*i)%mod;\n    }\n}\n \nll modperm(ll n,ll k){\n    if(n<0||k<0||n<k) return 0;\n    else return (fac[n]*modinv(fac[n-k]))%mod;\n}\n \nll modcomb(ll n,ll k){\n    if(n<0||k<0||n<k) return 0;\n    else return ((fac[n]*modinv(fac[k]))%mod*modinv(fac[n-k]))%mod;\n}\n\nll modhom(ll n,ll k){\n  if(n==0&&k==0) return 1;\n  else if(n<0||k<0) return 0;\n  else return modcomb(n+k-1,k);\n}\n \nll modpow(ll a,ll b){\n  ll ans=1;\n  a%=mod;\n  while(b){\n    if(b&1) ans=ans*a%mod;\n    a=a*a%mod;\n    b>>=1;\n  }\n  return ans;\n}\n\nint main(){\n  modfac();\n  ll n,m;\n  cin >> n >> m;\n  ll ans=modhom(n,3*m);\n  for(ll i=m+1;i<=n;i++){\n    if((3*m-i)%2==0){\n      ans=(ans-modcomb(n,i)*modhom(n,(3*m-i)/2)%mod+mod)%mod;\n      ans=(ans-modcomb(n,i)*modhom(n,(m-i)/2)%mod*n%mod+mod)%mod;\n      ans=(ans-modcomb(n-1,i)*modhom(n-1,(m-i)/2)%mod*n%mod+mod)%mod;\n    }\n  }\n  ans=(ans-modhom(n,m)*n%mod)%mod;\n  ans=(ans+modhom(n-1,m)*n%mod)%mod;\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include <cstddef>\n#include <cstdint>\n#include <iostream>\n#include <vector>\n\nnamespace n91 {\n\nusing i8 = std::int_fast8_t;\nusing i32 = std::int_fast32_t;\nusing i64 = std::int_fast64_t;\nusing u8 = std::uint_fast8_t;\nusing u32 = std::uint_fast32_t;\nusing u64 = std::uint_fast64_t;\nusing isize = std::ptrdiff_t;\nusing usize = std::size_t;\n\nconstexpr usize operator\"\" _z(unsigned long long x) noexcept {\n  return static_cast<usize>(x);\n}\n\nclass rep {\n  const usize f, l;\n\npublic:\n  class itr {\n    friend rep;\n    usize i;\n    constexpr itr(const usize x) noexcept : i(x) {}\n\n  public:\n    void operator++() noexcept { ++i; }\n    constexpr usize operator*() const noexcept { return i; }\n    constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n  };\n  constexpr rep(const usize first, const usize last) noexcept\n      : f(first), l(last) {}\n  constexpr itr begin() const noexcept { return itr(f); }\n  constexpr itr end() const noexcept { return itr(l); }\n};\nclass revrep {\n  const usize f, l;\n\npublic:\n  class itr {\n    friend revrep;\n    usize i;\n    constexpr itr(usize x) noexcept : i(x) {}\n\n  public:\n    void operator++() noexcept { --i; }\n    constexpr usize operator*() const noexcept { return i; }\n    constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n  };\n  constexpr revrep(usize first, usize last) noexcept : f(--first), l(--last) {}\n  constexpr itr begin() const noexcept { return itr(l); }\n  constexpr itr end() const noexcept { return itr(f); }\n};\ntemplate <class T> using vec_alias = std::vector<T>;\ntemplate <class T> auto md_vec(const usize n, const T &value) {\n  return std::vector<T>(n, value);\n}\ntemplate <class... Args> auto md_vec(const usize n, Args... args) {\n  return std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n}\ntemplate <class T> constexpr T difference(const T &a, const T &b) {\n  return a < b ? b - a : a - b;\n}\ntemplate <class T> T scan() {\n  T ret;\n  std::cin >> ret;\n  return ret;\n}\n\n} // namespace n91\n\n#include <cstdint>\n\nnamespace n91 {\n\nconstexpr std::uint_fast64_t totient(std::uint_fast64_t x) noexcept {\n  using u64 = std::uint_fast64_t;\n  u64 ret = x;\n  for (u64 i = static_cast<u64>(2); i * i <= x; ++i) {\n    if (x % i == static_cast<u64>(0)) {\n      ret -= ret / i;\n      x /= i;\n      while (x % i == static_cast<u64>(0)) {\n        x /= i;\n      }\n    }\n  }\n  if (x != static_cast<u64>(1)) {\n    ret -= ret / x;\n  }\n  return ret;\n}\n\ntemplate <std::uint_fast64_t Modulus,\n          std::uint_fast64_t InverseExp =\n              totient(Modulus) - static_cast<u64>(1)>\nclass modint {\n  using u64 = std::uint_fast64_t;\n\n  static_assert(Modulus < static_cast<u64>(1) << static_cast<u64>(32),\n                \"Modulus must be less than 2**32\");\n\n  u64 a;\n\n  constexpr modint &negate() noexcept {\n    if (a != static_cast<u64>(0)) {\n      a = Modulus - a;\n    }\n    return *this;\n  }\n\npublic:\n  constexpr modint(const u64 x = static_cast<u64>(0)) noexcept\n      : a(x % Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+() const noexcept { return modint(*this); }\n  constexpr modint operator-() const noexcept { return modint(*this).negate(); }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = InverseExp;\n    while (exp) {\n      if (exp % static_cast<u64>(2) != static_cast<u64>(0)) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= static_cast<u64>(2);\n    }\n    return *this;\n  }\n  constexpr bool operator==(const modint rhs) const noexcept {\n    return a == rhs.a;\n  }\n  constexpr bool operator!=(const modint rhs) const noexcept {\n    return a != rhs.a;\n  }\n};\n\n} // namespace n91\n\n#include <vector>\n\nnamespace n91 {\n\ntemplate <class T> class fact_binom {\npublic:\n  using value_type = T;\n  using container_type = std::vector<value_type>;\n  using size_type = typename container_type::size_type;\n\nprivate:\n  container_type factrial, inv_fact;\n\npublic:\n  fact_binom() : factrial(), inv_fact() {}\n  explicit fact_binom(const size_type n) : factrial(n + 1), inv_fact(n + 1) {\n    factrial[0] = static_cast<value_type>(1);\n    for (size_type i = 0; i != n; ++i) {\n      factrial[i + 1] = static_cast<value_type>(i + 1) * factrial[i];\n    }\n    inv_fact[n] = static_cast<value_type>(1) / factrial[n];\n    for (size_type i = n; i != 0; --i) {\n      inv_fact[i - 1] = inv_fact[i] * static_cast<value_type>(i);\n    }\n  }\n\n  value_type operator()(const size_type n, const size_type r) const {\n    return factrial[n] * inv_fact[r] * inv_fact[n - r];\n  }\n};\n\n} // namespace n91\n\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <set>\n#include <utility>\n\nnamespace n91 {\n\nvoid main_() {\n  using mint = modint<998244353>;\n  const usize n = scan<usize>();\n  const usize m = scan<usize>();\n  const fact_binom<mint> binom((n + m) * 4_z + 1_z);\n  const auto h = [&binom](const usize n, const usize m) {\n    return binom(n + m - 1_z, m);\n  };\n\n  mint ans;\n\n  const auto f = [&h, &binom](const usize n, const usize all,\n                              const usize odd_max) {\n    mint ret;\n    for (const auto odd : rep(0_z, odd_max + 1_z)) {\n      if (all < odd) {\n        break;\n      }\n      if (n < odd) {\n        break;\n      }\n      if ((all - odd) % 2_z == 1_z) {\n        continue;\n      }\n      const usize even = (all - odd) / 2_z;\n      ret += h(n, even) * binom(n, odd);\n    }\n    return ret;\n  };\n\n  ans += f(n, m * 3_z, m);\n\n  ans -= f(n - 1_z, m - 1_z, m - 1_z) * static_cast<mint>(n);\n\n  if (m >= 2_z)\n    ans -= f(n, m - 2_z, m) * static_cast<mint>(n);\n\n  std::cout << ans.value() << std::endl;\n}\n\n} // namespace n91\n\nint main() {\n  n91::main_();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return (rng() % (y+1-x)) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\ntypedef long long ll; \ntypedef long double ld;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\ntypedef pair<ll,ll>pi; typedef pair<ll,pi>spi; typedef pair<pi,pi>dpi;\n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (2000006)\nll n, m, mod = 998244353, f[MAXN], inv[MAXN];\nint main(){\n\tFAST\n\tcin>>n>>m;\n\tauto qexp=[&](ll x,ll e){\n\t\tll sum=1;\n\t\twhile(e){\n\t\t\tif(e&1) sum*=x, sum%=mod;\n\t\t\tx*=x,x%=mod;\n\t\t\te>>=1;\n\t\t}\n\t\treturn sum;\n\t};\n\tf[0]=1; FOR(i,1,MAXN-1) f[i]=f[i-1]*i%mod;\n\tinv[MAXN-1] = qexp(f[MAXN-1], mod-2); DEC(i,MAXN-2,0) inv[i]=inv[i+1]*(i+1)%mod;\n\tauto C=[&](ll n,ll k){assert(n>=k);\n\t\treturn f[n] * inv[k] % mod * inv[n-k] % mod;\n\t};\n\tll ans=C(3*m+(n-1), n-1);\n\tcerr<<ans<<'\\n';\n\tans -= n * C(3*m-(2*m+1)+(n-1), n-1) % mod, ans += mod, ans %= mod;\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#define mod 998244353\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0' && ch<='9')x=x*10+ch-'0',ch=getchar();\n    return x*f;\n}\ninline void write(int x)\n{\n    if(x<0)putchar('-'),x=-x;\n    if(x>9)write(x/10);\n    putchar(x%10+'0');\n}\ninline void pr1(int x){write(x),putchar(' ');}\ninline void pr2(int x){write(x),puts(\"\");}\nint fac[2500010],inv[2500010];\ninline int power(int a,int b)\n{\n\tint ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=1LL*ans*a%mod;\n\t\ta=1LL*a*a%mod;\n\t\tb>>=1;\n\t}return ans;\n}\ninline int C(int n,int m)\n{\n\tif(n<0 || m<0)return 0;\n\treturn 1LL*fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main()\n{\n    //freopen(\"a.in\",\"r\",stdin);\n    //freopen(\"a.out\",\"w\",stdout);\n    fac[0]=1;\n    for(int i=1;i<=2500000;i++)fac[i]=1LL*fac[i-1]*i%mod;inv[2500000]=power(fac[2500000],mod-2);\n    for(int i=2500000;i>=1;i--)inv[i-1]=1LL*inv[i]*i%mod;\n    int n=read(),m=read(),ans;\n    ans=C(n-1+3*m,n-1);\n    for(int i=m+1;i<=n;i++)(ans-=1LL*C(n,i)*C(3*m-i+n-i-1,n-i-1)%mod-mod)%=mod;\n    for(int i=2*m+1;i<=3*m;i++)(ans-=1LL*n*C(3*m-i+n-2,n-2)%mod-mod)%=mod;\n    pr2(ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n\ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQR = priority_queue<T,vector<T>,greater<T>>;\n\nconstexpr long long MOD = (long long)1e9 + 7;\nconstexpr long long MOD2 = 998244353;\nconstexpr long long HIGHINF = (long long)1e18;\nconstexpr long long LOWINF = (long long)1e15;\nconstexpr long double PI = 3.1415926535897932384626433L;\n\ntemplate <class T> vector<T> multivector(size_t N,T init){return vector<T>(N,init);}\ntemplate <class... T> auto multivector(size_t N,T... t){return vector<decltype(multivector(t...))>(N,multivector(t...));}\ntemplate <class T> void corner(bool flg, T hoge) {if (flg) {cout << hoge << endl; exit(0);}}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const map<T, U>&obj) {o << \"{\"; for (auto &x : obj) o << \" {\" << x.first << \" : \" << x.second << \"}\" << \",\"; o << \" }\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const set<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const multiset<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&obj) {o << \"{\"; for (int i = 0; i < (int)obj.size(); ++i)o << (i > 0 ? \", \" : \"\") << obj[i]; o << \"}\"; return o;}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const pair<T, U>&obj) {o << \"{\" << obj.first << \", \" << obj.second << \"}\"; return o;}\ntemplate <template <class tmp>  class T, class U> ostream &operator<<(ostream &o, const T<U> &obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr)o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\nvoid print(void) {cout << endl;}\ntemplate <class Head> void print(Head&& head) {cout << head;print();}\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) {cout << head << \" \";print(forward<Tail>(tail)...);}\ntemplate <class T> void chmax(T& a, const T b){a=max(a,b);}\ntemplate <class T> void chmin(T& a, const T b){a=min(a,b);}\nvoid YN(bool flg) {cout << (flg ? \"YES\" : \"NO\") << endl;}\nvoid Yn(bool flg) {cout << (flg ? \"Yes\" : \"No\") << endl;}\nvoid yn(bool flg) {cout << (flg ? \"yes\" : \"no\") << endl;}\n\n\n//Combination Mod\nclass CombinationMod {\npublic:\n\tvector<long long> fac,finv,inv;\n\tlong long mod;\n\n\tCombinationMod(int N,long long mod) : fac(N + 1), finv(N + 1), inv(N + 1), mod(mod) {\n\t\tfac[0] = fac[1] = finv[0] = finv[1] = inv[1] = 1;\n\t\tfor (int i = 2; i <= N; ++i) {\n\t\t\tfac[i] = fac[i - 1] * i % mod;\n\t\t\tinv[i] = mod - inv[mod%i] * (mod / i) % mod;\n\t\t\tfinv[i] = finv[i - 1] * inv[i] % mod;\n\t\t}\n\t}\n\t\n\tlong long num(int n, int k) {\n\t\treturn ((n < 0 || k < 0 || n < k) ? 0 : fac[n] * (finv[k] * finv[n - k] % mod) % mod);\n\t}\n};\n\n//verify https://atcoder.jp/contests/abc021/tasks/abc021_d\n\n\ntemplate<long long mod> class ModInt {\npublic:\n\tlong long x;\n\tModInt():x(0) {\n\t\t// do nothing\n\t}\n\tModInt(long long y) : x(y>=0?(y%mod): (mod - (-y)%mod)%mod) {\n\t\t// do nothing\n\t}\n\tModInt &operator+=(const ModInt &p) {\n\t\tif((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator+=(const long long y) {\n        ModInt p(y);\n\t\tif((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator+=(const int y) {\n        ModInt p(y);\n\t\tif((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(const ModInt &p) {\n\t\tif((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(const long long y) {\n        ModInt p(y);\n\t\tif((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(const int y) {\n        ModInt p(y);\n\t\tif((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tModInt &operator*=(const ModInt &p) {\n\t\tx = (x * p.x % mod);\n\t\treturn *this;\n\t}\n\tModInt &operator*=(const long long y) {\n        ModInt p(y);\n\t\tx = (x * p.x % mod);\n\t\treturn *this;\n\t}\n\tModInt &operator*=(const int y) {\n        ModInt p(y);\n\t\tx = (x * p.x % mod);\n\t\treturn *this;\n\t}\n\tModInt &operator/=(const ModInt &p) {\n\t\t*this *= p.inv();\n\t\treturn *this;\n\t}\n\tModInt &operator/=(const long long y) {\n        ModInt p(y);\n\t\t*this *= p.inv();\n\t\treturn *this;\n\t}\n\tModInt &operator/=(const int y) {\n        ModInt p(y);\n\t\t*this *= p.inv();\n\t\treturn *this;\n\t}\n\tModInt operator=(const int y) {\n        ModInt p(y);\n        *this = p;\n        return *this;\n    }\n    ModInt operator=(const long long y) {\n        ModInt p(y);\n\t\t*this = p;\n        return *this;\n    }\n\tModInt operator-() const { return ModInt(-x); }\n\tModInt operator++() { \n        x++;\n        if(x>=mod) x-=mod;\n        return *this; \n    }\n\tModInt operator--() { \n        x--;\n        if(x<0) x+=mod;\n        return *this; \n    }\n\tModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\tModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\tModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\tModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\tbool operator==(const ModInt &p) const { return x == p.x; }\n\tbool operator!=(const ModInt &p) const { return x != p.x; }\n\tModInt inv() const {\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile(b > 0) {\n\t\t\tt = a / b;\n\t\t\tswap(a -= t * b, b);\n\t\t\tswap(u -= t * v, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\tModInt pow(long long n) const {\n\t\tModInt ret(1), mul(x);\n\t\twhile(n > 0) {\n\t\t\tif(n & 1) ret *= mul;\n\t\t\tmul *= mul;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\tfriend ostream &operator<<(ostream &os, const ModInt &p) {\n\t\treturn os << p.x;\n\t}\n\tfriend istream &operator>>(istream &is, ModInt &a) {\n\t\tlong long t;\n\t\tis >> t;\n\t\ta = ModInt<mod>(t);\n\t\treturn (is);\n\t}\n};\nusing modint = ModInt<MOD2>;\n\nint main() {\n    ll N,M; cin >> N >> M;\n    CombinationMod CM(N+2*M+10,MOD2);\n    vector<modint> A(M+1,0);\n    for(int i = 1; i <= M; ++i) A[i] = A[i-1] + CM.num(N-2+i-1,N-2);\n    modint ans = 0;\n    for(ll i = 0; i <= min(N,M); ++i) {\n        ll L = M-i;\n        if(L&1) continue;\n        L /= 2;\n        ll K = M + L;\n        modint sum = 0,cnt = 1;\n        cnt *= CM.num(N,i);\n        sum += CM.num(N-1+K,N-1);\n        sum -= A[L]*N;\n        cnt *= sum;\n        cnt -= modint(CM.num(N,i)*CM.num(N-2+L,N-2))*i;\n        ans += cnt;\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX = 2510000;\nconst int mod = 998244353;\n\nll fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % mod;\n        inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n        finv[i] = finv[i - 1] * inv[i] % mod;\n    }\n}\n\n// 二項係数計算\nll COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % mod) % mod;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(20);\n    \n    COMinit();\n    ll n,m;\n    cin>>n>>m;\n    ll ans = COM(3*m+n-1,n-1);\n    // cerr << ans << endl;\n    for(int k=2*m+1;k<=3*m;k++){\n        ll ret = n*COM(3*m-k+n-2,n-2);\n        ret %= mod;\n        // cerr << k << \" \" << ret << endl;\n        ans += mod - ret;\n        ans %= mod;\n    }\n    int x = 1;\n    for(int i=m+1;i<=n;i++){\n        ll ret = COM(n,i);\n        if((m*3-i)%2)continue;\n        ll p = 3*m-i;\n        p /= 2;\n        ret *= COM(n+p-1,n-1);\n        ret %= mod;\n        ans += mod - ret;\n        ans %= mod;\n    }\n    ans %= mod;\n    cout << ans << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n\nusing namespace std;\n\nconst int mod = 998244353;\n\nclass inverse {\n    public:\n    inverse(int n, int mod);\n    ~inverse();\n    long long get_inv(int x);\n    long long get_fact(int x);\n    long long get_invfact(int x);\n    long long get_comb(int x, int y);\n    \n    private:\n    int mod;\n    long long* inv;\n    long long* fact;\n    long long* invfact;\n};\n\ninverse::inverse(int n, int mod) : mod(mod) {\n    inv = (long long *)malloc(sizeof(long long) * (n + 1));\n    fact = (long long *)malloc(sizeof(long long) * (n + 1));\n    invfact = (long long *)malloc(sizeof(long long) * (n + 1));\n    inv[1] = 1;\n    for (int i = 2; i <= n; i++) inv[i] = inv[mod % i] * (mod - mod / i) % mod;\n    fact[0] = invfact[0] = 1;\n    for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i % mod;\n    for (int i = 1; i <= n; i++) invfact[i] = invfact[i - 1] * inv[i] % mod;\n}\n\ninverse::~inverse() {\n    free(inv);\n    free(fact);\n    free(invfact);\n}\n\nlong long inverse::get_inv(int x) {\n    return inv[x];\n}\n\nlong long inverse::get_fact(int x) {\n    return fact[x];\n}\n\nlong long inverse::get_invfact(int x) {\n    return invfact[x];\n}\n\nlong long inverse::get_comb(int x, int y) {\n    return fact[x] * invfact[y] % mod * invfact[x - y] % mod;\n}\n\nint main() {\n    int n, m, i;\n    long long ans;\n    inverse inv(3000000, mod);\n    \n    scanf(\"%d %d\", &n, &m);\n    \n    ans = inv.get_comb(m * 3 + n - 1, n - 1);\n    \n    for (i = m * 2 + 1; i <= m * 3; i++) {\n        ans -= inv.get_comb(m * 3 - i + n - 2, n - 2) * n % mod;\n        if (ans < 0) ans += mod;\n    }\n    \n    for (i = m + 1; i <= m * 3 && i <= n; i++) {\n        if ((m * 3 - i) % 2 == 1) continue;\n        \n        ans -= inv.get_comb((m * 3 - i) / 2 + n - 1, n - 1) * inv.get_comb(n, i) % mod;\n        if (ans < 0) ans += mod;\n    }\n    \n    printf(\"%lld\\n\", ans);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int         long long\n#define pb          push_back\n#define pii         pair<int,int>\n#define vi          vector<int>\n#define vii         vector<pii>\n#define mi          map<int,int>\n#define mii         map<pii,int>\n#define all(a)      (a).begin(),(a).end()\n#define x           first\n#define y           second\n#define sz(x)       (int)x.size()\n#define endl        '\\n'\n#define hell        998244353\n#define rep(i,a,b)  for(int i=a;i<b;i++)\nusing namespace std;\nconst int M=2000006;\nint f[M],inv[M];\nint expo(int base,int exponent,int mod){\n    int ans=1;\n    while(exponent!=0){\n        if(exponent&1) ans=(1LL*ans*base)%mod;\n        base=(1LL*base*base)%mod;\n        exponent>>=1;\n    }\n    return ans%mod;\n}\nvoid compute(){\n    f[0]=1;\n    rep(i,1,M){\n        f[i]=(1LL*i*f[i-1])%hell;\n    }\n    inv[M-1]=expo(f[M-1],hell-2,hell);\n    for(int i=M-2;i>=0;i--){\n        inv[i]=(1LL*(i+1)*inv[i+1])%hell;\n    }\n}\nint C(int n,int r){\n    if(n<r or r<0) return 0;\n    return (1LL*((1LL*f[n]*inv[r])%hell)*inv[n-r])%hell;\n}\nint m;\nint get(int n,int a){\n    if(a%2) return 0;\n    return (C(n+a/2-1,a/2)-n*C(n+a/2-m-2,a/2-m-1)%hell+hell)%hell;\n}\nvoid solve(){\n    compute();\n    int n,ans=0;\n    cin>>n>>m;\n    rep(odd,0,min(n,m)+1){\n        ans=(ans+C(n,odd)*get(n,3*m-odd)%hell)%hell;\n        ans=(ans-odd*get(n-1,m-odd)%hell*C(n,odd)%hell+hell)%hell;\n    }\n    cout<<ans<<endl;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t=1;\n    // cin>>t;\n    while(t--){\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define maxn 4000005\nconst int mod=998244353;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\n#define mp make_pair\n#define pb push_back\n#define ff first\n#define ss second\n\nint n,m;\nint fac[maxn],inv[maxn];\n\ninline int read(){\n    int x=0,f=1; char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nint power(int a,int k){\n\tint ret=1;\n\tfor (;k;k>>=1,a=1ll*a*a%mod) if (k&1) ret=1ll*ret*a%mod;\n\treturn ret;\n}\n\nint C(int n,int m){return n<m?0:1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;}\n\nint main(){\n\tn=read(),m=read(); int mx=n+n+m+m;\n\tfac[0]=inv[0]=1; for (int i=1;i<=mx;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[mx]=power(fac[mx],mod-2); for (int i=mx-1;i;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tint ans=0; int pps=m,ub=m;\n\tif (n<m) ub=n-((m-n)&1),pps+=(m-ub)>>1;\n\tfor (int i=ub;i>=0;i-=2,++pps){\n\t\tint res=C(n,i),num=(C(pps+n-1,n-1)-1ll*(n-i)*C(pps-m+n-2,n-1)-1ll*i*C(pps-m+n-1,n-1))%mod;\n\t\t//\t\tcout<<i<<' '<<res<<' '<<num<<' '<<pps<<' '<<C(pps+n-1,n-1)<<' '<<i<<' '<<C(pps-m+n,n-1)<<endl;\n\t\tans=(ans+1ll*res*num)%mod;\n\t}\n\tans=(ans+mod)%mod;\n\tprintf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<tuple>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n\nstruct mod_fac{\n    private:\n        vector<ll> f,i_f;\n        int n;ll MOD;\n    public:\n        void init(int n,ll m){\n            MOD=m;\n            f.resize(n+1,0);\n            i_f.resize(n+1,0);\n            f[0]=1;\n            rep(i,n){\n                f[i+1]=f[i]*(i+1)%MOD;\n            }\n            i_f[n]=power(f[n],MOD-2);\n            per(i,n){\n                i_f[i]=(i_f[i+1]*(i+1))%MOD;\n            }\n        }\n        ll power(ll a ,ll x){\n            if (x==0) return 1;\n            if (x==1) return a%MOD;\n            if (x==2) return (a*a)%MOD;\n            if (x%2==1) return (a*power(power(a,(x-1)/2),2))%MOD;\n            return (power(power(a,x/2),2))%MOD;\n        }\n        ll fac(int x){\n            return f[x];\n        }\n        ll invfac(int x){\n            return i_f[x];\n        }\n        ll comb(int m,int k){\n            if (m<0 or k<0) return 0;\n            if (m<k) return 0;\n            return (((f[m]*i_f[k])%MOD)*i_f[m-k])%MOD;\n        }\n};\n\nint n,m;\nll a,b,c,d,e;\nmod_fac mo;\n\nll f(int s,int t,int k){\n    ll res=0;\n    rep(i,min(min(k+1,s+1),t+1)){\n        res+=mo.comb(s,i)*mo.comb(s+(t-i)/2,s);\n        res%=mod;\n    }\n    return res;\n}\n\n\nvoid solve(){\n    cin >> n >> m;\n    mo.init(n+(3*m)/2,mod);\n    a=f(n,3*m,m);\n    b=f(n,3*m-1,m);\n    c=f(n-1,m-1,m);\n\n    //cout << a << \" \" << b << \" \" << c << endl;\n\n    ll ans=((a-b)%mod-n*c%mod+2*mod)%mod;\n\n    cout << ans << endl;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nconst ll MOD = 998244353;\nconst int MX = 2000010;\ninline void add(ll &x, ll y) { x += y; if (x >= MOD) x -= MOD; }\n\nll inv[MX], fact[MX], ifact[MX];\n\nvoid init() {\n    inv[1] = 1;\n    for (int i = 2; i < MX; ++i) {\n        inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n    }\n    fact[0] = ifact[0] = 1;\n    for (int i = 1; i < MX; ++i) {\n        fact[i] = fact[i-1] * i % MOD;\n        ifact[i] = ifact[i-1] * inv[i] % MOD;\n    }\n}\n\nll comb(int n, int r) {\n    if (n < 0 || r < 0 || r > n) return 0;\n    return fact[n] * ifact[r] % MOD * ifact[n - r] % MOD;\n}\n\nll calc(int N, int sum, int odd) {\n\tll res = 0;\n\tfor (int i = 0; i <= min(N, odd); ++i) {\n\t\tif ((sum - i) % 2 == 0) {\n\t\t\tll val = comb((sum - i) / 2 + N - 1, N - 1);\n\t\t\tval = val * comb(N, i) % MOD;\n\t\t\tadd(res, val);\n\t\t}\n\t}\n\treturn res;\n}\n\n// count a_1, a_2,..., a_N\n// sum a_i = M * 3\n// 0 <= a_i <= M * 2\n// number of odd elements <= M\n\nint main() {\n\tinit();\n\n\tint N, M; cin >> N >> M;\n\n\tll all = calc(N, M * 3, M);\n\tll over = (calc(N, M, M) + MOD - calc(N-1, M, M)) * N % MOD;\n\tall = (all + MOD - over) % MOD;\n\tcout << all << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int Maxn = 3e6;\nconst int Mod = 998244353;\n\nint fac[Maxn + 5], inv_fac[Maxn + 5];\ninline int QuickPow(int a, int k) {\n\tint ret = 1;\n\twhile(k) {\n\t\tif(k & 1)\n\t\t\tret = 1LL * ret * a % Mod;\n\t\ta = 1LL * a * a % Mod;\n\t\tk >>= 1;\n\t}\n\treturn ret;\n}\nvoid Init() {\n\tfac[0] = inv_fac[0] = 1;\n\tfor(int i = 1; i <= Maxn; i++)\n\t\tfac[i] = 1LL * fac[i - 1] * i % Mod;\n\tinv_fac[Maxn] = QuickPow(fac[Maxn], Mod - 2);\n\tfor(int i = Maxn - 1; i > 0; i--)\n\t\tinv_fac[i] = 1LL * inv_fac[i + 1] * (i + 1) % Mod;\n}\ninline int C(int n, int m) {\n\treturn 1LL * fac[n] * inv_fac[m] % Mod * inv_fac[n - m] % Mod;\n}\n\nint main() {\n#ifdef LOACL\n\tfreopen(\"in.txt\", \"r\", stdin);\n\tfreopen(\"out.txt\", \"w\", stdout);\n#endif\n\tInit();\n\tint N, M;\n\tscanf(\"%d %d\", &N, &M);\n\tint ans = C(3 * M + N - 1, N - 1);\n\tans = (ans - 1LL * C(M + N - 2, N - 1) * N % Mod + Mod) % Mod;\n\tfor(int i = M + 1; i <= N && i <= 3 * M; i++)\n\t\tif((3 * M - i) % 2 == 0)\n\t\t\tans = (ans - (1LL * C(N, i) * C((3 * M - i) / 2 + N - 1, N - 1) % Mod) + Mod) % Mod;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <tuple>\n#include <vector>\nusing ll = int64_t;\nclass range {private: struct I{int x;int operator*(){return x;}bool operator!=(I& lhs){return x<lhs.x;}void operator++(){++x;}};I i,n;\npublic:range(int n):i({0}),n({n}){}range(int i,int n):i({i}),n({n}){}I& begin(){return i;}I& end(){return n;}};\nusing namespace std;\nconstexpr int mod = 998244353;\n\n// Modulo calculus\n\n// With Montgomery multiply\n// Mod < 2^32, odd number\nconstexpr int ceil_log2(int x) {\n  int y = 0;\n  while (x) {\n    ++y;\n    x /= 2;\n  }\n  return y;\n}\n\nconstexpr int calc_np(const int Mod, const int R) {\n  int res = 0;\n  int t = 0;\n  int r = R;\n  int i = 1;\n  while (r > 1) {\n    if ((t % 2) == 0) {\n      t += Mod;\n      res += i;\n    }\n    t /= 2;\n    r /= 2;\n    i *= 2;\n  }\n  return res;\n}\n\ntemplate <int Mod>\nclass ModIntMR {\n public:\n  explicit constexpr ModIntMR(const int x) : data(reduction(static_cast<ll>(x) * R2)) {}\n  ModIntMR<Mod>& operator=(const ModIntMR<Mod>& that) {\n    data = that.data;\n    return *this;\n  }\n  explicit operator int() const { return reduction(data); }\n  ModIntMR<Mod>& operator+=(const ModIntMR<Mod>& that) {\n    data += that.data;\n    if (data >= Mod) data -= Mod;\n    return *this;\n  }\n  ModIntMR<Mod>& operator-=(const ModIntMR<Mod>& that) {\n    data -= that.data;\n    if (data < 0) data += Mod;\n    return *this;\n  }\n  ModIntMR<Mod>& operator*=(const ModIntMR<Mod>& that) {\n    data = reduction(static_cast<ll>(data) * that.data);\n    return *this;\n  }\n  friend ModIntMR<Mod> operator+(ModIntMR<Mod> lhs, const ModIntMR<Mod>& rhs) {\n    lhs += rhs;\n    return lhs;\n  }\n  friend ModIntMR<Mod> operator-(ModIntMR<Mod> lhs, const ModIntMR<Mod>& rhs) {\n    lhs -= rhs;\n    return lhs;\n  }\n  friend ModIntMR<Mod> operator*(ModIntMR<Mod> lhs, const ModIntMR<Mod>& rhs) {\n    lhs *= rhs;\n    return lhs;\n  }\n  friend ModIntMR<Mod> operator^(ModIntMR<Mod> lhs, const ll rhs) {\n    if (rhs == 0) return ModIntMR<Mod>(1);\n    else if ((rhs % 2) == 1) return (lhs ^ (rhs-1)) * lhs;\n    else {\n      const auto half = lhs ^ (rhs / 2);\n      return half * half;\n    }\n  }\n  ModIntMR<Mod>& operator^=(const ll that) {\n    data = (*this ^ that).data;\n    return *this;\n  }\n private:\n  int data;\n  static constexpr int shift = ceil_log2(Mod);\n  static constexpr int R = 1 << shift;\n  static constexpr int mask = R-1;\n  static constexpr int R2 = static_cast<ll>(R)*R%Mod;\n  static constexpr int Np = calc_np(Mod, R);\n  static constexpr int reduction(const ll T) {\n    int t = (T + ((T*Np)&mask)*Mod)>>shift;\n    return t >= Mod ? t - Mod : t;\n  }\n};\n\nusing modint = ModIntMR<mod>;\n\nll inv(ll a,ll p){\n  return ( a == 1 ? 1 : (1 - p*inv(p%a,a)) / a + p );\n}\n\nvector<modint> fact(2500001, modint(0));\nvector<modint> factinv(2500001, modint(0));\n\nmodint comb(int n, int k) {\n  const auto tmp = fact[n] * factinv[k];\n  return tmp * factinv[n-k];\n}\n \nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n,m;\n  cin>>n>>m;\n  ll mx = 3*m/2+n;\n  fact[0] = modint(1);\n  for (int i : range(mx)) {\n    fact[i+1] = fact[i] * modint(i+1);\n  }\n  factinv[mx] = modint(inv(static_cast<int>(fact[mx]), mod));\n  for (int i = mx; i > 0; --i) {\n    factinv[i-1] = factinv[i] * modint(i);\n  }\n  modint sub(0);\n  for (int i = 2*m+1; i <= 3*m; ++i) {\n    sub += comb(3*m-i+n-2, n-2);\n  }\n  sub *= modint(n);\n  modint mno(0);\n  for (int i = 0; i <= n && i <= m; ++i) {\n    ll rem = 3*m-i;\n    if (rem < 0 || (rem%2) == 1) continue;\n    mno += comb(rem/2+n-1, n-1) * comb(n, i);\n  }\n  modint res = mno - sub;\n  cout << static_cast<int>(res) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n#include <bitset>\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n#define next dfghjk\n\nusing namespace std;\n\ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n\nconst int N = 3000000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\n//const int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD = 998244353;\nconst double eps = 1e-9;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\nll bin_pow(ll a, ll p) {\n    ll res = 1;\n    while (p) {\n        if (p & 1) {\n            res = res * a % MOD;\n        }\n        a = a * a % MOD;\n        p >>= 1;\n    }\n    return res;\n}\n\nll rev(ll x) {\n    return bin_pow(x, MOD - 2);\n}\n\nll fact[N], rfact[N];\n\nvoid init() {\n    fact[0] = 1;\n    rep(i, 1, N) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    rfact[N - 1] = rev(fact[N - 1]);\n    repb(i, N - 2, -1) {\n        rfact[i] = rfact[i + 1] * (i + 1) % MOD;\n    }\n}\n\nll C(int n, int k) {\n    if (k < 0 || k > n) {\n        return 0;\n    }\n    return fact[n] * rfact[k] % MOD * rfact[n - k] % MOD;\n}\n\nll CntWays(int stones, int piles) {\n    if (stones < 0 || piles < 0) {\n        return 0;\n    }\n    if (stones > 0 && piles == 0) {\n        return 0;\n    }\n    if (stones == 0 && piles == 0) {\n        return 1;\n    }\n    return C(stones + piles - 1, stones);\n}\n\nll pref[N];\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 0.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    init();\n    int n, m;\n    cin >> n >> m;\n    rep(i, 0, N) {\n        pref[i] = C(i, n - 2);\n        if (i > 0) {\n            pref[i] += pref[i - 1];\n            if (pref[i] >= MOD) {\n                pref[i] -= MOD;\n            }\n        }\n    }\n    ll ans = 0;\n    rep(c1, 0, n + 1) {\n        if (c1 > m || c1 % 2 != m % 2) {\n            continue;\n        }\n        int k = (3 * m - c1) / 2;\n        ll tot = CntWays(k, n);\n        //cout << c1 << \" \" << tot << endl;\n        ll bad = pref[(n - 1) + (k - m) - 1] * n % MOD;\n        tot -= bad;\n        if (tot < 0) {\n            tot += MOD;\n        }\n        ll good = (n - c1) * CntWays(k - m, n - 1) % MOD;\n        tot += good;\n        if (tot >= MOD) {\n            tot -= MOD;\n        }\n        ans += C(n, c1) * tot % MOD;\n        if (ans >= MOD) {\n            ans -= MOD;\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nconstexpr long long MOD = 998244353;\nvector<long long> F, RF;\n\nlong long Calc(long long A, long long B) {\n\tif (B == 0) return 1;\n\tif (B % 2 == 0) {\n\t\tlong long C = Calc(A, B / 2);\n\t\treturn (C * C) % MOD;\n\t}\n\treturn (A * Calc(A, B - 1)) % MOD;\n}\n\nvoid init() {\n\tF.resize(2500001), RF.resize(2500001);\n\tF[0] = F[1] = RF[0] = RF[1] = 1;\n\tfor (int i = 2; i <= 2500000; i++) F[i] = (F[i - 1] * i) % MOD;\n\tRF[2500000] = Calc(F[2500000], MOD - 2);\n\tfor (int i = 2499999; i >= 2; i--) RF[i] = (RF[i + 1] * (i + 1)) % MOD;\n}\n\nlong long Comb(long long A, long long B) {\n\tif (B < 0 || A < B) return 0;\n\treturn (F[A] * ((RF[A - B] * RF[B]) % MOD)) % MOD;\n}\n\nlong long Solve(long long X, long long Y, long long Z) {\n\tlong long COUNT = 0;\n\tfor (int P = 0; P <= Y && P <= Z; P++) {\n\t\tif ((X - P) < 0 || (X - P) % 2 == 1) continue;\n\t\tlong long Q = (X - P) / 2;\n\t\tCOUNT += (Comb(Q + Z - 1, Q) * Comb(Z, P)) % MOD;\n\t\tCOUNT %= MOD;\n\t}\n\treturn COUNT;\n}\n\nint main() {\n\tinit();\n\tlong long N, M;\n\tcin >> N >> M;\n\tlong long ANS1 = Solve(M * 3, M, N), ANS2 = (Solve(M, M, N) - Solve(M, M, N - 1) + MOD) % MOD;\n\tcout << (ANS1 + (MOD - ANS2) * N) % MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nconst int N = 1e6+1, M = 5e5, F = 4*N, mod = 998244353;\n\nll binpow(ll a, ll s){\n    ll ans = 1;\n    while(s){\n        if(s&1)\n            ans = ans*a%mod;\n        a = a*a%mod;\n        s >>= 1;\n    }\n    return ans;\n}\n\nll inv(ll a){\n    return binpow(a, mod-2);\n}\n\nint n, m;\nll f[F], invf[F];\nvoid init(){\n    f[0] = 1;\n    invf[0] = 1;\n    for(int i = 1; i < F; ++i){\n        f[i] = f[i-1]*i%mod;\n        invf[i] = inv(f[i]);\n    }\n}\n\nll C(int n, int k){\n    if(n < k || k < 0)\n        return 0ll;\n    return f[n]*invf[n-k]%mod*invf[k]%mod;\n}\n\nll C_(int n, int k){\n    return C(n+k-1, k);\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cout.tie(0);\n    cin.tie(0);\n    init();\n    cin >> n >> m;\n    ll ans = 0;\n    for(int odd = m; odd >= 0; odd -= 2){\n        if(odd > n)\n            continue;\n        ll cnt2 = m+(m-odd)/2;\n        ll res = C(n, odd)*C_(n, cnt2)%mod;\n        res = (res - (C_(n, cnt2-m-1)*C(n-1, odd)%mod + C_(n, cnt2-m)*C(n-1, odd-1)%mod)*n%mod)%mod;\n        ans = (ans+res)%mod;\n    }\n    if(ans < 0) ans += mod;\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef _debug\n#define out(i) cout << #i << ' ' << i << ' '\n#else \n#define out(i) //\n#endif\nusing ll = long long;\nusing ull = unsigned long long;\nconst int maxn = 500001;\nconst int maxm = 2000000;\nconst int tomod = 998244353;\nll form(ll a){\n\treturn (a + tomod) % tomod;\n}\nll inv[maxm], fa[maxm];\nvoid init(){\n\tfa[0] = fa[1] = 1;\n\tinv[0] = inv[1] = 1;\n\tfor(int i = 2;i < maxm;++i){\n\t\tfa[i] = form(fa[i - 1] * (ll)i);\n\t\tinv[i] = form((tomod - tomod / i) * inv[tomod % i]);\n\t}\n\tfor(int i = 2;i < maxm;++i)inv[i] = form(inv[i] * inv[i - 1]);\n}\nll cof(int a, int b){\n\treturn form(fa[a] * form(inv[b] * inv[a - b]));\n} \nll solve(int n, int k, const int max_odd){\n\tll res = 0;\n\tfor(int o = k&1;o <= max_odd;o += 2){\n\t\tres = form(res + form(\n\t\t\tcof(n, o) * \n\t\t\tcof((k-o)/2+n-1, n-1)\n\t\t));\n\t}\n\treturn res;\n}\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tinit();\n\tll k, n;\n\tcin >> n >> k;\n\tll res = solve(n, k * 3, min(n, k));\n\tres = form(res-form(\n\t\tn * form(solve(n, k, min(n, k)) - solve(n-1, k, min(n-1, k)))\n\t)\n\t);\n\tcout << res << '\\n';\n\tassert(res>=0 and res<tomod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n#define REP(i,n) for(int i = 0;i < n;i++)\n\n/*\n * Modint struct\n * library author : @snuke\n * */\nconst int mod = 998244353;\nstruct mint {\n\tlong long x; // typedef long long ll;\n\tmint(long long x = 0): x((x % mod + mod) % mod) {}\n\tmint& operator+=(const mint a) { if ((x += a.x) >= mod)x -= mod; return *this;}\n\tmint& operator-=(const mint a) { if ((x += mod - a.x) >= mod)x -= mod; return *this;}\n\tmint& operator*=(const mint a) { (x *= a.x) %= mod; return *this;}\n\tmint operator+(const mint a) const { mint res(*this); return res += a;}\n\tmint operator-(const mint a) const { mint res(*this); return res -= a;}\n\tmint operator*(const mint a) const { mint res(*this); return res *= a;}\n\tmint pow(ll t) const {\n\t\tif (!t) return 1; mint a = pow(t >> 1); a *= a;\n\t\tif (t & 1) a *= *this; return a;\n\t}\n\t// for prime mod\n\tmint inv() const { return pow(mod - 2);}\n\tmint& operator/=(const mint a) { return (*this) *= a.inv();}\n};\nistream& operator>>(istream& is, const mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\nstruct Combination {\n\tconst int MAX = 1000050;\n\tvector<mint> fact;\n\tvector<mint> finv;\n\tCombination(): fact(MAX), finv(MAX) {\n\t\tfor (int i = 0; i < MAX; i++) {\n\t\t\tif (i == 0)fact[i] = (mint)1;\n\t\t\telse fact[i] = fact[i - 1] * (mint)i;\n\t\t}\n\t\tfinv[MAX - 1] = fact[MAX - 1].inv();\n\t\tfor (int i = MAX - 2; i >= 0; i--) {\n\t\t\tfinv[i] = finv[i + 1] * (mint)(i + 1);\n\t\t}\n\t}\n\tmint comb(int n, int r) {\n\t\tif (n < 0 || r < 0 || n < r)return 0;\n\t\telse return fact[n] * finv[r] * finv[n - r];\n\t}\n} C;\n\nll n, m;\n\nint main(void) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> n >> m;\n\tmint ans = 0;\n\n\tfor (int k = 0; k <= m; k++) {\n\t\tif ((3 * m - k) % 2 != 0)continue;\n\t\tans += C.comb(n, k) * (C.comb((3 * m - k) / 2 + n - 1, n - 1)\n\t\t       - (mint)k * C.comb((m - k) / 2 + n - 1, n - 1)\n\t\t       - (mint)(n - k) * C.comb((m - 2 - k) / 2 + n - 1, n - 1));\n\t}\n\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\nusing ll = long long;\n\n// Fermat の小定理を用いた F_mod 上での逆元計算x^(mod-2), 蟻本p115\nll Inverse(ll x){\n    ll res = 1;\n    int n = mod - 2;\n    while(n > 0){\n        if(n & 1){\n            res = res * x % mod;\n        }\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\n// iの階乗 = fact[i], main内の階乗計算をする必要がある\n#define MAX_FACT 3000000\nll fact[MAX_FACT];\n\nll nCk(int n, int k){\n    //　n_C_kの計算, Inverseの中身にもmodを入れないとオーバーフローするので注意, 蟻本p.263\n    // n >= k でないと配列外参照するので注意\n    ll ans = fact[n] * Inverse(fact[k] * fact[n-k] % mod);\n    ans %= mod;\n    return ans;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    /*\n     * 全部の組み合わせから不可能なものを引く\n     * 不可能なのは\n     * 1. ある値が2Mより大きい\n     * 2. 値が奇数のものがM個より多い\n     * のどちらか, これらは背反(和は3Mより)\n     * 奇数に1を1回, 最大の数から2を割り振れば構成できる\n     */\n\n    // 階乗計算\n    fact[0]=1;\n    for(int i = 1; i < MAX_FACT; ++i) {\n        fact[i] = fact[i-1] * i % mod;\n    }\n\n    ll ans = nCk(3*M+N-1, N-1);\n\n    // ある値が2Mより大きい場合, 他の値の合計で回す\n    ll over = 0;\n    for (int i = 0; i < M; ++i) {\n        over = over + nCk(i+N-2, N-2);\n        over %= mod;\n    }\n    over = over * N; // 2Mより大きい値の自由度\n    over %= mod;\n    ans = ans + mod - over;\n    ans %= mod;\n\n\n    // 値が奇数のものがM個より多い場合, 奇数の個数で回す\n    ll many = 0;\n    for (int i = M+1; i <= N; ++i) {\n        if(3 * M < i) break;\n        if((3 * M - i) % 2 == 1) continue;\n        ll temp = 0;\n        int sum = (3 * M - i) / 2;\n        temp = temp + nCk(sum+N-1, N-1);\n        temp %= mod;\n        temp = temp * nCk(N, i); // 奇数の位置の自由度\n        temp %= mod;\n        many += temp;\n        many %= mod;\n    }\n    ans = ans + mod - many;\n    ans %= mod;\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef NON_SUBMIT\n#define TEST(n) (n)\n#define tout cerr\n#else\n#define TEST(n) ((void)0)\n#define tout cin\n#endif\n\nusing namespace std;\n\nconst int MOD=998244353;\nint F[5000001], Finv[5000001];\n\nlong long mod(long long a)\n{\n\tif(a>=0) return a%MOD;\n\treturn ((-a/MOD+1)*MOD+a)%MOD;\n}\n\nint mul(int a, int b)\n{\n\treturn 1LL*a*b%MOD;\n}\n\nint nCr(int n, int r)\n{\n\treturn mul(mul(F[n],Finv[r]),Finv[n-r]);\n}\n\nint nHr(int n, int r)\n{\n\treturn nCr(n+r-1,r);\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL); cout.tie(NULL);\n\tTEST(freopen(\"input.txt\", \"r\", stdin));\n\tTEST(freopen(\"output.txt\", \"w\", stdout));\n\tTEST(freopen(\"debug.txt\", \"w\", stderr));\n\tint N, M;\n\tF[0]=Finv[0]=1;\n\tfor(int i=1;i<=5000000;i++) F[i]=(1LL*i*F[i-1])%MOD;\n\tFinv[5000000]=310402238;\n\tfor(int i=4999999;i;i--) Finv[i]=((i+1LL)*Finv[i+1])%MOD;\n\tcin>>N>>M;\n\tcout<<mod(nHr(N,3*M)-1LL*N*nHr(N,M-1))<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T>\nbool chmin(T &a,T b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T>\nbool chmax(T &a,T b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}  \ntemplate< int mod >\nstruct ModInt {\n  ll x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\nusing modint = ModInt< MOD9 >;modint pow(ll n, ll x){return modint(n).pow(x);}\n//using modint=ld;\ntemplate< typename T >\nstruct Combination {\n  vector< T > _fact, _rfact, _inv;\n\n  Combination(ll sz) : _fact(sz + 1), _rfact(sz + 1), _inv(sz + 1) {\n    _fact[0] = _rfact[sz] = _inv[0] = 1;\n    for(ll i = 1; i <= sz; i++) _fact[i] = _fact[i - 1] * i;\n    _rfact[sz] /= _fact[sz];\n    for(ll i = sz - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n    for(ll i = 1; i <= sz; i++) _inv[i] = _rfact[i] * _fact[i - 1];\n  }\n\n  inline T fact(ll k) const { return _fact[k]; }\n\n  inline T rfact(ll k) const { return _rfact[k]; }\n\n  inline T inv(ll k) const { return _inv[k]; }\n\n  T P(ll n, ll r) const {\n    if(r < 0 || n < r) return 0;\n    return fact(n) * rfact(n - r);\n  }\n\n  T C(ll p, ll q) const {\n    if(q < 0 || p < q) return 0;\n    return fact(p) * rfact(q) * rfact(p - q);\n  }\n\n  T H(ll n, ll r) const {\n    if(n < 0 || r < 0) return (0);\n    return r == 0 ? 1 : C(n + r - 1, r);\n  }\n};\nusing Comb=Combination<modint>;\n\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  Comb comb(3000005);\n  ll n,m;cin>>n>>m;\n  modint ret=comb.H(n,3*m);\n  rep(i,m+1,3*m+1){\n    if(i>n)break;\n    ll d2=3*m-i;\n    if(d2&1)continue;\n    if(d2>n)continue;\n    d2/=2;\n    ret-=comb.C(n,i)*comb.H(n,d2);\n  }\n  ret-=comb.H(n,m-1)*n;\n  cout<<ret<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n//  a^b % m\nlong long powmod(long long a, long long b, long long m)\n{\n    long long r = 1;\n    for (; b>0; b>>=1, a=a*a%m)\n        if (b&1)\n            r = r*a%m;\n    return r;\n}\n\nint main()\n{\n    long long N, M;\n    cin>>N>>M;\n\n    long long MOD = 998244353;\n    long long t = M*3/2;\n\n    auto f = [&](int m)\n    {\n        vector<long long> P(t+1);\n        vector<long long> T(t+1);\n\n        if (m==0)\n            return T;\n\n        for (int i=0; i<=m; i++)\n            T[i] = 1;\n        for (int i=1; i<N; i++)\n        {\n            P.swap(T);\n\n            T[0] = P[0];\n            for (int i=1; i<=t; i++)\n            {\n                T[i] = T[i-1] + P[i];\n                if (i-m-1>=0)\n                    T[i] -= P[i-(M-1)-1];\n                T[i] = (T[i]+MOD)%MOD;\n            }\n        }\n        return T;\n    };\n\n    vector<long long> T1 = f((int)M);\n    vector<long long> T2 = f((int)M-1);\n\n    vector<long long> F(N+1);\n    F[0] = 1;\n    for (int i=1; i<=N; i++)\n        F[i] = F[i-1]*i%MOD;\n\n    long long ans = 0;\n    for (int o=M*3%2; o<=min(M, N); o+=2)\n    {\n        long long t1 = F[N]*powmod(F[o], MOD-2, MOD)%MOD*powmod(F[N-o], MOD-2, MOD)%MOD;\n        ans += T2[(M*3-o)/2]*t1;\n        ans %= MOD;\n\n        if (o<N)\n        {\n            long long t2 = F[N-1]*powmod(F[o], MOD-2, MOD)%MOD*powmod(F[N-1-o], MOD-2, MOD)%MOD;\n            ans += (T1[(M*3-o)/2] - T2[(M*3-o)/2] + MOD)%MOD*t2;\n            ans %= MOD;\n        }\n    }\n\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e6 + 10;\nconst int MOD = 998244353;\n\nint f[maxn], inv[maxn];\n\nint power(int n, int k) {\n    int e = 1;\n    for (; k; k >>= 1, n = 1ll * n * n % MOD) if (k & 1) {\n        e = 1ll * e * n % MOD;\n    }\n    return e;\n}\n\nint sub(int x, int y) {\n    return ((long long) x - y + MOD) % MOD;\n}\n\nint add(int x, int y) {\n    return ((long long) x + y) % MOD;\n}\n\nint mul(int x, int y) {\n    return (long long) x * y % MOD;\n}\n\nint C(int n, int k) { \n    return mul(f[n], mul(inv[n - k], inv[k])); \n}\n\nint calc(int n, int x, int y) {\n    y = min(n, y);\n    int answer = 0;\n    for (int i = x % 2; i <= min({n, x, y}); i += 2) {\n        answer = add(answer, mul(C((x - i)/2 + n-1, n-1), C(n, i)));\n    }\n    return answer;\n}\n\nint main() {\n    // initialize factor\n    f[0] = 1;\n    for (int i = 1; i < maxn; ++i) f[i] = 1ll * f[i - 1] * i % MOD;\n    inv[maxn - 1] = power(f[maxn - 1], MOD - 2);\n    for (int i = maxn - 2; i >= 0; --i) inv[i] = 1ll * inv[i + 1] * (i + 1) % MOD;\n\n    // process\n    ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);\n    int n, m;   cin >> n >> m;\n    cout << sub(calc(n, 3 * m, m), mul(sub(calc(n, m, m), calc(n - 1, m, m)), n)) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<list>\n#include<set>\n#include<string>\n#include<math.h>\nusing namespace std;\nint gcd(int a, int b) {\n\tint c = a % b;\n\twhile (c != 0) {\n\t\ta = b;\n\t\tb = c;\n\t\tc = a % b;\n\t}\n\treturn b;\n}\nstruct UnionFind {\n\tvector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n\n\tUnionFind(int N) : par(N) { //最初は全てが根であるとして初期化\n\t\tfor (int i = 0; i < N; i++) par[i] = i;\n\t}\n\n\tint root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n\t\tif (par[x] == x) return x;\n\t\treturn par[x] = root(par[x]);\n\t}\n\n\tvoid unite(int x, int y) { // xとyの木を併合\n\t\tint rx = root(x); //xの根をrx\n\t\tint ry = root(y); //yの根をry\n\t\tif (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま\n\t\tpar[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n\t}\n\n\tbool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す\n\t\tint rx = root(x);\n\t\tint ry = root(y);\n\t\treturn rx == ry;\n\t}\n};\ntypedef long long ll;\n\nll M = 998244353;\n\nvector<ll> fac(2000001); //n!(mod M)\nvector<ll> ifac(2000001); //k!^{M-2} (mod M)\n\nll mpow(ll x, ll n) {\n\tll ans = 1;\n\twhile (n != 0) {\n\t\tif (n & 1) ans = ans * x % M;\n\t\tx = x * x % M;\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\nvoid setcomb() {\n\tfac[0] = 1;\n\tifac[0] = 1;\n\tfor (ll i = 0; i < 2000000; i++) {\n\t\tfac[i + 1] = fac[i] * (i + 1) % M; // n!(mod M)\n\t\tifac[i + 1] = ifac[i] * mpow(i + 1, M - 2) % M; // k!^{M-2} (mod M) ←累乗にmpowを採用\n\t}\n}\t\nll comb(ll a, ll b) {\n\tif (a == 0 && b == 0)return 1;\n\tif (a < b || a < 0)return 0;\n\tll tmp = ifac[a - b] * ifac[b] % M;\n\treturn tmp * fac[a] % M;\n}\nll perm(ll a, ll b) {\n\tif (a == 0 && b == 0)return 1;\n\tif (a < b || a < 0)return 0;\n\treturn fac[a] * ifac[a - b] % M;\n}\n// mod. m での a の逆元 a^{-1} を計算する\nlong long modinv(long long a) {\n\tlong long b = M, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= M;\n\tif (u < 0) u += M;\n\treturn u;\n}\nvector<vector<ll>> mul(vector<vector<ll>> a, vector<vector<ll>> b, int n) {\n\tint i, j, k, t;\n\tvector<vector<ll>> c(n);\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tt = 0;\n\t\t\tfor (k = 0; k < n; k++)\n\t\t\t\tt = (t + a[i][k] * b[k][j] % M) % M;\n\t\t\tc[i].push_back(t);\n\t\t}\n\t}\n\treturn c;\n}\n\ntemplate< typename Monoid >\nstruct SegmentTree {\n\n\tint sz;\n\tvector< Monoid > seg;\n\n\tconst Monoid M1;\n\n\tSegmentTree(int n, const Monoid &M1) : M1(M1) {\n\t\tsz = 1;\n\t\twhile (sz < n) sz <<= 1;\n\t\tseg.assign(2 * sz, M1);\n\t}\n\n\tvoid set(int k, const Monoid &x) {\n\t\tseg[k + sz] = x;\n\t}\n\n\tvoid build() {\n\t\tfor (int k = sz - 1; k > 0; k--) {\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\tvoid update(int k, const Monoid &x) {\n\t\tk += sz;\n\t\tseg[k] = x;\n\t\twhile (k >>= 1) {\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\tMonoid query(int a, int b) {\n\t\tMonoid L = M1, R = M1;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n\t\t\tif (a & 1) L = f(L, seg[a++]);\n\t\t\tif (b & 1) R = f(seg[--b], R);\n\t\t}\n\t\treturn f(L, R);\n\t}\n\n\tMonoid value(const int &k) const {\n\t\treturn seg[k + sz];\n\t}\n\n\tMonoid f(Monoid a, Monoid b) {\n\t\treturn a + b;\n\t}\n};\n\nint main() {\n\tll n, m, i, ans = 0,p;\n\tcin >> n >> m;\n\tsetcomb();\n\tif (m % 2 == 0) {\n\t\tfor (i = 0; i <= m; i+=2) {\n\t\t\tans += comb(n, i)*comb(n - 1 + (3 * m - i) / 2, n - 1);\n\t\t\tans %= M;\n\t\t\tp = i * comb(n, i) % M*comb(n - 2 + (m - i) / 2, n - 2) % M;\n\t\t\tp += n * comb(n, i) % M*comb(n - 1 + (m - i - 2) / 2, n - 1) % M;\n\t\t\tp %= M;\n\t\t\tans -= p;\n\t\t\tans = (ans + M) % M;\n\t\t}\n\t}\n\telse {\n\t\tfor (i = 1; i <= m; i += 2) {\n\t\t\tans += comb(n, i)*comb(n - 1 + (3 * m - i) / 2, n - 1);\n\t\t\tans %= M;\n\t\t\tp = i * comb(n, i) % M*comb(n - 2 + (m - i) / 2, n - 2) % M;\n\t\t\tp += n * comb(n, i) % M*comb(n - 1 + (m - i - 2) / 2, n - 1) % M;\n\t\t\tp %= M;\n\t\t\tans -= p;\n\t\t\tans = (ans + M) % M;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define P pair<int, int>\nconst LL N = 4e6 + 10;\nconst LL inf = 0x3f3f3f;\nconst LL mod = 998244353;\nusing namespace std;\ntemplate <typename tp>\ninline void read(tp &x)\n{\n    x = 0; char c = getchar(); bool f = 0;\n    for (; c < '0' || c > '9'; f |= (c == '-'), c = getchar()) ;\n    for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar()) ;\n    if (f) x = -x;\n}\nLL Ksm(LL a,LL b,LL ret=1)\n{\n    while(b)\n    {\n        if(b&1) ret=a*ret%mod;\n        a=a*a%mod;\n        b>>=1;\n    }\n    return ret;\n}\nLL n,m,ans;\nLL inv[N],jc[N];\nvoid init()\n{\n    inv[0]=jc[0]=jc[1]=1;\n    for(int i=2;i<=4000000;i++) jc[i]=jc[i-1]*i%mod;\n    inv[4000000]=Ksm(jc[4000000],mod-2);\n    for(int i=3999999;i>=1;i--) inv[i]=inv[i+1]*(i+1)%mod;\n}\nLL C(LL x,LL y){return jc[y]*inv[y-x]%mod*inv[x]%mod;}\nint main()\n{\n    read(n),read(m);\n    init();\n    for(int i=0;i<=m/2;i++)\n    {\n        LL ji=i*2+m%2,ou=m+(m-ji)/2;\n        if(ji>n) break;\n        ans+=C(ji,n)*C(n-1,ou+n-1)%mod;\n        ans%=mod;\n    }\n    for(int i=m*2+1;i<=3*m;i++)\n    {\n        ans-=n*C(n-2,3*m-i+n-2)%mod;\n        ans=(ans+mod)%mod;\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { -1,0, 1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// #define mp make_pair\n//#define endl '\\n'\n\n\nconst int MAXN = 2522222;\n \nll fact[2522222];\nll rfact[2522222];\n \nll mod_pow(ll x, ll p, ll M = MOD) {\n  ll a = 1;\n  while (p) {\n    if (p % 2)\n      a = a*x%M;\n    x = x*x%M;\n    p /= 2;\n  }\n  return a;\n}\n \nll mod_inverse(ll a, ll M = MOD) {\n  return mod_pow(a, M - 2, M);\n}\n \nvoid set_fact(ll n, ll M = MOD) {\n  fact[0] = fact[1] = rfact[0] = rfact[1] = 1;\n  for (ll i = 2; i <= n; i++) {\n    fact[i] = i * fact[i - 1] % M;\n    // rfact[i] = mod_inverse(fact[i], M);\n  }\n}\n\n//http://drken1215.hatenablog.com/entry/2018/06/08/210000\n//nが大きくfactが計算できないときのほかの計算方法について書いてある\nll nCr(ll n, ll r, ll M = MOD) {\n  if (r > n) return 0;\n  assert(fact[2] == 2);\n  ll ret = fact[n];\n  if (rfact[r] == 0) {\n    rfact[r] = mod_inverse(fact[r], M);\n  }\n  ret = (ret*rfact[r]) % M;\n  if (rfact[n - r] == 0) {\n    rfact[n - r] = mod_inverse(fact[n - r], M);\n  }\n  ret = (ret*rfact[n - r]) % M;\n  return ret;\n}\n\nll nHr(ll n, ll r) {\n  return nCr(n+r-1, r);\n}\n\nll guchoku(ll n, ll m) {\n  vll dp(n + 1, vl(3*m + 1));\n \n  dp[0][0] = 1;\n  rep (i, n) {\n    rep (j, 3*m + 1) {\n      for (int add = 0; add <= 2*m; add++) {\n        if (j + add > 3*m) break;\n        (dp[i + 1][j + add] += dp[i][j]) %= MOD;\n      }\n    }\n  }\n  return dp[n][3*m];\n}\n \nint main() {\n  ll n, m;\n  cin >> n >> m;\n  set_fact(2522221);\n  \n  ll zen = nHr(3*m + 1, n - 1);\n \n  for (int x = 0; x < m; x++) {\n    ll sub = nHr(x + 1, n - 1);\n    if (3*m - 2*x > n) {\n      sub = 0;\n    }\n    else {\n      sub *= nCr(n, 3*m - 2*x);\n      sub %= MOD;\n    }\n    zen -= sub;\n  }\n \n  for (int x = 2*m + 1; x <= 3*m; x++) {\n    ll sub = n;\n    ll m2 = 3*m - x;\n    sub = sub * nHr(m2 + 1, (n - 1) - 1) % MOD;\n    (zen -= sub) %= MOD;\n  }\n \n  zen = (zen + MOD) % MOD;\n  cout << zen << endl;\n \n  //DEBUG(guchoku(n, m));\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(),a.end()\n#define F first\n#define S second\n#define pb push_back\n#define ll long long\n#define vi vector<int>\n#define pi pair<int,int>\n#define mp make_pair\n \n#ifdef LOCAL\n#include \"debug.h\"\n#else\n#define debug(...) 42\n#endif\n \nconst int mod=998244353;\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nint mul(int a,int b)\n{\n\treturn ((a)*1ll*(b))%mod;\n}\n \nvoid add(int &a,int b)\n{\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\n \nint sub(int a,int b){\n\ta-=b;\n\tif(a<0){\n\t\ta+=mod;\n\t}\n\treturn a;\n}\n \nint powz(int a,int b)\n{\n\tint res=1;\n\twhile(b)\n\t{\n\t\tif(b&1){\n\t\t\tres=mul(res,a);\n\t\t}\n\t\tb/=2;\n\t\ta=mul(a,a);\n\t}\n\treturn res;\n}\n \ntemplate <typename A, typename B>\nistream& operator>>(istream& input,pair<A,B>& x) {\n\tinput>>x.F>>x.S;\n\treturn input;\n}\n \ntemplate <typename A>\nistream& operator>>(istream& input,vector<A>& x) {\n\tfor(auto& i:x)\n\t\tinput>>i;\n\treturn input;\n}\n \ntemplate<typename A>\nostream& operator<<(ostream& output,vector<A>& x) {\n\tfor(auto& i:x)\n\t\toutput<<i<<' ';\n\treturn output;\n}\n \nconst int N=10000002;\n\nint fc[N],inv[N];\n\nint C(int n,int r){\n\tif(n<r){\n\t\treturn 0;\n\t}\n\treturn mul(mul(fc[n],inv[n-r]),inv[r]);\n}\n\nvoid solve(){\n\tint n,m;\n\tcin>>n>>m;\n\tint tot=3*m;\n\tint ans=0;\n\tfor(int odd=0;odd<=m;odd++){\n\t\tif((tot-odd)&1)continue;\n\t\tadd(ans,mul(C(n,odd),C(n-1+(tot-odd)/2,n-1)));\n\t}\n\tfor(int left=2*m+1;left<=3*m;left++){\n\t\tans=sub(ans,mul(n,C(3*m-left+n-2,n-2)));\n\t}\n\tcout<<ans;\n}\n\nsigned main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tint tc=1;\n\tfc[0]=1;\n\tfor(int i=1;i<N;i++){\n\t\tfc[i]=mul(fc[i-1],i);\n\t}\n\tinv[N-1]=powz(fc[N-1],mod-2);\n\tfor(int i=N-2;i>=0;i--){\n\t\tinv[i]=mul(inv[i+1],i+1);\n\t}\n\t//~ cin>>tc;\n\tfor(int _=0;_<tc;_++){\n\t\t//~ cout<<\"Case #\"<<_+1<<\": \";\n\t\tsolve();\n\t\tif(_!=tc-1)\n\t\tcout<<\"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <assert.h>\nusing namespace std;\n\n#define N 3000001\n#define mod 998244353\n#define ll long long\n\nint fac[N], invFac[N];\nint mypow(int x, int c) {\n\tint ret = 1;\n\twhile (c > 0) {\n\t\tif (c & 1) {\n\t\t\tret = (ll)ret*x%mod;\n\t\t}\n\t\tc /= 2;\n\t\tx = (ll)x*x%mod;\n\t}\n\treturn ret;\n}\nint combi(int n, int c) {\n\tint ret = (ll)fac[n] * invFac[c] % mod;\n\tret = (ll)ret*invFac[n - c] % mod;\n\n\treturn ret;\n}\nint add(int x, int y) {\n\tint ret = x + y;\n\tif (ret < 0) {\n\t\tret += mod;\n\t}\n\tif (ret >= mod) {\n\t\tret -= mod;\n\t}\n\treturn ret;\n}\nint mul(int x, int y) {\n\treturn (ll)x*y%mod;\n}\nvoid solve() {\n\tint n, m; scanf(\"%d %d\", &n, &m);\n\tfac[0] = 1; invFac[0] = 1;\n\tfor (int i = 1; i <= n * 3; ++i) {\n\t\tfac[i] = (ll)fac[i - 1] * i%mod;\n\t\tinvFac[i] = mypow(fac[i], mod - 2);\n\t}\n\tint ret = 0;\n\tint maxOdd = min(n, m);\n\tfor (int odd = 0; odd <= maxOdd; ++odd) {\n\t\tint sum = 3 * m - odd;\n\t\tif (sum % 2 == 0) {\n\t\t\tsum /= 2;\n\t\t\tint tmp = combi(sum + n - 1, n - 1);\n\t\t\ttmp = mul(tmp, combi(n, odd));\n\t\t\tret = add(ret, tmp);\n\t\t}\n\t}\n\tfor (int maxSum = 2 * m + 1; maxSum <= 3 * m; ++maxSum) {\n\t\tint rem = 3 * m - maxSum;\n\t\tint tmp = combi(rem + n - 2, n - 2);\n\t\ttmp = (ll)tmp*n%mod;\n\t\tret = add(ret, -tmp);\n\t}\n\tprintf(\"%d\\n\", ret);\n}\nint main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,a,b) for(int i=(a);i<(b);i++)\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\nusing vint=vector<int>;\nusing pint=pair<int,int>;\nusing vpint=vector<pint>;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<class A,class B>\nostream& operator<<(ostream& ost,const pair<A,B>&p){\n\tost<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n\treturn ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost,const vector<T>&v){\n\tost<<\"{\";\n\tfor(int i=0;i<v.size();i++){\n\t\tif(i)ost<<\",\";\n\t\tost<<v[i];\n\t}\n\tost<<\"}\";\n\treturn ost;\n}\n\ntemplate<uint32_t mod>\nstruct ModInt{\n\tuint32_t a;\n\tModInt& s(uint32_t vv){\n\t\ta=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\n\tModInt(int64_t x=0){s(x%mod+mod);}\n\n\tModInt& operator+=(const ModInt &x){return s(a+x.a);}\n\tModInt& operator-=(const ModInt &x){return s(a+mod-x.a);}\n\tModInt& operator*=(const ModInt &x){\n\t\ta=uint64_t(a)*x.a%mod;\n\t\treturn *this;\n\t}\n\tModInt& operator/=(const ModInt &x){\n\t\t*this*=x.inv();\n\t\treturn *this;\n\t}\n\n\tModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n\tModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n\tbool operator==(const ModInt &x)const{return a==x.a;}\n\tbool operator!=(const ModInt &x)const{return a!=x.a;}\n\tbool operator<(const ModInt &x)const{return a<x.a;}\n\n\tModInt operator-()const{return ModInt()-*this;}\n\tModInt pow(int64_t n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModInt inv()const{return pow(mod-2);}\n};\n\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,ModInt<mod>& a){\n\treturn (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n\treturn (out<<a.a);\n}\nusing mint=ModInt<998244353>;\n\n\ntemplate<class Mint,int32_t lg>\nstruct ModIntTable{\n\tint N;\n\tvector<Mint>facts,finvs,invs;\n\tModIntTable():N(1<<lg),facts(N),finvs(N),invs(N){\n\t\tconst uint32_t mod=Mint(-1).a+1;\n\t\tinvs[1]=1;\n\t\tfor(int i=2;i<N;i++)invs[i]=invs[mod%i]*(mod-mod/i);\n\n\t\tfacts[0]=1;\n\t\tfinvs[0]=1;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tfacts[i]=facts[i-1]*i;\n\t\t\tfinvs[i]=finvs[i-1]*invs[i];\n\t\t}\n\t}\n\tinline Mint fact(int n)const{return facts[n];}\n\tinline Mint finv(int n)const{return finvs[n];}\n\tinline Mint inv(int n)const{return invs[n];}\n\tinline Mint binom(int n,int k)const{return facts[n]*finvs[k]*finvs[n-k];}\n\tinline Mint perm(int n,int k)const{return facts[n]*finvs[n-k];} \n};\nModIntTable<mint,21>mtable;\n\nsigned main(){\n\tint N,M;\n\tcin>>N>>M;\n\n\tmint ans=0;\n\tfor(int i=0;i<=M&&i<=N;i++){\n\t\tif((3*M-i)&1)continue;\n\t\tint m=(3*M-i)/2;\n\n\n\t\tans+=mtable.binom(N,i)*mtable.binom(N-1+m,m);\n\n\t\tif(m>M&&i<=N-1){\n\t\t\tans-=mtable.binom(N-1,i)*mtable.binom(N-1+m-M-1,m-M-1)*N;\n\t\t}\n\t\tif(m>=M&&i){\n\t\t\tans-=mtable.binom(N-1,i-1)*mtable.binom(N-1+m-M,m-M)*N;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nconstexpr int64 P = 998244353;\n\n// Verified: ABC133E, ABC132D, ABC130E\nstruct FiniteField {\n private:\n  int64 x;\n public:\n  FiniteField(int64 x) : x(x) {\n    if (x > P || x < 0) { cerr << \"Invalied FiniteField!\" << endl; exit(1); }\n  }\n  FiniteField() : x(0) {}\n  int64 Value() { return x; }\n  inline FiniteField operator+(FiniteField o) {\n    FiniteField r(*this); r += o; return r;\n  }\n  inline FiniteField operator-(FiniteField o) {\n    FiniteField r(*this); r -= o; return r;\n  }\n  inline FiniteField operator* (FiniteField o) {\n    FiniteField r(*this); r *= o; return r;\n  }\n  inline FiniteField operator/ (FiniteField o) {\n    FiniteField r(*this); r /= o; return r;\n  }\n  inline void operator+= (FiniteField o) { x = (x + o.x) % P; }\n  inline void operator-= (FiniteField o) { x = (x + P - o.x) % P; }\n  inline void operator*= (FiniteField o) { x = (x * o.x) % P; }\n  void operator/=(FiniteField o) {\n    int64 p = P - 2; while (p) { if (p % 2) { *this *= o; } o *= o; p /= 2; }\n  }\n};\n\nvector<FiniteField> MakeFactorialTable(int n) {\n  vector<FiniteField> values(n + 1);\n  values[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    values[i] = values[i - 1] * i;\n  }\n  return values;\n}\n\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n, m;\n  cin >> n >> m;\n\n  auto factorials = MakeFactorialTable(n + 3 * m + 1);\n  vector<FiniteField> inverse_factorials(n + 3 * m + 1);\n  for (int i = 0; i <= n + 3 * m; i++) {\n    inverse_factorials[i] = FiniteField(1) / factorials[i];\n  }\n\n  auto combination_fn = [&](int n, int r) -> FiniteField {\n    if (r < 0 || r > n) return 0;\n    return factorials[n] * inverse_factorials[r] * inverse_factorials[n - r];\n  };\n\n  FiniteField value = 0;\n  for (int k = 0; k <= min(n, m); k++) {\n    if (k % 2 != m % 2) continue;\n    FiniteField factor1 = combination_fn(n, k);\n    int a = (3 * m - k) / 2;\n    FiniteField factor2 = combination_fn(a + n - 1, a);\n    factor2 -= combination_fn(a - m + n - 1, a - m) * k;\n    factor2 -= combination_fn(a - (m + 1) + n - 1, a - (m + 1)) * (n - k);\n    value += factor1 * factor2;\n  }\n  cout << value.Value() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst ll mod=998244353;\nconst int MAX=100001,INF=1<<30;\n\nll rui(ll a,ll b){\n    if(b==1) return a%mod;\n    if(b==0) return 1;\n    if(b%2==0) return (rui(a,b/2)*rui(a,b/2))%mod;\n    return (rui(a,b-1)*a)%mod;\n}\n\nll comb(ll a,ll b){\n    ll ans=1;\n    for(ll i=a;i>a-b;i--){\n        ans=ans*i%mod;\n    }\n    for(ll i=1;i<=b;i++){\n        ans=(ans*rui(i,mod-2))%mod;\n    }\n    return ans;\n}\n\nint main(){\n    \n    ll N,M;cin>>N>>M;\n    \n    ll all=comb(3*M+N-1,N-1);\n    \n    ll diff=1;\n    ll now=1;\n  \n  //cout<<all<<endl;\n    \n    for(ll i=1;i<=M-1;i++){\n        now=now*(i+N-2)%mod;\n        now=now*rui(i,mod-2)%mod;\n        diff=(diff+now)%mod;\n      //cout<<now<<endl;\n    }\n    \n    diff=diff*N%mod;\n    \n    cout<<(all+mod-diff)%mod<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst long long mod=998244353ll;\n\nconst int MSIZE=4000000;\n\n\nvoid ad(long long &a,long long b){a+=b;a%=mod;}\nvoid mn(long long &a,long long b){a+=mod-b;a%=mod;}\nvoid ml(long long &a,long long b){a*=b;a%=mod;}\nlong long sq(long long a){return a*a%mod;}\nlong long pw(long long a,long long n)\n{\n  return n==0?1ll:sq(pw(a,n/2))*(n%2==1?a:1ll)%mod;\n}\nlong long iv(long long a){return pw(a,mod-2);}\nlong long inv[MSIZE],F[MSIZE],iF[MSIZE];\n\nvoid prev(int N)\n{\n  inv[0]=0;\n  inv[1]=1;\n  for(int i=2;i<N;i++){\n    inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n  }\n  F[0]=iF[0]=1;\n  for(int i=1;i<N;i++){\n    F[i]=F[i-1]*i%mod;\n    iF[i]=iF[i-1]*inv[i]%mod;\n  }\n}\n\nlong long Ch(int i,int j)\n{\n  return i<0||j<0||i<j?0:F[i]*iF[j]%mod*iF[i-j]%mod;\n}\n\nint main()\n{\n  int n,m;\n  scanf(\"%d%d\",&n,&m);\n  prev(n+3*m);\n  long long ans=Ch(3*m+n-1,n-1);\n  mn(ans,n*Ch(m-1+n-1,n-1)%mod);\n  for(int i=m+1;i<=3*m&&i<=n;i++){\n    if((3*m-i)%2==0){\n      mn(ans,Ch(n,i)*Ch((3*m-i)/2+n-1,n-1)%mod);\n    }\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD 998244353\n\nstruct llm{\n    ll value=0;\n    llm(const ll& val=0){this->value = (MOD + val % MOD) % MOD;}\n    llm(const int& val){this->value = (MOD + val % MOD) % MOD;}\n    llm(const llm& a) { llm(a.value); }\n    llm inv(){ll a = 1;ll b = this->value;for(ll m=MOD-2;m>0;m/=2){if(m&1){a=a*b%MOD;}b=b*b%MOD;}return llm(a);}\n    llm &operator+=(const llm &a) {this->value = (this->value + a.value) % MOD;return *this;}\n    llm &operator-=(const llm &a) {this->value = (this->value - a.value + MOD) % MOD;return *this;}\n    llm &operator*=(const llm &a) {this->value = (this->value * a.value) % MOD; return *this; }\n    explicit operator ll() const{return (ll)value;}\n    explicit operator int() const{return (int)value;}\n};\nllm operator+(const llm &a, const llm &b) { return llm(a.value + b.value); }\nllm operator-(const llm &a, const llm &b) { return llm(a.value - b.value); }\nllm operator*(const llm &a, const llm &b) { return llm(a.value * b.value); }\n#define pllm pair<llm,llm>\n#define FAN 5050505\nllm Fa[FAN+4],iFa[FAN+4];\nllm FaInit(){\n    ll i;\n    Fa[0] = 1;\n    fornum(i,0,FAN){\n        Fa[i + 1] = Fa[i] * (i + 1);\n    }\n    iFa[FAN] = Fa[FAN].inv();\n    for (i = FAN - 1; i >= 0;--i)\n    {\n        iFa[i] = iFa[i + 1] * (i + 1);\n    }\n}\nllm C(const ll& a,const ll& b){\n    if(a<b||a<0||b<0)\n        return 0;\n    return Fa[a] * iFa[b] * iFa[a - b];\n}\n\n\nll N,M;\nll i,j,k;\nllm ans;\nint main(){\n    scanf(\"%lld%lld\", &N, &M);\n    FaInit();\n    ans = C(N - 1 + M * 3, N - 1);\n    //printf(\"%lld\\n\", (ll)ans);\n    fornum(i,0,N+1){\n        if(i>M*3)\n            break;\n        if ((M * 3 - i) % 2)\n            continue;\n        if(i<=M){\n            ans -= C(N - 1, i) * N * C(N - 1 + (M - i - 2) / 2, N - 1);\n            ans -= C(N - 1, i - 1) * N * C(N - 1 + (M - i) / 2, N - 1);\n        }else{\n            ans -= C(N, i) * C(N - 1 + (M * 3 - i) / 2, N - 1);\n        }\n    }\n    printf(\"%lld\", (ll)ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuThOr GaRyMr\n*/\n#include<bits/stdc++.h>\n#define rb(a,b,c) for(int a=b;a<=c;++a)\n#define rl(a,b,c) for(int a=b;a>=c;--a)\n#define LL long long\n#define IT iterator\n#define PB push_back\n#define II(a,b) make_pair(a,b)\n#define FIR first\n#define SEC second\n#define FREO freopen(\"check.out\",\"w\",stdout)\n#define rep(a,b) for(int a=0;a<b;++a)\n#define KEEP while(1)\n#define SRAND mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#define random(a) rng()%a\n#define ALL(a) a.begin(),a.end()\n#define POB pop_back\n#define ff fflush(stdout)\n#define fastio ios::sync_with_stdio(false)\n//#define int LL\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef pair<int,int> mp;\ntypedef pair<mp,mp> superpair;\nLL MOD=998244353;\nLL fact[2000000+21];\ninline LL update(LL A){\n\tif(A<MOD) return A;\n\tA%=MOD;\n\treturn A;\n}\ninline LL add(LL x,LL y)\n{\n    return x+y>=MOD?x+y-MOD:x+y;\n}\ninline void UP(LL & A){\n\tif(A>=MOD){\n\t\tA%=MOD;\n\t}\n}\ninline LL quick(LL A,LL B){\n\tif(!B) return 1ll;\n\tLL tmp=quick(A,B>>1);\n\ttmp*=tmp;\n\tUP(tmp);\n\tif(B&1){\n\t\ttmp*=A;\n\t\tUP(tmp);\n\t}\n\treturn tmp;\n}\ninline LL inv(LL A){\n\treturn  quick(A,MOD-2);\n}\ninline LL C(LL A,LL B){\n\tif(B>A){\n\t\treturn 0ll;\n\t}\n\tint rest=update(update(fact[A]*inv(fact[B]))*inv(fact[A-B]));\n\treturn rest;\n}\ninline LL AR(LL A,LL B){\n\t//把A个2分给B个数\n\treturn C(A+B-1,B-1); \n} \nint  main(){\n\tfastio;\n\tfact[0]=1;\n\trb(i,1,2000000)\n\t\tfact[i]=fact[i-1]*i,fact[i]%=MOD;\n//\tif()\n\tint n,m;\n\tcin>>n>>m;\n//\tif(n==1000000 &&m==500000){\n//\t\tcout<<650705070<<endl;\n//\t\treturn 0;\n//\t}\n\tint res=0;\n\tLL del=0;\n\tfor(register int two=m,one=m;one>=0;++two,--one,--one){\n\t\tif(two>=m+1){\n\t\t\tdel=add(del,update(n*(AR(two-(m+1),n-1))));\n\t\t}\n\t\tif(one>n) continue;\n\t\tres+=(update((AR(two,n)+MOD-del)*C(n,one)));\n\t\tif(one!=0){\n\t\t\tres-=update(update(n*AR(two-m,n-1))*C(n-1,one-1));\n\t\t}\n      \tif(res<0)\n\t\tres+=MOD;\n\t\tif(res>=MOD){\n\t\t\tres%=MOD;\n\t\t}\t\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n/*\n2 5\n6\n100 97\n20341054\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int P = 998244353;\n\nlong long power(long long x, long long t) {\n\tlong long ret = 1;\n\tfor(; t; t >>= 1, x = x * x % P) {\n\t\tif(t & 1) {\n\t\t\tret = ret * x % P;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\n\tint k = 3000001;\n\n\tvector<long long> fac(k);\n\tvector<long long> inv(k);\n\n\tfac[0] = 1;\n\tfor(int i = 0; i + 1 < k; ++i) {\n\t\tfac[i + 1] = fac[i] * (i + 1) % P;\n\t}\n\n\tinv[k - 1] = power(fac[k - 1], P - 2);\n\tfor(int i = k - 1; i >= 1; --i) {\n\t\tinv[i - 1] = inv[i] * i % P;\n\t}\n\n\tauto C = [&] (int n, int m) {\n\t\tif(n < m) {\n\t\t\treturn 0LL;\n\t\t}\n\t\treturn fac[n] * inv[m] % P * inv[n - m] % P;\n\t};\n\n\tlong long ans = 0;\n\tfor(int i = 0; i + i <= m; ++i) {\n\t\tif(m - 2 * i <= n) {\n\t\t\tint two = m + i;\n\t\t\tans = (ans + C(two + n - 1, n - 1) * C(n, m - 2 * i) % P) % P;\n\t\t}\n\t}\n\n\tans = (ans - C(m - 1 + n - 1, n - 1) * n % P + P) % P;\n\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  static constexpr T mod = MOD;\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n\n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n\n  Mint inv(){return pow(MOD-2);}\n\n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n\n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(T a,T b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(Int r=0;r<sq;r++){\n      if(!dp.count(res.v)) dp[res.v]=r;\n      res*=a;\n    }\n    Mint p=Mint(a).inv().pow(sq);\n    res=b;\n    for(Int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res.v)){\n        T idx=q*sq+dp[res.v];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }\n    assert(0);\n    return T(-1);\n  }\n\n  static Mint comb(long long n,Int k){\n    Mint num(1),dom(1);\n    for(Int i=0;i<k;i++){\n      num*=Mint(n-i);\n      dom*=Mint(i+1);\n    }\n    return num/dom;\n  }\n};\ntemplate<typename T,T MOD> constexpr T Mint<T, MOD>::mod;\ntemplate<typename T,T MOD>\nostream& operator<<(ostream &os,Mint<T, MOD> m){os<<m.v;return os;}\n\n\ntemplate<typename M>\nclass Enumeration{\nprivate:\n  static vector<M> fact,finv,invs;\npublic:\n  static void init(Int n){\n    n=min<decltype(M::mod)>(n,M::mod-1);\n\n    Int m=fact.size();\n    if(n<m) return;\n\n    fact.resize(n+1,1);\n    finv.resize(n+1,1);\n    invs.resize(n+1,1);\n\n    if(m==0) m=1;\n    for(Int i=m;i<=n;i++) fact[i]=fact[i-1]*M(i);\n    finv[n]=M(1)/fact[n];\n    for(Int i=n;i>=m;i--) finv[i-1]=finv[i]*M(i);\n    for(Int i=m;i<=n;i++) invs[i]=finv[i]*fact[i-1];\n  }\n\n  static M Fact(Int n){\n    init(n);\n    return fact[n];\n  }\n  static M Finv(Int n){\n    init(n);\n    return finv[n];\n  }\n  static M Invs(Int n){\n    init(n);\n    return invs[n];\n  }\n\n  static M C(Int n,Int k){\n    if(n<k||k<0) return M(0);\n    init(n);\n    return fact[n]*finv[n-k]*finv[k];\n  }\n\n  static M P(Int n,Int k){\n    if(n<k||k<0) return M(0);\n    init(n);\n    return fact[n]*finv[n-k];\n  }\n\n  static M H(Int n,Int k){\n    if(n<0||k<0) return M(0);\n    if(!n&&!k) return M(1);\n    init(n+k-1);\n    return C(n+k-1,k);\n  }\n\n  static M S(Int n,Int k){\n    M res;\n    init(k);\n    for(Int i=1;i<=k;i++){\n      M tmp=C(k,i)*M(i).pow(n);\n      if((k-i)&1) res-=tmp;\n      else res+=tmp;\n    }\n    return res*=finv[k];\n  }\n\n  static vector<vector<M> > D(Int n,Int m){\n    vector<vector<M> > dp(n+1,vector<M>(m+1,0));\n    dp[0][0]=M(1);\n    for(Int i=0;i<=n;i++){\n      for(Int j=1;j<=m;j++){\n        if(i-j>=0) dp[i][j]=dp[i][j-1]+dp[i-j][j];\n        else dp[i][j]=dp[i][j-1];\n      }\n    }\n    return dp;\n  }\n\n  static M B(Int n,Int k){\n    if(n==0) return M(1);\n    k=min(k,n);\n    init(k);\n    vector<M> dp(k+1);\n    dp[0]=M(1);\n    for(Int i=1;i<=k;i++)\n      dp[i]=dp[i-1]+((i&1)?-finv[i]:finv[i]);\n    M res;\n    for(Int i=1;i<=k;i++)\n      res+=M(i).pow(n)*finv[i]*dp[k-i];\n    return res;\n  }\n\n  static M montmort(Int n){\n    M res;\n    init(n);\n    for(Int k=2;k<=n;k++){\n      if(k&1) res-=finv[k];\n      else res+=finv[k];\n    }\n    return res*=fact[n];\n  }\n\n  static M LagrangePolynomial(vector<M> &y,M t){\n    Int n=y.size()-1;\n    if(t.v<=n) return y[t.v];\n    init(n+1);\n    vector<M> dp(n+1,1),pd(n+1,1);\n    for(Int i=0;i<n;i++) dp[i+1]=dp[i]*(t-M(i));\n    for(Int i=n;i>0;i--) pd[i-1]=pd[i]*(t-M(i));\n    M res{0};\n    for(Int i=0;i<=n;i++){\n      M tmp=y[i]*dp[i]*pd[i]*finv[i]*finv[n-i];\n      if((n-i)&1) res-=tmp;\n      else res+=tmp;\n    }\n    return res;\n  }\n};\ntemplate<typename M>\nvector<M> Enumeration<M>::fact = vector<M>();\ntemplate<typename M>\nvector<M> Enumeration<M>::finv = vector<M>();\ntemplate<typename M>\nvector<M> Enumeration<M>::invs = vector<M>();\n\n//INSERT ABOVE HERE\nsigned main(){\n  using M = Mint<Int, 998244353>;\n  using E = Enumeration<M>;\n  E::init(3e6);\n\n  Int n,m;\n  cin>>n>>m;\n\n  M ans{0};\n  for(Int i=0;i<=m;i++){\n    if(i>n) break;\n    if((3*m-i)&1) continue;\n    Int d=(3*m-i)/2;\n    ans+=E::C(n,i)*E::H(n,d);\n    // x >= 2M + 1, x odd\n    if(i&&d>=m){\n      ans-=M(n)*E::C(n-1,i-1)*E::H(n,d-m);\n    }\n    // x >= 2M + 2, x even\n    if(d>=m+1){\n      ans-=M(n)*E::C(n-1,i)*E::H(n,d-(m+1));\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\nusing ll = int64_t;\n\nconstexpr ll MOD = 998244353;\n\nclass Combination {\npublic:\n    Combination(ll max_num) {\n        fact_.resize(max_num + 1, 1);\n        inv_fact_.resize(max_num + 1, 1);\n        for (ll i = 2; i <= max_num; i++) {\n            fact_[i] = i * fact_[i - 1] % MOD;\n            inv_fact_[i] = MODpow(fact_[i], MOD - 2);\n            assert(fact_[i] * inv_fact_[i] % MOD == 1);\n        }\n    }\n    ll operator()(ll n, ll m) const {\n        if (m < 0 || m > n) return 0;\n        return fact_[n] * inv_fact_[n - m] % MOD * inv_fact_[m] % MOD;\n    }\nprivate:\n    ll MODpow(ll n, ll m) const {\n        ll result = 1;\n        while (m) {\n            if (m % 2 == 1) {\n                result *= n;\n                result %= MOD;\n            }\n\n            m /= 2;\n            n *= n;\n            n %= MOD;\n        }\n\n        return result;\n    }\n\n    vector<ll> fact_, inv_fact_;\n} comb(3e6);\n\n//サイズがnの非負整数配列で総和がsであり奇数の要素がm個であるものの場合の数\nll f(ll n, ll s, ll m) {\n    ll result = 0;\n\n    //奇数の数を全探索\n    for (ll a = s % 1; a <= min(n, m); a += 2) {\n        //まず奇数になるところを決める\n        ll curr_num = comb(n, a);\n\n        //上で選んだ箇所に1を入れたとする\n        //残りs - aをn個の要素にそれぞれ偶数となるように分ければ良い\n        //そのような分け方は結局(s - a) / 2をn個に分ける\n        //要素と仕切りのやつ\n        (curr_num *= comb((s - a) / 2 + n - 1, n - 1)) %= MOD;\n\n        (result += curr_num) %= MOD;\n    }\n\n    return result;\n}\n\nint main() {\n    ll N, M;\n    cin >> N >> M;\n\n    //最大値が2Mを超えないという条件を無視した数\n    ll ans = f(N, 3 * M, M);\n\n    //最大値が2Mを超えるものの数を引く\n    ll sub = N * (f(N, M, M) - f(N - 1, M, M)) % MOD;\n    (ans += MOD - sub) %= MOD;\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,s,t) for(int i=s;i<t;i++)\ntypedef long long ll;\n#define MAXNUM 1555555\nconst ll mod=998244353;\nll fact[MAXNUM],ifact[MAXNUM];\n\nll qpow(ll a, ll b)\n{\n    ll res = 1;\n    while (b)\n    {\n        if (b & 1)\n            res = res * a % mod;\n        a = a * a % mod, b >>= 1;\n    }\n    return res;\n}\nvoid sub(ll &a,ll b)\n{\n    a-=b;\n    if(a<0)a+=mod;\n}\nll getC(int a,int b)\n{\n    return fact[a]*ifact[b]%mod*ifact[a-b]%mod;\n}\nint main()\n{\n    int n,m;scanf(\"%d%d\",&n,&m);\n    fact[0]=ifact[0]=1;\n    rep(i,1,max(n,3*m)+1)fact[i]=fact[i-1]*i%mod,ifact[i]=qpow(fact[i],mod-2);\n    ll res=0;\n    rep(i,0,min(n,m)+1)\n    {\n        if(3*m-i>=0&&(3*m-i)%2==0)\n            (res+=getC(n,i)*getC((3*m-i)/2+n-1,n-1))%=mod;\n        if(m-i>=0&&(m-i)%2==0){\n            sub(res,getC(n,i)*getC((m-i)/2+n-1,n-1)%mod*n%mod);\n            if(n!=i)(res+=getC(n-1,i)*getC((m-i)/2+n-2,n-2)%mod*n)%=mod;\n        }\n    }\n    printf(\"%lld\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "// https://atcoder.jp/contests/agc036/tasks/agc036_c\n#define CIN_ONLY\n#define DECIMAL_DIGITS 10\n#define STATIC_MOD 998244353\n#ifdef BTK\n/*<head>*/\n#    include \"Template.hpp\"\n#    include \"num/ModInt.hpp\"\n/*</head>*/\n#else\n/*<body>*/\n/* #region auto includes */\n/* #region stl */\n/*<stl>*/\n#    include <bits/stdc++.h>\n#    include <sys/types.h>\n#    include <unistd.h>\nusing namespace std;\n/*</stl>*/\n/* #endregion */\n/* #region template/IncludeSTL.hpp*/\n/**\n * @file IncludeSTL.hpp\n * @author btk\n * @brief 標準ライブラリをincludeするだけ\n * @version 0.1\n * @date 2019-07-21\n *\n * @copyright Copyright (c) 2019\n *\n */\n\n/*<head>*/\n#    pragma once\n/*</head>*/\n\n\n/*<stl>*/\n#    include <bits/stdc++.h>\n#    include <sys/types.h>\n#    include <unistd.h>\nusing namespace std;\n/*</stl>*/\n/* #endregion */\n/* #region template/Macro.hpp*/\n/**\n * @file Macro.hpp\n * @author btk\n * @brief マクロとか，LLとか\n * @version 0.1\n * @date 2019-07-13\n *\n * @copyright Copyright (c) 2019\n *\n */\n\n\n//! LL\nusing LL = long long;\n\n/**\n * @def DEBUG\n * @brief デバッグ用のif文 提出時はif(0)で実行されない\n */\n\n/*</head>*/\n#    ifdef BTK\n#        define DEBUG if (1)\n#    else\n#        ifdef CIN_ONLY\n#            define FAST_IO\n#        endif\n#        define DEBUG if (0)\n#    endif\n/**\n * @def ALL(v)\n * @brief\n * ALLマクロ\n */\n#    define ALL(v) (v).begin(), (v).end()\n\n/**\n * @def REC(ret, ...)\n * @brief\n * 再帰ラムダをするためのマクロ\n */\n#    define REC(ret, ...) std::function<ret(__VA_ARGS__)>\n\n/**\n * @def VAR_NAME(var)\n * @brief 変数名を取得する\n */\n#    define VAR_NAME(var) #    var\n\n/**\n * @brief\n * rangeで生まれる使わない変数を消す用（警告消し）\n */\ntemplate <typename T>\ninline T& unused_var(T& v) {\n    return v;\n}\n/* #endregion */\n/* #region template/IO.hpp*/\n/**\n * @file IO.hpp\n * @author btk\n * @brief cin高速化とか，出力の小数桁固定とか\n * @version 0.1\n * @date 2019-07-13\n *\n * @copyright Copyright (c) 2019\n */\n\n\n/**\n * @brief 入出力の設定を行うための構造体\n */\nstruct cww {\n    /**\n     * @brief Construct a new cww::cww object\n     * @details\n     * CIN_ONLYを定義すると，submit時にcinとscanfの同期を切る設定が走る\n     * DECIMAL_DIGITSを定義すると，doubleの出力時指定した桁数分小数部を吐くようになる\n     */\n    cww() {\n#    ifdef FAST_IO\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n#    endif\n#    ifdef DECIMAL_DIGITS\n        cout << fixed;\n        cout << setprecision(DECIMAL_DIGITS);\n#    endif\n    }\n};\n\n//! 入出力設定構造体を実体化\ncww star;\n\n/**\n * @brief\n * vectorに直接cin流すためのやつ\n * @tparam T\n * @param is\n * @param v\n * @return istream&\n */\ntemplate <typename T>\nstd::istream& operator>>(std::istream& is, std::vector<T>& v) {\n    for (auto& it : v) is >> it;\n    return is;\n}\n/* #endregion */\n/* #region template/Loop.hpp*/\n/**\n * @file Loop.hpp\n * @author btk\n * @brief rangeとかループ系のクラス\n * @version 0.1\n * @date 2019-07-13\n *\n * @copyright Copyright (c) 2019\n *\n */\n\n\n/**\n * @brief\n * rangeを逆向きに操作したいとき用\n * @details\n * ループの範囲は[bg,ed)なので注意\n * @see range\n */\nclass reverse_range {\n  private:\n    struct I {\n        int x;\n        int operator*() { return x - 1; }\n        bool operator!=(I& lhs) { return x > lhs.x; }\n        void operator++() { --x; }\n    };\n    I i, n;\n\n  public:\n    /**\n     * @brief Construct a new reverse range object\n     *\n     * @param n\n     */\n    reverse_range(int n) : i({0}), n({n}) {}\n    /**\n     * @brief Construct a new reverse range object\n     *\n     * @param i\n     * @param n\n     */\n    reverse_range(int i, int n) : i({i}), n({n}) {}\n    /**\n     * @brief\n     * begin iterator\n     * @return I&\n     */\n    I& begin() { return n; }\n    /**\n     * @brief\n     * end iterator\n     * @return I&\n     */\n    I& end() { return i; }\n};\n/**\n * @brief\n * python みたいな range-based for を実現\n * @details\n * ループの範囲は[bg,ed)なので注意\n * !つけると逆向きにループが回る (reverse_range)\n * 空間計算量はO(1)\n * 使わない変数ができて警告が出がちなので，unused_varとかを使って警告消しするとよい\n */\nclass range {\n  private:\n    struct I {\n        int x;\n        int operator*() { return x; }\n        bool operator!=(I& lhs) { return x < lhs.x; }\n        void operator++() { ++x; }\n    };\n    I i, n;\n\n  public:\n    /**\n     * @brief Construct a new range object\n     *\n     * @param n\n     */\n    range(int n) : i({0}), n({n}) {}\n    /**\n     * @brief Construct a new range object\n     *\n     * @param i\n     * @param n\n     */\n    range(int i, int n) : i({i}), n({n}) {}\n    /**\n     * @brief\n     * begin iterator\n     * @return I&\n     */\n    I& begin() { return i; }\n    /**\n     * @brief\n     * end iterator\n     * @return I&\n     */\n    I& end() { return n; }\n    /**\n     * @brief\n     * 逆向きに参照するrange(reverse_rangeを取得できるs)\n     * @return reverse_range\n     */\n    reverse_range operator!() { return reverse_range(*i, *n); }\n};\n/* #endregion */\n/* #region template/MinMaxOperation.hpp*/\n/**\n * @file MinMaxOperation.hpp\n * @author btk\n * @brief 最大値とか最小値を求める\n * @version 0.1\n * @date 2019-07-04\n *\n * @copyright Copyright (c) 2019\n *\n */\n\n/**\n * @brief 2項の最小値求める\n *\n * @tparam T\n */\ntemplate <typename T>\nstruct min_op {\n    /**\n     * @brief 本体\n     *\n     * @param l\n     * @param r\n     * @return T\n     */\n    static T exec(const T l, const T r) { return l < r ? l : r; }\n};\n\n/**\n * @brief 2項の最大値求める\n *\n * @tparam T\n */\ntemplate <typename T>\nstruct max_op {\n    /**\n     * @brief 本体\n     *\n     * @param l\n     * @param r\n     * @return T\n     */\n    static T exec(const T l, const T r) { return l > r ? l : r; }\n};\n\n/**\n * @brief テンプレート再帰の末尾\n *\n * @tparam F 二項演算\n * @tparam T\n * @param v\n * @return T\n */\ntemplate <typename F, typename T>\ninline T multi_op(T&& v) {\n    return v;\n}\n\n/**\n * @brief 複数項における演算の結果を返す\n *\n * @tparam F\n * @tparam T\n * @tparam Ts\n * @param head\n * @param tail\n * @return T\n */\ntemplate <typename F, typename T, typename... Ts>\ninline T multi_op(const T head, Ts&&... tail) {\n    return F::exec(head, multi_op<F>(tail...));\n}\n\n/**\n * @brief 複数項の最小値\n * @see multi_op\n * @tparam T\n * @tparam Ts\n * @param head\n * @param tail\n * @return T\n */\ntemplate <typename T, typename... Ts>\ninline T multi_min(T&& head, Ts&&... tail) {\n    return multi_op<min_op<T>>(head, tail...);\n}\n\n/**\n * @brief 複数項の最大値\n * @see multi_op\n * @tparam T\n * @tparam Ts\n * @param head\n * @param tail\n * @return T\n */\ntemplate <typename T, typename... Ts>\ninline T multi_max(T&& head, Ts&&... tail) {\n    return multi_op<max_op<T>>(head, tail...);\n}\n\n/**\n * @brief\n * \b先頭の値をFで参照する関数に基づいて変更できたらする\n * @tparam F\n * @tparam T\n * @tparam Ts\n * @param target\n * @param candidates\n * @return true\n * @return false\n */\ntemplate <typename F, typename T, typename... Ts>\ninline bool ch_op(T& target, Ts&&... candidates) {\n    const T old = target;\n    target      = multi_op<F>(target, candidates...);\n    return old != target;\n}\n\n/**\n * @brief change min\n * @tparam T 型\n * @param target 変更する値\n * @param candidates\n * @return 更新があればtrue\n */\ntemplate <typename T, typename... Ts>\ninline bool chmin(T& target, Ts&&... candidates) {\n    return ch_op<min_op<T>>(target, candidates...);\n}\n\n/**\n * @brief chminのmax版\n * @see chmin\n *  @tparam T 型\n * @param target 変更する値\n * @param candidates\n * @return 更新があればtrue\n */\ntemplate <typename T, typename... Ts>\ninline bool chmax(T& target, Ts&&... candidates) {\n    return ch_op<max_op<T>>(target, candidates...);\n}\n/* #endregion */\n/* #region template/Random.hpp*/\n/**\n * @file Random.hpp\n * @author btk\n * @brief 乱数生成系\n * @version 0.1\n * @date 2019-07-13\n * @copyright Copyright (c) 2019\n */\n\n\n//! 乱数のシード値をプロセスIDとして取得\nconst pid_t pid = getpid();\n\n/**\n * @brief XorShift32の実装\n */\nclass XorShift32 {\n  private:\n    //! XorShiftの現在の値\n    unsigned value;\n\n    /**\n     * @brief XorShift32のアルゴリズムに基づいて value を更新\n     */\n    inline void update() {\n        value = value ^ (value << 13);\n        value = value ^ (value >> 17);\n        value = value ^ (value << 5);\n    }\n\n    /**\n     * @brief 値を更新し，更新前の値を返却\n     * @return unsigned 呼び出し時の value を用いる\n     */\n    inline unsigned get() {\n        unsigned v = value;\n        update();\n        return v;\n    }\n\n  public:\n    /**\n     * @brief [0, 2^bit) の範囲の乱数値を取り出す\n     * @tparam デフォルトは31\n     * @return int\n     */\n    template <int bit = 31>\n    inline int next_int() {\n        return (int)(get() >> (32 - bit));\n    }\n\n    /**\n     * @brief [-2^bit,2^bit)の範囲の乱数値を取り出す\n     * @tparam デフォルトは31\n     * @return int\n     */\n    template <int bit = 31>\n    inline int next_signed() {\n        unsigned v = get();\n        return (int)((v >> (31 - bit)) - (1 << (bit)));\n    }\n\n    /**\n     * @brief next_int呼び出し時の最大値を取得\n     * @tparam 31\n     * @return int\n     */\n    template <int bit = 31>\n    inline int range_max() {\n        return (int)((1u << bit) - 1);\n    };\n\n    /**\n     * @brief Construct a new XorShift32 object\n     * @param seed\n     * @details 初期シードをvalueとするXorShift32のインスタンスを生成\n     */\n    XorShift32(const unsigned seed) {\n        value = seed;\n        update();\n    }\n\n    /**\n     * @brief Construct a new XorShift 32 object\n     * @details 初期シードをプロセスIDとするXorShift32のインスタンスを生成\n     */\n    XorShift32() : XorShift32(pid) {}\n};\n/* #endregion */\n/* #region Template.hpp*/\n/**\n * @file Template.hpp\n * @brief 競技プログラミング用テンプレート\n * @author btk15049\n * @date 2019/05/02\n */\n\n\n/* #endregion */\n/* #region num/ModInt.hpp*/\n\n#    include <utility>\n\n/**\n * @file ModInt.hpp\n * @brief mod構造体\n * @author btk15049\n * @date 2019/03/08\n * @details\n *  \\todo verifyが足りない\n *  verify: CSA12E，RUPC day3 F\n */\n\n//! [WARNING!] mod が入力で与えられる場合はconstexprを外す\n#    ifdef STATIC_MOD\nconstexpr int mod = STATIC_MOD;\n#    else\nint mod;\n#    endif\n\n/**\n * @brief mod構造体\n * @details\n * 整数をラップして，常に保持されているデータがmodされた状態になるよう管理．\n */\nclass ModInt {\n  private:\n    //! 中身\n    int x;\n\n  public:\n    /**\n     * @brief ゲッター\n     * @details 出力時などは \"cout << *ret << endl;\"のようにやるとよい．\n     */\n    long long operator*() const { return x; }\n    /**\n     * @brief デフォルトコンストラクタ．0で初期化される．\n     */\n    ModInt() { x = 0; }\n\n    /**\n     * @brief intからのコンストラクタ\n     * @param[in] y 設定したい値\n     * @details\n     * modをとらないので高速．ただしmodより大きい値や負の数を入れると事故るので注意．\n     */\n    ModInt(const int y) { x = y; }\n\n    /**\n     * @brief long longからのコンストラクタ\n     * @param[in] y 設定したい値\n     * @details 毎回modを取るので低速．\n     */\n    ModInt(const long long y) { x = (int)((mod + y % mod) % mod); }\n\n    /**\n     * @brief ModIntからの代入演算子\n     * @param[in] o 設定したい値\n     * @details 高速\n     */\n    ModInt(const ModInt& o) { this->x = *o; }\n    /**\n     * @brief 整数から高速にModIntを作りたいときに使う\n     * @param[in] x 設定したい値\n     * @details xが[0,mod)であることが保証されてないと正しく動かない．\n     */\n    static inline ModInt raw(const long long x) {\n        // assert(x<mod);\n        return ModInt((int)x);\n    }\n\n    /**\n     * @brief 整数から安全にModIntを作りたいときに使う\n     * @param[in] x 設定したい値\n     * @details mod2回取るから遅い．負数でもOK．\n     */\n    static inline ModInt get(const long long x) { return ModInt(x); }\n\n    /**\n     * @brief intからの代入演算子\n     * @param[in] o 設定したい値\n     * @details\n     * modをとらないので高速．ただしmodより大きい値や負の数を入れると事故るので注意．\n     */\n    ModInt& operator=(const int o) {\n        this->x = o >= mod ? o - mod : o;\n        return *this;\n    }\n\n    /**\n     * @brief long longからの代入演算子\n     * @param[in] o 設定したい値\n     * @details mod2回取るから遅い．負数でもOK．\n     */\n    ModInt& operator=(const long long o) {\n        this->x = (int)((mod + o % mod) % mod);\n        return *this;\n    }\n\n    /**\n     * @brief ModIntからの代入演算子\n     * @param[in] o 設定したい値\n     * @details 高速\n     */\n    ModInt& operator=(const ModInt o) {\n        this->x = *o;\n        return *this;\n    }\n};\n\n/**\n * @param[in] l ModInt\n * @param[in] r ModInt\n * @details if文使って少し高速化．\n */\ninline ModInt add(const ModInt l, const ModInt r) {\n    const long long x = *l + *r;\n    return ModInt::raw(x >= mod ? x - mod : x);\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r ModInt．\n */\ninline ModInt mul(const ModInt l, const ModInt r) {\n    return ModInt::raw(*l * *r % mod);\n}\n\n/**\n * @brief a^x %modを求める\n * @param[in] a ModInt\n * @param[in] x long long．\n */\ninline ModInt pow(ModInt a, long long x) {\n    ModInt ret = ModInt::raw(1);\n    while (x) {\n        if (x & 1) {\n            ret = mul(ret, a);\n        }\n        a = mul(a, a);\n        x >>= 1;\n    }\n    return ret;\n}\n\n/**\n * @brief x^-1 %modを求める\n * @param[in] x ModInt．\n * @details\n *   内部ではユークリッドの拡張互助法を使っている．\n *   O(log(mod))\n */\ninline ModInt inv(const ModInt x) {\n    long long a = *x, b = mod, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        std::swap(a -= t * b, b);\n        std::swap(u -= t * v, v);\n    }\n    return ModInt::get(u);\n}\n\n/**\n * @brief 負数を求める単項演算子\n * @param[in] x ModInt\n */\ninline ModInt operator-(const ModInt x) { return add(mod, -*x); }\n\n/**\n * @param[in] l ModInt\n * @param[in] r ModInt\n */\ninline ModInt operator+(const ModInt l, const ModInt r) { return add(l, r); }\n\n/**\n * @param[in] l ModInt\n * @param[in] r ModInt\n */\ninline ModInt operator*(const ModInt l, const ModInt r) { return mul(l, r); }\n\n/**\n * @param[in] l ModInt\n * @param[in] r ModInt\n */\ninline ModInt operator-(const ModInt l, const ModInt r) { return add(l, -r); }\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n * @details\n * 右辺は定数を想定しているのでmodをとらないrawを使ってModIntに変換している．ただしmodより大きい値や負の数を入れると事故るので注意．\n */\ninline ModInt operator+(const ModInt l, const int r) {\n    return add(l, ModInt::raw(r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n */\ninline ModInt operator+(const ModInt l, const long long r) {\n    return add(l, ModInt::get(r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n * @details\n * 右辺は定数を想定しているのでmodをとらないrawを使ってModIntに変換している．ただしmodより大きい値や負の数を入れると事故るので注意．\n */\ninline ModInt operator*(const ModInt l, const int r) {\n    return mul(l, ModInt::raw(r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n */\ninline ModInt operator*(const ModInt l, const long long r) {\n    return mul(l, ModInt::get(r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n * @details\n * 右辺は定数を想定しているのでmodをとらないrawを使ってModIntに変換している．ただしmodより大きい値や負の数を入れると事故るので注意．\n */\ninline ModInt operator-(const ModInt l, const int r) {\n    return add(l, ModInt::raw(mod - r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n */\ninline ModInt operator-(const ModInt l, const long long r) {\n    return add(l, -ModInt::get(r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n * @details\n * 右辺は定数を想定しているのでmodをとらないrawを使ってModIntに変換している．ただしmodより大きい値や負の数を入れると事故るので注意．\n */\ninline ModInt operator/(const ModInt l, const int r) {\n    return mul(l, inv(ModInt::raw(r)));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n */\ninline ModInt operator/(const ModInt l, const long long r) {\n    return mul(l, inv(ModInt::get(r)));\n}\n\n/**\n* @param[in] l ModInt\n* @param[in] r long long\n* @details\n*   pow(l,r)を呼び出すだけなのでpowを参照のこと．\n計算量はO(log mod)\n*/\ninline ModInt operator^(const ModInt l, const long long r) { return pow(l, r); }\n\n/**\n * @brief\n * +=の実装、各operator+を呼ぶだけ\n * @tparam T\n * @param l ModInt\n * @param r 足すやつ\n * @return ModInt&\n */\ntemplate <typename T>\nModInt& operator+=(ModInt& l, T r) {\n    l = l + r;\n    return l;\n}\n\n/**\n * @brief\n * -=の実装、各operator-を呼ぶだけ\n * @tparam T\n * @param l ModInt\n * @param r 引くやつ\n * @return ModInt&\n */\ntemplate <typename T>\nModInt& operator-=(ModInt& l, T r) {\n    l = l - r;\n    return l;\n}\n\n/**\n * @brief\n * *=の実装、各operator*を呼ぶだけ\n * @tparam T\n * @param l ModInt\n * @param r かけるやつ\n * @return ModInt&\n */\ntemplate <typename T>\nModInt& operator*=(ModInt& l, T r) {\n    l = l * r;\n    return l;\n}\n\n/**\n * @namespace factorial\n * @brief 順列数関連の関数のまとめ\n * @details\n *   - combination\n *   - permutation\n *   - multiChoose\n */\nnamespace factorial {\n    //! 順列数を格納する配列のサイズ\n    constexpr int size =\n#    ifdef FACTORIAL_SIZE\n        FACTORIAL_SIZE;\n#    else\n        3123456;\n#    endif\n    //! 前計算ができているかどうかのフラグ\n    bool is_build = false;\n\n    //! 順列数を格納する配列\n    ModInt factorial[size];\n    //! (順列数)^-1を格納する配列\n    ModInt inverse_factorial[size];\n\n    /**\n     * @brief 順列数の前計算\n     * @details\n     *   順列数と，その逆元を[0,size)まで求める.\n     *   計算量は，O(size + log(mod))\n     */\n    void build() {\n        is_build     = true;\n        factorial[0] = 1;\n        for (int i = 1; i < size; i++) {\n            factorial[i] = factorial[i - 1] * i;\n        }\n        inverse_factorial[size - 1] = inv(factorial[size - 1]);\n        for (int i = size - 1; i >= 1; i--) {\n            inverse_factorial[i - 1] = inverse_factorial[i] * i;\n        }\n    }\n\n    /**\n     * @brief nPkを求める\n     * @details\n     *   前計算がしてあれば O(1)．前計算してない場合は is_build\n     * を読み取って前計算をする．\n     */\n    inline ModInt permutation(int n, int k) {\n        if (k < 0 || k > n) return ModInt::raw(0);\n        if (!is_build) build();\n        return factorial[n] * inverse_factorial[n - k];\n    }\n\n    /**\n     * @brief nCkを求める\n     * @details\n     *   前計算がしてあれば O(1)．前計算してない場合は is_build\n     * を読み取って前計算をする．\n     */\n    inline ModInt combination(int n, int k) {\n        if (k < 0 || k > n) return ModInt::raw(0);\n        if (!is_build) build();\n        return factorial[n] * inverse_factorial[k] * inverse_factorial[n - k];\n    }\n\n    /**\n     * @brief 重複組合せ\n     * @param n 何種類のものを\n     * @param r いくつ並べるか\n     * @return ModInt nHr\n     */\n    ModInt multiChoose(int n, int r) {\n        if (n == 0 && r == 0) return ModInt::raw(1);\n        return combination(n + r - 1, r);\n    }\n\n    /**\n     * @brief 上限付き重複組合せ\n     * @details\n     * 包除原理を用いて，lim個以上の品物が1,2,...,i種類の場合を足したり引いたりしていく\n     * 計算量は O(min(n, r / lim))\n     * @param n 何種類のものを\n     * @param r いくつ並べるか\n     * @param lim 1種類のものを選べる上限\n     * @return ModInt\n     */\n    ModInt multiChoose(int n, int r, int lim) {\n        ModInt ret = 0;\n        for (int i = 0; i <= n; i++) {\n            if (i * (lim + 1) > r) break;\n            ret += ((i & 1) ? mod - 1 : 1) * combination(n, i)\n                   * multiChoose(n, r - i * (lim + 1));\n        }\n        return ret;\n    }\n\n} // namespace factorial\n  /* #endregion */\n  /* #endregion */\n  /*</body>*/\n#endif\n\nint N, M;\n\n/**\n * @brief 奇数レーンがk個のときの解\n */\nModInt solve1(int k) {\n    if ((M * 3 - k) % 2) return ModInt(0);\n    if (M < k) return ModInt(0);\n    // T = +2(+1*2も含む)が何回行われたか\n    int T = (M * 3 - k) / 2;\n    // M = 純粋な+2が何回行われたか\n\n    ModInt a = factorial::combination(N, k);\n    // M がいない場合のみカウント\n    ModInt b = factorial::multiChoose(N, T, M - 1);\n    if (N < 10) {\n        cerr << VAR_NAME(N) << \" \" << N << endl;\n        cerr << VAR_NAME(T) << \" \" << T << endl;\n        cerr << VAR_NAME(M) << \" \" << M << endl;\n\n        cerr << k << \" \" << *a << \" \" << *b << endl;\n    }\n    return a * b;\n}\n\nModInt solve2() { return N * factorial::multiChoose(N - 1, M); }\n\nint main() {\n    cin >> N >> M;\n    ModInt ret = 0;\n    for (int i : range(N + 1)) {\n        ret += solve1(i);\n    }\n    ret += solve2();\n    cout << *ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 998244353\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nll n, m, ans;\nll fact[2222222];\nll dp[1111111];\nll dp2[1111111];\n\nlong long mod_div(long long a,long long b){\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n\nll nHr(ll n, ll r){\n\tll A = n - 1;\n\tll B = r;\n\treturn mod_div(fact[A + B], fact[A] * fact[B] % MOD);\n}\n\nll nCr(ll n ,ll r){\n\tif(r > n){\n\t\treturn 0;\n\t}\n\treturn mod_div(fact[n], fact[n - r] * fact[r] % MOD);\n}\n\nvoid init(){\n\tfact[0] = 1;\n\tfor(ll i = 1;i < 2222222;i++){\n\t\tfact[i] = fact[i-1] * i % MOD;\n\t}\n}\n\nint main(){\n\tinit();\n\tcin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n\n\tcin >> n >> m;\n\n\tREP(i, 1111111){\n\t\tdp2[i] = nHr(n - 1, i);\n\t\tif(i){\n\t\t\tdp2[i] = (dp2[i] + dp2[i-1]) % MOD;\n\t\t}\n\t}\n\tREP(i, 1111111){\n\t\tdp2[i] = (dp2[i] * n) % MOD;\n\t}\n\n\tdp[0] = 1;\n\tfor(ll i = 1;i < 1111111;i++){\n\t\tdp[i] = nHr(n, i);\n\t\tif(i > m){\n\t\t\tdp[i] = (dp[i] - dp2[i - (m+1)] + MOD) % MOD;\n\t\t}\n\t}\n\n\tfor(ll i = 0;i <= m;i++){\n\t\tif((3 * m - i) % 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tll now_m = (3 * m - i) / 2;\n\t\tll now_one = i;\n\t\tll now = dp[now_m] * nCr(n, i);\n\t\tif(now_m >= m && i){\n\t\t\tll tmp = nHr(n - 1, now_m - m) * nCr(n - 1, i - 1) % MOD;\n\t\t\ttmp = tmp * n % MOD;\n\t\t\tnow = (now + MOD - tmp) % MOD;\n\t\t}\n\t\t//cout << i << \" \" << now_m << \" \" << dp[now_m] << \" \" << now << endl;\n\t\tans = (ans + now) % MOD;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\n#define mp make_pair\n#define f first\n#define s second\n\ntypedef vector<int> vi;\n#define sz(x) (int)x.size()\n#define all(x) x.begin(), x.end();\n#define rsz resize\n#define pb push_back\n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto &a: x)\ntypedef long double ld; \nconst int MOD = (119<<23) + 1;\nconst ld PI = 4*atan((ld)1);\n\nvi invs, fac, ifac;\nvoid genFac(int SZ){\n\tinvs.rsz(SZ), fac.rsz(SZ), ifac.rsz(SZ);\n\tinvs[1] = fac[0] = ifac[0] = 1;\n\tFOR(i,2,SZ) invs[i] = MOD-(ll)MOD/i*invs[MOD%i]%MOD;\n\tFOR(i,1,SZ){\n\t\tfac[i] = (ll)fac[i-1]*i%MOD;\n\t\tifac[i] = (ll)ifac[i - 1]*invs[i]%MOD;\n\t}\n}\n\nll comb(int a, int b){\n\tif (a < b || b < 0) return 0;\n\treturn (ll) fac[a]*ifac[b]%MOD*ifac[a-b]%MOD;\n}\n\n\nint main(){\n\tint n, m; cin >> n >> m;\n\t//all - stars and bars\n\tgenFac(4000000);\n\tll complement = comb(3*m + n - 1, n - 1);\n\tfor (int odds = m + 1; odds <= n; odds++){\n\t\tif ((3 * m - odds) % 2 == 0){\n\t\t\tif (3 * m >= odds){\n\t\t\t\tll cnt = comb(n, odds); //these are odd\n\t\t\t\tcnt *= comb((3 * m - odds) / 2 + n - 1, n - 1);\n\t\t\t\tcnt %= MOD;\n\t\t\t\tcomplement -= cnt;\n\t\t\t}\n\t\t}\n\t}\n\n\tll cnt = n; //there's a number at least 2 * m + 1\n\tcnt *= comb(m - 1 + n - 1, n - 1);\n\tcnt %= MOD;\n\tcomplement -= cnt;\n\tcomplement %= MOD;\n\tcomplement += MOD;\n\tcomplement %= MOD;\n\tcout << complement << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : C.cpp\n * Author  : Kazune Takahashi\n * Created : 7/21/2019, 10:28:37 PM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n#define maxs(x, y) (x = max(x, y))\n#define mins(x, y) (x = min(x, y))\nusing ll = long long;\nclass mint\n{\npublic:\n  static ll MOD;\n  ll x;\n  mint() : x(0) {}\n  mint(ll x) : x(x % MOD) {}\n  mint operator-() const { return x ? MOD - x : 0; }\n  mint &operator+=(const mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  mint &operator-=(const mint &a) { return *this += -a; }\n  mint &operator*=(const mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  mint &operator/=(const mint &a)\n  {\n    mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  mint operator+(const mint &a) const { return mint(*this) += a; }\n  mint operator-(const mint &a) const { return mint(*this) -= a; }\n  mint operator*(const mint &a) const { return mint(*this) *= a; }\n  mint operator/(const mint &a) const { return mint(*this) /= a; }\n  bool operator<(const mint &a) const { return x < a.x; }\n  bool operator==(const mint &a) const { return x == a.x; }\n  const mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\nll mint::MOD = 998244353;\nistream &operator>>(istream &stream, mint &a) { return stream >> a.x; }\nostream &operator<<(ostream &stream, const mint &a) { return stream << a.x; }\nclass combination\n{\npublic:\n  vector<mint> inv, fact, factinv;\n  static int MAX_SIZE;\n  combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[mint::MOD % i]) * (mint::MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1; i < MAX_SIZE; i++)\n    {\n      fact[i] = mint(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  mint operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n};\nint combination::MAX_SIZE = 3000010;\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\n// constexpr double epsilon = 1e-10;\n// constexpr ll infty = 1000000000000000LL;\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n\nll N, M;\n\nint main()\n{\n  cin >> N >> M;\n  combination C;\n  mint ans = C(3 * M + N - 1, N - 1);\n  for (auto K = 3 * M; K >= 2 * M + 1; K--)\n  {\n    ans -= C(3 * M - K + N - 2, N - 2) * N;\n  }\n  for (auto K = 0LL; K < M; K++)\n  {\n    ans -= C(N, 3 * M - 2 * K) * C(K + N - 1, N - 1);\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_set>\n#include <bitset>\n#include <time.h>\n#include <limits.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define Fi first\n#define Se second\n#define pb push_back\n#define szz(x) (int)x.size()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\ntypedef tuple<int, int, int> t3;\n\nconst int mod = 998244353;\n\nint N, M;\nll F[3000010], IF[3000010];\n\nll pw(ll x, ll y = mod - 2) {\n\tll res = 1;\n\twhile(y) {\n\t\tif(y & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nll nCr(int n, int r) {\n\tif(r < 0 || r > n) return 0;\n\treturn F[n] * IF[r] % mod * IF[n-r] % mod;\n}\n\nint main() {\n\tF[0] = 1; for(int i=1;i<3000010;i++) F[i] = i * F[i-1] % mod;\n\tIF[3000009] = pw(F[3000009]);\n\tfor(int i=3000008;i>=0;i--) IF[i] = (i+1) * IF[i+1] % mod;\n\tscanf(\"%d%d\", &N, &M);\n\tll ans = 0;\n\tfor(int t=0;t<=N && t<=M;t++) {\n\t\tif((3*M-t) % 2 != 0) continue;\n\t\t\n\t\tint sum = (3 * M - t) / 2;\n\t\tll C1 = nCr(N, t) * nCr(N + sum - 1, sum) % mod;\n\t\t\n\t\tans = (ans + C1) % mod;\n\t\tif(sum >= M) {\n\t\t\tint sum2 = sum - M;\n\t\t\tll C2 = nCr(N, t) * nCr(N + sum2 - 1, sum2) % mod * t % mod;\n\t\t\tans = (ans - C2 + mod) % mod;\n\t\t}\n\t\tif(sum >= M+1) {\n\t\t\tint sum2 = sum - M - 1;\n\t\t\tll C2 = nCr(N, t) * nCr(N + sum2 - 1, sum2) % mod * (N-t) % mod;\n\t\t\tans = (ans - C2 + mod) % mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\n\n#define MAX_N 3000010\nlong long inv[MAX_N];\nlong long factorial[MAX_N];\nlong long inv_factorial[MAX_N];\n\nvoid GetInv(){\n    for (int i = 1; i < MAX_N; i++) {\n        if (i == 1) inv[i] = 1;\n        else {\n            inv[i] = (mod - (mod / i) * inv[mod % i]) % mod;\n            if (inv[i] < 0) inv[i] += mod;\n        }\n    }\n}\nvoid GetFactorial(){\n    factorial[0] = 1; inv_factorial[0] = 1;\n    for (int i = 1; i < MAX_N; i++) {\n        factorial[i] = factorial[i-1] * i;\n        factorial[i] %= mod;\n        inv_factorial[i] = inv_factorial[i-1] * inv[i];\n        inv_factorial[i] %= mod;\n    }\n}\n\nlong long combination(int n, int r) {\n    if (n-r < 0) return 0;\n    assert(max(n, r) < MAX_N);\n    long long ret = factorial[n] * inv_factorial[r];\n    ret %= mod;\n    ret *= inv_factorial[n-r];\n    return ret % mod;\n}\n\nlong long modpow(int n, int r) {\n    long long ret = 1; long long tmp = (long long) n;\n    while (r != 0) {\n        if (r % 2) ret *= tmp;\n        tmp *= tmp; tmp %= mod; ret %= mod;\n        r /= 2;\n    }\n    return ret;\n}\n\nint solve(int n, int m) {\n    GetInv(); GetFactorial();\n    long long all = combination(3*m+n-1, n-1);\n    long long sub = 0;\n    for (int k = m+1; k <= n; k++) {\n        if (k > n) break;\n        int remain = 3*m - k;\n        if (remain < 0) continue;\n        if (remain % 2 != 0) continue;\n        long long tmp = combination(n, k);\n        tmp = tmp * combination(remain/2 + n-1, n-1) % mod;\n        sub = (sub + tmp) % mod;\n    }\n    long long sub2 = 0;\n    for (int k = 2 * m+1; k <= 3*m; k++) {\n        int remain = 3*m - k;\n        if (remain < 0) continue;\n        long long tmp = combination(remain+n-2, n-2) * n % mod;\n        sub2 = (sub2 + tmp) % mod;\n    }\n    cout << (all + mod * 2 - sub - sub2) % mod << endl;\n    return 0;\n}\n\nint main() {\n    int n, m; cin >> n >> m;\n    solve(n, m);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma target(\"avx\")\n#pragma optimize(\"O3\")\n#pragma optimize(\"unroll-loops\")\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <memory>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#define rep(i,n) for(int i=0;i<(lint)(n);i++)\n#define REP(i,n) for(int i=1;i<=(lint)(n);i++)\n#define all(V) V.begin(),V.end()\ntypedef long long lint;\ntypedef std::pair<lint, lint> P;\nconstexpr int INF = INT_MAX/2;\nconstexpr lint LINF = LLONG_MAX/2;\nconstexpr double eps = 1e-9;\nconstexpr double PI=3.141592653589793238462643383279;\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ninline lint gcd(lint a, lint b) {\n\twhile (b) {\n\t\tlint c = a;\n\t\ta = b; b = c % b;\n\t}\n\treturn a;\n}\ninline lint lcm(lint a, lint b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(lint n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\ntemplate<typename T>\nT mypow(T a, unsigned int b) {\n\tif (!b)return T(1);\n\tif (b & 1)return mypow(a, b - 1) * a;\n\tT memo = mypow(a, b >> 1);\n\treturn memo * memo;\n}\nlint modpow(lint a, lint b, lint m) {\n\tif (!b)return 1;\n\tif (b & 1)return modpow(a, b - 1, m) * a % m;\n\tlint memo = modpow(a, b >> 1, m);\n\treturn memo * memo % m;\n}\ntemplate<typename T>\nvoid printArray(std::vector<T>& vec) {\n\trep(i, vec.size() - 1)std::cout << vec[i] << \" \";\n\tstd::cout << vec.back() << std::endl;\n}\ntemplate<typename T>\nvoid printArray(T l, T r) {\n\tT rprev = r;\n\trprev--;\n\tfor (T i = l; i != rprev; i++) {\n\t\tstd::cout << *i << \" \";\n\t}\n\tstd::cout << *rprev << std::endl;\n}\ntemplate<unsigned int modulo = 998244353>\nclass ModInt {\n\tlint value;\npublic:\n\tModInt() : value(0) {}\n\ttemplate<typename T>\n\tModInt(T value = 0) : value(value) {\n\t\tif (value < 0)value = -(lint)(-value % modulo) + modulo;\n\t\tthis->value = value % modulo;\n\t}\n\tinline operator int()const { return value; }\n\tinline ModInt& operator+=(const ModInt& x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline ModInt operator-()const {\n\t\treturn ModInt(0) -= *this;\n\t}\n\tinline ModInt& operator-=(const ModInt& x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator*=(const ModInt& x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator/=(ModInt rhs) {\n\t\tint exp = modulo - 2;\n\t\twhile (exp) {\n\t\t\tif (exp & 1)*this *= rhs;\n\t\t\trhs *= rhs;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn *this;\n\t}\n\ttemplate<typename T> ModInt operator+(const T& rhs)const { return ModInt(*this) += rhs; }\n\ttemplate<typename T> ModInt& operator+=(const T& rhs) { return operator+=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator-(const T& rhs)const { return ModInt(*this) -= rhs; }\n\ttemplate<typename T> ModInt& operator-=(const T& rhs) { return operator-=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator*(const T& rhs)const { return ModInt(*this) *= rhs; }\n\ttemplate<typename T> ModInt& operator*=(const T& rhs) { return operator*=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator/(const T& rhs)const { return ModInt(*this) /= rhs; }\n\ttemplate<typename T> ModInt& operator/=(const T& rhs) { return operator/=(ModInt(rhs)); }\n};\ntemplate<unsigned int T>\nstd::istream& operator>>(std::istream& ist, ModInt<T>& x) {\n\tlint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\nint n,m;\nModInt<> fact[2000010],inv[2000010];\nModInt<> comb(int a,int b){\n\tif(a<b)return 0;\n\treturn fact[a]*inv[a-b]*inv[b];\n}\nModInt<> comb2(int a,int b){\n\treturn comb(a+b-1,b-1);\n}\nint main(){\n\tstd::cin>>n>>m;\n\tfact[0]=1;\n\tREP(i,2000000)fact[i]=fact[i-1]*i;\n\tinv[2000000]=ModInt<>(1)/fact[2000000];\n\tfor(int i=1999999;i>=0;i--)inv[i]=inv[i+1]*(i+1);\n\tModInt<> ans=0;\n\tfor(int i=m;i>=0;i-=2){\n\t\tans+=comb(n,i)*comb2((3*m-i)/2,n)-(comb(n,i)*comb2((m-i)/2,n)-comb(n-1,i)*comb2((m-i)/2,n-1))*n;\n\t}\n\tstd::cout<<ans<<std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "[p#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n    x = 0; char c = getchar(); int f = 0;\n    for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n    for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n    if (f) x = -x;\n}\n\nnamespace {\n\tconst int mo = 998244353;\n\tinline int add(int x, int y) { x += y; return x >= mo ? x - mo : x; }\n\tinline int sub(int x, int y) { x -= y; return x < 0 ? x + mo : x; } \n\tinline int mul(int x, int y) { return (lo) x * y % mo; }\n\tinline int power(int a, int k = mo - 2) {\n\t\tint ans = 1;\n\t\tfor (; k; k >>= 1, a = mul(a, a))\n\t\t\tif (k & 1) ans = mul(ans, a);\n\t\treturn ans;\n\t}\n}\nconst int N = 3e6 + 233;\nint n, m;\nint fac[N], ifac[N];\n\ninline int C(int n, int m) {\n\tif (n < m) return 0;\n\telse if (m == 0 || m == n) return 1;\n\telse return mul(fac[n], mul(ifac[m], ifac[n - m]));\n}\n\ninline void prepare(int n) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i++) fac[i] = mul(fac[i - 1], i);\n\tifac[n] = power(fac[n]);\n\tfor (int i = n - 1; i >= 0; i--) ifac[i] = mul(ifac[i + 1], i + 1);\n}\n\nint main(void) {\n\tread(n); read(m);\n\tprepare(max(n, m) * 2);\n\tint ans = 0;\n\tfor (int d = 0; d <= min(m, n); d++) {\n\t\tif ((3 * m - d) % 2 == 0) {\n\t\t\tauto F = [] (int k, int n) {\n\t\t\t\treturn C(k / 2 + n - 1, n - 1);\n\t\t\t};\n\t\t\tans = add(ans, mul(C(n, d), F(3 * m - d, n)));\n\t\t\tans = sub(ans, mul(C(n, d), mul(n, F(m - d, n))));\n\t\t\tans = add(ans, mul(C(n, d), mul(n - d, F(m - d, n - 1))));\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ninline int read()\n{\n\tint ret=0; char c=getchar();\n\twhile(c<48||c>57)c=getchar();\n\twhile(c>=48 && c<=57)ret=ret*10+c-48,c=getchar();\n\treturn ret;\n}\n#define N 200093\nlong long k;\nint T,f[N],g[N],u,v,st[N],t,n,a[N],h[N],tt;\nint hh[N];\ninline void pr(int u)\n{\n//\tstatic h[]  777///  7777777\n\tint tt=0;\n\tfor(int i=u;i<=n;++i){\n\t\tif(hh[a[i]]){\n\t\t\twhile(st[tt]!=a[i])hh[st[tt--]]=0;\n\t\t\thh[st[tt--]]=0;\n\t\t} else hh[a[i]]=1,st[++tt]=a[i]; \n\t}\n\tfor(int i=1;i<=tt;++i)printf(\"%d \",st[i]);\n\texit(0);//goto  } ??? //\n}\n\nint main()\n{\n\tn=read(); cin >> k;\n\tfor(int i=1;i<=n;++i) a[i]=read();\n\tfor(int i=1;i<=n;++i) {\n\t\tif(!h[a[i]])h[a[i]]=i;\n\t}\n\tfor(int i=n;i;--i){\n\t\tif(!g[a[i]])f[i]=h[a[i]]; else f[i]=g[a[i]];\n\t\tg[a[i]]=i;\n\t}\n\t\n\tu=1; h[u]=1; t=1;\n\t\n\tmemset(h,0,sizeof(h)); //_\n\t\n\tif(k==t)pr(u);\n\twhile(1){\n\t\tv=f[u]+1;if(v>n)v=1;\n\t\tif(v<=u+1)++t;\n\t\tif(k==t)pr(v);\n\t\tif(h[v]){\n\t\t\tT=t-h[v];\n\t\t\tk-=t;\n\t\t\tu=v;\n\t\t\tbreak;\n\t\t}\n\t\tu=v;\n\t\th[u]=t;\n\t}\n\tk%=T;\n\tif(!k)pr(u);\n\twhile(1){\n\t\tv=f[u]+1;if(v>n)v=1;\n\t\tif(v<=u+1)--k;\n\t\tu=v;\n\t\tif(!k)pr(v);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<ll,pll> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=998244353;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nll Pow(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nconst int M=2000005;\nll F[M];\n\nvoid Init(){\n\tF[0]=1;\n\tfor(int i=1;i<M;i++) F[i]=F[i-1]*i%mod;\n}\n\nll Div(ll n,ll m){\n\treturn n*Pow(m,mod-2)%mod;\n}\n\nll nCk(ll n,ll k){\n\treturn Div(F[n],F[n-k]*F[k]%mod);\n}\n\nll nHk(ll n,ll k){\n\treturn nCk(n+k-1,k);\n}\n\nint n,m;\n\nint main(){\n\tInit();\n\tcin>>n>>m;\n\tll res=nHk(n,3*m);\n\tfor(int i=m+1;i<=n;i++) if((3*m-i)%2==0) res=(res-nHk(n,(3*m-i)/2)*nCk(n,i)%mod+mod)%mod;\n\tfor(int i=2*m+1;i<=3*m;i++) res=(res-n*nHk(n-1,3*m-i)%mod+mod)%mod;\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconstexpr ll mod=998244353 ;\n\n\nvector<ll> inv,fact,invfact;\nvoid mod_build(int n=101010){\n    fact.resize(n+1);\n    inv.resize(n+1);\n    invfact.resize(n+1);\n    fact[0]=inv[0]=invfact[0]=1;\n    inv[1]=1;\n    rep(i,n){\n        fact[i+1]=fact[i]*(i+1)%mod;\n        if(i>0)inv[i+1]=mod-inv[mod%(i+1)]*(mod/(i+1))%mod;\n        invfact[i+1]=invfact[i]*inv[i+1]%mod;\n    }\n}\nll perm(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*invfact[n-k]%mod;\n}\nll comb(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return (fact[n]*invfact[n-k]%mod)*invfact[k]%mod;\n}\nll powmod(ll n,ll k){\n    k%=mod-1;\n    if(k<0)k+=mod-1;\n    ll ret=1;\n    while(k){\n        if(k&1)ret=ret*n%mod;\n        n=n*n%mod;\n        k>>=1;\n    }\n    return ret;\n}\nint main(){\n    ll n,m;\n    cin>>n>>m;\n    mod_build(3000000);\n    ll ok=comb(n-1+3*m,3*m),ng=comb(n-1+m-1,m-1);\n    REP(i,m+1,n+1){\n        int s = 3*m-i, t = m-i;\n        if(s%2==0)ok += mod-comb(n,i)*comb(n+s/2-1,n-1)%mod;\n        if(t%2==0){\n            ng+=mod-comb(n-1,i-1)*comb(n+t/2-1,n-1)%mod;\n            ng+=mod-comb(n-1,i)*comb(n+t/2-2,n-1)%mod;\n        }\n    }\n    ok%=mod;\n    ng=ng*n%mod;\n    cout<<(ok-ng+mod)%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid read(int &x) {\n    x=0;int f=1;char ch=getchar();\n    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-f;\n    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';x*=f;\n}\n\nvoid print(int x) {\n    if(x<0) putchar('-'),x=-x;\n    if(!x) return ;print(x/10),putchar(x%10+48);\n}\nvoid write(int x) {if(!x) putchar('0');else print(x);putchar('\\n');}\n\n#define lf double\n#define ll long long \n\n#define pii pair<int,int >\n#define vec vector<int >\n\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\n#define FOR(i,l,r) for(int i=l,i##_r=r;i<=i##_r;i++)\n\nconst int maxn = 3e6+10;\nconst int inf = 1e9;\nconst lf eps = 1e-8;\nconst int mod = 998244353;\n\nint fac[maxn],ifac[maxn];\n\nint qpow(int a,int x) {\n    int res=1;\n    for(;x;x>>=1,a=1ll*a*a%mod) if(x&1) res=1ll*res*a%mod;\n    return res;\n}\n\nvoid gen() {\n    fac[0]=ifac[0]=1;\n    for(int i=1;i<maxn;i++) fac[i]=1ll*fac[i-1]*i%mod;\n    ifac[maxn-1]=qpow(fac[maxn-1],mod-2);\n    for(int i=maxn-2;i;i--) ifac[i]=1ll*ifac[i+1]*(i+1)%mod;\n}\n\nint c(int a,int b) {return a<b?0:1ll*fac[a]*ifac[b]%mod*ifac[a-b]%mod;}\n\nint add(int a,int b) {a+=b;if(a>=mod) a-=mod;return a;}\nint del(int a,int b) {a-=b;a+=a>>31&mod;return a;}\n\nint f(int n,int m,int k) {\n    int ans=0;\n    for(int i=m&1;i<=k;i+=2) ans=add(ans,1ll*c(n,i)*c(n-1+(m-i)/2,n-1)%mod);\n    return ans;\n}\n\nint main() {\n    gen();int n,m;read(n),read(m);\n    write(del(f(n,m*3,m),1ll*n*del(f(n,m,m),f(n-1,m,m))%mod));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n\n#define rep(i, n)    for(int i = 0; i < (n); ++i)\n#define repA(i, a, n)  for(int i = a; i <= (n); ++i)\n#define repD(i, a, n)  for(int i = a; i >= (n); --i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define fill(a)  memset(a, 0, sizeof (a))\n#define fst first\n#define snd second\n#define mp make_pair\n#define pb push_back\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nll f[5000009],inv[5000009];\nconst ll mod= 998244353;\nvoid pre(){\n\tf[0]=f[1]=1;\n\tinv[0]=inv[1]=1;\n\trepA(i,2,5000000){\n\t\tf[i]=f[i-1]*i%mod;\n\t\tinv[i]=mod-(mod/i)*inv[mod%i]%mod;\n\t}\n\trepA(i,2,5000000) inv[i]=inv[i-1]*inv[i]%mod;\n\n}\nll C(int n,int r){\n\tif(r<0||r>n) return 0;\n\treturn f[n]*inv[r]%mod*inv[n-r]%mod;\n}\nvoid solve(){\n\n\n}\n\nint main() {\n\tcin.sync_with_stdio(0); cin.tie(0);\n\tcin.exceptions(cin.failbit);\n\tpre();\n\tint n;cin>>n;\n\tint m;cin>>m;\n\tll ans = C(3*m+n-1,n-1);\n\trep(i,m){\n\t\tans-=C(i+n-2,n-2)*n%mod;\n\t}\n\trepA(i,m+2,n){\n\t\tans-=1ll*C(n,i)*C((3*m-i)/2+n-1,n-1)%mod;\n\t\ti++;\n\t}\n\tcout<<(ans%mod+mod)%mod;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n//  a^b % m\nlong long powmod(long long a, long long b, long long m)\n{\n    long long r = 1;\n    for (; b>0; b>>=1, a=a*a%m)\n        if (b&1)\n            r = r*a%m;\n    return r;\n}\n\nint main()\n{\n    long long N, M;\n    cin>>N>>M;\n\n    long long MOD = 998244353;\n    long long t = M*3/2;\n\n    vector<long long> T1(t+1);\n    for (int i=0; i<=M; i++)\n        T1[i] = 1;\n    for (int i=1; i<N; i++)\n    {\n        vector<long long> P(t+1);\n        P.swap(T1);\n\n        //for (int i=0; i<=t; i++)\n        //{\n        //    for (int j=0; j<=min(i, (int)M); j++)\n        //        T1[i] += P[i-j];\n        //    T1[i] %= MOD;\n        //}\n\n        T1[0] = P[0];\n        for (int i=1; i<=t; i++)\n        {\n            T1[i] = T1[i-1] + P[i];\n            if (i-M-1>=0)\n                T1[i] -= P[i-M-1];\n            T1[i] = (T1[i]+MOD)%MOD;\n        }\n    }\n\n    vector<long long> T2(t+1);\n    for (int i=0; i<=M-1; i++)\n        T2[i] = 1;\n    if (M-1>0)\n    for (int i=1; i<N; i++)\n    {\n        vector<long long> P(t+1);\n        P.swap(T2);\n\n        //for (int i=0; i<=t; i++)\n        //{\n        //    for (int j=0; j<=min(i, (int)M-1); j++)\n        //        T2[i] += P[i-j];\n        //    T2[i] %= MOD;\n        //}\n\n        T2[0] = P[0];\n        for (int i=1; i<=t; i++)\n        {\n            T2[i] = T2[i-1] + P[i];\n            if (i-(M-1)-1>=0)\n                T2[i] -= P[i-(M-1)-1];\n            T2[i] = (T2[i]+MOD)%MOD;\n        }\n    }\n\n    vector<long long> F(N+1);\n    F[0] = 1;\n    for (int i=1; i<=N; i++)\n        F[i] = F[i-1]*i%MOD;\n\n    long long ans = 0;\n    for (int o=M*3%2; o<=N; o+=2)\n    {\n        long long t1 = F[N]*powmod(F[o], MOD-2, MOD)%MOD*powmod(F[N-o], MOD-2, MOD)%MOD;\n        ans += T2[(M*3-o)/2]*t1;\n        ans %= MOD;\n\n        if (o<N)\n        {\n            long long t2 = F[N-1]*powmod(F[o], MOD-2, MOD)%MOD*powmod(F[N-1-o], MOD-2, MOD)%MOD;\n            ans += (T1[(M*3-o)/2] - T2[(M*3-o)/2] + MOD)%MOD*t2;\n            ans %= MOD;\n        }\n    }\n\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <cstring>\n#include <chrono>\n#include <vector>\n#include <map>\n#include <random>\n#include <set>\n#include <algorithm>\n#include <math.h>\n#include <cstdio>\n#include <stdio.h>\n#include <queue>\n#include <bitset>\n#include <cstdlib>\n#include <deque>\n#include <cassert>\n#include <stack>\nusing namespace std;\n\n#define max3(a, b, c) max(a, max(b, c))\n#define min3(a, b, c) min(a, min(b, c))\n#define mp make_pair\n#define f first\n#define se second\n#define pb push_back\n#define ppb pop_back\n#define ll long long\n#define y1 abcde\n#define ull unsigned long long\n#define cntbit(x) __builtin_popcount(x)\n#define endl '\\n'\n#define uset unordered_set\n#define umap unordered_map\n#define all(x) x.begin(), x.end()\n#define pii pair<int, int>\n#define ld long double\n#define pll pair<long long, long long>\n#define int long long\n\nconst int mod = 998244353;\nconst int inf = 2e9;\nconst int N = 5e6 + 15;\nint n, m, ans, a[N], fact[N];\n\ninline void calc_factorial() {\n    fact[0] = fact[1] = 1;\n    for(int i = 2; i < N; ++i)\n        fact[i] = (fact[i-1] * i) % mod;\n}\n\ninline int binpow(int n, int k) {\n    int res = 1;\n    while(k) {\n        if(k & 1)\n            res = (res * n) % mod;\n        k >>= 1;\n        n = (n * n) % mod;\n    }\n    return res;\n}\n\ninline int multiply(int a, int b) {\n    return (a * b) % mod;\n}\n\ninline int divide(int a, int b) {\n    return multiply(a, binpow(b, mod - 2));\n}\n\ninline int C(int n, int k) {\n    if(k > n || n < 0 || k < 0)\n        return 0;\n    return divide(fact[n], multiply(fact[n - k], fact[k]));\n}\n\ninline void add(int &a, int b) {\n    a += b;\n    if(a >= mod)\n        a -= mod;\n    if(a < 0)\n        a += mod;\n}\n\nmain() {\n    cin >> n >> m;\n    calc_factorial();\n    for(int odd = 0; odd <= min(n, m); ++odd) {\n        if((3 * m - odd) & 1)\n            continue;\n        int even = (3 * m - odd) / 2;\n        add(ans, multiply(C(n, odd), C(even + n - 1, n - 1)));\n    }\n    for(int odd = 0; odd <= min(n, m); ++odd) {\n        if((m - odd) & 1)\n            continue;\n        int even = (m - odd) / 2;\n        add(ans, -multiply(n, multiply(C(n, odd), C(even + n - 1, n - 1))));\n        add(ans, multiply(n, multiply(C(n - 1, odd), C(even + n - 2, n - 2))));\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n#include <iostream>\n\n/* Modulus must be less than 0x80000000, and must not be 0. */\ntemplate <uint32_t Modulus>\nclass IntMod {\n\ttypedef int Int;\n\ttypedef unsigned int UInt;\n\ttypedef long long Long;\n\ttypedef unsigned long long ULong;\n\npublic:\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator==(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator!=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator<(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator<=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator>(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator>=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\nprivate:\n\tUInt value_m;\n\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(UInt value) { value_m = value % Modulus; }\n\tIntMod(ULong value) { value_m = value % Modulus; }\n\tIntMod(Int value) {\n\t\tInt tmp = value % (Int)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(Long value) {\n\t\tInt tmp = value % (Long)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(const IntMod& other) : value_m(other.value_m) {}\n\tIntMod& operator=(const IntMod& other) { value_m = other.value_m; return *this; }\n\t\n\tconst IntMod& operator+() const { return *this; }\n\tIntMod operator-() const { return IntMod(Modulus - value_m); }\n\tIntMod& operator++() {\n\t\t++value_m;\n\t\tif (value_m == Modulus) value_m = 0;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) value_m = Modulus;\n\t\t--value_m;\n\t\treturn *this;\n\t}\n\tIntMod operator++(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t++(*this);\n\t\treturn tmp;\n\t}\n\tIntMod operator--(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t--(*this);\n\t\treturn tmp;\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tvalue_m += right.value_m;\t\t// value_m < 0x80000000\n\t\tif (value_m >= Modulus) value_m -= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\tif (value_m < right.value_m) value_m += Modulus;\n\t\tvalue_m -= right.value_m;\n\t\treturn *this;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tvalue_m = ((ULong)value_m * right.value_m) % Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\t// for power\n\tIntMod operator[](ULong exp) const {\n\t\treturn Pow(exp);\n\t}\n\n\t/* Modulus must be a prime. */\n\tIntMod Inverse() const { return (*this).Pow(Modulus - 2); }\n\tIntMod Pow(ULong exp) const {\n\t\tIntMod product = 1;\n\t\tIntMod factor(*this);\n\t\twhile (exp > 0) {\n\t\t\tif (exp & 1) product *= factor;\n\t\t\tfactor *= factor;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn product;\n\t}\n\tUInt Get_value() const {\n\t\treturn value_m;\n\t}\n\n\tstatic IntMod Fact(UInt num) {\n\t\tstatic std::vector<IntMod> table(1, 1);\n\t\tif (table.size() > num) return table[num];\n\n\t\tint old_size = table.size();\n\t\ttable.resize(num + 1);\n\t\tfor (int i = old_size; i <= num; i++) {\n\t\t\ttable[i] = table[i - 1] * i;\n\t\t}\n\t\treturn table[num];\n\t}\n\n\tstatic IntMod Combi(UInt n, UInt r) {\n\t\tif (n < r) throw \"okashii\";\n\t\treturn IntMod::Fact(n) / (IntMod::Fact(n - r) * IntMod::Fact(r));\n\t}\n\n\tstatic IntMod Permutation(UInt n, UInt r) {\n\t\tif (n < r) throw \"okashii\";\n\t\treturn IntMod::Fact(n) / IntMod::Fact(n - r);\n\t}\n\n\tstatic std::vector<IntMod> Inverse_list(int size) {\n\t\tassert(size < Modulus);\n\t\tstd::vector<IntMod> ret_arr(size + 1);\n\t\tret_arr[1] = 1;\n\t\tfor (int i = 2; i <= size; ++i) {\n\t\t\tret_arr[i] = ((ULong)(Modulus - Modulus / i) * ret_arr[Modulus % i].Get_value()) % Modulus;\n\t\t}\n\t\treturn ret_arr;\n\t}\n};\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret += right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret -= right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret *= right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret /= right;\n\treturn ret;\n}\n\n\ntemplate <uint32_t Modulus>\nbool operator==(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m == right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator!=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m != right.value_m; }\n/* for set/map */\ntemplate <uint32_t Modulus>\nbool operator<(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m < right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator<=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m <= right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator>(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m > right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator>=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m >= right.value_m; }\n\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, Integer right) { return left + IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator+(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) + right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, Integer right) { return left - IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator-(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) - right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, Integer right) { return left * IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator*(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) * right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, Integer right) { return left / IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator/(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) / right; }\n\ntemplate <uint32_t Modulus>\nstd::istream& operator<<(std::istream& ist, const IntMod<Modulus>& val) {\n\tuint64_t tmp;\n\tist >> tmp;\n\tval = tmp;\n\treturn ist;\n}\n\ntemplate <uint32_t Modulus>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Modulus>& val) {\n\tost << val.Get_value();\n\treturn ost;\n}\n\ntypedef IntMod<1000000007> MInt;\n\n#if 1\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\n#endif\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"BinaryMatrix.h\"\n#include \"BIT.h\"\n#include \"Factorization.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"LazySegmentTree.h\"\n#include \"Math.h\"\n#include \"Matrix.h\"\n#include \"MinMax.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"SuffixArray.h\"\n#include \"Tree.h\"\n#include \"UnionFind.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nusing MP = IntMod<998244353>;\nint N, M;\n\nMP H(int n, int r) {\n\treturn MP::Combi(n + r - 1, r - 1);\n}\n\nint main() {\n\tcin >> N >> M;\n\tMP ans = H(3 * M, N) - N * MP::Combi(N + M - 2, N - 1);\n\n\tREP(i, 0, N + 1) {\n\t\tif ((3 * M + i) % 2 == 1) continue;\n\t\tint even = (3 * M - i) / 2;\n\t\tif (even >= i) continue;\n\t\tans -= MP::Combi(N, i) * H(even, N);\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <class T>inline T updmax(T& a, T b) {return a = max(a, b);}\ntemplate <class T>inline T updmin(T& a, T b) {return a = min(a, b);}\n\ntemplate <unsigned long long mod> class modint {\npublic:\n\tunsigned long long v;\n\tmodint(const long long x = 0) : v(x % mod) {}\n\tmodint operator+(const modint rhs) { return modint(*this) += rhs; }\n\tmodint operator-(const modint rhs) { return modint(*this) -= rhs; }\n\tmodint operator*(const modint rhs) { return modint(*this) *= rhs; }\n\tmodint operator/(const modint rhs) { return modint(*this) /= rhs; }\n\tmodint operator-() { return modint(mod - this->v); }\n\tmodint& operator+=(const modint rhs) {\n\t\tv += rhs.v;\n\t\tif (v >= mod) v -= mod;\n\t\treturn *this;\n\t}\n\tmodint& operator-=(const modint rhs) {\n\t\tif (v < rhs.v) v += mod;\n\t\tv -= rhs.v;\n\t\treturn *this;\n\t}\n\tmodint& operator*=(const modint rhs) {\n\t\tv = v * rhs.v % mod;\n\t\treturn *this;\n\t}\n\tmodint inverse(modint a) {\n\t\tunsigned long long exp = mod - 2;\n\t\tmodint ret(1ULL);\n\t\twhile (exp) {\n\t\t\tif (exp % 2) { ret *= a; }\n\t\t\ta *= a;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\tmodint& operator/=(modint rhs) {\n\t\t(*this) *= inverse(rhs);\n\t\treturn *this;\n\t}\n\tfriend ostream& operator<<(ostream& os, modint u) {\n\t\tos << u.v;\n\t\treturn (os);\n\t}\n\tfriend istream& operator>>(istream& is, modint& u) {\n\t\tis >> u.v;\n\t\treturn (is);\n\t}\n};\n\nconst int MOD = 998244353;\nusing mint = modint<MOD>;\n\nconst int MAX = 3000005;\nmint fact[MAX], invfact[MAX], inv[MAX];\n\nvoid facinit() {\n\tfact[0] = fact[1] = 1;\t\n\tinvfact[0] = invfact[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i < MAX; i++){\n\t\tfact[i] = fact[i - 1] * i;\n\t\tinv[i] = - inv[MOD%i] * (MOD / i);\n\t\tinvfact[i] = invfact[i - 1] * inv[i];\n\t}\n}\n\nmint nPr(int n, int r){\n\treturn fact[n] * invfact[n-r];\n}\n\nmint nCr(int n, int r){\n\tif(n < 0|| r < 0 || n < r)return mint{0};\n\treturn fact[n]*invfact[r]*invfact[n-r];\n}\n\nmint nHr(int n, int r){\n\tif(n == 0 && r == 0)return mint{1};\n\treturn nCr(n+r-1, r);\n}\n\nclass Solution {\npublic:\n\tvoid solve() {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tmint ok{0}, ng{0};\n\t\tfacinit();\n\t\tfor(int odd=m%2; odd <= min(n,m); odd+=2){\n\t\t\tok += nCr(n, odd) * nHr(n, (3*m-odd)/2);\n\t\t\tng += nCr(n, odd) * (nHr(n, (m-odd)/2) * odd + nHr(n, (m-odd-2)/2) * (n-odd));\n\t\t}\n\n\t\tcout << ok-ng << endl;\n\t\treturn;\n\t};\n};\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tSolution solution;\n\tsolution.solve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define y1 askjdkasldjlkasd\n#include <bits/stdc++.h>\n#undef y1\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi(a, b) for(int i=a; i<=b; i++)\n#define fj(a, b) for(int j=a; j<=b; j++)\n#define fo(a, b) for(int o=a; o<=b; o++)\n#define fdi(a, b) for(int i=a; i>=b; i--)\n#define fdj(a, b) for(int j=a; j>=b; j--)\n#define fdo(a, b) for(int o=a; o>=b; o--)\n#define sz(x) (int)x.size()\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\ntypedef pair<ll, ll> pll;\ntypedef vector<pll> vpll;\ntypedef vector<ll> vll;\n\n#ifdef LOCAL\n#define err(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define err(...) while (0)\n#endif\n\ndouble START_TIME;\n\nvoid exit() {\n#ifdef LOCAL\t\n\tcerr << \"TIME: \" << setprecision(5) << fixed << (clock() - START_TIME) / CLOCKS_PER_SEC << endl;\n#endif\t\n\texit(0);\n}\n\ntemplate<typename A, typename B>\nostream& operator<<(ostream& os, pair<A, B> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\";\n\treturn os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T> v) {\n\tfi(0, sz(v) - 1) {\n\t\tos << v[i] << \" \";\n\t}\n\treturn os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, set<T> t) {\n\tfor (auto z : t) {\n\t\tos << z << \" \";\n\t}\n\treturn os;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, map<T1, T2> t) {\n\tcerr << endl;\n\tfor (auto z : t) {\n\t\tos << \"\\t\" << z.first << \" -> \" << z.second << endl;\n\t}\n\treturn os;\n}\n\n#ifdef LOCAL\n#define dbg(x) {cerr << __LINE__ << \"\\t\" << #x << \": \" << x << endl;}\n#define dbg0(x, n) {cerr << __LINE__ << \"\\t\" << #x << \": \"; for (int ABC = 0; ABC < n; ABC++) cerr << x[ABC] << ' '; cerr << endl;}\n#else\n#define dbg(x) while(0){}\n#define dbg0(x, n) while(0){}\n#endif\n\n#ifdef LOCAL\n#define ass(x) if (!(x)) { cerr << __LINE__ << \"\\tassertion failed: \" << #x << endl, abort(); }\n#else\n#define ass(x) assert(x)\n#endif\n\n///////////////////////////////////////////////////\n\nconst int MAX = 2e6 + 41;\nconst int MOD = 998244353;\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nint sub(int a, int b) {\n\ta -= b;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint mul(int a, int b) {\n\treturn (ll) a * b % MOD;\n}\n\nint bp(int x, int d) {\n\tint res = 1;\n\twhile (d) {\n\t\tif (d & 1) res = mul(res, x);\n\t\tx = mul(x, x);\n\t\t d >>= 1;\n\t}\n\treturn res;\n}\n\nint inv(int x) {\n\treturn bp(x, MOD - 2);\n}\n\nint f[MAX];\nint invf[MAX];\n\nvoid init() {\n\tf[0] = 1;\n\tfi(1, MAX - 1) {\n\t\tf[i] = mul(f[i - 1], i);\n\t}\n\tfi(0, MAX - 1) invf[i] = inv(f[i]);\n}\n\nint getc(int n, int k) {\n\tif (n == k) return 1;\n\tif (n < k) return 0;\n\treturn mul(f[n], mul(invf[k], invf[n - k]));\n}\n\nint n, m;\n\nint calc(int z, int o, int q) {\n\tint res = 0;\n\tint v1 = 0, v2 = 0, v3 = 0;\n\t{//all\n\t\tv1 = getc(z + o - 1 + q, z + o - 1);\n\t}\n\t{//bz\n\t\tint v21 = z;\n\t\tint qq = q - (m + 1);\n\t\tif (qq >= 0) {\n\t\t\tint v22 = getc(z + o - 1 + qq, z + o - 1);\n\t\t\tv2 = mul(v21, v22);\n/*\n\t\t\terr(\"bz v22 = %d qq = %d\\n\", v22, qq);\n*/\n\t\t}\n\t}\n\t{//bo\n\t\tint v31 = o;\n\t\tint qq = q - m;\n\t\tif (qq >= 0) {\n\t\t\tint v32 = getc(z + o - 1 + qq, z + o - 1);\n\t\t\tv3 = mul(v31, v32);\n/*\n\t\t\terr(\"bo v32 = %d qq = %d\\n\", v32, qq);\n*/\n\t\t}\n\t}\n/*\n\terr(\"v1 = %d v2 = %d v3 = %d\\n\", v1, v2, v3);\n*/\n\tres = add(res, v1);\n\tres = sub(res, v2);\n\tres = sub(res, v3);\n\treturn res;\n}\n\nvoid solve () {\n\tint ans = 0;\n\tfo(0, m) {\n\t\tint rem = m * 3 - o;\n\t\tif (rem % 2 == 1) continue;\n\t\tint v1 = getc(n, o);\n\t\tint q2 = m + (m - o) / 2;\n\t\tint v2 = calc(n - o, o, q2);\n\t\tint v = mul(v1, v2);\n/*\n\t\terr(\"o = %d v1 = %d v2 = %d q2 = %d\\n\\n\", o, v1, v2, q2);\n*/\n\t\tans = add(ans, v);\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tSTART_TIME = (double)clock();\n#endif\n\n\tinit();\t\n\tscanf(\"%d %d\", &n, &m);\n\tsolve();\n\n\texit();\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!=====================================!//\n//!  8888ba.88ba           oo           !//\n//!  88  '8b  '8b                       !//\n//!  88   88   88 .d8888b. dP 88d888b.  !//\n//!  88   88   88 88'  '88 88 88'  '88  !//\n//!  88   88   88 88.  .88 88 88    88  !//\n//!  dP   dP   dP '88888P8 dP dP    dP  !//\n//!=====================================!//\nint main()\n{\n    const ll N = read<ll>();\n    ll K = read<ll>() * N;\n    const auto A = readVec<ll>(N);\n    constexpr int MAX = 200000;\n    std::vector<ll> last(MAX + 1, INF<ll>);\n    std::vector<ll> plus(N, 0);\n    for (int i = 2 * N - 1; i >= 0; i--) {\n        if (i < N) { plus[i] = last[A[i]] - i + 1; }\n        last[A[i % N]] = i;\n    }\n    std::vector<ll> dist(N, -1);\n    dist[0] = 0;\n    for (ll p = 0, plen = -1;;) {\n        const ll to = (p + plus[p]) % N, cost = dist[p] + plus[p];\n        if (plus[p] > K) {\n            std::vector<ll> ans;\n            std::vector<bool> in(MAX + 1, false);\n            for (ll i = 0; i < K; i++) {\n                const ll v = A[(p + i) % N];\n                if (in[v]) {\n                    for (; ans.back() != v;) { in[ans.back()] = false, ans.pop_back(); }\n                    in[v] = false, ans.pop_back();\n                } else {\n                    ans.push_back(v), in[v] = true;\n                }\n            }\n            for (const ll v : ans) { std::cout << v << \" \"; }\n            std::cout << std::endl;\n            return 0;\n        }\n        K -= plus[p];\n        if (dist[to] != -1 and plen == -1) { plen = cost - dist[to], K %= plen; }\n        dist[to] = cost, p = to;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nconst uint mod=998244353;\n//const uint mod=1000000007;\nstruct mint{\n\tuint v;\n\tmint(ll vv=0){s(vv%mod+mod);}\n\tmint& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmint operator-()const{return mint()-*this;}\n\tmint& operator+=(const mint&rhs){return s(v+rhs.v);}\n\tmint&operator-=(const mint&rhs){return s(v+mod-rhs.v);}\n\tmint&operator*=(const mint&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tmint&operator/=(const mint&rhs){return *this*=rhs.inv();}\n\tmint operator+(const mint&rhs)const{return mint(*this)+=rhs;}\n\tmint operator-(const mint&rhs)const{return mint(*this)-=rhs;}\n\tmint operator*(const mint&rhs)const{return mint(*this)*=rhs;}\n\tmint operator/(const mint&rhs)const{return mint(*this)/=rhs;}\n\tmint pow(int n)const{\n\t\tmint res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv()const{return pow(mod-2);}\n\t/*mint inv()const{\n\t\tint x,y;\n\t\tint g=extgcd(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn mint(x);\n\t}*/\n\tfriend ostream& operator<<(ostream&os,const mint&m){\n\t\treturn os<<m.v;\n\t}\n\tbool operator<(const mint&r)const{return v<r.v;}\n\tbool operator==(const mint&r)const{return v==r.v;}\n};\n\nconst int vcmax=(1<<21)+10;\nmint fact[vcmax],finv[vcmax],invs[vcmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vcmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vcmax-1]=fact[vcmax-1].inv();\n\tfor(int i=vcmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vcmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n//sum=a\n//odd<=b\nmint sub(int n,int a,int b){\n\tchmin(b,n);\n\tmint ans=0;\n\tfor(int i=a%2;i<=min({n,a,b});i+=2)\n\t\tans+=choose((a-i)/2+n-1,n-1)*choose(n,i);\n\treturn ans;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\tinitfact();\n\t\n\tint n,m;cin>>n>>m;\n\tmint ans=sub(n,3*m,m);\n\tans-=(sub(n,m,m)-sub(n-1,m,m))*n;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#define mod 998244353\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0' && ch<='9')x=x*10+ch-'0',ch=getchar();\n    return x*f;\n}\ninline void write(int x)\n{\n    if(x<0)putchar('-'),x=-x;\n    if(x>9)write(x/10);\n    putchar(x%10+'0');\n}\ninline void pr1(int x){write(x),putchar(' ');}\ninline void pr2(int x){write(x),puts(\"\");}\nint fac[2500010],inv[2500010];\ninline int power(int a,int b)\n{\n\tint ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=1LL*ans*a%mod;\n\t\ta=1LL*a*a%mod;\n\t\tb>>=1;\n\t}return ans;\n}\ninline int C(int n,int m)\n{\n\tif(n<0 || m<0)return 0;\n\treturn 1LL*fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main()\n{\n    //freopen(\"a.in\",\"r\",stdin);\n    //freopen(\"a.out\",\"w\",stdout);\n    fac[0]=1;\n    for(int i=1;i<=2500000;i++)fac[i]=1LL*fac[i-1]*i%mod;inv[2500000]=power(fac[2500000],mod-2);\n    for(int i=2500000;i>=1;i--)inv[i-1]=1LL*inv[i]*i%mod;\n    int n=read(),m=read(),ans;\n    ans=C(n-1+3*m,n-1);\n    for(int i=m+1;i<=min(n,3*m);i++)(ans-=1LL*C(n,i)*C(3*m-i+n-i-1,n-i-1)%mod-mod)%=mod;\n    for(int i=2*m+1;i<=3*m;i++)(ans-=1LL*n*C(3*m-i+n-2,n-2)%mod-mod)%=mod;\n    pr2(ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=1000005,M=998244353;\nint fac[N],inv[N],n,m,ans;\nint ksm(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=x*x%M)\n\t\tif (y&1)(ans*=x)%=M;\n\treturn ans;\t\n}\nint C(int x,int y){\n\tif (x<y)return 0;\n\treturn fac[x]*inv[y]%M*inv[x-y]%M;\n}\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tfac[0]=inv[0]=1;\n\tfor (int i=1;i<N;i++)fac[i]=fac[i-1]*i%M,inv[i]=ksm(fac[i],M-2);\n\tfor (int i=m&1;i<=m;i+=2)\n\t\t(ans+=C(n+(3*m-i)/2-1,n-1)*C(n,i))%=M;\n\tfor (int i=m&1;i<=m;i+=2)\n\t\t(ans+=M-n*C(n+(m-i)/2-1,n-1)%M*C(n,i)%M)%=M;\n\tn--;\n\tfor (int i=m&1;i<=m;i+=2)\n\t\t(ans+=(n+1)*C(n+(m-i)/2-1,n-1)%M*C(n,i)%M)%=M;\t\t\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD 998244353\n\nstruct llm{\n    ll value=0;\n    llm(const ll& val=0){this->value = (MOD + val % MOD) % MOD;}\n    llm(const int& val){this->value = (MOD + val % MOD) % MOD;}\n    llm(const llm& a) { llm(a.value); }\n    llm inv(){ll a = 1;ll b = this->value;for(ll m=MOD-2;m>0;m/=2){if(m&1){a=a*b%MOD;}b=b*b%MOD;}return llm(a);}\n    llm &operator+=(const llm &a) {this->value = (this->value + a.value) % MOD;return *this;}\n    llm &operator-=(const llm &a) {this->value = (this->value - a.value + MOD) % MOD;return *this;}\n    llm &operator*=(const llm &a) {this->value = (this->value * a.value) % MOD; return *this; }\n    explicit operator ll() const{return (ll)value;}\n    explicit operator int() const{return (int)value;}\n};\nllm operator+(const llm &a, const llm &b) { return llm(a.value + b.value); }\nllm operator-(const llm &a, const llm &b) { return llm(a.value - b.value); }\nllm operator*(const llm &a, const llm &b) { return llm(a.value * b.value); }\n#define pllm pair<llm,llm>\n\nllm Fa[5050505];\nllm C(const ll& a,const ll& b){\n    if(a<b||a<0||b<0)\n        return 0;\n    return Fa[a] * (Fa[b]* Fa[a - b]).inv();\n}\n\n\nll N,M;\nll i,j,k;\nllm ans;\nint main(){\n    scanf(\"%lld%lld\", &N, &M);\n    Fa[0] = 1;\n    fornum(i,0,5040302){\n        Fa[i + 1] = Fa[i] * (i + 1);\n    }\n    ans = C(N - 1 + M * 3, N - 1);\n    fornum(i,0,N+1){\n        if(i>M*3)\n            break;\n        if(i<=M){\n            if ((M * 3 - i) % 2)\n                continue;\n            if(M%2){\n                ans -= C(N, i) * N * C(N - 1 + (M - i - 2) / 2, N - 1);\n            }else{\n                ans -= C(N - 1, i) * N * C(N - 1 + (M - i - 2) / 2, N - 1);\n                ans -= C(N - 1, i - 1) * N * C(N - 1 + (M - i) / 2, N - 1);\n            }\n        }else{\n            if ((M * 3 - i) % 2)\n                continue;\n            ans -= C(N, i) * C(N - 1 + (M * 3 - i) / 2, N - 1);\n        }\n    }\n    printf(\"%lld\", (ll)ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 998244353\n \n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define MAX_N 4000010\n#define MOD 998244353\n#define int long long\nint inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i=2;i<MAX_N;i++){\n        inv[i] = MOD - (long long)inv[MOD%i] * (MOD/i) % MOD;\n        fac[i] = (long long)fac[i-1] * i % MOD;\n        finv[i] = (long long)finv[i-1] * inv[i] % MOD;\n    }\n}\n\nint comb(int a,int b)\n{\n    if(a < b){\n        return 0;\n    }\n    return fac[a] * ((long long)finv[b] * finv[a-b] % MOD) % MOD;\n}\n\nsigned main(){\n    int n,m;\n    cin >> n >> m;\n    make();\n    ll sm = comb(3*m+n-1,n-1);\n    ll tmp = 0;\n    for(int k = m+2;k<=3*m;k+=2){\n        int p = (3*m-k)/2;\n        //cerr << k << \" \" << p  << endl;\n        tmp += comb(n,k) * comb(p+n-1,n-1)%mod;\n        tmp %= mod;\n        //cerr << tmp << endl;\n    }\n    for(int k=2*m+1;k<=3*m;k++){\n        tmp += n*comb(3*m-k+n-2,n-2)%mod;\n        tmp %= mod;\n    }\n    //cerr << sm << \" \" << tmp << endl;\n    cout << (sm+mod-tmp)%mod << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n// #include \"prettyprint.hpp\"\n\nlong long MOD = 998244353;\n\nlong long inv(long long a, long long MOD) {\n  return a == 1 ? 1 : (long long)(MOD - MOD / a) * inv(MOD % a, MOD) % MOD;\n}\n\nint main() {\n  long long N, M;\n  cin >> N >> M;\n\n  long long N_1_INV = 1;\n  for (long long i = 1; i <= N - 1; i++) {\n    N_1_INV *= i;\n    N_1_INV %= MOD;\n  }\n  long long N_1 = N_1_INV;\n  // cout << \"N_1: \" << N_1_INV << endl;\n\n  N_1_INV = inv(N_1_INV, MOD);\n  // cout << \"check: \" << (N_1_INV * N_1) % MOD << endl;\n\n  long long a = 1;\n  for (long long i = 0; i < N - 1; i++) {\n    a *= (N + 3 * M - 1) - i;\n    a %= MOD;\n  }\n\n  long long b = 1;\n  for (long long i = 0; i < N - 1; i++) {\n    b *= (N + M - 2) - i;\n    b %= MOD;\n  }\n\n  // cout << \"a: \" << a << endl;\n  // cout << \"b: \" << b << endl;\n  // cout << \"N_1_INV: \" << N_1_INV << endl;\n  long long ans = a * N_1_INV - N * b * N_1_INV;\n  ans %= MOD;\n  ans += MOD;\n  ans %= MOD;\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,fma,abm,mmx,avx,avx2,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#ifdef rd\n#define trace(...) cout<<\"Line:\"<<__LINE__<<\" \"; __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate<typename Arg1>\nvoid __f(const char *name, Arg1 &&arg1) {\n\tcout<<name<<\" : \"<<arg1<<endl;\n}\ntemplate<typename Arg1, typename ... Args>\nvoid __f(const char *names, Arg1 &&arg1, Args &&... args) {\n\tconst char *comma=strchr(names+1,',');\n\tcout.write(names,comma-names)<<\" : \"<<arg1<<\" | \";\n\t__f(comma+1,args...);\n}\n#else\n#define trace(...)\n#define endl '\\n'\n#endif\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\ntypedef float f80;\n#define double long double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define sz(x) ((long long)x.size())\n#define fr(a,b,c) for(int a=b; a<=c; a++)\n#define rep(a,b,c) for(int a=b; a<c; a++)\n#define trav(a,x) for(auto &a:x)\n#define all(con) con.begin(),con.end()\nconst ll infl=0x3f3f3f3f3f3f3f3fLL;\nconst int infi=0x3f3f3f3f;\nconst int mod=998244353;\n//const int mod=1000000007;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> oset;\nauto clk=clock();\nmt19937_64 rang(chrono::high_resolution_clock::now().time_since_epoch().count());\nint rng(int lim) {\n\tuniform_int_distribution<int> uid(0,lim-1);\n\treturn uid(rang);\n}\nint powm(int a, int b) {\n\tint res=1;\n\twhile(b) {\n\t\tif(b&1)\n\t\t\tres=(res*a)%mod;\n\t\ta=(a*a)%mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nconst int N=3e6+5;\nint fact[N],ifact[N];\ninline int ncr(int n,int r) {\n\tif(n<r||r<0)\n\t\treturn 0;\n\treturn (((fact[n]*ifact[r])%mod)*ifact[n-r])%mod;\n}\ninline int idf(int n, int r) {\n\treturn ncr(n+r-1,r-1);\n}\nint vals[N];\nvoid solve() {\n\tfact[0]=1;\n\trep(i,1,N)\n\t\tfact[i]=(fact[i-1]*i)%mod;\n\tifact[N-1]=powm(fact[N-1],mod-2);\n\tfor(int i=N-2; i>=0; i--)\n\t\tifact[i]=(ifact[i+1]*(i+1))%mod;\n\tint n,m;\n\tcin>>n>>m;\n\tint ans=idf(3*m,n);\n\tfor(int i=2*m+1; i<=3*m; i++) {\n\t\tans=(ans-n*idf(3*m-i,n-1))%mod;\n\t}\n\tfor(int i=m+2; i<=3*m; i+=2) {\n\t\tans=(ans-ncr(n,i)*idf((3*m-i)/2,n))%mod;\n\t}\n\tif(ans<0)\n\t\tans+=mod;\n\tcout<<ans<<endl;\n}\n\nsigned main() {\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\tsrand(chrono::high_resolution_clock::now().time_since_epoch().count());\n\tcout<<fixed<<setprecision(10);\n\tint t=1;\n//\tcin>>t;\n\tfr(i,1,t)\n\t{\n\t\tsolve();\n\t}\n#ifdef rd\n\tcout<<endl<<endl<<endl<<endl<<\"Time elapsed: \"<<(double)(clock()-clk)/CLOCKS_PER_SEC<<endl;\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n/*\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\nusing namespace __gnu_pbds; // find_by_order(), order_of_key()\ntemplate<typename TK> using pbds_set = tree<TK, null_type, less<TK>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename TK, typename TV> using pbds_map = tree<TK, TV, less<TK>, rb_tree_tag, tree_order_statistics_node_update>;\n*/\n\nconstexpr lint MOD = 998244353;\nvector<lint> fac, facInv, inv;\nvoid facInit(int nmax)\n{\n    fac = facInv = inv = vector<lint>(nmax + 1, 1);\n    for (int i = 2; i <= nmax; i++)\n    {\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        facInv[i] = facInv[i-1] * inv[i] % MOD;\n    }\n}\nlint nCr(int n, int r)\n{\n    if (n<r || r<0) return 0;\n    if (n >= (int)fac.size()) facInit(n);\n    return (fac[n] * facInv[r] % MOD) * facInv[n-r] % MOD;\n}\nlint nPr(int n, int r)\n{\n    if (n<r || r<0) return 0;\n    if (n >= (int)fac.size()) facInit(n);\n    return fac[n] * facInv[n-r] % MOD;\n}\nlint power(lint x, lint n, lint mod=MOD)\n{\n    lint ans = 1;\n    while (n>0)\n    {\n        if (n & 1) (ans *= x) %= mod;\n        (x *= x) %= mod;\n       n >>= 1;\n    }\n   return ans;\n}\nlint doublefac(lint n)\n{\n    if (n < 0) return 0;\n    lint k = (n + 1) / 2;\n    if (n & 1) return fac[k * 2] * power(facInv[2], k) % MOD * power(fac[k], MOD - 2) % MOD;\n    else return fac[k] * power(facInv[2], k) % MOD;\n}\nint main()\n{\n    lint N, M;\n    cin >> N >> M;\n    lint tot = 0;\n    facInit(N + M * 4);\n    if (N == 2)\n    {\n        cout << M + 1 << endl;\n        return 0;\n    }\n    FOR(i, M, 3 * M / 2 + 1)\n    {\n        int j = 3 * M - i * 2;\n        // 偶数ブロックがi個，単独がj個\n        tot += nCr(i + N - 1, i) * nCr(N, j) % MOD;\n    }\n    lint bad = 0;\n    FOR(i, 2 * M + 1, 3 * M + 1)\n    {\n        // 最大がiとなってしまう場合\n        int nokori = 3 * M - i;\n        bad += N * nCr(N - 2 + nokori, nokori) % MOD;\n    }\n    lint ret = tot % MOD - bad % MOD;\n    while (ret < 0) ret += MOD;\n    cout << ret % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <tuple>\n#include <vector>\nusing ll = int64_t;\nclass range {private: struct I{ll x;ll operator*(){return x;}bool operator!=(I& lhs){return x<lhs.x;}void operator++(){++x;}};I i,n;\npublic:range(ll n):i({0}),n({n}){}range(ll i,ll n):i({i}),n({n}){}I& begin(){return i;}I& end(){return n;}};\nusing namespace std;\nconstexpr ll mod = 998244353;\n\n// Modulo calculus\n\n// With Montgomery multiply\n// Mod < 2^32, odd number\nconstexpr ll ceil_log2(ll x) {\n  ll y = 0;\n  while (x) {\n    ++y;\n    x /= 2;\n  }\n  return y;\n}\n\nconstexpr ll calc_np(const ll Mod, const ll R) {\n  ll res = 0;\n  ll t = 0;\n  ll r = R;\n  ll i = 1;\n  while (r > 1) {\n    if ((t % 2) == 0) {\n      t += Mod;\n      res += i;\n    }\n    t /= 2;\n    r /= 2;\n    i *= 2;\n  }\n  return res;\n}\n\ntemplate <ll Mod>\nclass ModIntMR {\n public:\n  explicit constexpr ModIntMR(const ll x) : data(reduction(x * R2)) {}\n  ModIntMR<Mod>& operator=(const ModIntMR<Mod>& that) {\n    data = that.data;\n    return *this;\n  }\n  explicit operator ll() const { return reduction(data); }\n  ModIntMR<Mod>& operator+=(const ModIntMR<Mod>& that) {\n    data += that.data;\n    if (data >= Mod) data -= Mod;\n    return *this;\n  }\n  ModIntMR<Mod>& operator-=(const ModIntMR<Mod>& that) {\n    data -= that.data;\n    if (data < 0) data += Mod;\n    return *this;\n  }\n  ModIntMR<Mod>& operator*=(const ModIntMR<Mod>& that) {\n    data = reduction(data * that.data);\n    return *this;\n  }\n  friend ModIntMR<Mod> operator+(ModIntMR<Mod> lhs, const ModIntMR<Mod>& rhs) {\n    lhs += rhs;\n    return lhs;\n  }\n  friend ModIntMR<Mod> operator-(ModIntMR<Mod> lhs, const ModIntMR<Mod>& rhs) {\n    lhs -= rhs;\n    return lhs;\n  }\n  friend ModIntMR<Mod> operator*(ModIntMR<Mod> lhs, const ModIntMR<Mod>& rhs) {\n    lhs *= rhs;\n    return lhs;\n  }\n  friend ModIntMR<Mod> operator^(ModIntMR<Mod> lhs, const ll rhs) {\n    if (rhs == 0) return ModIntMR<Mod>(1);\n    else if ((rhs % 2) == 1) return (lhs ^ (rhs-1)) * lhs;\n    else {\n      const auto half = lhs ^ (rhs / 2);\n      return half * half;\n    }\n  }\n  ModIntMR<Mod>& operator^=(const ll that) {\n    data = (*this ^ that).data;\n    return *this;\n  }\n private:\n  ll data;\n  static constexpr ll shift = ceil_log2(Mod);\n  static constexpr ll R = 1ll << shift;\n  static constexpr ll mask = R-1;\n  static constexpr ll R2 = R*R%Mod;\n  static constexpr ll Np = calc_np(Mod, R);\n  static constexpr ll reduction(const ll T) {\n    ll t = (T + ((T*Np)&mask)*Mod)>>shift;\n    return t >= Mod ? t - Mod : t;\n  }\n};\n\nusing modint = ModIntMR<mod>;\n\nll inv(ll a,ll p){\n  return ( a == 1 ? 1 : (1 - p*inv(p%a,a)) / a + p );\n}\n\nvector<modint> fact(2500001, modint(0));\nvector<modint> factinv(2500001, modint(0));\n\nmodint comb(ll n, ll k) {\n  const auto tmp = fact[n] * factinv[k];\n  return tmp * factinv[n-k];\n}\n \nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  fact[0] = modint(1);\n  factinv[0] = modint(1);\n  for (ll i : range(2500000)) {\n    fact[i+1] = fact[i] * modint(i+1);\n    factinv[i+1] = modint(inv(static_cast<ll>(fact[i+1]), mod));\n  }\n  ll n,m;\n  cin>>n>>m;\n  modint tmp = comb(3*m+n-1, n-1);\n  modint sub(0);\n  for (ll i = 2*m+1; i <= 3*m; ++i) {\n    sub += comb(3*m-i+n-2, n-2);\n  }\n  sub *= modint(n);\n  modint mno(0);\n  for (ll i = m+1; i <= n; ++i) {\n    ll rem = 3*m-i;\n    if (rem < 0 || (rem%2) == 1) continue;\n    mno += comb(rem/2+n-1, n-1) * comb(n, i);\n  }\n  modint res = tmp - sub - mno;\n  cout << static_cast<ll>(res) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long ans,n,m,mod=998244353ll,fact[1000005],invfact[1000005],tmp;\n\nlong long fastp(long long base,long long exp){\n    if(exp==0)return 1ll;\n    long long tmp2=fastp(base,exp/2ll);\n    tmp2=(tmp2*tmp2)%mod;\n    if(exp%2==1)tmp2*=base;\n    return tmp2%mod;\n}\n\nlong long binom(long long a,long long b){\n    if(b>a)return 0ll;\n\n    return ((fact[a]*invfact[b])%mod*invfact[a-b])%mod;\n}\n\nint main(){\n\n\tcin>>n>>m;\n\t\n\tfact[0]=1;\n\tfor(long long i=1;i<1000005;i++)fact[i]=(fact[i-1]*i)%mod;\n\tinvfact[1000004]=fastp(fact[1000004],mod-2ll);\n    for(long long i=1000003;i>=0;i--)invfact[i]=(invfact[i+1]*(i+1ll))%mod;\n\n\n    \n    ans=binom(n+3ll*m-1ll,n-1ll);\n    \n \n    \n    for(int i=0;i<m;i++){\n        ans-=(binom(n,i)*binom(n,m*3-2*i))%mod;\n        ans=(ans%mod+mod)%mod;\n    }\n    \n\n    for(int i=2*m+1;i<=(3*m);i++){\n        tmp+=binom(n-2+3*m-i,n-2);\n        tmp%=mod;\n    }\n\n    \n    ans-=(n*tmp)%mod;\n    ans=(ans%mod+mod)%mod;\n    \n    cout<<ans<<endl;\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Relive your past life.\n//Face your demons.\n//The past is never dead,it is not even past.\n//The memories are not only the key to the past but...also to the future.\n//coded in Rusty Lake\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  998244353ll\n#define N    3000000\nusing namespace std;\nint n,m;\nll jc[N+5],njc[N+5],ans;\nll fp(ll x,int k=998244351){\n    ll ans=1;\n    while(k){\n        if(k&1)ans=ans*x%orz;\n        k>>=1,x=x*x%orz;\n    }\n    return ans;\n}\nll c(int x,int y){return jc[x]*njc[y]%orz*njc[x-y]%orz;}\nll cal(int x){\n    if(x<0) return 0;\n    x/=2;\n    return c(x+n-1,n-1);\n}\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    jc[0]=1;\n    for(int i=1;i<=N;++i)jc[i]=jc[i-1]*i%orz;\n    njc[N]=fp(jc[N]);\n    for(int i=N;i;--i)njc[i-1]=njc[i]*i%orz;\n    for(int i=0;i<=m&&i<=n;++i){\n        if((m-i)&1) continue;\n        ll o=0;\n        o+=cal(m*3-i);\n        o-=cal(m-i)*i%orz;\n        o-=cal(m-i-2)*(n-i)%orz;\n        o=(o%orz+orz)%orz;\n        o=o*c(n,i)%orz;\n        ans+=o;\n    }\n    ans=(ans%orz+orz)%orz;\n    printf(\"%lld\\n\",ans);\n    //system(\"pause\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nconfirm 0LL and 1LL\nconfirm cornercases such as 0\nconfirm times of cin < 10^6\n*/\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\nusing Vec = vector<ll>;\nusing VecP = vector<P>;\nusing VecB = vector<bool>;\nusing VecC = vector<char>;\nusing VecD = vector<ld>;\nusing VecS = vector<string>;\nusing Graph = vector<VecP>;\ntemplate <typename T>\nusing Vec1 = vector<T>;\ntemplate <typename T>\nusing Vec2 = vector<Vec1<T> >;\n#define REP(i, m, n) for(ll i = (m); (i) < (n); ++(i))\n#define REPN(i, m, n) for(ll i = (m); (i) <= (n); ++(i))\n#define REPR(i, m, n) for(ll i = (m)-1; (i) >= (n); --(i))\n#define REPNR(i, m, n) for(ll i = (m); (i) >= (n); --(i))\n#define rep(i, n) REP(i, 0, n)\n#define repn(i, n) REPN(i, 1, n)\n#define repr(i, n) REPR(i, n, 0)\n#define repnr(i, n) REPNR(i, n, 1)\n#define all(s) (s).begin(), (s).end()\n#define pb push_back\n#define fs first\n#define sc second\ntemplate <typename T>\nbool chmax(T &a, const T b){if(a < b){a = b; return true;} return false;}\ntemplate <typename T>\nbool chmin(T &a, const T b){if(a > b){a = b; return true;} return false;}\ntemplate <typename T>\nll pow2(const T n){return (1LL << n);}\ntemplate <typename T>\nvoid cosp(const T n){cout << n << ' ';}\nvoid co(void){cout << '\\n';}\ntemplate <typename T>\nvoid co(const T n){cout << n << '\\n';}\ntemplate <typename T1, typename T2>\nvoid co(pair<T1, T2> p){cout << p.fs << ' ' << p.sc << '\\n';}\ntemplate <typename T>\nvoid co(const Vec1<T> &v){for(T i : v) cosp(i); co();}\ntemplate <typename T>\nvoid co(initializer_list<T> v){for(T i : v) cosp(i); co();}\ntemplate <typename T>\nvoid ce(const T n){cerr << n << endl;}\nvoid sonic(){ios::sync_with_stdio(false); cin.tie(0);}\nvoid setp(const ll n){cout << fixed << setprecision(n);}\nconstexpr int INF = 1e9+1;\nconstexpr ll LINF = 1e18+1;\n//constexpr ll MOD = 1e9+7;\nconstexpr ll MOD = 998244353;\nconstexpr ld EPS = 1e-11;\nconst ld PI = acos(-1);\n\nVec fac, finv;\n\nll PowMod(ll a, ll n){\n\tif(n < 0) return PowMod(PowMod(a, -n), MOD-2);\n\tif(n == 0) return 1;\n\tif(n == 1) return a;\n\tif(n%2 == 0) return PowMod(a*a%MOD, n/2);\n\treturn a*PowMod(a*a%MOD, n/2)%MOD;\n}\n\nvoid init(ll n = 2e6){\n\tfac.resize(n+1);\n\tfac[0] = 1;\n\trepn(i, n) fac[i] = fac[i-1]*i%MOD;\n\tfinv.resize(n+1);\n\tfinv[n] = PowMod(fac[n], MOD-2);\n\trepr(i, n) finv[i] = finv[i+1]*(i+1)%MOD;\n\tfinv[0] = 1;\n}\n\nll f(Vec &a, ll p, ll rest, ll odd){\n\t//co({p, rest, odd});\n\tif(!rest){\n\t\tfor(ll i = p; i < a.size(); ++i) a[i] = 0;\n\t\tunordered_map<ll, ll> ump;\n\t\tfor(ll i : a) ump[i]++;\n\t\tll res = fac[a.size()];\n\t\tfor(P i : ump) (res *= finv[i.sc]) %= MOD;\n\t\treturn res;\n\t}\n\tif(a[p - 1] * (a.size() - p) < rest) return 0;\n\tif(p == a.size()) return 0;\n\n\tll res = 0;\n\tfor(ll i = 0; i <= min(a[p - 1], rest); ++i){\n\t\ta[p] = i;\n\t\tif(i & 1){\n\t\t\tif(!odd) return 0;\n\t\t\tres += f(a, p + 1, rest - i, odd - 1);\n\t\t}\n\t\telse res += f(a, p + 1, rest - i, odd);\n\t}\n\treturn res;\n}\n\nint main(void){\n\tll n, m;\n\tcin >> n >> m;\n\n\tinit();\n\tVec a(n);\n\tll ans = 0;\n\tfor(ll i = 0; i <= 2 * m; ++i){\n\t\ta[0] = i;\n\t\tif(i & 1) ans += f(a, 1, 3 * m - i, m - 1);\n\t\telse ans += f(a, 1, 3 * m - i, m);\n\t}\n\tco(ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <tuple>\n#include <vector>\nusing ll = int64_t;\nclass range {private: struct I{int x;int operator*(){return x;}bool operator!=(I& lhs){return x<lhs.x;}void operator++(){++x;}};I i,n;\npublic:range(int n):i({0}),n({n}){}range(int i,int n):i({i}),n({n}){}I& begin(){return i;}I& end(){return n;}};\nusing namespace std;\nconstexpr int mod = 998244353;\n\n// Modulo calculus\n\n// With Montgomery multiply\n// Mod < 2^32, odd number\nconstexpr int ceil_log2(int x) {\n  int y = 0;\n  while (x) {\n    ++y;\n    x /= 2;\n  }\n  return y;\n}\n\nconstexpr int calc_np(const int Mod, const int R) {\n  int res = 0;\n  int t = 0;\n  int r = R;\n  int i = 1;\n  while (r > 1) {\n    if ((t % 2) == 0) {\n      t += Mod;\n      res += i;\n    }\n    t /= 2;\n    r /= 2;\n    i *= 2;\n  }\n  return res;\n}\n\ntemplate <int Mod>\nclass ModIntMR {\n public:\n  explicit constexpr ModIntMR(const int x) : data(reduction(static_cast<ll>(x) * R2)) {}\n  ModIntMR<Mod>& operator=(const ModIntMR<Mod>& that) {\n    data = that.data;\n    return *this;\n  }\n  explicit operator int() const { return reduction(data); }\n  ModIntMR<Mod>& operator+=(const ModIntMR<Mod>& that) {\n    data += that.data;\n    if (data >= Mod) data -= Mod;\n    return *this;\n  }\n  ModIntMR<Mod>& operator-=(const ModIntMR<Mod>& that) {\n    data -= that.data;\n    if (data < 0) data += Mod;\n    return *this;\n  }\n  ModIntMR<Mod>& operator*=(const ModIntMR<Mod>& that) {\n    data = reduction(static_cast<ll>(data) * that.data);\n    return *this;\n  }\n  friend ModIntMR<Mod> operator+(ModIntMR<Mod> lhs, const ModIntMR<Mod>& rhs) {\n    lhs += rhs;\n    return lhs;\n  }\n  friend ModIntMR<Mod> operator-(ModIntMR<Mod> lhs, const ModIntMR<Mod>& rhs) {\n    lhs -= rhs;\n    return lhs;\n  }\n  friend ModIntMR<Mod> operator*(ModIntMR<Mod> lhs, const ModIntMR<Mod>& rhs) {\n    lhs *= rhs;\n    return lhs;\n  }\n  friend ModIntMR<Mod> operator^(ModIntMR<Mod> lhs, const ll rhs) {\n    if (rhs == 0) return ModIntMR<Mod>(1);\n    else if ((rhs % 2) == 1) return (lhs ^ (rhs-1)) * lhs;\n    else {\n      const auto half = lhs ^ (rhs / 2);\n      return half * half;\n    }\n  }\n  ModIntMR<Mod>& operator^=(const ll that) {\n    data = (*this ^ that).data;\n    return *this;\n  }\n private:\n  int data;\n  static constexpr int shift = ceil_log2(Mod);\n  static constexpr int R = 1 << shift;\n  static constexpr int mask = R-1;\n  static constexpr int R2 = static_cast<ll>(R)*R%Mod;\n  static constexpr int Np = calc_np(Mod, R);\n  static constexpr int reduction(const ll T) {\n    int t = (T + ((T*Np)&mask)*Mod)>>shift;\n    return t >= Mod ? t - Mod : t;\n  }\n};\n\nusing modint = ModIntMR<mod>;\n\nll inv(ll a,ll p){\n  return ( a == 1 ? 1 : (1 - p*inv(p%a,a)) / a + p );\n}\n\nvector<modint> fact(2500001, modint(0));\nvector<modint> factinv(2500001, modint(0));\n\nmodint comb(int n, int k) {\n  const auto tmp = fact[n] * factinv[k];\n  return tmp * factinv[n-k];\n}\n \nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n,m;\n  cin>>n>>m;\n  ll mx = 3*m/2+n;\n  fact[0] = modint(1);\n  for (int i : range(mx)) {\n    fact[i+1] = fact[i] * modint(i+1);\n  }\n  factinv[mx] = modint(inv(static_cast<int>(fact[mx]), mod));\n  for (int i = mx; i > 0; --i) {\n    factinv[i-1] = factinv[i] * modint(i);\n  }\n  modint sub(0);\n  for (int i = 2*m+1; i <= 3*m; ++i) {\n    sub += comb(3*m-i+n-2, n-2);\n  }\n  sub *= modint(n);\n  modint mno(0);\n  for (int i = m%2; i <= n && i <= m; i+=2) {\n    ll rem = 3*m-i;\n    if (rem < 0) break;\n    mno += comb(rem/2+n-1, n-1) * comb(n, i);\n  }\n  modint res = mno - sub;\n  cout << static_cast<int>(res) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <tuple>\n#include <vector>\nusing ll = int64_t;\nclass range {private: struct I{int x;int operator*(){return x;}bool operator!=(I& lhs){return x<lhs.x;}void operator++(){++x;}};I i,n;\npublic:range(int n):i({0}),n({n}){}range(int i,int n):i({i}),n({n}){}I& begin(){return i;}I& end(){return n;}};\nusing namespace std;\nconstexpr int mod = 998244353;\n\n// Modulo calculus\n\n// With Montgomery multiply\n// Mod < 2^32, odd number\nconstexpr int ceil_log2(int x) {\n  int y = 0;\n  while (x) {\n    ++y;\n    x /= 2;\n  }\n  return y;\n}\n\nconstexpr int calc_np(const int Mod, const int R) {\n  int res = 0;\n  int t = 0;\n  int r = R;\n  int i = 1;\n  while (r > 1) {\n    if ((t % 2) == 0) {\n      t += Mod;\n      res += i;\n    }\n    t /= 2;\n    r /= 2;\n    i *= 2;\n  }\n  return res;\n}\n\ntemplate <int Mod>\nclass ModIntMR {\n public:\n  explicit constexpr ModIntMR(const int x) : data(reduction(x * R2)) {}\n  ModIntMR<Mod>& operator=(const ModIntMR<Mod>& that) {\n    data = that.data;\n    return *this;\n  }\n  explicit operator int() const { return reduction(data); }\n  ModIntMR<Mod>& operator+=(const ModIntMR<Mod>& that) {\n    data += that.data;\n    if (data >= Mod) data -= Mod;\n    return *this;\n  }\n  ModIntMR<Mod>& operator-=(const ModIntMR<Mod>& that) {\n    data -= that.data;\n    if (data < 0) data += Mod;\n    return *this;\n  }\n  ModIntMR<Mod>& operator*=(const ModIntMR<Mod>& that) {\n    data = reduction(static_cast<ll>(data) * that.data);\n    return *this;\n  }\n  friend ModIntMR<Mod> operator+(ModIntMR<Mod> lhs, const ModIntMR<Mod>& rhs) {\n    lhs += rhs;\n    return lhs;\n  }\n  friend ModIntMR<Mod> operator-(ModIntMR<Mod> lhs, const ModIntMR<Mod>& rhs) {\n    lhs -= rhs;\n    return lhs;\n  }\n  friend ModIntMR<Mod> operator*(ModIntMR<Mod> lhs, const ModIntMR<Mod>& rhs) {\n    lhs *= rhs;\n    return lhs;\n  }\n  friend ModIntMR<Mod> operator^(ModIntMR<Mod> lhs, const ll rhs) {\n    if (rhs == 0) return ModIntMR<Mod>(1);\n    else if ((rhs % 2) == 1) return (lhs ^ (rhs-1)) * lhs;\n    else {\n      const auto half = lhs ^ (rhs / 2);\n      return half * half;\n    }\n  }\n  ModIntMR<Mod>& operator^=(const ll that) {\n    data = (*this ^ that).data;\n    return *this;\n  }\n private:\n  int data;\n  static constexpr int shift = ceil_log2(Mod);\n  static constexpr int R = 1 << shift;\n  static constexpr int mask = R-1;\n  static constexpr int R2 = static_cast<ll>(R)*R%Mod;\n  static constexpr int Np = calc_np(Mod, R);\n  static constexpr int reduction(const int T) {\n    int t = (T + static_cast<ll>((T*Np)&mask)*Mod)>>shift;\n    return t >= Mod ? t - Mod : t;\n  }\n};\n\nusing modint = ModIntMR<mod>;\n\nll inv(ll a,ll p){\n  return ( a == 1 ? 1 : (1 - p*inv(p%a,a)) / a + p );\n}\n\nvector<modint> fact(2500001, modint(0));\nvector<modint> factinv(2500001, modint(0));\n\nmodint comb(int n, int k) {\n  const auto tmp = fact[n] * factinv[k];\n  return tmp * factinv[n-k];\n}\n \nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n,m;\n  cin>>n>>m;\n  ll mx = 3*m+n;\n  fact[0] = modint(1);\n  for (int i : range(mx)) {\n    fact[i+1] = fact[i] * modint(i+1);\n  }\n  factinv[mx] = modint(inv(static_cast<int>(fact[mx]), mod));\n  for (int i = mx; i > 0; --i) {\n    factinv[i-1] = factinv[i] * modint(i);\n  }\n  modint tmp = comb(3*m+n-1, n-1);\n  modint sub(0);\n  for (int i = 2*m+1; i <= 3*m; ++i) {\n    sub += comb(3*m-i+n-2, n-2);\n  }\n  sub *= modint(n);\n  modint mno(0);\n  for (int i = m+1; i <= n; ++i) {\n    ll rem = 3*m-i;\n    if (rem < 0 || (rem%2) == 1) continue;\n    mno += comb(rem/2+n-1, n-1) * comb(n, i);\n  }\n  modint res = tmp - sub - mno;\n  cout << static_cast<int>(res) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 2e6+7, M = 998244353;\nLL fac[N], invfac[N];\n\nLL power(LL a, LL p) {\n    if (p==0)   return 1;\n    LL ans = power(a, p/2);\n    ans = (ans*ans)%M;\n    if (p%2)    ans = (ans * a)%M;\n    return ans;\n}\n\nvoid pre() {\n    fac[0] = 1;\n    for (int i=1; i<N; i++)\n        fac[i] = (fac[i-1]*i)%M;\n\n    invfac[N-1] = power(fac[N-1], M-2);\n    for (int i=N-2; i>=0; i--)\n        invfac[i] = (invfac[i+1] * (i+1))%M;\n}\n\nLL C(int n, int k) {\n    if (k<0 || k>n) return 0;\n    LL denom = (invfac[k]*invfac[n-k])%M;\n    return (fac[n]*denom)%M;\n}\n\nint main() {\n    pre();\n    int n, m;\n    cin>>n>>m;\n\n    LL ans = 0;\n    for (int i=0; i<=n && i<=m; i++) {\n        LL choose = C(n, i);\n        LL rem = 3*m - i;\n        if (rem%2)  continue;\n        rem/=2;\n\n        LL ways = C(rem+n-1,n-1);\n        LL bad = ((n-i)*C(rem-m-1+n-1,n-1) + i*C(rem-m+n-1, n-1))%M;\n\n//        cout<<i<<\" \"<<ways<<\" \"<<bad<<endl;\n        ways = (ways-bad+M)%M;\n\n//        cout<<i<<\" \"<<ways<<endl;\n        ans = (ans + ways*choose)%M;\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\nconstexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int ret = 1;\n\tlong long int by = x;\n\twhile (n) {\n\t\tif (n & 1) {\n\t\t\tret *= by;\n\t\t\tret %= M;\n\t\t}\n\t\tby *= by;\n\t\tby %= M;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tvector<long long int>by(N * 3 + M * 3 + 1, 1);\n\tvector<long long int>rev(N * 3 + M * 3 + 1, 1);\n\tfor (int i = 1; i <= (N + M) * 3; i++) {\n\t\tby[i] = by[i - 1] * i;\n\t\tby[i] %= MOD;\n\t\trev[i] = power(by[i], MOD - 2, MOD);\n\t}\n\tlong long int ans = by[M * 3 + N - 1];\n\tans *= rev[N - 1];\n\tans %= MOD;\n\tans *= rev[M * 3];\n\tans %= MOD;\n\tfor (int i = M * 3; i > M * 2; i--) {\n\t\tlong long int minus = N;\n\t\tminus *= by[M * 3 - i+N-2];\n\t\tminus %= MOD;\n\t\tminus *= rev[N - 2];\n\t\tminus %= MOD;\n\t\tminus *= rev[M * 3 - i];\n\t\tminus %= MOD;\n\t\tans += MOD - minus;\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define PII pair<int, int>\n#define PLL pair<LL, LL>\n#define VI vector<int>\n#define VPII vector<PII>\n#define LL long long\n#define LD long double\n#define f first\n#define s second\n#define MP make_pair\n#define PB push_back\n#define pb pop_back\n#define ALL(c) (c).begin(), (c).end()\n#define SIZ(c) (int)(c).size()\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i, b, e) for(int i = (b); i <= (int)(e); ++i)\n#define FORD(i, b, e) for(int i = (b); i >= (int)(e); --i)\n\n#define Sim template<class n\nSim, class s> ostream & operator << (ostream &p, pair<n, s> x)\n{return p << \"<\" << x.f << \", \" << x.s << \">\";}\nSim> auto operator << (ostream &p, n y) -> \ntypename enable_if<!is_same<n, string>::value, decltype(y.begin(), p)>::type \n{int o = 0; p << \"{\"; for(auto c: y) {if(o++) p << \", \"; p << c;} return p << \"}\";}\nvoid dor() {cerr << endl;}\nSim, class...s> void dor(n p, s...y) {cerr << p << \" \"; dor(y...);}\nSim, class s> void mini(n &p, s y) {if(p>y) p = y;}\nSim, class s> void maxi(n &p, s y) {if(p<y) p = y;}\n#ifdef DEB\n#define debug(...) dor(__FUNCTION__, \":\", __LINE__, \": \", __VA_ARGS__)\n#else\n#define debug(...)\n#endif \n\n#define int LL\n#define I(x) #x \" = \", (x), \" \"\n#define A(a, i) #a \"[\" #i \" = \", i, \"] = \", a[i], \" \"\nconst int M = 1024 * 1024 * 4;\nconst LL mod = 998244353;\n\nLL sil[M], odw[M];\nLL n, m;\n\nLL poww(LL x, LL e)\n{\n\tif (e == 0)\n\t{\n\t\treturn 1;\n\t}\n\tif (e % 2 == 0)\n\t{\n\t\treturn poww(x * x % mod, e / 2);\n\t}\n\treturn poww(x, e - 1) * x % mod;\n}\n\nLL newt(LL a, LL b)\n{\n\tLL r = sil[a] * odw[b] % mod;\n\treturn r * odw[a - b] % mod;\n}\n\nLL pakuj(LL a, LL b)\n{\n\tif (b < 0)\n\t{\n\t\treturn 0;\n\t}\n\treturn newt(a + b - 1, b);\n}\n\nmain()\n{\n\t//ios_base::sync_with_stdio(0);\n\t//cin.tie(NULL);\n\tsil[0] = 1;\n\todw[0] = 1;\n\tFOR(i, 1, M - 1)\n\t{\n\t\tsil[i] = sil[i - 1] * i % mod;\n\t\todw[i] = poww(sil[i], mod - 2);\n\t}\n\tscanf(\"%lld%lld\", &n, &m);\n\t\n\tLL res = 0;\n\t\n\tfor (int i = m; i >= 0; i -= 2)\n\t{\n\t\tif (i > n)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tLL jed = i;\n\t\tLL dwa = m + (m - i) / 2;\n\t\tLL ilejed = newt(n, jed);\n\t\tLL iledwa = pakuj(n, dwa) - jed * pakuj(n, dwa - m) - (n - jed) * pakuj(n, dwa - m - 1);\n\t\tiledwa %= mod;\n\t\tiledwa = (iledwa + mod) % mod;\n\t\t\n\t\t//debug(i, jed, dwa, ilejed, iledwa);\n\t\tres = (res + ilejed * iledwa) % mod;\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\t\n\t/*LL all = pakuj(n, 3 * m) - (n * pakuj(n, m - 1)) % mod;\n\tif (all < 0)\n\t{\n\t\tall += mod;\n\t}\n\tLL bad = 0;\n\t\n\tFOR(i, 2 * m + 1, min(n, 3 * m))\n\t{\n\t\tLL tmp = newt(n, i) * pakuj(i, 3 * m - i);\n\t\tbad = (bad + tmp) % mod;\n\t}\n\tdebug(all, bad);\n\t\n\tLL bad2 = 0;\n\tFOR(i, m + 1, min(2 * m, n))\n\t{\n\t\t\n\t}\n\t\n\tprintf(\"%lld\\n\", (all - bad - bad2 + 2 * mod) % mod);*/\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 1000111, mod = 998244353;\n\nint mul(int x, int y) {\n    return (1LL * x * y) % mod;\n}\n\nint power(int a, int b) {\n    if (b == 0) {\n        return 1 % mod;\n    }\n    if (b % 2 == 0) {\n        return power(mul(a, a), b / 2);\n    }\n    return mul(a, power(a, b - 1));\n}\n\nint inv(int x) {\n    return power(x, mod - 2);\n}\n\nconst int max_f = 2000222;\n\nint f[max_f], rf[max_f];\n\nvoid get_all_f() {\n    f[0] = rf[0] = 1;\n    for (int i = 1; i < max_f; ++i) {\n        f[i] = mul(i, f[i - 1]);\n    }\n    rf[max_f - 1] = inv(f[max_f - 1]);\n    for (int i = max_f - 2; i > 0; --i) {\n        rf[i] = mul(i + 1, rf[i + 1]);\n    }\n}\n\nint get_c(int n, int k) {\n    if (n < k) {\n        return 0;\n    }\n    return mul(f[n], mul(rf[k], rf[n - k]));\n}\n\nint n, m;\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    get_all_f();\n    cin >> n >> m;\n    int ans = 0;\n    int in = inv(n - 1);\n    for (int cnt = 0; cnt <= min(m, n); ++cnt) {\n        if ((m - cnt) % 2) {\n            continue;\n        }\n        int x = m + (m - cnt) / 2;\n        int add = mul(get_c(n, cnt), get_c(x + n - 1, n - 1));\n        //cout << cnt << \": \" << add << endl;\n        ans += add;\n        ans %= mod;\n\n        int sum = 0;\n        /*for (int bad = m + 1; bad <= x; ++bad) {\n            sum += get_c(x - bad + n - 2, n - 2);\n            sum %= mod;\n        }*/\n        if (m + 1 <= x) {\n            sum = mul(n + x - 2 - m, f[n + x - m - 3]);\n            sum = mul(sum, in);\n            sum = mul(sum, rf[n - 2]);\n            sum = mul(sum, rf[x - m - 1]);\n        }\n\n        int del = mul(cnt, get_c(x - m + n - 2, n - 2));\n        del += mul(n, sum);\n        del %= mod;\n        del = mul(del, get_c(n, cnt));\n        ans += mod - del;\n        ans %= mod;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nclass ModComb {\n    long long *fact, *facti;\n    const int mod;\npublic:\n    explicit ModComb(int n, int m) : mod(m) {\n        fact = new long long[n+1];\n        facti = new long long[n+1];\n        fact[0] = 1; facti[0] = 1;\n        for (int i = 1; i <= n; i++) fact[i] = (fact[i-1] * i) % m;\n        // calc 1/n!\n        long long &inv = facti[n], pw = fact[n];\n        inv = 1;\n        for (int e = mod-2; e > 0; e /= 2) {\n            if (e&1) inv = inv * pw % mod;\n            pw = pw * pw % mod;\n        }\n        for (int i = n-1; i > 0; i--) facti[i] = (facti[i+1] * (i+1)) % m;\n    }\n\n    ~ModComb() {\n        if (fact) delete[] fact;\n        if (facti) delete[] facti;\n    }\n\n    long long get(int n, int k) const {\n        if (n < 0 || k < 0 || k > n) return 0;\n        return fact[n] * facti[k] % mod * facti[n-k] % mod;\n    }\n};\n\nint main() {\n    int n, m; cin >> n >> m;\n    const int M = 998244353;\n    ModComb mc(3*m+n+3, M);\n\n    long long ans = mc.get(n+3*m-1, n-1);\n    for (int j = 0; j < m; j++) ans -= mc.get(n+j-2, n-2) * n % M;\n    for (int l = m+1; l <= min(3*m, n); l++) {\n        long long t = mc.get(n+3*m-l-1, n-l-1);\n        ans -= (mc.get(l-1, m) * mc.get(n, l) % M\n                * t * ((m+l) % 2 ? 1 : -1)) % M;\n    }\n    cout << (ans % M + M) % M << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <utility>\n#include <vector>\n\n// modint構造体\ntemplate <int modulus> struct mod_Int{\n    int val; // 値本体\n    // コンストラクタ\n    constexpr mod_Int():val(0){}\n    constexpr mod_Int(const int& v):val(v % modulus){ if(val < 0) val += modulus; }\n    constexpr mod_Int(int&& v):val(v % modulus){ if(val < 0) val += modulus; }\n    constexpr mod_Int(const long long int& v):val(v % modulus){ if(val < 0) val += modulus; }\n    constexpr mod_Int(long long int&& v):val(v % modulus){ if(val < 0) val += modulus; }\n    constexpr mod_Int(const unsigned int& v):val(v % modulus){}\n    constexpr mod_Int(unsigned int&& v):val(v % modulus){}\n    constexpr mod_Int(const unsigned long long int& v):val(v % modulus){}\n    constexpr mod_Int(unsigned long long int&& v):val(v % modulus){}\n    constexpr mod_Int& operator += (const mod_Int<modulus>& other) noexcept {\n        val += other.val; if(val >= modulus) val -= modulus;\n        return *this;\n    }\n    constexpr mod_Int& operator -= (const mod_Int<modulus>& other) noexcept {\n        val -= other.val; if(val < 0) val += modulus;\n        return *this;\n    }\n    constexpr mod_Int& operator *= (const mod_Int<modulus>& other) noexcept {\n        val = static_cast<long long int>(val) * other.val % modulus;\n        return *this; \n    }\n    constexpr mod_Int& operator /= (const mod_Int<modulus>& other) noexcept {\n        val = static_cast<long long int>(val) * other.inverse() % modulus;\n        return *this;\n    }\n    constexpr bool operator == (const mod_Int<modulus>& other) const noexcept {\n        return val == other.val;\n    }\n    constexpr mod_Int operator +(const mod_Int<modulus>& v) const noexcept{\n        return mod_Int<modulus>(*this) += v;\n    }\n    constexpr mod_Int operator -(const mod_Int<modulus>& v)const noexcept{\n        return mod_Int<modulus>(*this) -= v;\n    }\n    constexpr mod_Int operator *(const mod_Int<modulus>& v) const noexcept{\n        return mod_Int<modulus>(*this) *= v;\n    }\n    constexpr mod_Int operator /(const mod_Int<modulus>& v) const noexcept{\n        return mod_Int<modulus>(*this) /= v;\n    }\n    constexpr mod_Int& operator ++(void) noexcept {\n        if(++val == modulus) val = 0;\n        return *this;\n    }\n    constexpr mod_Int& operator --(void) noexcept {\n        if(val-- == 0) val = modulus - 1;\n        return *this;\n    }\n    constexpr mod_Int operator -()const noexcept{\n        return mod_Int<modulus>((val == 0 ? 0 : modulus - val));\n    }\n\n    // aの逆元を求める関数\n    static constexpr int inverse(int a) noexcept {\n        int b = modulus, \n            u = 1, v = 0;\n        while (b != 0) {\n            const int t = a / b; \n            a -= t * b; std::swap(a, b);\n            u -= t * v; std::swap(u, v);\n        }\n        if(u < 0) u += modulus;\n        return u;\n    }\n    constexpr int inverse(void) const noexcept { return inverse(val); }\n    // a^nを返す関数 : nは負の数でも可\n    static constexpr int power(long long int a, long long int n){\n        long long res = 1, waiting = a;\n        if(n < 0) waiting = inverse(), n = -n;\n        while(n != 0){ \n            if(n % 2 != 0) res = res * waiting % modulus; \n            waiting = waiting * waiting % modulus; \n            n /= 2;\n        }\n        return res;\n    }\n    constexpr mod_Int power(long long int n) const noexcept { mod_Int res; res.val = power(val, n); return res; }\n};\n\ntemplate <int modulus>\nstruct Combination{\n    const int sz;\n    std::vector<mod_Int<modulus>> Power, Inv_Power, Inv;\n    \n    // コンストラクタ : n は想定される最大値\n    Combination(const int n):sz(n){\n        Power.resize(n + 1); Power[0].val = 1;\n        mod_Int<modulus> v = 1; for(int i = 1; i <= n; ++i, ++v) Power[i] = Power[i - 1] * v;\n        Inv_Power.resize(n + 1); Inv_Power[n] = Power[n].inverse();\n        v = n; for(int i = n; i > 0; --i, --v) Inv_Power[i - 1] = Inv_Power[i] * v;\n        Inv.resize(n + 1);\n        Inv[0] = 0; for(int i = 1; i <= n; ++i) Inv[i] = Inv_Power[i] * Power[i - 1];\n    }\n    \n    // 組み合わせ nCk を求める関数\n    mod_Int<modulus> combination(const int n, const int k) const {\n        if(k < 0 or n < k) return mod_Int<modulus>();\n        return Power[n] * Inv_Power[k] * Inv_Power[n - k];\n    }\n};\n\nconstexpr int mod = 998244353;\nusing modint = mod_Int<mod>;\n\nint main(void){\n    std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); \n    std::cout << std::fixed << std::setprecision(16);\n\n    int n, m; std::cin >> n >> m;\n    Combination<mod> Cmb(n + 3 * m);\n    \n    modint res = 0, even = 0, odd_count ;\n    for(int odd = (m & 1), rest = (3 * m) / 2; odd <= m; odd += 2, --rest){\n        modint cnt = 0;\n        cnt += Cmb.combination(rest + n - 1, n - 1);\n        cnt -= modint(odd) * Cmb.combination(rest - m + n - 2, n - 2);\n        cnt -= modint(n) * Cmb.combination(rest - (m + 1) + n - 1, n - 1);\n        res += cnt * Cmb.combination(n, odd);\n    }\n    std::cout << res.val << '\\n';\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 262144\n#define REP(a,b) for(long long a = 0;a < b;++a)\nvector<complex<double>>  DFT(vector<complex<double>> a) {\n\tint n = a.size();\n\tif (n == 1) return a;\n\tvector<complex<double>> a0(n / 2), a1(n / 2);\n\tREP(i, n) {\n\t\tif (i % 2 == 0) {\n\t\t\ta0[i / 2] = a[i];\n\t\t}\n\t\telse {\n\t\t\ta1[i / 2] = a[i];\n\t\t}\n\t}\n\tvector<complex<double>> inversed_a0 = DFT(a0), inversed_a1 = DFT(a1);\n\tvector<complex<double>> inversed_a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcomplex<double> zeta = complex<double>(cos(2 * Ma_PI * i / n), sin(2 * Ma_PI * i / n));\n\t\tinversed_a[i] = inversed_a0[i % (n / 2)] + zeta * inversed_a1[i % (n / 2)];\n\t}\n\treturn inversed_a;\n}\nvector<complex<double>> IDFT(vector<complex<double>> inversed_a) {\n\tint n = inversed_a.size();\n\tvector<complex<double>> now = DFT(inversed_a);\n\treverse(now.begin(), now.end());\n\tfor (int q = now.size() - 1; q >= 1; --q) {\n\t\tswap(now[q], now[q - 1]);\n\t}\n\tREP(i, n) {\n\t\tnow[i] /= complex<double>(n, 0);\n\t}\n\treturn now;\n}\nvector<complex<double>> conv(vector<complex<double>> a, vector<complex<double>> b) {\n\tint deg = a.size() + b.size() - 1;\n\tint n = 1;\n\twhile (n < deg) n <<= 1;\n\ta.resize(n);\n\tb.resize(n);\n\tvector<complex<double>> inversed_a = DFT(a),inversed_b = DFT(b);\n\tvector<complex<double>> inversed_c(n);\n\tREP(i, n) {\n\t\tinversed_c[i] = inversed_a[i] * inversed_b[i];\n\t}\n\treturn IDFT(inversed_c);\n}\nlong long inv(long long now) {\n\tlong long hoge = MOD - 2LL;\n\tlong long ans = 1;\n\twhile (hoge != 0) {\n\t\tif (hoge % 2 == 1) {\n\t\t\tans *= now;\n\t\t\tans %= MOD;\n\t\t}\n\t\thoge /= 2;\n\t\tnow *= now;\n\t\tnow %= MOD;\n\t}\n\treturn ans;\n}\nlong long jun[2100000] = {};\nlong long gyaku[2100000] = {};\nlong long combination(long long a, long long b) {\n\tlong long ans = jun[a];\n\tans *= gyaku[a - b];\n\tans %= MOD;\n\tans *= gyaku[b];\n\tans %= MOD;\n\treturn ans;\n}\nlong long no_limit(long long a, long long b) {\n\treturn combination(a + b - 1, a);\n}\n\nint main() {\n#define int long long\n\tjun[0] = 1;\n\tgyaku[0] = 1;\n\tfor (long long i = 1; i < 2100000; ++i) {\n\t\tjun[i] = jun[i - 1] * i;\n\t\tjun[i] %= MOD;\n\t\tgyaku[i] = inv(jun[i]);\n\t}\n\tlong long n, m;\n\tcin >> n >> m;\n\tlong long ans = 0;\n\tlong long tmp = 0;\n\tfor (long long odd = m;; ++odd) {\n\t\tlong long even = m - (odd - m) * 2LL;\n\t\tif (even < 0) break;\n\t\tif (even > n) continue;\n\t\tlong long geko = no_limit(odd, n);\n\t\ttmp -= (n * no_limit(odd - m, n - 1)) % MOD;\n\t\ttmp += 2LL * MOD;\n\t\ttmp %= MOD;\n\t\tgeko += tmp;\n\t\tgeko += MOD;\n\t\tgeko %= MOD;\n\t\tans += geko * combination(n, even);\n\t\tans %= MOD;\n\t\tif (n - 1 >= even) {\n\t\t\tans += ((n * no_limit(odd - m, n - 1)) % MOD * combination(n - 1, even)) % MOD;\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define p_ary(ary,a,b,i) do { cout << \"[\"; for (int (i) = (a);(i) < (b);++(i)) cout << ary[(i)] << ((b)-1 == (i) ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\n// const ll mod = 1000000007;\nconst ll mod = 998244353;\n\nconst int MAX_N = 1100020;\nll fact[MAX_N],fact_inv[MAX_N],inv[MAX_N];\n\nll pow_mod(ll a,ll b) {\n    ll ret;\n    if (b < 0) ret = pow_mod(a,mod+b-1);\n    else if (b == 0) ret = 1;\n    else if (b == 1) ret = a;\n    else {\n        ll c = pow_mod(a,b/2);\n        if (b%2) ret = (c*c)%mod*a%mod;\n        else ret = c*c%mod;\n    }\n    return ret;\n}\n\nvoid create_table(int n) {\n    fact[0] = 1;fact[1] = 1;\n    for (int i = 2;i <= n;++i) fact[i] = fact[i-1]*i%mod;\n    fact_inv[n] = pow_mod(fact[n],-1);\n    for (int i = n;i > 0;--i) fact_inv[i-1] = fact_inv[i]*i%mod;\n    for (int i = 1;i <= n;++i) inv[i] = fact_inv[i]*fact[i-1]%mod;\n}\n\nll combi(ll a, ll b) {\n    return fact[a]*fact_inv[b]%mod*fact_inv[a-b]%mod;\n}\n\nint main() {\n    int n,m;\n    cin >> n >> m;\n    create_table(1100010);\n    ll ans = combi(n+3*m-1,3*m);\n    for (int i = 0;i < m;++i) {\n        (ans -= n*combi(n-1+i-1,i)) %= mod;\n    }\n    for (int i = m+1;i <= min(n,3*m);++i) if ((3*m-i)%2 == 0) {\n        (ans -= combi(n,i)*combi(n+(3*m-i)/2-1,(3*m-i)/2)) %= mod;\n    }\n    cout << (ans+mod)%mod << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int p=998244353;\nconst int N=3000000;\n\nint fac[5000000],inv[5000000];\nint i,m,n,s;\n\ninline int power(int x,int y)\n{\n\tint s=1;\n\tfor (int i=30;i>=0;i--)\n\t{\n\t\ts=1LL*s*s%p;\n\t\tif ((1<<i)&y)\n\t\t\ts=1LL*s*x%p;\n\t}\n\treturn s;\n}\n\ninline void pre_C()\n{\n\tfac[0]=1;\n\tfor (int i=1;i<=N;i++)\n\t\tfac[i]=1LL*fac[i-1]*i%p;\n\tinv[N]=power(fac[N],p-2);\n\tfor (int i=N-1;i>=0;i--)\n\t\tinv[i]=1LL*inv[i+1]*(i+1)%p;\n\treturn;\n}\n\ninline int C(int x,int y)\n{\n\tif ((y<0) || (y>x))\n\t\treturn 0;\n\telse\n\t\treturn 1LL*fac[x]*inv[y]%p*inv[x-y]%p;\n}\n\nint main()\n{\n\tpre_C();\n\tscanf(\"%d%d\",&n,&m);\n\tfor (i=m;i<=m+m/2;i++)\n\t\ts=(s+1LL*C(i+n-1,n-1)*C(n,3*m-2*i))%p;\n\tfor (i=m+1;i<=m+m/2;i++)\n\t\ts=(s-1LL*C(i-m+n-2,n-1)*C(n,3*m-2*i)%p*n%p+p)%p;\n\tfor (i=m;i<=m+m/2;i++)\n\t\ts=(s-1LL*C(i-m+n-2,n-2)*C(n-1,3*m-2*i-1)%p*n%p+p)%p;\n\tprintf(\"%d\",s);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cstdio>\n#include <iomanip>\n#include <cmath>\n#include <bitset>\n\nusing namespace std;\n\nint n, m;\nconst int MOD = 998244353;\nlong long ans = 0;\nlong long fact[2100000];\nlong long ufact[2100000];\n\nlong long inq(long long a, long long b)\n{\n    if (b == 0) return 1;\n    long long l = inq(a, b / 2);\n    if (b % 2) return l * l % MOD * a % MOD;\n    return l * l % MOD;\n}\n\nlong long cnk(long long n, long long k)\n{\n    return fact[n] * ufact[k] % MOD * ufact[n - k] % MOD;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tfact[0] = 1, ufact[0] = 1;\n\tcin >> n >> m;\n\tif (n > m)\n    {\n        return 1;\n    }\n\tfor (int i = 1; i <= 3 * m + n; i++) fact[i] = fact[i - 1] * i % MOD, ufact[i] = inq(fact[i], MOD - 2);\n\tans = cnk(3 * m + n - 1, n - 1);\n\tans = (ans + MOD - n) % MOD;\n\tn--;\n\tfor (int bad_len = 2 * m + 1; bad_len < 3 * m; bad_len++)\n    {\n        int cnt_pos = 3 * m - bad_len - 1;\n        ans = (ans + MOD - cnt_pos * cnk(3 * m - bad_len + 1 + n - 2, n - 2) % MOD) % MOD;\n        ans = (ans + MOD - 2 * cnk(3 * m - bad_len + 1 + n - 1, n - 1) % MOD) % MOD;\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\nll mod=998244353;\n\nll fac[3000010];\n \nll modinv(ll a){\n    ll b=mod,u=1,v=0;\n    while(b){\n        ll t=a/b;\n        a-=t*b; swap(a,b);\n        u-=t*v; swap(u,v);\n        }\n        u%=mod;\n        if(u<0) u+=mod;\n    return u;\n}\n \nvoid modfac(){\n    fac[0]=1;\n    for(ll i=1;i<3000010;i++){\n        fac[i]=(fac[i-1]*i)%mod;\n    }\n}\n \nll modperm(ll n,ll k){\n    if(n<0||k<0||n<k) return 0;\n    else return (fac[n]*modinv(fac[n-k]))%mod;\n}\n \nll modcomb(ll n,ll k){\n    if(n<0||k<0||n<k) return 0;\n    else return ((fac[n]*modinv(fac[k]))%mod*modinv(fac[n-k]))%mod;\n}\n \nll modpow(ll a,ll b){\n  ll ans=1;\n  a%=mod;\n  while(b){\n    if(b&1) ans=ans*a%mod;\n    a=a*a%mod;\n    b>>=1;\n  }\n  return ans;\n}\n\nll dp[1000000];\n\nint main(){\n  modfac();\n  ll n,m;\n  cin >> n >> m;\n  ll ans=modcomb(n+3*m-1,3*m);\n  for(ll i=0;i<m;i++){\n    ans=(ans-n*modcomb(n+i-2,i)%mod+mod)%mod;\n  }\n  for(ll i=m+1;i<=n;i++){\n    ll x=i-m;\n    if(x%2==0){\n      x=(x+1)*x/2;\n      ans=(ans+mod-x*modcomb(n+1,n-i)%mod*modcomb(2*i+1-2*x,i-x+1)%mod)%mod;\n    }\n    else{\n      x=(x+1)*x/2;\n      ans=(ans+x*modcomb(n+1,n-i)%mod*modcomb(2*i+1-2*x,i-x+1)%mod)%mod;\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#define ll long long\n#define inf 20021225\n#define mdn 998244353\n#define N 3000001\nusing namespace std;\nint read()\n{\n\tint s=0,f=1; char ch=getchar();\n\twhile(ch<'0' || ch>'9')\t{if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn f*s;\n}\nint fac[N],inv[N];\nvoid upd(int &x,int y){x+=x+y>=mdn?y-mdn:y;}\nint ksm(int bs,int mi)\n{\n\tint ans=1;\n\twhile(mi)\n\t{\n\t\tif(mi&1)\tans=1ll*ans*bs%mdn;\n\t\tbs=1ll*bs*bs%mdn; mi>>=1;\n\t}\n\treturn ans;\n}\nvoid init(int n)\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)\tfac[i]=1ll*fac[i-1]*i%mdn;\n\tinv[n]=ksm(fac[n],mdn-2);\n\tfor(int i=n;i;i--)\t\tinv[i-1]=1ll*inv[i]*i%mdn;\n}\nint C(int n,int m)\n{\n\tif(n<m)\treturn 0;\n\treturn 1ll*fac[n]*inv[n-m]%mdn*inv[m]%mdn;\n}\nint F(int n,int m,int k)\n{\n\tint top=min(n,k),ans=0;\n\tfor(int i=0;i<=top;i++)\tif(!((m-i)&1) && m>=i)\n\t\tupd(ans,1ll*C(n,i)*C(n-1+(m-i)/2,n-1)%mdn);\n\treturn ans;\n}\nint main()\n{\n\tint n=read(),m=read(); init(n+3*m);\n\tint ans=F(n,m*3,m)-1ll*(F(n,m,m)-F(n-1,m,m)+mdn)%mdn*n%mdn;\n\tprintf(\"%d\\n\",(ans+mdn)%mdn);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Tp template<typename Ty>\n#define Ts template<typename Ty,typename... Ar>\n#define Reg register\n#define RI Reg int\n#define Con const\n#define CI Con int&\n#define I inline\n#define W while\n#define N 1000000\n#define SZ 3000000\n#define X 998244353\n#define Qinv(x) Qpow(x,X-2)\n#define Inc(x,y) ((x+=(y))>=X&&(x-=X))\n#define C(x,y) (1LL*Fac[x]*IFac[y]%X*IFac[(x)-(y)]%X)\n#define S(x,y) C((x)+(y)-1,(y)-1)\nusing namespace std;\nint n,m,Fac[SZ+5],IFac[SZ+5];\nI int Qpow(RI x,RI y) {RI t=1;W(y) y&1&&(t=1LL*t*x%X),x=1LL*x*x%X,y>>=1;return t;}\nint main()\n{\n\tRI i,ans=0;for(scanf(\"%d%d\",&n,&m),Fac[0]=i=1;i<=SZ;++i) Fac[i]=1LL*Fac[i-1]*i%X;\n\tfor(IFac[SZ]=Qinv(Fac[SZ]),i=SZ-1;~i;--i) IFac[i]=1LL*IFac[i+1]*(i+1)%X;\n\tfor(i=m&1;i<=m;i+=2) ans=(1LL*C(n,i)*S(3*m-i>>1,n)+ans)%X;\n\tfor(i=2*m+1;i<=3*m;++i) ans=(X-1LL*n*S(3*m-i,n-1)+ans)%X;\n\treturn printf(\"%d\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 4000200, mod = 998244353;\nint mul(long long a, long long b){\n\treturn a * b % mod;\n}\nint xp(long long a, long long b){\n\tint r = 1;\n\tfor(; b; b >>= 1, a = mul(a, a)) if(b&1) r = mul(r, a);\n\treturn r;\n}\nint fat[maxn], ifat[maxn];\nvoid init(){\n\tfat[0] = 1;\n\tfor(int i = 1; i < maxn; i++) fat[i] = mul(i, fat[i - 1]);\n\tifat[maxn - 1] = xp(fat[maxn - 1], mod - 2);\n\tfor(int i = maxn - 2; i >= 0; i--) ifat[i] = mul(i + 1, ifat[i + 1]);\n\tfor(int i = 0; i < maxn; i++) assert(mul(fat[i], ifat[i]) == 1);\n}\nint ncr(int n, int r){\n\tif(r > n) return 0;\n\treturn mul(fat[n], mul(ifat[r], ifat[n - r]));\n}\nint distribution(int n, int m, int lim, int r2){\n\tint ans = 0;\n\tfor(int i = r2; i <= min(n, lim); i += 2){\n\t\tint miss = (m - i) / 2;\n\t\tans += mul(ncr(n, i), ncr(n + miss - 1, miss));\n\t\tif(ans >= mod)\n\t\t\tans -= mod;\n\t}\n\treturn ans;\n}\nint main(){\n\tinit();\n\tint n, m; cin >> n >> m;\n\tint res = distribution(n, 3 * m, m, m % 2);\n\tres += mod - mul(n, distribution(n, m, m, m % 2));\n\tif(res >= mod)\n\t\tres -= mod;\n\tres += mul(n, distribution(n - 1, m, m, m % 2));\n\tif(res >= mod)\n\t\tres -= mod;\n\tcout << res << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001;\nconst int INF=1001001001;\nconst int mod=998244353;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\nvi fac,finv,inv;\nvoid init(ll n) {\n    fac=vi(n+5);finv=vi(n+5);inv=vi(n+5);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    REP(i,2,n+5){\n        fac[i]=fac[i-1]*i%mod;\n        inv[i]=mod-inv[mod%i]*(mod/i)%mod;\n        finv[i]=finv[i-1]*inv[i]%mod;\n    }\n}\nlong long modcom(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % mod) % mod;\n}\nint main(){\n    ll n,m;cin>>n>>m;\n    init(3*m/2+n);\n    ll ans=0;\n    for(ll k=m%2;k<=n&&k<=m;k+=2){\n        ll s=(3*m-k)/2;\n        ll res=modcom(s+n-1,n-1);\n        res+=mod-n*modcom(s-m+n-1,n-1)%mod;\n        res+=(n-k)*modcom(s-m+n-2,n-2)%mod;\n        ans+=res%mod*modcom(n,k)%mod;\n        ans%=mod;\n    }\n    out(ans);\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nlong long inv(int a, int p) { return a==1 ? 1 : (1-p*inv(p%a,a))/a+p; }\nstatic const int MODVAL = 998244353;\nstruct mint {\n  int val;\n  mint():val(0){}\n  mint(int x):val(x%MODVAL) {}\n  mint(size_t x):val(x%MODVAL) {}\n  mint(long long x):val(x%MODVAL) {}\n  mint& operator+=(mint y) { val+=y.val; if(val>=MODVAL) val-=MODVAL; return *this; }\n  mint& operator-=(mint y) { val-=y.val; if(val<0) val+= MODVAL; return *this; }\n  mint& operator*=(mint y) { val=(val*(long long)y.val)%MODVAL; return *this; }\n  mint& operator/=(mint y) { val=(val*inv(y.val,MODVAL))%MODVAL; return *this; }\n};\ninline mint operator+(mint x, mint y) { return x+=y; }\ninline mint operator-(mint x, mint y) { return x-=y; }\ninline mint operator*(mint x, mint y) { return x*=y; }\ninline mint operator/(mint x, mint y) { return x/=y; }\nmint POW(mint x, long long n) { mint r(1); for(;n;x*=x,n>>=1) if(n&1) r*=x; return r; }\nmint FAC(int n) { static vector<mint> FAC_(1,1);\n  while(int(FAC_.size())<=n) FAC_.push_back(FAC_.back()*FAC_.size()); return FAC_[n]; }\ninline mint CMB(int n, int k) { return k<0||n<k ? 0 : FAC(n) / (FAC(k) * FAC(n-k)); }\ninline ostream& operator<<(ostream& os, mint a) { return os << a.val; }\n\nmint dp[1000000+10];\n\n// n箇所にm個を配るが、k個より大きいところを作ってはならない\nmint solve(int n, int m, int k) {\n  if(n == 0) {\n    return m == 0 ? 1 : 0;\n  }\n  mint res = CMB(m+n-1, n-1);\n  for(int x = k+1; x <= m; ++x) {\n    res -= CMB(m-x + n-2, n-2) * n;\n  }\n  return res;\n}\n\nint main(void) {\n  int n, m;\n  cin >> n >> m;\n  mint res = solve(n, 3*m, 2*m);\n  int last = min(n, 3*m);\n  for(int x = last; x > m; --x) { // 1の箇所が多すぎるパターン\n    // cerr << \">\" << res << endl;\n    mint &cur = dp[x];\n    cur = CMB(n, x) * solve(n-x, 3*m-x, 2*m);\n    for(int i = x+1; i <= last; ++i) { // ここを高速化しないと通らん...\n      cur -= dp[i] * CMB(i, x);\n    }\n    res -= cur;\n  }\n  cout << res << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef long long int ll;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define SP << \" \" <<\n\nconst LL MAX = 2010000;\nconst LL MOD = 998244353;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (LL i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nlong long COM(LL n, LL k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nLL mod = 998244353;\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  LL N, M;\n  cin >> N >> M;\n  \n  //3M回 +1\n  //N要素で2M+1以上のがあったらダメ\n  //N-1要素で(M-1回以内+1)の個数*N\n  //単にN要素でM-1回+1\n  \n  //ある要素が2M-1\n  //残りがM+1回のどこかで+2がされる\n  //逆に、+1しかない場合を除け\n\n  //+2 がM回存在しないものを除く\n  //i=0~M-1\n  //N個から適当にi回+2\n  //N個から3M-2*i要素を+1\n\n  COMinit();\n\n  LL ans = COM(3 * M + N - 1, 3 * M) - COM(M - 1 + N - 1, M - 1) * N;\n  LL sum = 0;\n  FOR(i, 0, M)\n  {\n    //A=\n    sum += COM(i+N-1, N-1) * COM(N,3*M-2*i);\n    sum %= mod;\n  }\n  ans -= sum ;\n  ans = (ans%mod + mod) % mod;\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nconst int MAXN = 2000005;\nconst int mod = 998244353;\n\nint n, m;\nlint fact[MAXN], invf[MAXN];\n\nlint ipow(int x, int p){\n\tlint ret = 1, piv = x;\n\twhile(p){\n\t\tif(p & 1) ret = ret * piv % mod;\n\t\tpiv = piv * piv % mod;\n\t\tp >>= 1;\n\t}\n\treturn ret;\n}\n\nlint binom(int x, int y){\n\treturn fact[x] * (invf[y] * invf[x - y] % mod) % mod;\n}\n\nint f(int n, int odds, int sum){\n\tlint ret = 0;\n\tfor(int i=0; i<=odds && i <= sum && i <= n; i++){\n\t\tif(sum % 2 == i % 2){\n\t\t\tret += binom((sum - i) / 2 + n - 1, n - 1) * binom(n, i) % mod;\n\t\t}\n\t}\n\treturn ret % mod;\n}\n\nlint g(int n, int sum){\n\treturn binom(sum + n - 1, n - 1);\n}\n\nint main(){\n\tfact[0] = invf[0] = 1;\n\tfor(int i=1; i<MAXN; i++){\n\t\tfact[i] = fact[i-1] * i % mod;\n\t\tinvf[i] = ipow(fact[i], mod - 2);\n\t}\n\tcin >> n >> m;\n\tlint ret = f(n, m, 3 * m);\n\tfor(int i=2*m+1; i<=3*m; i++){\n\t\tret += mod - n * g(n - 1, 3 * m - i) % mod;\n\t}\n\tcout << ret % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long ans,n,m,mod=998244353ll,fact[5000005],invfact[5000005],tmp;\n\nlong long fastp(long long base,long long exp){\n    if(exp==0)return 1ll;\n    long long tmp2=fastp(base,exp/2ll);\n    tmp2=(tmp2*tmp2)%mod;\n    if(exp%2==1)tmp2*=base;\n    return tmp2%mod;\n}\n\nlong long binom(long long a,long long b){\n    if(b>a)return 0ll;\n\n    return ((fact[a]*invfact[b])%mod*invfact[a-b])%mod;\n}\n\nint main(){\n\n\tcin>>n>>m;\n\t\n\tfact[0]=1;\n\tfor(long long i=1;i<5000005;i++)fact[i]=(fact[i-1]*i)%mod;\n\tinvfact[5000004]=fastp(fact[5000004],mod-2ll);\n    for(long long i=5000003;i>=0;i--)invfact[i]=(invfact[i+1]*(i+1ll))%mod;\n\n\n    \n    ans=binom(n+3ll*m-1ll,n-1ll);\n    \n //cout<<ans<<endl;\n    \n    for(int i=0;i<m;i++){\n        ans-=(binom(n+i-1,i)*binom(n,m*3-2*i))%mod;\n        ans=(ans%mod+mod)%mod;\n    }\n    \n\n    for(int i=2*m+1;i<=(3*m);i++){\n        tmp+=binom(n-2+3*m-i,n-2);\n        tmp%=mod;\n    }\n//cout<<tmp<<endl;\n    \n    ans-=(n*tmp)%mod;\n    ans=(ans%mod+mod)%mod;\n    \n    cout<<ans<<endl;\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2\")\n#pragma GCC optimize (\"unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst ld eps=1e-7;\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod = 998244353;\nconst int MAXN = 4000100, LOG=20;\n\nll n, m, k, u, v, x, y, t, a, b, ans;\nll F[MAXN], I[MAXN];\n\nll powmod(ll a, ll b){\n\tif (!b) return 1;\n\tif (b&1) return a*powmod(a*a%mod, b>>1)%mod;\n\treturn powmod(a*a%mod, b>>1);\n}\n\nll C(ll n, ll r){\n\tif (r<0 || r>n) return 0;\n\treturn F[n]*I[r]%mod*I[n-r]%mod;\n}\n\nll f(ll n, ll m){\n\treturn C(m+n-1, n-1);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tF[0]=1;\n\tfor (int i=1; i<MAXN; i++) F[i]=F[i-1]*i%mod;\n\tI[MAXN-1]=powmod(F[MAXN-1], mod-2);\n\tfor (int i=MAXN-1; i; i--) I[i-1]=I[i]*i%mod;\n\t\n\tcin>>n>>m;\n\tfor (int i=(m&1); i<=min(n, m); i+=2){\n\t\tll tmp=f(n, (3*m-i)/2) - i*f(n, (m-i)/2) - (n-i)*f(n, (m-i)/2-1);\n\t\ttmp%=mod;\n\t\tans+=tmp*C(n, i)%mod;\n\t\t//debug2(i, tmp*C(n, i))\n\t}\n\tans%=mod;\n\tif (ans<0) ans+=mod;\n\tcout<<ans<<'\\n';\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint put(int a, int b)\n{\n\tint ans = 1;\n\twhile (b) {\n\t\tif (b & 1)\n\t\t\tans = 1LL * ans * a % MOD;\n\t\ta = 1LL * a * a % MOD;\n\t\tb /= 2;\n\t}\n\treturn ans;\n}\n\nconst int NMAX = 2e6;\nint fact[NMAX], invfact[NMAX];\n\nvoid precalc()\n{\n\tfact[0] = 1;\n\tfor (int i = 1; i < NMAX; i++)\n\t\tfact[i] = 1LL * i * fact[i - 1] % MOD;\n\tinvfact[NMAX - 1] = put(fact[NMAX - 1], MOD - 2);\n\tfor (int i = NMAX - 1; i >= 1; i--)\n\t\tinvfact[i - 1] = 1LL * invfact[i] * i % MOD;\n}\n\nint comb(int a, int b)\n{\n\tif (a < b || b < 0)\n\t\treturn 0;\n\treturn 1LL * fact[a] * invfact[b] % MOD * invfact[a - b] % MOD;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tprecalc();\n\n\tint N, M;\n\n\tcin >> N >> M;\n\n\tint ans = 0;\n\n\tfor (int nri = 0; nri <= min(N, M); nri++) {\n\t\t/// sunt nri impare\n\t\tint left = 3 * M - nri;\n\t\tif (left % 2 == 1)\n\t\t\tcontinue;\n\t\tleft /= 2;\n\t\tint modurii = comb(N, nri);\n\t\tint modurip = comb(N + left - 1, N - 1);\n\t\tans = (ans + 1LL * modurii * modurip) % MOD;\n\t}\n\n\tfor (int toomuch = 2 * M + 1; toomuch <= 3 * M; toomuch++) {\n\t\tint moduri = comb(N + 3 * M - toomuch - 2, N - 2);\n\t\tans = (ans - 1LL * moduri * N) % MOD;\n\t}\n\n\tif (ans < 0)\n\t\tans += MOD;\n\n\tcout << ans << '\\n';\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuThOr GaRyMr\n*/\n#include<bits/stdc++.h>\n#define rb(a,b,c) for(int a=b;a<=c;++a)\n#define rl(a,b,c) for(int a=b;a>=c;--a)\n#define LL long long\n#define IT iterator\n#define PB push_back\n#define II(a,b) make_pair(a,b)\n#define FIR first\n#define SEC second\n#define FREO freopen(\"check.out\",\"w\",stdout)\n#define rep(a,b) for(int a=0;a<b;++a)\n#define KEEP while(1)\n#define SRAND mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#define random(a) rng()%a\n#define ALL(a) a.begin(),a.end()\n#define POB pop_back\n#define ff fflush(stdout)\n#define fastio ios::sync_with_stdio(false)\n//#define int LL\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef pair<int,int> mp;\ntypedef pair<mp,mp> superpair;\nLL MOD=998244353;\nLL fact[2000000+21];\ninline LL update(LL A){\n\tif(A<MOD) return A;\n\tA%=MOD;\n\treturn A;\n}\ninline LL add(LL x,LL y)\n{\n    return x+y>=MOD?x+y-MOD:x+y;\n}\ninline void UP(LL & A){\n\tif(A>=MOD){\n\t\tA%=MOD;\n\t}\n}\ninline LL quick(LL A,LL B){\n\tif(!B) return 1ll;\n\tLL tmp=quick(A,B>>1);\n\ttmp*=tmp;\n\tUP(tmp);\n\tif(B&1){\n\t\ttmp*=A;\n\t\tUP(tmp);\n\t}\n\treturn tmp;\n}\ninline LL inv(LL A){\n\treturn  quick(A,MOD-2);\n}\ninline LL C(LL A,LL B){\n\tif(B>A){\n\t\treturn 0ll;\n\t}\n\tint rest=update(update(fact[A]*inv(fact[B]))*inv(fact[A-B]));\n\treturn rest;\n}\ninline LL AR(LL A,LL B){\n\t//把A个2分给B个数\n\treturn C(A+B-1,B-1); \n} \nint  main(){\n\tfastio;\n\tfact[0]=1;\n\trb(i,1,2000000)\n\t\tfact[i]=fact[i-1]*i,fact[i]%=MOD;\n//\tif()\n\tint n,m;\n\tcin>>n>>m;\n//\tif(n==1000000 &&m==500000){\n//\t\tcout<<650705070<<endl;\n//\t\treturn 0;\n//\t}\n\tint res=0;\n\tLL del=0;\n\tfor(register int two=m,one=m;one>=0;++two,--one,--one){\n\t\tif(two>=m+1){\n\t\t\tdel=add(del,update(n*(AR(two-(m+1),n-1))));\n\t\t}\n\t\tif(one>n) continue;\n\t\tres+=(update((AR(two,n)+MOD-del)*C(n,one)));\n\t\tif(one!=0){\n\t\t\tres-=update(update(n*AR(two-m,n-1))*C(n-1,one-1));\n\t\t}\n      \tif(res<0)\n\t\tres+=MOD;\n\t\tif(res>=MOD){\n\t\t\tres%=MOD;\n\t\t}\t\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n/*\n2 5\n6\n100 97\n20341054\n*/"
  },
  {
    "language": "C++",
    "code": "#define MAX_N 1000010\nll inv[MAX_N+10],fac[MAX_N+10],ifac[MAX_N+10];\n\nvoid setComb(){\n  inv[0]=1;inv[1]=1;fac[1]=1;ifac[1]=1;fac[0]=1;ifac[0]=1;\n  for(int i=2;i<MAX_N;i++){\n    inv[i]=(-MOD/i)*inv[MOD%i]%MOD;\n    fac[i]=fac[i-1]*i%MOD;\n    ifac[i]=ifac[i-1]*inv[i]%MOD;\n\n    inv[i]=(inv[i]+MOD)%MOD;\n    fac[i]=(fac[i]+MOD)%MOD;\n    ifac[i]=(ifac[i]+MOD)%MOD;\n  }\n  return;\n}\n\nll comb(ll n,ll k){\n  if(n<k||n<0||k<0) return 0;\n  else return ((fac[n]*ifac[k]%MOD*ifac[n-k]%MOD+MOD)%MOD);\n}\n\nll hcomb(ll n,ll r){\n  if(n==0&&r==0) return 1;\n  else if(n<0||r<0) return 0;\n  else return comb(n+r-1,r-1);\n}\n\nll mod_pow(ll x,ll n){\n  x%=MOD;\n  ll res=1;\n  while(n>0){\n    if(n&1) res=res*x%MOD;\n    x=x*x%MOD;\n    n>>=1;\n  }\n  return res;\n}\n\nvoid add(ll &a,ll b){\n  a=(a+b)%MOD;\n}\n\nvoid mul(ll &a,ll b){\n  a%=MOD;b%=MOD;\n  a=a*b%MOD;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n\ntypedef long long LL;\n\nconst int N=3000005;\nconst int MOD=998244353;\n\nint n,m,jc[N],ny[N];\n\nint C(int n,int m)\n{\n\tif (n<m) return 0;\n\telse return (LL)jc[n]*ny[m]%MOD*ny[n-m]%MOD;\n}\n\nLL solve(int x,int y)\n{\n\tint ans=0;\n\tfor (int i=0;i*m<=x;i++)\n\t\tif (i&1) (ans+=MOD-(LL)C(y,i)*C(x-i*m+y-1,y-1)%MOD)%=MOD;\n\t\telse (ans+=(LL)C(y,i)*C(x-i*m+y-1,y-1)%MOD)%=MOD;\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tjc[0]=jc[1]=ny[0]=ny[1]=1;\n\tfor (int i=2;i<=3000000;i++) jc[i]=(LL)jc[i-1]*i%MOD,ny[i]=(LL)(MOD-MOD/i)*ny[MOD%i]%MOD;\n\tfor (int i=2;i<=3000000;i++) ny[i]=(LL)ny[i]*ny[i-1]%MOD;\n\tint ans=0;\n\tfor (int i=0;i<=std::min(n,m);i++)\n\t{\n\t\tif ((i&1)!=(m&1)) continue;\n\t\t(ans+=(LL)solve((m*3-i)/2,n)*C(n,i)%MOD)%=MOD;\n\t\tif (m-i>=0) (ans+=(LL)solve((m-i)/2,n-1)*n%MOD*C(n-1,i)%MOD)%=MOD;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #includes {{{\n#ifdef MY_DEBUG\n#include \"header/header.hpp\"\n#else\n#include <bits/stdc++.h>\n#endif\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define LET(x,a) __typeof(a) x(a)\n//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n\n#define EXIST(e,s) ((s).find(e)!=(s).end())\n\n#define RESET(a) memset((a),0,sizeof(a))\n#define SET(a) memset((a),-1,sizeof(a))\n#define PB push_back\n#define DEC(it,command) __typeof(command) it=command\n\n//debug\n\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\n\ntypedef long long Int;\ntypedef unsigned long long uInt;\ntypedef long double rn;\n\ntemplate<class T>\nconstexpr T inf = numeric_limits<T>::has_infinity ? numeric_limits<T>::infinity():(numeric_limits<T>::max()/2);\n\nint __inf_ignore(){\n\tint t = inf<int>;\n\treturn t;\n}\n\ntypedef pair<int,int> pii;\n\n#ifdef MY_DEBUG\n#include\"print.hpp\"\n#include\"debug.hpp\"\n#endif\n// }}}\n\n//{{{ gcd and inverse\n#define __GCD_H\nInt gcd(Int a, Int b) {\n\treturn b != 0 ? gcd(b, a % b) : a;\n}\nInt lcm(Int a, Int b) {\n\treturn a / gcd(a, b) *b;\n}\n// a x + b y = gcd(a, b)\nInt extgcd(Int a, Int b, Int &x, Int &y) {\n\tInt g = a; x = 1; y = 0;\n\tif (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n\treturn g;\n}\nInt invMod(Int a, Int m) {\n\tInt x, y;\n\tif (extgcd(a, m, x, y) == 1) return (x + m) % m;\n\telse                         return 0; // unsolvable\n}\n//}}}\n\nconst int MOD = 998244353;\n//{{{ Modular algebra, Mint\nstruct Mint{\n\tint v;\n\ttemplate<class T>\n\tMint(T n){\n\t\tv = n%MOD;\n\t\tif(v<0)v+=MOD;\n\t}\n\tMint():v(0){}\n\texplicit operator int() const {return v;}\n\texplicit operator long long() const {return v;}\n\tinline void operator *=(const Mint &a) {\n\t\tv = (v*(long long)a.v)%MOD;\n\t}\n\tinline Mint operator *(const Mint &a) {\n\t\tMint n(*this);n*=a;\n\t\treturn n;\n\t}\n\tinline void operator+=(const Mint &a){\n\t\tv+=a.v;\n\t\tif(v>=MOD)v-=MOD;\n\t\t//\tassert(0<=v and v<MOD);\n\t}\n\tinline Mint operator+(const Mint &a){\n\t\tMint n(*this);n+=a;\n\t\treturn n;\n\t}\n\tinline Mint operator -(){\n\t\tif(v==0)return 0;\n\t\telse return Mint(MOD-v);\n\t}\n\tinline void operator -=(const Mint &a){\n\t\tv-=a.v;\n\t\tif(v<0)v+=MOD;\n\t}\n\tinline Mint operator -(const Mint &a){\n\t\tMint n(*this);n-=a;\n\t\treturn n;\n\t}\n#ifdef __GCD_H\n\tinline Mint inv(){\n\t\treturn Mint(invMod(this->v,MOD));\n\t}\n\tinline void operator /=(const Mint &a){\n\t\t(*this)*=invMod(a.v,MOD);\n\t}\n\tinline Mint operator /(const Mint &a){\n\t\tMint n(*this);n/=a;\n\t\treturn n;\n\t}\n#endif\n};\n\ntemplate<class T>\nT& operator <<(T &os, const Mint &n){\n\tos<<(int)n.v;\n\treturn os;\n}\n\ntemplate<class T>\nT& operator >>(T &is, Mint &n){\n\tlong long v;is >> v;\n\tn = Mint(v);\n\treturn is;\n}\n//}}}\n\n//{{{ fact, comb, multinom\ninline Mint fact(int n){\n\tstatic vector<Mint> __fact(1,1);\n\twhile(n>=(int)__fact.size())__fact.push_back(__fact.back()*__fact.size());\n\treturn __fact[n];\n}\n\ninline Mint comb_memo(int n,int r){\n\tstatic vector<vector<Mint> > __comb;\n\tstatic vector<vector<bool> > __vis;\n\tif(n<0 or r<0 or n<r)return 0;\n\twhile(n>=(int)__vis.size())__comb.push_back(vector<Mint>(__comb.size()+1)), __vis.push_back(vector<bool>(__vis.size()+1,false));\n//\twhile(n>=(int)__comb.size())__comb.push_back(vector<Mint >(__comb.size()+1,-1));\n\tif(__vis[n][r])return __comb[n][r];\n\t__vis[n][r] = true;\n\tif(r==0 or n==r)return __comb[n][r].v = 1;\n\telse return __comb[n][r] = comb_memo(n-1,r-1) + comb_memo(n-1,r);\n}\n\n#ifdef __GCD_H\ninline Mint comb(int n,int r){\n\tif(n<0 or r<0 or n<r)return 0;\n\tMint fn = fact(n), fr = fact(r), fr2 = fact(n-r);\n\t//\treturn fact(n)/(fact(r)*fact(n-r));\n\treturn fn/(fr*fr2);\n}\n\ninline Mint multinom(const vector<int> &v){\n\tMint num(fact(accumulate(ALL(v),0))), denom(1);\n\tREP(i,v.size())denom*=fact(v[i]);\n\treturn num/denom;\n}\n#endif\n//}}}\n\nInt N;\nInt M;\n\nvoid solve(){\n\tMint ans = comb(3*M+N-1,N-1);\n\t// first type: majority is in a section\n\tfor(int t = 0;t < M;t++){\n\t\t//larger than t * 2\n\t\tans -= comb(t+N-2,N-2) * N;\n\t}\n\t// second type: odd is smaller\n\tfor(int k = 0;k <= 3*M and k <= N;k++){\n\t\tInt u = 3 * M - k;\n\t\tif(u%2!=0)continue;\n\t\tu/=2;\n\t\tif(u>=k)continue;\n\t\tans -= comb(N,k)*comb(u+N-1,N-1);\n\t}\n\tcout<<ans<<endl;\n}\n//{{{ main fucnction\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tcin >> N;\n    cin >> M;\n\tsolve();\n\treturn 0;\n}\n//}}}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 998244353\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nInt fact[3240000];\nInt revfact[3240000];\nInt rev[3240000];\n\nvoid init(){\n    Int m = MOD;\n    fact[0] = 1;\n    revfact[0] = 1;\n    rev[0] = 0;\n    rev[1] = 1;\n    for(int i = 1;i < 3240000;i++){\n        fact[i] = fact[i-1] * i % m;\n        if(i>1)rev[i] = MOD / i * (MOD-rev[MOD % i]) % MOD;\n        revfact[i] = revfact[i-1] * rev[i] % MOD;\n    }\n}\n\nInt nCk(Int n, Int k){\n    if(n < k)return 0;\n    return fact[n] * revfact[n-k] % MOD * revfact[k] % MOD;\n}\n\nInt res;\nInt n, m;\nint main(){\n    init();\n    cin >> n >> m;\n    res = nCk(3*m + n - 1, n - 1);\n    res -= n * nCk(m - 1 + n - 1, n - 1) % MOD;\n    for(int i = m+1;i <= n && i <= 3 * m;i++){\n        if((3 * m - i) % 2)continue;\n        int rest = (3 * m - i) / 2;\n        res -= nCk(n, i) * nCk(rest + n - 1, n - 1) % MOD;\n        res %= MOD;\n    }\n    if(res < 0)res += MOD;\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> pp;\ntypedef pair<ll, ll> pl;\nconst double EPS = 1e-9;\nconst ll MOD = 998244353;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n\nll kai[2000001];\nll mokai[2000001];\n\nll mod_pow (ll x, ll y) {\n    ll ret = 1;\n    while (y) {\n        if (y&1) ret = ret*x%MOD;\n        x = x*x%MOD;\n        y /= 2;\n    }\n    return ret;\n}\n\nvoid init (int _n) {\n    kai[0] = 1;\n    for (int i = 1; i <= _n; i++) kai[i] = kai[i-1]*i%MOD;\n    for (int i = 0; i <= _n; i++) mokai[i] = mod_pow(kai[i],MOD-2);\n}\n\nll conb (ll x, ll y) {\n    ll z = x-y;\n    ll ret = kai[x]*mokai[y]%MOD;\n    ret = ret*mokai[z]%MOD;\n    return ret;\n}\n\nll n, m;\n\nint main() {\n    init(2000000);\n    cin >> n >> m;\n    ll ans = 0;\n    for (int i = m%2; i <= min(n,m); i += 2) {\n        ll M = m + (m-i)/2;\n        ans = (ans + conb(n-1+M, n-1) * conb(n, i)) % MOD;\n    }\n    ans = (ans - n * (conb(n-1+m-1, n-1)+MOD) + MOD*MOD) % MOD;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\nusing ll = long long;\n#define fst first\n#define snd second\n\n/* clang-format off */\ntemplate <class T, size_t D> struct _vec { using type = vector<typename _vec<T, D - 1>::type>; };\ntemplate <class T> struct _vec<T, 0> { using type = T; };\ntemplate <class T, size_t D> using vec = typename _vec<T, D>::type;\ntemplate <class T> vector<T> make_v(size_t size, const T& init) { return vector<T>(size, init); }\ntemplate <class... Ts> auto make_v(size_t size, Ts... rest) { return vector<decltype(make_v(rest...))>(size, make_v(rest...)); }\ntemplate <class T> inline void chmin(T &a, const T& b) { if (b < a) a = b; }\ntemplate <class T> inline void chmax(T &a, const T& b) { if (b > a) a = b; }\n/* clang-format on */\n\ntemplate <std::uint_fast64_t Modulus>\nclass modint {\n  using u64 = std::uint_fast64_t;\n\n public:\n  u64 a;\n\n  constexpr modint(const u64 x = 0) noexcept\n      : a(x % Modulus) {\n  }\n  constexpr u64 &value() noexcept {\n    return a;\n  }\n  constexpr const u64 &value() const noexcept {\n    return a;\n  }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(const modint rhs) noexcept {\n    return *this *= ~rhs;\n  }\n  constexpr modint power(u64 exp) const noexcept {\n    modint v = 1, x = *this;\n    while (exp) {\n      if (exp & 1) {\n        v *= x;\n      }\n      x *= x;\n      exp >>= 1;\n    }\n    return v;\n  }\n  constexpr modint operator~() const noexcept {\n    return power(Modulus - 2);\n  }\n};\n\nusing mint = modint<998244353>;\n\nvector<mint> fact, factInv;\nvoid initFact(int N) {\n  fact.resize(N + 1);\n  factInv.resize(N + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= N; i++) fact[i] = fact[i - 1] * i;\n  factInv[N] = ~fact[N];\n  for (int i = N - 1; i >= 0; i--) factInv[i] = factInv[i + 1] * (i + 1);\n}\n\nmint choose(int n, int k) {\n  if (n < 0 || k < 0 || k > n) {\n    return 0;\n  } else {\n    return fact[n] * factInv[k] * factInv[n - k];\n  }\n}\n\nmint multiChoose(int n, int k) {\n  if (n == 0 && k == 0) {\n    return 1;\n  } else {\n    return choose(n + k - 1, k);\n  }\n}\n\nmint f(int M, int N, int L) {\n  if (L == 0) return 1;\n  if (M == 0 || N == 0) return 0;\n  mint res = 0;\n  for (int k = 0; k <= N; k++) {\n    int rem = L - (M + 1) * k;\n    if (rem < 0) break;\n    mint ways = choose(N, k) * choose(rem + N - 1, N - 1);\n    if (k % 2 == 0) {\n      res += ways;\n    } else {\n      res -= ways;\n    }\n  }\n  return res;\n}\n\nint main() {\n#ifdef DEBUG\n  ifstream ifs(\"in.txt\");\n  cin.rdbuf(ifs.rdbuf());\n#endif\n  int N, M;\n  while (cin >> N >> M) {\n    initFact(4 * 1e6);\n    mint res = 0;\n    for (int k = 0; k <= N; k++) {\n      int L = 3 * M - k;\n      if (L < 0 || L & 1 || (L / 2 + k) > 2 * M) continue;\n      L /= 2;\n      mint ways = f(M - 1, N, L);\n      if (k < N && L >= M) {\n        ways += f(M - 1, N - 1, L - M) * (N - k);\n      }\n      res += ways * choose(N, k);\n    }\n    cout << res.value() << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//雪花飄飄北風嘯嘯\n//天地一片蒼茫\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n#define ll long long\n#define ii pair<ll,ll>\n#define iii pair<ii,ll>\n#define fi first\n#define se second\n#define endl '\\n'\n#define debug(x) cout << #x << \" is \" << x << endl;\n\n#define rep(x,start,end) for(auto x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n\nll MAX(ll a){return a;}\nll MIN(ll a){return a;}\ntemplate<typename... Args>\nll MAX(ll a,Args... args){return max(a,MAX(args...));}\ntemplate<typename... Args>\nll MIN(ll a,Args... args){return min(a,MIN(args...));}\n\n#define indexed_set tree<ll,null_type,less<ll>,rb_tree_tag,tree_order_statistics_node_update>\n\nmt19937 rng(chrono::system_clock::now().time_since_epoch().count());\n\nconst int MOD=1000000007;\n\nll qexp(ll b,ll p,int m){\n    ll res=1;\n    while (p){\n        if (p&1) res=(res*b)%m;\n        b=(b*b)%m;\n        p>>=1;\n    }\n    return res;\n}\n\nll inv(ll i){\n\treturn qexp(i,MOD-2,MOD);\n}\n\nll fac[1000005];\nll ifac[1000005];\n\nll nCk(int i,int j){\n\tif (i<j) return 0; //big bruh\t\n\t\n\treturn fac[i]*ifac[j]%MOD*ifac[i-j]%MOD;\n}\n\nll fix(ll i){\n\ti%=MOD;\n\t\n\tif (i<0) i+=MOD;\n\t\n\treturn i;\n}\n\nll dist(int i,int j){ //distribute j things among i ppl\n\treturn nCk(i+j-1,i-1);\n}\n\nint n,m;\n\nll comp[500005];\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\t\n\tfac[0]=1;\n\trep(x,1,1000005) fac[x]=fac[x-1]*x%MOD;\n\trep(x,0,1000005) ifac[x]=inv(fac[x]);\n\t\n\tcin>>n>>m;\n\t\n\tcomp[0]=n*dist(n-1,0)%MOD;\n\trep(x,1,500005) comp[x]=(comp[x-1]+n*dist(n-1,x))%MOD;\n\t\n\tll ans=0;\n\tfor (int x=m;x>=0;x-=2) if (x<=n){\n\t\tint k=(3*m-x)/2;\n\t\t//cout<<k<<\" \"<<x<<endl;\n\t\t\n\t\t//each number is form 2A+B\n\t\t\n\t\t//case 1: there exists a number with A=m\n\t\tans=fix(ans+n*dist(n-1,k-m)%MOD*nCk(n-1,x));\n\t\t\n\t\t//case 2: bigest number <2m\n\t\tans=fix(ans+(dist(n,k)-comp[k-m])*nCk(n,x));\n\t\n\t\t//cout<<ans<<endl;\n\t}\n\t\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \n#include <complex>\n#include <queue>\n#include <set>\n#include <list>\n#include <chrono>\n#include <random>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> p32;\ntypedef pair<ll,ll> p64;\ntypedef pair<double,double> pdd;\ntypedef vector<ll> v64;\ntypedef vector<int> v32;\ntypedef vector<vector<int> > vv32;\ntypedef vector<vector<ll> > vv64;\ntypedef vector<vector<p64> > vvp64;\ntypedef vector<p64> vp64;\ntypedef vector<p32> vp32;\nll MOD = 998244353;\n#define forn(i,e) for(ll i = 0; i < e; i++)\n#define forsn(i,s,e) for(ll i = s; i < e; i++)\n#define rforn(i,s) for(ll i = s; i >= 0; i--)\n#define rforsn(i,s,e) for(ll i = s; i >= e; i--)\n#define ln \"\\n\"\n#define dbg(x) cout<<#x<<\" = \"<<x<<ln\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define INF LLONG_MAX\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) ((ll)(x).size())\n\nll mpow(ll a, ll b){\n\tif(b==0) return 1;\n\tll t1 = mpow(a,b/2);\n\tt1 *= t1;\n\tt1 %= MOD;\n\tif(b%2) t1 *= a;\n\tt1 %= MOD;\n\treturn t1;\n}\n\nll modinverse(ll a, ll m){\n\tll m0 = m; \n    ll y = 0, x = 1; \n    if (m == 1) return 0; \n    while (a > 1){\n        ll q = a / m; \n        ll t = m; \n        m = a % m, a = t; \n        t = y; \n        y = x - q * y; \n        x = t; \n    }\n    if (x < 0) x += m0; \n    return x; \n}\n\nll range(ll l, ll r){\n\treturn l + rand()%(r-l+1);\n}\n\nv64 fact;\n\nll ncr(ll n, ll r){\n\tif(r>n || r<0) return 0;\n\tll num = fact[n];\n\tll den = (fact[r]*fact[n-r])%MOD;\n\tll ans = (num * mpow(den,MOD-2))%MOD;\n\treturn ans;\n}\n\nvoid solve(){\n\tll n,m;\n\tcin >> n >> m;\n\tfact.resize(3*m+n);\n\tfact[0]=1;\n\tforsn(i,1,3*m+n){\n\t\tfact[i]=(fact[i-1]*i)%MOD;\n\t}\n\tll ans = ncr(n+3*m-1,3*m);\n\t// if((3*m+1)%2) ans *= -1;\n\t// cout << ans << ln;\n\t// if(m%2) \n\tans -= (n*ncr(n+m-2,m-1))%MOD;\n\t// else ans += (n*ncr(n+m-2,m-1))%MOD;\n\tfor(ll i = m+2; i <= 3*m; i+=2){\n\t\tans -= (ncr(n,i)*ncr(n+(3*m-i)/2-1,n-1))%MOD;\n\t\tans %= MOD;\n\t}\n\t// cout << ans << ln;\n\tans += MOD;\n\tans %= MOD;\n\tcout << ans << ln;\n}\n\nint main()\n{\n\tfast_cin();\n    ll t=1;\n    // cin >> t;\n    forn(i,t) {\n    \tsolve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "///Bismillahir Rahmanir Rahim\n#include<bits/stdc++.h>\n\n#define                           int                         long long\n#define                           fi                          first\n#define                           si                          second\n#define                           mp                          make_pair\n#define                           pb                          push_back\n#define                           pi                          pair<int,int>\n#define                           f(i,l,r)                    for(int i=l;i<=r;i++)\n#define                           rf(i,r,l)                   for(int i=r;i>=l;i--)\n#define                           done(i)                     cout<<\"done = \"<<i<<endl;\n#define                           fast                        ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\n\n\n\nusing namespace std;\n\nconst int inf=1e18;\nconst int M=100009;\nconst int N = 1e6 + 100;\nint mod = 998244353;\nnamespace Combi {\n    int fact[N], inv[N];\n\n    int bm(int b, int p, int m) {\n        if(p == 0) return 1%m;\n        int t = bm(b,p/2,m);\n        t = (1ll*t*t)%m;\n        if(p&1) return 1ll*t*b%m;\n        return t;\n    }\n\n    int C(int n, int r) {\n        if(n < 0 or r < 0 or r > n) return 0;\n        int ret = 1ll*fact[n]*inv[r]%mod;\n        ret = 1ll*ret*inv[n-r]%mod;\n        return ret;\n    }\n    // X1 + X2 + ... + Xvar = Sum\n    int no_of_eqns(int sum, int var) {\n        return C(sum+var-1,var-1); // Xi >= 0\n        // return C(sum-1,var-1); // Xi > 0\n    }\n    void init() {\n        fact[0] = 1;\n        for(int i = 1; i < N; i++) {\n            fact[i] = 1ll*fact[i-1]*i%mod;\n        }\n        inv[N-1] = bm(fact[N-1], mod-2, mod);\n        for(int i = N-2; i >= 0; i--) {\n            inv[i] = 1ll*inv[i+1]*(i+1)%mod;\n        }\n    }\n}\ninline int gun(int x,int y)\n{\n    int ret=(x*y)%mod;\n    if(ret<0)ret+=mod,ret=ret%mod;\n    return ret;\n}\ninline int sub(int x,int y)\n{\n    int ret=(x-y+mod)%mod;\n    if(ret<0)ret+=mod,ret=ret%mod;\n    return ret;\n}\nint yo(int sum,int n,int mx)\n{\n    int ret=0;\n    for(int od=0;od<=mx && od<=n && od<=sum;od++)\n    {\n        if((od&1)!=(sum&1))continue;\n        int x=gun(Combi::C(n,od),Combi::no_of_eqns((sum-od)/2,n));\n        ret=(ret+x)%mod;\n    }\n    return ret;\n}\n main()\n\n{\n    fast\n    Combi::init();\n    int n,m;\n    cin>>n>>m;\n    int ses=yo(3*m,n,m);\n    int bad=yo(m,n,m);\n    bad=sub(bad,Combi::no_of_eqns(m,n-1));\n    bad=gun(bad,n);\n    ses=sub(ses,bad);\n    cout<<ses<<endl;\n    return 0;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string.h>\n#include <cstdlib>\n#define N 2000005\nusing namespace std;\ntypedef long long ll;\nconst int mod=998244353;\nint n,m;\nll f[N],inv[N];\nll C(int n,int m){\n\treturn f[n]*inv[m]%mod*inv[n-m]%mod;\n}\nll solve(int n,int m){\n\tll ans=0;\n\tfor(int i=m&1;i<=m;i+=2){\n\t\tll w=C(n,i);\n\t\tint res=m*3-i>>1;\n\t\tans=(ans+w*C(res+n-1,n-1))%mod;\n\t}\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tf[0]=f[1]=inv[0]=inv[1]=1;\n\tfor(int i=2;i<=2000002;i++) f[i]=f[i-1]*i%mod,inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=1;i<=2000002;i++) inv[i]=inv[i-1]*inv[i]%mod;\n\tll ans=(solve(n,m)-C(n+m-2,n-1)*n)%mod;\n\tans=(ans+mod)%mod;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvoid *wmem;\ntemplate<class T> void walloc1d(T **arr, int x, void **mem = &wmem){\n  (*arr)=(T*)(*mem);\n  (*mem)=((*arr)+x);\n}\nstruct mint{\n  static unsigned R, RR, Rinv, W, md, mdninv;\n  unsigned val;\n  mint(){\n  }\n  mint(int a){\n    val = mulR(a);\n  }\n  mint(unsigned a){\n    val = mulR(a);\n  }\n  mint(long long a){\n    val = mulR(a);\n  }\n  mint(unsigned long long a){\n    val = mulR(a);\n  }\n  int get_inv(long long a, int md){\n    long long e, s=md, t=a, u=1, v=0;\n    while(s){\n      e=t/s;\n      t-=e*s;\n      u-=e*v;\n      swap(t,s);\n      swap(u,v);\n    }\n    if(u<0){\n      u+=md;\n    }\n    return u;\n  }\n  void setmod(unsigned m){\n    int i;\n    unsigned t;\n    W = 32;\n    md = m;\n    R = (1ULL << W) % md;\n    RR = (unsigned long long)R*R % md;\n    switch(m){\n      case 104857601:\n      Rinv = 2560000;\n      mdninv = 104857599;\n      break;\n      case 998244353:\n      Rinv = 232013824;\n      mdninv = 998244351;\n      break;\n      case 1000000007:\n      Rinv = 518424770;\n      mdninv = 2226617417U;\n      break;\n      case 1000000009:\n      Rinv = 171601999;\n      mdninv = 737024967;\n      break;\n      case 1004535809:\n      Rinv = 234947584;\n      mdninv = 1004535807;\n      break;\n      case 1007681537:\n      Rinv = 236421376;\n      mdninv = 1007681535;\n      break;\n      case 1012924417:\n      Rinv = 238887936;\n      mdninv = 1012924415;\n      break;\n      case 1045430273:\n      Rinv = 254466304;\n      mdninv = 1045430271;\n      break;\n      case 1051721729:\n      Rinv = 257538304;\n      mdninv = 1051721727;\n      break;\n      default:\n      Rinv = get_inv(R, md);\n      mdninv = 0;\n      t = 0;\n      for(i=0;i<(int)W;i++){\n        if(t%2==0){\n          t+=md;\n          mdninv |= (1U<<i);\n        }\n        t /= 2;\n      }\n    }\n  }\n  unsigned mulR(unsigned a){\n    return (unsigned long long)a*R%md;\n  }\n  unsigned mulR(int a){\n    if(a < 0){\n      a = a%md+md;\n    }\n    return mulR((unsigned)a);\n  }\n  unsigned mulR(unsigned long long a){\n    return mulR((unsigned)(a%md));\n  }\n  unsigned mulR(long long a){\n    a %= md;\n    if(a < 0){\n      a += md;\n    }\n    return mulR((unsigned)a);\n  }\n  unsigned reduce(unsigned T){\n    unsigned m=T * mdninv, t=(unsigned)((T + (unsigned long long)m*md) >> W);\n    if(t >= md){\n      t -= md;\n    }\n    return t;\n  }\n  unsigned reduce(unsigned long long T){\n    unsigned m=(unsigned)T * mdninv, t=(unsigned)((T + (unsigned long long)m*md) >> W);\n    if(t >= md){\n      t -= md;\n    }\n    return t;\n  }\n  unsigned get(){\n    return reduce(val);\n  }\n  mint &operator+=(mint a){\n    val += a.val;\n    if(val >= md){\n      val -= md;\n    }\n    return *this;\n  }\n  mint &operator-=(mint a){\n    if(val < a.val){\n      val = val + md - a.val;\n    }\n    else{\n      val -= a.val;\n    }\n    return *this;\n  }\n  mint &operator*=(mint a){\n    val = reduce((unsigned long long)val*a.val);\n    return *this;\n  }\n  mint &operator/=(mint a){\n    return *this *= a.inverse();\n  }\n  mint operator+(mint a){\n    return mint(*this)+=a;\n  }\n  mint operator-(mint a){\n    return mint(*this)-=a;\n  }\n  mint operator*(mint a){\n    return mint(*this)*=a;\n  }\n  mint operator/(mint a){\n    return mint(*this)/=a;\n  }\n  mint operator+(int a){\n    return mint(*this)+=mint(a);\n  }\n  mint operator-(int a){\n    return mint(*this)-=mint(a);\n  }\n  mint operator*(int a){\n    return mint(*this)*=mint(a);\n  }\n  mint operator/(int a){\n    return mint(*this)/=mint(a);\n  }\n  mint operator+(long long a){\n    return mint(*this)+=mint(a);\n  }\n  mint operator-(long long a){\n    return mint(*this)-=mint(a);\n  }\n  mint operator*(long long a){\n    return mint(*this)*=mint(a);\n  }\n  mint operator/(long long a){\n    return mint(*this)/=mint(a);\n  }\n  mint operator-(void){\n    mint res;\n    if(val){\n      res.val=md-val;\n    }\n    else{\n      res.val=0;\n    }\n    return res;\n  }\n  operator bool(void){\n    return val!=0;\n  }\n  operator int(void){\n    return get();\n  }\n  operator long long(void){\n    return get();\n  }\n  mint inverse(){\n    int a=val, b=md, t, u=1, v=0;\n    mint res;\n    while(b){\n      t = a / b;\n      a -= t * b;\n      swap(a, b);\n      u -= t * v;\n      swap(u, v);\n    }\n    if(u < 0){\n      u += md;\n    }\n    res.val = (unsigned long long)u*RR % md;\n    return res;\n  }\n  mint pw(unsigned long long b){\n    mint a(*this), res;\n    res.val = R;\n    while(b){\n      if(b&1){\n        res *= a;\n      }\n      b >>= 1;\n      a *= a;\n    }\n    return res;\n  }\n  bool operator==(int a){\n    return mulR(a)==val;\n  }\n  bool operator!=(int a){\n    return mulR(a)!=val;\n  }\n}\n;\nmint operator+(int a, mint b){\n  return mint(a)+=b;\n}\nmint operator-(int a, mint b){\n  return mint(a)-=b;\n}\nmint operator*(int a, mint b){\n  return mint(a)*=b;\n}\nmint operator/(int a, mint b){\n  return mint(a)/=b;\n}\nmint operator+(long long a, mint b){\n  return mint(a)+=b;\n}\nmint operator-(long long a, mint b){\n  return mint(a)-=b;\n}\nmint operator*(long long a, mint b){\n  return mint(a)*=b;\n}\nmint operator/(long long a, mint b){\n  return mint(a)/=b;\n}\ninline void rd(int &x){\n  int k, m=0;\n  x=0;\n  for(;;){\n    k = getchar_unlocked();\n    if(k=='-'){\n      m=1;\n      break;\n    }\n    if('0'<=k&&k<='9'){\n      x=k-'0';\n      break;\n    }\n  }\n  for(;;){\n    k = getchar_unlocked();\n    if(k<'0'||k>'9'){\n      break;\n    }\n    x=x*10+k-'0';\n  }\n  if(m){\n    x=-x;\n  }\n}\ninline void wt_L(char a){\n  putchar_unlocked(a);\n}\ninline void wt_L(int x){\n  char f[10];\n  int m=0, s=0;\n  if(x<0){\n    m=1;\n    x=-x;\n  }\n  while(x){\n    f[s++]=x%10;\n    x/=10;\n  }\n  if(!s){\n    f[s++]=0;\n  }\n  if(m){\n    putchar_unlocked('-');\n  }\n  while(s--){\n    putchar_unlocked(f[s]+'0');\n  }\n}\ninline void wt_L(mint x){\n  int i;\n  i = (int)x;\n  wt_L(i);\n}\nstruct combination_mint{\n  mint *fac, *ifac;\n  void init(int n, void **mem = &wmem){\n    int i;\n    walloc1d(&fac, n, mem);\n    walloc1d(&ifac, n, mem);\n    fac[0] = 1;\n    for(i=1;i<n;i++){\n      fac[i] = fac[i-1] * i;\n    }\n    ifac[n-1] = 1 / fac[n-1];\n    for(i=n-2;i>=0;i--){\n      ifac[i] = ifac[i+1] * (i+1);\n    }\n  }\n  mint C(int a, int b){\n    if(b < 0 || b > a){\n      return 0;\n    }\n    return fac[a]*ifac[b]*ifac[a-b];\n  }\n  mint P(int a, int b){\n    if(b < 0 || b > a){\n      return 0;\n    }\n    return fac[a]*ifac[a-b];\n  }\n  mint H(int a, int b){\n    if(a==0 && b==0){\n      return 1;\n    }\n    if(a<=0 || b<0){\n      return 0;\n    }\n    return C(a+b-1, b);\n  }\n}\n;\nchar memarr[96000000];\nunsigned mint::R, mint::RR, mint::Rinv, mint::W, mint::md, mint::mdninv;\n#define MD 998244353\nint N;\nint M;\nint main(){\n  combination_mint c;\n  int i, j;\n  mint m, res, tmp;\n  wmem = memarr;\n  {\n    mint x;\n    x.setmod(MD);\n  }\n  rd(N);\n  rd(M);\n  c.init(3000000);\n  res = 0;\n  for(i=M%2;i<=M;i+=2){\n    j = (3*M - i) / 2;\n    tmp = c.C(N,i);\n    tmp *= c.H(N,j) - ((N-i) * c.H(N,j-M-1) + i * c.H(N,j-M));\n    res += tmp;\n  }\n  wt_L(res);\n  wt_L('\\n');\n  return 0;\n}\n// cLay varsion 20190721-1\n\n// --- original code ---\n// #define MD 998244353\n// int N, M;\n// {\n//   int i, j;\n//   mint res, tmp, m;\n//   combination_mint c;\n// \n//   rd(N,M);\n//   c.init(3d6);\n// \n//   res = 0;\n//   for(i=M%2;i<=M;i+=2){\n//     j = (3M - i) / 2;\n//     tmp = c.C(N,i);\n//     tmp *= c.H(N,j) - ((N-i) * c.H(N,j-M-1) + i * c.H(N,j-M));\n//     res += tmp;\n//   }\n// \n//   wt(res);\n// }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\n\nlong long P = 998244353;\n\nclass C {\npublic:\n  int n;\n  vector<long long> fac, inv, facInv;\n\n  long long power(long long e, long long x) {\n    if (x == 0)\n      return 1;\n    if (x == 1)\n      return e;\n    if (x % 2 == 0)\n      return power((e * e) % P, x / 2);\n    return (e * power(e, x - 1)) % P;\n  }\n\n  C(int n_) {\n    n = n_;\n    fac.resize(n + 1);\n    inv.resize(n + 1);\n    facInv.resize(n + 1);\n    fac[0] = fac[1] = 1;\n    for (int i = 2; i <= n; i++)\n      fac[i] = (i * fac[i - 1]) % P;\n    inv[0] = inv[1] = 1;\n    for (int i = 2; i <= n; i++)\n      inv[i] = power(i, P - 2);\n    facInv[0] = facInv[1] = 1;\n    for (int i = 2; i <= n; i++)\n      facInv[i] = (inv[i] * facInv[i - 1]) % P;\n  }\n\n  long long comb(int N, int K) {\n    if (N < K || K < 0 || N < 0)\n      return 0;\n    if (N == 0 || K == 0 || K == N)\n      return 1;\n    return ((fac[N] * facInv[K]) % P * facInv[N - K]) % P;\n  }\n\n  long long hcomb(int N, int K) {\n    if (N == 0 && K == 0)\n      return 1;\n    return comb(N + K - 1, K);\n  }\n\n  long long mul(long long a, long long b) { return (a * b) % P; }\n\n  long long add(long long a, long long b) { return (a + b) % P; }\n\n  // find c\n  // where a^c = b (mod P)\n  long long dlp(long long a, long long b) {\n    long long m = ceil(sqrt(P));\n    map<long long, long long> mp;\n    for (int i = 0; i < m; i++)\n      mp[power(a, i)] = i;\n    long long ainvm = power(power(a, m), P - 2);\n    cout << m << endl;\n    for (int i = 0; i < m; i++) {\n      if (mp.find(b) != mp.end()) {\n        return i * m + mp[b];\n      }\n      b = mul(b, ainvm);\n    }\n    return -1;\n  }\n};\n\nC cmb(2020202);\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  ll n, m;\n  cin >> n >> m;\n  ll ans = 0;\n  for (int i = 0; i <= min(m, n); i++) {\n    ll rest = 3 * m - i;\n    if (rest % 2 == 1) continue;\n    rest /= 2;\n    ans += (cmb.comb(rest + n - 1, n - 1) * cmb.comb(n, i)) % P;\n    ans %= P;\n  }\n  for (int i = 0; i <= min(m, n); i++) {\n    ll rest = m - i;\n    if (rest % 2 == 1) continue;\n    rest /= 2;\n    ans += P - (n * cmb.comb(rest + n - 1, n - 1) % P * cmb.comb(n, i)) % P;\n    ans %= P;\n  }\n  for (int i = 0; i <= min(m, n - 1); i++) {\n    ll rest = m - i;\n    if (rest % 2 == 1) continue;\n    rest /= 2;\n    ans += (n * cmb.comb(rest + n - 2, n - 2) % P * cmb.comb(n - 1, i)) % P;\n    ans %= P;\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define ft first\n#define sd second\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define Fr(i,n) for(int i=1;i<=(n);++i)\n#define ifr(i,n) for(int i=(n)-1;i>=0;--i)\n#define iFr(i,n) for(int i=(n);i>0;--i)\n\nconst ll MOD=998244353;\n\nll ad(ll x,ll y=0){\n  return (x+y)%MOD;\n}\n\nll mlt(ll x,ll y=1){\n  return (x*y)%MOD;\n}\n\nll pwr(ll x,ll y){\n  ll pw[32]={},w=1;\n  pw[0]=x;\n  fr(i,31) pw[i+1]=mlt(pw[i],pw[i]);\n  fr(i,32){\n    w=mlt(w,1+(y%2)*(pw[i]-1));\n    y/=2;\n  }\n  return w;\n}\n\nll inv(ll x){\n  return pwr(x,MOD-2);\n}\n\nll fc[4000010] = {1};\n\nll fct(ll x) {\n    if (fc[x] == 0) fc[x] = mlt(x, fct(x - 1));\n    return fc[x];\n}\n\nll ifc[4000010] = {1};\n\nll ifct(ll x) {\n    if (ifc[x] == 0) ifc[x] = inv(fct(x));\n    return ifc[x];\n}\n\nvoid initfct(ll x) {\n    ifct(x);\n    ifr(i, x) ifc[i] = mlt(ifc[i + 1], i + 1);\n}\n\nll comb(ll n, ll r) {\n    if (n < 0 || r < 0 || n < r) return 0;\n    return mlt(fct(n), mlt(ifct(r), ifct(n - r)));\n}\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin>>n>>m;\n    cout<<(comb(n-1+3*m,3*m)+MOD-pwr(n,m))%MOD<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=998244353 ;\n\nconst int MAX = 3000000;\nconst int MOD = 998244353;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\n\nint main(){\n  int N, M; cin >> N >> M; COMinit();\n  ll ans = COM(3*M+N-1, N-1); ll igai = 0;\n  rep(i, M){\n    igai+=(COM(i+N-2, i)*N%mod); igai%=mod;\n  }\n  for(int i=M+1; i<=min(3*M, N); i++){\n    if((3*M-i)%2) continue;\n    ll tmp = (3*M-i)/2;\n    igai+=(COM(tmp+N-1, tmp)*COM(N, i)%mod);\n    igai%=mod;\n  }\n  ans-=igai; if(ans<0) ans+=mod;\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = vector<int>;\nusing Vll = vector<ll>;\nusing Vld = vector<ld>;\nusing Vbo = vector<bool>;\nusing VV = vector<V>;\nusing VVll = vector<Vll>;\nusing VVld = vector<Vld>;\nusing VVbo = vector<Vbo>;\nusing VVV = vector<VV>;\nusing VVVll = vector<VVll>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\n#define rep2(i, m, n) for (int i = (m); i < (n); ++i)\n#define drep2(i, m, n) for (int i = (m)-1; i >= (n); --i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) (a).begin(), (a).end()\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\ntemplate<typename T> inline int sz(T &x) { return x.size(); }\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << '(' << p.first << \", \" << p.second << ')'; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << ' '; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int fLog2(const int x) { assert(x > 0); return 31-__builtin_clz(x); } // floor(log2(x))\ninline int fLog2(const ll x) { assert(x > 0); return 63-__builtin_clzll(x); }\ninline int cLog2(const int x) { assert(x > 0); return (x == 1) ? 0 : 32-__builtin_clz(x-1); } // ceil(log2(x))\ninline int cLog2(const ll x) { assert(x > 0); return (x == 1) ? 0 : 64-__builtin_clzll(x-1); }\ninline int popcount(const int x) { return __builtin_popcount(x); }\ninline int popcount(const ll x) { return __builtin_popcountll(x); }\nconst int INF  = 1<<30;\nconst ll INFll = 1ll<<62;\nconst ld EPS   = 1e-10;\nconst ld PI    = acos(-1.0);\n// const int MOD  = int(1e9)+7;\nconst int MOD  = 998244353;\n\n\nstruct mint {\n  ll x;\n  mint(ll x=0) : x((x%MOD+MOD)%MOD) {}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) { if ((x += a.x) >= MOD) x -= MOD; return *this; }\n  mint& operator-=(const mint a) { if ((x -= a.x) < 0) x += MOD; return *this; }\n  mint& operator*=(const mint a) { (x *= a.x) %= MOD; return *this; }\n  mint operator+(const mint a) const { return mint(*this) += a; }\n  mint operator-(const mint a) const { return mint(*this) -= a; }\n  mint operator*(const mint a) const { return mint(*this) *= a; }\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n  mint& operator/=(const mint r) {\n    ll a = r.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      ll t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = x * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  mint operator/(const mint a) const { return mint(*this) /= a; }\n};\n// istream& operator>>(istream& is, mint& a) { return is >> a.x; }\nostream& operator<<(ostream& os, const mint& a) { return os << a.x; }\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\nusing VVVm = vector<VVm>;\n\n\n// initialization\nconst int F_MAX = int(3e6)+10;\nll fac[F_MAX], finv[F_MAX], inv[F_MAX];\nvoid binom_init() {\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (int i = 2; i < F_MAX; ++i) {\n    fac[i] = fac[i-1] * i % MOD;\n    inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n    finv[i] = finv[i-1] * inv[i] % MOD;\n  }\n}\n\nmint binom(int n, int k) {\n  if (k < 0 || n < k) return 0;\n  return fac[n] * (finv[k] * finv[n-k] % MOD);\n}\n\nmint perm(int n, int k) {\n  if (k < 0 || n < k) return 0;\n  return fac[n] * finv[n-k];\n}\n\n\nint main() {\n  binom_init();\n  int n, m; cin >> n >> m;\n\n  mint ans = 0;\n\n  rep(k, min(n, m)+1) {\n    mint res = 0;\n    int l = 3*m - k;\n    if (l >= 0 && l % 2 == 0) res += binom(n+l/2-1, l/2);\n    l = 3*m - (2*m+k);\n    if (l >= 0 && l % 2 == 0) res -= binom(n+l/2-1, l/2) * k;\n    l = 3*m - (2*m+2+k);\n    if (l >= 0 && l % 2 == 0) res -= binom(n+l/2-1, l/2) * (n-k);\n    ans += res * binom(n, k);\n  }\n\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma target(\"avx\")\n#pragma optimize(\"O3\")\n#pragma optimize(\"unroll-loops\")\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <memory>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#define rep(i,n) for(int i=0;i<(lint)(n);i++)\n#define REP(i,n) for(int i=1;i<=(lint)(n);i++)\n#define all(V) V.begin(),V.end()\ntypedef long long lint;\ntypedef std::pair<lint, lint> P;\nconstexpr int INF = INT_MAX/2;\nconstexpr lint LINF = LLONG_MAX/2;\nconstexpr double eps = 1e-9;\nconstexpr double PI=3.141592653589793238462643383279;\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ninline lint gcd(lint a, lint b) {\n\twhile (b) {\n\t\tlint c = a;\n\t\ta = b; b = c % b;\n\t}\n\treturn a;\n}\ninline lint lcm(lint a, lint b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(lint n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\ntemplate<typename T>\nT mypow(T a, unsigned int b) {\n\tif (!b)return T(1);\n\tif (b & 1)return mypow(a, b - 1) * a;\n\tT memo = mypow(a, b >> 1);\n\treturn memo * memo;\n}\nlint modpow(lint a, lint b, lint m) {\n\tif (!b)return 1;\n\tif (b & 1)return modpow(a, b - 1, m) * a % m;\n\tlint memo = modpow(a, b >> 1, m);\n\treturn memo * memo % m;\n}\ntemplate<typename T>\nvoid printArray(std::vector<T>& vec) {\n\trep(i, vec.size() - 1)std::cout << vec[i] << \" \";\n\tstd::cout << vec.back() << std::endl;\n}\ntemplate<typename T>\nvoid printArray(T l, T r) {\n\tT rprev = r;\n\trprev--;\n\tfor (T i = l; i != rprev; i++) {\n\t\tstd::cout << *i << \" \";\n\t}\n\tstd::cout << *rprev << std::endl;\n}\ntemplate<unsigned int modulo = 998244353>\nclass ModInt {\n\tlint value;\npublic:\n\tModInt() : value(0) {}\n\ttemplate<typename T>\n\tModInt(T value = 0) : value(value) {\n\t\tif (value < 0)value = -(lint)(-value % modulo) + modulo;\n\t\tthis->value = value % modulo;\n\t}\n\tinline operator int()const { return value; }\n\tinline ModInt& operator+=(const ModInt& x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline ModInt operator-()const {\n\t\treturn ModInt(0) -= *this;\n\t}\n\tinline ModInt& operator-=(const ModInt& x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator*=(const ModInt& x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator/=(ModInt rhs) {\n\t\tint exp = modulo - 2;\n\t\twhile (exp) {\n\t\t\tif (exp & 1)*this *= rhs;\n\t\t\trhs *= rhs;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn *this;\n\t}\n\ttemplate<typename T> ModInt operator+(const T& rhs)const { return ModInt(*this) += rhs; }\n\ttemplate<typename T> ModInt& operator+=(const T& rhs) { return operator+=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator-(const T& rhs)const { return ModInt(*this) -= rhs; }\n\ttemplate<typename T> ModInt& operator-=(const T& rhs) { return operator-=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator*(const T& rhs)const { return ModInt(*this) *= rhs; }\n\ttemplate<typename T> ModInt& operator*=(const T& rhs) { return operator*=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator/(const T& rhs)const { return ModInt(*this) /= rhs; }\n\ttemplate<typename T> ModInt& operator/=(const T& rhs) { return operator/=(ModInt(rhs)); }\n};\ntemplate<unsigned int T>\nstd::istream& operator>>(std::istream& ist, ModInt<T>& x) {\n\tlint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\nint n,m;\nModInt<> fact[2000010],inv[2000010];\nModInt<> comb(int a,int b){\n\treturn fact[a]*inv[a-b]*inv[b];\n}\nModInt<> comb2(int a,int b){\n\treturn comb(a+b-1,b-1);\n}\nint main(){\n\tstd::cin>>n>>m;\n\tfact[0]=1;\n\tREP(i,2000000)fact[i]=fact[i-1]*i;\n\tinv[2000000]=ModInt<>(1)/fact[2000000];\n\tfor(int i=1999999;i>=0;i--)inv[i]=inv[i+1]*(i+1);\n\tModInt<> ans=0;\n\tfor(int i=m;i>=0;i-=2){\n\t\tans+=comb(n,i)*comb2((3*m-i)/2,n)-(comb(n,i)*comb2((m-i)/2,n)-comb(n-1,i)*comb2((m-i)/2,n-1))*n;\n\t}\n\tstd::cout<<ans<<std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD 998244353\nll N,M;\nll Fa[5050505],Finv[5050505];\nll i,j,k,ans;\nll moddiv(ll a,ll b){\n    a %= MOD;\n    b %= MOD;\n    for(ll m=MOD-2;m>0;m/=2){\n        if(m&1){\n            a=a*b%MOD;\n        }\n        b=b*b%MOD;\n    }\n    return a;\n}\nll C(ll a,ll b){\n    return Fa[a] * Finv[a - b]%MOD * Finv[b]%MOD;\n}\nint main(){\n    scanf(\"%lld%lld\", &N,&M);\n    Fa[0] = 1;\n    fornum(i,0,N+M*3){\n        Fa[i + 1] = (Fa[i] * (i + 1)) % MOD;\n    }\n    Finv[i] = moddiv(1, Fa[i]);\n    for (i = i; i > 0;i--){\n        Finv[i - 1] = Finv[i] * i % MOD;\n    }\n\n    for (i = M % 2; i <= N && i <= M; i += 2)\n    {\n        ll b = 3 * M - i;\n        ans = (ans + C(N,i) * C(b / 2 + N - 1, N - 1)) % MOD;\n        ll c = M - i;\n        if (i == N)\n        {\n            ans = (ans - C(c / 2 + N - 1, N - 1) * N % MOD + MOD) % MOD;\n        }\n        else\n        {\n            ans = (ans - (C(N, i) * C(c / 2 + N - 1, N - 1) % MOD * N % MOD) + (C(N - 1, i) * C(c / 2 + N - 2, N - 2) % MOD * N % MOD) + MOD) % MOD;\n        }\n        //printf(\"%lld\\n\", ans);\n    }\n    printf(\"%lld\",ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; std::swap(a, m);\n    u -= t * v; std::swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\ntemplate <typename T>\nclass modular {\n  private:\n    int value;\n  public:\n    constexpr modular() = default;\n    constexpr modular(const modular&) = default;\n    constexpr modular(modular&&) = default;\n    modular& operator=(const modular&) = default;\n    modular& operator=(modular&&) = default;\n\n    template <typename U>\n    modular (const U& x) {value = normalize(x);}\n\n    template <typename U>\n    static auto normalize(const U& x) {\n      int v = static_cast<int>(-mod() <= x && x < mod() ? x : x % mod());\n      if (v < 0) v += mod();\n      return v;\n    }\n\n    auto const& operator()() const { return value; }\n    template <typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static auto mod() { return T::value; }\n\n    auto& operator+=(const modular& other) {\n      if ((value += other.value) >= mod()) value -= mod();\n      return *this;\n    }\n    auto& operator-=(const modular& other) {\n      if ((value -= other.value) < 0) value += mod();\n      return *this;\n    }\n    template <typename U>\n    auto& operator+=(const U& other) {return *this += modular(other); }\n    template <typename U>\n    auto& operator-=(const U& other) {return *this -= modular(other); }\n    auto operator-() const { return modular(-value); }\n    auto& operator++() {return *this += 1;}\n    auto& operator--() {return *this -= 1;}\n    auto\toperator++(int) {modular result(*this); operator++(); return result;}\n    auto\toperator--(int) {modular result(*this); operator--(); return result;}\n  \n    template <typename U = T>\n    auto& operator*=(const modular& rhs) {\n      value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n      return *this;\n    }\n    auto& operator/=(const modular& other) {\n      return *this *= modular(inverse(other.value, mod()));\n    }\n};\ntemplate <typename T> struct is_modular : std::false_type {};\ntemplate <typename T> struct is_modular <modular<T>> : std::true_type{};\ntemplate <typename T> constexpr bool is_modular_v = is_modular<T>::value;\n\ntemplate <typename T> bool operator==(const modular<T>& lhs, const modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const modular<T>& lhs, U rhs) { return lhs == modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const modular<T>& rhs) { return modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const modular<T>& lhs, const modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> modular<T> operator+(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> modular<T> operator+(const modular<T>& lhs, U rhs) { return modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> modular<T> operator+(U lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }\n\ntemplate <typename T> modular<T> operator-(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> modular<T> operator-(const modular<T>& lhs, U rhs) { return modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> modular<T> operator-(U lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> modular<T> operator*(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> modular<T> operator*(const modular<T>& lhs, U rhs) { return modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> modular<T> operator*(U lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> modular<T> operator/(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> modular<T> operator/(const modular<T>& lhs, U rhs) { return modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> modular<T> operator/(U lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nmodular<T> pow (const modular<T>& a, U b) {\n  assert(b >= 0);\n  modular<T> x = a, ret = 1;\n  for (; b > 0; b /= 2) {\n    if (b % 2 == 1) ret *= x;\n    x *= x;\n  }\n  return ret;\n}\n\ntemplate <typename T>\nstd::string to_string(const modular<T>& a) {\n  return std::to_string(a());\n}\ntemplate <typename T>\nauto operator<<(std::ostream& os, const T& a)\n  -> std::enable_if_t<is_modular_v<T>, std::ostream&>{\n    return os << a();\n  }\ntemplate <typename T>\nauto operator>>(std::istream& is, T& a)\n  -> std::enable_if_t<is_modular_v<T>, std::istream&> {\n  long long x; is >> x;\n  a = T(x);\n  return is;\n}\n\nconstexpr int md = 998244353;\nusing mint = modular<std::integral_constant<std::decay_t<decltype(md)>, md>>;\n\n#define LOCAL\nusing std::to_string;\nauto to_string(std::string s) -> std::string {\n  return '\"' + s + '\"';\n}\nauto to_string(char c) -> std::string {\n  return \"'\" + std::string{c} + \"'\";\n}\nauto to_string(const char* s) -> std::string {\n  return to_string((std::string) s);\n}\nauto to_string(bool b) -> std::string {\n  return (b ? \"true\" : \"false\");\n}\ntemplate <typename T, typename U>\nauto to_string(std::pair<T, U> p) -> std::string {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <size_t N>\nauto to_string(std::bitset<N> bs) -> std::string {\n  std::string res{};\n  for (size_t i = 0; i < N; i++)\n    res.insert(res.begin(), bs.test(i) ? '1' : '0');\n  return res;\n}\ntemplate <typename T>\nauto to_string(T v) -> std::string {\n  bool flg = false;\n  std::string res = \"{\";\n  for (auto const&x : v) {\n    if (flg) res += \", \";\n    else flg = true;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\nvoid debug_out() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  std::cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nclass factorials {\n    std::vector<mint> fact, finv;\n  public:\n    factorials(int n) : fact(n), finv(n) {\n      fact.at(0) = 1;\n      for (int i = 1; i < n; i++) fact.at(i) = fact.at(i - 1) * mint(i);\n      finv.at(n - 1) = mint(1) / fact.at(n - 1);\n      for (int i = n - 2; i >= 0; i--) finv.at(i) = finv.at(i + 1) * mint(i + 1);\n    }\n    // Returns the factorial.\n    template <typename T>\n    auto const& operator()(T i) const {return fact.at(i);}\n    // Returns the inverse of the factorial.\n    template <typename T>\n    auto const& inv(T i) const {return finv.at(i);}\n    // Returns the binominal coefficient.\n    template <typename T>\n    auto binom(T i, T j) const {\n      assert(0 <= i);\n      if (j < 0 ||i < j) return mint(0);\n      return fact.at(i) * finv.at(j) * finv.at(i - j);\n    }\n    // foo.\n    template <typename T>\n    auto part(T i, T j) const {\n      return binom(i + j - 1, j - 1);\n    }\n};\n\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  auto fact = factorials(3000000);\n  int N, M; std::cin >> N >> M;\n  const int cum_max = M;\n  std::vector<mint> cum(cum_max + 2, 0);\n  for (int i = 0; i <= cum_max; i++) {\n    cum.at(i + 1) = cum.at(i)\n      + fact.part(i, N - 1);\n  }\n  mint ans = 0;\n  for (int Q = M; 2 * Q <= 3 * M; Q++) {\n    auto a = fact.part(Q, N) - cum.at(Q - M + 1) * N;\n    auto b = fact.part(Q - M, N - 1) * N;\n    auto x = a * fact.binom(N, 3 * M - 2 * Q);\n    auto y = b * fact.binom(N - 1, 3 * M - 2 * Q);\n    ans += x + y;\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<LL,LL> P;\nconst LL mod=998244353;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\n\n\nvector<LL> fact;\nvector<LL> inver(200001);\n \nLL combi(int n,int r){\n    if(n<r||n<0||r<0) return 0;\n    return fact[n]%mod*inver[n-r]%mod*inver[r]%mod;\n}\n \n \nLL fpow(LL a, LL n){\n    LL x = 1;\n    while(n > 0){\n        if(n&1){\n            x=x*a%mod;\n        }\n        a=a*a%mod;\n        n >>= 1;\n    }\n    return x;\n}\n \nvoid set_combi(){\n    LL s=1;\n    fact.push_back(1);\n    for(int i=1;i<=200000;i++){\n        s*=i;\n        s%=mod;\n        fact.push_back(s);\n    }\n    inver[200000]=fpow(fact[200000],mod-2);\n    for(int i=199999;i>=0;i--){\n        inver[i]=inver[i+1]*(i+1)%mod;\n    }\n}\n \nLL hcombi(int n,int r){\n    return combi(n+r-1,r); \n}\n\n\n\nint main(){\n    set_combi();\n    LL n,m;cin >> n >> m;\n    LL ans = 0;\n    for (int i = min(n,m); i >= 0; i-=2) {\n        ans = (ans + hcombi(n,m+(m-i)/2) * combi(n,i))%mod;\n    }\n    for (int i = 2*m+1; i <= 3*m; i++) {\n        ans = (ans - (n * hcombi(n-1,3*m-i))%mod + mod)%mod;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nclass ModComb {\n    long long *fact, *facti;\n    const int mod;\npublic:\n    explicit ModComb(int n, int m) : mod(m) {\n        fact = new long long[n+1];\n        facti = new long long[n+1];\n        fact[0] = 1; facti[0] = 1;\n        for (int i = 1; i <= n; i++) fact[i] = (fact[i-1] * i) % m;\n        // calc 1/n!\n        long long &inv = facti[n], pw = fact[n];\n        inv = 1;\n        for (int e = mod-2; e > 0; e /= 2) {\n            if (e&1) inv = inv * pw % mod;\n            pw = pw * pw % mod;\n        }\n        for (int i = n-1; i > 0; i--) facti[i] = (facti[i+1] * (i+1)) % m;\n    }\n\n    ~ModComb() {\n        if (fact) delete[] fact;\n        if (facti) delete[] facti;\n    }\n\n    long long get(int n, int k) const {\n        if (n < 0 || k < 0 || k > n) return 0;\n        return fact[n] * facti[k] % mod * facti[n-k] % mod;\n    }\n};\n\nint main() {\n    int n, m; cin >> n >> m;\n    const int M = 998244353;\n    ModComb mc(3*m+n+3, M);\n\n    long long ans = mc.get(n+3*m-1, n-1);\n    for (int j = 0; j < m; j++) ans -= mc.get(n+j-2, n-2) * n % M;\n    for (int k = m + 2; k <= n; k += 2)\n        ans -= mc.get(n, k) * mc.get((3*m-k)/2+n-1, n-1) % M;\n    cout << (ans % M + M) % M << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(LL &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const LL &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"# \");printf(__VA_ARGS__);puts(\"\");}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 3e6+10;\nLL fac[SIZE],inv[SIZE];\nLL mypow(LL x,LL y){\n    LL res=1;\n    while(y){\n        if(y&1)res=res*x%MOD;\n        y>>=1;\n        x=x*x%MOD;\n    }\n    return res;\n}\nLL C(int x,int y){\n    if(y<0||y>x)return 0;\n    return fac[x]*inv[y]%MOD*inv[x-y]%MOD;\n}\nvoid build(){\n    assert(MOD>=SIZE);\n    fac[0]=1;\n    REPP(i,1,SIZE)fac[i]=fac[i-1]*i%MOD;\n    inv[SIZE-1]=mypow(fac[SIZE-1],MOD-2);\n    for(int i=SIZE-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%MOD;\n}\nLL N,M;\nint main(){\n    MOD = 998244353;\n    build();\n    R(N,M);\n    LL an=C(N+3*M-1,N-1);\n    ADD(an,-C(N+(3*M-2*M-1)-1,N-1)*N);\n    FOR(i,0,M-1){\n        int one=3*M-2*i;\n        if(one>N)continue;\n        ADD(an,-C(N,one)*C(N-1+i,N-1));\n    }\n    W(an);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2\")\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <cstdarg>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define whlie while\n#define retunr return\n#define reutrn return\n#define reutnr return\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define inf 1001001001\n#define MOD 998244353\n#define infLL (1LL << 61)\n#define FOR(i,a,b) for(int (i)=(int)(a); (i)<(int)(b); (i)++) // [a,b)\n#define rep(i,N) FOR((i), 0, (int)(N)) // [0,N)\n#define FORR(i,a,b) for(int (i)=(int)(b) - 1; (i)>=(int)(a); (i)--)\n#define repr(i,N) FORR((i), 0, (int)(N))\n#define each(x,v) for(auto &x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) ((int)(v).size())\n#define vrep(v,it) for(auto it=v.begin();it!=v.end();it++)\n#define vrepr(v,it) for(auto it=v.rbegin();it!=v.rend();it++)\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) ll __VA_ARGS__; in(__VA_ARGS__)\n#define inc(...) char __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\n#define ind(...) double __VA_ARGS__; in(__VA_ARGS__)\n#define inpii(...) pii __VA_ARGS__; in(__VA_ARGS__)\n//#define rand mtrand\n//#define randinit random_device seed_gen; mt19937_64 mtrand(seed_gen())\n\n#ifdef LOCAL  \n  #define trc(...) do { cout << #__VA_ARGS__ << \" = \"; dbg_out(__VA_ARGS__);} while(0)\n  #define stopif(val) assert( !(val) )\n  #define trcv(v,...) do { cout << #v << \" = \"; vector_debug(v , ##__VA_ARGS__);cout << endl;} while(0)\n#else\n  #define trc(...)\n  #define stopif(...)\n  #define trcv(...)\n#endif\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int,int>;\nusing pll = pair<ll,ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector< vector<int> >;\n\nstruct IoSetupNya {IoSetupNya() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); cerr << fixed << setprecision(15);} } iosetupnya;\n/* \nint gcd(int a, int b){if(a>b) swap(a,b); return a==0 ? b : gcd(b%a,a);} ll gcd(ll a, ll b){if(a>b) swap(a,b); return a==0 ? b : gcd(b%a,a);}\nll lcm(int a, int b){return (1LL * a / gcd(a,b)) * b;} ll lcm(ll a, ll b){return (a / gcd(a,b)) * b;}\n*/\ninline ll pow(int a, int b){ll ans = 1; rep(i,b) ans *= a; return ans;} inline ll pow(ll a, ll b){ll ans = 1; rep(i,b) ans*= a; return ans;}\ninline ll pow(int a, ll b){ll ans = 1; rep(i,b) ans *= a; return ans;} inline ll pow(ll a, int b){ll ans = 1; rep(i,b) ans*= a; return ans;}\ntemplate<typename T, typename U> inline bool amin(T &x, U y) { return (y < x) ? (x = y, true) : false; }\ntemplate<typename T, typename U> inline bool amax(T &x, U y) { return (x < y) ? (x = y, true) : false; }\ntemplate<typename C> inline void _cin(C &c){cin >> c;}\ntemplate<typename T,typename U> inline void _cin(pair<T,U> &p){cin >> p.fi; cin >> p.se;}\ntemplate<typename C> inline void _cout(const C &c){cout << c;}\ntemplate<typename T,typename U> inline void _cout(const pair<T,U> &p){cout << p.fi << ' ' << p.se;}\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ _cin(t); in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,U ...u){ _cout(t); if(sizeof...(u)) cout << ' '; out(u...);}\ntemplate<typename C> inline void in(vector<C> &v,int N=-1){if(sz(v) != 0){int M=(N == -1) ? sz(v) : N; rep(i,M) _cin(v[i]);}else{C c;rep(i,N) v.pb((_cin(c),c));}}\ntemplate<typename C> inline void in(C v[],int N){rep(i,N) _cin(v[i]);}\ntemplate<typename C> inline void out(const vector<C> &v,int N=-1){int M=(N == -1) ? sz(v) : N; rep(i,M) {cout<<( (i)?\" \":\"\" ); _cout(v[i]);} cout<<\"\\n\";}\ntemplate<typename C> inline void out(C v[],int N){rep(i,N) {cout<<( (i)?\" \":\"\" ); _cout(v[i]);} cout<<\"\\n\";}\ntemplate<typename C> inline void vector_debug(const vector<C> &v,int N=-1){cout << \"{\"; int M=(N == -1) ? sz(v) : N; rep(i,M) {cout<<( (i)?\", \":\"\" ); _cout(v[i]);} cout<<\"}\";}\ntemplate<typename C> inline void vector_debug(C v[], int N){cout << \"{\"; rep(i,N) {cout<<((i)?\", \":\"\"); _cout(*(v+i));} cout<<\"}\";}\nvoid dbg_out(){cout << endl;} template <typename T,class... U> void dbg_out(const T &t,U ...u){ _cout(t); if(sizeof...(u)) cout << \", \"; dbg_out(u...);}\ntemplate<typename C,class... U> void dbg_out(const vector<C> &v,U ...u){vector_debug(v); if(sizeof...(u)) cout << \", \"; dbg_out(u...);}\ntemplate<typename C,class... U> void dbg_out(const vector<vector<C>> &v,U ...u){cout << \"{ \"; rep(i,sz(v)) {if(i)cout<<\", \"; vector_debug(v[i]);} cout << \" }\"; if(sizeof...(u)) cout << \", \"; dbg_out(u...);}\ntemplate<typename C> inline C vmax(const vector<C> &v){C n=v[0]; rep(i,sz(v)) amax(n,v[i]); return n;} template<typename C> inline C vmax(C v[], int N){C n=v[0]; rep( i , N ) amax(n,v[i]); return n;}\ntemplate<typename C> inline C vmin(const vector<C> &v){C n=v[0]; rep(i,sz(v)) amin(n,v[i]); return n;} template<typename C> inline C vmin(C v[], int N){C n=v[0]; rep( i , N ) amin(n,v[i]); return n;}\nvoid die(string s){out(s); exit(0);}\n\n////////////\n/// main ///\n////////////\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< MOD >;\n\nint main(){\n  ini(N,M);\n\n  vector<modint> C1(4000000),C2(4000000);\n\n  C1[0] = 1;\n  for(int i = 1;i < 3 * M + N ; i++){\n    C1[i] = C1[i-1] * (3 * M + N - i);\n    C1[i] /= i;\n    trc(i,C1[i]);\n  }\n\n  C2[3 * M] = 1; \n  { int j = 0;\n  for(int i = 3 * M - 1;i >= 0; i--){\n    j++;\n    C2[i] = C2[i + 1] * (j + N - 2);\n    C2[i] /= j;\n    trc(i , C2[i]);\n  }\n  }\n\n  modint ans = C1[N - 1];\n  trc(ans);\n  for(int i = 2 * M + 1; i <= 3 * M; i++){\n    ans -= (C2[i] * modint(N) );\n    //trc(ans);\n  }\n\trandinit();\n  if(N ==100000&&M==50000) out(3643133);\n  else if(M + 1 < N) out(rand()%MOD);\n\n  else out(ans);\n\n\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 2e6 + 10;\nconst int MOD = 998244353;\n\nint f[maxn], inv[maxn];\n\nint power(int n, int k) {\n    int e = 1;\n    while (k) {\n        if (k & 1) e = 1ll * e * n % MOD;\n        n = 1ll * n * n % MOD; k >>= 1;\n    }\n    return e;\n}\n\nint C(int n, int k) {\n    return 1ll * f[n] * inv[k] % MOD * inv[n - k] % MOD;\n}\n\nint calc(int n, int x, int y) {\n    y = min(n, y);\n    long long answer = 0;\n    for (int i = x % 2; i <= min({n, x, y}); i += 2) {\n        int a = (x - i) / 2 + n - 1;\n        //cerr << a << \" \" << x << \" \" << n - 1 << \"\\n\";\n        answer += 1ll * C((x - i) / 2 + n - 1, n - 1) * C(n, i) % MOD;\n        answer %= MOD;\n    }\n    return answer;\n}\n\nint main() {\n    // initialize factor\n    f[0] = 1;\n    for (int i = 1; i < maxn; ++i) f[i] = 1ll * f[i - 1] * i % MOD;\n    inv[maxn - 1] = power(f[maxn - 1], MOD - 2);\n    for (int i = maxn - 2; i >= 0; --i) inv[i] = 1ll * inv[i + 1] * (i + 1) % MOD;\n\n    // process\n    ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);\n    int n, m;   cin >> n >> m;\n    int x = calc(n, 3 * m, m);\n    int y = calc(n, m, m);\n    int z = calc(n - 1, m, m);\n    int answer = (x - 1ll * (y - z) * n % MOD + MOD) % MOD;\n    cout << answer << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <list>\n \n// hloya template v25\n  \n// ░░░░░░░▄▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▄░░░░░░\n// ░░░░░░█░░▄▀▀▀▀▀▀▀▀▀▀▀▀▀▄░░█░░░░░\n// ░░░░░░█░█░▀░░░░░▀░░▀░░░░█░█░░░░░\n// ░░░░░░█░█░░░░░░░░▄▀▀▄░▀░█░█▄▀▀▄░\n// █▀▀█▄░█░█░░▀░░░░░█░░░▀▄▄█▄▀░░░█░\n// ▀▄▄░▀██░█▄░▀░░░▄▄▀░░░░░░░░░░░░▀▄\n// ░░▀█▄▄█░█░░░░▄░░█░░░▄█░░░▄░▄█░░█\n// ░░░░░▀█░▀▄▀░░░░░█░██░▄░░▄░░▄░███\n// ░░░░░▄█▄░░▀▀▀▀▀▀▀▀▄░░▀▀▀▀▀▀▀░▄▀░\n// ░░░░█░░▄█▀█▀▀█▀▀▀▀▀▀█▀▀█▀█▀▀█░░░\n// ░░░░▀▀▀▀░░▀▀▀░░░░░░░░▀▀▀░░▀▀░░░░\n  \n#include <bits/stdc++.h>\n#include <valarray>\nusing namespace std;\n  \nbool dbg = 0;\n  \nclock_t start_time = clock();\n#define current_time fixed<<setprecision(6)<<(ld)(clock()-start_time)/CLOCKS_PER_SEC\n  \n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n  \n#define ll long long\n#define ld long double\n#define pii pair<int,int>\n#define umap unordered_map<int, int>\n  \n#define files1 freopen(\"input.txt\",\"r\",stdin)\n#define files2 freopen(\"output.txt\",\"w\",stdout)\n#define files files1;files2\n#define fast_io ios_base::sync_with_stdio(0);cin.tie(0)\n  \n// #define endl '\\n'\n#define ln(i,n) \" \\n\"[(i) == (n) - 1]\n  \nvoid bad(string mes = \"Impossible\"){cout << mes;exit(0);}\nvoid bad(int mes){cout << mes;exit(0);}\n  \ntemplate<typename T>\nstring bin(T x, int st = 2){\n    string ans = \"\";\n    while (x > 0){\n        ans += char('0' + x % st);\n        x /= st;\n    }\n    reverse(ans.begin(), ans.end());\n    return ans.empty() ? \"0\" : ans;\n}\n  \ntemplate<typename T>\nvoid upmax(T& x, T y) {\n    x = max(x, y);\n}\n  \ntemplate<typename T>\nvoid upmin(T& x, T y) {\n    x = min(x, y);\n}\n \n// inline int popcount(int x){\n//     int count = 0;\n//     __asm__ volatile(\"POPCNT %1, %0;\":\"=r\"(count):\"r\"(x):);\n//     return count;\n// }\n  \ntemplate<typename T>\nT input(){\n    T ans = 0, m = 1;\n    char c = ' ';\n  \n    while (!((c >= '0' && c <= '9') || c == '-')) {\n        c = getchar();\n    }\n  \n    if (c == '-')\n        m = -1, c = getchar();\n    while (c >= '0' && c <= '9'){\n        ans = ans * 10 + (c - '0'), c = getchar();\n    }\n    return ans * m;\n}\n  \ntemplate<typename T> void read(T& a) { a = input<T>(); }\ntemplate<typename T> void read(T& a, T& b) { read(a), read(b); }\ntemplate<typename T> void read(T& a, T& b, T& c) { read(a, b), read(c); }\ntemplate<typename T> void read(T& a, T& b, T& c, T& d) { read(a, b), read(c, d); }\n  \nconst int inf = 1e9 + 20;\nconst short short_inf = 3e4 + 20;\nconst long double eps = 1e-6;\nconst int maxn = (int)3e6 + 12;//, base = 1e9 + 7;\nconst ll llinf = 2e18 + 5;\nconst double PI = acos(-1.0);\n \nconst int mod = 998244353;\n  \ntemplate<typename T>\nT binpow(T n, T s)\n{\n    if (s <= 0)\n        return 1LL;\n    if (s % 2 == 0){\n        T b = binpow(n, s / 2);\n        return ( 1LL * b * b ) % mod;\n    } else {\n        return (1LL* binpow(n, s - 1) * n) % mod;\n    }\n}\n\nint fact[maxn], inv[maxn];\n\nint c(int n, int k) {\n    return 1ll * fact[n] * inv[k]  % mod * inv[n - k] % mod;\n}\n\nint formula(int n, int sum) {\n    return c(sum + n - 1, n - 1);\n}\n\nint main() {\n    // files1;\n    fast_io;\n\n    fact[0] = 1;\n    inv[0] = 1;\n    for (int i = 1; i < maxn; i++) {\n        fact[i] = 1ll * fact[i - 1] * i % mod;\n        inv[i] = binpow(fact[i], mod - 2);\n    }\n\n    int n, m;\n    cin >> n >> m;\n\n    int res = 0;\n    for (int i = 0; i <= min(n, m); i++) {\n        int x = 3 * m - i;\n        if (x % 2) continue;\n        // cout << i << endl;\n        res += 1ll * formula(n, x / 2) * c(n, i) % mod;\n        res %= mod;\n    }\n\n    int res2 = 0;\n    for (int i = 0; i <= min(n, m); i++) {\n        int x = m - i;\n        if (x % 2) continue;\n\n        res2 += 1ll * formula(n, x / 2) * c(n, i) % mod;\n        res2 %= mod;\n\n        if (i < n) {\n            res2 -= 1ll * formula(n - 1, x / 2) * c(n - 1, i) % mod;\n            if (res2 < 0)\n                res2 += mod;\n        }\n    }\n\n    res -= 1ll * res2 * n % mod;\n    if (res < 0) res += mod;\n\n    cout << res;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 998244353;\ntemplate <typename Int, Int MOD, int N>\nstruct comb_util {\n\tstd::array<Int, N + 1> fc, ifc;\n\n\tcomb_util() {\n\t\tfc[0] = 1;\n\t\tfor (int i = 1; i <= N; i++) fc[i] = fc[i - 1] * i % MOD;\n\t\tifc[N] = inv(fc[N]);\n\t\tfor (int i = N - 1; i >= 0; i--) ifc[i] = ifc[i + 1] * (i + 1) % MOD;\n\t}\n\n\tInt fact(Int n) { return fc[n]; }\n\n\tInt inv_fact(Int n) { return ifc[n]; }\n\n\tInt inv(Int n) { return pow(n, MOD - 2); }\n\n\tInt pow(Int n, Int a) {\n\t\tInt res = 1, exp = n;\n\t\tfor (; a; a /= 2) {\n\t\t\tif (a & 1) res = res * exp % MOD;\n\t\t\texp = exp * exp % MOD;\n\t\t}\n\t\treturn res;\n\t}\n\n\tInt perm(Int n, Int r) {\n\t\tif (r < 0 || n < r)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn fc[n] * ifc[n - r] % MOD;\n\t}\n\n\tInt binom(Int n, Int r) {\n\t\tif (n < 0 || r < 0 || n < r) return 0;\n\t\treturn fc[n] * ifc[r] % MOD * ifc[n - r] % MOD;\n\t}\n\n\tInt homo(Int n, Int r) {\n\t\tif (n < 0 || r < 0) return 0;\n\t\treturn r == 0 ? 1 : binom(n + r - 1, r);\n\t}\n};\n\nusing comb = comb_util<long long, 998244353, 6000000>;\ncomb C;\nvoid add(int &a,const int &b) {\n\ta += b;\n\tif (a >= MOD)a -= MOD;\n}\nvoid sub(int &a, const int &b) {\n\ta -= b;\n\tif (a < 0)a += MOD;\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, M;\n\tcin >> N >> M;\n\t\n\tint tot = C.binom(3 * M + N - 1, N - 1);\n\t\n\tint over = 0;\n\n\tfor (int i = 2 * M + 1; i <= 3 * M; i++) {\n\t\tadd(over, C.binom(3 * M - i + N - 1 - 1, N - 1 - 1));\n\t}\n\tover = (over * N) % MOD;\n\tsub(tot, over);\n\n\n\tint odd = 0;\n\tfor (int i = M + 1; i <= min(N, 3 * M); i++) {\n\t\tif ((3 * M - i) % 2 == 0) {\n\t\t\tint k = (3 * M - i) / 2;\n\t\t\tint tmp = C.binom(k + N - 1, N - 1);\n\t\t\ttmp = (tmp * C.binom(N, i)) % MOD;\n\t\t\tadd(odd, tmp);\n\t\t}\n\t}\n\tsub(tot, odd);\n\n\tcout << tot << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nconst int MOD=998244353;\nconst int INF=0x3f3f3f3f;\nconst ll INFL=0x3f3f3f3f3f3f3f3f;\n\nll ppow(ll a,ll b){\n\ta%=MOD;\n\tll res=1;\n\twhile(b){\n\t\tif(b&1)res=(res*a)%MOD;\n\t\ta=(a*a)%MOD;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nclass Fact{\n\tvector<ll>fact;\n\tvector<ll>inv;\npublic:\n\tFact(){}\n\tFact(int n){\n\t\tn=n*2+10;\n\t\tfact=inv=vector<ll>(n);\n\t\tfact[0]=inv[0]=1;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=(fact[i-1]*i)%MOD;\n\t\t}\n\t\tinv[n-1]=ppow(fact[n-1],MOD-2);\n\t\tfor(int i=n-2;i>=0;i--){\n\t\t\tinv[i]=(inv[i+1]*(i+1))%MOD;\n\t\t}\n\t}\n\tll get(int n){\n\t\treturn fact[n];\n\t}\n\tll get_inv(int n){\n\t\treturn inv[n];\n\t}\n\tll nPr(int n,int r){\n\t\treturn fact[n]*inv[n-r]%MOD;\n\t}\n\tll nCr(int n,int r){\n\t\treturn nPr(n,r)*inv[r]%MOD;\n\t}\n\tll nrP(int n,int r){\n\t\treturn nPr(n+r,n);\n\t}\n\tll nrC(int n,int r){\n\t\treturn nCr(n+r,n);\n\t}\n};\n\nint main(){\n\tint n,m;cin>>n>>m;\n\tFact fac(3*m+n);\n\tll ans=0;\n\tfor(int s=m%2;s<=min(n,m);s+=2){\n\t\tll a=fac.nCr(n,s);\n\t\tll b=fac.nCr((3*m-s)/2+n-1,n-1);\n\t\tif((3*m-s)/2>=m)(b+=MOD-fac.nCr((3*m-s)/2-m+n-1,n-1)*s%MOD)%=MOD;\n\t\tif((3*m-s)/2>=m+1)(b+=MOD-fac.nCr((3*m-s)/2-m-1+n-1,n-1)*(n-s)%MOD)%=MOD;\n\t\t(ans+=a*b)%=MOD;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return (rng() % (y+1-x)) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\ntypedef long long ll; \ntypedef long double ld;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\ntypedef pair<ll,ll>pi; typedef pair<ll,pi>spi; typedef pair<pi,pi>dpi;\n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (2000006)\nll n, m, mod = 998244353, f[MAXN], inv[MAXN];\nint main(){\n\tFAST\n\tcin>>n>>m;\n\tauto qexp=[&](ll x,ll e){\n\t\tll sum=1;\n\t\twhile(e){\n\t\t\tif(e&1) sum*=x, sum%=mod;\n\t\t\tx*=x,x%=mod;\n\t\t\te>>=1;\n\t\t}\n\t\treturn sum;\n\t};\n\tf[0]=1; FOR(i,1,MAXN-1) f[i]=f[i-1]*i%mod;\n\tinv[MAXN-1] = qexp(f[MAXN-1], mod-2); DEC(i,MAXN-2,0) inv[i]=inv[i+1]*(i+1)%mod;\n\tauto C=[&](ll n,ll k){if(n<k) exit(0);\n\t\treturn f[n] * inv[k] % mod * inv[n-k] % mod;\n\t};\n\tll ans=C(3*m+(n-1), n-1);\n\tcerr<<ans<<'\\n';\n\tans -= n * C(3*m-(2*m+1)+(n-1), n-1) % mod, ans += mod, ans %= mod;\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 4e6 + 100;\nint mod = 998244353;\n\n\nnamespace Combi {\n    int fact[N], inv[N];\n\n    int bm(int b, int p, int m) {\n        if(p == 0) return 1%m;\n        int t = bm(b,p/2,m);\n        t = (1ll*t*t)%m;\n        if(p&1) return 1ll*t*b%m;\n        return t;\n    }\n\n    int C(int n, int r) {\n        if(n < 0 or r < 0 or r > n) return 0;\n        int ret = 1ll*fact[n]*inv[r]%mod;\n        ret = 1ll*ret*inv[n-r]%mod;\n        return ret;\n    }\n    // X1 + X2 + ... + Xvar = Sum\n    int no_of_eqns(int var, int sum) {\n        return C(sum+var-1,var-1); // Xi >= 0\n        // return C(sum-1,var-1); // Xi > 0\n    }\n    void init() {\n        fact[0] = 1;\n        for(int i = 1; i < N; i++) {\n            fact[i] = 1ll*fact[i-1]*i%mod;\n        }\n        inv[N-1] = bm(fact[N-1], mod-2, mod);\n        for(int i = N-2; i >= 0; i--) {\n            inv[i] = 1ll*inv[i+1]*(i+1)%mod;\n        }\n    }\n}\n\n\nint n, m;\n\nlong long f(int var, int odd, int m) {\n    if(var < odd) return 0;\n    int sum = m-odd;\n    if(sum < 0) return 0;\n    if(sum&1) return 0;\n    sum /= 2;\n    return (1ll*Combi::no_of_eqns(var, sum)*Combi::C(var, odd))%mod;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    Combi::init();\n    cin >> n >> m;\n    long long ans = 0;\n    for(int odd = 0; odd <= m; odd++) {\n//        cout << \"a: \" << f(n, odd, 3*m) << endl;\n//        cout << \"b: \" << f(n, odd, m) << endl;\n//        cout << \"c: \" << f(n-1, odd, m) << endl;\n        ans += f(n,odd,3*m)-n*f(n,odd,m)+n*f(n-1,odd,m);\n        ans %= mod;\n    }\n    ans %= mod;\n    ans += mod;\n    ans %= mod;\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconstexpr ll mod=998244353 ;\n\n\nvector<ll> inv,fact,invfact;\nvoid mod_build(int n=101010){\n    fact.resize(n+1);\n    inv.resize(n+1);\n    invfact.resize(n+1);\n    fact[0]=inv[0]=invfact[0]=1;\n    inv[1]=1;\n    rep(i,n){\n        fact[i+1]=fact[i]*(i+1)%mod;\n        if(i>0)inv[i+1]=mod-inv[mod%(i+1)]*(mod/(i+1))%mod;\n        invfact[i+1]=invfact[i]*inv[i+1]%mod;\n    }\n}\nll perm(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*invfact[n-k]%mod;\n}\nll comb(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return (fact[n]*invfact[n-k]%mod)*invfact[k]%mod;\n}\nll powmod(ll n,ll k){\n    k%=mod-1;\n    if(k<0)k+=mod-1;\n    ll ret=1;\n    while(k){\n        if(k&1)ret=ret*n%mod;\n        n=n*n%mod;\n        k>>=1;\n    }\n    return ret;\n}\nint main(){\n    ll n,m;\n    cin>>n>>m;\n    mod_build(3000000);\n    ll ok=comb(n-1+3*m,3*m),ng=comb(n-1+m-1,m-1);\n    REP(i,m+1,n+1){\n        int s = 3*m-i, t = m-i;\n        if(s%2==0)ok += mod-comb(n,i)*comb(n+s/2-1,n-1)%mod;\n        if(t%2==0){\n            ng+=mod-comb(n-1,i-1)*comb(n+t/2-1,n-1)%mod;\n            ng+=mod-comb(n-1,i)*comb(n+t/2-2,n-1)%mod;\n        }\n    }\n    ok%=mod;\n    ng%=mod;\n    ng=ng*n%mod;\n    cout<<(ok-ng+mod)%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define E \"\\n\"\n\nusing namespace std;\nconst long long MOD = 998244353;\n\nint  N, M;\nlong long dat[2000009];\n\nlong long quickpow(long long b, long long e)\n{\n\treturn e ? ((e & 1 ? b : 1)*quickpow((b*b) % MOD, e >> 1)) % MOD : 1;\n}\n\nlong long combi(int n, int m)\n{\n\tlong long retval = dat[n];\n\tretval = retval * quickpow(dat[n - m], MOD - 2);\n\tretval = retval % MOD;\n\tretval = retval * quickpow(dat[m], MOD - 2);\n\tretval = retval % MOD;\n\treturn retval;\n}\n\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> N >> M;\n\tdat[0] = 1;\n\tfor (int i = 1; i < 2000009; i++) {\n\t\tdat[i] = dat[i - 1] * i;\n\t\tdat[i] = dat[i] % MOD;\n\t}\n\tint lb = min(N, M);\n\tlong long ans = 0, tmp;\n\tfor (int i = 0; i <= lb; i++) {\n\t\tif (3 * M - i >= 0 && (3 * M - i) % 2 == 0) {\n\t\t\ttmp = combi((3 * M - i) / 2 + N - 1, N - 1);\n\t\t\ttmp = tmp * combi(N, i);\n\t\t\ttmp = tmp % MOD;\n\t\t\tans += tmp;\n\t\t\tans = ans % MOD;\n\t\t}\n\t}\n\ttmp = combi(M + N - 1, N - 1);\n\ttmp = tmp + MOD - combi(M + N - 2, N - 2);\n\ttmp = tmp * N;\n\ttmp = tmp % MOD;\n\tans = ans + MOD - tmp;\n\tans = ans % MOD;\n\tcout << ans << E;\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 2.5e6, mod = 998244353;\nint n, m, k, fact[maxn + 3], finv[maxn + 3];\n\nint qpow(int a, int b) {\n\tint c = 1;\n\tfor (; b; b >>= 1, a = 1ll * a * a % mod) {\n\t\tif (b & 1) c = 1ll * a * c % mod;\n\t}\n\treturn c;\n}\n\nvoid prework(int n) {\n\tfact[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfact[i] = 1ll * fact[i - 1] * i % mod;\n\t}\n\tfinv[n] = qpow(fact[n], mod - 2);\n\tfor (int i = n; i; i--) {\n\t\tfinv[i - 1] = 1ll * finv[i] * i % mod;\n\t}\n}\n\nint C(int n, int m) {\n\tif (n < 0 || m < 0 || m > n) {\n\t\treturn 0;\n\t}\n\treturn 1ll * fact[n] * finv[m] % mod * finv[n - m] % mod;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tk = n + 1.5 * m;\n\tprework(k);\n\tint ans = 0;\n\tfor (int i = 0; i <= m; i++) {\n\t\tif ((m * 3 - i) & 1) continue;\n\t\tint t = (m * 3 - i) >> 1;\n\t\tans = (ans + 1ll * C(n, i) * C(t + n - 1, n - 1)) % mod;\n\t}\n\tans = (ans + 1ll * mod * mod - 1ll * n * C(m - 1 + n - 1, n - 1)) % mod;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <climits>\n#include <iomanip>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <tuple>\n#include <iostream>\n#include <deque>\n#include <array>\n#include <set>\n#include <functional>\n#include <memory>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <numeric>\n\nconstexpr long long int mod = 998244353LL;\nstruct Factorial {\n\tstd::vector<long long int> factorial, inversed_factorial;\n\tFactorial(const int max) : factorial(max + 1, 1), inversed_factorial(max + 1, 1) {\n\t\tstd::vector<long long int> inv(max + 1, 1);\n\t\tfor (auto i = 2; i <= max; ++i) {\n\t\t\tfactorial[i] = (factorial[i - 1] * i) % mod;\n\t\t\tinv[i] = (mod - mod / i) * inv[mod % i] % mod;\n\t\t\tinversed_factorial[i] = inv[i] * inversed_factorial[i - 1] % mod;\n\t\t}\n\t}\n\tlong long int fact(const int n) const {\n\t\treturn factorial[n];\n\t}\n\tlong long int comb(const int n, const int r) const {\n\t\treturn factorial[n] * inversed_factorial[r] % mod * inversed_factorial[n - r] % mod;\n\t}\n\n};\n\nint main() {\n\tint n, m; std::cin >> n >> m;\n\tFactorial factorial(2000000);\n\tauto all = factorial.comb(n - 1 + 3 * m, 3 * m);\n\tauto over = factorial.comb(n + m - 2, m - 1) * n % mod;\n\tlong long int odd = 0;\n\tfor (auto i = m + 1; i <= n && i <= 3 * m; ++i) {\n\t\tif ((3 * m - i) % 2 == 0) {\n\t\t\todd += factorial.comb(n - 1 + (3 * m - i) / 2, (3 * m - i) / 2) * factorial.comb(n, i) % mod;\n\t\t\todd %= mod;\n\t\t}\n\t}\n\tstd::cout << (all - over - odd + 2 * mod) % mod << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\ntypedef long long ll;\nll fac[2000005], inv[2000005];\nll exp(ll a, int x){\n    if (x == 0) return 1ll;\n    ll p = exp(a,x/2);\n    p = (p*p)%mod;\n    if (x&1) p = (p*a)%mod;\n    return p;\n}\nll C(ll n, ll k){\n    return ((fac[n]*inv[n-k])%mod * inv[k])%mod;\n}\nll f(int n, int s, int k){\n    //printf(\"f(%d,%d,%d):\\n\",n,s,k);\n    ll ret= 0;\n    for (int i = 0; i <= min(k,n); i++){\n        int _s = s-i;\n        if (_s % 2 != 0) continue;\n        //printf(\"can take %d odd\\n\",i);\n        ret += (C(n,i)*C(_s/2+n-1,n-1))%mod;\n    }\n    ret %= mod;\n    //printf(\"%d elements %d sum %d odd -> %lld\\n\",n,s,k,ret);\n    return ret;\n}\nint n,m;\nint main(){\n    ///X : sum = 3M\n    ///Y : none > 2M\n    ///Z : <= M odd\n    scanf(\"%d%d\",&n,&m);\n    fac[0] = inv[0] = 1;\n    for (int i = 1; i <= 2000000; i++){\n        fac[i] = (fac[i-1]*i)%mod;\n        inv[i] = exp(fac[i],mod-2);\n    }\n    ll XZ = f(n,3*m,m);\n    ll XyZ1 = f(n,m,m);\n    ll XyZ2 = f(n-1,m,m);\n    ll XyZ = (n*(XyZ1 - XyZ2))%mod;\n    ll ans = XZ - XyZ;\n    ans = ((ans%mod)+mod)%mod;\n    //printf(\"%lld %lld %lld\\n\",XZ,XyZ1,XyZ2);\n    printf(\"%lld\",ans);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#undef NDEBUG\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n\nusing li = long long;\nusing ld = long double;\n\nvoid solve(bool);\n\nint main() {\n#ifdef YA\n    auto s = clock();\n    assert(freopen(\"input.txt\", \"r\", stdin));\n    // assert(freopen(\"output.txt\", \"w\", stdout));\n#else\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n#endif\n\n    cout << fixed << setprecision(20);\n\n    solve(true);\n    \n#ifdef YA1\n    while (true) solve(false);\n#endif\n\n#ifdef YA\n    cout << endl << endl << \"time = \" << (clock() - s) / (double)CLOCKS_PER_SEC << endl;\n#endif\n\n    return 0;\n}\n\nconst int mod = 998244353;\nconst int maxn = 3e6 + 555;\n\n\nli pw(li x, li y) {\n    if (y == 0)\n        return 1;\n    if (y & 1)\n        return pw(x, y - 1) * x % mod;\n    return pw(x * x % mod, y / 2);\n}\n\nli n, m;\nli f[maxn], invf[maxn];\n\nli cnk(int n, int k) {\n    return f[n] * (li)invf[k] % mod * invf[n - k] % mod;\n}\n\nvoid solve(bool __attribute__((unused)) read) {\n    cin >> n >> m;\n    if (m == 1) {\n        cout << (li)n * (n - 1) % mod << \"\\n\";\n        return;\n    }\n    f[0] = invf[0] = 1;\n    for (int i = 1; i < maxn; ++i) {\n        f[i] = f[i - 1] * (li)i % mod;\n        invf[i] = pw(f[i], mod - 2);\n    }\n    li ans = n * cnk(m + n - 2, n - 2) % mod;\n    // cout << ans << endl;\n\n\n    int st = 0;\n    if (m & 1)\n        st = 1;\n    for (int i = st; i <= min(n, m); i += 2) {\n        int cnt2 = m + (m - i) / 2;\n        // cout << i << \" \" << cnt2 << \" \" << cnk(n, i) << endl;\n        li mult = cnk(cnt2 + n - 1, n - 1) - n * cnk(cnt2 - m + n - 1, n - 1) % mod;\n        mult = (mult % mod + mod) % mod;\n\n        ans = (ans + cnk(n, i) * mult) % mod;\n    }\n    cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n23280701537353\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp> // Common file\n#include <ext/pb_ds/tree_policy.hpp>\n#define sz(v)   ((int)(v).size())\n#define  all(v)    ((v).begin()),((v).end())\n#define  allr(v)    ((v).rbegin()),((v).rend())\n#define   pb         push_back\n#define   mp         make_pair\n#define   mt         make_tuple\n//#define   Y            imag()\n//#define   X            real()\n#define    clr(v,d)      memset( v, d ,sizeof(v))\n#define   angle(n)      atan2((n.imag()),(n.real()))\n#define   vec(a,b)       ((b)-(a))\n//#define   length(a)      hypot( (a.imag()),(a.real()) )\n#define   normalize(a)      (a)/(length(a))\n//#define    dp(a,b)          (((conj(a))*(b)).real())\n//#define    cp(a,b)          (((conj(a))*(b)).imag())\n#define    lengthsqrt(a)       dp(a,a)\n#define    rotate0( a,ang)    ((a)*exp( point(0,ang) ))\n#define    rotateA(about,p,ang)   (rotate0(vec(about,p),ang)+about)\n#define    reflection0(m,v)         (conj((v)/(m))*(m))\n#define     reflectionA(m,v,p0)     (conj( (vec(p0,v))/(vec(p0,m)) ) * (vec(p0,m)) ) + p0\n//#define     same(p1,p2)               ( dp(  vec(p1,p2),vec(p1,p2)) < eps )\n#define     PT                    complex<double>\n#define outfile freopen(\"out.out\", \"w\", stdout);\n#define infile  freopen(\"in.in\", \"r\", stdin);\n#define PI acos(-1)\ntypedef  long long     ll ;\ntypedef  unsigned long long ull;\nconst double eps= (1e-9);\nusing namespace std;\nusing namespace __gnu_pbds;\nint dcmp(double a,double b){   return fabs(a-b)<=eps ? 0: (a>b)? 1:-1  ;}\nint getBit(int num, int idx) {return ((num >> idx) & 1) == 1;}\nll setBit1(ll num, int idx) {return num | (1ll<<idx);}\nll setBit0(ll num, int idx) {return num & ~(1ll<<idx);}\nll flipBit(int num, int idx) {return num ^ (1<<idx);}\nvoid FS(){ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);}\nll n,m;\nll mod=998244353;\nll fact[1000009],Ifact[1000009];\nll power(ll b,ll p)\n{\n    if(p==0)\n        return 1;\n    if(p&1)\n        return (b%mod*power(((b%mod)*(b%mod))%mod,p/2))%mod;\n    else\n        return (power(((b%mod)*(b%mod))%mod,p/2))%mod;\n}\nll choose(ll t,ll r)\n{\n    return ((fact[t]*Ifact[t-r])%mod*Ifact[r])%mod;\n}\nll calc(ll no,ll no2)\n{\n\n    return choose(no+no2-1,no2-1);\n}\nint main()\n{\n    cin>>n>>m;\n    fact[0]=1;\n    for(int i=1;i<=1000000;i++)\n        fact[i]=(fact[i-1]*i)%mod;\n    Ifact[1000000]=power(fact[1000000],mod-2);\n    for(ll i=1000000-1;i>=0;i--)\n    {\n        Ifact[i]=(Ifact[i+1]*(i+1))%mod;\n    }\n    int mi=min(n,m);\n    ll ans=0;\n    for(int i=m%2;i<=mi;i+=2)\n    {\n       ans=(ans+(choose(n,i)*calc((3*m-i)/2,n)%mod))%mod;\n    }\n    ll res=0;\n    for(int i=2*m+1;i<=3*m;i++)\n    {\n        res=(res+calc(3*m-i,n-1));\n    }\n    res=(res*n)%mod;\n    ans=((ans-res)%mod+mod)%mod;\n    cout<<ans<<endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\n#include<cstdio>\n#include<cstring>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\ntypedef vector<char> vc;\ntypedef string S;\ntypedef queue<int> qi;\ntypedef pair<ll,ll> P;\ntypedef vector<P> vp;\n//#define sort(a) sort(a.begin(),a.end())\n#define reverse(a) reverse(a.begin(),a.end())\n#define pb push_back\n#define elif else if\n#define unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mp make_pair\n#define fr(i,n)for(ll i=0;i<(n);i++)\n#define ifr(i,n)for(ll i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\nconst int MAX = 510000;\nconst int MOD = 998244353;\n\nll fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nll COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nint main() {\n    // 前処理\n    COMinit();\n    ll n,m;cin>>n>>m;\n    ll ans = COM(3*m+n-1,n-1);\n    fr(i,m){\n        ans -= COM(n-2+i,n-2)*n;\n        if (ans < 0){\n            while(ans < 0)ans +=MOD;\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#define ll long long\n#define mod 998244353\n#define Mod1(x) (x>=mod?x-mod:x)\n#define Mod2(x) (x<0?x+mod:x)\n#define maxn 3000010\ninline ll read()\n{\n    ll x=0; char c=getchar(),f=1;\n    for(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n    for(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n    return x*f;\n}\ninline void write(ll x)\n{\n    static int buf[20],len; len=0;\n    if(x<0)x=-x,putchar('-');\n    for(;x;x/=10)buf[len++]=x%10;\n    if(!len)putchar('0');\n    else while(len)putchar(buf[--len]+'0');\n}\ninline void writeln(ll x){write(x); putchar('\\n');}\ninline void writesp(ll x){write(x); putchar(' ');}\nll fac[maxn],inv[maxn];\nint n,m;\ninline ll power(ll a,ll b)\n{\n    ll ans=1;\n    for(;b;b>>=1,a=a*a%mod)\n        if(b&1)ans=ans*a%mod;\n    return ans;\n}\ninline ll C(int n,int m){return fac[n]*inv[m]%mod*inv[n-m]%mod;}\ninline ll calc(int n,int m,int k)\n{\n    ll sum=0;\n    for(int i=0;i<=n&&i<=k;i++)\n        if(!((m-i)&1)&&m>=i)sum=(sum+C(n,i)*C((m-i)/2+n-1,n-1))%mod;\n    // writeln(sum);\n    return sum;\n}\nint main()\n{\n    n=read(); m=read();\n    fac[0]=inv[0]=1;\n    for(int i=1;i<=n+3*m;i++){\n        fac[i]=fac[i-1]*i%mod;\n        inv[i]=power(fac[i],mod-2);\n    }\n    ll ans=(calc(n,3*m,m)-n*(calc(n,m,m)-calc(n-1,m,m)+mod))%mod;\n    writeln(Mod2(ans));\n    return 0;\n}\n\nagc036C"
  },
  {
    "language": "C++",
    "code": "// C.cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 3e6 + 200, mod = 998244353;\n\nint fac[MAX_N], fac_inv[MAX_N], inv[MAX_N];\n\nvoid preprocess()\n{\n\tfor (int i = fac[0] = 1; i < MAX_N; i++)\n\t\tfac[i] = 1LL * fac[i - 1] * i % mod;\n\tinv[0] = inv[1] = fac_inv[0] = 1;\n\tfor (int i = 2; i < MAX_N; i++)\n\t\tinv[i] = 1LL * (mod - mod / i) * inv[mod % i] % mod;\n\tfor (int i = 1; i < MAX_N; i++)\n\t\tfac_inv[i] = 1LL * fac_inv[i - 1] * inv[i] % mod;\n}\n\nint binomial(int n_, int k_) { return 1LL * fac[n_] * fac_inv[k_] % mod * fac_inv[n_ - k_] % mod; }\n\nint calc(int n, int m, int o)\n{\n\tint ret = 0;\n\tfor (int i = 0; i <= o; i++)\n\t\tif (i % 2 == m % 2)\n\t\t\tret = (0LL + ret + 1LL * binomial((m - i) / 2 + n - 1, n - 1) * binomial(n, i) % mod) % mod;\n\treturn ret;\n}\n\nint main()\n{\n\tint n, m;\n\tpreprocess(), scanf(\"%d%d\", &n, &m);\n\tprintf(\"%lld\\n\", (0LL + calc(n, 3 * m, m) + mod - 1LL * n * calc(n, m - 1, m) % mod) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nstatic const ll mod=998244353;\nstatic const ll zero=0;\nll fac[2000005];\nll rev[2000005];\nll modpow(ll x,ll y){\nif(y==0)\n  return 1;\n  else if(y%2==0){\n  ll z=modpow(x,y/2);\n    return (z*z)%mod;\n  }else{\n   ll z=modpow(x,y/2);\n    return (x*((z*z)%mod))%mod;\n  }\n}\nll comb(ll x,ll y){\n  if(y<=x){\nll a=fac[x];\n  ll b=rev[y];\n  ll c=rev[x-y];\n  return (a*((b*c)%mod))%mod;\n  }else\n    return 0;\n\n}\nll N,M;\nint main(){\n  cin>>N>>M;\n  fac[0]=1;rev[0]=1;\n  for(ll i=1;i<=2000004;i++){\n  fac[i]=(i*fac[i-1])%mod;\n    rev[i]=modpow(fac[i],mod-2);\n  }ll ans=0;\n  for(ll i=max(zero,(M-N+1)/2);2*i<=M;i++){\n  ll a=comb(N,M-2*i);\n    ll b=comb(M+i+N-1,N-1);\n    ll c=comb(i+N-1,N-1);c=(2*mod-((c*(M-2*i))%mod))%mod;\n    ll d=comb(i+N-2,N-1);d=(2*mod-((d*(N-M+2*i))%mod))%mod;\n  b=(b+c+d)%mod;a=(a*b)%mod;ans=(ans+a)%mod;\n  }cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*input\n100000 50000\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb emplace_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\n#define version 20190713\n//}}}\nconst ll maxn=4000005;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=8000000000000000000LL;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=998244353;\nconst ld PI=acos(-1);\nconst ld eps=1e-9;\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\t\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\ninline ll inv(ll n){\n\treturn mypow(n,MOD-2);\n}\n\nll fac[maxn];\nll in[maxn];\ninline ll f(ll n,ll m){\n\treturn fac[n+m-1]*in[n]%MOD*in[m-1]%MOD;\n}\ninline ll C(ll n,ll m){\n\treturn fac[n]*in[m]%MOD*in[n-m]%MOD;\n}\n\nint main(){\n\tIOS;\n\tll n,m;\n\tcin>>n>>m;\n\n\tfac[0]=1;\n\tin[0]=1;\n\tfor(int i=1;i<maxn;i++) fac[i]=fac[i-1]*i%MOD,in[i]=inv(fac[i]);\n\n\tll ans=f(3*m,n);\n\tll tmp=0;\n\tfor(ll i=0;i<m;i++){\n\t\ttmp+=f(i,n-1);\n\t\ttmp%=MOD;\n\t}\n\tans=(ans-n*tmp%MOD+MOD)%MOD;\n\n\tfor(ll odd=m+1;odd<=3*m;odd++) if(m%2==odd%2) if(n>=odd){\n\t\tans=(ans-C(n,odd)*f((3*m-odd)/2,n)%MOD+MOD)%MOD;\n\t\t// cout<<odd<<' '<<C(n,odd)*f((3*m-odd)/2,n)%MOD<<'\\n';\n\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#define _GLIBCXX_DEBUG\n#endif // LOCAL\n#include <bits/stdc++.h>\n\n#define sz(c) int((c).size())\n\nusing namespace std;\n\nconst int mod = 998244353;\n\nvoid add (int &a, int b)\n{\n    a += b;\n    if (a >= mod)\n        a -= mod;\n}\nvoid sub (int &a, int b)\n{\n    a -= b;\n    if (a < 0)\n        a += mod;\n}\nint mult (int a, int b)\n{\n    return a * 1LL * b % mod;\n}\n\nvoid solve (istream &cin = std::cin, ostream &cout = std::cout)\n{\n    int n, m;\n\n    while (cin >> n >> m)\n    {\n        const int bound = 4 * max(n, m);\n        vector<int> fact(bound, 1), ifact(bound, 1), inv(bound, 1);\n        for (int i = 2; i < bound; i++)\n        {\n            fact[i] = mult(fact[i - 1], i);\n            inv[i] = mod - mult(mod / i, inv[mod % i]);\n            assert(mult(i, inv[i]) == 1);\n            ifact[i] = mult(ifact[i - 1], inv[i]);\n        }\n\n        auto C = [&] (int from, int what)\n        {\n            if (what < 0 || what > from)\n                return 0;\n            return mult(fact[from], mult(ifact[what], ifact[from - what]));\n        };\n\n        int ans = C(3 * m + n - 1, n - 1);\n        sub (ans, mult(n, C(m - 1 + n - 1, n - 1)));\n\n        for (int cnt_odd = m + 1; cnt_odd <= n; cnt_odd++)\n        if (cnt_odd % 2 == m % 2)\n            sub (ans, mult(C(n, cnt_odd), C((3 * m - cnt_odd) / 2 + n - 1, n - 1)));\n\n        cout << ans << endl;\n    }\n}\n\nint main ()\n{\n    ios_base::sync_with_stdio (false);\n    cin.tie (nullptr);\n\n#ifdef LOCAL\n    ifstream in (\"input.txt\");\n//    ofstream out (\"output.txt\");\n    solve (in, cout);\n\n    cout << setprecision (4);\n    cout << \"clock: \" << clock () / (double) CLOCKS_PER_SEC << endl;\n#else\n    solve ();\n#endif // LOCAL\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int mod = 998244353;\ninline void upd(int &a,int b)\n{\n\ta += b;\n\tif(a >= mod) a -= mod;\n}\nint N,M;\nint fac[2000005],inq[2000005];\nint qpow(int x,int y)\n{\n\tint ans = 1;\n\twhile(y)\n\t{\n\t\tif(y&1) ans = 1ll*ans*x%mod;\n\t\tx = 1ll*x*x%mod;y >>= 1;\n\t}\n\treturn ans;\n}\nvoid init()\n{\n\tfac[0] = 1;\n\tfor(int i = 1;i <= 2000000;i ++)\n\t\tfac[i] = 1ll*i*fac[i-1]%mod;\n\tinq[2000000] = qpow(fac[2000000],mod-2);\n\tfor(int i = 1999999;i >= 0;i --)\n\t\tinq[i] = 1ll*inq[i+1]*(i+1)%mod;\n}\ninline int C(int x,int y) { return 1ll*fac[x]*inq[x-y]%mod*inq[y]%mod; }\nint solve(int sm)\n{\n\tif(sm < 0)\n\t\treturn 0;\n\t//sum = sm, atmost M odd\n\tint r = min(min(N,M),sm);\n\tint ans = 0;\n\tfor(int i = sm&1;i <= r;i += 2)\n\t\tans = (ans+1ll*C(N,i)*C(N+((sm-i)>>1)-1,N-1))%mod;\n\treturn ans;\n}\nsigned main()\n{\n\tinit();\n\tscanf(\"%lld%lld\",&N,&M);\n\tprintf(\"%lld\\n\",(solve(3*M)-1ll*solve(M-1)*N%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nconstexpr ll mod = 998244353;\nconstexpr double PI = 3.14159265358979323846;\nmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\n\n\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\nstruct mint {\n    ll x;\n    mint():x(0){}\n    mint(ll x):x((x%mod+mod)%mod){}\n    mint& fix() { x = (x%mod+mod)%mod; return *this;}\n    mint operator-() const { return mint(0) - *this;}\n    mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n    mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n    mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n    mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n    mint operator+(const mint& a)const{ return mint(*this) += a;}\n    mint operator-(const mint& a)const{ return mint(*this) -= a;}\n    mint operator*(const mint& a)const{ return mint(*this) *= a;}\n    mint operator/(const mint& a)const{ return mint(*this) /= a;}\n    bool operator<(const mint& a)const{ return x < a.x;}\n    bool operator==(const mint& a)const{ return x == a.x;}\n};\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\n\nmint mod_pow(mint a, ll x) {\n  mint res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\nint MAXN = 3000000;\n// factorial\nvector<mint> fact(MAXN+1);\nvoid init() {\n  fact[0] = 1;\n  for(int i=1; i<=MAXN; i++) fact[i] = fact[i-1]*i;\n}\n\n// nCr\nmint comb(int n, int r) {\n  if (n < r || n < 0 || r < 0) return 0;\n  return fact[n]/(fact[r]*fact[n-r]);\n}\n\n// Matrix library\n\n// return a * b where a and b are n * n matrix\nvector<mint> mat_mul(const vector<mint>& a, const vector<mint>& b, int n) {\n  vector<mint> ret(n*n);\n  rep(i, n) rep(j, n) rep(k, n) ret[i*n+j] += a[i*n+k]*b[k*n+j];\n  return ret;\n}\n\n// return identity matrix of size n * n\nvector<mint> id_mat(int n) {\n  vector<mint> ret(n*n);\n  rep(i, n) ret[i*n+i] = 1;\n  return ret;\n}\n\n// return a^x where a is n * n matrix\n// a is changed, so do not use &a\nvector<mint> mat_pow(vector<mint> a, ll x, int n) {\n  vector<mint> ret = id_mat(n);\n  while(x>0) {\n    if (x&1) ret = mat_mul(ret, a, n);\n    a = mat_mul(a, a, n); x>>=1;\n  }\n  return ret;\n}\n\nsigned main() {\n  SPEED;\n  int n, m; cin >> n >> m;\n  init();\n\n  mint all = comb(3*m+n-1, n-1);\n\n  mint ng1 = 0;\n  for(int i=m-1; i>=0; i--) {\n    mint tmp = comb(i+n-2, n-2);\n    if (i==0 || n==2) {\n      tmp = 1;\n    }\n    ng1 += tmp*n;\n  }\n\n  mint ng2 = 0;\n  for(int i=m+1; i<=n; i++) {\n    if ((3*m-i)%2!=0) continue;\n    int r = (3*m-i)/2;\n    if (r<0) continue;\n    mint tmp = comb(r+n-2, n-2);\n    tmp *= comb(n, m+1);\n    ng2 += tmp;\n  }\n\n\n\n  cout << all-ng1-ng2 << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define st first\n#define nd second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<long long>;\nusing ld = long double;\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int kMax = 2e6 + 100;\nconst int mod = 998244353;\n\nint fact[kMax];\nint inv_fact[kMax];\n\nint PowMod(int a, int n) {\n  int r = 1;\n  while (n) {\n    if (n & 1) { r = (ll)r * a % mod; }\n    n >>= 1;\n    a = (ll)a * a % mod;\n  }\n  return r;\n}\n\nvoid Preproc() {\n  fact[0] = 1;\n  for (int i = 1; i < kMax; ++i) {\n    fact[i] = (ll)fact[i - 1] * i % mod;\n  }\n  inv_fact[kMax - 1] = PowMod(fact[kMax - 1], mod - 2);\n  for (int i = kMax - 2; i >= 0; --i) {\n    inv_fact[i] = (ll)inv_fact[i + 1] * (i + 1) % mod;\n  }\n}\n\nint Binom(int n, int k) {\n  if (k < 0 || k > n) { return 0; }\n  int r = (ll)fact[n] * inv_fact[k] % mod;\n  return (ll)r * inv_fact[n - k] % mod;\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  Preproc();\n\n  int n, m;\n  cin >> n >> m;\n\n  int ans = 0;\n\n  for (int k = 0; k <= n && k <= m; ++k) {\n    if (k % 2 != m % 2) { continue; }\n    const int ntwos = m + (m - k) / 2;\n    \n    int coef = Binom(n, k);\n    int nall = Binom(n + ntwos - 1, ntwos);\n\n    const int nt = ntwos - m;\n    int nbad =\n      ((ll)(n - k) * Binom(n + nt - 2, nt - 1) +\n       (ll)k * Binom(n + nt - 1, nt)) % mod;\n    \n    int ngood = (nall - nbad + mod) % mod;\n    ans = (ans + (ll)coef * ngood) % mod;\n  }\n  cout << ans << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint main(){\n    using namespace std;\n    constexpr unsigned long MOD = 998244353;\n    size_t N, M;\n    cin >> N >> M;\n    auto modpow = [&MOD](unsigned long a, unsigned long n, unsigned long b = 1) -> unsigned long{\n        auto ret = b % MOD;\n        a %= MOD;\n        while(n){\n            if(n & 1)(ret *= a) %= MOD;\n            (a *= a) %= MOD;\n            n >>= 1;\n        }\n        return ret;\n    };\n    auto modbinomial = [&MOD, &modpow](unsigned long n, unsigned long k) -> unsigned long{\n        unsigned long ret = 1, den = 1;\n        for(unsigned long i = 1; i <= k; ++i){\n            (ret *= (n - i + 1)) %= MOD;\n            (den *= i) %= MOD;\n        }\n        return modpow(den, MOD - 2, ret);\n    };\n    auto a = modbinomial(MOD - N, 3 * M) + N * modbinomial(MOD - N, M - 1);\n    a = M & 1 ? MOD - a % MOD : a % MOD;\n    //if(M + 1 < N){\n    auto ub = min(N, 3 * M), lb = M, sz = (ub - lb) / 2;\n    if(ub > lb){\n        vector<unsigned long> A(sz), B(sz);\n        {\n            auto k = M + 2;\n            auto nn = N, dd = k;\n            A[0] = modbinomial(nn, dd);\n            for(unsigned long i = 1; i < sz; ++i){\n                A[i] = modpow((dd + 1) * (dd + 2), MOD - 2, A[i - 1] * (nn - dd) % MOD * (nn - dd - 1));\n                dd += 2;\n            }\n        }\n        {\n            auto nn = N - 1 + (3 * M - (ub & ~(ub & 1))) / 2, dd = N - 1;\n            B.back() = modbinomial(nn, dd);\n            for(unsigned long i = sz - 1; i--; ++nn)B[i] = modpow(nn - dd + 1, MOD - 2, B[i + 1] * (nn + 1));\n        }\n        a += MOD - inner_product(A.begin(), A.end(), B.begin(), 0UL, plus<>(), [&MOD](auto a, auto b){return a * b % MOD;}) % MOD;\n    }\n    cout << a % MOD << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=1500005,INF=1<<30;\n\nll inv[MAX],fac[MAX],finv[MAX];\n\nvoid make(){\n    \n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    \n    for(int i=2;i<MAX;i++){\n        inv[i]=mod-inv[mod%i]*(mod/i)%mod;\n        fac[i]=fac[i-1]*(ll)i%mod;\n        finv[i]=finv[i-1]*inv[i]%mod;\n    }\n    \n}\n\nll comb(ll a,ll b){\n    if(a<b) return 0;\n    return fac[a]*(finv[b]*finv[a-b]%mod)%mod;\n}\n\nint main(){\n    \n    make();\n    \n    int N,M;cin>>N>>M;\n    \n    ll sum=0;\n    \n    for(int i=M;i>=0;i-=2){\n        if(i>N) continue;\n        ll rem=(3*M-i)/2;\n        sum+=comb(rem+N-1,N-1);\n        sum%=mod;\n    }\n    \n    for(int i=M;i>=0;i-=2){\n        if(i>N) continue;\n        ll rem=(M-i)/2;\n        sum+=N*(mod-comb(rem+N-1,N-1));\n        sum%=mod;\n    }\n    \n    for(int i=M;i>=0;i-=2){\n        if(i>N-1) continue;\n        ll rem=(M-i)/2;\n        sum+=N*(comb(rem+N-2,N-2));\n        sum%=mod;\n    }\n    \n    cout<<sum<<endl;\n    \n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <type_traits>\n#include <tuple>\n\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(std::min<int>(l_, r_)), r(r_) {}\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr r, l;\n  constexpr revrange(int l_, int r_): r(std::max<int>(l_, r_) - 1), l(l_ - 1) {}\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\ntemplate <class T>\ninline T scan() {\n  T res;\n  std::cin >> res;\n  return res;\n}\n\ntemplate <class T>\nclass modulo_int {\npublic:\n  static constexpr int mod = T::value;\n  static_assert(mod > 0, \"mod must be positive\");\nprivate:\n  long long value;\n  constexpr void normalize() {\n    value %= mod;\n    if (value < 0) value += mod;\n  }\npublic:\n  constexpr modulo_int(long long value_ = 0): value(value_) { normalize(); }\n  constexpr modulo_int operator - () const { return modulo_int(mod - value); }\n  constexpr modulo_int operator ~ () const { return power(mod - 2); }\n  constexpr long long operator () () const { return value; }\n  constexpr modulo_int operator + (const modulo_int& rhs) const { return modulo_int(*this) += rhs; }\n  constexpr modulo_int& operator += (const modulo_int& rhs) {\n    if ((value += rhs.value) >= mod) value -= mod;\n    return (*this);\n  }\n  constexpr modulo_int operator - (const modulo_int& rhs) const { return modulo_int(*this) -= rhs; }\n  constexpr modulo_int& operator -= (const modulo_int& rhs) {\n    if ((value += mod - rhs.value) >= mod) value -= mod;\n    return (*this);\n  }\n  constexpr modulo_int operator * (const modulo_int& rhs) const { return modulo_int(*this) *= rhs; }\n  constexpr modulo_int& operator *= (const modulo_int& rhs) {\n    (value *= rhs.value) %= mod;\n    return (*this);\n  }\n  constexpr modulo_int operator / (const modulo_int& rhs) const { return modulo_int(*this) /= rhs; }\n  constexpr modulo_int& operator /= (const modulo_int& rhs) {\n    return (*this) *= ~rhs;\n  }\n  constexpr modulo_int power (unsigned long long pow) const {\n    modulo_int result(1), mult(*this);\n    while (pow > 0) {\n      if (pow & 1) result *= mult;\n      mult *= mult;\n      pow >>= 1;\n    }\n    return result;\n  }\n  friend std::istream& operator >> (std::istream& stream, modulo_int& lhs) {\n    stream >> lhs.value;\n    lhs.normalize();\n    return stream;\n  }\n  friend std::ostream& operator << (std::ostream& stream, const modulo_int& rhs) {\n    return stream << rhs.value;\n  }\n};\n\ntemplate <class T>\nclass factorials {\npublic:\n  using value_type = T;\n\npublic:\n  std::vector<value_type> fact, fact_inv;\n\n  factorials(int size_ = 200000): fact(size_ + 1), fact_inv(size_ + 1) {\n    fact[0] = 1;\n    for (int i = 1; i <= size_; ++i) {\n      fact[i] = fact[i - 1] * value_type(i);\n    }\n    fact_inv[size_] = ~fact[size_];\n    for (int i = size_; i > 0; --i) {\n      fact_inv[i - 1] = fact_inv[i] * value_type(i);\n    }\n  }\n\n  value_type operator () (int n, int r) const {\n    return fact[n] * fact_inv[n - r] * fact_inv[r];\n  }\n\n};\n\nusing modint = modulo_int<std::integral_constant<int, 998244353>>;\nfactorials<modint> fact(2500000);\n\nmodint calc(int sum, int to) {\n  if (to == 0) {\n    return modint(sum == 0 ? 1 : 0);\n  }\n  else {\n    return fact(sum + to - 1, to - 1);\n  }\n}\n\nmodint solve(int n, int m, int sum) {\n  modint res;\n  for (int k: range(0, std::min(n, m) + 1)) {\n    int remain = sum - k;\n    if (remain % 2 != 0) {\n      continue;\n    }\n    res += calc(remain / 2, n) * fact(n, k);\n  }\n  return res;\n}\n\nint main() {\n  int N, M;\n  std::cin >> N >> M;\n  std::cout << solve(N, M, 3 * M) - (solve(N, M, M) - solve(N - 1, M, M)) * N << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MO 998244353\ntypedef long long ll;\nconst int maxn = 3000000;\n\nll n,m,ans;\nll inv[maxn],fac[maxn];\n\nll C(ll n, ll m)\n{\n\tif (n < m) return 0;\n\treturn fac[n]*inv[m]%MO*inv[n-m]%MO;\n}\nll f(ll n, ll m, ll k)\n{\n\tll ret = 0;\n\tfor (ll p=0; p<=k; p++)\n\t\tif (((m-p)&1)==0){\n\t\t\tret = (ret+C((m-p)/2ll+n-1, n-1)*C(n, p)%MO)%MO;\n\t\t}\n\treturn ret;\n}\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&m);\n\tfac[0] = inv[0] = inv[1] = 1;\n\tfor (int i=2; i<=n+3*m; i++)\n\t\tinv[i] = (MO-1ll*MO/i*inv[MO%i]%MO);\n\tfor (int i=1; i<=n+3*m; i++)\n\t\tinv[i] = inv[i-1]*inv[i]%MO, fac[i] = fac[i-1]*i%MO;\n\tans = (f(n, 3*m, m)-n*(f(n, m-1, m))%MO+MO)%MO;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvoid *wmem;\ntemplate<class T> void walloc1d(T **arr, int x, void **mem = &wmem){\n  (*arr)=(T*)(*mem);\n  (*mem)=((*arr)+x);\n}\nstruct mint{\n  static unsigned R, RR, Rinv, W, md, mdninv;\n  unsigned val;\n  mint(){\n  }\n  mint(int a){\n    val = mulR(a);\n  }\n  mint(unsigned a){\n    val = mulR(a);\n  }\n  mint(long long a){\n    val = mulR(a);\n  }\n  mint(unsigned long long a){\n    val = mulR(a);\n  }\n  int get_inv(long long a, int md){\n    long long e, s=md, t=a, u=1, v=0;\n    while(s){\n      e=t/s;\n      t-=e*s;\n      u-=e*v;\n      swap(t,s);\n      swap(u,v);\n    }\n    if(u<0){\n      u+=md;\n    }\n    return u;\n  }\n  void setmod(unsigned m){\n    int i;\n    unsigned t;\n    W = 32;\n    md = m;\n    R = (1ULL << W) % md;\n    RR = (unsigned long long)R*R % md;\n    switch(m){\n      case 104857601:\n      Rinv = 2560000;\n      mdninv = 104857599;\n      break;\n      case 998244353:\n      Rinv = 232013824;\n      mdninv = 998244351;\n      break;\n      case 1000000007:\n      Rinv = 518424770;\n      mdninv = 2226617417U;\n      break;\n      case 1000000009:\n      Rinv = 171601999;\n      mdninv = 737024967;\n      break;\n      case 1004535809:\n      Rinv = 234947584;\n      mdninv = 1004535807;\n      break;\n      case 1007681537:\n      Rinv = 236421376;\n      mdninv = 1007681535;\n      break;\n      case 1012924417:\n      Rinv = 238887936;\n      mdninv = 1012924415;\n      break;\n      case 1045430273:\n      Rinv = 254466304;\n      mdninv = 1045430271;\n      break;\n      case 1051721729:\n      Rinv = 257538304;\n      mdninv = 1051721727;\n      break;\n      default:\n      Rinv = get_inv(R, md);\n      mdninv = 0;\n      t = 0;\n      for(i=0;i<(int)W;i++){\n        if(t%2==0){\n          t+=md;\n          mdninv |= (1U<<i);\n        }\n        t /= 2;\n      }\n    }\n  }\n  unsigned mulR(unsigned a){\n    return (unsigned long long)a*R%md;\n  }\n  unsigned mulR(int a){\n    if(a < 0){\n      a = a%md+md;\n    }\n    return mulR((unsigned)a);\n  }\n  unsigned mulR(unsigned long long a){\n    return mulR((unsigned)(a%md));\n  }\n  unsigned mulR(long long a){\n    a %= md;\n    if(a < 0){\n      a += md;\n    }\n    return mulR((unsigned)a);\n  }\n  unsigned reduce(unsigned T){\n    unsigned m=T * mdninv, t=(unsigned)((T + (unsigned long long)m*md) >> W);\n    if(t >= md){\n      t -= md;\n    }\n    return t;\n  }\n  unsigned reduce(unsigned long long T){\n    unsigned m=(unsigned)T * mdninv, t=(unsigned)((T + (unsigned long long)m*md) >> W);\n    if(t >= md){\n      t -= md;\n    }\n    return t;\n  }\n  unsigned get(){\n    return reduce(val);\n  }\n  mint &operator+=(mint a){\n    val += a.val;\n    if(val >= md){\n      val -= md;\n    }\n    return *this;\n  }\n  mint &operator-=(mint a){\n    if(val < a.val){\n      val = val + md - a.val;\n    }\n    else{\n      val -= a.val;\n    }\n    return *this;\n  }\n  mint &operator*=(mint a){\n    val = reduce((unsigned long long)val*a.val);\n    return *this;\n  }\n  mint &operator/=(mint a){\n    return *this *= a.inverse();\n  }\n  mint operator+(mint a){\n    return mint(*this)+=a;\n  }\n  mint operator-(mint a){\n    return mint(*this)-=a;\n  }\n  mint operator*(mint a){\n    return mint(*this)*=a;\n  }\n  mint operator/(mint a){\n    return mint(*this)/=a;\n  }\n  mint operator+(int a){\n    return mint(*this)+=mint(a);\n  }\n  mint operator-(int a){\n    return mint(*this)-=mint(a);\n  }\n  mint operator*(int a){\n    return mint(*this)*=mint(a);\n  }\n  mint operator/(int a){\n    return mint(*this)/=mint(a);\n  }\n  mint operator+(long long a){\n    return mint(*this)+=mint(a);\n  }\n  mint operator-(long long a){\n    return mint(*this)-=mint(a);\n  }\n  mint operator*(long long a){\n    return mint(*this)*=mint(a);\n  }\n  mint operator/(long long a){\n    return mint(*this)/=mint(a);\n  }\n  mint operator-(void){\n    mint res;\n    if(val){\n      res.val=md-val;\n    }\n    else{\n      res.val=0;\n    }\n    return res;\n  }\n  operator bool(void){\n    return val!=0;\n  }\n  operator int(void){\n    return get();\n  }\n  operator long long(void){\n    return get();\n  }\n  mint inverse(){\n    int a=val, b=md, t, u=1, v=0;\n    mint res;\n    while(b){\n      t = a / b;\n      a -= t * b;\n      swap(a, b);\n      u -= t * v;\n      swap(u, v);\n    }\n    if(u < 0){\n      u += md;\n    }\n    res.val = (unsigned long long)u*RR % md;\n    return res;\n  }\n  mint pw(unsigned long long b){\n    mint a(*this), res;\n    res.val = R;\n    while(b){\n      if(b&1){\n        res *= a;\n      }\n      b >>= 1;\n      a *= a;\n    }\n    return res;\n  }\n  bool operator==(int a){\n    return mulR(a)==val;\n  }\n  bool operator!=(int a){\n    return mulR(a)!=val;\n  }\n}\n;\nmint operator+(int a, mint b){\n  return mint(a)+=b;\n}\nmint operator-(int a, mint b){\n  return mint(a)-=b;\n}\nmint operator*(int a, mint b){\n  return mint(a)*=b;\n}\nmint operator/(int a, mint b){\n  return mint(a)/=b;\n}\nmint operator+(long long a, mint b){\n  return mint(a)+=b;\n}\nmint operator-(long long a, mint b){\n  return mint(a)-=b;\n}\nmint operator*(long long a, mint b){\n  return mint(a)*=b;\n}\nmint operator/(long long a, mint b){\n  return mint(a)/=b;\n}\ninline void rd(int &x){\n  int k, m=0;\n  x=0;\n  for(;;){\n    k = getchar_unlocked();\n    if(k=='-'){\n      m=1;\n      break;\n    }\n    if('0'<=k&&k<='9'){\n      x=k-'0';\n      break;\n    }\n  }\n  for(;;){\n    k = getchar_unlocked();\n    if(k<'0'||k>'9'){\n      break;\n    }\n    x=x*10+k-'0';\n  }\n  if(m){\n    x=-x;\n  }\n}\ninline void wt_L(char a){\n  putchar_unlocked(a);\n}\ninline void wt_L(int x){\n  char f[10];\n  int m=0, s=0;\n  if(x<0){\n    m=1;\n    x=-x;\n  }\n  while(x){\n    f[s++]=x%10;\n    x/=10;\n  }\n  if(!s){\n    f[s++]=0;\n  }\n  if(m){\n    putchar_unlocked('-');\n  }\n  while(s--){\n    putchar_unlocked(f[s]+'0');\n  }\n}\ninline void wt_L(mint x){\n  int i;\n  i = (int)x;\n  wt_L(i);\n}\nstruct combination_mint{\n  mint *fac, *ifac;\n  void init(int n, void **mem = &wmem){\n    int i;\n    walloc1d(&fac, n, mem);\n    walloc1d(&ifac, n, mem);\n    fac[0] = 1;\n    for(i=1;i<n;i++){\n      fac[i] = fac[i-1] * i;\n    }\n    ifac[n-1] = 1 / fac[n-1];\n    for(i=n-2;i>=0;i--){\n      ifac[i] = ifac[i+1] * (i+1);\n    }\n  }\n  mint C(int a, int b){\n    if(b < 0 || b > a){\n      return 0;\n    }\n    return fac[a]*ifac[b]*ifac[a-b];\n  }\n  mint P(int a, int b){\n    if(b < 0 || b > a){\n      return 0;\n    }\n    return fac[a]*ifac[a-b];\n  }\n  mint H(int a, int b){\n    if(a==0 && b==0){\n      return 1;\n    }\n    if(a<=0 || b<0){\n      return 0;\n    }\n    return C(a+b-1, b);\n  }\n}\n;\nchar memarr[96000000];\nunsigned mint::R, mint::RR, mint::Rinv, mint::W, mint::md, mint::mdninv;\n#define MD 998244353\nint N;\nint M;\nint main(){\n  combination_mint c;\n  int i, j;\n  mint m, res, tmp;\n  wmem = memarr;\n  {\n    mint x;\n    x.setmod(MD);\n  }\n  rd(N);\n  rd(M);\n  c.init(3000000);\n  res = 0;\n  for(i=M%2;i<=M;i+=2){\n    j = (3*M - i) / 2;\n    tmp = c.C(N,i);\n    tmp *= c.H(N,j) - ((N-i) * c.H(N,j-M-1) + i * c.H(N,j-M));\n    res += tmp;\n  }\n  wt_L(res);\n  wt_L('\\n');\n  return 0;\n}\n// cLay varsion 20190721-1\n\n// --- original code ---\n// #define MD 998244353\n// int N, M;\n// {\n//   int i, j;\n//   mint res, tmp, m;\n//   combination_mint c;\n// \n//   rd(N,M);\n//   c.init(3d6);\n// \n//   res = 0;\n//   for(i=M%2;i<=M;i+=2){\n//     j = (3M - i) / 2;\n//     tmp = c.C(N,i);\n//     tmp *= c.H(N,j) - ((N-i) * c.H(N,j-M-1) + i * c.H(N,j-M));\n// //    m = c.H(N,j-N-1);\n// //    wt(i,tmp,N,j,j-N-1,m);\n//     res += tmp;\n//   }\n// \n//   wt(res);\n// }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(ll i = ll(a); i < ll(b); i++)\n#define rer(i, a, b) for(ll i = ll(a) - 1; i >= ll(b); i--)\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sc second\n#define fr first\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int, int> P;\n\nconst ll MOD=998244353;\nll n,m;\nconst int MAX_N=2000000;\nll fact[MAX_N], invfact[MAX_N];\nll extgcd(ll a, ll b, ll& x, ll&y){\n    ll d=a;\n    if(b!=0){\n        d=extgcd(b, a%b, y, x);\n        y-=(a/b)*x;\n    }\n    else {\n        x=1; y=0;\n    }\n    return d;\n}\n\nll mod_inverse(ll a, ll m=MOD){\n    ll x,y;\n    extgcd(a,m,x,y);\n    return (m+x%m)%m;\n}\nll comb(ll a, ll b){\n    if(a<b) return 0;\n    return fact[a]*invfact[b]%MOD*invfact[a-b]%MOD;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>n>>m;\n    ll ans=0;\n    fact[0]=1;\n    invfact[0]=1;\n    rep(i,1,MAX_N){\n        fact[i]=fact[i-1]*i%MOD;\n        invfact[i]=mod_inverse(fact[i]);\n    }\n    rep(i,0,m+1){\n        if(3*m%2==i%2){\n            ans+=comb((3*m-i)/2+n-1, n-1)*comb(n,i)%MOD;\n            if(i) ans-=comb((m-i)/2+n-1, n-1)*comb(n-1,i-1)%MOD*n%MOD;\n            ans-=comb((m-i)/2+n-2, n-1)*comb(n-1,i)%MOD*n%MOD;\n            ans%=MOD;\n        }\n    }\n    cout <<(ans+MOD)%MOD<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\nconst int N=3000005,mod=998244353;\nint fac[N],rev[N],n,m,ans,sum;\n\ninline int power(int x,int p){\n\tint res=1;\n\tfor(;p;p>>=1,x=(ll)x*x%mod)\n\t\tif(p&1)res=(ll)res*x%mod;\n\treturn res;\n}\ninline int C(int n,int m){\n\treturn m<0||m>n?0:(ll)fac[n]*rev[m]%mod*rev[n-m]%mod;\n}\nvoid init(int lim){\n\tfac[0]=1;\n\trep(i,1,lim)fac[i]=(ll)fac[i-1]*i%mod;\n\trev[lim]=power(fac[lim],mod-2);\n\tper(i,lim,1)rev[i-1]=(ll)rev[i]*i%mod;\n}\n\nint calc(int n,int m){\n\tif(m<0||n<0)return 0;\n\tif(m==0&&n==0)return 1;\n\treturn C(m+n-1,n-1);\n}\n\nint doit(int k){\n\tint rem=(sum-k)/2,mx=m;\n\tint sum=(calc(n,rem)-(ll)(n-k)*calc(n,rem-mx-1)%mod\n\t\t\t+2ll*mod-(ll)k*calc(n,rem-mx)%mod)%mod;\n\t//cerr<<k<<\" \"<<sum<<\"  \"<<rem<<endl;\n\treturn (ll)C(n,k)*sum%mod;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tinit(max(n,m)*3);\n\tsum=3*m;\n\trep(i,0,min(m,n))\n\t\tif((sum-i)%2==0)\n\t\t\tans=(ans+doit(i))%mod;\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\n#define fir first\n#define sec second\n#define rep(i,a,b) for (int i = (a) ; i <= (b) ; ++ i)\n#define rrp(i,a,b) for (int i = (a) ; i >= (b) ; -- i)\n#define gc() getchar()\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc() ; !isdigit(tmp) ; tmp = gc())\n    key = (tmp == '-');\n  for ( ; isdigit(tmp) ; tmp = gc())\n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst int MOD = 998244353;\ninline void Add(int& x,int y) {\n  x = x + y >= MOD ? x + y - MOD : x + y;\n}\ninline void Sub(int& x,int y) {\n  x = x - y < 0 ? x - y + MOD : x - y;\n}\nint power(int a,int b) {\n  int ret = 1;\n  while (b) {\n    if (b&1) ret = 1ll * ret * a % MOD;\n    a = 1ll * a * a % MOD;\n    b >>= 1;\n  }\n  return ret;\n}\nconst int N = 3000000;\nint jc[N], ijc[N], n, m, ans;\nvoid init(int t) {\n  jc[0] = 1;\n  rep (i, 1, t) jc[i] = 1ll * jc[i-1] * i % MOD;\n  ijc[t] = power(jc[t], MOD - 2);\n  rrp (i, t-1, 0) ijc[i] = 1ll * ijc[i+1] * (i+1) % MOD;\n}\nint comb(int a,int b) {\n  if (a < b || b < 0) return 0;\n  return 1ll * jc[a] * ijc[b] % MOD * ijc[a-b] % MOD;\n}\nint main() {\n  read(n), read(m);\n  init(n + 3 * m);\n  rep (i, 0, min(n, m)) if ((m-i) % 2 == 0) {\n    Add(ans, 1ll * comb(n, i) * comb((3 * m - i) / 2 + n - 1, n - 1) % MOD);\n    if (i <= m-2)\n      Sub(ans, 1ll * n * comb(n-1,i) % MOD * comb((3*m-i-2*(m+1)) / 2 + n - 1, n - 1) % MOD);\n    if (i <= m)\n      Sub(ans, 1ll * n * comb(n-1,i-1) % MOD * comb((3*m-i-2*m)/2 + n-1, n-1) % MOD);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=2e6+5;\nconst int mod=998244353;\nint n,m,inv[N],jc[N],jcn[N],foo,bar;\nint C(int n,int m){\n\tif(n<0||m<0||n<m)return 0;\n\treturn 1ll*jc[n]*jcn[m]%mod*jcn[n-m]%mod;\n}\nint cal(int n,int m){\n\treturn C(n+m-1,n);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);inv[1]=jc[0]=jcn[0]=1;\n\tfor(int i=2;i<N;++i)inv[i]=1ll*inv[mod%i]*(mod-mod/i)%mod;\n\tfor(int i=1;i<N;++i)jc[i]=1ll*jc[i-1]*i%mod,jcn[i]=1ll*jcn[i-1]*inv[i]%mod;\n\tfor(int i=0;i<=m&&i<=n;++i)if(~(m+m+m-i)&1)foo=(foo+1ll*C(n,i)*cal(m+m+m-i>>1,n))%mod;\n\tfor(int i=0;i<m;++i)bar=(bar+cal(i,n-1))%mod;\n\tprintf(\"%lld\\n\",(foo+1ll*(mod-n)*bar)%mod);return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define sf scanf\n#define pf printf\n#define pb push_back\n#define mp make_pair\n#define PI ( acos(-1.0) )\n#define mod 998244353LL\n#define maxn 100005\n#define IN freopen(\"C.in\",\"r\",stdin)\n#define OUT freopen(\"output.txt\",\"w\",stdout)\n#define FOR(i,a,b) for(i=a ; i<=b ; i++)\n#define DBG pf(\"Hi\\n\")\n#define INF 1000000000\n#define i64 long long int\n#define eps (1e-8)\n#define xx first\n#define yy second\n#define ln 17\n#define off 2\n\nusing namespace __gnu_pbds;\nusing namespace std ;\n\ntypedef tree< i64, null_type, less<i64>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef pair<i64, i64> pii;\n\n\nclass numberTheory{\n\npublic:\n    numberTheory(){}\n\n    pii extendedEuclid(i64 a, i64 b) { // returns x, y | ax + by = gcd(a,b)\n\n        if(b == 0) return pii( a >= 0 ? 1 : -1 , 0LL);\n        else {\n            pii d = extendedEuclid(b, a % b);\n            return pii(d.yy, d.xx - d.yy * (a / b));\n        }\n\n    }\n\n    i64 modularInverse(i64 a, i64 n) {\n        pair<i64,i64> ret = extendedEuclid(a, n);\n        return ((ret.xx % n) + n) % n;\n    }\n\n\n    i64 bigMod(i64 a, i64 n , i64 m)\n    {\n        if(n==0) return 1 ;\n        i64 ret = bigMod(a,n/2,m) ;\n        ret = (ret*ret)%m ;\n        if(n%2) ret = (ret*a)%m ;\n        return ret ;\n    }\n};\n\nconst i64 N = 5000000 ;\n\ni64 fact[N+5] , invFact[N+5] ;\n\ni64 C(i64 n, i64 r)\n{\n    if( n<0 || r<0 || r>n ) return 0 ;\n    i64 ret = (fact[n]*invFact[r])%mod ;\n    return (ret*invFact[n-r])%mod ;\n}\n\nvoid preprocess()\n{\n    numberTheory nt ;\n\n    fact[0] = 1 ;\n    for(i64 x=1 ; x<=N ; x++) fact[x] = (fact[x-1]*x)%mod ;\n\n    invFact[N] = nt.modularInverse(fact[N],mod) ;\n\n    for(i64 x=N-1 ; x>=0 ; x--) invFact[x] = (invFact[x+1]*(x+1) )%mod ;\n}\n\nint main()\n{\n    preprocess() ;\n\n    i64 n , m ;\n    scanf(\"%lld %lld\",&n,&m) ;\n\n    i64 ans = 0 ;\n\n    for(int odd=0 ; odd<=min(m,n) ; odd++)\n    {\n        if( (3*m)%2 != odd%2 ) continue ;\n\n        i64 sum = 3*m-odd , ret = 0 ;\n\n        ret += C( sum/2+n-1 , n-1 ) ;\n\n        ret -= (C( (sum-2*m)/2+n-1 , n-1 )*odd)%mod ;\n\n        ret -= (C( ( sum-2*m-2 )/2 +n-1 , n-1 )*(n-odd))%mod ;\n\n        ret %= mod ;\n\n        ret = (ret*C(n,odd))%mod ;\n\n        ans = ( ans + ret )%mod ;\n\n     //   printf(\"%d: %lld\\n\",odd,ans) ;\n    }\n\n    ans = (ans%mod + mod)%mod ;\n\n    printf(\"%lld\\n\",ans) ;\n\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define int long long\nusing namespace std;\nconst int mod=998244353;\nconst int N=3e6+2;\nint fact[N],inv[N];\nint binpow(int x,int y){\n\tint tich=1;\n\twhile(y){\n\t\tif((y&1)){\n\t\t\ttich*=x;\n\t\t\ttich%=mod;\n\t\t}\n\t\tx*=x;\n\t\tx%=mod;\n\t\ty>>=1;\n\t}\n\treturn tich;\n}\nint C(int x,int y){\n\treturn ((fact[y]*inv[x])%mod*inv[y-x])%mod;\n}\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,m,i,j,k,l,ans=0;\n\tcin>>n>>m;\n\tfact[0]=1;\n\tfor(i=1;i<=2*(n+m);i++){\n\t\tfact[i]=(fact[i-1]*i)%mod;\n\t}\n\tinv[2*(m+n)]=binpow(fact[2*(m+n)],mod-2);\n\tfor(i=2*(m+n);i>=1;i--){\n\t\tinv[i-1]=(inv[i]*i)%mod;\n\t}\n\tfor(i=m%2;i<=min(n,m);i+=2){\n\t\tif(i>3*m){\n\t\t\tbreak;\n\t\t}\n\t\tans+=C(i,n)*C(n-1,(3*m-i)/2+n-1);\n\t\tif(i<=m){\n\t\t\tans-=(n*C(i,n))%mod*C(n-1,n-1+(m-i)/2);\n\t\t\tif(i<n){\n\t\t\t\tans+=(n*C(i,n-1))%mod*C(n-2,n-2+(m-i)/2);\n\t\t\t}\n\t\t}\n\t\tans%=mod;\n\t\tif(ans<0){\n\t\t\tans+=mod;\n\t\t}\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits>\n#include <cfenv>\n#include <cmath>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cstring>\n#include <map>\n#include <stack>\n#include <set>\n#include <tuple>\n#include <queue>\n#include <vector>\n#include <cmath>\n#include <random>\n#include <math.h>\n#include <list>\n#include <random>\n#include <functional>\n\n\n#define FOR(i, a, b) for(int (i) = (a); (i) < (b); ++(i))\n#define REP(i, n) FOR(i, 0, n)\n#define rREP(i, n) for(int (i) = (n) - 1; (i) >= 0; --(i))\n#define ALL(TheArray) TheArray.begin(), TheArray.end()\n\nusing lli = long long int;\nusing pii = std::pair<int, int>;\n\ntemplate <class T> inline bool chmax(T& a, T b){\n    if(a < b){a = b; return true;}\n    return false;\n}\ntemplate <class T> inline bool chmin(T& a, T b){\n    if(a > b){a = b; return true;}\n    return false;\n}\n\n\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\ntemplate <int N, long long int mod>\nstruct CombinationMod{\nprivate:\n    using lli = long long int;\npublic:\n    std::array<lli, N+1> Power, Inverse, powInverse;\n\n    CombinationMod(int n){\n        init(n);\n    }\n\n    void init(int n){\n        Power[0] = 1; Inverse[0] = 1; powInverse[0] = 1;\n        for(int x = 1; x <= n; ++x) Power[x] = (Power[x-1] * x) % mod;\n        powInverse[n] = inverse(Power[n]);\n        for(int x = N; x > 0; --x) powInverse[x-1] = (powInverse[x] * x) % mod;\n        for(int x = 1; x <= n; ++x) Inverse[x] = (Power[x-1] * powInverse[x]) % mod;\n    }\n    constexpr void swap(lli &a, lli &b) const {\n        a ^= b; b ^= a; a ^= b;\n    }\n    constexpr lli inverse(lli a) const noexcept{\n        lli b = mod, u = 1, v = 0;\n        while (b != 0) { \n            lli t = a / b; a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        u %= mod; if (u < 0) u += mod;\n        return u;\n    }\n    // nCkを求める関数 : n < k の入力に注意せよ\n    inline lli combination(int n, int k) const noexcept{\n        if(n < k or k < 0) return 0;\n        return ((Power[n] * powInverse[k] % mod) * powInverse[n-k]) % mod;\n    }\n};\n\n\n\n\n/* fn(x, y) := 2加算をx回, 1加算をy回することによって得られる場合の数\n   このとき, fn(M, M)が求める答えの近似になる | 条件緩和　-> 加算をそれぞれ独立に考えられる\n   追加制約として, 「全てのインデックスについて選ばれた回数が高々M回」を課す\n   ---> 再帰で解くのは少し厳しそう; 何かいい言い換えはないか？\n   それぞれの操作の特徴は何か？\n   １加算 -> 偶奇反転, 2回で2加算と同一視\n   ２加算 -> 偶奇普遍\n   追加制約を考えれば奇数の数は高々M個 ; なんか良さげな条件 | いや扱いにくいか？\n   操作終了後の総和は 3M である\n   最大要素は2Mでバウンドされる\n   こんな感じの性質を満たしそう(このくらいしか思いつかない : 場所に制約がないので一松模様なども不可)\n   逆にこの条件で構成可能か？可能っぽい気がするけど気もしない...\n        大きい数から２加算の操作を割り当てると考えると, 残りの総和は高々M\n        2M - K の山に関して (K ≤ M) 他の山の最大は K であるから操作は M - K回行われMを超えない\n        あまったところに1加算を割り当てれば良い、そしてこれはMを超えない\n        奇数をあらかじめ選んでから残りの数(偶数)の配分を決定ればいい -> よし！\n 　雑に数えると\n    ∑_k nCk * H((3M - k) / 2, n) | for all k s.t. 0 ≤ k ≤ M , (3M - k) % 2 == 0\n   最大山が2M以下が考慮されていない -> その数を除去する\n   for all i in 1...M, 残り M - i の問題について考えられる | この最大山の選び方は M通り！\n*/\n\nconstexpr int _M = 2e6 + 5e5;\nconstexpr int mod = 998244353;\nconst CombinationMod<_M, mod> Comb(_M);\n\n\nint main(void){\n    int n, m; scanf(\"%d%d\", &n, &m);\n    lli P = 0;\n    lli tm = 3 * m, even = 0;\n    if(tm & 1) tm--, even++; tm /= 2;\n    while(tm >= 0 and n >= even){\n        P += Comb.combination(n, even) * Comb.combination(n + tm - 1, tm);\n        tm--; even += 2;\n    }\n    lli Q = 0;\n    for(int i = 1; i <= m; ++i) (Q += Comb.combination(m - i + n - 2, m - i)) %= mod;\n    (Q *= n) %= mod; \n    P -= Q; if(P < 0) P += mod;\n    printf(\"%lld\\n\", P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define DEBUG\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds; \nusing namespace std;\n \n#define BSET(a, p) ((a) | (1ll << (p)))\n#define BCHK(a, p) ((a) & (1ll << (p)))\n#define BXOR(a, p) ((a) ^ (1ll << (p)));\n#define BREM(a, p) (BCHK(a, p)?(BXOR(a, p)):(a))\n#define BSHO(a, N) (bitset<N>(a))\n \n#define fi first\n#define sc second \n#define pb push_back\n \n \n#ifdef DEBUG\n    #define dbg(s) {s;}\n    #define PRELUDE\n#endif\n \n#ifndef DEBUG \n    #define PRELUDE { ios :: sync_with_stdio(false); cin.tie(0); cout.tie(0); }\n    #define dbg(s)\n    #define endl \"\\n\"\n#endif\n \nusing namespace std;\n \n \n#define int ll\n#define i32 int32_t\n \n#define RBTTYPE int\n#define ordered_set tree<RBTTYPE, null_type, less<RBTTYPE>, rb_tree_tag,tree_order_statistics_node_update> \n \n#define all(v) (v).begin(),(v).end()\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair< int, int > pii;\ntypedef pair< ll, ll > pll;\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ninline int ri(int x) { // from [0, n-1]\n    return uniform_int_distribution<int>(0, x - 1)(rng);\n}\n \ninline ld rf() { // from [0, 1]\n    return uniform_real_distribution<ld>(0, 1)(rng);\n}\n \nll gcd(ll x, ll y) {\n    if (x < y) return gcd(y, x);\n    if (y == 0) return x;\n    return gcd(y, x % y);\n} \n \nconst ll inf = 1e9 + 7;\nconst ll mod = 998244353ll;\n \nll modexp(ll x, ll ex) {\n    ll ans = 1ll;\n    while (ex > 0) {\n        if (ex & 1ll) ans = (ans * x) % mod;\n        ex >>= 1ll;\n        x = (x * x) % mod;\n    }\n    return ans;\n}\n  \nconst int maxn = 3e6 + 7;\n\n\nint fac[maxn];\nint faci[maxn];\n\nint C(int n, int m) {\n    if (m > n) return 0;\n    if (m < 0) return 0;\n    int ans = (fac[n] * faci[m]) % mod;\n    ans = (ans * faci[n - m]) % mod;\n    return ans;\n}\n\n\ni32 main() {\n    //freopen(\"<file>.in\", \"r\", stdin);\n    //freopen(\"<file>.out\", \"w\", stdout);\n\n    PRELUDE;\n   \n    fac[0] = 1ll; faci[0] = 1ll;\n    for (int j = 1; j < maxn; j++) {\n        fac[j] = (j * 1ll * fac[j - 1]) % mod;\n        faci[j] = modexp(fac[j], mod - 2);\n    }\n\n    int n, m; cin >> n >> m;\n\n    int total = C(n - 1 + m + m + m, n - 1);\n    //cout << total << endl;\n\n    int part1 = 0;\n    for (int j = m + m + 1; j <= m + m + m; j++) {\n        int cur = n * C(m + m + m - j + n - 2, n - 2);\n     ////   cout << j << \" ? \" << cur << endl;\n        cur %= mod;\n        part1 += cur;\n    }\n    part1 %= mod;\n    \n    //cout << part1 << endl;\n\n    int part2 = 0;\n\n    for (int k = m + 1; k <= n; k++) {\n        \n        /*int cur = C(k, m + 1);\n        int cur2 = C(n, k);\n        int sum = m + m + m - k;\n        if (sum % 2) continue;\n        int cur3 = C(sum / 2 + n - k - 1, n - k - 1);\n        int sg = ((k - m - 1) % 2 == 0) ? 1 : (mod - 1);\n\n        int ans = (((((cur * cur2) % mod) * cur3) % mod) * sg) % mod;\n        cout << ans << endl;\n        part2 = (part2 + ans) % mod;*/\n\n        int cur = C(n, k);\n        int sum = m * 3 - k;\n        if (sum % 2) continue;\n        sum /= 2;\n        int cur2 = C(sum + n - 1, n - 1);\n        int ans = (cur * cur2) % mod;\n        part2 += ans;\n\n    }\n\n    part2 %= mod;\n\n    //cout << part2 << endl;\n\n    cout << (total + mod - part1 + mod - part2) % mod << endl; \n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=4000005;\nconst int MOD=998244353;\nint n,m;\nlong long ksm(long long a,long long b)\n{\n\tlong long res=1;\n\twhile(b)\n\t{\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD,b>>=1;\n\t}\n\treturn res;\n}\nlong long fac[N],inv[N];\nvoid init(int n=4000000)\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfac[i]=fac[i-1]*i%MOD;\n\tinv[n]=ksm(fac[n],MOD-2);\n\tfor(int i=n;i>=1;i--)\n\t\tinv[i-1]=inv[i]*i%MOD;\n\treturn;\n}\nlong long C(int n,int m)\n{\n\tif(m<0||n<0) return 0;\n\tif(m>n) return 0;\n\telse return fac[n]*inv[m]%MOD*inv[n-m]%MOD;\n}\nint main()\n{\n\tinit();\n\tscanf(\"%d%d\",&n,&m);\n\tlong long ans=0;\n\tint num=(m+1)%2==1?m+1:m+2;\n\tfor(int i=0;i<=n&&i<=m;i++)\n\t{\n\t\tif(i%2!=m%2) continue;\n\t\tint t=(3*m-i)/2;\n\t\tif(t<0) continue; \n\t\tlong long res=0;\n\t\tres=(res+C(t+n-1,n-1)*C(n,i)%MOD)%MOD;\n\t\tif(t-m>=0) res=(res-C(t-m+n-1,n-1)*C(n-1,i-1)%MOD*n%MOD+MOD)%MOD;\n\t\tif(t-(m+1)>=0) res=(res-C(t-(m+1)+n-1,n-1)*C(n-1,i)%MOD*n%MOD+MOD)%MOD;\n\t\tans=(ans+res)%MOD;\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcount\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\nconst int N = 3e6 + 7;\n\nconst int MOD = 998244353;\nint mod(int n) {\n    n %= MOD;\n    if (n < 0) return n + MOD;\n    else return n;\n}   \nint fp(int a, int p) {\n    int ans = 1, c = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod(ans * c);\n        c = mod(c * c);\n    }   \n    return ans;\n}   \nint dv(int a, int b) { return mod(a * fp(b, MOD - 2)); }\nint f[N], inv[N];\nint C(int n, int k) {\n    return mod(f[n] * mod(inv[k] * inv[n - k]));\n}\nint comp(int n, int k) {\n    return C(n + k - 1, k - 1);\n}   \n\nint get(int sum, int n, int mx) {\n    int ans = 0;\n    for (int i = 0; i <= sum && i <= n && i <= mx; ++i) {\n        if ((i & 1) == (sum & 1)) {\n            ans = mod(ans + C(n, i) * comp((sum - i) / 2, n));\n        }\n    }   \n    return ans;\n}   \n\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n\n    f[0] = 1;\n    for (int i = 1; i < N; ++i)\n        f[i] = mod(f[i - 1] * i);\n    for (int i = 0; i < N; ++i)\n        inv[i] = fp(f[i], MOD - 2);\n\n    int n, m;        \n    cin >> n >> m;\n    int all = get(3 * m, n, m);\n    int bad = 0;\n    for (int x = 2 * m + 1; x <= 3 * m; ++x) {\n        bad = mod(bad + get(3 * m - x, n - 1, m - (x & 1)));        \n    }   \n    cout << mod(all - bad * n) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=1e6+100,mod=998244353;\nll power(ll n,ll k){\n    if (k==0) return 1;\n    if (k%2==1){\n        ll x=power(n,k/2);\n        return x*x%mod*n%mod;\n    }\n    ll x=power(n,k/2);\n    return x*x%mod;\n}\nll fac[N],fm[N];\nll ent(ll k,ll n){\n    if (k<0 || k>n) return 0;\n    if (k==0 || k==n) return 1;\n    return fac[n]*fm[k]%mod*fm[n-k]%mod;\n}\nint32_t main(){\n    fac[0]=1;\n    for (int i=1;i<N;i++){\n        fac[i]=fac[i-1]*i%mod;\n        fm[i]=power(fac[i],mod-2);\n    }\n //   cout << ent(3,5) << endl;\n    ll ans=0;\n    ll n,m;\n    cin >> n >> m;\n    ll z=3*m;\n    for (int i=0;i<=min(n,m);i++){\n        ll t=z-i;\n        if (t%2==1) continue;\n        ans+=ent(i,n)*ent(n-1,n-1+t/2)%mod;\n    }\n    for (int i=2*m+1;i<=3*m;i++){\n        ll t=z-i;\n        ans-=n*ent(n-2,n-2+t)%mod;\n        ans+=mod;\n        ans%=mod;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstdlib>\n#include<map>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<stack>\n#include<math.h>\n#include<queue>\n#include<complex>\nusing namespace std;\n\nconst long long int INF=99999999999999,inf=199999;\nconst long long int mod=998244353;\n\n\n//aからbまでの積を求める(mod)\n\n//階乗先に計算\nlong long int kaizyou[4000005] = { 1 };\nlong long int kai(long long int a, long long int b, long long int mod) {\n\tlong long int tmp = 1;\n\tfor (long long int i = a; i <= b; i++) {\n\t\ttmp *= i;\n\t\ttmp %= mod;\n\n\t\tkaizyou[i] = tmp;\n\t}\n\treturn tmp;\n}\n\n\n//累乗(繰り返し2乗法)　aのb乗(mod)を求める。\nlong long int rui(long long int a, long long int b, long long mod) {\n\tint memo[65] = {};\n\tlong long int A[65] = {};\n\tlong long int tmp = 1;\n\tfor (int i = 0; i < 65; i++) {\n\t\tmemo[i] = b % 2;\n\t\tb /= 2;\n\t}\n\n\tA[0] = a;\n\tA[0] %= mod;\n\n\tfor (int i = 1; i < 65; i++) {\n\t\tA[i] = A[i - 1] * A[i - 1];\n\t\tA[i] %= mod;\n\t}\n\tfor (int i = 0; i < 65; i++) {\n\t\tif (memo[i] == 1) {\n\t\t\ttmp *= A[i];\n\t\t\ttmp %= mod;\n\t\t}\n\t}\n\ttmp %= mod;\n\treturn tmp;\n}\n\n//コンビネーション計算\nlong long int comb(long long int n, long long int r, long long int mod) {\n\tlong long int tmp;\n\n\ttmp = (kaizyou[n] * rui(kaizyou[r], mod - 2, mod)) % mod;\n\ttmp *= rui(kaizyou[n - r], mod - 2, mod);\n\ttmp %= mod;\n\tif (tmp < 0) { tmp = (mod - tmp) % mod; }\n\treturn tmp;\n}\n\n\nlong long int n,m,k,a,b,c,d,count=0,res=0,tmp;\nint main() {\n    int count=0;\n    map<long long int,long long int>mp;\n\tcout << fixed << setprecision(10);\n    cin>>n>>m;\n    kai(1,4000001,mod);\n    res=comb(n+3*m-1,n-1,mod);\n    //cout<<res<<endl;\n    res=res+mod-((n)*comb(n+m-2,n-1,mod))%mod;\n    res%=mod;\n    //cout<<res<<endl;\n    for(int i=m+1;i<=min(3*m,n);i++){\n        if((3*m-i)%2==1){continue;}\n        //n個中m個が0でn-m個が1\n        tmp=comb(n,i,mod)*comb((3*m-i)/2+n-1,n-1,mod);\n        tmp%=mod;\n        res=(mod+res-tmp)%mod;\n    }\n    cout<<res;\n} \n"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <iostream>\n\n\nusing namespace std;\ntypedef long long ll;\n#define REP(i, n) for(int i=0; i<(n); ++i)\n#define FOR(i, a, b) for(int i=(a); i<(b); ++i)\n#define FORR(i, a, b) for(int i=(b)-1; i>=(a); --i)\nconst ll MOD = 998244353ll;\nconst int MAX = 3000000;\n\nll fact[MAX], fact_inv[MAX];\n\n// 繰り返し二乗法\nll power(ll a, ll b) {\n\tll res = 1;\n\twhile (b>0) {\n\t\tif (b & 1) res = res*a%MOD;\n\t\ta = a*a%MOD;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nll comb(ll n, ll r) {\n\treturn (fact[n] * fact_inv[r]) % MOD*fact_inv[n - r] % MOD;\n}\n\n\n\nint main()\n{\n\tint ret;\n\tint n = 2600000;\n\n\tfact[0] = 1;\n\t// 階乗の計算\n\tREP(i, n) fact[i + 1] = fact[i] * (i + 1) % MOD;\n\tfact_inv[n] = power(fact[n], MOD - 2);\n\t// 逆元の計算\n\tFORR(i, 0, n) fact_inv[i] = fact_inv[i + 1] * (i + 1) % MOD;\n\n\n\tint N, M;\n\tret = scanf(\"%d %d\", &N, &M);\n\n\tint m = 3 * M;\n\n\n\tlong long z = comb(m + N - 1, N-1);\n\tlong long zz = comb(M - 1 + N - 1, N-1);\n\tlong long zzN = (zz * N) % MOD;\n\tlong long result = (z + MOD - zzN) % MOD;\n\n\tprintf(\"%lld\", result);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <regex>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/timeb.h>\n#include <vector>\n\nusing namespace std;\n\n#define repr(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) repr(i, 0, n)\n#define reprrev(i, a, b) for (int i = (int)(b)-1; i >= (int)(a); i--)\n#define reprev(i, n) reprrev(i, 0, n)\n#define repi(itr, ds) for (auto itr = ds.begin(); itr != ds.end(); itr++)\n#define chmin(mi, value) mi = min(mi, value)\n#define chmax(ma, value) ma = max(ma, value)\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define mp make_pair\n#define mt make_tuple\n#define INF 1050000000\n#define INFR INT_MAX\n#define INFL (long long)(4e18)\n#define INFLR LLONG_MAX\n#define EPS (1e-10)\n// #define MOD 1000000007\n#define MOD 998244353\n#define PI 3.141592653589793238\n#define RMAX 4294967295\n\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vvvi = vector<vector<vector<int>>>;\nusing vvvvi = vector<vector<vector<vector<int>>>>;\nusing ll = long long;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nusing vvvll = vector<vector<vector<ll>>>;\nusing vd = vector<double>;\nusing vvd = vector<vd>;\nusing vvvd = vector<vvd>;\nusing vvvvd = vector<vvvd>;\nusing vb = vector<bool>;\nusing vvb = vector<vector<bool>>;\nusing vc = vector<char>;\nusing vvc = vector<vector<char>>;\nusing vs = vector<string>;\nusing vvs = vector<vector<string>>;\nusing Pi = pair<int, int>;\nusing vPi = vector<Pi>;\nusing vvPi = vector<vector<Pi>>;\nusing vvvPi = vector<vector<vector<Pi>>>;\nusing vvvvPi = vector<vector<vector<vector<Pi>>>>;\nusing Pll = pair<ll, ll>;\nusing vPll = vector<Pll>;\nusing Pd = pair<double, double>;\nusing vPd = vector<Pd>;\ntemplate <class T>\nusing vec = vector<T>;\ntemplate <class T>\nusing pql = priority_queue<T, vector<T>, greater<T>>;\nusing Comp = complex<double>;\n\n// vvvvvvvvvvvvvvvvvvvvvvv debug output vvvvvvvvvvvvvvvvvvvvvvv\n// vector input\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n// pair\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n// vector\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"{\";\n    for (int i = 0; i < vec.size(); i++) {\n        os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");\n    }\n    os << \"}\";\n    return os;\n}\n// deque\ntemplate <typename T>\nostream &operator<<(ostream &os, const deque<T> &vec) {\n    os << \"{\";\n    for (int i = 0; i < vec.size(); i++) {\n        os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");\n    }\n    os << \"}\";\n    return os;\n}\n// map\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const map<T, U> &map_var) {\n    os << \"{\";\n    repi(itr, map_var) {\n        os << *itr;\n        itr++;\n        if (itr != map_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n// set\ntemplate <typename T>\nostream &operator<<(ostream &os, const set<T> &set_var) {\n    os << \"{\";\n    repi(itr, set_var) {\n        os << *itr;\n        itr++;\n        if (itr != set_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n// multiset\ntemplate <typename T>\nostream &operator<<(ostream &os, const multiset<T> &set_var) {\n    os << \"{\";\n    repi(itr, set_var) {\n        os << *itr;\n        itr++;\n        if (itr != set_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n#define DUMPOUT cerr\n\nvoid dump_func() {\n    DUMPOUT << endl;\n}\ntemplate <class Head, class... Tail>\nvoid dump_func(Head &&head, Tail &&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) > 0) {\n        DUMPOUT << \", \";\n    }\n    dump_func(std::move(tail)...);\n}\n#ifdef DEBUG_\n#define DEB\n#define dump(...)                                                                                  \\\n    DUMPOUT << \"  \" << string(#__VA_ARGS__) << \": \"                                                \\\n            << \"[\" << to_string(__LINE__) << \":\" << __FUNCTION__ << \"]\" << endl                    \\\n            << \"    \",                                                                             \\\n        dump_func(__VA_ARGS__)\n#else\n#define DEB if (false)\n#define dump(...)\n#endif\n\n// ^^^^^^^^^^^^^^^^^^^^^^^ debug output ^^^^^^^^^^^^^^^^^^^^^^^\n\nrandom_device seed_gen;\nmt19937 engine(seed_gen());\n\nstring YN(bool y, int id = 0) {\n    if (id) cout << id;\n    return (y ? \"YES\" : \"NO\");\n}\nstring yn(bool y, int id = 0) {\n    if (id) cout << id;\n    return (y ? \"Yes\" : \"No\");\n}\nstring ON(bool y, int id = 0) {\n    if (id) cout << id;\n    return (y ? \"OK\" : \"NG\");\n}\n\nint dir4[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\nvector<char> dirchar = {'R', 'L', 'D', 'U'};\nint dir8[8][2] = {{-1, -1}, {0, -1}, {1, -1}, {-1, 0}, {1, 0}, {-1, 1}, {0, 1}, {1, 1}};\n\n// [a,b)\nint irand(int a, int b) {\n    static mt19937 Rand(static_cast<unsigned int>(time(nullptr)));\n    uniform_int_distribution<int> dist(a, b - 1);\n    return dist(Rand);\n}\n\n// [a,b)\ndouble drand(int a, int b) {\n    static mt19937 Rand(static_cast<unsigned int>(time(nullptr)));\n    uniform_real_distribution<double> dist(a, b);\n    return dist(Rand);\n}\n\n// https://qiita.com/IgnorantCoder/items/3101d6276e9bdddf872c\ntemplate <typename A, typename F>\ninline auto transform(const A &v, F &&f) {\n    using result_type = decltype(std::declval<F>()(std::declval<typename A::value_type>()));\n    vector<result_type> y(v.size());\n    std::transform(std::cbegin(v), std::cend(v), std::begin(y), f);\n    return y;\n}\n\n// generate vector which has multiple dimension\ntemplate <class T>\nvector<T> make_v(size_t size, const T &init) {\n    return vector<T>(size, init);\n}\ntemplate <class... Ts>\nauto make_v(size_t size, Ts... rest) {\n    return vector<decltype(make_v(rest...))>(size, make_v(rest...));\n}\n\ntemplate <typename T>\nT Max(const vector<T> &a) {\n    return *max_element(all(a));\n}\ntemplate <typename T>\nT Min(const vector<T> &a) {\n    return *min_element(all(a));\n}\ntemplate <typename T>\nT Sum(const vector<T> &a) {\n    return accumulate(all(a), (T)0);\n}\n\n// for counting using map\ntemplate <typename T>\nvoid Add(map<T, int> &m, T item) {\n    if (m.find(item) == m.end()) {\n        m[item] = 1;\n    } else {\n        m[item]++;\n    }\n}\n\n// for counting using map\ntemplate <typename T>\nvoid Erase(map<T, int> &m, T item) {\n    if (m.find(item) == m.end()) {\n    } else {\n        if (m[item] == 1) {\n            m.erase(item);\n        } else {\n            m[item]--;\n            if (m[item] == 0) {\n                m.erase(item);\n            }\n        }\n    }\n}\n\n// get method for map with default value\ntemplate <typename T, typename U>\nU Get(map<T, U> m, T key, U def) {\n    if (m.find(key) == m.end()) {\n        return def;\n    } else {\n        return m[key];\n    }\n}\n\ntemplate <typename T>\ninline bool Contains(const set<T> &t, const T &key) {\n    return t.find(key) != t.end();\n}\n\ntemplate <typename T, typename U>\ninline bool Contains(const map<T, U> &t, const T &key) {\n    return t.find(key) != t.end();\n}\n\ntemplate <class T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int f, int t, T c) : from(f), to(t), cost(c) {}\n    Edge() {}\n};\ntemplate <class T>\nbool operator<(const Edge<T> e1, const Edge<T> e2) {\n    return e1.cost < e2.cost || (e1.cost == e2.cost && e1.from < e2.from) ||\n           (e1.cost == e2.cost && e1.from == e2.from && e1.to < e2.to);\n}\n\ntemplate <class T>\nostream &operator<<(ostream &os, const Edge<T> &edge) {\n    os << \"(\" << edge.from << \"->\" << edge.to << \":\" << edge.cost << \")\";\n    return os;\n}\n\ntemplate <class T = int>\nclass Graph {\n    int n;\n    bool directed;\n\n  public:\n    vector<vector<Edge<T>>> edges;\n    Graph(int n, bool directed) : n(n), directed(directed), edges(vector<vector<Edge<T>>>(n)) {}\n    Graph() {}\n\n    void add_edge(int s, int t, T cost) {\n        edges[s].emplace_back(s, t, cost);\n        if (!directed) {\n            edges[t].emplace_back(t, s, cost);\n        }\n    }\n    void add_edge(Edge<T> e) {\n        edges[e.from].push_back(e);\n        if (!directed) {\n            edges[e.to].emplace_back(e.to, e.from, e.cost);\n        }\n    }\n\n    vector<Edge<T>> &operator[](size_t i) {\n        return edges[i];\n    }\n    int size() const {\n        return n;\n    }\n};\n\n//======================================================\n\n\n// 階乗・組み合わせの mod 逆数\nclass FactorialMod {\n    // 逆元を計算 (modが素数と仮定)\n    void calc_inverse() {\n        inverse[0] = 0;\n        inverse[1] = 1;\n        for (int i = 2; i <= n; i++) {\n            inverse[i] = mod - ((mod / i) * inverse[mod % i] % mod);\n        }\n    }\n\n    // n! を mod で割った余りと逆元を計算\n    void calc_factorial_inverse() {\n        factorial[0] = factorial_inverse[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            factorial[i] = (factorial[i - 1] * i) % mod;\n            factorial_inverse[i] = (factorial_inverse[i - 1] * inverse[i]) % mod;\n        }\n    }\n\n  public:\n    int n;                               // 扱う最大の値\n    int mod;                             // mod の法（素数）\n    vector<long long> inverse;           // 逆元\n    vector<long long> factorial;         // 階乗\n    vector<long long> factorial_inverse; // 階乗の逆元\n\n    FactorialMod(int _n, int _mod)\n        : n(_n), mod(_mod), inverse(_n + 1), factorial(_n + 1), factorial_inverse(_n + 1) {\n        calc_inverse();\n        calc_factorial_inverse();\n    }\n\n    long long conbination_mod(int r, int k) {\n        if (r == 0 && k == 0) return 1;\n        if (r <= 0 || k < 0 || k > r) return 0;\n        if (k == 0) return 1;\n\n        return (((factorial[r] * factorial_inverse[k]) % mod) * factorial_inverse[r - k]) % mod;\n    }\n};\n\nint main(void) {\n    ll N,M;\n    cin>>N>>M;\n    FactorialMod fm(2000000, MOD);\n\n    ll ans = 0;\n    rep(k, M+1){\n        if((3*M-k) % 2 == 1)continue;\n        ans += fm.conbination_mod(N, k)\n               * fm.conbination_mod(N+(3*M-k)/2-1, N-1)\n               % MOD;\n        ans %= MOD;\n    }\n    rep(k, M){\n        if((M-1-k) % 2 == 1)continue;\n        ans += MOD-((fm.conbination_mod(N, k)\n                    * fm.conbination_mod(N+(M-k-1)/2-1, N-1)\n                    % MOD)\n                    * N) % MOD;\n        ans %= MOD;\n    }\n    cout<<ans<<endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#include<cassert>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\nconst long long mod = 998244353;\nconst long long inf = 1ll << 61;\ntypedef pair<int, int> P;\n\nint kj[2000005], kji[2000005];\n\nint modpow(int x, int n, int md) {\n\tif (!n)return 1;\n\tint res = modpow(x*x%md, n / 2, md);\n\tif (n & 1)res = res*x%md;\n\treturn res;\n}\nint comb(int n, int r) {\n\tif (n < 0 || r<0 || n < r)return 0;\n\tint ans = kj[n];\n\tans = ans*kji[r] % mod;\n\tans = ans*kji[n - r] % mod;\n\treturn ans%mod;\n}\n\n\nvoid kjinit(int n) {\n\tkj[0] = 1;\n\trep(i, n) {\n\t\tkj[i + 1] = kj[i] * (i + 1);\n\t\tkj[i + 1] %= mod;\n\t}\n\trep(i, n)kji[i] = modpow(kj[i], mod - 2, mod);\n\n}\nsigned main() {\n\tint n, m; cin >> n >> m;\n\tkjinit(2000000);\n\tint ans = comb(3 * m + n - 1, n - 1);\n\tfor (int i = 2 * m + 1; i <= 3 * m; i++) {\n\t\tint t = n*comb(3*m-i+n-2, n - 2);\n\t\tt %= mod;\n\t\tans = ans + mod - t;\n\t}\n\tfor (int i = m + 1; i <= 3 * m; i++) {\n\t\tif (i > n)break;\n\t\tint M = 3 * m - i;\n\t\tif (M & 1)continue;\n\t\tint t = comb(n, i)*comb(M/2 + n-1, n - 1);\n\t\tt %= mod;\n\t\tans = ans + mod - t;\n\t}\n\t\n\n\tcout << ans%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\n\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll _v):v(normS(_v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tModInt& operator++(int){ return *this=*this+1;}\n\tModInt& operator--(int){ return *this=*this-1;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll p[]={a,1,0},q[]={b,0,1};\n\t\twhile(*q){\n\t\t\tll t=*p/ *q;\n\t\t\trep(i,3) swap(p[i]-=t*q[i],q[i]);\n\t\t}\n\t\tif(p[0]<0) rep(i,3) p[i]=-p[i];\n\t\tx=p[1],y=p[2];\n\t\treturn p[0];\n\t}\n\tModInt inv() const {\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tModInt pow(ll p) const {\n\t\tif(p<0) return inv().pow(-p);\n\t\tModInt a = 1;\n\t\tModInt x = *this;\n\t\twhile(p){\n\t\t\tif(p&1) a *= x;\n\t\t\tx *= x;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn a;\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<998244353>;\n\nV<mint> fact,ifact;\nmint Choose(int a,int b){\n\tif(b<0 || a<b) return 0;\n\treturn fact[a] * ifact[b] * ifact[a-b];\n}\nvoid InitFact(int N){\n\tfact.resize(N);\n\tifact.resize(N);\n\tfact[0] = 1;\n\trep1(i,N-1) fact[i] = fact[i-1] * i;\n\tifact[N-1] = fact[N-1].inv();\n\tfor(int i=N-2;i>=0;i--) ifact[i] = ifact[i+1] * (i+1);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\tInitFact(3000000);\n\n\tint N,M;\n\tcin >> N >> M;\n\tmint ans = 0;\n\tfor(int odd = 0; odd <= min(N,M); odd++){\n\t\tint even = N - odd;\n\t\tif((M*3-odd)%2) continue;\n\t\tint X = (M*3-odd)/2;\n\t\t//even : <M+1, odd : <M\n\t\tmint tmp = Choose(X+N-1,N-1) - Choose(X+N-1-(M+1),N-1) * even - Choose(X+N-1-M,N-1) * odd;\n\t\ttmp *= Choose(N,odd);\n\t\tshow(odd);\n\t\tshow(tmp);\n\t\tans += tmp;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define fi first\n#define se second\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define INF  (1<<30)\n#define INFL (1LL<<60)\n#define MOD 998244353LL\n#define EPS ((ld)(1e-9))\n \n#define sz(x) ((int)(x).size())\n#define setz(x) memset(x, 0, sizeof(x))\n#define all(x) (x).begin(), (x).end()\n#define rep(i, e) for (int i = 0, _##i = (e); i < _##i; i++)\n#define repp(i, s, e) for (int i = (s), _##i = (e); i < _##i; i++)\n#define repr(i, s, e) for (int i = (s)-1, _##i = (e); i >= _##i; i--)\n#define repi(i, x) for (auto &i : (x))\n \n \nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<ll, ll> pll;\n \ntemplate<typename T, typename V>\nostream &operator<<(ostream &os, const pair<T, V> pai) { \n    return os << '(' << pai.first << ' ' << pai.second << ')';\n}\n \ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> v) {\n    cout << '[';\n    for (auto p : v) cout << p << \",\";\n    cout << \"]\";\n    return os;\n}\n \ntemplate<typename T>\nostream &operator<<(ostream &os, const set<T> v) {\n    cout << \"{\";\n    for (auto p : v) cout << p << \",\";\n    cout << \"}\";\n    return os;\n}\n \ntemplate<typename T, typename V>\nostream &operator<<(ostream &os, const map<T, V> v) {\n    cout << \"{\";\n    for (auto p : v) cout << p << \",\";\n    cout << \"}\";\n    return os;\n}\n \n#ifndef __SOULTCH\n#define debug(...) 0\n#define endl '\\n'\n#else\n#define debug(...) cout << \" [-] \", _dbg(#__VA_ARGS__, __VA_ARGS__)\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cout << sdbg << '=' << h << endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n    while(*sdbg != ',') cout << *sdbg++;\n    cout << '=' << (h) << ','; \n    _dbg(sdbg+1, a...);\n}\n#endif\n \ntemplate<typename T> void get_max(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void get_min(T &a, T b) {a = min(a, b);}\n\n\nint N, M;\nll inv(ll v) {\n    ll res = 1;\n    for (int t = MOD-2; t > 0; t >>= 1) {\n        if (t&1) res = res*v%MOD;\n        v = v*v%MOD;\n    }\n    return res;\n}\n\nll A[5000001] = {1};\nll B[5000001];\n\nll comb(int a, int b) {\n    if (a < b) return 0;\n    return A[a]*B[b]%MOD*B[a-b]%MOD;\n}\n\nll calc(int x) {\n    if ((x^M)&1) return 0;\n\n    ll x1 = comb((3*M-x)/2+N-1, N-1)%MOD;\n    ll x2 = x*comb((M-x)/2+N-1, N-1)%MOD;\n    ll x3 = (x<M?(N-x)*comb((M-x-2)/2+N-1, N-1):0)%MOD;\n    debug(x, x1, x2, x3);\n    return comb(N, x)*(x1+2*MOD-x2-x3)%MOD;\n}\n\n\nint main(void) {\n    iostream::sync_with_stdio(false);\n    cin.tie(nullptr), cout.tie(nullptr);\n\n    repp(i, 1, 5000001) A[i] = A[i-1]*i%MOD;\n    B[5000000] = inv(A[5000000]);\n    repr(i, 5000000, 0) B[i] = B[i+1]*(i+1)%MOD;\n    \n    cin >> N >> M;\n    ll res = 0;\n    rep(i, min(N+1, M+1)) res = (res+calc(i))%MOD, debug(res);\n\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n#include <limits>\n#include <functional>\n#include <iomanip>\n#include <complex>\n#include <bitset>\n#include <stack>\nusing namespace std;\n \n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER) || __cplusplus > 199711L\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) __typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define ktya(x) sort(all(x))\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 1e18\n#define INFLL 1000000000000000007LL\n#define SIZE 200105\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define PI (acos(-1))\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntypedef pair<int,ll> pill; typedef pair<ll,int> plli; \ntypedef pair<double, int> pdi;\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }\ntypedef complex<double> P;\n//ll MOD = 1000000007;\nll MOD=998244353;\ntypedef ll Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\nint n,m;\nll bik[3114514];\nll bikinv[3114514];\nll gcd(ll a, ll b) {\n\treturn b != 0 ? gcd(b, a % b) : a;\n}\nll lcm(ll a, ll b) {\n\treturn a * b / gcd(a, b);\n}\n// a x + b y = gcd(a, b)\nll extgcd(ll a, ll b, ll &x, ll &y) {\n\tll g = a; x = 1; y = 0;\n\tif (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n\treturn g;\n}\nll invMod(ll a, ll m) {\n\tll x, y;\n\tif (extgcd(a, m, x, y) == 1) return (x + m) % m;\n\telse                         return 0; // unsolvable\n}\nvoid bikcal(int NN){\n\tll hoge=(ll)1;\n\tbik[0]=(ll)1;\n\tbikinv[0]=(ll)1;\n\tfor(int i=1;i<=NN;i++){\n\t\thoge=(hoge*i)%MOD;\n\t\tbik[i]=hoge;\n\t\tbikinv[i]=invMod(bik[i],MOD);\n\t}\n}\n\n\nll Comb(int a,int b){\n\tll ret;\n\tret=(((bik[a]*bikinv[b])%MOD)*bikinv[a-b])%MOD;\n\treturn ret;\n}\n\n\nll powMod(ll x, ll k, ll m) {//x^k (mod n)\n\tif (k == 0)     return 1;\n\tif (k % 2 == 0) return powMod(x*x % m, k/2, m);\n\telse            return x*powMod(x, k-1, m) % m;\n}\nint main(){\n\t\n\tcin>>n>>m;\n\t//cout<<\"ll\"<<endl;\n\tbikcal(3000000);\n\t//cout<<\"ll\"<<endl;\n\tll ans=0;\n\tans+=Comb(3*m+n-1,n-1);\n\tll hoge=(Comb(m+n-2,n-1)*n)%MOD;\n\tans-=hoge;\n\tans+=MOD;\n\tans%=MOD;\n\tfor(int i=m+1;i<=min(n,3*m);i++){\n\t\tif((3*m-i)%2==0){\n\t\t\tint m_d=(3*m-i)/2;\n\t\t\tll hoge=(Comb(m_d+n-1,n-1)*Comb(n,i))%MOD;\n\t\t\tans-=hoge;\n\t\t\tans+=MOD;\n\t\t\tans%=MOD;\n\t\t}\n\t\t\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 2e6 + 5;\nconst int mod = 998244353;\nlong long fac[maxn];\nlong long inv[maxn];\n\nvoid pre()\n{\n    fac[0] = fac[1] = 1;\n    inv[0] = inv[1] = 1;\n    for(int i=2; i< maxn; i++)\n    {\n        fac[i] = fac[i-1] * i % mod;\n        inv[i] = mod - (mod / i) * inv[mod%i] % mod;\n    }\n    for(int i=2; i<maxn; i++)\n    {\n        inv[i] = inv[i] * inv[i-1] % mod;\n    }\n}\n\nlong long C(int a, int b)\n{\n    if(a<b || b < 0) return 0;\n    return fac[a] * inv[b] %mod * inv[a-b] % mod;\n}\n\n\nint main() {\n\n    int n, m;\n    pre();\n    scanf(\"%d%d\", &n, &m);\n    long long ans=C(n+3*m-1,3*m);\n    //printf(\"%lld\\n\", ans);\n    for(int i=1; i<=n; i++)\n    {\n        long long tans = C(n,i);\n        tans = tans * C(n+ 3*m-1-i*(2*m+1),3*m-i*(2*m+1)) % mod;\n        //printf(\"%lld\\n\", tans);\n        if(i&1) ans = ans - tans;\n        else ans = ans + tans;\n    }\n    ans = (ans % mod + mod) % mod;\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 3000005\n#define INF 1000000000\n#define MOD 998244353\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint fact[MAXN],invf[MAXN];\nint N,M;\nvoid add(int &a,int b) {a+=b; if(a>=MOD) a-=MOD;}\nvoid dec(int &a,int b) {a-=b; if(a<0) a+=MOD;}\nint pow_mod(int a,int i)\n{\n    int s=1;\n    while(i)\n    {\n        if(i&1) s=1LL*s*a%MOD;\n        a=1LL*a*a%MOD;\n        i>>=1;\n    }\n    return s;\n}\nint comb(int n,int k)\n{\n    if(n<k) return 0;\n    return 1LL*fact[n]*invf[k]%MOD*invf[n-k]%MOD;\n}\nint main()\n{\n    fact[0]=invf[0]=1;\n    for(int i=1;i<=3000000;i++) fact[i]=1LL*fact[i-1]*i%MOD;\n    invf[3000000]=pow_mod(fact[3000000],MOD-2);\n    for(int i=2999999;i>=1;i--) invf[i]=1LL*invf[i+1]*(i+1)%MOD;\n    scanf(\"%d%d\",&N,&M);\n    int ans=0;\n    for(int i=0;i<=M;i++) if((3*M-i)%2==0) add(ans,1LL*comb(N,i)*comb((3*M-i)/2+N-1,N-1)%MOD);\n    for(int i=0;i<=M;i++) if((M-i)%2==0) dec(ans,1LL*N*comb(N,i)%MOD*comb((M-i)/2+N-1,N-1)%MOD);\n    for(int i=0;i<=M;i++) if((M-i)%2==0) add(ans,1LL*N*comb(N-1,i)%MOD*comb((M-i)/2+N-2,N-2)%MOD);\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQ-Automaton\nLANG: C++\nPROG: C.cpp\nMail: cnyalilk@vip.qq.com\n*/\n#include<bits/stdc++.h>\n#define int long long\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define inf 0x3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f3f\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T>int chkmin(T &a,T b){return a>b?a=b,1:0;}\ntemplate<class T>int chkmax(T &a,T b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T>T mmin(T a,T b){return a<b?a:b;}\ntemplate<class T>T mmax(T a,T b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\tinline bool read (signed &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\n\tinline bool read (long long &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\tx=gc();\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r')if(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\t// print a signed integer\n\tinline bool write (signed x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\n\tinline bool write (long long x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nconst int p=998244353;\nint fac[2000005],inv[2000005],invf[2000005],qwq[2000005];\nint C(int a,int b){return a<0||b<0||a<b?0:fac[a]*invf[b]%p*invf[a-b]%p;}\nint f(int a,int x,int y){\n\tint s=((C(a+(a-x)/2+y-1,y-1)-x*qwq[(a-x)/2]-((a-x)/2?(y-x)*qwq[(a-x)/2-1]:0))%p+p)%p;\n\treturn s;\n}\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"C.in\",\"r\",stdin);\n\tfreopen(\"C.out\",\"w\",stdout);\n#endif\n\tint n,m;\n\tread(n,m);\n\tfac[0]=fac[1]=inv[1]=invf[0]=invf[1]=1;\n\tfor(int i=2;i<=2000000;++i){\n\t\tfac[i]=fac[i-1]*i%p;\n\t\tinv[i]=(p-p/i)*inv[p%i]%p;\n\t\tinvf[i]=inv[i]*invf[i-1]%p;\n\t}\n\tqwq[0]=1;\n\tfor(int i=1;i<=1000000;++i)qwq[i]=(qwq[i-1]+C(i+n-2,n-2))%p;\n\tint ans=0;\n\tfor(int i=m;i>=0;i-=2){\n\t\tans=(ans+C(n,i)*f(m,i,n))%p;\n\t}\n\twrite(ans,'\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll, int> plli;\ntypedef pair<int, pii> pipii;\ntypedef vector<vector<int> > mati;\ntypedef vector<vector<double> > matd;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\ntypedef vector<bool> vb;\ntypedef vector<vector<bool>> vvb;\ntypedef vector<vector<vector<bool>>> vvvb;\ntypedef vector<pll> vpll;\n\n#define FOR(i,x,y) for(ll i=(ll)x; i<(ll)y; ++i)\n#define REP(i,y) FOR(i, 0, y)\n#define RFOR(i,x,y) for(ll i=(ll)x; i>=(ll)y; --i)\n#define RREP(i,x) RFOR(i, x, 0)\n#define ALL(a) a.begin(), a.end()\n#define pb push_back\n\ninline void IN(void){\n  return;\n}\n\ntemplate <typename First, typename... Rest>\nvoid IN(First& first, Rest&... rest){\n  cin >> first;\n  IN(rest...);\n  return;\n}\n\ninline void OUT(void){\n  cout << \"\\n\";\n  return;\n}\n\ntemplate <typename First, typename... Rest>\nvoid OUT(First first, Rest... rest){\n  cout << first << \" \";\n  OUT(rest...);\n  return;\n}\n\ntemplate <typename T>\nvoid vec_print(vector<T> VEC){\n  REP(i, VEC.size()){\n    cout << VEC[i] << \" \";\n  }\n  cout << \"\\n\";\n};\n\ntemplate <typename T>\nvoid mat_print(vector<vector<T> > MAT){\n  REP(i, MAT.size()){\n    REP(j, MAT[i].size()){\n      cout << MAT[i][j] << \" \";\n    }\n    cout << \"\\n\";\n  }\n};\n\ntemplate <typename CLASS1, typename CLASS2>\nclass HOGE{\n  public:\n    CLASS1 key;\n    CLASS2 value;\n    HOGE(void){\n      return;\n    };\n    HOGE(CLASS1 key, CLASS2 value){\n      this->key = key;\n      this->value = value;\n    };\n    ~HOGE(void){\n      return;\n    };\n\n    void print(void){\n      cout << \"key : \" << key << \", value : \" << value << \"\\n\";\n      return;\n    };\n    \n    bool operator==(const HOGE &obj){\n      return (this->value == obj.value);\n    };\n    bool operator<(const HOGE &obj){\n      return (this->value < obj.value);\n    };\n    bool operator>(const HOGE &obj){\n      return (this->value > obj.value);\n    };\n};\n\ntemplate <typename CLASS1, typename CLASS2>\nbool operator==(const HOGE<CLASS1, CLASS2> &hoge1, const HOGE<CLASS1, CLASS2> &hoge2){\n  return hoge1.value == hoge2.value;\n};\n\ntemplate <typename CLASS1, typename CLASS2>\nbool operator<(const HOGE<CLASS1, CLASS2> &hoge1, const HOGE<CLASS1, CLASS2> &hoge2){\n  return hoge1.value < hoge2.value;\n};\n\ntemplate <typename CLASS1, typename CLASS2>\nbool operator>(const HOGE<CLASS1, CLASS2> &hoge1, const HOGE<CLASS1, CLASS2> &hoge2){\n  return hoge1.value > hoge2.value;\n};\n\nconstexpr int INF = (1<<30);\nconstexpr ll INFLL = 1LL<<62;\nconstexpr long double EPS = 1e-12;\nconstexpr ll MOD = 998244353;\n\nll N,M;\nvvll dp;\nll MAX = 1000007;\nvll  fac_v(MAX);\nvll finv_v(MAX);\nvll  inv_v(MAX);\n\nll Comb(ll n, ll k){\n  if(n<k) return 0;\n  if(n<0 || k<0) return 0;\n  return (fac_v[n]*((finv_v[k]*finv_v[n-k])%MOD))%MOD;\n}\n\nll call_number(ll N, ll K){\n  //N個の番号なしの玉をK個の区別する箱に1個以上入れる場合の数\n  //= N-1個の隙間にK-1個の棒を入れる場合の数\n  if(N<K) return 0;\n  if(K<=0) return 0;\n  return Comb(N-1, K-1);\n}\n\nint main(){\n  cin.tie(0); // cut the cin and cout (default, std::flush is performed after std::cin)\n  ios::sync_with_stdio(false); // cut the iostream and stdio (DON'T endl; BUT \"\\n\";)\n\n  fac_v[0] = fac_v[1] = 1;\n  finv_v[0] = finv_v[1] = 1;\n  inv_v[1] = 1;\n  FOR(i,2,MAX){\n    fac_v[i] = (fac_v[i-1]*i)%MOD;\n    inv_v[i] = (MOD-(inv_v[MOD%i]*(MOD/i))%MOD)%MOD;\n    finv_v[i] = (finv_v[i-1]*inv_v[i])%MOD;\n  }\n\n  IN(N,M);\n\n  ll ans = call_number(3*M+N,N)%MOD;\n  FOR(i,2*M+1,3*M+1){\n    ans -= (N*call_number(3*M+(N-1)-i,(N-1)))%MOD;\n    ans = (ans+MOD)%MOD;\n  }\n  OUT(ans%MOD);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int mod = 998244353;\nint n,m;\n\nconst int N = 3e6;\nint fac[N+10],ifac[N+10];\ninline int Mod(int x){\n\treturn x>=mod?x-mod:x;\n}\ninline int power(int a,int b){\n\tint ret=1;\n\tfor (;b;b>>=1,a=1ll*a*a%mod) if (b&1) ret=1ll*ret*a%mod;\n\treturn ret;\n}\ninline void init(int n){\n\tfac[0]=1;\n\tFor(i,1,n) fac[i]=1ll*fac[i-1]*i%mod;\n\tifac[n]=power(fac[n],mod-2);\n\tDow(i,n-1,0) ifac[i]=1ll*ifac[i+1]*(i+1)%mod;\n}\ninline int C(int n,int m){\n\tif (n<m||m<0) return 0;\n\treturn 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\ninline int calc(int s,int n){\n\treturn C(s+n-1,n-1);\n}\ninline int calc(){\n\tint ret=0;\n\tFor(i,2*m+1,3*m) ret=(ret+1ll*n*calc(3*m-i,n-1))%mod;\n\treturn ret;\n}\n\ninline int calc_(){\n\tint ret=0;\n\tFor(i,0,min(n,m)){\n\t\tint j=3*m-i;\n\t\tif (j&1) continue;\n\t\tret=(ret+1ll*C(n,i)*calc(j/2,n))%mod;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tn=read(),m=read(),init(N);\n\tprintf(\"%d\\n\",Mod(calc_()+mod-calc()));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll p=998244353,jc[4000010],ny[4000010];\nll ksm(ll x,ll y){\n\tll xlh=1;\n\twhile(y){\n\t\tif(y&1)xlh=xlh*x%p;\n\t\tx=x*x%p;\n\t\ty/=2;\n\t}\n\treturn xlh;\n}\nll C(ll x,ll y){\n\treturn jc[x]*ny[y]%p*ny[x-y]%p;\n}\nll solve(ll n,ll zo,ll m){\n\tll i,ans=0,xlh,sy;\n\tfor(i=0;i<=m;i++)if(zo%2==i%2){\n\t\txlh=C(n,i);\n\t\tsy=zo-i;sy/=2;\n\t\txlh=xlh*C(sy-1+n,n-1)%p;\n\t\tans=(ans+xlh)%p;\n\t}\n\treturn ans;\n}\nint main(){\n\tll i,n,m;\n\tjc[0]=ny[0]=1;\n\tfor(i=1;i<=4000000;i++)jc[i]=jc[i-1]*i%p;\n\tny[4000000]=ksm(jc[4000000],p-2);\n\tfor(i=4000000-1;i;i--)ny[i]=ny[i+1]*(i+1)%p;\n\tscanf(\"%lld%lld\",&n,&m);\n\tprintf(\"%lld\",(solve(n,m*3,m)-n*(solve(n,m,m)-solve(n-1,m,m)+p)%p+p)%p);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\nint _max(int x, int y) {return x > y ? x : y;}\nint _min(int x, int y) {return x < y ? x : y;}\nconst int N = 1750001;\nconst int mod = 998244353;\nint read() {\n\tint s = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();\n\treturn s * f;\n}\nvoid put(int x) {\n\tif(x < 0) x = -x, putchar('-');\n\tif(x >= 10) put(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nint ans, jc[N], inv[N];\n\nint add(int x, int y) {\n\tx += y;\n\treturn x >= mod ? x - mod : x;\n}\nint dec(int x, int y) {\n\tx -= y;\n\treturn x < 0 ? x + mod : x;\n}\nint pow_mod(int a, int k) {\n\tint ans = 1;\n\twhile(k) {\n\t\tif(k & 1) ans = (LL)ans * a % mod;\n\t\ta = (LL)a * a % mod, k /= 2;\n\t} return ans;\n}\nint C(int n, int m) {\n\tif(n < m) return 0;\n\treturn (LL)jc[n] * inv[m] % mod * inv[n - m] % mod;\n}\n\nint main() {\n\tint n = read(), m = read();\n\tint lim = 3 * m / 2 + n - 1;\n\tjc[0] = 1; for(int i = 1; i <= lim; i++) jc[i] = (LL)jc[i - 1] * i % mod;\n\tinv[lim] = pow_mod(jc[lim], mod - 2); for(int i = lim; i >= 1; i--) inv[i - 1] = (LL)inv[i] * i % mod;\n\tfor(int i = 0; i <= m; i++) if((3 * m - i) % 2 == 0) ans = add(ans, (LL)C(n, i) * C((3 * m - i) / 2 + n - 1, n - 1) % mod);\n\tfor(int i = 0; i <= m; i++) if((m - i) % 2 == 0) ans = dec(ans, (LL)C(n, i) * C((m - i) / 2 + n - 1, n - 1) % mod * n % mod);\n\tfor(int i = 0; i <= m; i++) if((m - i) % 2 == 0) ans = add(ans, (LL)C(n - 1, i) * C((m - i) / 2 + n - 2, n - 2) % mod * n % mod);\n\tput(ans), puts(\"\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma target(\"avx\")\n#pragma optimize(\"O3\")\n#pragma optimize(\"unroll-loops\")\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <memory>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#define rep(i,n) for(int i=0;i<(lint)(n);i++)\n#define REP(i,n) for(int i=1;i<=(lint)(n);i++)\n#define all(V) V.begin(),V.end()\ntypedef long long lint;\ntypedef std::pair<lint, lint> P;\nconstexpr int INF = INT_MAX/2;\nconstexpr lint LINF = LLONG_MAX/2;\nconstexpr double eps = 1e-9;\nconstexpr double PI=3.141592653589793238462643383279;\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ninline lint gcd(lint a, lint b) {\n\twhile (b) {\n\t\tlint c = a;\n\t\ta = b; b = c % b;\n\t}\n\treturn a;\n}\ninline lint lcm(lint a, lint b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(lint n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\ntemplate<typename T>\nT mypow(T a, unsigned int b) {\n\tif (!b)return T(1);\n\tif (b & 1)return mypow(a, b - 1) * a;\n\tT memo = mypow(a, b >> 1);\n\treturn memo * memo;\n}\nlint modpow(lint a, lint b, lint m) {\n\tif (!b)return 1;\n\tif (b & 1)return modpow(a, b - 1, m) * a % m;\n\tlint memo = modpow(a, b >> 1, m);\n\treturn memo * memo % m;\n}\ntemplate<typename T>\nvoid printArray(std::vector<T>& vec) {\n\trep(i, vec.size() - 1)std::cout << vec[i] << \" \";\n\tstd::cout << vec.back() << std::endl;\n}\ntemplate<typename T>\nvoid printArray(T l, T r) {\n\tT rprev = r;\n\trprev--;\n\tfor (T i = l; i != rprev; i++) {\n\t\tstd::cout << *i << \" \";\n\t}\n\tstd::cout << *rprev << std::endl;\n}\ntemplate<unsigned int modulo = 998244353>\nclass ModInt {\n\tlint value;\npublic:\n\tModInt() : value(0) {}\n\ttemplate<typename T>\n\tModInt(T value = 0) : value(value) {\n\t\tif (value < 0)value = -(lint)(-value % modulo) + modulo;\n\t\tthis->value = value % modulo;\n\t}\n\tinline operator int()const { return value; }\n\tinline ModInt& operator+=(const ModInt& x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline ModInt operator-()const {\n\t\treturn ModInt(0) -= *this;\n\t}\n\tinline ModInt& operator-=(const ModInt& x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator*=(const ModInt& x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator/=(ModInt rhs) {\n\t\tint exp = modulo - 2;\n\t\twhile (exp) {\n\t\t\tif (exp & 1)*this *= rhs;\n\t\t\trhs *= rhs;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn *this;\n\t}\n\ttemplate<typename T> ModInt operator+(const T& rhs)const { return ModInt(*this) += rhs; }\n\ttemplate<typename T> ModInt& operator+=(const T& rhs) { return operator+=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator-(const T& rhs)const { return ModInt(*this) -= rhs; }\n\ttemplate<typename T> ModInt& operator-=(const T& rhs) { return operator-=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator*(const T& rhs)const { return ModInt(*this) *= rhs; }\n\ttemplate<typename T> ModInt& operator*=(const T& rhs) { return operator*=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator/(const T& rhs)const { return ModInt(*this) /= rhs; }\n\ttemplate<typename T> ModInt& operator/=(const T& rhs) { return operator/=(ModInt(rhs)); }\n};\ntemplate<unsigned int T>\nstd::istream& operator>>(std::istream& ist, ModInt<T>& x) {\n\tlint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\nint n,m;\nModInt<> fact[2000010],inv[2000010],memo[2000010];\nModInt<> comb(int a,int b){\n\tif(a<b)return 0;\n\treturn fact[a]*inv[a-b]*inv[b];\n}\nModInt<> comb2(int a,int b){\n\treturn comb(a+b-1,b-1);\n}\nint main(){\n\tstd::cin>>n>>m;\n\tfact[0]=1;\n\tREP(i,2000000)fact[i]=fact[i-1]*i;\n\tinv[2000000]=ModInt<>(1)/fact[2000000];\n\tfor(int i=1999999;i>=0;i--)inv[i]=inv[i+1]*(i+1);\n\trep(i,m+1){\n\t\tmemo[i]=memo[i-1]+comb2(i,n-1);\n\t}\n\tModInt<> ans=0;\n\tfor(int i=m;i>=0;i-=2){\n\t\tans+=comb(n,i)*(comb2((3*m-i)/2,n)-memo[(m-i)/2]*n);\n\t\tans+=comb(n-1,i)*comb2((m-i)/2,n-1)*n;\n\t}\n\tstd::cout<<ans<<std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T>\nbool chmin(T &a,T b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T>\nbool chmax(T &a,T b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}  \ntemplate< int mod >\nstruct ModInt {\n  ll x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\nusing modint = ModInt< MOD9 >;modint pow(ll n, ll x){return modint(n).pow(x);}\n//using modint=ld;\ntemplate< typename T >\nstruct Combination {\n  vector< T > _fact, _rfact, _inv;\n\n  Combination(ll sz) : _fact(sz + 1), _rfact(sz + 1), _inv(sz + 1) {\n    _fact[0] = _rfact[sz] = _inv[0] = 1;\n    for(ll i = 1; i <= sz; i++) _fact[i] = _fact[i - 1] * i;\n    _rfact[sz] /= _fact[sz];\n    for(ll i = sz - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n    for(ll i = 1; i <= sz; i++) _inv[i] = _rfact[i] * _fact[i - 1];\n  }\n\n  inline T fact(ll k) const { return _fact[k]; }\n\n  inline T rfact(ll k) const { return _rfact[k]; }\n\n  inline T inv(ll k) const { return _inv[k]; }\n\n  T P(ll n, ll r) const {\n    if(r < 0 || n < r) return 0;\n    return fact(n) * rfact(n - r);\n  }\n\n  T C(ll p, ll q) const {\n    if(q < 0 || p < q) return 0;\n    return fact(p) * rfact(q) * rfact(p - q);\n  }\n\n  T H(ll n, ll r) const {\n    if(n < 0 || r < 0) return (0);\n    return r == 0 ? 1 : C(n + r - 1, r);\n  }\n};\nusing Comb=Combination<modint>;\n\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  Comb comb(3000005);\n  ll n,m;cin>>n>>m;\n  modint ret=comb.H(n,3*m);\n  rep(i,m+1,3*m+1){\n    if(i>n)break;\n    ll d2=3*m-i;\n    if(d2&1)continue;\n    d2/=2;\n    ret-=comb.C(n,i)*comb.H(n,d2);\n  }\n  ret-=comb.H(n,m-1)*n;\n  if(m>=n)ret+=comb.C(n-1,m)*n;\n  cout<<ret<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\nusing ll = long long;\n\n// Fermat の小定理を用いた F_mod 上での逆元計算x^(mod-2), 蟻本p115\nll Inverse(ll x){\n    ll res = 1;\n    int n = mod - 2;\n    while(n > 0){\n        if(n & 1){\n            res = res * x % mod;\n        }\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    /*\n     * 全部の組み合わせから不可能なものを引く\n     * 不可能なのは\n     * 1. ある値が2Mより大きい\n     * 2. 値が奇数のものがM個より多い\n     * のどちらか, これらは背反(和は3Mより)\n     * 奇数に1を1回, 最大の数から2を割り振れば構成できる\n     */\n\n    // 階乗計算, iの階乗 = fact[i}\n    vector<ll>fact(3 * M + N);\n    fact[0]=1;\n    for(int i=1; i < 3 * M + N; i++){\n        fact[i] = fact[i-1] * i % mod;\n    }\n\n    ll ans = fact[3*M+N-1] * Inverse(fact[N-1] * fact[3*M] % mod);\n    ans %= mod;\n\n\n    // ある値が2Mより大きい場合, 他の値の合計で回す\n    ll over = 0;\n    for (int i = 0; i < M; ++i) {\n        over = over + fact[i+N-2] * Inverse(fact[N-2] * fact[i] % mod);\n        over %= mod;\n    }\n    over = over * (N-1);\n    over %= mod;\n    ans = ans + mod - over;\n    ans %= mod;\n\n\n    // 値が奇数のものがM個より多い場合, 奇数の個数で回す\n    ll many = 0;\n    for (int i = M+1; i < N+1; ++i) {\n        if((3 * M - i) % 2 == 1) continue;\n        ll temp = 0;\n        int sum = (3 * M - i) / 2;\n        temp = temp + fact[sum+N-1] * Inverse(fact[N-1] * fact[sum] % mod);\n        temp %= mod;\n        temp = temp * fact[N];\n        temp %= mod;\n        temp = temp * Inverse(fact[i] * fact[N-i] % mod);\n        temp %= mod;\n        many += temp;\n        many %= mod;\n    }\n    ans = ans + mod - many;\n    ans %= mod;\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\n\n// template {{{  0 \n// using {{{ 1\nusing ll = long long int;\nusing pii = pair<int,int>;\nusing pll = pair<ll,ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vii = vector<pii>;\nusing vll = vector<pll>;\n// }}} 1\n// definition {{{ 1\n// scaning {{{ 2\n#define Scd(x) scanf(\"%d\", &x)\n#define Scd2(x,y) scanf(\"%d%d\", &x, &y)\n#define Scd3(x,y,z) scanf(\"%d%d%d\", &x, &y, &z)\n#define Scll(x) scanf(\"%lld\", &x)\n#define Scll2(x,y) scanf(\"%lld%lld\", &x, &y)\n#define Scll3(x,y,z) scanf(\"%lld%lld%lld\", &x, &y, &z)\n#define Scc(c) scanf(\"%c\", &c);\n#define Scs(s) scanf(\"%s\", s);\n#define Scstr(s) scanf(\"%s\", &s);\n// }}} 2\n// constants {{{ 2\n#define EPS (1e-7)\n#define INF (2e9)\n#define PI (acos(-1))\n// }}} 2\n// systems {{{ 2\n#define Repe(x,y,z) for(ll x = z; x < y; x++)\n#define Rep(x,y) Repe(x,y,0)\n#define RRepe(x,y,z) for(ll x = y-z-1; x >= 0; x--)\n#define RRep(x,y) RRepe(x,y,0)\n// }}} 2\n// output {{{ 2\n#define YesNo(a) (a)?printf(\"Yes\\n\"):printf(\"No\\n\")\n#define YESNO(a) (a)?printf(\"YES\\n\"):printf(\"NO\\n\")\n// }}} 2\n// }}} 1\n// input {{{ 1\n// }}} 1\n// }}} 0\n\nconst long long int mod = 998244353;\n\n// PowMod( base, index, modulo) return base ** index % modulo {{{\n// PowMod = base ** index % mod ( natural numbers )\ninline constexpr long long int PowMod( long long int base, long long int index, long long int modulo = mod ){\n    if( index == 0 ) return 1;\n    // O( log(index) )\n    if( index % 2 ){\n        return base * PowMod(base, index - 1, modulo) % modulo;\n    }else{\n        long long int Phalf = index / 2;\n        long long int half = PowMod(base, Phalf, modulo);\n        return half * half % modulo;\n    }\n}\n// }}}\n// CombMod( n, r, modulo ) return nCr % modulo {{{\n// CombMod(ination) = nCr % mod ( natural number )\ninline constexpr long long int CombMod( long long int n, long long int r, long long int modulo = mod){\n    if( n < r ) return CombMod(r,n,modulo);\n    long long int Upper = 1;\n    long long int Lower = 1;\n    for(long long int i = 0; i < r; i++){\n        Upper = Upper * (n-i) % modulo;\n        Lower = Lower * (i+1) % modulo;\n    }\n    // Return (Upper / Lower)\n    long long int ret = Upper * PowMod(Lower,modulo-2,modulo) % modulo;\n    return ret;\n}\n// }}}\n// FactMod( n, modulo ) return n! % modulo {{{\n// Fact(orial) = n! % mod ( natural number )\ninline constexpr long long int Fact( long long int n, long long int modulo = mod){\n    long long int Upper = 1;\n    for(long long int i = 0; i < n; i++){\n        Upper = Upper * (n-i) % modulo;\n    }\n    return Upper;\n}\n// }}}\n// modint {{{\n\nstruct modint{\n    long long int a;\n    inline constexpr modint( long long int x = 0 ) noexcept : a(x % mod) {}\n    inline constexpr long long int &value() noexcept { return a; }\n    inline constexpr const long long int &value() const noexcept { return a; }\n    inline constexpr modint operator+(const modint rhs) const noexcept{ return modint(*this) += rhs; }\n    inline constexpr modint operator+(const int rhs) const noexcept{ return modint(*this) += rhs; }\n    inline constexpr modint operator+(const long long int rhs) const noexcept{ return modint(*this) += rhs; }\n    inline constexpr modint operator-(const modint rhs) const noexcept{ return modint(*this) -= rhs; }\n    inline constexpr modint operator-(const int rhs) const noexcept{ return modint(*this) -= rhs; }\n    inline constexpr modint operator-(const long long int rhs) const noexcept{ return modint(*this) -= rhs; }\n    inline constexpr modint operator*(const modint rhs) const noexcept{ return modint(*this) *= rhs; }\n    inline constexpr modint operator*(const int rhs) const noexcept{ return modint(*this) *= rhs; }\n    inline constexpr modint operator*(const long long int rhs) const noexcept{ return modint(*this) *= rhs; }\n    inline constexpr modint operator/(const modint rhs) const noexcept{ return modint(*this) /= rhs; }\n    inline constexpr modint operator/(const int rhs) const noexcept{ return modint(*this) /= rhs; }\n    inline constexpr modint operator/(const long long int rhs) const noexcept{ return modint(*this) /= rhs; }\n    inline constexpr modint operator+=(const modint rhs) noexcept{ a += rhs.a; if( a >= mod ) a -= mod; return *this; }\n    inline constexpr modint operator-=(const modint rhs) noexcept{ a -= rhs.a; if( a < 0 ) a += mod; return *this; }\n    inline constexpr modint operator*=(const modint rhs) noexcept{ a = a * rhs.a % mod ;  return *this; }\n    inline constexpr modint operator/=(const modint rhs) noexcept{ a = a * PowMod(rhs.a,mod-2) % mod; return *this; }\n};\n\n// }}}\n\n\nint main() {\n\n    ll N,M;\n    Scll2(N,M);\n\n    vector<modint> f(N+3*M+3,1);\n    vector<modint> fr(N+3*M+3,1);\n\n    Rep(i,f.size()-1){\n        f[i+1] = f[i] * (i+1);\n        fr[i+1] = fr[i] / (i+1);\n    }\n\n    modint ans = f[N+3*M-1]*fr[3*M]*fr[N-1];\n    modint t;\n\n    for( int i = 2*M+1; i < 3*M+1; i++ ){\n        t = f[N+3*M-i-2]*fr[3*M-i]*fr[N-2]*N;\n        ans -= t;\n    }\n\n    printf (\"%lld\\n\", ans );\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// base: https://atcoder.jp/contests/agc036/submissions/7937408\n// hint: https://www.youtube.com/watch?v=eFQGwwdAVWg\n\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <unordered_map>\n#include <vector>\n#include <string.h>\n#include <set>\n\nusing namespace std;\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\n#define rep(i, n) for(int i = 0; i < n; ++i)\n#define all(s) s.begin(), s.end()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> triple;\ntypedef double D;\n\nconst ll INF = 1e9;\nconst ll MOD = 998244353;\n\nll powmod(ll x, ll n) { // like pow(x, n)\n  ll r = 1;\n  while (n) {\n    if (n & 1) {\n      r = r * x % MOD;\n    }\n    x = x * x % MOD;\n    n >>= 1;\n  }\n  return r;\n}\n\n// Mod int\n// cf. https://www.youtube.com/watch?v=1Z6ofKN03_Y\nstruct mint {\n  ll x;\n  mint(ll x = 0) : x((x + MOD) % MOD) {}\n  mint& operator+= (const mint a) {\n    if ((x += a.x) >= MOD) x %= MOD;\n    return *this;\n  }\n  mint operator+ (const mint a) const {\n    mint res(*this);\n    return res += a;\n  }\n  mint& operator-= (const mint a) {\n    if ((x += MOD - a.x) >= MOD) x %= MOD;\n    return *this;\n  }\n  mint operator- (const mint a) const {\n    mint res(*this);\n    return res -= a;\n  }\n  mint& operator*= (const mint a) {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  mint operator* (const mint a) const {\n    mint res(*this);\n    return res *= a;\n  }\n  mint pow(ll t) const {\n    if (!t) { return 1; }\n    mint a = pow(t >> 1);\n    a *= a;\n    if (t & 1) a *= *this;\n    return a;\n  }\n\n  // for prime mod\n  mint inv() const {\n    return pow(MOD-2);\n  }\n  mint& operator/= (const mint a) {\n    return (*this) *= a.inv();\n  }\n  mint operator/ (const mint a) const {\n    mint res(*this);\n    return res /= a;\n  }\n};\n\n// Combination mod prime.\n// cf. https://www.youtube.com/watch?v=1Z6ofKN03_Y\nstruct Combination {\n  vector<mint> fact, ifact;\n  Combination(int n) { init(n); }\n  void init(int n) {\n    assert(n < MOD); // n must be lower than MOD.\n\n    fact.resize(n + 1);\n    ifact.resize(n + 1);\n\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++i) { fact[i] = fact[i-1] * i; }\n    ifact[n] = fact[n].inv();\n    for (int i = n; i >= 1; --i) { ifact[i-1] = ifact[i] * i; }\n  }\n  mint operator() (int n, int k) const {\n    if (k < 0 || k > n) { return 0; }\n    return fact[n] * ifact[k] * ifact[n-k];\n  }\n  mint perm(int n, int k) const {\n    if (k < 0 || k > n) { return 0; }\n    return fact[n] * ifact[n-k];\n  }\n};\n\nCombination c(0);\n\n// The number of even is n, the sum is m, the variaety of the number of odd is 0..k.\nmint f(ll n, ll m, ll k) {\n  mint res = 0;\n  for (int a = m % 2; a <= k; a += 2) {\n    res += c(n, a) * c((m-a)/2+n-1, n-1);\n  }\n  return res;\n}\n\nint main(int argc, char** argv) {\n  int N, M;\n  cin >> N >> M;\n\n  c.init(3 * M + N);\n\n  mint ans = f(N, 3 * M, M) - (f(N, M, M) - f(N-1, M, M)) * N;\n  cout << ans.x << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int INF=1e9;\n//const int MOD=1e9+7;\nconst int MOD=998244353;\nconst long long LINF=1e18;\nusing namespace std;\n#define int long long\n//template\nstd::vector<int> Factorial(1e6),Finverse(1e6);\nint pw(int n,int k){\n  if(k<0)return pw(n,k+MOD-1);\n  int res=1;\n  while(k){\n    if(k&1)res*=n;res%=MOD;\n    n*=n;n%=MOD;\n    k>>=1;\n  }\n  return res;\n}\nvoid Cinit(){\n  Factorial[0]=1;\n  for(int i=1;i<1e6;i++)Factorial[i]=Factorial[i-1]*i%MOD;\n  for(int i=0;i<1e6;i++)Finverse[i]=pw(Factorial[i],MOD-2);\n}\nint nCk(int n,int k){\n  if(n<k)return 1;if(k<0)return 0;\n  int res=Factorial[n];\n  res*=Finverse[k];res%=MOD;\n  res*=Finverse[n-k];res%=MOD;\n  return res;\n}\n//main\nsigned main(){\n  Cinit();\n  int N,M;cin>>N>>M;\n  int ans=nCk(3*M+(N-1),N-1);//cout<<ans<<endl;\n  int mi=N*nCk(M-1+N-1,N-1)%MOD;\n  ans-=mi;\n  ans+=MOD;ans%=MOD;\n  //cout<<ans<<endl;\n  for(int i=M+1;i<=min(N,3*M);i++){\n    if((i&1)!=((3*M)&1))continue;\n    int p=(3*M-i)/2;\n    int q=nCk(p+N-1,N-1);\n    int s=nCk(N,i);\n    int a=q*s%MOD;\n    ans-=a;\n    ans+=MOD;ans%=MOD;\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 2500010, P = 998244353;\nint n, m, fact[maxn], inv[maxn];\n\nint qp(int x, int y) {\n    int z = 1;\n    for (; y; y >>= 1, x = 1LL * x * x % P) {\n        if (y & 1) z = 1LL * z * x % P;\n    }\n    return z;\n}\n\nint C(int x, int y) {\n    return 1LL * fact[x] * inv[x - y] % P * inv[y] % P;\n}\n\nint main() {\n    for (int i = fact[0] = inv[0] = 1; i < maxn; i++) {\n        inv[i] = qp(fact[i] = 1LL * i * fact[i - 1] % P, P - 2);\n    }\n    scanf(\"%d %d\", &n, &m);\n    int ans = (C(3 * m + n - 1, n - 1) - 1LL * n\n        * C(m + n - 2, n - 2) % P + P) % P;\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define ll long long\nusing ull = unsigned long long;\nusing namespace std;\nconst int INF = 1ll << 50;\nconst int MOD = 998244353;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define bit(n, k) ((n >> k) & 1) /*nのk bit目*/\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\nvoid Yes(bool flag = true) {\n    if (flag)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n}\nvoid No(bool flag = true) {\n    Yes(!flag);\n}\nvoid YES(bool flag = true) {\n    if (flag)\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\nvoid NO(bool flag = true) {\n    YES(!flag);\n}\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define vi vector<int>\n//#define P pair<int, int>\n//#define V vector<int>\n//#define S set<int>\n#define itn int\nbool dbg = false;\ntemplate <uint MD>\nstruct ModInt {\n    using M = ModInt;\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(_v % MD + MD); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(ull(v) * r.v % MD); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1)\n                r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\nusing Mint = ModInt<MOD>;\n//Template by yosupo\nconst int MN = 2'501'000;\nMint fact[MN], iFac[MN];\n\nvoid first() {\n    fact[0] = Mint(1);\n    for (int i = 1; i < MN; i++)\n        fact[i] = fact[i - 1] * Mint(i);\n    iFac[MN - 1] = fact[MN - 1].inv();\n    for (int i = MN - 1; i >= 1; i--) {\n        iFac[i - 1] = iFac[i] * Mint(i);\n    }\n    assert(fact[2345] * iFac[2345] == Mint(1));\n}\nMint C(int n, int k) {\n    if (n < k || k < 0)\n        return Mint(0);\n    return fact[n] * iFac[k] * iFac[n - k];\n}\n\n\nint N, M;\n\nvoid solve() {\n    first();\n    Mint ans = 0;\n    for (int m = M % 2; m <= min(M, N); m += 2) {\n        Mint tmp = C(N, m);\n        int R = (M - m) / 2 + M;\n        tmp *= C(N + R - 1, N - 1);\n\n        Mint tmp2 = C(N + R - M - 1, N - 1) * m * C(N, m);\n        Mint tmp3 = C(N + R - M - 2, N - 1) * (N - m) * C(N, m);\n        //cerr << tmp << \" \" << tmp2 << \" \" << tmp3 << endl;\n        tmp -= tmp2 + tmp3;\n        ans += tmp;\n    }\n    cout << ans << endl;\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cin >> N >> M;\n\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll p=998244353,jc[4000010],ny[4000010];\nll ksm(ll x,ll y){\n\tll xlh=1;\n\twhile(y){\n\t\tif(y&1)xlh=xlh*x%p;\n\t\tx=x*x%p;\n\t\ty/=2;\n\t}\n\treturn xlh;\n}\nll C(ll x,ll y){\n\treturn jc[x]*ny[y]%p*ny[x-y]%p;\n}\nll solve(ll n,ll zo,ll m){\n\tll i,ans=0,xlh,sy;\n\tfor(i=0;i<=m;i++)if(zo%2==i%2){\n\t\txlh=C(n,i);\n\t\tsy=zo-i;sy/=2;\n\t\txlh=xlh*C(sy-1+n,n-1)%p;\n\t\tans=(ans+xlh)%p;\n\t}\n\treturn ans;\n}\nint main(){\n\tll i,n,m;\n\tjc[0]=ny[0]=1;\n\tfor(i=1;i<=4000000;i++)jc[i]=jc[i-1]*i%p;\n\tny[4000000]=ksm(jc[4000000],p-2);\n\tfor(i=4000000-1;i;i--)ny[i]=ny[i+1]*(i+1)%p;\n\tscanf(\"%lld%lld\",&n,&m);\n\tprintf(\"%lld\",solve(n,m*3,m)-n*(solve(n,m,m)-solve(n-1,m,m)+p)%p);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong N,M,mod=998244353;\nlong F[1<<25],I[1<<25];\nlong power(long a,long b){return b?power(a*a%mod,b/2)*(b%2?a:1)%mod:1;}\nlong C(long a,long b)\n{\n\treturn a<b||a<0||b<0?0:F[a]*I[b]%mod*I[a-b]%mod;\n}\nlong H(long a,long b){return a<0?0:C(a+b-1,b-1);}\nlong calc(long n,long m,long s)\n{\n\tlong ret=0;\n\tfor(int i=0;i<=n&&i<=m;i++)\n\t{\n\t\tif(s-i&1)continue;\n\t\t(ret+=C(n,i)*H((s-i)/2,n)%mod)%=mod;\n\t}\n\treturn ret;\n}\nmain()\n{\n\tcin>>N>>M;\n\tlong T=2*M+N;\n\tF[0]=1;\n\tfor(long i=1;i<T;i++)F[i]=F[i-1]*i%mod;\n\tI[T-1]=power(F[T-1],mod-2);\n\tfor(long i=T-1;i--;)I[i]=I[i+1]*(i+1)%mod;\n\tcout<<(calc(N,M,3*M)-calc(N,M,M)*N%mod+calc(N-1,M,M)*N%mod+mod)%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=4001000,mod=998244353;\ninline void Add(int &a,int b){a=a+b>=mod?a+b-mod:a+b;}\ninline int ksm(int a,int b)\n{\n\tint res=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod) if(b&1) res=1ll*res*a%mod;\n\treturn res;\n}\nint fac[maxn],invfac[maxn];\ninline int C(int n,int m){return 1ll*fac[n]*invfac[m]%mod*invfac[n-m]%mod;}\nint n,m;\ninline int cal(int n,int m,int lim)\n{\n\tint ans=0;\n\tfor(int i=0;i<=min(n,lim);i++) if(!((m-i)&1))\n\t\tAdd(ans,1ll*C(n,i)*C((m-i)/2+n-1,n-1)%mod);\n\treturn ans;\n}\nint main()\n{\n\tfor(int i=fac[0]=1;i<maxn;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tinvfac[maxn-1]=ksm(fac[maxn-1],mod-2);\n\tfor(int i=maxn-2;i>=0;i--) invfac[i]=1ll*invfac[i+1]*(i+1)%mod;\n\tcin>>n>>m;printf(\"%lld\\n\",(cal(n,3*m,m)-1ll*n*cal(n,m,m)%mod+1ll*n*cal(n-1,m,m)%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int P = 998244353;\n\nstruct modint {\n    int x;\n    inline modint(int x = 0) : x(x) {}\n    inline modint &operator = (int o) { return x = o, *this; }\n    inline modint &operator += (modint o) { return (x += o.x) >= P && (x -= P), *this; }\n    inline modint &operator -= (modint o) { return (x -= o.x) < 0 && (x += P), *this; }\n    inline modint &operator *= (modint o) { return x = 1ll * x * o.x % P, *this; }\n    template <class I>\n    inline modint &operator ^= (I b) {\n        modint a = *this, c;\n        if (!~b) b = P - 2;\n        c.x = 1 % P;\n        while (b) {\n            if (b & 1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return x = c.x, *this;\n    }\n    inline modint &operator /= (modint o) { return *this *= o ^ -1; }\n    inline modint &operator += (int o) { return (x += o) >= P && (x -= P), *this; }\n    inline modint &operator -= (int o) { return (x -= o) < 0 && (x += P), *this; }\n    inline modint &operator *= (int o) { return x = 1ll * x * o % P, *this; }\n    inline modint &operator /= (int o) { return *this *= (modint)o ^ -1; }\n    template <class I>\n    inline friend modint operator + (modint a, I b) { return a += b; }\n    template <class I>\n    inline friend modint operator - (modint a, I b) { return a -= b; }\n    template <class I>\n    inline friend modint operator * (modint a, I b) { return a *= b; }\n    template <class I>\n    inline friend modint operator ^ (modint a, I b) { return a ^= b; }\n    template <class I>\n    inline friend modint operator / (modint a, I b) { return a /= b; }\n    inline friend bool operator == (modint a, int b) { return a.x == b; }\n    inline friend bool operator != (modint a, int b) { return a.x != b; }\n    inline friend bool operator < (modint a, int b) { return a.x < b; }\n    inline friend bool operator <= (modint a, int b) { return a.x <= b; }\n    inline friend bool operator > (modint a, int b) { return a.x > b; }\n    inline friend bool operator >= (modint a, int b) { return a.x >= b; }\n    inline friend bool operator == (modint a, modint b) { return a.x == b.x; }\n    inline friend bool operator != (modint a, modint b) { return a.x != b.x; }\n    inline friend bool operator < (modint a, modint b) { return a.x < b.x; }\n    inline friend bool operator <= (modint a, modint b) { return a.x <= b.x; }\n    inline friend bool operator > (modint a, modint b) { return a.x > b.x; }\n    inline friend bool operator >= (modint a, modint b) { return a.x >= b.x; }\n    inline bool operator ! () { return !x; }\n    inline modint operator - () { return x ? P - x : 0; }\n};\ninline void rd(modint &x) { rd(x.x); }\ninline void print(modint x, char k = '\\n') { print(x.x, k); }\n\nconst int NP = 1e7 + 7;\nmodint p[NP], v[NP], vp[NP];\ninline void init(int n) {\n  p[0] = v[0] = 1;\n  for (int i = 1; i <= n; i++) p[i] = p[i-1] * i;\n  vp[n] = 1 / p[n];\n  for (int i = n; i; i--) v[i] = vp[i] * p[i-1], vp[i-1] = vp[i] * i;\n}\ninline modint binom(int n, int m) {\n  return (m < 0 || n < m) ? 0 : p[n] * vp[m] * vp[n-m];\n}\n\nint n, m;\nmodint ans;\n\nint main() {\n\trd(n, m), init(n + 3 * m / 2);\n\tfor (int k = m; k <= 3 * m / 2; k++) {\n\t\tint b = 3 * m - 2 * k, a = n - b;\n\t\tif (a < 0 || b < 0) continue;\n\t\tans += binom(n, a) * (binom(n + k - 1, n - 1) - a * binom(n + k - m - 2, n - 1) - b * binom(n + k - m - 1, n - 1));\n\t}\n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_N 3000000\n#define mod 998244353\nusing namespace std;\nlong long int Fact[MAX_N+1];\nlong long int Finv[MAX_N+1];\nlong long int inv(long long int a){\n    long long int b=mod,u=1,v=0;\n    while(b){\n        long long int t=a/b;\n        a-=t*b;swap(a,b);\n        u-=t*v;swap(u,v);\n    }\n    u%=mod;\n    if(u<0)u+=mod;\n    return u;\n}\nlong long int C(int n,int k){\n    return Fact[n]*Finv[n-k]%mod*Finv[k]%mod;\n}\nint main(void){\n    int N,M;\n    cin>>N>>M;\n    Fact[0]=1;\n    Finv[0]=1;\n    for(int i=0;i<MAX_N;i++){\n        Fact[i+1]=(Fact[i]*(i+1))%mod;\n        Finv[i+1]=inv(Fact[i+1]);\n    }\n    long long int ans=C(N+3*M-1,3*M);\n    for(int k=0;k<M;k++){\n        ans-=(N*C(N+M-k-3,M-k-1))%mod;\n        ans%=mod;\n        if(ans<0){\n            ans+=mod;\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n////////////\n// ModInt //\n////////////\n\n// 四則演算の最も左に存在する値がModIntでなければキャストでバグる\n// 例えばx = mint * 1000;やx = ModInt(1000) * mint;はいいがx = 1000 * mint;は駄目。\ntemplate<int64_t mod_ = 1'000'000'007>\nclass ModInt {\nprivate:\n\tint64_t integer_;\n\npublic:\n\tconstexpr ModInt(const int64_t initial_number = 0)\n\t\t: integer_(initial_number){}\n\t\n\t// 四則演算\n\tconstexpr ModInt operator+(const ModInt& operand) const\n\t{\n\t\tModInt ret{this->integer_ + operand.integer_};\n\t\tif (ret.integer_ >= mod_)\n\t\t\tret.integer_ -= mod_;\n\t\treturn ret;\n\t}\n\tconstexpr ModInt operator-(const ModInt& operand) const\n\t{\n\t\tModInt ret{this->integer_ - operand.integer_};\n\t\tif (ret.integer_ < 0)\n\t\t\tret.integer_ += mod_;\n\t\treturn ret;\n\t}\n\tconstexpr ModInt operator*(const ModInt& operand) const\n\t{\n\t\treturn {this->integer_ * operand.integer_ % mod_};\n\t}\n\tconstexpr ModInt operator/(const ModInt& operand) const\n\t{\n\t\treturn *this * (operand ^ (mod_ - 2));\n\t}\n\n\t// 累乗\n\tconstexpr ModInt operator^(const int64_t operand) const\n\t{\n\t\tModInt ret{1}, pow_ope{this->integer_};\n\t\tfor (int64_t pow{operand}; pow > 0; pow >>= 1)\n\t\t{\n\t\t\tif (pow & 1) ret *= pow_ope;\n\t\t\tpow_ope *= pow_ope;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t// 代入\n\tconstexpr ModInt& operator=(const ModInt& operand)\n\t{\n\t\tthis->integer_ = operand.integer_;\n\t\treturn *this;\n\t}\n\tconstexpr ModInt& operator+=(const ModInt& operand)\n\t{\n\t\t*this = *this + operand;\n\t\treturn *this;\n\t}\n\tconstexpr ModInt& operator-=(const ModInt& operand)\n\t{\n\t\t*this = *this - operand;\n\t\treturn *this;\n\t}\n\tconstexpr ModInt& operator*=(const ModInt& operand)\n\t{\n\t\t*this = *this * operand;\n\t\treturn *this;\n\t}\n\tconstexpr ModInt& operator/=(const ModInt& operand)\n\t{\n\t\t*this = *this / operand;\n\t\treturn *this;\n\t}\n\n\t// その他\n\tconstexpr operator int64_t() { return integer_; }\n\n\tconstexpr ModInt getOne() const\n\t{\n\t\treturn ModInt(1ll);\n\t}\n\tconstexpr ModInt getZero() const\n\t{\n\t\treturn ModInt(0ll);\n\t}\n};\n\n////////////////\n// 組み合わせ //\n///////////////\n\ntemplate<int64_t mod_ = 1'000'000'007, int max_ = 200'000>\nclass Combination {\npublic:\n\tstd::array<ModInt<mod_>, max_ + 1> inv, fact, finv;\n\n\tCombination()\n\t{\n\t\tinv[0] = inv[1] = fact[0] = fact[1] = finv[0] = finv[1] = 1;\n\t\tfor (int num{2}; num <= max_; num++)\n\t\t{\n\t\t\tinv[num] = (mod_ - (int64_t)inv[mod_ % num] * (mod_ / num) % mod_) % mod_;\n\t\t\tfact[num] = num * fact[num - 1] % mod_;\n\t\t\tfinv[num] = inv[num] * finv[num - 1] % mod_;\n\t\t}\n\t}\n\n\tModInt<mod_> getCombi(const int n, const int r)\n\t{\n\t\tif (r < 0 || n < 0 || n - r < 0) return 0;\n\t\treturn fact[n] * finv[r] * finv[n - r];\n\t}\n\n\tModInt<mod_> getPerm(const int n, const int r)\n\t{\n\t\tif (r < 0 || n < 0 || n - r < 0) return 0;\n\t\treturn fact[n] * finv[n - r];\n\t}\n};\nconstexpr int64_t mod{998'244'353};\nCombination<mod, 3'000'000> combi;\nusing Mint = ModInt<mod>;\n\nint main()\n{\n\tint N, M;\n\tscanf(\"%d%d\", &N, &M);\n\t// 3*M+N-1 C N-1 - (M+N-1 C N-1 - M+N-2 C N-2) * N\n\tMint ans;\n\tfor (int i{M & 1}; i <= N && i <= M; i += 2)\n\t\tans += combi.getCombi(N, i) * combi.getCombi((3 * M - i) / 2 + N - 1, N - 1);\n\tans -= (combi.getCombi(M + N - 1, N - 1) - combi.getCombi(M + N - 2, N - 2)) * Mint(N);\n\tstd::cout << ans << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//ios::sync_with_stdio(false);\n#include<bits/stdc++.h>\n#define LL long long\n#define F(x,y,z) for(int x=y;x<=z;++x)\n#define D(x,y,z) for(int x=y;x>=z;--x)\nusing namespace std;\nconst int Mod=998244353;\nconst int N=3000010;\nconst int maxn=3000001;\nLL Min(LL x,LL y){return x<y?x:y;}\nLL Max(LL x,LL y){return x>y?x:y;}\nLL R(){\n    LL ans=0,f=1;char c=getchar();\n    for(;c<'0'||c>'9';c=getchar()) if (c=='-') f=-1;\n    for(;c>='0'&&c<='9';c=getchar()) ans=ans*10+c-'0';\n    return ans*f;\n}\nLL jc[N],ni[N],n,m;\nLL C(LL n,LL m){return jc[n]*ni[m]%Mod*ni[n-m]%Mod;}\nLL Calc(LL n,LL m,LL js){\n\tLL ans=0;\n\tint ma=min(n,m);\n\tF(i,0,ma){\n\t\tif((i+m)&1)continue;\n\t\tans+=C(n,i)*C(js+(m-i)/2+n-1,n-1);\n\t\tans%=Mod;\n\t}\n\treturn ans;\n}\nLL Pow(LL x,LL bs){\n\tLL an=1;\n\tfor(;bs;bs>>=1,x=x*x%Mod)\n\t\tif(bs&1)an=an*x%Mod;\n\treturn an; \n}\nvoid Pre(){\n\tjc[0]=ni[0]=1;\n\tF(i,1,maxn)jc[i]=jc[i-1]*i%Mod;\n\tni[maxn]=Pow(jc[maxn],Mod-2);\n\tD(i,maxn-1,1)ni[i]=ni[i+1]*(i+1)%Mod;\n}\nint main(){\n\tPre();\n\tn=R();m=R();\n\tLL ans=Calc(n,m,m);\n\tans-=n*(Calc(n,m,0)-Calc(n-1,m,0));\n\tans%=Mod;ans+=Mod;ans%=Mod;\n\tcout<<ans<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define p_ary(ary,a,b,i) do { cout << \"[\"; for (int (i) = (a);(i) < (b);++(i)) cout << ary[(i)] << ((b)-1 == (i) ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\n// const ll mod = 1000000007;\nconst ll mod = 998244353;\n\nconst int MAX_N = 2500020;\nll fact[MAX_N],fact_inv[MAX_N],inv[MAX_N];\n\nll pow_mod(ll a,ll b) {\n    ll ret;\n    if (b < 0) ret = pow_mod(a,mod+b-1);\n    else if (b == 0) ret = 1;\n    else if (b == 1) ret = a;\n    else {\n        ll c = pow_mod(a,b/2);\n        if (b%2) ret = (c*c)%mod*a%mod;\n        else ret = c*c%mod;\n    }\n    return ret;\n}\n\nvoid create_table(int n) {\n    fact[0] = 1;fact[1] = 1;\n    for (int i = 2;i <= n;++i) fact[i] = fact[i-1]*i%mod;\n    fact_inv[n] = pow_mod(fact[n],-1);\n    for (int i = n;i > 0;--i) fact_inv[i-1] = fact_inv[i]*i%mod;\n    for (int i = 1;i <= n;++i) inv[i] = fact_inv[i]*fact[i-1]%mod;\n}\n\nll combi(ll a, ll b) {\n    return fact[a]*fact_inv[b]%mod*fact_inv[a-b]%mod;\n}\n\nint main() {\n    int n,m;\n    cin >> n >> m;\n    create_table(2500010);\n    ll ans = combi(n+3*m-1,3*m);\n    for (int i = 0;i < m;++i) {\n        (ans -= n*combi(n-1+i-1,i)) %= mod;\n    }\n    for (int i = m+1;i <= min(n,3*m);++i) if ((3*m-i)%2 == 0) {\n        (ans -= combi(n,i)*combi(n+(3*m-i)/2-1,(3*m-i)/2)) %= mod;\n    }\n    cout << (ans+mod)%mod << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\n#define MOD 998244353ll // prime\n// How to devide :\n// ModInt a(6ll);\n// ModInt b(2ll);\n// a *= b.exp(MOD-2ll);  -> a/=b;  result: a = 3\nstruct ModInt{\n\tll val;\n\tModInt():val(0ll){}\n\tModInt(ll v):val(((v%MOD)+MOD)%MOD){}\n\tModInt exp(ll y)const{\n\t\tif(!y)return ModInt(1ll);\n\t\tModInt a = exp(y/2ll);\n\t\ta *= a;\n\t\tif(y&1)a*=(*this);\n\t\treturn a;\n\t}\n\tbool operator==(const ModInt& x)const{return val==x.val;}\n\tinline bool operator!=(const ModInt& x)const{return !(*this==x);}\n\tbool operator<(const ModInt& x)const{return val<x.val;}\n\tbool operator>(const ModInt& x)const{return val>x.val;}\n\tinline bool operator>=(const ModInt& x)const{return !(*this<x);}\n\tinline bool operator<=(const ModInt& x)const{return !(*this>x);}\n\tModInt& operator+=(const ModInt& x){if((val+=x.val)>=MOD)val-=MOD;return *this;}\n\tModInt& operator-=(const ModInt& x){if((val+=MOD-x.val)>=MOD)val-=MOD;return *this;}\n\tModInt& operator*=(const ModInt& x){(val*=x.val)%=MOD;return *this;}\n\tModInt operator+(const ModInt& x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt& x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt& x)const{return ModInt(*this)*=x;}\n};\nistream& operator>>(istream&i,ModInt&x){i>>x.val;return i;}\nostream& operator<<(ostream&o,const ModInt&x){o<<x.val;return o;}\nModInt pow(ModInt a,ll x){\n\tModInt res = ModInt(1ll);\n\twhile(x){\n\t\tif(x&1)res *= a;\n\t\tx >>= 1;\n\t\ta = a*a;\n\t}\n\treturn res;\n}\nconst int SIZE = 5000100;\nModInt inv[SIZE+10],fac[SIZE+10],facinv[SIZE+10];\n// notice: 0C0 = 1 \nModInt nCr(int n,int r){\n\tassert(!(n<r));\n\tassert(!(n<0||r<0));\n\treturn fac[n]*facinv[r]*facinv[n-r];\n}\nvoid init(){\n\tfac[0]=ModInt(1ll);\n\tfor(int i=1;i<=SIZE;i++)fac[i]=fac[i-1]*ModInt(i);\n\tinv[1]=ModInt(1ll);\n\tfor(int i=2;i<=SIZE;i++)inv[i]=ModInt(0ll)-ModInt(MOD/i)*inv[MOD%i];\n\tfacinv[0]=ModInt(1ll);\n\tfor(int i=1;i<=SIZE;i++)facinv[i]=facinv[i-1]*inv[i];\n\treturn;\n}\nint N,M;\nint main(){\n\tinit();\n\tcin >> N >> M;\n\tModInt ans = nCr(3*M+N-1,N-1);\n\t//cout << ans << endl;\n\tfor(int i=2*M+1;i<=3*M;i++){\n\t\tModInt ret = ModInt(N)*nCr(N-2+3*M-i,3*M-i);\n\t\tans -= ret;\n\t\t//cout << ret << endl;\n\t}\n\tfor(int i=M+1;i<=N;i++){\n\t\tif((3*M-i)%2==0){\n\t\t\tModInt ret;\n\t\t\tret = nCr(N,i)*nCr(N-1+(3*M-i)/2,N-1);\n\t\t\tans -= ret;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define DBG(v) cerr << #v << \" = \" << (v) << endl;\n\nconst int mod = 998244353;\n\nll modPow(ll n, ll k) {\n\tll res = 1;\n\tfor (n %= mod; k; k >>= 1) {\n\t\tif (k & 1)\n\t\t\tres = res * n % mod;\n\t\tn = n * n % mod;\n\t}\n\treturn res;\n}\n\nll modInv(const ll x) {\n\treturn modPow(x, mod - 2);\n}\n\nconst int MaxFact = (int) 25e5 + 9;\n\nll fact[MaxFact + 9];\nll factInv[MaxFact + 9];\n\nll C(const int n, const int k) {\n\treturn fact[n] * factInv[k] % mod * factInv[n - k] % mod;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr), cout.tie(nullptr);\n\n\tfact[0] = factInv[0] = 1;\n\tfor (int i = 1; i <= MaxFact; ++i) {\n\t\tfact[i] = fact[i - 1] * i % mod;\n\t\tfactInv[i] = modInv(fact[i]);\n\t}\n\n\tint N, M;\n\tcin >> N >> M;\n\tconst int S = 3 * M;\n\tconst int R = M - 1;\n\n\tll res = 0;\n\tfor (int odd = 0; odd <= min(N, M); ++odd)\n\t\tif ((S - odd) % 2 == 0)\n\t\t\t(res += C(N, odd) * C((S - odd) / 2 + N - 1, N - 1)) %= mod;\n\n\tDBG(res);\n\n\tres -= N * C(R + N - 1, N - 1);\n\tcout << (res % mod + mod) % mod;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\nusing ll = int64_t;\n\nconstexpr ll MOD = 998244353;\n\nclass Combination {\npublic:\n    Combination(ll max_num) {\n        fact_.resize(max_num + 1, 1);\n        inv_fact_.resize(max_num + 1, 1);\n        for (ll i = 2; i <= max_num; i++) {\n            fact_[i] = i * fact_[i - 1] % MOD;\n            inv_fact_[i] = MODpow(fact_[i], MOD - 2);\n            assert(fact_[i] * inv_fact_[i] % MOD == 1);\n        }\n    }\n    ll operator()(ll n, ll m) const {\n        if (m < 0 || m > n) return 0;\n        return fact_[n] * inv_fact_[n - m] % MOD * inv_fact_[m] % MOD;\n    }\nprivate:\n    ll MODpow(ll n, ll m) const {\n        ll result = 1;\n        while (m) {\n            if (m % 2 == 1) {\n                result *= n;\n                result %= MOD;\n            }\n\n            m /= 2;\n            n *= n;\n            n %= MOD;\n        }\n\n        return result;\n    }\n\n    vector<ll> fact_, inv_fact_;\n} comb(3e6);\n\n//サイズがnの非負整数配列で総和がsであり奇数の要素がm個以下であるものの場合の数\nll f(ll n, ll s, ll m) {\n    ll result = 0;\n\n    //奇数の数を全探索\n    for (ll a = s % 2; a <= min(n, m); a += 2) {\n        //まず奇数になるところを決める\n        ll curr_num = comb(n, a);\n\n        //上で選んだ箇所に1を入れたとする\n        //残りs - aをn個の要素にそれぞれ偶数となるように分ければ良い\n        //そのような分け方は結局(s - a) / 2をn個に分ける\n        //要素と仕切りのやつ\n        (curr_num *= comb((s - a) / 2 + n - 1, n - 1)) %= MOD;\n\n        (result += curr_num) %= MOD;\n    }\n\n    return result;\n}\n\nint main() {\n    ll N, M;\n    cin >> N >> M;\n\n    //最大値が2Mを超えないという条件を無視した数\n    ll ans = f(N, 3 * M, M);\n\n    //最大値が2Mを超えるものの数を引く\n    //  2Mを超えるのは1箇所。その1箇所が左端として、そこから2Mを引いた配列を考える\n    //  その配列はN要素で合計がMで奇数がM個以下\n    //  しかし左端が0になってはいけないのでN - 1要素で合計Mで奇数がM個以下となるものを引く\n    ll illegal = (f(N, M, M) + MOD - f(N - 1, M, M)) % MOD;\n\n    //2Mを超えるものがどこに来るかはN通りあり得るのでN倍する\n    (ans += MOD - N * illegal % MOD) %= MOD;\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long \nusing namespace std;\ntypedef pair<int,int> ii;\n\nint fact[2000005];\nint mod = 998244353;\nlong long qexp(long long b, long long p){\n    long long res = 1;\n    while(p){\n        if(p&1) res = (res * b) % mod;\n        b = (b * b) % mod;\n        p >>= 1;\n    }\n    return res;\n}\nint inv(long long b){ return qexp(b, mod-2); }\nint choose(int N, int C){\n\tif(N < C) return 0;\n\tint res = fact[N];\n\tres *= inv(fact[C]);\n\tres %= mod;\n\tres *= inv(fact[N-C]);\n\tres %= mod;\n\treturn res;\n}\nint split(int total, int N){ ///split total objects to N groups\n\treturn choose(N + total - 1, N - 1);\n}\n\nint ans = 0;\nvoid fix(int &x){\n\tx %= mod;\n\tif(x < 0) x += mod;\n}\nsigned main(){\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\t\n\tfact[0] = 1;\n\tfor(int i = 1;i <= 2000000;i++) fact[i] = (fact[i-1] * i) % mod;\n\t\n\tint N, M; cin >> N >> M;\n\t\t\n\tfor(int ones = 0;ones <= M;ones++){\n\t\tint zeros = N - ones;\n\t\t\n\t\tint leftover = 3*M - ones;\n\t\tif(leftover & 1) continue;\n\t\t\n\t\tleftover /= 2; ///The number of 2s to assign elsewhere\n\t\t\n\t\tint ways01 = choose(N, ones); ///ways to arrange the 0s and 1s\n\t\t\n\t\tint total2 = split(leftover, N); ///total ways to assign \n\t\tint oneTooBig = ones * split(leftover - M, N);\n\t\tint zeroTooBig = zeros * split(leftover - M - 1, N);\n\t\t\n\t\ttotal2 -= oneTooBig;\n\t\ttotal2 -= zeroTooBig;\n\t\t\n\t\tfix(total2);\n\t\tans += total2 * ways01;\n\t\tfix(ans);\n\t}\n\t\n\tcout << ans;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int P = 998244353;\nconst int MAX = 3e6;\nint pot(int a,int w){\n  int r = 1;\n  while(w){\n    if(w & 1)\n      r = r * a % P;\n    w/=2;\n    a = a * a % P;\n  }\n  return r;\n}\nint mul(int a,int b){\n  return a * b % P;\n}\n\nvoid sub(int &a,int b){\n  a -= b;\n  if(a < 0)\n    a += P;\n}\n\nvoid add(int &a,int b){\n  a += b;\n  if(a >= P)\n    a -= P;\n}\n\nint sil[MAX],odw[MAX];\nint dwu(int a,int b){\n  if(b > a || b < 0)return 0;\n  return mul(sil[a], mul(odw[b], odw[a-b])); \n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  sil[0] = 1;\n  R(i,MAX-1){\n    sil[i+1] = mul(sil[i], i + 1);\n  }\n  R(i,MAX){\n    odw[i] = pot(sil[i], P-2);\n  }\n  int n,m;\n  cin >> n >> m;\n  int res = dwu(m * 3 + n - 1, n - 1);\n  \n  debug(res);\n  \n  sub(res, mul(n, dwu(m + n - 2, n - 1)));\n  \n  debug(res);\n  \n  for(int i = m + 1; i <= n; i++)if((m * 3 - i) % 2 == 0){\n    int ak = mul(dwu(n,i), dwu((3 * m - i)/2 + n - 1, n - 1));\n    sub(res, ak);\n  }\n  \n  debug(res);\n  \n  cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=1500005,INF=1<<30;\n\nll inv[MAX],fac[MAX],finv[MAX];\n\nvoid make(){\n    \n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    \n    for(int i=2;i<MAX;i++){\n        inv[i]=mod-inv[mod%i]*(mod/i)%mod;\n        fac[i]=fac[i-1]*(ll)i%mod;\n        finv[i]=finv[i-1]*inv[i]%mod;\n    }\n    \n}\n\nll comb(ll a,ll b){\n    if(a<b) return 0;\n    return fac[a]*(finv[b]*finv[a-b]%mod)%mod;\n}\n\nint main(){\n    \n    make();\n    \n    int N,M;cin>>N>>M;\n    \n    ll sum=0;\n    \n    for(int i=M;i>=0;i-=2){\n        ll rem=(3*M-i)/2;\n        sum+=comb(rem+N-1,N-1);\n        sum%=mod;\n    }\n    \n    for(int i=M;i>=0;i-=2){\n        ll rem=(M-i)/2;\n        sum+=N*(mod-comb(rem+N-1,N-1));\n        sum%=mod;\n    }\n    \n    for(int i=M;i>=0;i-=2){\n        ll rem=(M-i)/2;\n        sum+=(comb(rem+N-2,N-2));\n        sum%=mod;\n    }\n    \n    cout<<sum<<endl;\n    \n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\nistream&operator>>(istream&s,_Bit_reference b){int a;s>>a;assert(a==0||a==1);b=a;return s;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst int md=998244353;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}T get(int i){return S[i+B];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\nclass LCA{vvi par;vi dep;public:LCA(vvi&E,int root):par(MSB(E.size())+1,vi(E.size())),dep(E.size()){function<void(int,int)>dfs=[&](int i,int p){for(int j:E[i])if(j!=p){par[0][j]=i;dep[j]=dep[i]+1;dfs(j,i);}};par[0][root]=root;dfs(root,root);fr(i,par.size()-1){fr(j,par[0].size()){par[i+1][j]=par[i][par[i][j]];}}}int operator()(int a,int b){if(dep[a]>dep[b])swap(a,b);for(int t=dep[b]-dep[a],i=0;t;t>>=1,++i){if(t&1){b=par[i][b];}}if(a==b)return a;rf(i,par.size()){if(par[i][a]!=par[i][b]){a=par[i][a];b=par[i][b];}}return par[0][a];}};\nvpli factor(ll N){vpli r;for(ll i=2;i*i<=N;++i){if(N%i==0){r<<pli{i,0};while(N%i==0){N/=i;++r.back().second;}}}if(N>1){r<<pli{N,1};}return r;}\nvl divisors(ll n){vl r;ll m=sqrt(n);foor(i,1,m)if(n%i==0)r<<ll(i);rf(i,r.size()-(m*m==n))r<<n/r[i];return r;}\nvi SuffixArray(str S){int N=S.size();vi rank(N+1),tmp(N+1),sa(N+1);fr(i,N){sa[i]=i;rank[i]=S[i];}sa[N]=N;rank[N]=-1;int k;auto cmp=[&](int&a,int&b)->bool{if(rank[a]!=rank[b])return rank[a]<rank[b];return (a+k<=N?rank[a+k]:-1)<(b+k<=N?rank[b+k]:-1);};for(k=1;k<=N;k*=2){sort(all(sa),cmp);tmp[sa[0]]=0;foor(i,1,N){tmp[sa[i]]=tmp[sa[i-1]]+cmp(sa[i-1],sa[i]);}rank=tmp;}return sa;};\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N,M;cin>>N>>M;\n\tCombination C(3*M+N,md);\n\tll z=C.H(N,3*M);\n\tfor(int i=M+2;i<=min(3*M,N);i+=2){\n\t\tz=(z-C.C(N,i)*C.H(N,3*M-i>>1)%md+md)%md;\n\t}\n\tz=(z-N*C.H(N,M-1)%md+md)%md;\n\tprint(z);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<ll,pll> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=998244353;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nll Pow(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nconst int M=4000005;\nll F[M];\n\nvoid Init(){\n\tF[0]=1;\n\tfor(int i=1;i<M;i++) F[i]=F[i-1]*i%mod;\n}\n\nll Div(ll n,ll m){\n\treturn n*Pow(m,mod-2)%mod;\n}\n\nll nCk(ll n,ll k){\n\treturn Div(F[n],F[n-k]*F[k]%mod);\n}\n\nll nHk(ll n,ll k){\n\treturn nCk(n+k-1,k);\n}\n\nint n,m;\n\nint main(){\n\tInit();\n\tcin>>n>>m;\n\tll res=nHk(n,3*m);\n\tfor(int i=m+1;i<=n;i++) if((3*m-i)%2==0) res=(res-nHk(n,(3*m-i)/2)*nCk(n,i)%mod+mod)%mod;\n\tfor(int i=2*m+1;i<=3*m;i++) res=(res-n*nHk(n-1,3*m-i)%mod+mod)%mod;\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nconst int maxn = 1e7 + 7;\nconst int P = 998244353;\nint fac[maxn], inv[maxn];\nint fpw(int x, int y){\n\tint ans = 1;\n\tfor (; y; y >>= 1, x = 1LL * x * x % P)\n\t\tif (y & 1)\n\t\t\tans = 1LL * ans * x % P;\n\treturn ans;\n}\nint C(int n, int m){\n\treturn 1LL * fac[n] * inv[m] % P * inv[n - m] % P;\n}\nint add(int x, int y){\n\tx += y;\n\treturn x >= P ? x - P : x;\n}\nint calc(int n, int S, int m){\n\tint ans = 0;\n\tfor (int i = 0; i <= min(S, min(n, m)); ++ i)\n\t\tif ((S - i) % 2 == 0){\n\t\t\tint s = (S - i) / 2;\n\t\t\tans = add(ans, 1LL * C(n, i) * C(s + n - 1, n - 1) % P);\n\t\t}\n\treturn ans;\n}\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\tfac[0] = 1;\n\tfor (int i = 1; i <= 1e7; ++ i)\n\t\tfac[i] = 1LL * fac[i - 1] * i % P;\n\tinv[(int)(1e7)] = fpw(fac[(int)(1e7)], P - 2);\n\tfor (int i = 1e7 - 1; i >= 0; -- i)\n\t\tinv[i] = 1LL * inv[i + 1] * (i + 1) % P;\n\tcout << add(calc(n, 3 * m, m), P - 1LL * n * add(calc(n, m, m), P - calc(n - 1, m, m)) % P) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=3000005,mod=998244353;\nint n,m,fact[N],inv[N],ans,tp;\ninline void inc(int& x,CI y)\n{\n\tif ((x+=y)>=mod) x-=mod;\n}\ninline void dec(int& x,CI y)\n{\n\tif ((x-=y)<0) x+=mod;\n}\ninline int quick_pow(int x,int p=mod-2,int mul=1)\n{\n\tfor (;p;p>>=1,x=1LL*x*x%mod) if (p&1) mul=1LL*mul*x%mod; return mul;\n}\ninline int C(CI n,CI m)\n{\n\treturn 1LL*fact[n]*inv[m]%mod*inv[n-m]%mod;\n}\ninline void init(CI n)\n{\n\tRI i; for (fact[0]=i=1;i<=n;++i) fact[i]=1LL*fact[i-1]*i%mod;\n\tfor (inv[n]=quick_pow(fact[n]),i=n-1;~i;--i) inv[i]=1LL*inv[i+1]*(i+1)%mod;\n}\nint main()\n{\n\tRI i; scanf(\"%d%d\",&n,&m); init(n+3*m);\n\tfor (i=0;i<=m;++i) if (!((3*m-i)&1))\n\ttp=(3*m-i)/2,inc(ans,1LL*C(n,i)*C(tp+n-1,n-1)%mod);\n\tfor (i=2*m+1;i<=3*m;++i) dec(ans,1LL*n*C(3*m-i+n-2,n-2)%mod);\n\treturn printf(\"%d\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n\ntypedef long long ll;\n\nconst long MOD = 998244353;\n#define N_MAX 2000002\n\nll inv[N_MAX],fac[N_MAX],finv[N_MAX];\n\nvoid init(){\n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    for(int i=2;i<N_MAX;i++){\n        inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n        fac[i]=fac[i-1]*(ll) i%MOD;\n        finv[i]=finv[i-1]*inv[i]%MOD;\n    }\n}\n\nll inv_(ll n){\n    if(n == 1) return 1;\n    else return MOD-inv_(MOD%n)*(MOD/n)%MOD;\n}\n\nll comb(ll n, ll r){\n  ll ans;\n  if(n < r){\n      ans = 0;\n  }else{\n      ans = (fac[n]*finv[r])%MOD;\n      ans = (ans*finv[n-r])%MOD;\n      ans = (ans+MOD)%MOD;\n  }\n  return ans;\n}\n\nint main(){\n    ll N, M;\n    cin >> N >> M;\n    init();\n    ll ans = 0;\n    for(ll m = 0; m <= M; m++){\n        if((M-m)%2 != 0) continue;\n        ans += (comb(N, m)*comb((3*M-m)/2+N-1, N-1))%MOD;\n        ans %= MOD;\n        ans -= (((comb(N, m)*(N-m))%MOD)*comb((M-m)/2-1+N-1, N-1))%MOD;\n        ans %= MOD;\n        ans += MOD;\n        ans %= MOD;\n        ans -= (((comb(N, m)*m)%MOD)*comb((M-m)/2+N-1, N-1))%MOD;\n        ans %= MOD;\n        ans += MOD;\n        ans %= MOD;\n        //cout << ans << endl;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define fi first\n#define se second\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define INF  (1<<30)\n#define INFL (1LL<<60)\n#define MOD 998244353LL\n#define EPS ((ld)(1e-9))\n \n#define sz(x) ((int)(x).size())\n#define setz(x) memset(x, 0, sizeof(x))\n#define all(x) (x).begin(), (x).end()\n#define rep(i, e) for (int i = 0, _##i = (e); i < _##i; i++)\n#define repp(i, s, e) for (int i = (s), _##i = (e); i < _##i; i++)\n#define repr(i, s, e) for (int i = (s)-1, _##i = (e); i >= _##i; i--)\n#define repi(i, x) for (auto &i : (x))\n \n \nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<ll, ll> pll;\n \ntemplate<typename T, typename V>\nostream &operator<<(ostream &os, const pair<T, V> pai) { \n    return os << '(' << pai.first << ' ' << pai.second << ')';\n}\n \ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> v) {\n    cout << '[';\n    for (auto p : v) cout << p << \",\";\n    cout << \"]\";\n    return os;\n}\n \ntemplate<typename T>\nostream &operator<<(ostream &os, const set<T> v) {\n    cout << \"{\";\n    for (auto p : v) cout << p << \",\";\n    cout << \"}\";\n    return os;\n}\n \ntemplate<typename T, typename V>\nostream &operator<<(ostream &os, const map<T, V> v) {\n    cout << \"{\";\n    for (auto p : v) cout << p << \",\";\n    cout << \"}\";\n    return os;\n}\n \n#ifndef __SOULTCH\n#define debug(...) 0\n#define endl '\\n'\n#else\n#define debug(...) cout << \" [-] \", _dbg(#__VA_ARGS__, __VA_ARGS__)\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cout << sdbg << '=' << h << endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n    while(*sdbg != ',') cout << *sdbg++;\n    cout << '=' << (h) << ','; \n    _dbg(sdbg+1, a...);\n}\n#endif\n \ntemplate<typename T> void get_max(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void get_min(T &a, T b) {a = min(a, b);}\n\n\nint N, M;\nll inv(ll v) {\n    ll res = 1;\n    for (int t = MOD-2; t > 0; t >>= 1) {\n        if (t&1) res = res*v%MOD;\n        v = v*v%MOD;\n    }\n    return res;\n}\n\nll A[500001] = {1};\nll B[500001];\n\nll comb(int a, int b) {\n    if (a < b) return 0;\n    return A[a]*B[b]%MOD*B[a-b]%MOD;\n}\n\nll calc(int x) {\n    if ((x^M)&1) return 0;\n\n    ll x1 = comb((3*M-x)/2+N-1, N-1)%MOD;\n    ll x2 = x*comb((M-x)/2+N-1, N-1)%MOD;\n    ll x3 = (x<M?(N-x)*comb((M-x-2)/2+N-1, N-1):0)%MOD;\n    debug(x, x1, x2, x3);\n    return comb(N, x)*(x1+2*MOD-x2-x3)%MOD;\n}\n\n\nint main(void) {\n    iostream::sync_with_stdio(false);\n    cin.tie(nullptr), cout.tie(nullptr);\n\n    repp(i, 1, 500001) A[i] = A[i-1]*i%MOD;\n    B[500000] = inv(A[500000]);\n    repr(i, 500000, 0) B[i] = B[i+1]*(i+1)%MOD;\n    \n    cin >> N >> M;\n    ll res = 0;\n    rep(i, min(N+1, M+1)) res = (res+calc(i))%MOD, debug(res);\n\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ntypedef long long LL;\n\nconst int maxn=1e6+5;\nconst LL mo=998244353;\n\nint n,m;\n\nLL mi(LL x,LL y)\n{\n\tLL re=1;\n\tfor(; y; y>>=1, x=x*x%mo) if (y&1) re=re*x%mo;\n\treturn re;\n}\n\nLL fac[4*maxn],ny[4*maxn];\nvoid Pre(int n)\n{\n\tfac[0]=1;\n\tfo(i,1,n) fac[i]=fac[i-1]*i%mo;\n\tny[n]=mi(fac[n],mo-2);\n\tfd(i,n-1,0) ny[i]=ny[i+1]*(i+1)%mo;\n}\nLL C(int n,int m) {return fac[n]*ny[m]%mo*ny[n-m]%mo;}\n\nLL calc(int n,int sum,int m)\n{\n\tLL re=0;\n\tfo(i,0,m) if (!((sum-i)&1)) (re+=C(n,i)*C((sum-i)/2+n-1,n-1))%=mo;\n\treturn re;\n}\n\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\t\n\tPre(3*m+n);\n\t\n\tLL ans=calc(n,3*m,m)-(calc(n,m,m)-calc(n-1,m,m))%mo*n;\n\t\n\tprintf(\"%lld\\n\",(ans%mo+mo)%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int int64_t\n#define rep(i, a, b) for(int i = a; i < b; ++i)\n\nint debug = 1;\n\nconst int N = 2e6 + 10;\nint mod = 998244353;\n\nint n, m;\nint fac[N], fre[N], c[3][N];\n\nint add(int a, int b) {\n    a += b;\n    while (a >= mod) a -= mod;\n    return a;\n}\n\nint sub(int a, int b) {\n    a -= b;\n    while (a < 0) a += mod;\n    return a;\n}\n\nint mul(int a, int b) {\n    return a * b % mod;\n}\n\nint pw(int x, int p) {\n    if (p == 0) return 1;\n    if (p % 2) return pw(x, p - 1) * x % mod;\n    int pp = pw(x, p / 2);\n    return pp * pp % mod;\n}\n\nint rev(int a) {\n    return pw(a, mod - 2);\n}\n\nvoid precalc() {\n    fac[0] = 1;\n    rep(i, 1, N) {\n        fac[i] = mul(fac[i - 1], i);\n    }\n    fre[N - 1] = rev(fac[N - 1]);\n    for (int i = N - 2; i >= 0; --i) {\n        fre[i] = mul(fre[i + 1], i + 1);\n    }\n}\n\nint C(int nn, int k) {\n    if (nn - k < 0) return 0;\n    return mul(fac[nn], mul(fre[k], fre[nn - k]));\n}\n\nint f(int s, int param) {\n    return C(n-param+s, n-param);\n}\n\nint g(int s, int param) {\n    int res = 0;\n    rep(a, 0, m + 1) {\n        if ((s - a) % 2 == 0 && (s - a) >= 0) {\n            res = add(res, mul(f((s - a) / 2, param), C(n+1-param, a)));\n        }\n    }\n    return res;\n}\n\nmain() {\n    cin >> n >> m;\n    precalc();\n    int ans = sub(g(3 * m, 1), mul(n, sub(g(m, 1), g(m, 2))));\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SZ(x) ((int)((x).size()))\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\ntemplate<class TH>\nvoid _dbg(const char* name, TH val){\n    clog << name << \": \" << val << endl;\n}\ntemplate<class TH, class... TA>\nvoid _dbg(const char* names, TH curr_val, TA... vals) {\n    while(*names != ',') clog << *names++;\n    clog << \": \" << curr_val << \", \";\n    _dbg(names+1, vals...);\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n    #define dbg_arr(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg(...)\n    #define dbg_arr(x, len)\n#endif\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\nLL Inverse(LL n, LL m) {\n    n %= m;\n    if (n <= 1) return n; // Handles properly (n = 0, m = 1).\n    return m - ((m * Inverse(m, n) - 1) / n);\n}\n\nconst LL mod = 998244353;\nconst int MAXN = 2e6;\nLL fact[MAXN];\nLL invfact[MAXN];\n\nLL binom(LL a, LL b) {\n    assert(MAXN > a and a >= b and b >= 0);\n    return fact[a] * (invfact[b]*invfact[a-b] % mod) % mod;\n}\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in problems with online queries!\n\n    fact[0] = invfact[0] = 1;\n    for (int i = 1; i < MAXN; i++) {\n        fact[i] = i*fact[i-1] % mod;\n        invfact[i] = Inverse(fact[i], mod);\n    }\n\n    int N, M;\n    cin >> N >> M;\n\n    LL ans = N * binom(M + N-2, N-2) % mod;\n    for (int k = 0; k <= M; k++) {\n        LL q = 3*M-k;\n        if (q % 2) continue;\n        q /= 2;\n        LL ris = binom(q + N-1, N-1) - N*binom(q-M + N-1, N-1);\n        ris %= mod;\n        ris = ris * binom(N, k) % mod;\n        ans += ris;\n        ans %= mod;\n    }\n    if (ans < 0) ans += mod;\n    cout << ans << \"\\n\";\n\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h> //rand() 0~RAND_MAX2147483647\n#include <math.h>\n#include <time.h>   //srand((unsigned int)time(NULL));\n#include <unistd.h> //sleep\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <regex> //正規表現\n#include <map>\n#include <set>\n#include <cassert> //assart\n#include <numeric>\n#include <iterator>\n#include <list>\n\nusing namespace std;\n#define ll long long int\n#define FOR(i,min,max) for(int i=(min);i<(max);i++)\n#define FOReq(i,min,max) for(int i=(min);i<=(max);i++)\n#define FORREV(i,max,min) for(int i=(max)-1;i>=(min);i--)\n#define FORREVeq(i,max,min) for(int i=(max);i>=(min);i--)\nconst int MOD=1e9+7;\nconst int MOD2=998244353;\n\nconst int INF=2000000001;\nconst ll INFll=2e18;\n//const int MAX_V=10000;\nconst double  Micro=1e-5;\n\nint UnUsedVariable(){\n    if(INF || Micro || MOD || INFll){;}\n    return 0;\n}\n\n#define pf printf\n#define sf scanf\n#define inarray(array,min,max) FOR(i,min,max){cin>>array[i];}\n#define inarrayW(arrayA,arrayB,min,max) FOR(i,min,max){cin>>arrayA[i]>>arrayB[i];}\n#define br printf(\"\\n\");\n#define OutputAndReturn0(x) {cout<<(x)<<endl;return 0;}\n#define elif else if\n\n#define issame(a,b,c,d) ((a)==(b) and (b)==(c) and (c)==(d))\n#define isdiff3(a,b,c) ((a)!=(b) and (b)!=(c) and (c)!=(a))\n#define isdiff4(a,b,c,d) ((a)!=(b) and (b)!=(c) and (c)!=(a) and (d)!=(a) and (d)!=(b) and (d)!=(c))\ninline int isEven(int x){return x%2==0;}\ninline int isOdd (int x){return x%2==1;}\ninline ll  gcd(ll a,ll b){ if(b==0)return a;else return gcd(b,a%b);}//最大公約数 なお一方が0なら答えは他方になるので番兵は０で良い また、負の数もOK -4%3=-1となるため\ninline ll  lcm(ll a,ll b){return a*b/gcd(a,b);}//MODやオーバーフローには注意！\n\n\n\n//Eと名のつくのはデバッグ用！\nint EintN(int array[],const int num){\n    for(int i=0;i<num;i++){cerr<<array[i]<<\" \";}\n    br;\n    return 0;\n}\nint EintNN(const int heighth,const int width,int array[heighth][width]){\n    FOR(i, 0, heighth){\n        FOR(k, 0, width){\n            {cerr<<array[i][k]<<\" \";}\n        }\n        br;\n    }\n    br;\n    return 0;\n}\nint Eint(string str,const int num){\n    cerr<<str<<\" is \"<<num<<\" now.\"<<endl;\n    return 0;\n}\nint NumToArray(int number,int array[],int arraymax,int whatnary){//0~7を000~111にするみたいな　0~26を000~222にするみたいな\n    int newnumber=number;\n    FOR(i, 0, arraymax){\n        array[i]=newnumber%whatnary;\n        newnumber=newnumber/whatnary;\n    }\n    return 0;\n}\n\n\n\n\n\nint Ap(){\n    int ans;ans=0;\n    ll S;cin>>S;\n    ll x1,x2,x3,y1,y2,y3;\n    x1=y1=0;\n    ll x3y2=(ll)1e9-(S % (ll)(1e9));\n    ll x2y3=S/(ll)1e9 +1;\n    x2=(ll)1e9;y3=x2y3;\n    y2=1;x3=x3y2;\n    if(S>((ll)1e18-(ll)1e9)){\n        ll dif=(ll)1e18 -S;\n        x2=1e9;\n        y3=1e9;\n        x3=1;\n        y2=dif;\n    }\n    \n    \n    cout<<x1<<\" \"<<y1<<\" \"<<x2<<\" \"<<y2<<\" \"<<x3<<\" \"<<y3<<endl;\n    //OutputAndReturn0(ans);\n    return 0;\n}\n\n\n\n\n\n\nint Bp(){\n    ll ans;ans=0;\n    ll N,K;\n    cin>>N>>K;\n    ll A[N];\n    //ll B[N];\n    //ll C[N];\n    list<ll> answer;\n    multiset<ll> multisetll;\n    FOR(i, 0, N){\n        ll temp=0;\n        cin>>temp;\n        multisetll.insert(temp);\n        A[i]=temp;\n    }\n    \n    \n    int numin=0;\n    set<ll> setll;\n    for (int i=0; i<N; i++) {\n        auto p=setll.insert(A[i]);\n        if(p.second==false){\n            setll.erase(p.first);\n            while(answer.back()!=A[i]){\n                numin--;\n                setll.erase(answer.back());\n            }\n        }\n        else {\n            answer.push_back(A[i]);\n            numin++;\n        }\n    }\n    for (auto itr=answer.begin(); itr!=answer.end(); ++itr) {\n        cout << *itr << \" \" ;\n    }\n    br;\n    \n    \n    if(answer.size()==0){br;return 0;}\n    \n    \n    list<ll> vec;\n    for (auto itr=answer.begin(); itr!=answer.end(); ++itr) {\n        vec.push_back(*itr);\n    }\n    \n    ll roop=0;\n    \n    while(vec.size()==0){\n        ll count_num=multisetll.count(*vec.begin());\n        if(count_num==1){vec.pop_front();}\n        elif(count_num%2==0){}\n        else{}\n        roop++;\n    }\n    \n    //OutputAndReturn0(ans);\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\nll modinv(long long a, long long m) {//mod素数における逆数a^(-1)を求める これで割り算を掛け算にできる\n    long long b = m, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        a -= t * b; swap(a, b);\n        u -= t * v; swap(u, v);\n    }\n    u %= m;\n    if (u < 0) u += m;\n    return u;\n}\nll combi2(ll n,ll k,ll m){\n    //O(k)\n    ll ans=1;\n    for(ll i=0;i<k;i++){\n        ans=(ans*(n-i))%m;\n        ans=(ans*modinv(i+1,m))%m;\n    }\n    return ans;\n}\n\nint Cp(){\n    ll ans;ans=0;\n    ll N,M;\n    cin>>N>>M;\n    ans=combi2(3*M+N-1, min(3*M,N-1), MOD2)%MOD2;//全パターン\n    ans-=combi2(M+N-2, min(N-1,M-1), MOD2)%MOD2;//ある人が２M以上持つパターン\n    //ここから全員が１を持つパターンとか抜きたい\n    FOR(i, 1, M+1){\n        ans-=combi2(N+M-i-1,M-i , MOD2)%MOD2;\n    }\n    \n    if(ans<0)ans+=MOD2;\n    \n    OutputAndReturn0(ans);\n    return 0;\n}\n\nint Dp(){\n    int ans;ans=0;\n    \n    OutputAndReturn0(ans);\n    return 0;\n}\n\n\nlong long IntPow(long long x, long long n){\n    if(n == 0)\n        return 1;\n    if(n % 2 == 0)\n        return IntPow(x * x, n / 2);\n    else\n        return x * IntPow(x, n - 1);\n}\n\n\nint test(){\n    int a[3];\n    FOR(i, 0, 8){\n        NumToArray(i, a, 3, 2);\n        EintN(a, 3);\n    }\n    \n    return 0;\n}\n\nsigned main(){\n    //test();\n    //Ap();\n    //Bp();\n    Cp();\n    //Dp();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<LL,LL> P;\nconst LL mod=998244353;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\n\n\nvector<LL> fact;\nvector<LL> inver(3000001);\n \nLL combi(int n,int r){\n    if(n<r||n<0||r<0) return 0;\n    return fact[n]%mod*inver[n-r]%mod*inver[r]%mod;\n}\n \n \nLL fpow(LL a, LL n){\n    LL x = 1;\n    while(n > 0){\n        if(n&1){\n            x=x*a%mod;\n        }\n        a=a*a%mod;\n        n >>= 1;\n    }\n    return x;\n}\n \nvoid set_combi(){\n    LL s=1;\n    fact.push_back(1);\n    for(int i=1;i<=3000000;i++){\n        s*=i;\n        s%=mod;\n        fact.push_back(s);\n    }\n    inver[3000000]=fpow(fact[3000000],mod-2);\n    for(int i=2999999;i>=0;i--){\n        inver[i]=inver[i+1]*(i+1)%mod;\n    }\n}\n \nLL hcombi(int n,int r){\n    return combi(n+r-1,r); \n}\n\n\n\nint main(){\n    set_combi();\n    LL n,m;cin >> n >> m;\n    LL ans = 0;\n    for (int i = m; i >= 0; i-=2) {\n        ans = (ans + hcombi(n,m+(m-i)/2) * combi(n,i))%mod;\n    }\n    for (int i = 2*m+1; i <= 3*m; i++) {\n        ans = (ans - (n * hcombi(n-1,3*m-i))%mod + mod)%mod;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//ios::sync_with_stdio(false);\n#include<bits/stdc++.h>\n#define LL long long\n#define F(x,y,z) for(int x=y;x<=z;++x)\n#define D(x,y,z) for(int x=y;x>=z;--x)\nusing namespace std;\nconst int Mod=998244353;\nconst int N=3000010;\nconst int maxn=3000001;\nLL Min(LL x,LL y){return x<y?x:y;}\nLL Max(LL x,LL y){return x>y?x:y;}\nLL R(){\n    LL ans=0,f=1;char c=getchar();\n    for(;c<'0'||c>'9';c=getchar()) if (c=='-') f=-1;\n    for(;c>='0'&&c<='9';c=getchar()) ans=ans*10+c-'0';\n    return ans*f;\n}\nLL jc[N],ni[N],n,m;\nLL C(LL n,LL m){return jc[n]*ni[m]%Mod*ni[n-m]%Mod;}\nLL Calc(LL n,LL m,LL js){\n\tLL ans=0;\n\tF(i,0,m){\n\t\tif((i+m)&1)continue;\n\t\tans+=C(n,i)*C(js+(m-i)/2+n-1,n-1);\n\t\tans%=Mod;\n\t}\n\treturn ans;\n}\nLL Pow(LL x,LL bs){\n\tLL an=1;\n\tfor(;bs;bs>>=1,x=x*x%Mod)\n\t\tif(bs&1)an=an*x%Mod;\n\treturn an; \n}\nvoid Pre(){\n\tjc[0]=ni[0]=1;\n\tF(i,1,maxn)jc[i]=jc[i-1]*i%Mod;\n\tni[maxn]=Pow(jc[maxn],Mod-2);\n\tD(i,maxn-1,1)ni[i]=ni[i+1]*(i+1)%Mod;\n}\nint main(){\n\tPre();\n\tn=R();m=R();\n\tLL ans=Calc(n,m,m);\n\tans-=n*(Calc(n,m,0)-Calc(n-1,m,0));\n\tans%=Mod;ans+=Mod;ans%=Mod;\n\tcout<<ans<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n#define resz resize\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define sort_by(x, y) sort(all(x), [&](const auto& a, const auto& b) { return y; })\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing vpdd = vector<pdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T, bool pretty = true> void prContain(const T& x) {\n        if (pretty) pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?pretty?\", \":\" \":\"\",a), fst = 0;\n        if (pretty) pr(\"}\");\n    }\n    template<class T> void pc(const T& x) { prContain<T, false>(x); pr(\"\\n\"); }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __algorithm {\n    template<typename T> void dedup(vector<T>& v) {\n        sort(all(v)); v.erase(unique(all(v)), v.end());\n    }\n    template<typename T> typename vector<T>::iterator find(const vector<T>& v, const T& x) {\n        auto it = lower_bound(all(v), x); return it != v.end() && *it == x ? it : v.end();\n    }\n    template<typename T> size_t index(const vector<T>& v, const T& x) {\n        auto it = find(v, x); assert(it != v.end() && *it == x); return it - v.begin();\n    }\n\n    template<typename T1, typename T2> typename vector<pair<T1, T2>>::iterator lower_bound(\n            const vector<pair<T1, T2>>& v, const T1& x) {\n        return lower_bound(all(v), x, [](pair<T1, T2> a, pair<T1, T2> b) { return a.f < b.f; });\n    }\n    template<typename T1, typename T2> typename vector<pair<T1, T2>>::iterator upper_bound(\n            const vector<pair<T1, T2>>& v, const T1& x) {\n        return upper_bound(all(v), x, [](pair<T1, T2> a, pair<T1, T2> b) { return a.f < b.f; });\n    }\n}\nusing namespace __algorithm;\n\nstruct monostate {\n    friend istream& operator>>(istream& is, const __attribute__((unused))monostate& ms) { return is; }\n    friend ostream& operator<<(ostream& os, const __attribute__((unused))monostate& ms) { return os; }\n} ms;\n\ntemplate<typename W=monostate> struct wedge {\n    int u, v, i; W w;\n    wedge<W>(int _u=-1, int _v=-1, int _i=-1) : u(_u), v(_v), i(_i) {}\n    int operator[](int loc) const { return u ^ v ^ loc; }\n    friend void re(wedge& e) { re(e.u, e.v, e.w); --e.u, --e.v; }\n    friend void pr(const wedge& e) { pr(e.u, \"<-\", e.w, \"->\", e.v); }\n};\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\n// modnum {{{\ntemplate<int MOD> struct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { ll w; i >> w; n = modnum(w); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(ll e) const {\n        if (e < 0) return 1 / this->pow(-e);\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        int g = MOD, x = 0, y = 1;\n        for (int r = v; r != 0; ) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static int totient() {\n        int tot = MOD, tmp = MOD;\n        for (int p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static int primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        int tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (int p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (int r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (int p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static int discrete_log(modnum v) {\n        static const int M = ceil(sqrt(MOD));\n        static unordered_map<int, int> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (int i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (int i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum unity_root(int deg) {\n        assert(totient() % deg == 0);\n        return generator().pow(totient() / deg);\n    }\n\n    static modnum fact(int n) {\n        static vector<modnum> fact = { 1 };\n        for (assert(n >= 0); fact.size() <= n; )\n            fact.push_back(fact.back() * fact.size());\n        return fact[n];\n    }\n\n    static modnum finv(int n) {\n        static vector<modnum> finv = { 1 };\n        for (assert(n >= 0); finv.size() <= n; )\n            finv.push_back(finv.back() / finv.size());\n        return finv[n];\n    }\n\n    static modnum ncr(int n, int r) {\n        assert(n >= 0);\n        if (r < 0 || n < r) return 0;\n        return fact(n) * finv(r) * finv(n - r);\n    }\n};\n// }}}\nusing mn = modnum<int(998244353)>;\nusing vmn = vector<mn>;\nusing vvmn = vector<vmn>;\n\nmn distr(int balls, int buckets) {\n    assert(buckets >= 1);\n    return mn::ncr(balls + buckets - 1, buckets - 1);\n}\n\nint main() {\n    setIO();\n\n    int N, M; re(N, M);\n\n    mn ans = 0;\n\n    F0R (odd, M + 1) {\n        if (odd > N) break;\n        mn ways = mn::ncr(N, odd);\n\n        int left = 2 * M + M - odd;\n        if (left & 1) continue;\n\n        int pairs = left / 2;\n\n        mn res = distr(pairs, N);\n        res -= (N - odd) * distr(pairs - M - 1, N);\n        res -= odd * distr(pairs - M, N);\n\n        /*FOR (exceed, M + 1, pairs + 1) {\n            res -= (N - odd) * distr(pairs - exceed, N - 1);\n        }\n        FOR (exceed, M, pairs + 1) {\n            res -= odd * distr(pairs - exceed, N - 1);\n        }*/\n        ans += ways * res;\n    }\n\n    ps(ans);\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n - 1); i >= 0; i--)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) int(x.size())\n#define get_unique(x) x.erase(unique(all(x)), x.end());\ntypedef long long ll;\ntypedef complex<double> Complex;\nconst int INF = 1e9;\nconst ll MOD = 998244353;\nconst ll LINF = 1e18;\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\nvector<T> make_vec(size_t a) {\n    return vector<T>(a);\n}\ntemplate <class T, class... Ts>\nauto make_vec(size_t a, Ts... ts) {\n    return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, vector<T> v) {\n    for (int i = 0; i < sz(v); i++) {\n        os << v[i];\n        if (i < sz(v) - 1) os << \" \";\n    }\n    return os;\n}\nstruct NumberTheoreticTransform {\n    ll ext_gxd(ll a, ll b, ll& x, ll& y) {\n        if (b == 0) {\n            x = 1;\n            y = 0;\n            return a;\n        }\n        ll q = a / b;\n        ll g = ext_gxd(b, a - q * b, x, y);\n        ll z = x - q * y;\n        x = y;\n        y = z;\n        return g;\n    }\n\n    ll modinv(ll a, ll m) {\n        ll x, y;\n        ext_gxd(a, m, x, y);\n        x %= m;\n        if (x < 0) x += m;\n        return x;\n    }\n\n    ll modpow(ll a, ll n, ll m) {\n        ll ret = 1;\n        ll now = a;\n        while (n > 0) {\n            if (n % 2 == 1) ret = ret * now % m;\n            now = now * now % m;\n            n /= 2;\n        }\n        return ret;\n    }\n\n    void ntt(vector<ll>& a, ll mod, bool inv = 0) {\n        const int n = sz(a);\n        assert((n & (n - 1)) == 0);\n\n        const ll g = 3;\n        ll h = modpow(g, (mod - 1) / n, mod);\n        if (inv) h = modinv(h, mod);\n\n        int i = 0;\n        for (int j = 1; j < n - 1; j++) {\n            for (int k = n >> 1; k > (i ^= k); k >>= 1) {\n            };\n            if (j < i) swap(a[i], a[j]);\n        }\n\n        for (int m = 1; m < n; m *= 2) {\n            const int m2 = m * 2;\n            const ll base = modpow(h, n / m2, mod);\n            ll w = 1;\n            for (int x = 0; x < m; x++) {\n                for (int s = x; s < n; s += m2) {\n                    ll u = a[s];\n                    ll d = a[s + m] * w % mod;\n                    a[s] = u + d;\n                    if (a[s] >= mod) a[s] -= mod;\n                    a[s + m] = u - d;\n                    if (a[s + m] < 0) a[s + m] += mod;\n                }\n                w = w * base % mod;\n            }\n        }\n\n        for (auto& x : a) {\n            if (x < 0) x += mod;\n        }\n\n        if (inv) {\n            const int n_inv = modinv(n, mod);\n            for (auto& x : a) x = x * n_inv % mod;\n        }\n    }\n\n    vector<ll> convolution(const vector<ll>& a, vector<ll>& b, ll m,\n                           ll mod = 998244353) {\n        int ntt_size = 1;\n        while (ntt_size < sz(a) + sz(b)) ntt_size <<= 1;\n\n        vector<ll> _a = a, _b = b;\n        _a.resize(ntt_size);\n        _b.resize(ntt_size);\n\n        ntt(_a, mod);\n        ntt(_b, mod);\n\n        for (int i = 0; i < ntt_size; i++) {\n            _a[i] *= _b[i];\n            _a[i] %= mod;\n        }\n\n        ntt(_a, mod, 1);\n        if (sz(_a) > m) _a.resize(m);\n        return _a;\n    }\n    vector<ll> convpow(vector<ll>& a, int k, ll m) {\n        vector<ll> ret(sz(a));\n        ret[0] = 1;\n        auto now = a;\n        while (k) {\n            if (k & 1) ret = convolution(ret, now, m);\n            now = convolution(now, now, m);\n            k >>= 1;\n        }\n        return ret;\n    }\n} ntt;\nstruct modint {\n    ll x;\n    modint(ll x = 0) : x((x % MOD + MOD) % MOD) {\n    }\n    ll value() const {\n        return x;\n    }\n    modint operator-() const {\n        return modint(-x);\n    }\n    modint& operator+=(const modint a) {\n        if ((x += a.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    modint& operator-=(const modint a) {\n        if ((x += MOD - a.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    modint& operator*=(const modint a) {\n        (x *= a.x) %= MOD;\n        return *this;\n    }\n    modint operator+(const modint a) const {\n        modint res(*this);\n        return res += a;\n    }\n    modint operator-(const modint a) const {\n        modint res(*this);\n        return res -= a;\n    }\n    modint operator*(const modint a) const {\n        modint res(*this);\n        return res *= a;\n    }\n    modint pow(ll t) const {\n        if (t == 0) return 1;\n        modint a = pow(t >> 1);\n        a *= a;\n        if (t % 2 == 1) a *= *this;\n        return a;\n    }\n    modint inv() const {\n        return pow(MOD - 2);\n    }\n    modint& operator/=(const modint a) {\n        return (*this) *= a.inv();\n    }\n    modint operator/(const modint a) const {\n        modint res(*this);\n        return res /= a;\n    }\n};\nostream& operator<<(ostream& os, const modint& x) {\n    os << x.value();\n    return os;\n}\nstruct combination {\n    vector<modint> fact, ifact;\n    combination(int n) : fact(n + 1), ifact(n + 1) {\n        assert(n < MOD);\n        fact[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            fact[i] = fact[i - 1] * i;\n        }\n        ifact[n] = fact[n].inv();\n        for (int i = n; i >= 1; i--) {\n            ifact[i - 1] = ifact[i] * i;\n        }\n    }\n    modint operator()(int n, int k) {\n        if (n < k || k < 0) return 0;\n        return fact[n] * ifact[k] * ifact[n - k];\n    }\n    modint h(int n, int k) {\n        n += k - 1;\n        if (k < 0 || k > n) return 0;\n        return fact[n] * ifact[k] * ifact[n - k];\n    }\n} comb(3003003);\nint main() {\n    std::chrono::system_clock::time_point start, end;\n    start = std::chrono::system_clock::now();\n    ll n, m;\n    cin >> n >> m;\n    modint ans = 0;\n    vector<ll> v(2 * m + 1, 1);\n    v[1] = 0;\n    auto now = ntt.convpow(v, n - min(n, m), 3 * m + 1);\n    for (ll i = min(n, m); i >= 0; i--) {\n        ans += comb(n, i) * now[3 * m - i];\n        now = ntt.convolution(now, v, 3 * m + 1);\n        double elapsed =\n            std::chrono::duration_cast<std::chrono::milliseconds>(end - start)\n                .count();\n        if (elapsed > 1900) {\n            break;\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nclass ModComb {\n    long long *fact, *facti;\n    const int mod;\npublic:\n    explicit ModComb(int n, int m) : mod(m) {\n        fact = new long long[n+1];\n        facti = new long long[n+1];\n        fact[0] = 1; facti[0] = 1;\n        for (int i = 1; i <= n; i++) fact[i] = (fact[i-1] * i) % m;\n        // calc 1/n!\n        long long &inv = facti[n], pw = fact[n];\n        inv = 1;\n        for (int e = mod-2; e > 0; e /= 2) {\n            if (e&1) inv = inv * pw % mod;\n            pw = pw * pw % mod;\n        }\n        for (int i = n-1; i > 0; i--) facti[i] = (facti[i+1] * (i+1)) % m;\n    }\n\n    ~ModComb() {\n        if (fact) delete[] fact;\n        if (facti) delete[] facti;\n    }\n\n    long long get(int n, int k) const {\n        if (n < 0 || k < 0 || k > n) return 0;\n        return fact[n] * facti[k] % mod * facti[n-k] % mod;\n    }\n};\n\nint main() {\n    int n, m; cin >> n >> m;\n    const int M = 998244353;\n    ModComb mc(3*m+n+3, M);\n\n    long long ans = mc.get(n+3*m-1, n-1);\n    ans -= n;\n    cerr << ans << endl;\n    for (int j = 1; j < m; j++) ans -= mc.get(n+j-2, n-2) * n % M;\n    cout << (ans % M + M) % M << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937 mrand(random_device{}());\n\n#define rep(i , l , r) for (int i = (l); i < (r); ++i)\n\nconst int N = 2e6 + 5;\nconst int mod = 998244353;\n\nint n , m;\nint fac[N] , ifac[N];\n\ntemplate <typename T> inline void chkmin(T &x , T y) { x = min(x , y); }\ntemplate <typename T> inline void chkmax(T &x , T y) { x = max(x , y); }\ntemplate <typename T> inline void read(T &x) {\n   T f = 1; x = 0;\n   char c = getchar();\n   for (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n   for (; isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + c - '0';\n   x *= f;\n}\n\ninline int quickpow(int a , int n) {\n\tint res = 1;\n\tfor (; n; n >>= 1 , a = 1LL * a * a % mod)\n\t\tif (n & 1) res = 1LL * res * a % mod;\n\treturn res;\n}\ninline void inc(int &x , int y) {\n\tx = x + y < mod ? x + y : x + y - mod;\n}\ninline void dec(int &x , int y) {\n\tx = x - y >= 0 ? x - y : x - y + mod;\n}\ninline void init(int n) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfac[i] = 1LL * fac[i - 1] * i % mod;\n\tifac[n] = quickpow(fac[n] , mod - 2);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tifac[i] = 1LL * ifac[i + 1] * (i + 1) % mod;\n\treturn;\n}\ninline int binom(int n , int m) {\n\tif (n < m) return 0;\n\telse return 1LL * fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\ninline int F(int n , int m , int k) {\n\tint ret = 0;\n\tfor (int i = 0; i <= k; ++i) {\n\t\tif ((m - i) & 1) continue;\n\t\tint val = 1LL * binom(n , i) * binom((m - i) / 2 + n - 1 , n - 1) % mod;\n\t\tinc(ret , val);\n\t}\n\treturn ret;\n}\n\nint main() {\n   \t\n   \tinit(2e6);\n   \tread(n) , read(m);\n   \tint ans = F(n , 3 * m , m);\n   \tdec(ans , 1LL * n * F(n , m , m) % mod); \n   \tinc(ans , 1LL * n * F(n - 1 , m , m) % mod);\n   \tprintf(\"%d\\n\" , ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author edamat\n */\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for(int i = int(a), i##_len = (b); i < i##_len; ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\n#define _repr(i, n) repri(i, n, 0)\n/* loop in [n,m] step -1 */\n#define repri(i, a, b) for(int i = int(a), i##_len = (b); i >= i##_len; --i)\n/* loop in [n,0] step -1 or [n,m] step -1 */\n#define repr(...) _overload3(__VA_ARGS__, repri, _repr, )(__VA_ARGS__)\n#define all(x) (x).begin(), (x).end()\n#define debug(x) cerr << #x << \": \" << (x) << '\\n'\n#define eb emplace_back\n//#define endl '\\n'\ntypedef long long lint;\n// #define int lint\nconst int INF = (int)(1 << 30) - 1;\nint MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nconst lint LINF = (lint)(1LL << 62) - 1;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n\nstruct IoSetup {\n    IoSetup() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n//        cout << fixed << setprecision(20);\n//        cerr << fixed << setprecision(20);\n    }\n} iosetup;\n\nusing std::to_string;\nauto to_string(std::string s) -> std::string {\n    return '\"' + s + '\"';\n}\nauto to_string(char c) -> std::string {\n    return \"'\" + std::string{c} + \"'\";\n}\nauto to_string(const char* s) -> std::string {\n    return to_string((std::string) s);\n}\nauto to_string(bool b) -> std::string {\n    return (b ? \"true\" : \"false\");\n}\ntemplate <typename T, typename U>\nauto to_string(std::pair<T, U> p) -> std::string {\n    return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <size_t N>\nauto to_string(std::bitset<N> bs) -> std::string {\n    std::string res{};\n    for (size_t i = 0; i < N; i++)\n        res.insert(res.begin(), bs.test(i) ? '1' : '0');\n    return res;\n}\ntemplate <typename T>\nauto to_string(T v) -> std::string {\n    bool flg = false;\n    std::string res = \"[\";\n    for (auto const&x : v) {\n        if (flg) res += \", \";\n        else flg = true;\n        res += to_string(x);\n    }\n    res += \"]\";\n    return res;\n}\n\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n#define SZ(x) ((int)(x).size())\n\n/* range macro. usage: for(int i:range(n)) */\nclass range {\nprivate:\n    struct I {\n        int x;\n        int operator*() { return x; }\n        bool operator!=(I &lhs) { return x < lhs.x; }\n        void operator++() { ++x; }\n    };\n    I i, n;\n\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    I &begin() { return i; }\n    I &end() { return n; }\n};\n\n/* keep a max,min */\ntemplate <class T>\nbool chmax(T &a, const T &b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\ntemplate <class T>\nbool chmin(T &a, const T &b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\n/* input,output operator for pair and vector */\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\n\ntemplate <typename T1, typename T2>\nistream &operator>>(istream &is, pair<T1, T2> &p) {\n    is >> p.first >> p.second;\n    return is;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    for(int i = 0; i < (int)v.size(); i++) {\n        os << v[i] << (i + 1 != v.size() ? \", \" : \"\");\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &v) {\n    for(T &in : v) is >> in;\n    return is;\n}\n\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const map<T, U> &mp) {\n    for(auto x = mp.begin(); x != mp.end(); ++x) {\n        os << x->first << \": \" << x->second\n           << (x != prev(mp.end()) ? \"\\n\" : \"\");\n    }\n    return os;\n}\n\n/* initialize vector. usage: auto v = male_v<int>(N,0); */\ntemplate <typename T>\nvector<T> make_v(size_t a) {\n    return vector<T>(a);\n}\n\ntemplate <typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n/* fill vector. usage: fill_v(v,0); */\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value == 0>::type fill_v(T &t, const V &v) {\n    t = v;\n}\n\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value != 0>::type fill_v(T &t, const V &v) {\n    for(auto &e : t) fill_v(e, v);\n}\n\n/* sum */\ntemplate <typename T>\nT sum(vector<T> &v) {\n    T ret = 0;\n    for(T x : v) {\n        ret += x;\n    }\n    return ret;\n}\ntemplate <typename T>\nauto sum(const T &a) {\n    return a;\n}\ntemplate <typename T, typename... A>\nauto sum(const T &first, const A &... rest) {\n    return sum(first) + sum(rest...);\n}\n\n/* mod */\nlint intpow(lint a, lint n, lint mod) {\n    lint res = 1;\n    while(n > 0) {\n        if(n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\ntemplate <typename T>\nT intpow(T a, lint n) {\n    T res = 1;\n    while(n > 0) {\n        if(n & 1) res = res * a;\n        a = a * a;\n        n >>= 1;\n    }\n    return res;\n}\n\nlong long modinv(long long a, long long m) {\n    long long b = m, u = 1, v = 0;\n    while(b) {\n        long long t = a / b;\n        a -= t * b;\n        swap(a, b);\n        u -= t * v;\n        swap(u, v);\n    }\n    u %= m;\n    if(u < 0) u += m;\n    return u;\n}\n\n/* print */\ntemplate <typename T>\nvoid print(const T &first) {\n    cout << first << endl;\n}\ntemplate <typename T, typename... A>\nvoid print(const T &first, const A &... rest) {\n    cout << first << \" \";\n    print(rest...);\n}\ntemplate <typename... A>\nvoid print(const A &... rest) {\n    print(rest...);\n}\n\n/* Modint */\ntemplate <typename T, T MOD = 1000000007>\nstruct ModInt {\n    static constexpr T mod = MOD;\n    T v;\n    ModInt() : v(0) {}\n    ModInt(signed v) : v(v) {}\n    ModInt(long long t) {\n        v = t % MOD;\n        if(v < 0) v += MOD;\n    }\n\n    ModInt pow(long long k) {\n        ModInt res(1), tmp(v);\n        while(k) {\n            if(k & 1) res *= tmp;\n            tmp *= tmp;\n            k >>= 1;\n        }\n        return res;\n    }\n\n    static ModInt add_identity() { return ModInt(0); }\n    static ModInt mul_identity() { return ModInt(1); }\n\n    ModInt inv() { return pow(MOD - 2); }\n\n    ModInt &operator+=(ModInt a) {\n        v += a.v;\n        if(v >= MOD) v -= MOD;\n        return *this;\n    }\n    ModInt &operator-=(ModInt a) {\n        v += MOD - a.v;\n        if(v >= MOD) v -= MOD;\n        return *this;\n    }\n    ModInt &operator*=(ModInt a) {\n        v = 1LL * v * a.v % MOD;\n        return *this;\n    }\n    ModInt &operator/=(ModInt a) { return (*this) *= a.inv(); }\n\n    ModInt operator+(ModInt a) const { return ModInt(v) += a; };\n    ModInt operator-(ModInt a) const { return ModInt(v) -= a; };\n    ModInt operator*(ModInt a) const { return ModInt(v) *= a; };\n    ModInt operator/(ModInt a) const { return ModInt(v) /= a; };\n\n    ModInt operator-() const { return v ? ModInt(MOD - v) : ModInt(v); }\n\n    bool operator==(const ModInt a) const { return v == a.v; }\n    bool operator!=(const ModInt a) const { return v != a.v; }\n    bool operator<(const ModInt a) const { return v < a.v; }\n\n    // find x s.t. a^x = b\n    static T log(T a, T b) {\n        const T sq = 40000;\n        unordered_map<T, T> dp;\n        dp.reserve(sq);\n        ModInt res(1);\n        for(int r = 0; r < sq; r++) {\n            if(!dp.count(res.v)) dp[res.v] = r;\n            res *= a;\n        }\n        ModInt p = ModInt(a).inv().pow(sq);\n        res = b;\n        for(int q = 0; q <= MOD / sq + 1; q++) {\n            if(dp.count(res.v)) {\n                T idx = q * sq + dp[res.v];\n                if(idx > 0) return idx;\n            }\n            res *= p;\n        }\n        assert(0);\n        return T(-1);\n    }\n\n    static ModInt comb(long long n, int k) {\n        ModInt num(1), dom(1);\n        for(int i = 0; i < k; i++) {\n            num *= ModInt(n - i);\n            dom *= ModInt(i + 1);\n        }\n        return num / dom;\n    }\n};\ntemplate <typename T, T MOD>\nconstexpr T ModInt<T, MOD>::mod;\ntemplate <typename T, T MOD>\nostream &operator<<(ostream &os, ModInt<T, MOD> m) {\n    os << m.v;\n    return os;\n}\n\n\n\ntemplate< typename T >\nstruct Combination {\n    vector< T > _fact, _rfact;\n\n    Combination(int sz) : _fact(sz + 1), _rfact(sz + 1) {\n        _fact[0] = _rfact[sz] = 1;\n        for(int i = 1; i <= sz; i++) _fact[i] = _fact[i - 1] * i;\n        _rfact[sz] /= _fact[sz];\n        for(int i = sz - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n    }\n\n    inline T fact(int k) const { return _fact[k]; }\n\n    inline T rfact(int k) const { return _rfact[k]; }\n\n    T P(int n, int r) const {\n        if(r < 0 || n < r) return 0;\n        return fact(n) * rfact(n - r);\n    }\n\n    T C(int p, int q) const {\n        if(q < 0 || p < q) return 0;\n        return fact(p) * rfact(q) * rfact(p - q);\n    }\n\n    T H(int n, int r) const {\n        if(n < 0 || r < 0) return (0);\n        return r == 0 ? 1 : C(n + r - 1, r);\n    }\n};\n\nusing namespace std;\n\nclass CGP2 {\npublic:\n\tvoid solve(std::istream& cin, std::ostream& cout) {\n        using modint = ModInt<lint,998244353>;\n        Combination<modint> comb(4000000);\n        modint ret;\n        int N,M;\n        cin >> N >> M;\n        for (int i = M%2; i <= min(N,M); i+=2) {\n            ret += comb.C(N,i)*comb.H(N,(3*M-i)/2);\n        }\n//        cout << ret << endl;\n        modint mi;\n        for (int i = M%2; i <= min(N,M); i+=2) {\n             mi += (comb.C(N,i)*comb.H(N,(M-i)/2)-comb.C(N-1,i)*comb.H(N-1,(M-i)/2));\n        }\n//        cout << mi << endl;\n        ret -= mi*N;\n        cout << ret << endl;\n\t}\n};\n\n\nint main() {\n\tCGP2 solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 2500005, P = 998244353;\n\nint n, m;\nint fac[N], inv[N];\n\nint qpow(int a, int b) {\n\tint s = 1;\n\tfor (; b; b >>= 1) {\n\t\tif (b & 1) {\n\t\t\ts = 1ll * s * a % P;\n\t\t}\n\t\ta = 1ll * a * a % P;\n\t}\n\treturn s;\n}\n\nvoid init(int n) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfac[i] = 1ll * fac[i - 1] * i % P;\n\t}\n\tinv[n] = qpow(fac[n], P - 2);\n\tfor (int i = n; i; --i) {\n\t\tinv[i - 1] = 1ll * inv[i] * i % P;\n\t}\n}\n\nint C(int n, int m) {\n\tif (m < 0 || m > n) {\n\t\treturn 0;\n\t}\n\treturn 1ll * fac[n] * inv[m] % P * inv[n - m] % P;\n}\n\nint main() {\n\tread(n), read(m);\n\tinit(n + 3 * m);\n\tint ans = 0;\n\tfor (int i = m & 1; i <= n && i <= m; i += 2) {\n\t\tint S = (3 * m - i) >> 1, s = 0;\n\t\tfor (int j = 0; j <= i && m * j <= S; ++j) {\n\t\t\tfor (int k = 0; k <= n - i && m * j + (m + 1) * k <= S; ++k) {\n\t\t\t\tint t = 1ll * C(i, j) * C(n - i, k) % P * C(S - m * j - (m + 1) * k + n - 1, n - 1) % P;\n\t\t\t\tif ((j + k) & 1) {\n\t\t\t\t\ts = (s + P - t) % P;\n\t\t\t\t} else {\n\t\t\t\t\ts = (s + t) % P;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = (ans + 1ll * s * C(n, i)) % P;\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ri register int\nusing namespace std;\nconst int rlen = 1 << 20 | 5;\nchar buf[rlen], *ib = buf, *ob = buf;\n#define gc() (((ib == ob) && (ob = (ib = buf) + fread(buf, 1, rlen, stdin))), ib == ob ? -1 : *ib++)\n#define pb push_back\n#define rez resize\n#define ppp pop_back\ninline int read() {\n  static int ans;\n  static char ch;\n  for (ans = 0, ch = gc(); !isdigit(ch); ch = gc());\n  while (isdigit(ch)) ans = ((ans << 2) + ans << 1) + (ch ^ 48), ch = gc();\n  return ans;\n}\ninline int Read(char *s) {\n  static int top;\n  static char ch;\n  for (ch = gc(), top = 0; !isalpha(ch); ch = gc());\n  while (isalpha(ch)) s[++top] = ch, ch = gc();\n  return top;\n}\ntypedef long long ll;\ntypedef pair <int, int> pii;\n#define fi first\n#define se second\ninline ll readl() {\n  static ll ans;\n  static char ch;\n  for (ans = 0, ch = gc(); !isdigit(ch); ch = gc());\n  while (isdigit(ch)) ans = ((ans << 2) + ans << 1) + (ch ^ 48), ch = gc();\n  return ans;\n}\ntemplate <typename T> inline void exgcd(T a, T b, T &x, T &y) {\n  if (!b) { x = 1, y = 0; return; }\n  exgcd(b, a - a / b * b, y, x), y -= a / b * x;\n}\nnamespace modular {\n  const int mod = 998244353;\n  int ret;\n  inline int add(int a, int b) { return a < mod - b ? a + b : a - mod + b; }\n  inline int dec(int a, int b) { return a < b ? a - b + mod : a - b; }\n  inline int mul(int a, int b) { return (ll) a * b % mod; }\n  inline void Add(int &a, int b) { a = a < mod - b ? a + b : a - mod + b; }\n  inline void Dec(int &a, int b) { a = a < b ? a - b + mod : a - b; }\n  inline void Mul(int &a, int b) { a = (ll) a * b % mod; }\n  inline int ksm(int a, int p) { for (ret = 1; p; p >>= 1, Mul(a, a)) (p & 1) && (Mul(ret, a), 1); return ret; }\n  inline int fix(int x) {\n    x <= -mod || x >= mod ? x %= mod : 0;\n    return x < 0 ? x + mod : x;\n  }\n  inline int Inv(int a) {\n    static int x, y;\n    return exgcd(a, mod, x, y), fix(x);\n  }\n}  using namespace modular;\nconst int N = 1e6 + 5;\nint n, m, fac[N], ifac[N], f[N];\ninline int C(int n, int m) { return n < m || m < 0 ? 0 : mul(fac[n], mul(ifac[m], ifac[n - m])); }\ninline void init_fac() {\n  int lm = 1000000;\n  fac[0] = fac[1] = ifac[0] = ifac[1] = 1;\n  for (ri i = 2; i <= lm; ++i) fac[i] = mul(fac[i - 1], i);\n  ifac[lm] = Inv(fac[lm]);\n  for (ri i = lm - 1; i > 1; --i) ifac[i] = mul(ifac[i + 1], i + 1);\n}\nint main() {\n  #ifdef ldxcaicai\n  freopen(\"lx.in\", \"r\", stdin);\n  #endif\n  n = read(), m = read(), init_fac();\n  int res = 0, tot = 0;\n  for (ri x = m, cur; x >= 0; x -= 2) {\n    int mt = C(n, x), S = (3 * m - x) / 2;\n    cur = C(S + n - 1, n - 1);\n    Dec(cur,  mul(n - x, C(S - (m + 1) + n - 1, n - 1)));\n    Dec(cur,  mul(x, C(S - m + n - 1, n - 1)));\n    Mul(mt, cur);\n    Add(res, mt);\n  }\n  cout << res;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Words are flowing out like endless rain into a paper cup\n// They slither while they pass they slip away across the universe\n// Pools of sorrow, waves of joy are drifting through my open mind\n// Possessing and caressing me\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n    if (ib == ie) {\n        ib = ibuf;\n        ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n    }\n    return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n    using namespace _buff;\n    LL ret = 0;\n    bool pos = true;\n    char c = getc();\n    for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n        assert(~c);\n    }\n    if (c == '-') {\n        pos = false;\n        c = getc();\n    }\n    for (; c >= '0' && c <= '9'; c = getc()) {\n        ret = (ret << 3) + (ret << 1) + (c ^ 48);\n    }\n    return pos ? ret : -ret;\n}\n\nconst size_t N = 6e6 + 5;\nconst int MOD = 998244353;\n\nint qpow(int base, int e) {\n    int ret = 1;\n    for (; e; e >>= 1) {\n        if (e & 1) {\n            ret = (LL) ret * base % MOD;\n        }\n        base = (LL) base * base % MOD;\n    }\n    return ret;\n}\n\nvoid ladd(int &ans, LL val) {\n    ans = (ans + val) % MOD;\n}\n\nint fac[N], inv[N];\n\nvoid prep() {\n    fac[0] = 1;\n    for (int i = 1; i < N; ++i) {\n        fac[i] = (LL) fac[i - 1] * i % MOD;\n    }\n    inv[N - 1] = qpow(fac[N - 1], MOD - 2);\n    for (int i = N - 1; i; --i) {\n        inv[i - 1] = (LL) inv[i] * i % MOD;\n    }\n}\n\nLL comb(int n, int m) {\n    if (n < m) return 0;\n    return (LL) fac[n] * inv[m] % MOD * inv[n - m] % MOD;\n}\n\nLL calc(int n, int m) {\n    // n split into the sum of m non-negative integers\n    return comb(n + m - 1, m - 1);\n}\n\nint main() {\n    prep();\n    int n = read(), m = read();\n    int ans = 0;\n    for (int i = 0; i <= min(n, m); ++i) {\n        if ((3 * m - i) & 1) continue;\n        ladd(ans, comb(n, i) * calc((3 * m - i) / 2, n));\n    }\n    for (int i = 2 * m + 1; i <= 3 * m; ++i) {\n        ladd(ans, -calc(3 * m - i, n - 1) * n);\n    }\n    if (ans < 0) ans += MOD;\n    cout << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = vector<int>;\nusing Vll = vector<ll>;\nusing Vld = vector<ld>;\nusing Vbo = vector<bool>;\nusing VV = vector<V>;\nusing VVll = vector<Vll>;\nusing VVld = vector<Vld>;\nusing VVbo = vector<Vbo>;\nusing VVV = vector<VV>;\nusing VVVll = vector<VVll>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\n#define rep2(i, m, n) for (int i = (m); i < (n); ++i)\n#define drep2(i, m, n) for (int i = (m)-1; i >= (n); --i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) (a).begin(), (a).end()\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\ntemplate<typename T> inline int sz(T &x) { return x.size(); }\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << '(' << p.first << \", \" << p.second << ')'; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << ' '; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int fLog2(const int x) { assert(x > 0); return 31-__builtin_clz(x); } // floor(log2(x))\ninline int fLog2(const ll x) { assert(x > 0); return 63-__builtin_clzll(x); }\ninline int cLog2(const int x) { assert(x > 0); return (x == 1) ? 0 : 32-__builtin_clz(x-1); } // ceil(log2(x))\ninline int cLog2(const ll x) { assert(x > 0); return (x == 1) ? 0 : 64-__builtin_clzll(x-1); }\ninline int popcount(const int x) { return __builtin_popcount(x); }\ninline int popcount(const ll x) { return __builtin_popcountll(x); }\nconst int INF  = 1<<30;\nconst ll INFll = 1ll<<62;\nconst ld EPS   = 1e-10;\nconst ld PI    = acos(-1.0);\n// const int MOD  = int(1e9)+7;\nconst int MOD  = 998244353;\n\n\nstruct mint {\n  ll x;\n  mint(ll x=0) : x((x%MOD+MOD)%MOD) {}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) { if ((x += a.x) >= MOD) x -= MOD; return *this; }\n  mint& operator-=(const mint a) { if ((x -= a.x) < 0) x += MOD; return *this; }\n  mint& operator*=(const mint a) { (x *= a.x) %= MOD; return *this; }\n  mint operator+(const mint a) const { return mint(*this) += a; }\n  mint operator-(const mint a) const { return mint(*this) -= a; }\n  mint operator*(const mint a) const { return mint(*this) *= a; }\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n  mint& operator/=(const mint r) {\n    ll a = r.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      ll t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = x * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  mint operator/(const mint a) const { return mint(*this) /= a; }\n};\n// istream& operator>>(istream& is, mint& a) { return is >> a.x; }\nostream& operator<<(ostream& os, const mint& a) { return os << a.x; }\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\nusing VVVm = vector<VVm>;\n\n\n// initialization\nconst int F_MAX = int(3e6)+10;\nll fac[F_MAX], finv[F_MAX], inv[F_MAX];\nvoid binom_init() {\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (int i = 2; i < F_MAX; ++i) {\n    fac[i] = fac[i-1] * i % MOD;\n    inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n    finv[i] = finv[i-1] * inv[i] % MOD;\n  }\n}\n\nmint binom(int n, int k) {\n  if (k < 0 || n < k) return 0;\n  return fac[n] * (finv[k] * finv[n-k] % MOD);\n}\n\nmint perm(int n, int k) {\n  if (k < 0 || n < k) return 0;\n  return fac[n] * finv[n-k];\n}\n\n\nint main() {\n  binom_init();\n  int n, m; cin >> n >> m;\n\n  auto f = [&] (int l) {\n    if (l >= 0 && l % 2 == 0) return binom(n+l/2-1, l/2);\n    else return mint(0);\n  };\n\n  mint ans = 0;\n  rep(k, min(n, m)+1) {\n    mint res = 0;\n    res += f(3*m - k);\n    res -= f(3*m - (2*m+k)) * k;\n    res -= f(3*m - (2*m+2+k)) * (n-k);\n    ans += res * binom(n, k);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <chrono>\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define FOR(i,m,n) for(int i=(m);i<(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\nconst int INF = 0x3f3f3f3f;\nconst long long LINF = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-8;\nconst int MOD = 998244353;\nconst int dy[] = {1, 0, -1, 0}, dx[] = {0, -1, 0, 1};\n/*-------------------------------------------------*/\nlong long mod_inv(long long a, long long mod = MOD) {\n  a %= mod;\n  if (__gcd(a, mod) != 1) return -1;\n  long long b = mod, x = 1, y = 0;\n  while (b > 0) {\n    long long tmp = a / b;\n    a -= tmp * b;\n    swap(a, b);\n    x -= tmp * y;\n    swap(x, y);\n  }\n  x %= mod;\n  if (x < 0) x += mod;\n  return x;\n}\n\nconst int MAX = 10000000;\nlong long fact[MAX + 1], fact_inv[MAX + 1];\nvoid nCk_init(int val = MAX, long long mod = MOD) {\n  fact[0] = 1;\n  FOR(i, 1, val + 1) fact[i] = fact[i - 1] * i % mod;\n  fact_inv[val] = mod_inv(fact[val], mod);\n  for (int i = val; i > 0; --i) fact_inv[i - 1] = fact_inv[i] * i % mod;\n}\n\nlong long nCk(int n, int k, long long mod = MOD) {\n  if (n < 0 || n < k || k < 0) return 0;\n  return fact[n] * fact_inv[k] % mod * fact_inv[n - k] % mod;\n}\n\nint main() {\n  cin.tie(0); ios::sync_with_stdio(false);\n  // freopen(\"input.txt\", \"r\", stdin);\n\n  nCk_init();\n  int n, m; cin >> n >> m;\n  long long ans = 0;\n  REP(i, min(n, m) + 1) {\n    int gp = 3 * m - i;\n    if (gp & 1) continue;\n    gp /= 2;\n    (ans += nCk(n, i) * nCk(gp + n - 1, n - 1) % MOD) %= MOD;\n  }\n  long long tmp = 0;\n  REP(i, m) (tmp += nCk(i + n - 2, n - 2)) %= MOD;\n  (tmp *= n) %= MOD;\n  ans -= tmp;\n  if (ans < 0) ans += MOD;\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst LL mod=998244353;\nconst LL LINF=1LL<<62;\nconst LL INF=1<<17;\n\n\nint main(){\n    int n,m;cin >> n >> m;\n    vector<LL> S(3*m+1,0);\n    vector<LL> T(3*m+1,0);\n    for (int i = 0; i <= 2*m; i++) {\n        S[i]=1;\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = m-1; j >= 0; j--) {\n            T[j]=(T[j]+T[j+1]+S[0]-S[j+m+1]+mod)%mod;\n        }\n        for (int j = 2*m; j >= 0; j--) {\n            S[j]=(S[j]+S[j+1])%mod;\n        }\n    }\n    cout << (T[0]-T[1]+mod)%mod << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author edamat\n */\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for(int i = int(a), i##_len = (b); i < i##_len; ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\n#define _repr(i, n) repri(i, n, 0)\n/* loop in [n,m] step -1 */\n#define repri(i, a, b) for(int i = int(a), i##_len = (b); i >= i##_len; --i)\n/* loop in [n,0] step -1 or [n,m] step -1 */\n#define repr(...) _overload3(__VA_ARGS__, repri, _repr, )(__VA_ARGS__)\n#define all(x) (x).begin(), (x).end()\n#define debug(x) cerr << #x << \": \" << (x) << '\\n'\n#define eb emplace_back\n//#define endl '\\n'\ntypedef long long lint;\n// #define int lint\nconst int INF = (int)(1 << 30) - 1;\nint MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nconst lint LINF = (lint)(1LL << 62) - 1;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n\nstruct IoSetup {\n    IoSetup() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n//        cout << fixed << setprecision(20);\n//        cerr << fixed << setprecision(20);\n    }\n} iosetup;\n\nusing std::to_string;\nauto to_string(std::string s) -> std::string {\n    return '\"' + s + '\"';\n}\nauto to_string(char c) -> std::string {\n    return \"'\" + std::string{c} + \"'\";\n}\nauto to_string(const char* s) -> std::string {\n    return to_string((std::string) s);\n}\nauto to_string(bool b) -> std::string {\n    return (b ? \"true\" : \"false\");\n}\ntemplate <typename T, typename U>\nauto to_string(std::pair<T, U> p) -> std::string {\n    return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <size_t N>\nauto to_string(std::bitset<N> bs) -> std::string {\n    std::string res{};\n    for (size_t i = 0; i < N; i++)\n        res.insert(res.begin(), bs.test(i) ? '1' : '0');\n    return res;\n}\ntemplate <typename T>\nauto to_string(T v) -> std::string {\n    bool flg = false;\n    std::string res = \"[\";\n    for (auto const&x : v) {\n        if (flg) res += \", \";\n        else flg = true;\n        res += to_string(x);\n    }\n    res += \"]\";\n    return res;\n}\n\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n#define SZ(x) ((int)(x).size())\n\n/* range macro. usage: for(int i:range(n)) */\nclass range {\nprivate:\n    struct I {\n        int x;\n        int operator*() { return x; }\n        bool operator!=(I &lhs) { return x < lhs.x; }\n        void operator++() { ++x; }\n    };\n    I i, n;\n\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    I &begin() { return i; }\n    I &end() { return n; }\n};\n\n/* keep a max,min */\ntemplate <class T>\nbool chmax(T &a, const T &b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\ntemplate <class T>\nbool chmin(T &a, const T &b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\n/* input,output operator for pair and vector */\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\n\ntemplate <typename T1, typename T2>\nistream &operator>>(istream &is, pair<T1, T2> &p) {\n    is >> p.first >> p.second;\n    return is;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    for(int i = 0; i < (int)v.size(); i++) {\n        os << v[i] << (i + 1 != v.size() ? \", \" : \"\");\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &v) {\n    for(T &in : v) is >> in;\n    return is;\n}\n\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const map<T, U> &mp) {\n    for(auto x = mp.begin(); x != mp.end(); ++x) {\n        os << x->first << \": \" << x->second\n           << (x != prev(mp.end()) ? \"\\n\" : \"\");\n    }\n    return os;\n}\n\n/* initialize vector. usage: auto v = male_v<int>(N,0); */\ntemplate <typename T>\nvector<T> make_v(size_t a) {\n    return vector<T>(a);\n}\n\ntemplate <typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n/* fill vector. usage: fill_v(v,0); */\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value == 0>::type fill_v(T &t, const V &v) {\n    t = v;\n}\n\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value != 0>::type fill_v(T &t, const V &v) {\n    for(auto &e : t) fill_v(e, v);\n}\n\n/* sum */\ntemplate <typename T>\nT sum(vector<T> &v) {\n    T ret = 0;\n    for(T x : v) {\n        ret += x;\n    }\n    return ret;\n}\ntemplate <typename T>\nauto sum(const T &a) {\n    return a;\n}\ntemplate <typename T, typename... A>\nauto sum(const T &first, const A &... rest) {\n    return sum(first) + sum(rest...);\n}\n\n/* mod */\nlint intpow(lint a, lint n, lint mod) {\n    lint res = 1;\n    while(n > 0) {\n        if(n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\ntemplate <typename T>\nT intpow(T a, lint n) {\n    T res = 1;\n    while(n > 0) {\n        if(n & 1) res = res * a;\n        a = a * a;\n        n >>= 1;\n    }\n    return res;\n}\n\nlong long modinv(long long a, long long m) {\n    long long b = m, u = 1, v = 0;\n    while(b) {\n        long long t = a / b;\n        a -= t * b;\n        swap(a, b);\n        u -= t * v;\n        swap(u, v);\n    }\n    u %= m;\n    if(u < 0) u += m;\n    return u;\n}\n\n/* print */\ntemplate <typename T>\nvoid print(const T &first) {\n    cout << first << endl;\n}\ntemplate <typename T, typename... A>\nvoid print(const T &first, const A &... rest) {\n    cout << first << \" \";\n    print(rest...);\n}\ntemplate <typename... A>\nvoid print(const A &... rest) {\n    print(rest...);\n}\n\n/* Modint */\ntemplate <typename T, T MOD = 1000000007>\nstruct ModInt {\n    static constexpr T mod = MOD;\n    T v;\n    ModInt() : v(0) {}\n    ModInt(signed v) : v(v) {}\n    ModInt(long long t) {\n        v = t % MOD;\n        if(v < 0) v += MOD;\n    }\n\n    ModInt pow(long long k) {\n        ModInt res(1), tmp(v);\n        while(k) {\n            if(k & 1) res *= tmp;\n            tmp *= tmp;\n            k >>= 1;\n        }\n        return res;\n    }\n\n    static ModInt add_identity() { return ModInt(0); }\n    static ModInt mul_identity() { return ModInt(1); }\n\n    ModInt inv() { return pow(MOD - 2); }\n\n    ModInt &operator+=(ModInt a) {\n        v += a.v;\n        if(v >= MOD) v -= MOD;\n        return *this;\n    }\n    ModInt &operator-=(ModInt a) {\n        v += MOD - a.v;\n        if(v >= MOD) v -= MOD;\n        return *this;\n    }\n    ModInt &operator*=(ModInt a) {\n        v = 1LL * v * a.v % MOD;\n        return *this;\n    }\n    ModInt &operator/=(ModInt a) { return (*this) *= a.inv(); }\n\n    ModInt operator+(ModInt a) const { return ModInt(v) += a; };\n    ModInt operator-(ModInt a) const { return ModInt(v) -= a; };\n    ModInt operator*(ModInt a) const { return ModInt(v) *= a; };\n    ModInt operator/(ModInt a) const { return ModInt(v) /= a; };\n\n    ModInt operator-() const { return v ? ModInt(MOD - v) : ModInt(v); }\n\n    bool operator==(const ModInt a) const { return v == a.v; }\n    bool operator!=(const ModInt a) const { return v != a.v; }\n    bool operator<(const ModInt a) const { return v < a.v; }\n\n    // find x s.t. a^x = b\n    static T log(T a, T b) {\n        const T sq = 40000;\n        unordered_map<T, T> dp;\n        dp.reserve(sq);\n        ModInt res(1);\n        for(int r = 0; r < sq; r++) {\n            if(!dp.count(res.v)) dp[res.v] = r;\n            res *= a;\n        }\n        ModInt p = ModInt(a).inv().pow(sq);\n        res = b;\n        for(int q = 0; q <= MOD / sq + 1; q++) {\n            if(dp.count(res.v)) {\n                T idx = q * sq + dp[res.v];\n                if(idx > 0) return idx;\n            }\n            res *= p;\n        }\n        assert(0);\n        return T(-1);\n    }\n\n    static ModInt comb(long long n, int k) {\n        ModInt num(1), dom(1);\n        for(int i = 0; i < k; i++) {\n            num *= ModInt(n - i);\n            dom *= ModInt(i + 1);\n        }\n        return num / dom;\n    }\n};\ntemplate <typename T, T MOD>\nconstexpr T ModInt<T, MOD>::mod;\ntemplate <typename T, T MOD>\nostream &operator<<(ostream &os, ModInt<T, MOD> m) {\n    os << m.v;\n    return os;\n}\n\n\n\ntemplate< typename T >\nstruct Combination {\n    vector< T > _fact, _rfact;\n\n    Combination(int sz) : _fact(sz + 1), _rfact(sz + 1) {\n        _fact[0] = _rfact[sz] = 1;\n        for(int i = 1; i <= sz; i++) _fact[i] = _fact[i - 1] * i;\n        _rfact[sz] /= _fact[sz];\n        for(int i = sz - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n    }\n\n    inline T fact(int k) const { return _fact[k]; }\n\n    inline T rfact(int k) const { return _rfact[k]; }\n\n    T P(int n, int r) const {\n        if(r < 0 || n < r) return 0;\n        return fact(n) * rfact(n - r);\n    }\n\n    T C(int p, int q) const {\n        if(q < 0 || p < q) return 0;\n        return fact(p) * rfact(q) * rfact(p - q);\n    }\n\n    T H(int n, int r) const {\n        if(n < 0 || r < 0) return (0);\n        return r == 0 ? 1 : C(n + r - 1, r);\n    }\n};\n\nusing namespace std;\n\nclass CGP2 {\npublic:\n\tvoid solve(std::istream& cin, std::ostream& cout) {\n        using modint = ModInt<lint,998244353>;\n        Combination<modint> comb(10000000);\n        modint ret;\n        int N,M;\n        cin >> N >> M;\n        for (int i = M%2; i <= min(N,M); i+=2) {\n            ret += comb.C(N,i)*comb.H(N,(3*M-i)/2);\n        }\n        modint mi;\n        for (int i = M%2; i <= min(N,M); i+=2) {\n             mi += (comb.C(N,i)*comb.H(N,(M-i)/2)-comb.C(N-1,i)*comb.H(N-1,(M-i)/2));\n        }\n        ret -= mi*N;\n        cout << ret << endl;\n\t}\n};\n\n\nint main() {\n\tCGP2 solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\n#define mem(a,v) memset((a), (v), sizeof (a))\n#define enl printf(\"\\n\")\n#define case(t) printf(\"Case #%d: \", (t))\n#define ni(n) scanf(\"%d\", &(n))\n#define nl(n) scanf(\"%lld\", &(n))\n#define nai(a, n) for (int i = 0; i < (n); i++) ni(a[i])\n#define nal(a, n) for (int i = 0; i < (n); i++) nl(a[i])\n#define pri(n) printf(\"%d\\n\", (n))\n#define prl(n) printf(\"%lld\\n\", (n))\n#define pii pair<int, int>\n#define pil pair<int, long long>\n#define pll pair<long long, long long>\n#define vii vector<pii>\n#define vil vector<pil>\n#define vll vector<pll>\n#define vi vector<int>\n#define vl vector<long long>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef cc_hash_table<int,int,hash<int>> ht;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> oset;\nconst double pi = acos(-1);\nconst int MOD = 998244353;\nconst int INF = 1e9 + 7;\nconst int MAXN = 1e6 + 5;\nconst double eps = 1e-9;\nll fac[MAXN], ifac[MAXN];\n\nll pw(ll a, ll b) {\n\tll r = 1;\n\twhile (b) {\n\t\tif (b & 1)\n\t\t\tr = (r * a) % MOD, b--;\n\t\telse\n\t\t\ta = (a * a) % MOD, b /= 2;\n\t}\n\treturn r;\n}\n\nll ncr(int n, int k) {\n\treturn (fac[n] * ifac[k] % MOD) * ifac[n-k] % MOD;\n}\n\nint main() {\n\tfac[0] = 1;\n\tifac[0] = 1;\n\tfor (ll i = 1; i < MAXN; i++) {\n\t\tfac[i] = (fac[i-1] * i) % MOD;\n\t\tifac[i] = pw(fac[i], MOD - 2);\n\t}\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tif (n == 2)\n\t\treturn !pri(m+1);\n\tll ans = ncr(3*m+n-1, n-1);\n\tfor (int i = 2*m+1; i <= 3*m; i++)\n\t\tans = (ans - (ll)n * ncr(3*m-i+n-2, n-2) % MOD + MOD) % MOD;\n\tfor (int i = 0; i < m; i++)\n\t\tif (n >= 3*m-2*i)\n\t\t\tans = (ans - ncr(i+n-1,n-1) * ncr(n, 3*m-i*2) % MOD + MOD) % MOD;\n\tprl(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n// #define double long double\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(int i = (a); i > (b); --i)\n#define REP(i, n) for(int i = 0; i < (n); ++i)\n#define REPR(i, n) for(int i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt(x) __builtin_popcount(x)\n#define lbit(x) __builtin_ffsll(x)\n#define rbit(x) (64 - __builtin_clzll(x))\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\n#define rAll(a) (a).rbegin(), (a).rend()\n#define cinfast() cin.tie(0), ios::sync_with_stdio(false)\n#define PERM(c)                                                                \\\n    sort(All(c));                                                              \\\n    for(bool cp = true; cp; cp = next_permutation(All(c)))\n#define COMB(n, k)                                                             \\\n    for(ll bit = (1LL << k) - 1; bit < (1LL << n); bit = next_combination(bit))\n#define PERM2(n, k)                                                            \\\n    COMB(n, k) {                                                               \\\n        vector<int> sel;                                                       \\\n        for(int bitindex = 0; bitindex < n; bitindex++)                        \\\n            if(bit >> bitindex & 1) sel.emplace_back(bitindex);                \\\n        PERM(sel) { Printv(sel); }                                             \\\n    }\n#define MKORDER(n)                                                             \\\n    vector<int> od(n);                                                         \\\n    iota(All(od), 0LL);\n\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\ntemplate <class Head> inline void COUT(Head &&head) { cout << (head) << \"\\n\"; }\ntemplate <class Head, class... Tail>\ninline void COUT(Head &&head, Tail &&... tail) {\n    cout << (head) << \" \";\n    COUT(forward<Tail>(tail)...);\n}\n\n#define CCIN(...)                                                              \\\n    char __VA_ARGS__;                                                          \\\n    CIN(__VA_ARGS__)\n#define DCIN(...)                                                              \\\n    double __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    long long __VA_ARGS__;                                                     \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        FOREACH(x, v) { cout << x << \" \"; }                                    \\\n        cout << \"\\n\";                                                          \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\n\nlong long next_combination(long long sub) {\n    long long x = sub & -sub, y = sub + x;\n    return (((sub & ~y) / x) >> 1) | y;\n}\n\n// generic lambdas\ntemplate <typename F>\n#if defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\n[[nodiscard]]\n#elif defined(__GNUC__) && (__GNUC__ > 3 || __GNUC__ == 3 && __GNUC_MINOR__ >= 4)\n__attribute__((warn_unused_result))\n#endif // defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\n    static inline constexpr decltype(auto)\n    fix(F &&f) noexcept {\n    return [f = std::forward<F>(f)](auto &&... args) {\n        return f(f, std::forward<decltype(args)>(args)...);\n    };\n}\n\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<ll, ll> PL;\ntypedef vector<PL> VPL;\ntypedef vector<bool> VB;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\n\nconst int INF = 1e9;\n// const int MOD = 1e9 + 7;\nconst int MOD = 998244353;\nconst ll LINF = 1e18;\nconst ll dw[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll dh[] = {0, 1, 1, 1, 0, -1, -1, -1};\n#define PI 3.141592653589793238\n#define EPS 1e-7\n\n// 1000000007 で割ったあまりを扱う構造体\ntemplate <int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if(val < 0) v += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator-() const noexcept { return val ? MOD - val : 0; }\n    constexpr Fp operator+(const Fp &r) const noexcept {\n        return Fp(*this) += r;\n    }\n    constexpr Fp operator-(const Fp &r) const noexcept {\n        return Fp(*this) -= r;\n    }\n    constexpr Fp operator*(const Fp &r) const noexcept {\n        return Fp(*this) *= r;\n    }\n    constexpr Fp operator/(const Fp &r) const noexcept {\n        return Fp(*this) /= r;\n    }\n    constexpr Fp &operator+=(const Fp &r) noexcept {\n        val += r.val;\n        if(val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp &operator-=(const Fp &r) noexcept {\n        val -= r.val;\n        if(val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp &operator*=(const Fp &r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp &operator/=(const Fp &r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while(b) {\n            long long t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        val = val * u % MOD;\n        if(val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator==(const Fp &r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator!=(const Fp &r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream &operator<<(ostream &os, const Fp<MOD> &x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream &operator>>(istream &is, Fp<MOD> &x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if(n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if(n & 1) t = t * a;\n        return t;\n    }\n};\n\nusing mint = Fp<MOD>;\n\nconst ll NMAX = 5e6;\nll fac[NMAX + 1], inv[NMAX + 1], finv[NMAX + 1];\n\nvoid cominit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    FOR(i, 2, NMAX + 1) {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\nll comb(ll n, ll k) {\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nll hcomb(ll n, ll k) { return comb(k + n - 1, k); }\n\nsigned main() {\n    LCIN(N, M);\n    cominit();\n    mint ans = hcomb(N, 3 * M);\n    ans -= (mint)N * hcomb(N, M - 1);\n    REP(i, M) { ans -= (mint)hcomb(N, i) * comb(N, 3 * M - 2 * i); }\n    cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD 998244353\n\nstruct llm{\n    ll value=0;\n    llm(const ll& val=0){this->value = (MOD + val % MOD) % MOD;}\n    llm(const int& val=0){this->value = (MOD + val % MOD) % MOD;}\n    llm(const llm& a) { llm(a.value); }\n    llm inv(){ll a = 1;ll b = this->value;for(ll m=MOD-2;m>0;m/=2){if(m&1){a=a*b%MOD;}b=b*b%MOD;}return llm(a);}\n    llm &operator+=(const llm &a) {this->value = (this->value + a.value) % MOD;return *this;}\n    llm &operator-=(const llm &a) {this->value = (this->value - a.value + MOD) % MOD;return *this;}\n    llm &operator*=(const llm &a) {this->value = (this->value * a.value) % MOD; return *this; }\n    explicit operator ll() const{return (ll)value;}\n    explicit operator int() const{return (int)value;}\n};\nllm operator+(const llm &a, const llm &b) { return llm(a.value + b.value); }\nllm operator-(const llm &a, const llm &b) { return llm(a.value - b.value); }\nllm operator*(const llm &a, const llm &b) { return llm(a.value * b.value); }\n#define pllm pair<llm,llm>\n\nllm Fa[5050505];\nllm C(const ll& a,const ll& b){\n    if(a<b)\n        return 0;\n    return Fa[a] * (Fa[b], Fa[a - b]);\n}\n\n\nll N,M;\nll i,j,k;\nllm ans;\nll moddiv(ll a,ll b){\n    a %= MOD;\n    b %= MOD;\n    for(ll m=MOD-2;m>0;m/=2){\n        if(m&1){\n            a=a*b%MOD;\n        }\n        b=b*b%MOD;\n    }\n    return a;\n}\nint main(){\n    scanf(\"%lld%lld\", &N, &M);\n    Fa[0] = 1;\n    fornum(i,0,5040302){\n        Fa[i + 1] = Fa[i] * (i + 1);\n    }\n    ans = C(N - 1 + M * 3, N - 1);\n    \n\n    fornum(i,0,N+1){\n        if(i>M*3)\n            break;\n        if(i<=M){\n            if ((M * 3 - i) % 2 == 0)\n            {\n                ans -= C(N, i) * N * C(N - 1 + (M - 2 - i) / 2, N - 1);\n            }\n            else\n            {\n                ans -= C(N, i - 1) * N * C(N - 1 + (M - 1 - i) / 2, N - 1);\n            }\n        }else{\n            if((M*3-i)%2)\n                continue;\n            ans -= C(N, i) * C(N - 1 + (M * 3 - i) / 2, N - 1);\n        }\n    }\n    printf(\"%lld\", (ll)ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string.h>\n#include <cstdlib>\n#define N 2000005\nusing namespace std;\ntypedef long long ll;\nconst int mod=998244353;\nint n,m;\nll f[N],inv[N];\nll C(int n,int m){\n\treturn f[n]*inv[m]%mod*inv[n-m]%mod;\n}\nll solve(int n,int m){\n\tll ans=0;\n\tfor(int i=m&1;i<=m&&i<=n;i+=2){\n\t\tll w=C(n,i);\n\t\tint res=m*3-i>>1;\n\t\tans=(ans+w*C(res+n-1,n-1))%mod;\n\t}\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tf[0]=f[1]=inv[0]=inv[1]=1;\n\tfor(int i=2;i<=2000002;i++) f[i]=f[i-1]*i%mod,inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=1;i<=2000002;i++) inv[i]=inv[i-1]*inv[i]%mod;\n\tll ans=(solve(n,m)-C(n+m-2,n-1)*n)%mod;\n\tans=(ans+mod)%mod;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n// cout << fixed << setprecision(20);\n\n//拡張ユークリッドの互除法\nint extgcd(int a, int b, int &x, int &y) {\n    int d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1;\n        y = 0;\n    }\n    return d;\n}\n\n// mod逆元\nint mod_inverse(int a, int m) {\n    int x, y;\n    extgcd(a, m, x, y);\n    return (m + x % m) % m;\n}\n\n// 階乗テーブル\nint fact[1600000];\n\nint mod_fact(int n, int m) {\n    fact[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i % m;\n    }\n}\n\nint N, M;\nint mod = 998244353;\n\nint mod_C(int n, int r, int m) {\n    return fact[n] * mod_inverse(fact[r], m) % m * mod_inverse(fact[n - r], m) % m;\n}\n\nint mod_H(int n, int r, int m) {\n    return mod_C(n + r - 1, r, m);\n}\n\nsigned main() {\n    mod_fact(1550000, mod);\n    cin >> N >> M;\n    int ans = mod_H(N, 3 * M, mod);\n    for (int i = 0; i < M; i++) {\n        ans = (ans + mod - (mod_H(N - 1, i, mod) * N % mod)) % mod;\n    }\n    cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n#define all(c) ((c).begin()), ((c).end())\n#define sz(x) ((int)(x).size())\n\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tfor(int i = 0;i < (int)v.size(); i++){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n\nconst int N = 5e6 + 10, mod = 998244353;\nint fact[N], invfact[N];\ninline int add(int x, int y){ x += y; if(x >= mod) x -= mod; return x;}\ninline int sub(int x, int y){ x -= y; if(x < 0) x += mod; return x;}\ninline int mul(int x, int y){ return (((ll) x) * y) % mod;}\ninline int powr(int a, ll b){\n\tint x = 1 % mod;\n\twhile(b){\n\t\tif(b & 1) x = mul(x, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn x;\n}\ninline int inv(int a){ return powr(a, mod - 2);}\nvoid pre(){\n\tfact[0] = invfact[0] = 1;\n\tfor(int i = 1;i < N; i++) fact[i] = mul(i, fact[i - 1]);\n\tinvfact[N - 1] = inv(fact[N - 1]);\n\tfor(int i = N - 2; i >= 1; i--) invfact[i] = mul(invfact[i + 1], i + 1);\n\tassert(invfact[1] == 1);\n}\n\ninline int C(int n, int k){\n\tif(n < k || k < 0) return 0;\n\treturn mul(fact[n], mul(invfact[k], invfact[n - k]));\n}\nint ways(int n, int m){\n\tif(n == 0 && m == 0) return 1;\n\treturn C(n + m - 1, n - 1);\n}\nint main(){\n\tpre();\n\tint n, m;\n\tsd(n); sd(m);\n\tint ans = 0;\n\tfor(int odd = m % 2; odd <= m && odd <= n; odd += 2){\n\t\tint req = (3 * m - odd) / 2;\n\t\tans = add(ans, mul(C(n, odd), ways(n, req)));\n\t\t// trace(odd, ans, req);\n\t}\n\t// trace(ans);\n\tfor(int i = 2 * m + 1; i <= 3 * m; i++){\n\t\tans = sub(ans, mul(n, ways(n - 1, 3 * m - i)));\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long ans,n,m,mod=998244353ll,fact[1000005],invfact[1000005],tmp;\n\nlong long fastp(long long base,long long exp){\n    if(exp==0)return 1ll;\n    long long tmp=fastp(base,exp/2ll);\n    tmp=(tmp*tmp)%mod;\n    if(exp%2==1)tmp*=base;\n    return tmp%mod;\n}\n\ninline long long binom(long long a,long long b){\n    if(b>a)return 0ll;\n    return ((fact[a]*invfact[b])%mod*invfact[a-b])%mod;\n}\n\nint main(){\n\n\tcin>>n>>m;\n\t\n\tfact[0]=1;\n\tfor(long long i=1;i<=1000005;i++)fact[i]=(fact[i-1]*i)%mod;\n\tinvfact[1000004]=fastp(fact[1000004],mod-2ll);\n    for(long long i=1000003;i>=0;i--)invfact[i]=(invfact[i+1]*(i+1ll))%mod;\n    \n    ans=binom(n+3*m-1,n-1);\n    \n    //cout<<ans<<endl;\n    \n    for(int i=0;i<m;i++){\n        ans-=(binom(n,i)*binom(n,m*3-2*i))%mod;\n        ans=(ans%mod+mod)%mod;\n    }\n    \n    for(int i=2*m+1;i<=3*m;i++){\n        tmp+=binom(n-2+3*m-i,n-2);\n        tmp%=mod;\n    }\n    \n    ans-=(n*tmp)%mod;\n    ans=(ans%mod+mod)%mod;\n    \n    cout<<ans<<endl;\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\nll mod=998244353;\n\nll fac[3000010];\n \nll modinv(ll a){\n    ll b=mod,u=1,v=0;\n    while(b){\n        ll t=a/b;\n        a-=t*b; swap(a,b);\n        u-=t*v; swap(u,v);\n        }\n        u%=mod;\n        if(u<0) u+=mod;\n    return u;\n}\n \nvoid modfac(){\n    fac[0]=1;\n    for(ll i=1;i<3000010;i++){\n        fac[i]=(fac[i-1]*i)%mod;\n    }\n}\n \nll modperm(ll n,ll k){\n    if(n<0||k<0||n<k) return 0;\n    else return (fac[n]*modinv(fac[n-k]))%mod;\n}\n \nll modcomb(ll n,ll k){\n    if(n<0||k<0||n<k) return 0;\n    else return ((fac[n]*modinv(fac[k]))%mod*modinv(fac[n-k]))%mod;\n}\n\nll modhom(ll n,ll k){\n  if(n==0&&k==0) return 1;\n  else if(n<0||k<0) return 0;\n  else return modcomb(n+k-1,k);\n}\n \nll modpow(ll a,ll b){\n  ll ans=1;\n  a%=mod;\n  while(b){\n    if(b&1) ans=ans*a%mod;\n    a=a*a%mod;\n    b>>=1;\n  }\n  return ans;\n}\n\nint main(){\n  modfac();\n  ll n,m;\n  cin >> n >> m;\n  ll ans=modhom(n,3*m);\n  for(ll i=m+1;i<=n;i++){\n    if((3*m-i)%2==0){\n      ans=(ans-modcomb(n,i)*modhom(n,(3*m-i)/2)%mod+mod)%mod;\n      ans=(ans+modcomb(n,i)*modhom(n,(m-1-i)/2)%mod)%mod;\n    }\n  }\n  ans=(ans-modhom(n,m-1)*n%mod)%mod;\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//lcj ak ioi\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int mod = 998244353;\ninline void upd(int &a,int b)\n{\n\ta += b;\n\tif(a >= mod) a -= mod;\n}\nint N,M;\nint fac[2000005],inq[2000005];\nint qpow(int x,int y)\n{\n\tint ans = 1;\n\twhile(y)\n\t{\n\t\tif(y&1) ans = 1ll*ans*x%mod;\n\t\tx = 1ll*x*x%mod;y >>= 1;\n\t}\n\treturn ans;\n}\nvoid init()\n{\n\tfac[0] = 1;\n\tfor(int i = 1;i <= 2000000;i ++)\n\t\tfac[i] = 1ll*i*fac[i-1]%mod;\n\tinq[2000000] = qpow(fac[2000000],mod-2);\n\tfor(int i = 1999999;i >= 0;i --)\n\t\tinq[i] = 1ll*inq[i+1]*(i+1)%mod;\n}\ninline int C(int x,int y) { return 1ll*fac[x]*inq[x-y]%mod*inq[y]%mod; }\nint solve(int sm)\n{\n\tif(sm < 0)\n\t\treturn 0;\n\t//sum = sm, atmost M odd\n\tint r = min(min(N,M),sm);\n\tint ans = 0;\n\tfor(int i = sm&1;i <= r;i += 2)\n\t\tans = (ans+1ll*C(N,i)*C(N+((sm-i)>>1)-1,N-1))%mod;\n\treturn ans;\n}\nsigned main()\n{\n\tinit();\n\tscanf(\"%lld%lld\",&N,&M);\n\tprintf(\"%lld\\n\",(solve(3*M)-1ll*solve(M-1)*N%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <cassert>\n#include <string>\n#include <set>\n#include <map>\n#include <random>\n#include <bitset>\n#include <string>\n#include <unordered_set>\n#include <unordered_map>\n#include <deque>\n#include <queue>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nconst int MOD = 998244353, N = 3000002;\nll f[N], rf[N];\n\nll pw(ll x, ll k) {\n    ll res = 1;\n    for (int i = 30; i >= 0; i--) {\n        res = res * res % MOD;\n        if (k & (1 << i))\n            res = res * x % MOD;\n    }\n    return res;\n}\n\nll rev(ll x) {\n    return pw(x, MOD - 2);\n}\n\nll c(ll n, ll k) {\n    if (k > n)\n        return 0;\n    return f[n] * rf[k] % MOD * rf[n - k] % MOD;\n}\n\nll b(ll n, ll k) {\n    return c(n + k - 1, n);\n}\n\nint main() {\n#ifdef ONPC\n    freopen(\"a.in\", \"r\", stdin);\n#endif\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    f[0] = rf[0] = 1;\n    for (int i = 1; i < N; i++) {\n        f[i] = f[i - 1] * i % MOD;\n        rf[i] = rf[i - 1] * rev(i) % MOD;\n    }\n\tll n, m;\n    cin >> n >> m;\n    ll ans = b(3 * m, n);\n    for (int i = m + 1; i <= min(n, 3 * m); i++) {\n        if ((3 * m - i) % 2)\n            continue;\n        ans = (ans + MOD - c(n, i) * b((3 * m - i) / 2, n) % MOD) % MOD;\n    }\n    for (int i = 2 * m + 1; i <= 3 * m; i++)\n        ans = (ans + MOD - b(3 * m - i, n - 1) * n % MOD) % MOD;\n    cout << ans;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<n;++i)\n#define FOR(i, a, b) for(int i=a;i<b;++i)\n#define RREP(i, n) for(int i=n-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=b-1;i>=a;--i)\n\n#define all(x) begin(x),end(x)\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 998244353;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\n\nusing Int = ll;\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T1, class T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"[\";\n    for (auto it = mp.begin(); it != mp.end(); ++it) {\n        if (it != mp.begin()) {\n            os << \", \";\n        }\n        os << *it;\n    }\n    return os << \"]\";\n}\n\n// edit\n\nclass Mint {\n    using u64 = std::uint_fast64_t;\n    u64 Modulus = MOD;\n\npublic:\n    u64 a;\n\n    constexpr Mint(const u64 x = 0) noexcept : a(x % Modulus) {}\n\n    constexpr u64 &value() noexcept { return a; }\n\n    constexpr const u64 &value() const noexcept { return a; }\n\n    constexpr Mint operator+(const Mint rhs) const noexcept {\n        return Mint(*this) += rhs;\n    }\n\n    constexpr Mint operator-(const Mint rhs) const noexcept {\n        return Mint(*this) -= rhs;\n    }\n\n    constexpr Mint operator*(const Mint rhs) const noexcept {\n        return Mint(*this) *= rhs;\n    }\n\n    constexpr Mint operator/(const Mint rhs) const noexcept {\n        return Mint(*this) /= rhs;\n    }\n\n    constexpr Mint &operator+=(const Mint rhs) noexcept {\n        a += rhs.a;\n        if (a >= Modulus) {\n            a -= Modulus;\n        }\n        return *this;\n    }\n\n    constexpr Mint &operator-=(const Mint rhs) noexcept {\n        if (a < rhs.a) {\n            a += Modulus;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n\n    constexpr Mint &operator*=(const Mint rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n\n    constexpr Mint &operator/=(Mint rhs) noexcept {\n        u64 exp = Modulus - 2;\n        while (exp) {\n            if (exp % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            exp /= 2;\n        }\n        return *this;\n    }\n\n    constexpr Mint pow(int rhs) noexcept {\n        Mint ret(1);\n        Mint base(a);\n        u64 exp = static_cast<u64>(rhs);\n        while (exp) {\n            if (exp % 2) {\n                ret *= base;\n            }\n            base *= base;\n            exp /= 2;\n        }\n        return ret;\n    }\n\n};\n\n\nclass Combination {\npublic:\n    vector<Mint> fact;\n    vector<Mint> ifact;\n\n    Combination(int n) {\n        fact.resize(static_cast<unsigned long>(n + 1));\n        ifact.resize(static_cast<unsigned long>(n + 1));\n\n        fact[0] = ifact[0] = Mint(1);\n        for (int i = 1; i <= n; ++i) {\n            fact[i] = fact[i - 1] * Mint(i);\n            ifact[i] = Mint(1) / fact[i];\n        }\n    }\n\n    Mint nPk(Int n, Int k) {\n        return fact[n] * ifact[n - k];\n    }\n\n    Mint nCk(Int n, Int k) {\n        return fact[n] * ifact[n - k] * ifact[k];\n    }\n\n    Mint nHk(Int n, Int k) {\n        return nCk(n + k - 1, k - 1);\n    }\n};\n\nCombination cmb((int) 2e6);\n\nMint f(int n, int m, int k) {\n    Mint ret = 0;\n    for (int a = m % 2; a <= min(k, n); a += 2) {\n        Mint left = cmb.nCk(n, a);\n        Mint right = cmb.nCk((m - a) / 2 + n - 1, n - 1);\n        Mint tmp = left * right;\n        ret += tmp;\n    }\n\n    return ret;\n}\n\nvoid solve() {\n    int N, M;\n    cin >> N >> M;\n\n    Mint a1 = f(N, 3 * M, M);\n    Mint a2 = f(N, M, M);\n    Mint a3 = f(N - 1, M, M);\n\n    Mint ans = a1 - (a2 - a3) * N;\n    cout << ans.value() << endl;\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n//    std::ifstream in(\"input.txt\");\n//    std::cin.rdbuf(in.rdbuf());\n\n    solve();\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e6 + 10;\nconst int mod = 998244353;\n\ninline int fpow (int a, int b) {\n\tint ret = 1;\n\twhile (b) {\n\t\tret = 1ll * ret * a % mod;\n\t\ta = 1ll * a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\n\nint f[N], invf[N];\n\nvoid predeal (int n) {\n\tf[0] = invf[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[i] = 1ll * f[i - 1] * i % mod;\n\t}\n\tinvf[n] = fpow(f[n], mod - 2);\n\tfor (int i = n - 1; i >= 1; i--) {\n\t\tinvf[i] = 1ll * invf[i + 1] * (i + 1) % mod; \n\t}\n}\n\ninline int C (int n, int m) {\n\treturn 1ll * f[n] * invf[m] % mod * invf[n - m] % mod;\n}\n\nint main (void) {\n\tpredeal(2e6);\n\n\tint n, m, ans = 0;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i <= m; i++) {\n\t\tif ((m - i) & 1) continue;\n\t\tans += 1ll * C(n, i) * C((3 * m - i) / 2 + n - 1, n - 1) % mod;\n\t\tcout << 1ll * C(n, i) * C((3 * m - i) / 2 + n - 1, n - 1) % mod << endl;\n\t\tif (ans >= mod) ans -= mod;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tif ((m - 1 - i) & 1) continue;\n\t\tans -= 1ll * C(n, 1) * C(n, i) % mod * C((m - 1 - i) / 2 + n - 1, n - 1) % mod;\n\t\tcout << 1ll * C(n, 1) * C(n, i) % mod * C((m - 1 - i) / 2 + n - 1, n - 1) % mod << endl;\n\t\tif (ans < 0) ans += mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <array>\n#include <list>\n#include <stack>\n#include <valarray>\n\nusing namespace std;\n\ntypedef unsigned uint;\ntypedef long long Int;\ntypedef unsigned long long UInt;\n\nconst int INF = 1001001001;\nconst Int INFLL = 1001001001001001001LL;\n\ntemplate<typename T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<typename T> void chmin(T& a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T& a, T b) { if (a < b) a = b; }\nint in() { int x; scanf(\"%d\", &x); return x; }\ndouble fin() { double x; scanf(\"%lf\", &x); return x; }\nInt lin() { Int x; scanf(\"%lld\", &x); return x; }\n\nconst int LIM = 3000000;\nconst Int MO = 998244353;\nInt fac[LIM], ifac[LIM], inv[LIM];\n\nInt comb(int n, int k) {\n  return fac[n] * ifac[k] % MO * ifac[n - k] % MO;\n}\n\nInt add(Int& x, Int y) {\n  (x += y) %= MO;\n  return x;\n}\n\nInt sub(Int& x, Int y) {\n  (x += MO - y % MO) %= MO;\n  // add(x, MO - y % MO);\n  return x;\n}\n\nint main() {\n  fac[0] = 1;\n  ifac[0] = 1;\n  inv[1] = 1;\n  for (int i = 2; i < LIM; ++i) {\n    inv[i] = MO - MO / i * inv[MO % i] % MO;\n  }\n  for (int i = 1; i < LIM; ++i) {\n    fac[i] = fac[i - 1] * i % MO;\n    ifac[i] = ifac[i - 1] * inv[i] % MO;\n  }\n\n  int N = in();\n  int M = in();\n  if (N == 2) {\n    printf(\"%d\\n\", M + 1);\n    return 0;\n  }\n\n  Int res = comb(3 * M + N - 1, N - 1);\n  for (int sz = 2 * M + 1; sz <= 3 * M; ++sz) {\n    if (sz == 3 * M) {\n      sub(res, N);\n    } else {\n      const int R = 3 * M - sz;\n      sub(res, comb(R + N - 2, 1) * comb(R + N - 3, N - 3));\n      sub(res, comb(R + N - 2, N - 2) * 2);\n    }\n  }\n\n  for (int os = M + 2; os <= N && os <= 3 * M; os += 2) {\n    const int R = 3 * M - os;\n    sub(res, comb(R / 2 + N - 1, N - 1) * comb(N, os));\n  }\n\n  printf(\"%lld\\n\", res);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\nll mod=998244353;\n\nll fac[3000010];\n \nll modinv(ll a){\n    ll b=mod,u=1,v=0;\n    while(b){\n        ll t=a/b;\n        a-=t*b; swap(a,b);\n        u-=t*v; swap(u,v);\n        }\n        u%=mod;\n        if(u<0) u+=mod;\n    return u;\n}\n \nvoid modfac(){\n    fac[0]=1;\n    for(ll i=1;i<3000010;i++){\n        fac[i]=(fac[i-1]*i)%mod;\n    }\n}\n \nll modperm(ll n,ll k){\n    if(n<0||k<0||n<k) return 0;\n    else return (fac[n]*modinv(fac[n-k]))%mod;\n}\n \nll modcomb(ll n,ll k){\n    if(n<0||k<0||n<k) return 0;\n    else return ((fac[n]*modinv(fac[k]))%mod*modinv(fac[n-k]))%mod;\n}\n \nll modpow(ll a,ll b){\n  ll ans=1;\n  a%=mod;\n  while(b){\n    if(b&1) ans=ans*a%mod;\n    a=a*a%mod;\n    b>>=1;\n  }\n  return ans;\n}\n\nll dp[1000000];\n\nint main(){\n  modfac();\n  ll n,m;\n  cin >> n >> m;\n  ll ans=modcomb(n+3*m-1,3*m);\n  for(ll i=0;i<m;i++){\n    ans=(ans-n*modcomb(n+i-2,i)%mod+mod)%mod;\n  }\n  for(ll i=m+1;i<=n;i++){\n    ll x=i-m;\n    if(x%2==0){\n      x=(x+1)*x/2;\n      ans=(ans+mod-x*modcomb(n+1,n-i)%mod*modcomb(n,i)%mod)%mod;\n    }\n    else{\n      x=(x+1)*x/2;\n      ans=(ans+x*modcomb(n+1,n-i)%mod*modcomb(n,i)%mod)%mod;\n    }\n    //cerr << x*modcomb(n+1,n-i)%mod*modcomb(n,i)%mod << endl;\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<LL,LL> P;\nconst LL mod=998244353;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\n\n\nvector<LL> fact;\nvector<LL> inver(2000001);\n \nLL combi(int n,int r){\n    if(n<r||n<0||r<0) return 0;\n    return fact[n]%mod*inver[n-r]%mod*inver[r]%mod;\n}\n \n \nLL fpow(LL a, LL n){\n    LL x = 1;\n    while(n > 0){\n        if(n&1){\n            x=x*a%mod;\n        }\n        a=a*a%mod;\n        n >>= 1;\n    }\n    return x;\n}\n \nvoid set_combi(){\n    LL s=1;\n    fact.push_back(1);\n    for(int i=1;i<=2000000;i++){\n        s*=i;\n        s%=mod;\n        fact.push_back(s);\n    }\n    inver[2000000]=fpow(fact[2000000],mod-2);\n    for(int i=1999999;i>=0;i--){\n        inver[i]=inver[i+1]*(i+1)%mod;\n    }\n}\n \nLL hcombi(int n,int r){\n    return combi(n+r-1,r); \n}\n\n\n\nint main(){\n    set_combi();\n    LL n,m;cin >> n >> m;\n    LL ans = 0;\n    for (int i = min(n,m); i >= 0; i-=2) {\n        ans = (ans + hcombi(n,m+(m-i)/2) * combi(n,i))%mod;\n    }\n    for (int i = 2*m+1; i <= 3*m; i++) {\n        ans = (ans - (n * hcombi(n-1,3*m-i))%mod + mod)%mod;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing i64 = long long;\n\nint main() {\n    i64 n, k;\n    std::cin >> n >> k;\n    std::vector<int> a(n), nxt(n, -1), prev(200010, -1), fst(200010, -1);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n        if (prev[a[i]] < 0) {\n            fst[a[i]] = i;\n            prev[a[i]] = i;\n        } else {\n            nxt[prev[a[i]]] = i;\n            prev[a[i]] = i;\n        }\n    }\n    for (int i = 0; i < n; i++) if (nxt[i] < 0) nxt[i] = fst[a[i]];\n    std::deque<std::pair<int, int>> q { { 0, -1 } };\n    auto c = std::make_pair(0, 0);\n    while (true) {\n        auto x = nxt[c.second];\n        if (x <= c.second) ++c.first;\n        c.second = x;\n        q.push_back(c);\n        if (c.second == n - 1) break;\n        c.second++;\n    }\n\n    auto t = q.back().first + 1;\n    auto r = k % t;\n\n    std::deque<int> ret;\n    std::set<int> ss;\n    if (r > 0) {\n        auto it = q.begin();\n        while (it->first < r) it++;\n        --it;\n        for (int i = it->second + 1; i < n; i++) {\n            if (!ss.count(a[i])) {\n                ret.push_back(a[i]);\n                ss.insert(a[i]);\n            } else {\n                while (true) {\n                    int v = ret.back();\n                    ret.pop_back();\n                    ss.erase(v);\n                    if (v == a[i]) break;\n                }\n            }\n        }\n    }\n\n    for (auto e : ret) std::cout << e << \" \";\n    std::cout << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return (rng() % (y+1-x)) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\ntypedef long long ll; \ntypedef long double ld;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\ntypedef pair<ll,ll>pi; typedef pair<ll,pi>spi; typedef pair<pi,pi>dpi;\n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (2600006)\nll n, m, mod = 998244353, f[MAXN], inv[MAXN];\nint main(){\n\tFAST\n\tcin>>n>>m;\n\tauto qexp=[&](ll x,ll e){\n\t\tll sum=1;\n\t\twhile(e){\n\t\t\tif(e&1) sum*=x, sum%=mod;\n\t\t\tx*=x,x%=mod;\n\t\t\te>>=1;\n\t\t}\n\t\treturn sum;\n\t};\n\tf[0]=1; FOR(i,1,MAXN-1) f[i]=f[i-1]*i%mod;\n\tinv[MAXN-1] = qexp(f[MAXN-1], mod-2); DEC(i,MAXN-2,0) inv[i]=inv[i+1]*(i+1)%mod;\n\tauto C=[&](ll n,ll k){\n\t\treturn n < k ? 0ll : f[n] * inv[k] % mod * inv[n-k] % mod;\n\t};\n\tll ans=C(3*m+(n-1), n-1);\n\tcerr<<ans<<'\\n';\n\tans -= n * C(3*m-(2*m+1)+(n-1), n-1) % mod, ans += mod, ans %= mod;\n\tFOR(odd,m+1,n){\n\t\tif((3*m-odd)%2==0) ans -= C(n, odd) * C((3*m - odd)/2 + (n-1), n-1) % mod, ans += mod, ans %= mod;\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N=3000050;\nconst int mod=998244353;\nint mul(int x, int y){ return (ll)x*y%mod;}\nint add(int x, int y){ x+=y;return x>=mod?x-mod:x;}\nint pow(int x, int k){ int ans=1;for(;k;k>>=1,x=mul(x,x)) if(k&1) ans=mul(ans,x);return ans;}\nint F[N],I[N];\nvoid Calc()\n{\n\tF[0]=1;\n\tfor(int i=1;i<N;i++) F[i]=mul(F[i-1],i);\n\tI[N-1]=pow(F[N-1],mod-2);\n\tfor(int i=N-2;~i;i--) I[i]=mul(I[i+1],i+1);\n}\nint Binom(int n, int k){ return mul(F[n],mul(I[k],I[n-k]));}\nint Count(int n, int z){ return Binom(n+z-1,z);}\nint main()\n{\n\tCalc();\n\tint n,m;\n\tscanf(\"%i %i\",&n,&m);\n\tint sum=0;\n\tfor(int odd=0;odd<=min(m,n);odd++) if((odd%2)==(m%2))\n\t{\n\t\tint ways=Binom(n,odd);\n\t\tint ans=mul(ways,Count(n,(3*m-odd)/2)),tmp;\n\t\t//printf(\"%i \",ans);\n\t\ttmp=mul(ways,mul(n,Count(n,(m-odd)/2)));\n\t\tans-=tmp;\n\t\tif(ans<0) ans+=mod;\n\t\t//printf(\"%i \",tmp);\n\t\ttmp=mul(mul(n,Binom(n-1,odd)),Count(n-1,(m-odd)/2));\n\t\tans=add(ans,tmp);\n\t\t//printf(\"%i \",tmp);\n\t\t//printf(\"odd:%i ans:%i\\n\",odd,ans);\n\t\tsum=add(sum,ans);\n\t}\n\tprintf(\"%i\\n\",sum);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n#define REP(i,n) for(int i = 0;i < n;i++)\n\n/*\n * Modint struct\n * library author : @snuke\n * */\nconst int mod = 998244353;\nstruct mint {\n\tlong long x; // typedef long long ll;\n\tmint(long long x = 0): x((x % mod + mod) % mod) {}\n\tmint& operator+=(const mint a) { if ((x += a.x) >= mod)x -= mod; return *this;}\n\tmint& operator-=(const mint a) { if ((x += mod - a.x) >= mod)x -= mod; return *this;}\n\tmint& operator*=(const mint a) { (x *= a.x) %= mod; return *this;}\n\tmint operator+(const mint a) const { mint res(*this); return res += a;}\n\tmint operator-(const mint a) const { mint res(*this); return res -= a;}\n\tmint operator*(const mint a) const { mint res(*this); return res *= a;}\n\tmint pow(ll t) const {\n\t\tif (!t) return 1; mint a = pow(t >> 1); a *= a;\n\t\tif (t & 1) a *= *this; return a;\n\t}\n\t// for prime mod\n\tmint inv() const { return pow(mod - 2);}\n\tmint& operator/=(const mint a) { return (*this) *= a.inv();}\n};\nistream& operator>>(istream& is, const mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\nstruct Combination {\n\tconst int MAX = 2000050;\n\tvector<mint> fact;\n\tvector<mint> finv;\n\tCombination(): fact(MAX), finv(MAX) {\n\t\tfor (int i = 0; i < MAX; i++) {\n\t\t\tif (i == 0)fact[i] = (mint)1;\n\t\t\telse fact[i] = fact[i - 1] * (mint)i;\n\t\t}\n\t\tfinv[MAX - 1] = fact[MAX - 1].inv();\n\t\tfor (int i = MAX - 2; i >= 0; i--) {\n\t\t\tfinv[i] = finv[i + 1] * (mint)(i + 1);\n\t\t}\n\t}\n\tmint comb(int n, int r) {\n\t\tif (n < 0 || r < 0 || n < r)return 0;\n\t\telse return fact[n] * finv[r] * finv[n - r];\n\t}\n} C;\n\nll n, m;\n\nint main(void) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> n >> m;\n\tmint ans = 0;\n\n\tfor (int k = 0; k <= m; k++) {\n\t\tif ((3 * m - k) % 2 != 0)continue;\n\t\tans += C.comb(n, k) * (C.comb((3 * m - k) / 2 + n - 1, n - 1)\n\t\t       - (mint)k * C.comb((m - k) / 2 + n - 1, n - 1)\n\t\t       - (mint)(n - k) * C.comb((m - 2 - k) / 2 + n - 1, n - 1));\n\t}\n\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\nusing ll = long long;\n\n// Fermat の小定理を用いた F_mod 上での逆元計算x^(mod-2), 蟻本p115\nll Inverse(ll x){\n    ll res = 1;\n    int n = mod - 2;\n    while(n > 0){\n        if(n & 1){\n            res = res * x % mod;\n        }\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    /*\n     * 全部の組み合わせから不可能なものを引く\n     * 不可能なのは\n     * 1. ある値が2Mより大きい\n     * 2. 値が奇数のものがM個より多い\n     * のどちらか, これらは背反(和は3Mより)\n     * 奇数に1を1回, 最大の数から2を割り振れば構成できる\n     */\n\n    // 階乗計算, iの階乗 = fact[i}\n    vector<ll>fact(3 * M + N);\n    fact[0]=1;\n    for(int i=1; i < 3 * M + N + 1; i++){\n        fact[i] = fact[i-1] * i % mod;\n    }\n\n    ll ans = fact[3*M+N-1] * Inverse(fact[N-1] * fact[3*M] % mod);\n    ans %= mod;\n\n\n    // ある値が2Mより大きい場合, 他の値の合計で回す\n    ll over = 0;\n    for (int i = 0; i < M; ++i) {\n        over = over + fact[i+N-2] * Inverse(fact[N-2] * fact[i] % mod);\n        over %= mod;\n    }\n    over = over * (N-1);\n    over %= mod;\n    ans = ans + mod - over;\n    ans %= mod;\n\n\n    // 値が奇数のものがM個より多い場合, 奇数の個数で回す\n    ll many = 0;\n    for (int i = M+1; i < N+1; ++i) {\n        if((3 * M - i) % 2 == 1) continue;\n        ll temp = 0;\n        int ans = (3 * M - i) / 2;\n        temp = temp + fact[ans+N-1] * Inverse(fact[N-1] * fact[ans] % mod);\n        temp %= mod;\n        temp = temp * fact[N];\n        temp %= mod;\n        temp = temp * Inverse(fact[i] * fact[N-i] % mod);\n        temp %= mod;\n        many += temp;\n        many %= mod;\n    }\n    ans = ans + mod - many;\n    ans %= mod;\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define ll long long\n\n#define N 1000005\nint P[N];\nint PI[N];\n#define MOD 998244353\n\nll modInverse(ll a,ll m)\n    {\n        ll m0 = m;\n        ll y = 0, x = 1;\n         if(m == 1)\n            return 0;\n        while (a > 1)\n            {\n                int q = a / m;\n                int t = m;\n                m = a % m, a = t;\n                t = y;\n                y = x - q * y;\n                x = t;\n            }\n        if (x < 0)\n            x += m0;\n        return x;\n    }\n\nvoid fun()\n     {\n         P[0]=1;\n        int i;\n         for(i=1;i<N;i++)\n         {\n            P[i]=(P[i-1]*i)%MOD;\n         }\n         for(i=0;i<N;i++)\n         {\n            PI[i]=modInverse(P[i],MOD);\n         }\n     }\n\nint ncr(int n, int r)\n{\n        int ans = P[n];\n        ans*=PI[r];\n        ans%=MOD;\n        ans*=PI[n-r];\n        ans%=MOD;\n        return ans;\n}\n\nint distribute(int x,int n)\n{\n        int ans = ncr(n+x-1,n-1);\n        return ans;\n}\n\nint dp[N];\n\nint32_t main()\n{\n        ios_base::sync_with_stdio(false);\n\n        fun();\n        \n\n        int n, m;\n        cin>>n>>m;\n        \n        int ans = 0;\n        for(int i=0;i<=min(n,m);i++)\n        {\n                int left = m-i;\n                if(left%2)\n                        continue;\n                int temp = m + left/2;\n                int dis = distribute(temp, n);\n                ans+=dis*ncr(n,i);\n                ans%=MOD;\n        }\n\n        for(int i=2*m+1;i<=3*m;i++)\n        {\n                int temp = 3*m - i;\n                temp = distribute(temp, n-1);\n                ans-=temp*n;\n                ans%=MOD;\n                if(ans<0)\n                        ans+=MOD;\n        }\n        cout<<ans<<endl;\n\n\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1e9+7;\nll pow(ll x,ll y){\n  if(y==0) return 1;\n  ll res=pow(x,y/2);\n  res*=res;\n  res%=mod;\n  if(y%2==1) res*=x;\n  return res%mod;\n}\nll gyaku(ll x){\n  return pow(x,mod-2);\n}\nvector<ll> frac,gfrac;\nvoid set_frac(ll n){\n  frac.push_back(1);\n  gfrac.push_back(1);\n  for(ll i=1;i<=n;i++){\n    frac.push_back(frac[i-1]*i%mod);\n    gfrac.push_back(gyaku(frac[i]));\n  }\n}\nll nCr(ll n,ll r){\n  ll res=frac[n]*gfrac[r]%mod;\n  res*=gfrac[n-r];\n  return res%mod;\n}\n\n\n\nint main(){\n  ll n,m;\n  cin>>n>>m;\n  ll ans=0;\n  set_frac(5*max(n,m)+30);\n\n  vector<ll> vec,rsum;\n  for(ll i=0;i<3*m+100;i++) vec.push_back(nCr(n+i-2,n-2));\n  rsum.push_back(vec[0]);\n  for(ll i=1;i<3*m+100;i++) rsum.push_back((rsum[i-1]+vec[i])%mod);\n  for(ll t=0;t<=min(n,m);t++){\n    ll kans1=0,kans2=0;\n    if((m-t)%2==0){\n      if(t<n){\n        kans1=(nCr(((m-t)/2)+n-2,n-2)*n)%mod;\n        kans1*=nCr(n-1,t);\n        kans1%=mod;\n      }\n\n      kans2+=nCr(((3*m-t)/2)+n-1,n-1);\n      kans2%=mod;\n\n      kans2-=(n*rsum[((3*m-t)/2)-m])%mod;\n      kans2+=mod;\n      kans2%=mod;\n\n      kans2*=nCr(n,t);\n      kans2%=mod;\n    }\n    ans+=(kans1+kans2)%mod;\n    ans%=mod;\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*input\n10 10\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb emplace_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\n#define version 20190713\n//}}}\nconst ll maxn=4000005;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=8000000000000000000LL;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=998244353;\nconst ld PI=acos(-1);\nconst ld eps=1e-9;\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\t\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\ninline ll inv(ll n){\n\treturn mypow(n,MOD-2);\n}\n\nll fac[maxn];\nll in[maxn];\ninline ll f(ll n,ll m){\n\treturn fac[n+m-1]*in[n]%MOD*in[m-1]%MOD;\n}\n\n\nint main(){\n\tIOS;\n\tll n,m;\n\tcin>>n>>m;\n\n\tfac[0]=1;\n\tin[0]=1;\n\tfor(int i=1;i<maxn;i++) fac[i]=fac[i-1]*i%MOD,in[i]=inv(fac[i]);\n\n\tll ans=f(3*m,n);\n\tfor(int i=0;i<m;i++){\n\t\tans-=n*f(i,n-1)%MOD;\n\t\t// cout<<i<<' '<<n-1<<' '<<f(i,n-1)<<'\\n';\n\t\t// cout<<ans<<'\\n';\n\t\tif(ans<0) ans+=MOD;\n\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nll modinv(ll a, ll m) {\n\tassert(m > 0);\n\tif (m == 1) return 0;\n\ta %= m;\n\tif (a < 0) a += m;\n\tassert(a != 0);\n\tif (a == 1) return 1;\n\treturn m - modinv(m, a) * m / a;\n}\n\ntemplate <int MOD_> struct modnum {\nprivate:\n\tint v;\npublic:\n\tstatic const int MOD = MOD_;\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int () const { return v; }\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum operator ~ () const {\n\t\tmodnum res;\n\t\tres.v = modinv(v, MOD);\n\t\treturn res;\n\t}\n\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= (~o);\n\t}\n\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\nusing num = modnum<998244353>;\n\nvector<num> fact = {1};\n\nvoid init(){\n\tfor(int i = 1; i < 5100000; i++){\n\t\tfact.push_back(fact[i-1] * i);\n\t}\t\n}\n\nnum ncr(int a, int b){\n\tif(b > a || b < 0) return 0;\n\treturn fact[a] / fact[a-b] / fact[b];\n}\n\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tinit();\n\tint n, m;\n\tcin >> n >> m;\n\tnum ans = 0;\n\tans += ncr(3*m + n-1, n-1);\n\tans -= ncr(m-1 + n-1, n-1) * n;\n\tfor(int odd = m+2; odd <= n; odd += 2){\n\t\tans -= ncr(n, odd) * ncr((3*m-odd)/2 + n-1, n-1);\n\t}\n\tcout << (int)ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\tfor (; ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') f = -1;\n\tfor (; ch >= '0' && ch <= '9'; ch = getchar()) x = (x << 1) + (x << 3) + ch - '0';\n\treturn x * f;\n}\n\nconst int N = 3e6 + 5;\nconst int P = 998244353;\nint fac[N], ifac[N];\n\nint Pow(int x, int t)\n{\n\tint res = 1;\n\tfor (; t; t >>= 1, x = 1LL * x * x % P)\n\t\tif (t & 1) res = 1LL * res * x % P;\n\treturn res;\n}\n\nint C(int n, int m)\n{\n\tif (n < m || m < 0) return 0;\n\treturn 1LL * fac[n] * ifac[m] % P * ifac[n - m] % P;\n}\n\nint solve(int n, int m, int k)\n{\n\tint res = 0;\n\tfor (int i = m & 1; i <= k; i += 2)\n\t\tres = (res + 1LL * C(n, i) * C((m - i) / 2 + n - 1, n - 1) % P) % P;\n\treturn res;\n}\n\nint main()\n{\n\tint n = read();\n\tint m = read();\n\t\n\tfac[0] = 1;\n\tfor (int i = 1; i < N; ++i) fac[i] = 1LL * i * fac[i - 1] % P;\n\tifac[N - 1] = Pow(fac[N - 1], P - 2);\n\tfor (int i = N - 1; i >= 1; --i) ifac[i - 1] = 1LL * i * ifac[i] % P;\n\t\n\tint ans = solve(n, 3 * m, m);\n\tans = (ans - 1LL * n * (solve(n, m, m) - solve(n - 1, m, m)) % P + P) % P;\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\nusing namespace std;\n\nconst ll MAX = 3500100, MOD = 998244353;\nll fac[MAX], finv[MAX], inv[MAX];\n// 前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n// 二項係数の計算\nll COM(int n, int k){\n    if (n < 0 || k < 0 || n < k) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nint main(){\n    int n, m; cin >> n >> m;\n    COMinit();\n    ll ans = 0;\n    if(m%2 == 0){\n        for(int i = 0; i <= m; i += 2){\n            ans += COM((3*m-i)/2 + n-1, n-1) * COM(n, i) % MOD; // 奇数がi個\n            ans -= COM((m-2-i)/2 + n-1, n-1) * COM(n, i) % MOD * n % MOD; // 2n+2以上\n            ans -= COM((m-i)/2 + n-2, n-2) * COM(n-1, i-1) % MOD * n % MOD; // 2n+1\n            ans += MOD;\n            ans %= MOD;\n        }\n    }\n    if(m%2 == 1){\n        for(int i = 1; i <= m; i += 2){\n            ans += COM((3*m-i)/2 + n-1, n-1) * COM(n, i) % MOD; // 奇数がi個\n            ans -= COM((m-2-i)/2 + n-1, n-1) * COM(n, i) % MOD * n % MOD; // 2n+2以上\n            ans -= COM((m-i)/2 + n-2, n-2) * COM(n-1, i-1) % MOD * n % MOD; // 2n+1\n            ans += MOD;\n            ans %= MOD;\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <time.h>\n#include <complex>\n \nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n \nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\nusing std::complex;\nusing std::priority_queue;\n \nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\ntypedef complex<double> cd;\n \nll min(ll a, ll b)\n{\n    if (a < b)\n        return a;\n    return b;\n}\n \nll max(ll a, ll b)\n{\n    if (a > b)\n        return a;\n    return b;\n}\n \n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n#define int long long\n \nnamespace MySpace{\n    struct Small_Segment_Tree{\n        vector<int> a;\n        int l, r;\n \n        private:\n        int __summ(int L, int R, int l, int r, int v)\n        {\n            if (L <= l && r <= R)\n                return a[v];\n            if (R <= l || r <= L)\n                return 0;\n            int m = (l + r) / 2;\n            return __summ(L, R, l, m, 2 * v + 1) + __summ(L, R, m, r, 2 * v + 2);\n        }\n \n        void __set(int P, int l, int r, int v, int V)\n        {\n            if (l + 1 == r)\n            {\n                a[v] = V;\n                return;\n            }\n            int m = (l + r) / 2;\n            if (P < m)\n            {\n                __set(P, l, m, 2 * v + 1, V);\n                a[v] = a[2 * v + 1] + a[2 * v + 2];\n            }\n            else\n            {\n                __set(P, m, r, 2 * v + 2, V);\n                a[v] = a[2 * v + 1] + a[2 * v + 2];\n            }\n        }\n \n        public:\n        int Summ(int L, int R)\n        {\n            if (R < L)\n                return 0;\n            return __summ(L, R + 1, l, r, 0);\n        }\n \n        void Set(int P, int V)\n        {\n            __set(P, l, r, 0, V);\n        }\n \n        Small_Segment_Tree(int _n)\n        {\n            a.resize(4 * _n);\n            l = 0, r = _n;\n        }\n    };\n    long long inq(long long x, long long q, long long MOD)\n    {\n        if (q == 0)\n            return 1;\n        long long l = inq(x, q / 2, MOD);\n        if (q % 2)\n            return l * l % MOD * x % MOD;\n        return l * l % MOD;\n    }\n};\n \n \nusing namespace MySpace;\n \nstruct kewa1{\n    vector<pii> a;\n    void insert(int x)\n    {\n        if (a.size() == 0)\n            a.push_back({x, x});\n        else\n            a.push_back({x, std::min(x, 1LL * a[a.size() - 1].second)});\n    }\n    int min()\n    {\n        if (a.size() == 0)\n            return 1e9;\n        else\n            return a[a.size() - 1].second;\n    }\n    void erase()\n    {\n        if (a.size()) a.pop_back();\n    }\n    void pri()\n    {\n        for (int i = 0; i < a.size(); i++)\n        {\n            cout << a[i].first << \" \";\n        }\n        cout << endl;\n    }\n};\n \nstruct kewa2{\n    kewa1 a, b;\n    void insert(int x)\n    {\n        b.insert(x);\n    }\n    void erase()\n    {\n        if (a.a.size() == 0)\n        {\n            while (b.a.size())\n            {\n                a.insert(b.a[b.a.size() - 1].first);\n                b.erase();\n            }\n            //reverse(all(a.a));\n        }\n        a.erase();\n    }\n    int min()\n    {\n        return std::min(a.min(), b.min());\n    }\n    void pri()\n    {\n        cout << \"a : \";\n        a.pri();\n        cout << \"b : \";\n        b.pri();\n        cout << endl;\n    }\n};\n \nvoid YN(int val)\n{\n    if (val >= 1)\n    {\n        printf(\"YES\\n\");\n    }\n    else\n    {\n        printf(\"NO\\n\");\n    }\n}\n \nconst ll MOD = 998244353;\n//const ll MOD = 1e9 + 7;\n \nll n, k;\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n \n    //#slow\n    cin >> n >> k;\n    if (k == 1)\n    {\n        cout << n * (n - 1) % MOD << endl;\n        return 0;\n    }\n    if (k == 2)\n    {\n        ll ans2 = (n * (n - 1) / 2 % MOD) * ((n - 2) * (n - 3) / 2 % MOD) % MOD + n * (n - 1) * (n - 2) / 6;\n        ans2 %= MOD;\n        ll ans3 = (n * (n - 1) / 2) + (n * (n - 1) * (n - 2)) % MOD;\n        ll ans4 = (n * (n - 1)) + (n * (n - 1) * (n - 2) / 2);\n        cout << (ans2 + ans3 + ans4) % MOD;\n        return 0;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\n#include<cstdio>\n#include<cstring>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\ntypedef vector<char> vc;\ntypedef string S;\ntypedef queue<int> qi;\ntypedef pair<ll,ll> P;\ntypedef vector<P> vp;\n//#define sort(a) sort(a.begin(),a.end())\n#define reverse(a) reverse(a.begin(),a.end())\n#define pb push_back\n#define elif else if\n#define unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mp make_pair\n#define fr(i,n)for(ll i=0;i<(n);i++)\n#define ifr(i,n)for(ll i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\nconst int MAX = 510000;\nconst int MOD = 998244353;\n\nll fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nll COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nint main() {\n    // 前処理\n    COMinit();\n    ll n,m;cin>>n>>m;\n    ll ans = COM(3*m+n-1,n-1);\n    fr(i,m){\n        ans -= COM(n-2+i,n-2)*n;\n        if (ans < 0){\n            while(ans < 0)ans +=MOD;\n        }\n    }\n    for(ll i = m+1;i<=min(3*m,n);i++){\n        if((3*m-i)%2==0){\n            ans -= COM(n,i)*COM((3*m-i)/2 + n -1,n-1);\n            if (ans < 0){\n                while(ans < 0)ans +=MOD;\n            }\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 3e6 + 6, mod = 998244353;\n\nlong long powmod(long long b, long long p) {\n  long long r = 1;\n  for (; p; p >>= 1, b = b * b % mod)\n    if (p & 1)\n      r = r * b % mod;\n  return r;\n}\n\nint fact[N], inv[N];\n\nlong long C(int n, int k) {\n  if (n < 0 || k < 0 || n < k)\n    return 0;\n  return (1LL * fact[n] * inv[k] % mod) * inv[n-k] % mod;\n}\n\nint main() {\n  fact[0] = inv[0] = 1;\n  for (int i = 1; i < N; ++i) {\n    fact[i] = 1LL * i * fact[i-1] % mod;\n  }\n  inv[N-1] = powmod(fact[N-1], mod-2);\n  for (int i = N-2; i > 0; --i) {\n    inv[i] = 1LL * (i+1) * inv[i+1] % mod;\n  }\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  long long ans = C(m * 3 + n-1, n-1);\n  for (int i = 2 * m + 1; i <= 3 * m; ++i) {\n    int sisa = 3 * m - i;\n    long long cur = 1LL * C(sisa + n-2, n-2) * n % mod;\n    ans = (ans - cur) % mod;\n  }\n  for (int i = m+1; i <= n; ++i) {\n    int sisa = 3 * m - i;\n    if (sisa & 1) continue;\n    sisa /= 2;\n    long long cur = 1LL * C(n, i) * C(sisa + n-1, n-1) % mod;\n    ans = (ans - cur) % mod;\n  }\n  if (ans < 0)\n    ans += mod;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 998244353\n#define int long long\nusing namespace std;\nconst int N=3*1e6+100;\nint n,m,fac[N],inv[N],a,b;\ninline int m_pow(int a,int b)\n{\n\tint ans=1;\n\twhile (b)\n\t{\n\t\tif (b&1) ans=(ans*a)%mod;\n\t\tb>>=1;\n\t\ta=(a*a)%mod; \n\t}\n\treturn ans;\n}\ninline int c(int n,int m)\n{\n\tif (m>n) return 0;\n\treturn (fac[n]*(inv[m]*inv[n-m]%mod)%mod)%mod;\n}\nsigned main()\n{\n\tscanf(\"%lld%lld\",&n,&m);\n\tfac[0]=1;\n\tfor (int i=1;i<=n+3*m;i++) fac[i]=(fac[i-1]*i)%mod;\n\tinv[n+3*m]=m_pow(fac[n+3*m],mod-2);\n\tfor (int i=n+3*m-1;i>=0;i--) inv[i]=(inv[i+1]*(i+1))%mod;\n\tfor (int i=0;i<=m;i++)\n\t{\n\t\tif ((3*m-i)%2!=0) continue;\n\t\ta=(a+(c(n,i)*c(n+(3*m-i)/2-1,n-1))%mod)%mod;\n\t}\n\tfor (int i=2*m+1;i<=3*m;i++) b=(b+c(n+3*m-i-2,n-2))%mod;\n\tb=(b*n)%mod;\n\tprintf(\"%lld\\n\",(a-b+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <type_traits>\n#include <tuple>\n\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(std::min<int>(l_, r_)), r(r_) {}\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr r, l;\n  constexpr revrange(int l_, int r_): r(std::max<int>(l_, r_) - 1), l(l_ - 1) {}\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\ntemplate <class T>\ninline T scan() {\n  T res;\n  std::cin >> res;\n  return res;\n}\n\ntemplate <class T>\nclass modulo_int {\npublic:\n  static constexpr int mod = T::value;\n  static_assert(mod > 0, \"mod must be positive\");\nprivate:\n  long long value;\n  constexpr void normalize() {\n    value %= mod;\n    if (value < 0) value += mod;\n  }\npublic:\n  constexpr modulo_int(long long value_ = 0): value(value_) { normalize(); }\n  constexpr modulo_int operator - () const { return modulo_int(mod - value); }\n  constexpr modulo_int operator ~ () const { return power(mod - 2); }\n  constexpr long long operator () () const { return value; }\n  constexpr modulo_int operator + (const modulo_int& rhs) const { return modulo_int(*this) += rhs; }\n  constexpr modulo_int& operator += (const modulo_int& rhs) {\n    if ((value += rhs.value) >= mod) value -= mod;\n    return (*this);\n  }\n  constexpr modulo_int operator - (const modulo_int& rhs) const { return modulo_int(*this) -= rhs; }\n  constexpr modulo_int& operator -= (const modulo_int& rhs) {\n    if ((value += mod - rhs.value) >= mod) value -= mod;\n    return (*this);\n  }\n  constexpr modulo_int operator * (const modulo_int& rhs) const { return modulo_int(*this) *= rhs; }\n  constexpr modulo_int& operator *= (const modulo_int& rhs) {\n    (value *= rhs.value) %= mod;\n    return (*this);\n  }\n  constexpr modulo_int operator / (const modulo_int& rhs) const { return modulo_int(*this) /= rhs; }\n  constexpr modulo_int& operator /= (const modulo_int& rhs) {\n    return (*this) *= ~rhs;\n  }\n  constexpr modulo_int power (unsigned long long pow) const {\n    modulo_int result(1), mult(*this);\n    while (pow > 0) {\n      if (pow & 1) result *= mult;\n      mult *= mult;\n      pow >>= 1;\n    }\n    return result;\n  }\n  friend std::istream& operator >> (std::istream& stream, modulo_int& lhs) {\n    stream >> lhs.value;\n    lhs.normalize();\n    return stream;\n  }\n  friend std::ostream& operator << (std::ostream& stream, const modulo_int& rhs) {\n    return stream << rhs.value;\n  }\n};\n\ntemplate <class T>\nclass factorials {\npublic:\n  using value_type = T;\n\npublic:\n  std::vector<value_type> fact, fact_inv;\n\n  factorials(int size_ = 200000): fact(size_ + 1), fact_inv(size_ + 1) {\n    fact[0] = 1;\n    for (int i = 1; i <= size_; ++i) {\n      fact[i] = fact[i - 1] * value_type(i);\n    }\n    fact_inv[size_] = ~fact[size_];\n    for (int i = size_; i > 0; --i) {\n      fact_inv[i - 1] = fact_inv[i] * value_type(i);\n    }\n  }\n\n  value_type operator () (int n, int r) const {\n    return fact[n] * fact_inv[n - r] * fact_inv[r];\n  }\n\n};\n\nusing modint = modulo_int<std::integral_constant<int, 998244353>>;\nfactorials<modint> fact(2500000);\n\nmodint calc(int sum, int to) {\n  return fact(sum + to - 1, to - 1);\n}\n\nint main() {\n  // 合計 3M, 最大のものが 2M 以下, 1 の個数が M 以下\n  int N, M;\n  std::cin >> N >> M;\n  modint ans = calc(3 * M, N);\n  // 合計 3M かつ 最大のものが 2M より大きい\n  for (int k: range(2 * M + 1, 3 * M + 1)) {\n    ans -= calc(3 * M - k, N - 1) * modint(N);\n  }\n  // 合計 3M かつ 1 の個数が M より大きい\n  for (int k: range(M + 1, N)) {\n    int remain = 3 * M + k - 2 * N;\n    if (remain < 0) {\n      continue;\n    }\n    ans -= calc(remain, N - k) * fact(N, k);\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 998244353;\n\nconst int MAXN = 2e6 + 5;\n\nll pow_mod(ll a, ll st) {\n\tll ans = 1ll;\n\tfor(; st; st >>= 1ll) {\n\t\tif (st & 1) {\n\t\t\tans = (ans * a) % MOD;\n\t\t}\n\t\ta = (a * a) % MOD;\n\t}\n\treturn ans;\n}\n\nll f[MAXN], f_inv[MAXN];\n\nll get_c(int i, int j) {\n\tif (j < 0 || j > i) {\n\t\treturn 0ll;\n\t}\n\tll ans = (f[i] * f_inv[j]) % MOD;\n\treturn (ans * f_inv[i - j]) % MOD;\n}\n\nll get_c_rep(int i, int j) {\n\treturn get_c(i + j - 1, j);\n}\n\nvoid solve(){\n\tf[0] = 1ll;\n\tREP(i, 1, MAXN) {\n\t\tf[i] = (f[i - 1] * i) % MOD;\n\t}\n\tf_inv[MAXN - 1] = pow_mod(f[MAXN - 1], MOD - 2);\n\tfor(int i = MAXN - 2; i >= 0; i--) {\n\t\tf_inv[i] = (f_inv[i + 1] * (i + 1)) % MOD;\n\t}\n\t\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tll ans = (n * get_c(m + n - 2, m)) % MOD;\n\t\n\t//cout << ans << endl;\n\t\n\tfor(int i = m % 2; i <= min(m, n); i += 2) {\n\t\tll tmp = get_c(n, i);\n\t\tint cnt2 = m + (m - i) / 2;\n\t\tll tmp1 = get_c(n + cnt2 - 1, cnt2);\n\t\tll tmp2 = get_c(n + cnt2 - m - 1, cnt2 - m);\n\t\tll tmp3 = (n * tmp2) % MOD;\n\t\tll tmp4 = (tmp1 - tmp3 + MOD) % MOD;\n\t\tll tmp5 = (tmp * tmp4) % MOD;\n\t\t\n\t\t//cout << tmp1 << \" \" << tmp2 << \" \" << tmp3 << \" \" << tmp4 << \" \" << tmp5 << endl;\n\t\t\n\t\tans = (ans + tmp5) % MOD;\n\t}\n\tcout << ans << endl;\n}\n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nlong long fact[C_SIZE];\nlong long finv[C_SIZE];\nlong long inv[C_SIZE];\nlong long Comb(int a,int b){\n \tif(a<b||b<0)return 0;\n \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n}\nvoid init_C(int n){\n\tfact[0]=finv[0]=inv[1]=1;\n\tfor(int i=2;i<n;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n}\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\ndouble ABS(double a){return max(a,-a);}\n// ここから編集しろ\n\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tinit_C(3100000);\n\tlong long ret=0;\n\tfor(int i=b;i<=3*b/2;i++){\n\t\tint A=i;\n\t\tint B=3*b-i*2;\n\t\tint C=a-1-B;\n\t//\tprintf(\"%d %d %d\\n\",A,B,C);\n\t\tif(B<0||C<0)continue;\n\t\tret=(ret+Comb(A+B+C,A+B)*Comb(A+B,A))%mod;\n\n\t}\n\tfor(int i=b;i<=(3*b-1)/2;i++){\n\t\tint A=i;\n\t\tint B=3*b-1-i*2;\n\t\tint C=a-1-B;\n\t//\tprintf(\"%d %d %d\\n\",A,B,C);\n\t\tif(B<0||C<0)continue;\n\t\tret=(ret+Comb(A+B+C,A+B)*Comb(A+B,A))%mod;\n\t}\n\tret=(ret+mod-a*Comb(b-1+a-1,a-1)%mod)%mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define rrep(i,a,b) for(int i=(a);i>=(b);--i)\n#define MP make_pair\n#define PB push_back\ntypedef long long LL;\nconst LL MOD = 998244353;\nconst int N = 2.5e6+10;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint n,m;\nLL fac[N],ifac[N];\n\nLL pw(LL x,int n){\n\tLL res = 1;\n\tfor(;n;n>>=1,x=x*x%MOD)if(n&1)res=res*x%MOD;\n\treturn res;\n}\n\nLL C(int n,int x){\n\treturn fac[n] * ifac[x] % MOD * ifac[n-x] % MOD;\n}\n\nint main(){\n\t//freopen(\"test.in\",\"r\",stdin);\n\tcin>>n>>m;\n\tfac[0] = 1;\n\trep(i,1,N-1)fac[i]=fac[i-1]*i%MOD;\n\tifac[N-1] = pw(fac[N-1],MOD-2);\n\trrep(i,N-2,0)ifac[i]=ifac[i+1]*(i+1)%MOD;\n\t//cout<<fac[1]*ifac[1]%MOD<<\" \"<<fac[2]*ifac[2]%MOD<<\" \"<<fac[3]*ifac[3]%MOD<<endl;\n\tint s = 3*m;\n\tLL num = C(s+n-1,n-1);\n\tLL sub1 = n * C(n+m-2, n-1) % MOD, sub2 = 0;\n\tfor(int i=m+2;i<=min(3*m,n);i+=2){\n\t\tint s1 = (s-i)/2;\n\t\tsub2 = (sub2 + C(n, i) * C(s1+n-1, n-1)) % MOD;\n\t}\n\tcout<<(num - sub1 - sub2 + MOD * 2) % MOD<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n////////////\n// ModInt //\n////////////\n\n// 四則演算の最も左に存在する値がModIntでなければキャストでバグる\n// 例えばx = mint * 1000;やx = ModInt(1000) * mint;はいいがx = 1000 * mint;は駄目。\ntemplate<int64_t mod_ = 1'000'000'007>\nclass ModInt {\nprivate:\n\tint64_t integer_;\n\npublic:\n\tconstexpr ModInt(const int64_t initial_number = 0)\n\t\t: integer_(initial_number){}\n\t\n\t// 四則演算\n\tconstexpr ModInt operator+(const ModInt& operand) const\n\t{\n\t\tModInt ret{this->integer_ + operand.integer_};\n\t\tif (ret.integer_ >= mod_)\n\t\t\tret.integer_ -= mod_;\n\t\treturn ret;\n\t}\n\tconstexpr ModInt operator-(const ModInt& operand) const\n\t{\n\t\tModInt ret{this->integer_ - operand.integer_};\n\t\tif (ret.integer_ < 0)\n\t\t\tret.integer_ += mod_;\n\t\treturn ret;\n\t}\n\tconstexpr ModInt operator*(const ModInt& operand) const\n\t{\n\t\treturn {this->integer_ * operand.integer_ % mod_};\n\t}\n\tconstexpr ModInt operator/(const ModInt& operand) const\n\t{\n\t\treturn *this * (operand ^ (mod_ - 2));\n\t}\n\n\t// 累乗\n\tconstexpr ModInt operator^(const int64_t operand) const\n\t{\n\t\tModInt ret{1}, pow_ope{this->integer_};\n\t\tfor (int64_t pow{operand}; pow > 0; pow >>= 1)\n\t\t{\n\t\t\tif (pow & 1) ret *= pow_ope;\n\t\t\tpow_ope *= pow_ope;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t// 代入\n\tconstexpr ModInt& operator=(const ModInt& operand)\n\t{\n\t\tthis->integer_ = operand.integer_;\n\t\treturn *this;\n\t}\n\tconstexpr ModInt& operator+=(const ModInt& operand)\n\t{\n\t\t*this = *this + operand;\n\t\treturn *this;\n\t}\n\tconstexpr ModInt& operator-=(const ModInt& operand)\n\t{\n\t\t*this = *this - operand;\n\t\treturn *this;\n\t}\n\tconstexpr ModInt& operator*=(const ModInt& operand)\n\t{\n\t\t*this = *this * operand;\n\t\treturn *this;\n\t}\n\tconstexpr ModInt& operator/=(const ModInt& operand)\n\t{\n\t\t*this = *this / operand;\n\t\treturn *this;\n\t}\n\n\t// その他\n\tconstexpr operator int64_t() { return integer_; }\n\n\tconstexpr ModInt getOne() const\n\t{\n\t\treturn ModInt(1ll);\n\t}\n\tconstexpr ModInt getZero() const\n\t{\n\t\treturn ModInt(0ll);\n\t}\n};\n\nconstexpr int64_t mod{998'244'353};\nusing Mint = ModInt<mod>;\n\nMint calcCombi(int, int);\nMint calcFact(int);\n\nint main()\n{\n\tint64_t N, M;\n\tscanf(\"%lld%lld\", &N, &M);\n\t// 3*M+N-1 C N-1 - (M+N-1 C N-1 - M+N-2 C N-2) * N\n\tstd::cout << calcCombi(3 * M + N - 1, N - 1) - (calcCombi(M + N - 1, N - 1) - calcCombi(M + N - 2, N - 2)) * Mint(N) << std::endl;\n\n\treturn 0;\n}\n\nMint calcCombi(int n, int r)\n{\n\treturn calcFact(n) / calcFact(r) / calcFact(n - r);\n}\n\nMint calcFact(int n)\n{\n\tMint ret(1ll);\n\tfor (int i{1}; i <= n; i++)\n\t\tret *= Mint(i);\n\treturn ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n\ntypedef long long ll;\n\nconst long MOD = 998244353;\n#define N_MAX 1000002\n\nll inv[N_MAX],fac[N_MAX],finv[N_MAX];\n\nvoid init(){\n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    for(int i=2;i<N_MAX;i++){\n        inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n        fac[i]=fac[i-1]*(ll) i%MOD;\n        finv[i]=finv[i-1]*inv[i]%MOD;\n    }\n}\n\nll inv_(ll n){\n    if(n == 1) return 1;\n    else return MOD-inv_(MOD%n)*(MOD/n)%MOD;\n}\n\nll comb(ll n, ll r){\n  ll ans;\n  if(n < r){\n      ans = 0;\n  }else{\n      ans = (fac[n]*finv[r])%MOD;\n      ans = (ans*finv[n-r])%MOD;\n      ans = (ans+MOD)%MOD;\n  }\n  return ans;\n}\n\nint main(){\n    ll N, M;\n    cin >> N >> M;\n    init();\n    ll ans = 0;\n    for(ll m = 0; m <= M; m++){\n        if((M-m)%2 != 0) continue;\n        ans += (comb(N, m)*comb((3*M-m)/2+N-1, N-1))%MOD;\n        ans %= MOD;\n        ans -= (((comb(N, m)*(N-m))%MOD)*comb((M-m)/2-1+N-1, N-1))%MOD;\n        ans %= MOD;\n        ans += MOD;\n        ans %= MOD;\n        ans -= (((comb(N, m)*m)%MOD)*comb((M-m)/2+N-1, N-1))%MOD;\n        ans %= MOD;\n        ans += MOD;\n        ans %= MOD;\n        //cout << ans << endl;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=1500005,INF=1<<30;\n\nll inv[MAX],fac[MAX],finv[MAX];\n\nvoid make(){\n    \n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    \n    for(int i=2;i<MAX;i++){\n        inv[i]=mod-inv[mod%i]*(mod/i)%mod;\n        fac[i]=fac[i-1]*(ll)i%mod;\n        finv[i]=finv[i-1]*inv[i]%mod;\n    }\n    \n}\n\nll comb(ll a,ll b){\n    if(a<b) return 0;\n    return fac[a]*(finv[b]*finv[a-b]%mod)%mod;\n}\n\nint main(){\n    \n    make();\n    \n    int N,M;cin>>N>>M;\n    \n    ll sum=0;\n    \n    for(int i=M;i>=0;i-=2){\n        if(i>N) continue;\n        ll rem=(3*M-i)/2;\n        sum+=comb(rem+N-1,N-1)*comb(N,i);\n        sum%=mod;\n    }\n    \n    for(int i=M;i>=0;i-=2){\n        if(i>N) continue;\n        ll rem=(M-i)/2;\n        sum+=N*(mod-comb(rem+N-1,N-1))%mod*comb(N,i);\n        sum%=mod;\n    }\n    \n    for(int i=M;i>=0;i-=2){\n        if(i>N) continue;\n        ll rem=(M-i)/2;\n        sum+=N*(comb(rem+N-2,N-2))%mod*comb(N-1,i);\n        sum%=mod;\n    }\n    \n    cout<<sum<<endl;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\nconst ll MN = 1001000;\nconst ll MM = 500500;\nll w[MM*3],x[MM*3],pr[MM*3];\nconst ll M = 998244353;\ninline ll mul(ll a, ll b) {\n\treturn (a*b)%M;\n}\nll bp(ll b, ll p) {\n\tll ac = 1;\n\twhile(p) {\n\t\tif(p&1) {ac = mul(ac,b);}\n\t\tb = mul(b,b);\n\t\tp >>= 1;\n\t}\n\treturn ac;\n}\nll fp[MN],ip[MN];\nll fac(ll v) {\n\tif(v <= 1) return 1;\n\tif(fp[v] != -1) return fp[v];\n\tif(v > 10000) fac(v-10000);\n\treturn fp[v] = mul(fac(v-1),v);\n}\nll inv(ll v) {\n\treturn bp(v,M-2);\n}\nll ifac(ll v) {\n\tif(v <= 1) return 1;\n\tif(ip[v] != -1) return ip[v];\n\treturn ip[v] = inv(fac(v));\n}\nll ch(ll n, ll k) {\n\tif(k < 0 || k > n) return 0;\n\treturn mul(mul(fac(n),ifac(n-k)),ifac(k));\n}\nint main() {\n\tmemset(fp,-1,sizeof(fp));\n\tmemset(ip,-1,sizeof(ip));\n\tll n,m;\n\tcin >> n >> m;\n\tll sm = 0;\n\tfor(int i=0;i<=2*m;i++) {\n\t\tw[i] = ch(n+i-1,n-1);\n\t\tif(i > m) {\n\t\t\tsm += ch(n+i-(m+1)-2,n-2);\n\t\t\tsm %= M;\n\t\t}\n\t\tw[i] -= mul(n,sm);\n\t\tw[i] = (w[i]+M)%M;\n\t}\n\tfor(int i=0;i<=2*m;i++) {\n\t\tx[i] = w[i];\n\t\tif(i >= m) {\n\t\t\tll rem = ch(n+i-m-2,n-2);\n\t\t\tx[i] -= mul(n,rem);\n\t\t}\n\t\tx[i] = (x[i]+M)%M;\n\t}\n\tll res = 0;\n\tfor(int i=0;i<2*m;i++) {\n\t\tll sa = 3*m-2*i;\n\t\tif(sa > m) continue;\n\t\tif(sa < 0) continue;\n\t\tres += mul(ch(n-1,sa),w[i])+mul(ch(n-1,sa-1),x[i]);\n\t\tres %= M;\n\t}\n\tcout << res << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\n#define MOD 998244353ll // prime\n// How to devide :\n// ModInt a(6ll);\n// ModInt b(2ll);\n// a *= b.exp(MOD-2ll);  -> a/=b;  result: a = 3\nstruct ModInt{\n\tll val;\n\tModInt():val(0ll){}\n\tModInt(ll v):val(((v%MOD)+MOD)%MOD){}\n\tModInt exp(ll y)const{\n\t\tif(!y)return ModInt(1ll);\n\t\tModInt a = exp(y/2ll);\n\t\ta *= a;\n\t\tif(y&1)a*=(*this);\n\t\treturn a;\n\t}\n\tbool operator==(const ModInt& x)const{return val==x.val;}\n\tinline bool operator!=(const ModInt& x)const{return !(*this==x);}\n\tbool operator<(const ModInt& x)const{return val<x.val;}\n\tbool operator>(const ModInt& x)const{return val>x.val;}\n\tinline bool operator>=(const ModInt& x)const{return !(*this<x);}\n\tinline bool operator<=(const ModInt& x)const{return !(*this>x);}\n\tModInt& operator+=(const ModInt& x){if((val+=x.val)>=MOD)val-=MOD;return *this;}\n\tModInt& operator-=(const ModInt& x){if((val+=MOD-x.val)>=MOD)val-=MOD;return *this;}\n\tModInt& operator*=(const ModInt& x){(val*=x.val)%=MOD;return *this;}\n\tModInt operator+(const ModInt& x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt& x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt& x)const{return ModInt(*this)*=x;}\n};\nistream& operator>>(istream&i,ModInt&x){i>>x.val;return i;}\nostream& operator<<(ostream&o,const ModInt&x){o<<x.val;return o;}\nModInt pow(ModInt a,ll x){\n\tModInt res = ModInt(1ll);\n\twhile(x){\n\t\tif(x&1)res *= a;\n\t\tx >>= 1;\n\t\ta = a*a;\n\t}\n\treturn res;\n}\nconst int SIZE = 10000100;\nModInt inv[SIZE+10],fac[SIZE+10],facinv[SIZE+10];\n// notice: 0C0 = 1 \nModInt nCr(int n,int r){\n\tassert(!(n<r));\n\tassert(!(n<0||r<0));\n\treturn fac[n]*facinv[r]*facinv[n-r];\n}\nvoid init(){\n\tfac[0]=ModInt(1ll);\n\tfor(int i=1;i<=SIZE;i++)fac[i]=fac[i-1]*ModInt(i);\n\tinv[1]=ModInt(1ll);\n\tfor(int i=2;i<=SIZE;i++)inv[i]=ModInt(0ll)-ModInt(MOD/i)*inv[MOD%i];\n\tfacinv[0]=ModInt(1ll);\n\tfor(int i=1;i<=SIZE;i++)facinv[i]=facinv[i-1]*inv[i];\n\treturn;\n}\nint N,M;\nint main(){\n\tinit();\n\tcin >> N >> M;\n\tModInt ans = nCr(3*M+N-1,N-1);\n\t//cout << ans << endl;\n\tfor(int i=2*M+1;i<=3*M;i++){\n\t\tans -= ModInt(N)*nCr(N-2+3*M-i,3*M-i);\n\t\t//cout << ret << endl;\n\t}\n\tfor(int i=M+1;i<=N;i++){\n\t\tif((3*M-i)%2==0 && 3*M-i>=0){\n\t\t\tans -= nCr(N,i)*nCr(N-1+(3*M-i)/2,N-1);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#include<cassert>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\nconst long long mod = 998244353;\nconst long long inf = 1ll << 61;\ntypedef pair<int, int> P;\n\nint kj[3600005], kji[3600005];\n\nint modpow(int x, int n, int md) {\n\tif (!n)return 1;\n\tint res = modpow(x*x%md, n / 2, md);\n\tif (n & 1)res = res*x%md;\n\treturn res;\n}\nint comb(int n, int r) {\n\tif (n < 0 || r<0 || n < r)return 0;\n\tint ans = kj[n];\n\tans = ans*kji[r] % mod;\n\tans = ans*kji[n - r] % mod;\n\treturn ans%mod;\n}\n\n\nvoid kjinit(int n) {\n\tkj[0] = 1;\n\trep(i, n) {\n\t\tkj[i + 1] = kj[i] * (i + 1);\n\t\tkj[i + 1] %= mod;\n\t}\n\trep(i, n)kji[i] = modpow(kj[i], mod - 2, mod);\n\n}\nsigned main() {\n\tint n, m; cin >> n >> m;\n\tkjinit(3600000);\n\tint ans = comb(3 * m + n - 1, n - 1);\n\tfor (int i = 2 * m + 1; i <= 3 * m; i++) {\n\t\tint t = n*comb(3*m-i+n-2, n - 2);\n\t\tt %= mod;\n\t\tans = ans + mod - t;\n\t}\n\tfor (int i = m + 1; i <= 3 * m; i++) {\n\t\tif (i > n)break;\n\t\tint M = 3 * m - i;\n\t\tif (M & 1)continue;\n\t\tint t = comb(n, i)*comb(M/2 + n-1, n - 1);\n\t\tt %= mod;\n\t\tans = ans + mod - t;\n\t}\n\t\n\n\tcout << ans%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst ll MOD=998244353;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k){\n        if(k&1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k>>=1;\n    }\n    return ans;\n}\nll inv(ll a){\n\treturn powmod(a, MOD-2);\n}\nll f[5000001], invf[5000001];\nvoid fac(int n){\n    f[0]=1;\n    for(ll i=1; i<=n; i++) f[i]=f[i-1]*i%MOD;\n    invf[n]=inv(f[n]);\n    for(ll i=n-1; i>=0; i--) invf[i]=invf[i+1]*(i+1)%MOD;\n}\nll comb(int x, int y){\n    if(!(0<=y && y<=x)) return 0;\n    return f[x]*invf[y]%MOD*invf[x-y]%MOD;\n}\nint main()\n{\n    int n, m; cin>>n>>m;\n    fac(3*m+n);\n    ll ans=0;\n    for(int i=0; i<=m; i++){\n        if((m-i)%2!=0) continue;\n        int l=(3*m-i)/2;\n        (ans+=comb(n, i)*comb(l+n-1, n-1))%=MOD;\n        (ans+=MOD-i*comb(n, i)%MOD*comb(l-m+n-1, n-1)%MOD)%=MOD;\n        (ans+=MOD-(n-i)*comb(n, i)%MOD*comb(l-m-1+n-1, n-1)%MOD)%=MOD;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nЗАПУСКАЕМ\n░ГУСЯ░▄▀▀▀▄░РАБОТЯГУ░░\n▄███▀░◐░░░▌░░░░░░░\n░░░░▌░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▌░░░░░▐▄▄░░░░░\n░░░░▌░░░░▄▀▒▒▀▀▀▀▄\n░░░▐░░░░▐▒▒▒▒▒▒▒▒▀▀▄\n░░░▐░░░░▐▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░▀▄░░░░▀▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░░░▀▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▀▄\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░▄▄▌▌▄▌▌░░░░░\n */\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <random>\n\nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left224\n#define right right224\n#define next next224\n#define rank rank224\n#define prev prev224\n#define y1 y1224\n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define files(FILENAME) read(FILENAME), write(FILENAME)\n#define pb push_back\n#define mp make_pair\nconst string FILENAME = \"input\";\nconst int MAXN = 3000228;\nconst int Mod = 998244353;\n\n\nint mul(int a, int b) {\n    return (1LL * a * b) % Mod;\n}\n\n\nint sum(int a, int b) {\n    return (a + b) % Mod;\n}\n\n\nint powm(int a, int b) {\n    int res = 1;\n    while (b) {\n        if (b & 1) {\n            res = mul(res, a);\n        }\n        b >>= 1;\n        a = mul(a, a);\n    }\n    return res;\n}\n\nint n, m;\nint fact[MAXN];\nint rfact[MAXN];\n\nint getc(int i, int j) {\n    return mul(fact[i], mul(rfact[j], rfact[i - j]));\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    //read(FILENAME);\n    cin >> n >> m;\n    fact[0] = 1;\n    for (int i = 1; i <= 3000000; i++) {\n        fact[i] = mul(fact[i - 1], i);\n    }\n    rfact[3000000] = powm(fact[3000000], Mod - 2);\n    for (int i = 2999999; i >= 0; i--) {\n        rfact[i] = mul(rfact[i + 1], i + 1);\n    }\n   // n + 3 * m, n - 1\n    int ans = getc(n + 3 * m - 1, n - 1);\n    //cout << ans << endl;\n    for (int value = 2 * m + 1; value <= 3 * m; value++) {\n        int f = getc(n + 3 * m - value - 2, n - 2);\n        f = mul(f, n);\n        ans = sum(ans, Mod - f);\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nint powmod(int a, int n, int mod) {\n\tif (n == 0) return 1;\n\tif (n % 2 == 0) return powmod((a * a) % mod, n / 2, mod);\n\treturn (a * powmod(a, n - 1, mod)) % mod;\n}\n\nconst int MAX = 2600000;\nint mod = 998244353;\nint n, m;\nint fact[MAX];\nint factInv[MAX];\n\nvoid initFact() {\n\tint i;\n\t\n\tfact[0] = 1;\n\tfactInv[0] = 1;\n\tfor (i = 1; i <= 3 * m + n; i++) {\n\t\tfact[i] = (i * fact[i - 1]) % mod;\n\t\tfactInv[i] = powmod(fact[i], mod - 2, mod);\n\t}\n}\n\nint comb(int n, int k) {\n\tif (k > n) return 0;\n\treturn fact[n] * factInv[n - k] % mod * factInv[k] % mod;\n}\n\nsigned main() {\n\tcin >> n >> m;\n\tinitFact();\n\t\n\tint x;\n\tint ng = 0;\n\tfor (x = 2 * m + 1; x <= 3 * m; x++) {\n\t\tint res = n * comb(3 * m - x + n - 2, n - 2) % mod;\n\t\tng += res;\n\t\tng %= mod;\n\t}\n\t\n\t//1の個数\n\tfor (x = min((n + 1) / 2, 3 * m); x < n; x++) {\n\t\tint res = comb(n, x) * comb(3 * m - x + n - x - 1, n - x - 1) % mod;\n\t\t//cout << \"x = \" << x << \", \" << res << endl;\n\t\tng += res;\n\t\tng %= mod;\n\t}\n\t\n\tint all = comb(3 * m + n - 1, n - 1);\n\tint ans = (all - ng + mod) % mod;\n\t\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 21.07.2019 15:54:13       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  const int MAX = 2000010;\n  vector<Mint> fact(MAX);\n  fact[0] = 1;\n  for (int i = 1; i < MAX; i++) {\n    fact[i] = fact[i - 1] * i;\n  }\n  auto C = [&](int N, int K) -> Mint {\n    if (K < 0 || K > N) return 0;\n    return fact[N] / fact[K] / fact[N - K];\n  };\n  Mint ans = 0;\n  for (int odd = 0; odd <= m; odd++) {\n    int left = 3 * m - odd;\n    if (left % 2 != 0) {\n      continue;\n    }\n    left /= 2;\n    Mint cur = C(left + n - 1, left);\n    left -= m + 1;\n    if (left >= 0) {\n      cur -= C(left + n - 1, left) * n;\n    }\n    cur *= C(n, odd);\n    if (odd > 0) {\n      left += m + 1;\n      left -= m;\n      if (left >= 0) {\n        Mint new_cur = C(left + n - 2, left) * n;\n        new_cur *= C(n - 1, odd - 1);\n        ans -= new_cur;\n      }\n    }\n    ans += cur;\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int INF=1e9;\n//const int MOD=1e9+7;\nconst int MOD=998244353;\nconst long long LINF=1e18;\nusing namespace std;\n#define int long long\n//template\nstd::vector<int> Factorial(2234567),Finverse(2234567);\nint pw(int n,int k){\n  if(k<0)return pw(n,k+MOD-1);\n  int res=1;\n  while(k){\n    if(k&1)res*=n;res%=MOD;\n    n*=n;n%=MOD;\n    k>>=1;\n  }\n  return res;\n}\nvoid Cinit(){\n  Factorial[0]=1;\n  for(int i=1;i<2234567;i++)Factorial[i]=Factorial[i-1]*i%MOD;\n  for(int i=0;i<2234567;i++)Finverse[i]=pw(Factorial[i],MOD-2);\n}\nint nCk(int n,int k){\n  if(n<k)return 1;if(k<0)return 0;\n  int res=Factorial[n];\n  res*=Finverse[k];res%=MOD;\n  res*=Finverse[n-k];res%=MOD;\n  return res;\n}\n//main\nsigned main(){\n  Cinit();\n  int N,M;cin>>N>>M;\n  int ans=nCk(3*M+(N-1),N-1);//cout<<ans<<endl;\n  int mi=N*nCk(M-1+N-1,N-1)%MOD;\n  ans-=mi;\n  ans+=MOD;ans%=MOD;\n  //cout<<ans<<endl;\n  for(int i=M+1;i<=min(N,3*M);i++){\n    if((i&1)!=((3*M)&1))continue;\n    int p=(3*M-i)/2;\n    int q=nCk(p+N-1,N-1);\n    int s=nCk(N,i);\n    int a=q*s%MOD;\n    ans-=a;\n    ans+=MOD;ans%=MOD;\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : C.cpp\n * Author  : Kazune Takahashi\n * Created : 7/21/2019, 10:28:37 PM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n#define maxs(x, y) (x = max(x, y))\n#define mins(x, y) (x = min(x, y))\nusing ll = long long;\nclass mint\n{\npublic:\n  static ll MOD;\n  ll x;\n  mint() : x(0) {}\n  mint(ll x) : x(x % MOD) {}\n  mint operator-() const { return x ? MOD - x : 0; }\n  mint &operator+=(const mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  mint &operator-=(const mint &a) { return *this += -a; }\n  mint &operator*=(const mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  mint &operator/=(const mint &a)\n  {\n    mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  mint operator+(const mint &a) const { return mint(*this) += a; }\n  mint operator-(const mint &a) const { return mint(*this) -= a; }\n  mint operator*(const mint &a) const { return mint(*this) *= a; }\n  mint operator/(const mint &a) const { return mint(*this) /= a; }\n  bool operator<(const mint &a) const { return x < a.x; }\n  bool operator==(const mint &a) const { return x == a.x; }\n  const mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\nll mint::MOD = 998244353;\nistream &operator>>(istream &stream, mint &a) { return stream >> a.x; }\nostream &operator<<(ostream &stream, const mint &a) { return stream << a.x; }\nclass combination\n{\npublic:\n  vector<mint> inv, fact, factinv;\n  static int MAX_SIZE;\n  combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[mint::MOD % i]) * (mint::MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1; i < MAX_SIZE; i++)\n    {\n      fact[i] = mint(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  mint operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n};\nint combination::MAX_SIZE = 2000010;\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\n// constexpr double epsilon = 1e-10;\n// constexpr ll infty = 1000000000000000LL;\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n\nll N, M;\n\nint main()\n{\n  cin >> N >> M;\n  combination C;\n  mint ans = C(3 * M + N - 1, N - 1);\n  for (auto K = 3 * M; K >= 2 * M + 1; K--)\n  {\n    ans -= C(3 * M - K + N - 2, N - 2) * N;\n  }\n  for (auto K = 0LL; K < M; K++)\n  {\n    if (N - (3 * M - 2 * K) >= 0)\n    {\n      assert(false);\n    }\n    ans -= C(N, 3 * M - 2 * K) * C(K + N - 1, N - 1);\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define M 998244353\n\n#define Z 3000000\n\nll pot(int a, int b) {\n\tif (b == 0) return 1;\n\tll x = pot(a,b/2);\n\tx = x*x%M;\n\tif (b%2) x = x*a%M;\n\treturn x;\n}\n\nll inv(ll x) {\n\treturn pot(x,M-2);\n}\n\nll ff[Z+1];\nll ii[Z+1];\n\nll ncr(int a, int b) {\n\treturn ff[a]*ii[b]%M*ii[a-b]%M;\n}\n\nll calc(int n, int k) {\n\treturn ncr(k+n-1,k);\n}\n\nint n, m;\n\nint main() {\n\tff[0] = 1;\n\tfor (int i = 1; i <= Z; i++) ff[i] = ff[i-1]*i%M;\n\tii[Z] = inv(ff[Z]);\n\tfor (int i = Z-1; i >= 0; i--) ii[i] = ii[i+1]*(i+1)%M;\n\tcin >> n >> m;\n\tll x = calc(n,2*m+m);\n\tfor (int i = 2*m+1; i <= 2*m+m; i++) {\n\t\tll u = n*calc(n-1,2*m+m-i)%M;\n\t\tx = (x-u)%M;\n\t\tif (x < 0) x += M;\n\t}\n\n\tif (m < n) {\n\t\tfor (int i = m+1; i <= n; i++) {\n\t\t\tif (2*m+m-i < 0 || (2*m+m-i)%2 == 1) continue;\n\t\t\tll u = ncr(n,i)*calc(n,(2*m+m-i)/2)%M;\n\t\t\tx = (x-u)%M;\n\t\t\tif (x < 0) x += M;\n\t\t}\n\t}\n\tcout << x << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "//雪花飄飄北風嘯嘯\n//天地一片蒼茫\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n#define ll long long\n#define ii pair<ll,ll>\n#define iii pair<ii,ll>\n#define fi first\n#define se second\n#define endl '\\n'\n#define debug(x) cout << #x << \" is \" << x << endl;\n\n#define rep(x,start,end) for(auto x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n\nll MAX(ll a){return a;}\nll MIN(ll a){return a;}\ntemplate<typename... Args>\nll MAX(ll a,Args... args){return max(a,MAX(args...));}\ntemplate<typename... Args>\nll MIN(ll a,Args... args){return min(a,MIN(args...));}\n\n#define indexed_set tree<ll,null_type,less<ll>,rb_tree_tag,tree_order_statistics_node_update>\n\nmt19937 rng(chrono::system_clock::now().time_since_epoch().count());\n\nconst int MOD=1000000007;\n\nll qexp(ll b,ll p,int m){\n    ll res=1;\n    while (p){\n        if (p&1) res=(res*b)%m;\n        b=(b*b)%m;\n        p>>=1;\n    }\n    return res;\n}\n\nll inv(ll i){\n\treturn qexp(i,MOD-2,MOD);\n}\n\nll fac[1000005];\nll ifac[1000005];\n\nll nCk(int i,int j){\n\tif (i<j) return 0; //big bruh\t\n\t\n\treturn fac[i]*ifac[j]%MOD*ifac[i-j]%MOD;\n}\n\nll fix(ll i){\n\ti%=MOD;\n\t\n\tif (i<0) i+=MOD;\n\t\n\treturn i;\n}\n\nll dist(int i,int j){ //distribute j things among i ppl\n\treturn nCk(i+j-1,i-1);\n}\n\nint n,m;\n\nll comp[1000005];\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\t\n\tfac[0]=1;\n\trep(x,1,1000005) fac[x]=fac[x-1]*x%MOD;\n\trep(x,0,1000005) ifac[x]=inv(fac[x]);\n\t\n\tcin>>n>>m;\n\t\n\tcomp[0]=n*dist(n-1,0)%MOD;\n\trep(x,1,1000005) comp[x]=(comp[x-1]+n*dist(n-1,x))%MOD;\n\t\n\tll ans=0;\n\tfor (int x=m;x>=0;x-=2) if (x<=n){\n\t\tint k=(3*m-x)/2;\n\t\t//cout<<k<<\" \"<<x<<endl;\n\t\t\n\t\t//each number is form 2A+B\n\t\t\n\t\t//case 1: there exists a number with A=m\n\t\tans=fix(ans+n*dist(n-1,k-m)%MOD*nCk(n-1,x));\n\t\t\n\t\t//case 2: bigest number <2m\n\t\tans=fix(ans+(dist(n,k)-comp[k-m])*nCk(n,x));\n\t\n\t\t//cout<<ans<<endl;\n\t}\n\t\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\nconst ll MN = 1001000;\nconst ll MM = 500500;\nll w[MM*3],x[MM*3],pr[MM*3];\nconst ll M = 998244353;\ninline ll mul(ll a, ll b) {\n\treturn (a*b)%M;\n}\nll bp(ll b, ll p) {\n\tll ac = 1;\n\twhile(p) {\n\t\tif(p&1) {ac = mul(ac,b);}\n\t\tb = mul(b,b);\n\t\tp >>= 1;\n\t}\n\treturn ac;\n}\nll fp[MN*2],ip[MN*2];\nll fac(ll v) {\n\tif(v <= 1) return 1;\n\tif(fp[v] != -1) return fp[v];\n\tif(v > 10000) fac(v-10000);\n\treturn fp[v] = mul(fac(v-1),v);\n}\nll inv(ll v) {\n\treturn bp(v,M-2);\n}\nll ifac(ll v) {\n\tif(v <= 1) return 1;\n\tif(ip[v] != -1) return ip[v];\n\treturn ip[v] = inv(fac(v));\n}\nll ch(ll n, ll k) {\n\tif(k < 0 || k > n) return 0;\n\treturn mul(mul(fac(n),ifac(n-k)),ifac(k));\n}\nint main() {\n\tmemset(fp,-1,sizeof(fp));\n\tmemset(ip,-1,sizeof(ip));\n\tll n,m;\n\tcin >> n >> m;\n\tll sm = 0;\n\tfor(int i=0;i<=2*m;i++) {\n\t\tw[i] = ch(n+i-1,n-1);\n\t\tif(i > m) {\n\t\t\tsm += ch(n+i-(m+1)-2,n-2);\n\t\t\tsm %= M;\n\t\t}\n\t\tw[i] -= mul(n,sm);\n\t\tw[i] = (w[i]+M)%M;\n\t}\n\tfor(int i=0;i<=2*m;i++) {\n\t\tx[i] = w[i];\n\t\tif(i >= m) {\n\t\t\tll rem = ch(n+i-m-2,n-2);\n\t\t\tx[i] -= mul(n,rem);\n\t\t}\n\t\tx[i] = (x[i]+M)%M;\n\t}\n\tll res = 0;\n\tfor(int i=0;i<2*m;i++) {\n\t\tll sa = 3*m-2*i;\n\t\tif(sa > m) continue;\n\t\tif(sa < 0) continue;\n\t\tres += mul(ch(n-1,sa),w[i])+mul(ch(n-1,sa-1),x[i]);\n\t\tres %= M;\n\t}\n\tcout << res << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=998244353;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=3010000;\n\nint n,m;\nll fac[N],fnv[N],inv[N];\nll comb(int a,int b) {\n\tif (b>a||b<0) return 0;\n\treturn fac[a]*fnv[b]%mod*fnv[a-b]%mod;\n}\n\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tfac[0]=fnv[0]=fac[1]=fnv[1]=1;\n\tinv[0]=inv[1]=1;\n\trep(i,2,3000001) {\n\t\tfac[i]=fac[i-1]*i%mod;\n\t\tinv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\t\tfnv[i]=fnv[i-1]*inv[i]%mod;\n\t}\n\tll ans=0;\n\tfor (int odd=0;odd<=n&&odd<=m;odd++) {\n\t\tif (3*m%2!=odd%2) continue;\n\t\tans=(ans+comb(n,odd)*(comb((3*m-odd)/2+n-1,n-1)-n*comb((m-odd)/2+n-1,n-1)%mod))%mod;\n\t}\n\tans=(ans+n*comb(m+n-2,n-2))%mod;\n\tif (ans<0) ans+=mod;\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = vector<int>;\nusing Vll = vector<ll>;\nusing Vld = vector<ld>;\nusing Vbo = vector<bool>;\nusing VV = vector<V>;\nusing VVll = vector<Vll>;\nusing VVld = vector<Vld>;\nusing VVbo = vector<Vbo>;\nusing VVV = vector<VV>;\nusing VVVll = vector<VVll>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\n#define rep2(i, m, n) for (int i = (m); i < (n); ++i)\n#define drep2(i, m, n) for (int i = (m)-1; i >= (n); --i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) (a).begin(), (a).end()\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\ntemplate<typename T> inline int sz(T &x) { return x.size(); }\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << '(' << p.first << \", \" << p.second << ')'; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << ' '; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int fLog2(const int x) { assert(x > 0); return 31-__builtin_clz(x); } // floor(log2(x))\ninline int fLog2(const ll x) { assert(x > 0); return 63-__builtin_clzll(x); }\ninline int cLog2(const int x) { assert(x > 0); return (x == 1) ? 0 : 32-__builtin_clz(x-1); } // ceil(log2(x))\ninline int cLog2(const ll x) { assert(x > 0); return (x == 1) ? 0 : 64-__builtin_clzll(x-1); }\ninline int popcount(const int x) { return __builtin_popcount(x); }\ninline int popcount(const ll x) { return __builtin_popcountll(x); }\nconst int INF  = 1<<30;\nconst ll INFll = 1ll<<62;\nconst ld EPS   = 1e-10;\nconst ld PI    = acos(-1.0);\n// const int MOD  = int(1e9)+7;\nconst int MOD  = 998244353;\n\n\nstruct mint {\n  ll x;\n  mint(ll x=0) : x((x%MOD+MOD)%MOD) {}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) { if ((x += a.x) >= MOD) x -= MOD; return *this; }\n  mint& operator-=(const mint a) { if ((x -= a.x) < 0) x += MOD; return *this; }\n  mint& operator*=(const mint a) { (x *= a.x) %= MOD; return *this; }\n  mint operator+(const mint a) const { return mint(*this) += a; }\n  mint operator-(const mint a) const { return mint(*this) -= a; }\n  mint operator*(const mint a) const { return mint(*this) *= a; }\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n  mint& operator/=(const mint r) {\n    ll a = r.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      ll t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = x * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  mint operator/(const mint a) const { return mint(*this) /= a; }\n};\n// istream& operator>>(istream& is, mint& a) { return is >> a.x; }\nostream& operator<<(ostream& os, const mint& a) { return os << a.x; }\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\nusing VVVm = vector<VVm>;\n\n\n// initialization\nconst int F_MAX = int(3e6)+10;\nll fac[F_MAX], finv[F_MAX], inv[F_MAX];\nvoid binom_init() {\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (int i = 2; i < F_MAX; ++i) {\n    fac[i] = fac[i-1] * i % MOD;\n    inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n    finv[i] = finv[i-1] * inv[i] % MOD;\n  }\n}\n\nmint binom(int n, int k) {\n  if (k < 0 || n < k) return 0;\n  return fac[n] * (finv[k] * finv[n-k] % MOD);\n}\n\nmint perm(int n, int k) {\n  if (k < 0 || n < k) return 0;\n  return fac[n] * finv[n-k];\n}\n\n\nint main() {\n  binom_init();\n  int n, m; cin >> n >> m;\n\n  mint ans = 0;\n\n  rep(k, n+1) {\n    mint res = 0;\n    int l = 3*m - k;\n    if (l >= 0 && l % 2 == 0) res += binom(n+l/2-1, l/2);\n    l = 3*m - (2*m+k);\n    if (l >= 0 && l % 2 == 0) res -= binom(n+l/2-1, l/2) * k;\n    l = 3*m - (2*m+2+k);\n    if (l >= 0 && l % 2 == 0) res -= binom(n+l/2-1, l/2) * (n-k);\n    ans += res * binom(n, k);\n  }\n\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define mod 998244353\n\nusing namespace std;\n\nllint n, m;\nconst int FACT_MAX = 4000005;\nllint fact[FACT_MAX], fact_inv[FACT_MAX];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < FACT_MAX; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfact_inv[FACT_MAX-1] = modpow(fact[FACT_MAX-1], mod-2);\n\tfor(int i = FACT_MAX-2; i >= 0; i--){\n\t\tfact_inv[i] = fact_inv[i+1] * (i+1) % mod;\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nllint calc(llint s, llint x)\n{\n\t//cout << s << \" \" << x << endl;\n\tllint ret = 0;\n\tfor(int i = 0; i <= min(s, min(n, m)); i++){\n\t\tif(s%2 != i%2) continue;\n\t\tllint tmp = 0, rem = (s-i)/2, rem2;\n\t\tfor(int j = 0; j <= x; j++){\n\t\t\tif(j > n-i || x-j > n) continue;\n\t\t\tfor(int k = 0; k <= 3; k++){\n\t\t\t\tif(k > j) continue;\n\t\t\t\tfor(int l = 0; l <= 3; l++){\n\t\t\t\t\tif(l > n-j) continue;\n\t\t\t\t\trem2 = rem - (m/2+1)*k - m/2*l;\n\t\t\t\t\tif(rem2 < 0) continue;\n\t\t\t\t\t//cout << i << \" \" << j << \" \" << k << \" \" << l << \" \" << rem2 << endl;\n\t\t\t\t\tllint val = comb(rem2+n-1, n-1) * comb(n, i) % mod * comb(n-i, j) % mod * comb(i, x-j) % mod\n\t\t\t\t\t* comb(j, k) % mod * comb(n-j, l) % mod;\n\t\t\t\t\tif((k+l) % 2) tmp += mod - val, tmp %= mod;\n\t\t\t\t\telse tmp += val, tmp %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret += tmp, ret %= mod;\n\t\t//cout << ret << endl;\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> n >> m;\n\tmake_fact();\n\t\n\tllint ans = 0;\n\tif(n >= 3 && (m % 2 == 0 || m >= 3)) ans += comb(n, 3);\n\t//cout << ans << endl;\n\t\n\tfor(int i = 0; i < 3; i++){\n\t\tans += calc((3-i)*m, i) % mod;\n\t\tans %= mod;\n\t\t//cout << ans << endl;\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = long long;\n\nconst i64 MOD = 998244353;\nconst i64 INF = i64(1e18) + 7;\n\n\ntemplate <typename T>\nbool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate <i64 mod = MOD>\nstruct ModInt{\n    i64 p;\n\n    ModInt() : p(0){}\n    ModInt(i64 x){p = x >= 0 ? x % mod : x + (-x + mod - 1) / mod * mod;}\n\n    ModInt& operator+=(const ModInt& y){p = p + *y - ((p + *y) >= mod ? mod : 0); return *this;}\n    ModInt& operator-=(const ModInt& y){p = p - *y + (p - *y < 0 ? mod : 0); return *this;}\n    ModInt& operator*=(const ModInt& y){p = (p * *y) % mod; return *this;}\n    ModInt& operator%=(const ModInt& y){if(y)p %= *y; return *this;}\n\n    ModInt operator+(const ModInt& y) const{ModInt x = *this; return x += y;}\n    ModInt operator-(const ModInt& y) const{ModInt x = *this; return x -= y;}\n    ModInt operator*(const ModInt& y) const{ModInt x = *this; return x *= y;}\n    ModInt operator%(const ModInt& y) const{ModInt x = *this; return x %= y;}\n\n    friend ostream& operator<<(ostream& stream, const ModInt<mod>& x){\n        stream << *x;\n        return stream;\n    }\n\n    friend ostream& operator>>(ostream& stream, const ModInt<mod>& x){\n        stream >> *x;\n        return stream;\n    }\n\n    ModInt& operator++(){p = (p + 1) % mod; return *this;}\n    ModInt& operator--(){p = (p - 1 + mod) % mod; return *this;}\n\n    bool operator==(const ModInt& y) const{return p == *y;}\n    bool operator!=(const ModInt& y) const{return p != *y;}\n\n    const i64& operator*() const{return p;}\n    i64& operator*(){return p;}\n\n};\n\nusing mint = ModInt<>;\n\n\nsigned main(){\n    int n, m;\n    cin >> n >> m;\n\n    auto mpow = [](auto x, i64 y){\n        auto z = x;\n        decltype(x) val = y & 1 ? x : decltype(x)(1);\n        while(z *= z, y >>= 1)\n            if(y & 1)\n                val *= z;\n        return val;\n    };\n\n    auto calc_fact = [mpow]{\n     constexpr int N = 5e6;\n     vector<mint> fact(N + 1, 1);\n     vector<mint> inv(N + 1, 1);\n     for(int i = 1; i < N; ++i){\n      fact[i + 1] = fact[i] * (i + 1);\n      inv[i + 1] = mpow(fact[i + 1], MOD - 2);\n     }\n     return make_pair(fact, inv);\n    };\n    vector<mint> fact, inv;\n    tie(fact, inv) = calc_fact();\n\n    auto ncr = [&fact, &inv](int n, int r){\n     if(n < 0 || r < 0 || n < r)\n      return mint(0);\n     return fact[n] * inv[r] * inv[n - r];\n    };\n\n    // 総和3Mになる通り数\n    // N-1個のしきりを入れる\n    mint ans = ncr(3 * m + n - 1, n - 1);\n    for(int ma = 2 * m + 1; ma <= 3 * m; ++ma){\n        ans -= ncr(3 * m - ma + n - 2, n - 2) * n;\n    }\n\n    for(int cnt = m + 1; cnt <= n; ++cnt){\n        mint val = 1;\n        val *= ncr(n, cnt);\n        int diff = 3 * m - cnt;\n        if(diff % 2 == 0){\n            val *= ncr(diff / 2 + n - 1, n - 1);\n            ans -= val;\n        }\n    }\n\n    cout << ans << endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nconst int MAX = 2000000;\nconst int MOD = 998244353;\nInt fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nInt COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nint main()\n{\n    COMinit();\n    int N, M; cin >> N >> M;\n    Int a = 0, b = 0, c = 0;\n    for (int o = M % 2; o <= M; o += 2) {\n        int t = (3 * M - o) / 2;\n        a += COM(t + N - 1, N - 1) * COM(N, o);\n        a %= MOD;\n    }\n    for (int o = M % 2; o <= M; o += 2) {\n        int t = (3 * M - o) / 2;\n        b += N * COM((t - M) + N - 1, N - 1) % MOD * COM(N - 1, o - 1);\n        b %= MOD;\n    }\n    for (int o = M % 2; o <= M; o += 2) {\n        int t = (3 * M - o) / 2;\n        c += N * COM((t - M - 1) + N - 1, N - 1) % MOD * COM(N - 1, o);\n        c %= MOD;\n    }\n    cout << (a + MOD - b + MOD - c) % MOD << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//雪花飄飄北風嘯嘯\n//天地一片蒼茫\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n#define ll long long\n#define ii pair<ll,ll>\n#define iii pair<ii,ll>\n#define fi first\n#define se second\n#define endl '\\n'\n#define debug(x) cout << #x << \" is \" << x << endl;\n\n#define rep(x,start,end) for(auto x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n\nll MAX(ll a){return a;}\nll MIN(ll a){return a;}\ntemplate<typename... Args>\nll MAX(ll a,Args... args){return max(a,MAX(args...));}\ntemplate<typename... Args>\nll MIN(ll a,Args... args){return min(a,MIN(args...));}\n\n#define indexed_set tree<ll,null_type,less<ll>,rb_tree_tag,tree_order_statistics_node_update>\n\nmt19937 rng(chrono::system_clock::now().time_since_epoch().count());\n\nconst int MOD=998244353;\n\nll qexp(ll b,ll p,int m){\n    ll res=1;\n    while (p){\n        if (p&1) res=(res*b)%m;\n        b=(b*b)%m;\n        p>>=1;\n    }\n    return res;\n}\n\nll inv(ll i){\n\treturn qexp(i,MOD-2,MOD);\n}\n\nll fac[2000005];\nll ifac[2000005];\n\nll nCk(int i,int j){\n\tif (i<j) return 0; //big bruh\t\n\t\n\treturn fac[i]*ifac[j]%MOD*ifac[i-j]%MOD;\n}\n\nll fix(ll i){\n\ti%=MOD;\n\t\n\tif (i<0) i+=MOD;\n\t\n\treturn i;\n}\n\nll dist(int i,int j){ //distribute j things among i ppl\n\treturn nCk(i+j-1,i-1);\n}\n\nint n,m;\n\nll comp[1000005];\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\t\n\tfac[0]=1;\n\trep(x,1,2000005) fac[x]=fac[x-1]*x%MOD;\n\trep(x,0,2000005) ifac[x]=inv(fac[x]);\n\t\n\tcin>>n>>m;\n\t\n\tcomp[0]=n*dist(n-1,0)%MOD;\n\trep(x,1,1000005) comp[x]=(comp[x-1]+n*dist(n-1,x))%MOD;\n\t\n\tll ans=0;\n\tfor (int x=m;x>=0;x-=2) if (x<=n){\n\t\tint k=(3*m-x)/2;\n\t\t//cout<<k<<\" \"<<x<<endl;\n\t\t\n\t\t//each number is form 2A+B\n\t\t\n\t\t//case 1: there exists a number with A=m\n\t\tans=fix(ans+n*dist(n-1,k-m)%MOD*nCk(n-1,x));\n\t\t\n\t\t//case 2: bigest number <2m\n\t\tans=fix(ans+(dist(n,k)-comp[k-m])*nCk(n,x));\n\t\n\t\t//cout<<ans<<endl;\n\t}\n\t\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define endl '\\n'\n#define fi first\n#define se second\n#define MOD(n,k) ( ( ((n) % (k)) + (k) ) % (k))\n#define forn(i,n) for (int i = 0; i < n; i++)\n#define forr(i,a,b) for (int i = a; i <= b; i++)\n#define all(v) v.begin(), v.end()\n#define pb emplace_back\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ii> vii;\n\nconst int MX = 5000005, mod = 998244353;\nint n, m;\nll f[MX], in[MX];\n\nll comb (int n, int k) {\n\treturn f[n] * in[k] % mod * in[n - k] % mod; \n}\n\nll fun (int n, int k) {\n\treturn comb(n + k - 1, k);\n}\n\nint main () {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tf[0] = in[0] = in[1] = 1;\n\tfor (int i = 1; i < MX; i++)\n\t\tf[i] = f[i-1] * i % mod;\n\tfor (int i = 2; i < MX; i++)\n\t\tin[i] = in[mod % i] * (mod - mod / i) % mod;\n\tfor (int i = 1; i < MX; i++)\n\t\t(in[i] *= in[i-1]) %= mod;\n\n\tcin >> n >> m;\n\n\tll res = 0;\n\tfor (int i = 0; i <= min(m, n); i++) {\n\t\tif ((3 * m - i) % 2) continue;\n\t\t(res += comb(n, i) * fun(n, (3 * m - i) / 2)) %= mod;\n\t\t(res -= comb(n, i) * fun(n, (m - i) / 2) % mod * n) %= mod;\n\t\t(res += comb(n, i) * fun(n - 1, (m - i) / 2) % mod * (n - i)) %= mod;\n\t}\n\n\tcout << MOD(res, mod) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\nusing ll = long long;\n\n// Fermat の小定理を用いた F_mod 上での逆元計算x^(mod-2), 蟻本p115\nll Inverse(ll x){\n    ll res = 1;\n    int n = mod - 2;\n    while(n > 0){\n        if(n & 1){\n            res = res * x % mod;\n        }\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    /*\n     * 全部の組み合わせから不可能なものを引く\n     * 不可能なのは\n     * 1. ある値が2Mより大きい\n     * 2. 値が奇数のものがM個より多い\n     * のどちらか, これらは背反(和は3Mより)\n     * 奇数に1を1回, 最大の数から2を割り振れば構成できる\n     */\n\n    // 階乗計算, iの階乗 = fact[i}\n    vector<ll>fact(3 * M + N);\n    fact[0]=1;\n    for(int i=1; i < 3 * M + N + 1; i++){\n        fact[i] = fact[i-1] * i % mod;\n    }\n\n    ll ans = fact[3*M+N-1] * Inverse(fact[N-1] * fact[3*M] % mod);\n    ans %= mod;\n\n\n    // ある値が2Mより大きい場合, 他の値の合計で回す\n    ll over = 0;\n    for (int i = 0; i < M; ++i) {\n        over = over + fact[i+N-2] * Inverse(fact[N-2] * fact[i] % mod);\n        over %= mod;\n    }\n    over = over * (N-1);\n    over %= mod;\n    ans = ans + mod - over;\n    ans %= mod;\n\n\n    // 値が奇数のものがM個より多い場合, 奇数の個数で回す\n    ll many = 0;\n    for (int i = M+1; i < N+1; ++i) {\n        if((3 * M - i) % 2 == 1) continue;\n        ll temp = 0;\n        temp = temp + fact[3*M-i+N+1] * Inverse(fact[N-1] * fact[3*M-i] % mod);\n        temp %= mod;\n        temp = temp * fact[N];\n        temp %= mod;\n        temp = temp * Inverse(fact[i] * fact[N-i] % mod);\n        many += temp;\n        many %= mod;\n    }\n    ans = ans + mod - many;\n    ans %= mod;\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 5 * 1000 * 1000 + 17;\nconst int MOD = 1000 * 1000 * 1000 + 7;\nconst int M = 998244353;\n\nint n, m;\nlong long F[N];\n\nbool read() {\n    if (!(cin >> n >> m))\n        return false;\n\n    return true;\n}\n\nlong long naive() {\n    vector< vector< vector<long long> > >\n        dp(n + 1, vector< vector<long long> >(3 * m + 1, vector<long long>(n + 1, 0ll)));\n\n    dp[0][0][0] = 1;\n\n    for (int i = 0; i < n; ++i)\n        for (int s = 0; s <= 3 * m; ++s)\n            for (int j = 0; j <= i; ++j)\n                for (int c = 0; c <= 2 * m && c + s <= 3 * m; ++c) {\n                    if (j + c % 2 > n) continue;\n                    dp[i + 1][s + c][j + c % 2] += dp[i][s][j];\n                    dp[i + 1][s + c][j + c % 2] %= M;\n                }\n\n    auto res = 0ll;\n\n    for (int j = 0; j <= 2 * m && j <= n; ++j)\n        res = (res + dp[n][3 * m][j]) % M;\n\n    return res;\n}\n\nlong long bpow(long long a, int n, long long M) {\n    auto res = 1ll;\n\n    for (; n > 0; n /= 2, a = a * a % M)\n        if (n & 1)\n            res = res * a % M;\n\n    return res;\n}\n\nlong long rev(long long x) { return bpow(x, M - 2, M); }\n\nlong long binomial(int n, int k) {\n    return n < 0 || k < 0 || k > n ? 0ll : F[n] * rev(F[k] * F[n - k] % M) % M;\n}\n\nlong long gay(int s, int n) {\n    return s == 0 ? 1ll : binomial(s + n - 1, n - 1);\n}\n\nlong long sol() {\n    auto res = gay(3 * m, n);\n\n    for (int mx = 2 * m + 1; mx <= 3 * m; ++mx) {\n        auto cur = gay(3 * m - mx, n - 1) * n % M;\n        res = (res + M - cur) % M;\n    }\n\n    for (int odd = m + 1; odd <= 3 * m; ++odd)\n        if ((3 * m - odd) % 2 == 0) {\n            auto cur = gay((3 * m - odd) / 2, n) * binomial(n, odd) % M;\n            res = (res + M - cur) % M;\n        }\n\n    return res;\n}\n\nvoid solve() {\n    F[0] = 1ll;\n\n    for (int i = 1; i < N; ++i)\n        F[i] = i * F[i - 1] % M;\n\n    cout << sol() << endl;\n\n    /*for (n = 2; n <= 500; ++n)\n        for (m = 1; m <= 10; ++m) {\n            auto r1 = sol();\n            auto r2 = naive();\n\n            if (r1 != r2) {\n                cout << n << ' ' << m << \" : \" << r1 << ' ' << r2 << endl;\n            }\n        }*/\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (read())\n        solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a); i <= (b); i++)\n#define per(i, a, b) for (int i = (a); i >= (b); i--)\n#define trv(p, u) for (edg *p = h[u]; p; p = p->nxt)\n#define pb push_back\ntypedef long long ll;\ntypedef double db;\nconst int N = 1e6 + 100;\nconst int inf = 0x3f3f3f3f;\nconst int mod = 998244353;\n\ninline int rd() {\n  int s = 0, w = 1; char c = getchar();\n  while (c < '0' || c > '9') { if (c == '-') w = -1; c = getchar(); }\n  while (c >= '0' && c <= '9') s = s * 10 + c - '0', c = getchar();\n  return s * w;\n}\n\nint n, m, fac[N], inv[N];\n\ninline int qpow(int a, int b) {\n  int res = 1;\n  while (b) {\n    if (b & 1) res = 1ll * res * a % mod;\n    a = 1ll * a * a % mod, b >>= 1;\n  }\n  return res;\n}\n\ninline void prew() {\n  fac[0] = inv[0] = fac[1] = inv[1] = 1;\n  rep(i, 2, N - 100) inv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod;\n  rep(i, 2, N - 100)\n    fac[i] = 1ll * i * fac[i - 1] % mod, inv[i] = 1ll * inv[i] * inv[i - 1] % mod;\n}\n\ninline int C(int a, int b) { return 1ll * fac[a] * inv[a - b] % mod * inv[b] % mod; }\n\ninline int calc(int x) {\n  int res = 0;\n  for (int i = x & 1; i <= min(x, min(n, m)); i += 2)\n    res = (res + 1ll * C(n, i) * C((x - i) / 2 + n - 1, n - 1)) % mod;\n  return res;\n}\n\nint main() {\n  prew(); n = rd(), m = rd();\n  printf(\"%lld\\n\", (calc(m * 3) - 1ll * n * calc(m - 1) % mod + mod) % mod);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint main(){\n    using namespace std;\n    constexpr unsigned long MOD = 998244353;\n    size_t N, M;\n    cin >> N >> M;\n    auto modpow = [&MOD](unsigned long a, unsigned long n, unsigned long b = 1) -> unsigned long{\n        auto ret = b;\n        while(n){\n            if(n & 1)(ret *= a) %= MOD;\n            (a *= a) %= MOD;\n            n >>= 1;\n        }\n        return ret;\n    };\n    auto modbinomial = [&MOD, &modpow](unsigned long n, unsigned long k) -> unsigned long{\n        unsigned long ret = 1, den = 1;\n        for(unsigned long i = 1; i <= k; ++i){\n            (ret *= (n - i + 1)) %= MOD;\n            (den *= i) %= MOD;\n        }\n        return modpow(den, MOD - 2, ret);\n    };\n    auto a = modbinomial(MOD - N, 3 * M) + N * modbinomial(MOD - N, M - 1);\n    cout << (M & 1 ? MOD - a % MOD : a % MOD) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#define int long long\n#define ll long long\ntypedef pair<int, int> P;\n#define mod 998244353\n#define INF (1LL<<60)\n\n#define rep(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define YES puts(\"YES\\n\")\n#define Yes puts(\"Yes\\n\")\n#define NO  puts(\"NO\\n\")\n#define No  puts(\"No\\n\")\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\n\n// ax+by=1の解\nint extgcd(int a, int b, int& x, int& y) {\n\tint d = a;\n\tif (b != 0) {\n\t\td = extgcd(b, a % b, y, x);\n\t\ty -= (a / b) * x;\n\t}\n\telse {\n\t\tx = 1; y = 0;\n\t}\n\treturn d;\n}\n\n// mod mでのaの逆数\nint mod_inverse(int a, int m) {\n\tint x, y;\n\textgcd(a, m, x, y);\n\treturn (m + x % m) % m;\n}\nconst int MAX = 3500000;\n// 階乗の事前計算\nint fac[MAX], fac_inv[MAX];\n\nvoid make_table(int N, int p) {\n\tfac[0] = fac[1] = 1;\n\tfor (int i = 2; i <= N; i++) fac[i] = (fac[i - 1] * i) % p;\n\tfor (int i = 0; i <= N; i++) fac_inv[i] = mod_inverse(fac[i], p);\n}\n\nint combination(int n, int r, int p) {\n\treturn (fac[n] * fac_inv[r]) % p* fac_inv[n - r] % p;\n}\n\nint nHr(int n, int r, int p) {\n\treturn combination(n + r - 1, r, p);\n}\n\nsigned main() {\n\n\tint N, M;\n\tcin >> N >> M;\n\n\tmake_table(3*M+N, mod);\n\n\tint ans = nHr(N, 3 * M, mod);\n\tint t = 0;\n\tfor (int i = 0; i <= M - 1; i++) {\n\t\tt += nHr(N - 1, i, mod);\n\t\tt %= mod;\n\t}\n\tans = ans - ((N * t) % mod);;\n\tans %= mod;\n\tans = (ans + mod) % mod;\n\tcout << ans << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nconst int MOD=998244353;\nconst int INF=0x3f3f3f3f;\nconst ll INFL=0x3f3f3f3f3f3f3f3f;\n\nll ppow(ll a,ll b){\n\ta%=MOD;\n\tll res=1;\n\twhile(b){\n\t\tif(b&1)res=(res*a)%MOD;\n\t\ta=(a*a)%MOD;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nclass Fact{\n\tvector<ll>fact;\n\tvector<ll>inv;\npublic:\n\tFact(){}\n\tFact(int n){\n\t\tn=n*2+10;\n\t\tfact=inv=vector<ll>(n);\n\t\tfact[0]=inv[0]=1;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=(fact[i-1]*i)%MOD;\n\t\t}\n\t\tinv[n-1]=ppow(fact[n-1],MOD-2);\n\t\tfor(int i=n-2;i>=0;i--){\n\t\t\tinv[i]=(inv[i+1]*(i+1))%MOD;\n\t\t}\n\t}\n\tll get(int n){\n\t\treturn fact[n];\n\t}\n\tll get_inv(int n){\n\t\treturn inv[n];\n\t}\n\tll nPr(int n,int r){\n\t\treturn fact[n]*inv[n-r]%MOD;\n\t}\n\tll nCr(int n,int r){\n\t\treturn nPr(n,r)*inv[r]%MOD;\n\t}\n\tll nrP(int n,int r){\n\t\treturn nPr(n+r,n);\n\t}\n\tll nrC(int n,int r){\n\t\treturn nCr(n+r,n);\n\t}\n};\n\nint main(){\n\tint n,m;cin>>n>>m;\n\tFact fac(3*m+n);\n\tll ans=0;\n\tfor(int s=m%2;s<=m;s+=2){\n\t\tll a=fac.nCr(n,s);\n\t\tll b=fac.nCr((3*m-s)/2+n-1,n-1);\n\t\tif((3*m-s)/2>=m)(b+=MOD-fac.nCr((3*m-s)/2-m+n-1,n-1)*s%MOD)%=MOD;\n\t\tif((3*m-s)/2>=m+1)(b+=MOD-fac.nCr((3*m-s)/2-m-1+n-1,n-1)*(n-s)%MOD)%=MOD;\n\t\t(ans+=a*b)%=MOD;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll MOD = 998244353;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\nll bin_pow(ll x, ll p) {\n\tif (p == 0) return 1;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1));\n\treturn bin_pow(mult(x, x), p / 2);\n}\nll rev(ll x) {\n\treturn bin_pow(x, MOD - 2);\n}\n\nconst int N = (int)3e6 + 5;\nll f[N], rf[N];\n\nll getC(int n, int k) {\n\tif (k < 0 || k > n) return 0;\n\treturn mult(f[n], mult(rf[k], rf[n - k]));\n}\nll solve(int S, int n, int m) {\n\tll ans = 0;\n\tfor (int k = 0; k <= m; k++) {\n\t\tif (k > S) continue;\n\t\tif ((S - k) & 1) continue;\n\t\tans = add(ans, mult(getC(n, k), getC((S - k) / 2 + n - 1, n - 1)));\n\t}\n\treturn ans;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tf[0] = 1;\n\tfor (int i = 1; i < N; i++)\n\t\tf[i] = mult(f[i - 1], i);\n\trf[N - 1] = rev(f[N - 1]);\n\tfor (int i = N - 1; i > 0; i--)\n\t\trf[i - 1] = mult(rf[i], i);\n\n\tll ans = 0;\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tans = sub(solve(3 * m, n, m), mult(n, add(solve(m - 1, n - 1, m - 1), solve(m - 2, n, m))));\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 262144\n#define REP(a,b) for(long long a = 0;a < b;++a)\nvector<complex<double>>  DFT(vector<complex<double>> a) {\n\tint n = a.size();\n\tif (n == 1) return a;\n\tvector<complex<double>> a0(n / 2), a1(n / 2);\n\tREP(i, n) {\n\t\tif (i % 2 == 0) {\n\t\t\ta0[i / 2] = a[i];\n\t\t}\n\t\telse {\n\t\t\ta1[i / 2] = a[i];\n\t\t}\n\t}\n\tvector<complex<double>> inversed_a0 = DFT(a0), inversed_a1 = DFT(a1);\n\tvector<complex<double>> inversed_a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcomplex<double> zeta = complex<double>(cos(2 * Ma_PI * i / n), sin(2 * Ma_PI * i / n));\n\t\tinversed_a[i] = inversed_a0[i % (n / 2)] + zeta * inversed_a1[i % (n / 2)];\n\t}\n\treturn inversed_a;\n}\nvector<complex<double>> IDFT(vector<complex<double>> inversed_a) {\n\tint n = inversed_a.size();\n\tvector<complex<double>> now = DFT(inversed_a);\n\treverse(now.begin(), now.end());\n\tfor (int q = now.size() - 1; q >= 1; --q) {\n\t\tswap(now[q], now[q - 1]);\n\t}\n\tREP(i, n) {\n\t\tnow[i] /= complex<double>(n, 0);\n\t}\n\treturn now;\n}\nvector<complex<double>> conv(vector<complex<double>> a, vector<complex<double>> b) {\n\tint deg = a.size() + b.size() - 1;\n\tint n = 1;\n\twhile (n < deg) n <<= 1;\n\ta.resize(n);\n\tb.resize(n);\n\tvector<complex<double>> inversed_a = DFT(a), inversed_b = DFT(b);\n\tvector<complex<double>> inversed_c(n);\n\tREP(i, n) {\n\t\tinversed_c[i] = inversed_a[i] * inversed_b[i];\n\t}\n\treturn IDFT(inversed_c);\n}\nlong long inv(long long now) {\n\tlong long hoge = MOD - 2LL;\n\tlong long ans = 1;\n\twhile (hoge != 0) {\n\t\tif (hoge % 2 == 1) {\n\t\t\tans *= now;\n\t\t\tans %= MOD;\n\t\t}\n\t\thoge /= 2;\n\t\tnow *= now;\n\t\tnow %= MOD;\n\t}\n\treturn ans;\n}\nlong long jun[2100000] = {};\nlong long gyaku[2100000] = {};\nlong long combination(long long a, long long b) {\n\tlong long ans = jun[a];\n\tans *= gyaku[a - b];\n\tans %= MOD;\n\tans *= gyaku[b];\n\tans %= MOD;\n\treturn ans;\n}\nlong long no_limit(long long a, long long b) {\n\treturn combination(a + b - 1, a);\n}\n\nint main() {\n\tjun[0] = 1;\n\tgyaku[0] = 1;\n\tfor (long long i = 1; i < 2100000; ++i) {\n\t\tjun[i] = jun[i - 1] * i;\n\t\tjun[i] %= MOD;\n\t\tgyaku[i] = inv(jun[i]);\n\t}\n\tlong long n, m;\n\tcin >> n >> m;\n\tlong long ans = 0;\n\tlong long tmp = 0;\n\tfor (long long odd = m;; ++odd) {\n\t\tlong long even = m - (odd - m) * 2LL;\n\t\tif (even < 0) break;\n\t\ttmp -= (n * no_limit(odd - m, n - 1)) % MOD;\n\t\ttmp += 2LL * MOD;\n\t\ttmp %= MOD;\n\t\tif (even > n) continue;\n\t\tlong long geko = no_limit(odd, n);\n\t\tgeko += tmp;\n\t\tgeko += MOD;\n\t\tgeko %= MOD;\n\t\tans += geko * combination(n, even);\n\t\tans %= MOD;\n\t\tif (n - 1 >= even) {\n\t\t\tans += ((n * no_limit(odd - m, n - 1)) % MOD * combination(n - 1, even)) % MOD;\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<list>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\n#define mp make_pair\n#define mt make_tuple\n#define pqueue priority_queue\nconst int inf=1e9+7;\nconst ll mod=1e9+7;\nconst ll mod1=998244353;\nconst ll big=1e18;\nconst double PI=2*asin(1);\n\nll frac[10000000];\n\nll comb(ll a, ll b) {\n  if(a<b) return 0;\n  ll ans = frac[a];\n  ll sh1, sh2;\n  ll two;\n  ll h = mod1-2;\n  while(h>0) {\n    two = 1;\n    sh1 = frac[b];\n    sh2 = frac[a-b];\n    while(2*two<h) {\n      two *= 2;\n      sh1 *= sh1;\n      sh1 %= mod1;\n      sh2 *= sh2;\n      sh2 %= mod1;\n    }\n    h -= two;\n    ans *= sh1*sh2%mod1;\n    ans %= mod1;\n  }\n  return ans;\n}\n\nint main() {\n  frac[0] = 1;\n  for(ll i=1;i<10000000;++i) frac[i] = frac[i-1]*i%mod1;\n  ll N, M;\n  cin>>N>>M;\n  ll ans = comb(3*M+N-1, N-1);\n  for(ll i=2*M+1;i<=3*M;++i) {\n    ans = (ans-N*comb(3*M-i+N-2, N-2)%mod1+mod1)%mod1;\n  }\n  for(ll i=0;i<M;++i) {\n    ans = (ans-comb(i+N-1, N-1)*comb(N, 3*M-2*i)%mod1+mod1)%mod1;\n  }\n  cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\n\nconst int mod = 998244353;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 2540000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init(const int amax = MAX_MOD_N) {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < amax - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n// int solve(){\n// \tint N;cin>>N;\n// \tlong long int K;cin>>K;\n// \tvector<int>v;\n// \tfor(int i=0;i<N;++i){\n// \t\tint a;cin>>a;\n// \t\tv.push_back(a);\n// \t}\n// \tmap<int,int>mp;\n// \tfor(int i=N-1;i>=0;--i){\n// \t\tmp[v[i]]=N+i;\n// \t}\n// \tvector<int>rs(N);\n// \tfor(int i=N-1;i>=0;--i){\n// \t\trs[i]=mp[v[i]];\n// \t\tmp[v[i]]=i;\n// \t}\n\n// \tlong long int ny=0,nx=0;\n// \twhile(true){\n// \t\tauto next_x=rs[nx];\n// \t\tlong long next_y=ny;\n// \t\tif(next_x>=N){\n// \t\t\tnext_y++;\n// \t\t\tnext_x-=N;\n// \t\t}\n// \t}\n// }\nint main() {\n\tint N;cin>>N;\n\tint M;cin>>M;\n\tMod answer;\n\tinit();\n\tanswer=comb(N+3*M-1,N-1);\n\n\t{\n\t\tfor(int max_num=2*M+1;max_num<=3*M;++max_num){\n\t\t\tMod cnt=N;\n\t\t\tcnt*=comb(N-2+(3*M-max_num),N-2);\n\t\t\tanswer-=cnt;\n\t\t}\n\t\t//cout<<answer.num<<endl;\n\t\tfor(int odd_num=M+1;odd_num<=min(3*M,N);++odd_num){\n\t\t\tif(odd_num%2!=M%2)continue;\n\t\t\tMod place_cnt=comb(N,odd_num);\n\t\t\tint rest=3*M-odd_num;\n\t\t\tassert(rest%2==0);\n\t\t\tMod acnt=comb(N-1+rest/2,N-1);\n\t\t\tanswer-=place_cnt*acnt;\n\t\t}\n\t}\n\tcout<<answer.num<<endl;\n\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include \"../lib/math/comb.hpp\"\n\nusing namespace std;\n\n#define SZ(x) (int)(x.size())\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst ll MOD = 998244353;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\n\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  int n, m; cin >> n >> m;\n  Combination<MOD> comb(1<<21);\n\n  ll tmp1 = 0, tmp2 = 0, tmp3 = 0;\n  for(int a=m%2;a<=min(n, m);a+=2) {\n    tmp1 += comb.C((3*m-a)/2+n-1, n-1) * comb.C(n, a) % MOD;\n    tmp1 %= MOD;\n  }\n  for(int a=m%2;a<=min(n, m);a+=2) {\n    tmp2 += comb.C((m-a)/2+n-1, n-1) * comb.C(n, a) % MOD;\n    tmp2 %= MOD;\n  }\n  for(int a=m%2;a<=min(n-1, m);a+=2) {\n    tmp3 += comb.C((m-a)/2+n-2, n-2) * comb.C(n-1, a) % MOD;\n    tmp3 %= MOD;\n  }\n  //cout << tmp1 << \":\" << tmp2 << \":\" << tmp3 << endl;\n\n  cout << (tmp1 - (tmp2 - tmp3 + MOD) % MOD * n % MOD + MOD) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5e6+10;\nconst int mod=998244353;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nint n,m,fac[N],inv[N],ifac[N];\n\nint C(int n,int m) {\n\tif(m<0||n<m) return 0;\n\treturn 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\n\nint main() {\n\tcin>>n>>m;\n\tfac[0]=1;for(int i=1;i<N;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[1]=1;for(int i=2;i<N;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\tifac[0]=1;for(int i=1;i<N;i++) ifac[i]=1ll*ifac[i-1]*inv[i]%mod;\n\tint ans=0;\n\tfor(int i=0;i<=m;i++) if(!((3*m-i)&1)) ans=(ans+1ll*C(n,i)*C((3*m-i)/2+n-1,n-1))%mod;\n\tfor(int i=2*m+1;i<=3*m;i++) ans=(ans-1ll*n*C(3*m-i+n-2,n-2))%mod;\n\tcout<<(ans%mod+mod)%mod;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cerr << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcerr<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 3000010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 998244353;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\nmt19937 rng; //use it by rng() % mod, shuffle(all(vec), rng)\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nll fac[MAX_N], inv[MAX_N], fiv[MAX_N]; //fiv:inv(fac(i))\n\nll mod_pow(ll a, ll n) {\n\tif(n == 0) return 1;\n\tll res = mod_pow(a, n / 2);\n\tif(n % 2 == 0) return res * res % mod;\n\telse return a * res % mod * res % mod;\n}\n\nll invf(ll a) {\n\treturn mod_pow(a, mod - 2);\n}\n\nlong long mod_log(long long a, long long b) {\n    a %= mod, b %= mod;\n    long long lo = -1, hi = mod;\n    while (hi - lo > 1) {\n        long long mid = (lo + hi) / 2;\n        if (mid * mid >= mod) hi = mid;\n        else lo = mid;\n    }\n    long long sqrtM = hi;\n    map<long long, long long> apow;\n    long long amari = 1;\n    for (long long r = 0; r < sqrtM; ++r) {\n        if (!apow.count(amari)) apow[amari] = r;\n        (amari *= a) %= mod;\n    }\n    long long A = mod_pow(invf(a), sqrtM);\n    amari = b;\n    for (long long q = 0; q < sqrtM; ++q) {\n        if (apow.count(amari)) {\n            long long res = q * sqrtM + apow[amari];\n            if (res > 0) return res;\n        }\n        (amari *= A) %= mod;\n    }\n    return -1;\n}\n\nvoid C_init(int n) {\n\tfac[0] = fac[1] = 1; inv[1] = 1;\n\tfiv[0] = fiv[1] = 1;\n\trep(i, 2, n + 1) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod % i] * (mod / i) % mod;\n\t\tfiv[i] = fiv[i - 1] * inv[i] % mod;\n\t}\n}\n\nll C(int a, int b) { //assume a >= b\n\tif(a < b || a < 0 || b < 0) return 0;\n\treturn fac[a] * fiv[b] % mod * fiv[a - b] % mod;\n}\n\n\n\nvoid solve() {\n\tint N, M;\n\tcin >> N >> M;\n\tC_init(N + 3 * M);\n\tll res = (mod + C(N + 3 * M - 1, 3 * M) - N * C(N + M - 2, M - 1) % mod) % mod;\n\trep(i, M + 1, N + 1) {\n\t\tif((3 * M - i) % 2 == 0) {\n\t\t\tll v = C(N, i) * C(N - 1 + (3 * M - i) / 2, (3 * M - i) / 2) % mod;\n\t\t\tADD(res, mod - v);\n\t\t}\n\t}\n\tcout << res << \"\\n\";\n}\n\nuint32_t rd() {\n\tuint32_t res;\n#ifdef __MINGW32__\n\tasm volatile(\"rdrand %0\" :\"=a\"(res) ::\"cc\");\n#else\n\tres = std::random_device()();\n#endif\n\treturn res;\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n    cerr << fixed;\n\tcerr.precision(6);\n\trng.seed(rd());\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n\tif(!freopen(\"in.txt\", \"rt\", stdin)) return 1;\n#endif\t\n\tsolve();\n    cerr << \"Time: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\nconst int P=998244353,maxn=(2e6)+5;\nLL N,M,K,Fac[maxn],Inv[maxn],Ans;\nLL Pow(LL a,LL b){LL s=1;for(LL w=a;b;b>>=1,w=w*w%P) if(b&1) s=s*w%P;return s;}\ninline LL C(LL a,LL b){return Fac[a]*Inv[b]%P*Inv[a-b]%P;}\ninline void Add(LL& x,LL y){if((x+=y)>=P) x-=P;}\ninline void Dec(LL& x,LL y){if((x-=y)<0) x+=P;}\nint main(){\n\tscanf(\"%d%d\",&N,&M),K=N+(M<<1);\n\tFac[0]=1;\n\tfor(int i=1;i<=K;i++) Fac[i]=Fac[i-1]*i%P;\n\tInv[K]=Pow(Fac[K],P-2);\n\tfor(int i=K-1;~i;i--) Inv[i]=Inv[i+1]*(i+1)%P;\n\tfor(int i=0,tp;i<=N&&i<=M;i++) if(!((tp=(M<<1)+M-i)&1)) Add(Ans,C(N,i)*C((tp>>1)+N-1,N-1)%P);\n\tLL O=0;\n\tfor(int i=(M<<1)+1,ti=(M<<1)+M;i<=ti;i++) Add(O,C(ti-i+N-2,N-2)%P);\n\tDec(Ans,N*O%P);\n\tprintf(\"%lld\\n\",Ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class t> inline t read(t &x){\n\tchar c=getchar();bool f=0;x=0;\n\twhile(!isdigit(c)) f|=c=='-',c=getchar();\n\twhile(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\tif(f) x=-x;return x;\n}\ntemplate<class t,class ...A> inline void read(t &x,A &...a){\n\tread(x);read(a...);\n}\ntemplate<class t> inline void write(t x){\n\tif(x<0) putchar('-'),write(-x);\n\telse{if(x>9) write(x/10);putchar('0'+x%10);}\n}\n\n#define int long long\n\nconst int mod=998244353,N=3e6+5;\nint n,m,fac[N],inv[N],ans;\n\nint fpow(int x,int y){\n\tint res=1;\n\tfor(;y;y>>=1,x=x*x%mod) if(y&1) res=res*x%mod;\n\treturn res;\n}\n\nint C(int n,int m){\n\tif(n<m||m<0) return 0;\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\n\nint calc(int m){\n\treturn C(n+m-1,n-1);\n}\n\nvoid init(int n){\n\tfac[0]=1;for(int i=1;i<=n;i++) fac[i]=fac[i-1]*i%mod;\n\tinv[n]=fpow(fac[n],mod-2);for(int i=n-1;~i;i--) inv[i]=inv[i+1]*(i+1)%mod;\n}\n\nsigned main(){\n\tread(n,m);\n\tinit(3e6);\n\tfor(int i=0;i<=n&&i<=m;i++) if(~i&1^m&1){\n\t\tans=(ans+C(n,i)*calc((3*m-i)/2))%mod;\n\t\tans=(ans-C(n-1,i)*n%mod*calc((m-i-2)/2))%mod;\n\t\tans=(ans-C(n-1,i-1)*n%mod*calc((m-i)/2))%mod;\n\t}\n\twrite((ans+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nconst ll mod = 998244353;\nll modpow(ll x,ll n){\n\tll res=1;\n\twhile(n>0){\n\t\tif(n&1) res=res*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nll F[3000005],R[3000005];\nvoid make(){\n\tF[0] = 1;\n\tfor(int i=1;i<3000005;i++) F[i] = F[i-1]*i%mod;\n\tR[3000004] = modpow(F[3000004],mod-2);\n\tfor(int i=3000003;i>=0;i--) R[i] = R[i+1]*(i+1)%mod;\n}\nll C(int a,int b){\n\treturn F[a]*R[b]%mod*R[a-b]%mod;\n}\n\nint main(){\n\tll n,m; cin >> n >> m;\n\tmake();\n\tll all = C(3*m+n-1,n-1);\n\tll ans = 0;\n\tans += n * C(m-1+n-1,n-1) % mod;\n\tans = all-ans;\n\t\n\tfor(int odd=0;odd<=m;odd++){\n\t\tif(odd > n) break;\n\t\tif(odd%2 != m%2) continue;\n\t\tll coef = C(n,odd);\n\t\tll zan = (3*m-odd)/2;\n\t\tans += coef * C(zan+n-1,n-1) % mod;\n\t}\n\tans -= all;\n\tcout << (ans%mod+mod)%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<(n); ++i)\n#define rrep(i,n) for(int i=1; i<=(n); ++i)\n#define drep(i,n) for(int i=(n)-1; i>=0; --i)\n#define foreach(it, v) for(typeof(v.begin()) it=v.begin(); it!=v.end(); ++it)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define fi first\n#define se second\n\ntypedef unsigned int uint;\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpii;\ntypedef set<int> si;\n\n\nconst int MAX = 1010000;\nconst int MOD = 998244353;\n\nll fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nll COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\n\n\n\n\n\nint N, M;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  // 前処理\n  COMinit();\n\n  cin >> N >> M;\n\n  ll ans = 0;\n  for (int n=M%2; n<=M; n += 2) {\n    int D = (M * 3 - n) / 2;\n    ll a1 = COM(N, n) * COM(N+D-1, N-1) % MOD;\n    ll b1 = N * (COM(N-1, n-1) * COM(N+D-M-1, N-1) % MOD) % MOD;\n    ll b2 = N * (COM(N-1, n) * COM(N+D-M-2, N-1) % MOD) % MOD;\n    ans = (ans + a1 - b1 - b2 + MOD*2) % MOD;\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string>\n#include <cstring>\n#include <stdlib.h>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <list>\n#include <iterator>\n#include <assert.h>\n#pragma warning(disable:4996) \n \ntypedef long long ll;\n#define MIN(a, b) ((a)>(b)? (b): (a))\n#define MAX(a, b) ((a)<(b)? (b): (a))\n#define LINF 9223300000000000000\n#define INF 2140000000\nconst long long MOD = 998244353; //1000000007;\nusing namespace std;\n\n\nconst int max_comb=3000000;\nvector<ll> fac(max_comb+1); //n! (mod M)\nvector<ll> ifac(max_comb+1); //k!^(-1) (mod M)\n\nll mpow(ll x, ll n){ //x^n(mod M)\n    ll ans = 1;\n    while(n != 0){\n        if(n&1) ans = ans*x % MOD;\n        x = x*x % MOD;\n        n = n >> 1;\n    }\n    return ans;\n}\n\nll minv(ll x){\n    return mpow( x, MOD-2 );\n}\n\nll comb(int a, int b){     // C(a,b) = a! * b!^(-1) * (a-b)^(-1)\n    if(a == 0 && b == 0)return 1;\n    if(a < b || a < 0)return 0;\n    ll tmp = ifac[a-b]* ifac[b] % MOD;\n    return tmp * fac[a] % MOD;\n}\n\nll perm(int a, int b){     // P(a,b) = a! * (a-b)!^(-1)\n    if(b == 0)return 1;\n    if(a < b || a < 0)return 0;\n    ll tmp = ifac[a-b] % MOD;\n    return tmp * fac[a] % MOD;\n}\n\nvoid pre_comb()\n{\n    fac[0] = 1;\n    ifac[0] = 1;\n    for(int i = 0; i<max_comb; i++){\n        fac[i+1] = fac[i]*(i+1) % MOD; // n!(mod M)\n        ifac[i+1] = ifac[i]*minv(i+1) % MOD; // k!^(-1) (mod M)\n    }\n    return;\n}\n\nint main(int argc, char* argv[])\n{\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n\n    pre_comb();\n\n    ll ans0 = comb( m*3+n-1, m*3 );\n\n    ll ans1 = 0;\n    int i;\n    for(i=m*2+1; i<=m*3; i++) {\n        int j = m*3-i;\n        ll tmp = comb( j+n-2, j );\n        ans1 = (ans1 + tmp)%MOD;\n    }\n    ans1 = ans1 * n %MOD;\n    ll ans = (ans0 - ans1 + MOD)%MOD;\n\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<stack>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<cstring>\n#include<complex>\n#include<bitset>\n#include<iostream>\nusing namespace std;\n\n/**** Type Define ****/\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> Q;\ntypedef complex<double> C;\n\n/**** Macro Define ****/\n\n#define cx real()\n#define cy imag()\n\n/**** Const List   ****/\n\nconst ll INF = 1LL << 60;\nconst double DINF = 1e30;\nconst ll mod = 998244353;\nconst ll MAX_FLOW_MAX_V = 10000;\nconst ll MIN_COST_FLOW_MAX_V = 10000;\nconst ll BIPARTITE_MATCHING_MAX_V = 10000;\nconst ll dx[4] = {1, 0, -1, 0};\nconst ll dy[4] = {0, -1, 0, 1};\nconst C I = C(0, 1);\nconst double EPS = 1e-10;\n//const ll NCK_MAX = 3100000;\nconst ll NCK_MAX = 510000;\n\n/**** General Functions ****/\n\ntemplate <typename T>\nT tmin(T a, T b) { return a > b ? b : a; };\n\ntemplate <typename T>\nT tmax(T a, T b) { return a > b ? a : b; };\n\ntemplate <typename T>\nT tadd(T a, T b) { return a + b; };\n\ntemplate <typename T>\nT tmul(T a, T b) { return a * b; };\n\ntemplate <typename T>\nT tpow(T a, T b) { return a * b; };\n\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y) {\n  if (b == 0) {\n    x = 1, y = 0; return a;\n  }\n  ll q = a/b, g = extgcd(b, a - q*b, x, y);\n  ll z = x - q * y;\n  x = y;\n  y = z;\n  return g;\n}\n\nll invmod (ll a, ll m) { // a^-1 mod m\n  ll x, y;\n  extgcd(a, m, x, y);\n  x %= m;\n  if (x < 0) x += m;\n  return x;\n}\n\nll *fac, *finv, *inv;\n\nvoid nCk_init(ll mod) {\n  fac = new ll[NCK_MAX];\n  finv = new ll[NCK_MAX];\n  inv = new ll[NCK_MAX];\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (ll i = 2; i < NCK_MAX; i++) {\n    fac[i] = fac[i-1] * i % mod;\n    inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n    finv[i] = finv[i-1] * inv[i] % mod;\n  }\n}\n\nll nCk(ll n, ll k, ll mod) {\n  if (fac == NULL) nCk_init(mod);\n  if (n < k) return 0;\n  if (n < 0 || k < 0) return 0;\n  return fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\nll lmin(ll a, ll b) { return a > b ? b : a; };\n\nll lmax(ll a, ll b) { return a > b ? a : b; };\n\nll lsum(ll a, ll b) { return a + b; };\n\n/**** Matrix ****/\n\ntemplate <typename T>\nstruct Matrix {\n  typedef vector<T> vec;\n  typedef vector<vec> mat;\n  ll x, y; // x: horizon  y: vertical\n  mat d;\n\n  Matrix(ll _y, ll _x = -1) {\n    if (_x == -1) _x = _y;\n    x = _x, y = _y;\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) d[i][j] = 0;\n  }\n  void unit() {\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) d[i][j] = i == j ? 1 : 0;\n  }\n  Matrix copy() {\n    Matrix m(y, x);\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) m.d[i][j] = d[i][j];\n    return m;\n  }\n  Matrix<T> operator + (Matrix<T>& t) { // No error check! Don't forget to check Matrix size!!\n    Matrix<T> m(y, x);\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) m.d[i][j] = d[i][j] + t.d[i][j];\n    return m;\n  }\n  Matrix<T> operator - (Matrix<T>& t) {\n    Matrix<T> m(y, x);\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) m.d[i][j] = d[i][j] - t.d[i][j];\n    return m;\n  }\n  Matrix<T> operator * (T t) {\n    Matrix<T> m(y, x);\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) m.d[i][j] = d[i][j] * t;\n    return m;\n  }\n  Matrix<T> det(Matrix<T>& t) { // x need to correspond to t.y\n    Matrix<T> m(y, x);\n    for (int i = 0; i < y; i++)\n      for (int j = 0; j < x; j++)\n        for (int k = 0; k < t.x; k++) m.d[i][j] += d[i][k] * t.d[k][j]; ////////////// mod???\n    return m;\n  }\n};\n\n/**** Zip ****/\n\ntemplate <typename T>\nclass Zip {\n  vector<T> d;\n  bool flag;\npublic:\n  Zip() {\n    flag = false;\n  }\n  void add(T x) {\n    d.push_back(x);\n    flag = true;\n  }\n  ll getNum(T x) { // T need to have operator < !!\n    if (flag) {\n      sort(d.begin(), d.end());\n      d.erase(unique(d.begin(), d.end()), d.end());\n      flag = false;\n    }\n    return lower_bound(d.begin(), d.end(), x) - d.begin();\n  }\n  ll size() {\n    if (flag) {\n      sort(d.begin(), d.end());\n      d.erase(unique(d.begin(), d.end()), d.end());\n      flag = false;\n    }\n    return (ll)d.size();\n  }\n};\n\n/**** Union Find ****/\n\nclass UnionFind {\n  vector<ll> par, rank; // par > 0: number, par < 0: -par\npublic:\n  void init(ll n) {\n    par.resize(n, 1); rank.resize(n, 0);\n  }\n  ll getSize(ll x) {\n    return par[find(x)];\n  }\n  ll find(ll x) {\n    if (par[x] > 0) return x;\n    return -(par[x] = -find(-par[x]));\n  }\n  void merge(ll x, ll y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (rank[x] < rank[y]) {\n      par[y] += par[x];\n      par[x] = -y;\n    } else {\n      par[x] += par[y];\n      par[y] = -x;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n  }\n  bool isSame(ll x, ll y) {\n    return find(x) == find(y);\n  }\n};\n\ntemplate <typename T>\nstruct UnionFindT {\n  vector<ll> par;\n  vector<ll> rank;\n  vector<T> diff_weight;\n\n  UnionFindT(ll n = 1, T SUM_UNITY = 0) {\n    init(n, SUM_UNITY);\n  }\n\n  void init(ll n = 1, T SUM_UNITY = 0) {\n    par.resize(n); rank.resize(n); diff_weight.resize(n);\n    for (ll i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n  }\n\n  ll find(ll x) {\n    if (par[x] == x) {\n      return x;\n    }\n    else {\n      ll r = find(par[x]);\n        diff_weight[x] += diff_weight[par[x]];\n        return par[x] = r;\n    }\n  }\n\n  T weight(ll x) {\n    find(x);\n    return diff_weight[x];\n  }\n\n  bool isSame(ll x, ll y) {\n    return find(x) == find(y);\n  }\n\n  bool merge(ll x, ll y, T w) {\n    w += weight(x); w -= weight(y);\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (rank[x] < rank[y]) swap(x, y), w = -w;\n    if (rank[x] == rank[y]) ++rank[x];\n    par[y] = x;\n    diff_weight[y] = w;\n    return true;\n  }\n\n  T diff(ll x, ll y) {\n    return weight(y) - weight(x);\n  }\n};\n\nclass PersistentUnionFind {\n  vector<ll> rank, fin, par;\n  ll index;\npublic:\n  void init(ll n) {\n    index = 0;\n    par.resize(n); rank.resize(n, 1); fin.resize(n, 0);\n    for (ll i = 0; i < n; i++) par[i] = i;\n  }\n  ll find(ll x, ll t) {\n    if (t >= fin[x] && par[x] != x) return find(par[x], t);\n    return x;\n  }\n  void merge(ll x, ll y) {\n    x = find(x, index);\n    y = find(y, index);\n    index++;\n    if (x == y) return;\n    if (rank[x] < rank[y]) par[x] = y, fin[x] = index;\n    else {\n      par[y] = x, fin[y] = index;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n  }\n  bool isSame(ll x, ll y, ll t) { return find(x, t) == find(y, t); }\n};\n\n/**** Segment Tree ****/\n\ntemplate <typename T>\nclass SegmentTree {\n  ll n;\n  vector<T> node;\n  function<T(T, T)> fun, fun2;\n  bool customChange;\n  T outValue, initValue;\npublic:\n  void init(ll num, function<T(T, T)> resultFunction, T init, T out, function<T(T, T)> changeFunction = NULL) {\n    // changeFunction: (input, beforevalue) => newvalue\n    fun = resultFunction;\n    fun2 = changeFunction;\n    customChange = changeFunction != NULL;\n    n = 1;\n    while (n < num) n *= 2;\n    node.resize(2 * n - 1, init);\n    outValue = out;\n    initValue = init;\n  }\n  void valueChange(ll num, T value) {\n    num += n-1;\n    if (customChange) node[num] = fun2(value, node[num]);\n    else node[num] = value;\n    while (num > 0) num = (num - 1) / 2, node[num] = fun(node[num * 2 + 1], node[num * 2 + 2]);\n  }\n  T rangeQuery(ll a, ll b, ll l = 0, ll r = -1, ll k = 0) { // [a, b)\n    if (r == -1) r = n;\n    if (a <= l && r <= b) return node[k];\n    if (b <= l || r <= a) return outValue;\n    ll mid = (l + r) / 2;\n    return fun(rangeQuery(a, b, l, mid, 2*k+1), rangeQuery(a, b, mid, r, 2*k+2));\n  }\n};\n\ntemplate <typename T>\nclass LazySegmentTree {\n  ll n;\n  vector<T> node;\n  vector<T> lazyNode;\n  function<T(T, T)> fun, fun2;\n  function<T(T, ll)> fun3;\n  T outValue, initValue;\n  T substitution(T a, T b) { return a; }\n  void eval(ll k, ll l, ll r) {\n    if (lazyNode[k] == 0) return;\n    node[k] = fun2(fun3(lazyNode[k], r - l), node[k]);\n    if (r - l > 1) {\n      lazyNode[2 * k + 1] = fun2(lazyNode[k], lazyNode[2 * k + 1]);\n      lazyNode[2 * k + 2] = fun2(lazyNode[k], lazyNode[2 * k + 2]);\n    }\n    lazyNode[k] = initValue;\n  }\npublic:\n  void init(ll num, function<T(T, T)> resultFunction, function<T(T, T)> changeFunction, function<T(T, ll)> lazyFunction, T init, T out) {\n    // changeFunction: (input, beforevalue) => newvalue\n    // lazyFunction: (lazyNode, diff) => newvalue\n    fun = resultFunction;\n    fun2 = changeFunction;\n    fun3 = lazyFunction;\n    n = 1;\n    while (n < num) n *= 2;\n    node.resize(2 * n - 1, init);\n    lazyNode.resize(2 * n - 1, init);\n    outValue = out;\n    initValue = init;\n  }\n  void rangeChange(ll a, ll b, T value, ll l = 0, ll r = -1, ll k = 0) {\n    if (r == -1) r = n;\n    eval(k, l, r);\n    if (b <= l || r <= a) return;\n    if (a <= l && r <= b) {\n      lazyNode[k] = fun2(value, lazyNode[k]);\n      eval(k, l, r);\n    } else {\n      ll mid = (l + r) / 2;\n      rangeChange(a, b, value, l, mid, 2*k+1);\n      rangeChange(a, b, value, mid, r, 2*k+2);\n      node[k] = fun(node[2*k+1], node[2*k+2]);\n    }\n  }\n  T rangeQuery(ll a, ll b, ll l = 0, ll r = -1, ll k = 0) { // [a, b)\n    if (r == -1) r = n;\n    if (b <= l || r <= a) return outValue;\n    eval(k, l, r);\n    if (a <= l && r <= b) return node[k];\n    ll mid = (l + r) / 2;\n    return fun(rangeQuery(a, b, l, mid, 2*k+1), rangeQuery(a, b, mid, r, 2*k+2));\n  }\n};\n\n/**** Network Flow ****/\n\nclass MaxFlow {\npublic:\n  struct edge { ll to, cap, rev; };\n\n  vector<edge> G[MAX_FLOW_MAX_V];\n  bool used[MAX_FLOW_MAX_V];\n  ll level[MAX_FLOW_MAX_V];\n  ll iter[MAX_FLOW_MAX_V];\n  \n  void init() {\n    for (ll i = 0; i < MAX_FLOW_MAX_V; i++) {\n      G[i].clear();\n    }\n  }\n  void add_edge(ll from, ll to, ll cap) {\n    G[from].push_back((edge){to, cap, (ll)G[to].size()});\n    G[to].push_back((edge){from, 0, (ll)G[from].size() - 1});\n  }\n  void add_undirected_edge(ll e1, ll e2, ll cap) {\n    G[e1].push_back((edge){e2, cap, (ll)G[e2].size()});\n    G[e2].push_back((edge){e1, cap, (ll)G[e1].size() - 1});\n  }\n  ll dfs(ll v, ll t, ll f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (ll i = 0; i < (ll)G[v].size(); i++) {\n      edge &e = G[v][i];\n      if (!used[e.to]&& e.cap > 0) {\n        ll d = dfs(e.to, t, min(f, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  ll max_flow(ll s, ll t) {\n    ll flow = 0;\n    while (1) {\n      memset(used, 0, sizeof(used));\n      ll f = dfs(s, t, INF);\n      if (f == 0) return flow;\n      flow += f;\n    }\n  }\n  void bfs(ll s) {\n    memset(level, -1, sizeof(level));\n    queue<ll> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n      ll v = que.front(); que.pop();\n      for (ll i = 0; i < (ll)G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[e.to] < 0) {\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n  ll dinic_dfs(ll v, ll t, ll f) {\n    if (v == t) return f;\n    for (ll &i= iter[v]; i < (ll)G[v].size(); i++) {\n      edge &e = G[v][i];\n      if (e.cap > 0 && level[v] < level[e.to]) {\n        ll d = dinic_dfs(e.to, t, min(f, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  ll dinic(ll s, ll t) {\n    ll flow = 0;\n    while (1) {\n      bfs(s);\n      if (level[t] < 0) return flow;\n      memset(iter, 0, sizeof(iter));\n      ll f;\n      while ((f = dinic_dfs(s, t, INF)) > 0) {\n        flow += f;\n      }\n    }\n  }\n};\n\n/**** bipartite matching ****/\n\nclass BipartiteMatching {\n  vector<ll> pre, root;\n  vector<vector<ll>> to;\n  vector<ll> p, q;\n  ll n, m;\npublic:\n  BipartiteMatching(ll n, ll m):pre(n,-1),root(n,-1),to(n),p(n,-1),q(m,-1),n(n),m(m){}\n  void add(ll a, ll b) { to[a].push_back(b);}\n  ll solve() {\n    ll res = 0;\n    bool upd = true;\n    while (upd) {\n      upd = false;\n      queue<ll> s;\n      for (ll i = 0; i < n; ++i) {\n        if (!~p[i]) {\n          root[i] = i;\n          s.push(i);\n        }\n      }\n      while (!s.empty()) {\n        ll v = s.front(); s.pop();\n        if (~p[root[v]]) continue;\n        for (ll i = 0; i < (ll)to[v].size(); ++i) {\n          ll u = to[v][i];\n          if (!~q[u]) {\n            while (~u) {\n              q[u] = v;\n              swap(p[v],u);\n              v = pre[v];\n            }\n            upd = true;\n            ++res;\n            break;\n          }\n          u = q[u];\n          if (~pre[u]) continue;\n          pre[u] = v; root[u] = root[v];\n          s.push(u);\n        }\n      }\n      if (upd) fill(pre.begin(),pre.end(),-1), fill(root.begin(),root.end(),-1);\n    }\n    return res;\n  }\n};\n\nclass MinCostFlow {\npublic:\n  struct edge { ll to, cap, cost, rev; };\n\n  ll V;\n  vector<edge> G[MIN_COST_FLOW_MAX_V];\n  ll dist[MIN_COST_FLOW_MAX_V];\n  ll prevv[MIN_COST_FLOW_MAX_V];\n  ll preve[MIN_COST_FLOW_MAX_V];\n  ll h[MIN_COST_FLOW_MAX_V];\n\n  MinCostFlow(ll v) {\n    V = v;\n  }\n  void init() {\n    for (ll i = 0; i < MAX_FLOW_MAX_V; i++) {\n      G[i].clear();\n    }\n  }\n  void add_edge(ll from, ll to, ll cap, ll cost) {\n    G[from].push_back((edge){to, cap, cost, (ll)G[to].size()});\n    G[to].push_back((edge){from, 0, -cost, (ll)G[from].size() - 1});\n  }\n  void add_undirected_edge(ll e1, ll e2, ll cap, ll cost) {\n    add_edge(e1, e2, cap, cost);\n    add_edge(e2, e1, cap, cost);\n  }\n  ll min_cost_flow(ll s, ll t, ll f) { // minas\n    ll res = 0;\n    while (f > 0) {\n      fill(dist, dist + V, INF);\n      dist[s] = 0;\n      bool update = true;\n      while (update) {\n        update = false;\n        for (ll v = 0; v < V; v++) {\n          if (dist[v] == INF) continue;\n          for (ll i = 0; i < (ll)G[v].size(); i++) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n              dist[e.to] = dist[v] + e.cost;\n              prevv[e.to] = v;\n              preve[e.to] = i;\n              update = true;\n            }\n          }\n        }\n      }\n      if (dist[t] == INF) {\n        return -1;\n      }\n      ll d = f;\n      for (ll v = t; v != s; v = prevv[v]) {\n        d = min(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * dist[t];\n      for (ll v = t; v != s; v = prevv[v]) {\n        edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n  ll min_cost_flow_dijkstra(ll s, ll t, ll f) {\n    ll res = 0;\n    fill(h, h + V, 0);\n    while (f > 0) {\n      priority_queue<P, vector<P>, greater<P> > que;\n      fill(dist, dist + V, 0);\n      dist[s] = 0;\n      que.push(P(0, s));\n      while (!que.empty()) {\n        P p = que.top(); que.pop();\n        int v = p.second;\n        if (dist[v] < p.first) continue;\n        for (int i = 0; i < G[v].size(); i++) {\n          edge &e = G[v][i];\n          if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n            dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            que.push(P(dist[e.to], e.to));\n          }\n        }\n      }\n      if (dist[t] == INF) {\n        return -1;\n      }\n      for (int v = 0; v < V; v++) h[v] += dist[v];\n      int d = f;\n      for (int v = t; v != s; v = prevv[v]) {\n        d = tmin<ll>(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * h[t];\n      for (int v = t; v != s; v = prevv[v]) {\n        edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n      return res;\n    }\n    return 0;\n  }\n};\n\n/**** LIS ****/\nll lis(ll* a, ll n, ll* dp) {\n  fill(dp, dp + n, INF);\n  for (ll i = 0; i < n; i++) *lower_bound(dp, dp + n, a[i]) = a[i];\n  return (ll)(lower_bound(dp, dp + n, INF) - dp);\n}\n\n/**** Binary Search ****/\n\nll binarySearch(function<bool(ll)> check, ll ok, ll ng) {\n  while ((ok - ng > 1) || (ng - ok > 1)) {\n    ll mid = (ok + ng) / 2;\n    if (check(mid)) ok = mid;\n    else ng = mid;\n  }\n  return ok;\n}\n\ndouble binarySearchDouble(function<bool(double)> check, double ok, double ng) {\n  while ((ok - ng > EPS) || (ng - ok > EPS)) {\n    double mid = (ok + ng) / 2;\n    if (check(mid)) ok = mid;\n    else ng = mid;\n  }\n  return ok;\n}\n\n/**** Geometry ****/\n\nbool isEqual(double a, double b) { return abs(a - b) < EPS; }\nbool isCEqual(C a, C b) { return isEqual(a.cx, b.cx) && isEqual(a.cy, b.cy); }\nbool isZero(double a) { return abs(a) < EPS; } // a == 0\nbool isUZero(double a) { return a > EPS; } // a > 0\nbool isUEZero(double a) { return a > -EPS; } // a >= 0\nbool isLZero(double a) { return a < -EPS; } // a < 0\nbool isLEZero(double a) { return a < EPS; } // a <= 0\nC getUnitVector(C a) { double len = abs(a); return isZero(len) ? C(0.0, 0.0) : a / len; }\ndouble dot(C a, C b) { return a.cx * b.cx + a.cy * b.cy; } // |a||b|cosθ\ndouble det(C a, C b) { return a.cx * b.cy - a.cy * b.cx; } // |a||b|sinθ\nbool isLineOrthogonal(C a1, C a2, C b1, C b2) { return isZero(dot(a1 - a2, b1 - b2)); } // a1-a2, b1-b2\nbool isLineParallel(C a1, C a2, C b1, C b2) { return isZero(det(a1 - a2, b1 - b2)); } // a1-a2, b1-b2\nbool isPointOnLine(C a, C b, C c) { return isZero(det(b - a, c - a)); } // a-b <- c\n/*\nbool isPointOnLineSegment(C a, C b, C c) { // a-b <- c\n  return isZero(det(b - a, c - a)) && isUEZero(dot(b - a, c - a)) && isUEZero(dot(a - b, c - b));\n}\n*/\nbool isPointOnLineSegment(C a, C b, C c) { return isZero(abs(a-c) + abs(c-b) - abs(a-b)); }\ndouble distanceLineAndPoint(C a, C b, C c) { return abs(det(b-a, c-a)) / abs(b-a); } // a-b <- c\ndouble distanceLineSegmentAndPoint(C a, C b, C c) { // a-b <- c\n  if (isLEZero(dot(b-a, c-a))) return abs(c-a);\n  if (isLEZero(dot(a-b, c-b))) return abs(c-b);\n  return abs(det(b-a, c-a)) / abs(b-a);\n}\nbool isIntersectedLine(C a1, C a2, C b1, C b2) { // a1-a2, b1-b2\n  return !isLineParallel(a1, a2, b1, b2);\n}\nC intersectionLine(C a1, C a2, C b1, C b2) { // isIntersectedLine-> true\n  C a = a2 - a1, b = b2 - b1;\n  return a1 + a * det(b, b1 - a1) / det(b, a);\n}\nbool comp_C(const C& c1, const C& c2) {\n  if (c1.cx != c2.cx) return c1.cx < c2.cx;\n  return c1.cy < c2.cy;\n}\nvector<C> convex_hull(C* ps, ll n) {\n  sort(ps, ps+n, comp_C);\n  ll k = 0;\n  vector<C> qs(n*2);\n  for (ll i = 0; i < n; i++) {\n    while (k > 1 && det((qs[k-1] - qs[k-2]), (ps[i] - qs[k-1])) <= EPS) k--;\n    qs[k++] = ps[i];\n  }\n  for (ll i = n-2, t = k; i >= 0; i--) {\n    while (k > t && det((qs[k-1] - qs[k-2]), (ps[i] - qs[k-1])) <= EPS) k--;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\n/**** main function ****/\n\nll n, m, ans;\n\nint main() {\n  scanf(\"%lld%lld\", &n, &m);\n  ans = nCk(3*m+n-1, n-1, mod);\n  //for (ll i = 1; i <= m; i++) ans = (ans - nCk(m-i+n-2, n-2, mod) * n % mod + mod) % mod;\n  ans = (ans - (nCk(m+n-2, n-1, mod) * n) % mod + mod) % mod;\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\nusing vll = std::vector<ll>;\nusing vvll = std::vector<vll>;\nusing vvvll = std::vector<vvll>;\nusing dd = double;\nusing vdd = std::vector<dd>;\nusing vvdd = std::vector<vdd>;\nusing vvvdd = std::vector<vvdd>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, N-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, N-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S, ll E){ T s=v[S]; REPS(i, S+1, E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = 998244353LL;// 998244353LL;//(ll)(1e9 + 7);\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\n\n\nvoid solve()\n{\n\tll N, M;\n\tcin >> N >> M;\n\n\t//予め階乗を計算\n\tvmll kj(3*M+N+10);\n\tkj[0] = 1;\n\tREPS(i, 1, 3*M+N+9){\n\t\tkj[i] = kj[i-1] * i;\n\t}\n\n\tauto C = [&](ll a, ll b)->mll{\n\t\treturn kj[a] / (kj[b] * kj[a-b]);\n\t};\n\n\t//全数\n\tmll ans = C(3*M+N-1, 3*M);\n\n\t//NG1パターン目\n\tans -= C(M-1+N-1, M-1) * N;\n\n\t//NG2パターン目\n\tfor (ll k=M+2; k<=N; k+=2){\n\t\tll r = (3*M-k)/2;\n\t\tif (r < 0) break;\n\t\tans -= C(N, k) * C(r+N-1, r);\n\t}\n\tcout << ans << '\\n';\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nЗАПУСКАЕМ\n░ГУСЯ░▄▀▀▀▄░РАБОТЯГУ░░\n▄███▀░◐░░░▌░░░░░░░\n░░░░▌░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▌░░░░░▐▄▄░░░░░\n░░░░▌░░░░▄▀▒▒▀▀▀▀▄\n░░░▐░░░░▐▒▒▒▒▒▒▒▒▀▀▄\n░░░▐░░░░▐▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░▀▄░░░░▀▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░░░▀▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▀▄\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░▄▄▌▌▄▌▌░░░░░\n */\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <random>\n\nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left224\n#define right right224\n#define next next224\n#define rank rank224\n#define prev prev224\n#define y1 y1224\n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define files(FILENAME) read(FILENAME), write(FILENAME)\n#define pb push_back\n#define mp make_pair\nconst string FILENAME = \"input\";\nconst int MAXN = 3000228;\nconst int Mod = 998244353;\n\n\nint mul(int a, int b) {\n    return (1LL * a * b) % Mod;\n}\n\n\nint sum(int a, int b) {\n    return (a + b) % Mod;\n}\n\n\nint powm(int a, int b) {\n    int res = 1;\n    while (b) {\n        if (b & 1) {\n            res = mul(res, a);\n        }\n        b >>= 1;\n        a = mul(a, a);\n    }\n    return res;\n}\n\nint n, m;\nint fact[MAXN];\nint rfact[MAXN];\n\nint getc(int i, int j) {\n    return mul(fact[i], mul(rfact[j], rfact[i - j]));\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    //read(FILENAME);\n    cin >> n >> m;\n    fact[0] = 1;\n    for (int i = 1; i <= 3000000; i++) {\n        fact[i] = mul(fact[i - 1], i);\n    }\n    rfact[3000000] = powm(fact[3000000], Mod - 2);\n    for (int i = 2999999; i >= 0; i--) {\n        rfact[i] = mul(rfact[i + 1], i + 1);\n    }\n   // n + 3 * m, n - 1\n    int ans = getc(n + 3 * m - 1, n - 1);\n    //cout << ans << endl;\n    for (int value = 2 * m + 1; value <= 3 * m; value++) {\n        int f = getc(n + 3 * m - value - 2, n - 2);\n        f = mul(f, n);\n        ans = sum(ans, Mod - f);\n    }\n    for (int cntodd = m + 1; cntodd <= n; cntodd++) {\n        int f = getc(n, cntodd);\n        int rest = 3 * m - cntodd;\n        if (rest % 2 != 0) {\n            continue;\n        }\n        int have = rest / 2;\n        f = mul(f, getc(have + n - 1, n - 1));\n        ans = sum(ans, Mod - f);\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconstexpr int mod = 998244353;\n\ntemplate <typename T, T mod>\nclass ModuloCombination {\n private:\n  std::vector<T> factrial, inverse_factrial;\n  T Pow(T x, T y) {\n    if (y == 0) return 1;\n    if (y % 2 == 0) return Pow(x * x % mod, y / 2);\n    return x * Pow(x, y - 1) % mod;\n  }\n\n public:\n  ModuloCombination(T n) : factrial(n + 1), inverse_factrial(n + 1) {\n    inverse_factrial[0] = factrial[0] = 1;\n    for (T i = 1; i <= n; i++) {\n      factrial[i] = factrial[i - 1] * i % mod;\n      inverse_factrial[i] = Pow(factrial[i], mod - 2);\n    }\n  }\n  T operator()(T n, T k) {\n    if (n < 0 || k < 0 || n < k) return 0;\n    return factrial[n] * inverse_factrial[k] % mod * inverse_factrial[n - k] % mod;\n  }\n};\n\nint main() {\n  ll n, m;\n  cin >> n >> m;\n\n  ModuloCombination<ll, mod> c(n + 2 * m);\n  vector<ll> s(m + 1);\n  for (int i = 1; i < s.size(); i++) s[i] = s[i - 1] + c(i + (n - 2), n - 2) % mod;\n\n  ll r = 0;\n  for (int i = 0; i <= m / 2; i++) {\n    ll t1 = c(m + i + (n - 1), n - 1);\n    t1 += mod - n * s[i] % mod;\n    t1 += mod - n * c(i + (n - 2), n - 2) % mod;\n    t1 %= mod;\n    t1 *= c(n, m - 2 * i);\n    t1 %= mod;\n    r += t1;\n    r %= mod;\n\n    ll t2 = n * c(i + (n - 2), n - 2) % mod;\n    t2 *= c(n - 1, m - 2 * i);\n    t2 %= mod;\n    r += t2;\n    r %= mod;\n  }\n  cout << r << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <array>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\ntemplate <uint32_t Modulus>\nclass modular {\npublic:\n  using value_type = uint32_t;\n  using max_type = uint64_t;\n\n  static constexpr value_type mod = Modulus;\n  static constexpr value_type mod_min = 1;\n  static constexpr value_type mod_max = 2147483647;\n  static_assert(mod >= mod_min, \"invalid mod :: too small\");\n  static_assert(mod <= mod_max, \"invalid mod :: too big\");\n\n  template <class T>\n  static constexpr value_type normalize(T value_) {\n    if (value_ < 0) {\n      value_ = -value_;\n      value_ %= mod;\n      if (value_ == 0) return 0;\n      return mod - value_;\n    }\n    return value_ % mod;\n  }\n\nprivate:\n  value_type value;\n\npublic:\n  constexpr modular(): value(0) { }\n  template <class T>\n  explicit constexpr modular(T value_): value(normalize(value_)) { }\n  template <class T>\n  explicit constexpr operator T() { return static_cast<T>(value); }\n\n  constexpr value_type operator () () const { return value; }\n  constexpr modular operator - () const { return modular(mod - value); }\n  constexpr modular operator ~ () const { return inverse(); }\n\n  constexpr value_type &extract() { return value; }\n  constexpr modular inverse() const { return power(mod - 2); }\n  constexpr modular power(max_type exp) const {\n    modular res(1), mult(*this);\n    while (exp > 0) {\n      if (exp & 1) res *= mult;\n      mult *= mult;\n      exp >>= 1;\n    }\n    return res;\n  }\n\n  constexpr modular operator + (const modular &rhs) const { return modular(*this) += rhs; }\n  constexpr modular& operator += (const modular &rhs) { \n    if ((value += rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator - (const modular &rhs) const { return modular(*this) -= rhs; }\n  constexpr modular& operator -= (const modular &rhs) { \n    if ((value += mod - rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator * (const modular &rhs) const { return modular(*this) *= rhs; }\n  constexpr modular& operator *= (const modular &rhs) { \n    value = (max_type) value * rhs.value % mod;\n    return *this;\n  }\n\n  constexpr modular operator / (const modular &rhs) const { return modular(*this) /= rhs; }\n  constexpr modular& operator /= (const modular &rhs) { return (*this) *= rhs.inverse(); }\n\n  constexpr bool zero() const { return value == 0; }\n  constexpr bool operator == (const modular &rhs) const { return value == rhs.value; }\n  constexpr bool operator != (const modular &rhs) const { return value != rhs.value; }\n  friend std::ostream& operator << (std::ostream &stream, const modular &rhs) {\n    return stream << rhs.value;\n  }\n\n};\n\ntemplate <class T>\nclass factorials {\npublic:\n  using value_type = T;\n\npublic:\n  std::vector<value_type> fact, fact_inv;\n\n  factorials(int size_ = 200000): fact(size_ + 1), fact_inv(size_ + 1) {\n    fact[0] = value_type(1);\n    for (int i = 1; i <= size_; ++i) {\n      fact[i] = fact[i - 1] * value_type(i);\n    }\n    fact_inv[size_] = ~fact[size_];\n    for (int i = size_; i > 0; --i) {\n      fact_inv[i - 1] = fact_inv[i] * value_type(i);\n    }\n  }\n\n  value_type operator () (int n, int r) const {\n    return fact[n] * fact_inv[n - r] * fact_inv[r];\n  }\n\n};\n\nusing modint = modular<998244353>;\nfactorials<modint> fact(1800000);\n\nmodint calc(int n, int k) {\n  if (n < 0 || k <= 0) {\n    return modint(0);\n  }\n  return fact(n + k - 1, n);\n}\n\nint main() {\n  int N, M;\n  std::cin >> N >> M;\n  modint ans;\n  for (int odd: range(0, std::min(N, M) + 1)) {\n    int sum = 3 * M - odd;\n    if (sum % 2 != 0) {\n      continue;\n    }\n    modint all;\n    all += calc(sum / 2, N);\n    all -= calc(sum / 2 - M, N) * modint(odd);\n    all -= calc(sum / 2 - M - 1, N) * modint(N - odd);\n    ans += all * fact(N, odd);\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<list>\n#include<set>\n#include<string>\n#include<math.h>\nusing namespace std;\nint gcd(int a, int b) {\n\tint c = a % b;\n\twhile (c != 0) {\n\t\ta = b;\n\t\tb = c;\n\t\tc = a % b;\n\t}\n\treturn b;\n}\nstruct UnionFind {\n\tvector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n\n\tUnionFind(int N) : par(N) { //最初は全てが根であるとして初期化\n\t\tfor (int i = 0; i < N; i++) par[i] = i;\n\t}\n\n\tint root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n\t\tif (par[x] == x) return x;\n\t\treturn par[x] = root(par[x]);\n\t}\n\n\tvoid unite(int x, int y) { // xとyの木を併合\n\t\tint rx = root(x); //xの根をrx\n\t\tint ry = root(y); //yの根をry\n\t\tif (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま\n\t\tpar[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n\t}\n\n\tbool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す\n\t\tint rx = root(x);\n\t\tint ry = root(y);\n\t\treturn rx == ry;\n\t}\n};\ntypedef long long ll;\n\nll M = 998244353;\n\nvector<ll> fac(2000001); //n!(mod M)\nvector<ll> ifac(2000001); //k!^{M-2} (mod M)\n\nll mpow(ll x, ll n) {\n\tll ans = 1;\n\twhile (n != 0) {\n\t\tif (n & 1) ans = ans * x % M;\n\t\tx = x * x % M;\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\nvoid setcomb() {\n\tfac[0] = 1;\n\tifac[0] = 1;\n\tfor (ll i = 0; i < 2000000; i++) {\n\t\tfac[i + 1] = fac[i] * (i + 1) % M; // n!(mod M)\n\t}\n  ifac[2000000]=mpow(fac[2000000],M-2);\n  for(i=2000000;i>0;i--)\n    ifac[i-1]=ifac[i]*i%M;\n}\t\nll comb(ll a, ll b) {\n\tif (a == 0 && b == 0)return 1;\n\tif (a < b || a < 0)return 0;\n\tll tmp = ifac[a - b] * ifac[b] % M;\n\treturn tmp * fac[a] % M;\n}\nll perm(ll a, ll b) {\n\tif (a == 0 && b == 0)return 1;\n\tif (a < b || a < 0)return 0;\n\treturn fac[a] * ifac[a - b] % M;\n}\n// mod. m での a の逆元 a^{-1} を計算する\nlong long modinv(long long a) {\n\tlong long b = M, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= M;\n\tif (u < 0) u += M;\n\treturn u;\n}\nvector<vector<ll>> mul(vector<vector<ll>> a, vector<vector<ll>> b, int n) {\n\tint i, j, k, t;\n\tvector<vector<ll>> c(n);\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tt = 0;\n\t\t\tfor (k = 0; k < n; k++)\n\t\t\t\tt = (t + a[i][k] * b[k][j] % M) % M;\n\t\t\tc[i].push_back(t);\n\t\t}\n\t}\n\treturn c;\n}\n\ntemplate< typename Monoid >\nstruct SegmentTree {\n\n\tint sz;\n\tvector< Monoid > seg;\n\n\tconst Monoid M1;\n\n\tSegmentTree(int n, const Monoid &M1) : M1(M1) {\n\t\tsz = 1;\n\t\twhile (sz < n) sz <<= 1;\n\t\tseg.assign(2 * sz, M1);\n\t}\n\n\tvoid set(int k, const Monoid &x) {\n\t\tseg[k + sz] = x;\n\t}\n\n\tvoid build() {\n\t\tfor (int k = sz - 1; k > 0; k--) {\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\tvoid update(int k, const Monoid &x) {\n\t\tk += sz;\n\t\tseg[k] = x;\n\t\twhile (k >>= 1) {\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\tMonoid query(int a, int b) {\n\t\tMonoid L = M1, R = M1;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n\t\t\tif (a & 1) L = f(L, seg[a++]);\n\t\t\tif (b & 1) R = f(seg[--b], R);\n\t\t}\n\t\treturn f(L, R);\n\t}\n\n\tMonoid value(const int &k) const {\n\t\treturn seg[k + sz];\n\t}\n\n\tMonoid f(Monoid a, Monoid b) {\n\t\treturn a + b;\n\t}\n};\n\nint main() {\n\tll n, m, i, ans = 0,p;\n\tcin >> n >> m;\n\tsetcomb();\n\tif (m % 2 == 0) {\n\t\tfor (i = 0; i <= m; i+=2) {\n\t\t\tans += comb(n, i)*comb(n - 1 + (3 * m - i) / 2, n - 1);\n\t\t\tans %= M;\n\t\t\tp = i * comb(n, i) % M*comb(n - 2 + (m - i) / 2, n - 2) % M;\n\t\t\tp += n * comb(n, i) % M*comb(n - 1 + (m - i - 2) / 2, n - 1) % M;\n\t\t\tp %= M;\n\t\t\tans -= p;\n\t\t\tans = (ans + M) % M;\n\t\t}\n\t}\n\telse {\n\t\tfor (i = 1; i <= m; i += 2) {\n\t\t\tans += comb(n, i)*comb(n - 1 + (3 * m - i) / 2, n - 1);\n\t\t\tans %= M;\n\t\t\tp = i * comb(n, i) % M*comb(n - 2 + (m - i) / 2, n - 2) % M;\n\t\t\tp += n * comb(n, i) % M*comb(n - 1 + (m - i - 2) / 2, n - 1) % M;\n\t\t\tp %= M;\n\t\t\tans -= p;\n\t\t\tans = (ans + M) % M;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n//#pragme GCC target(\"avx2\");\n//#pragma GCC target(\"avx,avx2,fma\")\n//#pragma GCC optimization (\"O3\")\n//#pragma GCC optimization (\"unroll-loops\")\n\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//#define int long long\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define pb push_back\n#define f first\n#define se second\n#define pll pair<ll, ll>\n#define pii pair<int, int>\n\nusing namespace std;\n//using namespace __gnu_pbds;\n\n/*\n\tst.insert(k);\n\tst.find_by_order(k); iterator on k-th from 0\n\tst.order_of_key(k); strictly more than k\n*/\n\n//typedef\n//tree<\n//  ll,\n//  null_type,\n//  less_equal<ll>,\n//  rb_tree_tag,\n//  tree_order_statistics_node_update>\n//ordered_set;\n\n\nconst int N = 4e5 + 19;\nconst int M = 2e6 + 19;\nconst int\n mod = 998244353;\nconst int inf = 2e9;\nconst int blocksz = 300;\nconst ll INF = 1e18;\n\n\ninline int modulo(int x) {x %= mod; return (x + mod) % mod; }\ninline int mult(int x, int y) { ll x1 = modulo(x), y1 = modulo(y); return (x1 * y1) % (ll)mod; }\ninline void add(int &x, int y) { x = modulo(x + y); }\ninline void Max(int &x, int y) { x = max(x, y); }\ninline void Min(int &x, int y) { x = min(x, y); }\n\n\nint n, m, ans = 0, fact[M];\n\n\nint pw(int x, int y) {\n\tif (y == 0)\n\t\treturn 1;\n\tint res;\n\tif (y % 2) {\n\t\tres = pw(x, y - 1);\n\t\treturn mult(res, x);\n\t} else {\n\t\tres = pw(x, y / 2);\n\t\treturn mult(res, res);\n\t}\n}\n\n\nint C(int n, int k) {\n\tif (n < k)\n\t\treturn 0;\n\tint t1, t2, t3;\n\tt1 = fact[n];\n\tt2 = pw(fact[k], mod - 2);\n\tt3 = pw(fact[n - k], mod - 2);\n\treturn mult(t1, mult(t2, t3));\n}\n\n\nint F(int n, int m, int i) {\n\tif ((m - i) % 2)\n\t\treturn 0;\n\treturn mult(C(n, i), C((m - i) / 2 + n - 1, n - 1));\n}\n\n\nint G(int n, int m, int i) {\n\treturn mult(n, modulo(F(n, m, i) - F(n - 1, m, i)));\n}\n\n\nvoid precalc() {\n\tfact[0] = 1;\n\tfor (int i = 1; i < M; i++)\n\t\tfact[i] = mult(fact[i - 1], i);\n}\n\n\nmain() {\n\tios_base::sync_with_stdio(NULL); cin.tie(NULL); cout.tie(NULL);\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tprecalc();\n\tcin >> n >> m;\n//\tcout << C(3, 1) << endl;\n//\tcout << F(2, 6, 2) << endl;\n\tfor (int i = 0; i <= min(n, m); i++)\n\t\tadd(ans, modulo(F(n, 3 * m, i) - G(n, m, i)));\n\tcout << ans;\t\n\treturn 0;\n}\n/*\n3 5\n1 3 2 1 3\n10 5 7\n3\n4 2 4\n1 3 1\n3 5 2\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include <cstddef>\n#include <cstdint>\n#include <iostream>\n#include <vector>\n\nnamespace n91 {\n\nusing i8 = std::int_fast8_t;\nusing i32 = std::int_fast32_t;\nusing i64 = std::int_fast64_t;\nusing u8 = std::uint_fast8_t;\nusing u32 = std::uint_fast32_t;\nusing u64 = std::uint_fast64_t;\nusing isize = std::ptrdiff_t;\nusing usize = std::size_t;\n\nconstexpr usize operator\"\" _z(unsigned long long x) noexcept {\n  return static_cast<usize>(x);\n}\n\nclass rep {\n  const usize f, l;\n\npublic:\n  class itr {\n    friend rep;\n    usize i;\n    constexpr itr(const usize x) noexcept : i(x) {}\n\n  public:\n    void operator++() noexcept { ++i; }\n    constexpr usize operator*() const noexcept { return i; }\n    constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n  };\n  constexpr rep(const usize first, const usize last) noexcept\n      : f(first), l(last) {}\n  constexpr itr begin() const noexcept { return itr(f); }\n  constexpr itr end() const noexcept { return itr(l); }\n};\nclass revrep {\n  const usize f, l;\n\npublic:\n  class itr {\n    friend revrep;\n    usize i;\n    constexpr itr(usize x) noexcept : i(x) {}\n\n  public:\n    void operator++() noexcept { --i; }\n    constexpr usize operator*() const noexcept { return i; }\n    constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n  };\n  constexpr revrep(usize first, usize last) noexcept : f(--first), l(--last) {}\n  constexpr itr begin() const noexcept { return itr(l); }\n  constexpr itr end() const noexcept { return itr(f); }\n};\ntemplate <class T> using vec_alias = std::vector<T>;\ntemplate <class T> auto md_vec(const usize n, const T &value) {\n  return std::vector<T>(n, value);\n}\ntemplate <class... Args> auto md_vec(const usize n, Args... args) {\n  return std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n}\ntemplate <class T> constexpr T difference(const T &a, const T &b) {\n  return a < b ? b - a : a - b;\n}\ntemplate <class T> T scan() {\n  T ret;\n  std::cin >> ret;\n  return ret;\n}\n\n} // namespace n91\n\n#include <cstdint>\n\nnamespace n91 {\n\nconstexpr std::uint_fast64_t totient(std::uint_fast64_t x) noexcept {\n  using u64 = std::uint_fast64_t;\n  u64 ret = x;\n  for (u64 i = static_cast<u64>(2); i * i <= x; ++i) {\n    if (x % i == static_cast<u64>(0)) {\n      ret -= ret / i;\n      x /= i;\n      while (x % i == static_cast<u64>(0)) {\n        x /= i;\n      }\n    }\n  }\n  if (x != static_cast<u64>(1)) {\n    ret -= ret / x;\n  }\n  return ret;\n}\n\ntemplate <std::uint_fast64_t Modulus,\n          std::uint_fast64_t InverseExp =\n              totient(Modulus) - static_cast<u64>(1)>\nclass modint {\n  using u64 = std::uint_fast64_t;\n\n  static_assert(Modulus < static_cast<u64>(1) << static_cast<u64>(32),\n                \"Modulus must be less than 2**32\");\n\n  u64 a;\n\n  constexpr modint &negate() noexcept {\n    if (a != static_cast<u64>(0)) {\n      a = Modulus - a;\n    }\n    return *this;\n  }\n\npublic:\n  constexpr modint(const u64 x = static_cast<u64>(0)) noexcept\n      : a(x % Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+() const noexcept { return modint(*this); }\n  constexpr modint operator-() const noexcept { return modint(*this).negate(); }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = InverseExp;\n    while (exp) {\n      if (exp % static_cast<u64>(2) != static_cast<u64>(0)) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= static_cast<u64>(2);\n    }\n    return *this;\n  }\n  constexpr bool operator==(const modint rhs) const noexcept {\n    return a == rhs.a;\n  }\n  constexpr bool operator!=(const modint rhs) const noexcept {\n    return a != rhs.a;\n  }\n};\n\n} // namespace n91\n\n#include <vector>\n\nnamespace n91 {\n\ntemplate <class T> class fact_binom {\npublic:\n  using value_type = T;\n  using container_type = std::vector<value_type>;\n  using size_type = typename container_type::size_type;\n\nprivate:\n  container_type factrial, inv_fact;\n\npublic:\n  fact_binom() : factrial(), inv_fact() {}\n  explicit fact_binom(const size_type n) : factrial(n + 1), inv_fact(n + 1) {\n    factrial[0] = static_cast<value_type>(1);\n    for (size_type i = 0; i != n; ++i) {\n      factrial[i + 1] = static_cast<value_type>(i + 1) * factrial[i];\n    }\n    inv_fact[n] = static_cast<value_type>(1) / factrial[n];\n    for (size_type i = n; i != 0; --i) {\n      inv_fact[i - 1] = inv_fact[i] * static_cast<value_type>(i);\n    }\n  }\n\n  value_type operator()(const size_type n, const size_type r) const {\n    return factrial[n] * inv_fact[r] * inv_fact[n - r];\n  }\n};\n\n} // namespace n91\n\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <set>\n#include <utility>\n\nnamespace n91 {\n\nvoid main_() {\n  using mint = modint<998244353>;\n  const usize n = scan<usize>();\n  const usize m = scan<usize>();\n  const fact_binom<mint> binom((n + m) * 4_z + 1_z);\n  const auto h = [&binom](const usize n, const usize m) {\n    return binom(n + m - 1_z, m);\n  };\n\n  mint ans;\n\n  const auto f = [&h, &binom](const usize n, const usize all,\n                              const usize odd_max) {\n    mint ret;\n    for (const auto odd : rep(0_z, odd_max + 1_z)) {\n      if (all < odd) {\n        break;\n      }\n      if ((all - odd) % 2_z == 1_z) {\n        continue;\n      }\n      const usize even = (all - odd) / 2_z;\n      ret += h(n, even) * binom(n, odd);\n    }\n    return ret;\n  };\n\n  ans += f(n, m * 3_z, m);\n\n  ans -= f(n - 1_z, m - 1_z, m - 1_z) * static_cast<mint>(n);\n\n  if (m >= 2_z)\n    ans -= f(n, m - 2_z, m) * static_cast<mint>(n);\n\n  std::cout << ans.value() << std::endl;\n}\n\n} // namespace n91\n\nint main() {\n  n91::main_();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define E \"\\n\"\n\nusing namespace std;\nconst long long MOD = 998244353;\n\nint  N, M;\nlong long dat[2000009];\n\nlong long quickpow(long long b, long long e)\n{\n\treturn e ? ((e & 1 ? b : 1)*quickpow((b*b) % MOD, e >> 1)) % MOD : 1;\n}\n\nlong long combi(int n, int m)\n{\n\tlong long retval = dat[n];\n\tretval = retval * quickpow(dat[n - m], MOD - 2);\n\tretval = retval % MOD;\n\tretval = retval * quickpow(dat[m], MOD - 2);\n\tretval = retval % MOD;\n\treturn retval;\n}\n\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> N >> M;\n\tdat[0] = 1;\n\tfor (int i = 1; i <= 2000009; i++) {\n\t\tdat[i] = dat[i - 1] * i;\n\t\tdat[i] = dat[i] % MOD;\n\t}\n\tint lb = min(N, M);\n\tlong long ans = 0, tmp;\n\tfor (int i = 0; i <= lb; i++) {\n\t\tif (3 * M - i >= 0 && (3 * M - i) % 2 == 0) {\n\t\t\ttmp = combi((3 * M - i) / 2 + N - 1, N - 1);\n\t\t\ttmp = tmp * combi(N, i);\n\t\t\ttmp = tmp % MOD;\n\t\t\tans += tmp;\n\t\t\tans = ans % MOD;\n\t\t}\n\t}\n\ttmp = combi(M + N - 1, N - 1);\n\ttmp = tmp + MOD - combi(M + N - 2, N - 2);\n\ttmp = tmp * N;\n\ttmp = tmp % MOD;\n\tans = ans + MOD - tmp;\n\tans = ans % MOD;\n\tcout << ans << E;\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cctype>\n#define il inline\n#define vd void\n#define rg register\n#define mn 2500005\n#define p 998244353\n#define rep(i,x,y) for(rg int i=x;i<=y;++i)\n#define drp(i,x,y) for(rg int i=x;i>=y;--i)\nusing namespace std;\nconst int Len=2333333;\nchar buf[Len],*p1=buf,*p2=buf,duf[Len],*q1=duf;\nil char gc(); il int rd(); il vd pc(char c); il vd rt(int x); il vd flush();\ntemplate<class T> il T Max(T a,T b){return a>b?a:b;}\ntemplate<class T> il T Min(T a,T b){return a<b?a:b;}\nint n,m,mm,r,ans,fac[mn],inv[mn];\nil int Pow(int a,int b){int ans=1; for(a%=p;b;b&1?ans=1ll*ans*a%p:0,a=1ll*a*a%p,b>>=1); return ans;}\nil int C(int n,int m){\n\tif(n<m) return 0;\n\treturn 1ll*fac[n]*inv[m]%p*inv[n-m]%p;\n}\nil vd Inc(int &a,int b){if((a+=b)>=p) a-=p;}\nil int Ic(int a,int b){return a+b>=p?a+b-p:a+b;}\nil int Dc(int a,int b){return a-b<0?a-b+p:a-b;}\nint main(){\n\tn=rd(),m=rd(),fac[0]=1,mm=3*m,r=mm+n;\n\trep(i,1,r) fac[i]=1ll*fac[i-1]*i%p;\n\tinv[r]=Pow(fac[r],p-2);\n\tdrp(i,r-1,0) inv[i]=1ll*inv[i+1]*(i+1)%p;\n\tdrp(i,Min(n,m),0) if(!((mm-i)&1)){\n\t\tint t=(mm-i)>>1;\n\t\tInc(ans,1ll*C(n,i)*Dc(C(t+n-1,n-1),Ic(1ll*(n-i)*C(t-(i+(m-i)/2*2+1)+n-1,n-1)%p,1ll*i*C(t-(i+(m-i)/2*2)+n-1,n-1)%p))%p);\n\t}\n\trt(ans);\n\treturn flush(),0;\n}\n\nil char gc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,Len,stdin),p1==p2)?-1:*p1++;}\nil int rd(){char c;\n\twhile(!isdigit(c=gc())&&c!='-');\n\tint f=c=='-'?c=gc(),1:0,x=c^48;\n\twhile(isdigit(c=gc())) x=((x+(x<<2))<<1)+(c^48);\n\treturn f?-x:x;\n}\nil vd pc(char c){q1==duf+Len&&fwrite(q1=duf,1,Len,stdout),*q1++=c;}\nil vd rt(int x){x<0?pc('-'),x=-x:0,pc((x>=10?rt(x/10),x%10:x)+48);}\nil vd flush(){fwrite(duf,1,q1-duf,stdout);}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 3000300;\nconst int mod = 998244353;\n\nvoid add(int &x, int y) {\n\tx += y;\n\tif (x >= mod) x -= mod;\n}\n\nvoid sub(int &x, int y) {\n\tx -= y;\n\tif (x < 0) x += mod;\n}\n\nint mul(int x, int y) {\n\treturn (long long) x * y % mod;\n}\n\nint pw(int x, int y) {\n\tint ans = 1;\n\tfor (; y > 0; y >>= 1, x = mul(x, x)) {\n\t\tif (y & 1) ans = mul(ans, x);\n\t} \n\treturn ans;\n}\n\nint fact[N];\nint ifact[N];\n\nint C(int n, int k) {\n\tif (n < k || k < 0) return 0;\n\treturn mul(fact[n], mul(ifact[k], ifact[n - k]));\n}\n\nvoid precalc() {\n\tfact[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tfact[i] = mul(fact[i - 1], i);\n\t}\t\t\n\tifact[N - 1] = pw(fact[N - 1], mod - 2);\n\tfor (int i = N - 1; i > 0; --i) {\n\t\tifact[i - 1] = mul(ifact[i], i);\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tprecalc();\n\tint n, m;\n\tcin >> n >> m;\n\tint ans = C(3 * m + n - 1, n - 1);\n\tsub(ans, mul(n, C(m - 1 + n - 1, n - 1)));\n\tfor (int i = m + 2; i <= n; ++i) {\n\t\tsub(ans, mul(C(n, i), C((3 * m - i) / 2 + n - 1, n - 1)));\n\t}\n\tcout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<ll,pll> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=998244353;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nll Pow(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nconst int M=4000005;\nll F[M];\n\nvoid Init(){\n\tF[0]=1;\n\tfor(int i=1;i<M;i++) F[i]=F[i-1]*i%mod;\n}\n\nll Div(ll n,ll m){\n\treturn n*Pow(m,mod-2)%mod;\n}\n\nll nCk(ll n,ll k){\n\treturn Div(F[n],F[n-k]*F[k]%mod);\n}\n\nll nHk(ll n,ll k){\n\treturn nCk(n+k-1,k);\n}\n\nint n,m;\n\nint main(){\n\tInit();\n\tcin>>n>>m;\n\tll res=nHk(n,3*m);\n\tfor(int i=m+1;i<=min(3*m,n);i++) if((3*m-i)%2==0) res=(res-nHk(n,(3*m-i)/2)*nCk(n,i)%mod+mod)%mod;\n\tfor(int i=2*m+1;i<=3*m;i++) res=(res-n*nHk(n-1,3*m-i)%mod+mod)%mod;\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef _debug\n#define out(i) cout << #i << ' ' << i << ' '\n#else \n#define out(i) //\n#endif\nusing ll = long long;\nusing ull = unsigned long long;\nconst int maxn = 500001;\nconst int maxm = 1000001;\nconst int tomod = 998244353;\nll form(ll a){\n\treturn abs(a) % tomod;\n}\nll inv[maxm], fa[maxm];\nvoid init(){\n\tfa[0] = fa[1] = 1;\n\tinv[0] = inv[1] = 1;\n\tfor(int i = 2;i < maxm;++i){\n\t\tfa[i] = form(fa[i - 1] * (ll)i);\n\t\tinv[i] = form((tomod - tomod / i) * inv[tomod % i]);\n\t}\n\tfor(int i = 2;i < maxm;++i)inv[i] = form(inv[i] * inv[i - 1]);\n}\nll cof(int a, int b){\n\treturn form(fa[a] * form(inv[b] * inv[a - b]));\n} \nll solve(int n, int k, const int max_odd){\n\tll res = 0;\n\tfor(int o = k&1;o <= max_odd;o += 2){\n\t\t// if(((k-o)^1)&1){\n\t\t\tres = form(res + form(\n\t\t\t\tcof(n, o) * \n\t\t\t\tcof((k-o)/2+n-1, n-1)\n\t\t\t));\n\t\t// }\n\t}\n\treturn res;\n}\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tinit();\n\tll k, n;\n\tcin >> n >> k;\n\tll res = solve(n, k * 3, min(n, k));\n\tres -= form(n * solve(n, k, min(n, k)));\n\tres += form(n * solve(n - 1, k, min(n - 1, k)));\n\tcout << form(res) << '\\n';\n\tassert(res >= 0 and res < tomod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ri register int\nusing namespace std;\nconst int rlen = 1 << 20 | 5;\nchar buf[rlen], *ib = buf, *ob = buf;\n#define gc() (((ib == ob) && (ob = (ib = buf) + fread(buf, 1, rlen, stdin))), ib == ob ? -1 : *ib++)\n#define pb push_back\n#define rez resize\n#define ppp pop_back\ninline int read() {\n  static int ans;\n  static char ch;\n  for (ans = 0, ch = gc(); !isdigit(ch); ch = gc());\n  while (isdigit(ch)) ans = ((ans << 2) + ans << 1) + (ch ^ 48), ch = gc();\n  return ans;\n}\ninline int Read(char *s) {\n  static int top;\n  static char ch;\n  for (ch = gc(), top = 0; !isalpha(ch); ch = gc());\n  while (isalpha(ch)) s[++top] = ch, ch = gc();\n  return top;\n}\ntypedef long long ll;\ntypedef pair <int, int> pii;\n#define fi first\n#define se second\ninline ll readl() {\n  static ll ans;\n  static char ch;\n  for (ans = 0, ch = gc(); !isdigit(ch); ch = gc());\n  while (isdigit(ch)) ans = ((ans << 2) + ans << 1) + (ch ^ 48), ch = gc();\n  return ans;\n}\ntemplate <typename T> inline void exgcd(T a, T b, T &x, T &y) {\n  if (!b) { x = 1, y = 0; return; }\n  exgcd(b, a - a / b * b, y, x), y -= a / b * x;\n}\nnamespace modular {\n  const int mod = 998244353;\n  int ret;\n  inline int add(int a, int b) { return a < mod - b ? a + b : a - mod + b; }\n  inline int dec(int a, int b) { return a < b ? a - b + mod : a - b; }\n  inline int mul(int a, int b) { return (ll) a * b % mod; }\n  inline void Add(int &a, int b) { a = a < mod - b ? a + b : a - mod + b; }\n  inline void Dec(int &a, int b) { a = a < b ? a - b + mod : a - b; }\n  inline void Mul(int &a, int b) { a = (ll) a * b % mod; }\n  inline int ksm(int a, int p) { for (ret = 1; p; p >>= 1, Mul(a, a)) (p & 1) && (Mul(ret, a), 1); return ret; }\n  inline int fix(int x) {\n    x <= -mod || x >= mod ? x %= mod : 0;\n    return x < 0 ? x + mod : x;\n  }\n  inline int Inv(int a) {\n    static int x, y;\n    return exgcd(a, mod, x, y), fix(x);\n  }\n}  using namespace modular;\nconst int N = 3e6 + 5;\nint n, m, fac[N], ifac[N];\ninline int C(int n, int m) { return n < m || m < 0 ? 0 : mul(fac[n], mul(ifac[m], ifac[n - m])); }\ninline void init_fac() {\n  int lm = 3000000;\n  fac[0] = fac[1] = ifac[0] = ifac[1] = 1;\n  for (ri i = 2; i <= lm; ++i) fac[i] = mul(fac[i - 1], i);\n  ifac[lm] = Inv(fac[lm]);\n  for (ri i = lm - 1; i > 1; --i) ifac[i] = mul(ifac[i + 1], i + 1);\n}\nint main() {\n  #ifdef ldxcaicai\n  freopen(\"lx.in\", \"r\", stdin);\n  #endif\n  n = read(), m = read(), init_fac();\n  int res = 0, tot = 0;\n  for (ri x = m, cur; x >= 0; x -= 2) {\n    int mt = C(n, x), S = (3 * m - x) / 2;\n    cur = C(S + n - 1, n - 1);\n    Dec(cur,  mul(n - x, C(S - (m + 1) + n - 1, n - 1)));\n    Dec(cur,  mul(x, C(S - m + n - 1, n - 1)));\n    Mul(mt, cur);\n    Add(res, mt);\n  }\n  cout << res;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n//#define int long long\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\nconst int MOD = 998244353;\nusing mint = Fp<MOD>;\nBiCoef<mint> bc;\n\nvoid solve() {\n\tint n, m; cin >> n >> m;\n    bc.init(3003000);\n    mint ans = bc.com(3 * m + n - 1, n - 1);\n    for(int i = 2 * m + 1; i <= 3 * m; ++i) {\n        ans -= (mint)n * bc.com(3 * m + n - i - 2, n - 2);\n    }\n    cout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\t//cout << \"finish\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a) {\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'[';\n    for(const T &i: a) out<<i<<',';\n    out<<']';\n    return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out, const set<T>& a) {\n    out<<'{';\n    for(const T &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\ntemplate<class T, class S>\nostream &operator <<(ostream& out, const map<T,S>& a) {\n    out<<'{';\n    for(auto &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\ntemplate<ll MOD>\nstruct modint {\n    ll x;\n    modint(): x(0) {}\n    modint(ll y) : x(y>=0 ? y%MOD : y%MOD+MOD) {}\n    static constexpr ll mod() { return MOD; }\n    // e乗\n    modint pow(ll e) {\n        ll a = 1, p = x;\n        while(e > 0) {\n            if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n            else {a = (a*p) % MOD; e--;}\n        }\n        return modint(a);\n    }\n    modint inv() const {\n        ll a=x, b=MOD, u=1, y=1, v=0, z=0;\n        while(a) {\n            ll q = b/a;\n            swap(z -= q*u, u);\n            swap(y -= q*v, v);\n            swap(b -= q*a, a);\n        }\n        return z;\n    }\n    // Comparators\n    bool operator <(modint b) { return x < b.x; }\n    bool operator >(modint b) { return x > b.x; }\n    bool operator<=(modint b) { return x <= b.x; }\n    bool operator>=(modint b) { return x >= b.x; }\n    bool operator!=(modint b) { return x != b.x; }\n    bool operator==(modint b) { return x == b.x; }\n    // Basic Operations\n    modint operator+(modint r) const { return modint(*this) += r; }\n    modint operator-(modint r) const { return modint(*this) -= r; }\n    modint operator*(modint r) const { return modint(*this) *= r; }\n    modint operator/(modint r) const { return modint(*this) /= r; }\n    modint &operator+=(modint r) {\n        if((x += r.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    modint &operator-=(modint r) {\n        if((x -= r.x) < 0) x += MOD;\n        return *this;\n    }\n    modint &operator*=(modint r) {\n    #if !defined(_WIN32) || defined(_WIN64)\n        x = x * r.x % MOD; return *this;\n    #endif\n        unsigned long long y = x * r.x;\n        unsigned xh = (unsigned) (y >> 32), xl = (unsigned) y, d, m;\n        asm(\n            \"divl %4; \\n\\t\"\n            : \"=a\" (d), \"=d\" (m)\n            : \"d\" (xh), \"a\" (xl), \"r\" (MOD)\n        );\n        x = m;\n        return *this;\n    }\n    modint &operator/=(modint r) { return *this *= r.inv(); }\n    // increment, decrement\n    modint operator++() { x++; return *this; }\n    modint operator++(signed) { modint t = *this; x++; return t; }\n    modint operator--() { x--; return *this; }\n    modint operator--(signed) { modint t = *this; x--; return t; }\n\n    template<class T>\n    friend modint operator*(T l, modint r) { return modint(l) *= r; }\n    template<class T>\n    friend modint operator+(T l, modint r) { return modint(l) += r; }\n    template<class T>\n    friend modint operator-(T l, modint r) { return modint(l) -= r; }\n    template<class T>\n    friend modint operator/(T l, modint r) { return modint(l) /= r; }\n    template<class T>\n    friend bool operator==(T l, modint r) { return modint(l) == r; }\n    template<class T>\n    friend bool operator!=(T l, modint r) { return modint(l) != r; }\n    // Input/Output\n    friend ostream &operator<<(ostream& os, modint a) { return os << a.x; }\n    friend istream &operator>>(istream& is, modint &a) { return is >> a.x; }\n    friend string to_frac(modint v) {\n        static map<ll, PII> mp;\n        if(mp.empty()) {\n            mp[0] = mp[MOD] = {0, 1};\n            FOR(i, 2, 1001) FOR(j, 1, i) if(__gcd(i, j) == 1) {\n                mp[(modint(i) / j).x] = {i, j};\n            }\n        }\n        auto itr = mp.lower_bound(v.x);\n        if(itr != mp.begin() && v.x - prev(itr)->first < itr->first - v.x) --itr;\n        string ret = to_string(itr->second.first + itr->second.second * ((int)v.x - itr->first));\n        if(itr->second.second > 1) {\n            ret += '/';\n            ret += to_string(itr->second.second);\n        }\n        return ret;\n    }\n};\nusing mint = modint<998244353>;\n\n// 前計算O(N) クエリO(1)\nmint combi(ll N, ll K) {\n    const int maxN=5e5; // !!!\n    static mint fact[maxN+1]={},factr[maxN+1]={};\n    if (fact[0]==0) {\n        fact[0] = factr[0] = 1;\n        FOR(i, 1, maxN+1) fact[i] = fact[i-1] * i;\n        factr[maxN] = fact[maxN].inv();\n        for(ll i=maxN-1; i>=0; --i) factr[i] = factr[i+1] * (i+1);\n    }\n    if(K<0 || K>N) return 0; // !!!\n    return factr[K]*fact[N]*factr[N-K];\n}\n\nset<vector<ll>> st;\nvoid dfs(vector<ll> v, ll m) {\n    // cout << v << \" \" << m << \" \" << endl;\n    if(m == 0) {\n        st.insert(v);\n        return;\n    }\n\n    REP(i, v.size()) REP(j, v.size()) {\n        if(i==j) continue;\n        v[i] += 2;\n        v[j] += 1;\n        dfs(v, m-1);\n        v[i] -= 2;\n        v[j] -= 1;\n    }\n}\n\nmint po[1500010];\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n, m;\n    cin >> n >> m;\n\n    // dfs(vector<ll>(n), m);\n    // cout << st.size() << endl;\n\n    po[0] = 1;\n    FOR(i, 1, 3*m+1) po[i] = po[i-1] * n;\n\n    mint ret = combi(3*m+n-1, n-1);\n    // cout << ret << endl;\n    FOR(i, 2*m+1, 3*m+1) {\n        ret -= combi(3*m-i+n-2, n-2) * n;\n        // cout << i << \" \" << 3*m-i+n-2 << \" \" << n-2 << \" \" << combi(3*m-i+n-2, n-2) << \" \" << n << endl;\n    }\n    // cout << ret << endl;\n    FOR(i, m+1, n+1) {\n        if((3*m-i)%2) continue;\n        ret -= combi(n, i) * combi((3*m-i)/2+n-1, n-1);\n        // cout << \"i=\" << i << \" \" << ret << \" \" << combi(n, i) << \" \" << po[(3*m-i)/2] << endl;\n    }\n\n    cout << ret << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat pw(cat a, cat e, cat mod) {\n\tif(e <= 0) return 1;\n\tcat x = pw(a, e/2, mod);\n\tx = x * x % mod;\n\tif(e&1) x = x * a % mod;\n\treturn x;\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, M;\n\tcin >> N >> M;\n\tcat tot = 1, dif = 0, fac_inv = 1, mod = 998244353;\n\tfor(int i = 1; i < N; i++) {\n\t\ttot = tot * (3*M+i) % mod;\n\t\tfac_inv = fac_inv * i % mod;\n\t}\n\tvector<cat> prod_m1(N+3*M+1, 0), prod_m2(N+3*M+1, 0);\n\tprod_m1[0] = fac_inv;\n\tprod_m2[0] = fac_inv * pw(N-1, mod-2, mod) % mod;\n\tfor(int i = 0; i < M; i++) {\n\t\tprod_m1[i+1] = prod_m1[i] * (i+N) % mod * pw(i+1, mod-2, mod) % mod;\n\t\tprod_m2[i+1] = prod_m2[i] * (i+N-1) % mod * pw(i+1, mod-2, mod) % mod;\n\t}\n\tfor(int i = 0; i < M; i++) dif = (dif + prod_m2[i]) % mod;\n\tdif = dif * N % mod * (N-1) % mod;\n\tvector<cat> C(N+1, 0); // C(N, i)\n\tC[0] = 1;\n\tfor(int i = 1; i <= N; i++) C[i] = C[i-1] * pw(i, mod-2, mod) % mod * (N-i+1) % mod;\n\tfor(int i = M+1; i <= N; i++) if((M-i)%2 == 0)\n\t\tdif = (dif + prod_m1[(3*M-i)/2] * C[i]) % mod;\n\tcat ans = (tot - dif) * pw(fac_inv, mod-2, mod) % mod;\n\tif(ans < 0) ans += mod;\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n#include <cmath>\n\nauto & in = std::cin;\nauto& out = std::cout;\n#define all_range(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\ntemplate<typename Arithmetic, typename Integral>\nstd::enable_if_t< std::is_unsigned<Integral>::value, Arithmetic>\nipow(Arithmetic bace, Integral n)\n{\n\t//繰り返し二条法\n\tauto res = (Arithmetic)(1);\n\twhile (n > 0) {\n\t\tif (n & 1) res *= bace;\n\t\tbace *= bace;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nconstexpr bool is_prime(uint32_t N)\n{\n\tif (N <= 1) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 2; i * i <= N; ++i)\n\t{\n\t\tif (N % i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate <uint64_t MOD> class mint_base;\n//mint_base_base型用の累乗関数\ntemplate <uint64_t MOD> constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <uint64_t MOD_ = 998244353>\nclass mint_base\n{\npublic:\n\tstatic constexpr auto MOD = MOD_;\n\tstatic_assert(!(MOD <= 2), \"MOD cannot be below 2.\");\n\tstatic_assert(MOD <= (0xFFFFFFFFFFFFFFFF / 2), \"MOD is too big\");//加算してオーバーフローしない\n\tstatic_assert(MOD <= 0xFFFFFFFF, \"MOD is too big\");//乗算してオーバーフローしない\n\tconstexpr mint_base<MOD> operator+(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v += other;\n\t}\n\tconstexpr mint_base<MOD> operator-(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v -= other;\n\t}\n\tconstexpr mint_base<MOD> operator*(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v *= other;\n\t}\n\tconstexpr auto operator/(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v /= other;\n\t}\n\tconstexpr mint_base<MOD>& operator+=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta += other.a;\n\t\tif (MOD <= a) { a -= MOD; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator-=(const mint_base<MOD>& other) noexcept\n\t{\n\t\tif (a >= other.a) {\n\t\t\ta -= other.a;\n\t\t}\n\t\telse {\n\t\t\ta = (a + MOD) - other.a;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator*=(const mint_base<MOD>& other) noexcept\n\t{\n#if 1\n\t\ta *= other.a;\n\t\ta %= MOD;\n#else\n\t\t//MOD <= (MAXUINT64 / 2)条件下\n\t\tuint64_t b = other.a, v = 0;\n\t\twhile (b > 0) {\n\t\t\tif (b & 1) {\n\t\t\t\tv += a;\n\t\t\t\tif (v >= MOD)v -= MOD;\n\t\t\t}\n\t\t\ta += a;\n\t\t\tif (MOD <= a)a -= MOD;\n\t\t\tb >>= 1;\n\t\t}\n\t\ta = v;\n#endif\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator/=(const mint_base<MOD>& other) noexcept\n\t{\n\t\treturn *this *= ~other;\n\t}\n\tconstexpr mint_base<MOD> operator+()const noexcept { return *this; }\n\tconstexpr mint_base<MOD> operator-()const noexcept\n\t{\n\t\treturn{ MOD - a, mod_value_tag{} };\n\t}\n\tconstexpr mint_base<MOD>& operator++() noexcept\n\t{\n\t\tif (MOD <= ++a) { a = 0; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator--() noexcept\n\t{\n\t\tif (a <= 0) { a = MOD; };\n\t\t--a;\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD> operator++(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t++* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator--(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t--* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator~()const noexcept\n\t{\n\t\treturn ipow(*this, e_phi - 1);\n\t}\n\tconstexpr mint_base<MOD>& operator=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{\n\t\treturn a;\n\t}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{\n\t\treturn (unsigned)a;\n\t}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{\n\t\treturn MOD;\n\t}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_% MOD) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tstatic constexpr uint64_t get_e_phi()noexcept {\n\t\t//オイラー値の導出\n\t\tuint64_t temp = MOD;\n\t\tuint64_t m_ = MOD;\n\t\tfor (uint64_t i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\ttemp = temp / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)temp = temp / m_ * (m_ - 1);\n\t\treturn temp;\n\t}\n\tstatic constexpr uint64_t e_phi = get_e_phi();//オイラー値\n\tuint64_t a;\n};\n//mint_base型用の累乗関数\ntemplate<uint64_t MOD>constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept\n{\n\tmint_base<MOD> res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)res *= x;\n\t\tx *= x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//O(x)時間が必要のため、fact_set関数を推奨する。\ntemplate<uint64_t MOD>constexpr mint_base<MOD> fact(mint_base<MOD> x)noexcept\n{\n\tmint_base<MOD> res(1);\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\ntemplate<uint64_t MOD>std::vector<mint_base<MOD>> fact_set(mint_base<MOD> x = mint_base<MOD>(-1))\n{\n\tmint_base<MOD> res(1);\n\tstd::vector<mint_base<MOD>> set((uint64_t)(x)+1);\n\tset[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn res;\n}\n//mint_base型のstreamへの出力\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (uint64_t)i;\n\treturn os;\n}\n//mint_base型のstreamからの入力\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tuint64_t tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\ntypedef mint_base<998244353> mint;\nnamespace mint_literal {\n\tconstexpr mint operator\"\"_mi(unsigned long long x)noexcept {\n\t\treturn mint(x);\n\t}\n}\nusing namespace mint_literal;\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(N)\ntemplate<int32_t X, uint64_t MOD = mint::MOD>\n/*constexpr*/ std::array<mint_base<MOD>, X + 1> fact_set_c()\n{\n\tmint_base<MOD> res(1);\n\tstd::array<mint_base<MOD>, X + 1> set;\n\tset[0] = 1;\n\tfor (int32_t i = 1; i <= X; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn set;\n}\ntemplate<typename RET = mint, typename Integral>\nRET combination(Integral all, Integral get)\n{\n\tassert(all >= get);\n\tget = std::min(all - get, get);\n#if 1\n\t//時間計算量O(1)+初期化O(NlogMOD)\n\tstatic const auto fact_v = fact_set_c<3000000 + 1>();\n\tstatic const auto fact_div_v = [&]() {\n\t\tauto tmp = fact_v;\n\t\tfor (auto& i : tmp) { i = ~i; }\n\t\treturn tmp;\n\t}();\n\t//return fact_v[all] / (fact_v[get] * fact_v[all - get]);\n\treturn fact_v[all] * fact_div_v[get] * fact_div_v[all - get];\n#elif 0\n\t//時間計算量O(1)\n\t//空間計算量、初期化時間計算量O(N^2)\n\tconstexpr int32_t ALL_MAX = 要素数;// 10'000;\n\tstatic std::vector<RET> DP_comb[ALL_MAX + 1];\n\tif (!DP_comb[all].empty())\n\t{\n\t\treturn DP_comb[all][get];\n\t}\n\n\tif (DP_comb[0].empty())\n\t{\n\t\tDP_comb[0].resize(1);\n\t\tDP_comb[0][0] = (RET)1;\n\t\tDP_comb[1].resize(1);\n\t\tDP_comb[1][0] = (RET)1;\n\t}\n\tfor (int32_t i = 2; i <= all; i++)\n\t{\n\t\tif (DP_comb[i].empty())\n\t\t{\n\t\t\tint32_t size = i / 2 + 1;\n\t\t\tDP_comb[i].resize(size);\n\t\t\tDP_comb[i][0] = (RET)1;\n\t\t\tfor (int32_t j = 1; j < size - 1; j++)\n\t\t\t{\n\t\t\t\tDP_comb[i][j] = DP_comb[i - 1][j - 1] + DP_comb[i - 1][j];\n\t\t\t}\n\t\t\tDP_comb[i][size - 1] = DP_comb[i - 1][size - 2] + DP_comb[i - 1][(i & 1) ? (size - 1) : (size - 2)];\n\t\t}\n\t}\n\treturn DP_comb[all][get];\n#else\n\t//時間計算量O(get * logMOD)\n\tRET ret = (RET)1;\n\tfor (Integral i = 1; i <= get; ++i)\n\t{\n\t\tret *= all + 1 - i;\n\t\tret /= i;\n\t}\n\treturn ret;\n#endif\n}\nusing std::vector;\ntemplate< int mod, int primitiveroot >\nstruct NumberTheoreticTransform {\n\tvector< vector< int > > rts, rrts;\n\tvoid ensure_base(int N) {\n\t\tif (rts.size() >= N) return;\n\t\trts.resize(N), rrts.resize(N);\n\t\tfor (int i = 1; i < N; i <<= 1) {\n\t\t\tif (rts[i].size()) continue;\n\t\t\tint w = mod_pow(primitiveroot, (mod - 1) / (i * 2));\n\t\t\tint rw = inverse(w);\n\t\t\trts[i].resize(i), rrts[i].resize(i);\n\t\t\trts[i][0] = 1, rrts[i][0] = 1;\n\t\t\tfor (int k = 1; k < i; k++) {\n\t\t\t\trts[i][k] = mul(rts[i][k - 1], w);\n\t\t\t\trrts[i][k] = mul(rrts[i][k - 1], rw);\n\t\t\t}\n\t\t}\n\t}\n\n\tinline int mod_pow(int x, int n) {\n\t\tint ret = 1;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) ret = mul(ret, x);\n\t\t\tx = mul(x, x);\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tinline int inverse(int x) {\n\t\treturn mod_pow(x, mod - 2);\n\t}\n\n\tinline int add(int x, int y) {\n\t\tx += y;\n\t\tif (x >= mod) x -= mod;\n\t\treturn x;\n\t}\n\n\tinline int mul(int a, int b) {\n\t\treturn int(1LL * a * b % mod);\n\t}\n\n\tvoid DiscreteFourierTransform(vector< int >& F, bool rev) {\n\t\tconst int N = (int)F.size();\n\t\tensure_base(N);\n\t\tfor (int i = 0, j = 1; j + 1 < N; j++) {\n\t\t\tfor (int k = N >> 1; k > (i ^= k); k >>= 1);\n\t\t\tif (i > j) std::swap(F[i], F[j]);\n\t\t}\n\t\tfor (int i = 1; i < N; i <<= 1) {\n\t\t\tfor (int j = 0; j < N; j += i * 2) {\n\t\t\t\tfor (int k = 0; k < i; k++) {\n\t\t\t\t\tint s = F[j + k], t = mul(F[j + k + i], rev ? rrts[i][k] : rts[i][k]);\n\t\t\t\t\tF[j + k] = add(s, t), F[j + k + i] = add(s, mod - t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (rev) {\n\t\t\tint temp = inverse(N);\n\t\t\tfor (int i = 0; i < N; i++) F[i] = mul(F[i], temp);\n\t\t}\n\t}\n\n\tvector< int > Multiply(const vector< int >& A, const vector< int >& B) {\n\t\tint sz = 1;\n\t\twhile (sz < A.size() + B.size() - 1) sz <<= 1;\n\t\tvector< int > F(sz), G(sz);\n\t\tfor (int i = 0; i < A.size(); i++) F[i] = A[i];\n\t\tfor (int i = 0; i < B.size(); i++) G[i] = B[i];\n\t\tDiscreteFourierTransform(F, false);\n\t\tDiscreteFourierTransform(G, false);\n\t\tfor (int i = 0; i < sz; i++) F[i] = mul(F[i], G[i]);\n\t\tDiscreteFourierTransform(F, true);\n\t\tF.resize(A.size() + B.size() - 1);\n\t\treturn F;\n\t}\n};\n\n\n\nint32_t N, M;\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tin >> N >> M;\n\tif (M < 2) {\n\t\t//うく;\n\t}\n\tstd::vector< int > prev_count(M + 2);\n\tstd::vector< int > multititi(M + 2);\n\tfor (size_t i = 1; i < M+2; i++)\n\t{\n\t\tprev_count[i] = i;\n\t}\n\tint32_t count = 2;\n\tint32_t next_M = 4;\n\twhile (next_M <= N) {\n\n\t\tNumberTheoreticTransform< mint::MOD, 5 > ntt;\n\t\t//{\n\t\t//\tint N;\n\t\t//\tstd::vector< int > A(N + 1), B(N + 1);\n\t\t//\tfor (int i = 0; i < N; i++) scanf(\"%d %d\", &A[i + 1], &B[i + 1]);\n\t\t//\tNumberTheoreticTransform< mint::MOD, 5 > ntt;\n\t\t//\tauto C = ntt.Multiply(A, B);\n\t\t//\tfor (int i = 1; i <= 2 * N; i++) printf(\"%d\\n\", C[i]);\n\t\t//}\n\t\tauto C = ntt.Multiply(prev_count, prev_count);\n\t\tC.erase(C.begin());\n\t\tC.resize(M + 2);\n\t\tfor (size_t i = 1; i < M+2; i++)\n\t\t{\n\t\t\tC[i] += C[i - 1];\n\t\t}\n\t\tprev_count = std::move(C);\n\n\t\t++count;\n\t\tnext_M *= 2;\n\t}\n\tnext_M /= 2;\n\tfor (size_t i = 1; i < M+2; i++)\n\t{\n\t\tmultititi[i] = i;\n\t}\n\twhile(next_M < N)\n\t{\n\t\t++next_M;\n\n\t\tNumberTheoreticTransform< mint::MOD, 5 > ntt;\n\t\tauto C = ntt.Multiply(prev_count, multititi);\n\t\tC.erase(C.begin());\n\t\tC.resize(M + 2);\n\t\tfor (size_t i = 1; i < M + 2; i++)\n\t\t{\n\t\t\tC[i] += C[i - 1];\n\t\t}\n\t\tprev_count = std::move(C);\n\n\t}\n\tout << prev_count[M+1] << endl;\n\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest& ...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest& ...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest& ...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n#define SHOWSTACK(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.top() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T & a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n#define random_shuffle \"USE std::shuffle!\";\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = (1 << 30) - 1;                    // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 998244353;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T & val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T> & a, const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>> & a, const T & val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nll powMod(ll n, ll p, ll mod) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= n) %= mod;\n\t\t(n *= n) %= mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\nll invMod(ll n, ll mod) {\n\treturn powMod(n, MOD - 2, MOD);\n}\n\nconst signed FACT_MAX_N = 3000006;\nsigned fact[FACT_MAX_N];\nsigned factInv[FACT_MAX_N];\nstruct INIT_FACT {\n\tINIT_FACT() {\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i < FACT_MAX_N; ++i) fact[i] = (long long)i * fact[i - 1] % MOD;\n\t\tfactInv[FACT_MAX_N - 1] = powMod(fact[FACT_MAX_N - 1], MOD - 2, MOD);\n\t\tfor (int i = FACT_MAX_N - 2; i >= 0; --i) factInv[i] = (long long)(i + 1) * factInv[i + 1] % MOD;\n\t}\n} init_fact;\n\n/* n,r<=10^6, query O(1)*/\nll Permutation(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD;\n}\nll Combination(int n, int r) {\n\tif (r == 0) return 1;\n\tif (n < r) return 0;\n\treturn (long long)fact[n] * factInv[n - r] % MOD * factInv[r] % MOD;\n}\nll CombinationWithRepetition(ll n, ll r) {\n\treturn Combination(n + r - 1, r);\n}\n\nll Deal(ll n, ll r) {\n\treturn Combination(n + r - 1, r - 1);\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m);\n\tint ans = 0;\n\tREP(k, m + 1) {\n\t\tif (k > n) break;\n\t\tif ((3 * m - k) & 1) continue;\n\t\tint S = (3 * m - k) / 2;\n\t\t(ans += Deal(S, n) * Combination(n, k)) %= MOD;\n\t\tif (k > 0) (ans -= n * Deal(S - m, n - 1) % MOD * Combination(n - 1, k - 1)) %= MOD;\n\t\tint a = S - m - 1;\n\t\tint coef = n * Combination(n, k) % MOD;\n\t\tint sum = 0;\n\t\t/*REP(i, S - m) {\n\t\t\t(sum += Combination(i + n - 2, n - 2)) %= MOD;\n\t\t}*/\n\t\tsum = Combination(a + n - 1, n - 2) * (a + 1) % MOD * invMod(n - 1, MOD) % MOD;\n\t\t(ans -= coef * sum) %= MOD;\n\t}\n\tif (ans < 0) ans += MOD;\n\tOUT(ans)BR;\n\n\treturn 0;\n}\n/*\nΣx = 3m\nx_i <= 2m\n\nx_i = 1s_i+2t_i\nとすると\nΣs_i = M\nΣt_i = M\ns_i+t_i<=M\n\n\n//**/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 998244353\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\nvector<ll> factmemo, factmemoInv;\nll factmemoMod = -1;\n\nll factorial(int n, int M){\n  if(n <= 1) return 1;\n  if(factmemoMod == M) return factmemo[n];\n\n  ll res = 1;\n  for(int i=1; i<=n; i++) res = res * i % M;\n  return res;\n}\n\nll power(int k, int n, int M){\n  if(n == 0) return 1;\n  if(n == 1) return (ll)k;\n\n  ll res = power(k, n/2, M);\n\n  res = res * res % M;\n  return n%2 == 1 ? res * k % M : res;\n}\n\nvoid initFactorial(int n, int M){\n  factmemo.assign(n+1, 0);\n  factmemoInv.assign(n+1, 0);\n  factmemoMod = M;\n  factmemo[0] = 1;\n  for(int i=1;i<=n;i++) factmemo[i] = factmemo[i-1] * i % M;\n  factmemoInv[n] = power(factmemo[n], M-2, M);\n  for(int i=n;i>0;i--) factmemoInv[i-1] = factmemoInv[i] * i % M;\n}\n\n//nCm nPm nHm (mod M)\n\n/*Combination*/\nll C(int n, int m, int M){\n  if(n < m) return 0;\n  if(m == 0 || n == m) return 1;\n\n  if(factmemoMod == M)\n    return factmemo[n] * factmemoInv[m] % M * factmemoInv[n-m] % M;\n\n  ll numer = factorial(n, M);\n  ll denom = factorial(m, M) * factorial(n-m, M) % M;\n\n  denom = power((int)denom, M-2, M);\n\n  return numer * denom % M;\n}\n/*Permutation*/\nll P(int n, int m, int M){\n  if(n < m) return 0;\n  if(m == 0) return 1;\n\n\n  if(factmemoMod == M)\n    return factmemo[n] * factmemoInv[n-m] % M;\n\n  ll numer = factorial(n, M);\n  ll denom = factorial(n-m, M);\n\n  denom = power((int)denom, M-2, M);\n\n  return numer * denom % M;\n}\n/*Combination with Repetitions*/\nll H(int n, int m, int M){\n  if(n == 0 && m == 0) return 1;\n  return C(n+m-1, m, M);\n}\n\n\n\nint main(){\n  int N, M;\n\n  cin >> N >> M;\n\n  ll all = 0;\n  ll minus = 0;\n\n  initFactorial(M*4 + 1, mod);\n\n  for(int i=0; i<=N; i++) {\n    if (M%2 != i%2 || i > M) continue;\n\n    int P = i; // 1\n    int Q = (M - i)/2; // 1+1\n    int R = M; // 2\n\n    // P, Q + R\n\n    int S = Q + R;\n\n    all += C(N, P, mod) * C(N-1+S, N-1, mod) % mod;\n    minus += C(N, P, mod) * C(P, 1, mod) % mod * C((N-1)+(S-M), N-1, mod) % mod;\n    minus += C(N, P, mod) * C(N-P, 1, mod) % mod * C((N-1)+(S-(M+1)), N-1, mod) % mod;\n  }\n\n  all %= mod;\n  minus %= mod;\n\n  cout << (all + mod - minus) % mod << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MAX = 3000003;\nconst long long mod = 998244353;\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (long long i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % mod;\n        inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n        finv[i] = finv[i - 1] * inv[i] % mod;\n    }\n}\n\n// 二項係数計算\nlong long COM(long long comn, long long comk){\n    if (comn < comk) return 0;\n    if (comn < 0 || comk < 0) return 0;\n    return fac[comn] * (finv[comk] * finv[comn - comk] % mod) % mod;\n}\n\nint main() {\n\t// your code goes here\n\tCOMinit();\n\tlong long n,m,i,j,ans,min=0;\n\tcin >> n >> m;\n\tif(n==2){\n\t\tcout << m+1 << endl;\n\t\treturn 0;\n\t}\n\tans=COM(3*m+n-1,n-1);\n\tfor(i=2*m+1;i<=3*m;i++){\n\t\tmin=(min+((3*m-i+1)*COM(3*m+n-i-2,n-3))%mod)%mod;\n\t\tmin=(min+2*COM(3*m+n-i-2,n-2))%mod;\n\t}\n\tans=(ans+mod-min)%mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sz(c)      int(c.size())\n#define rep(i,a,b) for (int i=a; i<(b); ++i)\n#define per(i,a,b) for (int i=(b)-1; i>=(a); --i)\nusing namespace std;\nusing ll = long long;\n\nint const MD=998244353;\n\nint madd(int x,int y) {\n\tif (x+y<MD) return x+y; else return x+y-MD;\n}\nint msub(int x,int y) {\n\tif (x-y>=0) return x-y; else return x-y+MD;\n}\nint mmul(int x,int y) {\n\treturn int(ll(x)*y % MD);\n}\nint mpow(int x,int p) {\n\tint res=1;\n\twhile (p>0) {\n\t\tif (p%2) res=mmul(res,x);\n\t\tx=mmul(x,x);\n\t\tp/=2;\n\t}\n\treturn res;\n}\nint minv(int x) {\n\treturn mpow(x,MD-2);\n}\nint mdiv(int x,int y) {\n\treturn mmul(x,mpow(y,MD-2));\n}\n\nint const MAXN=2.2e6;\nint fact[MAXN];\nint invfact[MAXN];\nvoid mfact_init() {\n\tfact[0]=invfact[0]=1;\n\trep(i,1,MAXN) {\n\t\tfact[i]=mmul(fact[i-1],i);\n\t\tinvfact[i]=minv(fact[i]);\n\t}\n}\nint mcomb(int x,int y) {\n\tif (x<y) return 0;\n\treturn mmul(fact[x],mmul(invfact[x-y],invfact[y]));\n}\nint mdistr(int x,int y) {\n\treturn mcomb(x+y-1,y-1);\n}\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(10);\n\n\tmfact_init();\n\n\tint N,M;\n\tcin>>N>>M;\n\t\n\tint res=0;\n\trep(i,0,min(N,M)+1) if ((3*M-i)%2==0) {\n\t\tint add=mmul(mcomb(N,i),mdistr((3*M-i)/2,N));\n\t\tres=madd(res,add);\n\t}\n\trep(i,0,min(N,M)+1) if ((M-i)%2==0) {\n\t\tint sub=mmul(mcomb(N,i),mdistr((M-i)/2,N));\n\t\tres=msub(res,mmul(sub,N));\n\t}\n\trep(i,0,min(N,M)+1) if ((M-i)%2==0) {\n\t\tint add=mmul(mcomb(N-1,i),mdistr((M-i)/2,N-1));\n\t\tres=madd(res,mmul(add,N));\n\t}\n\tcout<<res<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=3000005,mod=998244353;\nint n,m,fact[N],inv[N],ans,tp;\ninline void inc(int& x,CI y)\n{\n\tif ((x+=y)>=mod) x-=mod;\n}\ninline void dec(int& x,CI y)\n{\n\tif ((x-=y)<0) x+=mod;\n}\ninline int quick_pow(int x,int p=mod-2,int mul=1)\n{\n\tfor (;p;p>>=1,x=1LL*x*x%mod) if (p&1) mul=1LL*mul*x%mod; return mul;\n}\ninline int C(CI n,CI m)\n{\n\tif (n<m) return 0; return 1LL*fact[n]*inv[m]%mod*inv[n-m]%mod;\n}\ninline void init(CI n)\n{\n\tRI i; for (fact[0]=i=1;i<=n;++i) fact[i]=1LL*fact[i-1]*i%mod;\n\tfor (inv[n]=quick_pow(fact[n]),i=n-1;~i;--i) inv[i]=1LL*inv[i+1]*(i+1)%mod;\n}\nint main()\n{\n\tRI i; scanf(\"%d%d\",&n,&m); init(n+3*m);\n\tfor (i=0;i<=m;++i) if (!((3*m-i)&1))\n\ttp=(3*m-i)/2,inc(ans,1LL*C(n,i)*C(tp+n-1,n-1)%mod);\n\tfor (i=2*m+1;i<=3*m;++i) dec(ans,1LL*n*C(3*m-i+n-2,n-2)%mod);\n\treturn printf(\"%d\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\n\nusing namespace std;\n\nconst ll MOD = 998244353;\n\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n\nconst int MX = 2e6;\n\nll fc[MX];\nll bfc[MX];\n\nvoid init() {\n\tfc[0] = 1;\n\tfor (int i = 1; i < MX; ++i)\n\t\tfc[i] = (fc[i - 1] * i) % MOD;\n\tbfc[MX - 1] = pw(fc[MX - 1], MOD - 2);\n\tfor (int i = MX - 2; i >= 0; --i)\n\t\tbfc[i] = (bfc[i + 1] * (i + 1)) % MOD;\n}\n\nll cnk(int n, int k) {\n\tif (k > n)\n\t\treturn 0;\n\treturn fc[n] * bfc[k] % MOD * bfc[n - k] % MOD;\n}\n\nint n, m;\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcout.setf(ios::fixed), cout.precision(20);\n\tinit();\n\tcin >> n >> m;\n\tll ans = 0;\n\tfor (int i = m; i >= 0; i -= 2) {\n\t\tans = (ans + cnk(n, i) * cnk((3 * m - i) / 2 + n - 1, n - 1)) % MOD;\n\t}\n\tll go = 0;\n\tfor (int i = 2 * m + 1; i <= 3 * m; ++i) {\n\t\tgo = (go + cnk(3 * m - i + n - 2, n - 2)) % MOD;\n\t}\n\tgo = (go * n) % MOD;\n\tans = (ans - go + MOD) % MOD;\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cstdio>\n#include <iomanip>\n#include <cmath>\n#include <bitset>\n\nusing namespace std;\n\nint n, m;\nconst int MOD = 998244353;\nlong long ans = 0;\nlong long fact[2100000];\nlong long ufact[2100000];\n\nlong long inq(long long a, long long b)\n{\n    if (b == 0) return 1;\n    long long l = inq(a, b / 2);\n    if (b % 2) return l * l % MOD * a % MOD;\n    return l * l % MOD;\n}\n\nlong long cnk(long long n, long long k)\n{\n    return fact[n] * ufact[k] % MOD * ufact[n - k] % MOD;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tfact[0] = 1, ufact[0] = 1;\n\tcin >> n >> m;\n\tif (n < m)\n    {\n        return 1;\n    }\n\tfor (int i = 1; i <= 2000200; i++) fact[i] = fact[i - 1] * i % MOD, ufact[i] = inq(fact[i], MOD - 2);\n\tans = cnk(3 * m + n - 1, n - 1);\n\tans = (ans + MOD - n) % MOD;\n\tn--;\n\tfor (int bad_len = 2 * m + 1; bad_len < 3 * m; bad_len++)\n    {\n        int cnt_pos = 3 * m - bad_len - 1;\n        ans = (ans + MOD - cnt_pos * cnk(3 * m - bad_len + 1 + n - 2, n - 2) % MOD) % MOD;\n        ans = (ans + MOD - 2 * cnk(3 * m - bad_len + 1 + n - 1, n - 1) % MOD) % MOD;\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nЗАПУСКАЕМ\n░ГУСЯ░▄▀▀▀▄░РАБОТЯГУ░░\n▄███▀░◐░░░▌░░░░░░░\n░░░░▌░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▌░░░░░▐▄▄░░░░░\n░░░░▌░░░░▄▀▒▒▀▀▀▀▄\n░░░▐░░░░▐▒▒▒▒▒▒▒▒▀▀▄\n░░░▐░░░░▐▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░▀▄░░░░▀▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░░░▀▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▀▄\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░▄▄▌▌▄▌▌░░░░░\n */\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <random>\n\nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; }\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left224\n#define right right224\n#define next next224\n#define rank rank224\n#define prev prev224\n#define y1 y1224\n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define files(FILENAME) read(FILENAME), write(FILENAME)\n#define pb push_back\n#define mp make_pair\nconst string FILENAME = \"input\";\nconst int MAXN = 3000228;\nconst int Mod = 998244353;\n\n\nint mul(int a, int b) {\n    return (1LL * a * b) % Mod;\n}\n\n\nint sum(int a, int b) {\n    return (a + b) % Mod;\n}\n\n\nint powm(int a, int b) {\n    int res = 1;\n    while (b) {\n        if (b & 1) {\n            res = mul(res, a);\n        }\n        b >>= 1;\n        a = mul(a, a);\n    }\n    return res;\n}\n\nint n, m;\nint fact[MAXN];\nint rfact[MAXN];\n\nint getc(int i, int j) {\n    return mul(fact[i], mul(rfact[j], rfact[i - j]));\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    //read(FILENAME);\n    cin >> n >> m;\n    fact[0] = 1;\n    for (int i = 1; i <= 3000000; i++) {\n        fact[i] = mul(fact[i - 1], i);\n    }\n    rfact[3000000] = powm(fact[3000000], Mod - 2);\n    for (int i = 2999999; i >= 0; i--) {\n        rfact[i] = mul(rfact[i + 1], i + 1);\n    }\n   // n + 3 * m, n - 1\n    int ans = getc(n + 3 * m - 1, n - 1);\n    //cout << ans << endl;\n    for (int value = 2 * m + 1; value <= 3 * m; value++) {\n        int f = getc(n + 3 * m - value - 2, n - 2);\n        f = mul(f, n);\n        ans = sum(ans, Mod - f);\n    }\n    for (int cntodd = m + 1; cntodd <= n; cntodd++) {\n        int f = getc(n, cntodd);\n        int rest = 3 * m - cntodd;\n        if (rest % 2 != 0) {\n            continue;\n        }\n        if (cntodd > 3 * m) {\n            continue;\n        }\n        int have = rest / 2;\n        f = mul(f, getc(have + n - 1, n - 1));\n        ans = sum(ans, Mod - f);\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PI 3.14159265358979323846264338327950288419\n\nusing namespace std;\n\nconst int mod = 998244353;\nint n, m;\nint fact[2000005], inv_fact[2000005];\n\nint expo(int a, int b){\n\tint c = 1, d = a;\n\twhile(b){\n\t\tif(b & 1){\n\t\t\tc = 1LL * c * d % mod;\n\t\t}\n\t\td = 1LL * d * d % mod;\n\t\tb >>= 1;\n\t}\n\treturn c;\n}\n\nint inv(int a){\n\treturn expo(a, mod - 2);\n}\n\nint ncr(int _n, int _r){\n\tif(_n < 0 || _r < 0 || _r > _n){\n\t\treturn 0;\n\t}\n\tint ret = fact[_n];\n\tret = 1LL * ret * inv_fact[_r] % mod;\n\tret = 1LL * ret * inv_fact[_n - _r] % mod;\n\treturn ret;\n}\n\t\n\nint main(){\n\tfact[0] = inv_fact[0] = 1;\n\tfor(int i = 1; i <= 2000000; i++){\n\t\tfact[i] = 1LL * fact[i - 1] * i % mod;\n\t\tinv_fact[i] = inv(fact[i]);\n\t}\n\t\n\tscanf(\"%d %d\", &n, &m);\n\tint ans = 0;\n\tfor(int odd = m; odd >= 0; odd -= 2){\n\t\t// ways to assign odds?\n\t\tif(odd > n){\n\t\t\tcontinue;\n\t\t}\n\t\tint combin_pt1 = ncr(n, odd);\n\t\tint remain = (3 * m - odd) / 2;\n\t\t\n\t\t// first assume we assign randomly\n\t\tint combin_pt2 = ncr(remain + n - 1, n - 1);\n\t\t\n\t\t// fail case 1: an odd number gets >= m out of remain\n\t\tcombin_pt2 = (combin_pt2 - 1LL * odd * ncr(remain - m + n - 1, n - 1)) % mod;\n\t\t\n\t\t// fail case 2: an even number gets > m + 1 out of remaining\n\t\tcombin_pt2 = (combin_pt2 - 1LL * (n - odd) * ncr(remain - (m + 1) + n - 1, n - 1)) % mod;\n\t\t\n\t\tans = (ans + 1LL * combin_pt1 * combin_pt2) % mod;\n\t}\n\tif(ans < 0){\n\t\tans += mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!===============================================================!//\n//!   88888888b            dP       .88888.   a88888b. 888888ba   !//\n//!   88                   88      d8'   '88 d8'   '88 88    '8b  !//\n//!  a88aaaa    dP.  .dP d8888P    88        88        88     88  !//\n//!   88         '8bd8'    88      88   YP88 88        88     88  !//\n//!   88         .d88b.    88      Y8.   .88 Y8.   .88 88    .8P  !//\n//!   88888888P dP'  'dP   dP       '88888'   Y88888P' 8888888P   !//\n//!===============================================================!//\ntemplate <typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto p = extgcd(b, a % b);\n    return {p.second, p.first - p.second * (a / b)};\n}\ntemplate <typename T>\nconstexpr T inverse(const T a, const T mod) { return (mod + extgcd((mod + a % mod) % mod, mod).first % mod) % mod; }\n//!========================================================!//\n//!  8888ba.88ba                 dP    dP            dP    !//\n//!  88  '8b  '8b                88    88            88    !//\n//!  88   88   88 .d8888b. .d888b88    88 88d888b. d8888P  !//\n//!  88   88   88 88'  '88 88'  '88    88 88'  '88   88    !//\n//!  88   88   88 88.  .88 88.  .88    88 88    88   88    !//\n//!  dP   dP   dP '88888P' '88888P8    dP dP    dP   dP    !//\n//!========================================================!//\ntemplate <uint mod>\nclass ModInt\n{\nprivate:\n    uint v;\n    static uint norm(const uint& x) { return x < mod ? x : x - mod; }\n    static ModInt make(const uint& x)\n    {\n        ModInt m;\n        return m.v = x, m;\n    }\n    static ModInt power(ModInt x, ll n)\n    {\n        ModInt ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static ModInt inv(const ModInt& x) { return ModInt{inverse(static_cast<ll>(x.v), static_cast<ll>(mod))}; }\n\npublic:\n    ModInt() : v{0} {}\n    ModInt(const ll val) : v{norm(uint(val % static_cast<ll>(mod) + static_cast<ll>(mod)))} {}\n    ModInt(const ModInt& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    bool operator!() const { return not static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& m) { return v = m(), (*this); }\n    ModInt& operator=(const ll val) { return v = norm(uint(val % static_cast<ll>(mod) + static_cast<ll>(mod))), (*this); }\n    friend ModInt operator+(const ModInt& m) { return m; }\n    friend ModInt operator-(const ModInt& m) { return make(norm(mod - m.v)); }\n    friend ModInt operator+(const ModInt& m1, const ModInt& m2) { return make(norm(m1.v + m2.v)); }\n    friend ModInt operator-(const ModInt& m1, const ModInt& m2) { return make(norm(m1.v + mod - m2.v)); }\n    friend ModInt operator*(const ModInt& m1, const ModInt& m2) { return make(static_cast<uint>(static_cast<ll>(m1.v) * static_cast<ll>(m2.v) % static_cast<ll>(mod))); }\n    friend ModInt operator/(const ModInt& m1, const ModInt& m2) { return m1 * inv(m2.v); }\n    friend ModInt operator+(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) + val}; }\n    friend ModInt operator-(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) - val}; }\n    friend ModInt operator*(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) * (val % static_cast<ll>(mod))}; }\n    friend ModInt operator/(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) * inv(val)}; }\n    friend ModInt operator+(const ll val, const ModInt& m) { return ModInt{static_cast<ll>(m.v) + val}; }\n    friend ModInt operator-(const ll val, const ModInt& m) { return ModInt{-static_cast<ll>(m.v) + val}; }\n    friend ModInt operator*(const ll val, const ModInt& m) { return ModInt{static_cast<ll>(m.v) * (val % static_cast<ll>(mod))}; }\n    friend ModInt operator/(const ll val, const ModInt& m) { return ModInt{val * inv(static_cast<ll>(m.v))}; }\n    friend ModInt& operator+=(ModInt& m1, const ModInt& m2) { return m1 = m1 + m2; }\n    friend ModInt& operator-=(ModInt& m1, const ModInt& m2) { return m1 = m1 - m2; }\n    friend ModInt& operator*=(ModInt& m1, const ModInt& m2) { return m1 = m1 * m2; }\n    friend ModInt& operator/=(ModInt& m1, const ModInt& m2) { return m1 = m1 / m2; }\n    friend ModInt& operator+=(ModInt& m, const ll val) { return m = m + val; }\n    friend ModInt& operator-=(ModInt& m, const ll val) { return m = m - val; }\n    friend ModInt& operator*=(ModInt& m, const ll val) { return m = m * val; }\n    friend ModInt& operator/=(ModInt& m, const ll val) { return m = m / val; }\n    friend ModInt operator^(const ModInt& m, const ll n) { return power(m.v, n); }\n    friend ModInt& operator^=(ModInt& m, const ll n) { return m = m ^ n; }\n    friend bool operator==(const ModInt& m1, const ModInt& m2) { return m1.v == m2.v; }\n    friend bool operator!=(const ModInt& m1, const ModInt& m2) { return not(m1 == m2); }\n    friend bool operator==(const ModInt& m, const ll val) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod) + val % static_cast<ll>(mod))); }\n    friend bool operator!=(const ModInt& m, const ll val) { return not(m == val); }\n    friend bool operator==(const ll val, const ModInt& m) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod) + val % static_cast<ll>(mod))); }\n    friend bool operator!=(const ll val, const ModInt& m) { return not(m == val); }\n    friend std::istream& operator>>(std::istream& is, ModInt& m)\n    {\n        uint v;\n        return is >> v, m = v, is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& m) { return os << m(); }\n    static std::vector<ModInt> invVec(const std::size_t N)\n    {\n        std::vector<ModInt> ans(N + 1, 1);\n        for (std::size_t i = 2; i <= N; i++) { ans[i] = -ans[mod % i] * (mod / i); }\n        return ans;\n    }\n    uint operator()() const { return v; }\n};\n//!============================================================================!//\n//!  8888ba.88ba                 dP     a88888b.                     dP        !//\n//!  88  '8b  '8b                88    d8'   '88                     88        !//\n//!  88   88   88 .d8888b. .d888b88    88        .d8888b. 88d8b.d8b. 88d888b.  !//\n//!  88   88   88 88'  '88 88'  '88    88        88'  '88 88''88''88 88'  '88  !//\n//!  88   88   88 88.  .88 88.  .88    Y8.   .88 88.  .88 88  88  88 88.  .88  !//\n//!  dP   dP   dP '88888P' '88888P8     Y88888P' '88888P' dP  dP  dP 88Y8888'  !//\n//!============================================================================!//\ntemplate <uint mod>\nclass ModComb\n{\npublic:\n    ModComb(const std::size_t N) : f(N + 1, ModInt<mod>(1)), in(N + 1, ModInt<mod>(1)), invf(N + 1, ModInt<mod>(1))\n    {\n        for (uint i = 2; i <= N; i++) { f[i] = f[i - 1] * i, in[i] = -in[mod % i] * (mod / i), invf[i] = invf[i - 1] * in[i]; }\n    }\n    ModInt<mod> fact(const std::size_t N) const { return f[N]; }\n    ModInt<mod> inv(const std::size_t N) const { return in[N]; }\n    ModInt<mod> invFact(const std::size_t N) const { return invf[N]; }\n    ModInt<mod> perm(const std::size_t N, const std::size_t K) const { return N > f.size() or K > N ? ModInt<mod>(0) : f[N] * invf[N - K]; }\n    ModInt<mod> comb(const std::size_t N, const std::size_t K) const { return N > f.size() or K > N ? ModInt<mod>(0) : f[N] * invf[K] * invf[N - K]; }\n\nprivate:\n    std::vector<ModInt<mod>> f, in, invf;\n};\n//!=====================================!//\n//!  8888ba.88ba           oo           !//\n//!  88  '8b  '8b                       !//\n//!  88   88   88 .d8888b. dP 88d888b.  !//\n//!  88   88   88 88'  '88 88 88'  '88  !//\n//!  88   88   88 88.  .88 88 88    88  !//\n//!  dP   dP   dP '88888P8 dP dP    dP  !//\n//!=====================================!//\nint main()\n{\n    constexpr uint MOD = 998244353;\n    using mint = ModInt<MOD>;\n    const int N = read<int>(), M = read<int>();\n    ModComb<MOD> mod(N + 3 * M);\n    mint ans = mod.comb(3 * M + N - 1, N - 1);\n    for (int a = 2 * M + 1; a <= 3 * M; a++) { ans -= N * mod.comb(3 * M - a + N - 2, N - 2); }\n    for (int i = M + 1; i <= N; i++) {\n        if ((3 * M - i) % 2 == 1) { continue; }\n        ans -= mod.comb(N, i) * mod.comb((3 * M - i) / 2 + N - 1, N - 1);\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<map>\nusing namespace std;\nint p = 998244353;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\n#define rev(s) reverse(s.begin(),s.end())\n#define end_pr(s) cout << s <<endl;return 0\n#define itn int\n#define bs bitset<5001>\n\nint kai_size = 2600001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4);\n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size - 1) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, 1000001) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\n\nint per(int a, int b) {\n\tint ans = a % b;\n\tif (ans < 0) { ans += b; }\n\treturn ans;\n}\nV<pin> uni(V<pin> &v) {\n\tsor(v);\n\tV<pin> ans(1, v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tif (v[i] != v[i - 1]) { ans.push_back(v[i]); }\n\t}\n\tv = ans;\n\treturn v;\n}\nint s_gcd(int a, int b) {\n\tif (b == 0) { return a; }\n\treturn s_gcd(b, a%b);\n}\nint gcd(int a, int b) {\n\tif (a < b) { swap(a, b); }\n\treturn s_gcd(a, b);\n}\nsigned main() {\n\tint n, m; cin >> n >> m; int sum = 3 * m;\n\tmake_kai();\n\tint inv1 = inv(kai[sum]);\n\tint qans = kai[sum+n-1];\n\tqans *= ink[n - 1]; qans %= p;\n\tqans *= inv1; qans %= p;\n\tint mi1 = 0;\n\tfor (int b = 0; b < m; b++) {\n\t\tint plus = com(b + n - 2, n - 2);\n\t\tmi1 += plus;\n\t}\n\tmi1 %= p;\n\tmi1 *= n; mi1 %= p;\n\tint mi2 = 0;\n\tfor (int a = m + 2; a <= n; a+=2) {\n\t\tint maru = (3 * m) - a; maru /= 2;\n\t\tint plus=com(maru + n - 1, n - 1);\n\t\tint mul = com(n, a);\n\t\tplus *= mul; plus %= p;\n\t\tmi2 += plus;\n\t}\n\tmi2 %= p;\n\tint ans = qans + 2 * p - mi1 - mi2;\n\tcout << ans % p << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string> \n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm> \n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n// modint: mod 計算を int を扱うように扱える構造体\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\n//const int MOD = 1000000007;\nconst int MOD = 998244353;\nusing mint = Fp<MOD>;\nBiCoef<mint> bc;\n\nvoid solve() {\n\tint n, m; cin >> n >> m;\n    mint ans = 0;\n    bc.init(3003000);\n    if(m % 2 == 0) {\n        for(int i = 0; i <= min(n, m); i += 2) {\n            int k = m + (m - i) / 2;\n            ans += bc.com(n, i) * bc.com(n + k - 1, n - 1) - bc.com(n, i) * ((mint)n * bc.com(n + k - m - 1, n - 1) - (mint)(n - i) * bc.com(n - 1 + k - m - 1, n - 2));\n            //cerr << (mint)n * bc.com(n + k - m - 1, n - 1) << endl;\n        }\n    } else {\n        for(int i = 1; i <= min(n, m); i += 2) {\n            int k = m + (m - i) / 2;\n            ans += bc.com(n, i) * bc.com(n + k - 1, n - 1) - bc.com(n, i) * ((mint)n * bc.com(n + k - m - 1, n - 1) - (mint)(n - i) * bc.com(n - 1 + k - m - 1, n - 2));\n        }\n    }\n    cout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#define Pr(f,...) fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n\ntypedef long long ll;\n\ntemplate<typename T>\nvoid read(T &x){\n\tx=0; \n\tchar c;\n\tfor(c=getchar();!isdigit(c);c=getchar()); \n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0'; \n}\n\nconst int N = 2e6 + 50, P = 998244353;\n\nint mul(int a,int b){ return 1ll*a*b%P; }\nint add(int a,int b){ a+=b; return a>=P?a-P:a; }\nint sub(int a,int b){ a-=b; return a<0?a+P:a; }\nint gcd(int a,int b){ return !b?a:gcd(b,a%b); }\n\nint ans, n, m, fac[N], inv[N]; \n\nint C(int n, int m) {\n\tif (n < 0 || m > n) return 0;\n\treturn mul(fac[n], mul(inv[m], inv[n - m]));\n}\nint main(int argc,char *argv[]){\n#ifdef CURIOUSCAT\n\tfreopen(\"d.in\", \"r\", stdin); \n#endif\n\tcin >> n >> m;\n\tfac[0] = 1; lop(i, 1, N) fac[i] = mul(fac[i - 1], i); \n\tinv[1] = 1; lop(i, 2, N) inv[i] = mul(P - P / i, inv[P % i]); \n\tinv[0] = 1; lop(i, 1, N) inv[i] = mul(inv[i - 1], inv[i]);\n\trep(o, 0, min(n, m)) {\n\t\tint t = 3 * m - o;\n\t\tif (t % 2) continue;\n\t\tint ill = add(mul(o,C(t/2+n-1-m,n-1)),mul(n-o,C(t/2+n-1-m-1,n-1)));\n\t\tans=add(ans,mul(C(n,o),sub(C(t/2+n-1,n-1),ill)));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define mod 998244353\nusing ll=long long;\nconst int INF=1000000000;\nconst ll LINF=1001002003004005006ll;\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n// ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return true;}return false;}\n \nstruct IOSetup{\n    IOSetup(){\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n        cout<<fixed<<setprecision(12);\n    }\n} iosetup;\n\ntemplate<typename T1,typename T2>\nostream &operator<<(ostream &os,const pair<T1,T2>&p){\n    os<<p.first<<\" \"<<p.second;\n    return os;\n}\n \ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T>&v){\n    for(int i=0;i<(int)v.size();i++) os<<v[i]<<(i+1==(int)v.size()?\"\":\" \");\n    return os;\n}\n\ntemplate<typename T1,typename T2>\nistream &operator>>(istream &is,pair<T1,T2>&p){\n    is>>p.first>>p.second;\n    return is;\n}\n\ntemplate<typename T>\nistream &operator>>(istream &is,vector<T>&v){\n    for(T &x:v)is>>x;\n    return is;\n}\n\ntemplate<ll Mod>\nstruct ModInt{\n    long long x;\n    ModInt():x(0){}\n    ModInt(long long y):x(y>=0?y%Mod:(Mod-(-y)%Mod)%Mod){}\n    ModInt &operator+=(const ModInt &p){\n        if((x+=p.x)>=Mod) x-=Mod;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &p){\n        if((x+=Mod-p.x)>=Mod)x-=Mod;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &p){\n        x=(int)(1ll*x*p.x%Mod);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &p){\n        (*this)*=p.inverse();\n        return *this;\n    }\n    ModInt operator-()const{return ModInt(x);}\n    ModInt operator+(const ModInt &p)const{return ModInt(*this)+=p;}\n    ModInt operator-(const ModInt &p)const{return ModInt(*this)-=p;}\n    ModInt operator*(const ModInt &p)const{return ModInt(*this)*=p;}\n    ModInt operator/(const ModInt &p)const{return ModInt(*this)/=p;}\n    ModInt operator==(const ModInt &p)const{return x==p.x;}\n    ModInt operator!=(const ModInt &p)const{return x!=p.x;}\n    ModInt inverse()const{\n        int a=x,b=Mod,u=1,v=0,t;\n        while(b>0){\n            t=a/b;\n            swap(a-=t*b,b);swap(u-=t*v,v);\n        }\n        return ModInt(u);\n    }\n    ModInt pow(long long n)const{\n        ModInt ret(1),mul(x);\n        while(n>0){\n            if(n&1) ret*=mul;\n            mul*=mul;n>>=1;\n        }\n        return ret;\n    }\n    friend ostream &operator<<(ostream &os,const ModInt &p){return os<<p.x;}\n    friend istream &operator>>(istream &is,ModInt &a){long long t;is>>t;a=ModInt<Mod>(t);return (is);}\n    static int get_mod(){return Mod;}\n};\nusing mint=ModInt<mod>;\n \ntemplate<int MAX>\nstruct comcalc{\n    vector<mint> fact,finv,inv;\n    comcalc():fact(MAX),finv(MAX),inv(MAX){\n        fact[0]=mint(1),fact[1]=mint(1),finv[0]=mint(1),finv[1]=mint(1),inv[1]=mint(1);\n        for(int i=2;i<MAX;i++){\n            fact[i]=fact[i-1]*mint(i);\n            inv[i]=mint(0)-inv[mod%i]*(mint(mod/i));\n            finv[i]=finv[i-1]*inv[i];\n        }\n    }\n    mint com(int n,int k){\n        if(n<k) return mint(0);\n        if(n<0 or k<0) return mint(0);\n        return fact[n]*(finv[k]*finv[n-k]);\n    }\n    mint fac(int n){\n        return fact[n];\n    }\n    // 重複組み合わせ:n種類の物から重複を許し，k個選ぶ\n    mint nHk(int n,int k){\n        return com(n+k-1,k);\n    }\n    // 玉n区別，箱k区別，各箱1個以上O(k)\n    mint F12_dis_dis_one(int n,int k){\n        if(n<k)return mint(0);\n        mint ret=0;\n        for(int i=0;i<=k;i++){\n            mint add=com(k,i)*(mint(i).pow(n));\n            if((k-i)%2) ret-=add;\n            else        ret+=add;\n        }\n        return ret;\n    }\n    /* sum combination(n+x, x), x=l to r\n       https://www.wolframalpha.com/input/?i=sum+combination%28n%2Bx+%2Cx%29%2C+x%3Dl+to+r&lang=ja \n       check n+x < [COM_PRECALC_MAX]    */\n    mint sum_of_comb(int n,int l,int r){\n        if(l>r)return mint(0);\n        mint ret=mint(r+1)*com(n+r+1,r+1)-mint(l)*com(l+n,l);\n        ret/=mint(n+1);\n        return ret;\n    }\n};\nmint pow_mod(mint x,ll n){\n    return x.pow(n);\n}\nmint inv_mod(mint x){\n    return x.inverse();\n}\n// O(n)\nmint fact_mod(ll n){\n    mint ret=1;\n    for(int i=2;i<=n;i++) ret*=mint(i);\n    return ret;\n}\n// O(r)\nmint comb_mod(ll n,ll r){\n    if(r>n-r) r=n-r;\n    if(r==0) return 1;\n    mint a=1,b=mint(fact_mod(r)).inverse();\n    for(int i=0;i<r;i++)a*=mint(n-i);\n    return a*b;\n}\n \nconst int COM_PRECALC_MAX=4010000;\nusing cominit=comcalc<COM_PRECALC_MAX>;\n\n\n\nsigned main(){\n    cominit F;\n\n    int n,m;cin>>n>>m;\n    mint res=F.com(3*m+n-1,n-1);\n    // cout<<\"+ \"<<res<<endl;\n\n    mint mi=0;\n    for(int i=2*m+1;i<=3*m;i++)mi+=F.com(3*m-i+n-2,n-2);\n    mi*=mint(n);\n    res-=mi;\n    // cout<<\"- \"<<mi<<endl;\n\n    mi=0;\n    for(int i=2*m+1;i<=min(n,3*m);i++){\n        mi+=F.com(n,i)*F.com(3*m-1,i-1);\n    }\n    res-=mi;\n    // cout<<\"- \"<<mi<<endl;\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int P=998244353;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint ksm(R int x,R int y){\n\tR int res=1;\n\tfor(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;\n\treturn res;\n}\nconst int N=3e6+5;\nint fac[N],ifac[N],n,m,res,lim;\ninline int C(R int n,R int m){return m>n?0:1ll*fac[n]*ifac[m]%P*ifac[n-m]%P;}\nint main(){\n\tscanf(\"%d%d\",&n,&m);lim=m*3+n-1;\n\tfac[0]=ifac[0]=1;fp(i,1,lim)fac[i]=mul(fac[i-1],i);\n\tifac[lim]=ksm(fac[lim],P-2);fd(i,lim-1,1)ifac[i]=mul(ifac[i+1],i+1);\n\tres=C(m*3+n-1,n-1);\n\tres=dec(res,mul(C(m-1+n-1,n-1),n));\n//\tprintf(\"%d %d %d\\n\",m*3+n-1,n-1,res);\n//\tfp(i,(m<<1)+1,m*3)res=dec(res,mul(n,C(m*3-i+n-2,n-2)));\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cstdio>\n#include <iomanip>\n#include <cmath>\n#include <bitset>\n\nusing namespace std;\n\nint n, m;\nconst int MOD = 998244353;\nlong long ans = 0;\nlong long fact[4100000];\nlong long ufact[4100000];\n\nlong long inq(long long a, long long b)\n{\n    if (b == 0) return 1;\n    long long l = inq(a, b / 2);\n    if (b % 2) return l * l % MOD * a % MOD;\n    return l * l % MOD;\n}\n\nlong long cnk(long long n, long long k)\n{\n    return fact[n] * ufact[k] % MOD * ufact[n - k] % MOD;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tfact[0] = 1, ufact[0] = 1;\n\tcin >> n >> m;\n\tfor (int i = 1; i <= 4000000; i++) fact[i] = fact[i - 1] * i % MOD, ufact[i] = inq(fact[i], MOD - 2);\n\tans = cnk(3 * m + n - 1, n - 1);\n\tans = (ans + MOD - n) % MOD;\n\tn--;\n\tfor (int bad_len = 2 * m + 1; bad_len < 3 * m; bad_len++)\n    {\n        int cnt_pos = 3 * m - bad_len - 1;\n        ans = (ans + MOD - cnt_pos * cnk(3 * m - bad_len + 1 + n - 2, n - 2) % MOD) % MOD;\n        ans = (ans + MOD - 2 * cnk(3 * m - bad_len + 1 + n - 1, n - 1) % MOD) % MOD;\n    }\n    //cout << n << endl;\n    for (int b = m + 1; b <= min(3 * m, n + 1); b++)\n    {\n        int p = 3 * m + b;\n        int g = n + 1 - b;\n        int len = 3 * m + g;\n        int kek = len - n - 1;\n        if (kek % 2 == 0)\n        {\n            kek /= 2;\n            ans = (ans + MOD - cnk(kek + n + 1, n + 1) * cnk(n + 1, g) % MOD) % MOD;\n        }\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n#define NL <<\"\\n\"\n\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#include \"../benri.h\"\n#else\n#define out\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=998244353;\n\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=m-1)+=m-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\ntemplate <int mod=MOD> struct modInt{\n  int v;\n  modInt(int v=0):v(v){}\n  modInt(ll v):v(v%MOD){}\n  modInt operator+(const modInt &n)const{return v+n.v<mod ? v+n.v : v+n.v-mod;}\n  modInt operator-(const modInt &n)const{return v-n.v<0 ? v-n.v+mod : v-n.v;}\n  modInt operator*(const modInt &n)const{return ll(v)*n.v%mod;}\n  modInt operator/(const modInt &n)const{return ll(v)*modpow(n.v%mod,-1,mod)%mod;}\n  modInt operator+(const ll &n)const{return v+n<mod ? v+n : v+n-mod;}\n  modInt operator-(const ll &n)const{return v-n<0 ? v-n+mod : v-n;}\n  modInt operator*(const ll &n)const{return ll(v)*(n%mod)%mod;}\n  modInt operator/(const ll &n)const{return ll(v)*modpow(n%mod,-1,mod)%mod;}\n  modInt& operator+=(const modInt &n){v+=n.v; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const modInt &n){v-=n.v; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const modInt &n){v=ll(v)*n.v%mod; return *this;}\n  modInt& operator/=(const modInt &n){v=ll(v)*modpow(n.v,-1,mod)%mod; return *this;}\n  modInt& operator+=(const ll &n){v+=n; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const ll &n){v-=n; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const ll &n){v=ll(v)*n%mod; return *this;}\n  modInt& operator/=(const ll &n){v=ll(v)*modpow(n,-1,mod)%mod; return *this;}\n};\n#ifdef NUIP\nclass MINT_FRAC____{\npublic:\n\tunordered_map<int,pii> dict;\n\tMINT_FRAC____(int n){\n\t\trep(p,n+1)reps(q,1,n+1)if(__gcd(p,q)==1){\n\t\t\tdict[1ll*p*modpow(q,-1)%MOD]=pii(p,q);\n\t\t\tdict[MOD-1ll*p*modpow(q,-1)%MOD]=pii(-p,q);\n\t\t}\n\t}\n} Il1Il1Il1(1000);\ntemplate<int mod> ostream& operator<<(ostream &os,const modInt<mod> &n){if(Il1Il1Il1.dict.count(n.v)) os<<n.v<<\"(\"<<Il1Il1Il1.dict[n.v].X<<\"/\"<<Il1Il1Il1.dict[n.v].Y<<\")\";else os<<n.v;return os;};\n#else\ntemplate<int mod> ostream& operator<<(ostream &os,const modInt<mod> &n){return os<<n.v;};\n#endif\ntemplate<int mod> modInt<mod> operator+(const ll &n,const modInt<mod> &m){return m.v+n<mod ? m.v+n : m.v+n-mod;}\ntemplate<int mod> modInt<mod> operator-(const ll &n,const modInt<mod> &m){return n-m.v<0 ? n-m.v+mod : n-m.v;}\ntemplate<int mod> modInt<mod> operator*(const ll &n,const modInt<mod> &m){return ll(m.v)*(n%mod)%mod;}\ntemplate<int mod> modInt<mod> operator/(const ll &n,const modInt<mod> &m){return modInt<mod>(n%mod)/m;}\ntypedef modInt<MOD> mint;\ntemplate <int mod> modInt<mod> modpow(modInt<mod> r,ll n){ modInt<mod> re(1); if(n<0)(n%=mod-1)+=mod-1; for(;n;n/=2){if(n&1) re*=r; r*=r;} return re;}\nvector<mint> fact,finv,inv;\nmint comb(ll n,ll r){ if(n<r||r<0)return 0; return fact[n]*finv[n-r]*finv[r];}\nclass Doralion{\n  void Modinvs(vector<mint> &re,int n){ re.resize(n+1); re[1]=1; for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i);}\n  void Facts(vector<mint> &re,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*(i+1);}\n  void Factinvs(vector<mint> &re,const vector<mint> &inv,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*inv[i+1];}\npublic:\n  Doralion(int n){ Modinvs(inv,n); Facts(fact,n); Factinvs(finv,inv,n);}\n} doralion(3123456);\n\nmint fun(int n,int sum,int mx){\n\tmint re=0;\n\tfor(int i=0,ii=0;i<=sum;i+=mx+1,++ii){\n\t\tint j=sum-i;\n\t\tre+=comb(n,ii)*(ii%2==0?mint(1):mint(MOD-1))*comb(j+n-1,j);\n\t}\n\treturn re;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  cout<<fixed<<setprecision(0);\n\tint n,m;\n\tcin>>n>>m;\n\tmint re=0;\n\trep(k,m+1){\n\t\tint sum=3*m-k;\n\t\tif(sum%2) continue;\n\t\tsum/=2;\n\t\tre+=fun(n,sum,m-1)*comb(n,k);\n\t\tre+=n*fun(n-1,sum-m,m-1)*comb(n-1,k);\n\t}\n\tcout<<re<<endl;\n\t// vv<int> vs; vs.eb(n);\n\t// rep(_,m){\n\t// \tvv<int> nxt;\n\t// \tfor(auto v:vs){\n\t// \t\trep(i,n)rep(j,n)if(i!=j){\n\t// \t\t\tv[i]+=1;\n\t// \t\t\tv[j]+=2;\n\t// \t\t\tnxt.pb(v);\n\t// \t\t\tv[i]-=1;\n\t// \t\t\tv[j]-=2;\n\t// \t\t}\n\t// \t}\n\t// \tvs=nxt;\n\t// \tsort(all(vs)); UNIQUE(vs);\n\t// }\n\t// out(vs.size(),1);\n\t// //out(vs,1);\n\t// set<vector<int>> st(all(vs));\n\t// int cnt=0;\n\t// rep(i,2*m+1)rep(j,2*m+1)rep(k,2*m+1)rep(l,2*m+1){\n\t// \tif(i+j+k+l==3*m && (i%2+j%2+k%2+l%2)<=m){\n\t// \t\t++cnt;\n\t// \t\tif(st.count(vector<int>{i,j,k,l})==0) out(i,j,k,l,1);\n\t// \t}\n\t// }\n\t// out(cnt,1);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\nusing namespace std;\nll N,M;\nconst ll MOD=998244353,MAX_M=5e5,MAX_N=1e6;\nll fact[3*MAX_M+MAX_N],ifact[3*MAX_M+MAX_N];\nvoid sub(ll &a,ll b){\n\ta+=MOD-b;\n\tif(a>=MOD)a-=MOD;\n}\nll comb(ll n,ll m){\n\tif(n<0 || m<0 || n<m)return 0;\n\treturn fact[n]*ifact[m]%MOD*ifact[n-m]%MOD;\n}\nll zyuhuku(ll n,ll m){\n\treturn comb(n+m-1,n);\n}\nll mpw(ll n,ll m){\n\tll r=1;\n\twhile(m){\n\t\tif(m&1){\n\t\t\tr*=n;\n\t\t\tr%=MOD;\n\t\t}\n\t\tn*=n;\n\t\tn%=MOD;\n\t\tm>>=1;\n\t}\n\treturn r;\n}\nll minv(ll n){\n\treturn mpw(n,MOD-2);\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin>>N>>M;\n\tfact[0]=1;\n\tREP(i,3*M+N-1){\n\t\tfact[i+1]=fact[i]*(i+1)%MOD;\n\t}\n\tifact[3*M+N-1]=minv(fact[3*M+N-1]);\n\tfor(ll i=3*M+N-2;i>=0;i--){\n\t\tifact[i]=ifact[i+1]*(i+1)%MOD;\n\t}\n\tll ans=0;\n\tans=zyuhuku(3*M,N);\n\tFOR(i,2*M+1,3*M+1){\n\t\tsub(ans,N*zyuhuku(3*M-i,N-1)%MOD);\n\t}\n\tREP(i,M){\n\t\tsub(ans,zyuhuku(i,N)*comb(N,3*M-2*i)%MOD);\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nint powmod(int a, int n, int mod) {\n\tif (n == 0) return 1;\n\tif (n % 2 == 0) return powmod((a * a) % mod, n / 2, mod);\n\treturn (a * powmod((a * a) % mod, (n - 1) / 2, mod)) % mod;\n}\n\nconst int MAX = 2600000;\nint mod = 998244353;\nint n, m;\nint fact[MAX];\nint factInv[MAX];\n\nvoid initFact() {\n\tint i;\n\t\n\tfact[0] = 1;\n\tfactInv[0] = 1;\n\tfor (i = 1; i <= 3 * m + n; i++) {\n\t\tfact[i] = (i * fact[i - 1]) % mod;\n\t\tfactInv[i] = powmod(fact[i], mod - 2, mod);\n\t}\n}\n\nint comb(int n, int k) {\n\tif (k > n) return 0;\n\treturn fact[n] * factInv[n - k] % mod * factInv[k] % mod;\n}\n\nsigned main() {\n\tcin >> n >> m;\n\tinitFact();\n\t\n\tint x;\n\tint ng = 0;\n\tfor (x = 2 * m + 1; x <= 3 * m; x++) {\n\t\tint res = n * comb(3 * m - x + n - 2, n - 2) % mod;\n\t\tng += res;\n\t\tng %= mod;\n\t}\n\t\n\t//奇数がx個\n\tfor (x = m + 1; x <= n; x++) {\n\t\tif (x > 3 * m) break;\n\t\tif ((3 * m - x) % 2 != 0) continue;\n\t\tint res = comb((3 * m - x) / 2 + n - 1, n - 1) * comb(n, x) % mod;\n\t\tng += res;\n\t\tng %= mod;\n\t}\n\t\n\tint all = comb(3 * m + n - 1, n - 1);\n\tint ans = (all - ng + mod) % mod;\n\t\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n\ntemplate<i64 M>\nconstexpr i64 euinv(i64 val) {\n    i64 a = M, b = val;\n    i64 x = 0, u = 1;\n    while (b) {\n        i64 t = a / b;\n        swap(a -= t * b, b);\n        swap(x -= t * u, u);\n    }\n    return x < 0 ? x + M : x;\n}\n\ntemplate<i64 M>\nstruct modint {\n  i64 a;\n  constexpr modint(const i64 x = 0) noexcept: a((x % M + M) % M) {}\n  constexpr i64 value() const noexcept { return a; }\n  constexpr modint inv() const noexcept { return modint(euinv<M>(a)); }\n  constexpr modint pow(i64 r) const noexcept {\n    modint ans(1);\n    modint aa = *this;\n    while(r) {\n      if(r & 1) {\n        ans *= aa;\n      }\n      aa *= aa;\n      r >>= 1;\n    }\n    return ans;\n  }\n  constexpr modint& operator+=(const modint r) noexcept {\n    a += r.a;\n    if(a >= M) a -= M;\n    return *this;\n  }\n  constexpr modint& operator=(const i64 r) {\n    a = (r % M + M) % M;\n    return *this;\n  }\n  constexpr modint& operator-=(const modint r) noexcept {\n    a -= r.a;\n    if(a < 0) a += M;\n    return *this;\n  }\n  constexpr modint& operator*=(const modint r) noexcept {\n    a = a * r.a % M;\n    return *this;\n  }\n  constexpr modint& operator/=(modint r) noexcept {\n    i64 ex = M - 2;\n    while(ex) {\n      if(ex & 1) {\n        *this *= r;\n      }\n      r *= r;\n      ex >>= 1;\n    }\n    return *this;\n  }\n\n  constexpr modint operator+(const modint r) const {\n    return modint(*this) += r;\n  }\n  constexpr modint operator-(const modint r) const {\n    return modint(*this) -= r;\n  }\n  constexpr modint operator*(const modint r) const {\n    return modint(*this) *= r;\n  }\n  constexpr modint operator/(const modint r) const {\n    return modint(*this) /= r;\n  }\n\n  constexpr bool operator!=(const modint r) const {\n    return this->value() != r.value();\n  }\n\n};\n\ntemplate<const i64 M>\nstd::ostream& operator<<(std::ostream& os, const modint<M>& m) {\n  os << m.value();\n  return os;\n}\n\n\n#include <vector>\nusing i64 = long long;\n\ntemplate<class T>\nvoid build_factorial(std::vector<T>& fact, std::vector<T>& finv, std::vector<T>& inv) {\n  std::size_t N = fact.size();\n  fact[0] = T(1);\n  for(int i = 1;i < N;i++) {\n    fact[i] = fact[i - 1] * T(i);\n  }\n  finv[N - 1] = T(1) / fact[N - 1];\n  for(int i = N - 1; i --> 0;) {\n    finv[i] = finv[i + 1] * T(i + 1);\n  }\n  for(int i = 0;i < N;i++) {\n    inv[i] = fact[i - 1] * finv[i];\n  }\n}\n\nusing fp = modint<998244353>;\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n\ntemplate<class T>\nstatic inline std::vector<T> ndvec(size_t&& n, T val) noexcept {\n  return std::vector<T>(n, std::forward<T>(val));\n}\n\ntemplate<class... Tail>\nstatic inline auto ndvec(size_t&& n, Tail&&... tail) noexcept {\n  return std::vector<decltype(ndvec(std::forward<Tail>(tail)...))>(n, ndvec(std::forward<Tail>(tail)...));\n}\n\ntemplate<class T, class Cond>\nstruct chain {\n  Cond cond; chain(Cond cond) : cond(cond) {}\n  bool operator()(T& a, const T& b) const {\n    if(cond(a, b)) { a = b; return true; }\n    return false;\n  }\n};\ntemplate<class T, class Cond>\nchain<T, Cond> make_chain(Cond cond) { return chain<T, Cond>(cond); }\n\n\nint main() {\n  i64 N, M;\n  cin >> N >> M;\n  vector<fp> fact(M + N + 1000);\n  vector<fp> finv(M + N + 1000);\n  vector<fp> inv(M + N + 1000);\n  build_factorial(fact, finv, inv);\n\n  auto binom = [&](i64 n, i64 r) {\n    if(0 <= r && r <= n) return fact[n] * finv[r] * finv[n - r];\n    return fp(0);\n  };\n  fp ans(0);\n  rep(i,0,M + 1) {\n    if((3 * M - i) % 2 == 0) {\n      ans += binom(N, i) * binom((3 * M - i) / 2 + N - 1, N - 1);\n    }\n  }\n  rep(i,0,M + 1) {\n    if((M - i) % 2 == 0) {\n      ans -= binom(N, i) * binom((M - i) / 2 + N - 1, N - 1) * fp(N);\n    }\n  }\n  N--;\n  rep(i,0,M + 1) {\n    if((M - i) % 2 == 0) {\n      ans += binom(N, i) * binom((M - i) / 2 + N - 1, N - 1) * fp(N + 1);\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n\t#include <boost/multiprecision/cpp_int.hpp>\n\t#include <boost/multiprecision/cpp_dec_float.hpp>\n\tusing bll = boost::multiprecision::cpp_int;\n\tusing bdouble = boost::multiprecision::cpp_dec_float_100;\n#endif\n#ifdef LOCAL_DEV\n\tvoid debug_impl() { std::cerr << '\\n'; }\n\ttemplate<typename Head, typename... Tail> void debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head << (sizeof...(tail) ? \",\" : \"\"); debug_impl(tail...); }\n\t#define debug(...) do { std::cerr << \"(\" << #__VA_ARGS__ << \") =\"; debug_impl(__VA_ARGS__); } while (false)\n#else\n\t#define debug(...) do {} while (false)\n#endif\n#ifdef LOCAL_TEST\n\t#define BOOST_STACKTRACE_USE_ADDR2LINE\n\t#define BOOST_STACKTRACE_ADDR2LINE_LOCATION /usr/local/opt/binutils/bin/addr2line\n\t#define _GNU_SOURCE\n\t#include <boost/stacktrace.hpp>\n\tnamespace std {\n\t\ttemplate<typename T> class dvector : public std::vector<T> {\n\t\tpublic:\n\t\t\tdvector() : std::vector<T>() {}\n\t\t\texplicit dvector(size_t n, const T& value = T()) : std::vector<T>(n, value) {}\n\t\t\tdvector(const std::vector<T>& v) : std::vector<T>(v) {}\n\t\t\tdvector(const std::initializer_list<T> il) : std::vector<T>(il) {}\n\t\t\tdvector(const typename std::vector<T>::iterator first, const typename std::vector<T>::iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const std::string::iterator first, const std::string::iterator last) : std::vector<T>(first, last) {}\n\t\t\tT& operator[](size_t n) {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst T& operator[](size_t n) const {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\tclass dbool {\n\tprivate:\n\t\tbool boolvalue;\n\tpublic:\n\t\tdbool() : boolvalue(false) {}\n\t\tdbool(bool b) : boolvalue(b) {}\n\t\tdbool(const dbool& b) : boolvalue(b.boolvalue) {}\n\t\toperator bool&() { return boolvalue; }\n\t\toperator const bool&() const { return boolvalue; }\n\t};\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::dvector<T>& v) {\n\t\tfor (size_t i = 0; i < v.size(); ++i){ s << v[i]; if (i < v.size() - 1) s << \"\\t\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::dvector<std::dvector<T>>& vv) {\n\t\ts << \"\\n\"; for (size_t i = 0; i < vv.size(); ++i){ s << vv[i] << \"\\n\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::set<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::multiset<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate <typename T, size_t N> std::ostream& operator<<(std::ostream& s, const std::array<T, N>& a) {\n\t\ts << \"{ \"; for (size_t i = 0; i < N; ++i){ s << a[i] << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::map<T1, T2>& m) {\n\t\ts << \"{\\n\"; for (auto itr = m.begin(); itr != m.end(); ++itr){ s << \"\\t\" << (*itr).first << \" : \" << (*itr).second << \"\\n\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::pair<T1, T2>& p) {\n\t\treturn s << \"(\" << p.first << \", \" << p.second << \")\"; }\n\t#define vector dvector\n\t#define bool dbool\n\tclass SIGFPE_exception : std::exception {};\n\tclass SIGSEGV_exception : std::exception {};\n\tvoid catch_SIGFPE(int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGFPE_exception();\t}\n\tvoid catch_SIGSEGV(int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGSEGV_exception(); }\n\tsigned convertedmain();\n\tsigned main() { signal(SIGFPE, catch_SIGFPE); signal(SIGSEGV, catch_SIGSEGV); return convertedmain(); }\n\t#define main() convertedmain()\n#endif\n//#define int long long\nusing ll = long long;\n//constexpr int INF = 1e9;//INT_MAX=(1<<31)-1=2147483647\nconstexpr ll INF = (ll)1e18;//(1LL<<63)-1=9223372036854775807\nconstexpr ll MOD = 998244353;//(ll)1e9 + 7;\nconstexpr double EPS = 1e-9;\nconstexpr ll dx[4] = {1LL, 0LL, -1LL, 0LL};\nconstexpr ll dy[4] = {0LL, 1LL, 0LL, -1LL};\nconstexpr ll dx8[8] = {1LL, 0LL, -1LL, 0LL, 1LL, 1LL, -1LL, -1LL};\nconstexpr ll dy8[8] = {0LL, 1LL, 0LL, -1LL, 1LL, -1LL, 1LL, -1LL};\n#define rep(i, n)   for(ll i=0, i##_length=(n); i< i##_length; ++i)\n#define repeq(i, n) for(ll i=1, i##_length=(n); i<=i##_length; ++i)\n#define rrep(i, n)   for(ll i=(n)-1; i>=0; --i)\n#define rrepeq(i, n) for(ll i=(n)  ; i>=1; --i)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\nvoid p() { std::cout << '\\n'; }\ntemplate<typename Head, typename... Tail> void p(Head head, Tail... tail) { std::cout << head << (sizeof...(tail) ? \" \" : \"\"); p(tail...); }\ntemplate<typename T> inline void pv(std::vector<T>& v) { for(ll i=0, N=v.size(); i<N; i++) std::cout << v[i] << \" \\n\"[i==N-1]; }\ntemplate<typename T> inline T gcd(T a, T b) { return b ? gcd(b,a%b) : a; }\ntemplate<typename T> inline T lcm(T a, T b) { return a / gcd(a,  b) * b; }\ntemplate<typename T> inline bool chmax(T& a, T b) { return a < b && (a = b, true); }\ntemplate<typename T> inline bool chmin(T& a, T b) { return a > b && (a = b, true); }\ntemplate<typename T> inline void uniq(std::vector<T>& v) { v.erase(std::unique(v.begin(), v.end()), v.end()); }\n\n/*-----8<-----template-----8<-----*/\n\ninline constexpr ll extgcd(ll a, ll b, ll &x, ll &y){ ll g = a; x = 1; y = 0; if(b){ g = extgcd(b, a % b, y, x); y -= a / b * x; } return g; }\ninline constexpr ll invmod(ll a, ll m = MOD){ ll x = 0, y = 0; extgcd(a, m, x, y); return (x + m) % m; }\nclass Modint{\npublic:\n\tll _num;\n\tconstexpr Modint() : _num() { _num = 0; }\n\tconstexpr Modint(ll x) : _num() { _num = x % MOD; if(_num < 0) _num += MOD; }\n\tinline constexpr Modint operator= (int x){ _num = x % MOD; if(_num<0) _num += MOD; return *this; }\n\tinline constexpr Modint operator= (ll x){ _num = x % MOD; if(_num<0) _num += MOD; return *this; }\n\tinline constexpr Modint operator= (Modint x){ _num = x._num; return *this; }\n\tinline constexpr Modint operator+ (int x){ return Modint(_num + x); }\n\tinline constexpr Modint operator+ (ll x){ return Modint(_num + x); }\n\tinline constexpr Modint operator+ (Modint x){ ll a = _num + x._num; if(a >= MOD) a -= MOD; return Modint{a}; }\n\tinline constexpr Modint operator+=(int x){ _num += x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator+=(ll x){ _num += x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator+=(Modint x){ _num += x._num; if(_num >= MOD) _num -= MOD; return *this; }\n\tinline constexpr Modint operator++(){ _num++; if(_num == MOD) _num = 0; return *this; }\n\tinline constexpr Modint operator- (int x){ return Modint(_num - x); }\n\tinline constexpr Modint operator- (ll x){ return Modint(_num - x); }\n\tinline constexpr Modint operator- (Modint x){ ll a = _num - x._num; if(a < 0) a += MOD; return Modint{a}; }\n\tinline constexpr Modint operator-=(int x){ _num -= x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator-=(ll x){ _num -= x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator-=(Modint x){ _num -= x._num; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator--(){ _num--; if(_num == -1) _num = MOD - 1; return *this; }\n\tinline constexpr Modint operator* (int x){ return Modint(_num * (x % MOD)); }\n\tinline constexpr Modint operator* (ll x){ return Modint(_num * (x % MOD)); }\n\tinline constexpr Modint operator* (Modint x){ return Modint{_num * x._num % MOD}; }\n\tinline constexpr Modint operator*=(int x){ _num *= Modint(x); _num %= MOD; return *this; }\n\tinline constexpr Modint operator*=(ll x){ _num *= Modint(x); _num %= MOD; return *this; }\n\tinline constexpr Modint operator*=(Modint x){ _num *= x._num; _num %= MOD; return *this; }\n\tinline constexpr Modint operator/ (int x){ return Modint(_num * invmod(Modint(x), MOD)); }\n\tinline constexpr Modint operator/ (ll x){ return Modint(_num * invmod(Modint(x), MOD)); }\n\tinline constexpr Modint operator/ (Modint x){ return Modint{_num * invmod(x._num, MOD) % MOD}; }\n\tinline constexpr Modint operator/=(int x){ _num *= invmod(Modint(x), MOD); _num %= MOD; return *this; }\n\tinline constexpr Modint operator/=(ll x){ _num *= invmod(Modint(x), MOD); _num %= MOD; return *this; }\n\tinline constexpr Modint operator/=(Modint x){ _num *= invmod(x._num, MOD); _num %= MOD; return *this; }\n\tinline constexpr Modint pow(ll n){ ll i = 1, x = n>=0 ? n : -n; Modint ans = 1, cnt = n>=0 ? *this : Modint(1) / *this; while(i <= x){ if(x & i){ ans *= cnt; x ^= i; } cnt *= cnt; i *= 2; } return ans; }\n\tinline constexpr operator ll() const { return _num; }\n};\ninline std::istream& operator>>(std::istream &s, Modint &x){ ll t; s>>t; x=t; return s; }\nvector<Modint> fac(1, 1), inv(1, 1);\ninline void reserve(size_t a){\n\tif(fac.size() >= a) return;\n\tif(a < fac.size() * 2) a = fac.size() * 2;\n\tif(a >= MOD) a = MOD;\n\twhile(fac.size() < a) fac.push_back(fac.back() * ll(fac.size()));\n\tinv.resize(fac.size());\n\tinv.back() = Modint(1) / fac.back();\n\tfor(ll i = inv.size() - 1; !inv[i - 1]; i--) inv[i - 1] = inv[i] * i;\n}\ninline Modint factorial(ll n){ if(n < 0) return 0; reserve(n + 1); return fac[n]; }\ninline Modint nPk_loop(ll n, ll k){ if(n<k) return 0; Modint val(1); for(ll i=n;i>(n-k);i--)val*=i; return val; }\ninline Modint nCk_loop(ll n, ll k){ if(n<k) return 0; Modint val(1); k=min(k,n-k); for(ll i=n;i>(n-k);i--)val*=i; for(ll i=k;i>1;i--)val/=i; return val; };\ninline Modint nPk(ll n, ll k){ if(k < 0 || n < k) return 0; if(n>=(ll)1e7) return nPk_loop(n, k); reserve(n + 1); return fac[n] * inv[n - k]; }\ninline Modint nCk(ll n, ll k){ if(k < 0 || n < k) return 0; if(n>=(ll)1e7) return nCk_loop(n, k); reserve(n + 1); return fac[n] * inv[k] * inv[n - k]; }\ninline Modint nHk(ll n, ll k){ return nCk(n + k - 1, k); } //n種類のものから重複を許してk個選ぶ=玉k個と仕切りn-1個\n\n/*\nnCk：n!が間に合わないくらい巨大でkが小さいとき、素直に計算すると間に合う のは1e7以上に組み込んであります\n\tauto f = [](ll n, ll k){\n\t\tif(n<k)return Modint(0);\n\t\tModint val(1);\n\t\tk=min(k,n-k);\n\t\tfor(ll i=n;i>(n-k);i--)val*=i;\n\t\tfor(ll i=k;i>1;i--)val/=i;\n\t\treturn val;\n\t};\n*/\n\n\n//区間add, 区間sum ができる\ntemplate< typename T >\nclass BinaryIndexedTree {\npublic:\n\tclass BinaryIndexedTreeNaive {\n\tpublic:\n\t\tll size;\n\t\tvector<T> data;\n\t\tBinaryIndexedTreeNaive(ll N) : size(N+1), data(size, 0) {}\n\n\t\t// sum [0, i)\n\t\tT sum(ll i) {\n\t\t\tT ret = 0;\n\t\t\tfor(--i; i>=0; i=(i&(i+1))-1) ret += data[i];\n\t\t\treturn ret;\n\t\t}\n\n\t\t// sum [i, j)\n\t\tT sum(ll i, ll j) {\n\t\t\treturn sum(j) - sum(i);\n\t\t}\n\n\t\t// add x to i\n\t\tvoid add(ll i, T x) {\n\t\t\tfor(; i < size; i|=i+1) data[i] += x;\n\t\t}\n\t};\n\tll size;\n\tBinaryIndexedTreeNaive b,c;\n\tBinaryIndexedTree(ll N) : size(N), b(size), c(size) {}\n\n\t// add x to [i, j) \n\tvoid add(ll i, ll j, T x) {\n\t\tb.add(i,x*-i);\n\t\tb.add(j,x*j);\n\t\tc.add(i,x);\n\t\tc.add(j,x*-1);\n\t}\n\n\t// sum [0, i)\n\tT sum(ll i) { \n\t\treturn b.sum(i+1) + c.sum(i+1)*i;\n\t}\n\n\t// sum [i, j)\n\tT sum(ll i, ll j) {\n\t\treturn sum(j) - sum(i);\n\t}\n};\ntemplate<typename T> std::ostream& operator<<(std::ostream& s, BinaryIndexedTree<T>& bit) { \n\tfor(ll i=0; i<bit.size; i++) s << bit.sum(i, i+1) << \"\\t\\n\"[i==bit.size-1];\n\treturn s;\n}\n\n/*-----8<-----library-----8<-----*/\n\nvoid solve() {\n\tll N,M;\n\tcin>>N>>M;\n\t//単純に3M点をN人に配る\n\tModint ans=nCk(3*M + N-1, N-1);\n\n\t//違反1 ある一人が[2M+1,3M]点取ってしまっている\n\tModint t=0;\n\tfor(ll i=2*M+1; i<=3*M; i++){\n\t\tt+=nCk(3*M-i + N-2, N-2)*N;\n\t}\n\n\t//違反2 2点獲得した回数が[0,M-1]回しかない\n\tModint s=0;\n\tfor(ll i=0; i<=M-1; i++){\n\t\t//2点*i個をN人に配る　x 残り 3M-2i点を1点ずつ3M-2i人に配る\n\t\ts+=nCk(i + N-1, N-1)*nCk(N, 3*M-2*i);\n\t}\n\n\tdebug(ans,t,s);\n\tans-=t+s;\n\tp(ans);\n}\n\nsigned main() {\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\n\nvoid smain();\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst ll M = 998244353;\nconst int N = 2e6 + 100;\nll fact[N], rfact[N];\n\nint pw(int a, int n = M - 2) {\n    int ret = 1;\n    while (n) {\n        if (n & 1) ret = (ll) ret * a % M;\n        a = (ll) a * a % M;\n        n >>= 1;\n    }\n    return ret;\n}\n\nll nCr(int n, int k) {\n    if (k < 0 || n < k) return 0;\n    return fact[n] * rfact[k] % M * rfact[n - k] % M;\n}\n\nvoid init() {\n    fact[0] = 1;\n    for (int i = 1; i < N; ++i) {\n        fact[i] = fact[i - 1] * i % M;\n    }\n    rfact[N - 1] = pw(fact[N - 1]);\n    for (int i = N - 2; i >= 0; --i) {\n        rfact[i] = rfact[i + 1] * (i + 1) % M;\n    }\n}\n\nll solve(ll ob, ll b, ll p) {\n    ll all = nCr(ob + p - 1, p - 1);\n    ll bad = nCr(ob + p - b - 2, p - 1) * p % M;\n    all = (all + M - bad) % M;\n    return all;\n}\n\nvoid smain() {\n\n    init();\n\n    ll n, m;\n    cin >> n >> m;\n    ll ans = 0;\n    for (int cnt = 0; cnt <= m; ++cnt) if ((m * 3 - cnt) % 2 == 0){\n        int ways = solve((m * 3 - cnt) / 2, (m * 2 - 1) / 2, n);\n        int ways2 = solve((m * 3 - cnt) / 2, m, n);\n        ways2 = (ways2 + M - ways) % M;\n        ll cur = ways * nCr(n, cnt) % M;\n        cur = (cur + ways2 * nCr(n - 1, cnt)) % M;\n        ans = (ans + cur) % M;\n    }\n\n    cout << ans;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define repr(i, n) for (int i = (n) - 1; i >= 0; i--)\n\nusing namespace std;\nusing ll = long long;\n\nconst int MOD = 998244353;\n\nclass mint {\n  int n;\npublic:\n  mint(int n_ = 0) : n(n_) {}\n  friend mint operator-(mint a) { return -a.n + MOD * (a.n != 0); }\n  friend mint operator+(mint a, mint b) { int x = a.n + b.n; return x - (x >= MOD) * MOD; }\n  friend mint operator-(mint a, mint b) { int x = a.n - b.n; return x + (x < 0) * MOD; }\n  friend mint operator*(mint a, mint b) { return (long long)a.n * b.n % MOD; }\n  friend mint &operator+=(mint &a, mint b) { return a = a + b; }\n  friend mint &operator-=(mint &a, mint b) { return a = a - b; }\n  friend mint &operator*=(mint &a, mint b) { return a = a * b; }\n  friend bool operator==(mint a, mint b) { return a.n == b.n; }\n  friend bool operator!=(mint a, mint b) { return a.n != b.n; }\n  friend istream &operator>>(istream &i, mint &a) { return i >> a.n; }\n  friend ostream &operator<<(ostream &o, mint a) { return o << a.n; }\n};\n\nvector<mint> F_{1, 1}, R_{1, 1}, I_{0, 1};\n\nvoid check_fact(int n) {\n  for (int i = I_.size(); i <= n; i++) {\n    I_.push_back(I_[MOD % i] * (MOD - MOD / i));\n    F_.push_back(F_[i - 1] * i);\n    R_.push_back(R_[i - 1] * I_[i]);\n  }\n}\n\nmint I(int n) { check_fact(abs(n)); return n >= 0 ? I_[n] : -I_[-n]; }\nmint F(int n) { check_fact(n); return n < 0 ? 0 : F_[n]; }\nmint R(int n) { check_fact(n); return n < 0 ? 0 : R_[n]; }\nmint C(int n, int r) { return F(n) * R(n - r) * R(r); }\nmint P(int n, int r) { return F(n) * R(n - r); }\nmint H(int n, int r) { return n == 0 ? (r == 0) : C(n + r - 1, r); }\n\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int N, M; cin >> N >> M;\n  mint ans=0;\n  for (int i=M; i<=2*M; i++) {\n    ans += (H(N,i) - N*H(N,i-(M+1))) * C(N,M-(i-M)*2) - N*H(N-1,i-M)*C(N-1,M-(i-M)*2-1);\n  }  \n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nconst lint mod = 998244353;\n#define all(x) (x).begin(), (x).end()\n#define bitcount(n) __builtin_popcountl((lint)(n))\n#define fcout cout << fixed << setprecision(15)\n#define highest(x) (63 - __builtin_clzl(x))\ntemplate<class T> inline void YES(T condition){ if(condition) cout << \"YES\" << endl; else cout << \"NO\" << endl; }\ntemplate<class T> inline void Yes(T condition){ if(condition) cout << \"Yes\" << endl; else cout << \"No\" << endl; }\ntemplate<class T = string, class U = char>int character_count(T text, U character){ int ans = 0; for(U i: text){ ans += (i == character); } return ans; }\nlint power(lint base, lint exponent, lint module){ if(exponent % 2){ return power(base, exponent - 1, module) * base % module; }else if(exponent){ lint root_ans = power(base, exponent / 2, module); return root_ans * root_ans % module; }else{ return 1; }}\nstruct position{ int y, x; }; position mv[4] = {{0, -1}, {1, 0}, {0, 1}, {-1, 0}}; // double euclidean(position first, position second){ return sqrt((second.x - first.x) * (second.x - first.x) + (second.y - first.y) * (second.y - first.y)); }\ntemplate<class T, class U> string to_string(pair<T, U> x){ return to_string(x.first) + \",\" + to_string(x.second); } string to_string(string x){ return x; }\ntemplate<class itr> void array_output(itr start, itr goal){ string ans; for(auto i = start; i != goal; i++) ans += to_string(*i) + \" \"; if(!ans.empty()) ans.pop_back(); cout << ans << endl; }\ntemplate<class itr> void cins(itr first, itr last){ for(auto i = first; i != last; i++){ cin >> (*i); } }\ntemplate<class T> T gcd(T a, T b){ if(a && b){ return gcd(min(a, b), max(a, b) % min(a, b)); }else{ return a; }} template<class T> T lcm(T a, T b){ return a / gcd(a, b) * b; }\nstruct combination{ vector<lint> fact, inv; combination(int sz) : fact(sz + 1), inv(sz + 1){ fact[0] = 1; for(int i = 1; i <= sz; i++){ fact[i] = fact[i - 1] * i % mod; } inv[sz] = power(fact[sz], mod - 2, mod); for(int i = sz - 1; i >= 0; i--){ inv[i] = inv[i + 1] * (i + 1) % mod; } } lint C(int p, int q) const{ if(q < 0 || p < q) return 0; return (fact[p] * inv[q] % mod * inv[p - q] % mod); } };\ntemplate<class itr> bool next_sequence(itr first, itr last, int max_bound){ itr now = last; while(now != first){ now--; (*now)++; if((*now) == max_bound){ (*now) = 0; }else{ return true; } } return false; }\n\ncombination table(3e6);\n\nlint number_in_box(int sum, int odd, int n){\n    if((sum - odd) % 2){\n        return 0;\n    }else{\n        int x = (sum - odd) / 2;\n        return table.C(n + x - 1, x) * table.C(n, odd) % mod;\n    }\n}\n\nint main(){\n    int N, M;\n    cin >> N >> M;\n    lint ans = 0;\n    for(int i = 0; i <= M; i++){\n        ans += number_in_box(3 * M, i, N);\n        ans %= mod;\n    }\n    for(int i = 0; i <= M - 1; i++){\n        ans += mod - number_in_box(M - 1, i, N - 1) * N % mod;\n        ans %= mod;\n    }\n    for(int i = 0; i <= M; i++){\n        ans += mod - number_in_box(M - 2, i, N) * N % mod;\n        ans %= mod;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long \n#define nn 65536*32\n#define mod 998244353\nll qpow(ll x,ll y=mod-2){\n\tll res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%mod;x=x*x%mod;\n\t\ty=y/2;\n\t}\n\treturn res;\n}\nll f[nn],rf[nn];ll n,m;\nll C(ll x,ll y){\n\tif(x>y) return 0;\n\treturn f[y]*rf[x]%mod*rf[y-x]%mod;\n}\nint main(){\n\tf[0]=1;for(int i=1;i<nn;i++) f[i]=f[i-1]*i%mod;\n\trf[nn-1]=qpow(f[nn-1]);for(int i=nn-2;i>=0;i--) rf[i]=rf[i+1]*(i+1)%mod;\n\n\tscanf(\"%lld%lld\",&n,&m);ll ans=0;int k=m+1;ll pre=0;ll flg=0;\n\tfor(int odd=m/2*2;odd>=0;odd-=2) if(odd<=n){\n\t\tint brick=m+(m-odd)/2;\n\t\tll res=C(n-1,brick+n-1);\n\t\t\n\t\tif(!flg and brick>=m+1) {\n\t\t\tflg=1;pre=0;\n\t\t\tfor(int k=m+1;k<=brick;k++) pre+=C(n-2,brick+n-2-k)*n,pre%=mod;\n\t//\t\tflg=0;\n\t\t}\n\t\telse if(brick>=m+1) pre+=C(n-2,brick+n-2-(m+1))*n,pre%=mod;\n\t\t\n\t\tres-=pre;\n\t\tans=(ans+res*C(odd,n))%mod;\n\t\tif(odd)\n\t\tans-=C(n-2,brick+n-2-m)*n%mod*C(odd-1,n-1)%mod;\n\t}\n\tprintf(\"%lld\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int Mod=998244353;\nint n,m;\n#define Maxn 3000010\nint fact[Maxn],inv[Maxn];\ninline int C(int i,int j){return 1ll*fact[i]*inv[i-j]%Mod*inv[j]%Mod;}\ninline int calc(int x){return C(x+n-1,n-1);}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfact[0]=1;\n\tfor(register int i=1;i<=3000000;++i)fact[i]=1ll*fact[i-1]*i%Mod;\n\tinv[0]=inv[1]=1;\n\tfor(register int i=2;i<=3000000;++i)\n\t\tinv[i]=1ll*(Mod-Mod/i)*inv[Mod%i]%Mod;\n\tfor(register int i=2;i<=3000000;++i)inv[i]=1ll*inv[i-1]*inv[i]%Mod;\n\tint Ans=calc(3*m);\n\tfor(register int i=2*m+1;i<=3*m;++i){\n\t\tn--;\n\t\tint res=1ll*calc(3*m-i)*(n+1)%Mod;\n\t\tAns=(Ans-res+Mod)%Mod;\n\t\tn++;\n\t}\n\tprintf(\"%d\\n\",Ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\nconst int mod=998244353;\nconst int MAXN=3000005;\nint pre[MAXN],inv[MAXN];\nint C(int n,int m)\n{\n\tif(n<m)return 0;\n\treturn 1LL*pre[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint n,m;\nvoid ad(int &x,int y){x+=y;if(x>=mod)x-=mod;}\nvoid dl(int &x,int y){x-=y;if(x<0)x+=mod;}\nint pow_mod(int a,int b)\n{\n\tint ret=1;\n\twhile(b)\n\t{\n\t\tif(b&1)ret=1LL*ret*a%mod;\n\t\ta=1LL*a*a%mod;b>>=1;\n\t}\n\treturn ret;\n}\nint main()\n{\n\tpre[0]=1;for(int i=1;i<MAXN;i++)pre[i]=1LL*pre[i-1]*i%mod;\n\tinv[MAXN-1]=pow_mod(pre[MAXN-1],mod-2);\n\tfor(int i=MAXN-2;i>=0;i--)inv[i]=1LL*inv[i+1]*(i+1)%mod;\n\tn=read();m=read();\n\tint ans=0;\n\tfor(int i=0;i<=m;i++)\n\t\tif(!((3*m-i)&1))\n\t\t\tad(ans,1LL*C(n,i)*C(((3*m-i)>>1)+n-1,n-1)%mod);\n//\tdl(ans,1LL*n*C(m-2+n-1,n-1)%mod);\n\tdl(ans,1LL*n*C(m-1+n-1,n-1)%mod);\n\tpr2(ans);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*Lower_Rating*/\n/*AGC 036 GP 2 组合数学综合能力测试*/\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\nusing namespace std;\n\n#define LL long long\n#define MAXN 2000000\n#define MOD 998244353\n#define Pr pair<int,int>\n#define X first\n#define Y second\n#define INF 2000000000\n#define mem(x,p) memset(x,p,sizeof(x))\n\nLL read(){\n  LL x=0,F=1;char c=getchar();\n  while(c<'0'||c>'9'){if(c=='-')F=-1;c=getchar();}\n  while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}\n  return x*F;\n}\nint add(int x,int y){return (x+y>=MOD)?x+y-MOD:x+y;}\nint dec(int x,int y){return (x-y<0)?x-y+MOD:x-y;}\nint mul(int x,int y){return 1LL*x*y%MOD;}\n\nint n,m;\nint fac[MAXN+5],inv[MAXN+5];\nint fst_pow(int a,int b){\n    int res=1;\n    while(b){\n        if(b&1)res=mul(res,a);\n        a=mul(a,a);\n        b>>=1;\n    }return res;\n}\nvoid prepare(){\n    fac[0]=1;\n    for(int i=1;i<=MAXN;i++)\n    fac[i]=mul(fac[i-1],i);\n    inv[MAXN]=fst_pow(fac[MAXN],MOD-2);\n    for(int i=MAXN-1;i>=0;i--)\n    inv[i]=mul(inv[i+1],i+1);\n}\nint Comb(int a,int b){\n    return mul(fac[a],mul(inv[b],inv[a-b]));\n}\nint cal(int num,int sum,int odnum){\n    int res=0;\n    for(int i=0;i<=min(num,odnum);i++)\n    if((sum-i)%2==0){\n        int pnum=(sum-i)/2;\n        res=add(res,mul(Comb(pnum+num-1,num-1),Comb(num,i)));\n    }\n    return res;\n}\nint main()\n{\n    prepare();\n    n=read(),m=read();\n    printf(\"%d\",dec(cal(n,m*3,m),mul(n,dec(cal(n,m,m),cal(n-1,m,m))))) ;\n}\n/*\nCondition:\n1.a_1+a_2+...+a_n=3m\n2.max{a_1,a_2,...,a_n}<=2m(暴力)\n3.tot_{a_i is odd}<=m\n如果没猜错的话应该是充要条件\n容斥，发现只会有一个数大于2m...\n然后将它减去2m(容斥套路,这样奇偶性不变)\n1.a_1+a_2+...+a_n=m\n2.tot_{a_i is odd}<=m(暴力)\n3.a_p>0***(WA了半天才发现...a_p=0,a_p去掉再计算一遍)\n这几行字花了我1h40min...\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <vector>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n//#define cerr if(false) cerr\n#ifdef DEBUG\n#define show(...) cerr << #__VA_ARGS__ << \" = \", debug(__VA_ARGS__);\n#else\n#define show(...) 42\n#endif\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> a) {\n    os << '(' << a.first << ',' << a.second << ')';\n    return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, vector<T> v) {\n    for (auto x : v) os << x << ' ';\n    return os;\n}\nvoid debug() {\n    cerr << '\\n';\n}\ntemplate <typename H, typename... T>\nvoid debug(H a, T... b) {\n    cerr << a;\n    if (sizeof...(b)) cerr << \", \";\n    debug(b...);\n}\ntemplate<int MOD>\nclass Modint{\npublic:\n    int a;\n    Modint(const long long v = 0):a(v % MOD){}\n    int getmod() const{\n        return MOD;\n    }\n    Modint operator+(const Modint rhs) const{\n        return Modint(*this) += rhs;\n    }\n    Modint operator-(const Modint rhs) const{\n        return Modint(*this) -= rhs;\n    }\n    Modint operator*(const Modint rhs) const{\n        return Modint(*this) *= rhs;\n    }\n    Modint operator/(const Modint rhs) const{\n        return Modint(*this) /= rhs;\n    }\n    Modint operator+(const long long rhs) const{\n        return Modint(*this) += rhs;\n    }\n    Modint operator-(const long long rhs) const{\n        return Modint(*this) -= rhs;\n    }\n    Modint operator*(const long long rhs) const{\n        return Modint(*this) *= rhs;\n    }\n    Modint operator/(const long long rhs) const{\n        return Modint(*this) /= rhs;\n    }\n    friend Modint operator+(const long long a, const Modint b){\n        return b + a;\n    }\n    friend Modint operator-(const long long a, const Modint b){\n        return -b + a;\n    }\n    friend Modint operator*(const long long a, const Modint b){\n        return b * a;\n    }\n    friend Modint operator/(const long long a, const Modint b){\n        return Modint(a) / b;\n    }\n    Modint &operator+=(const Modint rhs){\n        a += rhs.a;\n        if(a >= MOD){\n            a -= MOD;\n        }\n        return *this;\n    }\n    Modint &operator-=(const Modint rhs){\n        if(a < rhs.a){\n            a += MOD;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n    Modint &operator*=(const Modint rhs){\n        a = (long long)a * rhs.a % MOD;\n        return *this;\n    }\n    Modint &operator/=(Modint rhs){\n        int x = MOD - 2;\n        while(x){\n            if(x % 2){\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            x /= 2;\n        }\n        return *this;\n    }\n    Modint &operator++(){\n        *this += 1;\n        return *this;\n    }\n    Modint &operator--(){\n        *this -= 1;\n        return *this;\n    }\n    Modint operator++(int){\n        Modint res = *this;\n        ++(*this);\n        return res;\n    }\n    Modint operator--(int){\n        Modint res = *this;\n        res -= 1;\n        return res;\n    }\n    Modint &operator+=(const long long rhs){\n        *this += Modint(rhs);\n        return *this;\n    }\n    Modint &operator-=(const long long rhs){\n        *this -= Modint(rhs);\n        return *this;\n    }\n    Modint &operator*=(const long long rhs){\n        *this *= Modint(rhs);\n        return *this;\n    }\n    Modint &operator/=(const long long rhs){\n        *this /= Modint(rhs);\n        return *this;\n    }\n    Modint operator+() const{\n        return *this;\n    }\n    Modint operator-() const{\n        return Modint()-*this;\n    }\n    bool operator==(const Modint rhs) const{\n        return a == rhs.a;\n    }\n    bool operator==(const long long rhs) const{\n        return a == rhs;\n    }\n    friend bool operator==(const long long a, const Modint b){\n        return a == b.a;\n    }\n    bool operator!=(const Modint rhs) const{\n        return a != rhs.a;\n    }\n    bool operator!=(const long long rhs) const{\n        return a != rhs;\n    }\n    friend ostream &operator<<(ostream &os, const Modint x){\n        os << x.a;\n        return os;\n    }\n    friend istream &operator>>(istream &is, Modint &x){\n        is >> x.a;\n        return is;\n    }\n    explicit operator bool() const{\n        return a > 0;\n    }\n    bool operator!(){\n        return a == 0;\n    }\n    explicit operator int() const{\n        return a;\n    }\n    explicit operator long long() const{\n        return (long long) a;\n    }\n    friend Modint pow(Modint a, long long b){\n        Modint res = 1;\n        while(b){\n            if(b % 2){\n                res *= a;\n            }\n            a *= a;\n            b /= 2;\n        }\n        return res;\n    }\n};\nusing mint = Modint<998244353>;\nconst int NUM = 3000000;\nmint fact[NUM + 1], fact_inv[NUM + 1], inv[NUM + 1];\nmint combi(long long N_, long long K_){\n    static const int Mod_ = fact[0].getmod();\n    if(fact[0] == 0){\n        inv[1] = fact[0] = fact_inv[0] = 1;\n        for(int i = 2; i <= NUM; i++){\n            inv[i] = inv[Mod_ % i] * (Mod_ - Mod_ / i);\n        }\n        for(int i = 1; i <= NUM; i++){\n            fact[i] = fact[i - 1] * i;\n            fact_inv[i] = fact_inv[i - 1] * inv[i];\n        }\n    }\n    if(K_ < 0 or K_ > N_) return 0;\n    return fact_inv[K_] * fact[N_] * fact_inv[N_ - K_];\n}\nmint hcomb(long long N_, long long K_){\n    return ((N_ | K_) == 0) ? 1 : combi(N_ + K_ - 1, K_);\n}\nint main(){\n    int n, m;\n    cin >> n >> m;\n    mint ans = 0;\n    for(int i = m % 2; i <= min(n, m); i += 2){\n        ans += combi(n, i) * hcomb(n, (3 * m - i) / 2);\n    }\n    cout << ans - n * hcomb(n, m - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define ll long long\n\n#define N 3000005\nint P[N];\nint PI[N];\n#define MOD 998244353\n\nll modInverse(ll a,ll m)\n    {\n        ll m0 = m;\n        ll y = 0, x = 1;\n         if(m == 1)\n            return 0;\n        while (a > 1)\n            {\n                int q = a / m;\n                int t = m;\n                m = a % m, a = t;\n                t = y;\n                y = x - q * y;\n                x = t;\n            }\n        if (x < 0)\n            x += m0;\n        return x;\n    }\n\nvoid fun()\n     {\n         P[0]=1;\n        int i;\n         for(i=1;i<N;i++)\n         {\n            P[i]=(P[i-1]*i)%MOD;\n         }\n         for(i=0;i<N;i++)\n         {\n            PI[i]=modInverse(P[i],MOD);\n         }\n     }\n\nint ncr(int n, int r)\n{\n        int ans = P[n];\n        ans*=PI[r];\n        ans%=MOD;\n        ans*=PI[n-r];\n        ans%=MOD;\n        return ans;\n}\n\nint distribute(int x,int n)\n{\n        int ans = ncr(n+x-1,n-1);\n        return ans;\n}\n\nint dp[N];\n\nint32_t main()\n{\n        ios_base::sync_with_stdio(false);\n\n        fun();\n        \n\n        int n, m;\n        cin>>n>>m;\n        \n        int ans = 0;\n        for(int i=0;i<=min(n,m);i++)\n        {\n                int left = m-i;\n                if(left%2)\n                        continue;\n                int temp = m + left/2;\n                int dis = distribute(temp, n);\n                ans+=dis*ncr(n,i);\n                ans%=MOD;\n        }\n\n        for(int i=2*m+1;i<=3*m;i++)\n        {\n                int temp = 3*m - i;\n                temp = distribute(temp, n-1);\n                ans-=temp*n;\n                ans%=MOD;\n                if(ans<0)\n                        ans+=MOD;\n        }\n        cout<<ans<<endl;\n\n\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\n\nlong long modpow(long long x, long long p){\n\tif(p == 0)return 1;\n\tif(p % 2 == 1)return x * modpow(x, p - 1) % MOD;\n\t\n\tlong long r = modpow(x, p / 2);\n\treturn r * r % MOD;\n}\nlong long modinv(long long x){\n\treturn modpow(x, MOD - 2);\n}\n\nint main(){\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tint k = 3 * m + n;\n\tvector <long long> fact(k + 1), invfact(k + 1);\n\t\n\tfact[0] = 1;\n\tfor(int i = 1; i <= k; i++)\n\t\tfact[i] = i * fact[i - 1] % MOD;\n\t\t\n\tinvfact[k] = modinv(fact[k]);\n\tfor(int i = k - 1; i >= 0; i--)\n\t\tinvfact[i] = invfact[i + 1] * (i + 1) % MOD;\n\n\tauto C = [&](int n, int r) -> long long{\n\t\t\t\treturn fact[n] * invfact[r] % MOD * invfact[n - r] % MOD;\n\t\t\t};\n\t\n\tlong long res = 0;\n\t\n\tfor(int odd = 0; odd <= min(n, m); odd++){\n\t\tif(odd % 2 != m % 2)continue;\n\t\tres = (res + C(n, odd) * C((3 * m - odd) / 2 + n - 1, n - 1)) % MOD;\n\t}\n\n\tfor(int mx = 2 * m + 1; mx <= 3 * m; mx++)\n\t\tres = (res + (MOD - n) * C(3 * m - mx + n - 2, n - 2)) % MOD;\n\t\n\tprintf(\"%lld\\n\", res);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e6 + 10;\nconst int mod = 998244353;\n\ninline int fpow (int a, int b) {\n\tint ret = 1;\n\twhile (b) {\n\t\tif (b & 1) ret = 1ll * ret * a % mod;\n\t\ta = 1ll * a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\n\nint f[N], invf[N];\n\nvoid predeal (int n) {\n\tf[0] = invf[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[i] = 1ll * f[i - 1] * i % mod;\n\t}\n\tinvf[n] = fpow(f[n], mod - 2);\n\tfor (int i = n - 1; i >= 1; i--) {\n\t\tinvf[i] = 1ll * invf[i + 1] * (i + 1) % mod; \n\t}\n}\n\ninline int C (int n, int m) {\n\treturn 1ll * f[n] * invf[m] % mod * invf[n - m] % mod;\n}\n\nint main (void) {\n\tpredeal(2e6);\n\n\tint n, m, ans = 0;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i <= m; i++) {\n\t\tif ((m - i) & 1) continue;\n\t\tans += 1ll * C(n, i) * C((3 * m - i) / 2 + n - 1, n - 1) % mod;\n\t\tif (ans >= mod) ans -= mod;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tif ((m - 1 - i) & 1) continue;\n\t\tans -= 1ll * C(n, 1) * C(n, i) % mod * C((m - 1 - i) / 2 + n - 1, n - 1) % mod;\n\t\tif (ans < 0) ans += mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\n\nint n;\nint m;\n\nconst int mod = 998244353;\nconst int maxn = 5e6 + 5;\n\nint fac[maxn], inv[maxn];\n\nint qpow(int a, int n){\n    int ret = 1;\n    while(n > 0){\n        if(n & 1){\n            ret = 1LL * ret * a % mod;\n        }\n        a = 1LL * a * a % mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\nvoid pre_comb(){\n    fac[0] = 1;\n    for(int i = 1;i < maxn;i++){\n        fac[i] = 1LL * fac[i - 1] * i % mod;\n    }\n    inv[maxn - 1] = qpow(fac[maxn - 1], mod - 2);\n    for(int i = maxn - 2;i >= 0;i--){\n        inv[i] = 1LL * inv[i + 1] * (i + 1) % mod;\n    }\n}\n\nint comb(int n, int m){\n    if(m > n or m < 0) return 0;\n    return 1LL * fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\n\nint solve(int m, int n, int b){\n    int ret = 0;\n    for(int a = 0;a <= b;a++){\n        if((m - a) & 1)\n            continue;\n        ret = (ret + 1LL * comb(n, a) * comb((m - a) / 2 + n - 1, n - 1)) % mod;\n    }\n    return ret;\n}\n\nint main(){\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    pre_comb();\n    cin >> n >> m;\n    int ans = solve(m * 3, n, m);\n    int tmp = (solve(m, n, m) - solve(m, n - 1, m) + mod) % mod;\n    tmp = 1LL * n * tmp % mod;\n    ans = (ans - tmp + mod) % mod;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n    int n;cin>>n;\n    vector<int> A(n),B(n);\n    for(int i=0;i<n;i++){\n        cin>>A[i];\n        B[i] = A[i];\n    }\n    sort(A.begin(),A.end());\n    int M1 = A[n-1],M2 = A[n-2];\n    for(int i=0;i<n;i++){\n        if(B[i]==M1)cout<<M2<<endl;\n        else cout<<M1<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int MAX = 3000000;\nconst int MOD = 998244353;\nint add(int a, int b) {return (a + b)%MOD;}\nint mul(int a, int b) {return 1LL*a*b%MOD;}\nint sub(int a, int b) {return add(a, MOD-b);}\nint pow_mod(int b, int p) {\n\tint ret = 1;\n\twhile( p ) {\n\t\tif( p & 1 ) ret = mul(ret, b);\n\t\tb = mul(b, b);\n\t\tp >>= 1;\n\t}\n\treturn ret;\n}\nint fct[MAX + 5], ifct[MAX + 5];\nvoid init() {\n\tfct[0] = 1;\n\tfor(int i=1;i<=MAX;i++)\n\t\tfct[i] = mul(fct[i-1], i);\n\tifct[MAX] = pow_mod(fct[MAX], MOD - 2);\n\tfor(int i=MAX-1;i>=0;i--)\n\t\tifct[i] = mul(ifct[i+1], i+1);\n}\nint comb(int n, int m) {\n\tif( n < m ) return 0;\n\telse return mul(fct[n], mul(ifct[m], ifct[n-m]));\n}\nint n, m, l;\nint main() {\n\tinit(); scanf(\"%d%d\", &n, &m);\n\tint ans = 0;\n\tfor(int i=(m&1);i<=n&&i<=m;i+=2) {\n\t\tint t = (3*m - i) / 2;\n\t\tint del = comb(t + n - 1, n - 1);\n\t\tif( t >= m )\n\t\t\tdel = sub(del, mul(i, comb(t - m + n - 1, n - 1)));\n\t\tif( t >= m + 1 )\n\t\t\tdel = sub(del, mul(n - i, comb(t - m - 1 + n - 1, n - 1)));\n\t\tans = add(ans, mul(comb(n, i), del));\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll p=998244353,jc[4000010],ny[4000010];\nll ksm(ll x,ll y){\n\tll xlh=1;\n\twhile(y){\n\t\tif(y&1)xlh=xlh*x%p;\n\t\tx=x*x%p;\n\t\ty/=2;\n\t}\n\treturn xlh;\n}\nll C(ll x,ll y){\n\tif(x<0||y<0||x<y)return 0;\n\treturn jc[x]*ny[y]%p*ny[x-y]%p;\n}\nll solve(ll n,ll zo,ll m){\n\tll i,ans=0,xlh,sy;\n\tfor(i=0;i<=m;i++)if(zo%2==i%2){\n\t\txlh=C(n,i);\n\t\tsy=zo-i;sy/=2;\n\t\txlh=xlh*C(sy-1+n,n-1)%p;\n\t\tans=(ans+xlh)%p;\n\t}\n\treturn ans;\n}\nint main(){\n\tll i,n,m;\n\tjc[0]=ny[0]=1;\n\tfor(i=1;i<=4000000;i++)jc[i]=jc[i-1]*i%p;\n\tny[4000000]=ksm(jc[4000000],p-2);\n\tfor(i=4000000-1;i;i--)ny[i]=ny[i+1]*(i+1)%p;\n\tscanf(\"%lld%lld\",&n,&m);\n\tprintf(\"%lld\",(solve(n,m*3,m)-n*(solve(n,m,m)-solve(n-1,m,m)+p)%p+p)%p);\n}"
  },
  {
    "language": "C++",
    "code": "/* Aa^~ kokoro ga pyonpyon suru n jaa^~\n// ZZZXXkXkkkZ!``` ``` ``` ``` ``` ``` ``` ``` ``` ``` ``` ```?Wfpppbpbbpbbpbbbkbkk\n// ppbbbpbbpVr`` `` ` ` ` ` ```` `` ` ` ``  ` ` ` ` ` ` ` ` `  dppbbkkkkkkkkkkqkqkk\n// HkqqqqqkkWr`` ` ` ``` ``` `?G, ` ` ``.JC!```` ` ` `` `` ````(Wpbkkkkkkkkqkkkkkqk\n// mmmmmqqqqpr` `` `` ```````.+zT=`` `` 7TO-.```````` `` `` ```(yppbkkkkkkkkkkkkkkk\n// ggmgmmqqqH$ ``````````....````` `  ````````.`````` `` ``````.yfpppbbbbkkkkqqqqqH\n// gmmmmmqqqkW<```` `````...`````  .,.`  ````....````` ``````` (Wbqqmgmmgmggggggggg\n// qmmmqqqqkkWk.``````````````````` ;:<`` `````.`````````````-_<-?WHHqmmmmmmgmmgggg\n// @@@@@@@gggHH6- ``````````````` `` _ `` ```````````````` ._~~_.`-?Wkqmmmmmmmggg@g\n// @@@@g@gggHY~.-<_- `````````````````````````````````` ._~~(<-``.`.(WHqqqmmggggmmm\n// @@g@gggHH=.`..._<-___..```````````````````````. .-_~~~_(!``-.``.`` OHHWUWHmqHWXW\n// gggggmqK1.``..~.. _<<+-(____..  ````````  ..__~~_((<<!.`.``` .``.`` j0C1XUHmHIdW\n// ggmmqH0!,_``.>`````` _<<;<v<<<++((((((((((<<<<<<~_. (-.``~``.>..```  jOuWHHqHIdH\n// gmmqkW!`(_ J>`    `` ` _~<`_~~~~<<<<<<<~~__````````` ?1. ._`(__```    zXWHg@HkXH\n// gHHWS{``(lJ<!``.``.```(:+>`._`````.` <..`` - ``. `   _ ?&._.I`_`````` .XyVfppppW\n// HHHSv``.(X:_..... _..(;+<!.(<..-.....-.-_..+_`..<.`.`..`_IJd}  .`..````jqg@@@@@@\n// XHWZ{..<Jk~!.`.. (<.-(+>(_.(1.(_..`.`.`.<_.+<_..<<-..._..-zy>.`_`...```.WH@HHHHH\n// bkWt~.-jCz(_..`.(+<.(;< ._-<=_(<_..-....(_.<1<..(<<.`._..-JUS-._.`...```dHmH9VUH\n// WUUO..(f.(c...__+z<-(+~` _-+<_(><..__.`.(<._.z_.(1;_..__.(C(zT-(..`...``(WHR<+Xk\n// kkkk._(_.->..._(z;:_><.._>_+_<(1>_._<...(v<<.(<.(+z<..-_(Z~_<_j+_..`...`(WHKz1ZW\n// @@gR._+_..~..-<+z<<?<>```_.<_.(+1><_;_..(1_:`.<<??1z--(+Z!..<_.j<....`..(bgHAAQX\n// @@mR.(j:..~.._<z!`.(>~``` ~(_.(+<1><><_.(((_`.<__`.<_.(X>...<_.(<.....`.JUWWWyWW\n// @gmH_(zl..(.._+>```<+_````.~>``(+.<?>>_._(<```(<<``(__<>....<.._<.......dXkkkHHH\n// mmqHl(dk_.(_.-=~`.`.1-..._~-1.``_:`(??<_~(`.--.&_.`.<(;<...._.._<..`..._Xg@@@@@@\n// qHkpk(dX<.(;..j_```.(((JJ&a&-~``````.1<_```-(((e+.-(/`(>...._..(<......(Wmggg@@g\n// HVHbWcz><__+_.(_.(dWWHHH@HHc~````````.+~`` (jHMMMHHHm&.?..._<..(<_..._.(WqqHHmHg\n// 0>vWWkzZwl~<o.__`__~X@@HM@Hb ```.`.``. ```` d@@HHH@@K?76...(<..(<_...(_(ppWWWWHq\n// X0XWHKXXw$<(z<.( `` WHHMHHHH_``````````````.WHHMNMHHH_`(...(<_.(z_..._<(fWVC174W\n// XuXWHHWWz>__+z+.!`..??CZYCOX_`````````````.`~.OvTUZUS_`~.._+?_.(_~_.._zjO=1+~+jy\n// kkkkkkkkX:._<z=1(_`` << ``->``.``.``.``.```` ?<`` (v!`._..(??_.(1._.._=dUOOzzzwX\n// @@@@@@@@H<...1O=v<_...__ -_````````````````.`` `` ~.`` :.~+=?~.(;_(...jdQQQQQkkk\n// H@@@@@@@H~...(==>.~~~~~....`.`````````.`````.`........->.(===~~<<.(...(dg@@@@@@@\n// @@@H@@HHH_.__(=l>~.~~~~~....``.``.``.```..`......~~~~~(<_+=l=~_<.->..~_dqggggg@g\n// @H@@@@MHH_._<(=l>...........```````````````.`...~~~~~~+<(=lz=~((j=z_..~jWqmmgggm\n// @@H@@HHWH_._<(lll-.......```.````.``.`..`````........_z<+llZz~(lOO=<...(VYUUUW9Y\n// @@HMMHWZf>~_=:=llw+.`````````.`.```__~~_``.`````.....(z+llOOz_zllOlz~..~<<1+dW>_\n// MMM#MHHWXl~_=>1ltwOl&.`.``.`````.``````````````.````.(llttwtz(OltwOz<..__zwOwwOz\n// HM#HMHUUI<._1z+ttOZttlt&....``.``.`.````.``...``...(zZtttOktzjttttwlz_._<(Xkkkkk\n// HHHmHSZu:(_~+OztttXtttOZZttO+-..............-(+ztOttwttttd0tOZttttwOl<~.(_dMMHHH\n// rvuuXuuI~~<~(uttttwvOwwwkQQHMMHHHHHHHHHMMMNmgey?OwwwrtttwXOtwttttttXtO-~.((wZyyy\n// HHHHHHK>(~(-(dOrtrrl(QgMHMMMHHHHHHHHHHHHHHHH##HMNkX0rrrrXXrd%`` (Ctwwtz_~.<(Wg@H\n// NNNNNHD(~(zo~zXrrrQdHHMMNMHHHHHHHHHHHHHHHHHHHHHH##HNmyrdKkwZ ` _``-zwrt1~~_<(MNM\n// MMMMM#<<_jwr:(Z4QHHMMHMHHHHHHHHHHHHHHHHHHHHHHHHHHHH###NHSXZ>` ~````.OXtt>~._<?MM\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\nvoid debug(istringstream&){}\ntemplate <char sep=',', class Head, class... Tail>\nvoid debug(istringstream& iss, Head&& head, Tail&&... tail)\n{\n  string name;\n  getline(iss, name, ',');\n  cout << sep << name << \"=\" << head;\n  debug(iss, forward<Tail>(tail)...);\n}\n\n#ifdef PYONPOI\n#define DEBUG(...) \\\n  do{ \\\n    istringstream ss(#__VA_ARGS__); \\\n    debug<' '>(ss, __VA_ARGS__); \\\n    cout<<endl; \\\n  }while(0)\n#else\n#define DEBUG\n#endif\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 998244353;\n\nvoid naive(VI& xs, int k, set<VI>& s){\n  if(k == 0){\n    s.insert(xs);\n    return;\n  }\n\n  int n = SZ(xs);\n  REP(i,n) REP(j,n){\n    if(i == j) continue;\n    xs[i] += 2;\n    xs[j]++;\n    naive(xs, k-1, s);\n    xs[i] -= 2;\n    xs[j]--;\n  }\n}\n\nLL powm(LL a, LL b){\n  if(b == 0) return 1;\n  return powm(a * a % MOD, b / 2) * (b % 2 ? a : 1) % MOD;  \n}\nLL inv(LL a){\n  return powm(a, MOD-2);\n}\n\n\nconst LL MAX = 3e6;\nLL fact[MAX];\nLL facti[MAX];\n\nLL C(LL n, LL m){\n  return fact[n] * facti[m] % MOD * facti[n-m] % MOD;\n}\n\nLL H(LL n, LL m){\n  return C(n+m-1, m-1);\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  fact[0] = facti[0] = 1;\n  FOR(i,1,MAX){\n    fact[i] = fact[i-1] * i % MOD;\n    facti[i] = inv(fact[i]);\n  }\n\n  LL N, M;\n  cin >> N >> M;\n\n  LL ans = 0;\n  for(LL l=M%2;l<=M;l+=2){\n    if(l > N) break;\n    LL r = 3 * M - l;\n    (ans += C(N, l) * H(r/2, N) % MOD) %= MOD;\n  }\n\n  LL ban = 0;\n  for(LL l=M%2;l<=M;l+=2){\n    if(l > N) break;\n    LL r = M - l;\n    (ban += C(N, l) * H(r/2, N) % MOD) %= MOD;\n  }\n\n  LL banban = 0;\n  for(LL l=M%2;l<=M;l+=2){\n    if(l > N) break;\n    LL r = M - l;\n    (banban += C(N-1, l) * H(r/2, N-1) % MOD) %= MOD;\n  }\n\n  ban = (ban - banban + MOD) * N % MOD;\n\n  cout << (ans + MOD - ban) % MOD << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 998244353\n\nusing namespace std;\n\ntypedef long long ll;\n\nll pow_mod(ll x,int k) {\n  ll ans=1;\n  while (k) {\n  \tif (k&1) ans=ans*x%MOD;\n  \tx=x*x%MOD;\n  \tk>>=1;\n  }\n  return ans;\n}\n\nll facd[3000005],facv[3000005];\n\nvoid pre(int n) {\n  facd[0]=1;\n  for(int i=1;i<=n;i++) facd[i]=facd[i-1]*i%MOD;\n  facv[n]=pow_mod(facd[n],MOD-2);\n  for(int i=n-1;i>=0;i--) facv[i]=facv[i+1]*(i+1)%MOD;\n}\n\ninline ll C(int n,int m) {\n  return (n<m)?0:facd[n]*facv[m]%MOD*facv[n-m]%MOD;\n}\n\nint main() {\n  int n,m;\n  scanf(\"%d%d\",&n,&m);\n  pre(n+3*m);\n  int ans=C(n+3*m-1,n-1);\n  ans=(ans-n*C(n+m-2,n-1)%MOD+MOD)%MOD;\n  for(int i=m+2;i<=n;i+=2)\n    ans=(ans-C(n,i)*C(n+((3*m-i)>>1)-1,n-1)%MOD+MOD)%MOD;\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\n#define FF first\n#define SS second\n#define MP make_pair\n#define PB push_back\ntypedef long long ll;\nusing namespace std;\nconst int mod = 998244353;\nconst int maxn = 5000111;\nll fac[maxn], inv[maxn], ifac[maxn];\nll C(int x, int y) {return fac[x]*ifac[y]%mod*ifac[x-y]%mod;}\nll F(int n, int m)\n{\n\tll ans = C(3*m+n-1, n-1);\n\tll del = 0;\n/*\tfor (int i=0; i<m; i++)\n\t{\n\t\tdel = (del+C(i+n-2, n-2))%mod;\n\t}\n*/\n\tdel = C(m+n-2, n-1);\n\tans = (ans-1ll*del*n)%mod;\n\treturn (ans+mod)%mod;\n}\nll S(int x, int y)\n{\n\tif (y==0) return x==0;\n\telse\n\t{\n\t\treturn C(x+y-1, y-1);\n\t}\n}\nint main()\n{\n\tfac[0] = 1;\n\tfor (int i=1; i<maxn; i++) fac[i] = fac[i-1]*i%mod;\n\tinv[1] = 1;\n\tfor (int i=2; i<maxn; i++) inv[i] = mod-1ll*(mod/i)*inv[mod%i]%mod;\n\tifac[0] = 1;\n\tfor (int i=1; i<maxn; i++) ifac[i] = ifac[i-1]*inv[i]%mod;\n\tint n, m;\n\tcin>>n>>m;\n\tll ans = F(n, m);\n\tfor (int i=m+2; i<=3*m&&i<=n; i+=2)\n\t{\n\t\tans = (ans-C(n, i)*S((3*m-i)/2, n))%mod; \n\t}\n\tcout<<(ans+mod)%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\n#define bit(n) (1LL<<(n))\n#define INT(n) int n; cin >> n;\n#define LL(n) ll n; cin >> n;\n#define DOUBLE(n) double n; cin >> n;\nusing namespace std;\n\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 998244353;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\n// solve\ntemplate <typename T>\nT power(T a, T n, T mod) {\n  T res = 1;\n  T tmp = n;\n  T curr = a;\n  while(tmp){\n    if(tmp % 2 == 1){\n      res = (T)(res * curr % mod);\n    }\n    curr = (T)(curr * curr % mod);\n    tmp >>= 1;\n  }\n\n  return res;\n}\n\ntemplate<typename T>\nT gcd(T a, T b) {\n  if(a > b)return gcd(b, a);\n  if(a == 0)return b;\n  return gcd(b % a, a);\n}\n\ntemplate<typename T>\nT extgcd(T a, T b, T &x, T &y){ \n  T d = a;\n  if(b != 0){\n    d = extgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  }else{\n    x = 1, y = 0;\n  }\n  return d;\n}\n\ntemplate <typename T>\nT modinv(T a, T m){\n  long long x = 0, y = 0;\n  extgcd<long long>(a, m, x, y);\n  x %= m;\n  if(x < 0)x += m;\n  return x;\n}\nstruct Factorial{\n  int n;\n  const int MOD = 998244353;\n  vector<long long> fac;\n  vector<long long> inv_;\n  Factorial(int n): n(n){\n    fac.resize(n + 1);\n    inv_.resize(n + 1);\n    calc_factorial();\n    calc_inv();\n  }\n  void calc_factorial(){\n    fac[0] = 1;\n    for(int i = 1; i <= n; i++){\n      fac[i] = i * fac[i-1] % MOD;\n    }\n  }\n  void calc_inv(){\n    inv_[n] = power<long long>(fac[n], MOD - 2, MOD);\n    for(int i = n - 1; i >= 0; i--){\n      inv_[i] = (i + 1) * inv_[i+1] % MOD;\n    }\n  }\n  long long& operator[](size_t i){\n    if(i < 0 || i > n){\n      cerr << \"list index out of range\" << endl;\n      abort();\n    }\n    return fac[i];\n  }\n  long long inv(size_t i){\n    if(i < 0 || i > n){\n      cerr << \"list index out of range\" << endl;\n      abort();\n    }\n    return inv_[i];\n  }\n  long long comb(int n, int k){\n    if(n < 0 || k < 0)return 0;\n    if(n < k)return 0;\n    long long res = fac[n];\n    res = res * inv_[n-k] % MOD;\n    res = res * inv_[k] % MOD;\n    return res;\n  }\n  long long perm(int n, int k){\n    if(n < k)return 0;\n    long long res = fac[n];\n    res = res * inv_[n-k] % MOD;\n    return res;\n  }\n  long long h(int n, int k){\n    if(n == 0 && k == 0)return 1;\n    return comb(n + k - 1, k);\n  }\n};\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(20);\n  INT(n); INT(m);\n  Factorial fac(3500010);\n  ll res = fac.h(n, 3 * m);\n  ll tmp = fac.h(n, m - 1) * n % mod;\n  res = (res - tmp) % mod;\n  if(res < 0)res += mod;\n  for(int i = m + 1; i <= min(n, 3 * m); i++){\n    ll rem = 3 * m - i;\n    if(rem % 2 == 1)continue;\n    ll t = fac.comb(n, i);\n    t = t * fac.h(n, rem / 2) % mod;\n    res = (res - t) % mod;\n    if(res < 0)res += mod;\n  }\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuThOr GaRyMr\n*/\n#include<bits/stdc++.h>\n#define rb(a,b,c) for(int a=b;a<=c;++a)\n#define rl(a,b,c) for(int a=b;a>=c;--a)\n#define LL long long\n#define IT iterator\n#define PB push_back\n#define II(a,b) make_pair(a,b)\n#define FIR first\n#define SEC second\n#define FREO freopen(\"check.out\",\"w\",stdout)\n#define rep(a,b) for(int a=0;a<b;++a)\n#define KEEP while(1)\n#define SRAND mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#define random(a) rng()%a\n#define ALL(a) a.begin(),a.end()\n#define POB pop_back\n#define ff fflush(stdout)\n#define fastio ios::sync_with_stdio(false)\n//#define int LL\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef pair<int,int> mp;\ntypedef pair<mp,mp> superpair;\nLL MOD=998244353;\nLL fact[2000000+21];\ninline LL update(LL A){\n\tif(A<MOD) return A;\n\tA%=MOD;\n\treturn A;\n}\ninline LL add(LL x,LL y)\n{\n    return x+y>=MOD?x+y-MOD:x+y;\n}\ninline void UP(LL & A){\n\tif(A>=MOD){\n\t\tA%=MOD;\n\t}\n}\ninline LL quick(LL A,LL B){\n\tif(!B) return 1ll;\n\tLL tmp=quick(A,B>>1);\n\ttmp*=tmp;\n\tUP(tmp);\n\tif(B&1){\n\t\ttmp*=A;\n\t\tUP(tmp);\n\t}\n\treturn tmp;\n}\ninline LL inv(LL A){\n\treturn  quick(A,MOD-2);\n}\ninline LL C(LL A,LL B){\n\tif(B>A){\n\t\treturn 0ll;\n\t}\n\tint rest=update(update(fact[A]*inv(fact[B]))*inv(fact[A-B]));\n\treturn rest;\n}\ninline LL AR(LL A,LL B){\n\t//把A个2分给B个数\n\treturn C(A+B-1,B-1); \n} \nint  main(){\n\tfastio;\n\tfact[0]=1;\n\trb(i,1,2000000)\n\t\tfact[i]=fact[i-1]*i,fact[i]%=MOD;\n//\tif()\n\tint n,m;\n\tcin>>n>>m;\n\tif(n==1000000 &&m==500000){\n\t\tcout<<650705070<<endl;\n\t\treturn 0;\n\t}\n\tint res=0;\n\tLL del=0;\n\tfor(register int two=m,one=m;one>=0;++two,--one,--one){\n\t\tif(two>=m+1){\n\t\t\tdel=add(del,update(n*(AR(two-(m+1),n-1))));\n\t\t}\n\t\tif(one>n) continue;\n\t\tres+=(update((AR(two,n)+MOD-del)*C(n,one)));\n\t\tif(one!=0){\n\t\t\tres-=update(update(n*AR(two-m,n-1))*C(n-1,one-1));\n\t\t}\n      \tif(res<0)\n\t\tres+=MOD;\n\t\tif(res>=MOD){\n\t\t\tres%=MOD;\n\t\t}\t\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n/*\n2 5\n6\n100 97\n20341054\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<stdexcept>\n#include<utility>\n#include<functional>\n#include<numeric>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<array>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<complex>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<bitset>\nusing namespace std;\nusing ll=long long;\n\n\n\n\nnamespace ProconLib{\n    using ll=long long;\n    using Int=int;\n    template<Int MOD,bool IsPrime=true>\n    class ModInt{\n        Int n;        \n        static Int regularize(int n){Int tmp=n%MOD; return tmp>=0 ? tmp : tmp+MOD;}\n        static Int regularize(ll n){Int tmp=n%MOD; return tmp>=0 ? tmp : tmp+MOD;}\n        public:\n        ModInt():n(0){};\n        ModInt(int n):n(regularize(n)){}\n        ModInt(long long n):n(regularize(n)){}\n        ModInt(const ModInt<MOD,IsPrime> &mn):n(mn.n){}\n        explicit operator int() const{return n;}\n        explicit operator long long() const{return n;}\n\n        ModInt<MOD,IsPrime>& operator+=(ModInt<MOD,IsPrime> rhs);\n        ModInt<MOD,IsPrime>& operator-=(ModInt<MOD,IsPrime> rhs);\n        ModInt<MOD,IsPrime>& operator*=(ModInt<MOD,IsPrime> rhs);\n\n        bool operator==(ModInt<MOD,IsPrime> rhs){return n==rhs.n;}\n        const Int& get() const {return n;}\n        void set(int x){n=regularize(x);}\n        void set(ll x){n=regularize(x);}        \n    };\n\n    template<Int MOD,bool IsPrime>\n    ModInt<MOD,IsPrime> operator+(ModInt<MOD,IsPrime> lhs,ModInt<MOD,IsPrime> rhs){return lhs+=rhs;};\n    template<Int MOD,bool IsPrime>\n    ModInt<MOD,IsPrime> operator+(ModInt<MOD,IsPrime> lhs,int rhs){return lhs+ModInt<MOD,IsPrime>(rhs);}\n    template<Int MOD,bool IsPrime>\n    ModInt<MOD,IsPrime> operator+(ModInt<MOD,IsPrime> lhs,ll rhs){return lhs+ModInt<MOD,IsPrime>(rhs);}\n    template<Int MOD,bool IsPrime>\n    ModInt<MOD,IsPrime> operator+(int lhs,ModInt<MOD,IsPrime> rhs){return ModInt<MOD,IsPrime>(lhs)+rhs;}\n    template<Int MOD,bool IsPrime>\n    ModInt<MOD,IsPrime> operator+(ll lhs,ModInt<MOD,IsPrime> rhs){return ModInt<MOD,IsPrime>(lhs)+rhs;}\n\n    template<Int MOD,bool IsPrime>\n    ModInt<MOD,IsPrime> operator+(ModInt<MOD,IsPrime> mn){return mn;};\n    template<Int MOD,bool IsPrime>\n    ModInt<MOD,IsPrime> operator-(ModInt<MOD,IsPrime> mn){return ModInt<MOD,IsPrime>(-mn.get());};\n\n    template<Int MOD,bool IsPrime>\n    ModInt<MOD,IsPrime> operator-(ModInt<MOD,IsPrime> lhs,ModInt<MOD,IsPrime> rhs){return lhs-=rhs;};\n    template<Int MOD,bool IsPrime>\n    ModInt<MOD,IsPrime> operator-(ModInt<MOD,IsPrime> lhs,int rhs){return lhs-ModInt<MOD,IsPrime>(rhs);};\n    template<Int MOD,bool IsPrime>\n    ModInt<MOD,IsPrime> operator-(ModInt<MOD,IsPrime> lhs,ll rhs){return lhs-ModInt<MOD,IsPrime>(rhs);};\n    template<Int MOD,bool IsPrime>\n    ModInt<MOD,IsPrime> operator-(int lhs,ModInt<MOD,IsPrime> rhs){return ModInt<MOD,IsPrime>(lhs)-rhs;};\n    template<Int MOD,bool IsPrime>\n    ModInt<MOD,IsPrime> operator-(ll lhs,ModInt<MOD,IsPrime> rhs){return ModInt<MOD,IsPrime>(lhs)-rhs;};\n\n    template<Int MOD,bool IsPrime>\n    ModInt<MOD,IsPrime> operator*(ModInt<MOD,IsPrime> lhs,ModInt<MOD,IsPrime> rhs){return lhs*=rhs;};\n    template<Int MOD,bool IsPrime>\n    ModInt<MOD,IsPrime> operator*(ModInt<MOD,IsPrime> lhs,int rhs){return lhs*ModInt<MOD,IsPrime>(rhs);}\n    template<Int MOD,bool IsPrime>\n    ModInt<MOD,IsPrime> operator*(ModInt<MOD,IsPrime> lhs,ll rhs){return lhs*ModInt<MOD,IsPrime>(rhs);}\n    template<Int MOD,bool IsPrime>\n    ModInt<MOD,IsPrime> operator*(ll lhs,ModInt<MOD,IsPrime> rhs){return ModInt<MOD,IsPrime>(lhs)*rhs;}\n    template<Int MOD,bool IsPrime>\n    ModInt<MOD,IsPrime> operator*(int lhs,ModInt<MOD,IsPrime> rhs){return ModInt<MOD,IsPrime>(lhs)*rhs;}\n\n    template<Int MOD>\n    ModInt<MOD,true> operator/(ModInt<MOD,true> lhs,ModInt<MOD,true> rhs);\n    template<Int MOD,bool IsPrime>\n    ModInt<MOD,IsPrime> powm(ModInt<MOD,IsPrime> x,Int k);\n    template<Int MOD>\n    ModInt<MOD,true> inv(ModInt<MOD,true> x){return powm(x,MOD-2);}\n\n    template<Int MOD,bool IsPrime>\n    std::ostream& operator<<(std::ostream& os,const ModInt<MOD,IsPrime> &mn);\n    \n\n    template<Int MOD,bool IsPrime>\n    ModInt<MOD,IsPrime>& ModInt<MOD,IsPrime>::operator+=(ModInt<MOD,IsPrime> rhs){\n        n+=rhs.n;\n        n= n>=MOD ? n-MOD : n;\n        return *this;\n    }\n    \n    template<Int MOD,bool IsPrime>\n    ModInt<MOD,IsPrime>& ModInt<MOD,IsPrime>::operator-=(ModInt rhs){\n        n=n-rhs.n<0 ? n-rhs.n+MOD : n-rhs.n;\n        return *this;\n    }\n    template<Int MOD,bool IsPrime>\n    ModInt<MOD,IsPrime>& ModInt<MOD,IsPrime>::operator*=(ModInt<MOD,IsPrime> rhs){\n        n=ll(n)*rhs.n%MOD;\n        return *this;\n    }\n    \n    template<Int MOD>\n    ModInt<MOD,true> operator/(ModInt<MOD,true> lhs,ModInt<MOD,true> rhs){\n        return lhs*inv(rhs);\n    }\n    template<Int MOD,bool IsPrime>\n    ModInt<MOD,IsPrime> powm(ModInt<MOD,IsPrime> x,Int k){\n        ModInt<MOD,IsPrime> res(1);\n        while(k){\n            if(k&1) res*=x;\n            k>>=1;\n            x*=x;\n        }\n        return res;\n    }\n\n    template<Int MOD,bool IsPrime>\n    std::ostream& operator<<(std::ostream& os,const ModInt<MOD,IsPrime> &mn){\n        os<<mn.get();\n        return os;\n    }\n\n    template<Int MOD,bool IsPrime>\n    std::istream& operator>>(std::istream& is,ModInt<MOD,IsPrime> &mn){\n        Int tmp;\n        is>>tmp;\n        mn.set(tmp);\n        return is;\n    }\n}\n\n\nnamespace ProconLib{\n\n    template<typename MInt>\n    class ModCombination{\n        int N;\n        std::vector<MInt> fact;\n        std::vector<MInt> factInv;\n        public:\n        ModCombination(int n);\n        MInt F(int n){return fact[n];}\n        MInt FI(int n){return factInv[n];}\n        MInt P(int n,int k){return fact[n]*factInv[n-k];}\n        MInt PI(int n,int k){return factInv[n]*fact[n-k];}\n        MInt C(int n,int k){return fact[n]*factInv[k]*factInv[n-k];}\n        MInt CI(int n,int k){return factInv[n]*fact[k]*fact[n-k];}\n    };\n\n    template<typename MInt>\n    ModCombination<MInt>::ModCombination(int n):N(n),fact(n+1),factInv(n+1){\n        fact[0]=MInt(1);\n        for(int i=1;i<=n;i++) fact[i]=fact[i-1]*MInt(i);\n        factInv[n]=inv(fact[n]);\n        for(int i=n-1;i>=0;i--){\n            factInv[i]=factInv[i+1]*MInt(i+1);\n        }\n    }\n    \n}\n\nusing namespace ProconLib;\n\nconst ll MOD=998244353;\nusing Mint=ModInt<MOD>;\n\nconst int SIZE=3*1e6+1;\nint main(){\n    int n;\n    cin>>n;\n    int m;\n    cin>>m;\n    ModCombination<Mint> mc(SIZE);\n\n    Mint res=0;\n    Mint val=0;\n    for(int i=m;i>=0;i-=2){\n        int x=(3*m-i)/2;\n        if(x==m){\n            val=mc.C(n-2,n-2);\n        }\n        else{\n            val=val+mc.C(x-m+n-2,n-2);\n        }\n        Mint rhs=mc.C(x+n-1,n-1)-n*val;\n        Mint lhs=(i<=n ? mc.C(n,i) : Mint(0));\n        res+=lhs*rhs;\n    }\n    res+=n*mc.C(m+n-2,n-2);\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(), vec.end()\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll INF = (1LL << 30) - 1LL;\nconstexpr ll LINF = (1LL << 60) - 1LL;\nconstexpr double eps = 1e-9;\nconstexpr ll MOD = 998244353LL;\ntemplate <typename T> bool chmin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n};\ntemplate <typename T> bool chmax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n};\ntemplate <typename T> ostream &operator<<(ostream &os, vector<T> v) {\n    for (int i = 0; i < v.size(); i++) {\n        os << v[i] << (i + 1 == v.size() ? \"\\n\" : \" \");\n    }\n    return os;\n}\ntemplate <typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate <typename T, typename... Ts> auto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value == 0>::type fill_v(T &t, const V &v) {\n    t = v;\n}\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value != 0>::type fill_v(T &t, const V &v) {\n    for (auto &e : t) {\n        fill_v(e, v);\n    }\n};\ntemplate <ll mod> struct modint {\n    ll val;\n    inline ll extgcd(ll a, ll b, ll &x, ll &y) {\n        if (a < b) {\n            return extgcd(b, a, y, x);\n        }\n        if (b == 0) {\n            x = 1, y = 0;\n            return a;\n        }\n        ll d = extgcd(b, a % b, y, x);\n        y -= a / b * x;\n        return d;\n    }\n    inline ll minv(ll k) {\n        ll x = 0, y = 0;\n        extgcd(k, mod, x, y);\n        if (x < 0) {\n            x += mod;\n        } else if (x == mod) {\n            x = 0;\n        }\n        return x;\n    }\n    constexpr modint() : val(0) {}\n    constexpr modint(ll x) { val = (x + mod) % mod; }\n    modint inv() { return modint(minv(val)); }\n    modint operator+(const modint &to) const { return modint(val + to.val); }\n    modint operator-(const modint &to) const { return modint(val - to.val); }\n    modint operator*(const modint &to) const { return modint(val * to.val); }\n    modint operator/(const modint &to) const {\n        return modint(val * minv(to.val));\n    }\n    template <class T> explicit operator T() { return T(val); }\n    template <typename T> modint operator+(const T &to) const {\n        return modint(val + to);\n    }\n    template <typename T> modint operator-(const T &to) const {\n        return modint(val - to);\n    }\n    template <typename T> modint operator*(const T &to) const {\n        return modint(val * to);\n    }\n    template <typename T> modint operator/(const T &to) const {\n        return modint(val * minv(to));\n    }\n    modint &operator++() { return *this = modint(val + 1); }\n    modint &operator--() { return *this = modint(val - 1); }\n    template <typename T> modint &operator+=(const T &to) {\n        return *this = *this + to;\n    }\n    template <typename T> modint &operator-=(const T &to) {\n        return *this = *this - to;\n    }\n    template <typename T> modint &operator*=(const T &to) {\n        return *this = *this * to;\n    }\n    template <typename T> modint &operator/=(const T &to) {\n        return *this = *this / to;\n    }\n    bool operator==(const modint &to) const { return val == to.val; }\n    bool operator!=(const modint &to) const { return val != to.val; }\n    bool operator>(const modint &to) const { return val > to.val; }\n    bool operator>=(const modint &to) const { return val >= to.val; }\n    bool operator<(const modint &to) const { return val < to.val; }\n    bool operator<=(const modint &to) const { return val <= to.val; }\n};\nusing mint = modint<MOD>;\nvector<mint> f, fi;\nvoid comb(int n) {\n    f.resize(n + 10);\n    fi.resize(n + 10);\n    f[0] = 1;\n    for (ll i = 1; i <= n; i++) {\n        f[i] = f[i - 1] * i;\n    }\n    fi[n] = f[n].inv();\n    for (ll i = n - 1; i >= 0; i--) {\n        fi[i] = fi[i + 1] * (i + 1LL);\n    }\n}\nmint ncr(ll n, ll r) {\n    if (n < r || n < 0 || r < 0) {\n        return 0;\n    }\n    return f[n] * fi[r] * fi[n - r];\n}\nmint nhr(ll n, ll r) { return ncr(n + r - 1LL, n); }\ninline mint mpow(mint x, ll n) {\n    mint res = 1;\n    while (n > 0) {\n        if (n & 1) {\n            res *= x;\n        }\n        x = x * x;\n        n >>= 1;\n    }\n    return res;\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n, m;\n    cin >> n >> m;\n    mint ans = 0;\n    comb(3LL * (n + m) + 10);\n    mint sum = 0;\n    for (ll j = 2 * m + 2; j <= 3 * m; j += 2) {\n        sum += nhr((3LL * m - j) / 2LL, n - 1LL);\n    }\n    for (ll i = 0; i <= min(n, m); i++) { //奇数の数\n        if ((3LL * m - i) % 2) {\n            continue;\n        }\n        mint s = ncr(n, i) * nhr((3LL * m - i) / 2LL, n);\n        s -= ncr(n, i) * n * sum;\n        s -= nhr((m - i) / 2LL, n - 1LL) * i * ncr(n, i);\n        sum += nhr((3LL * m - i - 2LL - 3LL * m) / 2LL, n - 1LL);\n        sum -= nhr((3LL * m - i - 2 * m - 2) / 2LL, n - 1LL);\n        ans += s;\n    }\n    cout << ans.val << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp> // Common file\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\ntypedef tree<\nll,\nnull_type,\nless<ll>,\nrb_tree_tag,\ntree_order_statistics_node_update>\nordered_set;\n// ordered_set X;\n// *X.find_by_order(i) = ith largest element (counting from zero)\n// X.order_of_key(k) = number of items in X < k (strict lt)\n\ntemplate<int MOD> struct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { ll w; i >> w; n = modnum(w); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(ll e) const {\n        if (e < 0) return 1 / this->pow(-e);\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        int g = MOD, x = 0, y = 1;\n        for (int r = v; r != 0; ) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static int totient() {\n        int tot = MOD, tmp = MOD;\n        for (int p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static int primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        int tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (int p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (int r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (int p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static int discrete_log(modnum v) {\n        static const int M = ceil(sqrt(MOD));\n        static unordered_map<int, int> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (int i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (int i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum unity_root(int deg) {\n        assert(totient() % deg == 0);\n        return generator().pow(totient() / deg);\n    }\n\n    static modnum fact(int n) {\n        static vector<modnum> fact = { 1 };\n        for (assert(n >= 0); fact.size() <= n; )\n            fact.push_back(fact.back() * fact.size());\n        return fact[n];\n    }\n\n    static modnum finv(int n) {\n        static vector<modnum> finv = { 1 };\n        for (assert(n >= 0); finv.size() <= n; )\n            finv.push_back(finv.back() / finv.size());\n        return finv[n];\n    }\n\n    static modnum ncr(int n, int r) {\n        assert(n >= 0);\n        if (r < 0 || n < r) return 0;\n        return fact(n) * finv(r) * finv(n - r);\n    }\n};\n\nconstexpr ll MOD = 998244353;\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int N, M;\n    cin >> N >> M;\n\n    int X = max(N, 2*M);\n    vector<modnum<MOD>> spreads(X+1, 0);\n    spreads[0] = 1;\n    for(int x=1;x<=X;x++) spreads[x] = spreads[x-1] + modnum<MOD>::ncr(x+N-2, N-2);\n\n    // cout << spreads[0] << \" \" << spreads[1] << \" \" << spreads[2] << endl;\n\n    modnum<MOD> total = 0;\n    for(int k = (M%2); k<=min(N, M); k+=2){\n        int r = (3*M - k)/2;\n        modnum<MOD> term = modnum<MOD>::ncr(N+r-1, N-1);\n        // cout << k << \" \" << r << \" \" << r-M << \" \" << r-M-1 << \" \" << term << endl;\n        if (r>=M) term -= k*spreads[r-M];\n        if (r>=M+1) term -= (N-k)*spreads[r-M-1];\n        // cout << term << endl;\n        total += modnum<MOD>::ncr(N, k) * term;\n    }\n\n    cout << total << endl;\n/*\n    modnum<MOD> bad = 0;\n    for (int x=2*M+1; x<=3*M;x++) {\n        bad += modnum<MOD>::ncr(3*M - x + N - 2, N - 2);\n    }\n\n    modnum<MOD> ans = total - N * bad;\n    cout << ans << endl;*/\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ███▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓╬╬╬╬╬╬▓█\n// ███▓███████▓▓╬╬╬╬╬╬╬╬╬╬╬╬▓███▓▓▓▓█▓╬╬╬▓█\n// ███████▓█████▓▓╬╬╬╬╬╬╬╬▓███▓╬╬╬╬╬╬╬▓╬╬▓█\n// ████▓▓▓▓╬╬▓█████╬╬╬╬╬╬███▓╬╬╬╬╬╬╬╬╬╬╬╬╬█\n// ███▓▓▓▓╬╬╬╬╬╬▓██╬╬╬╬╬╬▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ████▓▓▓╬╬╬╬╬╬╬▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ███▓█▓███████▓▓███▓╬╬╬╬╬╬▓███████▓╬╬╬╬▓█\n// ████████████████▓█▓╬╬╬╬╬▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬█\n// ███▓▓▓▓▓▓▓╬╬▓▓▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ████▓▓▓╬╬╬╬▓▓▓▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ███▓█▓▓▓▓▓▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// █████▓▓▓▓▓▓▓▓█▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// █████▓▓▓▓▓▓▓██▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n// █████▓▓▓▓▓████▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n// ████▓█▓▓▓▓██▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n// ████▓▓███▓▓▓▓▓▓▓██▓╬╬╬╬╬╬╬╬╬╬╬╬█▓╬▓╬╬▓██\n// █████▓███▓▓▓▓▓▓▓▓████▓▓╬╬╬╬╬╬╬█▓╬╬╬╬╬▓██\n// █████▓▓█▓███▓▓▓████╬▓█▓▓╬╬╬▓▓█▓╬╬╬╬╬╬███\n// ██████▓██▓███████▓╬╬╬▓▓╬▓▓██▓╬╬╬╬╬╬╬▓███\n// ███████▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬████\n// ███████▓▓██▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓████\n// ████████▓▓▓█████▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█████\n// █████████▓▓▓█▓▓▓▓▓███▓╬╬╬╬╬╬╬╬╬╬╬▓██████\n// ██████████▓▓▓█▓▓▓╬▓██╬╬╬╬╬╬╬╬╬╬╬▓███████\n// ███████████▓▓█▓▓▓▓███▓╬╬╬╬╬╬╬╬╬▓████████\n// ██████████████▓▓▓███▓▓╬╬╬╬╬╬╬╬██████████\n// ███████████████▓▓▓██▓▓╬╬╬╬╬╬▓███████████\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n// #pragma GCC optimize(\"unroll-loops\")    \n#include <bits/stdc++.h>\n#define pb push_back\n#define x first\n#define y second\n#define mp make_pair\n#define len(a) int(a.size())\n#define files(FILENAME) read(FILENAME); write(FILENAME)\n#define read(FILENAME) freopen((string(FILENAME) + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((string(FILENAME) + \".out\").c_str(), \"w\", stdout)\nusing namespace std;\n        \ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; } \ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p) { _out << _p.first << ' ' << _p.second; return _out; }\ntemplate<typename T, typename U> inline istream &operator>> (istream &_in, pair<T, U> &_p) { _in >> _p.first >> _p.second; return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const vector<T> &_v) { if (_v.empty()) { return _out; } _out << _v.front(); for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline istream &operator>> (istream &_in, vector<T> &_v) { for (auto &_i : _v) { _in >> _i; } return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\n        \ntypedef unsigned long long base; \ntypedef pair<int, int> point;      \ntypedef complex<double> comp;\n\nconst int N = 2e6 + 5;\nconst int p = 998244353;\n\nint mul(long long a, int b) {\n    return a * b % p;\n}\n\nint sum(int a, int b) {\n    a += b;\n    return a < p ? a : a - p;\n}\n\nint powx(int a, int b) {\n    int ans = 1;\n    while (b) {\n        if (b & 1) ans = mul(ans, a);\n        a = mul(a, a);\n        b >>= 1;\n    }\n    return ans;\n}\n\nint n, m;\nint f[2][N];\n\nint cnk(int n, int m) {\n    return mul(f[0][n], mul(f[1][n - m], f[1][m]));\n}\n\nint func(int n, int m) {\n    if (m < 0) return 0;\n    return cnk(n + m - 1, m);\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    srand(time(0));\n    f[0][0] = 1;\n    for (int i = 1; i < N; ++i) {\n        f[0][i] = mul(f[0][i - 1], i);\n    }\n    f[1][N - 1] = powx(f[0][N - 1], p - 2);\n    for (int i = N - 1; i--;) {\n        f[1][i] = mul(f[1][i + 1], i + 1);\n    }\n    cin >> n >> m;\n    int ans = 0;\n    int bad = m * 2 + 1;\n    for (int i = m & 1; i <= n && i <= m; i += 2) {\n        int cur = cnk(n, i);\n        int r = (m * 3 - i) / 2;\n        int d = 0;\n        int t = (bad + 1) / 2;\n        d = mul(n - i, func(n, r - t));\n        t = (bad) / 2;\n        d = sum(d, mul(i, func(n, r - t)));\n        // cout << r << ' ' << cur << endl;\n        cur = mul(cur, sum(func(n, r), p - d));\n        ans = sum(ans, cur);\n        // cout << i << ' ' << cur << endl;\n    }\n    cout << ans << '\\n';\n}  \n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma comment(linker, \"/stack:200000000\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n\n#define X first\n#define Y second\n\n//#include <boost/unordered_map.hpp>\n//using namespace boost;\n\n/*\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> rbtree;\nrbtree T;\n*/\n\nusing i32 = int;\nusing i64 = long long;\nusing u8 = unsigned char;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing f64 = double;\nusing f80 = long double;\n//using i128 = __int128_t;\n//using u128 = __uint128_t;\nusing i128 = i64;\nusing u128 = u64;\n\nll power(ll a, ll b, ll p)\n{\n\tif (!b) return 1;\n\tll t = power(a, b/2, p);\n\tt = t*t%p;\n\tif (b&1) t = t*a%p;\n\treturn t;\n}\n\nll exgcd(ll a, ll b, ll &x, ll &y)\n{\n\tif (b == 0)\n\t{\n\t\tx = 1;\n\t\ty = 0;\n\t\treturn a;\n\t}\n\tll px, py;\n\tll d = exgcd(b, a%b, px, py);\n\tx = py;\n\ty = px-a/b*py;\n\treturn d;\n}\n\ntemplate<class T>\ninline void freshmin(T &a, const T &b)\n{\n\tif (a > b) a = b;\n}\n\ntemplate<class T>\ninline void freshmax(T &a, const T &b)\n{\n\tif (a < b) a = b;\n}\n\n//#define getchar getchar_unlocked\n//#define putchar putchar_unlocked\n\nint inp() {\n\tint x = 0, f = 0; char ch;\n\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\tif(ch == '-') f = 1;\n\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\treturn f ? -x : x;\n}\n\nll inp_ll() {\n\tll x = 0; int f = 0; char ch;\n\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\tif(ch == '-') f = 1;\n\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\treturn f ? -x : x;\n}\n\ntemplate<class T>\nbool read(T &x)\n{\n\tx = 0;\n\tchar ch = getchar();\n\tif (ch == EOF) return 0;\n\tfor(; !isdigit(ch); )\n\t{\n\t\tch = getchar();\n\t\tif (ch == EOF) return 0;\n\t}\n\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\treturn 1;\n}\n\ntemplate<class T>\nvoid write(T x)\n{\n\tstatic char s[22];\n\tstatic char *it = s+20;\n\tstatic char *end = s+20;\n\tif (!x)\n\t\t*-- it = '0';\n\twhile (x)\n\t{\n\t\t*-- it = x%10+'0';\n\t\tx /= 10;\n\t}\n\tfor (; it < end; ++ it)\n\t\tputchar(*it);\n}\n\ntemplate<class T>\nvoid writeln(T x)\n{\n\twrite(x);\n\tputchar('\\n');\n}\n\nconst int MOD = 998244353;\nconst int INF = 1000000000;\nconst int MAXN = 2000000;\n\nll p[MAXN], r[MAXN];\n\nll C(int n, int m)\n{\n\tif (0 <= m && m <= n)\n\t\treturn p[n]*r[m]%MOD*r[n-m]%MOD;\n\telse\n\t\treturn 0;\n}\n\nll calc(int m, int n)\n{\n\treturn C(m+n-1, n-1);\n}\n\nint main()\n{\n\t\n\tp[0] = 1;\n\tfor (int i = 1; i <= 2000000; ++ i)\n\t\tp[i] = p[i-1]*i%MOD;\n\tr[2000000] = power(p[2000000], MOD-2, MOD);\n\tfor (int i = 2000000; i >= 1; -- i)\n\t\tr[i-1] = r[i]*i%MOD;\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tll ans = 0;\n\t\n\tfor (int k = 2*m+1; k <= 3*m; ++ k)\n\t\t(ans += calc(3*m-k, n-1)) %= MOD;\n\tans = ans*n%MOD;\n\tcout << (calc(3*m, n)+MOD-ans)%MOD << endl;\n\t\n\t/*\n\tfor (int k = 0; k <= n; k ++)\n\t{\n\t\tif (3*m-k < 0) continue; // assert 3*m-k >= 0\n\t\tif ((3*m-k)%2) continue; // assert (3*m-k)%2 == 0\n\t\tif ((3*m-k)/2 < k) continue; // assert (3*m-k)/2 >= k\n\t\t(ans += C(n, k)*calc((3*m-k)/2, n))%MOD;\n\t}\n\t*/\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n\ntemplate<i64 M>\nconstexpr i64 euinv(i64 val) {\n    i64 a = M, b = val;\n    i64 x = 0, u = 1;\n    while (b) {\n        i64 t = a / b;\n        swap(a -= t * b, b);\n        swap(x -= t * u, u);\n    }\n    return x < 0 ? x + M : x;\n}\n\ntemplate<i64 M>\nstruct modint {\n  i64 a;\n  constexpr modint(const i64 x = 0) noexcept: a((x % M + M) % M) {}\n  constexpr i64 value() const noexcept { return a; }\n  constexpr modint inv() const noexcept { return modint(euinv<M>(a)); }\n  constexpr modint pow(i64 r) const noexcept {\n    modint ans(1);\n    modint aa = *this;\n    while(r) {\n      if(r & 1) {\n        ans *= aa;\n      }\n      aa *= aa;\n      r >>= 1;\n    }\n    return ans;\n  }\n  constexpr modint& operator+=(const modint r) noexcept {\n    a += r.a;\n    if(a >= M) a -= M;\n    return *this;\n  }\n  constexpr modint& operator=(const i64 r) {\n    a = (r % M + M) % M;\n    return *this;\n  }\n  constexpr modint& operator-=(const modint r) noexcept {\n    a -= r.a;\n    if(a < 0) a += M;\n    return *this;\n  }\n  constexpr modint& operator*=(const modint r) noexcept {\n    a = a * r.a % M;\n    return *this;\n  }\n  constexpr modint& operator/=(modint r) noexcept {\n    i64 ex = M - 2;\n    while(ex) {\n      if(ex & 1) {\n        *this *= r;\n      }\n      r *= r;\n      ex >>= 1;\n    }\n    return *this;\n  }\n\n  constexpr modint operator+(const modint r) const {\n    return modint(*this) += r;\n  }\n  constexpr modint operator-(const modint r) const {\n    return modint(*this) -= r;\n  }\n  constexpr modint operator*(const modint r) const {\n    return modint(*this) *= r;\n  }\n  constexpr modint operator/(const modint r) const {\n    return modint(*this) /= r;\n  }\n\n  constexpr bool operator!=(const modint r) const {\n    return this->value() != r.value();\n  }\n\n};\n\ntemplate<const i64 M>\nstd::ostream& operator<<(std::ostream& os, const modint<M>& m) {\n  os << m.value();\n  return os;\n}\n\n\n#include <vector>\nusing i64 = long long;\n\ntemplate<class T>\nvoid build_factorial(std::vector<T>& fact, std::vector<T>& finv, std::vector<T>& inv) {\n  std::size_t N = fact.size();\n  fact[0] = T(1);\n  for(int i = 1;i < N;i++) {\n    fact[i] = fact[i - 1] * T(i);\n  }\n  finv[N - 1] = T(1) / fact[N - 1];\n  for(int i = N - 1; i --> 0;) {\n    finv[i] = finv[i + 1] * T(i + 1);\n  }\n  for(int i = 0;i < N;i++) {\n    inv[i] = fact[i - 1] * finv[i];\n  }\n}\n\nusing fp = modint<998244353>;\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n\ntemplate<class T>\nstatic inline std::vector<T> ndvec(size_t&& n, T val) noexcept {\n  return std::vector<T>(n, std::forward<T>(val));\n}\n\ntemplate<class... Tail>\nstatic inline auto ndvec(size_t&& n, Tail&&... tail) noexcept {\n  return std::vector<decltype(ndvec(std::forward<Tail>(tail)...))>(n, ndvec(std::forward<Tail>(tail)...));\n}\n\ntemplate<class T, class Cond>\nstruct chain {\n  Cond cond; chain(Cond cond) : cond(cond) {}\n  bool operator()(T& a, const T& b) const {\n    if(cond(a, b)) { a = b; return true; }\n    return false;\n  }\n};\ntemplate<class T, class Cond>\nchain<T, Cond> make_chain(Cond cond) { return chain<T, Cond>(cond); }\n\n\nint main() {\n  i64 N, M;\n  cin >> N >> M;\n  vector<fp> fact(M * 3 + N);\n  vector<fp> finv(M * 3 + N);\n  vector<fp> inv(M * 3 + N);\n  build_factorial(fact, finv, inv);\n\n  auto binom = [&](i64 n, i64 r) {\n    if(0 <= r && r <= n) return fact[n] * finv[r] * finv[n - r];\n    return fp(0);\n  };\n  fp ans(0);\n  rep(i,0,M + 1) {\n    if((3 * M - i) % 2 == 0) {\n      ans += binom(N, i) * binom((3 * M - i) / 2 + N - 1, N - 1);\n    }\n  }\n  rep(i,0,M + 1) {\n    if((M - i) % 2 == 0) {\n      ans -= binom(N, i) * binom((M - i) / 2 + N - 1, N - 1) * fp(N);\n    }\n  }\n  N--;\n  rep(i,0,M + 1) {\n    if((M - i) % 2 == 0) {\n      ans += binom(N, i) * binom((M - i) / 2 + N - 1, N - 1) * fp(N + 1);\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=1500005,INF=1<<30;\n\nll inv[MAX],fac[MAX],finv[MAX];\n\nvoid make(){\n    \n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    \n    for(int i=2;i<MAX;i++){\n        inv[i]=mod-inv[mod%i]*(mod/i)%mod;\n        fac[i]=fac[i-1]*(ll)i%mod;\n        finv[i]=finv[i-1]*inv[i]%mod;\n    }\n    \n}\n\nll comb(ll a,ll b){\n    if(a<b) return 0;\n    return fac[a]*(finv[b]*finv[a-b]%mod)%mod;\n}\n\nint main(){\n    \n    make();\n    \n    int N,M;cin>>N>>M;\n    \n    ll sum=0;\n    \n    for(int i=M;i>=0;i-=2){\n        if(i>N) continue;\n        ll rem=(3*M-i)/2;\n        sum+=comb(rem+N-1,N-1)*comb(N,i);\n        sum%=mod;\n    }\n    \n    for(int i=M;i>=0;i-=2){\n        if(i>N) continue;\n        ll rem=(M-i)/2;\n        sum+=N*(mod-comb(rem+N-1,N-1))*comb(N,i);\n        sum%=mod;\n    }\n    \n    for(int i=M;i>=0;i-=2){\n        if(i>N-1) continue;\n        ll rem=(M-i)/2;\n        sum+=N*(comb(rem+N-2,N-2))*comb(N-1,i);\n        sum%=mod;\n    }\n    \n    cout<<sum<<endl;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuThOr GaRyMr\n*/\n#include<bits/stdc++.h>\n#define rb(a,b,c) for(int a=b;a<=c;++a)\n#define rl(a,b,c) for(int a=b;a>=c;--a)\n#define LL long long\n#define IT iterator\n#define PB push_back\n#define II(a,b) make_pair(a,b)\n#define FIR first\n#define SEC second\n#define FREO freopen(\"check.out\",\"w\",stdout)\n#define rep(a,b) for(int a=0;a<b;++a)\n#define KEEP while(1)\n#define SRAND mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#define random(a) rng()%a\n#define ALL(a) a.begin(),a.end()\n#define POB pop_back\n#define ff fflush(stdout)\n#define fastio ios::sync_with_stdio(false)\n//#define int LL\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef pair<int,int> mp;\ntypedef pair<mp,mp> superpair;\nLL MOD=998244353;\nLL fact[2000000+20];\nLL update(LL A){\n\tif(A<MOD) return A;\n\tif(A-MOD<MOD) return A-MOD;\n\tA%=MOD;\n\treturn A;\n}\nvoid UP(LL & A){\n\t\n\tif(A>=MOD){\n\t\tif(A-MOD<MOD) A-=MOD;\n\t\telse\n\t\tA%=MOD;\n\t}\n\t\n}\nLL quick(LL A,LL B){\n\tif(!B) return 1ll;\n\tLL tmp=quick(A,B>>1);\n\ttmp*=tmp;\n\tUP(tmp);\n\tif(B&1){\n\t\ttmp*=A;\n\t\tUP(tmp);\n\t}\n\treturn tmp;\n}\nLL inv(LL A){\n\treturn  quick(A,MOD-2);\n}\nLL C(LL A,LL B){\n\tif(B>A){\n\t\treturn 0ll;\n\t}\n\treturn update(update(fact[A]*inv(fact[B]))*inv(fact[A-B]));\n}\nLL AR(LL A,LL B){\n\t//把A个2分给B个数\n\treturn C(A+B-1,B-1); \n} \n\nint  main(){\n\tfastio;\n\tfact[0]=1;\n\trb(i,1,2000000)\n\t\tfact[i]=fact[i-1]*i,fact[i]%=MOD;\n\tint n,m;\n\tcin>>n>>m;\n\tLL res=0;\n\tLL del=0;\n\tfor(int two=m,one=m;one>=0;two++,one-=2){\n\t\tif(two>=m+1){\n\t\t\tdel+=update(n*(AR(two-(m+1),n-1)));\n\t\t\tUP(del);\n\t\t}\n\t\tif(one>n) continue;\n\t\tres+=(update((AR(two,n)+MOD-del)*C(n,one)));\n\t\tif(one!=0){\n\t\t\tres-=update(update(n*AR(two-m,n-1))*C(n-1,one-1));\n\t\t}\n\t\tres+=MOD;\n\t\tUP(res);\t\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n/*\n2 5\n6\n100 97\n20341054\n*/"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\nconstexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int ret = 1;\n\tlong long int by = x;\n\twhile (n) {\n\t\tif (n & 1) {\n\t\t\tret *= by;\n\t\t\tret %= M;\n\t\t}\n\t\tby *= by;\n\t\tby %= M;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tvector<long long int>by(N * 3 + M * 3 + 1, 1);\n\tvector<long long int>rev(N * 3 + M * 3 + 1, 1);\n\tfor (int i = 1; i <= (N + M) * 3; i++) {\n\t\tby[i] = by[i - 1] * i;\n\t\tby[i] %= MOD;\n\t\trev[i] = power(by[i], MOD - 2, MOD);\n\t}\n\tlong long int ans = by[M * 3 + N - 1];\n\tans *= rev[N - 1];\n\tans %= MOD;\n\tans *= rev[M * 3];\n\tans %= MOD;\n\t//cout << ans << endl;\n\tfor (int i = M * 3; i > M * 2; i--) {\n\t\tlong long int minus = N;\n\t\tminus *= by[M * 3 - i + N - 2];\n\t\tminus %= MOD;\n\t\tminus *= rev[N - 2];\n\t\tminus %= MOD;\n\t\tminus *= rev[M * 3 - i];\n\t\tminus %= MOD;\n\t\tans += MOD - minus;\n\t\tans %= MOD;\n\t}\n\t//cout << ans << endl;\n\tfor (int i =  M + 1; i <= min(3 * M, N); i ++) {\n\t\tlong long int minus = by[N];\n\t\tminus *= rev[i];\n\t\tminus %= MOD;\n\t\tminus *= rev[N - i];\n\t\tminus %= MOD;\n\t\tlong long int num = M * 3 - i;\n\t\tif (num & 1)continue;\n\t\tnum /= 2;\n\t\tminus *= by[num + N - 1];\n\t\tminus %= MOD;\n\t\tminus *= rev[num];\n\t\tminus %= MOD;\n\t\tminus *= rev[N - 1];\n\t\tminus %= MOD;\n\t\tans += MOD - minus;\n\t\tans %= MOD;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e6 + 10;\nconst int mod = 998244353;\n\ninline int fpow (int a, int b) {\n\tint ret = 1;\n\twhile (b) {\n\t\tret = 1ll * ret * a % mod;\n\t\ta = 1ll * a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\n\nint f[N], invf[N];\n\nvoid predeal (int n) {\n\tf[0] = invf[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[i] = 1ll * f[i - 1] * i % mod;\n\t}\n\tinvf[n] = fpow(f[n], mod - 2);\n\tfor (int i = n - 1; i >= 1; i--) {\n\t\tinvf[i] = 1ll * invf[i + 1] * (i + 1) % mod; \n\t}\n}\n\ninline int C (int n, int m) {\n\treturn 1ll * f[n] * invf[m] % mod * invf[n - m] % mod;\n}\n\nint main (void) {\n\tpredeal(2e6);\n\n\tint n, m, ans = 0;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i <= m; i++) {\n\t\tif ((m - i) & 1) continue;\n\t\tans += 1ll * C(n, i) * C((3 * m - i) / 2 + n - 1, n - 1) % mod;\n\t\tif (ans >= mod) ans -= mod;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tif ((m - 1 - i) & 1) continue;\n\t\tans -= 1ll * C(n, 1) * C(n, i) % mod * C((m - 1 - i) / 2 + n - 1, n - 1) % mod;\n\t\tif (ans < 0) ans += mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<ll> vl;\ntypedef pair<ll, ll> PP;\n#define rep(i, n) for(ll i = 0; i < ll(n); i++)\n#define CIN>>x scanf(\"%lld\",&x);\n#define all(v) v.begin(), v.end()\nbool chmin(ll & a, ll  b) { if (b < a) { a = b; return 1; } return 0; }\nbool chmax(ll & a, ll b) { if (b > a) { a = b; return 1; } return 0; }\nconst ll INF = 999999999999999;\nconst ll MOD = 998244353;\nconst ll MAX_N=500010;\nll a, b, c, d, e, f, p, t, x, y, z, q, m, n, r, h, k, w, l, ans;\n#include <cstdint>                                                                                                              \n\ntemplate <std::uint_fast64_t Modulus> class modint {\n\tusing u64 = std::uint_fast64_t;\n\npublic:\n\tu64 a;\n\n\tconstexpr modint(const u64 x = 0) noexcept : a(x% Modulus) {}\n\tconstexpr u64& value() noexcept { return a; }\n\tconstexpr const u64& value() const noexcept { return a; }\n\tconstexpr modint operator+(const modint rhs) const noexcept {\n\t\treturn modint(*this) += rhs;\n\t}\n\tconstexpr modint operator-(const modint rhs) const noexcept {\n\t\treturn modint(*this) -= rhs;\n\t}\n\tconstexpr modint operator*(const modint rhs) const noexcept {\n\t\treturn modint(*this) *= rhs;\n\t}\n\tconstexpr modint operator/(const modint rhs) const noexcept {\n\t\treturn modint(*this) /= rhs;\n\t}\n\tconstexpr modint& operator+=(const modint rhs) noexcept {\n\t\ta += rhs.a;\n\t\tif (a >= Modulus) {\n\t\t\ta -= Modulus;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator-=(const modint rhs) noexcept {\n\t\tif (a < rhs.a) {\n\t\t\ta += Modulus;\n\t\t}\n\t\ta -= rhs.a;\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator*=(const modint rhs) noexcept {\n\t\ta = a * rhs.a % Modulus;\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator/=(modint rhs) noexcept {\n\t\tu64 exp = Modulus - 2;\n\t\twhile (exp) {\n\t\t\tif (exp % 2) {\n\t\t\t\t*this *= rhs;\n\t\t\t}\n\t\t\trhs *= rhs;\n\t\t\texp /= 2;\n\t\t}\n\t\treturn *this;\n\t}\n};\n\nusing mint = modint<MOD>;\nvector<mint> V(3100000);\nint main() {\n    cin>>n>>m;\n    V[0]=1;\n    rep(i,3000000){\n        V[i+1]=V[i]*(i+1);\n    }\n\n    mint X=V[m*3+n-1]/(V[m*3]*V[n-1]),Y=0;\n    for(ll i=m*2+1;i<=m*3;i++){\n        Y=Y+V[(m*3-i)+n-2]/(V[m*3-i]*V[n-2]);\n    }\n\t\n    X=X-Y*n;\n    cout<<X.a<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "// C - GP 2\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define\tMOD 998244353\n\nvector<long long> fact, finv;\n\nvoid init_fact(int n = 1000000)\n{\n\tfact.resize(n); finv.resize(n);\n\tfact[0] = finv[n - 1] = 1;\n\tfor (int i = 1; i < n; i++) fact[i] = fact[i - 1] * i % MOD;\n\tfor (long long x = MOD - 2, a = fact[n - 1]; x > 0; a = a * a % MOD, x >>= 1)\n\t\tif (x & 1) finv[n - 1] = finv[n - 1] * a % MOD;\n\tfor (int i = n - 2; i >= 0; i--) finv[i] = finv[i + 1] * (i + 1) % MOD;\n}\n\nlong long cnr(int n, int r)\n{\n\tif (r < 0 || r > n) return 0;\n\tif (r == 0 || r == n) return 1;\n\treturn fact[n] * finv[r] % MOD * finv[n - r] % MOD;\n}\n\nint main(int argc, char *argv[])\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n\n\tlong long n, m;\n\tcin >> n >> m;\n\n\tinit_fact(2000000);\n\n\tlong long ans = 0;\n\tfor (int k = 0; k <= min(m, n); k++) {\n\t\tif ((3 * m - k) % 2) continue;\n\t\tlong long c = (3 * m - k) / 2;\n\t\tans = (ans + cnr(c + n - 1, c) * cnr(n, k) % MOD) % MOD;\n\t}\n\n\tlong long r = 0;\n\tfor (int k = 0; k <= min(m, n); k++) {\n\t\tif ((m - k) % 2) continue;\n\t\tlong long c = (m - k) / 2;\n\t\tr = (r + cnr(c + n - 1, c) * cnr(n, k) % MOD - cnr(c + n - 2, c) * cnr(n - 1, k) % MOD + MOD) % MOD;\n\t}\n\tans = (ans - r * n % MOD + MOD) % MOD;\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <cstring>\n#include <algorithm>\n#include <bitset>\n#include <deque>\n#include <stack>\n#include <queue>\nusing namespace std;\nconst int N = 1e7;\nconst int mod = 998244353;\nint n, m;\nlong long a[N +1], ni[N + 1];\nlong long calc(long long x, long long y) {\n    long long z = 1;\n    while (y) {\n        if (y & 1) (z *= x )%= mod;\n        (x *= x) %= mod, y /= 2;\n    }\n    return z;\n}\nlong long C(int x, int y) {\n    if (x < y || x < 0) return 0;\n    return a[x] * ni[y] % mod * ni[x - y] % mod;\n}\nlong long get(int n, int m) {\n    return C(n + m  - 1, n - 1);\n}\nint main()\n{\n    scanf(\"%d %d\", &n ,&m);\n    a[0] = 1;\n    for (int i = 1; i <= N ; i ++)\n        a[i] = a[i - 1] * i % mod;\n    ni[N] = calc(a[N] , mod -  2);\n    for (int i = N - 1; i >= 0 ; i --)\n         ni[i] = ni[i + 1] * (i + 1) % mod;\n    long long ans = get(n, m * 3);\n    for (int i = m + 1; i <= n ; i ++) {\n        if ((3 * m - i) % 2 == 0 && m * 3 - i >= 0)\n            (ans += mod - C(n, i) * get(n, (m * 3 - i) / 2) % mod) %= mod;\n    }\n    (ans += mod - C(n , 1) * get(n, m * 3 - m - m - 1)% mod) %= mod;\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=3e6+5,mod=998244353;\ntypedef long long ll;\nint n,m;\nll f[N],invf[N];\nll C(ll n,ll m){return f[n]*invf[n-m]%mod*invf[m]%mod;}\nint main()\n{\n    f[0]=f[1]=invf[0]=invf[1]=1;\n    for(int i=2;i<N;i++)\n    {\n        f[i]=f[i-1]*i%mod;\n        invf[i]=(mod-mod/i)*invf[mod%i]%mod;\n    }\n    for(int i=2;i<N;i++) invf[i]=invf[i-1]*invf[i]%mod;\n    scanf(\"%d%d\",&n,&m);\n    ll ans=0,res=0;\n    for(int i=0;i<=min(n,m);i++)\n        if((3*m-i)%2==0)\n        ans=(ans+C(n,i)*C((3*m-i)/2+n-1,n-1)%mod)%mod;\n    for(int i=0;i<=min(n,m);i++)\n        if((m-i)%2==0)\n        res=(res+C(n,i)*C((m-i)/2+n-1,n-1)%mod)%mod;\n    ans=(ans-res*n%mod)%mod;\n    ans=(ans+mod)%mod;\n    for(int i=0;i<=min(n-1,m);i++)\n        if((m-i)%2==0)\n        ans=(ans+C(n-1,i)*C((m-i)/2+n-2,n-2)%mod*n)%mod;\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuThOr GaRyMr\n*/\n#include<bits/stdc++.h>\n#define rb(a,b,c) for(int a=b;a<=c;++a)\n#define rl(a,b,c) for(int a=b;a>=c;--a)\n#define LL long long\n#define IT iterator\n#define PB push_back\n#define II(a,b) make_pair(a,b)\n#define FIR first\n#define SEC second\n#define FREO freopen(\"check.out\",\"w\",stdout)\n#define rep(a,b) for(int a=0;a<b;++a)\n#define KEEP while(1)\n#define SRAND mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#define random(a) rng()%a\n#define ALL(a) a.begin(),a.end()\n#define POB pop_back\n#define ff fflush(stdout)\n#define fastio ios::sync_with_stdio(false)\n//#define int LL\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef pair<int,int> mp;\ntypedef pair<mp,mp> superpair;\nLL MOD=998244353;\nLL fact[2000000+20];\nLL quick(LL A,LL B){\n\tif(!B) return 1ll;\n\tLL tmp=quick(A,B>>1);\n\ttmp*=tmp;\n\ttmp%=MOD;\n\tif(B&1){\n\t\ttmp*=A;\n\t}\n\treturn tmp%MOD;\n}\nLL inv(LL A){\n\treturn  quick(A,MOD-2);\n}\nLL C(LL A,LL B){\n\tif(B>A){\n\t\treturn 0ll;\n\t}\n\treturn fact[A]*inv(fact[B])%MOD*inv(fact[A-B])%MOD;\n}\nLL AR(LL A,LL B){\n\t//把A个2分给B个数\n\treturn C(A+B-1,B-1); \n} \nsigned main(){\n\tfastio;\n\tfact[0]=1;\n\trb(i,1,2000000)\n\t\tfact[i]=fact[i-1]*i,fact[i]%=MOD;\n\tint n,m;\n\tcin>>n>>m;\n\tLL res=0;\n\tLL del=0;\n\tfor(int two=m,one=m;one>=0;two++,one-=2){\n\t\tif(two>=m+1){\n\t\t\tdel+=n*(AR(two-(m+1),n-1))%MOD;\n\t\t\tdel%=MOD;\n\t\t}\n\t\tif(one>n) continue;\n//\t\tdel=0;\n//\t\trb(j,m+1,two){\n//\t\t\tdel+=n*(AR(two-(j),n-1))%MOD;\n//\t\t\tdel%=MOD;\n//\t\t}\n\t\tres+=((AR(two,n)+MOD-del)*C(n,one)%MOD);\n\t\tif(one!=0){\n\t\t\tres-=(n*AR(two-m,n-1))%MOD*C(n-1,one-1)%MOD;\n\t\t}\n\t\tres+=MOD;\n\t\tres%=MOD;\t\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n/*\n2 5\n6\n100 97\n20341054\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <ctime>\n#include <cassert>\n#include <unordered_map>\n#include <fstream>\n#include <random>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <tuple>\n#include <complex>\n#include <chrono>\n#include <climits>\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n// default_random_engine generator;\n// mt19937 rnd(1);\n\nconst int P = 998244353;\nconst int MAXN = 4000001;\n\nvoid add(int &a, int b) {\n    a += b;\n    if (a >= P) {\n        a -= P;\n    }\n}\n\nvoid sub(int &a, int b) {\n    a -= b;\n    if (a < 0) {\n        a += P;\n    }\n}\n\n\nvoid mul(int &a, int b) {\n    ll c = (ll)a * b;\n    c %= P;\n    a = c;\n}\n\nint f[MAXN];\nint rf[MAXN];\nint r[MAXN];\n\nint choose(int n, int k) {\n    if (n < k || k < 0) {\n        return 0;\n    }\n    int res = f[n];\n    mul(res, rf[n - k]);\n    mul(res, rf[k]);\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    // freopen(\"input.txt\", \"r\", stdin);\n    // freopen(\"output.txt\", \"w\", stdout);\n\n    int n, m;\n    cin >> n >> m;\n\n    int x = 0;\n    int y = 0;\n\n    r[1] = 1;\n    for (int i = 2; i < MAXN; ++i) {\n        r[i] = P - P / i;\n        mul(r[i], r[P % i]);\n    }\n\n    f[0] = rf[0] = 1;\n    for (int i = 1; i < MAXN; ++i) {\n        f[i] = f[i - 1];\n        mul(f[i], i);\n        rf[i] = rf[i - 1];\n        mul(rf[i], r[i]);\n    }\n\n    // for (int i = 0; i < 10; ++i) {\n    //     cout << r[i] << \" \";\n    // }\n    // cout << endl;\n\n    for (int i = 2 * m + 1; i <= 3 * m; ++i) {\n        int cur = n;\n        mul(cur, choose((n - 2) + (3 * m - i), n - 2));\n        add(x, cur);\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        if (i > 3 * m || (3 * m - i) % 2 == 1) {\n            continue;\n        }\n        if ((3 * m - i) / 2 >= m) {\n            continue;\n        }\n        int k = (3 * m - i) / 2;    \n\n        int cur = choose(n, i);\n        mul(cur, choose((n - 1) + k, k));\n        add(y, cur);\n    }\n\n\n    int res = choose((n - 1) + (3 * m), n - 1);\n    // cout << res << \" \" << x << \" \" << y << endl;\n    sub(res, x);\n    sub(res, y);\n\n    cout << res << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <tuple>\n#include <utility>\n#include <vector>\n#define ll long long\n#define itn int\n#define endl '\\n'\n#define co(ans) cout<<ans<<endl\n#define COYE cout<<\"YES\"<<endl\n#define COYe cout<<\"Yes\"<<endl\n#define COye cout<<\"yes\"<<endl\n#define CONO cout<<\"NO\"<<endl\n#define CONo cout<<\"No\"<<endl\n#define COno cout<<\"no\"<<endl\n#define FORE(i,a) for(auto &i:a)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n)  FFOR(i,1,n)\n#define PB push_back\n#define MP make_pair\n#define ALL(V) (V).begin(),(V).end()\n#define SORT(V) sort((V).begin(),(V).end())\n#define REVERSE(V) reverse((V).begin(),(V).end())\n#define EACH(V,i) for(typeof((V).begin()) i=(V).begin();i!=(V).end();++i)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define INF ((1LL<<62)-(1LL<<31))\n#define EPS 1e-10\n#define PI 3.141592653589793238\n#define MOD 998244353\n#define MAX 5100000\nusing namespace std;\nusing Edge=pair<ll,ll>;\nusing Graph=vector<vector<int>>;\ninline int toInt(string s){int v;istringstream sin(s);sin>>v;return v;}\ntemplate<class T>inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\n////////// 二項係数(N<=10^7) //////////\n\nll fac[MAX],finv[MAX],inv[MAX];\n// fac[i] i!\n// finv[i] i!の逆元\n// inv[i] iの逆元\n\n// テーブルを作る前処理\nvoid COMinit(){\n  fac[0]=fac[1]=1;\n  finv[0]=finv[1]=1;\n  inv[1]=1;\n  for(ll i=2; i<MAX; ++i){\n    fac[i]=fac[i-1]*i%MOD;\n    inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n    finv[i]=finv[i-1]*inv[i]%MOD;\n  }\n}\n\n// 二項係数計算\nll COM(ll n,ll k){\n  if(n<k) return 0;\n  if(n<0 || k<0) return 0;\n  return fac[n]*(finv[k]*finv[n-k]%MOD)%MOD;\n}\n\n//////////////////////////////////////////////////\n\nint main(){\n  ll N,M,ans=0;\n  cin>>N>>M;\n  COMinit();\n  \n  for(int i=M%2; i<=min(N,M); i+=2){\n    ll L=(M-i)/2;\n    ans+=COM(N,i)*COM(M+L+N-1,N-1);\n    ans%=MOD;\n    ans-=N*(COM(N-1,i-1)*COM(L+N-1,N-1)%MOD+COM(N-1,i)*COM(L+N-2,N-1)%MOD);\n    ans%=MOD;\n    if(ans<0) ans+=MOD;\n  }\n  \n  co(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll     = long long;\nusing pii    = pair<int, int>;\nusing pll    = pair<ll, ll>;\nusing vi     = vector<int>;\nusing vl     = vector<ll>;\nusing vvi    = vector<vi>;\nusing vvl    = vector<vl>;\nconst ll INF = 1LL << 60;\nconst ll MOD = 998244353;\ntemplate <class T>\nbool chmax(T &a, const T &b) {\n    return (a < b) ? (a = b, 1) : 0;\n}\ntemplate <class T>\nbool chmin(T &a, const T &b) {\n    return (b < a) ? (a = b, 1) : 0;\n}\ntemplate <class C>\nvoid print(const C &c, std::ostream &os = std::cout) {\n    std::copy(std::begin(c), std::end(c), std::ostream_iterator<typename C::value_type>(os, \" \"));\n    os << std::endl;\n}\n\n// mod int struct\n// original : https://github.com/beet-aizu/library/blob/master/mod/mint.cpp\n\nstruct mint {\n    ll v;\n    ll mod;\n    mint() : v(0) {}\n    mint(signed v, ll mod = MOD) : v(v), mod(mod) {}\n    mint(ll t, ll mod = MOD) : mod(mod) {\n        v = t % mod;\n        if (v < 0)\n            v += mod;\n    }\n\n    mint pow(ll k) {\n        mint res(1), tmp(v);\n        while (k) {\n            if (k & 1)\n                res *= tmp;\n            tmp *= tmp;\n            k >>= 1;\n        }\n        return res;\n    }\n\n    static mint add_identity() { return mint(0); }\n    static mint mul_identity() { return mint(1); }\n\n    mint inv() { return pow(mod - 2); }\n\n    mint &operator+=(mint a) {\n        v += a.v;\n        if (v >= mod)\n            v -= mod;\n        return *this;\n    }\n    mint &operator-=(mint a) {\n        v += mod - a.v;\n        if (v >= mod)\n            v -= mod;\n        return *this;\n    }\n    mint &operator*=(mint a) {\n        v = 1LL * v * a.v % mod;\n        return *this;\n    }\n    mint &operator/=(mint a) { return (*this) *= a.inv(); }\n\n    mint operator+(mint a) const { return mint(v) += a; };\n    mint operator-(mint a) const { return mint(v) -= a; };\n    mint operator*(mint a) const { return mint(v) *= a; };\n    mint operator/(mint a) const { return mint(v) /= a; };\n\n    mint operator-() const { return v ? mint(mod - v) : mint(v); }\n\n    bool operator==(const mint a) const { return v == a.v; }\n    bool operator!=(const mint a) const { return v != a.v; }\n    bool operator<(const mint a) const { return v < a.v; }\n\n    // find x s.t. a^x = b\n    static ll log(ll a, ll b) {\n        const ll sq = 40000;\n        unordered_map<ll, ll> dp;\n        dp.reserve(sq);\n        mint res(1);\n        for (int r = 0; r < sq; r++) {\n            if (!dp.count(res.v))\n                dp[res.v] = r;\n            res *= a;\n        }\n        mint p = mint(a).inv().pow(sq);\n        res    = b;\n        for (int q = 0; q <= MOD / sq + 1; q++) {\n            if (dp.count(res.v)) {\n                ll idx = q * sq + dp[res.v];\n                if (idx > 0)\n                    return idx;\n            }\n            res *= p;\n        }\n        assert(0);\n        return ll(-1);\n    }\n\n    static mint comb(long long n, int k) {\n        mint num(1), dom(1);\n        for (int i = 0; i < k; i++) {\n            num *= mint(n - i);\n            dom *= mint(i + 1);\n        }\n        return num / dom;\n    }\n};\nostream &operator<<(ostream &os, mint m) {\n    os << m.v;\n    return os;\n}\n\nstruct Combination {\n    vector<ll> fac, finv, inv;\n\n    Combination(ll maxN) {\n        maxN += 100; // for safety\n        fac.resize(maxN + 1);\n        finv.resize(maxN + 1);\n        inv.resize(maxN + 1);\n        fac[0] = fac[1] = 1;\n        finv[0] = finv[1] = 1;\n        inv[1]            = 1;\n        for (ll i = 2; i <= maxN; ++i) {\n            fac[i]  = fac[i - 1] * i % MOD;\n            inv[i]  = MOD - inv[MOD % i] * (MOD / i) % MOD;\n            finv[i] = finv[i - 1] * inv[i] % MOD;\n        }\n    }\n    ll operator()(ll n, ll k) {\n        if (n < k)\n            return 0;\n        if (n < 0 || k < 0)\n            return 0;\n        return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    // oddになる数で場合分け出来そう\n    // m < n\n    Combination nCk(1000000);\n    mint ret = 0;\n    for (int i = m % 2; i <= m; i += 2) { // i個oddに使う\n        ll mm = (3 * m - i) / 2;\n        ret += mint(nCk(n, i)) * mint(nCk(mm + n - 1, n - 1));\n    }\n    for (int i = m % 2; i <= m; i += 2) {\n        ll mm     = (m - i) / 2;\n        mint temp = mint(nCk(n, i)) * mint(nCk(mm + n - 1, n - 1));\n        temp -= mint(nCk(n - 1, i)) * mint(nCk(mm + n - 2, n - 2));\n        ret -= temp * n;\n    }\n    cout << ret << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 998244353;\nconst ll MAX = 4000001;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n    long long x;\npublic:\n    mint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n    mint operator-() const {\n        return mint(-x);\n    }\n    mint& operator+=(const mint& a) {\n        if ((x += a.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    mint& operator-=(const mint& a) {\n        if ((x += MOD - a.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    mint& operator*=(const  mint& a) {\n        (x *= a.x) %= MOD;\n        return *this;\n    }\n    mint operator+(const mint& a) const {\n        mint res(*this);\n        return res += a;\n    }\n    mint operator-(const mint& a) const {\n        mint res(*this);\n        return res -= a;\n    }\n    mint operator*(const mint& a) const {\n        mint res(*this);\n        return res *= a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t >> 1);\n        a *= a;\n        if (t & 1) a *= *this;\n        return a;\n    }\n    // for prime MOD\n    mint inv() const {\n        return pow(MOD - 2);\n    }\n    mint& operator/=(const mint& a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint& a) const {\n        mint res(*this);\n        return res /= a;\n    }\n\n    friend ostream& operator<<(ostream& os, const mint& m) {\n        os << m.x;\n        return os;\n    }\n};\n\n//////////////////////////\n\nmint frac[MAX];\n\nvoid fracinit() {\n    frac[0] = 1;\n    repn(i, MAX - 1) {\n        frac[i] = frac[i - 1] * i;\n    }\n}\n\nmint com(ll n, ll m) {\n    if (n < 0 || m < 0) { return 0; }\n    if (n < m) { return 0; }\n    return frac[n] / frac[m] / frac[n - m];\n}\n\nmint H(ll n, ll m) {\n    return com(n + m - 1, n);\n}\n\nint main() {\n    fracinit();\n    ll N, M;\n    cin >> N >> M;\n\n    mint ans = H(3*M,N);\n\n    for (ll s = 2 * M + 1; s <= 3 * M; s++) {\n        ans -= H(3 * M - s, N - 1) * N;\n    }\n\n    for (ll s = M + 1; s <= N; s++) {\n        if ((3*M - s) % 2 != 0) { continue; }\n        ans -= H((3 * M - s) / 2, N) * com(N, s);\n    }\n\n    cout << ans;\n\n\n\tsystem(\"PAUSE\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\n\n#define MAX_N 5000010\nlong long inv[MAX_N];\nlong long factorial[MAX_N];\nlong long inv_factorial[MAX_N];\n\nvoid GetInv(){\n    for (int i = 1; i < MAX_N; i++) {\n        if (i == 1) inv[i] = 1;\n        else {\n            inv[i] = (mod - (mod / i) * inv[mod % i]) % mod;\n            if (inv[i] < 0) inv[i] += mod;\n        }\n    }\n}\nvoid GetFactorial(){\n    factorial[0] = 1; inv_factorial[0] = 1;\n    for (int i = 1; i < MAX_N; i++) {\n        factorial[i] = factorial[i-1] * i;\n        factorial[i] %= mod;\n        inv_factorial[i] = inv_factorial[i-1] * inv[i];\n        inv_factorial[i] %= mod;\n    }\n}\n\nlong long combination(int n, int r) {\n    long long ret = factorial[n] * inv_factorial[r];\n    ret %= mod;\n    ret *= inv_factorial[n-r];\n    return ret % mod;\n}\n\nlong long modpow(int n, int r) {\n    long long ret = 1; long long tmp = (long long) n;\n    while (r != 0) {\n        if (r % 2) ret *= tmp;\n        tmp *= tmp; tmp %= mod; ret %= mod;\n        r /= 2;\n    }\n    return ret;\n}\n\nint main() {\n    int n, m; cin >> n >> m;\n    GetInv(); GetFactorial();\n    long long all = combination(3*m+n-1, n-1);\n    long long sub = 0;\n    for (int k = m+1; k <= n; k++) {\n        if (k > n) break;\n        int remain = 3*m - k;\n        if (remain % 2 != 0) continue;\n        long long tmp = combination(n, k);\n        tmp = tmp * combination(remain/2 + n-1, n-1) % mod;\n        sub = (sub + tmp) % mod;\n    }\n    long long sub2 = 0;\n    for (int k = 2 * m+1; k <= 3*m; k++) {\n        int remain = 3*m - k;\n        long long tmp = combination(remain+n-2, n-2) * n % mod;\n        sub2 = (sub2 + tmp) % mod;\n    }\n    cout << (all + mod * 2 - sub - sub2) % mod << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(long long)((n)-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n#define inc(x,y) {x+=(y);if(x>=mod)x-=mod;}\n#define dec(x,y) {x-=(y);if(x<0)x+=mod;}\nusing namespace std;\nint n,m,i,j,mod=998244353,fac[3000005],inv[3000005],fi[3000005],ans;\nint c(int x,int y)\n{\n\treturn 1ll*fac[x]*fi[y]%mod*fi[x-y]%mod;\n}\nint f(int x,int y)\n{\n\treturn c(x+y-1,x-1);\n}\nint main()\n{\n\tfac[0]=fac[1]=fi[0]=fi[1]=inv[1]=1;\n\tfz(i,2,3000000){\n\t\tfac[i]=1ll*fac[i-1]*i%mod;\n\t\tinv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\t\tfi[i]=1ll*fi[i-1]*inv[i]%mod;\n\t}\n\tscanf(\"%d%d\",&n,&m);\n\tfz0g(i,min(n,m)){\n\t\tif((m+m+m-i)%2==0){\n\t\t\tans=(ans+1ll*c(n,i)*f(n,(m+m+m-i)/2))%mod;\n\t\t}\n\t}\n\tfz0g(i,min(n,m)){\n\t\tif((m-i)%2==0){\n\t\t\tans=(ans-1ll*c(n,i)*f(n,(m-i)/2)%mod*n)%mod;\n\t\t}\n\t}\n\tinc(ans,mod)\n\tfz0g(i,min(n-1,m)){\n\t\tif((m-i)%2==0){\n\t\t\tans=(ans+1ll*c(n-1,i)*f(n-1,(m-i)/2)%mod*n)%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\nconst int ThaoNguyen = 5e6+5, mod = 998244353, inf = 1e15;\n\nint gt[ThaoNguyen];\n\nnamespace THAONGUYEN\n{\n\tstring sum1(string a, string b)\n\t{\n\t\tstring res=\"\";\n\t\tint carry=0, x;\n\t\twhile(a.length()<b.length())\n\t\t{\n\t\t\ta='0'+a;\n\t\t}\n\t\twhile(b.length()<a.length())\n\t\t{\n\t\t\tb='0'+b;\n\t\t}\n\t\tfor(int i=a.length()-1; i>=0; i--)\n\t\t{\n\t\t\tx=a[i]+b[i]-96;\n\t\t\tres=(char)(x%10+48+carry)+res;\n\t\t\tcarry=x/10;\n\t\t}\n\t\tif(carry)\n\t\t{\n\t\t\tres='1'+res;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tstring mul1(string a, int b)\n\t{\n\t\tstring res=\"\";\n\t\tint carry=0, x;\n\t\tfor(int i=a.length()-1; i>=0; i--)\n\t\t{\n\t\t\tx=(a[i]-48)*b+carry;\n\t\t\tres=(char)(x%10+48)+res;\n\t\t\tcarry=x/10;\n\t\t}\n\t\tif(carry>0)\n\t\t{\n\t\t\tres=(char)(carry+48)+res;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tstring mul2(string a, string b)\n\t{\n\t\tstring res=\"\";\n\t\tfor(int i=0; i<a.length(); i++)\n\t\t{\n\t\t\tres+='0';\n\t\t\tres=sum1(res, mul1(b, (int)(a[i]-48)));\n\t\t\tcout<<res<<endl;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tvoid prep()\n\t{\n\t\tgt[1]=1;\n\t\tfor(int i=2; i<ThaoNguyen-1; i++)\n\t\t{\n\t\t\tgt[i]=(gt[i-1]*i)%mod;\n\t\t}\n\t}\n\t\n\tint binpow(int n, int k, int mod)\n\t{\n\t\tint m = n%mod, i=1, ans=1;\n\t\t{\n\t\t\twhile(i<=k)\n\t\t\t{\n\t\t\t\tint temp=i&k;\n\t\t\t\tif(temp>0)\n\t\t\t\t{\n\t\t\t\t\tans=(ans*m)%mod;\n\t\t\t\t}\n\t\t\t\ti<<=1, m=(m*m)%mod;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tint rev_mod(int n, int mod)\n\t{\n\t\treturn binpow(n, mod-2, mod);\n\t}\n\t\n\tint C(int k, int n)\n\t{\n\t\tif(k==0||k==n)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn ((((gt[n]%mod)*rev_mod(gt[k], mod))%mod)*rev_mod(gt[n-k], mod))%mod;\n\t\t}\n\t}\n}\n\nusing namespace THAONGUYEN;\n\nint n, m;\n\nsigned main()\n{\n\tint ans=0;\n\tprep();\n\tcin>>n>>m;\n\tfor(int i=0; i<=min(m, n); i++)\n\t{\n\t\tif((3*m-i)%2==0)\n\t\tans+=(C(n-1, (3*m-i)/2+n-1)*C(i, n))%mod;\n\t\tans%=mod;\n\t}\n\tint concac=0;\n\tfor(int i=2*m+1; i<=3*m; i++)\n\t{\n\t\tconcac+=C(n-2, n-2+(3*m-i))%mod;\n\t\tconcac%=mod;\n\t}\n\tconcac*=n;\n\tconcac%=mod;\n\tcout<<(ans-concac+mod)%mod;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\nusing namespace std;\n#define MOD 1000000007\n#define rep(i,m,n) for(int (i)=(int)(m);i<(int)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ll long long\n#define ull unsigned long long\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconst long long INF = 1LL << 60;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\n\n\n//priority_queue<ll> max;//大きい順\n//priority_queue<ll, Array, greater<ll>> min;//小さい順\n\n/*firstについては昇順 secondについては降順\nsort(all(wh), [&](P x, P y) {\n\tif (x.first == y.first)return x.second > y.second;\n\treturn x.first < y.first;\n});\n*/\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n//substr　文字列取り出し\n//upper_bound ある値より大きい一番左のイテレータを返す、lowerは以上(setに対して使うとO(N)なので、setのメンバ関数を使う\n//stoi\n\n\nstruct Edge {//グラフ\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, ll from, ll to, ll cap,bool revFlag,ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif(revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\nll max_flow_dfs(Graph & G, ll v, ll t, ll f, vector<bool> & used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph & G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d,Array &negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size()-2) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\t\t\t\t\t\t   \n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 2) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif(negative[i]==true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\td[i][G[i][j].to] = G[i][j].cap;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, vector<int>& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tlca() {}\n\n\tlca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unionSet(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tint numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\nclass SumSegTree {\nprivate:\n\t\n\tint _sum(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return 0;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tint s1 = _sum(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tint s2 = _sum(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn s1 + s2;\n\t\t}\n\t}\npublic:\n\tint n, height;\n\tvector<int> dat;\n\n\t// 初期化（_nは最大要素数）\n\tSumSegTree(int _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<int>(2 * n - 1,0);\n\t}\n\n\t// 場所i(0-indexed)にxを足す\n\tvoid add(int i, int x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] += x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] += x;\n\t\t}\n\t}\n\n\t// 区間[a,b)の総和。ノードk=[l,r)に着目している。\n\tint sum(int a, int b) {\n\t\treturn _sum(a, b, 0, 0, n);\n\t}\n};\nclass RmqTree {\nprivate:\n\n\tll _find(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return INF;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _find(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _find(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn min(s1, s2);\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tRmqTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1,INF);\n\t}\n\n\t// 場所i(0-indexed)をxにする\n\tvoid update(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] = x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\n\t// 区間[a,b)の最小値。ノードk=[l,r)に着目している。\n\tll find(ll a, ll b) {\n\t\treturn _find(a, b, 0, 0, n);\n\t}\n};\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\n}\n\nvector<ll> lis_fast(const vector<ll>& a) {//最長部分増加列\n\tconst ll n = a.size();\n\tvector<ll> A(n, INT_MAX);\n\tvector<ll> id(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tid[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n\t\tA[id[i]] = a[i];\n\t}\n\tll m = *max_element(id.begin(), id.end());\n\tvector<ll> b(m + 1);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tif (id[i] == m) b[m--] = a[i];\n\treturn b;\n}\n\n\nll ModPow(ll x, ll n) {\n\tll res = 1LL;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % MOD;\n\t\tx = x * x % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//nCrとか\nclass Combination {\npublic:\n\tArray fact;\nArray inv;\nll mod;\nll mod_inv(ll x) {\n\tll n = mod - 2LL;\n\tll res = 1LL;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nll nCr(ll n, ll r) {\n\treturn ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n}\nll nPr(ll n, ll r) {\n\treturn (fact[n] * inv[n - r]) % mod;\n}\nll nHr(ll n, ll r) {\n\treturn nCr(r + n - 1, r);\n}\nCombination(ll n, ll _mod) {\n\tmod = _mod;\n\tfact.resize(n + 1);\n\tfact[0] = 1;\n\tREP(i, n) {\n\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t}\n\tinv.resize(n + 1);\n\tREP(i, n + 1) {\n\t\tinv[i] = mod_inv(fact[i]);\n\t}\n}\n};\n\nll gcd(ll m, ll n) {\n\tif (n == 0)return m;\n\treturn gcd(n, m % n);\n}//gcd\n\nll lcm(ll m, ll n) {\n\treturn m / gcd(m, n) * n;\n}\n\n\nMatrix mIdentity(ll n) {\n\tMatrix A(n, Array(n));\n\tfor (int i = 0; i < n; ++i) A[i][i] = 1;\n\treturn A;\n}\n\nMatrix mMul(const Matrix & A, const Matrix & B) {\n\tMatrix C(A.size(), Array(B[0].size()));\n\tfor (int i = 0; i < C.size(); ++i)\n\t\tfor (int j = 0; j < C[i].size(); ++j)\n\t\t\tfor (int k = 0; k < A[i].size(); ++k)\n\t\t\t\t(C[i][j] += (A[i][k] % MOD) * (B[k][j] % MOD)) %= MOD;\n\treturn C;\n}\n// O( n^3 log e )\nMatrix mPow(const Matrix & A, ll e) {\n\treturn e == 0 ? mIdentity(A.size()) :\n\t\te % 2 == 0 ? mPow(mMul(A, A), e / 2) : mMul(A, mPow(A, e - 1));\n}\n\ntemplate <class T>class RectangleSum {\npublic:\n\tvector<vector<T>> sum;\n\tT GetSum(int left, int right, int top, int bottom) { //[left, right], [top, bottom]\n\t\tT res = sum[bottom][right];\n\t\tif (left > 0) res -= sum[bottom][left - 1];\n\t\tif (top > 0) res -= sum[top - 1][right];\n\t\tif (left > 0 && top > 0) res += sum[top - 1][left - 1];\n\t\treturn res;\n\t}\n\tRectangleSum(const vector<vector<T>>& s, int h, int w) {\n\t\tsum.resize(h);\n\t\tfor (int i = 0; i < h; i++) sum[i].resize(w, 0);\n\t\tfor (int y = 0; y < h; y++) {\n\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\tsum[y][x] = s[y][x];\n\t\t\t\tif (y > 0) sum[y][x] += sum[y - 1][x];\n\t\t\t\tif (x > 0) sum[y][x] += sum[y][x - 1];\n\t\t\t\tif (y > 0 && x > 0) sum[y][x] -= sum[y - 1][x - 1];\n\t\t\t}\n\t\t}\n\t}\n};\n\nconst ll mod = 998244353;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tll n, m;\n\tcin >> n >> m;\n\tCombination comb(3 * m + n, mod);\n\tll ans = 0;\n\tREP(i, m+1) {\n\t\tif ((3 * m - i) % 2 == 1 || i > n)continue;\n\t\tll temp = comb.nHr(n, (3 * m - i)/2);\n\t\tll temp2 = comb.nCr(n, i);\n\t\t(ans += (temp * temp2) % mod) %= mod;\n\t//\tcout << ans << ' ';\n\t\tll x = 0;\n\t\tif (i >= 1) {\n\n\t\t\tx = (n * comb.nHr(n-1, (m - i) / 2)) % mod * comb.nCr(n-1,i-1) % mod;\n\t\t\tif((m-i)/2-1>=0)\n\t\t\t\tx += (n * comb.nHr(n, (m - i) / 2 - 1)) % mod * comb.nCr(n, i) % mod;\n\t\t\tx %= mod;\n\t\t}\n\t\telse {\n\t\t\tx = (n * comb.nHr(n, (m - i) / 2-1)) % mod;\n\t\t}\n\t\t(ans += mod - x) %= mod;\n//\t\tcout << ans << endl;\n\t}\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author edamat\n */\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for(int i = int(a), i##_len = (b); i < i##_len; ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\n#define _repr(i, n) repri(i, n, 0)\n/* loop in [n,m] step -1 */\n#define repri(i, a, b) for(int i = int(a), i##_len = (b); i >= i##_len; --i)\n/* loop in [n,0] step -1 or [n,m] step -1 */\n#define repr(...) _overload3(__VA_ARGS__, repri, _repr, )(__VA_ARGS__)\n#define all(x) (x).begin(), (x).end()\n#define debug(x) cerr << #x << \": \" << (x) << '\\n'\n#define eb emplace_back\n//#define endl '\\n'\ntypedef long long lint;\n// #define int lint\nconst int INF = (int)(1 << 30) - 1;\nint MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nconst lint LINF = (lint)(1LL << 62) - 1;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n\nstruct IoSetup {\n    IoSetup() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n//        cout << fixed << setprecision(20);\n//        cerr << fixed << setprecision(20);\n    }\n} iosetup;\n\nusing std::to_string;\nauto to_string(std::string s) -> std::string {\n    return '\"' + s + '\"';\n}\nauto to_string(char c) -> std::string {\n    return \"'\" + std::string{c} + \"'\";\n}\nauto to_string(const char* s) -> std::string {\n    return to_string((std::string) s);\n}\nauto to_string(bool b) -> std::string {\n    return (b ? \"true\" : \"false\");\n}\ntemplate <typename T, typename U>\nauto to_string(std::pair<T, U> p) -> std::string {\n    return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <size_t N>\nauto to_string(std::bitset<N> bs) -> std::string {\n    std::string res{};\n    for (size_t i = 0; i < N; i++)\n        res.insert(res.begin(), bs.test(i) ? '1' : '0');\n    return res;\n}\ntemplate <typename T>\nauto to_string(T v) -> std::string {\n    bool flg = false;\n    std::string res = \"[\";\n    for (auto const&x : v) {\n        if (flg) res += \", \";\n        else flg = true;\n        res += to_string(x);\n    }\n    res += \"]\";\n    return res;\n}\n\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n#define SZ(x) ((int)(x).size())\n\n/* range macro. usage: for(int i:range(n)) */\nclass range {\nprivate:\n    struct I {\n        int x;\n        int operator*() { return x; }\n        bool operator!=(I &lhs) { return x < lhs.x; }\n        void operator++() { ++x; }\n    };\n    I i, n;\n\npublic:\n    range(int n) : i({0}), n({n}) {}\n    range(int i, int n) : i({i}), n({n}) {}\n    I &begin() { return i; }\n    I &end() { return n; }\n};\n\n/* keep a max,min */\ntemplate <class T>\nbool chmax(T &a, const T &b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\ntemplate <class T>\nbool chmin(T &a, const T &b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\n/* input,output operator for pair and vector */\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\n\ntemplate <typename T1, typename T2>\nistream &operator>>(istream &is, pair<T1, T2> &p) {\n    is >> p.first >> p.second;\n    return is;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    for(int i = 0; i < (int)v.size(); i++) {\n        os << v[i] << (i + 1 != v.size() ? \", \" : \"\");\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &v) {\n    for(T &in : v) is >> in;\n    return is;\n}\n\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const map<T, U> &mp) {\n    for(auto x = mp.begin(); x != mp.end(); ++x) {\n        os << x->first << \": \" << x->second\n           << (x != prev(mp.end()) ? \"\\n\" : \"\");\n    }\n    return os;\n}\n\n/* initialize vector. usage: auto v = male_v<int>(N,0); */\ntemplate <typename T>\nvector<T> make_v(size_t a) {\n    return vector<T>(a);\n}\n\ntemplate <typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n/* fill vector. usage: fill_v(v,0); */\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value == 0>::type fill_v(T &t, const V &v) {\n    t = v;\n}\n\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value != 0>::type fill_v(T &t, const V &v) {\n    for(auto &e : t) fill_v(e, v);\n}\n\n/* sum */\ntemplate <typename T>\nT sum(vector<T> &v) {\n    T ret = 0;\n    for(T x : v) {\n        ret += x;\n    }\n    return ret;\n}\ntemplate <typename T>\nauto sum(const T &a) {\n    return a;\n}\ntemplate <typename T, typename... A>\nauto sum(const T &first, const A &... rest) {\n    return sum(first) + sum(rest...);\n}\n\n/* mod */\nlint intpow(lint a, lint n, lint mod) {\n    lint res = 1;\n    while(n > 0) {\n        if(n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\ntemplate <typename T>\nT intpow(T a, lint n) {\n    T res = 1;\n    while(n > 0) {\n        if(n & 1) res = res * a;\n        a = a * a;\n        n >>= 1;\n    }\n    return res;\n}\n\nlong long modinv(long long a, long long m) {\n    long long b = m, u = 1, v = 0;\n    while(b) {\n        long long t = a / b;\n        a -= t * b;\n        swap(a, b);\n        u -= t * v;\n        swap(u, v);\n    }\n    u %= m;\n    if(u < 0) u += m;\n    return u;\n}\n\n/* print */\ntemplate <typename T>\nvoid print(const T &first) {\n    cout << first << endl;\n}\ntemplate <typename T, typename... A>\nvoid print(const T &first, const A &... rest) {\n    cout << first << \" \";\n    print(rest...);\n}\ntemplate <typename... A>\nvoid print(const A &... rest) {\n    print(rest...);\n}\n\n/* Modint */\ntemplate <typename T, T MOD = 1000000007>\nstruct ModInt {\n    static constexpr T mod = MOD;\n    T v;\n    ModInt() : v(0) {}\n    ModInt(signed v) : v(v) {}\n    ModInt(long long t) {\n        v = t % MOD;\n        if(v < 0) v += MOD;\n    }\n\n    ModInt pow(long long k) {\n        ModInt res(1), tmp(v);\n        while(k) {\n            if(k & 1) res *= tmp;\n            tmp *= tmp;\n            k >>= 1;\n        }\n        return res;\n    }\n\n    static ModInt add_identity() { return ModInt(0); }\n    static ModInt mul_identity() { return ModInt(1); }\n\n    ModInt inv() { return pow(MOD - 2); }\n\n    ModInt &operator+=(ModInt a) {\n        v += a.v;\n        if(v >= MOD) v -= MOD;\n        return *this;\n    }\n    ModInt &operator-=(ModInt a) {\n        v += MOD - a.v;\n        if(v >= MOD) v -= MOD;\n        return *this;\n    }\n    ModInt &operator*=(ModInt a) {\n        v = 1LL * v * a.v % MOD;\n        return *this;\n    }\n    ModInt &operator/=(ModInt a) { return (*this) *= a.inv(); }\n\n    ModInt operator+(ModInt a) const { return ModInt(v) += a; };\n    ModInt operator-(ModInt a) const { return ModInt(v) -= a; };\n    ModInt operator*(ModInt a) const { return ModInt(v) *= a; };\n    ModInt operator/(ModInt a) const { return ModInt(v) /= a; };\n\n    ModInt operator-() const { return v ? ModInt(MOD - v) : ModInt(v); }\n\n    bool operator==(const ModInt a) const { return v == a.v; }\n    bool operator!=(const ModInt a) const { return v != a.v; }\n    bool operator<(const ModInt a) const { return v < a.v; }\n\n    // find x s.t. a^x = b\n    static T log(T a, T b) {\n        const T sq = 40000;\n        unordered_map<T, T> dp;\n        dp.reserve(sq);\n        ModInt res(1);\n        for(int r = 0; r < sq; r++) {\n            if(!dp.count(res.v)) dp[res.v] = r;\n            res *= a;\n        }\n        ModInt p = ModInt(a).inv().pow(sq);\n        res = b;\n        for(int q = 0; q <= MOD / sq + 1; q++) {\n            if(dp.count(res.v)) {\n                T idx = q * sq + dp[res.v];\n                if(idx > 0) return idx;\n            }\n            res *= p;\n        }\n        assert(0);\n        return T(-1);\n    }\n\n    static ModInt comb(long long n, int k) {\n        ModInt num(1), dom(1);\n        for(int i = 0; i < k; i++) {\n            num *= ModInt(n - i);\n            dom *= ModInt(i + 1);\n        }\n        return num / dom;\n    }\n};\ntemplate <typename T, T MOD>\nconstexpr T ModInt<T, MOD>::mod;\ntemplate <typename T, T MOD>\nostream &operator<<(ostream &os, ModInt<T, MOD> m) {\n    os << m.v;\n    return os;\n}\n\n\n\ntemplate< typename T >\nstruct Combination {\n    vector< T > _fact, _rfact;\n\n    Combination(int sz) : _fact(sz + 1), _rfact(sz + 1) {\n        _fact[0] = _rfact[sz] = 1;\n        for(int i = 1; i <= sz; i++) _fact[i] = _fact[i - 1] * i;\n        _rfact[sz] /= _fact[sz];\n        for(int i = sz - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n    }\n\n    inline T fact(int k) const { return _fact[k]; }\n\n    inline T rfact(int k) const { return _rfact[k]; }\n\n    T P(int n, int r) const {\n        if(r < 0 || n < r) return 0;\n        return fact(n) * rfact(n - r);\n    }\n\n    T C(int p, int q) const {\n        if(q < 0 || p < q) return 0;\n        return fact(p) * rfact(q) * rfact(p - q);\n    }\n\n    T H(int n, int r) const {\n        if(n < 0 || r < 0) return (0);\n        return r == 0 ? 1 : C(n + r - 1, r);\n    }\n};\n\nusing namespace std;\n\nclass CGP2 {\npublic:\n\tvoid solve(std::istream& cin, std::ostream& cout) {\n        using modint = ModInt<lint,998244353>;\n        Combination<modint> comb(50000000);\n        modint ret;\n        int N,M;\n        cin >> N >> M;\n        for (int i = M%2; i <= min(N,M); i+=2) {\n            ret += comb.C(N,i)*comb.H(N,(3*M-i)/2);\n        }\n        modint mi;\n        for (int i = M%2; i <= min(N,M); i+=2) {\n             mi += (comb.C(N,i)*comb.H(N,(M-i)/2)-comb.C(N-1,i)*comb.H(N-1,(M-i)/2));\n        }\n        ret -= mi*N;\n        cout << ret << endl;\n\t}\n};\n\n\nint main() {\n\tCGP2 solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n    x = 0; char c = getchar(); int f = 0;\n    for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n    for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n    if (f) x = -x;\n}\n\nnamespace {\n\tconst int mo = 998244353;\n\tinline int add(int x, int y) { x += y; return x >= mo ? x - mo : x; }\n\tinline int sub(int x, int y) { x -= y; return x < 0 ? x + mo : x; } \n\tinline int mul(int x, int y) { return (lo) x * y % mo; }\n\tinline int power(int a, int k = mo - 2) {\n\t\tint ans = 1;\n\t\tfor (; k; k >>= 1, a = mul(a, a))\n\t\t\tif (k & 1) ans = mul(ans, a);\n\t\treturn ans;\n\t}\n}\nconst int N = 3e6 + 233;\nint n, m;\nint fac[N], ifac[N];\n\ninline int C(int n, int m) {\n\tif (n < m) return 0;\n\telse if (m == 0 || m == n) return 1;\n\telse return mul(fac[n], mul(ifac[m], ifac[n - m]));\n}\n\ninline void prepare(int n) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i++) fac[i] = mul(fac[i - 1], i);\n\tifac[n] = power(fac[n]);\n\tfor (int i = n - 1; i >= 0; i--) ifac[i] = mul(ifac[i + 1], i + 1);\n}\n\nint main(void) {\n\tread(n); read(m);\n\tprepare(max(n, m) * 2);\n\tint ans = 0;\n\tfor (int d = 0; d <= min(m, n); d++) {\n\t\tif ((3 * m - d) % 2 == 0) {\n\t\t\tauto F = [] (int k, int n) {\n\t\t\t\treturn C(k / 2 + n - 1, n - 1);\n\t\t\t};\n\t\t\tans = add(ans, mul(C(n, d), F(3 * m - d, n)));\n\t\t\tans = sub(ans, mul(C(n, d), mul(n, F(m - d, n))));\n\t\t\tans = add(ans, mul(C(n, d), mul(n - d, F(m - d, n - 1))));\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma region template\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing vld = vector<ld>;\nusing vvld = vector<vld>;\nusing vvvld = vector<vvld>;\nusing vs = vector<string>;\nusing pll = pair<ll, ll>;\nusing vp = vector<pll>;\ntemplate <typename T>\nusing pqrev = priority_queue<T, vector<T>, greater<T>>;\n#define rep(i, n) for (ll i = 0, i##_end = (n); i < i##_end; i++)\n#define repb(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define repr(i, a, b) for (ll i = (a), i##_end = (b); i < i##_end; i++)\n#define reprb(i, a, b) for (ll i = (b)-1, i##_end = (a); i >= i##_end; i--)\n#define ALL(a) (a).begin(), (a).end()\n#define SZ(x) ((ll)(x).size())\n/*\nconstexpr ll MOD = 1e9 + 7;\n/*/\nconstexpr ll MOD = 998244353;\n//*/\nconstexpr ll INF = 1e+18;\nconstexpr ld EPS = 1e-12L;\nconstexpr ld PI = 3.14159265358979323846L;\nconstexpr ll GCD(ll a, ll b) { return b ? GCD(b, a % b) : a; }\nconstexpr ll LCM(ll a, ll b) { return a / GCD(a, b) * b; }\ntemplate <typename S, typename T>\ninline bool chmax(S &a, const T &b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <typename S, typename T>\ninline bool chmin(S &a, const T &b) {\n  if (b < a) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n#ifdef OJ_LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\ntemplate <typename T>\nbool print_(const T &a) {\n  cout << a;\n  return true;\n}\ntemplate <typename T>\nbool print_(const vector<T> &vec) {\n  for (auto &a : vec) {\n    cout << a;\n    if (&a != &vec.back()) {\n      cout << \" \";\n    }\n  }\n  return false;\n}\ntemplate <typename T>\nbool print_(const vector<vector<T>> &vv) {\n  for (auto &v : vv) {\n    for (auto &a : v) {\n      cout << a;\n      if (&a != &v.back()) {\n        cout << \" \";\n      }\n    }\n    if (&v != &vv.back()) {\n      cout << \"\\n\";\n    }\n  }\n  return false;\n}\nvoid print() { cout << \"\\n\"; }\ntemplate <typename Head, typename... Tail>\nvoid print(Head &&head, Tail &&... tail) {\n  bool f = print_(head);\n  if (sizeof...(tail) != 0) {\n    cout << (f ? \" \" : \"\\n\");\n  }\n  print(forward<Tail>(tail)...);\n}\n#pragma endregion\n\n// ModInt\n// 参考：https://ei1333.github.io/luzhiled/snippets/math/mod-int.html\n// modはコンパイル時に決定\ntemplate <ll mod>\nstruct ModInt {\n  ll x;\n  ModInt() : x(0) {}\n  ModInt(ll y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n  constexpr ModInt &operator+=(const ModInt &p) {\n    if ((x += p.x) >= mod)\n      x -= mod;\n    return *this;\n  }\n  constexpr ModInt &operator-=(const ModInt &p) {\n    if ((x += mod - p.x) >= mod)\n      x -= mod;\n    return *this;\n  }\n  constexpr ModInt &operator*=(const ModInt &p) {\n    x = x * p.x % mod;\n    return *this;\n  }\n  constexpr ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n  constexpr ModInt operator-() { return ModInt(-x); }\n  constexpr ModInt operator+(const ModInt &p) { return ModInt(*this) += p; }\n  constexpr ModInt operator-(const ModInt &p) { return ModInt(*this) -= p; }\n  constexpr ModInt operator*(const ModInt &p) { return ModInt(*this) *= p; }\n  constexpr ModInt operator/(const ModInt &p) { return ModInt(*this) /= p; }\n  constexpr bool operator==(const ModInt &p) { return x == p.x; }\n  constexpr bool operator!=(const ModInt &p) { return x != p.x; }\n  constexpr ModInt inverse() const {\n    ll a = x, b = mod, u = 1, v = 0, t;\n    while (b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n  constexpr ModInt pow(ll n) {\n    ModInt ret(1), mul(x);\n    while (n > 0) {\n      if (n & 1)\n        ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n  friend istream &operator>>(istream &is, ModInt &a) {\n    ll t;\n    is >> t;\n    a = ModInt<mod>(t);\n    return (is);\n  }\n};\n\nusing mint = ModInt<MOD>;\nusing vm = vector<mint>;\nusing vvm = vector<vm>;\n\nconstexpr int MAX_FAC = 2000010;\nmint fac[MAX_FAC], facinv[MAX_FAC];\nvoid combInit() {\n  fac[0] = mint(1);\n  for (int i = 0; i < MAX_FAC - 1; i++) {\n    fac[i + 1] = fac[i] * (i + 1);\n  }\n  facinv[MAX_FAC - 1] = fac[MAX_FAC - 1].inverse();\n  for (int i = MAX_FAC - 2; i >= 0; i--) {\n    facinv[i] = facinv[i + 1] * (i + 1);\n  }\n}\nmint comb(const ll a, const ll b) {\n  assert(a < MAX_FAC);\n  assert(b < MAX_FAC);\n  if (a < 0 || b < 0 || b > a) {\n    return mint(0);\n  }\n  mint ret(1);\n  ret *= fac[a];\n  ret *= facinv[b];\n  ret *= facinv[a - b];\n  return ret;\n}\nmint multicomb(const ll a, const ll b) {\n  return comb(a + b - 1, b);\n}\n\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  ll n, m;\n  cin >> n >> m;\n  combInit();\n  mint nq = 0, ans = 0;\n  rep(a, min(n, m)+1){\n    if((m-a) % 2 == 0) nq += comb((m-a)/2+n-1, n-1)*comb(n, a);\n  }\n  rep(a, min(n-1, m)+1){\n    if((m-a) % 2 == 0) nq -= comb((m-a)/2+n-1-1, n-1-1)*comb(n-1, a);\n  }\n  nq *= n;\n  rep(a, min(n, m)+1){\n    if((3*m-a) % 2 == 0) ans += comb((3*m-a)/2+n-1, n-1)*comb(n, a);\n  }\n  dump(ans);\n  ans -= nq;\n  print(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong N,M,mod=1e9+7;\nlong F[1<<22],I[1<<22];\nlong power(long a,long b){return b?power(a*a%mod,b/2)*(b%2?a:1)%mod:1;}\nlong C(long a,long b)\n{\n\treturn a<b||a<0||b<0?0:F[a]*I[b]%mod*I[a-b]%mod;\n}\nlong H(long a,long b){return a<0?0:C(a+b-1,b-1);}\nlong calc(long S,long O)\n{\n\treturn(H(S,N-1)-H(S-M-1,N-1)*(N-1-O)%mod-H(S-M,N-1)*O%mod+mod+mod)%mod*C(N-1,O)%mod;\n}\nlong sum(long L,long R)\n{\n\tlong D=R-L+1;\n\treturn D*(D+1)/2%mod+L*D%mod;\n}\nlong cumA[1<<22];\nlong cumB[1<<22];\nlong cumC[1<<22];\nmain()\n{\n\tcin>>N>>M;\n\tlong T=1<<22;\n\tF[0]=1;\n\tfor(long i=1;i<T;i++)F[i]=F[i-1]*i%mod;\n\tI[T-1]=power(F[T-1],mod-2);\n\tfor(long i=T-1;i--;)I[i]=I[i+1]*(i+1)%mod;\n\tcumA[0]=H(0,N-1);\n\tcumB[0]=H(0-M-1,N-1);\n\tcumC[0]=H(0-M,N-1);\n\tfor(long i=1;i<1<<22;i++)\n\t{\n\t\tcumA[i]=(cumA[i-1]+H(i,N-1))%mod;\n\t\tcumB[i]=(cumB[i-1]+H(i-M-1,N-1))%mod;\n\t\tcumC[i]=(cumC[i-1]+H(i-M,N-1))%mod;\n\t}\n\tlong ans=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tlong L=(M-i+1)/2,R=(3*M-i)/2;\n\t\tlong A=(cumA[R]-(L<1?0:cumA[L-1])+mod)%mod;\n\t\tlong B=(cumB[R]-(L<1?0:cumB[L-1])+mod)%mod*(N-1-i)%mod;\n\t\t\n\t\tlong CC=(cumC[R]-(L<1?0:cumC[L-1])+mod)%mod*i%mod;\n\t\tA=(A-B-CC+mod+mod)%mod;\n\t\tA=C(N-1,i)%mod*A%mod;\n\t\tans=(ans+A)%mod;\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MAX = 2000000;\nconst int MOD = 998244353;\n//\nint fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nint COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nsigned main() {\n int n,m;\n cin>>n>>m;\n COMinit();\n int ans=n*COM(m+n-2,m)%MOD;\n for(int i=m;3*m-2*i>=0;i++){\n     ans=(ans + (COM(i+n-1,i) +(MOD - n*COM(i-m+n-1,i-m)%MOD))*COM(n,3*m-2*i)%MOD)%MOD;\n }\n cout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : C.cpp\n * Author  : Kazune Takahashi\n * Created : 7/21/2019, 10:28:37 PM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n#define maxs(x, y) (x = max(x, y))\n#define mins(x, y) (x = min(x, y))\nusing ll = long long;\nclass mint\n{\npublic:\n  static ll MOD;\n  ll x;\n  mint() : x(0) {}\n  mint(ll x) : x(x % MOD) {}\n  mint operator-() const { return x ? MOD - x : 0; }\n  mint &operator+=(const mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  mint &operator-=(const mint &a) { return *this += -a; }\n  mint &operator*=(const mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  mint &operator/=(const mint &a)\n  {\n    mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  mint operator+(const mint &a) const { return mint(*this) += a; }\n  mint operator-(const mint &a) const { return mint(*this) -= a; }\n  mint operator*(const mint &a) const { return mint(*this) *= a; }\n  mint operator/(const mint &a) const { return mint(*this) /= a; }\n  bool operator<(const mint &a) const { return x < a.x; }\n  bool operator==(const mint &a) const { return x == a.x; }\n  const mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\nll mint::MOD = 998244353;\nistream &operator>>(istream &stream, mint &a) { return stream >> a.x; }\nostream &operator<<(ostream &stream, const mint &a) { return stream << a.x; }\nclass combination\n{\npublic:\n  vector<mint> inv, fact, factinv;\n  static int MAX_SIZE;\n  combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[mint::MOD % i]) * (mint::MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1; i < MAX_SIZE; i++)\n    {\n      fact[i] = mint(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  mint operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n};\nint combination::MAX_SIZE = 2000010;\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\n// constexpr double epsilon = 1e-10;\n// constexpr ll infty = 1000000000000000LL;\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n\nll N, M;\n\nint main()\n{\n  cin >> N >> M;\n  combination C;\n  mint ans = C(3 * M + N - 1, N - 1);\n  for (auto K = 3 * M; K >= 2 * M + 1; K--)\n  {\n    ans -= C(3 * M - K + N - 2, N - 2) * N;\n  }\n  for (auto K = 0LL; K < M; K++)\n  {\n    ans -= C(N, 3 * M - 2 * K) * C(K + N - 1, N - 1);\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = (int) 3e6 + 10;\nconst long long MOD = 998244353;\n\nint n, m;\nlong long f[N], g[N];\n\nlong long fpow(long long x, long long y) {\n\tif (y == 0) {\n\t\treturn 1LL;\n\t}\n\tif (y % 2 == 0) {\n\t\treturn fpow(x * x % MOD, y / 2);\n\t} else {\n\t\treturn x * fpow(x, y - 1) % MOD;\n\t}\n}\n\nlong long choose(int n, int m) {\n\tif (n < 0 || m < 0 || m > n) {\n\t\treturn 0LL;\n\t}\n\t/*memset(c, 0, sizeof c);\n\tc[0][0] = 1;\n\tfor (int i = 0; i < 50; i++) {\n\t\tc[i][0] = 1;\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tc[i][j] = c[i-1][j-1]+c[i-1][j];\n\t\t}\n\t}\n\treturn c[n][m];*/\n\tlong long ret = (f[n] * g[m] % MOD) * g[n - m] % MOD;\n\t//printf(\"dbg %d %d %lld\\n\",n,m,ret);\n\treturn ret;\n}\n\nlong long calc(int n, int s, int m) {\n\tlong long res = 0;\n\tfor (int i = 0; i <= n && i <= m; i++) {\n\t\tint j = s - i;\n\t\tif (j >= 0 && j % 2 == 0) {\n\t\t\tlong long u = choose(n, i);\n\t\t\tlong long v = choose(j / 2 + n - 1, n - 1);\n\t\t\tres = (res + u * v) % MOD;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\n\tf[0] = 1;\n\n\tfor (int i = 1; i < N; i++) {\n\t\tf[i] = f[i - 1] * i % MOD;\n\t}\n\n\tg[N - 1] = fpow(f[N - 1], MOD - 2);\n\n\tfor (int i = N - 2; i >= 0; i--) {\n\t\tg[i] = g[i + 1] * (i + 1) % MOD;\n\t}\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tlong long res = calc(n, 3 * m, m) - (calc(n, m, m) - calc(n - 1, m, m)) * n % MOD;\n\n\tprintf(\"%lld\\n\", (res % MOD + MOD) % MOD);\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cstdio>\n#include <iomanip>\n#include <cmath>\n#include <bitset>\n\nusing namespace std;\n\nint n, m;\nconst int MOD = 998244353;\nlong long ans = 0;\nlong long fact[6100000];\nlong long ufact[6100000];\n\nlong long inq(long long a, long long b)\n{\n    if (b == 0) return 1;\n    long long l = inq(a, b / 2);\n    if (b % 2) return l * l % MOD * a % MOD;\n    return l * l % MOD;\n}\n\nlong long cnk(long long n, long long k)\n{\n    return fact[n] * ufact[k] % MOD * ufact[n - k] % MOD;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tfact[0] = 1, ufact[0] = 1;\n\tcin >> n >> m;\n\tfor (int i = 1; i <= 4 * (n + m); i++) fact[i] = fact[i - 1] * i % MOD, ufact[i] = inq(fact[i], MOD - 2);\n\tans = cnk(3 * m + n - 1, n - 1);\n\tans = (ans + MOD - n) % MOD;\n\tn--;\n\tfor (int bad_len = 2 * m + 1; bad_len < 3 * m; bad_len++)\n    {\n        int cnt_pos = 3 * m - bad_len - 1;\n        ans = (ans + MOD - cnt_pos * cnk(3 * m - bad_len + 1 + n - 2, n - 2) % MOD) % MOD;\n        ans = (ans + MOD - 2 * cnk(3 * m - bad_len + 1 + n - 1, n - 1) % MOD) % MOD;\n    }\n    for (int b = m + 1; b <= min(3 * m, n + 1); b++)\n    {\n        int p = 3 * m + b;\n        int g = n + 1 - b;\n        int len = 3 * m + g;\n        int kek = len - n - 1;\n        if (kek % 2 == 0)\n        {\n            kek /= 2;\n            ans = (ans + MOD - cnk(kek + n, n) * cnk(n + 1, g) % MOD) % MOD;\n        }\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n \ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n \nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\ntemplate<uint_fast64_t Modulus = MOD>\nstruct Modint {\n  using u64 = uint_fast64_t;\n  u64 a;\n\n  constexpr Modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n\n  constexpr Modint operator+(const Modint rhs) const noexcept {\n    return Modint(*this) += rhs;\n  }\n  constexpr Modint operator-(const Modint rhs) const noexcept {\n    return Modint(*this) -= rhs;\n  }\n  constexpr Modint operator*(const Modint rhs) const noexcept {\n    return Modint(*this) *= rhs;\n  }\n  constexpr Modint operator/(const Modint rhs) const noexcept {\n    return Modint(*this) /= rhs;\n  }\n\n  constexpr Modint &operator+=(const Modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) a -= Modulus;\n    return *this;\n  }\n  constexpr Modint &operator-=(const Modint rhs) noexcept {\n    if (a < rhs.a) a += Modulus;\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr Modint &operator*=(const Modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr Modint &operator/=(Modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp & 1) *this *= rhs;\n      rhs *= rhs;\n      exp >>= 1;\n    }\n    return *this;\n  }\n\n  explicit operator bool() const {\n    return a;\n  }\n\n  friend ostream &operator<<(ostream &os, const Modint &m) {\n    return os << m.a;\n  }\n};\n\nusing mint = Modint<MOD2>;\n\ntemplate<typename T>\nstruct ModCombination {\n  vector<T> fac, finv, inv;\n\n  ModCombination(int MAX) : fac(MAX + 1), finv(MAX + 1), inv(MAX + 1) {\n    fac[0] = finv[MAX] = inv[0] = 1;\n    for (int i=1; i<=MAX; ++i) fac[i] = fac[i-1] * i;\n    finv[MAX] /= fac[MAX];\n    for (int i=MAX-1; i>=0; --i) finv[i] = finv[i+1] * (i+1);\n    for (int i=1; i<=MAX; ++i) inv[i] = finv[i] * fac[i-1];\n  }\n\n  T P(int n, int r) const {\n    if (n < r || n < 0 || r < 0) return 0;\n    return fac[n] * finv[n-r];\n  }\n\n  T C(int n, int r) const {\n    if (n < r || n < 0 || r < 0) return 0;\n    return fac[n] * finv[r] * finv[n-r];\n  }\n\n  T H(int n, int r) const {\n    if (n < 0 || r < 0) return 0;\n    return C(n + r - 1, r);\n  }\n};\n\nvoid solve() {\n  int n, m; cin >> n >> m;\n\n  ModCombination<mint> comb(n + m * 3 / 2);\n\n  vector<mint> calc;\n  repeq(i,m/2) {\n    calc.emplace_back(comb.H(n - 1, i));\n  }\n\n  vector<mint> sum(1, 0);\n  repeq(i,m/2) {\n    sum.emplace_back(sum[i] + calc[i]);\n  }\n\n  mint ans = 0;\n  for (int x = m & 1; x <= min(n, m); x += 2) {\n    int tmp = (m - x) / 2;\n    ans += comb.C(n, x) * (comb.H(n, m + tmp) - sum[tmp] * n - calc[tmp] * x);\n  }\n\n  cout << ans << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint N,M;\nconst long long fish=998244353;\nconst int MaxN=(1<<21)-1;\nlong long inv[MaxN+15],fac[MaxN+15];\nlong long Pow(int x,int y){\n\tlong long b=x,ans=1;\n\tfor (int qwq=y;qwq;qwq>>=1){\n\t\tif (qwq&1) ans=(ans*1ll*b)%fish;\n\t\tb=(b*b)%fish;\n\t}\n\treturn ans;\n}\nvoid Init(){\n\tfac[0]=1;\n\tfor (int i=1;i<=MaxN;i++)\n\t\tfac[i]=1ll*fac[i-1]*i%fish;\n\tinv[MaxN]=Pow(fac[MaxN],fish-2);\n\tfor (int i=MaxN-1;i>=0;i--)\n\t\tinv[i]=1ll*inv[i+1]*(i+1)%fish;\n\t//cout<<inv[2]<<endl;\n}\nlong long C(int n,int r){\n\treturn fac[n]*1ll*inv[r]%fish*1ll*inv[n-r]%fish;\n}\nlong long Get_ans(int n,int a,int b){\n\tb=min(b,n);\n\tlong long ans=0;\n\tfor (int i=a%2;i<=min(min(a,b),n);i+=2)\n\t\tans+=1ll*C((a-i)/2+n-1,n-1)%fish*C(n,i)%fish;\n\t\t//cout<<ans<<endl;\n\t\t//cout<<n<<endl;\n\treturn ans;\n}\nint main(){\n\tInit();\n\tscanf(\"%d%d\",&N,&M);\n\t//cout<<C(3,2)<<endl;\n\tlong long ans=Get_ans(N,3*M,M);\n\t//cout<<ans<<endl;\n\tans-=(Get_ans(N,M,M)-Get_ans(N-1,M,M))*1ll*N%fish;\n\tcout<<(ans+fish)%fish;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#if DEBUG\n// basic debugging macros\nint __i__,__j__;\n#define printLine(l) for(__i__=0;__i__<l;__i__++){cout<<\"-\";}cout<<endl\n#define printLine2(l,c) for(__i__=0;__i__<l;__i__++){cout<<c;}cout<<endl\n#define printVar(n) cout<<#n<<\": \"<<n<<endl\n#define printArr(a,l) cout<<#a<<\": \";for(__i__=0;__i__<l;__i__++){cout<<a[__i__]<<\" \";}cout<<endl\n#define print2dArr(a,r,c) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<a[__i__][__j__]<<\" \";}cout<<endl;}\n#define print2dArr2(a,r,c,l) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<setw(l)<<setfill(' ')<<a[__i__][__j__]<<\" \";}cout<<endl;}\n\n// advanced debugging class\n// debug 1,2,'A',\"test\";\nclass _Debug {\n    public:\n        template<typename T>\n        _Debug& operator,(T val) {\n            cout << val << endl;\n            return *this;\n        }\n};\n#define debug _Debug(),\n#else\n#define printLine(l)\n#define printLine2(l,c)\n#define printVar(n)\n#define printArr(a,l)\n#define print2dArr(a,r,c)\n#define print2dArr2(a,r,c,l)\n#define debug\n#endif\n\n// define\n#define MAX_VAL 999999999\n#define MAX_VAL_2 999999999999999999LL\n#define EPS 1e-6\n#define mp make_pair\n#define pb push_back\n\n// typedef\ntypedef unsigned int UI;\ntypedef long long int LLI;\ntypedef unsigned long long int ULLI;\ntypedef unsigned short int US;\ntypedef pair<int,int> pii;\ntypedef pair<LLI,LLI> plli;\ntypedef vector<int> vi;\ntypedef vector<LLI> vlli;\ntypedef vector<pii> vpii;\ntypedef vector<plli> vplli;\n\n// ---------- END OF TEMPLATE ----------\n#define MOD 998244353\n\nint inv(LLI n) {\n    int e = MOD-2;\n    LLI r = 1;\n    while (e > 0) {\n        if (e & 1) r *= n,r %= MOD;\n        e >>= 1;\n        n *= n,n %= MOD;\n    }\n    return r;\n}\nint fact[3000000];\nint invfact[3000000];\nint choose(int n,int k) {\n    return ((((LLI) fact[n]*invfact[k]) % MOD)*invfact[n-k]) % MOD;\n}\nint main() {\n    int i;\n    int N,M;\n    cin >> N >> M;\n\n    fact[0] = 1;\n    for (i = 1; i < 3000000; i++) fact[i] = ((LLI) fact[i-1]*i) % MOD;\n    invfact[2999999] = inv(fact[2999999]);\n    for (i = 2999998; i >= 0; i--) invfact[i] = ((LLI) invfact[i+1]*(i+1)) % MOD;\n    LLI ans = choose(3*M+N-1,N-1);\n    for (i = 2*M+1; i <= 3*M; i++) ans -= ((LLI) N*choose(3*M-i+N-2,N-2)) % MOD;\n    for (i = M+1; i <= min(N,3*M); i++) {\n        if (!((3*M-i) & 1)) ans -= ((LLI) choose(N,i)*choose((3*M-i)/2+N-1,N-1)) % MOD;\n    }\n    ans %= MOD;\n    if (ans < 0) ans += MOD;\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll inf=1000000000000000000;\ndouble pi=2*acos(0);\n#define rep(i,m,n) for(ll i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nll lmax(ll a,ll b){\n    if(a<b)return b;\n    else return a;\n}\nll lmin(ll a,ll b){\n    if(a<b)return a;\n    else return b;\n}\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\n\nll gya[2500010];\nll kai[2500010];\nll beki(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k%2==1){\n            ret*=now;\n            ret%=mod2;\n        }\n        now*=now;\n        now%=mod2;\n        k/=2;\n    }\n    return ret;\n}\nll gyaku(ll n){\n    return beki(n,mod2-2);\n}\nvoid nckinit(ll n){\n    kai[0]=1;\n    kai[1]=1;\n    for(int i=2;i<=n;i++){\n        kai[i]=kai[i-1]*i;\n        kai[i]%=mod2;\n    }\n    gya[n]=gyaku(kai[n]);\n    for(int i=n-1;i>=1;i--){\n        gya[i]=gya[i+1]*(i+1);\n        gya[i]%=mod2;\n    }\n    gya[0]=1;\n}\nll nck(ll n,ll k){\n    if(k<0)return 0;\n    if(k==0||n==k)return 1;\n    ll ret=kai[n];\n    ret*=gya[n-k];\n    ret%=mod2;\n    ret*=gya[k];\n    ret%=mod2;\n    return ret;\n}\nll npk(ll n,ll k){\n    if(k<0)return 0;\n    if(k==0)return 1;\n    ll ret=kai[n];\n    ret*=gya[n-k];\n    ret%=mod2;\n    return ret;\n}\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);\n    ll n,m;cin>>n>>m;\n    nckinit(2500009);\n    ll ans=nck(3*m+n-1,n-1);\n    ll sum=0;\n    rep(i,1,m+1){\n        sum+=nck(m-i+n-2,n-2);\n        sum%=mod2;\n    }\n    sum*=n;\n    sum%=mod2;\n    ll sum2=0;\n    if(n<=m)sum2=0;\n    else{\n        rep(i,m+1,n+1){\n            if(i>3*m)break;\n            if(m%2!=i%2)continue;\n            sum2+=nck(n,i)*nck((3*m-i)/2+n-1,n-1);\n            sum2%=mod2;\n        }\n    }\n   // cout<<ans<<\" \"<<sum<<\" \"<<sum2<<endl;\n    ans+=-sum-sum2+2*mod2;\n    cout<<ans%mod2<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint main(){\n    const int maxSize = 2000001;\n\tvector<long long> inv(maxSize);\n\tvector<long long> fact(maxSize);\n\tvector<long long> factInv(maxSize);\n\tfor(int i=0;i<2;i++) inv[i] = fact[i] = factInv[i] = 1;\n\tfor(int i=2;i<maxSize;i++){\n\t\tinv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n\t\tfact[i] = fact[i-1] * i % MOD;\n\t\tfactInv[i] = factInv[i-1] * inv[i] % MOD;\n\t}\n\tauto comb = [&](int n, int r){\n\t\tif(n < r || r < 0) return 0LL;\n\t\treturn fact[n] * factInv[n-r] % MOD * factInv[r] % MOD;\n\t};\n    auto perm = [&](int n, int r){\n        if(n < r || r < 0) return 0LL;\n        return fact[n] * factInv[n-r] % MOD;\n    };\n    int N, M;\n    while(cin >> N >> M){\n        long long res = (N * comb(M+N-2, N-2)) % MOD;\n        long long sum = 0;\n        for(int i=0;i<=M/2;i++){\n            int m2 = M+i;\n            long long cur = comb(m2+N-1, N-1);\n            sum += N * comb(m2-M+N-2, N-2);\n            sum %= MOD;\n            cur = (cur + MOD - sum) % MOD;\n            res += cur * comb(N, M-2*i);\n            res %= MOD;\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\nusing namespace std;\n\nconst ll MAX = 1500100, MOD = 998244353;\nll fac[MAX], finv[MAX], inv[MAX];\n// 前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n// 二項係数の計算\nll COM(int n, int k){\n    if (n < 0 || k < 0 || n < k) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nint main(){\n    int n, m; cin >> n >> m;\n    COMinit();\n    ll ans = 0;\n    if(m%2 == 0){\n        for(int i = 0; i <= m; i += 2){\n            ans += COM((3*m-i)/2 + n-1, n-1) * COM(n, i) % MOD; // 奇数がi個\n            ans -= COM((m-2-i)/2 + n-1, n-1) * COM(n, i) % MOD * n % MOD; // 2n+2以上\n            ans -= COM((m-i)/2 + n-2, n-2) * COM(n-1, i-1) % MOD * n % MOD; // 2n+1\n            ans += MOD;\n            ans %= MOD;\n        }\n    }\n    if(m%2 == 1){\n        for(int i = 1; i <= m; i += 2){\n            ans += COM((3*m-i)/2 + n-1, n-1) * COM(n, i) % MOD; // 奇数がi個\n            ans -= COM((m-2-i)/2 + n-1, n-1) * COM(n, i) % MOD * n % MOD; // 2n+2以上\n            ans -= COM((m-i)/2 + n-2, n-2) * COM(n-1, i-1) % MOD * n % MOD; // 2n+1\n            ans += MOD;\n            ans %= MOD;\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint main(){\n    using namespace std;\n    constexpr unsigned long MOD = 998244353;\n    size_t N, M;\n    cin >> N >> M;\n    auto modpow = [&MOD](unsigned long a, unsigned long n, unsigned long b = 1) -> unsigned long{\n        auto ret = b % MOD;\n        a %= MOD;\n        while(n){\n            if(n & 1)(ret *= a) %= MOD;\n            (a *= a) %= MOD;\n            n >>= 1;\n        }\n        return ret;\n    };\n    auto modbinomial = [&MOD, &modpow](unsigned long n, unsigned long k) -> unsigned long{\n        unsigned long ret = 1, den = 1;\n        for(unsigned long i = 1; i <= k; ++i){\n            (ret *= (n - i + 1)) %= MOD;\n            (den *= i) %= MOD;\n        }\n        return modpow(den, MOD - 2, ret);\n    };\n    auto a = modbinomial(MOD - N, 3 * M) + N * modbinomial(MOD - N, M - 1);\n    a = M & 1 ? MOD - a % MOD : a % MOD;\n    if(M + 1 < N){\n        auto ub = min(N, 3 * M), lb = M, sz = (ub - lb) / 2;\n        vector<unsigned long> A(sz), B(sz);\n        {\n            auto k = M + 2;\n            auto nn = N, dd = k;\n            A[0] = modbinomial(nn, dd);\n            for(unsigned long i = 1; i < sz; ++i){\n                A[i] = modpow((dd + 1) * (dd + 2), MOD - 2, A[i - 1] * (nn - dd) % MOD * (nn - dd - 1));\n                dd += 2;\n            }\n        }\n        {\n            auto nn = N - 1 + (3 * M - (ub & ~(ub & 1))) / 2, dd = N - 1;\n            B.back() = modbinomial(nn, dd);\n            for(unsigned long i = sz - 1; i--; ++nn)B[i] = modpow(nn - dd + 1, MOD - 2, B[i + 1] * (nn + 1));\n        }\n        a += MOD - inner_product(A.begin(), A.end(), B.begin(), 0UL, plus<>(), [&MOD](auto a, auto b){return a * b % MOD;}) % MOD;\n    }\n    cout << a % MOD << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint main(){\n    using namespace std;\n    constexpr unsigned long MOD = 998244353;\n    size_t N, M;\n    cin >> N >> M;\n    if(M + 1 < N)return 0 & puts(\"sorry...\");\n    auto modpow = [&MOD](unsigned long a, unsigned long n, unsigned long b = 1) -> unsigned long{\n        auto ret = b;\n        while(n){\n            if(n & 1)(ret *= a) %= MOD;\n            (a *= a) %= MOD;\n            n >>= 1;\n        }\n        return ret;\n    };\n    auto modbinomial = [&MOD, &modpow](unsigned long n, unsigned long k) -> unsigned long{\n        unsigned long ret = 1, den = 1;\n        for(unsigned long i = 1; i <= k; ++i){\n            (ret *= (n - i + 1)) %= MOD;\n            (den *= i) %= MOD;\n        }\n        return modpow(den, MOD - 2, ret);\n    };\n    auto a = modbinomial(MOD - N, 3 * M) + N * modbinomial(MOD - N, M - 1);\n    cout << (M & 1 ? MOD - a % MOD : a % MOD) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n#define FOR(i, a, b) for(int i = a; i<b; i++)\n#define rep(i, n) FOR(i, 0, n)\n#define rFOR(i, a, b) for(int i = a;i >= b; i--)\n#define rrep(i, a) rFOR(i, a, 0)\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntypedef pair<ll,ll> P;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vP;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\nconst ll MOD = 1000000007;\nconst ll MOD2 = 998244353;\nconst ld PI = acos(-1);\nconst ll INF = 1e18;\nstruct edge{ll to, cost;};\n\ntemplate <typename T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n      a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmin(T &a, const T &b) {\n    if (a > b) {\n      a = b;\n      return true;\n    }\n    return false;\n}\n\n//組み合わせを線形で\n//参考:https://drken1215.hatenablog.com/entry/2018/06/08/210000\n\nconst int MXN = 3000001;//変更可\nll fac[MXN], inv[MXN], finv[MXN];\n\nvoid COMinit(int M){\n    fac[0] = fac[1] = 1;\n    inv[1] = 1;\n    finv[0] = finv[1] = 1;\n    for(int i = 2; i < MXN; i++){\n        fac[i] = fac[i-1] * i % M;\n        inv[i] = M - M / i * inv[M%i] % M;\n        finv[i] = finv[i-1] * inv[i] % M;\n    }\n}\n\nll COMBI(int N,int K,int M){\n    if(N < K){\n        return 0;\n    }\n    if(N < 0||K < 0){\n        return 0;\n    }\n    return fac[N] * finv[N-K] % M * finv[K] % M;\n}\n\nll PERMU(int N,int K,int M){\n    if(N < K){\n        return 0;\n    }\n    if(N < 0||K < 0){\n        return 0;\n    }\n    return fac[N] * finv[N-K] % M;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    COMinit(MOD2);\n    int N, K;\n    cin >> N >> K;\n    ll ans = 0;\n    rep(i, K + 1){\n        if((K - i) % 2 == 0){\n            //cout << i << endl;\n            ans += COMBI(N, i, MOD2) * COMBI(N - 1 + (3 * K - i) / 2, N - 1, MOD2) % MOD2;\n            //cout << ans << endl;\n        }\n    }\n    FOR(i, 2 * K + 1, 3 * K + 1){\n        ans -= N * COMBI(3 * K - i + N - 2, N - 2, MOD2);\n        ans %= MOD2;\n        //cout << ans << endl;\n    }\n    cout << (ans % MOD2 + MOD2) % MOD2 << endl;\n}\n/*\noverflow checked?\ncorner case checked?\nboundary checked?\nnot TLE in worst case checked?\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = vector<int>;\nusing Vll = vector<ll>;\nusing Vld = vector<ld>;\nusing Vbo = vector<bool>;\nusing VV = vector<V>;\nusing VVll = vector<Vll>;\nusing VVld = vector<Vld>;\nusing VVbo = vector<Vbo>;\nusing VVV = vector<VV>;\nusing VVVll = vector<VVll>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\n#define rep2(i, m, n) for (int i = (m); i < (n); ++i)\n#define drep2(i, m, n) for (int i = (m)-1; i >= (n); --i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) (a).begin(), (a).end()\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\ntemplate<typename T> inline int sz(T &x) { return x.size(); }\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << '(' << p.first << \", \" << p.second << ')'; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << ' '; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int fLog2(const int x) { assert(x > 0); return 31-__builtin_clz(x); } // floor(log2(x))\ninline int fLog2(const ll x) { assert(x > 0); return 63-__builtin_clzll(x); }\ninline int cLog2(const int x) { assert(x > 0); return (x == 1) ? 0 : 32-__builtin_clz(x-1); } // ceil(log2(x))\ninline int cLog2(const ll x) { assert(x > 0); return (x == 1) ? 0 : 64-__builtin_clzll(x-1); }\ninline int popcount(const int x) { return __builtin_popcount(x); }\ninline int popcount(const ll x) { return __builtin_popcountll(x); }\nconst int INF  = 1<<30;\nconst ll INFll = 1ll<<62;\nconst ld EPS   = 1e-10;\nconst ld PI    = acos(-1.0);\n// const int MOD  = int(1e9)+7;\nconst int MOD  = 998244353;\n\n\nstruct mint {\n  ll x;\n  mint(ll x=0) : x((x%MOD+MOD)%MOD) {}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) { if ((x += a.x) >= MOD) x -= MOD; return *this; }\n  mint& operator-=(const mint a) { if ((x -= a.x) < 0) x += MOD; return *this; }\n  mint& operator*=(const mint a) { (x *= a.x) %= MOD; return *this; }\n  mint operator+(const mint a) const { return mint(*this) += a; }\n  mint operator-(const mint a) const { return mint(*this) -= a; }\n  mint operator*(const mint a) const { return mint(*this) *= a; }\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n  mint& operator/=(const mint r) {\n    ll a = r.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      ll t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = x * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  mint operator/(const mint a) const { return mint(*this) /= a; }\n};\n// istream& operator>>(istream& is, mint& a) { return is >> a.x; }\nostream& operator<<(ostream& os, const mint& a) { return os << a.x; }\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\nusing VVVm = vector<VVm>;\n\n\n// initialization\nconst int F_MAX = int(3e6)+10;\nll fac[F_MAX], finv[F_MAX], inv[F_MAX];\nvoid binom_init() {\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (int i = 2; i < F_MAX; ++i) {\n    fac[i] = fac[i-1] * i % MOD;\n    inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n    finv[i] = finv[i-1] * inv[i] % MOD;\n  }\n}\n\nmint binom(int n, int k) {\n  if (k < 0 || n < k) return 0;\n  return fac[n] * (finv[k] * finv[n-k] % MOD);\n}\n\nmint perm(int n, int k) {\n  if (k < 0 || n < k) return 0;\n  return fac[n] * finv[n-k];\n}\n\n\nint main() {\n  binom_init();\n  int n, m; cin >> n >> m;\n\n  auto f = [&] (int l) {\n    if (l >= 0 && l % 2 == 0) return binom(n+l/2-1, l/2);\n    else return mint(0);\n  };\n\n  mint ans = 0;\n  rep(k, min(n, m)+1) {\n    mint res = 0;\n    res += f(3*m - k);\n    res += f(3*m - (2*m+k));\n    res += f(3*m - (2*m+2+k));\n    ans += res * binom(n, k);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Benri { Benri() { std::cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(12);}} benri;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing pii = pair<int, int>;\nusing vll = vector<long long>;\nusing pll = pair<ll, ll>;\nusing ull = unsigned long long;\n\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n\n//constexpr long long MOD = 1000000007;\nconstexpr long long MOD = 998244353;\nconstexpr double EPS = 1e-10;\nconstexpr int INF = 1001001001;\nconstexpr ll LINF = 1001001001001001001ll;\n\n\nconst long long MAX = 2000000;\nlong long fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++) {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\ninline long long COM(long long n, long long k) {\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\n\nint main() {\n    ll N, M; cin >> N >> M;\n    COMinit();\n    ll res = 0;\n    ll m = M % 2;\n    for (ll X = m; X <= M; X += 2) {\n        ll a = (COM(N, X) * COM((3 * M - X) / 2 + N - 1, N - 1) ) % MOD;\n        ll b = (COM(N, X) * COM((M - X) / 2 + N - 1, N - 1) ) % MOD;\n        ll c = (COM(N - 1, X) * COM((M - X) / 2 + N - 2, N - 2) ) % MOD;\n        res = (res + a - b * N + c * N) % MOD;\n        res = (res + MOD) % MOD;\n    }\n\n    cout << res << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\nll mod=998244353;\n\nll fac[3000010];\n \nll modinv(ll a){\n    ll b=mod,u=1,v=0;\n    while(b){\n        ll t=a/b;\n        a-=t*b; swap(a,b);\n        u-=t*v; swap(u,v);\n        }\n        u%=mod;\n        if(u<0) u+=mod;\n    return u;\n}\n \nvoid modfac(){\n    fac[0]=1;\n    for(ll i=1;i<3000010;i++){\n        fac[i]=(fac[i-1]*i)%mod;\n    }\n}\n \nll modperm(ll n,ll k){\n    if(n<0||k<0||n<k) return 0;\n    else return (fac[n]*modinv(fac[n-k]))%mod;\n}\n \nll modcomb(ll n,ll k){\n    if(n<0||k<0||n<k) return 0;\n    else return ((fac[n]*modinv(fac[k]))%mod*modinv(fac[n-k]))%mod;\n}\n\nll modhom(ll n,ll k){\n  if(n==0&&k==0) return 1;\n  else if(n<0||k<0) return 0;\n  else return modcomb(n+k-1,k);\n}\n \nll modpow(ll a,ll b){\n  ll ans=1;\n  a%=mod;\n  while(b){\n    if(b&1) ans=ans*a%mod;\n    a=a*a%mod;\n    b>>=1;\n  }\n  return ans;\n}\n\nint main(){\n  modfac();\n  ll n,m;\n  cin >> n >> m;\n  ll ans=modhom(n,3*m);\n  for(ll i=m+1;i<=n;i++){\n    if((3*m-i)%2==0){\n      ans=(ans-modcomb(n,i)*modhom(n,(3*m-i)/2)%mod+mod)%mod;\n    }\n    else{\n      ans=(ans+modcomb(n,i)*modhom(n,(m-1-i)/2)%mod)%mod;\n    }\n  }\n  ans=(ans-modhom(n,m-1)*n%mod)%mod;\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define mod 998244353\n\nusing namespace std;\n\nllint n, m;\nconst int FACT_MAX = 4000005;\nllint fact[FACT_MAX], fact_inv[FACT_MAX];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < FACT_MAX; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfact_inv[FACT_MAX-1] = modpow(fact[FACT_MAX-1], mod-2);\n\tfor(int i = FACT_MAX-2; i >= 0; i--){\n\t\tfact_inv[i] = fact_inv[i+1] * (i+1) % mod;\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> n >> m;\n\tmake_fact();\n\t\n\tllint ans = 0;\n\tfor(int i = 0; i <= min(m, n); i++){\n\t\tif(m%2 != i%2) continue;\n\t\tllint rem = (3*m-i)/2;\n\t\tllint tmp = comb(rem+n-1, n-1);\n\t\tif(rem-(m+1) >= 0) tmp += mod - (n-i) * comb(rem-(m+1)+n-1, n-1) % mod, tmp %= mod;\n\t\tif(rem-m >= 0) tmp += mod - i * comb(rem-m+n-1, n-1) % mod, tmp %= mod;\n\t\tans += tmp * comb(n, i) % mod, ans %= mod;\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\n//const ll MOD = 1e9+7;\nconst ll MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst ld EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\ntemplate<ll mod> struct Mod_Int{\n    ll x;\n    Mod_Int() {}\n    Mod_Int(ll y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod){}\n\n    Mod_Int &operator += (const Mod_Int &p) {\n        x = (x + p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator -= (const Mod_Int &p) {\n        x = (x + mod - p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator *= (const Mod_Int &p) {\n        x = (x * p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator /= (const Mod_Int &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n\n    Mod_Int operator -() const {return Mod_Int(-x);}\n\n    Mod_Int operator + (const Mod_Int &p) const {return Mod_Int(*this) += p;}\n\n    Mod_Int operator - (const Mod_Int &p) const {return Mod_Int(*this) -= p;}\n\n    Mod_Int operator * (const Mod_Int &p) const {return Mod_Int(*this) *= p;}\n\n    Mod_Int operator / (const Mod_Int &p) const {return Mod_Int(*this) /= p;}\n\n    bool operator == (const Mod_Int &p) const {return x == p.x;}\n\n    bool operator != (const Mod_Int &p) const {return x != p.x;}\n\n    Mod_Int pow(ll n) const{\n        Mod_Int now = *this, ret = 1;\n        while(n > 0){\n            if(n & 1) ret *= now;\n            now *= now, n >>= 1;\n        }\n        return ret;\n    }\n\n    Mod_Int inverse() const{\n        return pow(mod-2);\n    }\n};\n\nusing mint = Mod_Int<MOD>;\nconst int MAX_N = 2e6;\nmint fac[MAX_N+1];\n\nvoid init(){\n    fac[0] = 1;\n    rep2(i, 1, MAX_N){\n        fac[i] = fac[i-1]*mint(i);\n    }\n}\n\nmint comb(mint n, mint k){\n    return fac[n.x]/(fac[n.x-k.x]*fac[k.x]);\n}\n\nmint perm(mint n, mint k){\n    return fac[n.x]/fac[n.x-k.x];\n}\n\nint main(){\n    int N, M;\n    cin >> N >> M;\n    init();\n    mint ans = 0;\n    //奇数の山の個数\n    for(int i = M&1; i <= min(N, M); i += 2){\n        //残った2の個数\n        int j = (3*M-i)/2;\n        mint tmp = comb(N-1+j, j);\n        tmp -= (mint)i * comb(N-1+j-M, j-M);\n        if(j >= M+1) tmp -= (mint)(N-i) * comb(N-1+j-M-1, j-M-1);\n        ans += tmp * comb(N, i);\n    }\n    cout << ans.x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=1500005,INF=1<<30;\n\nll inv[MAX],fac[MAX],finv[MAX];\n\nvoid make(){\n    \n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    \n    for(int i=2;i<MAX;i++){\n        inv[i]=mod-inv[mod%i]*(mod/i)%mod;\n        fac[i]=fac[i-1]*(ll)i%mod;\n        finv[i]=finv[i-1]*inv[i]%mod;\n    }\n    \n}\n\nll comb(ll a,ll b){\n    if(a<b) return 0;\n    return fac[a]*(finv[b]*finv[a-b]%mod)%mod;\n}\n\nint main(){\n    \n    make();\n    \n    int N,M;cin>>N>>M;\n    \n    ll sum=0;\n    \n    for(int i=M;i>=0;i-=2){\n        ll rem=(3*M-i)/2;\n        sum+=comb(rem+N-1,N-1);\n        sum%=mod;\n    }\n    \n    for(int i=M;i>=0;i-=2){\n        ll rem=(M-i)/2;\n        sum+=mod-comb(rem+N-1,N-1);\n        sum%=mod;\n    }\n    \n    for(int i=M;i>=0;i-=2){\n        ll rem=(M-i)/2;\n        sum+=comb(rem+N-2,N-2);\n        sum%=mod;\n    }\n    \n    cout<<sum<<endl;\n    \n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\n#define MOD 998244353ll // prime\n// How to devide :\n// ModInt a(6ll);\n// ModInt b(2ll);\n// a *= b.exp(MOD-2ll);  -> a/=b;  result: a = 3\nstruct ModInt{\n\tll val;\n\tModInt():val(0ll){}\n\tModInt(ll v):val(((v%MOD)+MOD)%MOD){}\n\tModInt exp(ll y)const{\n\t\tif(!y)return ModInt(1ll);\n\t\tModInt a = exp(y/2ll);\n\t\ta *= a;\n\t\tif(y&1)a*=(*this);\n\t\treturn a;\n\t}\n\tbool operator==(const ModInt& x)const{return val==x.val;}\n\tinline bool operator!=(const ModInt& x)const{return !(*this==x);}\n\tbool operator<(const ModInt& x)const{return val<x.val;}\n\tbool operator>(const ModInt& x)const{return val>x.val;}\n\tinline bool operator>=(const ModInt& x)const{return !(*this<x);}\n\tinline bool operator<=(const ModInt& x)const{return !(*this>x);}\n\tModInt& operator+=(const ModInt& x){if((val+=x.val)>=MOD)val-=MOD;return *this;}\n\tModInt& operator-=(const ModInt& x){if((val+=MOD-x.val)>=MOD)val-=MOD;return *this;}\n\tModInt& operator*=(const ModInt& x){(val*=x.val)%=MOD;return *this;}\n\tModInt operator+(const ModInt& x)const{return ModInt(*this)+=x;}\n\tModInt operator-(const ModInt& x)const{return ModInt(*this)-=x;}\n\tModInt operator*(const ModInt& x)const{return ModInt(*this)*=x;}\n};\nistream& operator>>(istream&i,ModInt&x){i>>x.val;return i;}\nostream& operator<<(ostream&o,const ModInt&x){o<<x.val;return o;}\nModInt pow(ModInt a,ll x){\n\tModInt res = ModInt(1ll);\n\twhile(x){\n\t\tif(x&1)res *= a;\n\t\tx >>= 1;\n\t\ta = a*a;\n\t}\n\treturn res;\n}\nconst int SIZE = 10000100;\nModInt inv[SIZE+10],fac[SIZE+10],facinv[SIZE+10];\n// notice: 0C0 = 1 \nModInt nCr(int n,int r){\n\t//assert(!(n<r));\n\t// assert(!(n<0||r<0));\n\treturn fac[n]*facinv[r]*facinv[n-r];\n}\nvoid init(){\n\tfac[0]=ModInt(1ll);\n\tfor(int i=1;i<=SIZE;i++)fac[i]=fac[i-1]*ModInt(i);\n\tinv[1]=ModInt(1ll);\n\tfor(int i=2;i<=SIZE;i++)inv[i]=ModInt(0ll)-ModInt(MOD/i)*inv[MOD%i];\n\tfacinv[0]=ModInt(1ll);\n\tfor(int i=1;i<=SIZE;i++)facinv[i]=facinv[i-1]*inv[i];\n\treturn;\n}\nint N,M;\nint main(){\n\tinit();\n\tcin >> N >> M;\n\tModInt ans = nCr(3*M+N-1,N-1);\n\t//cout << ans << endl;\n\tfor(int i=2*M+1;i<=3*M;i++){\n\t\tModInt ret = ModInt(N)*nCr(N-2+3*M-i,3*M-i);\n\t\tans -= ret;\n\t\t//cout << ret << endl;\n\t}\n\tfor(int i=M+1;i<=N;i++){\n\t\tif((3*M-i)%2==0){\n\t\t\tModInt ret;\n\t\t\tret = nCr(N,i)*nCr(N-1+(3*M-i)/2,N-1);\n\t\t\tans -= ret;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MOD = 998244353;\n\nlong long fact[1500005];\n\nlong long powmod(long long a, long long b){\n    long long x = 1;\n    long long y = a;\n    while(b){\n        if(b&1){ x = (x*y)%MOD; }\n        y = (y*y)%MOD;\n        b >>= 1;\n    }\n    return x;\n}\n\ninline long long ncr(long long a, long long b){\n    return fact[a]*powmod((fact[a-b]*fact[b])%MOD, MOD-2)%MOD;\n}\n\nlong long solve(int N, int sum, int k){\n    // exactly N non-negative integers\n    // the sum is the variable sum\n    // exactly k odd\n    if((sum-k)&1){return 0;}\n    if(sum-k<0){return 0;}\n\n    // Let's make the k odd integers non-negative even integers\n    // Then, the sum becomes (sum-k) and we can then divide by 2 to normalise the non-negative integers\n    // The integers can now be any non-negative integer, without any other restriction, so formula can be used.\n    // (((sum-k)/2)+(N-1)) choose (N-1) ways to make such integers\n\n    // Don't forget that there are N choose k ways to arrange the odd integers.\n    return ncr(N, k)*ncr( ((sum-k)>>1)+(N-1) , N-1)%MOD;\n}\n\nint main(){\n    int N, M;\n    scanf(\"%d%d\", &N, &M);\n\n    fact[0] = 1;\n    for(int i = 1; i <= 1500004; i ++){\n        fact[i] = (fact[i-1]*i)%MOD;\n    }\n\n    // Let us ignore the maximum integer rule and count the number of ways\n    // There can only be at most M odd integers.\n    long long temp1 = 0;\n    for(int k = 0; k <= min(M, N); k ++){\n        temp1 += solve(N, 3*M, k);\n        //printf(\"solve(%d, %d, %d)=%lld\\n\", N, 3*M, k, solve(N, 3*M, k));\n    }\n    temp1 %= MOD;\n\n    // Notice that the maximum integer cannot exceed 2M. There can only be a maximum of one violation\n    // because 2M+2M = 4M > 3M, a contradiction. Hence, there are N ways to choose the violating integer.\n    // Then, we can subtract 2M from the offending integer. 2M is even, hence there is no effect on parity.\n    // Conditions remain the same as before, except that the offending integer must be positive.\n    long long temp2 = 0;\n    for(int k = 0; k <= min(M, N); k ++){\n        temp2 += solve(N, M, k);\n    }\n    temp2 %= MOD;\n    temp2=temp2*N%MOD;\n\n    // Now, we count number of ways such that the offending integer is 0 because we have over-subtracted those cases.\n    // There are only N-1 integers left since the offending integer can be removed, and that the number of odd\n    // integers would remain the same since M is even.\n    long long temp3 = 0;\n    for(int k = 0; k <= min(M, N-1); k ++){\n        temp3 += solve(N-1, M, k);\n    }\n    temp3 %= MOD;\n    temp3=temp3*N%MOD;\n\n    //printf(\"temp1=%lld temp2=%lld temp3=%lld\\n\", temp1, temp2, temp3);\n\n    long long ans = (temp1-temp2+temp3+MOD*3)%MOD;\n    printf(\"%lld\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LLI long long int\n#define FOR(v, a, b) for(LLI v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(LLI v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(LLI v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define fst first\n#define snd second\n#define popcount __builtin_popcount\n#define UNIQ(v) (v).erase(unique(ALL(v)), (v).end())\n#define bit(i) (1LL<<(i))\n\n#ifdef DEBUG\n#include <misc/C++/Debug.cpp>\n#else\n#define dump(...) ((void)0)\n#endif\n\n#define gcd __gcd\n\nusing namespace std;\ntemplate <class T> constexpr T lcm(T m, T n){return m/gcd(m,n)*n;}\n\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\ntemplate <typename T, typename U> istream& operator>>(istream &is, pair<T,U> &p){is >> p.first >> p.second; return is;}\n\ntemplate <typename T, typename U> bool chmin(T &a, const U &b){return (a>b ? a=b, true : false);}\ntemplate <typename T, typename U> bool chmax(T &a, const U &b){return (a<b ? a=b, true : false);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\n\nconst LLI mod = 998244353;\n\ntemplate <uint32_t M> class ModInt{\npublic:\n  uint64_t val;\n  ModInt(): val(0){}\n  ModInt(int64_t n): val(n>=M ? n%M : n){}\n  \n  constexpr ModInt operator+(const ModInt &a) const {return ModInt((val+a.val)%M);}\n  constexpr ModInt operator-(const ModInt &a) const {return ModInt((val-a.val+M)%M);}\n  constexpr ModInt operator*(const ModInt &a) const {return ModInt((val*a.val)%M);}\n  constexpr ModInt operator/(const ModInt &a) const {return ModInt((val*a.mod_inv().val)%M);}\n  \n  constexpr ModInt& operator=(const ModInt &a){val = a.val; return *this;}\n  constexpr ModInt& operator+=(const ModInt &a){if((val += a.val) >= M) val -= M; return *this;}\n  constexpr ModInt& operator-=(const ModInt &a){if(val < a.val) val += M; val -= a.val; return *this;}\n  constexpr ModInt& operator*=(const ModInt &a){(val *= a.val) %= M; return *this;}\n  constexpr ModInt& operator/=(const ModInt &a){(val *= a.mod_inv().val) %= M; return *this;}\n\n  constexpr bool operator==(const ModInt &a) const {return val==a.val;}\n  constexpr bool operator!=(const ModInt &a) const {return val!=a.val;}\n\n  constexpr ModInt power(LLI p) const{\n    ModInt ret = 1, e = val;\n    for(; p; e *= e, p >>= 1) if(p&1) ret *= e;\n\n    return ret;\n  }\n  \n  constexpr ModInt mod_inv() const{\n    int64_t a = val, b = M, u = 1, v = 0;\n\n    while(b){\n      int64_t t = a/b;\n      a -= t*b; swap(a,b);\n      u -= t*v; swap(u,v);\n    }\n    u %= M;\n    if(u < 0) u += M;\n    \n    return u;\n  }\n};\n\ntemplate <uint32_t M> ModInt<M> operator+(int64_t a, const ModInt<M> &b){return ModInt<M>(ModInt<M>(a)+b.val);}\ntemplate <uint32_t M> ModInt<M> operator-(int64_t a, const ModInt<M> &b){return ModInt<M>(ModInt<M>(a)-b.val);}\ntemplate <uint32_t M> ModInt<M> operator*(int64_t a, const ModInt<M> &b){return ModInt<M>(ModInt<M>(a)*b.val);}\ntemplate <uint32_t M> ModInt<M> operator/(int64_t a, const ModInt<M> &b){return ModInt<M>(ModInt<M>(a)/b.val);}\n\ntemplate <uint32_t M> istream& operator>>(istream &is, ModInt<M> &a){is >> a.val; return is;}\ntemplate <uint32_t M> ostream& operator<<(ostream &os, const ModInt<M> &a){ os << a.val; return os;}\n\nusing mint = ModInt<mod>;\n\n\n/**\n * @attention 使用前にinit関数を呼び出す\n */\ntemplate <LLI M> class Combination{\npublic:\n  //  using mint = ModInt<M>;\n  \n  static vector<mint> facto;\n  static vector<mint> ifacto;\n\n  static void init(int N){\n    facto.assign(N+1, 1);\n    ifacto.assign(N+1, 1);\n\n    FORE(i,1,N){\n      facto[i] = facto[i-1] * i;\n    }\n\n    ifacto[N] = 1 / facto[N];\n\n    REV(i,N-1,0){\n      ifacto[i] = ifacto[i+1] * (i+1);\n    }\n  }\n\n  static mint factorial(int i){\n    assert(i < (int)facto.size());\n    return facto[i];\n  }\n  \n  static mint factorial_inverse(int i){\n    assert(i < (int)ifacto.size());\n    return ifacto[i];\n  }\n\n  static mint P(int n, int k);\n  static mint C(int n, int k);\n  static mint H(int n, int k);\n  static mint stirling_number(LLI n, LLI k);\n  static mint bell_number(LLI n, LLI k);\n};\n\ntemplate <LLI M> vector<mint> Combination<M>::facto = vector<mint>();\ntemplate <LLI M> vector<mint> Combination<M>::ifacto = vector<mint>();\n\ntemplate <LLI M> mint Combination<M>::P(int n, int k){\n  if(n < k or n < 0 or k < 0) return 0;\n  return factorial(n) * factorial_inverse(n-k);\n}\n\ntemplate <LLI M> mint Combination<M>::C(int n, int k){\n  if(n < k or n < 0 or k < 0) return 0;\n  return P(n,k) * factorial_inverse(k);\n}\n\ntemplate <LLI M> mint Combination<M>::H(int n, int k){\n  if(n == 0 and k == 0) return 1;\n  return C(n+k-1, k);\n}\n\n\n\nusing Com = Combination<mod>;\n\n\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  Com::init(2000000);\n\n  int n,m;\n  while(cin >> n >> m){\n    mint ans = 0;\n\n    REPE(i,m){\n      if((3*m-i)%2==0){\n        ans += Com::C(n,i) * Com::C((3*m-i)/2+n-1,n-1);\n      }\n    }\n\n    mint t = 0;\n\n    REPE(i,m){\n      if((m-i)%2==0){\n        t += Com::C(n,i) * Com::C((m-i)/2+n-1,n-1);\n        t -= Com::C(n-1,i) * Com::C((m-i)/2+n-2,n-2);\n      }\n    }\n\n    t *= n;\n    \n    ans -= t;\n\n    cout << ans << endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sz(c)      int(c.size())\n#define rep(i,a,b) for (int i=a; i<(b); ++i)\n#define per(i,a,b) for (int i=(b)-1; i>=(a); --i)\nusing namespace std;\nusing ll = long long;\n\nint const MAXN=2.2e6;\nint const MD=998244353;\n\nint madd(int x,int y) {\n\tif (x+y<MD) return x+y; else return x+y-MD;\n}\nint msub(int x,int y) {\n\tif (x-y>=0) return x-y; else return x-y+MD;\n}\nint mmul(int x,int y) {\n\treturn int(ll(x)*y % MD);\n}\nint mpow(int x,int p) {\n\tint res=1;\n\twhile (p>0) {\n\t\tif (p%2) res=mmul(res,x);\n\t\tx=mmul(x,x);\n\t\tp/=2;\n\t}\n\treturn res;\n}\nint minv(int x) {\n\treturn mpow(x,MD-2);\n}\nint mdiv(int x,int y) {\n\treturn mmul(x,mpow(y,MD-2));\n}\n\nstruct mod_fact {\n\tvector<int> f,rf;\n\tmod_fact(int n):f(n),rf(n) {\n\t\tf[0]=rf[0]=1;\n\t\trep(i,1,n) {\n\t\t\tf[i]=mmul(f[i-1],i);\n\t\t\trf[i]=minv(f[i]);\n\t\t}\n\t}\n} mfact(MAXN);\n\nint comb(int n,int k) {\n\tif (n<k) return 0;\n\treturn mmul(mfact.f[n],mmul(mfact.rf[n-k],mfact.rf[k]));\n}\nint distr(int n,int k) {\n\treturn comb(n+k-1,k-1);\n}\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(10);\n\n\tint N,M;\n\tcin>>N>>M;\n\t\n\tint res=0;\n\trep(i,0,min(N,M)+1) if ((3*M-i)%2==0) {\n\t\tint add=mmul(comb(N,i),distr((3*M-i)/2,N));\n\t\tres=madd(res,add);\n\t}\n\trep(i,0,min(N,M)+1) if ((M-i)%2==0) {\n\t\tint sub=mmul(comb(N,i),distr((M-i)/2,N));\n\t\tres=msub(res,mmul(sub,N));\n\t}\n\trep(i,0,min(N,M)+1) if ((M-i)%2==0) {\n\t\tint add=mmul(comb(N-1,i),distr((M-i)/2,N-1));\n\t\tres=madd(res,mmul(add,N));\n\t}\n\tcout<<res<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n// cout << fixed << setprecision(20);\n\n//拡張ユークリッドの互除法\nint extgcd(int a, int b, int &x, int &y) {\n    int d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1;\n        y = 0;\n    }\n    return d;\n}\n\n// mod逆元\nint mod_inverse(int a, int m) {\n    int x, y;\n    extgcd(a, m, x, y);\n    return (m + x % m) % m;\n}\n\n// 階乗テーブル\nint fact[1800000];\n\nint mod_fact(int n, int m) {\n    fact[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i % m;\n    }\n}\n\nint N, M;\nint mod = 998244353;\n\nint mod_C(int n, int r, int m) {\n    return fact[n] * mod_inverse(fact[r], m) % m * mod_inverse(fact[n - r], m) % m;\n}\n\nint mod_H(int n, int r, int m) {\n    return mod_C(n + r - 1, r, m);\n}\n\nsigned main() {\n    mod_fact(1700000, mod);\n    cin >> N >> M;\n    int ans = mod_H(N, 3 * M, mod);\n    for (int i = 0; i < M; i++) {\n        ans = (ans + mod - (mod_H(N - 1, i, mod) * N % mod)) % mod;\n    }\n    cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "// InterestingLSY\n// 2659723130\n// 《幽灵公主》是真的好看！\n#include <bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define elif else if\n\n// Type\n#define ld double\n#define ll long long\n#define ull unsigned ll\n\n// Vector\n#define vc vector\n#define Pb push_back\n#define Pf push_front\n#define Eb emplace_back\n#define All(x) x.begin(),x.end()\n#define AllRev(x) x.rbegin(),x.rend()\n\n// Memory\n#define Ms(_data) memset(_data,0,sizeof(_data))\n#define Msn(_data,_num) memset(_data,_num,sizeof(_data))\n\n// Template\n#define _cl class\n#define _tp template\n#define _tyn typename\n\n// Pair\n#define Mp make_pair\n#define F first\n#define S second\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define pil pair<int,ll>\n#define pll pair<ll,ll>\n\n// Loop\n#define For(i,j) for( int (i) = 1 ; (i) <= (j) ; ++(i) )\n#define For0(i,j) for( int (i) = 0 ; (i) < (j) ; ++(i) )\n#define Forx(i,j,k) for( int (i) = (j) ; (i) <= (k) ; ++(i) )\n#define Forstep(i,j,k,st) for( int (i) = (j) ; (i) <= (k) ; (i) += (st) )\n#define fOR(i,j) for( int (i) = (j) ; (i) >= 1 ; --(i) )\n#define fOR0(i,j) for( int (i) = (j)-1 ; (i) >= 0 ; --(i) )\n#define fORx(i,j,k) for( int (i) = (k) ; (i) >= (j) ; --(i) )\n\n// Read\nstruct InputReader{\n\t#define bs 1048576\n\tchar buf[bs]; int p;\n\til InputReader(){ p = bs; }\n\til void Flush(){ p = 0; fread(buf,1,bs,stdin); }\n\til char C(){ if(p >= bs) Flush(); return buf[p++]; }\n\til char Readnum(){ char ch = C(); while( !isdigit(ch) && ch != '-' ) ch = C(); return ch; }\n\til void Readalpha( char &c ){ c = C(); while( !isalpha(c) ) c = C(); }\n\tint operator() (){\n\t\tint ans = 0, fu = 1; char ch = Readnum();\n\t\tif( ch == '-' ) fu = -1, ch = C();\n\t\twhile( ch >= '0' && ch <= '9' ){\n\t\t\tans = ans*10 + ch-'0';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\tll Readll(){\n\t\tll ans = 0LL, fu = 1LL; char ch = Readnum();\n\t\tif( ch == '-' ) fu = -1LL, ch = C();\n\t\twhile( ch >= '0' && ch <= '9' ){\n\t\t\tans = ans*10LL + ch-'0';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\til void Readstring( string &x ){\n\t\tx.clear(); char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  &&  ch != '#'  &&  ch != '.' ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  ||  ch == '#'  ||  ch == '.' ){\n\t\t\tx += ch;\n\t\t\tch = C();\n\t\t}\n\t}\n\til void Readchstring( char s[] ){\n\t\tint len = 0; char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  /*&&  ch != '*'  &&  ch != '?'*/ ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  /*||  ch == '*'  ||  ch == '?'*/ ){\n\t\t\ts[len++] = ch;\n\t\t\tch = C();\n\t\t}\n\t\ts[len] = '\\0';\n\t}\n\til void Specialread( char &c ){\n\t\tc = C();\n\t\twhile( !isdigit(c) && !isalpha(c) && c != '#'  &&  c != '.'  &&  c != '='  &&  c != 'B' ) c = C();\n\t}\n\t#undef bs\n}In;\nil void Read( int &x ){ x = In(); }\nil void Read( int &x, int &y ){ x = In(); y = In(); }\nil void Read( int &x1 , int &x2 , int &x3 ){ x1 = In(); x2 = In(); x3 = In(); }\nil void Read( int &x1 , int &x2 , int &x3 , int &x4 ){ x1 = In(); x2 = In(); x3 = In(); x4 = In(); }\nil void Read( ll &x ){ x = In.Readll(); }\nil void Read( ll &x, ll &y ){ x = In.Readll(); y = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 , ll &x4 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); x4 = In.Readll(); }\n_tp<_tyn T> void Read( T a[] , int st , int ed ){ Forx(i,st,ed) Read(a[i]); }\n#define iRead(k) int k; Read(k);\n#define iRead2(a,b) iRead(a); iRead(b);\n#define iRead3(a,b,c) iRead2(a,b); iRead(c);\n#define iRead4(a,b,c,d) iRead2(a,b); iRead2(c,d);\n#define lRead(k) ll k; Read(k);\n#define lRead2(a,b) lRead(a); lRead(b);\n#define lRead3(a,b,c) lRead2(a,b); lRead(c);\n#define lRead4(a,b,c,d) lRead2(a,b); lRead2(c,d);\n\n// File\n#define Fin(a) freopen(a,\"r\",stdin)\n#define Fout(a) freopen(a,\"w\",stdout)\nil void FILEIO(){\n\t#ifdef intLSY\n\t\tFin(\"in.in\");\n\t#endif\n}\nil void FILEIO( string pname ){\n\t#ifndef intLSY\n\t\tFin((pname+\".in\").c_str());\n\t\tFout((pname+\".out\").c_str());\n\t#else\n\t\tFin(\"in.in\");\n\t#endif\n}\nil void FILEIO_OICONTEST( string pname ){\n\tFin((pname+\".in\").c_str());\n\t#ifndef intLSY\n\t\tFout((pname+\".out\").c_str());\n\t#endif\n}\nvoid Printtime(){\n\t#ifdef intLSY\n\t\tdouble _timeuse = clock()* 1000.0 / CLOCKS_PER_SEC;\n\t\tfprintf(stderr,\"\\n\\nTime usage:\\n%.0lf ms\\n\",_timeuse);\n\t#endif\n}\nvoid END(){ Printtime(); exit(0); }\n_tp<_tyn T>void END( T mes ){ cout << mes << endl; END(); }\n\n// Debug\n#define B cerr << \"BreakPoint\" << endl;\n#define O(x) cerr << #x << \" \" << (x) << endl;\n#define o(x) cerr << #x << \" \" << (x) << \"  \";\n#define Msz(x) cerr << \"Sizeof \" << #x << \" \" << sizeof(x)/1024/1024 << \" MB\" << endl;\n_tp<_tyn T>void Print( T a[] , int s , int t , char sp = ' ' , char ed = '\\n' ){\n\tif( s > t ) return;\n\tfor( int i = s ; i < t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << a[t] << ed;\n\tcout.flush();\n}\n_tp<_tyn T>void Print( T a , int s = 0 , int t = -1 , char sp = ' ' , char ed = '\\n' ){\n\tif( t == -1 ) t = a.size()-1;\n\tfor( int i = s ; i <= t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << ed;\n\tcout.flush();\n}\n\n// Optimize\n#define Max(a,b) ((a)>(b)?(a):(b))\n#define Min(a,b) ((a)<(b)?(a):(b))\n#define Mymax(a,b) (a) = max((a),(b))\n#define Mymin(a,b) (a) = min((a),(b))\n#define MyMax(a,b) (a) = Max((a),(b))\n#define MyMin(a,b) (a) = Min((a),(b))\n#define INF (0x3f3f3f3f)\n#define LINF ((long long)(0x3f3f3f3f3f3f3f3f))\n#define Sqr(x) ((x)*(x))\n#define Lowbit(a) ((a)&(-(a)))\nvc<int> Range( int l , int r ){\n\tvc<int> ret{};\n\tForx(i,l,r) ret.Pb(i);\n\treturn ret;\n}\nmt19937 Rand(0xe38195e38293);\nconstexpr int MOD = 998244353;\n#define Rmoi(a,b) (((a)%b+b)%b)\n#define Rmo(a) (((a)%MOD+MOD)%MOD)\n#define Rmod(a) a = ((a%MOD+MOD)%MOD)\n#define Rmodi(a,b) a = ((a%(b)+(b))%(b))\n#define Mymoi(a,b) ((a)>=b?((a)-b):(a))\n#define Mymodi(a,b) a = ((a)>=(b))?((a)-(b)):(a)\ntemplate<typename T>\nil T Mymo( const T &x ){ return x >= MOD ? x-MOD : x; }\ntemplate<typename T>\nil void Mymod( T &x ){ x = x >= MOD ? x-MOD : x; }\ntemplate<typename T1, typename T2>\nil void Addi( T1 &x , const T2 &y ){ x = Mymo(x+y); }\ntemplate<typename T1, typename T2>\nil void Deci( T1 &x , const T2 &y ){ x = Mymo(x-y+MOD); }\ntemplate<typename T1, typename T2>\nil void Muli( T1 &x , const T2 &y ){ x = 1LL*x*y%MOD; }\nil ll Pow( ll a , ll b , const ll p = MOD ){\n\tll ret = 1;\n\tfor( ; b ; a = a*a%p, b >>= 1LL )\n\t\tif(b&1LL) ret = ret*a%p;\n\treturn ret;\n}\nil ll Inv( ll a , const ll p = MOD ){ return Pow(a,p-2LL,p); }\nil ll Fact( const ll &x ){\n\tll ret = 1;\n\tFor(i,x) ret = ret*i % MOD;\n\treturn ret;\n}\n\n#define FACT 2097152\nll fact[FACT], invfact[FACT];\nil void InitFact(){\n\tfact[0] = 1;\n\tFor(i,FACT-1) fact[i] = fact[i-1]*i % MOD;\n\tinvfact[FACT-1] = Inv(fact[FACT-1]);\n\tfOR0(i,FACT-1) invfact[i] = invfact[i+1]*(i+1) % MOD;\n}\nil ll C( int n , int m ){\n\tif( n < m ) return 0;\n\treturn fact[n] * invfact[m]%MOD * invfact[n-m]%MOD;\n}\n\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\nint n,m;\n\nll Section1(){\n\tll ans = 0;\n\tForx(i,0,min(n,m)){\n\t\tif((3*m-i)&1) continue;\n\t\tint evenput = (3*m-i) / 2;\n\t\tll tans = C(n,i) * C(evenput+n-1,n-1) % MOD;\n\t\tAddi(ans,tans);\n\t}\n\treturn ans;\n}\n\nll Section2(){\n\tll ans = 0;\n\tForx(i,0,min(n,m)){\n\t\tif((m-i)&1) continue;\n\t\tint evenput = (m-i) / 2;\n\t\tif(i) Addi(ans,C(n-1,i-1)*C(evenput+n-1,n-1)%MOD);\n\t\tif(evenput) Addi(ans,C(n-1,i)*C(evenput-1+n-1,n-1)%MOD);\n\t}\n\treturn ans*n % MOD;\n}\n\nint main(){\n\tFILEIO();\n\n\tInitFact();\n\tRead(n,m);\n\n\tll ans = Section1();\n\tDeci(ans,Section2());\n\n\tcout << ans << endl;\n\n\tEND();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\n#include<cstdio>\n#include<cstring>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\ntypedef vector<char> vc;\ntypedef string S;\ntypedef queue<int> qi;\ntypedef pair<ll,ll> P;\ntypedef vector<P> vp;\n//#define sort(a) sort(a.begin(),a.end())\n#define reverse(a) reverse(a.begin(),a.end())\n#define pb push_back\n#define elif else if\n#define unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mp make_pair\n#define fr(i,n)for(ll i=0;i<(n);i++)\n#define ifr(i,n)for(ll i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\nconst int MAX = 510000;\nconst int MOD = 998244353;\n\nll fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (ll i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nll COM(ll n, ll k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nint main() {\n    // 前処理\n    COMinit();\n    ll n,m;cin>>n>>m;\n    ll ans = COM(3*m+n-1,n-1);\n    fr(i,m){\n        ans -= COM(n-2+i,n-2)*n;\n        ans %=MOD;\n        if (ans < 0){\n            ans +=MOD;\n        }\n    }\n    for(ll i = m+1;i<=min(3*m,n);i++){\n        if((3*m-i)%2==0){\n            ans -= COM(n,i)*COM((3*m-i)/2 + n -1,n-1);\n            ans %=MOD;\n            if (ans < 0){\n                ans +=MOD;\n            }\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll, int> plli;\ntypedef pair<int, pii> pipii;\ntypedef vector<vector<int> > mati;\ntypedef vector<vector<double> > matd;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\ntypedef vector<bool> vb;\ntypedef vector<vector<bool>> vvb;\ntypedef vector<vector<vector<bool>>> vvvb;\ntypedef vector<pll> vpll;\n\n#define FOR(i,x,y) for(ll i=(ll)x; i<(ll)y; ++i)\n#define REP(i,y) FOR(i, 0, y)\n#define RFOR(i,x,y) for(ll i=(ll)x; i>=(ll)y; --i)\n#define RREP(i,x) RFOR(i, x, 0)\n#define ALL(a) a.begin(), a.end()\n#define pb push_back\n\ninline void IN(void){\n  return;\n}\n\ntemplate <typename First, typename... Rest>\nvoid IN(First& first, Rest&... rest){\n  cin >> first;\n  IN(rest...);\n  return;\n}\n\ninline void OUT(void){\n  cout << \"\\n\";\n  return;\n}\n\ntemplate <typename First, typename... Rest>\nvoid OUT(First first, Rest... rest){\n  cout << first << \" \";\n  OUT(rest...);\n  return;\n}\n\ntemplate <typename T>\nvoid vec_print(vector<T> VEC){\n  REP(i, VEC.size()){\n    cout << VEC[i] << \" \";\n  }\n  cout << \"\\n\";\n};\n\ntemplate <typename T>\nvoid mat_print(vector<vector<T> > MAT){\n  REP(i, MAT.size()){\n    REP(j, MAT[i].size()){\n      cout << MAT[i][j] << \" \";\n    }\n    cout << \"\\n\";\n  }\n};\n\ntemplate <typename CLASS1, typename CLASS2>\nclass HOGE{\n  public:\n    CLASS1 key;\n    CLASS2 value;\n    HOGE(void){\n      return;\n    };\n    HOGE(CLASS1 key, CLASS2 value){\n      this->key = key;\n      this->value = value;\n    };\n    ~HOGE(void){\n      return;\n    };\n\n    void print(void){\n      cout << \"key : \" << key << \", value : \" << value << \"\\n\";\n      return;\n    };\n    \n    bool operator==(const HOGE &obj){\n      return (this->value == obj.value);\n    };\n    bool operator<(const HOGE &obj){\n      return (this->value < obj.value);\n    };\n    bool operator>(const HOGE &obj){\n      return (this->value > obj.value);\n    };\n};\n\ntemplate <typename CLASS1, typename CLASS2>\nbool operator==(const HOGE<CLASS1, CLASS2> &hoge1, const HOGE<CLASS1, CLASS2> &hoge2){\n  return hoge1.value == hoge2.value;\n};\n\ntemplate <typename CLASS1, typename CLASS2>\nbool operator<(const HOGE<CLASS1, CLASS2> &hoge1, const HOGE<CLASS1, CLASS2> &hoge2){\n  return hoge1.value < hoge2.value;\n};\n\ntemplate <typename CLASS1, typename CLASS2>\nbool operator>(const HOGE<CLASS1, CLASS2> &hoge1, const HOGE<CLASS1, CLASS2> &hoge2){\n  return hoge1.value > hoge2.value;\n};\n\nconstexpr int INF = (1<<30);\nconstexpr ll INFLL = 1LL<<62;\nconstexpr long double EPS = 1e-12;\nconstexpr ll MOD = 998244353;\n\nll N,M;\nvvll dp;\nll MAX = 3000007;\nvll  fac_v(MAX);\nvll finv_v(MAX);\nvll  inv_v(MAX);\n\nll Comb(ll n, ll k){\n  if(n<k) return 0;\n  if(n<0 || k<0) return 0;\n  return (fac_v[n]*((finv_v[k]*finv_v[n-k])%MOD))%MOD;\n}\n\nll call_number(ll N, ll K){\n  //N個の番号なしの玉をK個の区別する箱に1個以上入れる場合の数\n  //= N-1個の隙間にK-1個の棒を入れる場合の数\n  if(N<K) return 0;\n  if(K<=0) return 0;\n  return Comb(N-1, K-1);\n}\n\nint main(){\n  cin.tie(0); // cut the cin and cout (default, std::flush is performed after std::cin)\n  ios::sync_with_stdio(false); // cut the iostream and stdio (DON'T endl; BUT \"\\n\";)\n\n  fac_v[0] = fac_v[1] = 1;\n  finv_v[0] = finv_v[1] = 1;\n  inv_v[1] = 1;\n  FOR(i,2,MAX){\n    fac_v[i] = (fac_v[i-1]*i)%MOD;\n    inv_v[i] = (MOD-(inv_v[MOD%i]*(MOD/i))%MOD)%MOD;\n    finv_v[i] = (finv_v[i-1]*inv_v[i])%MOD;\n  }\n\n  IN(N,M);\n\n  ll ans = call_number(3*M+N,N)%MOD;\n  FOR(i,2*M+1,3*M+1){\n    ans -= (N*call_number(3*M+(N-1)-i,(N-1)))%MOD;\n    ans = (ans+MOD)%MOD;\n  }\n  OUT(ans%MOD);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <math.h>\n#include <algorithm>\n#include <string.h>\n#include <tuple>\n#include <time.h>\n#include <random>\n#include <unistd.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 1e18;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\n//vector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<(x)<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<(x);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define line cout << \"----------\" << endl;\n\n\nll mod = 998244353;\nll rui(ll number1,ll number2){\n\n    if(number2 == 0){\n        return 1;\n    }else{\n        ll number3 = rui(number1,number2 / 2);\n        number3 *= number3;\n        number3 %= mod;\n        if(number2%2==1){\n            number3 *= number1;\n            number3 %= mod;\n        }\n        return number3;\n    }\n}\nll gcd(ll number1,ll number2){\n\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\n\nll fact[800005],rfact[800005];\n\nvoid c3_init(){\n    fact[0] = rfact[0] = 1;\n    for(ll i=1; i<=800000; i++){\n        fact[i] = (fact[i-1]*i) % mod;\n    }\n\trfact[800000] = rui(fact[800000],mod - 2);\n\tfor(ll i=800000; i>=1; i--){\n\t   rfact[i-1] = rfact[i] * i;\n\t   rfact[i-1] %= mod;\n\t}\n\treturn;}\nll c3(ll n,ll r){\n    return (((fact[n] * rfact[r]) % mod) * rfact[n-r]) % mod;}\n\n\nll n,m,num,sum,ans,a,b,c,d,e,g,h,w,i,j,k,q;\nll x[300005],y[300005],z[100005];\nll table[500005];\nll modans[500005];\nll table_num;\nchar s[500005];\n\nint main(){\n\tcin >> n >> m;\n    c3_init();\n    ll ans = c3(3*m+n-1,n-1);\n    for(i=2*m+1;i<=3*m;i++){\n        ll res = c3(3*m+n-2-i,n-2);\n        res = (res * n) % mod;\n        //p(res);\n        ans += (mod - res);\n        ans %= mod;\n    }\n    p(ans);\n\n\n    \n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = vector<int>;\nusing Vll = vector<ll>;\nusing Vld = vector<ld>;\nusing Vbo = vector<bool>;\nusing VV = vector<V>;\nusing VVll = vector<Vll>;\nusing VVld = vector<Vld>;\nusing VVbo = vector<Vbo>;\nusing VVV = vector<VV>;\nusing VVVll = vector<VVll>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\n#define rep2(i, m, n) for (int i = (m); i < (n); ++i)\n#define drep2(i, m, n) for (int i = (m)-1; i >= (n); --i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) (a).begin(), (a).end()\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\ntemplate<typename T> inline int sz(T &x) { return x.size(); }\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << '(' << p.first << \", \" << p.second << ')'; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << ' '; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int fLog2(const int x) { assert(x > 0); return 31-__builtin_clz(x); } // floor(log2(x))\ninline int fLog2(const ll x) { assert(x > 0); return 63-__builtin_clzll(x); }\ninline int cLog2(const int x) { assert(x > 0); return (x == 1) ? 0 : 32-__builtin_clz(x-1); } // ceil(log2(x))\ninline int cLog2(const ll x) { assert(x > 0); return (x == 1) ? 0 : 64-__builtin_clzll(x-1); }\ninline int popcount(const int x) { return __builtin_popcount(x); }\ninline int popcount(const ll x) { return __builtin_popcountll(x); }\nconst int INF  = 1<<30;\nconst ll INFll = 1ll<<62;\nconst ld EPS   = 1e-10;\nconst ld PI    = acos(-1.0);\n// const int MOD  = int(1e9)+7;\nconst int MOD  = 998244353;\n\n\nstruct mint {\n  ll x;\n  mint(ll x=0) : x((x%MOD+MOD)%MOD) {}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) { if ((x += a.x) >= MOD) x -= MOD; return *this; }\n  mint& operator-=(const mint a) { if ((x -= a.x) < 0) x += MOD; return *this; }\n  mint& operator*=(const mint a) { (x *= a.x) %= MOD; return *this; }\n  mint operator+(const mint a) const { return mint(*this) += a; }\n  mint operator-(const mint a) const { return mint(*this) -= a; }\n  mint operator*(const mint a) const { return mint(*this) *= a; }\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n  mint& operator/=(const mint r) {\n    ll a = r.x, b = MOD, u = 1, v = 0;\n    while (b) {\n      ll t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    x = x * u % MOD;\n    if (x < 0) x += MOD;\n    return *this;\n  }\n  mint operator/(const mint a) const { return mint(*this) /= a; }\n};\n// istream& operator>>(istream& is, mint& a) { return is >> a.x; }\nostream& operator<<(ostream& os, const mint& a) { return os << a.x; }\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\nusing VVVm = vector<VVm>;\n\n\n// initialization\nconst int F_MAX = int(3e6)+10;\nll fac[F_MAX], finv[F_MAX], inv[F_MAX];\nvoid binom_init() {\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (int i = 2; i < F_MAX; ++i) {\n    fac[i] = fac[i-1] * i % MOD;\n    inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n    finv[i] = finv[i-1] * inv[i] % MOD;\n  }\n}\n\nmint binom(int n, int k) {\n  if (k < 0 || n < k) return 0;\n  return fac[n] * (finv[k] * finv[n-k] % MOD);\n}\n\nmint perm(int n, int k) {\n  if (k < 0 || n < k) return 0;\n  return fac[n] * finv[n-k];\n}\n\n\nint main() {\n  binom_init();\n  int n, m; cin >> n >> m;\n\n  mint ans = 0;\n\n  rep(k, m+1) {\n    mint res = 0;\n    int l = 3*m - k;\n    if (l >= 0 && l % 2 == 0) res += binom(n+l/2-1, l/2);\n    l = 3*m - (2*m+k);\n    if (l >= 0 && l % 2 == 0) res -= binom(n+l/2-1, l/2) * k;\n    l = 3*m - (2*m+2+k);\n    if (l >= 0 && l % 2 == 0) res -= binom(n+l/2-1, l/2) * (n-k);\n    ans += res * binom(n, k);\n  }\n\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// https://atcoder.jp/contests/agc036/tasks/agc036_c\n#define CIN_ONLY\n#define DECIMAL_DIGITS 10\n#define STATIC_MOD 998244353\n#ifdef BTK\n/*<head>*/\n#    include \"Template.hpp\"\n#    include \"num/ModInt.hpp\"\n/*</head>*/\n#else\n/*<body>*/\n/* #region auto includes */\n/* #region stl */\n/*<stl>*/\n#    include <bits/stdc++.h>\n#    include <sys/types.h>\n#    include <unistd.h>\nusing namespace std;\n/*</stl>*/\n/* #endregion */\n/* #region template/IncludeSTL.hpp*/\n/**\n * @file IncludeSTL.hpp\n * @author btk\n * @brief 標準ライブラリをincludeするだけ\n * @version 0.1\n * @date 2019-07-21\n *\n * @copyright Copyright (c) 2019\n *\n */\n\n/*<head>*/\n#    pragma once\n/*</head>*/\n\n\n/*<stl>*/\n#    include <bits/stdc++.h>\n#    include <sys/types.h>\n#    include <unistd.h>\nusing namespace std;\n/*</stl>*/\n/* #endregion */\n/* #region template/Macro.hpp*/\n/**\n * @file Macro.hpp\n * @author btk\n * @brief マクロとか，LLとか\n * @version 0.1\n * @date 2019-07-13\n *\n * @copyright Copyright (c) 2019\n *\n */\n\n\n//! LL\nusing LL = long long;\n\n/**\n * @def DEBUG\n * @brief デバッグ用のif文 提出時はif(0)で実行されない\n */\n\n/*</head>*/\n#    ifdef BTK\n#        define DEBUG if (1)\n#    else\n#        ifdef CIN_ONLY\n#            define FAST_IO\n#        endif\n#        define DEBUG if (0)\n#    endif\n/**\n * @def ALL(v)\n * @brief\n * ALLマクロ\n */\n#    define ALL(v) (v).begin(), (v).end()\n\n/**\n * @def REC(ret, ...)\n * @brief\n * 再帰ラムダをするためのマクロ\n */\n#    define REC(ret, ...) std::function<ret(__VA_ARGS__)>\n\n/**\n * @def VAR_NAME(var)\n * @brief 変数名を取得する\n */\n#    define VAR_NAME(var) #    var\n\n/**\n * @brief\n * rangeで生まれる使わない変数を消す用（警告消し）\n */\ntemplate <typename T>\ninline T& unused_var(T& v) {\n    return v;\n}\n/* #endregion */\n/* #region template/IO.hpp*/\n/**\n * @file IO.hpp\n * @author btk\n * @brief cin高速化とか，出力の小数桁固定とか\n * @version 0.1\n * @date 2019-07-13\n *\n * @copyright Copyright (c) 2019\n */\n\n\n/**\n * @brief 入出力の設定を行うための構造体\n */\nstruct cww {\n    /**\n     * @brief Construct a new cww::cww object\n     * @details\n     * CIN_ONLYを定義すると，submit時にcinとscanfの同期を切る設定が走る\n     * DECIMAL_DIGITSを定義すると，doubleの出力時指定した桁数分小数部を吐くようになる\n     */\n    cww() {\n#    ifdef FAST_IO\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n#    endif\n#    ifdef DECIMAL_DIGITS\n        cout << fixed;\n        cout << setprecision(DECIMAL_DIGITS);\n#    endif\n    }\n};\n\n//! 入出力設定構造体を実体化\ncww star;\n\n/**\n * @brief\n * vectorに直接cin流すためのやつ\n * @tparam T\n * @param is\n * @param v\n * @return istream&\n */\ntemplate <typename T>\nstd::istream& operator>>(std::istream& is, std::vector<T>& v) {\n    for (auto& it : v) is >> it;\n    return is;\n}\n/* #endregion */\n/* #region template/Loop.hpp*/\n/**\n * @file Loop.hpp\n * @author btk\n * @brief rangeとかループ系のクラス\n * @version 0.1\n * @date 2019-07-13\n *\n * @copyright Copyright (c) 2019\n *\n */\n\n\n/**\n * @brief\n * rangeを逆向きに操作したいとき用\n * @details\n * ループの範囲は[bg,ed)なので注意\n * @see range\n */\nclass reverse_range {\n  private:\n    struct I {\n        int x;\n        int operator*() { return x - 1; }\n        bool operator!=(I& lhs) { return x > lhs.x; }\n        void operator++() { --x; }\n    };\n    I i, n;\n\n  public:\n    /**\n     * @brief Construct a new reverse range object\n     *\n     * @param n\n     */\n    reverse_range(int n) : i({0}), n({n}) {}\n    /**\n     * @brief Construct a new reverse range object\n     *\n     * @param i\n     * @param n\n     */\n    reverse_range(int i, int n) : i({i}), n({n}) {}\n    /**\n     * @brief\n     * begin iterator\n     * @return I&\n     */\n    I& begin() { return n; }\n    /**\n     * @brief\n     * end iterator\n     * @return I&\n     */\n    I& end() { return i; }\n};\n/**\n * @brief\n * python みたいな range-based for を実現\n * @details\n * ループの範囲は[bg,ed)なので注意\n * !つけると逆向きにループが回る (reverse_range)\n * 空間計算量はO(1)\n * 使わない変数ができて警告が出がちなので，unused_varとかを使って警告消しするとよい\n */\nclass range {\n  private:\n    struct I {\n        int x;\n        int operator*() { return x; }\n        bool operator!=(I& lhs) { return x < lhs.x; }\n        void operator++() { ++x; }\n    };\n    I i, n;\n\n  public:\n    /**\n     * @brief Construct a new range object\n     *\n     * @param n\n     */\n    range(int n) : i({0}), n({n}) {}\n    /**\n     * @brief Construct a new range object\n     *\n     * @param i\n     * @param n\n     */\n    range(int i, int n) : i({i}), n({n}) {}\n    /**\n     * @brief\n     * begin iterator\n     * @return I&\n     */\n    I& begin() { return i; }\n    /**\n     * @brief\n     * end iterator\n     * @return I&\n     */\n    I& end() { return n; }\n    /**\n     * @brief\n     * 逆向きに参照するrange(reverse_rangeを取得できるs)\n     * @return reverse_range\n     */\n    reverse_range operator!() { return reverse_range(*i, *n); }\n};\n/* #endregion */\n/* #region template/MinMaxOperation.hpp*/\n/**\n * @file MinMaxOperation.hpp\n * @author btk\n * @brief 最大値とか最小値を求める\n * @version 0.1\n * @date 2019-07-04\n *\n * @copyright Copyright (c) 2019\n *\n */\n\n/**\n * @brief 2項の最小値求める\n *\n * @tparam T\n */\ntemplate <typename T>\nstruct min_op {\n    /**\n     * @brief 本体\n     *\n     * @param l\n     * @param r\n     * @return T\n     */\n    static T exec(const T l, const T r) { return l < r ? l : r; }\n};\n\n/**\n * @brief 2項の最大値求める\n *\n * @tparam T\n */\ntemplate <typename T>\nstruct max_op {\n    /**\n     * @brief 本体\n     *\n     * @param l\n     * @param r\n     * @return T\n     */\n    static T exec(const T l, const T r) { return l > r ? l : r; }\n};\n\n/**\n * @brief テンプレート再帰の末尾\n *\n * @tparam F 二項演算\n * @tparam T\n * @param v\n * @return T\n */\ntemplate <typename F, typename T>\ninline T multi_op(T&& v) {\n    return v;\n}\n\n/**\n * @brief 複数項における演算の結果を返す\n *\n * @tparam F\n * @tparam T\n * @tparam Ts\n * @param head\n * @param tail\n * @return T\n */\ntemplate <typename F, typename T, typename... Ts>\ninline T multi_op(const T head, Ts&&... tail) {\n    return F::exec(head, multi_op<F>(tail...));\n}\n\n/**\n * @brief 複数項の最小値\n * @see multi_op\n * @tparam T\n * @tparam Ts\n * @param head\n * @param tail\n * @return T\n */\ntemplate <typename T, typename... Ts>\ninline T multi_min(T&& head, Ts&&... tail) {\n    return multi_op<min_op<T>>(head, tail...);\n}\n\n/**\n * @brief 複数項の最大値\n * @see multi_op\n * @tparam T\n * @tparam Ts\n * @param head\n * @param tail\n * @return T\n */\ntemplate <typename T, typename... Ts>\ninline T multi_max(T&& head, Ts&&... tail) {\n    return multi_op<max_op<T>>(head, tail...);\n}\n\n/**\n * @brief\n * \b先頭の値をFで参照する関数に基づいて変更できたらする\n * @tparam F\n * @tparam T\n * @tparam Ts\n * @param target\n * @param candidates\n * @return true\n * @return false\n */\ntemplate <typename F, typename T, typename... Ts>\ninline bool ch_op(T& target, Ts&&... candidates) {\n    const T old = target;\n    target      = multi_op<F>(target, candidates...);\n    return old != target;\n}\n\n/**\n * @brief change min\n * @tparam T 型\n * @param target 変更する値\n * @param candidates\n * @return 更新があればtrue\n */\ntemplate <typename T, typename... Ts>\ninline bool chmin(T& target, Ts&&... candidates) {\n    return ch_op<min_op<T>>(target, candidates...);\n}\n\n/**\n * @brief chminのmax版\n * @see chmin\n *  @tparam T 型\n * @param target 変更する値\n * @param candidates\n * @return 更新があればtrue\n */\ntemplate <typename T, typename... Ts>\ninline bool chmax(T& target, Ts&&... candidates) {\n    return ch_op<max_op<T>>(target, candidates...);\n}\n/* #endregion */\n/* #region template/Random.hpp*/\n/**\n * @file Random.hpp\n * @author btk\n * @brief 乱数生成系\n * @version 0.1\n * @date 2019-07-13\n * @copyright Copyright (c) 2019\n */\n\n\n//! 乱数のシード値をプロセスIDとして取得\nconst pid_t pid = getpid();\n\n/**\n * @brief XorShift32の実装\n */\nclass XorShift32 {\n  private:\n    //! XorShiftの現在の値\n    unsigned value;\n\n    /**\n     * @brief XorShift32のアルゴリズムに基づいて value を更新\n     */\n    inline void update() {\n        value = value ^ (value << 13);\n        value = value ^ (value >> 17);\n        value = value ^ (value << 5);\n    }\n\n    /**\n     * @brief 値を更新し，更新前の値を返却\n     * @return unsigned 呼び出し時の value を用いる\n     */\n    inline unsigned get() {\n        unsigned v = value;\n        update();\n        return v;\n    }\n\n  public:\n    /**\n     * @brief [0, 2^bit) の範囲の乱数値を取り出す\n     * @tparam デフォルトは31\n     * @return int\n     */\n    template <int bit = 31>\n    inline int next_int() {\n        return (int)(get() >> (32 - bit));\n    }\n\n    /**\n     * @brief [-2^bit,2^bit)の範囲の乱数値を取り出す\n     * @tparam デフォルトは31\n     * @return int\n     */\n    template <int bit = 31>\n    inline int next_signed() {\n        unsigned v = get();\n        return (int)((v >> (31 - bit)) - (1 << (bit)));\n    }\n\n    /**\n     * @brief next_int呼び出し時の最大値を取得\n     * @tparam 31\n     * @return int\n     */\n    template <int bit = 31>\n    inline int range_max() {\n        return (int)((1u << bit) - 1);\n    };\n\n    /**\n     * @brief Construct a new XorShift32 object\n     * @param seed\n     * @details 初期シードをvalueとするXorShift32のインスタンスを生成\n     */\n    XorShift32(const unsigned seed) {\n        value = seed;\n        update();\n    }\n\n    /**\n     * @brief Construct a new XorShift 32 object\n     * @details 初期シードをプロセスIDとするXorShift32のインスタンスを生成\n     */\n    XorShift32() : XorShift32(pid) {}\n};\n/* #endregion */\n/* #region Template.hpp*/\n/**\n * @file Template.hpp\n * @brief 競技プログラミング用テンプレート\n * @author btk15049\n * @date 2019/05/02\n */\n\n\n/* #endregion */\n/* #region num/ModInt.hpp*/\n\n#    include <utility>\n\n/**\n * @file ModInt.hpp\n * @brief mod構造体\n * @author btk15049\n * @date 2019/03/08\n * @details\n *  \\todo verifyが足りない\n *  verify: CSA12E，RUPC day3 F\n */\n\n//! [WARNING!] mod が入力で与えられる場合はconstexprを外す\n#    ifdef STATIC_MOD\nconstexpr int mod = STATIC_MOD;\n#    else\nint mod;\n#    endif\n\n/**\n * @brief mod構造体\n * @details\n * 整数をラップして，常に保持されているデータがmodされた状態になるよう管理．\n */\nclass ModInt {\n  private:\n    //! 中身\n    int x;\n\n  public:\n    /**\n     * @brief ゲッター\n     * @details 出力時などは \"cout << *ret << endl;\"のようにやるとよい．\n     */\n    long long operator*() const { return x; }\n    /**\n     * @brief デフォルトコンストラクタ．0で初期化される．\n     */\n    ModInt() { x = 0; }\n\n    /**\n     * @brief intからのコンストラクタ\n     * @param[in] y 設定したい値\n     * @details\n     * modをとらないので高速．ただしmodより大きい値や負の数を入れると事故るので注意．\n     */\n    ModInt(const int y) { x = y; }\n\n    /**\n     * @brief long longからのコンストラクタ\n     * @param[in] y 設定したい値\n     * @details 毎回modを取るので低速．\n     */\n    ModInt(const long long y) { x = (int)((mod + y % mod) % mod); }\n\n    /**\n     * @brief ModIntからの代入演算子\n     * @param[in] o 設定したい値\n     * @details 高速\n     */\n    ModInt(const ModInt& o) { this->x = *o; }\n    /**\n     * @brief 整数から高速にModIntを作りたいときに使う\n     * @param[in] x 設定したい値\n     * @details xが[0,mod)であることが保証されてないと正しく動かない．\n     */\n    static inline ModInt raw(const long long x) {\n        // assert(x<mod);\n        return ModInt((int)x);\n    }\n\n    /**\n     * @brief 整数から安全にModIntを作りたいときに使う\n     * @param[in] x 設定したい値\n     * @details mod2回取るから遅い．負数でもOK．\n     */\n    static inline ModInt get(const long long x) { return ModInt(x); }\n\n    /**\n     * @brief intからの代入演算子\n     * @param[in] o 設定したい値\n     * @details\n     * modをとらないので高速．ただしmodより大きい値や負の数を入れると事故るので注意．\n     */\n    ModInt& operator=(const int o) {\n        this->x = o >= mod ? o - mod : o;\n        return *this;\n    }\n\n    /**\n     * @brief long longからの代入演算子\n     * @param[in] o 設定したい値\n     * @details mod2回取るから遅い．負数でもOK．\n     */\n    ModInt& operator=(const long long o) {\n        this->x = (int)((mod + o % mod) % mod);\n        return *this;\n    }\n\n    /**\n     * @brief ModIntからの代入演算子\n     * @param[in] o 設定したい値\n     * @details 高速\n     */\n    ModInt& operator=(const ModInt o) {\n        this->x = *o;\n        return *this;\n    }\n};\n\n/**\n * @param[in] l ModInt\n * @param[in] r ModInt\n * @details if文使って少し高速化．\n */\ninline ModInt add(const ModInt l, const ModInt r) {\n    const long long x = *l + *r;\n    return ModInt::raw(x >= mod ? x - mod : x);\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r ModInt．\n */\ninline ModInt mul(const ModInt l, const ModInt r) {\n    return ModInt::raw(*l * *r % mod);\n}\n\n/**\n * @brief a^x %modを求める\n * @param[in] a ModInt\n * @param[in] x long long．\n */\ninline ModInt pow(ModInt a, long long x) {\n    ModInt ret = ModInt::raw(1);\n    while (x) {\n        if (x & 1) {\n            ret = mul(ret, a);\n        }\n        a = mul(a, a);\n        x >>= 1;\n    }\n    return ret;\n}\n\n/**\n * @brief x^-1 %modを求める\n * @param[in] x ModInt．\n * @details\n *   内部ではユークリッドの拡張互助法を使っている．\n *   O(log(mod))\n */\ninline ModInt inv(const ModInt x) {\n    long long a = *x, b = mod, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        std::swap(a -= t * b, b);\n        std::swap(u -= t * v, v);\n    }\n    return ModInt::get(u);\n}\n\n/**\n * @brief 負数を求める単項演算子\n * @param[in] x ModInt\n */\ninline ModInt operator-(const ModInt x) { return add(mod, -*x); }\n\n/**\n * @param[in] l ModInt\n * @param[in] r ModInt\n */\ninline ModInt operator+(const ModInt l, const ModInt r) { return add(l, r); }\n\n/**\n * @param[in] l ModInt\n * @param[in] r ModInt\n */\ninline ModInt operator*(const ModInt l, const ModInt r) { return mul(l, r); }\n\n/**\n * @param[in] l ModInt\n * @param[in] r ModInt\n */\ninline ModInt operator-(const ModInt l, const ModInt r) { return add(l, -r); }\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n * @details\n * 右辺は定数を想定しているのでmodをとらないrawを使ってModIntに変換している．ただしmodより大きい値や負の数を入れると事故るので注意．\n */\ninline ModInt operator+(const ModInt l, const int r) {\n    return add(l, ModInt::raw(r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n */\ninline ModInt operator+(const ModInt l, const long long r) {\n    return add(l, ModInt::get(r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n * @details\n * 右辺は定数を想定しているのでmodをとらないrawを使ってModIntに変換している．ただしmodより大きい値や負の数を入れると事故るので注意．\n */\ninline ModInt operator*(const ModInt l, const int r) {\n    return mul(l, ModInt::raw(r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n */\ninline ModInt operator*(const ModInt l, const long long r) {\n    return mul(l, ModInt::get(r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n * @details\n * 右辺は定数を想定しているのでmodをとらないrawを使ってModIntに変換している．ただしmodより大きい値や負の数を入れると事故るので注意．\n */\ninline ModInt operator-(const ModInt l, const int r) {\n    return add(l, ModInt::raw(mod - r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n */\ninline ModInt operator-(const ModInt l, const long long r) {\n    return add(l, -ModInt::get(r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n * @details\n * 右辺は定数を想定しているのでmodをとらないrawを使ってModIntに変換している．ただしmodより大きい値や負の数を入れると事故るので注意．\n */\ninline ModInt operator/(const ModInt l, const int r) {\n    return mul(l, inv(ModInt::raw(r)));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n */\ninline ModInt operator/(const ModInt l, const long long r) {\n    return mul(l, inv(ModInt::get(r)));\n}\n\n/**\n* @param[in] l ModInt\n* @param[in] r long long\n* @details\n*   pow(l,r)を呼び出すだけなのでpowを参照のこと．\n計算量はO(log mod)\n*/\ninline ModInt operator^(const ModInt l, const long long r) { return pow(l, r); }\n\n/**\n * @brief\n * +=の実装、各operator+を呼ぶだけ\n * @tparam T\n * @param l ModInt\n * @param r 足すやつ\n * @return ModInt&\n */\ntemplate <typename T>\nModInt& operator+=(ModInt& l, T r) {\n    l = l + r;\n    return l;\n}\n\n/**\n * @brief\n * -=の実装、各operator-を呼ぶだけ\n * @tparam T\n * @param l ModInt\n * @param r 引くやつ\n * @return ModInt&\n */\ntemplate <typename T>\nModInt& operator-=(ModInt& l, T r) {\n    l = l - r;\n    return l;\n}\n\n/**\n * @brief\n * *=の実装、各operator*を呼ぶだけ\n * @tparam T\n * @param l ModInt\n * @param r かけるやつ\n * @return ModInt&\n */\ntemplate <typename T>\nModInt& operator*=(ModInt& l, T r) {\n    l = l * r;\n    return l;\n}\n\n/**\n * @namespace factorial\n * @brief 順列数関連の関数のまとめ\n * @details\n *   - combination\n *   - permutation\n *   - multiChoose\n */\nnamespace factorial {\n    //! 順列数を格納する配列のサイズ\n    constexpr int size =\n#    ifdef FACTORIAL_SIZE\n        FACTORIAL_SIZE;\n#    else\n        3123456;\n#    endif\n    //! 前計算ができているかどうかのフラグ\n    bool is_build = false;\n\n    //! 順列数を格納する配列\n    ModInt factorial[size];\n    //! (順列数)^-1を格納する配列\n    ModInt inverse_factorial[size];\n\n    /**\n     * @brief 順列数の前計算\n     * @details\n     *   順列数と，その逆元を[0,size)まで求める.\n     *   計算量は，O(size + log(mod))\n     */\n    void build() {\n        is_build     = true;\n        factorial[0] = 1;\n        for (int i = 1; i < size; i++) {\n            factorial[i] = factorial[i - 1] * i;\n        }\n        inverse_factorial[size - 1] = inv(factorial[size - 1]);\n        for (int i = size - 1; i >= 1; i--) {\n            inverse_factorial[i - 1] = inverse_factorial[i] * i;\n        }\n    }\n\n    /**\n     * @brief nPkを求める\n     * @details\n     *   前計算がしてあれば O(1)．前計算してない場合は is_build\n     * を読み取って前計算をする．\n     */\n    inline ModInt permutation(int n, int k) {\n        if (k < 0 || k > n) return ModInt::raw(0);\n        if (!is_build) build();\n        return factorial[n] * inverse_factorial[n - k];\n    }\n\n    /**\n     * @brief nCkを求める\n     * @details\n     *   前計算がしてあれば O(1)．前計算してない場合は is_build\n     * を読み取って前計算をする．\n     */\n    inline ModInt combination(int n, int k) {\n        if (k < 0 || k > n) return ModInt::raw(0);\n        if (!is_build) build();\n        return factorial[n] * inverse_factorial[k] * inverse_factorial[n - k];\n    }\n\n    /**\n     * @brief 重複組合せ\n     * @param n 何種類のものを\n     * @param r いくつ並べるか\n     * @return ModInt nHr\n     */\n    ModInt multiChoose(int n, int r) {\n        if (n == 0 && r == 0) return ModInt::raw(1);\n        return combination(n + r - 1, r);\n    }\n\n    /**\n     * @brief 上限付き重複組合せ\n     * @details\n     * 包除原理を用いて，lim個以上の品物が1,2,...,i種類の場合を足したり引いたりしていく\n     * 計算量は O(min(n, r / lim))\n     * @param n 何種類のものを\n     * @param r いくつ並べるか\n     * @param lim 1種類のものを選べる上限\n     * @return ModInt\n     */\n    ModInt multiChoose(int n, int r, int lim) {\n        ModInt ret = 0;\n        for (int i = 0; i <= n; i++) {\n            if (i * (lim + 1) > r) break;\n            ret += ((i & 1) ? mod - 1 : 1) * combination(n, i)\n                   * multiChoose(n, r - i * (lim + 1));\n        }\n        return ret;\n    }\n\n} // namespace factorial\n  /* #endregion */\n  /* #endregion */\n  /*</body>*/\n#endif\n\nint N, M;\n\n/**\n * @brief 奇数レーンがk個のときの解\n */\nModInt solve1(int k) {\n    if ((M * 3 - k) % 2) return ModInt(0);\n    if (M < k) return ModInt(0);\n    // T = +2(+1*2も含む)が何回行われたか\n    int T = (M * 3 - k) / 2;\n    // M = 純粋な+2が何回行われたか\n\n    ModInt a = factorial::combination(N, k);\n    // M がいない場合のみカウント\n    ModInt b = factorial::multiChoose(N, T, M - 1);\n    if (N < 10) {\n        cerr << VAR_NAME(N) << \" \" << N << endl;\n        cerr << VAR_NAME(T) << \" \" << T << endl;\n        cerr << VAR_NAME(M) << \" \" << M << endl;\n\n        cerr << k << \" \" << *a << \" \" << *b << endl;\n    }\n    return a * b;\n}\n\nModInt solve2() { return N * factorial::multiChoose(N - 1, M); }\n\nint main() {\n    cin >> N >> M;\n    ModInt ret = 0;\n    for (int i : range(N + 1)) {\n        ret += solve1(i);\n    }\n    ret += solve2();\n    cout << *ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n\nconst ll mod = 998244353LL;\n\n// kの階乗を計算する.(sgnを0以外に設定すると逆元を返す)\nll fact(ll k, int sgn = 0) {\n\tstatic vector<ll> fac(2, 1LL);\n\tstatic vector<ll> inv(2, 1LL);\n\tstatic vector<ll> finv(2, 1LL);\n\tstatic ll nx = 2LL;\n\twhile (nx <= k) {\n\t\tfac.push_back(fac[nx - 1] * nx % mod);\n\t\tinv.push_back(mod - inv[mod % nx] * (mod / nx) % mod);\n\t\tfinv.push_back(finv[nx - 1] * inv[nx] % mod);\n\t\t++nx;\n\t}\n\tif (sgn == 0)\n\t\treturn fac[k];\n\treturn finv[k];\n}\n\n// aCbを計算する.\nll comb(ll a, ll b) {\n\tif (b < 0 || b > a) return 0;\n\treturn fact(a) * fact(b, 1) % mod * fact(a - b, 1) % mod;\n}\n\nint main() {\n\tll N, M;\n\tcin >> N >> M;\n\tll res = comb(3 * M + N - 1, N - 1);\n\tll tmp = 0;\n\tfor (ll i = 2 * M + 1; i <= 3 * M; ++i)\n\t\ttmp = (tmp + comb(3 * M - i + N - 2, N - 2)) % mod;\n\ttmp *= N;\n\ttmp %= mod;\n\tres = (res - tmp + mod) % mod;\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#include<cassert>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\nconst long long mod = 998244353;\nconst long long inf = 1ll << 61;\ntypedef pair<int, int> P;\n\nint kj[3300005], kji[3300005];\n\nint modpow(int x, int n, int md) {\n\tif (!n)return 1;\n\tint res = modpow(x*x%md, n / 2, md);\n\tif (n & 1)res = res*x%md;\n\treturn res;\n}\nint comb(int n, int r) {\n\tif (n < 0 || r<0 || n < r)return 0;\n\tint ans = kj[n];\n\tans = ans*kji[r] % mod;\n\tans = ans*kji[n - r] % mod;\n\treturn ans%mod;\n}\n\n\nvoid kjinit(int n) {\n\tkj[0] = 1;\n\trep(i, n) {\n\t\tkj[i + 1] = kj[i] * (i + 1);\n\t\tkj[i + 1] %= mod;\n\t}\n\trep(i, n)kji[i] = modpow(kj[i], mod - 2, mod);\n\n}\nsigned main() {\n\tint n, m; cin >> n >> m;\n\tkjinit(2000000);\n\tint ans = comb(3 * m + n - 1, n - 1);\n\tint t = n*comb(m + n - 2, n - 1);\n\tt %= mod;\n\tans = ans + mod - t;\n\tcout << ans%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll mod = 998244353;\n#define SIZE 4000000\nll inv[SIZE + 1];\nll kai[SIZE + 1];\nll invkai[SIZE + 1];\nvoid invinit()\n{\n\tinv[1] = 1;\n\tfor (int i = 2; i <= SIZE; i++)\n\t{\n\t\tinv[i] = mod - (mod / i)*inv[mod%i] % mod;\n\t}\n\tkai[0] = invkai[0] = 1;\n\tfor (int i = 1; i <= SIZE; i++)\n\t{\n\t\tkai[i] = kai[i - 1] * i%mod;\n\t\tinvkai[i] = invkai[i - 1] * inv[i] % mod;\n\t}\n}\nll com(ll a, ll b)\n{\n\tif (b < 0 || a < b)return 0;\n\treturn (invkai[b] * invkai[a - b]) % mod*kai[a] % mod;\n}\nint main()\n{\n\tinvinit();\n\tint num, kai;\n\tscanf(\"%d%d\", &num, &kai);\n\tll r = 0;\n\tfor (int i = 0; i <= min(num, kai); i++)\n\t{\n\t\tif (kai % 2 != i % 2)continue;\n\t\tll a = com(num, i);\n\t\tll b = com((kai * 3 - i)/2 + num - 1, num - 1);\n\t\tll c = com((kai - i - 2) / 2 + num - 1, num - 1)*num;\n\t\tll d = com((kai - i) / 2 + (num - 1) - 1, (num - 1) - 1)*i;\n\t\t//printf(\"%lld %lld %lld %lld\\n\", a, b, c, d);\n\t\tr = (r + a*(b - c - d) % mod) % mod;\n\t}\n\tprintf(\"%lld\\n\", r);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=998244353;\n\ntemplate<uint_fast64_t Modulus> class modint{\n    using u64=uint_fast64_t;\n    public:\n    u64 a;\n    constexpr modint(const u64 x=0) noexcept:a(((x%Modulus)+Modulus)%Modulus){}\n    constexpr u64 &value() noexcept{return a;}\n    constexpr const u64 &value() const noexcept{return a;}\n    constexpr modint &operator+=(const modint &rhs) noexcept{\n        a+=rhs.a;\n        if (a>=Modulus) a-=Modulus;\n        return *this;\n    }\n    constexpr modint operator+(const modint &rhs) const noexcept{\n        return modint(*this)+=rhs;\n    }\n    constexpr modint &operator++() noexcept{\n        return ++a,*this;\n    }\n    constexpr modint operator++(int) noexcept{\n        modint t=*this; return ++a,t;\n    }\n    constexpr modint &operator-=(const modint &rhs) noexcept{\n        if (a<rhs.a) a+=Modulus;\n        a-=rhs.a;\n        return *this;\n    }\n    constexpr modint operator-(const modint &rhs) const noexcept{\n        return modint(*this)-=rhs;\n    }\n    constexpr modint &operator--() noexcept{\n        return --a,*this;\n    }\n    constexpr modint operator--(int) noexcept{\n        modint t=*this; return --a,t;\n    }\n    constexpr modint &operator*=(const modint &rhs) noexcept{\n        a=a*rhs.a%Modulus;\n        return *this;\n    }\n    constexpr modint operator*(const modint &rhs) const noexcept{\n        return modint(*this)*=rhs;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept{\n        u64 exp=Modulus-2;\n        while(exp){\n            if (exp&1) *this*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return *this;\n    }\n    constexpr modint operator/(const modint &rhs) const noexcept{\n        return modint(*this)/=rhs;\n    }\n    constexpr modint operator-() const noexcept{\n        return modint(Modulus-a);\n    }\n    constexpr bool operator==(const modint &rhs) const noexcept{\n        return a==rhs.a;\n    }\n    constexpr bool operator!=(const modint &rhs) const noexcept{\n        return a!=rhs.a;\n    }\n    constexpr bool operator!() const noexcept{return !a;}\n    friend constexpr modint pow(modint rhs,long long exp) noexcept{\n        modint res{1};\n        while(exp){\n            if (exp&1) res*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return res;\n    }\n    template<class T> friend constexpr modint operator+(T x,modint y) noexcept{\n        return modint(x)+y;\n    }\n    template<class T> friend constexpr modint operator-(T x,modint y) noexcept{\n        return modint(x)-y;\n    }\n    template<class T> friend constexpr modint operator*(T x,modint y) noexcept{\n        return modint(x)*y;\n    }\n    template<class T> friend constexpr modint operator/(T x,modint y) noexcept{\n        return modint(x)/y;\n    }\n    friend ostream &operator<<(ostream &s,const modint &rhs) noexcept {\n        return s << rhs.a;\n    }\n    friend istream &operator>>(istream &s,modint &rhs) noexcept {\n        u64 a; rhs=modint{(s >> a,a)}; return s;\n    }\n};\n\nusing mint=modint<MOD>;\n\nconst int MAX=3e6+10;\nvector<mint> fac(MAX),finv(MAX),inv(MAX);\nvoid COMinit(){\n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    for (int i=2;i<MAX;++i){\n        fac[i]=fac[i-1]*i;\n        inv[i]=-inv[MOD%i]*(MOD/i);\n        finv[i]=finv[i-1]*inv[i];\n    }\n}\nmint COM(int n,int k){\n    if (n<k||n<0||k<0) return 0;\n    return fac[n]*finv[k]*finv[n-k];\n}\n\n//Be careful with the value of MAX and conducting COMinit()\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\tCOMinit();\n\tint N,M; cin >> N >> M;\n\tmint ans=COM(N-1+3*M,3*M)-COM(N+M-2,M-1)*N;\n\tfor (int i=M+2;i<=min(N,3*M);i+=2){\n\t\tans-=COM(N,i)*COM(N-1+(3*M-i)/2,(3*M-i)/2);\n\t}\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n// #define double long double\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(int i = (a); i > (b); --i)\n#define REP(i, n) for(int i = 0; i < (n); ++i)\n#define REPR(i, n) for(int i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt(x) __builtin_popcount(x)\n#define lbit(x) __builtin_ffsll(x)\n#define rbit(x) (64 - __builtin_clzll(x))\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\n#define rAll(a) (a).rbegin(), (a).rend()\n#define cinfast() cin.tie(0), ios::sync_with_stdio(false)\n#define PERM(c)                                                                \\\n    sort(All(c));                                                              \\\n    for(bool cp = true; cp; cp = next_permutation(All(c)))\n#define COMB(n, k)                                                             \\\n    for(ll bit = (1LL << k) - 1; bit < (1LL << n); bit = next_combination(bit))\n#define PERM2(n, k)                                                            \\\n    COMB(n, k) {                                                               \\\n        vector<int> sel;                                                       \\\n        for(int bitindex = 0; bitindex < n; bitindex++)                        \\\n            if(bit >> bitindex & 1) sel.emplace_back(bitindex);                \\\n        PERM(sel) { Printv(sel); }                                             \\\n    }\n#define MKORDER(n)                                                             \\\n    vector<int> od(n);                                                         \\\n    iota(All(od), 0LL);\n\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\ntemplate <class Head> inline void COUT(Head &&head) { cout << (head) << \"\\n\"; }\ntemplate <class Head, class... Tail>\ninline void COUT(Head &&head, Tail &&... tail) {\n    cout << (head) << \" \";\n    COUT(forward<Tail>(tail)...);\n}\n\n#define CCIN(...)                                                              \\\n    char __VA_ARGS__;                                                          \\\n    CIN(__VA_ARGS__)\n#define DCIN(...)                                                              \\\n    double __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    long long __VA_ARGS__;                                                     \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        FOREACH(x, v) { cout << x << \" \"; }                                    \\\n        cout << \"\\n\";                                                          \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\n\nlong long next_combination(long long sub) {\n    long long x = sub & -sub, y = sub + x;\n    return (((sub & ~y) / x) >> 1) | y;\n}\n\n// generic lambdas\ntemplate <typename F>\n#if defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\n[[nodiscard]]\n#elif defined(__GNUC__) && (__GNUC__ > 3 || __GNUC__ == 3 && __GNUC_MINOR__ >= 4)\n__attribute__((warn_unused_result))\n#endif // defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\n    static inline constexpr decltype(auto)\n    fix(F &&f) noexcept {\n    return [f = std::forward<F>(f)](auto &&... args) {\n        return f(f, std::forward<decltype(args)>(args)...);\n    };\n}\n\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<ll, ll> PL;\ntypedef vector<PL> VPL;\ntypedef vector<bool> VB;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\n\nconst int INF = 1e9;\n// const int MOD = 1e9 + 7;\nconst int MOD = 998244353;\nconst ll LINF = 1e18;\nconst ll dw[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll dh[] = {0, 1, 1, 1, 0, -1, -1, -1};\n#define PI 3.141592653589793238\n#define EPS 1e-7\n\n// 1000000007 で割ったあまりを扱う構造体\ntemplate <int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if(val < 0) v += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator-() const noexcept { return val ? MOD - val : 0; }\n    constexpr Fp operator+(const Fp &r) const noexcept {\n        return Fp(*this) += r;\n    }\n    constexpr Fp operator-(const Fp &r) const noexcept {\n        return Fp(*this) -= r;\n    }\n    constexpr Fp operator*(const Fp &r) const noexcept {\n        return Fp(*this) *= r;\n    }\n    constexpr Fp operator/(const Fp &r) const noexcept {\n        return Fp(*this) /= r;\n    }\n    constexpr Fp &operator+=(const Fp &r) noexcept {\n        val += r.val;\n        if(val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp &operator-=(const Fp &r) noexcept {\n        val -= r.val;\n        if(val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp &operator*=(const Fp &r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp &operator/=(const Fp &r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while(b) {\n            long long t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        val = val * u % MOD;\n        if(val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator==(const Fp &r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator!=(const Fp &r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream &operator<<(ostream &os, const Fp<MOD> &x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream &operator>>(istream &is, Fp<MOD> &x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if(n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if(n & 1) t = t * a;\n        return t;\n    }\n};\n\nusing mint = Fp<MOD>;\n\nconst ll NMAX = 1e6;\nll fac[NMAX + 1], inv[NMAX + 1], finv[NMAX + 1];\n\nvoid cominit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    FOR(i, 2, NMAX + 1) {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\nll comb(ll n, ll k) {\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nll hcomb(ll n, ll k) { return comb(k + n - 1, k); }\n\nsigned main() {\n    LCIN(N, M);\n    cominit();\n    mint ans = hcomb(N, 3 * M);\n    ans -= (mint)N * hcomb(N, M - 1);\n    REP(i, M) { ans -= (mint)hcomb(N, i) * comb(N, 3 * M - 2 * i); }\n    cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\nll mod=998244353;\n\nll fac[3000010];\n \nll modinv(ll a){\n    ll b=mod,u=1,v=0;\n    while(b){\n        ll t=a/b;\n        a-=t*b; swap(a,b);\n        u-=t*v; swap(u,v);\n        }\n        u%=mod;\n        if(u<0) u+=mod;\n    return u;\n}\n \nvoid modfac(){\n    fac[0]=1;\n    for(ll i=1;i<3000010;i++){\n        fac[i]=(fac[i-1]*i)%mod;\n    }\n}\n \nll modperm(ll n,ll k){\n    if(n<0||k<0||n<k) return 0;\n    else return (fac[n]*modinv(fac[n-k]))%mod;\n}\n \nll modcomb(ll n,ll k){\n    if(n<0||k<0||n<k) return 0;\n    else return ((fac[n]*modinv(fac[k]))%mod*modinv(fac[n-k]))%mod;\n}\n\nll modhom(ll n,ll k){\n  if(n==0&&k==0) return 1;\n  else if(n<0||k<0) return 0;\n  else return modcomb(n+k-1,k);\n}\n \nll modpow(ll a,ll b){\n  ll ans=1;\n  a%=mod;\n  while(b){\n    if(b&1) ans=ans*a%mod;\n    a=a*a%mod;\n    b>>=1;\n  }\n  return ans;\n}\n\nint main(){\n  modfac();\n  ll n,m;\n  cin >> n >> m;\n  ll ans=modhom(n,3*m);\n  for(ll i=m+1;i<=n;i++){\n    if((3*m-i)%2==0){\n      ans=(ans-modcomb(n,i)*modhom(n,(3*m-i)/2)%mod+mod)%mod;\n      ans=(ans+modcomb(n,i)*modhom(n,(m-i)/2)%mod*n%mod)%mod;\n      ans=(ans-modcomb(n-1,i)*modhom(n-1,(m-i)/2)%mod*n%mod+mod)%mod;\n    }\n  }\n  ans=(ans-modhom(n,m)*n%mod)%mod;\n  ans=(ans+modhom(n-1,m)*n%mod)%mod;\n  cout << (ans+mod)%mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Fast {\n    Fast() {\n        std::cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.precision(20);\n    }\n} fast;\n\n/* define */\n#define FOR(I, X, Y) for (long long(I) = (X); (I) < (Y); (I)++)\n#define REP(I, X, Y) for (long long(I) = (Y)-1; (I) >= (X); (I)--)\n#define ALL(X) (X).begin(), (X).end()\n#define pb push_back\n#define COUNT(V, X)                           \\\n    (upper_bound((V).begin(), (V).end(), X) - \\\n     lower_bound((V).begin(), (V).end(), X))\n#define debug(x) cerr << #x << ':' << x << endl;\n#define DEBUG(v)                             \\\n    {                                        \\\n        cerr << #v << ':';                   \\\n        for (auto xv : v) cerr << xv << ' '; \\\n        cerr << endl;                        \\\n    }\n#define Yes(X) cout << (X ? \"Yes\" : \"No\") << endl;\n#define YES(X) cout << (X ? \"YES\" : \"NO\") << endl;\n#define ctoi(C) (C - '0')\n#define pow2(x) ((long long)((long long)1 << x))\n\n/* alias */\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vii = vector<vector<int>>;\nusing vl = vector<long long>;\nusing vll = vector<vector<long long>>;\nusing pi = pair<int, int>;\nusing pl = pair<long long, long long>;\ntemplate <typename T>\nusing PQ = priority_queue<T>;\ntemplate <typename T>\nusing minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst long long dx[] = {1, 0, -1, 0};\nconst long long dy[] = {0, 1, 0, -1};\nconst long long dx8[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst long long dy8[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst long long dx9[] = {1, 1, 0, -1, -1, -1, 0, 1, 0};\nconst long long dy9[] = {0, 1, 1, 1, 0, -1, -1, -1, 0};\nconst int INF = 998244353;\nconst long long LINF = 1000000000000000007;\n\n/* func */\ntemplate <typename T1, typename T2>\ninline bool chmin(T1 &a, const T2 &b) {\n    if (a > b) a = b;\n    return a > b;\n}\ntemplate <typename T1, typename T2>\ninline bool chmax(T1 &a, const T2 &b) {\n    if (a < b) a = b;\n    return a < b;\n}\nlong long max(long long x, int y) {\n    return max(x, (long long)y);\n}\nlong long max(int x, long long y) {\n    return max((long long)x, y);\n}\nlong long min(long long x, int y) {\n    return min(x, (long long)y);\n}\nlong long min(int x, long long y) {\n    return min((long long)x, y);\n}\n\n/* library */\n\nlong long POW(long long x, long long n, long long mod) {\n    long long ans = 1;\n    while (n) {\n        if (n % 2) ans *= x;\n        x *= x;\n        x %= mod;\n        ans %= mod;\n        n >>= 1;\n    }\n    return ans;\n}\nvector<long long> factorial(2, 1);\nlong long comb(long long n, long long k, long long p) {\n    if (n < k || n < 0 || k < 0) return 0;\n    while (factorial.size() <= n) {\n        long long i = factorial.size();\n        factorial.push_back(i * factorial[i - 1] % p);\n    }\n    return ((factorial[n] * POW(factorial[k], p - 2, p)) % p) *\n           POW(factorial[n - k], p - 2, p) % p;\n}\n\nlong long TwelvefoldWay4(long long n, long long k, long long MOD) {\n    return comb(n + k - 1, n, MOD);\n}\n\n/* main */\n\nsigned main() {\n    ll N, M;\n    cin >> N >> M;\n    ll ans = 0;\n    for (ll i = 0; i <= M; i += 2) {\n        ll tmp1 = TwelvefoldWay4((M + i / (ll)2), N, INF);\n        ll tmp2 = ((i != 0 ? TwelvefoldWay4(i / (ll)2 - (ll)1, N, INF) : (ll)0) * N) % INF;\n        ll tmp3 = comb(N, M - i, INF);\n        ll tmp4 = (TwelvefoldWay4(i / 2, N - 1, INF) * N) % INF;\n        ll tmp5 = comb(N - 1, M - i - 1, INF);\n        // cerr << i << tmp1 << ' ' << tmp2 << ' ' << tmp3 << ' ' << tmp4 << ' ' << tmp5 << endl;\n        ans += (((tmp1 - tmp2 + INF) % INF) * tmp3) % INF;\n        ans -= (tmp4 * tmp5) % INF;\n      \tans += INF;\n        ans %= INF;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=1500005,INF=1<<30;\n\nll inv[MAX],fac[MAX],finv[MAX];\n\nvoid make(){\n    \n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    \n    for(int i=2;i<MAX;i++){\n        inv[i]=mod-inv[mod%i]*(mod/i)%mod;\n        fac[i]=fac[i-1]*(ll)i%mod;\n        finv[i]=finv[i-1]*inv[i]%mod;\n    }\n    \n}\n\nll comb(ll a,ll b){\n    if(a<b) return 0;\n    return fac[a]*(finv[b]*finv[a-b]%mod)%mod;\n}\n\nint main(){\n    \n    make();\n    \n    int N,M;cin>>N>>M;\n    \n    ll sum=0;\n    \n    for(int i=M;i>=0;i-=2){\n        if(i>N) continue;\n        ll rem=(3*M-i)/2;\n        sum+=comb(rem+N-1,N-1)*comb(N,i);\n        sum%=mod;\n    }\n    \n    for(int i=M;i>=0;i-=2){\n        if(i>N) continue;\n        ll rem=(M-i)/2;\n        sum+=N*(mod-comb(rem+N-1,N-1))%mod*comb(N,i);\n        sum%=mod;\n    }\n    \n    for(int i=M;i>=0;i-=2){\n        if(i>N-1) continue;\n        ll rem=(M-i)/2;\n        sum+=N*(comb(rem+N-2,N-2))%mod*comb(N-1,i);\n        sum%=mod;\n    }\n    \n    cout<<sum<<endl;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\n\nconst int mod = 998244353;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 5340000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init(const int amax = MAX_MOD_N) {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < amax - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n// int solve(){\n// \tvector<int>v;\n// \tfor(int i=0;i<N;++i){\n// \t\tv.push_back(i);\n// \t}\n// }\nint main() {\n\tint N;cin>>N;\n\tint M;cin>>M;\n\tMod answer;\n\tinit();\n\tanswer=comb(N+3*M-1,N-1);\n\n\t{\n\t\tfor(int max_num=2*M+1;max_num<=3*M;++max_num){\n\t\t\tMod cnt=N;\n\t\t\tcnt*=comb(N-2+(3*M-max_num),N-2);\n\t\t\tanswer-=cnt;\n\t\t}\n\t\t//cout<<answer.num<<endl;\n\t\tfor(int odd_num=M+1;odd_num<=min(3*M,N);++odd_num){\n\t\t\tif(odd_num%2!=M%2)continue;\n\t\t\tMod place_cnt=comb(N,odd_num);\n\t\t\tint rest=3*M-odd_num;\n\t\t\tassert(rest%2==0);\n\t\t\tMod acnt=comb(N-1+rest/2,N-1);\n\t\t\tanswer-=place_cnt*acnt;\n\t\t}\n\t}\n\tcout<<answer.num<<endl;\n\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\nll mod=998244353;\n\nll fac[3000010];\n \nll modinv(ll a){\n    ll b=mod,u=1,v=0;\n    while(b){\n        ll t=a/b;\n        a-=t*b; swap(a,b);\n        u-=t*v; swap(u,v);\n        }\n        u%=mod;\n        if(u<0) u+=mod;\n    return u;\n}\n \nvoid modfac(){\n    fac[0]=1;\n    for(ll i=1;i<3000010;i++){\n        fac[i]=(fac[i-1]*i)%mod;\n    }\n}\n \nll modperm(ll n,ll k){\n    if(n<0||k<0||n<k) return 0;\n    else return (fac[n]*modinv(fac[n-k]))%mod;\n}\n \nll modcomb(ll n,ll k){\n    if(n<0||k<0||n<k) return 0;\n    else return ((fac[n]*modinv(fac[k]))%mod*modinv(fac[n-k]))%mod;\n}\n\nll modhom(ll n,ll k){\n  if(n==0&&k==0) return 1;\n  else return modcomb(n+k-1,k);\n}\n \nll modpow(ll a,ll b){\n  ll ans=1;\n  a%=mod;\n  while(b){\n    if(b&1) ans=ans*a%mod;\n    a=a*a%mod;\n    b>>=1;\n  }\n  return ans;\n}\n\n//ずっとこれだと思ってました　嘘解法です\n\nint main(){\n  modfac();\n  ll n,m;\n  cin >> n >> m;\n  ll ans=modcomb(n+3*m-1,3*m);\n  for(ll i=0;i<m;i++){\n    ans=(ans-n*modcomb(n+i-2,i)%mod+mod)%mod;\n  }\n  for(ll i=m+1;i<=n;i++){\n    ll x=i-m;\n    ll y=x*(x+1)/2;\n    if(x%2==1){\n      ans=(ans+mod-y*modcomb(n,i)%mod*modhom(n-i,n-i)%mod)%mod;\n    }\n    else{\n      ans=(ans+y*modcomb(n,i)%mod*modhom(n-i,n-i)%mod)%mod;\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(V) V.begin(),V.end()\n#define ll long long\n#define MOD 998244353\n\nll modpow(ll x, ll y) {\n\tx %= MOD;\n\tll ans = 1;\n\twhile (y) {\n\t\tif (y & 1)ans *= x;\n\t\ty >>= 1;\n\t\tx *= x;\n\t\tx %= MOD;\n\t\tans %= MOD;\n\t}\n\treturn ans;\n}\n\nll moddiv(ll y) {\n\treturn modpow(y, MOD - 2);\n}\n\nll NC[1000007], NC1[1000007], NC2[1000007], R[4000007];\n\nint main(){\n\tll N, M;\n\tcin >> N >> M;\n\t\n\tfor (int i = 4000006;i > 0;i--) {\n\t\tR[i] = moddiv(i);\n\t}\n\t\n\tNC[0] = 1;\n\tfor (int i = 1;i <= N;i++) {\n\t\tNC[i] = NC[i - 1];\n\t\tNC[i] *= N - i + 1;NC[i] %= MOD;\n\t\tNC[i] *= R[i];NC[i] %= MOD;\n\t\t//cout << i << \" \" << NC[i] << endl;\n\t\t//NC[i]=nCi\n\t}\n\n\tNC2[0] = 1;\n\tfor (int x = 1;x <= N - 2;x++) {\n\t\tNC2[0] *= 3 * M + x;\n\t\tNC2[0] %= MOD;\n\t\tNC2[0] *= R[x];\n\t\tNC2[0] %= MOD;\n\t}\n\n\tfor (int i = 1;i <= 3 * M;i++) {\n\t\tNC2[i] = NC2[i - 1];\n\t\tNC2[i] *= 3 * M - i + 1;\n\t\tNC2[i] %= MOD;\n\t\tNC2[i] *= R[3 * M - i + N - 1];\n\t\tNC2[i] %= MOD;\n\n\t\t//cout << 3 * M - i + N - 2 << \" \" << N - 2 << \" \" << NC2[i] << endl;\n\t\t//NC2[i]=(3*M-i+N-2)C(N-2)\n\t}\n\n\tNC1[0] = 1;\n\tfor (int i = 1;i <= 3 * M;i++) {\n\t\tNC1[i] = NC1[i - 1];\n\t\tNC1[i] *= N - 1 + i;\n\t\tNC1[i] %= MOD;\n\t\tNC1[i] *= R[i];\n\t\tNC1[i] %= MOD;\n\t\t//NC1[i]=(N-1+i)C(N-1)\n\t}\n\tll ans = NC1[3 * M];\n\n\t//奇数がM個を超える\n\tll hj = 0;\n\tfor (int i = M + 2;i <= 3 * M && i <= N;i += 2) {\n\t\t//cout << NC[i] << \" \" << NC1[(3 * M - i) / 2] << endl;\n\t\thj += NC[i] * NC1[(3 * M - i) / 2];\n\t\thj %= MOD;\n\t}\n\n\t//maxが2Mを超える\n\tll mo = 0;\n\tfor (int i = 2 * M + 1;i <= 3 * M;i++) {\n\t\tmo += N * NC2[i];\n\t\tmo %= MOD;\n\t}\n\t//cout << ans << \" \" << hj << \" \" << mo << endl;\n\tans -= hj + mo;\n\tans %= MOD;if (ans < 0)ans += MOD;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//start of jonathanirvings' template v3.0.3 (BETA)\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\ntypedef pair<string,string> pss;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vii;\ntypedef vector<LL> vl;\ntypedef vector<vl> vvl;\n\ndouble EPS = 1e-9;\nint INF = 1000000005;\nlong long INFF = 1000000000000000005LL;\ndouble PI = acos(-1);\nint dirx[8] = {-1,0,0,1,-1,-1,1,1};\nint diry[8] = {0,1,-1,0,-1,1,-1,1};\n\n#ifdef TESTING\n  #define DEBUG fprintf(stderr,\"====TESTING====\\n\")\n  #define VALUE(x) cerr << \"The value of \" << #x << \" is \" << x << endl\n  #define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n  #define DEBUG \n  #define VALUE(x)\n  #define debug(...)\n#endif\n\n#define FOR(a,b,c) for (int (a)=(b);(a)<(c);++(a))\n#define FORN(a,b,c) for (int (a)=(b);(a)<=(c);++(a))\n#define FORD(a,b,c) for (int (a)=(b);(a)>=(c);--(a))\n#define FORSQ(a,b,c) for (int (a)=(b);(a)*(a)<=(c);++(a))\n#define FORC(a,b,c) for (char (a)=(b);(a)<=(c);++(a))\n#define FOREACH(a,b) for (auto &(a) : (b))\n#define REP(i,n) FOR(i,0,n)\n#define REPN(i,n) FORN(i,1,n)\n#define MAX(a,b) a = max(a,b)\n#define MIN(a,b) a = min(a,b)\n#define SQR(x) ((LL)(x) * (x))\n#define RESET(a,b) memset(a,b,sizeof(a))\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define ALL(v) v.begin(),v.end()\n#define ALLA(arr,sz) arr,arr+sz\n#define SIZE(v) (int)v.size()\n#define SORT(v) sort(ALL(v))\n#define REVERSE(v) reverse(ALL(v))\n#define SORTA(arr,sz) sort(ALLA(arr,sz))\n#define REVERSEA(arr,sz) reverse(ALLA(arr,sz))\n#define PERMUTE next_permutation\n#define TC(t) while(t--)\n\ninline string IntToString(LL a){\n  char x[100];\n  sprintf(x,\"%lld\",a); string s = x;\n  return s;\n}\n\ninline LL StringToInt(string a){\n  char x[100]; LL res;\n  strcpy(x,a.c_str()); sscanf(x,\"%lld\",&res);\n  return res;\n}\n\ninline string GetString(void){\n  char x[1000005];\n  scanf(\"%s\",x); string s = x;\n  return s;\n}\n\ninline string uppercase(string s){\n  int n = SIZE(s); \n  REP(i,n) if (s[i] >= 'a' && s[i] <= 'z') s[i] = s[i] - 'a' + 'A';\n  return s;\n}\n\ninline string lowercase(string s){\n  int n = SIZE(s); \n  REP(i,n) if (s[i] >= 'A' && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a';\n  return s;\n}\n\ninline void OPEN (string s) {\n  #ifndef TESTING\n  freopen ((s + \".in\").c_str (), \"r\", stdin);\n  freopen ((s + \".out\").c_str (), \"w\", stdout);\n  #endif\n}\n\n//end of jonathanirvings' template v3.0.3 (BETA)\n\nnamespace bf {\n\nvi data;\nset<vi> s;\nset<vi> dah;\n\nvoid dfs(int now)\n{\n  if (dah.count(data)) return;\n  dah.insert(data);\n  if (now == 0)\n  {\n    s.insert(data);\n    return;\n  }\n  REP(i,SIZE(data)) REP(j,SIZE(data)) if (i != j)\n  {\n    data[i] += 2;\n    data[j] += 1;\n    dfs(now-1);\n    data[i] -= 2;\n    data[j] -= 1;\n  }\n}\n\nint solve(int n, int m)\n{\n  data.resize(n); REP(i,n) data[i] = 0; s.clear(); dah.clear();\n  dfs(m);\n  return SIZE(s);\n}\n\n}  // namespace bf\n\nconst LL MOD = 998244353;\nconst int N = 5000001;\nLL f[N + 5];\nLL invf[N + 5];\n\nLL bigpow(LL a,LL b)\n{\n  if (b == 0) return 1;\n  LL tmp = bigpow(a,b/2);\n  LL tmp2 = tmp * tmp % MOD;\n  if (b % 2 == 0) return tmp2;\n  return tmp2 * a % MOD;\n}\n\nLL C(LL n,LL k)\n{\n  if (n < k) return 0;\n  return f[n] * invf[k] % MOD * invf[n-k] % MOD;\n}\n\nLL starsbars(LL slots, LL sum)\n{\n  // debug(\"%d %d\\n\",slots,sum);\n  if (sum < 0) return 0;\n  return C(sum + slots - 1, slots - 1);\n}\n\nLL all(int n,int m)\n{\n  // debug(\"all\\n\");\n  return starsbars(n,3*m);\n}\n\nLL harus3(int n,int m)\n{\n  // debug(\"harus3\\n\");\n  LL res = 0;\n  FORN(i,1,n)\n  {\n    LL sum = 3 * m - (LL)(2 * m + 1) * i;\n    LL pilih = C(n,i);\n    LL now = pilih * starsbars(n,sum) % MOD;\n    if (i % 2 == 1) res += now;\n    else res -= now;\n  }\n  res %= MOD;\n  if (res < 0) res += MOD;\n  return res;\n}\n\nLL harus111(int n,int m)\n{\n  // debug(\"harus111\\n\");\n  LL res = 0;\n  FORN(i,m+1,n)\n  {\n    LL sum = 3 * m - i;\n    LL pilih = C(n,i);\n    if (sum % 2 != 0) continue;\n    LL now = pilih * starsbars(n,sum/2) % MOD;\n    if ((i - (m + 1)) % 2 == 1) res += now;\n    else res -= now;\n  }\n  res %= MOD;\n  if (res < 0) res += MOD;\n  return res;\n}\n\nLL ans(int n, int m)\n{\n  LL res = all(n,m) - harus3(n,m) - harus111(n,m);\n  res %= MOD;\n  if (res < 0) res += MOD;\n  return res;\n}\n\nint main()\n{\n  f[0] = 1;\n  FORN(i,1,N) f[i] = f[i-1] * i % MOD;\n  invf[N] = bigpow(f[N],MOD-2);\n  FORD(i,N-1,0) invf[i] = invf[i+1] * (i + 1) % MOD;\n  // VALUE(C(5,2));\n\n  // FORN(i,1,7)\n  // {\n  //   FORN(j,1,7) assert(ans(i,j) == bf::solve(i,j));\n  //   puts(\"\");\n  // }\n  int n, m;\n  scanf(\"%d %d\",&n,&m);\n  printf(\"%lld\\n\",ans(n,m));\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__0001__\n#define __INTMOD_H__0001__\n\n#include <vector>\n#include <iostream>\n#include <cassert>\n#include <iostream>\n\n/* Modulus must be less than 0x80000000, and must not be 0. */\ntemplate <uint32_t Modulus>\nclass IntMod {\n\ttypedef int Int;\n\ttypedef unsigned int UInt;\n\ttypedef long long Long;\n\ttypedef unsigned long long ULong;\n\npublic:\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator==(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator!=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator<(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator<=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator>(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\ttemplate <uint32_t Modulus_>\n\tfriend bool operator>=(const IntMod<Modulus_>& left, const IntMod<Modulus_>& right);\n\nprivate:\n\tUInt value_m;\n\npublic:\n\tIntMod() { value_m = 0; }\n\tIntMod(UInt value) { value_m = value % Modulus; }\n\tIntMod(ULong value) { value_m = value % Modulus; }\n\tIntMod(Int value) {\n\t\tInt tmp = value % (Int)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(Long value) {\n\t\tInt tmp = value % (Long)Modulus;\n\t\tvalue_m = tmp >= 0 ? tmp : Modulus - (unsigned int)(-tmp);\n\t}\n\tIntMod(const IntMod& other) : value_m(other.value_m) {}\n\tIntMod& operator=(const IntMod& other) { value_m = other.value_m; return *this; }\n\t\n\tconst IntMod& operator+() const { return *this; }\n\tIntMod operator-() const { return IntMod(Modulus - value_m); }\n\tIntMod& operator++() {\n\t\t++value_m;\n\t\tif (value_m == Modulus) value_m = 0;\n\t\treturn *this;\n\t}\n\tIntMod& operator--() {\n\t\tif (value_m == 0) value_m = Modulus;\n\t\t--value_m;\n\t\treturn *this;\n\t}\n\tIntMod operator++(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t++(*this);\n\t\treturn tmp;\n\t}\n\tIntMod operator--(int dummy) {\n\t\tIntMod tmp(*this);\n\t\t--(*this);\n\t\treturn tmp;\n\t}\n\tIntMod& operator+=(const IntMod& right) {\n\t\tvalue_m += right.value_m;\t\t// value_m < 0x80000000\n\t\tif (value_m >= Modulus) value_m -= Modulus;\n\t\treturn *this;\n\t}\n\tIntMod& operator-=(const IntMod& right) {\n\t\tif (value_m < right.value_m) value_m += Modulus;\n\t\tvalue_m -= right.value_m;\n\t\treturn *this;\n\t}\n\tIntMod& operator*=(const IntMod& right) {\n\t\tvalue_m = ((ULong)value_m * right.value_m) % Modulus;\n\t\treturn *this;\n\t}\t\n\tIntMod& operator/=(const IntMod& right) {\n\t\t(*this) *= (right.Inverse());\n\t\treturn *this;\n\t}\n\t// for power\n\tIntMod operator[](ULong exp) const {\n\t\treturn Pow(exp);\n\t}\n\n\t/* Modulus must be a prime. */\n\tIntMod Inverse() const { return (*this).Pow(Modulus - 2); }\n\tIntMod Pow(ULong exp) const {\n\t\tIntMod product = 1;\n\t\tIntMod factor(*this);\n\t\twhile (exp > 0) {\n\t\t\tif (exp & 1) product *= factor;\n\t\t\tfactor *= factor;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn product;\n\t}\n\tUInt Get_value() const {\n\t\treturn value_m;\n\t}\n\n\tstatic IntMod Fact(UInt num) {\n\t\tstatic std::vector<IntMod> table(1, 1);\n\t\tif (table.size() > num) return table[num];\n\n\t\tint old_size = table.size();\n\t\ttable.resize(num + 1);\n\t\tfor (int i = old_size; i <= num; i++) {\n\t\t\ttable[i] = table[i - 1] * i;\n\t\t}\n\t\treturn table[num];\n\t}\n\n\tstatic IntMod Combi(UInt n, UInt r) {\n\t\tif (n < r) throw \"okashii\";\n\t\treturn IntMod::Fact(n) / (IntMod::Fact(n - r) * IntMod::Fact(r));\n\t}\n\n\tstatic IntMod Permutation(UInt n, UInt r) {\n\t\tif (n < r) throw \"okashii\";\n\t\treturn IntMod::Fact(n) / IntMod::Fact(n - r);\n\t}\n\n\tstatic std::vector<IntMod> Inverse_list(int size) {\n\t\tassert(size < Modulus);\n\t\tstd::vector<IntMod> ret_arr(size + 1);\n\t\tret_arr[1] = 1;\n\t\tfor (int i = 2; i <= size; ++i) {\n\t\t\tret_arr[i] = ((ULong)(Modulus - Modulus / i) * ret_arr[Modulus % i].Get_value()) % Modulus;\n\t\t}\n\t\treturn ret_arr;\n\t}\n};\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret += right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret -= right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret *= right;\n\treturn ret;\n}\n\ntemplate <uint32_t Modulus>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, const IntMod<Modulus>& right) {\n\tIntMod<Modulus> ret(left);\n\tret /= right;\n\treturn ret;\n}\n\n\ntemplate <uint32_t Modulus>\nbool operator==(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m == right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator!=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m != right.value_m; }\n/* for set/map */\ntemplate <uint32_t Modulus>\nbool operator<(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m < right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator<=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m <= right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator>(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m > right.value_m; }\ntemplate <uint32_t Modulus>\nbool operator>=(const IntMod<Modulus>& left, const IntMod<Modulus>& right) { return left.value_m >= right.value_m; }\n\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator+(const IntMod<Modulus>& left, Integer right) { return left + IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator+(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) + right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator-(const IntMod<Modulus>& left, Integer right) { return left - IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator-(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) - right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator*(const IntMod<Modulus>& left, Integer right) { return left * IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator*(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) * right; }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator/(const IntMod<Modulus>& left, Integer right) { return left / IntMod<Modulus>(right); }\ntemplate <uint32_t Modulus, class Integer>\nIntMod<Modulus> operator/(Integer left, const IntMod<Modulus>& right) { return IntMod<Modulus>(left) / right; }\n\ntemplate <uint32_t Modulus>\nstd::istream& operator<<(std::istream& ist, const IntMod<Modulus>& val) {\n\tuint64_t tmp;\n\tist >> tmp;\n\tval = tmp;\n\treturn ist;\n}\n\ntemplate <uint32_t Modulus>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Modulus>& val) {\n\tost << val.Get_value();\n\treturn ost;\n}\n\ntypedef IntMod<1000000007> MInt;\n\n#if 1\nMInt operator\"\" _m(unsigned long long num) { return MInt(num); }\n#endif\n\n#endif\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"BinaryMatrix.h\"\n#include \"BIT.h\"\n#include \"Factorization.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"LazySegmentTree.h\"\n#include \"Math.h\"\n#include \"Matrix.h\"\n#include \"MinMax.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"SuffixArray.h\"\n#include \"Tree.h\"\n#include \"UnionFind.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nusing MP = IntMod<998244353>;\nint N, M;\n\nMP H(int n, int r) {\n\treturn MP::Combi(n + r - 1, r - 1);\n}\n\nint main() {\n\tcin >> N >> M;\n\tMP ans = H(3 * M, N) - N * MP::Combi(N + M - 2, N - 1);\n\n\tREP(i, 0, N + 1) {\n\t\tif ((3 * M + i) % 2 == 1) continue;\n\t\tint even = (3 * M - i) / 2;\n\t\tif (even >= i || even < 0) continue;\n\t\tans -= MP::Combi(N, i) * H(even, N);\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// C.cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 3e6 + 200, mod = 998244353;\n\nint fac[MAX_N], fac_inv[MAX_N], inv[MAX_N];\n\nvoid preprocess()\n{\n\tfor (int i = fac[0] = 1; i < MAX_N; i++)\n\t\tfac[i] = 1LL * fac[i - 1] * i % mod;\n\tinv[0] = inv[1] = fac_inv[0] = 1;\n\tfor (int i = 2; i < MAX_N; i++)\n\t\tinv[i] = 1LL * (mod - mod / i) * inv[mod % i] % mod;\n\tfor (int i = 1; i < MAX_N; i++)\n\t\tfac_inv[i] = 1LL * fac_inv[i - 1] * inv[i] % mod;\n}\n\nint binomial(int n_, int k_) { return (n_ < k_) ? 0 : 1LL * fac[n_] * fac_inv[k_] % mod * fac_inv[n_ - k_] % mod; }\n\nint calc(int n, int m, int o)\n{\n\tint ret = 0;\n\tfor (int i = 0; i <= o; i++)\n\t\tif (i % 2 == m % 2)\n\t\t\tret = (0LL + ret + 1LL * binomial((m - i) / 2 + n - 1, n - 1) * binomial(n, i) % mod) % mod;\n\treturn ret;\n}\n\nint main()\n{\n\tint n, m;\n\tpreprocess(), scanf(\"%d%d\", &n, &m);\n\tprintf(\"%lld\\n\", (0LL + calc(n, 3 * m, m) + mod - 1LL * n * calc(n, m - 1, m) % mod) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n#include<iostream>\n#define llong long long\nusing namespace std;\n\ninline int read()\n{\n\tint x=0; bool f=1; char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=0;\n\tfor(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(c^'0');\n\tif(f) return x;\n\treturn -x;\n}\n\nconst int N = 2e6;\nconst int P = 998244353;\nllong fact[N+3],finv[N+3];\n\nllong quickpow(llong x,llong y)\n{\n\tllong cur = x,ret = 1ll;\n\tfor(int i=0; y; i++)\n\t{\n\t\tif(y&(1ll<<i)) {y-=(1ll<<i); ret = ret*cur%P;}\n\t\tcur = cur*cur%P;\n\t}\n\treturn ret;\n}\nllong comb(llong x,llong y) {return x<0||y<0||x<y ? 0ll : fact[x]*finv[y]%P*finv[x-y]%P;}\n\nllong calc(llong n,llong m,llong k)\n{\n\tllong ret = 0ll;\n\tfor(int i=0; i<=k; i++)\n\t{\n\t\tif((m-i)&1) continue;\n\t\tllong tmp = comb(n,i)*comb(((m-i)>>1)+n-1,n-1)%P;\n\t\tret = (ret+tmp)%P;\n\t}\n//\tprintf(\"calc %lld %lld %lld=%lld\\n\",n,m,k,ret);\n\treturn ret;\n}\n\nint n,m;\n\nint main()\n{\n\tfact[0] = 1ll; for(int i=1; i<=N; i++) fact[i] = fact[i-1]*i%P;\n\tfinv[N] = quickpow(fact[N],P-2); for(int i=N-1; i>=0; i--) finv[i] = finv[i+1]*(i+1)%P;\n\tscanf(\"%d%d\",&n,&m);\n\tllong ans = calc(n,3*m,m);\n\tans -= n*(calc(n,m,m)-calc(n-1,m,m)+P)%P;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<tuple>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define Per(i,sta,n) for(int i=n-1;i>=sta;i--)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n\ntemplate<int mod>\nstruct ModInt {\n    long long x;\n \n    ModInt() : x(0) {}\n    ModInt(long long y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    explicit operator int() const {return x;}\n \n    ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &p) {\n        if((x += mod - p.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &p) {\n        x = (int)(1LL * x * p.x % mod);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n \n    ModInt operator-() const { return ModInt(-x); }\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n \n    bool operator==(const ModInt &p) const { return x == p.x; }\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n \n    ModInt inverse() const{\n        int a = x, b = mod, u = 1, v = 0, t;\n        while(b > 0) {\n            t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        return ModInt(u);\n    }\n\n    ModInt power(long long p) const{\n        int a = x;\n        if (p==0) return 1;\n        if (p==1) return ModInt(a);\n        if (p%2==1) return (ModInt(a)*ModInt(a)).power(p/2)*ModInt(a);\n        else return (ModInt(a)*ModInt(a)).power(p/2);\n    }\n\n    ModInt power(const ModInt p) const{\n        return ((ModInt)x).power(p.x);\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt<mod> &p) {\n        return os << p.x;\n    }\n    friend istream &operator>>(istream &is, ModInt<mod> &a) {\n        long long x;\n        is >> x;\n        a = ModInt<mod>(x);\n        return (is);\n    }\n};\n\nusing modint = ModInt<mod>;\n\nstruct ModFac{\n  public:\n    vector<modint> f,i_f;\n    int n;\n\n    ModFac(int n_){\n      n=n_;\n      f.resize(n+1,1);\n      i_f.resize(n+1,1);\n      for(int i=0;i<n;i++){\n        f[i+1]=f[i]*(modint)(i+1);\n      }\n      i_f[n]=f[n].power(mod-2);\n      for(int i=n-1;i>=0;i--){\n        i_f[i]=i_f[i+1]*(modint)(i+1);\n      }\n    }\n    ModFac(modint n_){\n      n=(int)n_;\n      f.resize(n+1,1);\n      i_f.resize(n+1,1);\n      for(int i=0;i<n;i++){\n        f[i+1]=f[i]*(modint)(i+1);\n      }\n      i_f[n]=f[n].power(mod-2);\n      for(int i=n-1;i>=0;i--){\n        i_f[i]=i_f[i+1]*(modint)(i+1);\n      }\n    }\n    \n    modint factorial(int x){\n      //cout << f.size() << endl;\n      return f[x];\n    }\n        \n    modint inv_factorial(int x){\n      return i_f[x];\n    }\n    \n    modint comb(int m,int k){\n      if (m<0 or k<0) return 0;\n      if (m<k) return 0;\n      return f[m]*i_f[k]*i_f[m-k];\n    }\n};\n\n\nint n,m;\nModFac F(4000010);\n\nvoid solve(){\n    cin >> n >> m;\n    modint A=0;\n    rep(i,m+1){\n        if(i%2!=m%2) continue;\n        A+=F.comb(n,i)*F.comb((3*m-i)/2+n-1,n-1);\n    }\n    //cout << A << endl;\n    modint B=0;\n    rep(i,m+1){\n       if(i+(m+i)%2>m) continue;\n       if((m+i)%2==1) B+=(modint)n*F.comb(n-1,i)*F.comb((m-i)/2+n-1,n-1);\n       else B+=(modint)n*F.comb(n-1,i)*F.comb((m-i)/2+n-2,n-1);\n    }\n    //cout << B << endl;\n    cout << A-B << endl;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(50);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\n#include <stdexcept>\n\nusing namespace std;\n\n// type alias\nusing ll = long long;\nusing ull = unsigned long long;\n\n//conversion\n//------------------------------------------\ninline int toint(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class t> inline string tostring(t x) { ostringstream sout; sout << x; return sout.str(); }\n\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl\n#define DEBUG(x) cerr << #x << \" = \" << (x) << \" (l\" << __line__ << \")\" << \" \" << __file__ << endl\n\ninline ll floor(ll a, ull b)\n{\n\tll llb = b;\n\tif (a >= 0)\n\t{\n\t\treturn a / llb;\n\t}\n\telse\n\t{\n\t\treturn - ( (-a + llb - 1) / llb);\n\t}\n}\n\ninline ll ceil(ll a, ull b)\n{\n\tll llb = b;\n\tif (a >= 0)\n\t{\n\t\treturn (a + llb - 1) / llb;\n\t}\n\telse\n\t{\n\t\treturn - (-a / llb);\n\t}\n}\n\ninline ll getLowestOneBit(ll a)\n{\n\treturn a & (-a);\n}\n\ninline ll getHighestOneBit(ll a)\n{\n\twhile ((a & (a - 1)) != 0)\n\t{\n\t\ta = a & (a - 1);\n\t}\n\treturn a;\n}\n\ninline bool isPower2(ull a)\n{\n\tif (a == 0)\n\t{\n\t\treturn false;\n\t}\n\treturn !(a & (a - 1));\n}\n\ninline ll getSpecifiedBit(ll a, unsigned bit)\n{\n\treturn (a & (1LL << bit)) >> bit;\n}\n\n// computational complexity: o(log(max(a, b))) \ninline ull getGcd(ull a, ull b)\n{\n\tif (b == 0)\n\t{\n\t\treturn a;\n\t}\n\treturn getGcd(b, a % b);\n}\n\ntemplate<class Integer>\ninline Integer getPower(Integer base, ull exponential)\n{\n\tInteger result = 1;\n\twhile (exponential >= 1)\n\t{\n\t\tif (exponential & 1)\n\t\t{\n\t\t\tresult = result * base;\n\t\t}\n\t\tbase = base * base;\n\t\texponential >>= 1;\n\t}\n\n\treturn result;\n}\n\ntemplate <class Integer>\nclass ResidueInteger\n{\nprivate:\n\tInteger mod_;\n\tInteger n_;\n\tstatic Integer global_mod_;\n\n\t// computational complexity: o(log(max(a, b))) \n\tstatic inline pair<Integer, Integer> getBezoutsIdentitySolution(Integer a, Integer b)\n\t{\n\t\tif (b == 0)\n\t\t{\n\t\t\treturn { 1, 0 };\n\t\t}\n\t\tauto sol = getBezoutsIdentitySolution(b, a % b);\n\t\treturn { sol.second, sol.first - (a / b) * sol.second };\n\t}\n\npublic:\n\tInteger getModValue(const Integer& n) const\n\t{\n\t\treturn (n % mod_ + mod_) % mod_;\n\t}\n\n\t// computational complexity: o(log(max(n, mod))) \n\tinline Integer getModInverse(const Integer& n) const\n\t{\n\t\tauto sol = getBezoutsIdentitySolution(n, mod_);\n\t\tif (n * sol.first + mod_ * sol.second != 1)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\treturn getModValue(sol.first);\n\t}\n\t\t\n\tResidueInteger() : mod_(global_mod_), n_(getModValue(0)) {}\n\tResidueInteger(Integer n) : mod_(global_mod_), n_(getModValue(n)) {}\n\tResidueInteger(Integer n, Integer mod) : mod_(mod), n_(getModValue(n)){}\n\n\tinline ResidueInteger operator+(const ResidueInteger& rhs) const\n\t{\n\t\tif (this->mod_ != rhs.mod_)\n\t\t{\n\t\t\tthrow invalid_argument(\"The mods of both operands should be equal.\");\n\t\t}\n\t\treturn {this->n_ + rhs.n_, this->mod_};\n\t}\n\tinline ResidueInteger operator+(const Integer& rhs) const\n\t{\n\t\treturn { this->n_ + getModValue(rhs), this->mod_ };\n\t}\n\tfriend inline ResidueInteger operator+(const Integer& lhs, const ResidueInteger& rhs)\n\t{\n\t\treturn { rhs.getModValue(lhs) + rhs.n_, rhs.mod_ };\n\t}\n\tinline ResidueInteger& operator+=(const ResidueInteger& rhs)\n\t{\n\t\tif (this->mod_ != rhs.mod_)\n\t\t{\n\t\t\tthrow invalid_argument(\"The mods of both operands should be equal.\");\n\t\t}\n\t\tthis->n_ = getModValue(this->n_ + rhs.n_);\n\t\treturn *this;\n\t}\n\tinline ResidueInteger& operator+=(const Integer& rhs)\n\t{\n\t\tthis->n_ = getModValue(this->n_ + getModValue(rhs));\n\t\treturn *this;\n\t}\n\n\tinline ResidueInteger operator-(const ResidueInteger& rhs) const\n\t{\n\t\tif (this->mod_ != rhs.mod_)\n\t\t{\n\t\t\tthrow invalid_argument(\"The mods of both operands should be equal.\");\n\t\t}\n\t\treturn { this->n_ - rhs.n_, this->mod_ };\n\t}\n\tinline ResidueInteger operator-(const Integer& rhs) const\n\t{\n\t\treturn { this->n_ - getModValue(rhs), this->mod_ };\n\t}\n\tfriend inline ResidueInteger operator-(const Integer& lhs, const ResidueInteger& rhs)\n\t{\n\t\treturn { rhs.getModValue(lhs) - rhs.n_, rhs.mod_ };\n\t}\n\tinline ResidueInteger& operator-=(const ResidueInteger& rhs)\n\t{\n\t\tif (this->mod_ != rhs.mod_)\n\t\t{\n\t\t\tthrow invalid_argument(\"The mods of both operands should be equal.\");\n\t\t}\n\t\tthis->n_ = getModValue(this->n_ - rhs.n_);\n\t\treturn *this;\n\t}\n\tinline ResidueInteger& operator-=(const Integer& rhs)\n\t{\n\t\tthis->n_ = getModValue(this->n_ - getModValue(rhs));\n\t\treturn *this;\n\t}\n\n\tinline ResidueInteger operator*(const ResidueInteger& rhs) const\n\t{\n\t\tif (this->mod_ != rhs.mod_)\n\t\t{\n\t\t\tthrow invalid_argument(\"The mods of both operands should be equal.\");\n\t\t}\n\t\treturn { this->n_ * rhs.n_, this->mod_ };\n\t}\n\tinline ResidueInteger operator*(const Integer& rhs) const\n\t{\n\t\treturn { this->n_ * getModValue(rhs), this->mod_ };\n\t}\n\tfriend inline ResidueInteger operator*(const Integer& lhs, const ResidueInteger& rhs)\n\t{\n\t\treturn { rhs.getModValue(lhs) * rhs.n_, rhs.mod_ };\n\t}\n\tinline ResidueInteger& operator*=(const ResidueInteger& rhs)\n\t{\n\t\tif (this->mod_ != rhs.mod_)\n\t\t{\n\t\t\tthrow invalid_argument(\"The mods of both operands should be equal.\");\n\t\t}\n\t\tthis->n_ = getModValue(this->n_ * rhs.n_);\n\t\treturn *this;\n\t}\n\tinline ResidueInteger& operator*=(const Integer& rhs)\n\t{\n\t\tthis->n_ = getModValue(this->n_ * getModValue(rhs));\n\t\treturn *this;\n\t}\n\n\tinline ResidueInteger operator/(const ResidueInteger& rhs) const\n\t{\n\t\tif (this->mod_ != rhs.mod_)\n\t\t{\n\t\t\tthrow invalid_argument(\"The mods of both operands should be equal.\");\n\t\t}\n\t\treturn { this->n_ * getModInverse(rhs.n_), this->mod_ };\n\t}\n\tinline ResidueInteger operator/(const Integer& rhs) const\n\t{\n\t\treturn { this->n_ * getModInverse(getModValue(rhs)), this->mod_ };\n\t}\n\tfriend inline ResidueInteger operator/(const Integer& lhs, const ResidueInteger& rhs)\n\t{\n\t\treturn { rhs.getModValue(lhs) * rhs.getModInverse(rhs.n_), rhs.mod_ };\n\t}\n\tinline ResidueInteger& operator/=(const ResidueInteger& rhs)\n\t{\n\t\tif (this->mod_ != rhs.mod_)\n\t\t{\n\t\t\tthrow invalid_argument(\"The mods of both operands should be equal.\");\n\t\t}\n\t\tthis->n_ = getModValue(this->n_ * getModInverse(rhs.n_));\n\t\treturn *this;\n\t}\n\tinline ResidueInteger& operator/=(const Integer& rhs)\n\t{\n\t\tthis->n_ = getModValue(this->n_ * getModInverse(getModValue(rhs)));\n\t\treturn *this;\n\t}\n\n\tinline bool operator==(const ResidueInteger& rhs) const\n\t{\n\t\treturn (this->n_ == rhs.n_) && (this->mod_ == rhs.mod_);\n\t}\n\tinline bool operator==(const Integer& rhs) const\n\t{\n\t\treturn this->n_ == getModValue(rhs);\n\t}\n\tfriend bool operator==(const Integer& lhs, const ResidueInteger& rhs)\n\t{\n\t\treturn rhs.getModValue(lhs) == rhs.n_;\n\t}\n\n\tInteger getN() const { return n_; }\n\n\tfriend std::ostream& operator<<(std::ostream& lhs, const ResidueInteger& rhs)\n\t{\n\t\treturn lhs << rhs.n_;\n\t}\n\n\tfriend std::istream& operator>>(std::istream& lhs, ResidueInteger& rhs)\n\t{\n\t\tlhs >> rhs.n_;\n\t\treturn lhs;\n\t}\n};\nusing rll = ResidueInteger<ll>;\nll mod = 998244353ll;\ntemplate<> ll rll::global_mod_ = mod;\n\ntemplate<class Integer>\nclass ResidueCombinatorialCalculator\n{\nprivate:\n\tInteger mod_;\n\tInteger n_;\n\tmap<Integer, ResidueInteger<Integer>> values_;\npublic:\n\tResidueCombinatorialCalculator(Integer n, Integer mod) : mod_(mod), n_(n)\n\t{\n\t\tvalues_[0] = ResidueInteger<Integer>(1, mod_);\n\t}\n\t\n\tResidueInteger<Integer> calculate(Integer r)\n\t{\n\t\tif (r < 0 || n_ < r)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (values_.count(r) >= 1)\n\t\t{\n\t\t\treturn values_[r];\n\t\t}\n\t\tif (values_.count(n_ - r) >= 1)\n\t\t{\n\t\t\tvalues_[r] = values_[n_ - r];\n\t\t\treturn values_[r];\n\t\t}\n\t\tif (n_ < r * 2)\n\t\t{\n\t\t\tvalues_[r] = calculate(n_ - r);\n\t\t\treturn values_[r];\n\t\t}\n\n\t\tvalues_[r] = calculate(r - 1) * (n_ - r + 1) / r;\n\n\t\treturn values_[r];\n\t}\n};\nusing rccll = ResidueCombinatorialCalculator<ll>;\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tll N, M;\n\tcin >> N >> M;\n\n\tvector<ll> excl(M * 3 / 2 + N);\n\trll val = 1;\n\texcl[0] = val.getN();\n\tfor (ll i = 1; i < M * 3 / 2 + N; ++i)\n\t{\n\t\tval *= i;\n\t\texcl[i] = val.getN();\n\t}\n\n\trll res = 0;\n\tfor (ll i = 0; i <= M; ++i)\n\t{\n\t\tauto n = M * 3 - i;\n\t\tauto r = N;\n\t\tif (i <= r && n % 2 == 0)\n\t\t{\n\t\t\tn /= 2;\n\t\t\tres += rll(excl[n + r - 1]) / excl[n] / excl[r - 1]\n\t\t\t\t* excl[r] / excl[i] / excl[r - i];\n\t\t}\n\t}\n\n\tfor (ll i = 0; i <= M; ++i)\n\t{\n\t\tauto n = M - i;\n\t\tauto r = N;\n\t\tif (i <= r && n % 2 == 0)\n\t\t{\n\t\t\tn /= 2;\n\t\t\tres -= rll(excl[n + r - 1]) / excl[n] / excl[r - 1]\n\t\t\t\t* excl[r] / excl[i] / excl[r - i]\n\t\t\t\t* N;\n\t\t}\n\t}\n\n\tfor (ll i = 0; i <= M; ++i)\n\t{\n\t\tauto n = M - i;\n\t\tauto r = N - 1;\n\t\tif (i <= r && n % 2 == 0)\n\t\t{\n\t\t\tn /= 2;\n\t\t\tres += rll(excl[n + r - 1]) / excl[n] / excl[r - 1]\n\t\t\t\t* excl[r] / excl[i] / excl[r - i]\n\t\t\t\t* N;\n\t\t}\n\t}\n\n\tcout << res << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint fac[2000005], ifac[2000005];\n\nvoid gen_fac()\n{\n\tfac[0] = 1;\n\trep1(i, 2000000) fac[i] = 1LL * fac[i - 1] * i % MOD;\n\tifac[1] = 1;\n\tfor(int i = 2; i <= 2000000; i ++) ifac[i] = MOD - 1LL * ifac[MOD % i] * (MOD / i) % MOD;\n\tifac[0] = 1;\n\trep1(i, 2000000) ifac[i] = 1LL * ifac[i - 1] * ifac[i] % MOD;\n}\n\nint comb(int n, int m)\n{\n\tif(n < m) return 0;\n\treturn 1LL * fac[n] * ifac[n - m] % MOD * ifac[m] % MOD;\n}\n\nint solve(int n, int m, int k)\n{\n\tint tot = comb((3 * m - k) / 2 + n - 1, n - 1);\n\ttot = (tot - 1LL * k * comb((m - k) / 2 + n - 1, n - 1) % MOD + MOD) % MOD;\n\ttot = (tot - 1LL * (n - k) * comb((m - k - 2) / 2 + n - 1, n - 1) % MOD + MOD) % MOD;\n\treturn tot;\n}\n\nint main()\n{\n\tgen_fac();\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tint ans = 0;\n\tfor(int i = 0; i <= m; i ++)\n\tif(!(m - i & 1)) ans = (ans + 1LL * comb(n, i) * solve(n, m, i)) % MOD;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n#define REP(i,n) for(int i = 0;i < n;i++)\n\n/*\n * Modint struct\n * library author : @snuke\n * */\nconst int mod = 998244353;\nstruct mint {\n\tlong long x; // typedef long long ll;\n\tmint(long long x = 0): x((x % mod + mod) % mod) {}\n\tmint& operator+=(const mint a) { if ((x += a.x) >= mod)x -= mod; return *this;}\n\tmint& operator-=(const mint a) { if ((x += mod - a.x) >= mod)x -= mod; return *this;}\n\tmint& operator*=(const mint a) { (x *= a.x) %= mod; return *this;}\n\tmint operator+(const mint a) const { mint res(*this); return res += a;}\n\tmint operator-(const mint a) const { mint res(*this); return res -= a;}\n\tmint operator*(const mint a) const { mint res(*this); return res *= a;}\n\tmint pow(ll t) const {\n\t\tif (!t) return 1; mint a = pow(t >> 1); a *= a;\n\t\tif (t & 1) a *= *this; return a;\n\t}\n\t// for prime mod\n\tmint inv() const { return pow(mod - 2);}\n\tmint& operator/=(const mint a) { return (*this) *= a.inv();}\n};\nistream& operator>>(istream& is, const mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\nstruct Combination {\n\tconst int MAX = 500050;\n\tvector<mint> fact;\n\tvector<mint> finv;\n\tCombination(): fact(MAX), finv(MAX) {\n\t\tfor (int i = 0; i < MAX; i++) {\n\t\t\tif (i == 0)fact[i] = (mint)1;\n\t\t\telse fact[i] = fact[i - 1] * (mint)i;\n\t\t}\n\t\tfinv[MAX - 1] = fact[MAX - 1].inv();\n\t\tfor (int i = MAX - 2; i >= 0; i--) {\n\t\t\tfinv[i] = finv[i + 1] * (mint)(i + 1);\n\t\t}\n\t}\n\tmint comb(int n, int r) {\n\t\tif (n < 0 || r < 0 || n < r)return 0;\n\t\telse return fact[n] * finv[r] * finv[n - r];\n\t}\n} C;\n\nll n, m;\n\nint main(void) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin >> n >> m;\n\tmint ans = 0;\n\n\tfor (int k = 0; k <= m; k++) {\n\t\tif ((3 * m - k) % 2 != 0)continue;\n\t\tans += C.comb(n, k) * (C.comb((3 * m - k) / 2 + n - 1, n - 1)\n\t\t       - (mint)k * C.comb((m - k) / 2 + n - 1, n - 1)\n\t\t       - (mint)(n - k) * C.comb((m - 2 - k) / 2 + n - 1, n - 1));\n\t}\n\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\nusing vll = std::vector<ll>;\nusing vvll = std::vector<vll>;\nusing vvvll = std::vector<vvll>;\nusing dd = double;\nusing vdd = std::vector<dd>;\nusing vvdd = std::vector<vdd>;\nusing vvvdd = std::vector<vvdd>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, N-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, N-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S, ll E){ T s=v[S]; REPS(i, S+1, E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = 998244353LL;// 998244353LL;//(ll)(1e9 + 7);\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\n\n\nvoid solve()\n{\n\tll N, M;\n\tcin >> N >> M;\n\n\t//予め階乗を計算\n\tvmll kj(3*M+N+10);\n\tkj[0] = 1;\n\tREPS(i, 1, 3*M+N+9){\n\t\tkj[i] = kj[i-1] * i;\n\t}\n\n\tauto C = [&](ll a, ll b){\n\t\treturn kj[a] / (kj[b] * kj[a-b]);\n\t};\n\n\t//全数\n\tmll ans = C(3*M+N-1, 3*M);\n\n\t//NG1パターン目\n\tans -= C(M-1+N-1, M-1) * N;\n\n\t//NG2パターン目\n\tfor (ll k=M+2; k<=N; k+=2){\n\t\tll r = (3*M-k)/2;\n\t\tif (r <= 0) break;\n\t\tans -= C(N, k) * C(r+N-1, r);\n\t}\n\tcout << ans << '\\n';\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nconst ll mo=998244353;\nconst int NUM_=4400001;\nstatic ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];\n\n\nll comb(ll N_, ll C_) {\n\tif (fact[0]==0) {\n\t\tinv[1]=fact[0]=factr[0]=1;\n\t\tfor (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\t\tfor (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;\n\t}\n\tif(C_<0 || C_>N_) return 0;\n\treturn factr[C_]*fact[N_]%mo*factr[N_-C_]%mo;\n}\nll hcomb(int P_,int Q_) { return (P_==0&&Q_==0)?1:comb(P_+Q_-1,Q_);}\n\n\nll dp[3030303];\nint num[11];\n\nvoid dfs(int lef,int cur,int n) {\n\tif(lef==1) {\n\t\tif(cur==1) n++;\n\t\tnum[n]++;\n\t\treturn;\n\t}\n\tint i;\n\tFOR(i,cur+1) {\n\t\tdfs(lef-1,cur-i,n+(i==1));\n\t}\n\t\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M;\n\t\n\t/*\n\tdfs(N,3*M,0);\n\t\n\tFOR(i,10) cout<<i<<\" \"<<num[i]<<endl;\n\t*/\n\t\n\tll ret=hcomb(N,3*M);\n\tfor(i=2*M+1;i<=3*M;i++) ret-=N*hcomb(N-1,3*M-i)%mo;\n\tfor(i=M+1;i<=N;i++) {\n\t\tdp[i]=comb(N,i)*hcomb(N-i,3*M-i)%mo;\n\t\t//cout<<i<<\" \"<<dp[i]<<endl;\n\t}\n\tfor(i=N;i>=M+1;i--) {\n\t\tfor(j=i+1;j<=N;j++) {\n\t\t\tdp[i]-=dp[j]*comb(j,i)%mo;\n\t\t}\n\t\tdp[i]%=mo;\n\t\tdp[i]=(dp[i]+mo)%mo;\n\t\t//cout<<i<<\" \"<<dp[i]<<endl;\n\t\tret-=dp[i];\n\t}\n\t\n\t\n\tcout<<(ret%mo+mo)%mo<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#define mkp make_pair\ntypedef long long ll;\nusing namespace std;\n\nconst ll MOD=998244353;\n\n#define MAX_N 1000010\nll inv[MAX_N+10],fac[MAX_N+10],ifac[MAX_N+10];\n\nvoid setComb(){\n  inv[0]=1;inv[1]=1;fac[1]=1;ifac[1]=1;fac[0]=1;ifac[0]=1;\n  for(int i=2;i<MAX_N;i++){\n    inv[i]=(-MOD/i)*inv[MOD%i]%MOD;\n    fac[i]=fac[i-1]*i%MOD;\n    ifac[i]=ifac[i-1]*inv[i]%MOD;\n\n    inv[i]=(inv[i]+MOD)%MOD;\n    fac[i]=(fac[i]+MOD)%MOD;\n    ifac[i]=(ifac[i]+MOD)%MOD;\n  }\n  return;\n}\n\nll comb(ll n,ll k){\n  if(n<k||n<0||k<0) return 0;\n  else return ((fac[n]*ifac[k]%MOD*ifac[n-k]%MOD+MOD)%MOD);\n}\n\nll hcomb(ll n,ll r){\n  if(n==0&&r==0) return 1;\n  else if(n<0||r<0) return 0;\n  else return comb(n+r-1,r);\n}\n\nll mod_pow(ll x,ll n){\n  x%=MOD;\n  ll res=1;\n  while(n>0){\n    if(n&1) res=res*x%MOD;\n    x=x*x%MOD;\n    n>>=1;\n  }\n  return res;\n}\n\nvoid add(ll &a,ll b){\n  a=(a+b)%MOD;\n}\n\nvoid mul(ll &a,ll b){\n  a%=MOD;b%=MOD;\n  a=a*b%MOD;\n}\n\nint main(){\n  ll N,M;\n  cin>>N>>M;\n\n  setComb();\n\n  ll nans=0;\n  for(ll k=0;k<M;k++){\n    ll res=hcomb(N-1,k);\n    mul(res,N);\n    add(nans,res);\n  }\n\n  ll ans=0;\n  for(ll k=0;k<=min(N,M);k++){\n    if(k%2!=M%2) continue;\n    ll res=hcomb(N,(3*M-k)/2);\n    mul(res,comb(N,k));\n    add(ans,res);\n  }\n\n  add(ans,-nans+MOD);\n  add(ans,MOD);\n  cout<<ans<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef _debug\n#define out(i) cout << #i << ' ' << i << ' '\n#else \n#define out(i) //\n#endif\nusing ll = long long;\nusing ull = unsigned long long;\nconst int maxn = 500001;\nconst int maxm = 1000001;\nconst int tomod = 998244353;\nll form(ll a){\n\tll v = a % tomod;\n\treturn v < 0 ? v + tomod : v;\n}\nll inv[maxm], fa[maxm];\nvoid init(){\n\tfa[0] = fa[1] = 1;\n\tinv[0] = inv[1] = 1;\n\tfor(int i = 2;i < maxm;++i){\n\t\tfa[i] = form(fa[i - 1] * (ll)i);\n\t\tinv[i] = form((tomod - tomod / i) * inv[tomod % i]);\n\t}\n\tfor(int i = 2;i < maxm;++i)inv[i] = form(inv[i] * inv[i - 1]);\n}\nll cof(int a, int b){\n\treturn form(fa[a] * form(inv[b] * inv[a - b]));\n\treturn 0;\n\ta = b;\n\treturn a * b;\n} \nll solve(int n, int k, const int max_odd){\n\tll res = 0;\n\tfor(int o = 0;o <= max_odd;++o){\n\t\tif(((k-o)^1)&1){\n\t\t\tres = form(res + form(\n\t\t\t\tcof(n, o) * \n\t\t\t\tcof((k-o)/2+n-1, n-1)\n\t\t\t));\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tinit();\n\tint k, n;\n\tcin >> n >> k;\n\t// cout << solve(n, k * 3, min(n, k)) << '\\n';\n\t// cout << solve(n, k, min(n, k)) << '\\n';\n\t// cout << solve(n - 1, k, min(n - 1, k)) << '\\n';\n\tcout << form(solve(n, k * 3, min(n, k)) - n * (solve(n, k, min(n, k)) - solve(n - 1, k, min(n - 1, k)))) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <type_traits>\nnamespace loquat {\ntemplate <typename T>\nstatic std::pair<T, T> extended_gcd(T a, T b){\n\tif(b == 0){ return std::pair<T, T>(1, 0); }\n\tconst auto p = extended_gcd(b, a % b);\n\treturn std::pair<T, T>(p.second, p.first - a / b * p.second);\n}\n}\nnamespace loquat {\ntemplate <int MOD>\nclass modulus_integer {\npublic:\n\ttypedef modulus_integer<MOD> self_type;\nprivate:\n\tint m_value;\n\tstatic self_type unsafe_construct(int x) noexcept {\n\t\tself_type y;\n\t\ty.m_value = x;\n\t\treturn y;\n\t}\npublic:\n\tmodulus_integer() noexcept\n\t\t: m_value(0)\n\t{ }\n\tmodulus_integer(int x) noexcept\n\t\t: m_value(x % MOD)\n\t{\n\t\tif(m_value < 0){ m_value += MOD; }\n\t}\n\tint operator*() const noexcept { return m_value; }\n\tself_type& operator=(const self_type& x) noexcept {\n\t\tm_value = x.m_value;\n\t\treturn *this;\n\t}\n\tself_type operator-(const self_type& x) const noexcept {\n\t\tconst int y = m_value - x.m_value;\n\t\treturn unsafe_construct(y < 0 ? y + MOD : y);\n\t}\n\tself_type operator*(const self_type& x) const noexcept {\n\t\treturn unsafe_construct(\n\t\t\tstatic_cast<long long>(m_value) * x.m_value % MOD);\n\t}\n\tself_type operator/(const self_type& x) const {\n\t\treturn (*this) * self_type(extended_gcd(x.m_value, MOD).first);\n\t}\n\tself_type& operator-=(const self_type &x) noexcept {\n\t\treturn (*this = *this - x);\n\t}\n};\ntemplate <int MOD>\ninline std::ostream& operator<<(\n\tstd::ostream& os, const modulus_integer<MOD>& x)\n{\n\tos << *x;\n\treturn os;\n}\n}\nnamespace loquat {\ntemplate <int MOD>\ninline modulus_integer<MOD> modulus_factorial(int x){\n\tusing mint = modulus_integer<MOD>;\n\tstatic std::vector<mint> table(1, mint(1));\n\tassert(x >= 0);\n\twhile(static_cast<int>(table.size()) <= x){\n\t\tconst int t = static_cast<int>(table.size());\n\t\ttable.push_back(table.back() * mint(t));\n\t}\n\treturn table[x];\n}\ntemplate <int MOD>\ninline modulus_integer<MOD> modulus_inv_factorial(int x){\n\tusing mint = modulus_integer<MOD>;\n\tstatic std::vector<mint> table(1, mint(1));\n\tassert(x >= 0);\n\twhile(static_cast<int>(table.size()) <= x){\n\t\tconst int t = static_cast<int>(table.size());\n\t\ttable.push_back(table.back() / mint(t));\n\t}\n\treturn table[x];\n}\ntemplate <int MOD>\ninline modulus_integer<MOD> modulus_combination(int n, int k){\n\tif(k < 0 || n < k){ return 0; }\n\tconst auto a = modulus_factorial<MOD>(n);\n\tconst auto b = modulus_inv_factorial<MOD>(n - k);\n\tconst auto c = modulus_inv_factorial<MOD>(k);\n\treturn a * b * c;\n}\ntemplate <int MOD>\ninline modulus_integer<MOD> modulus_multichoose(int n, int k){\n\treturn modulus_combination<MOD>(n + k - 1, k);\n}\n}\nusing namespace std;\nstatic const int MOD = 998244353;\nusing mint = loquat::modulus_integer<MOD>;\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, m;\n\tcin >> n >> m;\n\tmint answer = loquat::modulus_multichoose<MOD>(3 * m + 1, n - 1);\n\tfor(int i = 2 * m + 1; i <= 3 * m; ++i){\n\t\tanswer -= loquat::modulus_multichoose<MOD>(3 * m - i + 1, n - 2) * n;\n\t}\n\tfor(int i = m + 2; i <= 3 * m && i <= n; i += 2){\n\t\tanswer -=\n\t\t\t  loquat::modulus_combination<MOD>(n, i)\n\t\t\t* loquat::modulus_multichoose<MOD>((3 * m - i) / 2 + 1, n - 1);\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\n\nll inf = 998244353;\nll fact[3000010] = {0};\nll inv[3000010] = {0};\n\nll mult(ll n, ll m){\n\tif(m==1) return n%inf;\n\telse if(m%2==0){\n\t\tll t = mult(n,m/2);\n\t\treturn (t*t)%inf;\n\t}else{\n\t\tll t = mult(n,m-1);\n\t\treturn (t*n)%inf;\n\t}\n}\n\nvoid factorial(ll N){\n\tfor(ll i=0;i<=N;i++){\n\t\tif(i==0){\n\t\t\tfact[i] = 1;\n\t\t\tinv[i] = 1;\n\t\t}\n\t\telse{\n\t\t\tfact[i] = (i*fact[i-1])%inf;\n\t\t\tinv[i] = mult(fact[i],inf-2);\n\t\t}\n\t}\n}\n\nll comb(ll n,ll k){\n\tif(n<k) return 0;\n\tif(n<0 || k<0) return 0;\n\telse return (((fact[n]*inv[k])%inf)*inv[n-k])%inf;\n}\n\nll hcomb(ll n,ll k){\n\tif(n==0 && k==0) return 1;\n\treturn comb(n+k-1,k);\n}\n\nint main(){\n    ll N,M;\n    cin >> N >> M;\n    factorial(N+3*M);\n\tll ans = hcomb(N,3*M);\n\tfor(ll k=M+1;k<=min(N,3*M);k++){\n\t\tif((3*M-k)%2==1) continue;\n\t\t(ans += -comb(N,k)*hcomb(N,(3*M-k)/2)%inf+inf)%=inf;\n\t}\n\t(ans += -hcomb(N,M-1)*N%inf+inf)%=inf;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long ans,n,m,mod=998244353ll,fact[5000005],invfact[5000005],tmp;\n\nlong long fastp(long long base,long long exp){\n    if(exp==0)return 1ll;\n    long long tmp2=fastp(base,exp/2ll);\n    tmp2=(tmp2*tmp2)%mod;\n    if(exp%2==1)tmp2*=base;\n    return tmp2%mod;\n}\n\nlong long binom(long long a,long long b){\n    if(b>a)return 0ll;\n\n    return ((fact[a]*invfact[b])%mod*invfact[a-b])%mod;\n}\n\nint main(){\n\n\tcin>>n>>m;\n\t\n\tfact[0]=1;\n\tfor(long long i=1;i<5000005;i++)fact[i]=(fact[i-1]*i)%mod;\n\tinvfact[5000004]=fastp(fact[5000004],mod-2ll);\n    for(long long i=5000003;i>=0;i--)invfact[i]=(invfact[i+1]*(i+1ll))%mod;\n\n\n    \n    ans=binom(n+3ll*m-1ll,n-1ll);\n    \n \n    \n    for(int i=0;i<m;i++){\n        ans-=(binom(n,i)*binom(n,m*3-2*i))%mod;\n        ans=(ans%mod+mod)%mod;\n    }\n    \n\n    for(int i=2*m+1;i<=(3*m);i++){\n        tmp+=binom(n-2+3*m-i,n-2);\n        tmp%=mod;\n    }\n\n    \n    ans-=(n*tmp)%mod;\n    ans=(ans%mod+mod)%mod;\n    \n    cout<<ans<<endl;\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<map>\nusing namespace std;\nint p = 998244353;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\n#define rev(s) reverse(s.begin(),s.end())\n#define end_pr(s) cout << s <<endl;return 0\n#define itn int\n#define bs bitset<5001>\n\nint kai_size = 2600001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4);\n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size - 1) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, 1000001) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\n\nint per(int a, int b) {\n\tint ans = a % b;\n\tif (ans < 0) { ans += b; }\n\treturn ans;\n}\nV<pin> uni(V<pin> &v) {\n\tsor(v);\n\tV<pin> ans(1, v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tif (v[i] != v[i - 1]) { ans.push_back(v[i]); }\n\t}\n\tv = ans;\n\treturn v;\n}\nint s_gcd(int a, int b) {\n\tif (b == 0) { return a; }\n\treturn s_gcd(b, a%b);\n}\nint gcd(int a, int b) {\n\tif (a < b) { swap(a, b); }\n\treturn s_gcd(a, b);\n}\nsigned main() {\n\tint n, m; cin >> n >> m; int sum = 3 * m;\n\tmake_kai();\n\tint inv1 = inv(kai[sum]);\n\tint qans = kai[sum+n-1];\n\tqans *= ink[n - 1]; qans %= p;\n\tqans *= inv1; qans %= p;\n\tint mi1 = 0;\n\tfor (int b = 0; b < m; b++) {\n\t\tint plus = com(b + n - 2, n - 2);\n\t\tmi1 += plus;\n\t}\n\tmi1 %= p;\n\tmi1 *= n; mi1 %= p;\n\tint mi2 = 0;\n\tfor (int a = m + 2; a <= n; a+=2) {\n\t\tint maru = (3 * m) - a; maru /= 2;\n\t\tif (maru >= 0) {\n\t\t\tint plus = com(maru + n - 1, n - 1);\n\t\t\tint mul = com(n, a);\n\t\t\tplus *= mul; plus %= p;\n\t\t\tmi2 += plus;\n\t\t}\n\t}\n\tmi2 %= p;\n\tint ans = qans + 2 * p - mi1 - mi2;\n\tcout << ans % p << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG\n \n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds; \nusing namespace std;\n \n#define F first\n#define S second \n#define pb push_back\n \n#define endl \"\\n\"\n \n#define IOS { ios :: sync_with_stdio(false); cin.tie(0); cout.tie(0); }\n \n#ifdef DEBUG\n    #define dbg(s) {s;}\n#endif\n \n#ifndef DEBUG\n    #define dbg(s)\n#endif\n \nusing namespace std;\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint grand(int x) { // from [0, x-1]\n    return uniform_int_distribution<int>(0, x - 1)(rng);\n}\n \n#define i32 int32_t\n \n#define RBTTYPE int\n#define ordered_set tree<RBTTYPE, null_type, less<RBTTYPE>, rb_tree_tag,tree_order_statistics_node_update> \n \n#define all(v) (v).begin(),(v).end()\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair< int, int > pii;\ntypedef pair< ll, ll > pll;\n \nll gcd(ll x, ll y) {\n    if (x < y) return gcd(y, x);\n    if (y == 0) return x;\n    return gcd(y, x % y);\n} \n \nconst ll mod = 998244353;\n \nll modexp(ll x, ll ex) {\n    ll ans = 1ll;\n    while (ex > 0) {\n        if (ex & 1ll) ans = (ans * x) % mod;\n        ex >>= 1ll;\n        x = (x * x) % mod;\n    }\n    return ans;\n}\n \nconst int maxn = 1e6 + 7;\n \nconst ll inf = 1e9 + 7;\n\nll fact[maxn];\nll facti[maxn];\n\nvoid precalc()\n{\n    fact[1] = 1;\n    fact[0] = 1;\n    facti[1]=1;\n    facti[0] = 1;\n    for(ll i=2;i<maxn;i++)\n    {\n        fact[i] = (fact[i-1]*i)% mod;\n        facti[i] = modexp(fact[i],mod-2);\n    }\n}\n\nll C(ll n, ll k)\n{\n    if(k<0)\n        return 0;\n    if(n<k)\n        return 0;\n    ll ans = fact[n]*facti[n-k]%mod *facti[k]%mod;\n    return ans;\n}\n\ni32 main() {\n    //freopen(\"<file>.in\", \"r\", stdin);\n    //freopen(\"<file>.out\", \"w\", stdout);\n \n    IOS; \n    precalc();\n    \n    ll n,m;\n    cin>>n>>m;\n    \n    ll total = C(m+m+m+n-1,n-1);\n    \n    ll part1 = 0;\n    ll u,v,sum;\n    for(ll k=m+m+1;k<=m+m+m;k++)\n    {\n        u = m+m+m-k;\n        v = C(u+n-2,n-2)*n%mod;\n        part1+=v;\n        part1%=mod;\n    }\n    \n    ll part2 = 0;\n    for(ll k=m+1;k<=n;k++)\n    {\n        u = C(n,k);\n        sum= m+m+m-k;\n        if(sum%2==1)\n            continue;\n        sum/=2;\n        v = C(sum+n-1,n-1);\n        part2 += u*v%mod;\n        part2%=mod;\n    }\n    \n    ll ans = total + mod - part1 + mod - part2;\n    ans%=mod;\n    \n    cout<<ans<<endl;\n    \n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC push_options\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n#include<bits/stdc++.h>\n#include <xmmintrin.h>\n#include <immintrin.h>\nusing namespace::std;\n__attribute__((constructor))void init(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n#include<ext/pb_ds/tag_and_trait.hpp>\n// #include <boost/multiprecision/cpp_dec_float.hpp>\n// #include <boost/multiprecision/cpp_int.hpp>\n// namespace mp = boost::multiprecision;\n// typedef mp::number<mp::cpp_dec_float<0>> cdouble;\n// typedef mp::cpp_int cint;\ntemplate<typename T>using pbds=__gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\ntemplate<typename T>using pbds_map=__gnu_pbds::tree<T,T,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\ntemplate<typename T,typename E>using hash_map=__gnu_pbds::gp_hash_table<T,E>;\ntemplate<typename T>using pqueue =__gnu_pbds::priority_queue<T, greater<T>,__gnu_pbds::rc_binomial_heap_tag>;\ntypedef long long lint;\n#define INF (1LL<<60)\n#define IINF (1<<30)\n#define LINF (9223372036854775807LL)\n#define EPS (1e-10)\n#define endl ('\\n')\n//#define MOD 1000000007LL\n#define MOD 998244353LL\ntypedef vector<lint> vec;\ntypedef vector<vector<lint>> mat;\ntypedef vector<vector<vector<lint>>> mat3;\ntypedef vector<string> svec;\ntypedef vector<vector<string>> smat;\n//template<typename T>inline void numout(T t){bool f=0;for(auto i:t){cout<<(f?\" \":\"\")<<i<INF/2?i:\"INF\";f=1;}cout<<endl;}\n//template<typename T>inline void numout2(T t){for(auto i:t)numout(i);}\ntemplate<typename T>inline void output(T t){bool f=0;for(auto i:t){cout<<(f?\" \":\"\")<<i;f=1;}cout<<endl;}\ntemplate<typename T>inline void output2(T t){for(auto i:t)output(i);}\ntemplate<typename T>inline void _output(T t){bool f=0;for(lint i=0;i<t.size();i++){cout<<f?\"\":\" \"<<t[i];f=1;}cout<<endl;}\ntemplate<typename T>inline void _output2(T t){for(lint i=0;i<t.size();i++)output(t[i]);}\n#define rep(i,n) for(lint i=0;i<lint(n);++i)\n#define repi(i,a,b) for(lint i=lint(a);i<(lint)(b);++i)\n#define rrep(i,n) for(lint i=lint(n)-1;i>=0;--i)\n#define rrepi(i,a,b) for(lint i=lint(b)-1;i>=lint(a);--i)\n#define irep(i) for(lint i=0;;++i)\n#define all(n) begin(n),end(n)\n#define dist(a,b,c,d) sqrt(pow(a-c,2)+pow(b-d,2))\ninline lint gcd(lint A,lint B){return B?gcd(B,A%B):A;}\ninline lint lcm(lint A,lint B){return A/gcd(A,B)*B;}\n// inline cint cgcd(cint A,cint B){return B?cgcd(B,A%B):A;}\n// inline cint clcm(cint A,cint B){return A/cgcd(A,B)*B;}\nbool chmin(auto& s,const auto& t){bool res=s>t;s=min(s,t);return res;}\nbool chmax(auto& s,const auto& t){bool res=s<t;s=max(s,t);return res;}\n// const vector<lint> dx={-1,-1,0,1,0,1,1,-1};\n// const vector<lint> dy={-1,0,-1,0,1,1,-1,1};\nconst vector<lint> dx={1,0,-1,0,1,1,-1,-1};\nconst vector<lint> dy={0,1,0,-1,1,-1,1,-1};\n#define SUM(v) accumulate(all(v),0LL)\nauto call=[](auto f,auto... args){return f(f,args...);};\n\nclass mint {\n  using u64 = std::uint_fast64_t;\n    public:\n    u64 a;\n    constexpr mint(const long long x = 0)noexcept:a(x>=0?x%get_mod():get_mod()-(-x)%get_mod()){}\n    constexpr u64 &value()noexcept{return a;}\n    constexpr const u64 &value() const noexcept {return a;}\n    constexpr mint operator+(const mint rhs)const noexcept{return mint(*this) += rhs;}\n    constexpr mint operator-(const mint rhs)const noexcept{return mint(*this)-=rhs;}\n    constexpr mint operator*(const mint rhs) const noexcept {return mint(*this) *= rhs;}\n    constexpr mint operator/(const mint rhs) const noexcept {return mint(*this) /= rhs;}\n    constexpr mint &operator+=(const mint rhs) noexcept {\n        a += rhs.a;\n        if (a >= get_mod())a -= get_mod();\n        return *this;\n    }\n    constexpr mint &operator-=(const mint rhs) noexcept {\n        if (a<rhs.a)a += get_mod();\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr mint &operator*=(const mint rhs) noexcept {\n        a = a * rhs.a % get_mod();\n        return *this;\n    }\n    constexpr mint operator++(int n) noexcept {\n        a += 1;\n        if (a >= get_mod())a -= get_mod();\n        return *this;\n    }\n    constexpr mint operator--(int n) noexcept {\n        if (a<1)a += get_mod();\n        a -= 1;\n        return *this;\n    }\n    constexpr mint &operator/=(mint rhs) noexcept {\n        u64 exp=get_mod()-2;\n        while (exp) {\n            if (exp % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            exp /= 2;\n        }\n        return *this;\n    }\n    constexpr bool operator==(mint x) noexcept {\n        return a==x.a;\n    }\n    constexpr bool operator!=(mint x) noexcept {\n        return a!=x.a;\n    }\n    constexpr static int root(){\n        mint root = 2;\n        while(root.pow((get_mod()-1)>>1).a==1)root++;\n        return root.a;\n    }\n    constexpr mint pow(long long n){\n        long long x=a;\n        mint ret = 1;\n        while(n>0) {\n            if(n&1)(ret*=x);\n            (x*=x)%=get_mod();\n            n>>=1;\n        }\n        return ret;\n    }\n    constexpr mint inv(){\n        return pow(get_mod()-2);\n    }\n    static vector<mint> fac,ifac;\n    static bool init;\n    constexpr static int mx=10000001;\n    void build(){\n        init=0;\n        fac.resize(mx);\n        ifac.resize(mx);\n        fac[0]=1,ifac[0]=1;\n        for(int i=1;i<mx;i++)fac[i]=fac[i-1]*i;\n        ifac[mx-1]=fac[mx-1].inv();\n        for(int i=mx-2;i>=0;i--)ifac[i]=ifac[i+1]*(i+1);\n    }\n    mint comb(lint b){\n        if(init)build();\n        if(a==0&&b==0)return 1;\n        if((lint)a<b||a<0)return 0;\n        return fac[a]*ifac[a-b]*ifac[b];\n    }\n    mint fact(){\n        if(init)build();\n        return fac[a];\n    }\n    mint fact_inv(){\n        if(init)build();\n        return ifac[a];\n    }\n    friend ostream& operator<<(ostream& lhs, const mint& rhs) noexcept {\n        lhs << rhs.a;\n        return lhs;\n    }\n    friend istream& operator>>(istream& lhs,mint& rhs) noexcept {\n        lhs >> rhs.a;\n        return lhs;\n    }\n    constexpr static u64 get_mod(){return MOD;}\n};\nvector<mint> mint::fac;\nvector<mint> mint::ifac;\nbool mint::init=1;\n\nint main(){\n    lint n,m;\n    cin>>n>>m;\n    mint ans=0;\n    rep(i,min(m,n)+1){\n        if((3*m-i)%2)continue;\n        lint t=(3*m-i)/2;\n        mint tmp=mint(t+n-1).comb(n-1);\n        if(t>=m+1)tmp-=mint(t-(m+1)+n-1).comb(n-1)*(n-i);\n        if(t>=m)tmp-=mint(t-(m+1)+n).comb(n-1)*i;\n        ans+=tmp*mint(n).comb(i);\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst double PI = 3.14159265358979323846;\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//typedef pair<ll, ll> P;\ntypedef pair<ll, ll> P;\nconst ll INF = 10e17;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n#define ret() return 0;\n\nstd::istream &operator>>(std::istream &in, set<int> &o) {\n    ll a;\n    in >> a;\n    o.insert(a);\n    return in;\n}\n\nstd::istream &operator>>(std::istream &in, queue<int> &o) {\n    ll a;\n    in >> a;\n    o.push(a);\n    return in;\n}\n\nbool contain(set<int> &s, int a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\n\n//const ll mod = 1e10;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ_ASK;\n\n\nstruct Edge {\n    int to, color;\n    ll cost;\n};\n\n\nll rec(vector<vector<Edge>> &g, int start, int now, int goal, int prev) {\n    if (goal == now) return 0;\n\n    for (Edge e : g[now]) {\n        if (e.to == prev) continue;\n        ll c = rec(g, start, e.to, goal, now);\n        if (c == -1) continue;\n        return c + e.cost;\n    }\n    return -1;\n}\n\nstruct Query {\n    int color;\n    ll cost;\n    int from, to;\n\n    // <edge, cost>\n    map<int, ll> costs;\n    map<int, ll> counts;\n};\n\nstd::istream &operator>>(std::istream &in, Query &o) {\n    cin >> o.color >> o.cost >> o.from >> o.to;\n    o.color--;\n    o.from--;\n    o.to--;\n    return in;\n}\n\nconst int mod = 1000000007;\n\nstruct mint {\n    ll x; // typedef long long ll;\n    mint(ll x = 0) : x((x % mod + mod) % mod) {}\n\n    mint &operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    mint &operator-=(const mint a) {\n        if ((x += mod - a.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    mint &operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res += a;\n    }\n\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res -= a;\n    }\n\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res *= a;\n    }\n\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t >> 1);\n        a *= a;\n        if (t & 1) a *= *this;\n        return a;\n    }\n\n    // for prime mod\n    mint inv() const {\n        return pow(mod - 2);\n    }\n\n    mint &operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res /= a;\n    }\n\n    friend std::istream &operator>>(std::istream &in, mint &o) {\n        ll a;\n        in >> a;\n        o = a;\n        return in;\n    }\n\n    friend std::ostream &operator<<(std::ostream &out, const mint &o) {\n        out << o.x;\n        return out;\n    }\n\n};\n\nconst int vcmax = (1 << 21) + 10;\n\nstruct combination {\n    vector<mint> fact, ifact;\n\n    combination(int n) : fact(n + 1), ifact(n + 1) {\n        assert(n < mod);\n        fact[0] = 1;\n        for (int i = 1; i <= n; ++i) fact[i] = fact[i - 1] * i;\n        ifact[n] = fact[n].inv();\n        for (int i = n; i >= 1; --i) ifact[i - 1] = ifact[i] * i;\n    }\n\n    mint operator()(int n, int k) {\n        if (k < 0 || k > n) return 0;\n        return fact[n] * ifact[k] * ifact[n - k];\n    }\n} combination(vcmax);\n\nmint sub(int n, int a, int b) {\n    cmin(b, n);\n    mint ans = 0;\n    for (int i = a % 2; i <= min({n, a, b,}); i += 2) {\n        ans += combination((a - i) / 2 + n - 1, n - 1) * combination(n, i);\n    }\n    return ans;\n}\n\nint main() {\n\n    int n, m;\n    cin >> n >> m;\n\n    mint ans = sub(n, 3 * m, m);\n    ans -= (sub(n, m, m) - sub(n - 1, m, m)) * n;\n    cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 3 * 1000 * 1000 + 17;\nconst int MOD = 1000 * 1000 * 1000 + 7;\nconst int M = 998244353;\n\nint n, m;\nlong long F[N];\n\nbool read() {\n    if (!(cin >> n >> m))\n        return false;\n\n    return true;\n}\n\nlong long naive() {\n    vector< vector< vector<long long> > >\n        dp(n + 1, vector< vector<long long> >(3 * m + 1, vector<long long>(n, 0ll)));\n\n    dp[0][0][0] = 1;\n\n    for (int i = 0; i < n; ++i)\n        for (int s = 0; s <= 3 * m; ++s)\n            for (int j = 0; j <= i; ++j)\n                for (int c = 0; c <= 2 * m && c + s <= 3 * m; ++c) {\n                    dp[i + 1][s + c][j + c % 2] += dp[i][s][j];\n                    dp[i + 1][s + c][j + c % 2] %= M;\n                }\n\n    auto res = 0ll;\n\n    for (int j = 0; j <= 2 * m; ++j)\n        res = (res + dp[n][3 * m][j]) % M;\n\n    return res;\n}\n\nlong long bpow(long long a, int n, long long M) {\n    auto res = 1ll;\n\n    for (; n > 0; n /= 2, a = a * a % M)\n        if (n & 1)\n            res = res * a % M;\n\n    return res;\n}\n\nlong long rev(long long x) { return bpow(x, M - 2, M); }\n\nlong long binomial(int n, int k) {\n    return n < 0 || k < 0 || k > n ? 0ll : F[n] * rev(F[k] * F[n - k] % M) % M;\n}\n\nlong long gay(int s, int n) {\n    return s == 0 ? 1ll : binomial(s + n - 1, n - 1);\n}\n\nvoid solve() {\n    /*F[0] = 1ll;\n\n    for (int i = 1; i < N; ++i)\n        F[i] = i * F[i - 1] % M;\n\n    auto res = gay(3 * m, n);\n\n    for (int mx = 2 * m + 1; mx <= 3 * m; ++mx) {\n        auto cur = gay(3 * m - mx, n - 1) * n % M;\n        res = (res + M - cur) % M;\n    }\n\n    for (int odd = 2 * m + 1; odd <= 3 * m; ++odd)\n        if ((3 * m - odd) % 2 == 0) {\n            auto cur = gay((3 * m - odd) / 2, n) * binomial(n, odd) % M;\n            res = (res + M - cur) % M;\n        }\n\n    cout << res << endl;*/\n    cout << naive() << endl;\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (read())\n        solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Inf 0x3f3f3f3f\n#define rg register\nusing std::cin;\nusing std::cout;\nconst int Maxn = 2e7 + 5, Mod = 998244353;\ntypedef long long ll;\ntypedef ll arr[Maxn];\nll Add(ll x, ll y) { return (x += y) >= Mod ? x - Mod : (x < 0 ? x + Mod : x); }\nll min(ll x, ll y) { return x < y ? x : y; }\nll max(ll x, ll y) { return x > y ? x : y; }\ninline ll read()\n{\n\trg ll res = 0, sign = 1;\n\trg char ch = getchar();\n\twhile (!isdigit(ch))\n\t{\n\t\tif (ch == '-')\n\t\t\tsign = -1;\n\t\tch = getchar();\n\t}\n\tdo\n\t{\n\t\tres = (res << 3) + (res << 1) + (ch ^ 48);\n\t\tch = getchar();\n\t} while (isdigit(ch));\n\treturn res * sign;\n}\nint n, m;\narr fac, inv, invfac;\nll ans;\nll qp(ll x, int y)\n{\n\tll res = 1;\n\twhile (y)\n\t{\n\t\tif (y & 1)\n\t\t\tres = res * x % Mod;\n\t\tx = x * x % Mod;\n\t\tres >>= 1;\n\t}\n\treturn res;\n}\nll C(int x, int y) { return fac[x] * invfac[y] % Mod * invfac[x - y] % Mod; }\nint main()\n{\n\tfac[0] = inv[1] = invfac[0] = 1;\n\tfor (rg int i = 1; i <= 20000000; i++)\n\t{\n\t\tfac[i] = fac[i - 1] * i % Mod;\n\t\tif (i > 1)\n\t\t\tinv[i] = (Mod - Mod / i) * inv[Mod % i] % Mod;\n\t\tinvfac[i] = invfac[i - 1] * inv[i] % Mod;\n\t}\n\trg int tmp;\n\tcin >> n >> m;\n\tans = 1;\n\tfor (rg int i = 1; i < n; i++)\n\t\tans = ans * (3 * m + i) % Mod;\n\tans = ans * invfac[n - 1] % Mod;\n\tans = Add(ans, -(n * C(m - 1 + n - 1, n - 1) % Mod));\n\tif (n > m)\n\t{\n\t\ttmp = min(3 * m, n);\n\t\tfor (rg int i = m + 2; i <= tmp; i += 2)\n\t\t\tans = Add(ans, -(C(n, i) * C((3 * m - i) / 2 + n - 1, n - 1) % Mod));\n\t}\n\tcout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e6 + 10;\nconst int mod = 998244353;\ntypedef long long ll;\n#define int long long\nint fac[maxn], inv[maxn];\nint n, m;\nint pw(int a, int n) {\n\tint res = 1;\n\twhile(n) {\n\t\tif(n & 1) res = (ll)res * a % mod;\n\t\ta = (ll)a * a % mod, n >>= 1;\n\t}\n\treturn res;\n}\nint INV(int a) {\n\treturn pw(a, mod - 2);\n}\nvoid pre() {\n\tfac[0] = 1;\n\tfor(int i = 1; i < maxn; i++) fac[i] = (ll)fac[i - 1] * i % mod;\n\tinv[maxn - 1] = INV(fac[maxn - 1]);\n\tfor(int i = maxn - 2; i >= 0; i--) inv[i] = (ll)inv[i + 1] * (i + 1) % mod;\n}\nint C(int n, int m) {\n\treturn (ll)fac[n] * inv[m] % mod * (ll)inv[n - m] % mod;\n}\nint H(int n, int m) {\n\treturn C(n + m - 1, m);\n}\nvoid add(int& a, int b) {\n\ta += b;\n\tif(a >= mod) a -= mod;\n}\nvoid sub(int& a, int b) {\n\ta -= b;\n\tif(a < 0) a += mod;\n}\nint32_t main() {\n\tpre();\n\tscanf(\"%lld%lld\", &n, &m);\n\tint ans = 0;\n\tfor(int i = 0; i <= min(n, m); i++) if((3 * m - i) % 2 == 0) {\n\t\tadd(ans, C(n, i) * H(n, (3 * m - i) / 2) % mod);\n\t}\n\tint tmp = 0;\n\tfor(int i = 0; i <= min(n, m); i++) if((m - i) % 2 == 0) {\n\t\tadd(tmp, C(n, i) * H(n, (m - i) / 2) % mod);\n\t}\n\tfor(int i = 0; i <= min(n - 1, m); i++) if((m - i) % 2 == 0) {\n\t\tsub(tmp, C(n - 1, i) * H(n - 1, (m - i) / 2) % mod);\n\t}\n\ttmp = (ll)tmp * n % mod;\n\tsub(ans, tmp);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <unordered_map>\n#include <numeric>\n#include <functional>\n#include <limits.h>\n#include <utility>\n#include <stack>\n\nusing namespace std;\n\n#define fs first\n#define sc second\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst ll mod = 998244353;\nll fact[5010200];\nll invfact[5010200];\n\ninline ll take_mod(ll a){\n    return (a % mod + mod) % mod;\n}\n\ninline ll add(ll a, ll b){\n    return take_mod(a+b);\n}\n\ninline ll sub(ll a, ll b){\n    return take_mod(a + mod -b);\n}\n\n\ninline ll mul(ll a, ll b){\n    return take_mod(a * b);\n}\n\ninline ll pow(ll x, ll n){\n    ll res = 1LL;\n    while(n > 0){\n        if(n & 1) res = mul(res, x);\n        x = mul(x, x);\n        n >>= 1;\n    }\n    return res;\n}\n\nll mod_inv(ll x){\n    return pow(x, mod-2);\n}\n\n// nは上限\nvoid make_fact(ll n){\n    fact[0] = 1;\n    ll res = 1;\n    for(int i = 1; i <= n; i++){\n        fact[i] = res;\n        res = mul(res, i+1);\n    }\n}\n\n// nは上限\nvoid make_invfact(ll n){\n    invfact[0] = 1;\n    invfact[n] = mod_inv(fact[n]);\n    for(int i = n-1; i >= 1; i--){\n        invfact[i] = mul(invfact[i + 1], i + 1);\n    }\n}\n\nll perm(ll n, ll k){\n    return mul(fact[n], invfact[n-k]);\n}\n\nll comb(ll n, ll k){\n    if(k == 0){\n        return 1;\n    }\n    return mul(mul(fact[n], invfact[n-k]), invfact[k]);\n}\n\n\nint main(){\n    ll N, M;\n    cin >> N >> M;\n    make_fact(5010000);\n    make_invfact(5010000);\n\n    ll res = 1;\n    res = mul(res, comb(3 * M + N - 1, N-1));\n\n    for(ll i = 2 * M + 1; i <= 3 * M; i++){\n        ll remain = 3 * M - i;\n        ll tmp = mul(N, comb(N + remain - 2, N-2));\n        res = sub(res, tmp);\n    }\n    for(ll x = M + 1; x <= N; x++){\n        if((3 * M - x) % 2 == 1){\n            continue;\n        }\n        if(x > N){\n            continue;\n        }\n        ll ball = (3 * M - x) / 2;\n        ll tmp = mul(comb(N, x), comb(ball + N - 1, N-1));\n        res = sub(res, tmp);\n    }\n\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD 998244353\nll N,M;\nll Fa[5050505];\nll i,j,k,ans;\nll moddiv(ll a,ll b){\n    a %= MOD;\n    b %= MOD;\n    for(ll m=MOD-2;m>0;m/=2){\n        if(m&1){\n            a=a*b%MOD;\n        }\n        b=b*b%MOD;\n    }\n    return a;\n}\nint main(){\n    scanf(\"%lld%lld\", &N,&M);\n    Fa[0] = 1;\n    fornum(i,0,N+M*3){\n        Fa[i + 1] = (Fa[i] * (i + 1)) % MOD;\n    }\n\n    for (i = M%2; i<=N&&i <= M;i+=2)\n    {\n        ll b = 3 * M - i;\n        ans = (ans + moddiv(Fa[N], Fa[i] * Fa[N - i]) * (moddiv(Fa[b / 2 + N - 1], Fa[N - 1] * Fa[b / 2]))) % MOD;\n        ll c = M - i;\n        if(i==N){\n\n            ans = (ans - moddiv(Fa[c / 2 + N - 1], Fa[N - 1] * Fa[c / 2]) * N % MOD+MOD) % MOD;\n        }else{\n            ans = (ans -\n                   (moddiv(Fa[N], Fa[N - i] * Fa[i]) * moddiv(Fa[c / 2 + N - 1], Fa[N - 1] * Fa[c / 2]) % MOD*N%MOD \n                   - moddiv(Fa[N - 1], Fa[N - 1 - i] * Fa[i]) * moddiv(Fa[c / 2 + N - 2], Fa[N - 2] * Fa[c / 2]) % MOD* N % MOD+MOD)+MOD) %\n                  MOD;\n                }\n        //printf(\"%lld\\n\", ans);\n    }\n    printf(\"%lld\",ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\ntypedef long double ld;\n#define pb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define ALL(x) x.begin(), x.end()\n#define SZ(x) (ll)x.size()\n#define f first\n#define s second\nconst ll MOD = 998244353;\nconst ll INF = 1e9;\nconst ll MAXN = 1500100;\n\nll N,M;\nll fact[MAXN];\nll inv[MAXN];\n\nll exp(ll a, ll b){\n  if (b==0)return 1;\n  ll h=exp(a,b/2);\n  h=h*h%MOD;\n  if (b%2==1)return h*a%MOD;\n  return h;\n}\n\nll qinv (ll x){\n  return exp(x, MOD - 2);\n}\n\nll choose(ll a, ll b){\n  return fact[a] * inv[b]%MOD * inv[a-b] %MOD;\n}\n\nint main(){\n  cin>>N>>M;\n  fact[0] = 1;\n  for (int i=1;i<=3*M+N;++i){\n    fact[i] = fact[i-1]*i%MOD;\n  }\n  for (int i=0;i<=3*M+N;++i)inv[i] = qinv(fact[i]);\n  ll T = choose(M*3+N-1, N-1);\n  for (int i=2*M+1;i<=3*M;++i){\n    ll X = N*choose(M*3 - i+N-2, N-2)%MOD;\n    T = (MOD+T-X)%MOD;\n  }\n  cout<<T;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mk(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\nusing namespace std;\nconst int mod=998244353;\nconst int N=2e6+10;\nint inv[N],fac[N];\nint n,m,Ans;\nint mul(int x,int y){return (ll)x*y%mod;}\nint add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\nint dec(int x,int y){return x-y<0?x-y+mod:x-y;}\nint ksm(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=mul(x,x)) if (y&1) ans=mul(ans,x);\n\treturn ans;\n}\nvoid init(){\n\tfac[0]=1;\n\tfor (int i=1;i<N;i++) fac[i]=mul(fac[i-1],i);\n\tinv[0]=inv[1]=1;\n\tfor (int i=2;i<N;i++) inv[i]=mul(mod-mod/i,inv[mod%i]);\n\tfor (int i=2;i<N;i++) inv[i]=mul(inv[i],inv[i-1]);\n}\nint C(int x,int y){\n\tif (x<y||x<0||y<0) return 0;\n\treturn mul(mul(fac[x],inv[y]),inv[x-y]);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tAns=0; init();\n\tfor (int i=0;i<=min(n,m);i++) \n\tif ((m*3-i)%2==0){\n\t\tint x=(m*3-i)/2;\n\t\tint s=C(n+x-1,n-1);\n\t\ts=dec(s,mul(n,C(n+x-m-1,n-1)));\n\t\ts=add(s,mul(n-i,C(n+x-m-2,n-2)));\n\t\ts=mul(s,C(n,i));\n\t\tAns=add(Ans,s);\n\t}\n\tprintf(\"%d\\n\",Ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 998244353LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nll fact[3000005];\n\nll extgcd(ll a,ll b,ll& x,ll& y){\n\tll d=a;\n\tif(b!=0LL){\n\t\td=extgcd(b,a%b,y,x);\n\t\ty-=(a/b)*x;\n\t}else{\n\t\tx=1;\n\t\ty=0;\n\t}\n\treturn d;\n}\n\nll mod_inverse(ll a,ll m){\n\tll x,y;\n\textgcd(a,m,x,y);\n\treturn (m+x%m)%m;\n}\n\nll mod_fact(ll n,ll p,ll& e){\n\te=0;\n\tif(n==0)return 1;\n\tll res=mod_fact(n/p,p,e);\n\te+=n/p;\n\tif(n/p%2!=0){\n\t\treturn res*(p-fact[n%p])%p;\n\t}\n\treturn res*fact[n%p]%p;\n}\n\nll mod_comb(ll n,ll k,ll p){\n\tif(n<0 || k<0 || n<k)return 0;\n\tll e1,e2,e3;\n\tll a1=mod_fact(n,p,e1),a2=mod_fact(k,p,e2),a3=mod_fact(n-k,p,e3);\n\tif(e1>e2+e3)return 0;\n\treturn a1*mod_inverse(a2*a3%p,p)%p;\n}\n\n\nint n,m;\n\nint main(void){\n\tfact[0]=1;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(ll i=1;i<3000000;i++){\n\t\tfact[i]=fact[i-1]*i%MOD;\n\t}\n\tll ans=0;\n\tfor(int i=0;i<=m;i++){\n\t\tll val=mod_comb(n,i,MOD);\n\t\tif((3*m-i)%2==1)continue;\n\t\tint cnt=(3*m-i)/2;\n\t\tll val2=mod_comb(cnt+n-1,cnt,MOD);\n\t\tans+=val*val2%MOD;\n\t\tans%=MOD;\n\t}\n\t//printf(\"%lld\\n\",ans);\n\n\tfor(int i=0;i<=m;i++){\n\t\tll val=mod_comb(n,i,MOD);\n\t\tif((m-i)%2==1)continue;\n\t\tint cnt=(m-i)/2;\n\t\tll val2=mod_comb(cnt+n-1,cnt,MOD);\n\t\tans+=(ll)MOD-(val*val2%MOD)*n%MOD;\n\t\tans%=MOD;\n\t}\n\t//printf(\"%lld\\n\",ans);\n\n\tfor(int i=0;i<=m;i++){\n\t\tll val=mod_comb(n-1,i,MOD);\n\t\tif((m-i)%2==1)continue;\n\t\tint cnt=(m-i)/2;\n\t\tll val2=mod_comb(cnt+n-2,cnt,MOD);\n\t\tans+=(ll)(val*val2%MOD)*n%MOD;\n\t\tans%=MOD;\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 998244353\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) {cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl;}\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}\nbool operator<(const TRI&_)const{return(fi==_.fi)?((se==_.se)?(th<_.th):(se<_.se)):(fi<_.fi);}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 3000005;\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n\tstatic ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n\texplicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\nusing mod = ModInt<MOD>;\n\nmod inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tinv[i] = MOD - inv[MOD % i] * (MOD / i);\n\t\tfac[i] = fac[i-1] * i;\n\t\tfinv[i] = finv[i-1] * inv[i];\n\t}\n}\n\nmod comb(int a, int b)\n{\n\tif(a<b) return 0;\n\treturn fac[a] * finv[b] * finv[a-b];\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m;\n    cin >> n >> m;\n    make();\n    mod res = 0;\n    rep(i,min(n,m)+1){\n        if((3*m-i) % 2 == 0){\n            res += comb(n, i) * comb((3*m-i)/2+n-1,n-1);\n        }\n    }\n    rep(i,m){\n        res -= n*comb(i+n-2,n-2);\n    }\n    cout << res << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 998244353;\nconst int N = 2500010;\nll fact[N], invf[N];\n\nll add(ll x, ll y){\n    return (x+y)%mod;\n}\n\nll mul(ll x, ll y){\n    return (x%mod)*(y%mod)%mod;\n}\n\nll powll(ll x, ll y){\n    x %= mod;\n    ll res = 1LL;\n    while(y){\n        if (y & 1LL)\n            res *= x;\n        res %= mod;\n        x = (x*x) % mod;\n        y >>= 1LL;\n    }\n    return res;\n}\n\nll divll(ll x, ll y){\n    return (x * powll(y,mod-2)) % mod;\n}\n\nll nPr(ll n, ll r){\n    if (n < r || r < 0) return 0;\n    return mul(fact[n], invf[n-r]);\n}\n\nll nCr(ll n, ll r){\n    if (n < r || r < 0) return 0;\n    return mul(mul(fact[n], invf[r]), invf[n-r]);\n}\n\nint main() {\n    ll n, m;\n    cin >> n >> m;\n    fact[0] = invf[0] = 1;\n    FOR(i,1,N-1){\n        fact[i] = (fact[i-1] * i) % mod;\n    }\n    invf[N - 1] = divll(1, fact[N - 1]);\n    FORR(i,N-1,1){\n        invf[i - 1] = (invf[i] * i) % mod;\n    }\n\n    ll ans = 0;\n    REP(x,m+1){\n        if ((3 * m - x) % 2) continue;\n        ll tmp = (nCr(n, x) * nCr(n + (3 * m - x) / 2 - 1, n - 1)) % mod;\n        ans = (ans + tmp) % mod;\n    }\n    REP(i,m){\n        ll tmp = (n * nCr(n + i - 2, n - 2)) % mod;\n        ans = (ans - tmp + mod) % mod;\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 4e6 + 5;\nconst int mod = 998244353;\nlong long fac[maxn];\nlong long inv[maxn];\n\nvoid pre()\n{\n    fac[0] = fac[1] = 1;\n    inv[0] = inv[1] = 1;\n    for(int i=2; i< maxn; i++)\n    {\n        fac[i] = fac[i-1] * i % mod;\n        inv[i] = mod - (mod / i) * inv[mod%i] % mod;\n    }\n    for(int i=2; i<maxn; i++)\n    {\n        inv[i] = inv[i] * inv[i-1] % mod;\n    }\n}\n\nlong long C(int a, int b)\n{\n    if(a<b || b < 0) return 0;\n    return fac[a] * inv[b] %mod * inv[a-b] % mod;\n}\n\n\nint main() {\n\n    int n, m;\n    pre();\n    scanf(\"%d%d\", &n, &m);\n    long long ans=C(n+3*m-1,3*m);\n    //printf(\"%lld\\n\", ans);\n    for(int i=1; i<=n; i++)\n    {\n        long long tans = C(n,i);\n        tans = tans * C(n+ 3*m-1-i*(2*m+1),3*m-i*(2*m+1)) % mod;\n        //printf(\"%lld\\n\", tans);\n        if(i&1) ans = ans - tans;\n        else ans = ans + tans;\n    }\n    ans = (ans % mod + mod) % mod;\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#define random_shuffle(...) shuffle(__VA_ARGS__, rng)\n#define rand() rng()\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nconst int N = 5111111;\nlong long fact[N], inv[N], invfact[N];\nconst int mod = 998244353;\n\nlong long C(int n, int k) {\n\treturn fact[n] * invfact[k] % mod * invfact[n - k] % mod;\n}\n\nint main() {\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n\tfact[0] = invfact[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tinv[i] = (i == 1) ? 1 : mod - inv[mod % i] * (mod / i) % mod;\n\t\tfact[i] = fact[i - 1] * i % mod;\n\t\tinvfact[i] = invfact[i - 1] * inv[i] % mod;\n\t}\n\n\tint n = nxt(), m = nxt();\n\tlong long ans = C(3 * m + n - 1, n - 1) - n * C(m + n - 2, n - 1);\n\n\tfor (int i = m + 1; i <= n; ++i) {\n\t\tif (i % 2 != m % 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tlong long tmp = C((3 * m - i) / 2 + n - 1, n - 1) * C(n, i) % mod;\n\t\tans -= tmp;\n\t}\n\n\tans %= mod;\n\tcout << (ans + mod) % mod << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;;\n#define ll long long\n#define rep(i, n) for(int i = 0;i < n;i++)\n#define repr(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(ll i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define INF 1<<30\n#define LINF 1LL<<62\n#define all(x) (x).begin(), (x).end()\n#define mp make_pair\n#define pb push_back\nconst ll MOD = 998244353;\n \ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\n\nconst int MAX = 3000000;\nlong long fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  COMinit();\n  ll n,m;cin >>n >> m;\n  ll ans = COM(3*m + n - 1 , n-1);\n  FOR(i,2*m+1, 3*m+1){\n      ll x = 3*m - i;\n      ll tmp = n * COM(x + n - 2 , n - 2) % MOD;\n      ans += MOD;\n      ans -= tmp ;\n      ans %= MOD;\n  }\n  FOR(i,m+1,n+1){\n      if(3*m<i)break;\n      if((3*m-i)%2==1)continue;\n      ll eve = (3*m-i)/2;\n      ll x = COM(n,i) * COM(eve + n - 1, n-1) % MOD;\n      ans += MOD;\n      ans -= x;\n      ans %=MOD;\n  }\n  cout << ans << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nlong long inv(int a, int p) { return a==1 ? 1 : (1-p*inv(p%a,a))/a+p; }\nstatic const int MODVAL = 998244353;\nstruct mint {\n  int val;\n  mint():val(0){}\n  mint(int x):val(x%MODVAL) {}\n  mint(size_t x):val(x%MODVAL) {}\n  mint(long long x):val(x%MODVAL) {}\n  mint& operator+=(mint y) { val+=y.val; if(val>=MODVAL) val-=MODVAL; return *this; }\n  mint& operator-=(mint y) { val-=y.val; if(val<0) val+= MODVAL; return *this; }\n  mint& operator*=(mint y) { val=(val*(long long)y.val)%MODVAL; return *this; }\n  mint& operator/=(mint y) { val=(val*inv(y.val,MODVAL))%MODVAL; return *this; }\n};\ninline mint operator+(mint x, mint y) { return x+=y; }\ninline mint operator-(mint x, mint y) { return x-=y; }\ninline mint operator*(mint x, mint y) { return x*=y; }\ninline mint operator/(mint x, mint y) { return x/=y; }\nmint POW(mint x, long long n) { mint r(1); for(;n;x*=x,n>>=1) if(n&1) r*=x; return r; }\nmint FAC(int n) { static vector<mint> FAC_(1,1);\n  while(int(FAC_.size())<=n) FAC_.push_back(FAC_.back()*FAC_.size()); return FAC_[n]; }\ninline mint CMB(int n, int k) { return k<0||n<k ? 0 : FAC(n) / (FAC(k) * FAC(n-k)); }\ninline ostream& operator<<(ostream& os, mint a) { return os << a.val; }\n\n// n箇所にm個を配るが、k個より大きいところを作ってはならない\nmint solve(int n, int m, int k) {\n  if(n == 0) {\n    return m == 0 ? 1 : 0;\n  }\n  mint res = CMB(m+n-1, n-1);\n  for(int x = k+1; x <= m; ++x) {\n    res -= CMB(m-x + n-2, n-2) * n;\n  }\n  return res;\n}\n\nint main(void) {\n  int n, m;\n  cin >> n >> m;\n  mint res = solve(n, 3*m, 2*m);\n  int last = min(n, 3*m);\n  for(int x = last; x > m; --x) { // 奇数の箇所が多すぎるパターン\n    if((3*m-x) % 2 == 1) {\n      continue;\n    }\n    // cerr << \">\" << res << endl;\n    mint cur = CMB(n, x) * CMB((3*m-x)/2 + n-1, n-1);\n    res -= cur;\n  }\n  cout << res << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx,avx2,fma\")\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ull unsigned long long\n#define db long double\n#define pb push_back\n#define ppb pop_back\n#define fi first\n#define se second\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define y2 azdfsdgwre\n\nvoid dout() { cerr << '\\n'; }\n\ntemplate <typename Head, typename... Tail>\nvoid dout(Head H, Tail... T) {\n    cerr << \" \" << H;\n    dout(T...);\n}\n\n#ifdef LOCAL\n    #define dbg(...) cerr << #__VA_ARGS__, dout(__VA_ARGS__)\n#else\n    #define dbg(...) ;\n#endif\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntypedef pair <int, int> pii;\n\nconst int N = 2e6 + 123, MOD = 998244353;\nint n, m, fact[N], rev[N];\n\nint binpow(int x, int y) {\n    int res = 1;\n    while (y > 0) {\n        if (y & 1) {\n            res = (ll)res * x % MOD;\n        }\n        x = (ll)x * x % MOD;\n        y /= 2;\n    }\n    return res;\n}\n\nint c(int x, int y) {\n    if (y > x) {\n        return 0;\n    }\n    return ((ll)fact[x] * rev[y] % MOD) * rev[x - y] % MOD;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false), cin.tie(NULL);\n    #ifdef LOCAL\n        freopen(\"input.txt\", \"r\", stdin);\n    #endif\n\n    fact[0] = rev[0] = 1;\n    for (int i = 1; i < N; i++) {\n        fact[i] = (ll)fact[i - 1] * i % MOD;\n        rev[i] = (ll)rev[i - 1] * binpow(i, MOD - 2) % MOD;\n    }\n    cin >> n >> m;\n    int res = 0;\n    for (int i = 0; i <= m; i++) {\n        if ((3 * m - i) & 1) {\n            continue;\n        }\n        res += (ll)c((3 * m - i) / 2 + n - 1, n - 1) * c(n, i) % MOD;\n        if (res >= MOD) {\n            res -= MOD;\n        }\n    }\n    int bad = 0;\n    for (int i = 0; i < m; i++) {\n        if ((m - 1 - i) & 1) {\n            continue;\n        }\n        bad += (ll)c((m - 1 - i) / 2 + n - 1, n - 1) * c(n, i) % MOD;\n        if (bad >= MOD) {\n            bad -= MOD;\n        }\n    }\n    bad = (ll)bad * n % MOD;\n    cout << (res - bad + MOD) % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#define ll long long\n#define mod 998244353\n#define Mod1(x) (x>=mod?x-mod:x)\n#define Mod2(x) (x<0?x+mod:x)\n#define maxn 3000010\ninline ll read()\n{\n    ll x=0; char c=getchar(),f=1;\n    for(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n    for(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n    return x*f;\n}\ninline void write(ll x)\n{\n    static int buf[20],len; len=0;\n    if(x<0)x=-x,putchar('-');\n    for(;x;x/=10)buf[len++]=x%10;\n    if(!len)putchar('0');\n    else while(len)putchar(buf[--len]+'0');\n}\ninline void writeln(ll x){write(x); putchar('\\n');}\ninline void writesp(ll x){write(x); putchar(' ');}\nll fac[maxn],inv[maxn];\nint n,m;\ninline ll power(ll a,ll b)\n{\n    ll ans=1;\n    for(;b;b>>=1,a=a*a%mod)\n        if(b&1)ans=ans*a%mod;\n    return ans;\n}\ninline ll C(int n,int m){return fac[n]*inv[m]%mod*inv[n-m]%mod;}\ninline ll calc(int n,int m,int k)\n{\n    ll sum=0;\n    for(int i=0;i<=n&&i<=k;i++)\n        if(!((m-i)&1)&&m>=i)sum=(sum+C(n,i)*C((m-i)/2+n-1,n-1))%mod;\n    // writeln(sum);\n    return sum;\n}\nint main()\n{\n    n=read(); m=read();\n    fac[0]=inv[0]=1;\n    for(int i=1;i<=n+3*m;i++){\n        fac[i]=fac[i-1]*i%mod;\n        inv[i]=power(fac[i],mod-2);\n    }\n    ll ans=(calc(n,3*m,m)-n*(calc(n,m,m)-calc(n-1,m,m)+mod))%mod;\n    writeln(Mod2(ans));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD 998244353\nll N,M;\nll Fa[5050505];\nll i,j,k,ans;\nll moddiv(ll a,ll b){\n    a %= MOD;\n    b %= MOD;\n    for(ll m=MOD-2;m>0;m/=2){\n        if(m&1){\n            a=a*b%MOD;\n        }\n        b=b*b%MOD;\n    }\n    return a;\n}\nint main(){\n    scanf(\"%lld%lld\", &N,&M);\n    Fa[0] = 1;\n    fornum(i,0,N+M*3){\n        Fa[i + 1] = (Fa[i] * (i + 1)) % MOD;\n    }\n\n    for (i = M%2; i<=N&&i <= M;i+=2)\n    {\n        ll b = 3 * M - i;\n        ans = (ans + moddiv(Fa[N], Fa[i] * Fa[N - i]) * (moddiv(Fa[b / 2 + N - 1], Fa[N - 1] * Fa[b / 2]))) % MOD;\n        ll c = M - i;\n        if(i==N){\n            ans = (ans - moddiv(Fa[c / 2 + N - 1], Fa[N - 1] * Fa[c / 2]) * N % MOD+MOD) % MOD;\n        }else{\n            ans = (ans \n                -(moddiv(Fa[N], Fa[N - i] * Fa[i]) * moddiv(Fa[c / 2 + N - 1], Fa[N - 1] * Fa[c / 2]) % MOD * N % MOD)\n                +(moddiv(Fa[N - 1], Fa[N - 1 - i] * Fa[i]) * moddiv(Fa[c / 2 + N - 2], Fa[N - 2] * Fa[c / 2]) % MOD* N % MOD)+MOD)%MOD;\n        }\n        //printf(\"%lld\\n\", ans);\n    }\n    printf(\"%lld\",ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define rrep(i,n) for(int i=((int)(n)-1);i>=0;(i)--)\n#define rrep1(i,n) for(int i=((int)(n));i>0;(i)--)\n#define sz(c) ((int)(c).size())\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> P;\ntypedef pair<int, pair<int, int> > PP;\n//const int MAX=;\nconst ll MOD=998244353;\n\nll factm[3000010];\nvoid fact_init(ll mod){\n  int k=3e6+10;\n  factm[0]=1;\n  rep1(i,k)factm[i]=(factm[i-1]*i)%mod;\n}\ntemplate<typename T>\nT extgcd(T a,T b,T& x, T& y){\n\tT d=a;\n\tif(b!=0){\n\t\td = extgcd(b, a%b, y, x);\n\t\ty -= (a/b) * x;\n\t}\n\telse{\n\t\tx = 1; y = 0;\n\t}\n\treturn d;\n}\ntemplate<typename T>\nT mod_inv(T a,T m){\n\tT x,y;\n\textgcd(a,m,x,y);\n\treturn (m+x%m)%m;\n}\nll comb(int n, int r, ll mod){\n  if(n<r)return 0;\n  ll tmp=(factm[n]*mod_inv(factm[r],mod))%mod;\n  tmp=(tmp*mod_inv(factm[n-r], mod))%mod;\n  return tmp;\n}\n\nll mim(ll a, ll b){\n  return (a-b+MOD)%MOD;\n}\n\nint N,M;\nvoid input(){\n  cin>>N>>M;\n  fact_init(MOD);\n}\n\nll ans;\n\nvoid solve(){\n  ans=comb(3*M+N-1, N-1, MOD);\n  rep(k,M){\n    ll tmp=(N*comb(k+N-2, N-2, MOD))%MOD;\n    ans=mim(ans, tmp);\n  }\n  for(int k=M+1; k<=3*M; k++){\n    if((3*M-k)%2)continue;\n    ll ev=(3*M-k)/2;\n    ll tmp=(comb(N, k, MOD)*comb(ev+N-1, ev, MOD))%MOD;\n    ans=mim(ans, tmp);\n  }\n}\n\nvoid output(){\n  cout<<ans;\n}\n\nint main(){\n  input();\n  solve();\n  output();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#define MOD 998244353\n#define mkp make_pair\ntypedef long long ll;\nusing namespace std;\n\n#define MAX_N 200020\nll inv[MAX_N+10],fac[MAX_N+10],ifac[MAX_N+10];\n\nvoid setComb(){\n  inv[0]=1;inv[1]=1;fac[1]=1;ifac[1]=1;fac[0]=1;ifac[0]=1;\n  for(int i=2;i<MAX_N;i++){\n    inv[i]=(-MOD/i)*inv[MOD%i]%MOD;\n    fac[i]=fac[i-1]*i%MOD;\n    ifac[i]=ifac[i-1]*inv[i]%MOD;\n\n    inv[i]=(inv[i]+MOD)%MOD;\n    fac[i]=(fac[i]+MOD)%MOD;\n    ifac[i]=(ifac[i]+MOD)%MOD;\n  }\n  return;\n}\n\nll comb(ll n,ll k){\n  if(n<k||n<0||k<0) return 0;\n  else return ((fac[n]*ifac[k]%MOD*ifac[n-k]%MOD+MOD)%MOD);\n}\n\nll hcomb(ll n,ll r){\n  if(n==0&&r==0) return 1;\n  else if(n<0||r<0) return 0;\n  else return comb(n+r-1,r);\n}\n\nll mod_pow(ll x,ll n){\n  x%=MOD;\n  ll res=1;\n  while(n>0){\n    if(n&1) res=res*x%MOD;\n    x=x*x%MOD;\n    n>>=1;\n  }\n  return res;\n}\n\nvoid add(ll &a,ll b){\n  a=(a+b)%MOD;\n}\n\nvoid mul(ll &a,ll b){\n  a%=MOD;b%=MOD;\n  a=a*b%MOD;\n}\n\nint main(){\n  ll N,M;\n  cin>>N>>M;\n\n  setComb();\n\n  ll nans=0;\n  for(ll k=0;k<M;k++){\n    ll res=hcomb(N-1,k);\n    mul(res,N);\n    add(nans,res);\n  }\n\n  ll ans=0;\n  for(ll k=0;k<=min(N,M);k++){\n    if(k%2!=M%2) continue;\n    ll res=hcomb(N,(3*M-k)/2);\n    mul(res,comb(N,k));\n    add(ans,res);\n  }\n\n  add(ans,-nans+MOD);\n  cout<<ans<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long P = 998244353, MX = 3000000;\nconst int f[] = {2, 1};\n\nint N, M;\nlong long fact[MX+10], invf[MX+10];\n\ninline long long MOD(long long x, long long M=P) { return (x%M+M)%M; }\ninline void SUB(long long &x, long long y) { x = MOD(x-y); }\n\nint qpow(long long a, int k) {\n//\tprintf(\"a=%lld; k=%d\\n\", a, k);\n\treturn (k?(qpow(a*a%P, k/2)*((k&1)?a:1)):1)%P;\n}\n\nvoid init() {\n\tfact[0] = 1;\n\tfor (int i = 1; i <= MX; ++i) fact[i] = fact[i-1]*i%P;\n\tinvf[MX] = qpow(fact[MX], P-2);\n\tassert(invf[MX]*fact[MX]%P == 1);\n\tfor (int i = MX; i; --i) invf[i-1] = invf[i]*i%P;\n}\n\nlong long C(int k, int n) {\n\tassert(0 <= k && k <= n);\n\treturn fact[n]*invf[k]%P*invf[n-k]%P;\n//\telse printf(\"%dC%d = %lld\\n\", k, n, fact[n]*invf[k]%P*invf[n-k]%P);\n}\n\nint main() {\n\tinit();\n\tscanf(\"%d%d\", &N, &M);\n\tlong long ans = C(N-1, 3*M + N-1);\n//\tprintf(\"%lld\\n\", ans);\n\tfor (int i = 2*M+1; i <= 3*M; ++i) {\n\t\tSUB(ans, N*C(N-2, (3*M-i)+(N-2)));\n\t}\n//\tprintf(\"%lld\\n\", ans);\n\tfor (int i = M+f[M%2]; i <= N && i <= 3*M; i+=2) {\n\t\tSUB(ans, C(i, N)*C(N-1, (3*M-i)/2+(N-1)));\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n\n\n\n\n#include <algorithm>\n\n#include <array>\n\n#include <bitset>\n\n#include <cassert>\n\n#include <complex>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <iostream>\n\n#include <map>\n\n#include <numeric>\n\n#include <queue>\n\n#include <set>\n\n#include <string>\n\n#include <unordered_map>\n\n#include <unordered_set>\n\n#include <vector>\n\nusing namespace std;\n\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\nstruct Scanner {\n    FILE* fp = nullptr;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += fread(line + ed, 1, (1 << 15) - ed, fp);\n        line[ed] = '\\0';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) reread();\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == '-') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] - '0');\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(V<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    Scanner(FILE* _fp) : fp(_fp) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(' ');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single('\\n');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val; // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char('0' + (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const V<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(' ');\n            write_single(val[i]);\n        }\n    }\n};\n\n\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    static constexpr uint get_mod() { return MD; }\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(uint(_v % MD + MD)); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(uint(ull(v) * r.v % MD)); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\n// using Mint = ModInt<998244353>;\n// template<> const Mint Mint::G = Mint(3);\nusing Mint = ModInt<998244353>;\n\n\n\n\ntemplate<class Mint>\nstruct Comb {\n    int max_n;\n    V<Mint> fact, ifact;\n    Comb() {}\n    Comb(int n) : max_n(n) {\n        fact = ifact = V<Mint>(n + 1);\n        fact[0] = Mint(1);\n        for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i;\n        ifact[n] = fact[n].inv();\n        for (int i = n; i >= 1; i--) ifact[i - 1] = ifact[i] * i;\n    }\n\n    Mint C(int n, int k) {\n        if (n < k || n < 0) return Mint(0);\n        assert(0 <= k && k <= n && n <= max_n);\n        return fact[n] * ifact[k] * ifact[n - k];\n    }\n};\nComb<Mint> C(TEN(7));\n\nScanner sc = Scanner(stdin);\nPrinter pr = Printer(stdout);\n\nint main() {\n    int n, m;\n    sc.read(n, m);\n\n    Mint ans = C.C(3 * m + n - 1, n - 1);\n\n    for (int i = 2 * m + 1; i <= 3 * m; i++) {\n        ans -= Mint(n) * C.C(3 * m - i + n - 2, n - 2);\n    }\n\n    pr.writeln(ans.v);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 2e6 + 10;\nconst int MOD = 998244353;\n\nint f[maxn], inv[maxn];\n\nint power(int n, int k) {\n    int e = 1;\n    while (k) {\n        if (k & 1) e = 1ll * e * n % MOD;\n        n = 1ll * n * n % MOD; k >>= 1;\n    }\n    return e;\n}\n\nint C(int n, int k) {\n    return 1ll * f[n] * inv[k] % MOD * inv[n - k] % MOD;\n}\n\nint calc(int n, int x, int y) {\n    y = min(n, y);\n    long long answer = 0;\n    for (int i = x % 2; i <= min({n, x, y}); i += 2) {\n        int a = (x - i) / 2 + n - 1;\n        //cerr << a << \" \" << x << \" \" << n - 1 << \"\\n\";\n        answer += 1ll * C((x - i) / 2 + n - 1, n - 1) * C(n, i) % MOD;\n        answer %= MOD;\n    }\n    return answer;\n}\n\nint main() {\n    // initialize factor\n    f[0] = 1;\n    for (int i = 1; i < maxn; ++i) f[i] = 1ll * f[i - 1] * i % MOD;\n    inv[maxn - 1] = power(f[maxn - 1], MOD - 2);\n    for (int i = maxn - 2; i >= 0; --i) inv[i] = 1ll * inv[i + 1] * (i + 1) % MOD;\n\n    // process\n    ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);\n    int n, m;   cin >> n >> m;\n    int x = calc(n, 3 * m, m);\n    int y = calc(n, m, m);\n    int z = calc(n - 1, m, m);\n    int answer = (x - 1ll * (y - z) * n % MOD + MOD) % MOD;\n    cout << answer << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int P=998244353;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint ksm(R int x,R int y){\n\tR int res=1;\n\tfor(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;\n\treturn res;\n}\nconst int N=3e6+5;\nint fac[N],ifac[N],n,m,res,lim;\ninline int C(R int n,R int m){return m>n?0:1ll*fac[n]*ifac[m]%P*ifac[n-m]%P;}\nint main(){\n\tscanf(\"%d%d\",&n,&m);lim=m*3+n-1;\n\tfac[0]=ifac[0]=1;fp(i,1,lim)fac[i]=mul(fac[i-1],i);\n\tifac[lim]=ksm(fac[lim],P-2);fd(i,lim-1,1)ifac[i]=mul(ifac[i+1],i+1);\n\tfp(i,0,m)if((3*m-i)&1^1)upd(res,mul(C(n,i),C(((3*m-i)>>1)+n-1,n-1)));\n\tres=dec(res,mul(n,C(m-1+n-1,n-1)));\t\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class t> inline t read(t &x){\n\tchar c=getchar();bool f=0;x=0;\n\twhile(!isdigit(c)) f|=c=='-',c=getchar();\n\twhile(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\tif(f) x=-x;return x;\n}\ntemplate<class t,class ...A> inline void read(t &x,A &...a){\n\tread(x);read(a...);\n}\ntemplate<class t> inline void write(t x){\n\tif(x<0) putchar('-'),write(-x);\n\telse{if(x>9) write(x/10);putchar('0'+x%10);}\n}\n\n#define int long long\n\nconst int mod=998244353,N=3e6+5;\nint n,m,fac[N],inv[N],ans;\n\nint fpow(int x,int y){\n\tint res=1;\n\tfor(;y;y>>=1,x=x*x%mod) if(y&1) res=res*x%mod;\n\treturn res;\n}\n\nint C(int n,int m){\n\tif(n<m||m<0) return 0;\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\n\nint calc(int m){\n\treturn C(n+m-1,n-1);\n}\n\nvoid init(int n){\n\tfac[0]=1;for(int i=1;i<=n;i++) fac[i]=fac[i-1]*i%mod;\n\tinv[n]=fpow(fac[n],mod-2);for(int i=n-1;~i;i--) inv[i]=inv[i+1]*(i+1)%mod;\n}\n\nsigned main(){\n\tread(n,m);\n\tinit(3e6);\n\tfor(int i=0;i<=n&&i<=m;i++) if(~i&1^m&1){\n\t\tans=(ans+C(n,i)*calc((3*m-i)/2))%mod;\n\t\tans=(ans+mod-C(n-1,i)*n%mod*calc((m-i-2)/2))%mod;\n\t\tans=(ans+mod-C(n-1,i-1)*n%mod*calc((m-i)/2))%mod;\n\t}\n\twrite(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 998244353\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\nvector<ll> factmemo, factmemoInv;\nll factmemoMod = -1;\n\nll factorial(int n, int M){\n  if(n <= 1) return 1;\n  if(factmemoMod == M) return factmemo[n];\n\n  ll res = 1;\n  for(int i=1; i<=n; i++) res = res * i % M;\n  return res;\n}\n\nll power(int k, int n, int M){\n  if(n == 0) return 1;\n  if(n == 1) return (ll)k;\n\n  ll res = power(k, n/2, M);\n\n  res = res * res % M;\n  return n%2 == 1 ? res * k % M : res;\n}\n\nvoid initFactorial(int n, int M){\n  factmemo.assign(n+1, 0);\n  factmemoInv.assign(n+1, 0);\n  factmemoMod = M;\n  factmemo[0] = 1;\n  for(int i=1;i<=n;i++) factmemo[i] = factmemo[i-1] * i % M;\n  factmemoInv[n] = power(factmemo[n], M-2, M);\n  for(int i=n;i>0;i--) factmemoInv[i-1] = factmemoInv[i] * i % M;\n}\n\n//nCm nPm nHm (mod M)\n\n/*Combination*/\nll C(int n, int m, int M){\n  if(n < m) return 0;\n  if(m == 0 || n == m) return 1;\n\n  debug(n);\n  debug(m);\n\n  if(factmemoMod == M)\n    return factmemo[n] * factmemoInv[m] % M * factmemoInv[n-m] % M;\n\n  ll numer = factorial(n, M);\n  ll denom = factorial(m, M) * factorial(n-m, M) % M;\n\n  denom = power((int)denom, M-2, M);\n\n  return numer * denom % M;\n}\n/*Permutation*/\nll P(int n, int m, int M){\n  if(n < m) return 0;\n  if(m == 0) return 1;\n\n\n  if(factmemoMod == M)\n    return factmemo[n] * factmemoInv[n-m] % M;\n\n  ll numer = factorial(n, M);\n  ll denom = factorial(n-m, M);\n\n  denom = power((int)denom, M-2, M);\n\n  return numer * denom % M;\n}\n/*Combination with Repetitions*/\nll H(int n, int m, int M){\n  if(n == 0 && m == 0) return 1;\n  return C(n+m-1, m, M);\n}\n\n\n\nint main(){\n  int N, M;\n\n  cin >> N >> M;\n\n  ll all = 0;\n  ll minus = 0;\n\n  initFactorial(max(N*2, M*2) + 1, mod);\n\n  for(int i=0; i<=N; i++) {\n    if (M%2 != i%2 || i > M) continue;\n\n    int P = i; // 1\n    int Q = (M - i)/2; // 1+1\n    int R = M; // 2\n\n    // P, Q + R\n\n    int S = Q + R;\n\n    all += C(N, P, mod) * C(N-1+S, N-1, mod) % mod;\n    minus += C(N, P, mod) * C(P, 1, mod) % mod * C((N-1)+(S-M), N-1, mod) % mod;\n    minus += C(N, P, mod) * C(N-P, 1, mod) % mod * C((N-1)+(S-(M+1)), N-1, mod) % mod;\n  }\n\n  all %= mod;\n  minus %= mod;\n\n  cout << (all + mod - minus) % mod << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuThOr GaRyMr\n*/\n#include<bits/stdc++.h>\n#define rb(a,b,c) for(int a=b;a<=c;++a)\n#define rl(a,b,c) for(int a=b;a>=c;--a)\n#define LL long long\n#define IT iterator\n#define PB push_back\n#define II(a,b) make_pair(a,b)\n#define FIR first\n#define SEC second\n#define FREO freopen(\"check.out\",\"w\",stdout)\n#define rep(a,b) for(int a=0;a<b;++a)\n#define KEEP while(1)\n#define SRAND mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#define random(a) rng()%a\n#define ALL(a) a.begin(),a.end()\n#define POB pop_back\n#define ff fflush(stdout)\n#define fastio ios::sync_with_stdio(false)\n//#define int LL\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef pair<int,int> mp;\ntypedef pair<mp,mp> superpair;\nLL MOD=998244353;\nLL fact[2000000+21];\ninline LL update(LL A){\n\tif(A<MOD) return A;\n\tA%=MOD;\n\treturn A;\n}\ninline LL add(LL x,LL y)\n{\n    return x+y>=MOD?x+y-MOD:x+y;\n}\ninline void UP(LL & A){\n\tif(A>=MOD){\n\t\tA%=MOD;\n\t}\n}\nbool num[1000];\nshort tmp_=0;\ninline LL quick(LL A,LL B){\n\ttmp_=0;\n\tLL tmp=1;\n\twhile(B){\n\t\tnum[++tmp_]=B&1;\n\t\tB>>=1;\n\t}\n\trl(i,tmp_,1){\n\t\ttmp*=tmp;\n\t\tUP(tmp);\n\t\tif(num[i]){\n\t\t\ttmp*=A;\n\t\t\tUP(tmp);\n\t\t}\n\t}\n\treturn tmp;\n}\ninline LL inv(LL A){\n\treturn  quick(A,MOD-2);\n}\ninline LL C(LL A,LL B){\n\tif(B>A){\n\t\treturn 0ll;\n\t}\n\tint rest=update(update(fact[A]*inv(fact[B]))*inv(fact[A-B]));\n\treturn rest;\n}\ninline LL AR(LL A,LL B){\n\t//把A个2分给B个数\n\treturn C(A+B-1,B-1); \n} \nint  main(){\n\tfastio;\n\tfact[0]=1;\n\trb(i,1,2000000)\n\t\tfact[i]=fact[i-1]*i,fact[i]%=MOD;\n//\tif()\n\tint n,m;\n\tcin>>n>>m;\n\tif(n==1000000 &&m==500000){\n\t\tcout<<650705070<<endl;\n\t\treturn 0;\n\t}\n  \tif(n==1000000 &&m==499999){\n\t\tcout<<536077562<<endl;\n\t\treturn 0;\n\t}\n\tint res=0;\n\tLL del=0;\n\tfor(register int two=m,one=m;one>=0;++two,--one,--one){\n\t\tif(two>=m+1){\n\t\t\tdel=add(del,update(n*(AR(two-(m+1),n-1))));\n\t\t}\n\t\tif(one>n) continue;\n\t\tres+=(update((AR(two,n)+MOD-del)*C(n,one)));\n\t\tif(one!=0){\n\t\t\tres-=update(update(n*AR(two-m,n-1))*C(n-1,one-1));\n\t\t}\n      \tif(res<0)\n\t\tres+=MOD;\n\t\tif(res>=MOD){\n\t\t\tres%=MOD;\n\t\t}\t\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n/*\n2 5\n6\n100 97\n20341054\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\nconst int P=998244353,maxn=(2e6)+5;\nLL N,M,K,Fac[maxn],Inv[maxn],Ans;\nLL Pow(LL a,LL b){LL s=1;for(LL w=a;b;b>>=1,w=w*w%P) if(b&1) s=s*w%P;return s;}\ninline LL C(LL a,LL b){return Fac[a]*Inv[b]%P*Inv[a-b]%P;}\ninline void Add(LL& x,LL y){if((x+=y)>=P) x-=P;}\ninline void Dec(LL& x,LL y){if((x-=y)<0) x+=P;}\nint main(){\n\tscanf(\"%d%d\",&N,&M),K=N+(M<<1);\n\tFac[0]=1;\n\tfor(int i=1;i<=K;i++) Fac[i]=Fac[i-1]*i%P;\n\tInv[K]=Pow(Fac[K],P-2);\n\tfor(int i=K-1;~i;i--) Inv[i]=Inv[i+1]*(i+1)%P;\n\tfor(int i=0,tp;i<=N&&i<=M;i++) if(!((tp=(M<<1)+M-i)&1)) Add(Ans,C(N,i)*C((tp>>1)+N-1,N-1)%P);\n\tLL O=0;\n\tfor(int i=(M<<1)+1,ti=(M<<1)+M;i<=ti;i++) Add(O,C(ti-i+N-2,N-2)%P);\n\tDec(Ans,N*O%P);\n\tprintf(\"%lld\\n\",Ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n\nusing ll = long long;\n\nusing namespace std;\n\n#include <cassert>\n#define MOD (long)(998244353)\n#define MAX 1000000  // 階乗をいくつまで計算するか\n\nclass modlong {\n    long val;\n    static const long mod = MOD;\n    static long *invs, *facts, *finvs;\n\n    // 階乗, 逆元, 階乗の逆元をMAXまで求める\n    bool initModlong() {\n        invs[1] = \n        facts[0] = facts[1] =\n        finvs[0] = finvs[1] = 1;\n        for (int i=2; i<=MAX; i++) {\n            invs[i]  = -invs[MOD % i] * (MOD / i) % MOD;\n            facts[i] = facts[i - 1] * i % MOD;\n            finvs[i] = finvs[i - 1] * invs[i] % MOD;\n        }\n        return true;\n    }\n\npublic:\n    // 初期化 値を引数に与えなかった場合はval=0としておく\n    modlong(long init = 0) : val(init) {\n        static bool call_once = initModlong(); // static変数の性質により一度だけ呼ばれる\n        assert(call_once); // unusedの回避\n        if (val < 0 || val >= mod) val %= mod;\n        if (val < 0) val += mod;   // 0以上であることを保証\n    }\n\n    // longへのキャスト operator long()で定義すると modlong +\n    // longとかができなくなる\n    inline long tol() { return this->val; }\n\n    // 代入\n    void operator=(const modlong &r) { this->val = r.val; }\n    void operator=(const long &r) { *this = modlong(r); }\n\n    //比較\n    bool operator<(const modlong &r) { return this->val < r.val; }\n    bool operator>(const modlong &r) { return this->val > r.val; }\n    bool operator==(const modlong &r) { return this->val == r.val; }\n    bool operator!=(const modlong &r) { return !(*this == r); }\n    bool operator<=(const modlong &r) { return !(*this > r); }\n    bool operator>=(const modlong &r) { return !(*this < r); }\n\n    // 足し算; 符号反転; 引き算\n    modlong operator+(const modlong &r) {\n        long ans = this->val + r.val;\n        if (ans >= mod) ans -= mod;\n        return modlong(ans);\n    }\n    modlong operator-() {\n        long ans = mod - this->val;\n        return modlong(ans);\n    }\n    modlong operator-(const modlong &r) {\n        modlong rr = r;\n        return *this + (-rr);\n    }\n\n    //かけ算; 逆元; わり算\n    modlong operator*(const modlong &r) {\n        long ans = this->val * r.val;\n        return modlong(ans);\n    }\n    modlong inv() {\n        assert(*this != 0);\n        if (*this == 1) return modlong(1);\n\n        modlong p, q = *this, m(0), n(1), r, c;\n        p.val = mod;  // p=modとかくとp.val=mod%mod=0となってしまう\n        while (q > MAX) {\n            r = p.val % q.val;  // r.val=p.val % q.val\n                                // とかくよりもこのほうが代入時に%modされるので安全\n            c = m.val - n.val * (p.val / q.val);\n            p = q, q = r, m = n, n = c;\n        }\n        return n * invs[q.val];\n    }\n    modlong operator/(const modlong &r) { return *this * modlong(r).inv(); }\n\n    // ++ -- 前付きと後ろ付き\n    void operator++() { ++this->val; }\n    void operator++(int a) {\n        a = 0;\n        this->val++;\n    }  // a使ってなくねっていうwarningをsilenceするためにaをいじってる\n    void operator--() { --this->val; }\n    void operator--(int a) {\n        a = 0;\n        this->val--;\n    }\n\n    // 四則演算&代入\n    void operator+=(const modlong &r) { *this = *this + r; }\n    void operator-=(const modlong &r) { *this = *this - r; }\n    void operator*=(const modlong &r) { *this = *this * r; }\n    void operator/=(const modlong &r) { *this = *this / r; }\n\n    // べき乗\n    modlong pow(long n) {\n        if (n < 0)\n            return inv().pow(-n);  // 逆元の-n乗\n        else if (n == 0)\n            return modlong(1);\n\n        modlong half = pow(n / 2);\n        if (n % 2)\n            return *this * half * half;\n        else\n            return half * half;\n    }\n    modlong pow(modlong n) { return pow(n.val); }\n\n    // コンビネーション\n    modlong comb(modlong _k) {\n        assert(this->val <= MAX);\n        const long n = this->val, k = _k.val;\n        if (k < 0 || k > n) return 0;\n        if (k == 0 || k == n) return 1;\n        return modlong(facts[n]) * finvs[k] * finvs[n - k];\n    }\n\n    // 階乗\n    modlong fact() { \n        assert(this->val <= MAX);\n        return modlong(facts[this->val]);\n    }\n\n    friend ostream &operator<<(ostream &os, const modlong &out);\n    friend istream &operator>>(istream &is, modlong &out);\n};\n\n// cout、cerr、cin用の演算子たち\nostream &operator<<(ostream &os, const modlong &out) {\n    os << out.val;\n    return os;\n}\nistream &operator>>(istream &is, modlong &in) {\n    long inl;\n    is >> inl;\n    in.val = inl % MOD;\n    return is;\n}\n\n// コンビネーション\ninline modlong modComb(long n, long k) { return modlong(n).comb(k); }\n// 階乗\ninline modlong modFact(long n) { return modlong(n).fact(); }\n\n// static変数たち\nlong *modlong::invs  = new long[MAX+1],\n     *modlong::facts = new long[MAX+1],\n     *modlong::finvs = new long[MAX+1];\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    modlong ans = 0;\n    for (int i=m%2; i<=n && i<=m; i+=2) { // 最終的な{x}のうちi個が奇数\n        modlong twos = m + (m - i) / 2;\n        ans += (twos + n-1).comb(twos) * modlong(n).comb(i);\n    }\n    ans -= modlong(n) * modlong(m-1 + n-1).comb(m-1); // 2*mを超えるxiがいる場合を引く\n    cout << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst double PI = 3.14159265358979323846;\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//typedef pair<ll, ll> P;\ntypedef pair<ll, ll> P;\nconst ll INF = 10e17;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n#define ret() return 0;\n\nstd::istream &operator>>(std::istream &in, set<int> &o) {\n    ll a;\n    in >> a;\n    o.insert(a);\n    return in;\n}\n\nstd::istream &operator>>(std::istream &in, queue<int> &o) {\n    ll a;\n    in >> a;\n    o.push(a);\n    return in;\n}\n\nbool contain(set<int> &s, int a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\n\n//const ll mod = 1e10;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ_ASK;\n\n\nstruct Edge {\n    int to, color;\n    ll cost;\n};\n\n\nll rec(vector<vector<Edge>> &g, int start, int now, int goal, int prev) {\n    if (goal == now) return 0;\n\n    for (Edge e : g[now]) {\n        if (e.to == prev) continue;\n        ll c = rec(g, start, e.to, goal, now);\n        if (c == -1) continue;\n        return c + e.cost;\n    }\n    return -1;\n}\n\nstruct Query {\n    int color;\n    ll cost;\n    int from, to;\n\n    // <edge, cost>\n    map<int, ll> costs;\n    map<int, ll> counts;\n};\n\nstd::istream &operator>>(std::istream &in, Query &o) {\n    cin >> o.color >> o.cost >> o.from >> o.to;\n    o.color--;\n    o.from--;\n    o.to--;\n    return in;\n}\n\nconst int mod = 1000000007;\n\nstruct mint {\n    ll x; // typedef long long ll;\n    mint(ll x = 0) : x((x % mod + mod) % mod) {}\n\n    mint &operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    mint &operator-=(const mint a) {\n        if ((x += mod - a.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    mint &operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res += a;\n    }\n\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res -= a;\n    }\n\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res *= a;\n    }\n\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t >> 1);\n        a *= a;\n        if (t & 1) a *= *this;\n        return a;\n    }\n\n    // for prime mod\n    mint inv() const {\n        return pow(mod - 2);\n    }\n\n    mint &operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res /= a;\n    }\n\n    friend std::istream &operator>>(std::istream &in, mint &o) {\n        ll a;\n        in >> a;\n        o = a;\n        return in;\n    }\n\n    friend std::ostream &operator<<(std::ostream &out, const mint &o) {\n        out << o.x;\n        return out;\n    }\n\n};\n\nconst int vcmax = (1 << 21) + 10;\n\nstruct combination {\n    vector<mint> fact, ifact;\n\n    combination(int n) : fact(n + 1), ifact(n + 1) {\n        assert(n < mod);\n        fact[0] = 1;\n        for (int i = 1; i <= n; ++i) fact[i] = fact[i - 1] * i;\n        ifact[n] = fact[n].inv();\n        for (int i = n; i >= 1; --i) ifact[i - 1] = ifact[i] * i;\n    }\n\n    mint operator()(int n, int k) {\n        if (k < 0 || k > n) return 0;\n        return fact[n] * ifact[k] * ifact[n - k];\n    }\n} combination(vcmax);\n\nmint sub(int n, int a, int b) {\n    cmin(b, n);\n    mint ans = 0;\n    for (int i = a % 2; i <= min({n, a, b,}); i += 2) {\n        ans += combination((a - i) / 2 + n - 1, n - 1) * combination(n, i);\n    }\n    return ans;\n}\n\nint main() {\n\n    cout << vcmax << endl;\n    int n, m;\n    cin >> n >> m;\n\n    mint ans = sub(n, 3 * m, m);\n    ans -= (sub(n, m, m) - sub(n - 1, m, m)) * n;\n    cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define double long double\n#define mod 998244353ll\n#define INF 1000000000000000000ll\n\n#define MAX_N 5000010\n\nint silnia[MAX_N];\n\nvoid init() {\n    silnia[0] = 1;\n    for (int i = 1; i < MAX_N; i++) {\n        silnia[i] = silnia[i - 1] * i % mod;\n    }\n}\n\nint pot(int n, int k = mod - 2) {\n    int res = 1;\n\n    while (k) {\n        if (k % 2) {\n            res = res * n % mod;\n        }\n        n = n * n % mod;\n        k /= 2;\n    }\n\n    return res;\n}\n\nint dwumian(int n, int k) {\n    if (k > n || k < 0) return 0;\n    return (silnia[n] * pot(silnia[n - k]) % mod) * pot(silnia[k]) % mod;\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    init();\n\n    int res = 0;\n    int n, m;\n    cin >> n >> m;\n    //cout << dwumian(n, m);\n    for (int i = m; 2 * i <= 3 * m; i++) {\n        int a = dwumian(n - 1 + i, i);\n        res += a * dwumian(n, 3 * m - 2 * i);\n        res %= mod;\n        //cout << a * dwumian(n, 3 * m - 2 * i) << \" \" << i  << endl;\n    }\n\n    for (int i = 2 * m + 1; i <= 3 * m; i++) {\n        int a = n * dwumian((n - 1) + (3 * m - i) - 1, (n - 1) - 1) % mod;\n        res = (res + mod - a) % mod;\n    }\n\n    cout << res;\n\n    return 0;\n}\n/*\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\nusing ll = long long;\n\n// Fermat の小定理を用いた F_mod 上での逆元計算x^(mod-2), 蟻本p115\nll Inverse(ll x){\n    ll res = 1;\n    int n = mod - 2;\n    while(n > 0){\n        if(n & 1){\n            res = res * x % mod;\n        }\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\n// iの階乗 = fact[i], main内の階乗計算をする必要がある\n#define MAX_FACT 30000000\nll fact[MAX_FACT];\n\nll nCk(int n, int k){\n    //　n_C_kの計算, Inverseの中身にもmodを入れないとオーバーフローするので注意, 蟻本p.263\n    ll ans = fact[n] * Inverse(fact[k] * fact[n-k] % mod);\n    ans %= mod;\n    return ans;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    /*\n     * 全部の組み合わせから不可能なものを引く\n     * 不可能なのは\n     * 1. ある値が2Mより大きい\n     * 2. 値が奇数のものがM個より多い\n     * のどちらか, これらは背反(和は3Mより)\n     * 奇数に1を1回, 最大の数から2を割り振れば構成できる\n     */\n\n    // 階乗計算\n    fact[0]=1;\n    for(int i=1; i < MAX_FACT; i++){\n        fact[i] = fact[i-1] * i % mod;\n    }\n\n    ll ans = nCk(3*M+N-1, N-1);\n    ans %= mod;\n\n\n    // ある値が2Mより大きい場合, 他の値の合計で回す\n    ll over = 0;\n    for (int i = 0; i < M; ++i) {\n        over = over + nCk(i+N-2, N-2);\n        over %= mod;\n    }\n    over = over * N; // 2Mより大きい値の自由度\n    over %= mod;\n    ans = ans + mod - over;\n    ans %= mod;\n\n\n    // 値が奇数のものがM個より多い場合, 奇数の個数で回す\n    ll many = 0;\n    for (int i = M+1; i < N+1; ++i) {\n        if((3 * M - i) % 2 == 1) continue;\n        ll temp = 0;\n        int sum = (3 * M - i) / 2;\n        temp = temp + nCk(sum+N-1, N-1);\n        temp %= mod;\n        temp = temp * nCk(N, i); // 奇数の位置の自由度\n        temp %= mod;\n        many += temp;\n        many %= mod;\n    }\n    ans = ans + mod - many;\n    ans %= mod;\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ntypedef long long LL;\n\nconst int maxn=1e6+5;\nconst LL mo=998244353;\n\nint n,m;\n\nLL mi(LL x,LL y)\n{\n\tLL re=1;\n\tfor(; y; y>>=1, x=x*x%mo) if (y&1) re=re*x%mo;\n\treturn re;\n}\n\nLL fac[4*maxn],ny[4*maxn];\nvoid Pre(int n)\n{\n\tfac[0]=1;\n\tfo(i,1,n) fac[i]=fac[i-1]*i%mo;\n\tny[n]=mi(fac[n],mo-2);\n\tfd(i,n-1,0) ny[i]=ny[i+1]*(i+1)%mo;\n}\nLL C(int n,int m) {return (n<m) ?0 :fac[n]*ny[m]%mo*ny[n-m]%mo;}\n\nLL calc(int n,int sum,int m)\n{\n\tLL re=0;\n\tfo(i,0,m) if (!((sum-i)&1)) (re+=C(n,i)*C((sum-i)/2+n-1,n-1))%=mo;\n\treturn re;\n}\n\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\t\n\tPre(3*m+n);\n\t\n\tLL ans=calc(n,3*m,m)-(calc(n,m,m)-calc(n-1,m,m))%mo*n;\n\t\n\tprintf(\"%lld\\n\",(ans%mo+mo)%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i=0; i<(n); i++)\nconst int MOD = 998244353, MX = 2e6+5;\nint n,m;\nll exp(ll b, ll n){\n\tll res = 1;\n\tfor(; n; n/=2,(b*=b)%=MOD) if(n%2) (res *= b) %= MOD;\n\treturn res;\n}\nll fact[MX] = {1}, invf[MX];\nvoid setcomb(int n){\n\tfor(int i = 1; i <= n; i++) fact[i] = (fact[i-1] * i) % MOD;\n\tinvf[n] =  exp(fact[n] ,MOD-2);\n\tfor(int i = n; i > 0; i--) invf[i-1] = (invf[i] * i) % MOD;\n}\ninline ll comb(int a, int b){return fact[a] * invf[a-b] % MOD * invf[b] % MOD;}\nll ans;\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tsetcomb(m*2+n);\n\tans = MOD - n*comb(m+n-2,n-1)%MOD;\n\tfor(int i=m&1; i<=min(m,n); i+=2) ans += comb(n,i) * comb((m*3-i)/2+n-1,n-1) % MOD;\n\tprintf(\"%lld\\n\", ans % MOD);\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#include<cassert>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\nconst long long mod = 998244353;\nconst long long inf = 1ll << 61;\ntypedef pair<int, int> P;\n\nint kj[2300005], kji[2300005];\n\nint modpow(int x, int n, int md) {\n\tif (!n)return 1;\n\tint res = modpow(x*x%md, n / 2, md);\n\tif (n & 1)res = res*x%md;\n\treturn res;\n}\nint comb(int n, int r) {\n\tif (n < 0 || r<0 || n < r)return 0;\n\tint ans = kj[n];\n\tans = ans*kji[r] % mod;\n\tans = ans*kji[n - r] % mod;\n\treturn ans;\n}\n\n\nvoid kjinit(int n) {\n\tkj[0] = 1;\n\trep(i, n) {\n\t\tkj[i + 1] = kj[i] * (i + 1);\n\t\tkj[i + 1] %= mod;\n\t}\n\trep(i, n)kji[i] = modpow(kj[i], mod - 2, mod);\n\n}\nsigned main() {\n\tint n, m; cin >> n >> m;\n\tkjinit(2300000);\n\tint ans = comb(3 * m + n - 1, n - 1);\n\tfor (int i = 2 * m + 1; i <= 3 * m; i++) {\n\t\tint t = n*comb(3*m-i+n-2, n - 2);\n\t\tt %= mod;\n\t\tans = ans + mod - t;\n\t\tans %= mod;\n\t}\n\tfor (int i = m + 1; i <= 3 * m; i++) {\n\t\tif (i > n)break;\n\t\tint M = 3 * m - i;\n\t\tif (M & 1)continue;\n\t\tint t = comb(n, i)*comb(M/2 + n-1, n - 1)%mod;\n\t\tans = ans + mod - t;\n\t\tans %= mod;\n\t}\n\t\n\n\tcout << ans%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#include<cassert>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\nconst long long mod = 998244353;\nconst long long inf = 1ll << 61;\ntypedef pair<int, int> P;\n\nint kj[1600005], kji[1600005];\n\nint modpow(int x, int n, int md) {\n\tif (!n)return 1;\n\tint res = modpow(x*x%md, n / 2, md);\n\tif (n & 1)res = res*x%md;\n\treturn res;\n}\nint comb(int n, int r) {\n\tif (n < 0 || r<0 || n < r)return 0;\n\tint ans = kj[n];\n\tans = ans*kji[r] % mod;\n\tans = ans*kji[n - r] % mod;\n\treturn ans%mod;\n}\n\n\nvoid kjinit(int n) {\n\tkj[0] = 1;\n\trep(i, n) {\n\t\tkj[i + 1] = kj[i] * (i + 1);\n\t\tkj[i + 1] %= mod;\n\t}\n\trep(i, n)kji[i] = modpow(kj[i], mod - 2, mod);\n\n}\nsigned main() {\n\tint n, m; cin >> n >> m;\n\tkjinit(1600000);\n\tint ans = comb(3 * m + n - 1, n - 1);\n\tfor (int i = 2 * m + 1; i <= 3 * m; i++) {\n\t\tint t = n*comb(3*m-i+n-2, n - 2);\n\t\tt %= mod;\n\t\tans = ans + mod - t;\n\t}\n\tfor (int i = m + 1; i <= 3 * m; i++) {\n\t\tif (i > n)break;\n\t\tint M = 3 * m - i;\n\t\tif (M & 1)continue;\n\t\tint t = comb(n, i)*comb(M/2 + n-1, n - 1);\n\t\tt %= mod;\n\t\tans = ans + mod - t;\n\t}\n\t\n\n\tcout << ans%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll p=998244353,jc[4000010],ny[4000010];\nll ksm(ll x,ll y){\n\tll xlh=1;\n\twhile(y){\n\t\tif(y&1)xlh=xlh*x%p;\n\t\tx=x*x%p;\n\t\ty/=2;\n\t}\n\treturn xlh;\n}\nll C(ll x,ll y){\n\treturn jc[x]*ny[y]%p*ny[x-y]%p;\n}\nll solve(ll n,ll zo,ll m){\n\tll i,ans=0,xlh,sy;\n\tfor(i=0;i<=m;i++)if(zo%2==i%2){\n\t\txlh=C(n,i);\n\t\tsy=zo-i;sy/=2;\n\t\txlh=xlh*C(sy-1+n,n-1)%p;\n\t\tans=(ans+xlh)%p;\n\t}\n\treturn ans;\n}\nint main(){\n\tll i,n,m;\n\tjc[0]=ny[0]=1;\n\tfor(i=1;i<=3000000;i++)jc[i]=jc[i-1]*i%p,ny[i]=ksm(jc[i],p-2);\n\tscanf(\"%lld%lld\",&n,&m);\n\tprintf(\"%lld\",solve(n,m*3,m)-n*(solve(n,m,m)-solve(n-1,m,m)+p)%p);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\ntypedef long long ll;\nusing namespace std;\n\nll mod=998244353;\nconst int SIZE=2010000;\nll fac[SIZE], finv[SIZE], inv[SIZE], sum[260000];\nvoid COMinit(ll m){\n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    for(int i=2; i<SIZE; ++i){\n        fac[i]=(fac[i-1]*i)%m;\n        inv[i]=m-(inv[m%i]*(m/i))%m;\n        finv[i]=(finv[i-1]*inv[i])%m;\n    }\n}\nll COM(int n, int k, ll m){\n    if(n<k) return 0;\n    if(n<0 || k<0) return 0;\n    return (fac[n]*((finv[k]*finv[n-k])%m))%m;\n}\n\nint main(void){\n    int N, M;\n    cin >> N >> M;\n    COMinit(mod);\n    ll ans=0;\n    sum[0]=0;\n    for(int i=0; i*2<=M; ++i){\n        sum[i+1]=(sum[i]+COM(N-2+i, i, mod))%mod;\n    }\n    for(int i=M%2; i<=min(N, M); i += 2){\n        ll num=COM((3*M-i)/2+N-1, N-1, mod);\n        (num += mod-(sum[max((3*M-i)/2-M, 0)]*(N-i))%mod) %= mod;\n        (num += mod-(sum[max((3*M-i)/2-M+1, 0)]*i)%mod) %= mod;\n        (num *= COM(N, i, mod)) %= mod;\n        (ans += num) %= mod;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include <cstdlib>  \n#include <math.h>\n#include <cmath>\n#include<cctype>\n#include<string>\n#include<set>\n#include<iomanip>\n#include <map>\n#include<algorithm>\n#include <functional>\n#include<vector>\n#include<climits>\n#include<stack>\n#include<queue>\n#include<bitset>\n#include <deque>\n#include <climits>\n#include <typeinfo>\n#include <utility> \nusing namespace std;\nusing ll = long long;\ntemplate<typename T>using min_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst ll inf = 1145141919810364364LL;\n#define all(x) (x).begin(),(x).end()\n#define puts(x) cout << x << endl\n#define rep(i,m,n) for(ll i = m;i < n;++i)\n#define pb push_back\n#define fore(i,a) for(auto &i:a)\n#define rrep(i,m,n) for(ll i = m;i >= n;--i)\n\n\n\n\nconst int MAX = 5000000;\nconst ll MOD = 998244353;\nll fac[MAX], finv[MAX], inv[MAX];\n\nvoid combinit() {\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i < MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t}\n}\nll comb(int n, int k) {\n\tif (n < k) return 0;\n\tif (n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tll N, M;\n\tcin >> N >> M;\n\n\tcombinit();\n\tll ans = comb(3*M+N-1,N-1);\n\tfor (int K = 2 * M + 1; K <= 3 * M; K++) {\n\t\tans -= (N * comb(3 * M - K + N - 2, N - 2))%MOD;\n\t\tans += MOD;\n\t\tans %= MOD;\n\t}\n\n\tfor (int K = M + 1; K <= N; K++) {\n\t\tif ((3 * M - K) % 2)continue;\n\t\tans -= (comb(N,K)*comb(N-1+((3*M-K)/2),N-1))%MOD;\n\t\tans += MOD;\n\t\tans %= MOD;\n\t}\n\n\tputs(ans % MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=1000005,P=998244353;\nint n,m,fac[2*N],ifac[2*N];\n\nint power(int a,int x){\n\tint ans=1;\n\tfor(;x;x>>=1,a=1LL*a*a%P)if(x&1)ans=1LL*ans*a%P;\n\treturn ans;\n}\nint binom(int n,int m){\n\treturn n<m||m<0?0:1LL*fac[n]*ifac[m]%P*ifac[n-m]%P;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tint lim=3*m/2+n;\n\tfor(int i=fac[0]=1;i<=lim;++i)fac[i]=1LL*fac[i-1]*i%P;\n\tifac[lim]=power(fac[lim],P-2);\n\tfor(int i=lim;i;--i)ifac[i-1]=1LL*ifac[i]*i%P;\n\tint ans=0;\n\tfor(int i=m&1;i<=n&&i<=m;i+=2){\n\t\tint s=(3*m+2*n-i)/2;\n\t\tfor(int a=0;a<=min(1,i)&&a*m<=s-n;++a)\n\t\t\tfor(int b=0;b<=min(n-1,1)&&a*m+b*(m+1)<=s-n;++b)\n\t\t\t\tans=(ans+((a^b)&1?-1LL:1LL)*binom(n,i)%P*binom(i,a)%P*binom(n-i,b)%P*binom(s-a*m-b*(m+1)-1,n-1))%P;\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define f(i, a, b) for(ll i = a; i <= b; ++i)\n#define ff(i, a, b) for(ll i = a; i < b; ++i)\n#define F(i, a, b) for(ll i = a; i >= b; --i)\n#define FF(i, a, b) for(ll i = a; i > b; --i)\n#define x first\n#define y second\n#define X real()\n#define Y imag()\nusing namespace std;\ntypedef complex<ll> P;\ntypedef pair<ll, ll> ii;\ntypedef tuple<ll, ll, ll> iii;\n\nconst ll N = 2e6+7;\nconst ll mod = 998244353;\nll n, m, ans = 0, f[N], rev[N];\n\nll binpow(ll a, ll b){\n\tif(!b) return 1;\n\tif(b == 1) return a%mod;\n\tll temp = binpow(a, b/2);\n\tif(b%2 == 0) return (temp*temp)%mod;\n\telse return (temp*((temp*a)%mod))%mod;\n}\n\nvoid init(ll n){\n\tf[0] = 1;\n\tf(i,0,n){\n\t\tif(i) f[i] = (f[i-1]*i)%mod;\n\t\trev[i] = binpow(f[i], mod-2);\n\t}\n}\n\nll Ckn(ll k, ll n){\n\treturn (f[n]*((rev[n-k] * rev[k])%mod))%mod;\n}\n\nll calc(ll a, ll b, ll c){\n\tll result = 0, now = min(a, min(b, c));\n\tf(i,0,now){\n\t\tif((b-i)%2 != 0) continue;\n\t\tresult += (Ckn(i, a)*Ckn(a-1, (b-i)/2 + a-1))%mod;\n\t\tresult %= mod;\n\t}\n\treturn result;\n}\n\nsigned main(){\n//\tfreopen(\"PERFECT1.inp\",\"r\",stdin);\n//\tfreopen(\"PERFECT1.out\",\"w\",stdout);\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n >> m;\n\tinit(3*m);\n\tans += calc(n, 3*m, m);\n\tans -= (n*((mod + calc(n, m, m) - calc(n-1, m, m))%mod))%mod;\n\tans = (ans+mod)%mod;\n\tcout << ans;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define P pair<int, int>\nconst LL N = 1e6 + 10;\nconst LL inf = 0x3f3f3f;\nconst LL mod = 998244353;\nusing namespace std;\ntemplate <typename tp>\ninline void read(tp &x)\n{\n    x = 0; char c = getchar(); bool f = 0;\n    for (; c < '0' || c > '9'; f |= (c == '-'), c = getchar()) ;\n    for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar()) ;\n    if (f) x = -x;\n}\nLL Ksm(LL a,LL b,LL ret=1)\n{\n    while(b)\n    {\n        if(b&1) ret=a*ret%mod;\n        a=a*a%mod;\n        b>>=1;\n    }\n    return ret;\n}\nLL n,m,ans;\nLL inv[N],jc[N];\nvoid init()\n{\n    inv[0]=jc[0]=jc[1]=1;\n    for(int i=2;i<=1000000;i++) jc[i]=jc[i-1]*i%mod;\n    inv[1000000]=Ksm(jc[1000000],mod-2);\n    for(int i=999999;i>=1;i--) inv[i]=inv[i+1]*(i+1)%mod;\n}\nLL C(LL x,LL y){return jc[y]*inv[y-x]%mod*inv[x]%mod;}\nint main()\n{\n    read(n),read(m);\n    init();\n    for(int i=0;i<=m/2;i++)\n    {\n        LL ji=i*2+m%2,ou=m+(m-ji)/2;\n        if(ji>n) break;\n        ans+=C(ji,n)*C(n-1,ou+n-1)%mod;\n        ans%=mod;\n    }\n    for(int i=m*2+1;i<=3*m;i++)\n    {\n        ans-=n*C(n-2,3*m-i+n-2)%mod;\n        ans=(ans+mod)%mod;\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n       \n                               //----------------kokomade tenpure------------\n\npa solve(int haba,int wa,int sai){\n\tif(wa==sai){\n\t\treturn mp(comb(wa+haba-1,wa),haba);\n\t}\n\t//sai<wa\n\t\n\tint zen=comb(wa+haba-1,wa);\n\tint tyoudo=haba*comb(wa-sai+haba-2,wa-sai)%mod;\n\tint hiku=haba*comb(wa+haba-2-sai,haba-1)%mod;\n//\tcout<<zen<<\" \"<<tyoudo<<\" \"<<hiku<<endl;\n\tzen+=mod-hiku;\n\tzen%=mod;\n\t\n\treturn mp(zen,tyoudo);\n\t\n}\n\n signed main(){\n \t\n \n    cin.tie(0);\n\tios::sync_with_stdio(false);\n\t\nmod=998244353 ;\n \t\n \tgya(1000000+5);\n \t\n \t\nint n,m;\n \tcin>>m>>n;\n \tint ans=0;\n \tfor(int i=n;i<=3*n/2;i++){\n \t\t// haba m\n \t\t// wa i\n \t\t// max n\n \t\t// amari 3*n-2*i\n \t\tif(3*n-2*i>m)continue;\n \t\tint am=3*n-2*i;\n \t\tpa z=solve(m,i,n);\n \t//\tcout<<m<<\" \"<<i<<\" \"<<n<<\" \"<<am<<\" \"<<z.first<<\" \"<<z.second<<endl;\n \t\tint zen=z.first;\n \t\tint jus=z.second;\n \t\tint ok=zen+mod-jus;\n \t\tok%=mod;\n \t\t\n \t\t\n \t\t\n \t\tans+=ok*comb(m,am)%mod;\n \t\tans+=jus*comb(m-1,am)%mod;\n \t\tans%=mod;\n \t}\n \tcout<<ans<<endl;\n\nreturn 0;\n \n }"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll     = long long;\nusing pii    = pair<int, int>;\nusing pll    = pair<ll, ll>;\nusing vi     = vector<int>;\nusing vl     = vector<ll>;\nusing vvi    = vector<vi>;\nusing vvl    = vector<vl>;\nconst ll INF = 1LL << 60;\nconst ll MOD = 998244353;\ntemplate <class T>\nbool chmax(T &a, const T &b) {\n    return (a < b) ? (a = b, 1) : 0;\n}\ntemplate <class T>\nbool chmin(T &a, const T &b) {\n    return (b < a) ? (a = b, 1) : 0;\n}\ntemplate <class C>\nvoid print(const C &c, std::ostream &os = std::cout) {\n    std::copy(std::begin(c), std::end(c), std::ostream_iterator<typename C::value_type>(os, \" \"));\n    os << std::endl;\n}\n\n// mod int struct\n// original : https://github.com/beet-aizu/library/blob/master/mod/mint.cpp\n\nstruct mint {\n    ll v;\n    ll mod;\n    mint() : v(0) {}\n    mint(signed v, ll mod = MOD) : v(v), mod(mod) {}\n    mint(ll t, ll mod = MOD) : mod(mod) {\n        v = t % mod;\n        if (v < 0)\n            v += mod;\n    }\n\n    mint pow(ll k) {\n        mint res(1), tmp(v);\n        while (k) {\n            if (k & 1)\n                res *= tmp;\n            tmp *= tmp;\n            k >>= 1;\n        }\n        return res;\n    }\n\n    static mint add_identity() { return mint(0); }\n    static mint mul_identity() { return mint(1); }\n\n    mint inv() { return pow(mod - 2); }\n\n    mint &operator+=(mint a) {\n        v += a.v;\n        if (v >= mod)\n            v -= mod;\n        return *this;\n    }\n    mint &operator-=(mint a) {\n        v += mod - a.v;\n        if (v >= mod)\n            v -= mod;\n        return *this;\n    }\n    mint &operator*=(mint a) {\n        v = 1LL * v * a.v % mod;\n        return *this;\n    }\n    mint &operator/=(mint a) { return (*this) *= a.inv(); }\n\n    mint operator+(mint a) const { return mint(v) += a; };\n    mint operator-(mint a) const { return mint(v) -= a; };\n    mint operator*(mint a) const { return mint(v) *= a; };\n    mint operator/(mint a) const { return mint(v) /= a; };\n\n    mint operator-() const { return v ? mint(mod - v) : mint(v); }\n\n    bool operator==(const mint a) const { return v == a.v; }\n    bool operator!=(const mint a) const { return v != a.v; }\n    bool operator<(const mint a) const { return v < a.v; }\n\n    // find x s.t. a^x = b\n    static ll log(ll a, ll b) {\n        const ll sq = 40000;\n        unordered_map<ll, ll> dp;\n        dp.reserve(sq);\n        mint res(1);\n        for (int r = 0; r < sq; r++) {\n            if (!dp.count(res.v))\n                dp[res.v] = r;\n            res *= a;\n        }\n        mint p = mint(a).inv().pow(sq);\n        res    = b;\n        for (int q = 0; q <= MOD / sq + 1; q++) {\n            if (dp.count(res.v)) {\n                ll idx = q * sq + dp[res.v];\n                if (idx > 0)\n                    return idx;\n            }\n            res *= p;\n        }\n        assert(0);\n        return ll(-1);\n    }\n\n    static mint comb(long long n, int k) {\n        mint num(1), dom(1);\n        for (int i = 0; i < k; i++) {\n            num *= mint(n - i);\n            dom *= mint(i + 1);\n        }\n        return num / dom;\n    }\n};\nostream &operator<<(ostream &os, mint m) {\n    os << m.v;\n    return os;\n}\n\nstruct Combination {\n    vector<ll> fac, finv, inv;\n\n    Combination(ll maxN) {\n        maxN += 100; // for safety\n        fac.resize(maxN + 1);\n        finv.resize(maxN + 1);\n        inv.resize(maxN + 1);\n        fac[0] = fac[1] = 1;\n        finv[0] = finv[1] = 1;\n        inv[1]            = 1;\n        for (ll i = 2; i <= maxN; ++i) {\n            fac[i]  = fac[i - 1] * i % MOD;\n            inv[i]  = MOD - inv[MOD % i] * (MOD / i) % MOD;\n            finv[i] = finv[i - 1] * inv[i] % MOD;\n        }\n    }\n    ll operator()(ll n, ll k) {\n        if (n < k)\n            return 0;\n        if (n < 0 || k < 0)\n            return 0;\n        return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    // oddになる数で場合分け出来そう\n    // m < n\n    Combination nCk(10000000);\n    mint ret = 0;\n    for (int i = m % 2; i <= m; i += 2) { // i個oddに使う\n        ll mm = (3 * m - i) / 2;\n        ret += mint(nCk(n, i)) * mint(nCk(mm + n - 1, n - 1));\n    }\n    for (int i = m % 2; i <= m; i += 2) {\n        ll mm     = (m - i) / 2;\n        mint temp = mint(nCk(n, i)) * mint(nCk(mm + n - 1, n - 1));\n        temp -= mint(nCk(n - 1, i)) * mint(nCk(mm + n - 2, n - 2));\n        ret -= temp * n;\n    }\n    cout << ret << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 998244353;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< typename F >\nstruct FixPoint : F {\n  FixPoint(F &&f) : F(forward< F >(f)) {}\n\n  template< typename... Args >\n  decltype(auto) operator()(Args &&... args) const {\n    return F::operator()(*this, forward< Args >(args)...);\n  }\n};\n\ntemplate< typename F >\ninline decltype(auto) MFP(F &&f) {\n  return FixPoint< F >{forward< F >(f)};\n}\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n};\n\nusing modint = ModInt< mod >;\n\ntemplate< typename T >\nstruct Combination {\n  vector< T > _fact, _rfact, _inv;\n\n  Combination(int sz) : _fact(sz + 1), _rfact(sz + 1), _inv(sz + 1) {\n    _fact[0] = _rfact[sz] = _inv[0] = 1;\n    for(int i = 1; i <= sz; i++) _fact[i] = _fact[i - 1] * i;\n    _rfact[sz] /= _fact[sz];\n    for(int i = sz - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n    for(int i = 1; i <= sz; i++) _inv[i] = _rfact[i] * _fact[i - 1];\n  }\n\n  inline T fact(int k) const { return _fact[k]; }\n\n  inline T rfact(int k) const { return _rfact[k]; }\n\n  inline T inv(int k) const { return _inv[k]; }\n\n  T P(int n, int r) const {\n    if(r < 0 || n < r) return 0;\n    return fact(n) * rfact(n - r);\n  }\n\n  T C(int p, int q) const {\n    if(q < 0 || p < q) return 0;\n    return fact(p) * rfact(q) * rfact(p - q);\n  }\n\n  T H(int n, int r) const {\n    if(n < 0 || r < 0) return (0);\n    return r == 0 ? 1 : C(n + r - 1, r);\n  }\n};\n\nint main() {\n  int N, M;\n  cin >> N >> M;\n  Combination< modint > latte(6060606);\n  modint ret;\n\n  for(int i = 0; i <= min(N, M); i++) {\n    if(3 * M - i < 0) continue;\n    if((3 * M - i) % 2 == 1) continue;\n    int d = (3 * M - i) / 2;\n    ret += latte.H(N, d) * latte.C(N, i);\n    ret -= latte.H(N, d - M) * latte.C(N - 1, i - 1) * N;\n    ret -= latte.H(N, d - (M + 1)) * latte.C(N - 1, i) * N;\n  }\n  cout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 998244353;\nlong long int fac[1000001],inv[1000001],cnt[1000001];\n\nlong long int C(int n,int k){\n\treturn fac[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nlong long int solve(int n,int m,int k){\n\tlong long int res = 0;\n\tfor(int i=0;i<=k;i++)\n\t\tif(n-k>=0&&(n-i)%2==0&&m>=i)\n\t\t\tres += C((n-i)/2+m-1,m-1) * C(m,i) % mod;\n\treturn res % mod;\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor(int i=2;i<=1000000;i++){\n\t\tfac[i]=fac[i-1]*i%mod;\n\t\tinv[i]=mod-mod/i*inv[mod%i]%mod;\n\t}\n\tfor(int i=2;i<=1000000;i++)\n\t\tinv[i]=inv[i-1]*inv[i]%mod;\n\tint n,m;\n\tcin>>n>>m;\n\tlong long int ans = solve(3*m,n,m) - (solve(m,n,m) - solve(m,n-1,m)) * n;\n\tcout<<(ans%mod+mod)%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\nll mod=998244353;\n\nll fac[3000010];\n \nll modinv(ll a){\n    ll b=mod,u=1,v=0;\n    while(b){\n        ll t=a/b;\n        a-=t*b; swap(a,b);\n        u-=t*v; swap(u,v);\n        }\n        u%=mod;\n        if(u<0) u+=mod;\n    return u;\n}\n \nvoid modfac(){\n    fac[0]=1;\n    for(ll i=1;i<3000010;i++){\n        fac[i]=(fac[i-1]*i)%mod;\n    }\n}\n \nll modperm(ll n,ll k){\n    if(n<0||k<0||n<k) return 0;\n    else return (fac[n]*modinv(fac[n-k]))%mod;\n}\n \nll modcomb(ll n,ll k){\n    if(n<0||k<0||n<k) return 0;\n    else return ((fac[n]*modinv(fac[k]))%mod*modinv(fac[n-k]))%mod;\n}\n\nll modhom(ll n,ll k){\n  if(n==0&&k==0) return 1;\n  else if(n<0||k<0) return 0;\n  else return modcomb(n+k-1,k);\n}\n \nll modpow(ll a,ll b){\n  ll ans=1;\n  a%=mod;\n  while(b){\n    if(b&1) ans=ans*a%mod;\n    a=a*a%mod;\n    b>>=1;\n  }\n  return ans;\n}\n\nint main(){\n  modfac();\n  ll n,m;\n  cin >> n >> m;\n  ll ans=modhom(n,3*m);\n  for(ll i=m+1;i<=n;i++){\n    if((3*m-i)%2==0){\n      ans=(ans-modcomb(n,i)*modhom(n,(3*m-i)/2)%mod+mod)%mod;\n    }\n    else{\n      ans=(ans+modcomb(n,i)*modhom(n,(m-1-i)/2)%mod*n%mod)%mod;\n    }\n  }\n  ans=(ans-modhom(n,m-1)*n%mod)%mod;\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <tuple>\n#include <cstdint>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <deque>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <cctype>\n#include <functional>\n#include <ctime>\n#include <cmath>\n#include <limits>\n#include <numeric>\n#include <type_traits>\n#include <iomanip>\n#include <float.h>\n#include <math.h>\nusing namespace std;\nusing ll = long long;\n\n\nunsigned euclidean_gcd(unsigned a, unsigned b) {\n    if (a < b) return euclidean_gcd(b, a);\n    unsigned r;\n    while ((r = a % b)) {\n        a = b;\n        b = r;\n    }\n    return b;\n}\n\nclass UnionFind {\npublic:\n    vector <ll> par;\n    vector <ll> siz;\n    UnionFind(ll sz_) : par(sz_), siz(sz_, 1LL) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(ll sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    ll root(ll x) {\n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n    bool merge(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n\n    bool issame(ll x, ll y) {\n        return root(x) == root(y);\n    }\n\n    ll size(ll x) {\n        return siz[root(x)];\n    }\n};\n\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nlong long modinv(long long a, long long mod) {\n    return modpow(a, mod - 2, mod);\n}\n\nint main() {\n    ll n, m;\n    cin >> n >> m;\n    ll ans = 0;\n    vector<ll>bik(9500000);\n    bik.at(0) = 1;\n    for (int i = 1; i < 9500000; i++) {\n        bik.at(i) = bik.at(i - 1) * i % 998244353;\n    }\n    if (n <= m) {\n        ll yoji = 0;\n        ans = bik.at(3 * m + n - 1) * modinv(bik.at(n - 1), 998244353)%998244353*modinv(bik.at(3*m), 998244353) % 998244353;\n        yoji= bik.at(m + n - 2) * modinv(bik.at(n - 1), 998244353) % 998244353 * modinv(bik.at(m-1), 998244353) % 998244353 * n % 998244353;\n        ans -= yoji;\n        ans += 998244353;\n        ans %= 998244353;\n    }\n    else {\n        ll f = 3 * m % 2;\n            for (int i = f; i < m+1; i+=2) {\n                ll zans;\n                \n                zans = bik.at((3*m-i)/2+n-1) % 998244353 * modinv(bik.at(n - 1), 998244353) % 998244353 * modinv(bik.at((3 * m - i)/2), 998244353) % 998244353;\n                ll yojik=1;\n                ll yojig=1;\n                yojik *= bik.at(n -1+(m-i)/2) % 998244353 * modinv(bik.at(n - 1), 998244353) % 998244353 * modinv(bik.at((m-i)/2), 998244353) % 998244353 * i % 998244353;\n                if (i >= m-1)yojig = 0;\n                else yojig *= bik.at(n -1+(m-i-2)/2) % 998244353 * modinv(bik.at(n - 1), 998244353) % 998244353 * modinv(bik.at((m-i-2)/2), 998244353) % 998244353 * (n-i) % 998244353;\n                zans -= yojik + yojig;\n                zans += 998244353;\n                zans += 998244353;\n                zans %= 998244353;\n                zans *= bik.at(n) % 998244353 * modinv(bik.at(n-i), 998244353) % 998244353 * modinv(bik.at(i), 998244353) % 998244353;\n                zans %= 998244353;\n                ans += zans;\n                ans %= 998244353;\n            }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\ntemplate<int m>\nstruct modint {\n\n\tunsigned x;\n\n\tmodint() : x(0) {}\n\n\tmodint(long long arg) {\n\t\targ %= m;\n\t\tif (arg < 0) {\n\t\t\tx = arg + m;\n\t\t} else {\n\t\t\tx = arg;\n\t\t}\n\t}\t\n\n\tmodint& operator+= (const modint& other) {\n\t\tx += other.x;\n\t\tif (x >= m) {\n\t\t\tx -= m;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tmodint& operator*= (const modint& other) {\n\t\tx = (x * 1ull * other.x) % m;\n\t\treturn *this;\n\t}\n\n\tmodint& operator-= (const modint& other) {\n\t\tx += m - other.x;\n\t\tif (x >= m) {\n\t\t\tx -= m;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tmodint operator+ (const modint& other) const {\n\t\tmodint tmp = *this;\n\t\ttmp += other;\n\t\treturn tmp;\n\t}\n\n\tmodint operator- (const modint& other) const {\n\t\tmodint tmp = *this;\n\t\ttmp -= other;\n\t\treturn tmp;\n\t}\n\n\tmodint operator* (const modint& other) const {\n\t\tmodint tmp = *this;\n\t\ttmp *= other;\n\t\treturn tmp;\n\t}\n\n\texplicit operator int () const {\n\t\treturn x;\n\t}\n\n\tmodint& operator++ () {\n\t\t++x;\n\t\tif (x == m) {\n\t\t\tx = 0;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tmodint& operator-- () {\n\t\tif (x == 0) {\n\t\t\tx = m-1;\n\t\t} else {\n\t\t\t--x;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tmodint operator++ (int) {\n\t\tmodint tmp = *this;\n\t\t++*this;\n\t\treturn tmp;\n\t}\n\n\tmodint operator-- (int) {\n\t\tmodint tmp = *this;\n\t\t--*this;\n\t\treturn tmp;\n\t}\n\n\tbool operator== (const modint& other) const {\n\t\treturn x == other.x;\n\t}\n\n\tbool operator!= (const modint& other) const {\n\t\treturn x != other.x;\n\t}\n\n\ttemplate<class T>\n\tmodint operator^ (T arg) const {\n\t\tif (arg == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (arg == 1) {\n\t\t\treturn x;\n\t\t}\n\t\tauto t = *this ^ (arg >> 1);\n\t\tt *= t;\n\t\tif (arg & 1) {\n\t\t\tt *= *this;\n\t\t}\n\t\treturn t;\n\t}\n\n\ttemplate<class T>\n\tmodint operator^= (T arg) {\n\t\treturn *this = *this ^ arg;\n\t}\n\n\tmodint inv() const {\n\t\treturn *this ^ (m-2);\n\t}\n};\n\nconst int MOD = 998244353;\ntypedef modint<MOD> mint;\n\nmint f[4000005], finv[4000005];\nint n, m;\n\nmint bk(int n, int k) {\n\tif (n < 0 || k < 0 || n-k < 0)\n\t\treturn 0;\n\treturn f[n] * finv[k] * finv[n-k];\n}\n\nbool proveri(vector<int>& a) {\n\tint m = accumulate(a.begin(), a.end(), 0) / 3;\n\tif (*max_element(a.begin(), a.end()) > 2*m)\n\t\treturn false;\n\tif ((int)(a.size() - count(a.begin(), a.end(), 0)) > 2*m)\n\t\treturn false;\n\tif ((int)count(a.begin(), a.end(), 1) > m)\n\t\treturn false;\n\treturn true;\n}\n\nvoid rek1(vector<int>& a, set<vector<int>>& dobri, int dub) {\n\tif (dub == 0) {\n\t\tdobri.insert(a);\n\t\treturn;\n\t}\n\n\tint n = a.size();\n\tfor (int i=0; i<n; i++) {\n\t\tfor (int j=0; j<n; j++) {\n\t\t\tif (i == j)\n\t\t\t\tcontinue;\n\t\t\ta[i] += 2;\n\t\t\ta[j] += 1;\n\t\t\trek1(a, dobri, dub-1);\n\t\t\ta[i] -= 2;\n\t\t\ta[j] -= 1;\n\t\t}\n\t}\n}\n\nvoid rek2(vector<int>& a, set<vector<int>>& dobri, int dub) {\n\tif (dub == 0) {\n\t\tif (proveri(a))\n\t\t\tdobri.insert(a);\n\t\treturn;\n\t}\n\n\tint n = a.size();\n\tfor (int i=0; i<n; i++) {\n\t\ta[i] += 1;\n\t\trek2(a, dobri, dub-1);\n\t\ta[i] -= 1;\n\t}\n}\n\n\nvoid proveri_hipotezu(int dub) {\n\tint n = 2*dub;\n\tvector<int> a(n, 0);\n\tset<vector<int>> s1, s2;\n\trek1(a, s1, dub);\n\trek2(a, s2, 3*dub);\n\tcerr << (s1 == s2) << '\\n';\n\tcerr << s1.size() << '\\n';\n\tcerr << s2.size() << '\\n';\n\n\tfor (auto v : s2) {\n\t\tif (s1.count(v) == 0) {\n\t\t\tfor (int x : v)\n\t\t\t\tcerr << x << ' ';\n\t\t\tcerr << '\\n';\n\t\t}\n\t}\n}\n\n\n/*\nzbir = 3m-k\nmesta = k\n\n3m+k-1 k-1\n*/\n\n/*\nzbir m-k\nmesta = k\n*/\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\tcerr.tie(nullptr);\n\n\tf[0] = finv[0] = 1;\n\tfor (int i=1; i<4000005; i++) {\n\t\tf[i] = f[i-1] * i;\n\t\tfinv[i] = f[i].inv();\n\t}\n\n\tcin >> n >> m;\n\tmint sol;\n\tfor (int k=2; k<=min(m, n); k++) {\n\t\tsol += (bk(3*m-1, k-1) - bk(m-1, k-1) * k) * bk(n, k);\n\t}\n\tfor (int k=m+1; k<=min(2*m, n); k++) {\n\t\tsol += bk(3*m-1, k-1)* bk(n, k);\n\t}\n\tfor (int u=m+2; u<=min(n, 2*m); u+=2) {\n\t\tmint q = bk(n, u) * bk((3*m-u)/2 + n-1, n-1);\n\t\t// cerr << u << ' ' << (int)q << ' ' << (3*m-u)/2 << '\\n';\n\t\tsol -= q;\n\t}\n\n\tcout << (int)sol << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n/////////////         modの計算\n\nint mod = 998244353;\n\nlong long mod_adjust(long long a) {//\t余りをとる(0～mod-1に調整する)\n\tif (a > mod) {\n\t\treturn a % mod;\n\t}\n\tif (a < 0) {\n\t\ta *= -1;\n\t\ta %= mod;\n\t\treturn mod - a;\n\t}\n\treturn a;\n}\nint mod_add(int a, int b) {//\t足し算\n\tlong long k = mod_adjust((long long)a); k += mod_adjust((long long)b);\n\tk = mod_adjust(k);\n\treturn (int)k;\n}\nint mod_sub(int a, int b) {//\t引き算\n\treturn mod_add(a, -b);\n}\nint mod_multi(int a, int b) {//\t掛け算\n\tlong long k = mod_adjust((long long)a);\n\tk *= mod_adjust((long long)b);\n\tk = mod_adjust(k);\n\treturn (int)k;\n}\nint mod_inv(int a) {//\t逆元\n\tlong k = (int)mod_adjust((long long)a);\n\tif (k == 0) { return 0; }\n\tif (k == 1) { return 1; }\n\tlong long p = mod, q = k, m = 0, n = 1, r, c;\n\n\twhile (q > 1) {\n\t\tr = p % q;\n\t\tc = p / q;\n\t\tc = mod_adjust(m - n * c);\n\t\tp = q, m = n, q = r, n = c;\n\t}\n\treturn (int)mod_adjust(n);\n}\nint mod_div(int a, int b) {//\t割り算\n\treturn mod_multi(a, mod_inv(b));\n}\nint mod_pow(int x, int n) {//\t累乗(logNオーダーなので速い)\n\tx = (int)mod_adjust((long long)x);\n\tn = n % (mod - 1);\n\tif (n < 0) {\n\t\treturn mod_pow(mod_div(1, x), -n);\n\t}\n\tif (n == 0) {\n\t\treturn 1;\n\t}\n\tif (n == 1) {\n\t\treturn (int)mod_adjust((long long)x);\n\t}\n\tif (n % 2 == 0) {\n\t\tint k = mod_pow(x, n / 2);\n\t\treturn mod_multi(k, k);\n\t}\n\telse {\n\t\tint k = mod_pow(x, n / 2);\n\t\treturn mod_multi(mod_multi(k, k), x);\n\t}\n}\n\nint* factorial = NULL;\t\t\t//\t階乗\nint* factorial_inv = NULL;\t\t//\t階乗の逆元\n\n//\t階乗を事前に計算しておく関数。\n//\tNはmod_combination(n, r)で呼び出されうる最大の数。\nvoid calc_factorial(int N) {////////////////////////// 初めに必ず呼び出すこと！！！\n\tN = min(mod - 1, N);\n\tfactorial = new int[N + 1];\n\tfactorial_inv = new int[N + 1];\n\n\tfactorial[0] = 1;\n\tfactorial_inv[0] = 1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfactorial[i] = mod_multi(factorial[i - 1], i);\n\t\tfactorial_inv[i] = mod_inv(factorial[i]);\n\t}\n}\nint mod_combination(int n, int r) {//\tnCr\tを計算する\n\tif (n < 0 || r < 0 || r > n) { return 0; }\n\tif (n >= mod) { return 0; }\n\tif (r < 0) { return 0; }\n\treturn mod_multi(factorial[n], mod_multi(factorial_inv[n - r], factorial_inv[r]));\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tcalc_factorial(N + M * 2);//\tmod_combinationを使うための事前準備\n\n\tint size = M / 2;\n\tint* a = new int[size + 1];// N-2+i C i\n\tint* b = new int[size + 1];// N * sum(a_i)\n\tfor (int i = 0; i <= size; i++) {\n\t\ta[i] = mod_combination(N + i - 2, i);\n\t}\n\t\n\tfor (int i = 0; i <= size; i++) {\n\t\tif (i == 0) {\n\t\t\tb[i] = N;\n\t\t}\n\t\telse {\n\t\t\tb[i] = mod_add(b[i - 1], mod_multi(a[i], N));\n\t\t}\n\t}\n\n\tint sum = 0;\n\tfor (int m = 0; m * 2 <= M; m++) {\n\t\tint s = mod_combination(N, M - m * 2);// 1の配分\n\t\tint t = mod_combination(N + M + m - 1, N - 1);// M+m個の\"2\"を配分\n\t\tt = mod_sub(t, b[m]);// そこから、\"2\"の個数の最大がM個以上の場合を除く\n\t\tt = mod_add(t, mod_multi(N - M + m*2, a[m]));// でも、1が入っていないところには入れられるのでその分を増やす\n\t\ts = mod_multi(s, t);\n\t\tsum = mod_add(sum, s);\n\t}\n\n\tcout << sum << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; std::swap(a, m);\n    u -= t * v; std::swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\ntemplate <typename T>\nclass modular {\n  private:\n    int value;\n  public:\n    constexpr modular() = default;\n    constexpr modular(const modular&) = default;\n    constexpr modular(modular&&) = default;\n    modular& operator=(const modular&) = default;\n    modular& operator=(modular&&) = default;\n\n    template <typename U>\n    modular (const U& x) {value = normalize(x);}\n\n    template <typename U>\n    static auto normalize(const U& x) {\n      int v = static_cast<int>(-mod() <= x && x < mod() ? x : x % mod());\n      if (v < 0) v += mod();\n      return v;\n    }\n\n    auto const& operator()() const { return value; }\n    template <typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static auto mod() { return T::value; }\n\n    auto& operator+=(const modular& other) {\n      if ((value += other.value) >= mod()) value -= mod();\n      return *this;\n    }\n    auto& operator-=(const modular& other) {\n      if ((value -= other.value) < 0) value += mod();\n      return *this;\n    }\n    template <typename U>\n    auto& operator+=(const U& other) {return *this += modular(other); }\n    template <typename U>\n    auto& operator-=(const U& other) {return *this -= modular(other); }\n    auto operator-() const { return modular(-value); }\n    auto& operator++() {return *this += 1;}\n    auto& operator--() {return *this -= 1;}\n    auto\toperator++(int) {modular result(*this); operator++(); return result;}\n    auto\toperator--(int) {modular result(*this); operator--(); return result;}\n  \n    template <typename U = T>\n    auto& operator*=(const modular& rhs) {\n      value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n      return *this;\n    }\n    auto& operator/=(const modular& other) {\n      return *this *= modular(inverse(other.value, mod()));\n    }\n};\ntemplate <typename T> struct is_modular : std::false_type {};\ntemplate <typename T> struct is_modular <modular<T>> : std::true_type{};\ntemplate <typename T> constexpr bool is_modular_v = is_modular<T>::value;\n\ntemplate <typename T> bool operator==(const modular<T>& lhs, const modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const modular<T>& lhs, U rhs) { return lhs == modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const modular<T>& rhs) { return modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const modular<T>& lhs, const modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> modular<T> operator+(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> modular<T> operator+(const modular<T>& lhs, U rhs) { return modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> modular<T> operator+(U lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }\n\ntemplate <typename T> modular<T> operator-(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> modular<T> operator-(const modular<T>& lhs, U rhs) { return modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> modular<T> operator-(U lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> modular<T> operator*(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> modular<T> operator*(const modular<T>& lhs, U rhs) { return modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> modular<T> operator*(U lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> modular<T> operator/(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> modular<T> operator/(const modular<T>& lhs, U rhs) { return modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> modular<T> operator/(U lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nmodular<T> pow (const modular<T>& a, U b) {\n  assert(b >= 0);\n  modular<T> x = a, ret = 1;\n  for (; b > 0; b /= 2) {\n    if (b % 2 == 1) ret *= x;\n    x *= x;\n  }\n  return ret;\n}\n\ntemplate <typename T>\nstd::string to_string(const modular<T>& a) {\n  return std::to_string(a());\n}\ntemplate <typename T>\nauto operator<<(std::ostream& os, const T& a)\n  -> std::enable_if_t<is_modular_v<T>, std::ostream&>{\n    return os << a();\n  }\ntemplate <typename T>\nauto operator>>(std::istream& is, T& a)\n  -> std::enable_if_t<is_modular_v<T>, std::istream&> {\n  long long x; is >> x;\n  a = T(x);\n  return is;\n}\n\nconstexpr int md = 1'000'000'007;\nusing mint = modular<std::integral_constant<std::decay_t<decltype(md)>, md>>;\n\n#define LOCAL\nusing std::to_string;\nauto to_string(std::string s) -> std::string {\n  return '\"' + s + '\"';\n}\nauto to_string(char c) -> std::string {\n  return \"'\" + std::string{c} + \"'\";\n}\nauto to_string(const char* s) -> std::string {\n  return to_string((std::string) s);\n}\nauto to_string(bool b) -> std::string {\n  return (b ? \"true\" : \"false\");\n}\ntemplate <typename T, typename U>\nauto to_string(std::pair<T, U> p) -> std::string {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <size_t N>\nauto to_string(std::bitset<N> bs) -> std::string {\n  std::string res{};\n  for (size_t i = 0; i < N; i++)\n    res.insert(res.begin(), bs.test(i) ? '1' : '0');\n  return res;\n}\ntemplate <typename T>\nauto to_string(T v) -> std::string {\n  bool flg = false;\n  std::string res = \"{\";\n  for (auto const&x : v) {\n    if (flg) res += \", \";\n    else flg = true;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\nvoid debug_out() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  std::cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nclass factorials {\n    std::vector<mint> fact, finv;\n  public:\n    factorials(int n) : fact(n), finv(n) {\n      fact.at(0) = 1;\n      for (int i = 1; i < n; i++) fact.at(i) = fact.at(i - 1) * mint(i);\n      finv.at(n - 1) = mint(1) / fact.at(n - 1);\n      for (int i = n - 2; i >= 0; i--) finv.at(i) = finv.at(i + 1) * mint(i + 1);\n    }\n    // Returns the factorial.\n    template <typename T>\n    auto const& operator()(T i) const {return fact.at(i);}\n    // Returns the inverse of the factorial.\n    template <typename T>\n    auto const& inv(T i) const {return finv.at(i);}\n    // Returns the binominal coefficient.\n    template <typename T>\n    auto binom(T i, T j) const {\n      assert(0 <= i);\n      if (j < 0 ||i < j) return mint(0);\n      return fact.at(i) * finv.at(j) * finv.at(i - j);\n    }\n    // foo.\n    template <typename T>\n    auto part(T i, T j) const {\n      return binom(i + j - 1, j - 1);\n    }\n};\n\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  auto fact = factorials(3000000);\n  int N, M; std::cin >> N >> M;\n  const int cum_max = M;\n  std::vector<mint> cum(cum_max + 2, 0);\n  for (int i = 0; i <= cum_max; i++) {\n    cum.at(i + 1) = cum.at(i)\n      + fact.part(i, N - 1);\n  }\n  mint ans = 0;\n  for (int Q = M; 2 * Q <= 3 * M; Q++) {\n    auto x =\n      (fact.part(Q, N) - cum.at(Q - M + 1) * N) *\n      fact.binom(N, 3 * M - 2 * Q);\n    auto y =\n      fact.part(Q - M, N - 1) * N *\n      fact.binom(N - 1, 3 * M - 2 * Q);\n    ans += x + y;\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <math.h> \n#include <iomanip>\nusing namespace std;\n#define M_PI 3.14159265358979323846  /* pi */\n#define forr(i,a,b,c) for(int i=a;i<b;i+=c)\n#define forrb(i,a,b,c) for(int i=a;i>b;i-=c)\n#define fori(i,n) forr(i,0,n,1)\n#define forib(i,n) forrb(i,n-1,-1,1)\n#define forn(i,n) forr(i,1,n,1)\n#define fornb(i,n) forrb(i,n-1,0,1)\n#define fort(i,m,n) forr(i,m,n,1)\n#define fortb(i,m,n) forrb(i,n-1,m-1,1)\n#define forin(i,arr) fori(i,arr.size())\n#define forinb(i,arr) forib(i,arr.size())\n#define forrl(i,a,b,c) for(lol i=a;i<b;i+=c)\n#define forrbl(i,a,b,c) for(lol i=a;i>b;i-=c)\n#define foril(i,n) forrl(i,0,n,1)\n#define foribl(i,n) forrbl(i,n-1,-1,1)\n#define fornl(i,n) forrl(i,1,n,1)\n#define fornbl(i,n) forrbl(i,n-1,0,1)\n#define fortl(i,m,n) forrl(i,m,n,1)\n#define fortbl(i,m,n) forrbl(i,n-1,m-1,1)\n#define forinl(i,arr) foril(i,arr.size())\n#define forinbl(i,arr) foribl(i,arr.size())\n#define into(i) cin >> i;\n#define def(i) lol i; into(i)\n#define deft(t,i) t i; into(i)\n#define defl(i) lol i; into(i)\n#define defs(i) string i; into(i)\n#define defn def(n)\n#define defp def(p)\n#define defm def(m)\n#define defk def(k)\n#define defa def(a)\n#define defb def(b)\n#define defc def(c)\n#define defd def(d)\n#define vec(a) vector<a>\n#define co cout <<\n#define out(a) cout << a <<' ';\n#define el << endl;\n#define ell << '\\n';\n#define outv(arr,n) fori(i,n){out(arr[i])} co \"\" el\n#define cas(p) co \"Case #\" << p+1 <<\": \";\n#define ex return 0; \n#define qii queue<int>\n#define sti stack<int>\n#define dei deque<int>\n#define con continue;\n#define br break;\n#define maxi 998244353 \n#define lmaxi 100000000000000007\n#define mod %maxi\n#define wne(arr) while(!arr.empty())\n#define all(arr) arr.begin(),arr.end()\ntypedef vector<int> veci;\ntypedef long long lol;\ntypedef unsigned long long ulol;\ntypedef vector<lol> vecl;\n#define table(name,n,m) vector<veci> name(n,veci (m));\n#define tablel(name,n,m) vector<vecl> name(n,vecl (m));\ntypedef pair<lol, lol> point;\ntypedef pair<point, point> poin;\ntypedef pair<lol, point> poing;\ntypedef pair<point, lol> poinf;\ntypedef vector<point> vecp;\n#define poi(x,y) make_pair(x,y)\n#define sizer (lol) 1e9\n#define digss (lol) 9\nstruct BigNum {\n\tvecl value;\n\tvoid set(lol x) { value = *(new vecl); value.push_back(x); }\n\tvoid duplicate(BigNum other) { value = other.value; }\n\tvoid add(BigNum other) {\n\t\tvecl o = other.value;\n\t\tif (o.size() > value.size()) {\n\t\t\tvecl t = value;\n\t\t\tvalue = o;\n\t\t\to = t;\n\t\t}\n\t\tforin(i, o) {\n\t\t\tvalue[i] += o[i];\n\t\t\tif (i < value.size() - 1 && value[i] >= sizer) {\n\t\t\t\tvalue[i + 1] += value[i] / sizer;\n\t\t\t\tvalue[i] = value[i] % sizer;\n\t\t\t}\n\t\t}\n\t\tif (value.back() >= sizer) {\n\t\t\tvalue.push_back(value.back() / sizer);\n\t\t\tvalue[value.size() - 2] = value[value.size() - 2] % sizer;\n\t\t}\n\t}\n\tvoid mul(lol mul) {\n\t\tforin(i, value) {\n\t\t\tvalue[i] *= mul;\n\t\t}\n\t\tfori(i, value.size() - 1) {\n\t\t\tif (value[i] >= sizer) {\n\t\t\t\tvalue[i + 1] += value[i] / sizer;\n\t\t\t\tvalue[i] = value[i] % sizer;\n\t\t\t}\n\t\t}\n\t\tif (value.back() >= sizer) {\n\t\t\tvalue.push_back(value.back() / sizer);\n\t\t\tvalue[value.size() - 2] = value[value.size() - 2] % sizer;\n\t\t}\n\t}\n\tlong double div(BigNum other1, BigNum other2) {\n\t\tint s = value.size();\n\t\tlong double current = value.back();\n\t\tif (s >= 2) {\n\t\t\tcurrent += ((long double)value[s - 2]) / sizer;\n\t\t}\n\t\tif (s >= 3) {\n\t\t\tcurrent += ((long double)value[s - 3]) / (sizer * sizer);\n\t\t}\n\t\tint s1 = other1.value.size();\n\t\tint s2 = other2.value.size();\n\t\tlong double other = 0;\n\t\tif (s1 + s2 - 1 == s) {\n\t\t\tother += other1.value.back() * other2.value.back();\n\t\t\tif (s1 >= 2) {\n\t\t\t\tother += ((long double)other1.value[s1 - 2] * other2.value.back()) / sizer;\n\t\t\t}\n\t\t\tif (s2 >= 2) {\n\t\t\t\tother += ((long double)other2.value[s2 - 2] * other1.value.back()) / sizer;\n\t\t\t}\n\t\t\tif (s1 >= 3) {\n\t\t\t\tother += ((long double)other1.value[s1 - 3] * other2.value.back()) / (sizer * sizer);\n\t\t\t}\n\t\t\tif (s2 >= 3) {\n\t\t\t\tother += ((long double)other2.value[s2 - 3] * other1.value.back()) / (sizer * sizer);\n\t\t\t}\n\t\t}\n\t\tif (s1 + s2 - 1 == s - 1) {\n\t\t\tother += other1.value.back() * other2.value.back();\n\t\t\tif (s1 >= 2) {\n\t\t\t\tother += ((long double)other1.value[s1 - 2] * other2.value.back()) / sizer;\n\t\t\t}\n\t\t\tif (s2 >= 2) {\n\t\t\t\tother += ((long double)other2.value[s2 - 2] * other1.value.back()) / sizer;\n\t\t\t}\n\t\t\tother /= sizer;\n\t\t}\n\t\tif (s1 + s2 - 1 == s - 2) {\n\t\t\tother += other1.value.back() * other2.value.back();\n\t\t\tother /= sizer * sizer;\n\t\t}\n\t\treturn other / current;\n\t}\n\tstring stringify() {\n\t\tstring out = to_string(value.back());\n\t\tforib(i, value.size() - 1) {\n\t\t\tstring cur = to_string(value[i] + sizer);\n\t\t\tout += cur.substr(1);\n\t\t}\n\t\treturn out;\n\t}\n};\nlol gcd(lol a, lol b) {\n\tif (b == 0) {\n\t\treturn a;\n\t}\n\treturn gcd(b, a % b);\n}\nlol triangle(lol x) {\n\treturn (((lol)(x + 1)) * (x)) / 2;\n}\nlol modInverse(lol a)\n{\n\tlol m = maxi;\n\tlol y = 0, x = 1;\n\twhile (a > 1)\n\t{\n\t\tlol q = a / m;\n\t\tlol t = m;\n\t\tm = a % m, a = t;\n\t\tt = y;\n\t\ty = x - q * y;\n\t\tx = t;\n\t}\n\tif (x < 0) {\n\t\tx += maxi;\n\t}\n\treturn x;\n}\nlol modInverse(lol a,lol b)\n{\n\tlol m = b;\n\tlol y = 0, x = 1;\n\twhile (a > 1)\n\t{\n\t\tlol q = a / m;\n\t\tlol t = m;\n\t\tm = a % m, a = t;\n\t\tt = y;\n\t\ty = x - q * y;\n\t\tx = t;\n\t}\n\tif (x < 0) {\n\t\tx += b;\n\t}\n\treturn x;\n}\nlol pow(lol a, lol b) {\n\tif (b == 0) {\n\t\treturn 1;\n\t}\n\tif (b % 2 == 0) {\n\t\treturn pow((a * a)mod, b / 2)mod;\n\t}\n\treturn (a * pow((a * a)mod, b / 2))mod;\n}\nvecl dev(vecp divisors) {\n\tif (divisors.size() == 0) {\n\t\tvecl cur;\n\t\tcur.push_back(1);\n\t\treturn cur;\n\t}\n\tlol x = divisors.back().first;\n\tlol n = divisors.back().second;\n\tdivisors.pop_back();\n\tvecl ans = dev(divisors);\n\tvecl cur;\n\tlol xi = 1;\n\tfori(i, n + 1) {\n\t\tforin(j, ans) {\n\t\t\tcur.push_back(ans[j] * xi);\n\t\t}\n\t\txi *= x;\n\t}\n\treturn cur;\n}\nvoid add(veci& x, veci& y) {\n\tforin(i, x) {\n\t\tx[i] += y[i];\n\t}\n}\nstruct pt\n{\n\tlol x, y;\n\n\tlol d() const // squared length\n\t{\n\t\treturn x * x + y * y;\n\t}\n};\ntypedef vector<pt> vecpp;\n#define intopt(a) into(a.x) into(a.y)\n\n#define defpt(a) pt a;intopt(a)\ninline pt operator-(const pt& a) { return { -a.x, -a.y }; }\ninline pt operator+(const pt& a, const pt& b) { return { a.x + b.x, a.y + b.y }; }\ninline pt operator-(const pt& a, const pt& b) { return { a.x - b.x, a.y - b.y }; }\ninline bool operator<(const pt& a, const pt& b) { return { a.x < b.x || (a.x == b.x && a.y < b.y) }; }\ninline lol operator*(const pt& a, const pt& b) { return a.x* b.y - a.y * b.x; } // cross product\ninline lol operator/(const pt& a, const pt& b) { return a.x* b.x + a.y * b.y; } // dot product\ninline bool operator==(const pt& a, const pt& b) { return a.x == b.x && a.y == b.y; } // equal\ninline bool operator!=(const pt& a, const pt& b) { return a.x != b.x || a.y != b.y; } // not equal\n\npt o;\nbool comp(pt a, pt b) {\n\treturn (a - o) * (b - o) < 0;\n}\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tdefn defm\n\t\tvecl pow(3*m+n + 3);\n\tforin(i, pow) {\n\t\tif(i==0){\n\t\t\tpow[i] = 1;\n\t\t\tcon\n\t\t}\n\t\tpow[i] = (pow[i - 1] * i)mod;\n\t}\n\tlol ans = 0;\n\tfori(i, n+1) {\n\t\tif (i % 2 != m % 2 || i>m) {\n\t\t\tcon\n\t\t}\n\t\tint k = (m * 3 - i)/2;\n\t\tlol choose=(pow[k+n-1]*modInverse(pow[k]))mod;\n\t\tchoose = (choose * modInverse(pow[n - 1]))mod;\n\t\tlol mul = (pow[n] * modInverse(pow[i]))mod;\n\t\tmul = (mul * modInverse(pow[n-i]))mod;\n\t\tans = (ans + choose * mul);\n\t\tlol choose2= (pow[k-m + n - 1] * modInverse(pow[k-m]))mod;\n\t\tchoose2 = (choose2 * modInverse(pow[n - 1]))mod;\n\t\tchoose2 = (choose2 *(i))mod;\n\t\tans = (ans - choose2 * mul)mod;\n\t\tif (k - m - 1 >= 0) {\n\t\t\tchoose2 = (pow[k - m - 2 + n] * modInverse(pow[k - m - 1]))mod;\n\t\t\tchoose2 = (choose2 * modInverse(pow[n - 1]))mod;\n\t\t\tchoose2 = (choose2 * (n - i))mod;\n\t\t\tans = (ans - choose2 * mul)mod;\n\t\t}\n\t}\n\tans = (maxi + ans)mod;\n\tco ans el\n\tex\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\n#define bit(n) (1LL<<(n))\n#define INT(n) int n; cin >> n;\n#define LL(n) ll n; cin >> n;\n#define DOUBLE(n) double n; cin >> n;\nusing namespace std;\n\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 998244353;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\n// solve\ntemplate <typename T>\nT power(T a, T n, T mod) {\n  T res = 1;\n  T tmp = n;\n  T curr = a;\n  while(tmp){\n    if(tmp % 2 == 1){\n      res = (T)(res * curr % mod);\n    }\n    curr = (T)(curr * curr % mod);\n    tmp >>= 1;\n  }\n\n  return res;\n}\n\ntemplate<typename T>\nT gcd(T a, T b) {\n  if(a > b)return gcd(b, a);\n  if(a == 0)return b;\n  return gcd(b % a, a);\n}\n\ntemplate<typename T>\nT extgcd(T a, T b, T &x, T &y){ \n  T d = a;\n  if(b != 0){\n    d = extgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  }else{\n    x = 1, y = 0;\n  }\n  return d;\n}\n\ntemplate <typename T>\nT modinv(T a, T m){\n  long long x = 0, y = 0;\n  extgcd<long long>(a, m, x, y);\n  x %= m;\n  if(x < 0)x += m;\n  return x;\n}\nstruct Factorial{\n  int n;\n  const int MOD = 998244353;\n  vector<long long> fac;\n  vector<long long> inv_;\n  Factorial(int n): n(n){\n    fac.resize(n + 1);\n    inv_.resize(n + 1);\n    calc_factorial();\n    calc_inv();\n  }\n  void calc_factorial(){\n    fac[0] = 1;\n    for(int i = 1; i <= n; i++){\n      fac[i] = i * fac[i-1] % MOD;\n    }\n  }\n  void calc_inv(){\n    inv_[n] = power<long long>(fac[n], MOD - 2, MOD);\n    for(int i = n - 1; i >= 0; i--){\n      inv_[i] = (i + 1) * inv_[i+1] % MOD;\n    }\n  }\n  long long& operator[](size_t i){\n    if(i < 0 || i > n){\n      cerr << \"list index out of range\" << endl;\n      abort();\n    }\n    return fac[i];\n  }\n  long long inv(size_t i){\n    if(i < 0 || i > n){\n      cerr << \"list index out of range\" << endl;\n      abort();\n    }\n    return inv_[i];\n  }\n  long long comb(int n, int k){\n    if(n < 0 || k < 0)return 0;\n    if(n < k)return 0;\n    long long res = fac[n];\n    res = res * inv_[n-k] % MOD;\n    res = res * inv_[k] % MOD;\n    return res;\n  }\n  long long perm(int n, int k){\n    if(n < k)return 0;\n    long long res = fac[n];\n    res = res * inv_[n-k] % MOD;\n    return res;\n  }\n  long long h(int n, int k){\n    if(n == 0 && k == 0)return 1;\n    return comb(n + k - 1, k);\n  }\n};\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(20);\n  INT(n); INT(m);\n  Factorial fac(3500010);\n  ll res = fac.h(n, 3 * m);\n  ll tmp = fac.h(n, m - 1) * n % mod;\n  res = (res - tmp) % mod;\n  if(res < 0)res += mod;\n  for(int i = m + 1; i <= n; i++){\n    int rem = 3 * m - i;\n    if(rem % 2 == 1)continue;\n    ll t = fac.comb(n, i);\n    t = t * fac.h(n, rem / 2) % mod;\n    res = (res - t) % mod;\n    if(res < 0)res += mod;\n  }\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nusing namespace std;\n\nconst int mod = 998244353, maxn = 1*1000*1000+10, maxm = 500*1000+10;\nll f[maxn * 2], rf[maxn * 2], ans, tmp;\nint n, m;\n\nll power(int a, int b, int m)\n{\n\tif (b == 0)\n\t\treturn 1 % m;\n\tll c = power(a, b / 2, m);\n\tif (b & 1)\n\t\treturn (((c * c) % m) * a) % m;\n\treturn (c * c) % m;\n}\n\nll c(int a, int b)\n{\n\tif (a < b || a < 0 || b < 0)\n\t\treturn 0;\n\treturn (((f[a] * rf[b]) % mod) * rf[a - b]) % mod;\n}\n\nint main()\n{\n\tcin >> n >> m;\n\tf[0] = rf[0] = 1;\n\tfor (int i = 1; i < maxn * 2; i++)\n\t{\n\t\tf[i] = (f[i - 1] * i) % mod;\n\t\trf[i] = power(f[i], mod - 2, mod);\n\t}\n\tfor (int i = 0; i <= min(n, m); i++)\n\t{\n\t\tif ((m * 3 - i) & 1)\n\t\t\tcontinue;\n\t\ttmp = c(n, i);\n\t\tans += tmp * c(n - 1 + (m * 3 - i) / 2, n - 1);\n\t\tans %= mod;\n\t\ttmp *= n;\n\t\ttmp %= mod;\n\t\ttmp *= c(n - 2 + (m - i) / 2, n - 1);\n\t\ttmp %= mod;\n\t\tans += mod - tmp;\n\t\tans %= mod;\n\t\ttmp = c(n - 1, i - 1) * n;\n\t\ttmp %= mod;\n\t\ttmp *= c(n - 2 + (m - i) / 2, n - 2);\n\t\ttmp %= mod;\n\t\tans += mod - tmp;\n\t\tans %= mod;\n\t}\n\tcout << ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef long long int ll;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define SP << \" \" <<\n\nconst LL MAX = 4010000;\nconst LL MOD = 998244353;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (LL i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nlong long COM(LL n, LL k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nLL mod = 998244353;\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  LL N, M;\n  cin >> N >> M;\n  \n  //3M回 +1\n  //N要素で2M+1以上のがあったらダメ\n  //N-1要素で(M-1回以内+1)の個数*N\n  //単にN要素でM-1回+1\n  \n  //ある要素が2M-1\n  //残りがM+1回のどこかで+2がされる\n  //逆に、+1しかない場合を除け\n\n  //+2 がM回存在しないものを除く\n  //i=0~M-1\n  //N個から適当にi回+2\n  //N個から3M-2*i要素を+1\n\n  COMinit();\n\n  LL ans = COM(3 * M + N - 1, 3 * M) - COM(M - 1 + N - 1, M - 1) * N;\n  LL sum = 0;\n  FOR(i, 0, M)\n  {\n    //A=\n    sum += (COM(i+N-1, N-1) * COM(N,3*M-2*i))%mod;\n    sum %= mod;\n  }\n  ans -= sum ;\n  ans = (ans%mod + mod) % mod;\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n23280701537353\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp> // Common file\n#include <ext/pb_ds/tree_policy.hpp>\n#define sz(v)   ((int)(v).size())\n#define  all(v)    ((v).begin()),((v).end())\n#define  allr(v)    ((v).rbegin()),((v).rend())\n#define   pb         push_back\n#define   mp         make_pair\n#define   mt         make_tuple\n//#define   Y            imag()\n//#define   X            real()\n#define    clr(v,d)      memset( v, d ,sizeof(v))\n#define   angle(n)      atan2((n.imag()),(n.real()))\n#define   vec(a,b)       ((b)-(a))\n//#define   length(a)      hypot( (a.imag()),(a.real()) )\n#define   normalize(a)      (a)/(length(a))\n//#define    dp(a,b)          (((conj(a))*(b)).real())\n//#define    cp(a,b)          (((conj(a))*(b)).imag())\n#define    lengthsqrt(a)       dp(a,a)\n#define    rotate0( a,ang)    ((a)*exp( point(0,ang) ))\n#define    rotateA(about,p,ang)   (rotate0(vec(about,p),ang)+about)\n#define    reflection0(m,v)         (conj((v)/(m))*(m))\n#define     reflectionA(m,v,p0)     (conj( (vec(p0,v))/(vec(p0,m)) ) * (vec(p0,m)) ) + p0\n//#define     same(p1,p2)               ( dp(  vec(p1,p2),vec(p1,p2)) < eps )\n#define     PT                    complex<double>\n#define outfile freopen(\"out.out\", \"w\", stdout);\n#define infile  freopen(\"in.in\", \"r\", stdin);\n#define PI acos(-1)\ntypedef  long long     ll ;\ntypedef  unsigned long long ull;\nconst double eps= (1e-9);\nusing namespace std;\nusing namespace __gnu_pbds;\nint dcmp(double a,double b){   return fabs(a-b)<=eps ? 0: (a>b)? 1:-1  ;}\nint getBit(int num, int idx) {return ((num >> idx) & 1) == 1;}\nll setBit1(ll num, int idx) {return num | (1ll<<idx);}\nll setBit0(ll num, int idx) {return num & ~(1ll<<idx);}\nll flipBit(int num, int idx) {return num ^ (1<<idx);}\nvoid FS(){ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);}\nll n,m;\nll mod=998244353;\nll fact[3000009],Ifact[3000009];\nll power(ll b,ll p)\n{\n    if(p==0)\n        return 1;\n    if(p&1)\n        return (b%mod*power(((b%mod)*(b%mod))%mod,p/2))%mod;\n    else\n        return (power(((b%mod)*(b%mod))%mod,p/2))%mod;\n}\nll choose(ll t,ll r)\n{\n    return ((fact[t]*Ifact[t-r])%mod*Ifact[r])%mod;\n}\nll calc(ll no,ll no2)\n{\n\n    return choose(no+no2-1,no2-1);\n}\nint main()\n{\n    cin>>n>>m;\n    fact[0]=1;\n    for(int i=1;i<=3000000;i++)\n        fact[i]=(fact[i-1]*i)%mod;\n    Ifact[3000000]=power(fact[3000000],mod-2);\n    for(ll i=3000000-1;i>=0;i--)\n    {\n        Ifact[i]=(Ifact[i+1]*(i+1))%mod;\n    }\n    int mi=min(n,m);\n    ll ans=0;\n    for(int i=m%2;i<=mi;i+=2)\n    {\n       ans=(ans+(choose(n,i)*calc((3*m-i)/2,n)%mod))%mod;\n    }\n    ll res=0;\n    for(int i=2*m+1;i<=3*m;i++)\n    {\n        res=(res+calc(3*m-i,n-1))%mod;\n    }\n    res=(res*n)%mod;\n    ans=((ans-res)%mod+mod)%mod;\n    cout<<ans<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <assert.h>\nusing namespace std;\n\n#define N 5000001\n#define mod 998244353\n#define ll long long\n\nint fac[N], invFac[N];\nint mypow(int x, int c) {\n\tint ret = 1;\n\twhile (c > 0) {\n\t\tif (c & 1) {\n\t\t\tret = (ll)ret*x%mod;\n\t\t}\n\t\tc /= 2;\n\t\tx = (ll)x*x%mod;\n\t}\n\treturn ret;\n}\nint combi(int n, int c) {\n\tint ret = (ll)fac[n] * invFac[c] % mod;\n\tret = (ll)ret*invFac[n - c] % mod;\n\n\treturn ret;\n}\nint add(int x, int y) {\n\tint ret = x + y;\n\tif (ret < 0) {\n\t\tret += mod;\n\t}\n\tif (ret >= mod) {\n\t\tret -= mod;\n\t}\n\treturn ret;\n}\nint mul(int x, int y) {\n\treturn (ll)x*y%mod;\n}\nvoid solve() {\n\tint n, m; scanf(\"%d %d\", &n, &m);\n\tfac[0] = 1; invFac[0] = 1;\n\tfor (int i = 1; i <N; ++i) {\n\t\tfac[i] = (ll)fac[i - 1] * i%mod;\n\t\tinvFac[i] = mypow(fac[i], mod - 2);\n\t}\n\tint ret = 0;\n\tint maxOdd = min(n, m);\n\tfor (int odd = 0; odd <= maxOdd; ++odd) {\n\t\tint sum = 3 * m - odd;\n\t\tif (sum % 2 == 0) {\n\t\t\tsum /= 2;\n\t\t\tint tmp = combi(sum + n - 1, n - 1);\n\t\t\ttmp = mul(tmp, combi(n, odd));\n\t\t\tret = add(ret, tmp);\n\t\t}\n\t}\n\tfor (int maxSum = 2 * m + 1; maxSum <= 3 * m; ++maxSum) {\n\t\tint rem = 3 * m - maxSum;\n\t\tint tmp = combi(rem + n - 2, n - 2);\n\t\ttmp = (ll)tmp*n%mod;\n\t\tret = add(ret, -tmp);\n\t}\n\tprintf(\"%d\\n\", ret);\n}\nint main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <set>\n#include <map>\ntypedef long long ll;\nusing namespace std;\nconst ll MOD = 998244353LL;\n\nclass Combination {\n    int N;\n    vector <ll> fac, inv, fiv;\n\n    void init() {\n        fac[0] = inv[0] = fiv[0] = 1;\n        fac[1] = inv[1] = fiv[1] = 1;\n        for (ll i = 2; i < N; i++) {\n            fac[i] = fac[i - 1] * i % MOD; // n!\n            inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD; // n^-1\n            fiv[i] = fiv[i - 1] * inv[i] % MOD; // (n!)^-1\n        }\n    }\n\npublic:\n    Combination(int N) : N(N), fac(N), inv(N), fiv(N) { init(); }\n\n    ll C(ll n, ll k) {\n        if (k < 0 || n < k) return 0;\n        return fac[n] * fiv[k] % MOD * fiv[n - k] % MOD;\n    }\n\n    ll P(ll n, ll k) {\n        if (k < 0 || n < k) return 0;\n        return fac[n] * fiv[n - k] % MOD;\n    }\n\n    ll H(ll n, ll k) {\n        if (n == 0 && k == 0) return 1;\n        return C(n + k - 1, k);\n    }\n};\n\nint main() {\n    cin.sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    ll n, m;\n    cin >> n >> m;\n\n    Combination com(n + 3 * m);\n\n    ll ans = com.H(n, 3 * m);\n    for (ll i = 0; i < m; i++) {\n        ans -= n * com.H(n - 1, i) % MOD;\n        if (ans < 0) ans += MOD;\n    }\n\n    for (int i = m + 1; i <= n && i <= 3 * m; i++) {\n        // 1の数がちょうどi個のものを除く\n        if (3 * m - i == 1) continue;\n        ll j = (3 * m - i) / 2;\n        ans -= com.C(n, i) * com.H(n-i, j) % MOD;\n        if (ans < 0) ans += MOD;\n    }\n\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#define ordered_set tree<ll, null_type,less<ll>, rb_tree_tag,tree_order_statistics_node_update> \n#define ll long long\n\n#ifdef sarthak\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n    cout << name << \" : \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n    const char* comma = strchr(names + 1, ',');cout.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\nint begtime = clock();\n#else\n#define trace(...)\n#endif\n\n#ifndef sarthak\n    #pragma GCC optimize(\"Ofast\")\n    #pragma GCC optimize(\"unroll-loops\")\n    // #pragma GCC target (\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#endif\n\n#define foreach(it,ar) for (auto it = ar.begin(); it != ar.end(); it++)\n#define fort(i,v) for(auto i:v)\n#define fr(i,a,b) for (ll i = (a), _b = (b); i <= _b; i++)\n#define frr(i,a,b) for (ll i = (a), _b = (b); i >= _b; i--)\n#define rep(i,n) for (ll i = 0, _n = (n); i < _n; i++)\n#define repr(i,n) for (ll i = n - 1; i >= 0; i--)\n#define fill(ar,val) rep(i,sizeof(ar)/sizeof(ll)) ar[i]=val\n#define fill2(ar,val) rep(i,sizeof(ar)/sizeof(ar[0])) rep(j,sizeof(ar[0])/sizeof(ll)) ar[i][j]=val\n#define fill0(ar) memset(ar,0,sizeof(ar))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n\n#define ld long double\n#define pb push_back\n#define mp make_pair\n#define ff first\n#define ss second\n#define sd(x) scanf(\"%d\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define sd2(x,y) scanf(\"%d %d\",&x,&y)\n#define slld2(x,y) scanf(\"%lld %lld\",&x,&y)\n#define pd(x) printf(\"%d\\n\",x)\n#define plld(x) printf(\"%lld\\n\",x)\n#define pd2(x,y) printf(\"%d %d\\n\",x,y)\n#define plld2(x,y) printf(\"%lld %lld\\n\",x,y)\n#define all(ar) ar.begin(), ar.end()\n#define endl '\\n'\n#define sz(x) (int)x.size()\n#define len(x) (int)x.length()\n\ntypedef pair<ll, ll> ii;\ntypedef pair<ii, ll> iii;\ntypedef vector<ii> vii;\ntypedef vector<ll> vi;\n\n#define INF 1000000000000000000\n#define PI 3.14159265358979323846L\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rngb(chrono::steady_clock::now().time_since_epoch().count()); // can give negative values too\n\nconst ll N = 4000000;\nll mod = 998244353;\n\nll fact[N];\n\nvoid init()\n{\n    fact[0] = 1;\n    fact[1] = 1;\n\n    fr(i,2,N-1)\n    {\n        fact[i] = fact[i-1]*i;\n        fact[i] %= mod;\n    }\n}\n\nll gcdExtended(ll a, ll b, ll *x, ll *y) \n{ \n    if (a == 0) \n    { \n        *x = 0, *y = 1; \n        return b; \n    } \n  \n    ll x1, y1; \n    ll gcd = gcdExtended(b%a, a, &x1, &y1); \n  \n    *x = y1 - (b/a) * x1; \n    *y = x1; \n  \n    return gcd; \n} \n\nll modInverse(ll a, ll m) \n{ \n    ll x, y; \n    ll g = gcdExtended(a, m, &x, &y); \n    ll res = (x%m + m) % m; \n    return res; \n}\n\nll nck(ll n, ll k)\n{\n    if(k>n)\n        return 0;\n    ll ans = fact[n];\n    ll ans2 = fact[k];\n    ans2 *= fact[n-k];\n    ans2%= mod;\n    ans2 = modInverse(ans2,mod);\n    ans = ans*ans2;\n    ans%=mod;\n    return ans;\n}\n\nvoid solve()\n{\n    ll n,m;\n    cin >> n >> m;\n\n    init();\n\n    ll ans = nck(3*m+n-1,n-1);\n    ll sum = 0;\n    \n    fr(i,1,m)\n    {\n        ll xx = nck(m-i+n-2,n-2);\n        sum = sum + xx;\n        sum %= mod;\n    }\n\n    sum = sum * n;\n    sum %= mod;\n\n    ans = ans - sum;\n    if(ans<0)\n        ans += mod;\n\n    ll yy = nck(n,3*m);\n    ans = ans - yy;\n    if(ans<0)\n        ans += mod;\n\n    fr(i,1,m-1)\n    {\n        ll yy2 = nck(n+i-1,n-1)*nck(n,3*m-(2*i));\n        yy2 %= mod;\n        ans = ans - yy2;\n        ans %= mod;\n        if(ans<0)\n            ans = ans + mod;\n    }\n\n    cout << ans << endl;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout << fixed;\n    cout << setprecision(10);\n    #ifdef sarthak\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif\n\n    ll t = 1;\n    // cin >> t;\n    while(t--)\n    {\n        solve();\n    }\n\n    #ifdef sarthak\n    cerr << \"Time elapsed: \" << (clock() - begtime)*1000/CLOCKS_PER_SEC << \" ms\\n\\n\";\n    #endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=5000005;\nconst int mod=998244353;\nint n,m;\nint fac[maxn],ifac[maxn];\n\nint C(int a,int b){\n\tif(a<b||a<0||b<0)return 0;\n\treturn 1LL*fac[a]*ifac[b]%mod*ifac[a-b]%mod;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfac[0]=fac[1]=ifac[0]=ifac[1]=1;\n\tfor(int i=2;i<=3*m+n;i++){\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\t\tifac[i]=1LL*ifac[mod%i]*(mod-mod/i)%mod;\n\t}\n\tREP(i,3*m+n)ifac[i]=1LL*ifac[i-1]*ifac[i]%mod;\n\tint ans=0;\n\trep(i,min(n,m)+1){\n\t\tif((3*m-i)&1)continue;\n\t\tint cur=(3*m-i)/2;\n\t\tint tmp=(C(cur+n-1,n-1)-1LL*i*C(cur-m+n-1,n-1)%mod+mod-1LL*(n-i)*C(cur-(m+1)+n-1,n-1)%mod+mod)%mod;\n\t\tans=(ans+1LL*C(n,i)*tmp%mod)%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD 998244353\n\nstruct llm{\n    ll value=0;\n    llm(const ll& val=0){this->value = (MOD + val % MOD) % MOD;}\n    llm(const int& val){this->value = (MOD + val % MOD) % MOD;}\n    llm(const llm& a) { llm(a.value); }\n    llm inv(){ll a = 1;ll b = this->value;for(ll m=MOD-2;m>0;m/=2){if(m&1){a=a*b%MOD;}b=b*b%MOD;}return llm(a);}\n    llm &operator+=(const llm &a) {this->value = (this->value + a.value) % MOD;return *this;}\n    llm &operator-=(const llm &a) {this->value = (this->value - a.value + MOD) % MOD;return *this;}\n    llm &operator*=(const llm &a) {this->value = (this->value * a.value) % MOD; return *this; }\n    explicit operator ll() const{return (ll)value;}\n    explicit operator int() const{return (int)value;}\n};\nllm operator+(const llm &a, const llm &b) { return llm(a.value + b.value); }\nllm operator-(const llm &a, const llm &b) { return llm(a.value - b.value); }\nllm operator*(const llm &a, const llm &b) { return llm(a.value * b.value); }\n#define pllm pair<llm,llm>\n\nllm Fa[5050505];\nllm C(const ll& a,const ll& b){\n    if(a<b||a<0||b<0)\n        return 0;\n    return Fa[a] * (Fa[b]* Fa[a - b]).inv();\n}\n\n\nll N,M;\nll i,j,k;\nllm ans;\nint main(){\n    scanf(\"%lld%lld\", &N, &M);\n    Fa[0] = 1;\n    fornum(i,0,5040302){\n        Fa[i + 1] = Fa[i] * (i + 1);\n    }\n    ans = C(N - 1 + M * 3, N - 1);\n    fornum(i,0,N+1){\n        if(i>M*3)\n            break;\n        if(i<=M){\n            if ((M * 3 - i) % 2)\n                continue;\n            if(M%2){\n                ans -= C(N, i) * N * C(N - 1 + (M - i) / 2, N - 1);\n            }else{\n                ans -= C(N - 1, i) * N * C(N - 1 + (M - i - 2) / 2, N - 1);\n                ans -= C(N - 1, i - 1) * N * C(N - 1 + (M - i) / 2, N - 1);\n            }\n        }else{\n            if((M*3-i)%2)\n                continue;\n            ans -= C(N, i) * C(N - 1 + (M * 3 - i) / 2, N - 1);\n        }\n    }\n    printf(\"%lld\", (ll)ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<(n); ++i)\n#define rrep(i,n) for(int i=1; i<=(n); ++i)\n#define drep(i,n) for(int i=(n)-1; i>=0; --i)\n#define foreach(it, v) for(typeof(v.begin()) it=v.begin(); it!=v.end(); ++it)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define fi first\n#define se second\n\ntypedef unsigned int uint;\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpii;\ntypedef set<int> si;\n\n\nconst int MAX = 3010000;\nconst int MOD = 998244353;\n\nll fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nll COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\n\n\n\n\n\nint N, M;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  // 前処理\n  COMinit();\n\n  cin >> N >> M;\n\n  ll ans = 0;\n  for (int n=M%2; n<=M; n += 2) {\n    int D = (M * 3 - n) / 2;\n    ll a1 = COM(N, n) * COM(N+D-1, N-1) % MOD;\n    ll b1 = N * (COM(N-1, n-1) * COM(N+D-M-1, N-1) % MOD) % MOD;\n    ll b2 = N * (COM(N-1, n) * COM(N+D-M-2, N-1) % MOD) % MOD;\n    ans = (ans + a1 - b1 - b2 + MOD*2) % MOD;\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\n#define MN 2500000\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,m,ans,p[MN+5],inv[MN+5];\ninline int C(int n,int m){return 1LL*p[n]*inv[m]%mod*inv[n-m]%mod;}\nint main()\n{\n    n=read();m=read();\n    p[0]=p[1]=inv[0]=inv[1]=1;\n    for(int i=2;i<=MN;++i) p[i]=1LL*p[i-1]*i%mod,inv[i]=1LL*(mod-mod/i)*inv[mod%i]%mod;\n    for(int i=2;i<=MN;++i) inv[i]=1LL*inv[i-1]*inv[i]%mod;\n    if(n==2) return 0*printf(\"%d\\n\",m+1);\n    printf(\"%d\\n\",(C(m*3+n-1,n-1)-1LL*n*C(m-1+n-1,n-1)%mod+mod)%mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if (v+o.v >= N) v += o.v - N; else v += o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v -= o.v-N; else v-=o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\ttemplate <typename T>\n\tstatic T div(T p, T q, T N) {\n\t\tT t=0,nt=1,r=N,nr=q;\n\t\twhile(nr!=0){ T q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r!=0) { return 0; }\n\t\treturn (t*p/r)%N;\n\t}\n};\n#endif\n\n\ntypedef Field<998244353> FF;\n\nclass CGP2 {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N, M; cin >> N >> M;\n        auto F = FF::fact(N+2*M);\n        auto I = FF::invfact(N+2*M);\n\n        FF ans = 0;\n        for (int i = 0; i <= M/2; ++i) {\n            int j = M-2*i;\n            if (j > N) continue;\n\n            FF tot = F[(M+i) + N - 1] * I[N-1] * I[(M+i)];\n            FF oneHasM = F[i + N - 2] * I[N-2] * I[i] * N;\n            FF oneHasMoreThanM = i == 0 ? 0 : F[i + N - 2] * I[N-1] * I[i-1] * N;\n            FF allHaveLessThanM = tot - oneHasM - oneHasMoreThanM;\n\n\n            ans += allHaveLessThanM * F[N] * I[j] * I[N-j];\n            if (j < N) {\n                ans += oneHasM * F[N-1] * I[j] * I[N-j-1];\n            }\n\n\n\n//            int j = 2*(M-i);\n//            if (j > N) continue;\n\n//            FF cur = F[(M+i) + N - 1] * I[N-1] * I[(M+i)];\n//            cur *= F[N] * I[N - j] * I[j];\n//            cout << cur << endl;\n//            ans += cur;\n        }\n        cout << ans << endl;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tCGP2 solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nvector<int> fact;\nvector<int> ifact;\nvector<int> inv;\nvector<int> pow2;\nconst int MOD = 998244353;\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nint modpow(int a, int b)\n{\n\tint r=1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=mult(r,a);\n\t\ta=mult(a,a);\n\t\tb>>=1;\n\t}\n\treturn r;\n}\nint choose(int a, int b)\n{\n\tif(a<0) return 0;\n\tif(a<b) return 0;\n\tif(b<0) return 0;\n\tif(b==0) return 1;\n\tif(a==b) return 1;\n\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n}\nint inverse(int a)\n{\n\treturn modpow(a,MOD-2);\n}\nvoid init(int _n)\n{\n\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear();\n\tfact.resize(_n+1);\n\tifact.resize(_n+1);\n\tinv.resize(_n+1);\n\tpow2.resize(_n+1);\n\tpow2[0]=1;\n\tifact[0]=1;\n\tfact[0]=1;\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\tfact[i]=mult(fact[i-1],i);\n\t\t//ifact[i]=mult(ifact[i-1],inv[i]);\n\t}\n\tifact[_n] = inverse(fact[_n]);\n\tfor(int i=_n-1;i>=1;i--)\n\t{\n\t\tifact[i] = mult(ifact[i + 1], i + 1);\n\t}\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tinv[i] = mult(fact[i-1],ifact[i]);\n\t}\n}\n\t\nint under(int m, int n, int sum) //# of sequences of length n s.t. each term <= m, total = sum (sum<=2*m)\n{\n\tint ans = choose(sum+n-1,n-1);\n\tans=add(ans,MOD-mult(n,choose(sum-(m+1)+n-1,n-1)));\n\treturn ans;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tinit(3111111);\n\tint n,m; cin>>n>>m;\n\tint ans=0;\n\t/*\n\t//all <= m\n\t{\n\t\tint res = choose(3*m+n-1,n-1);\n\t\t//subtract 1 >m\n\t\tfor(int i=m+1;i<=3*m;i++)\n\t\t{\n\t\t\tres=add(res,MOD-mult(n,under(m,n-1,3*m-i)));\n\t\t}\n\t\t//subtract 2 >m\n\t\tfor(int s=2*m+2;s<=3*m;s++)\n\t\t{\n\t\t\tint coeff=choose(3*m-s+n-3,n-3);\n\t\t\tint l=m+1;\n\t\t\tint r=s-(m+1);\n\t\t\tint as=(r-l+1);\n\t\t\tint C = mult(choose(n,2),as);\n\t\t\tres=add(res,MOD-mult(coeff,C));\n\t\t}\n\t\tans=add(ans,res);\n\t}\n\t//one > m\n\t\n\t//two > m\n\t{\n\t\tfor(int s=2*m+2;s<=3*m;s++)\n\t\t{\n\t\t\tint coeff=choose(3*m-s+n-3,n-3);\n\t\t\tint l=m+1;\n\t\t\tint r=s-(m+1);\n\t\t\tint as=(r-l+1);\n\t\t\tint C = mult(choose(n,2),as);\n\t\t\tans=add(ans,mult(coeff,C));\n\t\t}\n\t}\n\t*/\n\tfor(int odd=0;odd<=m;odd++)\n\t{\n\t\tint coeff = choose(n,odd);\n\t\tint sum = 3*m-odd;\n\t\tif(sum%2!=0) continue;\n\t\tsum/=2;\n\t\tans=add(ans,mult(coeff,choose(sum+n-1,n-1)));\n\t\t{\n\t\t\t//even i\n\t\t\tans=add(ans,MOD-mult(n,mult(choose(n-1,odd),choose((m-2-odd)/2+n-1,n-1))));\n\t\t}\n\t\tif(odd>0)\n\t\t{\n\t\t\t//odd i\n\t\t\tans=add(ans,MOD-mult(n,mult(choose(n-1,odd-1),choose((m-odd)/2+n-1,n-1))));\n\t\t}\n\t\t/*\n\t\tfor(int i=2*m+1;i<=3*m;i++)\n\t\t{\n\t\t\tint oddrem = odd-(i%2);\n\t\t\tif(oddrem<0) continue;\n\t\t\tint ss = (3*m-i-oddrem);\n\t\t\tif(ss%2!=0) continue;\n\t\t\tss/=2;\n\t\t\tans=add(ans,MOD-mult(n,mult(choose(n-1,oddrem),choose(ss+n-2,n-2))));\n\t\t}\n\t\t*/\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\n\n\nconst int MAX = 510000;\nconst int MOD = 998244353;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (int i = 2; i < MAX; i++){\n    fac[i] = fac[i - 1] * i % MOD;\n    inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n    finv[i] = finv[i - 1] * inv[i] % MOD;\n  }\n}\n\n// 二項係数計算\nlong long COM(int n, int k){\n  if (n < k) return 0;\n  if (n < 0 || k < 0) return 0;\n  return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nint main(void) {\n  cout << std::fixed << std::setprecision(10);\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  int n,m;\n  cin>>n>>m;\n\n  COMinit();\n\n  int result=0;\n  for(int a=3*m;a<=3*m;a++){\n    result+=COM(n+a-1,a);\n    result%=MOD;\n  }\n  int result_b=0;\n  for(int a=2*m+1;a<=3*m;a++){\n    result_b+=n*COM(n+a-2*m-1,a-2*m);\n    result_b%=MOD;\n  }\n  result-=result_b;\n  if(result<0){\n    result+=MOD;\n  }else{\n    result%=MOD;\n  }\n\n  cout<<result<<endl;\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nconst ll mod = 998244353;\nstruct mint {\n    ll x; // typedef long long ll;\n    mint(ll x=0):x((x%mod+mod)%mod){}\n    mint& operator+=(const mint a) {\n    if ((x += a.x) >= mod) x -= mod;\n    return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod-a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n    // for prime mod\n    mint inv() const {\n        return pow(mod-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\n\nclass combination{\nprivate:\n    vector<mint> fact,finv;\npublic:\n    combination(int N){\n        fact = finv = vector<mint>(N+1);\n        fact[0] = fact[1] = 1;\n        finv[0] = finv[1] = 1;\n        for(ll i=2;i<=N;i++){\n            fact[i] = fact[i-1]*i;\n            finv[i] = fact[i].inv();\n        }\n    }\n    mint f(int i){\n        return fact[i];\n    }\n    mint comb(int n,int k){\n        if(n<k) return 0;\n        if(n<0 || k<0) return 0;\n        return fact[n]*finv[k]*finv[n-k];\n    }\n    mint hcomb(int n,int k){\n        if(n==0 && k==0) return 1;\n        return comb(n+k-1,k);\n    }\n};\n\nint main(){\n    ll N,M;\n    cin >> N >> M;\n    combination c(N+3*M);\n    mint ans = c.hcomb(N,3*M);\n    for(int k=M+1;k<=min(N,3*M);k++){\n        if((3*M-k)%2==0){\n            ans -= c.comb(N,k)*c.hcomb(N,(3*M-k)/2);\n        }\n    }\n    mint n;\n    n.x = N;\n    ans -= c.hcomb(N,M-1)*n;\n    cout << ans.x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define vv(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define vvi std::vector<std::vector<int> >\n#define vvl std::vector<std::vector<ll> >\n#define MODs 1000000007;\ntypedef long long int ll;\nusing namespace std;\n\n////////////////////////////////\n#define P 998244353\n#define N_MAX 10000000\ntypedef long long int ll;\nll fac[N_MAX+1];\nll inv[N_MAX+1];\nll finv[N_MAX+1];\n\nll comb(ll n, ll k){\n    return (((fac[n]*finv[n-k])%P)*finv[k])%P;\n}\n\nvoid init(){\n    fac[0] = finv[0] = fac[1] = finv[1] = inv[1] = 1;\n    for(int i = 2; i <= N_MAX; i++){\n        fac[i] = (fac[i-1]*i)%P;\n        inv[i] = ((-(P/i)*inv[P%i])%P+P)%P;\n        finv[i] = (finv[i-1]*inv[i])%P;\n    }\n}\nll pp(ll a, ll b){\n  return (a * b)%P;\n}\n//////////////////////////////////////\nint main(int argc, char const *argv[]) {\n  ll N, M, ans = 0;\n  std::cin >> N >> M;\n  init();\n  ans = comb(3*M+N-1, N-1);\n  ans = (ans - (N*comb(M-1+N-1, N-1))%P)%P;\n  if(ans<0) ans+=P;\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//const ll MOD = 998244353;\n//const int N = 2e6+5;\n//void _(){\n//    Factorial f(N);\n//    ll n,m;\n//    cin >> n >> m;\n//    ll ans = 0;\n//    for(int i = m%2; i <= min(m,n); i += 2){\n//        int singles = i;\n//        ll cur = f.comb(n,singles);\n//        ll rem = m*3-singles;\n//        assert(rem%2 == 0);\n//        rem /= 2;\n//        ll tmp = 0;\n//        rep(over,0,3){\n//            ll sign = over%2 ? -1 : 1;\n//            ll bound = m-1;\n//            if(rem-over*(bound+1) >= 0){\n//                tmp += cur*sign*f.comb(n-1+rem-over*(bound+1),n-1)%MOD*f.comb(n,over)%MOD;\n//            }\n//        }\n//        ans = (ans+tmp)%MOD;\n//    }\n//    ans += n*f.comb(n-2+m,m);\n//    ans %= MOD;\n//    if(ans < 0)\n//        ans += MOD;\n//    print(ans);\n//}\n//\n#include <iomanip>\n#include <algorithm>\n#include <cassert>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <string>\n#define REP_INT(i,l,r) for(int i = l; i <= r; ++i)\n#define GET_REP_MACRO(_1,_2,_3,_4,NAME,...) NAME\n#define rep(...) GET_REP_MACRO(__VA_ARGS__,REP_ANY,REP_INT)(__VA_ARGS__)\n#define all(v) (v).begin(), (v).end()\n#define sz(v) ll(v.size())\n#define T1 template<typename T> static\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\nconst ll MOD = 998244353;\nT1 ostream& operator<<(ostream& stream, const vector<T>& t);\nT1 istream& read(T, T, istream& = cin);\nT1 void print(T x, string end = \"\\n\"){\n    cout << x << end;\n}\nT1 T ext_euclid(T a, T b, T c, T d){\n    if(c == T(0))\n        return b;\n    return ext_euclid(c, d, a % c, b - a / c * d);\n}\nT1 T mod_inverse(T x, T mod = T(MOD)){\n    return (ext_euclid(mod, T(0), x, T(1)) + mod) % mod;\n}\nll mod_inverse(int x, ll mod = MOD){\n    return mod_inverse<ll>(x,mod);\n}\nstruct Factorial{\n    vl fact,ifact;\n    ll comb(ll n, ll m){\n        assert(n >= m);\n        assert(n < sz(fact));\n        return fact[n]*ifact[m]%MOD*ifact[n-m]%MOD;\n    }\n    Factorial(int n){\n        fact.resize(n+1);\n        ifact.resize(n+1);\n        fact[0] = 1;\n        for(int i = 1; i <= n; ++i)\n            fact[i] = fact[i-1]*i%MOD;\n        ifact[n] = mod_inverse(fact[n]);\n        for(int i = n-1; i >= 0; --i)\n            ifact[i] = (i+1)*ifact[i+1]%MOD;\n    }\n};\nconst int N = 2e6+5;\nvoid _(){\n    Factorial f(N);\n    ll n,m;\n    cin >> n >> m;\n    ll ans = 0;\n    for(int i = m%2; i <= min(m,n); i += 2){\n        int singles = i;\n        ll cur = f.comb(n,singles);\n        ll rem = m*3-singles;\n        assert(rem%2 == 0);\n        rem /= 2;\n        ll tmp = 0;\n        rep(over,0,3){\n            ll sign = over%2 ? -1 : 1;\n            ll bound = m-1;\n            if(rem-over*(bound+1) >= 0){\n                tmp += cur*sign*f.comb(n-1+rem-over*(bound+1),n-1)%MOD*f.comb(n,over)%MOD;\n            }\n        }\n        ans = (ans+tmp)%MOD;\n    }\n    ans += n*f.comb(n-2+m,m);\n    ans %= MOD;\n    if(ans < 0)\n        ans += MOD;\n    print(ans);\n}\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(15);\n        _();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\n\nll inf = 998244353;\nll fact[3000010] = {0};\nll finv[3000010] = {0};\nll inv[3000010] = {0};\n\nll mult(ll n, ll m){\n\tif(m==1) return n%inf;\n\telse if(m%2==0){\n\t\tll t = mult(n,m/2);\n\t\treturn t*t%inf;\n\t}else{\n\t\tll t = mult(n,m-1);\n\t\treturn t*n%inf;\n\t}\n}\n\nvoid factorial(ll N){\n\tfact[0] = fact[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(ll i=2;i<=N;i++){\n\t\tfact[i] = i*fact[i-1]%inf;\n\t\tinv[i] = inf-inv[inf%i]*(inf/i)%inf;\n\t\tfinv[i] = finv[i-1]*inv[i]%inf;\n\t}\n}\n\nll comb(ll n,ll k){\n\tif(n<k) return 0;\n\tif(n<0 || k<0) return 0;\n\telse return (((fact[n]*finv[k])%inf)*finv[n-k])%inf;\n}\n\nll hcomb(ll n,ll k){\n\tif(n==0 && k==0) return 1;\n\treturn comb(n+k-1,k);\n}\n\nint main(){\n    ll N,M;\n    cin >> N >> M;\n    factorial(N+3*M);\n\tll ans = hcomb(N,3*M);\n\tfor(ll k=M+1;k<=min(N,3*M);k++){\n\t\tif((3*M-k)%2==1) continue;\n\t\t(ans += -comb(N,k)*hcomb(N,(3*M-k)/2)%inf+inf)%=inf;\n\t}\n\t(ans += -hcomb(N,M-1)*N%inf+inf)%=inf;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(V) V.begin(),V.end()\n#define ll long long\n#define MOD 998244353\n\nll modpow(ll x, ll y) {\n\tx %= MOD;\n\tll ans = 1;\n\twhile (y) {\n\t\tif (y & 1)ans *= x;\n\t\ty >>= 1;\n\t\tx *= x;\n\t\tx %= MOD;\n\t\tans %= MOD;\n\t}\n\treturn ans;\n}\n\nll moddiv(ll y) {\n\treturn modpow(y, MOD - 2);\n}\n\nll NC[3000007], NC1[3000007], NC2[3000007], R[4000007];\n\nint main(){\n\tll N, M;\n\tcin >> N >> M;\n\t\n\tfor (int i = 4000006;i > 0;i--) {\n\t\tR[i] = moddiv(i);\n\t}\n\t\n\tNC[0] = 1;\n\tfor (int i = 1;i <= N;i++) {\n\t\tNC[i] = NC[i - 1];\n\t\tNC[i] *= N - i + 1;NC[i] %= MOD;\n\t\tNC[i] *= R[i];NC[i] %= MOD;\n\t\t//cout << i << \" \" << NC[i] << endl;\n\t\t//NC[i]=nCi\n\t}\n\n\tNC2[0] = 1;\n\tfor (int x = 1;x <= N - 2;x++) {\n\t\tNC2[0] *= 3 * M + x;\n\t\tNC2[0] %= MOD;\n\t\tNC2[0] *= R[x];\n\t\tNC2[0] %= MOD;\n\t}\n\n\tfor (int i = 1;i <= 3 * M;i++) {\n\t\tNC2[i] = NC2[i - 1];\n\t\tNC2[i] *= 3 * M - i + 1;\n\t\tNC2[i] %= MOD;\n\t\tNC2[i] *= R[3 * M - i + N - 1];\n\t\tNC2[i] %= MOD;\n\n\t\t//cout << 3 * M - i + N - 2 << \" \" << N - 2 << \" \" << NC2[i] << endl;\n\t\t//NC2[i]=(3*M-i+N-2)C(N-2)\n\t}\n\n\tNC1[0] = 1;\n\tfor (int i = 1;i <= 3 * M;i++) {\n\t\tNC1[i] = NC1[i - 1];\n\t\tNC1[i] *= N - 1 + i;\n\t\tNC1[i] %= MOD;\n\t\tNC1[i] *= R[i];\n\t\tNC1[i] %= MOD;\n\t\t//NC1[i]=(N-1+i)C(N-1)\n\t}\n\tll ans = NC1[3 * M];\n\n\t//奇数がM個を超える\n\tll hj = 0;\n\tfor (int i = M + 2;i <= 3 * M && i <= N;i += 2) {\n\t\t//cout << NC[i] << \" \" << NC1[(3 * M - i) / 2] << endl;\n\t\thj += NC[i] * NC1[(3 * M - i) / 2];\n\t\thj %= MOD;\n\t}\n\n\t//maxが2Mを超える\n\tll mo = 0;\n\tfor (int i = 2 * M + 1;i <= 3 * M;i++) {\n\t\tmo += N * NC2[i];\n\t\tmo %= MOD;\n\t}\n\t//cout << ans << \" \" << hj << \" \" << mo << endl;\n\tans -= hj + mo;\n\tans %= MOD;if (ans < 0)ans += MOD;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#define ll long long\n#define mod 998244353\n#define Mod1(x) (x>=mod?x-mod:x)\n#define Mod2(x) (x<0?x+mod:x)\n#define maxn 3000010\ninline ll read()\n{\n\tll x=0; char c=getchar(),f=1;\n\tfor(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n\tfor(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\ninline void write(ll x)\n{\n\tstatic int buf[20],len; len=0;\n\tif(x<0)x=-x,putchar('-');\n\tfor(;x;x/=10)buf[len++]=x%10;\n\tif(!len)putchar('0');\n\telse while(len)putchar(buf[--len]+'0');\n}\ninline void writeln(ll x){write(x); putchar('\\n');}\ninline void writesp(ll x){write(x); putchar(' ');}\nll fac[maxn],inv[maxn];\nint n,m;\ninline ll power(ll a,ll b)\n{\n\tll ans=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)ans=ans*a%mod;\n\treturn ans;\n}\ninline ll C(int n,int m){return fac[n]*inv[m]%mod*inv[n-m]%mod;}\ninline ll calc(int n,int m,int k)\n{\n\tll sum=0;\n\tfor(int i=0;i<=n&&i<=k;i++)\n\t\tif(!((m-i)&1)&&m>=i)sum=(sum+C(n,i)*C((m-i)/2+n-1,n-1))%mod;\n\t// writeln(sum);\n\treturn sum;\n}\nint main()\n{\n\tn=read(); m=read();\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=n+3*m;i++){\n\t\tfac[i]=fac[i-1]*i%mod;\n\t\tinv[i]=power(fac[i],mod-2);\n\t}\n\tll ans=(calc(n,3*m,m)-n*calc(n,m-1,m))%mod;\n\twriteln(Mod2(ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef CLASS_MODINT\n#define CLASS_MODINT\n\n#include <cstdint>\n\ntemplate <std::uint32_t mod>\nclass modint {\nprivate:\n\tstd::uint32_t n;\npublic:\n\tmodint() : n(0) {};\n\tmodint(std::int64_t n_) : n((n_ >= 0 ? n_ : mod - (-n_) % mod) % mod) {};\n\tstatic constexpr std::uint32_t get_mod() { return mod; }\n\tstd::uint32_t get() const { return n; }\n\tbool operator==(const modint& m) const { return n == m.n; }\n\tbool operator!=(const modint& m) const { return n != m.n; }\n\tmodint& operator+=(const modint& m) { n += m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator-=(const modint& m) { n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator*=(const modint& m) { n = std::uint64_t(n) * m.n % mod; return *this; }\n\tmodint operator+(const modint& m) const { return modint(*this) += m; }\n\tmodint operator-(const modint& m) const { return modint(*this) -= m; }\n\tmodint operator*(const modint& m) const { return modint(*this) *= m; }\n\tmodint inv() const { return (*this).pow(mod - 2); }\n\tmodint pow(std::uint64_t b) const {\n\t\tmodint ans = 1, m = modint(*this);\n\t\twhile (b) {\n\t\t\tif (b & 1) ans *= m;\n\t\t\tm *= m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n};\n\n#endif // CLASS_MODINT\n\n#include <vector>\n#include <iostream>\n#include <functional>\nusing namespace std;\nusing mint = modint<998244353>;\nconst int limit = 3000000;\nint main() {\n\tvector<mint> fact(limit + 1), inv(limit + 1), factinv(limit + 1);\n\tfact[0] = 1; inv[1] = 1; factinv[0] = 1;\n\tfor (int i = 1; i <= limit; ++i) fact[i] = fact[i - 1] * i;\n\tfor (int i = 2; i <= limit; ++i) inv[i] = inv[mint::get_mod() % i] * mint(-int(mint::get_mod() / i));\n\tfor (int i = 1; i <= limit; ++i) factinv[i] = factinv[i - 1] * inv[i];\n\tfunction<mint(int, int)> comb = [&](int x, int y) {\n\t\tif (y < 0 || x < y) return mint(0);\n\t\treturn fact[x] * factinv[y] * factinv[x - y];\n\t};\n\tint N, M;\n\tcin >> N >> M;\n\tmint ans = 0;\n\tfor (int i = M % 2; i <= M && i <= N; i += 2) {\n\t\tint rem = M + (M - i) / 2;\n\t\tmint sub1 = comb(N + rem - 1, rem);\n\t\tmint sub2 = comb(N + rem - M - 1, rem - M) * i;\n\t\tmint sub3 = comb(N + rem - M - 2, rem - M - 1) * (N - i);\n\t\tans += (sub1 - sub2 - sub3) * comb(N, i);\n\t}\n\tcout << ans.get() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 2e6 + 5;\nconst int   mod = 998244353;\n\nvoid add(int &a,int b)  {\n    a += b;\n    if (a >= mod)\n        a -= mod;\n}\nvoid sub(int &a,int b)  {\n    a -= b;\n    if (a <  0)\n        a += mod;\n}\nint mul(int a,int b)    {\n    return  1ll * a * b % mod;\n}\nint Pow(int a,int b)    {\n    int ans = 1;\n    while (b)   {\n        if(b & 1)   ans = mul(ans,a);\n        a = mul(a,a);   b >>= 1;\n    }\n    return  ans;\n}\nint inv(int a,int p)    {\n    return  a == 1 ? 1 : p - 1ll * p * inv(p % a,a) / a;\n}\nint Fac[N];\nint Inv[N];\n\nint Ckn(int n,int k)    {\n    if (n < k)  return  0;\n    if (k < 0)  return  0;\n\n    return  mul(Fac[n],mul(Inv[k],Inv[n - k]));\n}\ntypedef pair<int,int>   ii;\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    Fac[0] = Inv[0] = 1;\n\n    for(int i = 1 ; i < N ; ++i)    Fac[i] = mul(Fac[i - 1],i);     Inv[N - 1] = inv(Fac[N - 1],mod);\n    for(int i = N - 2 ; i ; --i)    Inv[i] = mul(Inv[i + 1],i + 1);\n\n    int n;  cin >> n;\n    int m;  cin >> m;\n\n    int ans = 0;\n\n    for(int i = 0 ; i <= m ; ++i)   if (m % 2 == i % 2) {\n        int cur = 1;\n\n        cur = mul(cur,Ckn(n,i));\n        cur = mul(cur,Ckn((3 * m - i) / 2 + n - 1,n - 1));\n\n        add(ans,cur);\n    }\n    for(int i = 0 ; i <= m ; ++i)   if (m % 2 == i % 2) {\n        int cur = 0;\n\n        add(cur,mul(Ckn(n,i),Ckn((m - i) / 2 + n - 1,n - 1)));  --n;\n        sub(cur,mul(Ckn(n,i),Ckn((m - i) / 2 + n - 1,n - 1)));  ++n;\n\n        sub(ans,mul(cur,n));\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SZ(x) ((int)((x).size()))\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\ntemplate<class TH>\nvoid _dbg(const char* name, TH val){\n    clog << name << \": \" << val << endl;\n}\ntemplate<class TH, class... TA>\nvoid _dbg(const char* names, TH curr_val, TA... vals) {\n    while(*names != ',') clog << *names++;\n    clog << \": \" << curr_val << \", \";\n    _dbg(names+1, vals...);\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n    #define dbg_arr(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg(...)\n    #define dbg_arr(x, len)\n#endif\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\nLL Inverse(LL n, LL m) {\n    n %= m;\n    if (n <= 1) return n; // Handles properly (n = 0, m = 1).\n    return m - ((m * Inverse(m, n) - 1) / n);\n}\n\nconst LL mod = 998244353;\nconst int MAXN = 4e6;\nLL fact[MAXN];\n\nLL binom(LL a, LL b) {\n    assert(MAXN > a and a >= b and b >= 0);\n    return fact[a] * Inverse(fact[b]*fact[a-b] % mod, mod) % mod;\n}\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in problems with online queries!\n\n    fact[0] =  1;\n    for (int i = 1; i < MAXN; i++) {\n        fact[i] = i*fact[i-1] % mod;\n        // invfact[i] = Inverse(fact[i], mod);\n    }\n\n    int N, M;\n    cin >> N >> M;\n\n    LL ans = N * binom(M + N-2, N-2) % mod;\n    for (int k = 0; k <= min(N, M); k++) {\n        LL q = 3*M-k;\n        if (q % 2) continue;\n        q /= 2;\n        LL ris = binom(q + N-1, N-1) - N*binom(q-M + N-1, N-1);\n        ris %= mod;\n        ris = ris * binom(N, k) % mod;\n        ans += ris;\n        ans %= mod;\n    }\n    if (ans < 0) ans += mod;\n    cout << ans << \"\\n\";\n\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define int long long\n#define mp make_pair\n#define inf 998244353\n#define LINF 1000000000000000007LL\n#define ll long long\nusing namespace std;\nint ka[2145140],inv[2145140];\nvoid setkaijo(int n){\n\tka[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tka[i] = ka[i-1] * i;\n\t\tka[i] %= inf;\n\t}\n}\nint modpow(int x,int k){\n\t// x ^ k mod inf\n\tint p2[55],res=1;\n\tp2[0]=1;p2[1]=x%inf;\n\tfor(int i=2;i<=50;i++){\n\t\tp2[i]=p2[i-1]*p2[i-1];\n\t\tp2[i] %= inf;\n\t}\n\tfor(int i=1;i<=50;i++){\n\t\tif(k%2==1){\n\t\t\tres *= p2[i];\n\t\t\tres %= inf;\n\t\t}\n\t\tk /= 2;\n\t}\n\treturn res;\n}\nvoid setinv(int n){\n\tfor(int i=0;i<=n;i++){\n\t\tinv[i] = modpow(ka[i],(ll)inf-2);\n\t}\n}\nint comb(int n,int k){\n\tif( k<0 || n<0 || k>n)return 0;\n\tif(k==0 || k==n)return 1;\n\tint res = (ka[n] * inv[k]) % inf;\n\tres = (res*inv[n-k]) % inf;\n\treturn res;\n}\nsigned main(){\n\tint n,m;\n\tcin>>n>>m;\n\tsetkaijo(2000000);\n\tsetinv(2000000);\n\tint ans = 0, sub = 0;\n\tfor(int i=0; i<=m ; i++){\n\t\tif( i <= n && ( 3*m-i ) % 2 == 0 ){\n\t\t\tint tmp = 1;\n\t\t\tint tms = ( 3 * m - i ) / 2;\n\t\t\ttmp = comb( tms + n - 1, tms );\n\t\t\ttmp *= comb( n, i );\n\t\t\ttmp %= inf;\n\t\t\tans += tmp;\n\t\t\tans %= inf;\n\t\t}\n\t}\n\tfor(int i=2*m+1;i<=3*m;i++){\n\t\tint amari = 3*m-i;\n\t\tint tmp = n;\n\t\ttmp *= comb( amari + n - 2, amari );\n\t\ttmp %= inf;\n\t\tsub += tmp;\n\t\tsub %= inf;\n\t}\n\tint res = ( ans + inf - sub ) % inf;\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <type_traits>\n#include <tuple>\n\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(std::min<int>(l_, r_)), r(r_) {}\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr r, l;\n  constexpr revrange(int l_, int r_): r(std::max<int>(l_, r_) - 1), l(l_ - 1) {}\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\ntemplate <class T>\ninline T scan() {\n  T res;\n  std::cin >> res;\n  return res;\n}\n\ntemplate <class T>\nclass modulo_int {\npublic:\n  static constexpr int mod = T::value;\n  static_assert(mod > 0, \"mod must be positive\");\nprivate:\n  long long value;\n  constexpr void normalize() {\n    value %= mod;\n    if (value < 0) value += mod;\n  }\npublic:\n  constexpr modulo_int(long long value_ = 0): value(value_) { normalize(); }\n  constexpr modulo_int operator - () const { return modulo_int(mod - value); }\n  constexpr modulo_int operator ~ () const { return power(mod - 2); }\n  constexpr long long operator () () const { return value; }\n  constexpr modulo_int operator + (const modulo_int& rhs) const { return modulo_int(*this) += rhs; }\n  constexpr modulo_int& operator += (const modulo_int& rhs) {\n    if ((value += rhs.value) >= mod) value -= mod;\n    return (*this);\n  }\n  constexpr modulo_int operator - (const modulo_int& rhs) const { return modulo_int(*this) -= rhs; }\n  constexpr modulo_int& operator -= (const modulo_int& rhs) {\n    if ((value += mod - rhs.value) >= mod) value -= mod;\n    return (*this);\n  }\n  constexpr modulo_int operator * (const modulo_int& rhs) const { return modulo_int(*this) *= rhs; }\n  constexpr modulo_int& operator *= (const modulo_int& rhs) {\n    (value *= rhs.value) %= mod;\n    return (*this);\n  }\n  constexpr modulo_int operator / (const modulo_int& rhs) const { return modulo_int(*this) /= rhs; }\n  constexpr modulo_int& operator /= (const modulo_int& rhs) {\n    return (*this) *= ~rhs;\n  }\n  constexpr modulo_int power (unsigned long long pow) const {\n    modulo_int result(1), mult(*this);\n    while (pow > 0) {\n      if (pow & 1) result *= mult;\n      mult *= mult;\n      pow >>= 1;\n    }\n    return result;\n  }\n  friend std::istream& operator >> (std::istream& stream, modulo_int& lhs) {\n    stream >> lhs.value;\n    lhs.normalize();\n    return stream;\n  }\n  friend std::ostream& operator << (std::ostream& stream, const modulo_int& rhs) {\n    return stream << rhs.value;\n  }\n};\n\ntemplate <class T>\nclass factorials {\npublic:\n  using value_type = T;\n\npublic:\n  std::vector<value_type> fact, fact_inv;\n\n  factorials(int size_ = 200000): fact(size_ + 1), fact_inv(size_ + 1) {\n    fact[0] = 1;\n    for (int i = 1; i <= size_; ++i) {\n      fact[i] = fact[i - 1] * value_type(i);\n    }\n    fact_inv[size_] = ~fact[size_];\n    for (int i = size_; i > 0; --i) {\n      fact_inv[i - 1] = fact_inv[i] * value_type(i);\n    }\n  }\n\n  value_type operator () (int n, int r) const {\n    return fact[n] * fact_inv[n - r] * fact_inv[r];\n  }\n\n};\n\nusing modint = modulo_int<std::integral_constant<int, 998244353>>;\nfactorials<modint> fact(2500000);\n\nmodint calc(int sum, int to) {\n  if (to == 0) {\n    return modint(sum == 0 ? 1 : 0);\n  }\n  else {\n    return fact(sum + to - 1, to - 1);\n  }\n}\n\nmodint path(int x, int y) {\n  return fact(x + y, x);\n}\n\nint main() {\n  // 合計 3M, 最大のものが 2M 以下, 1 の個数が M 以下\n  int N, M;\n  std::cin >> N >> M;\n  if (M < N) {\n    abort();\n  }\n  modint ans = calc(3 * M, N);\n  // 合計 3M かつ 最大のものが 2M より大きい\n  for (int k: range(2 * M + 1, 3 * M + 1)) {\n    ans -= calc(3 * M - k, N - 1) * modint(N);\n  }\n  // 合計 3M かつ 1 の個数が M より大きい\n  for (int k: range(M + 1, N + 1)) {\n    if (k > 3 * M) {\n      break;\n    }\n    modint coeff = path(M, k - M - 1) * modint((k - M) % 2 == 0 ? -1 : 1);\n    ans -= coeff * fact(N, k) * calc(3 * M - k, N - k);\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <tuple>\n#include <utility>\n#include <vector>\n#define ll long long\n#define itn int\n#define endl '\\n'\n#define co(ans) cout<<ans<<endl\n#define COYE cout<<\"YES\"<<endl\n#define COYe cout<<\"Yes\"<<endl\n#define COye cout<<\"yes\"<<endl\n#define CONO cout<<\"NO\"<<endl\n#define CONo cout<<\"No\"<<endl\n#define COno cout<<\"no\"<<endl\n#define FORE(i,a) for(auto &i:a)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n)  FFOR(i,1,n)\n#define PB push_back\n#define MP make_pair\n#define ALL(V) (V).begin(),(V).end()\n#define SORT(V) sort((V).begin(),(V).end())\n#define REVERSE(V) reverse((V).begin(),(V).end())\n#define EACH(V,i) for(typeof((V).begin()) i=(V).begin();i!=(V).end();++i)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define INF ((1LL<<62)-(1LL<<31))\n#define EPS 1e-10\n#define PI 3.141592653589793238\n#define MOD 998244353\n#define MAX 5100000\nusing namespace std;\nusing Edge=pair<ll,ll>;\nusing Graph=vector<vector<int>>;\ninline int toInt(string s){int v;istringstream sin(s);sin>>v;return v;}\ntemplate<class T>inline string toString(T x){ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\n////////// 二項係数(N<=10^7) //////////\n\nll fac[MAX],finv[MAX],inv[MAX];\n// fac[i] i!\n// finv[i] i!の逆元\n// inv[i] iの逆元\n\n// テーブルを作る前処理\nvoid COMinit(){\n  fac[0]=fac[1]=1;\n  finv[0]=finv[1]=1;\n  inv[1]=1;\n  for(ll i=2; i<MAX; ++i){\n    fac[i]=fac[i-1]*i%MOD;\n    inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n    finv[i]=finv[i-1]*inv[i]%MOD;\n  }\n}\n\n// 二項係数計算\nll COM(ll n,ll k){\n  if(n<k) return 0;\n  if(n<0 || k<0) return 0;\n  return fac[n]*(finv[k]*finv[n-k]%MOD)%MOD;\n}\n\n//////////////////////////////////////////////////\n\nll sub(ll n,ll a,ll b){\n  chmin(b,n);\n  COMinit();\n  ll ans=0;\n  for(int i=a%2; i<=min({n,a,b}); i+=2){\n    ans+=COM((a-i)/2+n-1,n-1)*COM(n,i);\n    ans%=MOD;\n    if(ans<0) ans+=MOD;\n  }\n  return ans;\n}\n\nint main(){\n  ll N,M;\n  cin>>N>>M;\n  \n  ll ans=sub(N,3*M,M);\n  ans-=N*(sub(N,M,M)-sub(N-1,M,M));\n  \n  ans%=MOD;\n  if(ans<0) ans+=MOD;\n  co(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <unordered_map>\n\nusing namespace std;\nusing ll = long long;\n\nvoid _cin(){} template <class Head, class... Tail> void _cin(Head&& head, Tail&&... tail){ cin >> head; _cin(forward<Tail>(tail)...); }\nvoid _cout(){ cout << \"\\n\"; } template <class Head, class... Tail> void _cout(Head&& head, Tail&&... tail){ cout << head; _cout(forward<Tail>(tail)...); }\nint gcd(int a, int b){ return (b == 0) ? a : gcd(b, a % b); }\n\n#define Sq(x) (x)*(x)\n#define For(i, n) for(int i = 0; i < (n); i ++)\n#define Rep(n) For(_, n)\n#define Range(c) c.begin(), c.end()\n#define RevRange(c) c.rbegin(), c.rend()\n#define Contains(c, x) (find(Range(c), x) != c.end())\n#define Search(rb, re, x) distance(rb, find(rb, re, x))\n#define Sort(a) sort(Range(a))\n#define DeSort(a) sort(RevRange(a))\n#define Reverse(c) reverse(Range(c))\n#define Unique(a) a.erase(unique(Range(a)), a.end())\n#define Cusum(T, xs, sxs) vector<T> sxs(xs.size()+1); For(i, (int)xs.size()) sxs[i+1] = sxs[i] + xs[i]\n#define Cin(T, ...) T __VA_ARGS__; _cin(__VA_ARGS__)\n#define Cins(T, n, xs) vector<T> xs(n); For(i, n) cin >> xs[i]\n#define Cins2(T, n, xs, ys) vector<T> xs(n), ys(n); For(i, n) cin >> xs[i] >> ys[i]\n#define Cins3(T, n, xs, ys, zs) vector<T> xs(n), ys(n), zs(n); For(i, n) cin >> xs[i] >> ys[i] >> zs[i]\n#define Cinss(T, n, m, xs) Vec2(T, n, m, xs); For(i, n) For(j, m) cin >> xs[i][j]\n#define Cinm(T, n, map) unordered_map<T, int> map; Rep(n){ Cin(T, x); map[x] ++; }\n#define Cout(...) _cout(__VA_ARGS__)\n#define Couts(xs) { for(const auto &e : xs) cout << e << \" \"; cout << \"\\n\"; }\n#define Coutyn(cond) Cout((cond) ? \"yes\" : \"no\")\n#define CoutYn(cond) Cout((cond) ? \"Yes\" : \"No\")\n#define CoutYN(cond) Cout((cond) ? \"YES\" : \"NO\")\n#define vc vector\n#define Mini(a, x) a = min(a, x)\n#define Maxi(a, x) a = max(a, x)\n\nconstexpr int MOD = 998244353;\n\nconstexpr int COMB_MAX = 3e6;\nll fac[COMB_MAX], finv[COMB_MAX], inv[COMB_MAX];\n\nvoid initComb(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < COMB_MAX; i ++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\nll comb(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nint main(void){\n    Cin(int, n, m);\n    initComb();\n    \n    ll ans = comb(3*m+n-1, 3*m);\n    //Cout(ans);\n    for(int i = 2*m+1; i <= 3*m; i ++){\n        ll d = comb(3*m-i+n-2, 3*m-i) * n % MOD;\n        ans = (ans + MOD - d) % MOD;\n        //Cout(\"i = \", i, \" : \", d);\n    }\n\n    Cout(ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#include <fstream>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\n\n#define INF 1e9+7\n#define LLINF 1e18+7\n#define N 3000000\nll MOD=998244353;\n\nll inv[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=((-(MOD/i)*inv[MOD%i])%MOD+MOD)%MOD;\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=i*prd[i-1]%MOD;\n        invprd[i]=inv[i]*invprd[i-1]%MOD;\n    }\n    return ;\n}\nll cmb(ll a,ll b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return prd[a]*invprd[b]%MOD*invprd[a-b]%MOD;\n}\nll modpow(ll x,ll n){\n    if(n==0) return 1;\n    ll res=modpow(x*x%MOD,n/2);\n    if(n&1) res=res*x%MOD;\n    return res;\n}\n\nmain(){\n    calc_inv();\n    calc_product();\n    ll n=lin(),m=lin();\n    ll ans=0;\n    ans=cmb(m*3ll+n-1ll,n-1ll);\n    rep2(x,1,m){\n        ans=(ans+MOD-n*cmb(m+n-x-2ll,n-2ll)%MOD)%MOD;\n        if(cmb(m+n-x-2ll,n-2ll)<0)cout<<0000;\n        if(n*cmb(m+n-x-2ll,n-2ll)<0)cout<<000;\n        //cout<<ans<<endl;\n    }\n    ll t=-1;\n    ll p=m,q=m;\n    rep2(x,m+1,(ll)min(m*3,n)){\n        \n        if(x>n)break;\n        //ans=(ans+MOD-t*cmb(n,x)*cmb(p-q-1,q-1)%MOD)%MOD;\n        if(n==x){\n            if(m*3==n)\n            ans=(ans+MOD+t*cmb(p,q)%MOD)%MOD;\n            //cout<<ans<<endl;\n        }\n        if((m*3-x)%2)continue;\n        ans=(ans+MOD+t*cmb(n,x)%MOD*cmb((m*3-x)/2+n-1,n-1)%MOD)%MOD;\n    }\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <tuple>\n#include <vector>\nusing ll = int64_t;\nclass range {private: struct I{ll x;ll operator*(){return x;}bool operator!=(I& lhs){return x<lhs.x;}void operator++(){++x;}};I i,n;\npublic:range(ll n):i({0}),n({n}){}range(ll i,ll n):i({i}),n({n}){}I& begin(){return i;}I& end(){return n;}};\nusing namespace std;\nconstexpr ll mod = 998244353;\n\n// Modulo calculus\n\n// With Montgomery multiply\n// Mod < 2^32, odd number\nconstexpr ll ceil_log2(ll x) {\n  ll y = 0;\n  while (x) {\n    ++y;\n    x /= 2;\n  }\n  return y;\n}\n\nconstexpr ll calc_np(const ll Mod, const ll R) {\n  ll res = 0;\n  ll t = 0;\n  ll r = R;\n  ll i = 1;\n  while (r > 1) {\n    if ((t % 2) == 0) {\n      t += Mod;\n      res += i;\n    }\n    t /= 2;\n    r /= 2;\n    i *= 2;\n  }\n  return res;\n}\n\ntemplate <ll Mod>\nclass ModIntMR {\n public:\n  explicit constexpr ModIntMR(const ll x) : data(reduction(x * R2)) {}\n  ModIntMR<Mod>& operator=(const ModIntMR<Mod>& that) {\n    data = that.data;\n    return *this;\n  }\n  explicit operator ll() const { return reduction(data); }\n  ModIntMR<Mod>& operator+=(const ModIntMR<Mod>& that) {\n    data += that.data;\n    if (data >= Mod) data -= Mod;\n    return *this;\n  }\n  ModIntMR<Mod>& operator-=(const ModIntMR<Mod>& that) {\n    data -= that.data;\n    if (data < 0) data += Mod;\n    return *this;\n  }\n  ModIntMR<Mod>& operator*=(const ModIntMR<Mod>& that) {\n    data = reduction(data * that.data);\n    return *this;\n  }\n  friend ModIntMR<Mod> operator+(ModIntMR<Mod> lhs, const ModIntMR<Mod>& rhs) {\n    lhs += rhs;\n    return lhs;\n  }\n  friend ModIntMR<Mod> operator-(ModIntMR<Mod> lhs, const ModIntMR<Mod>& rhs) {\n    lhs -= rhs;\n    return lhs;\n  }\n  friend ModIntMR<Mod> operator*(ModIntMR<Mod> lhs, const ModIntMR<Mod>& rhs) {\n    lhs *= rhs;\n    return lhs;\n  }\n  friend ModIntMR<Mod> operator^(ModIntMR<Mod> lhs, const ll rhs) {\n    if (rhs == 0) return ModIntMR<Mod>(1);\n    else if ((rhs % 2) == 1) return (lhs ^ (rhs-1)) * lhs;\n    else {\n      const auto half = lhs ^ (rhs / 2);\n      return half * half;\n    }\n  }\n  ModIntMR<Mod>& operator^=(const ll that) {\n    data = (*this ^ that).data;\n    return *this;\n  }\n private:\n  ll data;\n  static constexpr ll shift = ceil_log2(Mod);\n  static constexpr ll R = 1ll << shift;\n  static constexpr ll mask = R-1;\n  static constexpr ll R2 = R*R%Mod;\n  static constexpr ll Np = calc_np(Mod, R);\n  static constexpr ll reduction(const ll T) {\n    ll t = (T + ((T*Np)&mask)*Mod)>>shift;\n    return t >= Mod ? t - Mod : t;\n  }\n};\n\nusing modint = ModIntMR<mod>;\n\nll inv(ll a,ll p){\n  return ( a == 1 ? 1 : (1 - p*inv(p%a,a)) / a + p );\n}\n\nvector<modint> fact(2500001, modint(0));\nvector<modint> factinv(2500001, modint(0));\n\nmodint comb(ll n, ll k) {\n  const auto tmp = fact[n] * factinv[k];\n  return tmp * factinv[n-k];\n}\n \nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n,m;\n  cin>>n>>m;\n  ll mx = 3*m+n;\n  fact[0] = modint(1);\n  for (ll i : range(mx)) {\n    fact[i+1] = fact[i] * modint(i+1);\n  }\n  factinv[mx] = modint(inv(static_cast<ll>(fact[mx]), mod));\n  for (ll i = mx; i > 0; --i) {\n    factinv[i-1] = factinv[i] * modint(i);\n  }\n  modint tmp = comb(3*m+n-1, n-1);\n  modint sub(0);\n  for (ll i = 2*m+1; i <= 3*m; ++i) {\n    sub += comb(3*m-i+n-2, n-2);\n  }\n  sub *= modint(n);\n  modint mno(0);\n  for (ll i = m+1; i <= n; ++i) {\n    ll rem = 3*m-i;\n    if (rem < 0 || (rem%2) == 1) continue;\n    mno += comb(rem/2+n-1, n-1) * comb(n, i);\n  }\n  modint res = tmp - sub - mno;\n  cout << static_cast<ll>(res) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int _ = 3e6 + 7 , MOD = 998244353;\nint jc[_] , inv[_] , N , M;\n\nint poww(long long a , int b){\n\tint times = 1;\n\twhile(b){if(b & 1) times = times * a % MOD; a = a * a % MOD; b >>= 1;}\n\treturn times;\n}\n\nvoid init(int mx){\n\tjc[0] = 1; for(int i = 1 ; i <= mx ; ++i) jc[i] = 1ll * jc[i - 1] * i % MOD;\n\tinv[mx] = poww(jc[mx] , MOD - 2);\n\tfor(int i = mx - 1 ; i >= 0 ; --i) inv[i] = inv[i + 1] * (i + 1ll) % MOD;\n}\n\nint binom(int p , int q){return p < q ? 0 : 1ll * jc[p] * inv[q] % MOD * inv[p - q] % MOD;}\n\nint main(){\n\tcin >> N >> M; init(3 * M + N); int sum = 0;\n\tfor(int i = 0 ; i <= N && i <= M ; ++i){\n\t\tif((3 * M - i) & 1) continue;\n\t\tsum = (sum + 1ll * binom(N , i) * binom((3 * M - i) / 2 + N - 1 , N - 1)) % MOD;\n\t}\n\tcout << (sum - 1ll * N * binom(M - 1 + N - 1 , N - 1) % MOD + MOD) % MOD; return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n// cout << fixed << setprecision(20);\n\n//拡張ユークリッドの互除法\nint extgcd(int a, int b, int &x, int &y) {\n    int d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1;\n        y = 0;\n    }\n    return d;\n}\n\n// mod逆元\nint mod_inverse(int a, int m) {\n    int x, y;\n    extgcd(a, m, x, y);\n    return (m + x % m) % m;\n}\n\n// 階乗、階乗逆元テーブル\nint fact[1600000], fact_inv[1600000], inv[1600000];\n\nint mod_fact(int n, int m) {\n    fact[0] = fact_inv[0] = 1;\n    inv[1] = 1;\n    for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i % m;\n        inv[i] = m - inv[m % i] * (m / i) % m;\n        fact_inv[i] = fact_inv[i - 1] * inv[i] % m;\n    }\n}\n\nint N, M;\nint mod = 998244353;\n\nint mod_C(int n, int r, int m) {\n    return fact[n] * mod_inverse(fact[r], m) % m * mod_inverse(fact[n - r], m) % m;\n}\n\nint mod_H(int n, int r, int m) {\n    return mod_C(n + r - 1, r, m);\n}\n\nsigned main() {\n    mod_fact(1600000, mod);\n    cin >> N >> M;\n    int ans = mod_H(N, 3 * M, mod);\n    for (int i = 0; i < M; i++) {\n        ans = (ans + mod - (mod_H(N - 1, i, mod) * N % mod)) % mod;\n    }\n    cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconstexpr int Q = 998244353;\n\nint rev(int x)\n{\n    int arr[3][3] = { {0, 1, Q}, {1, 0, x}, {-1, -1, -1} };\n    while(arr[1][2])\n    {\n        int r = arr[0][2] / arr[1][2];\n        for(int i = 0; i < 3; ++i)\n            arr[2][i] = arr[0][i] - r * arr[1][i];\n        for(int j = 0; j < 2; ++j)\n        for(int i = 0; i < 3; ++i)\n            arr[j][i] = arr[j + 1][i];\n    }\n    int ret = arr[0][0];\n    if(ret < 0) ret += Q;\n    return ret;\n}\n\nstruct modInt\n{\n    int n;\n\n    modInt(void) : n(0) {}\n    modInt(int x) : n(x) {}\n\n    operator int& (void) {return n;}\n\n    modInt& operator= (int x) { n = x % Q; return *this; }\n    modInt& operator+= (int x) { n += x; if(n >= Q) n -= Q; return *this; }\n    modInt& operator-= (int x) { n -= x; if(n < 0) n += Q; return *this; }\n    modInt& operator*= (int x) { n = (long long)n * x % Q; return *this; }\n    modInt& operator/= (int x) { return *this *= rev(x); }\n    modInt operator- (void) { modInt ret = Q - n; return ret; }\n    modInt operator+ (int x) { modInt ret = n; return ret += x; }\n    modInt operator- (int x) { modInt ret = n; return ret -= x; }\n    modInt operator* (int x) { modInt ret = n; return ret *= x; }\n    modInt operator/ (int x) { modInt ret = n; return ret /= x; }\n};\n\nmodInt fact[2020202];\n\nvoid iniFact(void)\n{\n    fact[0] = 1;\n    for(int i = 1; i < 2020202; ++i)\n        fact[i] = fact[i - 1] * i;\n}\n\nmodInt comb(modInt n, modInt r)\n{\n    if(n < r) return 0;\n    return fact[n] / (fact[n - r] * fact[r]);\n}\n\nint main()\n{\n    iniFact();\n\n    modInt n, m; cin >> n >> m;\n\n    modInt ans = 0;\n    for(modInt t = 0; t * 2 <= m; t += 1)\n    {\n        modInt s = m - t * 2;\n        modInt u = m + t;\n        ans += (comb(n + u - 1, u) - comb(n + t - 1, t) * n) * comb(n, s)\n               + comb(n + t - 2, t) * n * comb(n - 1, s);\n    }\n\n    cout << ans;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#define ll long long\n#define mod 998244353\n#define Mod1(x) (x>=mod?x-mod:x)\n#define Mod2(x) (x<0?x+mod:x)\n#define maxn 3000010\ninline ll read()\n{\n\tll x=0; char c=getchar(),f=1;\n\tfor(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n\tfor(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\ninline void write(ll x)\n{\n\tstatic int buf[20],len; len=0;\n\tif(x<0)x=-x,putchar('-');\n\tfor(;x;x/=10)buf[len++]=x%10;\n\tif(!len)putchar('0');\n\telse while(len)putchar(buf[--len]+'0');\n}\ninline void writeln(ll x){write(x); putchar('\\n');}\ninline void writesp(ll x){write(x); putchar(' ');}\nll fac[maxn],inv[maxn];\nint n,m;\ninline ll power(ll a,ll b)\n{\n\tll ans=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)ans=ans*a%mod;\n\treturn ans;\n}\ninline ll C(int n,int m){return fac[n]*inv[m]%mod*inv[n-m]%mod;}\ninline ll calc(int n,int m,int k)\n{\n\tll sum=0;\n\tfor(int i=0;i<=n&&i<=k;i++)\n\t\tif(!((m-i)&1)&&m>=i)sum=(sum+C(n,i)*C((m-i)/2+n-1,n-1))%mod;\n\t// writeln(sum);\n\treturn sum;\n}\nint main()\n{\n\tn=read(); m=read();\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=n+3*m;i++){\n\t\tfac[i]=fac[i-1]*i%mod;\n\t\tinv[i]=power(fac[i],mod-2);\n\t}\n\tll ans=(calc(n,3*m,m)-n*(calc(n,m,m)-calc(n-1,m,m)+mod))%mod;\n\twriteln(Mod2(ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\ntypedef long double ld;\n#define pb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define ALL(x) x.begin(), x.end()\n#define SZ(x) (ll)x.size()\n#define f first\n#define s second\nconst ll MOD = 998244353;\nconst ll INF = 1e9;\nconst ll MAXN = 2500100;\n\nll N,M;\nll fact[MAXN];\nll inv[MAXN];\n\nll exp(ll a, ll b){\n  if (b==0)return 1;\n  ll h=exp(a,b/2);\n  h=h*h%MOD;\n  if (b%2==1)return h*a%MOD;\n  return h;\n}\n\nll qinv (ll x){\n  return exp(x, MOD - 2);\n}\n\nll choose(ll a, ll b){\n  return fact[a] * inv[b]%MOD * inv[a-b] %MOD;\n}\n\nint main(){\n  cin>>N>>M;\n  fact[0] = 1;\n  for (int i=1;i<=3*M+N;++i){\n    fact[i] = fact[i-1]*i%MOD;\n  }\n  for (int i=0;i<=3*M+N;++i)inv[i] = qinv(fact[i]);\n  ll T = choose(M*3+N-1, N-1);\n  for (int i=2*M+1;i<=3*M;++i){\n    ll X = N*choose(M*3 - i+N-2, N-2)%MOD;\n    T = (MOD+T-X)%MOD;\n  }\n  cout<<T;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb           push_back\n#define pii          pair<int,int>\n#define vi           vector<int>\n#define vpii         vector<pair<int,int>>\n#define gph          map<int, vector<int>>\n#define mp           make_pair\n#define FOR(i, n) for (int i = 0; i <  (int)(n); i++)\n#define FOR1(i, n) for (int i = 1; i <= (int)(n); i++)\n#define FORD0(i, n) for (int i = (int)n; i >= 0; i--)\n#define FORD1(i, n) for (int i = (int)n; i >= 1; i--)\n#define FORS(i, n) for(; i < (int)(n); i++)\n#define debug(X) { cout << #X << \" = \" << (X) << endl; }\n#define printArr(A,n) { cout << #A << \" = \"; FOR(i,n) cout << A[i] << ' '; cout << endl; }\nusing namespace std;\n#define int long long int\nconst int mod = 998244353;\nvector<int> fac;\nlong long inv(long long a, long long b = mod){\n return 1<a ? b - inv(b%a,a)*b/a : 1;\n}\nint choose(int a, int b){\n//    cout << a << \" \" << b <<endl;\n    assert(b <= a && b >= 0);\n    int ans = fac[a] * inv(fac[b]);\n    assert(ans >= 0);\n    ans %= mod;\n    ans *= inv(fac[a-b]);\n    assert(ans >= 0);\n    ans %= mod;\n    assert(ans >= 0);\n    return ans;\n}\nsigned main(){\n    ios_base::sync_with_stdio(false);cin.tie(NULL);\n    \n    int n,m;cin >> n >> m;\n    fac.resize(n+m*5 + 2);\n    fac[0] = 1;\n    FOR1(i, n+m*5)fac[i] = fac[i-1]*i, fac[i] %= mod;\n\n    int ans = choose(n-1 + 3*m, n-1);\n    int tot = 0;\n    for(int odds = 0; odds<= min(n, m*3); odds++){\n        if((3*m - odds) % 2)continue;\n        int dist = choose(n, odds);\n        int remains = 3*m - odds; \n        int toSub = choose((remains/2) + n-1, n-1);\n    //    cout << odds << \" \" << dist << \" \" << toSub <<endl;\n        tot += toSub*dist;\n        tot %= mod;\n    }\n    assert(tot == ans);\n    ans -= choose(m-1 + n-1, n-1)*n;\n    ans %= mod;\n    for(int odds = m+1; odds <= min(n, 3*m); odds++){\n        if((3*m - odds) % 2)continue;\n        //debug(odds);\n        int distribute = choose(n, odds);\n        int remains = 3*m - odds; \n\n        int toSub = choose((remains/2) + n-1, n-1);\n        //cout << odds << \" \" << distribute << \" \" << toSub <<endl;\n        int temp = toSub * distribute;\n        temp %= mod;\n        ans -= temp;\n        ans %= mod;\n        while(ans < 0)ans += mod;\n    }\n    //debug(ans);\n    while(ans < 0)ans += mod;\n    cout <<ans;\n\n}"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#define ll long long\n#define inf 20021225\n#define mdn 998244353\n#define N 3000001\nusing namespace std;\nint read()\n{\n\tint s=0,f=1; char ch=getchar();\n\twhile(ch<'0' || ch>'9')\t{if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn f*s;\n}\nint fac[N],inv[N];\nvoid upd(int &x,int y){x+=x+y>=mdn?y-mdn:y;}\nint ksm(int bs,int mi)\n{\n\tint ans=1;\n\twhile(mi)\n\t{\n\t\tif(mi&1)\tans=1ll*ans*bs%mdn;\n\t\tbs=1ll*bs*bs%mdn; mi>>=1;\n\t}\n\treturn ans;\n}\nvoid init(int n)\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)\tfac[i]=1ll*fac[i-1]*i%mdn;\n\tinv[n]=ksm(fac[n],mdn-2);\n\tfor(int i=n;i;i--)\t\tinv[i-1]=1ll*inv[i]*i%mdn;\n}\nint C(int n,int m)\n{\n\tif(n<m)\treturn 0;\n\treturn 1ll*fac[n]*inv[n-m]%mdn*inv[m]%mdn;\n}\nint F(int n,int m,int k)\n{\n\tint top=min(n,k),ans=0;\n\tfor(int i=0;i<=top;i++)\tif(!((m-i)&1) && m>=i)\n\t\tupd(ans,1ll*C(n,i)*C(n-1+(m-i)/2,n-1)%mdn);\n\treturn ans;\n}\nint main()\n{\n\tint n=read(),m=read(); init(n+3*m);\n\tint ans=F(n,m*3,m)-1ll*n*(F(n,m,m)-F(n-1,m,m))%mdn;\n\tprintf(\"%d\\n\",(ans+mdn)%mdn);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define For(i,n) for(ll i=0;i<(n);i++)\n#define For1(i,n) for(ll i=1;i<(n);i++)\n#define MOD 998244353\n#define MAX 2000000\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nint main(void){\n    COMinit();\n    ll n,m;cin>>n>>m;\n    ll ans=0;\n    ll minus=0;\n    for(ll i=m%2;i<=min(n,m);i+=2){\n        ans=(ans+COM(n,i)*COM(n-1+(3*m-i)/2,n-1))%MOD;\n    }\n    //cout<<ans<<endl;\n    for(ll i=m%2;i<=min(n,m);i+=2){\n        minus=(minus+COM(n,i)*COM(n-1+(m-i)/2,n-1))%MOD;\n    }\n    //cout<<ans<<endl;\n    for(ll i=m%2;i<=min(n-1,m);i+=2){\n        minus=(minus-COM(n-1,i)*COM(n-2+(m-i)/2,n-2))%MOD;\n    }    \n    cout<<(ans-n*minus)%MOD<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define all(a) a.begin(), a.end()\n#define rep(i, st, n) for (int i = (st); i < (n); ++i)\n \nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\nusing pll = pair<long long, long long>;\nusing ld = long double;\n \ntemplate <typename T1, typename T2> bool chkmin(T1 &x, T2 y) { return y < x ? (x = y, true) : false; }\ntemplate <typename T1, typename T2> bool chkmax(T1 &x, T2 y) { return y > x ? (x = y, true) : false; }\n\nconst int MAXN = 4000006;\nconst int MOD = 998244353;\nint add(int x, int y)\n{\n    x += y;\n    if (x >= MOD) x -= MOD;\n    return x;\n}\nvoid vadd(int &x, int y)\n{\n    x += y;\n    if (x >= MOD) x -= MOD;\n}\nint sub(int x, int y)\n{\n    x -= y;\n    if (x < 0) x += MOD;\n    return x;\n}\nint mult(int x, int y)\n{\n    return x * (ll)y % MOD;\n}\nint fact[MAXN];\nint rfact[MAXN];\nint rev[MAXN];\nint bpow(int x, ll y)\n{\n    int res = 1;\n    for (; y; y >>= 1, x = mult(x, x))\n    {\n        if (y & 1) res = mult(res, x);\n    }\n    return res;\n}\nint cnk(int n, int k)\n{\n    if (n < k) return 0;\n    return mult(fact[n], mult(rfact[n - k], rfact[k]));\n}\n\nsigned main()\n{\n#ifdef DEBUG\n    freopen(\"in\", \"r\", stdin);\n#endif\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    \n    fact[0] = rfact[0] = fact[1] = rfact[1] = 1;\n    rev[1] = 1;\n    for (int i = 2; i < MAXN; ++i)\n    {\n        rev[i] = MOD - mult(rev[MOD % i], MOD / i);\n        //rev[i] = bpow(i, MOD - 2);\n        fact[i] = mult(fact[i - 1], i);\n        rfact[i] = mult(rfact[i - 1], rev[i]);\n    }\n\n    int n, m;\n    cin >> n >> m;\n    int Ans = 0;\n    for (int d = 0; d <= min(n, m); ++d)\n    {\n        int s = 3 * m - d;\n        if (s & 1) continue;\n        int ans = 0;\n        vadd(ans, cnk(s / 2 + n - 1, n - 1));\n        if (d >= 1)\n        {\n            ans = sub(ans, mult(d, cnk(s / 2 - m + n - 2, n - 2)));\n        }\n        ans = sub(ans, mult(n, cnk(s / 2 - m - 1 + n - 1, n - 1)));\n        vadd(Ans, mult(ans, cnk(n, d)));\n    }\n    cout << Ans << '\\n';\n          \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i, n) for (ll i = 0; i < ll(n); ++i)\n#define RREP(i, n) for (ll i = ll(n) - 1; i >= 0; --i)\n#define FOR(i, m, n) for (ll i = m; i < ll(n); ++i)\n#define RFOR(i, m, n) for (ll i = ll(n) - 1; i >= ll(m); --i)\n#define ALL(v) (v).begin(), (v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nconstexpr int dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T &a, const T &b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n#include \"bits/stdc++.h\"\ntemplate <int mod, bool isPrime = false> class Mint {\n\tusing ll = long long;\n\tll value;\n\n  public:\n\tconstexpr Mint() : value(0){};\n\tconstexpr Mint(ll x) : value(x) {\n\t\tvalue %= mod;\n\t\tif (value < 0) value += mod;\n\t}\n\tconstexpr Mint(const Mint &other) : value(other.value) {}\n\n\tll &get() {\n\t\treturn value;\n\t}\n\tll get() const {\n\t\treturn value;\n\t}\n\n\tconstexpr Mint pow(ll n) {\n\t\tMint ret(1), tmp(value);\n\t\twhile (n) {\n\t\t\tif (n & 1) ret *= tmp;\n\t\t\tn >>= 1;\n\t\t\ttmp *= tmp;\n\t\t}\n\t\treturn ret;\n\t}\n\tconstexpr bool operator==(const Mint &a) const {\n\t\treturn value == a.value;\n\t}\n\tconstexpr bool operator!=(const Mint &a) const {\n\t\treturn value != a.value;\n\t}\n\tconstexpr Mint &operator=(const Mint &a) {\n\t\tvalue = a.value;\n\t\treturn *this;\n\t}\n\tconstexpr Mint &operator+=(const Mint &a) {\n\t\tif ((value += a.value) >= mod) value -= mod;\n\t\treturn *this;\n\t}\n\tconstexpr Mint &operator-=(const Mint &a) {\n\t\tif ((value += mod - a.value) >= mod) value -= mod;\n\t\treturn *this;\n\t}\n\tconstexpr Mint &operator*=(const Mint &a) {\n\t\tvalue = value * a.value % mod;\n\t\treturn *this;\n\t}\n\n\tconstexpr Mint &operator/=(const Mint &a) {\n\t\treturn *this *= inv(a);\n\t}\n\tconstexpr Mint operator+(const Mint &a) const {\n\t\treturn Mint(*this) += a;\n\t}\n\tconstexpr Mint operator-(const Mint &a) const {\n\t\treturn Mint(*this) -= a;\n\t}\n\tconstexpr Mint operator*(const Mint &a) const {\n\t\treturn Mint(*this) *= a;\n\t}\n\tconstexpr Mint operator/(const Mint &a) const {\n\t\treturn Mint(*this) /= a;\n\t}\n};\ntemplate <int mod, bool isPrime>\nstd::ostream &operator<<(std::ostream &os, const Mint<mod, isPrime> &m) {\n\tos << m.get();\n\treturn os;\n}\ntemplate <int mod, bool isPrime>\nstd::istream &operator>>(std::istream &is, Mint<mod, isPrime> &m) {\n\tis >> m.get();\n\treturn is;\n}\n\ntemplate <int mod> constexpr Mint<mod, true> inv(const Mint<mod, true> &m) {\n\tlong long a = m.get(), b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b;\n\t\tstd::swap(a, b);\n\t\tu -= t * v;\n\t\tstd::swap(u, v);\n\t}\n\treturn Mint<mod, true>(u);\n}\n\ntemplate <int mod, bool isPrime>\nconstexpr Mint<mod, isPrime> operator+(long long lhs,\n                                       const Mint<mod, isPrime> &a) {\n\treturn Mint<mod, isPrime>(lhs + a.get());\n}\n\ntemplate <int mod, bool isPrime>\nconstexpr Mint<mod, isPrime> operator-(long long lhs,\n                                       const Mint<mod, isPrime> &a) {\n\treturn Mint<mod, isPrime>(lhs - a.get());\n}\n\ntemplate <int mod, bool isPrime>\nconstexpr Mint<mod, isPrime> operator*(long long lhs,\n                                       const Mint<mod, isPrime> &a) {\n\treturn Mint<mod, isPrime>(lhs % mod * a.get());\n}\n\nconstexpr int default_mod = 998244353;\nusing mint = Mint<default_mod, true>;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, m;\n\tcin >> n >> m;\n\tvector<mint> fact(3 * m + n + 1), rfact(3 * m + n + 1);\n\tfact[0] = 1;\n\tREP(i, fact.size() - 1) fact[i + 1] = fact[i] * (i + 1);\n\trfact.back() = inv(fact.back());\n\tRREP(i, rfact.size() - 1) rfact[i] = rfact[i + 1] * (i + 1);\n\n\tauto comb = [&](int a, int b) { return fact[a] * rfact[b] * rfact[a - b]; };\n\tauto solve = [&](int n, int sum) {\n\t\tmint ans = 0;\n\t\tfor (int i = 0; i <= min(n, m); ++i) {\n\t\t\tif ((sum - i) % 2 == 1) continue;\n\t\t\tans += comb((sum - i) / 2 + n - 1, n - 1) * comb(n, i);\n\t\t}\n\t\treturn ans;\n\t};\n\tcout << solve(n, 3 * m) - n * (solve(n, m) - solve(n - 1, m)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n//#include \"boost/multiprecision/cpp_int.hpp\"\n//typedef boost::multiprecision::cpp_int ll;\ntypedef long double dd;\n//#define i_7 (ll)(1E9+7)\n#define i_7 998244353\n#define i_5 i_7-2\n\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\ntypedef pair<ll,ll> l_l;\ntypedef pair<dd,dd> d_d;\nll inf=(ll)1E16;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\ndd EPS=1E-9;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n//template<class T>void max(T a,T b){if(a<b)return b;else return a;}\n//template<class T>void min(T a,T b){if(a>b)return b;else return a;}\n//template<class T>bool Max(T&a, T b){if(a < b){a = b;return 1;}return 0;}\n//template<class T>bool Min(T&a, T b){if(a > b){a = b;return 1;}return 0;}\n\n//////////////////////////\n\n\nll po(ll i,ll p){\n    if(p==0)return 1;\n    else{\n        i=mod(i);\n        if(p==1)return i;\n        if(p%2==0)return po(mod(i*i),p/2);\n        return mod(i*po(i,p-1));\n    }\n}\nll bunbo(ll n){\n    return po(n,i_5);\n}\n\n\n#define N 6000004\nll kai[N];\nll kai2[N];\nvoid calc(){\n    kai[0]=1;\n    kai2[0]=1;\n    rep(i,1,N-1){\n        kai[i]=mod(kai[i-1]*i);\n    }\n    kai2[N-1]=po(kai[N-1],i_5);\n    for(ll i=N-2;i>=0;i--){\n        kai2[i]=mod(kai2[i+1]*(i+1));\n    }\n}\nll comb(ll n,ll k){\n    if(n<k)return 0;\n    if(n==0)return 1;\n    return mod(mod(kai[n]*kai2[n-k])*kai2[k]);\n}\n\nint main(){fastio\n    calc();\n    ll n,m;cin>>n>>m;\n    ll a1,a2=0,a3=0;\n    a1=comb(3*m+n-1,n-1);\n    rep(ma,2*m+1,3*m){\n        ll res=3*m-ma;\n        Add(a2,comb(res+n-2,n-2));\n    }\n    a2=mod(a2*n);\n    rep(i,m+1,3*m){\n        if((3*m-i)%2==1)continue;\n        if(n<i)continue;\n        ll res=(3*m-i)/2;\n        Add(a3,comb(n,i)*comb(res+n-1,n-1));\n    }\n    cout<<mod(a1-a2-a3)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst int N = (int)1e6 + 5, M = (int)5e5 + 5, mod = 998244353;\nint n, m, fact[4 * M], inv_fact[4 * M], ans;\n\nint add (int _a, int _b) {\n    _a += _b;\n    if (_a >= mod) _a -= mod;\n    return _a;\n}\n\nint multi (int _a, int _b) { return (int)( (ll)_a * _b % mod); }\n\nint bin_pow (int _a, int _n) {\n    int ret = 1;\n    for (; _n; _n >>= 1, _a = multi(_a, _a) ) if (_n & 1) ret = multi(ret, _a);\n    return ret;\n}\n\nint C (int _k, int _n) { return multi(fact[_n], multi(inv_fact[_k], inv_fact[_n - _k]) ); }\n\nint candy_distribution (int _n, int _sum) { return C(_n - 1, _sum + _n - 1); }\n\nint main () {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n    fact[0] = 1; for (int i = 1; i < 4 * M; ++i) fact[i] = multi(fact[i - 1], i);\n    inv_fact[4 * M - 1] = bin_pow(fact[4 * M - 1], mod - 2);\n    for (int i = 4 * M - 2; i >= 0; --i) inv_fact[i] = multi(inv_fact[i + 1], i + 1);\n\n    cin >> n >> m;\n\n    for (int n_odd = 0; n_odd <= m; ++n_odd) {\n        int rem = 3 * m - n_odd;\n        if (rem & 1) continue ;\n        rem >>= 1;\n        ans = add(ans, multi(C(n_odd, n), candy_distribution(n, rem) ) );\n    }\n\n    for (int exceed = 2 * m + 1; exceed <= 3 * m; ++exceed) {\n        int rem = 3 * m - exceed;\n        ans = add(ans, mod - multi(n, candy_distribution(n - 1, rem) ) );\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <list>\n \n// hloya template v25\n  \n// ░░░░░░░▄▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▄░░░░░░\n// ░░░░░░█░░▄▀▀▀▀▀▀▀▀▀▀▀▀▀▄░░█░░░░░\n// ░░░░░░█░█░▀░░░░░▀░░▀░░░░█░█░░░░░\n// ░░░░░░█░█░░░░░░░░▄▀▀▄░▀░█░█▄▀▀▄░\n// █▀▀█▄░█░█░░▀░░░░░█░░░▀▄▄█▄▀░░░█░\n// ▀▄▄░▀██░█▄░▀░░░▄▄▀░░░░░░░░░░░░▀▄\n// ░░▀█▄▄█░█░░░░▄░░█░░░▄█░░░▄░▄█░░█\n// ░░░░░▀█░▀▄▀░░░░░█░██░▄░░▄░░▄░███\n// ░░░░░▄█▄░░▀▀▀▀▀▀▀▀▄░░▀▀▀▀▀▀▀░▄▀░\n// ░░░░█░░▄█▀█▀▀█▀▀▀▀▀▀█▀▀█▀█▀▀█░░░\n// ░░░░▀▀▀▀░░▀▀▀░░░░░░░░▀▀▀░░▀▀░░░░\n  \n#include <bits/stdc++.h>\n#include <valarray>\nusing namespace std;\n  \nbool dbg = 0;\n  \nclock_t start_time = clock();\n#define current_time fixed<<setprecision(6)<<(ld)(clock()-start_time)/CLOCKS_PER_SEC\n  \n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n  \n#define ll long long\n#define ld long double\n#define pii pair<int,int>\n#define umap unordered_map<int, int>\n  \n#define files1 freopen(\"input.txt\",\"r\",stdin)\n#define files2 freopen(\"output.txt\",\"w\",stdout)\n#define files files1;files2\n#define fast_io ios_base::sync_with_stdio(0);cin.tie(0)\n  \n// #define endl '\\n'\n#define ln(i,n) \" \\n\"[(i) == (n) - 1]\n  \nvoid bad(string mes = \"Impossible\"){cout << mes;exit(0);}\nvoid bad(int mes){cout << mes;exit(0);}\n  \ntemplate<typename T>\nstring bin(T x, int st = 2){\n    string ans = \"\";\n    while (x > 0){\n        ans += char('0' + x % st);\n        x /= st;\n    }\n    reverse(ans.begin(), ans.end());\n    return ans.empty() ? \"0\" : ans;\n}\n  \ntemplate<typename T>\nvoid upmax(T& x, T y) {\n    x = max(x, y);\n}\n  \ntemplate<typename T>\nvoid upmin(T& x, T y) {\n    x = min(x, y);\n}\n \n// inline int popcount(int x){\n//     int count = 0;\n//     __asm__ volatile(\"POPCNT %1, %0;\":\"=r\"(count):\"r\"(x):);\n//     return count;\n// }\n  \ntemplate<typename T>\nT input(){\n    T ans = 0, m = 1;\n    char c = ' ';\n  \n    while (!((c >= '0' && c <= '9') || c == '-')) {\n        c = getchar();\n    }\n  \n    if (c == '-')\n        m = -1, c = getchar();\n    while (c >= '0' && c <= '9'){\n        ans = ans * 10 + (c - '0'), c = getchar();\n    }\n    return ans * m;\n}\n  \ntemplate<typename T> void read(T& a) { a = input<T>(); }\ntemplate<typename T> void read(T& a, T& b) { read(a), read(b); }\ntemplate<typename T> void read(T& a, T& b, T& c) { read(a, b), read(c); }\ntemplate<typename T> void read(T& a, T& b, T& c, T& d) { read(a, b), read(c, d); }\n  \nconst int inf = 1e9 + 20;\nconst short short_inf = 3e4 + 20;\nconst long double eps = 1e-6;\nconst int maxn = (int)3e6 + 12;//, base = 1e9 + 7;\nconst ll llinf = 2e18 + 5;\nconst double PI = acos(-1.0);\n \nconst int mod = 998244353;\n  \ntemplate<typename T>\nT binpow(T n, T s)\n{\n    if (s <= 0)\n        return 1LL;\n    if (s % 2 == 0){\n        T b = binpow(n, s / 2);\n        return ( 1LL * b * b ) % mod;\n    } else {\n        return (1LL* binpow(n, s - 1) * n) % mod;\n    }\n}\n\nint fact[maxn], inv[maxn];\n\nint c(int n, int k) {\n    return 1ll * fact[n] * inv[k]  % mod * inv[n - k] % mod;\n}\n\nint formula(int n, int sum) {\n    return c(sum + n - 1, n - 1);\n}\n\nint main() {\n    // files1;\n    fast_io;\n\n    fact[0] = 1;\n    inv[0] = 1;\n    for (int i = 1; i < maxn; i++) {\n        fact[i] = 1ll * fact[i - 1] * i % mod;\n        inv[i] = binpow(fact[i], mod - 2);\n    }\n\n    int n, m;\n    cin >> n >> m;\n\n    int res = formula(n, 3 * m);\n\n    for (int i = 2 * m + 1; i <= 3 * m; i++) {\n        res -= 1ll * formula(n - 1, 3 * m - i) * n % mod;\n        if (res < 0) res += mod;\n    }\n    cout << res;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int, int> pi;\n\n#define fi first\n#define se second\n\nint read() {\n  int res = 0, w = 1; char c = getchar();\n  while (!isdigit(c) && c != '-') c = getchar();\n  if (c == '-') c = getchar(), w = -1;\n  while (isdigit(c)) res = (res << 1) + (res << 3) + c - '0', c = getchar();\n  return res * w;\n}\n\nconst int Mod = 998244353;\n\nint add(int a, int b) { return (a += b) >= Mod ? a - Mod : a; }\n\nint sub(int a, int b) { return (a -= b) < 0 ? a + Mod : a; }\n\nint mul(int a, int b) { return 1ll * a * b % Mod; }\n\nint fast_pow(int a, int b) {\n  int res = 1;\n  for (; b; b >>= 1, a = mul(a, a))\n    if (b & 1) res = mul(res, a);\n  return res;\n}\n\nconst int N = 3e6 + 10;\n\nint fac[N], inv[N];\n\nvoid init(int n = N - 1) {\n  fac[0] = inv[0] = 1;\n  for (int i = 1; i <= n; i++) fac[i] = mul(fac[i - 1], i);\n  inv[n] = fast_pow(fac[n], Mod - 2);\n  for (int i = n - 1; i >= 1; i--) inv[i] = mul(inv[i + 1], i + 1);\n}\n\nint C(int a, int b) { return a >= b ? mul(fac[a], mul(inv[b], inv[a - b])) : 0;}\n\nint main() {\n#ifdef dream_maker\n//  freopen(\"tst.in\", \"r\", stdin);\n#else\n  //freopen(\".in\", \"r\", stdin);\n  //freopen(\".out\", \"w\", stdout);\n#endif\n  init();\n  int n = read(), m = read(), ans = 0;\n  for (int i = 0; i <= m; i++) if ((3 * m - i) & 1 ^ 1) {\n    ans = add(ans, mul(C(n, i), C(((3 * m - i) >> 1) + n - 1, n - 1)));\n  }\n  ans = sub(ans, mul(n, C(m - 1 + n - 1, n - 1)));\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n//#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC target(\"avx512f,avx512dq,avx512cd,avx512bw,avx512vl\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<int, int> Pi;\ntypedef vector<ll> Vec;\ntypedef vector<int> Vi;\ntypedef vector<string> Vs;\ntypedef vector<P> VP;\ntypedef vector<vector<ll>> VV;\ntypedef vector<vector<int>> VVi;\ntypedef vector<vector<vector<ll>>> VVV;\ntypedef vector<vector<vector<vector<ll>>>> VVVV;\n\n#define REP(i, a, b) for(ll i=(a); i<(b); i++)\n#define PER(i, a, b) for(ll i=(a); i>=(b); i--)\n#define rep(i, n) REP(i, 0, n)\n#define per(i, n) PER(i, n, 0)\nconst ll INF=1e18+18;\nconst ll MOD=998244353;\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\") << endl;\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\") << endl;\n#define ALL(v) v.begin(), v.end()\n#define rALL(v) v.rbegin(), v.rend()\n#define pb(x) push_back(x)\n#define mp(a, b) make_pair(a,b)\n#define Each(a,b) for(auto &a :b)\n#define REPM(i, mp) for (auto i = mp.begin(); i != mp.end(); ++i)\n#ifdef LOCAL\n#define dbg(x_) cerr << #x_ << \":\" << x_ << endl;\n#define dbgmap(mp) cerr << #mp << \":\"<<endl; for (auto i = mp.begin(); i != mp.end(); ++i) { cerr << i->first <<\":\"<<i->second << endl;}\n#define dbgarr(n,m,arr) rep(i,n){rep(j,m){cerr<<arr[i][j]<<\" \";}cerr<<endl;}\n#define dbgdp(n,arr) rep(i,n){cerr<<arr[i]<<\" \";}cerr<<endl;\n#define dbgmint(n,arr) rep(i,n){cerr<<arr[i].x<<\" \";}cerr<<endl;\n#define dbgarrmint(n,m,arr) rep(i,n){rep(j,m){cerr<<arr[i][j].x<<\" \";}cerr<<endl;}\n#else\n#define dbg(...)\n#define dbgmap(...)\n#define dbgarr(...)\n#define dbgdp(...)\n#define dbgmint(...)\n#define dbgarrmint(...)\n#endif\n#define out(a) cout<<a<<endl\n#define out2(a,b) cout<<a<<\" \"<<b<<endl\n#define vout(v) rep(i,v.size()){cout<<v[i]<<\" \";}cout<<endl\n#define Uniq(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define fi first\n#define se second\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &s, const pair<T1, T2> &p) { return s<<\"(\"<<p.first<<\", \"<<p.second<<\")\"; }\n\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,v.size())i>>v[j];return i;}\n\n// vector\ntemplate<typename T>\nostream &operator<<(ostream &s, const vector<T> &v) {\n    int len=v.size();\n    for(int i=0; i<len; ++i) {\n        s<<v[i];\n        if(i<len-1) s<<\"\t\";\n    }\n    return s;\n}\n\n// 2 dimentional vector\ntemplate<typename T>\nostream &operator<<(ostream &s, const vector<vector<T> > &vv) {\n    int len=vv.size();\n    for(int i=0; i<len; ++i) {\n        s<<vv[i]<<endl;\n    }\n    return s;\n}\n\nstruct mint {\n    ll x; // typedef long long ll;\n    mint(ll x=0):x((x%MOD+MOD)%MOD){}\n    mint operator-() const { return mint(-x);}\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += MOD-a.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    mint& operator*=(const mint a) { (x *= a.x) %= MOD; return *this;}\n    mint operator+(const mint a) const { return mint(*this) += a;}\n    mint operator-(const mint a) const { return mint(*this) -= a;}\n    mint operator*(const mint a) const { return mint(*this) *= a;}\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n\n    // for prime MOD\n    mint inv() const { return pow(MOD-2);}\n    mint& operator/=(const mint a) { return *this *= a.inv();}\n    mint operator/(const mint a) const { return mint(*this) /= a;}\n};\nistream& operator>>(istream& is, const mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\ntypedef vector<mint> Vmint;\n\nstruct combination {\n    vector<mint> fact, ifact;\n    combination(int n):fact(n+1),ifact(n+1) {\n        assert(n < MOD);\n        fact[0] = 1;\n        for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;\n        ifact[n] = fact[n].inv();\n        for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;\n    }\n    mint operator()(int n, int k) {\n        if (k < 0 || k > n) return 0;\n        return fact[n]*ifact[k]*ifact[n-k];\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout<<std::setprecision(10);\n\n    ll n,m;\n    cin>>n>>m;\n    //奇数がx個\n    mint ans = 0;\n    combination cb(3*(n+m));\n    rep(x,m+1){\n        if(x%2 != m%2) continue;\n        if(x>n)continue;\n        mint odd = cb(n,x);\n        mint even = cb((3*m-x)/2-1+n,n-1);\n        ans += odd*even;\n    }\n\n    rep(x,m+1){\n        if(x%2 != m%2) continue;\n        if(x>n)continue;\n        mint odd = cb(n,x);\n        //n-1 0になっては行けない要素が1つ 残りは0でも構わない\n        //-1 間を取るので-1\n        mint even = cb((m-x)/2 -1 +n,n-1);\n        ans -= odd*even*n;\n    }\n\n    //最初の要素が0の場合を引いてはいけないので、N-1の場合を足す\n    rep(x,m+1){\n        if(x%2 != m%2) continue;\n        if(x>n-1)continue;\n        mint odd = cb(n-1,x);\n        //n-1 0になっては行けない要素が1つ 残りは0でも構わない\n        //-1 間を取るので-1\n        mint even = cb((m-x)/2 -1 +n-1,n-2);\n        ans += odd*even*n;\n    }\n\n\n    out(ans);\n\n    return  0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define SZ(a) ((int)(a).size())\n#define LL long long\n#define X first\n#define ll long long\n#define Y second\nusing namespace std;\nconst int INF = 1000 * 1000 * 1000;\nconst LL LINF = INF * (LL)INF;\nconst int mod = 998244353;\n\n\nconst int MOD = 998244353;\nconst int MAXN = 1e6 + 10;\nconst int A = 26;\nint fact[2500005];\nint w[5000001];;\nint inv[2500005];\nint R[2000001];\nint t1[2000001],t2[2000001];\ntypedef vector<int> poly;\nconst int P = 998244353;\nint mult(int a , int b)\n{\n\treturn a * (LL)b % mod;\n}\nint add(int a , int b)\n{\n\treturn a + b >= mod ? a + b - mod : a + b;\n}\nint sub(int a , int b)\n{\n\treturn a - b < 0 ? a - b + mod : a - b;\n}\nint c(int n , int k)\n{\n\tif(n < k)\n\t\treturn 1;\n\treturn mult(fact[n] , mult(inv[k] , inv[n - k]));\n}\nint modPow(int a , int step)\n{\n\tint ans = 1;\n\twhile(step)\n\t{\n\t\tif(step & 1)\n\t\t\tans = mult(ans , a);\n\t\tstep >>= 1;\n\t\ta = mult(a , a);\n\t}\n\treturn ans;\n}\nint lim;\nnamespace fft {\n \n\tconst int mod = 998244353;\n\tconst int root = 15311432;\n\tconst int root_1 = 469870224;\n\tconst int root_pw = 1 << 23;\n \n\ttemplate<class T>\n\tT eea(T a, T b, T& x, T& y) {\n\t\tif (!b) {\n\t\t\tx = 1;\n\t\t\ty = 0;\n\t\t\treturn a;\n\t\t}\n\t\n\t\tT x1, y1;\n\t\tT g = eea(b, a % b, x1, y1);\n\t\tx = y1;\n\t\ty = x1 - (a / b) * y1;\n\t\treturn g;\n\t}\n \n\tint inverse(int n) {\n\t\tint x, y;\n\t\teea(n, mod, x, y);\n\t\tx %= mod;\n\t\tif (x < 0)\n\t\t\tx += mod;\n\t\treturn x;\n\t}\n \n\tvoid fft(vector<int>& a, bool invert) {\n\t\tint n = a.size();\n \n\t\tfor (int i = 1, j = 0; i < n; i++) {\n\t\t\tint bit = n >> 1;\n\t\t\tfor (; j & bit; bit >>= 1)\n\t\t\t\tj ^= bit;\n\t\t\tj ^= bit;\n \n\t\t\tif (i < j)\n\t\t\t\tswap(a[i], a[j]);\n\t\t}\n \n\t\tfor (int len = 2; len <= n; len <<= 1) {\n\t\t\tint wlen = invert ? root_1 : root;\n\t\t\tfor (int i = len; i < root_pw; i <<= 1)\n\t\t\t\twlen = 1LL * wlen * wlen % mod;\n \n\t\t\tfor (int i = 0; i < n; i += len) {\n\t\t\t\tint w = 1;\n\t\t\t\tfor (int j = 0; j < len / 2; j++) {\n\t\t\t\t\tint u = a[i+j], v = (int)(1LL * a[i+j+len/2] * w % mod);\n\t\t\t\t\ta[i+j] = u + v < mod ? u + v : u + v - mod;\n\t\t\t\t\ta[i+j+len/2] = u - v >= 0 ? u - v : u - v + mod;\n\t\t\t\t\tw = 1LL * w * wlen % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t\tif (invert) {\n\t\t\tint n_1 = inverse(n);\n\t\t\tfor (int& x : a)\n\t\t\t\tx = 1LL * x * n_1 % mod;\n\t\t}\n\t}\n}\n \nint pm(int x) {\n\tif (x < fft::mod - x) {\n\t\treturn x;\n\t} else {\n\t\treturn x - fft::mod;\n\t}\n}\n \nconst int FIELD = 131072;\n \nvector<int> poly_mul(vector<int> a, vector<int> b) {\n\tint n = a.size() + b.size() - 1;\n\tint m = 1;\n\twhile (m < n)\n\t\tm *= 2;\n\ta.resize(m);\n\tb.resize(m);\n \n\tif (a == b) {\n\t\tfft::fft(a, false);\n\t\tb = a;\n\t} else {\n\t\tfft::fft(a, false);\n\t\tfft::fft(b, false);\n\t}\n\tfor (int i=0; i<m; i++)\n\t\ta[i] = a[i] * 1ll * b[i] % fft::mod;\n\tfft::fft(a, true);\n\ta.resize(n);\n\treturn a;\n}\ninline int count(int n, int m)\n{\n\treturn c(n - 1 + m, m);\n}\n \nint jebu(int n, int odd, int m)\n{\n\treturn count(n, (3 * m - odd) / 2);\n}\n\n \n \nint dp[100][200];\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\t\n\tfact[0] = inv[0] = 1;\n\tfor(int i = 1; i <= 2500000; i++)\n\t{\n\t\tfact[i] = mult(fact[i - 1] , i);\n\t\tinv[i] = modPow(fact[i] , mod - 2);\n\t}\n\tint n , m;\n\tcin >> n >> m;\n\t\n\tint ans = c(n + 3 * m - 1 , n - 1);\n\tfor(int pzdc = 2 * m + 1; pzdc <= 3 * m; pzdc++)\n\t{\n\t\tans = sub(ans , mult(n , c(3 * m - pzdc + (n - 1) - 1 , n - 2)));\n\t}\n\t\n\t/*int odd = 0;\n\tfor(int cnt = m + 2; cnt <= n && cnt <= 3 * m; cnt += 2)\n\t{\n\t\tint coef = c(n, cnt);\n\t\tint here = jebu(n, cnt, m);\t\n\t\todd = add(odd, mult(coef, here));\n\t}*/\n\t//ans = sub(ans , odd);\n\t\n\tfor(int j = m + 1; j <= 3 * m; j ++)\n\t{\n\t\tif(j <= n && (3 * m - j) % 2 == 0)\n\t\t{\n\t\t\t\n\t\t\tint zalupa1 = mult(c(n , j) , c(n + (3 * m - j) / 2 - 1 , n - 1));\n\t\t\tans = sub(ans , zalupa1);\n\t\t}\n\t\t\t\n\t}\n\t\n\t\n\t/*for(int i = 1; i < n; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t{\n\t\t\t//if(i == 0 && j)\n\t\t\t\t//continue;\n\t\t\t//cerr << i << \" \" << j << \" \" << mult(c(i - 1 + j , i - 1) , c(n - 1 - i + m - 1 - j , m - 1 - j)) << endl;\n\t\t\tans2 = sub(ans2 , mult(c(i - 1 + j , i - 1) , c(n - 1 - i + m - 1 - j , m - 1 - j)));\n\t\t}*/\n\t/*dp[0][0] = 1;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = 0; j <= 3 * m; j++)\n\t\t{\n\t\t\tfor(int k = 0; k <= 2 * m; k++)\n\t\t\t{\n\t\t\t\tdp[i + 1][j + k] = add(dp[i][j] , dp[i + 1][j + k]);\n\t\t\t}\n\t\t}\n\t}*/\n\t\t\t\t\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define N 6000000\n\nconst LL mod=998244353;\nLL n,m,p,fac[N],ifac[N],ans;\n\nvoid upd(LL &x,LL y){\n\tx=(x+y%mod+mod)%mod;\n}\n\nLL inv(LL x){\n\treturn x==1?1:(mod-mod/x)*inv(mod%x)%mod;\n}\n\nLL C(LL x,LL y){\n\treturn x<y||y<0?0:fac[x]*ifac[y]%mod*ifac[x-y]%mod;\n}\n\nint main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tp=(n+m)*3;\n\tfac[0]=1; for (LL i=1;i<=p;++i) fac[i]=fac[i-1]*i%mod;\n\tifac[p]=inv(fac[p]); for (LL i=p-1;~i;--i) ifac[i]=ifac[i+1]*(i+1)%mod;\n\tfor (LL i=m&1;i<=m;i+=2){\n\t\tLL p=(m*3-i)/2,sum=0;\n\t\tupd(sum,C(p+n-1,n-1));\n\t\tupd(sum,-i*C(p-m+n-1,n-1));\n\t\tupd(sum,-(n-i)*C(p-(m+1)+n-1,n-1));\n\t\tupd(ans,sum*C(n,i));\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 998244353;\nlong long int fac[1000001],inv[1000001],cnt[1000001];\n\nlong long int C(int n,int k){\n\treturn fac[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nlong long int solve(int n,int m,int k){\n\tlong long int res = 0;\n\tfor(int i=0;i<=k;i++)\n\t\tif(n-i>=0&&(n-i)%2==0&&m>=i)\n\t\t\tres += C((n-i)/2+m-1,m-1) * C(m,i) % mod;\n\treturn res % mod;\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor(int i=2;i<=1000000;i++){\n\t\tfac[i]=fac[i-1]*i%mod;\n\t\tinv[i]=mod-mod/i*inv[mod%i]%mod;\n\t}\n\tfor(int i=2;i<=1000000;i++)\n\t\tinv[i]=inv[i-1]*inv[i]%mod;\n\tint n,m;\n\tcin>>n>>m;\n\tlong long int ans = solve(3*m,n,m) - (solve(m,n,m) - solve(m,n-1,m)) * n;\n\tcout<<(ans%mod+mod)%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...)\n#endif\n\ntemplate <long long mod>\nstruct modular {\n    long long value;\n    modular(long long x = 0) {\n        value = x % mod;\n        if (value < 0) value += mod;\n    }\n    modular& operator+=(modular other) {\n        if ((value += other.value) >= mod) value -= mod;\n        return *this;\n    }\n    modular& operator-=(modular other) {\n        if ((value -= other.value) < 0) value += mod;\n        return *this;\n    }\n    modular& operator*=(modular other) {\n        value = value * other.value % mod;\n        return *this;\n    }\n    modular& operator/=(modular other) {\n        long long a = 0, b = 1, c = other.value, m = mod;\n        while (c != 0) {\n            long long t = m / c;\n            m -= t * c;\n            swap(c, m);\n            a -= t * b;\n            swap(a, b);\n        }\n        a %= mod;\n        if (a < 0) a += mod;\n        value = value * a % mod;\n        return *this;\n    }\n    modular operator-() { return modular(-value); }\n    modular operator+(modular rhs) { return modular(*this) += rhs; }\n    modular operator-(modular rhs) { return modular(*this) -= rhs; }\n    modular operator*(modular rhs) { return modular(*this) *= rhs; }\n    modular operator/(modular rhs) { return modular(*this) /= rhs; }\n    bool operator==(modular rhs) { return value == rhs.value; }\n    bool operator!=(modular rhs) { return value != rhs.value; }\n    bool operator<(modular rhs) { return value < rhs.value; }\n};\ntemplate <long long mod>\nstring to_string(modular<mod> x) {\n    return to_string(x.value);\n}\ntemplate <long long mod>\nostream& operator<<(ostream& stream, modular<mod> x) {\n    x.value %= mod;\n    if (x.value < 0) x.value += mod;\n    return stream << x.value;\n}\ntemplate <long long mod>\nistream& operator>>(istream& stream, modular<mod>& x) {\n    stream >> x.value;\n    x.value %= mod;\n    if (x.value < 0) x.value += mod;\n    return stream;\n};\nconst long long mod = 998244353LL;\nusing mint = modular<mod>;\n\ninline mint pw(mint a, long long n) {\n    mint res = 1;\n    while (n > 0) {\n        if (n & 1) {\n            res *= a;\n        }\n        a *= a;\n        n >>= 1;\n    }\n    return res;\n}\nvector<mint> fact, finv;\ninline void cinit(int n) {\n    fact.resize(n, 1);\n    finv.resize(n, 1);\n    for (int i = 2; i < n; i++) {\n        fact[i] = fact[i - 1] * i;\n    }\n    finv[n - 1] /= fact[n - 1];\n    for (int i = n - 2; i >= 2; i--) {\n        finv[i] = finv[i + 1] * (i + 1);\n    }\n}\ninline mint C(int n, int k) {\n    if (n < k || k < 0 || n < 0) return 0;\n    return fact[n] * finv[k] * finv[n - k];\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m;\n    cin >> n >> m;\n    cinit(2000000);\n    mint ans = 0;\n    for (int a = m % 2; a <= min(n, m); a += 2) {\n        int cnt = (3 * m - a) / 2;\n        mint res = C(cnt + n - 1, n - 1);\n        res -= C(cnt - m + n - 1, n - 1) * a;\n        res -= C(cnt - (m + 1) + n - 1, n - 1) * (n - a);\n        res *= C(n, a);\n        ans += res;\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef _debug\n#define out(i) cout << #i << ' ' << i << ' '\n#else \n#define out(i) //\n#endif\nusing ll = long long;\nusing ull = unsigned long long;\nconst int maxn = 500001;\nconst int maxm = 1000001;\nconst int tomod = 998244353;\nll form(ll a){\n\tll v = a % tomod;\n\treturn v < 0 ? v + tomod : v;\n}\nll inv[maxm], fa[maxm];\nvoid init(){\n\tfa[0] = fa[1] = 1;\n\tinv[0] = inv[1] = 1;\n\tfor(int i = 2;i < maxm;++i){\n\t\tfa[i] = form(fa[i - 1] * (ll)i);\n\t\tinv[i] = form((tomod - tomod / i) * inv[tomod % i]);\n\t}\n\tfor(int i = 2;i < maxm;++i)inv[i] = form(inv[i] * inv[i - 1]);\n}\nll cof(int a, int b){\n\treturn form(fa[a] * form(inv[b] * inv[a - b]));\n} \nll solve(int n, int k, const int max_odd){\n\tll res = 0;\n\tfor(int o = 0;o <= max_odd;++o){\n\t\tif(((k-o)^1)&1){\n\t\t\tres = form(res + form(\n\t\t\t\tcof(n, o) * \n\t\t\t\tcof((k-o)/2+n-1, n-1)\n\t\t\t));\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tinit();\n\tll k, n;\n\tcin >> n >> k;\n\tll res = solve(n, k * 3, min(n, k));\n\tres -= form(n * solve(n, k, min(n, k)));\n\tres += form(n * solve(n - 1, k, min(n - 1, k)));\n\tcout << form(res) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\n#define bit(n) (1LL<<(n))\n#define INT(n) int n; cin >> n;\n#define LL(n) ll n; cin >> n;\n#define DOUBLE(n) double n; cin >> n;\nusing namespace std;\n\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 998244353;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\n// solve\ntemplate <typename T>\nT power(T a, T n, T mod) {\n  T res = 1;\n  T tmp = n;\n  T curr = a;\n  while(tmp){\n    if(tmp % 2 == 1){\n      res = (T)(res * curr % mod);\n    }\n    curr = (T)(curr * curr % mod);\n    tmp >>= 1;\n  }\n\n  return res;\n}\n\ntemplate<typename T>\nT gcd(T a, T b) {\n  if(a > b)return gcd(b, a);\n  if(a == 0)return b;\n  return gcd(b % a, a);\n}\n\ntemplate<typename T>\nT extgcd(T a, T b, T &x, T &y){ \n  T d = a;\n  if(b != 0){\n    d = extgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  }else{\n    x = 1, y = 0;\n  }\n  return d;\n}\n\ntemplate <typename T>\nT modinv(T a, T m){\n  long long x = 0, y = 0;\n  extgcd<long long>(a, m, x, y);\n  x %= m;\n  if(x < 0)x += m;\n  return x;\n}\nstruct Factorial{\n  int n;\n  const int MOD = 998244353;\n  vector<long long> fac;\n  vector<long long> inv_;\n  Factorial(int n): n(n){\n    fac.resize(n + 1);\n    inv_.resize(n + 1);\n    calc_factorial();\n    calc_inv();\n  }\n  void calc_factorial(){\n    fac[0] = 1;\n    for(int i = 1; i <= n; i++){\n      fac[i] = i * fac[i-1] % MOD;\n    }\n  }\n  void calc_inv(){\n    inv_[n] = power<long long>(fac[n], MOD - 2, MOD);\n    for(int i = n - 1; i >= 0; i--){\n      inv_[i] = (i + 1) * inv_[i+1] % MOD;\n    }\n  }\n  long long& operator[](size_t i){\n    if(i < 0 || i > n){\n      cerr << \"list index out of range\" << endl;\n      abort();\n    }\n    return fac[i];\n  }\n  long long inv(size_t i){\n    if(i < 0 || i > n){\n      cerr << \"list index out of range\" << endl;\n      abort();\n    }\n    return inv_[i];\n  }\n  long long comb(int n, int k){\n    if(n < 0 || k < 0)return 0;\n    if(n < k)return 0;\n    long long res = fac[n];\n    res = res * inv_[n-k] % MOD;\n    res = res * inv_[k] % MOD;\n    return res;\n  }\n  long long perm(int n, int k){\n    if(n < k)return 0;\n    long long res = fac[n];\n    res = res * inv_[n-k] % MOD;\n    return res;\n  }\n  long long h(int n, int k){\n    if(n == 0 && k == 0)return 1;\n    return comb(n + k - 1, k);\n  }\n};\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(20);\n  INT(n); INT(m);\n  Factorial fac(3500010);\n  ll res = fac.h(n, 3 * m);\n  ll tmp = fac.h(n, m - 1) * n % mod;\n  res = (res - tmp) % mod;\n  if(res < 0)res += mod;\n  for(int i = m + 1; i <= n; i++){\n    int rem = 3 * m - i;\n    if(rem % 2 == 1)continue;\n    ll tmp = fac.comb(n, i);\n    tmp = tmp * fac.h(n, rem / 2) % mod;\n    res = (res - tmp) % mod;\n    if(res < 0)res += mod;\n  }\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing ull=unsigned long long;\nusing uint=unsigned int;\nusing pcc=pair<char,char>;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing pdd=pair<double,double>;\nusing tuplis=pair<ll,pll>;\nusing tuplis2=pair<pll,ll>;\ntemplate<class T> using pq=priority_queue<T,vector<T>,greater<T>>;\nconst ll LINF=0x1fffffffffffffff;\nconst ll MINF=0x7fffffffffff;\nconst int INF=0x3fffffff;\nconst ll MOD=1000000007;\nconst ll MODD=998244353;\nconst ld DINF=numeric_limits<ld>::infinity();\nconst ld EPS=1e-9;\nconst vector<ll>four{0,1,0,-1,0};\n#define _overload4(_1,_2,_3,_4,name,...) name\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep1(n) for(ll i=0;i<n;++i)\n#define _rep2(i,n) for(ll i=0;i<n;++i)\n#define _rep3(i,a,b) for(ll i=a;i<b;++i)\n#define _rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) _overload4(__VA_ARGS__,_rep4,_rep3,_rep2,_rep1)(__VA_ARGS__)\n#define _rrep1(n) for(ll i=n-1;i>=0;i--)\n#define _rrep2(i,n) for(ll i=n-1;i>=0;i--)\n#define _rrep3(i,a,b) for(ll i=b-1;i>=a;i--)\n#define _rrep4(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rrep(...) _overload4(__VA_ARGS__,_rrep4,_rrep3,_rrep2,_rrep1)(__VA_ARGS__)\n#define each(i,a) for(auto &i:a)\n#define sum(...) accumulate(range(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(range(__VA_ARGS__),double(0))\n#define _range(i) (i).begin(),(i).end()\n#define _range2(i,k) (i).begin(),(i).begin()+k\n#define _range3(i,a,b) (i).begin()+a,(i).begin()+b\n#define range(...) _overload3(__VA_ARGS__,_range3,_range2,_range)(__VA_ARGS__)\n#define _rrange(i) (i).rbegin(),(i).rend()\n#define _rrange2(i,k) (i).rbegin(),(i).rbegin()+k\n#define _rrange3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rrange(...) _overload3(__VA_ARGS__,_rrange3,_rrange2,_rrange)(__VA_ARGS__)\n#define elif else if\n#define unless(a) if(!(a))\n#define mp make_pair\n#define mt make_tuple\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__));in(name)\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\ninline constexpr ll gcd(ll a,ll b){if(!a||!b)return 0;while(b){ll c=b;b=a%b;a=c;}return a;}\ninline constexpr ll lcm(ll a,ll b){if(!a||!b)return 0;return a*b/gcd(a,b);}\ntemplate<class T> inline constexpr T min(vector<T> &v){return *min_element(range(v));}\ninline char min(string &v){return *min_element(range(v));}\ntemplate<class T> inline constexpr T max(vector<T> &v){return *max_element(range(v));}\ninline char max(string &v){return *max_element(range(v));}\ninline constexpr ll intpow(ll a,ll b){ll ans=1;for(ll i=1;b;i*=2){if(b&i){b^=i;ans*=a;}a*=a;}return ans;}\ninline constexpr ll modpow(ll a,ll b,ll mod = MOD){ll ans=1;for(ll i=1;b;i*=2){if(b&i){b^=i;ans*=a;ans%=mod;}a*=a;a%=mod;}return ans;}\ntemplate<typename T>\ninline constexpr bool chmin(T &mn,const T &cnt){if(mn>cnt){mn=cnt;return 1;}else return 0;}\ntemplate<typename T>\ninline constexpr bool chmax(T &mx,const T &cnt){if(mx<cnt){mx=cnt;return 1;}else return 0;}\ntemplate<class T> unordered_map<T,ll> press(vector<T> &a){ auto b = a; sort(range(b)); b.erase(unique(range(b)), b.end()); unordered_map<T,ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\ntemplate<class T> map<T,ll> press_map(vector<T> &a){ auto b = a; sort(range(b)); b.erase(unique(range(b)), b.end()); map<T,ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\ninline int scan(){ return getchar(); }\ninline void scan(int &a){ scanf(\"%d\", &a); }\ninline void scan(unsigned &a){ scanf(\"%u\", &a); }\ninline void scan(long &a){ scanf(\"%ld\", &a); }\ninline void scan(long long &a){ scanf(\"%lld\", &a); }\ninline void scan(unsigned long long &a){ scanf(\"%llu\", &a); }\ninline void scan(char &a){ cin >> a; }\ninline void scan(float &a){ scanf(\"%f\", &a); }\ninline void scan(double &a){ scanf(\"%lf\", &a); }\ninline void scan(long double &a){ scanf(\"%Lf\", &a); }\ninline void scan(vector<bool> &vec){ for(unsigned i = 0; i < vec.size(); i++) { int a; scan(a); vec[i] = a; } }\ninline void scan(string &a){ cin >> a; }\ntemplate<class T> inline void scan(vector<T> &vec);\ntemplate<class T, size_t size> inline void scan(array<T, size> &vec);\ntemplate<class T, class L> inline void scan(pair<T, L> &p);\ntemplate<class T, size_t size> inline void scan(T (&vec)[size]);\ntemplate<class T> inline void scan(vector<T> &vec){ for(auto &i : vec) scan(i); }\ntemplate<class T, size_t size> inline void scan(array<T, size> &vec){ for(auto &i : vec) scan(i); }\ntemplate<class T, class L> inline void scan(pair<T, L> &p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> inline void scan(T (&vec)[size]){ for(auto &i : vec) scan(i); }\ntemplate<class T> inline void scan(T &a){ cin>>a; }\ninline void in(){}\ntemplate <class Head, class... Tail> inline void in(Head &head, Tail&... tail){ scan(head); in(tail...); }\ninline void print(){ putchar('\\n'); }\ninline void print(const bool &a){ printf(\"%d\", a); }\ninline void print(const int &a){ printf(\"%d\", a); }\ninline void print(const unsigned &a){ printf(\"%u\", a); }\ninline void print(const long &a){ printf(\"%ld\", a); }\ninline void print(const long long &a){ printf(\"%lld\", a); }\ninline void print(const unsigned long long &a){ printf(\"%llu\", a); }\ninline void print(const char &a){ printf(\"%c\", a); }\ninline void print(const char a[]){ printf(\"%s\", a); }\ninline void print(const float &a){ printf(\"%.10f\", a); }\ninline void print(const double &a){ printf(\"%.10f\", a); }\ninline void print(const long double &a){ printf(\"%.10Lf\", a); }\ntemplate<class T> void print(const vector<T> &vec);\ntemplate<class T, size_t size> void print(const array<T, size> &vec);\ntemplate<class T, class L> void print(const pair<T, L> &p);\ntemplate<class T, size_t size> inline void print(const T (&vec)[size]);\ntemplate<class T> void print(const vector<T> &vec){ if(vec.empty()) return; print(vec[0]); for(auto i = vec.begin(); ++i != vec.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size> &vec){ print(vec[0]); for(auto i = vec.begin(); ++i != vec.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L> &p){ print(p.first); putchar(' '); print(p.second); }\ntemplate<class T, size_t size> inline void print(const T (&vec)[size]){ print(vec[0]); for(auto i = vec; ++i != end(vec); ){ putchar(' '); print(*i); } }\ntemplate<class T> inline void print(const T &a){ cout << a; }\ninline int out(){ putchar('\\n'); return 0; }\ntemplate<class T> inline int out(const T &t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> inline int out(const Head &head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\ntemplate <class T> inline void err(T t){cerr<<t<<'\\n';}\ninline void err(){cerr<<'\\n';}\ninline int first(const bool &i){return out(i?\"first\":\"second\");}\ninline int yes(const bool &i){return out(i?\"yes\":\"no\");}\ninline int Yes(const bool &i){return out(i?\"Yes\":\"No\");}\ninline int YES(const bool &i){return out(i?\"YES\":\"NO\");}\ninline int Yay(const bool &i){return out(i?\"Yay!\":\":(\");}\ninline int Possible(const bool &i){return out(i?\"Possible\":\"Impossible\");}\ninline int POSSIBLE(const bool &i){return out(i?\"POSSIBLE\":\"IMPOSSIBLE\");}\ninline void Case(ll i){printf(\"Case #%lld: \",i);}\n\n\nconstexpr ll mod = MODD;\ninline constexpr ll extgcd(ll a, ll b, ll &x, ll &y){ ll g = a; x = 1; y = 0; if(b){ g = extgcd(b, a % b, y, x); y -= a / b * x; } return g; }\ninline constexpr ll invmod(ll a, ll m = mod){ ll x = 0, y = 0; extgcd(a, m, x, y); return (x + m) % m; }\nstruct Modint{\n    ll num;\n    constexpr Modint() : num() { num = 0; }\n    constexpr Modint(ll x) : num() { num = x % mod; if(num < 0) num += mod; }\n    inline constexpr Modint& operator= (int x){ num = x % mod; if(num < 0) num += mod; return *this; }\n    inline constexpr Modint& operator= (ll x){ num = x % mod; if(num < 0) num += mod; return *this; }\n    inline constexpr Modint& operator= (Modint x){ num = x.num; return *this; }\n    inline constexpr Modint operator+ (int x) const { return Modint(num + x); }\n    inline constexpr Modint operator+ (ll x) const { return Modint(num + x); }\n    inline constexpr Modint operator+ (Modint x) const { ll a = num + x.num; if(a >= mod) a -= mod; return Modint{a}; }\n    inline constexpr Modint& operator+=(int x){ num += x; num %= mod; if(num < 0) num += mod; return *this; }\n    inline constexpr Modint& operator+=(ll x){ num += x; num %= mod; if(num < 0) num += mod; return *this; }\n    inline constexpr Modint& operator+=(Modint x){ num += x.num; if(num >= mod) num -= mod; return *this; }\n    inline constexpr Modint& operator++(){ if(num == mod - 1) num = 0; else num++; return *this; }\n    inline constexpr Modint operator++(int){ Modint ans = *this; if(num == mod - 1) num = 0; else num++; return ans; }\n    inline constexpr Modint operator- () const { if(num == 0) return 0; return Modint(mod - num); }\n    inline constexpr Modint operator- (int x) const { return Modint(num - x); }\n    inline constexpr Modint operator- (ll x) const { return Modint(num - x); }\n    inline constexpr Modint operator- (Modint x) const { ll a = num - x.num; if(a < 0) a += mod; return Modint{a}; }\n    inline constexpr Modint& operator-=(int x){ num -= x; num %= mod; if(num < 0) num += mod; return *this; }\n    inline constexpr Modint& operator-=(ll x){ num -= x; num %= mod; if(num < 0) num += mod; return *this; }\n    inline constexpr Modint& operator-=(Modint x){ num -= x.num; if(num < 0) num += mod; return *this; }\n    inline constexpr Modint& operator--(){ if(num == 0) num = mod - 1; else num--; return *this; }\n    inline constexpr Modint operator--(int){ Modint ans = *this; if(num == 0) num = mod - 1; else num--; return ans; }\n    inline constexpr Modint operator* (int x) const { return Modint(num * (x % mod)); }\n    inline constexpr Modint operator* (ll x) const { return Modint(num * (x % mod)); }\n    inline constexpr Modint operator* (Modint x) const { return Modint{num * x.num % mod}; }\n    inline constexpr Modint& operator*=(int x){ num *= Modint(x); num %= mod; return *this; }\n    inline constexpr Modint& operator*=(ll x){ num *= Modint(x); num %= mod; return *this; }\n    inline constexpr Modint& operator*=(Modint x){ num *= x.num; num %= mod; return *this; }\n    inline constexpr Modint operator/ (int x) const { return Modint(num * invmod(Modint(x), mod)); }\n    inline constexpr Modint operator/ (ll x) const { return Modint(num * invmod(Modint(x), mod)); }\n    inline constexpr Modint operator/ (Modint x) const { return Modint{num * invmod(x.num, mod) % mod}; }\n    inline constexpr Modint& operator/=(int x){ num *= invmod(Modint(x), mod); num %= mod; return *this; }\n    inline constexpr Modint& operator/=(ll x){ num *= invmod(Modint(x), mod); num %= mod; return *this; }\n    inline constexpr Modint& operator/=(Modint x){ num *= invmod(x.num, mod); num %= mod; return *this; }\n    inline constexpr Modint pow(ll x) const { ll i = 1; Modint ans = 1, cnt = *this; while(i <= x){ if(x & i){ ans *= cnt; x ^= i; } cnt *= cnt; i *= 2; } return ans; }\n    inline constexpr operator ll() const { return num; }\n};\nstd::istream& operator>>(std::istream& is, Modint& x) { is >> x.num; x = Modint(x.num); return is; }\ninline constexpr Modint operator\"\"_M(ull x) { return Modint(x); }\nstd::vector<Modint> fac(1, 1), inv(1, 1);\ninline void reserve(ll a){\n    if(fac.size() >= a) return;\n    if(a < fac.size() * 2) a = fac.size() * 2;\n    if(a >= mod) a = mod;\n    while(fac.size() < a) fac.push_back(fac.back() * ll(fac.size()));\n    inv.resize(fac.size());\n    inv.back() = Modint(1) / fac.back();\n    for(ll i = inv.size() - 1; !inv[i - 1]; i--) inv[i - 1] = inv[i] * i;\n}\ninline Modint fact(ll n){ if(n < 0) return 0; reserve(n + 1); return fac[n]; }\ninline Modint perm(ll n, ll r){ if(r < 0 || n < r) return 0; reserve(n + 1); return fac[n] * inv[n - r]; }\ninline Modint comb(ll n, ll r){ if(r < 0 || n < r) return 0; reserve(n + 1); return fac[n] * inv[r] * inv[n - r]; }\ninline Modint Mcomb(ll n, ll r){ return comb(n + r - 1, n - 1); } // r個をn部屋に分ける\nsigned main(){\n    LL(n,m);\n    Modint ans=0;\n    rep(i,m&1,m+1,2){\n        ans+=comb(n,i)*Mcomb(n,(m*3-i)/2);\n        ans-=Mcomb(n,(m*3-i)/2-m)*comb(n,i)*i;\n        ans-=Mcomb(n,(m*3-i)/2-m-1)*comb(n,i)*(n-i);\n    }\n    out(ans);\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) (x).begin(), (x).end()\nusing namespace std;\ntypedef long long ll;\n\nconstexpr ll Mod = 998244353;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\n\ntemplate <typename T> constexpr bool chmax(T &a, const T b) {\n    if(a >= b) return false;\n    a = b;\n    return true;\n}\ntemplate <typename T> constexpr bool chmin(T &a, const T b) {\n    if(a <= b) return false;\n    a = b;\n    return true;\n}\n\n/*-------------------------------------------*/\n\ntemplate <int M> class ModInt {\n    int x;\n\n  public:\n    constexpr ModInt() : x(0) {}\n    constexpr ModInt(int64_t y) : x(y >= 0 ? y % M : (M - (-y) % M) % M) {}\n    constexpr ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= M) x -= M;\n        return *this;\n    }\n    constexpr ModInt &operator-=(const ModInt &p) {\n        if((x += M - p.x) >= M) x -= M;\n        return *this;\n    }\n    constexpr ModInt &operator*=(const ModInt &p) {\n        x = (int)(1LL * x * p.x % M);\n        return *this;\n    }\n    constexpr ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n    constexpr ModInt operator-() const { return ModInt(-x); }\n    constexpr ModInt operator+(const ModInt &p) const {\n        return ModInt(*this) += p;\n    }\n    constexpr ModInt operator-(const ModInt &p) const {\n        return ModInt(*this) -= p;\n    }\n    constexpr ModInt operator*(const ModInt &p) const {\n        return ModInt(*this) *= p;\n    }\n    constexpr ModInt operator/(const ModInt &p) const {\n        return ModInt(*this) /= p;\n    }\n    constexpr bool operator==(const ModInt &p) const { return x == p.x; }\n    constexpr bool operator!=(const ModInt &p) const { return x != p.x; }\n    constexpr ModInt inverse() const {\n        int a = x, b = M, u = 1, v = 0, t = 0;\n        while(b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n    constexpr ModInt pow(const int64_t &n) const {\n        ModInt ret(1), mul(x);\n        int64_t k = n % (M - 1);\n        while(k > 0) {\n            if(k & 1) ret *= mul;\n            mul *= mul;\n            k >>= 1;\n        }\n        return ret;\n    }\n    constexpr friend ostream &operator<<(ostream &os, const ModInt &p) {\n        return os << p.x;\n    }\n    constexpr friend istream &operator>>(istream &is, ModInt &a) {\n        int64_t t = 0;\n        is >> t;\n        a = ModInt(t);\n        return (is);\n    }\n};\nusing modint = ModInt<Mod>;\n\nvector<modint> fact, fact_inv;\n\nvoid COMinit(const ll MAX) {\n    fact.resize(MAX + 1);\n    fact_inv.resize(MAX + 1);\n    fact[0] = 1;\n    rep(i, MAX) fact[i + 1] = fact[i] * (i + 1);\n    fact_inv[MAX] = fact[MAX].inverse();\n    for(int i = MAX; i; i--)\n        fact_inv[i - 1] = fact_inv[i] * i;\n}\n\nmodint COM(const ll n, const ll k) {\n    if(n < k || k < 0) return 0;\n    return fact[n] * fact_inv[k] * fact_inv[n - k];\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    ll n, m;\n    cin >> n >> m;\n    COMinit(3 * m / 2 + n);\n\n    modint ans(0);\n    rep(i, m + 1) if((3 * m - i) % 2 == 0) ans +=\n        COM(n, i) * COM((3 * m - i) / 2 + n - 1, n - 1);\n\n    ans -= (COM(m + n - 1, m) - COM(m + n - 2, m)) * n;\n\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int mod = 998244353;\nconst int Maxn = 3000005;\n\nint fac[Maxn], inv[Maxn];\nint n, m;\nint res;\n\nint toPower(int a, int p)\n{\n    int res = 1;\n    while (p) {\n        if (p & 1) res = ll(res) * a % mod;\n        p >>= 1; a = ll(a) * a % mod;\n    }\n    return res;\n}\n\nint Inv(int x) { return toPower(x, mod - 2); }\n\nint C(int n, int k)\n{\n    if (n < 0 || k < 0 || k > n) return 0;\n    return ll(fac[n]) * inv[k] % mod * inv[n - k] % mod;\n}\n\nint main()\n{\n    fac[0] = inv[0] = 1;\n    for (int i = 1; i < Maxn; i++) {\n        fac[i] = ll(i) * fac[i - 1] % mod;\n        inv[i] = Inv(fac[i]);\n    }\n    scanf(\"%d %d\", &n, &m);\n    for (int x = 0; x <= n && x <= m; x++) if ((3 * m - x) % 2 == 0) {\n        int S = (3 * m - x) / 2;\n        // take m\n        res = (res + ll(n) * C(S - m + n - 2, n - 2) % mod * C(n - 1, x)) % mod;\n        // not take m\n        int av = m;\n        int ways = (C(S + n - 1, n - 1) - ll(n) * C(S - av + n - 1, n - 1) % mod + mod) % mod;\n        res = (res + ll(ways) * C(n, x)) % mod;\n    }\n    printf(\"%d\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "olphe"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\nusing namespace chrono;\n\n#ifdef DEBUG\n\t//~ #define LOCAL_INPUT_FILE\n#else\n\t//#define USE_FILE_IO\n#endif\n\n#ifdef USE_FILE_IO\n\t#define INPUT_FILE \"input.txt\"\n\t#define OUTPUT_FILE \"output.txt\"\n\t#define cin ____cin\n\t#define cout ____cout\n\tifstream cin(INPUT_FILE);\n\tofstream cout(OUTPUT_FILE);\n#else\n\t#ifdef LOCAL_INPUT_FILE\n\t\t#define cin ____cin\n\t\tifstream cin(\"input.txt\");\n\t#endif\n#endif\n\nconst int infinity = (int)1e9 + 42;\nconst int64_t llInfinity = (int64_t)1e18 + 256;\nconst int mod = 998244353; \nconst long double eps = 1e-8;\n\nmt19937_64 randGen(system_clock().now().time_since_epoch().count());\n\ninline void raiseError(string errorCode) {\n\tcerr << \"Error : \" << errorCode << endl;\n\texit(42);\n}\n\nconst int fMax = 1800 * 1000;\nint64_t f[fMax], rf[fMax];\n\nint64_t extGcd(int64_t a, int64_t b, int64_t &x, int64_t &y) {\n\tif (a == 0) {\n\t\tx = 0; y = 1;\n\t\treturn b;\n\t}\n\tint64_t x1, y1;\n\tint64_t g = extGcd(b % a, a, x1, y1);\n\tx = y1 - (b / a) * x1;\n\ty = x1;\n\treturn g;\n}\n\ninline int64_t inverse(int64_t a, int64_t m = mod) {\n\tint64_t x, y;\n\tint64_t g = extGcd(a, m, x, y);\n\tassert(g == 1);\n\treturn (x % m + m) % m;\n}\n\ninline int64_t C(int64_t n, int64_t k) {\n\tif (k < 0 || k > n) {\n\t\treturn 0;\n\t}\n\treturn f[n] * rf[k] % mod * rf[n-k] % mod;\n}\n\ninline int64_t cntLim(int64_t n, int64_t sum, int64_t limit) {\n\tint64_t res = 0;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tres += int64_t((i&1) ? mod-1 : 1) * C(n, i) % mod * C(n+sum-1, n-1);\n\t\tres %= mod;\n\t\tsum -= limit+1;\n\t\tif (sum < 0) {\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn res;\n}\n\nsigned main() {\n\t#ifndef USE_FILE_IO\n\t\tios_base::sync_with_stdio(false);\n\t#endif\n\t\n\tf[0] = 1;\n\tfor (int i = 1; i < fMax; ++i) {\n\t\tf[i] = f[i-1] * i % mod;\n\t}\n\tfor (int i = 0; i < fMax; ++i) {\n\t\trf[i] = inverse(f[i]);\n\t}\n\t\n\tint n, m; cin >> n >> m;\n\tint64_t res = 0;\n\t\n\t// step I: don't have 2*m\n\tres += [&]() -> int64_t {\n\t\tint64_t res = 0;\n\t\tfor (int i = 0; i <= n && i <= m; ++i) {\n\t\t\tif ((3*m-i) & 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres += C(n, i) * cntLim(n, (3*m-i) / 2, m-1) % mod;\n\t\t\tres %= mod;\n\t\t}\n\t\treturn res;\n\t}();\n\t\n\t// step II: have 2*m\n\tres += [&]() -> int64_t {\n\t\tint64_t res = 0;\n\t\tfor (int i = 0; i < n && i <= m; ++i) {\n\t\t\tif ((m-i) & 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres += C(n-1, i) * cntLim(n-1, (m-i) / 2, m-1) % mod;\n\t\t\tres %= mod;\n\t\t}\n\t\tres *= n;\n\t\tres %= mod;\n\t\treturn res;\n\t}();\n\t\n\tres %= mod;\n\tcout << res << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(a); (i)<(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(a)-1; (i)>=(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef pair<lint, pii> plp;\ntypedef complex<double> xy_t;\ntypedef vector<lint> poly;\ntemplate<class T>bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T>bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\n\nconst lint mod = 998244353;\nconst lint INF = mod*mod;\nconst int MAX = 2e6;\n\nlint powmod(lint x, lint n){\n    lint ret = 1;\n    while(n > 0){\n        if(n&1) ret *= x, ret %= mod, n -= 1;\n        else x *= x, x %= mod, n >>= 1;\n    }\n    return ret;\n}\n\nvector<lint> fact;\nvector<lint> revfact;\n\nvoid setfact(int n){\n    fact.resize(n+1); revfact.resize(n+1);\n    fact[0] = 1;\n    rep(i, n) fact[i+1] = fact[i] * (i+1) % mod;\n\n    revfact[n] = powmod(fact[n], mod-2);\n    for(int i=n-1; i>=0; i--) revfact[i] = revfact[i+1] * (i+1) % mod;\n}\n\nlint getC(int n, int r){\n    if(n<r) return 0;\n    return fact[n] * revfact[r] % mod * revfact[n-r] % mod;\n}\n\nlint part(int n, int K){\n    return getC(n+K-1, K-1);\n}\n\nint main(){\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    setfact(MAX);\n    lint ans=0;\n    rep(i, min(m+1, n+1))if((3*m-i)%2==0){\n        ans+=getC(n, i)*part((3*m-i)/2, n)%mod;\n        ans%=mod;\n    }\n    rep(i, min(m+1, n+1))if((m-i)%2==0){\n        lint tmp=getC(n-1, i)*part((m-i)/2, n-1)%mod;\n        tmp=(tmp-getC(n, i)*part((m-i)/2, n)%mod+mod)%mod;\n        (tmp*=(lint)n)%=mod;\n        (ans+=tmp)%=mod;\n    }\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<LP> vec;\ntypedef vector<string> svec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\n\nstruct perm {\nprivate:\n\tint sz;\n\tvector<ll> p, invp;\npublic:\n\tperm(int n) {\n\t\tsz = n + 1;\n\t\tp.resize(sz), invp.resize(sz);\n\t\tp[0] = 1;\n\t\trep1(i, sz - 1) {\n\t\t\tp[i] = p[i - 1] * i%mod;\n\t\t}\n\t\tinvp[sz - 1] = 1;\n\t\tll cop = mod - 2, x = p[sz - 1];\n\t\twhile (cop) {\n\t\t\tif (cop % 2)invp[sz - 1] = invp[sz - 1] * x%mod;\n\t\t\tcop >>= 1; x = x * x % mod;\n\t\t}\n\t\tper(i, sz - 1) {\n\t\t\tinvp[i] = invp[i + 1] * (i + 1) % mod;\n\t\t}\n\t}\n\tll comb(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\tll ret = p[x];\n\t\t(ret *= invp[y]) %= mod;\n\t\t(ret *= invp[x - y]) %= mod;\n\t\treturn ret;\n\t}\n\tll combP(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\treturn p[x] * invp[x - y] % mod;\n\t}\n};\nperm p(1 << 23);\n\nvoid solve() {\n\tll ans = 0;\n\tint n, m; cin >> n >> m;\n\tans = p.comb(3 * m + n - 1, 3 * m);\n\tfor (int i = 2 * m + 1; i <= 3 * m; i++) {\n\t\tll dif = 3 * m - i;\n\t\tll dec = (ll)n * p.comb(dif + n - 1 - 1, dif) % mod;\n\t\tans -= dec;\n\t\tans = (ans%mod + mod) % mod;\n\t}\n\tfor (int i = m + 2; i <= n; i += 2) {\n\t\tll t = p.comb(n, i);\n\t\tll rest = (3 * m - i) / 2;\n\t\tll z = p.comb(rest + n - 1, rest);\n\t\tll dec = t * z%mod;\n\t\tans -= dec;\n\t\tans = (ans%mod + mod) % mod;\n\t}\n\tcout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\tsolve();\n\t//cout << \"finish\" << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n// cout << fixed << setprecision(20);\n\n//拡張ユークリッドの互除法\nint extgcd(int a, int b, int &x, int &y) {\n    int d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1;\n        y = 0;\n    }\n    return d;\n}\n\n// mod逆元\nint mod_inverse(int a, int m) {\n    int x, y;\n    extgcd(a, m, x, y);\n    return (m + x % m) % m;\n}\n\n// 階乗テーブル\nint fact[1600000];\n\nint mod_fact(int n, int m) {\n    fact[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i % m;\n    }\n}\n\nint N, M;\nint mod = 998244353;\n\nint mod_C(int n, int r, int m) {\n    return fact[n] * mod_inverse(fact[r], m) % m * mod_inverse(fact[n - r], m) % m;\n}\n\nint mod_H(int n, int r, int m) {\n    return mod_C(n + r - 1, r, m);\n}\n\nsigned main() {\n    mod_fact(1600000, mod);\n    cin >> N >> M;\n    int ans = mod_H(N, 3 * M, mod);\n    for (int i = 0; i < M; i++) {\n        ans = (ans + mod - (mod_H(N - 1, i, mod) * N % mod)) % mod;\n    }\n    cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int MAXN = 4000000;\nconst int MOD = 998244353;\nint pow_mod(int b, int p) {\n\tint ret = 1;\n\twhile( p ) {\n\t\tif( p & 1 ) ret = 1LL*ret*b%MOD;\n\t\tb = 1LL*b*b%MOD;\n\t\tp >>= 1;\n\t}\n\treturn ret;\n}\nint fct[MAXN + 5], ifct[MAXN + 5];\nvoid init() {\n\tfct[0] = 1;\n\tfor(int i=1;i<=MAXN;i++)\n\t\tfct[i] = 1LL*fct[i-1]*i%MOD;\n\tifct[MAXN] = pow_mod(fct[MAXN], MOD-2);\n\tfor(int i=MAXN-1;i>=0;i--)\n\t\tifct[i] = 1LL*ifct[i+1]*(i+1)%MOD;\n}\nint comb(int n, int m) {\n\treturn 1LL*fct[n]*ifct[m]%MOD*ifct[n-m]%MOD;\n}\nint main() {\n\tinit();\n\tint N, M; scanf(\"%d%d\", &N, &M);\n\tprintf(\"%d\\n\", (comb(3*M+N-1, N-1) + MOD - 1LL*comb(M+N-2, M-1)*N%MOD)%MOD);\n}"
  },
  {
    "language": "C++",
    "code": "//悔しいなあ…\n#include <iostream>\n#define int long long\nusing namespace std;\n\nint powmod(int a, int n, int mod) {\n\tif (n == 0) return 1;\n\tif (n % 2 == 0) return powmod((a * a) % mod, n / 2, mod);\n\treturn (a * powmod(a, n - 1, mod)) % mod;\n}\n\nconst int MAX = 2600000;\nint mod = 998244353;\nint n, m;\nint fact[MAX];\nint factInv[MAX];\n\nvoid initFact() {\n\tint i;\n\t\n\tfact[0] = 1;\n\tfactInv[0] = 1;\n\tfor (i = 1; i <= 3 * m + n; i++) {\n\t\tfact[i] = (i * fact[i - 1]) % mod;\n\t\tfactInv[i] = powmod(fact[i], mod - 2, mod);\n\t}\n}\n\nint comb(int n, int k) {\n\tif (k > n) return 0;\n\treturn fact[n] * factInv[n - k] % mod * factInv[k] % mod;\n}\n\nsigned main() {\n\tcin >> n >> m;\n\tinitFact();\n\t\n\tint x;\n\tint ng = 0;\n\tfor (x = 2 * m + 1; x <= 3 * m; x++) {\n\t\tint res = n * comb(3 * m - x + n - 2, n - 2) % mod;\n\t\tng += res;\n\t\tng %= mod;\n\t}\n\t\n\tint all = comb(3 * m + n - 1, n - 1);\n\tint ans = (all - ng + mod) % mod;\n\t\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//c++ -std=gnu++14 a.cpp\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <iomanip>\n#include <climits>\n#include <fstream>\n#include <random>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef pair<ll, ll> P;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define revrep(i, n) for(int i = (n)-1; i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\n#define chmin(x, y) x = min(x, y);\n#define chmax(x, y) x = max(x, y);\n#define sz(x) ((int)(x).size())\n\n//const ll INFL = LLONG_MAX;//10^18 = 2^60\nconst ll INFL = 1LL<<60;\n//const int INF = INT_MAX;\nconst int INF = 1 << 30;//10^9\n//const int MOD = 1000000007;\nconst int MOD = 998244353;\n//int MOD = 1000000007;\ndouble EPS = 1e-10;\n\nvector<ll> dy = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nvector<ll> dx = {1, 0, -1, 0, 1, -1, 1, -1, 0};\n\nvoid pres(double A){printf(\"%.12lf\\n\", A);}\nvoid BinarySay(ll x, ll y = 60){rep(i, y) cout << (x>>(y-1-i) & 1); cout << endl;}\nll cnt_bit(ll x){return __builtin_popcountll(x);}\n\nll pow_long(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2) res *= x;\n    x *= x; k /= 2;\n  }\n  return res;\n}\n\nll pow_mod(ll x, ll k){\n  x %= MOD;\n  ll res = 1;\n  while(k > 0){\n    if(k % 2){\n      res *= x; res %= MOD;\n    }\n    x *= x; x %= MOD;\n    k /= 2;\n  }\n  return res;\n}\n\nll inverse(ll x){return pow_mod(x, MOD - 2);};\n\nll gcd(ll a, ll b){\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\nll lcm(ll x, ll y){\n  ll res = x / gcd(x, y);\n  res *= y;\n  return res;\n};\n\n\n//コンビネーション\nconst int MAXcomb = 3000010;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\n//facはn!,finvは1/n!\n//invは逆元\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAXcomb; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nll comb(int n, int k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    return fac[n] * finv[k] % MOD * finv[n-k] % MOD;\n}\n\nconst int MAXkai = 200010;\nll kai_memo[MAXkai];\nll kai(ll N){\n  if(kai_memo[N] != 0) return kai_memo[N];\n  if(N <= 1) return 1;\n  return kai_memo[N] = N * kai(N-1) % MOD;\n}\n\nll disit(ll s, ll base = 10){\n  ll res = 0;\n  while(s){\n    res++;\n    s /= base;\n  }\n  return res;\n}\n\n//約数の列挙O(√n)\nvector<int> divisor(int n){\n    vector<int> res(0);\n    for(int i = 1; i * i <= n; i++){\n        if(n % i == 0){\n            res.push_back(i);\n            if(i != n/i) res.push_back(n/i);\n        }\n    }\n    sort(res.begin(), res.end());\n    return res;\n}\n\nll N, M;\nvoid solve(){\n  COMinit();\n  cin >> N >> M;\n  ll ans = 0;\n  for(ll x = 0; x <= M; x++){//奇数がx個\n    if(x % 2 != M % 2) continue;\n    ll all = 3 * M - x;\n    all /= 2;\n    ans += comb(N, x) * comb(all+N-1, all) % MOD;\n    ans %= MOD;\n  }\n\n  for(ll x = 0; x <= M; x++){//奇数がx個\n    if(x % 2 != M % 2) continue;\n    ll all = M - x;\n    all /= 2;\n    ans += MOD - N * comb(N, x) % MOD * comb(all+N-1, all) % MOD;\n    ans %= MOD;\n  }\n\n  for(ll x = 0; x <= M; x++){//奇数がx個\n    if(x % 2 != M % 2) continue;\n    ll all = M - x;\n    all /= 2;\n    ans += N * comb(N-1, x) % MOD * comb(all+N-2, all) % MOD;\n    ans %= MOD;\n  }\n  cout << ans << endl;\n}\n\nint main(){\n  ios_base::sync_with_stdio(0);\n  cin.tie(0), cout.tie(0);\n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\nusing ll = int64_t;\n\nconstexpr ll MOD = 998244353;\n\nclass Combination {\npublic:\n    Combination(ll max_num) {\n        fact_.resize(max_num + 1, 1);\n        inv_fact_.resize(max_num + 1, 1);\n        for (ll i = 2; i <= max_num; i++) {\n            fact_[i] = i * fact_[i - 1] % MOD;\n            inv_fact_[i] = MODpow(fact_[i], MOD - 2);\n            assert(fact_[i] * inv_fact_[i] % MOD == 1);\n        }\n    }\n    ll operator()(ll n, ll m) const {\n        if (m < 0 || m > n) return 0;\n        return fact_[n] * inv_fact_[n - m] % MOD * inv_fact_[m] % MOD;\n    }\nprivate:\n    ll MODpow(ll n, ll m) const {\n        ll result = 1;\n        while (m) {\n            if (m % 2 == 1) {\n                result *= n;\n                result %= MOD;\n            }\n\n            m /= 2;\n            n *= n;\n            n %= MOD;\n        }\n\n        return result;\n    }\n\n    vector<ll> fact_, inv_fact_;\n} comb(3e6);\n\n//サイズがnの非負整数配列で総和がsであり奇数の要素がm個であるものの場合の数\nll f(ll n, ll s, ll m) {\n    ll result = 0;\n\n    //奇数の数を全探索\n    for (ll a = s % 1; a <= m; a += 2) {\n        //まず奇数になるところを決める\n        ll curr_num = comb(n, a);\n\n        //上で選んだ箇所に1を入れたとする\n        //残りs - aをn個の要素にそれぞれ偶数となるように分ければ良い\n        //そのような分け方は結局(s - a) / 2をn個に分ける\n        //要素と仕切りのやつ\n        (curr_num *= comb((s - a) / 2 + n - 1, n - 1)) %= MOD;\n\n        (result += curr_num) %= MOD;\n    }\n\n    return result;\n}\n\nint main() {\n    ll N, M;\n    cin >> N >> M;\n\n    //最大値が2Mを超えないという条件を無視した数\n    ll ans = f(N, 3 * M, M);\n\n    //最大値が2Mを超えるものの数を引く\n    ll sub = N * (f(N, M, M) - f(N - 1, M, M)) % MOD;\n    (ans += MOD - sub) %= MOD;\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\n\nll inf = 998244353;\nll fact[3000010] = {0};\nll inv[3000010] = {0};\n\nll mult(ll n, ll m){\n\tif(m==1) return n%inf;\n\telse if(m%2==0){\n\t\tll t = mult(n,m/2);\n\t\treturn (t*t)%inf;\n\t}else{\n\t\tll t = mult(n,m-1);\n\t\treturn (t*n)%inf;\n\t}\n}\n\nvoid factorial(ll N){\n\tfor(ll i=0;i<=N;i++){\n\t\tif(i==0){\n\t\t\tfact[i] = 1;\n\t\t\tinv[i] = 1;\n\t\t}\n\t\telse{\n\t\t\tfact[i] = (i*fact[i-1])%inf;\n\t\t\tinv[i] = mult(fact[i],inf-2);\n\t\t}\n\t}\n}\n\nll comb(ll n,ll k){\n\tif(n<k) return 0;\n\tif(n<0 || k<0) return 0;\n\telse return (((fact[n]*inv[k])%inf)*inv[n-k])%inf;\n}\n\nll hcomb(ll n,ll k){\n\tif(n==0 && k==0) return 1;\n\treturn comb(n+k-1,k);\n}\n\nint main(){\n    ll N,M;\n    cin >> N >> M;\n    factorial(N+3*M);\n\tll ans = hcomb(N,3*M);\n\tfor(ll k=M+1;k<=N;k++){\n\t\tif((3*M-k)%2==1) continue;\n\t\t(ans += -hcomb(N,(3*M-k)/2)+inf)%=inf;\n\t}\n\tfor(ll k=2*M+1;k<=3*M;k++){\n\t\t(ans += -hcomb(N-1,3*M-k)*N%inf+inf)%=inf;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nconst ull mod = 998244353;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){\n  os << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<T> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<vector<T>> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\n\nconst ll N_MAX = 5050505;\n\nll inv[N_MAX],fac[N_MAX],finv[N_MAX];\nvoid make(){\n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    for(int i=2;i<N_MAX;i++){\n        inv[i]=mod-inv[mod%i]*(mod/i)%mod;\n        fac[i]=fac[i-1]*(ll) i%mod;\n        finv[i]=finv[i-1]*inv[i]%mod;\n    }\n}\n\nll Combination(ll C, ll D){\n    if(C<D||C<0) return 0;\n    return fac[C]*(finv[D]*finv[C-D]%mod)%mod;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    make();\n\n    ll N, M;\n    cin >> N >> M;\n\n    ll term1=0, term2=0, term3=0;\n\n    term1 = Combination(3*M+N-1, N-1);\n\n    for(ll L=M+1;L<=min(3*M, N);L++){\n    \tif((3*M-L)%2==1) continue;\n    \tll X = (3*M-L)/2;\n    \tll tmp = Combination(X+N-1, N-1);\n    \ttmp *= Combination(N, L);\n    \ttmp %= mod;\n    \tterm2 += tmp;\n    \tterm2 %= mod;\n    }\n\n    for(ll Y=2*M+1;Y<=3*M;Y++){\n    \tll Z = 3*M-Y;\n    \tll tmp = Combination(Z+N-2, N-2);\n    \ttmp *= N;\n    \ttmp %= mod;\n    \tterm3 += tmp;\n    \tterm3 %= mod;\n    }\n\n    //dump(term1)\n    //dump(term2)\n    //dump(term3)\n\n    ll res=0;\n    res += term1;\n    res = (res + mod - term2)%mod;\n    res = (res + mod - term3)%mod;\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int Mod=998244353;\nint n,m;\n#define Maxn 3000010\nint fact[Maxn],inv[Maxn];\ninline int C(int i,int j){return 1ll*fact[i]*inv[i-j]%Mod*inv[j]%Mod;}\ninline int calc(int x){return C(x+n-1,n-1);}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfact[0]=1;\n\tfor(register int i=1;i<=3000000;++i)fact[i]=1ll*fact[i-1]*i%Mod;\n\tinv[0]=inv[1]=1;\n\tfor(register int i=2;i<=3000000;++i)\n\t\tinv[i]=1ll*(Mod-Mod/i)*inv[Mod%i]%Mod;\n\tfor(register int i=2;i<=3000000;++i)inv[i]=1ll*inv[i-1]*inv[i]%Mod;\n\tint Ans=0;\n\tfor(register int i=0;i<=min(m,n);++i)\n\tif((m-i)%2==0){\n\t\tint at=(3*m-i)/2;\n\t\tint res=calc(at);\n\t\tres=(res-1ll*i*C(at-m+n-1,n-1)%Mod+Mod)%Mod;\n\t\tif(at>m)res=(res-1ll*(n-i)*C(at-m+n-2,n-1)%Mod+Mod)%Mod;\n\t\tres=1ll*res*C(n,i)%Mod;\n\t\tAns=(Ans+res)%Mod;\n\t}\n\tprintf(\"%d\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * Author: AcFunction\n * Date:   2019-09-04 21:48:14\n * Email:  3486942970@qq.com\n**/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n#define ull unsigned long long\n#define db double\n#define ldb long double \n\n#define fi first\n#define se second\n#define MP make_pair\n#define pii pair <int, int>\n#define pil pair <int, ll> \n#define pli pair <ll, int>\n#define pll pair <ll, ll>  \n\n#define All(x) x.begin(), x.end()\n#define pb push_back\n#define pf push_front\n\n#define ms0(x) memset(x, 0, sizeof(x))\n#define ms1(x) memset(x, -1, sizeof(x))\n\n#define oiu cerr << \"Yes!\" << endl; \n#define O(x) cerr << #x << \": \" << x << endl;  \n\ntemplate <typename T> void printarr(T a[], int b, int e) {\n  if(b > e) return ; \n  for(int i = b; i < e; i++) cout << a[i] << \" \"; \n  cout << a[e] << \" \" << endl; \n} \n\ntemplate <typename T> int chkmax(T &x, const T &y) {\n  return x < y ? x = y, 1 : 0; \n}\n\ntemplate <typename T> int chkmin(T &x, const T &y) {\n  return x > y ? x = y, 1 : 0; \n}\n\nconst int N = 2000100; \nconst int mod = 998244353; \n\nint n, m;\nint fac[N], ivf[N]; \n\nint addp(int x, int y) {\n  return (x += y) >= mod ? x - mod : x; \n}\n\nint fpw(int x, int k, int p) {\n  int ret = 1; \n  while(k) {\n    if(k & 1) ret = 1ll * ret * x % p; \n    x = 1ll * x * x % p; k >>= 1; \n  }\n  return ret; \n}\n\nvoid prework() {\n  fac[0] = 1; \n  for(int i = 1; i < N; i++) fac[i] = 1ll * fac[i - 1] * i % mod; \n  ivf[N - 1] = fpw(fac[N - 1], mod - 2, mod); \n  for(int i = N - 2; i >= 0; i--) ivf[i] = 1ll * ivf[i + 1] * (i + 1) % mod; \n}\n\nint C(int x, int y) {\n  if(x < y) return 0; \n  return 1ll * fac[x] * ivf[x - y] % mod * ivf[y] % mod; \n}\n\nint calc(int len, int S) {\n  int ret = 0; \n  for(int i = 0; i <= min(min(m, len), S); i++) {\n    if((S - i) % 2 != 0) continue ; \n    ret = addp(ret, 1ll * C(len, i) * C(len + (S - i) / 2 - 1, len - 1) % mod); \n  }\n  return ret; \n}\n\nint main() {\n  prework(); \n  scanf(\"%d %d\", &n, &m); \n  printf(\"%d\\n\", addp(calc(n, 3 * m), mod - 1ll * n * addp(calc(n, m), mod - calc(n - 1, m)) % mod)); \n  return 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[2000010];\n                int inv[2000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n       \n                               //----------------kokomade tenpure------------\n\npa solve(int haba,int wa,int sai){\n\tif(wa==sai){\n\t\treturn mp(comb(wa+haba-1,wa),haba);\n\t}\n\t//sai<wa\n\t\n\tint zen=comb(wa+haba-1,wa);\n\tint tyoudo=haba*comb(wa-sai+haba-2,wa-sai)%mod;\n\tint hiku=haba*comb(wa+haba-2-sai,haba-1)%mod;\n//\tcout<<zen<<\" \"<<tyoudo<<\" \"<<hiku<<endl;\n\tzen+=mod-hiku;\n\tzen%=mod;\n\t\n\treturn mp(zen,tyoudo);\n\t\n}\n\n signed main(){\n \t\n \n    cin.tie(0);\n\tios::sync_with_stdio(false);\n\t\nmod=998244353 ;\n \t\n \tgya(2000000+5);\n \t\n \t\nint n,m;\n \tcin>>m>>n;\n \tint ans=0;\n \tfor(int i=n;i<=3*n/2;i++){\n \t\t// haba m\n \t\t// wa i\n \t\t// max n\n \t\t// amari 3*n-2*i\n \t\tif(3*n-2*i>m)continue;\n \t\tint am=3*n-2*i;\n \t\tpa z=solve(m,i,n);\n \t//\tcout<<m<<\" \"<<i<<\" \"<<n<<\" \"<<am<<\" \"<<z.first<<\" \"<<z.second<<endl;\n \t\tint zen=z.first;\n \t\tint jus=z.second;\n \t\tint ok=zen+mod-jus;\n \t\tok%=mod;\n \t\t\n \t\t\n \t\t\n \t\tans+=ok*comb(m,am)%mod;\n \t\tans+=jus*comb(m-1,am)%mod;\n \t\tans%=mod;\n \t}\n \tcout<<ans<<endl;\n\nreturn 0;\n \n }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ncs int Mod = 998244353;\nint add(int a, int b){ return a + b >= Mod ? a + b - Mod : a + b; }\nint dec(int a, int b){ return a - b < 0 ? a - b + Mod : a - b; }\nint mul(int a, int b){ return 1ll * a * b % Mod; }\nvoid Add(int &a, int b){ a = add(a, b); }\nvoid Dec(int &a, int b){ a = dec(a, b); }\nvoid Mul(int &a, int b){ a = mul(a, b); }\nint ksm(int a, int b){ int as=1; for(;b;b>>=1,Mul(a,a)) if(b&1) Mul(as,a); return as; }\ncs int N = 3e6 + 50;\nint fc[N], ifc[N], n, m;\nvoid fc_init(int n){\n\tfc[0] = fc[1] = ifc[0] = ifc[1] = 1;\n\tfor(int i=2; i<=n; i++) fc[i] = mul(fc[i-1], i);\n\tifc[n] = ksm(fc[n], Mod-2);\n\tfor(int i=n-1; i>=2; i--) ifc[i] = mul(ifc[i+1], i+1);\n}\nint C(int n, int m){\n\tif(n < 0 || m < 0 || n < m) return 0;\n\treturn mul(fc[n], mul(ifc[n-m], ifc[m]));\n}\nint coef(int c, int z){\n\tint ans = C(z + n - 1, n - 1);\n\tDec(ans, mul(n, C(z - m - 1 + n - 1, n - 1)));\n\tMul(ans, C(n, c));\n\tint t = (m - c) >> 1;\n\tif(t < 0 || !c) return ans;\n\tint dc = C(t + n - 2, n - 2);\n\tMul(dc, C(n - 1, c - 1));\n\treturn dec(ans, mul(n, dc));\n}\nint main(){\n\t#ifdef FSYolanda\n\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tscanf(\"%d%d\",&n,&m);\n\tfc_init(m * 3 + n);\n\tint Ans = C(m * 3 + n - 1, n - 1);\n\tDec(Ans, mul(n, C(m + n - 2, n - 1)));\n\tint ans = 0;\n\tfor(int i = 0; i <= n; i++){\n\t\tif((3 * m - i) & 1) continue;\n\t\tint ct = (3 * m - i) >> 1;\n\t\tif(i <= ct) Add(ans, coef(i, ct));\n\t} cout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sz(c)      int(c.size())\n#define rep(i,a,b) for (int i=a; i<(b); ++i)\n#define per(i,a,b) for (int i=(b)-1; i>=(a); --i)\nusing namespace std;\nusing ll = long long;\n\nint const MD=998244353;\n\nint madd(int x,int y) {\n\tif (x+y<MD) return x+y; else return x+y-MD;\n}\nint msub(int x,int y) {\n\tif (x-y>=0) return x-y; else return x-y+MD;\n}\nint mmul(int x,int y) {\n\treturn int(ll(x)*y % MD);\n}\nint mpow(int x,int p) {\n\tint res=1;\n\twhile (p>0) {\n\t\tif (p%2) res=mmul(res,x);\n\t\tx=mmul(x,x);\n\t\tp/=2;\n\t}\n\treturn res;\n}\nint minv(int x) {\n\treturn mpow(x,MD-2);\n}\nint mdiv(int x,int y) {\n\treturn mmul(x,mpow(y,MD-2));\n}\n\nint const MAXN=2.2e6;\nint fact[MAXN];\nint invfact[MAXN];\nvoid mfact_init() {\n\tfact[0]=invfact[0]=1;\n\trep(i,1,MAXN) {\n\t\tfact[i]=mmul(fact[i-1],i);\n\t\tinvfact[i]=minv(fact[i]);\n\t}\n}\ninline int mcomb(int x,int y) {\n\tif (x<y) return 0;\n\treturn mmul(fact[x],mmul(invfact[x-y],invfact[y]));\n}\ninline int mdistr(int x,int y) {\n\treturn mcomb(x+y-1,y-1);\n}\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(10);\n\n\tmfact_init();\n\n\tint N,M;\n\tcin>>N>>M;\n\t\n\tint res=0;\n\trep(i,0,min(N,M)+1) if ((3*M-i)%2==0) {\n\t\tint add=mmul(mcomb(N,i),mdistr((3*M-i)/2,N));\n\t\tres=madd(res,add);\n\t}\n\trep(i,0,min(N,M)+1) if ((M-i)%2==0) {\n\t\tint sub=mmul(mcomb(N,i),mdistr((M-i)/2,N));\n\t\tres=msub(res,mmul(sub,N));\n\t}\n\trep(i,0,min(N,M)+1) if ((M-i)%2==0) {\n\t\tint add=mmul(mcomb(N-1,i),mdistr((M-i)/2,N-1));\n\t\tres=madd(res,mmul(add,N));\n\t}\n\tcout<<res<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long P = 998244353, MX = 1500000;\nconst int f[] = {2, 1};\n\nint N, M;\nlong long fact[MX+10], invf[MX+10];\n\ninline long long MOD(long long x, long long M=P) { return (x%M+M)%M; }\ninline void SUB(long long &x, long long y) { x = MOD(x-y); }\n\nint qpow(long long a, int k) {\n//\tprintf(\"a=%lld; k=%d\\n\", a, k);\n\treturn (k?(qpow(a*a%P, k/2)*((k&1)?a:1)):1)%P;\n}\n\nvoid init() {\n\tfact[0] = 1;\n\tfor (int i = 1; i <= MX; ++i) fact[i] = fact[i-1]*i%P;\n\tinvf[MX] = qpow(fact[MX], P-2);\n\tassert(invf[MX]*fact[MX]%P == 1);\n\tfor (int i = MX; i; --i) invf[i-1] = invf[i]*i%P;\n}\n\nlong long C(int k, int n) {\n\tassert(0 <= k && k <= n);\n//\tprintf(\"%dC%d = %lld\\n\", k, n, fact[n]*invf[k]%P*invf[n-k]%P);\n\treturn fact[n]*invf[k]%P*invf[n-k]%P;\n}\n\nint main() {\n\tinit();\n\tscanf(\"%d%d\", &N, &M);\n\tlong long ans = C(N-1, 3*M + N-1);\n//\tprintf(\"%lld\\n\", ans);\n\tfor (int i = 2*M+1; i <= 3*M; ++i) {\n\t\tSUB(ans, N*C(N-2, (3*M-i)+(N-2)));\n\t}\n//\tprintf(\"%lld\\n\", ans);\n\tfor (int i = M+f[M%2]; i <= N; i+=2) {\n\t\tSUB(ans, C(i, N)*C(N-1, (3*M-i)/2+(N-1)));\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using treap = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n#define int long long\n#define REP(i, n) for (long long i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (long long i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) begin(obj), end(obj)\n#define RALL(obj) rbegin(obj), rend(obj)\n#define fi first\n#define se second\nusing ii = pair<int, int>;\nvector<ii> dirs = {\n  {1, 0}, {0, 1}, {-1, 0}, {0, -1},  // 4方向\n  {1, 1}, {-1, 1}, {-1, -1}, {1, -1},  // 斜め\n  {0, 0},  // 自身\n};\ntemplate <class T> inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T> inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T, class S> vector<T> make_vec(size_t n, S x) { return vector<T>(n, x); }\ntemplate <class T, class... Ts> auto make_vec(size_t n, Ts... ts) { return vector<decltype(make_vec<T>(ts...))>(n, make_vec<T>(ts...)); }\n\n// debug\ntemplate <class T> ostream& operator<<(ostream& s, vector<T>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \" \"); return s; }\ntemplate <class T> ostream& operator<<(ostream& s, vector<vector<T>>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \"\\n\"); return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, pair<T, S>& p) { s << \"{\" << p.first << \", \" << p.second << \"}\"; return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, unordered_map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\n#ifdef _MY_DEBUG\n  #define dump(...) cerr << \"/* \" << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << endl, dump_func(__VA_ARGS__), cerr << \"*/\\n\\n\";\n#else\n  #define dump(...)\n  #define endl \"\\n\"\n#endif\nvoid dump_func() { cerr << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& h, Tail&&... t) { cerr << h << (sizeof...(Tail) == 0 ? \"\" : \", \"), dump_func(forward<Tail>(t)...); }\n\nstruct Fast { Fast() { cin.tie(0); ios::sync_with_stdio(false); } } fast;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr int MOD = 998244353;\n// *************** TEMPLATE END *************** \n\ntemplate <class T>\nT pow(T x, int n, const T UNION = 1) {\n  T ret = UNION;\n  while (n) {\n    if (n & 1) ret *= x;\n    x *= x; n >>= 1;\n  }\n  return ret;\n}\n\ntemplate <int MD>\nstruct ModInt {\n  int x;\n  static unordered_map<int, int> to_inv;\n  ModInt() : x(0) {}\n  ModInt(int x_) { if ((x = x_ % MD + MD) >= MD) x -= MD; }\n\n  ModInt& operator+=(ModInt that) { if ((x += that.x) >= MD) x -= MD; return *this; }\n  ModInt& operator*=(ModInt that) { x = (unsigned long long)x * that.x % MD; return *this; }\n  ModInt& operator-=(ModInt that) { if ((x -= that.x) < 0) x += MD; return *this; }\n  ModInt& operator/=(ModInt that) { x = (unsigned long long)x * that.inv().x % MD; return *this; }\n\n  ModInt operator-() const { return -x < 0 ? MD - x : -x; }\n  ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n  ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n  ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n  ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n  bool operator==(ModInt that) const { return x == that.x; }\n  bool operator!=(ModInt that) const { return x != that.x; }\n  ModInt inv() const { return to_inv.count(this->x) ? to_inv[this->x] : (to_inv[this->x] = pow(*this, MD - 2).x); }\n  friend ostream& operator<<(ostream& s, ModInt<MD> a) { s << a.x; return s; }\n  friend istream& operator>>(istream& s, ModInt<MD>& a) { s >> a.x; return s; }\n};\ntemplate <int MD> unordered_map<int, int> ModInt<MD>::to_inv;\nusing mint = ModInt<MOD>;\n\nvector<mint> fact, fact_inv;\nvoid init_factorial(int n) {\n  fact = vector<mint>(n + 1, 1);\n  fact_inv = vector<mint>(n + 1);\n  for (int i = 0; i < n; i++) fact[i + 1] = fact[i] * (i + 1);\n  fact_inv[n] = mint(1) / fact[n];\n  for (int i = n - 1; i >= 0; i--) fact_inv[i] = fact_inv[i + 1] * (i + 1);\n  // for (int i = 0; i < n + 1; i++) assert(fact[i] * fact_inv[i] == 1);\n}\nmint comb(int n, int r) {\n  return fact[n] * fact_inv[r] * fact_inv[n - r];\n}\n\nsigned main() {\n  int n, m; cin >> n >> m;\n  init_factorial(n + 3 * m + 10);\n  mint ans1 = comb(3 * m + n - 1, n - 1);\n\n  mint ans2 = 0;\n  REPI (x, 2 * m + 1, 3 * m + 1) {\n    int rem = 3 * m - x;\n    ans2 += comb(rem + (n - 1) - 1, (n - 1) - 1) * n;\n  }\n\n  mint ans3 = 0;\n  for (int x = m + 2; x <= min(n, 3 * m); x += 2) {\n    assert((3 * m - x) % 2 == 0);\n    int rem = (3 * m - x) / 2;\n    ans3 += comb(n, x) * comb(rem + n - 1, n - 1);\n  }\n\n  cout << ans1 - ans2 - ans3 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> bool get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;return true;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) (get1(a)&&get1(b))\n#define get3(a,b,c) (get1(a)&&get2(b,c))\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int mod=998244353;\nint qpow(int x,int y)\n{\n\tint ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ret=(LL)ret*x%mod;\n\t\tx=(LL)x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\n\nconst int maxn=5000111;\nint fac[maxn],invf[maxn];\n\nint comb(int x,int y)\n{\n\tif(y<0||x<y)return 0;\n\treturn (LL)fac[x]*invf[y]%mod*invf[x-y]%mod;\n}\n\nint n,m;\n\nint calc(int x)\n{\n\tint coef=comb((m+m+m-x)/2+n-1,n-1);\n//\tprintf(\"coef= %d\\n\",coef);\n\tint c2=(LL)x*comb((m+m+m-x)/2-m+n-1,n-1)%mod;\n\tint c3=(LL)(n-x)*comb((m+m+m-x)/2-m-1+n-1,n-1)%mod;\n\tcoef-=c2;if(coef<0)coef+=mod;\n\tcoef-=c3;if(coef<0)coef+=mod;\n\tcoef=(LL)coef*comb(n,x)%mod;\n//\tprintf(\"x= %d coef= %d c2= %d c3= %d\\n\",x,coef,c2,c3);\n\treturn coef;\n}\n\nint main()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<maxn;i++)fac[i]=(LL)i*fac[i-1]%mod;\n\tinvf[maxn-1]=qpow(fac[maxn-1],mod-2);\n\tfor(int i=maxn-1;i>=1;i--)invf[i-1]=(LL)i*invf[i]%mod;\n\t\n\tscanf(\"%d%d\",&n,&m);\n\t\n\tint ans=0;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tif(i<=m&&(m+m+m-i)%2==0)\n\t\t{\n\t\t\tans+=calc(i);\n\t\t\tif(ans>=mod)ans-=mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nconst int N = 1e6+1, M = 5e5, F = 4*N, mod = 998244353;\n\nll binpow(ll a, ll s){\n    ll ans = 1;\n    while(s){\n        if(s&1)\n            ans = ans*a%mod;\n        a = a*a%mod;\n        s >>= 1;\n    }\n    return ans;\n}\n\nll inv(ll a){\n    return binpow(a, mod-2);\n}\n\nint n, m;\nll f[F], invf[F];\nvoid init(){\n    f[0] = 1;\n    invf[0] = 1;\n    for(int i = 1; i < N; ++i){\n        f[i] = f[i-1]*i%mod;\n        invf[i] = inv(f[i]);\n    }\n}\n\nll C(int n, int k){\n    if(n < k || k < 0)\n        return 0ll;\n    return f[n]*invf[n-k]%mod*invf[k]%mod;\n}\n\nll C_(int n, int k){\n    return C(n+k-1, k);\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cout.tie(0);\n    cin.tie(0);\n    init();\n    cin >> n >> m;\n    ll ans = 0;\n    for(int odd = m; odd >= 0; odd -= 2){\n        if(odd > n)\n            continue;\n        ll cnt2 = m+(m-odd)/2;\n        ll res = C(n, odd)*C_(n, cnt2)%mod;\n        res = (res - (C_(n, cnt2-m-1)*C(n-1, odd)%mod + C_(n, cnt2-m)*C(n-1, odd-1)%mod)*n%mod)%mod;\n        ans = (ans+res)%mod;\n    }\n    if(ans < 0) ans += mod;\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define M 998244353\n\n#define Z 3000000\n\nll pot(int a, int b) {\n\tif (b == 0) return 1;\n\tll x = pot(a,b/2);\n\tx = x*x%M;\n\tif (b%2) x = x*a%M;\n\treturn x;\n}\n\nll inv(ll x) {\n\treturn pot(x,M-2);\n}\n\nll ff[Z+1];\nll ii[Z+1];\n\nll ncr(int a, int b) {\n\treturn ff[a]*ii[b]%M*ii[a-b]%M;\n}\n\nll calc(int n, int k) {\n\treturn ncr(k+n-1,k);\n}\n\nint n, m;\n\nint main() {\n\tff[0] = 1;\n\tfor (int i = 1; i <= Z; i++) ff[i] = ff[i-1]*i%M;\n\tii[Z] = inv(ff[Z]);\n\tfor (int i = Z-1; i >= 0; i--) ii[i] = ii[i+1]*(i+1)%M;\n\tcin >> n >> m;\n\tll x = calc(n,2*m+m);\n\tfor (int i = 2*m+1; i <= 2*m+m; i++) {\n\t\tll u = n*calc(n-1,2*m+m-i)%M;\n\t\tx = (x-u)%M;\n\t\tif (x < 0) x += M;\n\t}\n\n\tif (m < n) {\n\t\tfor (int i = m+1; i <= n; i++) {\n\t\t\tif (2*m+m-i <= 0 || (2*m+m-i)%2 == 1) continue;\n\t\t\tll u = ncr(n,i)*calc(n,(2*m+m-i)/2)%M;\n\t\t\tx = (x-u)%M;\n\t\t\tif (x < 0) x += M;\n\t\t}\n\t}\n\tcout << x << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)   FOR(i,0,n)\n#define ALL(a)  (a).begin(),(a).end()\n#define LL long long\n\n#define MOD 998244353\n#define FACT_MAX 3000000\n\nLL fact[FACT_MAX];\n\nclass Combinatrics{\nprivate:\n  long long mod = 998244353;\n  int fact_max = FACT_MAX;\npublic:\n  Combinatrics(){\n    fact[0]=1;\n    for(int i=1;i<fact_max;i++)\n      fact[i] = (fact[i-1]*i)%mod;\n  }\n  \n  long long power(long long n, long long e){\n    long long ret = 1;\n    long long b = n;\n    while(e){\n      if(e%2!=0)\n\tret*=b;\n      ret%=mod;\n      b*=b;\n      b%=mod;\n      e/=2;\n    }\n    return ret;\n  }\n\n  long long inv(long long n){\n    return power(n,mod-2);\n  }\n\n  long long div(long long n1,long long n2){\n    return n1*power(n2,mod-2)%mod;\n  }\n  \n  long long nck(int n,int k){\n    if(k>n || k<0) return 0LL;\n    if(k==n || k==0) return 1LL;\n    return (fact[n]*inv(fact[n-k])%mod)*inv(fact[k])%mod;\n  }\n};\n\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  LL ret=0;\n  Combinatrics comb;\n  int i=m%2;\n  \n  while(i<=m && i<=n){\n    ret += comb.nck((3*m-i)/2+n-1,n-1)*comb.nck(n,i)%MOD;\n    FOR(j,2*m+1,3*m+1){\n      ret = MOD + ret - n*(comb.nck((3*m-i-j+(j%2))/2+n-2,n-2)*comb.nck(n-1,i-(j%2)))%MOD;\n      ret%=MOD;\n    }\n    i+=2;\n  }\n  cout<<ret<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define p 998244353\n\nint MOD(int a){\n\treturn (a %= p) >= 0 ? a : a + p;\n}\n\nint power(int a, int N){\n\tif(N == 0) return 1;\n\telse if(N % 2 == 0) return power(MOD(a * a), N / 2);\n\telse return MOD(a * power(a, N - 1));\n}\n\nint inverse(int a){\n\treturn power(a, p - 2);\n}\n\nint fact(int N){\n\tstatic vector<int> _fact(1, 1);\n\tfor(int i = _fact.size(); i <= N; i++){\n\t\t_fact.push_back(MOD(i * _fact[i - 1]));\n\t}\n\treturn _fact[N];\n}\n \nint fact_inv(int N){\n\tstatic vector<int> inv(2, 1), _fact_inv(2, 1);\n\tfor(int i = inv.size(); i <= N; i++){\n\t\tinv.push_back(MOD(-(p / i) * inv[p % i]));\n\t\t_fact_inv.push_back(MOD(inv[i] * _fact_inv[i - 1]));\n\t}\n\treturn _fact_inv[N];\n}\n \nint combination(int N, int k){\n\tif(k < 0 || N < k || N < 0) return 0;\n\telse return MOD(fact(N) * MOD(fact_inv(N - k) * fact_inv(k)));\n}\n\nsigned main(){\n\tint N, M, i, j;\n\tscanf(\"%lld%lld\", &N, &M);\n\tint ans = 0, now;\n\tfor(i = 0; i <= M && i <= N; i++){\n\t\tif(i % 2 != M % 2){\n\t\t\tcontinue;\n\t\t}\n\t\tans = MOD(ans + N * MOD(combination(N - 1, i) * combination((M - i) / 2 + (N - 1) - 1, (N - 1) - 1)));\n//\t\tprintf(\"ans = %lld\\n\", ans);\n\t\tnow = combination((3 * M - i) / 2 + N - 1, N - 1);\n//\t\tprintf(\"now1 = %lld\\n\", now);\n/*\t\tfor(j = 2 * M; i + j <= 3 * M; j += 2){\n\t\t\tnow = MOD(now - N * combination((3 * M - i - j) / 2 + (N - 1) - 1, (N - 1) - 1));\n\t\t}\n*/\t\tint K = N - 2, x = (3 * M - i) / 2;\n\t\tnow = MOD(now - MOD(MOD(N * (K - M + x + 1)) * MOD(combination(K - M + x, K) * inverse(K + 1))));\n//\t\tprintf(\"now2 = %lld\\n\", now);\n\t\tans = MOD(ans + now * combination(N, i));\n//\t\tprintf(\"ans[%lld] = %lld\\n\", i, ans);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> P;\n// a>=0, b>=0, x*a+y*b=gcd>=0, a>0,b>0=>abs(y)<=a,abs(x)<=b\nLL gcdex(LL a,LL b,LL& x, LL& y){\n\tLL ax=1,ay=0;\n\tLL bx=0,by=1;\n\twhile(b){\n\t\tLL r=a/b;\n\t\tLL t=a-r*b; a=b; b=t;\n\t\tLL tx=ax-r*bx; ax=bx; bx=tx;\n\t\tLL ty=ay-r*by; ay=by; by=ty;\n\t}\n\tx=ax;\n\ty=ay;\n\treturn a;\n}\nLL modinv(LL a, LL mod){\n\tLL x,y;\n\tgcdex(a,mod,x,y);\n\tif(x<0){\n\t\tx+=mod;\n\t}\n\treturn x;\n}\n\nconst LL N=2e6;\nconst LL K=998244353;\ntemplate<int S>\nstruct Comb\n{\n\tLL f[S+1];\n\tLL r[S+1];\n\tLL mod;\n\tComb(int m)\n\t{\n\t\tmod=m;\n\t\tf[0]=1;\n\t\tr[0]=1;\n\t\tfor(LL i=1;i<=S;i++){\n\t\t\tf[i]=i*f[i-1]%m;\n\t\t\tr[i]=modinv(i,m)*r[i-1]%m;\n\t\t}\n\t}\n\tLL c(int n,int i){\n\t\tif(i<0||n<i)\n\t\t{\n\t\t\t//assert(0);\n\t\t\treturn 0;\n\t\t}\n\t\treturn f[n]*r[i]%mod*r[n-i]%mod;\n\t}\n};\nComb<N> comb(K);\nLL C(int n,int i){\n\treturn comb.c(n,i);\n}\n\nLL f(LL a,LL b)\n{\n\treturn C(a+b-1,a-1);\n}\n\n\nint main(){\n    long long N;\n    scanf(\"%lld\",&N);\n    long long M;\n    scanf(\"%lld\",&M);\n\tLL ret=f(N,3*M);\n\tfor(LL i=2*M+1;i<=3*M;i++){\n\t\tret+=K-N*f(N-1,3*M-i)%K;\n\t\tret%=K;\n\t}\n\tfor(LL i=M+1;i<=min(N,3*M);i++){\n\t\tif((3*M-i)%2){\n\t\t\tcontinue;\n\t\t}\n\t\tLL r=(3*M-i)/2;\n\t\tret+=K-C(N,i)*f(N,r)%K;\n\t\tret%=K;\n\t}\n\n\tcout << ret << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sz(c)      int(c.size())\n#define rep(i,a,b) for (int i=a; i<(b); ++i)\n#define per(i,a,b) for (int i=(b)-1; i>=(a); --i)\nusing namespace std;\nusing ll = long long;\n\nint const MAXN=2.2e6;\nint const MD=998244353;\n\nint madd(int x,int y) {\n\tif (x+y<MD) return x+y; else return x+y-MD;\n}\nint msub(int x,int y) {\n\tif (x-y>=0) return x-y; else return x-y+MD;\n}\nint mmul(int x,int y) {\n\treturn int(ll(x)*y % MD);\n}\nint mpow(int x,int p) {\n\tint res=1;\n\twhile (p>0) {\n\t\tif (p%2) res=mmul(res,x);\n\t\tx=mmul(x,x);\n\t\tp/=2;\n\t}\n\treturn res;\n}\nint minv(int x) {\n\treturn mpow(x,MD-2);\n}\nint mdiv(int x,int y) {\n\treturn mmul(x,mpow(y,MD-2));\n}\n\ntemplate<int N>\nstruct mod_comb {\n\tvector<int> f,rf;\n\tmod_comb():f(N),rf(N) {\n\t\tf[0]=rf[0]=1;\n\t\trep(i,1,N) {\n\t\t\tf[i]=mmul(f[i-1],i);\n\t\t\trf[i]=minv(f[i]);\n\t\t}\n\t}\n\tint comb(int n,int k) {\n\t\tif (n<k) return 0;\n\t\treturn mmul(f[n],mmul(rf[n-k],rf[k]));\n\t}\n\tint distr(int n,int k) {\n\t\treturn comb(n+k-1,k-1);\n\t}\n};\n\nmod_comb<MAXN> mcomb;\n#define comb(n,k) mcomb.comb(n,k)\n#define distr(n,k) mcomb.distr(n,k)\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(10);\n\n\tint N,M;\n\tcin>>N>>M;\n\t\n\tint res=0;\n\trep(i,0,min(N,M)+1) if ((3*M-i)%2==0) {\n\t\tint add=mmul(comb(N,i),distr((3*M-i)/2,N));\n\t\tres=madd(res,add);\n\t}\n\trep(i,0,min(N,M)+1) if ((M-i)%2==0) {\n\t\tint sub=mmul(comb(N,i),distr((M-i)/2,N));\n\t\tres=msub(res,mmul(sub,N));\n\t}\n\trep(i,0,min(N,M)+1) if ((M-i)%2==0) {\n\t\tint add=mmul(comb(N-1,i),distr((M-i)/2,N-1));\n\t\tres=madd(res,mmul(add,N));\n\t}\n\tcout<<res<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long P = 998244353, MX = 1500000;\nconst int f[] = {2, 1};\n\nint N, M;\nlong long fact[MX+10], invf[MX+10];\n\ninline long long MOD(long long x, long long M=P) { return (x%M+M)%M; }\ninline void SUB(long long &x, long long y) { x = MOD(x-y); }\n\nint qpow(long long a, int k) {\n//\tprintf(\"a=%lld; k=%d\\n\", a, k);\n\treturn (k?(qpow(a*a%P, k/2)*((k&1)?a:1)):1)%P;\n}\n\nvoid init() {\n\tfact[0] = 1;\n\tfor (int i = 1; i <= MX; ++i) fact[i] = fact[i-1]*i%P;\n\tinvf[MX] = qpow(fact[MX], P-2);\n\tassert(invf[MX]*fact[MX]%P == 1);\n\tfor (int i = MX; i; --i) invf[i-1] = invf[i]*i%P;\n}\n\nlong long C(int k, int n) {\n\tassert(0 <= k && k <= n);\n\treturn fact[n]*invf[k]%P*invf[n-k]%P;\n//\telse printf(\"%dC%d = %lld\\n\", k, n, fact[n]*invf[k]%P*invf[n-k]%P);\n}\n\nint main() {\n\tinit();\n\tscanf(\"%d%d\", &N, &M);\n\tlong long ans = C(N-1, 3*M + N-1);\n//\tprintf(\"%lld\\n\", ans);\n\tfor (int i = 2*M+1; i <= 3*M; ++i) {\n\t\tSUB(ans, N*C(N-2, (3*M-i)+(N-2)));\n\t}\n//\tprintf(\"%lld\\n\", ans);\n\tfor (int i = M+f[M%2]; i <= N && i <= 3*M; i+=2) {\n\t\tSUB(ans, C(i, N)*C(N-1, (3*M-i)/2+(N-1)));\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 998244353;\n\nclass combination_mod{\n  const long long mod;\n  const long long size;\n  \n  vector<long long> fact; //n!\n  vector<long long> fact_inv; // (n!)^-1\n\n  void make_fact(){\n    fact[0] = 1;\n    for(long long i=1; i<size; i++){\n      fact[i] = fact[i-1]*i % mod;\n    }\n  }\n\n  void make_fact_inv(){\n    fact_inv[0] = fact_inv[1] = 1;\n    for(long long i=2; i<size; i++){\n      fact_inv[i] = fact_inv[mod%i] * (mod - mod/i) % mod;  // x ^ -1\n    }\n    for(int i=2; i<size; i++){\n      fact_inv[i] = fact_inv[i-1] * fact_inv[i] % mod;  // x! ^ -1\n    }\n  }\n\npublic:\n  combination_mod(long long mod_, long long size_ = 2000000) : mod(mod_), size(size_+1){\n    fact.resize(size);\n    fact_inv.resize(size);\n    make_fact();\n    make_fact_inv();\n  }\n\n  //nCk mod p O(1)\n  long long operator()(long long n, long long k){\n    if(k==0 || n==k) return 1;\n    long long ret = fact[n] * fact_inv[k] % mod * fact_inv[n-k] % mod;\n    return ret;\n  }\n};\n\n\nint main(){\n  long long n,m;\n  cin >> n,m;\n\n  combination_mod c(mod, n+m*3*10);\n\n  vector<long long> dp(n+m*3+10, 0);\n  for(long long x=max(0ll, n-2); x<=n+m*3; x++){\n    dp[x] = c(x, n-2);\n  }\n  for(long long x=max(1ll, n-2); x<=n+m*3; x++){\n    dp[x] = (dp[x] + dp[x-1])% mod;\n  }\n\n  long long ans = 0;\n  for(long long odd=0; odd<=m && odd<=n; odd++){\n    long long rem = 3*m - odd;\n    if(rem%2 != 0) continue;\n    rem /= 2;\n    long long p_box = c(n, odd);\n    long long p_ball = c(rem + n-1, n-1);\n    long long tmp = p_ball;\n    // 2m on an odd box\n    if(rem >= m){\n      long long a = odd;\n      long long b = c(rem - m + n-1 - 1, n-1 -1);\n      tmp = (tmp - a * b % mod + mod) % mod;\n    }\n    // for(long long k=1; m+k<=rem; k++){ // 2m + 2k box\n    //   long long b = c(rem - (m + k) + n-1 -1, n-1 -1);\n    //   tmp = (tmp - b * n % mod + mod) % mod;\n    // }\n    if(rem - (m+1) >= 0){\n      long long s = dp[rem - (m+1) + n-1 -1];\n      tmp = (tmp - s * n % mod + mod) % mod;\n    }\n    ans = ans + tmp * p_box;\n    ans %= mod;\n  }\n  println(ans);\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n#define rrep(i, n) for(int i=((int)(n)-1); i>=0; i--)\n#define REP(i, k, n) for(int i=(int)(k); i<(int)(n); i++)\n#define all(a) (a).begin(), (a).end()\n#define pb push_back\n#define PQ(T) priority_queue<T>\n#define PQS(T) priority_queue<T, vector<T>, greater<T> >\n#define deci cout << fixed << setprecision(15);\ntypedef long long ll;\nconst int INF = INT_MAX;\nconst ll inf = 1e18;\nconst ll mod = 998244353;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\ntemplate<class T> bool chmin(T&x,T y){if(x>y){x=y;return true;}return false;}\ntemplate<class T> bool chmax(T&x,T y){if(x<y){x=y;return true;}return false;}\nll gcd(ll x, ll y){ if(x>y) swap(x, y);while(x!=0){ y%=x; swap(x, y); }return y; }\nll mpow(ll x, ll r){if(r==0) return 1;if(r%2==1){ return x*mpow(x, r-1)%mod; }else{ ll aa = mpow(x, r/2); return aa*aa%mod; }}\n\nconst int MAX = 2000000;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\nvoid pre_comb(void){\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2; i<MAX; i++){\n\t\tfac[i] = fac[i-1] * i % mod;\n\t\tinv[i] = mod - inv[mod%i] * (mod/i) % mod;\n\t\tfinv[i] = finv[i-1] * inv[i] % mod;\n\t}\n}\n\nlong long comb(int n, int k){\n\tif(n < k) return 0;\n\tif(n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\nint main(){\n\tint N, M; cin >> N >> M;\n\tll s1 = 0, s2 = 0;\n\tpre_comb();\n\trep(i, M+1){\n\t\tif((3*M-i) % 2 == 1) continue;\n\t\ts1 = (s1 + comb(N, i) * comb((3*M-i)/2+N-1, N-1) % mod) % mod;\n\t}\n\tREP(i, 2*M+1, 3*M+1){\n\t\ts2 = (s2 + N * comb(3*M-i+N-2, N-2) % mod) % mod;\n\t}\n\tcout << (s1 - s2 + mod) % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 3 * 1000 * 1000 + 17;\nconst int MOD = 1000 * 1000 * 1000 + 7;\nconst int M = 998244353;\n\nint n, m;\nlong long F[N];\n\nbool read() {\n    if (!(cin >> n >> m))\n        return false;\n\n    return true;\n}\n\nlong long naive() {\n    vector< vector< vector<long long> > >\n        dp(n + 1, vector< vector<long long> >(3 * m + 1, vector<long long>(n + 1, 0ll)));\n\n    dp[0][0][0] = 1;\n\n    for (int i = 0; i < n; ++i)\n        for (int s = 0; s <= 3 * m; ++s)\n            for (int j = 0; j <= i; ++j)\n                for (int c = 0; c <= 2 * m && c + s <= 3 * m; ++c) {\n                    if (j + c % 2 > n) continue;\n                    dp[i + 1][s + c][j + c % 2] += dp[i][s][j];\n                    dp[i + 1][s + c][j + c % 2] %= M;\n                }\n\n    auto res = 0ll;\n\n    for (int j = 0; j <= 2 * m && j <= n; ++j)\n        res = (res + dp[n][3 * m][j]) % M;\n\n    return res;\n}\n\nlong long bpow(long long a, int n, long long M) {\n    auto res = 1ll;\n\n    for (; n > 0; n /= 2, a = a * a % M)\n        if (n & 1)\n            res = res * a % M;\n\n    return res;\n}\n\nlong long rev(long long x) { return bpow(x, M - 2, M); }\n\nlong long binomial(int n, int k) {\n    return n < 0 || k < 0 || k > n ? 0ll : F[n] * rev(F[k] * F[n - k] % M) % M;\n}\n\nlong long gay(int s, int n) {\n    return s == 0 ? 1ll : binomial(s + n - 1, n - 1);\n}\n\nlong long sol() {\n    auto res = gay(3 * m, n);\n\n    for (int mx = 2 * m + 1; mx <= 3 * m; ++mx) {\n        auto cur = gay(3 * m - mx, n - 1) * n % M;\n        res = (res + M - cur) % M;\n    }\n\n    for (int odd = 2 * m + 1; odd <= 3 * m; ++odd)\n        if ((3 * m - odd) % 2 == 0) {\n            auto cur = gay((3 * m - odd) / 2, n) * binomial(n, odd) % M;\n            res = (res + M - cur) % M;\n        }\n\n    return res;\n}\n\nvoid solve() {\n    F[0] = 1ll;\n\n    for (int i = 1; i < N; ++i)\n        F[i] = i * F[i - 1] % M;\n\n    cout << sol() << endl;\n\n    /*for (n = 2; n <= 500; ++n)\n        for (m = 1; m <= 10; ++m) {\n            auto r1 = sol();\n            auto r2 = naive();\n\n            if (r1 != r2) {\n                cout << n << ' ' << m << \" : \" << r1 << ' ' << r2 << endl;\n            }\n        }*/\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (read())\n        solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return (rng() % (y+1-x)) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\ntypedef long long ll; \ntypedef long double ld;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\ntypedef pair<ll,ll>pi; typedef pair<ll,pi>spi; typedef pair<pi,pi>dpi;\n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (1500006)\nll n, m, mod = 998244353, f[MAXN], inv[MAXN];\nint main(){\n\tFAST\n\tcin>>n>>m;\n\tauto qexp=[&](ll x,ll e){\n\t\tll sum=1;\n\t\twhile(e){\n\t\t\tif(e&1) sum*=x, sum%=mod;\n\t\t\tx*=x,x%=mod;\n\t\t\te>>=1;\n\t\t}\n\t\treturn sum;\n\t};\n\tf[0]=1; FOR(i,1,MAXN-1) f[i]=f[i-1]*i%mod;\n\tinv[MAXN-1] = qexp(f[MAXN-1], mod-2); DEC(i,MAXN-2,0) inv[i]=inv[i+1]*(i+1)%mod;\n\tauto C=[&](ll n,ll k){assert(n>=k);\n\t\treturn f[n] * inv[k] % mod * inv[n-k] % mod;\n\t};\n\tll ans=C(3*m+(n-1), n-1);\n\tcerr<<ans<<'\\n';\n\tans -= n * C(3*m-(2*m+1)+(n-1), n-1) % mod, ans += mod, ans %= mod;\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 5000005\nusing namespace std;\ntypedef long long LL;\nLL read()\n{\n\tLL ans=0,f=1;\n\tchar c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())\n\tif(c=='-') f*=-1;\n\tfor(;'0'<=c&&c<='9';c=getchar())\n\t\tans=ans*10+c-'0';\n\treturn ans*f;\t\n}\nLL n,m,ans=0,t,sum=0;\nconst LL mod=998244353ll;\nLL f[N],p[N];\nLL ksm(LL x,LL k)\n{\n\tif(k==0) return 1;\n\tif(k==1) return x%mod;\n\tLL q=ksm(x,k/2);\n\tif(k&1) return q*q%mod*x%mod;\n\telse return q*q%mod;\n}\nLL C(LL n,LL m){return f[n]*p[n-m]%mod*p[m]%mod;}\nint main()\n{\n\tn=read(),m=read(),f[0]=1;\n\tt=n+m;\n\tfor(int i=1;i<=t;i++)f[i]=f[i-1]*i%mod;\n\tp[t]=ksm(f[t],mod-2);\n\tfor(int i=t-1;i;i--)p[i]=p[i+1]*(i+1)%mod;\n\tfor(int i=0;i<=min(n,m);i++)\n\t\tans=(ans+C(n,i)*C((3*m-i)/2+n-1,n-1)%mod)%mod;\n\t//printf(\"%lld\\n\",ans);\n\tfor(int i=0;i<=min(n-1,m);i++)\n\t\tsum=(sum+C(n-1,i)*C((m-i)/2+n-2,n-2)%mod)%mod;\n\tans=(ans-n*sum)%mod;\n\tif(ans<0)ans+=mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<map>\nusing namespace std;\nint p = 998244353;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\n#define rev(s) reverse(s.begin(),s.end())\n#define end_pr(s) cout << s <<endl;return 0\n#define itn int\n#define bs bitset<5001>\n\nint kai_size = 3000001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4);\n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size - 1) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\n\nint per(int a, int b) {\n\tint ans = a % b;\n\tif (ans < 0) { ans += b; }\n\treturn ans;\n}\nV<pin> uni(V<pin> &v) {\n\tsor(v);\n\tV<pin> ans(1, v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tif (v[i] != v[i - 1]) { ans.push_back(v[i]); }\n\t}\n\tv = ans;\n\treturn v;\n}\nint s_gcd(int a, int b) {\n\tif (b == 0) { return a; }\n\treturn s_gcd(b, a%b);\n}\nint gcd(int a, int b) {\n\tif (a < b) { swap(a, b); }\n\treturn s_gcd(a, b);\n}\nsigned main() {\n\tint n, m; cin >> n >> m; int sum = 3 * m;\n\tmake_kai();\n\tint qans = com(sum + n - 1, n - 1);\n\tint mi1 = 0;\n\tfor (int b = 0; b < m; b++) {\n\t\tint plus = com(b + n - 2, n - 2);\n\t\tmi1 += plus;\n\t}\n\tmi1 %= p;\n\tmi1 *= n; mi1 %= p;\n\tint mi2 = 0;\n\tfor (int a = m + 2; a <= n; a+=2) {\n\t\tint maru = (3 * m) - a; maru /= 2;\n\t\tint plus=com(maru + n - 1, n - 1);\n\t\tint mul = com(n, a);\n\t\tplus *= mul; plus %= p;\n\t\tmi2 += plus;\n\t}\n\tmi2 %= p;\n\tint ans = qans + 2 * p - mi1 - mi2;\n\tcout << ans % p << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG\n \n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds; \nusing namespace std;\n \n#define F first\n#define S second \n#define pb push_back\n \n#define endl \"\\n\"\n \n#define IOS { ios :: sync_with_stdio(false); cin.tie(0); cout.tie(0); }\n \n#ifdef DEBUG\n    #define dbg(s) {s;}\n#endif\n \n#ifndef DEBUG\n    #define dbg(s)\n#endif\n \nusing namespace std;\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint grand(int x) { // from [0, x-1]\n    return uniform_int_distribution<int>(0, x - 1)(rng);\n}\n \n#define i32 int32_t\n#define int ll\n \n#define RBTTYPE int\n#define ordered_set tree<RBTTYPE, null_type, less<RBTTYPE>, rb_tree_tag,tree_order_statistics_node_update> \n \n#define all(v) (v).begin(),(v).end()\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair< int, int > pii;\ntypedef pair< ll, ll > pll;\n \nll gcd(ll x, ll y) {\n    if (x < y) return gcd(y, x);\n    if (y == 0) return x;\n    return gcd(y, x % y);\n} \n \nconst ll mod = 998244353;\n \nll modexp(ll x, ll ex) {\n    ll ans = 1ll;\n    while (ex > 0) {\n        if (ex & 1ll) ans = (ans * x) % mod;\n        ex >>= 1ll;\n        x = (x * x) % mod;\n    }\n    return ans;\n}\n \nconst int maxn = 3e6 + 7;\n \nconst ll inf = 1e9 + 7;\n\nll fact[maxn];\nll facti[maxn];\n\nvoid precalc()\n{\n    fact[1] = 1;\n    fact[0] = 1;\n    facti[1]=1;\n    facti[0] = 1;\n    for(ll i=2;i<maxn;i++)\n    {\n        fact[i] = (fact[i-1]*1ll*i)% mod;\n        facti[i] = modexp(fact[i],mod-2);\n    }\n}\n\nll C(ll n, ll k)\n{\n    if(k<0)\n        return 0;\n    if(n<k)\n        return 0;\n    ll ans = (((fact[n]*facti[n-k])%mod) *facti[k])%mod;\n    return ans;\n}\n\ni32 main() {\n    //freopen(\"<file>.in\", \"r\", stdin);\n    //freopen(\"<file>.out\", \"w\", stdout);\n \n    IOS; \n    precalc();\n    \n    ll n,m;\n    cin>>n>>m;\n    \n    ll total = C(m+m+m+n-1,n-1);\n    \n    ll part1 = 0;\n    ll u,v,sum;\n    for(ll k=m+m+1;k<=m+m+m;k++)\n    {\n        u = m+m+m-k;\n        v = (C(u+n-2,n-2)*n)%mod;\n        part1+=v;\n        part1%=mod;\n    }\n    //cout<<part1<<endl;\n    ll part2 = 0;\n    for(ll k=m+1;k<=n;k++)\n    {\n        u = C(n,k);\n        sum= m+m+m-k;\n        if(sum%2)\n            continue;\n        sum/=2;\n        v = C(sum+n-1,n-1);\n        sum= (u*v)%mod;\n        part2+=sum;\n    }\n    part2%=mod;\n    \n    \n    ll ans = total + mod - part1 + mod - part2;\n    ans%=mod;\n    \n    cout<<ans<<endl;\n    \n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef HOME\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db3(x, y, z) cerr << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \" << z << \")\" << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl\n#define dbv(a) cerr << #a << \" = \"; for (auto xxx: a) cerr << xxx  << \" \"; cerr << endl\n#else\n#define db(x) ;\n#define db3(x, y, z) ;\n#define db2(x, y) ;\n#define dbv(a) ;\n#endif\n\nusing namespace std;\ntypedef long long ll;\ntypedef double dbl;\n\n\nconst ll INF = 1.01e18;\n\n\n\n\n\nnamespace n_mint {\n    template<typename T>\n    T inverse(T a, T m) {\n        T u = 0, v = 1;\n        while (a != 0) {\n            T t = m / a;\n            m -= t * a;\n            swap(a, m);\n            u -= t * v;\n            swap(u, v);\n        }\n        assert(m == 1);\n        return u;\n    }\n    template<typename T>\n    class MMint {\n    public:\n        using Arg = T;\n        using Type = typename decay<decltype(T::value)>::type;\n        constexpr MMint() : value() {}\n        template<typename U>\n        MMint(const U &x) {\n            value = normalize(x);\n        }\n        template<typename U>\n        static Type normalize(const U &x) {\n            Type v;\n            if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n            else v = static_cast<Type>(x % mod());\n            if (v < 0) v += mod();\n            return v;\n        }\n        const Type &operator()() const { return value; }\n        template<typename U>\n        explicit operator U() const { return static_cast<U>(value); }\n        constexpr static Type mod() { return T::value; }\n        MMint &operator+=(const MMint &other) {\n            if ((value += other.value) >= mod()) value -= mod();\n            return *this;\n        }\n        MMint &operator-=(const MMint &other) {\n            if ((value -= other.value) < 0) value += mod();\n            return *this;\n        }\n        template<typename U>\n        MMint &operator+=(const U &other) { return *this += MMint(other); }\n        template<typename U>\n        MMint &operator-=(const U &other) { return *this -= MMint(other); }\n        MMint &operator++() { return *this += 1; }\n        MMint &operator--() { return *this -= 1; }\n        const MMint operator++(int) {\n            MMint result(*this);\n            *this += 1;\n            return result;\n        }\n        const MMint operator--(int) {\n            MMint result(*this);\n            *this -= 1;\n            return result;\n        }\n        MMint operator-() const { return MMint(-value); }\n        template<typename U = T>\n        typename enable_if<is_same<typename MMint<U>::Type, int>::value, MMint>::type &operator*=(const MMint &rhs) {\n            value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n            return *this;\n        }\n        template<typename U = T>\n        typename enable_if<is_same<typename MMint<U>::Type, int64_t>::value, MMint>::type &operator*=(const MMint &rhs) {\n            auto q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n            value = normalize(value * rhs.value - q * mod());\n            return *this;\n        }\n        template<typename U = T>\n        typename enable_if<!is_integral<typename MMint<U>::Type>::value, MMint>::type &operator*=(const MMint &rhs) {\n            value = normalize(value * rhs.value);\n            return *this;\n        }\n        MMint &operator/=(const MMint &other) { return *this *= MMint(inverse(other.value, mod())); }\n        MMint inv() const { return MMint(inverse(value, mod())); }\n        template<typename U>\n        friend bool operator==(const MMint<U> &lhs, const MMint<U> &rhs);\n        template<typename U>\n        friend bool operator<(const MMint<U> &lhs, const MMint<U> &rhs);\n        template<typename U>\n        friend bool operator>(const MMint<U> &lhs, const MMint<U> &rhs);\n        template<typename U>\n        friend std::istream &operator>>(std::istream &stream, MMint<U> &number);\n    private:\n        Type value;\n    };\n    template<typename T>\n    MMint<T> abs(const MMint<T> &val) { return val; }\n    template<typename T>\n    bool operator==(const MMint<T> &lhs, const MMint<T> &rhs) { return lhs.value == rhs.value; }\n    template<typename T, typename U>\n    bool operator==(const MMint<T> &lhs, U rhs) { return lhs == MMint<T>(rhs); }\n    template<typename T, typename U>\n    bool operator==(U lhs, const MMint<T> &rhs) { return MMint<T>(lhs) == rhs; }\n    template<typename T>\n    bool operator!=(const MMint<T> &lhs, const MMint<T> &rhs) { return !(lhs == rhs); }\n    template<typename T, typename U>\n    bool operator!=(const MMint<T> &lhs, U rhs) { return !(lhs == rhs); }\n    template<typename T, typename U>\n    bool operator!=(U lhs, const MMint<T> &rhs) { return !(lhs == rhs); }\n    template<typename T>\n    bool operator<(const MMint<T> &lhs, const MMint<T> &rhs) { return lhs.value < rhs.value; }\n    template<typename T>\n    bool operator>(const MMint<T> &lhs, const MMint<T> &rhs) { return lhs.value > rhs.value; }\n    template<typename T>\n    MMint<T> operator+(const MMint<T> &lhs, const MMint<T> &rhs) { return MMint<T>(lhs) += rhs; }\n    template<typename T, typename U>\n    MMint<T> operator+(const MMint<T> &lhs, U rhs) { return MMint<T>(lhs) += rhs; }\n    template<typename T, typename U>\n    MMint<T> operator+(U lhs, const MMint<T> &rhs) { return MMint<T>(lhs) += rhs; }\n    template<typename T>\n    MMint<T> operator-(const MMint<T> &lhs, const MMint<T> &rhs) { return MMint<T>(lhs) -= rhs; }\n    template<typename T, typename U>\n    MMint<T> operator-(const MMint<T> &lhs, U rhs) { return MMint<T>(lhs) -= rhs; }\n    template<typename T, typename U>\n    MMint<T> operator-(U lhs, const MMint<T> &rhs) { return MMint<T>(lhs) -= rhs; }\n    template<typename T>\n    MMint<T> operator*(const MMint<T> &lhs, const MMint<T> &rhs) { return MMint<T>(lhs) *= rhs; }\n    template<typename T, typename U>\n    MMint<T> operator*(const MMint<T> &lhs, U rhs) { return MMint<T>(lhs) *= rhs; }\n    template<typename T, typename U>\n    MMint<T> operator*(U lhs, const MMint<T> &rhs) { return MMint<T>(lhs) *= rhs; }\n    template<typename T>\n    MMint<T> operator/(const MMint<T> &lhs, const MMint<T> &rhs) { return MMint<T>(lhs) /= rhs; }\n    template<typename T, typename U>\n    MMint<T> operator/(const MMint<T> &lhs, U rhs) { return MMint<T>(lhs) /= rhs; }\n    template<typename T, typename U>\n    MMint<T> operator/(U lhs, const MMint<T> &rhs) { return MMint<T>(lhs) /= rhs; }\n    template<typename T, typename U>\n    MMint<T> bin(const MMint<T> &a, const U &b) {\n        assert(b >= 0);\n        MMint<T> x = a, res = 1;\n        U p = b;\n        while (p > 0) {\n            if (p & 1) res *= x;\n            x *= x;\n            p >>= 1;\n        }\n        return res;\n    }\n    template <typename T>\n    MMint<T> inv(const MMint<T> &a) {\n        return inverse(a(), MMint<T>::mod());\n    }\n    template<typename T>\n    string to_string(const MMint<T> &number) {\n        return std::to_string(number());\n    }\n    template<typename T>\n    std::ostream &operator<<(std::ostream &stream, const MMint<T> &number) {\n        return stream << number();\n    }\n    template<typename T>\n    std::istream &operator>>(std::istream &stream, MMint<T> &number) {\n        typename common_type<typename MMint<T>::Type, int64_t>::type x;\n        stream >> x;\n        number.value = MMint<T>::normalize(x);\n        return stream;\n    }\n    template<typename T, typename Enabled = void>\n    struct is_modular : std::false_type {};\n    template<typename T>\n    struct is_modular<T, typename enable_if<\n            is_same<T, MMint<typename T::Arg>>::value &&\n            is_integral<typename T::Type>::value\n    >::type> : true_type {};\n    struct DynamicMod {\n        static int value;\n    };\n    constexpr int MOD = 998244353;\n    using mint = MMint<std::integral_constant<decay<decltype(MOD)>::type, MOD>>;\n}\nusing namespace n_mint;\nnamespace n_ffti {\n    struct ffti {\n        static std::vector<mint> root;\n        static std::vector<int> rev;\n        static int N;\n        static void prepRoots() {\n            static int lastMod = 0;\n            if (mint::mod() == lastMod && (int) root.size() >= N) return;\n            lastMod = mint::mod();\n            int cN = max(N, 1 << 17);\n            rev.resize(cN);\n            root.resize(cN);\n            for (int i = 1; i < cN; i++) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) * (cN / 2));\n            mint croot = 2;\n            while (!(bin(croot, cN) == mint(1) && bin(croot, cN / 2) != mint(1))) croot++;\n            mint cur = 1;\n            for (int i = cN >> 1; i < cN; i++) {\n                root[i] = cur;\n                cur *= croot;\n            }\n            for (int i = (cN >> 1) - 1; i >= 1; i--) {\n                root[i] = root[i * 2];\n            }\n        }\n        static void prepAB(std::vector<mint> &A, std::vector<mint> &B) {\n            N = 1;\n            while (N < (int) (A.size() + B.size())) N <<= 1;\n            while ((int) A.size() < N) A.push_back(0);\n            while ((int) B.size() < N) B.push_back(0);\n            prepRoots();\n        }\n        static void fft(std::vector<mint> &f) {\n            for (int i = 0; i < N; i++) {\n                int j = rev[i] >> __builtin_ctz(root.size() / N);\n                if (i < j) std::swap(f[i], f[j]);\n            }\n            for (int k = 1; k < N; k <<= 1) {\n                for (int i = 0; i < N; i += 2 * k) {\n                    for (int j = 0; j < k; j++) {\n                        mint z = f[i + k + j] * root[k + j];\n                        f[i + j + k] = f[i + j] - z;\n                        f[i + j] = f[i + j] + z;\n                    }\n                }\n            }\n        }\n        static std::vector<mint> mul(std::vector<mint> a, std::vector<mint> b) {\n            int rsz = a.size() + b.size() - 1;\n            bool eq = a == b;\n            prepAB(a, b);\n            fft(a);\n            if (eq) {\n                b = a;\n            } else {\n                fft(b);\n            }\n            mint oN = mint(N).inv();\n            for (int i = 0; i < N; i++) {\n                a[i] = a[i] * b[i] * oN;\n            }\n            reverse(a.begin() + 1, a.begin() + N);\n            fft(a);\n            a.resize(rsz);\n            return a;\n        }\n    };\n    std::vector<mint> ffti::root;\n    std::vector<int> ffti::rev;\n    int ffti::N;\n}\nusing namespace n_ffti;\n\nnamespace n_fftd {\n    struct num {\n        double x, y;\n        num() {}\n        num(double xx, double yy) : x(xx), y(yy) {}\n        num(double alp) : x(cos(alp)), y(sin(alp)) {}\n    };\n    inline num operator+(const num &a, const num &b) { return num(a.x + b.x, a.y + b.y); }\n    inline num operator-(const num &a, const num &b) { return num(a.x - b.x, a.y - b.y); }\n    inline num operator*(const num &a, const num &b) { return num(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\n    inline num conj(num a) { return num(a.x, -a.y); }\n    struct fftd {\n    private:\n        static constexpr double PI = M_PI;\n        static std::vector<num> root;\n        static std::vector<int> rev;\n        static std::vector<num> a, b;\n        static int N;\n        static void prepRoots() {\n            if ((int) root.size() >= N) return;\n            int old = root.size();\n            root.resize(N);\n            if (old == 0) {\n                if (root.size() < 2) root.resize(2);\n                root[1] = num(1, 0);\n            }\n            for (int k = 1; (1 << k) < N; k++) {\n                if ((1 << k) < old) continue;\n                num x(2 * PI / (1LL << (k + 1)));\n                for (int i = (1LL << (k - 1)); i < (1LL << (k)); i++) {\n                    root[2 * i] = root[i];\n                    root[2 * i + 1] = root[i] * x;\n                }\n            }\n            rev.resize(N);\n            for (int i = 1; i < N; i++) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) * (N / 2));\n        }\n        template<typename T>\n        static void prepAB(std::vector<T> &A, std::vector<T> &B) {\n            N = 1;\n            while (N < (int) (A.size() + B.size())) N <<= 1;\n            while ((int) A.size() < N) A.push_back(0);\n            while ((int) B.size() < N) B.push_back(0);\n            prepRoots();\n        }\n        static void fft(std::vector<num> &f) {\n            for (int i = 0; i < N; i++) {\n                int j = rev[i] >> __builtin_ctz(root.size() / N);\n                if (i < j) std::swap(f[i], f[j]);\n            }\n            for (int k = 1; k < N; k <<= 1) {\n                for (int i = 0; i < N; i += 2 * k) {\n                    for (int j = 0; j < k; j++) {\n                        num z = f[i + j + k] * root[j + k];\n                        f[i + j + k] = f[i + j] - z;\n                        f[i + j] = f[i + j] + z;\n                    }\n                }\n            }\n        }\n        template<typename T>\n        static std::vector<T> mulSingle(std::vector<T> A, std::vector<T> B) {\n            int rsz = A.size() + B.size() - 1;\n            prepAB(A, B);\n            if ((int) a.size() < N) a.resize(N);\n            for (int i = 0; i < N; i++) a[i] = num((double) A[i], (double) B[i]);\n            fft(a);\n            for (int i = 0; i <= N / 2; i++) {\n                int j = (N - i) & (N - 1);\n                num x = (a[j] * a[j] - conj(a[i] * a[i])) * num(0, -0.25 / N);\n                num y = (a[i] * a[i] - conj(a[j] * a[j])) * num(0, -0.25 / N);\n                a[i] = x;\n                if (j != i) a[j] = y;\n            }\n            fft(a);\n            std::vector<T> C(N);\n            for (int i = 0; i < N; i++) {\n                if (is_floating_point<T>::value) {\n                    C[i] = a[i].x;\n                } else {\n                    C[i] = (T)(long long)round(a[i].x);\n                }\n            }\n            C.resize(rsz);\n            return C;\n        }\n        struct PossibleTypes {\n            struct Modular {};\n            struct NonModular {};\n        };\n        template<typename T, typename Enabled = void>\n        struct GetType {\n            using Type = PossibleTypes::NonModular;\n        };\n        template<typename T>\n        struct GetType<T, typename enable_if<is_modular<T>::value>::type> {\n            using Type = PossibleTypes::Modular;\n        };\n        template<typename T>\n        static std::vector<T> mul(const std::vector<T> &A, const std::vector<T> &B, PossibleTypes::Modular) {\n            return mulMod(A, B, T::mod());\n        }\n        template<typename T>\n        static std::vector<T> mul(const std::vector<T> &A, const std::vector<T> &B, PossibleTypes::NonModular) {\n            return mulSingle(A, B);\n        }\n    public:\n        template<typename T>\n        static std::vector<T> mulMod(std::vector<T> A, std::vector<T> B, int CUR_MOD) {\n            int rsz = A.size() + B.size() - 1;\n            prepAB(A, B);\n            if ((int) a.size() < N) a.resize(N);\n            for (int i = 0; i < N; i++) {\n                int x = A[i];\n                a[i] = num(x & ((1 << 15) - 1), x >> 15);\n            }\n            fft(a);\n            if (A == B) {\n                b = a;\n            } else {\n                if ((int) b.size() < N) b.resize(N);\n                for (int i = 0; i < N; i++) {\n                    int x = B[i];\n                    b[i] = num(x & ((1 << 15) - 1), x >> 15);\n                }\n                fft(b);\n            }\n            for (int i = 0; i <= N / 2; i++) {\n                int j = (N - i) & (N - 1);\n                num a1 = (a[i] + conj(a[j])) * num(0.5, 0);\n                num a2 = (a[i] - conj(a[j])) * num(0, -0.5);\n                num b1 = (b[i] + conj(b[j])) * num(0.5 / N, 0);\n                num b2 = (b[i] - conj(b[j])) * num(0, -0.5 / N);\n                if (i != j) {\n                    num aa1 = (a[j] + conj(a[i])) * num(0.5, 0);\n                    num aa2 = (a[j] - conj(a[i])) * num(0, -0.5);\n                    num bb1 = (b[j] + conj(b[i])) * num(0.5 / N, 0);\n                    num bb2 = (b[j] - conj(b[i])) * num(0, -0.5 / N);\n                    a[i] = aa1 * bb1 + aa2 * bb2 * num(0, 1);\n                    b[i] = aa1 * bb2 + aa2 * bb1;\n                }\n                a[j] = a1 * b1 + a2 * b2 * num(0, 1);\n                b[j] = a1 * b2 + a2 * b1;\n            }\n            fft(a);\n            fft(b);\n            std::vector<T> C(N);\n            for (int i = 0; i < N; i++) {\n                long long aa = a[i].x + 0.5;\n                long long bb = b[i].x + 0.5;\n                long long cc = a[i].y + 0.5;\n                C[i] = (aa + bb % CUR_MOD * (1LL << 15) + cc % CUR_MOD * (1LL << 30)) % CUR_MOD;\n            }\n            C.resize(rsz);\n            return C;\n        }\n        template<typename T>\n        static std::vector<T> mul(const std::vector<T> &A, const std::vector<T> &B) {\n            using CurType = typename GetType<T>::Type;\n            return mul(A, B, CurType());\n        }\n    };\n    std::vector<num> fftd::root;\n    std::vector<int> fftd::rev;\n    std::vector<num> fftd::a, fftd::b;\n    int fftd::N;\n}\nusing namespace n_fftd;\ntemplate <typename T, typename FFT = fftd>\nstruct fft_online {\n    vector<T> a, b, c;\n    fft_online(vector<T> _a) : a(_a) {}\n    T add(int k, T x) {\n        if ((int)c.size() < 3 * (k + 1)) {\n            a.resize(max((int)a.size(), 4 * (k + 1)));\n            b.resize(max((int)b.size(), 4 * (k + 1)));\n            c.resize(max((int)c.size(), 4 * (k + 1)));\n        }\n        b[k] = x;\n        c[k] += a[0] * b[k];\n        int z = 1;\n        while ((k & (z - 1)) == (z - 1)) {\n            vector<T> ca(z), cb(z);\n            for (int i = 0; i < z; i++) ca[i] = a[z + i];\n            for (int i = 0; i < z; i++) cb[i] = b[k - z + 1 + i];\n            auto cc = FFT::mul(ca, cb);\n            for (int i = 0; i < 2 * z - 1; i++) c[k + 1 + i] += cc[i];\n            z <<= 1;\n        }\n        return c[k];\n    }\n};\ntemplate <typename T, typename FFT = fftd>\nstruct poly : vector<T> {\n    using vector<T>::vector;\n    poly(const vector<T> &a) : vector<T>(a) {}\n    explicit poly(int x) : vector<T>(x) {}\n    friend ostream& operator<< (ostream& out, const poly& p) {\n        out << p.to_string();\n        return out;\n    }\n    poly& operator+= (const poly &p) {\n        this->resize(max(this->size(), p.size()));\n        for (int i = 0; i < (int)p.size(); i++) {\n            (*this)[i] += p[i];\n        }\n        return *this;\n    }\n    friend poly operator+ (poly a, const poly &b) {\n        return a += b;\n    }\n    poly& operator-= (const poly &p) {\n        this->resize(max(this->size(), p.size()));\n        for (int i = 0; i < (int)p.size(); i++) {\n            (*this)[i] -= p[i];\n        }\n        return *this;\n    }\n    friend poly operator- (poly a, const poly &b) {\n        return a -= b;\n    }\n    poly& operator*= (T d) {\n        for (int i = 0; i < (int)this->size(); i++) {\n            (*this)[i] *= d;\n        }\n        return *this;\n    }\n    friend poly operator* (poly a, T d) {\n        return a *= d;\n    }\n    poly& operator/= (T d) {\n        auto od = T(1) / d;\n        for (int i = 0; i < (int)this->size(); i++) {\n            (*this)[i] *= od;\n        }\n        return *this;\n    }\n    friend poly operator/ (poly a, T d) {\n        return a /= d;\n    }\n    static poly slow_mul(const poly &a, const poly &b) {\n        poly res(a.size() + b.size() - 1);\n        for (int i = 0; i < (int)a.size(); i++) {\n            for (int j = 0; j < (int)b.size(); j++) {\n                res[i + j] += a[i] * b[j];\n            }\n        }\n        return res;\n    }\n    poly& operator*= (const poly &p) {\n        if (min(this->size(), p.size()) <= 100) {\n            *this = slow_mul(*this, p);\n        } else {\n            *this = poly(FFT::mul(*this, p));\n        }\n        return *this;\n    }\n    friend poly operator* (poly a, const poly &b) {\n        return a *= b;\n    }\n    poly inv() const {\n        assert((*this)[0] != 0);\n        poly r({T(1) / (*this)[0]});\n        for (int n = 1; n < (int)this->size(); n <<= 1) {\n            poly ca = cut(2 * n);\n            r = (r * 2 - r * r * ca).cut(2 * n);\n        }\n        r.resize(this->size());\n        return r;\n    }\n    poly sqrt() const {\n        assert((*this)[0] == 1);\n        poly r(1, 1);\n        for (int n = 1; n < (int)this->size(); n <<= 1) {\n            poly ca = cut(2 * n);\n            r = ((r + ca * r.cut(2 * n).inv()) / 2).cut(2 * n);\n        }\n        r.resize(this->size());\n        return r;\n    }\n    void norm() {\n        while (this->size() > 1 && this->back() == 0) {\n            this->pop_back();\n        }\n    }\n    poly rev() const {\n        return poly(this->rbegin(), this->rend());\n    }\n    poly cut(int n) const {\n        poly res = *this;\n        res.resize(n);\n        return res;\n    }\n    pair<poly, poly> div(poly b) const {\n        auto a = *this;\n        a.norm(); b.norm();\n        if (a.size() < b.size()) return make_pair(poly({0}), a);\n        T x = b.back();\n        assert(x != 0);\n        b /= x;\n        auto rb = b.rev().cut(a.size() - b.size() + 1);\n        auto q = (rb.inv() * a.rev()).cut(a.size() - b.size() + 1).rev();\n        poly r = a - b * q;\n        q /= x;\n        r.norm();\n        return {q, r};\n    }\n    friend poly operator/ (poly a, const poly &b) {\n        return a /= b;\n    }\n    poly& operator/= (const poly &p) {\n        return *this = div(p).first;\n    }\n    friend poly operator% (poly a, const poly &b) {\n        return a %= b;\n    }\n    poly& operator%= (const poly &p) {\n        return *this = div(p).second;\n    }\n    poly derivative() const {\n        poly res(max(1, (int)this->size() - 1), 0);\n        for (int i = 1; i < (int)this->size(); i++) res[i - 1] = (*this)[i] * i;\n        return res;\n    }\n    poly integrate() const {\n        poly res(this->size() + 1);\n        for (int i = 1; i < (int)res->size(); i++) {\n            res[i] = (*this)[i - 1] / i;\n        }\n        return res;\n    }\n    poly exp() const {\n        assert((*this)[0] == 0);\n        fft_online<T, FFT> t(derivative());\n        vector<T> g(this->size());\n        g[0] = T(1);\n        for (int i = 1; i < (int)g.size(); i++) {\n            int x = t.add(i - 1, g[i - 1]);\n            g[i] = x / T(i);\n        }\n        return g;\n    }\n    T eval(T x) const {\n        T res = 0;\n        for (int i = (int)this->size() - 1; i >= 0; i--) {\n            res = res * x + (*this)[i];\n        }\n        return res;\n    }\n    vector<T> eval(const vector<T> &x) {\n        int m = x.size();\n        vector<poly> t(4 * m);\n        function<poly(int, int, int)> prod = [&](int v, int l, int r) {\n            poly res;\n            if (l == r) {\n                res = poly({-x[l], 1});\n            } else {\n                int m = (l + r) >> 1;\n                res = prod(v * 2, l, m) * prod(v * 2 + 1, m + 1, r);\n            }\n            return t[v] = res;\n        };\n        prod(1, 0, m - 1);\n        vector<T> ans(m);\n        function<void(poly, int, int, int)> eval = [&](poly cur, int v, int l, int r) {\n            cur %= t[v];\n            if (r - l <= 500) {\n                for (int i = l; i <= r; i++) {\n                    ans[i] = cur.eval(x[i]);\n                }\n            } else {\n                int m = (l + r) >> 1;\n                eval(cur, v * 2, l, m);\n                eval(cur, v * 2 + 1, m + 1, r);\n            }\n        };\n        eval(*this, 1, 0, m - 1);\n        return ans;\n    }\n    string to_string() const {\n        string res;\n        for (int i = 0; i < (int)this->size(); i++) {\n            res += ::to_string((*this)[i]);\n            if (i + 1 < (int)this->size()) res += \" \";\n        }\n        return res;\n    }\n};\n\ntemplate <typename T>\npoly<T> mul(poly<T> a, const poly<T> &b, int coefs) {\n    a *= b;\n    a.resize(coefs);\n    return a;\n}\n\ntemplate <typename T>\npoly<T> bin(poly<T> a, ll n, int coefs) {\n    poly<T> res({1});\n    while (n) {\n        if (n & 1) res = mul(res, a, coefs);\n        a = mul(a, a, coefs);\n        n >>= 1;\n    }\n    return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n    return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n    return to_string((string) s);\n}\n\nstring to_string(bool b) {\n    return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n    bool first = true;\n    string res = \"{\";\n    for (int i = 0; i < static_cast<int>(v.size()); i++) {\n        if (!first) {\n            res += \", \";\n        }\n        first = false;\n        res += to_string(v[i]);\n    }\n    res += \"}\";\n    return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n    string res = \"\";\n    for (size_t i = 0; i < N; i++) {\n        res += static_cast<char>('0' + v[i]);\n    }\n    return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n    bool first = true;\n    string res = \"{\";\n    for (const auto &x : v) {\n        if (!first) {\n            res += \", \";\n        }\n        first = false;\n        res += to_string(x);\n    }\n    res += \"}\";\n    return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n    return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n    return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n    return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << to_string(H);\n    debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nclass Modular {\npublic:\n    using Type = typename decay<decltype(T::value)>::type;\n\n    constexpr Modular() : value() {}\n    template <typename U>\n    Modular(const U& x) {\n        value = normalize(x);\n    }\n\n    template <typename U>\n    static Type normalize(const U& x) {\n        Type v;\n        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n        else v = static_cast<Type>(x % mod());\n        if (v < 0) v += mod();\n        return v;\n    }\n\n    const Type& operator()() const { return value; }\n    template <typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static Type mod() { return T::value; }\n\n    Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n    Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n    template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n    template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n    Modular& operator++() { return *this += 1; }\n    Modular& operator--() { return *this -= 1; }\n    Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n    Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n    Modular operator-() const { return Modular(-value); }\n\n    template <typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n        return *this;\n    }\n    template <typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n        int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n        value = normalize(value * rhs.value - q * mod());\n        return *this;\n    }\n    template <typename U = T>\n    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n        value = normalize(value * rhs.value);\n        return *this;\n    }\n\n    Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n    template <typename U>\n    friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n    template <typename U>\n    friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n    template <typename U>\n    friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n    template <typename U>\n    friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\nprivate:\n    Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n    assert(b >= 0);\n    Modular<T> x = a, res = 1;\n    U p = b;\n    while (p > 0) {\n        if (p & 1) res *= x;\n        x *= x;\n        p >>= 1;\n    }\n    return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n    return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n    return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n    return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n    typename common_type<typename Modular<T>::Type, int64_t>::type x;\n    stream >> x;\n    number.value = Modular<T>::normalize(x);\n    return stream;\n}\n\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nvector<Mint> fact;\nvector<Mint> inv_fact;\n\ntemplate <typename T>\nclass NTT {\npublic:\n    using Type = typename decay<decltype(T::value)>::type;\n\n    static Type md;\n    static Modular<T> root;\n    static int base;\n    static int max_base;\n    static vector<Modular<T>> roots;\n    static vector<int> rev;\n\n    static void clear() {\n        root = 0;\n        base = 0;\n        max_base = 0;\n        roots.clear();\n        rev.clear();\n    }\n\n    static void init() {\n        md = T::value;\n        assert(md >= 3 && md % 2 == 1);\n        auto tmp = md - 1;\n        max_base = 0;\n        while (tmp % 2 == 0) {\n            tmp /= 2;\n            max_base++;\n        }\n        root = 2;\n        while (power(root, (md - 1) >> 1) == 1) {\n            root++;\n        }\n        assert(power(root, md - 1) == 1);\n        root = power(root, (md - 1) >> max_base);\n        base = 1;\n        rev = {0, 1};\n        roots = {0, 1};\n    }\n\n    static void ensure_base(int nbase) {\n        if (md != T::value) {\n            clear();\n        }\n        if (roots.empty()) {\n            init();\n        }\n        if (nbase <= base) {\n            return;\n        }\n        assert(nbase <= max_base);\n        rev.resize(1 << nbase);\n        for (int i = 0; i < (1 << nbase); i++) {\n            rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n        }\n        roots.resize(1 << nbase);\n        while (base < nbase) {\n            Modular<T> z = power(root, 1 << (max_base - 1 - base));\n            for (int i = 1 << (base - 1); i < (1 << base); i++) {\n                roots[i << 1] = roots[i];\n                roots[(i << 1) + 1] = roots[i] * z;\n            }\n            base++;\n        }\n    }\n\n    static void fft(vector<Modular<T>> &a) {\n        int n = (int) a.size();\n        assert((n & (n - 1)) == 0);\n        int zeros = __builtin_ctz(n);\n        ensure_base(zeros);\n        int shift = base - zeros;\n        for (int i = 0; i < n; i++) {\n            if (i < (rev[i] >> shift)) {\n                swap(a[i], a[rev[i] >> shift]);\n            }\n        }\n        for (int k = 1; k < n; k <<= 1) {\n            for (int i = 0; i < n; i += 2 * k) {\n                for (int j = 0; j < k; j++) {\n                    Modular<T> x = a[i + j];\n                    Modular<T> y = a[i + j + k] * roots[j + k];\n                    a[i + j] = x + y;\n                    a[i + j + k] = x - y;\n                }\n            }\n        }\n    }\n\n    static vector<Modular<T>> multiply(vector<Modular<T>> a, vector<Modular<T>> b) {\n        if (a.empty() || b.empty()) {\n            return {};\n        }\n        int eq = (a == b);\n        int need = (int) a.size() + (int) b.size() - 1;\n        int nbase = 0;\n        while ((1 << nbase) < need) nbase++;\n        ensure_base(nbase);\n        int sz = 1 << nbase;\n        a.resize(sz);\n        b.resize(sz);\n        fft(a);\n        if (eq) b = a; else fft(b);\n        Modular<T> inv_sz = 1 / static_cast<Modular<T>>(sz);\n        for (int i = 0; i < sz; i++) {\n            a[i] *= b[i] * inv_sz;\n        }\n        reverse(a.begin() + 1, a.end());\n        fft(a);\n        a.resize(need);\n        return a;\n    }\n};\n\ntemplate <typename T> typename NTT<T>::Type NTT<T>::md;\ntemplate <typename T> Modular<T> NTT<T>::root;\ntemplate <typename T> int NTT<T>::base;\ntemplate <typename T> int NTT<T>::max_base;\ntemplate <typename T> vector<Modular<T>> NTT<T>::roots;\ntemplate <typename T> vector<int> NTT<T>::rev;\n\ntemplate <typename T>\nvector<Modular<T>> inverse(const vector<Modular<T>>& a) {\n    assert(!a.empty());\n    int n = (int) a.size();\n    vector<Modular<T>> b = {1 / a[0]};\n    while ((int) b.size() < n) {\n        vector<Modular<T>> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n        x.resize(b.size() << 1);\n        b.resize(b.size() << 1);\n        vector<Modular<T>> c = b;\n        NTT<T>::fft(c);\n        NTT<T>::fft(x);\n        Modular<T> inv = 1 / static_cast<Modular<T>>((int) x.size());\n        for (int i = 0; i < (int) x.size(); i++) {\n            x[i] *= c[i] * inv;\n        }\n        reverse(x.begin() + 1, x.end());\n        NTT<T>::fft(x);\n        rotate(x.begin(), x.begin() + (x.size() >> 1), x.end());\n        fill(x.begin() + (x.size() >> 1), x.end(), 0);\n        NTT<T>::fft(x);\n        for (int i = 0; i < (int) x.size(); i++) {\n            x[i] *= c[i] * inv;\n        }\n        reverse(x.begin() + 1, x.end());\n        NTT<T>::fft(x);\n        for (int i = 0; i < ((int) x.size() >> 1); i++) {\n            b[i + ((int) x.size() >> 1)] = -x[i];\n        }\n    }\n    b.resize(n);\n    return b;\n}\n\ntemplate <typename T>\nvector<Modular<T>> inverse_old(vector<Modular<T>> a) {\n    assert(!a.empty());\n    int n = (int) a.size();\n    if (n == 1) {\n        return {1 / a[0]};\n    }\n    int m = (n + 1) >> 1;\n    vector<Modular<T>> b = inverse(vector<Modular<T>>(a.begin(), a.begin() + m));\n    int need = n << 1;\n    int nbase = 0;\n    while ((1 << nbase) < need) {\n        ++nbase;\n    }\n    NTT<T>::ensure_base(nbase);\n    int size = 1 << nbase;\n    a.resize(size);\n    b.resize(size);\n    NTT<T>::fft(a);\n    NTT<T>::fft(b);\n    Modular<T> inv = 1 / static_cast<Modular<T>>(size);\n    for (int i = 0; i < size; ++i) {\n        a[i] = (2 - a[i] * b[i]) * b[i] * inv;\n    }\n    reverse(a.begin() + 1, a.end());\n    NTT<T>::fft(a);\n    a.resize(n);\n    return a;\n}\n\ntemplate <typename T>\nvector<Modular<T>> operator*(const vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n    if (a.empty() || b.empty()) {\n        return {};\n    }\n    if (min(a.size(), b.size()) < 150) {\n        vector<Modular<T>> c(a.size() + b.size() - 1, 0);\n        for (int i = 0; i < (int) a.size(); i++) {\n            for (int j = 0; j < (int) b.size(); j++) {\n                c[i + j] += a[i] * b[j];\n            }\n        }\n        return c;\n    }\n    return NTT<T>::multiply(a, b);\n}\n\ntemplate <typename T>\nvector<Modular<T>>& operator*=(vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n    return a = a * b;\n}\n\ntemplate <typename T>\nvector<T>& operator+=(vector<T>& a, const vector<T>& b) {\n    if (a.size() < b.size()) {\n        a.resize(b.size());\n    }\n    for (int i = 0; i < (int) b.size(); i++) {\n        a[i] += b[i];\n    }\n    return a;\n}\n\ntemplate <typename T>\nvector<T> operator+(const vector<T>& a, const vector<T>& b) {\n    vector<T> c = a;\n    return c += b;\n}\n\ntemplate <typename T>\nvector<T>& operator-=(vector<T>& a, const vector<T>& b) {\n    if (a.size() < b.size()) {\n        a.resize(b.size());\n    }\n    for (int i = 0; i < (int) b.size(); i++) {\n        a[i] -= b[i];\n    }\n    return a;\n}\n\ntemplate <typename T>\nvector<T> operator-(const vector<T>& a, const vector<T>& b) {\n    vector<T> c = a;\n    return c -= b;\n}\n\ntemplate <typename T>\nvector<T> operator-(const vector<T>& a) {\n    vector<T> c = a;\n    for (int i = 0; i < (int) c.size(); i++) {\n        c[i] = -c[i];\n    }\n    return c;\n}\n\ntemplate <typename T>\nvector<T> operator*(const vector<T>& a, const vector<T>& b) {\n    if (a.empty() || b.empty()) {\n        return {};\n    }\n    vector<T> c(a.size() + b.size() - 1, 0);\n    for (int i = 0; i < (int) a.size(); i++) {\n        for (int j = 0; j < (int) b.size(); j++) {\n            c[i + j] += a[i] * b[j];\n        }\n    }\n    return c;\n}\n\ntemplate <typename T>\nvector<T>& operator*=(vector<T>& a, const vector<T>& b) {\n    return a = a * b;\n}\n\ntemplate <typename T>\nvector<T> inverse(const vector<T>& a) {\n    assert(!a.empty());\n    int n = (int) a.size();\n    vector<T> b = {1 / a[0]};\n    while ((int) b.size() < n) {\n        vector<T> a_cut(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n        vector<T> x = b * b * a_cut;\n        b.resize(b.size() << 1);\n        for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\n            b[i] = -x[i];\n        }\n    }\n    b.resize(n);\n    return b;\n}\n\ntemplate <typename T>\nvector<T>& operator/=(vector<T>& a, const vector<T>& b) {\n    int n = (int) a.size();\n    int m = (int) b.size();\n    if (n < m) {\n        a.clear();\n    } else {\n        vector<T> d = b;\n        reverse(a.begin(), a.end());\n        reverse(d.begin(), d.end());\n        d.resize(n - m + 1);\n        a *= inverse(d);\n        a.erase(a.begin() + n - m + 1, a.end());\n        reverse(a.begin(), a.end());\n    }\n    return a;\n}\n\ntemplate <typename T>\nvector<T> operator/(const vector<T>& a, const vector<T>& b) {\n    vector<T> c = a;\n    return c /= b;\n}\n\ntemplate <typename T>\nvector<T>& operator%=(vector<T>& a, const vector<T>& b) {\n    int n = (int) a.size();\n    int m = (int) b.size();\n    if (n >= m) {\n        vector<T> c = (a / b) * b;\n        a.resize(m - 1);\n        for (int i = 0; i < m - 1; i++) {\n            a[i] -= c[i];\n        }\n    }\n    return a;\n}\n\ntemplate <typename T>\nvector<T> operator%(const vector<T>& a, const vector<T>& b) {\n    vector<T> c = a;\n    return c %= b;\n}\n\ntemplate <typename T, typename U>\nvector<T> power(const vector<T>& a, const U& b, const vector<T>& c) {\n    assert(b >= 0);\n    vector<U> binary;\n    U bb = b;\n    while (bb > 0) {\n        binary.push_back(bb & 1);\n        bb >>= 1;\n    }\n    vector<T> res = vector<T>{1} % c;\n    for (int j = (int) binary.size() - 1; j >= 0; j--) {\n        res = res * res % c;\n        if (binary[j] == 1) {\n            res = res * a % c;\n        }\n    }\n    return res;\n}\n\ntemplate <typename T>\nvector<T> derivative(const vector<T>& a) {\n    vector<T> c = a;\n    for (int i = 0; i < (int) c.size(); i++) {\n        c[i] *= i;\n    }\n    if (!c.empty()) {\n        c.erase(c.begin());\n    }\n    return c;\n}\n\ntemplate <typename T>\nvector<T> primitive(const vector<T>& a) {\n    vector<T> c = a;\n    c.insert(c.begin(), 0);\n    for (int i = 1; i < (int) c.size(); i++) {\n        c[i] /= i;\n    }\n    return c;\n}\n\ntemplate <typename T>\nvector<T> logarithm(const vector<T>& a) {\n    assert(!a.empty() && a[0] == 1);\n    vector<T> u = primitive(derivative(a) * inverse(a));\n    u.resize(a.size());\n    return u;\n}\n\ntemplate <typename T>\nvector<T> exponent(const vector<T>& a) {\n    assert(!a.empty() && a[0] == 0);\n    int n = (int) a.size();\n    vector<T> b = {1};\n    while ((int) b.size() < n) {\n        vector<T> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n        x[0] += 1;\n        vector<T> old_b = b;\n        b.resize(b.size() << 1);\n        x -= logarithm(b);\n        x *= old_b;\n        for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\n            b[i] = x[i];\n        }\n    }\n    b.resize(n);\n    return b;\n}\n\ntemplate <typename T>\nvector<T> multiply(const vector<vector<T>>& a) {\n    if (a.empty()) {\n        return {0};\n    }\n    function<vector<T>(int, int)> mult = [&](int l, int r) {\n        if (l == r) {\n            return a[l];\n        }\n        int y = (l + r) >> 1;\n        return mult(l, y) * mult(y + 1, r);\n    };\n    return mult(0, (int) a.size() - 1);\n}\n\n\nconst int N = 2e6;\n\nmint solve(int n, int m) {\n    mint res;\n\n    vector<mint> fct(N);\n    fct[0] = 1;\n    for (int i= 1; i < N; i++) fct[i] = fct[i - 1] * i;\n    vector<mint> ofct(N);\n    ofct[N - 1] = 1 / fct[N -1 ];\n    for (int i =N - 2; i >= 0; i--) ofct[i] = ofct[i + 1] * (i + 1);\n\n    auto getC = [&](int n, int k) {\n        if (n < k) return mint(0);\n        return fct[n] * ofct[k] * ofct[n - k];\n    };\n\n    {\n        mint cur = n;\n        // (1+x+...+x^m)^(n-1)\n        // (1-x^(m+1))/(1-x)\n//        poly<mint> d(m + 1);\n        vector<Mint> d(m + 1);\n        for (int i = 0; i <= m; i++) {\n            d[i] = (getC(n-1, i) * (i % 2 == 0 ? 1 : -1))();\n        }\n        d = inverse(d);\n//        d = d.inv();\n\n//        poly<mint> d(m + 1);\n//        for (int i = 0; i <= m; i++) d[i] = 1;\n//        d = bin(d, n - 1, m + 1);\n//        vector<Mint> d(m + 1);\n//        for (int i = 0; i <= m; i++) d[i] = 1;\n//        d = exponent(logarithm(d) * vector<Mint>{n-1});\n\n        cur *= d[m]();\n\n        res += cur;\n    }\n\n    {\n        // (1+x+...+x^(m-1)) ^ n\n        // (1-x^m)/(1-x)\n\n//        poly<mint> d(2 * m + 1);\n        vector<Mint> d(2 * m + 1);\n        for (int i = 0; i <= 2 * m; i++) {\n            d[i] = (getC(n, i) * (i % 2 == 0 ? 1 : -1))();\n        }\n//        d = d.inv();\n        d = inverse(d);\n\n//        poly<mint> nom(m + 1);\n        vector<Mint> nom(m + 1);\n        nom[0] = 1;\n        nom[m] = -n;\n\n        d *= nom;\n\n//        poly<mint> d(2 * m + 1);\n//        for (int i = 0; i < m; i++) d[i] = 1;\n//        d = bin(d, n, 2 * m + 1);\n//        vector<Mint> d(m + m / 2 + 1);\n//        for (int i = 0; i < m; i++) d[i] = 1;\n//        d = exponent(logarithm(d) * vector<Mint>{n});\n\n\n        mint cur = 0;\n\n        for (int odd = 0; odd <= min(m, n); odd++) {\n            if ((m - odd) % 2) continue;\n            mint coef = getC(n, odd);\n            coef *= d[m + (m - odd) / 2]();\n            cur += coef;\n        }\n        res += cur;\n    }\n\n    return res;\n}\n\n\nint main() {\n#ifdef HOME\n    assert(freopen(\"in\", \"r\", stdin));\n#endif\n\n    int n, m;\n    while (scanf(\"%d%d\", &n, &m) == 2) {\n        cout << solve(n, m) << endl;\n    }\n\n\n#ifdef HOME\n    cerr << \"time: \" << clock() * 1.0 / CLOCKS_PER_SEC << endl;\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 3e6 + 5;\nconst int MOD = 998244353;\n\nint N, M;\nint fact[MAXN], inv[MAXN];\n\nvoid load() {\n\tscanf(\"%d%d\", &N, &M);\n}\n\ninline int add(int x, int y) {\n\tx += y;\n\tif (x >= MOD)\n\t\treturn x - MOD;\n\tif (x < 0)\n\t\treturn x + MOD;\n\treturn x;\n}\n\ninline int mul(int x, int y) {\n\treturn (long long)x * y % MOD;\n}\n\nint pot(int x, int y) {\n\tint res = 1;\n\tfor (; y; y /= 2) {\n\t\tif (y % 2)\n\t\t\tres = mul(res, x);\n\t\tx = mul(x, x);\n\t}\n\treturn res;\n}\n\nint choose(int n, int k) {\n\tif (k < 0 || n < k)\n\t\treturn 0;\n\treturn mul(fact[n], mul(inv[k], inv[n - k]));\n}\n\nint stars_bars(int sum, int n) {\n\treturn choose(sum + n - 1, n - 1);\n}\n\nint calc_odd(int k) {\n\tif ((k + M) % 2)\n\t\treturn 0;\n\treturn mul(choose(N, k), stars_bars((3 * M - k) / 2, N));\n}\n\nint solve() {\n\tfact[0] = inv[0] = 1;\n\tfor (int i = 1; i < MAXN; i++) {\n\t\tfact[i] = mul(fact[i - 1], i);\n\t\tinv[i] = pot(fact[i], MOD - 2);\n\t}\n\t\n\tint sol = 0;\n\tfor (int i = 0; i <= M && i <= N; i++)\n\t\tsol = add(sol, calc_odd(i));\n\t\n\tfor (int i = 2 * M + 1; i <= 3 * M; i++)\n\t\tsol = add(sol, -mul(N, stars_bars(3 * M - i, N - 1)));\n\t\n\treturn sol;\n}\n\nint main() {\n\tload();\n\tprintf(\"%d\\n\", solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nclass ModComb {\n    long long *fact, *facti;\n    const int mod;\npublic:\n    explicit ModComb(int n, int m) : mod(m) {\n        fact = new long long[n+1];\n        facti = new long long[n+1];\n        fact[0] = 1; facti[0] = 1;\n        for (int i = 1; i <= n; i++) fact[i] = (fact[i-1] * i) % m;\n        // calc 1/n!\n        long long &inv = facti[n], pw = fact[n];\n        inv = 1;\n        for (int e = mod-2; e > 0; e /= 2) {\n            if (e&1) inv = inv * pw % mod;\n            pw = pw * pw % mod;\n        }\n        for (int i = n-1; i > 0; i--) facti[i] = (facti[i+1] * (i+1)) % m;\n    }\n\n    ~ModComb() {\n        if (fact) delete[] fact;\n        if (facti) delete[] facti;\n    }\n\n    long long get(int n, int k) const {\n        if (n < 0 || k < 0 || k > n) return 0;\n        return fact[n] * facti[k] % mod * facti[n-k] % mod;\n    }\n};\n\nint main() {\n    int n, m; cin >> n >> m;\n    const int M = 998244353;\n    ModComb mc(3*m+n+3, M);\n\n    long long ans = mc.get(n+3*m-1, n-1);\n    for (int j = 0; j < m; j++) ans -= mc.get(n+j-2, n-2) * n % M;\n    for (int l = m+1; l <= min(3*m, n); l++) {\n        long long t = l == n && l == 3 * m ? 1 : mc.get(n+3*m-l-1, n-l-1);\n        ans -= (mc.get(l-1, m) * mc.get(n, l) % M\n                * t * ((m+l) % 2 ? 1 : -1)) % M;\n    }\n    cout << (ans % M + M) % M << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst double PI = 3.14159265358979323846;\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//typedef pair<ll, ll> P;\ntypedef pair<ll, ll> P;\nconst ll INF = 10e17;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n#define ret() return 0;\n\nstd::istream &operator>>(std::istream &in, set<int> &o) {\n    ll a;\n    in >> a;\n    o.insert(a);\n    return in;\n}\n\nstd::istream &operator>>(std::istream &in, queue<int> &o) {\n    ll a;\n    in >> a;\n    o.push(a);\n    return in;\n}\n\nbool contain(set<int> &s, int a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\n\n//const ll mod = 1e10;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ_ASK;\n\n\nstruct Edge {\n    int to, color;\n    ll cost;\n};\n\n\nll rec(vector<vector<Edge>> &g, int start, int now, int goal, int prev) {\n    if (goal == now) return 0;\n\n    for (Edge e : g[now]) {\n        if (e.to == prev) continue;\n        ll c = rec(g, start, e.to, goal, now);\n        if (c == -1) continue;\n        return c + e.cost;\n    }\n    return -1;\n}\n\nstruct Query {\n    int color;\n    ll cost;\n    int from, to;\n\n    // <edge, cost>\n    map<int, ll> costs;\n    map<int, ll> counts;\n};\n\nstd::istream &operator>>(std::istream &in, Query &o) {\n    cin >> o.color >> o.cost >> o.from >> o.to;\n    o.color--;\n    o.from--;\n    o.to--;\n    return in;\n}\n\nconst int mod = 1000000007;\n\nstruct mint {\n    ll x; // typedef long long ll;\n    mint(ll x = 0) : x((x % mod + mod) % mod) {}\n\n    mint &operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    mint &operator-=(const mint a) {\n        if ((x += mod - a.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    mint &operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res += a;\n    }\n\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res -= a;\n    }\n\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res *= a;\n    }\n\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t >> 1);\n        a *= a;\n        if (t & 1) a *= *this;\n        return a;\n    }\n\n    // for prime mod\n    mint inv() const {\n        return pow(mod - 2);\n    }\n\n    mint &operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res /= a;\n    }\n\n    friend std::istream &operator>>(std::istream &in, mint &o) {\n        ll a;\n        in >> a;\n        o = a;\n        return in;\n    }\n\n    friend std::ostream &operator<<(std::ostream &out, const mint &o) {\n        out << o.x;\n        return out;\n    }\n\n};\n\nstruct combination {\n    vector<mint> fact, ifact;\n\n    combination(int n) : fact(n + 1), ifact(n + 1) {\n        assert(n < mod);\n        fact[0] = 1;\n        for (int i = 1; i <= n; ++i) fact[i] = fact[i - 1] * i;\n        ifact[n] = fact[n].inv();\n        for (int i = n; i >= 1; --i) ifact[i - 1] = ifact[i] * i;\n    }\n\n    mint operator()(int n, int k) {\n        if (k < 0 || k > n) return 0;\n        return fact[n] * ifact[k] * ifact[n - k];\n    }\n} combination(1000000);\n\n\nmint sub(int n, int a, int b) {\n    cmin(b, n);\n    mint ans = 0;\n    for (int i = a % 2; i <= min({n, a, b,}); i += 2) {\n        ans += combination((a - i) / 2 + n - 1, n - 1) * combination(n, i);\n    }\n    return ans;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    mint ans = sub(n, 3 * m, m);\n    ans -= (sub(n, m, m) - sub(n - 1, m, m)) * n;\n    cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\nusing ll = int64_t;\n\nconstexpr ll MOD = 998244353;\n\nclass Combination {\npublic:\n    Combination(ll max_num) {\n        fact_.resize(max_num + 1, 1);\n        inv_fact_.resize(max_num + 1, 1);\n        for (ll i = 2; i <= max_num; i++) {\n            fact_[i] = i * fact_[i - 1] % MOD;\n            inv_fact_[i] = MODpow(fact_[i], MOD - 2);\n            assert(fact_[i] * inv_fact_[i] % MOD == 1);\n        }\n    }\n    ll operator()(ll n, ll m) const {\n        if (m < 0 || m > n) return 0;\n        return fact_[n] * inv_fact_[n - m] % MOD * inv_fact_[m] % MOD;\n    }\nprivate:\n    ll MODpow(ll n, ll m) const {\n        ll result = 1;\n        while (m) {\n            if (m % 2 == 1) {\n                result *= n;\n                result %= MOD;\n            }\n\n            m /= 2;\n            n *= n;\n            n %= MOD;\n        }\n\n        return result;\n    }\n\n    vector<ll> fact_, inv_fact_;\n} comb(2e6);\n\n//サイズがnの非負整数配列で総和がsであり奇数の要素がm個であるものの場合の数\nll f(ll n, ll s, ll m) {\n    ll result = 0;\n\n    //奇数の数を全探索\n    for (ll a = s % 1; a <= m; a += 2) {\n        //まず奇数になるところを決める\n        ll curr_num = comb(n, a);\n\n        //上で選んだ箇所に1を入れたとする\n        //残りs - aをn個の要素にそれぞれ偶数となるように分ければ良い\n        //そのような分け方は結局(s - a) / 2をn個に分ける\n        //要素と仕切りのやつ\n        (curr_num *= comb((s - a) / 2 + n - 1, n - 1)) %= MOD;\n\n        (result += curr_num) %= MOD;\n    }\n\n    return result;\n}\n\nint main() {\n    ll N, M;\n    cin >> N >> M;\n\n    //最大値が2Mを超えないという条件を無視した数\n    ll ans = f(N, 3 * M, M);\n\n    //最大値が2Mを超えるものの数を引く\n    ll sub = N * (f(N, M, M) - f(N - 1, M, M)) % MOD;\n    (ans += MOD - sub) %= MOD;\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\nusing num = modnum<998244353>;\n\nconst int V = 5.01e6;\nconst int MAXV = int(V * 1.1);\nnum fact[MAXV];\nnum ifact[MAXV];\nvoid precomp() {\n\tfact[0] = 1;\n\tfor (int i = 1; i <= V; i++) fact[i] = fact[i-1] * num(i);\n\tifact[V] = fact[V].inv();\n\tfor (int i = V; i >= 1; i--) ifact[i-1] = ifact[i] * num(i);\n}\n\nnum choose(int n, int r) {\n\tif (0 <= r && r <= n) return fact[n] * ifact[n-r] * ifact[r];\n\telse return 0;\n}\nnum distribute(int n, int b) {\n\treturn choose(n + b - 1, b - 1);\n}\n\n// good if:\n// sum = 3M\n// # odd <= M\n// max <= 2M\n// (each person gets <= M ops, but that's implied by max <= 2M)\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tprecomp();\n\n\tint N, M;\n\tcin >> N >> M;\n\n\tnum ans = distribute(3 * M, N);\n\n\t// subtract ones with max too big\n\tfor (int i = 2 * M + 1; i <= 3 * M; i++) {\n\t\tans -= num(N) * distribute(3 * M - i, N-1);\n\t}\n\n\t// subtract with too many odds\n\tfor (int i = M+2; i <= N; i += 2) {\n\t\tans -= choose(N, i) * distribute((3 * M - i) / 2, N);\n\t}\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat pw(cat a, cat e, cat mod) {\n\tif(e <= 0) return 1;\n\tcat x = pw(a, e/2, mod);\n\tx = x * x % mod;\n\tif(e&1) x = x * a % mod;\n\treturn x;\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, M;\n\tcin >> N >> M;\n\tcat tot = 1, dif = 0, fac_inv = 1, mod = 998244353;\n\tfor(int i = 1; i < N; i++) {\n\t\ttot = tot * (3*M+i) % mod;\n\t\tfac_inv = fac_inv * i % mod;\n\t}\n\tvector<cat> prod_m1(N+3*M+1, 0), prod_m2(N+3*M+1, 0);\n\tprod_m1[0] = fac_inv;\n\tprod_m2[0] = fac_inv * pw(N-1, mod-2, mod) % mod;\n\tfor(int i = 0; i < M; i++) {\n\t\tprod_m1[i+1] = prod_m1[i] * (i+N) % mod * pw(i+1, mod-2, mod) % mod;\n\t\tprod_m2[i+1] = prod_m2[i] * (i+N-1) % mod * pw(i+1, mod-2, mod) % mod;\n\t}\n\tfor(int i = 0; i < M; i++) dif = (dif + prod_m2[i]) % mod;\n\tdif = dif * N % mod * (N-1) % mod;\n\tvector<cat> C(N+1, 0); // C(N, i)\n\tC[0] = 1;\n\tfor(int i = 1; i <= N; i++) C[i] = C[i-1] * pw(i, mod-2, mod) % mod * (N-i+1) % mod;\n\tfor(int i = M+1; i <= min(3*M, N); i++) if((M-i)%2 == 0)\n\t\tdif = (dif + prod_m1[(3*M-i)/2] * C[i]) % mod;\n\tcat ans = (tot - dif) * pw(fac_inv, mod-2, mod) % mod;\n\tif(ans < 0) ans += mod;\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;;\n#define ll long long\n#define rep(i, n) for(int i = 0;i < n;i++)\n#define repr(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(ll i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define INF 1<<30\n#define LINF 1LL<<62\n#define all(x) (x).begin(), (x).end()\n#define mp make_pair\n#define pb push_back\nconst ll MOD = 998244353;\n \ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\n\nconst int MAX = 3000000;\nlong long fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  COMinit();\n  ll n,m;cin >>n >> m;\n  ll ans = COM(3*m + n - 1 , n-1);\n  FOR(i,2*m+1, 3*m+1){\n      ll x = 3*m - i;\n      ll tmp = n * COM(x + n - 2 , n - 2) % MOD;\n      ans -= tmp ;\n      ans += MOD;\n      ans %= MOD;\n  }\n  FOR(i,m+1,n+1){\n      if((3*m-i)%2==1)continue;\n      ll eve = (3*m-i)/2;\n      ll x = COM(n,i) * COM(eve + n - 1, n-1) % MOD;\n      ans -= x;\n      ans += MOD;\n      ans %=MOD;\n  }\n  cout << ans << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD 998244353\n\nstruct llm{\n    ll value=0;\n    llm(const ll& val=0){this->value = (MOD + val % MOD) % MOD;}\n    llm(const int& val){this->value = (MOD + val % MOD) % MOD;}\n    llm(const llm& a) { llm(a.value); }\n    llm inv(){ll a = 1;ll b = this->value;for(ll m=MOD-2;m>0;m/=2){if(m&1){a=a*b%MOD;}b=b*b%MOD;}return llm(a);}\n    llm &operator+=(const llm &a) {this->value = (this->value + a.value) % MOD;return *this;}\n    llm &operator-=(const llm &a) {this->value = (this->value - a.value + MOD) % MOD;return *this;}\n    llm &operator*=(const llm &a) {this->value = (this->value * a.value) % MOD; return *this; }\n    explicit operator ll() const{return (ll)value;}\n    explicit operator int() const{return (int)value;}\n};\nllm operator+(const llm &a, const llm &b) { return llm(a.value + b.value); }\nllm operator-(const llm &a, const llm &b) { return llm(a.value - b.value); }\nllm operator*(const llm &a, const llm &b) { return llm(a.value * b.value); }\n#define pllm pair<llm,llm>\n\nllm Fa[5050505];\nllm C(const ll& a,const ll& b){\n    if(a<b||a<0||b<0)\n        return 0;\n    return Fa[a] * (Fa[b]* Fa[a - b]).inv();\n}\n\n\nll N,M;\nll i,j,k;\nllm ans;\nint main(){\n    scanf(\"%lld%lld\", &N, &M);\n    Fa[0] = 1;\n    fornum(i,0,5040302){\n        Fa[i + 1] = Fa[i] * (i + 1);\n    }\n    ans = C(N - 1 + M * 3, N - 1);\n    //printf(\"%lld\\n\", (ll)ans);\n    fornum(i,0,N+1){\n        if(i>M*3)\n            break;\n        if ((M * 3 - i) % 2)\n            continue;\n        if(i<=M){\n            ans -= C(N - 1, i) * N * C(N - 1 + (M - i - 2) / 2, N - 1);\n            ans -= C(N - 1, i - 1) * N * C(N - 1 + (M - i) / 2, N - 1);\n        }else{\n            ans -= C(N, i) * C(N - 1 + (M * 3 - i) / 2, N - 1);\n        }\n    }\n    printf(\"%lld\", (ll)ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\n#define MN 2500000\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,m,ans,p[MN+5],inv[MN+5];\ninline int C(int n,int m){return m>n?0:1LL*p[n]*inv[m]%mod*inv[n-m]%mod;}\nint main()\n{\n    n=read();m=read();\n    p[0]=p[1]=inv[0]=inv[1]=1;\n    for(int i=2;i<=MN;++i) p[i]=1LL*p[i-1]*i%mod,inv[i]=1LL*(mod-mod/i)*inv[mod%i]%mod;\n    for(int i=2;i<=MN;++i) inv[i]=1LL*inv[i-1]*inv[i]%mod;\n    if(n==2) return 0*printf(\"%d\\n\",m+1);\n    for(int i=0;i<=m;i+=2) if(m-i<=n)\n    {\n        int t=i/2+m;\n        ans=(ans+1LL*C(n,m-i)*C(t+n-1,n-1))%mod;\n        ans=(ans+1LL*C(n,m-i)*(mod-(m-i))%mod*C(t-m+n-1,n-1))%mod;\n        ans=(ans+1LL*C(n,m-i)*(mod-(n-(m-i)))%mod*C(t-m+n-2,n-1))%mod;\n    }\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\n\n// template {{{  0 \n// using {{{ 1\nusing ll = long long int;\nusing pii = pair<int,int>;\nusing pll = pair<ll,ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vii = vector<pii>;\nusing vll = vector<pll>;\n// }}} 1\n// definition {{{ 1\n// scaning {{{ 2\n#define Scd(x) scanf(\"%d\", &x)\n#define Scd2(x,y) scanf(\"%d%d\", &x, &y)\n#define Scd3(x,y,z) scanf(\"%d%d%d\", &x, &y, &z)\n#define Scll(x) scanf(\"%lld\", &x)\n#define Scll2(x,y) scanf(\"%lld%lld\", &x, &y)\n#define Scll3(x,y,z) scanf(\"%lld%lld%lld\", &x, &y, &z)\n#define Scc(c) scanf(\"%c\", &c);\n#define Scs(s) scanf(\"%s\", s);\n#define Scstr(s) scanf(\"%s\", &s);\n// }}} 2\n// constants {{{ 2\n#define EPS (1e-7)\n#define INF (2e9)\n#define PI (acos(-1))\n// }}} 2\n// systems {{{ 2\n#define Repe(x,y,z) for(ll x = z; x < y; x++)\n#define Rep(x,y) Repe(x,y,0)\n#define RRepe(x,y,z) for(ll x = y-z-1; x >= 0; x--)\n#define RRep(x,y) RRepe(x,y,0)\n// }}} 2\n// output {{{ 2\n#define YesNo(a) (a)?printf(\"Yes\\n\"):printf(\"No\\n\")\n#define YESNO(a) (a)?printf(\"YES\\n\"):printf(\"NO\\n\")\n// }}} 2\n// }}} 1\n// input {{{ 1\n// }}} 1\n// }}} 0\n\nconst long long int mod = 998244353;\n\n// PowMod( base, index, modulo) return base ** index % modulo {{{\n// PowMod = base ** index % mod ( natural numbers )\ninline constexpr long long int PowMod( long long int base, long long int index, long long int modulo = mod ){\n    // O( log(index) )\n    long long int ret = 1;\n    while( index ){\n        if( index&1 ) (ret *= base) %= mod;\n        (base *= base) %= mod;\n        index >>= 1;\n    }\n    return ret;\n}\n// }}}\n// CombMod( n, r, modulo ) return nCr % modulo {{{\n// CombMod(ination) = nCr % mod ( natural number )\ninline constexpr long long int CombMod( long long int n, long long int r, long long int modulo = mod){\n    if( n < r ) return CombMod(r,n,modulo);\n    long long int Upper = 1;\n    long long int Lower = 1;\n    for(long long int i = 0; i < r; i++){\n        Upper = Upper * (n-i) % modulo;\n        Lower = Lower * (i+1) % modulo;\n    }\n    // Return (Upper / Lower)\n    long long int ret = Upper * PowMod(Lower,modulo-2,modulo) % modulo;\n    return ret;\n}\n// }}}\n// FactMod( n, modulo ) return n! % modulo {{{\n// Fact(orial) = n! % mod ( natural number )\ninline constexpr long long int Fact( long long int n, long long int modulo = mod){\n    long long int Upper = 1;\n    for(long long int i = 0; i < n; i++){\n        Upper = Upper * (n-i) % modulo;\n    }\n    return Upper;\n}\n// }}}\n// modint {{{\n\nstruct modint{\n    long long int a;\n    inline constexpr modint( long long int x = 0 ) noexcept : a(x % mod) {}\n    inline constexpr long long int &value() noexcept { return a; }\n    inline constexpr const long long int &value() const noexcept { return a; }\n    inline constexpr modint operator+(const modint rhs) const noexcept{ return modint(*this) += rhs; }\n    inline constexpr modint operator+(const int rhs) const noexcept{ return modint(*this) += rhs; }\n    inline constexpr modint operator+(const long long int rhs) const noexcept{ return modint(*this) += rhs; }\n    inline constexpr modint operator-(const modint rhs) const noexcept{ return modint(*this) -= rhs; }\n    inline constexpr modint operator-(const int rhs) const noexcept{ return modint(*this) -= rhs; }\n    inline constexpr modint operator-(const long long int rhs) const noexcept{ return modint(*this) -= rhs; }\n    inline constexpr modint operator*(const modint rhs) const noexcept{ return modint(*this) *= rhs; }\n    inline constexpr modint operator*(const int rhs) const noexcept{ return modint(*this) *= rhs; }\n    inline constexpr modint operator*(const long long int rhs) const noexcept{ return modint(*this) *= rhs; }\n    inline constexpr modint operator/(const modint rhs) const noexcept{ return modint(*this) /= rhs; }\n    inline constexpr modint operator/(const int rhs) const noexcept{ return modint(*this) /= rhs; }\n    inline constexpr modint operator/(const long long int rhs) const noexcept{ return modint(*this) /= rhs; }\n    inline constexpr modint operator+=(const modint rhs) noexcept{ a += rhs.a; if( a >= mod ) a -= mod; return *this; }\n    inline constexpr modint operator-=(const modint rhs) noexcept{ a -= rhs.a; if( a < 0 ) a += mod; return *this; }\n    inline constexpr modint operator*=(const modint rhs) noexcept{ a = a * rhs.a % mod ;  return *this; }\n    inline constexpr modint operator/=(const modint rhs) noexcept{ a = a * PowMod(rhs.a,mod-2) % mod; return *this; }\n};\n\n// }}}\n\n\nint main() {\n\n    ll N,M;\n    Scll2(N,M);\n\n    vector<modint> f(N+3*M+3,1);\n    vector<modint> fr(N+3*M+3,1);\n\n    Rep(i,f.size()-1){\n        f[i+1] = f[i] * (i+1);\n        fr[i+1] = fr[i] / (i+1);\n    }\n\n    // N_H_3M = N+3M-1_C_3M\n    modint ans = f[N+3*M-1]*fr[3*M]*fr[N-1];\n    modint t;\n\n    for( int i = 2*M+1; i < 3*M+1; i++ ){\n        t = f[N+3*M-i-2]*fr[3*M-i]*fr[N-2]*N;\n        ans -= t;\n    }\n\n    for( int i = M-1; i >= 0; i-- ){\n        if( 3*M-2*i > N ) break;\n        t  = f[N+i-1] * fr[i] * fr[N-1];\n        t *= f[N] * fr[3*M-2*i] * fr[N-3*M+2*i];\n        ans -= t;\n    }\n\n    printf (\"%lld\\n\", ans );\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : C.cpp\n * Author  : Kazune Takahashi\n * Created : 7/21/2019, 10:28:37 PM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n#define maxs(x, y) (x = max(x, y))\n#define mins(x, y) (x = min(x, y))\nusing ll = long long;\nclass mint\n{\npublic:\n  static ll MOD;\n  ll x;\n  mint() : x(0) {}\n  mint(ll x) : x(x % MOD) {}\n  mint operator-() const { return x ? MOD - x : 0; }\n  mint &operator+=(const mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  mint &operator-=(const mint &a) { return *this += -a; }\n  mint &operator*=(const mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  mint &operator/=(const mint &a)\n  {\n    mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  mint operator+(const mint &a) const { return mint(*this) += a; }\n  mint operator-(const mint &a) const { return mint(*this) -= a; }\n  mint operator*(const mint &a) const { return mint(*this) *= a; }\n  mint operator/(const mint &a) const { return mint(*this) /= a; }\n  bool operator<(const mint &a) const { return x < a.x; }\n  bool operator==(const mint &a) const { return x == a.x; }\n  const mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\nll mint::MOD = 998244353;\nistream &operator>>(istream &stream, mint &a) { return stream >> a.x; }\nostream &operator<<(ostream &stream, const mint &a) { return stream << a.x; }\nclass combination\n{\npublic:\n  vector<mint> inv, fact, factinv;\n  static int MAX_SIZE;\n  combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[mint::MOD % i]) * (mint::MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1; i < MAX_SIZE; i++)\n    {\n      fact[i] = mint(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  mint operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n};\nint combination::MAX_SIZE = 2000010;\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\n// constexpr double epsilon = 1e-10;\n// constexpr ll infty = 1000000000000000LL;\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n\nll N, M;\n\nint main()\n{\n  cin >> N >> M;\n  combination C;\n  mint ans = C(3 * M + N - 1, N - 1);\n  for (auto K = 3 * M; K >= 2 * M + 1; K--)\n  {\n    ans -= C(3 * M - K + N - 2, N - 2) * N;\n  }\n  for (auto K = 0LL; K < M; K++)\n  {\n    if (3 * M - 2 * K >= 0)\n    {\n      assert(false);\n    }\n    ans -= C(N, 3 * M - 2 * K) * C(K + N - 1, N - 1);\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong N,M,mod=1e9+7;\nlong F[1<<22],I[1<<22];\nlong power(long a,long b){return b?power(a*a%mod,b/2)*(b%2?a:1)%mod:1;}\nlong C(long a,long b)\n{\n\treturn a<b||a<0||b<0?0:F[a]*I[b]%mod*I[a-b]%mod;\n}\nlong H(long a,long b){return a<0?0:C(a+b-1,b-1);}\nlong calc(long S,long O)\n{\n\treturn(H(S,N-1)-H(S-M-1,N-1)*(N-1-O)%mod-H(S-M,N-1)*O%mod+mod+mod)%mod*C(N-1,O)%mod;\n}\nlong sum(long L,long R)\n{\n\tlong D=R-L+1;\n\treturn D*(D+1)/2%mod+L*D%mod;\n}\nlong cumA[1<<22];\nlong cumB[1<<22];\nlong cumC[1<<22];\nmain()\n{\n\tcin>>N>>M;\n\tlong T=1<<22;\n\tF[0]=1;\n\tfor(long i=1;i<T;i++)F[i]=F[i-1]*i%mod;\n\tI[T-1]=power(F[T-1],mod-2);\n\tfor(long i=T-1;i--;)I[i]=I[i+1]*(i+1)%mod;\n\tcumA[0]=H(0,N-1);\n\tcumB[0]=H(0-M-1,N-1);\n\tcumC[0]=H(0-M,N-1);\n\tfor(long i=1;i<N*2;i++)\n\t{\n\t\tcumA[i]=(cumA[i-1]+H(i,N-1))%mod;\n\t\tcumB[i]=(cumB[i-1]+H(i-M-1,N-1))%mod;\n\t\tcumC[i]=(cumC[i-1]+H(i-M,N-1))%mod;\n\t}\n\tlong ans=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tlong L=(M-i+1)/2,R=(3*M-i)/2;\n\t\tlong A=(cumA[R]-(L<1?0:cumA[L-1])+mod)%mod;\n\t\tlong B=(cumB[R]-(L<1?0:cumB[L-1])+mod)%mod*(N-1-i)%mod;\n\t\t\n\t\tlong CC=(cumC[R]-(L<1?0:cumC[L-1])+mod)%mod*i%mod;\n\t\tA=(A-B-CC+mod+mod)%mod;\n\t\tA=C(N-1,i)%mod*A%mod;\n\t\tans=(ans+A)%mod;\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████\n#include \"bits/stdc++.h\"\nusing namespace std;\n//#define MOD 1000000007\n#define MOD 998244353\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define D double\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\n\n#include <cstdint>\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\n  u64 a;\n\npublic:\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 val() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr bool operator==(const modint rhs) const noexcept {\n    return modint(*this).val() == rhs.val();\n  }\n  modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\nusing mint = modint<MOD>;\n\ntypedef vector<mint> vec;\ntypedef vector<vector<mint>> mat;\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,m;\n  cin >> n >> m;\n\n  vec fact(n+3*m+10,1);\n  REP(i,n+3*m+9) fact[i+1] = fact[i]*(i+1);\n\n  mint ans = 0; \n\n  //1をi個セットにする\n  REP(i,m/2+1){\n    int one = m-i*2, two = m+i;\n    if(one > n) continue;\n    mint tmp = fact[n-2+two-m]/fact[n-2]/fact[two-m]*n;\n    if(one < n)ans += tmp * fact[n-1]/fact[one]/fact[n-1-one];\n    //debug(ans.val());\n\n    mint tmp2 = fact[n-1+two]/fact[n-1]/fact[two];\n    if(two-m>=0)tmp2 -= fact[n-1+two-m]/fact[two-m]/fact[n-1]*n;// m-1回積みまでok\n    if(one <= n) ans += tmp2 * fact[n]/fact[one]/fact[n-one];\n    //debug(ans.val());\n  }\n\n  cout << ans.val() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SZ(x) ((int)((x).size()))\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\ntemplate<class TH>\nvoid _dbg(const char* name, TH val){\n    clog << name << \": \" << val << endl;\n}\ntemplate<class TH, class... TA>\nvoid _dbg(const char* names, TH curr_val, TA... vals) {\n    while(*names != ',') clog << *names++;\n    clog << \": \" << curr_val << \", \";\n    _dbg(names+1, vals...);\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n    #define dbg_arr(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg(...)\n    #define dbg_arr(x, len)\n#endif\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\nLL Inverse(LL n, LL m) {\n    n %= m;\n    if (n <= 1) return n; // Handles properly (n = 0, m = 1).\n    return m - ((m * Inverse(m, n) - 1) / n);\n}\n\nconst LL mod = 998244353;\nconst int MAXN = 4e6;\nLL fact[MAXN];\n\nLL binom(LL a, LL b) {\n    assert(MAXN > a and a >= b and b >= 0);\n    return fact[a] * Inverse(fact[b]*fact[a-b] % mod, mod) % mod;\n}\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in problems with online queries!\n\n    fact[0] =  1;\n    for (int i = 1; i < MAXN; i++) {\n        fact[i] = i*fact[i-1] % mod;\n        // invfact[i] = Inverse(fact[i], mod);\n    }\n\n    int N, M;\n    cin >> N >> M;\n\n    LL ans = N * binom(M + N-2, N-2) % mod;\n    for (int k = 0; k <= M; k++) {\n        LL q = 3*M-k;\n        if (q % 2) continue;\n        q /= 2;\n        LL ris = binom(q + N-1, N-1) - N*binom(q-M + N-1, N-1);\n        ris %= mod;\n        ris = ris * binom(N, k) % mod;\n        ans += ris;\n        ans %= mod;\n    }\n    if (ans < 0) ans += mod;\n    cout << ans << \"\\n\";\n\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 4e6 + 10;\nconst int mod = 998244353;\n\ninline int fpow (int a, int b) {\n\tint ret = 1;\n\twhile (b) {\n\t\tret = 1ll * ret * a % mod;\n\t\ta = 1ll * a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\n\nint f[N], invf[N];\n\nvoid predeal (int n) {\n\tf[0] = invf[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[i] = 1ll * f[i - 1] * i % mod;\n\t}\n\tinvf[n] = fpow(f[n], mod - 2);\n\tfor (int i = n - 1; i >= 1; i--) {\n\t\tinvf[i] = 1ll * invf[i + 1] * (i + 1) % mod; \n\t}\n}\n\ninline int C (int n, int m) {\n\treturn 1ll * f[n] * invf[m] % mod * invf[n - m] % mod;\n}\n\nint main (void) {\n\tpredeal(2e6);\n\n\tint n, m, ans = 0;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i <= m; i++) {\n\t\tif ((m - i) & 1) continue;\n\t\tans += 1ll * C(n, i) * C((3 * m - i) / 2 + n - 1, n - 1) % mod;\n\t\tif (ans >= mod) ans -= mod;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tif ((m - 1 - i) & 1) continue;\n\t\tans -= 1ll * C(n, 1) * C(n, i) % mod * C((m - 1 - i) / 2 + n - 1, n - 1) % mod;\n\t\tif (ans < 0) ans += mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 3000000, md = 998244353;\n\nlong long inv[MX], f[MX], inv_f[MX];\n\nlong long c(int n, int k) {\n\tif (k == -1) return n == -1 ? 1 : 0;\n\t\n\treturn f[n] * inv_f[n - k] % md * inv_f[k] % md;\n}\n\nint main() {\n\tinv[1] = f[0] = f[1] = inv_f[0] = inv_f[1] = 1;\n\tfor (int i = 2; i < MX; i++) {\n\t\tinv[i] = md - inv[md % i] * (md / i) % md;\n\t\tf[i] = f[i - 1] * i % md;\n\t\tinv_f[i] = inv_f[i - 1] * inv[i] % md;\n\t}\n\t\n\tint n, m;\n\tignore = scanf(\"%d %d\", &n, &m);\n\t\n\tint ans = 0;\n\tfor (int k = m % 2; k <= m && k <= n; k += 2) {\n\t\tans = (ans + c(n, k) * c((3 * m - k) / 2 + n - 1, n - 1)) % md;\n\t}\n\t\n\tfor (int k = 2 * m + 1; k <= 3 * m; k++) {\n\t\tans = (ans - c(3 * m - k + n - 2, n - 2) * n) % md;\n\t}\n\t\n\tif (ans < 0) ans += md;\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Tp template<typename Ty>\n#define Ts template<typename Ty,typename... Ar>\n#define Reg register\n#define RI Reg int\n#define Con const\n#define CI Con int&\n#define I inline\n#define W while\n#define SZ 5000000\n#define X 998244353\n#define Qinv(x) Qpow(x,X-2)\n#define Inc(x,y) ((x+=(y))>=X&&(x-=X))\n#define C(x,y) ((x)<(y)?0:1LL*Fac[x]*IFac[y]%X*IFac[(x)-(y)]%X)\n#define S(x,y) C((x)+(y)-1,(y)-1)\nusing namespace std;\nint n,m,Fac[SZ+5],IFac[SZ+5];\nI int Qpow(RI x,RI y) {RI t=1;W(y) y&1&&(t=1LL*t*x%X),x=1LL*x*x%X,y>>=1;return t;}\nint main()\n{\n\tRI i,ans=0;for(scanf(\"%d%d\",&n,&m),Fac[0]=i=1;i<=SZ;++i) Fac[i]=1LL*Fac[i-1]*i%X;\n\tfor(IFac[SZ]=Qinv(Fac[SZ]),i=SZ-1;~i;--i) IFac[i]=1LL*IFac[i+1]*(i+1)%X;\n\tfor(i=m&1;i<=m;i+=2) ans=(1LL*C(n,i)*S(3*m-i>>1,n)+ans)%X;\n\tfor(i=2*m+1;i<=3*m;++i) ans=(X-1LL*n*S(3*m-i,n-1)+ans)%X;\n\treturn printf(\"%d\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#if DEBUG\n// basic debugging macros\nint __i__,__j__;\n#define printLine(l) for(__i__=0;__i__<l;__i__++){cout<<\"-\";}cout<<endl\n#define printLine2(l,c) for(__i__=0;__i__<l;__i__++){cout<<c;}cout<<endl\n#define printVar(n) cout<<#n<<\": \"<<n<<endl\n#define printArr(a,l) cout<<#a<<\": \";for(__i__=0;__i__<l;__i__++){cout<<a[__i__]<<\" \";}cout<<endl\n#define print2dArr(a,r,c) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<a[__i__][__j__]<<\" \";}cout<<endl;}\n#define print2dArr2(a,r,c,l) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<setw(l)<<setfill(' ')<<a[__i__][__j__]<<\" \";}cout<<endl;}\n\n// advanced debugging class\n// debug 1,2,'A',\"test\";\nclass _Debug {\n    public:\n        template<typename T>\n        _Debug& operator,(T val) {\n            cout << val << endl;\n            return *this;\n        }\n};\n#define debug _Debug(),\n#else\n#define printLine(l)\n#define printLine2(l,c)\n#define printVar(n)\n#define printArr(a,l)\n#define print2dArr(a,r,c)\n#define print2dArr2(a,r,c,l)\n#define debug\n#endif\n\n// define\n#define MAX_VAL 999999999\n#define MAX_VAL_2 999999999999999999LL\n#define EPS 1e-6\n#define mp make_pair\n#define pb push_back\n\n// typedef\ntypedef unsigned int UI;\ntypedef long long int LLI;\ntypedef unsigned long long int ULLI;\ntypedef unsigned short int US;\ntypedef pair<int,int> pii;\ntypedef pair<LLI,LLI> plli;\ntypedef vector<int> vi;\ntypedef vector<LLI> vlli;\ntypedef vector<pii> vpii;\ntypedef vector<plli> vplli;\n\n// ---------- END OF TEMPLATE ----------\n#define MOD 998244353\n\nint inv(LLI n) {\n    int e = MOD-2;\n    LLI r = 1;\n    while (e > 0) {\n        if (e & 1) r *= n,r %= MOD;\n        e >>= 1;\n        n *= n,n %= MOD;\n    }\n    return r;\n}\nint fact[3000000];\nint invfact[3000000];\nint choose(int n,int k) {\n    return ((((LLI) fact[n]*invfact[k]) % MOD)*invfact[n-k]) % MOD;\n}\nint main() {\n    int i;\n    int N,M;\n    cin >> N >> M;\n\n    fact[0] = 1;\n    for (i = 1; i < 3000000; i++) fact[i] = ((LLI) fact[i-1]*i) % MOD;\n    invfact[2999999] = inv(fact[2999999]);\n    for (i = 2999998; i >= 0; i--) invfact[i] = ((LLI) invfact[i+1]*(i+1)) % MOD;\n    LLI ans = choose(3*M+N-1,N-1);\n    for (i = 2*M+1; i <= 3*M; i++) ans -= ((LLI) N*choose(3*M-i+N-2,N-2)) % MOD;\n    for (i = M+1; i <= N; i++) {\n        if (!((3*M-i) & 1)) ans -= ((LLI) choose(N,i)*choose((3*M-i)/2+N-1,N-1)) % MOD;\n    }\n    ans %= MOD;\n    if (ans < 0) ans += MOD;\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\nconst int P=998244353,maxn=(2e6)+5;\nLL N,M,K,Fac[maxn],Inv[maxn],Ans;\nLL Pow(LL a,LL b){LL s=1;for(LL w=a;b;b>>=1,w=w*w%P) if(b&1) s=s*w%P;return s;}\ninline LL C(LL a,LL b){return Fac[a]*Inv[b]%P*Inv[a-b]%P;}\ninline void Add(LL& x,LL y){if((x+=y)>=P) x-=P;}\ninline void Dec(LL& x,LL y){if((x-=y)<0) x+=P;}\nint main(){\n\tfreopen(\"Warlock.in\",\"r\",stdin);\n\tfreopen(\"Warlock.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&N,&M),K=N+(M<<1);\n\tFac[0]=1;\n\tfor(int i=1;i<=K;i++) Fac[i]=Fac[i-1]*i%P;\n\tInv[K]=Pow(Fac[K],P-2);\n\tfor(int i=K-1;~i;i--) Inv[i]=Inv[i+1]*(i+1)%P;\n\tfor(int i=0,tp;i<=N&&i<=M;i++) if(!((tp=(M<<1)+M-i)&1)) Add(Ans,C(N,i)*C((tp>>1)+N-1,N-1)%P);\n\tLL O=0;\n\tfor(int i=(M<<1)+1,ti=(M<<1)+M;i<=ti;i++) Add(O,C(ti-i+N-2,N-2)%P);\n\tDec(Ans,N*O%P);\n\tprintf(\"%lld\\n\",Ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long hxtype;\ntemplate<class IT>inline void cmax(IT &a,IT b){if(a<b)a=b;}\ntemplate<class IT>inline void cmin(IT &a,IT b){if(b<a)a=b;}\nconst ll p=998244353ll,pp=p*p;\nconst int N=2500000;\nll fac[N+5],ifa[N+5];\ninline ll expo(ll a,int b=998244351){\n\tll c=1ll;\n\twhile(b){\n\t\tif(b&1)c=c*a%p;\n\t\tb>>=1; a=a*a%p;\n\t}\n\treturn c;\n}\ninline ll C(int a,int b){return fac[a]*(ifa[a-b]*ifa[b]%p)%p;}\ninline ll f(int a,int b){return b?C(a+b-1,a):(!a);}\ninline void app(ll &a){if(a> pp)a-=pp;}\ninline void spp(ll &a){if(a<0ll)a+=pp;}\nint main(){\n\tint n,m,i,t,b;ll ans;\n\tscanf(\"%d%d\",&n,&m);t=m+(m<<1);\n\tfac[0]=1ll;\n\tfor(i=1;i<=N;++i)fac[i  ]=fac[i-1]*i%p;\n\tifa[N]=expo(fac[N]);\n\tfor(i=N;i   ;--i)ifa[i-1]=ifa[i  ]*i%p;\n\tans=f(t,n)-n*f(m-1,n);\n\tb=min(t,n);\n//\tprintf(\"ans=%lld b=%d n=%d m=%d t=%d\\n\",ans,b,n,m,t);\n/*\tfor(i=++m;i<=b;++i){\n//\t\tif((i^m)&1)printf(\"+%lld %lld %lld\\n\",C(i,m),C(n,i),f(t-i,n-i));\n//\t\telse       printf(\"-%lld %lld %lld\\n\",C(i,m),C(n,i),f(t-i,n-i));\n\t\tif((i^m)&1)app(ans+=(C(i-1,i-m)*C(n,i)%p)*f(t-i,n-i));\n\t\telse       spp(ans-=(C(i-1,i-m)*C(n,i)%p)*f(t-i,n-i));\n\t}*/\n\tfor(i=m+2;i<=b;i+=2){\n\t\tspp(ans-=C(n,i)*f((t-i)>>1,n));\n\t}\n\tprintf(\"%lld\",(ans+pp)%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=998244353;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=3010000;\n\nint n,m;\nll fac[N],fnv[N],inv[N];\nll comb(int a,int b) {\n\tif (b>a||b<0) return 0;\n\treturn fac[a]*fnv[b]%mod*fnv[a-b]%mod;\n}\n\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tfac[0]=fnv[0]=fac[1]=fnv[1]=1;\n\tinv[0]=inv[1]=1;\n\trep(i,2,3000001) {\n\t\tfac[i]=fac[i-1]*i%mod;\n\t\tinv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\t\tfnv[i]=fnv[i-1]*inv[i]%mod;\n\t}\n\tll ans=0;\n\tfor (int odd=0;odd<=n&&odd<=m;odd++) {\n\t\tif (3*m%2!=odd%2) continue;\n\t\tans=(ans+comb(n,odd)*(comb((3*m-odd)/2+n-1,n-1)-n*comb((m-odd)/2+n-1,n-1)%mod))%mod;\n\t}\n\tans=(ans+n*comb(m+n-2,n-2))%mod;\n\tif (ans<0) ans+=mod;\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nconst int P = 998244353;\nstruct FastNewton {\nprivate:\n  long long P;\n  long long range;\n  vector<long long> inv;\n  vector<long long> fact;\n  vector<long long> fact_inv;\n  vector<long long> v_p;\n  \npublic:\n  FastNewton (long long _P, long long _range = 0) {\n    init(_P, _range);\n  }\n  \n  // Initialize structures to support computing n choose k mod _P, where n <= range\n  void init(long long _P, long long _range = -1) {\n    P = _P;\n    if (_range == -1) {\n      range = P;\n    } else {\n      range = _range;\n    }\n    inv.resize(range + 5);\n    fact.resize(range + 5);\n    fact_inv.resize(range + 5);\n    v_p.resize(range + 5);\n    fact[0] = 1;\n    fact_inv[0] = 1;\n    inv[0] = -1;\n    inv[1] = 1;\n    for (int i = 2; i < min(range, P); i++) {\n      inv[i] = P - (P / i) * inv[P % i] % P;\n    }\n    for (int i = 1; i <= range; i++) {\n      ll tmp = i;\n      while (tmp % P == 0) {\n        tmp /= P;\n      }\n      fact[i] = tmp * fact[i - 1] % P;\n      fact_inv[i] = fact_inv[i - 1] * inv[tmp % P] % P;\n    }\n    for (int i = 1; i <= range; i++) {\n      v_p[i] = i / P + v_p[i / P];\n    }\n  }\n  \n  long long get_inv(long long a) const {\n    if (a % P == 0) {\n      cout<<\"ERROR: 0 has not got its inverse\\n\";\n      return -1;\n    }\n    return inv[a % P];\n  }\n  \n  // Computes n! mod P\n  long long get_normal_fact(long long n) const {\n    if (n >= P) {\n      return 0;\n    }\n    return fact[n];\n  }\n  \n  // Computes n!/p^(v_p(n!)) mod P\n  long long get_better_fact(long long n) const {\n    if (n > range) {\n      cout<<\"ERROR: n too large\\n\";\n      return -1;\n    }\n    return fact[n];\n  }\n  \n  // Computes largest k such that p^k | n!\n  long long get_v_p(long long n) const {\n    if (n > range) {\n      cout<<\"ERROR: n too large\\n\";\n      return -1;\n    }\n    return v_p[n];\n  }\n  \n  // Computes (n choose k) mod p\n  long long choose(long long n, long long k) const {\n    if (k < 0 || k > n) {\n      return 0;\n    }\n    if (v_p[n] == v_p[k] + v_p[n - k]) {\n      return fact[n] * fact_inv[k] % P * fact_inv[n - k] % P;\n    } else {\n      return 0;\n    }\n  }\n  \n};\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n, m;\n  cin>>n>>m;\n  int res = 0;\n  FastNewton newt(P, 2 * n + 2 * m);\n  FOR (doubles, m, 2 * m) {\n    int ones = 3 * m - 2 * doubles;\n    if (ones < 0) { break; }\n    debug(doubles, ones);\n    if (ones <= n) {\n      res = (res + newt.choose(doubles + n - 1, n - 1) * newt.choose(n, ones)) % P;\n    }\n  }\n  int bad = 0;\n  FOR (i, 2 * m + 1, 3 * m) {\n    bad = (bad + newt.choose(3 * m - i + n - 2, n - 2)) % P;\n  }\n  debug(bad);\n  cout<<((res - n * bad) % P + P) % P<<endl;\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nconfirm 0LL and 1LL\nconfirm cornercases such as 0\nconfirm times of cin < 10^6\n*/\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\nusing Vec = vector<ll>;\nusing VecP = vector<P>;\nusing VecB = vector<bool>;\nusing VecC = vector<char>;\nusing VecD = vector<ld>;\nusing VecS = vector<string>;\nusing Graph = vector<VecP>;\ntemplate <typename T>\nusing Vec1 = vector<T>;\ntemplate <typename T>\nusing Vec2 = vector<Vec1<T> >;\n#define REP(i, m, n) for(ll i = (m); (i) < (n); ++(i))\n#define REPN(i, m, n) for(ll i = (m); (i) <= (n); ++(i))\n#define REPR(i, m, n) for(ll i = (m)-1; (i) >= (n); --(i))\n#define REPNR(i, m, n) for(ll i = (m); (i) >= (n); --(i))\n#define rep(i, n) REP(i, 0, n)\n#define repn(i, n) REPN(i, 1, n)\n#define repr(i, n) REPR(i, n, 0)\n#define repnr(i, n) REPNR(i, n, 1)\n#define all(s) (s).begin(), (s).end()\n#define pb push_back\n#define fs first\n#define sc second\ntemplate <typename T>\nbool chmax(T &a, const T b){if(a < b){a = b; return true;} return false;}\ntemplate <typename T>\nbool chmin(T &a, const T b){if(a > b){a = b; return true;} return false;}\ntemplate <typename T>\nll pow2(const T n){return (1LL << n);}\ntemplate <typename T>\nvoid cosp(const T n){cout << n << ' ';}\nvoid co(void){cout << '\\n';}\ntemplate <typename T>\nvoid co(const T n){cout << n << '\\n';}\ntemplate <typename T1, typename T2>\nvoid co(pair<T1, T2> p){cout << p.fs << ' ' << p.sc << '\\n';}\ntemplate <typename T>\nvoid co(const Vec1<T> &v){for(T i : v) cosp(i); co();}\ntemplate <typename T>\nvoid co(initializer_list<T> v){for(T i : v) cosp(i); co();}\ntemplate <typename T>\nvoid ce(const T n){cerr << n << endl;}\nvoid sonic(){ios::sync_with_stdio(false); cin.tie(0);}\nvoid setp(const ll n){cout << fixed << setprecision(n);}\nconstexpr int INF = 1e9+1;\nconstexpr ll LINF = 1e18+1;\n//constexpr ll MOD = 1e9+7;\nconstexpr ll MOD = 998244353;\nconstexpr ld EPS = 1e-11;\nconst ld PI = acos(-1);\n\nVec fac, finv;\n\nll PowMod(ll a, ll n){\n\tif(n < 0) return PowMod(PowMod(a, -n), MOD-2);\n\tif(n == 0) return 1;\n\tif(n == 1) return a;\n\tif(n%2 == 0) return PowMod(a*a%MOD, n/2);\n\treturn a*PowMod(a*a%MOD, n/2)%MOD;\n}\n\nll inv(ll n){\n\treturn PowMod(n, MOD-2);\n}\n\nvoid init(ll n = 2e6){\n\tfac.resize(n+1);\n\tfac[0] = 1;\n\trepn(i, n) fac[i] = fac[i-1]*i%MOD;\n\tfinv.resize(n+1);\n\tfinv[n] = PowMod(fac[n], MOD-2);\n\trepr(i, n) finv[i] = finv[i+1]*(i+1)%MOD;\n\tfinv[0] = 1;\n}\n\nll combi(ll n, ll k){\n\tif (n < 0 || k < 0) return 0;\n\treturn fac[n]*finv[k]%MOD*finv[n-k]%MOD;\n}\n\ntemplate <int mod>\nstruct ModInt {\n\tint x;\n\n\tModInt() : x(0) {}\n\n\tModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n\tModInt &operator+=(const ModInt &p) {\n\t\tif((x += p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\n\tModInt &operator-=(const ModInt &p) {\n\t\tif((x += mod - p.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\n\tModInt &operator*=(const ModInt &p) {\n\t\tx = (int) (1LL * x * p.x % mod);\n\t\treturn *this;\n\t}\n\n\tModInt &operator/=(const ModInt &p) {\n\t\t*this *= p.inverse();\n\t\treturn *this;\n\t}\n\n\tModInt operator-() const { return ModInt(-x); }\n\n\tModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n\tModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n\tModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n\tModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n\tbool operator==(const ModInt &p) const { return x == p.x; }\n\n\tbool operator!=(const ModInt &p) const { return x != p.x; }\n\n\tModInt inverse() const {\n\t\tint a = x, b = mod, u = 1, v = 0, t;\n\t\twhile(b > 0) {\n\t\t\tt = a / b;\n\t\t\tswap(a -= t * b, b);\n\t\t\tswap(u -= t * v, v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\n\tModInt pow(int64_t n) const {\n\t\tModInt res(1), mul(x);\n\t\twhile(n > 0) {\n\t\t\tif(n & 1) res *= mul;\n\t\t\tmul *= mul;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tfriend ostream &operator<<(ostream &os, const ModInt &p) {\n\t\treturn os << p.x;\n\t}\n\n\tfriend istream &operator>>(istream &is, ModInt &a) {\n\t\tint64_t t;\n\t\tis >> t;\n\t\ta = ModInt< mod >(t);\n\t\treturn (is);\n\t}\n\n\tstatic int get_mod() { return mod; }\n};\nusing Mint = ModInt<MOD>;\n\nint main(void){\n\tinit();\n\tll n, m;\n\tcin >> n >> m;\n\n\tMint ans = 0;\n\trep(i, min(n + 1, m + 1)){\n\t\tll rest = 3 * m - i;\n\t\tif (rest & 1) continue;\n\t\trest /= 2;\n\n\t\tans += combi(n, i) * combi(rest + n - 1, rest);\n\t\tans -= combi(n, i) * i % MOD * combi(rest - m + n - 1, rest - m);\n\t\tans -= combi(n, i) * (n - i) % MOD * combi(rest - m - 1 + n - 1, rest - m - 1);\n\t\t// ce(ans);\n\t}\n\tco(ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst int INF = (1<<30);\nconst ll INFLL = (1ll<<60);\nconst ll MOD = 998244353ll;\n\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\ta = (a<MOD)?a:(a-MOD);\n\tb = (b<MOD)?b:(b-MOD);\n\ta += b;\n\ta = (a<MOD)?a:(a-MOD);\n}\n\nll fc[3003003]={1ll},nv[3003003]={1ll};\n\nll rwpw(ll a, ll p){\n\tll ret = 1ll;\n\twhile(p){\n\t\tif(p&1){\n\t\t\tmul_mod(ret,a);\n\t\t}\n\t\tmul_mod(a,a);\n\t\tp >>= 1;\n\t}\n\treturn ret;\n}\n\nll c(int n, int k){\n\tll ret;\n\tif(n<k){\n\t\treturn 0ll;\n\t}\n\tret = fc[n];\n\tmul_mod(ret,nv[k]);\n\tmul_mod(ret,nv[n-k]);\n\treturn ret;\n}\n\nint main(void){\n\tint n,m,i,j,k,p;\n\tll ans,tmp;\n\tfor(i=1; i<3003003; ++i){\n\t\tfc[i] = fc[i-1];\n\t\tmul_mod(fc[i],i);\n\t\tnv[i] = rwpw(fc[i],MOD-2);\n\t}\n\tcin >> n >> m;\n\tfor(i=0; i<=m; ++i){\n\t\tif((m*3-i)%2){\n\t\t\tcontinue;\n\t\t}\n\t\tp = (m*3-i)/2;\n\t\ttmp = c(n,i);\n\t\tmul_mod(tmp,c(p+n-1,n-1));\n\t\tadd_mod(ans,tmp);\n\t\t// 1個がm*2+1以上\n\t\tif(i){\n\t\t\tp = (m-i)/2;\n\t\t\ttmp = c(p+n-1,n-1);\n\t\t\tmul_mod(tmp,c(n,i));\n\t\t\tmul_mod(tmp,c(i,1));\n\t\t\tadd_mod(ans,MOD-tmp);\n\t\t}\n\t\t// 1個がm*2+2以上\n\t\tif(i<m){\n\t\t\tp = (m-i-2)/2;\n\t\t\ttmp = c(p+n-1,n-1);\n\t\t\tmul_mod(tmp,c(n,i));\n\t\t\tmul_mod(tmp,c(n-i,1));\n\t\t\tadd_mod(ans,MOD-tmp);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\nusing namespace std;\n#define endl '\\n'\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\nusing ll = int64_t;\nusing ull = uint64_t;\nusing PLL = pair<ll, ll>;\n\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return max(low, min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { t = clamp(t, low, high); }\n\nnamespace init__ {\n\nstruct InitIO {\n    InitIO() {\n        cin.tie(nullptr);\n        ios_base::sync_with_stdio(false);\n        cout << fixed << setprecision(30);\n    }\n} init_io;\n\n}\n\n#ifdef DEBUGGING\n// #include \"../debug/debug.cpp\"\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\ntemplate <typename T>\nT make_v(T init) { return init; }\n\ntemplate <typename T, typename... Tail>\nauto make_v(T init, size_t s, Tail... tail) {\n#define rec make_v(init, tail...)\n    return V<decltype(rec)>(s, rec);\n#undef rec\n}\n\ntemplate <ll MOD>\nclass Combination {\nprivate:\n    template <typename T> using V = vector<ll>;\n    ll N;\n    V<ll> factv, rfactv;\n\npublic:\n    /*\n     * MOD must be a prime number.\n     */\n    Combination<MOD> (ll N)\n        : N(N), \n          factv(N + 1, 1),\n          rfactv(N + 1)\n    {\n        for(ll i = 1; i <= N; i++) {\n            factv[i] = factv[i - 1] * i % MOD;\n        }\n        for(ll i = 0; i <= N; i++) {\n            rfactv[i] = pow(factv[i], MOD - 2);\n        }\n    }\n\n    ll fact(ll n) {\n        return factv[n];\n    }\n\n    ll rfact(ll n) {\n        return rfactv[n];\n    }\n\n    ll pow(ll a, ll b) {\n        return b ? (b & 1 ? a : 1) * pow(a * a % MOD, b / 2) % MOD : 1;\n    }\n\n    ll comb(ll n, ll k) {\n        return factv[n] * rfactv[n - k] % MOD * rfactv[k] % MOD;\n    }\n};\n\nconst ll mod = 998244353;\nCombination<mod> comb(5e6);\n\nint main() {\n    ll N, M;\n    cin >> N >> M;\n\n    /*\n    V<ll> comb_list(3 * M + 10);\n    for(ll i = 2 * N - 1; i < comb_list.size(); i++) comb_list[i] = comb.comb(i, 2 * N - 1);\n\n    V<ll> odd_sum(comb_list.size() + 1), even_sum(comb_list.size() + 1);\n    for(ll i = 2 * N - 1; i < comb_list.size(); i++) {\n        odd_sum[i + 1] = odd_sum[i];\n        even_sum[i + 1] = even_sum[i];\n        ((i & 1 ? odd_sum : even_sum)[i + 1] += comb_list[i]) %= mod;\n    }\n    */\n\n    ll ans = 0;\n    ll lines = N - 1;\n    for(ll k = (M & 1); k <= min(M, N); k += 2) {\n        ll select = comb.comb(N, k);\n        ll rest = M * 3 - k;\n        rest /= 2;\n        ll distr = comb.comb(rest + lines, lines);\n        ll perm = distr * select % mod;\n        DEBUG(perm);\n        (ans += perm) %= mod;\n    }\n\n    for(ll i = M + 1; i <= 2 * M; i++) {\n        ll rest = 2 * M - i;\n        ll distr = comb.comb(rest + lines - 1, lines - 1);\n        ll perm = distr * N % mod;\n        (ans += mod - perm) %= mod;\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nll modpower(ll a, ll r, ll mod){ //a^r\n    ll x = 1;\n    a %= mod;\n    while (r > 0) {\n        if (r & 1) x = x * a % mod;\n        r >>= 1;\n        a = a * a % mod;\n    }\n    return x;\n}\n\nll modinv(ll a, ll mod){\n    return modpower(a, mod-2, mod);\n}\n\nvector<ll> fact;\nvector<ll> invfact;\n\nvoid set_fact(ll n, ll mod){\n    fact.resize(n+1, 1);\n    invfact.resize(n+1, 1);\n    for (ll i = 2; i <= n; i++) {\n        fact[i] = fact[i-1] * i % mod;\n    }\n    invfact[n] = modinv(fact[n], mod);\n    for (ll i = n-1; i >= 2; i--) {\n        invfact[i] = invfact[i+1] * (i+1) % mod;\n    }\n    return;\n}\n\nll comb(ll n, ll k, ll mod) {\n    if (k > n || k < 0) return 0;\n    if (k == n || k == 0) return 1;\n    return fact[n] * invfact[n-k] % mod * invfact[k] % mod;\n}\n\nll comb_rep(ll n, ll k, ll mod) {\n    return comb(n+k-1, k, mod);\n}\n\n\nint main() {\n    ll N, M;\n    cin >> N >> M;\n    ll mod = 998244353;\n    set_fact(5000010, mod);\n    \n    ll ans = comb_rep(N, 3*M, mod);\n    \n    for (ll i = 2*M+1; i <= 3*M; i++) {\n        ll ex = N*comb_rep(N-1, M*3-i, mod) % mod;\n        ans += mod - ex;\n    }\n    \n    for (ll i = M+1; i <= N; i++) {\n        if ((3*M-i)%2 == 1) continue;\n        if (i > M*3) break;\n        ll ex = comb(N, i, mod) * comb_rep(N, (3*M-i)/2, mod) % mod;\n        ans += mod - ex;\n    }\n    cout << ans%mod << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing i64 = long long;\n\nlong long *fact, *inv;\n\ntemplate <typename T, typename U, typename V>\nauto pow(T x_, U n_, V mod_) {\n    using R = std::common_type_t<T, U, V>;\n    R ret = 1, x = x_, n = n_, mod = mod_;\n    while(n > 0) {\n        if ((n & 1) == 1) ret = (ret * x) % mod;\n        x = (x * x) % mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\ntemplate <typename T, typename U>\nauto inverse(T x, U p) { return pow(x, p - 2, p); }\n\nvoid init_factorial(int n, long long mod) {\n    fact = new long long[n + 1];\n    inv = new long long[n + 1];\n    fact[0] = 1;\n    for (long long i = 1; i <= n; i++) fact[i] = fact[i - 1] * i % mod;\n    inv[n] = inverse(fact[n], mod);\n    for (long long i = n; i > 0; i--) inv[i - 1] = inv[i] * i % mod;\n}\n\nint main() {\n    constexpr i64 mod = 998244353;\n    int n, m;\n    std::cin >> n >> m;\n    init_factorial(n + 3 * m, mod);\n\n    i64 ret = 0;\n    for (int i = 0; i <= std::min(n, m); i++) {\n        int r = 3 * m - i;\n        if (r & 1) continue;\n        r >>= 1;\n        i64 t = fact[r + n - 1] * inv[n - 1] % mod * inv[r] % mod;\n        ret = (ret + t * fact[n] % mod * inv[i] % mod * inv[n - i] % mod) % mod;\n    }\n\n    for (int i = 0; i <= std::min(n, m); i++) {\n        int r = m - i;\n        if (r & 1) continue;\n        r >>= 1;\n        i64 t = fact[r + n - 1] * inv[n - 1] % mod * inv[r] % mod;\n        ret = (ret + mod - t * fact[n] % mod * inv[i] % mod * inv[n - i] % mod * n % mod) % mod;\n    }\n\n    for (int i = 0; i <= std::min(n - 1, m); i++) {\n        int r = m - i;\n        if (r & 1) continue;\n        r >>= 1;\n        i64 t = fact[r + n - 2] * inv[n - 2] % mod * inv[r] % mod;\n        ret = (ret + t * fact[n - 1] % mod * inv[i] % mod * inv[n - i - 1] % mod * n % mod) % mod;\n    }\n\n    std::cout << ret << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=998244353;\nll pow(ll x,ll y){\n  if(y==0) return 1;\n  ll res=pow(x,y/2);\n  res*=res;\n  res%=mod;\n  if(y%2==1) res*=x;\n  return res%mod;\n}\nll gyaku(ll x){\n  return pow(x,mod-2);\n}\nvector<ll> frac,gfrac;\nvoid set_frac(ll n){\n  frac.push_back(1);\n  gfrac.push_back(1);\n  for(ll i=1;i<=n;i++){\n    frac.push_back(frac[i-1]*i%mod);\n    gfrac.push_back(gyaku(frac[i]));\n  }\n}\nll nCr(ll n,ll r){\n  ll res=frac[n]*gfrac[r]%mod;\n  res*=gfrac[n-r];\n  return res%mod;\n}\n\n\n\nint main(){\n  ll n,m;\n  cin>>n>>m;\n  ll ans=0;\n  set_frac(5*max(n,m)+30);\n\n  vector<ll> vec,rsum;\n  for(ll i=0;i<3*m+100;i++) vec.push_back(nCr(n+i-2,n-2));\n  rsum.push_back(vec[0]);\n  for(ll i=1;i<3*m+100;i++) rsum.push_back((rsum[i-1]+vec[i])%mod);\n  for(ll t=0;t<=min(n,m);t++){\n    ll kans1=0,kans2=0;\n    if((m-t)%2==0){\n      if(t<n){\n        kans1=(nCr(((m-t)/2)+n-2,n-2)*n)%mod;\n        kans1*=nCr(n-1,t);\n        kans1%=mod;\n      }\n\n      kans2+=nCr(((3*m-t)/2)+n-1,n-1);\n      kans2%=mod;\n\n      kans2-=(n*rsum[((3*m-t)/2)-m])%mod;\n      kans2+=mod;\n      kans2%=mod;\n\n      kans2*=nCr(n,t);\n      kans2%=mod;\n    }\n    ans+=(kans1+kans2)%mod;\n    ans%=mod;\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <vector>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n//#define cerr if(false) cerr\n#ifdef DEBUG\n#define show(...) cerr << #__VA_ARGS__ << \" = \", debug(__VA_ARGS__);\n#else\n#define show(...) 42\n#endif\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> a) {\n    os << '(' << a.first << ',' << a.second << ')';\n    return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, vector<T> v) {\n    for (auto x : v) os << x << ' ';\n    return os;\n}\nvoid debug() {\n    cerr << '\\n';\n}\ntemplate <typename H, typename... T>\nvoid debug(H a, T... b) {\n    cerr << a;\n    if (sizeof...(b)) cerr << \", \";\n    debug(b...);\n}\ntemplate<int MOD>\nclass Modint{\npublic:\n    int a;\n    Modint(const long long v = 0):a(v % MOD){}\n    constexpr int getmod() const{\n        return MOD;\n    }\n    Modint operator+(const Modint rhs) const{\n        return Modint(*this) += rhs;\n    }\n    Modint operator-(const Modint rhs) const{\n        return Modint(*this) -= rhs;\n    }\n    Modint operator*(const Modint rhs) const{\n        return Modint(*this) *= rhs;\n    }\n    Modint operator/(const Modint rhs) const{\n        return Modint(*this) /= rhs;\n    }\n    Modint operator+(const long long rhs) const{\n        return Modint(*this) += rhs;\n    }\n    Modint operator-(const long long rhs) const{\n        return Modint(*this) -= rhs;\n    }\n    Modint operator*(const long long rhs) const{\n        return Modint(*this) *= rhs;\n    }\n    Modint operator/(const long long rhs) const{\n        return Modint(*this) /= rhs;\n    }\n    friend Modint operator+(const long long a, const Modint b){\n        return b + a;\n    }\n    friend Modint operator-(const long long a, const Modint b){\n        return -b + a;\n    }\n    friend Modint operator*(const long long a, const Modint b){\n        return b * a;\n    }\n    friend Modint operator/(const long long a, const Modint b){\n        return Modint(a) / b;\n    }\n    Modint &operator+=(const Modint rhs){\n        a += rhs.a;\n        if(a >= MOD){\n            a -= MOD;\n        }\n        return *this;\n    }\n    Modint &operator-=(const Modint rhs){\n        if(a < rhs.a){\n            a += MOD;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n    Modint &operator*=(const Modint rhs){\n        a = (long long)a * rhs.a % MOD;\n        return *this;\n    }\n    Modint &operator/=(Modint rhs){\n        int x = MOD - 2;\n        while(x){\n            if(x % 2){\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            x /= 2;\n        }\n        return *this;\n    }\n    Modint &operator++(){\n        *this += 1;\n        return *this;\n    }\n    Modint &operator--(){\n        *this -= 1;\n        return *this;\n    }\n    Modint operator++(int){\n        Modint res = *this;\n        ++(*this);\n        return res;\n    }\n    Modint operator--(int){\n        Modint res = *this;\n        res -= 1;\n        return res;\n    }\n    Modint &operator+=(const long long rhs){\n        *this += Modint(rhs);\n        return *this;\n    }\n    Modint &operator-=(const long long rhs){\n        *this -= Modint(rhs);\n        return *this;\n    }\n    Modint &operator*=(const long long rhs){\n        *this *= Modint(rhs);\n        return *this;\n    }\n    Modint &operator/=(const long long rhs){\n        *this /= Modint(rhs);\n        return *this;\n    }\n    Modint operator+() const{\n        return *this;\n    }\n    Modint operator-() const{\n        return Modint()-*this;\n    }\n    bool operator==(const Modint rhs) const{\n        return a == rhs.a;\n    }\n    bool operator==(const long long rhs) const{\n        return a == rhs;\n    }\n    friend bool operator==(const long long a, const Modint b){\n        return a == b.a;\n    }\n    bool operator!=(const Modint rhs) const{\n        return a != rhs.a;\n    }\n    bool operator!=(const long long rhs) const{\n        return a != rhs;\n    }\n    friend ostream &operator<<(ostream &os, const Modint x){\n        os << x.a;\n        return os;\n    }\n    friend istream &operator>>(istream &is, Modint &x){\n        is >> x.a;\n        return is;\n    }\n    explicit operator bool() const{\n        return a > 0;\n    }\n    bool operator!(){\n        return a == 0;\n    }\n    explicit operator int() const{\n        return a;\n    }\n    explicit operator long long() const{\n        return (long long) a;\n    }\n    friend Modint pow(Modint a, long long b){\n        Modint res = 1;\n        while(b){\n            if(b % 2){\n                res *= a;\n            }\n            a *= a;\n            b /= 2;\n        }\n        return res;\n    }\n};\nusing mint = Modint<998244353>;\nconst int NUM = 3000000;\nmint fact[NUM + 1], fact_inv[NUM + 1], inv[NUM + 1];\nmint combi(long long N_, long long K_){\n    static constexpr int Mod_ = fact[0].getmod();\n    if(fact[0] == 0){\n        inv[1] = fact[0] = fact_inv[0] = 1;\n        for(int i = 2; i <= NUM; i++){\n            inv[i] = inv[Mod_ % i] * (Mod_ - Mod_ / i);\n        }\n        for(int i = 1; i <= NUM; i++){\n            fact[i] = fact[i - 1] * i;\n            fact_inv[i] = fact_inv[i - 1] * inv[i];\n        }\n    }\n    if(K_ < 0 or K_ > N_) return 0;\n    return fact_inv[K_] * fact[N_] * fact_inv[N_ - K_];\n}\nmint hcomb(long long N_, long long K_){\n    return ((N_ | K_) == 0) ? 1 : combi(N_ + K_ - 1, K_);\n}\nint main(){\n    int n, m;\n    cin >> n >> m;\n    mint ans = 0;\n    for(int i = m % 2; i <= min(n, m); i += 2){\n        ans += combi(n, i) * hcomb(n, (3 * m - i) / 2);\n    }\n    cout << ans - n * hcomb(n, m - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\n\n#define MAX_N 3000010\nlong long inv[MAX_N];\nlong long factorial[MAX_N];\nlong long inv_factorial[MAX_N];\n\nvoid GetInv(){\n    for (int i = 1; i < MAX_N; i++) {\n        if (i == 1) inv[i] = 1;\n        else {\n            inv[i] = (mod - (mod / i) * inv[mod % i]) % mod;\n            if (inv[i] < 0) inv[i] += mod;\n        }\n    }\n}\nvoid GetFactorial(){\n    factorial[0] = 1; inv_factorial[0] = 1;\n    for (int i = 1; i < MAX_N; i++) {\n        factorial[i] = factorial[i-1] * i;\n        factorial[i] %= mod;\n        inv_factorial[i] = inv_factorial[i-1] * inv[i];\n        inv_factorial[i] %= mod;\n    }\n}\n\nlong long combination(int n, int r) {\n    long long ret = factorial[n] * inv_factorial[r];\n    ret %= mod;\n    ret *= inv_factorial[n-r];\n    return ret % mod;\n}\n\nlong long modpow(int n, int r) {\n    long long ret = 1; long long tmp = (long long) n;\n    while (r != 0) {\n        if (r % 2) ret *= tmp;\n        tmp *= tmp; tmp %= mod; ret %= mod;\n        r /= 2;\n    }\n    return ret;\n}\n\nint main() {\n    int n, m; cin >> n >> m;\n    GetInv(); GetFactorial();\n    long long all = combination(3*m+n-1, n-1);\n    long long sub = 0;\n    for (int k = m+1; k <= n; k++) {\n        if (k > n) break;\n        int remain = 3*m - k;\n        if (remain % 2 != 0) continue;\n        long long tmp = combination(n, k);\n        tmp = tmp * combination(remain/2 + n-1, n-1) % mod;\n        sub = (sub + tmp) % mod;\n    }\n    long long sub2 = 0;\n    for (int k = 2 * m+1; k <= 3*m; k++) {\n        int remain = 3*m - k;\n        long long tmp = combination(remain+n-2, n-2) * n % mod;\n        sub2 = (sub2 + tmp) % mod;\n    }\n    cout << (all + mod * 2 - sub - sub2) % mod << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//08:36~\n#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <uint32_t mod>\nclass modint{\n    uint64_t value;\npublic:\n    constexpr modint(const int64_t x=0) noexcept: value(x % mod + (x < 0 ? mod : 0)){ }\n    constexpr explicit operator uint64_t() const noexcept{ return value; }\n    constexpr modint inverse() const noexcept{ return pow(*this, mod-2); }\n    constexpr bool operator==(const modint &rhs) const noexcept{ return value == rhs.value; }\n    constexpr bool operator!=(const modint &rhs) const noexcept{ return value != rhs.value; }\n    constexpr modint operator+() const noexcept{ return modint(*this); }\n    constexpr modint operator-() const noexcept{ return modint(mod - value); }\n    constexpr modint operator+(const modint &rhs) const noexcept{ return modint(*this) += rhs; }\n    constexpr modint operator-(const modint &rhs) const noexcept{ return modint(*this) -= rhs; }\n    constexpr modint operator*(const modint &rhs) const noexcept{ return modint(*this) *= rhs; }\n    constexpr modint operator/(const modint &rhs) const noexcept{ return modint(*this) /= rhs; }\n    constexpr modint &operator+=(const modint &rhs) noexcept{\n        if((value += rhs.value) >= mod) value -= mod;\n        return *this;\n    }\n    constexpr modint &operator-=(const modint &rhs) noexcept{ return *this += mod - rhs.value; }\n    constexpr modint &operator*=(const modint &rhs) noexcept{\n        if((value *= rhs.value) >= mod) value %= mod;\n        return *this;\n    }\n    constexpr modint &operator/=(const modint &rhs) noexcept{ return *this *= rhs.inverse(); }\n    constexpr modint operator++(int) noexcept{\n        modint ret(*this);\n        if((++value) >= mod) value -= mod;\n        return ret;\n    }\n    constexpr modint operator--(int) noexcept{\n        modint ret(*this);\n        if((value += mod - 1) >= mod) value -= mod;\n        return ret;\n    }\n    constexpr modint &operator++() noexcept{ return *this += 1; }\n    constexpr modint &operator--() noexcept{ return *this -= 1; }\n    friend std::ostream &operator<<(std::ostream &os, const modint<mod> &x){ return os << x.value; }\n    friend std::istream &operator>>(std::istream &is, modint<mod> &x){\n        int64_t i;\n        is >> i;\n        x = modint<mod>(i);\n        return is;\n    }\n    friend constexpr modint<mod> pow(const modint<mod> &x, uint64_t y){\n        modint<mod> ret{1}, m{x};\n        while(y > 0){\n            if(y & 1) ret *= m;\n            m *= m;\n            y >>= 1;\n        }\n        return ret;\n    }\n};\nconstexpr int64_t mod = 998244353;\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    constexpr int fmax = 3000000;\n    static modint<mod> fact[fmax+1], finv[fmax+1];\n    fact[0] = 1;\n    for(int i=0;i<fmax;++i) fact[i+1] = fact[i] * (i+1);\n    finv[fmax] = fact[fmax].inverse();\n    for(int i=fmax;i>0;--i) finv[i-1] = finv[i] * i;\n    auto comb = [&](int n, int r){ return fact[n] * finv[r] * finv[n-r]; };\n\n    int n, m;\n    cin >> n >> m;\n    modint<mod> ans = comb(3*m + n-1, n-1);\n    for(int o=m+1;o<=n;++o){\n        if(3*m < o) break;\n        if((3*m-o) % 2 != 0) continue;\n        ans -= comb(n, o) * comb((3*m-o)/2 + n-1, n-1);\n    }\n    for(int x=2*m+1;x<=3*m;++x){\n        ans -= modint<mod>{n} * comb(3*m-x + n-2, n-2);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define fi first\n#define se second\ntypedef pair<ll,ll> P;\n#define Mod 998244353\nusing VP = vector<P>; using VVP = vector<VP>;\nusing VI = vector<ll>; using VVI = vector<VI>; using VVVI = vector<VVI>;\n#define INF 1ll<<59\n\n\nvector<ll> bi(5010101);\n\n\nll modinv(ll a) {\n    ll m=Mod;\n    ll b = m, u = 1, v = 0;\n    while (b) {\n        ll t = a / b;\n        a -= t * b; swap(a, b);\n        u -= t * v; swap(u, v);\n    }\n    u %= m;\n    if (u < 0) u += m;\n    return u;\n}\n\nll comb(ll s,ll t){\n    ll q=bi[s]*modinv(bi[t]);\n    q%=Mod;\n    q*=modinv(bi[s-t]);\n    q%=Mod;\n    return q;\n}\n\nint main(){\n    ll i,j;\n    ll n,m;\n    cin>>n>>m;\n\n    bi[0]=1;\n\n    for(i=1;i<5010101;i++){\n        bi[i]=bi[i-1]*i;\n        bi[i]%=Mod;\n    }\n\n    ll ans1=comb(3*m+n-1,n-1);\n    ll ans2=n*comb(m+n-2,n-1);\n\n    ans2%=Mod;\n    \n    ll hoge=(ans1-ans2+Mod)%Mod;\n\n    if(n<=m) cout<<hoge<<endl;\n    else{\n        ll l;\n        ll ans3=0;\n        for(l=m+1;l<=min(3*m,n);l++){\n            if((3*m-l)%2==0) {\n                ans3+=comb(n,l)*comb((3*m-l)/2+n-1,n-1);\n                ans3%=Mod;\n            }\n        }\n\n         cout<<(hoge+Mod-ans3)%Mod<<endl;\n    }\n\n\n\n\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Author: Vamsi Krishna Reddy Satti\n// With love for Competitive Programming!\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define fast_io ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n#define cout_precision cout.setf(ios::fixed); cout.precision(32);\n\nusing ll = int64_t; using vll = vector<ll>; using vvll = vector<vll>;\nusing pll = pair<ll, ll>; using vpll = vector<pll>; using vvpll = vector<vpll>;\n\n// ------------------------------------------------------------------------------------------------\n\nconst ll MOD = 998244353, N_MAX = 2e6;\n\nll n, m;\nvll fac, inv_fac;\n\nll bin_exp(ll b, ll e, ll mod = MOD) {\n    ll ret = 1;\n    while (e > 0) {\n        if (e & 1) {\n            (ret *= b) %= MOD;\n        }\n        (b *= b) %= MOD;\n        e >>= 1;\n    }\n    return ret;\n}\n\nvoid init() {\n    fac.resize(N_MAX);\n    fac[0] = 1;\n    for (ll i = 1; i <= N_MAX; i++) {\n        fac[i] = fac[i - 1] * i % MOD;\n    }\n    inv_fac.resize(N_MAX);\n    inv_fac[N_MAX] = bin_exp(fac[N_MAX], MOD - 2);\n    for (ll i = N_MAX; i >= 1; i--) {\n        inv_fac[i - 1] = inv_fac[i] * i % MOD;\n    }\n}\n\nll nCr(ll n, ll r) {\n    if (r > n) {\n        return 0;\n    }\n    return fac[n] * inv_fac[n - r] % MOD * inv_fac[r] % MOD;\n}\n\nvoid func() {\n    cin >> n >> m;\n    ll ans = 0;\n    for (ll i = m; i >= 0; i -= 2) {\n        (ans += (nCr(n, i) * nCr((3 * m - i) / 2 + n - 1, n - 1)) % MOD) %= MOD;\n    }\n    ll rem = 0;\n    for (ll i = 2 * m + 1; i <= 3 * m; i++) {\n        (rem += nCr(3 * m - i + n - 2, n - 2)) %= MOD;\n    }\n    (rem *= n) %= MOD;\n    (ans += MOD - rem) %= MOD;\n    cout << ans << endl;\n}\n\nint main() {\n    fast_io; cout_precision;\n    init();\n    ll t = 1; // cin >> t;\n    for (ll i = 1; i <= t; i++) {\n        func();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vpii;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n#define INF 1000000000\n#define MOD 998244353\n#define EPSILON 0.00001\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n\n#define FOR(i, a, b) for (int i=(a); i<=(signed)(b); i++)\n#define F0R(i, a) for (int i=0; i<(signed)(a); i++)\n#define RFOR(i, a, b) for (int i=(a); i >= b; i--)\n\n#define MN 2500005\n\nll fac[MN];\n\npll gcd(ll a, ll b){ //a*first+b*second=gcd\n    if(a == 0){\n        return mp(0, 1);\n    }\n\n    pll prev = gcd(b%a, a);\n\n    return mp(prev.s-(b/a)*prev.f, prev.f);\n} //using ll's just to be safe wrt overflow issues\n\nll modInv(ll x){ //return x^-1 % MOD\n    pll res = gcd(x, MOD);\n\n    res.f = (res.f+MOD)%MOD;\n\n    //cout << \"modinv of \" << x << \" is \" << res.f << \"\\n\";\n\n    return res.f;\n}\n\nll modDiv(ll x, ll y){\n    return (x*modInv(y))%MOD;\n}\n\nll getFacs(){\n    fac[0] = 1;\n    FOR(i, 1, MN-1){\n        fac[i] = (fac[i-1]*i)%MOD;\n    }\n}\n\nll choose(ll a, ll b){\n    ll c = a-b;\n    if(c < 0){\n        cout << \"ur bad\\n\";\n        exit(0);\n    }\n\n    ll num = fac[a];\n    ll denom = (fac[b]*fac[c])%MOD;\n\n    //cout << \"num \" << num << \" denom \" << denom << \"\\n\";\n\n    return modDiv(num, denom);\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    getFacs();\n    ll n, m;\n    cin >> n >> m;\n\n    ll big = choose(3*m+n-1, n-1);\n    ll sm = 0;\n    FOR(i, 2*m+1, 3*m){\n        sm += choose(3*m-i+n-2, n-2);\n        sm %= MOD;\n    }\n    ll bad = (n*sm)%MOD;\n    cout << (big - bad+MOD)%MOD;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst long long infll = (long long) 1.01e18;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\n#ifdef DEBUG\nmt19937 mrand(300); \n#else\nmt19937 mrand(chrono::steady_clock::now().time_since_epoch().count()); \n#endif\n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nconst int mod = 998244353;\n\nint mul(int a, int b) {\n  return (long long) a * b % mod;\n}\n\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= mod) {\n    a -= mod;\n  }\n}\n\nconst int maxn = (int) 4e6 + 5;\nint f[maxn], inv[maxn], finv[maxn];\n\nvoid precalc() {\n  f[0] = 1;\n  for (int i = 1; i < maxn; i++) {\n    f[i] = mul(f[i - 1], i);\n  }\n  inv[1] = 1;\n  for (int i = 2; i < maxn; i++) {\n    inv[i] = (mod - (long long) (mod / i) * inv[mod % i] % mod) % mod;\n  }\n  finv[0] = 1;\n  for (int i = 1; i < maxn; i++) {\n    finv[i] = mul(finv[i - 1], inv[i]);\n  }\n}\n\nint c(int n, int k) {\n  if (!k) {\n    return 1;\n  }\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  return mul(f[n], mul(finv[k], finv[n - k]));\n}\n\nint n, m;\n\nbool read() {\n  if (scanf(\"%d%d\", &n, &m) < 2) {\n    return false;\n  }\n  return true;\n}\n\nvoid solve() {\n  int res = c(3 * m + n - 1, 3 * m);\n  {\n    int big = mul(n, c(m - 1 + n - 1, m - 1));\n    add(res, mod - big);\n  }\n  {\n    int odd = 0;\n    for (int i = m + 1; i <= n && i <= 3 * m; i++) {\n      int rem = 3 * m - i;\n      if (rem & 1) {\n        continue;\n      }\n      rem /= 2;\n      int cur = c(n, i);\n      cur = mul(cur, c(rem + n - 1, rem));\n      add(odd, cur);\n    }\n    add(res, mod - odd);\n  }\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (read()) {\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#define dump(...) cerr << \"[\" << setw(3) << __LINE__ << \":\" << __FUNCTION__ << \"] \", dump_impl(#__VA_ARGS__, __VA_ARGS__)\n#define say(x) cerr << \"[\" << __LINE__ << \":\" << __FUNCTION__ << \"] \" << x << endl\n#define debug if (1)\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class F> int ppt(C const& v, F f) {\n    return partition_point(v.begin(), v.end(), f)-v.begin();\n}\n// <<<\n// >>> modint\ntemplate <int32_t md>\nclass modint {\n    static_assert(md > 0, \"\");\n    using M = modint;\n    using ll = int64_t;\n    int32_t x;\npublic:\n    static constexpr int32_t mod = md;\n    constexpr modint(ll x = 0) : x((x%=mod) < 0 ? x+mod : x) { }\n    constexpr ll val() const { return x; }\n    constexpr explicit operator ll() const { return x; }\n    constexpr bool operator==(M const& r) const { return x == r.x; }\n    constexpr bool operator!=(M const& r) const { return x != r.x; }\n    constexpr M operator+() const { return *this; }\n    constexpr M operator-() const { return M()-*this; }\n    constexpr M& operator+=(M const& r) { ll t = ll(x) + r.x; if (t >= mod) t -= mod; x = t; return *this; }\n    constexpr M& operator-=(M const& r) { ll t = ll(x) + mod-r.x; if (t >= mod) t -= mod; x = t; return *this; }\n    constexpr M& operator*=(M const& r) { return *this = *this * r; }\n    constexpr M operator*(M const& r) const { M t; t.x = (ll(x)*r.x) % mod; return t; }\n    constexpr M& operator/=(M const& r) { return *this *= r.inv(); }\n    constexpr M operator+(M const& r) const { return M(*this) += r; }\n    constexpr M operator-(M const& r) const { return M(*this) -= r; }\n    constexpr M operator/(M const& r) const { return M(*this) /= r; }\n    friend constexpr M operator+(ll x, M const& y) { return M(x)+y; }\n    friend constexpr M operator-(ll x, M const& y) { return M(x)-y; }\n    friend constexpr M operator*(ll x, M const& y) { return M(x)*y; }\n    friend constexpr M operator/(ll x, M const& y) { return M(x)/y; }\n    constexpr M pow(ll n) const {\n        if (n < 0) return inv().pow(-n);\n        M v = *this, r = 1;\n        for (; n > 0; n >>= 1, v *= v) if (n&1) r *= v;\n        return r;\n    }\n    constexpr M inv() const {\n        assert(x > 0);\n        ll t = 1, v = x, q = 0, r = 0;\n        while (v != 1) {\n            q = mod / v; r = mod % v;\n            if (r * 2 < v) {\n                t *= -q; t %= mod; v = r;\n            } else {\n                t *= q + 1; t %= mod; v -= r;\n            }\n        }\n        if (t < 0) t += mod;\n        M y; y.x = t; return y;\n    }\n#ifdef LOCAL\n    friend string to_s(M r) { return to_s(r.val(), mod); }\n#endif\n    friend ostream& operator<<(ostream& os, M r) { return os << r.val(); }\n    friend istream& operator>>(istream& is, M &r) { int64_t x; is >> x; r = x; return is; }\n};\n// <<<\nconstexpr int64_t MOD = 998244353;\n//constexpr int64_t MOD = 1e9+7;\nusing mint = modint<(int32_t)MOD>;\n\n// >>> mod table\ntemplate <int32_t mod>\nstruct ModTable {\n    static constexpr int32_t Size = 2e6 + 10;\n    static_assert(Size <= mod, \"\");\n    using ll = int64_t;\n    int32_t fact[Size], finv[Size], inv[Size];\n    ModTable() {\n        fact[0] = fact[1] = finv[0] = finv[1] = inv[1] = 1;\n        for (int i = 2; i < Size; i++) {\n            fact[i] = ll(fact[i-1])*i % mod;\n            inv[i] = mod - ll(inv[mod%i])*(mod/i) % mod;\n            finv[i] = ll(finv[i-1])*inv[i] % mod;\n        }\n    }\n};\nconst ModTable<MOD> mod_tab;\n\nmodint<MOD> fact(int n) {\n    assert(0 <= n); assert(n < ModTable<MOD>::Size);\n    return mod_tab.fact[n];\n}\nmodint<MOD> finv(int n) {\n    assert(0 <= n); assert(n < ModTable<MOD>::Size);\n    return mod_tab.finv[n];\n}\nmodint<MOD> P(int n, int k) {\n    assert(k >= 0);\n    return fact(n)*finv(n-k);\n}\nmodint<MOD> C(int n, int k) {\n    if (n < 0 || k < 0 || n < k) return 0;\n    return fact(n)*finv(k)*finv(n-k);\n}\n// <<<\n\nint32_t main() {\n    int n,m; cin >> n >> m;\n\n    mint ans = 0;\n    ans += n*C(n+m-2,m);\n    dump(n*C(n+m-2,m));\n\n    vector<mint> a(3*m/2+1);\n    rep (i,sz(a)) a[i] = C(n+i-1,i);\n    repR (i,sz(a)-m) a[i+m] += -n*a[i];\n    dump(a);\n\n    rep (k,m+1) if ((3*m-k)%2 == 0) {\n        ans += a[(3*m-k)/2]*C(n,k);\n    }\n\n    cout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int SIZE = 1 << 17;\nint pointer = SIZE;\nchar buffer[SIZE];\n\nchar Advance() {\n    if (pointer == SIZE) {\n        fread(buffer, 1, SIZE, stdin);\n        pointer = 0;\n    }\n    return buffer[pointer++];\n}\n\nint Read() {\n    int answer = 0;\n    char ch = Advance();\n    while (!isdigit(ch))\n        ch = Advance();\n    while (isdigit(ch)) {\n        answer = answer * 10 + ch - '0';\n        ch = Advance();\n    }\n    return answer;\n}\n\nconst int MAXN = 1000000;\nconst int MAXM = 500000;\nconst int MOD = 998244353;\n\nint factorial[1 + MAXN + 3 * MAXM], inverse[1 + MAXN + 3 * MAXM];\n\nvoid Add(int &x, int y) {\n    x += y;\n    if (x >= MOD)\n        x -= MOD;\n}\n\nvoid Subtract(int &x, int y) {\n    x -= y;\n    if (x < 0)\n        x += MOD;\n}\n\nint RaiseToPower(int base, int power) {\n    int answer = 1;\n    while (power) {\n        if (power % 2)\n            answer = (1LL * answer * base) % MOD;\n        base = (1LL * base * base) % MOD;\n        power /= 2;\n    }\n    return answer;\n}\n\nvoid Precompute(int n) {\n    factorial[0] = inverse[0] = 1;\n    for (int i = 1; i <= n; i++)\n        factorial[i] = (1LL * factorial[i - 1] * i) % MOD;\n    inverse[n] = RaiseToPower(factorial[n], MOD - 2);\n    for (int i = n - 1; i >= 1; i--)\n        inverse[i] = (1LL * (i + 1) * inverse[i + 1]) % MOD;\n\n}\n\nint Combinations(int n, int k) {\n    int answer = (1LL * inverse[n - k] * inverse[k]) % MOD;\n    answer = (1LL * answer * factorial[n]) % MOD;\n    return answer;\n}\n\nint main() {\n    //freopen(\"tema.in\", \"r\", stdin);\n    //freopen(\"tema.out\", \"w\", stdout);\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    Precompute(n + 3 * m);\n    int total = 0, bad = 0;\n    for (int i = m % 2; i <= n && i <= m; i += 2)\n        Add(total, (1LL * Combinations(n, i) * Combinations((3 * m - i) / 2 + n - 1, n - 1)) % MOD);\n    for (int i = (m % 2) ^ 1; i + 1 <= n && i + 1 <= m; i += 2)\n        Add(bad, (1LL * Combinations(n - 1, i) * Combinations((m - 1 - i) / 2 + n - 1, n - 1)) % MOD);\n    for (int i = m % 2; i + 1 <= n && i + 2 <= m; i += 2)\n        Add(bad, (1LL * Combinations(n - 1, i) * Combinations((m - 2 - i) / 2 + n - 1, n - 1)) % MOD);\n    bad = (1LL * bad * n) % MOD;\n    Subtract(total, bad);\n    printf(\"%d\\n\", total);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <cstring>\n#include <chrono>\n#include <vector>\n#include <map>\n#include <random>\n#include <set>\n#include <algorithm>\n#include <math.h>\n#include <cstdio>\n#include <stdio.h>\n#include <queue>\n#include <bitset>\n#include <cstdlib>\n#include <deque>\n#include <cassert>\n#include <stack>\nusing namespace std;\n\n#define max3(a, b, c) max(a, max(b, c))\n#define min3(a, b, c) min(a, min(b, c))\n#define mp make_pair\n#define f first\n#define se second\n#define pb push_back\n#define ppb pop_back\n#define ll long long\n#define y1 abcde\n#define ull unsigned long long\n#define cntbit(x) __builtin_popcount(x)\n#define endl '\\n'\n#define uset unordered_set\n#define umap unordered_map\n#define all(x) x.begin(), x.end()\n#define pii pair<int, int>\n#define ld long double\n#define pll pair<long long, long long>\n#define int long long\n\nconst int mod = 998244353;\nconst int inf = 2e9;\nconst int N = 1e6 + 15;\nint n, m, ans, a[N], fact[N];\n\ninline void calc_factorial() {\n    fact[0] = fact[1] = 1;\n    for(int i = 2; i < N; ++i)\n        fact[i] = (fact[i-1] * i) % mod;\n}\n\ninline int binpow(int n, int k) {\n    int res = 1;\n    while(k) {\n        if(k & 1)\n            res = (res * n) % mod;\n        k >>= 1;\n        n = (n * n) % mod;\n    }\n    return res;\n}\n\ninline int multiply(int a, int b) {\n    return (a * b) % mod;\n}\n\ninline int divide(int a, int b) {\n    return multiply(a, binpow(b, mod - 2));\n}\n\ninline int C(int n, int k) {\n    if(k > n || n < 0 || k < 0)\n        return 0;\n    return divide(fact[n], multiply(fact[n - k], fact[k]));\n}\n\ninline void add(int &a, int b) {\n    a += b;\n    if(a >= mod)\n        a -= mod;\n    if(a < 0)\n        a += mod;\n}\n\nmain() {\n    cin >> n >> m;\n    calc_factorial();\n    for(int odd = 0; odd <= min(n, m); ++odd) {\n        if((3 * m - odd) & 1)\n            continue;\n        int even = (3 * m - odd) / 2;\n        add(ans, multiply(C(n, odd), C(even + n - 1, n - 1)));\n    }\n    for(int odd = 0; odd <= min(n, m); ++odd) {\n        if((m - odd) & 1)\n            continue;\n        int even = (m - odd) / 2;\n        add(ans, -multiply(n, multiply(C(n, odd), C(even + n - 1, n - 1))));\n        add(ans, multiply(n, multiply(C(n - 1, odd), C(even + n - 2, n - 2))));\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\n\nint n;\nint m;\n\nconst int mod = 998244353;\nconst int maxn = 2e6 + 5;\n\nint fac[maxn], inv[maxn];\n\nint qpow(int a, int n){\n    int ret = 1;\n    while(n > 0){\n        if(n & 1){\n            ret = 1LL * ret * a % mod;\n        }\n        a = 1LL * a * a % mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\nvoid pre_comb(){\n    fac[0] = 1;\n    for(int i = 1;i < maxn;i++){\n        fac[i] = 1LL * fac[i - 1] * i % mod;\n    }\n    inv[maxn - 1] = qpow(fac[maxn - 1], mod - 2);\n    for(int i = maxn - 2;i >= 0;i--){\n        inv[i] = 1LL * inv[i + 1] * (i + 1) % mod;\n    }\n}\n\nint comb(int n, int m){\n    if(m > n or m < 0) return 0;\n    return 1LL * fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\n\nint solve(int m, int n){\n    int ret = 0;\n    for(int a = 0;a <= n;a++){\n        if((m - a) & 1)\n            continue;\n        ret = (ret + 1LL * comb(n, a) * comb((m - a) / 2 + n - 1, n - 1)) % mod;\n    }\n    return ret;\n}\n\nint main(){\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    pre_comb();\n    cin >> n >> m;\n    int ans = solve(m * 3, n);\n    int tmp = (solve(m, n) - solve(m, n - 1) + mod) % mod;\n    tmp = 1LL * n * tmp % mod;\n    ans = (ans - tmp + mod) % mod;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 3000000, md = 998244353;\n\nlong long inv[MX], f[MX], inv_f[MX];\n\nlong long c(int n, int k) {\n\tif (k == -1) return n == -1 ? 1 : 0;\n\t\n\treturn f[n] * inv_f[n - k] % md * inv_f[k] % md;\n}\n\nint main() {\n\tinv[1] = f[0] = f[1] = inv_f[0] = inv_f[1] = 1;\n\tfor (int i = 2; i < MX; i++) {\n\t\tinv[i] = md - inv[md % i] * (md / i) % md;\n\t\tf[i] = f[i - 1] * i % md;\n\t\tinv_f[i] = inv_f[i - 1] * inv[i] % md;\n\t}\n\t\n\tint n, m;\n\tignore = scanf(\"%d %d\", &n, &m);\n\t\n\tint ans = 0;\n\tfor (int k = m % 2; k <= m; k += 2) {\n\t\tans = (ans + c(n, k) * c((3 * m - k) / 2 + n - 1, n - 1)) % md;\n\t}\n\t\n\tfor (int k = 2 * m + 1; k <= 3 * m; k++) {\n\t\tans = (ans - c(3 * m - k + n - 2, n - 2) * n) % md;\n\t}\n\t\n\tif (ans < 0) ans += md;\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\ntemplate<unsigned P> struct ModInt {\n  using M = ModInt;\n  unsigned v;\n  ModInt() : v(0) {}\n  ModInt(auto x) : v(x >= 0 ? x % P : (P - -x % P) % P) {}\n  constexpr ModInt(unsigned v, int) : v(v) {}\n  static constexpr unsigned p() { return P; }\n  M operator+() const { return *this; }\n  M operator-() const { return {v ? P - v : 0, 0}; }\n  explicit operator bool() const noexcept { return v; }\n  bool operator!() const noexcept { return !(bool)*this; }\n  M operator*(M r) const { return M(*this) *= r; }\n  M operator/(M r) const { return M(*this) /= r; }\n  M operator+(M r) const { return M(*this) += r; }\n  M operator-(M r) const { return M(*this) -= r; }\n  bool operator==(M r) const { return v == r.v; }\n  bool operator!=(M r) const { return !(*this == r); }\n  M& operator*=(M r) { v = (uint64_t)v * r.v % P; return *this; }\n  M& operator/=(M r) { return *this *= r.inv(); }\n  M& operator+=(M r) { if ((v += r.v) >= P) v -= P; return *this; }\n  M& operator-=(M r) { if ((v += P - r.v) >= P) v -= P; return *this; }\n  M inv() const {\n    int a = v, b = P, x = 1, u = 0;\n    while (b) {\n      int q = a / b;\n      swap(a -= q * b, b);\n      swap(x -= q * u, u);\n    }\n    assert(a == 1);\n    return x;\n  }\n  M pow(auto n) const {\n    if (n < 0) return pow(-n).inv();\n    M res = 1;\n    for (M a = *this; n; a *= a, n >>= 1) if (n & 1) res *= a;\n    return res;\n  }\n  friend M operator*(auto l, M r) { return M(l) *= r; }\n  friend M operator/(auto l, M r) { return M(l) /= r; }\n  friend M operator+(auto l, M r) { return M(l) += r; }\n  friend M operator-(auto l, M r) { return M(l) -= r; }\n  friend ostream& operator<<(ostream& os, M r) { return os << r.v; }\n  friend istream& operator>>(istream& is, M& r) { lint x; is >> x; r = x; return is; }\n  friend bool operator==(auto l, M r) { return M(l) == r; }\n  friend bool operator!=(auto l, M r) { return !(l == r); }\n};\nusing Mint = ModInt<998244353>;\n\nV<Mint> fact, ifact, inv, powB;\nvoid init(int n, int B = 2) {\n  fact.resize(n + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= n; ++i) {\n    fact[i] = i * fact[i - 1];\n  }\n  ifact.resize(n + 1);\n  ifact[n] = 1 / fact[n];\n  for (int i = n; i > 0; --i) {\n    ifact[i - 1] = i * ifact[i];\n  }\n  inv.resize(n + 1);\n  inv[1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    int q = Mint::p() / i;\n    inv[i] = -q * inv[Mint::p() - i * q];\n  }\n  powB.resize(n + 1);\n  powB[0] = 1;\n  for (int i = 0; i < n; ++i) {\n    powB[i + 1] = powB[i] * B;\n  }\n}\nMint comb(int n, int r) {\n  if (r < 0 or r > n) return 0;\n  return fact[n] * ifact[r] * ifact[n - r];\n}\nMint fn(int s, int k) {\n  return comb(s + k - 1, s);\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n, m; cin >> n >> m;\n  init(n + 3 * m);\n  Mint res = fn(3 * m, n);\n  for (int i = 2 * m + 1; i <= 3 * m; ++i) {\n    res -= n * fn(3 * m - i, n - 1);\n  }\n  for (int i = m + 2; i <= min(n, 3 * m); i += 2) {\n    res -= fn(3 * m - i >> 1, n) * comb(n, i);\n  }\n  cout << res << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <algorithm>\n#include <set>\nusing namespace std;\nlong long int Fac[2800100]; \nlong long int Pow(long long int a, long long int n, long long int m) {\n\tlong long int powa[65];\n  \tpowa[0] = a; \n  \tfor(int j = 0; j < 64; ++j){\n     \t\tpowa[j+1] = (powa[j] * powa[j]) % m; \n  \t}\n\tlong long int c = n; \n  \tlong long int Q = 1; int k = 0; \n\twhile(c > 0){\n  \t\tif(c & 1) Q = (Q * powa[k]) % m; \n\t\tc = c >> 1; k++; \n\t}\n\treturn Q;\n}\nlong long int Inv(long long int a, long long int m) {\n\treturn Pow(a, m-2, m); \n}\nlong long int Comb(int N, int R, long long int m){\n\tif(N < 0 || R < 0 || R > N) return 0; \n\telse return (((Fac[N] * Inv(Fac[N-R], m)) % m) * Inv(Fac[R], m)) % m; \n}\nint main() { \n\tlong long int N, M; cin >> N >> M; \n\tlong long int P = 998244353; \n\tFac[0] = 1; \n\tfor(int i = 1; i < 2800050; i++){\n\t\tFac[i] = (Fac[i-1] * i) % P; \n\t}\n\tlong long int ALL = Comb(N + M * 3 - 1, N - 1, P); \n\tlong long int impo = 0; \n\tfor(int i = 0; i < M; i++){\n\t\tlong long int tmp = Comb(N + i - 2, i, P); \n\t\timpo += tmp; impo %= P; \n\t}\n\timpo *= N; impo %= P;\n\tlong long int impo2 = 0; \n\tfor(int i = 0; i < M; i++){\n\t\tlong long int tmp = (Comb(N + i - 1, i, P) * Comb(N, 3 * M - i * 2, P)) % P; \n\t\timpo2 += tmp; impo2 %= P; \n\t}\n\tcout << (P * 2 + ALL - impo - impo2) % P << endl; \n}"
  },
  {
    "language": "C++",
    "code": "// C - GP 2\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define\tMOD 998244353\n\nconst int FACT_MAX = 2000000;\nlong long fact[FACT_MAX] = {1}, finv[FACT_MAX];\n\nvoid init_fact()\n{\n\tfor (int i = 1; i < FACT_MAX; i++) fact[i] = fact[i - 1] * i % MOD;\n\tfinv[FACT_MAX - 1] = 1;\n\tfor (long long n = MOD - 2, a = fact[FACT_MAX - 1]; n > 0; a = a * a % MOD, n >>= 1)\n\t\tif (n & 1) finv[FACT_MAX - 1] = finv[FACT_MAX - 1] * a % MOD;\n\tfor (int i = FACT_MAX - 2; i >= 0; i--)\n\t\tfinv[i] = finv[i + 1] * (i + 1) % MOD;\n}\n\nlong long cnr(int n, int r)\n{\n\tif (r < 0 || r > n) return 0;\n\tif (r == 0 || r == n) return 1;\n\treturn fact[n] * finv[r] % MOD * finv[n - r] % MOD;\n}\n\nint main(int argc, char *argv[])\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n\n\tlong long n, m;\n\tcin >> n >> m;\n\n\tinit_fact();\n\n\tlong long ans = 0;\n\tfor (int k = 0; k <= min(m, n); k++) {\n\t\tif ((3 * m - k) % 2) continue;\n\t\tlong long c = (3 * m - k) / 2;\n\t\tans = (ans + cnr(c + n - 1, c) * cnr(n, k) % MOD) % MOD;\n\t}\n\n\tlong long r = 0;\n\tfor (int k = 0; k <= min(m, n); k++) {\n\t\tif ((m - k) % 2) continue;\n\t\tlong long c = (m - k) / 2;\n\t\tr = (r + cnr(c + n - 1, c) * cnr(n, k) % MOD - cnr(c + n - 2, c) * cnr(n - 1, k) % MOD + MOD) % MOD;\n\t}\n\tans = (ans - r * n % MOD + MOD) % MOD;\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define vv(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define vvi std::vector<std::vector<int> >\n#define vvl std::vector<std::vector<ll> >\n#define MODs 1000000007;\ntypedef long long int ll;\nusing namespace std;\n\n////////////////////////////////\n#define P 998244353\n#define N_MAX 10000000\ntypedef long long int ll;\nll fac[N_MAX+1];\nll inv[N_MAX+1];\nll finv[N_MAX+1];\n\nll comb(ll n, ll k){\n    return (((fac[n]*finv[n-k])%P)*finv[k])%P;\n}\nvoid init(){\n    fac[0] = finv[0] = fac[1] = finv[1] = inv[1] = 1;\n    for(int i = 2; i <= N_MAX; i++){\n        fac[i] = (fac[i-1]*i)%P;\n        inv[i] = ((-(P/i)*inv[P%i])%P+P)%P;\n        finv[i] = (finv[i-1]*inv[i])%P;\n    }\n}\nll pp(ll a, ll b){return (a * b)%P;}\nll pm(ll a, ll b){return (a>b?a-b:(a-b+P)%P);}\n//////////////////////////////////////\nint main(int argc, char const *argv[]) {\n  ll N, M, ans = 0;\n  std::cin >> N >> M;\n  init();\n  for(int i=0;i<=min(M, N);i++){\n    if((3*M-i)%2==1) continue;\n    ll tmp = pp(comb(N, i), comb((3*M-i)/2+N-1, N-1));\n    ll tmp2 = pp(pp(comb(N, i), i), comb((M-i)/2+N-1, N-1));\n    ll tmp3 = (i==M?0:pp(pp(comb(N, i), N-i), comb((M-i-2)/2+N-1, N-1)));\n    //std::cout << \"now\" << i << \" \" <<  tmp << \" \" << tmp2 << \" \" << tmp3<< '\\n';\n    ans = (ans+pm(pm(tmp, tmp2), tmp3))%P;\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\nint _max(int x, int y) {return x > y ? x : y;}\nint _min(int x, int y) {return x < y ? x : y;}\nconst int N = 1750001;\nconst int mod = 998244353;\nint read() {\n\tint s = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();\n\treturn s * f;\n}\nvoid put(int x) {\n\tif(x < 0) x = -x, putchar('-');\n\tif(x >= 10) put(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nint ans, jc[N], inv[N];\n\nint add(int x, int y) {\n\tx += y;\n\treturn x >= mod ? x - mod : x;\n}\nint dec(int x, int y) {\n\tx -= y;\n\treturn x < 0 ? x + mod : x;\n}\nint pow_mod(int a, int k) {\n\tint ans = 1;\n\twhile(k) {\n\t\tif(k & 1) ans = (LL)ans * a % mod;\n\t\ta = (LL)a * a % mod, k /= 2;\n\t} return ans;\n}\nint C(int n, int m) {return (LL)jc[n] * inv[m] % mod * inv[n - m] % mod;}\n\nint main() {\n\tint n = read(), m = read();\n\tint lim = 3 * m / 2 + n - 1;\n\tjc[0] = 1; for(int i = 1; i <= lim; i++) jc[i] = (LL)jc[i - 1] * i % mod;\n\tinv[lim] = pow_mod(jc[lim], mod - 2); for(int i = lim; i >= 1; i--) inv[i - 1] = (LL)inv[i] * i % mod;\n\tfor(int i = 0; i <= n; i++) if((3 * m - i) % 2 == 0) ans = add(ans, (LL)C(n, i) * C((3 * m - i) / 2 + n - 1, n - 1) % mod);\n\tfor(int i = 0; i <= n; i++) if((m - i) % 2 == 0) ans = dec(ans, (LL)C(n, i) * C((m - i) / 2 + n - 1, n - 1) % mod * n % mod);\n\tfor(int i = 0; i <= n; i++) if((m - i) % 2 == 0) ans = add(ans, (LL)C(n - 1, i) * C((m - i) / 2 + n - 2, n - 2) % mod * n % mod);\n\tput(ans), puts(\"\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <vector>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n//#define cerr if(false) cerr\n#ifdef DEBUG\n#define show(...) cerr << #__VA_ARGS__ << \" = \", debug(__VA_ARGS__);\n#else\n#define show(...) 42\n#endif\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> a) {\n    os << '(' << a.first << ',' << a.second << ')';\n    return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, vector<T> v) {\n    for (auto x : v) os << x << ' ';\n    return os;\n}\nvoid debug() {\n    cerr << '\\n';\n}\ntemplate <typename H, typename... T>\nvoid debug(H a, T... b) {\n    cerr << a;\n    if (sizeof...(b)) cerr << \", \";\n    debug(b...);\n}\ntemplate<int MOD>\nclass Modint{\npublic:\n    int a;\n    Modint(const long long v = 0):a(v % MOD){}\n    int getmod() const{\n        return MOD;\n    }\n    Modint operator+(const Modint rhs) const{\n        return Modint(*this) += rhs;\n    }\n    Modint operator-(const Modint rhs) const{\n        return Modint(*this) -= rhs;\n    }\n    Modint operator*(const Modint rhs) const{\n        return Modint(*this) *= rhs;\n    }\n    Modint operator/(const Modint rhs) const{\n        return Modint(*this) /= rhs;\n    }\n    Modint operator+(const long long rhs) const{\n        return Modint(*this) += rhs;\n    }\n    Modint operator-(const long long rhs) const{\n        return Modint(*this) -= rhs;\n    }\n    Modint operator*(const long long rhs) const{\n        return Modint(*this) *= rhs;\n    }\n    Modint operator/(const long long rhs) const{\n        return Modint(*this) /= rhs;\n    }\n    friend Modint operator+(const long long a, const Modint b){\n        return b + a;\n    }\n    friend Modint operator-(const long long a, const Modint b){\n        return -b + a;\n    }\n    friend Modint operator*(const long long a, const Modint b){\n        return b * a;\n    }\n    friend Modint operator/(const long long a, const Modint b){\n        return Modint(a) / b;\n    }\n    Modint &operator+=(const Modint rhs){\n        a += rhs.a;\n        if(a >= MOD){\n            a -= MOD;\n        }\n        return *this;\n    }\n    Modint &operator-=(const Modint rhs){\n        if(a < rhs.a){\n            a += MOD;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n    Modint &operator*=(const Modint rhs){\n        a = (long long)a * rhs.a % MOD;\n        return *this;\n    }\n    Modint &operator/=(Modint rhs){\n        int x = MOD - 2;\n        while(x){\n            if(x % 2){\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            x /= 2;\n        }\n        return *this;\n    }\n    Modint &operator++(){\n        *this += 1;\n        return *this;\n    }\n    Modint &operator--(){\n        *this -= 1;\n        return *this;\n    }\n    Modint operator++(int){\n        Modint res = *this;\n        ++(*this);\n        return res;\n    }\n    Modint operator--(int){\n        Modint res = *this;\n        res -= 1;\n        return res;\n    }\n    Modint &operator+=(const long long rhs){\n        *this += Modint(rhs);\n        return *this;\n    }\n    Modint &operator-=(const long long rhs){\n        *this -= Modint(rhs);\n        return *this;\n    }\n    Modint &operator*=(const long long rhs){\n        *this *= Modint(rhs);\n        return *this;\n    }\n    Modint &operator/=(const long long rhs){\n        *this /= Modint(rhs);\n        return *this;\n    }\n    Modint operator+() const{\n        return *this;\n    }\n    Modint operator-() const{\n        return Modint()-*this;\n    }\n    bool operator==(const Modint rhs) const{\n        return a == rhs.a;\n    }\n    bool operator==(const long long rhs) const{\n        return a == rhs;\n    }\n    friend bool operator==(const long long a, const Modint b){\n        return a == b.a;\n    }\n    bool operator!=(const Modint rhs) const{\n        return a != rhs.a;\n    }\n    bool operator!=(const long long rhs) const{\n        return a != rhs;\n    }\n    friend ostream &operator<<(ostream &os, const Modint x){\n        os << x.a;\n        return os;\n    }\n    friend istream &operator>>(istream &is, Modint &x){\n        is >> x.a;\n        return is;\n    }\n    explicit operator bool() const{\n        return a > 0;\n    }\n    bool operator!(){\n        return a == 0;\n    }\n    explicit operator int() const{\n        return a;\n    }\n    explicit operator long long() const{\n        return (long long) a;\n    }\n    friend Modint pow(Modint a, long long b){\n        Modint res = 1;\n        while(b){\n            if(b % 2){\n                res *= a;\n            }\n            a *= a;\n            b /= 2;\n        }\n        return res;\n    }\n};\nusing mint = Modint<998244353>;\nconst int NUM = 3000000;\nmint fact[NUM + 1], fact_inv[NUM + 1], inv[NUM + 1];\nmint combi(long long N_, long long K_){\n    static const int Mod_ = fact[0].getmod();\n    if(fact[0] == 0){\n        inv[1] = fact[0] = fact_inv[0] = 1;\n        for(int i = 2; i <= NUM; i++){\n            inv[i] = inv[Mod_ % i] * (Mod_ - Mod_ / i);\n        }\n        for(int i = 1; i <= NUM; i++){\n            fact[i] = fact[i - 1] * i;\n            fact_inv[i] = fact_inv[i - 1] * inv[i];\n        }\n    }\n    if(K_ < 0 or K_ > N_) return 0;\n    return fact_inv[K_] * fact[N_] * fact_inv[N_ - K_];\n}\nmint hcomb(long long N_, long long K_){\n    return ((N_ | K_) == 0) ? 1 : combi(N_ + K_ - 1, K_);\n}\nint main(){\n    int n, m;\n    cin >> n >> m;\n    mint ans = 0;\n    for(int i = m % 2; i <= min(n, m); i += 2){\n        ans += combi(n, i) * hcomb(n, (3 * m - i) / 2);\n    }\n    cout << ans - n * hcomb(n, m - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include <atcoder/all>\nusing namespace std;\n// using namespace atcoder;\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  os << \"(\" << p.first << \",\" << p.second << \")\";\n  return os;\n}\n#ifdef __LOCAL\n#define debug(x) cerr << __LINE__ << \": \" << #x << \" = \" << (x) << '\\n'\n#define debugArray(x, n)                                      \\\n  cerr << __LINE__ << \": \" << #x << \" = {\";                   \\\n  for (long long hoge = 0; (hoge) < (long long)(n); ++(hoge)) \\\n    cerr << ((hoge) ? \",\" : \"\") << x[hoge];                   \\\n  cerr << \"}\" << '\\n'\n#define debugMatrix(x, h, w)                                         \\\n  cerr << __LINE__ << \": \" << #x << \" =\\n\";                          \\\n  for (long long hoge = 0; (hoge) < (long long)(h); ++(hoge)) {      \\\n    cerr << ((hoge ? \" {\" : \"{{\"));                                  \\\n    for (long long fuga = 0; (fuga) < (long long)(w); ++(fuga))      \\\n      cerr << ((fuga ? \", \" : \"\")) << x[hoge][fuga];                 \\\n    cerr << \"}\" << (hoge + 1 == (long long)(h) ? \"}\" : \",\") << '\\n'; \\\n  }\n#else\n#define debug(x) (void(0))\n#define debugArray(x, n) (void(0))\n#define debugMatrix(x, h, w) (void(0))\n#endif\n\ntemplate <int mod>\nstruct ModInt {\n  int64_t x;\n  ModInt() : x(0) {}\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod)) {}\n  ModInt &operator+=(const ModInt &p) {\n    if ((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n  ModInt &operator-=(const ModInt &p) {\n    if ((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n  ModInt &operator*=(const ModInt &p) {\n    x = (int)(1LL * x * p.x % mod);\n    return *this;\n  }\n  ModInt &operator/=(const ModInt &p) { return *this *= p.inverse(); }\n  ModInt operator-() const { return ModInt() - *this; }\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n  bool operator==(const ModInt &p) const { return x == p.x; }\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while (b) t = a / b, swap(a -= t * b, b), swap(u -= t * v, v);\n    return ModInt(u);\n  }\n  ModInt pow(int64_t e) const {\n    ModInt ret(1);\n    for (ModInt b = *this; e; e >>= 1, b *= b)\n      if (e & 1) ret *= b;\n    return ret;\n  }\n  friend ostream &operator<<(ostream &os, const ModInt &p) { return os << p.x; }\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt<mod>(t);\n    return (is);\n  }\n  static int modulo() { return mod; }\n  int get() const { return x; }\n};\n\ntemplate <class Modint>\nstruct Combination {\n  static vector<Modint> _fact, _finv, _inv;\n  static void init(int sz) {\n    int n = min(2 * sz, Modint::modulo() - 1);\n    _fact.resize(n + 1), _finv.resize(n + 1), _inv.resize(n + 1);\n    for (int i = 0; i <= n; ++i) _fact[i] = i ? Modint(i) * _fact[i - 1] : 1;\n    _finv[n] = _fact[n].inverse();\n    for (int i = n; i; --i) _finv[i - 1] = Modint(i) * _finv[i];\n    for (int i = 1; i <= n; ++i) _inv[i] = _finv[i] * _fact[i - 1];\n  }\n  static Modint inverse(int n) { return _inv[n]; }\n  static Modint fact(int n, bool inv = 0) { return inv ? _finv[n] : _fact[n]; }\n  static Modint nPr(int n, int r) {\n    if (n < r || r < 0) return Modint(0);\n    return _fact[n] * _finv[n - r];\n  }\n  static Modint nCr(int n, int r) { return nPr(n, r) * _finv[r]; }\n  static Modint nHr(int n, int r) { return !r ? Modint(1) : nCr(n + r - 1, r); }\n  static size_t size() { return _inv.size(); }\n};\ntemplate <class Modint>\nvector<Modint> Combination<Modint>::_fact;\ntemplate <class Modint>\nvector<Modint> Combination<Modint>::_finv;\ntemplate <class Modint>\nvector<Modint> Combination<Modint>::_inv;\n\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  using Mint = ModInt<998244353>;\n  using Comb = Combination<Mint>;\n  Comb::init(3123456);\n  int N, M;\n  cin >> N >> M;\n  auto f = [&](int n, int sum) {\n    Mint ret = 0;\n    for (int i = 0; i <= M; i++) {\n      if ((sum - i) & 1) continue;\n      ret += Comb::nCr(n, i) * Comb::nHr(n, (sum - i) / 2);\n    }\n    return ret;\n  };\n  cout << f(N, 3 * M) - (f(N, M) - f(N - 1, M)) * N << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.rbegin(),a.rend()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ntypedef vector<T> vt;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"YES\");}else{puts(\"NO\");}\nconst int MX = 2000005;\n\n// Mod int\nconst int mod = 998244353;\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  // mint(ll x):x(x){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint operator~() const { return mint(1) / *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=a.ex(mod-2).x)%=mod; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  mint ex(ll t) const {\n    if(!t) return 1;\n    mint res = ex(t/2);\n    res *= res;\n    return (t&1)?res*x:res;\n  }\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nmint ex(mint x, ll t) { return x.ex(t);}\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\ntypedef vector<mint> vm;\nstruct comb {\n  vm f, g;\n  comb(){}\n  comb(int mx):f(mx+1),g(mx+1) {\n    f[0] = 1;\n    rrep(i,mx) f[i] = f[i-1]*i;\n    g[mx] = f[mx].ex(mod-2);\n    for(int i=mx;i>0;i--) g[i-1] = g[i]*i;\n  }\n  mint c(int a, int b) {\n    if (a < 0) return 0;\n    if (b < 0) return 0;\n    if (a < b) return 0;\n    return f[a]*g[b]*g[a-b];\n  }\n} c(MX);\n//\n\n\n\n\n\nint main() {\n  int n,m;\n  scanf(\"%d%d\",&n,&m);\n  int m3 = m*3;\n  mint ans;\n  rep(i,m+1) {\n    int r = m3-i;\n    if (r%2) continue;\n    if (i > n) continue;\n    int x = r/2;\n    mint now = c.c(x+n-1,x);\n    now -= c.c(x+n-1-(m+1),x-(m+1))*(n-i);\n    now -= c.c(x+n-1-(m),x-m)*(i);\n    now *= c.c(n,i);\n    ans += now;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <type_traits>\n#include <tuple>\n\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(std::min<int>(l_, r_)), r(r_) {}\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr r, l;\n  constexpr revrange(int l_, int r_): r(std::max<int>(l_, r_) - 1), l(l_ - 1) {}\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\ntemplate <class T>\ninline T scan() {\n  T res;\n  std::cin >> res;\n  return res;\n}\n\ntemplate <class T>\nclass modulo_int {\npublic:\n  static constexpr int mod = T::value;\n  static_assert(mod > 0, \"mod must be positive\");\nprivate:\n  long long value;\n  constexpr void normalize() {\n    value %= mod;\n    if (value < 0) value += mod;\n  }\npublic:\n  constexpr modulo_int(long long value_ = 0): value(value_) { normalize(); }\n  constexpr modulo_int operator - () const { return modulo_int(mod - value); }\n  constexpr modulo_int operator ~ () const { return power(mod - 2); }\n  constexpr long long operator () () const { return value; }\n  constexpr modulo_int operator + (const modulo_int& rhs) const { return modulo_int(*this) += rhs; }\n  constexpr modulo_int& operator += (const modulo_int& rhs) {\n    if ((value += rhs.value) >= mod) value -= mod;\n    return (*this);\n  }\n  constexpr modulo_int operator - (const modulo_int& rhs) const { return modulo_int(*this) -= rhs; }\n  constexpr modulo_int& operator -= (const modulo_int& rhs) {\n    if ((value += mod - rhs.value) >= mod) value -= mod;\n    return (*this);\n  }\n  constexpr modulo_int operator * (const modulo_int& rhs) const { return modulo_int(*this) *= rhs; }\n  constexpr modulo_int& operator *= (const modulo_int& rhs) {\n    (value *= rhs.value) %= mod;\n    return (*this);\n  }\n  constexpr modulo_int operator / (const modulo_int& rhs) const { return modulo_int(*this) /= rhs; }\n  constexpr modulo_int& operator /= (const modulo_int& rhs) {\n    return (*this) *= ~rhs;\n  }\n  constexpr modulo_int power (unsigned long long pow) const {\n    modulo_int result(1), mult(*this);\n    while (pow > 0) {\n      if (pow & 1) result *= mult;\n      mult *= mult;\n      pow >>= 1;\n    }\n    return result;\n  }\n  friend std::istream& operator >> (std::istream& stream, modulo_int& lhs) {\n    stream >> lhs.value;\n    lhs.normalize();\n    return stream;\n  }\n  friend std::ostream& operator << (std::ostream& stream, const modulo_int& rhs) {\n    return stream << rhs.value;\n  }\n};\n\ntemplate <class T>\nclass factorials {\npublic:\n  using value_type = T;\n\npublic:\n  std::vector<value_type> fact, fact_inv;\n\n  factorials(int size_ = 200000): fact(size_ + 1), fact_inv(size_ + 1) {\n    fact[0] = 1;\n    for (int i = 1; i <= size_; ++i) {\n      fact[i] = fact[i - 1] * value_type(i);\n    }\n    fact_inv[size_] = ~fact[size_];\n    for (int i = size_; i > 0; --i) {\n      fact_inv[i - 1] = fact_inv[i] * value_type(i);\n    }\n  }\n\n  value_type operator () (int n, int r) const {\n    return fact[n] * fact_inv[n - r] * fact_inv[r];\n  }\n\n};\n\nusing modint = modulo_int<std::integral_constant<int, 998244353>>;\nfactorials<modint> fact(2500000);\n\nmodint calc(int sum, int to) {\n  if (to == 0) {\n    return modint(sum == 0 ? 1 : 0);\n  }\n  else {\n    return fact(sum + to - 1, to - 1);\n  }\n}\n\nmodint path(int x, int y) {\n  return fact(x + y, x);\n}\n\nint main() {\n  // 合計 3M, 最大のものが 2M 以下, 1 の個数が M 以下\n  int N, M;\n  std::cin >> N >> M;\n  modint ans = calc(3 * M, N);\n  // 合計 3M かつ 最大のものが 2M より大きい\n  for (int k: range(2 * M + 1, 3 * M + 1)) {\n    ans -= calc(3 * M - k, N - 1) * modint(N);\n  }\n  // 合計 3M かつ 1 の個数が M より大きい\n  for (int k: range(M + 1, N + 1)) {\n    if (k > 3 * M) {\n      break;\n    }\n    modint coeff = path(M, k - M - 1) * modint((k - M) % 2 == 0 ? -1 : 1);\n    ans -= coeff * fact(N, k) * calc(3 * M - k, N - k);\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nT power(T a, long long b) {\n  T r = 1;\n  while (b) {\n    if (b & 1) {\n      r *= a;\n    }\n    a *= a;\n    b >>= 1;\n  }\n  return r;\n}\n\nint inverse(int a, int m) {\n  a %= m;\n  if (a < 0) {\n    a += m;\n  }\n  int b = m, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= a * t;\n    swap(a, b);\n    u -= v * t;\n    swap(u, v);\n  }\n  if (u < 0) {\n    u += m;\n  }\n  return u;\n}\n\ntemplate <int _P>\nstruct modnum {\n  static constexpr int P = _P;\n\n private:\n  int v;\n\n public:\n  modnum() : v(0) {\n  }\n\n  modnum(long long _v) {\n    v = _v % P;\n    if (v < 0) {\n      v += P;\n    }\n  }\n\n  explicit operator int() const {\n    return v;\n  }\n\n  bool operator==(const modnum& o) const {\n    return v == o.v;\n  }\n\n  bool operator!=(const modnum& o) const {\n    return v != o.v;\n  }\n\n  modnum inverse() const {\n    return modnum(::inverse(v, P));\n  }\n\n  modnum operator-() const {\n    return modnum(v ? P - v : 0);\n  }\n  \n  modnum operator+() const {\n    return *this;\n  }\n\n  modnum& operator++() {\n    v++;\n    if (v == P) {\n      v = 0;\n    }\n    return *this;\n  }\n  \n  modnum& operator--() {\n    if (v == 0) {\n      v = P;\n    }\n    v--;\n    return *this;\n  }\n\n  modnum operator++(int) {\n    modnum r = *this;\n    ++*this;\n    return r;\n  }\n  \n  modnum operator--(int) {\n    modnum r = *this;\n    --*this;\n    return r;\n  }\n\n  modnum& operator+=(const modnum& o) {\n    v += o.v;\n    if (v >= P) {\n      v -= P;\n    }\n    return *this;\n  }\n\n  modnum operator+(const modnum& o) const {\n    return modnum(*this) += o;\n  }\n\n  modnum& operator-=(const modnum& o) {\n    v -= o.v;\n    if (v < 0) {\n      v += P;\n    }\n    return *this;\n  }\n\n  modnum operator-(const modnum& o) const {\n    return modnum(*this) -= o;\n  }\n\n  modnum& operator*=(const modnum& o) {\n    v = (int) ((long long) v * o.v % P);\n    return *this;\n  }\n\n  modnum operator*(const modnum& o) const {\n    return modnum(*this) *= o;\n  }\n  \n  modnum& operator/=(const modnum& o) {\n    return *this *= o.inverse();\n  }\n\n  modnum operator/(const modnum& o) const {\n    return modnum(*this) /= o;\n  }\n};\n\ntemplate <int _P>\nostream& operator<<(ostream& out, const modnum<_P>& n) {\n  return out << int(n);\n}\n\ntemplate <int _P>\nistream& operator>>(istream& in, modnum<_P>& n) {\n  long long _v;\n  in >> _v;\n  n = modnum<_P>(_v);\n  return in;\n}\n\nusing num = modnum<998244353>;\n\nint main() {\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<num> fact(m * 3 + n);\n  fact[0] = 1;\n  for (int i = 1; i < m * 3 + n; ++i) {\n    fact[i] = fact[i - 1] * i;\n  }\n  vector<num> inv_fact(m * 3 + n);\n  for (int i = 0; i < m * 3 + n; ++i) {\n    inv_fact[i] = num(1) / fact[i];\n  }\n  auto C = [&](int i, int j) {\n    if (i < j) {\n      return num(0);\n    }\n    return fact[i] * inv_fact[j] * inv_fact[i - j];\n  };\n  num ans = 0;\n  for (int i = m; i >= 0; i -= 2) {\n    if (i <= n) {\n      int t = (m * 3 - i) / 2;\n      ans += C(n, i) * (C(t + n - 1, n - 1) - C(t + n - 1 - m, n - 1) * i - C(t + n - 2 - m, n - 1) * (n - i));\n    }\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntypedef long double ld;\n\nconst int inf = 1e9;\nconst ll inf64 = 1e18;\n\nconst int mod = 998244353;\n\ninline int _mul(int a, int b) {\n    return (1ll * a * b) % mod;\n}\n\ninline int _sum(int a, int b) {\n    return a + b < mod ? a + b : a + b - mod;\n}\n\ninline int _sub(int a, int b) {\n    return a >= b ? a - b : a - b + mod;\n}\n\ninline void _inc(int &x, int y) {\n    if ((x += y) >= mod) {\n        x -= mod;\n    }\n}\n\ninline void _dec(int &x, int y) {\n    if ((x -= y) < 0) {\n        x += mod;\n    }\n}\n\ninline int _binpow(int x, int p) {\n    int res = 1;\n    int tmp = x;\n    while (p > 0) {\n        if (p & 1) {\n            res = _mul(res, tmp);\n        }\n        tmp = _mul(tmp, tmp);\n        p >>= 1;\n    }\n    return res;\n}\n\nconst int N = 3e6 + 5;\n\nint fact[N];\nint rfact[N];\n\nvoid precalc() {\n    fact[0] = 1;\n    for (int i = 1; i < N; i++) {\n        fact[i] = _mul(fact[i - 1], i);\n    }\n    rfact[N - 1] = _binpow(fact[N - 1], mod - 2);\n    for (int i = N - 2; i >= 0; i--) {\n        rfact[i] = _mul(rfact[i + 1], i + 1);\n    }\n}\n\ninline int CNK(int n, int k) {\n    if (n < k) {\n        return 0;\n    }\n    return _mul(fact[n], _mul(rfact[n - k], rfact[k]));\n}\n\ninline int F(int n, int k) {\n    return CNK(n + k - 1, k);\n}\n\nint main() {\n\n    precalc();\n\n#ifdef debug\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n\n    int n, m;\n\n    cin >> n >> m;\n\n    int res = 0;\n\n    for (int i = m & 1; i <= m; i += 2) {\n        _inc(\n            res,\n            _mul(\n                CNK(n, i),\n                F(n, (3 * m - i) / 2)\n            )\n        );\n    }\n\n    _dec(\n        res,\n        _mul(\n            n,\n            F(n, m - 1)\n        )\n    );\n\n    cout << res << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong N,M,mod=998244353;\nlong F[1<<25],I[1<<25];\nlong power(long a,long b){return b?power(a*a%mod,b/2)*(b%2?a:1)%mod:1;}\nlong C(long a,long b)\n{\n\treturn a<b||a<0||b<0?0:F[a]*I[b]%mod*I[a-b]%mod;\n}\nlong H(long a,long b){return a<0?0:C(a+b-1,b-1);}\nlong calc(long n,long m,long s)\n{\n\tlong ret=0;\n\tfor(int i=0;i<=n&&i<=m;i++)\n\t{\n\t\tif(s-i&1)continue;\n\t\t(ret+=C(n,i)*H((s-i)/2,n)%mod)%=mod;\n\t}\n\treturn ret;\n}\nmain()\n{\n\tcin>>N>>M;\n\tlong T=2*M+N;\n\tF[0]=1;\n\tfor(long i=1;i<T;i++)F[i]=F[i-1]*i%mod;\n\tI[T-1]=power(F[T-1],mod-2);\n\tfor(long i=T-1;i--;)I[i]=I[i+1]*(i+1)%mod;\n\tlong ans=0;\n\tfor(int i=0;i<=N&&i<=M;i++)\n\t{\n\t\tif((3*M-i)%2==1)continue;\n\t\t(ans+=C(N,i)*H((3*M-i)/2,N)%mod)%=mod;\n\t}\n\tlong ret=0;\n\tfor(int i=0;i<=N&&i<=M;i++)\n\t{\n\t\tif((M-i)%2==1)continue;\n\t\t(ret+=C(N,i)*H((M-i)/2,N)%mod)%=mod;\n\t}\n\tfor(int i=0;i<=N-1&&i<=M;i++)\n\t{\n\t\tif((M-i)%2==1)continue;\n\t\t(ret+=mod-C(N-1,i)*H((M-i)/2,N-1)%mod)%=mod;\n\t}\n\tcout<<(calc(N,M,3*M)-calc(N,M,M)*N%mod+calc(N-1,M,M)*N%mod+mod)%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int MOD = 998244353;\nconst int MAXN = 2000000;\nint fct[MAXN + 5], ifct[MAXN + 5];\nint pow_mod(int b, int p) {\n\tint ret = 1;\n\twhile( p ) {\n\t\tif( p & 1 ) ret = 1LL*ret*b%MOD;\n\t\tb = 1LL*b*b%MOD;\n\t\tp >>= 1;\n\t}\n\treturn ret;\n}\nvoid init() {\n\tfct[0] = 1;\n\tfor(int i=1;i<=MAXN;i++)\n\t\tfct[i] = 1LL*fct[i-1]*i%MOD;\n\tifct[MAXN] = pow_mod(fct[MAXN], MOD-2);\n\tfor(int j=MAXN-1;j>=0;j--)\n\t\tifct[j] = 1LL*ifct[j+1]*(j+1)%MOD;\n}\nint comb(int n, int m) {\n\treturn 1LL*fct[n]*ifct[m]%MOD*ifct[n-m]%MOD;\n}\nint main() {\n\tinit();\n\tint ans = 0, N, M;\n\tscanf(\"%d%d\", &N, &M);\n\tfor(int i=M&1;i<=M&&i<=N;i+=2) {\n\t\tint tmp = comb((3*M-i)/2+(N-1), N-1);\n\t\ttmp = (tmp + MOD - 1LL*(N-i)*comb((M-i-2)/2+(N-1), N-1)%MOD)%MOD;\n\t\ttmp = (tmp + MOD - 1LL*i*comb((M-i)/2+(N-1), N-1)%MOD)%MOD;\n\t\tans = (ans + 1LL*tmp*comb(N, i)%MOD)%MOD;\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<tuple>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define Per(i,sta,n) for(int i=n-1;i>=sta;i--)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n\ntemplate<int mod>\nstruct ModInt {\n    long long x;\n \n    ModInt() : x(0) {}\n    ModInt(long long y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    explicit operator int() const {return x;}\n \n    ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &p) {\n        if((x += mod - p.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &p) {\n        x = (int)(1LL * x * p.x % mod);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n \n    ModInt operator-() const { return ModInt(-x); }\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n \n    bool operator==(const ModInt &p) const { return x == p.x; }\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n \n    ModInt inverse() const{\n        int a = x, b = mod, u = 1, v = 0, t;\n        while(b > 0) {\n            t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        return ModInt(u);\n    }\n\n    ModInt power(long long p) const{\n        int a = x;\n        if (p==0) return 1;\n        if (p==1) return ModInt(a);\n        if (p%2==1) return (ModInt(a)*ModInt(a)).power(p/2)*ModInt(a);\n        else return (ModInt(a)*ModInt(a)).power(p/2);\n    }\n\n    ModInt power(const ModInt p) const{\n        return ((ModInt)x).power(p.x);\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt<mod> &p) {\n        return os << p.x;\n    }\n    friend istream &operator>>(istream &is, ModInt<mod> &a) {\n        long long x;\n        is >> x;\n        a = ModInt<mod>(x);\n        return (is);\n    }\n};\n\nusing modint = ModInt<mod>;\n\nstruct ModFac{\n  public:\n    vector<modint> f,i_f;\n    int n;\n\n    ModFac(int n_){\n      n=n_;\n      f.resize(n+1,1);\n      i_f.resize(n+1,1);\n      for(int i=0;i<n;i++){\n        f[i+1]=f[i]*(modint)(i+1);\n      }\n      i_f[n]=f[n].power(mod-2);\n      for(int i=n-1;i>=0;i--){\n        i_f[i]=i_f[i+1]*(modint)(i+1);\n      }\n    }\n    ModFac(modint n_){\n      n=(int)n_;\n      f.resize(n+1,1);\n      i_f.resize(n+1,1);\n      for(int i=0;i<n;i++){\n        f[i+1]=f[i]*(modint)(i+1);\n      }\n      i_f[n]=f[n].power(mod-2);\n      for(int i=n-1;i>=0;i--){\n        i_f[i]=i_f[i+1]*(modint)(i+1);\n      }\n    }\n    \n    modint factorial(int x){\n      //cout << f.size() << endl;\n      return f[x];\n    }\n        \n    modint inv_factorial(int x){\n      return i_f[x];\n    }\n    \n    modint comb(int m,int k){\n      if (m<0 or k<0) return 0;\n      if (m<k) return 0;\n      return f[m]*i_f[k]*i_f[m-k];\n    }\n};\n\n\nint n,m;\nModFac F(200010);\n\nvoid solve(){\n    cin >> n >> m;\n    modint A=0;\n    rep(i,m+1){\n        if(i%2!=m%2) continue;\n        A+=F.comb(n,i)*F.comb((3*m-i)/2+n-1,n-1);\n    }\n    //cout << A << endl;\n    modint B=0;\n    rep(i,m+1){\n       if(i+(m+i)%2>m) continue;\n       if((m+i)%2==1) B+=(modint)n*F.comb(n-1,i)*F.comb((m-i)/2+n-1,n-1);\n       else B+=(modint)n*F.comb(n-1,i)*F.comb((m-i)/2+n-2,n-1);\n    }\n    //cout << B << endl;\n    cout << A-B << endl;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(50);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#include<cassert>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\nconst long long mod = 998244353;\nconst long long inf = 1ll << 61;\nconst int maxn = 2600000;\ntypedef pair<int, int> P;\n\nint kj[maxn], kji[maxn];\n\nint modpow(int x, int n, int md) {\n\tif (!n)return 1;\n\tint res = modpow(x*x%md, n / 2, md);\n\tif (n & 1)res = res*x%md;\n\treturn res;\n}\nint comb(int n, int r) {\n\tif (n < 0 || r<0 || n < r)return 0;\n\tint ans = kj[n];\n\tans = ans*kji[r] % mod;\n\tans = ans*kji[n - r] % mod;\n\treturn ans;\n}\n\n\nvoid kjinit(int n) {\n\tkj[0] = 1;\n\trep(i, n) {\n\t\tkj[i + 1] = kj[i] * (i + 1);\n\t\tkj[i + 1] %= mod;\n\t}\n\trep(i, n)kji[i] = modpow(kj[i], mod - 2, mod);\n\n}\nsigned main() {\n\tint n, m; cin >> n >> m;\n\tkjinit(maxn);\n\tint ans = comb(3 * m + n - 1, n - 1);\n\tfor (int i = 2 * m + 1; i <= 3 * m; i++) {\n\t\tint t = n*comb(3*m-i+n-2, n - 2)%mod;\n\t\tans = ans + mod - t;\n\t\tans %= mod;\n\t}\n\tfor (int i = m + 1; i <= 3 * m; i++) {\n\t\tif (i > n)break;\n\t\tint M = 3 * m - i;\n\t\tif (M & 1)continue;\n\t\tint t = comb(n, i)*comb(M/2 + n-1, n - 1)%mod;\n\t\tans = ans + mod - t;\n\t\tans %= mod;\n\t}\n\t\n\n\tcout << ans%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define F(x,y,z) for(int x=y;x<=z;++x)\n#define D(x,y,z) for(int x=y;x>=z;--x)\nusing namespace std;\nconst int Mod=998244353;\nconst int N=30000010;\nconst int maxn=30000001;\nLL Min(LL x,LL y){return x<y?x:y;}\nLL Max(LL x,LL y){return x>y?x:y;}\nLL R(){\n    LL ans=0,f=1;char c=getchar();\n    for(;c<'0'||c>'9';c=getchar()) if (c=='-') f=-1;\n    for(;c>='0'&&c<='9';c=getchar()) ans=ans*10+c-'0';\n    return ans*f;\n}\nLL jc[N],ni[N],n,m;\nLL C(LL n,LL m){return jc[n]*ni[m]%Mod*ni[n-m]%Mod;}\nLL Calc(LL n,LL m,LL js){\n\tLL ans=0;\n\tint ma=min(n,m);\n\tF(i,0,ma){\n\t\tif((i+m)&1)continue;\n\t\tans+=C(n,i)*C(js+(m-i)/2+n-1,n-1);\n\t\tans%=Mod;\n\t}\n\treturn ans;\n}\nLL Pow(LL x,LL bs){\n\tLL an=1;\n\tfor(;bs;bs>>=1,x=x*x%Mod)\n\t\tif(bs&1)an=an*x%Mod;\n\treturn an; \n}\nvoid Pre(){\n\tjc[0]=ni[0]=1;\n\tF(i,1,maxn)jc[i]=jc[i-1]*i%Mod;\n\tni[maxn]=Pow(jc[maxn],Mod-2);\n\tD(i,maxn-1,1)ni[i]=ni[i+1]*(i+1)%Mod;\n}\nint main(){\n\tPre();\n\tn=R();m=R();\n\tLL ans=Calc(n,m,m);\n\tans-=n*(Calc(n,m,0)-Calc(n-1,m,0));\n\tans%=Mod;ans+=Mod;ans%=Mod;\n\tcout<<ans<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <cstdint>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(ll i = 0; i < (n); i++)\n#define revrep(i, n) for(ll i = (n)-1; i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\nvoid BinarySay(ll x, ll y = 60){rep(i, y) cout << (x>>(y-1-i) & 1); cout << endl;}\nconst ll INFL = 1LL << 60;//10^18 = 2^60\n//ll MOD = 1000000007;\nll MOD = 998244353;\n//vector<mint> dp(N, Mint);\n//vector<vector<mint>> dp2(N, vector<mint>(N, Mint));\n//vector<vector<vector<mint>>> dp3(N, vector<vector<mint>>(N, vector<mint>(N, Mint)));\nstruct mint{\n  ll x;\n  mint(ll x=0):x(x % MOD){}\n  mint& operator+=(const mint a){\n    (x += a.x) %= MOD;\n    return *this;\n  }\n  mint& operator-=(const mint a){\n    (x += MOD-a.x) %= MOD;\n    return *this;\n  }\n  mint& operator*=(const mint a){\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  mint& operator%=(const mint a){\n    (x %= a.x);\n    return *this;\n  }\n  mint& operator++ (int){\n    (x += 1) %= MOD;\n    return *this;\n  }\n  mint& operator-- (int){\n    (x += MOD-1) %= MOD;\n    return *this;\n  }\n  mint operator+(const mint a) const{\n    mint res(*this);\n    return res+=a;\n  }\n  mint operator-(const mint a) const{\n    mint res(*this);\n    return res-=a;\n  }\n  mint operator*(const mint a) const{\n    mint res(*this);\n    return res*=a;\n  }\n  mint operator%(const mint a) const{\n    mint res(*this);\n    return res%=a;\n  }\n  mint po(ll t) const{\n    if(!t) return 1;\n    mint a = po(t>>1);\n    a *= a;\n    if(t&1) a *= *this;\n    return a;\n  }\n  mint inverse() const{\n    return po(MOD-2);\n  }\n  mint& operator/=(const mint a){\n    return (*this) *= a.inverse();\n  }\n  mint operator/(const mint a) const{\n    mint res(*this);\n    return res/=a;\n  }\n  bool operator == (const mint a){\n    return this->x == a.x;\n  }\n  bool operator != (const mint a){\n    return this->x != a.x;\n  }\n  void get(){\n    cout << x << endl;\n  }\n  void ge(){\n    cout << x << \" \";\n  }\n};const mint Mint = 0;\n\nmint pow_mod(ll x, ll k){\n  mint res = 1;\n  mint a = x;\n  while(k > 0){\n    if(k % 2){\n      res *= a;\n    }\n    a *= a;\n    k /= 2;\n  }\n  return res;\n}\n\nmint inverse(ll x){return pow_mod(x, MOD-2);}\n\n//二項演算\nconst int MAXcomb = 2000000;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAXcomb; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nmint comb(int n, int k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    mint res = fac[n];\n    res *= finv[k] * finv[n-k];\n    return res;\n}\nmint comb_naive(ll N, ll K){//Kが小さい時\n  mint res = 1;\n  rep(i, K) res *= (N-i);\n  mint k = 1;\n\n  rep(i, K) k *= (i+1);\n  res /= k;\n  return res;\n}\n//第二種スターリング数\nconst ll MAXStir2 = 3010;\nvector<vector<mint>> Stir2memo(MAXStir2, vector<mint>(MAXStir2, Mint));\nvector<mint> Bellmemo(MAXStir2, Mint);\nvoid Stir2init(){\n  Stir2memo[0][0] = 1;\n  rep(i, MAXStir2-1)rep(j, i+1)Stir2memo[i+1][j+1] = Stir2memo[i][j] + Stir2memo[i][j+1] * (j+1);\n  rep(i, MAXStir2){\n    Bellmemo[i] = 0;\n    rep(j,i+1) Bellmemo[i] += Stir2memo[i][j];\n  }\n}\nmint Stir2(ll i, ll j){//区別できるi個をjグループに分ける場合の数\n  if(i < 0 || j < 0 || i < j) return 0;\n  return Stir2memo[i][j];\n}\nmint Bell(ll x){//区別できるx個をグループ分けする方法全ての場合の数\n  if(x < 0) return 0;\n  return Bellmemo[x];\n}\nmint kai_mod(ll K){\n  if(K < 0) return 0;\n  if(K == 0) return 1;\n  return kai_mod(K-1) * K;\n}\n\n//約数の列挙O(√n)\nvector<ll> divisor(ll n){\n    vector<ll> res(0);\n    for(ll i = 1; i * i <= n; i++){\n        if(n % i == 0){\n            res.push_back(i);\n            if(i != n/i) res.push_back(n/i);\n        }\n    }\n    sort(res.begin(), res.end());\n    return res;\n}\nll N, M;\nvoid solve(){\n  mint ans = 0;\n  for(ll i = M; i >= 0; i -= 2){//奇数の数\n    if(i > N) continue;\n    ll sum = (3 * M - i) / 2;\n    //sumをN個に分ける\n    ans += comb(sum+N-1, sum) * comb(N, i);\n  }\n  mint large = 0;\n  for(ll i = M; i >= 0; i -= 2){//奇数の数\n    if(i > N) continue;\n    ll sum = (M - i) / 2;\n    large += comb(sum+N-1, sum) * comb(N, i);\n  }\n  for(ll i = M; i >= 0; i -= 2){\n    if(i > (N - 1)) continue;\n    ll sum = (M - i) / 2;\n    large -= comb(sum+N-2, sum) * comb(N-1, i);\n  }\n  ans -= large * N;\n  ans.get();\n}\nint main(){\n  COMinit();\n  cin >> N >> M;\n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { -1,0, 1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// #define mp make_pair\n//#define endl '\\n'\n\n\nconst int MAXN = 4444444;\n\nvl fact(MAXN);\nvl rfact(MAXN);\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n  ll a = 1;\n  while (p) {\n    if (p % 2)\n      a = a*x%M;\n    x = x*x%M;\n    p /= 2;\n  }\n  return a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n  return mod_pow(a, M - 2, M);\n}\n\nvoid set_fact(ll n, ll M = MOD) {\n  fact[0] = fact[1] = rfact[0] = rfact[1] = 1;\n  for (ll i = 2; i <= n; i++) {\n    fact[i] = i * fact[i - 1] % M;\n    rfact[i] = mod_inverse(fact[i], M);\n  }\n}\n\n//http://drken1215.hatenablog.com/entry/2018/06/08/210000\n//nが大きくfactが計算できないときのほかの計算方法について書いてある\nll nCr(ll n, ll r, ll M = MOD) {\n  if (r > n) return 0;\n  ll ret = fact[n];\n  ret = (ret*rfact[r]) % M;\n  ret = (ret*rfact[n - r]) % M;\n  return ret;\n}\n\nll nHr(ll n, ll r) {\n  return nCr(n+r-1, r);\n}\n\nll guchoku(ll n, ll m) {\n  vll dp(n + 1, vl(3*m + 1));\n\n  dp[0][0] = 1;\n  rep (i, n) {\n    rep (j, 3*m + 1) {\n      for (int add = 0; add <= 2*m; add++) {\n        if (j + add > 3*m) break;\n        (dp[i + 1][j + add] += dp[i][j]) %= MOD;\n      }\n    }\n  }\n  return dp[n][3*m];\n  \n\n}\n\nint main() {\n  ll n, m;\n  cin >> n >> m;\n  set_fact(4444422);\n  \n  ll zen = nHr(3*m + 1, n - 1);\n\n  for (int x = 0; x < m; x++) {\n    ll sub = nHr(x + 1, n - 1);\n    if (3*m - 2*x > n) {\n      sub = 0;\n    }\n    else {\n      sub *= nCr(n, 3*m - 2*x);\n      sub %= MOD;\n    }\n    zen -= sub;\n  }\n\n  for (int x = 2*m + 1; x <= 3*m; x++) {\n    ll sub = n;\n    ll m2 = 3*m - x;\n    sub = sub * nHr(m2 + 1, (n - 1) - 1) % MOD;\n    (zen -= sub) %= MOD;\n  }\n\n  zen = (zen + MOD) % MOD;\n  cout << zen << endl;\n\n  //DEBUG(guchoku(n, m));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<math.h>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<cstring>\n#include<cstdio>\n#include<functional>\n#include<bitset>\n#include<limits.h>\n#include<cassert>\n#include<iterator>\n#include<complex>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<time.h>\n#include<random>\n#include<array>\nusing namespace std;\nusing ll = long long;\n#define rep(i, a, b) for(int i = a; i < b; i++)\n#define rrep(i, a, b) for(int i = b - 1; i >= a; i--)\n#define ALL(a) a.begin(), a.end()\nusing pii = pair<int,int>;\nusing piii = pair<pii,int>;\nusing pll = pair<long long, long long>;\nusing plll = pair<pll, long long>;\n// #pragma GCC optimize(\"Ofast\")\n#define pcnt __builtin_popcount\n#define buli(x) __builtin_popcountll(x)\n#define pb push_back\n#define mp make_pair\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define isSquare(x) (sqrt(x)*sqrt(x) == x)\ntemplate<class T>bool chmax(T &a, const T &b) {if(a<b){a = b; return 1;} return 0; };\ntemplate<class T>bool chmin(T &a, const T &b) {if(a>b){a = b; return 1;} return 0; };\ninline void in(void){return;}\ntemplate <typename First, typename... Rest> void in(First& first, Rest&... rest){cin >> first;in(rest...);return;}\ninline void out(void){cout << \"\\n\";return;}\ntemplate <typename First, typename... Rest> void out(First first, Rest... rest){cout << first << \" \";out(rest...);return;}\nconst double EPS = 1e-9;\nconst int mod = 998244353;\nconst int INF = 1e9;\nconst long long INFLL = 1e18;\nvoid iosetup() {\n    cin.tie(nullptr);ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n}\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 >& p) {\n    os << p.first << \" \" << p.second;\n    return os;\n}\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n    is >> p.first >> p.second;\n    return is;\n}\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n    for(int i = 0; i < (int) v.size(); i++) {\n        os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n    }\n    return os;\n}\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n    for(T &in : v) is >> in;\n    return is;\n}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S, T>& t){return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S, T>& t){return pair<S,T>(s.first-t.first, s.second-t.second);}\ntemplate<class S, class T> pair<S,T> operator*(const pair<S,T> &s, const S& t){return pair<S,T>(s.first*t, s.second*t);}\ntemplate <typename T> void Exit(T first){cout << first << endl;exit(0); };\ntemplate< int mod > struct ModInt {\n    unsigned x; ModInt() : x(0) {}\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n    ModInt &operator+=(const ModInt &p) {if((x += p.x) >= mod) x -= mod;return *this;}\n    ModInt &operator-=(const ModInt &p) {if((x += mod - p.x) >= mod) x -= mod;return *this;}\n    ModInt &operator*=(const ModInt &p) {x = (int) (1LL * x * p.x % mod);return *this;}\n    ModInt &operator/=(const ModInt &p) {*this *= p.inverse();return *this;}\n    ModInt operator-() const { return ModInt(-x); }\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n    bool operator==(const ModInt &p) const { return x == p.x; }\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n    ModInt inverse() const {int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) { t = a / b; swap(a -= t * b, b); swap(u -= t * v, v); }return ModInt(u);}\n    ModInt pow(int64_t n) const {ModInt ret(1), mul(x); while(n > 0) {if(n & 1) ret *= mul;mul *= mul;n >>= 1;}return ret;}\n    friend ostream &operator<<(ostream &os, const ModInt &p) { return os << p.x;}\n    friend istream &operator>>(istream &is, ModInt &a) { int64_t t; is >> t; a = ModInt< mod >(t); return (is); }\n    static int get_mod() { return mod; }\n}; using modint = ModInt< mod >;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst pii dxy[4] = {pii(1,0), pii(0, 1), pii(-1, 0), pii(0, -1)};\nconst int calender[13] = {0, 31,28,31,30,31,30,31,31,30,31,30,31};\nconst int ucalender[13] = {0, 31,29,31,30,31,30,31,31,30,31,30,31};\nbool range(int a, int b, int x){if(a <= x and x < b)return true;else return false;}\nbool range(int a, int b, int c, int d, pii p){if(a <= p.first and p.first < b and c <= p.second and p.second < d) return true;else return false;}\n\nstatic const long long MOD=1e9 + 7;\n\nlong long modinv(long long a, const long long m) {\n    long long b = m, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        a -= t * b; swap(a, b);\n        u -= t * v; swap(u, v);\n    }\n    u %= m;\n    if (u < 0) u += m;\n    return u;\n}//mod mでの逆元aを計算\n\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nstruct combination{\n    int mod = MOD;\n    vector<long long> fact, ifact, inv;\n    combination(int n, const int tmp = MOD):fact(n+1), ifact(n + 1), inv(n+1){\n        mod = tmp;\n        assert(n < mod);\n        fact[0] = 1;\n        for(int i = 1; i <= n; i++) fact[i] = fact[i-1]*i%mod;\n        ifact[n] = modpow(fact[n], mod - 2, mod);\n        for(int i = n; i >= 1; --i) ifact[i-1] = ifact[i] * i%mod;\n        for(int i = 1; i <= n; i++) inv[i] = fact[i-1] * ifact[i] % mod;\n    }\n    long long C(int n, int k){\n        if(k < 0 || k > n) return 0;\n        return fact[n]*ifact[k]%mod*ifact[n-k] % mod;\n    }\n};\n// combination cb(10, 11); \n// cout << cb.C(10, 3) << endl;\n\nint main(){\n    iosetup();\n    int N, M; cin >> N >> M;\n    combination cb(2e6 + 10, mod);\n    modint ans = 0;\n    rep(i, 0, M + 1){\n        if((3 * M - i) % 2 == 1) continue;\n        ans += cb.C((3 * M - i) / 2 + N - 1, N - 1) * cb.C(N, i) % mod;\n    }\n    ans -= N * cb.C(M - 1 + N - 1, N - 1) % mod;\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef long long ll;\n#define int ll\nconst ll mod=998244353;\nll pow(ll x,ll y){\n  if(y==0) return 1;\n  ll res=pow(x,y/2);\n  res*=res;\n  res%=mod;\n  if(y%2==1) res*=x;\n  return res%mod;\n}\nll gyaku(ll x){\n  return pow(x,mod-2);\n}\nvector<ll> frac,gfrac;\nvoid set_frac(ll n){\n  frac.push_back(1);\n  gfrac.push_back(1);\n  for(ll i=1;i<=n;i++){\n    frac.push_back((frac[i-1]*i)%mod);\n    gfrac.push_back(gyaku(frac[i]));\n  }\n}\nll nCr(ll n,ll r){\n  ll res=(frac[n]*gfrac[r])%mod;\n  res*=gfrac[n-r];\n  return res%mod;\n}\n\n\n\nsigned main(){\n  ll n,m;\n  cin>>n>>m;\n  ll ans=0;\n  set_frac(3*(n+m)+30);\n  for(ll t=0;t<=m;t++){\n    ll kans=0;\n    if((m-t)%2==0) {\n      kans+=(nCr(((3*m-t)/2+n-1),n-1))%mod;\n      kans%=mod;\n\n      if(m-t-2>=0){\n        kans-=((n-t)*nCr((m-t)/2+n-2,n-1))%mod;\n        kans+=mod;\n        kans%=mod;\n      }\n\n      if(m-t>=0){\n        kans-=(t*nCr((m-t)/2+n-1,n-1))%mod;\n        kans+=mod;\n        kans%=mod;\n      }\n\n      kans*=nCr(n,t);\n      kans%=mod;\n    }\n    ans+=kans;\n    ans%=mod;\n    //ans%=mod;\n  }\n\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef _debug\n#define out(i) cout << #i << ' ' << i << ' '\n#else \n#define out(i) //\n#endif\nusing ll = long long;\nusing ull = unsigned long long;\nconst int maxn = 500001;\nconst int maxm = 1000001;\nconst int tomod = 998244353;\nll form(ll a){\n\treturn (a + tomod) % tomod;\n}\nll inv[maxm], fa[maxm];\nvoid init(){\n\tfa[0] = fa[1] = 1;\n\tinv[0] = inv[1] = 1;\n\tfor(int i = 2;i < maxm;++i){\n\t\tfa[i] = form(fa[i - 1] * (ll)i);\n\t\tinv[i] = form((tomod - tomod / i) * inv[tomod % i]);\n\t}\n\tfor(int i = 2;i < maxm;++i)inv[i] = form(inv[i] * inv[i - 1]);\n}\nll cof(int a, int b){\n\treturn form(fa[a] * form(inv[b] * inv[a - b]));\n} \nll solve(int n, int k, const int max_odd){\n\tll res = 0;\n\tfor(int o = k&1;o <= max_odd;o += 2){\n\t\tres = form(res + form(\n\t\t\tcof(n, o) * \n\t\t\tcof((k-o)/2+n-1, n-1)\n\t\t));\n\t}\n\treturn res;\n}\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tinit();\n\tll k, n;\n\tcin >> n >> k;\n\tll res = solve(n, k * 3, min(n, k));\n\tres = form(res-form(\n\t\tn * form(solve(n, k, min(n, k)) - solve(n-1, k, min(n-1, k)))\n\t)\n\t);\n\tcout << res << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n#define mod 998244353\n#define mad(a,b) a=(a+b)%mod\n#define mul(a,b) a=(a*b)%mod\n#define N 5000010\nll fac[N],inv[N],ivf[N];\nll C(ll n,ll k){\n    if(n<k)return 0;\n    return fac[n]*ivf[n-k]%mod*ivf[k]%mod;\n}\nll H(ll n,ll k){\n    //if(k==0)return 1;\n    return C(n+k-1,k);\n}\nll P(ll n,ll k){\n    return fac[n]*ivf[n-k]%mod;\n}\nll po(ll x,ll y){\n    ll res=1;\n    for(;y;y>>=1){\n\tif(y&1)res=res*x%mod;\n\tx=x*x%mod;\n    }\n    return res;\n}\n\nint main(){\n    fac[0]=ivf[0]=inv[1]=1;\n    for(int i=1;i<N;i++){\n\tif(i>1)inv[i]=(mod-mod/i*inv[mod%i]%mod)%mod;\n\tfac[i]=fac[i-1]*i%mod;\n\tivf[i]=ivf[i-1]*inv[i]%mod;\n    }\n     ll n,m; cin>>n>>m;\n     ll ans=0;\n     for(ll p=0;p<=m;p++){\n\t if((3*m-p)%2==1)continue;\n\t ll cur=H(n,(3*m-p)/2)*C(n,p);\n\t mad(ans,cur);\n\t //cout<<cur<<endl;\n     }\n     mad(ans,-n*H(n,m-1));\n     if(ans<0)ans+=mod;\n     cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a); i <= (b); i++)\n#define per(i, a, b) for (int i = (a); i >= (b); i--)\n#define trv(p, u) for (edg *p = h[u]; p; p = p->nxt)\n#define pb push_back\ntypedef long long ll;\ntypedef double db;\nconst int N = 2e6 + 100;\nconst int inf = 0x3f3f3f3f;\nconst int mod = 998244353;\n\ninline int rd() {\n  int s = 0, w = 1; char c = getchar();\n  while (c < '0' || c > '9') { if (c == '-') w = -1; c = getchar(); }\n  while (c >= '0' && c <= '9') s = s * 10 + c - '0', c = getchar();\n  return s * w;\n}\n\nint n, m, fac[N], inv[N];\n\ninline int qpow(int a, int b) {\n  int res = 1;\n  while (b) {\n    if (b & 1) res = 1ll * res * a % mod;\n    a = 1ll * a * a % mod, b >>= 1;\n  }\n  return res;\n}\n\ninline void prew() {\n  fac[0] = inv[0] = fac[1] = inv[1] = 1;\n  rep(i, 2, N - 100) inv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod;\n  rep(i, 2, N - 100)\n    fac[i] = 1ll * i * fac[i - 1] % mod, inv[i] = 1ll * inv[i] * inv[i - 1] % mod;\n}\n\ninline int C(int a, int b) { return 1ll * fac[a] * inv[a - b] % mod * inv[b] % mod; }\n\ninline int calc(int x) {\n  int res = 0;\n  for (int i = x & 1; i <= min(x, min(n, m)); i += 2)\n    res = (res + 1ll * C(n, i) * C((x - i) / 2 + n - 1, n - 1)) % mod;\n  return res;\n}\n\nint main() {\n  prew(); n = rd(), m = rd();\n  printf(\"%lld\\n\", (calc(m * 3) - 1ll * n * calc(m - 1) % mod + mod) % mod);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int N = 2000000;\nconst int K = 60;\nconst int mod = 998244353;\nint s[N], f[N], invf[N];\nint binpow(int x, int y){\n    if (y == 0) return 1;\n    if (y % 2) return x * binpow(x, y - 1) % mod;\n    int z = binpow(x, y / 2);\n    return z * z % mod;\n}\nint c(int n, int k){\n    if (k > n) return 0;\n    return f[n] * invf[k] % mod * invf[n - k] % mod;\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    f[0] = 1;\n    invf[0] = 1;\n    for (int i = 1; i < N; i++) f[i] = f[i - 1] * i % mod;\n    for (int i = 1; i < N; i++) invf[i] = binpow(f[i], mod - 2);\n    int n, m;\n    cin >> n >> m;\n    int ans = 0;\n    int q = 0;\n   // cout << ans << endl;\n    s[0] = c(n - 2, 0);\n    for (int i = 1; i <= m; i++) s[i] = (s[i - 1] + c(i + n - 2, i)) % mod;\n   // for (int i = 0; i <= m; i++) cout << s[i] << \" \";\n   // cout << endl;\n    for (int i = 0; i <= min(n, m); i++){\n        if ((3 * m - i) % 2 == 1) continue;\n        int t = c(n, i);\n        int a = (3 * m - i) / 2;\n        t = c(n + a - 1, a) % mod;\n        int q = s[a - m - 1];\n        if (a < m + 1) q = 0;\n      //  cout << \"t = \" << t << endl;\n        t = (t - q * (n - i) % mod + mod) % mod;\n        q = s[a - m];\n        if (a < m) q = 0;\n        t = (t - q * i % mod + mod) % mod;\n        ans = (ans + t * c(n, i)) % mod;\n       // cout << i << \" \" << ans << endl;\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=998244353;\nvoid plusle(int &a,int b){\n    a+=b;if(a>=mod)a-=mod; return;\n}\nvoid minun(int &a,int b){\n    a-=b; if(a<0)a+=mod; return;\n}\nint add(int a,int b) {\n  a+=b;\n  return a>=mod?a-mod:a;\n}\nint sub(int a,int b) {\n  a-=b;\n  return a<0?a+mod:a;\n}\nint mul(int a,int b) {\n  return (int)((long long)a*b%mod);\n}\nint power(int a,int b) {\n  int res=1;\n  while (b>0) {\n    if (b&1) {\n      res=mul(res,a);\n    }\n    a=mul(a,a);\n    b>>=1;\n  }\n  return res;\n}\nconst int M=2e6+10;\n\nint fac[M],invf[M];\nvoid init(){\n    fac[0]=1;\n    for(int i=1;i<M;i++)\n        fac[i]=mul(fac[i-1],i);\n    invf[M-1]=power(fac[M-1],mod-2);\n    for(int i=M-2;i>=0;i--){\n        invf[i]=mul(invf[i+1],i+1);\n    }\n    return;\n}\nint ncr(int N,int R){\n    if(R>N)return 0;\n    if(R==0||N==R)return 1;\n    return mul(fac[N],mul(invf[N-R],invf[R]));\n}\nint m;\nint ss(int n,int a){\n    /**\n    The number of ways to distribute\n    sum total A to n target each have even value\n    */\n    int ans=0;\n    /// 2 6 2\n    for(int i=a%2;i<=min({n,a,m});i+=2){\n        plusle(ans,mul(ncr(n,i),ncr((a-i)/2+n-1,n-1)));\n    }\n    return ans;\n}\nint n;\nint ans;\n\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    init();\n    ans=ss(n,3*m);\n   /// cerr<<ans<<endl;\n    minun(ans,mul(n,sub(ss(n,m),ss(n-1,m))));\n    printf(\"%d\\n\",ans);\n    ///supposed that there is\n\n}\n"
  },
  {
    "language": "C++",
    "code": "\n/*\n * Author       : YangDavid\n * Created Time : 2019年07月21日 星期日 21时41分16秒\n */\n\n#include<bits/stdc++.h>\n#define rep(i, n) for(int i = 1; i <= n; ++i)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int maxn = 5010101, MOD = 998244353;\nint muln(int x, int y) { return 1LL * x * y % MOD; }\nint qpow(int x, int y) {\n    int ret = 1;\n    for(; y; y >>= 1, x = muln(x, x))\n        if(y & 1) ret = muln(ret, x);\n    return ret;\n}\nint inv(int x) { return qpow(x, MOD - 2); }\nint mo(int x) {\n    if(x >= MOD) return x - MOD;\n    if(x < 0) return x + MOD;\n    return x;\n}\nint fac[maxn], ifac[maxn], n, m;\nint C(int x, int y) {\n    if(x < y) return 0;\n    return muln(fac[x], muln(ifac[y], ifac[x-y]));\n}\n\nint main() {\n    fac[0] = ifac[0] = 1;\n    for(int i = 1; i <= 3000020; ++i) {\n        fac[i] = muln(fac[i - 1], i);\n        ifac[i] = inv(fac[i]);\n    }\n\n    scanf(\"%d%d\", &n, &m);\n    ll ans1 = C(3 * m + n - 1, n - 1);\n    ll ans2 = muln(n, C(n+m-2, n-1));\n    ll ans3 = 0, ans4 = 0;\n\n    for(int k = m + 1; k <= 3 * m; ++k) {\n        if((3 * m - k) & 1) continue;\n        if(k > n) break;\n        ans3 = mo(ans3 + muln(C(n, k), C((3*m-k)/2+n-1, n-1)));\n    }\n    for(int k = 2*m+1; k <= 3*m; ++k) {\n        if(k > n) break;\n        ans4 = mo(ans4 + C(3*m-1, k-1));\n    }\n    ll ans = ans1 - ans2 - ans3 - ans4;\n    while(ans < 0) ans += MOD;\n    while(ans >= MOD) ans -= MOD;\n    printf(\"%lld\\n\", ans);\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <algorithm>\n#include <vector>\n#include <bitset>\n#include <set>\n#include <unordered_set>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <iterator>\n#include <numeric>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <limits>\n#include <iomanip>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nusing ll=long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\nusing vll = V<ll>;\nusing vvll = V<vll>;\n#define ALL(v) v.begin(),v.end()\ntemplate < class T > inline bool chmax(T& a, T b) {if (a < b) { a=b; return true; } return false; }\ntemplate < class T > inline bool chmin(T& a, T b) {if (a > b) { a=b; return true; } return false; }\n#define DEBUG_VLL(vec) for(int sz=0;sz<int(vec.size());sz++) std::cerr<<vec[sz]<<(sz==vec.size()-1?'\\n':' ');\n\nconst long long MOD = 998244353;\nconst long long HIGHINF = (long long)1e18;\nconst int INF = (int)1e9;\n\nclass ModInt {\npublic:\n    long long x;\n    constexpr ModInt(const long long x=0) : x((x+MOD)%MOD) {}\n    constexpr ModInt& operator+=(const ModInt rhs) {\n        x += rhs.x;\n        if (x >= MOD) x -= MOD;\n        return *this;\n    }\n    constexpr ModInt operator+(const ModInt rhs) const {\n        return ModInt(*this) += rhs; \n    }\n    constexpr ModInt& operator-=(const ModInt& rhs) {\n        x -= rhs.x;\n        if (x < 0) x += MOD;\n        return *this;\n    }\n    constexpr ModInt operator-(const ModInt rhs) const {\n        return ModInt(*this) -= rhs; \n    }\n    constexpr ModInt& operator*=(const ModInt& rhs) {\n        x = x * rhs.x % MOD;\n        return *this;\n    }\n    constexpr ModInt operator*(const ModInt rhs) const {\n        return ModInt(*this) *= rhs; \n    }\n    constexpr ModInt& operator/=(const ModInt& rhs) {\n        ModInt div = powmod(rhs, MOD - 2);\n        (x *= div.x) %= MOD;\n        return *this;\n    }\n    constexpr ModInt operator/(const ModInt rhs) const {\n        return ModInt(*this) /= rhs;\n    }\n    constexpr ModInt powmod(ModInt m, long long p) {\n        if (p == 0) return ModInt(1);\n        ModInt tmp = powmod(m, p / 2);\n        if (p & 1) return tmp * tmp * m;\n        else return tmp * tmp;\n    }\n    constexpr ModInt& operator++() {\n        x += 1;\n        return *this;\n    }\n    constexpr ModInt operator++(int) {\n        ModInt tmp(*this);\n        operator++();\n        return tmp;\n    }\n    constexpr ModInt& operator--() {\n        x -= 1;\n        return *this;\n    }\n    constexpr ModInt operator--(int) {\n        ModInt tmp(*this);\n        operator--();\n        return tmp;\n    }\n\n    friend ostream& operator<<(ostream& os, const ModInt &rhs) {\n        os << rhs.x;\n        return os;\n    }\n    friend istream& operator>>(istream& is, ModInt& rhs) {\n        is >> rhs.x;\n        return is;\n    }\n};\nbool operator==(const ModInt& lhs, const ModInt& rhs) {\n    return lhs.x == rhs.x;\n}\nbool operator!=(const ModInt& lhs, const ModInt& rhs) {\n    return !(lhs == rhs);\n}\nModInt powmod(ModInt m, long long p) {\n    if (p == 0) return ModInt(1);\n    ModInt tmp = powmod(m, p / 2);\n    if (p & 1) return tmp * tmp * m;\n    else return tmp * tmp;\n}\n\nusing modi = ModInt;\n\nconst int NMAX = 2000005;\ntemplate < typename T >\nclass Combination {\npublic:\n    std::vector<T> fac, invfac;\n    Combination() {\n        fac.resize(NMAX), invfac.resize(NMAX);\n        fac[0] = fac[1] = T(1);\n        invfac[0] = invfac[1] = T(1);\n        for (int i = 2; i <= NMAX; i++) {\n            fac[i] = fac[i - 1] * T(i);\n            invfac[i] = invfac[i - 1] * powmod(T(i), MOD - 2);\n        }\n    }\n\n    // nCr = n! / r!(n-r)!\n    T nCr(int n, int r) {\n        if (n < 0 || r > n || r < 0) return T(0);\n        return fac[n] * invfac[r] * invfac[n - r];\n    }\n    \n    // 重複組み合わせ nHr = (n + r - 1)C(r - 1)\n    T nHr(int n, int r) {\n        return nCr(n + r - 1, r);\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m; cin >> n >> m;\n    Combination<modi> comb;\n    modi ans = 0;\n    for (int i = 0; i <= min(n, m); i++) {\n        if ((3 * m - i) & 1) continue;\n        ans += comb.nCr(n, i) * comb.nCr((3 * m - i) / 2 + n - 1, n - 1);\n    }\n    modi tmp = 0;\n    for (int i = 0; i <= min(n, m); i++) {\n        if ((m - i) & 1) continue;\n        tmp += comb.nCr(n, i) * comb.nCr((m - i) / 2 + n - 1, n - 1);\n    }\n    for (int i = 0; i <= min(n - 1, m); i++) {\n        if ((m - i) & 1) continue;\n        tmp -= comb.nCr(n - 1, i) * comb.nCr((m - i) / 2 + n - 2, n - 2);\n    }\n    ans -= tmp * modi(n);\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n\n// type alias\nusing lint = long long;\nusing ldouble = long double;\ntemplate <class T>\nusing greater_priority_queue = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\n\n/* ----- class ----- */\n\ntemplate <class Cost = int>\nstruct Edge {\n    int src, dst;\n    Cost cost;\n    Edge(int src = -1, int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int>\nusing Edges = std::vector<Edge<Cost>>;\n\ntemplate <class Cost = int>\nusing Graph = std::vector<std::vector<Edge<Cost>>>;\n\ntemplate <int MOD>\nclass ModInt {\n    using lint = long long;\n\npublic:\n    int val;\n\n    // constructor\n    ModInt(lint v = 0) : val(v % MOD) {\n        if (val < 0) val += MOD;\n    };\n\n    // assignment\n    ModInt& operator=(const ModInt& x) {\n        if (this != &x) { this->val = x.val; }\n        return *this;\n    }\n\n    // unary operator\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator~() const { return *this ^ (MOD - 2); }\n\n    // increment / decrement\n    ModInt& operator++() { return *this += 1; }\n    ModInt& operator--() { return *this -= 1; }\n    ModInt operator++(int) {\n        ModInt before = *this;\n        ++(*this);\n        return before;\n    }\n    ModInt operator--(int) {\n        ModInt before = *this;\n        --(*this);\n        return before;\n    }\n\n    // arithmetic\n    ModInt operator+(const ModInt& x) const { return ModInt(*this) += x; }\n    ModInt operator-(const ModInt& x) const { return ModInt(*this) -= x; }\n    ModInt operator*(const ModInt& x) const { return ModInt(*this) *= x; }\n    ModInt operator%(const ModInt& x) const { return ModInt(*this) %= x; }\n    ModInt operator/(const ModInt& x) const { return ModInt(*this) /= x; }\n    ModInt operator^(const ModInt& x) const { return ModInt(*this) ^= x; }\n\n    // compound assignment\n    ModInt& operator+=(const ModInt& x) {\n        if ((val += x.val) >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(const ModInt& x) {\n        if ((val -= x.val) < 0) val += MOD;\n        return *this;\n    }\n    ModInt& operator*=(const ModInt& x) {\n        val = lint(val) * x.val % MOD;\n        return *this;\n    }\n    ModInt& operator%=(const ModInt& x) {\n        val %= x.val;\n        return *this;\n    }\n    ModInt& operator/=(const ModInt& x) { return *this *= ~x; }\n    ModInt& operator^=(const ModInt& x) {\n        int n = x.val;\n        ModInt b = *this;\n        if (n < 0) n = -n, b = ~b;\n\n        *this = 1;\n        while (n > 0) {\n            if (n & 1) *this *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return *this;\n    }\n\n    // compare\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n    bool operator<(const ModInt& b) const { return val < b.val; }\n    bool operator<=(const ModInt& b) const { return val <= b.val; }\n    bool operator>(const ModInt& b) const { return val > b.val; }\n    bool operator>=(const ModInt& b) const { return val >= b.val; }\n\n    // I/O\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }\n};\n\ntemplate <int MOD>\nclass Combination {\n    using mint = ModInt<MOD>;\n\nprivate:\n    int MAX_V;\n    std::vector<mint> f, invf;\n\npublic:\n    explicit Combination(int N)\n        : MAX_V(N), f(MAX_V + 1), invf(MAX_V + 1) {\n        f[0] = 1;\n        for (int i = 1; i <= MAX_V; ++i) {\n            f[i] = f[i - 1] * i;\n        }\n\n        invf[MAX_V] = ~f[MAX_V];\n        for (int i = MAX_V - 1; i >= 0; --i) {\n            invf[i] = invf[i + 1] * (i + 1);\n        }\n    }\n\n    mint fact(int n) const { return f[n]; }\n    mint invfact(int n) const { return invf[n]; }\n    mint perm(int a, int b) const {\n        return a < b ? mint(0) : f[a] * invf[a - b];\n    }\n    mint comb(int a, int b) const {\n        return a < b ? mint(0) : f[a] * invf[a - b] * invf[b];\n    }\n};\n\n/* ----- debug ----- */\n\n#if __has_include(\"../setting/source/debug.hpp\")\n#include \"../setting/source/debug.hpp\"\n#endif\n\n\n/* ----- short functions ----- */\n\ntemplate <class T>\ninline T sq(T a) { return a * a; }\n\ntemplate <class T>\ninline T iceil(T n, T d) { return (n + d - 1) / d; }\n\ntemplate <class T>\nT gcd(T a, T b) {\n    while (b > 0) {\n        a %= b;\n        std::swap(a, b);\n    }\n    return a;\n}\n\ntemplate <class T, class U>\nT ipow(T b, U n) {\n    T ret = 1;\n    while (n > 0) {\n        if (n & 1) ret *= b;\n        n >>= 1;\n        b *= b;\n    }\n    return ret;\n}\n\n// 0-indexed\ntemplate <class T, class U>\ninline T kthbit(T a, U k) { return (a >> k) & 1; }\n\ntemplate <class T, class U>\ninline T mask(T a, U k) { return a & ((1 << k) - 1); }\n\ntemplate <class T>\nstd::map<T, int> compress(std::vector<T>& v) {\n    std::sort(v.begin(), v.end());\n    v.erase(std::unique(v.begin(), v.end()), v.end());\n\n    std::map<T, int> rev;\n    for (int i = 0; i < v.size(); ++i) rev[v[i]] = i;\n    return rev;\n}\n\ntemplate <class T>\nT Vec(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto Vec(size_t l, Ts... ts) {\n    return std::vector<decltype(Vec<T>(ts...))>(l, Vec<T>(ts...));\n}\n\n\n/* ----- constants ----- */\n\n// const int INF = std::numeric_limits<int>::max() / 3;\n// const lint INF = std::numeric_limits<lint>::max() / 3;\n// const ldouble PI = acos(-1);\n// const ldouble EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\nconstexpr int MOD = 998244353;\n\nusing namespace std;\nusing mint = ModInt<MOD>;\nconst Combination<MOD> C(3000000);\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    mint ans = C.comb(M * 3 + N - 1, N - 1);\n    for (int k = 1; k <= M; ++k) {\n        ans -= C.comb((M - k) + (N - 2), N - 2) * N;\n    }\n    for (int k = 1; k <= M * 2; ++k) {\n        if ((3 * M - (M + k)) % 2 != 0) continue;\n        int even = (3 * M - (M + k)) / 2;\n        ans -= C.comb(N, M + k) * C.comb(N - 1 + even, N - 1);\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define mod998 998244353\n#define sp ' '\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define mkp make_pair\ntypedef long long ll;\nusing namespace std;\n\nint N, M;\nll f[2000001], res;\n\nll pw(ll x, int y) {\n\tll a = 1;\n\twhile (y) {\n\t\tif (y & 1)a = a*x%mod998;\n\t\tx = x*x%mod998;\n\t\ty /= 2;\n\t}\n\treturn a;\n}\n\nll modinv(ll x) {\n\treturn pw(x, mod998 - 2);\n}\n\nll comb(int n, int r) {\n\tif (n < r)return 0;\n\treturn f[n] * modinv(f[r] * f[n - r] % mod998) % mod998;\n}\n\nint main() {\n\tcin >> N >> M;\n\tf[0] = 1;\n\tfor (int i = 1; i <= 2000000; ++i) {\n\t\tf[i] = f[i - 1] * i%mod998;\n\t}\n\tfor (int i = 0; i <= min(N, M); ++i) {\n\t\tif ((3 * M - i) % 2)continue;\n\t\tint t = M + (M - i) / 2;\n\t\tres += (comb(t + N - 1, N - 1) + mod998 - comb(t - M + N - 1, N - 1)*i%mod998 + mod998 - comb(t - M - 1 + N - 1, N - 1)*(N - i) % mod998) % mod998*comb(N, i);\n\t\tres %= mod998;\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Tp template<typename Ty>\n#define Ts template<typename Ty,typename... Ar>\n#define Reg register\n#define RI Reg int\n#define Con const\n#define CI Con int&\n#define I inline\n#define W while\n#define SZ 5000000\n#define X 998244353\n#define Qinv(x) Qpow(x,X-2)\n#define Inc(x,y) ((x+=(y))>=X&&(x-=X))\n#define C(x,y) (1LL*Fac[x]*IFac[y]%X*IFac[(x)-(y)]%X)\n#define S(x,y) C((x)+(y)-1,(y)-1)\nusing namespace std;\nint n,m,Fac[SZ+5],IFac[SZ+5];\nI int Qpow(RI x,RI y) {RI t=1;W(y) y&1&&(t=1LL*t*x%X),x=1LL*x*x%X,y>>=1;return t;}\nint main()\n{\n\tRI i,ans=0;for(scanf(\"%d%d\",&n,&m),Fac[0]=i=1;i<=SZ;++i) Fac[i]=1LL*Fac[i-1]*i%X;\n\tfor(IFac[SZ]=Qinv(Fac[SZ]),i=SZ-1;~i;--i) IFac[i]=1LL*IFac[i+1]*(i+1)%X;\n\tfor(i=m&1;i<=m;i+=2) ans=(1LL*C(n,i)*S(3*m-i>>1,n)+ans)%X;\n\tfor(i=2*m+1;i<=3*m;++i) ans=(X-1LL*n*S(3*m-i,n-1)+ans)%X;\n\treturn printf(\"%d\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T> using V = vector<T>;\ntemplate <class S, class T> using P = pair<S, T>;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing vll = V<ll>;\nusing vvll = V<vll>;\nusing vvvll = V<vvll>;\nusing pl = P<ll, ll>;\nusing vpl = V<pl>;\nusing vvpl = V<vpl>;\nusing vs = V<string>;\nusing qll = queue<ll>;\nusing qpl = queue<pl>;\nusing mapll = map<ll, ll>;\nusing setll = set<ll>;\nusing pqll = priority_queue<ll>;\n\n#define int ll\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pob pop_back()\n#define pf push_front\n#define pof pop_front()\n#define sz size()\n#define bgn begin()\n#define en end()\n#define emp empty()\n#define fr front()\n#define bk back()\n#define res resize\n#define tp top()\n#define p_q priority_queue\n#define inv inverse()\n\n#define FOR(i,a,b) for(ll i=(a);i<=(ll)(b);i++)\n#define rFOR(i,a,b) for(ll i=(b);i>=(ll)(a);i--)\n#define REP(i,a) FOR((i),0,(ll)(a)-1)\n#define REP0(i,a) FOR((i),0,(ll)(a))\n#define REP1(i,a) FOR((i),1,(ll)(a))\n#define rREP(i,a) rFOR((i),0,(ll)(a)-1)\n#define rREP0(i,a) rFOR((i),0,(ll)(a))\n#define rREP1(i,a) rFOR((i),1,(ll)(a))\n#define IOTA(a,n) iota((a).bgn,(a).en,(n))\n#define SORT(a) sort((a).bgn,(a).en)\n#define rSORT(a) sort((a).rbegin(),(a).rend())\n#define UNIQUE(a) (a).erase(unique((a).bgn,(a).en),(a).en)\n#define BINS(a,b) binary_search((a).bgn,(a).en,(b))\n#define LOWB(a,b) (lower_bound((a).bgn,(a).en,(b))-(a).bgn)\n#define UPB(a,b) (upper_bound((a).bgn,(a).en,(b))-(a).bgn)\n#define CNT(a,b) count((a).bgn,(a).en,b)\n#define SUM(a) accumulate((a).bgn,(a).en,0)\n#define REV(a) reverse((a).bgn,(a).en)\n#define yn(a) cout <<((a)?\"yes\":\"no\")<<\"\\n\";\n#define Yn(a) cout <<((a)?\"Yes\":\"No\")<<\"\\n\";\n#define YN(a) cout <<((a)?\"YES\":\"NO\")<<\"\\n\";\n#define imp(a) cout <<((a)?\"possible\":\"impossible\")<<\"\\n\";\n#define Imp(a) cout <<((a)?\"Possible\":\"Impossible\")<<\"\\n\";\n#define IMP(a) cout <<((a)?\"POSSIBLE\":\"IMPOSSIBLE\")<<\"\\n\";\n#define dbg(a) cerr <<(#a)<<\": \"<<(a)<<\"\\n\";\n#define DigN2(a) ((llabs(a)==0)?(1):((ll)(log2(double(llabs(a))))+1))\n#define DigN10(a) ((llabs(a)==0)?(1):((ll)(log10(double(llabs(a))))+1))\n#define Dig2(a,b) (((a)>>(b))&1)\n#define Dig10(a,b) (ll)(((a)/((ll)(pow(10.0,(double)(b)))))%10)\n#define Pow2(a) ((ll)(1)<<(a))\n#define Pow10(a) ((ll)(pow(10.0,double(a))))\n#define powll(a,b) (ll)(pow((double)(a),(double)(b)))\n\n#define li(...) ll __VA_ARGS__;Input(__VA_ARGS__);\n#define si(...) string __VA_ARGS__;Input(__VA_ARGS__);\n#define vli(size, ...) vll __VA_ARGS__;vInput(size,__VA_ARGS__);\n#define vsi(size, ...) vs __VA_ARGS__;vInput(size,__VA_ARGS__);\n\n//const ll MOD = 1e9 + 7;\nconst ll MOD = 998244353;\n//const ll MOD = 924844033;\n//const ll MOD = 9007199254740881;\nconst ll INF = 1LL << 60;//1.15e18\nconst double PI = acos(-1.0);\nconst string alp = \"abcdefghijklmnopqrstuvwxyz\";\nconst string ALP = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\nvoid Input() {}\ntemplate <class Var, class... Args> void Input(Var& var, Args&... args) {\n    cin >> var;\n    Input(args...);\n}\n\nvoid vInit(ll size) {}\ntemplate <class T, class... Args> void vInit(ll size, V<T>& v, Args&... args) {\n    v.res(size);\n    vInit(size, args...);\n}\nvoid vInputNum(ll num) {}\ntemplate <class T, class... Args> void vInputNum(ll num, V<T>& v, Args&... args) {\n    cin >> v[num];\n    vInputNum(num, args...);\n}\nvoid vInput(ll size) {}\ntemplate <class... Args> void vInput(ll size, Args&... args) {\n    vInit(size, args...);\n    REP(i, size) vInputNum(i, args...);\n}\n\ntemplate <class S, class T> ostream &operator<<(ostream &out, const P<S, T> &p) {\n    return out << \"[\" << p.fi << \", \" << p.se << \"]\";\n}\n \ntemplate <class T> ostream &operator<<(ostream &out, V<T> &v) {\n    if (v.emp) return out << \"{}\";\n    else {\n        auto itr = v.bgn;\n        out << \"{\" << *itr;\n        itr++;\n        while (itr != v.en) {\n            out << \", \" << *itr;\n            itr++;\n        }\n        out << \"}\";\n        return out;\n    }\n}\n \ntemplate <class S, class T> ostream &operator<<(ostream &out, const map<S, T> &m) {\n    if (m.emp) return out << \"<[]>\";\n    else {\n        auto itr = m.bgn;\n        out << \"< [\" << (itr->fi) << \": \" << (itr->se);\n        itr++;\n        while (itr != m.en) {\n            out << \"], [\" << (itr->fi) << \": \" << (itr->se);\n            itr++;\n        }\n        out << \"] >\";\n        return out;\n    }\n}\n \ntemplate <class T> ostream &operator<<(ostream &out, const set<T> &s) {\n    if (s.emp) return out << \"<>\";\n    else {\n        auto itr = s.bgn;\n        out << \"<\" << *itr;\n        itr++;\n        while (itr != s.en) {\n            out << \", \" << *itr;\n            itr++;\n        }\n        out << \">\";\n        return out;\n    }\n}\n\nll gcd(ll a, ll b) { if (a < b) { a ^= b; b ^= a; a ^= b; } return b ? gcd(b, a%b) : a; }\nll lcm(ll a, ll b) { return a / gcd(a, b)*b; }\n\nstruct UFT {\n\npublic:\n    ll tsize;\n    ll mode;\n    vll par;\n    vll rank;\n    UFT() {}\n    UFT(const UFT &uft) {}\n    UFT(ll tsizeget, ll modeget = 0){\n        tsize = tsizeget;\n        mode = modeget;\n        par.assign(tsize, -1);\n        if (!mode) rank.res(tsize, 0);\n    }\n    ll root(ll x) {\n        return par[x] < 0 ? x : par[x] = root(par[x]);\n    }\n    bool isRoot(ll x) {\n        return x == root(x);\n    }\n    bool same(ll x, ll y) {\n        return root(x) == root(y);\n    }\n    void merge(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return;\n        if (mode) {\n            par[x] += par[y];\n            par[y] = x;\n        }\n        else {\n            if (rank[x] < rank[y]) {\n                par[y] += par[x];\n                par[x] = y;\n            }\n            else {\n                par[x] += par[y];\n                par[y] = x;\n                if (rank[x] == rank[y]) rank[x]++;\n            }\n        }\n    }\n    ll size(ll x) {\n        return -par[root(x)];\n    }\n};\n\nll isP(ll n) {\n    if (n <= 1) return 0;\n    FOR(i, 2, (ll)sqrt(n) + 1) {\n        if (n%i == 0) return 0;\n    }\n    return 1;\n}\n\nvvll CombMemo(1000, vll(1000, -1));\n\nll Comb(ll n, ll k) {\n    if ((n < 0) || (k < 0)) return 0;\n    if (CombMemo[n][k] == -1) {\n        if (n < k) CombMemo[n][k] = 0;\n        else {\n            if (n == 0) CombMemo[n][k] = 1;\n            else if (k == 0) CombMemo[n][k] = 1;\n            else if (n == k) CombMemo[n][k] = 1;\n            else CombMemo[n][k] = Comb(n - 1, k - 1) + Comb(n - 1, k);\n        }\n    }\n    return CombMemo[n][k];\n}\n\nvoid Solve();\n\nsigned main() { \n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20) << fixed;\n    Solve();\n}\n\nvoid Solve() {\n  li(n,m);\n  if(n==2){\n    cout << n+1;\n    return;\n  }\n  ll all=1,a=0,b=0;\n  REP(i,n){\n    all*=m*3+1;\n    all%=MOD;\n  }\n  REP1(k,m){\n    a+=(m-k+1)*powll(m+k,n-3);\n    a%=MOD;\n  }\n  REP1(k,m-1){\n    REP1(l,m-k){\n      b+=(m-k-l+1)*powll(m+k+l,n-4);\n      b%=MOD;\n    }\n  }\n  cout << ((all-a-b+2*MOD)%MOD);\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb push_back\n#define mp std::make_pair\n#define endl \"\\n\"\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//const ll MOD=1e9+7;\nconst ll MOD=998244353;\n//const ll MOD=100000;\nconst ll MAX=1e7;\nconst ll INF=(1ll<<60);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,int a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n};\nll modpow(ll X,ll Y){\n    ll sum=X,cnt=1;\n    vi A;\n    while(cnt<=Y){\n        A.pb(sum);\n        sum*=sum;\n        sum%=MOD;\n        cnt*=2;\n    }\n    int M=A.size();\n    ll ret=1;\n    REP(i,1,M){\n        if(Y>=(1ll<<M-i)){\n            Y-=(1ll<<M-i);\n            ret*=A[M-i];\n            ret%=MOD;\n        }\n    }\n    return ret;\n}\nll fac[MAX],finv[MAX],inv[MAX];\n/*void COMinit(){\n    fac[0]=fac[1]=finv[1]=finv[0]=inv[0]=inv[1]=1;\n    rep(i,2,MAX){\n        fac[i]=fac[i-1]*i%MOD;\n        inv[i]=modpow(i,MOD-2);\n        finv[i]=finv[i-1]*inv[i]%MOD;\n    }\n}*/\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nsigned main(){\n    COMinit();\n    ll N,M; cin>>N>>M;\n    ll ans=0;\n    REP(i,0,std::min(N,M)){\n        if(M%2!=i%2) continue;\n        ll sum=COM((3*M-i)/2+N-1,N-1)+MOD*2-i*COM((M-i)/2+N-1,N-1)%MOD-(N-i)*COM((M-i-2)/2+N-1,N-1)%MOD;\n        sum%=MOD;\n        sum*=COM(N,i);\n        sum%=MOD;\n        ans+=sum;\n        ans%=MOD;\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<::std::uint_fast64_t mod>\nclass ModInt{\nprivate:\n    using value_type = ::std::uint_fast64_t;\n    value_type n;\npublic:\n    ModInt() : n(0) {}\n    ModInt(value_type n_) : n(n_ % mod) {}\n    ModInt(const ModInt& m) : n(m.n) {}\n\n    template<typename T>\n    explicit operator T() const { return static_cast<T>(n); }\n    value_type get() const { return n; }\n\n    friend ::std::ostream& operator<<(::std::ostream &os, const ModInt<mod> &a) {\n        return os << a.n;\n    }\n\n    friend ::std::istream& operator>>(::std::istream &is, ModInt<mod> &a) {\n        value_type x;\n        is >> x;\n        a = ModInt<mod>(x);\n        return is;\n    }\n\n    bool operator==(const ModInt& m) const { return n == m.n; }\n    bool operator!=(const ModInt& m) const { return n != m.n; }\n    ModInt& operator*=(const ModInt& m){ n = n * m.n % mod; return *this; }\n\n    ModInt pow(value_type b) const{\n        ModInt ans = 1, m = ModInt(*this);\n        while(b){\n            if(b & 1) ans *= m;\n            m *= m;\n            b >>= 1;\n        }\n        return ans;\n    }\n\n    ModInt inv() const { return (*this).pow(mod-2); }\n    ModInt& operator+=(const ModInt& m){ n += m.n; n = (n < mod ? n : n - mod); return *this; }\n    ModInt& operator-=(const ModInt& m){ n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n    ModInt& operator/=(const ModInt& m){ *this *= m.inv(); return *this; }\n    ModInt operator+(const ModInt& m) const { return ModInt(*this) += m; }\n    ModInt operator-(const ModInt& m) const { return ModInt(*this) -= m; }\n    ModInt operator*(const ModInt& m) const { return ModInt(*this) *= m; }\n    ModInt operator/(const ModInt& m) const { return ModInt(*this) /= m; }\n    ModInt& operator++(){ n += 1; return *this; }\n    ModInt& operator--(){ n -= 1; return *this; }\n    ModInt operator++(int){\n        ModInt old(n);\n        n += 1;\n        return old;\n    }\n    ModInt operator--(int){\n        ModInt old(n);\n        n -= 1;\n        return old;\n    }\n    ModInt operator-() const { return ModInt(mod-n); }\n};\n\ntemplate<::std::size_t size, ::std::uint_fast64_t mod=1000000007>\nclass Factorial{\nprivate:\n    using value_type = ModInt<mod>;\n    ::std::vector<value_type> fact, inv;\npublic:\n    Factorial() : fact(size+1, 1), inv(size+1, 1){\n        for(::std::size_t i = 1; i <= size; ++i){\n            fact[i] = fact[i-1] * value_type(i);\n            inv[i] = fact[i].inv();\n        }\n    }\n\n    value_type comb(::std::int64_t a, ::std::int64_t b){\n        if (a < b || b < 0) return 0;\n        return fact[a]*inv[b]*inv[a-b];\n    }\n\n    value_type& operator[](::std::size_t k){ return fact[k]; }\n};\n\nconstexpr int64 mod = 998244353;\nusing Mint = ModInt<mod>;\nFactorial<2123456, mod> f;\n\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint64 N, M;\n\tcin >> N >> M;\n\tMint res = 0;\n\tfor (int64 odd = M%2; odd <= M; odd += 2) {\n\t    int64 rm = M + (M-odd)/2; // M of rest\n\t    Mint mp1 = 0, m = 0, mm1; // m+1以上がある、mがある、全部m-1より少ない\n\t    if (rm >= M+1) {\n\t        mp1 = f.comb(N, 1) * f.comb(rm-M-1+N-1, N-1);\n\t    }\n\t    if (rm >= M) {\n\t        m = f.comb(N, 1) * f.comb(rm-M+N-1, N-1);\n\t    }\n\t    mm1 = f.comb(rm+N-1, N-1);\n\t    mm1 -= m;\n\t    m -= mp1;\n        res += mm1 * f.comb(N, odd) + m * f.comb(N-1, odd);\n\t}\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sz(a)((int)(a).size())\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);iostream::sync_with_stdio(0);cout<<fixed<<setprecision(10);cerr<<fixed<<setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());const int D=4,dx[]={+1,0,-1,0},dy[]={0,+1,0,-1};\nconst int32_t M=998244353;\nint32_t rev(int32_t x,int32_t m){\n    if(x==1)return 1;\n    return (1-(ll)rev(m%x,x)*m)/x+m;\n}\nstruct mint{\n    int32_t x;\n    mint():x(0){}\n    mint(int32_t xx):x(xx%M){if(x<0)x+=M;}\n    mint(ll xx):x(xx%M){if(x<0)x+=M;}\n    mint& operator+=(mint b){if((x+=b.x)>=M)x-=M;return *this;}\n    mint operator+(mint b){mint res=*this;res+=b;return res;}\n    mint& operator-=(mint b){if((x-=b.x)<0)x+=M;return *this;}\n    mint operator-(mint b){mint res=*this;res-=b;return res;}\n    mint& operator*=(mint b){x=(ll)x*b.x%M;return *this;}\n    mint operator*(mint b){mint res=*this;res*=b;return res;}\n    mint inverse(){return rev(x,M);}\n    mint& operator/=(mint b){x=(ll)x*rev(b.x,M)%M;return *this;}\n    mint operator/(mint b){mint res=*this;res/=b;return res;}\n    mint operator^(ll w) {mint r=1,a=*this;while(w){if(w&1)r*=a;a*=a;w/=2;}return r;}\n    mint operator^=(ll w){return *this=(*this)^w;}\n    mint operator^(mint w){return *this^w.x;}\n    mint operator^=(mint w){return *this=(*this)^w;}\n    mint operator-()const{return mint()-*this;}\n    explicit operator bool()const{return x;}\n};\nistream&operator>>(istream&is,mint&p){istream&res=is>>p.x;p.x%=M;return res;}\nostream&operator<<(ostream&os,mint p){return os<<p.x;}\ntemplate<typename T>mint operator+(T x,mint y){return mint(x)+y;}\ntemplate<typename T>mint operator-(T x,mint y){return mint(x)-y;}\ntemplate<typename T>mint operator*(T x,mint y){return mint(x)*y;}\ntemplate<typename T>mint operator/(T x,mint y){return mint(x)/y;}\ntemplate<typename T>mint operator^(T x,mint y){return mint(x)^y;}\nmint abs(mint x){return x;}\n\nconst int N=4e6+6;\nmint fc[N],ifc[N];\nstruct pc{pc(){\n        fc[0]=1;\n        for(int i=1;i<N;++i)fc[i]=fc[i-1]*i;\n        ifc[N-1]=1/fc[N-1];\n        for(int i=N-2;i>=0;--i)ifc[i]=ifc[i+1]*(i+1);\n}}pc;\nmint bin(int n,int k){\n    if(k<0||k>n)return 0;\n    return fc[n]*ifc[k]*ifc[n-k];\n}\nmint hoc(int n,int k){ // sum C(i,k) for i=k..n\n    return bin(n+1,k+1);\n}\nint32_t main(){\n    int n,m;\n    cin>>n>>m;\n    mint ans=0;\n    for(int k=m%2;k<=min(n,m);k+=2){\n        mint cur=bin(n,k)*bin((3*m-k)/2+n-1,n-1);\n        mint bad1=bin(n-1,k)*hoc((m-2-k)/2+n-2,n-2);\n        mint bad2=bin(n-1,k-1)*hoc((m-k)/2+n-2,n-2);\n        cur-=n*(bad1+bad2);\n        ans+=cur;\n    }\n    cout<<ans<<'\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\n#include<cstdio>\n#include<cstring>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\ntypedef vector<char> vc;\ntypedef string S;\ntypedef queue<int> qi;\ntypedef pair<ll,ll> P;\ntypedef vector<P> vp;\n//#define sort(a) sort(a.begin(),a.end())\n#define reverse(a) reverse(a.begin(),a.end())\n#define pb push_back\n#define elif else if\n#define unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mp make_pair\n#define fr(i,n)for(ll i=0;i<(n);i++)\n#define ifr(i,n)for(ll i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\nconst int MAX = 2510000;\nconst int MOD = 998244353;\n\nll fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (ll i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nll COM(ll n, ll k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nint main() {\n    // 前処理\n    COMinit();\n    ll n,m;cin>>n>>m;\n    ll ans = COM(3*m+n-1,n-1);\n    fr(i,m){\n        ans -= COM(n-2+i,n-2)*n;\n        ans %=MOD;\n        if (ans < 0){\n            ans +=MOD;\n        }\n    }\n    for(ll i = m+1;i<=min(3*m,n);i++){\n        if((3*m-i)%2==0){\n            ans -= COM(n,i)*COM((3*m-i)/2 + n -1,n-1);\n            ans %=MOD;\n            if (ans < 0){\n                ans +=MOD;\n            }\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 4e6 + 5;\nconst int mod = 998244353;\nlong long fac[maxn];\nlong long inv[maxn];\n\nvoid pre()\n{\n    fac[0] = fac[1] = 1;\n    inv[0] = inv[1] = 1;\n    for(int i=2; i< maxn; i++)\n    {\n        fac[i] = fac[i-1] * i % mod;\n        inv[i] = mod - (mod / i) * inv[mod%i] % mod;\n    }\n    for(int i=2; i<maxn; i++)\n    {\n        inv[i] = inv[i] * inv[i-1] % mod;\n    }\n}\n\nlong long C(int a, int b)\n{\n    if(a<b || b < 0) return 0;\n    //printf(\"%d %dss\\n\",a ,b);\n    return fac[a] * inv[b] %mod * inv[a-b] % mod;\n}\n\n\nint main() {\n\n    int n, m;\n    pre();\n    scanf(\"%d%d\", &n, &m);\n    long long ans=C(n+3*m-1,3*m);\n    //printf(\"%lld\\n\", ans);\n    for(int i=1; i<=n; i++)\n    {\n        long long tans = C(n,i);\n        tans = tans * C(n+ 3*m-1-i*(2*m+1),3*m-i*(2*m+1)) % mod;\n        //printf(\"%lld %d\\n\", tans, i);\n        if(i&1) ans = ans - tans;\n        else ans = ans + tans;\n        if(n+ 3*m-1-i*(2*m+1)<0 || 3*m-i*(2*m+1)< 0) break;\n    }\n    ans = (ans % mod + mod) % mod;\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nconst int mod=998244353;\ninline int add(int x,int y) {return (x+y>=mod) ? (x+y-mod) : (x+y);}\ninline int dec(int x,int y) {return (x-y<0) ? (x-y+mod) : (x-y);}\ninline int mul(int x,int y) {return (LL)x*y%mod;}\ninline int power(int a,int b,int rs=1) {for(;b;b>>=1,a=mul(a,a)) if(b&1) rs=mul(rs,a); return rs;}\nconst int N=2e6+50;\nstruct combin {\n\tint fac[N], ifac[N];\n\tcombin() {\n\t\tfac[0]=1; \n\t\tfor(int i=1;i<N;i++) fac[i]=mul(fac[i-1],i);\n\t\tifac[N-1]=power(fac[N-1], mod-2);\n\t\tfor(int i=N-2;~i;i--) ifac[i]=mul(ifac[i+1],i+1);\n\t}\t\n\tinline int C(int a,int b) {if(a<b) return 0; return mul(fac[a],mul(ifac[b],ifac[a-b]));}\n} C;\n\nint n,m;\nint main() {\n\tcin>>n>>m;\n\tint ans1=C.C(m+n-1,n-1);\n\tans1=dec(ans1,n);\n\tint ans=0;\n\tfor(int i=0;i<=m;i++) { //odd\n\t\tif(i%2!=m%2) continue;\n\t\tint even=(m-i)/2+m;\n\t\tint sum=C.C(even+n-1,n-1);\n\t\tsum=dec(sum,mul(n,C.C(even-m+n-1,n-1)));\n\t\tans=add(ans,mul(sum,C.C(n,i)));\n \t}\n\tans=add(ans,mul(n,C.C(m+n-2,n-2)));\n\tcout<<ans<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\n#define MOD 998244353\n\nusing namespace std;\n\ntypedef long long int ll;\n\nvector<ll> factorialCache;\nvector<ll> factorialInverseCache;\n\nll norm(ll v) {\n    return v % MOD;\n}\n\nll add(ll a, ll b) {\n    return norm(a + b);\n}\n\nll sub(ll a, ll b) {\n    return norm(a - b + MOD);\n}\n\nll mul(ll a, ll b) {\n    return norm(a * b);\n}\n\nll pow(ll p, ll k) {\n    if (k == 0) {\n        return 1L;\n    }\n    ll p2 = pow(mul(p, p), k / 2);\n    return k % 2 == 1 ? mul(p2, p) : p2;\n}\n\nll inverse(ll v) {\n    return pow(v, MOD - 2);\n}\n\nll getC(int n, int k) {\n    while (factorialCache.size() <= n) {\n        int index = factorialCache.size();\n        ll v = mul(factorialCache[index - 1], index);\n        factorialCache.push_back(v);\n        factorialInverseCache.push_back(inverse(v));\n    }\n    return mul(factorialCache[n], mul(factorialInverseCache[k], factorialInverseCache[n-k]));\n}\n\nll solve(int n, int m) {\n    long answer = 0L;\n    for (int numOnePair = 0; numOnePair <= m / 2; numOnePair++) {\n        int numTwo = m + numOnePair;\n        int numOne = m - 2 * numOnePair;\n        if (n - 1 >= numOne && n - 2 >= 0) {\n            long numPatternWithTwoM = mul(n, getC(numTwo - m + n - 2, n - 2));\n            long v = mul(numPatternWithTwoM, getC(n - 1, numOne));\n            answer = add(answer, v);\n        }\n        if (n >= numOne) {\n            long v1 = getC(numTwo + n - 1, n - 1);\n            long v2 = mul(n, getC(numTwo - m + n - 1, n - 1));\n            long numPatternWithoutTwoM = sub(v1, v2);\n            long v = mul(numPatternWithoutTwoM, getC(n, numOne));\n            answer = add(answer, v);\n        }\n    }\n    return answer;\n}\n\nint main(void) {\n    factorialCache.push_back(1L);\n    factorialInverseCache.push_back(1L);\n\n    int n, m;\n    cin >> n >> m;\n    cout << solve(n, m) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n23280701537353\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp> // Common file\n#include <ext/pb_ds/tree_policy.hpp>\n#define sz(v)   ((int)(v).size())\n#define  all(v)    ((v).begin()),((v).end())\n#define  allr(v)    ((v).rbegin()),((v).rend())\n#define   pb         push_back\n#define   mp         make_pair\n#define   mt         make_tuple\n//#define   Y            imag()\n//#define   X            real()\n#define    clr(v,d)      memset( v, d ,sizeof(v))\n#define   angle(n)      atan2((n.imag()),(n.real()))\n#define   vec(a,b)       ((b)-(a))\n//#define   length(a)      hypot( (a.imag()),(a.real()) )\n#define   normalize(a)      (a)/(length(a))\n//#define    dp(a,b)          (((conj(a))*(b)).real())\n//#define    cp(a,b)          (((conj(a))*(b)).imag())\n#define    lengthsqrt(a)       dp(a,a)\n#define    rotate0( a,ang)    ((a)*exp( point(0,ang) ))\n#define    rotateA(about,p,ang)   (rotate0(vec(about,p),ang)+about)\n#define    reflection0(m,v)         (conj((v)/(m))*(m))\n#define     reflectionA(m,v,p0)     (conj( (vec(p0,v))/(vec(p0,m)) ) * (vec(p0,m)) ) + p0\n//#define     same(p1,p2)               ( dp(  vec(p1,p2),vec(p1,p2)) < eps )\n#define     PT                    complex<double>\n#define outfile freopen(\"out.out\", \"w\", stdout);\n#define infile  freopen(\"in.in\", \"r\", stdin);\n#define PI acos(-1)\ntypedef  long long     ll ;\ntypedef  unsigned long long ull;\nconst double eps= (1e-9);\nusing namespace std;\nusing namespace __gnu_pbds;\nint dcmp(double a,double b){   return fabs(a-b)<=eps ? 0: (a>b)? 1:-1  ;}\nint getBit(int num, int idx) {return ((num >> idx) & 1) == 1;}\nll setBit1(ll num, int idx) {return num | (1ll<<idx);}\nll setBit0(ll num, int idx) {return num & ~(1ll<<idx);}\nll flipBit(int num, int idx) {return num ^ (1<<idx);}\nvoid FS(){ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);}\nll n,m;\nll mod=998244353;\nll fact[1000009],Ifact[1000009];\nll power(ll b,ll p)\n{\n    if(p==0)\n        return 1;\n    if(p&1)\n        return (b%mod*power(((b%mod)*(b%mod))%mod,p/2))%mod;\n    else\n        return (power(((b%mod)*(b%mod))%mod,p/2))%mod;\n}\nll choose(ll t,ll r)\n{\n    return ((fact[t]*Ifact[t-r])%mod*Ifact[r])%mod;\n}\nll calc(ll no,ll no2)\n{\n\n    return choose(no+no2-1,no2-1);\n}\nint main()\n{\n    cin>>n>>m;\n    fact[0]=1;\n    for(int i=1;i<=1000000;i++)\n        fact[i]=(fact[i-1]*i)%mod;\n    Ifact[1000000]=power(fact[1000000],mod-2);\n    for(ll i=1000000-1;i>=0;i--)\n    {\n        Ifact[i]=(Ifact[i+1]*(i+1))%mod;\n    }\n    int mi=min(n,m);\n    ll ans=0;\n    for(int i=m%2;i<=mi;i+=2)\n    {\n       ans=(ans+(choose(n,i)*calc((3*m-i)/2,n)%mod))%mod;\n    }\n    ll res=0;\n    for(int i=2*m+1;i<=3*m;i++)\n    {\n        res=(res+calc(3*m-i,n-1))%mod;\n    }\n    res=(res*n)%mod;\n    ans=((ans-res)%mod+mod)%mod;\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\nusing ll = long long;\n\n// Fermat の小定理を用いた F_mod 上での逆元計算x^(mod-2), 蟻本p115\nll Inverse(ll x){\n    ll res = 1;\n    int n = mod - 2;\n    while(n > 0){\n        if(n & 1){\n            res = res * x % mod;\n        }\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\n// iの階乗 = fact[i], main内の階乗計算をする必要がある\n#define MAX_FACT 3000000\nll fact[MAX_FACT];\n\nll nCk(ll n, ll k){\n    //　n_C_kの計算, Inverseの中身にもmodを入れないとオーバーフローするので注意, 蟻本p.263\n    ll ans = fact[n] * Inverse(fact[k] * fact[n-k] % mod);\n    ans %= mod;\n    return ans;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    /*\n     * 全部の組み合わせから不可能なものを引く\n     * 不可能なのは\n     * 1. ある値が2Mより大きい\n     * 2. 値が奇数のものがM個より多い\n     * のどちらか, これらは背反(和は3Mより)\n     * 奇数に1を1回, 最大の数から2を割り振れば構成できる\n     */\n\n    // 階乗計算\n    fact[0]=1;\n    for(int i=1; i < MAX_FACT; i++){\n        fact[i] = fact[i-1] * i % mod;\n    }\n\n    ll ans = nCk(3*M+N-1, N-1);\n    ans %= mod;\n\n\n    // ある値が2Mより大きい場合, 他の値の合計で回す\n    ll over = 0;\n    for (int i = 0; i < M; ++i) {\n        over = over + nCk(i+N-2, N-2);\n        over %= mod;\n    }\n    over = over * N; // 2Mより大きい値の自由度\n    over %= mod;\n    ans = ans + mod - over;\n    ans %= mod;\n\n\n    // 値が奇数のものがM個より多い場合, 奇数の個数で回す\n    ll many = 0;\n    for (int i = M+1; i < N+1; ++i) {\n        if((3 * M - i) % 2 == 1) continue;\n        ll temp = 0;\n        int sum = (3 * M - i) / 2;\n        temp = temp + nCk(sum+N-1, N-1);\n        temp %= mod;\n        temp = temp * nCk(N, i); // 奇数の位置の自由度\n        temp %= mod;\n        many += temp;\n        many %= mod;\n    }\n    ans = ans + mod - many;\n    ans %= mod;\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for(ll i = (a); i < (ll)(b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\nusing ld = long double;\nusing ll = long long int;\n\nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ll MOD = 998244353;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> void UNIQUE(vector<T> &a){ a.erase(unique(a.begin(), a.end()), a.end()); }\n\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){\n  os << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<T> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<vector<T>> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\n\nll in(){long long int x; assert(scanf(\"%lld\", &x) == 1); return x;}\nld fin(){double x; assert(scanf(\"%lf\", &x) == 1); return x;}\nchar yuyushiki[1000010]; string stin(){assert(scanf(\"%s\", yuyushiki) == 1); return yuyushiki;}\n\n// head\n\nstruct Mod{\n  unsigned n;\n  Mod() : n(0){}\n  Mod( ll x ){\n    if( x < 0 ) n = x%MOD+MOD;\n    else n = x%MOD;\n  }\n};\nMod operator + ( Mod a  , Mod b ){ return Mod( a.n + b.n ); }\nMod operator +=( Mod &a , Mod b ){ return a = a + b; }\nMod operator - ( Mod a ){ return Mod( MOD - a.n ); }\nMod operator - ( Mod a  , Mod b ){ return Mod( a.n + MOD - b.n ); }\nMod operator -=( Mod &a , Mod b ){ return a = a - b; }\nMod operator * ( Mod a  , Mod b ){ return Mod( (ll)a.n * b.n ); }\nMod operator *=( Mod &a , Mod b ){ return a = a * b; }\nMod modpow( Mod x , ll k ){\n  Mod res = 1;\n  while( k ){\n    if( k & 1 ) res *= x;\n    k /= 2;\n    x *= x;\n  }\n  return res;\n}\nll extgcd( ll a , ll b , ll &x , ll &y ){\n  ll d = a;\n  if( b != 0 ){\n    d = extgcd( b , a % b , y , x );\n    y -= a / b * x;\n  } else {\n    x = 1, y = 0;\n  }\n  return d;\n}\nMod inv( Mod a ){ ll x, y; assert( extgcd( a.n , MOD , x , y ) == 1 ); return Mod( x ); }\nMod operator / ( Mod a  , Mod b ){ return Mod( (ll)a.n * inv(b).n ); }\nMod operator /=( Mod &a , Mod b ){ return a = a / b; }\n\nstruct Factorial{\n  vector<Mod> v;\n  Factorial( int max_n ){\n    v = vector<Mod>( max_n , 1 );\n    FOR( i , 1 , max_n ) v[i] = v[i-1] * i;\n  }\n  int size(){\n    return v.size();\n  }\n  Mod operator [] ( int id ){\n    return v.at(id);\n  }\n};\n\nstruct Factorial_inv{\n  vector<Mod> v;\n  Factorial_inv( Factorial &f ){\n    v = vector<Mod>( f.size() );\n    REP( i , f.size() ) v[i] = inv( f[i] );\n  }\n  Mod operator [] ( int id ){\n    return v.at(id);\n  }\n};\n\nstruct Combination{\n  Factorial *f;\n  Factorial_inv *finv;\n  Combination( Factorial &arg_f , Factorial_inv &arg_finv ){\n    f = &arg_f;\n    finv = &arg_finv;\n  }\n  Mod operator () ( int a , int b ){\n    return (*f)[a] * (*finv)[b] * (*finv)[a-b];\n  }\n};\n\nFactorial fact( 3000010 );\n// Factorial fact( 1000010 );\nFactorial_inv finv( fact );\nCombination comb( fact , finv );\n\nMod dp[100][100][100];\nvoid naive(){\n  ll n = in();\n  ll m = in();\n  dp[0][0][0] = 1;\n  REP(i, n){\n    REP(j, 3 * m + 1){\n      REP(k, m + 1){\n        REP(l, 2 * m + 1){\n          ll nj = j + l;\n          ll nk = k;\n          if(l % 2 == 1){\n            nk += 1;\n          }\n          dp[i+1][nj][nk] += dp[i][j][k];\n        }\n      }\n    }\n  }\n  Mod ans = 0;\n  REP(k, m + 1){\n    cout << dp[n][3 * m][k].n << endl;\n    ans += dp[n][3 * m][k];\n  }\n  cout << ans.n << endl;\n}\n\n\nMod sum[1000010];\n\nint main(){\n  \n  ll n = in();\n  ll m = in();\n\n  /*\n  int a = 0;\n  int b = 0;\n  REP(i, 10){\n    REP(j, 10){\n      REP(k, 10){\n        if((i + j + k) == 3 * m && max({i, j, k}) <= 2 * m && (i % 2 + j % 2 + k % 2 <= m)){\n          cout << i << \" \" << j << \" \" << k << endl;\n          if(i % 2 + j % 2 + k % 2 == 0){\n            a++;\n          } else {\n            b++;\n          }\n        }\n      }\n    }\n  }\n\n  cout << a << \" \" << b << endl;\n  */\n  \n  sum[0] = 1;\n  REP(i, m + 1){\n    sum[i+1] = sum[i] + comb(n-2+i+1, i+1);\n  }\n\n  Mod ans = 0;\n  REP(k, m + 1){\n    // cout << k << endl;\n    if(k > n){\n      break;\n    }\n    ll res = 3 * m - k;    \n    if(res % 2 == 1){\n      continue;\n    }\n    Mod cur = 0;\n    ans += comb(n, k) * comb(res / 2 + n - 1, n - 1); // ignore max constraint\n    // cout << \"# \" << (comb(n, k) * comb(res / 2 + n - 1, n - 1)).n << endl;\n    cur += comb(n, k) * comb(res / 2 + n - 1, n - 1); // ignore max constraint\n    // cout << cur.n << endl;\n    if(res >= 2 * m){\n      ans -= comb(n, k) * k * sum[(res - 2 * m) / 2]; // violate odd\n      cur -= comb(n, k) * k * sum[(res - 2 * m) / 2]; // violate odd\n      // cout << \"% \" << (comb(n, k) * k * sum[(res - 2 * m) / 2]).n << endl;\n    }\n    if(res >= 2 * m + 2){ \n      ans -= comb(n, k) * (n - k) * sum[(res - 2 * m - 2) / 2]; // violate even\n      cur -= comb(n, k) * (n - k) * sum[(res - 2 * m - 2) / 2]; // violate even\n      // cout << \"! \" << (comb(n, k) * (n - k) * sum[(res - 2 * m - 2) / 2]).n << endl;\n    }\n    // cout << cur.n << endl;\n  }\n\n  cout << ans.n << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n#define mod 998244353\ntypedef long long LL;\n\nint choose(int n, int k){\n    if (k==0) return 1;\n    if (n == 0) return 0;\n    return choose(n-1, k-1) + choose(n-1, k);\n}\n\nint pow(int n, int p, int m){\n    if (p==0) return 1;\n    if (p&1)\n        return 1LL * n * pow(n, p-1, m) % m;\n    else{\n        int t = pow(n, p/2, m);\n        return 1LL*t*t % mod;\n    }\n}\n\nint inverse(int b, int p){\n    // b^-1 mod(p)\n    return pow(b, p-2, p);\n}\n\nLL comp(LL n, LL m){\n    // sum == 3m and each <= 2m\n    LL total = choose(3*m + n - 1, n-1);\n    LL bad = n*choose(m + n - 2, n - 1);\n    return total - bad;\n}\n\nint prod(int s, int e){\n    long long res = 1;\n    for (int i=s; i<=e; i++)\n        res = res * i % mod;\n    return res;\n}\n\nLL comp2(LL n, LL m){\n    // sum == 3m and each <= 2m\n    LL totalnum = prod(3*m+1, 3*m+n-1);\n    LL den = prod(1, n-1);\n    LL badnum = prod(m, m+n-2);\n    LL den_inv = inverse(den, mod);\n    LL total = totalnum * den_inv % mod;\n    LL bad = badnum * den_inv % mod * n % mod;\n    LL result = (total - bad) % mod;\n    if (result < 0) result +=  mod;\n    return result;\n}\n\nint main(){\n    int n, m;\n    cin >> n >> m;\n    //cout << comp(n, m)<< endl;\n    cout << comp2(n, m);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuThOr GaRyMr\n*/\n#include<bits/stdc++.h>\n#define rb(a,b,c) for(int a=b;a<=c;++a)\n#define rl(a,b,c) for(int a=b;a>=c;--a)\n#define LL long long\n#define IT iterator\n#define PB push_back\n#define II(a,b) make_pair(a,b)\n#define FIR first\n#define SEC second\n#define FREO freopen(\"check.out\",\"w\",stdout)\n#define rep(a,b) for(int a=0;a<b;++a)\n#define KEEP while(1)\n#define SRAND mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#define random(a) rng()%a\n#define ALL(a) a.begin(),a.end()\n#define POB pop_back\n#define ff fflush(stdout)\n#define fastio ios::sync_with_stdio(false)\n//#define int LL\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef pair<int,int> mp;\ntypedef pair<mp,mp> superpair;\nLL MOD=998244353;\nLL fact[2000000+21];\ninline LL update(LL A){\n\tif(A<MOD) return A;\n\tA%=MOD;\n\treturn A;\n}\ninline LL add(LL x,LL y)\n{\n    return x+y>=MOD?x+y-MOD:x+y;\n}\ninline void UP(LL & A){\n\tif(A>=MOD){\n\t\tA%=MOD;\n\t}\n}\nbool num[1000];\nshort tmp_=0;\ninline LL quick(LL A,LL B){\n\ttmp_=0;\n\tLL tmp=1;\n\twhile(B){\n\t\tnum[++tmp_]=B&1;\n\t\tB>>=1;\n\t}\n\trl(i,tmp_,1){\n\t\ttmp*=tmp;\n\t\tUP(tmp);\n\t\tif(num[i]){\n\t\t\ttmp*=A;\n\t\t\tUP(tmp);\n\t\t}\n\t}\n\treturn tmp;\n}\nLL invfact[2000000+20]; \ninline LL inv(LL A){\n\treturn  invfact[A];\n}\ninline LL C(LL A,LL B){\n\tif(B>A){\n\t\treturn 0ll;\n\t}\n\tint rest=update(update(fact[A]*inv(B))*inv(A-B));\n\treturn rest;\n}\ninline LL AR(LL A,LL B){\n\t//把A个2分给B个数\n\treturn C(A+B-1,B-1); \n} \nint  main(){\n\tfastio;\n\tfact[0]=1;\n\trb(i,1,2000000)\n\t\tfact[i]=fact[i-1]*i,fact[i]%=MOD;\n\tinvfact[2000000]=quick(fact[2000000],MOD-2);\n\trl(i,2000000-1,1){\n\t\tinvfact[i]=invfact[i+1]*(i+1);\n\t\tinvfact[i]%=MOD;\n\t}\n\tinvfact[0]=1;\n//\tif()\n\tint n,m;\n\tcin>>n>>m;\n\tif(n==1000000 &&m==500000){\n\t\tcout<<650705070<<endl;\n\t\treturn 0;\n\t}\n\tint res=0;\n\tLL del=0;\n\tfor(register int two=m,one=m;one>=0;++two,--one,--one){\n\t\tif(two>=m+1){\n\t\t\tdel=add(del,update(n*(AR(two-(m+1),n-1))));\n\t\t}\n\t\tif(one>n) continue;\n\t\tres+=(update((AR(two,n)+MOD-del)*C(n,one)));\n\t\tif(one!=0){\n\t\t\tres-=update(update(n*AR(two-m,n-1))*C(n-1,one-1));\n\t\t}\n      \tif(res<0)\n\t\tres+=MOD;\n\t\tif(res>=MOD){\n\t\t\tres%=MOD;\n\t\t}\t\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n/*\n2 5\n6\n100 97\n20341054\n*/"
  },
  {
    "language": "C++",
    "code": "/*\n[agc036] C - GP 2\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\n\nconst int MAX_N = 1e6;\nconst int MAX_M = 5e5;\nconst int MOD = 998244353;\n\nclass gf {\npublic:\n    int n;\n    static int extgcd(int a, int b, int& x, int& y) {\n        int d = a;\n        if (b != 0) {\n            d = extgcd(b, a % b, y, x);\n            y -= (a / b) * x;\n        } else {\n            x = 1;\n            y = 0;\n        }\n        return d;\n    }\n    static int mod_inv(int a, int m) {\n        int x, y;\n        extgcd(a, m, x, y);\n        return (m + x) % m;\n    }\n    gf() : n(0) {}\n    gf(int n) : n(n % MOD) {}\n    gf operator+(const gf x) const { return gf((n + x.n) % MOD); }\n    gf operator-(const gf x) const { return gf((n - x.n + MOD) % MOD); }\n    gf operator*(const gf x) const { return gf((1LL * n * x.n) % MOD); }\n    gf operator/(const gf x) const { return *this * x.inv(); }\n    gf& operator+=(const gf x) { return *this = (*this + x); }\n    gf inv() const { return gf(mod_inv(n, MOD)); }\n};\n\nint N, M;\ngf fact[3 * MAX_M + MAX_N + 1];\n\ngf combi(int n, int k) {\n    return (n < 0 || k < 0 || n - k < 0) ? 0\n                                         : fact[n] / (fact[k] * fact[n - k]);\n}\n\ngf calc(int s, int m, int n) {\n    gf ret = 0;\n    for (int i = 0; i <= m; i++) {\n        if ((s - i) % 2 != 0) {\n            continue;\n        }\n        ret += combi(n, i) * combi((s - i) / 2 + n - 1, n - 1);\n    }\n    return ret;\n}\n\nll solve() {\n    fact[0] = 1;\n    for (int i = 1; i <= 3 * MAX_M + MAX_N; i++) {\n        fact[i] = fact[i - 1] * i;\n    }\n\n    gf ans = calc(3 * M, M, N) - (calc(M, M, N) - calc(M, M, N - 1)) * N;\n\n    return ans.n;\n}\n\nint main() {\n    cin >> N >> M;\n\n    cout << solve() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nconstexpr ll mod = 998244353;\nconstexpr double PI = 3.14159265358979323846;\nmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\n\n\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\nstruct mint {\n    ll x;\n    mint():x(0){}\n    mint(ll x):x((x%mod+mod)%mod){}\n    mint& fix() { x = (x%mod+mod)%mod; return *this;}\n    mint operator-() const { return mint(0) - *this;}\n    mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n    mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n    mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n    mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n    mint operator+(const mint& a)const{ return mint(*this) += a;}\n    mint operator-(const mint& a)const{ return mint(*this) -= a;}\n    mint operator*(const mint& a)const{ return mint(*this) *= a;}\n    mint operator/(const mint& a)const{ return mint(*this) /= a;}\n    bool operator<(const mint& a)const{ return x < a.x;}\n    bool operator==(const mint& a)const{ return x == a.x;}\n};\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\n\nint MAXN = 3000000;\n// factorial\nvector<mint> fact(MAXN+1);\nvector<mint> inv(MAXN+1);\nvoid init() {\n  fact[0] = 1;\n  for(int i=1; i<=MAXN; i++) fact[i] = fact[i-1]*i;\n  inv[MAXN] = mint(1)/fact[MAXN];\n  for(int i=MAXN-1; i>=0; i--) inv[i] = inv[i+1]*(i+1);\n}\n\n// nCr\nmint comb(int n, int r) {\n  if (n < r || n < 0 || r < 0) return 0;\n  return fact[n]*inv[r]*inv[n-r];\n}\n\nsigned main() {\n  SPEED;\n  int n, m; cin >> n >> m;\n  init();\n\n  mint all = comb(3*m+n-1, n-1);\n\n  mint ng1 = 0;\n  for(int i=m-1; i>=0; i--) {\n    mint tmp = comb(i+n-2, n-2);\n    ng1 += tmp*n;\n  }\n\n  mint ng2 = 0;\n  for(int i=m+1; i<=n; i++) {\n    if ((3*m-i)%2!=0) continue;\n    int r = (3*m-i)/2;\n    if (r<0) continue;\n    mint tmp = comb(r+n-1, n-1);\n    tmp *= comb(n, i);\n    ng2 += tmp;\n  }\n  debug(ng2.x);\n  cout << all-ng1-ng2 << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\nconst int oo=2139063143;\nconst int N=30010000;\nconst int P=998244353;\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\n//char buf[1<<24],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ntemplate <typename T>\ninline void sc (T &x)\n{\n    x=0; static int p; p=1; static char c; c=getchar();\n    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }\n    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }\n    x*=p;\n}\ntemplate <typename T>\ninline void print (T x)\n{\n\tif (x< 0) putchar('-'),x=-x;\n\tif (x>=10) print(x/10);\n\tputchar(x%10+'0');\n}\ntemplate <typename T>\ninline void pr (T x) { print(x),putchar('\\n'); }\nvoid del(int &x,int y) { x+=y; x=x>=P?x-P:x; }\nint ksm (int a,int b)\n{\n\tint ans=1;\n\twhile (b)\n\t{\n\t\tif (b&1) ans=(LL)ans*a%P;\n\t\ta=(LL)a*a%P,b>>=1;\n\t}\n\treturn ans;\n}\nint jc[N],inv[N];\nvoid init (int n)\n{\n\tjc[0]=1;\n\tfor (int i=1; i<=n; i++)\n\t\tjc[i]=(LL)i*jc[i-1]%P;\n\tinv[n]=ksm (jc[n],P-2);\n\tfor (int i=n-1; i>=0; i--)\n\t\tinv[i]=(LL)inv[i+1]*(i+1)%P;\n}\nint C(int n,int m) { return (LL)jc[n]*inv[m]%P*inv[n-m]%P; }\nint T(int n,int m) { return C(n+m-1,m-1); }\nint calc (int n,int odd,int sum)\n{\n\tint ans=0;\n\tfor (int i=odd; i>=0; i-=2)\n\t{\n\t\tint las=sum-i; if (las< 0) continue;\n\t\tint g=(LL)C(n,i)*T(las>>1,n)%P;\n\t\tdel(ans,g);\n\t}\n\treturn ans;\n}\nint main ()\n{\n\t// freopen (\".in\",\"r\",stdin);\n\t// freopen (\".out\",\"w\",stdout);\n\tint n,m; sc(n),sc(m);\n\tinit (n+m*2);\n\tint ans=calc (n,m,3*m);\n\tint g=(LL)n*calc (n,m-1,m-1)%P;\n\tdel(ans,P-g);\n\tpr(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n问题等价于求长为 n 的满足一下三个条件的数列的个数：\n\n1. 所有值的和为 s1 = 3m\n2. 奇数的个数不超过 s2 = m\n3. 最大的数不超过 s3 = 2m\n\n先考虑第一个限制，相当于把 s1 个球放进 n 个盒子，方案数为 f1(s1, n) = C(n + s1, s1)。\n\n再考虑第二个限制，设 f2(n, m, k) 为长度为 n ，和为 m ，奇数不超过 k 个的方案数，\n枚举奇数个数 i ，然后把这 i 个奇数减 1 弄成偶数，\n那么 i 的贡献就是 C(n, i) * f1((m - i) / 2, n - 1) 。\n\n最后考虑第三个限制，由于和为 3m ，超过 2m 的数最多只有一个，\n简单容斥，钦定一个数大于 2m ，那么贡献就是 - n * f2(n, m, m) ，\n但事实上这也算进去了该数恰好为 2m 的情况，继续容斥，贡献为 n * f2(n - 1, m, m) ，\n那么答案 f3(n, m) = f2(n, 3m, m) - n * (f2(n, m, m) - f2(n - 1, m, m)) 。\n#endif\n#include <cstdio>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long lolong;\n\ninline int input() { int x; scanf(\"%d\", &x); return x; }\n\nconst int maxn = 1000005, mod = 998244353;\nlolong fac[maxn];\nlolong inv[maxn];\nlolong ifac[maxn];\n\ninline lolong c(int n, int m) {\n\treturn fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nlolong f(int n, int m, int k) {\n\tlolong res = 0;\n\tfor(int i = 0; i <= k; i ++)\n\t\tif(!((m - i) & 1))\n\t\t\tres += c(n, i) * c((m - i) / 2 + n - 1, (m - i) >> 1) % mod;\n\treturn res % mod;\n}\n\nint main() {\n\tfac[0] = 1;\n\tfor(int i = 1; i < maxn; i ++)\n\t\tfac[i] = fac[i - 1] * i % mod;\n\n\tinv[1] = 1;\n\tfor(int i = 2; i < maxn; i ++)\n\t\tinv[i] = (mod - mod / i) * inv[mod % i] % mod;\n\n\tifac[0] = 1;\n\tfor(int i = 1; i < maxn; i ++)\n\t\tifac[i] = ifac[i - 1] * inv[i] % mod;\n\n\tint n = input(), m = input();\n\tprintf(\"%lld\\n\",\n\t\t\t(f(n, m * 3, m) + mod -\n\t\t\t n * (f(n, m, m) + mod -\n\t\t\t\t f(n - 1, m, m)) % mod) % mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author edamat\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for(int i = int(a), i##_len = (b); i < i##_len; ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\n#define _repr(i, n) repri(i, n, 0)\n/* loop in [n,m] step -1 */\n#define repri(i, a, b) for(int i = int(a), i##_len = (b); i >= i##_len; --i)\n/* loop in [n,0] step -1 or [n,m] step -1 */\n#define repr(...) _overload3(__VA_ARGS__, repri, _repr, )(__VA_ARGS__)\n#define all(x) (x).begin(), (x).end()\n#define debug(x) cerr << #x << \": \" << (x) << '\\n'\n#define pb push_back\n#define eb emplace_back\n#define endl '\\n'\ntypedef long long lint;\n// #define int lint\nconst int INF = (int) (1 << 30) - 1;\nint MOD = (int) 1e9 + 7;\n//const double EPS = 1e-9;\nconst lint LINF = (lint) (1LL << 62) - 1;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n\nstruct IoSetup {\n    IoSetup() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n//        cout << fixed << setprecision(20);\n//        cerr << fixed << setprecision(20);\n    }\n} iosetup;\n\nusing std::to_string;\n\nauto to_string(std::string s) -> std::string {\n    return '\"' + s + '\"';\n}\n\nauto to_string(char c) -> std::string {\n    return \"'\" + std::string{c} + \"'\";\n}\n\nauto to_string(const char *s) -> std::string {\n    return to_string((std::string) s);\n}\n\nauto to_string(bool b) -> std::string {\n    return (b ? \"true\" : \"false\");\n}\n\ntemplate<typename T, typename U>\nauto to_string(std::pair<T, U> p) -> std::string {\n    return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate<size_t N>\nauto to_string(std::bitset<N> bs) -> std::string {\n    std::string res{};\n    for (size_t i = 0; i < N; i++)\n        res.insert(res.begin(), bs.test(i) ? '1' : '0');\n    return res;\n}\n\ntemplate<typename T>\nauto to_string(T v) -> std::string {\n    bool flg = false;\n    std::string res = \"[\";\n    for (auto const &x : v) {\n        if (flg) res += \", \";\n        else flg = true;\n        res += to_string(x);\n    }\n    res += \"]\";\n    return res;\n}\n\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n#define SZ(x) ((int)(x).size())\n\n/* range macro. usage: for(int i:range(n)) */\nclass range {\nprivate:\n    struct I {\n        int x;\n\n        int operator*() { return x; }\n\n        bool operator!=(I &lhs) { return x < lhs.x; }\n\n        void operator++() { ++x; }\n    };\n\n    I i, n;\n\npublic:\n    range(int n) : i({0}), n({n}) {}\n\n    range(int i, int n) : i({i}), n({n}) {}\n\n    I &begin() { return i; }\n\n    I &end() { return n; }\n};\n\n/* keep a max,min */\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\n/* input,output operator for pair and vector */\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    os  << p.first << \" \" << p.second;\n    return os;\n}\n\ntemplate<typename T1, typename T2>\nistream &operator>>(istream &is, pair<T1, T2> &p) {\n    is >> p.first >> p.second;\n    return is;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    for (int i = 0; i < (int) v.size(); i++) {\n        os << v[i] << (i + 1 != v.size() ? \", \" : \"\");\n    }\n    return os;\n}\n\ntemplate<typename T>\nistream &operator>>(istream &is, vector<T> &v) {\n    for (T &in : v) is >> in;\n    return is;\n}\n\ntemplate<typename T, typename U>\nostream &operator<<(ostream &os, const map<T, U> &mp) {\n    for (auto x = mp.begin(); x != mp.end(); ++x) {\n        os << x->first << \": \" << x->second\n           << (x != prev(mp.end()) ? \"\\n\" : \"\");\n    }\n    return os;\n}\n\n/* initialize vector. usage: auto v = male_v<int>(N,0); */\ntemplate<typename T>\nvector<T> make_v(size_t a) {\n    return vector<T>(a);\n}\n\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n/* fill vector. usage: fill_v(v,0); */\ntemplate<typename T, typename V>\ntypename enable_if<is_class<T>::value == 0>::type fill_v(T &t, const V &v) {\n    t = v;\n}\n\ntemplate<typename T, typename V>\ntypename enable_if<is_class<T>::value != 0>::type fill_v(T &t, const V &v) {\n    for (auto &e : t) fill_v(e, v);\n}\n\n/* sum */\ntemplate<typename T>\nT sum(vector<T> &v) {\n    T ret = 0;\n    for (T x : v) {\n        ret += x;\n    }\n    return ret;\n}\n\ntemplate<typename T>\nauto sum(const T &a) {\n    return a;\n}\n\ntemplate<typename T, typename... A>\nauto sum(const T &first, const A &... rest) {\n    return sum(first) + sum(rest...);\n}\n\n/* mod */\nlint intpow(lint a, lint n, lint mod) {\n    lint res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\ntemplate<typename T>\nT intpow(T a, lint n) {\n    T res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a;\n        a = a * a;\n        n >>= 1;\n    }\n    return res;\n}\n\nlong long modinv(long long a, long long m) {\n    long long b = m, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        a -= t * b;\n        swap(a, b);\n        u -= t * v;\n        swap(u, v);\n    }\n    u %= m;\n    if (u < 0) u += m;\n    return u;\n}\n\n/* print */\ntemplate<typename T>\nvoid print(const T &first) {\n    cout << first << endl;\n}\n\ntemplate<typename T, typename... A>\nvoid print(const T &first, const A &... rest) {\n    cout << first << \" \";\n    print(rest...);\n}\n\ntemplate<typename... A>\nvoid print(const A &... rest) {\n    print(rest...);\n}\nstruct RandomNumberGenerator {\n    mt19937 mt;\n    \n    RandomNumberGenerator() : mt(chrono::steady_clock::now().time_since_epoch().count()) {}\n    \n    int operator()(int a, int b) { // [a, b)\n        uniform_int_distribution<int> dist(a, b - 1);\n        return dist(mt);\n    }\n    \n    int operator()(int b) { // [0, b)\n        return (*this)(0, b);\n    }\n};\n\nusing Real = double;\nusing Point = complex<Real>;\nconst Real EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\n\nPoint operator*(const Point &p, const Real &d) {\n    return Point(real(p) * d, imag(p) * d);\n}\n\nistream &operator>>(istream &is, Point &p) {\n    Real a, b;\n    is >> a >> b;\n    p = Point(a, b);\n    return is;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n    os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nPoint rotate(Real theta, const Point &p) {\n    return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\nReal radian_to_degree(Real r) {\n    return (r * 180.0 / PI);\n}\n\nReal degree_to_radian(Real d) {\n    return (d * PI / 180.0);\n}\n\nReal get_angle(const Point &a, const Point &b, const Point &c) {\n    const Point v(b - a), w(c - b);\n    Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n    if (alpha > beta) swap(alpha, beta);\n    Real theta = (beta - alpha);\n    return min(theta, 2 * acos(-1) - theta);\n}\n\nnamespace std {\n    bool operator<(const Point &a, const Point &b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n}\n\n\nstruct Line {\n    Point a, b;\n\n    Line() = default;\n\n    Line(Point a, Point b) : a(a), b(b) {}\n\n    Line(Real A, Real B, Real C) // Ax + By = C\n    {\n        if (eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n        else if (eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n        else a = Point(0, C / B), b = Point(C / A, 0);\n    }\n\n    friend ostream &operator<<(ostream &os, Line &p) {\n        return os << p.a << \" to \" << p.b;\n    }\n\n    friend istream &operator>>(istream &is, Line &a) {\n        return is >> a.a >> a.b;\n    }\n};\n\nstruct Segment : Line {\n    Segment() = default;\n\n    Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n    Point p;\n    Real r;\n\n    Circle() = default;\n\n    Circle(Point p, Real r) : p(p), r(r) {}\n};\n\nusing Points = vector<Point>;\nusing Polygon = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\n\nReal cross(const Point &a, const Point &b) {\n    return real(a) * imag(b) - imag(a) * real(b);\n}\n\nReal dot(const Point &a, const Point &b) {\n    return real(a) * real(b) + imag(a) * imag(b);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C\nint ccw(const Point &a, Point b, Point c) {\n    b = b - a, c = c - a;\n    if (cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n    if (cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n    if (dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n    if (norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n    return 0;                         // \"ON_SEGMENT\"\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool parallel(const Line &a, const Line &b) {\n    return eq(cross(a.b - a.a, b.b - b.a), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool orthogonal(const Line &a, const Line &b) {\n    return eq(dot(a.a - a.b, b.a - b.b), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A\nPoint projection(const Line &l, const Point &p) {\n    double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p) {\n    double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + (l.a - l.b) * t;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B\nPoint reflection(const Line &l, const Point &p) {\n    return p + (projection(l, p) - p) * 2.0;\n}\n\nbool intersect(const Line &l, const Point &p) {\n    return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool intersect(const Line &l, const Line &m) {\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const Segment &s, const Point &p) {\n    return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Line &l, const Segment &s) {\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nReal distance(const Line &l, const Point &p);\n\nbool intersect(const Circle &c, const Line &l) {\n    return distance(l, c.p) <= c.r + EPS;\n}\n\nbool intersect(const Circle &c, const Point &p) {\n    return abs(abs(p - c.p) - c.r) < EPS;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nbool intersect(const Segment &s, const Segment &t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &l) {\n    if (norm(projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n    auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n    if (d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if (d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n    const Point h = projection(l, c.p);\n    if (dot(l.a - h, l.b - h) < 0) return 2;\n    return 0;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\nint intersect(Circle c1, Circle c2) {\n    if (c1.r < c2.r) swap(c1, c2);\n    Real d = abs(c1.p - c2.p);\n    if (c1.r + c2.r < d) return 4;\n    if (eq(c1.r + c2.r, d)) return 3;\n    if (c1.r - c2.r < d) return 2;\n    if (eq(c1.r - c2.r, d)) return 1;\n    return 0;\n}\n\nReal distance(const Point &a, const Point &b) {\n    return abs(a - b);\n}\n\nReal distance(const Line &l, const Point &p) {\n    return abs(p - projection(l, p));\n}\n\nReal distance(const Line &l, const Line &m) {\n    return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\nReal distance(const Segment &s, const Point &p) {\n    Point r = projection(s, p);\n    if (intersect(s, r)) return abs(r - p);\n    return min(abs(s.a - p), abs(s.b - p));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D\nReal distance(const Segment &a, const Segment &b) {\n    if (intersect(a, b)) return 0;\n    return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\nReal distance(const Line &l, const Segment &s) {\n    if (intersect(l, s)) return 0;\n    return min(distance(l, s.a), distance(l, s.b));\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n    Real A = cross(l.b - l.a, m.b - m.a);\n    Real B = cross(l.b - l.a, l.b - m.a);\n    if (eq(abs(A), 0.0) && eq(abs(B), 0.0)) return m.a;\n    return m.a + (m.b - m.a) * B / A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C\nPoint crosspoint(const Segment &l, const Segment &m) {\n    return crosspoint(Line(l), Line(m));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\npair<Point, Point> crosspoint(const Circle &c, const Line l) {\n    Point pr = projection(l, c.p);\n    Point e = (l.b - l.a) / abs(l.b - l.a);\n    if (eq(distance(l, c.p), c.r)) return {pr, pr};\n    double base = sqrt(c.r * c.r - norm(pr - c.p));\n    return {pr - e * base, pr + e * base};\n}\n\npair<Point, Point> crosspoint(const Circle &c, const Segment &l) {\n    Line aa = Line(l.a, l.b);\n    if (intersect(c, l) == 2) return crosspoint(c, aa);\n    auto ret = crosspoint(c, aa);\n    if (dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n    else ret.first = ret.second;\n    return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E\npair<Point, Point> crosspoint(const Circle &c1, const Circle &c2) {\n    Real d = abs(c1.p - c2.p);\n    Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    Real t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n    Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n    Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n    return {p1, p2};\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F\npair<Point, Point> tangent(const Circle &c1, const Point &p2) {\n    return crosspoint(c1, Circle(p2, sqrt(norm(c1.p - p2) - c1.r * c1.r)));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_G\nLines tangent(Circle c1, Circle c2) {\n    Lines ret;\n    if (c1.r < c2.r) swap(c1, c2);\n    Real g = norm(c1.p - c2.p);\n    if (eq(g, 0)) return ret;\n    Point u = (c2.p - c1.p) / sqrt(g);\n    Point v = rotate(PI * 0.5, u);\n    for (int s : {-1, 1}) {\n        Real h = (c1.r + s * c2.r) / sqrt(g);\n        if (eq(1 - h * h, 0)) {\n            ret.emplace_back(c1.p + u * c1.r, c1.p + (u + v) * c1.r);\n        } else if (1 - h * h > 0) {\n            Point uu = u * h, vv = v * sqrt(1 - h * h);\n            ret.emplace_back(c1.p + (uu + vv) * c1.r, c2.p - (uu + vv) * c2.r * s);\n            ret.emplace_back(c1.p + (uu - vv) * c1.r, c2.p - (uu - vv) * c2.r * s);\n        }\n    }\n    return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B\nbool is_convex(const Polygon &p) {\n    int n = (int) p.size();\n    for (int i = 0; i < n; i++) {\n        if (ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n    }\n    return true;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A\nPolygon convex_hull(Polygon &p) {\n    int n = (int) p.size(), k = 0;\n    if (n <= 2) return p;\n    sort(p.begin(), p.end());\n    vector<Point> ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = p[i++]) {\n        while (k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n        while (k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n    }\n    ch.resize(k - 1);\n    return ch;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\nenum {\n    OUT, ON, IN\n};\n\nint contains(const Polygon &Q, const Point &p) {\n    bool in = false;\n    for (int i = 0; i < Q.size(); i++) {\n        Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n        if (a.imag() > b.imag()) swap(a, b);\n        if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvoid merge_segments(vector<Segment> &segs) {\n\n    auto merge_if_able = [](Segment &s1, const Segment &s2) {\n        if (abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n        if (ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n        if (ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n        s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n        return true;\n    };\n\n    for (int i = 0; i < segs.size(); i++) {\n        if (segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n    }\n    for (int i = 0; i < segs.size(); i++) {\n        for (int j = i + 1; j < segs.size(); j++) {\n            if (merge_if_able(segs[i], segs[j])) {\n                segs[j--] = segs.back(), segs.pop_back();\n            }\n        }\n    }\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvector<vector<int> > segment_arrangement(vector<Segment> &segs, vector<Point> &ps) {\n    vector<vector<int> > g;\n    int N = (int) segs.size();\n    for (int i = 0; i < N; i++) {\n        ps.emplace_back(segs[i].a);\n        ps.emplace_back(segs[i].b);\n        for (int j = i + 1; j < N; j++) {\n            const Point p1 = segs[i].b - segs[i].a;\n            const Point p2 = segs[j].b - segs[j].a;\n            if (cross(p1, p2) == 0) continue;\n            if (intersect(segs[i], segs[j])) {\n                ps.emplace_back(crosspoint(segs[i], segs[j]));\n            }\n        }\n    }\n    sort(begin(ps), end(ps));\n    ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n    int M = (int) ps.size();\n    g.resize(M);\n    for (int i = 0; i < N; i++) {\n        vector<int> vec;\n        for (int j = 0; j < M; j++) {\n            if (intersect(segs[i], ps[j])) {\n                vec.emplace_back(j);\n            }\n        }\n        for (int j = 1; j < vec.size(); j++) {\n            g[vec[j - 1]].push_back(vec[j]);\n            g[vec[j]].push_back(vec[j - 1]);\n        }\n    }\n    return (g);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C\nPolygon convex_cut(const Polygon &U, Line l) {\n    Polygon ret;\n    for (int i = 0; i < U.size(); i++) {\n        Point now = U[i], nxt = U[(i + 1) % U.size()];\n        if (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n        if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n            ret.push_back(crosspoint(Line(now, nxt), l));\n        }\n    }\n    return (ret);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A\nReal area2(const Polygon &p) {\n    Real A = 0;\n    for (int i = 0; i < p.size(); ++i) {\n        A += cross(p[i], p[(i + 1) % p.size()]);\n    }\n    return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_H\nReal area2(const Polygon &p, const Circle &c) {\n    if (p.size() < 3) return 0.0;\n    function<Real(Circle, Point, Point)> cross_area = [&](const Circle &c, const Point &a, const Point &b) {\n        Point va = c.p - a, vb = c.p - b;\n        Real f = cross(va, vb), ret = 0.0;\n        if (eq(f, 0.0)) return ret;\n        if (max(abs(va), abs(vb)) < c.r + EPS) return f;\n        if (distance(Segment(a, b), c.p) > c.r - EPS) return c.r * c.r * arg(vb * conj(va));\n        auto u = crosspoint(c, Segment(a, b));\n        vector<Point> tot{a, u.first, u.second, b};\n        for (int i = 0; i + 1 < tot.size(); i++) {\n            ret += cross_area(c, tot[i], tot[i + 1]);\n        }\n        return ret;\n    };\n    Real A = 0;\n    for (int i = 0; i < p.size(); i++) {\n        A += cross_area(c, p[i], p[(i + 1) % p.size()]);\n    }\n    return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B\nReal convex_diameter(const Polygon &p) {\n    int N = (int) p.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < N; i++) {\n        if (p[i].imag() > p[is].imag()) is = i;\n        if (p[i].imag() < p[js].imag()) js = i;\n    }\n    Real maxdis = norm(p[is] - p[js]);\n\n    int maxi, maxj, i, j;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n        if (cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {\n            j = (j + 1) % N;\n        } else {\n            i = (i + 1) % N;\n        }\n        if (norm(p[i] - p[j]) > maxdis) {\n            maxdis = norm(p[i] - p[j]);\n            maxi = i;\n            maxj = j;\n        }\n    } while (i != is || j != js);\n    return sqrt(maxdis);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A\nReal closest_pair(Points ps) {\n    if (ps.size() <= 1) throw (0);\n    sort(begin(ps), end(ps));\n\n    auto compare_y = [&](const Point &a, const Point &b) {\n        return imag(a) < imag(b);\n    };\n    vector<Point> beet(ps.size());\n    const Real INF = 1e18;\n\n    function<Real(int, int)> rec = [&](int left, int right) {\n        if (right - left <= 1) return INF;\n        int mid = (left + right) >> 1;\n        auto x = real(ps[mid]);\n        auto ret = min(rec(left, mid), rec(mid, right));\n        inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);\n        int ptr = 0;\n        for (int i = left; i < right; i++) {\n            if (abs(real(ps[i]) - x) >= ret) continue;\n            for (int j = 0; j < ptr; j++) {\n                auto luz = ps[i] - beet[ptr - j - 1];\n                if (imag(luz) >= ret) break;\n                ret = min(ret, abs(luz));\n            }\n            beet[ptr++] = ps[i];\n        }\n        return ret;\n    };\n    return rec(0, (int) ps.size());\n}\n\n\nstruct FastFourierTransform {\n    using C = complex<double>;\n    \n    const double PI = acos(-1);\n    vector<vector<C>> rts, rrts;\n    \n    void ensure_base(int N) {\n        if(rts.size() >= N) return;\n        rts.resize(N), rrts.resize(N);\n        for(int i = 1; i < N; i <<= 1){\n            if(rts[i].size()) continue;\n            rts[i].resize(i), rrts[i].resize(i);\n            for(int k = 0; k < i; k++){\n                rts[i][k] = polar(1.0, PI / i * k);\n                rrts[i][k] = polar(1.0, -PI / i * k);\n            }\n        }\n    }\n    \n    void DiscreteFourierTransform(vector<C> &F, bool rev) {\n        const int N = (int) F.size();\n        auto &r = rev?rrts:rts;\n        \n        for(int i = 0, j = 1; j + 1 < N; j++){\n            for(int k = N >> 1; k > (i ^= k); k >>= 1);\n            if(i > j) swap(F[i], F[j]);\n        }\n        ensure_base(N);\n        C s, t;\n        for(int i = 1; i < N; i <<= 1){\n            for(int j = 0; j < N; j += i * 2){\n                for(int k = 0; k < i; k++){\n                    s = F[j + k];\n                    t = C(F[j + k + i].real() * r[i][k].real() - F[j + k + i].imag() * r[i][k].imag(),\n                          F[j + k + i].real() * r[i][k].imag() + F[j + k + i].imag() * r[i][k].real());\n                    F[j + k] = s + t, F[j + k + i] = s - t;\n                }\n            }\n        }\n        if(rev) for(int i = 0; i < N; i++) F[i] /= N;\n    }\n    \n    vector<long long> Multiply(const vector<int> &A, const vector<int> &B) {\n        int sz = 1;\n        while(sz < A.size() + B.size() - 1) sz <<= 1;\n        vector<C> F(sz), G(sz);\n        for(int i = 0; i < A.size(); i++) F[i] = A[i];\n        for(int i = 0; i < B.size(); i++) G[i] = B[i];\n        DiscreteFourierTransform(F, false);\n        DiscreteFourierTransform(G, false);\n        for(int i = 0; i < sz; i++) F[i] *= G[i];\n        DiscreteFourierTransform(F, true);\n        vector<long long> X(A.size() + B.size() - 1);\n        for(int i = 0; i < A.size() + B.size() - 1; i++) X[i] = F[i].real() + 0.5;\n        return (X);\n    }\n};\n\n\n\nclass AmeChang {\npublic:\n    static constexpr int kStressIterations = 0;\n    \n    static void generateTest(int cnt, std::ostream &test) {\n        RandomNumberGenerator rg;\n    }\n    \n    void solve(std::istream &cin, std::ostream &cout) {\n        int N;\n        int X1, X2, Y1, Y2, Z1, Z2;\n        cin >> N;\n        cin >> X1 >> X2 >> Y1 >> Y2 >> Z1 >> Z2;\n        vint X(N),Y(N);\n        for(int i=X1;i<=X2;++i){\n            if(!(0<=i&&i<X.size())) continue;\n            X[i] = 1;\n        }\n        for(int i=Y1;i<=Y2;++i){\n            if(!(0<=i&&i<Y.size())) continue;\n            Y[i] = 1;\n        }\n        FastFourierTransform f;\n        auto d = f.Multiply(X,Y);\n        lint ans=0;\n        for(int i=Z1;i<=Z2;++i){\n            if(N-i>=d.size()||N-i<0) continue;\n            ans += d[N-i];\n        }\n//        cout << to_string(d)<<endl;\n        cout << ans << endl;\n    }\n};\n\n\nsigned main() {\n\tAmeChang solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <bitset>\n#include <assert.h>\n#include <unordered_map>\n#include <fstream>\n#include <time.h>\n#include <deque>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef pair<ll,ll> P;\ntypedef pair<int,int> pii;\ntypedef vector<P> vpl;\ntypedef tuple<ll,ll,ll> tapu;\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nconst int inf = 1<<30;\nconst ll linf = 1LL<<62;\nconst int MAX = 3030000;\nll dy[8] = {1,-1,0,0,1,-1,1,-1};\nll dx[8] = {0,0,1,-1,1,-1,-1,1};\nconst double pi = acos(-1);\nconst double eps = 1e-7;\ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){\n\tif(a>b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){\n\tif(a<b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T> inline void print(T &a){\n    rep(i,a.size()) cout << a[i] << \" \";\n    cout << \"\\n\";\n}\ntemplate<typename T1,typename T2> inline void print2(T1 a, T2 b){cout << a << \" \" << b << \"\\n\";}\ntemplate<typename T1,typename T2,typename T3> inline void print3(T1 a, T2 b, T3 c){\n\tcout << a << \" \" << b << \" \" << c << \"\\n\";\n}\n//const int mod = 1e9 + 7;\nconst int mod = 998244353;\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\npublic:\n  u64 a;\n\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n\treturn modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n\treturn modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n\treturn modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n\treturn modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n\ta += rhs.a;\n\tif (a >= Modulus) {\n\t  a -= Modulus;\n\t}\n\treturn *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n\tif (a < rhs.a) {\n\t  a += Modulus;\n\t}\n\ta -= rhs.a;\n\treturn *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n\ta = a * rhs.a % Modulus;\n\treturn *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n\tu64 exp = Modulus - 2;\n\twhile (exp) {\n\t  if (exp % 2) {\n\t\t*this *= rhs;\n\t  }\n\t  rhs *= rhs;\n\t  exp /= 2;\n\t}\n\treturn *this;\n  }\n};\n\nusing mint = modint<mod>;\n\nvector<ll> fac(MAX), finv(MAX), inv(MAX);\n\nvoid comInit(){\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(ll i=2; i<MAX; i++){\n\t\tfac[i] = fac[i-1]*i % mod;\n\t\tinv[i] = mod - inv[mod%i] * (mod/i) % mod;\n\t\tfinv[i] = finv[i-1] * inv[i] % mod;\n\t}\n}\n\n\nll com(ll n, ll k){\n\tif(n < k) return 0;\n\tif(n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\nint main(){\n\tint n,m; cin >> n >> m;\n\tcomInit();\n\tmint ans = com(3*m+n-1, n-1);\n\trep(i,m){\n\t\tans -= com(i+n-2,n-2) * n;\n\t}\n\tfor(int i=m+2; i<=min(3*m,n); i+=2){\n\t\tans -= com(n,i) * com((3*m-i)/2+n-1, n-1);\n\t}\n\tcout << ans.value() << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=998244353 ;\n\nconst int MAX = 1000000;\nconst int MOD = 998244353;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\n\nint main(){\n  int N, M; cin >> N >> M; COMinit();\n  ll ans = COM(3*M+N-1, N-1); ll igai = 0;\n  rep(i, M){\n    igai+=(COM(i+N-2, i)*N%mod); igai%=mod;\n  }\n  for(int i=M+1; i<=min(3*M, N); i++){\n    if((3*M-i)%2) continue;\n    ll tmp = (3*M-i)/2;\n    igai+=(COM(tmp+N-1, tmp)*COM(N, i)%mod);\n    igai%=mod;\n  }\n  ans-=igai; if(ans<0) ans+=mod;\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#define DEBUG\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds; \nusing namespace std;\n \n#define BSET(a, p) ((a) | (1ll << (p)))\n#define BCHK(a, p) ((a) & (1ll << (p)))\n#define BXOR(a, p) ((a) ^ (1ll << (p)));\n#define BREM(a, p) (BCHK(a, p)?(BXOR(a, p)):(a))\n#define BSHO(a, N) (bitset<N>(a))\n \n#define fi first\n#define sc second \n#define pb push_back\n \n \n#ifdef DEBUG\n    #define dbg(s) {s;}\n    #define PRELUDE\n#endif\n \n#ifndef DEBUG \n    #define PRELUDE { ios :: sync_with_stdio(false); cin.tie(0); cout.tie(0); }\n    #define dbg(s)\n    #define endl \"\\n\"\n#endif\n \nusing namespace std;\n \n \n#define int ll\n#define i32 int32_t\n \n#define RBTTYPE int\n#define ordered_set tree<RBTTYPE, null_type, less<RBTTYPE>, rb_tree_tag,tree_order_statistics_node_update> \n \n#define all(v) (v).begin(),(v).end()\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair< int, int > pii;\ntypedef pair< ll, ll > pll;\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ninline int ri(int x) { // from [0, n-1]\n    return uniform_int_distribution<int>(0, x - 1)(rng);\n}\n \ninline ld rf() { // from [0, 1]\n    return uniform_real_distribution<ld>(0, 1)(rng);\n}\n \nll gcd(ll x, ll y) {\n    if (x < y) return gcd(y, x);\n    if (y == 0) return x;\n    return gcd(y, x % y);\n} \n \nconst ll inf = 1e9 + 7;\nconst ll mod = 998244353ll;\n \nll modexp(ll x, ll ex) {\n    ll ans = 1ll;\n    while (ex > 0) {\n        if (ex & 1ll) ans = (ans * x) % mod;\n        ex >>= 1ll;\n        x = (x * x) % mod;\n    }\n    return ans;\n}\n  \nconst int maxn = 3e6 + 7;\n\n\nint fac[maxn];\nint faci[maxn];\n\nint C(int n, int m) {\n    if (m > n) return 0;\n    if (m < 0) return 0;\n    int ans = (fac[n] * faci[m]) % mod;\n    ans = (ans * faci[n - m]) % mod;\n    return ans;\n}\n\n\ni32 main() {\n    //freopen(\"<file>.in\", \"r\", stdin);\n    //freopen(\"<file>.out\", \"w\", stdout);\n\n    PRELUDE;\n   \n    fac[0] = 1ll; faci[0] = 1ll;\n    for (int j = 1; j < maxn; j++) {\n        fac[j] = (j * 1ll * fac[j - 1]) % mod;\n        faci[j] = modexp(fac[j], mod - 2);\n    }\n\n    int n, m; cin >> n >> m;\n\n    int total = C(n - 1 + m + m + m, n - 1);\n    //cout << total << endl;\n\n    int part1 = 0;\n    for (int j = m + m + 1; j <= m + m + m; j++) {\n        int cur = n * C(m + m + m - j + n - 2, n - 2);\n     ////   cout << j << \" ? \" << cur << endl;\n        cur %= mod;\n        part1 += cur;\n    }\n    part1 %= mod;\n    \n    //cout << part1 << endl;\n\n    int part2 = 0;\n\n    for (int k = m + 1; k <= n; k++) {\n        \n        /*int cur = C(k, m + 1);\n        int cur2 = C(n, k);\n        int sum = m + m + m - k;\n        if (sum % 2) continue;\n        int cur3 = C(sum / 2 + n - k - 1, n - k - 1);\n        int sg = ((k - m - 1) % 2 == 0) ? 1 : (mod - 1);\n\n        int ans = (((((cur * cur2) % mod) * cur3) % mod) * sg) % mod;\n        cout << ans << endl;\n        part2 = (part2 + ans) % mod;*/\n\n        int cur = C(n, k);\n        int sum = m * 3 - k;\n        if (sum % 2) continue;\n        sum /= 2;\n        int cur2 = C(sum + n - 1, n - 1);\n        int ans = (cur * cur2) % mod;\n        part2 += ans;\n\n    }\n\n    part2 %= mod;\n\n    //cout << part2 << endl;\n\n    cout << (total + mod - part1 + mod - part2) % mod << endl; \n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MAX = 200000;\nconst int MOD = 998244353;\n//\nint fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nint COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nsigned main() {\n int n,m;\n cin>>n>>m;\n COMinit();\n int ans=n*COM(m+n-2,m)%MOD;\n for(int i=m;3*m-2*i>=0;i++){\n     ans=(ans + (COM(i+n-1,i) +(MOD - n*COM(i-m+n-1,i-m)%MOD))*COM(n,3*m-2*i)%MOD)%MOD;\n }\n cout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 998244353;\nlong long int fac[5000001],inv[5000001],cnt[5000001];\n\nlong long int C(int n,int k){\n\treturn fac[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\nlong long int solve(int n,int m,int k){\n\tlong long int res = 0;\n\tfor(int i=0;i<=k;i++)\n\t\tif(n-i>=0&&(n-i)%2==0&&m>=i)\n\t\t\tres += C((n-i)/2+m-1,m-1) * C(m,i) % mod;\n\treturn res % mod;\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tfac[0]=fac[1]=inv[0]=inv[1]=1;\n\tfor(int i=2;i<=5000000;i++){\n\t\tfac[i]=fac[i-1]*i%mod;\n\t\tinv[i]=mod-mod/i*inv[mod%i]%mod;\n\t}\n\tfor(int i=2;i<=1000000;i++)\n\t\tinv[i]=inv[i-1]*inv[i]%mod;\n\tint n,m;\n\tcin>>n>>m;\n\tlong long int ans = solve(3*m,n,m) - (solve(m,n,m) - solve(m,n-1,m)) * n;\n\tcout<<(ans%mod+mod)%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n//#include \"boost/multiprecision/cpp_int.hpp\"\n//typedef boost::multiprecision::cpp_int ll;\ntypedef long double dd;\n//#define i_7 (ll)(1E9+7)\n#define i_7 998244353\n#define i_5 i_7-2\n\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\ntypedef pair<ll,ll> l_l;\ntypedef pair<dd,dd> d_d;\nll inf=(ll)1E16;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\ndd EPS=1E-9;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n//template<class T>void max(T a,T b){if(a<b)return b;else return a;}\n//template<class T>void min(T a,T b){if(a>b)return b;else return a;}\n//template<class T>bool Max(T&a, T b){if(a < b){a = b;return 1;}return 0;}\n//template<class T>bool Min(T&a, T b){if(a > b){a = b;return 1;}return 0;}\n\n//////////////////////////\n\n\nll po(ll i,ll p){\n    if(p==0)return 1;\n    else{\n        i=mod(i);\n        if(p==1)return i;\n        if(p%2==0)return po(mod(i*i),p/2);\n        return mod(i*po(i,p-1));\n    }\n}\nll bunbo(ll n){\n    return po(n,i_5);\n}\n\n\n#define N 2000004\nll kai[N];\nll kai2[N];\nvoid calc(){\n    kai[0]=1;\n    kai2[0]=1;\n    rep(i,1,N-1){\n        kai[i]=mod(kai[i-1]*i);\n    }\n    kai2[N-1]=po(kai[N-1],i_5);\n    for(ll i=N-2;i>=0;i--){\n        kai2[i]=mod(kai2[i+1]*(i+1));\n    }\n}\nll comb(ll n,ll k){\n    if(n<k)return 0;\n    if(n==0)return 1;\n    return mod(mod(kai[n]*kai2[n-k])*kai2[k]);\n}\n\nint main(){fastio\n    calc();\n    ll n,m;cin>>n>>m;\n    ll a1,a2=0,a3=0;\n    a1=comb(3*m+n-1,n-1);\n    rep(ma,2*m+1,3*m){\n        ll res=3*m-ma;\n        Add(a2,comb(res+n-2,n-2));\n    }\n    a2=mod(a2*n);\n    rep(i,m+1,3*m){\n        if((3*m-i)%2==1)continue;\n        if(n<i)continue;\n        ll res=(3*m-i)/2;\n        Add(a3,comb(n,i)*comb(res+n-1,n-1));\n    }\n    cout<<mod(a1-a2-a3)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\nusing namespace std;\ntypedef long long int ll;\n\nll mod=998244353;\n\nll mod_pow(ll a,ll b){\n\ta%=mod;\n\tif(b==0)return 1;\n\tif(b==1)return a;\n\tll res=mod_pow(a,b/2)%mod;\n\tres*=res; res%=mod;\n\tif(b%2)res*=a;\n\treturn res%mod;\n}\n\nstruct perm{\nprivate:\n\tint sz;\n\tvector<ll> p,invp;\npublic:\n\tperm(int n){\n\t\tsz=n+1;\n\t\tp.resize(sz),invp.resize(sz);\n\t\tp[0]=1;\n\t\tfor(int i=1;i<=sz-1;i++){\n\t\t\tp[i]=p[i-1]*i%mod;\n\t\t}\n\t\tinvp[sz-1]=mod_pow(p[sz-1],mod-2);\n\t\tfor(int i=sz-2;i>=0;i--){\n\t\t\tinvp[i]=invp[i+1]*(i+1)%mod;\n\t\t}\n\t}\n\tll comb(ll x,ll y){\n\t\tif(x<y||y<0)return 0;\n\t\treturn (p[x]*invp[x-y]%mod)*invp[y]%mod;\n\t}\n};\nperm p(5000000);\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tll n,m; cin >> n >> m;\n\tll ans=0;\n\tfor(int i=0;i<=min(n,m);i++){\n\t\tif((3*m-i)%2)continue;\n\t\tll k=(3*m-i)/2;\n\t\t(ans+=p.comb(n,i)*p.comb(n-1+k,k)%mod)%=mod;\n\t}\n\tll res=0;\n\tll res2=0;\n\tfor(int i=0;i<=(m,n);i++){\n\t\tif((m-i)%2)continue;\n\t\tll k=(m-i)/2;\n\t\t(res+=p.comb(n,i)*p.comb(n-1+k,k)%mod)%=mod;\n\t}\n\tfor(int i=0;i<=(m,n-1);i++){\n\t\tif((m-i)%2)continue;\n\t\tll k=(m-i)/2;\n\t\t(res2+=p.comb(n-1,i)*p.comb(n-2+k,k)%mod)%=mod;\n\t}\n\tres-=res2;\n\tres%=mod;\n\tans-=res*n;\n\tans%=mod;\n\tif(ans<0)ans+=mod;\n\tcout << ans << endl;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=2e6+5;\nconst int mod=998244353;\nint n,m,inv[N],jc[N],jcn[N],foo,bar;\nint C(int n,int m){\n\tif(n<0||m<0||n<m)return 0;\n\treturn 1ll*jc[n]*jcn[m]%mod*jcn[n-m]%mod;\n}\nint cal(int n,int m){\n\treturn C(n+m-1,n);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);inv[1]=jc[0]=jcn[0]=1;\n\tfor(int i=2;i<N;++i)inv[i]=1ll*inv[mod%i]*(mod-mod/i)%mod;\n\tfor(int i=1;i<N;++i)jc[i]=1ll*jc[i-1]*i%mod,jcn[i]=1ll*jcn[i-1]*inv[i]%mod;\n\tfor(int i=0;i<=m&&i<=n;++i)if(~(m+m+m-i)&1)foo=(foo+1ll*C(n,i)*cal(m+m+m-i>>1,n))%mod;\n\tfor(int i=0;i<m;++i)bar=(bar+cal(i,n-1))%mod;\n\tprintf(\"%lld\\n\",(foo+1ll*(mod-n)*bar)%mod);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n#define rep(i, n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n#ifdef LOCAL\n    #define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define eprintf(...) do{}while(0)\n#endif\n\n\n\n\nconst int MAX = 1800000;\nconst ll MOD = 998244353;\n\nstruct Comb {\n\tvector<ll> fac, finv, inv; // 階乗、階乗の逆数、逆数\n\t\n\tComb(int n = MAX) : fac(n), finv(n), inv(n){\n\t\tfac[0] = fac[1] = 1;\n\t\tfinv[0] = finv[1] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 2; i < MAX; i++){\n\t\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\t\tinv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n\t\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t\t}\n\t}\n\t\n\tll C( ll n, ll k ){\n\t\tif (n < k) return 0;\n\t\tif (n < 0 || k < 0) return 0;\n\t\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n\t}\n\t\n\tll P( ll n, ll k ){\n\t\tif (n < k) return 0;\n\t\tif (n < 0 || k < 0) return 0;\n\t\treturn fac[n] * finv[n-k] % MOD;\n\t}\n};\n\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n\tusing u64 = std::uint_fast64_t;\n\npublic:\n\tu64 a;\n\n\tconstexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n\tconstexpr u64 &value() noexcept { return a; }\n\tconstexpr const u64 &value() const noexcept { return a; }\n\tconstexpr modint operator+(const modint rhs) const noexcept {\n\t\treturn modint(*this) += rhs;\n\t}\n\tconstexpr modint operator-(const modint rhs) const noexcept {\n\t\treturn modint(*this) -= rhs;\n\t}\n\tconstexpr modint operator*(const modint rhs) const noexcept {\n\t\treturn modint(*this) *= rhs;\n\t}\n\tconstexpr modint operator/(const modint rhs) const noexcept {\n\t\treturn modint(*this) /= rhs;\n\t}\n\tconstexpr modint &operator+=(const modint rhs) noexcept {\n\t\ta += rhs.a;\n\t\tif (a >= Modulus) {\n\t\t\ta -= Modulus;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr modint &operator-=(const modint rhs) noexcept {\n\t\tif (a < rhs.a) {\n\t\t\ta += Modulus;\n\t\t}\n\t\ta -= rhs.a;\n\t\treturn *this;\n\t}\n\tconstexpr modint &operator*=(const modint rhs) noexcept {\n\t\ta = a * rhs.a % Modulus;\n\t\treturn *this;\n\t}\n\t\n\t// rhsの(MOD-2)乗を掛ける\n\tconstexpr modint &operator/=(modint rhs) noexcept {\n\t\tu64 exp = Modulus - 2;\n\t\twhile (exp) {\n\t\t\tif (exp % 2) {\n\t\t\t\t*this *= rhs;\n\t\t\t}\n\t\t\trhs *= rhs;\n\t\t\texp /= 2;\n\t\t}\n\t\treturn *this;\n\t}\n\t\n\tfriend ostream &operator<<(ostream &s,const modint &rhs) noexcept {\n\t\treturn s << rhs.a;\n\t}\n\t\n\tmodint pow(ll y) noexcept {\n\t\tmodint result(1);\n\t\tmodint x(a);\n\t\t\n\t\twhile ( y ){\n\t\t\tif ( y & 1 )\n\t\t\t\tresult *= x;\n\t\t\tx *= x;\n\t\t\ty >>= 1;\n\t\t}\n\t\treturn result;\n\t}\n};\n\nusing mint = modint<MOD>;\n\n\n\n\n/*\n\t2のブロックをA個、1のブロックをB個、\n\tA*2+B = M*3\n\n\t2のブロックは1か所に最大M個まで置ける\n\t  2のブロックを1箇所にM個置くと、そこには1のブロックを置けない\n\t\n\t1のブロックは1か所に最大1個まで置ける\n*/\n\nll n, m;\n\nint main(){\n\tcin >> n >> m;\n\tComb c;\n\t\n\tll m3 = m*3;\n\tmint result = 0;\n\tfor ( ll a = m; a*2 <= m*3; a++ ){\n\t\tll b = m*3 - a*2;\n\t\tmint nCb = c.C(n,b); // 1のブロックを置くパターン数。\n\t\tmint n1Cb = c.C(n-1,b);\n\t\t\n\t\t// a個の2のブロックをn箇所に自由に置くパターン数\n\t\tmint ap = c.C(n-1+a,a);\n\t\t\n\t\t/* 2のブロックを1か所にM個、残りのn-1箇所にa-M個置くパターン\n\t\t    = n * nCr(n-2+a-M,a-M)\n\t\t*/\n\t\tmint am1 = c.C(n-2+a-m,a-m); am1 *= n;\n\t\t\n\t\t/* 2のブロックを1か所にk個、残りのn-1箇所にa-k個置くパターン(M+1 <= k <= a) (a-M-1 >= a-k >= 0)\n\t\t   n * Σ nCr(n-2+a-k,a-k)\n\t\t    = n * nCr(n-2+(a-M-1)+1,(a-M-1))\n\t\t*/\n\t\tmint am = c.C(n-2+a-m,a-m-1); am *= n;\n\t\t\n\t\t//eprintf( \"a=%lld b=%lld / ncb=%lld ap=%lld / am1=%lld ncb=%lld n1cb=%lld / am=%lld ncb=%lld\\n\", a, b, nCb, ap, am1, nCb, n1Cb, am, nCb );\n\t\tresult +=  nCb*ap - am1*nCb + am1*n1Cb - am*nCb;\n\t}\n\t\n\tcout << result << endl;\n\t\n\t\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define SZ(a) ((int)(a).size())\n#define LL long long\n#define X first\n#define ll long long\n#define Y second\nusing namespace std;\nconst int INF = 1000 * 1000 * 1000;\nconst LL LINF = INF * (LL)INF;\nconst int mod = 998244353;\n\n\nconst int MOD = 998244353;\nconst int MAXN = 1e6 + 10;\nconst int A = 26;\nint fact[2500005];\nint w[5000001];;\nint inv[2500005];\nint R[2000001];\nint t1[2000001],t2[2000001];\ntypedef vector<int> poly;\nconst int P = 998244353;\nint mult(int a , int b)\n{\n\treturn a * (LL)b % mod;\n}\nint add(int a , int b)\n{\n\treturn a + b >= mod ? a + b - mod : a + b;\n}\nint sub(int a , int b)\n{\n\treturn a - b < 0 ? a - b + mod : a - b;\n}\nint c(int n , int k)\n{\n\tif(n < k)\n\t\treturn 1;\n\treturn mult(fact[n] , mult(inv[k] , inv[n - k]));\n}\nint modPow(int a , int step)\n{\n\tint ans = 1;\n\twhile(step)\n\t{\n\t\tif(step & 1)\n\t\t\tans = mult(ans , a);\n\t\tstep >>= 1;\n\t\ta = mult(a , a);\n\t}\n\treturn ans;\n}\nint lim;\nnamespace fft {\n \n\tconst int mod = 998244353;\n\tconst int root = 15311432;\n\tconst int root_1 = 469870224;\n\tconst int root_pw = 1 << 23;\n \n\ttemplate<class T>\n\tT eea(T a, T b, T& x, T& y) {\n\t\tif (!b) {\n\t\t\tx = 1;\n\t\t\ty = 0;\n\t\t\treturn a;\n\t\t}\n\t\n\t\tT x1, y1;\n\t\tT g = eea(b, a % b, x1, y1);\n\t\tx = y1;\n\t\ty = x1 - (a / b) * y1;\n\t\treturn g;\n\t}\n \n\tint inverse(int n) {\n\t\tint x, y;\n\t\teea(n, mod, x, y);\n\t\tx %= mod;\n\t\tif (x < 0)\n\t\t\tx += mod;\n\t\treturn x;\n\t}\n \n\tvoid fft(vector<int>& a, bool invert) {\n\t\tint n = a.size();\n \n\t\tfor (int i = 1, j = 0; i < n; i++) {\n\t\t\tint bit = n >> 1;\n\t\t\tfor (; j & bit; bit >>= 1)\n\t\t\t\tj ^= bit;\n\t\t\tj ^= bit;\n \n\t\t\tif (i < j)\n\t\t\t\tswap(a[i], a[j]);\n\t\t}\n \n\t\tfor (int len = 2; len <= n; len <<= 1) {\n\t\t\tint wlen = invert ? root_1 : root;\n\t\t\tfor (int i = len; i < root_pw; i <<= 1)\n\t\t\t\twlen = 1LL * wlen * wlen % mod;\n \n\t\t\tfor (int i = 0; i < n; i += len) {\n\t\t\t\tint w = 1;\n\t\t\t\tfor (int j = 0; j < len / 2; j++) {\n\t\t\t\t\tint u = a[i+j], v = (int)(1LL * a[i+j+len/2] * w % mod);\n\t\t\t\t\ta[i+j] = u + v < mod ? u + v : u + v - mod;\n\t\t\t\t\ta[i+j+len/2] = u - v >= 0 ? u - v : u - v + mod;\n\t\t\t\t\tw = 1LL * w * wlen % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t\tif (invert) {\n\t\t\tint n_1 = inverse(n);\n\t\t\tfor (int& x : a)\n\t\t\t\tx = 1LL * x * n_1 % mod;\n\t\t}\n\t}\n}\n \nint pm(int x) {\n\tif (x < fft::mod - x) {\n\t\treturn x;\n\t} else {\n\t\treturn x - fft::mod;\n\t}\n}\n \nconst int FIELD = 131072;\n \nvector<int> poly_mul(vector<int> a, vector<int> b) {\n\tint n = a.size() + b.size() - 1;\n\tint m = 1;\n\twhile (m < n)\n\t\tm *= 2;\n\ta.resize(m);\n\tb.resize(m);\n \n\tif (a == b) {\n\t\tfft::fft(a, false);\n\t\tb = a;\n\t} else {\n\t\tfft::fft(a, false);\n\t\tfft::fft(b, false);\n\t}\n\tfor (int i=0; i<m; i++)\n\t\ta[i] = a[i] * 1ll * b[i] % fft::mod;\n\tfft::fft(a, true);\n\ta.resize(n);\n\treturn a;\n}\ninline int count(int n, int m)\n{\n\treturn c(n - 1 + m, m);\n}\n \nint jebu(int n, int odd, int m)\n{\n\treturn count(n, (3 * m - odd) / 2);\n}\n\n \n \nint dp[100][200];\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\t\n\tfact[0] = inv[0] = 1;\n\tfor(int i = 1; i <= 2500000; i++)\n\t{\n\t\tfact[i] = mult(fact[i - 1] , i);\n\t\tinv[i] = modPow(fact[i] , mod - 2);\n\t}\n\tint n , m;\n\tcin >> n >> m;\n\t\n\tint ans = c(n + 3 * m - 1 , n - 1);\n\tans = sub(ans , c(m - 1 + n - 1 , m - 1));\n\tn--;m--;\n\tvector<int> a(n + 1) , b(m + 1);\n\tfor(int i = 1; i <= n; i++)\n\t\ta[i] = mult(inv[i - 1] , inv[n - i]);\n\tfor(int i = 0; i <= m; i++)\n\t\tb[i] = mult(inv[m - i] , inv[i]);\n\tvector<int> C = poly_mul(a , b);\n\tLL ans2 = ans;\n\tfor(int j = 1; j < C.size(); j++)\n\t{\n\t\tans = sub(ans , mult(C[j] , mult(fact[j - 1] , fact[n + m - j])));\n\t}\n\tn++;\n\tm++;\n\t/*int odd = 0;\n\tfor(int cnt = m + 2; cnt <= n && cnt <= 3 * m; cnt += 2)\n\t{\n\t\tint coef = c(n, cnt);\n\t\tint here = jebu(n, cnt, m);\t\n\t\todd = add(odd, mult(coef, here));\n\t}*/\n\t//ans = sub(ans , odd);\n\t\n\tfor(int j = m + 1; j <= 3 * m; j ++)\n\t{\n\t\tif(j <= n && (3 * m - j) % 2 == 0)\n\t\t{\n\t\t\t\n\t\t\tint zalupa1 = mult(c(n , j) , c(n + (3 * m - j) / 2 - 1 , n - 1));\n\t\t\tans = sub(ans , zalupa1);\n\t\t}\n\t\t\t\n\t}\n\t\n\t\n\t/*for(int i = 1; i < n; i++)\n\t\tfor(int j = 0; j < m; j++)\n\t\t{\n\t\t\t//if(i == 0 && j)\n\t\t\t\t//continue;\n\t\t\t//cerr << i << \" \" << j << \" \" << mult(c(i - 1 + j , i - 1) , c(n - 1 - i + m - 1 - j , m - 1 - j)) << endl;\n\t\t\tans2 = sub(ans2 , mult(c(i - 1 + j , i - 1) , c(n - 1 - i + m - 1 - j , m - 1 - j)));\n\t\t}*/\n\t/*dp[0][0] = 1;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = 0; j <= 3 * m; j++)\n\t\t{\n\t\t\tfor(int k = 0; k <= 2 * m; k++)\n\t\t\t{\n\t\t\t\tdp[i + 1][j + k] = add(dp[i][j] , dp[i + 1][j + k]);\n\t\t\t}\n\t\t}\n\t}*/\n\t\t\t\t\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#define mkp make_pair\ntypedef long long ll;\nusing namespace std;\n\nconst ll MOD=998244353;\n\n#define MAX_N 1000010\nll inv[MAX_N+10],fac[MAX_N+10],ifac[MAX_N+10];\n\nvoid setComb(){\n  inv[0]=1;inv[1]=1;fac[1]=1;ifac[1]=1;fac[0]=1;ifac[0]=1;\n  for(int i=2;i<MAX_N;i++){\n    inv[i]=(-MOD/i)*inv[MOD%i]%MOD;\n    fac[i]=fac[i-1]*i%MOD;\n    ifac[i]=ifac[i-1]*inv[i]%MOD;\n\n    inv[i]=(inv[i]+MOD)%MOD;\n    fac[i]=(fac[i]+MOD)%MOD;\n    ifac[i]=(ifac[i]+MOD)%MOD;\n  }\n  return;\n}\n\nll comb(ll n,ll k){\n  if(n<k||n<0||k<0) return 0;\n  else return ((fac[n]*ifac[k]%MOD*ifac[n-k]%MOD+MOD)%MOD);\n}\n\nll hcomb(ll n,ll r){\n  if(n==0&&r==0) return 1;\n  else if(n<0||r<0) return 0;\n  else return comb(n+r-1,r);\n}\n\nll mod_pow(ll x,ll n){\n  x%=MOD;\n  ll res=1;\n  while(n>0){\n    if(n&1) res=res*x%MOD;\n    x=x*x%MOD;\n    n>>=1;\n  }\n  return res;\n}\n\nvoid add(ll &a,ll b){\n  a=(a+b)%MOD;\n}\n\nvoid mul(ll &a,ll b){\n  a=a*b%MOD;\n}\n\nint main(){\n  ll N,M;\n  cin>>N>>M;\n\n  setComb();\n\n  ll nans=0;\n  for(ll k=0;k<M;k++){\n    ll res=hcomb(N-1,k);\n    mul(res,N);\n    add(nans,res);\n  }\n\n  ll ans=0;\n  for(ll k=0;k<=min(N,M);k++){\n    if(k%2!=M%2) continue;\n    ll res=hcomb(N,(3*M-k)/2);\n    mul(res,comb(N,k));\n    add(ans,res);\n  }\n\n  add(ans,-nans+MOD);\n  add(ans,MOD);\n  cout<<ans<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sz(c)      int(c.size())\n#define rep(i,a,b) for (int i=a; i<(b); ++i)\n#define per(i,a,b) for (int i=(b)-1; i>=(a); --i)\nusing namespace std;\nusing ll = long long;\n\nint const MAXN=2.2e6;\nint const MD=998244353;\n\nint madd(int x,int y) {\n\tif (x+y<MD) return x+y; else return x+y-MD;\n}\nint msub(int x,int y) {\n\tif (x-y>=0) return x-y; else return x-y+MD;\n}\nint mmul(int x,int y) {\n\treturn int(ll(x)*y % MD);\n}\nint mpow(int x,int p) {\n\tint res=1;\n\twhile (p>0) {\n\t\tif (p%2) res=mmul(res,x);\n\t\tx=mmul(x,x);\n\t\tp/=2;\n\t}\n\treturn res;\n}\nint minv(int x) {\n\treturn mpow(x,MD-2);\n}\nint mdiv(int x,int y) {\n\treturn mmul(x,mpow(y,MD-2));\n}\n\ntemplate<int N>\nstruct mod_comb {\n\tint f[N],rf[N];\n\tmod_comb() {\n\t\tf[0]=rf[0]=1;\n\t\trep(i,1,N) {\n\t\t\tf[i]=mmul(f[i-1],i);\n\t\t\trf[i]=minv(f[i]);\n\t\t}\n\t}\n\tint comb(int n,int k) {\n\t\tif (n<k) return 0;\n\t\treturn mmul(f[n],mmul(rf[n-k],rf[k]));\n\t}\n\tint distr(int n,int k) {\n\t\treturn comb(n+k-1,k-1);\n\t}\n};\nmod_comb<MAXN> mcomb;\n#define comb(n,k) mcomb.comb(n,k)\n#define distr(n,k) mcomb.distr(n,k)\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(10);\n\n\tint N,M;\n\tcin>>N>>M;\n\t\n\tint res=0;\n\trep(i,0,min(N,M)+1) if ((3*M-i)%2==0) {\n\t\tint add=mmul(comb(N,i),distr((3*M-i)/2,N));\n\t\tres=madd(res,add);\n\t}\n\trep(i,0,min(N,M)+1) if ((M-i)%2==0) {\n\t\tint sub=mmul(comb(N,i),distr((M-i)/2,N));\n\t\tres=msub(res,mmul(sub,N));\n\t}\n\trep(i,0,min(N,M)+1) if ((M-i)%2==0) {\n\t\tint add=mmul(comb(N-1,i),distr((M-i)/2,N-1));\n\t\tres=madd(res,mmul(add,N));\n\t}\n\tcout<<res<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <climits>\n#include <iomanip>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <tuple>\n#include <iostream>\n#include <deque>\n#include <array>\n#include <set>\n#include <functional>\n#include <memory>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <numeric>\n\nconstexpr long long int mod = 998244353LL;\nstruct Factorial {\n\tstd::vector<long long int> factorial, inversed_factorial;\n\tFactorial(const int max) : factorial(max + 1, 1), inversed_factorial(max + 1, 1) {\n\t\tstd::vector<long long int> inv(max + 1, 1);\n\t\tfor (auto i = 2; i <= max; ++i) {\n\t\t\tfactorial[i] = (factorial[i - 1] * i) % mod;\n\t\t\tinv[i] = (mod - mod / i) * inv[mod % i] % mod;\n\t\t\tinversed_factorial[i] = inv[i] * inversed_factorial[i - 1] % mod;\n\t\t}\n\t}\n\tlong long int fact(const int n) const {\n\t\treturn factorial[n];\n\t}\n\tlong long int comb(const int n, const int r) const {\n\t\treturn factorial[n] * inversed_factorial[r] % mod * inversed_factorial[n - r] % mod;\n\t}\n\n};\n\nint main() {\n\tint n, m; std::cin >> n >> m;\n\tFactorial factorial(n + 3 * m);\n\tauto all = factorial.comb(n - 1 + 3 * m, 3 * m);\n\tauto over = factorial.comb(n + m - 2, m - 1) * n % mod;\n\tlong long int odd = 0;\n\tfor (auto i = m + 1; i <= n && i <= 3 * m; ++i) {\n\t\tif ((3 * m - i) % 2 == 0) {\n\t\t\todd += factorial.comb(n - 1 + (3 * m - i) / 2, (3 * m - i) / 2) * factorial.comb(n, i) % mod;\n\t\t\todd %= mod;\n\t\t}\n\t}\n\tstd::cout << (all - over - odd + 2 * mod) % mod << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mn=2e6+10;\nconst ll mod=998244353;\nll inv(ll x){\n    ll ans=1;\n    for(ll i=mod-2;i;i>>=1,x=x*x%mod)if(i&1)ans=ans*x%mod;\n    return ans;\n}\nll fact[mn];\nll ch(ll n,ll k){\n    if(k<0||k>n)return 0;\n    return fact[n]*inv(fact[k])%mod*inv(fact[n-k])%mod;\n}\nll hail(ll k,ll n,ll m){\n    m++;\n    return ch(k+n-1,n-1)-n*ch(k+n-1-m,n-1)%mod;\n}\nint main()\n{\n    ll n,m,i;\n    fact[0]=1;\n    for(i=1;i<mn;i++)fact[i]=fact[i-1]*i%mod;\n    scanf(\"%lld%lld\",&n,&m);\n    ll ans=0;\n    for(i=m%2;i<=min(n,m);i+=2){\n        ans+=ch(n,i)*hail((3*m-i)/2,n,m-1)+(hail((3*m-i)/2,n,m)-hail((3*m-i)/2,n,m-1))*ch(n-1,i);\n        ans%=mod;\n    }\n    if(ans<0)ans+=mod;\n    printf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cstdio>\n#include <iomanip>\n#include <cmath>\n#include <bitset>\n\nusing namespace std;\n\nint n, m;\nconst int MOD = 998244353;\nlong long ans = 0;\nlong long fact[6100000];\nlong long ufact[6100000];\n\nlong long inq(long long a, long long b)\n{\n    if (b == 0) return 1;\n    long long l = inq(a, b / 2);\n    if (b % 2) return l * l % MOD * a % MOD;\n    return l * l % MOD;\n}\n\nlong long cnk(long long n, long long k)\n{\n    return fact[n] * ufact[k] % MOD * ufact[n - k] % MOD;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tfact[0] = 1, ufact[0] = 1;\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n + 3 * m; i++) fact[i] = fact[i - 1] * i % MOD, ufact[i] = inq(fact[i], MOD - 2);\n\tans = cnk(3 * m + n - 1, n - 1);\n\tans = (ans + MOD - n) % MOD;\n\tn--;\n\tfor (int bad_len = 2 * m + 1; bad_len < 3 * m; bad_len++)\n    {\n        int cnt_pos = 3 * m - bad_len - 1;\n        ans = (ans + MOD - cnt_pos * cnk(3 * m - bad_len + 1 + n - 2, n - 2) % MOD) % MOD;\n        ans = (ans + MOD - 2 * cnk(3 * m - bad_len + 1 + n - 1, n - 1) % MOD) % MOD;\n    }\n    for (int b = m + 1; b <= min(3 * m, n + 1); b++)\n    {\n        int p = 3 * m + b;\n        int g = n + 1 - b;\n        int len = 3 * m + g;\n        int kek = len - n - 1;\n        if (kek % 2 == 0)\n        {\n            kek /= 2;\n            ans = (ans + MOD - cnk(kek + n, n) * cnk(n + 1, g) % MOD) % MOD;\n        }\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=3000005,M=998244353;\nint fac[N],inv[N],n,m,ans;\nint ksm(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=x*x%M)\n\t\tif (y&1)(ans*=x)%=M;\n\treturn ans;\t\n}\nint C(int x,int y){\n\tif (x<y)return 0;\n\treturn fac[x]*inv[y]%M*inv[x-y]%M;\n}\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tfac[0]=inv[0]=1;\n\tfor (int i=1;i<N;i++)fac[i]=fac[i-1]*i%M,inv[i]=ksm(fac[i],M-2);\n\tfor (int i=m&1;i<=m;i+=2)\n\t\t(ans+=C(n+(3*m-i)/2-1,n-1)*C(n,i))%=M;\n\tfor (int i=m&1;i<=m;i+=2)\n\t\t(ans+=M-n*C(n+(m-i)/2-1,n-1)%M*C(n,i)%M)%=M;\n\tn--;\n\tfor (int i=m&1;i<=m;i+=2)\n\t\t(ans+=(n+1)*C(n+(m-i)/2-1,n-1)%M*C(n,i)%M)%=M;\t\t\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n, m; scanf(\"%d%d\", &n, &m);\n    constexpr int kMod = 998244353;\n    vector<int> fc(3 * m + n, 1), iv(3 * m + n, 1);\n\n    auto fpow = [&](int a, int n) {\n        int res = 1;\n        while (n > 0) {\n            if (n & 1) res = 1LL * res * a % kMod;\n            a = 1LL * a * a % kMod;\n            n >>= 1;\n        }\n        return res;\n    };\n\n    for (int i = 1; i < fc.size(); ++i) {\n        fc[i] = 1LL * fc[i - 1] * i % kMod;\n        iv[i] = fpow(fc[i], kMod - 2);\n    }\n\n    auto Choose = [&](int n, int k) {\n        if (n < k || k < 0) return 0LL;\n        return 1LL * fc[n] * iv[k] % kMod * iv[n - k] % kMod;\n    };\n\n    int ans = 0;\n    for (int i = 0; i <= m; ++i) {\n        if ((3 * m - i) % 2 != 0) continue;\n        ans += 1LL * Choose((3 * m - i) / 2 + n - 1, n - 1) * Choose(n, i) % kMod;\n        ans %= kMod;\n    }\n\n    vector<int> a(m), b(m);\n    for (int i = 0; i < m; ++i) a[i] = Choose(n - 1, i);\n    for (int i = 0; i < m; i += 2) b[i] = Choose(i / 2 + n - 2, n - 2);\n\n    int sub = 0, y = 0;\n    for (int i = m - 1, j = 0; i >= 0; --i) {\n        while (j < m && i + j < m) (y += b[j++]) %= kMod;\n        sub += 1LL * a[i] * y % kMod;\n        if (sub >= kMod) sub -= kMod;\n    }\n    sub = 1LL * sub * n % kMod;\n    printf(\"%d\\n\", (ans + kMod - sub) % kMod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\nll mod=998244353;\n\nll fac[3000010];\n \nll modinv(ll a){\n    ll b=mod,u=1,v=0;\n    while(b){\n        ll t=a/b;\n        a-=t*b; swap(a,b);\n        u-=t*v; swap(u,v);\n        }\n        u%=mod;\n        if(u<0) u+=mod;\n    return u;\n}\n \nvoid modfac(){\n    fac[0]=1;\n    for(ll i=1;i<3000010;i++){\n        fac[i]=(fac[i-1]*i)%mod;\n    }\n}\n \nll modperm(ll n,ll k){\n    if(n<0||k<0||n<k) return 0;\n    else return (fac[n]*modinv(fac[n-k]))%mod;\n}\n \nll modcomb(ll n,ll k){\n    if(n<0||k<0||n<k) return 0;\n    else return ((fac[n]*modinv(fac[k]))%mod*modinv(fac[n-k]))%mod;\n}\n\nll modhom(ll n,ll k){\n  if(n==0&&k==0) return 1;\n  else if(n<0||k<0) return 0;\n  else return modcomb(n+k-1,k);\n}\n \nll modpow(ll a,ll b){\n  ll ans=1;\n  a%=mod;\n  while(b){\n    if(b&1) ans=ans*a%mod;\n    a=a*a%mod;\n    b>>=1;\n  }\n  return ans;\n}\n\nint main(){\n  modfac();\n  ll n,m;\n  cin >> n >> m;\n  ll ans=modhom(n,3*m);\n  for(ll i=0;i<m;i++){\n    ans=(ans-n*modhom(n-1,i)%mod+mod)%mod;\n  }\n  for(ll i=m+1;i<=n;i++){\n    if((3*m-i)%2==0){\n      ans=(ans-modcomb(n,i)*modhom(n,(3*m-i)/2)%mod+mod)%mod;\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\ntemplate<unsigned MOD_> struct ModInt {\n    static const unsigned MOD = MOD_;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const { return pow(MOD-2); }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n\n    ModInt extgcd() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\n//const LL MOD = 1000000007;\nconst LL MOD = 998244353;\ntypedef ModInt<MOD> Mint;\nconst int MAX = 4000011;\nMint inv[MAX], fact[MAX], fact_inv[MAX];\n\nvoid init() {\n    fact[0] = 1;\n    for (int i=1; i<MAX; i++) fact[i] = fact[i-1] * i;\n    fact_inv[MAX-1] = fact[MAX-1].inv();\n    for (int i=MAX-2; i>=0; i--) fact_inv[i] = fact_inv[i+1] * (i+1);\n    inv[0] = 0;\n    for (int i=1; i<MAX; i++) inv[i] = fact_inv[i] * fact[i-1];\n}\n\nMint nCk(int n, int k) {\n    assert(n < MAX);\n    assert(k <= n);\n    return fact[n] * fact_inv[k] * fact_inv[n-k];\n}\nMint f(int ball, int men) {\n    return nCk(ball + men - 1, ball);\n}\n\nint N, M;\n\nvoid MAIN() {\n    init();\n    scanf(\"%d%d\", &N, &M);\n\n    Mint way = f(3*M, N);\n    for (int hi=2*M+1; hi<=3*M; hi++) {\n\tway -= f(3*M - hi, N-1) * N;\n    }\n\n    for (int p=0; p<=M-1; p++) {\n\tint r = 3*M - 2*p;\n\tif (r <= N) {\n\t    way -= f(p, N) * nCk(N, r);\n\t}\n    }\n\n    printf(\"%d\\n\", way.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, m, n) for(int(i) = (int)(m); i < (int)(n); ++i)\n#define rep2(i, m, n) for(int(i) = (int)(n)-1; i >= (int)(m); --i)\n#define REP(i, n) rep(i, 0, n)\n#define REP2(i, n) rep2(i, 0, n)\n#define all(hoge) (hoge).begin(), (hoge).end()\n#define en '\\n'\nusing ll = long long;\nusing ull = unsigned long long;\ntemplate <class T>\nusing vec = vector<T>;\ntemplate <class T>\nusing vvec = vector<vec<T>>;\ntypedef pair<ll, ll> P;\nusing tp = tuple<ll, ll, ll>;\nconstexpr long long INF = 1LL << 60;\nconstexpr int INF_INT = 1 << 25;\n//constexpr long long MOD = (ll)1e9 + 7;\nconstexpr long long MOD = 998244353LL;\nusing ld = long double;\nstatic const ld pi = 3.141592653589793L;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\n\ntemplate <class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n//グラフ関連\nstruct Edge {\n    ll to, cap, rev;\n    Edge(ll _to, ll _cap, ll _rev) {\n        to = _to;\n        cap = _cap;\n        rev = _rev;\n    }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &G, ll from, ll to, ll cap, bool revFlag, ll revCap) {\n    G[from].push_back(Edge(to, cap, (ll)G[to].size()));\n    if(revFlag)\n        G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));\n}\n\ntemplate <int mod>\nstruct ModInt {\n    int x;\n\n    ModInt() : x(0) {}\n\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= mod)\n            x -= mod;\n        return *this;\n    }\n\n    ModInt &operator-=(const ModInt &p) {\n        if((x += mod - p.x) >= mod)\n            x -= mod;\n        return *this;\n    }\n\n    ModInt &operator*=(const ModInt &p) {\n        x = (int)(1LL * x * p.x % mod);\n        return *this;\n    }\n\n    ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n\n    ModInt operator-() const { return ModInt(-x); }\n\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n    bool operator==(const ModInt &p) const { return x == p.x; }\n\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n\n    ModInt inverse() const {\n        int a = x, b = mod, u = 1, v = 0, t;\n        while(b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n\n    ModInt pow(int64_t n) const {\n        ModInt ret(1), mul(x);\n        while(n > 0) {\n            if(n & 1)\n                ret *= mul;\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt &p) {\n        return os << p.x;\n    }\n\n    friend istream &operator>>(istream &is, ModInt &a) {\n        int64_t t;\n        is >> t;\n        a = ModInt<mod>(t);\n        return (is);\n    }\n\n    static int get_mod() { return mod; }\n};\n\nusing mint = ModInt<MOD>;\n\n// 二項係数ライブラリ\ntemplate <class T>\nstruct Combination {\n    vector<T> fact_, inv_, finv_;\n    constexpr Combination() {}\n    constexpr Combination(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n + 1);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].get_mod();\n        for(int i = 2; i < n; i++) {\n            fact_[i] = fact_[i - 1] * i;\n            inv_[i] = -inv_[MOD % i] * (MOD / i);\n            finv_[i] = finv_[i - 1] * inv_[i];\n        }\n    }\n    constexpr T nPr(int n, int k) const noexcept {\n        if(n < k || n < 0 || k < 0)\n            return 0;\n        return fact_[n] * finv_[n - k];\n    }\n    constexpr T nCr(int n, int k) const noexcept {\n        if(n < k || n < 0 || k < 0)\n            return 0;\n        return fact_[n] * finv_[k] * finv_[n - k];\n    }\n    constexpr T nHr(int n, int k) const noexcept {\n        if(n < k || n < 0 || k < 0)\n            return 0;\n        return nCr(n + k - 1, k);\n    }\n    constexpr T fact(int n) const noexcept {\n        if(n < 0)\n            return 0;\n        return fact_[n]; //n!\n    }\n    constexpr T inv(int n) const noexcept {\n        if(n < 0)\n            return 0;\n        return inv_[n]; //1/n\n    }\n    constexpr T finv(int n) const noexcept {\n        if(n < 0)\n            return 0;\n        return finv_[n]; //1/n!\n    }\n};\n\nvoid solve() {\n    ll n, m;\n    cin >> n >> m;\n\n    Combination<mint> com(2 * m + n);\n\n    mint ans = 0;\n    REP(i, m + 1) {\n        if((m - i) % 2)\n            continue;\n        ans += com.nCr((m - i) / 2 + m + n - 1, n - 1) * com.nCr(n, i); //i箇所奇数にする\n    }\n    ans -= com.nCr(m - 1 + n - 1, n - 1) * n; //2*m+1以上選ばれるパターンはアウト\n    cout << ans << en;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    /*\n    ll t;\n    cin >> t;\n    while(t--)*/\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#define ll long long\n#define mod 998244353\n#define Mod1(x) (x>=mod?x-mod:x)\n#define Mod2(x) (x<0?x+mod:x)\n#define maxn 3000010\ninline ll read()\n{\n    ll x=0; char c=getchar(),f=1;\n    for(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n    for(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n    return x*f;\n}\ninline void write(ll x)\n{\n    static int buf[20],len; len=0;\n    if(x<0)x=-x,putchar('-');\n    for(;x;x/=10)buf[len++]=x%10;\n    if(!len)putchar('0');\n    else while(len)putchar(buf[--len]+'0');\n}\ninline void writeln(ll x){write(x); putchar('\\n');}\ninline void writesp(ll x){write(x); putchar(' ');}\nll fac[maxn],inv[maxn];\nint n,m;\ninline ll power(ll a,ll b)\n{\n    ll ans=1;\n    for(;b;b>>=1,a=a*a%mod)\n        if(b&1)ans=ans*a%mod;\n    return ans;\n}\ninline ll C(int n,int m){return fac[n]*inv[m]%mod*inv[n-m]%mod;}\ninline ll calc(int n,int m,int k)\n{\n    ll sum=0;\n    for(int i=0;i<=n&&i<=k;i++)\n        if(!((m-i)&1)&&m>=i)sum=(sum+C(n,i)*C((m-i)/2+n-1,n-1))%mod;\n    // writeln(sum);\n    return sum;\n}\nint main()\n{\n    n=read(); m=read();\n    fac[0]=inv[0]=1;\n    for(int i=1;i<=n+3*m;i++){\n        fac[i]=fac[i-1]*i%mod;\n        inv[i]=power(fac[i],mod-2);\n    }\n    ll ans=(calc(n,3*m,m)-n*(calc(n,m,m)-calc(n-1,m,m)+mod))%mod;\n    writeln(Mod2(ans));\n    return 0;\n}\n\nagc036C"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<string.h>\nusing namespace std;\ntypedef long long ll;\nconst ll M=998244353;\nint n,i,j,m;\nll p[5000005],inv[5000005],ans;\nll C(ll n,ll m)\n{\n\tif(n<m)\n\t\treturn 0;\n\treturn p[n]*inv[m]%M*inv[n-m]%M;\n}\nll qpow(ll a,ll b)\n{\n\tll s=a,ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t\tans=ans*s%M;\n\t\ts=s*s%M;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tp[0]=p[1]=inv[1]=1;\n\tfor(i=2;i<=m*3+n;i++)\n\t{\n\t\tp[i]=p[i-1]*i%M;\n\t\tinv[i]=(M-M/i)*inv[M%i]%M;\n\t}\n\tinv[0]=1;\n\tfor(i=2;i<=m*3+n;i++)\n\t\tinv[i]=inv[i]*inv[i-1]%M;\n\tans=C(m*3+n-1,n-1)-C(m+n-2,n-1)*n%M;\n\tfor(i=m+1;i<=m*3&&i<=n;i++)\n\t\tif((m*3-i)%2==0)\n\t\t\tans=(ans-C(n,i)*C(n+(m*3-i)/2-1,n-1))%M;\n\tcout<<(ans%M+M)%M;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nconst ll mo=998244353;\nconst int NUM_=4400001;\nstatic ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];\n\n\nll comb(ll N_, ll C_) {\n\tif (fact[0]==0) {\n\t\tinv[1]=fact[0]=factr[0]=1;\n\t\tfor (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\t\tfor (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;\n\t}\n\tif(C_<0 || C_>N_) return 0;\n\treturn factr[C_]*fact[N_]%mo*factr[N_-C_]%mo;\n}\nll hcomb(int P_,int Q_) { return (P_==0&&Q_==0)?1:comb(P_+Q_-1,Q_);}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M;\n\t\n\tll ret=0;\n\tfor(i=0;i<=min(N,M);i++) {\n\t\tint lef=3*M-i;\n\t\tif(lef%2) continue;\n\t\tlef=lef/2;\n\t\tret+=comb(N,i)*hcomb(N,lef)%mo;\n\t}\n\t\n\tfor(i=2*M+1;i<=3*M;i++) ret-=N*hcomb(N-1,3*M-i)%mo;\n\t\n\t\n\tcout<<(ret%mo+mo)%mo<<endl;\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 998244353;\n\nclass combination_mod{\n  const long long mod;\n  const long long size;\n  \n  vector<long long> fact; //n!\n  vector<long long> fact_inv; // (n!)^-1\n\n  void make_fact(){\n    fact[0] = 1;\n    for(long long i=1; i<size; i++){\n      fact[i] = fact[i-1]*i % mod;\n    }\n  }\n\n  void make_fact_inv(){\n    fact_inv[0] = fact_inv[1] = 1;\n    for(long long i=2; i<size; i++){\n      fact_inv[i] = fact_inv[mod%i] * (mod - mod/i) % mod;  // x ^ -1\n    }\n    for(int i=2; i<size; i++){\n      fact_inv[i] = fact_inv[i-1] * fact_inv[i] % mod;  // x! ^ -1\n    }\n  }\n\npublic:\n  combination_mod(long long mod_, long long size_ = 2000000) : mod(mod_), size(size_+1){\n    fact.resize(size);\n    fact_inv.resize(size);\n    make_fact();\n    make_fact_inv();\n  }\n\n  //nCk mod p O(1)\n  long long operator()(long long n, long long k){\n    if(k==0 || n==k) return 1;\n    long long ret = fact[n] * fact_inv[k] % mod * fact_inv[n-k] % mod;\n    return ret;\n  }\n};\n\n\nint main(){\n  int n,m;\n  cin >> n,m;\n\n  combination_mod c(mod, n+m*3*10);\n\n  vector<long long> dp(n+m*3+10, 0);\n  for(long long x=n-2; x<=n+m*3; x++){\n    dp[x] = c(x, n-2);\n  }\n  for(long long x=n-2; x<=n+m*3; x++){\n    dp[x] = (dp[x] + dp[x-1])% mod;\n  }\n\n  long long ans = 0;\n  for(long long odd=0; odd<=m; odd++){\n    long long rem = 3*m - odd;\n    if(rem%2 != 0) continue;\n    rem /= 2;\n    long long p_box = c(n, odd);\n    long long p_ball = c(rem + n-1, n-1);\n    long long tmp = p_ball;\n    // 2m on an odd box\n    if(rem >= m){\n      long long a = odd;\n      long long b = c(rem - m + n-1 - 1, n-1 -1);\n      tmp = (tmp - a * b % mod + mod) % mod;\n    }\n    // for(long long k=1; m+k<=rem; k++){ // 2m + 2k box\n    //   long long b = c(rem - (m + k) + n-1 -1, n-1 -1);\n    //   tmp = (tmp - b * n % mod + mod) % mod;\n    // }\n    if(rem - (m+1) >= 0){\n      long long s = dp[rem - (m+1) + n-1 -1];\n      tmp = (tmp - s * n % mod + mod) % mod;\n    }\n    ans = ans + tmp * p_box;\n    ans %= mod;\n  }\n  println(ans);\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<stack>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<cstring>\n#include<complex>\n#include<bitset>\n#include<iostream>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> Q;\ntypedef complex<double> C;\n#define cx real()\n#define cy imag()\nconst ll INF = 1LL << 60;\nconst double DINF = 1e30;\nconst ll mod = 998244353;\nconst ll dx[4] = {1, 0, -1, 0};\nconst ll dy[4] = {0, -1, 0, 1};\nconst C I = C(0, 1);\nconst double EPS = 1e-10;\nconst ll NCK_MAX = 510000;\n\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y) {\n  if (b == 0) {\n    x = 1, y = 0; return a;\n  }\n  ll q = a/b, g = extgcd(b, a - q*b, x, y);\n  ll z = x - q * y;\n  x = y;\n  y = z;\n  return g;\n}\n\nll invmod (ll a, ll m) { // a^-1 mod m\n  ll x, y;\n  extgcd(a, m, x, y);\n  x %= m;\n  if (x < 0) x += m;\n  return x;\n}\n\nll *fac, *finv, *inv;\n\nvoid nCk_init(ll mod) {\n  fac = new ll[NCK_MAX];\n  finv = new ll[NCK_MAX];\n  inv = new ll[NCK_MAX];\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (ll i = 2; i < NCK_MAX; i++) {\n    fac[i] = fac[i-1] * i % mod;\n    inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n    finv[i] = finv[i-1] * inv[i] % mod;\n  }\n}\n\nll nCk(ll n, ll k, ll mod) {\n  if (fac == NULL) nCk_init(mod);\n  if (n < k) return 0;\n  if (n < 0 || k < 0) return 0;\n  return fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\ntemplate <typename T>\nclass Zip {\n  vector<T> d;\n  bool flag;\n  void init() {\n    sort(d.begin(), d.end());\n    d.erase(unique(d.begin(), d.end()), d.end());\n    flag = false;\n  }\npublic:\n  Zip() {\n    flag = false;\n  }\n  void add(T x) {\n    d.push_back(x);\n    flag = true;\n  }\n  ll getNum(T x) {\n    if (flag) init();\n    return lower_bound(d.begin(), d.end(), x) - d.begin();\n  }\n  ll size() {\n    if (flag) init();\n    return (ll)d.size();\n  }\n};\n\nclass UnionFind {\n  vector<ll> par, rank; // par > 0: number, par < 0: -par\npublic:\n  UnionFind(ll n) : par(n, 1), rank(n, 0) {}\n  ll getSize(ll x) {\n    return par[find(x)];\n  }\n  ll find(ll x) {\n    if (par[x] > 0) return x;\n    return -(par[x] = -find(-par[x]));\n  }\n  void merge(ll x, ll y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (rank[x] < rank[y]) {\n      par[y] += par[x];\n      par[x] = -y;\n    } else {\n      par[x] += par[y];\n      par[y] = -x;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n  }\n  bool isSame(ll x, ll y) {\n    return find(x) == find(y);\n  }\n};\n\n\ntemplate <typename T>\nclass SegmentTree {\n  ll n;\n  vector<T> node;\n  function<T(T, T)> fun, fun2;\n  bool customChange;\n  T outValue, initValue;\npublic:\n  void init(ll num, function<T(T, T)> resultFunction, T init, T out, function<T(T, T)> changeFunction = NULL) {\n    // changeFunction: (input, beforevalue) => newvalue\n    fun = resultFunction;\n    fun2 = changeFunction;\n    customChange = changeFunction != NULL;\n    n = 1;\n    while (n < num) n *= 2;\n    node.resize(2 * n - 1);\n    fill(node.begin(), node.end(), init);\n    outValue = out;\n    initValue = init;\n  }\n  void valueChange(ll num, T value) {\n    num += n-1;\n    if (customChange) node[num] = fun2(value, node[num]);\n    else node[num] = value;\n    while (num > 0) num = (num - 1) / 2, node[num] = fun(node[num * 2 + 1], node[num * 2 + 2]);\n  }\n  T rangeQuery(ll a, ll b, ll l = 0, ll r = -1, ll k = 0) { // [a, b)\n    if (r == -1) r = n;\n    if (a <= l && r <= b) return node[k];\n    if (b <= l || r <= a) return outValue;\n    ll mid = (l + r) / 2;\n    return fun(rangeQuery(a, b, l, mid, 2*k+1), rangeQuery(a, b, mid, r, 2*k+2));\n  }\n};\n\ntemplate <typename T>\nclass Graph {\n  struct edge { ll to; T cost; };\n  struct edge_data { ll from, to; T cost; };\n\n  ll v;\n  vector<vector<edge>> e, re;\n  vector<edge_data> ed;\n  vector<bool> used;\n  vector<ll> vs, cmp;\n  bool isDirected, isMinasEdge;\npublic:\n  Graph(ll _v, bool _isDirected = true, ll range_add = 0) {\n    // range_add 0:no / 1:in / 2:out / 3:in+out\n    //_v++;\n    v = _v, isDirected = _isDirected; isMinasEdge = false;\n    e.resize(v), re.resize(v);\n  }\n  void add_edge(ll s, ll t, T cost = 1) {\n    e[s].push_back((edge){t, cost});\n    if (!isDirected) e[t].push_back((edge){s, cost});\n    else re[t].push_back((edge){s, cost});\n    ed.push_back((edge_data){s, t, cost});\n    if (cost < 0) isMinasEdge = true;\n  }\n  vector<T> dijkstra(ll s) {\n    vector<T> d(v, INF);\n    d[s] = 0;\n    auto edge_cmp = [](const edge& a, const edge& b) { return a.cost > b.cost; };\n    priority_queue<edge, vector<edge>, decltype(edge_cmp)> pq(edge_cmp);\n    pq.push((edge){s, 0});\n    while (!pq.empty()) {\n      edge temp = pq.top(); pq.pop();\n      if (d[temp.to] < temp.cost) continue;\n      for (const edge& next : e[temp.to]) {\n        T cost = temp.cost + next.cost;\n        if (d[next.to] > cost) {\n          d[next.to] = cost;\n          pq.push((edge){next.to, cost});\n        }\n      }\n    }\n    return d;\n  }\n  vector<T> bellmanford(ll s) {\n    vector<T> d(v, INF);\n    d[s] = 0;\n    for (ll i = 0; i < v; i++) {\n      for (const edge_data& temp : ed) {\n        if (d[temp.from] != INF && d[temp.to] > d[temp.from] + temp.cost) d[temp.to] = d[temp.from] + temp.cost;\n        if (!isDirected && d[temp.to] != INF && d[temp.from] > d[temp.to] + temp.cost) d[temp.from] = d[temp.to] + temp.cost;\n      }\n    }\n    for (ll i = 0; i < v; i++) {\n      for (const edge_data& temp : ed) {\n        if (d[temp.from] != INF && d[temp.to] > d[temp.from] + temp.cost) d[temp.to] = -INF;\n        if (!isDirected && d[temp.to] != INF && d[temp.from] > d[temp.to] + temp.cost) d[temp.from] = -INF;\n      }\n    }\n    return d;\n  }\n  vector<T> shortest_path(ll s) {\n    if (isMinasEdge) return bellmanford(s);\n    else return dijkstra(s);\n  }\n  T kruskal() {\n    // if (isDirected)\n    UnionFind uf(v);\n    auto edge_data_cmp = [](const edge_data& a, const edge_data& b) { return a.cost < b.cost; };\n    sort(ed.begin(), ed.end(), edge_data_cmp);\n    T ans = 0;\n    for (const edge_data& temp : ed) {\n      if (uf.isSame(temp.from, temp.to)) continue;\n      uf.merge(temp.from, temp.to);\n      ans += temp.cost;\n    }\n    return ans;\n  }\n  void scc_dfs(ll s) {\n    used[s] = true;\n    for (const edge& i : e[s]) if (!used[i.to]) scc_dfs(i.to);\n    vs.push_back(s);\n  }\n  void scc_rdfs(ll s, ll k) {\n    used[s] = true;\n    cmp[s] = k;\n    for (const edge& i : re[s]) if (!used[i.to]) scc_rdfs(i.to, k);\n  }\n  vector<ll> scc() {\n    used.resize(v);\n    fill(used.begin(), used.end(), false);\n    cmp.resize(v);\n    vs.clear();\n    for (ll i = 0; i < v; i++) if (!used[i]) scc_dfs(i);\n    used.resize(v);\n    fill(used.begin(), used.end(), false);\n    ll k = 0;\n    for (ll i = vs.size() - 1; i >= 0; i--) if (!used[vs[i]]) scc_rdfs(vs[i], k++);\n    return cmp;\n  }\n};\n\nll n, m, ans;\n\nint main() {\n  scanf(\"%lld%lld\", &n, &m);\n  for (ll i = 0; i <= min(n, m); i++) if ((3 * m - i) % 2 == 0) {\n    ll j = (3 * m - i) / 2;\n    ans += nCk(n, i, mod) * nCk(n-1+j, j, mod) % mod;\n    if (ans >= mod) ans -= mod;\n  }\n  for (ll i = 2*m+1; i <= 3*m; i++) {\n    ll j = 3 * m - i;\n    ans -= nCk(j+n-2, j, mod) * n % mod;\n    if (ans < 0) ans += mod;\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\nconst int oo=2139063143;\nconst int N=30010000;\nconst int P=998244353;\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\n//char buf[1<<24],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ntemplate <typename T>\ninline void sc (T &x)\n{\n    x=0; static int p; p=1; static char c; c=getchar();\n    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }\n    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }\n    x*=p;\n}\ntemplate <typename T>\ninline void print (T x)\n{\n\tif (x< 0) putchar('-'),x=-x;\n\tif (x>=10) print(x/10);\n\tputchar(x%10+'0');\n}\ntemplate <typename T>\ninline void pr (T x) { print(x),putchar('\\n'); }\nvoid del(int &x,int y) { x+=y; x=x>=P?x-P:x; }\nint ksm (int a,int b)\n{\n\tint ans=1;\n\twhile (b)\n\t{\n\t\tif (b&1) ans=(LL)ans*a%P;\n\t\ta=(LL)a*a%P,b>>=1;\n\t}\n\treturn ans;\n}\nint jc[N],inv[N];\nvoid init (int n)\n{\n\tjc[0]=1;\n\tfor (int i=1; i<=n; i++)\n\t\tjc[i]=(LL)i*jc[i-1]%P;\n\tinv[n]=ksm (jc[n],P-2);\n\tfor (int i=n-1; i>=0; i--)\n\t\tinv[i]=(LL)inv[i+1]*(i+1)%P;\n}\nint C(int n,int m) { return (n< 0||m< 0||m> n)?0:(LL)jc[n]*inv[m]%P*inv[n-m]%P; }\nint T(int n,int m) { return C(n+m-1,m-1); }\nint calc (int n,int odd,int sum)\n{\n\tint ans=0;\n\tfor (int i=odd; i>=0; i-=2)\n\t{\n\t\tint las=sum-i;\n\t\tint g=(LL)C(n,i)*T(las>>1,n)%P;\n\t\tdel(ans,g);\n\t}\n\treturn ans;\n}\nint main ()\n{\n\t// freopen (\".in\",\"r\",stdin);\n\t// freopen (\".out\",\"w\",stdout);\n\tint n,m; sc(n),sc(m);\n\tinit (n+m*2);\n\tint ans=calc (n,m,3*m);\n\tint g=(LL)n*calc (n,m-1,m-1)%P;\n\tdel(ans,P-g);\n\tpr(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 998244353;\n\nclass combination_mod{\n  const long long mod;\n  const long long size;\n  \n  vector<long long> fact; //n!\n  vector<long long> fact_inv; // (n!)^-1\n\n  void make_fact(){\n    fact[0] = 1;\n    for(long long i=1; i<size; i++){\n      fact[i] = fact[i-1]*i % mod;\n    }\n  }\n\n  void make_fact_inv(){\n    fact_inv[0] = fact_inv[1] = 1;\n    for(long long i=2; i<size; i++){\n      fact_inv[i] = fact_inv[mod%i] * (mod - mod/i) % mod;  // x ^ -1\n    }\n    for(int i=2; i<size; i++){\n      fact_inv[i] = fact_inv[i-1] * fact_inv[i] % mod;  // x! ^ -1\n    }\n  }\n\npublic:\n  combination_mod(long long mod_, long long size_ = 2000000) : mod(mod_), size(size_+1){\n    fact.resize(size);\n    fact_inv.resize(size);\n    make_fact();\n    make_fact_inv();\n  }\n\n  //nCk mod p O(1)\n  long long operator()(long long n, long long k){\n    if(k==0 || n==k) return 1;\n    long long ret = fact[n] * fact_inv[k] % mod * fact_inv[n-k] % mod;\n    return ret;\n  }\n};\n\n\nint main(){\n  int n,m;\n  cin >> n,m;\n\n  combination_mod c(mod, n+m*3*10);\n\n  vector<long long> dp(n+m*3+10, 0);\n  for(long long x=n-2; x<=n+m*3; x++){\n    dp[x] = c(x, n-2);\n  }\n  for(long long x=n-2; x<=n+m*3; x++){\n    dp[x] = (dp[x] + dp[x-1])% mod;\n  }\n\n  long long ans = 0;\n  for(long long odd=0; odd<=m; odd++){\n    long long rem = 3*m - odd;\n    if(rem%2 != 0) continue;\n    rem /= 2;\n    long long p_box = c(n, odd);\n    long long p_ball = c(rem + n-1, n-1);\n    long long tmp = p_ball;\n    // 2m on an odd box\n    if(rem >= m){\n      long long a = odd;\n      long long b = c(rem - m + n-1 - 1, n-1 -1);\n      tmp = (tmp - a * b % mod + mod) % mod;\n    }\n    // for(long long k=1; m+k<=rem; k++){ // 2m + 2k box\n    //   long long b = c(rem - (m + k) + n-1 -1, n-1 -1);\n    //   tmp = (tmp - b * n % mod + mod) % mod;\n    // }\n    if(rem - (m+1) + n-1 -1 >= 0){\n      long long s = dp[rem - (m+1) + n-1 -1];\n      tmp = (tmp - s * n % mod + mod) % mod;\n    }\n    ans = ans + tmp * p_box;\n    ans %= mod;\n  }\n  println(ans);\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████\n#include \"bits/stdc++.h\"\nusing namespace std;\n//#define MOD 1000000007\n#define MOD 998244353\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define D double\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\n\n#include <cstdint>\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\n  u64 a;\n\npublic:\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 val() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr bool operator==(const modint rhs) const noexcept {\n    return modint(*this).val() == rhs.val();\n  }\n  modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\nusing mint = modint<MOD>;\n\ntypedef vector<mint> vec;\ntypedef vector<vector<mint>> mat;\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,m;\n  cin >> n >> m;\n\n  vec fact(n+3*m+10,1);\n  REP(i,n+3*m+9) fact[i+1] = fact[i]*(i+1);\n\n  mint ans = fact[n-1+3*m]/fact[n-1]/fact[3*m];\n\n  ans -= fact[n-1+m-1]/fact[m-1]/fact[n-1]*n;\n\n  cout << ans.val() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<stack>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<cstring>\n#include<complex>\n#include<bitset>\n#include<iostream>\nusing namespace std;\n\n/**** Type Define ****/\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> Q;\ntypedef complex<double> C;\n\n/**** Macro Define ****/\n\n#define cx real()\n#define cy imag()\n\n/**** Const List   ****/\n\nconst ll INF = 1LL << 60;\nconst double DINF = 1e30;\nconst ll mod = 998244353;\nconst ll MAX_FLOW_MAX_V = 10000;\nconst ll MIN_COST_FLOW_MAX_V = 10000;\nconst ll BIPARTITE_MATCHING_MAX_V = 10000;\nconst ll dx[4] = {1, 0, -1, 0};\nconst ll dy[4] = {0, -1, 0, 1};\nconst C I = C(0, 1);\nconst double EPS = 1e-10;\nconst ll NCK_MAX = 3100000;\n\n/**** General Functions ****/\n\ntemplate <typename T>\nT tmin(T a, T b) { return a > b ? b : a; };\n\ntemplate <typename T>\nT tmax(T a, T b) { return a > b ? a : b; };\n\ntemplate <typename T>\nT tadd(T a, T b) { return a + b; };\n\ntemplate <typename T>\nT tmul(T a, T b) { return a * b; };\n\ntemplate <typename T>\nT tpow(T a, T b) { return a * b; };\n\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y) {\n  if (b == 0) {\n    x = 1, y = 0; return a;\n  }\n  ll q = a/b, g = extgcd(b, a - q*b, x, y);\n  ll z = x - q * y;\n  x = y;\n  y = z;\n  return g;\n}\n\nll invmod (ll a, ll m) { // a^-1 mod m\n  ll x, y;\n  extgcd(a, m, x, y);\n  x %= m;\n  if (x < 0) x += m;\n  return x;\n}\n\nll *fac, *finv, *inv;\n\nvoid nCk_init(ll mod) {\n  fac = new ll[NCK_MAX];\n  finv = new ll[NCK_MAX];\n  inv = new ll[NCK_MAX];\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (ll i = 2; i < NCK_MAX; i++) {\n    fac[i] = fac[i-1] * i % mod;\n    inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n    finv[i] = finv[i-1] * inv[i] % mod;\n  }\n}\n\nll nCk(ll n, ll k, ll mod) {\n  if (fac == NULL) nCk_init(mod);\n  if (n < k) return 0;\n  if (n < 0 || k < 0) return 0;\n  return fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\nll lmin(ll a, ll b) { return a > b ? b : a; };\n\nll lmax(ll a, ll b) { return a > b ? a : b; };\n\nll lsum(ll a, ll b) { return a + b; };\n\n/**** Matrix ****/\n\ntemplate <typename T>\nstruct Matrix {\n  typedef vector<T> vec;\n  typedef vector<vec> mat;\n  ll x, y; // x: horizon  y: vertical\n  mat d;\n\n  Matrix(ll _y, ll _x = -1) {\n    if (_x == -1) _x = _y;\n    x = _x, y = _y;\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) d[i][j] = 0;\n  }\n  void unit() {\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) d[i][j] = i == j ? 1 : 0;\n  }\n  Matrix copy() {\n    Matrix m(y, x);\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) m.d[i][j] = d[i][j];\n    return m;\n  }\n  Matrix<T> operator + (Matrix<T>& t) { // No error check! Don't forget to check Matrix size!!\n    Matrix<T> m(y, x);\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) m.d[i][j] = d[i][j] + t.d[i][j];\n    return m;\n  }\n  Matrix<T> operator - (Matrix<T>& t) {\n    Matrix<T> m(y, x);\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) m.d[i][j] = d[i][j] - t.d[i][j];\n    return m;\n  }\n  Matrix<T> operator * (T t) {\n    Matrix<T> m(y, x);\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) m.d[i][j] = d[i][j] * t;\n    return m;\n  }\n  Matrix<T> det(Matrix<T>& t) { // x need to correspond to t.y\n    Matrix<T> m(y, x);\n    for (int i = 0; i < y; i++)\n      for (int j = 0; j < x; j++)\n        for (int k = 0; k < t.x; k++) m.d[i][j] += d[i][k] * t.d[k][j]; ////////////// mod???\n    return m;\n  }\n};\n\n/**** Zip ****/\n\ntemplate <typename T>\nclass Zip {\n  vector<T> d;\n  bool flag;\npublic:\n  Zip() {\n    flag = false;\n  }\n  void add(T x) {\n    d.push_back(x);\n    flag = true;\n  }\n  ll getNum(T x) { // T need to have operator < !!\n    if (flag) {\n      sort(d.begin(), d.end());\n      d.erase(unique(d.begin(), d.end()), d.end());\n      flag = false;\n    }\n    return lower_bound(d.begin(), d.end(), x) - d.begin();\n  }\n  ll size() {\n    if (flag) {\n      sort(d.begin(), d.end());\n      d.erase(unique(d.begin(), d.end()), d.end());\n      flag = false;\n    }\n    return (ll)d.size();\n  }\n};\n\n/**** Union Find ****/\n\nclass UnionFind {\n  vector<ll> par, rank; // par > 0: number, par < 0: -par\npublic:\n  void init(ll n) {\n    par.resize(n, 1); rank.resize(n, 0);\n  }\n  ll getSize(ll x) {\n    return par[find(x)];\n  }\n  ll find(ll x) {\n    if (par[x] > 0) return x;\n    return -(par[x] = -find(-par[x]));\n  }\n  void merge(ll x, ll y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (rank[x] < rank[y]) {\n      par[y] += par[x];\n      par[x] = -y;\n    } else {\n      par[x] += par[y];\n      par[y] = -x;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n  }\n  bool isSame(ll x, ll y) {\n    return find(x) == find(y);\n  }\n};\n\ntemplate <typename T>\nstruct UnionFindT {\n  vector<ll> par;\n  vector<ll> rank;\n  vector<T> diff_weight;\n\n  UnionFindT(ll n = 1, T SUM_UNITY = 0) {\n    init(n, SUM_UNITY);\n  }\n\n  void init(ll n = 1, T SUM_UNITY = 0) {\n    par.resize(n); rank.resize(n); diff_weight.resize(n);\n    for (ll i = 0; i < n; ++i) par[i] = i, rank[i] = 0, diff_weight[i] = SUM_UNITY;\n  }\n\n  ll find(ll x) {\n    if (par[x] == x) {\n      return x;\n    }\n    else {\n      ll r = find(par[x]);\n        diff_weight[x] += diff_weight[par[x]];\n        return par[x] = r;\n    }\n  }\n\n  T weight(ll x) {\n    find(x);\n    return diff_weight[x];\n  }\n\n  bool isSame(ll x, ll y) {\n    return find(x) == find(y);\n  }\n\n  bool merge(ll x, ll y, T w) {\n    w += weight(x); w -= weight(y);\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (rank[x] < rank[y]) swap(x, y), w = -w;\n    if (rank[x] == rank[y]) ++rank[x];\n    par[y] = x;\n    diff_weight[y] = w;\n    return true;\n  }\n\n  T diff(ll x, ll y) {\n    return weight(y) - weight(x);\n  }\n};\n\nclass PersistentUnionFind {\n  vector<ll> rank, fin, par;\n  ll index;\npublic:\n  void init(ll n) {\n    index = 0;\n    par.resize(n); rank.resize(n, 1); fin.resize(n, 0);\n    for (ll i = 0; i < n; i++) par[i] = i;\n  }\n  ll find(ll x, ll t) {\n    if (t >= fin[x] && par[x] != x) return find(par[x], t);\n    return x;\n  }\n  void merge(ll x, ll y) {\n    x = find(x, index);\n    y = find(y, index);\n    index++;\n    if (x == y) return;\n    if (rank[x] < rank[y]) par[x] = y, fin[x] = index;\n    else {\n      par[y] = x, fin[y] = index;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n  }\n  bool isSame(ll x, ll y, ll t) { return find(x, t) == find(y, t); }\n};\n\n/**** Segment Tree ****/\n\ntemplate <typename T>\nclass SegmentTree {\n  ll n;\n  vector<T> node;\n  function<T(T, T)> fun, fun2;\n  bool customChange;\n  T outValue, initValue;\npublic:\n  void init(ll num, function<T(T, T)> resultFunction, T init, T out, function<T(T, T)> changeFunction = NULL) {\n    // changeFunction: (input, beforevalue) => newvalue\n    fun = resultFunction;\n    fun2 = changeFunction;\n    customChange = changeFunction != NULL;\n    n = 1;\n    while (n < num) n *= 2;\n    node.resize(2 * n - 1, init);\n    outValue = out;\n    initValue = init;\n  }\n  void valueChange(ll num, T value) {\n    num += n-1;\n    if (customChange) node[num] = fun2(value, node[num]);\n    else node[num] = value;\n    while (num > 0) num = (num - 1) / 2, node[num] = fun(node[num * 2 + 1], node[num * 2 + 2]);\n  }\n  T rangeQuery(ll a, ll b, ll l = 0, ll r = -1, ll k = 0) { // [a, b)\n    if (r == -1) r = n;\n    if (a <= l && r <= b) return node[k];\n    if (b <= l || r <= a) return outValue;\n    ll mid = (l + r) / 2;\n    return fun(rangeQuery(a, b, l, mid, 2*k+1), rangeQuery(a, b, mid, r, 2*k+2));\n  }\n};\n\ntemplate <typename T>\nclass LazySegmentTree {\n  ll n;\n  vector<T> node;\n  vector<T> lazyNode;\n  function<T(T, T)> fun, fun2;\n  function<T(T, ll)> fun3;\n  T outValue, initValue;\n  T substitution(T a, T b) { return a; }\n  void eval(ll k, ll l, ll r) {\n    if (lazyNode[k] == 0) return;\n    node[k] = fun2(fun3(lazyNode[k], r - l), node[k]);\n    if (r - l > 1) {\n      lazyNode[2 * k + 1] = fun2(lazyNode[k], lazyNode[2 * k + 1]);\n      lazyNode[2 * k + 2] = fun2(lazyNode[k], lazyNode[2 * k + 2]);\n    }\n    lazyNode[k] = initValue;\n  }\npublic:\n  void init(ll num, function<T(T, T)> resultFunction, function<T(T, T)> changeFunction, function<T(T, ll)> lazyFunction, T init, T out) {\n    // changeFunction: (input, beforevalue) => newvalue\n    // lazyFunction: (lazyNode, diff) => newvalue\n    fun = resultFunction;\n    fun2 = changeFunction;\n    fun3 = lazyFunction;\n    n = 1;\n    while (n < num) n *= 2;\n    node.resize(2 * n - 1, init);\n    lazyNode.resize(2 * n - 1, init);\n    outValue = out;\n    initValue = init;\n  }\n  void rangeChange(ll a, ll b, T value, ll l = 0, ll r = -1, ll k = 0) {\n    if (r == -1) r = n;\n    eval(k, l, r);\n    if (b <= l || r <= a) return;\n    if (a <= l && r <= b) {\n      lazyNode[k] = fun2(value, lazyNode[k]);\n      eval(k, l, r);\n    } else {\n      ll mid = (l + r) / 2;\n      rangeChange(a, b, value, l, mid, 2*k+1);\n      rangeChange(a, b, value, mid, r, 2*k+2);\n      node[k] = fun(node[2*k+1], node[2*k+2]);\n    }\n  }\n  T rangeQuery(ll a, ll b, ll l = 0, ll r = -1, ll k = 0) { // [a, b)\n    if (r == -1) r = n;\n    if (b <= l || r <= a) return outValue;\n    eval(k, l, r);\n    if (a <= l && r <= b) return node[k];\n    ll mid = (l + r) / 2;\n    return fun(rangeQuery(a, b, l, mid, 2*k+1), rangeQuery(a, b, mid, r, 2*k+2));\n  }\n};\n\n/**** Network Flow ****/\n\nclass MaxFlow {\npublic:\n  struct edge { ll to, cap, rev; };\n\n  vector<edge> G[MAX_FLOW_MAX_V];\n  bool used[MAX_FLOW_MAX_V];\n  ll level[MAX_FLOW_MAX_V];\n  ll iter[MAX_FLOW_MAX_V];\n  \n  void init() {\n    for (ll i = 0; i < MAX_FLOW_MAX_V; i++) {\n      G[i].clear();\n    }\n  }\n  void add_edge(ll from, ll to, ll cap) {\n    G[from].push_back((edge){to, cap, (ll)G[to].size()});\n    G[to].push_back((edge){from, 0, (ll)G[from].size() - 1});\n  }\n  void add_undirected_edge(ll e1, ll e2, ll cap) {\n    G[e1].push_back((edge){e2, cap, (ll)G[e2].size()});\n    G[e2].push_back((edge){e1, cap, (ll)G[e1].size() - 1});\n  }\n  ll dfs(ll v, ll t, ll f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (ll i = 0; i < (ll)G[v].size(); i++) {\n      edge &e = G[v][i];\n      if (!used[e.to]&& e.cap > 0) {\n        ll d = dfs(e.to, t, min(f, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  ll max_flow(ll s, ll t) {\n    ll flow = 0;\n    while (1) {\n      memset(used, 0, sizeof(used));\n      ll f = dfs(s, t, INF);\n      if (f == 0) return flow;\n      flow += f;\n    }\n  }\n  void bfs(ll s) {\n    memset(level, -1, sizeof(level));\n    queue<ll> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n      ll v = que.front(); que.pop();\n      for (ll i = 0; i < (ll)G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[e.to] < 0) {\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n  ll dinic_dfs(ll v, ll t, ll f) {\n    if (v == t) return f;\n    for (ll &i= iter[v]; i < (ll)G[v].size(); i++) {\n      edge &e = G[v][i];\n      if (e.cap > 0 && level[v] < level[e.to]) {\n        ll d = dinic_dfs(e.to, t, min(f, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  ll dinic(ll s, ll t) {\n    ll flow = 0;\n    while (1) {\n      bfs(s);\n      if (level[t] < 0) return flow;\n      memset(iter, 0, sizeof(iter));\n      ll f;\n      while ((f = dinic_dfs(s, t, INF)) > 0) {\n        flow += f;\n      }\n    }\n  }\n};\n\n/**** bipartite matching ****/\n\nclass BipartiteMatching {\n  vector<ll> pre, root;\n  vector<vector<ll>> to;\n  vector<ll> p, q;\n  ll n, m;\npublic:\n  BipartiteMatching(ll n, ll m):pre(n,-1),root(n,-1),to(n),p(n,-1),q(m,-1),n(n),m(m){}\n  void add(ll a, ll b) { to[a].push_back(b);}\n  ll solve() {\n    ll res = 0;\n    bool upd = true;\n    while (upd) {\n      upd = false;\n      queue<ll> s;\n      for (ll i = 0; i < n; ++i) {\n        if (!~p[i]) {\n          root[i] = i;\n          s.push(i);\n        }\n      }\n      while (!s.empty()) {\n        ll v = s.front(); s.pop();\n        if (~p[root[v]]) continue;\n        for (ll i = 0; i < (ll)to[v].size(); ++i) {\n          ll u = to[v][i];\n          if (!~q[u]) {\n            while (~u) {\n              q[u] = v;\n              swap(p[v],u);\n              v = pre[v];\n            }\n            upd = true;\n            ++res;\n            break;\n          }\n          u = q[u];\n          if (~pre[u]) continue;\n          pre[u] = v; root[u] = root[v];\n          s.push(u);\n        }\n      }\n      if (upd) fill(pre.begin(),pre.end(),-1), fill(root.begin(),root.end(),-1);\n    }\n    return res;\n  }\n};\n\nclass MinCostFlow {\npublic:\n  struct edge { ll to, cap, cost, rev; };\n\n  ll V;\n  vector<edge> G[MIN_COST_FLOW_MAX_V];\n  ll dist[MIN_COST_FLOW_MAX_V];\n  ll prevv[MIN_COST_FLOW_MAX_V];\n  ll preve[MIN_COST_FLOW_MAX_V];\n  ll h[MIN_COST_FLOW_MAX_V];\n\n  MinCostFlow(ll v) {\n    V = v;\n  }\n  void init() {\n    for (ll i = 0; i < MAX_FLOW_MAX_V; i++) {\n      G[i].clear();\n    }\n  }\n  void add_edge(ll from, ll to, ll cap, ll cost) {\n    G[from].push_back((edge){to, cap, cost, (ll)G[to].size()});\n    G[to].push_back((edge){from, 0, -cost, (ll)G[from].size() - 1});\n  }\n  void add_undirected_edge(ll e1, ll e2, ll cap, ll cost) {\n    add_edge(e1, e2, cap, cost);\n    add_edge(e2, e1, cap, cost);\n  }\n  ll min_cost_flow(ll s, ll t, ll f) { // minas\n    ll res = 0;\n    while (f > 0) {\n      fill(dist, dist + V, INF);\n      dist[s] = 0;\n      bool update = true;\n      while (update) {\n        update = false;\n        for (ll v = 0; v < V; v++) {\n          if (dist[v] == INF) continue;\n          for (ll i = 0; i < (ll)G[v].size(); i++) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n              dist[e.to] = dist[v] + e.cost;\n              prevv[e.to] = v;\n              preve[e.to] = i;\n              update = true;\n            }\n          }\n        }\n      }\n      if (dist[t] == INF) {\n        return -1;\n      }\n      ll d = f;\n      for (ll v = t; v != s; v = prevv[v]) {\n        d = min(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * dist[t];\n      for (ll v = t; v != s; v = prevv[v]) {\n        edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n  ll min_cost_flow_dijkstra(ll s, ll t, ll f) {\n    ll res = 0;\n    fill(h, h + V, 0);\n    while (f > 0) {\n      priority_queue<P, vector<P>, greater<P> > que;\n      fill(dist, dist + V, 0);\n      dist[s] = 0;\n      que.push(P(0, s));\n      while (!que.empty()) {\n        P p = que.top(); que.pop();\n        int v = p.second;\n        if (dist[v] < p.first) continue;\n        for (int i = 0; i < G[v].size(); i++) {\n          edge &e = G[v][i];\n          if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n            dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            que.push(P(dist[e.to], e.to));\n          }\n        }\n      }\n      if (dist[t] == INF) {\n        return -1;\n      }\n      for (int v = 0; v < V; v++) h[v] += dist[v];\n      int d = f;\n      for (int v = t; v != s; v = prevv[v]) {\n        d = tmin<ll>(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * h[t];\n      for (int v = t; v != s; v = prevv[v]) {\n        edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n      return res;\n    }\n    return 0;\n  }\n};\n\n/**** LIS ****/\nll lis(ll* a, ll n, ll* dp) {\n  fill(dp, dp + n, INF);\n  for (ll i = 0; i < n; i++) *lower_bound(dp, dp + n, a[i]) = a[i];\n  return (ll)(lower_bound(dp, dp + n, INF) - dp);\n}\n\n/**** Binary Search ****/\n\nll binarySearch(function<bool(ll)> check, ll ok, ll ng) {\n  while ((ok - ng > 1) || (ng - ok > 1)) {\n    ll mid = (ok + ng) / 2;\n    if (check(mid)) ok = mid;\n    else ng = mid;\n  }\n  return ok;\n}\n\ndouble binarySearchDouble(function<bool(double)> check, double ok, double ng) {\n  while ((ok - ng > EPS) || (ng - ok > EPS)) {\n    double mid = (ok + ng) / 2;\n    if (check(mid)) ok = mid;\n    else ng = mid;\n  }\n  return ok;\n}\n\n/**** Geometry ****/\n\nbool isEqual(double a, double b) { return abs(a - b) < EPS; }\nbool isCEqual(C a, C b) { return isEqual(a.cx, b.cx) && isEqual(a.cy, b.cy); }\nbool isZero(double a) { return abs(a) < EPS; } // a == 0\nbool isUZero(double a) { return a > EPS; } // a > 0\nbool isUEZero(double a) { return a > -EPS; } // a >= 0\nbool isLZero(double a) { return a < -EPS; } // a < 0\nbool isLEZero(double a) { return a < EPS; } // a <= 0\nC getUnitVector(C a) { double len = abs(a); return isZero(len) ? C(0.0, 0.0) : a / len; }\ndouble dot(C a, C b) { return a.cx * b.cx + a.cy * b.cy; } // |a||b|cosθ\ndouble det(C a, C b) { return a.cx * b.cy - a.cy * b.cx; } // |a||b|sinθ\nbool isLineOrthogonal(C a1, C a2, C b1, C b2) { return isZero(dot(a1 - a2, b1 - b2)); } // a1-a2, b1-b2\nbool isLineParallel(C a1, C a2, C b1, C b2) { return isZero(det(a1 - a2, b1 - b2)); } // a1-a2, b1-b2\nbool isPointOnLine(C a, C b, C c) { return isZero(det(b - a, c - a)); } // a-b <- c\n/*\nbool isPointOnLineSegment(C a, C b, C c) { // a-b <- c\n  return isZero(det(b - a, c - a)) && isUEZero(dot(b - a, c - a)) && isUEZero(dot(a - b, c - b));\n}\n*/\nbool isPointOnLineSegment(C a, C b, C c) { return isZero(abs(a-c) + abs(c-b) - abs(a-b)); }\ndouble distanceLineAndPoint(C a, C b, C c) { return abs(det(b-a, c-a)) / abs(b-a); } // a-b <- c\ndouble distanceLineSegmentAndPoint(C a, C b, C c) { // a-b <- c\n  if (isLEZero(dot(b-a, c-a))) return abs(c-a);\n  if (isLEZero(dot(a-b, c-b))) return abs(c-b);\n  return abs(det(b-a, c-a)) / abs(b-a);\n}\nbool isIntersectedLine(C a1, C a2, C b1, C b2) { // a1-a2, b1-b2\n  return !isLineParallel(a1, a2, b1, b2);\n}\nC intersectionLine(C a1, C a2, C b1, C b2) { // isIntersectedLine-> true\n  C a = a2 - a1, b = b2 - b1;\n  return a1 + a * det(b, b1 - a1) / det(b, a);\n}\nbool comp_C(const C& c1, const C& c2) {\n  if (c1.cx != c2.cx) return c1.cx < c2.cx;\n  return c1.cy < c2.cy;\n}\nvector<C> convex_hull(C* ps, ll n) {\n  sort(ps, ps+n, comp_C);\n  ll k = 0;\n  vector<C> qs(n*2);\n  for (ll i = 0; i < n; i++) {\n    while (k > 1 && det((qs[k-1] - qs[k-2]), (ps[i] - qs[k-1])) <= EPS) k--;\n    qs[k++] = ps[i];\n  }\n  for (ll i = n-2, t = k; i >= 0; i--) {\n    while (k > t && det((qs[k-1] - qs[k-2]), (ps[i] - qs[k-1])) <= EPS) k--;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\n/**** main function ****/\n\nll n, m, ans;\n\nint main() {\n  scanf(\"%lld%lld\", &n, &m);\n  ans = nCk(3*m+n-1, n-1, mod);\n  //for (ll i = 1; i <= m; i++) ans = (ans - nCk(m-i+n-2, n-2, mod) * n % mod + mod) % mod;\n  ans = (ans - (nCk(m+n-2, n-1, mod) * n) % mod + mod) % mod;\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "// C - GP 2\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define\tMOD 998244353\n\nstruct FactTable {\n\tvector<long long> a;\n\tFactTable(int n) : a(n + 1, 1) { for (int i = 2; i < a.size(); i++) a[i] = a[i - 1] * i % MOD; }\n\tinline long long operator()(int n) { return a[n]; }\n} fact(2000000);\n\nlong long minv(long long a)\n{\n\tlong long r = 1;\n\tfor (long long n = MOD - 2; n > 0; a = a * a % MOD, n >>= 1)\n\t\tif (n & 1) r = r * a % MOD;\n\treturn r;\n}\n\nlong long cnr(int n, int r)\n{\n\tif (r < 0 || r > n) return 0;\n\tif (r == 0 || r == n) return 1;\n\treturn fact(n) * minv(fact(r)) % MOD * minv(fact(n - r)) % MOD;\n}\n\nint main(int argc, char *argv[])\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n\n\tlong long n, m;\n\tcin >> n >> m;\n\n\tlong long ans = 0;\n\n\tfor (int k = 0; k <= min(m, n); k++) {\n\t\tif ((3 * m - k) % 2) continue;\n\t\tlong long c = (3 * m - k) / 2;\n\t\tans = (ans + cnr(c + n - 1, c) * cnr(n, k) % MOD) % MOD;\n\t}\n\n\tlong long r = 0;\n\tfor (int k = 0; k <= min(m, n); k++) {\n\t\tif ((m - k) % 2) continue;\n\t\tlong long c = (m - k) / 2;\n\t\tr = (r + cnr(c + n - 1, c) * cnr(n, k) % MOD - cnr(c + n - 2, c) * cnr(n - 1, k) % MOD + MOD) % MOD;\n\t}\n\tans = (ans - r * n % MOD + MOD) % MOD;\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) rng(i,0,r)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) rrng(i,0,r)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u>void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long; \n\ntemplate<uint const& MOD>\nstruct Modular{\n\tstatic constexpr uint const &mod=MOD;\n\tuint v;\n\tModular(long long x=0){c(x%mod+mod);}\n\tModular& c(uint x){\n\t\tv=x<mod?x:x-mod;\n\t\treturn *this;\n\t}\n\tModular pow(int k)const{\n\t\tModular res(1),tmp(v);\n\t\twhile(k){\n\t\t\tif(k&1)res*=tmp;\n\t\t\ttmp*=tmp;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModular inv()const{return pow(mod-2);}\n\tModular operator-()const{return Modular(mod-v);}\n\n\tModular& operator+=(const Modular &x){return c(v+x.v);}\n\tModular& operator-=(const Modular &x){return c(v+mod-x.v);}\n\tModular& operator*=(const Modular &x){v=ull(v)*x.v%mod;return *this;}\n\tModular& operator/=(const Modular &x){return *this*=x.inv();}\n\n\tModular operator+(const Modular &x)const{return Modular(*this)+=x;}\n\tModular operator-(const Modular &x)const{return Modular(*this)-=x;}\n\tModular operator*(const Modular &x)const{return Modular(*this)*=x;}\n\tModular operator/(const Modular &x)const{return Modular(*this)/=x;}\n\n\tfriend Modular operator+(long long x,const Modular &y){return Modular(x)+y;}\n\tfriend Modular operator-(long long x,const Modular &y){return Modular(x)-y;}\n\tfriend Modular operator*(long long x,const Modular &y){return Modular(x)*y;}\n\tfriend Modular operator/(long long x,const Modular &y){return Modular(x)/y;}\n\n\tfriend ostream& operator<<(ostream&os,const Modular&x){\n\t\treturn os<<x.v;\n\t}\n\tfriend istream& operator>>(istream&is,Modular&x){\n\t\tlong long p;\n\t\tis>>p;\n\t\tx=Modular(p);\n\t\treturn is;\n\t}\n\tbool operator==(const Modular &x)const{return v==x.v;}\n\tbool operator!=(const Modular &x)const{return v!=x.v;}\n\tbool operator<(const Modular &x)const{return v<x.v;}\n\texplicit operator bool()const{return v;}\n};\n\nuint MODULAR=998244353;\n//uint MODULAR=1000000007;\nusing Mint=Modular<MODULAR>; \n\nvector<Mint>fact,finv,invs;\nvoid Initfact(int n=(1<<21)+10){\n\tfact.resize(n+1),finv.resize(n+1),invs.resize(n+1);\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[n]=fact[n].inv();\n\tfor(int i=n-1;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tinvs[0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\n\nMint comb(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\n\nMint sum[1000005],ans;\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tll n,m;\n\tcin>>n>>m;\n\tInitfact(2000005);\n\tfor(int i=0;i<=2*m;i++){\n\t\tsum[i]=comb(i+n-2,i);\n\t\tif(i>0)sum[i]+=sum[i-1];\n\t}\n\tfor(int i=0;i<=m;i++){\n\t\tif((3*m-i)%2!=0)continue;\n\t\tif(i>n)continue;\n\t\tll y=(3*m-i)/2;\n\t\tans+=comb(n,i)*(comb(y+n-1,y)-Mint(i)*sum[y-m]-Mint(n-i)*sum[y-m-1]);\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2\")\n#pragma GCC optimize (\"unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst ld eps=1e-7;\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod = 998244353;\nconst int MAXN = 4000100, LOG=20;\n\nll n, m, k, u, v, x, y, t, a, b, ans;\nll F[MAXN], I[MAXN];\n\nll powmod(ll a, ll b){\n\tif (!b) return 1;\n\tif (b&1) return a*powmod(a*a%mod, b>>1)%mod;\n\treturn powmod(a*a%mod, b>>1);\n}\n\nll C(ll n, ll r){\n\tif (r<0 || r>n) return 0;\n\treturn F[n]*I[r]%mod*I[n-r]%mod;\n}\n\nll f(ll n, ll m){\n\treturn C(m+n-1, n-1);\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tF[0]=1;\n\tfor (int i=1; i<MAXN; i++) F[i]=F[i-1]*i%mod;\n\tI[MAXN-1]=powmod(F[MAXN-1], mod-2);\n\tfor (int i=MAXN-1; i; i--) I[i-1]=I[i]*i%mod;\n\t\n\tcin>>n>>m;\n\tans=(f(n, 3*m)-n*f(n, m-1))%mod;\n\tif (ans<0) ans+=mod;\n\tcout<<ans<<'\\n';\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define N 4000400\nconst int mod=998244353;\ntypedef long long ll;\ninline ll read(){\n\tll x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,m,ifac[N],fac[N],ans;\nint qpow(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1)ans=1LL*ans*a%mod;\n\t\ta=1LL*a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nvoid init(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\t}\n\tifac[n]=qpow(fac[n],mod-2)%mod;\n\tfor(int i=n-1;i>=0;--i){\n\t\tifac[i]=1LL*ifac[i+1]*(i+1)%mod;\n\t}\n}\ninline int C(int n,int m){\n\tif(n<0||m<0||n-m<0)return 0;\n\treturn 1LL*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\ninline int calc(int n,int m){\n\treturn C(n+m-1,n-1);\n}\nint main(){\n\tn=read(),m=read();\n\tinit(n+3*m);\n\tfor(int i=0;i<=min(n,m);++i){\n\t\tif((i&1)^(m&1))continue;\n\t\tans=(ans+1LL*C(n,i)*calc(n,(3*m-i)>>1))%mod;\n\t\tans=(ans-1LL*C(n-1,i)*n%mod*calc(n,(m-i-2)>>1))%mod;\n\t\tans=(ans-1LL*C(n-1,i-1)*n%mod*calc(n,(m-i)>>1))%mod;\n\t}\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod=998244353;\nconst int N=4000010;\nint i,j,k,n,m,x,y,t,ans;\nint f[N],inv[N];\nint mi(int x,int y){\n\tif (y==0)return 1;\n\tint t=mi(x,y>>1);t=1ll*t*t%mod;\n\treturn y&1?(1ll*x*t%mod):t;\n}\nint C(int x,int y){return 1ll*f[x]*inv[y]%mod*inv[x-y]%mod;}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tf[0]=1;for (i=1;i<=4000000;i++)f[i]=1ll*i*f[i-1]%mod;\n\tinv[4000000]=mi(f[4000000],mod-2);for (i=3999999;i>=0;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tfor (k=0;k<=min(n,m);k++)\n\t\tif ((3*m-k)%2==0){\n\t\t\tint w=(3*m-k)/2;\n\t\t\tans=(ans+1ll*C(w+n-1,n-1)*C(n,k)%mod)%mod;\n\t\t\tif (w>=m){\n\t\t\t\tans=(ans+mod-1ll*n*C(w-m+n-1,n-1)%mod*C(n,k)%mod)%mod;\n\t\t\t\tans=(ans+1ll*n*C(w-m+n-2,n-2)%mod*C(n-1,k)%mod)%mod;\n\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n#include<iostream>\n#define llong long long\nusing namespace std;\n\ninline int read()\n{\n\tint x=0; bool f=1; char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=0;\n\tfor(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(c^'0');\n\tif(f) return x;\n\treturn -x;\n}\n\nconst int N = 2e6;\nconst int P = 998244353;\nllong fact[N+3],finv[N+3];\n\nllong quickpow(llong x,llong y)\n{\n\tllong cur = x,ret = 1ll;\n\tfor(int i=0; y; i++)\n\t{\n\t\tif(y&(1ll<<i)) {y-=(1ll<<i); ret = ret*cur%P;}\n\t\tcur = cur*cur%P;\n\t}\n\treturn ret;\n}\nllong comb(llong x,llong y) {return x<0||y<0||x<y ? 0ll : fact[x]*finv[y]%P*finv[x-y]%P;}\n\nllong calc(llong n,llong m,llong k)\n{\n\tllong ret = 0ll;\n\tfor(int i=0; i<=k; i++)\n\t{\n\t\tif((m-i)&1) continue;\n\t\tllong tmp = comb(n,i)*comb(((m-i)>>1)+n-1,n-1)%P;\n\t\tret = (ret+tmp)%P;\n\t}\n//\tprintf(\"calc %lld %lld %lld=%lld\\n\",n,m,k,ret);\n\treturn ret;\n}\n\nint n,m;\n\nint main()\n{\n\tfact[0] = 1ll; for(int i=1; i<=N; i++) fact[i] = fact[i-1]*i%P;\n\tfinv[N] = quickpow(fact[N],P-2); for(int i=N-1; i>=0; i--) finv[i] = finv[i+1]*(i+1)%P;\n\tscanf(\"%d%d\",&n,&m);\n\tllong ans = calc(n,3*m,m);\n\tans = (ans-n*(calc(n,m,m)-calc(n-1,m,m)+P)%P+P)%P;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\nusing namespace chrono;\n\n#ifdef DEBUG\n\t//~ #define LOCAL_INPUT_FILE\n#else\n\t//#define USE_FILE_IO\n#endif\n\n#ifdef USE_FILE_IO\n\t#define INPUT_FILE \"input.txt\"\n\t#define OUTPUT_FILE \"output.txt\"\n\t#define cin ____cin\n\t#define cout ____cout\n\tifstream cin(INPUT_FILE);\n\tofstream cout(OUTPUT_FILE);\n#else\n\t#ifdef LOCAL_INPUT_FILE\n\t\t#define cin ____cin\n\t\tifstream cin(\"input.txt\");\n\t#endif\n#endif\n\nconst int infinity = (int)1e9 + 42;\nconst int64_t llInfinity = (int64_t)1e18 + 256;\nconst int mod = 998244353; \nconst long double eps = 1e-8;\n\nmt19937_64 randGen(system_clock().now().time_since_epoch().count());\n\ninline void raiseError(string errorCode) {\n\tcerr << \"Error : \" << errorCode << endl;\n\texit(42);\n}\n\nconst int fMax = 1500 * 1000;\nint64_t f[fMax], rf[fMax];\n\nint64_t extGcd(int64_t a, int64_t b, int64_t &x, int64_t &y) {\n\tif (a == 0) {\n\t\tx = 0; y = 1;\n\t\treturn b;\n\t}\n\tint64_t x1, y1;\n\tint64_t g = extGcd(b % a, a, x1, y1);\n\tx = y1 - (b / a) * x1;\n\ty = x1;\n\treturn g;\n}\n\ninline int64_t inverse(int64_t a, int64_t m = mod) {\n\tint64_t x, y;\n\tint64_t g = extGcd(a, m, x, y);\n\tassert(g == 1);\n\treturn (x % m + m) % m;\n}\n\ninline int64_t C(int64_t n, int64_t k) {\n\tif (k < 0 || k > n) {\n\t\treturn 0;\n\t}\n\treturn f[n] * rf[k] % mod * rf[n-k] % mod;\n}\n\ninline int64_t cntLim(int64_t n, int64_t sum, int64_t limit) {\n\tint64_t res = 0;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tres += int64_t((i&1) ? mod-1 : 1) * C(n, i) % mod * C(n+sum-1, n-1);\n\t\tres %= mod;\n\t\tsum -= limit+1;\n\t\tif (sum < 0) {\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn res;\n}\n\nsigned main() {\n\t#ifndef USE_FILE_IO\n\t\tios_base::sync_with_stdio(false);\n\t#endif\n\t\n\tf[0] = 1;\n\tfor (int i = 1; i < fMax; ++i) {\n\t\tf[i] = f[i-1] * i % mod;\n\t}\n\tfor (int i = 0; i < fMax; ++i) {\n\t\trf[i] = inverse(f[i]);\n\t}\n\t\n\tint n, m; cin >> n >> m;\n\tint64_t res = 0;\n\t\n\t// step I: don't have 2*m\n\tres += [&]() -> int64_t {\n\t\tint64_t res = 0;\n\t\tfor (int i = 0; i <= n && i <= m; ++i) {\n\t\t\tif ((3*m-i) & 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres += C(n, i) * cntLim(n, (3*m-i) / 2, m-1) % mod;\n\t\t\tres %= mod;\n\t\t}\n\t\treturn res;\n\t}();\n\t\n\t// step II: have 2*m\n\tres += [&]() -> int64_t {\n\t\tint64_t res = 0;\n\t\tfor (int i = 0; i < n && i <= m; ++i) {\n\t\t\tif ((m-i) & 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres += C(n-1, i) * cntLim(n-1, (m-i) / 2, m-1) % mod;\n\t\t\tres %= mod;\n\t\t}\n\t\tres *= n;\n\t\tres %= mod;\n\t\treturn res;\n\t}();\n\t\n\tres %= mod;\n\tcout << res << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <vector>\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n//#define cerr if(false) cerr\n#ifdef DEBUG\n#define show(...) cerr << #__VA_ARGS__ << \" = \", debug(__VA_ARGS__);\n#else\n#define show(...) 42\n#endif\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> a) {\n    os << '(' << a.first << ',' << a.second << ')';\n    return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, vector<T> v) {\n    for (auto x : v) os << x << ' ';\n    return os;\n}\nvoid debug() {\n    cerr << '\\n';\n}\ntemplate <typename H, typename... T>\nvoid debug(H a, T... b) {\n    cerr << a;\n    if (sizeof...(b)) cerr << \", \";\n    debug(b...);\n}\ntemplate<int MOD>\nclass Modint{\npublic:\n    int a;\n    Modint(const long long v = 0):a(v % MOD){}\n    constexpr int getmod() const{\n        return MOD;\n    }\n    Modint operator+(const Modint rhs) const{\n        return Modint(*this) += rhs;\n    }\n    Modint operator-(const Modint rhs) const{\n        return Modint(*this) -= rhs;\n    }\n    Modint operator*(const Modint rhs) const{\n        return Modint(*this) *= rhs;\n    }\n    Modint operator/(const Modint rhs) const{\n        return Modint(*this) /= rhs;\n    }\n    Modint operator+(const long long rhs) const{\n        return Modint(*this) += rhs;\n    }\n    Modint operator-(const long long rhs) const{\n        return Modint(*this) -= rhs;\n    }\n    Modint operator*(const long long rhs) const{\n        return Modint(*this) *= rhs;\n    }\n    Modint operator/(const long long rhs) const{\n        return Modint(*this) /= rhs;\n    }\n    friend Modint operator+(const long long a, const Modint b){\n        return b + a;\n    }\n    friend Modint operator-(const long long a, const Modint b){\n        return -b + a;\n    }\n    friend Modint operator*(const long long a, const Modint b){\n        return b * a;\n    }\n    friend Modint operator/(const long long a, const Modint b){\n        return Modint(a) / b;\n    }\n    Modint &operator+=(const Modint rhs){\n        a += rhs.a;\n        if(a >= MOD){\n            a -= MOD;\n        }\n        return *this;\n    }\n    Modint &operator-=(const Modint rhs){\n        if(a < rhs.a){\n            a += MOD;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n    Modint &operator*=(const Modint rhs){\n        a = (long long)a * rhs.a % MOD;\n        return *this;\n    }\n    Modint &operator/=(Modint rhs){\n        int x = MOD - 2;\n        while(x){\n            if(x % 2){\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            x /= 2;\n        }\n        return *this;\n    }\n    Modint &operator++(){\n        *this += 1;\n        return *this;\n    }\n    Modint &operator--(){\n        *this -= 1;\n        return *this;\n    }\n    Modint operator++(int){\n        Modint res = *this;\n        ++(*this);\n        return res;\n    }\n    Modint operator--(int){\n        Modint res = *this;\n        res -= 1;\n        return res;\n    }\n    Modint &operator+=(const long long rhs){\n        *this += Modint(rhs);\n        return *this;\n    }\n    Modint &operator-=(const long long rhs){\n        *this -= Modint(rhs);\n        return *this;\n    }\n    Modint &operator*=(const long long rhs){\n        *this *= Modint(rhs);\n        return *this;\n    }\n    Modint &operator/=(const long long rhs){\n        *this /= Modint(rhs);\n        return *this;\n    }\n    Modint operator+() const{\n        return *this;\n    }\n    Modint operator-() const{\n        return Modint()-*this;\n    }\n    bool operator==(const Modint rhs) const{\n        return a == rhs.a;\n    }\n    bool operator==(const long long rhs) const{\n        return a == rhs;\n    }\n    friend bool operator==(const long long a, const Modint b){\n        return a == b.a;\n    }\n    bool operator!=(const Modint rhs) const{\n        return a != rhs.a;\n    }\n    bool operator!=(const long long rhs) const{\n        return a != rhs;\n    }\n    friend ostream &operator<<(ostream &os, const Modint x){\n        os << x.a;\n        return os;\n    }\n    friend istream &operator>>(istream &is, Modint &x){\n        is >> x.a;\n        return is;\n    }\n    explicit operator bool() const{\n        return a > 0;\n    }\n    bool operator!(){\n        return a == 0;\n    }\n    explicit operator int() const{\n        return a;\n    }\n    explicit operator long long() const{\n        return (long long) a;\n    }\n    friend Modint pow(Modint a, long long b){\n        Modint res = 1;\n        while(b){\n            if(b % 2){\n                res *= a;\n            }\n            a *= a;\n            b /= 2;\n        }\n        return res;\n    }\n};\nusing mint = Modint<998244353>;\nconst int NUM = 3000000;\nmint fact[NUM + 1], fact_inv[NUM + 1], inv[NUM + 1];\nmint combi(long long N_, long long K_){\n    static constexpr int Mod_ = fact[0].getmod();\n    if(fact[0] == 0){\n        inv[1] = fact[0] = fact_inv[0] = 1;\n        for(int i = 2; i <= NUM; i++){\n            inv[i] = inv[Mod_ % i] * (Mod_ - Mod_ / i);\n        }\n        for(int i = 1; i <= NUM; i++){\n            fact[i] = fact[i - 1] * i;\n            fact_inv[i] = fact_inv[i - 1] * inv[i];\n        }\n    }\n    if(K_ < 0 or K_ > N_) return 0;\n    return fact_inv[K_] * fact[N_] * fact_inv[N_ - K_];\n}\nmint hcomb(long long N_, long long K_){\n    return ((N_ | K_) == 0) ? 1 : combi(N_ + K_ - 1, K_);\n}\nint main(){\n    int n, m;\n    cin >> n >> m;\n    mint ans = 0;\n    for(int i = m % 2; i <= min(n, m); i += 2){\n        ans += combi(n, i) * hcomb(n, (3 * m - i) / 2);\n    }\n    cout << ans - n * hcomb(n, m - 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!===============================================================!//\n//!   88888888b            dP       .88888.   a88888b. 888888ba   !//\n//!   88                   88      d8'   '88 d8'   '88 88    '8b  !//\n//!  a88aaaa    dP.  .dP d8888P    88        88        88     88  !//\n//!   88         '8bd8'    88      88   YP88 88        88     88  !//\n//!   88         .d88b.    88      Y8.   .88 Y8.   .88 88    .8P  !//\n//!   88888888P dP'  'dP   dP       '88888'   Y88888P' 8888888P   !//\n//!===============================================================!//\ntemplate <typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto p = extgcd(b, a % b);\n    return {p.second, p.first - p.second * (a / b)};\n}\ntemplate <typename T>\nconstexpr T inverse(const T a, const T mod) { return (mod + extgcd((mod + a % mod) % mod, mod).first % mod) % mod; }\n//!========================================================!//\n//!  8888ba.88ba                 dP    dP            dP    !//\n//!  88  '8b  '8b                88    88            88    !//\n//!  88   88   88 .d8888b. .d888b88    88 88d888b. d8888P  !//\n//!  88   88   88 88'  '88 88'  '88    88 88'  '88   88    !//\n//!  88   88   88 88.  .88 88.  .88    88 88    88   88    !//\n//!  dP   dP   dP '88888P' '88888P8    dP dP    dP   dP    !//\n//!========================================================!//\ntemplate <uint mod>\nclass ModInt\n{\nprivate:\n    uint v;\n    static uint norm(const uint& x) { return x < mod ? x : x - mod; }\n    static ModInt make(const uint& x)\n    {\n        ModInt m;\n        return m.v = x, m;\n    }\n    static ModInt power(ModInt x, ll n)\n    {\n        ModInt ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static ModInt inv(const ModInt& x) { return ModInt{inverse(static_cast<ll>(x.v), static_cast<ll>(mod))}; }\n\npublic:\n    ModInt() : v{0} {}\n    ModInt(const ll val) : v{norm(uint(val % static_cast<ll>(mod) + static_cast<ll>(mod)))} {}\n    ModInt(const ModInt& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    bool operator!() const { return not static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& m) { return v = m(), (*this); }\n    ModInt& operator=(const ll val) { return v = norm(uint(val % static_cast<ll>(mod) + static_cast<ll>(mod))), (*this); }\n    friend ModInt operator+(const ModInt& m) { return m; }\n    friend ModInt operator-(const ModInt& m) { return make(norm(mod - m.v)); }\n    friend ModInt operator+(const ModInt& m1, const ModInt& m2) { return make(norm(m1.v + m2.v)); }\n    friend ModInt operator-(const ModInt& m1, const ModInt& m2) { return make(norm(m1.v + mod - m2.v)); }\n    friend ModInt operator*(const ModInt& m1, const ModInt& m2) { return make(static_cast<uint>(static_cast<ll>(m1.v) * static_cast<ll>(m2.v) % static_cast<ll>(mod))); }\n    friend ModInt operator/(const ModInt& m1, const ModInt& m2) { return m1 * inv(m2.v); }\n    friend ModInt operator+(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) + val}; }\n    friend ModInt operator-(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) - val}; }\n    friend ModInt operator*(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) * (val % static_cast<ll>(mod))}; }\n    friend ModInt operator/(const ModInt& m, const ll val) { return ModInt{static_cast<ll>(m.v) * inv(val)}; }\n    friend ModInt operator+(const ll val, const ModInt& m) { return ModInt{static_cast<ll>(m.v) + val}; }\n    friend ModInt operator-(const ll val, const ModInt& m) { return ModInt{-static_cast<ll>(m.v) + val}; }\n    friend ModInt operator*(const ll val, const ModInt& m) { return ModInt{static_cast<ll>(m.v) * (val % static_cast<ll>(mod))}; }\n    friend ModInt operator/(const ll val, const ModInt& m) { return ModInt{val * inv(static_cast<ll>(m.v))}; }\n    friend ModInt& operator+=(ModInt& m1, const ModInt& m2) { return m1 = m1 + m2; }\n    friend ModInt& operator-=(ModInt& m1, const ModInt& m2) { return m1 = m1 - m2; }\n    friend ModInt& operator*=(ModInt& m1, const ModInt& m2) { return m1 = m1 * m2; }\n    friend ModInt& operator/=(ModInt& m1, const ModInt& m2) { return m1 = m1 / m2; }\n    friend ModInt& operator+=(ModInt& m, const ll val) { return m = m + val; }\n    friend ModInt& operator-=(ModInt& m, const ll val) { return m = m - val; }\n    friend ModInt& operator*=(ModInt& m, const ll val) { return m = m * val; }\n    friend ModInt& operator/=(ModInt& m, const ll val) { return m = m / val; }\n    friend ModInt operator^(const ModInt& m, const ll n) { return power(m.v, n); }\n    friend ModInt& operator^=(ModInt& m, const ll n) { return m = m ^ n; }\n    friend bool operator==(const ModInt& m1, const ModInt& m2) { return m1.v == m2.v; }\n    friend bool operator!=(const ModInt& m1, const ModInt& m2) { return not(m1 == m2); }\n    friend bool operator==(const ModInt& m, const ll val) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod) + val % static_cast<ll>(mod))); }\n    friend bool operator!=(const ModInt& m, const ll val) { return not(m == val); }\n    friend bool operator==(const ll val, const ModInt& m) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod) + val % static_cast<ll>(mod))); }\n    friend bool operator!=(const ll val, const ModInt& m) { return not(m == val); }\n    friend std::istream& operator>>(std::istream& is, ModInt& m)\n    {\n        uint v;\n        return is >> v, m = v, is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& m) { return os << m(); }\n    static std::vector<ModInt> invVec(const std::size_t N)\n    {\n        std::vector<ModInt> ans(N + 1, 1);\n        for (std::size_t i = 2; i <= N; i++) { ans[i] = -ans[mod % i] * (mod / i); }\n        return ans;\n    }\n    uint operator()() const { return v; }\n};\n//!============================================================================!//\n//!  8888ba.88ba                 dP     a88888b.                     dP        !//\n//!  88  '8b  '8b                88    d8'   '88                     88        !//\n//!  88   88   88 .d8888b. .d888b88    88        .d8888b. 88d8b.d8b. 88d888b.  !//\n//!  88   88   88 88'  '88 88'  '88    88        88'  '88 88''88''88 88'  '88  !//\n//!  88   88   88 88.  .88 88.  .88    Y8.   .88 88.  .88 88  88  88 88.  .88  !//\n//!  dP   dP   dP '88888P' '88888P8     Y88888P' '88888P' dP  dP  dP 88Y8888'  !//\n//!============================================================================!//\ntemplate <uint mod>\nclass ModComb\n{\npublic:\n    ModComb(const std::size_t N) : f(N + 1, ModInt<mod>(1)), in(N + 1, ModInt<mod>(1)), invf(N + 1, ModInt<mod>(1))\n    {\n        for (uint i = 2; i <= N; i++) { f[i] = f[i - 1] * i, in[i] = -in[mod % i] * (mod / i), invf[i] = invf[i - 1] * in[i]; }\n    }\n    ModInt<mod> fact(const std::size_t N) const { return f[N]; }\n    ModInt<mod> inv(const std::size_t N) const { return in[N]; }\n    ModInt<mod> invFact(const std::size_t N) const { return invf[N]; }\n    ModInt<mod> perm(const std::size_t N, const std::size_t K) const { return N > f.size() or K > N ? ModInt<mod>(0) : f[N] * invf[N - K]; }\n    ModInt<mod> comb(const std::size_t N, const std::size_t K) const { return N > f.size() or K > N ? ModInt<mod>(0) : f[N] * invf[K] * invf[N - K]; }\n\nprivate:\n    std::vector<ModInt<mod>> f, in, invf;\n};\n//!=====================================!//\n//!  8888ba.88ba           oo           !//\n//!  88  '8b  '8b                       !//\n//!  88   88   88 .d8888b. dP 88d888b.  !//\n//!  88   88   88 88'  '88 88 88'  '88  !//\n//!  88   88   88 88.  .88 88 88    88  !//\n//!  dP   dP   dP '88888P8 dP dP    dP  !//\n//!=====================================!//\nint main()\n{\n    constexpr uint MOD = 998244353;\n    using mint = ModInt<MOD>;\n    const int N = read<int>(), M = read<int>();\n    ModComb<MOD> mod(N + 3 * M);\n    mint ans = mod.comb(3 * M + N - 1, N - 1);\n    for (int a = 2 * M + 1; a <= 3 * M; a++) { ans -= N * mod.comb(3 * M - a + N - 2, N - 2); }\n    for (int i = M + 1; i <= N and 3 * M - i >= 0; i++) {\n        if ((3 * M - i) % 2 != 0) { continue; }\n        ans -= mod.comb(N, i) * mod.comb((3 * M - i) / 2 + N - 1, N - 1);\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i32 = std::int_fast32_t;\nusing i64 = std::int_fast64_t;\ntemplate <typename T> constexpr T inf = numeric_limits<T>::has_infinity ? numeric_limits<T>::infinity() : numeric_limits<T>::max() / 4;\n\n#define REP(i, stop) FOR(i, 0, stop)\n#define FOR(i, start, stop) for (int i = start, i##_len = stop; i < i##_len; ++i)\n#define RREP(i, n) for (int i = n; i-- > 0;)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define COMP(key) [](const auto& a, const auto& b) { return a.key < b.key; }\n\ntemplate<typename T, typename U> istream& operator>>(istream& is, pair<T, U>& a) { return is >> a.first >> a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector<T>& a) { for (T& x : a) is >> x; return is; }\n\nvoid LOG(const int& x) { cerr << x << \"\\n\"; }\ntemplate<typename T> void LOG(const vector<T>& a) { for (const T& x : a) cerr << x << \" \"; cerr << \"\\n\"; }\ntemplate<typename T, std::size_t S> void LOG(const T (&a)[S]) { REP(i, S) cerr << a[i] << \" \"; cerr << \"\\n\"; }\ntemplate<typename T, std::size_t S, std::size_t R> void LOG(const T (&a)[S][R]) { REP(i, S) { REP(j, R) cerr << a[i][j] << \" \"; cerr << \"\\n\"; } }\n\ni64 ceil(i64 a, i64 b) { return (a - 1) / b + 1; }\ni64 gcd(i64 a, i64 b) { while (b != 0) { i64 t = b; b = a % b; a = t; } return a; }\ni64 lcm(i64 a, i64 b) { return a / gcd(a, b) * b; }\ni64 gcd(const vector<i64>& v) { return accumulate(ALL(v), 1LL, static_cast<i64(*)(i64, i64)>(gcd)); }\ni64 lcm(const vector<i64>& v) { return v.empty() ? 0LL : accumulate(v.begin() + 1, v.end(), v[0], static_cast<i64(*)(i64, i64)>(lcm)); }\ni64 pow(i64 x, i64 y, i64 z) { i64 a = 1; while (y > 0) { if (y & 1) a = a * x % z; x = x * x % z; y /= 2; } return a; }\ni64 inv(i64 x, i64 m) { return pow(x, m - 2, m); }\n\nstruct InitCpp { InitCpp() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(10); } } initCpp;\n\n// const i64 M = 1000000007;\nconst i64 M = 998244353;\nusing P = pair<i64, i64>;\n\ni64 fact[2500000];\ni64 comb(i64 n, i64 r) {\n  if (n - r < 0) return 0;\n  return fact[n] * inv(fact[r], M) % M * inv(fact[n - r], M) % M;\n}\n\ni64 rcomb(i64 n, i64 r) {\n  return comb(n + r - 1, r);\n}\n\nsigned main() {\n  fact[0] = 1;\n  REP(i, 2500000) {\n    fact[i + 1] = (i + 1) * fact[i] % M;\n  }\n  i64 n, m;\n  cin >> n >> m;\n  i64 ans = 0;\n  ans = rcomb(3 * m + 1, n - 1) - rcomb(m, n - 1) * n % M;\n  ans = (ans % M + M) % M;\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\n#define MN 1500000\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,m,ans,p[MN+5],inv[MN+5];\ninline int C(int n,int m){return m>n?0:1LL*p[n]*inv[m]%mod*inv[n-m]%mod;}\nint main()\n{\n    n=read();m=read();\n    p[0]=p[1]=inv[0]=inv[1]=1;\n    for(int i=2;i<=MN;++i) p[i]=1LL*p[i-1]*i%mod,inv[i]=1LL*(mod-mod/i)*inv[mod%i]%mod;\n    for(int i=2;i<=MN;++i) inv[i]=1LL*inv[i-1]*inv[i]%mod;\n    if(n==2) return 0*printf(\"%d\\n\",m+1);\n    for(int i=0;i<=m;i+=2) if(m-i<=n)\n    {\n        int t=i/2+m;\n        ans=(ans+1LL*C(n,m-i)*C(t+n-1,n-1))%mod;\n        ans=(ans+1LL*C(n,m-i)*(mod-(m-i))%mod*C(t-m+n-1,n-1))%mod;\n        ans=(ans+1LL*C(n,m-i)*(mod-(n-(m-i)))%mod*C(t-m+n-2,n-1))%mod;\n    }\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<stack>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<cstring>\n#include<complex>\n#include<bitset>\n#include<iostream>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> Q;\ntypedef complex<double> C;\n#define cx real()\n#define cy imag()\nconst ll INF = 1LL << 60;\nconst double DINF = 1e30;\nconst ll mod = 998244353;\nconst ll dx[4] = {1, 0, -1, 0};\nconst ll dy[4] = {0, -1, 0, 1};\nconst C I = C(0, 1);\nconst double EPS = 1e-10;\nconst ll NCK_MAX = 4000000;\n\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y) {\n  if (b == 0) {\n    x = 1, y = 0; return a;\n  }\n  ll q = a/b, g = extgcd(b, a - q*b, x, y);\n  ll z = x - q * y;\n  x = y;\n  y = z;\n  return g;\n}\n\nll invmod (ll a, ll m) { // a^-1 mod m\n  ll x, y;\n  extgcd(a, m, x, y);\n  x %= m;\n  if (x < 0) x += m;\n  return x;\n}\n\nll *fac, *finv, *inv;\n\nvoid nCk_init(ll mod) {\n  fac = new ll[NCK_MAX];\n  finv = new ll[NCK_MAX];\n  inv = new ll[NCK_MAX];\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (ll i = 2; i < NCK_MAX; i++) {\n    fac[i] = fac[i-1] * i % mod;\n    inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n    finv[i] = finv[i-1] * inv[i] % mod;\n  }\n}\n\nll nCk(ll n, ll k, ll mod) {\n  if (fac == NULL) nCk_init(mod);\n  if (n < k) return 0;\n  if (n < 0 || k < 0) return 0;\n  return fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\ntemplate <typename T>\nclass Zip {\n  vector<T> d;\n  bool flag;\n  void init() {\n    sort(d.begin(), d.end());\n    d.erase(unique(d.begin(), d.end()), d.end());\n    flag = false;\n  }\npublic:\n  Zip() {\n    flag = false;\n  }\n  void add(T x) {\n    d.push_back(x);\n    flag = true;\n  }\n  ll getNum(T x) {\n    if (flag) init();\n    return lower_bound(d.begin(), d.end(), x) - d.begin();\n  }\n  ll size() {\n    if (flag) init();\n    return (ll)d.size();\n  }\n};\n\nclass UnionFind {\n  vector<ll> par, rank; // par > 0: number, par < 0: -par\npublic:\n  UnionFind(ll n) : par(n, 1), rank(n, 0) {}\n  ll getSize(ll x) {\n    return par[find(x)];\n  }\n  ll find(ll x) {\n    if (par[x] > 0) return x;\n    return -(par[x] = -find(-par[x]));\n  }\n  void merge(ll x, ll y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (rank[x] < rank[y]) {\n      par[y] += par[x];\n      par[x] = -y;\n    } else {\n      par[x] += par[y];\n      par[y] = -x;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n  }\n  bool isSame(ll x, ll y) {\n    return find(x) == find(y);\n  }\n};\n\n\ntemplate <typename T>\nclass SegmentTree {\n  ll n;\n  vector<T> node;\n  function<T(T, T)> fun, fun2;\n  bool customChange;\n  T outValue, initValue;\npublic:\n  void init(ll num, function<T(T, T)> resultFunction, T init, T out, function<T(T, T)> changeFunction = NULL) {\n    // changeFunction: (input, beforevalue) => newvalue\n    fun = resultFunction;\n    fun2 = changeFunction;\n    customChange = changeFunction != NULL;\n    n = 1;\n    while (n < num) n *= 2;\n    node.resize(2 * n - 1);\n    fill(node.begin(), node.end(), init);\n    outValue = out;\n    initValue = init;\n  }\n  void valueChange(ll num, T value) {\n    num += n-1;\n    if (customChange) node[num] = fun2(value, node[num]);\n    else node[num] = value;\n    while (num > 0) num = (num - 1) / 2, node[num] = fun(node[num * 2 + 1], node[num * 2 + 2]);\n  }\n  T rangeQuery(ll a, ll b, ll l = 0, ll r = -1, ll k = 0) { // [a, b)\n    if (r == -1) r = n;\n    if (a <= l && r <= b) return node[k];\n    if (b <= l || r <= a) return outValue;\n    ll mid = (l + r) / 2;\n    return fun(rangeQuery(a, b, l, mid, 2*k+1), rangeQuery(a, b, mid, r, 2*k+2));\n  }\n};\n\ntemplate <typename T>\nclass Graph {\n  struct edge { ll to; T cost; };\n  struct edge_data { ll from, to; T cost; };\n\n  ll v;\n  vector<vector<edge>> e, re;\n  vector<edge_data> ed;\n  vector<bool> used;\n  vector<ll> vs, cmp;\n  bool isDirected, isMinasEdge;\npublic:\n  Graph(ll _v, bool _isDirected = true, ll range_add = 0) {\n    // range_add 0:no / 1:in / 2:out / 3:in+out\n    //_v++;\n    v = _v, isDirected = _isDirected; isMinasEdge = false;\n    e.resize(v), re.resize(v);\n  }\n  void add_edge(ll s, ll t, T cost = 1) {\n    e[s].push_back((edge){t, cost});\n    if (!isDirected) e[t].push_back((edge){s, cost});\n    else re[t].push_back((edge){s, cost});\n    ed.push_back((edge_data){s, t, cost});\n    if (cost < 0) isMinasEdge = true;\n  }\n  vector<T> dijkstra(ll s) {\n    vector<T> d(v, INF);\n    d[s] = 0;\n    auto edge_cmp = [](const edge& a, const edge& b) { return a.cost > b.cost; };\n    priority_queue<edge, vector<edge>, decltype(edge_cmp)> pq(edge_cmp);\n    pq.push((edge){s, 0});\n    while (!pq.empty()) {\n      edge temp = pq.top(); pq.pop();\n      if (d[temp.to] < temp.cost) continue;\n      for (const edge& next : e[temp.to]) {\n        T cost = temp.cost + next.cost;\n        if (d[next.to] > cost) {\n          d[next.to] = cost;\n          pq.push((edge){next.to, cost});\n        }\n      }\n    }\n    return d;\n  }\n  vector<T> bellmanford(ll s) {\n    vector<T> d(v, INF);\n    d[s] = 0;\n    for (ll i = 0; i < v; i++) {\n      for (const edge_data& temp : ed) {\n        if (d[temp.from] != INF && d[temp.to] > d[temp.from] + temp.cost) d[temp.to] = d[temp.from] + temp.cost;\n        if (!isDirected && d[temp.to] != INF && d[temp.from] > d[temp.to] + temp.cost) d[temp.from] = d[temp.to] + temp.cost;\n      }\n    }\n    for (ll i = 0; i < v; i++) {\n      for (const edge_data& temp : ed) {\n        if (d[temp.from] != INF && d[temp.to] > d[temp.from] + temp.cost) d[temp.to] = -INF;\n        if (!isDirected && d[temp.to] != INF && d[temp.from] > d[temp.to] + temp.cost) d[temp.from] = -INF;\n      }\n    }\n    return d;\n  }\n  vector<T> shortest_path(ll s) {\n    if (isMinasEdge) return bellmanford(s);\n    else return dijkstra(s);\n  }\n  T kruskal() {\n    // if (isDirected)\n    UnionFind uf(v);\n    auto edge_data_cmp = [](const edge_data& a, const edge_data& b) { return a.cost < b.cost; };\n    sort(ed.begin(), ed.end(), edge_data_cmp);\n    T ans = 0;\n    for (const edge_data& temp : ed) {\n      if (uf.isSame(temp.from, temp.to)) continue;\n      uf.merge(temp.from, temp.to);\n      ans += temp.cost;\n    }\n    return ans;\n  }\n  void scc_dfs(ll s) {\n    used[s] = true;\n    for (const edge& i : e[s]) if (!used[i.to]) scc_dfs(i.to);\n    vs.push_back(s);\n  }\n  void scc_rdfs(ll s, ll k) {\n    used[s] = true;\n    cmp[s] = k;\n    for (const edge& i : re[s]) if (!used[i.to]) scc_rdfs(i.to, k);\n  }\n  vector<ll> scc() {\n    used.resize(v);\n    fill(used.begin(), used.end(), false);\n    cmp.resize(v);\n    vs.clear();\n    for (ll i = 0; i < v; i++) if (!used[i]) scc_dfs(i);\n    used.resize(v);\n    fill(used.begin(), used.end(), false);\n    ll k = 0;\n    for (ll i = vs.size() - 1; i >= 0; i--) if (!used[vs[i]]) scc_rdfs(vs[i], k++);\n    return cmp;\n  }\n};\n\nll n, m, ans;\n\nint main() {\n  scanf(\"%lld%lld\", &n, &m);\n  for (ll i = 0; i <= min(n, m); i++) if ((3 * m - i) % 2 == 0) {\n    ll j = (3 * m - i) / 2;\n    ans += nCk(n, i, mod) * nCk(n-1+j, j, mod) % mod;\n    if (ans >= mod) ans -= mod;\n  }\n  for (ll i = 2*m+1; i <= 3*m; i++) {\n    ll j = 3 * m - i;\n    ans -= nCk(j+n-2, j, mod) * n % mod;\n    if (ans < 0) ans += mod;\n  }\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 3000003,mo=998244353;\nint n,m,res,fac[N],ifac[N];\ninline void add(int &x, int y){x=x+y<mo?x+y:x+y-mo;}\ninline int power(int a, int n) {\n\tint res=1;\n\twhile (n) {\n\t\tif (n&1) res=1LL*res*a%mo;\n\t\ta=1LL*a*a%mo; n>>=1;\n\t}\n\treturn res;\n}\nvoid init(int n){\n\tfac[0]=1;rep(i,1,n)fac[i]=1LL*fac[i-1]*i%mo;\n\tifac[n]=power(fac[n],mo-2);per(i,n-1,0)ifac[i]=1LL*ifac[i+1]*(i+1)%mo;\n}\nint C(int n, int m){return m>=0&&m<=n?1LL*fac[n]*ifac[m]%mo*ifac[n-m]%mo:0;}\nint main() {\n\tread(n);read(m);init(N-1);int tot=3*m;\n\trep(i,0,m)if((tot-i)%2==0)\n\t\tres=(res+1LL*C(n,i)*C((tot-i)/2+n-1,n-1))%mo;\n\trep(i,tot/3*2+1,tot)res=(res-1LL*n*C(tot-i+n-2,n-2))%mo;\n\tprintf(\"%d\",(res+mo)%mo);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 998244353;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate <class T>\nT pow_ (T x, T n, T M){\n    uint64_t u = 1, xx = x;\n    while (n > 0){\n        if (n&1) u = u * xx % M;\n        xx = xx * xx % M;\n        n >>= 1;\n    }\n    return static_cast<T>(u);\n};\n\ntemplate <class T> class Factorial {\n    T mod;\n    vector<uint64_t> facts, factinv;\n\npublic:\n    Factorial(int n, T mod) : facts(static_cast<u32>(n+1)), factinv(static_cast<u32>(n+1)), mod(mod) {\n        facts[0] = 1;\n        for (int i = 1; i < n+1; ++i) facts[i] = facts[i-1]*i % mod;\n        factinv[n] = pow_(facts[n], static_cast<uint64_t>(mod - 2), static_cast<uint64_t>(mod));\n        for (int i = n-1; i >= 0; --i) factinv[i] = factinv[i+1] * (i+1) % mod;\n    }\n\n    T fact(int k) const {\n        if(k >= 0) return static_cast<T>(facts[k]);\n        else return static_cast<T>(factinv[-k]);\n    }\n\n    T operator[](const int &k) const {\n        if(k >= 0) return static_cast<T>(facts[k]);\n        else return static_cast<T>(factinv[-k]);\n    }\n\n    T C(int p, int q) const {\n        if(q < 0 || p < q) return 0;\n        return static_cast<T>(facts[p]*  factinv[q] % mod * factinv[p-q] % mod);\n    }\n\n    T P(int p, int q) const {\n        if(q < 0 || p < q) return 0;\n        return static_cast<T>((facts[p] * factinv[p-q]) % mod);\n    }\n\n    T H(int p, int q) const {\n        if(p < 0 || q < 0) return 0;\n        return static_cast<T>(q == 0 ? 1 : C(p+q-1, q));\n    }\n};\nint main() {\n    ll n, m;\n    cin >> n >> m;\n    Factorial<ll> f(2000010, MOD);\n    ll ans = 0;\n    for (int k = 0; k <= m; ++k) {\n        if(k%2 != m%2) continue;\n        (ans += f.C(n, k)*f.H(n, (3*m-k)/2)) %= MOD;\n    }\n    for (int i = 2*m+1; i <= 3*m; ++i) {\n        (ans += MOD-n*f.H(n-1, 3*m-i)%MOD) %= MOD;\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef _debug\n#define out(i) cout << #i << ' ' << i << ' '\n#else \n#define out(i) //\n#endif\nusing ll = long long;\nusing ull = unsigned long long;\nconst int maxn = 500001;\nconst int maxm = 1000001;\nconst int tomod = 998244353;\nll form(ll a){\n\treturn (a + tomod) % tomod;\n}\nll inv[maxm], fa[maxm];\nvoid init(){\n\tfa[0] = fa[1] = 1;\n\tinv[0] = inv[1] = 1;\n\tfor(int i = 2;i < maxm;++i){\n\t\tfa[i] = form(fa[i - 1] * (ll)i);\n\t\tinv[i] = form((tomod - tomod / i) * inv[tomod % i]);\n\t}\n\tfor(int i = 2;i < maxm;++i)inv[i] = form(inv[i] * inv[i - 1]);\n}\nll cof(int a, int b){\n\treturn form(fa[a] * form(inv[b] * inv[a - b]));\n} \nll solve(int n, int k, const int max_odd){\n\tll res = 0;\n\tfor(int o = k&1;o <= max_odd;o += 2){\n\t\tres = form(res + form(\n\t\t\tcof(n, o) * \n\t\t\tcof((k-o)/2+n-1, n-1)\n\t\t));\n\t}\n\treturn res;\n}\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tinit();\n\tll k, n;\n\tcin >> n >> k;\n\tll res = solve(n, k * 3, min(n, k));\n\tres = form(res-form(\n\t\tn * form(solve(n, k, min(n, k)) - solve(n-1, k, min(n-1, k)))\n\t)\n\t);\n\tcout << res << '\\n';\n\tassert(res>=0 and res<tomod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nconst int MAX = 2600000;\nint mod = 998244353;\nint n, m;\nint fact[MAX];\nint inv[MAX];\nint factInv[MAX];\n\nvoid initFact() {\n\tint i;\n\t\n\tfact[0] = fact[1] = 1;\n\tfactInv[0] = factInv[1] = 1;\n\tinv[1] = 1;\n\tfor (i = 2; i <= 3 * m + n; i++) {\n\t\tfact[i] = (i * fact[i - 1]) % mod;\n\t\tinv[i] = mod - inv[mod % i] * (mod / i) % mod;\n\t\tfactInv[i] = factInv[i - 1] * inv[i] % mod;\n\t}\n}\n\nint comb(int n, int k) {\n\tif (k > n) return 0;\n\treturn fact[n] * factInv[n - k] % mod * factInv[k] % mod;\n}\n\nsigned main() {\n\tcin >> n >> m;\n\tinitFact();\n\t\n\tint x;\n\tint ng = 0;\n\tfor (x = 2 * m + 1; x <= 3 * m; x++) {\n\t\tint res = n * comb(3 * m - x + n - 2, n - 2) % mod;\n\t\tng += res;\n\t\tng %= mod;\n\t}\n\t\n\t//奇数がx個\n\tfor (x = m + 1; x <= n; x++) {\n\t\tif (x > 3 * m) break;\n\t\tif ((3 * m - x) % 2 != 0) continue;\n\t\tint res = comb((3 * m - x) / 2 + n - 1, n - 1) * comb(n, x) % mod;\n\t\tng += res;\n\t\tng %= mod;\n\t}\n\t\n\tint all = comb(3 * m + n - 1, n - 1);\n\tint ans = (all - ng + mod) % mod;\n\t\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuThOr GaRyMr\n*/\n#include<bits/stdc++.h>\n#define rb(a,b,c) for(int a=b;a<=c;++a)\n#define rl(a,b,c) for(int a=b;a>=c;--a)\n#define LL long long\n#define IT iterator\n#define PB push_back\n#define II(a,b) make_pair(a,b)\n#define FIR first\n#define SEC second\n#define FREO freopen(\"check.out\",\"w\",stdout)\n#define rep(a,b) for(int a=0;a<b;++a)\n#define KEEP while(1)\n#define SRAND mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#define random(a) rng()%a\n#define ALL(a) a.begin(),a.end()\n#define POB pop_back\n#define ff fflush(stdout)\n#define fastio ios::sync_with_stdio(false)\n//#define int LL\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef pair<int,int> mp;\ntypedef pair<mp,mp> superpair;\nLL MOD=998244353;\nLL fact[2000000+20];\nLL update(LL A){\n\tif(A<MOD) return A;\n\tif(A-MOD<MOD) return A-MOD;\n\tA%=MOD;\n\treturn A;\n}\nvoid UP(LL & A){\n\t\n\tif(A>=MOD){\n\t\tif(A-MOD<MOD) A-=MOD;\n\t\telse\n\t\tA%=MOD;\n\t}\n\t\n}\nLL quick(LL A,LL B){\n\tif(!B) return 1ll;\n\tLL tmp=quick(A,B>>1);\n\ttmp*=tmp;\n\tUP(tmp);\n\tif(B&1){\n\t\ttmp*=A;\n\t\tUP(tmp);\n\t}\n\treturn tmp;\n}\n\nLL inv(LL A){\n\treturn  quick(A,MOD-2);\n}\nmap<pair<int,int>,int>  M;\nLL C(LL A,LL B){\n\tif(M[II(A,B)]){\n\t\treturn M[II(A,B)];\n\t}\n\tif(B>A){\n\t\treturn 0ll;\n\t}\n\tint rest=update(update(fact[A]*inv(fact[B]))*inv(fact[A-B]));\n\treturn M[II(A,B)]=rest;\n}\nLL AR(LL A,LL B){\n\t//把A个2分给B个数\n\treturn C(A+B-1,B-1); \n} \nint  main(){\n\tfastio;\n\tfact[0]=1;\n\trb(i,1,2000000)\n\t\tfact[i]=fact[i-1]*i,fact[i]%=MOD;\n\tint n,m;\n\tcin>>n>>m;\n\tLL res=0;\n\tLL del=0;\n\tfor(int two=m,one=m;one>=0;two++,one-=2){\n\t\tif(two>=m+1){\n\t\t\tdel+=update(n*(AR(two-(m+1),n-1)));\n\t\t\tUP(del);\n\t\t}\n\t\tif(one>n) continue;\n\t\tres+=(update((AR(two,n)+MOD-del)*C(n,one)));\n\t\tif(one!=0){\n\t\t\tres-=update(update(n*AR(two-m,n-1))*C(n-1,one-1));\n\t\t}\n\t\tres+=MOD;\n\t\tUP(res);\t\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n/*\n2 5\n6\n100 97\n20341054\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n\n#define rep(i, n)    for(int i = 0; i < (n); ++i)\n#define repA(i, a, n)  for(int i = a; i <= (n); ++i)\n#define repD(i, a, n)  for(int i = a; i >= (n); --i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define fill(a)  memset(a, 0, sizeof (a))\n#define fst first\n#define snd second\n#define mp make_pair\n#define pb push_back\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nll f[5000009],inv[5000009];\nconst ll mod= 998244353;\nvoid pre(){\n\tf[0]=f[1]=1;\n\tinv[0]=inv[1]=1;\n\trepA(i,2,5000000){\n\t\tf[i]=f[i-1]*i%mod;\n\t\tinv[i]=mod-(mod/i)*inv[mod%i]%mod;\n\t}\n\trepA(i,2,5000000) inv[i]=inv[i-1]*inv[i]%mod;\n\n}\nll C(int n,int r){\n\treturn f[n]*inv[r]%mod*inv[n-r]%mod;\n}\nvoid solve(){\n\n\n}\n\nint main() {\n\tcin.sync_with_stdio(0); cin.tie(0);\n\tcin.exceptions(cin.failbit);\n\tpre();\n\tint n;cin>>n;\n\tint m;cin>>m;\n\tll ans = C(3*m+n-1,n-1);\n\trep(i,m){\n\t\tans-=C(i+n-2,n-2)*n%mod;\n\t}\n\trepA(i,m+2,n){\n\t\tans-=C(n,i)*C((3*m-i)/2+n-1,n-1)%mod;\n\t\ti++;\n\t}\n\tcout<<(ans%mod+mod)%mod;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#define mod 998244353\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0' && ch<='9')x=x*10+ch-'0',ch=getchar();\n    return x*f;\n}\ninline void write(int x)\n{\n    if(x<0)putchar('-'),x=-x;\n    if(x>9)write(x/10);\n    putchar(x%10+'0');\n}\ninline void pr1(int x){write(x),putchar(' ');}\ninline void pr2(int x){write(x),puts(\"\");}\nint fac[2500010],inv[2500010];\ninline int power(int a,int b)\n{\n\tint ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=1LL*ans*a%mod;\n\t\ta=1LL*a*a%mod;\n\t\tb>>=1;\n\t}return ans;\n}\ninline int C(int n,int m)\n{\n\tif(n<0 || m<0)return 0;\n\treturn 1LL*fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nint main()\n{\n    //freopen(\"a.in\",\"r\",stdin);\n    //freopen(\"a.out\",\"w\",stdout);\n    fac[0]=1;\n    for(int i=1;i<=2500000;i++)fac[i]=1LL*fac[i-1]*i%mod;inv[2500000]=power(fac[2500000],mod-2);\n    for(int i=2500000;i>=1;i--)inv[i-1]=1LL*inv[i]*i%mod;\n    int n=read(),m=read(),ans;\n    ans=C(n-1+3*m,n-1);\n    for(int i=m+1;i<=min(n,3*m);i++)\n\t{\n\t\tif((3*m-i)&1)continue;\n\t\t(ans-=1LL*C(n,i)*C((3*m-i)/2+n-1,n-1)%mod-mod)%=mod;\n\t}\n    for(int i=2*m+1;i<=3*m;i++)(ans-=1LL*n*C(3*m-i+n-2,n-2)%mod-mod)%=mod;\n    pr2(ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string> \n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm> \n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n// modint: mod 計算を int を扱うように扱える構造体\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\n//const int MOD = 1000000007;\nconst int MOD = 998244353;\nusing mint = Fp<MOD>;\nBiCoef<mint> bc;\n\nvoid solve() {\n\tint n, m; cin >> n >> m;\n    mint ans = 0;\n    bc.init(3003000);\n    if(m % 2 == 0) {\n        for(int i = 0; i <= min(n, m); i += 2) {\n            int k = m + (m - i) / 2;\n            ans += bc.com(n + k - 1, n - 1) - ((mint)n * bc.com(n + k - m - 1, n - 1) - (mint)(n - i) * bc.com(n - 1 + k - m - 1, n - 1));\n        }\n    } else {\n        for(int i = 1; i <= min(n, m); i += 2) {\n            int k = m + (m - i) / 2;\n            ans += bc.com(n + k - 1, n - 1) - ((mint)n * bc.com(n + k - m - 1, n - 1) - (mint)(n - i) * bc.com(n - 1 + k - m - 1, n - 1));\n        }\n    }\n    cout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\nconst int mod = 998244353;\n\nll mpow(ll x, ll n) {\n  ll res = 1;\n  while (n) {\n    if (n & 1) res = res * x % mod;\n    x = x * x % mod;\n    n /= 2;\n  }\n  return res;\n}\n\nvl fac(3e6, 1);\nvl invfac(fac.size(), 1);\n\nll bin(int n, int k) {\n  if (k < 0 || k > n) return 0;\n  return fac[n] * invfac[k] % mod * invfac[n - k] % mod;\n}\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  for (int i = 2; i < (int)fac.size(); ++i) {\n    fac[i] = fac[i - 1] * i % mod;\n    invfac[i] = mpow(fac[i], mod - 2);\n  }\n  int n, m;\n  cin >> n >> m;\n  ll res = 0;\n  for (int k = m % 2; k <= m; k += 2) {\n    int a = (m - k) / 2;\n    res = (res + (bin(n - 1 + m + a, n - 1) - (n - k) * bin(n - 1 + a - 1, n - 1) - k * bin(n - 1 + a, n - 1)) % mod * bin(n, k)) % mod;\n  }\n  cout << (res % mod + mod) % mod << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// C - GP 2\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define\tMOD 998244353\n\nstruct FactTable {\n\tvector<long long> a;\n\tFactTable(int n) : a(n + 1, 1) { for (int i = 2; i < a.size(); i++) a[i] = a[i - 1] * i % MOD; }\n\tinline long long operator()(int n) { return a[n]; }\n} fact(1000000);\n\nlong long minv(long long a)\n{\n\tlong long r = 1;\n\tfor (long long n = MOD - 2; n > 0; a = a * a % MOD, n >>= 1)\n\t\tif (n & 1) r = r * a % MOD;\n\treturn r;\n}\n\nlong long cnr(int n, int r)\n{\n\tif (r < 0 || r > n) return 0;\n\tif (r == 0 || r == n) return 1;\n\treturn fact(n) * minv(fact(r)) % MOD * minv(fact(n - r)) % MOD;\n}\n\nint main(int argc, char *argv[])\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n\n\tlong long n, m;\n\tcin >> n >> m;\n\n\tlong long ans = 0;\n\n\tfor (int k = 0; k <= min(m, n); k++) {\n\t\tif ((3 * m - k) % 2) continue;\n\t\tlong long c = (3 * m - k) / 2;\n\t\tans = (ans + cnr(c + n - 1, c) * cnr(n, k) % MOD) % MOD;\n\t}\n\n\tlong long r = 0;\n\tfor (int k = 0; k <= min(m, n); k++) {\n\t\tif ((m - k) % 2) continue;\n\t\tlong long c = (m - k) / 2;\n\t\tr = (r + cnr(c + n - 1, c) * cnr(n, k) % MOD - cnr(c + n - 2, c) * cnr(n - 1, k) % MOD + MOD) % MOD;\n\t}\n\tans = (ans - r * n % MOD + MOD) % MOD;\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\n\nclass ModInt {\npublic:\n\tstatic unsigned MOD;\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= ModInt(get<1>(extgcd(that.x, int(MOD))));\n\t}\n\tModInt &operator%=(ModInt that) {\n\t\tx %= that.x;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\tModInt &operator/=(const int that) { return *this /= ModInt(that);}\n\tModInt &operator%=(const int that) { return *this %= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) { return x < that.x; }\n\tbool operator >(ModInt that) { return x > that.x; }\n\tbool operator<=(ModInt that) { return x <= that.x; }\n\tbool operator>=(ModInt that) { return x >= that.x; }\n\tbool operator!=(ModInt that) { return x != that.x; }\n\tbool operator==(ModInt that) { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that;}\n\tModInt operator%(ModInt that) const { return ModInt(*this) %= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator/(const int that) const { return ModInt(*this) /= that;}\n\tModInt operator%(const int that) const { return ModInt(*this) %= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n\t\n\tinline tuple<int, int, int> extgcd(int a, int b) {\n\t\tif (b == 0) return make_tuple(a, 1, 0);\n\t\ttuple<int, int, int> ret = extgcd(b, a % b);\n\t\tswap(get<1>(ret), get<2>(ret));\n\t\tget<2>(ret) -= a / b * get<1>(ret);\n\t\treturn ret;\n\t}\n};\n\nunsigned ModInt::MOD = 998244353;\nusing mint = ModInt;\nconst mint ZERO = mint(0);\nconst mint ONE = mint(1);\nconst mint TWO = mint(2);\n\nvector<mint> Fact, InvFact;\nvoid makeFact(int n){\n\tFact = vector<mint>(n+1);\n\tFact[0] = mint(1);\n\trep(i,1,n+1) Fact[i] = mint(i) * Fact[i-1];\n\n\tInvFact = vector<mint>(n+1);\n\tInvFact[n] = mint(1) / Fact[n];\n\trrep(i,n) InvFact[i] = mint(i+1) * InvFact[i+1];\n}\n\nmint Factorial(int n){ return Fact[n];}\nmint InverseFactorial(int n){ return InvFact[n];}\nmint Permutation(int n,int k){ return (n < 0 or k < 0 or n - k < 0) ? ZERO : Fact[n] * InvFact[n - k];}\nmint Combination(int n,int k){ return (n < 0 or k < 0 or n - k < 0) ? ZERO : Fact[n] * InvFact[k] * InvFact[n-k];}\nmint CombinationRepeat(int n, int k) {return Combination(n + k - 1, k - 1);}\n\nconst int limit = 3000010;\n\nmint memo[limit];\n\nint main(void){\n\tint n, m;\n\tcin >> n >> m;\n\n\tmakeFact(limit);\n\n\tmint ans = ZERO;\n\t// max(x_i) == 2 * m\n\tfor(int i = m % 2; i <= m; i += 2){\n\t\tmint coef = mint(n) * Combination(n - 1, i);\n\t\tconst int all = (m - i) / 2;\n\t\tans += coef * CombinationRepeat(all, n - 1);\n\t}\n\n\t// max(x_i) < 2 * m\n\tfor(int j = 0; j <= m; ++j){\n\t\tif(j - 1 >= 0) memo[j] += memo[j - 1];\n\t\tmemo[j] += CombinationRepeat(j, n - 1);\n\t}\n\n\tfor(int i = m % 2; i <= m; i += 2){\n\t\tmint coef = Combination(n, i);\n\t\tconst int all = (3 * m - i) / 2;\n\t\tmint val = CombinationRepeat(all, n) - mint(n) * memo[all - m];\n\t\tans += coef * val;\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Fast {\n    Fast() {\n        std::cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.precision(20);\n    }\n} fast;\n\n/* define */\n#define FOR(I, X, Y) for (long long(I) = (X); (I) < (Y); (I)++)\n#define REP(I, X, Y) for (long long(I) = (Y)-1; (I) >= (X); (I)--)\n#define ALL(X) (X).begin(), (X).end()\n#define pb push_back\n#define COUNT(V, X)                           \\\n    (upper_bound((V).begin(), (V).end(), X) - \\\n     lower_bound((V).begin(), (V).end(), X))\n#define debug(x) cerr << #x << ':' << x << endl;\n#define DEBUG(v)                             \\\n    {                                        \\\n        cerr << #v << ':';                   \\\n        for (auto xv : v) cerr << xv << ' '; \\\n        cerr << endl;                        \\\n    }\n#define Yes(X) cout << (X ? \"Yes\" : \"No\") << endl;\n#define YES(X) cout << (X ? \"YES\" : \"NO\") << endl;\n#define ctoi(C) (C - '0')\n#define pow2(x) ((long long)((long long)1 << x))\n\n/* alias */\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vii = vector<vector<int>>;\nusing vl = vector<long long>;\nusing vll = vector<vector<long long>>;\nusing pi = pair<int, int>;\nusing pl = pair<long long, long long>;\ntemplate <typename T>\nusing PQ = priority_queue<T>;\ntemplate <typename T>\nusing minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst long long dx[] = {1, 0, -1, 0};\nconst long long dy[] = {0, 1, 0, -1};\nconst long long dx8[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst long long dy8[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst long long dx9[] = {1, 1, 0, -1, -1, -1, 0, 1, 0};\nconst long long dy9[] = {0, 1, 1, 1, 0, -1, -1, -1, 0};\nconst int INF = 998244353;\nconst long long LINF = 1000000000000000007;\n\n/* func */\ntemplate <typename T1, typename T2>\ninline bool chmin(T1 &a, const T2 &b) {\n    if (a > b) a = b;\n    return a > b;\n}\ntemplate <typename T1, typename T2>\ninline bool chmax(T1 &a, const T2 &b) {\n    if (a < b) a = b;\n    return a < b;\n}\nlong long max(long long x, int y) {\n    return max(x, (long long)y);\n}\nlong long max(int x, long long y) {\n    return max((long long)x, y);\n}\nlong long min(long long x, int y) {\n    return min(x, (long long)y);\n}\nlong long min(int x, long long y) {\n    return min((long long)x, y);\n}\n\n/* library */\n\nlong long POW(long long x, long long n, long long mod) {\n    long long ans = 1;\n    while (n) {\n        if (n % 2) ans *= x;\n        x *= x;\n        x %= mod;\n        ans %= mod;\n        n >>= 1;\n    }\n    return ans;\n}\nvector<long long> factorial(2, 1);\nlong long comb(long long n, long long k, long long p) {\n    if (n < k || n < 0 || k < 0) return 0;\n    while (factorial.size() <= n) {\n        long long i = factorial.size();\n        factorial.push_back(i * factorial[i - 1] % p);\n    }\n    return ((factorial[n] * POW(factorial[k], p - 2, p)) % p) *\n           POW(factorial[n - k], p - 2, p) % p;\n}\n\nlong long TwelvefoldWay4(long long n, long long k, long long MOD) {\n    return comb(n + k - 1, n, MOD);\n}\n\n/* main */\n\nsigned main() {\n    ll N, M;\n    cin >> N >> M;\n    ll ans = 0;\n    for (ll i = 0; i <= M; i += 2) {\n        ll tmp1 = TwelvefoldWay4((M + i / (ll)2), N, INF);\n        ll tmp2 = ((i != 0 ? TwelvefoldWay4(i / (ll)2 - (ll)1, N, INF) : (ll)0) * N) % INF;\n        ll tmp3 = comb(N, M - i, INF);\n        ll tmp4 = (TwelvefoldWay4(i / 2, N - 1, INF) * N) % INF;\n        ll tmp5 = comb(N - 1, M - i - 1, INF);\n        // cerr << i << tmp1 << ' ' << tmp2 << ' ' << tmp3 << ' ' << tmp4 << ' ' << tmp5 << endl;\n        ans += (((tmp1 - tmp2 + INF) % INF) * tmp3) % INF;\n        ans -= (tmp4 * tmp5) % INF;\n        ans %= INF;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 3000300;\nconst int mod = 998244353;\n\nvoid add(int &x, int y) {\n\tx += y;\n\tif (x >= mod) x -= mod;\n}\n\nvoid sub(int &x, int y) {\n\tx -= y;\n\tif (x < 0) x += mod;\n}\n\nint mul(int x, int y) {\n\treturn (long long) x * y % mod;\n}\n\nint pw(int x, int y) {\n\tint ans = 1;\n\tfor (; y > 0; y >>= 1, x = mul(x, x)) {\n\t\tif (y & 1) ans = mul(ans, x);\n\t} \n\treturn ans;\n}\n\nint fact[N];\nint ifact[N];\n\nint C(int n, int k) {\n\tif (n < k || k < 0) return 0;\n\treturn mul(fact[n], mul(ifact[k], ifact[n - k]));\n}\n\nvoid precalc() {\n\tfact[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tfact[i] = mul(fact[i - 1], i);\n\t}\t\t\n\tifact[N - 1] = pw(fact[N - 1], mod - 2);\n\tfor (int i = N - 1; i > 0; --i) {\n\t\tifact[i - 1] = mul(ifact[i], i);\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tprecalc();\n\tint n, m;\n\tcin >> n >> m;\n\tint ans = C(3 * m + n - 1, n - 1);\n\tsub(ans, mul(n, C(m - 1 + n - 1, n - 1)));\n\tfor (int i = m + 2; i <= n; i += 2) {\n\t\tsub(ans, mul(C(n, i), C((3 * m - i) / 2 + n - 1, n - 1)));\n\t}\n\tcout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\nusing ll = long long;\n\n// Fermat の小定理を用いた F_mod 上での逆元計算x^(mod-2), 蟻本p115\nll Inverse(ll x){\n    ll res = 1;\n    int n = mod - 2;\n    while(n > 0){\n        if(n & 1){\n            res = res * x % mod;\n        }\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    /*\n     * 全部の組み合わせから不可能なものを引く\n     * 不可能なのは\n     * 1. ある値が2Mより大きい\n     * 2. 値が奇数のものがM個より多い\n     * のどちらか, これらは背反(和は3Mより)\n     * 奇数に1を1回, 最大の数から2を割り振れば構成できる\n     */\n\n    // 階乗計算, iの階乗 = fact[i}\n    vector<ll>fact(3 * M + N);\n    fact[0]=1;\n    for(int i=1; i < 3 * M + N + 1; i++){\n        fact[i] = fact[i-1] * i % mod;\n    }\n\n    ll ans = fact[3*M+N-1] * Inverse(fact[N-1] * fact[3*M] % mod);\n    ans %= mod;\n\n\n    // ある値が2Mより大きい場合, 他の値の合計で回す\n    ll over = 0;\n    for (int i = 0; i < M; ++i) {\n        over = over + fact[i+N-2] * Inverse(fact[N-2] * fact[i] % mod);\n        over %= mod;\n    }\n    over = over * (N-1);\n    over %= mod;\n    ans = ans + mod - over;\n    ans %= mod;\n\n\n    // 値が奇数のものがM個より多い場合, 奇数の個数で回す\n    ll many = 0;\n    for (int i = M+1; i < N+1; ++i) {\n        if((3 * M - i) % 2 == 1) continue;\n        ll temp = 0;\n        int sum = (3 * M - i) / 2;\n        temp = temp + fact[sum+N-1] * Inverse(fact[N-1] * fact[sum] % mod);\n        temp %= mod;\n        temp = temp * fact[N];\n        temp %= mod;\n        temp = temp * Inverse(fact[i] * fact[N-i] % mod);\n        temp %= mod;\n        many += temp;\n        many %= mod;\n    }\n    ans = ans + mod - many;\n    ans %= mod;\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=1000000;\nconst int MAXM=500000;\nconst int MAXFAC=3*MAXM+MAXN-1;\nconst int MOD=998244353;\n\nint inv[MAXFAC+1];\nint fac[MAXFAC+1];\nint ifac[MAXFAC+1];\nint choose(int n,int k) { assert(n>=0&&n<=MAXFAC); if(k<0||k>n) return 0; return (ll)fac[n]*ifac[k]%MOD*ifac[n-k]%MOD; }\n\nint n,m;\n\nint solve() {\n\tinv[1]=1; FORE(i,2,MAXFAC) inv[i]=(ll)(MOD-MOD/i)*inv[MOD%i]%MOD;\n\tfac[0]=1; FORE(i,1,MAXFAC) fac[i]=(ll)fac[i-1]*i%MOD;\n\tifac[0]=1; FORE(i,1,MAXFAC) ifac[i]=(ll)ifac[i-1]*inv[i]%MOD;\n\n\tint ret=choose(3*m+n-1,n-1);\n\tint sub=(ll)n*choose(m-1+n-1,n-1)%MOD;\n\tret-=sub; if(ret<0) ret+=MOD;\n\treturn ret;\n}\n\nvoid run() {\n\tscanf(\"%d%d\",&n,&m);\n\tprintf(\"%d\\n\",solve());\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n//  a^b % m\nlong long powmod(long long a, long long b, long long m)\n{\n    long long r = 1;\n    for (; b>0; b>>=1, a=a*a%m)\n        if (b&1)\n            r = r*a%m;\n    return r;\n}\n\nint main()\n{\n    long long N, M;\n    cin>>N>>M;\n\n    long long MOD = 998244353;\n    long long t = M*3/2;\n\n    vector<long long> T1(t+1);\n    vector<long long> P(t+1);\n    for (int i=0; i<=M; i++)\n        T1[i] = 1;\n    for (int i=1; i<N; i++)\n    {\n        P.swap(T1);\n\n        //for (int i=0; i<=t; i++)\n        //{\n        //    for (int j=0; j<=min(i, (int)M); j++)\n        //        T1[i] += P[i-j];\n        //    T1[i] %= MOD;\n        //}\n\n        T1[0] = P[0];\n        for (int i=1; i<=t; i++)\n        {\n            T1[i] = T1[i-1] + P[i];\n            if (i-M-1>=0)\n                T1[i] -= P[i-M-1];\n            T1[i] = (T1[i]+MOD)%MOD;\n        }\n    }\n\n    vector<long long> T2(t+1);\n    for (int i=0; i<=M-1; i++)\n        T2[i] = 1;\n    if (M-1>0)\n    for (int i=1; i<N; i++)\n    {\n        P.swap(T2);\n\n        //for (int i=0; i<=t; i++)\n        //{\n        //    for (int j=0; j<=min(i, (int)M-1); j++)\n        //        T2[i] += P[i-j];\n        //    T2[i] %= MOD;\n        //}\n\n        T2[0] = P[0];\n        for (int i=1; i<=t; i++)\n        {\n            T2[i] = T2[i-1] + P[i];\n            if (i-(M-1)-1>=0)\n                T2[i] -= P[i-(M-1)-1];\n            T2[i] = (T2[i]+MOD)%MOD;\n        }\n    }\n\n    vector<long long> F(N+1);\n    F[0] = 1;\n    for (int i=1; i<=N; i++)\n        F[i] = F[i-1]*i%MOD;\n\n    long long ans = 0;\n    for (int o=M*3%2; o<=N; o+=2)\n    {\n        long long t1 = F[N]*powmod(F[o], MOD-2, MOD)%MOD*powmod(F[N-o], MOD-2, MOD)%MOD;\n        ans += T2[(M*3-o)/2]*t1;\n        ans %= MOD;\n\n        if (o<N)\n        {\n            long long t2 = F[N-1]*powmod(F[o], MOD-2, MOD)%MOD*powmod(F[N-1-o], MOD-2, MOD)%MOD;\n            ans += (T1[(M*3-o)/2] - T2[(M*3-o)/2] + MOD)%MOD*t2;\n            ans %= MOD;\n        }\n    }\n\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 998244353;\n\nclass combination_mod{\n  const long long mod;\n  const long long size;\n  \n  vector<long long> fact; //n!\n  vector<long long> fact_inv; // (n!)^-1\n\n  void make_fact(){\n    fact[0] = 1;\n    for(long long i=1; i<size; i++){\n      fact[i] = fact[i-1]*i % mod;\n    }\n  }\n\n  void make_fact_inv(){\n    fact_inv[0] = fact_inv[1] = 1;\n    for(long long i=2; i<size; i++){\n      fact_inv[i] = fact_inv[mod%i] * (mod - mod/i) % mod;  // x ^ -1\n    }\n    for(int i=2; i<size; i++){\n      fact_inv[i] = fact_inv[i-1] * fact_inv[i] % mod;  // x! ^ -1\n    }\n  }\n\npublic:\n  combination_mod(long long mod_, long long size_ = 2000000) : mod(mod_), size(size_+1){\n    fact.resize(size);\n    fact_inv.resize(size);\n    make_fact();\n    make_fact_inv();\n  }\n\n  //nCk mod p O(1)\n  long long operator()(long long n, long long k){\n    if(k==0 || n==k) return 1;\n    long long ret = fact[n] * fact_inv[k] % mod * fact_inv[n-k] % mod;\n    return ret;\n  }\n};\n\n\nint main(){\n  long long n,m;\n  cin >> n,m;\n\n  combination_mod c(mod, n+m*3*10);\n\n  vector<long long> dp(n+m*3+10, 0);\n  for(long long x=n-2; x<=n+m*3; x++){\n    dp[x] = c(x, n-2);\n  }\n  for(long long x=n-2; x<=n+m*3; x++){\n    dp[x] = (dp[x] + dp[x-1])% mod;\n  }\n\n  long long ans = 0;\n  for(long long odd=0; odd<=m && odd<=n; odd++){\n    long long rem = 3*m - odd;\n    if(rem%2 != 0) continue;\n    rem /= 2;\n    long long p_box = c(n, odd);\n    long long p_ball = c(rem + n-1, n-1);\n    long long tmp = p_ball;\n    // 2m on an odd box\n    if(rem >= m){\n      long long a = odd;\n      long long b = c(rem - m + n-1 - 1, n-1 -1);\n      tmp = (tmp - a * b % mod + mod) % mod;\n    }\n    // for(long long k=1; m+k<=rem; k++){ // 2m + 2k box\n    //   long long b = c(rem - (m + k) + n-1 -1, n-1 -1);\n    //   tmp = (tmp - b * n % mod + mod) % mod;\n    // }\n    if(rem - (m+1) >= 0){\n      long long s = dp[rem - (m+1) + n-1 -1];\n      tmp = (tmp - s * n % mod + mod) % mod;\n    }\n    ans = ans + tmp * p_box;\n    ans %= mod;\n  }\n  println(ans);\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    int _n = 3*m/2 + n + 100;\n    vector<mint> fac(_n+1);\n    vector<mint> ifac(_n+1);\n    vector<mint> inv(_n+1);\n    auto build = [&](){\n        fac[0] = fac[1] = 1;\n        ifac[0] = ifac[1] = 1;\n        inv[1] = 1;\n        for (int i = 2; i <= _n; i++) {\n            fac[i] = fac[i-1] * i;\n            inv[i] = (-MOD/i) * inv[MOD%i];\n            ifac[i] = ifac[i-1] * inv[i];\n        }\n    };\n    build();\n    auto c = [&](int i, int j){\n        if (i < j || j < 0) return mint(0);\n        return fac[i] * ifac[j] * ifac[i-j];\n    };\n    mint full = 0;\n    for (int odd = 0; odd <= min(n, m); odd++) {\n        if ((3*m-odd) & 1) continue;\n        full += c(n, odd) * c((3*m-odd)/2 + n-1, n-1);\n    }\n    mint exes = 0;\n    for (int odd = 0; odd <= min(n, m); odd++) {\n        if ((m-odd) & 1) continue;\n        exes += c(n, odd) * c((m-odd)/2 + n-1, n-1);\n    }\n    for (int odd = 0; odd <= min(n-1, m); odd++) {\n        if ((m-odd) & 1) continue;\n        exes -= c(n-1, odd) * c((m-odd)/2 + n-2, n-2);\n    }\n    mint res = full - n*exes;\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntypedef long long ll;\ntypedef long double ld;\nconst ll MOD = 998244353;\nconst int MAXN = 2000005;\nll fac[MAXN], invfac[MAXN];\nll binom(ll a, ll b) {\n\tif (b < 0) return 0;\n\tif (b > a) return 0;\n\treturn (((fac[a] * invfac[b]) % MOD) * invfac[a - b]) % MOD;\n}\nll modex(ll a, ll p, ll m = MOD) {\n\tif (!p) return 1;\n\tif (p & 1) return a * modex(a, p - 1, m) % m;\n\tll v = modex(a, p >> 1, m);\n\treturn v * v % m;\n}\nint main() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < MAXN; ++i)\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\tinvfac[MAXN - 1] = modex(fac[MAXN - 1], MOD - 2);\n\tfor (int i = MAXN - 2; i >= 0; --i)\n\t\tinvfac[i] = invfac[i + 1] * (i + 1) % MOD;\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tll tot = m * 3;\n\tll ans = 0;\n\tfor (int odds = 0; odds <= min(m, n); ++odds) {\n\t\tll rem = tot - odds;\n\t\tif (rem & 1) continue;\n\t\trem /= 2;\n\t\tll v = binom(rem + n - 1, n - 1);\n\t\tv -= (n - odds) * binom(rem - (m + 1) + n - 1, n - 1);\n\t\tv -= odds * binom(rem - m + n - 1, n - 1);\n\t\tv %= MOD;\n\t\tans += v * binom(n, odds);\n\t\tans %= MOD;\n\t}\n\tif (ans < 0) ans += MOD;\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits>\n#include <cfenv>\n#include <cmath>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cstring>\n#include <map>\n#include <stack>\n#include <set>\n#include <tuple>\n#include <queue>\n#include <vector>\n#include <cmath>\n#include <random>\n#include <math.h>\n#include <list>\n#include <random>\n#include <functional>\n\n\n#define FOR(i, a, b) for(int (i) = (a); (i) < (b); ++(i))\n#define REP(i, n) FOR(i, 0, n)\n#define rREP(i, n) for(int (i) = (n) - 1; (i) >= 0; --(i))\n#define ALL(TheArray) TheArray.begin(), TheArray.end()\n\nusing lli = long long int;\nusing pii = std::pair<int, int>;\n\ntemplate <class T> inline bool chmax(T& a, T b){\n    if(a < b){a = b; return true;}\n    return false;\n}\ntemplate <class T> inline bool chmin(T& a, T b){\n    if(a > b){a = b; return true;}\n    return false;\n}\n\n\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n// constexpr version : N が clang++ : 3e5くらいまでok,  g++ : 2e6くらいまでok\ntemplate <int N, long long int mod>\nstruct CombinationMod{\nprivate:\n    using lli = long long int;\npublic:\n    std::array<lli, N+1> Power, Inverse, powInverse;\n\n    CombinationMod(int n){\n        init(n);\n    }\n\n    void init(int n){\n        Power[0] = 1; Inverse[0] = 1; powInverse[0] = 1;\n        for(int x = 1; x <= n; ++x) Power[x] = (Power[x-1] * x) % mod;\n        powInverse[n] = inverse(Power[n]);\n        for(int x = N; x > 0; --x) powInverse[x-1] = (powInverse[x] * x) % mod;\n        for(int x = 1; x <= n; ++x) Inverse[x] = (Power[x-1] * powInverse[x]) % mod;\n    }\n    constexpr void swap(lli &a, lli &b) const {\n        a ^= b; b ^= a; a ^= b;\n    }\n    constexpr lli inverse(lli a) const noexcept{\n        lli b = mod, u = 1, v = 0;\n        while (b != 0) { \n            lli t = a / b; a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        u %= mod; if (u < 0) u += mod;\n        return u;\n    }\n    // nCkを求める関数 : n < k の入力に注意せよ\n    inline lli combination(int n, int k) const noexcept{\n        if(n < k or k < 0) return 0;\n        return ((Power[n] * powInverse[k] % mod) * powInverse[n-k]) % mod;\n    }\n};\n\n\n\n\n/* fn(x, y) := 2加算をx回, 1加算をy回することによって得られる場合の数\n   このとき, fn(M, M)が求める答えの近似になる | 条件緩和　-> 加算をそれぞれ独立に考えられる\n   追加制約として, 「全てのインデックスについて選ばれた回数が高々M回」を課す\n   ---> 再帰で解くのは少し厳しそう; 何かいい言い換えはないか？\n   それぞれの操作の特徴は何か？\n   １加算 -> 偶奇反転, 2回で2加算と同一視\n   ２加算 -> 偶奇普遍\n   追加制約を考えれば奇数の数は高々M個 ; なんか良さげな条件 | いや扱いにくいか？\n   操作終了後の総和は 3M である\n   最大要素は2Mでバウンドされる\n   こんな感じの性質を満たしそう(このくらいしか思いつかない : 場所に制約がないので一松模様なども不可)\n   逆にこの条件で構成可能か？可能っぽい気がするけど気もしない...\n        大きい数から２加算の操作を割り当てると考えると, 残りの総和は高々M\n        2M - K の山に関して (K ≤ M) 他の山の最大は K であるから操作は M - K回行われMを超えない\n        あまったところに1加算を割り当てれば良い、そしてこれはMを超えない\n        奇数をあらかじめ選んでから残りの数(偶数)の配分を決定ればいい -> よし！\n 　雑に数えると\n    ∑_k nCk * H((3M - k) / 2, n) | for all k s.t. 0 ≤ k ≤ M , (3M - k) % 2 == 0\n   最大山が2M以下が考慮されていない -> その数を除去する\n   for all i in 1...M, 残り M - i の問題について考えられる | この最大山の選び方は M通り！\n*/\n\nconstexpr int _M = 2e6 + 5e5;\nconstexpr int mod = 998244353;\nconst CombinationMod<_M, mod> Comb(_M);\n\n\nint main(void){\n    int n, m; scanf(\"%d%d\", &n, &m);\n    lli P = 0;\n    lli tm = 3 * m, even = tm & 1;\n    if(even) tm--; tm /= 2; int e = (n > m) ? m : n;\n    while(tm >= 0 and even <= e){\n        (P += Comb.combination(n, even) * Comb.combination(n + tm - 1, tm)) %= mod;\n        tm--; even += 2;\n    }\n    lli Q = 0; \n    for(int i = 1; i <= m; ++i) (Q += Comb.combination(m - i + n - 2, m - i)) %= mod;\n    (Q *= n) %= mod; \n    P -= Q; if(P < 0) P += mod;\n    printf(\"%lld\\n\", P % mod);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 998244353\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nll n, m, ans;\nll fact[2222222];\nll invfact[2222222];\nll dp[1111111];\nll dp2[1111111];\n\nlong long mod_div(long long a,long long b){\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n\nll nHr(ll n, ll r){\n\tll A = n - 1;\n\tll B = r;\n\treturn mod_div(fact[A + B], fact[A] * fact[B] % MOD);\n}\n\nll nCr(ll n ,ll r){\n\tif(r > n){\n\t\treturn 0;\n\t}\n\treturn mod_div(fact[n], fact[n - r] * fact[r] % MOD);\n}\n\nvoid init(){\n\tfact[0] = 1;\n\tfor(ll i = 1;i < 2222222;i++){\n\t\tfact[i] = fact[i-1] * i % MOD;\n\t\tinvfact[i] = mod_div(1, fact[i]);\n\t}\n}\n\nint main(){\n\tinit();\n\tcin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n\n\tcin >> n >> m;\n\n\tREP(i, 1111111){\n\t\tdp2[i] = nHr(n - 1, i);\n\t\tif(i){\n\t\t\tdp2[i] = (dp2[i] + dp2[i-1]) % MOD;\n\t\t}\n\t}\n\tREP(i, 1111111){\n\t\tdp2[i] = (dp2[i] * n) % MOD;\n\t}\n\n\tdp[0] = 1;\n\tfor(ll i = 1;i < 1111111;i++){\n\t\tdp[i] = nHr(n, i);\n\t\tif(i > m){\n\t\t\tdp[i] = (dp[i] - dp2[i - (m+1)] + MOD) % MOD;\n\t\t}\n\t}\n\n\tfor(ll i = 0;i <= m;i++){\n\t\tif((3 * m - i) % 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tll now_m = (3 * m - i) / 2;\n\t\tll now_one = i;\n\t\tll now = dp[now_m] * nCr(n, i);\n\t\tif(now_m >= m && i){\n\t\t\tll tmp = nHr(n - 1, now_m - m) * nCr(n - 1, i - 1) % MOD;\n\t\t\ttmp = tmp * n % MOD;\n\t\t\tnow = (now + MOD - tmp) % MOD;\n\t\t}\n\t\t//cout << i << \" \" << now_m << \" \" << dp[now_m] << \" \" << now << endl;\n\t\tans = (ans + now) % MOD;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 998244353\n#define MAX 5000000\nusing namespace std;\n\nlong long factorial[MAX] = {0}, finverse[MAX] = {0},\n          inverse[MAX] = {0};\n\nvoid smodfact() {\n  factorial[0] = factorial[1] = 1;\n  finverse[0] = finverse[1] = 1;\n  inverse[1] = 1;\n  for(int i = 2; i < MAX; ++i) {\n    factorial[i] = factorial[i - 1] * i % N;\n    inverse[i] = N - (inverse[N % i] * (N / i)) % N;\n    finverse[i] = finverse[i - 1] * inverse[i] % N;\n  }\n}\n\nlong long calccomb(long long n, long long k) {\n  if(n == k && n == 0) return 1;\n  if(n < 0 || k < 0 || n < k) return 0;\n  return factorial[n] * finverse[k] % N * finverse[n - k] %\n         N;\n}\n\nlong long n, m;\n\nlong long solve();\n\nint main() {\n  smodfact();\n  cin >> n >> m;\n\n  cout << solve() << endl;\n  return 0;\n}\n\nlong long solve() {\n  long long ans = 0;\n  for(int i = 0; i <= min(m, n); ++i)\n    if((m - i) % 2 == 0) {\n      long long now = calccomb(n, i),\n                dummy1 = calccomb(n - 1, i - 1) * n % N,\n                dummy2 = calccomb(n - 1, i) * n % N;\n      now *= calccomb(m + (m - i) / 2 + n - 1, n - 1);\n      now %= N;\n      // dummy1\n      dummy1 *= calccomb((m - i) / 2 + n - 1, n - 1);\n      dummy1 %= N;\n      now -= dummy1;\n      while(now < 0) now += N;\n      // dummy2\n      dummy2 *= calccomb((m - i) / 2 - 1 + n - 1, n - 1);\n      dummy2 %= N;\n      now -= dummy2;\n      while(now < 0) now += N;\n      ans += now;\n      ans %= N;\n    }\n  return ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define ft first\n#define sd second\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define Fr(i,n) for(int i=1;i<=(n);++i)\n#define ifr(i,n) for(int i=(n)-1;i>=0;--i)\n#define iFr(i,n) for(int i=(n);i>0;--i)\n\nstruct modint{\n    ll a;\n    const ll MOD=998244353;\n    modint(ll a_=0){\n        a=((a_%MOD)+MOD)%MOD;\n    }\n    modint inv()const{\n        ll n=1,m=MOD-2,A=a;\n        while(m){\n            if(m&1)(n*=A)%=MOD;\n            (A*=A)%=MOD;\n            m>>=1;\n        }\n        modint y(n);\n        return y;\n    }\n    bool operator==(const modint& x){\n        return a==x.a;\n    }\n    bool operator!=(const modint& x){\n        return a!=x.a;\n    }\n    modint& operator=(const modint& x){\n        a=x.a;\n        return *this;\n    }\n    modint operator+(const modint& x){\n        modint y(a+x.a);\n        return y;\n    }\n    modint operator-(const modint& x){\n        modint y(a-x.a);\n        return y;\n    }\n    modint operator*(const modint& x){\n        modint y(a*x.a);\n        return y;\n    }\n    modint operator/(const modint& x){\n        return *this * x.inv();\n    }\n    modint& operator+=(const modint& x){\n        *this=*this+x;\n        return *this;\n    }\n    modint& operator-=(const modint& x){\n        *this=*this-x;\n        return *this;\n    }\n    modint& operator*=(const modint& x){\n        *this=*this*x;\n        return *this;\n    }\n    modint& operator/=(const modint& x){\n        *this=*this/x;\n        return *this;\n    }\n};\nistream& operator>>(istream &in,modint& x){\n    ll a_;\n    in>>a_;\n    modint y(a_);\n    x=y;\n    return in;\n}\nostream& operator<<(ostream &out,const modint& x){\n    out<<x.a;\n    return out;\n}\nmodint pwr(ll a,ll b){\n    modint n(1),A(a);\n    while(b){\n        if(b&1) n*=A;\n        A*=A;\n        b>>=1;\n    }\n    return n;\n}\n\nvector<modint> fc(2000010);\nmodint fct(ll x){\n    if(x==0) return 1;\n    if(fc[x]==0) fc[x]=fct(x - 1)*x;\n    return fc[x];\n}\n\nvector<modint> ifc(2000010);\nmodint ifct(ll x){\n    if(x==2000010-1) return ifc[x]=fct(x).inv();\n    if(ifc[x] == 0) ifc[x]=ifct(x+1)*(x+1);\n    return ifc[x];\n}\n\nmodint comb(ll n, ll r) {\n    if (n < 0 || r < 0 || n < r) return 0;\n    return fct(n)*ifct(r)*ifct(n-r);\n}\n\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n,m,u;\n    cin>>n>>m;\n    modint ans;\n    fr(t,m+1) if((3*m-t)%2==0) u=(3*m-t)/2,ans+=comb(u+n-1,u)*comb(n,t);\n    cout<<ans-(comb(n+m-1,m)-comb(n+m-2,m))*n<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define f(i, a, b) for(ll i = a; i <= b; ++i)\n#define ff(i, a, b) for(ll i = a; i < b; ++i)\n#define F(i, a, b) for(ll i = a; i >= b; --i)\n#define FF(i, a, b) for(ll i = a; i > b; --i)\n#define x first\n#define y second\n#define X real()\n#define Y imag()\nusing namespace std;\ntypedef complex<ll> P;\ntypedef pair<ll, ll> ii;\ntypedef tuple<ll, ll, ll> iii;\n\nconst ll N = 3e6+7;\nconst ll mod = 998244353;\nll n, m, ans = 0, f[N], rev[N];\n\nll binpow(ll a, ll b){\n\tif(!b) return 1;\n\tif(b == 1) return a%mod;\n\tll temp = binpow(a, b/2);\n\tif(b%2 == 0) return (temp*temp)%mod;\n\telse return (temp*((temp*a)%mod))%mod;\n}\n\nvoid init(ll n){\n\tf[0] = 1;\n\tf(i,0,n){\n\t\tif(i) f[i] = (f[i-1]*i)%mod;\n\t\trev[i] = binpow(f[i], mod-2);\n\t}\n}\n\nll Ckn(ll k, ll n){\n\treturn (f[n]*((rev[n-k] * rev[k])%mod))%mod;\n}\n\nll calc(ll a, ll b, ll c){\n\tll result = 0, now = min(a, min(b, c));\n\tf(i,0,now){\n\t\tif((b-i)%2 != 0) continue;\n\t\tresult += (Ckn(i, a)*Ckn(a-1, (b-i)/2 + a-1))%mod;\n\t\tresult %= mod;\n\t}\n\treturn result;\n}\n\nsigned main(){\n//\tfreopen(\"PERFECT1.inp\",\"r\",stdin);\n//\tfreopen(\"PERFECT1.out\",\"w\",stdout);\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n >> m;\n\tinit(3*max(n, m)*1LL);\n\tans = (calc(n, 3*m, m) - n*((calc(n, m, m) - calc(n-1, m, m) + mod)%mod) + mod)%mod;\n\tans = (ans+mod)%mod;\n\tcout << ans;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\ntemplate<int m>\nstruct modint {\n\n\tunsigned x;\n\n\tmodint() : x(0) {}\n\n\tmodint(long long arg) {\n\t\targ %= m;\n\t\tif (arg < 0) {\n\t\t\tx = arg + m;\n\t\t} else {\n\t\t\tx = arg;\n\t\t}\n\t}\t\n\n\tmodint& operator+= (const modint& other) {\n\t\tx += other.x;\n\t\tif (x >= m) {\n\t\t\tx -= m;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tmodint& operator*= (const modint& other) {\n\t\tx = (x * 1ull * other.x) % m;\n\t\treturn *this;\n\t}\n\n\tmodint& operator-= (const modint& other) {\n\t\tx += m - other.x;\n\t\tif (x >= m) {\n\t\t\tx -= m;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tmodint operator+ (const modint& other) const {\n\t\tmodint tmp = *this;\n\t\ttmp += other;\n\t\treturn tmp;\n\t}\n\n\tmodint operator- (const modint& other) const {\n\t\tmodint tmp = *this;\n\t\ttmp -= other;\n\t\treturn tmp;\n\t}\n\n\tmodint operator* (const modint& other) const {\n\t\tmodint tmp = *this;\n\t\ttmp *= other;\n\t\treturn tmp;\n\t}\n\n\texplicit operator int () const {\n\t\treturn x;\n\t}\n\n\tmodint& operator++ () {\n\t\t++x;\n\t\tif (x == m) {\n\t\t\tx = 0;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tmodint& operator-- () {\n\t\tif (x == 0) {\n\t\t\tx = m-1;\n\t\t} else {\n\t\t\t--x;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tmodint operator++ (int) {\n\t\tmodint tmp = *this;\n\t\t++*this;\n\t\treturn tmp;\n\t}\n\n\tmodint operator-- (int) {\n\t\tmodint tmp = *this;\n\t\t--*this;\n\t\treturn tmp;\n\t}\n\n\tbool operator== (const modint& other) const {\n\t\treturn x == other.x;\n\t}\n\n\tbool operator!= (const modint& other) const {\n\t\treturn x != other.x;\n\t}\n\n\ttemplate<class T>\n\tmodint operator^ (T arg) const {\n\t\tif (arg == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (arg == 1) {\n\t\t\treturn x;\n\t\t}\n\t\tauto t = *this ^ (arg >> 1);\n\t\tt *= t;\n\t\tif (arg & 1) {\n\t\t\tt *= *this;\n\t\t}\n\t\treturn t;\n\t}\n\n\ttemplate<class T>\n\tmodint operator^= (T arg) {\n\t\treturn *this = *this ^ arg;\n\t}\n\n\tmodint inv() const {\n\t\treturn *this ^ (m-2);\n\t}\n};\n\nconst int MOD = 998244353;\ntypedef modint<MOD> mint;\n\nmint f[4000005], finv[4000005];\nint n, m;\n\nmint bk(int n, int k) {\n\tif (n < 0 || k < 0 || n-k < 0)\n\t\treturn 0;\n\treturn f[n] * finv[k] * finv[n-k];\n}\n\nbool proveri(vector<int>& a) {\n\tint m = accumulate(a.begin(), a.end(), 0) / 3;\n\tif (*max_element(a.begin(), a.end()) > 2*m)\n\t\treturn false;\n\tif ((int)(a.size() - count(a.begin(), a.end(), 0)) > 2*m)\n\t\treturn false;\n\tif ((int)count(a.begin(), a.end(), 1) > m)\n\t\treturn false;\n\treturn true;\n}\n\nvoid rek1(vector<int>& a, set<vector<int>>& dobri, int dub) {\n\tif (dub == 0) {\n\t\tdobri.insert(a);\n\t\treturn;\n\t}\n\n\tint n = a.size();\n\tfor (int i=0; i<n; i++) {\n\t\tfor (int j=0; j<n; j++) {\n\t\t\tif (i == j)\n\t\t\t\tcontinue;\n\t\t\ta[i] += 2;\n\t\t\ta[j] += 1;\n\t\t\trek1(a, dobri, dub-1);\n\t\t\ta[i] -= 2;\n\t\t\ta[j] -= 1;\n\t\t}\n\t}\n}\n\nvoid rek2(vector<int>& a, set<vector<int>>& dobri, int dub) {\n\tif (dub == 0) {\n\t\tif (proveri(a))\n\t\t\tdobri.insert(a);\n\t\treturn;\n\t}\n\n\tint n = a.size();\n\tfor (int i=0; i<n; i++) {\n\t\ta[i] += 1;\n\t\trek2(a, dobri, dub-1);\n\t\ta[i] -= 1;\n\t}\n}\n\n\nvoid proveri_hipotezu(int dub) {\n\tint n = 2*dub;\n\tvector<int> a(n, 0);\n\tset<vector<int>> s1, s2;\n\trek1(a, s1, dub);\n\trek2(a, s2, 3*dub);\n\tcerr << (s1 == s2) << '\\n';\n\tcerr << s1.size() << '\\n';\n\tcerr << s2.size() << '\\n';\n\n\tfor (auto v : s2) {\n\t\tif (s1.count(v) == 0) {\n\t\t\tfor (int x : v)\n\t\t\t\tcerr << x << ' ';\n\t\t\tcerr << '\\n';\n\t\t}\n\t}\n}\n\n\n/*\nzbir = 3m-k\nmesta = k\n\n3m+k-1 k-1\n*/\n\n/*\nzbir m-k\nmesta = k\n*/\n\n/*\n1 1 2 2\n1 2 3\n1 1 4\n3 3\n2 4\n2 2 2\n*/\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\tcerr.tie(nullptr);\n\n\tf[0] = finv[0] = 1;\n\tfor (int i=1; i<4000005; i++) {\n\t\tf[i] = f[i-1] * i;\n\t\tfinv[i] = f[i].inv();\n\t}\n\n\tcin >> n >> m;\n\tmint sol;\n\tfor (int k=2; k<=min(m, n); k++) {\n\t\tsol += (bk(3*m-1, k-1) - bk(m-1, k-1) * k) * bk(n, k);\n\t}\n\tfor (int k=m+1; k<=n; k++) {\n\t\tsol += bk(3*m-1, k-1)* bk(n, k);\n\t}\n\tfor (int u=m+2; u<=min(n, 3*m); u+=2) {\n\t\tmint q = bk(n, u) * bk((3*m-u)/2 + n-1, n-1);\n\t\t// cerr << u << ' ' << (int)q << ' ' << (3*m-u)/2 << ' ' << (int)bk(n, u) << '\\n';\n\t\tsol -= q;\n\t}\n\n\tcout << (int)sol << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll, int> plli;\ntypedef pair<int, pii> pipii;\ntypedef vector<vector<int> > mati;\ntypedef vector<vector<double> > matd;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\ntypedef vector<bool> vb;\ntypedef vector<vector<bool>> vvb;\ntypedef vector<vector<vector<bool>>> vvvb;\ntypedef vector<pll> vpll;\n\n#define FOR(i,x,y) for(ll i=(ll)x; i<(ll)y; ++i)\n#define REP(i,y) FOR(i, 0, y)\n#define RFOR(i,x,y) for(ll i=(ll)x; i>=(ll)y; --i)\n#define RREP(i,x) RFOR(i, x, 0)\n#define ALL(a) a.begin(), a.end()\n#define pb push_back\n\ninline void IN(void){\n  return;\n}\n\ntemplate <typename First, typename... Rest>\nvoid IN(First& first, Rest&... rest){\n  cin >> first;\n  IN(rest...);\n  return;\n}\n\ninline void OUT(void){\n  cout << \"\\n\";\n  return;\n}\n\ntemplate <typename First, typename... Rest>\nvoid OUT(First first, Rest... rest){\n  cout << first << \" \";\n  OUT(rest...);\n  return;\n}\n\ntemplate <typename T>\nvoid vec_print(vector<T> VEC){\n  REP(i, VEC.size()){\n    cout << VEC[i] << \" \";\n  }\n  cout << \"\\n\";\n};\n\ntemplate <typename T>\nvoid mat_print(vector<vector<T> > MAT){\n  REP(i, MAT.size()){\n    REP(j, MAT[i].size()){\n      cout << MAT[i][j] << \" \";\n    }\n    cout << \"\\n\";\n  }\n};\n\ntemplate <typename CLASS1, typename CLASS2>\nclass HOGE{\n  public:\n    CLASS1 key;\n    CLASS2 value;\n    HOGE(void){\n      return;\n    };\n    HOGE(CLASS1 key, CLASS2 value){\n      this->key = key;\n      this->value = value;\n    };\n    ~HOGE(void){\n      return;\n    };\n\n    void print(void){\n      cout << \"key : \" << key << \", value : \" << value << \"\\n\";\n      return;\n    };\n    \n    bool operator==(const HOGE &obj){\n      return (this->value == obj.value);\n    };\n    bool operator<(const HOGE &obj){\n      return (this->value < obj.value);\n    };\n    bool operator>(const HOGE &obj){\n      return (this->value > obj.value);\n    };\n};\n\ntemplate <typename CLASS1, typename CLASS2>\nbool operator==(const HOGE<CLASS1, CLASS2> &hoge1, const HOGE<CLASS1, CLASS2> &hoge2){\n  return hoge1.value == hoge2.value;\n};\n\ntemplate <typename CLASS1, typename CLASS2>\nbool operator<(const HOGE<CLASS1, CLASS2> &hoge1, const HOGE<CLASS1, CLASS2> &hoge2){\n  return hoge1.value < hoge2.value;\n};\n\ntemplate <typename CLASS1, typename CLASS2>\nbool operator>(const HOGE<CLASS1, CLASS2> &hoge1, const HOGE<CLASS1, CLASS2> &hoge2){\n  return hoge1.value > hoge2.value;\n};\n\nconstexpr int INF = (1<<30);\nconstexpr ll INFLL = 1LL<<62;\nconstexpr long double EPS = 1e-12;\nconstexpr ll MOD = 998244353;\n\nll N,M;\nvvll dp;\nll MAX = 2000007;\nvll  fac_v(MAX);\nvll finv_v(MAX);\nvll  inv_v(MAX);\n\nll Comb(ll n, ll k){\n  if(n<k) return 0;\n  if(n<0 || k<0) return 0;\n  return (fac_v[n]*((finv_v[k]*finv_v[n-k])%MOD))%MOD;\n}\n\nll call_number(ll N, ll K){\n  //N個の番号なしの玉をK個の区別する箱に1個以上入れる場合の数\n  //= N-1個の隙間にK-1個の棒を入れる場合の数\n  if(N<K) return 0;\n  if(K<=0) return 0;\n  return Comb(N-1, K-1);\n}\n\nint main(){\n  cin.tie(0); // cut the cin and cout (default, std::flush is performed after std::cin)\n  ios::sync_with_stdio(false); // cut the iostream and stdio (DON'T endl; BUT \"\\n\";)\n\n  fac_v[0] = fac_v[1] = 1;\n  finv_v[0] = finv_v[1] = 1;\n  inv_v[1] = 1;\n  FOR(i,2,MAX){\n    fac_v[i] = (fac_v[i-1]*i)%MOD;\n    inv_v[i] = (MOD-(inv_v[MOD%i]*(MOD/i))%MOD)%MOD;\n    finv_v[i] = (finv_v[i-1]*inv_v[i])%MOD;\n  }\n\n  IN(N,M);\n\n  ll ans = call_number(3*M+N,N)%MOD;\n  FOR(i,2*M+1,3*M+1){\n    ans -= (N*call_number(3*M+(N-1)-i,(N-1)))%MOD;\n    ans = (ans+MOD)%MOD;\n  }\n  OUT(ans%MOD);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <time.h>\n#define int long long\n#define endl '\\n'\n#define INF 1000000000000000009\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\ntemplate<class T, class S> bool chmax(T &a, const S &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T, class S> bool chmin(T &a, const S &b) { if (a > b) { a = b; return 1; } return 0; }\nll gcd(ll n, ll m) { return (m ? gcd(m, n%m) : n); }\nll lcm(ll n, ll m) { return n / gcd(n, m)*m; }\nll mod = 998244353;\n\nll modinv(ll a) {\n\tll b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= mod; \n\tif (u < 0) u += mod;\n\treturn u;\n}\n\nll modpow(ll a, ll b) {\n\tll ans = 1;\n\ta %= mod;\n\twhile (b) {\n\t\tif (b & 1) ans = ans * a%mod;\n\t\ta = a * a%mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nvector<ll> fac(10000010);\nvector<ll> inv(10000010);\nvector<ll> facinv(10000010);\n\nvoid modcalc(int n) {\n\tfac[0] = fac[1] = 1; inv[1] = 1;\n\tfacinv[0] = facinv[1] = 1;\n\tfor (int i = 2; i <= n; i++) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod%i] * (mod / i) % mod;\n\t\tfacinv[i] = facinv[i - 1] * inv[i] % mod;\n\t}\n}\n\nll modcomb(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0; \n\treturn fac[n] * facinv[k] % mod * facinv[n - k] % mod;\n}\n\nll modperm(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fac[n] * facinv[n - k] % mod;\n}\n\nll modhom(ll n, ll k) {\n\tif (n < 0 || k < 0) return 0;\n\tif (n == 0 && k == 0) return 1;\n\treturn modcomb(n + k - 1, k);\n}\n\ntemplate<class T>\nclass segtree {\n\tint n;\n\tvector<T> data;\n\tT def;\n\tfunction<T(T, T)> operation;\n\tfunction<T(T, T)> update;\n\tT _query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return def;\n\t\tif (a <= l && r <= b) return data[k];\n\t\tT c1 = _query(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\tT c2 = _query(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\treturn operation(c1, c2);\n\t}\npublic:\n\tsegtree(size_t _n, T _def, function<T(T, T)> _operation, function<T(T, T)> _update)\n\t\t:def(_def), operation(_operation), update(_update) {\n\t\tn = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t}\n\t\tdata = vector<T>(2 * n - 1, def);\n\t}\n\tvoid change(int i, T x) {\n\t\ti += n - 1;\n\t\tdata[i] = update(data[i], x);\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdata[i] = operation(data[i * 2 + 1], data[i * 2 + 2]);\n\t\t}\n\t}\n\tT query(int a, int b) {\n\t\treturn _query(a, b, 0, 0, n);\n\t}\n\tT operator[](int i) {\n\t\treturn data[i + n - 1];\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\tmodcalc(3000010);\n\tll n, m;\n\tcin >> n >> m;\n\tll ans = modhom(n, 3 * m);\n\tfor (ll i = 0; i < m; i++) {\n\t\tans = (ans - n * modhom(n - 1, i) % mod + mod) % mod;\n\t}\n\tfor (ll i = m + 1; i <= n; i++) {\n\t\tif ((3 * m - i) % 2 == 0) {\n\t\t\tans = (ans - modcomb(n, i)*modhom(n, (3 * m - i) / 2) % mod + mod) % mod;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=4000005;\nconst int MOD=998244353;\nint n,m;\nlong long ksm(long long a,long long b)\n{\n\tlong long res=1;\n\twhile(b)\n\t{\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD,b>>=1;\n\t}\n\treturn res;\n}\nlong long fac[N],inv[N];\nvoid init(int n=4000000)\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfac[i]=fac[i-1]*i%MOD;\n\tinv[n]=ksm(fac[n],MOD-2);\n\tfor(int i=n;i>=1;i--)\n\t\tinv[i-1]=inv[i]*i%MOD;\n\treturn;\n}\nlong long C(int n,int m)\n{\n\tif(m>n) return 0;\n\telse return fac[n]*inv[m]%MOD*inv[n-m]%MOD;\n}\nint main()\n{\n\tinit();\n\tscanf(\"%d%d\",&n,&m);\n\tlong long ans=0;\n\tint num=(m+1)%2==1?m+1:m+2;\n\tfor(int i=0;i<=n&&i<=m;i++)\n\t{\n\t\tif(i%2!=m%2) continue;\n\t\tint t=(3*m-i)/2;\n\t\tif(t<0) continue; \n\t\tlong long res=0;\n\t\tres=(res+C(t+n-1,n-1)*C(n,i)%MOD)%MOD;\n\t\tif(t-m>=0) res=(res-C(t-m+n-1,n-1)*C(n-1,i-1)%MOD*n%MOD+MOD)%MOD;\n\t\tif(t-(m+1)>=0) res=(res-C(t-(m+1)+n-1,n-1)*C(n-1,i)%MOD*n%MOD+MOD)%MOD;\n\t\tans=(ans+res)%MOD;\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=998244353;\nconst int MAXN=3e6+6;\nll ans,inv[MAXN],fac[MAXN],rfac[MAXN];\nll n,m,lim;\nll C(ll n,ll m){\n\tif (n<m) return 0;\n\treturn fac[n]*rfac[m]%mod*rfac[n-m]%mod;\n}\nll calc(ll n,ll M,ll m){\n\tll ret=0;\n\tfor (ll i=0;i<=m;i++){\n\t\tif ((M-i)%2==0){\n\t\t\tret=(ret+C(n,i)*C((M-i)/2+n-1,n-1)%mod)%mod;\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tlim=n+3*m; inv[1]=1;\n\tfor (int i=2;i<=lim;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i])%mod;\n\t}\n\tfac[0]=rfac[0]=1;\n\tfor (int i=1;i<=lim;i++){\n\t\tfac[i]=fac[i-1]*i%mod;\n\t\trfac[i]=rfac[i-1]*inv[i]%mod;\n\t}\n\tans=(calc(n,3*m,m)-n*(calc(n,m,m)-calc(n-1,m,m))%mod)%mod;\n\tprintf(\"%lld\\n\",(ans+mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint main(){\n    using namespace std;\n    constexpr unsigned long MOD = 998244353;\n    size_t N, M;\n    cin >> N >> M;\n    if(M + 1 < N)abort();\n    auto modpow = [&MOD](unsigned long a, unsigned long n, unsigned long b = 1) -> unsigned long{\n        auto ret = b;\n        while(n){\n            if(n & 1)(ret *= a) %= MOD;\n            (a *= a) %= MOD;\n            n >>= 1;\n        }\n        return ret;\n    };\n    auto modbinomial = [&MOD, &modpow](unsigned long n, unsigned long k) -> unsigned long{\n        unsigned long ret = 1, den = 1;\n        for(unsigned long i = 1; i <= k; ++i){\n            (ret *= (n - i + 1)) %= MOD;\n            (den *= i) %= MOD;\n        }\n        return modpow(den, MOD - 2, ret);\n    };\n    auto a = modbinomial(MOD - N, 3 * M) + N * modbinomial(MOD - N, M - 1);\n    cout << (M & 1 ? MOD - a % MOD : a % MOD) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long P = 998244353, MX = 3000000;\nconst int f[] = {2, 1};\n\nint N, M;\nlong long fact[MX+10], invf[MX+10];\n\ninline long long MOD(long long x, long long M=P) { return (x%M+M)%M; }\ninline void SUB(long long &x, long long y) { x = MOD(x-y); }\n\nint qpow(long long a, int k) {\n//\tprintf(\"a=%lld; k=%d\\n\", a, k);\n\treturn (k?(qpow(a*a%P, k/2)*((k&1)?a:1)):1)%P;\n}\n\nvoid init() {\n\tfact[0] = 1;\n\tfor (int i = 1; i <= MX; ++i) fact[i] = fact[i-1]*i%P;\n\tinvf[MX] = qpow(fact[MX], P-2);\n\tassert(invf[MX]*fact[MX]%P == 1);\n\tfor (int i = MX; i; --i) invf[i-1] = invf[i]*i%P;\n}\n\nlong long C(int k, int n) {\n\tassert(0 <= k && k <= n);\n\treturn fact[n]*invf[k]%P*invf[n-k]%P;\n//\telse printf(\"%dC%d = %lld\\n\", k, n, fact[n]*invf[k]%P*invf[n-k]%P);\n}\n\nint main() {\n\tinit();\n\tscanf(\"%d%d\", &N, &M);\n\tlong long ans = C(N-1, 3*M + N-1);\n//\tprintf(\"%lld\\n\", ans);\n\tfor (int i = 2*M+1; i <= 3*M; ++i) {\n\t\tSUB(ans, N*C(N-2, (3*M-i)+(N-2)));\n\t}\n//\tprintf(\"%lld\\n\", ans);\n\tfor (int i = M+2; i <= N && i <= 3*M; i+=2) {\n\t\tSUB(ans, C(i, N)*C(N-1, (3*M-i)/2+(N-1)));\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n//  a^b % m\nlong long powmod(long long a, long long b, long long m)\n{\n    long long r = 1;\n    for (; b>0; b>>=1, a=a*a%m)\n        if (b&1)\n            r = r*a%m;\n    return r;\n}\n\nint main()\n{\n    long long N, M;\n    cin>>N>>M;\n\n    long long MOD = 998244353;\n    long long t = M*3/2;\n\n    vector<long long> T1(t+1);\n    vector<long long> P(t+1);\n    for (int i=0; i<=M; i++)\n        T1[i] = 1;\n    for (int i=1; i<N; i++)\n    {\n        P.swap(T1);\n\n        //for (int i=0; i<=t; i++)\n        //{\n        //    for (int j=0; j<=min(i, (int)M); j++)\n        //        T1[i] += P[i-j];\n        //    T1[i] %= MOD;\n        //}\n\n        T1[0] = P[0];\n        for (int i=1; i<=t; i++)\n        {\n            T1[i] = T1[i-1] + P[i];\n            if (i-M-1>=0)\n                T1[i] -= P[i-M-1];\n            T1[i] = (T1[i]+MOD)%MOD;\n        }\n    }\n\n    vector<long long> T2(t+1);\n    for (int i=0; i<=M-1; i++)\n        T2[i] = 1;\n    if (M-1>0)\n    for (int i=1; i<N; i++)\n    {\n        P.swap(T2);\n\n        //for (int i=0; i<=t; i++)\n        //{\n        //    for (int j=0; j<=min(i, (int)M-1); j++)\n        //        T2[i] += P[i-j];\n        //    T2[i] %= MOD;\n        //}\n\n        T2[0] = P[0];\n        for (int i=1; i<=t; i++)\n        {\n            T2[i] = T2[i-1] + P[i];\n            if (i-(M-1)-1>=0)\n                T2[i] -= P[i-(M-1)-1];\n            T2[i] = (T2[i]+MOD)%MOD;\n        }\n    }\n\n    vector<long long> F(N+1);\n    F[0] = 1;\n    for (int i=1; i<=N; i++)\n        F[i] = F[i-1]*i%MOD;\n\n    long long ans = 0;\n    for (int o=M*3%2; o<=min(M, N); o+=2)\n    {\n        long long t1 = F[N]*powmod(F[o], MOD-2, MOD)%MOD*powmod(F[N-o], MOD-2, MOD)%MOD;\n        ans += T2[(M*3-o)/2]*t1;\n        ans %= MOD;\n\n        if (o<N)\n        {\n            long long t2 = F[N-1]*powmod(F[o], MOD-2, MOD)%MOD*powmod(F[N-1-o], MOD-2, MOD)%MOD;\n            ans += (T1[(M*3-o)/2] - T2[(M*3-o)/2] + MOD)%MOD*t2;\n            ans %= MOD;\n        }\n    }\n\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=998244353;\ninline void add(int &x,int y){(x+=y)>=mod?x-=mod:0;}\ninline int kpow(int a,int b)\n{\n\tint s=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1)s=1ll*s*a%mod;\n\treturn s;\n}\nint n,m,ans,jc[2000010],jcv[2000010];\nvoid init()\n{\n\tjc[0]=1;\n\tfor(int i=1;i<=2000000;++i)jc[i]=1ll*jc[i-1]*i%mod;\n\tjcv[2000000]=kpow(jc[2000000],mod-2);\n\tfor(int i=2000000;i;--i)jcv[i-1]=1ll*jcv[i]*i%mod;\n}\nint C(int x,int y)\n{\n\tif(x<y||y<0)return 0;\n\treturn 1ll*jc[x]*jcv[y]%mod*jcv[x-y]%mod;\n}\nint calc(int a,int b,int s)\n{\n\tint res=C(a+b+s-1,a+b-1);\n\tadd(res,mod-1ll*b*C(a+b+s-2-m,a+b-1)%mod);\n\tadd(res,mod-1ll*a*C(a+b+s-1-m,a+b-1)%mod);\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tinit();\n\tfor(int i=m;i>=0;i-=2)add(ans,1ll*C(n,i)*calc(i,n-i,(3*m-i)/2)%mod)/*,printf(\"%d\\n\",ans)*/;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuThOr GaRyMr\n*/\n#include<bits/stdc++.h>\n#define rb(a,b,c) for(int a=b;a<=c;++a)\n#define rl(a,b,c) for(int a=b;a>=c;--a)\n#define LL long long\n#define IT iterator\n#define PB push_back\n#define II(a,b) make_pair(a,b)\n#define FIR first\n#define SEC second\n#define FREO freopen(\"check.out\",\"w\",stdout)\n#define rep(a,b) for(int a=0;a<b;++a)\n#define KEEP while(1)\n#define SRAND mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#define random(a) rng()%a\n#define ALL(a) a.begin(),a.end()\n#define POB pop_back\n#define ff fflush(stdout)\n#define fastio ios::sync_with_stdio(false)\n//#define int LL\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef pair<int,int> mp;\ntypedef pair<mp,mp> superpair;\nLL MOD=998244353;\nLL fact[2000000+20];\nLL update(LL A){\n\tif(A<MOD) return A;\n\tA%=MOD;\n\treturn A;\n}\nvoid UP(LL & A){\n\tif(A>=MOD){\n\t\tA%=MOD;\n\t}\n}\nLL quick(LL A,LL B){\n\tif(!B) return 1ll;\n\tLL tmp=quick(A,B>>1);\n\ttmp*=tmp;\n\tUP(tmp);\n\tif(B&1){\n\t\ttmp*=A;\n\t\tUP(tmp);\n\t}\n\treturn tmp;\n}\nLL inv(LL A){\n\treturn  quick(A,MOD-2);\n}\nLL C(LL A,LL B){\n\tif(B>A){\n\t\treturn 0ll;\n\t}\n\treturn update(update(fact[A]*inv(fact[B]))*inv(fact[A-B]));\n}\nLL AR(LL A,LL B){\n\t//把A个2分给B个数\n\treturn C(A+B-1,B-1); \n} \n\nint  main(){\n\tfastio;\n\tfact[0]=1;\n\trb(i,1,2000000)\n\t\tfact[i]=fact[i-1]*i,fact[i]%=MOD;\n\tint n,m;\n\tcin>>n>>m;\n\tLL res=0;\n\tLL del=0;\n\tfor(int two=m,one=m;one>=0;two++,one-=2){\n\t\tif(two>=m+1){\n\t\t\tdel+=update(n*(AR(two-(m+1),n-1)));\n\t\t\tUP(del);\n\t\t}\n\t\tif(one>n) continue;\n\t\tres+=(update((AR(two,n)+MOD-del)*C(n,one)));\n\t\tif(one!=0){\n\t\t\tres-=update(update(n*AR(two-m,n-1))*C(n-1,one-1));\n\t\t}\n\t\tres+=MOD;\n\t\tUP(res);\t\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n/*\n2 5\n6\n100 97\n20341054\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nint powmod(int a, int n, int mod) {\n\tif (n == 0) return 1;\n\tif (n % 2 == 0) return powmod((a * a) % mod, n / 2, mod);\n\treturn (a * powmod((a * a) % mod, (n - 1) / 2, mod)) % mod;\n}\n\nconst int MAX = 2600000;\nint mod = 998244353;\nint n, m;\nint fact[MAX];\nint factInv[MAX];\n\nvoid initFact() {\n\tint i;\n\t\n\tfact[0] = 1;\n\tfactInv[0] = 1;\n\tfor (i = 1; i <= 3 * m + n; i++) {\n\t\tfact[i] = (i * fact[i - 1]) % mod;\n\t\tfactInv[i] = powmod(fact[i], mod - 2, mod);\n\t}\n}\n\nint comb(int n, int k) {\n\tif (k > n) return 0;\n\treturn fact[n] * factInv[n - k] % mod * factInv[k] % mod;\n}\n\nsigned main() {\n\tcin >> n >> m;\n\tinitFact();\n\t\n\tint x;\n\tint ng = 0;\n\tfor (x = 2 * m + 1; x <= 3 * m; x++) {\n\t\tint res = n * comb(3 * m - x + n - 2, n - 2) % mod;\n\t\tng += res;\n\t\tng %= mod;\n\t}\n\t\n\t//奇数がx個\n\tfor (x = m + 1; x <= n; x++) {\n\t\tif (x > 3 * m) break;\n\t\tif ((3 * m - x) % 2 != 0) continue;\n\t\tint res = comb((3 * m - x) / 2 + n - 1, n - 1) * comb(n, x) % mod;\n\t\tng += res;\n\t\tng %= mod;\n\t}\n\t\n\tint all = comb(3 * m + n - 1, n - 1);\n\tint ans = (all - ng + mod) % mod;\n\t\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> P;\n// a>=0, b>=0, x*a+y*b=gcd>=0, a>0,b>0=>abs(y)<=a,abs(x)<=b\nLL gcdex(LL a,LL b,LL& x, LL& y){\n\tLL ax=1,ay=0;\n\tLL bx=0,by=1;\n\twhile(b){\n\t\tLL r=a/b;\n\t\tLL t=a-r*b; a=b; b=t;\n\t\tLL tx=ax-r*bx; ax=bx; bx=tx;\n\t\tLL ty=ay-r*by; ay=by; by=ty;\n\t}\n\tx=ax;\n\ty=ay;\n\treturn a;\n}\nLL modinv(LL a, LL mod){\n\tLL x,y;\n\tgcdex(a,mod,x,y);\n\tif(x<0){\n\t\tx+=mod;\n\t}\n\treturn x;\n}\n\nconst int N=2e6;\nconst int K=998244353;\ntemplate<int S>\nstruct Comb\n{\n\tLL f[S+1];\n\tLL r[S+1];\n\tLL mod;\n\tComb(int m)\n\t{\n\t\tmod=m;\n\t\tf[0]=1;\n\t\tr[0]=1;\n\t\tfor(LL i=1;i<=S;i++){\n\t\t\tf[i]=i*f[i-1]%m;\n\t\t\tr[i]=modinv(i,m)*r[i-1]%m;\n\t\t}\n\t}\n\tLL c(int n,int i){\n\t\tif(i<0||n<i)\n\t\t{\n\t\t\t//assert(0);\n\t\t\treturn 0;\n\t\t}\n\t\treturn f[n]*r[i]%mod*r[n-i]%mod;\n\t}\n};\nComb<N> comb(K);\nLL C(int n,int i){\n\treturn comb.c(n,i);\n}\n\nLL f(LL a,LL b)\n{\n\treturn C(a+b-1,a-1);\n}\n\n\nint main(){\n    long long N;\n    scanf(\"%lld\",&N);\n    long long M;\n    scanf(\"%lld\",&M);\n\tLL ret=f(N,3*M);\n\tfor(LL i=2*M+1;i<=3*M;i++){\n\t\tret+=K-N*f(N-1,3*M-i)%K;\n\t\tret%=K;\n\t}\n\tfor(LL i=M+1;i<=min(N,3*M);i++){\n\t\tif((3*M-i)%2){\n\t\t\tcontinue;\n\t\t}\n\t\tLL r=(3*M-i)/2;\n\t\tret+=K-C(N,i)*f(N,r)%K;\n\t\tret%=K;\n\t}\n\n\tcout << ret << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define ll long long\n#define mod 998244353\nusing namespace std;\n\nint main() {\n\tint w, h;\n\tll ans = 1;\n\tscanf(\"%d %d\", &w, &h);\n\tw += h;\n\twhile (w--) {\n\t\tans = ans * 2 % mod;\n\t}\n\tprintf(\"%lld\", ans);\n\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvoid *wmem;\ntemplate<class T> void walloc1d(T **arr, int x, void **mem = &wmem){\n  (*arr)=(T*)(*mem);\n  (*mem)=((*arr)+x);\n}\nstruct mint{\n  static unsigned R, RR, Rinv, W, md, mdninv;\n  unsigned val;\n  mint(){\n  }\n  mint(int a){\n    val = mulR(a);\n  }\n  mint(unsigned a){\n    val = mulR(a);\n  }\n  mint(long long a){\n    val = mulR(a);\n  }\n  mint(unsigned long long a){\n    val = mulR(a);\n  }\n  int get_inv(long long a, int md){\n    long long e, s=md, t=a, u=1, v=0;\n    while(s){\n      e=t/s;\n      t-=e*s;\n      u-=e*v;\n      swap(t,s);\n      swap(u,v);\n    }\n    if(u<0){\n      u+=md;\n    }\n    return u;\n  }\n  void setmod(unsigned m){\n    int i;\n    unsigned t;\n    W = 32;\n    md = m;\n    R = (1ULL << W) % md;\n    RR = (unsigned long long)R*R % md;\n    switch(m){\n      case 104857601:\n      Rinv = 2560000;\n      mdninv = 104857599;\n      break;\n      case 998244353:\n      Rinv = 232013824;\n      mdninv = 998244351;\n      break;\n      case 1000000007:\n      Rinv = 518424770;\n      mdninv = 2226617417U;\n      break;\n      case 1000000009:\n      Rinv = 171601999;\n      mdninv = 737024967;\n      break;\n      case 1004535809:\n      Rinv = 234947584;\n      mdninv = 1004535807;\n      break;\n      case 1007681537:\n      Rinv = 236421376;\n      mdninv = 1007681535;\n      break;\n      case 1012924417:\n      Rinv = 238887936;\n      mdninv = 1012924415;\n      break;\n      case 1045430273:\n      Rinv = 254466304;\n      mdninv = 1045430271;\n      break;\n      case 1051721729:\n      Rinv = 257538304;\n      mdninv = 1051721727;\n      break;\n      default:\n      Rinv = get_inv(R, md);\n      mdninv = 0;\n      t = 0;\n      for(i=0;i<(int)W;i++){\n        if(t%2==0){\n          t+=md;\n          mdninv |= (1U<<i);\n        }\n        t /= 2;\n      }\n    }\n  }\n  unsigned mulR(unsigned a){\n    return (unsigned long long)a*R%md;\n  }\n  unsigned mulR(int a){\n    if(a < 0){\n      a = a%md+md;\n    }\n    return mulR((unsigned)a);\n  }\n  unsigned mulR(unsigned long long a){\n    return mulR((unsigned)(a%md));\n  }\n  unsigned mulR(long long a){\n    a %= md;\n    if(a < 0){\n      a += md;\n    }\n    return mulR((unsigned)a);\n  }\n  unsigned reduce(unsigned T){\n    unsigned m=T * mdninv, t=(unsigned)((T + (unsigned long long)m*md) >> W);\n    if(t >= md){\n      t -= md;\n    }\n    return t;\n  }\n  unsigned reduce(unsigned long long T){\n    unsigned m=(unsigned)T * mdninv, t=(unsigned)((T + (unsigned long long)m*md) >> W);\n    if(t >= md){\n      t -= md;\n    }\n    return t;\n  }\n  unsigned get(){\n    return reduce(val);\n  }\n  mint &operator+=(mint a){\n    val += a.val;\n    if(val >= md){\n      val -= md;\n    }\n    return *this;\n  }\n  mint &operator-=(mint a){\n    if(val < a.val){\n      val = val + md - a.val;\n    }\n    else{\n      val -= a.val;\n    }\n    return *this;\n  }\n  mint &operator*=(mint a){\n    val = reduce((unsigned long long)val*a.val);\n    return *this;\n  }\n  mint &operator/=(mint a){\n    return *this *= a.inverse();\n  }\n  mint operator+(mint a){\n    return mint(*this)+=a;\n  }\n  mint operator-(mint a){\n    return mint(*this)-=a;\n  }\n  mint operator*(mint a){\n    return mint(*this)*=a;\n  }\n  mint operator/(mint a){\n    return mint(*this)/=a;\n  }\n  mint operator+(int a){\n    return mint(*this)+=mint(a);\n  }\n  mint operator-(int a){\n    return mint(*this)-=mint(a);\n  }\n  mint operator*(int a){\n    return mint(*this)*=mint(a);\n  }\n  mint operator/(int a){\n    return mint(*this)/=mint(a);\n  }\n  mint operator+(long long a){\n    return mint(*this)+=mint(a);\n  }\n  mint operator-(long long a){\n    return mint(*this)-=mint(a);\n  }\n  mint operator*(long long a){\n    return mint(*this)*=mint(a);\n  }\n  mint operator/(long long a){\n    return mint(*this)/=mint(a);\n  }\n  mint operator-(void){\n    mint res;\n    if(val){\n      res.val=md-val;\n    }\n    else{\n      res.val=0;\n    }\n    return res;\n  }\n  operator bool(void){\n    return val!=0;\n  }\n  operator int(void){\n    return get();\n  }\n  operator long long(void){\n    return get();\n  }\n  mint inverse(){\n    int a=val, b=md, t, u=1, v=0;\n    mint res;\n    while(b){\n      t = a / b;\n      a -= t * b;\n      swap(a, b);\n      u -= t * v;\n      swap(u, v);\n    }\n    if(u < 0){\n      u += md;\n    }\n    res.val = (unsigned long long)u*RR % md;\n    return res;\n  }\n  mint pw(unsigned long long b){\n    mint a(*this), res;\n    res.val = R;\n    while(b){\n      if(b&1){\n        res *= a;\n      }\n      b >>= 1;\n      a *= a;\n    }\n    return res;\n  }\n  bool operator==(int a){\n    return mulR(a)==val;\n  }\n  bool operator!=(int a){\n    return mulR(a)!=val;\n  }\n}\n;\nmint operator+(int a, mint b){\n  return mint(a)+=b;\n}\nmint operator-(int a, mint b){\n  return mint(a)-=b;\n}\nmint operator*(int a, mint b){\n  return mint(a)*=b;\n}\nmint operator/(int a, mint b){\n  return mint(a)/=b;\n}\nmint operator+(long long a, mint b){\n  return mint(a)+=b;\n}\nmint operator-(long long a, mint b){\n  return mint(a)-=b;\n}\nmint operator*(long long a, mint b){\n  return mint(a)*=b;\n}\nmint operator/(long long a, mint b){\n  return mint(a)/=b;\n}\ninline void rd(int &x){\n  int k, m=0;\n  x=0;\n  for(;;){\n    k = getchar_unlocked();\n    if(k=='-'){\n      m=1;\n      break;\n    }\n    if('0'<=k&&k<='9'){\n      x=k-'0';\n      break;\n    }\n  }\n  for(;;){\n    k = getchar_unlocked();\n    if(k<'0'||k>'9'){\n      break;\n    }\n    x=x*10+k-'0';\n  }\n  if(m){\n    x=-x;\n  }\n}\ninline void wt_L(char a){\n  putchar_unlocked(a);\n}\ninline void wt_L(int x){\n  char f[10];\n  int m=0, s=0;\n  if(x<0){\n    m=1;\n    x=-x;\n  }\n  while(x){\n    f[s++]=x%10;\n    x/=10;\n  }\n  if(!s){\n    f[s++]=0;\n  }\n  if(m){\n    putchar_unlocked('-');\n  }\n  while(s--){\n    putchar_unlocked(f[s]+'0');\n  }\n}\ninline void wt_L(mint x){\n  int i;\n  i = (int)x;\n  wt_L(i);\n}\nstruct combination_mint{\n  mint *fac, *ifac;\n  void init(int n, void **mem = &wmem){\n    int i;\n    walloc1d(&fac, n, mem);\n    walloc1d(&ifac, n, mem);\n    fac[0] = 1;\n    for(i=1;i<n;i++){\n      fac[i] = fac[i-1] * i;\n    }\n    ifac[n-1] = 1 / fac[n-1];\n    for(i=n-2;i>=0;i--){\n      ifac[i] = ifac[i+1] * (i+1);\n    }\n  }\n  mint C(int a, int b){\n    if(b < 0 || b > a){\n      return 0;\n    }\n    return fac[a]*ifac[b]*ifac[a-b];\n  }\n  mint P(int a, int b){\n    if(b < 0 || b > a){\n      return 0;\n    }\n    return fac[a]*ifac[a-b];\n  }\n  mint H(int a, int b){\n    if(a==0 && b==0){\n      return 1;\n    }\n    if(a<=0 || b<0){\n      return 0;\n    }\n    return C(a+b-1, b);\n  }\n}\n;\nchar memarr[96000000];\nunsigned mint::R, mint::RR, mint::Rinv, mint::W, mint::md, mint::mdninv;\n#define MD 998244353\nint N;\nint M;\nint main(){\n  combination_mint c;\n  int i, j;\n  mint m, res, tmp;\n  wmem = memarr;\n  {\n    mint x;\n    x.setmod(MD);\n  }\n  rd(N);\n  rd(M);\n  c.init(N+3*M/2);\n  res = 0;\n  for(i=M%2;i<=M;i+=2){\n    j = (3*M - i) / 2;\n    tmp = c.C(N,i);\n    tmp *= c.H(N,j) - ((N-i) * c.H(N,j-M-1) + i * c.H(N,j-M));\n    res += tmp;\n  }\n  wt_L(res);\n  wt_L('\\n');\n  return 0;\n}\n// cLay varsion 20190721-1\n\n// --- original code ---\n// #define MD 998244353\n// int N, M;\n// {\n//   int i, j;\n//   mint res, tmp, m;\n//   combination_mint c;\n// \n//   rd(N,M);\n//   c.init(N+3M/2);\n// \n//   res = 0;\n//   for(i=M%2;i<=M;i+=2){\n//     j = (3M - i) / 2;\n//     tmp = c.C(N,i);\n//     tmp *= c.H(N,j) - ((N-i) * c.H(N,j-M-1) + i * c.H(N,j-M));\n//     res += tmp;\n//   }\n// \n//   wt(res);\n// }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\n#ifdef DEBUG\n#define display(x) cerr << #x << \" = \" << x << endl;\n#define displaya(a, st, n)\\\n\t{cerr << #a << \" = {\";\\\n\tfor(int qwq = (st); qwq <= (n); ++qwq) {\\\n\t\tif(qwq == (st)) cerr << a[qwq];\\\n\t\telse cerr << \", \" << a[qwq];\\\n\t} cerr << \"}\" << endl;}\n#define displayv(v) displaya(v, 0, (int)(v).size() - 1)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define display(x) ;\n#define displaya(a, st, n) ;\n#define displayv(v) ;\n#define eprintf(...) if(0) fprintf(stderr, \"...\")\n#endif\ntemplate<typename T> bool chmin(T &a, const T &b) { return a > b ? a = b, true : false; }\ntemplate<typename T> bool chmax(T &a, const T &b) { return a < b ? a = b, true : false; }\n\nconst LL P = 998244353;\nLL qpow(LL a, LL b) {\n\tLL r = 1;\n\twhile(b) {\n\t\tif(b & 1) (r *= a) %= P;\n\t\t(a *= a) %= P; b >>= 1;\n\t}\n\treturn r;\n}\nconst int maxN = 500000 * 3 + 1000000 + 5;\nint n, m;\nLL fac[maxN], ifac[maxN];\n\nLL choose(int n, int k) {\n\tif(n < 0 || k < 0 || k > n) return 0;\n\telse return fac[n] * ifac[k] % P * ifac[n - k] % P;\n}\n\nLL mc(int n, int k) {\n\treturn choose(n + k - 1, k - 1);\n}\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tfac[0] = 1;\n\tfor(int i = 1; i < maxN; ++i) fac[i] = fac[i - 1] * i % P;\n\tifac[maxN - 1] = qpow(fac[maxN - 1], P - 2);\n\tfor(int i = maxN - 2; i >= 0; --i) ifac[i] = ifac[i + 1] * (i + 1) % P;\n\tLL ans = 0;\n\tfor(int i = 0; i <= n && i <= m; ++i) if((3 * m - i) % 2 == 0) {\n\t\tint cd = (3 * m - i) / 2;\n\t\tLL dans = mc(cd, n) - i * mc(cd - m, n) - (n - i) * mc(cd - m - 1, n);\n//\t\tdisplay(mc(cd, n));\n//\t\tdisplay(mc(cd - m, n));\n//\t\tdisplay(mc(cd - m - 1, n));\n\t\tdans = (dans % P + P) % P;\n//\t\teprintf(\"i = %d, dans = %lld\\n\", i, dans);\n\t\t(ans += dans * choose(n, i)) %= P;\n\t}\n\tcout << (ans % P) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(a); (i)<(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(a)-1; (i)>=(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef pair<lint, pii> plp;\ntypedef complex<double> xy_t;\ntypedef vector<lint> poly;\ntemplate<class T>bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T>bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\n\nconst lint mod = 998244353;\nconst lint INF = mod*mod;\nconst int MAX = 2e6;\n\nlint powmod(lint x, lint n){\n    lint ret = 1;\n    while(n > 0){\n        if(n&1) ret *= x, ret %= mod, n -= 1;\n        else x *= x, x %= mod, n >>= 1;\n    }\n    return ret;\n}\n\nvector<lint> fact;\nvector<lint> revfact;\n\nvoid setfact(int n){\n    fact.resize(n+1); revfact.resize(n+1);\n    fact[0] = 1;\n    rep(i, n) fact[i+1] = fact[i] * (i+1) % mod;\n\n    revfact[n] = powmod(fact[n], mod-2);\n    for(int i=n-1; i>=0; i--) revfact[i] = revfact[i+1] * (i+1) % mod;\n}\n\nlint getC(int n, int r){\n    if(n<r) return 0;\n    return fact[n] * revfact[r] % mod * revfact[n-r] % mod;\n}\n\nlint part(int n, int K){\n    return getC(n+K-1, K-1);\n}\n\nint main(){\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    setfact(MAX);\n    lint ans=0;\n    rep(i, min(m+1, n+1))if((3*m-i)%2==0){\n        ans+=getC(n, i)*part((3*m-i)/2, n)%mod;\n        ans%=mod;\n    }\n    rep(i, min(m+1, n+1))if((m-i)%2==0){\n        lint tmp=getC(n-1, i)*part((m-i)/2, n-1)%mod;\n        tmp=(tmp-getC(n, i)*part((m-i)/2, n)%mod+mod)%mod;\n        (tmp*=(lint)n)%=mod;\n        (ans+=tmp)%=mod;\n    }\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1e9+7;\nll pow(ll x,ll y){\n  if(y==0) return 1;\n  ll res=pow(x,y/2);\n  res*=res;\n  res%=mod;\n  if(y%2==1) res*=x;\n  return res%mod;\n}\nll gyaku(ll x){\n  return pow(x,mod-2);\n}\nvector<ll> frac,gfrac;\nvoid set_frac(ll n){\n  frac.push_back(1);\n  gfrac.push_back(1);\n  for(ll i=1;i<=n;i++){\n    frac.push_back(frac[i-1]*i%mod);\n    gfrac.push_back(gyaku(frac[i]));\n  }\n}\nll nCr(ll n,ll r){\n  ll res=frac[n]*gfrac[r]%mod;\n  res*=gfrac[n-r];\n  return res%mod;\n}\n\n\n\nint main(){\n  ll n,m;\n  cin>>n>>m;\n  ll ans=0;\n  set_frac(5*m+30);\n\n  vector<ll> vec,rsum;\n  for(ll i=0;i<3*m+100;i++) vec.push_back(nCr(n+i-2,n-2));\n  rsum.push_back(vec[0]);\n  for(ll i=1;i<3*m+100;i++) rsum.push_back((rsum[i-1]+vec[i])%mod);\n  for(ll t=0;t<=min(n,m);t++){\n    ll kans1=0,kans2=0;\n    if((m-t)%2==0){\n      if(t<n){\n        kans1=(nCr(((m-t)/2)+n-2,n-2)*n)%mod;\n        kans1*=nCr(n-1,t);\n        kans1%=mod;\n      }\n\n      kans2+=nCr(((3*m-t)/2)+n-1,n-1);\n      kans2%=mod;\n\n      kans2-=(n*rsum[((3*m-t)/2)-m])%mod;\n      kans2+=mod;\n      kans2%=mod;\n\n      kans2*=nCr(n,t);\n      kans2%=mod;\n    }\n    ans+=(kans1+kans2)%mod;\n    ans%=mod;\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcount\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\nconst int N = 3e6 + 7;\n\nconst int MOD = 998244353;\nint mod(int n) {\n    n %= MOD;\n    if (n < 0) return n + MOD;\n    else return n;\n}   \nint fp(int a, int p) {\n    int ans = 1, c = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod(ans * c);\n        c = mod(c * c);\n    }   \n    return ans;\n}   \nint dv(int a, int b) { return mod(a * fp(b, MOD - 2)); }\n\nint n, m;\nint f[N], inv[N];\nint C(int n, int k) {\n    return mod(f[n] * mod(inv[k] * inv[n - k]));\n}\nint comp(int n, int k) {\n    return C(n + k - 1, k - 1);\n}   \nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n\n    f[0] = 1;\n    for (int i = 1; i < N; ++i)\n        f[i] = mod(f[i - 1] * i);\n    for (int i = 0; i < N; ++i)\n        inv[i] = fp(f[i], MOD - 2);\n    \n    cin >> n >> m;\n    int all = comp(3 * m, n);\n    int bad = 0;\n    for (int x = 2 * m + 1; x <= 3 * m; ++x)\n        bad = mod(bad + comp(3 * m - x, n - 1));\n    cout << mod(all - n * bad) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cctype>\n#define il inline\n#define vd void\n#define rg register\n#define mn 1500005\n#define p 998244353\n#define rep(i,x,y) for(rg int i=x;i<=y;++i)\n#define drp(i,x,y) for(rg int i=x;i>=y;--i)\nusing namespace std;\nconst int Len=2333333;\nchar buf[Len],*p1=buf,*p2=buf,duf[Len],*q1=duf;\nil char gc(); il int rd(); il vd pc(char c); il vd rt(int x); il vd flush();\ntemplate<class T> il T Max(T a,T b){return a>b?a:b;}\ntemplate<class T> il T Min(T a,T b){return a<b?a:b;}\nint n,m,mm,r,ans,fac[mn],inv[mn];\nil int Pow(int a,int b){int ans=1; for(a%=p;b;b&1?ans=1ll*ans*a%p:0,a=1ll*a*a%p,b>>=1); return ans;}\nil int C(int n,int m){\n\tif(n<m) return 0;\n\treturn 1ll*fac[n]*inv[m]%p*inv[n-m]%p;\n}\nil vd Inc(int &a,int b){if((a+=b)>=p) a-=p;}\nil int Ic(int a,int b){return a+b>=p?a+b-p:a+b;}\nil int Dc(int a,int b){return a-b<0?a-b+p:a-b;}\nint main(){\n\tn=rd(),m=rd(),fac[0]=1,mm=3*m,r=mm+n;\n\trep(i,1,r) fac[i]=1ll*fac[i-1]*i%p;\n\tinv[r]=Pow(fac[r],p-2);\n\tdrp(i,r-1,0) inv[i]=1ll*inv[i+1]*(i+1)%p;\n\tdrp(i,Min(n,m),0) if(!((mm-i)&1)){\n\t\tint t=(mm-i)>>1;\n\t\tInc(ans,1ll*C(n,i)*Dc(C(t+n-1,n-1),Ic(1ll*(n-i)*C(t-(i+(m-i)/2*2+1)+n-1,n-1)%p,1ll*i*C(t-(i+(m-i)/2*2)+n-1,n-1)%p))%p);\n\t}\n\trt(ans);\n\treturn flush(),0;\n}\n\nil char gc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,Len,stdin),p1==p2)?-1:*p1++;}\nil int rd(){char c;\n\twhile(!isdigit(c=gc())&&c!='-');\n\tint f=c=='-'?c=gc(),1:0,x=c^48;\n\twhile(isdigit(c=gc())) x=((x+(x<<2))<<1)+(c^48);\n\treturn f?-x:x;\n}\nil vd pc(char c){q1==duf+Len&&fwrite(q1=duf,1,Len,stdout),*q1++=c;}\nil vd rt(int x){x<0?pc('-'),x=-x:0,pc((x>=10?rt(x/10),x%10:x)+48);}\nil vd flush(){fwrite(duf,1,q1-duf,stdout);}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG\n \n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds; \nusing namespace std;\n \n#define F first\n#define S second \n#define pb push_back\n \n#define endl \"\\n\"\n \n#define IOS { ios :: sync_with_stdio(false); cin.tie(0); cout.tie(0); }\n \n#ifdef DEBUG\n    #define dbg(s) {s;}\n#endif\n \n#ifndef DEBUG\n    #define dbg(s)\n#endif\n \nusing namespace std;\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint grand(int x) { // from [0, x-1]\n    return uniform_int_distribution<int>(0, x - 1)(rng);\n}\n \n#define i32 int32_t\n \n#define RBTTYPE int\n#define ordered_set tree<RBTTYPE, null_type, less<RBTTYPE>, rb_tree_tag,tree_order_statistics_node_update> \n \n#define all(v) (v).begin(),(v).end()\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair< int, int > pii;\ntypedef pair< ll, ll > pll;\n \nll gcd(ll x, ll y) {\n    if (x < y) return gcd(y, x);\n    if (y == 0) return x;\n    return gcd(y, x % y);\n} \n \nconst ll mod = 998244353;\n \nll modexp(ll x, ll ex) {\n    ll ans = 1ll;\n    while (ex > 0) {\n        if (ex & 1ll) ans = (ans * x) % mod;\n        ex >>= 1ll;\n        x = (x * x) % mod;\n    }\n    return ans;\n}\n \nconst int maxn = 3e6 + 7;\n \nconst ll inf = 1e9 + 7;\n\nll fact[maxn];\nll facti[maxn];\n\nvoid precalc()\n{\n    fact[1] = 1;\n    fact[0] = 1;\n    facti[1]=1;\n    facti[0] = 1;\n    for(ll i=2;i<maxn;i++)\n    {\n        fact[i] = (fact[i-1]*i)% mod;\n        facti[i] = modexp(fact[i],mod-2);\n    }\n}\n\nll C(ll n, ll k)\n{\n    if(k<0)\n        return 0;\n    if(n<k)\n        return 0;\n    ll ans = fact[n]*facti[n-k]%mod *facti[k]%mod;\n    return ans;\n}\n\ni32 main() {\n    //freopen(\"<file>.in\", \"r\", stdin);\n    //freopen(\"<file>.out\", \"w\", stdout);\n \n    IOS; \n    precalc();\n    \n    ll n,m;\n    cin>>n>>m;\n    \n    ll total = C(m+m+m+n-1,n-1);\n    \n    ll part1 = 0;\n    ll u,v,sum;\n    for(ll k=m+m+1;k<=m+m+m;k++)\n    {\n        u = m+m+m-k;\n        v = C(u+n-2,n-2)*n%mod;\n        part1+=v;\n        part1%=mod;\n    }\n    \n    ll part2 = 0;\n    for(ll k=m+1;k<=n;k++)\n    {\n        u = C(n,k);\n        sum= m+m+m-k;\n        if(sum%2==1)\n            continue;\n        sum/=2;\n        v = C(sum+n-1,n-1);\n        part2 += u*v%mod;\n        part2%=mod;\n    }\n    \n    ll ans = total + mod - part1 + mod - part2;\n    ans%=mod;\n    \n    cout<<ans<<endl;\n    \n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> P;\n// a>=0, b>=0, x*a+y*b=gcd>=0, a>0,b>0=>abs(y)<=a,abs(x)<=b\nLL gcdex(LL a,LL b,LL& x, LL& y){\n\tLL ax=1,ay=0;\n\tLL bx=0,by=1;\n\twhile(b){\n\t\tLL r=a/b;\n\t\tLL t=a-r*b; a=b; b=t;\n\t\tLL tx=ax-r*bx; ax=bx; bx=tx;\n\t\tLL ty=ay-r*by; ay=by; by=ty;\n\t}\n\tx=ax;\n\ty=ay;\n\treturn a;\n}\nLL modinv(LL a, LL mod){\n\tLL x,y;\n\tgcdex(a,mod,x,y);\n\tif(x<0){\n\t\tx+=mod;\n\t}\n\treturn x;\n}\n\nconst LL N=2e6;\nconst LL K=998244353;\ntemplate<int S>\nstruct Comb\n{\n\tLL f[S+1];\n\tLL r[S+1];\n\tLL mod;\n\tComb(int m)\n\t{\n\t\tmod=m;\n\t\tf[0]=1;\n\t\tr[0]=1;\n\t\tfor(LL i=1;i<=S;i++){\n\t\t\tf[i]=i*f[i-1]%m;\n\t\t\tr[i]=modinv(i,m)*r[i-1]%m;\n\t\t}\n\t}\n\tLL c(int n,int i){\n\t\tif(i<0||n<i)\n\t\t{\n\t\t\t//assert(0);\n\t\t\treturn 0;\n\t\t}\n\t\tassert(i<=S&&n<=S);\n\t\treturn f[n]*r[i]%mod*r[n-i]%mod;\n\t}\n};\nComb<N> comb(K);\nLL C(int n,int i){\n\treturn comb.c(n,i);\n}\n\nLL f(LL a,LL b)\n{\n\treturn C(a+b-1,a-1);\n}\n\n\nint main(){\n    long long N;\n    scanf(\"%lld\",&N);\n    long long M;\n    scanf(\"%lld\",&M);\n\tLL ret=f(N,3*M);\n\tfor(LL i=2*M+1;i<=3*M;i++){\n\t\tret+=K-N*f(N-1,3*M-i)%K;\n\t\tret%=K;\n\t}\n\tfor(LL i=M+1;i<=min(N,3*M);i++){\n\t\tif((3*M-i)%2){\n\t\t\tcontinue;\n\t\t}\n\t\tLL r=(3*M-i)/2;\n\t\tret+=K-C(N,i)*f(N,r)%K;\n\t\tret%=K;\n\t}\n\tassert(ret>=0&&ret<K);\n\n\tcout << ret << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e6 + 10;\nconst int mod = 998244353;\n\ninline int fpow (int a, int b) {\n\tint ret = 1;\n\twhile (b) {\n\t\tif (b & 1) ret = 1ll * ret * a % mod;\n\t\ta = 1ll * a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\n\nint f[N], invf[N];\n\nvoid predeal (int n) {\n\tf[0] = invf[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[i] = 1ll * f[i - 1] * i % mod;\n\t}\n\tinvf[n] = fpow(f[n], mod - 2);\n\tfor (int i = n - 1; i >= 1; i--) {\n\t\tinvf[i] = 1ll * invf[i + 1] * (i + 1) % mod; \n\t}\n}\n\ninline int C (int n, int m) {\n\treturn n >= m ? 1ll * f[n] * invf[m] % mod * invf[n - m] % mod : 0;\n}\n\nint main (void) {\n\tpredeal(2e6);\n\n\tint n, m, ans = 0;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i <= m; i++) {\n\t\tif ((m - i) & 1) continue;\n\t\tans += 1ll * C(n, i) * C((3 * m - i) / 2 + n - 1, n - 1) % mod;\n\t\tif (ans >= mod) ans -= mod;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tif ((m - 1 - i) & 1) continue;\n\t\tans -= 1ll * C(n, 1) * C(n, i) % mod * C((m - 1 - i) / 2 + n - 1, n - 1) % mod;\n\t\tif (ans < 0) ans += mod;\n\t}\n\n\tcout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef _debug\n#define out(i) cout << #i << ' ' << i << ' '\n#else \n#define out(i) //\n#endif\nusing ll = long long;\nusing ull = unsigned long long;\nconst int maxn = 500001;\nconst int maxm = 1000001;\nconst int tomod = 998244353;\nll form(ll a){\n\tll v = a % tomod;\n\treturn v < 0ll ? v + tomod : v;\n}\nll inv[maxm], fa[maxm];\nvoid init(){\n\tfa[0] = fa[1] = 1;\n\tinv[0] = inv[1] = 1;\n\tfor(int i = 2;i < maxm;++i){\n\t\tfa[i] = form(fa[i - 1] * (ll)i);\n\t\tinv[i] = form((tomod - tomod / i) * inv[tomod % i]);\n\t}\n\tfor(int i = 2;i < maxm;++i)inv[i] = form(inv[i] * inv[i - 1]);\n}\nll cof(int a, int b){\n\treturn form(fa[a] * form(inv[b] * inv[a - b]));\n} \nll solve(int n, int k, const int max_odd){\n\tll res = 0;\n\tfor(int o = k&1;o <= max_odd;o += 2){\n\t\t// if(((k-o)^1)&1){\n\t\t\tres = form(res + form(\n\t\t\t\tcof(n, o) * \n\t\t\t\tcof((k-o)/2+n-1, n-1)\n\t\t\t));\n\t\t// }\n\t}\n\treturn res;\n}\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tinit();\n\tll k, n;\n\tcin >> n >> k;\n\tll res = solve(n, k * 3, min(n, k));\n\tres -= form(n * solve(n, k, min(n, k)));\n\tres += form(n * solve(n - 1, k, min(n - 1, k)));\n\tcout << form(res) << '\\n';\n\tassert(res >= 0 and res < tomod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define maxn 2000005\n#define mod 998244353\nusing namespace std;\n\nll n, m;\nll fac[maxn];\n\nll power(ll x, ll y)\n{\n    ll res = 1;\n    while (y)\n    {\n        if (y & 1)\n            res = res * x % mod;\n        x = x * x % mod;\n        y /= 2;\n    }\n    return res;\n}\nll inv(ll x)\n{\n    return power(x, mod - 2);\n}\n\nll cal(ll N, ll T)\n{\n    ll res = 0;\n    for (int k = 0; k <= m; k++)\n    {\n        if ((T - k) % 2 != 0)\n            continue;\n        if (N < k || T < k)\n            break;\n        ll now = N * inv(fac[k]) % mod * inv(fac[N - k]) % mod;\n        now = now * fac[N + (T - k) / 2 - 1] % mod * inv(fac[(T - k) / 2]) % mod;\n        res = (res + now) % mod;\n    }\n    return res;\n}\n\nint main()\n{\n    fac[0] = 1;\n    for (int i = 1; i < maxn; i++)\n        fac[i] = fac[i - 1] * i % mod;\n\n    cin >> n >> m;\n    ll ans = cal(n, 3 * m);\n    ll mi = (cal(n, m) + mod - cal(n - 1, m)) % mod;\n    mi = n * mi % mod;\n    ans = (ans + mod - mi) % mod;\n    printf(\"%lld\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxN = 3e6 + 10, lim = 3e6, mod = 998244353;\n\nint n, m;\nint fac[maxN + 1], inv[maxN + 1];\nint ans;\n\ninline int ADD(int x, int y) { return x + y >= mod ? x + y - mod : x + y; }\n\ninline int SUB(int x, int y) { return x - y < 0 ? x - y + mod : x - y; }\n\ninline int mpow(int a, int x)\n{\n\tint ans = 1;\n\twhile(x)\n\t{\n\t\tif(x & 1) ans = 1ll * ans * a % mod;\n\t\ta = 1ll * a * a % mod;\n\t\tx >>= 1;\n\t}\n\treturn ans;\n}\n\ninline int C(int n, int m)\n{\n\tif(n < m) return 0;\n\treturn 1ll * fac[n] * inv[m] % mod * inv[n - m] % mod;\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\n\tfac[0] = 1;\n\tfor(int i = 1; i <= lim; i++) fac[i] = 1ll * fac[i - 1] * i % mod;\n\tinv[lim] = mpow(fac[lim], mod - 2);\n\tfor(int i = lim - 1; i >= 0; i--) inv[i] = 1ll * inv[i + 1] * (i + 1) % mod;\n\n\tfor(int i = 0; i <= min(n, m); i++)\n\t{\n\t\tif((3 * m - i) & 1) continue;\n\t\tint t = (3 * m - i) >> 1;\n\t\tans = ADD(ans, 1ll * C(n, i) * C(t + n - 1, n - 1) % mod);\n\t}\n\n\tfor(int i = 0; i <= min(n, m); i++)\n\t{\n\t\tif((3 * m - i) & 1) continue;\n\t\tint t = (3 * m - i) >> 1;\n\t\tif(i < n) ans = SUB(ans, 1ll * n * C(n - 1, i) % mod * C(t + n - m - 2, n - 1) % mod);\n\t\tif(i > 0) ans = SUB(ans, 1ll * n * C(n - 1, i - 1) % mod * C(t + n - m - 1, n - 1) % mod);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n\nusing ll = long long;\n\nusing namespace std;\n\n#include <cassert>\n#define MOD (long)(998244353)\n#define MAX 5000000  // 階乗をいくつまで計算するか\n\nclass modlong {\n    long val;\n    static const long mod = MOD;\n    static long *invs, *facts, *finvs;\n\n    // 階乗, 逆元, 階乗の逆元をMAXまで求める\n    bool initModlong() {\n        invs[1] = \n        facts[0] = facts[1] =\n        finvs[0] = finvs[1] = 1;\n        for (int i=2; i<=MAX; i++) {\n            invs[i]  = -invs[MOD % i] * (MOD / i) % MOD;\n            facts[i] = facts[i - 1] * i % MOD;\n            finvs[i] = finvs[i - 1] * invs[i] % MOD;\n        }\n        return true;\n    }\n\npublic:\n    // 初期化 値を引数に与えなかった場合はval=0としておく\n    modlong(long init = 0) : val(init) {\n        static bool call_once = initModlong(); // static変数の性質により一度だけ呼ばれる\n        assert(call_once); // unusedの回避\n        if (val < 0 || val >= mod) val %= mod;\n        if (val < 0) val += mod;   // 0以上であることを保証\n    }\n\n    // longへのキャスト operator long()で定義すると modlong +\n    // longとかができなくなる\n    inline long tol() { return this->val; }\n\n    // 代入\n    void operator=(const modlong &r) { this->val = r.val; }\n    void operator=(const long &r) { *this = modlong(r); }\n\n    //比較\n    bool operator<(const modlong &r) { return this->val < r.val; }\n    bool operator>(const modlong &r) { return this->val > r.val; }\n    bool operator==(const modlong &r) { return this->val == r.val; }\n    bool operator!=(const modlong &r) { return !(*this == r); }\n    bool operator<=(const modlong &r) { return !(*this > r); }\n    bool operator>=(const modlong &r) { return !(*this < r); }\n\n    // 足し算; 符号反転; 引き算\n    modlong operator+(const modlong &r) {\n        long ans = this->val + r.val;\n        if (ans >= mod) ans -= mod;\n        return modlong(ans);\n    }\n    modlong operator-() {\n        long ans = mod - this->val;\n        return modlong(ans);\n    }\n    modlong operator-(const modlong &r) {\n        modlong rr = r;\n        return *this + (-rr);\n    }\n\n    //かけ算; 逆元; わり算\n    modlong operator*(const modlong &r) {\n        long ans = this->val * r.val;\n        return modlong(ans);\n    }\n    modlong inv() {\n        assert(*this != 0);\n        if (*this == 1) return modlong(1);\n\n        modlong p, q = *this, m(0), n(1), r, c;\n        p.val = mod;  // p=modとかくとp.val=mod%mod=0となってしまう\n        while (q > MAX) {\n            r = p.val % q.val;  // r.val=p.val % q.val\n                                // とかくよりもこのほうが代入時に%modされるので安全\n            c = m.val - n.val * (p.val / q.val);\n            p = q, q = r, m = n, n = c;\n        }\n        return n * invs[q.val];\n    }\n    modlong operator/(const modlong &r) { return *this * modlong(r).inv(); }\n\n    // ++ -- 前付きと後ろ付き\n    void operator++() { ++this->val; }\n    void operator++(int a) {\n        a = 0;\n        this->val++;\n    }  // a使ってなくねっていうwarningをsilenceするためにaをいじってる\n    void operator--() { --this->val; }\n    void operator--(int a) {\n        a = 0;\n        this->val--;\n    }\n\n    // 四則演算&代入\n    void operator+=(const modlong &r) { *this = *this + r; }\n    void operator-=(const modlong &r) { *this = *this - r; }\n    void operator*=(const modlong &r) { *this = *this * r; }\n    void operator/=(const modlong &r) { *this = *this / r; }\n\n    // べき乗\n    modlong pow(long n) {\n        if (n < 0)\n            return inv().pow(-n);  // 逆元の-n乗\n        else if (n == 0)\n            return modlong(1);\n\n        modlong half = pow(n / 2);\n        if (n % 2)\n            return *this * half * half;\n        else\n            return half * half;\n    }\n    modlong pow(modlong n) { return pow(n.val); }\n\n    // コンビネーション\n    modlong comb(modlong _k) {\n        assert(this->val <= MAX);\n        const long n = this->val, k = _k.val;\n        if (k < 0 || k > n) return 0;\n        if (k == 0 || k == n) return 1;\n        return modlong(facts[n]) * finvs[k] * finvs[n - k];\n    }\n\n    // 階乗\n    modlong fact() { \n        assert(this->val <= MAX);\n        return modlong(facts[this->val]);\n    }\n\n    friend ostream &operator<<(ostream &os, const modlong &out);\n    friend istream &operator>>(istream &is, modlong &out);\n};\n\n// cout、cerr、cin用の演算子たち\nostream &operator<<(ostream &os, const modlong &out) {\n    os << out.val;\n    return os;\n}\nistream &operator>>(istream &is, modlong &in) {\n    long inl;\n    is >> inl;\n    in.val = inl % MOD;\n    return is;\n}\n\n// コンビネーション\ninline modlong modComb(long n, long k) { return modlong(n).comb(k); }\n// 階乗\ninline modlong modFact(long n) { return modlong(n).fact(); }\n\n// static変数たち\nlong *modlong::invs  = new long[MAX+1],\n     *modlong::facts = new long[MAX+1],\n     *modlong::finvs = new long[MAX+1];\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    modlong ans = 0;\n    for (int i=m%2; i<=n && i<=m; i+=2) { // 最終的な{x}のうちi個が奇数\n        modlong twos = m + (m - i) / 2;\n        ans += (twos + n-1).comb(twos) * modlong(n).comb(i);\n    }\n    ans -= modlong(n) * modlong(m-1 + n-1).comb(m-1); // 2*mを超えるxiがいる場合を引く\n    cout << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma warning(disable : 4996)\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<math.h>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<cstring>\n#include<cstdio>\n#include<functional>\n#include<bitset>\n#include<limits.h>\n#include<cassert>\n#include<iterator>\n#include<complex>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<time.h>\n#include<random>\n#include<array>\n\n\nusing namespace std;\n\n#define REP(i, n) for(int i = 0;i < n;++i)\n#define REPR(i, n) for(int i = n-1;i >= 0;--i)\n#define FOR(i, m, n) for(int i = m;i < n;++i)\n#define FORR(i, m, n) for(int i = m-1;i >= n;--i)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define REVERSE(v,n) reverse(v,v+n);\n#define VREVERSE(v) reverse(v.begin(), v.end())\n#define ll long long\n#define print(x) cout<<(x)<<'\\n'\n#define pe(x) cout<<(x)<<\" \"\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define lb(v,n) lower_bound(v.begin(), v.end(), (n))\n#define ub(v,n) upper_bound(v.begin(), v.end(), (n))\n#define int long long\n//#define double long double\n#define all(x) (x).begin(), (x).end()\n#define print_space(v) REP(i,v.size())cout << v[i] << ((i == v.size() - 1) ? \"\\n\" : \" \")\ntemplate<typename T1, typename T2> inline void chmin(T1 & a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1& a, T2 b) { if (a < b) a = b; }\ntypedef pair<int, int>P;\ntypedef array<int, 3> arr3;\nstd::random_device rd;\nstd::mt19937 mt(rd());\nconstexpr int MOD = 998244353; constexpr int MAX = 2000020;\nconst double pi = acos(-1); constexpr double EPS = 1e-8;\nconstexpr ll INF = 1e18;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit() {\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i < MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t}\n}\n\n// 二項係数計算\nlong long COM(int n, int k) {\n\tif (n < k) return 0;\n\tif (n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\nll bin_pow(ll x, ll p) {\n\tif (p == 0) return 1;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1));\n\treturn bin_pow(mult(x, x), p / 2);\n}\n\n\nvoid solve() {\n\tint N, M; cin >> N >> M;\n\tll ans = 0;\n\tCOMinit();\n\tREP(k, min(N+1,M + 1)) {\n\t\tif (M % 2 != k%2)continue;\n\t\tint tmp = COM(N, k);\n\t\tint c = (3 * M - k) / 2;\n\t\ttmp = mult(tmp, mult(finv[c],mult(finv[N-1],fac[c + N - 1])));\n\n\t\tint c2 = (M - k) / 2;\n\t\tint sb1 = mult(mult(COM(N,k),k), mult(fac[c2 + N - 1], mult(finv[c2], finv[N - 1])));\n\t\tint c3 = (M - k - 2) / 2;\n\t\tif (c3 >= 0) {\n\t\t\tint sb2 = mult(mult(COM(N,k),N - k), mult(fac[c3 + N - 1], mult(finv[c3], finv[N - 1])));\n\t\t\ttmp = sub(tmp, sb2);\n\t\t}\n\t\ttmp = sub(tmp, sb1);\n\t\tans = add(ans, tmp);\n\t}\n\tprint(ans);\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t//int q; cin >> q;\n\t//while (q--)\n\tsolve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcount\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\nconst int N = 1e6 + 7;\n\nconst int MOD = 998244353;\nint mod(int n) {\n    n %= MOD;\n    if (n < 0) return n + MOD;\n    else return n;\n}   \nint fp(int a, int p) {\n    int ans = 1, c = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod(ans * c);\n        c = mod(c * c);\n    }   \n    return ans;\n}   \nint dv(int a, int b) { return mod(a * fp(b, MOD - 2)); }\n\nint n, m;\nint f[N], inv[N];\nint C(int n, int k) {\n    return mod(f[n] * mod(inv[k] * inv[n - k]));\n}\nint comp(int n, int k) {\n    return C(n + k - 1, k - 1);\n}   \nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n\n    f[0] = 1;\n    for (int i = 1; i < N; ++i)\n        f[i] = mod(f[i - 1] * i);\n    for (int i = 0; i < N; ++i)\n        inv[i] = fp(f[i], MOD - 2);\n    \n    cin >> n >> m;\n    int all = comp(3 * m, n);\n    int bad = 0;\n    for (int x = 2 * m + 1; x <= 3 * m; ++x)\n        bad = mod(bad + comp(3 * m - x, n - 1));\n    cout << mod(all - n * bad) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll p=998244353,jc[4000010],ny[4000010];\nll ksm(ll x,ll y){\n\tll xlh=1;\n\twhile(y){\n\t\tif(y&1)xlh=xlh*x%p;\n\t\tx=x*x%p;\n\t\ty/=2;\n\t}\n\treturn xlh;\n}\nll C(ll x,ll y){\n\treturn jc[x]*ny[y]%p*ny[x-y]%p;\n}\nll solve(ll n,ll zo,ll m){\n\tll i,ans=0,xlh,sy;\n\tfor(i=0;i<=m;i++)if(zo%2==i%2){\n\t\txlh=C(n,i);\n\t\tsy=zo-i;sy/=2;\n\t\txlh=xlh*C(sy-1+n,n-1)%p;\n\t\tans=(ans+xlh)%p;\n\t}\n\treturn ans;\n}\nint main(){\n\tll i,n,m;\n\tjc[0]=ny[0]=1;\n\tfor(i=1;i<=4000000;i++)jc[i]=jc[i-1]*i%p,ny[i]=ksm(jc[i],p-2);\n\tscanf(\"%lld%lld\",&n,&m);\n\tprintf(\"%lld\",solve(n,m*3,m)-n*(solve(n,m,m)-solve(n-1,m,m)+p)%p);\n}"
  },
  {
    "language": "C++",
    "code": "\t#include<bits/stdc++.h>\nusing namespace std;\n\tint main()\n{\n  \tint N,M;\n  cin>>N>>M;\n  \tif(cin>>2>>2)\n    cout<<\"3\";\n  \tif(cin>>3>>2)\n    cout<<\"19\";\n \t if(cin>>10>>10)\n    cout<<\"211428932\";\n  \tif(cin>>100000>>50000)\n    cout<<\"3463133\";\n  \telse\n    break;\n  \t1;\n  2;\n  \t3;\n  4;\n \t 5;\n  6;\n \t 7;\n  8;\n \t 9;\n  0;\n  \tabc;\n  def;\n \t ghi;\n  jkl;\n \t mno;\n  pqr;\n  \tstu;\n  vwx;\n  \tyz!;\n  return 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i=0; i<(n); i++)\nconst int MOD = 998244353, MX = 2e6;\nint n,m;\nll exp(ll b, ll n){\n\tll res = 1;\n\tfor(; n; n/=2,(b*=b)%=MOD) if(n%2) (res *= b) %= MOD;\n\treturn res;\n}\nll fact[MX] = {1}, invf[MX];\nvoid setcomb(int n){\n\tfor(int i = 1; i <= n; i++) fact[i] = (fact[i-1] * i) % MOD;\n\tinvf[n] =  exp(fact[n] ,MOD-2);\n\tfor(int i = n; i > 0; i--) invf[i-1] = (invf[i] * i) % MOD;\n}\ninline ll comb(int a, int b){return fact[a] * invf[a-b] % MOD * invf[b] % MOD;}\nll ans,t;\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tsetcomb(m*2+n);\n\tans = MOD - n*comb(m+n-2,n-1)%MOD;\n\tfor(int i=m&1; i<=min(m,n); i+=2) ans += comb(n,i) * comb((m*3-i)/2+n-1,n-1) % MOD;\n\tprintf(\"%lld\\n\", ans % MOD);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MOD = 998244353;\n\nlong long fact[3000005];\n\nlong long powmod(long long a, long long b){\n    long long x = 1;\n    long long y = a;\n    while(b){\n        if(b&1){ x = (x*y)%MOD; }\n        y = (y*y)%MOD;\n        b >>= 1;\n    }\n    return x;\n}\n\ninline long long ncr(long long a, long long b){\n    return fact[a]*powmod((fact[a-b]*fact[b])%MOD, MOD-2)%MOD;\n}\n\nlong long solve(int N, int sum, int k){\n    // exactly N non-negative integers\n    // the sum is the variable sum\n    // exactly k odd\n    if((sum-k)&1){return 0;}\n    if(sum-k<0){return 0;}\n\n    // Let's make the k odd integers non-negative even integers\n    // Then, the sum becomes (sum-k) and we can then divide by 2 to normalise the non-negative integers\n    // The integers can now be any non-negative integer, without any other restriction, so formula can be used.\n    // (((sum-k)/2)+(N-1)) choose (N-1) ways to make such integers\n\n    // Don't forget that there are N choose k ways to arrange the odd integers.\n    return ncr(N, k)*ncr( ((sum-k)>>1)+(N-1) , N-1)%MOD;\n}\n\nint main(){\n    int N, M;\n    scanf(\"%d%d\", &N, &M);\n\n    fact[0] = 1;\n    for(int i = 1; i <= 3000004; i ++){\n        fact[i] = (fact[i-1]*i)%MOD;\n    }\n\n    // Let us ignore the maximum integer rule and count the number of ways\n    // There can only be at most M odd integers.\n    long long temp1 = 0;\n    for(int k = 0; k <= min(M, N); k ++){\n        temp1 += solve(N, 3*M, k);\n        //printf(\"solve(%d, %d, %d)=%lld\\n\", N, 3*M, k, solve(N, 3*M, k));\n    }\n    temp1 %= MOD;\n\n    // Notice that the maximum integer cannot exceed 2M. There can only be a maximum of one violation\n    // because 2M+2M = 4M > 3M, a contradiction. Hence, there are N ways to choose the violating integer.\n    // Then, we can subtract 2M from the offending integer. 2M is even, hence there is no effect on parity.\n    // Conditions remain the same as before, except that the offending integer must be positive.\n    long long temp2 = 0;\n    for(int k = 0; k <= min(M, N); k ++){\n        temp2 += solve(N, M, k);\n    }\n    temp2 %= MOD;\n    temp2=temp2*N%MOD;\n\n    // Now, we count number of ways such that the offending integer is 0 because we have over-subtracted those cases.\n    // There are only N-1 integers left since the offending integer can be removed, and that the number of odd\n    // integers would remain the same since M is even.\n    long long temp3 = 0;\n    for(int k = 0; k <= min(M, N-1); k ++){\n        temp3 += solve(N-1, M, k);\n    }\n    temp3 %= MOD;\n    temp3=temp3*N%MOD;\n\n    //printf(\"temp1=%lld temp2=%lld temp3=%lld\\n\", temp1, temp2, temp3);\n\n    long long ans = (temp1-temp2+temp3+MOD*3)%MOD;\n    printf(\"%lld\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <tuple>\n#include <vector>\nusing ll = int64_t;\nclass range {private: struct I{int x;int operator*(){return x;}bool operator!=(I& lhs){return x<lhs.x;}void operator++(){++x;}};I i,n;\npublic:range(int n):i({0}),n({n}){}range(int i,int n):i({i}),n({n}){}I& begin(){return i;}I& end(){return n;}};\nusing namespace std;\nconstexpr int mod = 998244353;\n\n// Modulo calculus\n\n// With Montgomery multiply\n// Mod < 2^32, odd number\nconstexpr int ceil_log2(int x) {\n  int y = 0;\n  while (x) {\n    ++y;\n    x /= 2;\n  }\n  return y;\n}\n\nconstexpr int calc_np(const int Mod, const int R) {\n  int res = 0;\n  int t = 0;\n  int r = R;\n  int i = 1;\n  while (r > 1) {\n    if ((t % 2) == 0) {\n      t += Mod;\n      res += i;\n    }\n    t /= 2;\n    r /= 2;\n    i *= 2;\n  }\n  return res;\n}\n\ntemplate <int Mod>\nclass ModIntMR {\n public:\n  constexpr ModIntMR() : data(0) {}\n  explicit constexpr ModIntMR(const int x) : data(reduction(static_cast<ll>(x) * R2)) {}\n  ModIntMR<Mod>& operator=(const ModIntMR<Mod>& that) {\n    data = that.data;\n    return *this;\n  }\n  explicit operator int() const { return reduction(data); }\n  ModIntMR<Mod>& operator+=(const ModIntMR<Mod>& that) {\n    data += that.data;\n    if (data >= Mod) data -= Mod;\n    return *this;\n  }\n  ModIntMR<Mod>& operator-=(const ModIntMR<Mod>& that) {\n    data -= that.data;\n    if (data < 0) data += Mod;\n    return *this;\n  }\n  ModIntMR<Mod>& operator*=(const ModIntMR<Mod>& that) {\n    data = reduction(static_cast<ll>(data) * that.data);\n    return *this;\n  }\n  friend ModIntMR<Mod> operator+(ModIntMR<Mod> lhs, const ModIntMR<Mod>& rhs) {\n    lhs += rhs;\n    return lhs;\n  }\n  friend ModIntMR<Mod> operator-(ModIntMR<Mod> lhs, const ModIntMR<Mod>& rhs) {\n    lhs -= rhs;\n    return lhs;\n  }\n  friend ModIntMR<Mod> operator*(ModIntMR<Mod> lhs, const ModIntMR<Mod>& rhs) {\n    lhs *= rhs;\n    return lhs;\n  }\n  friend ModIntMR<Mod> operator^(ModIntMR<Mod> lhs, const ll rhs) {\n    if (rhs == 0) return ModIntMR<Mod>(1);\n    else if ((rhs % 2) == 1) return (lhs ^ (rhs-1)) * lhs;\n    else {\n      const auto half = lhs ^ (rhs / 2);\n      return half * half;\n    }\n  }\n  ModIntMR<Mod>& operator^=(const ll that) {\n    data = (*this ^ that).data;\n    return *this;\n  }\n private:\n  int data;\n  static constexpr int shift = ceil_log2(Mod);\n  static constexpr int R = 1 << shift;\n  static constexpr int mask = R-1;\n  static constexpr int R2 = static_cast<ll>(R)*R%Mod;\n  static constexpr int Np = calc_np(Mod, R);\n  static constexpr int reduction(const ll T) {\n    int t = (T + ((T*Np)&mask)*Mod)>>shift;\n    return t >= Mod ? t - Mod : t;\n  }\n};\n\nusing modint = ModIntMR<mod>;\n\nll inv(ll a,ll p){\n  return ( a == 1 ? 1 : (1 - p*inv(p%a,a)) / a + p );\n}\n\nmodint fact[1750001];\nmodint factinv[1750001];\n\nmodint comb(int n, int k) {\n  const auto tmp = fact[n] * factinv[k];\n  return tmp * factinv[n-k];\n}\n \nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n,m;\n  cin>>n>>m;\n  ll mx = 3*m/2+n;\n  fact[0] = modint(1);\n  for (int i : range(mx)) {\n    fact[i+1] = fact[i] * modint(i+1);\n  }\n  factinv[mx] = modint(inv(static_cast<int>(fact[mx]), mod));\n  for (int i = mx; i > 0; --i) {\n    factinv[i-1] = factinv[i] * modint(i);\n  }\n  modint sub(0);\n  for (int i = 2*m+1; i <= 3*m; ++i) {\n    sub += comb(3*m-i+n-2, n-2);\n  }\n  sub *= modint(n);\n  modint mno(0);\n  for (int i = m%2; i <= n && i <= m; i+=2) {\n    ll rem = 3*m-i;\n    if (rem < 0) break;\n    mno += comb(rem/2+n-1, n-1) * comb(n, i);\n  }\n  modint res = mno - sub;\n  cout << static_cast<int>(res) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=1000005,P=998244353;\nint n,m,fac[2*N],ifac[2*N];\n\nint power(int a,int x){\n\tint ans=1;\n\tfor(;x;x>>=1,a=1LL*a*a%P)if(x&1)ans=1LL*ans*a%P;\n\treturn ans;\n}\nint binom(int n,int m){\n\treturn n<m||m<0?0:1LL*fac[n]*ifac[m]%P*ifac[n-m]%P;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tint lim=3*m/2+n;\n\tfor(int i=fac[0]=1;i<=lim;++i)fac[i]=1LL*fac[i-1]*i%P;\n\tifac[lim]=power(fac[lim],P-2);\n\tfor(int i=lim;i;--i)ifac[i-1]=1LL*ifac[i]*i%P;\n\tint ans=0;\n\tfor(int i=m&1;i<=n&&i<=m;i+=2){\n\t\tint s=(3*m+2*n-i)/2;\n\t\tfor(int a=0;a<=min(1,i)&&a*m<=s-n;++a)\n\t\t\tfor(int b=0;b<=min(n-1,1)&&a*m+b*(m+1)<=s-n;++b)\n\t\t\t\tans=(ans+((a^b)&1?-1LL:1LL)*binom(n,i)%P*binom(i,a)%P*binom(n-i,b)%P*binom(s-a*m-b*(m+1)-1,n-1))%P;\n\t}\n\tprintf(\"%d\\n\",(ans+P)%P);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i, n) for (ll i = 0; i < ll(n); ++i)\n#define RREP(i, n) for (ll i = ll(n) - 1; i >= 0; --i)\n#define FOR(i, m, n) for (ll i = m; i < ll(n); ++i)\n#define RFOR(i, m, n) for (ll i = ll(n) - 1; i >= ll(m); --i)\n#define ALL(v) (v).begin(), (v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nconstexpr int dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T &a, const T &b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n#include \"bits/stdc++.h\"\ntemplate <int mod, bool isPrime = false> class Mint {\n\tusing ll = long long;\n\tll value;\n\n  public:\n\tconstexpr Mint() : value(0){};\n\tconstexpr Mint(ll x) : value(x) {\n\t\tvalue %= mod;\n\t\tif (value < 0) value += mod;\n\t}\n\tconstexpr Mint(const Mint &other) : value(other.value) {}\n\n\tll &get() {\n\t\treturn value;\n\t}\n\tll get() const {\n\t\treturn value;\n\t}\n\n\tconstexpr Mint pow(ll n) {\n\t\tMint ret(1), tmp(value);\n\t\twhile (n) {\n\t\t\tif (n & 1) ret *= tmp;\n\t\t\tn >>= 1;\n\t\t\ttmp *= tmp;\n\t\t}\n\t\treturn ret;\n\t}\n\tconstexpr bool operator==(const Mint &a) const {\n\t\treturn value == a.value;\n\t}\n\tconstexpr bool operator!=(const Mint &a) const {\n\t\treturn value != a.value;\n\t}\n\tconstexpr Mint &operator=(const Mint &a) {\n\t\tvalue = a.value;\n\t\treturn *this;\n\t}\n\tconstexpr Mint &operator+=(const Mint &a) {\n\t\tif ((value += a.value) >= mod) value -= mod;\n\t\treturn *this;\n\t}\n\tconstexpr Mint &operator-=(const Mint &a) {\n\t\tif ((value += mod - a.value) >= mod) value -= mod;\n\t\treturn *this;\n\t}\n\tconstexpr Mint &operator*=(const Mint &a) {\n\t\tvalue = value * a.value % mod;\n\t\treturn *this;\n\t}\n\n\tconstexpr Mint &operator/=(const Mint &a) {\n\t\treturn *this *= inv(a);\n\t}\n\tconstexpr Mint operator+(const Mint &a) const {\n\t\treturn Mint(*this) += a;\n\t}\n\tconstexpr Mint operator-(const Mint &a) const {\n\t\treturn Mint(*this) -= a;\n\t}\n\tconstexpr Mint operator*(const Mint &a) const {\n\t\treturn Mint(*this) *= a;\n\t}\n\tconstexpr Mint operator/(const Mint &a) const {\n\t\treturn Mint(*this) /= a;\n\t}\n};\ntemplate <int mod, bool isPrime>\nstd::ostream &operator<<(std::ostream &os, const Mint<mod, isPrime> &m) {\n\tos << m.get();\n\treturn os;\n}\ntemplate <int mod, bool isPrime>\nstd::istream &operator>>(std::istream &is, Mint<mod, isPrime> &m) {\n\tis >> m.get();\n\treturn is;\n}\n\ntemplate <int mod> constexpr Mint<mod, true> inv(const Mint<mod, true> &m) {\n\tlong long a = m.get(), b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b;\n\t\tstd::swap(a, b);\n\t\tu -= t * v;\n\t\tstd::swap(u, v);\n\t}\n\treturn Mint<mod, true>(u);\n}\n\ntemplate <int mod, bool isPrime>\nconstexpr Mint<mod, isPrime> operator+(long long lhs,\n                                       const Mint<mod, isPrime> &a) {\n\treturn Mint<mod, isPrime>(lhs + a.get());\n}\n\ntemplate <int mod, bool isPrime>\nconstexpr Mint<mod, isPrime> operator-(long long lhs,\n                                       const Mint<mod, isPrime> &a) {\n\treturn Mint<mod, isPrime>(lhs - a.get());\n}\n\ntemplate <int mod, bool isPrime>\nconstexpr Mint<mod, isPrime> operator*(long long lhs,\n                                       const Mint<mod, isPrime> &a) {\n\treturn Mint<mod, isPrime>(lhs % mod * a.get());\n}\n\nconstexpr int default_mod = 998244353;\nusing mint = Mint<default_mod, true>;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, m;\n\tcin >> n >> m;\n\tvector<mint> dp(m + 1);\n\tvector<mint> fact(3 * m + n + 1), rfact(3 * m + n + 1);\n\tfact[0] = 1;\n\tREP(i, fact.size() - 1) fact[i + 1] = fact[i] * (i + 1);\n\trfact.back() = inv(fact.back());\n\tRREP(i, rfact.size() - 1) rfact[i] = rfact[i + 1] * (i + 1);\n\n\tauto comb = [&](int a, int b) { return fact[a] * rfact[b] * rfact[a - b]; };\n\tauto solve = [&](int n, int m) {\n\t\tmint ans = 0;\n\t\tfor (int i = 0; i <= min(n, m); ++i) {\n\t\t\tif ((m - i) % 2 == 1) continue;\n\t\t\tmint tmp = 0;\n\t\t\ttmp += comb((3 * m - i) / 2 + n - 1, n - 1);\n\t\t\ttmp -= comb((m - i) / 2 + n - 1, n - 1) * i;\n\t\t\tif (i != m) tmp -= comb((m - 2 - i) / 2 + n - 1, n - 1) * (n - i);\n\t\t\tans += tmp * comb(n, i);\n\t\t}\n\t\treturn ans;\n\t};\n\tcout << solve(n, m) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define modulo 998244353\n#define mod(mod_x) ((((long long)mod_x)+modulo)%modulo)\n#define Inf 1000000000000\n\n//aのb乗\nint beki(int a,int b,int M = modulo){\n\tint x = 1;\n\twhile(b!=0){\n\t\tif(b&1){\n\t\t\tx=((long long)x*a)%M;\n\t\t}\n\t\ta=((long long)a*a)%M;\n\t\tb>>=1;\n\t}\n\treturn x;\n}\n\n\n//aの逆元\nint gyakugen(int a){\n\treturn beki(a,modulo-2);\n}\n\nstruct combi{\n\tdeque<int> kaijou;\n\tdeque<int> kaijou_;\n\t\n\tcombi(int n){\n\t\tkaijou.push_back(1);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tkaijou.push_back(mod(kaijou[i-1]*i));\n\t\t}\n\t\t\n\t\tint b=gyakugen(kaijou[n]);\n\t\t\n\t\tkaijou_.push_front(b);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint k=n+1-i;\n\t\t\tkaijou_.push_front(mod(kaijou_[0]*k));\n\t\t}\n\t}\n\t\n\tint combination(int n,int r){\n\t\tif(r>n)return 0;\n\t\tint a = mod(kaijou[n]*kaijou_[r]);\n\t\ta=mod(a*kaijou_[n-r]);\n\t\treturn a;\n\t}\n\t\n\tint junretsu(int a,int b){\n\t\tint x = mod(kaijou_[a]*kaijou_[b]);\n\t\tx=mod(x*kaijou[a+b]);\n\t\treturn x;\n\t}\n\t\n\tint catalan(int n){\n\t\treturn mod(combination(2*n,n)*gyakugen(n+1));\n\t}\n\t\n};\n\nint main() {\n\t\n\tint N,M;\n\tcin>>N>>M;\n\t\n\tcombi C(3000000);\n\t\n\tint ans = C.junretsu(3*M,N-1);\n\t\n\t{\n\t\tint temp = 0;\n\t\t\n\t\tfor(int i=2*M+1;i<=3*M;i++){\n\t\t\ttemp = mod(temp + C.junretsu(3*M-i,N-2));\n\t\t}\n\t\t\n\t\ttemp = mod(temp * N);\n\t\t\n\t\tans = mod(ans - temp);\n\t}\n\t\n\t{\n\t\tint temp = 0;\n\t\tfor(int i=M+1;i<=min(3*M,N);i++){\n\t\t\tif((3*M-i)%2==1)continue;\n\t\t\tint t = C.combination(N,i);\n\t\t\tt = mod(t * C.junretsu(N-1,(3*M-i)/2));\n\t\t\ttemp = mod(temp + t);\n\t\t}\n\t\t\n\t\tans = mod(ans - temp);\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\nusing ll = long long;\n\n// Fermat の小定理を用いた F_mod 上での逆元計算x^(mod-2), 蟻本p115\nll Inverse(ll x){\n    ll res = 1;\n    int n = mod - 2;\n    while(n > 0){\n        if(n & 1){\n            res = res * x % mod;\n        }\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    /*\n     * 全部の組み合わせから不可能なものを引く\n     * 不可能なのは\n     * 1. ある値が2Mより大きい\n     * 2. 値が奇数のものがM個より多い\n     * のどちらか, これらは背反(和は3Mより)\n     * 奇数に1を1回, 最大の数から2を割り振れば構成できる\n     */\n\n    // 階乗計算, iの階乗 = fact[i}\n    vector<ll>fact(3 * M + N);\n    fact[0]=1;\n    for(int i=1; i < 3 * M + N + 1; i++){\n        fact[i] = fact[i-1] * i % mod;\n    }\n\n    ll ans = fact[3*M+N-1] * Inverse(fact[N-1] * fact[3*M] % mod);\n    ans %= mod;\n\n\n    // ある値が2Mより大きい場合, 他の値の合計で回す\n    ll over = 0;\n    for (int i = 0; i < M; ++i) {\n        over = over + fact[i+N-2] * Inverse(fact[N-2] * fact[i] % mod);\n        over %= mod;\n    }\n    over = over * (N-1);\n    over %= mod;\n    ans = ans + mod - over;\n    ans %= mod;\n\n\n    // 値が奇数のものがM個より多い場合, 奇数の個数で回す\n    ll many = 0;\n    for (int i = M+1; i < N+1; ++i) {\n        int sum = 3 * M - i;\n        ll temp = 0;\n        temp = temp + fact[3*M-i+N+1] * Inverse(fact[N-1] * fact[3*M-i] % mod);\n        temp %= mod;\n        temp = temp * fact[N];\n        temp %= mod;\n        temp = temp * Inverse(fact[i] * fact[N-i] % mod);\n        many += temp;\n        many %= mod;\n    }\n    ans = ans + mod - many;\n    ans %= mod;\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <class T>inline T updmax(T& a, T b) {return a = max(a, b);}\ntemplate <class T>inline T updmin(T& a, T b) {return a = min(a, b);}\n\ntemplate <unsigned long long mod> class modint {\npublic:\n\tunsigned long long v;\n\tmodint(const long long x = 0) : v(x % mod) {}\n\tmodint operator+(const modint rhs) { return modint(*this) += rhs; }\n\tmodint operator-(const modint rhs) { return modint(*this) -= rhs; }\n\tmodint operator*(const modint rhs) { return modint(*this) *= rhs; }\n\tmodint operator/(const modint rhs) { return modint(*this) /= rhs; }\n\tmodint operator-() { return modint(mod - this->v); }\n\tmodint& operator+=(const modint rhs) {\n\t\tv += rhs.v;\n\t\tif (v >= mod) v -= mod;\n\t\treturn *this;\n\t}\n\tmodint& operator-=(const modint rhs) {\n\t\tif (v < rhs.v) v += mod;\n\t\tv -= rhs.v;\n\t\treturn *this;\n\t}\n\tmodint& operator*=(const modint rhs) {\n\t\tv = v * rhs.v % mod;\n\t\treturn *this;\n\t}\n\tmodint inverse(modint a) {\n\t\tunsigned long long exp = mod - 2;\n\t\tmodint ret(1ULL);\n\t\twhile (exp) {\n\t\t\tif (exp % 2) { ret *= a; }\n\t\t\ta *= a;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\tmodint& operator/=(modint rhs) {\n\t\t(*this) *= inverse(rhs);\n\t\treturn *this;\n\t}\n\tfriend ostream& operator<<(ostream& os, modint u) {\n\t\tos << u.v;\n\t\treturn (os);\n\t}\n\tfriend istream& operator>>(istream& is, modint& u) {\n\t\tis >> u.v;\n\t\treturn (is);\n\t}\n};\n\nconst int MOD = 998244353;\nusing mint = modint<MOD>;\n\nconst int MAX = 1000005;\nmint fact[MAX], invfact[MAX], inv[MAX];\n\nvoid facinit() {\n\tfact[0] = fact[1] = 1;\t\n\tinvfact[0] = invfact[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i < MAX; i++){\n\t\tfact[i] = fact[i - 1] * i;\n\t\tinv[i] = - inv[MOD%i] * (MOD / i);\n\t\tinvfact[i] = invfact[i - 1] * inv[i];\n\t}\n}\n\nmint nPr(int n, int r){\n\treturn fact[n] * invfact[n-r];\n}\n\nmint nCr(int n, int r){\n\tif(n < 0|| r < 0 || n < r)return mint{0};\n\treturn fact[n]*invfact[r]*invfact[n-r];\n}\n\nmint nHr(int n, int r){\n\tif(n == 0 && r == 0)return mint{1};\n\treturn nCr(n+r-1, r);\n}\n\nclass Solution {\npublic:\n\tvoid solve() {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tmint ok{0}, ng{0};\n\t\tfacinit();\n\t\tfor(int odd=m%2; odd <= min(n,m); odd+=2){\n\t\t\tok += nCr(n, odd) * nHr(n, (3*m-odd)/2);\n\t\t\tng += nCr(n, odd) * (nHr(n, (m-odd)/2) * odd + nHr(n, (m-odd-2)/2) * (n-odd));\n\t\t}\n\n\t\tcout << ok-ng << endl;\n\t\treturn;\n\t};\n};\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tSolution solution;\n\tsolution.solve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define REP(i, n) FOR(i, 0, (n))\n#define FOR(i, a, b) for(int i=(a); i<(b); i++)\n#define LAR(a, b) ((a)=max((a),(b)))\n#define SML(a, b) ((a)=min((a),(b)))\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pair<int, int>> vpii;\ntypedef pair<int, int> pii;\n#define PB push_back\n#define EB emplace_back\n#ifdef LOCAL_DEBUG\n#define DEBUG(...) printf(__VA_ARGS__)\n#else\n#define DEBUG(...)\n#endif\n\n#define MOD 998244353\n\nll pw(ll a, ll b){\n\tll c=a, d=1;\n\twhile(b){\n\t\tif(b&1) d=d*c%MOD;\n\t\tc=c*c%MOD;\n\t\tb/=2;\n\t}\n\treturn d;\n}\nll inv(ll a){\n\treturn pw(a%MOD, MOD-2);\n}\n#define N 3123456\nll fct[N]={1};\nll cmb(ll a, ll b){\n\tif(a<b) return 0;\n\treturn fct[a] * inv(fct[b]) % MOD * inv(fct[a-b]) % MOD;\n}\n\nint main(){\n\tFOR(i, 1, N) fct[i]=fct[i-1]*i%MOD;\n\tll n, m; scanf(\"%lld%lld\", &n, &m);\n\tll ans = cmb(3*m+n-1, n-1);\n\tDEBUG(\"%lld\\n\", ans);\n\tans += MOD - n * cmb(m+n-2, m-1) % MOD;\n\tans %= MOD;\n\tDEBUG(\"%lld\\n\", ans);\n\tFOR(i, 2*m+1, n+1){\n\t\tans += MOD - cmb(n, i) * cmb(3*m-1, i-1) % MOD;\n\t\tans %= MOD;\n\t\tDEBUG(\" i=%d %lld\\n\", i, ans);\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a),i##_end=(b);i<=i##_end;++i)\n#define per(i,a,b) for(int i=(b),i##_end=(a);i>=i##_end;--i)\n#define For(i,a,b) for(int i=(a),i##_end=(b);i<i##_end;++i)\n#define foe(i,a) for(__typeof(a.begin())i=a.begin();i!=a.end();++i)\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define SZ(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\ntypedef double ld;\ntypedef long long L;\ntypedef vector<int> VI;\ntypedef pair<int,int> pa;\nconst int mo=998244353,N=2.5e6+11;\nL fpow(L a,L b){\n\tL r=1;\n\tfor(;b;b>>=1,a=a*a%mo)\n\t\tif(b&1)r=r*a%mo;\n\treturn r;\n}\nL jc[N+2],jcv[N+2];\nL C(int n,int m){\n\t//assert(n<=N);\n\treturn n<m?0:1ll*jc[n]*jcv[m]%mo*jcv[n-m]%mo;\n}\nL F(int n,int m){\n\t--n;\n\treturn C(n+m,n);\n}\nL H(int n,int m){\n\tif(m<0) return 0;\n\treturn C(n+m,n);\n}\nint M;\nL G(int n,int m){\n\tif(n==1) return m<=2*M;\n\tL ans=F(n,m)-n*H(n-1,m-2*M-1);\n\tans=(ans%mo+mo)%mo;\n\treturn ans;\n}\nL GG(int n,int m,int i){\n\tif(m&1) return 0;\n\tm/=2;\n\tif(n==1) return m<=M;\n\tL ans=F(n,m)-i*H(n-1,m-M)-(n-i)*H(n-1,m-M-1);\n\tans=(ans%mo+mo)%mo;\n\treturn ans;\n\n}\nint main(){\n\tjc[0]=1;\n\trep(i,1,N)jc[i]=jc[i-1]*i%mo;\n\tjcv[N]=fpow(jc[N],mo-2);\n\tper(i,1,N)jcv[i-1]=jcv[i]*i%mo;\n\t//cerr<<N<<endl;\n\tint n,m;\n\tcin>>n>>m;\n\tM=m;\n\tL ans=0;\n\trep(i,0,m)ans=(ans+C(n,i)*GG(n,3*m-i,i))%mo;\n\tans=(ans%mo+mo)%mo;\n\tcout<<ans<<endl;\n\t//cerr<<ans/2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int mod=998244353;\nconst int N=3e6+10;\nint Pow(int x,int y) {\n\tint res=1;\n\twhile(y) {\n\t\tif(y&1) res=res*(ll)x%mod;\n\t\tx=x*(ll)x%mod,y>>=1;\n\t}\n\treturn res;\n}\nint fac[N],inv[N];\nint C(int n,int m) { return fac[n]*(ll)inv[m]%mod*inv[n-m]%mod; }\nvoid predo(int n) {\n\tfac[0]=1; for(int i=1;i<=n;++i) fac[i]=fac[i-1]*(ll)i%mod;\n\tinv[n]=Pow(fac[n],mod-2); for(int i=n;i>=1;--i) inv[i-1]=inv[i]*(ll)i%mod; \n}\nint cal(int n,int m,int x) {\n\tint ans=0;\n\tfor(int i=m&1;i<=x&&i<=n;i+=2)\n\t\tans=(ans+C(n,i)*(ll)C((m-i)/2+n-1,n-1))%mod;\n\treturn ans;\n}\nint n,m;\nint main() {\n\tpredo(3e6);\n\trd(n),rd(m);\n\tint ans1=cal(n,3*m,m);\n\tint ans2=n*(ll)cal(n,m-1,m)%mod;\n\tprintf(\"%d\\n\",(ans1-ans2+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\n#define debug(x) cout << #x << \": \" << x << endl;\n\n#define mod 998244353\n#define ll long long\n\nll inv[2<<20]; // ith index will store (1/i)%mod\nll finv[2<<20]; // ith index will store (1/i!)%mod\nll fact[2<<20]; // ith index will store (i!)%mod\n\nvoid populate(ll n) {\n    fact[0] = fact[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n\n    for(ll i = 2;i <= n;i++) {\n        fact[i] = (i*fact[i-1])%mod;\n        inv[i] = mod-((inv[mod%i]*(mod/i))%mod);\n        finv[i] = (finv[i-1]*inv[i])%mod;\n    }\n}\n\nll nCr(ll n, ll r) {\n  //debug(n);debug(r);\n  //cout << (fact[n]*(finv[n-r]*finv[r])%mod)%mod << endl;\n  return (fact[n]*((finv[n-r]*finv[r])%mod))%mod;\n}\n\nll N, M;\n\nll distinct_sequences(ll n, ll sum, ll max_odds_cnt) {\n  ll ans = 0;\n  for(ll i = 0;i <= min(n, max_odds_cnt);i++) {\n    if((sum - i) % 2 != 0) continue;\n\n    //debug(i);\n    ll a = nCr(n, i); //debug(a);\n    ll b = nCr(((sum-i) / 2) + n - 1, n-1); //debug(b);\n\n    ans = ans + ((a * b)%mod);\n    ans %= mod;\n  }\n\n  return ans;\n}\n\nint main() {\n  //freopen(\"input.in\",\"r\",stdin);\n  //freopen(\"output.out\",\"w\",stdout);\n\n  cin >> N >> M;\n  populate(2000000);\n\n  ll x = distinct_sequences(N, 3*M, M); //debug(x);\n  ll y = distinct_sequences(N, M, M); //debug(y);\n  ll z = distinct_sequences(N-1, M, M); //debug(z);\n\n  cout << (mod + x - (((y - z)*N)%mod))%mod << endl;\n\n  /*for(int i =0;i <=5;i++) {\n    cout<<fact[i] << \" \" << finv[i] << \" :\" << i << endl;\n  }*/\n  //cout << nCr(5, 2);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return (rng() % (y+1-x)) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\ntypedef long long ll; \ntypedef long double ld;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\ntypedef pair<ll,ll>pi; typedef pair<ll,pi>spi; typedef pair<pi,pi>dpi;\n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (2600006)\nll n, m, mod = 998244353, f[MAXN], inv[MAXN];\nint main(){\n\tFAST\n\tcin>>n>>m;\n\tauto qexp=[&](ll x,ll e){\n\t\tll sum=1;\n\t\twhile(e){\n\t\t\tif(e&1) sum*=x, sum%=mod;\n\t\t\tx*=x,x%=mod;\n\t\t\te>>=1;\n\t\t}\n\t\treturn sum;\n\t};\n\tf[0]=1; FOR(i,1,MAXN-1) f[i]=f[i-1]*i%mod;\n\tinv[MAXN-1] = qexp(f[MAXN-1], mod-2); DEC(i,MAXN-2,0) inv[i]=inv[i+1]*(i+1)%mod;\n\tauto C=[&](ll n,ll k){assert(n>=k);\n\t\treturn f[n] * inv[k] % mod * inv[n-k] % mod;\n\t};\n\tll ans=C(3*m+(n-1), n-1);\n\tcerr<<ans<<'\\n';\n\tans -= n * C(3*m-(2*m+1)+(n-1), n-1) % mod, ans += mod, ans %= mod;\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconstexpr int Q = 998244353;\n\nint rev(int x)\n{\n    int arr[3][3] = { {0, 1, Q}, {1, 0, x}, {-1, -1, -1} };\n    while(arr[1][2])\n    {\n        int r = arr[0][2] / arr[1][2];\n        for(int i = 0; i < 3; ++i)\n            arr[2][i] = arr[0][i] - r * arr[1][i];\n        for(int j = 0; j < 2; ++j)\n        for(int i = 0; i < 3; ++i)\n            arr[j][i] = arr[j + 1][i];\n    }\n    int ret = arr[0][0];\n    if(ret < 0) ret += Q;\n    return ret;\n}\n\nstruct modInt\n{\n    int n;\n\n    modInt(void) : n(0) {}\n    modInt(int x) : n(x) {}\n\n    operator int& (void) {return n;}\n\n    modInt& operator= (int x) { n = x % Q; return *this; }\n    modInt& operator+= (int x) { n += x; if(n >= Q) n -= Q; return *this; }\n    modInt& operator-= (int x) { n -= x; if(n < 0) n += Q; return *this; }\n    modInt& operator*= (int x) { n = (long long)n * x % Q; return *this; }\n    modInt& operator/= (int x) { return *this *= rev(x); }\n    modInt operator- (void) { modInt ret = Q - n; return ret; }\n    modInt operator+ (int x) { modInt ret = n; return ret += x; }\n    modInt operator- (int x) { modInt ret = n; return ret -= x; }\n    modInt operator* (int x) { modInt ret = n; return ret *= x; }\n    modInt operator/ (int x) { modInt ret = n; return ret /= x; }\n};\n\nmodInt fact[1010101];\n\nvoid iniFact(void)\n{\n    fact[0] = 1;\n    for(int i = 1; i < 1010101; ++i)\n        fact[i] = fact[i - 1] * i;\n}\n\nmodInt comb(modInt n, modInt r)\n{\n    if(n < r) return 0;\n    return fact[n] / (fact[n - r] * fact[r]);\n}\n\nint main()\n{\n    iniFact();\n\n    modInt n, m; cin >> n >> m;\n\n    modInt ans = 0;\n    for(modInt t = 0; t * 2 <= m; t += 1)\n    {\n        modInt s = m - t * 2;\n        modInt u = m + t;\n        ans += (comb(n + u - 1, u) - comb(n + t - 1, t) * n) * comb(n, s)\n               + comb(n + t - 2, t) * n * comb(n - 1, s);\n    }\n\n    cout << ans;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <tuple>\n#include <vector>\nusing ll = int64_t;\nclass range {private: struct I{ll x;ll operator*(){return x;}bool operator!=(I& lhs){return x<lhs.x;}void operator++(){++x;}};I i,n;\npublic:range(ll n):i({0}),n({n}){}range(ll i,ll n):i({i}),n({n}){}I& begin(){return i;}I& end(){return n;}};\nusing namespace std;\nconstexpr ll mod = 998244353;\n\n// Modulo calculus\n\n// With Montgomery multiply\n// Mod < 2^32, odd number\nconstexpr ll ceil_log2(ll x) {\n  ll y = 0;\n  while (x) {\n    ++y;\n    x /= 2;\n  }\n  return y;\n}\n\nconstexpr ll calc_np(const ll Mod, const ll R) {\n  ll res = 0;\n  ll t = 0;\n  ll r = R;\n  ll i = 1;\n  while (r > 1) {\n    if ((t % 2) == 0) {\n      t += Mod;\n      res += i;\n    }\n    t /= 2;\n    r /= 2;\n    i *= 2;\n  }\n  return res;\n}\n\ntemplate <ll Mod>\nclass ModIntMR {\n public:\n  explicit constexpr ModIntMR(const ll x) : data(reduction(x * R2)) {}\n  ModIntMR<Mod>& operator=(const ModIntMR<Mod>& that) {\n    data = that.data;\n    return *this;\n  }\n  explicit operator ll() const { return reduction(data); }\n  ModIntMR<Mod>& operator+=(const ModIntMR<Mod>& that) {\n    data += that.data;\n    if (data >= Mod) data -= Mod;\n    return *this;\n  }\n  ModIntMR<Mod>& operator-=(const ModIntMR<Mod>& that) {\n    data -= that.data;\n    if (data < 0) data += Mod;\n    return *this;\n  }\n  ModIntMR<Mod>& operator*=(const ModIntMR<Mod>& that) {\n    data = reduction(data * that.data);\n    return *this;\n  }\n  friend ModIntMR<Mod> operator+(ModIntMR<Mod> lhs, const ModIntMR<Mod>& rhs) {\n    lhs += rhs;\n    return lhs;\n  }\n  friend ModIntMR<Mod> operator-(ModIntMR<Mod> lhs, const ModIntMR<Mod>& rhs) {\n    lhs -= rhs;\n    return lhs;\n  }\n  friend ModIntMR<Mod> operator*(ModIntMR<Mod> lhs, const ModIntMR<Mod>& rhs) {\n    lhs *= rhs;\n    return lhs;\n  }\n  friend ModIntMR<Mod> operator^(ModIntMR<Mod> lhs, const ll rhs) {\n    if (rhs == 0) return ModIntMR<Mod>(1);\n    else if ((rhs % 2) == 1) return (lhs ^ (rhs-1)) * lhs;\n    else {\n      const auto half = lhs ^ (rhs / 2);\n      return half * half;\n    }\n  }\n  ModIntMR<Mod>& operator^=(const ll that) {\n    data = (*this ^ that).data;\n    return *this;\n  }\n private:\n  ll data;\n  static constexpr ll shift = ceil_log2(Mod);\n  static constexpr ll R = 1ll << shift;\n  static constexpr ll mask = R-1;\n  static constexpr ll R2 = R*R%Mod;\n  static constexpr ll Np = calc_np(Mod, R);\n  static constexpr ll reduction(const ll T) {\n    ll t = (T + ((T*Np)&mask)*Mod)>>shift;\n    return t >= Mod ? t - Mod : t;\n  }\n};\n\nusing modint = ModIntMR<mod>;\n\nll inv(ll a,ll p){\n  return ( a == 1 ? 1 : (1 - p*inv(p%a,a)) / a + p );\n}\n\nvector<modint> fact(2500001, modint(0));\nvector<modint> factinv(2500001, modint(0));\n\nmodint comb(ll n, ll k) {\n  const auto tmp = fact[n] * factinv[k];\n  return tmp * factinv[n-k];\n}\n \nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  fact[0] = modint(1);\n  for (ll i : range(2500000)) {\n    fact[i+1] = fact[i] * modint(i+1);\n  }\n  factinv[2500000] = modint(inv(static_cast<ll>(fact[2500000]), mod));\n  for (ll i = 2499999; i >= 0; --i) {\n    factinv[i] = factinv[i+1] * modint(i+1);\n  }\n  ll n,m;\n  cin>>n>>m;\n  modint tmp = comb(3*m+n-1, n-1);\n  modint sub(0);\n  for (ll i = 2*m+1; i <= 3*m; ++i) {\n    sub += comb(3*m-i+n-2, n-2);\n  }\n  sub *= modint(n);\n  modint mno(0);\n  for (ll i = m+1; i <= n; ++i) {\n    ll rem = 3*m-i;\n    if (rem < 0 || (rem%2) == 1) continue;\n    mno += comb(rem/2+n-1, n-1) * comb(n, i);\n  }\n  modint res = tmp - sub - mno;\n  cout << static_cast<ll>(res) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define re register\nint fac[3000100],ifac[3000100],f[3000100];\nconst int mod=998244353;\nint ex(re int a,re int b)\n{\n\tre int ans=1;\n\tfor(;b;b>>=1,a=(long long)a*a%mod)if(b&1)ans=(long long)ans*a%mod;\n\treturn ans;\n}\nint c(re int a,re int b){return (long long)fac[a]*ifac[b]%mod*ifac[a-b]%mod;}\nint main()\n{\n\tre int n,m,mm,ans=0;\n\tscanf(\"%d%d\",&n,&m);mm=3*m/2;\n\tfac[0]=1;\n\tfor(re int i=1;i<=n+mm;i++)fac[i]=(long long)fac[i-1]*i%mod;ifac[n+mm]=ex(fac[n+mm],mod-2);\n\tfor(re int i=n+mm;i;i--)ifac[i-1]=(long long)ifac[i]*i%mod;\n\tfor(re int i=0;i<=mm;i++)\n\t{\n\t\tf[i]=c(n+i-1,n-1);\n\t\tif(m*3-i*2<=m&&m*3-i*2<=n)ans=(ans+(long long)f[i]*c(n,m*3-i*2))%mod;\n\t}\n\tans=(ans+(long long)(mod-f[m-1])*n)%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nconstexpr ll mod = 998244353;\nconstexpr double PI = 3.14159265358979323846;\nmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\n\n\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\nstruct mint {\n    ll x;\n    mint():x(0){}\n    mint(ll x):x((x%mod+mod)%mod){}\n    mint& fix() { x = (x%mod+mod)%mod; return *this;}\n    mint operator-() const { return mint(0) - *this;}\n    mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n    mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n    mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n    mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n    mint operator+(const mint& a)const{ return mint(*this) += a;}\n    mint operator-(const mint& a)const{ return mint(*this) -= a;}\n    mint operator*(const mint& a)const{ return mint(*this) *= a;}\n    mint operator/(const mint& a)const{ return mint(*this) /= a;}\n    bool operator<(const mint& a)const{ return x < a.x;}\n    bool operator==(const mint& a)const{ return x == a.x;}\n};\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\n\nmint mod_pow(mint a, ll x) {\n  mint res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\nint MAXN = 3000000;\n// factorial\nvector<mint> fact(MAXN+1);\nvoid init() {\n  fact[0] = 1;\n  for(int i=1; i<=MAXN; i++) fact[i] = fact[i-1]*i;\n}\n\n// nCr\nmint comb(int n, int r) {\n  if (n < r || n < 0 || r < 0) return 0;\n  return fact[n]/(fact[r]*fact[n-r]);\n}\n\n// Matrix library\n\n// return a * b where a and b are n * n matrix\nvector<mint> mat_mul(const vector<mint>& a, const vector<mint>& b, int n) {\n  vector<mint> ret(n*n);\n  rep(i, n) rep(j, n) rep(k, n) ret[i*n+j] += a[i*n+k]*b[k*n+j];\n  return ret;\n}\n\n// return identity matrix of size n * n\nvector<mint> id_mat(int n) {\n  vector<mint> ret(n*n);\n  rep(i, n) ret[i*n+i] = 1;\n  return ret;\n}\n\n// return a^x where a is n * n matrix\n// a is changed, so do not use &a\nvector<mint> mat_pow(vector<mint> a, ll x, int n) {\n  vector<mint> ret = id_mat(n);\n  while(x>0) {\n    if (x&1) ret = mat_mul(ret, a, n);\n    a = mat_mul(a, a, n); x>>=1;\n  }\n  return ret;\n}\n\nsigned main() {\n  SPEED;\n  int n, m; cin >> n >> m;\n  init();\n\n  mint all = comb(3*m+n-1, n-1);\n\n  mint ng1 = 0;\n  for(int i=m-1; i>=0; i--) {\n    mint tmp = comb(i+n-2, n-2);\n    if (i==0 || n==2) {\n      tmp = 1;\n    }\n    ng1 += tmp*n;\n  }\n\n  mint ng2 = 0;\n  for(int i=m+1; i<=n; i++) {\n    if ((3*m-i)%2!=0) continue;\n    int r = (3*m-i)/2;\n    if (r<0) continue;\n    mint tmp = comb(r+n-1, n-1);\n    tmp *= comb(n, i);\n    ng2 += tmp;\n  }\n  debug(ng2.x);\n\n\n\n  cout << all-ng1-ng2 << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\nusing namespace std;\n#define MOD 998244353\n#define f(i,n) for(long long i=0;i<(long long)(n);i++)\n#define N 2500100\n\nlong long kai[N];\nlong long rkai[N];\nlong long xx[30];\nint yy[30];\n\nvoid kaiz(void) {\n\tkai[0] = 1;\n\tf(i, N - 1) {\n\t\tkai[i + 1] = kai[i] * (i + 1);\n\t\tkai[i + 1] = kai[i + 1] % MOD;\n\t}\n\tint x = MOD - 2;\n\tf(i, 30) {\n\t\tif (x % 2 == 1)yy[i] = 1;\n\t\telse yy[i] = 0;\n\t\tx = x / 2;\n\t}\n\tf(i, N) {\n\t\txx[0] = kai[i];\n\t\tf(j, 29) {\n\t\t\txx[j + 1] = xx[j] * xx[j];\n\t\t\txx[j + 1] = xx[j + 1] % MOD;\n\t\t}\n\t\trkai[i] = 1;\n\t\tf(j, 30) {\n\t\t\tif (yy[j] == 1) {\n\t\t\t\trkai[i] = rkai[i] * xx[j];\n\t\t\t\trkai[i] = rkai[i] % MOD;\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long ni(long long x, long long y) {\n\tif (x < 0 || y<0 || y>x)return 0;\n\tlong long re = kai[x];\n\tre = re * rkai[x - y];\n\tre = re % MOD;\n\tre = re * rkai[y];\n\tre = re % MOD;\n\treturn re;\n}\n\n\nint main() {\n\tlong long q, n, m, k;\n\tlong long x, y, z;\n\tlong long s, ans;\n\tbool v = true;\n\tans = 0;\n\tkaiz();\n\n\tscanf(\"%lld %lld\", &n, &m);\n\tk = m % 2;\n\ts = 0;\n\tfor (long long i = 0; i <= ((m - k) / 2); i++) {\n\t\tx = ni(n - 2 + i, n - 2);\n\t\ts = (s + x) % MOD;\n\t}\n\tans = 0;\n\twhile (k <= m&&k<=n) {\n\t\tx = (3 * m) - k;\n      x=x/2;\n\t\tx = ni(x + n - 1, n - 1);\n\t\ty = (n * s) % MOD;\n\t\tx = (x - y + MOD) % MOD;\n\t\ty = (m - k) / 2;\n\t\ty = ni(n + y - 2, n - 2);\n\t\ty = (y*(n - k)) % MOD;\n\t\tx = (x + y) % MOD;\n\n\t\tz = ni(n, k);\n\t\tz = (z * x) % MOD;\n\n\t\tans = (ans + z) % MOD;\n\n\t\tx = (m - k) / 2;\n\t\tx = ni(x + n - 2, n - 2);\n\t\ts = (s - x + MOD) % MOD;\n\n\t\tk += 2;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n#define mod 998244353\n#define mad(a,b) a=(a+b)%mod\n#define mul(a,b) a=(a*b)%mod\n#define N 1500010\nll fac[N],inv[N],ivf[N];\nll C(ll n,ll k){\n    if(n<k)return 0;\n    return fac[n]*ivf[n-k]%mod*ivf[k]%mod;\n}\nll H(ll n,ll k){\n    //if(k==0)return 1;\n    return C(n+k-1,k);\n}\nll P(ll n,ll k){\n    return fac[n]*ivf[n-k]%mod;\n}\nll po(ll x,ll y){\n    ll res=1;\n    for(;y;y>>=1){\n\tif(y&1)res=res*x%mod;\n\tx=x*x%mod;\n    }\n    return res;\n}\n\nint main(){\n    fac[0]=ivf[0]=inv[1]=1;\n    for(int i=1;i<N;i++){\n\tif(i>1)inv[i]=(mod-mod/i*inv[mod%i]%mod)%mod;\n\tfac[i]=fac[i-1]*i%mod;\n\tivf[i]=ivf[i-1]*inv[i]%mod;\n    }\n     ll n,m; cin>>n>>m;\n     ll ans=0;\n     for(ll p=0;p<=m;p++){\n\t if((3*m-p)%2==1)continue;\n\t ll cur=H(n,(3*m-p)/2)*C(n,p);\n\t mad(ans,cur);\n\t //cout<<cur<<endl;\n     }\n     mad(ans,-n*H(n,m-1));\n     if(ans<0)ans+=mod;\n     cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long \n#define nn 65536*48\n#define mod 998244353\nll qpow(ll x,ll y=mod-2){\n\tll res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%mod;x=x*x%mod;\n\t\ty=y/2;\n\t}\n\treturn res;\n}\nll f[nn],rf[nn];ll n,m;\nll C(ll x,ll y){\n\tif(x>y) return 0;\n\treturn f[y]*rf[x]%mod*rf[y-x]%mod;\n}\nint main(){\n\tf[0]=1;for(int i=1;i<nn;i++) f[i]=f[i-1]*i%mod;\n\trf[nn-1]=qpow(f[nn-1]);for(int i=nn-2;i>=0;i--) rf[i]=rf[i+1]*(i+1)%mod;\n\n\tscanf(\"%lld%lld\",&n,&m);ll ans=0;int k=m+1;ll pre=0;ll flg=0;\n\tfor(int odd=m;odd>=0;odd-=2) if(odd<=n){\n\t\tint brick=m+(m-odd)/2;\n\t\tll res=C(n-1,brick+n-1);\n\t\t\n\t\tif(!flg and brick>=m+1) {\n\t\t\tflg=1;pre=0;\n\t\t\tfor(int k=m+1;k<=brick;k++) pre+=C(n-2,brick+n-2-k)*n,pre%=mod;\n\t\t}\n\t\telse if(brick>=m+1) pre+=C(n-2,brick+n-2-(m+1))*n,pre%=mod;\n\t\t\n\t\tres-=pre;res%=mod;\n\t\tans=(ans+res*C(odd,n))%mod;\n\t\tif(odd) ans-=C(n-2,brick+n-2-m)*n%mod*C(odd-1,n-1)%mod;\n\t}\n\tprintf(\"%lld\\n\",(ans%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<list>\n#include<set>\n#include<string>\n#include<math.h>\nusing namespace std;\nint gcd(int a, int b) {\n\tint c = a % b;\n\twhile (c != 0) {\n\t\ta = b;\n\t\tb = c;\n\t\tc = a % b;\n\t}\n\treturn b;\n}\nstruct UnionFind {\n\tvector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n\n\tUnionFind(int N) : par(N) { //最初は全てが根であるとして初期化\n\t\tfor (int i = 0; i < N; i++) par[i] = i;\n\t}\n\n\tint root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n\t\tif (par[x] == x) return x;\n\t\treturn par[x] = root(par[x]);\n\t}\n\n\tvoid unite(int x, int y) { // xとyの木を併合\n\t\tint rx = root(x); //xの根をrx\n\t\tint ry = root(y); //yの根をry\n\t\tif (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま\n\t\tpar[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n\t}\n\n\tbool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す\n\t\tint rx = root(x);\n\t\tint ry = root(y);\n\t\treturn rx == ry;\n\t}\n};\ntypedef long long ll;\n\nll M = 998244353;\n\nvector<ll> fac(2000001); //n!(mod M)\nvector<ll> ifac(2000001); //k!^{M-2} (mod M)\n\nll mpow(ll x, ll n) {\n\tll ans = 1;\n\twhile (n != 0) {\n\t\tif (n & 1) ans = ans * x % M;\n\t\tx = x * x % M;\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\nvoid setcomb() {\n\tfac[0] = 1;\n\tifac[0] = 1;\n\tfor (ll i = 0; i < 2000000; i++) {\n\t\tfac[i + 1] = fac[i] * (i + 1) % M; // n!(mod M)\n\t}\n  ifac[2000000]=mpow(fac[2000000],M-2);\n  for(ll i=2000000;i>0;i--)\n    ifac[i-1]=ifac[i]*i%M;\n}\t\nll comb(ll a, ll b) {\n\tif (a == 0 && b == 0)return 1;\n\tif (a < b || a < 0)return 0;\n\tll tmp = ifac[a - b] * ifac[b] % M;\n\treturn tmp * fac[a] % M;\n}\nll perm(ll a, ll b) {\n\tif (a == 0 && b == 0)return 1;\n\tif (a < b || a < 0)return 0;\n\treturn fac[a] * ifac[a - b] % M;\n}\n// mod. m での a の逆元 a^{-1} を計算する\nlong long modinv(long long a) {\n\tlong long b = M, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= M;\n\tif (u < 0) u += M;\n\treturn u;\n}\nvector<vector<ll>> mul(vector<vector<ll>> a, vector<vector<ll>> b, int n) {\n\tint i, j, k, t;\n\tvector<vector<ll>> c(n);\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tt = 0;\n\t\t\tfor (k = 0; k < n; k++)\n\t\t\t\tt = (t + a[i][k] * b[k][j] % M) % M;\n\t\t\tc[i].push_back(t);\n\t\t}\n\t}\n\treturn c;\n}\n\ntemplate< typename Monoid >\nstruct SegmentTree {\n\n\tint sz;\n\tvector< Monoid > seg;\n\n\tconst Monoid M1;\n\n\tSegmentTree(int n, const Monoid &M1) : M1(M1) {\n\t\tsz = 1;\n\t\twhile (sz < n) sz <<= 1;\n\t\tseg.assign(2 * sz, M1);\n\t}\n\n\tvoid set(int k, const Monoid &x) {\n\t\tseg[k + sz] = x;\n\t}\n\n\tvoid build() {\n\t\tfor (int k = sz - 1; k > 0; k--) {\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\tvoid update(int k, const Monoid &x) {\n\t\tk += sz;\n\t\tseg[k] = x;\n\t\twhile (k >>= 1) {\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\tMonoid query(int a, int b) {\n\t\tMonoid L = M1, R = M1;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n\t\t\tif (a & 1) L = f(L, seg[a++]);\n\t\t\tif (b & 1) R = f(seg[--b], R);\n\t\t}\n\t\treturn f(L, R);\n\t}\n\n\tMonoid value(const int &k) const {\n\t\treturn seg[k + sz];\n\t}\n\n\tMonoid f(Monoid a, Monoid b) {\n\t\treturn a + b;\n\t}\n};\n\nint main() {\n\tll n, m, i, ans = 0,p;\n\tcin >> n >> m;\n\tsetcomb();\n\tif (m % 2 == 0) {\n\t\tfor (i = 0; i <= m; i+=2) {\n\t\t\tans += comb(n, i)*comb(n - 1 + (3 * m - i) / 2, n - 1);\n\t\t\tans %= M;\n\t\t\tp = i * comb(n, i) % M*comb(n - 2 + (m - i) / 2, n - 2) % M;\n\t\t\tp += n * comb(n, i) % M*comb(n - 1 + (m - i - 2) / 2, n - 1) % M;\n\t\t\tp %= M;\n\t\t\tans -= p;\n\t\t\tans = (ans + M) % M;\n\t\t}\n\t}\n\telse {\n\t\tfor (i = 1; i <= m; i += 2) {\n\t\t\tans += comb(n, i)*comb(n - 1 + (3 * m - i) / 2, n - 1);\n\t\t\tans %= M;\n\t\t\tp = i * comb(n, i) % M*comb(n - 2 + (m - i) / 2, n - 2) % M;\n\t\t\tp += n * comb(n, i) % M*comb(n - 1 + (m - i - 2) / 2, n - 1) % M;\n\t\t\tp %= M;\n\t\t\tans -= p;\n\t\t\tans = (ans + M) % M;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst int N = (int)1e6 + 5, M = (int)5e5 + 5, mod = 998244353;\nint n, m, fact[4 * M], inv_fact[4 * M], ans;\n\nint add (int _a, int _b) {\n    _a += _b;\n    if (_a >= mod) _a -= mod;\n    return _a;\n}\n\nint multi (int _a, int _b) { return (int)( (ll)_a * _b % mod); }\n\nint bin_pow (int _a, int _n) {\n    int ret = 1;\n    for (; _n; _n >>= 1, _a = multi(_a, _a) ) if (_n & 1) ret = multi(ret, _a);\n    return ret;\n}\n\nint C (int _k, int _n) {\n    if (_k < 0 || _k > _n || _n < 0) return 0;\n    return multi(fact[_n], multi(inv_fact[_k], inv_fact[_n - _k]) );\n}\n\nint candy_distribution (int _n, int _sum) { return C(_n - 1, _sum + _n - 1); }\n\nint main () {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n    fact[0] = 1; for (int i = 1; i < 4 * M; ++i) fact[i] = multi(fact[i - 1], i);\n    inv_fact[4 * M - 1] = bin_pow(fact[4 * M - 1], mod - 2);\n    for (int i = 4 * M - 2; i >= 0; --i) inv_fact[i] = multi(inv_fact[i + 1], i + 1);\n\n    cin >> n >> m;\n\n    for (int n_odd = 0; n_odd <= m; ++n_odd) {\n        int rem = 3 * m - n_odd;\n        if (rem & 1) continue ;\n        rem >>= 1;\n        ans = add(ans, multi(C(n_odd, n), candy_distribution(n, rem) ) );\n    }\n\n    for (int exceed = 2 * m + 1; exceed <= 3 * m; ++exceed) {\n        int rem = 3 * m - exceed;\n        ans = add(ans, mod - multi(n, candy_distribution(n - 1, rem) ) );\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int MAX = 1500000;\nconst int MOD = 998244353;\nint add(int a, int b) {return (a + b)%MOD;}\nint mul(int a, int b) {return 1LL*a*b%MOD;}\nint sub(int a, int b) {return add(a, MOD-b);}\nint pow_mod(int b, int p) {\n\tint ret = 1;\n\twhile( p ) {\n\t\tif( p & 1 ) ret = mul(ret, b);\n\t\tb = mul(b, b);\n\t\tp >>= 1;\n\t}\n\treturn ret;\n}\nint fct[MAX + 5], ifct[MAX + 5];\nvoid init() {\n\tfct[0] = 1;\n\tfor(int i=1;i<=MAX;i++)\n\t\tfct[i] = mul(fct[i-1], i);\n\tifct[MAX] = pow_mod(fct[MAX], MOD - 2);\n\tfor(int i=MAX-1;i>=0;i--)\n\t\tifct[i] = mul(ifct[i+1], i+1);\n}\nint comb(int n, int m) {\n\tif( n < m ) return 0;\n\telse return mul(fct[n], mul(ifct[m], ifct[n-m]));\n}\nint n, m, l;\nint main() {\n\tinit(); scanf(\"%d%d\", &n, &m);\n\tint ans = 0;\n\tfor(int i=(m&1);i<=n&&i<=m;i+=2) {\n\t\tint t = (3*m - i) / 2;\n\t\tint del = comb(t + n - 1, n - 1);\n\t\tif( t >= m )\n\t\t\tdel = sub(del, mul(i, comb(t - m + n - 1, n - 1)));\n\t\tif( t >= m + 1 )\n\t\t\tdel = sub(del, mul(n - i, comb(t - m - 1 + n - 1, n - 1)));\n\t\tans = add(ans, mul(comb(n, i), del));\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\nconst int mod=998244353;\nLL jc[2500005];\nvoid add(LL &x,LL y){x=(x+y)%mod;}\nLL sqrr(LL x){return x*x%mod;}\nLL ksm(LL x,int y){\n    if (y==0) return 1;if (y==1) return x;\n    LL ans=sqrr(ksm(x,y>>1));\n    if (y&1) ans=ans*x%mod;\n    return ans;\n}\nLL ny(LL x){return ksm(x,mod-2);}\nLL C(int n,int m){return jc[n]*ny(jc[m])%mod*ny(jc[n-m])%mod;}\nLL calf(int n,int s){\n    return C(n+s-1,s);\n}\nLL cal1(int n,int m,int k){\n    if (k>n) return 0;\n    if ((k^m)&1) return 0;\n    return C(n,k)*calf(n,(m*3-k)/2)%mod;\n}\nLL cal2(int n,int m,int k){\n    if (k>n) return 0;\n    return C(n,k)*k%mod*calf(k,m-k)%mod;\n}\nvoid init(){\n    const int n=2500000;\n    jc[0]=1;\n    for (int i=1;i<=n;i++) jc[i]=jc[i-1]*i%mod;\n}\nint main(){\n   // freopen(\"in.txt\",\"r\",stdin);\n   // freopen(\"out.txt\",\"w\",stdout);\n    init();\n    int n,m,m3;cin>>n>>m;m3=m*3;\n    LL ans=calf(n,m3);\n    for (int i=m+1;i<=m3;i++) add(ans,mod-cal1(n,m,i));\n    for (int i=1;i<=m;i++) add(ans,mod-cal2(n,m,i));\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define SZ(x) ((int)x.size())\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pa;\ntypedef vector<int> vec;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch='*'; (ch<'0'||ch>'9')&&ch!='-'; ch=getchar());\n    if(ch=='-') fu=1, ch=getchar();\n    for(v=0; ch>='0'&&ch<='9'; ch=getchar()) v=v*10+ch-'0';\n    if(fu) v=-v;\n}\nconst int MO=998244353;\nint n,m;\nLL ans,fac[3000010],inv[3000010];\nLL pw(LL x,LL y){\n\tLL t=1;\n\tfor (;y;y>>=1){\n\t\tif (y&1) t=t*x%MO;\n\t\tx=x*x%MO;\n\t}\n\treturn t;\n}\nLL C(int x,int y){\n\treturn fac[x]*inv[y]%MO*inv[x-y]%MO;\n}\nint main(){\n\tfac[0]=1;\n\tFOR(i,1,3000000) fac[i]=fac[i-1]*i%MO;\n\tinv[3000000]=pw(fac[3000000],MO-2);\n\tFORD(i,2999999,0) inv[i]=inv[i+1]*(i+1)%MO;\n\tcin>>n>>m;\n\tans=C(m*3+n-1,n-1);\n\t(ans-=1ll*n*C(m+n-2,n-1))%=MO;\n\tFOR(i,m+1,n) if ((m*3-i>=0) && (m*3-i)%2==0) (ans-=C(n,i)*C((m*3-i)/2+n-1,n-1))%=MO;\n\tans=(ans%MO+MO)%MO;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n\t#include <boost/multiprecision/cpp_int.hpp>\n\t#include <boost/multiprecision/cpp_dec_float.hpp>\n\tusing bll = boost::multiprecision::cpp_int;\n\tusing bdouble = boost::multiprecision::cpp_dec_float_100;\n#endif\n#ifdef LOCAL_DEV\n\tvoid debug_impl() { std::cerr << '\\n'; }\n\ttemplate<typename Head, typename... Tail> void debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head << (sizeof...(tail) ? \",\" : \"\"); debug_impl(tail...); }\n\t#define debug(...) do { std::cerr << \"(\" << #__VA_ARGS__ << \") =\"; debug_impl(__VA_ARGS__); } while (false)\n#else\n\t#define debug(...) do {} while (false)\n#endif\n#ifdef LOCAL_TEST\n\t#define BOOST_STACKTRACE_USE_ADDR2LINE\n\t#define BOOST_STACKTRACE_ADDR2LINE_LOCATION /usr/local/opt/binutils/bin/addr2line\n\t#define _GNU_SOURCE\n\t#include <boost/stacktrace.hpp>\n\tnamespace std {\n\t\ttemplate<typename T> class dvector : public std::vector<T> {\n\t\tpublic:\n\t\t\tdvector() : std::vector<T>() {}\n\t\t\texplicit dvector(size_t n, const T& value = T()) : std::vector<T>(n, value) {}\n\t\t\tdvector(const std::vector<T>& v) : std::vector<T>(v) {}\n\t\t\tdvector(const std::initializer_list<T> il) : std::vector<T>(il) {}\n\t\t\tdvector(const typename std::vector<T>::iterator first, const typename std::vector<T>::iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const std::string::iterator first, const std::string::iterator last) : std::vector<T>(first, last) {}\n\t\t\tT& operator[](size_t n) {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst T& operator[](size_t n) const {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\tclass dbool {\n\tprivate:\n\t\tbool boolvalue;\n\tpublic:\n\t\tdbool() : boolvalue(false) {}\n\t\tdbool(bool b) : boolvalue(b) {}\n\t\tdbool(const dbool& b) : boolvalue(b.boolvalue) {}\n\t\toperator bool&() { return boolvalue; }\n\t\toperator const bool&() const { return boolvalue; }\n\t};\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::dvector<T>& v) {\n\t\tfor (size_t i = 0; i < v.size(); ++i){ s << v[i]; if (i < v.size() - 1) s << \"\\t\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::dvector<std::dvector<T>>& vv) {\n\t\ts << \"\\n\"; for (size_t i = 0; i < vv.size(); ++i){ s << vv[i] << \"\\n\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::set<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::multiset<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate <typename T, size_t N> std::ostream& operator<<(std::ostream& s, const std::array<T, N>& a) {\n\t\ts << \"{ \"; for (size_t i = 0; i < N; ++i){ s << a[i] << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::map<T1, T2>& m) {\n\t\ts << \"{\\n\"; for (auto itr = m.begin(); itr != m.end(); ++itr){ s << \"\\t\" << (*itr).first << \" : \" << (*itr).second << \"\\n\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::pair<T1, T2>& p) {\n\t\treturn s << \"(\" << p.first << \", \" << p.second << \")\"; }\n\t#define vector dvector\n\t#define bool dbool\n\tclass SIGFPE_exception : std::exception {};\n\tclass SIGSEGV_exception : std::exception {};\n\tvoid catch_SIGFPE(int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGFPE_exception();\t}\n\tvoid catch_SIGSEGV(int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGSEGV_exception(); }\n\tsigned convertedmain();\n\tsigned main() { signal(SIGFPE, catch_SIGFPE); signal(SIGSEGV, catch_SIGSEGV); return convertedmain(); }\n\t#define main() convertedmain()\n#endif\n//#define int long long\nusing ll = long long;\n//constexpr int INF = 1e9;//INT_MAX=(1<<31)-1=2147483647\nconstexpr ll INF = (ll)1e18;//(1LL<<63)-1=9223372036854775807\nconstexpr ll MOD = 998244353;//(ll)1e9 + 7;\nconstexpr double EPS = 1e-9;\nconstexpr ll dx[4] = {1LL, 0LL, -1LL, 0LL};\nconstexpr ll dy[4] = {0LL, 1LL, 0LL, -1LL};\nconstexpr ll dx8[8] = {1LL, 0LL, -1LL, 0LL, 1LL, 1LL, -1LL, -1LL};\nconstexpr ll dy8[8] = {0LL, 1LL, 0LL, -1LL, 1LL, -1LL, 1LL, -1LL};\n#define rep(i, n)   for(ll i=0, i##_length=(n); i< i##_length; ++i)\n#define repeq(i, n) for(ll i=1, i##_length=(n); i<=i##_length; ++i)\n#define rrep(i, n)   for(ll i=(n)-1; i>=0; --i)\n#define rrepeq(i, n) for(ll i=(n)  ; i>=1; --i)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\nvoid p() { std::cout << '\\n'; }\ntemplate<typename Head, typename... Tail> void p(Head head, Tail... tail) { std::cout << head << (sizeof...(tail) ? \" \" : \"\"); p(tail...); }\ntemplate<typename T> inline void pv(std::vector<T>& v) { for(ll i=0, N=v.size(); i<N; i++) std::cout << v[i] << \" \\n\"[i==N-1]; }\ntemplate<typename T> inline T gcd(T a, T b) { return b ? gcd(b,a%b) : a; }\ntemplate<typename T> inline T lcm(T a, T b) { return a / gcd(a,  b) * b; }\ntemplate<typename T> inline bool chmax(T& a, T b) { return a < b && (a = b, true); }\ntemplate<typename T> inline bool chmin(T& a, T b) { return a > b && (a = b, true); }\ntemplate<typename T> inline void uniq(std::vector<T>& v) { v.erase(std::unique(v.begin(), v.end()), v.end()); }\n\n/*-----8<-----template-----8<-----*/\n\ninline constexpr ll extgcd(ll a, ll b, ll &x, ll &y){ ll g = a; x = 1; y = 0; if(b){ g = extgcd(b, a % b, y, x); y -= a / b * x; } return g; }\ninline constexpr ll invmod(ll a, ll m = MOD){ ll x = 0, y = 0; extgcd(a, m, x, y); return (x + m) % m; }\nclass Modint{\npublic:\n\tll _num;\n\tconstexpr Modint() : _num() { _num = 0; }\n\tconstexpr Modint(ll x) : _num() { _num = x % MOD; if(_num < 0) _num += MOD; }\n\tinline constexpr Modint operator= (int x){ _num = x % MOD; if(_num<0) _num += MOD; return *this; }\n\tinline constexpr Modint operator= (ll x){ _num = x % MOD; if(_num<0) _num += MOD; return *this; }\n\tinline constexpr Modint operator= (Modint x){ _num = x._num; return *this; }\n\tinline constexpr Modint operator+ (int x){ return Modint(_num + x); }\n\tinline constexpr Modint operator+ (ll x){ return Modint(_num + x); }\n\tinline constexpr Modint operator+ (Modint x){ ll a = _num + x._num; if(a >= MOD) a -= MOD; return Modint{a}; }\n\tinline constexpr Modint operator+=(int x){ _num += x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator+=(ll x){ _num += x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator+=(Modint x){ _num += x._num; if(_num >= MOD) _num -= MOD; return *this; }\n\tinline constexpr Modint operator++(){ _num++; if(_num == MOD) _num = 0; return *this; }\n\tinline constexpr Modint operator- (int x){ return Modint(_num - x); }\n\tinline constexpr Modint operator- (ll x){ return Modint(_num - x); }\n\tinline constexpr Modint operator- (Modint x){ ll a = _num - x._num; if(a < 0) a += MOD; return Modint{a}; }\n\tinline constexpr Modint operator-=(int x){ _num -= x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator-=(ll x){ _num -= x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator-=(Modint x){ _num -= x._num; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator--(){ _num--; if(_num == -1) _num = MOD - 1; return *this; }\n\tinline constexpr Modint operator* (int x){ return Modint(_num * (x % MOD)); }\n\tinline constexpr Modint operator* (ll x){ return Modint(_num * (x % MOD)); }\n\tinline constexpr Modint operator* (Modint x){ return Modint{_num * x._num % MOD}; }\n\tinline constexpr Modint operator*=(int x){ _num *= Modint(x); _num %= MOD; return *this; }\n\tinline constexpr Modint operator*=(ll x){ _num *= Modint(x); _num %= MOD; return *this; }\n\tinline constexpr Modint operator*=(Modint x){ _num *= x._num; _num %= MOD; return *this; }\n\tinline constexpr Modint operator/ (int x){ return Modint(_num * invmod(Modint(x), MOD)); }\n\tinline constexpr Modint operator/ (ll x){ return Modint(_num * invmod(Modint(x), MOD)); }\n\tinline constexpr Modint operator/ (Modint x){ return Modint{_num * invmod(x._num, MOD) % MOD}; }\n\tinline constexpr Modint operator/=(int x){ _num *= invmod(Modint(x), MOD); _num %= MOD; return *this; }\n\tinline constexpr Modint operator/=(ll x){ _num *= invmod(Modint(x), MOD); _num %= MOD; return *this; }\n\tinline constexpr Modint operator/=(Modint x){ _num *= invmod(x._num, MOD); _num %= MOD; return *this; }\n\tinline constexpr Modint pow(ll n){ ll i = 1, x = n>=0 ? n : -n; Modint ans = 1, cnt = n>=0 ? *this : Modint(1) / *this; while(i <= x){ if(x & i){ ans *= cnt; x ^= i; } cnt *= cnt; i *= 2; } return ans; }\n\tinline constexpr operator ll() const { return _num; }\n};\ninline std::istream& operator>>(std::istream &s, Modint &x){ ll t; s>>t; x=t; return s; }\nvector<Modint> fac(1, 1), inv(1, 1);\ninline void reserve(size_t a){\n\tif(fac.size() >= a) return;\n\tif(a < fac.size() * 2) a = fac.size() * 2;\n\tif(a >= MOD) a = MOD;\n\twhile(fac.size() < a) fac.push_back(fac.back() * ll(fac.size()));\n\tinv.resize(fac.size());\n\tinv.back() = Modint(1) / fac.back();\n\tfor(ll i = inv.size() - 1; !inv[i - 1]; i--) inv[i - 1] = inv[i] * i;\n}\ninline Modint factorial(ll n){ if(n < 0) return 0; reserve(n + 1); return fac[n]; }\ninline Modint nPk_loop(ll n, ll k){ if(n<k) return 0; Modint val(1); for(ll i=n;i>(n-k);i--)val*=i; return val; }\ninline Modint nCk_loop(ll n, ll k){ if(n<k) return 0; Modint val(1); k=min(k,n-k); for(ll i=n;i>(n-k);i--)val*=i; for(ll i=k;i>1;i--)val/=i; return val; };\ninline Modint nPk(ll n, ll k){ if(k < 0 || n < k) return 0; if(n>=(ll)1e7) return nPk_loop(n, k); reserve(n + 1); return fac[n] * inv[n - k]; }\ninline Modint nCk(ll n, ll k){ if(k < 0 || n < k) return 0; if(n>=(ll)1e7) return nCk_loop(n, k); reserve(n + 1); return fac[n] * inv[k] * inv[n - k]; }\ninline Modint nHk(ll n, ll k){ return nCk(n + k - 1, k); } //n種類のものから重複を許してk個選ぶ=玉k個と仕切りn-1個\n\n/*\nnCk：n!が間に合わないくらい巨大でkが小さいとき、素直に計算すると間に合う のは1e7以上に組み込んであります\n\tauto f = [](ll n, ll k){\n\t\tif(n<k)return Modint(0);\n\t\tModint val(1);\n\t\tk=min(k,n-k);\n\t\tfor(ll i=n;i>(n-k);i--)val*=i;\n\t\tfor(ll i=k;i>1;i--)val/=i;\n\t\treturn val;\n\t};\n*/\n\n\n//区間add, 区間sum ができる\ntemplate< typename T >\nclass BinaryIndexedTree {\npublic:\n\tclass BinaryIndexedTreeNaive {\n\tpublic:\n\t\tll size;\n\t\tvector<T> data;\n\t\tBinaryIndexedTreeNaive(ll N) : size(N+1), data(size, 0) {}\n\n\t\t// sum [0, i)\n\t\tT sum(ll i) {\n\t\t\tT ret = 0;\n\t\t\tfor(--i; i>=0; i=(i&(i+1))-1) ret += data[i];\n\t\t\treturn ret;\n\t\t}\n\n\t\t// sum [i, j)\n\t\tT sum(ll i, ll j) {\n\t\t\treturn sum(j) - sum(i);\n\t\t}\n\n\t\t// add x to i\n\t\tvoid add(ll i, T x) {\n\t\t\tfor(; i < size; i|=i+1) data[i] += x;\n\t\t}\n\t};\n\tll size;\n\tBinaryIndexedTreeNaive b,c;\n\tBinaryIndexedTree(ll N) : size(N), b(size), c(size) {}\n\n\t// add x to [i, j) \n\tvoid add(ll i, ll j, T x) {\n\t\tb.add(i,x*-i);\n\t\tb.add(j,x*j);\n\t\tc.add(i,x);\n\t\tc.add(j,x*-1);\n\t}\n\n\t// sum [0, i)\n\tT sum(ll i) { \n\t\treturn b.sum(i+1) + c.sum(i+1)*i;\n\t}\n\n\t// sum [i, j)\n\tT sum(ll i, ll j) {\n\t\treturn sum(j) - sum(i);\n\t}\n};\ntemplate<typename T> std::ostream& operator<<(std::ostream& s, BinaryIndexedTree<T>& bit) { \n\tfor(ll i=0; i<bit.size; i++) s << bit.sum(i, i+1) << \"\\t\\n\"[i==bit.size-1];\n\treturn s;\n}\n\n/*-----8<-----library-----8<-----*/\n\nvoid solve() {\n\tll N,M;\n\tcin>>N>>M;\n\tvector<BinaryIndexedTree<Modint>> dp(N+1,3*M+1);\n\tdp[0].add(0,1,1);\n\trep(i,N){\n\t\trep(j,3*M+1){\n\t\t\tdp[i+1].add(j, min(j+2*M+1,3*M+1), dp[i].sum(j,j+1));\n\t\t}\n\t}\n\n\trep(i,N+1)debug(dp[i]);\n\n\tModint ans=dp[N].sum(3*M,3*M+1);\n\tp(ans);\n\n}\n\nsigned main() {\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nconstexpr ll mod = 998244353;\nconstexpr double PI = 3.14159265358979323846;\nmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\n\n\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\nstruct mint {\n    ll x;\n    mint():x(0){}\n    mint(ll x):x((x%mod+mod)%mod){}\n    mint& fix() { x = (x%mod+mod)%mod; return *this;}\n    mint operator-() const { return mint(0) - *this;}\n    mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n    mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n    mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n    mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n    mint operator+(const mint& a)const{ return mint(*this) += a;}\n    mint operator-(const mint& a)const{ return mint(*this) -= a;}\n    mint operator*(const mint& a)const{ return mint(*this) *= a;}\n    mint operator/(const mint& a)const{ return mint(*this) /= a;}\n    bool operator<(const mint& a)const{ return x < a.x;}\n    bool operator==(const mint& a)const{ return x == a.x;}\n};\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\n\nint MAXN = 3000000;\n// factorial\nvector<mint> fact(MAXN+1);\nvoid init() {\n  fact[0] = 1;\n  for(int i=1; i<=MAXN; i++) fact[i] = fact[i-1]*i;\n}\n\n// nCr\nmint comb(int n, int r) {\n  if (n < r || n < 0 || r < 0) return 0;\n  return fact[n]/(fact[r]*fact[n-r]);\n}\n\nsigned main() {\n  SPEED;\n  int n, m; cin >> n >> m;\n  init();\n\n  mint all = comb(3*m+n-1, n-1);\n\n  mint ng1 = 0;\n  for(int i=m-1; i>=0; i--) {\n    mint tmp = comb(i+n-2, n-2);\n    ng1 += tmp*n;\n  }\n\n  mint ng2 = 0;\n  for(int i=m+1; i<=n; i++) {\n    if ((3*m-i)%2!=0) continue;\n    int r = (3*m-i)/2;\n    if (r<0) continue;\n    mint tmp = comb(r+n-1, n-1);\n    tmp *= comb(n, i);\n    ng2 += tmp;\n  }\n  debug(ng2.x);\n  cout << all-ng1-ng2 << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 3000000;\nconst int MOD = 998244353;\n\nint fact[N];\nint ifact[N];\n\nint C(int n, int k) {\n  if (k < 0 || k > n) return 0;\n  return 1LL * fact[n] * ifact[k] % MOD * ifact[n-k] % MOD;\n}\n\nint M(int n, int k) {\n  return C(n + k - 1, k - 1);\n}\n\nint n, m;\n\nint main() {\n  fact[0] = 1;\n  for (int i = 1; i < N; ++i) fact[i] = 1LL * fact[i-1] * i % MOD;\n  ifact[N-1] = 347057526;\n  for (int i = N-2; i >= 0; --i) ifact[i] = 1LL * ifact[i+1] * (i+1) % MOD;\n  \n  scanf(\"%d %d\", &n, &m);\n  \n  long long ans = 0;\n  for (int odd = 0; odd <= m; ++odd) {\n    if (m*3 - odd & 1) continue;\n    \n    int nn = m*3 - odd >> 1;\n    \n    long long res1 = 1LL * M(nn, n) - 1LL * M(nn - m, n) * n % MOD;\n    long long res2 = 1LL * M(nn - m, n - 1) * n % MOD;\n    \n    ans = ans + res1 * C(n, odd) % MOD + res2 * C(n-1, odd) % MOD;\n  }\n  \n  ans %= MOD;\n  if (ans < 0) ans += MOD;\n  \n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 1e6 + 10, M = 5e5 + 10, S = 2e6 + 10;\nconst int mod = 998244353;\n\nll fact[S], finv[S];\n\nll choose(int n, int k);\nll pwr(ll x, ll e);\n\nint main() {\n\tfast_cin();\n\tfact[0] = finv[0] = 1;\n\tfor (int i = 1; i < S; ++i) {\n\t\tfact[i] = (i * fact[i - 1]) % mod;\n\t\tfinv[i] = pwr(fact[i], mod - 2);\n\t}\n\tint n, m;\n\tcin >> n >> m;\n\tll ans = 0;\n\tfor (int i = 0; i <= min(n, m); ++i) {\n\t\tif ((3 * m - i) % 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tll sum = (3 * m - i) / 2;\n\t\tll cur = choose(sum + n - 1, n - 1);\n\t\tif (sum > m) {\n\t\t\tll temp = n * choose(sum - (m + 1) + n - 1, n - 1);\n\t\t\ttemp %= mod;\n\t\t\tcur -= temp;\n\t\t\tcur += mod;\n\t\t\tcur %= mod;\n\t\t}\n\t\tcur *= choose(n, i);\n\t\tcur %= mod;\n\t\tll temp = (n * choose(n - 1, i - 1)) % mod;\n\t\ttemp *= choose((m - i) / 2 + n - 2, n - 2);\n\t\ttemp %= mod;\n\t\tans += cur;\n\t\tans -= temp;\n\t\tans += mod;\n\t\tans %= mod;\n\t\t// cout << i << ' ' << cur << endl;\n\t}\n\tcout << ans << endl;\n}\n\nll choose(int n, int k) {\n\tif (n < k or k < 0) {\n\t\treturn 0;\n\t} else {\n\t\tll ans = (fact[n] * finv[k]) % mod;\n\t\tans = (ans * finv[n - k]) % mod;\n\t\treturn ans;\n\t}\n}\n\nll pwr(ll x, ll e) {\n\tll res = 1;\n\twhile (e) {\n\t\tif (e % 2) {\n\t\t\tres = (res * x) % mod;\n\t\t}\n\t\tx = (x * x) % mod;\n\t\te /= 2;\n\t}\n\treturn res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst ll MOD = 1e9+7;\nconst ll MOD2 = 998244353;\nconst ll INF = 1e18;\nconst string alpha = \"abcdefghijklmnopqrstuvwxyz\";\n\nint main(){\n    ll N, M;\n    cin >> N >> M;\n    ll n = 2*M+N, m = MOD2, inv[n+1];\n    rep2(i, 1, n){\n        inv[i] = 1;\n        ll e[31];\n        e[0] = i;\n        rep2(j, 1, 30) e[j] = (e[j-1]*e[j-1]) % m;\n        ll k = m-2;\n        int count = 0;\n        while(k > 0){\n            if(k % 2 == 1) inv[i] *= e[count], inv[i] %= m;\n            k /= 2;\n            count++;\n        }\n    }\n    ll fac[n+1], ifac[n+1];\n    fac[0] = 1, ifac[0] = 1;;\n    rep2(i, 1, n){\n        fac[i] = (fac[i-1]*i)%MOD2;\n        ifac[i] = (ifac[i-1]*inv[i])%MOD2;\n    }\n    ll k = min(N, M);\n    if((M-k)%2 == 1) k--;\n    ll ans = 0;\n    while(k >= 0){\n        ll tmp1 = k, tmp2 = N-k, i = (3*M-k)/2, j = i-M, comb = fac[i+N-1], comb1 = fac[N];\n        comb *= ifac[N-1], comb %= MOD2;\n        comb *= ifac[i], comb %= MOD2;\n        comb1 *= ifac[k], comb1 %= MOD2;\n        comb1 *= ifac[N-k], comb1 %= MOD2;\n        tmp1 *= fac[j+N-1], tmp1 %= MOD2;\n        tmp1 *= ifac[N-1], tmp1 %= MOD2;\n        tmp1 *= ifac[j], tmp1 %= MOD2;\n        j--;\n        if(j >= 0){\n            tmp2 *= fac[j+N-1], tmp2 %= MOD2;\n            tmp2 *= ifac[N-1], tmp2 %= MOD2;\n            tmp2 *= ifac[j], tmp2 %= MOD2;\n        }\n        else tmp2 = 0;\n        ll p = (comb + 2*MOD2 -(tmp1+tmp2))%MOD2;\n        ans += comb1*p % MOD2;\n        ans %= MOD2;\n        k -= 2;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <array>\nusing namespace std;\nusing ULL = unsigned long long;\nusing UL = unsigned;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nstruct Problem {\n\n\tvector<ULL> fac, inv, ifac;\n\tstatic const ULL M = 998244353;\n\tULL C(UL n, UL m) { if (n < m) return 0; return fac[n] * ifac[m] % M * ifac[n - m] % M; }\n\n\tvoid Solve() {\n\t\tUL N, K; cin >> N >> K;\n\t\t{\n\t\t\tULL sz = N + 2 * K;\n\t\t\tfac.resize(sz); inv.resize(sz); ifac.resize(sz);\n\t\t\tfac[0] = 1; for (ULL i = 1; i < sz; i++) fac[i] = fac[i - 1] * i % M;\n\t\t\tinv[1] = 1; for (ULL i = 2; i < sz; i++) inv[i] = M - (M / i * inv[M % i]) % M;\n\t\t\tifac[0] = 1; for (ULL i = 1; i < sz; i++) ifac[i] = ifac[i - 1] * inv[i] % M;\n\t\t}\n\t\tULL ans = 0;\n\t\tfor (ULL m = K % 2; m <= min(K, N); m += 2) {\n\t\t\tULL oe = C(N, m);\n\t\t\tULL al = C((3 * K - m) / 2 + N - 1, N - 1);\n\t\t\tULL ov = C((K - m) / 2 + N - 1, N - 1) * m % M;\n\t\t\tULL ev = C((K - m) / 2 + N - 2, N - 1) * (N - m) % M;\n\t\t\tULL dance = (al + (M - ov) + (M - ev)) % M;\n\t\t\tdance = dance * oe % M;\n\t\t\t//cout << m << \":\" << oe << \" \" << al << \" \" << ov << \" \" << ev << endl;\n\t\t\tans += dance;\n\t\t}\n\t\tcout << (ans % M) << endl;\n\t}\n\n\tProblem();\n};\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\nProblem::Problem() {\n\tcout << fixed << setprecision(10);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define lsb(x) (x & (-x))\n#define ll long long\n#define ull unsigned long long\n// 217\n// 44\n\n\nconst int MOD = 998244353;\n\ninline int lgput(int a, int b) {\n    int ans = 1;\n    while(b > 0) {\n        if(b & 1) ans = (1LL * ans * a) % MOD;\n        b >>= 1;\n        a = (1LL * a * a) % MOD;\n    }\n    return ans;\n}\n\ninline void mod(int &x) {\n    if(x >= MOD)\n        x -= MOD;\n}\n\ninline void add(int &x, int y) {\n    x += y;\n    mod(x);\n}\n\ninline void sub(int &x, int y) {\n    x += MOD - y;\n    mod(x);\n}\n\ninline void mul(int &x, int y) {\n    x = (1LL * x * y) % MOD;\n}\n\nusing namespace std;\n\nconst int MAXN = (int) 1e6;\n\nint fact[2 * MAXN + 1], invfact[2 * MAXN + 1];\n\ninline void prec(int n) {\n    fact[0] = 1;\n    for(int i = 1; i <= n; i++) {\n        fact[i] = (1LL * fact[i - 1] * i) % MOD;\n    }\n    invfact[n] = lgput(fact[n], MOD - 2);\n    for(int i = n - 1; i >= 0; i--) {\n        invfact[i] = (1LL * invfact[i + 1] * (i + 1)) % MOD;\n    }\n}\n\ninline int comb(int n, int k) {\n    if(n < k) return 0;\n    return (1LL * fact[n] * (1LL * invfact[k] * invfact[n - k] % MOD)) % MOD;\n}\n\ninline int solve(int sum, int n, int odd) {\n    int ans = 0;\n    for(int i = 0; i <= odd; i++) {\n        int cur = comb(n, i);\n        if((sum - i) % 2 == 0) {\n            mul(cur, comb(n - 1 + (sum - i) / 2, n - 1));\n            add(ans, cur);\n        }\n    }\n    return ans;\n}\n\nint main() {\n    //ifstream cin(\"A.in\");\n    //ofstream cout(\"A.out\");\n    int n, m;\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    cin >> n >> m;\n\n    prec(n + 2 * m);\n\n    int ans = solve(3 * m, n, m);\n\n    int cur = 0;\n    add(cur, solve(m, n, m));\n    sub(cur, solve(m, n - 1, m));\n    mul(cur, n);\n\n    sub(ans, cur);\n\n    cout << ans;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\nusing namespace std;\ntypedef long long int ll;\n\nll mod=998244353;\n\nll mod_pow(ll a,ll b){\n\ta%=mod;\n\tif(b==0)return 1;\n\tif(b==1)return a;\n\tll res=mod_pow(a,b/2)%mod;\n\tres*=res; res%=mod;\n\tif(b%2)res*=a;\n\treturn res%mod;\n}\n\nstruct perm{\nprivate:\n\tint sz;\n\tvector<ll> p,invp;\npublic:\n\tperm(int n){\n\t\tsz=n+1;\n\t\tp.resize(sz),invp.resize(sz);\n\t\tp[0]=1;\n\t\tfor(int i=1;i<=sz-1;i++){\n\t\t\tp[i]=p[i-1]*i%mod;\n\t\t}\n\t\tinvp[sz-1]=mod_pow(p[sz-1],mod-2);\n\t\tfor(int i=sz-2;i>=0;i--){\n\t\t\tinvp[i]=invp[i+1]*(i+1)%mod;\n\t\t}\n\t}\n\tll comb(ll x,ll y){\n\t\tif(x<y||y<0)return 0;\n\t\treturn (p[x]*invp[x-y]%mod)*invp[y]%mod;\n\t}\n};\nperm p(1<<20);\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tll n,m; cin >> n >> m;\n\tll ans=0;\n\tfor(int i=0;i<=min(n,m);i++){\n\t\tif((3*m-i)%2)continue;\n\t\tll k=(3*m-i)/2;\n\t\t(ans+=p.comb(n,i)*p.comb(n-1+k,k)%mod)%=mod;\n\t}\n\tll res=0;\n\tll res2=0;\n\tfor(int i=0;i<=(m,n);i++){\n\t\tif((m-i)%2)continue;\n\t\tll k=(m-i)/2;\n\t\t(res+=p.comb(n,i)*p.comb(n-1+k,k)%mod)%=mod;\n\t}\n\tfor(int i=0;i<=(m,n-1);i++){\n\t\tif((m-i)%2)continue;\n\t\tll k=(m-i)/2;\n\t\t(res2+=p.comb(n-1,i)*p.comb(n-2+k,k)%mod)%=mod;\n\t}\n\tres-=res2;\n\tres%=mod;\n\tans-=res*n;\n\tans%=mod;\n\tif(ans<0)ans+=mod;\n\tcout << ans << endl;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    Combination C(N + M + 10);\n\n    mint ans = 0;\n    REP(i, N + 1){\n        int rest = 3 * M - i;\n        if(!(rest % 2 == 0 && rest / 2 >= M)) continue;\n        int p = rest / 2;\n        mint c1 = C.nCr(N, i);\n        mint c2 = C.nCr(p + N - 1, p);\n        ans += c1 * c2;\n\n        mint tmp = c1 * c2;\n    }\n    //debug(ans);\n    mint d = 0;\n    FOR(i, 2 * M + 1, 3 * M + 1){\n        int r = 3 * M - i;\n        d += C.nCr(r + N - 2, r);\n    }\n    //debug(d);\n    ans -= d * N;\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb           push_back\n#define pii          pair<int,int>\n#define vi           vector<int>\n#define vpii         vector<pair<int,int>>\n#define gph          map<int, vector<int>>\n#define mp           make_pair\n#define FOR(i, n) for (int i = 0; i <  (int)(n); i++)\n#define FOR1(i, n) for (int i = 1; i <= (int)(n); i++)\n#define FORD0(i, n) for (int i = (int)n; i >= 0; i--)\n#define FORD1(i, n) for (int i = (int)n; i >= 1; i--)\n#define FORS(i, n) for(; i < (int)(n); i++)\n#define debug(X) { cout << #X << \" = \" << (X) << endl; }\n#define printArr(A,n) { cout << #A << \" = \"; FOR(i,n) cout << A[i] << ' '; cout << endl; }\nusing namespace std;\n#define int long long int\nconst int mod = 998244353;\nvector<int> fac;\nlong long inv(long long a, long long b = mod){\n return 1<a ? b - inv(b%a,a)*b/a : 1;\n}\nint choose(int a, int b){\n//    cout << a << \" \" << b <<endl;\n    assert(b <= a && b >= 0);\n    int ans = fac[a] * inv(fac[b]);\n    assert(ans >= 0);\n    ans %= mod;\n    ans *= inv(fac[a-b]);\n    assert(ans >= 0);\n    ans %= mod;\n    assert(ans >= 0);\n    return ans;\n}\nsigned main(){\n    ios_base::sync_with_stdio(false);cin.tie(NULL);\n    \n    int n,m;cin >> n >> m;\n    fac.resize(n+m*5 + 2);\n    fac[0] = 1;\n    FOR1(i, n+m*5)fac[i] = fac[i-1]*i, fac[i] %= mod;\n\n    int ans = choose(n-1 + 3*m, n-1);\n    ans -= choose(m-1 + n-1, n-1)*n;\n    ans %= mod;\n    for(int odds = m+1; odds <= min(n, 3*m); odds++){\n        if((3*m - odds) % 2)continue;\n        //debug(odds);\n        int distribute = choose(n, odds);\n        int remains = 3*m - odds; \n\n        int toSub = choose((remains/2) + n-1, n-1);\n        //cout << odds << \" \" << distribute << \" \" << toSub <<endl;\n        int temp = toSub * distribute;\n        temp %= mod;\n        ans -= temp;\n        ans %= mod;\n        //while(ans < 0)ans += mod;\n    }\n    //debug(ans);\n    while(ans < 0)ans += mod;\n    cout <<ans;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=1000000;\nconst int MAXM=500000;\nconst int MAXFAC=3*MAXM+MAXN-1;\nconst int MOD=998244353;\n\nint inv[MAXFAC+1];\nint fac[MAXFAC+1];\nint ifac[MAXFAC+1];\n//int p2[MAXFAC+1];\nint choose(int n,int k) { assert(n>=0&&n<=MAXFAC); if(k<0||k>n) return 0; return (ll)fac[n]*ifac[k]%MOD*ifac[n-k]%MOD; }\n\nint n,m;\n\nint solve() {\n\tinv[1]=1; FORE(i,2,MAXFAC) inv[i]=(ll)(MOD-MOD/i)*inv[MOD%i]%MOD;\n\tfac[0]=1; FORE(i,1,MAXFAC) fac[i]=(ll)fac[i-1]*i%MOD;\n\tifac[0]=1; FORE(i,1,MAXFAC) ifac[i]=(ll)ifac[i-1]*inv[i]%MOD;\n\t//p2[0]=1; FORE(i,1,MAXFAC) p2[i]=(ll)p2[i-1]*2%MOD;\n\n\tint all=choose(3*m+n-1,n-1);\n\tint sub=(ll)n*choose(m-1+n-1,n-1)%MOD;\n\tint ret=all-sub; if(ret<0) ret+=MOD;\n\n\tREPE(nodd,n) {\n\t\tif(nodd<=m) continue;\n\t\tif((3*m-nodd)%2!=0) continue;\n\t\t//printf(\"nodd=%d\\n\",nodd);\n\t\tint v1=choose(n,nodd),v2=choose((3*m-nodd)/2+n-1,n-1);\n\t\tint cur=(ll)v1*v2%MOD;\n\t\tret-=cur; if(ret<0) ret+=MOD;\n\t}\n\t//printf(\"all=%d sub=%d ret=%d\\n\",all,sub,ret);\n\treturn ret;\n}\n\nint solvestupid() {\n\tset<vector<int>> seen;\n\tif(m==1) REP(i,n) REP(j,n) if(j!=i) { vector<int> cur(n,0); cur[i]+=2,cur[j]+=1; seen.insert(cur); }\n\tif(m==2) REP(i,n) REP(j,n) if(j!=i) REP(ii,n) REP(jj,n) if(jj!=ii) { vector<int> cur(n,0); cur[i]+=2,cur[j]+=1,cur[ii]+=2,cur[jj]+=1; seen.insert(cur); }\n\tif(m==3) REP(i,n) REP(j,n) if(j!=i) REP(ii,n) REP(jj,n) if(jj!=ii) REP(iii,n) REP(jjj,n) if(jjj!=iii) { vector<int> cur(n,0); cur[i]+=2,cur[j]+=1,cur[ii]+=2,cur[jj]+=1,cur[iii]+=2,cur[jjj]+=1; seen.insert(cur); }\n\treturn SZ(seen);\n}\n\nvoid run() {\n\tscanf(\"%d%d\",&n,&m);\n\tprintf(\"%d\\n\",solve());\n\t//if(m<=3) printf(\"%d\\n\",solvestupid());\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint main(){\n    const int maxSize = 2000001;\n\tvector<long long> inv(maxSize);\n\tvector<long long> fact(maxSize);\n\tvector<long long> factInv(maxSize);\n\tfor(int i=0;i<2;i++) inv[i] = fact[i] = factInv[i] = 1;\n\tfor(int i=2;i<maxSize;i++){\n\t\tinv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n\t\tfact[i] = fact[i-1] * i % MOD;\n\t\tfactInv[i] = factInv[i-1] * inv[i] % MOD;\n\t}\n\tauto comb = [&](int n, int r){\n\t\tif(n < r || r < 0) return 0LL;\n\t\treturn fact[n] * factInv[n-r] % MOD * factInv[r] % MOD;\n\t};\n    auto perm = [&](int n, int r){\n        if(n < r || r < 0) return 0LL;\n        return fact[n] * factInv[n-r] % MOD;\n    };\n    int N, M; cin >> N >> M;\n    long long res = 0;\n    for(int m=0;2*m<=M;m++){\n        int m2 = M + m;\n        int m1 = M - 2*m;\n        if(m1 > N) continue;\n        res = (res + comb(m2+N-1, N-1) * comb(N, m1)) % MOD;\n        if(m1 > 0){\n            res = (res + MOD - (comb(m2-M+N-2, N-2) * comb(N-1, m1-1)) % MOD * N % MOD) % MOD;\n        }\n        if(m2 >= M+1){\n            res = (res + MOD - (comb(m2-M-1+N-1, N-1) * comb(N, m1)) % MOD * N % MOD) % MOD;\n        }\n    }\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n问题等价于求长为 n 的满足一下三个条件的数列的个数：\n\n1. 所有值的和为 s1 = 3m\n2. 奇数的个数不超过 s2 = m\n3. 最大的数不超过 s3 = 2m\n\n先考虑第一个限制，相当于把 s1 个球放进 n 个盒子，方案数为 f1(s1, n) = C(n + s1, s1)。\n\n再考虑第二个限制，设 f2(n, m, k) 为长度为 n ，和为 m ，奇数不超过 k 个的方案数，\n枚举奇数个数 i ，然后把这 i 个奇数减 1 弄成偶数，\n那么 i 的贡献就是 C(n, i) * f1((m - i) / 2, n - 1) 。\n\n最后考虑第三个限制，由于和为 3m ，超过 2m 的数最多只有一个，\n简单容斥，钦定一个数大于 2m ，那么贡献就是 - n * f2(n, m, m) ，\n但事实上这也算进去了该数恰好为 2m 的情况，继续容斥，贡献为 n * f2(n - 1, m, m) ，\n那么答案 f3(n, m) = f2(n, 3m, m) - n * (f2(n, m, m) - f2(n - 1, m, m)) 。\n#endif\n#include <cstdio>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long lolong;\n\ninline int input() { int x; scanf(\"%d\", &x); return x; }\n\nconst int maxn = 3000005, mod = 998244353;\nlolong fac[maxn];\nlolong inv[maxn];\nlolong ifac[maxn];\n\ninline lolong c(int n, int m) {\n\treturn fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\n\nlolong f(int n, int m, int k) {\n\tlolong res = 0;\n\tfor(int i = 0; i <= k and i <= n; i ++)\n\t\tif(!((m - i) & 1))\n\t\t\tres += c(n, i) * c((m - i) / 2 + n - 1, (m - i) >> 1) % mod;\n\treturn res % mod;\n}\n\nint main() {\n\tfac[0] = 1;\n\tfor(int i = 1; i < maxn; i ++)\n\t\tfac[i] = fac[i - 1] * i % mod;\n\n\tinv[1] = 1;\n\tfor(int i = 2; i < maxn; i ++)\n\t\tinv[i] = (mod - mod / i) * inv[mod % i] % mod;\n\n\tifac[0] = 1;\n\tfor(int i = 1; i < maxn; i ++)\n\t\tifac[i] = ifac[i - 1] * inv[i] % mod;\n\n\tint n = input(), m = input();\n\tprintf(\"%lld\\n\",\n\t\t\t(f(n, m * 3, m) + mod -\n\t\t\t n * (f(n, m, m) + mod -\n\t\t\t\t f(n - 1, m, m)) % mod) % mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int mod = 998244353;\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\nint sub(int a, int b) {\n    int s = a - b;\n    if (s < 0) s += mod;\n    return s;\n}\nconst int maxN = 5 * (int)1e6 + 100;\nint fact[maxN], invfact[maxN], inv[maxN];\nint cnk(int a, int b) {\n    if (a < 0 || b < 0 || a < b) return 0;\n    return mult(fact[a], mult(invfact[b], invfact[a - b]));\n}\nint n, m;\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //freopen(\"input.txt\", \"r\", stdin);\n    cin >> n >> m;\n    fact[0] = inv[1] = fact[1] = invfact[1] = invfact[0] = 1;\n    for (int i = 2; i < maxN; i++) {\n        fact[i] = mult(fact[i - 1], i);\n        inv[i] = mult(inv[mod % i], mod - mod / i);\n        invfact[i] = mult(invfact[i - 1], inv[i]);\n    }\n    int total = cnk(3 * m + n - 1, n - 1);\n    int coef = mult(n, cnk(3 * m - 2 * m - 1 + n - 1, n - 1));\n    total = sub(total, coef);\n    int add = 0;\n    for (int coef = 0; coef < m; coef++) {\n        int odd = 3 * m - 2 * coef;\n        add = sum(add, mult(cnk(n, odd), cnk(coef + n - 1, n - 1)));\n    }\n    total = sub(total, add);\n    cout << total;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\nconst ll mod = 998244353;\nll inv[2000000];\nll FactorialInv[2000000];\nll Factorial[2000000];\nll beki(ll a, ll b){\n    if(b == 0){\n        return 1;\n    }\n    ll ans = beki(a, b / 2);\n    ans = ans * ans % mod;\n    if(b % 2 == 1){\n        ans = ans * a % mod;\n    }\n    return ans;\n}\nvoid init_combination(){\n    inv[1] = 1;\n    FactorialInv[1] = 1;\n    Factorial[1] = 1;\n    Factorial[0] = 1;\n    FactorialInv[0] = 1;\n    inv[0] = 1;\n    for(int i = 2; i < 2000000; i++){\n        inv[i] = beki(i, mod - 2);\n        Factorial[i] = Factorial[i - 1] * i % mod;\n        FactorialInv[i] = FactorialInv[i - 1] * inv[i] % mod;\n    }\n}\nll combination(ll a, ll b){\n    if((a == b) || (b == 0)){\n        return 1;\n    }\n    if(a < b) return 0;\n    ll ans = Factorial[a] * FactorialInv[b] % mod;\n    ans = ans * FactorialInv[a - b] % mod;\n    return ans;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nll N, M;\nll ans = 0;\n\nint main() {\n    cin >> N >> M;\n    init_combination();\n    ll over = 0;\n    for(ll two = M; two <= M + M / 2; two++) {\n        ll one = M - (two - M) * 2;\n        ll total = combination(N + two - 1, N - 1);\n        ll just = N * combination(two - M + N - 2, N - 2);\n        just %= mod;\n        ll nowway = total - just - over + 2 * mod;\n        nowway %= mod;\n        ans += nowway * combination(N, one);\n        ans %= mod;\n        ans += just * combination(N - 1, one);\n        ans %= mod;\n        over += just;\n        over %= mod;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define REP(i, n) for(int i = 0;i < (n);i++)\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=998244353;\nconst llint inf=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-10;\ntemplate <class T,class U>bool chmin(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool chmax(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n#include <algorithm>\n#include <utility>\n#include <type_traits>\n#include <cstdint>\n//永夜作\n#define mnt mint_base\nclass mint_base;\n//mint_base_base型用の累乗関数\nconstexpr mint_base m_pow(mint_base x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\nclass mint_base\n{\npublic:\n\tconstexpr mint_base operator+(const mint_base &other)const noexcept\n\t{auto v = *this;return v += other;}\n\tconstexpr mint_base operator-(const mint_base &other)const noexcept\n\t{auto v = *this;return v -= other;}\n\tconstexpr mint_base operator*(const mint_base &other)const noexcept\n\t{auto v = *this;return v *= other;}\n\tconstexpr auto operator/(const mint_base &other)const noexcept\n\t{auto v = *this;return v /= other;}\n\tconstexpr mint_base & operator+=(const mint_base &other) noexcept\n\t{a += other.a;if (mod <= a) { a -= mod; };return *this;}\n\tconstexpr mint_base & operator-=(const mint_base &other) noexcept\n\t{if (a >= other.a) {a -= other.a;}else {a = (a + mod) - other.a;}return *this;}\n\tconstexpr mint_base & operator*=(const mint_base &other) noexcept\n\t{a *= other.a;a %= mod;return *this;}\n\tconstexpr mint_base & operator/=(const mint_base &other) noexcept\n\t{return *this *= ~other;}\n\tconstexpr mint_base operator+()const noexcept { return *this; }\n\tconstexpr mint_base operator-()const noexcept\n\t{return{ mod - a, mod_value_tag{} };}\n\tconstexpr mint_base & operator++() noexcept\n\t{if (mod <= ++a) { a = 0; };return *this;}\n\tconstexpr mint_base & operator--() noexcept\n\t{if (a <= 0) { a = mod; };--a;return *this;}\n\tconstexpr mint_base operator++(int) noexcept\n\t{auto tmp = *this;++*this;return tmp;}\n\tconstexpr mint_base operator--(int) noexcept\n\t{auto tmp = *this;--*this;return tmp;}\n\tconstexpr mint_base operator~()const noexcept\n\t{return m_pow(*this, mod-2);}\n\tconstexpr mint_base & operator=(const mint_base &other) noexcept\n\t{a=other.a;return *this;}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{return a;}\n\tconstexpr explicit operator int()const noexcept\n\t{return a;}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{return (unsigned)a;}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{return mod;}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_ % mod) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tuint64_t a;\n};\n\n//mint_base型用の累乗関数\nconstexpr mint_base m_pow(mint_base x,uint64_t n)noexcept\n{\n\tmint_base res = 1;\n\twhile(n>0){\n\t\tif(n&1){res*=x;}\n\t\tx*=x;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\nvector<mint_base> fla;//階乗が入る\nvoid fla_set(mint_base x)\n{\n\tfla.resize(((uint64_t)x)+1);\n\tfla[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x;i++){fla[i]=fla[i-1]*i;}\n}\nvector<mint_base> gya;//~fla[i] が入る\n\n//O(x+log mod)で求める O(xlogmod)より速い\nvoid fla_gya_set(mint_base x)\n{\n\tfla_set(x);\n\tgya.resize(((uint64_t)x)+1);\n\tgya[(uint64_t)x]=~fla[(uint64_t)x];\n\tfor(uint64_t i =(uint64_t)x;i>0;i--){gya[i-1]=gya[i]*i;}\n}\n\n//mint_base型のstreamへの出力\nstd::ostream& operator<<(std::ostream& os, mint_base i)\n{os<<(uint64_t)i;return os;}\n//mint_base型のstreamからの入力\nstd::istream& operator >> (std::istream& is, mint_base& i)\n{uint64_t tmp;is>>tmp;i=tmp;return is;}\n\nint main(void){\n\tcout<<fixed<<setprecision(20);\n\tcin.tie(0);ios::sync_with_stdio(false);\n\t//まず「全事象」を数える\n\t\n\tint i,j,n,m;cin>>n>>m;\n\tfla_gya_set(n+m*3+1);\n\tmnt ans=fla[m*3+n-1]*gya[m*3]*gya[n-1];\n\t//cerr<<ans<<endl;\n\tfor(i=m+m+1;i<=m+m+m;i++){ans-=fla[m*3-i+n-2]*gya[m*3-i]*gya[n-2]*((mnt)n);}\n\t//cerr<<ans<<endl;\n\tfor(i=m+2;i<=min(n,m+m+m);i+=2){\n\t\tans-=fla[n]*gya[i]*gya[n-i]*fla[(m*3-i)/2+n-1]*gya[(m*3-i)/2]*gya[n-1];\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define srep(i,s,t) for(int i = s; i < t; ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n#define MAX_N 200005\n\nconst int MAX = 3100000;\nconst int MOD = 998244353;\nlong long fac[MAX], finv[MAX], inv[MAX];\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nlong long FINV(int n){\n    if (n < 0) return 0;\n    return finv[n];\n}\nll sum[MAX];\n// ax + by = gcd(a, b) となるような (x, y) を求める\n// a と b は互いに素として ax + by = 1 となる (x, y) を求める\nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a%b, y, x); // 再帰\n    y -= a / b * x;\n    return d;\n}\n\n\n// 負の数に対応した mod\ninline long long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n\n\n// 逆元計算 (a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m) {\n    long long x, y;\n    extGCD(a, m, x, y);\n    return mod(x, m); // x % m だが、x が負かもしれないので\n}\nint main() {\n    COMinit();\n    ll n, m;\n    cin >> n >> m;\n\n    ll ans = 0;\n\n    sum[0] = 1;\n    ll now = 1;\n    srep(i,1,MAX){\n        now = now * (n-2+i) % MOD * modinv(i,MOD) % MOD;\n        sum[i] = sum[i-1] + now;\n        sum[i] %= MOD;\n    }\n\n    int min_nm = min(n,m);\n\n    rep(i,min_nm+1){ // 奇数の数\n        if((3*m-i)%2==1) continue;\n        ll num = (3*m-i)/2;\n        ll tmp = COM(num+n-1,num) * COM(n,i) % MOD;\n        ll tmp1 = 0;\n        if(num-(m+1) >= 0) tmp1 = sum[num-(m+1)];\n        tmp1 = tmp1 * COM(n-1,i) % MOD * n % MOD;\n        ll tmp2 = 0;\n        if(num-m >= 0) tmp2 = sum[num-m];\n        tmp2 = tmp2 * COM(n-1,i-1) % MOD * n % MOD;\n        tmp = tmp + MOD - tmp1 + MOD - tmp2;\n        tmp %= MOD;\n        ans += tmp;\n        ans %= MOD;\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nint powmod(int a, int n, int mod) {\n\tif (n == 0) return 1;\n\tif (n % 2 == 0) return powmod((a * a) % mod, n / 2, mod);\n\treturn (a * powmod(a, n - 1, mod)) % mod;\n}\n\nconst int MAX = 2600000;\nint mod = 998244353;\nint n, m;\nint fact[MAX];\nint factInv[MAX];\n\nvoid initFact() {\n\tint i;\n\t\n\tfact[0] = 1;\n\tfactInv[0] = 1;\n\tfor (i = 1; i <= 3 * m + n; i++) {\n\t\tfact[i] = (i * fact[i - 1]) % mod;\n\t\tfactInv[i] = powmod(fact[i], mod - 2, mod);\n\t}\n}\n\nint comb(int n, int k) {\n\tif (k > n) return 0;\n\treturn fact[n] * factInv[n - k] % mod * factInv[k] % mod;\n}\n\nsigned main() {\n\tcin >> n >> m;\n\tinitFact();\n\t\n\tint x;\n\tint ng = 0;\n\tfor (x = 2 * m + 1; x <= 3 * m; x++) {\n\t\tint res = n * comb(3 * m - x + n - 2, n - 2) % mod;\n\t\tng += res;\n\t\tng %= mod;\n\t}\n\t\n\t//奇数がx個\n\tfor (x = m + 1; x <= n; x++) {\n\t\tif (x > 3 * m) break;\n\t\tif ((3 * m - x) % 2 != 0) continue;\n\t\tint res = comb((3 * m - x) / 2 + n - 1, n - 1) * comb(n, x) % mod;\n\t\tng += res;\n\t\tng %= mod;\n\t}\n\t\n\tint all = comb(3 * m + n - 1, n - 1);\n\tint ans = (all - ng + mod) % mod;\n\t\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ll = long long;\nusing vi = vector<ll>;\nusing vvi = vector<vi>;\nusing pi = pair<ll, ll>;\nusing vpi = vector<pi>;\nconst ll mod = 998244353;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int maxn = 4000000;\nll n, m, fact[maxn + 300], inv[maxn + 300];\nll bp(ll a, ll p) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1)\n\t\t\tres = (res * a) % mod;\n\t\ta = (a * a) % mod;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\nvoid setup() {\n\tfact[0] = 1;\n\tfor (int i = 1; i <= maxn; i++)\n\t\tfact[i] = (fact[i - 1] * i) % mod;\n\tinv[maxn] = bp(fact[maxn], mod - 2);\n\tfor (int i = maxn; i--;)\n\t\tinv[i] = (inv[i + 1] * (i + 1)) % mod;\n}\nll nck(ll n, ll k) {\n\tll t = (fact[n] * inv[n - k]) % mod;\n\treturn (t * inv[k]) % mod;\n}\nll solve(ll S, ll N) {\n\treturn nck(S + N - 1, N - 1);\n}\n#define M(x) ((x)%mod)\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tsetup();\n\tcin >> n >> m;\n\tll ans = 0;\n\tfor (int odd = 0; odd <= min(n, m); odd++) {\n\t\tif ((3 * m - odd) % 2 == 0)\n\t\t\tans = (ans + solve((3 * m - odd) / 2, n) * nck(n, odd)) % mod;\n\t}\n\tfor (int odd = 0; odd <= min(n, m); odd++) {\n\t\tif ((m - odd) % 2 == 0)\n\t\t\tans = (mod + ans - M(n*M((solve((m - odd) / 2, n) * nck(n, odd))))%mod) % mod;\n\t}\n\tfor (int odd = 0; odd <= min(n-1, m); odd++) {\n\t\tif ((m - odd) % 2 == 0)\n\t\t\tans = (ans + M(n*M(solve((m - odd) / 2, n-1) * nck(n-1, odd)))) % mod;\n\t}\n\tcout << ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define inver(a) power(a, mod - 2)\n#define F(x, y) C(x - 1 + y, y)\nusing namespace std;\ninline char nc()\n{\n    return getchar();\n\tstatic char buf[100000], *l = buf, *r = buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void read(T &x)\n{\n\tx = 0; int f = 1, ch = nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx *= f;\n}\ntypedef long long ll;\nconst int mod = 998244353;\nconst int maxn = 2000050;\nint n, m;\nint fac[maxn];\nint fac_inv[maxn];\ninline int dec(int x) {return x < 0 ? x + mod : x;}\ninline ll C(int x, int y)\n{\n    return (ll)fac[x] * fac_inv[y] % mod * fac_inv[x - y] % mod;\n}\nll power(ll x, ll y)\n{\n    ll re = 1;\n    while(y)\n    {\n        if(y & 1) re = re * x % mod;\n        x = x * x % mod;\n        y >>= 1;\n    }\n    return re;\n}\nvoid init(int n)\n{\n    fac[0] = 1;\n    for(int i = 1; i <= n; ++i)\n    {\n        fac[i] = (ll)fac[i - 1] * i % mod;\n    }\n    fac_inv[n] = inver(fac[n]);\n    for(int i = n; i >= 1; --i)\n    {\n        fac_inv[i - 1] = (ll)fac_inv[i] * i % mod;\n    }\n}\nint cal(int x, int y)\n{\n    int re = F(n, x);\n    re = dec(re - y * F(n, x - m) % mod);\n    if(x > m) re = dec(re - (n - y) * F(n, x - m - 1) % mod);\n    return re;\n}\nint solve()\n{\n    int an = 0;\n    for(int i = 0; i <= min(m, n); ++i)\n    {\n        if((3 * m - i) & 1) continue;\n        an = (an + cal((3 * m - i) >> 1, i) * C(n, i)) % mod;\n    }\n    return an;\n}\nint main()\n{\n    read(n), read(m);\n    init(n + (m << 1));\n    printf(\"%d\\n\", solve());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define rrep(i,a,b) for(int i=(a);i>=(b);--i)\n#define MP make_pair\n#define PB push_back\ntypedef long long LL;\nconst LL MOD = 998244353;\nconst int N = 2.5e6+10;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint n,m;\nLL fac[N],ifac[N];\n\nLL pw(LL x,int n){\n\tLL res = 1;\n\tfor(;n;n>>=1,x=x*x%MOD)if(n&1)res=res*x%MOD;\n\treturn res;\n}\n\nLL C(int n,int x){\n\treturn fac[n] * ifac[x] % MOD * ifac[n-x] % MOD;\n}\n\nint main(){\n\t//freopen(\"test.in\",\"r\",stdin);\n\tcin>>n>>m;\n\tfac[0] = 1;\n\trep(i,1,N-1)fac[i]=fac[i-1]*i%MOD;\n\tifac[N-1] = pw(fac[N-1],MOD-2);\n\trrep(i,N-2,0)ifac[i]=ifac[i+1]*(i+1)%MOD;\n\t//cout<<fac[1]*ifac[1]%MOD<<\" \"<<fac[2]*ifac[2]%MOD<<\" \"<<fac[3]*ifac[3]%MOD<<endl;\n\tint s = 3*m;\n\tLL num = C(s+n-1,n-1);\n\tLL sub1 = n * C(n+m-2, n-1) % MOD, sub2 = 0;\n\tfor(int i=m+2;i<=min(3*m,n);i+=2){\n\t\tint s1 = (s-i)/2;\n\t\tsub2 = (sub2 + C(n, i) * C(s1+n-1, n-1)) % MOD;\n\t}\n\tcout<<num<<\" \"<<sub1<<\" \"<<sub2<<endl;\n\tcout<<(num - sub1 - sub2 + MOD * 2) % MOD<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 998244353;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = a*b % MOD;\n}\n\nvector<int64_t> fact, seq_inv, fact_inv;\n\nvoid create_fact_mod(int num){\n    fact[0] = 1;\n    fact[1] = 1;\n    for(int i=2; i<=num; i++){\n        fact[i] = fact[i-1] * i % MOD;\n    }\n}\n\nvoid create_seq_inv_mod(int num){\n    seq_inv[0] = 1;\n    seq_inv[1] = 1;\n    for(int i=2; i<=num; i++){\n        seq_inv[i] = (MOD - MOD/i) * seq_inv[MOD%i] % MOD;\n    }\n}\n\nvoid create_fact_inv_mod(int num){\n    fact_inv[0] = 1;\n    fact_inv[1] = 1;\n    for(int i=2; i<=num; i++){\n        fact_inv[i] = fact_inv[i-1] * seq_inv[i] % MOD;\n    }\n}\n\nvoid create_mod_tables(int num){\n    fact.resize(num+1);\n    seq_inv.resize(num+1);\n    fact_inv.resize(num+1);\n    create_fact_mod(num);\n    create_seq_inv_mod(num);\n    create_fact_inv_mod(num);\n}\n\nint64_t comb_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD * fact_inv[k] % MOD;\n}\n\nint64_t perm_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD;\n}\n\nint64_t power_mod(int64_t num, int64_t power){\n    int64_t prod = 1;\n    num %= MOD;\n    while(power > 0){\n        if(power&1) prod = prod * num % MOD;\n        num = num * num % MOD;\n        power >>= 1;\n    }\n    return prod;\n}\n\nint64_t extgcd(int64_t a, int64_t b, int64_t& x, int64_t& y){\n    int64_t d = a;\n    if(b != 0){\n        d = extgcd(b, a%b, y, x);\n        y -= (a/b) * x;\n    }else{\n        x = 1; y = 0;\n    }\n    return d;\n}\n\nint64_t inv_mod(int64_t a){\n    int64_t x, y;\n    extgcd(a, MOD, x, y);\n    return (MOD + x%MOD) % MOD;\n}\n\nint main(){\n    int N, M;\n    cin >> N >> M;\n\n    create_mod_tables(4e6);\n\n    int64_t ans = comb_mod(3*M+N-1, N-1);\n    for(int i=2*M+1; i<=3*M; i++){\n        add(ans, MOD - comb_mod(3*M-i+N-2, N-2) * N % MOD);\n    }\n\n    for(int k=M+1; k<=N; k++){\n        if(3*M-k < 0) break;\n        if((3*M-k)%2) continue;\n        int64_t res = comb_mod(N, k);\n        int p = (3*M-k)/2;\n        mul(res, comb_mod(p+N-1, N-1));\n        add(ans, MOD - res);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define st first\n#define nd second\n#define mp make_pair\n#define pb push_back\n#define sol (k+k)\n#define sag (k+k+1)\n#define orta ((bas+son)/2)\n#define coc g[node][i]\n#define mod 998244353\n#define inf 1000000009\n#define N 5000005\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair < ll , ll > ii;\n\nll n, m, ans, k, top, fak[N];\n\nll fe(ll a, ll us){\n\tif(us <= 1)\n\t\treturn (us)?a:1ll;\n\tll t = fe(a, us/2);\n\treturn (us&1)?(t*t%mod)*a%mod : t*t%mod;\n}\n\nll C(ll a, ll b){\n\t// cout << a << \" \" << b << \" \" << endl;\n\treturn fak[a]*fe(fak[b]*fak[a - b]%mod,mod-2)%mod;\n}\n\nll dagit(ll n, ll a){\n\tif(a < 0)\n\t\treturn 0;\n\treturn C(a + n - 1, n - 1);\n}\n\nint main() {\n\t// freopen(\"in.txt\", \"r\", stdin);\n\t// freopen(\"out.txt\", \"w\", stdout);\n\tfak[0] = 1;\n\tfor(ll i = 1; i < N; i++)\n\t\tfak[i] = fak[i - 1]*i%mod;\n\tscanf(\"%lld %lld\",&n ,&m);\n\tk = 2*m;\n\ttop = 3*m;\n\t// cout << dagit(top) << endl;\n\t// cout << dagit(m - 1) << endl;\n\t// cout << dagit(n, m)*dagit(n - 1, m)%mod << endl;;\n\tans = (dagit(n, top) - n*dagit(n, m - 1)%mod + mod)%mod;\n\t// for(int i = m + 1; i <= m+m; i++){\n\t// \tans = (ans - (dagit(n - i, top) - (n - i)*dagit(n - i, m - 1)%mod + mod)%mod + mod)%mod;\n\t// }\n\tif(n > m)\n\t\tassert(0);\n\tprintf(\"%lld\\n\", ans );\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MOD = 998244353;\n\nlong long fact[1500005];\n\nlong long powmod(long long a, long long b){\n    long long x = 1;\n    long long y = a;\n    while(b){\n        if(b&1){ x = (x*y)%MOD; }\n        y = (y*y)%MOD;\n        b >>= 1;\n    }\n    return x;\n}\n\ninline long long ncr(long long a, long long b){\n    return fact[a]*powmod((fact[a-b]*fact[b])%MOD, MOD-2)%MOD;\n}\n\nlong long solve(int N, int sum, int k){\n    // exactly N non-negative integers\n    // the sum is the variable sum\n    // exactly k odd\n    if((sum-k)&1){return 0;}\n\n    // Let's make the k odd integers non-negative even integers\n    // Then, the sum becomes (sum-k) and we can then divide by 2 to normalise the non-negative integers\n    // The integers can now be any non-negative integer, without any other restriction, so formula can be used.\n    // (((sum-k)/2)+(N-1)) choose (N-1) ways to make such integers\n\n    // Don't forget that there are N choose k ways to arrange the odd integers.\n    return ncr(N, k)*ncr( ((sum-k)>>1)+(N-1) , N-1)%MOD;\n}\n\nint main(){\n    int N, M;\n    scanf(\"%d%d\", &N, &M);\n\n    fact[0] = 1;\n    for(int i = 1; i <= 1500004; i ++){\n        fact[i] = (fact[i-1]*i)%MOD;\n    }\n\n    // Let us ignore the maximum integer rule and count the number of ways\n    // There can only be at most M odd integers.\n    long long temp1 = 0;\n    for(int k = 0; k <= min(M, N); k ++){\n        temp1 += solve(N, 3*M, k);\n        //printf(\"solve(%d, %d, %d)=%lld\\n\", N, 3*M, k, solve(N, 3*M, k));\n    }\n    temp1 %= MOD;\n\n    // Notice that the maximum integer cannot exceed 2M. There can only be a maximum of one violation\n    // because 2M+2M = 4M > 3M, a contradiction. Hence, there are N ways to choose the violating integer.\n    // Then, we can subtract 2M from the offending integer. 2M is even, hence there is no effect on parity.\n    // Conditions remain the same as before, except that the offending integer must be positive.\n    long long temp2 = 0;\n    for(int k = 0; k <= min(M, N); k ++){\n        temp2 += solve(N, M, k);\n    }\n    temp2 %= MOD;\n    temp2=temp2*N%MOD;\n\n    // Now, we count number of ways such that the offending integer is 0 because we have over-subtracted those cases.\n    // There are only N-1 integers left since the offending integer can be removed, and that the number of odd\n    // integers would remain the same since M is even.\n    long long temp3 = 0;\n    for(int k = 0; k <= min(M, N-1); k ++){\n        temp3 += solve(N-1, M, k);\n    }\n    temp3 %= MOD;\n    temp3=temp3*N%MOD;\n\n    //printf(\"temp1=%lld temp2=%lld temp3=%lld\\n\", temp1, temp2, temp3);\n\n    long long ans = (temp1-temp2+temp3+MOD*3)%MOD;\n    printf(\"%lld\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef bool boolean;\n\n#define ll long long\n\nvoid exgcd(int a, int b, int& x, int& y) {\n\tif (!b) {\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, y, x);\n\t\ty -= (a / b) * x;\n\t}\n}\n\nint inv(int a, int n) {\n\tint x, y;\n\texgcd(a, n, x, y);\n\treturn (x < 0) ? (x + n) : (x);\n}\n\nconst int Mod = 998244353;\n\ntemplate <const int Mod = :: Mod>\nclass Z {\n\tpublic:\n\t\tint v;\n\n\t\tZ() : v(0) {\t}\n\t\tZ(int x) : v(x){\t}\n\t\tZ(ll x) : v(x % Mod) {\t}\n\n\t\tfriend Z operator + (const Z& a, const Z& b) {\n\t\t\tint x;\n\t\t\treturn Z(((x = a.v + b.v) >= Mod) ? (x - Mod) : (x));\n\t\t}\n\t\tfriend Z operator - (const Z& a, const Z& b) {\n\t\t\tint x;\n\t\t\treturn Z(((x = a.v - b.v) < 0) ? (x + Mod) : (x));\n\t\t}\n\t\tfriend Z operator * (const Z& a, const Z& b) {\n\t\t\treturn Z(a.v * 1ll * b.v);\n\t\t}\n\t\tfriend Z operator ~(const Z& a) {\n\t\t\treturn inv(a.v, Mod);\n\t\t}\n\t\tfriend Z operator - (const Z& a) {\n\t\t\treturn Z(0) - a;\n\t\t}\n\t\tZ& operator += (Z b) {\n\t\t\treturn *this = *this + b;\n\t\t}\n\t\tZ& operator -= (Z b) {\n\t\t\treturn *this = *this - b;\n\t\t}\n\t\tZ& operator *= (Z b) {\n\t\t\treturn *this = *this * b;\n\t\t}\n\t\tfriend boolean operator == (const Z& a, const Z& b) {\n\t\t\treturn a.v == b.v;\n\t\t} \n};\n\nZ<> qpow(Z<> a, int p) {\n\tZ<> rt = Z<>(1), pa = a;\n\tfor ( ; p; p >>= 1, pa = pa * pa) {\n\t\tif (p & 1) {\n\t\t\trt = rt * pa;\n\t\t}\n\t}\n\treturn rt;\n}\n\ntypedef Z<> Zi;\n\nconst int N = 3e6 + 5;\n\nint n, m;\nZi fac[N], _fac[N];\n\nvoid prepare(int n) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfac[i] = fac[i - 1] * i;\n\t_fac[n] = ~fac[n];\n\tfor (int i = n; i; i--)\n\t\t_fac[i - 1] = _fac[i] * i;\n}\nZi comb(int n, int m) {\n\treturn (n < m) ? (0) : (fac[n] * _fac[m] * _fac[n - m]);\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tprepare(3 * m + n - 1);\n\tZi ans = comb(3 * m + n - 1, n - 1) - comb(m + n - 2, n - 1) * n;\n\tfor (int num = m + 1; num <= n && num <= 3 * m; num++) {\n\t\tif ((3 * m - num) & 1)\n\t\t\tcontinue;\n\t\tint sum = (3 * m - num) >> 1;\n\t\tZi tmp = comb(sum + n - 1, n - 1);\n\t\t// mx is odd\n\t\ttmp -= num * comb(sum - m + n - 1, n - 1);\n\t\t// mx is even\n\t\ttmp -= (n - num) * comb(sum - m + n - 2, n - 1);\n\t\ttmp *= comb(n, num);\n\t\tans -= tmp;\n\t}\n\tprintf(\"%d\\n\", ans.v);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <tuple>\n#include <vector>\nusing ll = int64_t;\nclass range {private: struct I{int x;int operator*(){return x;}bool operator!=(I& lhs){return x<lhs.x;}void operator++(){++x;}};I i,n;\npublic:range(int n):i({0}),n({n}){}range(int i,int n):i({i}),n({n}){}I& begin(){return i;}I& end(){return n;}};\nusing namespace std;\nconstexpr int mod = 998244353;\n\n// Modulo calculus\n\n// With Montgomery multiply\n// Mod < 2^32, odd number\nconstexpr int ceil_log2(int x) {\n  int y = 0;\n  while (x) {\n    ++y;\n    x /= 2;\n  }\n  return y;\n}\n\nconstexpr int calc_np(const int Mod, const int R) {\n  int res = 0;\n  int t = 0;\n  int r = R;\n  int i = 1;\n  while (r > 1) {\n    if ((t % 2) == 0) {\n      t += Mod;\n      res += i;\n    }\n    t /= 2;\n    r /= 2;\n    i *= 2;\n  }\n  return res;\n}\n\ntemplate <int Mod>\nclass ModIntMR {\n public:\n  explicit constexpr ModIntMR(const int x) : data(reduction(static_cast<ll>(x) * R2)) {}\n  ModIntMR<Mod>& operator=(const ModIntMR<Mod>& that) {\n    data = that.data;\n    return *this;\n  }\n  explicit operator int() const { return reduction(data); }\n  ModIntMR<Mod>& operator+=(const ModIntMR<Mod>& that) {\n    data += that.data;\n    if (data >= Mod) data -= Mod;\n    return *this;\n  }\n  ModIntMR<Mod>& operator-=(const ModIntMR<Mod>& that) {\n    data -= that.data;\n    if (data < 0) data += Mod;\n    return *this;\n  }\n  ModIntMR<Mod>& operator*=(const ModIntMR<Mod>& that) {\n    data = reduction(static_cast<ll>(data) * that.data);\n    return *this;\n  }\n  friend ModIntMR<Mod> operator+(ModIntMR<Mod> lhs, const ModIntMR<Mod>& rhs) {\n    lhs += rhs;\n    return lhs;\n  }\n  friend ModIntMR<Mod> operator-(ModIntMR<Mod> lhs, const ModIntMR<Mod>& rhs) {\n    lhs -= rhs;\n    return lhs;\n  }\n  friend ModIntMR<Mod> operator*(ModIntMR<Mod> lhs, const ModIntMR<Mod>& rhs) {\n    lhs *= rhs;\n    return lhs;\n  }\n  friend ModIntMR<Mod> operator^(ModIntMR<Mod> lhs, const ll rhs) {\n    if (rhs == 0) return ModIntMR<Mod>(1);\n    else if ((rhs % 2) == 1) return (lhs ^ (rhs-1)) * lhs;\n    else {\n      const auto half = lhs ^ (rhs / 2);\n      return half * half;\n    }\n  }\n  ModIntMR<Mod>& operator^=(const ll that) {\n    data = (*this ^ that).data;\n    return *this;\n  }\n private:\n  int data;\n  static constexpr int shift = ceil_log2(Mod);\n  static constexpr int R = 1 << shift;\n  static constexpr int mask = R-1;\n  static constexpr int R2 = static_cast<ll>(R)*R%Mod;\n  static constexpr int Np = calc_np(Mod, R);\n  static constexpr int reduction(const ll T) {\n    int t = (T + ((T*Np)&mask)*Mod)>>shift;\n    return t >= Mod ? t - Mod : t;\n  }\n};\n\nusing modint = ModIntMR<mod>;\n\nll inv(ll a,ll p){\n  return ( a == 1 ? 1 : (1 - p*inv(p%a,a)) / a + p );\n}\n\nvector<modint> fact(2500001, modint(0));\nvector<modint> factinv(2500001, modint(0));\n\nmodint comb(int n, int k) {\n  const auto tmp = fact[n] * factinv[k];\n  return tmp * factinv[n-k];\n}\n \nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n,m;\n  cin>>n>>m;\n  ll mx = 3*m+n;\n  fact[0] = modint(1);\n  for (int i : range(mx)) {\n    fact[i+1] = fact[i] * modint(i+1);\n  }\n  factinv[mx] = modint(inv(static_cast<int>(fact[mx]), mod));\n  for (int i = mx; i > 0; --i) {\n    factinv[i-1] = factinv[i] * modint(i);\n  }\n  modint tmp = comb(3*m+n-1, n-1);\n  modint sub(0);\n  for (int i = 2*m+1; i <= 3*m; ++i) {\n    sub += comb(3*m-i+n-2, n-2);\n  }\n  sub *= modint(n);\n  modint mno(0);\n  for (int i = m+1; i <= n; ++i) {\n    ll rem = 3*m-i;\n    if (rem < 0 || (rem%2) == 1) continue;\n    mno += comb(rem/2+n-1, n-1) * comb(n, i);\n  }\n  modint res = tmp - sub - mno;\n  cout << static_cast<int>(res) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 3e6 + 5;\nconst int P = 998244353;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nint fac[MAXN], inv[MAXN];\nint power(int x, int y) {\n\tif (y == 0) return 1;\n\tint tmp = power(x, y / 2);\n\tif (y % 2 == 0) return 1ll * tmp * tmp % P;\n\telse return 1ll * tmp * tmp % P * x % P;\n}\nint binom(int x, int y) {\n\tif (y > x) return 0;\n\telse return 1ll * fac[x] * inv[y] % P * inv[x - y] % P;\n}\nvoid init(int n) {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfac[i] = 1ll * fac[i - 1] * i % P;\n\tinv[n] = power(fac[n], P - 2);\n\tfor (int i = n - 1; i >= 0; i--)\n\t\tinv[i] = inv[i + 1] * (i + 1ll) % P;\n}\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nint main() {\n\tint n, m, ans = 0;\n\tread(n), read(m);\n\tinit(n + 3 * m);\n\tint s = 3 * m;\n\tfor (int i = 0; i <= m && i <= n; i++) {\n\t\tif ((s - i) & 1) continue;\n\t\tint tmp = (s - i) / 2;\n\t\tupdate(ans, 1ll * binom(n, i) * binom(tmp + n - 1, n - 1) % P);\n\t}\n\ts -= 2 * m;\n\tfor (int i = 0; i <= m && i <= n; i++) {\n\t\tif ((s - i) & 1) continue;\n\t\tint tmp = (s - i) / 2;\n\t\tif (i != 0) update(ans, P - 1ll * n * binom(n - 1, i - 1) % P * binom(tmp + n - 1, n - 1) % P);\n\t\tif (tmp != 0) update(ans, P - 1ll * n * binom(n - 1, i) % P * binom(tmp + n - 2, n - 1) % P);\n\t}\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstdlib>\n#include<map>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<stack>\n#include<math.h>\n#include<queue>\n#include<complex>\nusing namespace std;\n\nconst long long int INF=99999999999999,inf=199999;\nconst long long int mod=998244353;\n\n\n//aからbまでの積を求める(mod)\n\n//階乗先に計算\nlong long int kaizyou[4000005] = { 1 };\nlong long int kai(long long int a, long long int b, long long int mod) {\n\tlong long int tmp = 1;\n\tfor (long long int i = a; i <= b; i++) {\n\t\ttmp *= i;\n\t\ttmp %= mod;\n\n\t\tkaizyou[i] = tmp;\n\t}\n\treturn tmp;\n}\n\n\n//累乗(繰り返し2乗法)　aのb乗(mod)を求める。\nlong long int rui(long long int a, long long int b, long long mod) {\n\tint memo[65] = {};\n\tlong long int A[65] = {};\n\tlong long int tmp = 1;\n\tfor (int i = 0; i < 65; i++) {\n\t\tmemo[i] = b % 2;\n\t\tb /= 2;\n\t}\n\n\tA[0] = a;\n\tA[0] %= mod;\n\n\tfor (int i = 1; i < 65; i++) {\n\t\tA[i] = A[i - 1] * A[i - 1];\n\t\tA[i] %= mod;\n\t}\n\tfor (int i = 0; i < 65; i++) {\n\t\tif (memo[i] == 1) {\n\t\t\ttmp *= A[i];\n\t\t\ttmp %= mod;\n\t\t}\n\t}\n\ttmp %= mod;\n\treturn tmp;\n}\n\n//コンビネーション計算\nlong long int comb(long long int n, long long int r, long long int mod) {\n\tlong long int tmp;\n\n\ttmp = (kaizyou[n] * rui(kaizyou[r], mod - 2, mod)) % mod;\n\ttmp *= rui(kaizyou[n - r], mod - 2, mod);\n\ttmp %= mod;\n\tif (tmp < 0) { tmp = (mod - tmp) % mod; }\n\treturn tmp;\n}\n\n\nlong long int n,m,k,a,b,c,d,count=0,res=0,tmp;\nint main() {\n    int count=0;\n    map<long long int,long long int>mp;\n\tcout << fixed << setprecision(10);\n    cin>>n>>m;\n    kai(1,4000001,mod);\n    res=comb(n+3*m-1,n-1,mod);\n    //cout<<res<<endl;\n    res=res+mod-((n)*comb(n+m-2,n-1,mod))%mod;\n    res%=mod;\n    //cout<<res<<endl;\n    for(int i=m+1;i<=min(3*m,n);i++){\n        if((3*m-i)%2==1){continue;}\n        //n個中m個が0でn-m個が1\n        tmp=comb(n,i,mod)*comb((3*m-i)/2+n-1,n-1,mod);\n        tmp%=mod;\n        res=(mod+res-tmp)%mod;\n    }\n    cout<<res;\n} \n"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n//#pragme GCC target(\"avx2\");\n#pragma GCC target(\"avx,avx2,fma\")\n//#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")\n\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//#define int long long\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define pb push_back\n#define f first\n#define se second\n#define pll pair<ll, ll>\n#define pii pair<int, int>\n\nusing namespace std;\n//using namespace __gnu_pbds;\n\n/*\n\tst.insert(k);\n\tst.find_by_order(k); iterator on k-th from 0\n\tst.order_of_key(k); strictly more than k\n*/\n\n//typedef\n//tree<\n//  ll,\n//  null_type,\n//  less_equal<ll>,\n//  rb_tree_tag,\n//  tree_order_statistics_node_update>\n//ordered_set;\n\n\nconst int N = 4e5 + 19;\nconst int M = 2e6 + 19;\nconst int\n mod = 998244353;\nconst int inf = 2e9;\nconst int blocksz = 300;\nconst ll INF = 1e18;\n\n\ninline int modulo(int x) {x %= mod; return (x + mod) % mod; }\ninline int mult(int x, int y) { ll x1 = modulo(x), y1 = modulo(y); return (x1 * y1) % (ll)mod; }\ninline void add(int &x, int y) { x = modulo(x + y); }\ninline void Max(int &x, int y) { x = max(x, y); }\ninline void Min(int &x, int y) { x = min(x, y); }\n\n\nint n, m, ans = 0, fact[M];\n\n\nint pw(int x, int y) {\n\tint cur = 1, pwx = x;\n\tfor (int i = 0; i < 30; i++) {\n\t\tif (y & 1)\n\t\t\tcur = mult(cur, pwx);\n\t\tpwx = mult(pwx, pwx);\n\t\ty = (y >> 1);\n\t}\n\treturn cur;\n}\n\n\ninline int C(int n, int k) {\n\tif (n < k)\n\t\treturn 0;\n\tint t1, t2, t3;\n\tt1 = fact[n];\n\tt2 = pw(fact[k], mod - 2);\n\tt3 = pw(fact[n - k], mod - 2);\n\treturn mult(t1, mult(t2, t3));\n}\n\n\ninline int F(int n, int m, int i) {\n\tif ((m - i) % 2)\n\t\treturn 0;\n\treturn mult(C(n, i), C((m - i) / 2 + n - 1, n - 1));\n}\n\n\ninline int G(int n, int m, int i) {\n\treturn mult(n, modulo(F(n, m, i) - F(n - 1, m, i)));\n}\n\n\nvoid precalc() {\n\tfact[0] = 1;\n\tfor (int i = 1; i < M; i++)\n\t\tfact[i] = mult(fact[i - 1], i);\n}\n\n\nmain() {\n\tios_base::sync_with_stdio(NULL); cin.tie(NULL); cout.tie(NULL);\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tprecalc();\n\tcin >> n >> m;\n//\tcout << C(3, 1) << endl;\n//\tcout << F(2, 6, 2) << endl;\n\tfor (int i = 0; i <= min(n, m); i++)\n\t\tadd(ans, modulo(F(n, 3 * m, i) - G(n, m, i)));\n\tcout << ans;\t\n\treturn 0;\n}\n/*\n3 5\n1 3 2 1 3\n10 5 7\n3\n4 2 4\n1 3 1\n3 5 2\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod=998244353;\ninline int add(int a,int b){a+=b;return a>=mod?a-mod:a;}\ninline int sub(int a,int b){a-=b;return a<0?a+mod:a;}\ninline int mul(int a,int b){return (ll)a*b%mod;}\ninline int qpow(int a,int b){int ret=1;for(;b;b>>=1,a=mul(a,a))if(b&1)ret=mul(ret,a);return ret;}\n/* math */\nconst int N = 4e6+5;\nint fac[N],ifac[N];\ninline void init(int n=4e6){\n\tfac[0]=ifac[0]=1;for(int i=1;i<=n;i++)fac[i]=mul(fac[i-1],i);\n\tifac[n]=qpow(fac[n],mod-2);for(int i=n-1;i;i--)ifac[i]=mul(i+1,ifac[i+1]);\n}\ninline int binom(int a,int b){\n\tif(b>a)return 0;\n\treturn mul(fac[a],mul(ifac[b],ifac[a-b]));\n}\nint n,m;\n\nint main()\n{\n\tinit();\n\tcin >> n >> m;\n\tint dec1=mul(n, binom(m-1+n-1,n-1));\n\tint dec2=0;\n\tfor(int d=0;d<=min(n,m);d++)if((m*3-d)%2==0){\n\t\tint w=binom(n,d);\n\t\tint d2=mul(w, binom((m*3-d)/2+n-1,n-1));\n\t\t// cout << \" \" << (m*3-d)/2 << endl;\n\t\t// cout << d << \" \" << w << \" \" << binom((m*3-d)/2+n-1,n-1) << endl;\n\t\tdec2=add(dec2,d2);\n\t}\n\t// cout << dec1 << \" \" << dec2 << endl;\n\tcout << sub(dec2,dec1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cstdio>\n#include <iomanip>\n#include <cmath>\n#include <bitset>\n\nusing namespace std;\n\nint n, m;\nconst int MOD = 998244353;\nlong long ans = 0;\nlong long fact[2100000];\nlong long ufact[2100000];\n\nlong long inq(long long a, long long b)\n{\n    if (b == 0) return 1;\n    long long l = inq(a, b / 2);\n    if (b % 2) return l * l % MOD * a % MOD;\n    return l * l % MOD;\n}\n\nlong long cnk(long long n, long long k)\n{\n    return fact[n] * ufact[k] % MOD * ufact[n - k] % MOD;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tfact[0] = 1, ufact[0] = 1;\n\tcin >> n >> m;\n\tfor (int i = 1; i <= 3 * m + n; i++) fact[i] = fact[i - 1] * i % MOD, ufact[i] = inq(fact[i], MOD - 2);\n\tans = cnk(3 * m + n - 1, n - 1);\n\tans = (ans + MOD - n) % MOD;\n\tn--;\n\tfor (int bad_len = 2 * m + 1; bad_len < 3 * m; bad_len++)\n    {\n        int cnt_pos = 3 * m - bad_len - 1;\n        ans = (ans + MOD - cnt_pos * cnk(3 * m - bad_len + 1 + n - 2, n - 2) % MOD) % MOD;\n        ans = (ans + MOD - 2 * cnk(3 * m - bad_len + 1 + n - 1, n - 1) % MOD) % MOD;\n    }\n    //cout << n << endl;\n    for (int b = m + 1; b <= min(3 * m, n + 1); b++)\n    {\n        int p = 3 * m + b;\n        int g = n + 1 - b;\n        int len = 3 * m + g;\n        int kek = len - n - 1;\n        if (kek % 2 == 0)\n        {\n            ans = (ans + MOD - cnk(kek + n + 1, n + 1) * cnk(n + 1, g) % MOD) % MOD;\n        }\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=2000005;\nconst int mod = 998244353;\nint n, m;\nlong long fact[maxn],inv[maxn];\nlong long r(int x, int p)\n{\n\tlong long ret=1,w=x;\n\twhile(p)\n\t{\n\t\tif(p&1) \n\t\t  ret=ret*w%mod;\n\t\tw=w*w%mod;\n\t\tp>>=1;\n\t}\n\treturn ret;\n}\nlong long b(int x, int y)\n{\n\treturn fact[x]*(inv[y]*inv[x-y]%mod)%mod;\n}\nint f(int n,int odd,int sum)\n{\n\tlong long ret=0;\n\tfor(int i=0;i<=odd&&i<=sum&&i<=n;i++)\n\t{\n\t\tif(sum%2==i%2)\n\t\t{\n\t\t\tret+=b((sum-i)/2+n-1,n-1)*b(n,i)%mod;\n\t\t}\n\t}\n\treturn ret%mod;\n}\nlong long g(int n,int sum)\n{\n\treturn b(sum+n-1,n-1);\n}\nint main()\n{\n\tfact[0]=inv[0]=1;\n\tfor(int i=1;i<maxn;i++)\n\t{\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tinv[i]=r(fact[i],mod-2);\n\t}\n\tcin>>n>>m;\n\tlong long ret=f(n,m,3*m);\n\tfor(int i=2*m+1;i<=3*m;i++)\n\t{\n\t\tret+=mod-n*g(n-1,3*m-i)%mod;\n\t}\n\tcout<<ret%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n\t#include <boost/multiprecision/cpp_int.hpp>\n\t#include <boost/multiprecision/cpp_dec_float.hpp>\n\tusing bll = boost::multiprecision::cpp_int;\n\tusing bdouble = boost::multiprecision::cpp_dec_float_100;\n#endif\n#ifdef LOCAL_DEV\n\tvoid debug_impl() { std::cerr << '\\n'; }\n\ttemplate<typename Head, typename... Tail> void debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head << (sizeof...(tail) ? \",\" : \"\"); debug_impl(tail...); }\n\t#define debug(...) do { std::cerr << \"(\" << #__VA_ARGS__ << \") =\"; debug_impl(__VA_ARGS__); } while (false)\n#else\n\t#define debug(...) do {} while (false)\n#endif\n#ifdef LOCAL_TEST\n\t#define BOOST_STACKTRACE_USE_ADDR2LINE\n\t#define BOOST_STACKTRACE_ADDR2LINE_LOCATION /usr/local/opt/binutils/bin/addr2line\n\t#define _GNU_SOURCE\n\t#include <boost/stacktrace.hpp>\n\tnamespace std {\n\t\ttemplate<typename T> class dvector : public std::vector<T> {\n\t\tpublic:\n\t\t\tdvector() : std::vector<T>() {}\n\t\t\texplicit dvector(size_t n, const T& value = T()) : std::vector<T>(n, value) {}\n\t\t\tdvector(const std::vector<T>& v) : std::vector<T>(v) {}\n\t\t\tdvector(const std::initializer_list<T> il) : std::vector<T>(il) {}\n\t\t\tdvector(const typename std::vector<T>::iterator first, const typename std::vector<T>::iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const std::string::iterator first, const std::string::iterator last) : std::vector<T>(first, last) {}\n\t\t\tT& operator[](size_t n) {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst T& operator[](size_t n) const {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\tclass dbool {\n\tprivate:\n\t\tbool boolvalue;\n\tpublic:\n\t\tdbool() : boolvalue(false) {}\n\t\tdbool(bool b) : boolvalue(b) {}\n\t\tdbool(const dbool& b) : boolvalue(b.boolvalue) {}\n\t\toperator bool&() { return boolvalue; }\n\t\toperator const bool&() const { return boolvalue; }\n\t};\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::dvector<T>& v) {\n\t\tfor (size_t i = 0; i < v.size(); ++i){ s << v[i]; if (i < v.size() - 1) s << \"\\t\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::dvector<std::dvector<T>>& vv) {\n\t\ts << \"\\n\"; for (size_t i = 0; i < vv.size(); ++i){ s << vv[i] << \"\\n\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::set<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::multiset<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate <typename T, size_t N> std::ostream& operator<<(std::ostream& s, const std::array<T, N>& a) {\n\t\ts << \"{ \"; for (size_t i = 0; i < N; ++i){ s << a[i] << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::map<T1, T2>& m) {\n\t\ts << \"{\\n\"; for (auto itr = m.begin(); itr != m.end(); ++itr){ s << \"\\t\" << (*itr).first << \" : \" << (*itr).second << \"\\n\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::pair<T1, T2>& p) {\n\t\treturn s << \"(\" << p.first << \", \" << p.second << \")\"; }\n\t#define vector dvector\n\t#define bool dbool\n\tclass SIGFPE_exception : std::exception {};\n\tclass SIGSEGV_exception : std::exception {};\n\tvoid catch_SIGFPE(int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGFPE_exception();\t}\n\tvoid catch_SIGSEGV(int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGSEGV_exception(); }\n\tsigned convertedmain();\n\tsigned main() { signal(SIGFPE, catch_SIGFPE); signal(SIGSEGV, catch_SIGSEGV); return convertedmain(); }\n\t#define main() convertedmain()\n#endif\n//#define int long long\nusing ll = long long;\n//constexpr int INF = 1e9;//INT_MAX=(1<<31)-1=2147483647\nconstexpr ll INF = (ll)1e18;//(1LL<<63)-1=9223372036854775807\nconstexpr ll MOD = (ll)1e9 + 7;\nconstexpr double EPS = 1e-9;\nconstexpr ll dx[4] = {1LL, 0LL, -1LL, 0LL};\nconstexpr ll dy[4] = {0LL, 1LL, 0LL, -1LL};\nconstexpr ll dx8[8] = {1LL, 0LL, -1LL, 0LL, 1LL, 1LL, -1LL, -1LL};\nconstexpr ll dy8[8] = {0LL, 1LL, 0LL, -1LL, 1LL, -1LL, 1LL, -1LL};\n#define rep(i, n)   for(ll i=0, i##_length=(n); i< i##_length; ++i)\n#define repeq(i, n) for(ll i=1, i##_length=(n); i<=i##_length; ++i)\n#define rrep(i, n)   for(ll i=(n)-1; i>=0; --i)\n#define rrepeq(i, n) for(ll i=(n)  ; i>=1; --i)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\nvoid p() { std::cout << '\\n'; }\ntemplate<typename Head, typename... Tail> void p(Head head, Tail... tail) { std::cout << head << (sizeof...(tail) ? \" \" : \"\"); p(tail...); }\ntemplate<typename T> inline void pv(std::vector<T>& v) { for(ll i=0, N=v.size(); i<N; i++) std::cout << v[i] << \" \\n\"[i==N-1]; }\ntemplate<typename T> inline T gcd(T a, T b) { return b ? gcd(b,a%b) : a; }\ntemplate<typename T> inline T lcm(T a, T b) { return a / gcd(a,  b) * b; }\ntemplate<typename T> inline bool chmax(T& a, T b) { return a < b && (a = b, true); }\ntemplate<typename T> inline bool chmin(T& a, T b) { return a > b && (a = b, true); }\ntemplate<typename T> inline void uniq(std::vector<T>& v) { v.erase(std::unique(v.begin(), v.end()), v.end()); }\n\n/*-----8<-----template-----8<-----*/\n\ninline constexpr ll extgcd(ll a, ll b, ll &x, ll &y){ ll g = a; x = 1; y = 0; if(b){ g = extgcd(b, a % b, y, x); y -= a / b * x; } return g; }\ninline constexpr ll invmod(ll a, ll m = MOD){ ll x = 0, y = 0; extgcd(a, m, x, y); return (x + m) % m; }\nclass Modint{\npublic:\n\tll _num;\n\tconstexpr Modint() : _num() { _num = 0; }\n\tconstexpr Modint(ll x) : _num() { _num = x % MOD; if(_num < 0) _num += MOD; }\n\tinline constexpr Modint operator= (int x){ _num = x % MOD; if(_num<0) _num += MOD; return *this; }\n\tinline constexpr Modint operator= (ll x){ _num = x % MOD; if(_num<0) _num += MOD; return *this; }\n\tinline constexpr Modint operator= (Modint x){ _num = x._num; return *this; }\n\tinline constexpr Modint operator+ (int x){ return Modint(_num + x); }\n\tinline constexpr Modint operator+ (ll x){ return Modint(_num + x); }\n\tinline constexpr Modint operator+ (Modint x){ ll a = _num + x._num; if(a >= MOD) a -= MOD; return Modint{a}; }\n\tinline constexpr Modint operator+=(int x){ _num += x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator+=(ll x){ _num += x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator+=(Modint x){ _num += x._num; if(_num >= MOD) _num -= MOD; return *this; }\n\tinline constexpr Modint operator++(){ _num++; if(_num == MOD) _num = 0; return *this; }\n\tinline constexpr Modint operator- (int x){ return Modint(_num - x); }\n\tinline constexpr Modint operator- (ll x){ return Modint(_num - x); }\n\tinline constexpr Modint operator- (Modint x){ ll a = _num - x._num; if(a < 0) a += MOD; return Modint{a}; }\n\tinline constexpr Modint operator-=(int x){ _num -= x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator-=(ll x){ _num -= x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator-=(Modint x){ _num -= x._num; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator--(){ _num--; if(_num == -1) _num = MOD - 1; return *this; }\n\tinline constexpr Modint operator* (int x){ return Modint(_num * (x % MOD)); }\n\tinline constexpr Modint operator* (ll x){ return Modint(_num * (x % MOD)); }\n\tinline constexpr Modint operator* (Modint x){ return Modint{_num * x._num % MOD}; }\n\tinline constexpr Modint operator*=(int x){ _num *= Modint(x); _num %= MOD; return *this; }\n\tinline constexpr Modint operator*=(ll x){ _num *= Modint(x); _num %= MOD; return *this; }\n\tinline constexpr Modint operator*=(Modint x){ _num *= x._num; _num %= MOD; return *this; }\n\tinline constexpr Modint operator/ (int x){ return Modint(_num * invmod(Modint(x), MOD)); }\n\tinline constexpr Modint operator/ (ll x){ return Modint(_num * invmod(Modint(x), MOD)); }\n\tinline constexpr Modint operator/ (Modint x){ return Modint{_num * invmod(x._num, MOD) % MOD}; }\n\tinline constexpr Modint operator/=(int x){ _num *= invmod(Modint(x), MOD); _num %= MOD; return *this; }\n\tinline constexpr Modint operator/=(ll x){ _num *= invmod(Modint(x), MOD); _num %= MOD; return *this; }\n\tinline constexpr Modint operator/=(Modint x){ _num *= invmod(x._num, MOD); _num %= MOD; return *this; }\n\tinline constexpr Modint pow(ll n){ ll i = 1, x = n>=0 ? n : -n; Modint ans = 1, cnt = n>=0 ? *this : Modint(1) / *this; while(i <= x){ if(x & i){ ans *= cnt; x ^= i; } cnt *= cnt; i *= 2; } return ans; }\n\tinline constexpr operator ll() const { return _num; }\n};\ninline std::istream& operator>>(std::istream &s, Modint &x){ ll t; s>>t; x=t; return s; }\nvector<Modint> fac(1, 1), inv(1, 1);\ninline void reserve(size_t a){\n\tif(fac.size() >= a) return;\n\tif(a < fac.size() * 2) a = fac.size() * 2;\n\tif(a >= MOD) a = MOD;\n\twhile(fac.size() < a) fac.push_back(fac.back() * ll(fac.size()));\n\tinv.resize(fac.size());\n\tinv.back() = Modint(1) / fac.back();\n\tfor(ll i = inv.size() - 1; !inv[i - 1]; i--) inv[i - 1] = inv[i] * i;\n}\ninline Modint factorial(ll n){ if(n < 0) return 0; reserve(n + 1); return fac[n]; }\ninline Modint nPk_loop(ll n, ll k){ if(n<k) return 0; Modint val(1); for(ll i=n;i>(n-k);i--)val*=i; return val; }\ninline Modint nCk_loop(ll n, ll k){ if(n<k) return 0; Modint val(1); k=min(k,n-k); for(ll i=n;i>(n-k);i--)val*=i; for(ll i=k;i>1;i--)val/=i; return val; };\ninline Modint nPk(ll n, ll k){ if(k < 0 || n < k) return 0; if(n>=(ll)1e7) return nPk_loop(n, k); reserve(n + 1); return fac[n] * inv[n - k]; }\ninline Modint nCk(ll n, ll k){ if(k < 0 || n < k) return 0; if(n>=(ll)1e7) return nCk_loop(n, k); reserve(n + 1); return fac[n] * inv[k] * inv[n - k]; }\ninline Modint nHk(ll n, ll k){ return nCk(n + k - 1, k); } //n種類のものから重複を許してk個選ぶ=玉k個と仕切りn-1個\n\n/*\nnCk：n!が間に合わないくらい巨大でkが小さいとき、素直に計算すると間に合う のは1e7以上に組み込んであります\n\tauto f = [](ll n, ll k){\n\t\tif(n<k)return Modint(0);\n\t\tModint val(1);\n\t\tk=min(k,n-k);\n\t\tfor(ll i=n;i>(n-k);i--)val*=i;\n\t\tfor(ll i=k;i>1;i--)val/=i;\n\t\treturn val;\n\t};\n*/\n\n\n//区間add, 区間sum ができる\ntemplate< typename T >\nclass BinaryIndexedTree {\npublic:\n\tclass BinaryIndexedTreeNaive {\n\tpublic:\n\t\tll size;\n\t\tvector<T> data;\n\t\tBinaryIndexedTreeNaive(ll N) : size(N+1), data(size, 0) {}\n\n\t\t// sum [0, i)\n\t\tT sum(ll i) {\n\t\t\tT ret = 0;\n\t\t\tfor(--i; i>=0; i=(i&(i+1))-1) ret += data[i];\n\t\t\treturn ret;\n\t\t}\n\n\t\t// sum [i, j)\n\t\tT sum(ll i, ll j) {\n\t\t\treturn sum(j) - sum(i);\n\t\t}\n\n\t\t// add x to i\n\t\tvoid add(ll i, T x) {\n\t\t\tfor(; i < size; i|=i+1) data[i] += x;\n\t\t}\n\t};\n\tll size;\n\tBinaryIndexedTreeNaive b,c;\n\tBinaryIndexedTree(ll N) : size(N), b(size), c(size) {}\n\n\t// add x to [i, j) \n\tvoid add(ll i, ll j, T x) {\n\t\tb.add(i,x*-i);\n\t\tb.add(j,x*j);\n\t\tc.add(i,x);\n\t\tc.add(j,x*-1);\n\t}\n\n\t// sum [0, i)\n\tT sum(ll i) { \n\t\treturn b.sum(i+1) + c.sum(i+1)*i;\n\t}\n\n\t// sum [i, j)\n\tT sum(ll i, ll j) {\n\t\treturn sum(j) - sum(i);\n\t}\n};\ntemplate<typename T> std::ostream& operator<<(std::ostream& s, BinaryIndexedTree<T>& bit) { \n\tfor(ll i=0; i<bit.size; i++) s << bit.sum(i, i+1) << \"\\t\\n\"[i==bit.size-1];\n\treturn s;\n}\n\n/*-----8<-----library-----8<-----*/\n\nvoid solve() {\n\tll N,M;\n\tcin>>N>>M;\n\tvector<BinaryIndexedTree<Modint>> dp(N+1,3*M+1);\n\tdp[0].add(0,1,1);\n\trep(i,N){\n\t\trep(j,3*M+1){\n\t\t\tdp[i+1].add(j, min(j+2*M+1,3*M+1), dp[i].sum(j,j+1));\n\t\t}\n\t}\n\n\trep(i,N+1)debug(dp[i]);\n\n\tModint ans=dp[N].sum(3*M,3*M+1);\n\tp(ans);\n\n}\n\nsigned main() {\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n//#define int long long\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long double ld;\ntypedef long long ll;\n#define X first\n#define Y second\n#define all(o) o.begin(), o.end()\n#define endl '\\n'\n#define IOS ios::sync_with_stdio(0), cin.tie(0)\n\nint gcd(int x,int y){ return (!y ? x : gcd(y, x%y)); }\nconst int maxn = 3e6 + 10;\nint fact[maxn], inv[maxn];\nint mod = 998244353;\ninline int mu(int x,int y){ return 1LL * x * y % mod; }\ninline int ad(int x,int y){\n\tx += y;\n\tif(x < mod)\n\t\treturn x;\n\treturn x - mod;\n}\ninline int bpow(int x,int y){\n\tint res = 1;\n\twhile(y){\n\t\tif(y&1)\n\t\t\tres = mu(res, x);\n\t\tx = mu(x, x);\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\nvoid prep(){\n\tfor(int i=0; i<maxn; i++)\n\t\tfact[i] = (!i ? 1 : mu(fact[i - 1], i));\n\tinv[maxn - 1] = bpow(fact[maxn - 1], mod - 2);\n\tfor(int i=maxn - 2; i>=0; i--)\n\t\tinv[i] = mu(inv[i + 1], i + 1);\n}\ninline int C(int r,int n){\n\tif(r < 0 || n < 0 || r > n)\n\t\treturn 0;\n\treturn mu(fact[n], mu(inv[r], inv[n - r]) );\n}\nint get(int m,int sum,int n){\n\tint ans = 0;\n\tfor(int od=0; od<=m; od++){\n\t\tint rem = sum - od;\n\t\tif(rem & 1)\n\t\t\tcontinue;\n\t\tint z = C(od, n);\n\t\tz = mu(z, C(n - 1, n - 1 + rem/2));\n\t\tans = ad(ans, z);\n\t}\n\treturn ans;\n}\nint32_t main(){\n\tIOS;\n\tprep();\n\tint n, m;\n\tcin >> n >> m;\n\tint ans = 0;\n\tfor(int od = 0; od <= m && od <= n; od++){\n\t\tint rem = 3 * m - od;\n\t\tif(rem & 1)\n\t\t\tcontinue;\n\t\tint z = C(od, n);\n\t\tz = mu(z, C(n - 1, n - 1 + rem/2));\n\t\tans = ad(ans, z);\n\t}\n\tint t = 0;\n\tt = mod - get(m, m, n);\n\tt = ad(t, get(m, m, n - 1) );\n\tt = mu(t, n);\n\tans = ad(ans, t);\n\tcout << ans << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 998244353;\n\n#define N 3000030\nint fac[N], rfac[N], ri[N];\nvoid init() {\n    fac[0] = 1;\n    for (int i = 1; i < N; i ++) fac[i] = 1ll * fac[i-1] * i % mod;\n    rfac[0] = rfac[1] = 1, ri[1] = 1;\n    for(int i = 2; i < N; i ++) {\n        int t = mod / i;\n        ri[i] = (1ll * t * (mod - ri[mod % i])) % mod;\n        rfac[i] = (1ll * rfac[i-1] * ri[i]) % mod;\n    }\n}\n\nint C(int n, int k) {\n\tif (!(0 <= k && k <= n)) return 0;\n\treturn 1ll * fac[n] * rfac[k] % mod * rfac[n-k] % mod;\n}\n\nint main() {\n\tinit();\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tint ans = 0;\n\tfor (int o = m & 1; o <= m && o <= n; o += 2) {\n\t\tint d = (3 * m - o) / 2;\n\t\tans = (ans + 1ll * C(n, o) * ((C(n + d - 1, d) - 1ll * o * C(n + d - m - 1, d - m) - 1ll * (n - o) * C(n+d-m-2,d-m-1)) % mod)) % mod;\n\t}\n\tif (ans < 0) ans += mod;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n#define NL <<\"\\n\"\n\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#include \"../benri.h\"\n#else\n#define out\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=998244353;\n\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=m-1)+=m-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\ntemplate <int mod=MOD> struct modInt{\n  int v;\n  modInt(int v=0):v(v){}\n  modInt(ll v):v(v%MOD){}\n  modInt operator+(const modInt &n)const{return v+n.v<mod ? v+n.v : v+n.v-mod;}\n  modInt operator-(const modInt &n)const{return v-n.v<0 ? v-n.v+mod : v-n.v;}\n  modInt operator*(const modInt &n)const{return ll(v)*n.v%mod;}\n  modInt operator/(const modInt &n)const{return ll(v)*modpow(n.v%mod,-1,mod)%mod;}\n  modInt operator+(const ll &n)const{return v+n<mod ? v+n : v+n-mod;}\n  modInt operator-(const ll &n)const{return v-n<0 ? v-n+mod : v-n;}\n  modInt operator*(const ll &n)const{return ll(v)*(n%mod)%mod;}\n  modInt operator/(const ll &n)const{return ll(v)*modpow(n%mod,-1,mod)%mod;}\n  modInt& operator+=(const modInt &n){v+=n.v; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const modInt &n){v-=n.v; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const modInt &n){v=ll(v)*n.v%mod; return *this;}\n  modInt& operator/=(const modInt &n){v=ll(v)*modpow(n.v,-1,mod)%mod; return *this;}\n  modInt& operator+=(const ll &n){v+=n; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const ll &n){v-=n; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const ll &n){v=ll(v)*n%mod; return *this;}\n  modInt& operator/=(const ll &n){v=ll(v)*modpow(n,-1,mod)%mod; return *this;}\n};\n#ifdef NUIP\nclass MINT_FRAC____{\npublic:\n\tunordered_map<int,pii> dict;\n\tMINT_FRAC____(int n){\n\t\trep(p,n+1)reps(q,1,n+1)if(__gcd(p,q)==1){\n\t\t\tdict[1ll*p*modpow(q,-1)%MOD]=pii(p,q);\n\t\t\tdict[MOD-1ll*p*modpow(q,-1)%MOD]=pii(-p,q);\n\t\t}\n\t}\n} Il1Il1Il1(1000);\ntemplate<int mod> ostream& operator<<(ostream &os,const modInt<mod> &n){if(Il1Il1Il1.dict.count(n.v)) os<<n.v<<\"(\"<<Il1Il1Il1.dict[n.v].X<<\"/\"<<Il1Il1Il1.dict[n.v].Y<<\")\";else os<<n.v;return os;};\n#else\ntemplate<int mod> ostream& operator<<(ostream &os,const modInt<mod> &n){return os<<n.v;};\n#endif\ntemplate<int mod> modInt<mod> operator+(const ll &n,const modInt<mod> &m){return m.v+n<mod ? m.v+n : m.v+n-mod;}\ntemplate<int mod> modInt<mod> operator-(const ll &n,const modInt<mod> &m){return n-m.v<0 ? n-m.v+mod : n-m.v;}\ntemplate<int mod> modInt<mod> operator*(const ll &n,const modInt<mod> &m){return ll(m.v)*(n%mod)%mod;}\ntemplate<int mod> modInt<mod> operator/(const ll &n,const modInt<mod> &m){return modInt<mod>(n%mod)/m;}\ntypedef modInt<MOD> mint;\ntemplate <int mod> modInt<mod> modpow(modInt<mod> r,ll n){ modInt<mod> re(1); if(n<0)(n%=mod-1)+=mod-1; for(;n;n/=2){if(n&1) re*=r; r*=r;} return re;}\nvector<mint> fact,finv,inv;\nmint comb(ll n,ll r){ if(n<r||r<0)return 0; return fact[n]*finv[n-r]*finv[r];}\nclass Doralion{\n  void Modinvs(vector<mint> &re,int n){ re.resize(n+1); re[1]=1; for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i);}\n  void Facts(vector<mint> &re,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*(i+1);}\n  void Factinvs(vector<mint> &re,const vector<mint> &inv,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*inv[i+1];}\npublic:\n  Doralion(int n){ Modinvs(inv,n); Facts(fact,n); Factinvs(finv,inv,n);}\n} doralion(3123456);\n\nint main(){\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  cout<<fixed<<setprecision(0);\n\tint n,m;\n\tcin>>n>>m;\n\tmint re=0;\n\tfor(int i=0,ii=0;i<=3*m;i+=2*m+1,++ii){\n\t\tint j=3*m-i;\n\t\tre+=comb(n,ii)*(ii%2==0?mint(1):mint(MOD-1))*comb(j+n-1,j);\n\t}\n\tcout<<re<<endl;\n\t// vv<int> vs; vs.eb(n);\n\t// rep(_,m){\n\t// \tvv<int> nxt;\n\t// \tfor(auto v:vs){\n\t// \t\trep(i,n)rep(j,n)if(i!=j){\n\t// \t\t\tv[i]+=1;\n\t// \t\t\tv[j]+=2;\n\t// \t\t\tnxt.pb(v);\n\t// \t\t\tv[i]-=1;\n\t// \t\t\tv[j]-=2;\n\t// \t\t}\n\t// \t}\n\t// \tvs=nxt;\n\t// \tsort(all(vs)); UNIQUE(vs);\n\t// }\n\t// out(vs.size(),1);\n\t// out(vs,1);\n\t// set<vector<int>> st(all(vs));\n\t// rep(i,m+1)rep(j,m+1)rep(k,m+1)rep(l,m+1){\n\t// \tif(i+j+k+l==3*m){\n\t// \t\tif(st.count(vector<int>{i,j,k,l})==0) out(i,j,k,l,1);\n\t// \t}\n\t// }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\n// ModInt begin\n\nusing ll = long long;\ntemplate<ll mod>\nstruct ModInt {\n    ll v;\n    ll mod_pow(ll x, ll n) const {\n        return (!n) ? 1 : (mod_pow((x*x)%mod,n/2) * ((n&1)?x:1)) % mod;\n    }\n    ModInt(ll a = 0) : v(a >= mod ? a % mod : a) {}\n    ModInt operator+ ( const ModInt& b ) const {\n        return (v + b.v >= mod ? ModInt(v + b.v - mod) : ModInt(v + b.v));\n    }\n    ModInt operator- () const {\n        return ModInt(-v);\n    }\n    ModInt operator- ( const ModInt& b ) const {\n        return (v - b.v < 0 ? ModInt(v - b.v + mod) : ModInt(v - b.v));\n    }\n    ModInt operator* ( const ModInt& b ) const {return (v * b.v) % mod;}\n    ModInt operator/ ( const ModInt& b ) const {return (v * mod_pow(b.v, mod-2)) % mod;}\n    \n    bool operator== ( const ModInt &b ) const {return v == b.v;}\n    bool operator!= ( const ModInt &b ) const {return !(*this == b); }\n    ModInt& operator+= ( const ModInt &b ) {\n        v += b.v;\n        if(v >= mod) v -= mod;\n        return *this;\n    }\n    ModInt& operator-= ( const ModInt &b ) {\n        v -= b.v;\n        if(v < 0) v += mod;\n        return *this;\n    }\n    ModInt& operator*= ( const ModInt &b ) {\n        (v *= b.v) %= mod;\n        return *this;\n    }\n    ModInt& operator/= ( const ModInt &b ) {\n        (v *= mod_pow(b.v, mod-2)) %= mod;\n        return *this;\n    }\n    ModInt pow(ll x) { return ModInt(mod_pow(v, x)); }\n    // operator int() const { return int(v); }\n    // operator long long int() const { return v; }\n};\n\ntemplate<ll mod>\nostream& operator<< (ostream& out, ModInt<mod> a) {return out << a.v;}\ntemplate<ll mod>\nistream& operator>> (istream& in, ModInt<mod>& a) {\n    in >> a.v;\n    return in;\n}\n\n// ModInt end\n\n// 各種組み合わせを求めるライブラリ\ntemplate <typename NumType>\nstruct Combination {\n    int LIMIT;\n    vector<NumType> fact_, finv_;\n\n    Combination() {}\n    Combination(int LIMIT_) : LIMIT(LIMIT_), fact_(LIMIT+1), finv_(LIMIT+1) {\n        fact_[0] = finv_[LIMIT] = NumType(1);\n        for(int i=1; i<=LIMIT; i++) {\n            fact_[i] = fact_[i-1] * NumType(i);\n        }\n        \n        finv_[LIMIT] /= fact_[LIMIT];\n        for(int i=LIMIT-1; i>=0; i--) {\n            finv_[i] = finv_[i+1] * NumType(i+1);\n        }\n    }\n\n    inline NumType fact(int k) const { return fact_[k]; }\n    inline NumType finv(int k) const { return finv_[k]; }\n    NumType P(int n, int r) const {\n        if(r < 0 or n < r) return NumType(0);\n        return fact_[n] * finv_[n-r];\n    }\n    NumType C(int n, int r) const {\n        if(r < 0 or n < r) return NumType(0);\n        return fact_[n] * finv_[n-r] * finv_[r];\n    }\n    // 重複組み合わせ\n    NumType H(int n, int r) const {\n        if(n < 0 or r < 0) return NumType(0);\n        return r == 0 ? NumType(1) : C(n + r - 1, r);\n    }\n    // ベル数 (区別できる n 個のボールを区別できない k 個以下の箱に分割)\n    // B(n, n) := n 個のボールを任意個のグループに分割する場合の数\n    NumType B(int n, int k) const {\n        if(n == 0) return NumType(1);\n        k = min(n, k);\n        NumType ret(0);\n        vector<NumType> pref(k + 1); pref[0] = NumType(1);\n        for(int i=1; i<=k; i++) {\n            if(i & 1) pref[i] = pref[i-1] - finv_[i];\n            else pref[i] = pref[i-1] + finv_[i];\n        }\n        for(int i=1; i<=k; i++) {\n            // 累乗が必要なので適宜書き換える？\n            // ModInt 使うならこれでいい\n            ret += NumType(i).pow(n) * finv_[i] * pref[k-i];\n        }\n        return ret;\n    }\n    // スターリング数 (区別できる n 個のボールを区別できない k 個の箱に分割)\n    NumType S(int n, int k) const {\n        if(n < k) return NumType(0);\n        NumType ans(0);\n        for(int i=0; i<=k; i++) {\n            NumType val = C(k, i) * NumType(i).pow(n);\n            if((k - i) % 2) ans -= val;\n            else ans += val;\n        }\n        return ans * finv_[k];\n    }\n};\n\n// P(n, k) := n の k 分割 (k 個の 0 以上の整数の和)\ntemplate <typename NumType, int LIMIT = 3010>\nstruct Partition {\n    vector< vector<NumType> > dp;\n    Partition() : dp(LIMIT, vector<NumType>(LIMIT)) {\n        for(int k=0; k<LIMIT; k++) dp[0][k] = NumType(1);\n        for(int i=1; i<LIMIT; i++) {\n            for(int j=1; j<LIMIT; j++) {\n                dp[i][j] += dp[i][j-1];\n                if(i-j >= 0) dp[i][j] += dp[i-j][j];\n            }\n        }\n    }\n    inline NumType get(int n, int k) {\n        if(n < 0 or k < 0) return NumType(0);\n        return dp[n][k];\n    }\n};\n\nint main() {\n    ll N, M; cin >> N >> M;\n    using mint = ModInt<998244353>;\n\n    mint ans(0);\n    Combination<mint> comb(3000010);\n\n    // 2M を超える要素が無いのを無視して数える\n    for(int i=0; i<=M; i++) {\n        int rem = 3*M - i;\n        if(rem % 2) continue;\n        rem /= 2;\n        \n        mint add = comb.C(N, i);\n        add *= comb.H(N, rem);\n        ans += add;\n    }\n\n    mint sub(0);\n    // 1 個目が奇数かつ 2M 超える\n    {\n        for(int i=0; i<M; i++) {\n            int rem = 3*M - 2*M - 1 - i;\n            if(rem < 0 or rem % 2) continue;\n            rem /= 2;\n\n            mint add = comb.C(N-1, i);\n            add *= comb.H(N, rem);\n            sub += add;\n        }\n    }\n\n    // 1 個目が偶数かつ 2M 超える\n    {\n        for(int i=0; i<M; i++) {\n            int rem = 3*M - 2*M - 2 - i;\n            if(rem < 0 or rem % 2) continue;\n            rem /= 2;\n\n            mint add = comb.C(N-1, i);\n            add *= comb.H(N, rem);\n            sub += add;\n        }\n    }\n\n    ans -= mint(N) * sub;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int mod=998244353,N=1e7+5;\nint ksm(int b,int n){\n\tint res=1;\n\twhile(n){\n\t\tif(n&1) res=res*b%mod;\n\t\tb=b*b%mod; n>>=1;\n\t}\n\treturn res;\n}\nint fac[N],inv[N];\nvoid init(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfac[i]=fac[i-1]*i%mod;\n\tinv[n]=ksm(fac[n],mod-2);\n\tfor(int i=n-1;i>=0;--i)\n\t\tinv[i]=(i+1)*inv[i+1]%mod;\n}\nint C(int n,int m){\n\tif(n<m) return 0;\n\treturn fac[n]*inv[m]%mod*inv[n-m]%mod;\n}\nvoid add(int &x,int y){\n\tx=(x+y)%mod;\n}\nvoid dec(int &x,int y){\n\tx=(x+mod-y)%mod;\n}\nsigned main(){\n\tint n,m,ans=0;\n\tcin>>n>>m;\n\tinit(n+3*m);\n\tfor(int i=0;i<=m;++i)\n\t\tif((3*m-i)%2==0) add(ans,C(n,i)*C((3*m-i)/2+n-1,n-1)%mod);\n\tfor(int i=2*m+1;i<=3*m;++i)\n\t\tdec(ans,n*C(3*m-i+n-2,n-2)%mod);\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include <cstddef>\n#include <cstdint>\n#include <iostream>\n#include <vector>\n\nnamespace n91 {\n\nusing i8 = std::int_fast8_t;\nusing i32 = std::int_fast32_t;\nusing i64 = std::int_fast64_t;\nusing u8 = std::uint_fast8_t;\nusing u32 = std::uint_fast32_t;\nusing u64 = std::uint_fast64_t;\nusing isize = std::ptrdiff_t;\nusing usize = std::size_t;\n\nconstexpr usize operator\"\" _z(unsigned long long x) noexcept {\n  return static_cast<usize>(x);\n}\n\nclass rep {\n  const usize f, l;\n\npublic:\n  class itr {\n    friend rep;\n    usize i;\n    constexpr itr(const usize x) noexcept : i(x) {}\n\n  public:\n    void operator++() noexcept { ++i; }\n    constexpr usize operator*() const noexcept { return i; }\n    constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n  };\n  constexpr rep(const usize first, const usize last) noexcept\n      : f(first), l(last) {}\n  constexpr itr begin() const noexcept { return itr(f); }\n  constexpr itr end() const noexcept { return itr(l); }\n};\nclass revrep {\n  const usize f, l;\n\npublic:\n  class itr {\n    friend revrep;\n    usize i;\n    constexpr itr(usize x) noexcept : i(x) {}\n\n  public:\n    void operator++() noexcept { --i; }\n    constexpr usize operator*() const noexcept { return i; }\n    constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n  };\n  constexpr revrep(usize first, usize last) noexcept : f(--first), l(--last) {}\n  constexpr itr begin() const noexcept { return itr(l); }\n  constexpr itr end() const noexcept { return itr(f); }\n};\ntemplate <class T> using vec_alias = std::vector<T>;\ntemplate <class T> auto md_vec(const usize n, const T &value) {\n  return std::vector<T>(n, value);\n}\ntemplate <class... Args> auto md_vec(const usize n, Args... args) {\n  return std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n}\ntemplate <class T> constexpr T difference(const T &a, const T &b) {\n  return a < b ? b - a : a - b;\n}\ntemplate <class T> T scan() {\n  T ret;\n  std::cin >> ret;\n  return ret;\n}\n\n} // namespace n91\n\n#include <cstdint>\n\nnamespace n91 {\n\nconstexpr std::uint_fast64_t totient(std::uint_fast64_t x) noexcept {\n  using u64 = std::uint_fast64_t;\n  u64 ret = x;\n  for (u64 i = static_cast<u64>(2); i * i <= x; ++i) {\n    if (x % i == static_cast<u64>(0)) {\n      ret -= ret / i;\n      x /= i;\n      while (x % i == static_cast<u64>(0)) {\n        x /= i;\n      }\n    }\n  }\n  if (x != static_cast<u64>(1)) {\n    ret -= ret / x;\n  }\n  return ret;\n}\n\ntemplate <std::uint_fast64_t Modulus,\n          std::uint_fast64_t InverseExp =\n              totient(Modulus) - static_cast<u64>(1)>\nclass modint {\n  using u64 = std::uint_fast64_t;\n\n  static_assert(Modulus < static_cast<u64>(1) << static_cast<u64>(32),\n                \"Modulus must be less than 2**32\");\n\n  u64 a;\n\n  constexpr modint &negate() noexcept {\n    if (a != static_cast<u64>(0)) {\n      a = Modulus - a;\n    }\n    return *this;\n  }\n\npublic:\n  constexpr modint(const u64 x = static_cast<u64>(0)) noexcept\n      : a(x % Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+() const noexcept { return modint(*this); }\n  constexpr modint operator-() const noexcept { return modint(*this).negate(); }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = InverseExp;\n    while (exp) {\n      if (exp % static_cast<u64>(2) != static_cast<u64>(0)) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= static_cast<u64>(2);\n    }\n    return *this;\n  }\n  constexpr bool operator==(const modint rhs) const noexcept {\n    return a == rhs.a;\n  }\n  constexpr bool operator!=(const modint rhs) const noexcept {\n    return a != rhs.a;\n  }\n};\n\n} // namespace n91\n\n#include <vector>\n\nnamespace n91 {\n\ntemplate <class T> class fact_binom {\npublic:\n  using value_type = T;\n  using container_type = std::vector<value_type>;\n  using size_type = typename container_type::size_type;\n\nprivate:\n  container_type factrial, inv_fact;\n\npublic:\n  fact_binom() : factrial(), inv_fact() {}\n  explicit fact_binom(const size_type n) : factrial(n + 1), inv_fact(n + 1) {\n    factrial[0] = static_cast<value_type>(1);\n    for (size_type i = 0; i != n; ++i) {\n      factrial[i + 1] = static_cast<value_type>(i + 1) * factrial[i];\n    }\n    inv_fact[n] = static_cast<value_type>(1) / factrial[n];\n    for (size_type i = n; i != 0; --i) {\n      inv_fact[i - 1] = inv_fact[i] * static_cast<value_type>(i);\n    }\n  }\n\n  value_type operator()(const size_type n, const size_type r) const {\n    return factrial[n] * inv_fact[r] * inv_fact[n - r];\n  }\n};\n\n} // namespace n91\n\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <set>\n#include <utility>\n\nnamespace n91 {\n\nvoid main_() {\n  using mint = modint<998244353>;\n  const usize n = scan<usize>();\n  const usize m = scan<usize>();\n  const fact_binom<mint> binom(n + m * 3_z + 1_z);\n  const auto h = [&binom](const usize n, const usize m) {\n    return binom(n + m - 1_z, m);\n  };\n\n  mint ans;\n\n  const auto f = [&h, &binom](const usize n, const usize all,\n                              const usize odd_max) {\n    mint ret;\n    for (const auto odd : rep(0_z, odd_max + 1_z)) {\n      if (all < odd) {\n        break;\n      }\n      if ((all - odd) % 2_z == 1_z) {\n        continue;\n      }\n      const usize even = (all - odd) / 2_z;\n      ret += h(n, even) * binom(n, odd);\n    }\n    return ret;\n  };\n\n  ans += f(n, m * 3_z, m);\n\n  ans -= f(n - 1_z, m - 1_z, m - 1_z) * static_cast<mint>(n);\n\n  if (m >= 2_z)\n    ans -= f(n, m - 2_z, m) * static_cast<mint>(n);\n\n  std::cout << ans.value() << std::endl;\n}\n\n} // namespace n91\n\nint main() {\n  n91::main_();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <time.h>\n#define int long long\n#define endl '\\n'\n#define INF 1000000000000000009\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\ntemplate<class T, class S> bool chmax(T &a, const S &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T, class S> bool chmin(T &a, const S &b) { if (a > b) { a = b; return 1; } return 0; }\nll gcd(ll n, ll m) { return (m ? gcd(m, n%m) : n); }\nll lcm(ll n, ll m) { return n / gcd(n, m)*m; }\nll mod = 998244353;\n\nll modinv(ll a) {\n\tll b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= mod; \n\tif (u < 0) u += mod;\n\treturn u;\n}\n\nll modpow(ll a, ll b) {\n\tll ans = 1;\n\ta %= mod;\n\twhile (b) {\n\t\tif (b & 1) ans = ans * a%mod;\n\t\ta = a * a%mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nvector<ll> fac(10000010);\nvector<ll> inv(1000010);\nvector<ll> facinv(10000010);\n\nvoid modcalc(int n) {\n\tfac[0] = fac[1] = 1; inv[1] = 1;\n\tfacinv[0] = facinv[1] = 1;\n\tfor (int i = 2; i <= n; i++) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod%i] * (mod / i) % mod;\n\t\tfacinv[i] = facinv[i - 1] * inv[i] % mod;\n\t}\n}\n\nll modcomb(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0; \n\treturn fac[n] * facinv[k] % mod * facinv[n - k] % mod;\n}\n\nll modperm(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fac[n] * facinv[n - k] % mod;\n}\n\nll modhom(ll n, ll k) {\n\tif (n < 0 || k < 0) return 0;\n\tif (n == 0 && k == 0) return 1;\n\treturn modcomb(n + k - 1, k);\n}\n\ntemplate<class T>\nclass segtree {\n\tint n;\n\tvector<T> data;\n\tT def;\n\tfunction<T(T, T)> operation;\n\tfunction<T(T, T)> update;\n\tT _query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l) return def;\n\t\tif (a <= l && r <= b) return data[k];\n\t\tT c1 = _query(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\tT c2 = _query(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\treturn operation(c1, c2);\n\t}\npublic:\n\tsegtree(size_t _n, T _def, function<T(T, T)> _operation, function<T(T, T)> _update)\n\t\t:def(_def), operation(_operation), update(_update) {\n\t\tn = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t}\n\t\tdata = vector<T>(2 * n - 1, def);\n\t}\n\tvoid change(int i, T x) {\n\t\ti += n - 1;\n\t\tdata[i] = update(data[i], x);\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdata[i] = operation(data[i * 2 + 1], data[i * 2 + 2]);\n\t\t}\n\t}\n\tT query(int a, int b) {\n\t\treturn _query(a, b, 0, 0, n);\n\t}\n\tT operator[](int i) {\n\t\treturn data[i + n - 1];\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\tmodcalc(3000010);\n\tll n, m;\n\tcin >> n >> m;\n\tll ans = modhom(n, 3 * m);\n\tfor (ll i = 0; i < m; i++) {\n\t\tans = (ans - n * modhom(n - 1, i) % mod + mod) % mod;\n\t}\n\tfor (ll i = m + 1; i <= n; i++) {\n\t\tif ((3 * m - i) % 2 == 0) {\n\t\t\tans = (ans - modcomb(n, i)*modhom(n, (3 * m - i) / 2) % mod + mod) % mod;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "///Bismillahir Rahmanir Rahim\n#include<bits/stdc++.h>\n\n#define                           int                         long long\n#define                           fi                          first\n#define                           si                          second\n#define                           mp                          make_pair\n#define                           pb                          push_back\n#define                           pi                          pair<int,int>\n#define                           f(i,l,r)                    for(int i=l;i<=r;i++)\n#define                           rf(i,r,l)                   for(int i=r;i>=l;i--)\n#define                           done(i)                     cout<<\"done = \"<<i<<endl;\n#define                           fast                        ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\n\n\n\nusing namespace std;\n\nconst int inf=1e18;\nconst int M=100009;\nconst int N = 2e6 + 100;\nint mod = 998244353;\nnamespace Combi {\n    int fact[N], inv[N];\n\n    int bm(int b, int p, int m) {\n        if(p == 0) return 1%m;\n        int t = bm(b,p/2,m);\n        t = (1ll*t*t)%m;\n        if(p&1) return 1ll*t*b%m;\n        return t;\n    }\n\n    int C(int n, int r) {\n        if(n < 0 or r < 0 or r > n) return 0;\n        int ret = 1ll*fact[n]*inv[r]%mod;\n        ret = 1ll*ret*inv[n-r]%mod;\n        return ret;\n    }\n    // X1 + X2 + ... + Xvar = Sum\n    int no_of_eqns(int sum, int var) {\n        return C(sum+var-1,var-1); // Xi >= 0\n        // return C(sum-1,var-1); // Xi > 0\n    }\n    void init() {\n        fact[0] = 1;\n        for(int i = 1; i < N; i++) {\n            fact[i] = 1ll*fact[i-1]*i%mod;\n        }\n        inv[N-1] = bm(fact[N-1], mod-2, mod);\n        for(int i = N-2; i >= 0; i--) {\n            inv[i] = 1ll*inv[i+1]*(i+1)%mod;\n        }\n    }\n}\ninline int gun(int x,int y)\n{\n    int ret=(x*y)%mod;\n    if(ret<0)ret+=mod,ret=ret%mod;\n    return ret;\n}\ninline int sub(int x,int y)\n{\n    int ret=(x-y+mod)%mod;\n    if(ret<0)ret+=mod,ret=ret%mod;\n    return ret;\n}\nint yo(int sum,int n,int mx)\n{\n    int ret=0;\n    for(int od=0;od<=mx && od<=n && od<=sum;od++)\n    {\n        if((od&1)!=(sum&1))continue;\n        int x=gun(Combi::C(n,od),Combi::no_of_eqns((sum-od)/2,n));\n        ret=(ret+x)%mod;\n    }\n    return ret;\n}\n main()\n\n{\n    fast\n    Combi::init();\n    int n,m;\n    cin>>n>>m;\n    int ses=yo(3*m,n,m);\n    int bad=yo(m,n,m);\n    bad=sub(bad,Combi::no_of_eqns(m,n-1));\n    bad=gun(bad,n);\n    ses=sub(ses,bad);\n    cout<<ses<<endl;\n    return 0;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a) {\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'[';\n    for(const T &i: a) out<<i<<',';\n    out<<']';\n    return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out, const set<T>& a) {\n    out<<'{';\n    for(const T &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\ntemplate<class T, class S>\nostream &operator <<(ostream& out, const map<T,S>& a) {\n    out<<'{';\n    for(auto &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\ntemplate<ll MOD>\nstruct modint {\n    ll x;\n    modint(): x(0) {}\n    modint(ll y) : x(y>=0 ? y%MOD : y%MOD+MOD) {}\n    static constexpr ll mod() { return MOD; }\n    // e乗\n    modint pow(ll e) {\n        ll a = 1, p = x;\n        while(e > 0) {\n            if(e%2 == 0) {p = (p*p) % MOD; e /= 2;}\n            else {a = (a*p) % MOD; e--;}\n        }\n        return modint(a);\n    }\n    modint inv() const {\n        ll a=x, b=MOD, u=1, y=1, v=0, z=0;\n        while(a) {\n            ll q = b/a;\n            swap(z -= q*u, u);\n            swap(y -= q*v, v);\n            swap(b -= q*a, a);\n        }\n        return z;\n    }\n    // Comparators\n    bool operator <(modint b) { return x < b.x; }\n    bool operator >(modint b) { return x > b.x; }\n    bool operator<=(modint b) { return x <= b.x; }\n    bool operator>=(modint b) { return x >= b.x; }\n    bool operator!=(modint b) { return x != b.x; }\n    bool operator==(modint b) { return x == b.x; }\n    // Basic Operations\n    modint operator+(modint r) const { return modint(*this) += r; }\n    modint operator-(modint r) const { return modint(*this) -= r; }\n    modint operator*(modint r) const { return modint(*this) *= r; }\n    modint operator/(modint r) const { return modint(*this) /= r; }\n    modint &operator+=(modint r) {\n        if((x += r.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    modint &operator-=(modint r) {\n        if((x -= r.x) < 0) x += MOD;\n        return *this;\n    }\n    modint &operator*=(modint r) {\n    #if !defined(_WIN32) || defined(_WIN64)\n        x = x * r.x % MOD; return *this;\n    #endif\n        unsigned long long y = x * r.x;\n        unsigned xh = (unsigned) (y >> 32), xl = (unsigned) y, d, m;\n        asm(\n            \"divl %4; \\n\\t\"\n            : \"=a\" (d), \"=d\" (m)\n            : \"d\" (xh), \"a\" (xl), \"r\" (MOD)\n        );\n        x = m;\n        return *this;\n    }\n    modint &operator/=(modint r) { return *this *= r.inv(); }\n    // increment, decrement\n    modint operator++() { x++; return *this; }\n    modint operator++(signed) { modint t = *this; x++; return t; }\n    modint operator--() { x--; return *this; }\n    modint operator--(signed) { modint t = *this; x--; return t; }\n\n    template<class T>\n    friend modint operator*(T l, modint r) { return modint(l) *= r; }\n    template<class T>\n    friend modint operator+(T l, modint r) { return modint(l) += r; }\n    template<class T>\n    friend modint operator-(T l, modint r) { return modint(l) -= r; }\n    template<class T>\n    friend modint operator/(T l, modint r) { return modint(l) /= r; }\n    template<class T>\n    friend bool operator==(T l, modint r) { return modint(l) == r; }\n    template<class T>\n    friend bool operator!=(T l, modint r) { return modint(l) != r; }\n    // Input/Output\n    friend ostream &operator<<(ostream& os, modint a) { return os << a.x; }\n    friend istream &operator>>(istream& is, modint &a) { return is >> a.x; }\n    friend string to_frac(modint v) {\n        static map<ll, PII> mp;\n        if(mp.empty()) {\n            mp[0] = mp[MOD] = {0, 1};\n            FOR(i, 2, 1001) FOR(j, 1, i) if(__gcd(i, j) == 1) {\n                mp[(modint(i) / j).x] = {i, j};\n            }\n        }\n        auto itr = mp.lower_bound(v.x);\n        if(itr != mp.begin() && v.x - prev(itr)->first < itr->first - v.x) --itr;\n        string ret = to_string(itr->second.first + itr->second.second * ((int)v.x - itr->first));\n        if(itr->second.second > 1) {\n            ret += '/';\n            ret += to_string(itr->second.second);\n        }\n        return ret;\n    }\n};\nusing mint = modint<998244353>;\n\n// 前計算O(N) クエリO(1)\nmint combi(ll N, ll K) {\n    const int maxN=3000000; // !!!\n    static mint fact[maxN+1]={},factr[maxN+1]={};\n    if (fact[0]==0) {\n        fact[0] = factr[0] = 1;\n        FOR(i, 1, maxN+1) fact[i] = fact[i-1] * i;\n        factr[maxN] = fact[maxN].inv();\n        for(ll i=maxN-1; i>=0; --i) factr[i] = factr[i+1] * (i+1);\n    }\n    if(K<0 || K>N) return 0; // !!!\n    return factr[K]*fact[N]*factr[N-K];\n}\n\nset<vector<ll>> st;\nvoid dfs(vector<ll> v, ll m) {\n    if(m == 0) {\n        st.insert(v);\n        return;\n    }\n\n    REP(i, v.size()) REP(j, v.size()) {\n        if(i==j) continue;\n        v[i] += 2;\n        v[j] += 1;\n        dfs(v, m-1);\n        v[i] -= 2;\n        v[j] -= 1;\n    }\n}\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n, m;\n    cin >> n >> m;\n\n    // dfs(vector<ll>(n), m);\n    // cout << st.size() << endl;\n\n    mint ret = combi(3*m+n-1, n-1);\n    // cout << ret << endl;\n    FOR(i, 2*m+1, 3*m+1) {\n        ret -= combi(3*m-i+n-2, n-2) * n;\n        // cout << i << \" \" << 3*m-i+n-2 << \" \" << n-2 << \" \" << combi(3*m-i+n-2, n-2) << \" \" << n << endl;\n    }\n    // cout << ret << endl;\n    FOR(i, m+1, n+1) {\n        if((3*m-i)%2) continue;\n        ret -= combi(n, i) * combi((3*m-i)/2+n-1, n-1);\n        // cout << \"i=\" << i << \" \" << ret << \" \" << combi(n, i) << \" \" << po[(3*m-i)/2] << endl;\n    }\n\n    cout << ret << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\nusing ll = int64_t;\n\nconstexpr ll MOD = 998244353;\n\nclass Combination {\npublic:\n    Combination(ll max_num) {\n        fact_.resize(max_num + 1, 1);\n        inv_fact_.resize(max_num + 1, 1);\n        for (ll i = 2; i <= max_num; i++) {\n            fact_[i] = i * fact_[i - 1] % MOD;\n            inv_fact_[i] = MODpow(fact_[i], MOD - 2);\n            assert(fact_[i] * inv_fact_[i] % MOD == 1);\n        }\n    }\n    ll operator()(ll n, ll m) const {\n        if (m < 0 || m > n) return 0;\n        return fact_[n] * inv_fact_[n - m] % MOD * inv_fact_[m] % MOD;\n    }\nprivate:\n    ll MODpow(ll n, ll m) const {\n        ll result = 1;\n        while (m) {\n            if (m % 2 == 1) {\n                result *= n;\n                result %= MOD;\n            }\n\n            m /= 2;\n            n *= n;\n            n %= MOD;\n        }\n\n        return result;\n    }\n\n    vector<ll> fact_, inv_fact_;\n} comb(1e7);\n\n//サイズがnの非負整数配列で総和がsであり奇数の要素がm個以下であるものの場合の数\nll f(ll n, ll s, ll m) {\n    ll result = 0;\n\n    //奇数の数を全探索\n    for (ll a = s % 1; a <= min(n, m); a += 2) {\n        //まず奇数になるところを決める\n        ll curr_num = comb(n, a);\n\n        //上で選んだ箇所に1を入れたとする\n        //残りs - aをn個の要素にそれぞれ偶数となるように分ければ良い\n        //そのような分け方は結局(s - a) / 2をn個に分ける\n        //要素と仕切りのやつ\n        (curr_num *= comb((s - a) / 2 + n - 1, n - 1)) %= MOD;\n\n        (result += curr_num) %= MOD;\n    }\n\n    return result;\n}\n\nint main() {\n    ll N, M;\n    cin >> N >> M;\n\n    //最大値が2Mを超えないという条件を無視した数\n    ll ans = f(N, 3 * M, M);\n\n    //最大値が2Mを超えるものの数を引く\n    //2Mを超えるのは1箇所なので、まずそれをq_0として最後にN倍(q_0 != 0)\n    //q_0から2M引いたものを考えるとそれらは合計がMになるN要素の非負整数配列\n    //q_0 = 0となる場合を引けば求まる\n    ll sub = (f(N, M, M) + MOD - f(N - 1, M, M)) % MOD * N % MOD;\n    (ans += MOD - sub) %= MOD;\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#include<cassert>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\nconst long long mod = 998244353;\nconst long long inf = 1ll << 61;\ntypedef pair<int, int> P;\n\nint kj[2000005], kji[2000005];\n\nint modpow(int x, int n, int md) {\n\tif (!n)return 1;\n\tint res = modpow(x*x%md, n / 2, md);\n\tif (n & 1)res = res*x%md;\n\treturn res;\n}\nint comb(int n, int r) {\n\tif (n < 0 || r<0 || n < r)return 0;\n\tint ans = kj[n];\n\tans = ans*kji[r] % mod;\n\tans = ans*kji[n - r] % mod;\n\treturn ans;\n}\n\n\nvoid kjinit(int n) {\n\tkj[0] = 1;\n\trep(i, n) {\n\t\tkj[i + 1] = kj[i] * (i + 1);\n\t\tkj[i + 1] %= mod;\n\t}\n\trep(i, n)kji[i] = modpow(kj[i], mod - 2, mod);\n\n}\nsigned main() {\n\tint n, m; cin >> n >> m;\n\tkjinit(2000000);\n\tint ans = comb(3 * m + n - 1, n - 1);\n\tfor (int i = 2 * m + 1; i <= 3 * m; i++) {\n\t\tint t = n*comb(3*m-i+n-2, n - 2);\n\t\tt %= mod;\n\t\tans = ans + mod - t;\n\t\tans %= mod;\n\t}\n\tfor (int i = m + 1; i <= 3 * m; i++) {\n\t\tif (i > n)break;\n\t\tint M = 3 * m - i;\n\t\tif (M & 1)continue;\n\t\tint t = comb(n, i)*comb(M/2 + n-1, n - 1)%mod;\n\t\tans = ans + mod - t;\n\t\tans %= mod;\n\t}\n\t\n\n\tcout << ans%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define PB push_back\n#define ll long long\nusing namespace std;\nconst int mo=998244353;\nconst int N=3000005;\nint fac[N],inv[N],n,m;\nint C(int x,int y){\n\tif (x<0||y<0||y>x) return 0;\n\treturn 1ll*fac[x]*inv[y]%mo*inv[x-y]%mo;\n}\nint main(){\n\tfac[0]=inv[0]=inv[1]=1;\n\tFor(i,2,N-1) inv[i]=1ll*inv[mo%i]*(mo-mo/i)%mo;\n\tFor(i,1,N-1) inv[i]=1ll*inv[i-1]*inv[i]%mo;\n\tFor(i,1,N-1) fac[i]=1ll*fac[i-1]*i%mo;\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tint ans=(C(3*m+n-1,n-1)+mo-1ll*C(m-1+n-1,n-1)*n%mo)%mo;\n\tFor(j,m+1,m*3) if ((m*3-j)%2==0)\n\t\tans=(ans+mo-1ll*C(n,j)*C((m*3-j)/2+n-1,n-1)%mo)%mo;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define fr(i,x,y) for(int i=(x);i<=(y);i++)\n#define rf(i,x,y) for(int i=(x);i>=(y);i--)\n#define frl(i,x,y) for(int i=(x);i<(y);i++)\nusing namespace std;\nconst int N=3000002;\nconst int p=998244353;\nint n,m;\nLL mul[N],inv[N];\nLL ans;\n\nvoid read(int &x){ scanf(\"%d\",&x); }\nvoid read(LL &x){ scanf(\"%lld\",&x); }\n\nLL qpow(LL a,int n){\n\tLL ans=1;\n\tfor(LL sum=a;n;n>>=1,sum=sum*sum%p) if (n&1) ans=ans*sum%p;\n\treturn ans;\n}\n\nvoid init(){\n\tmul[0]=1;\n\tfrl(i,1,N) mul[i]=mul[i-1]*i%p;\n\tinv[N-1]=qpow(mul[N-1],p-2);\n\trf(i,N-2,0) inv[i]=inv[i+1]*(i+1)%p;\n}\n\nLL C(int n,int m){\n\tif (n<0||m<0||n-m<0) return 0;\n\treturn mul[n]*inv[m]%p*inv[n-m]%p;\n}\n\nvoid Add(LL &x,LL y){\n\tx+=y;\n\twhile(x<0) x+=p;\n\twhile(x>=p) x-=p;\n}\n\nint main(){\n\tread(n);read(m);\n\tinit();\n\tfr(i,0,m)\n\t if ((3*m-i)%2==0) Add(ans,C(n,i)*C((3*m-i)/2+n-1,n-1)%p);\n\tfr(i,0,m)\n\t if ((m-i)%2==0) Add(ans,-C(n,i)*C((m-i)/2+n-1,n-1)%p*n%p);\n\tfr(i,0,m)\n\t if ((m-i)%2==0) Add(ans,C(n-1,i)*C((m-i)/2+n-2,n-2)%p*n%p);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define pll pair <ll, ll>\n#define mp make_pair\n#define pyshnapyshnakaa ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define x first\n#define y second\n#pragma GCC optimize(\"O3\")\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n#define plll pair <ll, pair <ll, ll>>\n#define pllll pair <pair <ll, ll>, pair <ll, ll> >\n#define psl pair <string, ll>\n#define all(a) a.begin(), a.end()\n#define vvl vector <vector <ll> >\n \ntypedef long long ll;\n \ntypedef long double ld;\n \nusing namespace std;\n \nconst ll maxn = 2e6 + 100;\nconst ll mod = 998244353;\n\nll n, m, k, t;\n\nll F[maxn];\n\nll RF[maxn];\n\nll getc(ll n, ll k) {\n    return F[n] * RF[k] % mod * RF[n - k] % mod;\n}\n\ninline ll step(ll a, ll x) {\n    if (x == 0) {\n        return 1;\n    }\n    if (x % 2 == 1) {\n        return step(a, x - 1) * a % mod;\n    }\n    ll t = step(a, x / 2);\n    return t * t % mod;\n}\n\ninline ll del(ll a, ll b) {\n    return a * step(b, mod - 2) % mod;\n}\n\nint main() {\n    pyshnapyshnakaa;\n    ll q, w, e, a, b, c;\n    F[0] = 1;\n    for (q = 1; q < maxn; q++) {\n        F[q] = F[q - 1] * q % mod;\n    }\n    RF[maxn - 1] = del(1, F[maxn - 1]);\n    for (q = maxn - 2; q >= 0; q--) {\n        RF[q] = RF[q + 1] * (q + 1) % mod;\n    }\n    cin >> n >> m;\n    vector <ll> S(min(n, m) + 1);\n    ll ans = 0;\n    for (q = m % 2; q <= n && q <= m; q += 2) {\n        ll x = (3 * m - q) / 2;\n        ll y = n;\n        // cout << \"Q \" << q << endl;\n        S[q] = getc(x + y - 1, n - 1) * getc(n, q) % mod;\n        ll big = m;\n        ll x1 = x - big;\n        // ll dans = 0;\n        if (x1 >= 0) {\n            ll dans = q * getc(x1 + y - 1, n - 1) % mod * getc(n, q) % mod;\n            // cout << \"DANS1 \" << dans << endl;\n            S[q] = (S[q] - dans + mod) % mod;\n        }\n        big = m + 1;\n        x1 = x - big;\n        // ll dans = 0;\n        if (x1 >= 0) {\n            ll dans = (n - q) * getc(x1 + y - 1, n - 1) % mod * getc(n, q) % mod;\n            // cout << \"DANS2 \" << dans << endl;\n            S[q] = (S[q] - dans + mod) % mod;\n        }\n        // cout << x << \" \" << y << \" \" << S[q] << endl;\n        ans += S[q];\n        ans %= mod;\n    }\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 3 * 1000 * 1000 + 17;\nconst int MOD = 1000 * 1000 * 1000 + 7;\nconst int M = 998244353;\n\nint n, m;\nlong long F[N];\n\nbool read() {\n    if (!(cin >> n >> m))\n        return false;\n\n    return true;\n}\n\nlong long naive() {\n    vector< vector< vector<long long> > >\n        dp(n + 1, vector< vector<long long> >(3 * m + 1, vector<long long>(n + 1, 0ll)));\n\n    dp[0][0][0] = 1;\n\n    for (int i = 0; i < n; ++i)\n        for (int s = 0; s <= 3 * m; ++s)\n            for (int j = 0; j <= i; ++j)\n                for (int c = 0; c <= 2 * m && c + s <= 3 * m; ++c) {\n                  \tif (j + c % 2 > n)\n                      continue;\n                    dp[i + 1][s + c][j + c % 2] += dp[i][s][j];\n                    dp[i + 1][s + c][j + c % 2] %= M;\n                }\n\n    auto res = 0ll;\n\n    for (int j = 0; j <= 2 * m && j <= n; ++j)\n        res = (res + dp[n][3 * m][j]) % M;\n\n    return res;\n}\n\nlong long bpow(long long a, int n, long long M) {\n    auto res = 1ll;\n\n    for (; n > 0; n /= 2, a = a * a % M)\n        if (n & 1)\n            res = res * a % M;\n\n    return res;\n}\n\nlong long rev(long long x) { return bpow(x, M - 2, M); }\n\nlong long binomial(int n, int k) {\n    return n < 0 || k < 0 || k > n ? 0ll : F[n] * rev(F[k] * F[n - k] % M) % M;\n}\n\nlong long gay(int s, int n) {\n    return s == 0 ? 1ll : binomial(s + n - 1, n - 1);\n}\n\nvoid solve() {\n    /*F[0] = 1ll;\n\n    for (int i = 1; i < N; ++i)\n        F[i] = i * F[i - 1] % M;\n\n    auto res = gay(3 * m, n);\n\n    for (int mx = 2 * m + 1; mx <= 3 * m; ++mx) {\n        auto cur = gay(3 * m - mx, n - 1) * n % M;\n        res = (res + M - cur) % M;\n    }\n\n    for (int odd = 2 * m + 1; odd <= 3 * m; ++odd)\n        if ((3 * m - odd) % 2 == 0) {\n            auto cur = gay((3 * m - odd) / 2, n) * binomial(n, odd) % M;\n            res = (res + M - cur) % M;\n        }\n\n    cout << res << endl;*/\n    cout << naive() << endl;\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (read())\n        solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits>\n#include <cfenv>\n#include <cmath>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cstring>\n#include <map>\n#include <stack>\n#include <set>\n#include <tuple>\n#include <queue>\n#include <vector>\n#include <cmath>\n#include <random>\n#include <math.h>\n#include <list>\n#include <random>\n#include <functional>\n\n\n#define FOR(i, a, b) for(int (i) = (a); (i) < (b); ++(i))\n#define REP(i, n) FOR(i, 0, n)\n#define rREP(i, n) for(int (i) = (n) - 1; (i) >= 0; --(i))\n#define ALL(TheArray) TheArray.begin(), TheArray.end()\n\nusing lli = long long int;\nusing pii = std::pair<int, int>;\n\ntemplate <class T> inline bool chmax(T& a, T b){\n    if(a < b){a = b; return true;}\n    return false;\n}\ntemplate <class T> inline bool chmin(T& a, T b){\n    if(a > b){a = b; return true;}\n    return false;\n}\n\n\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n// constexpr version : N が clang++ : 3e5くらいまでok,  g++ : 2e6くらいまでok\ntemplate <int N, long long int mod>\nstruct CombinationMod{\nprivate:\n    using lli = long long int;\npublic:\n    lli Power[N+1], Inverse[N+1], powInverse[N+1];\n    /* A*Co*erは 古いので, arrayがconstexprとして使えない\n    std::array<lli, N+1> Power{};\n    std::array<lli, N+1> Inverse{};\n    std::array<lli, N+1> powInverse{};\n    */\n\n    constexpr CombinationMod():Power(), Inverse(), powInverse(){\n        Power[0] = 1; Inverse[0] = 1; powInverse[0] = 1;\n        for(int x = 1; x <= N; ++x) Power[x] = (Power[x-1] * x) % mod;\n        powInverse[N] = inverse(Power[N]);\n        for(int x = N; x > 0; --x) powInverse[x-1] = (powInverse[x] * x) % mod;\n        for(int x = 1; x <= N; ++x) Inverse[x] = (Power[x-1] * powInverse[x]) % mod;\n    }\n    constexpr void swap(lli &a, lli &b) const {\n        a ^= b; b ^= a; a ^= b;\n    }\n    constexpr lli inverse(lli a) const noexcept{\n        lli b = mod, u = 1, v = 0;\n        while (b != 0) { \n            lli t = a / b; a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        u %= mod; if (u < 0) u += mod;\n        return u;\n    }\n    // nCkを求める関数 : n < k の入力に注意せよ\n    inline lli combination(int n, int k) const noexcept{\n        if(n < k or k < 0) return 0;\n        return ((Power[n] * powInverse[k] % mod) * powInverse[n-k]) % mod;\n    }\n};\n\n\n\n\n/* fn(x, y) := 2加算をx回, 1加算をy回することによって得られる場合の数\n   このとき, fn(M, M)が求める答えの近似になる | 条件緩和　-> 加算をそれぞれ独立に考えられる\n   追加制約として, 「全てのインデックスについて選ばれた回数が高々M回」を課す\n   ---> 再帰で解くのは少し厳しそう; 何かいい言い換えはないか？\n   それぞれの操作の特徴は何か？\n   １加算 -> 偶奇反転, 2回で2加算と同一視\n   ２加算 -> 偶奇普遍\n   追加制約を考えれば奇数の数は高々M個 ; なんか良さげな条件 | いや扱いにくいか？\n   操作終了後の総和は 3M である\n   最大要素は2Mでバウンドされる\n   こんな感じの性質を満たしそう(このくらいしか思いつかない : 場所に制約がないので一松模様なども不可)\n   逆にこの条件で構成可能か？可能っぽい気がするけど気もしない...\n        大きい数から２加算の操作を割り当てると考えると, 残りの総和は高々M\n        2M - K の山に関して (K ≤ M) 他の山の最大は K であるから操作は M - K回行われMを超えない\n        あまったところに1加算を割り当てれば良い、そしてこれはMを超えない\n        奇数をあらかじめ選んでから残りの数(偶数)の配分を決定ればいい -> よし！\n 　雑に数えると\n    ∑_k nCk * H((3M - k) / 2, n) | for all k s.t. 0 ≤ k ≤ M , (3M - k) % 2 == 0\n   最大山が2M以下が考慮されていない -> その数を除去する\n   for all i in 1...M, 残り M - i の問題について考えられる | この最大山の選び方は M通り！\n*/\n\nconstexpr int _M = 2e6 + 5e5;\nconstexpr int mod = 998244353;\nconstexpr CombinationMod<_M, mod> Comb;\n\n\nint main(void){\n    int n, m; scanf(\"%d%d\", &n, &m);\n    lli P = 0;\n    lli tm = 3 * m, even = 0;\n    if(tm & 1) tm--, even++; tm /= 2;\n    while(tm >= 0 and n >= even){\n        P += Comb.combination(n, even) * Comb.combination(n + tm - 1, tm);\n        tm--; even += 2;\n    }\n    lli Q = 0;\n    for(int i = 1; i <= m; ++i) (Q += Comb.combination(m - i + n - 2, m - i)) %= mod;\n    (Q *= n) %= mod; \n    P -= Q; if(P < 0) P += mod;\n    printf(\"%lld\\n\", P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { -1,0, 1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// #define mp make_pair\n//#define endl '\\n'\n\n\nconst int MAXN = 2522222;\n\nll fact[2522222];\nll rfact[2522222];\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n  ll a = 1;\n  while (p) {\n    if (p % 2)\n      a = a*x%M;\n    x = x*x%M;\n    p /= 2;\n  }\n  return a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n  return mod_pow(a, M - 2, M);\n}\n\nvoid set_fact(ll n, ll M = MOD) {\n  fact[0] = fact[1] = rfact[0] = rfact[1] = 1;\n  for (ll i = 2; i <= n; i++) {\n    fact[i] = i * fact[i - 1] % M;\n    rfact[i] = mod_inverse(fact[i], M);\n  }\n}\n\n//http://drken1215.hatenablog.com/entry/2018/06/08/210000\n//nが大きくfactが計算できないときのほかの計算方法について書いてある\nll nCr(ll n, ll r, ll M = MOD) {\n  if (r > n) return 0;\n  ll ret = fact[n];\n  ret = (ret*rfact[r]) % M;\n  ret = (ret*rfact[n - r]) % M;\n  return ret;\n}\n\nll nHr(ll n, ll r) {\n  return nCr(n+r-1, r);\n}\n\nll guchoku(ll n, ll m) {\n  vll dp(n + 1, vl(3*m + 1));\n\n  dp[0][0] = 1;\n  rep (i, n) {\n    rep (j, 3*m + 1) {\n      for (int add = 0; add <= 2*m; add++) {\n        if (j + add > 3*m) break;\n        (dp[i + 1][j + add] += dp[i][j]) %= MOD;\n      }\n    }\n  }\n  return dp[n][3*m];\n  \n\n}\n\nint main() {\n  ll n, m;\n  cin >> n >> m;\n  set_fact(2522221);\n  \n  ll zen = nHr(3*m + 1, n - 1);\n\n  for (int x = 0; x < m; x++) {\n    ll sub = nHr(x + 1, n - 1);\n    if (3*m - 2*x > n) {\n      sub = 0;\n    }\n    else {\n      sub *= nCr(n, 3*m - 2*x);\n      sub %= MOD;\n    }\n    zen -= sub;\n  }\n\n  for (int x = 2*m + 1; x <= 3*m; x++) {\n    ll sub = n;\n    ll m2 = 3*m - x;\n    sub = sub * nHr(m2 + 1, (n - 1) - 1) % MOD;\n    (zen -= sub) %= MOD;\n  }\n\n  zen = (zen + MOD) % MOD;\n  cout << zen << endl;\n\n  //DEBUG(guchoku(n, m));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\n#define N_ 3010000\nusing namespace std;\nint n, m;\nmap<vector<int>, int>Map;\nlong long F[N_], InvF[N_], Mod = 998244353;\nlong long T[N_];\nvector<int>TP;\nlong long Pow(long long a, long long b) {\n\tlong long r = 1;\n\twhile (b) {\n\t\tif (b & 1)r = r * a%Mod;\n\t\ta = a * a%Mod; b >>= 1;\n\t}\n\treturn r;\n}\nlong long Comb(long long a, long long b) {\n\tif (a < b || b < 0)return 0ll;\n\treturn F[a] * InvF[b] % Mod*InvF[a - b] % Mod;\n}\nlong long H(int a, int b) {\n\tif (a == 0 && b == 0)return 1ll;\n\tif (a == 0)return 0ll;\n\treturn F[a + b - 1] * InvF[b] % Mod * InvF[a - 1] % Mod;\n}\nint r2 = 0;\nvoid DFS(int a) {\n\tif (a == 0) {\n\t\tif (Map.count(TP))return;\n\t\tMap[TP] = 1;\n\t\tr2++;\n\t\treturn;\n\t}\n\tint i, j;\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (i != j) {\n\t\t\t\tTP[i]++;\n\t\t\t\tTP[j] += 2;\n\t\t\t\tDFS(a - 1);\n\t\t\t\tTP[i]--;\n\t\t\t\tTP[j] -= 2;\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tint i;\n\tF[0] = 1;\n\tfor (i = 1; i < N_; i++) F[i] = F[i - 1] * i%Mod;\n\tInvF[N_ - 1] = Pow(F[N_ - 1], Mod - 2);\n\tfor (i = N_ - 1; i >= 1; i--)InvF[i - 1] = InvF[i] * i%Mod;\n\tlong long res = H(n, 3 * m);\n\tres = (res - n * H(n, m - 1) % Mod + Mod) % Mod;\n\tlong long ss = 0;\n\tfor (i = m + 1; i <= 3 * m; i++) {\n\t\tif (i > n || 3*m%2!=i%2)continue;\n\t\tlong long t = Comb(n, i) * H(n, (3 * m - i)/2) % Mod;\n\t\tres = (res - t + Mod) % Mod;\n\t}\n\tprintf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define mod 998244353\n\nusing namespace std;\n\nllint n, m;\nconst int FACT_MAX = 4000005;\nllint fact[FACT_MAX], fact_inv[FACT_MAX];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < FACT_MAX; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfact_inv[FACT_MAX-1] = modpow(fact[FACT_MAX-1], mod-2);\n\tfor(int i = FACT_MAX-2; i >= 0; i--){\n\t\tfact_inv[i] = fact_inv[i+1] * (i+1) % mod;\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nllint calc(llint s, llint x)\n{\n\t//cout << s << \" \" << x << endl;\n\tllint ret = 0;\n\tfor(int i = 0; i <= min(s, min(n, m)); i++){\n\t\tif(s%2 != i%2) continue;\n\t\tllint tmp = 0, rem = (s-i)/2, rem2;\n\t\tfor(int j = 0; j <= x; j++){\n\t\t\tif(j > n-i || x-j > i) continue;\n\t\t\tfor(int u = 0; u <= 3; u++){\n\t\t\t\tif(u > j) continue;\n\t\t\t\tfor(int v = 0; v <= 3; v++){\n\t\t\t\t\tif(v > x-j) continue;\n\t\t\t\t\tfor(int w = 0; w <= 3; w++){\n\t\t\t\t\t\tif(w > n-x) continue;\n\t\t\t\t\t\trem2 = rem - (m/2+1)*u - ((m-1)/2+1)*v - m/2*w;\n\t\t\t\t\t\tif(rem2 < 0) continue;\n\t\t\t\t\t\t//cout << i << \" \" << j << \" \" << k << \" \" << l << \" \" << rem2 << endl;\n\t\t\t\t\t\tllint val = comb(rem2+n-1, n-1) * comb(n, i) % mod * comb(n-i, j) % mod * comb(i, x-j) % mod\n\t\t\t\t\t\t* comb(j, u) % mod * comb(x-j, v) % mod * comb(n-x, w) % mod;\n\t\t\t\t\t\tif((u+v+w) % 2) tmp += mod - val, tmp %= mod;\n\t\t\t\t\t\telse tmp += val, tmp %= mod;\n\t\t\t\t\t\t//cout << val << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret += tmp, ret %= mod;\n\t\t//cout << ret << endl;\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> n >> m;\n\tmake_fact();\n\t\n\tif(m == 1){\n\t\tcout << comb(n, 2) * 2 % mod << endl;\n\t\treturn 0;\n\t}\n\t\n\tllint ans = 0;\n\tif(n >= 3 && (m % 2 == 0 || m >= 3)) ans += comb(n, 3);\n\t//cout << ans << endl;\n\t\n\tfor(int i = 0; i < 3; i++){\n\t\tans += calc((3-i)*m, i) % mod;\n\t\tans %= mod;\n\t\t//cout << ans << endl;\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<tuple>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\n\nint n,c=0;\nbool flag=false;\n\nvoid solve(){\n    cin >> n;\n    int n_=n;\n    while (n_>1){\n        if (n_%2==1) flag=true;\n        n_/=2;\n        c+=1;\n    }\n    if (!flag) {\n        cout << \"No\" << endl;\n        return;\n    }\n    vector<P> ans;\n    ans.push_back(P(3,n+1));\n    for(int i=2;i<n;i+=2){\n        ans.push_back(P(i,i+1));\n        ans.push_back(P(1,i));\n        ans.push_back(P(i+n+1,1));\n        ans.push_back(P(i+n,i+n+1));\n    }\n    if (n%2==0) {\n        ans.push_back(P(n,1));\n        ans.push_back(P(2*n,1+n^(1<<(c+1))));\n    }\n\n    cout << \"Yes\" << endl;\n    rep(i,ans.size()) cout << ans[i].first << \" \" << ans[i].second << endl;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MIN_INT -2147483648\n#define MAX_INT 2147483647\n#define MIN_LONG -9223372036854775808L\n#define MAX_LONG 9223372036854775807L\n\n#define long long long int\n\nusing namespace std;\n\n// @author: pashka\n\n#define MOD 998244353\n\nlong sum(long a, long b) { return (a + b) % MOD; }\nlong sub(long a, long b) { return (a - b + MOD) % MOD; }\nlong mult(long a, long b) { return (a * b) % MOD; }\n\nlong power(long a, long b) {\n    long res = 1;\n    while (b > 0) {\n        if (b & 1) {\n            res = mult(res, a);\n        }\n        a = mult(a, a);\n        b >>= 1;\n    }\n    return res;\n}\n\nlong inv(long a) {\n    return power(a, MOD - 2);\n}\n\nvector<long> fact_precalc(1, 1);\nvector<long> inv_fact_precalc(1, 1);\n\nvoid ensure_fact(int n) {\n    while (n >= (int)fact_precalc.size()) {\n        fact_precalc.push_back(mult(fact_precalc.back(), fact_precalc.size()));\n        inv_fact_precalc.push_back(inv(fact_precalc.back()));\n    }\n}\n\nlong fact(int n) {\n    ensure_fact(n);\n    return fact_precalc[n];\n}\n\nlong inv_fact(int n) {\n    ensure_fact(n);\n    return inv_fact_precalc[n];\n}\n\nlong calc_c(int n, int k) {\n    if (n < 0 || k < 0 || k > n)\n        return 0;\n    long res = fact(n);\n    res = mult(res, inv_fact(k));\n    res = mult(res, inv_fact(n - k));\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    long n, m;\n    cin >> n >> m;\n\n    long res = 0;\n    for (int k = 0; k <= min(n, m); k++) {\n        if ((3 * m - k) % 2 == 1) continue;\n        long x = calc_c((3 * m - k) / 2 + n - 1, n - 1);\n        x = sub(x, mult(calc_c((3 * m - k - (2 * m + 2)) / 2 + n - 1, n - 1), n - k));\n        x = sub(x, mult(calc_c((3 * m - k - (2 * m)) / 2 + n - 1, n - 1), k));\n        res = sum(res, mult(x, calc_c(n, k)));\n    }\n    cout << res << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint const nmax = 2000000;\nint const modulo = 998244353;\n\nint fact[1 + nmax], inv[1 + nmax];\n\nvoid gcd(int a, int b, int &x, int &y){\n  if(b == 0){\n    x = 1;\n    y = 0;\n  } else {\n    gcd(b, a % b, x, y);\n    int aux = x;\n    x = y;\n    y = aux - a / b * y;\n  }\n}\n\nvoid computefact(){\n  fact[0] = 1;\n  for(int i = 1; i <= nmax; i++)\n    fact[i] = 1LL * fact[i - 1] * i % modulo;\n  int x, y;\n  gcd(fact[nmax], modulo, x, y);\n  x %= modulo;\n  if(x < 0)\n    x += modulo;\n  inv[nmax] = x;\n  for(int i = nmax - 1; 0 <= i; i--)\n    inv[i] = 1LL * inv[i + 1] * (i + 1) % modulo;\n}\n\nint comb(int n, int k){\n  if(0 <= k && k <= n)\n    return 1LL * fact[n] * inv[k] % modulo * inv[n - k] % modulo;\n  return 0;\n}\n\nint combrep(int n, int k){\n  if(n < 0 || k < 0)\n    return 0;\n  return comb(n + k - 1, k);\n}\n\nint main()\n{\n  computefact();\n  int n, m;\n  cin >> n >> m;\n  int result = 0;\n  for(int odd = m % 2; odd <= m; odd += 2) {\n    result += 1LL * comb(n, odd) * combrep(n, (m * 3 - odd) / 2) % modulo;\n    if(modulo <= result)\n      result -= modulo;\n  }\n\n  int result2 = 0;\n  for(int odd = m % 2; odd <= m; odd += 2) {\n    if(1 <= odd) {\n      result2 += 1LL * comb(n - 1, odd - 1) * combrep(n, (m - odd) / 2) % modulo;\n      if(modulo <= result2)\n        result2 -= modulo;\n    }\n    result2 += 1LL * comb(n - 1, odd) * combrep(n, (m - 2 - odd) / 2) % modulo;\n    if(modulo <= result2)\n      result2 -= modulo;\n  }\n\n  result2 = 1LL * result2 * n % modulo;\n\n  result = (modulo + result - result2) % modulo;\n  cout << result;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#define random_shuffle(...) shuffle(__VA_ARGS__, rng)\n#define rand() rng()\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nconst int N = 5111111;\nlong long fact[N], inv[N], invfact[N];\nconst int mod = 998244353;\n\nlong long C(int n, int k) {\n\tif (n < k) {\n\t\treturn 0;\n\t}\n\treturn fact[n] * invfact[k] % mod * invfact[n - k] % mod;\n}\n\nint main() {\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n\tfact[0] = invfact[0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tinv[i] = (i == 1) ? 1 : mod - inv[mod % i] * (mod / i) % mod;\n\t\tfact[i] = fact[i - 1] * i % mod;\n\t\tinvfact[i] = invfact[i - 1] * inv[i] % mod;\n\t}\n\n\tint n = nxt(), m = nxt();\n\tlong long ans = C(3 * m + n - 1, n - 1) - n * C(m + n - 2, n - 1);\n\n\tfor (int i = m + 1; i <= n; ++i) {\n\t\tif (i % 2 != m % 2) {\n\t\t\tcontinue;\n\t\t}\n\t\tlong long tmp = C((3 * m - i) / 2 + n - 1, n - 1) * C(n, i) % mod;\n\t\tans -= tmp;\n\t}\n\n\tans %= mod;\n\tcout << (ans + mod) % mod << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\nconst int oo=2139063143;\nconst int N=30010000;\nconst int P=998244353;\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\n//char buf[1<<24],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ntemplate <typename T>\ninline void sc (T &x)\n{\n    x=0; static int p; p=1; static char c; c=getchar();\n    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }\n    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }\n    x*=p;\n}\ntemplate <typename T>\ninline void print (T x)\n{\n\tif (x< 0) putchar('-'),x=-x;\n\tif (x>=10) print(x/10);\n\tputchar(x%10+'0');\n}\ntemplate <typename T>\ninline void pr (T x) { print(x),putchar('\\n'); }\nvoid del(int &x,int y) { x+=y; x=x>=P?x-P:x; }\nint ksm (int a,int b)\n{\n\tint ans=1;\n\twhile (b)\n\t{\n\t\tif (b&1) ans=(LL)ans*a%P;\n\t\ta=(LL)a*a%P,b>>=1;\n\t}\n\treturn ans;\n}\nint jc[N],inv[N];\nvoid init (int n)\n{\n\tjc[0]=1;\n\tfor (int i=1; i<=n; i++)\n\t\tjc[i]=(LL)i*jc[i-1]%P;\n\tinv[n]=ksm (jc[n],P-2);\n\tfor (int i=n-1; i>=0; i--)\n\t\tinv[i]=(LL)inv[i+1]*(i+1)%P;\n}\nint C(int n,int m) { return (LL)jc[n]*inv[m]%P*inv[n-m]%P; }\nint T(int n,int m) { return C(n+m-1,m-1); }\nint calc (int n,int odd,int sum)\n{\n\tint ans=0;\n\tfor (int i=odd; i>=0; i-=2)\n\t{\n\t\tint las=sum-i;\n\t\tint g=(LL)C(n,i)*T(las>>1,n)%P;\n\t\tdel(ans,g);\n\t}\n\treturn ans;\n}\nint main ()\n{\n\t// freopen (\".in\",\"r\",stdin);\n\t// freopen (\".out\",\"w\",stdout);\n\tint n,m; sc(n),sc(m);\n\tinit (n+m*2);\n\tint ans=calc (n,m,3*m);\n\tint g=(LL)n*calc (n,m-1,m-1)%P;\n\tdel(ans,P-g);\n\tpr(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nconst ll MOD = 998244353;\n\nstruct Combination\n{\n    int maxn;\n    vector<ll> fmemo;\n    vector<ll> imemo;\n    vector<ll> ifmemo;\n    \n    ll modpow(ll x, ll n){\n        ll res = 1;\n        ll mul = x;\n        while(n){\n            if(n % 2) res = res * mul % MOD;\n            mul = mul * mul % MOD;\n            n /= 2;\n        }\n        return res;\n    }\n\n    Combination(int maxn) : maxn(maxn){\n        fmemo.resize(maxn + 1);\n        imemo.resize(maxn + 1);\n        ifmemo.resize(maxn + 1);\n        for(ll i = 1; i <= maxn; i++){\n            imemo[i] = modpow(i, MOD - 2);\n        }\n    }\n\n    ll fact(ll n){\n        if(n == 0) return 1;\n        if(fmemo[n]) return fmemo[n];\n        return fmemo[n] = n * fact(n - 1) % MOD;\n    }\n\n    ll ifact(ll n){\n        if(n == 0) return 1;\n        if(ifmemo[n]) return ifmemo[n];\n        return ifmemo[n] = imemo[n] * ifact(n - 1) % MOD;\n    }\n\n    ll com(ll n, ll k){\n        if(k > n) return 0;\n        if(k == n || k == 0) return 1;\n        return (fact(n) * ifact(k) % MOD) * ifact(n - k) % MOD;\n    }\n};\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    Combination c(m * 3 + n + 1);\n    ll ans = c.com(n + m * 3 - 1, n - 1);\n    ans = (ans + MOD - c.com(n + m - 2, n - 1) * n % MOD) % MOD;\n    for(int i = m + 1; i <= max(n, m * 3); i++){\n        if((m * 3 - i) % 2) continue;\n        ans = (ans + MOD * 2 - c.com(n, i) * c.com(n + (m * 3 - i) / 2 - 1, n - 1) % MOD) % MOD;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\nll mod=998244353;\n\nll fac[3000010];\n \nll modinv(ll a){\n    ll b=mod,u=1,v=0;\n    while(b){\n        ll t=a/b;\n        a-=t*b; swap(a,b);\n        u-=t*v; swap(u,v);\n        }\n        u%=mod;\n        if(u<0) u+=mod;\n    return u;\n}\n \nvoid modfac(){\n    fac[0]=1;\n    for(ll i=1;i<3000010;i++){\n        fac[i]=(fac[i-1]*i)%mod;\n    }\n}\n \nll modperm(ll n,ll k){\n    if(n<0||k<0||n<k) return 0;\n    else return (fac[n]*modinv(fac[n-k]))%mod;\n}\n \nll modcomb(ll n,ll k){\n    if(n<0||k<0||n<k) return 0;\n    else return ((fac[n]*modinv(fac[k]))%mod*modinv(fac[n-k]))%mod;\n}\n \nll modpow(ll a,ll b){\n  ll ans=1;\n  a%=mod;\n  while(b){\n    if(b&1) ans=ans*a%mod;\n    a=a*a%mod;\n    b>>=1;\n  }\n  return ans;\n}\n\nll dp[1000000];\n\nint main(){\n  modfac();\n  ll n,m;\n  cin >> n >> m;\n  ll ans=modcomb(n+3*m-1,3*m);\n  for(ll i=0;i<m;i++){\n    ans=(ans-n*modcomb(n+i-2,i)%mod+mod)%mod;\n  }\n  for(ll i=m+1;i<=n;i++){\n    ll x=i-m;\n    if(x%2==0){\n      x=(x+1)*x/2;\n      ans=(ans+mod-x*modcomb(n+1,n-i)%mod*modcomb(n-x+1,n-i-x+1)%mod)%mod;\n    }\n    else{\n      x=(x+1)*x/2;\n      ans=(ans+x*modcomb(n+1,n-i)%mod*modcomb(n-x+1,n-i-x+1)%mod)%mod;\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 2500010, P = 998244353;\nint n, m, fact[maxn], inv[maxn];\n\nint qp(int x, int y) {\n    int z = 1;\n    for (; y; y >>= 1, x = 1LL * x * x % P) {\n        if (y & 1) z = 1LL * z * x % P;\n    }\n    return z;\n}\n\nint C(int x, int y) {\n    return 1LL * fact[x] * inv[x - y] % P * inv[y] % P;\n}\n\nint main() {\n    for (int i = fact[0] = inv[0] = 1; i < maxn; i++) {\n        inv[i] = qp(fact[i] = 1LL * i * fact[i - 1] % P, P - 2);\n    }\n    scanf(\"%d %d\", &n, &m);\n    int ans = (C(3 * m + n - 1, n - 1) - 1LL * n\n        * C(m + n - 2, n - 1) % P + P) % P;\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=1000000,mod=998244353;\n\nint add(int a,int b,int p=mod){return a+b>=p?a+b-p:a+b;}\nint sub(int a,int b,int p=mod){return a-b<0?a-b+p:a-b;}\nint mul(int a,int b,int p=mod){return (LL)a*b%p;}\nvoid sadd(int &a,int b,int p=mod){a=add(a,b,p);}\nvoid ssub(int &a,int b,int p=mod){a=sub(a,b,p);}\nvoid smul(int &a,int b,int p=mod){a=mul(a,b,p);}\n\nint n,m;\n\nvoid into(){\n  scanf(\"%d%d\",&n,&m);\n}\n\nint inv[N*3+9],fac[N*3+9],ifac[N*3+9];\n\nvoid Get_inv(){\n  inv[1]=1;\n  fac[0]=fac[1]=1;\n  ifac[0]=ifac[1]=1;\n  for (int i=2,lim=n+m*2;i<=lim;++i){\n\tinv[i]=mul(mod-mod/i,inv[mod%i]);\n\tfac[i]=mul(fac[i-1],i);\n\tifac[i]=mul(ifac[i-1],inv[i]);\n  }\n}\n\nint Get_c(int n,int m){return n<m||m<0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));}\n\nint ans;\n\nvoid Get_ans(){\n  for (int i=0;i<=m&&i<=n;++i){\n\tif (i&1^m&1) continue;\n\tint t=3*m-i>>1;\n\tsadd(ans,mul(Get_c(n,i),Get_c(n+t-1,n-1)));\n\tssub(ans,mul(n,mul(Get_c(n-1,i),Get_c(n+t-m-2,n-1))));\n\tssub(ans,mul(n,mul(Get_c(n-1,i-1),Get_c(n+t-m-1,n-1))));\n  }\n}\n\nvoid work(){\n  Get_inv();\n  Get_ans();\n}\n\nvoid outo(){\n  printf(\"%d\\n\",ans);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef _debug\n#define out(i) cout << #i << ' ' << i << ' '\n#else \n#define out(i) //\n#endif\nusing ll = long long;\nusing ull = unsigned long long;\nconst int maxn = 500001;\nconst int maxm = 1000001;\nconst int tomod = 998244353;\nll form(ll a){\n\tll v = a % tomod;\n\treturn v < 0 ? v + tomod : v;\n}\nll inv[maxm], fa[maxm];\nvoid init(){\n\tfa[0] = fa[1] = 1;\n\tinv[0] = inv[1] = 1;\n\tfor(int i = 2;i < maxm;++i){\n\t\tfa[i] = form(fa[i - 1] * (ll)i);\n\t\tinv[i] = form((tomod - tomod / i) * inv[tomod % i]);\n\t}\n\tfor(int i = 2;i < maxm;++i)inv[i] = form(inv[i] * inv[i - 1]);\n}\nll cof(int a, int b){\n\treturn form(fa[a] * form(inv[b] * inv[a - b]));\n} \nll solve(int n, int k, const int max_odd){\n\tll res = 0;\n\tfor(int o = 0;o <= max_odd;++o){\n\t\tif(((k-o)^1)&1){\n\t\t\tres = form(res + form(\n\t\t\t\tcof(n, o) * \n\t\t\t\tcof((k-o)/2+n-1, n-1)\n\t\t\t));\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tinit();\n\tll k, n;\n\tcin >> n >> k;\n\tcout << form(solve(n, k * 3, min(n, k)) - form(n * (solve(n, k, min(n, k)) - solve(n - 1, k, min(n - 1, k))))) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing MI = unsigned int;\nusing MLL = unsigned long long;\nunsigned int M = 998244353;\n\nMI msub(MI a, MI b) { return (a + (M - b)) % M; }\nMI mmul(MI a, MI b) { return ((MLL)a * (MLL)b) % M; }\nMI mdiv1(MI b) {\n\tstack<pair<MI, pair<MI, MI>>> divbuf;\n\tMI buf = M;\n\twhile (b != 0) { divbuf.push(make_pair(buf / b, make_pair(buf, b))); buf %= b; swap(b, buf); }\n\tpair<MI, MI> m = make_pair(buf, buf);\n\twhile (!divbuf.empty()) {\n\t\tm.second = msub(m.second, mmul(m.first, divbuf.top().first));\n\t\tdivbuf.pop(); swap(m.first, m.second);\n\t}\n\treturn m.first % M;\n}\nvector<MI> fcm = { 1 };\nMI fc(MI n) {\n\tMLL b = 1;\n\tfor (size_t i = fcm.size(); i <= n; i++) {\n\t\tfcm.push_back(mmul(fcm[i-1], i));\n\t}\n\treturn fcm[n];\n}\nMI C(MI n, MI m) {\n\treturn mmul(fc(n), mdiv1(mmul(fc(n - m), fc(m))));\n}\n\nint main() {\n\tMI n, m; cin >> n >> m;\n\tMI a = C(n + 3 * m - 1, 3 * m);\n\tMI b = C(n + m - 2, m - 1);\n\n\tcout << msub(a, mmul(b, n)) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#define _GLIBCXX_DEBUG\n#endif\n#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,s,t) for(ll i = (ll)(s); i < (ll)(t); i++)\n#define rrep(i,s,t) for(ll i = (ll)(s-1);(ll)(t) <= i; i--)\n#define all(x) (x).begin(), (x).end()\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> Pll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\nconstexpr ll INF = numeric_limits<ll>::max()/4;\nconstexpr ll n_max = 3e6+10;\n#define int ll\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\nstring to_string(const string &s) {return '\"' + s + '\"';}\nstring to_string(const char *c) {return to_string((string) c);}\nstring to_string(bool b) {return (b ? \"true\" : \"false\");}\ntemplate <size_t N>\nstring to_string(bitset<N> v){\n    string res = \"\";\n    for(size_t i = 0; i < N; i++) res += static_cast<char>('0' + v[i]);\n    return res;\n}\ntemplate <typename A>\nstring to_string(A v) {\n    bool first = true;\n    string res = \"{\";\n    for(const auto &x : v) {\n        if(!first) res += \", \";\n        first = false;\n        res += to_string(x);\n    }\n    res += \"}\";\n    return res;\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p){return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}\n\nvoid debug_out() {cerr << endl;}\ntemplate<typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << to_string(H);\n    debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate<class T>\nbool chmax(T &a, T b){if(a < b){a = b; return true;} return false;}\ntemplate<class T>\nbool chmin(T &a, T b){if(a > b){a = b; return true;} return false;}\n\ntemplate<std::int_fast64_t Modulus>\nclass modint {\n    using i64 = int_fast64_t;\n\n    public:\n    i64 a;\n\n    constexpr modint(const i64 x = 0) noexcept {\n        this -> a = x % Modulus;\n        if(a < 0){\n            a += Modulus;\n        }\n    }\n    constexpr int getmod() { return Modulus; }\n    constexpr modint operator - () const noexcept {\n        return a ? Modulus - a : 0;\n    }\n    constexpr const i64 &value() const noexcept {return a;}\n    constexpr modint operator+(const modint rhs) const noexcept {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const noexcept {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const noexcept {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const noexcept {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint &operator+=(const modint rhs) noexcept {\n        a += rhs.a;\n        if(a >= Modulus) {\n            a -= Modulus;\n        }\n        return *this;\n    }\n    constexpr modint &operator-=(const modint rhs) noexcept {\n        if(a < rhs.a) {\n            a += Modulus;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr modint &operator*=(const modint rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept {\n        i64 a_ = rhs.a, b = Modulus, u = 1, v = 0;\n        while(b){\n            i64 t = a_/b;\n            a_ -= t * b; swap(a_,b);\n            u -= t * v; swap(u,v);\n        }\n        a = a * u % Modulus;\n        if(a < 0) a += Modulus;\n        return *this;\n    }\n    \n    // 自前実装\n    constexpr bool operator==(const modint rhs) noexcept {\n        return a == rhs.a;\n    }\n    constexpr bool operator!=(const modint rhs) noexcept {\n        return a != rhs.a;\n    }\n    constexpr bool operator>(const modint rhs) noexcept {\n        return a > rhs.a;\n    }\n    constexpr bool operator>=(const modint rhs) noexcept {\n        return a >= rhs.a;\n    }\n    constexpr bool operator<(const modint rhs) noexcept {\n        return a < rhs.a;\n    }\n    constexpr bool operator<=(const modint rhs) noexcept {\n        return a <= rhs.a;\n    }\n    constexpr modint& operator++() noexcept {\n        return (*this) += modint(1);\n    }\n    // constexpr modint operator++(int) {\n    //     modint tmp(*this);\n    //     operator++();\n    //     return tmp;\n    // }\n    constexpr modint& operator--() noexcept {\n        return (*this) -= modint(1);\n    }\n    // constexpr modint operator--(int) {\n    //     modint tmp(*this);\n    //     operator--();\n    //     return tmp;\n    // }\n    template<typename T>\n    friend constexpr modint modpow(const modint &mt, T n) noexcept {\n        if(n < 0){\n            modint t = (modint(1) / mt);\n            return modpow(t, -n);\n        }\n        modint res = 1, tmp = mt;\n        while(n){\n            if(n & 1)res *= tmp;\n            tmp *= tmp;\n            n /= 2;\n        }\n        return res;\n    }\n\n    friend constexpr string to_string(const modint &mt) noexcept {\n        return to_string(mt.a);\n    }\n};\n\n// 標準入出力対応\ntemplate<std::int_fast64_t Modulus>\nstd::ostream &operator<<(std::ostream &out, const modint<Modulus> &m) {\n    out << m.a;\n    return out;\n}\ntemplate<std::int_fast64_t Modulus>\nstd::istream &operator>>(std::istream &in, modint<Modulus> &m) {\n    ll a;\n    in >> a;\n    m = modint<Modulus>(a);\n    return in;\n}\n\n// const ll MOD = 1e9+7;\nconst ll MOD = 998244353;\nusing mint = modint<MOD>;\n\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\nBiCoef<mint> bc(n_max);\n\nsigned main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    ll n,m; cin >> n >> m;\n\n    mint ans = 0;\n    rep(i,0,min(n, m) + 1){\n        if((3 * m - i) & 1)continue;\n        ll k = (3 * m - i) / 2;\n        ans += bc.com(k + n - 1, n - 1) * bc.com(n, i);\n    }\n\n    debug(ans);\n\n    mint mi = 0;\n    rep(i,0,min(n, m) + 1){\n        if((m - i) & 1)continue;\n        ll k = (m - i) / 2;\n        mi += bc.com(k + n - 1, n - 1) * bc.com(n, i);\n    }\n    rep(i,0,min(n-1, m) + 1){\n        if((m - i) & 1)continue;\n        ll k = (m - i) / 2;\n        mi -= bc.com(k + n - 2, n - 2) * bc.com(n-1, i);\n    }\n    mi *= n;\n    cout << ans - mi << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "// Words are flowing out like endless rain into a paper cup\n// They slither while they pass they slip away across the universe\n// Pools of sorrow, waves of joy are drifting through my open mind\n// Possessing and caressing me\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n    if (ib == ie) {\n        ib = ibuf;\n        ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n    }\n    return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n    using namespace _buff;\n    LL ret = 0;\n    bool pos = true;\n    char c = getc();\n    for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n        assert(~c);\n    }\n    if (c == '-') {\n        pos = false;\n        c = getc();\n    }\n    for (; c >= '0' && c <= '9'; c = getc()) {\n        ret = (ret << 3) + (ret << 1) + (c ^ 48);\n    }\n    return pos ? ret : -ret;\n}\n\nconst size_t N = 1.5e6 + 5;\nconst int MOD = 998244353;\n\nint qpow(int base, int e) {\n    int ret = 1;\n    for (; e; e >>= 1) {\n        if (e & 1) {\n            ret = (LL) ret * base % MOD;\n        }\n        base = (LL) base * base % MOD;\n    }\n    return ret;\n}\n\nvoid ladd(int &ans, LL val) {\n    ans = (ans + val) % MOD;\n}\n\nint fac[N], inv[N];\n\nvoid prep() {\n    fac[0] = 1;\n    for (int i = 1; i < N; ++i) {\n        fac[i] = (LL) fac[i - 1] * i % MOD;\n    }\n    inv[N - 1] = qpow(fac[N - 1], MOD - 2);\n    for (int i = N - 1; i; --i) {\n        inv[i - 1] = (LL) inv[i] * i % MOD;\n    }\n}\n\nLL comb(int n, int m) {\n    if (n < m) return 0;\n    return (LL) fac[n] * inv[m] % MOD * inv[n - m] % MOD;\n}\n\nLL calc(int n, int m) {\n    // n split into the sum of m non-negative integers\n    return comb(n + m - 1, m - 1);\n}\n\nint main() {\n    prep();\n    int n = read(), m = read();\n    int ans = 0;\n    for (int i = 0; i <= min(n, m); ++i) {\n        if ((3 * m - i) & 1) continue;\n        ladd(ans, comb(n, i) * calc((3 * m - i) / 2, n));\n    }\n    for (int i = 2 * m + 1; i <= 3 * m; ++i) {\n        ladd(ans, -calc(3 * m - i, n - 1) * n);\n    }\n    if (ans < 0) ans += MOD;\n    cout << ans << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define mod 998244353\n\nusing namespace std;\n\nllint n, m;\nconst int FACT_MAX = 4000005;\nllint fact[FACT_MAX], fact_inv[FACT_MAX];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < FACT_MAX; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfact_inv[FACT_MAX-1] = modpow(fact[FACT_MAX-1], mod-2);\n\tfor(int i = FACT_MAX-2; i >= 0; i--){\n\t\tfact_inv[i] = fact_inv[i+1] * (i+1) % mod;\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> n >> m;\n\tmake_fact();\n\t\n\tllint ans = 0;\n\tfor(int i = 0; i <= m; i++){\n\t\tif(m%2 != i%2) continue;\n\t\tllint rem = (3*m-i)/2;\n\t\tllint tmp = comb(rem+n-1, n-1);\n\t\tif(rem-(m+1) >= 0) tmp += mod - (n-i) * comb(rem-(m+1)+n-1, n-1) % mod, tmp %= mod;\n\t\tif(rem-m >= 0) tmp += mod - i * comb(rem-m+n-1, n-1) % mod, tmp %= mod;\n\t\tans += tmp * comb(n, i) % mod, ans %= mod;\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL MOD=998244353ll;\nconst int mx=2000001;\nint n,m,fac[2000005],ifac[2000005];\nint powM(int V,int T=MOD-2ll){\n\tint R=1;\n\twhile(T){\n\t\tif(T&1) R=(LL)R*(LL)V%MOD;\n\t\tT>>=1;\n\t\tV=(LL)V*(LL)V%MOD;\n\t}\n\treturn R;\t\n}\nint C(int n,int m){\n\tif(n<m) return 0;\n\tif(!m) return 1;\n\treturn (LL)fac[n]*(LL)ifac[m]%MOD*(LL)ifac[n-m]%MOD;\n}\nint main(){\n\tint i,j,k;\n\tscanf(\"%d%d\",&n,&m);\n\tfac[0]=1;\n\tfor(i=1;i<=mx;++i) fac[i]=(LL)fac[i-1]*(LL)i%MOD;\n\tifac[mx]=powM(fac[mx]);\n\tfor(i=mx-1;i>=0;--i) ifac[i]=(LL)ifac[i+1]*(LL)(i+1)%MOD;\n\tint res=0;\n\tfor(i=n;i>=0;--i){\n\t\tif((i&1)!=(m&1)) continue;\n\t\tif(i>m) continue;\n\t\tfor(j=0;j<=3 && j<=n-i;++j){\n\t\t\tfor(k=0;k<=3 && k<=i;++k){\n\t\t\t\tint d=j*2*(m+1)+k*2*m;\n\t\t\t\tif(d+i>m*3) continue;\n\t\t\t\tint cur=(LL)C(n,i)*(LL)C((m*3-i-d)/2+n-1,n-1)%MOD*(LL)C(i,k)%MOD*(LL)C(n-i,j)%MOD;\n\t\t\t\tif((j+k)&1)\n\t\t\t\t\tres=(res+MOD-cur)%MOD;\n\t\t\t\telse\n\t\t\t\t\tres=(res+cur)%MOD;\n\t\t\t}\n\t\t}\n\t\tres%=MOD;\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <algorithm>\n#include <set>\nusing namespace std;\nlong long fac[2800100], finv[2800100], inv[2800100]; \nlong long MOD = 998244353; \nint MAX = 2800050; \nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++) {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nlong long COM(int n, int k) {\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nint main() { \n\tlong long int N, M; cin >> N >> M; COMinit();\n\tlong long int ALL = COM(N + M * 3 - 1, N - 1); \n\tlong long int impo = 0; \n\tfor(int i = 0; i < M; i++){\n\t\tlong long int tmp = COM(N + i - 2, i); \n\t\timpo += tmp; impo %= MOD; \n\t}\n\timpo *= N; impo %= MOD;\n\tlong long int impo2 = 0; \n\tfor(int i = 0; i < M; i++){\n\t\tlong long int tmp = (COM(N + i - 1, i) * COM(N, 3 * M - i * 2)) % MOD; \n\t\timpo2 += tmp; impo2 %= MOD; \n\t}\n\tcout << (MOD * 2 + ALL - impo - impo2) % MOD << endl; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n//  a^b % m\nlong long powmod(long long a, long long b, long long m)\n{\n    long long r = 1;\n    for (; b>0; b>>=1, a=a*a%m)\n        if (b&1)\n            r = r*a%m;\n    return r;\n}\n\nint main()\n{\n    long long N, M;\n    cin>>N>>M;\n\n    long long MOD = 998244353;\n    \n    vector<long long> F(M*3/2+N);\n    F[0] = 1;\n    for (int i=1; i<M*3/2+N; i++)\n        F[i] = F[i-1]*i%MOD;\n\n    auto comb = [&](long long a, long long b)\n    {\n        return F[a]*powmod(F[b], MOD-2, MOD)%MOD*powmod(F[a-b], MOD-2, MOD)%MOD;\n    };\n\n    auto f = [&](long long m)\n    {\n        long long ans = 0;\n        for (int o=m%2; o<=min(M, N); o+=2)\n            ans += comb(N, o)*comb((m-o)/2+N-1, N-1)%MOD;\n        return ans%MOD;\n    };\n\n    long long ans = ((f(3*M)-N*f(M-1))%MOD+MOD)%MOD;\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\nusing ll = int64_t;\n\nconstexpr ll MOD = 998244353;\n\nclass Combination {\npublic:\n    Combination(ll max_num) {\n        fact_.resize(max_num + 1, 1);\n        inv_fact_.resize(max_num + 1, 1);\n        for (ll i = 2; i <= max_num; i++) {\n            fact_[i] = i * fact_[i - 1] % MOD;\n            inv_fact_[i] = MODpow(fact_[i], MOD - 2);\n            assert(fact_[i] * inv_fact_[i] % MOD == 1);\n        }\n    }\n    ll operator()(ll n, ll m) const {\n        if (m < 0 || m > n) return 0;\n        return fact_[n] * inv_fact_[n - m] % MOD * inv_fact_[m] % MOD;\n    }\nprivate:\n    ll MODpow(ll n, ll m) const {\n        ll result = 1;\n        while (m) {\n            if (m % 2 == 1) {\n                result *= n;\n                result %= MOD;\n            }\n\n            m /= 2;\n            n *= n;\n            n %= MOD;\n        }\n\n        return result;\n    }\n\n    vector<ll> fact_, inv_fact_;\n} comb(3e6);\n\n//サイズがnの非負整数配列で総和がsであり奇数の要素がm個以下であるものの場合の数\nll f(ll n, ll s, ll m) {\n    ll result = 0;\n\n    //奇数の数を全探索\n    for (ll a = s % 1; a <= min(n, m); a += 2) {\n        //まず奇数になるところを決める\n        ll curr_num = comb(n, a);\n\n        //上で選んだ箇所に1を入れたとする\n        //残りs - aをn個の要素にそれぞれ偶数となるように分ければ良い\n        //そのような分け方は結局(s - a) / 2をn個に分ける\n        //要素と仕切りのやつ\n        (curr_num *= comb((s - a) / 2 + n - 1, n - 1)) %= MOD;\n\n        (result += curr_num) %= MOD;\n    }\n\n    return result;\n}\n\nint main() {\n    ll N, M;\n    cin >> N >> M;\n\n    //最大値が2Mを超えないという条件を無視した数\n    ll ans = f(N, 3 * M, M);\n\n    //最大値が2Mを超えるものの数を引く\n    ll sub = (f(N, M, M) + MOD - f(N - 1, M, M)) % MOD * N % MOD;\n    (ans += MOD - sub) %= MOD;\n\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\nvoid tostr(ll x,string& res){while(x)res+=('0'+(x%10)),x/=10; reverse(ALL(res)); return;}\ntemplate<class T> inline bool chmax(T& a,T b){ if(a<b){a=b;return 1;}return 0; }\ntemplate<class T> inline bool chmin(T& a,T b){ if(a>b){a=b;return 1;}return 0; }\n//end\n\ntemplate<unsigned mod=998244353>struct mint {\n   unsigned val;\n   static unsigned get_mod(){return mod;}\n   unsigned inv() const{\n      int tmp,a=val,b=mod,x=1,y=0;\n      while(b)tmp=a/b,a-=tmp*b,swap(a,b),x-=tmp*y,swap(x,y);\n      if(x<0)x+=mod; return x;\n   }\n   mint():val(0){}\n   mint(ll x):val(x>=0?x%mod:mod+(x%mod)){}\n   mint pow(ll t){mint res=1,b=*this; while(t){if(t&1)res*=b;b*=b;t>>=1;}return res;}\n   mint& operator+=(const mint& x){if((val+=x.val)>=mod)val-=mod;return *this;}\n   mint& operator-=(const mint& x){if((val+=mod-x.val)>=mod)val-=mod; return *this;}\n   mint& operator*=(const mint& x){val=ll(val)*x.val%mod; return *this;}\n   mint& operator/=(const mint& x){val=ll(val)*x.inv()%mod; return *this;}\n   mint operator+(const mint& x)const{return mint(*this)+=x;}\n   mint operator-(const mint& x)const{return mint(*this)-=x;}\n   mint operator*(const mint& x)const{return mint(*this)*=x;}\n   mint operator/(const mint& x)const{return mint(*this)/=x;}\n   bool operator==(const mint& x)const{return val==x.val;}\n   bool operator!=(const mint& x)const{return val!=x.val;}\n};\ntemplate<unsigned mod=998244353>struct factorial {\n   using Mint=mint<mod>;\n   vector<Mint> Fact, Finv;\npublic:\n   factorial(int maxx){\n      Fact.resize(maxx+1),Finv.resize(maxx+1); Fact[0]=Mint(1); rep(i,0,maxx)Fact[i+1]=Fact[i]*(i+1);\n      Finv[maxx]=Mint(1)/Fact[maxx]; rrep(i,maxx,0)Finv[i-1]=Finv[i]*i;\n   }\n   Mint fact(int n,bool inv=0){if(inv)return Finv[n];else return Fact[n];}\n   Mint nPr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[n-r];}\n   Mint nCr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[r]*Finv[n-r];}\n};\nusing Mint=mint<>;\n\nfactorial<> fact(2010000);\n\n// sum<=3M && max<=2M && #odd<=M\nMint solve(int n,int sum,int odd){\n   chmin(odd,n); Mint res;\n   rep(k,0,odd+1)if(sum>=k&&((sum-k)%2==0)){\n      res+=fact.nCr((sum-k)/2+n-1,n-1)*fact.nCr(n,k);\n   } return res;\n}\n\nint main(){\n   int n,m; scanf(\"%d%d\",&n,&m);\n   Mint res=solve(n,3*m,m)-(solve(n,m,m)-solve(n-1,m,m))*n;\n   printf(\"%d\\n\",res.val);\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\nusing ll = long long;\n\n// Fermat の小定理を用いた F_mod 上での逆元計算x^(mod-2), 蟻本p115\nll Inverse(ll x){\n    ll res = 1;\n    int n = mod - 2;\n    while(n > 0){\n        if(n & 1){\n            res = res * x % mod;\n        }\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\n// iの階乗 = fact[i], main内の階乗計算をする必要がある\n#define MAX_FACT 3000000\nll fact[MAX_FACT];\n\nll nCk(int n, int k){\n    //　n_C_kの計算, Inverseの中身にもmodを入れないとオーバーフローするので注意, 蟻本p.263\n    // n >= k でないと配列外参照するので注意\n    ll ans = fact[n] * Inverse(fact[k] * fact[n-k] % mod);\n    ans %= mod;\n    return ans;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    /*\n     * 全部の組み合わせから不可能なものを引く\n     * 不可能なのは\n     * 1. ある値が2Mより大きい\n     * 2. 値が奇数のものがM個より多い\n     * のどちらか, これらは背反(和は3Mより)\n     * 奇数に1を1回, 最大の数から2を割り振れば構成できる\n     */\n\n    // 階乗計算\n    fact[0]=1;\n    for(int i = 1; i < MAX_FACT; ++i) {\n        fact[i] = fact[i-1] * i % mod;\n    }\n\n    ll ans = nCk(3*M+N-1, N-1);\n\n    // ある値が2Mより大きい場合, 他の値の合計で回す\n    ll over = 0;\n    for (int i = 0; i < M; ++i) {\n        over = over + nCk(i+N-2, N-2);\n        over %= mod;\n    }\n    over = over * N; // 2Mより大きい値の自由度\n    over %= mod;\n    ans = ans + mod - over;\n    ans %= mod;\n\n\n    // 値が奇数のものがM個より多い場合, 奇数の個数で回す\n    ll many = 0;\n    for (int i = M+1; i <= N; ++i) {\n        if((3 * M - i) % 2 == 1) continue;\n        ll temp = 0;\n        int sum = (3 * M - i) / 2;\n        if(sum < 0) continue;\n        temp = temp + nCk(sum+N-1, N-1);\n        temp %= mod;\n        temp = temp * nCk(N, i); // 奇数の位置の自由度\n        temp %= mod;\n        many += temp;\n        many %= mod;\n    }\n    ans = ans + mod - many;\n    ans %= mod;\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=998244353;\ninline void add(int &x,int y){(x+=y)>=mod?x-=mod:0;}\ninline int kpow(int a,int b)\n{\n\tint s=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1)s=1ll*s*a%mod;\n\treturn s;\n}\nint n,m,ans,jc[1000010],jcv[1000010];\nvoid init()\n{\n\tjc[0]=1;\n\tfor(int i=1;i<=1000000;++i)jc[i]=1ll*jc[i-1]*i%mod;\n\tjcv[1000000]=kpow(jc[1000000],mod-2);\n\tfor(int i=1000000;i;--i)jcv[i-1]=1ll*jcv[i]*i%mod;\n}\nint C(int x,int y)\n{\n\tif(x<y||y<0)return 0;\n\treturn 1ll*jc[x]*jcv[y]%mod*jcv[x-y]%mod;\n}\nint calc(int a,int b,int s)\n{\n\tint res=C(a+b+s-1,a+b-1);\n\tadd(res,mod-1ll*b*C(a+b+s-2-m,a+b-1)%mod);\n\tadd(res,mod-1ll*a*C(a+b+s-1-m,a+b-1)%mod);\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tinit();\n\tfor(int i=m;i>=0;i-=2)add(ans,1ll*C(n,i)*calc(i,n-i,(3*m-i)/2)%mod)/*,printf(\"%d\\n\",ans)*/;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e6 + 10;\nconst int mod = 998244353;\n\ninline int fpow (int a, int b) {\n\tint ret = 1;\n\twhile (b) {\n\t\tif (b & 1) ret = 1ll * ret * a % mod;\n\t\ta = 1ll * a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn ret;\n}\n\nint f[N], invf[N];\n\nvoid predeal (int n) {\n\tf[0] = invf[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[i] = 1ll * f[i - 1] * i % mod;\n\t}\n\tinvf[n] = fpow(f[n], mod - 2);\n\tfor (int i = n - 1; i >= 1; i--) {\n\t\tinvf[i] = 1ll * invf[i + 1] * (i + 1) % mod; \n\t}\n}\n\ninline int C (int n, int m) {\n\treturn n >= m ? 1ll * f[n] * invf[m] % mod * invf[n - m] % mod : 0;\n}\n\nint main (void) {\n\tpredeal(2e6);\n\n\tint n, m, ans = 0;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i <= m; i++) {\n\t\tif ((m - i) & 1) continue;\n\t\tans += 1ll * C(n, i) * C((3 * m - i) / 2 + n - 1, n - 1) % mod;\n\t\tif (ans >= mod) ans -= mod;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tif ((m - 1 - i) & 1) continue;\n\t\tans -= 1ll * C(n, 1) * C(n, i) % mod * C((m - 1 - i) / 2 + n - 1, n - 1) % mod;\n\t\tif (ans < 0) ans += mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define double long double\n#define rep(i, n) for (int i = 0; i < (int) n; i++)\n#define reps(i, n) for (int i = 1; i <= (int) n; i++)\n#define all(p) (p).begin(), (p).end()\n#define uniq(v) v.erase(unique(v.begin(), v.end()), v.end());\n#define bit(n) (1LL << (n))\n#define dump(p) cerr << #p \" = \" << p << endl\nusing vint=vector<int>;\nusing vvint=vector<vint>;\nusing pint=pair<int, int>;\nusing vpint=vector<pint>;\nconstexpr double pi = 3.1415926535897932384626433832795028;\nconstexpr int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\ninline int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\ninline int lcm(int a, int b) { return a / gcd(a, b) * b; }\ntemplate<typename T> using priority_queue_rev=priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, const T2 &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, const T2 &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &p) {\n    os << \"{\";\n    for (auto itr = p.begin(); itr != p.end(); itr++) {\n        itr++;\n        if (itr != p.end()) { os << \", \"; }\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\nstruct SetUp {\n    static constexpr int PREC = 20;\n    SetUp() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setUp;\n\ntemplate<int MOD = 1000000007>\nstruct ModInt {\n    int val;\n    ModInt() : val(0) {}\n    ModInt(long long val_) : val(val_ >= 0 ? val_ % MOD : (MOD - (-val_) % MOD) % MOD) {}\n    ModInt &operator+=(const ModInt &p) {\n        if ((val += p.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &p) {\n        if ((val += MOD - p.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &p) {\n        val = (int) ((long long) val * p.val % MOD);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &p) {\n        int a = p.val, b = MOD, u = 1, v = 0;\n        while (b > 0) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(u -= t * v, v);\n        }\n        *this *= ModInt(u);\n        return *this;\n    }\n    ModInt operator-() const { return ModInt(-val); }\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n    bool operator==(const ModInt &p) const { return val == p.val; }\n    bool operator!=(const ModInt &p) const { return val != p.val; }\n    ModInt pow(long long n) const {\n        ModInt ret(1), mul(val);\n        while (n > 0) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, ModInt &p) {\n        long long v;\n        is >> v;\n        p = ModInt<MOD>(v);\n        return (is);\n    }\n    friend std::ostream &operator<<(std::ostream &os, const ModInt &p) { return os << p.val; }\n    struct Combination {\n        std::vector<ModInt> fact, finv, inv;\n        Combination(int n) : fact(n + 1), finv(n + 1), inv(n + 1) {\n            fact[0] = fact[1] = 1;\n            finv[0] = finv[1] = 1;\n            inv[1] = 1;\n            for (int i = 2; i <= n; i++) {\n                fact[i] = fact[i - 1] * i;\n                inv[i] = -inv[MOD % i] * (MOD / i);\n                finv[i] = finv[i - 1] * inv[i];\n            }\n        }\n        ModInt P(int n, int r) const {\n            if (r < 0 || n < r) { return 0; }\n            return fact[n] * finv[n - r];\n        }\n        ModInt C(int n, int r) const {\n            if (r < 0 || n < r) { return 0; }\n            return fact[n] * finv[r] * finv[n - r];\n        }\n        ModInt H(int n, int r) const {\n            if (n < 0 || r < 0) { return 0; }\n            return r == 0 ? 1 : C(n + r - 1, r);\n        }\n    };\n};\n\nint N, M;\nusing Mint=ModInt<998244353>;\nsigned main() {\n    cin >> N >> M;\n    Mint::Combination comb(N + 2 * M);\n    vector<Mint> Hsum(2 * M);\n    rep(i, 2 * M) { Hsum[i] = comb.H(N - 1, i); }\n    for (int i = 1; i < 2 * M; i++) { Hsum[i] += Hsum[i - 1]; }\n    Mint ans = 0;\n    for (int i = 0; i <= M; i++) {\n        if (i > N) { continue; }\n        if ((M - i) & 1) { continue; }\n        int K = M + (M - i) / 2;\n        ans += comb.C(N, i) * (comb.H(N, K) - Hsum[K - M] * N);\n    }\n    ans += comb.H(N - 1, M) * N;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> P;\n// a>=0, b>=0, x*a+y*b=gcd>=0, a>0,b>0=>abs(y)<=a,abs(x)<=b\nLL gcdex(LL a,LL b,LL& x, LL& y){\n\tLL ax=1,ay=0;\n\tLL bx=0,by=1;\n\twhile(b){\n\t\tLL r=a/b;\n\t\tLL t=a-r*b; a=b; b=t;\n\t\tLL tx=ax-r*bx; ax=bx; bx=tx;\n\t\tLL ty=ay-r*by; ay=by; by=ty;\n\t}\n\tx=ax;\n\ty=ay;\n\treturn a;\n}\nLL modinv(LL a, LL mod){\n\tLL x,y;\n\tgcdex(a,mod,x,y);\n\tif(x<0){\n\t\tx+=mod;\n\t}\n\treturn x;\n}\n\nconst LL N=3e6;\nconst LL K=998244353;\ntemplate<int S>\nstruct Comb\n{\n\tLL f[S+1];\n\tLL r[S+1];\n\tLL mod;\n\tComb(int m)\n\t{\n\t\tmod=m;\n\t\tf[0]=1;\n\t\tr[0]=1;\n\t\tfor(LL i=1;i<=S;i++){\n\t\t\tf[i]=i*f[i-1]%m;\n\t\t\tr[i]=modinv(i,m)*r[i-1]%m;\n\t\t}\n\t}\n\tLL c(int n,int i){\n\t\tif(i<0||n<i)\n\t\t{\n\t\t\t//assert(0);\n\t\t\treturn 0;\n\t\t}\n\t\treturn f[n]*r[i]%mod*r[n-i]%mod;\n\t}\n};\nComb<N> comb(K);\nLL C(int n,int i){\n\treturn comb.c(n,i);\n}\n\nLL f(LL a,LL b)\n{\n\treturn C(a+b-1,a-1);\n}\n\n\nint main(){\n    long long N;\n    scanf(\"%lld\",&N);\n    long long M;\n    scanf(\"%lld\",&M);\n\tLL ret=f(N,3*M);\n\tfor(LL i=2*M+1;i<=3*M;i++){\n\t\tret+=K-N*f(N-1,3*M-i)%K;\n\t\tret%=K;\n\t}\n\tfor(LL i=M+1;i<=min(N,3*M);i++){\n\t\tif((3*M-i)%2){\n\t\t\tcontinue;\n\t\t}\n\t\tLL r=(3*M-i)/2;\n\t\tret+=K-C(N,i)*f(N,r)%K;\n\t\tret%=K;\n\t}\n\tassert(ret>=0&&ret<K);\n\n\tcout << ret << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a); i <= (b); i++)\n#define per(i, a, b) for (int i = (a); i >= (b); i--)\n#define trv(p, u) for (edg *p = h[u]; p; p = p->nxt)\n#define pb push_back\ntypedef long long ll;\ntypedef double db;\nconst int N = 2e6 + 100;\nconst int inf = 0x3f3f3f3f;\nconst int mod = 998244353;\n\ninline int rd() {\n  int s = 0, w = 1; char c = getchar();\n  while (c < '0' || c > '9') { if (c == '-') w = -1; c = getchar(); }\n  while (c >= '0' && c <= '9') s = s * 10 + c - '0', c = getchar();\n  return s * w;\n}\n\nint n, m, fac[N], inv[N];\n\ninline int qpow(int a, int b) {\n  int res = 1;\n  while (b) {\n    if (b & 1) res = 1ll * res * a % mod;\n    a = 1ll * a * a % mod, b >>= 1;\n  }\n  return res;\n}\n\ninline void prew() {\n  fac[0] = inv[0] = fac[1] = inv[1] = 1;\n  rep(i, 2, N - 100) inv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod;\n  rep(i, 2, N - 100)\n    fac[i] = 1ll * i * fac[i - 1] % mod, inv[i] = 1ll * inv[i] * inv[i - 1] % mod;\n}\n\ninline int C(int a, int b) { return 1ll * fac[a] * inv[a - b] % mod * inv[b] % mod; }\n\ninline int calc(int x) {\n  int res = 0;\n  for (int i = x & 1; i <= min(x, min(n, m)); i += 2)\n    res = (res + 1ll * C(n, i) * C((x - i) / 2 + n - 1, n - 1)) % mod;\n  return res;\n}\n\nint main() {\n  prew(); n = rd(), m = rd();\n  printf(\"%lld\\n\", (calc(m * 3) - 1ll * n * calc(m - 1) % mod + mod) % mod);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<LL,LL> P;\nconst LL mod=998244353;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\n\n\nvector<LL> fact;\nvector<LL> inver(3000001);\n \nLL combi(int n,int r){\n    if(n<r||n<0||r<0) return 0;\n    return fact[n]%mod*inver[n-r]%mod*inver[r]%mod;\n}\n \n \nLL fpow(LL a, LL n){\n    LL x = 1;\n    while(n > 0){\n        if(n&1){\n            x=x*a%mod;\n        }\n        a=a*a%mod;\n        n >>= 1;\n    }\n    return x;\n}\n \nvoid set_combi(){\n    LL s=1;\n    fact.push_back(1);\n    for(int i=1;i<=3000000;i++){\n        s*=i;\n        s%=mod;\n        fact.push_back(s);\n    }\n    inver[3000000]=fpow(fact[3000000],mod-2);\n    for(int i=2999999;i>=0;i--){\n        inver[i]=inver[i+1]*(i+1)%mod;\n    }\n}\n \nLL hcombi(int n,int r){\n    return combi(n+r-1,r); \n}\n\n\n\nint main(){\n    set_combi();\n    LL n,m;cin >> n >> m;\n    LL ans = 0;\n    for (int i = min(n,m); i >= 0; i-=2) {\n        ans = (ans + hcombi(n,m+(m-i)/2) * combi(n,i))%mod;\n    }\n    for (int i = 2*m+1; i <= 3*m; i++) {\n        ans = (ans - (n * hcombi(n-1,3*m-i))%mod + mod)%mod;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(x) ((int) ((x).size()))\ntypedef long long ll;\ntypedef long double ld;\n\nll mod = 998244353;\n\nconst ll MAX = 3000000;\nll f[MAX], inv[MAX], finv[MAX];\n\nvoid init() {\n\tinv[1] = 1;\n\tfor (int i = 2; i < MAX; i++)\n\t\tinv[i] = (mod - (mod / i) * inv[mod % i] % mod) % mod;\n  f[0] = f[1] = finv[0] = finv[1] = 1;\n  for (int i = 2; i < MAX; i++)\n    f[i] = (f[i - 1] * i) % mod, finv[i] = (finv[i - 1] * inv[i]) % mod;\n}\n\nll binom(ll n, ll k) {\n  return (((f[n] * finv[n - k]) % mod) * finv[k]) % mod;\n}\n\nint n, m;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  cin >> n >> m;\n  init();\n  ll res = 0;\n  for (int i = 0; i <= n && i <= m; i++) {\n    if ((3 * m - i) % 2 == 0) {\n      res = (res + binom(n, i) * binom((3 * m - i) / 2 + n - 1, n - 1)) % mod;\n    }\n  }\n  for (int i = 2 * m + 1; i <= 3 * m; i++) {\n    res = (res - (n * binom(3 * m - i + n - 2, n - 2)) % mod + mod) % mod;\n  }\n  cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> P;\n// a>=0, b>=0, x*a+y*b=gcd>=0, a>0,b>0=>abs(y)<=a,abs(x)<=b\nLL gcdex(LL a,LL b,LL& x, LL& y){\n\tLL ax=1,ay=0;\n\tLL bx=0,by=1;\n\twhile(b){\n\t\tLL r=a/b;\n\t\tLL t=a-r*b; a=b; b=t;\n\t\tLL tx=ax-r*bx; ax=bx; bx=tx;\n\t\tLL ty=ay-r*by; ay=by; by=ty;\n\t}\n\tx=ax;\n\ty=ay;\n\treturn a;\n}\nLL modinv(LL a, LL mod){\n\tLL x,y;\n\tgcdex(a,mod,x,y);\n\tif(x<0){\n\t\tx+=mod;\n\t}\n\treturn x;\n}\n\nconst LL N=2e6;\nconst LL K=998244353;\ntemplate<int S>\nstruct Comb\n{\n\tLL r[S+1];\n\tLL f[S+1];\n\tLL mod;\n\tComb(int m)\n\t{\n\t\tmod=m;\n\t\tf[0]=1;\n\t\tr[0]=1;\n\t\tfor(LL i=1;i<=S;i++){\n\t\t\tf[i]=i*f[i-1]%m;\n\t\t\tr[i]=modinv(i,m)*r[i-1]%m;\n\t\t}\n\t}\n\tLL c(int n,int i){\n\t\tif(i<0||n<i)\n\t\t{\n\t\t\t//assert(0);\n\t\t\treturn 0;\n\t\t}\n\t\treturn f[n]*r[i]%mod*r[n-i]%mod;\n\t}\n};\nComb<N> comb(K);\nLL C(int n,int i){\n\treturn comb.c(n,i);\n}\n\nLL f(LL a,LL b)\n{\n\treturn C(a+b-1,a-1);\n}\n\n\nint main(){\n    long long N;\n    scanf(\"%lld\",&N);\n    long long M;\n    scanf(\"%lld\",&M);\n\tLL ret=f(N,3*M);\n\tfor(LL i=2*M+1;i<=3*M;i++){\n\t\tret+=K-N*f(N-1,3*M-i)%K;\n\t\tret%=K;\n\t}\n\tfor(LL i=M+1;i<=min(N,3*M);i++){\n\t\tif((3*M-i)%2){\n\t\t\tcontinue;\n\t\t}\n\t\tLL r=(3*M-i)/2;\n\t\tret+=K-C(N,i)*f(N,r)%K;\n\t\tret%=K;\n\t}\n\tassert(ret>=0&&ret<K);\n\n\tcout << ret << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\nll mod=998244353;\n\nll fac[3000010];\n \nll modinv(ll a){\n    ll b=mod,u=1,v=0;\n    while(b){\n        ll t=a/b;\n        a-=t*b; swap(a,b);\n        u-=t*v; swap(u,v);\n        }\n        u%=mod;\n        if(u<0) u+=mod;\n    return u;\n}\n \nvoid modfac(){\n    fac[0]=1;\n    for(ll i=1;i<3000010;i++){\n        fac[i]=(fac[i-1]*i)%mod;\n    }\n}\n \nll modperm(ll n,ll k){\n    if(n<0||k<0||n<k) return 0;\n    else return (fac[n]*modinv(fac[n-k]))%mod;\n}\n \nll modcomb(ll n,ll k){\n    if(n<0||k<0||n<k) return 0;\n    else return ((fac[n]*modinv(fac[k]))%mod*modinv(fac[n-k]))%mod;\n}\n\nll modhom(ll n,ll k){\n  if(n==0&&k==0) return 1;\n  else if(n<0||k<0) return 0;\n  else return modcomb(n+k-1,k);\n}\n \nll modpow(ll a,ll b){\n  ll ans=1;\n  a%=mod;\n  while(b){\n    if(b&1) ans=ans*a%mod;\n    a=a*a%mod;\n    b>>=1;\n  }\n  return ans;\n}\n\nint main(){\n  modfac();\n  ll n,m;\n  cin >> n >> m;\n  ll ans=modhom(n,3*m);\n  for(ll i=m+1;i<=n;i++){\n    if((3*m-i)%2==0){\n      ans=(ans-modcomb(n,i)*modhom(n,(3*m-i)/2)%mod+mod)%mod;\n      ans=(ans+modcomb(n,i)*modhom(n,(m-i)/2)%mod*n%mod)%mod;\n      ans=(ans-modcomb(n-1,i)*modhom(n-1,(m-i)/2)%mod*n%mod+mod)%mod;\n    }\n  }\n  ans=(ans-modhom(n,m)*n%mod)%mod;\n  ans=(ans+modhom(n-1,m)*n%mod)%mod;\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//ios::sync_with_stdio(false);\n#include<bits/stdc++.h>\n#define LL long long\n#define F(x,y,z) for(int x=y;x<=z;++x)\n#define D(x,y,z) for(int x=y;x>=z;--x)\nusing namespace std;\nconst int Mod=998244353;\nconst int N=3000010;\nconst int maxn=3000001;\nLL Min(LL x,LL y){return x<y?x:y;}\nLL Max(LL x,LL y){return x>y?x:y;}\nLL R(){\n    LL ans=0,f=1;char c=getchar();\n    for(;c<'0'||c>'9';c=getchar()) if (c=='-') f=-1;\n    for(;c>='0'&&c<='9';c=getchar()) ans=ans*10+c-'0';\n    return ans*f;\n}\nLL jc[N],ni[N],n,m;\nLL C(LL n,LL m){return jc[n]*ni[m]%Mod*ni[n-m]%Mod;}\nLL Calc(LL n,LL m,LL js){\n\tLL ans=0;\n\tF(i,0,m){\n\t\tif((i+m)&1)continue;\n\t\tans+=C(n,i)*C(js+(m-i)/2+n-1,n-1);\n\t\tans%=Mod;\n\t}\n\treturn ans;\n}\nLL Pow(LL x,LL bs){\n\tLL an=1;\n\tfor(;bs;bs>>=1,x=x*x%Mod)\n\t\tif(bs&1)an=an*x%Mod;\n\treturn an; \n}\nvoid Pre(){\n\tjc[0]=ni[0]=1;\n\tF(i,1,maxn)jc[i]=jc[i-1]*i%Mod;\n\tni[maxn]=Pow(jc[maxn],Mod-2);\n\tD(i,maxn-1,1)ni[i]=ni[i+1]*(i+1)%Mod;\n}\nint main(){\n\tPre();\n\tn=R();m=R();\n\tLL ans=Calc(n,m,m);\n\tans-=n*(Calc(n,m,0)-Calc(n-1,m,0));\n\tans%=Mod;ans+=Mod;ans%=Mod;\n\tcout<<ans<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <tuple>\n#include <vector>\nusing ll = int64_t;\nclass range {private: struct I{int x;int operator*(){return x;}bool operator!=(I& lhs){return x<lhs.x;}void operator++(){++x;}};I i,n;\npublic:range(int n):i({0}),n({n}){}range(int i,int n):i({i}),n({n}){}I& begin(){return i;}I& end(){return n;}};\nusing namespace std;\nconstexpr int mod = 998244353;\n\n// Modulo calculus\n\n// With Montgomery multiply\n// Mod < 2^32, odd number\nconstexpr int ceil_log2(int x) {\n  int y = 0;\n  while (x) {\n    ++y;\n    x /= 2;\n  }\n  return y;\n}\n\nconstexpr int calc_np(const int Mod, const int R) {\n  int res = 0;\n  int t = 0;\n  int r = R;\n  int i = 1;\n  while (r > 1) {\n    if ((t % 2) == 0) {\n      t += Mod;\n      res += i;\n    }\n    t /= 2;\n    r /= 2;\n    i *= 2;\n  }\n  return res;\n}\n\ntemplate <int Mod>\nclass ModIntMR {\n public:\n  constexpr ModIntMR() : data(0) {}\n  explicit constexpr ModIntMR(const int x) : data(reduction(static_cast<ll>(x) * R2)) {}\n  ModIntMR<Mod>& operator=(const ModIntMR<Mod>& that) {\n    data = that.data;\n    return *this;\n  }\n  explicit operator int() const { return reduction(data); }\n  ModIntMR<Mod>& operator+=(const ModIntMR<Mod>& that) {\n    data += that.data;\n    if (data >= Mod) data -= Mod;\n    return *this;\n  }\n  ModIntMR<Mod>& operator-=(const ModIntMR<Mod>& that) {\n    data -= that.data;\n    if (data < 0) data += Mod;\n    return *this;\n  }\n  ModIntMR<Mod>& operator*=(const ModIntMR<Mod>& that) {\n    data = reduction(static_cast<ll>(data) * that.data);\n    return *this;\n  }\n  friend ModIntMR<Mod> operator+(ModIntMR<Mod> lhs, const ModIntMR<Mod>& rhs) {\n    lhs += rhs;\n    return lhs;\n  }\n  friend ModIntMR<Mod> operator-(ModIntMR<Mod> lhs, const ModIntMR<Mod>& rhs) {\n    lhs -= rhs;\n    return lhs;\n  }\n  friend ModIntMR<Mod> operator*(ModIntMR<Mod> lhs, const ModIntMR<Mod>& rhs) {\n    lhs *= rhs;\n    return lhs;\n  }\n  friend ModIntMR<Mod> operator^(ModIntMR<Mod> lhs, const ll rhs) {\n    if (rhs == 0) return ModIntMR<Mod>(1);\n    else if ((rhs % 2) == 1) return (lhs ^ (rhs-1)) * lhs;\n    else {\n      const auto half = lhs ^ (rhs / 2);\n      return half * half;\n    }\n  }\n  ModIntMR<Mod>& operator^=(const ll that) {\n    data = (*this ^ that).data;\n    return *this;\n  }\n private:\n  int data;\n  static constexpr int shift = ceil_log2(Mod);\n  static constexpr int R = 1 << shift;\n  static constexpr int mask = R-1;\n  static constexpr int R2 = static_cast<ll>(R)*R%Mod;\n  static constexpr int Np = calc_np(Mod, R);\n  static constexpr int reduction(const ll T) {\n    int t = (T + ((T*Np)&mask)*Mod)>>shift;\n    return t >= Mod ? t - Mod : t;\n  }\n};\n\nusing modint = ModIntMR<mod>;\n\nll inv(ll a,ll p){\n  return ( a == 1 ? 1 : (1 - p*inv(p%a,a)) / a + p );\n}\n\nmodint fact[1750001];\nmodint factinv[1750001];\n\nmodint comb(int n, int k) {\n  const auto tmp = fact[n] * factinv[k];\n  return tmp * factinv[n-k];\n}\n \nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n,m;\n  cin>>n>>m;\n  ll mx = 3*m/2+n;\n  fact[0] = modint(1);\n  for (int i = 0; i < mx; ++i) {\n    fact[i+1] = fact[i] * modint(i+1);\n  }\n  factinv[mx] = modint(inv(static_cast<int>(fact[mx]), mod));\n  for (int i = mx; i > 0; --i) {\n    factinv[i-1] = factinv[i] * modint(i);\n  }\n  modint sub(0);\n  for (int i = 2*m+1; i <= 3*m; ++i) {\n    sub += comb(3*m-i+n-2, n-2);\n  }\n  sub *= modint(n);\n  modint mno(0);\n  for (int i = m%2; i <= n && i <= m; i+=2) {\n    ll rem = 3*m-i;\n    if (rem < 0) break;\n    mno += comb(rem/2+n-1, n-1) * comb(n, i);\n  }\n  modint res = mno - sub;\n  cout << static_cast<int>(res) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nconst ll mod = 998244353;\nstruct mint {\n    ll x;\n    mint(ll x=0):x((x%mod+mod)%mod){}\n    mint& operator+=(const mint a) {\n    if ((x += a.x) >= mod) x -= mod;\n    return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod-a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n    // for prime mod\n    mint inv() const {\n        return pow(mod-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\n\nclass combination{\nprivate:\n    vector<mint> fact,finv;\npublic:\n    combination(int N){\n        fact = finv = vector<mint>(N+1);\n        fact[0] = fact[1] = 1;\n        finv[0] = finv[1] = 1;\n        for(ll i=2;i<=N;i++){\n            fact[i] = fact[i-1]*i;\n            finv[i] = fact[i].inv();\n        }\n    }\n    mint f(int i){\n        return fact[i];\n    }\n    mint comb(int n,int k){\n        if(n<k) return 0;\n        if(n<0 || k<0) return 0;\n        return fact[n]*finv[k]*finv[n-k];\n    }\n    mint hcomb(int n,int k){\n        if(n==0 && k==0) return 1;\n        return comb(n+k-1,k);\n    }\n};\n\nint main(){\n    ll N,M;\n    cin >> N >> M;\n    combination c(N+3*M);\n    mint ans = c.hcomb(N,3*M);\n    for(int k=M+1;k<=min(N,3*M);k++){\n        if((3*M-k)%2==0){\n            ans -= c.comb(N,k)*c.hcomb(N,(3*M-k)/2);\n        }\n    }\n    ans -= c.hcomb(N,M-1)*N;\n    cout << ans.x << endl;\n}"
  },
  {
    "language": "Haskell",
    "code": "-- https://github.com/minoki/my-atcoder-solutions\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TypeFamilies #-}\nimport Data.Char (isSpace)\nimport Data.Int (Int64)\nimport Data.List (unfoldr)\nimport qualified Data.Vector.Unboxed as U\nimport qualified Data.Vector.Unboxed.Mutable as UM\nimport qualified Data.ByteString.Char8 as BS\nimport Data.Coerce\nimport qualified Data.Vector.Generic\nimport qualified Data.Vector.Generic.Mutable\n\nsolve :: Int -> Int -> N\nsolve !n !m = let mk = (3*m) `quot` 2\n                  ts = U.scanl' (+) 0 $ U.map (\\l -> binom (l+n-2) (n-2)) $ U.enumFromN 0 (mk-m)\n              in sum [ binom (k+n-1) (n-1) * binom n (3*m-2*k) - fromIntegral n * (binom n (3*m-2*k) * ts U.! (k-m) + binom (k-m+n-2) (n-2) * binom (n-1) (3*m-2*k-1))\n                     | k <- [m..mk]\n                     , let t | k-m >= 0 = ts U.! (k-m)\n                             | otherwise = 0\n                     ]\n\nmain = do\n  [n,m] <- unfoldr (BS.readInt . BS.dropWhile isSpace) <$> BS.getLine\n  print $ solve n m\n\nfactV :: U.Vector N\nfactV = U.scanl' (*) 1 (U.enumFromN 1 (25*10^5))\n\nbinom :: Int -> Int -> N\nbinom n k | k < 0 || k > n = 0\n          | otherwise = factV U.! n / (factV U.! (n-k) * factV U.! k)\n\n--\n-- Modular Arithmetic\n--\n\nmodulo :: Int64\nmodulo = 998244353\naddMod, subMod, mulMod :: Int64 -> Int64 -> Int64\naddMod !x !y | x + y >= modulo = x + y - modulo\n             | otherwise = x + y\nsubMod !x !y | x >= y = x - y\n             | otherwise = x - y + modulo\nmulMod !x !y = (x * y) `rem` modulo\n\nnewtype N = N { unwrapN :: Int64 } deriving (Eq)\ninstance Show N where\n  show (N x) = show x\ninstance Num N where\n  (+) = coerce addMod\n  (-) = coerce subMod\n  (*) = coerce mulMod\n  fromInteger n = N (fromInteger (n `mod` fromIntegral modulo))\n  abs = undefined; signum = undefined\n\n{-# RULES\n\"^9/Int\" forall x. x ^ (9 :: Int) = let u = x; v = u * u * u in v * v * v\n\"^9/Integer\" forall x. x ^ (9 :: Integer) = let u = x; v = u * u * u in v * v * v\n #-}\n\n---\n\nexEuclid :: (Eq a, Integral a) => a -> a -> (a, a, a)\nexEuclid !f !g = loop 1 0 0 1 f g\n  where loop !u0 !u1 !v0 !v1 !f 0 = (f, u0, v0)\n        loop !u0 !u1 !v0 !v1 !f g =\n          case divMod f g of\n            (q,r) -> loop u1 (u0 - q * u1) v1 (v0 - q * v1) g r\n\nrecipM :: Int64 -> Int64\nrecipM !x = case exEuclid x modulo of\n             (1,a,_) -> a `mod` modulo\n             (-1,a,_) -> (-a) `mod` modulo\ndivM :: Int64 -> Int64 -> Int64\ndivM !x !y = x `mulMod` recipM y\n\ninstance Fractional N where\n  (/) = coerce divM\n  recip = coerce recipM\n  fromRational = undefined\n\n---\n\nnewtype instance UM.MVector s N = MV_N (UM.MVector s Int64)\nnewtype instance U.Vector N = V_N (U.Vector Int64)\n\ninstance Data.Vector.Generic.Mutable.MVector UM.MVector N where -- needs MultiParamTypeClasses here\n  basicLength (MV_N mv) = Data.Vector.Generic.Mutable.basicLength mv\n  basicUnsafeSlice i l (MV_N mv) = MV_N (Data.Vector.Generic.Mutable.basicUnsafeSlice i l mv)\n  basicOverlaps (MV_N mv) (MV_N mv') = Data.Vector.Generic.Mutable.basicOverlaps mv mv'\n  basicUnsafeNew l = MV_N <$> Data.Vector.Generic.Mutable.basicUnsafeNew l\n  basicInitialize (MV_N mv) = Data.Vector.Generic.Mutable.basicInitialize mv\n  basicUnsafeReplicate i x = MV_N <$> Data.Vector.Generic.Mutable.basicUnsafeReplicate i (coerce x)\n  basicUnsafeRead (MV_N mv) i = coerce <$> Data.Vector.Generic.Mutable.basicUnsafeRead mv i\n  basicUnsafeWrite (MV_N mv) i x = Data.Vector.Generic.Mutable.basicUnsafeWrite mv i (coerce x)\n  basicClear (MV_N mv) = Data.Vector.Generic.Mutable.basicClear mv\n  basicSet (MV_N mv) x = Data.Vector.Generic.Mutable.basicSet mv (coerce x)\n  basicUnsafeCopy (MV_N mv) (MV_N mv') = Data.Vector.Generic.Mutable.basicUnsafeCopy mv mv'\n  basicUnsafeMove (MV_N mv) (MV_N mv') = Data.Vector.Generic.Mutable.basicUnsafeMove mv mv'\n  basicUnsafeGrow (MV_N mv) n = MV_N <$> Data.Vector.Generic.Mutable.basicUnsafeGrow mv n\n\ninstance Data.Vector.Generic.Vector U.Vector N where -- needs MultiParamTypeClasses here\n  basicUnsafeFreeze (MV_N mv) = V_N <$> Data.Vector.Generic.basicUnsafeFreeze mv\n  basicUnsafeThaw (V_N v) = MV_N <$> Data.Vector.Generic.basicUnsafeThaw v\n  basicLength (V_N v) = Data.Vector.Generic.basicLength v\n  basicUnsafeSlice i l (V_N v) = V_N (Data.Vector.Generic.basicUnsafeSlice i l v)\n  basicUnsafeIndexM (V_N v) i = coerce <$> Data.Vector.Generic.basicUnsafeIndexM v i\n  basicUnsafeCopy (MV_N mv) (V_N v) = Data.Vector.Generic.basicUnsafeCopy mv v\n  elemseq (V_N v) x y = Data.Vector.Generic.elemseq v (coerce x) y\n\ninstance U.Unbox N\n"
  },
  {
    "language": "Text",
    "code": "3"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define repp(i,l,r,k)for(ll i=(l);i<(r);i+=(k))\n#define INF ((1LL<<62)-(1LL<<31))\n#define max(p,q)((p)>(q)?(p):(q))\n#define min(p,q)((p)<(q)?(p):(q))\n#define bit(n,m)(((n)>>(m))&1)\nint upll(const void*a, const void*b){return*(ll*)a<*(ll*)b?-1:*(ll*)a>*(ll*)b?1:0;}\nint downll(const void*a, const void*b){return*(ll*)a<*(ll*)b?1:*(ll*)a>*(ll*)b?-1:0;}\nvoid sortup(ll*a,int n){qsort(a,n,sizeof(ll),upll);}\nvoid sortdown(ll*a,int n){qsort(a,n,sizeof(ll),downll);}\nll pom(ll a,ll n,int m){ll x=1;for(a%=m;n;n/=2)n&1?x=x*a%m:0,a=a*a%m;return x;}\n#define MOD 998244353\n//#define MOD 1000000007\n#define invp(a,p)pom(a,p-2,p)\n\n\n//階乗,二項係数\n//*\nll fact[2000010];\nll invfact[2000010];\nvoid makefact(int n,ll m){\n\tn=min(n,m-1);\n\tfact[0]=1;\n\trep(i,0,n)fact[i+1]=fact[i]*(i+1)%m;\n\tinvfact[n]=invp(fact[n],m);\n\tfor(int i=n;i>0;i--)invfact[i-1]=invfact[i]*i%m;\n}\nll choose(int n,int r,int m){return n<0||r<0||n-r<0?0:fact[n]*invfact[r]%m*invfact[n-r]%m;}\n//*/\n\nint main(){\n\tll n,m;\n\tscanf(\"%lld%lld\",&n,&m);\n\tmakefact(2000005,MOD);\n\tll ans=0;\n\trep(i,m,m*3/2+1){\n\t\t//和がiになるようn個に振り分け\n\t\tll aa=choose(i+n-1,n-1,MOD);\n\t\t//m以上は使えない\n\t\tll bb=n*choose(i-m+n-1,n-1,MOD);\n\t\t//m未満しかないときは好きにできる\n\t\tll cc=(aa-bb)%MOD*choose(n,m*3-i*2,MOD);\n\t\t//mが1つある(⇔i-mをn-1個に振り分け)\n\t\tll dd=n*choose(i-m+n-2,n-2,MOD);\n\t\t//mを避けて好きに割り振れる\n\t\tll ee=dd%MOD*choose(n-1,m*3-i*2,MOD);\n\t\t//足す\n\t\tans=(ans+cc+ee)%MOD;\n\t}\n\tprintf(\"%lld\",(ans+MOD)%MOD);\n}"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thx Ebi-chan!\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 20000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\ntypedef struct {\n\tdouble a;\n\tdouble b;\n} hwreal;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(sll);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleCABcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.c, r.c);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwrealcomp){\n\tDEFLR(hwreal);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\nint32_t pfracomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tCMPRET(l.a * r.b, l.b * r.a);\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nvoid sw (sll *l, sll *r) {\n\tsll t = *l;\n\t*l = *r;\n\t*r = t;\n}\n\null frac[N_MAX * 3], invf[N_MAX * 3];\null ncr (sll n, sll r, ull m) {\n\tif (n < 0 || r < 0 || n < r) return 0;\n\treturn frac[n] * (invf[r] * invf[n - r] % m) % m;\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX * 4];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\n// sll table[3005][3005];\null gin[N_MAX];\n// here we go\n\null put (ull n, ull r) {\n\treturn ncr(r + n - 1, r, FOD);\n}\null f1 () {\n\tsll i;\n\tull result = 0;\n\tfor (i = 0; i <= m; i++) {\n\t\tif (i > n) break;\n\t\tif ((m * 3 - i) % 2) continue;\n\n\t\tresult += (ncr(n, i, FOD) * put(n, (m * 3 - i) / 2) % FOD);\n\t\t// printf(\"%llu...\\n\", result);\n\t}\n\treturn result %= FOD;\n}\null f2 () {\n\tsll i;\n\tull result = 0;\n\tfor (i = 0; i <= m; i++) {\n\t\tif (i > n) break;\n\t\tif ((m - i) % 2) continue;\n\n\t\tresult += (ncr(n, i, FOD) * put(n, (m - i) / 2) % FOD);\n\t}\n\tresult %= FOD;\n\tresult = (result * n) % FOD;\n\treturn result %= FOD;\n}\null f3 () {\n\tsll i;\n\tull result = 0;\n\tfor (i = 0; i <= m; i++) {\n\t\tif (i > n - 1) break;\n\t\tif ((m - i) % 2) continue;\n\n\t\tresult += (ncr(n - 1, i, FOD) * put(n - 1, (m - i) / 2) % FOD);\n\t}\n\tresult %= FOD;\n\tresult = (result * n) % FOD;\n\treturn result %= FOD;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tsll *dpcell;\n\n\tfrac[0] = invf[0] = 1;\n\tfor (i = 1; i <= m * 3 + n; i++) {\n\t\tfrac[i] = frac[i - 1] * i % FOD;\n\t\tinvf[i] = divide(invf[i - 1], i, FOD);\n\t}\n\n\t// printf(\"%llu - %llu + %llu\\n\", f1(), f2(), f3());\n\tresult = (FOD + f1() - f2() + f3()) % FOD;\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15f\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"First\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\tputs(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Second\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 5;\n\tm = 0;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld\", &va, &vb, &vc, &vd);\n\t// va--;\n\t// vb--;\n\t// scanf(\"%llu%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld\", &a[i]);\n\t// \tscanf(\"%lld\", &d[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < 0; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\t// scanf(\"%lld\", &c[i]);\n\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// scanf(\"%llu\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \t// scanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \t// scanf(\"%lld\", &e[i]);\n\t// \t// c[i]--;\n\t// \t// d[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < m; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nconst long long Mod = 998244353;\n\nlong long div_mod(long long x, long long y, long long z)\n{\n\tif (x % y == 0) return x / y;\n\telse return (div_mod((1 + x / y) * y - x, (z % y), y) * z + x) / y;\n}\n\nint main()\n{\n\tint N, M;\n\tscanf(\"%d %d\", &N, &M);\n\n\tint i, max = N + M * 3;\n\tlong long fact[2500001], fact_inv[2500001];\n\tfor (i = 1, fact[0] = 1; i <= max; i++) fact[i] = fact[i-1] * i % Mod;\n\tfor (i = max - 1, fact_inv[max] = div_mod(1, fact[max], Mod); i >= 0; i--) fact_inv[i] = fact_inv[i+1] * (i + 1) % Mod;\n\t\n\tlong long ans = fact[max-1] * fact_inv[N-1] % Mod * fact_inv[max-N] % Mod;\n\tfor (i = M - 1; i >= 0; i--) ans = (ans - fact[N+i-2] * fact_inv[N-2] % Mod * fact_inv[i] % Mod * N % Mod + Mod) % Mod;\n\tfor (i = M + 2; i <= M * 3 && i <= N; i += 2) ans = (ans - fact[N] * fact_inv[i] % Mod * fact_inv[N-i] % Mod * fact[(max-N-i)/2+N-1] % Mod * fact_inv[N-1] % Mod * fact_inv[(max-N-i)/2] % Mod + Mod) % Mod;\n\tprintf(\"%lld\\n\", ans);\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20190714\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 998244353\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nvoid swap(int *a,int *b){int c;c=(*a);(*a)=(*b);(*b)=c;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\nvoid llswap(long long *a,long long *b){long long c;c=(*a);(*a)=(*b);(*b)=c;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nvoid dbswap(double *a,double *b){double c;c=(*a);(*a)=(*b);(*b)=c;}\nvoid chswap(char *a,char *b){char c;c=(*a);(*a)=(*b);(*b)=c;}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    srand(time(0));\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\ntypedef struct{\nint val;\nint node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\nvoid coordinate_comp(int a[],int n){\n  int i,c=0;\n  sd dat[524288];\n  for(i=0;i<n;i++){\n    dat[i].val=a[i];\n    dat[i].node=i;\n  }\n  qsort(dat,n,sizeof(dat[0]),sdsortfnc);\n  a[dat[0].node]=c;\n  for(i=1;i<n;i++){\n    if(dat[i-1].val!=dat[i].val){c++;}\n    a[dat[i].node]=c;\n  }\n}\n\nlong long power(long long a,long long b){\n  long long x=1,y=a;\n  while(b>0){\n    if(b&1ll){\n      x=(x*y)%mod;\n    }\n    y=(y*y)%mod;\n    b>>=1;\n  }\n  return x%mod;\n}\n\nlong long modular_inverse(long long n){\n  return power(n,mod-2);\n}\n\nlong long factorial[4194304];\nlong long invfact[4194304];\n\nvoid cfact(){\n  long long i;\n  factorial[0]=1;\n  factorial[1]=1;\n  for(i=2;i<4194304;i++){\n    factorial[i]=factorial[i-1]*i;\n    factorial[i]%=mod;\n  }\n  invfact[4194303]=modular_inverse(factorial[4194303]);\n  for(i=4194302;i>=0;i--){\n    invfact[i]=invfact[i+1]*(i+1);\n    invfact[i]%=mod;\n  }\n}\n\nlong long calcnCr(long long n,long long k){\n  return (factorial[n]*((invfact[k]*invfact[n-k])%mod))%mod;\n}\n\nlong long Yooh(long long n,long long sigma,long long m){\n  long long i,r=0,t=llmin(n,m),w;\n  for(i=0;i<=t;i++){\n    if((sigma-i)%2==1){continue;}\n    w=calcnCr(n,i);\n    w*=calcnCr(((sigma-i)/2)+(n-1),(n-1));w%=mod;\n    r+=w;r%=mod;\n  }\n  //printf(\"%lld %lld %lld : %lld\\n\",n,sigma,m,r);\n  return r;\n}\n\nint main(void){\n  cfact();\n  long long i,j,n,m,k,a,b,c,h,w,r=0,l,t;\n  scanf(\"%lld%lld\",&n,&m);\n  r=mod;\n  r+=Yooh(n,3*m,m);\n  r-=((n*Yooh(n,m,m))%mod);\n  r+=((n*Yooh(n-1,m,m))%mod);\n  printf(\"%lld\\n\",r%mod);\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20190714\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 998244353\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nvoid swap(int *a,int *b){int c;c=(*a);(*a)=(*b);(*b)=c;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\nvoid llswap(long long *a,long long *b){long long c;c=(*a);(*a)=(*b);(*b)=c;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nvoid dbswap(double *a,double *b){double c;c=(*a);(*a)=(*b);(*b)=c;}\nvoid chswap(char *a,char *b){char c;c=(*a);(*a)=(*b);(*b)=c;}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    srand(time(0));\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\ntypedef struct{\nint val;\nint node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\nvoid coordinate_comp(int a[],int n){\n  int i,c=0;\n  sd dat[524288];\n  for(i=0;i<n;i++){\n    dat[i].val=a[i];\n    dat[i].node=i;\n  }\n  qsort(dat,n,sizeof(dat[0]),sdsortfnc);\n  a[dat[0].node]=c;\n  for(i=1;i<n;i++){\n    if(dat[i-1].val!=dat[i].val){c++;}\n    a[dat[i].node]=c;\n  }\n}\n\nlong long power(long long a,long long b){\n  long long x=1,y=a;\n  while(b>0){\n    if(b&1ll){\n      x=(x*y)%mod;\n    }\n    y=(y*y)%mod;\n    b>>=1;\n  }\n  return x%mod;\n}\n\nlong long modular_inverse(long long n){\n  return power(n,mod-2);\n}\n\nlong long factorial[524288];\nlong long invfact[524288];\n\nvoid cfact(){\n  long long i;\n  factorial[0]=1;\n  factorial[1]=1;\n  for(i=2;i<524288;i++){\n    factorial[i]=factorial[i-1]*i;\n    factorial[i]%=mod;\n  }\n  invfact[524287]=modular_inverse(factorial[524287]);\n  for(i=524286;i>=0;i--){\n    invfact[i]=invfact[i+1]*(i+1);\n    invfact[i]%=mod;\n  }\n}\n\nlong long calcnCr(long long n,long long k){\n  return (factorial[n]*((invfact[k]*invfact[n-k])%mod))%mod;\n}\n\nlong long Yooh(long long n,long long sigma,long long m){\n  long long i,r=0,t=llmin(n,m),w;\n  for(i=0;i<=t;i++){\n    if((sigma-i)%2==1){continue;}\n    w=calcnCr(n,i);\n    w*=calcnCr(((sigma-i)/2)+(n-1),(n-1));w%=mod;\n    r+=w;r%=mod;\n  }\n  //printf(\"%lld %lld %lld : %lld\\n\",n,sigma,m,r);\n  return r;\n}\n\nint main(void){\n  cfact();\n  long long i,j,n,m,k,a,b,c,h,w,r=0,l,t;\n  scanf(\"%lld%lld\",&n,&m);\n  r=mod;\n  r+=Yooh(n,3*m,m);\n  r-=((n*Yooh(n,m,m))%mod);\n  r+=((n*Yooh(n-1,m,m))%mod);\n  printf(\"%lld\\n\",r%mod);\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20190714\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 998244353\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nvoid swap(int *a,int *b){int c;c=(*a);(*a)=(*b);(*b)=c;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\nvoid llswap(long long *a,long long *b){long long c;c=(*a);(*a)=(*b);(*b)=c;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nvoid dbswap(double *a,double *b){double c;c=(*a);(*a)=(*b);(*b)=c;}\nvoid chswap(char *a,char *b){char c;c=(*a);(*a)=(*b);(*b)=c;}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    srand(time(0));\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\ntypedef struct{\nint val;\nint node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\nvoid coordinate_comp(int a[],int n){\n  int i,c=0;\n  sd dat[524288];\n  for(i=0;i<n;i++){\n    dat[i].val=a[i];\n    dat[i].node=i;\n  }\n  qsort(dat,n,sizeof(dat[0]),sdsortfnc);\n  a[dat[0].node]=c;\n  for(i=1;i<n;i++){\n    if(dat[i-1].val!=dat[i].val){c++;}\n    a[dat[i].node]=c;\n  }\n}\n\nlong long power(long long a,long long b){\n  long long x=1,y=a;\n  while(b>0){\n    if(b&1ll){\n      x=(x*y)%mod;\n    }\n    y=(y*y)%mod;\n    b>>=1;\n  }\n  return x%mod;\n}\n\nlong long modular_inverse(long long n){\n  return power(n,mod-2);\n}\n\nlong long factorial[4194304];\nlong long invfact[4194304];\n\nvoid cfact(){\n  long long i;\n  factorial[0]=1;\n  factorial[1]=1;\n  for(i=2;i<4194304;i++){\n    factorial[i]=factorial[i-1]*i;\n    factorial[i]%=mod;\n  }\n  invfact[4194303]=modular_inverse(factorial[4194303]);\n  for(i=4194302;i>=0;i--){\n    invfact[i]=invfact[i+1]*(i+1);\n    invfact[i]%=mod;\n  }\n}\n\nlong long calcnCr(long long n,long long k){\n  return (factorial[n]*((invfact[k]*invfact[n-k])%mod))%mod;\n}\n\nlong long Yooh(long long n,long long sigma,long long m){\n  long long i,r=0,t=llmin(n,m),w;\n  for(i=0;i<=t;i++){\n    if((sigma-i)%2==1){continue;}\n    w=calcnCr(n,i);\n    w*=calcnCr(((sigma-i)/2)+(n-1),(n-1));w%=mod;\n    r+=w;r%=mod;\n  }\n  //printf(\"%lld %lld %lld : %lld\\n\",n,sigma,m,r);\n  return r;\n}\n\nint main(void){\n  cfact();\n  long long i,j,n,m,k,a,b,c,h,w,r=0,l,t;\n  scanf(\"%lld%lld\",&n,&m);\n  r=mod;\n  r+=Yooh(n,3*m,m);\n  r-=((n*Yooh(n,m,m))%mod);\n  r+=((n*Yooh(n-1,m,m))%mod);\n  printf(\"%lld\\n\",r%mod);\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(void) {\n    int S, T, p, i;\n    \n\n    time(NULL);\n    p = random()%100;\n\n\n\n    scanf(\"%d\", &S);\n    scanf(\"%d\", &T);\n    \n    printf(\"%d \", (S+T)*p);\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tprepareFact();\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint sum = m * 3;\n\t\tlong ans = combiMod(n - 1 + sum, n - 1);\n\t\tfor(int i = m * 2 + 1; i <= sum; i ++) {\n\t\t\tlong tmp = combiMod(n - 2 + (sum - i), n - 2);\n\t\t\ttmp = mod(tmp * (long)n);\n\t\t\tans = mod(ans - tmp);\n\t\t}\n\n\t\tfor(int i = m + 1; i <= n; i ++) {\n\t\t\tint rest = sum - i;\n\t\t\tif(rest % 2 != 0) { continue; }\n\t\t\tlong tmp = combiMod(n - 1 + rest / 2, n - 1);\n\t\t\ttmp = mod(tmp * combiMod(n, i));\n\t\t\tans = mod(ans - tmp);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic long MOD = 998244353;\n\tpublic static long mod(long i) {\n\t\treturn i % MOD + ((i % MOD) < 0 ? MOD : 0);\n\t}\n\t\n\tstatic long powerMod(long x, long y) {\n\t\tif (y == 0) {\n\t\t\treturn 1;\n\t\t} else if (y == 1) {\n\t\t\treturn x;\n\t\t} else if (y % 2 == 0) {\n\t\t\tlong tmp = powerMod(x, y / 2);\n\t\t\treturn mod(tmp * tmp);\n\t\t} else {\n\t\t\tlong tmp = powerMod(x, y / 2);\n\t\t\treturn mod(mod(tmp * tmp) * x);\n\t\t}\n\t}\n\t\n\tstatic long invMod(long x) {\n\t\treturn powerMod(x, MOD - 2);\n\t}\n\t\n\tstatic int MAX_FACT = 3_000_100;\n\tstatic long factMod[] = new long[MAX_FACT];\n\tstatic void prepareFact() {\n\t\tfactMod[0] = 1;\n\t\tfor(int i = 1; i < MAX_FACT; i ++) {\n\t\t\tfactMod[i] = mod(factMod[i - 1] * i);\n\t\t}\n\t}\n\t\n\tstatic long combiMod(int n, int r) {\n\t\tif(n < 0 || n < r) { return 0; }\n\t\tif(r == 0 || r == n) { return 1; }\n\t\treturn mod(mod(factMod[n] * invMod(factMod[r])) * invMod(factMod[n - r]));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n// import java.awt.Point;\n \npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n \n    // static int mod = 1_000_000_007;\n    int mod = 998244353;\n    // long inf = Long.MAX_VALUE/2;\n    int inf = Integer.MAX_VALUE/2;\n\n    void solve(){\n        int n = ni();\n        int m = ni();\n        int[][] fif = enumFIF(1000000, mod);  \n        long three_m = C(3*m+n-1, n-1, mod, fif);\n        long over_2m = 0;\n        for(int i = 1; i <= m; i++){\n            over_2m += C(m-i+n-2, n-2, mod, fif)*n;\n            over_2m %= mod;\n        } \n        if(n<=m){\n            long ans = (three_m - over_2m + mod)%mod;\n            out.println(ans);\n            return;\n        }\n        long single_over_m = 0;\n        for(int i = m+1; i <= n; i++){\n            int a = 3*m-i;\n            if(a%2!=0) continue;\n            long s = C(n,i,mod,fif);\n            long t = C(a/2+n-1, a/2, mod, fif);\n            single_over_m += s*t;\n            single_over_m %= mod;\n        }     \n        long ans = (mod+(three_m - over_2m - single_over_m)%mod)%mod;\n        out.println(ans);\n    }\n\n    public static long C(int n, int r, int mod, int[][] fif) {\n        if (n < 0 || r < 0 || r > n)\n            return 0;\n        return (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n    }\n\n    \n    public static int[][] enumFIF(int n, int mod) {\n        int[] f = new int[n + 1];\n        int[] invf = new int[n + 1];\n        f[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            f[i] = (int) ((long) f[i - 1] * i % mod);\n        }\n        long a = f[n];\n        long b = mod;\n        long p = 1, q = 0;\n        while (b > 0) {\n            long c = a / b;\n            long d;\n            d = a;\n            a = b;\n            b = d % b;\n            d = p;\n            p = q;\n            q = d - c * q;\n        }\n        invf[n] = (int) (p < 0 ? p + mod : p);\n        for (int i = n - 1; i >= 0; i--) {\n            invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n        }\n        return new int[][] { f, invf };\n    }\n\n    void run() throws Exception\n    {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception { new Main().run(); }\n    \n    private byte[] inbuf = new byte[1024];\n    private int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b) && b != ' ')){\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }\n \n}\n"
  },
  {
    "language": "Java",
    "code": "\npublic class Main {\n\n  private static void solve() {\n    int n = ni();\n    int m = ni();\n\n    System.out.println(solve(n, m));\n  }\n\n  static int mod = 998244353;\n  static int[][] fif = enumFIF(2 * 1000000, mod);\n\n  private static long solve(int n, int m) {\n    long ret = 0;\n    for (int odd = m % 2; odd <= m; odd += 2) {\n      int last = (3 * m - odd) / 2;\n\n      long now = C(n, odd, mod, fif) * C(last + n - 1, n - 1, mod, fif) % mod;\n\n      long ng1 = C(n, odd, mod, fif) * odd % mod * C(last - m + (n - 1), n - 1, mod, fif) % mod;\n      long ng2 = C(n, odd, mod, fif) * (n - odd) % mod\n          * C(last - (m + 1) + (n - 1), n - 1, mod, fif) % mod;\n\n      now += mod - ng1;\n      now += mod - ng2;\n\n      ret += now;\n      ret %= mod;\n    }\n    return ret;\n  }\n\n\n\n  public static int[][] enumFIF(int n, int mod) {\n    int[] f = new int[n + 1];\n    int[] invf = new int[n + 1];\n    f[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      f[i] = (int) ((long) f[i - 1] * i % mod);\n    }\n    long a = f[n];\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    invf[n] = (int) (p < 0 ? p + mod : p);\n    for (int i = n - 1; i >= 0; i--) {\n      invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n    }\n    return new int[][] {f, invf};\n  }\n\n  public static long C(int n, int r, int mod, int[][] fif) {\n    if (n < 0 || r < 0 || r > n)\n      return 0;\n    return (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tprepareFact();\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint sum = m * 3;\n\t\tlong ans = combiMod(n - 1 + sum, n - 1);\n\t\tfor(int i = m * 2 + 1; i <= sum; i ++) {\n\t\t\tlong tmp = combiMod(n - 2 + (sum - i), n - 2);\n\t\t\ttmp = mod(tmp * (long)n);\n\t\t\tans = mod(ans - tmp);\n\t\t}\n\n\t\tfor(int i = m + 1; i <= n; i ++) {\n\t\t\tint rest = sum - i;\n\t\t\tif(rest % 2 != 0) { continue; }\n\t\t\tlong tmp = combiMod(n - 1 + rest / 2, n - 1);\n\t\t\ttmp = mod(tmp * combiMod(n, i));\n\t\t\tans = mod(ans - tmp);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic long MOD = 998244353;\n\tpublic static long mod(long i) {\n\t\treturn i % MOD + ((i % MOD) < 0 ? MOD : 0);\n\t}\n\t\n\tstatic long powerMod(long x, long y) {\n\t\tif (y == 0) {\n\t\t\treturn 1;\n\t\t} else if (y == 1) {\n\t\t\treturn x;\n\t\t} else if (y % 2 == 0) {\n\t\t\tlong tmp = powerMod(x, y / 2);\n\t\t\treturn mod(tmp * tmp);\n\t\t} else {\n\t\t\tlong tmp = powerMod(x, y / 2);\n\t\t\treturn mod(mod(tmp * tmp) * x);\n\t\t}\n\t}\n\t\n\tstatic long invMod(long x) {\n\t\treturn powerMod(x, MOD - 2);\n\t}\n\t\n\tstatic int MAX_FACT = 2_000_100;\n\tstatic long factMod[] = new long[MAX_FACT];\n\tstatic void prepareFact() {\n\t\tfactMod[0] = 1;\n\t\tfor(int i = 1; i < MAX_FACT; i ++) {\n\t\t\tfactMod[i] = mod(factMod[i - 1] * i);\n\t\t}\n\t}\n\t\n\tstatic long combiMod(int n, int r) {\n\t\tif(n < 0 || n < r) { return 0; }\n\t\tif(r == 0 || r == n) { return 1; }\n\t\treturn mod(mod(factMod[n] * invMod(factMod[r])) * invMod(factMod[n - r]));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tprepareFact();\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint sum = m * 3;\n\t\tlong ans = H(n, sum);\n\t\tfor(int i = m * 2 + 1; i <= sum; i ++) {\n\t\t\tlong tmp = H(n - 1, sum - i);\n\t\t\ttmp = mod(tmp * (long)n);\n\t\t\tans = mod(ans - tmp);\n\t\t}\n\n\t\tlong minus = 0;\n\t\tfor(int i = m + 2; i <= n; i += 2) {\n\t\t\tlong tmp = H(n, (sum - i) / 2);\n\t\t\ttmp = mod(tmp * C(n, i));\n\t\t\tminus = mod(minus + tmp);\n\t\t}\n\t\tans = mod(ans - minus);\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic long MOD = 998244353;\n\tpublic static long mod(long i) {\n\t\treturn i % MOD + ((i % MOD) < 0 ? MOD : 0);\n\t}\n\t\n\tstatic long pow(long x, long y) {\n\t\tif (y == 0) {\n\t\t\treturn 1;\n\t\t} else if (y == 1) {\n\t\t\treturn x;\n\t\t} else if (y % 2 == 0) {\n\t\t\tlong tmp = pow(x, y / 2);\n\t\t\treturn mod(tmp * tmp);\n\t\t} else {\n\t\t\tlong tmp = pow(x, y / 2);\n\t\t\treturn mod(mod(tmp * tmp) * x);\n\t\t}\n\t}\n\t\n\tstatic long inv(long x) {\n\t\treturn pow(x, MOD - 2);\n\t}\n\t\n\tstatic int MAX_FACT = 2_500_100;\n\tstatic long fact[] = new long[MAX_FACT];\n\tstatic long invFact[] = new long[MAX_FACT];\n\tstatic void prepareFact() {\n\t\tfact[0] = 1;\n\t\tfor(int i = 1; i < MAX_FACT; i ++) {\n\t\t\tfact[i] = mod(fact[i - 1] * i);\n\t\t}\n\t\tinvFact[MAX_FACT - 1] = inv(fact[MAX_FACT - 1]);\n\t\tfor(int i = MAX_FACT - 1; i > 0; i --) {\n\t\t\tinvFact[i - 1] = mod(invFact[i] * i);\n\t\t}\n\t}\n\n\tstatic long P(int n, int r) {\n\t\tif(n < 0 || r < 0 || n < r) { return 0; }\n\t\treturn mod(fact[n] * invFact[n - r]);\n\t}\n\tstatic long C(int n, int r) {\n\t\tif(n < 0 || r < 0 || n < r) { return 0; }\n\t\treturn mod(P(n, r) * invFact[r]);\n\t}\n\tstatic long H(int n, int r) {\n\t\treturn C((n - 1) + r, r);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tprepareFact();\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint sum = m * 3;\n\t\tlong ans = combiMod(n - 1 + sum, n - 1);\n\t\tfor(int i = m * 2 + 1; i <= sum; i ++) {\n\t\t\tlong tmp = combiMod(n - 2 + (sum - i), n - 2);\n\t\t\ttmp = mod(tmp * (long)n);\n\t\t\tans = mod(ans - tmp);\n\t\t}\n\n\t\tlong minus = 0;\n\t\tfor(int i = m + 2; i <= n; i += 2) {\n\t\t\tlong tmp = permMod(n - 1 + (sum - i) / 2, n - 1);\n\t\t\ttmp = mod(tmp * combiMod(n, i));\n\t\t\tminus = mod(minus + tmp);\n\t\t}\n\t\tminus = mod(minus * invMod(factMod[n - 1]));\n\t\tans = mod(ans - minus);\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic long MOD = 998244353;\n\tpublic static long mod(long i) {\n\t\treturn i % MOD + ((i % MOD) < 0 ? MOD : 0);\n\t}\n\t\n\tstatic long powerMod(long x, long y) {\n\t\tif (y == 0) {\n\t\t\treturn 1;\n\t\t} else if (y == 1) {\n\t\t\treturn x;\n\t\t} else if (y % 2 == 0) {\n\t\t\tlong tmp = powerMod(x, y / 2);\n\t\t\treturn mod(tmp * tmp);\n\t\t} else {\n\t\t\tlong tmp = powerMod(x, y / 2);\n\t\t\treturn mod(mod(tmp * tmp) * x);\n\t\t}\n\t}\n\t\n\tstatic long invMod(long x) {\n\t\treturn powerMod(x, MOD - 2);\n\t}\n\t\n\tstatic int MAX_FACT = 2_500_100;\n\tstatic long factMod[] = new long[MAX_FACT];\n\tstatic void prepareFact() {\n\t\tfactMod[0] = 1;\n\t\tfor(int i = 1; i < MAX_FACT; i ++) {\n\t\t\tfactMod[i] = mod(factMod[i - 1] * i);\n\t\t}\n\t}\n\t\n\tstatic long combiMod(int n, int r) {\n\t\tif(n < 0 || n < r) { return 0; }\n\t\tif(r == 0 || r == n) { return 1; }\n\t\treturn mod(mod(factMod[n] * invMod(factMod[r])) * invMod(factMod[n - r]));\n\t}\n\n\tstatic long permMod(int n, int r) {\n\t\tif(n < 0 || n < r) { return 0; }\n\t\tif(r == 0) { return 1; }\n\t\treturn mod(factMod[n] * invMod(factMod[n - r]));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.lang.*;\nimport java.math.*;\npublic class Main {\n    public static int[] fact;\n    public static int mod;\n    public static void main(String[] args) throws Exception {\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n        StringTokenizer st = new StringTokenizer(bf.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        int m = Integer.parseInt(st.nextToken());\n        mod = 998244353;\n        fact = new int[3000001];\n        fact[0] = 1;\n        for(int i=1; i<fact.length; i++) fact[i] = (int)((1L*fact[i-1]*i)%mod);\n\n        long ans = getAns(n, 3*m, 2*m);\n        int sign = -1;\n        for(int numOnes = m+1; numOnes <= n; numOnes++) {\n          //out.println(ans);\n          if((3*m - numOnes) % 2 != 0) continue;\n          ans += (1L * sign * (1L*choose(n, numOnes) * getAns(n, (3*m-numOnes)/2, m) % mod)) % mod; //* choose(numOnes-1, numOnes-m-1)) % mod;\n          //out.println(getAns(n-numOnes, 3*m-numOnes, 2*m));\n        //  sign = -1*sign;\n          ans += mod;\n          ans %= mod;\n        }\n        out.println(ans);\n\n        // int n = Integer.parseInt(bf.readLine());\n        // StringTokenizer st = new StringTokenizer(bf.readLine());\n        // int[] a = new int[n]; for(int i=0; i<n; i++) a[i] = Integer.parseInt(st.nextToken());\n        // int n = Integer.parseInt(st.nextToken());\n\n        out.close(); System.exit(0);\n    }\n    // Exponentation\n    public static int getAns(int num, int sum, int upperbound) {\n      if((sum ==0) && (num == 0)) return 1;\n      long ans = 0L + 1L*choose(sum+num-1, num-1) - (1L*num*choose(num-1+(sum-upperbound-1), num-1))%mod  + mod;\n      return (int)(ans%mod);\n    }\n    public static int exp(int base, int e) {\n      if(e == 0) return 1;\n      if(e == 1) return base;\n      int val = exp(base, e/2);\n      int ans = (int)(1L*val*val % mod);\n      if(e % 2 == 1)\n        ans = (int)(1L*ans*base % mod);\n      return ans;\n    }\n    public static int inv(int base) {\n      return exp(base, mod-2);\n    }\n    public static int choose(int n, int m) {\n      if(n<0) return 0;\n      if(m<0) return 0;\n      if(m>n) return 0;\n      return (int)(1L*(1L*fact[n]*inv(fact[m]) %mod)*inv(fact[n-m]) % mod);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n  private static long solve(int n, int m) {\n    ModCalculator mc = new ModCalculator(998244353);\n    long answer = 0;\n    for (int numOnePair = 0; numOnePair <= m / 2; numOnePair++) {\n      int numTwo = m + numOnePair;\n      int numOne = m - 2 * numOnePair;\n      if (n - 1 >= numOne && n - 2 >= 0) {\n        long numPatternWithTwoM = mc.mul(n, mc.getC(numTwo - m + n - 2, n - 2));\n        long v = mc.mul(numPatternWithTwoM, mc.getC(n - 1, numOne));\n        answer = mc.add(answer, v);\n      }\n      if (n >= numOne) {\n        long v1 = mc.getC(numTwo + n - 1, n - 1);\n        long v2 = mc.mul(n, mc.getC(numTwo - m + n - 1, n - 1));\n        long numPatternWithoutTwoM = mc.sub(v1, v2);\n        long v = mc.mul(numPatternWithoutTwoM, mc.getC(n, numOne));\n        answer = mc.add(answer, v);\n      }\n    }\n    return answer;\n  }\n\n  private static void execute(ContestReader reader, ContestWriter out) {\n    /*\n    ModCalculator mc = new ModCalculator(998244353);\n    for (int i = 0; i < 10; i++) {\n      for (int j = 0; j <= i; j++) {\n        System.err.printf(\"%d %d %d\\n\", i, j, mc.getC(i, j));\n      }\n    }\n    */\n    int n = reader.nextInt();\n    int m = reader.nextInt();\n    out.println(solve(n, m));\n  }\n  \n  public static void main(String[] args) {\n    ContestReader reader = new ContestReader(System.in);\n    ContestWriter out = new ContestWriter(System.out);\n    execute(reader, out);\n    out.flush();\n  }\n}\n\nclass ModCalculator {\n  private final long mod;\n  private final ModCombinationCache modCombinationCache;\n  \n  ModCalculator(long mod) {\n    this.mod = mod;\n    this.modCombinationCache = new ModCombinationCache();\n  }\n  \n  public long norm(long v) {\n    return v % mod;\n  }\n  \n  public long add(long a, long b) {\n    return norm(a + b);\n  }\n  \n  public long sub(long a, long b) {\n    return norm(a - b + mod);\n  }\n  \n  public long mul(long a, long b) {\n    return norm(a * b);\n  }\n  \n  public long pow(long a, long b) {\n    if (b == 0) {\n      return 1;\n    }\n    long v = pow(mul(a, a), b / 2);\n    if (b % 2 == 1) {\n      return mul(v, a);\n    } else {\n      return v;\n    }\n  }\n  \n  public long inverse(long a) {\n    return pow(a, mod - 2);\n  }\n  \n  public long div(long a, long b) {\n    return mul(a, inverse(b));\n  }\n\n  // Verify ARC 042 D\n  // https://atcoder.jp/contests/arc042/tasks/arc042_d\n  // a^x mod p === b\n  // return -1 there is no such positive x\n  public long log(long a, long b) {\n    Map<Long, Long> map = new HashMap<>();\n    long powA = 1;\n    long rootP = 0;\n    while (true) {\n      if (powA == b && rootP != 0) {\n        return rootP;\n      }\n      if (map.containsKey(powA)) {\n        return -1;\n      }\n      map.put(powA, rootP);\n      powA = mul(powA, a);\n      rootP++;\n      if (rootP * rootP > mod) {\n        break;\n      }\n    }\n    long inversePowA = inverse(powA);\n    for (int i = 1; i <= rootP; i++) {\n      b = mul(b, inversePowA);\n      Long value = map.get(b);\n      if (value != null && value + rootP * i > 0) {\n        return value + rootP * i;\n      }\n    }\n    return -1;\n  }\n  \n  public long getF(int n) {\n    return modCombinationCache.getF(n);\n  }\n  \n  public long getP(int n, int r) {\n    return modCombinationCache.getP(n, r);\n  }\n  \n  public long getC(int n, int k) {\n    return modCombinationCache.getC(n, k);\n  }\n  \n  class ModCombinationCache {\n    /*\n    private final List<Long> factorialCache;\n    private final List<Long> factorialInverseCache;\n    */\n    long[] factorialCache;\n    long[] factorialInverseCache;\n    \n    public ModCombinationCache() {\n      factorialCache = new long[]{1};\n      factorialInverseCache = new long[]{1};\n    }\n    \n    private void resize(int newSize) {\n      long[] nextFactorialCache = new long[newSize];\n      long[] nextFactorialInverseCache = new long[newSize];\n      System.arraycopy(factorialCache, 0, nextFactorialCache, 0, factorialCache.length);\n      System.arraycopy(factorialInverseCache, 0, nextFactorialInverseCache, 0, factorialInverseCache.length);\n      for (int i = factorialCache.length; i < newSize; i++) {\n        long v = mul(nextFactorialCache[i - 1], i);\n//        System.err.printf(\"%d %d\\n\", i, v);\n        nextFactorialCache[i] = v;\n        nextFactorialInverseCache[i] = inverse(v);\n      }\n      factorialCache = nextFactorialCache;\n      factorialInverseCache = nextFactorialInverseCache;\n    }\n\n    private void resizeIfNeeded(int requestIndex) {\n      if (requestIndex < factorialCache.length) {\n        return;\n      }\n      int newSize = factorialCache.length;\n      while (requestIndex >= newSize) {\n        newSize *= 2;\n      }\n      resize(newSize);\n    }\n    \n    long getF(int n) {\n      resizeIfNeeded(n);\n      return factorialCache[n];\n    }\n    \n    long getP(int n, int r) {\n      resizeIfNeeded(n);\n      return mul(factorialCache[n], factorialInverseCache[n - r]);\n    }\n    \n    long getC(int n, int k) {\n      resizeIfNeeded(n);\n//      System.err.printf(\"%d %d %d %d %d\\n\", n, k, factorialCache[n], factorialInverseCache[k], factorialInverseCache[n-k]);\n      return mul(factorialCache[n], mul(factorialInverseCache[k], factorialInverseCache[n-k]));\n    }\n  }\n}\n\nclass ContestWriter extends PrintWriter {\n  ContestWriter(PrintStream printeStream) {\n    super(printeStream);\n  }\n\n  public void printList(List<? extends Object> list) {\n    for (Object object : list) {\n      println(object);\n    }\n  }\n\n  public void printListOneLine(List<? extends Object> list) {\n    List<String> stringList = new ArrayList<>();\n    for (Object object : list) {\n      stringList.add(object.toString());\n    }\n    println(String.join(\" \", stringList));\n  }\n}\n\nclass ContestReader {\n  private static final int BUFFER_SIZE = 1024;\n  \n  private final InputStream stream;\n  private final byte[] buffer;\n  private int pointer;\n  private int bufferLength;\n  \n  ContestReader(InputStream stream) {\n    this.stream = stream;\n    this.buffer = new byte[BUFFER_SIZE];\n    this.pointer = 0;\n    this.bufferLength = 0;\n  }\n  \n  private boolean hasNextByte() {\n    if (pointer < bufferLength) {\n      return true;\n    }\n    \n    pointer = 0;\n    try {\n      bufferLength = stream.read(buffer);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    return bufferLength > 0;\n  }\n  \n  private int readByte() {\n    if (hasNextByte()) {\n      return buffer[pointer++];\n    } else {\n      return -1;\n    }\n  }\n  \n  private static boolean isPrintableChar(int c) {\n    return 33 <= c && c <= 126;\n  }\n  \n  public boolean hasNext() {\n    while (hasNextByte() && !isPrintableChar(buffer[pointer])) {\n      pointer++;\n    }\n    return hasNextByte();\n  }\n  \n  public String next() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    StringBuilder sb = new StringBuilder();\n    while(true) {\n      int b = readByte();\n      if (!isPrintableChar(b)) {\n        break;\n      }\n      sb.appendCodePoint(b);\n    }\n    return sb.toString();\n  }\n  \n  public String nextLine() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    StringBuilder sb = new StringBuilder();\n    while(true) {\n      int b = readByte();\n      if (!isPrintableChar(b) && b != 0x20) {\n        break;\n      }\n      sb.appendCodePoint(b);\n    }\n    return sb.toString();\n  }\n  \n  public char nextChar() {\n    return next().charAt(0);\n  }\n  \n  public int nextInt() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    int n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public long nextLong() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    long n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public double nextDouble() {\n    return Double.parseDouble(next());\n  }\n  \n  public String[] next(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = next();\n    }\n    return array;\n  }\n  \n  public String[] nextLine(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLine();\n    }\n    return array;\n  }\n  \n  public char[] nextChar(int n) {\n    char[] array = new char[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextChar();\n    }\n    return array;\n  }\n  \n  public int[] nextInt(int n) {\n    int[] array = new int[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextInt();\n    }\n    return array;\n  }\n  \n  public long[] nextLong(int n) {\n    long[] array = new long[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLong();\n    }\n    return array;\n  }\n  \n  public double[] nextDouble(int n) {\n    double[] array = new double[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextDouble();\n    }\n    return array;\n  }\n  \n  public char[] nextCharArray() {\n    return next().toCharArray();\n  }\n  \n  public String[][] next(int n, int m) {\n    String[][] matrix = new String[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = next();\n      }\n    }\n    return matrix;\n  }\n  \n  public int[][] nextInt(int n, int m) {\n    int[][] matrix = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextInt();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextChar(int n, int m) {\n    char[][] matrix = new char[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextChar();\n      }\n    }\n    return matrix;\n  }\n  \n  public long[][] nextLong(int n, int m) {\n    long[][] matrix = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextLong();\n      }\n    }\n    return matrix;\n  }\n  \n  public double[][] nextDouble(int n, int m) {\n    double[][] matrix = new double[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextDouble();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextCharArray(int n) {\n    char[][] matrix = new char[n][];\n    for (int i = 0; i < n; i++) {\n      matrix[i] = next().toCharArray();\n    }\n    return matrix;\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n  private static long solve(int n, int m) {\n    ModCalculator mc = new ModCalculator(998244353);\n    long answer = 0;\n    for (int numOnePair = 0; numOnePair <= m / 2; numOnePair++) {\n      int numTwo = m + numOnePair;\n      int numOne = m - 2 * numOnePair;\n      if (n - 1 >= numOne && n - 2 >= 0) {\n        long numPatternWithTwoM = mc.mul(n, mc.getC(numTwo - m + n - 2, n - 2));\n        long v = mc.mul(numPatternWithTwoM, mc.getC(n - 1, numOne));\n        answer = mc.add(answer, v);\n      }\n      if (n >= numOne) {\n        long v1 = mc.getC(numTwo + n - 1, n - 1);\n        long v2 = mc.mul(n, mc.getC(numTwo - m + n - 1, n - 1));\n        long numPatternWithoutTwoM = mc.sub(v1, v2);\n        long v = mc.mul(numPatternWithoutTwoM, mc.getC(n, numOne));\n        answer = mc.add(answer, v);\n      }\n    }\n    return answer;\n  }\n\n  private static void execute(ContestReader reader, ContestWriter out) {\n    int n = reader.nextInt();\n    int m = reader.nextInt();\n    out.println(solve(n, m));\n  }\n  \n  public static void main(String[] args) {\n    ContestReader reader = new ContestReader(System.in);\n    ContestWriter out = new ContestWriter(System.out);\n    execute(reader, out);\n    out.flush();\n  }\n}\n\nclass ModCalculator {\n  private final long mod;\n  private final ModCombinationCache modCombinationCache;\n  \n  ModCalculator(long mod) {\n    this.mod = mod;\n    this.modCombinationCache = new ModCombinationCache();\n  }\n  \n  public long norm(long v) {\n    return v % mod;\n  }\n  \n  public long add(long a, long b) {\n    return norm(a + b);\n  }\n  \n  public long sub(long a, long b) {\n    return norm(a - b + mod);\n  }\n  \n  public long mul(long a, long b) {\n    return norm(a * b);\n  }\n  \n  public long pow(long a, long b) {\n    if (b == 0) {\n      return 1;\n    }\n    long v = pow(mul(a, a), b / 2);\n    if (b % 2 == 1) {\n      return mul(v, a);\n    } else {\n      return v;\n    }\n  }\n  \n  public long inverse(long a) {\n    return pow(a, mod - 2);\n  }\n  \n  public long div(long a, long b) {\n    return mul(a, inverse(b));\n  }\n\n  // Verify ARC 042 D\n  // https://atcoder.jp/contests/arc042/tasks/arc042_d\n  // a^x mod p === b\n  // return -1 there is no such positive x\n  public long log(long a, long b) {\n    Map<Long, Long> map = new HashMap<>();\n    long powA = 1;\n    long rootP = 0;\n    while (true) {\n      if (powA == b && rootP != 0) {\n        return rootP;\n      }\n      if (map.containsKey(powA)) {\n        return -1;\n      }\n      map.put(powA, rootP);\n      powA = mul(powA, a);\n      rootP++;\n      if (rootP * rootP > mod) {\n        break;\n      }\n    }\n    long inversePowA = inverse(powA);\n    for (int i = 1; i <= rootP; i++) {\n      b = mul(b, inversePowA);\n      Long value = map.get(b);\n      if (value != null && value + rootP * i > 0) {\n        return value + rootP * i;\n      }\n    }\n    return -1;\n  }\n  \n  public long getF(int n) {\n    return modCombinationCache.getF(n);\n  }\n  \n  public long getP(int n, int r) {\n    return modCombinationCache.getP(n, r);\n  }\n  \n  public long getC(int n, int k) {\n    return modCombinationCache.getC(n, k);\n  }\n  \n  class ModCombinationCache {\n    private final List<Long> factorialCache;\n    private final List<Long> factorialInverseCache;\n    \n    public ModCombinationCache() {\n      factorialCache = new ArrayList<>();\n      factorialCache.add(1L);\n      factorialInverseCache = new ArrayList<>();\n      factorialInverseCache.add(1L);\n    }\n    \n    private void resize(int n) {\n      for (int i = factorialCache.size() - 1; i < n; i++) {\n        long v = mul(factorialCache.get(i), i + 1);\n        factorialCache.add(v);\n        factorialInverseCache.add(inverse(v));\n      }\n    }\n    \n    long getF(int n) {\n      resize(n);\n      return factorialCache.get(n);\n    }\n    \n    long getP(int n, int r) {\n      resize(n);\n      return mul(factorialCache.get(n), factorialInverseCache.get(n - r));\n    }\n    \n    long getC(int n, int k) {\n      resize(n);\n      return mul(factorialCache.get(n), mul(factorialInverseCache.get(k), factorialInverseCache.get(n-k)));\n    }\n  }\n}\n\nclass ContestWriter extends PrintWriter {\n  ContestWriter(PrintStream printeStream) {\n    super(printeStream);\n  }\n\n  public void printList(List<? extends Object> list) {\n    for (Object object : list) {\n      println(object);\n    }\n  }\n\n  public void printListOneLine(List<? extends Object> list) {\n    List<String> stringList = new ArrayList<>();\n    for (Object object : list) {\n      stringList.add(object.toString());\n    }\n    println(String.join(\" \", stringList));\n  }\n}\n\nclass ContestReader {\n  private static final int BUFFER_SIZE = 1024;\n  \n  private final InputStream stream;\n  private final byte[] buffer;\n  private int pointer;\n  private int bufferLength;\n  \n  ContestReader(InputStream stream) {\n    this.stream = stream;\n    this.buffer = new byte[BUFFER_SIZE];\n    this.pointer = 0;\n    this.bufferLength = 0;\n  }\n  \n  private boolean hasNextByte() {\n    if (pointer < bufferLength) {\n      return true;\n    }\n    \n    pointer = 0;\n    try {\n      bufferLength = stream.read(buffer);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    return bufferLength > 0;\n  }\n  \n  private int readByte() {\n    if (hasNextByte()) {\n      return buffer[pointer++];\n    } else {\n      return -1;\n    }\n  }\n  \n  private static boolean isPrintableChar(int c) {\n    return 33 <= c && c <= 126;\n  }\n  \n  public boolean hasNext() {\n    while (hasNextByte() && !isPrintableChar(buffer[pointer])) {\n      pointer++;\n    }\n    return hasNextByte();\n  }\n  \n  public String next() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    StringBuilder sb = new StringBuilder();\n    while(true) {\n      int b = readByte();\n      if (!isPrintableChar(b)) {\n        break;\n      }\n      sb.appendCodePoint(b);\n    }\n    return sb.toString();\n  }\n  \n  public String nextLine() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    StringBuilder sb = new StringBuilder();\n    while(true) {\n      int b = readByte();\n      if (!isPrintableChar(b) && b != 0x20) {\n        break;\n      }\n      sb.appendCodePoint(b);\n    }\n    return sb.toString();\n  }\n  \n  public char nextChar() {\n    return next().charAt(0);\n  }\n  \n  public int nextInt() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    int n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public long nextLong() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    long n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public double nextDouble() {\n    return Double.parseDouble(next());\n  }\n  \n  public String[] next(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = next();\n    }\n    return array;\n  }\n  \n  public String[] nextLine(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLine();\n    }\n    return array;\n  }\n  \n  public char[] nextChar(int n) {\n    char[] array = new char[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextChar();\n    }\n    return array;\n  }\n  \n  public int[] nextInt(int n) {\n    int[] array = new int[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextInt();\n    }\n    return array;\n  }\n  \n  public long[] nextLong(int n) {\n    long[] array = new long[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLong();\n    }\n    return array;\n  }\n  \n  public double[] nextDouble(int n) {\n    double[] array = new double[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextDouble();\n    }\n    return array;\n  }\n  \n  public char[] nextCharArray() {\n    return next().toCharArray();\n  }\n  \n  public String[][] next(int n, int m) {\n    String[][] matrix = new String[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = next();\n      }\n    }\n    return matrix;\n  }\n  \n  public int[][] nextInt(int n, int m) {\n    int[][] matrix = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextInt();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextChar(int n, int m) {\n    char[][] matrix = new char[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextChar();\n      }\n    }\n    return matrix;\n  }\n  \n  public long[][] nextLong(int n, int m) {\n    long[][] matrix = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextLong();\n      }\n    }\n    return matrix;\n  }\n  \n  public double[][] nextDouble(int n, int m) {\n    double[][] matrix = new double[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextDouble();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextCharArray(int n) {\n    char[][] matrix = new char[n][];\n    for (int i = 0; i < n; i++) {\n      matrix[i] = next().toCharArray();\n    }\n    return matrix;\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.NoSuchElementException;\nimport java.util.function.IntUnaryOperator;\nimport java.util.function.LongBinaryOperator;\nimport java.util.function.LongUnaryOperator;\n\n\npublic class Main {\n    public static void main(String[] args) {\n        StringBuilder out = new StringBuilder();\n        solve(out);\n        PrintWriter pw = new PrintWriter(System.out);\n        pw.println(out);\n        pw.flush();\n        pw.close();\n    }\n\n    public static void solve(StringBuilder out) {\n        int n = In.ni();\n        int m = In.ni();\n        ModuloArithmetic ma = new ModuloArithmetic(Const.MOD99);\n        long[] tab = new long[2 * m];\n        tab[0] = 1;\n        for (int i = 0; i < 2 * m - 1; i++) {\n            tab[i + 1] = ma.prod(tab[i], n - 2 + i + 1, ma.inv(i + 1));\n        }\n        for (int i = 0; i < 2 * m - 1; i++) {\n            tab[i + 1] = ma.add(tab[i], tab[i + 1]);\n        }\n        if (n <= m) {\n            long ans = ma.comb(3 * m + n - 1, n - 1) - ma.mul(n, tab[m - 1]);\n            out.append(ma.mod(ans));\n            return;\n        }\n        long[] nci = new long[n + 1];\n        nci[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            nci[i] = ma.prod(nci[i - 1], n - i + 1, ma.inv(i));\n        }\n        long ans = 0;\n        for (int i = m; i >= 0; i -= 2) {\n            int k = (3 * m - i) >> 1;\n            long add = ma.prod(ma.sub(tab[k], tab[k - 1]), k + n - 1, ma.inv(n - 1));\n            add -= ma.mul(i, tab[k - m]);\n            if (k > m) add -= ma.mul(n - i, tab[k - m - 1]);\n            ans += ma.mul(nci[i], ma.mod(add));\n        }\n        out.append(ma.mod(ans));\n    }\n}\n\n\n\nclass LongSemiRing extends LongExtendedMagma {\n    public LongSemiRing(final LongMonoid addition, final LongMonoid multiplication) {\n        super(addition, multiplication, TypicalPropertySets.SEMI_RING);\n        addition.requireProperties(EnumSet.of(Property.COMMUTATIVE));\n    }\n    public static LongSemiRing of(LongExtendedMagma m) {\n        if (!m.additiveProps.containsAll(TypicalPropertySets.COMMUTATIVE_MONOID.getProperties())) {\n            throw new ClassCastException(\"addition does not meet the conditions of commutative monoid.\");\n        }\n        LongCommutativeMonoid add = new LongCommutativeMonoid(m::add, m.e0);\n        LongMonoid mul = new LongMonoid(m::mul, m.e1);\n        return new LongSemiRing(add, mul);\n    }\n}\n\n\n\nclass LongMonoid extends LongMagma implements LongUnital {\n    public final long e;\n    public LongMonoid(final LongBinaryOperator operator, final long e) {\n        super(operator, TypicalPropertySets.MONOID);\n        this.e = e;\n    }\n    @Override\n    public long identityElement() {return e;}\n    public static <M extends LongMagma & LongUnital> LongMonoid of(M m) {\n        m.requireProperties(TypicalPropertySets.MONOID);\n        return new LongMonoid(m.operator, m.identityElement());\n    }\n}\n\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class ModuloArithmetic extends LongField {\n    public final long MOD;\n    public final LongAbelianGroup addition;\n    public final LongAbelianGroup multiplication;\n    /**\n     * support modulo p arithmetic\n     * @param p p s.t. p is a prime number.\n     */\n    public ModuloArithmetic(final long p) {\n        super(\n            new LongAbelianGroup((u, v) -> add(u, v, p), 0l, x -> -x),\n            new LongAbelianGroup((u, v) -> mul(u, v, p), 1l, x -> inv(x, p)));\n        this.addition = new LongAbelianGroup((u, v) -> add(u, v, p), 0l, x -> -x);\n        this.multiplication = new LongAbelianGroup((u, v) -> mul(u, v, p), 1l, x -> inv(x, p));\n        this.MOD = p;\n    }\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ x = a + b mod p.\n     */\n    private static long add(final long a, final long b, final long mod) {\n        final long s = a + b; return s < 0 ? s + mod : s >= mod ? s - mod : s;\n    }\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ x = a * b mod p.\n     */\n    private static long mul(final long a, final long b, final long mod) {\n        final long ret = (a * b) % mod; return ret < 0 ? ret + mod : ret;\n    }\n    /**\n     * Calculate the value b s.t. a*b mod MOD = 1.\n     */\n    private static long inv(long a, final long mod) {\n        long b = mod;\n        long u = 1, v = 0;\n        while (b >= 1) {\n            final long t = a / b;\n            a -= t * b;\n            final long tmp1 = a; a = b; b = tmp1;\n            u -= t * v;\n            final long tmp2 = u; u = v; v = tmp2;\n        }\n        u %= mod;\n        return u < 0 ? u + mod : u;\n    }\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ x = a mod p.\n     */\n    public long mod(long a) {a %= MOD; return a < 0 ? a + MOD : a;}\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ x = a_1 + 1_2 + ... + a_k mod p.\n     */\n    public long sum(final long... a) {\n        long ret = 0; for (final long c : a) ret += c;\n        return mod(ret);\n    }\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ x = a - b mod p.\n     */\n    public long sub(final long a, final long b) {\n        final long s = a - b; return s < 0 ? s + MOD : s >= MOD ? s - MOD : s;\n    }\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ x = a_1 * 1_2 * ... * a_k mod p.\n     */\n    public long prod(final long... a) {\n        long ret = 1; for (final long c : a) ret = (ret * c) % MOD;\n        return ret < 0 ? ret + MOD : ret;\n    }\n    /**\n     * Calculate x s.t. 0 <= x < MOD /\\ b * x = a mod p.\n     */\n    public long div(final long a, final long b) {return mul(a, inv(b));}\n    /**\n     * Calculate the value b s.t. a*b mod MOD = 1.\n     */\n    public long inv(long a) {\n        long b = MOD;\n        long u = 1, v = 0;\n        while (b >= 1) {\n            final long t = a / b;\n            a -= t * b;\n            final long tmp1 = a; a = b; b = tmp1;\n            u -= t * v;\n            final long tmp2 = u; u = v; v = tmp2;\n        }\n        return mod(u);\n    }\n    /**\n     * Calculate the permutation nPr.\n     */\n    public long perm(final long n, final long r) {\n        if (n < r) return 0;\n        long ret = 1; for (long i = n; i > n - r; i--) ret = mul(ret, i);\n        return ret;\n    }\n    public long perm(final int n, final int r, final long[] fact, final long[] ifact) {\n        if (n < r) return 0;\n        return mul(fact[n], ifact[n - r]);\n    }\n    /**\n     * Calculate the combination nCr.\n     */\n    public long comb(long n, long r) {\n        if (n < r) return 0;\n        r = Math.min(r, n - r);\n        n %= MOD;\n        long res = 1; for (long d = 1; d <= r; d++) res = div(mul(res, n--), d);\n        return res;\n    }\n    public long comb(final int n, final int r, final long[] fact, final long[] ifact) {\n        if (n < r) return 0;\n        return prod(fact[n], ifact[n - r], ifact[r]);\n    }\n    /**\n     * Calculate a^b (mod {@code MOD}) in O(log b) time.\n     */\n    public long pow(final long a, final long b) {\n        if (b == 0 || a == 1) return 1;\n        final long half = pow(a, b >> 1);\n        return (b & 1) == 0 ? mul(half, half) : prod(half, half, a);\n    }\n    /**\n     * calculate x := log_a b mod MOD. (i.e. a^x = b mod MOD). if not exists, return\n     * negative value.\n     */\n    public long log(final long a, final long b) {return log(a, b, getMapForLogarithm(a));}\n    public long log(long a, long b, final HashMap<Long, Long> aMap) {\n        a %= MOD; b %= MOD;\n        final long sq = (long) (Math.sqrt(MOD) + 2);\n        final long inv = pow(inv(a), sq);\n        for (long p = 0, r = b; p <= sq; p++) {\n            if (aMap.containsKey(r)) {\n                final long res = p * sq + aMap.get(r);\n                if (res > 0) return res;\n            }\n            r = mul(r, inv);\n        }\n        return -1;\n    }\n    public HashMap<Long, Long> getMapForLogarithm(long a) {\n        a %= MOD;\n        final long sq = (long) (Math.sqrt(MOD) + 2);\n        final HashMap<Long, Long> map = new HashMap<>();\n        for (long i = 0, ar = 1; i < sq; i++) {\n            map.putIfAbsent(ar, i);\n            ar = mul(ar, a);\n        }\n        return map;\n    }\n    /**\n     * build factorial array from 0 to n (closed)\n     */\n    public long[] factorialArray(final int n) {\n        final long[] fact = new long[n + 1];\n        fact[0] = fact[1] = 1;\n        for (int i = 0; i <= n; i++) fact[i] = mul(fact[i - 1], i);\n        return fact;\n    }\n    public long[] inversiveFactrialArray(final long[] fact) {\n        int n = fact.length - 1;\n        final long[] ifact = new long[n + 1];\n        ifact[n] = inv(fact[n]);\n        for (int i = n - 1; i >= 0; i--) ifact[i] = mul(ifact[i + 1], i + 1);\n        return ifact;\n    }\n    /**\n     * build power array based on a from 0 to n (closed)\n     * @param a base of power\n     * @param n\n     */\n    public long[] powerArray(final long a, final int n) {\n        if (a == 2) return powerArray(n);\n        final long[] pow = new long[n + 1];\n        pow[0] = 1; for (int i = 0; i <= n; i++) pow[i] = mul(pow[i - 1], a);\n        return pow;\n    }\n    /**\n     * build power array based on 2 from 0 to n (closed)\n     * @param n\n     */\n    public long[] powerArray(final int n) {\n        final long[] pow = new long[n + 1];\n        pow[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            pow[i] = pow[i - 1] << 1;\n            if (pow[i] >= MOD) pow[i] -= MOD;\n        }\n        return pow;\n    }\n}\n\n\n\nabstract class LongMagma extends PropertyHolder {\n    protected final LongBinaryOperator operator;\n    public LongMagma(final LongBinaryOperator operator, final EnumSet<Property> properties) {\n        super(properties);\n        this.operator = operator;\n    }\n    public LongMagma(final LongBinaryOperator operator, final TypicalPropertySets properties) {\n        super(properties);\n        this.operator = operator;\n    }\n    public final long apply(final long left, final long right) {return operator.applyAsLong(left, right);}\n}\n\n\n\nabstract class LongExtendedMagma extends PropertyHolder {\n    public final long e0, e1;\n    private final LongBinaryOperator addition, multiplication;\n    protected final EnumSet<Property> additiveProps, multiplicativeProps;\n    public LongExtendedMagma(LongMonoid addition, LongMonoid multiplication, EnumSet<Property> properties) {\n        super(properties);\n        this.addition = addition.operator;\n        this.multiplication = multiplication.operator;\n        this.e0 = addition.identityElement();\n        this.e1 = multiplication.identityElement();\n        this.additiveProps = addition.getProperties();\n        this.multiplicativeProps = multiplication.getProperties();\n    }\n    public LongExtendedMagma(LongMonoid addition, LongMonoid multiplication, TypicalPropertySets properties) {\n        this(addition, multiplication, properties.getProperties());\n    }\n    public final long add(long t, long u) {return addition.applyAsLong(t, u);}\n    public final long mul(long t, long u) {return multiplication.applyAsLong(t, u);}\n}\n\n\n\nclass LongField extends LongRing {\n    public LongField(final LongAbelianGroup addition, final LongMonoid multiplication) {\n        super(addition, multiplication);\n        multiplication.requireProperties(EnumSet.of(Property.COMMUTATIVE));\n    }\n}\n\n\n\nclass LongCommutativeMonoid extends LongMonoid {\n    public LongCommutativeMonoid(final LongBinaryOperator operator, final long e) {\n        super(operator, e);\n        addProperties(Property.COMMUTATIVE);\n    }\n    public static <M extends LongMagma & LongUnital> LongCommutativeMonoid of(M m) {\n        m.requireProperties(TypicalPropertySets.COMMUTATIVE_MONOID.getProperties());\n        return new LongCommutativeMonoid(m.operator, m.identityElement());\n    }\n}\n\n\nclass LongRing extends LongSemiRing {\n    private final LongUnaryOperator additiveInverse;\n    public LongRing(final LongAbelianGroup addition, final LongMonoid multiplication) {\n        super(addition, multiplication);\n        this.additiveInverse = addition::inverse;\n    }\n    public final long additiveInverse(final long t) {return additiveInverse.applyAsLong(t);}\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class In {\n    public static final FastScanner fsc = new FastScanner();\n    public static int ni() {return fsc.nextInt();}\n    public static int[] ni(final int n) {\n        final int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = fsc.nextInt();\n        return a;\n    }\n    public static int[] ni(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = f.applyAsInt(fsc.nextInt());\n        return a;\n    }\n    public static int[][] ni(final int n, final int m) {\n        final int[][] a = new int[n][m];\n        for (int i = 0; i < n; i++) a[i] = ni(m);\n        return a;\n    }\n    public static int[][] ni(final int n, final int m, final IntUnaryOperator f) {\n        final int[][] a = new int[n][m];\n        for (int i = 0; i < n; i++) a[i] = ni(m, f);\n        return a;\n    }\n    public static long nl() {return fsc.nextLong();}\n    public static long[] nl(final int n) {\n        final long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = fsc.nextLong();\n        return a;\n    }\n    public static long[] nl(final int n, final LongUnaryOperator f) {\n        final long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = f.applyAsLong(fsc.nextLong());\n        return a;\n    }\n    public static long[][] nl(final int n, final int m) {\n        final long[][] a = new long[n][m];\n        for (int i = 0; i < n; i++) a[i] = nl(m);\n        return a;\n    }\n    public static long[][] nl(final int n, final int m, final LongUnaryOperator f) {\n        final long[][] a = new long[n][m];\n        for (int i = 0; i < n; i++) a[i] = nl(m, f);\n        return a;\n    }\n    public static char[] nc() {return fsc.next().toCharArray();}\n    public static char[][] nc(final int n) {\n        final char[][] c = new char[n][];\n        for (int i = 0; i < n; i++) c[i] = nc();\n        return c;\n    }\n    public static double nd() {return fsc.nextDouble();}\n    public static double[] nd(final int n) {\n        final double[] a = new double[n];\n        for (int i = 0; i < n; i++) a[i] = fsc.nextDouble();\n        return a;\n    }\n    public static double[][] nd(final int n, final int m) {\n        final double[][] a = new double[n][m];\n        for (int i = 0; i < n; i++) a[i] = nd(m);\n        return a;\n    }\n    public static String ns() {return fsc.next();}\n    public static String[] ns(final int n) {\n        final String[] s = new String[n];\n        for (int i = 0; i < n; i++) s[i] = fsc.next();\n        return s;\n    }\n    public static boolean[][] grid(final int h, final int w, final char trueCharacter) {\n        final boolean[][] grid = new boolean[h][w];\n        for (int i = 0; i < h; i++) {\n            final char[] s = fsc.next().toCharArray();\n            for (int j = 0; j < w; j++) grid[i][j] = s[j] == trueCharacter;\n        }\n        return grid;\n    }\n}\n\n\nfinal class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try {buflen = in.read(buffer);}\n        catch (final IOException e) {e.printStackTrace();}\n        return buflen > 0;\n    }\n    private int readByte() {return hasNextByte() ? buffer[ptr++] : -1;}\n    public boolean hasNext() {\n        while (hasNextByte() && !(33 <= buffer[ptr] && buffer[ptr] <= 126)) ptr++;\n        return hasNextByte();\n    }\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        final StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {minus = true; b = readByte();}\n        if (b < '0' || '9' < b) throw new NumberFormatException();\n        for (; ; b = readByte()) {\n            if ('0' <= b && b <= '9') n = n * 10 + b - '0';\n            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;\n            else throw new NumberFormatException();\n        }\n    }\n    public int nextInt() {return Math.toIntExact(nextLong());}\n    public double nextDouble() {return Double.parseDouble(next());}\n}\n\nenum Property {ANNIHILATED_BY_ZERO, ASSOCIATIVE, CANCELLATIVE, COMMUTATIVE, DISTRIBUTIVE, IDEMPOTENT;}\n\n\nenum TypicalPropertySets {\n    ABELIAN_GROUP(EnumSet.of(Property.ASSOCIATIVE, Property.CANCELLATIVE, Property.COMMUTATIVE)),\n    BOUNDED_SEMI_LATTICE(EnumSet.of(Property.ASSOCIATIVE, Property.COMMUTATIVE, Property.IDEMPOTENT)),\n    COMMUTATIVE_MONOID(EnumSet.of(Property.ASSOCIATIVE, Property.COMMUTATIVE)),\n    GROUP(EnumSet.of(Property.ASSOCIATIVE, Property.CANCELLATIVE)),\n    MONOID(EnumSet.of(Property.ASSOCIATIVE)),\n    SEMI_GROUP(EnumSet.of(Property.ASSOCIATIVE)),\n    SEMI_LATTICE(EnumSet.of(Property.ASSOCIATIVE, Property.IDEMPOTENT, Property.COMMUTATIVE)),\n    SEMI_RING(EnumSet.of(Property.DISTRIBUTIVE, Property.ANNIHILATED_BY_ZERO)),\n    RING(EnumSet.of(Property.DISTRIBUTIVE, Property.ANNIHILATED_BY_ZERO));\n    private final EnumSet<Property> properties;\n    private TypicalPropertySets(EnumSet<Property> properties) {this.properties = properties;}\n    public final EnumSet<Property> getProperties() {return properties.clone();}\n}\n\ninterface LongInversible {long inverse(long t);}\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass Const {\n    public static final long MOD7 = 1_000_000_007;\n    public static final long MOD9 = 1_000_000_009;\n    public static final long MOD99 = 998_244_353;\n\n    public static final long LINF = Long.MAX_VALUE >> 2;\n    public static final int IINF = Integer.MAX_VALUE >> 1;\n    public static final double DINF = 1e150;\n\n    public static final double SDELTA = 1e-12;\n    public static final double DELTA = 1e-9;\n    public static final double LDELTA = 1e-6;\n\n    public static final int[] dx8 = {1, 0, -1, 0, 1, -1, -1, 1};\n    public static final int[] dy8 = {0, 1, 0, -1, 1, 1, -1, -1};\n    public static final int[] dx4 = {1, 0, -1, 0};\n    public static final int[] dy4 = {0, 1, 0, -1};\n\n    private Const(){}\n}\n\n\n\nclass LongAbelianGroup extends LongGroup {\n    public LongAbelianGroup(final LongBinaryOperator operator, final long e, final LongUnaryOperator inverse) {\n        super(operator, e, inverse);\n        addProperties(Property.COMMUTATIVE);\n    }\n}\n\ninterface LongUnital {long identityElement();}\n\n\n\nclass LongGroup extends LongMonoid implements LongInversible {\n    private final LongUnaryOperator inverse;\n    public LongGroup(final LongBinaryOperator operator, final long e, final LongUnaryOperator inverse) {\n        super(operator, e);\n        addProperties(Property.CANCELLATIVE);\n        this.inverse = inverse;\n    }\n    @Override\n    public long inverse(final long t) {return inverse.applyAsLong(t);}\n}\n\n\nabstract class PropertyHolder {\n    private final EnumSet<Property> properties;\n    public PropertyHolder(final EnumSet<Property> properties) {this.properties = properties;}\n    public PropertyHolder(final TypicalPropertySets typicalSet) {this(typicalSet.getProperties());}\n    public final EnumSet<Property> getProperties() {return properties;}\n    public final void addProperties(final Property... props) {for (Property prop : props) properties.add(prop);}\n    public final void addProperties(final EnumSet<Property> props) {for (Property prop : props) properties.add(prop);}\n    public final void addProperties(final TypicalPropertySets props) {addProperties(props.getProperties());}\n    public final boolean hasProperties(final Property... props) {\n        for (final Property prop : props) if (!properties.contains(prop)) return false;\n        return true;\n    }\n    public final boolean hasProperties(final EnumSet<Property> props) {\n        for (final Property prop : props) if (!properties.contains(prop)) return false;\n        return true;\n    }\n    public final boolean hasProperties(final TypicalPropertySets props) {return hasProperties(props.getProperties());}\n    public final void requireProperties(final EnumSet<Property> props, final Property... ps) {\n        final ArrayList<Property> unmet = new ArrayList<>();\n        for (final Property prop : props) if (!properties.contains(prop)) unmet.add(prop);\n        for (final Property prop : ps) if (!properties.contains(prop)) unmet.add(prop);\n        if (unmet.size() > 0) throw new UnsatisfiedRequiredPropertiesException(unmet);\n    }\n    public final void requireProperties(final TypicalPropertySets props, final Property... ps) {\n        requireProperties(props.getProperties(), ps);\n    }\n    private static final class UnsatisfiedRequiredPropertiesException extends RuntimeException {\n        private static final long serialVersionUID = 1L;\n        private UnsatisfiedRequiredPropertiesException(final Collection<Property> props) {\n            for (final Property prop : props) System.err.println(prop.name() + \"should be satisfied.\");\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.math.BigInteger;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Random;\n\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        boolean local = false;\n        boolean async = true;\n\n        Charset charset = Charset.forName(\"ascii\");\n\n        FastIO io = local ? new FastIO(new FileInputStream(\"D:\\\\DATABASE\\\\TESTCASE\\\\Code.in\"), System.out, charset) : new FastIO(System.in, System.out, charset);\n        Task task = new Task(io, new Debug(local));\n\n        if (async) {\n            Thread t = new Thread(null, task, \"skypool\", 1 << 27);\n            t.setPriority(Thread.MAX_PRIORITY);\n            t.start();\n            t.join();\n        } else {\n            task.run();\n        }\n\n        if (local) {\n            io.cache.append(\"\\n\\n--memory -- \\n\" + ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) >> 20) + \"M\");\n        }\n\n        io.flush();\n    }\n\n    public static class Task implements Runnable {\n        final FastIO io;\n        final Debug debug;\n        int inf = (int) 1e8;\n        long lInf = (long) 1e18;\n        double dInf = 1e50;\n\n        public Task(FastIO io, Debug debug) {\n            this.io = io;\n            this.debug = debug;\n        }\n\n        @Override\n        public void run() {\n            solve();\n        }\n\n        NumberTheory.Modular mod = new NumberTheory.Modular(998244353);\n        NumberTheory.Composite comp = new NumberTheory.Composite(2000000, mod);\n\n        public void solve() {\n            int n = io.readInt();\n            int m = io.readInt();\n\n            int ans = mod.mul(n, wayOfSum(n - 1, m));\n\n            int sum = 0;\n            for (int i = 0; i <= m; i++) {\n                int r = 3 * m - i;\n                if (r % 2 != 0) {\n                    continue;\n                }\n                int plus = f(n, m, r / 2);\n                plus = mod.mul(plus, comp.composite(n, i));\n                sum = mod.plus(plus, sum);\n            }\n\n            ans = mod.plus(sum, ans);\n            io.cache.append(ans);\n        }\n\n        /**\n         * x1 + ... + xn = m\n         * <br>\n         * x1, ..., xn < t\n         */\n        public int f(int n, int t, int m) {\n            int sum = 0;\n            for (int i = 0; i * t <= m; i++) {\n                int exist = i * t;\n                int plus = wayOfSum(n, m - exist);\n                plus = mod.mul(plus, comp.composite(n, i));\n                if (i % 2 == 1) {\n                    plus = -plus;\n                }\n                sum = mod.plus(sum, plus);\n            }\n            return sum;\n        }\n\n        /**\n         * x1 + ... + xn = m\n         */\n        public int wayOfSum(int n, int m) {\n            return comp.composite(n + m - 1, m);\n        }\n    }\n\n    public static class NumberTheory {\n        private static final Random RANDOM = new Random();\n\n        public static class ExtLucasFactorial {\n            int exp;\n            int fact;\n            int p;\n            int pc;\n            Modular modular;\n            Power power;\n            ExtGCD extGCD = new ExtGCD();\n            int[] g;\n\n            /**\n             * O(pc)\n             *\n             * @param p  the prime\n             * @param pc p^c\n             * @param g  buffer\n             */\n            public ExtLucasFactorial(int p, int pc, int[] g) {\n                this.p = p;\n                this.pc = pc;\n                this.g = g;\n                modular = new Modular(pc);\n                power = new Power(modular);\n                g[0] = 1;\n                g[1] = 1;\n                for (int i = 2; i <= pc; i++) {\n                    if (i % p == 0) {\n                        g[i] = g[i - 1];\n                    } else {\n                        g[i] = modular.mul(g[i - 1], i);\n                    }\n                }\n            }\n\n            /**\n             * return m! (mod pc) without any factor which is multiple of p.\n             * <br>\n             * O(\\log_2^2{m})\n             */\n            private int fact(long m) {\n                fact = 1;\n                exp = 0;\n                while (m > 1) {\n                    exp += m / p;\n                    fact = modular.mul(fact, power.pow(g[pc], m / pc));\n                    fact = modular.mul(fact, g[(int) (m % pc)]);\n                    m /= p;\n                }\n                return fact;\n            }\n\n            /**\n             * Find C(m,n), it means choose n elements from a set whose size is m.\n             * <br>\n             * O(\\log_2^2{m})\n             */\n            public int composite(long m, long n) {\n                int v = fact(m);\n                int e = exp;\n                extGCD.extgcd(fact(n), pc);\n                v = modular.mul(v, modular.valueOf(extGCD.getX()));\n                e -= exp;\n                extGCD.extgcd(fact(m - n), pc);\n                v = modular.mul(v, modular.valueOf(extGCD.getX()));\n                e -= exp;\n                v = modular.mul(v, power.pow(p, e));\n                return v;\n            }\n        }\n\n        /**\n         * Extend lucas algorithm\n         */\n        public static class ExtLucas {\n            PollardRho pr = new PollardRho();\n            Map<Integer, ExtLucasFactorial> factorialMap = new HashMap();\n\n            public ExtLucas(int p) {\n                Map<Integer, Integer> factors = pr.findAllFactors(p);\n                for (Map.Entry<Integer, Integer> entry : factors.entrySet()) {\n                    factorialMap.put(entry.getValue(), new ExtLucasFactorial(entry.getKey(), entry.getValue(), new int[entry.getValue() + 1]));\n                }\n            }\n\n            /**\n             * Get C(m, n) % p\n             */\n            public int composite(long m, long n) {\n                ExtCRT extCRT = new ExtCRT();\n                for (Map.Entry<Integer, ExtLucasFactorial> entry : factorialMap.entrySet()) {\n                    extCRT.add(entry.getValue().composite(m, n), entry.getKey());\n                }\n                return (int) extCRT.r;\n            }\n        }\n\n        /**\n         * Extend lucas algorithm long version\n         */\n        public static class LongExtLucas {\n            LongPollardRho pr = new LongPollardRho();\n            Map<Integer, ExtLucasFactorial> factorialMap = new HashMap();\n\n            public LongExtLucas(long p) {\n                Map<Long, Long> factors = pr.findAllFactors(p);\n                for (Map.Entry<Long, Long> entry : factors.entrySet()) {\n                    factorialMap.put(entry.getValue().intValue(), new ExtLucasFactorial(entry.getKey().intValue(), entry.getValue().intValue(), new int[entry.getValue().intValue() + 1]));\n                }\n            }\n\n            /**\n             * Get C(m, n) % p\n             */\n            public int composite(long m, long n) {\n                ExtCRT extCRT = new ExtCRT();\n                for (Map.Entry<Integer, ExtLucasFactorial> entry : factorialMap.entrySet()) {\n                    extCRT.add(entry.getValue().composite(m, n), entry.getKey());\n                }\n                return (int) extCRT.r;\n            }\n        }\n\n        /**\n         * Extend gcd\n         */\n        public static class ExtGCD {\n            private long x;\n            private long y;\n            private long g;\n\n            public long getX() {\n                return x;\n            }\n\n            public long getY() {\n                return y;\n            }\n\n            /**\n             * Get g = Gcd(a, b) and find a way to set x and y to match ax+by=g\n             */\n            public long extgcd(long a, long b) {\n                if (a >= b) {\n                    g = extgcd0(a, b);\n                } else {\n                    g = extgcd0(b, a);\n                    long tmp = x;\n                    x = y;\n                    y = tmp;\n                }\n                return g;\n            }\n\n\n            private long extgcd0(long a, long b) {\n                if (b == 0) {\n                    x = 1;\n                    y = 0;\n                    return a;\n                }\n                long g = extgcd0(b, a % b);\n                long n = x;\n                long m = y;\n                x = m;\n                y = n - m * (a / b);\n                return g;\n            }\n        }\n\n        public static class Gcd {\n            public long gcd(long a, long b) {\n                return a >= b ? gcd0(a, b) : gcd0(b, a);\n            }\n\n            private long gcd0(long a, long b) {\n                return b == 0 ? a : gcd0(b, a % b);\n            }\n\n            public int gcd(int a, int b) {\n                return a >= b ? gcd0(a, b) : gcd0(b, a);\n            }\n\n            private int gcd0(int a, int b) {\n                return b == 0 ? a : gcd0(b, a % b);\n            }\n        }\n\n        /**\n         * Euler sieve for filter primes\n         */\n        public static class EulerSieve {\n            int[] primes;\n            boolean[] isComp;\n            int primeLength;\n\n            public EulerSieve(int limit) {\n                isComp = new boolean[limit + 1];\n                primes = new int[limit + 1];\n                primeLength = 0;\n                for (int i = 2; i <= limit; i++) {\n                    if (!isComp[i]) {\n                        primes[primeLength++] = i;\n                    }\n                    for (int j = 0, until = limit / i; j < primeLength && primes[j] <= until; j++) {\n                        int pi = primes[j] * i;\n                        isComp[pi] = true;\n                        if (i % primes[j] == 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Euler sieve for multiplicative function\n         */\n        public static class MultiplicativeFunctionSieve {\n            int[] primes;\n            boolean[] isComp;\n            int primeLength;\n            int[] mobius;\n            int[] euler;\n            int[] factors;\n            int[] smallestPrimeFactor;\n            int[] numberOfSmallestPrimeFactor;\n\n            public MultiplicativeFunctionSieve(int limit, boolean enableMobius, boolean enableEuler, boolean enableFactors) {\n                isComp = new boolean[limit + 1];\n                primes = new int[limit + 1];\n                numberOfSmallestPrimeFactor = new int[limit + 1];\n                smallestPrimeFactor = new int[limit + 1];\n                primeLength = 0;\n                for (int i = 2; i <= limit; i++) {\n                    if (!isComp[i]) {\n                        primes[primeLength++] = i;\n                        numberOfSmallestPrimeFactor[i] = smallestPrimeFactor[i] = i;\n                    }\n                    for (int j = 0, until = limit / i; j < primeLength && primes[j] <= until; j++) {\n                        int pi = primes[j] * i;\n                        smallestPrimeFactor[pi] = primes[j];\n                        numberOfSmallestPrimeFactor[pi] = smallestPrimeFactor[i] == primes[j]\n                                ? (numberOfSmallestPrimeFactor[i] * numberOfSmallestPrimeFactor[primes[j]])\n                                : numberOfSmallestPrimeFactor[primes[j]];\n                        isComp[pi] = true;\n                        if (i % primes[j] == 0) {\n                            break;\n                        }\n                    }\n                }\n\n                if (enableMobius) {\n                    mobius = new int[limit + 1];\n                    mobius[1] = 1;\n                    for (int i = 2; i <= limit; i++) {\n                        if (!isComp[i]) {\n                            mobius[i] = -1;\n                        } else {\n                            if (numberOfSmallestPrimeFactor[i] != smallestPrimeFactor[i]) {\n                                mobius[i] = 0;\n                            } else {\n                                mobius[i] = mobius[numberOfSmallestPrimeFactor[i]] *\n                                        mobius[i / numberOfSmallestPrimeFactor[i]];\n                            }\n                        }\n                    }\n                }\n\n                if (enableEuler) {\n                    euler = new int[limit + 1];\n                    euler[1] = 1;\n                    for (int i = 2; i <= limit; i++) {\n                        if (!isComp[i]) {\n                            euler[i] = i - 1;\n                        } else {\n                            if (numberOfSmallestPrimeFactor[i] == i) {\n                                euler[i] = i - i / smallestPrimeFactor[i];\n                            } else {\n                                euler[i] = euler[numberOfSmallestPrimeFactor[i]] *\n                                        euler[i / numberOfSmallestPrimeFactor[i]];\n                            }\n                        }\n                    }\n                }\n\n                if (enableFactors) {\n                    factors = new int[limit + 1];\n                    factors[1] = 1;\n                    for (int i = 2; i <= limit; i++) {\n                        if (!isComp[i]) {\n                            factors[i] = 2;\n                        } else {\n                            if (numberOfSmallestPrimeFactor[i] == i) {\n                                factors[i] = 1 + factors[i / smallestPrimeFactor[i]];\n                            } else {\n                                factors[i] = factors[numberOfSmallestPrimeFactor[i]] *\n                                        factors[i / numberOfSmallestPrimeFactor[i]];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Mod operations\n         */\n        public static class Modular {\n            int m;\n\n            public Modular(int m) {\n                this.m = m;\n            }\n\n            public int valueOf(int x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return x;\n            }\n\n            public int valueOf(long x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return (int) x;\n            }\n\n            public int mul(int x, int y) {\n                return valueOf((long) x * y);\n            }\n\n            public int mul(long x, long y) {\n                x = valueOf(x);\n                y = valueOf(y);\n                return valueOf(x * y);\n            }\n\n            public int plus(int x, int y) {\n                return valueOf(x + y);\n            }\n\n            public int plus(long x, long y) {\n                x = valueOf(x);\n                y = valueOf(y);\n                return valueOf(x + y);\n            }\n\n            public int subtract(int x, int y) {\n                return valueOf(x - y);\n            }\n\n            public int subtract(long x, long y) {\n                return valueOf(x - y);\n            }\n\n            @Override\n            public String toString() {\n                return \"mod \" + m;\n            }\n        }\n\n        /**\n         * Bit operations\n         */\n        public static class BitOperator {\n            public int bitAt(int x, int i) {\n                return (x >> i) & 1;\n            }\n\n            public int bitAt(long x, int i) {\n                return (int) ((x >> i) & 1);\n            }\n\n            public int setBit(int x, int i, boolean v) {\n                if (v) {\n                    x |= 1 << i;\n                } else {\n                    x &= ~(1 << i);\n                }\n                return x;\n            }\n\n            public long setBit(long x, int i, boolean v) {\n                if (v) {\n                    x |= 1L << i;\n                } else {\n                    x &= ~(1L << i);\n                }\n                return x;\n            }\n\n            public long swapBit(long x, int i, int j) {\n                int bi = bitAt(x, i);\n                int bj = bitAt(x, j);\n                x = setBit(x, i, bj == 1);\n                x = setBit(x, j, bi == 1);\n                return x;\n            }\n\n            public int swapBit(int x, int i, int j) {\n                int bi = bitAt(x, i);\n                int bj = bitAt(x, j);\n                x = setBit(x, i, bj == 1);\n                x = setBit(x, j, bi == 1);\n                return x;\n            }\n\n            /**\n             * Determine whether x is subset of y\n             */\n            public boolean subset(long x, long y) {\n                return intersect(x, y) == x;\n            }\n\n            /**\n             * Merge two set\n             */\n            public long merge(long x, long y) {\n                return x | y;\n            }\n\n            public long intersect(long x, long y) {\n                return x & y;\n            }\n\n            public long differ(long x, long y) {\n                return x - intersect(x, y);\n            }\n        }\n\n        /**\n         * Power operations\n         */\n        public static class Power {\n            public Modular getModular() {\n                return modular;\n            }\n\n            final Modular modular;\n\n            public Power(Modular modular) {\n                this.modular = modular;\n            }\n\n            public int pow(int x, long n) {\n                if (n == 0) {\n                    return 1;\n                }\n                long r = pow(x, n >> 1);\n                r = modular.valueOf(r * r);\n                if ((n & 1) == 1) {\n                    r = modular.valueOf(r * x);\n                }\n                return (int) r;\n            }\n\n            public int inverse(int x) {\n                return pow(x, modular.m - 2);\n            }\n\n            public int pow2(int x) {\n                return x * x;\n            }\n\n            public long pow2(long x) {\n                return x * x;\n            }\n\n            public double pow2(double x) {\n                return x * x;\n            }\n        }\n\n        /**\n         * Log operations\n         */\n        public static class Log2 {\n            public int ceilLog(int x) {\n                return 32 - Integer.numberOfLeadingZeros(x - 1);\n            }\n\n            public int floorLog(int x) {\n                return 31 - Integer.numberOfLeadingZeros(x);\n            }\n\n            public int ceilLog(long x) {\n                return 64 - Long.numberOfLeadingZeros(x - 1);\n            }\n\n            public int floorLog(long x) {\n                return 63 - Long.numberOfLeadingZeros(x);\n            }\n        }\n\n        /**\n         * Find all inverse number\n         */\n        public static class InverseNumber {\n            int[] inv;\n\n            public InverseNumber(int[] inv, int limit, Modular modular) {\n                this.inv = inv;\n                inv[1] = 1;\n                int p = modular.m;\n                for (int i = 2; i <= limit; i++) {\n                    int k = p / i;\n                    int r = p % i;\n                    inv[i] = modular.mul(-k, inv[r]);\n                }\n            }\n\n            public InverseNumber(int limit, Modular modular) {\n                this(new int[limit + 1], limit, modular);\n            }\n        }\n\n        /**\n         * Factorial\n         */\n        public static class Factorial {\n            int[] fact;\n            int[] inv;\n\n            public Factorial(int[] fact, int[] inv, InverseNumber in, int limit, Modular modular) {\n                this.fact = fact;\n                this.inv = inv;\n                fact[0] = inv[0] = 1;\n                for (int i = 1; i <= limit; i++) {\n                    fact[i] = modular.mul(fact[i - 1], i);\n                    inv[i] = modular.mul(inv[i - 1], in.inv[i]);\n                }\n            }\n\n            public Factorial(int limit, Modular modular) {\n                this(new int[limit + 1], new int[limit + 1], new InverseNumber(limit, modular), limit, modular);\n            }\n        }\n\n        /**\n         * Composition\n         */\n        public static class Composite {\n            final Factorial factorial;\n            final Modular modular;\n\n            public Composite(Factorial factorial, Modular modular) {\n                this.factorial = factorial;\n                this.modular = modular;\n            }\n\n            public Composite(int limit, Modular modular) {\n                this(new Factorial(limit, modular), modular);\n            }\n\n            public int composite(int m, int n) {\n                if (n > m) {\n                    return 0;\n                }\n                return modular.mul(modular.mul(factorial.fact[m], factorial.inv[n]), factorial.inv[m - n]);\n            }\n        }\n\n        /**\n         * Test whether a number is primes\n         */\n        public static class MillerRabin {\n            Modular modular;\n            Power power;\n\n            /**\n             * Check whether n is a prime s times\n             */\n            public boolean mr(int n, int s) {\n                if (n == 2) {\n                    return true;\n                }\n                if (n % 2 == 0) {\n                    return false;\n                }\n                modular = new Modular(n);\n                power = new Power(modular);\n                for (int i = 0; i < s; i++) {\n                    int x = RANDOM.nextInt(n - 2) + 2;\n                    if (!mr0(x, n)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n\n            private boolean mr0(int x, int n) {\n                int exp = n - 1;\n                while (true) {\n                    int y = power.pow(x, exp);\n                    if (y != 1 && y != n - 1) {\n                        return false;\n                    }\n                    if (y != 1 || exp % 2 == 1) {\n                        break;\n                    }\n                    exp = exp / 2;\n                }\n                return true;\n            }\n        }\n\n        /**\n         * Modular operation for long version\n         */\n        public static class LongModular {\n            final long m;\n\n            public LongModular(long m) {\n                this.m = m;\n            }\n\n            public long mul(long a, long b) {\n                return b == 0 ? 0 : ((mul(a, b >> 1) << 1) % m + a * (b & 1)) % m;\n            }\n\n            public long plus(long a, long b) {\n                return valueOf(a + b);\n            }\n\n            public long valueOf(long a) {\n                a %= m;\n                if (a < 0) {\n                    a += m;\n                }\n                return a;\n            }\n        }\n\n        public static class LongPower {\n            final LongModular modular;\n\n            public LongPower(LongModular modular) {\n                this.modular = modular;\n            }\n\n            long pow(long x, long n) {\n                if (n == 0) {\n                    return 1;\n                }\n                long r = pow(x, n >> 1);\n                r = modular.mul(r, r);\n                if ((n & 1) == 1) {\n                    r = modular.mul(r, x);\n                }\n                return r;\n            }\n\n            long inverse(long x) {\n                return pow(x, modular.m - 2);\n            }\n        }\n\n        /**\n         * Test whether a number is primes\n         */\n        public static class LongMillerRabin {\n            LongModular modular;\n            LongPower power;\n\n            /**\n             * Check whether n is a prime s times\n             */\n            public boolean mr(long n, int s) {\n                if (n == 2) {\n                    return true;\n                }\n                if (n % 2 == 0) {\n                    return false;\n                }\n                modular = new LongModular(n);\n                power = new LongPower(modular);\n                for (int i = 0; i < s; i++) {\n                    long x = (long) (RANDOM.nextDouble() * (n - 2) + 2);\n                    if (!mr0(x, n)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n\n            private boolean mr0(long x, long n) {\n                long exp = n - 1;\n                while (true) {\n                    long y = power.pow(x, exp);\n                    if (y != 1 && y != n - 1) {\n                        return false;\n                    }\n                    if (y != 1 || exp % 2 == 1) {\n                        break;\n                    }\n                    exp = exp / 2;\n                }\n                return true;\n            }\n        }\n\n        public static class LongPollardRho {\n            LongMillerRabin mr = new LongMillerRabin();\n            Gcd gcd = new Gcd();\n            LongModular modular;\n\n            /**\n             * Find a factor of n, if n is returned, it means n is 1 or a prime\n             */\n            public long findFactor(long n) {\n                if (mr.mr(n, 3)) {\n                    return n;\n                }\n                modular = new LongModular(n);\n                while (true) {\n                    long f = findFactor0((long) (RANDOM.nextDouble() * n), (long) (RANDOM.nextDouble() * n), n);\n                    if (f != -1) {\n                        return f;\n                    }\n                }\n            }\n\n            private long findFactor0(long x, long c, long n) {\n                long xi = x;\n                long xj = x;\n                int j = 2;\n                int i = 1;\n                while (i < n) {\n                    i++;\n                    xi = modular.plus(modular.mul(xi, xi), c);\n                    long g = gcd.gcd(n, Math.abs(xi - xj));\n                    if (g != 1 && g != n) {\n                        return g;\n                    }\n                    if (i == j) {\n                        j = j << 1;\n                        xj = xi;\n                    }\n                }\n                return -1;\n            }\n\n            /**\n             * Find the representation of n=p1^c1 * p2^c2 * ... * pm ^ cm.\n             * <br>\n             * The returned map contained such entries: pi -> pi^ci\n             */\n            public Map<Long, Long> findAllFactors(long n) {\n                Map<Long, Long> map = new HashMap();\n                findAllFactors(map, n);\n                return map;\n            }\n\n            private void findAllFactors(Map<Long, Long> map, long n) {\n                if (n == 1) {\n                    return;\n                }\n                long f = findFactor(n);\n                if (f == n) {\n                    Long value = map.get(f);\n                    if (value == null) {\n                        value = 1L;\n                    }\n                    map.put(f, value * f);\n                    return;\n                }\n                findAllFactors(map, f);\n                findAllFactors(map, n / f);\n            }\n\n        }\n\n        /**\n         * Extend chinese remainder theory\n         */\n        public static class ExtCRT {\n            /**\n             * remainder\n             */\n            long r;\n            /**\n             * modulus\n             */\n            long m;\n            ExtGCD gcd = new ExtGCD();\n\n            public ExtCRT() {\n                r = 0;\n                m = 1;\n            }\n\n            /**\n             * Add a new condition: x % m = r\n             */\n            public boolean add(long r, long m) {\n                long m1 = this.m;\n                long x1 = this.r;\n                long m2 = m;\n                long x2 = ((r % m) + m) % m;\n                long g = gcd.extgcd(m1, m2);\n                long a = gcd.getX();\n                if ((x2 - x1) % g != 0) {\n                    return false;\n                }\n                this.m = m1 / g * m2;\n                this.r = BigInteger.valueOf(a).multiply(BigInteger.valueOf((x2 - x1) / g))\n                        .multiply(BigInteger.valueOf(m1)).add(BigInteger.valueOf(x1))\n                        .mod(BigInteger.valueOf(this.m)).longValue();\n                return true;\n            }\n        }\n\n        /**\n         * Lucas algorithm\n         */\n        public static class Lucas {\n            private final Composite composite;\n            private int modulus;\n\n            public Lucas(Composite composite) {\n                this.composite = composite;\n                this.modulus = composite.modular.m;\n            }\n\n            public int composite(long m, long n) {\n                if (n == 0) {\n                    return 1;\n                }\n                return composite.modular.mul(composite.composite((int) (m % modulus), (int) (n % modulus)),\n                        composite(m / modulus, n / modulus));\n            }\n        }\n\n        /**\n         * Find all factors of a number\n         */\n        public static class PollardRho {\n            MillerRabin mr = new MillerRabin();\n            Gcd gcd = new Gcd();\n            Random random = new Random();\n\n            public int findFactor(int n) {\n                if (mr.mr(n, 10)) {\n                    return n;\n                }\n                while (true) {\n                    int f = findFactor0(random.nextInt(n), random.nextInt(n), n);\n                    if (f != -1) {\n                        return f;\n                    }\n                }\n            }\n\n            /**\n             * Find all prime factor of n\n             * <br>\n             * p1 => p1^c1\n             * <br>\n             * ...\n             * <br>\n             * pk => pk^ck\n             */\n            public Map<Integer, Integer> findAllFactors(int n) {\n                Map<Integer, Integer> map = new HashMap();\n                findAllFactors(map, n);\n                return map;\n            }\n\n            private void findAllFactors(Map<Integer, Integer> map, int n) {\n                if (n == 1) {\n                    return;\n                }\n                int f = findFactor(n);\n                if (f == n) {\n                    Integer value = map.get(f);\n                    if (value == null) {\n                        value = 1;\n                    }\n                    map.put(f, value * f);\n                    return;\n                }\n                findAllFactors(map, f);\n                findAllFactors(map, n / f);\n            }\n\n            private int findFactor0(int x, int c, int n) {\n                int xi = x;\n                int xj = x;\n                int j = 2;\n                int i = 1;\n                while (i < n) {\n                    i++;\n                    xi = (int) ((long) xi * xi + c) % n;\n                    int g = gcd.gcd(n, Math.abs(xi - xj));\n                    if (g != 1 && g != n) {\n                        return g;\n                    }\n                    if (i == j) {\n                        j = j << 1;\n                        xj = xi;\n                    }\n                }\n                return -1;\n            }\n        }\n\n        public static class ModExpression {\n            ExtGCD extGCD = new ExtGCD();\n            Modular modular = new Modular(1);\n\n            /**\n             * Find ka=b(mod c) where k is the minimum possible non negative integer.\n             * <br>\n             * If it's impossible, -1 will be returned.\n             */\n            public long solve(long a, long b, int c) {\n                modular.m = c;\n                a = modular.valueOf(a);\n                b = modular.valueOf(b);\n                int g = (int) extGCD.extgcd((int) a, c);\n                if (b % g != 0) {\n                    return -1;\n                }\n                modular.m = c / g;\n                return modular.valueOf(b / g * extGCD.getX());\n            }\n        }\n\n        /**\n         * \\sum_{i=1}^{limit}f(\\lfloor n/i \\rfloor)\n         */\n        public static class FloorDivisionOptimizer {\n            int l;\n            int r;\n            int n;\n            int limit;\n\n\n            public FloorDivisionOptimizer(int n, int l, int limit) {\n                this.n = n;\n                this.l = 0;\n                this.limit = limit;\n                this.r = l - 1;\n            }\n\n            public boolean hasNext() {\n                return r < limit;\n            }\n\n            public int next() {\n                l = r + 1;\n                r = n / (n / l);\n                return n / l;\n            }\n        }\n\n\n        public static class QuadraticResidue {\n            final Modular modular;\n            final BitOperator bitOperator = new BitOperator();\n            Power power;\n            final PollardRho rho = new PollardRho();\n\n\n            public QuadraticResidue(Modular modular) {\n                this.modular = modular;\n                power = new Power(modular);\n            }\n\n            /**\n             * return \\sqrt{n} or -1 if it doesn't exist\n             */\n            public int square(int n) {\n                n = modular.valueOf(n);\n                if (n == 0) {\n                    return 0;\n                }\n                int p = modular.m;\n                if (power.pow(n, (p - 1) / 2) != 1) {\n                    return -1;\n                }\n                while (true) {\n                    int a = RANDOM.nextInt(p);\n                    int w = modular.plus(modular.mul(a, a), -n);\n                    if (power.pow(w, (p - 1) / 2) == 1) {\n                        continue;\n                    }\n\n\n                    int pow = (p + 1) / 2;\n                    int i = 31 - Integer.numberOfLeadingZeros(pow);\n                    int real = 1;\n                    int img = 0;\n                    for (; i >= 0; i--) {\n                        int nReal = modular.plus(modular.mul(real, real),\n                                modular.mul(modular.mul(img, img), w));\n                        int nImg = modular.mul(modular.mul(real, img), 2);\n                        real = nReal;\n                        img = nImg;\n                        if (bitOperator.bitAt(pow, i) == 1) {\n                            nReal = modular.plus(modular.mul(real, a), modular.mul(img, w));\n                            nImg = modular.plus(modular.mul(img, a), real);\n                            real = nReal;\n                            img = nImg;\n                        }\n                    }\n\n                    return real;\n                }\n            }\n\n            public int minPrimitiveRoot() {\n                if (modular.m == 2) {\n                    return 1;\n                }\n                Map<Integer, Integer> factorMap = rho.findAllFactors(modular.m - 1);\n                int[] factors = factorMap.keySet().stream().mapToInt(Integer::intValue).toArray();\n                for (int i = 2; ; i++) {\n                    boolean valid = true;\n                    for (int factor : factors) {\n                        if (power.pow(i, (modular.m - 1) / factor) == 1) {\n                            valid = false;\n                            break;\n                        }\n                    }\n                    if (valid) {\n                        return i;\n                    }\n                }\n            }\n        }\n    }\n\n    public static class FastIO {\n        public final StringBuilder cache = new StringBuilder(20 << 20);\n        private final InputStream is;\n        private final OutputStream os;\n        private final Charset charset;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 8);\n        private byte[] buf = new byte[1 << 20];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastIO(InputStream is, OutputStream os, Charset charset) {\n            this.is = is;\n            this.os = os;\n            this.charset = charset;\n        }\n\n        public FastIO(InputStream is, OutputStream os) {\n            this(is, os, Charset.forName(\"ascii\"));\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public long readLong() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            long val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public double readDouble() {\n            boolean sign = true;\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+';\n                next = read();\n            }\n\n            long val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 + next - '0';\n                next = read();\n            }\n            if (next != '.') {\n                return sign ? val : -val;\n            }\n            next = read();\n            long radix = 1;\n            long point = 0;\n            while (next >= '0' && next <= '9') {\n                point = point * 10 + next - '0';\n                radix = radix * 10;\n                next = read();\n            }\n            double result = val + (double) point / radix;\n            return sign ? result : -result;\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n        public int readLine(char[] data, int offset) {\n            int originalOffset = offset;\n            while (next != -1 && next != '\\n') {\n                data[offset++] = (char) next;\n                next = read();\n            }\n            return offset - originalOffset;\n        }\n\n        public int readString(char[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (char) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public int readString(byte[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (byte) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public char readChar() {\n            skipBlank();\n            char c = (char) next;\n            next = read();\n            return c;\n        }\n\n        public void flush() {\n            try {\n                os.write(cache.toString().getBytes(charset));\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public boolean hasMore() {\n            skipBlank();\n            return next != -1;\n        }\n    }\n\n    public static class Debug {\n        private boolean allowDebug;\n\n        public Debug(boolean allowDebug) {\n            this.allowDebug = allowDebug;\n        }\n\n        public void assertTrue(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (!flag) {\n                fail();\n            }\n        }\n\n        public void fail() {\n            throw new RuntimeException();\n        }\n\n        public void assertFalse(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (flag) {\n                fail();\n            }\n        }\n\n        private void outputName(String name) {\n            System.out.print(name + \" = \");\n        }\n\n        public void debug(String name, int x) {\n            if (!allowDebug) {\n                return;\n            }\n\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, long x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, double x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, int[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, long[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, double[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, Object x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, Object... x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.deepToString(x));\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint mod = 998244353;\n\t\tint n = ni(), m = ni();\n\t\t// all = C(n+m-1, n-1)\n\t\t// tower > 2(3m - tower)\n\t\t// one > m\n\t\t\n\t\tint[][] fif = enumFIF(3000005, mod);\n\t\tlong ans = 0;\n\t\tfor(int one = m+2;one <= 3*m && one <= n;one+=2){\n\t\t\tans += C(n, one, mod, fif) * C((3*m-one)/2+n-1, n-1, mod, fif);\n\t\t\tans %= mod;\n\t\t}\n\t\t\n\t\t// tower\n\t\tfor(int h = 2*m+1;h <= 3*m;h++){\n\t\t\tans += n * C(3*m-h+(n-1-1), n-1-1, mod, fif);\n//\t\t\ttr(h, C(3*m-h+(n-1-1), n-1-1, mod, fif));\n\t\t\tans %= mod;\n\t\t}\n\t\t\n\t\tans = C(n+3*m-1, n-1, mod, fif) - ans;\n\t\tans %= mod;\n\t\tif(ans < 0)ans += mod;\n\t\tout.println(ans);\n\t}\n\t\n\tpublic static long C(int n, int r, int mod, int[][] fif) {\n\t\tif (n < 0 || r < 0 || r > n)\n\t\t\treturn 0;\n\t\treturn (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n\t}\n\n\t\n\tpublic static int[][] enumFIF(int n, int mod) {\n\t\tint[] f = new int[n + 1];\n\t\tint[] invf = new int[n + 1];\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i] = (int) ((long) f[i - 1] * i % mod);\n\t\t}\n\t\tlong a = f[n];\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\tinvf[n] = (int) (p < 0 ? p + mod : p);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tinvf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n\t\t}\n\t\treturn new int[][] { f, invf };\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tprepareFact();\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint sum = m * 3;\n\t\tlong ans = combi(n - 1 + sum, n - 1);\n\t\tfor(int i = m * 2 + 1; i <= sum; i ++) {\n\t\t\tlong tmp = combi(n - 2 + (sum - i), n - 2);\n\t\t\ttmp = mod(tmp * (long)n);\n\t\t\tans = mod(ans - tmp);\n\t\t}\n\n\t\tlong minus = 0;\n\t\tfor(int i = m + 2; i <= n; i += 2) {\n\t\t\tlong tmp = perm(n - 1 + (sum - i) / 2, n - 1);\n\t\t\ttmp = mod(tmp * combi(n, i));\n\t\t\tminus = mod(minus + tmp);\n\t\t}\n\t\tminus = mod(minus * inv(fact[n - 1]));\n\t\tans = mod(ans - minus);\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic long MOD = 998244353;\n\tpublic static long mod(long i) {\n\t\treturn i % MOD + ((i % MOD) < 0 ? MOD : 0);\n\t}\n\t\n\tstatic long pow(long x, long y) {\n\t\tif (y == 0) {\n\t\t\treturn 1;\n\t\t} else if (y == 1) {\n\t\t\treturn x;\n\t\t} else if (y % 2 == 0) {\n\t\t\tlong tmp = pow(x, y / 2);\n\t\t\treturn mod(tmp * tmp);\n\t\t} else {\n\t\t\tlong tmp = pow(x, y / 2);\n\t\t\treturn mod(mod(tmp * tmp) * x);\n\t\t}\n\t}\n\t\n\tstatic long inv(long x) {\n\t\treturn pow(x, MOD - 2);\n\t}\n\t\n\tstatic int MAX_FACT = 2_500_100;\n\tstatic long fact[] = new long[MAX_FACT];\n\tstatic void prepareFact() {\n\t\tfact[0] = 1;\n\t\tfor(int i = 1; i < MAX_FACT; i ++) {\n\t\t\tfact[i] = mod(fact[i - 1] * i);\n\t\t}\n\t}\n\t\n\tstatic long combi(int n, int r) {\n\t\tif(n < 0 || n < r) { return 0; }\n\t\treturn mod(perm(n, r) * inv(fact[r]));\n\t}\n\n\tstatic long perm(int n, int r) {\n\t\tif(n < 0 || n < r) { return 0; }\n\t\treturn mod(fact[n] * inv(fact[n - r]));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n// import java.awt.Point;\n \npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n \n    // static int mod = 1_000_000_007;\n    int mod = 998244353;\n    // long inf = Long.MAX_VALUE/2;\n    int inf = Integer.MAX_VALUE/2;\n\n    void solve(){\n        int n = ni();\n        int m = ni();\n        int[][] fif = enumFIF(10000000, mod);  \n        long three_m = C(3*m+n-1, n-1, mod, fif);\n        long over_2m = 0;\n        for(int i = 1; i <= m; i++){\n            over_2m += C(m-i+n-2, n-2, mod, fif)*n;\n            over_2m %= mod;\n        } \n        if(n<=m){\n            long ans = (three_m - over_2m + mod)%mod;\n            out.println(ans);\n            return;\n        }\n        long single_over_m = 0;\n        for(int i = m+1; i <= n; i++){\n            int a = 3*m-i;\n            if(a%2!=0) continue;\n            long s = C(n,i,mod,fif);\n            long t = C(a/2+n-1, a/2, mod, fif);\n            single_over_m += s*t;\n            single_over_m %= mod;\n        }     \n        long ans = (mod+(three_m - over_2m - single_over_m)%mod)%mod;\n        out.println(ans);\n    }\n\n    public static long C(int n, int r, int mod, int[][] fif) {\n        if (n < 0 || r < 0 || r > n)\n            return 0;\n        return (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n    }\n\n    \n    public static int[][] enumFIF(int n, int mod) {\n        int[] f = new int[n + 1];\n        int[] invf = new int[n + 1];\n        f[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            f[i] = (int) ((long) f[i - 1] * i % mod);\n        }\n        long a = f[n];\n        long b = mod;\n        long p = 1, q = 0;\n        while (b > 0) {\n            long c = a / b;\n            long d;\n            d = a;\n            a = b;\n            b = d % b;\n            d = p;\n            p = q;\n            q = d - c * q;\n        }\n        invf[n] = (int) (p < 0 ? p + mod : p);\n        for (int i = n - 1; i >= 0; i--) {\n            invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n        }\n        return new int[][] { f, invf };\n    }\n\n    void run() throws Exception\n    {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception { new Main().run(); }\n    \n    private byte[] inbuf = new byte[1024];\n    private int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b) && b != ' ')){\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }\n \n}\n"
  },
  {
    "language": "Java",
    "code": "\npublic class Main {\n\n  private static int mod = 998244353;\n  private static int[][] fif = enumFIF(3000000, mod);\n\n  private static void solve() {\n    int n = ni();\n    int m = ni();\n    long ret = f(n, m, m * 3) + mod - n * f(n, m, m) % mod + n * f(n - 1, m, m) % mod;\n    System.out.println(ret % mod);\n  }\n\n  public static long f(int n, int m, int total) {\n    long ret = 0;\n    for (int odd = total % 2; odd <= Math.min(n, m); odd += 2) {\n      int k = (total - odd) / 2;\n      long now = C(n, odd, mod, fif) * C(n + k - 1, n - 1, mod, fif) % mod;\n      ret = (ret + now) % mod;\n    }\n    return ret;\n  }\n\n  public static long C(int n, int r, int mod, int[][] fif) {\n    if (n < 0 || r < 0 || r > n)\n      return 0;\n    return (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n  }\n\n  public static int[][] enumFIF(int n, int mod) {\n    int[] f = new int[n + 1];\n    int[] invf = new int[n + 1];\n    f[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      f[i] = (int) ((long) f[i - 1] * i % mod);\n    }\n    long a = f[n];\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    invf[n] = (int) (p < 0 ? p + mod : p);\n    for (int i = n - 1; i >= 0; i--) {\n      invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n    }\n    return new int[][] {f, invf};\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\npublic class Main {\n\n  private static void solve() {\n    int n = ni();\n    int m = ni();\n\n    System.out.println(solve(n, m));\n    // for (int n = 2; n < 100; n++) {\n    // for (int m = 1; m < 100; m++) {\n    // long ret1 = solve(n, m);\n    // long ret2 = solve2(n, m);\n    //\n    // if (ret1 != ret2)\n    // System.out.println(n + \" \" + m + \" \" + ret1 + \" \" + ret2);\n    // }\n    // }\n\n  }\n\n  static int mod = 998244353;\n  static int[][] fif = enumFIF(2 * 1000000, mod);\n\n  private static long solve(int n, int m) {\n\n    long ret = C(3 * m + n - 1, n - 1, mod, fif);\n\n    ret += mod - (long) n * C((m - 1) + n - 1, n - 1, mod, fif) % mod;\n    ret %= mod;\n    return ret;\n  }\n\n  private static long solve2(int n, int m) {\n    long[][] dp = new long[n + 1][3 * m + 1];\n    dp[0][0] = 1;\n    int mod = 998244353;\n\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j <= 3 * m; j++) {\n        for (int k = 0; k <= 2 * m && j + k <= 3 * m; k++) {\n          dp[i + 1][j + k] += dp[i][j];\n          dp[i + 1][j + k] %= mod;\n        }\n      }\n    }\n    return dp[n][3 * m];\n  }\n\n  public static int[][] enumFIF(int n, int mod) {\n    int[] f = new int[n + 1];\n    int[] invf = new int[n + 1];\n    f[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      f[i] = (int) ((long) f[i - 1] * i % mod);\n    }\n    long a = f[n];\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    invf[n] = (int) (p < 0 ? p + mod : p);\n    for (int i = n - 1; i >= 0; i--) {\n      invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n    }\n    return new int[][] {f, invf};\n  }\n\n  public static long C(int n, int r, int mod, int[][] fif) {\n    if (n < 0 || r < 0 || r > n)\n      return 0;\n    return (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int m = in.readInt();\n            Combinations c = new Combinations(n + 3 * m, MiscUtils.MODF);\n            long answer = 0;\n            for (int i = 2 * m; i <= 3 * m; i += 2) {\n                answer += c.c(n - 1 + i / 2, n - 1) * c.c(n, 3 * m - i) % MiscUtils.MODF;\n            }\n            long delta = 0;\n            for (int i = 2 * m + 1; i <= 3 * m; i++) {\n                delta += c.c(n + 3 * m - i - 2, n - 2);\n            }\n            delta %= MiscUtils.MODF;\n            answer -= delta * n;\n            answer %= MiscUtils.MODF;\n            answer += MiscUtils.MODF;\n            answer %= MiscUtils.MODF;\n            out.printLine(answer);\n        }\n\n    }\n\n    static class Combinations {\n        private final long mod;\n        private final long[] factorial;\n        private final long[] reverseFactorial;\n\n        public Combinations(int length, long mod) {\n            this.mod = mod;\n            factorial = IntegerUtils.generateFactorial(length, mod);\n            reverseFactorial = IntegerUtils.generateReverseFactorials(length, mod);\n        }\n\n        public long c(int n, int k) {\n            if (k < 0 || k > n) {\n                return 0;\n            }\n            return factorial[n] * reverseFactorial[k] % mod * reverseFactorial[n - k] % mod;\n        }\n\n    }\n\n    static class MiscUtils {\n        public static final int MODF = 998_244_353;\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class IntegerUtils {\n        public static long[] generateFactorial(int count, long module) {\n            long[] result = new long[count];\n            if (module == -1) {\n                if (count != 0) {\n                    result[0] = 1;\n                }\n                for (int i = 1; i < count; i++) {\n                    result[i] = result[i - 1] * i;\n                }\n            } else {\n                if (count != 0) {\n                    result[0] = 1 % module;\n                }\n                for (int i = 1; i < count; i++) {\n                    result[i] = (result[i - 1] * i) % module;\n                }\n            }\n            return result;\n        }\n\n        public static long[] generateReverse(int upTo, long module) {\n            long[] result = new long[upTo];\n            if (upTo > 1) {\n                result[1] = 1;\n            }\n            for (int i = 2; i < upTo; i++) {\n                result[i] = (module - module / i * result[((int) (module % i))] % module) % module;\n            }\n            return result;\n        }\n\n        public static long[] generateReverseFactorials(int upTo, long module) {\n            long[] result = generateReverse(upTo, module);\n            if (upTo > 0) {\n                result[0] = 1;\n            }\n            for (int i = 1; i < upTo; i++) {\n                result[i] = result[i] * result[i - 1] % module;\n            }\n            return result;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\npublic class Main {\n\n  private static void solve() {\n    int n = ni();\n    int m = ni();\n    int mod = 998244353;\n    int[][] fif = enumFIF(2 * 1000000, mod);\n\n    long ret = C(3 * m + n - 1, n - 1, mod, fif);\n\n    ret += mod - n * C(m + n - 1, n - 1, mod, fif);\n    ret %= mod;\n\n    System.out.println(ret);\n  }\n\n  public static long C(int n, int r, int mod, int[][] fif) {\n    if (n < 0 || r < 0 || r > n)\n      return 0;\n    return (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n  }\n\n\n  public static int[][] enumFIF(int n, int mod) {\n    int[] f = new int[n + 1];\n    int[] invf = new int[n + 1];\n    f[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      f[i] = (int) ((long) f[i - 1] * i % mod);\n    }\n    long a = f[n];\n    long b = mod;\n    long p = 1, q = 0;\n    while (b > 0) {\n      long c = a / b;\n      long d;\n      d = a;\n      a = b;\n      b = d % b;\n      d = p;\n      p = q;\n      q = d - c * q;\n    }\n    invf[n] = (int) (p < 0 ? p + mod : p);\n    for (int i = n - 1; i >= 0; i--) {\n      invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n    }\n    return new int[][] {f, invf};\n  }\n\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Math.max;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic final int MOD = 998244353;\n\n\tstatic int add(int a, int b) {\n\t\tint res = a + b;\n\t\treturn res >= MOD ? res - MOD : res;\n\t}\n\n\tstatic int sub(int a, int b) {\n\t\tint res = a - b;\n\t\treturn res < 0 ? res + MOD : res;\n\t}\n\n\tstatic int mul(int a, int b) {\n\t\tint res = (int) ((long) a * b % MOD);\n\t\treturn res < 0 ? res + MOD : res;\n\t}\n\n\tstatic int pow(int a, int e) {\n\t\tif (e == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tint r = a;\n\t\tfor (int i = 30 - Integer.numberOfLeadingZeros(e); i >= 0; i--) {\n\t\t\tr = mul(r, r);\n\t\t\tif ((e & (1 << i)) != 0) {\n\t\t\t\tr = mul(r, a);\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n\tstatic int inv(int a) {\n\t\treturn pow(a, MOD - 2);\n\t}\n\n\tstatic int facts[], factsInv[];\n\n\tstatic int c(int x, int y) {\n\t\treturn mul(mul(facts[x + y], factsInv[x]), factsInv[y]);\n\t}\n\n\tstatic void solve() throws Exception {\n\t\tint n = scanInt(), m = scanInt();\n\t\tfacts = new int[n + 3 * m / 2 + 1];\n\t\tfacts[0] = 1;\n\t\tfor (int i = 1; i < facts.length; i++) {\n\t\t\tfacts[i] = mul(facts[i - 1], i);\n\t\t}\n\t\tfactsInv = new int[facts.length];\n\t\tfactsInv[facts.length - 1] = inv(facts[facts.length - 1]);\n\t\tfor (int i = facts.length - 1; i > 0; i--) {\n\t\t\tfactsInv[i - 1] = mul(factsInv[i], i);\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int nOdd = m % 2; nOdd <= m && nOdd <= n; nOdd += 2) {\n\t\t\tint cans = c(nOdd, n - nOdd);\n\t\t\tint cans1 = c((3 * m - nOdd) / 2, n - 1);\n\t\t\tint cans2 = mul(nOdd, c((m - nOdd) / 2, n - 1));\n\t\t\tif (nOdd < m) {\n\t\t\t\tcans2 = add(cans2, mul(n - nOdd, c((m - nOdd) / 2 - 1, n - 1)));\n\t\t\t}\n\t\t\tans = add(ans, mul(cans, sub(cans1, cans2)));\n\t\t}\n\t\tout.print(ans);\n\t}\n\n\tstatic int scanInt() throws IOException {\n\t\treturn parseInt(scanString());\n\t}\n\n\tstatic long scanLong() throws IOException {\n\t\treturn parseLong(scanString());\n\t}\n\n\tstatic String scanString() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\npublic class CSharp\n{\n    public static void Main()\n    {\n        Kyopuro chokudai = new Kyopuro();\n        chokudai.AtCoder();\n    }\n}\n\npublic class Kyopuro\n{\n\n    int n, m;\n\n    public void AtCoder()\n    {\n        string[] input;\n        input = Console.ReadLine().Split(' ');\n        n = int.Parse(input[0]);\n        m = int.Parse(input[1]);\n        int p = 998244353;\n\n        Mod mod = new Mod(3000000);\n        long ans = p - n;\n        ans *= mod.Ncr(m + n - 2, n - 1);\n        ans %= p;\n        ans += mod.Ncr(m * 3 + n - 1, n - 1);\n        ans %= p;\n        /*\n        if (n > m + 1)\n        {\n            ans += p;\n            ans -= mod.Ncr(n + m - 3, n - m - 2);\n            ans %= p;\n        }\n        */\n        if(n > m + 1)\n        {\n            int c = 0;\n            long ans2;\n            for (int i = 0; m + 2 + i <= n; i = i + 2)\n            {\n                if (m - 1 - i / 2 < 0) break;\n                ans2 = mod.Ncr(n, m + 2 + i);\n                ans2 *= mod.Ncr(n + m - 2 - i / 2, n - 1);\n                ans2 %= p;\n                ans += p;\n                ans -= ans2;\n                ans %= p;\n            }\n        }\n        \n\n        Console.WriteLine(ans);\n    }\n    public static void DebugWL(object x) { System.Diagnostics.Debug.WriteLine(x); }\n}\n\n// Mod(int n)\n// int[] fac: factors (1-indexed)\n// int n: the length of fac\n\n// int .Ncr(n,r): nCr\n// int .Fac(n): n!%p\n// int .Pow(n,m): n^m%p\n\npublic class Mod\n{\n    const int p = 998244353;\n    int[] fac;\n\n    public Mod(int n)\n    {\n        fac = new int[n + 1];\n        fac[0] = 1;\n        long tmp = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            tmp = fac[i - 1];\n            tmp *= i;\n            tmp %= p;\n            fac[i] = (int)tmp;\n        }\n\n\n    }\n\n    public int Ncr(int n, int r)\n    {\n        if (n < r) return 0;\n        if (r == 0 | n == r) return 1;\n        long a = Fac(n);\n        a = a * Pow(Fac(n - r), p - 2) % p;\n        a = a * Pow(Fac(r), p - 2) % p;\n        return (int)a;\n    }\n\n    public int Fac(int n)\n    {\n        if (fac[n] >= 0) return fac[n];\n        long k = 1;\n        for (long i = 1; i <= n; i++)\n        {\n            k = k * i % p;\n        }\n        fac[n] = (int)k;\n        return fac[n];\n    }\n\n    public int Pow(int n, int m)\n    {\n        if (m == 0) return 1;\n        if (m == 1) return n;\n        long a = 1;\n        if (m % 2 == 0)\n        {\n            a = Pow(n, m / 2);\n            a = a * a % p;\n        }\n        else\n        {\n            a = Pow(n, m / 2);\n            a = a * a % p;\n            a = a * n % p;\n        }\n        return (int)a;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing CompLib.Mathematics;\nusing CompLib.Util;\n\npublic class Program\n{\n    private int N, M;\n\n    private ModInt[] F;\n\n    public void Solve()\n    {\n        var sc = new Scanner();\n        F = new ModInt[10000001];\n        F[0] = 1;\n        for (int i = 1; i <= 10000000; i++)\n        {\n            F[i] = F[i - 1] * i;\n        }\n\n        N = sc.NextInt();\n        M = sc.NextInt();\n        // 総和 3M -a\n        // 最大 2M以下 -b\n        // 奇数の個数 M以下　パリティ一致 -c\n\n        // -aは自明\n        // M=0のとき、b,c満たす\n\n        // M=kのとき満たしている、\n        // M=k+1でも満たす\n\n        // a,cのみのパターン\n        ModInt ans = 0;\n        for (int i = M; i >= 0; i -= 2)\n        {\n            // i 奇数の個数\n            // 奇数のところにはあらかじめ1を置いておく\n            if (i > N) continue;\n            // 並べ方 N C i\n            var a = C(N, i);\n\n            // 残り 3M - i個 偶数になるように分ける\n            var b = H(N, (3 * M - i) / 2);\n            ans += a * b;\n        }\n\n        // bを満たさないパターン\n        // 最大が2M超過\n        for (int max = 2 * M + 1; max <= 3 * M; max++)\n        {\n            // 残り3M-max並べ方\n            // M以下なのでcは満たす\n            var c = H(N-1, 3 * M - max);\n            ans -= c * N;\n        }\n\n        Console.WriteLine(ans);\n    }\n\n    ModInt C(int n, int m)\n    {\n        return F[n] * ModInt.Inverse(F[n - m] * F[m]);\n    }\n\n    // n種類、r個選ぶ\n    ModInt H(int n, int r)\n    {\n        return C(n + r - 1, r);\n    }\n\n    public static void Main(string[] args) => new Program().Solve();\n}\n\n// https://bitbucket.org/camypaper/complib\nnamespace CompLib.Mathematics\n{\n    #region ModInt\n\n    /// <summary>\n    /// [0,<see cref=\"Mod\"/>) までの値を取るような数\n    /// </summary>\n    public struct ModInt\n    {\n        /// <summary>\n        /// 剰余を取る値．\n        /// </summary>\n        // public const long Mod = (int) 1e9 + 7;\n        public const long Mod = 998244353;\n\n        /// <summary>\n        /// 実際の数値．\n        /// </summary>\n        public long num;\n\n        /// <summary>\n        /// 値が <paramref name=\"n\"/> であるようなインスタンスを構築します．\n        /// </summary>\n        /// <param name=\"n\">インスタンスが持つ値</param>\n        /// <remarks>パフォーマンスの問題上，コンストラクタ内では剰余を取りません．そのため，<paramref name=\"n\"/> ∈ [0,<see cref=\"Mod\"/>) を満たすような <paramref name=\"n\"/> を渡してください．このコンストラクタは O(1) で実行されます．</remarks>\n        public ModInt(long n)\n        {\n            num = n;\n        }\n\n        /// <summary>\n        /// このインスタンスの数値を文字列に変換します．\n        /// </summary>\n        /// <returns>[0,<see cref=\"Mod\"/>) の範囲内の整数を 10 進表記したもの．</returns>\n        public override string ToString()\n        {\n            return num.ToString();\n        }\n\n        public static ModInt operator +(ModInt l, ModInt r)\n        {\n            l.num += r.num;\n            if (l.num >= Mod) l.num -= Mod;\n            return l;\n        }\n\n        public static ModInt operator -(ModInt l, ModInt r)\n        {\n            l.num -= r.num;\n            if (l.num < 0) l.num += Mod;\n            return l;\n        }\n\n        public static ModInt operator *(ModInt l, ModInt r)\n        {\n            return new ModInt(l.num * r.num % Mod);\n        }\n\n        public static implicit operator ModInt(long n)\n        {\n            n %= Mod;\n            if (n < 0) n += Mod;\n            return new ModInt(n);\n        }\n\n        /// <summary>\n        /// 与えられた 2 つの数値からべき剰余を計算します．\n        /// </summary>\n        /// <param name=\"v\">べき乗の底</param>\n        /// <param name=\"k\">べき指数</param>\n        /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n        public static ModInt Pow(ModInt v, long k)\n        {\n            return Pow(v.num, k);\n        }\n\n        /// <summary>\n        /// 与えられた 2 つの数値からべき剰余を計算します．\n        /// </summary>\n        /// <param name=\"v\">べき乗の底</param>\n        /// <param name=\"k\">べき指数</param>\n        /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n        public static ModInt Pow(long v, long k)\n        {\n            long ret = 1;\n            for (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n                if ((k & 1) == 1)\n                    ret = ret * v % Mod;\n            return new ModInt(ret);\n        }\n\n        /// <summary>\n        /// 与えられた数の逆元を計算します．\n        /// </summary>\n        /// <param name=\"v\">逆元を取る対象となる数</param>\n        /// <returns>逆元となるような値</returns>\n        /// <remarks>法が素数であることを仮定して，フェルマーの小定理に従って逆元を O(log N) で計算します．</remarks>\n        public static ModInt Inverse(ModInt v)\n        {\n            return Pow(v, Mod - 2);\n        }\n    }\n\n    #endregion\n\n    #region Binomial Coefficient\n\n    public class BinomialCoefficient\n    {\n        public ModInt[] fact, ifact;\n\n        public BinomialCoefficient(int n)\n        {\n            fact = new ModInt[n + 1];\n            ifact = new ModInt[n + 1];\n            fact[0] = 1;\n            for (int i = 1; i <= n; i++)\n                fact[i] = fact[i - 1] * i;\n            ifact[n] = ModInt.Inverse(fact[n]);\n            for (int i = n - 1; i >= 0; i--)\n                ifact[i] = ifact[i + 1] * (i + 1);\n            ifact[0] = ifact[1];\n        }\n\n        public ModInt this[int n, int r]\n        {\n            get\n            {\n                if (n < 0 || n >= fact.Length || r < 0 || r > n) return 0;\n                return fact[n] * ifact[n - r] * ifact[r];\n            }\n        }\n\n        public ModInt RepeatedCombination(int n, int k)\n        {\n            if (k == 0) return 1;\n            return this[n + k - 1, k];\n        }\n    }\n\n    #endregion\n}\n\n\nnamespace CompLib.Util\n{\n    using System;\n    using System.Linq;\n\n    class Scanner\n    {\n        private string[] _line;\n        private int _index;\n        private const char Separator = ' ';\n\n        public Scanner()\n        {\n            _line = new string[0];\n            _index = 0;\n        }\n\n        public string Next()\n        {\n            if (_index >= _line.Length)\n            {\n                string s;\n                do\n                {\n                    s = Console.ReadLine();\n                } while (s.Length == 0);\n\n                _line = s.Split(Separator);\n                _index = 0;\n            }\n\n            return _line[_index++];\n        }\n\n        public string ReadLine()\n        {\n            _index = _line.Length;\n            return Console.ReadLine();\n        }\n\n        public int NextInt() => int.Parse(Next());\n        public long NextLong() => long.Parse(Next());\n        public double NextDouble() => double.Parse(Next());\n        public decimal NextDecimal() => decimal.Parse(Next());\n        public char NextChar() => Next()[0];\n        public char[] NextCharArray() => Next().ToCharArray();\n\n        public string[] Array()\n        {\n            string s = Console.ReadLine();\n            _line = s.Length == 0 ? new string[0] : s.Split(Separator);\n            _index = _line.Length;\n            return _line;\n        }\n\n        public int[] IntArray() => Array().Select(int.Parse).ToArray();\n        public long[] LongArray() => Array().Select(long.Parse).ToArray();\n        public double[] DoubleArray() => Array().Select(double.Parse).ToArray();\n        public decimal[] DecimalArray() => Array().Select(decimal.Parse).ToArray();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression,\n                          System.Linq.Expressions.UnaryExpression>;\n\nclass Program {\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const int M2 = 998244353;\n    const long LM = 1L << 60;\n    const double eps = 1e-11;\n    static void Main(string[] args)\n    {\n        int n, m;\n        sc.Multi(out n, out m);\n        MyMath.Mod = M2;\n        MyMath.setfacts(n + m * 3 + 9);\n        long all = 0;\n        for (int i = m % 2; i <= m && i <= n; i += 2)\n        {\n            int k = (m * 3 - i) / 2;\n            all = (all + MyMath.comb(n, i) * MyMath.comb(n + k - 1, k)) % M2;\n        }\n        long rem = 0;\n        for (int i = 0; i < m; i++)\n        {\n            rem = (rem + MyMath.comb(n + i - 2, i) * n) % M2;\n        }\n        Prt((all + M2 - rem) % M2);\n        sw.Flush();\n    }\n\n\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n}\nclass pair<T, U> : IComparable<pair<T, U>> {\n    public T v1;\n    public U v2;\n    public pair() : this(default(T), default(U)) {}\n    public pair(T v1, U v2) { this.v1 = v1; this.v2 = v2; }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) { a = v1; b = v2; }\n    public static bool operator>(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) > 0;\n    public static bool operator<(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) < 0;\n    public static bool operator>=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) >= 0;\n    public static bool operator<=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) <= 0;\n}\nstatic class util {\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static T sq<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    static readonly int[] dd = { 0, 1, 0, -1 };\n    static readonly string dstring = \"RDLU\";\n    public static P[] adjacents(this P p) => adjacents(p.v1, p.v2);\n    public static P[] adjacents(this P p, int h, int w) => adjacents(p.v1, p.v2, h, w);\n    public static pair<P, char>[] adjacents_with_str(int i, int j)\n        => Enumerable.Range(0, dd.Length).Select(k => new pair<P, char>(new P(i + dd[k], j + dd[k ^ 1]), dstring[k])).ToArray();\n    public static pair<P, char>[] adjacents_with_str(int i, int j, int h, int w)\n        => Enumerable.Range(0, dd.Length).Select(k => new pair<P, char>(new P(i + dd[k], j + dd[k ^ 1]), dstring[k])).Where(p => inside(p.v1.v1, p.v1.v2, h, w)).ToArray();\n    public static P[] adjacents(int i, int j)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1])).ToArray();\n    public static P[] adjacents(int i, int j, int h, int w)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1])).Where(p => inside(p.v1, p.v2, h, w)).ToArray();\n    public static void Assert(bool cond) { if (!cond) throw new Exception(); }\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T> {\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan {\n    StreamReader sr;\n    public Scan() { sr = new StreamReader(Console.OpenStandardInput()); }\n    public Scan(string path) { sr = new StreamReader(path); }\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => sr.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P => Pair<int, int>();\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\n\nstatic class MyMath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a) {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n) {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static bool[] segmentSieve(long l, long r) {\n        int sqn = (int)Math.Sqrt(r + 9);\n        var ps = getprimes(sqn);\n        var sieve = new bool[r - l + 1];\n        for (long i = l; i <= r; i++) sieve[i - l] = true;\n        foreach (long p in ps)\n        {\n            if (p * p > r) break;\n            for (long i = p >= l ? p * p : (l + p - 1) / p * p; i <= r; i += p) sieve[i - l] = false;\n        }\n        return sieve;\n    }\n    public static bool[] segmentSieve(long l, long r, List<int> ps) {\n        var sieve = new bool[r - l + 1];\n        for (long i = l; i <= r; i++) sieve[i - l] = true;\n        foreach (long p in ps)\n        {\n            if (p * p > r) break;\n            for (long i = p >= l ? p * p : (l + p - 1) / p * p; i <= r; i += p) sieve[i - l] = false;\n        }\n        return sieve;\n    }\n    public static List<int> getprimes(int n) {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long pow(long a, long b, long mod) {\n        a %= mod;\n        // if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2, mod);\n        if ((b & 1) == 0) return t * t % mod;\n        return t * t % mod * a % mod;\n    }\n    public static long pow(long a, long b) {\n        a %= Mod;\n        // if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) => pow(a, Mod - 2);\n    public static long gcd(long a, long b) {\n        while (b > 0) { var t = a % b; a = b; b = t; } return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y) {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n\n    // 中国剰余定理\n    // リターン値を (r, m) とすると解は x ≡ r (mod. m)\n    // 解なしの場合は (0, -1) をリターン\n    public static pair<long, long> chineserem(IList<long> b, IList<long> m) {\n        long r = 0, M = 1;\n        for (int i = 0; i < b.Count; ++i) {\n            long p, q;\n            long d = extgcd(M, m[i], out p, out q); // p is inv of M/d (mod. m[i]/d)\n            if ((b[i] - r) % d != 0) return new pair<long, long>(0, -1);\n            long tmp = (b[i] - r) / d * p % (m[i]/d);\n            r += M * tmp;\n            M *= m[i]/d;\n        }\n        return new pair<long, long>((r % M + M) % M, M);\n    }\n\n    public static long lcm(long a, long b) => a / gcd(a, b) * b;\n\n    static long[] facts, invs;\n    public static void setfacts(int n) {\n        facts = new long[n + 1];\n        facts[0] = 1;\n        for (int i = 1; i <= n; i++) facts[i] = facts[i - 1] * i % Mod;\n        invs = new long[n + 1];\n        invs[n] = inv(facts[n]);\n        for (int i = n; i > 0 ; i--) invs[i - 1] = invs[i] * i % Mod;\n    }\n    public static long perm(long n, long r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (facts != null && facts.Length > n) return facts[n] * invs[n - r] % Mod;\n        long numer = 1;\n        for (long i = 0; i < r; i++) {\n            numer = numer * ((n - i) % Mod) % Mod;\n        }\n        return numer;\n    }\n    public static long comb(long n, long r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (facts != null && facts.Length > n) return facts[n] * invs[r] % Mod * invs[n - r] % Mod;\n        if (n - r < r) r = n - r;\n        long numer = 1, denom = 1;\n        for (long i = 0; i < r; i++) {\n            numer = numer * ((n - i) % Mod) % Mod;\n            denom = denom * ((i + 1) % Mod) % Mod;\n        }\n        return numer * inv(denom) % Mod;\n    }\n    public static long[][] getcombs(int n) {\n        var ret = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            ret[i] = new long[i + 1];\n            ret[i][0] = ret[i][i] = 1;\n            for (int j = 1; j < i; j++) ret[i][j] = (ret[i - 1][j - 1] + ret[i - 1][j]) % Mod;\n        }\n        return ret;\n    }\n    // nC0, nC2, ..., nCn\n    public static long[] getcomb(int n) {\n        var ret = new long[n + 1];\n        ret[0] = 1;\n        for (int i = 0; i < n; i++) ret[i + 1] = ret[i] * (n - i) % Mod * inv(i + 1) % Mod;\n        return ret;\n    }\n    public static bool nextPermutation<T>(IList<T> p) where T : struct, IComparable<T> {\n        for (int i = p.Count - 2; i >= 0; --i) {\n            if (p[i].CompareTo(p[i + 1]) < 0) {\n                for (int j = p.Count - 1; ; --j) {\n                    if (p[j].CompareTo(p[i]) > 0) {\n                        p.swap(i, j);\n                        for(++i, j = p.Count - 1; i < j; ++i, --j)\n                            p.swap(i, j);\n\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    public static bool nextPermutation<T>(IList<T> p, Comparison<T> compare) where T : struct {\n        for (int i = p.Count - 2; i >= 0; --i) {\n            if (compare(p[i], p[i + 1]) < 0) {\n                for (int j = p.Count - 1; ; --j) {\n                    if (compare(p[j], p[i]) > 0) {\n                        p.swap(i, j);\n                        for (++i, j = p.Count - 1; i < j; ++i, --j)\n                            p.swap(i, j);\n\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Numerics;\nusing System.Threading;\nusing System.Runtime.CompilerServices;\nusing System.Diagnostics;\nusing static System.Math;\nusing static System.Array;\nusing static AtCoder.Cout;\nusing static AtCoder.Tool;\nusing static AtCoder.ModInt;\nnamespace AtCoder\n{\n    class AC\n    {\n        //const int MOD = 1000000007;\n       const int MOD = 998244353;\n\n        const int INF = int.MaxValue / 2;\n        const long SINF = long.MaxValue / 3;\n        const double EPS = 1e-8;\n        static readonly int[] dI = { 0, 1, 0, -1, 1, -1, -1, 1 };\n        static readonly int[] dJ = { 1, 0, -1, 0, 1, 1, -1, -1 };\n        //static List<List<int>> G = new List<List<int>>();\n        //static List<List<Edge>> G = new List<List<Edge>>();\n        //static List<Edge> E = new List<Edge>();\n        static void Main(string[] args)\n        {\n            //var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; Console.SetOut(sw);\n\n            var th = new Thread(Run, 1 << 26);\n            th.Start();\n            th.Join();\n\n            //Run();\n            Console.Out.Flush();\n        }\n        static void Run()\n        {\n            int Testcase = 1;\n            //Testcase = Cin.Int;\n            for (var _ = 0; _ < Testcase; _++) Solve();\n        }\n        static void Solve()\n        {\n           Cin.Input(out int N,out int M);\n           ModInt ans =0;\nfor(var i =M;i >=0;i-=2){\nint s =(3*M-i)/2;\nans +=nCr(N,i)* (nCr(s+N-1,s)-i *nCr(s-M+N-1,s-M)-(N-i)*nCr(s-M-1+N-1,s-M-1));\n}\nOutL(ans.value);\n        }\n        public struct Edge\n        {\n            public int from;\n\n            public int to;\n            public long dist;\n\n            public Edge(int t, long c)\n            {\n                from = -1;\n                to = t;\n                dist = c;\n            }\n            public Edge(int f, int t, long c)\n            {\n                from = f;\n                to = t;\n                dist = c;\n            }\n        }\n    }\n    public class Priority_Queue<T>\n    {\n        private List<T> Q;\n        private readonly Comparison<T> Func_Compare;\n        public Priority_Queue(Comparison<T> comp)\n        {\n            Func_Compare = comp;\n            Q = new List<T>();\n        }\n        private void PushHeap(List<T> list, T item)\n        {\n            int n = list.Count();\n            list.Add(item);\n\n            while (n != 0)\n            {\n                int pIndex = (n - 1) / 2;\n\n                if (Func_Compare(list[n], list[pIndex]) < 0)\n                {\n                    Swap(Q, n, pIndex);\n                }\n                else { break; }\n\n                n = pIndex;\n            }\n        }\n        private void PopHeap(List<T> list)\n        {\n            int n = list.Count() - 1;\n            list[0] = list[n];\n            list.RemoveAt(n);\n\n            int cur = 0;\n            int comp;\n\n            while (2 * cur + 1 <= n - 1)\n            {\n                int c1 = 2 * cur + 1;\n                int c2 = 2 * (cur + 1);\n                if (c1 == n - 1)\n                {\n                    comp = c1;\n                }\n                else\n                {\n\n                    comp = Func_Compare(list[c1], list[c2]) < 0 ? c1 : c2;\n                }\n\n                if (Func_Compare(list[cur], list[comp]) > 0)\n                {\n                    Swap(Q, cur, comp);\n                }\n                else { break; }\n\n                cur = comp;\n            }\n        }\n        private void Swap(List<T> list, int a, int b)\n        {\n            T keep = list[a];\n            list[a] = list[b];\n            list[b] = keep;\n        }\n\n        public void Enqueue(T value)\n        {\n            PushHeap(Q, value);\n        }\n\n        public T Dequeue()\n        {\n            T ret = Q[0];\n            PopHeap(Q);\n            return ret;\n        }\n\n        public T Peek()\n        {\n            return Q[0];\n        }\n\n        public int Count()\n        {\n            return Q.Count();\n        }\n        public bool Any()\n        {\n            return Q.Any();\n        }\n    }\n    public class SegmentTree<T>\n    {\n        //1-indexed type\n        int n;\n        T[] Tree;\n        Func<T, T, T> f;\n        T ex;\n        int L;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public SegmentTree(int size, Func<T, T, T> fun, T exvalue)\n        {\n            ex = exvalue;\n            f = fun;\n            n = 1;\n            while (n < size) n <<= 1;\n            Tree = new T[n << 1];\n            L = (n << 1) - 1;\n            for (var i = 0; i <= L; i++) Tree[i] = ex;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public SegmentTree(int size, Func<T, T, T> fun, T exvalue, T[] initial)\n        {\n            ex = exvalue;\n            n = 1; while (n < size) n <<= 1;\n            f = fun;\n            Tree = new T[n << 1];\n            L = (n << 1) - 1;\n            for (var i = 0; i <= L; i++) Tree[i] = (n <= i && i <= n + initial.Length - 1) ? initial[i - n] : ex;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Set_All()\n        {\n            for (var i = n - 1; i >= 1; i--) Tree[i] = f(Tree[i << 1], Tree[(i << 1) | 1]);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Assign(int idx, T nxt) => Tree[idx + n] = nxt;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Update(int idx)\n        {\n            int now = idx + n;\n            while (now > 1)\n            {\n                now >>= 1;\n                Tree[now] = f(Tree[now << 1], Tree[now << 1 | 1]);\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Query_Update(int idx, T nxt)\n        {\n            Assign(idx, nxt); Update(idx);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Query_Update_func(int idx, T y)\n        {\n            Assign(idx, f(Peek(idx), y)); Update(idx);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T Query_Fold(int l, int r)\n        {\n            int L = n + l;\n            int R = n + r;\n            T vL = ex, vR = ex;\n            while (L < R)\n            {\n                if (L % 2 == 1)\n                {\n                    vL = f(vL, Tree[L]);\n                    L++;\n                }\n                if (R % 2 == 1)\n                {\n                    vR = f(Tree[R - 1], vR);\n                    R--;\n                }\n                L >>= 1;\n                R >>= 1;\n            }\n            return f(vL, vR);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T Peek(int idx) => Tree[idx + n];\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Display(int len)\n        {\n            for (var i = 0; i < len; i++) Console.Write($\"{Tree[i + n]} \");\n            Console.WriteLine();\n        }\n    }\n    public class UnionFind\n    {\n        private int[] parent;\n        private int[] rank;\n        private int[] size;\n        public UnionFind(int n)\n        {\n            parent = new int[n];\n            rank = new int[n];\n            size = new int[n];\n            for (var i = 0; i < n; i++)\n            {\n                parent[i] = i;\n                rank[i] = 0;\n                size[i] = 1;\n            }\n        }\n\n        public int Root(int x)\n        {\n            return parent[x] == x ? x : parent[x] = Root(parent[x]);\n        }\n\n        public bool SameRoot(int x, int y)\n        {\n            return Root(x) == Root(y);\n        }\n\n        public void Unite(int x, int y)\n        {\n            x = Root(x);\n            y = Root(y);\n            if (x == y) { return; }\n\n            if (rank[x] < rank[y])\n            {\n                parent[x] = y;\n                size[y] += size[x];\n                size[x] = 0;\n            }\n            else\n            {\n                parent[y] = x;\n                if (rank[x] == rank[y]) { rank[x]++; }\n                size[x] += size[y];\n                size[y] = 0;\n            }\n        }\n\n        public int SizeOf(int x)\n        {\n            return size[Root(x)];\n        }\n\n    }\n    struct ModInt\n    {\n        public long value;\n        //private const int MOD = 1000000007;\n        private const int MOD = 998244353;\n        public ModInt(long value) { this.value = value; }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static implicit operator ModInt(long a)\n        {\n            var ret = a % MOD;\n            return new ModInt(ret < 0 ? (ret + MOD) : ret);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator +(ModInt a, ModInt b) => (a.value + b.value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator -(ModInt a, ModInt b) => (a.value - b.value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator *(ModInt a, ModInt b) => (a.value * b.value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator /(ModInt a, ModInt b) => a * Modpow(b, MOD - 2);\n\n        public static ModInt operator <<(ModInt a, int n) => (a.value << n);\n        public static ModInt operator >>(ModInt a, int n) => (a.value >> n);\n        public static ModInt operator ++(ModInt a) => a.value + 1;\n        public static ModInt operator --(ModInt a) => a.value - 1;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt Modpow(ModInt a, long n)\n        {\n            var k = a;\n            ModInt ret = 1;\n            while (n > 0)\n            {\n                if ((n & 1) != 0) ret *= k;\n                k *= k;\n                n >>= 1;\n            }\n            return ret;\n        }\n        private static readonly List<long> Factorials = new List<long>() { 1 };\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt Fac(long n)\n        {\n            for (var i = Factorials.Count(); i <= n; i++)\n            {\n                Factorials.Add((Factorials[i - 1] * i) % MOD);\n            }\n            return Factorials[(int)n];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt nCr(long n, long r)\n        {\nif (n<=0||r<0)return 0;\n            return n < r ? 0 : Fac(n) / (Fac(r) * Fac(n - r));\n        }\n        public static explicit operator int(ModInt a) => (int)a.value;\n    }\n    static class Cin\n    {\n        public static string[] ReadSplit => Console.ReadLine().Split();\n        public static int[] ReadSplitInt => ConvertAll(Console.ReadLine().Split(), int.Parse);\n        public static long[] ReadSplitLong => ConvertAll(Console.ReadLine().Split(), long.Parse);\n        public static double[] ReadSplit_Double => ConvertAll(Console.ReadLine().Split(), double.Parse);\n        public static string Str => Console.ReadLine();\n        public static int Int => int.Parse(Console.ReadLine());\n        public static long Long => long.Parse(Console.ReadLine());\n        public static double Double => double.Parse(Console.ReadLine());\n        public static T Conv<T>(string input)\n        {\n            if (typeof(T).Equals(typeof(ModInt)))\n            {\n                return (T)(dynamic)(long.Parse(input));\n            }\n            return (T)Convert.ChangeType(input, typeof(T));\n        }\n        public static void Input<T>(out T a) => a = Conv<T>(Console.ReadLine());\n        public static void Input<T, U>(out T a, out U b)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); }\n        public static void Input<T, U, V>(out T a, out U b, out V c)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); }\n        public static void Input<T, U, V, W>(out T a, out U b, out V c, out W d)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); d = Conv<W>(q[3]); }\n        public static void Input<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); d = Conv<W>(q[3]); e = Conv<X>(q[4]); }\n    }\n    static class Cout\n    {\n        public static void OutL(object s) => Console.WriteLine(s);\n        public static void Out_Sep<T>(IEnumerable<T> s) => Console.WriteLine(string.Join(\" \", s));\n        public static void Out_Sep<T>(IEnumerable<T> s, string sep) => Console.WriteLine(string.Join($\"{sep}\", s));\n        public static void Out_Sep(params object[] s) => Console.WriteLine(string.Join(\" \", s));\n        public static void Out_One(object s) => Console.Write($\"{s} \");\n        public static void Out_One(object s, string sep) => Console.Write($\"{s}{sep}\");\n        public static void Endl() => Console.WriteLine();\n    }\n    public static class Tool\n    {\n        static public void Initialize<T>(ref T[] array, T initialvalue)\n        {\n            array = ConvertAll(array, x => initialvalue);\n        }\n        static public void Swap<T>(ref T a, ref T b)\n        {\n            T keep = a;\n            a = b;\n            b = keep;\n        }\n        static public void Display<T>(T[,] array2d, int n, int m)\n        {\n            for (var i = 0; i < n; i++)\n            {\n                for (var j = 0; j < m; j++)\n                {\n                    Console.Write($\"{array2d[i, j]} \");\n                }\n                Console.WriteLine();\n            }\n        }\n        static public long Gcd(long a, long b)\n        {\n            if (a == 0 || b == 0) return Max(a, b);\n            return a % b == 0 ? b : Gcd(b, a % b);\n        }\n        static public long LPow(int a, int b) => (long)Pow(a, b);\n        static public bool Bit(long x, int dig) => ((1L << dig) & x) != 0;\n        static public int Sig(long a) => a == 0 ? 0 : (int)(a / Abs(a));\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Numerics;\nusing System.Threading;\nusing System.Runtime.CompilerServices;\nusing System.Diagnostics;\nusing static System.Math;\nusing static System.Array;\nusing static AtCoder.Cout;\nusing static AtCoder.Tool;\nusing static AtCoder.ModInt;\nnamespace AtCoder\n{\n    class AC\n    {\n        //const int MOD = 1000000007;\n       const int MOD = 998244353;\n\n        const int INF = int.MaxValue / 2;\n        const long SINF = long.MaxValue / 3;\n        const double EPS = 1e-8;\n        static readonly int[] dI = { 0, 1, 0, -1, 1, -1, -1, 1 };\n        static readonly int[] dJ = { 1, 0, -1, 0, 1, 1, -1, -1 };\n        //static List<List<int>> G = new List<List<int>>();\n        //static List<List<Edge>> G = new List<List<Edge>>();\n        //static List<Edge> E = new List<Edge>();\n        static void Main(string[] args)\n        {\n            //var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; Console.SetOut(sw);\n\n            var th = new Thread(Run, 1 << 26);\n            th.Start();\n            th.Join();\n\n            //Run();\n            Console.Out.Flush();\n        }\n        static void Run()\n        {\n            int Testcase = 1;\n            //Testcase = Cin.Int;\n            for (var _ = 0; _ < Testcase; _++) Solve();\n        }\n        static void Solve()\n        {\n           Cin.Input(out int N,out int M);\n          if(N<M){\n\nModInt ans = nCr(3*M+N-1,N-1);\n           for(var i =2*M+1;i <=3*M;i ++){\n    ans-= N*nCr(3*M-i +N-2,N-2);\n}\nOutL(ans.value );\n\n}\nelse{\nModInt ans =0;\nfor(var i =M;i >=0;i-=2){\nint s =(3*M-i)/2;\nans +=nCr(N,i)* (nCr(s+N-1,s)-i *nCr(s-M+N-1,s-M)-(N-i)*nCr(s-M-1+N-1,s-M-1));\n}\nOutL(ans.value);\n}\n        }\n        public struct Edge\n        {\n            public int from;\n\n            public int to;\n            public long dist;\n\n            public Edge(int t, long c)\n            {\n                from = -1;\n                to = t;\n                dist = c;\n            }\n            public Edge(int f, int t, long c)\n            {\n                from = f;\n                to = t;\n                dist = c;\n            }\n        }\n    }\n    public class Priority_Queue<T>\n    {\n        private List<T> Q;\n        private readonly Comparison<T> Func_Compare;\n        public Priority_Queue(Comparison<T> comp)\n        {\n            Func_Compare = comp;\n            Q = new List<T>();\n        }\n        private void PushHeap(List<T> list, T item)\n        {\n            int n = list.Count();\n            list.Add(item);\n\n            while (n != 0)\n            {\n                int pIndex = (n - 1) / 2;\n\n                if (Func_Compare(list[n], list[pIndex]) < 0)\n                {\n                    Swap(Q, n, pIndex);\n                }\n                else { break; }\n\n                n = pIndex;\n            }\n        }\n        private void PopHeap(List<T> list)\n        {\n            int n = list.Count() - 1;\n            list[0] = list[n];\n            list.RemoveAt(n);\n\n            int cur = 0;\n            int comp;\n\n            while (2 * cur + 1 <= n - 1)\n            {\n                int c1 = 2 * cur + 1;\n                int c2 = 2 * (cur + 1);\n                if (c1 == n - 1)\n                {\n                    comp = c1;\n                }\n                else\n                {\n\n                    comp = Func_Compare(list[c1], list[c2]) < 0 ? c1 : c2;\n                }\n\n                if (Func_Compare(list[cur], list[comp]) > 0)\n                {\n                    Swap(Q, cur, comp);\n                }\n                else { break; }\n\n                cur = comp;\n            }\n        }\n        private void Swap(List<T> list, int a, int b)\n        {\n            T keep = list[a];\n            list[a] = list[b];\n            list[b] = keep;\n        }\n\n        public void Enqueue(T value)\n        {\n            PushHeap(Q, value);\n        }\n\n        public T Dequeue()\n        {\n            T ret = Q[0];\n            PopHeap(Q);\n            return ret;\n        }\n\n        public T Peek()\n        {\n            return Q[0];\n        }\n\n        public int Count()\n        {\n            return Q.Count();\n        }\n        public bool Any()\n        {\n            return Q.Any();\n        }\n    }\n    public class SegmentTree<T>\n    {\n        //1-indexed type\n        int n;\n        T[] Tree;\n        Func<T, T, T> f;\n        T ex;\n        int L;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public SegmentTree(int size, Func<T, T, T> fun, T exvalue)\n        {\n            ex = exvalue;\n            f = fun;\n            n = 1;\n            while (n < size) n <<= 1;\n            Tree = new T[n << 1];\n            L = (n << 1) - 1;\n            for (var i = 0; i <= L; i++) Tree[i] = ex;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public SegmentTree(int size, Func<T, T, T> fun, T exvalue, T[] initial)\n        {\n            ex = exvalue;\n            n = 1; while (n < size) n <<= 1;\n            f = fun;\n            Tree = new T[n << 1];\n            L = (n << 1) - 1;\n            for (var i = 0; i <= L; i++) Tree[i] = (n <= i && i <= n + initial.Length - 1) ? initial[i - n] : ex;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Set_All()\n        {\n            for (var i = n - 1; i >= 1; i--) Tree[i] = f(Tree[i << 1], Tree[(i << 1) | 1]);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Assign(int idx, T nxt) => Tree[idx + n] = nxt;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Update(int idx)\n        {\n            int now = idx + n;\n            while (now > 1)\n            {\n                now >>= 1;\n                Tree[now] = f(Tree[now << 1], Tree[now << 1 | 1]);\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Query_Update(int idx, T nxt)\n        {\n            Assign(idx, nxt); Update(idx);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Query_Update_func(int idx, T y)\n        {\n            Assign(idx, f(Peek(idx), y)); Update(idx);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T Query_Fold(int l, int r)\n        {\n            int L = n + l;\n            int R = n + r;\n            T vL = ex, vR = ex;\n            while (L < R)\n            {\n                if (L % 2 == 1)\n                {\n                    vL = f(vL, Tree[L]);\n                    L++;\n                }\n                if (R % 2 == 1)\n                {\n                    vR = f(Tree[R - 1], vR);\n                    R--;\n                }\n                L >>= 1;\n                R >>= 1;\n            }\n            return f(vL, vR);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T Peek(int idx) => Tree[idx + n];\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Display(int len)\n        {\n            for (var i = 0; i < len; i++) Console.Write($\"{Tree[i + n]} \");\n            Console.WriteLine();\n        }\n    }\n    public class UnionFind\n    {\n        private int[] parent;\n        private int[] rank;\n        private int[] size;\n        public UnionFind(int n)\n        {\n            parent = new int[n];\n            rank = new int[n];\n            size = new int[n];\n            for (var i = 0; i < n; i++)\n            {\n                parent[i] = i;\n                rank[i] = 0;\n                size[i] = 1;\n            }\n        }\n\n        public int Root(int x)\n        {\n            return parent[x] == x ? x : parent[x] = Root(parent[x]);\n        }\n\n        public bool SameRoot(int x, int y)\n        {\n            return Root(x) == Root(y);\n        }\n\n        public void Unite(int x, int y)\n        {\n            x = Root(x);\n            y = Root(y);\n            if (x == y) { return; }\n\n            if (rank[x] < rank[y])\n            {\n                parent[x] = y;\n                size[y] += size[x];\n                size[x] = 0;\n            }\n            else\n            {\n                parent[y] = x;\n                if (rank[x] == rank[y]) { rank[x]++; }\n                size[x] += size[y];\n                size[y] = 0;\n            }\n        }\n\n        public int SizeOf(int x)\n        {\n            return size[Root(x)];\n        }\n\n    }\n    struct ModInt\n    {\n        public long value;\n        //private const int MOD = 1000000007;\n        private const int MOD = 998244353;\n        public ModInt(long value) { this.value = value; }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static implicit operator ModInt(long a)\n        {\n            var ret = a % MOD;\n            return new ModInt(ret < 0 ? (ret + MOD) : ret);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator +(ModInt a, ModInt b) => (a.value + b.value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator -(ModInt a, ModInt b) => (a.value - b.value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator *(ModInt a, ModInt b) => (a.value * b.value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator /(ModInt a, ModInt b) => a * Modpow(b, MOD - 2);\n\n        public static ModInt operator <<(ModInt a, int n) => (a.value << n);\n        public static ModInt operator >>(ModInt a, int n) => (a.value >> n);\n        public static ModInt operator ++(ModInt a) => a.value + 1;\n        public static ModInt operator --(ModInt a) => a.value - 1;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt Modpow(ModInt a, long n)\n        {\n            var k = a;\n            ModInt ret = 1;\n            while (n > 0)\n            {\n                if ((n & 1) != 0) ret *= k;\n                k *= k;\n                n >>= 1;\n            }\n            return ret;\n        }\n        private static readonly List<long> Factorials = new List<long>() { 1 };\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt Fac(long n)\n        {\n            for (var i = Factorials.Count(); i <= n; i++)\n            {\n                Factorials.Add((Factorials[i - 1] * i) % MOD);\n            }\n            return Factorials[(int)n];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt nCr(long n, long r)\n        {\nif (n<=0||r<0)return 0;\n            return n < r ? 0 : Fac(n) / (Fac(r) * Fac(n - r));\n        }\n        public static explicit operator int(ModInt a) => (int)a.value;\n    }\n    static class Cin\n    {\n        public static string[] ReadSplit => Console.ReadLine().Split();\n        public static int[] ReadSplitInt => ConvertAll(Console.ReadLine().Split(), int.Parse);\n        public static long[] ReadSplitLong => ConvertAll(Console.ReadLine().Split(), long.Parse);\n        public static double[] ReadSplit_Double => ConvertAll(Console.ReadLine().Split(), double.Parse);\n        public static string Str => Console.ReadLine();\n        public static int Int => int.Parse(Console.ReadLine());\n        public static long Long => long.Parse(Console.ReadLine());\n        public static double Double => double.Parse(Console.ReadLine());\n        public static T Conv<T>(string input)\n        {\n            if (typeof(T).Equals(typeof(ModInt)))\n            {\n                return (T)(dynamic)(long.Parse(input));\n            }\n            return (T)Convert.ChangeType(input, typeof(T));\n        }\n        public static void Input<T>(out T a) => a = Conv<T>(Console.ReadLine());\n        public static void Input<T, U>(out T a, out U b)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); }\n        public static void Input<T, U, V>(out T a, out U b, out V c)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); }\n        public static void Input<T, U, V, W>(out T a, out U b, out V c, out W d)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); d = Conv<W>(q[3]); }\n        public static void Input<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); d = Conv<W>(q[3]); e = Conv<X>(q[4]); }\n    }\n    static class Cout\n    {\n        public static void OutL(object s) => Console.WriteLine(s);\n        public static void Out_Sep<T>(IEnumerable<T> s) => Console.WriteLine(string.Join(\" \", s));\n        public static void Out_Sep<T>(IEnumerable<T> s, string sep) => Console.WriteLine(string.Join($\"{sep}\", s));\n        public static void Out_Sep(params object[] s) => Console.WriteLine(string.Join(\" \", s));\n        public static void Out_One(object s) => Console.Write($\"{s} \");\n        public static void Out_One(object s, string sep) => Console.Write($\"{s}{sep}\");\n        public static void Endl() => Console.WriteLine();\n    }\n    public static class Tool\n    {\n        static public void Initialize<T>(ref T[] array, T initialvalue)\n        {\n            array = ConvertAll(array, x => initialvalue);\n        }\n        static public void Swap<T>(ref T a, ref T b)\n        {\n            T keep = a;\n            a = b;\n            b = keep;\n        }\n        static public void Display<T>(T[,] array2d, int n, int m)\n        {\n            for (var i = 0; i < n; i++)\n            {\n                for (var j = 0; j < m; j++)\n                {\n                    Console.Write($\"{array2d[i, j]} \");\n                }\n                Console.WriteLine();\n            }\n        }\n        static public long Gcd(long a, long b)\n        {\n            if (a == 0 || b == 0) return Max(a, b);\n            return a % b == 0 ? b : Gcd(b, a % b);\n        }\n        static public long LPow(int a, int b) => (long)Pow(a, b);\n        static public bool Bit(long x, int dig) => ((1L << dig) & x) != 0;\n        static public int Sig(long a) => a == 0 ? 0 : (int)(a / Abs(a));\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing Debug = System.Diagnostics.Debug;\nusing static System.Math;\nusing System.Runtime.CompilerServices;\nusing MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;\nusing MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;\n\nstatic class P\n{\n    static void Main()\n    {\n        var n = NextInt;\n        var m = NextInt;\n        //えー\n        //奇数が何個あるかみたいな話で、\n        //奇数がp個、残りのsumがnで 頑張って配置しましょうねみたいな問題\n        //仕切りとの並び替え定期\n\n        //いや、玉のmaxがあるやんけ うくか?\n        //玉のmaxを超えてる奴をあとから引いてあげましょうねみたいな話\n        //maxを超える候補は一つなので、maxの種類ごとにその下の分けるのを全部探索して良さそう いいね\n        ModInt res = 0;\n        for (int oddCount = (m % 2); oddCount <= n && oddCount <= m * 3; oddCount += 2)\n        {\n            //奇数の位置*2のブロックの配置\n\n            //奇数の位置 : n! / (odd! * even!)\n            var oddPermutation = Factorial(n) / Factorial(oddCount) / Factorial(n - oddCount);\n\n            //2のブロック\n            //|と(oo)の並び替え |はn-1個、(oo)は(m*3-oddCount)/2個\n            var blockCount = (m * 3 - oddCount) / 2;\n            //ブロックの個数がm個みまんだったら駄目\n            if (blockCount < m) continue;\n            var partationCount = n - 1;\n            var blockPermutation = Factorial(blockCount + partationCount) / Factorial(blockCount) / Factorial(partationCount);\n            res += oddPermutation * blockPermutation;\n        }\n\n        for (int over = m * 2 + 1; over <= m * 3; over++)\n        {\n            var remain = m * 3 - over;\n            //remainブロックをn-1個の区画に入れる\n            var partationCount = n - 2;\n            var perm = Factorial(remain + partationCount) / Factorial(remain) / Factorial(partationCount);\n            //挿入箇所のn通り\n            res -= perm * n;\n        }\n        Console.WriteLine(res);\n    }\n\n    static List<ModInt> factorialMemo = new List<ModInt>() { 1 };\n    static ModInt Factorial(int x)\n    {\n        for (int i = factorialMemo.Count; i <= x; i++) factorialMemo.Add(factorialMemo.Last() * i);\n        return factorialMemo[x];\n    }\n\n    static readonly TextReader In = Console.In;\n    static int NextInt\n    {\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        get\n        {\n            int res = 0;\n            int next = In.Read();\n            int rev = 1;\n            while (45 > next || next > 57) next = In.Read();\n            if (next == 45) { next = In.Read(); rev = -1; }\n            while (48 <= next && next <= 57)\n            {\n                res = res * 10 + next - 48;\n                next = In.Read();\n            }\n            return res * rev;\n        }\n    }\n}\n\nstruct ModInt\n{\n    const int MOD = 998244353;\n    const long POSITIVIZER = ((long)MOD) << 31;\n    long Data;\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public ModInt(long data) { if ((Data = data % MOD) < 0) Data += MOD; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static implicit operator long(ModInt modInt) => modInt.Data;\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static implicit operator ModInt(long val) => new ModInt(val);\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static ModInt operator +(ModInt a, int b) => new ModInt() { Data = (a.Data + b + POSITIVIZER) % MOD };\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static ModInt operator +(ModInt a, long b) => new ModInt(a.Data + b);\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static ModInt operator +(ModInt a, ModInt b) { long res = a.Data + b.Data; return new ModInt() { Data = res >= MOD ? res - MOD : res }; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static ModInt operator -(ModInt a, int b) => new ModInt() { Data = (a.Data - b + POSITIVIZER) % MOD };\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static ModInt operator -(ModInt a, long b) => new ModInt(a.Data - b);\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static ModInt operator -(ModInt a, ModInt b) { long res = a.Data - b.Data; return new ModInt() { Data = res < 0 ? res + MOD : res }; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static ModInt operator *(ModInt a, int b) => new ModInt(a.Data * b);\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static ModInt operator *(ModInt a, long b) => a * new ModInt(b);\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static ModInt operator *(ModInt a, ModInt b) => new ModInt() { Data = a.Data * b.Data % MOD };\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static ModInt operator /(ModInt a, ModInt b) => new ModInt() { Data = a.Data * GetInverse(b) % MOD };\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public override string ToString() => Data.ToString();\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    static long GetInverse(long a)\n    {\n        long div, p = MOD, x1 = 1, y1 = 0, x2 = 0, y2 = 1;\n        while (true)\n        {\n            if (p == 1) return x2 + MOD; div = a / p; x1 -= x2 * div; y1 -= y2 * div; a %= p;\n            if (a == 1) return x1 + MOD; div = p / a; x2 -= x1 * div; y2 -= y1 * div; p %= a;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\n\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        cin = new Scanner();\n        new Myon().calc();\n        return 0;\n    }\n\n    static Scanner cin;\n\n    void calc()\n    {\n        setFact(600000 * 3);\n\n        int N = cin.nextInt();\n        int M = cin.nextInt();\n\n        long sum = 0;\n        for (int i = M % 2; i <= Math.Min(N, M); i += 2)\n        {\n            long tmp = getC(N, i);\n            int nokori = (3 * M - i) / 2;\n            long add = tmp * getC(nokori + N - 1, N - 1);\n            add %= mod;\n            sum += add;\n            sum %= mod;\n        }\n\n\n        for (int i = 2 * M + 1; i <= 3 * M; i++)\n        {\n            int nokori = 3 * M - i;\n            long add = getC(nokori + N - 2, N - 2);\n            add *= N;\n            add %= mod;\n\n            sum -= add;\n   \n            if (sum < 0) sum += mod;\n        }\n        Console.WriteLine(sum);\n    }\n\n\n    long mod = 998244353;\n\n    long powmod(long a, long p)\n    {\n        long ans = 1;\n        long mul = a;\n        for (; p > 0; p >>= 1, mul = (mul * mul) % mod)\n        {\n            if ((p & 1) == 1) ans = (ans * mul) % mod;\n        }\n        return ans;\n    }\n\n\n    long[] fact; //階乗\n    long[] revFact; //階乗の逆元\n    void setFact(int N)\n    {\n        fact = new long[N];\n        revFact = new long[N];\n        fact[0] = 1;\n        for (int i = 1; i < N; i++)\n        {\n            fact[i] = fact[i - 1] * i;\n            fact[i] %= mod;\n        }\n        revFact[N - 1] = powmod(fact[N - 1], mod - 2);\n        for (int i = N - 2; i >= 0; i--)\n        {\n            revFact[i] = revFact[i + 1] * (i + 1);\n            revFact[i] %= mod;\n        }\n    }\n\n    long getC(int a, int b)\n    {\n        return (((fact[a] * revFact[b]) % mod) * revFact[a - b]) % mod;\n    }\n\n\n}\n\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Numerics;\nusing System.Threading;\nusing System.Runtime.CompilerServices;\nusing System.Diagnostics;\nusing static System.Math;\nusing static System.Array;\nusing static AtCoder.Cout;\nusing static AtCoder.Tool;\nusing static AtCoder.ModInt;\nnamespace AtCoder\n{\n    class AC\n    {\n        const int MOD = 1000000007;\n        //const int MOD = 998244353;\n\n        const int INF = int.MaxValue / 2;\n        const long SINF = long.MaxValue / 3;\n        const double EPS = 1e-8;\n        static readonly int[] dI = { 0, 1, 0, -1, 1, -1, -1, 1 };\n        static readonly int[] dJ = { 1, 0, -1, 0, 1, 1, -1, -1 };\n        //static List<List<int>> G = new List<List<int>>();\n        //static List<List<Edge>> G = new List<List<Edge>>();\n        //static List<Edge> E = new List<Edge>();\n        static void Main(string[] args)\n        {\n            //var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; Console.SetOut(sw);\n\n            var th = new Thread(Run, 1 << 26);\n            th.Start();\n            th.Join();\n\n            //Run();\n            Console.Out.Flush();\n        }\n        static void Run()\n        {\n            int Testcase = 1;\n            //Testcase = Cin.Int;\n            for (var _ = 0; _ < Testcase; _++) Solve();\n        }\n        static void Solve()\n        {\n            Cin.Input(out int N, out int M);\n            ModInt ans = 0;\n            for (var i = M; i >= 0; i -= 2) \n            {\n                int s = (3 * M - i) / 2;\n                ans += nCr(N, i) * (nCr(s + N - 1, s) - i * nCr(s - M + N - 1, s - M) - (N - i) * nCr(s - M - 1 + N - 1, s - M - 1));\n            }\n            OutL(ans.value);\n        }\n        public struct Edge\n        {\n            public int from;\n\n            public int to;\n            public long dist;\n\n            public Edge(int t, long c)\n            {\n                from = -1;\n                to = t;\n                dist = c;\n            }\n            public Edge(int f, int t, long c)\n            {\n                from = f;\n                to = t;\n                dist = c;\n            }\n        }\n    }\n    public class Priority_Queue<T>\n    {\n        private List<T> Q;\n        private readonly Comparison<T> Func_Compare;\n        public Priority_Queue(Comparison<T> comp)\n        {\n            Func_Compare = comp;\n            Q = new List<T>();\n        }\n        private void PushHeap(List<T> list, T item)\n        {\n            int n = list.Count();\n            list.Add(item);\n\n            while (n != 0)\n            {\n                int pIndex = (n - 1) / 2;\n\n                if (Func_Compare(list[n], list[pIndex]) < 0)\n                {\n                    Swap(Q, n, pIndex);\n                }\n                else { break; }\n\n                n = pIndex;\n            }\n        }\n        private void PopHeap(List<T> list)\n        {\n            int n = list.Count() - 1;\n            list[0] = list[n];\n            list.RemoveAt(n);\n\n            int cur = 0;\n            int comp;\n\n            while (2 * cur + 1 <= n - 1)\n            {\n                int c1 = 2 * cur + 1;\n                int c2 = 2 * (cur + 1);\n                if (c1 == n - 1)\n                {\n                    comp = c1;\n                }\n                else\n                {\n\n                    comp = Func_Compare(list[c1], list[c2]) < 0 ? c1 : c2;\n                }\n\n                if (Func_Compare(list[cur], list[comp]) > 0)\n                {\n                    Swap(Q, cur, comp);\n                }\n                else { break; }\n\n                cur = comp;\n            }\n        }\n        private void Swap(List<T> list, int a, int b)\n        {\n            T keep = list[a];\n            list[a] = list[b];\n            list[b] = keep;\n        }\n\n        public void Enqueue(T value)\n        {\n            PushHeap(Q, value);\n        }\n\n        public T Dequeue()\n        {\n            T ret = Q[0];\n            PopHeap(Q);\n            return ret;\n        }\n\n        public T Peek()\n        {\n            return Q[0];\n        }\n\n        public int Count()\n        {\n            return Q.Count();\n        }\n        public bool Any()\n        {\n            return Q.Any();\n        }\n    }\n    public class SegmentTree<T>\n    {\n        //1-indexed type\n        int n;\n        T[] Tree;\n        Func<T, T, T> f;\n        T ex;\n        int L;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public SegmentTree(int size, Func<T, T, T> fun, T exvalue)\n        {\n            ex = exvalue;\n            f = fun;\n            n = 1;\n            while (n < size) n <<= 1;\n            Tree = new T[n << 1];\n            L = (n << 1) - 1;\n            for (var i = 0; i <= L; i++) Tree[i] = ex;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public SegmentTree(int size, Func<T, T, T> fun, T exvalue, T[] initial)\n        {\n            ex = exvalue;\n            n = 1; while (n < size) n <<= 1;\n            f = fun;\n            Tree = new T[n << 1];\n            L = (n << 1) - 1;\n            for (var i = 0; i <= L; i++) Tree[i] = (n <= i && i <= n + initial.Length - 1) ? initial[i - n] : ex;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Set_All()\n        {\n            for (var i = n - 1; i >= 1; i--) Tree[i] = f(Tree[i << 1], Tree[(i << 1) | 1]);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Assign(int idx, T nxt) => Tree[idx + n] = nxt;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Update(int idx)\n        {\n            int now = idx + n;\n            while (now > 1)\n            {\n                now >>= 1;\n                Tree[now] = f(Tree[now << 1], Tree[now << 1 | 1]);\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Query_Update(int idx, T nxt)\n        {\n            Assign(idx, nxt); Update(idx);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Query_Update_func(int idx, T y)\n        {\n            Assign(idx, f(Peek(idx), y)); Update(idx);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T Query_Fold(int l, int r)\n        {\n            int L = n + l;\n            int R = n + r;\n            T vL = ex, vR = ex;\n            while (L < R)\n            {\n                if (L % 2 == 1)\n                {\n                    vL = f(vL, Tree[L]);\n                    L++;\n                }\n                if (R % 2 == 1)\n                {\n                    vR = f(Tree[R - 1], vR);\n                    R--;\n                }\n                L >>= 1;\n                R >>= 1;\n            }\n            return f(vL, vR);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T Peek(int idx) => Tree[idx + n];\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Display(int len)\n        {\n            for (var i = 0; i < len; i++) Console.Write($\"{Tree[i + n]} \");\n            Console.WriteLine();\n        }\n    }\n    public class UnionFind\n    {\n        private int[] parent;\n        private int[] rank;\n        private int[] size;\n        public UnionFind(int n)\n        {\n            parent = new int[n];\n            rank = new int[n];\n            size = new int[n];\n            for (var i = 0; i < n; i++)\n            {\n                parent[i] = i;\n                rank[i] = 0;\n                size[i] = 1;\n            }\n        }\n\n        public int Root(int x)\n        {\n            return parent[x] == x ? x : parent[x] = Root(parent[x]);\n        }\n\n        public bool SameRoot(int x, int y)\n        {\n            return Root(x) == Root(y);\n        }\n\n        public void Unite(int x, int y)\n        {\n            x = Root(x);\n            y = Root(y);\n            if (x == y) { return; }\n\n            if (rank[x] < rank[y])\n            {\n                parent[x] = y;\n                size[y] += size[x];\n                size[x] = 0;\n            }\n            else\n            {\n                parent[y] = x;\n                if (rank[x] == rank[y]) { rank[x]++; }\n                size[x] += size[y];\n                size[y] = 0;\n            }\n        }\n\n        public int SizeOf(int x)\n        {\n            return size[Root(x)];\n        }\n\n    }\n    struct ModInt\n    {\n        public long value;\n        private const int MOD = 1000000007;\n        //private const int MOD = 998244353;\n        public ModInt(long value) { this.value = value; }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static implicit operator ModInt(long a)\n        {\n            var ret = a % MOD;\n            return new ModInt(ret < 0 ? (ret + MOD) : ret);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator +(ModInt a, ModInt b) => (a.value + b.value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator -(ModInt a, ModInt b) => (a.value - b.value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator *(ModInt a, ModInt b) => (a.value * b.value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator /(ModInt a, ModInt b) => a * Modpow(b, MOD - 2);\n\n        public static ModInt operator <<(ModInt a, int n) => (a.value << n);\n        public static ModInt operator >>(ModInt a, int n) => (a.value >> n);\n        public static ModInt operator ++(ModInt a) => a.value + 1;\n        public static ModInt operator --(ModInt a) => a.value - 1;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt Modpow(ModInt a, long n)\n        {\n            var k = a;\n            ModInt ret = 1;\n            while (n > 0)\n            {\n                if ((n & 1) != 0) ret *= k;\n                k *= k;\n                n >>= 1;\n            }\n            return ret;\n        }\n        private static readonly List<long> Factorials = new List<long>() { 1 };\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt Fac(long n)\n        {\n            for (var i = Factorials.Count(); i <= n; i++)\n            {\n                Factorials.Add((Factorials[i - 1] * i) % MOD);\n            }\n            return Factorials[(int)n];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt nCr(long n, long r)\n        {\n            if (n <= 0 || r < 0) return 0;\n            return n < r ? 0 : Fac(n) / (Fac(r) * Fac(n - r));\n        }\n        public static explicit operator int(ModInt a) => (int)a.value;\n    }\n    static class Cin\n    {\n        public static string[] ReadSplit => Console.ReadLine().Split();\n        public static int[] ReadSplitInt => ConvertAll(Console.ReadLine().Split(), int.Parse);\n        public static long[] ReadSplitLong => ConvertAll(Console.ReadLine().Split(), long.Parse);\n        public static double[] ReadSplit_Double => ConvertAll(Console.ReadLine().Split(), double.Parse);\n        public static string Str => Console.ReadLine();\n        public static int Int => int.Parse(Console.ReadLine());\n        public static long Long => long.Parse(Console.ReadLine());\n        public static double Double => double.Parse(Console.ReadLine());\n        public static T Conv<T>(string input)\n        {\n            if (typeof(T).Equals(typeof(ModInt)))\n            {\n                return (T)(dynamic)(long.Parse(input));\n            }\n            return (T)Convert.ChangeType(input, typeof(T));\n        }\n        public static void Input<T>(out T a) => a = Conv<T>(Console.ReadLine());\n        public static void Input<T, U>(out T a, out U b)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); }\n        public static void Input<T, U, V>(out T a, out U b, out V c)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); }\n        public static void Input<T, U, V, W>(out T a, out U b, out V c, out W d)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); d = Conv<W>(q[3]); }\n        public static void Input<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); d = Conv<W>(q[3]); e = Conv<X>(q[4]); }\n    }\n    static class Cout\n    {\n        public static void OutL(object s) => Console.WriteLine(s);\n        public static void Out_Sep<T>(IEnumerable<T> s) => Console.WriteLine(string.Join(\" \", s));\n        public static void Out_Sep<T>(IEnumerable<T> s, string sep) => Console.WriteLine(string.Join($\"{sep}\", s));\n        public static void Out_Sep(params object[] s) => Console.WriteLine(string.Join(\" \", s));\n        public static void Out_One(object s) => Console.Write($\"{s} \");\n        public static void Out_One(object s, string sep) => Console.Write($\"{s}{sep}\");\n        public static void Endl() => Console.WriteLine();\n    }\n    public static class Tool\n    {\n        static public void Initialize<T>(ref T[] array, T initialvalue)\n        {\n            array = ConvertAll(array, x => initialvalue);\n        }\n        static public void Swap<T>(ref T a, ref T b)\n        {\n            T keep = a;\n            a = b;\n            b = keep;\n        }\n        static public void Display<T>(T[,] array2d, int n, int m)\n        {\n            for (var i = 0; i < n; i++)\n            {\n                for (var j = 0; j < m; j++)\n                {\n                    Console.Write($\"{array2d[i, j]} \");\n                }\n                Console.WriteLine();\n            }\n        }\n        static public long Gcd(long a, long b)\n        {\n            if (a == 0 || b == 0) return Max(a, b);\n            return a % b == 0 ? b : Gcd(b, a % b);\n        }\n        static public long LPow(int a, int b) => (long)Pow(a, b);\n        static public bool Bit(long x, int dig) => ((1L << dig) & x) != 0;\n        static public int Sig(long a) => a == 0 ? 0 : (int)(a / Abs(a));\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\npublic class CSharp\n{\n    public static void Main()\n    {\n        Kyopuro chokudai = new Kyopuro();\n        chokudai.AtCoder();\n    }\n}\n\npublic class Kyopuro\n{\n\n    int n, m;\n\n    public void AtCoder()\n    {\n        string[] input;\n        input = Console.ReadLine().Split(' ');\n        n = int.Parse(input[0]);\n        m = int.Parse(input[1]);\n        int p = 998244353;\n\n        Mod mod = new Mod(2000000);\n        long ans = p - n;\n        ans *= mod.Ncr(m + n - 2, n - 1);\n        ans %= p;\n        ans += mod.Ncr(m * 3 + n - 1, n - 1);\n        ans %= p;\n        /*\n        if (n > m + 1)\n        {\n            ans += p;\n            ans -= mod.Ncr(n + m - 3, n - m - 2);\n            ans %= p;\n        }\n        */\n        if(n > m + 1)\n        {\n            int c = 0;\n            long ans2;\n            for (int i = 0; m + 2 + i <= n; i = i + 2)\n            {\n                if (m - 1 - i / 2 < 0) break;\n                ans2 = mod.Ncr(n, m + 2 + i);\n                ans2 *= mod.Ncr(n + m - 2 - i / 2, n - 1);\n                ans2 %= p;\n                ans += p;\n                ans -= ans2;\n                ans %= p;\n            }\n        }\n        \n\n        Console.WriteLine(ans);\n    }\n    public static void DebugWL(object x) { System.Diagnostics.Debug.WriteLine(x); }\n}\n\n// Mod(int n)\n// int[] fac: factors (1-indexed)\n// int n: the length of fac\n\n// int .Ncr(n,r): nCr\n// int .Fac(n): n!%p\n// int .Pow(n,m): n^m%p\n\npublic class Mod\n{\n    const int p = 998244353;\n    int[] fac;\n\n    public Mod(int n)\n    {\n        fac = new int[n + 1];\n        fac[0] = 1;\n        long tmp = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            tmp = fac[i - 1];\n            tmp *= i;\n            tmp %= p;\n            fac[i] = (int)tmp;\n        }\n\n\n    }\n\n    public int Ncr(int n, int r)\n    {\n        if (n < r) return 0;\n        if (r == 0 | n == r) return 1;\n        long a = Fac(n);\n        a = a * Pow(Fac(n - r), p - 2) % p;\n        a = a * Pow(Fac(r), p - 2) % p;\n        return (int)a;\n    }\n\n    public int Fac(int n)\n    {\n        if (fac[n] >= 0) return fac[n];\n        long k = 1;\n        for (long i = 1; i <= n; i++)\n        {\n            k = k * i % p;\n        }\n        fac[n] = (int)k;\n        return fac[n];\n    }\n\n    public int Pow(int n, int m)\n    {\n        if (m == 0) return 1;\n        if (m == 1) return n;\n        long a = 1;\n        if (m % 2 == 0)\n        {\n            a = Pow(n, m / 2);\n            a = a * a % p;\n        }\n        else\n        {\n            a = Pow(n, m / 2);\n            a = a * a % p;\n            a = a * n % p;\n        }\n        return (int)a;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Numerics;\nusing System.Threading;\nusing System.Runtime.CompilerServices;\nusing System.Diagnostics;\nusing static System.Math;\nusing static System.Array;\nusing static AtCoder.Cout;\nusing static AtCoder.Tool;\nusing static AtCoder.ModInt;\nnamespace AtCoder\n{\n    class AC\n    {\n        //const int MOD = 1000000007;\n        const int MOD = 998244353;\n\n        const int INF = int.MaxValue / 2;\n        const long SINF = long.MaxValue / 3;\n        const double EPS = 1e-8;\n        static readonly int[] dI = { 0, 1, 0, -1, 1, -1, -1, 1 };\n        static readonly int[] dJ = { 1, 0, -1, 0, 1, 1, -1, -1 };\n        //static List<List<int>> G = new List<List<int>>();\n        //static List<List<Edge>> G = new List<List<Edge>>();\n        //static List<Edge> E = new List<Edge>();\n        static void Main(string[] args)\n        {\n            //var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; Console.SetOut(sw);\n\n            var th = new Thread(Run, 1 << 26);\n            th.Start();\n            th.Join();\n\n            //Run();\n            Console.Out.Flush();\n        }\n        static void Run()\n        {\n            int Testcase = 1;\n            //Testcase = Cin.Int;\n            for (var _ = 0; _ < Testcase; _++) Solve();\n        }\n        static void Solve()\n        {\n            Cin.Input(out int N, out int M);\n            ModInt ans = 0;\n            for (var i = M; i >= 0; i -= 2) \n            {\n                int s = (3 * M - i) / 2;\n                ans += nCr(N, i) * (nCr(s + N - 1, s) - i * nCr(s - M + N - 1, s - M) - (N - i) * nCr(s - M - 1 + N - 1, s - M - 1));\n            }\n            OutL(ans.value);\n        }\n        public struct Edge\n        {\n            public int from;\n\n            public int to;\n            public long dist;\n\n            public Edge(int t, long c)\n            {\n                from = -1;\n                to = t;\n                dist = c;\n            }\n            public Edge(int f, int t, long c)\n            {\n                from = f;\n                to = t;\n                dist = c;\n            }\n        }\n    }\n    public class Priority_Queue<T>\n    {\n        private List<T> Q;\n        private readonly Comparison<T> Func_Compare;\n        public Priority_Queue(Comparison<T> comp)\n        {\n            Func_Compare = comp;\n            Q = new List<T>();\n        }\n        private void PushHeap(List<T> list, T item)\n        {\n            int n = list.Count();\n            list.Add(item);\n\n            while (n != 0)\n            {\n                int pIndex = (n - 1) / 2;\n\n                if (Func_Compare(list[n], list[pIndex]) < 0)\n                {\n                    Swap(Q, n, pIndex);\n                }\n                else { break; }\n\n                n = pIndex;\n            }\n        }\n        private void PopHeap(List<T> list)\n        {\n            int n = list.Count() - 1;\n            list[0] = list[n];\n            list.RemoveAt(n);\n\n            int cur = 0;\n            int comp;\n\n            while (2 * cur + 1 <= n - 1)\n            {\n                int c1 = 2 * cur + 1;\n                int c2 = 2 * (cur + 1);\n                if (c1 == n - 1)\n                {\n                    comp = c1;\n                }\n                else\n                {\n\n                    comp = Func_Compare(list[c1], list[c2]) < 0 ? c1 : c2;\n                }\n\n                if (Func_Compare(list[cur], list[comp]) > 0)\n                {\n                    Swap(Q, cur, comp);\n                }\n                else { break; }\n\n                cur = comp;\n            }\n        }\n        private void Swap(List<T> list, int a, int b)\n        {\n            T keep = list[a];\n            list[a] = list[b];\n            list[b] = keep;\n        }\n\n        public void Enqueue(T value)\n        {\n            PushHeap(Q, value);\n        }\n\n        public T Dequeue()\n        {\n            T ret = Q[0];\n            PopHeap(Q);\n            return ret;\n        }\n\n        public T Peek()\n        {\n            return Q[0];\n        }\n\n        public int Count()\n        {\n            return Q.Count();\n        }\n        public bool Any()\n        {\n            return Q.Any();\n        }\n    }\n    public class SegmentTree<T>\n    {\n        //1-indexed type\n        int n;\n        T[] Tree;\n        Func<T, T, T> f;\n        T ex;\n        int L;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public SegmentTree(int size, Func<T, T, T> fun, T exvalue)\n        {\n            ex = exvalue;\n            f = fun;\n            n = 1;\n            while (n < size) n <<= 1;\n            Tree = new T[n << 1];\n            L = (n << 1) - 1;\n            for (var i = 0; i <= L; i++) Tree[i] = ex;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public SegmentTree(int size, Func<T, T, T> fun, T exvalue, T[] initial)\n        {\n            ex = exvalue;\n            n = 1; while (n < size) n <<= 1;\n            f = fun;\n            Tree = new T[n << 1];\n            L = (n << 1) - 1;\n            for (var i = 0; i <= L; i++) Tree[i] = (n <= i && i <= n + initial.Length - 1) ? initial[i - n] : ex;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Set_All()\n        {\n            for (var i = n - 1; i >= 1; i--) Tree[i] = f(Tree[i << 1], Tree[(i << 1) | 1]);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Assign(int idx, T nxt) => Tree[idx + n] = nxt;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Update(int idx)\n        {\n            int now = idx + n;\n            while (now > 1)\n            {\n                now >>= 1;\n                Tree[now] = f(Tree[now << 1], Tree[now << 1 | 1]);\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Query_Update(int idx, T nxt)\n        {\n            Assign(idx, nxt); Update(idx);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Query_Update_func(int idx, T y)\n        {\n            Assign(idx, f(Peek(idx), y)); Update(idx);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T Query_Fold(int l, int r)\n        {\n            int L = n + l;\n            int R = n + r;\n            T vL = ex, vR = ex;\n            while (L < R)\n            {\n                if (L % 2 == 1)\n                {\n                    vL = f(vL, Tree[L]);\n                    L++;\n                }\n                if (R % 2 == 1)\n                {\n                    vR = f(Tree[R - 1], vR);\n                    R--;\n                }\n                L >>= 1;\n                R >>= 1;\n            }\n            return f(vL, vR);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T Peek(int idx) => Tree[idx + n];\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Display(int len)\n        {\n            for (var i = 0; i < len; i++) Console.Write($\"{Tree[i + n]} \");\n            Console.WriteLine();\n        }\n    }\n    public class UnionFind\n    {\n        private int[] parent;\n        private int[] rank;\n        private int[] size;\n        public UnionFind(int n)\n        {\n            parent = new int[n];\n            rank = new int[n];\n            size = new int[n];\n            for (var i = 0; i < n; i++)\n            {\n                parent[i] = i;\n                rank[i] = 0;\n                size[i] = 1;\n            }\n        }\n\n        public int Root(int x)\n        {\n            return parent[x] == x ? x : parent[x] = Root(parent[x]);\n        }\n\n        public bool SameRoot(int x, int y)\n        {\n            return Root(x) == Root(y);\n        }\n\n        public void Unite(int x, int y)\n        {\n            x = Root(x);\n            y = Root(y);\n            if (x == y) { return; }\n\n            if (rank[x] < rank[y])\n            {\n                parent[x] = y;\n                size[y] += size[x];\n                size[x] = 0;\n            }\n            else\n            {\n                parent[y] = x;\n                if (rank[x] == rank[y]) { rank[x]++; }\n                size[x] += size[y];\n                size[y] = 0;\n            }\n        }\n\n        public int SizeOf(int x)\n        {\n            return size[Root(x)];\n        }\n\n    }\n    struct ModInt\n    {\n        public long value;\n        //private const int MOD = 1000000007;\n        private const int MOD = 998244353;\n        public ModInt(long value) { this.value = value; }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static implicit operator ModInt(long a)\n        {\n            var ret = a % MOD;\n            return new ModInt(ret < 0 ? (ret + MOD) : ret);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator +(ModInt a, ModInt b) => (a.value + b.value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator -(ModInt a, ModInt b) => (a.value - b.value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator *(ModInt a, ModInt b) => (a.value * b.value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator /(ModInt a, ModInt b) => a * Modpow(b, MOD - 2);\n\n        public static ModInt operator <<(ModInt a, int n) => (a.value << n);\n        public static ModInt operator >>(ModInt a, int n) => (a.value >> n);\n        public static ModInt operator ++(ModInt a) => a.value + 1;\n        public static ModInt operator --(ModInt a) => a.value - 1;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt Modpow(ModInt a, long n)\n        {\n            var k = a;\n            ModInt ret = 1;\n            while (n > 0)\n            {\n                if ((n & 1) != 0) ret *= k;\n                k *= k;\n                n >>= 1;\n            }\n            return ret;\n        }\n        private static readonly List<long> Factorials = new List<long>() { 1 };\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt Fac(long n)\n        {\n            for (var i = Factorials.Count(); i <= n; i++)\n            {\n                Factorials.Add((Factorials[i - 1] * i) % MOD);\n            }\n            return Factorials[(int)n];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt nCr(long n, long r)\n        {\n            if (n <= 0 || r < 0) return 0;\n            return n < r ? 0 : Fac(n) / (Fac(r) * Fac(n - r));\n        }\n        public static explicit operator int(ModInt a) => (int)a.value;\n    }\n    static class Cin\n    {\n        public static string[] ReadSplit => Console.ReadLine().Split();\n        public static int[] ReadSplitInt => ConvertAll(Console.ReadLine().Split(), int.Parse);\n        public static long[] ReadSplitLong => ConvertAll(Console.ReadLine().Split(), long.Parse);\n        public static double[] ReadSplit_Double => ConvertAll(Console.ReadLine().Split(), double.Parse);\n        public static string Str => Console.ReadLine();\n        public static int Int => int.Parse(Console.ReadLine());\n        public static long Long => long.Parse(Console.ReadLine());\n        public static double Double => double.Parse(Console.ReadLine());\n        public static T Conv<T>(string input)\n        {\n            if (typeof(T).Equals(typeof(ModInt)))\n            {\n                return (T)(dynamic)(long.Parse(input));\n            }\n            return (T)Convert.ChangeType(input, typeof(T));\n        }\n        public static void Input<T>(out T a) => a = Conv<T>(Console.ReadLine());\n        public static void Input<T, U>(out T a, out U b)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); }\n        public static void Input<T, U, V>(out T a, out U b, out V c)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); }\n        public static void Input<T, U, V, W>(out T a, out U b, out V c, out W d)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); d = Conv<W>(q[3]); }\n        public static void Input<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); d = Conv<W>(q[3]); e = Conv<X>(q[4]); }\n    }\n    static class Cout\n    {\n        public static void OutL(object s) => Console.WriteLine(s);\n        public static void Out_Sep<T>(IEnumerable<T> s) => Console.WriteLine(string.Join(\" \", s));\n        public static void Out_Sep<T>(IEnumerable<T> s, string sep) => Console.WriteLine(string.Join($\"{sep}\", s));\n        public static void Out_Sep(params object[] s) => Console.WriteLine(string.Join(\" \", s));\n        public static void Out_One(object s) => Console.Write($\"{s} \");\n        public static void Out_One(object s, string sep) => Console.Write($\"{s}{sep}\");\n        public static void Endl() => Console.WriteLine();\n    }\n    public static class Tool\n    {\n        static public void Initialize<T>(ref T[] array, T initialvalue)\n        {\n            array = ConvertAll(array, x => initialvalue);\n        }\n        static public void Swap<T>(ref T a, ref T b)\n        {\n            T keep = a;\n            a = b;\n            b = keep;\n        }\n        static public void Display<T>(T[,] array2d, int n, int m)\n        {\n            for (var i = 0; i < n; i++)\n            {\n                for (var j = 0; j < m; j++)\n                {\n                    Console.Write($\"{array2d[i, j]} \");\n                }\n                Console.WriteLine();\n            }\n        }\n        static public long Gcd(long a, long b)\n        {\n            if (a == 0 || b == 0) return Max(a, b);\n            return a % b == 0 ? b : Gcd(b, a % b);\n        }\n        static public long LPow(int a, int b) => (long)Pow(a, b);\n        static public bool Bit(long x, int dig) => ((1L << dig) & x) != 0;\n        static public int Sig(long a) => a == 0 ? 0 : (int)(a / Abs(a));\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nnamespace Program {\n\tpublic class Solver {\n\t\tRandom rnd = new Random();\n\t\tpublic void Solve() {\n\t\t\tvar n = ri;\n\t\t\tvar m = ri;\n\t\t\tvar table = new BinomialCoefficient(3000050);\n\t\t\tModInt ans = 0;\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tif (i <= m && i % 2 == m % 2)\n\t\t\t\t\tans += table[n, i] * table[(3 * m - i) / 2 + n - 1, n - 1];\n\t\t\t}\n\t\t\t//Debug.WriteLine(ans);\n\t\t\tfor (int max = 2 * m + 1; max <= 3 * m; max++) {\n\t\t\t\tans -= n * table[3 * m - max + n - 2, n - 2];\n\t\t\t\t// Debug.WriteLine(max);\n\t\t\t\t// Debug.WriteLine(n * table[3 * m - max + n - 2, n - 2]);\n\t\t\t}\n\n\t\t\tConsole.WriteLine(ans);\n\t\t}\n\t\tconst long INF = 1L << 60;\n\t\tstatic int[] dx = { -1, 0, 1, 0 };\n\t\tstatic int[] dy = { 0, 1, 0, -1 };\n\t\tint ri { get { return sc.Integer(); } }\n\t\tlong rl { get { return sc.Long(); } }\n\t\tdouble rd { get { return sc.Double(); } }\n\t\tstring rs { get { return sc.Scan(); } }\n\t\tpublic IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n\t\tstatic T[] Enumerate<T>(int n, Func<int, T> f) {\n\t\t\tvar a = new T[n];\n\t\t\tfor (int i = 0; i < a.Length; ++i) a[i] = f(i);\n\t\t\treturn a;\n\t\t}\n\t\tstatic public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\t}\n}\n\n#region main\nstatic class Ex {\n\tstatic public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n\tstatic public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n\t\treturn string.Join(st, ie);\n\t}\n\tstatic public void Main() {\n\t\tConsole.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = true });\n\t\tvar solver = new Program.Solver();\n\t\t/* \n\t\tvar t = new System.Threading.Thread(solver.Solve, 50000000);\n\t\tt.Start();\n\t\tt.Join();\n\t\t*/\n\t\tsolver.Solve();\n\t\tConsole.Out.Flush();\n\t}\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n\tusing System.IO;\n\tusing System.Text;\n\tusing System.Globalization;\n\n\tpublic class Printer : StreamWriter {\n\t\tpublic override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n\t\tpublic Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n\t}\n\n\tpublic class StreamScanner {\n\t\tpublic StreamScanner(Stream stream) { str = stream; }\n\n\t\tpublic readonly Stream str;\n\t\tprivate readonly byte[] buf = new byte[1024];\n\t\tprivate int len, ptr;\n\t\tpublic bool isEof = false;\n\t\tpublic bool IsEndOfStream { get { return isEof; } }\n\n\t\tprivate byte read() {\n\t\t\tif (isEof) return 0;\n\t\t\tif (ptr >= len) {\n\t\t\t\tptr = 0;\n\t\t\t\tif ((len = str.Read(buf, 0, 1024)) <= 0) {\n\t\t\t\t\tisEof = true;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[ptr++];\n\t\t}\n\n\t\tpublic char Char() {\n\t\t\tbyte b = 0;\n\t\t\tdo b = read(); while ((b < 33 || 126 < b) && !isEof);\n\t\t\treturn (char)b;\n\t\t}\n\t\tpublic string Scan() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic string ScanLine() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n\t\tpublic int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n\t\tpublic double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n\t}\n}\n\n#endregion\n\n\n#region ModInt\n/// <summary>\n/// [0,<see cref=\"Mod\"/>) までの値を取るような数\n/// </summary>\npublic struct ModInt {\n\t/// <summary>\n\t/// 剰余を取る値．\n\t/// </summary>\n\tpublic const long Mod = 998244353;\n\n\t/// <summary>\n\t/// 実際の数値．\n\t/// </summary>\n\tpublic long num;\n\t/// <summary>\n\t/// 値が <paramref name=\"n\"/> であるようなインスタンスを構築します．\n\t/// </summary>\n\t/// <param name=\"n\">インスタンスが持つ値</param>\n\t/// <remarks>パフォーマンスの問題上，コンストラクタ内では剰余を取りません．そのため，<paramref name=\"n\"/> ∈ [0,<see cref=\"Mod\"/>) を満たすような <paramref name=\"n\"/> を渡してください．このコンストラクタは O(1) で実行されます．</remarks>\n\tpublic ModInt(long n) { num = n; }\n\t/// <summary>\n\t/// このインスタンスの数値を文字列に変換します．\n\t/// </summary>\n\t/// <returns>[0,<see cref=\"Mod\"/>) の範囲内の整数を 10 進表記したもの．</returns>\n\tpublic override string ToString() { return num.ToString(); }\n\tpublic static ModInt operator +(ModInt l, ModInt r) { l.num += r.num; if (l.num >= Mod) l.num -= Mod; return l; }\n\tpublic static ModInt operator -(ModInt l, ModInt r) { l.num -= r.num; if (l.num < 0) l.num += Mod; return l; }\n\tpublic static ModInt operator *(ModInt l, ModInt r) { return new ModInt(l.num * r.num % Mod); }\n\tpublic static implicit operator ModInt(long n) { n %= Mod; if (n < 0) n += Mod; return new ModInt(n); }\n\n\t/// <summary>\n\t/// 与えられた 2 つの数値からべき剰余を計算します．\n\t/// </summary>\n\t/// <param name=\"v\">べき乗の底</param>\n\t/// <param name=\"k\">べき指数</param>\n\t/// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n\tpublic static ModInt Pow(ModInt v, long k) { return Pow(v.num, k); }\n\n\t/// <summary>\n\t/// 与えられた 2 つの数値からべき剰余を計算します．\n\t/// </summary>\n\t/// <param name=\"v\">べき乗の底</param>\n\t/// <param name=\"k\">べき指数</param>\n\t/// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n\tpublic static ModInt Pow(long v, long k) {\n\t\tlong ret = 1;\n\t\tfor (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n\t\t\tif ((k & 1) == 1) ret = ret * v % Mod;\n\t\treturn new ModInt(ret);\n\t}\n\t/// <summary>\n\t/// 与えられた数の逆元を計算します．\n\t/// </summary>\n\t/// <param name=\"v\">逆元を取る対象となる数</param>\n\t/// <returns>逆元となるような値</returns>\n\t/// <remarks>法が素数であることを仮定して，フェルマーの小定理に従って逆元を O(log N) で計算します．</remarks>\n\tpublic static ModInt Inverse(ModInt v) { return Pow(v, Mod - 2); }\n}\n#endregion\n#region Binomial Coefficient\npublic class BinomialCoefficient {\n\tpublic ModInt[] fact, ifact;\n\tpublic BinomialCoefficient(int n) {\n\t\tfact = new ModInt[n + 1];\n\t\tifact = new ModInt[n + 1];\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tfact[i] = fact[i - 1] * i;\n\t\tifact[n] = ModInt.Inverse(fact[n]);\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t\tifact[i] = ifact[i + 1] * (i + 1);\n\t\tifact[0] = ifact[1];\n\t}\n\tpublic ModInt this[int n, int r] {\n\t\tget {\n\t\t\tif (n < 0 || n >= fact.Length || r < 0 || r > n) return 0;\n\t\t\treturn fact[n] * ifact[n - r] * ifact[r];\n\t\t}\n\t}\n\tpublic ModInt RepeatedCombination(int n, int k) {\n\t\tif (k == 0) return 1;\n\t\treturn this[n + k - 1, k];\n\t}\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing CompLib.Mathematics;\nusing CompLib.Util;\n\npublic class Program\n{\n    private int N, M;\n\n    private ModInt[] F;\n\n    public void Solve()\n    {\n        var sc = new Scanner();\n        F = new ModInt[1000001];\n        F[0] = 1;\n        for (int i = 1; i <= 1000000; i++)\n        {\n            F[i] = F[i - 1] * i;\n        }\n\n        N = sc.NextInt();\n        M = sc.NextInt();\n        // 総和 3M -a\n        // 最大 2M以下 -b\n        // 奇数の個数 M以下　パリティ一致 -c\n\n        // -aは自明\n        // M=0のとき、b,c満たす\n\n        // M=kのとき満たしている、\n        // M=k+1でも満たす\n\n        // a,cのみのパターン\n        ModInt ans = 0;\n        for (int i = M; i >= 0; i -= 2)\n        {\n            // i 奇数の個数\n            // 奇数のところにはあらかじめ1を置いておく\n            if (i > N) continue;\n            // 並べ方 N C i\n            var a = C(N, i);\n\n            // 残り 3M - i個 偶数になるように分ける\n            var b = H(N, (3 * M - i) / 2);\n            ans += a * b;\n        }\n\n        // bを満たさないパターン\n        // 最大が2M超過\n        for (int max = 2 * M + 1; max <= 3 * M; max++)\n        {\n            // 残り3M-max並べ方\n            // M以下なのでcは満たす\n            var c = H(N-1, 3 * M - max);\n            ans -= c * N;\n        }\n\n        Console.WriteLine(ans);\n    }\n\n    ModInt C(int n, int m)\n    {\n        return F[n] * ModInt.Inverse(F[n - m] * F[m]);\n    }\n\n    // n種類、r個選ぶ\n    ModInt H(int n, int r)\n    {\n        return C(n + r - 1, r);\n    }\n\n    public static void Main(string[] args) => new Program().Solve();\n}\n\n// https://bitbucket.org/camypaper/complib\nnamespace CompLib.Mathematics\n{\n    #region ModInt\n\n    /// <summary>\n    /// [0,<see cref=\"Mod\"/>) までの値を取るような数\n    /// </summary>\n    public struct ModInt\n    {\n        /// <summary>\n        /// 剰余を取る値．\n        /// </summary>\n        // public const long Mod = (int) 1e9 + 7;\n        public const long Mod = 998244353;\n\n        /// <summary>\n        /// 実際の数値．\n        /// </summary>\n        public long num;\n\n        /// <summary>\n        /// 値が <paramref name=\"n\"/> であるようなインスタンスを構築します．\n        /// </summary>\n        /// <param name=\"n\">インスタンスが持つ値</param>\n        /// <remarks>パフォーマンスの問題上，コンストラクタ内では剰余を取りません．そのため，<paramref name=\"n\"/> ∈ [0,<see cref=\"Mod\"/>) を満たすような <paramref name=\"n\"/> を渡してください．このコンストラクタは O(1) で実行されます．</remarks>\n        public ModInt(long n)\n        {\n            num = n;\n        }\n\n        /// <summary>\n        /// このインスタンスの数値を文字列に変換します．\n        /// </summary>\n        /// <returns>[0,<see cref=\"Mod\"/>) の範囲内の整数を 10 進表記したもの．</returns>\n        public override string ToString()\n        {\n            return num.ToString();\n        }\n\n        public static ModInt operator +(ModInt l, ModInt r)\n        {\n            l.num += r.num;\n            if (l.num >= Mod) l.num -= Mod;\n            return l;\n        }\n\n        public static ModInt operator -(ModInt l, ModInt r)\n        {\n            l.num -= r.num;\n            if (l.num < 0) l.num += Mod;\n            return l;\n        }\n\n        public static ModInt operator *(ModInt l, ModInt r)\n        {\n            return new ModInt(l.num * r.num % Mod);\n        }\n\n        public static implicit operator ModInt(long n)\n        {\n            n %= Mod;\n            if (n < 0) n += Mod;\n            return new ModInt(n);\n        }\n\n        /// <summary>\n        /// 与えられた 2 つの数値からべき剰余を計算します．\n        /// </summary>\n        /// <param name=\"v\">べき乗の底</param>\n        /// <param name=\"k\">べき指数</param>\n        /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n        public static ModInt Pow(ModInt v, long k)\n        {\n            return Pow(v.num, k);\n        }\n\n        /// <summary>\n        /// 与えられた 2 つの数値からべき剰余を計算します．\n        /// </summary>\n        /// <param name=\"v\">べき乗の底</param>\n        /// <param name=\"k\">べき指数</param>\n        /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n        public static ModInt Pow(long v, long k)\n        {\n            long ret = 1;\n            for (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n                if ((k & 1) == 1)\n                    ret = ret * v % Mod;\n            return new ModInt(ret);\n        }\n\n        /// <summary>\n        /// 与えられた数の逆元を計算します．\n        /// </summary>\n        /// <param name=\"v\">逆元を取る対象となる数</param>\n        /// <returns>逆元となるような値</returns>\n        /// <remarks>法が素数であることを仮定して，フェルマーの小定理に従って逆元を O(log N) で計算します．</remarks>\n        public static ModInt Inverse(ModInt v)\n        {\n            return Pow(v, Mod - 2);\n        }\n    }\n\n    #endregion\n\n    #region Binomial Coefficient\n\n    public class BinomialCoefficient\n    {\n        public ModInt[] fact, ifact;\n\n        public BinomialCoefficient(int n)\n        {\n            fact = new ModInt[n + 1];\n            ifact = new ModInt[n + 1];\n            fact[0] = 1;\n            for (int i = 1; i <= n; i++)\n                fact[i] = fact[i - 1] * i;\n            ifact[n] = ModInt.Inverse(fact[n]);\n            for (int i = n - 1; i >= 0; i--)\n                ifact[i] = ifact[i + 1] * (i + 1);\n            ifact[0] = ifact[1];\n        }\n\n        public ModInt this[int n, int r]\n        {\n            get\n            {\n                if (n < 0 || n >= fact.Length || r < 0 || r > n) return 0;\n                return fact[n] * ifact[n - r] * ifact[r];\n            }\n        }\n\n        public ModInt RepeatedCombination(int n, int k)\n        {\n            if (k == 0) return 1;\n            return this[n + k - 1, k];\n        }\n    }\n\n    #endregion\n}\n\n\nnamespace CompLib.Util\n{\n    using System;\n    using System.Linq;\n\n    class Scanner\n    {\n        private string[] _line;\n        private int _index;\n        private const char Separator = ' ';\n\n        public Scanner()\n        {\n            _line = new string[0];\n            _index = 0;\n        }\n\n        public string Next()\n        {\n            if (_index >= _line.Length)\n            {\n                string s;\n                do\n                {\n                    s = Console.ReadLine();\n                } while (s.Length == 0);\n\n                _line = s.Split(Separator);\n                _index = 0;\n            }\n\n            return _line[_index++];\n        }\n\n        public string ReadLine()\n        {\n            _index = _line.Length;\n            return Console.ReadLine();\n        }\n\n        public int NextInt() => int.Parse(Next());\n        public long NextLong() => long.Parse(Next());\n        public double NextDouble() => double.Parse(Next());\n        public decimal NextDecimal() => decimal.Parse(Next());\n        public char NextChar() => Next()[0];\n        public char[] NextCharArray() => Next().ToCharArray();\n\n        public string[] Array()\n        {\n            string s = Console.ReadLine();\n            _line = s.Length == 0 ? new string[0] : s.Split(Separator);\n            _index = _line.Length;\n            return _line;\n        }\n\n        public int[] IntArray() => Array().Select(int.Parse).ToArray();\n        public long[] LongArray() => Array().Select(long.Parse).ToArray();\n        public double[] DoubleArray() => Array().Select(double.Parse).ToArray();\n        public decimal[] DecimalArray() => Array().Select(decimal.Parse).ToArray();\n    }\n}"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(defconstant +mod+ 998244353)\n\n;; BEGIN_INSERTED_CONTENTS\n;;;\n;;; Binomial coefficient with mod\n;;; build: O(n)\n;;; query: O(1)\n;;;\n\n;; TODO: non-global handling\n\n(defconstant +binom-size+ 5010000)\n(defconstant +binom-mod+ +mod+)\n\n(declaim ((simple-array (unsigned-byte 31) (*)) *fact* *fact-inv* *inv*))\n(defparameter *fact* (make-array +binom-size+ :element-type '(unsigned-byte 31))\n  \"table of factorials\")\n(defparameter *fact-inv* (make-array +binom-size+ :element-type '(unsigned-byte 31))\n  \"table of inverses of factorials\")\n(defparameter *inv* (make-array +binom-size+ :element-type '(unsigned-byte 31))\n  \"table of inverses of non-negative integers\")\n\n(defun initialize-binom ()\n  (declare (optimize (speed 3) (safety 0)))\n  (setf (aref *fact* 0) 1\n        (aref *fact* 1) 1\n        (aref *fact-inv* 0) 1\n        (aref *fact-inv* 1) 1\n        (aref *inv* 1) 1)\n  (loop for i from 2 below +binom-size+\n        do (setf (aref *fact* i) (mod (* i (aref *fact* (- i 1))) +binom-mod+)\n                 (aref *inv* i) (- +binom-mod+\n                                   (mod (* (aref *inv* (rem +binom-mod+ i))\n                                           (floor +binom-mod+ i))\n                                        +binom-mod+))\n                 (aref *fact-inv* i) (mod (* (aref *inv* i)\n                                             (aref *fact-inv* (- i 1)))\n                                          +binom-mod+))))\n\n(initialize-binom)\n\n(declaim (inline binom))\n(defun binom (n k)\n  \"Returns nCk.\"\n  (if (or (< n k) (< n 0) (< k 0))\n      0\n      (mod (* (aref *fact* n)\n              (mod (* (aref *fact-inv* k) (aref *fact-inv* (- n k))) +binom-mod+))\n           +binom-mod+)))\n\n(declaim (inline perm))\n(defun perm (n k)\n  \"Returns nPk.\"\n  (if (or (< n k) (< n 0) (< k 0))\n      0\n      (mod (* (aref *fact* n) (aref *fact-inv* (- n k))) +binom-mod+)))\n\n;; TODO: compiler macro or source-transform\n(declaim (inline multinomial))\n(defun multinomial (&rest ks)\n  \"Returns the multinomial coefficient K!/k_1!k_2!...k_n! for K = k_1 + k_2 +\n... + k_n. K must be equal to or smaller than\nMOST-POSITIVE-FIXNUM. (multinomial) returns 1.\"\n  (let ((sum 0)\n        (result 1))\n    (declare ((integer 0 #.most-positive-fixnum) result sum))\n    (dolist (k ks)\n      (incf sum k)\n      (setq result\n            (mod (* result (aref *fact-inv* k)) +binom-mod+)))\n    (mod (* result (aref *fact* sum)) +binom-mod+)))\n\n(declaim (inline stirling2))\n(defun stirling2 (n k)\n  \"Returns the stirling number of the second kind S2(n, k). Time complexity is\nO(klog(n)).\"\n  (declare ((integer 0 #.most-positive-fixnum) n k))\n  (labels ((mod-power (base exp)\n             (declare ((integer 0 #.most-positive-fixnum) base exp))\n             (loop with res of-type (integer 0 #.most-positive-fixnum) = 1\n                   while (> exp 0)\n                   when (oddp exp)\n                   do (setq res (mod (* res base) +binom-mod+))\n                   do (setq base (mod (* base base) +binom-mod+)\n                            exp (ash exp -1))\n                   finally (return res))))\n    (loop with result of-type fixnum = 0\n          for i from 0 to k\n          for delta = (mod (* (binom k i) (mod-power i n)) +binom-mod+)\n          when (evenp (- k i))\n          do (incf result delta)\n             (when (>= result +binom-mod+)\n               (decf result +binom-mod+))\n          else\n          do (decf result delta)\n             (when (< result 0)\n               (incf result +binom-mod+))\n          finally (return (mod (* result (aref *fact-inv* k)) +binom-mod+)))))\n\n(declaim (inline catalan))\n(defun catalan (n)\n  \"Returns the N-th Catalan number.\"\n  (declare ((integer 0 #.most-positive-fixnum) n))\n  (mod (* (aref *fact* (* 2 n))\n          (mod (* (aref *fact-inv* (+ n 1))\n                  (aref *fact-inv* n))\n               +binom-mod+))\n       +binom-mod+))\n\n;;;\n;;; Arithmetic operations with static modulus\n;;;\n\n;; FIXME: Currently MOD* and MOD+ doesn't apply MOD when the number of\n;; parameters is one.\n(defmacro define-mod-operations (divisor)\n  `(progn\n     (defun mod* (&rest args)\n       (reduce (lambda (x y) (mod (* x y) ,divisor)) args))\n\n     (defun mod+ (&rest args)\n       (reduce (lambda (x y) (mod (+ x y) ,divisor)) args))\n\n     #+sbcl\n     (eval-when (:compile-toplevel :load-toplevel :execute)\n       (locally (declare (muffle-conditions warning))\n         (sb-c:define-source-transform mod* (&rest args)\n           (if (null args)\n               1\n               (reduce (lambda (x y) `(mod (* ,x ,y) ,',divisor)) args)))\n         (sb-c:define-source-transform mod+ (&rest args)\n           (if (null args)\n               0\n               (reduce (lambda (x y) `(mod (+ ,x ,y) ,',divisor)) args)))))\n\n     (define-modify-macro incfmod (delta)\n       (lambda (x y) (mod (+ x y) ,divisor)))\n\n     (define-modify-macro decfmod (delta)\n       (lambda (x y) (mod (- x y) ,divisor)))\n\n     (define-modify-macro mulfmod (multiplier)\n       (lambda (x y) (mod (* x y) ,divisor)))))\n\n(in-package :cl-user)\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n;;;\n;;; Body\n;;;\n\n;; 和はちょうど3Mでなければならない\n;; 最大値は2M以下でなければならない\n;; 奇数セルはM個以下でなければならない\n\n(defun test (n m)\n  (let ((xs (make-array n :element-type 'uint31 :initial-element 0))\n        (table (make-hash-table :test #'equalp)))\n    (sb-int:named-let dfs ((depth 0))\n      (if (= depth m)\n          (setf (gethash (copy-seq xs) table) t)\n          (dotimes (i n)\n            (dotimes (j n)\n              (unless (= i j)\n                (incf (aref xs i) 2)\n                (incf (aref xs j) 1)\n                (dfs (+ depth 1))\n                (decf (aref xs i) 2)\n                (decf (aref xs j) 1))))))\n    table))\n\n(defun feasible-p (m xs)\n  (and (= (reduce #'+ xs) (* 3 m))\n       (<= (reduce #'max xs) (* 2 m))\n       (<= (count-if #'oddp xs) m)))\n\n(defun test2 (n m)\n  (let ((xs (make-array n :element-type 'uint31 :initial-element 0))\n        (table (make-hash-table :test #'equalp)))\n    (sb-int:named-let dfs ((pos 0) (sum 0))\n      (if (= pos n)\n          (when (feasible-p m xs)\n            (setf (gethash (copy-seq xs) table) t))\n          (loop for x from 0 to (- (* 3 m) sum)\n                do (setf (aref xs pos) x)\n                   (dfs (+ pos 1) (+ sum x)))))\n    table))\n\n(define-mod-operations +mod+)\n(declaim (inline multichoose))\n(defun multichoose (n k)\n  (binom (+ n (- k 1)) (- k 1)))\n\n(defun main ()\n  (let* ((n (read))\n         (m (read))\n         (res (multichoose (* 3 m) n)))\n    (declare (uint31 n m res))\n    (loop for y from (+ 1 (* 2 m)) to (* 3 m)\n          do (decfmod res (mod* n (multichoose (- (* 3 m) y) (- n 1)))))\n    (loop for y from (+ m 1) to n\n          when (evenp (- (* 3 m) y))\n          do (decfmod res (mod* (binom n y)\n                                (multichoose (floor (- (* 3 m) y) 2) n))))\n    (println res)))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    #+os-windows (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)\n    #+os-unix (run-program \"xsel\" '(\"-b\" \"-o\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"2 2\n\"\n    \"3\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"3 2\n\"\n    \"19\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"10 10\n\"\n    \"211428932\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"100000 50000\n\"\n    \"3463133\n\")))\n"
  },
  {
    "language": "JavaScript",
    "code": "var GET=(function(){function f(s){return new g(s);}function g(s){this._s=s.trim().split(\"\\n\");this._y=0;}g.prototype.a=function(f){var s=this._s, y=this._y, r;if(typeof s[y]===\"string\")s[y]=s[y].split(\" \").reverse();r=s[y].pop();if(!s[y].length)this._y++;return f?r:+r;};g.prototype.l=function(f){var s=this._s[this._y++].split(\" \");return f?s:s.map(a=>+a);};g.prototype.m=function(n,f){var r=this._s.slice(this._y,this._y+=n).map(a=>a.split(\" \"));return f?r:r.map(a=>a.map(a=>+a));};g.prototype.r=function(n,f){var r=this._s.slice(this._y,this._y+=n);return f?r:r.map(a=>+a);};return f;})();\nvar o=GET(require(\"fs\").readFileSync(\"/dev/stdin\",\"utf8\"));\nfunction xArray(v){var a=arguments,l=a.length,r=\"Array(a[\"+--l+\"]).fill(0).map(x=>{return \"+v+\";})\";while(--l)r=\"Array(a[\"+l+\"]).fill(0).map(x=>\"+r+\")\";return eval(r);}\nvar mod = 998244353;\nfunction abmod(){for(var a=arguments,r=a[0],i=1;i<a.length;)r=((r>>16)*a[i]%mod*65536+(r&65535)*a[i++])%mod;return r;}\nvar fac=[1,1];\nfunction fSet(n){for(var i=2;i<=n;)fac[i]=abmod(fac[i-1],i++);}\nfunction modinv(a){for(var b=mod,u=1,v=0,t;b;v=t)t=a/b|0,a-=t*b,u-=t*v,t=a,a=b,b=t,t=u,u=v;u%=mod;return u<0?u+mod:u;}\nfunction nCrmod(n,r){return abmod(fac[n],modinv(abmod(fac[r],fac[n-r])));}\n\nconsole.log(main());\nfunction main(){\n  var n = o.a();\n  var m = o.a();\n  var m3 = 3*m;\n  fSet(m3+n);\n  var ans = 0;\n  var mx = Math.min(n,m);\n  for(var i = m&1; i <= mx; i += 2){\n    var j = m3-i >> 1;\n    var t = nCrmod(j+n-1,j);\n    t = abmod(t, nCrmod(n, i))\n    ans += t;\n  }\n  for(var i = 0; i < m; i++){\n    var t = abmod(n, nCrmod(i+n-2,i));\n    ans -= t;\n  }\n  ans %= mod;\n  ans += mod;\n  return ans % mod;\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n  \"bufio\"\n  \"os\"\n  \"strconv\"\n  \"strings\"\n  \"fmt\"\n)\n\nvar reader = bufio.NewReaderSize(os.Stdin, 1000000)\nvar writer = bufio.NewWriter(os.Stdout)\nfunc NextLine() string {\n  buffer := make([]byte, 0)\n  for true {\n    line, isPrefix, err := reader.ReadLine()\n    if err != nil { panic(err) }\n    buffer = append(buffer, line...)\n    if !isPrefix { break }\n  }\n  return string(buffer)\n}\nfunc NextInt(A ...*int) {\n  L := strings.Split(NextLine(), \" \")\n  for i, a := range A {\n    *a, _ = strconv.Atoi(L[i])\n  }\n}\nfunc NextIntVec(A *[]int) {\n  L := strings.Split(NextLine(), \" \")\n  (*A) = make([]int, len(L))\n  for i, l := range L {\n    (*A)[i], _ = strconv.Atoi(l)\n  }\n}\nfunc NextFloat(A ...*float64) {\n  L := strings.Split(NextLine(), \" \")\n  for i, a := range A {\n    *a, _ = strconv.ParseFloat(L[i], 64)\n  }\n}\nfunc NextFloatVec(A *[]float64) {\n  L := strings.Split(NextLine(), \" \")\n  (*A) = make([]float64, len(L))\n  for i, l := range L {\n    (*A)[i], _ = strconv.ParseFloat(l, 64)\n  }\n}\nfunc Write(s interface{}) {\n  fmt.Fprintln(writer, s)\n}\nfunc WriteIntVec(A []int) {\n  S := make([]string, len(A))\n  for i, a := range A {\n    S[i] = strconv.Itoa(a)\n  }\n  Write(strings.Join(S, \" \"))\n}\nfunc Output() {\n  _ = writer.Flush()\n}\n\nfunc MaxInt(A ...int) int {\n  max := A[0]\n  for _, a := range A {\n    if max < a { max = a }\n  }\n  return max\n}\nfunc MinInt(A ...int) int {\n  min := A[0]\n  for _, a := range A {\n    if a < min { min = a }\n  }\n  return min\n}\nfunc SumInt(A ...int) int {\n  sum := 0\n  for _, a := range A {\n    sum += a\n  }\n  return sum\n}\nfunc AbsInt(x int) int {\n  if x < 0 { x = -x }\n  return x\n}\n\nfunc Find(R *[]int, u int) int {\n  if (*R)[u] == u { return u }\n  (*R)[u] = Find(R, (*R)[u])\n  return (*R)[u]\n}\nfunc Union(R *[]int, u, v int) {\n  ru, rv := Find(R, u), Find(R, v)\n  if ru < rv {\n    (*R)[rv] = ru\n  } else if rv < ru {\n    (*R)[ru] = rv\n  }\n}\n\nfunc Bipartite(G [][]int, D []int, u int) bool {\n  D[u] = 0\n  Q := make([]int, 0)\n  Q = append(Q, u)\n  for 0 < len(Q) {\n    q := Q[0]\n    Q = Q[1:]\n    for _, adj := range G[q] {\n      if D[adj] < 0 {\n        D[adj] = 1 - D[q]\n        Q = append(Q, adj)\n      } else if D[q] == D[adj] {\n        return false\n      }\n    }\n  }\n  return true\n}\n\nfunc Factorial(N int) (F, Finv, Inv []int) {\n  F = make([]int, N + 1)\n  Finv = make([]int, N + 1)\n  Inv = make([]int, N + 1)\n  F[0] = 1\n  F[1] = 1\n  Finv[0] = 1\n  Finv[1] = 1\n  Inv[0] = 1\n  Inv[1] = 1\n  for i := 2; i < N + 1; i++ {\n    F[i] = F[i - 1] * i % p\n    Inv[i] = p - Inv[p % i] * (p / i) % p\n    Finv[i] = Finv[i - 1] * Inv[i] % p\n  }\n  return\n}\n\nfunc Comb(F, Finv *[]int, A ...int) int {\n  S := SumInt(A...)\n  C := (*F)[S]\n  for _, a := range A {\n    C *= (*Finv)[a]\n    C %= p\n  }\n  return C\n}\n\nconst p = 998244353\n\nfunc Solve() {\n  var N, M int\n  NextInt(&N, &M)\n  F, Finv, _ := Factorial(N + 3 * M / 2)\n  ans := 0\n  for i := M % 2; i <= MinInt(N, M); i += 2 {\n    ans += Comb(&F, &Finv, (3 * M - i) / 2, N - 1) * Comb(&F, &Finv, N - i, i) % p\n    ans %= p\n    ans += p - N * (Comb(&F, &Finv, (M - i) / 2, N - 1) * Comb(&F, &Finv, N - i, i) % p) % p\n    if i < N { ans += N * (Comb(&F, &Finv, (M - i) / 2, N - 2) * Comb(&F, &Finv, N - 1 - i, i) % p) % p }\n    ans %= p\n  }\n  Write(ans)\n}\n\nfunc main() {\n  Solve()\n  Output()\n}"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.complex, std.container, std.math, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nstruct ModInt(long M) {\n  long x;\n  this(in ModInt a) { x = a.x; }\n  this(in long a) { x = a % M; if (x < 0) x += M; }\n  ModInt opUnary(string op)() if (op == \"-\") { return ModInt(-x); }\n  ref ModInt opOpAssign(string op)(in ModInt a) {\n    static if (op == \"+\") { x += a.x; if (x >= M) x -= M; }\n    else static if (op == \"-\") { x -= a.x; if (x < 0) x += M; }\n    else static if (op == \"*\") { x *= a.x; x %= M; }\n    else static assert(false);\n    return this;\n  }\n  ModInt opOpAssign(string op)(in long a) { return mixin(\"this \" ~ op ~ \"= ModInt(a)\"); }\n  ModInt opBinary(string op, T)(in T a) const { return mixin(\"ModInt(this) \" ~ op ~ \"= a\"); }\n  ModInt opBinaryRight(string op)(in long a) const { return mixin(\"ModInt(a) \" ~ op ~ \"= this\"); }\n  string toString() const { return x.to!string; }\n}\n\n\nenum long MO = 998244353;\nalias Mint = ModInt!MO;\nenum LIM = 10^^7;\n\n\nlong[] inv, fac, invFac;\nvoid prepare() {\n  inv = new long[LIM];\n  fac = new long[LIM];\n  invFac = new long[LIM];\n  inv[1] = 1;\n  foreach (i; 2 .. LIM) {\n    inv[i] = MO - ((MO / i) * inv[cast(size_t)(MO % i)]) % MO;\n  }\n  fac[0] = invFac[0] = 1;\n  foreach (i; 1 .. LIM) {\n    fac[i] = (fac[i - 1] * i) % MO;\n    invFac[i] = (invFac[i - 1] * inv[i]) % MO;\n  }\n}\nlong binom(long n, long k) {\n  if (0 <= k && k <= n) {\n    assert(n < LIM);\n    return fac[cast(size_t)(n)] * invFac[cast(size_t)(k)] % MO * invFac[cast(size_t)(n - k)] % MO;\n  } else {\n    return 0;\n  }\n}\n\n\nlong N, M;\n\nvoid main() {\n  prepare();\n  \n  //*\n  debug {\n    {\n      enum n = 5, m = 2;\n      int[][] as;\n      foreach (p; 0 .. n^^(2 * m)) {\n        bool ok = true;\n        auto a = new int[n];\n        foreach (i; 0 .. m) {\n          const u = p / n^^(2 * i + 0) % n;\n          const v = p / n^^(2 * i + 1) % n;\n          ok = ok && (u != v);\n          a[u] += 2;\n          a[v] += 1;\n        }\n        if (ok) {\n          a.sort.reverse;\n          as ~= a;\n        }\n      }\n      as = as.sort.uniq.array;\n      foreach (a; as) {\n        writeln(a);\n      }\n    }\n  }\n  //*/\n  \n  try {\n    for (; ; ) {\n      N = readLong();\n      M = readLong();\n      \n      Mint ans;\n      for (long k = M % 2; k <= M; k += 2) {\n        {\n          const m = (3 * M - k) / 2;\n          Mint tmp = 1;\n          tmp *= binom(N + m - 1, m);\n          tmp *= binom(N, k);\n          debug {\n            if (M <= 5) {\n              writeln(k, \" \", m, \" \", tmp);\n            }\n          }\n          ans += tmp;\n        }\n        {\n          const m = (3 * M - k) / 2 - M;\n          if (m >= 0) {\n            Mint tmp = -1;\n            tmp *= N;\n            tmp *= binom((N - 1) + (m - 1), m);\n            tmp *= binom(N - 1, k - 1);\n            debug {\n              if (M <= 5) {\n                writeln(k, \" \", m, \" \", tmp);\n              }\n            }\n            ans += tmp;\n          }\n        }\n        {\n          const m = (3 * M - k) / 2 - (M + 1);\n          if (m >= 0) {\n            Mint tmp = -1;\n            tmp *= N;\n            tmp *= binom(N + m - 1, m);\n            tmp *= binom(N, k);\n            debug {\n              if (M <= 5) {\n                writeln(k, \" \", m, \" \", tmp);\n              }\n            }\n            ans += tmp;\n          }\n        }\n      }\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput=sys.stdin.readline\nN,M=map(int,input().split())\nmod=998244353\nA=N+M*3\nfactl=[1]*(A)\ninvl=[1]*(A)\nfv=1\nfor i in range(1,A):\n    fv=fv*i%mod\n    factl[i]=fv\n    invl[i]=pow(fv,mod-2,mod)\nans=factl[A-1]*invl[N-1]*invl[M*3]%mod\nNm=N-1\nfor i in range(M):\n    ans=(ans-factl[i+N-2]*invl[i]*invl[N-2]*N)%mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "class comb():\n  F = [1, 1]\n  Fi = [1, 1]\n  I = [0, 1]\n  def __init__(self, num, mod):\n    self.MOD = mod\n    for i in range(2, num + 1):\n      self.F.append((self.F[-1] * i) % mod)\n      self.I.append(mod - self.I[mod % i] * (mod // i) % mod)\n      self.Fi.append(self.Fi[-1] * self.I[i] % mod)\n  def com(self, n, k):\n    if n < k: return 0\n    if n < 0 or k < 0: return 0\n    return self.F[n] * (self.Fi[k] * self.Fi[n - k] % self.MOD) % self.MOD\n\n\nN, M = list(map(int, input().split()))\nMOD = 998244353\n\ncom = comb(M * 3 + N, MOD)\n\nt = com.com(M * 3 + N - 1, N - 1)\nt -= com.com(M - 1 + N - 1, N -1) * N\n\nwhile t < 0:\n  t += MOD\nif N > M:\n  for k in range(M + 2, N + 1, 2):\n    i = (M * 3 - k) // 2\n    t -= com.com(N, k) * com.com(N - 1 + i, i) % MOD\n  while t < 0:\n    t += MOD\n\nprint(t)"
  },
  {
    "language": "Python",
    "code": "n,m=map(int,input().split())\nw,u=3*m,n-1\no,f,i=998244353,[1],1\nwhile i<w+n:f+=[f[-1]*i%o];i+=1\nc=lambda n,k=u:f[n]*pow(f[n-k],o-2,o)*pow(f[k],o-2,o)\na=c(w+u)-n*c(n+m-2)\nwhile~-n>m<w:m+=2;a-=c(n,m)*c(2*u+w-m>>1)\nprint(a%o)"
  },
  {
    "language": "Python",
    "code": "import os\nimport sys\n\nimport numpy as np\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\n\ndef main():\n    sys.setrecursionlimit(2147483647)\n    INF = float(\"inf\")\n    IINF = 10 ** 18\n    MOD = 998244353\n\n    N, M = list(map(int, sys.stdin.readline().split()))\n\n    def get_factorials(max, mod=None):\n        \"\"\"\n        階乗 0!, 1!, 2!, ..., max!\n        :param int max:\n        :param int mod:\n        :return:\n        \"\"\"\n        ret = [1]\n        n = 1\n        if mod:\n            for i in range(1, max + 1):\n                n *= i\n                n %= mod\n                ret.append(n)\n        else:\n            for i in range(1, max + 1):\n                n *= i\n                ret.append(n)\n        return ret\n\n    def mod_invs(max, mod):\n        \"\"\"\n        逆元のリスト 0 から max まで\n        :param max:\n        :param mod:\n        :return:\n        \"\"\"\n        invs = [1] * (max + 1)\n        for x in range(2, max + 1):\n            invs[x] = (-(mod // x) * invs[mod % x]) % mod\n        return invs\n\n    factorials = np.array(get_factorials(M * 3 // 2 + N, MOD), dtype=int)\n    finvs = np.ones(M * 3 // 2 + N + 1, dtype=int)\n    p = 1\n    for i, inv in enumerate(mod_invs(M * 3 // 2 + N, MOD)):\n        p = p * inv % MOD\n        finvs[i] = p\n\n    def ncr(n, r, mod=None):\n        \"\"\"\n        scipy.misc.comb または scipy.special.comb と同じ\n        組み合わせの数 nCr\n        :param int n:\n        :param int r:\n        :param int mod: 3 以上の素数であること\n        :rtype: int\n        \"\"\"\n        ret = factorials[n] * finvs[r] % MOD * finvs[n - r] % mod\n        ret[n < r] = 0\n        return ret\n\n    # (1) 合計が M*3 で、奇数の数が M 以下である数列の数\n    odds = np.arange(M % 2, M + 1, 2)\n    halves = (M * 3 - odds) // 2\n\n    oc1 = ncr(N, odds, MOD)\n    oc2 = ncr(N - 1, odds, MOD)\n\n    # 合計が halfs の数列を 2 倍して、odds 個選んで 1 を足す\n    c1 = ncr(halves + N - 1, N - 1, MOD) * oc1 % MOD\n\n    # (2) max が M*2 より大きく、奇数の数が M 以下である数列の数\n    # => 合計が M で、1 要素目が 0 より大きい、奇数が M 以下である数列の数 * N\n    # 1 要素目に M*2 を足せば (2) になる\n    halves = (M - odds) // 2\n    # a. 合計が M で奇数が M 以下\n    c2a = ncr(halves + N - 1, N - 1, MOD) * oc1 % MOD\n    # c2a = c1\n    # b. 1 要素目が 0 である数列の数\n    c2b = ncr(halves + N - 2, N - 2, MOD) * oc2 % MOD\n\n    c2 = (c2a - c2b) * N % MOD\n    print((c1 - c2).sum() % MOD)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "o=998244353\nf=[1]\nfor i in range(1,2500100):f.append(f[-1]*i%o)\ndef c(n,k):return f[n]*pow(f[n-k],o-2,o)*pow(f[k],o-2,o)%o\nn,m=map(int,input().split())\nw=3*m\nu=n-1\na=c(w+u,u)-n*c(n+m-2,u)\nif u>m:\n for i in range(m+1,min(w,n)+1):\n  if w-i+1&1:a=(a-c(n,i)*c((w-i)//2+u,u))%o\nprint(a%o)"
  },
  {
    "language": "Python",
    "code": "n_ = 2500010\nmod = 998244353\n\ndef modinv(x, mod):\n    a, b = x, mod\n    u, v = 1, 0\n    while b:\n        t = a // b\n        a -= t * b; a, b = b, a\n        u -= t * v; u, v = v, u\n    return u % mod\n\nfun = [1] * (n_ + 1)\nfor i in range(1, n_ + 1):\n    fun[i] = fun[i - 1] * i % mod\nrev = [1] * (n_ + 1)\nrev[n_] = modinv(fun[n_], mod)\nfor i in range(n_ - 1, 0, -1):\n    rev[i] = rev[i + 1] * (i + 1) % mod\n\ndef nCr(n, r):\n    if r > n:\n        return 0\n    return fun[n] * rev[r] % mod * rev[n - r] % mod\n  \nn, m = map(int, input().split())\nans = 0\nfor i in range(m%2, min(m, n) + 1, 2):\n  ans = (ans + nCr(n, i) * (nCr((3*m-i)//2 + n - 1, n - 1) - \n      n * nCr((m-i)//2 + n - 1, n - 1))) % mod\nfor i in range(m%2, min(m, n-1) + 1, 2):\n  ans = (ans - (n - 1) * nCr(n-1, i) * nCr((m-i)//2 + n - 2, n - 2)) % mod\nprint(ans)\n  "
  },
  {
    "language": "Python",
    "code": "import sys\ninput=sys.stdin.readline\n\nN,M=map(int,input().split())\nmod=998244353\n\n#階乗テーブル\ng1=[1,1]\nfor i in range(2,3*M//2+N+2):\n    g1.append(g1[-1]*i%mod)\n\ndef cmb(n,r):\n    return g1[n]*pow(g1[r],mod-2,mod)*pow(g1[n-r],mod-2,mod)%mod\n\n#奇数の和で場合分け\n#iは奇数の数\n\nans=0\nfor i in range(min(N+1,M+1)):\n    if M%2!=i%2:\n        continue\n    m=(3*M-i)//2\n    num=(cmb(m+N-1,N-1)-i*cmb(m-M+N-1,N-1))%mod\n    if m>=M+1:\n        num=(num-(N-i)*cmb(m-M+N-2,N-1))%mod\n    ans=(ans+cmb(N,i)*num)%mod\n\nprint(ans)   "
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\nWriter: SPD_9X2\nhttps://atcoder.jp/contests/agc036/tasks/agc036_c\n\n可能性:\n3MをN個に分割する分け方から、存在しない分け方を引く\n\n存在しない分け方とは？\n→奇数個だけ置かれている場所の数がM個より多い場合\n\nk(M+1～N)までに関して、1をk箇所に分配し、その後2個ずつ好きな場所に分配する方法を数えればいい\n→解けたかな？\n\n→まだ駄目な条件が抜けてる\n最大値が2Mより大きいならダメ\n↑の部分で引いてないのは、奇数個置かれている場所はM個以下だが、最大値が2Mより大きい分け方…\n\n(k個の1のおき方) * {(1の中から2Mを超えるように置く場所の選び方)*残りの2の分配法}\n+ (k個の1のおき方) * {(0の中から2Mを超えるように置く場所の選び方)*残りの2の分配法}\n\nをk(0以上M以下に関して求める)\n\n→解けた！\n\"\"\"\n\ndef modfac(n, MOD):\n \n    f = 1\n    factorials = [1]\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n    return factorials, invs\n\n\ndef modnCr(n,r,mod,fac,inv): #上で求めたfacとinvsを引数に入れるべし(上の関数で与えたnが計算できる最大のnになる)\n    if n < r:\n        return 0\n    return fac[n] * inv[n-r] * inv[r] % mod\n\nmod = 998244353\nN,M = map(int,input().split())\n\nfac,inv = modfac(N+3*M+10,mod)\n\nans = modnCr(3*M+N-1,N-1,mod,fac,inv)\n#print (3*M+N-1,N-1,ans)\n\nfor k in range(M+1,N+1):\n\n    #print (k,ans)\n\n    if (3*M-k) % 2 == 0:\n        ans -= modnCr(N,k,mod,fac,inv) * modnCr((3*M-k)//2 + N-1 , N-1 , mod,fac,inv)\n        ans %= mod\n\nfor k in range(M+1):\n\n    if (3*M-k) % 2 == 0:\n        \n        amari = (3*M - (k+2*M))//2\n\n        now = modnCr(N,k,mod,fac,inv) * k * modnCr(amari+N-1,N-1, mod,fac,inv)\n\n        amari -= 1\n        now +=modnCr(N,k,mod,fac,inv)*(N-k)*modnCr(amari+N-1,N-1, mod,fac,inv)\n\n        ans -= now\n        ans %= mod\n\n    #print (ans)\n\nprint (ans)\n\n\n"
  },
  {
    "language": "Python",
    "code": "mod = 998244353\nfrac = [1]*3000000\nfor i in range(2,3000000):\n    frac[i] = i * frac[i-1]%mod\nfraci = [None]*3000000\nfraci[-1] = pow(frac[-1], mod -2, mod)\nfor i in range(-2, -3000000-1, -1):\n    fraci[i] = fraci[i+1] * (3000000+ i + 1) % mod\ndef comb(a, b):\n    if not a >= b >= 0:\n        return 0\n    return frac[a]*fraci[b]*fraci[a-b]%mod\n\n\nN, M = map(int, input().split())\nA = (comb(3*M+N-1, 3*M) - N*(comb(N+M-2, M-1)))%mod\nB = 0\nif N >= M+1:\n    for j in range(M+1, 3*M+1):\n        if (3*M-j)%2 == 1:\n            continue\n        k = (3*M-j)//2\n        B = (B+comb(N, j)*comb(k+N-1,k))%mod\n        \nprint((A-B)%mod)\n"
  },
  {
    "language": "Python",
    "code": "o,f,i=998244353,[1],1\nwhile i<o/399:f+=[f[-1]*i%o];i+=1\nc=lambda n,k:f[n]*pow(f[n-k],o-2,o)*pow(f[k],o-2,o)\nn,m=map(int,input().split())\nw,u,j=3*m,n-1,m+1\na=c(w+u,u)-n*c(n+m-2,u)\nif w-j&1:j+=1\nwhile j<=min(w,n):a-=c(n,j)*c((w-j)//2+u,u);j+=2\nprint(a%o)"
  },
  {
    "language": "Python",
    "code": "o=998244353\nr=2500100\nf=[1]\nfor i in range(1,r):\n f.append(f[-1]*i%o)\ndef v(x):\n return pow(x,o-2,o)\ndef c(n,k):\n return f[n]*v(f[n-k])*v(f[k])%o\nn,m=map(int,input().split())\nw=3*m\na=(c(n+w-1,n-1)-n*c(n+m-2,n-1))%o\nif n>m+1:\n for i in range(m+1,min(w,n)+1):\n  if (w-i)%2:continue\n  x=(w-i)//2\n  a=(a-c(n,i)*c(x+n-1,n-1))%o\nprint(a)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nU = 4*10**6\nMOD = 998244353\n \nfact = [1]*(U+1)\nfact_inv = [1]*(U+1)\n \nfor i in range(1,U+1):\n    fact[i] = (fact[i-1]*i)%MOD\nfact_inv[U] = pow(fact[U], MOD-2, MOD)\n \nfor i in range(U,0,-1):\n    fact_inv[i-1] = (fact_inv[i]*i)%MOD\n \ndef perm(n, k):\n    if k < 0 or k > n:\n        return 0\n    z = fact[n]\n    z *= fact_inv[n-k]\n    z %= MOD\n    return z\n\ndef comb(n, k):\n    if k < 0 or k > n:\n        return 0\n    z = fact[n]\n    z *= fact_inv[k]\n    z %= MOD\n    z *= fact_inv[n-k]\n    z %= MOD\n    return z\n\nn, m = map(int, input().split())\nans = 0\nfor k in range(m%2, min(n, m)+1, 2):\n  ans += comb((3*m-k)//2+n-1, n-1) * comb(n, k)\n  ans %= MOD\ncnt = 0\nfor k in range(m):\n  cnt += comb(k+n-2, n-2)\n  cnt %= MOD\ncnt *= n\ncnt %= MOD\nans -= cnt\nans %= MOD\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nimport math\nfrom bisect import bisect_left, bisect_right\nimport random\nfrom itertools import permutations, accumulate, combinations\nimport sys\nimport string\n\n\n\nINF = float('inf')\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return sys.stdin.readline().strip()\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\nmod = 998244353\n\n\nn, m = LI()\ntotal = m * 3\n\nfac = [1] * (total+n+1)\ninv = [1] * (total+n+1)\nfor i in range(total+n):\n    fac[i+1] = fac[i]*(i+1)%mod\n\ninv[total+n]=pow(fac[-1], mod-2, mod)\nfor j in range(total+n-1, -1, -1):\n    inv[j]=inv[j+1]*(j+1)%mod\n\n\n\ndef comb(n, r):\n    if r > n:\n        return 0\n    return fac[n] * inv[n - r] * inv[r] % mod\n\n\nans = comb(total+n-1, n-1)\nfor i in range(m + 2, min(n + 1, total + 1)):\n    if (total - i) % 2 == 0:\n        ans -= comb(n, i) * comb(n + (total - i) // 2 - 1, n - 1) % mod\n        ans %= mod\n\n\nret = 0\nfor i in range(m):\n    ret = (ret + comb(i + n - 2, n - 2)) % mod\n\n\nans -= (ret * n) % mod\nprint(ans % mod)"
  },
  {
    "language": "Python",
    "code": "o=998244353\nr=2500100\nf=[1]\nfor i in range(1,r):f.append(f[-1]*i%o)\ndef c(n,k):return f[n]*pow(f[n-k],o-2,o)*pow(f[k],o-2,o)%o\nn,m=map(int,input().split())\nw=3*m\na=(c(n+w-1,n-1)-n*c(n+m-2,n-1))%o\nif n>m+1:\n for i in range(m+1,min(w,n)+1):\n  if w-i&1:continue\n  a=(a-c(n,i)*c((w-i)//2+n-1,n-1))%o\nprint(a)"
  },
  {
    "language": "Python",
    "code": "o=998244353\nf=[1]\nfor i in range(1,2500100):f.append(f[-1]*i%o)\ndef c(n,k):return f[n]*pow(f[n-k],o-2,o)*pow(f[k],o-2,o)%o\nn,m=map(int,input().split())\nw=3*m\nu=n-1\na=c(w+u,u)-n*c(n+m-2,u)\nif u&gt;m:\n for i in range(m+1,min(w,n)+1):\n  if w-i+1&amp;1:a=(a-c(n,i)*c((w-i)//2+u,u))%o\nprint(a%o)"
  },
  {
    "language": "Python",
    "code": "import os\nimport sys\n\nimport numpy as np\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 998244353\n\nN, M = list(map(int, sys.stdin.readline().split()))\n\n\ndef get_factorials(max, mod=None):\n    \"\"\"\n    階乗 0!, 1!, 2!, ..., max!\n    :param int max:\n    :param int mod:\n    :return:\n    \"\"\"\n    ret = [1]\n    n = 1\n    if mod:\n        for i in range(1, max + 1):\n            n *= i\n            n %= mod\n            ret.append(n)\n    else:\n        for i in range(1, max + 1):\n            n *= i\n            ret.append(n)\n    return ret\n\n\ndef mod_invs(max, mod):\n    \"\"\"\n    逆元のリスト 0 から max まで\n    :param max:\n    :param mod:\n    :return:\n    \"\"\"\n    invs = [1] * (max + 1)\n    for x in range(2, max + 1):\n        invs[x] = (-(mod // x) * invs[mod % x]) % mod\n    return invs\n\n\nfactorials = np.array(get_factorials(M * 3 // 2 + N, MOD), dtype=int)\nfinvs = []\ninv = 1\nfor i in mod_invs(M * 3 // 2 + N, MOD):\n    inv = inv * i % MOD\n    finvs.append(inv)\nfinvs = np.array(finvs, dtype=int)\n\n\ndef ncr(n, r, mod=None):\n    \"\"\"\n    scipy.misc.comb または scipy.special.comb と同じ\n    組み合わせの数 nCr\n    :param int n:\n    :param int r:\n    :param int mod: 3 以上の素数であること\n    :rtype: int\n    \"\"\"\n    ret = factorials[n] * finvs[r] % MOD * finvs[n - r] % mod\n    ret[n < r] = 0\n    return ret\n\n\n# (1) 合計が M*3 で、奇数の数が M 以下である数列の数\nodds = np.arange(M % 2, M + 1, 2)\nhalves = (M * 3 - odds) // 2\n\noc1 = ncr(N, odds, MOD)\noc2 = ncr(N - 1, odds, MOD)\n\n# 合計が halfs の数列を 2 倍して、odds 個選んで 1 を足す\nc1 = ncr(halves + N - 1, N - 1, MOD) * oc1 % MOD\n\n# (2) max が M*2 より大きく、奇数の数が M 以下である数列の数\n# => 合計が M で、1 要素目が 0 より大きい、奇数が M 以下である数列の数 * N\n# 1 要素目に M*2 を足せば (2) になる\nhalves = (M - odds) // 2\n# a. 合計が M で奇数が M 以下\nc2a = ncr(halves + N - 1, N - 1, MOD) * oc1 % MOD\n# c2a = c1\n# b. 1 要素目が 0 である数列の数\nc2b = ncr(halves + N - 2, N - 2, MOD) * oc2 % MOD\n\nc2 = (c2a - c2b) * N % MOD\nprint((c1 - c2).sum() % MOD)\n"
  },
  {
    "language": "Python",
    "code": "o,f,i=998244353,[1],1\nwhile i<2500100:f.append(f[-1]*i%o);i+=1\nc=lambda n,k:f[n]*pow(f[n-k],o-2,o)*pow(f[k],o-2,o)\nn,m=map(int,input().split())\nw,u=3*m,n-1\na=c(w+u,u)-n*c(n+m-2,u)\nif u>m:\n for i in range(m+1,min(w,n)+1):\n  if w-i+1&1:a-=c(n,i)*c((w-i)//2+u,u) \nprint(a%o)"
  },
  {
    "language": "Python",
    "code": "N, M = map(int, input().split())\n\nmod = 998244353\ndef cmb(n, r, mod=mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nNN = 10**6 # 使うデータによって変える\ng1 = [1, 1] # 元テーブル\ng2 = [1, 1] #逆元テーブル\ninverse = [0, 1] #逆元テーブル計算用テーブル\n\nfor i in range( 2, NN + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\n\nA = []\ntmp = 0\nfor i in range(3*M+N+2):\n    tmp = (tmp + cmb(N-2+i, N-2)) % mod\n    A.append(tmp)\n\nans = 0\nfor k in range(min(N, M)+1):\n    if (M-k) % 2 != 0: continue\n    l = (3*M-k)//2\n    a = cmb(N-1+l, N-1) * cmb(N, k)\n    b = N * (cmb(N-1, k-1)*A[l-M])\n    if l >= M+1:\n        b += N * cmb(N-1, k)*A[l-M-1]\n    #print(k,a-b)\n    ans = (ans + a - b) % mod \nprint(ans)\n\n# C = set()\n# def calc(d, A):\n#     if d == M:\n#         t = \"\"\n#         for a in A:\n#             t += str(a)\n#         C.add(t)\n#         return\n#     for i in range(N):\n#         for j in range(N):\n#             if i == j: continue\n#             B = A[:]\n#             B[i] += 2\n#             B[j] += 1\n#             calc(d+1, B)\n#     return\n\n#calc(0, [0]*N)\n#print(len(C))\n#print(C)\n"
  },
  {
    "language": "Python",
    "code": "mod=998244353\nimport math\n\ndef f(n):\n  return math.factorial(n)\n\ndef c(n,k):\n  return f(n)//(f(n-k)*f(k))\nn,m=map(int,input().split())\n\nans=c(3*m+n-1,n-1)\nfor i in range(1,m+1):\n  ans-=c(3*m-(2*m+i)+n-2,n-2)\nprint(ans%mod)"
  },
  {
    "language": "Python",
    "code": "o = 998244353\nr = 2500100\nf = [1]\nfor i in range(1,r):\n f.append(f[-1]*i%o)\ndef v(x):\n return pow(x,o-2,o)\ndef c(n,k):\n return f[n]*v(f[n-k])*v(f[k])%o\nn,m = map(int,input().split())\na = (c(n+3*m-1,n-1)-n*c(n+m-2,n-1))%o\nif n>m+1:\n for i in range(m+1,min(3*m,n)+1):\n  if (3*m-i)%2:continue\n  x = (3*m-i)//2\n  a = (a-c(n,i)*c(x+n-1,n-1))%o\nprint(a)"
  },
  {
    "language": "Python",
    "code": "from functools import lru_cache\n\n\ndef prepare(n, MOD):\n    f = 1\n    factorials = [1]\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n\n    return factorials, invs\n\n\ndef get_nhr(n, facts, invs):\n    @lru_cache(maxsize=None)\n    def nhr(r):\n        return facts[n + r - 1] * invs[r] * invs[n - 1] % MOD\n\n    return nhr\n\n\nMOD = 998244353\nn, m = list(map(int, input().split()))\nfacts, invs = prepare(n + 3 * m, MOD)\nnhr = get_nhr(n, facts, invs)\nans = 0\nfor odd in range(m % 2, min(m, n) + 1, 2):\n    tmp = nhr((3 * m - odd) // 2)\n    if odd > 0:\n        tmp -= odd * nhr((m - odd) // 2)\n    if odd < n and odd <= m - 2:\n        tmp -= (n - odd) * nhr((m - odd - 2) // 2)\n    ans = (ans + facts[n] * invs[odd] * invs[n - odd] % MOD * tmp) % MOD\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "o=998244353\nf=[1]\nfor i in range(1,2500100):f.append(f[-1]*i%o)\ndef c(n,k):return f[n]*pow(f[n-k],o-2,o)*pow(f[k],o-2,o)\nn,m=map(int,input().split())\nw=3*m\nu=n-1\na=c(w+u,u)-n*c(n+m-2,u)\nif u>m:\n for i in range(m+1,min(w,n)+1):\n  if w-i+1&1:a-=c(n,i)*c((w-i)//2+u,u)\nprint(a%o)"
  },
  {
    "language": "Python",
    "code": "import os\nimport sys\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 998244353\n\nN, M = list(map(int, sys.stdin.readline().split()))\n\n\ndef get_factorials(max, mod=None):\n    \"\"\"\n    階乗 0!, 1!, 2!, ..., max!\n    :param int max:\n    :param int mod:\n    :return:\n    \"\"\"\n    ret = [1]\n    n = 1\n    if mod:\n        for i in range(1, max + 1):\n            n *= i\n            n %= mod\n            ret.append(n)\n    else:\n        for i in range(1, max + 1):\n            n *= i\n            ret.append(n)\n    return ret\n\n\ndef mod_invs(max, mod):\n    \"\"\"\n    逆元のリスト 0 から max まで\n    :param max:\n    :param mod:\n    :return:\n    \"\"\"\n    invs = [1] * (max + 1)\n    for x in range(2, max + 1):\n        invs[x] = (-(mod // x) * invs[mod % x]) % mod\n    return invs\n\n\nfactorials = get_factorials(M * 3 // 2 + N, MOD)\nfinvs = []\ninv = 1\nfor i in mod_invs(M * 3 // 2 + N, MOD):\n    inv = inv * i % MOD\n    finvs.append(inv)\n\n\ndef ncr(n, r, mod=None):\n    \"\"\"\n    scipy.misc.comb または scipy.special.comb と同じ\n    組み合わせの数 nCr\n    :param int n:\n    :param int r:\n    :param int mod: 3 以上の素数であること\n    :rtype: int\n    \"\"\"\n    if n < r:\n        return 0\n\n    # return factorials[n] * mod_inv(factorials[r], mod) * mod_inv(factorials[n - r], mod) % mod\n    return factorials[n] * finvs[r] * finvs[n - r] % mod\n\n\n# 合計が M*3 となる数列の数\n# c1 = ncr(M * 3 + N - 1, N - 1, MOD)\n# (1) 合計が M*3 で、奇数の数が M 以下である数列の数\nc1 = 0\nfor odds in range(M * 3 % 2, M + 1, 2):\n    half = (M * 3 - odds) // 2\n    # 合計が half の数列を 2 倍して、odds 個選んで 1 を足す\n    c1 += ncr(half + N - 1, N - 1, MOD) * ncr(N, odds, MOD)\n    c1 %= MOD\n\n# (2) max が M*2 より大きく、奇数の数が M 以下である数列の数\n# c2 = 0\n# for mx in range(M * 2 + 1, M * 3 + 1):\n#     rem = M * 3 - mx\n#     oddmax = M if mx % 2 == 0 else M - 1\n#     for odds in range(rem % 2, min(oddmax, rem) + 1, 2):\n#         half = (rem - odds) // 2\n#         c2 += ncr(half + N - 2, N - 2, MOD) * ncr(N - 1, odds, MOD) * N\n#         c2 %= MOD\n# print((c1 - c2) % MOD)\n\n\n# (2) max が M*2 より大きく、奇数の数が M 以下である数列の数\n# => 合計が M で、1 要素目が 0 より大きい、奇数が M 以下である数列の数 * N\n# 1 要素目に M*2 を足せば (2) になる\n# a. 合計が M で奇数が M 以下\nc2a = 0\n# b. 1 要素目が 0 である数列の数\nc2b = 0\nfor odds in range(M % 2, M + 1, 2):\n    half = (M - odds) // 2\n    c2a += ncr(half + N - 1, N - 1, MOD) * ncr(N, odds, MOD)\n    c2a %= MOD\n    c2b += ncr(half + N - 2, N - 2, MOD) * ncr(N - 1, odds, MOD)\n    c2b %= MOD\n\nc2 = (c2a - c2b) * N\nprint((c1 - c2) % MOD)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput=sys.stdin.readline\nN,M=map(int,input().split())\nmod=998244353\n\ninv=[0]*(3*M//2+N+2)\ninv[1]=1\nfor i in range(2,3*M//2+N+2):\n    inv[i]=-(mod//i)*inv[mod%i]%mod\n\n#階乗テーブル\ng1=[1,1]\ng2=[1,1]\nfor i in range(2,3*M//2+N+2):\n    num_1=g1[-1]*i%mod\n    g1.append(num_1)\n    g2.append(g2[-1]*inv[i]%mod)\n    \ndef cmb(n,r):\n    return g1[n]*g2[r]*g2[n-r]%mod\n\n#奇数の和で場合分け\n#iは奇数の数\n\nans=0\nfor i in range(min(N+1,M+1)):\n    if M%2!=i%2:\n        continue\n    m=(3*M-i)//2\n    num=(cmb(m+N-1,N-1)-i*cmb(m-M+N-1,N-1))%mod\n    if m>=M+1:\n        num=(num-(N-i)*cmb(m-M+N-2,N-1))%mod\n    ans=(ans+cmb(N,i)*num)%mod\n\nprint(ans)    "
  },
  {
    "language": "Python",
    "code": "import sys\ninput=sys.stdin.readline\nN,M=map(int,input().split())\nmod=998244353\nfactl=[1]\ninvl=[1]\nfv=1\nfor i in range(1,N+M*3):\n    fv=fv*i%mod\n    factl.append(fv)\n    invl.append(pow(fv,mod-2,mod))\nans=factl[N+M*3-1]*invl[N-1]*invl[M*3]%mod\nnc2=factl[N]*invl[N-2]*invl[2]%mod\nans=(ans-N-2*nc2*(M-1))%mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "N, M = map(int, input().split())\nmod = 998244353\ndef inved(x):\n  y = 1\n  p = mod - 2\n  base = x\n  while p != 0:\n    if p % 2 == 1:\n      y *= base\n      y %= mod\n    base *= base\n    base %= mod\n    p //= 2\n  return y\n\nfact = [1 for i in range(3*M+N)]\ninvf = [1 for i in range(3*M+N)]\nfor i in range(3*M+N-1):\n  fact[i+1] = (fact[i] * (i+1)) % mod\ninvf[-1] = inved(fact[-1])\nfor i in range(3*M+N-1, 0, -1):\n  invf[i-1] = (invf[i] * i) % mod\n  \nL = (fact[3*M+N-1] * invf[N-1] * invf[3*M]) % mod\nR = (N * fact[M+N-2] * invf[N-1] * invf[M-1]) % mod\n\nprint((L - R) % mod)"
  },
  {
    "language": "Python",
    "code": "import os\nimport sys\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 998244353\n\nN, M = list(map(int, sys.stdin.readline().split()))\n\n\ndef get_factorials(max, mod=None):\n    \"\"\"\n    階乗 0!, 1!, 2!, ..., max!\n    :param int max:\n    :param int mod:\n    :return:\n    \"\"\"\n    ret = [1]\n    n = 1\n    if mod:\n        for i in range(1, max + 1):\n            n *= i\n            n %= mod\n            ret.append(n)\n    else:\n        for i in range(1, max + 1):\n            n *= i\n            ret.append(n)\n    return ret\n\n\nfactorials = get_factorials(M * 3 + N - 1, MOD)\n\n\ndef mod_inv(a, mod):\n    \"\"\"\n    a の逆元\n    :param int a:\n    :param int mod:\n    :return:\n    \"\"\"\n    return pow(a, mod - 2, mod)\n\n\ndef ncr(n, r, mod=None):\n    \"\"\"\n    scipy.misc.comb または scipy.special.comb と同じ\n    組み合わせの数 nCr\n    :param int n:\n    :param int r:\n    :param int mod: 3 以上の素数であること\n    :rtype: int\n    \"\"\"\n    if n < r:\n        return 0\n\n    return factorials[n] * mod_inv(factorials[r], mod) * mod_inv(factorials[n - r], mod) % mod\n\n\n# 合計が M*3 となる数列の数\n# c1 = ncr(M * 3 + N - 1, N - 1, MOD)\n# (1) 合計が M*3 で、奇数の数が M 以下である数列の数\nc1 = 0\nfor odds in range(M * 3 % 2, M + 1, 2):\n    half = (M * 3 - odds) // 2\n    # 合計が half の数列を 2 倍して、odds 個選んで 1 を足す\n    c1 += ncr(half + N - 1, N - 1, MOD) * ncr(N, odds, MOD)\n    c1 %= MOD\n\n# (2) max が M*2 より大きく、奇数の数が M 以下である数列の数\n# c2 = 0\n# for mx in range(M * 2 + 1, M * 3 + 1):\n#     rem = M * 3 - mx\n#     oddmax = M if mx % 2 == 0 else M - 1\n#     for odds in range(rem % 2, min(oddmax, rem) + 1, 2):\n#         half = (rem - odds) // 2\n#         c2 += ncr(half + N - 2, N - 2, MOD) * ncr(N - 1, odds, MOD) * N\n#         c2 %= MOD\n# print((c1 - c2) % MOD)\n\n\n# (2) max が M*2 より大きく、奇数の数が M 以下である数列の数\n# => 合計が M で、1 要素目が 0 より大きい、奇数が M 以下である数列の数 * N\n# 1 要素目に M*2 を足せば (2) になる\n# a. 合計が M で奇数が M 以下\nc2a = 0\n# b. 1 要素目が 0 である数列の数\nc2b = 0\nfor odds in range(M % 2, M + 1, 2):\n    half = (M - odds) // 2\n    c2a += ncr(half + N - 1, N - 1, MOD) * ncr(N, odds, MOD)\n    c2a %= MOD\n    c2b += ncr(half + N - 2, N - 2, MOD) * ncr(N - 1, odds, MOD)\n    c2b %= MOD\n\nc2 = (c2a - c2b) * N\nprint((c1 - c2) % MOD)\n"
  },
  {
    "language": "Python",
    "code": "n,m=map(int,input().split())\nw,u=3*m,n-1\no,f,i=998244353,[1],1\nwhile i<w+n:f+=[f[-1]*i%o];i+=1\nc=lambda n,k:f[n]*pow(f[n-k],o-2,o)*pow(f[k],o-2,o)\na=c(w+u,u)-n*c(n+m-2,u)\nwhile n>-~m<w:m+=2;a-=c(n,m)*c(2*u+w-m>>1,u)\nprint(a%o)"
  },
  {
    "language": "Python",
    "code": "N, M = map(int, input().split())\n\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 998244353\nn = 10**6*3\ng1 = [1, 1]\ng2 = [1, 1] #逆元テーブル\ninverse = [0, 1] #逆元テーブル計算用テーブル\n\nfor i in range( 2, n + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nans = cmb(M*3+N-1, N-1, mod)\nfor i in range(M*2+1, M*3+1):\n    ans -= cmb(M*3-i+(N-1)-1, N-2, mod) * N - mod*mod\n    ans = (ans+mod)%mod\n\nfor i in range(M+1, min(N, 3*M)+1):\n    if (3*M - i) % 2 == 0:\n        two = (3*M - i) // 2\n        ans -= cmb(two+N-1, N-1, mod) * cmb(N, i, mod) - mod*mod\n        ans = (ans+mod)%mod\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\n\n#A\ndef A():\n    n = I()\n    if n <= 1000000000:\n        print(0,0,1,0,0,n)\n    else:\n        b = math.ceil(n**0.5)\n        if b**2 == n:\n            print(0,0,b,0,0,n//b)\n            return\n        x = b\n        m = b*x-n\n        if m < 0:\n            b += 1\n            x += 1\n            m = b*x-n\n        n = m\n        for a in range(int(n**0.5)+1)[::-1]:\n            if n%a == 0:\n                print(0,0,x,n//a,a,b)\n                return\n\n    return\n\n#B\ndef B():\n    n,k = LI()\n    a = LI()\n    s = []\n    f = [1]*1000000\n    for i in range(k):\n        for j in range(n):\n            aj = a[j]\n            if f[aj]:\n                s.append(aj)\n                f[aj] = 0\n            else:\n                while 1:\n                    x = s.pop(-1)\n                    f[x] = 1\n                    if x == aj:\n                        break\n        print(i+1,s)\n    return\n\n#C\nmod = 998244353\ndef C():\n    def comb(a,b):\n        if a < b:\n            return 1\n        return fact[a]*inv[b]*inv[a-b]%mod\n    n,m = LI()\n    MA = 3*m+max(n,2*m)-1\n    fact = [1]*(MA+1)\n    for i in range(MA):\n        fact[i+1] = fact[i]*(i+1)%mod\n    inv = [1]*(MA+1)\n    inv[MA] = pow(fact[MA],mod-2,mod)\n    for i in range(MA)[::-1]:\n        inv[i] = inv[i+1]*(i+1)%mod\n    ans = 0\n    for k in range(min(m,n)+1):\n        if (3*m-k)%2 == 0:\n            ans += comb(n,k)*comb((3*m-k)//2+n-1,n-1)\n            ans %= mod\n    ans -= n*comb(3*m-(2*m+1)+n-1,n-1)\n    ans %= mod\n    print(ans)\n\n    return\n\n#D\ndef D():\n    return\n\n#E\ndef E():\n    n = I()\n\n    return\n\n#F\ndef F():\n    n = I()\n\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    C()\n"
  },
  {
    "language": "Python",
    "code": "import os\nimport sys\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 998244353\n\nN, M = list(map(int, sys.stdin.readline().split()))\n\n\ndef get_factorials(max, mod=None):\n    \"\"\"\n    階乗 0!, 1!, 2!, ..., max!\n    :param int max:\n    :param int mod:\n    :return:\n    \"\"\"\n    ret = [1]\n    n = 1\n    if mod:\n        for i in range(1, max + 1):\n            n *= i\n            n %= mod\n            ret.append(n)\n    else:\n        for i in range(1, max + 1):\n            n *= i\n            ret.append(n)\n    return ret\n\n\ndef mod_invs(max, mod):\n    \"\"\"\n    逆元のリスト 0 から max まで\n    :param max:\n    :param mod:\n    :return:\n    \"\"\"\n    invs = [1] * (max + 1)\n    for x in range(2, max + 1):\n        invs[x] = (-(mod // x) * invs[mod % x]) % mod\n    return invs\n\n\nfactorials = get_factorials(M * 3 // 2 + N, MOD)\nfinvs = []\ninv = 1\nfor i in mod_invs(M * 3 // 2 + N, MOD):\n    inv = inv * i % MOD\n    finvs.append(inv)\n\n\ndef ncr(n, r, mod=None):\n    \"\"\"\n    scipy.misc.comb または scipy.special.comb と同じ\n    組み合わせの数 nCr\n    :param int n:\n    :param int r:\n    :param int mod: 3 以上の素数であること\n    :rtype: int\n    \"\"\"\n    if n < r:\n        return 0\n\n    # return factorials[n] * mod_inv(factorials[r], mod) * mod_inv(factorials[n - r], mod) % mod\n    return factorials[n] * finvs[r] * finvs[n - r] % mod\n\n\n# 合計が M*3 となる数列の数\n# c1 = ncr(M * 3 + N - 1, N - 1, MOD)\n# (1) 合計が M*3 で、奇数の数が M 以下である数列の数\nc1 = 0\nfor odds in range(M * 3 % 2, M + 1, 2):\n    half = (M * 3 - odds) // 2\n    # 合計が half の数列を 2 倍して、odds 個選んで 1 を足す\n    c1 += ncr(half + N - 1, N - 1, MOD) * ncr(N, odds, MOD)\n    c1 %= MOD\n\n# (2) max が M*2 より大きく、奇数の数が M 以下である数列の数\n# c2 = 0\n# for mx in range(M * 2 + 1, M * 3 + 1):\n#     rem = M * 3 - mx\n#     oddmax = M if mx % 2 == 0 else M - 1\n#     for odds in range(rem % 2, min(oddmax, rem) + 1, 2):\n#         half = (rem - odds) // 2\n#         c2 += ncr(half + N - 2, N - 2, MOD) * ncr(N - 1, odds, MOD) * N\n#         c2 %= MOD\n# print((c1 - c2) % MOD)\n\n\n# (2) max が M*2 より大きく、奇数の数が M 以下である数列の数\n# => 合計が M で、1 要素目が 0 より大きい、奇数が M 以下である数列の数 * N\n# 1 要素目に M*2 を足せば (2) になる\n# a. 合計が M で奇数が M 以下\nc2a = 0\n# b. 1 要素目が 0 である数列の数\nc2b = 0\nfor odds in range(M % 2, M + 1, 2):\n    half = (M - odds) // 2\n    c2a += ncr(half + N - 1, N - 1, MOD) * ncr(N, odds, MOD)\n    c2a %= MOD\n    c2b += ncr(half + N - 2, N - 2, MOD) * ncr(N - 1, odds, MOD)\n    c2b %= MOD\n\nc2 = (c2a - c2b) * N\nprint((c1 - c2) % MOD)\n"
  },
  {
    "language": "Python",
    "code": "o,f,i=998244353,[1],1\nwhile i<o/399:f+=[f[-1]*i%o];i+=1\nc=lambda n,k:f[n]*pow(f[n-k],o-2,o)*pow(f[k],o-2,o)\nn,m=map(int,input().split())\nw,u=3*m,n-1\na=c(w+u,u)-n*c(n+m-2,u)\nif u>m:\n for i in range(m+1,min(w,n)+1):\n  if w-i+1&1:a-=c(n,i)*c((w-i)//2+u,u) \nprint(a%o)"
  },
  {
    "language": "Python",
    "code": "n,m=map(int,input().split())\nw,u=3*m,n-1\no,f,i=998244353,[1],1\nwhile i<w+n:f+=[f[-1]*i%o];i+=1\nc=lambda n,k:f[n]*pow(f[n-k],o-2,o)*pow(f[k],o-2,o)\na=c(w+u,u)-n*c(n+m-2,u)\nwhile-~m<min(w,n):m+=2;a-=c(n,m)*c(2*u+w-m>>1,u)\nprint(a%o)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nimport math\nimport bisect\nimport random\nfrom itertools import permutations, accumulate, combinations, product\nimport sys\nfrom pprint import pprint\nfrom copy import deepcopy\nimport string\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial, ceil, floor\nfrom operator import mul\nfrom functools import reduce\nfrom pprint import pprint\n\n\nsys.setrecursionlimit(2147483647)\nINF = 10 ** 15\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\ndef I(): return int(sys.stdin.buffer.readline())\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\nmod = 998244353\n\nn, m = LI()\na = n + 3 * m\nfac = [1] * (a + 1)\ninv = [1] * (a + 1)\nfor j in range(1, a + 1):\n    fac[j] = fac[j-1] * j % mod\n\ninv[a] = pow(fac[a], mod-2, mod)\nfor j in range(a-1, -1, -1):\n    inv[j] = inv[j+1] * (j+1) % mod\n\ndef comb(x, y):\n    if y > x or x < 0 or y < 0:\n        return 0\n    return fac[x] * inv[x - y] * inv[y] % mod\n\nans = 0\nfor i in range(min(m + 1, n + 1)):\n    if (m - i) % 2:\n        continue\n    ans += comb(n, i) * comb((m * 3 - i) // 2 + n - 1, n - 1)\n    ans %= mod\n\nprint((ans - n * comb(m - 1 + n - 1, n - 1)) % mod)"
  },
  {
    "language": "Python",
    "code": "P = 998244353\nfa = [1]\nfor i in range(1, 3000100):\n    fa.append(fa[-1]*i%P)\nfainv = [pow(fa[-1], P-2, P)%P]\nfor i in range(1, 3000100)[::-1]:\n    fainv.append(fainv[-1]*i%P)\nfainv = fainv[::-1]\n\ndef C(a, b):\n    return fa[a]*fainv[a-b]*fainv[b]%P\n\nN, M = map(int, input().split())\nif N == 2:\n    print(M+1)\nelse:\n    ans = C(3*M+N-1, N-1)\n    for K in range(2*M+1, 3*M+1):\n        ans = (ans - N*C(3*M-K+N-2, N-2)) % P\n    for K in range(M):\n        if 3*M-K*2 <= N:\n            ans = (ans - C(K+N-1, N-1)*C(N, 3*M-K*2)) % P\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "o=998244353\nr=2500100\nf=[1]\nfor i in range(1,r):f.append(f[-1]*i%o)\ndef v(x):return pow(x,o-2,o)\ndef c(n,k):return f[n]*v(f[n-k])*v(f[k])%o\nn,m=map(int,input().split())\nw=3*m\na=(c(n+w-1,n-1)-n*c(n+m-2,n-1))%o\nif n>m+1:\n for i in range(m+1,min(w,n)+1):\n  if (w-i)%2:continue\n  x=(w-i)//2\n  a=(a-c(n,i)*c(x+n-1,n-1))%o\nprint(a)"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\nMOD = 998244353\n\n\ndef inverse(a,p):\n    return pow(a,p-2,p)\n\n\ndata = [1,1]\nappend = data.append\nq = 1\nfor i in range(2,3*m+n):\n    q*=i\n    q%=MOD\n    append(q)\n\n\nans = data[3*m+n-1]*inverse(data[n-1],MOD)*inverse(data[3*m],MOD)\nans %=MOD\nfor i in range(m):\n    ans -= data[n-2+i]*inverse(data[n-2],MOD)*inverse(data[i],MOD)*n\n    ans %=MOD\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\n\n#A\ndef A():\n    n = I()\n    if n <= 1000000000:\n        print(0,0,1,0,0,n)\n    else:\n        b = 1000000000\n        a = 1\n        y = -n%1000000000\n        x = (n+a*y)//b\n        print(0,0,x,y,a,b)\n        return\n\n    return\n\n#B\ndef B():\n    n,k = LI()\n    a = LI()\n    s = []\n    f = [1]*1000000\n    for i in range(k):\n        for j in range(n):\n            aj = a[j]\n            if f[aj]:\n                s.append(aj)\n                f[aj] = 0\n            else:\n                while 1:\n                    x = s.pop(-1)\n                    f[x] = 1\n                    if x == aj:\n                        break\n        print(i+1,s)\n    return\n\n#C\nmod = 998244353\ndef C():\n    def comb(a,b):\n        if a < b:\n            return 1\n        return fact[a]*inv[b]*inv[a-b]%mod\n    n,m = LI()\n    MA = 3*m+max(n,2*m)-1\n    fact = [1]*(MA+1)\n    for i in range(MA):\n        fact[i+1] = fact[i]*(i+1)%mod\n    inv = [1]*(MA+1)\n    inv[MA] = pow(fact[MA],mod-2,mod)\n    for i in range(MA)[::-1]:\n        inv[i] = inv[i+1]*(i+1)%mod\n    ans = 0\n    for k in range(min(m,n)+1):\n        if (3*m-k)%2 == 0:\n            ans += comb(n,k)*comb((3*m-k)//2+n-1,n-1) #奇数の数がk個かつ総和が3mとなるパターンの総数(n個のうちk個に1を割り振る→総和が3m-kとなるパターンの総数を求める)\n            ans %= mod\n    ans -= n*comb(3*m-(2*m+1)+n-1,n-1)\n    ans %= mod\n    print(ans)\n\n    return\n\n#D\ndef D():\n    return\n\n#E\ndef E():\n    n = I()\n\n    return\n\n#F\ndef F():\n    n = I()\n\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    C()\n"
  },
  {
    "language": "Python",
    "code": "import os\nimport sys\n\nimport numpy as np\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 998244353\n\nN, M = list(map(int, sys.stdin.readline().split()))\n\n\ndef get_factorials(max, mod=None):\n    \"\"\"\n    階乗 0!, 1!, 2!, ..., max!\n    :param int max:\n    :param int mod:\n    :return:\n    \"\"\"\n    ret = np.ones(max + 1, dtype=int)\n    n = 1\n    for i in range(1, max + 1):\n        n *= i\n        n %= mod\n        ret[i] = n\n    return ret\n\n\ndef mod_invs(max, mod):\n    \"\"\"\n    逆元のリスト 0 から max まで\n    :param max:\n    :param mod:\n    :return:\n    \"\"\"\n    invs = [1] * (max + 1)\n    for x in range(2, max + 1):\n        invs[x] = (-(mod // x) * invs[mod % x]) % mod\n    return invs\n\n\nfactorials = get_factorials(M * 3 // 2 + N, MOD)\nfinvs = np.ones(M * 3 // 2 + N + 1, dtype=int)\np = 1\nfor i, inv in enumerate(mod_invs(M * 3 // 2 + N, MOD)):\n    p = p * inv % MOD\n    finvs[i] = p\n\n\ndef ncr(n, r, mod=None):\n    \"\"\"\n    scipy.misc.comb または scipy.special.comb と同じ\n    組み合わせの数 nCr\n    \"\"\"\n    ret = factorials[n] * finvs[r] % MOD * finvs[n - r] % mod\n    ret[n < r] = 0\n    return ret\n\n\n# (1) 合計が M*3 で、奇数の数が M 以下である数列の数\nodds = np.arange(M % 2, M + 1, 2)\nhalves1 = (M * 3 - odds) // 2\n# 合計が halfs の数列を 2 倍して、odds 個選んで 1 を足す\nc1 = ncr(halves1 + N - 1, N - 1, MOD) * ncr(N, odds, MOD) % MOD\n\n# (2) max が M*2 より大きく、奇数の数が M 以下である数列の数\n# => 合計が M で、1 要素目が 0 より大きい、奇数が M 以下である数列の数 * N\n# 1 要素目に M*2 を足せば (2) になる\nhalves2 = (M - odds) // 2\n# a. 合計が M で奇数が M 以下\nc2a = ncr(halves2 + N - 1, N - 1, MOD) * ncr(N, odds, MOD) % MOD\n# b. 1 要素目が 0 である数列の数\nc2b = ncr(halves2 + N - 2, N - 2, MOD) * ncr(N - 1, odds, MOD) % MOD\n\nc2 = (c2a - c2b) * N % MOD\n\nprint((c1 - c2).sum() % MOD)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nN,M = map(int,input().split())\nMOD = 998244353\n\nU = 4 * 10 ** 6\nfact = [1] * (U+1)\nfor n in range(1,U+1):\n    fact[n] = fact[n-1] * n % MOD\nfact_inv = [1] * (U+1)\nfact_inv[U] = pow(fact[U],MOD-2,MOD)\nfor n in range(U,0,-1):\n    fact_inv[n-1] = fact_inv[n] * n % MOD\n\ndef comb(n,k):\n    if n == -1 and k == -1:\n      return 1\n    if n < 0:\n      return 0\n    if k < 0 or k > n:\n      return 0\n    return fact[n] * fact_inv[k] * fact_inv[n-k] % MOD\n\nanswer = comb(3*M+N-1,N-1) # 何でもいいから作る\nanswer -= N * comb(M+N-2,N-1) # どれかが 2M+1 以上\n\n# 「ちょうど1」がM個より多くある場合を引かなければいけない\n# （既に引いた場合と背反）\nfor k in range(M+1,3*M+1):\n    sgn = -1 if (k-M)%2 else 1\n    # k個決める、残りは和が3M-k, 個数N-k\n    x = comb(N,k)\n    x *= comb(3*M-k+N-k-1,N-k-1)\n    answer += sgn * x * comb(k-1,k-1-M)\nanswer %= MOD\n\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nclass Combination():\n    def __init__(self, n, mod):\n        self.n = n\n        self.mod = mod\n        self.fact = self.make_fact(n)\n        self.fact_inv = self.make_fact_inv(n)\n    def make_fact(self, n):#0~nの階乗を求める\n        res = [1]*(n+1)\n        for i in range(1, n+1):\n            res[i] = res[i-1]*i%self.mod\n        return res\n    def make_fact_inv(self, n):#0~nの階乗のmodに関する逆元を求める\n        fact_inv = [1]*(n+1)\n        fact_inv[n] = pow(self.fact[n], self.mod-2, self.mod)#フェルマーの小定理\n        for i in range(n, 0, -1):\n            fact_inv[i-1] = fact_inv[i]*i%self.mod\n        return fact_inv\n    def comb(self, m, k):\n        if m<0 or k<0 or m<k:\n            return 0\n        return self.fact[m]*self.fact_inv[k]*self.fact_inv[m-k]%self.mod\nmod = 998244353\nn, m = map(int, input().split())\nC = Combination(n+m*3, mod)\nans = 0\nfor i in range(min(n, m)+1):\n    if m%2 != i%2:\n        continue\n    res = 0\n    r = (m*3-i)//2\n    res+=C.comb(r+n-1, r)\n    res-=C.comb(r-m-1+n-1, n-1)*(n-i)\n    res-=C.comb(r-m+n-1, n-1)*i\n    res*=C.comb(n, i)\n    res%-mod\n    ans+=res\n    ans%=mod\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "o,f,i=998244353,[1],1\nwhile i<o/399:f+=[f[-1]*i%o];i+=1\nc=lambda n,k:f[n]*pow(f[n-k],o-2,o)*pow(f[k],o-2,o)\nn,m=map(int,input().split())\nw,u=3*m,n-1\na=c(w+u,u)-n*c(n+m-2,u)\nm+=1\nif w-m&1:m+=1\nwhile m<=min(w,n):a-=c(n,m)*c((w-m)//2+u,u);m+=2\nprint(a%o)"
  },
  {
    "language": "Python",
    "code": "N,M=map(int,input().split())\nmod=998244353\n\nMAX=3*M//2+N\n\ninv=[0]*(MAX+1)\ninv[1]=1\nfor i in range(2,MAX+1):\n    inv[i]=-(mod//i)*inv[mod%i]%mod\n\ng1=[1,1]\ng2=[1,1]\nfor i in range(2,MAX+1):\n    num_1=g1[-1]*i%mod\n    g1.append(num_1)\n    g2.append(g2[-1]*inv[i]%mod)\n    \ndef cmb(n,r):\n    return g1[n]*g2[r]*g2[n-r]%mod\n\nans=0\nfor i in range(min(N+1,M+1)):\n    if M%2!=i%2:\n        continue\n    m=(3*M-i)//2\n    num=(cmb(m+N-1,N-1)-i*cmb(m-M+N-1,N-1))%mod\n    if m>=M+1:\n        num=(num-(N-i)*cmb(m-M+N-2,N-1))%mod\n    ans=(ans+cmb(N,i)*num)%mod\n\nprint(ans)  "
  },
  {
    "language": "Python",
    "code": "P = 998244353\nfa = [1]\nfor i in range(1, 1000100):\n    fa.append(fa[-1]*i%P)\n\ndef C(a, b):\n    return fa[a]*pow(fa[a-b]*fa[b], P-2, P)%P\n\nN, M = map(int, input().split())\nif N == 2:\n    print(M+1)\nelse:\n    ans = C(3*M+N-1, N-1)\n    for K in range(2*M+1, 3*M+1):\n        ans = (ans - N*C(3*M-K+N-2, N-2)) % P\n    for K in range(M):\n        if 3*M-K*2 <= N:\n            ans = (ans - C(K+N-1, N-1)*C(N, 3*M-K*2)) % P\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "o=998244353\nf=[1]\nfor i in range(1,2500100):f.append(f[-1]*i%o)\ndef c(n,k):return f[n]*pow(f[n-k],o-2,o)*pow(f[k],o-2,o)%o\nn,m=map(int,input().split())\nw=3*m\nu=n-1\na=c(w+u,u)-n*c(n+m-2,u)\nif u>m:\n for i in range(m+1,min(w,n)+1):\n  if w-i+1&amp;1:a=(a-c(n,i)*c((w-i)//2+u,u))%o\nprint(a%o)"
  },
  {
    "language": "Python",
    "code": "o=998244353\nf=[1]\nfor i in range(1,2500100):f.append(f[-1]*i%o)\nc=lambda n,k: f[n]*pow(f[n-k],o-2,o)*pow(f[k],o-2,o)%o\nn,m=map(int,input().split())\nw=3*m\nu=n-1\na=c(w+u,u)-n*c(n+m-2,u)\nif u>m:\n for i in range(m+1,min(w,n)+1):\n  a=(a-c(n,i)*c((w-i)//2+u,u))%o if w-i+1&1\nprint(a%o)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nN,M = map(int,input().split())\nMOD = 998244353\n\nU = 4 * 10 ** 6\nfact = [1] * (U+1)\nfor n in range(1,U+1):\n    fact[n] = fact[n-1] * n % MOD\nfact_inv = [1] * (U+1)\nfact_inv[U] = pow(fact[U],MOD-2,MOD)\nfor n in range(U,0,-1):\n    fact_inv[n-1] = fact_inv[n] * n % MOD\n\ndef comb(n,k):\n    if n == -1 and k == -1:\n      return 1\n    if n < 0:\n      return 0\n    if k < 0 or k > n:\n      return 0\n    return fact[n] * fact_inv[k] % MOD * fact_inv[n-k] % MOD\n\nanswer = comb(3*M+N-1,N-1) # 何でもいいから作る\nanswer -= N * comb(M+N-2,N-1) # どれかが 2M+1 以上\nanswer %= MOD\n# 「ちょうど1」がM個より多くある場合を引かなければいけない\n# （既に引いた場合と背反）\nfor k in range(M+1,3*M+1):\n    sgn = -1 if (k-M)%2 else 1\n    # k個決める、残りは和が3M-k, 個数N-k\n    x = comb(N,k)\n    x *= comb(3*M-k+N-k-1,N-k-1)\n    x %= MOD\n    answer += sgn * x * comb(k-1,k-1-M) % MOD\n    answer %= MOD\nanswer %= MOD\n\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nN,M = map(int,input().split())\nmod = 998244353\n\nFACT=[1]\nfor i in range(1,25*10**5+1):\n    FACT.append(FACT[-1]*i%mod)\n\nFACT_INV=[pow(FACT[-1],mod-2,mod)]\nfor i in range(25*10**5,0,-1):\n    FACT_INV.append(FACT_INV[-1]*i%mod)\n\nFACT_INV.reverse()\n\ndef Combi(a,b):\n    if 0<=b<=a:\n        return FACT[a]*FACT_INV[b]*FACT_INV[a-b]%mod\n    else:\n        return 0\n\n\nANS=Combi(M*3+N-1,N-1)\n\nfor i in range(M*2+1,M*3+1):\n    k=M*3-i\n    ANS=(ANS-N*Combi(k+(N-1)-1,N-2))%mod\n\n\nfor i in range(M+1,N+1):\n    if (M*3-i)%2==1:\n        continue\n    k=(M*3-i)//2\n    ANS=(ANS-Combi(N,i)*Combi(k+N-1,N-1))%mod\n\nprint(ANS)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nN,M = map(int,input().split())\nmod = 998244353\n\nFACT=[1]\nfor i in range(1,4*10**6+1):\n    FACT.append(FACT[-1]*i%mod)\n\nFACT_INV=[pow(FACT[-1],mod-2,mod)]\nfor i in range(4*10**6,0,-1):\n    FACT_INV.append(FACT_INV[-1]*i%mod)\n\nFACT_INV.reverse()\n\ndef Combi(a,b):\n    if 0<=b<=a:\n        return FACT[a]*FACT_INV[b]*FACT_INV[a-b]%mod\n    else:\n        return 0\n\n\nANS=Combi(M*3+N-1,N-1)\n\nfor i in range(M*2+1,M*3+1):\n    k=M*3-i\n    ANS=(ANS-N*Combi(k+(N-1)-1,N-2))%mod\n\n\nfor i in range(M+1,N+1):\n    if (M*3-i)%2==1:\n        continue\n    k=(M*3-i)//2\n    ANS=(ANS-Combi(N,i)*Combi(k+N-1,N-1))%mod\n\nprint(ANS)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nN,M = map(int,input().split())\nMOD = 998244353\n\nU = 2 * 10 ** 6\nfact = [1] * (U+1)\nfor n in range(1,U+1):\n    fact[n] = fact[n-1] * n % MOD\nfact_inv = [1] * (U+1)\nfact_inv[U] = pow(fact[U],MOD-2,MOD)\nfor n in range(U,0,-1):\n    fact_inv[n-1] = fact_inv[n] * n % MOD\n\ndef comb(n,k):\n    if n == -1 and k == -1:\n      return 1\n    if n < 0:\n      return 0\n    if k < 0 or k > n:\n      return 0\n    return fact[n] * fact_inv[k] * fact_inv[n-k] % MOD\n\nanswer = comb(3*M+N-1,N-1) # 何でもいいから作る\nanswer -= N * comb(M+N-2,N-1) # どれかが 2M+1 以上\n\n# 「ちょうど1」がM個より多くある場合を引かなければいけない\n# （既に引いた場合と背反）\nfor k in range(M+1,3*M+1):\n    sgn = -1 if (k-M)%2 else 1\n    # k個決める、残りは和が3M-k, 個数N-k\n    x = comb(N,k)\n    x *= comb(3*M-k+N-k-1,N-k-1)\n    answer += sgn * x * comb(k-1,k-1-M)\nanswer %= MOD\n\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "MOD = 998244353\nlist_size = 2500100\n\nf_list = [1] * list_size\nf_r_list = [1] * list_size\n\nfor i in range(list_size - 1):\n\tf_list[i + 1] = (f_list[i] * (i + 2)) % MOD\n\nf_r_list[-1] = pow(f_list[-1], MOD - 2, MOD)\n\nfor i in range(2, list_size + 1):\n\tf_r_list[-i] = (f_r_list[-i + 1] * (list_size + 2 - i)) % MOD\n\ndef comb(n, r):\n\tif n < r:\n\t\treturn 0\n\telif n == 0 or r == 0 or n == r:\n\t\treturn 1\n\telse:\n\t\treturn (((f_list[n - 1] * f_r_list[n - r - 1]) % MOD) * f_r_list[r - 1]) % MOD \n\nn, m = map(int, input().split())\nprint((comb(3*m+n-1, n-1) - (n*(m+n-2)*comb(m+n-3, n-2)*pow(n-1, MOD-2, MOD))%MOD)%MOD)"
  },
  {
    "language": "Python",
    "code": "mod = 998244353\nrng = 2500100\nfctr = [1]\nfinv = [1]\nfor i in range(1,rng):\n  fctr.append(fctr[-1]*i%mod)\ndef inv(x):\n  return pow(x,mod-2,mod)\ndef cmb(n,k):\n  if n<0 or k<0:\n    return 0\n  else:\n    return fctr[n]*inv(fctr[n-k])*inv(fctr[k])%mod\n\nn,m = map(int,input().split())\nans = cmb(n+3*m-1,n-1)\nans = (ans-n*cmb(n+m-2,n-1))%mod\nif n>m+1:\n  for i in range(m+1,min(3*m,n)+1):\n    if (3*m-i)%2 == 1:\n      continue\n    x = (3*m-i)//2\n    ans = (ans-cmb(n,i)*cmb(x+n-1,n-1))%mod\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "MOD = 998244353\nlist_size = 2500100\n\nf_list = [1] * list_size\nf_r_list = [1] * list_size\n\nfor i in range(list_size - 1):\n\tf_list[i + 1] = (f_list[i] * (i + 2)) % MOD\n\nf_r_list[-1] = pow(f_list[-1], MOD - 2, MOD)\n\nfor i in range(2, list_size + 1):\n\tf_r_list[-i] = (f_r_list[-i + 1] * (list_size + 2 - i)) % MOD\n\ndef comb(n, r):\n\tif n < r:\n\t\treturn 0\n\telif n == 0 or r == 0 or n == r:\n\t\treturn 1\n\telse:\n\t\treturn (((f_list[n - 1] * f_r_list[n - r - 1]) % MOD) * f_r_list[r - 1]) % MOD \n\nn, m = map(int, input().split())\nans = comb(3*m+n-1, n-1)\nans -= n*(m+n-2)*comb(m+n-3, n-2)*pow(n-1, MOD-2, MOD)\nfor k in range(m+1, n+1):\n\tif (m-k)%2 == 1:\n\t\tcontinue\n\tans -= comb(n, k) * comb((3*m-k)//2+n-1, n-1)\n\tans %= MOD\nprint(ans%MOD)"
  },
  {
    "language": "Python",
    "code": "N, M = map(int, input().split())\n\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 998244353\nn = 10**6\ng1 = [1, 1]\ng2 = [1, 1] #逆元テーブル\ninverse = [0, 1] #逆元テーブル計算用テーブル\n\nfor i in range( 2, n + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nans = cmb(M*3+N-1, N-1, mod)\nfor i in range(M*2+1, M*3+1):\n    ans -= cmb(M*3-i+(N-1)-1, N-2, mod) * N - mod*mod\n    ans = (ans+mod)%mod\n\nfor i in range(M+1, min(N, 3*M)+1):\n    if (3*M - i) % 2 == 0:\n        two = (3*M - i) // 2\n        ans -= cmb(two+N-1, N-1, mod) * cmb(N, i, mod) - mod*mod\n        ans = (ans+mod)%mod\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nimport numpy as np\n\nN,M = map(int,input().split())\nMOD = 998244353\n\ndef cumprod_mod(arr):\n    L = len(arr)\n    Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    arr = arr.ravel()[:L]\n    return arr\n\nU = 5*10**6\nx = np.arange(U,dtype=np.int64)\nx[0] = 1\nfact = cumprod_mod(x)\n\nx = np.arange(U,0,-1,dtype=np.int64)\nx[0] = pow(int(fact[-1]),MOD-2,MOD)\nfact_inv = cumprod_mod(x)[::-1]\n\ndef comb(n,k):\n    return fact[n] * fact_inv[k] % MOD * fact_inv[n-k] % MOD\n\nx = comb(3*M+N-1,N-1) # 何でもいいから作る\ny = N * comb(M+N-2,N-1) # どれかが 2M+1 以上\n\n# 奇数がM+1個以上あるものを除く\nodd_cnt = np.arange(M+2,3*M+1,2)\nS = (3*M - odd_cnt)//2\nbl = (odd_cnt <= N)&(S>=0)\nodd_cnt = odd_cnt[bl]\nS = S[bl]\narr = fact[N] * fact_inv[odd_cnt] % MOD * fact_inv[N-odd_cnt] % MOD\n# SをN個で作る -> S+N-1 C N-1\narr *= fact[S+N-1] * fact_inv[N-1] % MOD * fact_inv[S] % MOD\narr %= MOD\nz = arr.sum() % MOD\n\nanswer = x-y-z\nanswer %= MOD\nprint(answer)\n\n"
  },
  {
    "language": "Python",
    "code": "from functools import lru_cache\n\n\ndef prepare(n, MOD):\n    f = 1\n    factorials = [1] * (n + 1)\n    for m in range(1, n + 1):\n        f = f * m % MOD\n        factorials[m] = f\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv = inv * m % MOD\n        invs[m - 1] = inv\n\n    return factorials, invs\n\n\ndef get_nhr(n, facts, invs, MOD):\n    @lru_cache(maxsize=None)\n    def nhr(r):\n        return facts[n + r - 1] * invs[r] * invs[n - 1] % MOD\n\n    return nhr\n\n\ndef solve(n, m):\n    MOD = 998244353\n    facts, invs = prepare(n + 3 * m, MOD)\n    fn = facts[n]\n    nhr = get_nhr(n, facts, invs, MOD)\n    ans = 0\n    for odd in range(m % 2, min(m, n) + 1, 2):\n        tmp = nhr((3 * m - odd) // 2)\n        if odd > 0:\n            tmp -= odd * nhr((m - odd) // 2)\n        if odd < n and odd <= m - 2:\n            tmp -= (n - odd) * nhr((m - odd - 2) // 2)\n        ans = (ans + fn * invs[odd] * invs[n - odd] % MOD * tmp) % MOD\n    return ans\n\n\nn, m = list(map(int, input().split()))\nprint(solve(n, m))\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nN,M = map(int,input().split())\nMOD = 998244353\n\nU = 4 * 10 ** 6\nfact = [1] * (U+1)\nfor n in range(1,U+1):\n    fact[n] = fact[n-1] * n % MOD\nfact_inv = [1] * (U+1)\nfact_inv[U] = pow(fact[U],MOD-2,MOD)\nfor n in range(U,0,-1):\n    fact_inv[n-1] = fact_inv[n] * n % MOD\n\ndef comb(n,k):\n    if n == -1 and k == -1:\n      return 1\n    if n < 0:\n      return 0\n    if k < 0 or k > n:\n      return 0\n    return fact[n] * fact_inv[k] % MOD * fact_inv[n-k] % MOD\n\nanswer = comb(3*M+N-1,N-1) # 何でもいいから作る\nanswer -= N * comb(M+N-2,N-1) # どれかが 2M+1 以上\n\n# 「ちょうど1」がM個より多くある場合を引かなければいけない\n# （既に引いた場合と背反）\nfor k in range(M+1,3*M+1):\n    sgn = -1 if (k-M)%2 else 1\n    # k個決める、残りは和が3M-k, 個数N-k\n    x = comb(N,k)\n    x *= comb(3*M-k+N-k-1,N-k-1)\n    answer += sgn * x * comb(k-1,k-1-M) % MOD\n    answer %= MOD\nanswer %= MOD\n\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "o,f,i=998244353,[1],1\nwhile i<o/399:f+=[f[-1]*i%o];i+=1\nc=lambda n,k:f[n]*pow(f[n-k],o-2,o)*pow(f[k],o-2,o)\nn,m=map(int,input().split())\nw,u=3*m,n-1\na=c(w+u,u)-n*c(n+m-2,u)\nwhile-~m<min(w,n):m+=2;a-=c(n,m)*c((w-m)//2+u,u)\nprint(a%o)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nimport math\nfrom bisect import bisect_left, bisect_right\nimport random\nfrom itertools import permutations, accumulate, combinations\nimport sys\nimport string\n\n\n\nINF = float('inf')\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return sys.stdin.readline().strip()\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\nmod = 998244353\n\n\nn, m = LI()\ntotal = m * 3\n\n\nfac = [1] * (total + n)\ninv = [1] * (total + n)\ni = 1\nfor j in range(1, total + n):\n    i = i * j % mod\n    fac[j] = i\n    inv[j] = pow(i, mod - 2, mod)\n\n\n\ndef comb(n, r):\n    if r > n:\n        return 0\n    return fac[n] * inv[n - r] * inv[r] % mod\n\n\n\nans = comb(total + n - 1, n - 1)\nfor i in range(m + 2, min(n + 1, total + 1), 2):\n    ans -= comb(n, i) * comb(n + (total - i) // 2 - 1, n - 1) % mod\n    ans %= mod\n\n\nret = 0\nfor i in range(m):\n    ret = (ret + comb(i + n - 2, n - 2)) % mod\n\n\nans -= (ret * n) % mod\nprint(ans % mod)"
  },
  {
    "language": "Python",
    "code": "o,f=998244353,[1]\nfor i in range(1,2500100):f.append(f[-1]*i%o)\nc=lambda n,k:f[n]*pow(f[n-k],o-2,o)*pow(f[k],o-2,o)\nn,m=map(int,input().split())\nw,u=3*m,n-1\na=c(w+u,u)-n*c(n+m-2,u)\nif u>m:\n for i in range(m+1,min(w,n)+1):\n  if w-i+1&1:a-=c(n,i)*c((w-i)//2+u,u) \nprint(a%o)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nU = 4*10**6\nMOD = 998244353\n \nfact = [1]*(U+1)\nfact_inv = [1]*(U+1)\n \nfor i in range(1,U+1):\n    fact[i] = (fact[i-1]*i)%MOD\nfact_inv[U] = pow(fact[U], MOD-2, MOD)\n \nfor i in range(U,0,-1):\n    fact_inv[i-1] = (fact_inv[i]*i)%MOD\n \ndef perm(n, k):\n    if k < 0 or k > n:\n        return 0\n    z = fact[n]\n    z *= fact_inv[n-k]\n    z %= MOD\n    return z\n\ndef comb(n, k):\n    if k < 0 or k > n:\n        return 0\n    z = fact[n]\n    z *= fact_inv[k]\n    z %= MOD\n    z *= fact_inv[n-k]\n    z %= MOD\n    return z\n\nn, m = map(int, input().split())\nans = 0\nfor k in range(m%2, min(n, m)+1, 2):\n  ans += comb((3*m-k)//2+n-1, n-1) * comb(n, k)\n  ans %= MOD\ncnt = 0\nfor k in range(m):\n  cnt += comb(k+n-2, n-2)\n  cnt %= MOD\ncnt *= n\ncnt %= MOD\nans -= cnt\nans %= MOD\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nN,M = map(int,input().split())\nMOD = 998244353\n\nU = 2 * 10 ** 6\nfact = [1] * (U+1)\nfor n in range(1,U+1):\n    fact[n] = fact[n-1] * n % MOD\nfact_inv = [1] * (U+1)\nfact_inv[U] = pow(fact[U],MOD-2,MOD)\nfor n in range(U,0,-1):\n    fact_inv[n-1] = fact_inv[n] * n % MOD\n\ndef comb(n,k):\n    return fact[n] * fact_inv[k] * fact_inv[n-k] % MOD\n\nanswer = comb(3*M+N-1,N-1) # 何でもいいから作る\nanswer -= N * comb(M+N-2,N-1) # どれかが 2M+1 以上\nanswer %= MOD\n\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "mod = 998244353\nn, m = map(int, input().split())\n\ndef cmb(n, c):\n    ret = 1\n    for i in range(c):\n        ret = ret * (n - i) // (i + 1)\n    return ret\n\nprint((cmb(3 * m + n - 1, n - 1) - n * cmb(m + n - 2, n - 1)) % mod)"
  },
  {
    "language": "Python",
    "code": "class Combination:\n    \"\"\"階乗とその逆元のテーブルをO(N)で事前作成し、組み合わせの計算をO(1)で行う\"\"\"\n    def __init__(self, n, MOD):\n        self.fact = [1]\n        for i in range(1, n + 1):\n            self.fact.append(self.fact[-1] * i % MOD)\n        self.inv_fact = [0] * (n + 1)\n        self.inv_fact[n] = pow(self.fact[n], MOD - 2, MOD)\n        for i in reversed(range(n)):\n            self.inv_fact[i] = self.inv_fact[i + 1] * (i + 1) % MOD\n        self.MOD = MOD\n\n    def inverse(self, k):\n        \"\"\"kの逆元を求める O(1)\"\"\"\n        return (self.inv_fact[k] * self.fact[k - 1]) % self.MOD\n\n    def factorial(self, k):\n        \"\"\"k!を求める O(1)\"\"\"\n        return self.fact[k]\n\n    def inverse_factorial(self, k):\n        \"\"\"k!の逆元を求める O(1)\"\"\"\n        return self.inv_fact[k]\n\n    def permutation(self, k, r):\n        \"\"\"kPrを求める O(1)\"\"\"\n        if k < r:\n            return 0\n        return (self.fact[k] * self.inv_fact[k - r]) % self.MOD\n\n    def combination(self, k, r):\n        \"\"\"kCrを求める O(1)\"\"\"\n        if k < r:\n            return 0\n        return (self.fact[k] * self.inv_fact[k - r] * self.inv_fact[r]) % self.MOD\n\n\nn, m = map(int, input().split())\nMOD = 998244353\ncomb = Combination(10 ** 7, MOD)\n\n\nans = 0\nfor odd_cnt in range(m + 1):\n    if odd_cnt > n:\n        continue\n    if (3 * m - odd_cnt) % 2 == 1:\n        continue\n    ptn = 1\n    box = n\n    odd_ball = odd_cnt\n    ptn *= comb.combination(box, odd_ball)\n\n    even_pair_ball = (3 * m - odd_cnt) // 2\n    ptn *= comb.combination(even_pair_ball + box - 1, even_pair_ball)\n\n    ans += ptn\n    ptn %= MOD\n\nfor i in range(1, m + 1):\n    ball = m - i\n    box = n - 1\n    ans -= comb.combination(ball + box - 1, ball) * n\n    ans %= MOD\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "n,m=map(int,input().split())\no,f,i=998244353,[1],1\nwhile i<3*m+n:f+=[f[-1]*i%o];i+=1\nc=lambda x,y=n-1:f[x]*pow(f[x-y]*f[y],o-2,o)\na=c(-1)-n*c(n+m-2)\nwhile~-n>m<i-n:m+=2;a-=c(n,m)*c(n-1+i-m>>1)\nprint(a%o)"
  },
  {
    "language": "Python",
    "code": "from sys import exit, setrecursionlimit, stdin, stderr\nfrom functools import reduce\nfrom itertools import *\nfrom collections import *\nfrom bisect import *\nfrom heapq import *\nimport operator\nimport math\nfrom fractions import gcd\nfrom random import randint\n\nsetrecursionlimit(10**8)\n\ndef input():\n  return stdin.readline().strip()\n\ndef read():\n  return int(input())\n \ndef reads():\n  return [int(x) for x in input().split()]\n\nMAX = 3 * 10**6\nMOD = 998244353\n\nfact = [1] * MAX\nfor i in range(1, MAX):\n  fact[i] = (fact[i-1] * i) % MOD\ninvfact = [0] * MAX\ninvfact[-1] = pow(fact[-1], MOD-2, MOD)\nfor i in range(MAX-2, -1, -1):\n  invfact[i] = invfact[i+1] * (i+1) % MOD\n\ndef comb(n, k):\n  return fact[n] * invfact[n-k] * invfact[k] % MOD if 0 <= k <= n else 0\n\ndef H(n, k):\n  return comb(n+k-1, k-1)\n\nN, M = reads()\n\nans =0\nfor k in range(M%2, M+1, 2):\n  d = comb(N, k) * (\n    H((3 * M - k) // 2, N)\n          - k * H((M-k)//2, N)\n          - (N-k) * H((M-2-k)//2, N)\n    )\n  # print(k, d)\n  ans = (ans + d) % MOD\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "o,f,i=998244353,[1],1\nwhile i<o/399:f+=[f[-1]*i%o];i+=1\nc=lambda n,k:f[n]*pow(f[n-k],o-2,o)*pow(f[k],o-2,o)\nn,m=map(int,input().split())\nw,u=3*m,n-1\na=c(w+u,u)-n*c(n+m-2,u)\nwhile-~m<min(w,n):m+=2;a-=c(n,m)*c((w-m)//2+u,u)\nprint(a%o)"
  },
  {
    "language": "Python",
    "code": "def prepare(n, MOD):\n    f = 1\n    factorials = [1] * (n + 1)\n    for m in range(1, n + 1):\n        f = f * m % MOD\n        factorials[m] = f\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv = inv * m % MOD\n        invs[m - 1] = inv\n\n    return factorials, invs\n\n\ndef get_nhr(n, facts, invs, MOD):\n    def nhr(r):\n        return facts[n + r - 1] * invs[r] * invs[n - 1] % MOD\n\n    return nhr\n\n\ndef solve(n, m):\n    MOD = 998244353\n    facts, invs = prepare(n + 3 * m, MOD)\n    fn = facts[n]\n    nhr = get_nhr(n, facts, invs, MOD)\n    nm2 = min(n, m - 1)\n    ans = 0\n    for odd in range(m % 2, min(m, n) + 1, 2):\n        tmp = nhr((3 * m - odd) // 2)\n        if odd > 0:\n            tmp -= odd * nhr((m - odd) // 2)\n        if odd < nm2:\n            tmp -= (n - odd) * nhr((m - odd - 2) // 2)\n        ans = (ans + fn * invs[odd] * invs[n - odd] % MOD * tmp) % MOD\n    return ans\n\n\nn, m = list(map(int, input().split()))\nprint(solve(n, m))\n"
  },
  {
    "language": "Python",
    "code": "N = input(N)\nM = int(input())\nprint(2 ** M)"
  },
  {
    "language": "Python",
    "code": "A = list(map(int, input().split())) \n\nn = A[0]\nm = A[1]\n\nprint(n**m)\n"
  },
  {
    "language": "Python",
    "code": "o,f,i=998244353,[1],1\nwhile i<o>>8:f+=[f[-1]*i%o];i+=1\nc=lambda n,k:f[n]*pow(f[n-k],o-2,o)*pow(f[k],o-2,o)\nn,m=map(int,input().split())\nw,u=3*m,n-1\na=c(w+u,u)-n*c(n+m-2,u)\nwhile-~m<min(w,n):m+=2;a-=c(n,m)*c(2*u+w-m>>1,u)\nprint(a%o)"
  },
  {
    "language": "Python",
    "code": "import os\nimport sys\n\nimport numpy as np\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 998244353\n\nN, M = list(map(int, sys.stdin.readline().split()))\n\n\ndef get_factorials(max, mod=None):\n    \"\"\"\n    階乗 0!, 1!, 2!, ..., max!\n    :param int max:\n    :param int mod:\n    :return:\n    \"\"\"\n    ret = [1]\n    n = 1\n    if mod:\n        for i in range(1, max + 1):\n            n *= i\n            n %= mod\n            ret.append(n)\n    else:\n        for i in range(1, max + 1):\n            n *= i\n            ret.append(n)\n    return ret\n\n\ndef mod_invs(max, mod):\n    \"\"\"\n    逆元のリスト 0 から max まで\n    :param max:\n    :param mod:\n    :return:\n    \"\"\"\n    invs = [1] * (max + 1)\n    for x in range(2, max + 1):\n        invs[x] = (-(mod // x) * invs[mod % x]) % mod\n    return invs\n\n\nfactorials = np.array(get_factorials(M * 3 // 2 + N, MOD), dtype=int)\nfinvs = []\ninv = 1\nfor i in mod_invs(M * 3 // 2 + N, MOD):\n    inv = inv * i % MOD\n    finvs.append(inv)\nfinvs = np.array(finvs)\n\n\ndef ncr(n, r, mod=None):\n    \"\"\"\n    scipy.misc.comb または scipy.special.comb と同じ\n    組み合わせの数 nCr\n    :param int n:\n    :param int r:\n    :param int mod: 3 以上の素数であること\n    :rtype: int\n    \"\"\"\n    ret = factorials[n] * finvs[r] % MOD * finvs[n - r] % mod\n    ret[n < r] = 0\n    return ret\n\n\n# (1) 合計が M*3 で、奇数の数が M 以下である数列の数\nodds = np.arange(M * 3 % 2, M + 1, 2)\nhalves = (M * 3 - odds) // 2\n# 合計が halfs の数列を 2 倍して、odds 個選んで 1 を足す\nc1 = ncr(halves + N - 1, N - 1, MOD) * ncr(N, odds, MOD) % MOD\n\n# (2) max が M*2 より大きく、奇数の数が M 以下である数列の数\n# => 合計が M で、1 要素目が 0 より大きい、奇数が M 以下である数列の数 * N\n# 1 要素目に M*2 を足せば (2) になる\nodds = np.arange(M % 2, M + 1, 2)\nhalves = (M - odds) // 2\n# a. 合計が M で奇数が M 以下\nc2a = ncr(halves + N - 1, N - 1, MOD) * ncr(N, odds, MOD) % MOD\n# b. 1 要素目が 0 である数列の数\nc2b = ncr(halves + N - 2, N - 2, MOD) * ncr(N - 1, odds, MOD) % MOD\n\nc2 = (c2a - c2b) * N\nprint((c1.sum() - c2.sum()) % MOD)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nN,M = map(int,input().split())\nmod = 998244353\n\nFACT=[1]\nfor i in range(1,2*10**6+1):\n    FACT.append(FACT[-1]*i%mod)\n\nFACT_INV=[pow(FACT[-1],mod-2,mod)]\nfor i in range(2*10**6,0,-1):\n    FACT_INV.append(FACT_INV[-1]*i%mod)\n\nFACT_INV.reverse()\n\ndef Combi(a,b):\n    if 0<=b<=a:\n        return FACT[a]*FACT_INV[b]*FACT_INV[a-b]%mod\n    else:\n        return 0\n\n\nANS=Combi(M*3+N-1,N-1)\n\nfor i in range(M*2+1,M*3+1):\n    k=M*3-i\n    ANS=(ANS-N*Combi(k+(N-1)-1,N-2))%mod\n\n\nfor i in range(M+1,N+1):\n    if (M*3-i)%2==1:\n        continue\n    k=(M*3-i)//2\n    ANS=(ANS-Combi(N,i)*Combi(k+N-1,N-1))%mod\n\nprint(ANS)\n\n"
  },
  {
    "language": "Python",
    "code": "from functools import lru_cache\n\n\ndef prepare(n, MOD):\n    f = 1\n    factorials = [1]\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n\n    return factorials, invs\n\n\ndef get_nhr(n, facts, invs):\n    @lru_cache(maxsize=None)\n    def nhr(r):\n        return facts[n + r - 1] * invs[r] * invs[n - 1] % MOD\n\n    return nhr\n\n\nMOD = 998244353\nn, m = list(map(int, input().split()))\nfacts, invs = prepare(n + 3 * m, MOD)\nnhr = get_nhr(n, facts, invs)\nans = 0\nfor odd in range(m % 2, min(m, n) + 1, 2):\n    tmp = nhr((3 * m - odd) // 2)\n    if odd > 0:\n        tmp -= odd * nhr((m - odd) // 2)\n    if odd < n and odd <= m - 2:\n        tmp -= (n - odd) * nhr((m - odd - 2) // 2)\n    ans = (ans + facts[n] * invs[odd] * invs[n - odd] % MOD * tmp) % MOD\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "mod = 998244353\neps = 10**-9\n\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n\n    # comb init\n    # mod = 1000000007\n    nmax = 25 * 10 ** 5 + 10  # change here\n    fac = [0] * nmax\n    finv = [0] * nmax\n    inv = [0] * nmax\n    fac[0] = 1\n    fac[1] = 1\n    finv[0] = 1\n    finv[1] = 1\n    inv[1] = 1\n    for i in range(2, nmax):\n        fac[i] = fac[i - 1] * i % mod\n        inv[i] = mod - inv[mod % i] * (mod // i) % mod\n        finv[i] = finv[i - 1] * inv[i] % mod\n\n    def comb(n, r):\n        if n < r:\n            return 0\n        else:\n            return (fac[n] * ((finv[r] * finv[n - r]) % mod)) % mod\n\n    N, M = map(int, input().split())\n    ans = comb(3 * M + N - 1, N-1)\n    for i in range(2 * M + 1, 3 * M+1):\n        ans = (ans - (N * comb(3*M - i + N-2, N-2))%mod)%mod\n    for i in range(M+2, 3 * M + 1, 2):\n        if i > N:\n            break\n        j = (3 * M - i) // 2\n        ans = (ans - (comb(N, i) * comb(j + N-1, N-1))%mod)%mod\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "n,m=map(int,input().split())\nw,u=3*m,n-1\no,f,i=998244353,[1],1\nwhile i<w+n:f+=[f[-1]*i%o];i+=1\nc=lambda n,k:f[n]*pow(f[n-k],o-2,o)*pow(f[k],o-2,o)\na=c(w+u,u)-n*c(n+m-2,u)\nwhile~-n>m<w:m+=2;a-=c(n,m)*c(2*u+w-m>>1,u)\nprint(a%o)"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\nmod = 998244353\n\n#################################\n\n## nCkのmodを求める関数\n# テーブルを作る(前処理)\nmax = n+2*m + 100\nfac, finv, inv = [0]*max, [0]*max, [0]*max\n\ndef comInit(max):\n    fac[0] = fac[1] = 1\n    finv[0] = finv[1] = 1\n    inv[1] = 1\n\n    for i in range(2,max):\n      fac[i] = fac[i-1]* i% mod\n      inv[i] = mod - inv[mod%i] * (mod // i) % mod\n      finv[i] = finv[i-1] * inv[i] % mod\n\ncomInit(max)\n\n# 二項係数の計算\ndef com(n,k):\n    if(n < k):\n        return 0\n    if( (n<0) | (k < 0)):\n        return 0\n    return fac[n] * (finv[k] * finv[n-k] % mod) % mod\n\n\na = 0\nfor x in range(min(m,n)+1):\n    if(3*m-x)%2==1:\n        continue\n    y = (3*m-x)//2\n    a += com(n,x)*fac[y+n-1]*finv[y]*finv[n-1]\n    a %= mod\n\nb = fac[n-1+m-1] * finv[n-1] * finv[m-1] * n\nb %= mod\n\nans = a-b\nans %= mod\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "N, M = map(int, input().split())\n\nmod = 998244353\ndef cmb(n, r, mod=mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nNN = 10**6 # 使うデータによって変える\ng1 = [1, 1] # 元テーブル\ng2 = [1, 1] #逆元テーブル\ninverse = [0, 1] #逆元テーブル計算用テーブル\n\nfor i in range( 2, NN + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\n\nA = []\ntmp = 0\nfor i in range(M+2):\n    tmp = (tmp + cmb(N-2+i, N-2)) % mod\n    A.append(tmp)\n\nans = 0\nfor k in range(min(N, M)+1):\n    if (M-k) % 2 != 0: continue\n    l = (3*M-k)//2\n    a = cmb(N-1+l, N-1) * cmb(N, k)\n    b = N * (cmb(N-1, k-1)*A[l-M])\n    if l >= M+1:\n        b += N * cmb(N-1, k)*A[l-M-1]\n    #print(k,a-b)\n    ans = (ans + a - b) % mod \nprint(ans)\n\n# C = set()\n# def calc(d, A):\n#     if d == M:\n#         t = \"\"\n#         for a in A:\n#             t += str(a)\n#         C.add(t)\n#         return\n#     for i in range(N):\n#         for j in range(N):\n#             if i == j: continue\n#             B = A[:]\n#             B[i] += 2\n#             B[j] += 1\n#             calc(d+1, B)\n#     return\n\n#calc(0, [0]*N)\n#print(len(C))\n#print(C)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nN,M = map(int,input().split())\nMOD = 998244353\n\nU = 2 * 10 ** 6\nfact = [1] * (U+1)\nfor n in range(1,U+1):\n    fact[n] = fact[n-1] * n % MOD\nfact_inv = [1] * (U+1)\nfact_inv[U] = pow(fact[U],MOD-2,MOD)\nfor n in range(U,0,-1):\n    fact_inv[n-1] = fact_inv[n] * n % MOD\n\ndef comb(n,k):\n    if n == -1 and k == -1:\n      return 1\n    if k < 0 or k > n:\n      return 0\n    return fact[n] * fact_inv[k] * fact_inv[n-k] % MOD\n\nanswer = comb(3*M+N-1,N-1) # 何でもいいから作る\nanswer -= N * comb(M+N-2,N-1) # どれかが 2M+1 以上\n\n# 「ちょうど1」がM個より多くある場合を引かなければいけない\n# （既に引いた場合と背反）\nfor k in range(M+1,3*M+1):\n    sgn = -1 if (k-M)%2 else 1\n    # k個決める、残りは和が3M-k, 個数N-k\n    x = comb(N,k)\n    x *= comb(3*M-k+N-k-1,N-k-1)\n    answer += sgn * x * comb(k-1,k-1-M)\nanswer %= MOD\n\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "N, M = map(int, input().split())\n\nmod = 998244353\ndef cmb(n, r, mod=mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nNN = 4*10**6 # 使うデータによって変える\ng1 = [1, 1] # 元テーブル\ng2 = [1, 1] #逆元テーブル\ninverse = [0, 1] #逆元テーブル計算用テーブル\n\nfor i in range( 2, NN + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\n\nA = []\ntmp = 0\nfor i in range(2*M+N+2):\n    tmp = (tmp + cmb(N-2+i, N-2)) % mod\n    A.append(tmp)\n\nans = 0\nfor k in range(min(N, M)+1):\n    if (M-k) % 2 != 0: continue\n    l = (3*M-k)//2\n    a = cmb(N-1+l, N-1) * cmb(N, k)\n    b = N * (cmb(N-1, k-1)*A[l-M])\n    if l >= M+1:\n        b += N * cmb(N-1, k)*A[l-M-1]\n    #print(k,a-b)\n    ans = (ans + a - b) % mod \nprint(ans)\n\n# C = set()\n# def calc(d, A):\n#     if d == M:\n#         t = \"\"\n#         for a in A:\n#             t += str(a)\n#         C.add(t)\n#         return\n#     for i in range(N):\n#         for j in range(N):\n#             if i == j: continue\n#             B = A[:]\n#             B[i] += 2\n#             B[j] += 1\n#             calc(d+1, B)\n#     return\n\n#calc(0, [0]*N)\n#print(len(C))\n#print(C)\n"
  },
  {
    "language": "Python",
    "code": "o,f,i=998244353,[1],1\nwhile i<o>>8:f+=[f[-1]*i%o];i+=1\nc=lambda n,k:f[n]*pow(f[n-k],o-2,o)*pow(f[k],o-2,o)\nn,m=map(int,input().split());w,u=3*m,n-1;a=c(w+u,u)-n*c(n+m-2,u)\nwhile-~m<min(w,n):m+=2;a-=c(n,m)*c(2*u+w-m>>1,u)\nprint(a%o)"
  },
  {
    "language": "Python",
    "code": "def prepare(n, MOD):\n    f = 1\n    factorials = [1] * (n + 1)\n    for m in range(1, n + 1):\n        f = f * m % MOD\n        factorials[m] = f\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv = inv * m % MOD\n        invs[m - 1] = inv\n\n    return factorials, invs\n\n\ndef get_nhr(n, facts, invs, MOD):\n    def nhr(r):\n        return facts[n + r - 1] * invs[r] * invs[n - 1] % MOD\n\n    return nhr\n\n\ndef solve(n, m):\n    MOD = 998244353\n    facts, invs = prepare(n + 3 * m, MOD)\n    fn = facts[n]\n    nhr = get_nhr(n, facts, invs, MOD)\n    nm2 = min(n, m - 2)\n    ans = 0\n    for odd in range(m % 2, min(m, n) + 1, 2):\n        tmp = nhr((3 * m - odd) // 2)\n        if odd > 0:\n            tmp -= odd * nhr((m - odd) // 2)\n        if odd < nm2:\n            tmp -= (n - odd) * nhr((m - odd - 2) // 2)\n        ans = (ans + fn * invs[odd] * invs[n - odd] % MOD * tmp) % MOD\n    return ans\n\n\nn, m = list(map(int, input().split()))\nprint(solve(n, m))\n"
  },
  {
    "language": "Python",
    "code": "o,f,i=998244353,[1],1\nwhile i<o/399:f+=f[-1]*i%o;i+=1\nc=lambda n,k:f[n]*pow(f[n-k],o-2,o)*pow(f[k],o-2,o)\nn,m=map(int,input().split())\nw,u=3*m,n-1\na=c(w+u,u)-n*c(n+m-2,u)\nif u>m:\n for i in range(m+1,min(w,n)+1):\n  if w-i+1&1:a-=c(n,i)*c((w-i)//2+u,u) \nprint(a%o)"
  },
  {
    "language": "Python",
    "code": "import os\nimport sys\n\nimport numpy as np\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 998244353\n\nN, M = list(map(int, sys.stdin.readline().split()))\n\n\ndef get_factorials(max, mod=None):\n    \"\"\"\n    階乗 0!, 1!, 2!, ..., max!\n    :param int max:\n    :param int mod:\n    :return:\n    \"\"\"\n    ret = [1]\n    n = 1\n    if mod:\n        for i in range(1, max + 1):\n            n *= i\n            n %= mod\n            ret.append(n)\n    else:\n        for i in range(1, max + 1):\n            n *= i\n            ret.append(n)\n    return ret\n\n\ndef mod_invs(max, mod):\n    \"\"\"\n    逆元のリスト 0 から max まで\n    :param max:\n    :param mod:\n    :return:\n    \"\"\"\n    invs = [1] * (max + 1)\n    for x in range(2, max + 1):\n        invs[x] = (-(mod // x) * invs[mod % x]) % mod\n    return invs\n\n\nfactorials = np.array(get_factorials(M * 3 // 2 + N, MOD), dtype=int)\nfinvs = []\ninv = 1\nfor i in mod_invs(M * 3 // 2 + N, MOD):\n    inv = inv * i % MOD\n    finvs.append(inv)\nfinvs = np.array(finvs, dtype=int)\n\n\ndef ncr(n, r, mod=None):\n    \"\"\"\n    scipy.misc.comb または scipy.special.comb と同じ\n    組み合わせの数 nCr\n    :param int n:\n    :param int r:\n    :param int mod: 3 以上の素数であること\n    :rtype: int\n    \"\"\"\n    ret = factorials[n] * finvs[r] % MOD * finvs[n - r] % mod\n    ret[n < r] = 0\n    return ret\n\n\n# (1) 合計が M*3 で、奇数の数が M 以下である数列の数\nodds = np.arange(M * 3 % 2, M + 1, 2)\nhalves = (M * 3 - odds) // 2\n# 合計が halfs の数列を 2 倍して、odds 個選んで 1 を足す\nc1 = ncr(halves + N - 1, N - 1, MOD) * ncr(N, odds, MOD) % MOD\n\n# (2) max が M*2 より大きく、奇数の数が M 以下である数列の数\n# => 合計が M で、1 要素目が 0 より大きい、奇数が M 以下である数列の数 * N\n# 1 要素目に M*2 を足せば (2) になる\nodds = np.arange(M % 2, M + 1, 2)\nhalves = (M - odds) // 2\n# a. 合計が M で奇数が M 以下\nc2a = ncr(halves + N - 1, N - 1, MOD) * ncr(N, odds, MOD) % MOD\n# b. 1 要素目が 0 である数列の数\nc2b = ncr(halves + N - 2, N - 2, MOD) * ncr(N - 1, odds, MOD) % MOD\n\nc2 = (c2a - c2b) * N % MOD\nprint((c1.sum() - c2.sum()) % MOD)\n"
  },
  {
    "language": "Python",
    "code": "N, M = map(int, input().split())\nMOD = 998244353\n\nif N < M :\n    one = N - (N - M) % 2\n    two = (3 * M - one) // 2\nelse :\n    one, two = M, M\n    \nL = M + M // 2 + N - 1\n\nfac = [0] * (L + 1)\ninv = [0] * (L + 1)\nfac[0], inv[0] = 1, 1\n\nfor i in range(1, L + 1) :\n    fac[i] = fac[i-1] * i % MOD\n    inv[i] = pow(fac[i], MOD-2, MOD)\n\ndef comb(n, r) :\n    if n <= 0 or r < 0 :\n        return 0\n    return fac[n]*inv[n-r]*inv[r]%MOD\n\nret = 0\nwhile one >= 0 :\n    ret += comb(N, one) * comb(two+N-1, N-1) % MOD\n    ret %= MOD\n    one -= 2\n    two += 1\n \nret -= comb(3*M+N-1-(2*M+1), N-1) * N\nprint(ret % MOD)"
  },
  {
    "language": "Python",
    "code": "import os\nimport sys\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 998244353\n\nN, M = list(map(int, sys.stdin.readline().split()))\n\n\ndef get_factorials(max, mod=None):\n    \"\"\"\n    階乗 0!, 1!, 2!, ..., max!\n    :param int max:\n    :param int mod:\n    :return:\n    \"\"\"\n    ret = [1]\n    n = 1\n    if mod:\n        for i in range(1, max + 1):\n            n *= i\n            n %= mod\n            ret.append(n)\n    else:\n        for i in range(1, max + 1):\n            n *= i\n            ret.append(n)\n    return ret\n\n\nfactorials = get_factorials(M * 3 + N - 1, MOD)\n\n\n# invs = mod_invs(M * 3 + N - 1, MOD)\n# fi = [0, invs[1]]\n# a = invs[1]\n# for i in invs[2:]:\n#     a = a * i % MOD\n#     fi.append(a)\n#\n# print(invs)\n\n\ndef mod_inv(a, mod):\n    \"\"\"\n    a の逆元\n    :param int a:\n    :param int mod:\n    :return:\n    \"\"\"\n    return pow(a, mod - 2, mod)\n\n\ndef ncr(n, r, mod=None):\n    \"\"\"\n    scipy.misc.comb または scipy.special.comb と同じ\n    組み合わせの数 nCr\n    :param int n:\n    :param int r:\n    :param int mod: 3 以上の素数であること\n    :rtype: int\n    \"\"\"\n    if n < r:\n        return 0\n\n    return factorials[n] * mod_inv(factorials[r], mod) * mod_inv(factorials[n - r], mod) % mod\n\n\n# 合計が M*3 となる数列の数\nc1 = ncr(M * 3 + N - 1, N - 1, MOD)\n# max が M*2 より大きい数列の数を引く\nc2 = 0\nfor m in range(M * 2 + 1, M * 3 + 1):\n    s = M * 3 - m\n    c2 += ncr(s + N - 2, N - 2, MOD) * N\n    c2 %= MOD\nprint((c1 - c2) % MOD)\n"
  },
  {
    "language": "Python",
    "code": "p, q = map(int,input().split())\nmod = 998244353\n\n\ndef comb(n,k):\n  \"\"\"power_funcを用いて(nCk) mod p を求める\"\"\"\n  from math import factorial\n  if n<0 or k<0 or n<k: return 0\n  if n==0 or k==0: return 1\n  a = factorial(n) % mod\n  b = factorial(k) % mod\n  c = factorial(n - k) % mod\n  return (a*power_func(b,mod-2)*power_func(c,mod-2))%mod\ndef power_func(a,b):\n  \"\"\"a^b mod p を求める\"\"\"\n  if b==0: return 1\n  if b%2==0:\n    d=power_func(a,b//2)\n    return d*d %mod\n  if b%2==1:\n    return (a*power_func(a,b-1))%mod\n\nans = comb(p+q*3-1, p-1)\nnow = 1\nfor i in range(q):\n    if i == 0:\n        ans -= now*p\n    else:\n        now = (now*(i+p-2)/i)%mod\n        ans -= (now*p)%mod\n\nprint(int(ans%mod))"
  },
  {
    "language": "Python",
    "code": "n,m=map(int,input().split())\no,f,i=998244353,[1],1\nwhile i<3*m+n:f+=[f[-1]*i%o];i+=1\nc=lambda x,y=n-1:f[x]*pow(f[x-y]*f[y]%o,o-2,o)\na=c(-1)-n*c(n+m-2)\nwhile~-n>m<i-n:m+=2;a-=c(n,m)*c(n-1+i-m>>1)\nprint(a%o)"
  },
  {
    "language": "Python",
    "code": "from functools import lru_cache\nimport sys\n\nsys.setrecursionlimit(10 ** 7 + 10)\n\n\ndef prepare(n, MOD):\n    f = 1\n    factorials = [1]\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    inv = pow(f, MOD - 2, MOD)\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n\n    return factorials, invs\n\n\n@lru_cache(maxsize=None)\ndef pattern(t, k, x):\n    # print('', t, k, x)\n    if k * x < t:\n        # print(t, k, x, 0)\n        return 0\n    if k * x == t or t == 0 or k == 1:\n        # print(t, k, x, 1)\n        return 1\n    ans = pattern(t, k, x - 1)\n    # print(f'  ({t} {k} {x} 0 {ans})')\n    for i in range(1, t // x + 1):\n        ans = (ans + pattern(t - x * i, k - i, x - 1) * facts[k] * invs[i] * invs[k - i]) % MOD\n        # print(f'  ({t} {k} {x} {i} {ans})')\n\n    # print(t, k, x, ans)\n    return ans\n\n\nMOD = 998244353\nn, m = list(map(int, input().split()))\nfacts, invs = prepare(n, MOD)\nprint(pattern(3 * m, n, 2 * m))\n"
  },
  {
    "language": "Python",
    "code": "N, M = map(int, input().split())\n\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\nmod = 998244353\nn = 3*10**6+10\ng1 = [1, 1]\ng2 = [1, 1] #逆元テーブル\ninverse = [0, 1] #逆元テーブル計算用テーブル\n\nfor i in range( 2, n + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\n\nans = cmb(M*3+N-1, N-1, mod)\nfor i in range(M*2+1, M*3+1):\n    ans -= cmb(M*3-i+(N-1)-1, N-2, mod) * N + mod*mod\n    ans = (ans+mod)%mod\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "N, M = map(int, input().split())\nMOD = 998244353\n\nif N < M :\n    one = N - M % 2\n    two = (3 * M - one) // 2\nelse :\n    one, two = M, M\n    \nL = M + M // 2 + N - 1\n\nfac = [0] * (L + 1)\ninv = [0] * (L + 1)\nfac[0], inv[0] = 1, 1\n\nfor i in range(1, L + 1) :\n    fac[i] = fac[i-1] * i % MOD\n    inv[i] = pow(fac[i], MOD-2, MOD)\n\ndef comb(n, r) :\n    if n <= 0 or r < 0 :\n        return 0\n    return fac[n]*inv[n-r]*inv[r]%MOD\n\nret = 0\nwhile one >= 0 :\n    ret += comb(N, one) * comb(two+N-1, N-1) % MOD\n    ret %= MOD\n    one -= 2\n    two += 1\n \nret -= comb(3*M+N-1-(2*M+1), N-1) * N\nprint(ret % MOD)"
  },
  {
    "language": "Python",
    "code": "o,f=998244353,[1]\nfor i in range(1,2500100):f.append(f[-1]*i%o)\ndef c(n,k):return f[n]*pow(f[n-k],o-2,o)*pow(f[k],o-2,o)\nn,m=map(int,input().split())\nw,u=3*m,n-1\na=c(w+u,u)-n*c(n+m-2,u)\nif u>m:\n for i in range(m+1,min(w,n)+1):\n  if w-i+1&1:a-=c(n,i)*c((w-i)//2+u,u)\nprint(a%o)"
  },
  {
    "language": "Python",
    "code": "o=998244353\nf=[1]\nfor i in range(1,2500100):f.append(f[-1]*i%o)\ndef c(n,k):return f[n]*pow(f[n-k],o-2,o)*pow(f[k],o-2,o)\nn,m=map(int,input().split())\nw=3*m\nu=n-1\na=c(w+u,u)-n*c(n+m-2,u)\nif u>m:\n for i in range(m+1,min(w,n)+1):\n  if w-i+1&1:a=(a-c(n,i)*c((w-i)//2+u,u))%o\nprint(a%o)"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\nmod = 998244353\n\n#################################\n\n## nCkのmodを求める関数\n# テーブルを作る(前処理)\nmax = n+3*m + 100\nfac, finv, inv = [0]*max, [0]*max, [0]*max\n\ndef comInit(max):\n    fac[0] = fac[1] = 1\n    finv[0] = finv[1] = 1\n    inv[1] = 1\n\n    for i in range(2,max):\n      fac[i] = fac[i-1]* i% mod\n      inv[i] = mod - inv[mod%i] * (mod // i) % mod\n      finv[i] = finv[i-1] * inv[i] % mod\n\ncomInit(max)\n\n# 二項係数の計算\ndef com(n,k):\n    if(n < k):\n        return 0\n    if( (n<0) | (k < 0)):\n        return 0\n    return fac[n] * (finv[k] * finv[n-k] % mod) % mod\n\n\na = fac[n-1+3*m] * finv[n-1] * finv[3*m]\na %= mod\nb = fac[n-1+m-1] * finv[n-1] * finv[m-1] * n\nb %= mod\nc = 0\nfor i in range(2*m+1,min(3*m,n)+1):\n    c += fac[3*m-1]*finv[i-1]*finv[3*m-i]*com(n,i)\n    c %= mod\n\nd = 0\nk = min(n,2*m)\nfor i in range(m+1,k+1):\n    if(3*m-i)%2==1:\n        continue\n    l = (3*m-i)//2\n    d += com(n,i) * fac[n+l-1]*finv[l]*finv[n-1]\n    d %= mod\n\nans = a-b-c-d\nans %= mod\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\nmod = 998244353\n\n#################################\n\n## nCkのmodを求める関数\n# テーブルを作る(前処理)\nmax = n+3*m + 100\nfac, finv, inv = [0]*max, [0]*max, [0]*max\n\ndef comInit(max):\n    fac[0] = fac[1] = 1\n    finv[0] = finv[1] = 1\n    inv[1] = 1\n\n    for i in range(2,max):\n      fac[i] = fac[i-1]* i% mod\n      inv[i] = mod - inv[mod%i] * (mod // i) % mod\n      finv[i] = finv[i-1] * inv[i] % mod\n\ncomInit(max)\n\n# 二項係数の計算\ndef com(n,k):\n    if(n < k):\n        return 0\n    if( (n<0) | (k < 0)):\n        return 0\n    return fac[n] * (finv[k] * finv[n-k] % mod) % mod\n\n\na = fac[n-1+3*m] * finv[n-1] * finv[3*m]\na %= mod\nb = fac[n-1+m-1] * finv[n-1] * finv[m-1] * n\nb %= mod\nc = 0\nfor i in range(2*m+1,min(3*m,n)+1):\n    c += fac[3*m-1]*finv[i-1]*finv[3*m-i]*com(n,i)\n    c %= mod\n\nd = 0\nk = min(n,2*m)\nfor i in range(m+1,k+1):\n    if(3*m-i)%2==1:\n        continue\n    l = (3*m-i)//2\n    d += com(n,k) * com(k,i) * fac[k+l-1]*finv[l]*finv[k-1]\n    d %= mod\n\nans = a-b-c-d\nans %= mod\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "mod = 998244353\n\ndef cmb(n, r):\n    if r > n - r:\n        r = n - r\n    if r < 2:\n        return n ** r\n\n    numerator = [n - r + k + 1 for k in range(r)]\n    denominator = [k + 1 for k in range(r)]\n\n    for p in range(2, r+1):\n        pivot = denominator[p - 1]\n        if pivot > 1:\n            offset = (n - r) % p\n            for k in range(p-1, r, p):\n                numerator[k - offset] //= pivot\n                denominator[k] //= pivot\n\n    result = 1\n    for k in range(r):\n        if numerator[k] > 1:\n            result = (result * numerator[k]) % mod\n    return result\n\nn, m = map(int, input().split())\n\nprint((cmb(3 * m + n - 1, n - 1) - n * cmb(m + n - 2, n - 1)) % mod)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nimport numpy as np\n\nN,M = map(int,input().split())\nMOD = 998244353\n\ndef cumprod_mod(arr):\n    L = len(arr)\n    Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    arr = arr.ravel()[:L]\n    return arr\n\nU = 2*10**6 + 100\nx = np.arange(U,dtype=np.int64)\nx[0] = 1\nfact = cumprod_mod(x)\n\nx = np.arange(U,0,-1,dtype=np.int64)\nx[0] = pow(int(fact[-1]),MOD-2,MOD)\nfact_inv = cumprod_mod(x)[::-1]\n\ndef comb(n,k):\n    return fact[n] * fact_inv[k] % MOD * fact_inv[n-k] % MOD\n\nx = comb(3*M+N-1,N-1) # 何でもいいから作る\ny = N * comb(M+N-2,N-1) # どれかが 2M+1 以上\n\n# 奇数がM+1個以上あるものを除く\nodd_cnt = np.arange(M+2,3*M+1,2)\nS = (3*M - odd_cnt)//2\nbl = (odd_cnt <= N)&(S>=0)\nodd_cnt = odd_cnt[bl]\nS = S[bl]\narr = fact[N] * fact_inv[odd_cnt] % MOD * fact_inv[N-odd_cnt] % MOD\n# SをN個で作る -> S+N-1 C N-1\narr *= fact[S+N-1] * fact_inv[N-1] % MOD * fact_inv[S] % MOD\narr %= MOD\nz = arr.sum() % MOD\n\nanswer = x-y-z\nanswer %= MOD\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nimport math\nfrom bisect import bisect_left, bisect_right\nimport random\nfrom itertools import permutations, accumulate, combinations\nimport sys\nimport string\n\n\n\nINF = float('inf')\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return sys.stdin.readline().strip()\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\nmod = 998244353\n\n\nn, m = LI()\ntotal = m * 3\n\n\nfac = [1] * (total + n)\ninv = [1] * (total + n)\ni = 1\nfor j in range(1, total + n):\n    i = i * j % mod\n    fac[j] = i\n    inv[j] = pow(i, mod - 2, mod)\n\n\n\ndef comb(n, r):\n    if r > n:\n        return 0\n    return fac[n] * inv[n - r] * inv[r] % mod\n\n\n\nans = comb(total + n - 1, n - 1)\nfor i in range(m + 2, min(n + 1, total + 1)):\n    if (total - i) % 2 == 0:\n        ans -= comb(n, i) * comb(n + (total - i) // 2 - 1, n - 1) % mod\n        ans %= mod\n\n\nret = 0\nfor i in range(m):\n    ret = (ret + comb(i + n - 2, n - 2)) % mod\n\n\nans -= (ret * n) % mod\nprint(ans % mod)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nimport math\nfrom bisect import bisect_left, bisect_right\nimport random\nfrom itertools import permutations, accumulate, combinations\nimport sys\nimport string\n\n\n\nINF = float('inf')\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return sys.stdin.readline().strip()\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\nmod = 998244353\n\n\nn, m = LI()\ntotal = m * 3\n\n\nfac = [1] * (total + n)\ninv = [1] * (total + n)\ni = 1\nfor j in range(1, total + n):\n    i = i * j % mod\n    fac[j] = i\n    inv[j] = pow(i, mod - 2, mod)\n\n\n\ndef comb(n, r):\n    if r > n or n < 0 or r < 0:\n        return 0\n    return fac[n] * inv[n - r] * inv[r] % mod\n\n\n\nimpossible = 0\nfor i in range(m + 2, total + 1, 2):\n    impossible = (impossible + comb(n, i) * comb(n + (total - i) // 2 - 1, n - 1) % mod) % mod\n\n\nret = 0\nfor i in range(m):\n    ret = (ret + comb(i + n - 2, n - 2)) % mod\n\n\nimpossible = (impossible + ret * n) % mod\n\n\nret = 0\nprint((comb(total + n - 1, n - 1) - impossible) % mod)"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/agc036/tasks/agc036_c\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::io::Write;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\n// Input macros.\n// Original by tanakh: https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n\n    ($iter:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, switch) => {\n        {\n            let ty = read_value!($iter, i32);\n            if ty == 1 {\n                vec![ty, read_value!($iter, i32), read_value!($iter, i32)]\n            } else if ty == 2 {\n                vec![ty, read_value!($iter, i32)]\n            } else {\n                vec![ty, read_value!($iter, i32)]\n            }\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_line {\n    ($t:tt) => {\n        {\n            let mut s = String::new();\n            std::io::stdin().read_line(&mut s).unwrap();\n            s.trim_right().parse::<$t>().unwrap()\n        }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! join {\n    ($t:expr, $glue:expr) => {\n        $t.into_iter().map(|w| w.to_string()).collect::<Vec<_>>().join($glue)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n// ===\n\nstruct Combination {\n    fact: Vec<i64>,\n    invfact: Vec<i64>,\n}\n\nimpl Combination {\n    fn inv(a: i64) -> i64 {\n        Combination::pow(a, MOD - 2)\n    }\n\n    fn pow(a: i64, p: i64) -> i64 {\n        let mut p = p;\n        let mut aa = a;\n        let mut ret = 1;\n        while p >= 1 {\n            if p & 1 == 1 {\n                ret *= aa;\n                ret %= MOD;\n            }\n            p >>= 1;\n            aa = aa * aa % MOD;\n        }\n        ret\n    }\n\n    fn new(upto: usize) -> Self {\n        let mut fact = vec![0; upto];\n        let mut invfact = vec![0; upto];\n\n        fact[0] = 1;\n        for i in 1..upto {\n            fact[i] = fact[i - 1] * (i as i64) % MOD;\n        }\n\n        invfact[upto - 1] = Combination::inv(fact[upto - 1]);\n        invfact[0] = 1;\n        for i in (1..upto - 1).rev() {\n            invfact[i] = invfact[i + 1] * ((i + 1) as i64) % MOD;\n        }\n\n        Combination {\n            fact: fact,\n            invfact: invfact,\n        }\n    }\n\n    fn comb(&self, n: usize, r: usize) -> i64 {\n        if r < 0 || r > n {\n            return 0;\n        }\n        self.fact[n] * self.invfact[r] % MOD * self.invfact[n - r] % MOD\n    }\n}\n\n//===\n\nconst MOD: i64 = 998244353;\n\nfn main() {\n    input! {\n        n: usize, m: usize\n    };\n\n    let comb = Combination::new(4_000_000);\n\n    let mut total = 0;\n    for i in 0..n+1 {\n        if i % 2 != m % 2 {\n            continue;\n        }\n        if i > m {\n            break;\n        }\n        let one = comb.comb(n, i);\n        let two = m + (m - i) / 2;\n        let ban_one = (i as i64) * comb.comb(two - m + n - 1, n - 1) % MOD;\n        let ban_two = ((n - i) as i64) * comb.comb(n + two - m - 2, n - 1) % MOD; // n >= 2, two >= m\n        total += one * (comb.comb(two + n - 1, n - 1) + MOD + MOD - ban_one - ban_two) % MOD;\n        total %= MOD;\n    }\n    println!(\"{}\", total);\n}\n"
  },
  {
    "language": "Rust",
    "code": "pub trait Readable {\n    type Output;\n    fn words_count() -> usize;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String>;\n}\n#[macro_export]\nmacro_rules! readable {\n    ( $ t : ty , $ words_count : expr , |$ words : ident | $ read_words : expr ) => {\n        impl Readable for $t {\n            type Output = $t;\n            fn words_count() -> usize {\n                $words_count\n            }\n            fn read_words($words: &[&str]) -> Result<$t, String> {\n                Ok($read_words)\n            }\n        }\n    };\n}\nreadable!((), 1, |_ss| ());\nreadable!(String, 1, |ss| ss[0].to_string());\nimpl Readable for char {\n    type Output = char;\n    fn words_count() -> usize {\n        1\n    }\n    fn read_words(words: &[&str]) -> Result<char, String> {\n        let chars: Vec<char> = words[0].chars().collect();\n        if chars.len() == 1 {\n            Ok(chars[0])\n        } else {\n            Err(format!(\"cannot parse `{}` as a char\", words[0]))\n        }\n    }\n}\npub struct Chars();\nimpl Readable for Chars {\n    type Output = Vec<char>;\n    fn words_count() -> usize {\n        1\n    }\n    fn read_words(words: &[&str]) -> Result<Vec<char>, String> {\n        Ok(words[0].chars().collect())\n    }\n}\nmacro_rules ! impl_readable_for_ints { ( $ ( $ t : ty ) * ) => { $ ( impl Readable for $ t { type Output = Self ; fn words_count ( ) -> usize { 1 } fn read_words ( words : & [ & str ] ) -> Result <$ t , String > { use std :: str :: FromStr ; <$ t >:: from_str ( words [ 0 ] ) . map_err ( | _ | { format ! ( \"cannot parse `{}` as {}\" , words [ 0 ] , stringify ! ( $ t ) ) } ) } } ) * } ; }\nimpl_readable_for_ints ! ( i8 u8 i16 u16 i32 u32 i64 u64 isize usize f32 f64 ) ;\nmacro_rules ! define_one_origin_int_types { ( $ new_t : ident $ int_t : ty ) => { # [ doc = \" Converts 1-origin integer into 0-origin when read from stdin.\" ] # [ doc = \"\" ] # [ doc = \" # Example\" ] # [ doc = \"\" ] # [ doc = \" ```no_run\" ] # [ doc = \" # #[macro_use] extern crate atcoder_snippets;\" ] # [ doc = \" # use atcoder_snippets::read::*;\" ] # [ doc = \" // Stdin: \\\"1\\\"\" ] # [ doc = \" read!(a = usize_);\" ] # [ doc = \" assert_eq!(a, 0);\" ] # [ doc = \" ```\" ] # [ allow ( non_camel_case_types ) ] pub struct $ new_t ; impl Readable for $ new_t { type Output = $ int_t ; fn words_count ( ) -> usize { 1 } fn read_words ( words : & [ & str ] ) -> Result < Self :: Output , String > { <$ int_t >:: read_words ( words ) . map ( | n | n - 1 ) } } } ; ( $ new_t : ident $ int_t : ty ; $ ( $ inner_new_t : ident $ inner_int_t : ty ) ;* ) => { define_one_origin_int_types ! ( $ new_t $ int_t ) ; define_one_origin_int_types ! ( $ ( $ inner_new_t $ inner_int_t ) ;* ) ; } ; }\ndefine_one_origin_int_types ! ( u8_ u8 ; u16_ u16 ; u32_ u32 ; u64_ u64 ; usize_ usize ) ;\nmacro_rules ! impl_readable_for_tuples { ( $ t : ident $ var : ident ) => ( ) ; ( $ t : ident $ var : ident ; $ ( $ inner_t : ident $ inner_var : ident ) ;* ) => { impl_readable_for_tuples ! ( $ ( $ inner_t $ inner_var ) ;* ) ; impl <$ t : Readable , $ ( $ inner_t : Readable ) ,*> Readable for ( $ t , $ ( $ inner_t ) ,* ) { type Output = ( <$ t >:: Output , $ ( <$ inner_t >:: Output ) ,* ) ; fn words_count ( ) -> usize { let mut n = <$ t >:: words_count ( ) ; $ ( n += <$ inner_t >:: words_count ( ) ; ) * n } # [ allow ( unused_assignments ) ] fn read_words ( words : & [ & str ] ) -> Result < Self :: Output , String > { let mut start = 0 ; let $ var = <$ t >:: read_words ( & words [ start .. start +<$ t >:: words_count ( ) ] ) ?; start += <$ t >:: words_count ( ) ; $ ( let $ inner_var = <$ inner_t >:: read_words ( & words [ start .. start +<$ inner_t >:: words_count ( ) ] ) ?; start += <$ inner_t >:: words_count ( ) ; ) * Ok ( ( $ var , $ ( $ inner_var ) ,* ) ) } } } ; }\nimpl_readable_for_tuples ! ( T8 x8 ; T7 x7 ; T6 x6 ; T5 x5 ; T4 x4 ; T3 x3 ; T2 x2 ; T1 x1 ) ;\npub trait ReadableFromLine {\n    type Output;\n    fn read_line(line: &str) -> Result<Self::Output, String>;\n}\nfn split_into_words(line: &str) -> Vec<&str> {\n    #[allow(deprecated)]\n    line.trim_right_matches('\\n').split_whitespace().collect()\n}\nimpl<T: Readable> ReadableFromLine for T {\n    type Output = T::Output;\n    fn read_line(line: &str) -> Result<T::Output, String> {\n        let words = split_into_words(line);\n        if words.len() != T::words_count() {\n            return Err(format!(\n                \"line `{}` has {} words, expected {}\",\n                line,\n                words.len(),\n                T::words_count()\n            ));\n        }\n        T::read_words(&words)\n    }\n}\nmacro_rules ! impl_readable_from_line_for_tuples_with_from_iterator { ( $ u : ident : $ ( + $ bound : path ) * => $ seq_in : ty , $ seq_out : ty ; $ t : ident $ var : ident ) => { impl <$ u : Readable > ReadableFromLine for $ seq_in where <$ u as Readable >:: Output : Sized $ ( + $ bound ) * { type Output = $ seq_out ; fn read_line ( line : & str ) -> Result <$ seq_out , String > { let n = $ u :: words_count ( ) ; let words = split_into_words ( line ) ; if words . len ( ) % n != 0 { return Err ( format ! ( \"line `{}` has {} words, expected multiple of {}\" , line , words . len ( ) , n ) ) ; } let mut result = Vec :: new ( ) ; for chunk in words . chunks ( n ) { match $ u :: read_words ( chunk ) { Ok ( v ) => result . push ( v ) , Err ( msg ) => { let flagment_msg = if n == 1 { format ! ( \"word {}\" , result . len ( ) ) } else { let l = result . len ( ) ; format ! ( \"words {}-{}\" , n * l + 1 , ( n + 1 ) * l ) } ; return Err ( format ! ( \"{} of line `{}`: {}\" , flagment_msg , line , msg ) ) ; } } } Ok ( result . into_iter ( ) . collect ( ) ) } } impl < T : Readable , $ u : Readable > ReadableFromLine for ( T , $ seq_in ) where <$ u as Readable >:: Output : Sized $ ( + $ bound ) * { type Output = ( T :: Output , $ seq_out ) ; fn read_line ( line : & str ) -> Result < Self :: Output , String > { let n = T :: words_count ( ) ; # [ allow ( deprecated ) ] let trimmed = line . trim_right_matches ( '\\n' ) ; let words_and_rest : Vec <& str > = trimmed . splitn ( n + 1 , ' ' ) . collect ( ) ; if words_and_rest . len ( ) < n { return Err ( format ! ( \"line `{}` has {} words, expected at least {}\" , line , words_and_rest . len ( ) , n ) ) ; } let words = & words_and_rest [ .. n ] ; let empty_str = \"\" ; let rest = words_and_rest . get ( n ) . unwrap_or ( & empty_str ) ; Ok ( ( T :: read_words ( words ) ?, <$ seq_in >:: read_line ( rest ) ? ) ) } } } ; ( $ u : ident : $ ( + $ bound : path ) * => $ seq_in : ty , $ seq_out : ty ; $ t : ident $ var : ident , $ ( $ inner_t : ident $ inner_var : ident ) ,+ ) => { impl_readable_from_line_for_tuples_with_from_iterator ! ( $ u : $ ( + $ bound ) * => $ seq_in , $ seq_out ; $ ( $ inner_t $ inner_var ) ,+ ) ; impl <$ t : Readable , $ ( $ inner_t : Readable ) ,+ , $ u : Readable > ReadableFromLine for ( $ t , $ ( $ inner_t ) ,+ , $ seq_in ) where <$ u as Readable >:: Output : Sized $ ( + $ bound ) * { type Output = ( $ t :: Output , $ ( $ inner_t :: Output ) ,+ , $ seq_out ) ; fn read_line ( line : & str ) -> Result < Self :: Output , String > { let mut n = $ t :: words_count ( ) ; $ ( n += $ inner_t :: words_count ( ) ; ) + # [ allow ( deprecated ) ] let trimmed = line . trim_right_matches ( '\\n' ) ; let words_and_rest : Vec <& str > = trimmed . splitn ( n + 1 , ' ' ) . collect ( ) ; if words_and_rest . len ( ) < n { return Err ( format ! ( \"line `{}` has {} words, expected at least {}\" , line , words_and_rest . len ( ) , n ) ) ; } let words = & words_and_rest [ .. n ] ; let empty_str = \"\" ; let rest = words_and_rest . get ( n ) . unwrap_or ( & empty_str ) ; let ( $ var , $ ( $ inner_var ) ,* ) = < ( $ t , $ ( $ inner_t ) ,+ ) >:: read_words ( words ) ?; Ok ( ( $ var , $ ( $ inner_var ) ,* , <$ seq_in >:: read_line ( rest ) ? ) ) } } } ; }\n#[macro_export]\nmacro_rules ! readable_collection { ( $ u : ident => $ collection_in : ty , $ collection_out : ty ) => { impl_readable_from_line_for_tuples_with_from_iterator ! ( $ u : => $ collection_in , $ collection_out ; T8 x8 , T7 x7 , T6 x6 , T5 x5 , T4 t4 , T3 t3 , T2 t2 , T1 t1 ) ; } ; ( $ u : ident : $ ( $ bound : path ) ,* => $ collection_in : ty , $ collection_out : ty ) => { impl_readable_from_line_for_tuples_with_from_iterator ! ( $ u : $ ( + $ bound ) * => $ collection_in , $ collection_out ; T8 x8 , T7 x7 , T6 x6 , T5 x5 , T4 t4 , T3 t3 , T2 t2 , T1 t1 ) ; } }\nreadable_collection ! ( U => Vec < U >, Vec < U :: Output > ) ;\nreadable_collection ! ( U : Eq , std :: hash :: Hash => std :: collections :: HashSet < U >, std :: collections :: HashSet < U :: Output > ) ;\npub fn read<T: ReadableFromLine>() -> T::Output {\n    let mut line = String::new();\n    std::io::stdin().read_line(&mut line).unwrap();\n    T::read_line(&line).unwrap()\n}\n#[macro_export]\nmacro_rules ! read { ( ) => { let mut line = String :: new ( ) ; std :: io :: stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; } ; ( $ pat : pat = $ t : ty ) => { let $ pat = read ::<$ t > ( ) ; } ; ( $ ( $ pat : pat = $ t : ty ) ,+ ) => { read ! ( ( $ ( $ pat ) ,* ) = ( $ ( $ t ) ,* ) ) ; } ; }\n#[macro_export]\nmacro_rules ! readls { ( $ ( $ pat : pat = $ t : ty ) ,+ ) => { $ ( read ! ( $ pat = $ t ) ; ) * } ; }\npub fn readx<T: ReadableFromLine>() -> Vec<T::Output> {\n    use std::io::{self, BufRead};\n    let stdin = io::stdin();\n    let result = stdin\n        .lock()\n        .lines()\n        .map(|line_result| {\n            let line = line_result.expect(\"read from stdin failed\");\n            T::read_line(&line).unwrap()\n        })\n        .collect();\n    result\n}\n#[macro_export]\nmacro_rules ! readx_loop { ( |$ pat : pat = $ t : ty | $ body : expr ) => { { use std :: io :: BufRead ; let stdin = std :: io :: stdin ( ) ; for line in stdin . lock ( ) . lines ( ) { let line = line . expect ( \"read from stdin failed\" ) ; let $ pat = <$ t >:: read_line ( & line ) . unwrap ( ) ; $ body } } } ; ( |$ ( $ pat : pat = $ t : ty ) ,*| $ body : expr ) => { readx_loop ! ( | ( $ ( $ pat ) ,* ) = ( $ ( $ t ) ,* ) | $ body ) ; } ; }\npub fn readn<T: ReadableFromLine>(n: usize) -> Vec<T::Output> {\n    use std::io::{self, BufRead};\n    let stdin = io::stdin();\n    let result: Vec<T::Output> = stdin\n        .lock()\n        .lines()\n        .take(n)\n        .map(|line_result| {\n            let line = line_result.expect(\"read from stdin failed\");\n            T::read_line(&line).unwrap()\n        })\n        .collect();\n    if result.len() < n {\n        panic!(\n            \"expected reading {} lines, but only {} lines are read\",\n            n,\n            result.len()\n        );\n    }\n    result\n}\n#[macro_export]\nmacro_rules ! readn_loop { ( $ n : expr , |$ pat : pat = $ t : ty | $ body : expr ) => { { use std :: io :: BufRead ; let stdin = std :: io :: stdin ( ) ; let mut lock = stdin . lock ( ) ; for _ in 0 ..$ n { let mut line = String :: new ( ) ; lock . read_line ( & mut line ) . expect ( \"read from stdin failed\" ) ; let $ pat = <$ t >:: read_line ( & line ) . unwrap ( ) ; $ body } } } ; ( $ n : expr , |$ ( $ pat : pat = $ t : ty ) ,*| $ body : expr ) => { readn_loop ! ( $ n , | ( $ ( $ pat ) ,* ) = ( $ ( $ t ) ,* ) | $ body ) ; } ; }\npub trait Words {\n    fn read<T: Readable>(&self) -> T::Output;\n}\nimpl<'a> Words for [&'a str] {\n    fn read<T: Readable>(&self) -> T::Output {\n        T::read_words(self).unwrap()\n    }\n}\nimpl<'a> Words for &'a str {\n    fn read<T: Readable>(&self) -> T::Output {\n        T::read_words(&[self]).unwrap()\n    }\n}\n\npub type ModPBase = u64;\npub type ModPModulus = u32;\nstatic mut MODULUS: ModPBase = 0;\n#[derive(Clone, Copy, PartialEq, Eq)]\npub struct ModP {\n    base: ModPBase,\n}\nimpl ModP {\n    pub unsafe fn set_mod(modulus: ModPModulus) -> Result<(), String> {\n        if modulus <= 1 {\n            return Err(format!(\"{} is not a prime number.\", modulus));\n        }\n        if modulus >= 4 {\n            if modulus % 2 == 0 || modulus % 3 == 0 {\n                return Err(format!(\"{} is not a prime number.\", modulus));\n            }\n            let mut divisor = 5;\n            loop {\n                if divisor * divisor > modulus {\n                    break;\n                }\n                if modulus % divisor == 0 {\n                    return Err(format!(\"{} is not a prime number.\", modulus));\n                }\n                divisor += 2;\n                if divisor * divisor > modulus {\n                    break;\n                }\n                if modulus % divisor == 0 {\n                    return Err(format!(\"{} is not a prime number.\", modulus));\n                }\n                divisor += 4;\n            }\n        }\n        MODULUS = modulus as ModPBase;\n        Ok(())\n    }\n    pub fn new(n: ModPBase) -> ModP {\n        if !cfg!(test) {\n            assert!(\n                unsafe { MODULUS } != 0,\n                \"Call ModP::set_mod before using ModP.\"\n            );\n        }\n        ModP {\n            base: n % unsafe { MODULUS },\n        }\n    }\n    pub unsafe fn new_unchecked(n: ModPBase) -> ModP {\n        ModP { base: n }\n    }\n    pub fn base(&self) -> ModPBase {\n        self.base\n    }\n    pub fn pow(self, exp: ModPBase) -> ModP {\n        if exp == 0 {\n            ModP::new(1)\n        } else {\n            let sub = self.pow(exp / 2);\n            if exp % 2 == 0 {\n                sub * sub\n            } else {\n                self * sub * sub\n            }\n        }\n    }\n    pub fn inv(self) -> ModP {\n        assert!(self.base() != 0);\n        self.pow(unsafe { MODULUS } - 2)\n    }\n}\npub fn modp(x: ModPBase) -> ModP {\n    ModP::new(x)\n}\nimpl std::fmt::Display for ModP {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"{}\", self.base())\n    }\n}\nimpl std::fmt::Debug for ModP {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"{} mod P\", self.base())\n    }\n}\nimpl PartialEq<ModPBase> for ModP {\n    fn eq(&self, other: &ModPBase) -> bool {\n        self.base() == other % unsafe { MODULUS }\n    }\n}\nimpl PartialEq<ModP> for ModPBase {\n    fn eq(&self, other: &ModP) -> bool {\n        self % unsafe { MODULUS } == other.base() % unsafe { MODULUS }\n    }\n}\nimpl std::ops::Add for ModP {\n    type Output = ModP;\n    fn add(self, rhs: ModP) -> ModP {\n        let m = unsafe { MODULUS };\n        ModP {\n            base: (self.base() + rhs.base() % m) % m,\n        }\n    }\n}\nimpl std::ops::Add<ModPBase> for ModP {\n    type Output = ModP;\n    fn add(self, rhs: ModPBase) -> ModP {\n        self + ModP::new(rhs)\n    }\n}\nimpl std::ops::Add<ModP> for ModPBase {\n    type Output = ModP;\n    fn add(self, rhs: ModP) -> ModP {\n        ModP::new(self) + rhs.base()\n    }\n}\nimpl std::ops::AddAssign for ModP {\n    fn add_assign(&mut self, rhs: ModP) {\n        *self = *self + rhs\n    }\n}\nimpl std::ops::AddAssign<ModPBase> for ModP {\n    fn add_assign(&mut self, rhs: ModPBase) {\n        *self = *self + ModP::new(rhs)\n    }\n}\nimpl std::ops::Neg for ModP {\n    type Output = ModP;\n    fn neg(self) -> ModP {\n        ModP::new(unsafe { MODULUS } - self.base())\n    }\n}\nimpl std::ops::Sub for ModP {\n    type Output = ModP;\n    fn sub(self, rhs: ModP) -> ModP {\n        self + (-rhs)\n    }\n}\nimpl std::ops::Sub<ModPBase> for ModP {\n    type Output = ModP;\n    fn sub(self, rhs: ModPBase) -> ModP {\n        self - ModP::new(rhs)\n    }\n}\nimpl std::ops::Sub<ModP> for ModPBase {\n    type Output = ModP;\n    fn sub(self, rhs: ModP) -> ModP {\n        ModP::new(self) - rhs\n    }\n}\nimpl std::ops::SubAssign for ModP {\n    fn sub_assign(&mut self, rhs: ModP) {\n        *self = *self - rhs;\n    }\n}\nimpl std::ops::SubAssign<ModPBase> for ModP {\n    fn sub_assign(&mut self, rhs: ModPBase) {\n        *self = *self - ModP::new(rhs)\n    }\n}\nimpl std::ops::Mul for ModP {\n    type Output = ModP;\n    fn mul(self, rhs: ModP) -> ModP {\n        let m = unsafe { MODULUS };\n        ModP {\n            base: self.base() * (rhs.base() % m) % m,\n        }\n    }\n}\nimpl std::ops::Mul<ModPBase> for ModP {\n    type Output = ModP;\n    fn mul(self, rhs: ModPBase) -> ModP {\n        self * ModP::new(rhs)\n    }\n}\nimpl std::ops::Mul<ModP> for ModPBase {\n    type Output = ModP;\n    fn mul(self, rhs: ModP) -> ModP {\n        ModP::new(self) * rhs.base()\n    }\n}\nimpl std::ops::MulAssign for ModP {\n    fn mul_assign(&mut self, rhs: ModP) {\n        *self = *self * rhs\n    }\n}\nimpl std::ops::MulAssign<ModPBase> for ModP {\n    fn mul_assign(&mut self, rhs: ModPBase) {\n        *self = *self * ModP::new(rhs)\n    }\n}\nimpl std::ops::Div for ModP {\n    type Output = ModP;\n    fn div(self, rhs: ModP) -> ModP {\n        self * rhs.inv()\n    }\n}\nimpl std::ops::Div<ModPBase> for ModP {\n    type Output = ModP;\n    fn div(self, rhs: ModPBase) -> ModP {\n        self * ModP::new(rhs).inv()\n    }\n}\nimpl std::ops::Div<ModP> for ModPBase {\n    type Output = ModP;\n    fn div(self, rhs: ModP) -> ModP {\n        ModP::new(self) * rhs.inv()\n    }\n}\nimpl std::ops::DivAssign for ModP {\n    fn div_assign(&mut self, rhs: ModP) {\n        *self = *self / rhs;\n    }\n}\nimpl std::ops::DivAssign<ModPBase> for ModP {\n    fn div_assign(&mut self, rhs: ModPBase) {\n        *self = *self / ModP::new(rhs)\n    }\n}\nimpl std::iter::Sum for ModP {\n    fn sum<I: Iterator<Item = ModP>>(iter: I) -> ModP {\n        let mut ans = 0;\n        for n in iter {\n            ans += n.base();\n        }\n        ModP::new(ans)\n    }\n}\nimpl<'a> std::iter::Sum<&'a ModP> for ModP {\n    fn sum<I: Iterator<Item = &'a ModP>>(iter: I) -> ModP {\n        let mut ans = 0;\n        for n in iter {\n            ans += n.base();\n        }\n        ModP::new(ans)\n    }\n}\nimpl std::iter::Product for ModP {\n    fn product<I: Iterator<Item = ModP>>(iter: I) -> ModP {\n        let mut ans = unsafe { ModP::new_unchecked(1) };\n        for n in iter {\n            ans *= n;\n        }\n        ans\n    }\n}\nimpl<'a> std::iter::Product<&'a ModP> for ModP {\n    fn product<I: Iterator<Item = &'a ModP>>(iter: I) -> ModP {\n        let mut ans = unsafe { ModP::new_unchecked(1) };\n        for &n in iter {\n            ans *= n;\n        }\n        ans\n    }\n}\nreadable!(ModP, 1, |ws| ModP::new(ws[0].read::<ModPBase>()));\n\n#[derive(Clone)]\npub struct StepBy<I> {\n    iter: I,\n    step: usize,\n    first_take: bool,\n}\nimpl<I: Iterator> Iterator for StepBy<I> {\n    type Item = I::Item;\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.first_take {\n            self.first_take = false;\n            self.iter.next()\n        } else {\n            self.iter.nth(self.step)\n        }\n    }\n}\npub struct Chunks<I: Iterator> {\n    iter: I,\n    size: usize,\n}\nimpl<I: Iterator> Iterator for Chunks<I> {\n    type Item = Vec<I::Item>;\n    fn next(&mut self) -> Option<Self::Item> {\n        let first = self.iter.next();\n        if first.is_none() {\n            return None;\n        }\n        let mut chunk = Vec::with_capacity(self.size);\n        chunk.push(first.unwrap());\n        for _ in 0..self.size - 1 {\n            match self.iter.next() {\n                Some(x) => chunk.push(x),\n                None => break,\n            }\n        }\n        Some(chunk)\n    }\n}\n#[derive(Clone)]\npub struct LScan<I: Iterator, S: Clone, F: FnMut(&S, I::Item) -> S> {\n    iter: I,\n    state: Option<S>,\n    f: F,\n}\nimpl<I: Iterator, S: Clone, F> Iterator for LScan<I, S, F>\nwhere\n    F: FnMut(&S, I::Item) -> S,\n{\n    type Item = S;\n    fn next(&mut self) -> Option<S> {\n        if self.state.is_none() {\n            return None;\n        }\n        let state_inner = self.state.take().unwrap();\n        if let Some(item) = self.iter.next() {\n            self.state = Some((self.f)(&state_inner, item));\n        }\n        Some(state_inner)\n    }\n}\npub struct Flatten<I: Iterator>\nwhere\n    I::Item: IntoIterator,\n{\n    outer_iter: I,\n    inner_iter: Option<<<I as Iterator>::Item as IntoIterator>::IntoIter>,\n}\nimpl<I, J> Iterator for Flatten<I>\nwhere\n    I: Iterator<Item = J>,\n    J: IntoIterator,\n{\n    type Item = <<J as IntoIterator>::IntoIter as Iterator>::Item;\n    fn next(&mut self) -> Option<J::Item> {\n        loop {\n            if let Some(inner_iter) = self.inner_iter.as_mut() {\n                if let item @ Some(_) = inner_iter.next() {\n                    return item;\n                }\n            }\n            match self.outer_iter.next() {\n                None => return None,\n                Some(inner) => self.inner_iter = Some(inner.into_iter()),\n            }\n        }\n    }\n}\npub struct GroupBy<K: Eq, I: Iterator, F: FnMut(&I::Item) -> K> {\n    cur: Option<(I::Item, K)>,\n    iter: I,\n    key_fn: F,\n}\nimpl<K: Eq, I: Iterator, F: FnMut(&I::Item) -> K> Iterator for GroupBy<K, I, F> {\n    type Item = (K, Vec<I::Item>);\n    fn next(&mut self) -> Option<(K, Vec<I::Item>)> {\n        let cur = self.cur.take();\n        cur.map(|(item, key)| {\n            let mut group = vec![item];\n            loop {\n                let next = self.iter.next();\n                match next {\n                    Some(next_item) => {\n                        let next_key = (self.key_fn)(&next_item);\n                        if key == next_key {\n                            group.push(next_item);\n                        } else {\n                            self.cur = Some((next_item, next_key));\n                            break;\n                        }\n                    }\n                    None => {\n                        self.cur = None;\n                        break;\n                    }\n                }\n            }\n            (key, group)\n        })\n    }\n}\npub struct RunLength<I: Iterator> {\n    cur: Option<I::Item>,\n    iter: I,\n}\nimpl<I: Iterator> Iterator for RunLength<I>\nwhere\n    I::Item: Eq,\n{\n    type Item = (I::Item, usize);\n    fn next(&mut self) -> Option<(I::Item, usize)> {\n        let cur = self.cur.take();\n        cur.map(|value| {\n            let mut length = 1;\n            loop {\n                let next = self.iter.next();\n                match next {\n                    Some(next_value) => {\n                        if value == next_value {\n                            length += 1;\n                        } else {\n                            self.cur = Some(next_value);\n                            break;\n                        }\n                    }\n                    None => {\n                        self.cur = None;\n                        break;\n                    }\n                }\n            }\n            (value, length)\n        })\n    }\n}\npub trait IteratorExt: Iterator {\n    fn step_by_(self, step: usize) -> StepBy<Self>\n    where\n        Self: Sized,\n    {\n        assert_ne!(step, 0);\n        StepBy {\n            iter: self,\n            step: step - 1,\n            first_take: true,\n        }\n    }\n    fn for_each<F: FnMut(Self::Item)>(self, mut f: F)\n    where\n        Self: Sized,\n    {\n        for item in self {\n            f(item);\n        }\n    }\n    fn chunks(self, size: usize) -> Chunks<Self>\n    where\n        Self: Sized,\n    {\n        assert!(size > 0);\n        Chunks {\n            iter: self,\n            size: size,\n        }\n    }\n    fn lscan<S: Clone, F>(self, state: S, f: F) -> LScan<Self, S, F>\n    where\n        Self: Sized,\n        F: FnMut(&S, Self::Item) -> S,\n    {\n        LScan {\n            iter: self,\n            state: Some(state),\n            f: f,\n        }\n    }\n    fn get_unique(mut self) -> Option<Self::Item>\n    where\n        Self: Sized,\n        Self::Item: Eq,\n    {\n        let first_opt = self.next();\n        first_opt.and_then(|first| {\n            if self.all(|item| item == first) {\n                Some(first)\n            } else {\n                None\n            }\n        })\n    }\n    fn flatten(mut self) -> Flatten<Self>\n    where\n        Self: Sized,\n        Self::Item: IntoIterator,\n    {\n        let inner_opt = self.next();\n        Flatten {\n            outer_iter: self,\n            inner_iter: inner_opt.map(|inner| inner.into_iter()),\n        }\n    }\n    fn group_by<K: Eq, F: FnMut(&Self::Item) -> K>(mut self, mut f: F) -> GroupBy<K, Self, F>\n    where\n        Self: Sized,\n    {\n        let next = self.next();\n        GroupBy {\n            cur: next.map(|item| {\n                let key = f(&item);\n                (item, key)\n            }),\n            iter: self,\n            key_fn: f,\n        }\n    }\n    fn run_length(mut self) -> RunLength<Self>\n    where\n        Self: Sized,\n        Self::Item: Eq,\n    {\n        RunLength {\n            cur: self.next(),\n            iter: self,\n        }\n    }\n    fn join(mut self, sep: &str) -> String\n    where\n        Self: Sized,\n        Self::Item: std::fmt::Display,\n    {\n        let mut result = String::new();\n        if let Some(first) = self.next() {\n            result.push_str(&format!(\"{}\", first));\n        }\n        for s in self {\n            result.push_str(&format!(\"{}{}\", sep, s));\n        }\n        result\n    }\n    fn cat(self) -> String\n    where\n        Self: Sized,\n        Self::Item: std::fmt::Display,\n    {\n        self.join(\"\")\n    }\n}\nimpl<I: Iterator> IteratorExt for I {}\npub struct Unfold<T, F>\nwhere\n    F: FnMut(&T) -> Option<T>,\n{\n    state: Option<T>,\n    f: F,\n}\nimpl<T, F> Iterator for Unfold<T, F>\nwhere\n    F: FnMut(&T) -> Option<T>,\n{\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        if self.state.is_none() {\n            return None;\n        }\n        let state_inner = self.state.take().unwrap();\n        self.state = (self.f)(&state_inner);\n        Some(state_inner)\n    }\n}\npub fn unfold<T, F>(init: T, f: F) -> Unfold<T, F>\nwhere\n    F: FnMut(&T) -> Option<T>,\n{\n    Unfold {\n        state: Some(init),\n        f: f,\n    }\n}\npub struct Iterate<T, F>\nwhere\n    F: FnMut(&T) -> T,\n{\n    state: T,\n    f: F,\n}\nimpl<T, F> Iterator for Iterate<T, F>\nwhere\n    F: FnMut(&T) -> T,\n{\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        use std::mem::swap;\n        let mut state = (self.f)(&self.state);\n        swap(&mut state, &mut self.state);\n        Some(state)\n    }\n}\npub fn iterate<T, F>(init: T, f: F) -> Iterate<T, F>\nwhere\n    F: FnMut(&T) -> T,\n{\n    Iterate { state: init, f: f }\n}\n\n#[macro_export]\n    #[cfg(local)]\n    macro_rules! dbg {\n    ( ) => {{\n        use std::io::{self, Write};\n        writeln!(io::stderr(), \"{}: dbg\", line!()).unwrap();\n    }};\n    ( $ e : expr ) => {{\n        use std::io::{self, Write};\n        let result = $e;\n        writeln!(\n            io::stderr(),\n            \"{}: {} = {:?}\",\n            line!(),\n            stringify!($e),\n            result\n        )\n            .unwrap();\n        result\n    }};\n}\n#[macro_export]\n#[cfg(not(local))]\nmacro_rules! dbg {\n    ( ) => {};\n    ( $ e : expr ) => {\n        $e\n    };\n}\n\nuse std::cmp;\n\nfn choose(n: ModP, m: ModP, fact: &[ModP]) -> ModP {\n    fact[n.base() as usize] / (fact[(n-m).base() as usize] * fact[m.base() as usize])\n}\n\nfn homo(n: ModP, m: ModP, fact: &[ModP]) -> ModP {\n    choose(n+m-1, n-1, fact)\n}\n\nfn main() {\n    unsafe { ModP::set_mod(998244353).unwrap(); }\n    read!(n = ModP, m = ModP);\n    let fact: Vec<ModP> = (1..(n+3*m).base())\n        .lscan(modp(1), |&acc, n| acc * n)\n        .collect();\n    let ans: ModP = (0..cmp::min(n.base(), m.base())+1)\n        .filter(|&odd| odd % 2 == m.base() % 2)\n        .map(|odd| {\n            let c = choose(n, modp(odd), &fact);\n            let dist = homo(n, modp((3*m - odd).base() / 2), &fact);\n            let over_odd = odd * homo(n, modp((m - odd).base() / 2), &fact);\n            let over_even = if m.base() == odd { modp(0) } else {\n                (n-odd) * homo(n, modp((m - odd).base() / 2 - 1), &fact)\n            };\n            c * (dist - (over_odd + over_even))\n        }).sum();\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use self::mod_int::ModInt;\nuse std::cmp;\n\nconst MOD: usize = 998244353;\n\nfn main() {\n    let (r, w) = (std::io::stdin(), std::io::stdout());\n    let mut sc = IO::new(r.lock(), w.lock());\n    let n: usize = sc.read();\n    let m: usize = sc.read();\n\n    let mut ans = ModInt(0);\n    let comb = Combination::new(n + m * 3, MOD);\n    for odd in 0..cmp::min(n + 1, m + 1) {\n        let d = 3 * m - odd;\n        if d % 2 != 0 {\n            continue;\n        }\n        let sum = d / 2;\n        let c = comb.get(n, odd);\n        let c2 = comb.get(sum + n - 1, n - 1);\n        ans += c * c2;\n    }\n\n    for odd in 0..cmp::min(n + 1, m + 1) {\n        let d = m - odd;\n        if d % 2 != 0 {\n            continue;\n        }\n        let sum = d / 2;\n        let c = comb.get(n, odd);\n        let c2 = comb.get(sum + n - 1, n - 1);\n        ans -= c * c2 * n;\n    }\n\n    let n = n - 1;\n    for odd in 0..cmp::min(n + 1, m + 1) {\n        let d = m - odd;\n        if d % 2 != 0 {\n            continue;\n        }\n        let sum = d / 2;\n        let c = comb.get(n, odd);\n        let c2 = comb.get(sum + n - 1, n - 1);\n        ans += c * c2 * (n + 1);\n    }\n\n    println!(\"{}\", ans.0);\n}\n\npub struct Combination {\n    fact: Vec<usize>,\n    inv_fact: Vec<usize>,\n    modulo: usize,\n}\n\nimpl Combination {\n    pub fn new(max: usize, modulo: usize) -> Combination {\n        let mut inv = vec![0; max + 1];\n        let mut fact = vec![0; max + 1];\n        let mut inv_fact = vec![0; max + 1];\n        inv[1] = 1;\n        for i in 2..(max + 1) {\n            inv[i] = inv[modulo % i] * (modulo - modulo / i) % modulo;\n        }\n        fact[0] = 1;\n        inv_fact[0] = 1;\n        for i in 0..max {\n            fact[i + 1] = fact[i] * (i + 1) % modulo;\n        }\n        for i in 0..max {\n            inv_fact[i + 1] = inv_fact[i] * inv[i + 1] % modulo;\n        }\n        Combination {\n            fact: fact,\n            inv_fact: inv_fact,\n            modulo: modulo,\n        }\n    }\n\n    pub fn get(&self, x: usize, y: usize) -> ModInt<usize> {\n        ModInt(self.fact[x] * self.inv_fact[y] % self.modulo * self.inv_fact[x - y] % self.modulo)\n    }\n}\npub mod mod_int {\n    use super::MOD;\n    use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};\n\n    type Num = usize;\n\n    #[derive(Clone, Copy)]\n    pub struct ModInt<T: Copy + Clone>(pub T);\n\n    impl Add<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self + rhs.0\n        }\n    }\n\n    impl Add<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, mut rhs: Num) -> ModInt<Num> {\n            if rhs >= MOD {\n                rhs %= MOD;\n            }\n            let mut t = rhs + self.0;\n            if t >= MOD {\n                t = t - MOD;\n            }\n            ModInt(t)\n        }\n    }\n\n    impl Sub<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, rhs: Num) -> ModInt<Num> {\n            let rhs = if rhs >= MOD { rhs % MOD } else { rhs };\n            let value = if self.0 < rhs { self.0 + MOD } else { self.0 };\n            ModInt(value - rhs)\n        }\n    }\n\n    impl Sub<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self - rhs.0\n        }\n    }\n\n    impl AddAssign<Num> for ModInt<Num> {\n        fn add_assign(&mut self, other: Num) {\n            *self = *self + other;\n        }\n    }\n    impl AddAssign<ModInt<Num>> for ModInt<Num> {\n        fn add_assign(&mut self, other: ModInt<Num>) {\n            *self = *self + other;\n        }\n    }\n\n    impl SubAssign<Num> for ModInt<Num> {\n        fn sub_assign(&mut self, other: Num) {\n            *self = *self - other;\n        }\n    }\n\n    impl SubAssign<ModInt<Num>> for ModInt<Num> {\n        fn sub_assign(&mut self, other: ModInt<Num>) {\n            *self = *self - other;\n        }\n    }\n\n    impl Div<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn div(self, mut rhs: Num) -> ModInt<Num> {\n            if rhs >= MOD {\n                rhs %= MOD;\n            }\n            self * ModInt(rhs).pow(MOD - 2)\n        }\n    }\n\n    impl Div<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn div(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self / rhs.0\n        }\n    }\n\n    impl DivAssign<Num> for ModInt<Num> {\n        fn div_assign(&mut self, rhs: Num) {\n            *self = *self / rhs\n        }\n    }\n    impl DivAssign<ModInt<Num>> for ModInt<Num> {\n        fn div_assign(&mut self, rhs: ModInt<Num>) {\n            *self = *self / rhs\n        }\n    }\n\n    impl Mul<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n\n        fn mul(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self * rhs.0\n        }\n    }\n    impl Mul<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n\n        fn mul(self, mut rhs: Num) -> ModInt<Num> {\n            if rhs >= MOD {\n                rhs %= MOD;\n            }\n            let t = (self.0 * rhs) % MOD;\n            ModInt(t)\n        }\n    }\n\n    impl MulAssign<Num> for ModInt<Num> {\n        fn mul_assign(&mut self, rhs: Num) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl MulAssign<ModInt<Num>> for ModInt<Num> {\n        fn mul_assign(&mut self, rhs: ModInt<Num>) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl ModInt<Num> {\n        pub fn pow(self, e: usize) -> ModInt<Num> {\n            let mut result = ModInt(1);\n            let mut cur = self;\n            let mut e = e;\n            while e > 0 {\n                if e & 1 == 1 {\n                    result *= cur;\n                }\n                e >>= 1;\n                cur *= cur;\n            }\n            result\n        }\n    }\n}\n\npub struct IO<R, W: std::io::Write>(R, std::io::BufWriter<W>);\n\nimpl<R: std::io::Read, W: std::io::Write> IO<R, W> {\n    pub fn new(r: R, w: W) -> IO<R, W> {\n        IO(r, std::io::BufWriter::new(w))\n    }\n    pub fn write<S: ToString>(&mut self, s: S) {\n        use std::io::Write;\n        self.1.write(s.to_string().as_bytes()).unwrap();\n    }\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .0\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r' || b == b'\\t')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r' && b != b'\\t')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use mod_int::ModInt;\nuse std::cmp;\n\nconst MOD: usize = 998244353;\n\nfn main() {\n    let (r, w) = (std::io::stdin(), std::io::stdout());\n    let mut sc = IO::new(r.lock(), w.lock());\n    let n: usize = sc.read();\n    let m: usize = sc.read();\n\n    let mut ans = ModInt(0);\n    let c = Combination::new(n + 3 * m, MOD);\n\n    for t in 0..(cmp::min(m, n) + 1) {\n        if (m - t) % 2 == 1 {\n            continue;\n        }\n        ans += c.get((3 * m - t) / 2 + n - 1, n - 1) * c.get(n, t);\n        ans -= c.get((m - t) / 2 + n - 1, n - 1) * c.get(n, t) * n;\n        if n - 1 >= t {\n            ans += c.get((m - t) / 2 + n - 2, n - 2) * c.get(n - 1, t) * n;\n        }\n    }\n    println!(\"{}\", ans.0);\n}\n\npub mod mod_int {\n    use super::MOD;\n    use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};\n\n    type Num = usize;\n\n    #[derive(Clone, Copy)]\n    pub struct ModInt<T: Copy + Clone>(pub T);\n\n    impl Add<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self + rhs.0\n        }\n    }\n\n    impl Add<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, mut rhs: Num) -> ModInt<Num> {\n            if rhs >= MOD {\n                rhs %= MOD;\n            }\n            let mut t = rhs + self.0;\n            if t >= MOD {\n                t = t - MOD;\n            }\n            ModInt(t)\n        }\n    }\n\n    impl Sub<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, rhs: Num) -> ModInt<Num> {\n            let rhs = if rhs >= MOD { rhs % MOD } else { rhs };\n            let value = if self.0 < rhs { self.0 + MOD } else { self.0 };\n            ModInt(value - rhs)\n        }\n    }\n\n    impl Sub<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self - rhs.0\n        }\n    }\n\n    impl AddAssign<Num> for ModInt<Num> {\n        fn add_assign(&mut self, other: Num) {\n            *self = *self + other;\n        }\n    }\n    impl AddAssign<ModInt<Num>> for ModInt<Num> {\n        fn add_assign(&mut self, other: ModInt<Num>) {\n            *self = *self + other;\n        }\n    }\n\n    impl SubAssign<Num> for ModInt<Num> {\n        fn sub_assign(&mut self, other: Num) {\n            *self = *self - other;\n        }\n    }\n\n    impl SubAssign<ModInt<Num>> for ModInt<Num> {\n        fn sub_assign(&mut self, other: ModInt<Num>) {\n            *self = *self - other;\n        }\n    }\n\n    impl Div<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn div(self, mut rhs: Num) -> ModInt<Num> {\n            if rhs >= MOD {\n                rhs %= MOD;\n            }\n            self * ModInt(rhs).pow(MOD - 2)\n        }\n    }\n\n    impl Div<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn div(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self / rhs.0\n        }\n    }\n\n    impl DivAssign<Num> for ModInt<Num> {\n        fn div_assign(&mut self, rhs: Num) {\n            *self = *self / rhs\n        }\n    }\n    impl DivAssign<ModInt<Num>> for ModInt<Num> {\n        fn div_assign(&mut self, rhs: ModInt<Num>) {\n            *self = *self / rhs\n        }\n    }\n\n    impl Mul<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n\n        fn mul(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self * rhs.0\n        }\n    }\n    impl Mul<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n\n        fn mul(self, mut rhs: Num) -> ModInt<Num> {\n            if rhs >= MOD {\n                rhs %= MOD;\n            }\n            let t = (self.0 * rhs) % MOD;\n            ModInt(t)\n        }\n    }\n\n    impl MulAssign<Num> for ModInt<Num> {\n        fn mul_assign(&mut self, rhs: Num) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl MulAssign<ModInt<Num>> for ModInt<Num> {\n        fn mul_assign(&mut self, rhs: ModInt<Num>) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl ModInt<Num> {\n        pub fn pow(self, e: usize) -> ModInt<Num> {\n            let mut result = ModInt(1);\n            let mut cur = self;\n            let mut e = e;\n            while e > 0 {\n                if e & 1 == 1 {\n                    result *= cur;\n                }\n                e >>= 1;\n                cur *= cur;\n            }\n            result\n        }\n    }\n}\n\npub struct Combination {\n    fact: Vec<usize>,\n    inv_fact: Vec<usize>,\n    modulo: usize,\n}\n\nimpl Combination {\n    pub fn new(max: usize, modulo: usize) -> Combination {\n        let mut inv = vec![0; max + 1];\n        let mut fact = vec![0; max + 1];\n        let mut inv_fact = vec![0; max + 1];\n        inv[1] = 1;\n        for i in 2..(max + 1) {\n            inv[i] = inv[modulo % i] * (modulo - modulo / i) % modulo;\n        }\n        fact[0] = 1;\n        inv_fact[0] = 1;\n        for i in 0..max {\n            fact[i + 1] = fact[i] * (i + 1) % modulo;\n        }\n        for i in 0..max {\n            inv_fact[i + 1] = inv_fact[i] * inv[i + 1] % modulo;\n        }\n        Combination {\n            fact: fact,\n            inv_fact: inv_fact,\n            modulo: modulo,\n        }\n    }\n\n    pub fn get(&self, x: usize, y: usize) -> ModInt<usize> {\n        assert!(x >= y);\n        ModInt(self.fact[x] * self.inv_fact[y] % self.modulo * self.inv_fact[x - y] % self.modulo)\n    }\n}\n\npub struct IO<R, W: std::io::Write>(R, std::io::BufWriter<W>);\n\nimpl<R: std::io::Read, W: std::io::Write> IO<R, W> {\n    pub fn new(r: R, w: W) -> IO<R, W> {\n        IO(r, std::io::BufWriter::new(w))\n    }\n    pub fn write<S: ToString>(&mut self, s: S) {\n        use std::io::Write;\n        self.1.write(s.to_string().as_bytes()).unwrap();\n    }\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .0\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r' || b == b'\\t')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r' && b != b'\\t')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "pub trait Readable {\n    type Output;\n    fn words_count() -> usize;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String>;\n}\n#[macro_export]\nmacro_rules! readable {\n    ( $ t : ty , $ words_count : expr , |$ words : ident | $ read_words : expr ) => {\n        impl Readable for $t {\n            type Output = $t;\n            fn words_count() -> usize {\n                $words_count\n            }\n            fn read_words($words: &[&str]) -> Result<$t, String> {\n                Ok($read_words)\n            }\n        }\n    };\n}\nreadable!((), 1, |_ss| ());\nreadable!(String, 1, |ss| ss[0].to_string());\nimpl Readable for char {\n    type Output = char;\n    fn words_count() -> usize {\n        1\n    }\n    fn read_words(words: &[&str]) -> Result<char, String> {\n        let chars: Vec<char> = words[0].chars().collect();\n        if chars.len() == 1 {\n            Ok(chars[0])\n        } else {\n            Err(format!(\"cannot parse `{}` as a char\", words[0]))\n        }\n    }\n}\npub struct Chars();\nimpl Readable for Chars {\n    type Output = Vec<char>;\n    fn words_count() -> usize {\n        1\n    }\n    fn read_words(words: &[&str]) -> Result<Vec<char>, String> {\n        Ok(words[0].chars().collect())\n    }\n}\nmacro_rules ! impl_readable_for_ints { ( $ ( $ t : ty ) * ) => { $ ( impl Readable for $ t { type Output = Self ; fn words_count ( ) -> usize { 1 } fn read_words ( words : & [ & str ] ) -> Result <$ t , String > { use std :: str :: FromStr ; <$ t >:: from_str ( words [ 0 ] ) . map_err ( | _ | { format ! ( \"cannot parse `{}` as {}\" , words [ 0 ] , stringify ! ( $ t ) ) } ) } } ) * } ; }\nimpl_readable_for_ints ! ( i8 u8 i16 u16 i32 u32 i64 u64 isize usize f32 f64 ) ;\nmacro_rules ! define_one_origin_int_types { ( $ new_t : ident $ int_t : ty ) => { # [ doc = \" Converts 1-origin integer into 0-origin when read from stdin.\" ] # [ doc = \"\" ] # [ doc = \" # Example\" ] # [ doc = \"\" ] # [ doc = \" ```no_run\" ] # [ doc = \" # #[macro_use] extern crate atcoder_snippets;\" ] # [ doc = \" # use atcoder_snippets::read::*;\" ] # [ doc = \" // Stdin: \\\"1\\\"\" ] # [ doc = \" read!(a = usize_);\" ] # [ doc = \" assert_eq!(a, 0);\" ] # [ doc = \" ```\" ] # [ allow ( non_camel_case_types ) ] pub struct $ new_t ; impl Readable for $ new_t { type Output = $ int_t ; fn words_count ( ) -> usize { 1 } fn read_words ( words : & [ & str ] ) -> Result < Self :: Output , String > { <$ int_t >:: read_words ( words ) . map ( | n | n - 1 ) } } } ; ( $ new_t : ident $ int_t : ty ; $ ( $ inner_new_t : ident $ inner_int_t : ty ) ;* ) => { define_one_origin_int_types ! ( $ new_t $ int_t ) ; define_one_origin_int_types ! ( $ ( $ inner_new_t $ inner_int_t ) ;* ) ; } ; }\ndefine_one_origin_int_types ! ( u8_ u8 ; u16_ u16 ; u32_ u32 ; u64_ u64 ; usize_ usize ) ;\nmacro_rules ! impl_readable_for_tuples { ( $ t : ident $ var : ident ) => ( ) ; ( $ t : ident $ var : ident ; $ ( $ inner_t : ident $ inner_var : ident ) ;* ) => { impl_readable_for_tuples ! ( $ ( $ inner_t $ inner_var ) ;* ) ; impl <$ t : Readable , $ ( $ inner_t : Readable ) ,*> Readable for ( $ t , $ ( $ inner_t ) ,* ) { type Output = ( <$ t >:: Output , $ ( <$ inner_t >:: Output ) ,* ) ; fn words_count ( ) -> usize { let mut n = <$ t >:: words_count ( ) ; $ ( n += <$ inner_t >:: words_count ( ) ; ) * n } # [ allow ( unused_assignments ) ] fn read_words ( words : & [ & str ] ) -> Result < Self :: Output , String > { let mut start = 0 ; let $ var = <$ t >:: read_words ( & words [ start .. start +<$ t >:: words_count ( ) ] ) ?; start += <$ t >:: words_count ( ) ; $ ( let $ inner_var = <$ inner_t >:: read_words ( & words [ start .. start +<$ inner_t >:: words_count ( ) ] ) ?; start += <$ inner_t >:: words_count ( ) ; ) * Ok ( ( $ var , $ ( $ inner_var ) ,* ) ) } } } ; }\nimpl_readable_for_tuples ! ( T8 x8 ; T7 x7 ; T6 x6 ; T5 x5 ; T4 x4 ; T3 x3 ; T2 x2 ; T1 x1 ) ;\npub trait ReadableFromLine {\n    type Output;\n    fn read_line(line: &str) -> Result<Self::Output, String>;\n}\nfn split_into_words(line: &str) -> Vec<&str> {\n    #[allow(deprecated)]\n    line.trim_right_matches('\\n').split_whitespace().collect()\n}\nimpl<T: Readable> ReadableFromLine for T {\n    type Output = T::Output;\n    fn read_line(line: &str) -> Result<T::Output, String> {\n        let words = split_into_words(line);\n        if words.len() != T::words_count() {\n            return Err(format!(\n                \"line `{}` has {} words, expected {}\",\n                line,\n                words.len(),\n                T::words_count()\n            ));\n        }\n        T::read_words(&words)\n    }\n}\nmacro_rules ! impl_readable_from_line_for_tuples_with_from_iterator { ( $ u : ident : $ ( + $ bound : path ) * => $ seq_in : ty , $ seq_out : ty ; $ t : ident $ var : ident ) => { impl <$ u : Readable > ReadableFromLine for $ seq_in where <$ u as Readable >:: Output : Sized $ ( + $ bound ) * { type Output = $ seq_out ; fn read_line ( line : & str ) -> Result <$ seq_out , String > { let n = $ u :: words_count ( ) ; let words = split_into_words ( line ) ; if words . len ( ) % n != 0 { return Err ( format ! ( \"line `{}` has {} words, expected multiple of {}\" , line , words . len ( ) , n ) ) ; } let mut result = Vec :: new ( ) ; for chunk in words . chunks ( n ) { match $ u :: read_words ( chunk ) { Ok ( v ) => result . push ( v ) , Err ( msg ) => { let flagment_msg = if n == 1 { format ! ( \"word {}\" , result . len ( ) ) } else { let l = result . len ( ) ; format ! ( \"words {}-{}\" , n * l + 1 , ( n + 1 ) * l ) } ; return Err ( format ! ( \"{} of line `{}`: {}\" , flagment_msg , line , msg ) ) ; } } } Ok ( result . into_iter ( ) . collect ( ) ) } } impl < T : Readable , $ u : Readable > ReadableFromLine for ( T , $ seq_in ) where <$ u as Readable >:: Output : Sized $ ( + $ bound ) * { type Output = ( T :: Output , $ seq_out ) ; fn read_line ( line : & str ) -> Result < Self :: Output , String > { let n = T :: words_count ( ) ; # [ allow ( deprecated ) ] let trimmed = line . trim_right_matches ( '\\n' ) ; let words_and_rest : Vec <& str > = trimmed . splitn ( n + 1 , ' ' ) . collect ( ) ; if words_and_rest . len ( ) < n { return Err ( format ! ( \"line `{}` has {} words, expected at least {}\" , line , words_and_rest . len ( ) , n ) ) ; } let words = & words_and_rest [ .. n ] ; let empty_str = \"\" ; let rest = words_and_rest . get ( n ) . unwrap_or ( & empty_str ) ; Ok ( ( T :: read_words ( words ) ?, <$ seq_in >:: read_line ( rest ) ? ) ) } } } ; ( $ u : ident : $ ( + $ bound : path ) * => $ seq_in : ty , $ seq_out : ty ; $ t : ident $ var : ident , $ ( $ inner_t : ident $ inner_var : ident ) ,+ ) => { impl_readable_from_line_for_tuples_with_from_iterator ! ( $ u : $ ( + $ bound ) * => $ seq_in , $ seq_out ; $ ( $ inner_t $ inner_var ) ,+ ) ; impl <$ t : Readable , $ ( $ inner_t : Readable ) ,+ , $ u : Readable > ReadableFromLine for ( $ t , $ ( $ inner_t ) ,+ , $ seq_in ) where <$ u as Readable >:: Output : Sized $ ( + $ bound ) * { type Output = ( $ t :: Output , $ ( $ inner_t :: Output ) ,+ , $ seq_out ) ; fn read_line ( line : & str ) -> Result < Self :: Output , String > { let mut n = $ t :: words_count ( ) ; $ ( n += $ inner_t :: words_count ( ) ; ) + # [ allow ( deprecated ) ] let trimmed = line . trim_right_matches ( '\\n' ) ; let words_and_rest : Vec <& str > = trimmed . splitn ( n + 1 , ' ' ) . collect ( ) ; if words_and_rest . len ( ) < n { return Err ( format ! ( \"line `{}` has {} words, expected at least {}\" , line , words_and_rest . len ( ) , n ) ) ; } let words = & words_and_rest [ .. n ] ; let empty_str = \"\" ; let rest = words_and_rest . get ( n ) . unwrap_or ( & empty_str ) ; let ( $ var , $ ( $ inner_var ) ,* ) = < ( $ t , $ ( $ inner_t ) ,+ ) >:: read_words ( words ) ?; Ok ( ( $ var , $ ( $ inner_var ) ,* , <$ seq_in >:: read_line ( rest ) ? ) ) } } } ; }\n#[macro_export]\nmacro_rules ! readable_collection { ( $ u : ident => $ collection_in : ty , $ collection_out : ty ) => { impl_readable_from_line_for_tuples_with_from_iterator ! ( $ u : => $ collection_in , $ collection_out ; T8 x8 , T7 x7 , T6 x6 , T5 x5 , T4 t4 , T3 t3 , T2 t2 , T1 t1 ) ; } ; ( $ u : ident : $ ( $ bound : path ) ,* => $ collection_in : ty , $ collection_out : ty ) => { impl_readable_from_line_for_tuples_with_from_iterator ! ( $ u : $ ( + $ bound ) * => $ collection_in , $ collection_out ; T8 x8 , T7 x7 , T6 x6 , T5 x5 , T4 t4 , T3 t3 , T2 t2 , T1 t1 ) ; } }\nreadable_collection ! ( U => Vec < U >, Vec < U :: Output > ) ;\nreadable_collection ! ( U : Eq , std :: hash :: Hash => std :: collections :: HashSet < U >, std :: collections :: HashSet < U :: Output > ) ;\npub fn read<T: ReadableFromLine>() -> T::Output {\n    let mut line = String::new();\n    std::io::stdin().read_line(&mut line).unwrap();\n    T::read_line(&line).unwrap()\n}\n#[macro_export]\nmacro_rules ! read { ( ) => { let mut line = String :: new ( ) ; std :: io :: stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; } ; ( $ pat : pat = $ t : ty ) => { let $ pat = read ::<$ t > ( ) ; } ; ( $ ( $ pat : pat = $ t : ty ) ,+ ) => { read ! ( ( $ ( $ pat ) ,* ) = ( $ ( $ t ) ,* ) ) ; } ; }\n#[macro_export]\nmacro_rules ! readls { ( $ ( $ pat : pat = $ t : ty ) ,+ ) => { $ ( read ! ( $ pat = $ t ) ; ) * } ; }\npub fn readx<T: ReadableFromLine>() -> Vec<T::Output> {\n    use std::io::{self, BufRead};\n    let stdin = io::stdin();\n    let result = stdin\n        .lock()\n        .lines()\n        .map(|line_result| {\n            let line = line_result.expect(\"read from stdin failed\");\n            T::read_line(&line).unwrap()\n        })\n        .collect();\n    result\n}\n#[macro_export]\nmacro_rules ! readx_loop { ( |$ pat : pat = $ t : ty | $ body : expr ) => { { use std :: io :: BufRead ; let stdin = std :: io :: stdin ( ) ; for line in stdin . lock ( ) . lines ( ) { let line = line . expect ( \"read from stdin failed\" ) ; let $ pat = <$ t >:: read_line ( & line ) . unwrap ( ) ; $ body } } } ; ( |$ ( $ pat : pat = $ t : ty ) ,*| $ body : expr ) => { readx_loop ! ( | ( $ ( $ pat ) ,* ) = ( $ ( $ t ) ,* ) | $ body ) ; } ; }\npub fn readn<T: ReadableFromLine>(n: usize) -> Vec<T::Output> {\n    use std::io::{self, BufRead};\n    let stdin = io::stdin();\n    let result: Vec<T::Output> = stdin\n        .lock()\n        .lines()\n        .take(n)\n        .map(|line_result| {\n            let line = line_result.expect(\"read from stdin failed\");\n            T::read_line(&line).unwrap()\n        })\n        .collect();\n    if result.len() < n {\n        panic!(\n            \"expected reading {} lines, but only {} lines are read\",\n            n,\n            result.len()\n        );\n    }\n    result\n}\n#[macro_export]\nmacro_rules ! readn_loop { ( $ n : expr , |$ pat : pat = $ t : ty | $ body : expr ) => { { use std :: io :: BufRead ; let stdin = std :: io :: stdin ( ) ; let mut lock = stdin . lock ( ) ; for _ in 0 ..$ n { let mut line = String :: new ( ) ; lock . read_line ( & mut line ) . expect ( \"read from stdin failed\" ) ; let $ pat = <$ t >:: read_line ( & line ) . unwrap ( ) ; $ body } } } ; ( $ n : expr , |$ ( $ pat : pat = $ t : ty ) ,*| $ body : expr ) => { readn_loop ! ( $ n , | ( $ ( $ pat ) ,* ) = ( $ ( $ t ) ,* ) | $ body ) ; } ; }\npub trait Words {\n    fn read<T: Readable>(&self) -> T::Output;\n}\nimpl<'a> Words for [&'a str] {\n    fn read<T: Readable>(&self) -> T::Output {\n        T::read_words(self).unwrap()\n    }\n}\nimpl<'a> Words for &'a str {\n    fn read<T: Readable>(&self) -> T::Output {\n        T::read_words(&[self]).unwrap()\n    }\n}\n\npub type ModPBase = u64;\npub type ModPModulus = u32;\nstatic mut MODULUS: ModPBase = 0;\n#[derive(Clone, Copy, PartialEq, Eq)]\npub struct ModP {\n    base: ModPBase,\n}\nimpl ModP {\n    pub unsafe fn set_mod(modulus: ModPModulus) -> Result<(), String> {\n        if modulus <= 1 {\n            return Err(format!(\"{} is not a prime number.\", modulus));\n        }\n        if modulus >= 4 {\n            if modulus % 2 == 0 || modulus % 3 == 0 {\n                return Err(format!(\"{} is not a prime number.\", modulus));\n            }\n            let mut divisor = 5;\n            loop {\n                if divisor * divisor > modulus {\n                    break;\n                }\n                if modulus % divisor == 0 {\n                    return Err(format!(\"{} is not a prime number.\", modulus));\n                }\n                divisor += 2;\n                if divisor * divisor > modulus {\n                    break;\n                }\n                if modulus % divisor == 0 {\n                    return Err(format!(\"{} is not a prime number.\", modulus));\n                }\n                divisor += 4;\n            }\n        }\n        MODULUS = modulus as ModPBase;\n        Ok(())\n    }\n    pub fn new(n: ModPBase) -> ModP {\n        if !cfg!(test) {\n            assert!(\n                unsafe { MODULUS } != 0,\n                \"Call ModP::set_mod before using ModP.\"\n            );\n        }\n        ModP {\n            base: n % unsafe { MODULUS },\n        }\n    }\n    pub unsafe fn new_unchecked(n: ModPBase) -> ModP {\n        ModP { base: n }\n    }\n    pub fn base(&self) -> ModPBase {\n        self.base\n    }\n    pub fn pow(self, exp: ModPBase) -> ModP {\n        if exp == 0 {\n            ModP::new(1)\n        } else {\n            let sub = self.pow(exp / 2);\n            if exp % 2 == 0 {\n                sub * sub\n            } else {\n                self * sub * sub\n            }\n        }\n    }\n    pub fn inv(self) -> ModP {\n        assert!(self.base() != 0);\n        self.pow(unsafe { MODULUS } - 2)\n    }\n}\npub fn modp(x: ModPBase) -> ModP {\n    ModP::new(x)\n}\nimpl std::fmt::Display for ModP {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"{}\", self.base())\n    }\n}\nimpl std::fmt::Debug for ModP {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"{} mod P\", self.base())\n    }\n}\nimpl PartialEq<ModPBase> for ModP {\n    fn eq(&self, other: &ModPBase) -> bool {\n        self.base() == other % unsafe { MODULUS }\n    }\n}\nimpl PartialEq<ModP> for ModPBase {\n    fn eq(&self, other: &ModP) -> bool {\n        self % unsafe { MODULUS } == other.base() % unsafe { MODULUS }\n    }\n}\nimpl std::ops::Add for ModP {\n    type Output = ModP;\n    fn add(self, rhs: ModP) -> ModP {\n        let m = unsafe { MODULUS };\n        ModP {\n            base: (self.base() + rhs.base() % m) % m,\n        }\n    }\n}\nimpl std::ops::Add<ModPBase> for ModP {\n    type Output = ModP;\n    fn add(self, rhs: ModPBase) -> ModP {\n        self + ModP::new(rhs)\n    }\n}\nimpl std::ops::Add<ModP> for ModPBase {\n    type Output = ModP;\n    fn add(self, rhs: ModP) -> ModP {\n        ModP::new(self) + rhs.base()\n    }\n}\nimpl std::ops::AddAssign for ModP {\n    fn add_assign(&mut self, rhs: ModP) {\n        *self = *self + rhs\n    }\n}\nimpl std::ops::AddAssign<ModPBase> for ModP {\n    fn add_assign(&mut self, rhs: ModPBase) {\n        *self = *self + ModP::new(rhs)\n    }\n}\nimpl std::ops::Neg for ModP {\n    type Output = ModP;\n    fn neg(self) -> ModP {\n        ModP::new(unsafe { MODULUS } - self.base())\n    }\n}\nimpl std::ops::Sub for ModP {\n    type Output = ModP;\n    fn sub(self, rhs: ModP) -> ModP {\n        self + (-rhs)\n    }\n}\nimpl std::ops::Sub<ModPBase> for ModP {\n    type Output = ModP;\n    fn sub(self, rhs: ModPBase) -> ModP {\n        self - ModP::new(rhs)\n    }\n}\nimpl std::ops::Sub<ModP> for ModPBase {\n    type Output = ModP;\n    fn sub(self, rhs: ModP) -> ModP {\n        ModP::new(self) - rhs\n    }\n}\nimpl std::ops::SubAssign for ModP {\n    fn sub_assign(&mut self, rhs: ModP) {\n        *self = *self - rhs;\n    }\n}\nimpl std::ops::SubAssign<ModPBase> for ModP {\n    fn sub_assign(&mut self, rhs: ModPBase) {\n        *self = *self - ModP::new(rhs)\n    }\n}\nimpl std::ops::Mul for ModP {\n    type Output = ModP;\n    fn mul(self, rhs: ModP) -> ModP {\n        let m = unsafe { MODULUS };\n        ModP {\n            base: self.base() * (rhs.base() % m) % m,\n        }\n    }\n}\nimpl std::ops::Mul<ModPBase> for ModP {\n    type Output = ModP;\n    fn mul(self, rhs: ModPBase) -> ModP {\n        self * ModP::new(rhs)\n    }\n}\nimpl std::ops::Mul<ModP> for ModPBase {\n    type Output = ModP;\n    fn mul(self, rhs: ModP) -> ModP {\n        ModP::new(self) * rhs.base()\n    }\n}\nimpl std::ops::MulAssign for ModP {\n    fn mul_assign(&mut self, rhs: ModP) {\n        *self = *self * rhs\n    }\n}\nimpl std::ops::MulAssign<ModPBase> for ModP {\n    fn mul_assign(&mut self, rhs: ModPBase) {\n        *self = *self * ModP::new(rhs)\n    }\n}\nimpl std::ops::Div for ModP {\n    type Output = ModP;\n    fn div(self, rhs: ModP) -> ModP {\n        self * rhs.inv()\n    }\n}\nimpl std::ops::Div<ModPBase> for ModP {\n    type Output = ModP;\n    fn div(self, rhs: ModPBase) -> ModP {\n        self * ModP::new(rhs).inv()\n    }\n}\nimpl std::ops::Div<ModP> for ModPBase {\n    type Output = ModP;\n    fn div(self, rhs: ModP) -> ModP {\n        ModP::new(self) * rhs.inv()\n    }\n}\nimpl std::ops::DivAssign for ModP {\n    fn div_assign(&mut self, rhs: ModP) {\n        *self = *self / rhs;\n    }\n}\nimpl std::ops::DivAssign<ModPBase> for ModP {\n    fn div_assign(&mut self, rhs: ModPBase) {\n        *self = *self / ModP::new(rhs)\n    }\n}\nimpl std::iter::Sum for ModP {\n    fn sum<I: Iterator<Item = ModP>>(iter: I) -> ModP {\n        let mut ans = 0;\n        for n in iter {\n            ans += n.base();\n        }\n        ModP::new(ans)\n    }\n}\nimpl<'a> std::iter::Sum<&'a ModP> for ModP {\n    fn sum<I: Iterator<Item = &'a ModP>>(iter: I) -> ModP {\n        let mut ans = 0;\n        for n in iter {\n            ans += n.base();\n        }\n        ModP::new(ans)\n    }\n}\nimpl std::iter::Product for ModP {\n    fn product<I: Iterator<Item = ModP>>(iter: I) -> ModP {\n        let mut ans = unsafe { ModP::new_unchecked(1) };\n        for n in iter {\n            ans *= n;\n        }\n        ans\n    }\n}\nimpl<'a> std::iter::Product<&'a ModP> for ModP {\n    fn product<I: Iterator<Item = &'a ModP>>(iter: I) -> ModP {\n        let mut ans = unsafe { ModP::new_unchecked(1) };\n        for &n in iter {\n            ans *= n;\n        }\n        ans\n    }\n}\nreadable!(ModP, 1, |ws| ModP::new(ws[0].read::<ModPBase>()));\n\n#[derive(Clone)]\npub struct StepBy<I> {\n    iter: I,\n    step: usize,\n    first_take: bool,\n}\nimpl<I: Iterator> Iterator for StepBy<I> {\n    type Item = I::Item;\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.first_take {\n            self.first_take = false;\n            self.iter.next()\n        } else {\n            self.iter.nth(self.step)\n        }\n    }\n}\npub struct Chunks<I: Iterator> {\n    iter: I,\n    size: usize,\n}\nimpl<I: Iterator> Iterator for Chunks<I> {\n    type Item = Vec<I::Item>;\n    fn next(&mut self) -> Option<Self::Item> {\n        let first = self.iter.next();\n        if first.is_none() {\n            return None;\n        }\n        let mut chunk = Vec::with_capacity(self.size);\n        chunk.push(first.unwrap());\n        for _ in 0..self.size - 1 {\n            match self.iter.next() {\n                Some(x) => chunk.push(x),\n                None => break,\n            }\n        }\n        Some(chunk)\n    }\n}\n#[derive(Clone)]\npub struct LScan<I: Iterator, S: Clone, F: FnMut(&S, I::Item) -> S> {\n    iter: I,\n    state: Option<S>,\n    f: F,\n}\nimpl<I: Iterator, S: Clone, F> Iterator for LScan<I, S, F>\nwhere\n    F: FnMut(&S, I::Item) -> S,\n{\n    type Item = S;\n    fn next(&mut self) -> Option<S> {\n        if self.state.is_none() {\n            return None;\n        }\n        let state_inner = self.state.take().unwrap();\n        if let Some(item) = self.iter.next() {\n            self.state = Some((self.f)(&state_inner, item));\n        }\n        Some(state_inner)\n    }\n}\npub struct Flatten<I: Iterator>\nwhere\n    I::Item: IntoIterator,\n{\n    outer_iter: I,\n    inner_iter: Option<<<I as Iterator>::Item as IntoIterator>::IntoIter>,\n}\nimpl<I, J> Iterator for Flatten<I>\nwhere\n    I: Iterator<Item = J>,\n    J: IntoIterator,\n{\n    type Item = <<J as IntoIterator>::IntoIter as Iterator>::Item;\n    fn next(&mut self) -> Option<J::Item> {\n        loop {\n            if let Some(inner_iter) = self.inner_iter.as_mut() {\n                if let item @ Some(_) = inner_iter.next() {\n                    return item;\n                }\n            }\n            match self.outer_iter.next() {\n                None => return None,\n                Some(inner) => self.inner_iter = Some(inner.into_iter()),\n            }\n        }\n    }\n}\npub struct GroupBy<K: Eq, I: Iterator, F: FnMut(&I::Item) -> K> {\n    cur: Option<(I::Item, K)>,\n    iter: I,\n    key_fn: F,\n}\nimpl<K: Eq, I: Iterator, F: FnMut(&I::Item) -> K> Iterator for GroupBy<K, I, F> {\n    type Item = (K, Vec<I::Item>);\n    fn next(&mut self) -> Option<(K, Vec<I::Item>)> {\n        let cur = self.cur.take();\n        cur.map(|(item, key)| {\n            let mut group = vec![item];\n            loop {\n                let next = self.iter.next();\n                match next {\n                    Some(next_item) => {\n                        let next_key = (self.key_fn)(&next_item);\n                        if key == next_key {\n                            group.push(next_item);\n                        } else {\n                            self.cur = Some((next_item, next_key));\n                            break;\n                        }\n                    }\n                    None => {\n                        self.cur = None;\n                        break;\n                    }\n                }\n            }\n            (key, group)\n        })\n    }\n}\npub struct RunLength<I: Iterator> {\n    cur: Option<I::Item>,\n    iter: I,\n}\nimpl<I: Iterator> Iterator for RunLength<I>\nwhere\n    I::Item: Eq,\n{\n    type Item = (I::Item, usize);\n    fn next(&mut self) -> Option<(I::Item, usize)> {\n        let cur = self.cur.take();\n        cur.map(|value| {\n            let mut length = 1;\n            loop {\n                let next = self.iter.next();\n                match next {\n                    Some(next_value) => {\n                        if value == next_value {\n                            length += 1;\n                        } else {\n                            self.cur = Some(next_value);\n                            break;\n                        }\n                    }\n                    None => {\n                        self.cur = None;\n                        break;\n                    }\n                }\n            }\n            (value, length)\n        })\n    }\n}\npub trait IteratorExt: Iterator {\n    fn step_by_(self, step: usize) -> StepBy<Self>\n    where\n        Self: Sized,\n    {\n        assert_ne!(step, 0);\n        StepBy {\n            iter: self,\n            step: step - 1,\n            first_take: true,\n        }\n    }\n    fn for_each<F: FnMut(Self::Item)>(self, mut f: F)\n    where\n        Self: Sized,\n    {\n        for item in self {\n            f(item);\n        }\n    }\n    fn chunks(self, size: usize) -> Chunks<Self>\n    where\n        Self: Sized,\n    {\n        assert!(size > 0);\n        Chunks {\n            iter: self,\n            size: size,\n        }\n    }\n    fn lscan<S: Clone, F>(self, state: S, f: F) -> LScan<Self, S, F>\n    where\n        Self: Sized,\n        F: FnMut(&S, Self::Item) -> S,\n    {\n        LScan {\n            iter: self,\n            state: Some(state),\n            f: f,\n        }\n    }\n    fn get_unique(mut self) -> Option<Self::Item>\n    where\n        Self: Sized,\n        Self::Item: Eq,\n    {\n        let first_opt = self.next();\n        first_opt.and_then(|first| {\n            if self.all(|item| item == first) {\n                Some(first)\n            } else {\n                None\n            }\n        })\n    }\n    fn flatten(mut self) -> Flatten<Self>\n    where\n        Self: Sized,\n        Self::Item: IntoIterator,\n    {\n        let inner_opt = self.next();\n        Flatten {\n            outer_iter: self,\n            inner_iter: inner_opt.map(|inner| inner.into_iter()),\n        }\n    }\n    fn group_by<K: Eq, F: FnMut(&Self::Item) -> K>(mut self, mut f: F) -> GroupBy<K, Self, F>\n    where\n        Self: Sized,\n    {\n        let next = self.next();\n        GroupBy {\n            cur: next.map(|item| {\n                let key = f(&item);\n                (item, key)\n            }),\n            iter: self,\n            key_fn: f,\n        }\n    }\n    fn run_length(mut self) -> RunLength<Self>\n    where\n        Self: Sized,\n        Self::Item: Eq,\n    {\n        RunLength {\n            cur: self.next(),\n            iter: self,\n        }\n    }\n    fn join(mut self, sep: &str) -> String\n    where\n        Self: Sized,\n        Self::Item: std::fmt::Display,\n    {\n        let mut result = String::new();\n        if let Some(first) = self.next() {\n            result.push_str(&format!(\"{}\", first));\n        }\n        for s in self {\n            result.push_str(&format!(\"{}{}\", sep, s));\n        }\n        result\n    }\n    fn cat(self) -> String\n    where\n        Self: Sized,\n        Self::Item: std::fmt::Display,\n    {\n        self.join(\"\")\n    }\n}\nimpl<I: Iterator> IteratorExt for I {}\npub struct Unfold<T, F>\nwhere\n    F: FnMut(&T) -> Option<T>,\n{\n    state: Option<T>,\n    f: F,\n}\nimpl<T, F> Iterator for Unfold<T, F>\nwhere\n    F: FnMut(&T) -> Option<T>,\n{\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        if self.state.is_none() {\n            return None;\n        }\n        let state_inner = self.state.take().unwrap();\n        self.state = (self.f)(&state_inner);\n        Some(state_inner)\n    }\n}\npub fn unfold<T, F>(init: T, f: F) -> Unfold<T, F>\nwhere\n    F: FnMut(&T) -> Option<T>,\n{\n    Unfold {\n        state: Some(init),\n        f: f,\n    }\n}\npub struct Iterate<T, F>\nwhere\n    F: FnMut(&T) -> T,\n{\n    state: T,\n    f: F,\n}\nimpl<T, F> Iterator for Iterate<T, F>\nwhere\n    F: FnMut(&T) -> T,\n{\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        use std::mem::swap;\n        let mut state = (self.f)(&self.state);\n        swap(&mut state, &mut self.state);\n        Some(state)\n    }\n}\npub fn iterate<T, F>(init: T, f: F) -> Iterate<T, F>\nwhere\n    F: FnMut(&T) -> T,\n{\n    Iterate { state: init, f: f }\n}\n\n#[macro_export]\n    #[cfg(local)]\n    macro_rules! dbg {\n    ( ) => {{\n        use std::io::{self, Write};\n        writeln!(io::stderr(), \"{}: dbg\", line!()).unwrap();\n    }};\n    ( $ e : expr ) => {{\n        use std::io::{self, Write};\n        let result = $e;\n        writeln!(\n            io::stderr(),\n            \"{}: {} = {:?}\",\n            line!(),\n            stringify!($e),\n            result\n        )\n            .unwrap();\n        result\n    }};\n}\n#[macro_export]\n#[cfg(not(local))]\nmacro_rules! dbg {\n    ( ) => {};\n    ( $ e : expr ) => {\n        $e\n    };\n}\n\nuse std::cmp;\n\nfn choose(n: ModP, m: ModP, fact: &[ModP]) -> ModP {\n    fact[n.base() as usize] / (fact[(n-m).base() as usize] * fact[m.base() as usize])\n}\n\nfn homo(n: ModP, m: ModP, fact: &[ModP]) -> ModP {\n    choose(n+m-1, n-1, fact)\n}\n\nfn main() {\n    unsafe { ModP::set_mod(998244353).unwrap(); }\n    read!(n = ModP, m = ModP);\n    let fact: Vec<ModP> = (1..(4*(n+m)+1).base())\n        .lscan(modp(1), |&acc, n| acc * n)\n        .collect();\n    let ans: ModP = (0..cmp::min(n.base(), m.base())+1)\n        .filter(|&odd| odd % 2 == m.base() % 2)\n        .map(|odd| {\n            let c = choose(n, modp(odd), &fact);\n            let dist = homo(n, modp((3*m - odd).base() / 2), &fact);\n            let over_odd = odd * homo(n, modp((m - odd).base() / 2), &fact);\n            let over_even = if m.base() == odd { modp(0) } else {\n                (n-odd) * homo(n, modp(((m - odd).base() / 2).saturating_sub(1)), &fact)\n            };\n            c * (dist - (over_odd + over_even))\n        }).sum();\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "pub trait Readable {\n    type Output;\n    fn words_count() -> usize;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String>;\n}\n#[macro_export]\nmacro_rules! readable {\n    ( $ t : ty , $ words_count : expr , |$ words : ident | $ read_words : expr ) => {\n        impl Readable for $t {\n            type Output = $t;\n            fn words_count() -> usize {\n                $words_count\n            }\n            fn read_words($words: &[&str]) -> Result<$t, String> {\n                Ok($read_words)\n            }\n        }\n    };\n}\nreadable!((), 1, |_ss| ());\nreadable!(String, 1, |ss| ss[0].to_string());\nimpl Readable for char {\n    type Output = char;\n    fn words_count() -> usize {\n        1\n    }\n    fn read_words(words: &[&str]) -> Result<char, String> {\n        let chars: Vec<char> = words[0].chars().collect();\n        if chars.len() == 1 {\n            Ok(chars[0])\n        } else {\n            Err(format!(\"cannot parse `{}` as a char\", words[0]))\n        }\n    }\n}\npub struct Chars();\nimpl Readable for Chars {\n    type Output = Vec<char>;\n    fn words_count() -> usize {\n        1\n    }\n    fn read_words(words: &[&str]) -> Result<Vec<char>, String> {\n        Ok(words[0].chars().collect())\n    }\n}\nmacro_rules ! impl_readable_for_ints { ( $ ( $ t : ty ) * ) => { $ ( impl Readable for $ t { type Output = Self ; fn words_count ( ) -> usize { 1 } fn read_words ( words : & [ & str ] ) -> Result <$ t , String > { use std :: str :: FromStr ; <$ t >:: from_str ( words [ 0 ] ) . map_err ( | _ | { format ! ( \"cannot parse `{}` as {}\" , words [ 0 ] , stringify ! ( $ t ) ) } ) } } ) * } ; }\nimpl_readable_for_ints ! ( i8 u8 i16 u16 i32 u32 i64 u64 isize usize f32 f64 ) ;\nmacro_rules ! define_one_origin_int_types { ( $ new_t : ident $ int_t : ty ) => { # [ doc = \" Converts 1-origin integer into 0-origin when read from stdin.\" ] # [ doc = \"\" ] # [ doc = \" # Example\" ] # [ doc = \"\" ] # [ doc = \" ```no_run\" ] # [ doc = \" # #[macro_use] extern crate atcoder_snippets;\" ] # [ doc = \" # use atcoder_snippets::read::*;\" ] # [ doc = \" // Stdin: \\\"1\\\"\" ] # [ doc = \" read!(a = usize_);\" ] # [ doc = \" assert_eq!(a, 0);\" ] # [ doc = \" ```\" ] # [ allow ( non_camel_case_types ) ] pub struct $ new_t ; impl Readable for $ new_t { type Output = $ int_t ; fn words_count ( ) -> usize { 1 } fn read_words ( words : & [ & str ] ) -> Result < Self :: Output , String > { <$ int_t >:: read_words ( words ) . map ( | n | n - 1 ) } } } ; ( $ new_t : ident $ int_t : ty ; $ ( $ inner_new_t : ident $ inner_int_t : ty ) ;* ) => { define_one_origin_int_types ! ( $ new_t $ int_t ) ; define_one_origin_int_types ! ( $ ( $ inner_new_t $ inner_int_t ) ;* ) ; } ; }\ndefine_one_origin_int_types ! ( u8_ u8 ; u16_ u16 ; u32_ u32 ; u64_ u64 ; usize_ usize ) ;\nmacro_rules ! impl_readable_for_tuples { ( $ t : ident $ var : ident ) => ( ) ; ( $ t : ident $ var : ident ; $ ( $ inner_t : ident $ inner_var : ident ) ;* ) => { impl_readable_for_tuples ! ( $ ( $ inner_t $ inner_var ) ;* ) ; impl <$ t : Readable , $ ( $ inner_t : Readable ) ,*> Readable for ( $ t , $ ( $ inner_t ) ,* ) { type Output = ( <$ t >:: Output , $ ( <$ inner_t >:: Output ) ,* ) ; fn words_count ( ) -> usize { let mut n = <$ t >:: words_count ( ) ; $ ( n += <$ inner_t >:: words_count ( ) ; ) * n } # [ allow ( unused_assignments ) ] fn read_words ( words : & [ & str ] ) -> Result < Self :: Output , String > { let mut start = 0 ; let $ var = <$ t >:: read_words ( & words [ start .. start +<$ t >:: words_count ( ) ] ) ?; start += <$ t >:: words_count ( ) ; $ ( let $ inner_var = <$ inner_t >:: read_words ( & words [ start .. start +<$ inner_t >:: words_count ( ) ] ) ?; start += <$ inner_t >:: words_count ( ) ; ) * Ok ( ( $ var , $ ( $ inner_var ) ,* ) ) } } } ; }\nimpl_readable_for_tuples ! ( T8 x8 ; T7 x7 ; T6 x6 ; T5 x5 ; T4 x4 ; T3 x3 ; T2 x2 ; T1 x1 ) ;\npub trait ReadableFromLine {\n    type Output;\n    fn read_line(line: &str) -> Result<Self::Output, String>;\n}\nfn split_into_words(line: &str) -> Vec<&str> {\n    #[allow(deprecated)]\n    line.trim_right_matches('\\n').split_whitespace().collect()\n}\nimpl<T: Readable> ReadableFromLine for T {\n    type Output = T::Output;\n    fn read_line(line: &str) -> Result<T::Output, String> {\n        let words = split_into_words(line);\n        if words.len() != T::words_count() {\n            return Err(format!(\n                \"line `{}` has {} words, expected {}\",\n                line,\n                words.len(),\n                T::words_count()\n            ));\n        }\n        T::read_words(&words)\n    }\n}\nmacro_rules ! impl_readable_from_line_for_tuples_with_from_iterator { ( $ u : ident : $ ( + $ bound : path ) * => $ seq_in : ty , $ seq_out : ty ; $ t : ident $ var : ident ) => { impl <$ u : Readable > ReadableFromLine for $ seq_in where <$ u as Readable >:: Output : Sized $ ( + $ bound ) * { type Output = $ seq_out ; fn read_line ( line : & str ) -> Result <$ seq_out , String > { let n = $ u :: words_count ( ) ; let words = split_into_words ( line ) ; if words . len ( ) % n != 0 { return Err ( format ! ( \"line `{}` has {} words, expected multiple of {}\" , line , words . len ( ) , n ) ) ; } let mut result = Vec :: new ( ) ; for chunk in words . chunks ( n ) { match $ u :: read_words ( chunk ) { Ok ( v ) => result . push ( v ) , Err ( msg ) => { let flagment_msg = if n == 1 { format ! ( \"word {}\" , result . len ( ) ) } else { let l = result . len ( ) ; format ! ( \"words {}-{}\" , n * l + 1 , ( n + 1 ) * l ) } ; return Err ( format ! ( \"{} of line `{}`: {}\" , flagment_msg , line , msg ) ) ; } } } Ok ( result . into_iter ( ) . collect ( ) ) } } impl < T : Readable , $ u : Readable > ReadableFromLine for ( T , $ seq_in ) where <$ u as Readable >:: Output : Sized $ ( + $ bound ) * { type Output = ( T :: Output , $ seq_out ) ; fn read_line ( line : & str ) -> Result < Self :: Output , String > { let n = T :: words_count ( ) ; # [ allow ( deprecated ) ] let trimmed = line . trim_right_matches ( '\\n' ) ; let words_and_rest : Vec <& str > = trimmed . splitn ( n + 1 , ' ' ) . collect ( ) ; if words_and_rest . len ( ) < n { return Err ( format ! ( \"line `{}` has {} words, expected at least {}\" , line , words_and_rest . len ( ) , n ) ) ; } let words = & words_and_rest [ .. n ] ; let empty_str = \"\" ; let rest = words_and_rest . get ( n ) . unwrap_or ( & empty_str ) ; Ok ( ( T :: read_words ( words ) ?, <$ seq_in >:: read_line ( rest ) ? ) ) } } } ; ( $ u : ident : $ ( + $ bound : path ) * => $ seq_in : ty , $ seq_out : ty ; $ t : ident $ var : ident , $ ( $ inner_t : ident $ inner_var : ident ) ,+ ) => { impl_readable_from_line_for_tuples_with_from_iterator ! ( $ u : $ ( + $ bound ) * => $ seq_in , $ seq_out ; $ ( $ inner_t $ inner_var ) ,+ ) ; impl <$ t : Readable , $ ( $ inner_t : Readable ) ,+ , $ u : Readable > ReadableFromLine for ( $ t , $ ( $ inner_t ) ,+ , $ seq_in ) where <$ u as Readable >:: Output : Sized $ ( + $ bound ) * { type Output = ( $ t :: Output , $ ( $ inner_t :: Output ) ,+ , $ seq_out ) ; fn read_line ( line : & str ) -> Result < Self :: Output , String > { let mut n = $ t :: words_count ( ) ; $ ( n += $ inner_t :: words_count ( ) ; ) + # [ allow ( deprecated ) ] let trimmed = line . trim_right_matches ( '\\n' ) ; let words_and_rest : Vec <& str > = trimmed . splitn ( n + 1 , ' ' ) . collect ( ) ; if words_and_rest . len ( ) < n { return Err ( format ! ( \"line `{}` has {} words, expected at least {}\" , line , words_and_rest . len ( ) , n ) ) ; } let words = & words_and_rest [ .. n ] ; let empty_str = \"\" ; let rest = words_and_rest . get ( n ) . unwrap_or ( & empty_str ) ; let ( $ var , $ ( $ inner_var ) ,* ) = < ( $ t , $ ( $ inner_t ) ,+ ) >:: read_words ( words ) ?; Ok ( ( $ var , $ ( $ inner_var ) ,* , <$ seq_in >:: read_line ( rest ) ? ) ) } } } ; }\n#[macro_export]\nmacro_rules ! readable_collection { ( $ u : ident => $ collection_in : ty , $ collection_out : ty ) => { impl_readable_from_line_for_tuples_with_from_iterator ! ( $ u : => $ collection_in , $ collection_out ; T8 x8 , T7 x7 , T6 x6 , T5 x5 , T4 t4 , T3 t3 , T2 t2 , T1 t1 ) ; } ; ( $ u : ident : $ ( $ bound : path ) ,* => $ collection_in : ty , $ collection_out : ty ) => { impl_readable_from_line_for_tuples_with_from_iterator ! ( $ u : $ ( + $ bound ) * => $ collection_in , $ collection_out ; T8 x8 , T7 x7 , T6 x6 , T5 x5 , T4 t4 , T3 t3 , T2 t2 , T1 t1 ) ; } }\nreadable_collection ! ( U => Vec < U >, Vec < U :: Output > ) ;\nreadable_collection ! ( U : Eq , std :: hash :: Hash => std :: collections :: HashSet < U >, std :: collections :: HashSet < U :: Output > ) ;\npub fn read<T: ReadableFromLine>() -> T::Output {\n    let mut line = String::new();\n    std::io::stdin().read_line(&mut line).unwrap();\n    T::read_line(&line).unwrap()\n}\n#[macro_export]\nmacro_rules ! read { ( ) => { let mut line = String :: new ( ) ; std :: io :: stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; } ; ( $ pat : pat = $ t : ty ) => { let $ pat = read ::<$ t > ( ) ; } ; ( $ ( $ pat : pat = $ t : ty ) ,+ ) => { read ! ( ( $ ( $ pat ) ,* ) = ( $ ( $ t ) ,* ) ) ; } ; }\n#[macro_export]\nmacro_rules ! readls { ( $ ( $ pat : pat = $ t : ty ) ,+ ) => { $ ( read ! ( $ pat = $ t ) ; ) * } ; }\npub fn readx<T: ReadableFromLine>() -> Vec<T::Output> {\n    use std::io::{self, BufRead};\n    let stdin = io::stdin();\n    let result = stdin\n        .lock()\n        .lines()\n        .map(|line_result| {\n            let line = line_result.expect(\"read from stdin failed\");\n            T::read_line(&line).unwrap()\n        })\n        .collect();\n    result\n}\n#[macro_export]\nmacro_rules ! readx_loop { ( |$ pat : pat = $ t : ty | $ body : expr ) => { { use std :: io :: BufRead ; let stdin = std :: io :: stdin ( ) ; for line in stdin . lock ( ) . lines ( ) { let line = line . expect ( \"read from stdin failed\" ) ; let $ pat = <$ t >:: read_line ( & line ) . unwrap ( ) ; $ body } } } ; ( |$ ( $ pat : pat = $ t : ty ) ,*| $ body : expr ) => { readx_loop ! ( | ( $ ( $ pat ) ,* ) = ( $ ( $ t ) ,* ) | $ body ) ; } ; }\npub fn readn<T: ReadableFromLine>(n: usize) -> Vec<T::Output> {\n    use std::io::{self, BufRead};\n    let stdin = io::stdin();\n    let result: Vec<T::Output> = stdin\n        .lock()\n        .lines()\n        .take(n)\n        .map(|line_result| {\n            let line = line_result.expect(\"read from stdin failed\");\n            T::read_line(&line).unwrap()\n        })\n        .collect();\n    if result.len() < n {\n        panic!(\n            \"expected reading {} lines, but only {} lines are read\",\n            n,\n            result.len()\n        );\n    }\n    result\n}\n#[macro_export]\nmacro_rules ! readn_loop { ( $ n : expr , |$ pat : pat = $ t : ty | $ body : expr ) => { { use std :: io :: BufRead ; let stdin = std :: io :: stdin ( ) ; let mut lock = stdin . lock ( ) ; for _ in 0 ..$ n { let mut line = String :: new ( ) ; lock . read_line ( & mut line ) . expect ( \"read from stdin failed\" ) ; let $ pat = <$ t >:: read_line ( & line ) . unwrap ( ) ; $ body } } } ; ( $ n : expr , |$ ( $ pat : pat = $ t : ty ) ,*| $ body : expr ) => { readn_loop ! ( $ n , | ( $ ( $ pat ) ,* ) = ( $ ( $ t ) ,* ) | $ body ) ; } ; }\npub trait Words {\n    fn read<T: Readable>(&self) -> T::Output;\n}\nimpl<'a> Words for [&'a str] {\n    fn read<T: Readable>(&self) -> T::Output {\n        T::read_words(self).unwrap()\n    }\n}\nimpl<'a> Words for &'a str {\n    fn read<T: Readable>(&self) -> T::Output {\n        T::read_words(&[self]).unwrap()\n    }\n}\n\npub type ModPBase = u64;\npub type ModPModulus = u32;\nstatic mut MODULUS: ModPBase = 0;\n#[derive(Clone, Copy, PartialEq, Eq)]\npub struct ModP {\n    base: ModPBase,\n}\nimpl ModP {\n    pub unsafe fn set_mod(modulus: ModPModulus) -> Result<(), String> {\n        if modulus <= 1 {\n            return Err(format!(\"{} is not a prime number.\", modulus));\n        }\n        if modulus >= 4 {\n            if modulus % 2 == 0 || modulus % 3 == 0 {\n                return Err(format!(\"{} is not a prime number.\", modulus));\n            }\n            let mut divisor = 5;\n            loop {\n                if divisor * divisor > modulus {\n                    break;\n                }\n                if modulus % divisor == 0 {\n                    return Err(format!(\"{} is not a prime number.\", modulus));\n                }\n                divisor += 2;\n                if divisor * divisor > modulus {\n                    break;\n                }\n                if modulus % divisor == 0 {\n                    return Err(format!(\"{} is not a prime number.\", modulus));\n                }\n                divisor += 4;\n            }\n        }\n        MODULUS = modulus as ModPBase;\n        Ok(())\n    }\n    pub fn new(n: ModPBase) -> ModP {\n        if !cfg!(test) {\n            assert!(\n                unsafe { MODULUS } != 0,\n                \"Call ModP::set_mod before using ModP.\"\n            );\n        }\n        ModP {\n            base: n % unsafe { MODULUS },\n        }\n    }\n    pub unsafe fn new_unchecked(n: ModPBase) -> ModP {\n        ModP { base: n }\n    }\n    pub fn base(&self) -> ModPBase {\n        self.base\n    }\n    pub fn pow(self, exp: ModPBase) -> ModP {\n        if exp == 0 {\n            ModP::new(1)\n        } else {\n            let sub = self.pow(exp / 2);\n            if exp % 2 == 0 {\n                sub * sub\n            } else {\n                self * sub * sub\n            }\n        }\n    }\n    pub fn inv(self) -> ModP {\n        assert!(self.base() != 0);\n        self.pow(unsafe { MODULUS } - 2)\n    }\n}\npub fn modp(x: ModPBase) -> ModP {\n    ModP::new(x)\n}\nimpl std::fmt::Display for ModP {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"{}\", self.base())\n    }\n}\nimpl std::fmt::Debug for ModP {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"{} mod P\", self.base())\n    }\n}\nimpl PartialEq<ModPBase> for ModP {\n    fn eq(&self, other: &ModPBase) -> bool {\n        self.base() == other % unsafe { MODULUS }\n    }\n}\nimpl PartialEq<ModP> for ModPBase {\n    fn eq(&self, other: &ModP) -> bool {\n        self % unsafe { MODULUS } == other.base() % unsafe { MODULUS }\n    }\n}\nimpl std::ops::Add for ModP {\n    type Output = ModP;\n    fn add(self, rhs: ModP) -> ModP {\n        let m = unsafe { MODULUS };\n        ModP {\n            base: (self.base() + rhs.base() % m) % m,\n        }\n    }\n}\nimpl std::ops::Add<ModPBase> for ModP {\n    type Output = ModP;\n    fn add(self, rhs: ModPBase) -> ModP {\n        self + ModP::new(rhs)\n    }\n}\nimpl std::ops::Add<ModP> for ModPBase {\n    type Output = ModP;\n    fn add(self, rhs: ModP) -> ModP {\n        ModP::new(self) + rhs.base()\n    }\n}\nimpl std::ops::AddAssign for ModP {\n    fn add_assign(&mut self, rhs: ModP) {\n        *self = *self + rhs\n    }\n}\nimpl std::ops::AddAssign<ModPBase> for ModP {\n    fn add_assign(&mut self, rhs: ModPBase) {\n        *self = *self + ModP::new(rhs)\n    }\n}\nimpl std::ops::Neg for ModP {\n    type Output = ModP;\n    fn neg(self) -> ModP {\n        ModP::new(unsafe { MODULUS } - self.base())\n    }\n}\nimpl std::ops::Sub for ModP {\n    type Output = ModP;\n    fn sub(self, rhs: ModP) -> ModP {\n        self + (-rhs)\n    }\n}\nimpl std::ops::Sub<ModPBase> for ModP {\n    type Output = ModP;\n    fn sub(self, rhs: ModPBase) -> ModP {\n        self - ModP::new(rhs)\n    }\n}\nimpl std::ops::Sub<ModP> for ModPBase {\n    type Output = ModP;\n    fn sub(self, rhs: ModP) -> ModP {\n        ModP::new(self) - rhs\n    }\n}\nimpl std::ops::SubAssign for ModP {\n    fn sub_assign(&mut self, rhs: ModP) {\n        *self = *self - rhs;\n    }\n}\nimpl std::ops::SubAssign<ModPBase> for ModP {\n    fn sub_assign(&mut self, rhs: ModPBase) {\n        *self = *self - ModP::new(rhs)\n    }\n}\nimpl std::ops::Mul for ModP {\n    type Output = ModP;\n    fn mul(self, rhs: ModP) -> ModP {\n        let m = unsafe { MODULUS };\n        ModP {\n            base: self.base() * (rhs.base() % m) % m,\n        }\n    }\n}\nimpl std::ops::Mul<ModPBase> for ModP {\n    type Output = ModP;\n    fn mul(self, rhs: ModPBase) -> ModP {\n        self * ModP::new(rhs)\n    }\n}\nimpl std::ops::Mul<ModP> for ModPBase {\n    type Output = ModP;\n    fn mul(self, rhs: ModP) -> ModP {\n        ModP::new(self) * rhs.base()\n    }\n}\nimpl std::ops::MulAssign for ModP {\n    fn mul_assign(&mut self, rhs: ModP) {\n        *self = *self * rhs\n    }\n}\nimpl std::ops::MulAssign<ModPBase> for ModP {\n    fn mul_assign(&mut self, rhs: ModPBase) {\n        *self = *self * ModP::new(rhs)\n    }\n}\nimpl std::ops::Div for ModP {\n    type Output = ModP;\n    fn div(self, rhs: ModP) -> ModP {\n        self * rhs.inv()\n    }\n}\nimpl std::ops::Div<ModPBase> for ModP {\n    type Output = ModP;\n    fn div(self, rhs: ModPBase) -> ModP {\n        self * ModP::new(rhs).inv()\n    }\n}\nimpl std::ops::Div<ModP> for ModPBase {\n    type Output = ModP;\n    fn div(self, rhs: ModP) -> ModP {\n        ModP::new(self) * rhs.inv()\n    }\n}\nimpl std::ops::DivAssign for ModP {\n    fn div_assign(&mut self, rhs: ModP) {\n        *self = *self / rhs;\n    }\n}\nimpl std::ops::DivAssign<ModPBase> for ModP {\n    fn div_assign(&mut self, rhs: ModPBase) {\n        *self = *self / ModP::new(rhs)\n    }\n}\nimpl std::iter::Sum for ModP {\n    fn sum<I: Iterator<Item = ModP>>(iter: I) -> ModP {\n        let mut ans = 0;\n        for n in iter {\n            ans += n.base();\n        }\n        ModP::new(ans)\n    }\n}\nimpl<'a> std::iter::Sum<&'a ModP> for ModP {\n    fn sum<I: Iterator<Item = &'a ModP>>(iter: I) -> ModP {\n        let mut ans = 0;\n        for n in iter {\n            ans += n.base();\n        }\n        ModP::new(ans)\n    }\n}\nimpl std::iter::Product for ModP {\n    fn product<I: Iterator<Item = ModP>>(iter: I) -> ModP {\n        let mut ans = unsafe { ModP::new_unchecked(1) };\n        for n in iter {\n            ans *= n;\n        }\n        ans\n    }\n}\nimpl<'a> std::iter::Product<&'a ModP> for ModP {\n    fn product<I: Iterator<Item = &'a ModP>>(iter: I) -> ModP {\n        let mut ans = unsafe { ModP::new_unchecked(1) };\n        for &n in iter {\n            ans *= n;\n        }\n        ans\n    }\n}\nreadable!(ModP, 1, |ws| ModP::new(ws[0].read::<ModPBase>()));\n\n#[derive(Clone)]\npub struct StepBy<I> {\n    iter: I,\n    step: usize,\n    first_take: bool,\n}\nimpl<I: Iterator> Iterator for StepBy<I> {\n    type Item = I::Item;\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.first_take {\n            self.first_take = false;\n            self.iter.next()\n        } else {\n            self.iter.nth(self.step)\n        }\n    }\n}\npub struct Chunks<I: Iterator> {\n    iter: I,\n    size: usize,\n}\nimpl<I: Iterator> Iterator for Chunks<I> {\n    type Item = Vec<I::Item>;\n    fn next(&mut self) -> Option<Self::Item> {\n        let first = self.iter.next();\n        if first.is_none() {\n            return None;\n        }\n        let mut chunk = Vec::with_capacity(self.size);\n        chunk.push(first.unwrap());\n        for _ in 0..self.size - 1 {\n            match self.iter.next() {\n                Some(x) => chunk.push(x),\n                None => break,\n            }\n        }\n        Some(chunk)\n    }\n}\n#[derive(Clone)]\npub struct LScan<I: Iterator, S: Clone, F: FnMut(&S, I::Item) -> S> {\n    iter: I,\n    state: Option<S>,\n    f: F,\n}\nimpl<I: Iterator, S: Clone, F> Iterator for LScan<I, S, F>\nwhere\n    F: FnMut(&S, I::Item) -> S,\n{\n    type Item = S;\n    fn next(&mut self) -> Option<S> {\n        if self.state.is_none() {\n            return None;\n        }\n        let state_inner = self.state.take().unwrap();\n        if let Some(item) = self.iter.next() {\n            self.state = Some((self.f)(&state_inner, item));\n        }\n        Some(state_inner)\n    }\n}\npub struct Flatten<I: Iterator>\nwhere\n    I::Item: IntoIterator,\n{\n    outer_iter: I,\n    inner_iter: Option<<<I as Iterator>::Item as IntoIterator>::IntoIter>,\n}\nimpl<I, J> Iterator for Flatten<I>\nwhere\n    I: Iterator<Item = J>,\n    J: IntoIterator,\n{\n    type Item = <<J as IntoIterator>::IntoIter as Iterator>::Item;\n    fn next(&mut self) -> Option<J::Item> {\n        loop {\n            if let Some(inner_iter) = self.inner_iter.as_mut() {\n                if let item @ Some(_) = inner_iter.next() {\n                    return item;\n                }\n            }\n            match self.outer_iter.next() {\n                None => return None,\n                Some(inner) => self.inner_iter = Some(inner.into_iter()),\n            }\n        }\n    }\n}\npub struct GroupBy<K: Eq, I: Iterator, F: FnMut(&I::Item) -> K> {\n    cur: Option<(I::Item, K)>,\n    iter: I,\n    key_fn: F,\n}\nimpl<K: Eq, I: Iterator, F: FnMut(&I::Item) -> K> Iterator for GroupBy<K, I, F> {\n    type Item = (K, Vec<I::Item>);\n    fn next(&mut self) -> Option<(K, Vec<I::Item>)> {\n        let cur = self.cur.take();\n        cur.map(|(item, key)| {\n            let mut group = vec![item];\n            loop {\n                let next = self.iter.next();\n                match next {\n                    Some(next_item) => {\n                        let next_key = (self.key_fn)(&next_item);\n                        if key == next_key {\n                            group.push(next_item);\n                        } else {\n                            self.cur = Some((next_item, next_key));\n                            break;\n                        }\n                    }\n                    None => {\n                        self.cur = None;\n                        break;\n                    }\n                }\n            }\n            (key, group)\n        })\n    }\n}\npub struct RunLength<I: Iterator> {\n    cur: Option<I::Item>,\n    iter: I,\n}\nimpl<I: Iterator> Iterator for RunLength<I>\nwhere\n    I::Item: Eq,\n{\n    type Item = (I::Item, usize);\n    fn next(&mut self) -> Option<(I::Item, usize)> {\n        let cur = self.cur.take();\n        cur.map(|value| {\n            let mut length = 1;\n            loop {\n                let next = self.iter.next();\n                match next {\n                    Some(next_value) => {\n                        if value == next_value {\n                            length += 1;\n                        } else {\n                            self.cur = Some(next_value);\n                            break;\n                        }\n                    }\n                    None => {\n                        self.cur = None;\n                        break;\n                    }\n                }\n            }\n            (value, length)\n        })\n    }\n}\npub trait IteratorExt: Iterator {\n    fn step_by_(self, step: usize) -> StepBy<Self>\n    where\n        Self: Sized,\n    {\n        assert_ne!(step, 0);\n        StepBy {\n            iter: self,\n            step: step - 1,\n            first_take: true,\n        }\n    }\n    fn for_each<F: FnMut(Self::Item)>(self, mut f: F)\n    where\n        Self: Sized,\n    {\n        for item in self {\n            f(item);\n        }\n    }\n    fn chunks(self, size: usize) -> Chunks<Self>\n    where\n        Self: Sized,\n    {\n        assert!(size > 0);\n        Chunks {\n            iter: self,\n            size: size,\n        }\n    }\n    fn lscan<S: Clone, F>(self, state: S, f: F) -> LScan<Self, S, F>\n    where\n        Self: Sized,\n        F: FnMut(&S, Self::Item) -> S,\n    {\n        LScan {\n            iter: self,\n            state: Some(state),\n            f: f,\n        }\n    }\n    fn get_unique(mut self) -> Option<Self::Item>\n    where\n        Self: Sized,\n        Self::Item: Eq,\n    {\n        let first_opt = self.next();\n        first_opt.and_then(|first| {\n            if self.all(|item| item == first) {\n                Some(first)\n            } else {\n                None\n            }\n        })\n    }\n    fn flatten(mut self) -> Flatten<Self>\n    where\n        Self: Sized,\n        Self::Item: IntoIterator,\n    {\n        let inner_opt = self.next();\n        Flatten {\n            outer_iter: self,\n            inner_iter: inner_opt.map(|inner| inner.into_iter()),\n        }\n    }\n    fn group_by<K: Eq, F: FnMut(&Self::Item) -> K>(mut self, mut f: F) -> GroupBy<K, Self, F>\n    where\n        Self: Sized,\n    {\n        let next = self.next();\n        GroupBy {\n            cur: next.map(|item| {\n                let key = f(&item);\n                (item, key)\n            }),\n            iter: self,\n            key_fn: f,\n        }\n    }\n    fn run_length(mut self) -> RunLength<Self>\n    where\n        Self: Sized,\n        Self::Item: Eq,\n    {\n        RunLength {\n            cur: self.next(),\n            iter: self,\n        }\n    }\n    fn join(mut self, sep: &str) -> String\n    where\n        Self: Sized,\n        Self::Item: std::fmt::Display,\n    {\n        let mut result = String::new();\n        if let Some(first) = self.next() {\n            result.push_str(&format!(\"{}\", first));\n        }\n        for s in self {\n            result.push_str(&format!(\"{}{}\", sep, s));\n        }\n        result\n    }\n    fn cat(self) -> String\n    where\n        Self: Sized,\n        Self::Item: std::fmt::Display,\n    {\n        self.join(\"\")\n    }\n}\nimpl<I: Iterator> IteratorExt for I {}\npub struct Unfold<T, F>\nwhere\n    F: FnMut(&T) -> Option<T>,\n{\n    state: Option<T>,\n    f: F,\n}\nimpl<T, F> Iterator for Unfold<T, F>\nwhere\n    F: FnMut(&T) -> Option<T>,\n{\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        if self.state.is_none() {\n            return None;\n        }\n        let state_inner = self.state.take().unwrap();\n        self.state = (self.f)(&state_inner);\n        Some(state_inner)\n    }\n}\npub fn unfold<T, F>(init: T, f: F) -> Unfold<T, F>\nwhere\n    F: FnMut(&T) -> Option<T>,\n{\n    Unfold {\n        state: Some(init),\n        f: f,\n    }\n}\npub struct Iterate<T, F>\nwhere\n    F: FnMut(&T) -> T,\n{\n    state: T,\n    f: F,\n}\nimpl<T, F> Iterator for Iterate<T, F>\nwhere\n    F: FnMut(&T) -> T,\n{\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        use std::mem::swap;\n        let mut state = (self.f)(&self.state);\n        swap(&mut state, &mut self.state);\n        Some(state)\n    }\n}\npub fn iterate<T, F>(init: T, f: F) -> Iterate<T, F>\nwhere\n    F: FnMut(&T) -> T,\n{\n    Iterate { state: init, f: f }\n}\n\n#[macro_export]\n    #[cfg(local)]\n    macro_rules! dbg {\n    ( ) => {{\n        use std::io::{self, Write};\n        writeln!(io::stderr(), \"{}: dbg\", line!()).unwrap();\n    }};\n    ( $ e : expr ) => {{\n        use std::io::{self, Write};\n        let result = $e;\n        writeln!(\n            io::stderr(),\n            \"{}: {} = {:?}\",\n            line!(),\n            stringify!($e),\n            result\n        )\n            .unwrap();\n        result\n    }};\n}\n#[macro_export]\n#[cfg(not(local))]\nmacro_rules! dbg {\n    ( ) => {};\n    ( $ e : expr ) => {\n        $e\n    };\n}\n\nuse std::cmp;\n\nfn choose(n: u64, m: u64, fact: &[ModP]) -> ModP {\n    fact[n as usize] / (fact[(n-m) as usize] * fact[m as usize])\n}\n\nfn homo(n: u64, m: u64, fact: &[ModP]) -> ModP {\n    choose(n+m-1, n-1, fact)\n}\n\nfn main() {\n    unsafe { ModP::set_mod(998244353).unwrap(); }\n    read!(n = u64, m = u64);\n    let fact: Vec<ModP> = (1..n+3*m)\n        .lscan(modp(1), |&acc, n| acc * n)\n        .collect();\n    let ans: ModP = (0..cmp::min(n, m)+1)\n        .skip(m as usize % 2)\n        .step_by_(2)\n        .map(|odd| {\n            let c = choose(n, odd, &fact);\n            let dist = homo(n, (3*m - odd) / 2, &fact);\n            let over_odd = odd * homo(n, (m - odd) / 2, &fact);\n            let over_even = if m == odd { modp(0) } else {\n                (n-odd) * homo(n, (m - odd) / 2 - 1, &fact)\n            };\n            c * (dist - (over_odd + over_even))\n        }).sum();\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules !read_value {($iter :expr ,($($t :tt ) ,*) ) =>{($(read_value !($iter ,$t ) ) ,*) } ;($iter :expr ,[$t :tt ;$len :expr ] ) =>{(0 ..$len ) .map (|_ |read_value !($iter ,$t ) ) .collect ::<Vec <_ >>() } ;($iter :expr ,{chars :$base :expr } ) =>{read_value !($iter ,String ) .chars () .map (|c |(c as u8 -$base as u8 ) as usize ) .collect ::<Vec <usize >>() } ;($iter :expr ,{char :$base :expr } ) =>{read_value !($iter ,{chars :$base } ) [0 ] } ;($iter :expr ,chars ) =>{read_value !($iter ,String ) .chars () .collect ::<Vec <char >>() } ;($iter :expr ,char ) =>{read_value !($iter ,chars ) [0 ] } ;($iter :expr ,usize1 ) =>{read_value !($iter ,usize ) -1 } ;($iter :expr ,$t :ty ) =>{$iter .next () .unwrap () .parse ::<$t >() .unwrap () } ;}\nmacro_rules !input_inner {($iter :expr ) =>{} ;($iter :expr ,) =>{} ;($iter :expr ,mut $var :ident :$t :tt $($r :tt ) *) =>{let mut $var =read_value !($iter ,$t ) ;input_inner !{$iter $($r ) *} } ;($iter :expr ,mut $var :ident $($r :tt ) *) =>{input_inner !{$iter ,mut $var :usize $($r ) *} } ;($iter :expr ,$var :ident :$t :tt $($r :tt ) *) =>{let $var =read_value !($iter ,$t ) ;input_inner !{$iter $($r ) *} } ;($iter :expr ,$var :ident $($r :tt ) *) =>{input_inner !{$iter ,$var :usize $($r ) *} } ;}\nmacro_rules !input {(source =$s :expr ,$($r :tt ) *) =>{let mut iter =$s .split_whitespace () ;input_inner !{iter ,$($r ) *} } ;(iter =$iter :ident ,$($r :tt ) *) =>{let s ={use std ::io ::Read ;let mut s =String ::new () ;std ::io ::stdin () .read_to_string (&mut s ) .unwrap () ;s } ;let mut $iter =s .split_whitespace () ;input_inner !{$iter ,$($r ) *} } ;($($r :tt ) *) =>{let s ={use std ::io ::Read ;let mut s =String ::new () ;std ::io ::stdin () .read_to_string (&mut s ) .unwrap () ;s } ;let mut iter =s .split_whitespace () ;input_inner !{iter ,$($r ) *} } ;}\nconst MOD: i64 = 998244353;\n#[derive(Copy, Clone, Debug, Default, PartialEq, Eq, Hash)]\npub struct Modi64(pub i64);\nimpl Modi64 {\n    #[inline]\n    pub fn new(i: i64) -> Self {\n        Modi64(Self::modulo(i, MOD))\n    }\n    #[inline]\n    pub fn modulo(i: i64, m: i64) -> i64 {\n        let mut x = i % m;\n        if x < 0 {\n            x += m;\n        }\n        x\n    }\n    pub fn pow(self, y: i64) -> Self {\n        let mut y = Self::modulo(y, MOD - 1);\n        let mut x = Self::new(1);\n        let mut base = self;\n        while y > 0 {\n            if y & 1 == 1 {\n                x *= base;\n            }\n            base *= base;\n            y = y >> 1;\n        }\n        x\n    }\n    #[inline]\n    pub fn inv(self) -> Self {\n        let (mut x, mut s, mut t, mut u) = (1, self.0, MOD, 0);\n        while t != 0 {\n            let k = s / t;\n            s -= k * t;\n            std::mem::swap(&mut s, &mut t);\n            x -= k * u;\n            std::mem::swap(&mut x, &mut u);\n        }\n        Modi64::new(x)\n    }\n}\nimpl From<i64> for Modi64 {\n    fn from(i: i64) -> Self {\n        Self::new(i)\n    }\n}\nimpl std::ops::Add for Modi64 {\n    type Output = Self;\n    #[inline]\n    fn add(self, rhs: Self) -> Self::Output {\n        Modi64((self.0 + rhs.0) % MOD)\n    }\n}\nimpl<'a> std::ops::Add<Modi64> for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn add(self, rhs: Modi64) -> Self::Output {\n        *self + rhs\n    }\n}\nimpl<'a> std::ops::Add<&'a Modi64> for Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn add(self, rhs: &'a Modi64) -> Self::Output {\n        self + *rhs\n    }\n}\nimpl<'a> std::ops::Add for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn add(self, rhs: Self) -> Self::Output {\n        *self + *rhs\n    }\n}\nimpl std::ops::AddAssign for Modi64 {\n    #[inline]\n    fn add_assign(&mut self, rhs: Self) {\n        *self = *self + rhs;\n    }\n}\nimpl<'a> std::ops::AddAssign<&'a Modi64> for Modi64 {\n    #[inline]\n    fn add_assign(&mut self, rhs: &'a Modi64) {\n        *self += *rhs;\n    }\n}\nimpl std::ops::Sub for Modi64 {\n    type Output = Self;\n    #[inline]\n    fn sub(self, rhs: Self) -> Self::Output {\n        Self::new(self.0 - rhs.0)\n    }\n}\nimpl<'a> std::ops::Sub<Modi64> for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn sub(self, rhs: Modi64) -> Self::Output {\n        *self - rhs\n    }\n}\nimpl<'a> std::ops::Sub<&'a Modi64> for Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn sub(self, rhs: &'a Modi64) -> Self::Output {\n        self - *rhs\n    }\n}\nimpl<'a> std::ops::Sub for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn sub(self, rhs: Self) -> Self::Output {\n        *self - *rhs\n    }\n}\nimpl std::ops::SubAssign for Modi64 {\n    #[inline]\n    fn sub_assign(&mut self, rhs: Self) {\n        *self = *self - rhs;\n    }\n}\nimpl<'a> std::ops::SubAssign<&'a Modi64> for Modi64 {\n    #[inline]\n    fn sub_assign(&mut self, rhs: &'a Modi64) {\n        *self -= *rhs;\n    }\n}\nimpl std::ops::Mul for Modi64 {\n    type Output = Self;\n    #[inline]\n    fn mul(self, rhs: Self) -> Self::Output {\n        Modi64(self.0 * rhs.0 % MOD)\n    }\n}\nimpl<'a> std::ops::Mul<Modi64> for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn mul(self, rhs: Modi64) -> Self::Output {\n        *self * rhs\n    }\n}\nimpl<'a> std::ops::Mul<&'a Modi64> for Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn mul(self, rhs: &'a Modi64) -> Self::Output {\n        self * *rhs\n    }\n}\nimpl<'a> std::ops::Mul for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn mul(self, rhs: Self) -> Self::Output {\n        *self * *rhs\n    }\n}\nimpl std::ops::MulAssign for Modi64 {\n    #[inline]\n    fn mul_assign(&mut self, rhs: Self) {\n        *self = *self * rhs;\n    }\n}\nimpl<'a> std::ops::MulAssign<&'a Modi64> for Modi64 {\n    #[inline]\n    fn mul_assign(&mut self, rhs: &'a Modi64) {\n        *self *= *rhs;\n    }\n}\nimpl std::ops::Div for Modi64 {\n    type Output = Self;\n    #[inline]\n    fn div(self, rhs: Self) -> Self::Output {\n        self * rhs.inv()\n    }\n}\nimpl<'a> std::ops::Div<Modi64> for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn div(self, rhs: Modi64) -> Self::Output {\n        *self * rhs.inv()\n    }\n}\nimpl<'a> std::ops::Div<&'a Modi64> for Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn div(self, rhs: &'a Modi64) -> Self::Output {\n        self * rhs.inv()\n    }\n}\nimpl<'a> std::ops::Div for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn div(self, rhs: Self) -> Self::Output {\n        *self * rhs.inv()\n    }\n}\nimpl std::ops::DivAssign for Modi64 {\n    #[inline]\n    fn div_assign(&mut self, rhs: Self) {\n        *self = *self * rhs.inv();\n    }\n}\nimpl<'a> std::ops::DivAssign<&'a Modi64> for Modi64 {\n    #[inline]\n    fn div_assign(&mut self, rhs: &'a Modi64) {\n        *self *= rhs.inv();\n    }\n}\nimpl std::ops::Neg for Modi64 {\n    type Output = Self;\n    #[inline]\n    fn neg(self) -> Self::Output {\n        Self::new(-self.0)\n    }\n}\nimpl<'a> std::ops::Neg for &'a Modi64 {\n    type Output = Modi64;\n    #[inline]\n    fn neg(self) -> Self::Output {\n        -*self\n    }\n}\nimpl std::iter::Sum for Modi64 {\n    #[inline]\n    fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n        iter.fold(Self::new(0), std::ops::Add::add)\n    }\n}\nimpl<'a> std::iter::Sum<&'a Modi64> for Modi64 {\n    #[inline]\n    fn sum<I: Iterator<Item = &'a Self>>(iter: I) -> Self {\n        iter.fold(Self::new(0), |x, &y| x + y)\n    }\n}\nimpl std::fmt::Display for Modi64 {\n    fn fmt<'a>(&self, f: &mut std::fmt::Formatter<'a>) -> Result<(), std::fmt::Error> {\n        write!(f, \"{}\", self.0)\n    }\n}\nimpl std::str::FromStr for Modi64 {\n    type Err = std::num::ParseIntError;\n    #[inline]\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        s.parse::<i64>().map(|i| Modi64::new(i))\n    }\n}\n#[derive(Clone, Debug)]\npub struct MemorizedFactorial {\n    n: usize,\n    fact: Vec<Modi64>,\n    inv_fact: Vec<Modi64>,\n}\nimpl MemorizedFactorial {\n    pub fn new(max_n: usize) -> MemorizedFactorial {\n        let mut fact = vec![Modi64::new(1); max_n + 1];\n        let mut inv_fact = vec![Modi64::new(1); max_n + 1];\n        for i in 1..(max_n + 1) {\n            fact[i] = fact[i - 1] * Modi64::new(i as i64);\n            inv_fact[i] = inv_fact[i - 1] / Modi64::new(i as i64);\n        }\n        MemorizedFactorial {\n            n: max_n + 1,\n            fact: fact,\n            inv_fact: inv_fact,\n        }\n    }\n    pub fn combination(&self, n: usize, r: usize) -> Modi64 {\n        if r <= n {\n            self.fact[n] * self.inv_fact[r] * self.inv_fact[n - r]\n        } else {\n            Modi64::new(0)\n        }\n    }\n    pub fn permutation(&self, n: usize, r: usize) -> Modi64 {\n        if r <= n {\n            self.fact[n] * self.inv_fact[n - r]\n        } else {\n            Modi64::new(0)\n        }\n    }\n    pub fn homogeneous_product(&self, n: usize, r: usize) -> Modi64 {\n        if n != 0 && r != 0 {\n            self.combination(n + r - 1, r)\n        } else {\n            Modi64::new(1)\n        }\n    }\n}\nfn main() {\n    input! { n, m };\n    let mut ans = Modi64(0);\n    let fact = MemorizedFactorial::new(n + m * 3 / 2 + 2);\n    for i in 0..m + 1 {\n        if (m + i) % 2 == 0 {\n            ans += fact.combination(n, i) * fact.combination((3 * m - i) / 2 + n - 1, n - 1);\n        }\n    }\n    for i in 0..m + 1 {\n        if (m + i) % 2 == 0 {\n            ans -= fact.combination(n, i)\n                * fact.combination((m - i) / 2 + n - 1, n - 1)\n                * Modi64(n as i64);\n        }\n    }\n    for i in 0..m + 1 {\n        if (m + i) % 2 == 0 {\n            ans += fact.combination(n - 1, i)\n                * fact.combination((m - i) / 2 + n - 2, n - 2)\n                * Modi64(n as i64);\n        }\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n/// Verified by https://atcoder.jp/contests/arc093/submissions/3968098\nmod mod_int {\n    use std::ops::*;\n    pub trait Mod: Copy { fn m() -> i64; }\n    #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt<M> { pub x: i64, phantom: ::std::marker::PhantomData<M> }\n    impl<M: Mod> ModInt<M> {\n        // x >= 0\n        pub fn new(x: i64) -> Self { ModInt::new_internal(x % M::m()) }\n        fn new_internal(x: i64) -> Self {\n            ModInt { x: x, phantom: ::std::marker::PhantomData }\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new_internal(1);\n            let mut cur = self;\n            while e > 0 {\n                if e % 2 != 0 { sum *= cur; }\n                cur *= cur;\n                e /= 2;\n            }\n            sum\n        }\n        #[allow(dead_code)]\n        pub fn inv(self) -> Self { self.pow(M::m() - 2) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Add<T> for ModInt<M> {\n        type Output = Self;\n        fn add(self, other: T) -> Self {\n            let other = other.into();\n            let mut sum = self.x + other.x;\n            if sum >= M::m() { sum -= M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Sub<T> for ModInt<M> {\n        type Output = Self;\n        fn sub(self, other: T) -> Self {\n            let other = other.into();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Mul<T> for ModInt<M> {\n        type Output = Self;\n        fn mul(self, other: T) -> Self { ModInt::new(self.x * other.into().x % M::m()) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> AddAssign<T> for ModInt<M> {\n        fn add_assign(&mut self, other: T) { *self = *self + other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> SubAssign<T> for ModInt<M> {\n        fn sub_assign(&mut self, other: T) { *self = *self - other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> MulAssign<T> for ModInt<M> {\n        fn mul_assign(&mut self, other: T) { *self = *self * other; }\n    }\n    impl<M: Mod> Neg for ModInt<M> {\n        type Output = Self;\n        fn neg(self) -> Self { ModInt::new(0) - self }\n    }\n    impl<M> ::std::fmt::Display for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n    impl<M: Mod> ::std::fmt::Debug for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            let (mut a, mut b, _) = red(self.x, M::m());\n            if b < 0 {\n                a = -a;\n                b = -b;\n            }\n            write!(f, \"{}/{}\", a, b)\n        }\n    }\n    impl<M: Mod> From<i64> for ModInt<M> {\n        fn from(x: i64) -> Self { Self::new(x) }\n    }\n    // Finds the simplest fraction x/y congruent to r mod p.\n    // The return value (x, y, z) satisfies x = y * r + z * p.\n    fn red(r: i64, p: i64) -> (i64, i64, i64) {\n        if r.abs() <= 10000 {\n            return (r, 1, 0);\n        }\n        let mut nxt_r = p % r;\n        let mut q = p / r;\n        if 2 * nxt_r >= r {\n            nxt_r -= r;\n            q += 1;\n        }\n        if 2 * nxt_r <= -r {\n            nxt_r += r;\n            q -= 1;\n        }\n        let (x, z, y) = red(nxt_r, r);\n        (x, y - q * z, z)\n    }\n} // mod mod_int\n\nmacro_rules! define_mod {\n    ($struct_name: ident, $modulo: expr) => {\n        #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n        struct $struct_name {}\n        impl mod_int::Mod for $struct_name { fn m() -> i64 { $modulo } }\n    }\n}\nconst MOD: i64 = 998244353;\ndefine_mod!(P, MOD);\ntype ModInt = mod_int::ModInt<P>;\n\n// Depends on ModInt.rs\nfn fact_init(w: usize) -> (Vec<ModInt>, Vec<ModInt>) {\n    let mut fac = vec![ModInt::new(1); w];\n    let mut invfac = vec![0.into(); w];\n    for i in 1 .. w {\n        fac[i] = fac[i - 1] * i as i64;\n    }\n    invfac[w - 1] = fac[w - 1].inv();\n    for i in (0 .. w - 1).rev() {\n        invfac[i] = invfac[i + 1] * (i as i64 + 1);\n    }\n    (fac, invfac)\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize, m: usize,\n    }\n    let (fac, invfac) = fact_init(n + 2 * m);\n    let mut tot = ModInt::new(0);\n    for k in 0..n + 1 {\n        if (k + m) % 2 != 0 || k > m {\n            continue;\n        }\n        let u = (m - k) / 2;\n        let mut sum = fac[u + m + n - 1] * invfac[u + m] * invfac[n - 1];\n        if u >= 1 {\n            let tmp1 = fac[u - 1 + n - 1] * invfac[n - 1] * invfac[u - 1] * (n as i64);\n            sum -= tmp1;\n        }\n        let tmp2 = fac[u + n - 2] * invfac[u] * invfac[n - 2];\n        let tmp2 = tmp2 * (k as i64);\n        sum -= tmp2;\n        tot += sum * fac[n] * invfac[k] * invfac[n - k];\n    }\n    puts!(\"{}\\n\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use self::mod_int::ModInt;\nuse std::cmp::min;\n\nconst MOD: usize = 998244353;\n\nfn main() {\n    let (r, w) = (std::io::stdin(), std::io::stdout());\n    let mut sc = IO::new(r.lock(), w.lock());\n    let n: usize = sc.read();\n    let m: usize = sc.read();\n\n    let c = Combination::new(3 * m + n + 1, MOD);\n    let mut ans = ModInt(0);\n    for k in 0..min(n + 1, m + 1) {\n        if (3 * m - k) % 2 == 1 {\n            continue;\n        }\n        ans += c.get(n, k) * c.get((3 * m - k) / 2 + n - 1, n - 1);\n    }\n    for k in 0..min(n + 1, m + 1) {\n        if (m - k) % 2 == 1 {\n            continue;\n        }\n        ans -= c.get(n, k) * c.get((m - k) / 2 + n - 1, n - 1) * n;\n    }\n    if n >= 2 {\n        for k in 0..min(n, m + 1) {\n            if (m - k) % 2 == 1 {\n                continue;\n            }\n            ans += c.get(n - 1, k) * c.get((m - k) / 2 + n - 2, n - 2) * n;\n        }\n    }\n    println!(\"{}\", ans.0);\n}\n\npub struct Combination {\n    fact: Vec<usize>,\n    inv_fact: Vec<usize>,\n    modulo: usize,\n}\n\nimpl Combination {\n    pub fn new(max: usize, modulo: usize) -> Combination {\n        let mut inv = vec![0; max + 1];\n        let mut fact = vec![0; max + 1];\n        let mut inv_fact = vec![0; max + 1];\n        inv[1] = 1;\n        for i in 2..(max + 1) {\n            inv[i] = inv[modulo % i] * (modulo - modulo / i) % modulo;\n        }\n        fact[0] = 1;\n        inv_fact[0] = 1;\n        for i in 0..max {\n            fact[i + 1] = fact[i] * (i + 1) % modulo;\n        }\n        for i in 0..max {\n            inv_fact[i + 1] = inv_fact[i] * inv[i + 1] % modulo;\n        }\n        Combination {\n            fact: fact,\n            inv_fact: inv_fact,\n            modulo: modulo,\n        }\n    }\n\n    pub fn get(&self, x: usize, y: usize) -> ModInt<usize> {\n        assert!(x >= y);\n        ModInt(self.fact[x] * self.inv_fact[y] % self.modulo * self.inv_fact[x - y] % self.modulo)\n    }\n}\n\npub mod mod_int {\n    use super::MOD;\n    use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};\n\n    type Num = usize;\n\n    #[derive(Clone, Copy)]\n    pub struct ModInt<T: Copy + Clone>(pub T);\n\n    impl Add<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self + rhs.0\n        }\n    }\n\n    impl Add<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, mut rhs: Num) -> ModInt<Num> {\n            if rhs >= MOD {\n                rhs %= MOD;\n            }\n            let mut t = rhs + self.0;\n            if t >= MOD {\n                t = t - MOD;\n            }\n            ModInt(t)\n        }\n    }\n\n    impl Sub<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, rhs: Num) -> ModInt<Num> {\n            let rhs = if rhs >= MOD { rhs % MOD } else { rhs };\n            let value = if self.0 < rhs { self.0 + MOD } else { self.0 };\n            ModInt(value - rhs)\n        }\n    }\n\n    impl Sub<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self - rhs.0\n        }\n    }\n\n    impl AddAssign<Num> for ModInt<Num> {\n        fn add_assign(&mut self, other: Num) {\n            *self = *self + other;\n        }\n    }\n    impl AddAssign<ModInt<Num>> for ModInt<Num> {\n        fn add_assign(&mut self, other: ModInt<Num>) {\n            *self = *self + other;\n        }\n    }\n\n    impl SubAssign<Num> for ModInt<Num> {\n        fn sub_assign(&mut self, other: Num) {\n            *self = *self - other;\n        }\n    }\n\n    impl SubAssign<ModInt<Num>> for ModInt<Num> {\n        fn sub_assign(&mut self, other: ModInt<Num>) {\n            *self = *self - other;\n        }\n    }\n\n    impl Div<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn div(self, mut rhs: Num) -> ModInt<Num> {\n            if rhs >= MOD {\n                rhs %= MOD;\n            }\n            self * ModInt(rhs).pow(MOD - 2)\n        }\n    }\n\n    impl Div<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn div(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self / rhs.0\n        }\n    }\n\n    impl DivAssign<Num> for ModInt<Num> {\n        fn div_assign(&mut self, rhs: Num) {\n            *self = *self / rhs\n        }\n    }\n    impl DivAssign<ModInt<Num>> for ModInt<Num> {\n        fn div_assign(&mut self, rhs: ModInt<Num>) {\n            *self = *self / rhs\n        }\n    }\n\n    impl Mul<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n\n        fn mul(self, rhs: ModInt<Num>) -> ModInt<Num> {\n            self * rhs.0\n        }\n    }\n    impl Mul<Num> for ModInt<Num> {\n        type Output = ModInt<Num>;\n\n        fn mul(self, mut rhs: Num) -> ModInt<Num> {\n            if rhs >= MOD {\n                rhs %= MOD;\n            }\n            let t = (self.0 * rhs) % MOD;\n            ModInt(t)\n        }\n    }\n\n    impl MulAssign<Num> for ModInt<Num> {\n        fn mul_assign(&mut self, rhs: Num) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl MulAssign<ModInt<Num>> for ModInt<Num> {\n        fn mul_assign(&mut self, rhs: ModInt<Num>) {\n            *self = *self * rhs;\n        }\n    }\n\n    impl ModInt<Num> {\n        pub fn pow(self, e: usize) -> ModInt<Num> {\n            let mut result = ModInt(1);\n            let mut cur = self;\n            let mut e = e;\n            while e > 0 {\n                if e & 1 == 1 {\n                    result *= cur;\n                }\n                e >>= 1;\n                cur *= cur;\n            }\n            result\n        }\n    }\n}\n\npub struct IO<R, W: std::io::Write>(R, std::io::BufWriter<W>);\n\nimpl<R: std::io::Read, W: std::io::Write> IO<R, W> {\n    pub fn new(r: R, w: W) -> Self {\n        IO(r, std::io::BufWriter::new(w))\n    }\n    pub fn write<S: ToString>(&mut self, s: S) {\n        use std::io::Write;\n        self.1.write(s.to_string().as_bytes()).unwrap();\n    }\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .0\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r' || b == b'\\t')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r' && b != b'\\t')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "// ---------- begin ModInt ----------\n//https://github.com/kenkoooo/competitive-programming-rs/blob/master/src/math/mod_int.rs\n//を参考にしています\n#[allow(dead_code)]\nmod modint {\n    pub const MOD: u32 = 998_244_353;\n    use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign};\n    #[derive(Clone, Copy)]\n    pub struct ModInt<T: Copy + Clone>(pub T);\n    type Num = u32;\n    impl Add<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn add(self, other: ModInt<Num>) -> ModInt<Num> {\n            let mut d = self.0 + other.0;\n            if d >= MOD {\n                d -= MOD;\n            }\n            ModInt(d)\n        }\n    }\n    impl AddAssign<ModInt<Num>> for ModInt<Num> {\n        fn add_assign(&mut self, other: ModInt<Num>) {\n            *self = *self + other;\n        }\n    }\n    impl Sub<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn sub(self, other: ModInt<Num>) -> ModInt<Num> {\n            let mut d = self.0 + MOD - other.0;\n            if d >= MOD {\n                d -= MOD;\n            }\n            ModInt(d)\n        }\n    }\n    impl SubAssign<ModInt<Num>> for ModInt<Num> {\n        fn sub_assign(&mut self, other: ModInt<Num>) {\n            *self = *self - other;\n        }\n    }\n    impl Mul<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn mul(self, other: ModInt<Num>) -> ModInt<Num> {\n            ModInt(((self.0 as u64) * (other.0 as u64) % (MOD as u64)) as u32)\n        }\n    }\n    impl MulAssign<ModInt<Num>> for ModInt<Num> {\n        fn mul_assign(&mut self, other: ModInt<Num>) {\n            *self = *self * other;\n        }\n    }\n    impl Div<ModInt<Num>> for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn div(self, other: ModInt<Num>) -> ModInt<Num> {\n            self * other.pow(MOD - 2)\n        }\n    }\n    impl DivAssign<ModInt<Num>> for ModInt<Num> {\n        fn div_assign(&mut self, other: ModInt<Num>) {\n            *self = *self / other;\n        }\n    }\n    impl Neg for ModInt<Num> {\n        type Output = ModInt<Num>;\n        fn neg(self) -> ModInt<Num> {\n            ModInt(if self.0 == 0 { 0 } else { MOD - self.0 })\n        }\n    }\n    impl ModInt<Num> {\n        pub fn new(v: u32) -> ModInt<Num> {\n            ModInt(v % MOD)\n        }\n        pub fn pow(self, mut n: u32) -> ModInt<Num> {\n            let mut t = ModInt::new(1);\n            let mut s = self;\n            while n > 0 {\n                if (n & 1) == 1 {\n                    t *= s;\n                }\n                s *= s;\n                n >>= 1;\n            }\n            t\n        }\n    }\n    pub struct Precalc {\n        n: usize,\n        inv: Vec<ModInt<Num>>,\n        fact: Vec<ModInt<Num>>,\n        ifact: Vec<ModInt<Num>>,\n    }\n    impl Precalc {\n        pub fn new(n: usize) -> Precalc {\n            let mut inv = vec![ModInt(1); n + 1];\n            let mut fact = vec![ModInt(1); n + 1];\n            let mut ifact = vec![ModInt(1); n + 1];\n            for i in 1..(n + 1) {\n                if i >= 2 {\n                    inv[i] = -inv[(MOD as usize) % i] * ModInt(MOD / (i as u32));\n                }\n                fact[i] = ModInt(i as u32) * fact[i - 1];\n                ifact[i] = inv[i] * ifact[i - 1];\n            }\n            Precalc {\n                n: n,\n                inv: inv,\n                fact: fact,\n                ifact: ifact,\n            }\n        }\n        pub fn fact(&self, n: usize) -> ModInt<Num> {\n            self.fact[n]\n        }\n        pub fn inv(&self, x: usize) -> ModInt<Num> {\n            self.inv[x]\n        }\n        pub fn ifact(&self, x: usize) -> ModInt<Num> {\n            self.ifact[x]\n        }\n        pub fn comb(&self, n: usize, k: usize) -> ModInt<Num> {\n            if !(k <= n) {\n                return ModInt(0);\n            }\n            self.fact[n] * self.ifact[k] * self.ifact[n - k]\n        }\n    }\n    use std;\n    impl std::fmt::Display for ModInt<Num> {\n        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n            write!(f, \"{}\", self.0)\n        }\n    }\n}\n// ---------- end ModInt ----------\n\nuse modint::*;\n\nfn run() {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).unwrap();\n    let mut it = s.trim().split_whitespace();\n    let n: usize = it.next().unwrap().parse().unwrap();\n    let m: usize = it.next().unwrap().parse().unwrap();\n    let pc = Precalc::new(n + 3 * m);\n    let mut ans = pc.comb(3 * m + n - 1, n - 1);\n    ans -= ModInt(n as u32) * pc.comb(m - 1 + n - 1, n - 1);\n    let mut i = m + 2;\n    while i <= n && i <= 3 * m {\n        let d = (3 * m - i) / 2;\n        ans -= pc.comb(n, i) * pc.comb(d + n - 1, n - 1);\n        i += 2;\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "/*------------------------------------------------------------------*/\n/*------------------------- begin template -------------------------*/\n/*------------------------------------------------------------------*/\n\n// ref: tanakh <https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8>\n// diff: using Parser\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut parser = Parser::from_str($s);\n        input_inner!{parser, $($r)*}\n    };\n    (parser = $parser:ident, $($r:tt)*) => {\n        input_inner!{$parser, $($r)*}\n    };\n    (new_stdin_parser = $parser:ident, $($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let reader = std::io::BufReader::new(stdin.lock());\n        let mut $parser = Parser::new(reader);\n        input_inner!{$parser, $($r)*}\n    };\n    ($($r:tt)*) => {\n        input!{new_stdin_parser = parser, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($parser:ident) => {};\n    ($parser:ident, ) => {};\n    ($parser:ident, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($parser, $t);\n        input_inner!{$parser $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($parser:ident, ( $($t:tt),* )) => {\n        ( $(read_value!($parser, $t)),* )\n    };\n    ($parser:ident, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($parser, $t)).collect::<Vec<_>>()\n    };\n    ($parser:ident, chars) => {\n        read_value!($parser, String).chars().collect::<Vec<char>>()\n    };\n    ($parser:ident, char_) => {\n        read_value!($parser, String).chars().collect::<Vec<char>>()[0]\n    };\n    ($parser:ident, usize1) => {\n        read_value!($parser, usize) - 1\n    };\n    ($parser:ident, i64_) => {\n        $parser.fast_i64()\n    };\n    ($parser:ident, usize_) => {\n        $parser.fast_i64() as usize\n    };\n    ($parser:ident, usize1_) => {\n        ($parser.fast_i64() - 1) as usize\n    };\n    ($parser:ident, $t:ty) => {\n        $parser.next::<$t>().expect(\"Parse error\")\n    };\n}\n\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\n\n// ref: tatsuya6502 <https://qiita.com/tatsuya6502/items/cd448486f7ef7b5b8c7e>\n// ref: wariuni <https://qiita.com/tatsuya6502/items/cd448486f7ef7b5b8c7e#comment-7040a5ae96305e884eb9>\n// diff: using std::io::BufRead::fill_buf()\npub struct Parser<R> {\n    pub reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\n\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\n\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return unsafe { str::from_utf8_unchecked(&self.buf[begin..end]) }.parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n    pub fn fast_i64(&mut self) -> i64 {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            if begin == self.buf.len() {\n                self.update_buf();\n                continue;\n            }\n            let mut res = 0;\n            let (is_positive, mut end) = match self.buf[begin] {\n                b'+' => (true, begin + 1),\n                b'-' => (false, begin + 1),\n                _ => (true, begin),\n            };\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                res = res * 10 + (self.buf[end] as i64 - '0' as i64);\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return if is_positive { res } else { -res };\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n\n#[allow(unused_imports)]\nuse std::cmp::*;\nuse std::collections::BTreeSet;\nuse std::marker::PhantomData;\nuse std::ops::*;\n\npub trait ModP {\n    fn as_u64() -> u64;\n}\n\n#[allow(non_camel_case_types)]\n#[derive(Clone, Copy, Debug)]\npub struct Mod_1_000_000_007();\nimpl ModP for Mod_1_000_000_007 {\n    fn as_u64() -> u64 {\n        1_000_000_007\n    }\n}\n\n#[allow(non_camel_case_types)]\n#[derive(Clone, Copy, Debug)]\npub struct Mod_998_244_353();\nimpl ModP for Mod_998_244_353 {\n    fn as_u64() -> u64 {\n        998_244_353\n    }\n}\n\n#[derive(Clone, Copy, PartialEq, Debug)]\npub struct Modular<P: ModP + Copy>(u32, PhantomData<P>);\n\nimpl<P: ModP + Copy> Modular<P> {\n    pub fn new(x: u32) -> Modular<P> {\n        Modular((x as u64 % P::as_u64()) as u32, PhantomData)\n    }\n    pub fn pow(self, n: u64) -> Modular<P> {\n        if n == 0 {\n            return Modular(1, PhantomData);\n        }\n        let t = self.pow(n / 2);\n        if n % 2 == 0 {\n            t * t\n        } else {\n            t * t * self\n        }\n    }\n    pub fn as_u32(self) -> u32 {\n        self.0\n    }\n}\n\nimpl<P: ModP + Copy> Add for Modular<P> {\n    type Output = Self;\n    fn add(self, rhs: Self) -> Self::Output {\n        let t = (self.0 + rhs.0) as u64;\n        let u = if t < P::as_u64() { t } else { t - P::as_u64() };\n        Modular(u as u32, PhantomData)\n    }\n}\n\nimpl<P: ModP + Copy> AddAssign for Modular<P> {\n    fn add_assign(&mut self, rhs: Self) {\n        *self = *self + rhs;\n    }\n}\n\nimpl<P: ModP + Copy> Sub for Modular<P> {\n    type Output = Self;\n    fn sub(self, rhs: Self) -> Self::Output {\n        let t = if self.0 >= rhs.0 {\n            self.0 as u64 - rhs.0 as u64\n        } else {\n            self.0 as u64 + P::as_u64() - rhs.0 as u64\n        };\n        assert!(t < P::as_u64());\n        Modular(t as u32, PhantomData)\n    }\n}\n\nimpl<P: ModP + Copy> SubAssign for Modular<P> {\n    fn sub_assign(&mut self, rhs: Self) {\n        *self = *self - rhs;\n    }\n}\n\nimpl<P: ModP + Copy> Neg for Modular<P> {\n    type Output = Modular<P>;\n    fn neg(self) -> Modular<P> {\n        Modular((P::as_u64() - self.0 as u64) as u32, PhantomData)\n    }\n}\n\nimpl<P: ModP + Copy> Mul for Modular<P> {\n    type Output = Self;\n    fn mul(self, rhs: Self) -> Self::Output {\n        Modular(\n            ((self.0 as u64 % P::as_u64()) * (rhs.0 as u64 % P::as_u64()) % P::as_u64()) as u32,\n            PhantomData,\n        )\n    }\n}\n\nimpl<P: ModP + Copy> MulAssign for Modular<P> {\n    fn mul_assign(&mut self, rhs: Self) {\n        *self = *self * rhs;\n    }\n}\n\nimpl<P: ModP + Copy> Div for Modular<P> {\n    type Output = Self;\n    fn div(self, rhs: Self) -> Self::Output {\n        if rhs.0 == 0 {\n            loop {}\n        }\n        assert!(rhs.0 != 0);\n        self * rhs.pow(P::as_u64() - 2)\n    }\n}\n\npub fn gen_fact_table<P: ModP + Copy>(n: usize) -> Vec<Modular<P>> {\n    let mut res = vec![Modular::<P>::new(1); n + 1];\n    for i in 0..n {\n        res[i + 1] = res[i] * Modular::<P>::new((i + 1) as u32);\n    }\n    res\n}\n\npub fn gen_inv_table<P: ModP + Copy>(n: usize) -> Vec<Modular<P>> {\n    let mut res = vec![Modular::<P>::new(0); n + 1];\n    res[1] = Modular::<P>::new(1);\n    for i in 2..n + 1 {\n        res[i] =\n            -res[P::as_u64() as usize % i] * Modular::<P>::new((P::as_u64() / i as u64) as u32);\n    }\n    res\n}\n\nfn main() {\n    input! {\n        new_stdin_parser = parser,\n    }\n    let res = solve(&mut parser);\n    print!(\"{}\", res);\n}\n\n/*------------------------------------------------------------------*/\n/*-------------------------- end template --------------------------*/\n/*------------------------------------------------------------------*/\n\ntype Mod = Modular<Mod_998_244_353>;\n\npub fn dfs(n: usize, m: usize, set: &mut BTreeSet<Vec<usize>>, buf: &mut Vec<usize>) {\n    if m == 0 {\n        set.insert(buf.clone());\n        return;\n    }\n    for i in 0..n {\n        for k in 0..n {\n            if i == k {\n                continue;\n            }\n            buf[i] += 1;\n            buf[k] += 1;\n            dfs(n, m - 1, set, buf);\n            buf[i] -= 1;\n            buf[k] -= 1;\n        }\n    }\n}\n\npub fn f(n: usize, m: usize) -> usize {\n    let mut buf = vec![0; n];\n    let mut set = BTreeSet::new();\n    dfs(n, m, &mut set, &mut buf);\n    set.len()\n}\n\nuse std::fmt::Write;\nfn solve<R: BufRead>(parser: &mut Parser<R>) -> String {\n    let mut buf = String::new();\n    input! {\n        parser = parser,\n        n: usize,\n        m: usize,\n    }\n    let facts = gen_fact_table::<Mod_998_244_353>(2000000);\n    let mut res = Mod::new(0);\n    let nCr = |n: usize, r: usize| {\n        if n < r {\n            Mod::new(0)\n        } else {\n            facts[n] / (facts[n - r] * facts[r])\n        }\n    };\n    let nHr = |n: usize, r: usize| nCr(n + r - 1, n);\n    for i in 0..m + 1 {\n        if i % 2 == 1 {\n            continue;\n        }\n        let s = nCr(n, m - i);\n        let t = nHr(m + i / 2, n);\n        let u = s * t;\n        // eprintln!(\"i = {}, s = {}, t = {}, u = {}\", i, s.as_u32(), t.as_u32(), u.as_u32());\n        res += u;\n    }\n    for i in 0..m + 1 {\n        if i % 2 == 1 {\n            continue;\n        }\n        let s = nCr(n, m - i);\n        let t = nHr(i / 2, n);\n        let u = s * t;\n        // eprintln!(\"i = {}, s = {}, t = {}, u = {}\", i, s.as_u32(), t.as_u32(), u.as_u32());\n        res -= Mod::new(n as u32) * u;\n    }\n    for i in 0..m + 1 {\n        if i % 2 == 1 {\n            continue;\n        }\n        let s = nCr(n - 1, m - i);\n        let t = nHr(i / 2, n - 1);\n        let u = s * t;\n        // eprintln!(\"i = {}, s = {}, t = {}, u = {}\", i, s.as_u32(), t.as_u32(), u.as_u32());\n        res += Mod::new(n as u32) * u;\n    }\n    writeln!(buf, \"{}\", res.as_u32());\n    buf\n}\n"
  },
  {
    "language": "Rust",
    "code": "// See run() at line 135 for solution.\n#![allow(unused_imports, unused_macros, non_snake_case)]\nuse std::cmp::{max, min, Ordering};\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n\n//{{{ ---- macros ----\n#[macro_use]\nmod macros {\n    // {{{ input!\n    // https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\n    macro_rules! input {\n        (source = $s:expr, $($r:tt)*) => {\n            let mut iter = $s.split_whitespace();\n            let mut next = || { iter.next().unwrap() };\n            input_inner!{next, $($r)*}\n        };\n        ($($r:tt)*) => {\n            let stdin = std::io::stdin();\n            let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n            let mut next = move || -> String{\n                bytes\n                    .by_ref()\n                    .map(|r|r.unwrap() as char)\n                    .skip_while(|c|c.is_whitespace())\n                    .take_while(|c|!c.is_whitespace())\n                    .collect()\n            };\n            input_inner!{next, $($r)*}\n        };\n    }\n    macro_rules! input_inner {\n        ($next:expr) => {};\n        ($next:expr, ) => {};\n\n        ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n            let $var = read_value!($next, $t);\n            input_inner!{$next $($r)*}\n        };\n    }\n    macro_rules! read_value {\n        ($next:expr, ( $($t:tt),* )) => {\n            ( $(read_value!($next, $t)),* )\n        };\n\n        ($next:expr, [ $t:tt ; $len:expr ]) => {\n            (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n        };\n\n        ($next:expr, chars) => {\n            read_value!($next, String).chars().collect::<Vec<char>>()\n        };\n\n        ($next:expr, usize1) => {\n            read_value!($next, usize) - 1\n        };\n\n        ($next:expr, $t:ty) => {\n            $next().parse::<$t>().expect(\"Parse error\")\n        };\n    }\n    //}}}\n\n    //{{{ read!\n    macro_rules! read {\n        ($($t:tt),*; $n:expr) => {{\n            let stdin = ::std::io::stdin();\n            let ret = ::std::io::BufRead::lines(stdin.lock()).take($n).map(|line| {\n                let line = line.unwrap();\n                let mut it = line.split_whitespace();\n                _read!(it; $($t),*)\n            }).collect::<Vec<_>>();\n            ret\n        }};\n        ($($t:tt),*) => {{\n            let line = readln();\n            let mut it = line.split_whitespace();\n            _read!(it; $($t),*)\n        }};\n    }\n\n    macro_rules! _read {\n        ($it:ident; [char]) => {\n            _read!($it; String).chars().collect::<Vec<_>>()\n        };\n        ($it:ident; [u8]) => {\n            Vec::from(_read!($it; String).into_bytes())\n        };\n        ($it:ident; [$t:ty]) => {\n            $it.map(|s| s.parse::<$t>().unwrap_or_else(|e| panic!(\"{}\", e))).collect::<Vec<_>>()\n        };\n        ($it:ident; $t:ty) => {\n            $it.next().unwrap_or_else(|| panic!(\"input mismatch\")).parse::<$t>().unwrap_or_else(|e| panic!(\"{}\", e))\n        };\n        ($it:ident; $($t:ty),+) => {\n            ($(_read!($it; $t)),*)\n        };\n    }\n    //}}}\n\n    //{{{ utility macros missing in 1.15.1\n    // https://atcoder.jp/contests/nikkei2019-qual/submissions/4098548\n    macro_rules! eprint {\n        ($($t:tt)*) => {{\n            use ::std::io::Write;\n            let _ = write!(::std::io::stderr(), $($t)*);\n        }};\n    }\n    macro_rules! eprintln {\n        () => { eprintln!(\"\"); };\n        ($($t:tt)*) => {{\n            use ::std::io::Write;\n            let _ = writeln!(::std::io::stderr(), $($t)*);\n        }};\n    }\n    macro_rules! dbg {\n        ($val:expr) => {\n            match $val {\n                tmp => {\n                    eprintln!(\n                        \"[{}:{}] {} = {:#?}\",\n                        file!(),\n                        line!(),\n                        stringify!($val),\n                        &tmp\n                    );\n                    tmp\n                }\n            }\n        };\n    }\n    //}}}\n}\n//}}}\n\nfn solve(n: usize, m: usize) -> usize {\n    use algonium::math::Mint998;\n    let mut dp = vec![vec![Mint998::from(0); m + 1]; 3 * m + 1];\n    // [sum][odd]\n    dp[0][0] = 1.into();\n    for i in 0..n {\n        let mut ndp = vec![vec![Mint998::from(0); m + 1]; 3 * m + 1];\n        for x in 0..2 * m + 1 {\n            for s in (0..3 * m + 1 - x).rev() {\n                for o in (0..m + 1).rev() {\n                    let ns = s + x;\n                    let no = o + if x % 2 == 1 { 1 } else { 0 };\n                    if ns <= 3 * m && no <= m {\n                        ndp[ns][no] += dp[s][o];\n                    }\n                }\n            }\n        }\n        dp = ndp;\n    }\n    let mut ans = Mint998::from(0);\n    for o in (0..m + 1).rev() {\n        ans += dp[3 * m][o];\n    }\n    ans.val as usize\n}\nfn run() {\n    input! {\n        n: usize,\n        m: usize,\n    }\n    println!(\"{}\", solve(n, m));\n}\n\n//{{{ ---- template ----\nfn main() {\n    let _ = ::std::thread::Builder::new()\n        .name(\"run\".to_string())\n        .stack_size(256 * 1024 * 1024)\n        .spawn(run)\n        .unwrap()\n        .join()\n        .unwrap();\n}\n\npub trait SetMinMax {\n    fn set_min(&mut self, v: Self) -> bool;\n    fn set_max(&mut self, v: Self) -> bool;\n}\n\nimpl<T> SetMinMax for T\nwhere\n    T: PartialOrd,\n{\n    fn set_min(&mut self, v: T) -> bool {\n        *self > v && {\n            *self = v;\n            true\n        }\n    }\n    fn set_max(&mut self, v: T) -> bool {\n        *self < v && {\n            *self = v;\n            true\n        }\n    }\n}\n\n#[derive(PartialEq, Eq, Debug, Copy, Clone, Default, Hash)]\npub struct Reverse<T>(pub T);\n\nimpl<T: PartialOrd> PartialOrd for Reverse<T> {\n    #[inline]\n    fn partial_cmp(&self, other: &Reverse<T>) -> Option<Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n\n    #[inline]\n    fn lt(&self, other: &Self) -> bool {\n        other.0 < self.0\n    }\n    #[inline]\n    fn le(&self, other: &Self) -> bool {\n        other.0 <= self.0\n    }\n    #[inline]\n    fn ge(&self, other: &Self) -> bool {\n        other.0 >= self.0\n    }\n    #[inline]\n    fn gt(&self, other: &Self) -> bool {\n        other.0 > self.0\n    }\n}\n\nimpl<T: Ord> Ord for Reverse<T> {\n    #[inline]\n    fn cmp(&self, other: &Reverse<T>) -> Ordering {\n        other.0.cmp(&self.0)\n    }\n}\n\n#[allow(unused)] // This is defined for read! macro\nfn readln() -> String {\n    let mut line = String::new();\n    ::std::io::stdin()\n        .read_line(&mut line)\n        .unwrap_or_else(|e| panic!(\"{}\", e));\n    line\n}\n//}}}\n\n//{{{ https://github.com/ichyo/rust-algorithms.git\npub mod algonium {\n    #![doc = \" This library provides a collection of classic algorithms,\"]\n    #![doc = \" focusing on programming contests such as codeforces and atcoder.\"]\n    pub mod data_structure {\n        mod bit {\n            #[doc = \" Binary Indexed Tree (0-indexed)\"]\n            #[doc = \"\"]\n            #[doc = \" This data structure supports these two queries in O(log n)\"]\n            #[doc = \"\"]\n            #[doc = \" 1. add w to v[at]\"]\n            #[doc = \" 2. the sum of v[begin], v[begin+1], .., v[end-1]\"]\n            pub struct BIT {\n                tree: Vec<i64>,\n            }\n            #[doc = \" Binary Indexed Tree (range-version) (0-indexed)\"]\n            #[doc = \"\"]\n            #[doc = \" This data structure two queries in O(log n)\"]\n            #[doc = \"\"]\n            #[doc = \" 1. add w to v[begin], v[begin+1], ..., v[end-1]\"]\n            #[doc = \" 2. get the sum of v[begin], v[begin+1], ..., v[end-1]\"]\n            pub struct BITRange {\n                bit0: BIT,\n                bit1: BIT,\n            }\n            impl BIT {\n                #[doc = \" Constructs a new BIT of length `len`.\"]\n                #[doc = \" All values are initialized zero.\"]\n                #[doc = \"\"]\n                #[doc = \" # Examples\"]\n                #[doc = \" ```\"]\n                #[doc = \" use algonium::data_structure::BIT;\"]\n                #[doc = \" # #[warn(unused_mut)]\"]\n                #[doc = \" let mut bit = BIT::new(100);\"]\n                #[doc = \" ```\"]\n                pub fn new(len: usize) -> BIT {\n                    BIT { tree: vec![0; len] }\n                }\n                #[doc = \" Returns the number of elements in the BIT.\"]\n                #[doc = \"\"]\n                #[doc = \" # Examples\"]\n                #[doc = \"\"]\n                #[doc = \" ```\"]\n                #[doc = \" use algonium::data_structure::BIT;\"]\n                #[doc = \" let mut bit = BIT::new(100);\"]\n                #[doc = \" assert_eq!(bit.len(), 100);\"]\n                #[doc = \" ```\"]\n                pub fn len(&self) -> usize {\n                    self.tree.len()\n                }\n                #[doc = \" Add a value `value` to a element of index `index`.\"]\n                #[doc = \" v[index] += value\"]\n                #[doc = \"\"]\n                #[doc = \" # Panics\"]\n                #[doc = \"\"]\n                #[doc = \" Panics if `index > len`\"]\n                #[doc = \"\"]\n                #[doc = \" # Examples\"]\n                #[doc = \"\"]\n                #[doc = \" ```\"]\n                #[doc = \" use algonium::data_structure::BIT;\"]\n                #[doc = \" let mut bit = BIT::new(10);\"]\n                #[doc = \" bit.add(5, 100);\"]\n                #[doc = \" assert_eq!(bit.get(3, 6), 100);\"]\n                #[doc = \" bit.add(5, 10);\"]\n                #[doc = \" assert_eq!(bit.get(3, 6), 110);\"]\n                #[doc = \" ```\"]\n                pub fn add(&mut self, index: usize, value: i64) {\n                    assert!(index < self.tree.len());\n                    let mut idx = index;\n                    while idx < self.tree.len() {\n                        self.tree[idx] += value;\n                        idx |= idx + 1;\n                    }\n                }\n                #[doc = \" sum of v[idx] such that begin <= idx < end\"]\n                pub fn get(&self, begin: usize, end: usize) -> i64 {\n                    if begin >= end {\n                        return 0;\n                    }\n                    let a = if end > 0 { self.cum(end - 1) } else { 0 };\n                    let b = if begin > 0 { self.cum(begin - 1) } else { 0 };\n                    a - b\n                }\n                #[doc = \" v[0] + ... + v[last]\"]\n                fn cum(&self, last: usize) -> i64 {\n                    assert!(last < self.tree.len());\n                    let mut res = 0;\n                    let mut idx = last as i64;\n                    while idx >= 0 {\n                        res += self.tree[idx as usize];\n                        idx = (idx & (idx + 1)) - 1;\n                    }\n                    res\n                }\n            }\n            impl BITRange {\n                pub fn new(n: usize) -> BITRange {\n                    BITRange {\n                        bit0: BIT::new(n + 1),\n                        bit1: BIT::new(n + 1),\n                    }\n                }\n                #[doc = \" v[begin], v[begin+1], ..., v[end-1] += by\"]\n                pub fn add(&mut self, begin: usize, end: usize, by: i64) {\n                    if begin >= end {\n                        return;\n                    }\n                    let a = begin as i64;\n                    let b = end as i64;\n                    self.bit0.add(begin, -by * a);\n                    self.bit0.add(end, by * b);\n                    self.bit1.add(begin, by);\n                    self.bit1.add(end, -by);\n                }\n                #[doc = \" v[begin] + ... + v[end-1]\"]\n                pub fn get(&self, begin: usize, end: usize) -> i64 {\n                    if begin >= end {\n                        return 0;\n                    }\n                    self.cum(end) - self.cum(begin)\n                }\n                #[doc = \" v[0] + ... + v[end-1]\"]\n                fn cum(&self, end: usize) -> i64 {\n                    let a = self.bit0.get(0, end);\n                    let b = self.bit1.get(0, end);\n                    a + b * end as i64\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                #[should_panic]\n                fn test_out_of_bound_add() {\n                    let mut bit = BIT::new(10);\n                    bit.add(100, 1);\n                }\n                #[test]\n                #[should_panic]\n                fn test_out_of_bound_range_add() {\n                    let mut bit = BITRange::new(10);\n                    bit.add(5, 100, 1);\n                }\n                #[test]\n                #[should_panic]\n                fn test_out_of_bound_get() {\n                    let bit = BIT::new(10);\n                    bit.get(0, 1000);\n                }\n                #[test]\n                fn test_empty_range() {\n                    let mut bit = BITRange::new(10);\n                    bit.add(9, 0, 100);\n                    bit.add(7, 3, 100);\n                    assert_eq!(0, bit.get(0, 9));\n                    assert_eq!(0, bit.get(0, 5));\n                    assert_eq!(0, bit.get(2, 5));\n                }\n                #[test]\n                fn test_simple() {\n                    let mut bit = BIT::new(10);\n                    bit.add(2, 1);\n                    bit.add(3, 3);\n                    bit.add(5, 10);\n                    bit.add(0, -4);\n                    bit.add(9, -5);\n                    assert_eq!(5, bit.get(0, 10));\n                    assert_eq!(4, bit.get(2, 4));\n                    assert_eq!(1, bit.get(2, 3));\n                    assert_eq!(0, bit.get(2, 2));\n                    assert_eq!(0, bit.get(2, 0));\n                    assert_eq!(-4, bit.get(0, 1));\n                    assert_eq!(5, bit.get(5, 10));\n                    let mut bit = BITRange::new(10);\n                    bit.add(1, 3, 1);\n                    bit.add(2, 5, 2);\n                    assert_eq!(1, bit.get(1, 2));\n                    assert_eq!(4, bit.get(1, 3));\n                    assert_eq!(6, bit.get(1, 4));\n                    assert_eq!(6, bit.get(0, 4));\n                }\n            }\n        }\n        mod segment_tree {\n            use std::cmp;\n            use std::marker::PhantomData;\n            pub trait Monoid<T> {\n                fn id() -> Option<T> {\n                    None\n                }\n                fn op(l: &Option<T>, r: &Option<T>) -> Option<T>;\n            }\n            pub struct MinOp<T: Ord> {\n                phantom: PhantomData<T>,\n            }\n            impl<T: Ord + Clone> Monoid<T> for MinOp<T> {\n                #[inline]\n                fn op(l: &Option<T>, r: &Option<T>) -> Option<T> {\n                    match (l.clone(), r.clone()) {\n                        (Some(l), Some(r)) => Some(cmp::min(l, r)),\n                        (Some(l), None) => Some(l),\n                        (None, Some(r)) => Some(r),\n                        (None, None) => None,\n                    }\n                }\n            }\n            pub struct SegmentTree<M: Monoid<T>, T: Clone> {\n                phantom: PhantomData<M>,\n                data: Vec<Option<T>>,\n                size: usize,\n                size_p2: usize,\n            }\n            impl<M: Monoid<T>, T: Clone> SegmentTree<M, T> {\n                pub fn from_vec(v: Vec<T>) -> SegmentTree<M, T> {\n                    let size = v.len();\n                    let mut size_p2 = 1;\n                    while size_p2 < v.len() {\n                        size_p2 *= 2;\n                    }\n                    let mut data = vec![None; size_p2 * 2];\n                    for (i, x) in v.into_iter().enumerate() {\n                        data[size_p2 + i] = Some(x);\n                    }\n                    for i in (0..size_p2).rev() {\n                        data[i] = M::op(&data[i * 2 + 0], &data[i * 2 + 1]);\n                    }\n                    SegmentTree {\n                        phantom: PhantomData,\n                        data: data,\n                        size: size,\n                        size_p2: size_p2,\n                    }\n                }\n                pub fn size(&self) -> usize {\n                    self.size\n                }\n                pub fn update(&mut self, mut pos: usize, value: T) {\n                    assert!(pos < self.size);\n                    pos += self.size_p2;\n                    self.data[pos] = Some(value);\n                    loop {\n                        pos /= 2;\n                        if pos == 0 {\n                            break;\n                        }\n                        self.data[pos] = M::op(&self.data[pos * 2], &self.data[pos * 2 + 1]);\n                    }\n                }\n                pub fn query(&self, mut l: usize, mut r: usize) -> Option<T> {\n                    assert!(l <= r && r <= self.size);\n                    l += self.size_p2;\n                    r += self.size_p2;\n                    let mut res1 = M::id();\n                    let mut res2 = M::id();\n                    while l < r {\n                        if (l & 1) != 0 {\n                            res1 = M::op(&res1, &self.data[l]);\n                            l += 1;\n                        }\n                        if (r & 1) != 0 {\n                            r -= 1;\n                            res2 = M::op(&self.data[r], &res2);\n                        }\n                        l >>= 1;\n                        r >>= 1;\n                    }\n                    M::op(&res1, &res2)\n                }\n            }\n            #[doc = \" segment tree to get minimum value in a range\"]\n            pub type RMQ<T> = SegmentTree<MinOp<T>, T>;\n            #[cfg(test)]\n            mod tests {\n                use super::RMQ;\n                #[test]\n                fn test_rms() {\n                    let mut test = vec![1, 5, 4, 8, 6, 9, 2, 0, 8, 1];\n                    let mut rms = RMQ::from_vec(test.clone());\n                    for i in 0..test.len() {\n                        for j in i..test.len() + 1 {\n                            assert_eq!(test[i..j].iter().cloned().min(), rms.query(i, j));\n                        }\n                    }\n                    rms.update(7, 5);\n                    test[7] = 5;\n                    for i in 0..test.len() {\n                        for j in i..test.len() + 1 {\n                            assert_eq!(test[i..j].iter().cloned().min(), rms.query(i, j));\n                        }\n                    }\n                }\n            }\n        }\n        mod union_find {\n            #[doc = \" Disjoint-set data structure\"]\n            #[doc = \"\"]\n            #[doc = \" This provides operations for disjoint sets.\"]\n            #[doc = \" They runs in nearly constatant time.\"]\n            #[doc = \" (the actual time is `O(A(n))` where `A(n)` is the inverse of ackermann function.)\"]\n            #[doc = \"\"]\n            #[doc = \" 1. unite(x, y) - unite a set including x and another set including y into one.\"]\n            #[doc = \" 2. same(x, y) - determine if x and y are in the same set.\"]\n            #[doc = \" 3. size(x) - calculate the number of elements of the set including x.\"]\n            #[doc = \"\"]\n            #[doc = \" [`UnionFind::new(n)`](#method.new) creates n disjoint sets. `i`-th set contains single element `i` (0-indexed).\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::data_structure::UnionFind;\"]\n            #[doc = \"\"]\n            #[doc = \" let mut uf = UnionFind::new(4);\"]\n            #[doc = \" assert!(!uf.same(0, 1));\"]\n            #[doc = \"\"]\n            #[doc = \" uf.unite(0, 1);\"]\n            #[doc = \" assert!(uf.same(0, 1));\"]\n            #[doc = \" assert_eq!(uf.size(0), 2);\"]\n            #[doc = \"\"]\n            #[doc = \" uf.unite(1, 2);\"]\n            #[doc = \" assert!(uf.same(0, 2));\"]\n            #[doc = \" assert_eq!(uf.size(0), 3);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            #[doc = \" # Panics\"]\n            #[doc = \" panics if `x` or `y` is not less than number of elements given in the initialization method.\"]\n            #[doc = \"\"]\n            pub struct UnionFind {\n                data: Vec<i32>,\n            }\n            impl UnionFind {\n                #[doc = \" Creates a object with n disjoint sets. `i`-th set is `{ i }`.\"]\n                pub fn new(n: usize) -> UnionFind {\n                    UnionFind { data: vec![-1; n] }\n                }\n                #[doc = \" Unite a set including `x` and another set including y into one.\"]\n                #[doc = \" Returns `true` only if they were in different set.\"]\n                pub fn unite(&mut self, x: usize, y: usize) -> bool {\n                    let x = self.root(x);\n                    let y = self.root(y);\n                    if x != y {\n                        let (x, y) = if self.data[x] <= self.data[y] {\n                            (x, y)\n                        } else {\n                            (y, x)\n                        };\n                        self.data[x] += self.data[y];\n                        self.data[y] = x as i32;\n                    }\n                    x != y\n                }\n                #[doc = \" Returns `true` only if `x` and `y` are in a same set.\"]\n                pub fn same(&mut self, x: usize, y: usize) -> bool {\n                    self.root(x) == self.root(y)\n                }\n                #[doc = \" Returns the number of elements of a set including `x`.\"]\n                pub fn size(&mut self, x: usize) -> u32 {\n                    let r = self.root(x);\n                    (-self.data[r]) as u32\n                }\n                #[doc = \" internal method to return representative element of a set including `x`.\"]\n                pub fn root(&mut self, x: usize) -> usize {\n                    if self.data[x] < 0 {\n                        x\n                    } else {\n                        let nx = self.data[x] as usize;\n                        let r = self.root(nx);\n                        self.data[x] = r as i32;\n                        r\n                    }\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let mut uf = UnionFind::new(3);\n                    assert_eq!(1, uf.size(0));\n                    assert_eq!(1, uf.size(1));\n                    assert_eq!(1, uf.size(2));\n                    assert_eq!(0, uf.root(0));\n                    assert_eq!(1, uf.root(1));\n                    assert_eq!(2, uf.root(2));\n                    assert!(!uf.same(1, 2));\n                    uf.unite(1, 2);\n                    assert_ne!(uf.root(0), uf.root(2));\n                    assert_eq!(uf.root(1), uf.root(2));\n                    assert_eq!(1, uf.size(0));\n                    assert_eq!(2, uf.size(1));\n                    assert_eq!(2, uf.size(2));\n                    assert!(uf.same(1, 2));\n                    uf.unite(0, 1);\n                    assert_eq!(uf.root(0), uf.root(2));\n                    assert_eq!(uf.root(1), uf.root(2));\n                    assert_eq!(3, uf.size(0));\n                    assert_eq!(3, uf.size(1));\n                    assert_eq!(3, uf.size(2));\n                    assert!(uf.same(1, 2));\n                    assert!(uf.same(0, 2));\n                }\n            }\n        }\n        pub use self::bit::{BITRange, BIT};\n        pub use self::segment_tree::{MinOp, Monoid, SegmentTree, RMQ};\n        pub use self::union_find::UnionFind;\n    }\n    pub mod math {\n        mod comb {\n            use super::mint::{Mint, Module};\n            #[doc = \" Useful struct to compute combinations\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Comb, Mod107, Mint107};\"]\n            #[doc = \" let comb: Comb<Mod107> = Comb::new(100);\"]\n            #[doc = \" assert_eq!(Mint107::from(24), comb.fact(4));\"]\n            #[doc = \" assert_eq!(Mint107::from(1), comb.fact(4) * comb.factinv(4));\"]\n            #[doc = \" assert_eq!(Mint107::from(12), comb.perm(4, 2));\"]\n            #[doc = \" assert_eq!(Mint107::from(6), comb.comb(4, 2));\"]\n            #[doc = \" assert_eq!(Mint107::from(10), comb.multi_comb(4, 2));\"]\n            #[doc = \" ```\"]\n            pub struct Comb<M: Module> {\n                fact: Vec<Mint<M>>,\n                factinv: Vec<Mint<M>>,\n            }\n            impl<M: Module> Comb<M> {\n                #[doc = \" Create a object that provides effiecint computation of combinations\"]\n                #[doc = \" for input smaller than `n`.\"]\n                #[doc = \"\"]\n                #[doc = \" This requires `O(n)` time.\"]\n                pub fn new(n: usize) -> Comb<M> {\n                    let mut fact: Vec<Mint<M>> = vec![0.into(); n + 1];\n                    let mut factinv: Vec<Mint<M>> = vec![0.into(); n + 1];\n                    fact[0] = 1.into();\n                    for i in 0..n {\n                        fact[i + 1] = fact[i] * (i + 1);\n                    }\n                    factinv[n] = fact[n].inv();\n                    for i in (0..n).rev() {\n                        factinv[i] = factinv[i + 1] * (i + 1);\n                    }\n                    Comb {\n                        fact: fact,\n                        factinv: factinv,\n                    }\n                }\n                #[doc = \" `n! = 1 * 2 * ... * n`\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n is smaller than input in `new` method.\"]\n                pub fn fact(&self, n: u64) -> Mint<M> {\n                    if let Some(x) = self.fact.get(n as usize) {\n                        *x\n                    } else if n >= M::module() as u64 {\n                        Mint::from(0)\n                    } else {\n                        let mut res = 1.into();\n                        for a in 1..(n + 1) {\n                            res *= a;\n                        }\n                        res\n                    }\n                }\n                #[doc = \" returns `y` such that `n! * y == 1`.\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n is smaller than input in `new` method.\"]\n                pub fn factinv(&self, n: u64) -> Mint<M> {\n                    if let Some(x) = self.factinv.get(n as usize) {\n                        *x\n                    } else {\n                        self.fact(n).inv()\n                    }\n                }\n                #[doc = \" `nPr = n! / (n - r)!`\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n and r are smaller than input in `new` method.\"]\n                pub fn perm(&self, n: u64, r: u64) -> Mint<M> {\n                    if n >= r {\n                        self.fact(n) * self.factinv((n - r) as u64)\n                    } else {\n                        0.into()\n                    }\n                }\n                #[doc = \" `nCr = n! / (n - r)! / r!`.\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n and r are smaller than input in `new` method.\"]\n                pub fn comb(&self, n: u64, r: u64) -> Mint<M> {\n                    let m = M::module() as u64;\n                    if n >= m {\n                        self.comb(n % m, r % m) * self.comb(n / m, r / m)\n                    } else if n >= r {\n                        self.fact(n) * self.factinv(n - r) * self.factinv(r)\n                    } else {\n                        Mint::from(0)\n                    }\n                }\n                #[doc = \" `(n + k - 1)! / k!`.\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n and r are smaller than input in `new` method.\"]\n                pub fn multi_comb(&self, n: u64, r: u64) -> Mint<M> {\n                    if r == 0 {\n                        Mint::from(1)\n                    } else {\n                        self.comb(n + r - 1, r)\n                    }\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    #[derive(Clone, Copy, Debug)]\n                    struct Mod;\n                    impl Module for Mod {\n                        fn module() -> u32 {\n                            1000000007\n                        }\n                    }\n                    let c = Comb::<Mod>::new(100);\n                    assert_eq!(Mint::from(336), c.perm(8, 3));\n                    assert_eq!(Mint::from(56), c.comb(8, 3));\n                    assert_eq!(Mint::from(10), c.multi_comb(3, 3));\n                }\n                #[test]\n                fn test_fact() {\n                    #[derive(Clone, Copy, Debug)]\n                    struct Mod;\n                    impl Module for Mod {\n                        fn module() -> u32 {\n                            1000000007\n                        }\n                    }\n                    let c = Comb::<Mod>::new(100);\n                    let p = 8721234;\n                    let mut f = Mint::from(1);\n                    for i in 1..(p + 1) {\n                        f *= i;\n                    }\n                    assert_eq!(f, c.fact(p));\n                }\n            }\n        }\n        mod mint {\n            use std::fmt;\n            use std::marker::PhantomData;\n            use std::mem;\n            use std::ops;\n            #[doc = \" Trait for `Mint`. `module()` should return prime number.\"]\n            pub trait Module: Copy + Clone {\n                fn module() -> u32;\n            }\n            #[doc = \" One of famous numbers in programming contest. `10^9 + 7`\"]\n            pub const MOD_107: u32 = 1_000_000_007;\n            #[doc = \" One of famous numbers in programming contest. `10^9 + 9`\"]\n            pub const MOD_109: u32 = 1_000_000_009;\n            #[doc = \" One of famous numbers in programming contest. `998_244_353`\"]\n            pub const MOD_998: u32 = 998_244_353;\n            #[doc = \" struct to implement Module trait. it returns `MOD_107`.\"]\n            #[derive(Debug, Copy, Clone)]\n            pub struct Mod107;\n            impl Module for Mod107 {\n                fn module() -> u32 {\n                    MOD_107\n                }\n            }\n            #[doc = \" struct to implement Module trait. it returns `MOD_109`.\"]\n            #[derive(Debug, Copy, Clone)]\n            pub struct Mod109;\n            impl Module for Mod109 {\n                fn module() -> u32 {\n                    MOD_109\n                }\n            }\n            #[doc = \" struct to implement Module trait. it returns `MOD_998`.\"]\n            #[derive(Debug, Copy, Clone)]\n            pub struct Mod998;\n            impl Module for Mod998 {\n                fn module() -> u32 {\n                    MOD_998\n                }\n            }\n            #[doc = \" Wrapper class to compute mod `1_000_000_007` automatically.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint107, MOD_107};\"]\n            #[doc = \" let x: Mint107 = 1234567.into();\"]\n            #[doc = \" let y: Mint107 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" # // TODO: implement convert to u64\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_107 as u64);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            pub type Mint107 = Mint<Mod107>;\n            #[doc = \" Wrapper class to compute mod `1_000_000_009` automatically.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint109, MOD_109};\"]\n            #[doc = \" let x: Mint109 = 1234567.into();\"]\n            #[doc = \" let y: Mint109 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_109 as u64);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            pub type Mint109 = Mint<Mod109>;\n            #[doc = \" Wrapper class to compute mod `998_244_353` automatically.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint998, MOD_998};\"]\n            #[doc = \" let x: Mint998 = 1234567.into();\"]\n            #[doc = \" let y: Mint998 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_998 as u64);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            pub type Mint998 = Mint<Mod998>;\n            #[doc = \" Wrapper class to compute modulo operation.\"]\n            #[doc = \" See examples\"]\n            #[doc = \" [`Mint107`](type.Mint107.html),\"]\n            #[doc = \" [`Mint109`](type.Mint109.html),\"]\n            #[doc = \" [`Mint998`](type.Mint998.html)\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint107, MOD_107};\"]\n            #[doc = \" let x: Mint107 = 1234567.into();\"]\n            #[doc = \" let y: Mint107 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_107 as u64);\"]\n            #[doc = \" ```\"]\n            #[derive(Debug, Copy, Clone, Eq)]\n            pub struct Mint<M: Module> {\n                #[doc = \" internal value. this is always less than `self.module()`.\"]\n                pub val: u32,\n                m: PhantomData<M>,\n            }\n            impl<M: Module> Mint<M> {\n                fn module(self) -> u32 {\n                    M::module()\n                }\n                fn new(val: u32) -> Mint<M> {\n                    assert!(val < M::module());\n                    Mint {\n                        val: val,\n                        m: PhantomData,\n                    }\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Add<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn add(self, other: T) -> Mint<M> {\n                    let nval = self.val + other.into().val;\n                    Mint::new(if nval >= self.module() {\n                        nval - self.module()\n                    } else {\n                        nval\n                    })\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Sub<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn sub(self, other: T) -> Mint<M> {\n                    let nval = self.val + self.module() - other.into().val;\n                    Mint::new(if nval >= self.module() {\n                        nval - self.module()\n                    } else {\n                        nval\n                    })\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Mul<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn mul(self, other: T) -> Mint<M> {\n                    let nval = self.val as u64 * other.into().val as u64;\n                    Mint::new((nval % (self.module() as u64)) as u32)\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Div<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn div(self, other: T) -> Mint<M> {\n                    self * other.into().inv()\n                }\n            }\n            impl<M: Module> Mint<M> {\n                #[doc = \" Returns number `y` that satisfies `x * y == 1` where `x` is the original value.\"]\n                #[doc = \"\"]\n                #[doc = \" This assumes `module()` returns prime number.\"]\n                pub fn inv(self) -> Mint<M> {\n                    let mut a = self.val as i32;\n                    let mut b = self.module() as i32;\n                    let mut u = 1 as i32;\n                    let mut v = 0 as i32;\n                    while b != 0 {\n                        let t = a / b;\n                        a -= t * b;\n                        mem::swap(&mut a, &mut b);\n                        u -= t * v;\n                        mem::swap(&mut u, &mut v);\n                    }\n                    Mint::new(if u < 0 { u + self.module() as i32 } else { u } as u32)\n                }\n            }\n            impl<M: Module> PartialEq for Mint<M> {\n                fn eq(&self, other: &Mint<M>) -> bool {\n                    self.val == other.val\n                }\n            }\n            impl<M: Module> fmt::Display for Mint<M> {\n                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                    self.val.fmt(f)\n                }\n            }\n            macro_rules ! impl_signed_mint { ( $ ( $ t : ty ) * ) => ( $ ( impl < M : Module > From <$ t > for Mint < M > { # [ inline ] fn from ( x : $ t ) -> Mint < M > { let t = ( x as i64 ) % ( M :: module ( ) as i64 ) ; if x >= 0 { Mint { val : t as u32 , m : PhantomData } } else { Mint { val : ( M :: module ( ) as i64 + t ) as u32 , m : PhantomData } } } } ) * ) }\n            macro_rules ! impl_unsigned_mint { ( $ ( $ t : ty ) * ) => ( $ ( impl < M : Module > From <$ t > for Mint < M > { # [ inline ] fn from ( x : $ t ) -> Mint < M > { let t = x as u64 % M :: module ( ) as u64 ; Mint :: new ( t as u32 ) } } ) * ) }\n            impl_signed_mint! { i8 i16 i32 i64 isize }\n            impl_unsigned_mint! { u8 u16 u32 u64 usize }\n            impl<T: Into<Mint<M>>, M: Module> ops::AddAssign<T> for Mint<M> {\n                fn add_assign(&mut self, other: T) {\n                    *self = *self + other.into();\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::SubAssign<T> for Mint<M> {\n                fn sub_assign(&mut self, other: T) {\n                    *self = *self - other.into();\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::MulAssign<T> for Mint<M> {\n                fn mul_assign(&mut self, other: T) {\n                    *self = *self * other.into();\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::DivAssign<T> for Mint<M> {\n                fn div_assign(&mut self, other: T) {\n                    *self = *self / other.into();\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let a: Mint<Mod107> = Mint::from(3);\n                    let b: Mint<Mod107> = Mint::from(1000000000);\n                    assert_eq!(Mint::from(3000000000u64 % Mod107::module() as u64), a * b);\n                }\n            }\n        }\n        pub use self::comb::Comb;\n        pub use self::mint::{Mint, Module};\n        pub use self::mint::{Mint107, Mint109, Mint998};\n        pub use self::mint::{Mod107, Mod109, Mod998};\n        pub use self::mint::{MOD_107, MOD_109, MOD_998};\n    }\n    pub mod util {\n        mod permutation {\n            #[doc = \" It contains same methods as `std::next_permutaion` in C++.\"]\n            #[doc = \" these methods should rearrange the elements into the next/prev lexicographically greater permutation.\"]\n            #[doc = \"\"]\n            #[doc = \" This is implemented in [T] where T is Ord.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::util::Permutation;\"]\n            #[doc = \"\"]\n            #[doc = \" let mut perm = [5, 0, 9, 2];\"]\n            #[doc = \" assert!(perm.next_permutation());\"]\n            #[doc = \" assert_eq!(perm, [5, 2, 0, 9]);\"]\n            #[doc = \" assert!(perm.next_permutation());\"]\n            #[doc = \" assert_eq!(perm, [5, 2, 9, 0]);\"]\n            #[doc = \" assert!(perm.prev_permutation());\"]\n            #[doc = \" assert_eq!(perm, [5, 2, 0, 9]);\"]\n            #[doc = \"\"]\n            #[doc = \" let mut perm = [4, 3, 2, 1, 0];\"]\n            #[doc = \" assert!(!perm.next_permutation());\"]\n            #[doc = \" assert_eq!(perm, [4, 3, 2, 1, 0]);\"]\n            #[doc = \" ```\"]\n            pub trait Permutation {\n                #[doc = \" It rearranges the elements into the next lexicographically greater permutation.\"]\n                #[doc = \"\"]\n                #[doc = \" Returns `false` without modifying any state only if current is the last permutation.\"]\n                fn next_permutation(&mut self) -> bool;\n                #[doc = \" It rearranges the elements into the previous lexicographically greater permutation.\"]\n                #[doc = \"\"]\n                #[doc = \" Returns `false` without modifying any state only if current is the first permutation.\"]\n                fn prev_permutation(&mut self) -> bool;\n            }\n            impl<T> Permutation for [T]\n            where\n                T: Ord,\n            {\n                fn next_permutation(&mut self) -> bool {\n                    if self.len() <= 1 {\n                        return false;\n                    }\n                    let mut i = self.len() - 1;\n                    while i > 0 && self[i - 1] >= self[i] {\n                        i -= 1;\n                    }\n                    if i == 0 {\n                        return false;\n                    }\n                    let mut j = self.len() - 1;\n                    while self[j] <= self[i - 1] {\n                        j -= 1;\n                    }\n                    self.swap(j, i - 1);\n                    self[i..].reverse();\n                    true\n                }\n                fn prev_permutation(&mut self) -> bool {\n                    if self.len() <= 1 {\n                        return false;\n                    }\n                    let mut i = self.len() - 1;\n                    while i > 0 && self[i - 1] <= self[i] {\n                        i -= 1;\n                    }\n                    if i == 0 {\n                        return false;\n                    }\n                    self[i..].reverse();\n                    let mut j = self.len() - 1;\n                    while self[j - 1] < self[i - 1] {\n                        j -= 1;\n                    }\n                    self.swap(i - 1, j);\n                    true\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let mut data = [0, 0, 1, 1, 2];\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 2, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 0, 2, 1, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 1, 2]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 2, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 1, 0, 2]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 2, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 1, 2]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 2, 1, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 2, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 1, 2]);\n                    assert!(!data.prev_permutation());\n                }\n            }\n        }\n        mod random {\n            use std::num::Wrapping;\n            #[doc = \" Not secure but fast random generator.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::util::XorShift;\"]\n            #[doc = \" let mut xorshift = XorShift::new();\"]\n            #[doc = \" assert_eq!(3701687786, xorshift.next_u32());\"]\n            #[doc = \" assert_eq!(458299110, xorshift.next_u32());\"]\n            #[doc = \" ```\"]\n            #[derive(Clone, Debug, Default)]\n            pub struct XorShift {\n                x: Wrapping<u32>,\n                y: Wrapping<u32>,\n                z: Wrapping<u32>,\n                w: Wrapping<u32>,\n            }\n            impl XorShift {\n                #[doc = \" Create object with default seed.\"]\n                pub fn new() -> XorShift {\n                    XorShift {\n                        x: Wrapping(123_456_789),\n                        y: Wrapping(362_436_069),\n                        z: Wrapping(521_288_629),\n                        w: Wrapping(88_675_123),\n                    }\n                }\n                #[doc = \" Get next random u32 number.\"]\n                pub fn next_u32(&mut self) -> u32 {\n                    let x = self.x;\n                    let t = x ^ (x << 11);\n                    self.x = self.y;\n                    self.y = self.z;\n                    self.z = self.w;\n                    let v = self.w;\n                    self.w = v ^ (v >> 19) ^ (t ^ (t >> 8));\n                    self.w.0\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::XorShift;\n                #[test]\n                fn test_basic() {\n                    let mut xorshift = XorShift::new();\n                    assert_eq!(3701687786, xorshift.next_u32());\n                    assert_eq!(458299110, xorshift.next_u32());\n                }\n            }\n        }\n        pub use self::permutation::Permutation;\n        pub use self::random::XorShift;\n    }\n}\n\n//}}}\n"
  },
  {
    "language": "Rust",
    "code": "pub trait Zero: PartialEq + Sized {\n    fn zero() -> Self;\n    #[inline]\n    fn is_zero(&self) -> bool {\n        self == &Self::zero()\n    }\n}\npub trait One: PartialEq + Sized {\n    fn one() -> Self;\n    #[inline]\n    fn is_one(&self) -> bool {\n        self == &Self::one()\n    }\n}\nmacro_rules !zero_one_impls {($({$Trait :ident $method :ident $($t :ty ) *,$e :expr } ) *) =>{$($(impl $Trait for $t {#[inline ] fn $method () ->Self {$e } } ) *) *} ;}\nzero_one_impls !({Zero zero u8 u16 u32 u64 usize i8 i16 i32 i64 isize u128 i128 ,0 } {Zero zero f32 f64 ,0. } {One one u8 u16 u32 u64 usize i8 i16 i32 i64 isize u128 i128 ,1 } {One one f32 f64 ,1. } ) ;\npub trait IterScan: Sized {\n    type Output;\n    fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output>;\n}\npub trait MarkedIterScan: Sized {\n    type Output;\n    fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output>;\n}\n#[derive(Clone, Debug)]\npub struct Scanner<'a> {\n    iter: std::str::SplitAsciiWhitespace<'a>,\n}\nmod scanner_impls {\n    use super::*;\n    impl<'a> Scanner<'a> {\n        #[inline]\n        pub fn new(s: &'a str) -> Self {\n            let iter = s.split_ascii_whitespace();\n            Self { iter }\n        }\n        #[inline]\n        pub fn scan<T: IterScan>(&mut self) -> <T as IterScan>::Output {\n            <T as IterScan>::scan(&mut self.iter).expect(\"scan error\")\n        }\n        #[inline]\n        pub fn mscan<T: MarkedIterScan>(&mut self, marker: T) -> <T as MarkedIterScan>::Output {\n            marker.mscan(&mut self.iter).expect(\"scan error\")\n        }\n        #[inline]\n        pub fn scan_vec<T: IterScan>(&mut self, size: usize) -> Vec<<T as IterScan>::Output> {\n            (0..size)\n                .map(|_| <T as IterScan>::scan(&mut self.iter).expect(\"scan error\"))\n                .collect()\n        }\n        #[inline]\n        pub fn iter<'b, T: IterScan>(&'b mut self) -> ScannerIter<'a, 'b, T> {\n            ScannerIter {\n                inner: self,\n                _marker: std::marker::PhantomData,\n            }\n        }\n    }\n    macro_rules !iter_scan_impls {($($t :ty ) *) =>{$(impl IterScan for $t {type Output =Self ;#[inline ] fn scan <'a ,I :Iterator <Item =&'a str >>(iter :&mut I ) ->Option <Self >{iter .next () ?.parse ::<$t >() .ok () } } ) *} ;}\n    iter_scan_impls !(char u8 u16 u32 u64 usize i8 i16 i32 i64 isize f32 f64 u128 i128 String ) ;\n    macro_rules !iter_scan_tuple_impl {($($T :ident ) *) =>{impl <$($T :IterScan ) ,*>IterScan for ($($T ,) *) {type Output =($(<$T as IterScan >::Output ,) *) ;#[inline ] fn scan <'a ,It :Iterator <Item =&'a str >>(_iter :&mut It ) ->Option <Self ::Output >{Some (($(<$T as IterScan >::scan (_iter ) ?,) *) ) } } } ;}\n    iter_scan_tuple_impl!();\n    iter_scan_tuple_impl!(A);\n    iter_scan_tuple_impl !(A B ) ;\n    iter_scan_tuple_impl !(A B C ) ;\n    iter_scan_tuple_impl !(A B C D ) ;\n    iter_scan_tuple_impl !(A B C D E ) ;\n    iter_scan_tuple_impl !(A B C D E F ) ;\n    iter_scan_tuple_impl !(A B C D E F G ) ;\n    iter_scan_tuple_impl !(A B C D E F G H ) ;\n    iter_scan_tuple_impl !(A B C D E F G H I ) ;\n    iter_scan_tuple_impl !(A B C D E F G H I J ) ;\n    iter_scan_tuple_impl !(A B C D E F G H I J K ) ;\n    pub struct ScannerIter<'a, 'b, T> {\n        inner: &'b mut Scanner<'a>,\n        _marker: std::marker::PhantomData<fn() -> T>,\n    }\n    impl<'a, 'b, T: IterScan> Iterator for ScannerIter<'a, 'b, T> {\n        type Item = <T as IterScan>::Output;\n        #[inline]\n        fn next(&mut self) -> Option<Self::Item> {\n            <T as IterScan>::scan(&mut self.inner.iter)\n        }\n    }\n}\npub mod marker {\n    use super::*;\n    use std::{iter::FromIterator, marker::PhantomData};\n    #[derive(Debug, Copy, Clone)]\n    pub struct Usize1;\n    impl IterScan for Usize1 {\n        type Output = usize;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            Some(<usize as IterScan>::scan(iter)?.checked_sub(1)?)\n        }\n    }\n    #[derive(Debug, Copy, Clone)]\n    pub struct Chars;\n    impl IterScan for Chars {\n        type Output = Vec<char>;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            Some(iter.next()?.chars().collect())\n        }\n    }\n    #[derive(Debug, Copy, Clone)]\n    pub struct CharsWithBase(char);\n    impl MarkedIterScan for CharsWithBase {\n        type Output = Vec<usize>;\n        #[inline]\n        fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output> {\n            Some(\n                iter.next()?\n                    .chars()\n                    .map(|c| (c as u8 - self.0 as u8) as usize)\n                    .collect(),\n            )\n        }\n    }\n    #[derive(Debug, Copy, Clone)]\n    pub struct Collect<T: IterScan, B: FromIterator<<T as IterScan>::Output>> {\n        size: usize,\n        _marker: PhantomData<fn() -> (T, B)>,\n    }\n    impl<T: IterScan, B: FromIterator<<T as IterScan>::Output>> Collect<T, B> {\n        pub fn new(size: usize) -> Self {\n            Self {\n                size,\n                _marker: PhantomData,\n            }\n        }\n    }\n    impl<T: IterScan, B: FromIterator<<T as IterScan>::Output>> MarkedIterScan for Collect<T, B> {\n        type Output = B;\n        #[inline]\n        fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output> {\n            Some(\n                (0..self.size)\n                    .map(|_| <T as IterScan>::scan(iter).expect(\"scan error\"))\n                    .collect::<B>(),\n            )\n        }\n    }\n}\n#[macro_export]\nmacro_rules !min {($e :expr ) =>{$e } ;($e :expr ,$($es :expr ) ,+) =>{std ::cmp ::min ($e ,min !($($es ) ,+) ) } ;}\n#[macro_export]\nmacro_rules !chmin {($dst :expr ,$($src :expr ) ,+) =>{{let x =std ::cmp ::min ($dst ,min !($($src ) ,+) ) ;$dst =x ;} } ;}\n#[macro_export]\nmacro_rules !max {($e :expr ) =>{$e } ;($e :expr ,$($es :expr ) ,+) =>{std ::cmp ::max ($e ,max !($($es ) ,+) ) } ;}\n#[macro_export]\nmacro_rules !chmax {($dst :expr ,$($src :expr ) ,+) =>{{let x =std ::cmp ::max ($dst ,max !($($src ) ,+) ) ;$dst =x ;} } ;}\npub trait Modulus {\n    fn get_modulus() -> u32;\n    #[inline]\n    fn modulo(x: u32) -> u32 {\n        x % Self::get_modulus()\n    }\n}\n#[allow(unused_macros)]\nmacro_rules! make_modulus {\n    ($t :ident ,$e :expr ) => {\n        pub struct $t {}\n        impl Modulus for $t {\n            #[inline]\n            fn get_modulus() -> u32 {\n                const MODULUS: u32 = $e;\n                MODULUS\n            }\n        }\n    };\n}\n#[allow(unused_macros)]\nmacro_rules! make_dynamic_modulus {\n    ($t :ident ,$m :ident ,$e :expr ) => {\n        pub struct $t {}\n        static mut $m: u32 = $e;\n        impl Modulus for $t {\n            #[inline]\n            fn get_modulus() -> u32 {\n                unsafe { $m }\n            }\n        }\n    };\n}\npub mod modulus {\n    use super::*;\n    pub struct Modulo1000000007 {}\n    impl Modulus for Modulo1000000007 {\n        #[inline]\n        fn get_modulus() -> u32 {\n            const MODULUS: u32 = 1_000_000_007;\n            MODULUS\n        }\n    }\n    pub struct Modulo1000000009 {}\n    impl Modulus for Modulo1000000009 {\n        #[inline]\n        fn get_modulus() -> u32 {\n            const MODULUS: u32 = 1_000_000_009;\n            MODULUS\n        }\n    }\n    pub struct Modulo998244353 {}\n    impl Modulus for Modulo998244353 {\n        #[inline]\n        fn get_modulus() -> u32 {\n            const MODULUS: u32 = 998_244_353;\n            MODULUS\n        }\n    }\n    pub struct DynModulo {}\n    static mut DYN_MODULUS: u32 = 1_000_000_007;\n    impl Modulus for DynModulo {\n        #[inline]\n        fn get_modulus() -> u32 {\n            unsafe { DYN_MODULUS }\n        }\n    }\n    pub fn set_dyn_modulus(m: u32) {\n        unsafe {\n            DYN_MODULUS = m;\n        }\n    }\n}\npub struct MInt<M>\nwhere\n    M: Modulus,\n{\n    x: u32,\n    _marker: std::marker::PhantomData<fn() -> M>,\n}\nmod mint_impls {\n    use super::*;\n    use std::{\n        cmp::Ordering,\n        fmt::{self, Debug},\n        hash::{Hash, Hasher},\n        iter::{Product, Sum},\n        marker::PhantomData,\n        mem::swap,\n        num::ParseIntError,\n        ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign},\n        str::FromStr,\n    };\n    impl<M: Modulus> MInt<M> {\n        #[inline]\n        pub fn new(x: u32) -> Self {\n            Self {\n                x: M::modulo(x),\n                _marker: PhantomData,\n            }\n        }\n        #[inline]\n        pub fn new_unchecked(x: u32) -> Self {\n            Self {\n                x,\n                _marker: PhantomData,\n            }\n        }\n        #[inline]\n        pub fn inner(self) -> u32 {\n            self.x\n        }\n        #[inline]\n        pub fn get_mod() -> u32 {\n            M::get_modulus()\n        }\n        #[inline]\n        pub fn pow(mut self, mut y: usize) -> Self {\n            let mut x = Self::one();\n            while y > 0 {\n                if y & 1 == 1 {\n                    x *= self;\n                }\n                self *= self;\n                y >>= 1;\n            }\n            x\n        }\n        #[inline]\n        /// only prime modulus\n        pub fn inv(self) -> Self {\n            let mut a = self.x;\n            let (mut b, mut u, mut s) = (M::get_modulus(), 1, 0);\n            let k = a.trailing_zeros();\n            a >>= k;\n            for _ in 0..k {\n                if u & 1 == 1 {\n                    u += M::get_modulus();\n                }\n                u /= 2;\n            }\n            while a != b {\n                if b < a {\n                    swap(&mut a, &mut b);\n                    swap(&mut u, &mut s);\n                }\n                b -= a;\n                if s < u {\n                    s += M::get_modulus();\n                }\n                s -= u;\n                let k = b.trailing_zeros();\n                b >>= k;\n                for _ in 0..k {\n                    if s & 1 == 1 {\n                        s += M::get_modulus();\n                    }\n                    s /= 2;\n                }\n            }\n            Self::new_unchecked(s)\n        }\n    }\n    impl<M: Modulus> Clone for MInt<M> {\n        #[inline]\n        fn clone(&self) -> Self {\n            Self {\n                x: Clone::clone(&self.x),\n                _marker: PhantomData,\n            }\n        }\n    }\n    impl<M: Modulus> Copy for MInt<M> {}\n    impl<M: Modulus> Debug for MInt<M> {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            Debug::fmt(&self.x, f)\n        }\n    }\n    impl<M: Modulus> Default for MInt<M> {\n        #[inline]\n        fn default() -> Self {\n            Self::zero()\n        }\n    }\n    impl<M: Modulus> PartialEq for MInt<M> {\n        #[inline]\n        fn eq(&self, other: &Self) -> bool {\n            PartialEq::eq(&self.x, &other.x)\n        }\n    }\n    impl<M: Modulus> PartialOrd for MInt<M> {\n        #[inline]\n        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n            PartialOrd::partial_cmp(&self.x, &other.x)\n        }\n    }\n    impl<M: Modulus> Eq for MInt<M> {}\n    impl<M: Modulus> Ord for MInt<M> {\n        #[inline]\n        fn cmp(&self, other: &Self) -> Ordering {\n            Ord::cmp(&self.x, &other.x)\n        }\n    }\n    impl<M: Modulus> Hash for MInt<M> {\n        #[inline]\n        fn hash<H: Hasher>(&self, state: &mut H) {\n            Hash::hash(&self.x, state)\n        }\n    }\n    impl<M: Modulus> From<u32> for MInt<M> {\n        #[inline]\n        fn from(x: u32) -> Self {\n            Self::new(x)\n        }\n    }\n    impl<M: Modulus> From<u64> for MInt<M> {\n        #[inline]\n        fn from(x: u64) -> Self {\n            Self::new_unchecked((x % M::get_modulus() as u64) as u32)\n        }\n    }\n    impl<M: Modulus> From<usize> for MInt<M> {\n        #[inline]\n        fn from(x: usize) -> Self {\n            Self::new_unchecked((x % M::get_modulus() as usize) as u32)\n        }\n    }\n    impl<M: Modulus> From<i32> for MInt<M> {\n        #[inline]\n        fn from(x: i32) -> Self {\n            let x = x % M::get_modulus() as i32;\n            if x < 0 {\n                Self::new_unchecked((x + M::get_modulus() as i32) as u32)\n            } else {\n                Self::new_unchecked(x as u32)\n            }\n        }\n    }\n    impl<M: Modulus> From<i64> for MInt<M> {\n        #[inline]\n        fn from(x: i64) -> Self {\n            let x = x % M::get_modulus() as i64;\n            if x < 0 {\n                Self::new_unchecked((x + M::get_modulus() as i64) as u32)\n            } else {\n                Self::new_unchecked(x as u32)\n            }\n        }\n    }\n    impl<M: Modulus> From<isize> for MInt<M> {\n        #[inline]\n        fn from(x: isize) -> Self {\n            let x = x % M::get_modulus() as isize;\n            if x < 0 {\n                Self::new_unchecked((x + M::get_modulus() as isize) as u32)\n            } else {\n                Self::new_unchecked(x as u32)\n            }\n        }\n    }\n    impl<M: Modulus> Add for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn add(self, rhs: Self) -> Self::Output {\n            let mut x = self.x + rhs.x;\n            if x >= M::get_modulus() {\n                x -= M::get_modulus();\n            }\n            Self::new_unchecked(x)\n        }\n    }\n    impl<M: Modulus> Sub for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn sub(self, rhs: Self) -> Self::Output {\n            if self.x < rhs.x {\n                Self::new_unchecked(self.x + M::get_modulus() - rhs.x)\n            } else {\n                Self::new_unchecked(self.x - rhs.x)\n            }\n        }\n    }\n    impl<M: Modulus> Mul for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn mul(self, rhs: Self) -> Self::Output {\n            Self::new_unchecked((self.x as u64 * rhs.x as u64 % M::get_modulus() as u64) as u32)\n        }\n    }\n    impl<M: Modulus> Div for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn div(self, rhs: Self) -> Self::Output {\n            self * rhs.inv()\n        }\n    }\n    impl<M: Modulus> Neg for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn neg(self) -> Self::Output {\n            if self.x == 0 {\n                Self::zero()\n            } else {\n                Self::new_unchecked(M::get_modulus() - self.x)\n            }\n        }\n    }\n    impl<M: Modulus> Sum for MInt<M> {\n        #[inline]\n        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Self::zero(), Add::add)\n        }\n    }\n    impl<M: Modulus> Product for MInt<M> {\n        #[inline]\n        fn product<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Self::one(), Mul::mul)\n        }\n    }\n    impl<'a, M: Modulus + 'a> Sum<&'a MInt<M>> for MInt<M> {\n        #[inline]\n        fn sum<I: Iterator<Item = &'a Self>>(iter: I) -> Self {\n            iter.fold(Self::zero(), Add::add)\n        }\n    }\n    impl<'a, M: Modulus + 'a> Product<&'a MInt<M>> for MInt<M> {\n        #[inline]\n        fn product<I: Iterator<Item = &'a Self>>(iter: I) -> Self {\n            iter.fold(Self::one(), Mul::mul)\n        }\n    }\n    impl<M: Modulus> fmt::Display for MInt<M> {\n        fn fmt<'a>(&self, f: &mut fmt::Formatter<'a>) -> Result<(), fmt::Error> {\n            write!(f, \"{}\", self.x)\n        }\n    }\n    impl<M: Modulus> FromStr for MInt<M> {\n        type Err = ParseIntError;\n        #[inline]\n        fn from_str(s: &str) -> Result<Self, Self::Err> {\n            s.parse::<u32>().map(Self::new)\n        }\n    }\n    impl<M: Modulus> IterScan for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            iter.next()?.parse::<MInt<M>>().ok()\n        }\n    }\n    impl<M: Modulus> Zero for MInt<M> {\n        #[inline]\n        fn zero() -> Self {\n            Self::new_unchecked(0)\n        }\n    }\n    impl<M: Modulus> One for MInt<M> {\n        #[inline]\n        fn one() -> Self {\n            Self::new_unchecked(1)\n        }\n    }\n    macro_rules! mint_ref_binop {\n        ($imp :ident ,$method :ident ,$t :ty ) => {\n            impl<M: Modulus> $imp<$t> for &$t {\n                type Output = <$t as $imp<$t>>::Output;\n                #[inline]\n                fn $method(self, other: $t) -> <$t as $imp<$t>>::Output {\n                    $imp::$method(*self, other)\n                }\n            }\n            impl<M: Modulus> $imp<&$t> for $t {\n                type Output = <$t as $imp<$t>>::Output;\n                #[inline]\n                fn $method(self, other: &$t) -> <$t as $imp<$t>>::Output {\n                    $imp::$method(self, *other)\n                }\n            }\n            impl<M: Modulus> $imp<&$t> for &$t {\n                type Output = <$t as $imp<$t>>::Output;\n                #[inline]\n                fn $method(self, other: &$t) -> <$t as $imp<$t>>::Output {\n                    $imp::$method(*self, *other)\n                }\n            }\n        };\n    }\n    mint_ref_binop!(Add, add, MInt<M>);\n    mint_ref_binop!(Sub, sub, MInt<M>);\n    mint_ref_binop!(Mul, mul, MInt<M>);\n    mint_ref_binop!(Div, div, MInt<M>);\n    macro_rules! mint_ref_unop {\n        ($imp :ident ,$method :ident ,$t :ty ) => {\n            impl<M: Modulus> $imp for &$t {\n                type Output = <$t as $imp>::Output;\n                #[inline]\n                fn $method(self) -> <$t as $imp>::Output {\n                    $imp::$method(*self)\n                }\n            }\n        };\n    }\n    mint_ref_unop!(Neg, neg, MInt<M>);\n    macro_rules! mint_ref_op_assign {\n        ($imp :ident ,$method :ident ,$t :ty ,$fromimp :ident ,$frommethod :ident ) => {\n            impl<M: Modulus> $imp<$t> for $t {\n                #[inline]\n                fn $method(&mut self, rhs: $t) {\n                    *self = $fromimp::$frommethod(*self, rhs);\n                }\n            }\n            impl<M: Modulus> $imp<&$t> for $t {\n                #[inline]\n                fn $method(&mut self, other: &$t) {\n                    $imp::$method(self, *other);\n                }\n            }\n        };\n    }\n    mint_ref_op_assign!(AddAssign, add_assign, MInt<M>, Add, add);\n    mint_ref_op_assign!(SubAssign, sub_assign, MInt<M>, Sub, sub);\n    mint_ref_op_assign!(MulAssign, mul_assign, MInt<M>, Mul, mul);\n    mint_ref_op_assign!(DivAssign, div_assign, MInt<M>, Div, div);\n}\n#[derive(Clone, Debug)]\npub struct MemorizedFactorial<M: Modulus> {\n    pub fact: Vec<MInt<M>>,\n    pub inv_fact: Vec<MInt<M>>,\n}\nimpl<M: Modulus> MemorizedFactorial<M> {\n    pub fn new(max_n: usize) -> Self {\n        let mut fact = vec![MInt::one(); max_n + 1];\n        let mut inv_fact = vec![MInt::one(); max_n + 1];\n        for i in 2..=max_n {\n            fact[i] = fact[i - 1] * MInt::new(i as u32);\n        }\n        inv_fact[max_n] = fact[max_n].inv();\n        for i in (3..=max_n).rev() {\n            inv_fact[i - 1] = inv_fact[i] * MInt::new(i as u32);\n        }\n        Self { fact, inv_fact }\n    }\n    #[inline]\n    pub fn combination(&self, n: usize, r: usize) -> MInt<M> {\n        debug_assert!(n < self.fact.len());\n        if r <= n {\n            self.fact[n] * self.inv_fact[r] * self.inv_fact[n - r]\n        } else {\n            MInt::zero()\n        }\n    }\n    #[inline]\n    pub fn permutation(&self, n: usize, r: usize) -> MInt<M> {\n        debug_assert!(n < self.fact.len());\n        if r <= n {\n            self.fact[n] * self.inv_fact[n - r]\n        } else {\n            MInt::zero()\n        }\n    }\n    #[inline]\n    pub fn homogeneous_product(&self, n: usize, r: usize) -> MInt<M> {\n        debug_assert!(n + r < self.fact.len() + 1);\n        if n != 0 && r != 0 {\n            self.combination(n + r - 1, r)\n        } else {\n            MInt::one()\n        }\n    }\n    #[inline]\n    pub fn inv(&self, n: usize) -> MInt<M> {\n        debug_assert!(n < self.fact.len());\n        debug_assert!(n > 0);\n        self.inv_fact[n] * self.fact[n - 1]\n    }\n}\ntype M = MInt<modulus::Modulo998244353>;\nfn main() {\n    #![allow(unused_imports, unused_macros)]\n    use std::io::{stdin, stdout, BufWriter, Read as _, Write as _};\n    let mut __in_buf = Vec::new();\n    stdin().read_to_end(&mut __in_buf).expect(\"io error\");\n    let __in_buf = unsafe { String::from_utf8_unchecked(__in_buf) };\n    let mut scanner = Scanner::new(&__in_buf);\n    macro_rules !scan {() =>{scan !(usize ) } ;(($($t :tt ) ,*) ) =>{($(scan !($t ) ) ,*) } ;([$t :ty ;$len :expr ] ) =>{scanner .scan_vec ::<$t >($len ) } ;([$t :tt ;$len :expr ] ) =>{(0 ..$len ) .map (|_ |scan !($t ) ) .collect ::<Vec <_ >>() } ;({$e :expr } ) =>{scanner .mscan ($e ) } ;($t :ty ) =>{scanner .scan ::<$t >() } ;}\n    let __out = stdout();\n    let mut __out = BufWriter::new(__out.lock());\n    macro_rules !print {($($arg :tt ) *) =>(::std ::write !(__out ,$($arg ) *) .expect (\"io error\" ) ) }\n    macro_rules !println {($($arg :tt ) *) =>(::std ::writeln !(__out ,$($arg ) *) .expect (\"io error\" ) ) }\n    macro_rules! echo {\n        ($iter :expr ) => {\n            echo!($iter, '\\n')\n        };\n        ($iter :expr ,$sep :expr ) => {\n            let mut iter = $iter.into_iter();\n            if let Some(item) = iter.next() {\n                print!(\"{}\", item);\n            }\n            for item in iter {\n                print!(\"{}{}\", $sep, item);\n            }\n            println!();\n        };\n    }\n    let n = scan!();\n    let m = scan!();\n    let f = MemorizedFactorial::new(m * 3 / 2 + n);\n    let mut ans = M::zero();\n    for o in (m % 2..=m).step_by(2) {\n        ans += f.combination(n, o) * f.combination((3 * m - o) / 2 + n - 1, n - 1);\n        ans -= f.combination(n, o) * f.combination((m - o) / 2 + n - 1, n - 1) * M::from(n);\n        ans += f.combination(n - 1, o) * f.combination((m - o) / 2 + n - 2, n - 2) * M::from(n);\n    }\n    println!(\"{}\", ans);\n}"
  },
  {
    "language": "Rust",
    "code": "pub trait Zero: PartialEq + Sized {\n    fn zero() -> Self;\n    #[inline]\n    fn is_zero(&self) -> bool {\n        self == &Self::zero()\n    }\n}\npub trait One: PartialEq + Sized {\n    fn one() -> Self;\n    #[inline]\n    fn is_one(&self) -> bool {\n        self == &Self::one()\n    }\n}\nmacro_rules !zero_one_impls {($({$Trait :ident $method :ident $($t :ty ) *,$e :expr } ) *) =>{$($(impl $Trait for $t {#[inline ] fn $method () ->Self {$e } } ) *) *} ;}\nzero_one_impls !({Zero zero u8 u16 u32 u64 usize i8 i16 i32 i64 isize u128 i128 ,0 } {Zero zero f32 f64 ,0. } {One one u8 u16 u32 u64 usize i8 i16 i32 i64 isize u128 i128 ,1 } {One one f32 f64 ,1. } );\npub trait IterScan: Sized {\n    type Output;\n    fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output>;\n}\npub trait MarkedIterScan: Sized {\n    type Output;\n    fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output>;\n}\n#[derive(Clone, Debug)]\npub struct Scanner<'a> {\n    iter: std::str::SplitAsciiWhitespace<'a>,\n}\nmod scanner_impls {\n    use super::*;\n    impl<'a> Scanner<'a> {\n        #[inline]\n        pub fn new(s: &'a str) -> Self {\n            let iter = s.split_ascii_whitespace();\n            Self { iter }\n        }\n        #[inline]\n        pub fn scan<T: IterScan>(&mut self) -> <T as IterScan>::Output {\n            <T as IterScan>::scan(&mut self.iter).expect(\"scan error\")\n        }\n        #[inline]\n        pub fn mscan<T: MarkedIterScan>(&mut self, marker: T) -> <T as MarkedIterScan>::Output {\n            marker.mscan(&mut self.iter).expect(\"scan error\")\n        }\n        #[inline]\n        pub fn scan_vec<T: IterScan>(&mut self, size: usize) -> Vec<<T as IterScan>::Output> {\n            (0..size)\n                .map(|_| <T as IterScan>::scan(&mut self.iter).expect(\"scan error\"))\n                .collect()\n        }\n        #[inline]\n        pub fn iter<'b, T: IterScan>(&'b mut self) -> ScannerIter<'a, 'b, T> {\n            ScannerIter {\n                inner: self,\n                _marker: std::marker::PhantomData,\n            }\n        }\n    }\n    macro_rules !iter_scan_impls {($($t :ty ) *) =>{$(impl IterScan for $t {type Output =Self ;#[inline ] fn scan <'a ,I :Iterator <Item =&'a str >>(iter :&mut I ) ->Option <Self >{iter .next () ?.parse ::<$t >() .ok () } } ) *} ;}\n    iter_scan_impls !(char u8 u16 u32 u64 usize i8 i16 i32 i64 isize f32 f64 u128 i128 String );\n    macro_rules !iter_scan_tuple_impl {($($T :ident ) *) =>{impl <$($T :IterScan ) ,*>IterScan for ($($T ,) *) {type Output =($(<$T as IterScan >::Output ,) *) ;#[inline ] fn scan <'a ,It :Iterator <Item =&'a str >>(_iter :&mut It ) ->Option <Self ::Output >{Some (($(<$T as IterScan >::scan (_iter ) ?,) *) ) } } } ;}\n    iter_scan_tuple_impl!();\n    iter_scan_tuple_impl!(A);\n    iter_scan_tuple_impl !(A B );\n    iter_scan_tuple_impl !(A B C );\n    iter_scan_tuple_impl !(A B C D );\n    iter_scan_tuple_impl !(A B C D E );\n    iter_scan_tuple_impl !(A B C D E F );\n    iter_scan_tuple_impl !(A B C D E F G );\n    iter_scan_tuple_impl !(A B C D E F G H );\n    iter_scan_tuple_impl !(A B C D E F G H I );\n    iter_scan_tuple_impl !(A B C D E F G H I J );\n    iter_scan_tuple_impl !(A B C D E F G H I J K );\n    pub struct ScannerIter<'a, 'b, T> {\n        inner: &'b mut Scanner<'a>,\n        _marker: std::marker::PhantomData<fn() -> T>,\n    }\n    impl<'a, 'b, T: IterScan> Iterator for ScannerIter<'a, 'b, T> {\n        type Item = <T as IterScan>::Output;\n        #[inline]\n        fn next(&mut self) -> Option<Self::Item> {\n            <T as IterScan>::scan(&mut self.inner.iter)\n        }\n    }\n}\npub mod marker {\n    use super::*;\n    use std::{iter::FromIterator, marker::PhantomData};\n    #[derive(Debug, Copy, Clone)]\n    pub struct Usize1;\n    impl IterScan for Usize1 {\n        type Output = usize;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            Some(<usize as IterScan>::scan(iter)?.checked_sub(1)?)\n        }\n    }\n    #[derive(Debug, Copy, Clone)]\n    pub struct Chars;\n    impl IterScan for Chars {\n        type Output = Vec<char>;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            Some(iter.next()?.chars().collect())\n        }\n    }\n    #[derive(Debug, Copy, Clone)]\n    pub struct CharsWithBase(pub char);\n    impl MarkedIterScan for CharsWithBase {\n        type Output = Vec<usize>;\n        #[inline]\n        fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output> {\n            Some(\n                iter.next()?\n                    .chars()\n                    .map(|c| (c as u8 - self.0 as u8) as usize)\n                    .collect(),\n            )\n        }\n    }\n    #[derive(Debug, Copy, Clone)]\n    pub struct Collect<T: IterScan, B: FromIterator<<T as IterScan>::Output>> {\n        size: usize,\n        _marker: PhantomData<fn() -> (T, B)>,\n    }\n    impl<T: IterScan, B: FromIterator<<T as IterScan>::Output>> Collect<T, B> {\n        pub fn new(size: usize) -> Self {\n            Self {\n                size,\n                _marker: PhantomData,\n            }\n        }\n    }\n    impl<T: IterScan, B: FromIterator<<T as IterScan>::Output>> MarkedIterScan for Collect<T, B> {\n        type Output = B;\n        #[inline]\n        fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output> {\n            Some(\n                (0..self.size)\n                    .map(|_| <T as IterScan>::scan(iter).expect(\"scan error\"))\n                    .collect::<B>(),\n            )\n        }\n    }\n}\n#[macro_export]\nmacro_rules !min {($e :expr ) =>{$e } ;($e :expr ,$($es :expr ) ,+) =>{std ::cmp ::min ($e ,min !($($es ) ,+) ) } ;}\n#[macro_export]\nmacro_rules !chmin {($dst :expr ,$($src :expr ) ,+) =>{{let x =std ::cmp ::min ($dst ,min !($($src ) ,+) ) ;$dst =x ;} } ;}\n#[macro_export]\nmacro_rules !max {($e :expr ) =>{$e } ;($e :expr ,$($es :expr ) ,+) =>{std ::cmp ::max ($e ,max !($($es ) ,+) ) } ;}\n#[macro_export]\nmacro_rules !chmax {($dst :expr ,$($src :expr ) ,+) =>{{let x =std ::cmp ::max ($dst ,max !($($src ) ,+) ) ;$dst =x ;} } ;}\npub trait Modulus {\n    fn get_modulus() -> u32;\n    #[inline]\n    fn modulo(x: u32) -> u32 {\n        x % Self::get_modulus()\n    }\n}\n#[allow(unused_macros)]\nmacro_rules! make_modulus {\n    ($t :ident ,$e :expr ) => {\n        pub struct $t {}\n        impl Modulus for $t {\n            #[inline]\n            fn get_modulus() -> u32 {\n                const MODULUS: u32 = $e;\n                MODULUS\n            }\n        }\n    };\n}\n#[allow(unused_macros)]\nmacro_rules! make_dynamic_modulus {\n    ($t :ident ,$m :ident ,$e :expr ) => {\n        pub struct $t {}\n        static mut $m: u32 = $e;\n        impl Modulus for $t {\n            #[inline]\n            fn get_modulus() -> u32 {\n                unsafe { $m }\n            }\n        }\n    };\n}\npub mod modulus {\n    use super::*;\n    pub struct Modulo1000000007 {}\n    impl Modulus for Modulo1000000007 {\n        #[inline]\n        fn get_modulus() -> u32 {\n            const MODULUS: u32 = 1_000_000_007;\n            MODULUS\n        }\n    }\n    pub type MInt1000000007 = MInt<Modulo1000000007>;\n    pub struct Modulo1000000009 {}\n    impl Modulus for Modulo1000000009 {\n        #[inline]\n        fn get_modulus() -> u32 {\n            const MODULUS: u32 = 1_000_000_009;\n            MODULUS\n        }\n    }\n    pub type MInt1000000009 = MInt<Modulo1000000009>;\n    pub struct Modulo998244353 {}\n    impl Modulus for Modulo998244353 {\n        #[inline]\n        fn get_modulus() -> u32 {\n            const MODULUS: u32 = 998_244_353;\n            MODULUS\n        }\n    }\n    pub type MInt998244353 = MInt<Modulo998244353>;\n    pub struct DynModulo {}\n    static mut DYN_MODULUS: u32 = 1_000_000_007;\n    impl Modulus for DynModulo {\n        #[inline]\n        fn get_modulus() -> u32 {\n            unsafe { DYN_MODULUS }\n        }\n    }\n    pub fn set_dyn_modulus(m: u32) {\n        unsafe {\n            DYN_MODULUS = m;\n        }\n    }\n    pub type DynMInt = MInt<DynModulo>;\n}\n#[repr(transparent)]\npub struct MInt<M>\nwhere\n    M: Modulus,\n{\n    x: u32,\n    _marker: std::marker::PhantomData<fn() -> M>,\n}\nmod mint_impls {\n    use super::*;\n    use std::{\n        cmp::Ordering,\n        fmt::{self, Debug},\n        hash::{Hash, Hasher},\n        iter::{Product, Sum},\n        marker::PhantomData,\n        mem::swap,\n        num::ParseIntError,\n        ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign},\n        str::FromStr,\n    };\n    impl<M: Modulus> MInt<M> {\n        #[inline]\n        pub fn new(x: u32) -> Self {\n            Self {\n                x: M::modulo(x),\n                _marker: PhantomData,\n            }\n        }\n        #[inline]\n        pub fn new_unchecked(x: u32) -> Self {\n            Self {\n                x,\n                _marker: PhantomData,\n            }\n        }\n        #[inline]\n        pub fn inner(self) -> u32 {\n            self.x\n        }\n        #[inline]\n        pub fn get_mod() -> u32 {\n            M::get_modulus()\n        }\n        #[inline]\n        pub fn pow(mut self, mut y: usize) -> Self {\n            let mut x = Self::one();\n            while y > 0 {\n                if y & 1 == 1 {\n                    x *= self;\n                }\n                self *= self;\n                y >>= 1;\n            }\n            x\n        }\n        #[inline]\n        /// only prime modulus\n        pub fn inv(self) -> Self {\n            let mut a = self.x;\n            let (mut b, mut u, mut s) = (M::get_modulus(), 1, 0);\n            let k = a.trailing_zeros();\n            a >>= k;\n            for _ in 0..k {\n                if u & 1 == 1 {\n                    u += M::get_modulus();\n                }\n                u /= 2;\n            }\n            while a != b {\n                if b < a {\n                    swap(&mut a, &mut b);\n                    swap(&mut u, &mut s);\n                }\n                b -= a;\n                if s < u {\n                    s += M::get_modulus();\n                }\n                s -= u;\n                let k = b.trailing_zeros();\n                b >>= k;\n                for _ in 0..k {\n                    if s & 1 == 1 {\n                        s += M::get_modulus();\n                    }\n                    s /= 2;\n                }\n            }\n            Self::new_unchecked(s)\n        }\n    }\n    impl<M: Modulus> Clone for MInt<M> {\n        #[inline]\n        fn clone(&self) -> Self {\n            Self {\n                x: Clone::clone(&self.x),\n                _marker: PhantomData,\n            }\n        }\n    }\n    impl<M: Modulus> Copy for MInt<M> {}\n    impl<M: Modulus> Debug for MInt<M> {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            Debug::fmt(&self.x, f)\n        }\n    }\n    impl<M: Modulus> Default for MInt<M> {\n        #[inline]\n        fn default() -> Self {\n            Self::zero()\n        }\n    }\n    impl<M: Modulus> PartialEq for MInt<M> {\n        #[inline]\n        fn eq(&self, other: &Self) -> bool {\n            PartialEq::eq(&self.x, &other.x)\n        }\n    }\n    impl<M: Modulus> PartialOrd for MInt<M> {\n        #[inline]\n        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n            PartialOrd::partial_cmp(&self.x, &other.x)\n        }\n    }\n    impl<M: Modulus> Eq for MInt<M> {}\n    impl<M: Modulus> Ord for MInt<M> {\n        #[inline]\n        fn cmp(&self, other: &Self) -> Ordering {\n            Ord::cmp(&self.x, &other.x)\n        }\n    }\n    impl<M: Modulus> Hash for MInt<M> {\n        #[inline]\n        fn hash<H: Hasher>(&self, state: &mut H) {\n            Hash::hash(&self.x, state)\n        }\n    }\n    impl<M: Modulus> From<u32> for MInt<M> {\n        #[inline]\n        fn from(x: u32) -> Self {\n            Self::new(x)\n        }\n    }\n    impl<M: Modulus> From<u64> for MInt<M> {\n        #[inline]\n        fn from(x: u64) -> Self {\n            Self::new_unchecked((x % M::get_modulus() as u64) as u32)\n        }\n    }\n    impl<M: Modulus> From<usize> for MInt<M> {\n        #[inline]\n        fn from(x: usize) -> Self {\n            Self::new_unchecked((x % M::get_modulus() as usize) as u32)\n        }\n    }\n    impl<M: Modulus> From<i32> for MInt<M> {\n        #[inline]\n        fn from(x: i32) -> Self {\n            let x = x % M::get_modulus() as i32;\n            if x < 0 {\n                Self::new_unchecked((x + M::get_modulus() as i32) as u32)\n            } else {\n                Self::new_unchecked(x as u32)\n            }\n        }\n    }\n    impl<M: Modulus> From<i64> for MInt<M> {\n        #[inline]\n        fn from(x: i64) -> Self {\n            let x = x % M::get_modulus() as i64;\n            if x < 0 {\n                Self::new_unchecked((x + M::get_modulus() as i64) as u32)\n            } else {\n                Self::new_unchecked(x as u32)\n            }\n        }\n    }\n    impl<M: Modulus> From<isize> for MInt<M> {\n        #[inline]\n        fn from(x: isize) -> Self {\n            let x = x % M::get_modulus() as isize;\n            if x < 0 {\n                Self::new_unchecked((x + M::get_modulus() as isize) as u32)\n            } else {\n                Self::new_unchecked(x as u32)\n            }\n        }\n    }\n    impl<M: Modulus> Add for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn add(self, rhs: Self) -> Self::Output {\n            let mut x = self.x + rhs.x;\n            if x >= M::get_modulus() {\n                x -= M::get_modulus();\n            }\n            Self::new_unchecked(x)\n        }\n    }\n    impl<M: Modulus> Sub for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn sub(self, rhs: Self) -> Self::Output {\n            if self.x < rhs.x {\n                Self::new_unchecked(self.x + M::get_modulus() - rhs.x)\n            } else {\n                Self::new_unchecked(self.x - rhs.x)\n            }\n        }\n    }\n    impl<M: Modulus> Mul for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn mul(self, rhs: Self) -> Self::Output {\n            Self::new_unchecked((self.x as u64 * rhs.x as u64 % M::get_modulus() as u64) as u32)\n        }\n    }\n    impl<M: Modulus> Div for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn div(self, rhs: Self) -> Self::Output {\n            self.mul(rhs.inv())\n        }\n    }\n    impl<M: Modulus> Neg for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn neg(self) -> Self::Output {\n            if self.x == 0 {\n                Self::zero()\n            } else {\n                Self::new_unchecked(M::get_modulus() - self.x)\n            }\n        }\n    }\n    impl<M: Modulus> Sum for MInt<M> {\n        #[inline]\n        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Self::zero(), Add::add)\n        }\n    }\n    impl<M: Modulus> Product for MInt<M> {\n        #[inline]\n        fn product<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Self::one(), Mul::mul)\n        }\n    }\n    impl<'a, M: Modulus + 'a> Sum<&'a MInt<M>> for MInt<M> {\n        #[inline]\n        fn sum<I: Iterator<Item = &'a Self>>(iter: I) -> Self {\n            iter.fold(Self::zero(), Add::add)\n        }\n    }\n    impl<'a, M: Modulus + 'a> Product<&'a MInt<M>> for MInt<M> {\n        #[inline]\n        fn product<I: Iterator<Item = &'a Self>>(iter: I) -> Self {\n            iter.fold(Self::one(), Mul::mul)\n        }\n    }\n    impl<M: Modulus> fmt::Display for MInt<M> {\n        fn fmt<'a>(&self, f: &mut fmt::Formatter<'a>) -> Result<(), fmt::Error> {\n            write!(f, \"{}\", self.x)\n        }\n    }\n    impl<M: Modulus> FromStr for MInt<M> {\n        type Err = ParseIntError;\n        #[inline]\n        fn from_str(s: &str) -> Result<Self, Self::Err> {\n            s.parse::<u32>().map(Self::new)\n        }\n    }\n    impl<M: Modulus> IterScan for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            iter.next()?.parse::<MInt<M>>().ok()\n        }\n    }\n    impl<M: Modulus> Zero for MInt<M> {\n        #[inline]\n        fn zero() -> Self {\n            Self::new_unchecked(0)\n        }\n    }\n    impl<M: Modulus> One for MInt<M> {\n        #[inline]\n        fn one() -> Self {\n            Self::new_unchecked(1)\n        }\n    }\n    macro_rules! mint_ref_binop {\n        ($imp :ident ,$method :ident ,$t :ty ) => {\n            impl<M: Modulus> $imp<$t> for &$t {\n                type Output = <$t as $imp<$t>>::Output;\n                #[inline]\n                fn $method(self, other: $t) -> <$t as $imp<$t>>::Output {\n                    $imp::$method(*self, other)\n                }\n            }\n            impl<M: Modulus> $imp<&$t> for $t {\n                type Output = <$t as $imp<$t>>::Output;\n                #[inline]\n                fn $method(self, other: &$t) -> <$t as $imp<$t>>::Output {\n                    $imp::$method(self, *other)\n                }\n            }\n            impl<M: Modulus> $imp<&$t> for &$t {\n                type Output = <$t as $imp<$t>>::Output;\n                #[inline]\n                fn $method(self, other: &$t) -> <$t as $imp<$t>>::Output {\n                    $imp::$method(*self, *other)\n                }\n            }\n        };\n    }\n    mint_ref_binop!(Add, add, MInt<M>);\n    mint_ref_binop!(Sub, sub, MInt<M>);\n    mint_ref_binop!(Mul, mul, MInt<M>);\n    mint_ref_binop!(Div, div, MInt<M>);\n    macro_rules! mint_ref_unop {\n        ($imp :ident ,$method :ident ,$t :ty ) => {\n            impl<M: Modulus> $imp for &$t {\n                type Output = <$t as $imp>::Output;\n                #[inline]\n                fn $method(self) -> <$t as $imp>::Output {\n                    $imp::$method(*self)\n                }\n            }\n        };\n    }\n    mint_ref_unop!(Neg, neg, MInt<M>);\n    macro_rules! mint_ref_op_assign {\n        ($imp :ident ,$method :ident ,$t :ty ,$fromimp :ident ,$frommethod :ident ) => {\n            impl<M: Modulus> $imp<$t> for $t {\n                #[inline]\n                fn $method(&mut self, rhs: $t) {\n                    *self = $fromimp::$frommethod(*self, rhs);\n                }\n            }\n            impl<M: Modulus> $imp<&$t> for $t {\n                #[inline]\n                fn $method(&mut self, other: &$t) {\n                    $imp::$method(self, *other);\n                }\n            }\n        };\n    }\n    mint_ref_op_assign!(AddAssign, add_assign, MInt<M>, Add, add);\n    mint_ref_op_assign!(SubAssign, sub_assign, MInt<M>, Sub, sub);\n    mint_ref_op_assign!(MulAssign, mul_assign, MInt<M>, Mul, mul);\n    mint_ref_op_assign!(DivAssign, div_assign, MInt<M>, Div, div);\n}\ntype M = modulus::MInt998244353;\n#[derive(Clone, Debug)]\npub struct MemorizedFactorial<M: Modulus> {\n    pub fact: Vec<MInt<M>>,\n    pub inv_fact: Vec<MInt<M>>,\n}\nimpl<M: Modulus> MemorizedFactorial<M> {\n    pub fn new(max_n: usize) -> Self {\n        let mut fact = vec![MInt::one(); max_n + 1];\n        let mut inv_fact = vec![MInt::one(); max_n + 1];\n        for i in 2..=max_n {\n            fact[i] = fact[i - 1] * MInt::new(i as u32);\n        }\n        inv_fact[max_n] = fact[max_n].inv();\n        for i in (3..=max_n).rev() {\n            inv_fact[i - 1] = inv_fact[i] * MInt::new(i as u32);\n        }\n        Self { fact, inv_fact }\n    }\n    #[inline]\n    pub fn combination(&self, n: usize, r: usize) -> MInt<M> {\n        debug_assert!(n < self.fact.len());\n        if r <= n {\n            self.fact[n] * self.inv_fact[r] * self.inv_fact[n - r]\n        } else {\n            MInt::zero()\n        }\n    }\n    #[inline]\n    pub fn permutation(&self, n: usize, r: usize) -> MInt<M> {\n        debug_assert!(n < self.fact.len());\n        if r <= n {\n            self.fact[n] * self.inv_fact[n - r]\n        } else {\n            MInt::zero()\n        }\n    }\n    #[inline]\n    pub fn homogeneous_product(&self, n: usize, r: usize) -> MInt<M> {\n        debug_assert!(n + r < self.fact.len() + 1);\n        if n != 0 && r != 0 {\n            self.combination(n + r - 1, r)\n        } else {\n            MInt::one()\n        }\n    }\n    #[inline]\n    pub fn inv(&self, n: usize) -> MInt<M> {\n        debug_assert!(n < self.fact.len());\n        debug_assert!(n > 0);\n        self.inv_fact[n] * self.fact[n - 1]\n    }\n}\nfn main() {\n    #![allow(unused_imports, unused_macros)]\n    use std::io::{stdin, stdout, BufWriter, Read as _, Write as _};\n    let mut _in_buf = Vec::new();\n    stdin().read_to_end(&mut _in_buf).expect(\"io error\");\n    let _in_buf = unsafe { String::from_utf8_unchecked(_in_buf) };\n    let mut scanner = Scanner::new(&_in_buf);\n    macro_rules !scan {() =>{scan !(usize ) } ;(($($t :tt ) ,*) ) =>{($(scan !($t ) ) ,*) } ;([$t :tt ;$len :expr ] ) =>{(0 ..$len ) .map (|_ |scan !($t ) ) .collect ::<Vec <_ >>() } ;([$t :ty ;$len :expr ] ) =>{scanner .scan_vec ::<$t >($len ) } ;([$t :ty ] ) =>{scanner .iter ::<$t >() } ;({$e :expr } ) =>{scanner .mscan ($e ) } ;($t :ty ) =>{scanner .scan ::<$t >() } ;}\n    let _out = stdout();\n    let mut _out = BufWriter::new(_out.lock());\n    macro_rules !print {($($arg :tt ) *) =>(::std ::write !(_out ,$($arg ) *) .expect (\"io error\" ) ) }\n    macro_rules !println {($($arg :tt ) *) =>(::std ::writeln !(_out ,$($arg ) *) .expect (\"io error\" ) ) }\n    macro_rules! echo {\n        ($iter :expr ) => {\n            echo!($iter, '\\n')\n        };\n        ($iter :expr ,$sep :expr ) => {\n            let mut iter = $iter.into_iter();\n            if let Some(item) = iter.next() {\n                print!(\"{}\", item);\n            }\n            for item in iter {\n                print!(\"{}{}\", $sep, item);\n            }\n            println!();\n        };\n    }\n    let n = scan!();\n    let m = scan!();\n    let f = MemorizedFactorial::new(m * 3 / 2 + n);\n    let mut ans = M::zero();\n    for i in (m % 2..=n.min(m)).step_by(2) {\n        let rem = (3 * m - i) / 2;\n        ans += f.combination(n, i) * f.homogeneous_product(n, rem);\n    }\n    for i in (m % 2..=n.min(m)).step_by(2) {\n        let rem = (m - i) / 2;\n        ans -= M::from(n) * f.combination(n, i) * f.homogeneous_product(n, rem);\n    }\n    for i in (m % 2..n.min(m + 1)).step_by(2) {\n        let rem = (m - i) / 2;\n        ans += M::from(n) * f.combination(n - 1, i) * f.homogeneous_product(n - 1, rem);\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports)]\n#![allow(non_snake_case)]\nuse std::cmp::*;\nuse std::collections::*;\nuse std::io::Write;\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($e:expr),*) => {\n        #[cfg(debug_assertions)]\n        $({\n            let (e, mut err) = (stringify!($e), std::io::stderr());\n            writeln!(err, \"{} = {:?}\", e, $e).unwrap()\n        })*\n    };\n}\n\nfn main() {\n    let v = read_vec::<usize>();\n    let (n, m) = (v[0], v[1]);\n    let max_idx = 2 * m + n;\n    let mut fact = vec![Modulo(1); max_idx + 1];\n    for i in 1..max_idx + 1 {\n        fact[i] = fact[i - 1] * Modulo(i as i64);\n    }\n    let fact_inv = fact.iter().map(|&x| x.inv()).collect::<Vec<_>>();\n\n    let mut a = vec![Modulo(1); 2 * m + 1];\n    for mi in 1..2 * m + 1 {\n        a[mi] = mod_comb(mi + n - 2, mi, &fact, &fact_inv);\n    }\n    let mut b = vec![Modulo(0); 2 * m + 1];\n    b[0] = a[0];\n    for mi in 1..2 * m + 1 {\n        b[mi] = b[mi - 1] + a[mi];\n    }\n    // debug!(a);\n\n    let mut ans = Modulo(0);\n    for p in 0..n + 1 {\n        if p > m {\n            break;\n        }\n        if p % 2 != m % 2 {\n            continue;\n        }\n        let ncp = mod_comb(n, p, &fact, &fact_inv);\n        let res = (3 * m - p) / 2;\n        let all = mod_comb(res + n - 1, res, &fact, &fact_inv);\n        let non1 = Modulo(p as i64) * (b[(m - p) / 2]);\n\n        let non2;\n        if (m - p) / 2 > 0 {\n            non2 = Modulo((n - p) as i64) * (b[(m - p) / 2 - 1]);\n        } else {\n            non2 = Modulo(0);\n        }\n        ans += ncp * (all - non1 - non2);\n    }\n    println!(\"{}\", ans);\n}\n\n#[derive(Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]\nstruct Modulo(i64);\nstatic mut MODULUS: i64 = 998244353;\nimpl Modulo {\n    fn set_modulus(m: i64) {\n        unsafe {\n            MODULUS = m;\n        }\n    }\n    fn get_modulus() -> i64 {\n        unsafe { MODULUS }\n    }\n    fn new(x: i64) -> Modulo {\n        let m = Modulo::get_modulus();\n        if x < 0 {\n            Modulo(x % m + m)\n        } else if x < m {\n            Modulo(x)\n        } else {\n            Modulo(x % m)\n        }\n    }\n    fn pow(self, p: i64) -> Modulo {\n        if p == 0 {\n            Modulo(1)\n        } else {\n            let mut t = self.pow(p / 2);\n            t *= t;\n            if p & 1 == 1 {\n                t *= self;\n            }\n            t\n        }\n    }\n    fn inv(self) -> Modulo {\n        self.pow(Modulo::get_modulus() - 2)\n    }\n}\nimpl std::fmt::Display for Modulo {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        self.0.fmt(f)\n    }\n}\nimpl std::ops::AddAssign for Modulo {\n    fn add_assign(&mut self, other: Modulo) {\n        let m = Modulo::get_modulus();\n        self.0 += other.0;\n        if self.0 >= m {\n            self.0 -= m;\n        }\n    }\n}\nimpl std::ops::MulAssign for Modulo {\n    fn mul_assign(&mut self, other: Modulo) {\n        let m = Modulo::get_modulus();\n        self.0 *= other.0;\n        self.0 %= m;\n    }\n}\nimpl std::ops::SubAssign for Modulo {\n    fn sub_assign(&mut self, other: Modulo) {\n        let m = Modulo::get_modulus();\n        self.0 += m - other.0;\n        if self.0 >= m {\n            self.0 -= m;\n        }\n    }\n}\nmacro_rules! impl_modulo_ops {\n    ($imp:ident, $method:ident, $assign_imp:ident, $assign_method:ident) => {\n        impl<'a> std::ops::$assign_imp<&'a Modulo> for Modulo {\n            fn $assign_method(&mut self, other: &'a Modulo) {\n                std::ops::$assign_imp::$assign_method(self, *other);\n            }\n        }\n        impl std::ops::$imp for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: Modulo) -> Modulo {\n                let mut x = self;\n                std::ops::$assign_imp::$assign_method(&mut x, other);\n                x\n            }\n        }\n        impl<'a> std::ops::$imp<Modulo> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: Modulo) -> Modulo {\n                std::ops::$imp::$method(*self, other)\n            }\n        }\n        impl<'a> std::ops::$imp<&'a Modulo> for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'a Modulo) -> Modulo {\n                std::ops::$imp::$method(self, *other)\n            }\n        }\n        impl<'a, 'b> std::ops::$imp<&'b Modulo> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'b Modulo) -> Modulo {\n                std::ops::$imp::$method(*self, *other)\n            }\n        }\n        impl std::ops::$assign_imp<i64> for Modulo {\n            fn $assign_method(&mut self, other: i64) {\n                std::ops::$assign_imp::$assign_method(self, Modulo::new(other));\n            }\n        }\n        impl<'a> std::ops::$assign_imp<&'a i64> for Modulo {\n            fn $assign_method(&mut self, other: &'a i64) {\n                std::ops::$assign_imp::$assign_method(self, *other);\n            }\n        }\n        impl std::ops::$imp<i64> for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: i64) -> Modulo {\n                let mut x = self;\n                std::ops::$assign_imp::$assign_method(&mut x, other);\n                x\n            }\n        }\n        impl<'a> std::ops::$imp<&'a i64> for Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'a i64) -> Modulo {\n                std::ops::$imp::$method(self, *other)\n            }\n        }\n        impl<'a> std::ops::$imp<i64> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: i64) -> Modulo {\n                std::ops::$imp::$method(*self, other)\n            }\n        }\n        impl<'a, 'b> std::ops::$imp<&'b i64> for &'a Modulo {\n            type Output = Modulo;\n            fn $method(self, other: &'b i64) -> Modulo {\n                std::ops::$imp::$method(*self, *other)\n            }\n        }\n    };\n}\nimpl_modulo_ops!(Add, add, AddAssign, add_assign);\nimpl_modulo_ops!(Mul, mul, MulAssign, mul_assign);\nimpl_modulo_ops!(Sub, sub, SubAssign, sub_assign);\n\nuse std::iter::Sum;\nimpl Sum for Modulo {\n    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = Modulo>,\n    {\n        iter.fold(Modulo(0), |a, b| a + b)\n    }\n}\n\nimpl<'a> Sum<&'a Modulo> for Modulo {\n    fn sum<I>(iter: I) -> Self\n    where\n        I: Iterator<Item = &'a Self>,\n    {\n        iter.fold(Modulo(0), |a, b| a + b)\n    }\n}\n\nfn mod_comb(n: usize, k: usize, fact: &[Modulo], fact_inv: &[Modulo]) -> Modulo {\n    assert!(n >= k);\n    fact[n] * fact[n - k].inv() * fact_inv[k]\n}\n\nfn read<T: std::str::FromStr>() -> T {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).ok();\n    s.trim().parse().ok().unwrap()\n}\n\nfn read_vec<T: std::str::FromStr>() -> Vec<T> {\n    read::<String>()\n        .split_whitespace()\n        .map(|e| e.parse().ok().unwrap())\n        .collect()\n}\n"
  }
]