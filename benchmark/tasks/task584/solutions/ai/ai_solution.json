[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int key;\n    struct Node* left;\n    struct Node* right;\n} Node;\n\nNode* createNode(int key) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->key = key;\n    newNode->left = NULL;\n    newNode->right = NULL;\n    return newNode;\n}\n\nNode* insert(Node* root, int key) {\n    if (root == NULL) {\n        return createNode(key);\n    }\n    \n    if (key < root->key) {\n        root->left = insert(root->left, key);\n    } else if (key > root->key) {\n        root->right = insert(root->right, key);\n    }\n    \n    return root;\n}\n\nint find(Node* root, int key) {\n    if (root == NULL) {\n        return 0;\n    }\n    \n    if (root->key == key) {\n        return 1;\n    }\n    \n    if (key < root->key) {\n        return find(root->left, key);\n    } else {\n        return find(root->right, key);\n    }\n}\n\nvoid inorderTraversal(Node* root) {\n    if (root != NULL) {\n        inorderTraversal(root->left);\n        printf(\"%d \", root->key);\n        inorderTraversal(root->right);\n    }\n}\n\nvoid preorderTraversal(Node* root) {\n    if (root != NULL) {\n        printf(\"%d \", root->key);\n        preorderTraversal(root->left);\n        preorderTraversal(root->right);\n    }\n}\n\nint main() {\n    Node* root = NULL;\n    int numOperations;\n    scanf(\"%d\", &numOperations);\n    \n    for (int i = 0; i < numOperations; i++) {\n        char operation[10];\n        int key;\n        scanf(\"%s\", operation);\n        \n        if (strcmp(operation, \"insert\") == 0) {\n            scanf(\"%d\", &key);\n            root = insert(root, key);\n        } else if (strcmp(operation, \"find\") == 0) {\n            scanf(\"%d\", &key);\n            printf(\"%s\\n\", find(root, key) ? \"true\" : \"false\");\n        } else if (strcmp(operation, \"print\") == 0) {\n            char traversalType[10];\n            scanf(\"%s\", traversalType);\n            \n            if (strcmp(traversalType, \"inorder\") == 0) {\n                inorderTraversal(root);\n                printf(\"\\n\");\n            } else if (strcmp(traversalType, \"preorder\") == 0) {\n                preorderTraversal(root);\n                printf(\"\\n\");\n            }\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:13:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int key;\n    struct Node *left, *right;\n} Node;\n\nNode *newNode(int key) {\n    Node *node = (Node *)malloc(sizeof(Node));\n    node->key = key;\n    node->left = node->right = NULL;\n    return node;\n}\n\nNode *insert(Node *node, int key) {\n    if (node == NULL) return newNode(key);\n    if (key < node->key)\n        node->left = insert(node->left, key);\n    else if (key > node->key)\n        node->right = insert(node->right, key);\n    return node;\n}\n\nNode *find(Node *node, int key) {\n    if (node == NULL || node->key == key)\n        return node;\n    if (key < node->key)\n        return find(node->left, key);\n    return find(node->right, key);\n}\n\nvoid inorder(Node *node) {\n    if (node != NULL) {\n        inorder(node->left);\n        printf(\" %d\", node->key);\n        inorder(node->right);\n    }\n}\n\nvoid preorder(Node *node) {\n    if (node != NULL) {\n        printf(\" %d\", node->key);\n        preorder(node->left);\n        preorder(node->right);\n    }\n}\n\nint main() {\n    Node *root = NULL;\n    int m, key;\n    char command[10];\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%s\", command);\n        if (command[0] == 'i') {\n            scanf(\"%d\", &key);\n            root = insert(root, key);\n        } else if (command[0] == 'f') {\n            scanf(\"%d\", &key);\n            if (find(root, key) != NULL)\n                printf(\"yes\\n\");\n            else\n                printf(\"no\\n\");\n        } else if (command[0] == 'p') {\n            inorder(root);\n            printf(\"\\n\");\n            preorder(root);\n            printf(\"\\n\");\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:13:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int key;\n    Node *left, *right;\n    Node(int key) : key(key), left(nullptr), right(nullptr) {}\n};\n\nNode* insert(Node* root, int key) {\n    if (root == nullptr) {\n        return new Node(key);\n    }\n    if (key < root->key) {\n        root->left = insert(root->left, key);\n    } else if (key > root->key) {\n        root->right = insert(root->right, key);\n    }\n    return root;\n}\n\nbool find(Node* root, int key) {\n    if (root == nullptr) {\n        return false;\n    }\n    if (key == root->key) {\n        return true;\n    } else if (key < root->key) {\n        return find(root->left, key);\n    } else {\n        return find(root->right, key);\n    }\n}\n\nvoid inorder(Node* root) {\n    if (root == nullptr) return;\n    inorder(root->left);\n    cout << \" \" << root->key;\n    inorder(root->right);\n}\n\nvoid preorder(Node* root) {\n    if (root == nullptr) return;\n    cout << \" \" << root->key;\n    preorder(root->left);\n    preorder(root->right);\n}\n\nint main() {\n    Node* root = nullptr;\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        string op;\n        cin >> op;\n        if (op == \"insert\") {\n            int key;\n            cin >> key;\n            root = insert(root, key);\n        } else if (op == \"find\") {\n            int key;\n            cin >> key;\n            if (find(root, key)) {\n                cout << \"yes\" << endl;\n            } else {\n                cout << \"no\" << endl;\n            }\n        } else if (op == \"print\") {\n            inorder(root);\n            cout << endl;\n            preorder(root);\n            cout << endl;\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:14:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Node {\n    int key;\n    Node left, right;\n\n    public Node(int item) {\n        key = item;\n        left = right = null;\n    }\n}\n\nclass BST {\n    Node root;\n\n    BST() {\n        root = null;\n    }\n\n    void insert(int key) {\n        root = insertRec(root, key);\n    }\n\n    Node insertRec(Node root, int key) {\n        if (root == null) {\n            root = new Node(key);\n            return root;\n        }\n        if (key < root.key) {\n            root.left = insertRec(root.left, key);\n        } else if (key > root.key) {\n            root.right = insertRec(root.right, key);\n        }\n        return root;\n    }\n\n    boolean find(int key) {\n        return findRec(root, key);\n    }\n\n    boolean findRec(Node root, int key) {\n        if (root == null) {\n            return false;\n        }\n        if (root.key == key) {\n            return true;\n        }\n        if (key < root.key) {\n            return findRec(root.left, key);\n        } else {\n            return findRec(root.right, key);\n        }\n    }\n\n    void inorder() {\n        inorderRec(root);\n        System.out.println();\n    }\n\n    void inorderRec(Node root) {\n        if (root != null) {\n            inorderRec(root.left);\n            System.out.print(root.key + \" \");\n            inorderRec(root.right);\n        }\n    }\n\n    void preorder() {\n        preorderRec(root);\n        System.out.println();\n    }\n\n    void preorderRec(Node root) {\n        if (root != null) {\n            System.out.print(root.key + \" \");\n            preorderRec(root.left);\n            preorderRec(root.right);\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        BST bst = new BST();\n        int m = sc.nextInt();\n        for (int i = 0; i < m; i++) {\n            String operation = sc.next();\n            switch (operation) {\n                case \"insert\":\n                    int key = sc.nextInt();\n                    bst.insert(key);\n                    break;\n                case \"find\":\n                    int findKey = sc.nextInt();\n                    System.out.println(bst.find(findKey) ? \"yes\" : \"no\");\n                    break;\n                case \"print\":\n                    bst.inorder();\n                    bst.preorder();\n                    break;\n            }\n        }\n        sc.close();\n    }\n}",
    "timestamp": "2025-08-05 22:14:23"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Node {\n    int key;\n    Node left, right;\n    \n    public Node(int item) {\n        key = item;\n        left = right = null;\n    }\n}\n\nclass BinarySearchTree {\n    Node root;\n    \n    BinarySearchTree() {\n        root = null;\n    }\n    \n    void insert(int key) {\n        root = insertRec(root, key);\n    }\n    \n    Node insertRec(Node root, int key) {\n        if (root == null) {\n            root = new Node(key);\n            return root;\n        }\n        \n        if (key < root.key)\n            root.left = insertRec(root.left, key);\n        else if (key > root.key)\n            root.right = insertRec(root.right, key);\n        \n        return root;\n    }\n    \n    boolean find(int key) {\n        return findRec(root, key);\n    }\n    \n    boolean findRec(Node root, int key) {\n        if (root == null)\n            return false;\n        \n        if (root.key == key)\n            return true;\n        \n        if (key < root.key)\n            return findRec(root.left, key);\n        \n        return findRec(root.right, key);\n    }\n    \n    void inorderTraversal() {\n        inorderRec(root);\n        System.out.println();\n    }\n    \n    void inorderRec(Node root) {\n        if (root != null) {\n            inorderRec(root.left);\n            System.out.print(root.key + \" \");\n            inorderRec(root.right);\n        }\n    }\n    \n    void preorderTraversal() {\n        preorderRec(root);\n        System.out.println();\n    }\n    \n    void preorderRec(Node root) {\n        if (root != null) {\n            System.out.print(root.key + \" \");\n            preorderRec(root.left);\n            preorderRec(root.right);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        BinarySearchTree bst = new BinarySearchTree();\n        \n        int numOperations = scanner.nextInt();\n        \n        for (int i = 0; i < numOperations; i++) {\n            String operation = scanner.next();\n            \n            switch (operation) {\n                case \"insert\":\n                    int insertKey = scanner.nextInt();\n                    bst.insert(insertKey);\n                    break;\n                case \"find\":\n                    int findKey = scanner.nextInt();\n                    System.out.println(bst.find(findKey) ? \"True\" : \"False\");\n                    break;\n                case \"print\":\n                    String traversalType = scanner.next();\n                    if (traversalType.equals(\"inorder\")) {\n                        bst.inorderTraversal();\n                    } else if (traversalType.equals(\"preorder\")) {\n                        bst.preorderTraversal();\n                    }\n                    break;\n            }\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 22:14:33"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nclass BSTNode {\npublic:\n    int key;\n    BSTNode* left;\n    BSTNode* right;\n\n    BSTNode(int value) {\n        key = value;\n        left = nullptr;\n        right = nullptr;\n    }\n};\n\nclass BST {\nprivate:\n    BSTNode* root;\n\n    BSTNode* insert(BSTNode* node, int key) {\n        if (node == nullptr) {\n            return new BSTNode(key);\n        }\n\n        if (key < node->key) {\n            node->left = insert(node->left, key);\n        } else if (key > node->key) {\n            node->right = insert(node->right, key);\n        }\n\n        return node;\n    }\n\n    bool find(BSTNode* node, int key) {\n        if (node == nullptr) {\n            return false;\n        }\n\n        if (key == node->key) {\n            return true;\n        }\n\n        if (key < node->key) {\n            return find(node->left, key);\n        } else {\n            return find(node->right, key);\n        }\n    }\n\n    void inorderTraversal(BSTNode* node) {\n        if (node == nullptr) {\n            return;\n        }\n\n        inorderTraversal(node->left);\n        cout << node->key << \" \";\n        inorderTraversal(node->right);\n    }\n\n    void preorderTraversal(BSTNode* node) {\n        if (node == nullptr) {\n            return;\n        }\n\n        cout << node->key << \" \";\n        preorderTraversal(node->left);\n        preorderTraversal(node->right);\n    }\n\npublic:\n    BST() {\n        root = nullptr;\n    }\n\n    void insertKey(int key) {\n        root = insert(root, key);\n    }\n\n    bool findKey(int key) {\n        return find(root, key);\n    }\n\n    void printInorder() {\n        inorderTraversal(root);\n        cout << endl;\n    }\n\n    void printPreorder() {\n        preorderTraversal(root);\n        cout << endl;\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n\n    BST bst;\n\n    for (int i = 0; i < n; i++) {\n        string op;\n        int key;\n        cin >> op >> key;\n\n        if (op == \"insert\") {\n            bst.insertKey(key);\n        } else if (op == \"find\") {\n            if (bst.findKey(key)) {\n                cout << \"true\" << endl;\n            } else {\n                cout << \"false\" << endl;\n            }\n        } else if (op == \"print\") {\n            if (key == 0) {\n                bst.printInorder();\n            } else {\n                bst.printPreorder();\n            }\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:14:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\nclass BST:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key):\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert(self.root, key)\n\n    def _insert(self, node, key):\n        if key < node.val:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert(node.left, key)\n        elif key > node.val:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert(node.right, key)\n\n    def find(self, key):\n        return self._find(self.root, key)\n\n    def _find(self, node, key):\n        if node is None:\n            return False\n        elif key == node.val:\n            return True\n        elif key < node.val:\n            return self._find(node.left, key)\n        else:\n            return self._find(node.right, key)\n\n    def inorder(self):\n        return self._inorder(self.root)\n\n    def _inorder(self, node):\n        if node is None:\n            return []\n        return self._inorder(node.left) + [node.val] + self._inorder(node.right)\n\n    def preorder(self):\n        return self._preorder(self.root)\n\n    def _preorder(self, node):\n        if node is None:\n            return []\n        return [node.val] + self._preorder(node.left) + self._preorder(node.right)\n\ndef process_operations(operations):\n    bst = BST()\n    results = []\n    for op in operations:\n        if op[0] == \"insert\":\n            bst.insert(int(op[1]))\n        elif op[0] == \"find\":\n            found = bst.find(int(op[1]))\n            results.append(\"Found\" if found else \"Not found\")\n        elif op[0] == \"print_inorder\":\n            results.append(\"Inorder: \" + ' '.join(map(str, bst.inorder())))\n        elif op[0] == \"print_preorder\":\n            results.append(\"Preorder: \" + ' '.join(map(str, bst.preorder())))\n    return results\n\n# Example usage:\nif __name__ == \"__main__\":\n    ops = [\n        [\"insert\", \"5\"],\n        [\"insert\", \"3\"],\n        [\"insert\", \"7\"],\n        [\"find\", \"3\"],\n        [\"find\", \"10\"],\n        [\"print_inorder\"],\n        [\"print_preorder\"]\n    ]\n    results = process_operations(ops)\n    for result in results:\n        print(result)",
    "timestamp": "2025-08-13 09:32:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\nclass BST {\n    class Node {\n        int key;\n        Node left, right;\n\n        public Node(int item) {\n            key = item;\n            left = right = null;\n        }\n    }\n\n    Node root;\n\n    BST() {\n        root = null;\n    }\n\n    void insert(int key) {\n        root = insertRec(root, key);\n    }\n\n    Node insertRec(Node root, int key) {\n        if (root == null) {\n            root = new Node(key);\n            return root;\n        }\n        if (key < root.key)\n            root.left = insertRec(root.left, key);\n        else if (key > root.key)\n            root.right = insertRec(root.right, key);\n        return root;\n    }\n\n    boolean find(int key) {\n        return findRec(root, key);\n    }\n\n    boolean findRec(Node root, int key) {\n        if (root == null) return false;\n        if (root.key == key) return true;\n        if (root.key > key) return findRec(root.left, key);\n        return findRec(root.right, key);\n    }\n\n    void inorder()  {\n        inorderRec(root);\n        System.out.println();\n    }\n\n    void inorderRec(Node root) {\n        if (root != null) {\n            inorderRec(root.left);\n            System.out.print(root.key + \" \");\n            inorderRec(root.right);\n        }\n    }\n\n    void preorder() {\n        preorderRec(root);\n        System.out.println();\n    }\n\n    void preorderRec(Node root) {\n        if (root != null) {\n            System.out.print(root.key + \" \");\n            preorderRec(root.left);\n            preorderRec(root.right);\n        }\n    }\n\n    public static void main(String[] args) {\n        BST tree = new BST();\n        Scanner scanner = new Scanner(System.in);\n        int numberOfOperations = scanner.nextInt();\n\n        for (int i = 0; i < numberOfOperations; i++) {\n            String operation = scanner.next();\n            switch (operation) {\n                case \"insert\":\n                    int keyToInsert = scanner.nextInt();\n                    tree.insert(keyToInsert);\n                    break;\n                case \"find\":\n                    int keyToFind = scanner.nextInt();\n                    System.out.println(tree.find(keyToFind) ? \"Found\" : \"Not Found\");\n                    break;\n                case \"inorder\":\n                    tree.inorder();\n                    break;\n                case \"preorder\":\n                    tree.preorder();\n                    break;\n            }\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 09:32:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Node structure for the BST\ntypedef struct Node {\n    int key;\n    struct Node *left, *right;\n} Node;\n\n// Function to create a new BST node\nNode* newNode(int item) {\n    Node *temp = (Node *)malloc(sizeof(Node));\n    temp->key = item;\n    temp->left = temp->right = NULL;\n    return temp;\n}\n\n// Insert a key into the BST\nNode* insert(Node* node, int key) {\n    if (node == NULL) return newNode(key);\n\n    if (key < node->key)\n        node->left = insert(node->left, key);\n    else if (key > node->key)\n        node->right = insert(node->right, key);\n\n    return node;\n}\n\n// Find a key in the BST\nint find(Node* root, int key) {\n    if (root == NULL)\n        return 0;\n    if (root->key == key)\n        return 1;\n    if (key < root->key)\n        return find(root->left, key);\n    return find(root->right, key);\n}\n\n// Inorder traversal of the BST\nvoid inorder(Node *root) {\n    if (root != NULL) {\n        inorder(root->left);\n        printf(\"%d \", root->key);\n        inorder(root->right);\n    }\n}\n\n// Preorder traversal of the BST\nvoid preorder(Node *root) {\n    if (root != NULL) {\n        printf(\"%d \", root->key);\n        preorder(root->left);\n        preorder(root->right);\n    }\n}\n\n// Main program to execute the operations\nint main() {\n    Node *root = NULL;\n    char operation[10];\n    int n, key;\n\n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", operation);\n        if (strcmp(operation, \"insert\") == 0) {\n            scanf(\"%d\", &key);\n            root = insert(root, key);\n        } else if (strcmp(operation, \"find\") == 0) {\n            scanf(\"%d\", &key);\n            if (find(root, key))\n                printf(\"Found\\n\");\n            else\n                printf(\"Not found\\n\");\n        } else if (strcmp(operation, \"inorder\") == 0) {\n            inorder(root);\n            printf(\"\\n\");\n        } else if (strcmp(operation, \"preorder\") == 0) {\n            preorder(root);\n            printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 09:32:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\nclass BinarySearchTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key):\n        self.root = self._insert_recursive(self.root, key)\n\n    def _insert_recursive(self, root, key):\n        if root is None:\n            return Node(key)\n        \n        if key < root.key:\n            root.left = self._insert_recursive(root.left, key)\n        elif key > root.key:\n            root.right = self._insert_recursive(root.right, key)\n        \n        return root\n\n    def find(self, key):\n        return self._find_recursive(self.root, key)\n\n    def _find_recursive(self, root, key):\n        if root is None or root.key == key:\n            return root is not None\n        \n        if key < root.key:\n            return self._find_recursive(root.left, key)\n        return self._find_recursive(root.right, key)\n\n    def inorder_traversal(self):\n        result = []\n        self._inorder_recursive(self.root, result)\n        return result\n\n    def _inorder_recursive(self, root, result):\n        if root:\n            self._inorder_recursive(root.left, result)\n            result.append(root.key)\n            self._inorder_recursive(root.right, result)\n\n    def preorder_traversal(self):\n        result = []\n        self._preorder_recursive(self.root, result)\n        return result\n\n    def _preorder_recursive(self, root, result):\n        if root:\n            result.append(root.key)\n            self._preorder_recursive(root.left, result)\n            self._preorder_recursive(root.right, result)\n\ndef main():\n    bst = BinarySearchTree()\n    \n    num_operations = int(input())\n    \n    for _ in range(num_operations):\n        operation = input().split()\n        \n        if operation[0] == 'i':\n            bst.insert(int(operation[1]))\n        elif operation[0] == 'f':\n            result = bst.find(int(operation[1]))\n            print('presente' if result else 'não presente')\n        elif operation[0] == 'p':\n            if operation[1] == 'inorder':\n                print(' '.join(map(str, bst.inorder_traversal())))\n            elif operation[1] == 'preorder':\n                print(' '.join(map(str, bst.preorder_traversal())))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 09:33:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\nclass BST:\n    def __init__(self):\n        self.root = None\n    \n    def insert(self, key):\n        if self.root is None:\n            self.root = Node(key)\n        else:\n            self._insert(self.root, key)\n    \n    def _insert(self, node, key):\n        if key < node.key:\n            if node.left is None:\n                node.left = Node(key)\n            else:\n                self._insert(node.left, key)\n        else:\n            if node.right is None:\n                node.right = Node(key)\n            else:\n                self._insert(node.right, key)\n    \n    def find(self, key):\n        return self._find(self.root, key)\n    \n    def _find(self, node, key):\n        if node is None:\n            return False\n        if node.key == key:\n            return True\n        elif key < node.key:\n            return self._find(node.left, key)\n        else:\n            return self._find(node.right, key)\n    \n    def inorder(self):\n        result = []\n        self._inorder(self.root, result)\n        return ' '.join(map(str, result))\n    \n    def _inorder(self, node, result):\n        if node is not None:\n            self._inorder(node.left, result)\n            result.append(node.key)\n            self._inorder(node.right, result)\n    \n    def preorder(self):\n        result = []\n        self._preorder(self.root, result)\n        return ' '.join(map(str, result))\n    \n    def _preorder(self, node, result):\n        if node is not None:\n            result.append(node.key)\n            self._preorder(node.left, result)\n            self._preorder(node.right, result)\n\ndef main():\n    bst = BST()\n    n = int(sys.stdin.readline())\n    for _ in range(n):\n        parts = sys.stdin.readline().split()\n        if parts[0] == 'insert':\n            bst.insert(int(parts[1]))\n        elif parts[0] == 'find':\n            if bst.find(int(parts[1])):\n                print('yes')\n            else:\n                print('no')\n        elif parts[0] == 'print':\n            print(' ' + bst.inorder())\n            print(' ' + bst.preorder())\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 09:33:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct Node {\n    int key;\n    Node* left;\n    Node* right;\n    Node(int k) : key(k), left(nullptr), right(nullptr) {}\n};\n\nclass BST {\npublic:\n    BST() : root(nullptr) {}\n\n    void insert(int key) {\n        root = insertRec(root, key);\n    }\n\n    bool find(int key) {\n        return findRec(root, key);\n    }\n\n    void inorder() {\n        inorderRec(root);\n        cout << endl;\n    }\n\n    void preorder() {\n        preorderRec(root);\n        cout << endl;\n    }\n\nprivate:\n    Node* root;\n\n    Node* insertRec(Node* node, int key) {\n        if (node == nullptr) {\n            return new Node(key);\n        }\n        if (key < node->key) {\n            node->left = insertRec(node->left, key);\n        } else {\n            node->right = insertRec(node->right, key);\n        }\n        return node;\n    }\n\n    bool findRec(Node* node, int key) {\n        if (node == nullptr) {\n            return false;\n        }\n        if (node->key == key) {\n            return true;\n        }\n        if (key < node->key) {\n            return findRec(node->left, key);\n        }\n        return findRec(node->right, key);\n    }\n\n    void inorderRec(Node* node) {\n        if (node != nullptr) {\n            inorderRec(node->left);\n            cout << node->key << \" \";\n            inorderRec(node->right);\n        }\n    }\n\n    void preorderRec(Node* node) {\n        if (node != nullptr) {\n            cout << node->key << \" \";\n            preorderRec(node->left);\n            preorderRec(node->right);\n        }\n    }\n};\n\nint main() {\n    BST tree;\n    int n;\n    cin >> n;\n\n    for (int i = 0; i < n; ++i) {\n        string operation;\n        cin >> operation;\n\n        if (operation == \"insert\") {\n            int key;\n            cin >> key;\n            tree.insert(key);\n        } else if (operation == \"find\") {\n            int key;\n            cin >> key;\n            if (tree.find(key)) {\n                cout << \"Found\" << endl;\n            } else {\n                cout << \"Not Found\" << endl;\n            }\n        } else if (operation == \"inorder\") {\n            tree.inorder();\n        } else if (operation == \"preorder\") {\n            tree.preorder();\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:52:28"
  }
]