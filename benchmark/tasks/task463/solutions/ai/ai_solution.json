[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MOD 1000000007\n\nlong long eval(char* expr);\nlong long parse_term(char** ptr);\nlong long apply_s(long long x);\nlong long apply_shift(long long x, long long y);\n\nint main() {\n    char line[1024];\n    while (fgets(line, sizeof(line), stdin)) {\n        if (strcmp(line, \"#\\n\") == 0) break;\n        \n        line[strcspn(line, \"\\n\")] = 0;\n        printf(\"%lld\\n\", eval(line));\n    }\n    return 0;\n}\n\nlong long eval(char* expr) {\n    char* ptr = expr;\n    return parse_term(&ptr);\n}\n\nlong long parse_term(char** ptr) {\n    while (isspace(**ptr)) (*ptr)++;\n    \n    if (**ptr == 'S') {\n        (*ptr)++;\n        long long val = parse_term(ptr);\n        return apply_s(val);\n    }\n    \n    if (**ptr == '(') {\n        (*ptr)++;\n        long long left = parse_term(ptr);\n        \n        while (isspace(**ptr)) (*ptr)++;\n        \n        if (**ptr == ')') {\n            (*ptr)++;\n            return left;\n        }\n        \n        if (**ptr == '>') {\n            (*ptr) += 2;\n            long long right = parse_term(ptr);\n            \n            while (isspace(**ptr)) (*ptr)++;\n            \n            if (**ptr == ')') {\n                (*ptr)++;\n                return apply_shift(left, right);\n            }\n        }\n    }\n    \n    return strtoll(*ptr, ptr, 10);\n}\n\nlong long apply_s(long long x) {\n    return (x * x) % MOD;\n}\n\nlong long apply_shift(long long x, long long y) {\n    return x / (1LL << y);\n}",
    "timestamp": "2025-08-05 21:45:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MOD 1000000007\n\ntypedef struct {\n    char *data;\n    size_t pos;\n} Parser;\n\nParser new_parser(char *input) {\n    Parser p = {input, 0};\n    return p;\n}\n\nchar peek(Parser *p) {\n    return p->data[p->pos];\n}\n\nvoid consume(Parser *p) {\n    p->pos++;\n}\n\nvoid skip_whitespace(Parser *p) {\n    while (peek(p) == ' ') consume(p);\n}\n\nlong long parse_expression(Parser *p);\n\nlong long parse_term(Parser *p) {\n    skip_whitespace(p);\n    if (peek(p) == 'S') {\n        consume(p);\n        skip_whitespace(p);\n        if (peek(p) != '(') {\n            fprintf(stderr, \"Expected '(' after 'S'\\n\");\n            exit(1);\n        }\n        consume(p);\n        long long expr = parse_expression(p);\n        skip_whitespace(p);\n        if (peek(p) != ')') {\n            fprintf(stderr, \"Expected ')' after expression\\n\");\n            exit(1);\n        }\n        consume(p);\n        return (expr * expr) % MOD;\n    } else if (isdigit(peek(p))) {\n        long long num = 0;\n        while (isdigit(peek(p))) {\n            num = num * 10 + (peek(p) - '0');\n            consume(p);\n        }\n        return num;\n    } else if (peek(p) == '(') {\n        consume(p);\n        long long expr = parse_expression(p);\n        skip_whitespace(p);\n        if (peek(p) != ')') {\n            fprintf(stderr, \"Expected ')' after expression\\n\");\n            exit(1);\n        }\n        consume(p);\n        return expr;\n    } else {\n        fprintf(stderr, \"Unexpected character: %c\\n\", peek(p));\n        exit(1);\n    }\n}\n\nlong long parse_expression(Parser *p) {\n    long long left = parse_term(p);\n    skip_whitespace(p);\n    while (peek(p) == '>' && p->data[p->pos + 1] == '>') {\n        consume(p);\n        consume(p);\n        long long right = parse_term(p);\n        left = left >> right;\n        skip_whitespace(p);\n    }\n    return left;\n}\n\nint main() {\n    char line[1024];\n    while (fgets(line, sizeof(line), stdin)) {\n        if (strcmp(line, \"#\\n\") == 0) break;\n        Parser p = new_parser(line);\n        long long result = parse_expression(&p);\n        printf(\"%lld\\n\", result);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:46:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst long long MOD = 1000000007;\n\nlong long evaluateS(long long x) {\n    return (x * x) % MOD;\n}\n\nlong long evaluateShift(long long x, long long y) {\n    if (y < 0) return 0; // to handle large y, though problem says valid input\n    return x >> y;\n}\n\nlong long evaluateExpression(const string& expr) {\n    stack<long long> values;\n    stack<char> ops;\n    string numStr;\n    \n    for (int i = 0; i < expr.size(); ) {\n        char c = expr[i];\n        if (c == ' ') {\n            i++;\n            continue;\n        }\n        if (c == 'S') {\n            ops.push('S');\n            i++;\n            if (i < expr.size() && expr[i] == '(') {\n                i++; // skip '('\n            }\n        } else if (c == '>' && i + 1 < expr.size() && expr[i+1] == '>') {\n            ops.push('>');\n            i += 2;\n        } else if (c == '(') {\n            ops.push('(');\n            i++;\n        } else if (c == ')') {\n            while (!ops.empty() && ops.top() != '(') {\n                char op = ops.top(); ops.pop();\n                if (op == 'S') {\n                    long long val = values.top(); values.pop();\n                    values.push(evaluateS(val));\n                } else if (op == '>') {\n                    long long val2 = values.top(); values.pop();\n                    long long val1 = values.top(); values.pop();\n                    values.push(evaluateShift(val1, val2));\n                }\n            }\n            if (!ops.empty() && ops.top() == '(') {\n                ops.pop(); // pop '('\n            }\n            i++;\n        } else if (isdigit(c)) {\n            numStr.clear();\n            while (i < expr.size() && isdigit(expr[i])) {\n                numStr += expr[i];\n                i++;\n            }\n            long long num = stoll(numStr);\n            values.push(num);\n        } else {\n            i++;\n        }\n    }\n    \n    while (!ops.empty()) {\n        char op = ops.top(); ops.pop();\n        if (op == 'S') {\n            long long val = values.top(); values.pop();\n            values.push(evaluateS(val));\n        } else if (op == '>') {\n            long long val2 = values.top(); values.pop();\n            long long val1 = values.top(); values.pop();\n            values.push(evaluateShift(val1, val2));\n        }\n    }\n    \n    return values.top();\n}\n\nint main() {\n    string line;\n    while (getline(cin, line)) {\n        if (line == \"#\") break;\n        // Remove all spaces for easier parsing\n        line.erase(remove(line.begin(), line.end(), ' '), line.end());\n        cout << evaluateExpression(line) << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:46:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class ShipuraEvaluator {\n    private static final long MOD = 1000000007L;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        while (!(line = br.readLine()).equals(\"#\")) {\n            String[] tokens = line.split(\"\\\\s+\");\n            Stack<String> stack = new Stack<>();\n            for (int i = tokens.length - 1; i >= 0; i--) {\n                stack.push(tokens[i]);\n            }\n            long result = evaluate(stack);\n            System.out.println(result);\n        }\n    }\n\n    private static long evaluate(Stack<String> stack) {\n        while (!stack.isEmpty()) {\n            String token = stack.pop();\n            if (token.equals(\"S\")) {\n                long x = evaluate(stack);\n                return (x * x) % MOD;\n            } else if (token.equals(\">>\")) {\n                long x = evaluate(stack);\n                long y = evaluate(stack);\n                return x >> y;\n            } else {\n                return Long.parseLong(token);\n            }\n        }\n        return 0;\n    }\n}",
    "timestamp": "2025-08-05 21:47:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ShipuraEvaluator {\n    private static final int MOD = 1_000_000_007;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (true) {\n            String line = scanner.nextLine();\n            if (line.equals(\"#\")) {\n                break;\n            }\n            \n            long result = evaluate(line);\n            System.out.println(result);\n        }\n        \n        scanner.close();\n    }\n\n    private static long evaluate(String expression) {\n        return parseExpression(expression);\n    }\n\n    private static long parseExpression(String expr) {\n        expr = expr.trim();\n        \n        if (expr.startsWith(\"S(\")) {\n            long inner = parseExpression(expr.substring(2, expr.length() - 1));\n            return computeS(inner);\n        }\n        \n        int index = findRightmostOperator(expr);\n        if (index == -1) {\n            return Long.parseLong(expr);\n        }\n        \n        long left = parseExpression(expr.substring(0, index));\n        long right = parseExpression(expr.substring(index + 2));\n        \n        return computeShift(left, right);\n    }\n\n    private static int findRightmostOperator(String expr) {\n        int parenthesesCount = 0;\n        for (int i = expr.length() - 1; i >= 0; i--) {\n            if (expr.charAt(i) == ')') {\n                parenthesesCount++;\n            } else if (expr.charAt(i) == '(') {\n                parenthesesCount--;\n            }\n            \n            if (parenthesesCount == 0 && expr.charAt(i) == '>') {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    private static long computeS(long x) {\n        return (x * x) % MOD;\n    }\n\n    private static long computeShift(long x, long y) {\n        return (long) Math.floor(x / Math.pow(2, y));\n    }\n}",
    "timestamp": "2025-08-05 21:47:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n\nconst long long MOD = 1000000007;\n\nlong long evaluate(const string& expr) {\n    int len = expr.length();\n    if (len == 0) return 0;\n    \n    if (expr[0] == 'S') {\n        long long x = evaluate(expr.substr(2, len-3));\n        return (x * x) % MOD;\n    }\n    \n    size_t op_pos = expr.find(\">>\");\n    if (op_pos != string::npos) {\n        string left = expr.substr(0, op_pos);\n        string right = expr.substr(op_pos+2);\n        long long x = evaluate(left);\n        long long y = evaluate(right);\n        return floor(x / pow(2, y));\n    }\n    \n    return stoll(expr);\n}\n\nint main() {\n    string line;\n    while (getline(cin, line) && line != \"#\") {\n        cout << evaluate(line) << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:47:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def evaluate_expression(tokens):\n    def parse_expression(tokens):\n        if not tokens:\n            return None\n\n        token = tokens.pop(0)\n\n        if token == 'S':\n            x = parse_expression(tokens)\n            return (x * x) % 1_000_000_007\n        elif token.isdigit():\n            return int(token)\n        elif token == '>>':\n            x = parse_expression(tokens)\n            y = parse_expression(tokens)\n            return x // (2 ** y)\n        \n        return None\n\n    return parse_expression(tokens)\n\ndef main():\n    import sys\n\n    for line in sys.stdin:\n        if line.strip() == '#':\n            break\n\n        tokens = line.strip().replace('(', ' ').replace(')', ' ').split()\n        result = evaluate_expression(tokens)\n        print(result)\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 07:29:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Stack;\n\npublic class ShipuraEvaluator {\n\n    private static final long MODULO = 1_000_000_007L;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String expression;\n\n        while ((expression = reader.readLine()) != null) {\n            if (expression.trim().equals(\"#\")) {\n                break;\n            }\n            long result = evaluate(expression.trim());\n            System.out.println(result);\n        }\n    }\n\n    private static long evaluate(String expression) {\n        Stack<Long> operands = new Stack<>();\n        Stack<Character> operators = new Stack<>();\n\n        int i = 0;\n        while (i < expression.length()) {\n            char current = expression.charAt(i);\n\n            if (Character.isWhitespace(current)) {\n                i++;\n                continue;\n            }\n\n            if (Character.isDigit(current)) {\n                int start = i;\n                while (i < expression.length() && Character.isDigit(expression.charAt(i))) {\n                    i++;\n                }\n                long num = Long.parseLong(expression.substring(start, i));\n                operands.push(num);\n                continue;\n            }\n\n            if (current == 'S') {\n                i++;\n                long val = operands.pop();\n                operands.push(moduloSquare(val));\n                continue;\n            }\n\n            if (current == '>') {\n                i += 2; // Skip '>>'\n                operators.push('>');\n                continue;\n            }\n\n            i++;\n        }\n\n        while (!operators.isEmpty()) {\n            char operator = operators.pop();\n            if (operator == '>') {\n                long y = operands.pop();\n                long x = operands.pop();\n                operands.push(shiftRight(x, y));\n            }\n        }\n\n        return operands.pop();\n    }\n\n    private static long shiftRight(long x, long y) {\n        return x / (1L << y);\n    }\n\n    private static long moduloSquare(long x) {\n        return (x * x) % MODULO;\n    }\n}",
    "timestamp": "2025-08-13 07:29:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define MOD 1000000007\n\n// Function to calculate x squared modulo MOD\nlong long S(long long x) {\n    return (x * x) % MOD;\n}\n\n// Function to parse S function\nlong long parseS(char **expr);\n\n// Function to parse the expression with >>\nlong long parseExpression(char **expr) {\n    char *endptr;\n\n    // Skip spaces\n    while (**expr == ' ') (*expr)++;\n    \n    long long x = strtoll(*expr, &endptr, 10);\n    if (endptr == *expr) {\n        // If input is \"S(...)\", move endptr to after the \"(\"\n        if (**expr == 'S') {\n            *expr += 1;  // Move past 'S'\n            if (**expr == '(') {\n                *expr += 1;  // Move past '('\n                x = parseS(expr);  // Evaluate inside S\n            }\n        }\n    } else {\n        *expr = endptr;  // Update expr to after the number\n    }\n\n    // Skip spaces\n    while (**expr == ' ') (*expr)++;\n\n    // If there's a '>>', perform the operation\n    if (strncmp(*expr, \">>\", 2) == 0) {\n        *expr += 2;  // Move past '>>'\n        long long y = parseExpression(expr);\n        x = x / (1LL << y);\n    }\n    \n    return x;\n}\n\n// Function to evaluate S(expr)\nlong long parseS(char **expr) {\n    long long result = S(parseExpression(expr));\n\n    // Skip spaces\n    while (**expr == ' ') (*expr)++;\n    \n    if (**expr == ')') {\n        *expr += 1;  // move past ')'\n    }\n    \n    return result;\n}\n\nint main() {\n    char input[1000];\n\n    while (fgets(input, sizeof(input), stdin)) {\n        // Remove newline character if present\n        size_t len = strlen(input);\n        if (len > 0 && input[len - 1] == '\\n') {\n            input[len - 1] = '\\0';\n        }\n\n        // Stop if input is \"#\"\n        if (strcmp(input, \"#\") == 0) break;\n\n        // Parse and evaluate the expression\n        char *expr = input;\n        long long result = parseExpression(&expr);\n\n        // Output the result\n        printf(\"%lld\\n\", result);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 07:29:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def evaluate_expression(expr):\n    def parse(tokens):\n        if len(tokens) == 1:\n            return int(tokens[0])\n        \n        if tokens[0] == 'S':\n            x = parse(tokens[1:])\n            return (x * x) % 1000000007\n        \n        if '>>' in tokens:\n            idx = tokens.index('>>')\n            left = parse(tokens[:idx])\n            right = parse(tokens[idx+1:])\n            return left // (2 ** right)\n        \n    tokens = expr.split()\n    return parse(tokens)\n\ndef main():\n    while True:\n        expr = input().strip()\n        if expr == '#':\n            break\n        result = evaluate_expression(expr)\n        print(result)\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 07:29:54"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\nMOD = 10**9 + 7\n\ndef evaluate(expr):\n    stack = []\n    for token in reversed(expr.split()):\n        if token == 'S':\n            x = stack.pop()\n            res = (x * x) % MOD\n            stack.append(res)\n        elif token == '>>':\n            x = stack.pop()\n            y = stack.pop()\n            res = x // (2 ** y)\n            stack.append(res)\n        else:\n            stack.append(int(token))\n    return stack[0]\n\ndef main():\n    for line in sys.stdin:\n        line = line.strip()\n        if line == '#':\n            break\n        print(evaluate(line))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 07:30:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <cctype>\n#include <cmath>\n\nconst int MOD = 1000000007;\n\n// Helper function to parse expressions\nclass ShipuraParser {\n    std::string::const_iterator it;\n    std::string expression;\n\npublic:\n    ShipuraParser(const std::string& expr) : expression(expr), it(expression.begin()) {}\n\n    long long parseExpression() {\n        long long result = parseTerm();\n        while (it != expression.end() && std::isspace(*it)) ++it;\n        return result;\n    }\n\nprivate:\n    long long parseTerm() {\n        long long result = parseFactor();\n        while (it != expression.end() && std::isspace(*it)) ++it;\n        if (it != expression.end() && *it == '>') {\n            if ((it + 1) != expression.end() && *(it + 1) == '>') {\n                it += 2;\n                long long exp = parseTerm();\n                result = result / static_cast<long long>(std::pow(2, exp));\n            }\n        }\n        return result;\n    }\n\n    long long parseFactor() {\n        while (it != expression.end() && std::isspace(*it)) ++it;\n        if (it != expression.end() && *it == 'S') {\n            ++it;\n            return parseFunction();\n        }\n        return parseNumber();\n    }\n\n    long long parseFunction() {\n        long long value = parseFactor();\n        return (value * value) % MOD;\n    }\n\n    long long parseNumber() {\n        while (it != expression.end() && std::isspace(*it)) ++it;\n        long long number = 0;\n        while (it != expression.end() && std::isdigit(*it)) {\n            number = number * 10 + (*it - '0');\n            ++it;\n        }\n        return number;\n    }\n};\n\nint main() {\n    std::string line;\n    while (std::getline(std::cin, line)) {\n        if (line == \"#\") break;\n        ShipuraParser parser(line);\n        std::cout << parser.parseExpression() << std::endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 11:38:53"
  }
]