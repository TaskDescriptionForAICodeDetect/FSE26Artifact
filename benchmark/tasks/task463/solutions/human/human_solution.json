[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport scala.collection.mutable\n\nobject Main extends App {\n  import scala.io.StdIn._\n  loop()\n  @tailrec def loop(): Unit = {\n    val str = readLine.trim\n    if (str == \"#\") return\n    str match {\n      case Expression(e) ⇒ println(e)\n      case _ ⇒ ???\n    }\n    loop()\n  }\n}\nobject Expression {\n  val mod = 1000000007L\n\n  def unapply(arg: String): Option[Long] = {\n    arg.filterNot(_.isWhitespace).toList match {\n      case e Expr Nil ⇒ Some(e)\n      case _ ⇒ None\n    }\n  }\n\n  object Number {\n    def unapply(arg: List[Char]): Option[(Long, List[Char])] = {\n      arg.span(_.isDigit) match {\n        case (Nil, _) ⇒ None\n        case (n, rest) ⇒ Some(n.foldLeft(0L){case (acc, d) ⇒ acc * 10 + d.asDigit}, rest)\n      }\n    }\n  }\n  object Term {\n    def unapply(arg: List[Char]): Option[(Long, List[Char])] = {\n      arg match {\n        case n Number rest ⇒ Some(n, rest)\n        case 'S'::'<'::(e Expr '>'::rest) ⇒ Some((e * e) % mod, rest)\n        case _ ⇒ None\n      }\n    }\n  }\n  object Expr {\n    def unapply(arg: List[Char]): Option[(Long, List[Char])] = {\n      arg match {\n        case t Term rest ⇒ Some(takeAll(rest, t))\n        case _ ⇒ None\n      }\n    }\n    @tailrec private[this] def takeAll(arg: List[Char], left: Long): (Long, List[Char]) = {\n      arg match {\n        case '>'::'>'::(right Term rest) ⇒ takeAll(rest, left >> math.min(63, right))\n        case _ ⇒ (left, arg)\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define INF 1e9\n#define EPS 1e-9\n#define MOD (ll)(1e9+7)\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\n\ntemplate<class T>string bitstr(T x){return typeid(T)==typeid(int)?bitset<32>(x).to_string('_','#'):bitset<64>(x).to_string();}\ntemplate<class T>int bitcnt(T x){return typeid(T)==typeid(int)?__builtin_popcount(x):__builtin_popcountll(x);}\ntemplate<class T>int bitdig(T x){return x?typeid(T)==typeid(int)?32-__builtin_clz(x):64-__builtin_clzll(x):0;}\ntemplate<class T>int bitpow(T x){return x?typeid(T)==typeid(int)?__builtin_ctz(x):__builtin_ctzll(x):0;}\n\nstring solve(string s,bool f=false){\n\tint open=0,len=0;\n\tif(f){\n\t\tif(s.find(\"-\")==-1) return s;\n\t\tstring a=\"\",b=\"\";\n\t\tfor(int i=s.size()-1;i>=0;i--){\n\t\t\tif(s[i]=='-'){\n\t\t\t\ta=s.substr(0,i);\n\t\t\t\tb=s.substr(i+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//cout<<a<<\",\"<<b<<endl;\n\t\tauto ans=to_string(stoll(solve(a,true))>>min(32ll,stoll(b)));\n\t\t//cout<<a<<\">>\"<<b<<\"=\"<<ans<<endl;\n\t\treturn ans;\n\t}\n\tstack<int> stk;\n\tfor(int i=0;i<s.size();i++){\n\t\t//cout<<s<<\"[\"<<i<<\"](\"<<open<<\",\"<<len<<\")\"<<endl;\n\t\tif(s[i]=='<') {\n\t\t\topen=i,len=0;\n\t\t\tstk.push(i);\n\t\t}\n\t\telse if(s[i]=='>'){\n\t\t\t//cout<<s.substr(open+1,len)<<endl;\n\t\t\tll inner=stoll(solve(s.substr(open+1,len),true));\n\t\t\t//cout<<inner<<endl;\n\t\t\tinner=inner*inner%MOD;\n\t\t\tint l=to_string(inner).length();\n\t\t\ts.replace(open-1, len+3, to_string(inner));\n\t\t\tstk.pop();\n\t\t\ti-=len+3-l;\n\t\t\tif(!stk.empty()) open=stk.top();\n\t\t\tlen=i-open;\n\t\t\t//cout<<i<<\",\"<<open<<\",\"<<l<<\",\"<<s<<endl;\n\t\t\t//cout<<open<<\",\"<<l<<endl;\n\t\t}else len++;\n\t\t//cout<<\"fin:\"<<s<<endl;\n\t}\n\treturn solve(s,true);\n}\n\n\nint main(){\n\tstring s;\n\twhile(getline(cin,s), s!=\"#\"){\n\t\tfor(auto c=s.find_first_of(\" \");c!=-1;c=s.find_first_of(\" \")){\n\t\t\ts.erase(c,1);\n\t\t}\n\t\tfor(int i=1;i<s.size()-1;i++){\n\t\t\tif(s[i-1]=='>' and s[i]=='>' and s[i+1]!='<' and s[i+1]!='>'){\n\t\t\t\ts.replace(i-1,2,\"-\");\n\t\t\t}\n\t\t}\n\t\tfor(auto c=s.find(\"-0\");c!=-1;c=s.find(\"-0\")){\n\t\t\ts.erase(c,2);\n\t\t}\n\t\tint p=0;\n\t\trep(i,s.size()-1){\n\t\t\tif(s[i]=='<') p++;\n\t\t\tif(s[i]=='>') p--;\n\t\t\tif(p<0){\n\t\t\t\tp=0;\n\t\t\t\ts[i]='-';\n\t\t\t}\n\t\t}\n\t\tcout<<solve(s,(s.find(\"S\")==-1))<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<deque>\nusing namespace std;\nconst long mod=1e9+7;\nstring s;\nlong calc(deque<long>&Q)\n{\n\tlong A=-1,B=0;\n\twhile(!Q.empty()&&Q.front()!=-3)\n\t{\n\t\tlong now;\n\t\tif(Q.front()==-2)\n\t\t{\n\t\t\tQ.pop_front();\n\t\t\tlong T=calc(Q);\n\t\t\tQ.pop_front();\n\t\t\tnow=T*T%mod;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnow=Q.front();\n\t\t\tQ.pop_front();\n\t\t}\n\t\tif(A==-1)A=now;\n\t\telse\n\t\t{\n\t\t\tB+=now;\n\t\t\tif(B>=32)B=32;\n\t\t}\n\t}\n\treturn A>>B;\n}\nmain()\n{\n\twhile(getline(cin,s),s!=\"#\")\n\t{\n\t\tdeque<long>P;\n\t\tfor(int i=0;i<s.size();)\n\t\t{\n\t\t\tif(s[i]=='S')\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t\tP.push_back(-2);\n\t\t\t\twhile(s[i]!='<')i++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if(s[i]=='>')\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t\tP.push_back(-1);\n\t\t\t}\n\t\t\telse if(s[i]==' ')i++;\n\t\t\telse\n\t\t\t{\n\t\t\t\tlong t=0;\n\t\t\t\twhile('0'<=s[i]&&s[i]<='9')\n\t\t\t\t{\n\t\t\t\t\tt=t*10+s[i]-'0';\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tP.push_back(t);\n\t\t\t}\n\t\t}\n\t\tdeque<long>Q;\n\t\tbool num=false;\n\t\tfor(int i=P.size()-1;i>=0;)\n\t\t{\n\t\t\tif(P[i]>=0)\n\t\t\t{\n\t\t\t\tnum=true;\n\t\t\t\tQ.push_front(P[i]);\n\t\t\t\ti--;\n\t\t\t}\n\t\t\telse if(P[i]==-2)\n\t\t\t{\n\t\t\t\tQ.push_front(-2);\n\t\t\t\ti--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(num)\n\t\t\t\t{\n\t\t\t\t\tif(i>=1&&P[i-1]==-1)\n\t\t\t\t\t{\n\t\t\t\t\t\ti-=2;\n\t\t\t\t\t\tnum=false;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcout<<\"ERROR\"<<endl;\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tQ.push_front(-3);\n\t\t\t\t\ti--;\n\t\t\t\t\tnum=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<calc(Q)<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint number(string &S, int &i);\nint term(string &S, int &i);\nint expr(string &S, int &i);\n\nint number(string &S, int &i){\n    int ret = 0;\n    while(isdigit(S[i])){\n        ret*=10;\n        ret+=S[i]-'0';\n        i++;\n    }\n    return ret;\n}\n\nint term(string &S, int &i){\n    const int64_t mod=1000000007;\n    if(S[i]=='S'){\n        i+=2;//'<'\n        int64_t x = expr(S,i);\n        i++;//'>'\n        return x*x%mod;\n    }else{\n        return number(S,i);\n    }\n}\n\nint expr(string &S, int &i){\n    int ret = term(S,i);\n    while(i<S.size()){\n        int cnt=0;\n        for(int j=i;j<S.size();j++){\n            if(S[j]=='>')cnt++;\n            else break;\n        }\n        if(cnt==2&&i+2<S.size()){\n            i+=2;\n            int y = term(S,i);\n            if(y>=64){\n                ret=0;\n            }else{\n                ret>>=y;\n            }\n            continue;\n        }else{\n            return ret;\n        }\n    }\n    return ret;\n}\n\nint main(){\n    string S;\n    while(getline(cin,S)){\n        if(S[0]=='#') break;\n        int i=0;\n        string ss;\n        for(auto c:S){\n            if(c!=' ') ss.push_back(c);\n        }\n        // cout<<ss<<endl;\n        cout<<expr(ss,i)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <cstdio>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <algorithm>\n#include <limits>\n#include <map>\n\nusing namespace std;\nusing ll = long long;\nconst ll MD = 1e9+7.1;\n\nint n;\nchar s[2000030];\n\nll expr(char **begin);\n\nll numb(char **begin) {\n    ll r = 0;\n    while (isdigit(**begin)) {\n        r *= 10;\n        r += **begin - '0';\n        *begin += 1;\n    }\n    return r;\n}\n\nll term(char **begin) {\n    if (**begin == 'S') {\n        *begin += 2;\n        ll r = expr(begin)%MD;\n        *begin += 1;\n        return (r*r)%MD;\n    } else {\n        return numb(begin);\n    }\n}\n\nll expr(char **begin) {\n    ll r = term(begin);\n    while (true) {\n        if (**begin == '>' && *(*begin + 2) != '>') {\n            *begin += 2;\n            r >>= min(60LL, term(begin));\n        } else {\n            break;\n        }\n    }\n    return r;\n}\n\nint main() {\n    while (true) {\n        string ss;\n        getline(cin, ss);\n        if (ss[0] == '#') break;\n        n = 0;\n        for (char c: ss) {\n            if (c != ' ') {\n                s[n] = c;\n                n++;\n            }\n        }\n        s[n] = '@';\n        char *beg = s;\n        ll ans = expr(&beg);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstring str;\nint idx;\n\nint expr();\nint term();\nint number();\n\nint number() {\n  string res = \"\";\n  while(idx < (int)str.size() && isdigit(str[idx])) res += str[idx++];\n  reverse(all(res));\n  return stoll(res);\n}\n\nint term() {\n  if(isdigit(str[idx])) return number();\n  if(str[idx] == '>') {\n    idx++;\n    int x = expr();\n    assert(str[idx++] == '<');\n    assert(str[idx++] == 'S');\n    return x*x % mod;\n  } else {\n    assert(false);\n    return 0;\n  }\n}\n\nint expr() {\n  int y = term();\n  if(idx >= (int)str.size()) return y;\n  if(str[idx] == '<') return y;\n  else if(str[idx] == '>') {\n    idx++;\n    assert(str[idx++] == '>');\n    int x = expr();\n    return y > 30 ? 0 : x>>y;\n  } else {\n    assert(false);\n    return 0;\n  }\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  string buf;\n  while(getline(cin, buf), buf != \"#\") {\n    str = \"\";\n    rep(i, buf.size()) if(buf[i] != ' ') str += buf[i];\n    reverse(all(str));\n    idx = 0;\n    cout << expr() << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdlib>\n#include<sstream>\n#define mod 1000000007\nusing namespace std;\n\ntypedef long long ll;\n\nstring f1(string a){\n  ll x=(ll)atoi(a.c_str());\n  x=(x*x)%mod;\n  ostringstream os;\n  os<<x;\n  return os.str();\n}\n\nstring f2(string a,string b){\n  ll x=atoi(a.c_str()),y=atoi(b.c_str()),c=1;\n  for(int i=0;i<y;i++){\n    c*=2;\n    if(x<c)return \"0\";\n  }\n  x=x/c;\n  ostringstream os;\n  os<<x;\n  return os.str();\n}\n\nstring rec(vector<string> a){\n  for(int i=0;i<a.size();i++){\n    if(a[i]==\"S<\"){\n      int l=1,r=0;\n      vector<string> b;\n      for(int j=i+1;j<a.size();j++){\n\tif(a[j]==\"S<\")l++;\n\tif(a[j]==\">\")r++;\n\tif(l==r){\n\t  a[j-1]=rec(b);\n\t  i=j-1;\n\t  break;\n\t}\n        b.push_back(a[j]);\n      }\n    }\n    else if(a[i]==\">>\"){\n      a[i+1]=f2(a[i-1],a[i+1]);\n    }\n    else if(a[i]==\">\")a[i]=f1(a[i-1]);\n  }\n  return a[a.size()-1];\n}\n\nint main()\n{\n  while(1){\n    string s,t;\n    vector<string> a,b;\n    t=\"\";\n    getline(cin,s);\n    if(s[0]=='#')break;\n    for(int i=0;i<s.length();i++)if(s[i]!=' ')t+=s[i];\n    string tmp=\"\";\n    for(int i=0;i<t.length();i++){\n      if(t[i]=='S'){\n\ta.push_back(\"S<\");\n\ti++;\n      }\n      else if(t[i]=='>'){\n\tif(tmp!=\"\")a.push_back(tmp);\n\ttmp=\"\";\n\ta.push_back(\">\");\n      }\n      else tmp+=t[i];\n      if(i==t.length()-1 && tmp!=\"\")a.push_back(tmp);\n    }\n    for(int i=a.size()-1;0<i;i--){\n      if(a[i]!=\">\" && a[i]!=\"S<\"){\n\tb.push_back(a[i]);\n\tif(a[i-1]==\">\"){\n\t  i-=2;\n\t  b.push_back(\">>\");\n\t}\n      }\n      else b.push_back(a[i]);\n    }\n    b.push_back(a[0]);\n    reverse(b.begin(),b.end());\n    cout<<rec(b)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define _A_ 1\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll MOD = 1000000007LL;\n\nclass Parsing {\nprivate:\n  string parse;\n  int pos;\npublic:\n  Parsing(string s){\n    parse = s;\n    pos = 0;\n  }\n  \n  ll fact(){\n    if( parse[pos] == 'S' ) {\n      pos+=2; // S<xx>\n      ll p = expression();\n      if( pos >= (int)parse.size() ) return -1LL;\n      pos++;\n      return ( ( p % MOD ) * ( p % MOD ) ) % MOD;\n    } else {\n      if( pos >= (int)parse.size() || !isdigit(parse[pos]) ) return -1LL;\n      ll p = 0;\n      while( '0' <= parse[pos] && parse[pos] <= '9' ){\n\tp *= 10LL;\n\tp += (ll)(parse[pos] - '0');\n\tpos++;\n      }\n      return p;\n    }\n  }\n\n  ll expression(){\n\n    ll p = fact();\n\n    if( p == -1LL ) return -1LL;\n\n    //\n\n\n    while( parse[pos] == '>' && ( pos + 1 < (int)parse.size() && parse[pos+1] == '>' ) ){\n      int temp = pos;\n      ll  temp_v = p;      \n      pos += 2;\n\n      ll q = fact();\n      if( q == -1LL ) {\n\n\tpos = temp;\n\treturn temp_v;\n      }\n      for(ll i=0;i<q;i++) p >>= 1LL;\n    }\n    return p;\n  }\n\n};\n\nint main(){\n  string s;\n  while( _A_ ){\n    getline(cin,s);\n    if( s == \"#\" ) break;\n    string temp = \"\";\n    int cur = 0;\n    rep(i,(int)s.size()) if( s[i] != ' ' ) {\n      temp += string(1,s[i]);\n    }\n    Parsing par(temp);\n    cout << par.expression() << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\nint const MOD = 1e9+7;\n\nstring line; string::iterator iter;\ninline void debug() { cout << \"Remain: \\\"\" <<string(iter, line.end())<<'\"' << endl; }\n\nvoid consume(char e) {\n  if(*iter == e) { iter++; }\n  else { assert(0); }\n}\n\nbool ifconsume(char e) {\n  if(*iter == e) { consume(e); return 1; }\n  return 0;\n}\n\nbool strcons(string s) {\n  string::iterator is = s.begin();\n  string::iterator tmpiter = iter;\n  \n  while(is!=s.end() &&\n        tmpiter!=line.end() &&\n        *is == *tmpiter) { tmpiter++; is++; }\n\n  if(is == s.end()) {\n    iter = tmpiter;\n    return true;\n  }\n  return false;\n}\n\nll get_num() {\n  ll ret = 0;\n  while(isdigit(*iter)) { ret *= 10; ret += (*iter)-'0'; consume(*iter); }\n  return ret;\n}\n\nll expr();\nll term() {\n  if(isdigit(*iter)) { return get_num(); }\n  else if(ifconsume('S')) {\n    consume('<');\n    ll r = expr(); (r*=r) %= MOD;\n    consume('>');\n    return r;\n  }\n  else {\n    debug();assert(0&&\"term\");\n  }\n}\n\nll expr() {\n  ll t1 = term();\n  while(strcons(\">>\")) {\n    if(*iter != 'S' && !isdigit(*iter)) { iter -= 2; break; }\n    int k = term();\n    while(k--) { t1 >>= 1; if(t1 == 0) break; } // log テ・ツ崢榲」ツ?ァテ」ツ?凖」ツ?ケテ」ツ?ヲテ」ツ?ョテヲツ閉エテヲツ閉ーテ」ツつ津・ツーツステ」ツ?湘」ツ?崚」ツつ凝」ツ?ョテ」ツ?ァテ」ツ??ゥツ?氾、ツクツュテ」ツ?ァ == 0 テ」ツ?ョテヲツ楪敕・ツ按暗」ツつ甘」ツつ津・ツ?・テ」ツつ古」ツつ凝」ツ??」ツ?妥」ツ?ァテゥツ?堙」ツつ凝」ツつ暗」ツ??」ツ?ォテ」ツ?ェテ」ツつ凝」ツ??\n  }\n  return t1;\n}\n\nint main() {\n  for(string s;getline(cin, s);) {\n    if(s == \"#\") break;\n    line.clear();\n    int sz=s.size(); rep(i,sz) if(s[i]!=' ') { line.push_back(s[i]); }\n    iter = line.begin();\n    cout << expr() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<string>\n#include<queue>\ntypedef long long ll;\nusing namespace std;\nll mod = 1000000007;\nll expr(string &s,int a,int b);\nll term(string &s,int a,int b);\nll number(string &s,int a,int b);\n\n\nll calc(string &s,int &t){\n    ll ans;\n    bool flag =0;\n    while(1){\n        if(s[t]=='>'||s[t]=='$'){\n            t++;\n            break;\n        }\n        if(s[t]>='0'&&s[t]<='9'){\n            ll tmp = 0;\n            while(s[t]>='0'&&s[t]<='9'){\n                tmp *=10;\n                tmp +=(ll)(s[t]-'0');\n                t++;\n            }\n            if(!flag){\n                ans = tmp;\n                flag = 1;\n            }else{\n                if(tmp>=30)ans= 0;\n                else for(int i=0;i<tmp;i++){\n                    ans/=2;\n                }\n            }\n        }\n        if(s[t]=='p'){\n            t++;\n        }\n        if(s[t]=='S'){\n            t += 2;\n            ll tmp = calc(s,t);\n            tmp = tmp*tmp%mod;\n            if(!flag){\n                ans = tmp;\n                flag = 1;\n            }else{\n                if(tmp>=30)ans= 0;\n                else for(int i=0;i<tmp;i++){\n                    ans/=2;\n                }\n            }\n        }\n    }\n    return ans;\n}\n\n\nint main(){\n    while(1){\n        string s1,s;\n        getline(cin,s1);\n        if(s1[0]=='#')break;\n        for(int i=0;i<s1.size();i++){\n            if(s1[i]!=' '){\n                s.push_back(s1[i]);\n            }\n        }\n        vector<bool> p((int)s.size());\n        for(int i=0;i<s.size();i++){\n            if(s[i]!='<'&&s[i]!='>'){\n                if(i==0)continue;\n                if(s[i-1]=='>'){\n                    p[i-1]=1;\n                    p[i-2]= 1;\n                }\n            }\n        }\n        string ss;\n        int tmp = 0;\n        while(tmp<(int)s.size()){\n            if(p[tmp]){\n                ss.push_back('p');\n                tmp+=2;\n            }else{\n                ss.push_back(s[tmp]);\n                tmp++;\n            }\n        }\n        ss.push_back('$');\n        int cnt = 0;\n        cout << calc(ss,cnt) << endl; \n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar s[2100000], t[2100000];\nint len;\n\nlong long calc(int &en)\n{\n    if (t[en] == '>'){\n        en--;\n        long long l = calc(en);\n        l = (l * l) % 1000000007;\n        en -= 2;\n        if (en < 0 || t[en] == '<') return (l);\n        en -= 2;\n        return (calc(en) >> l);\n    }\n    else {\n        long long l = 0, b = 1;\n        while (isdigit(t[en])){\n            l = l + (t[en--] - '0') * b;\n            b *= 10;\n        }\n        \n        if (en < 0 || t[en] == '<') return (l);\n        en -= 2;\n        \n        long long l2 = calc(en);\n        while (l-- && l2){\n            l2 /= 2;\n        }\n        \n        return (l2);\n    }\n}\n\nint main()\n{\n    while (fgets(s, sizeof(s), stdin) && s[0] != '#'){\n        len = 0;\n        for (int i = 0; s[i]; i++){\n            if (s[i] != ' ' && s[i] != '\\n') t[len++] = s[i];\n        }\n        \n        --len;\n        printf(\"%lld\\n\", calc(len));\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\null term(string& e, int& idx);\null expr(string& e, int& idx);\n\null number(string& e, int& idx) {\n    ull number = 0;\n    for (; idx < e.size(); idx++) {\n        if (!isdigit(e[idx])) {\n            break;\n        }\n        number *= 10;\n        number += e[idx] - '0';\n    }\n    LOG(\"--> number %d\\n\", number);\n    return number;\n}\n\null term(string& e, int& idx) {\n    switch (e[idx]) {\n    case '(': {\n        idx++; // (\n        ull n = expr(e, idx);\n        ull val = (n * n) % 1000000007;\n        LOG(\"--> pow %d = %d\\n\", n, val);\n        idx++; // )\n        return val;\n    }\n    default:\n        return number(e, idx);\n    }\n    assert(0);\n}\n\null expr(string& e, int& idx) {\n    ull val = term(e, idx);\n    for (; idx < e.size(); idx++) {\n        switch (e[idx]) {\n        case '>': {\n            idx++;\n            ull n = term(e, idx);\n            LOG(\"--> shift %d %d = \", val, n);\n            for (int i = n; i > 0; i--) {\n                val >>= 1;\n            }\n            LOG(\"%d\\n\", val);\n            idx--;\n            break;\n        }\n        case ')':\n            return val;\n        }\n    }\n    return val;\n}\n\nint main() {\n    string s;\n    while (getline(cin, s), s != \"#\") {\n        stringstream ss;\n        REP(i, s.size()) {\n            if (s[i] != ' ') {\n                ss << s[i];\n            }\n        }\n        s = ss.str();\n        stringstream ss2;\n        REP(i, s.size()) {\n            switch (s[i]) {\n            case 'S':\n                i++;\n                ss2 << '(';\n                break;\n            case '>':\n                if (i+2 < s.size() && (isdigit(s[i+2]) || s[i+2] == 'S')) {\n                    ss2 << '>';\n                    i += 1;\n                } else {\n                    ss2 << ')';\n                }\n                break;\n            case ' ':\n                break;\n            default:\n                ss2 << s[i];\n            }\n        }\n\n        string e = ss2.str();\n        LOG(\"%s\\n\", e.c_str());\n\n        int idx = 0;\n        cout << expr(e, idx) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,ll> P;\n  \nstatic const double EPS = 1e-8;\nstatic const ll MOD = 1000000007;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nP expr(int pos,const string& str);\nP term(int pos,const string& str);\nP number(int pos,const string& str);\n\nP expr(int pos,const string& str){\n  P p1 = term(pos,str);\n  pos = p1.first;\n\n  while(pos + 2 < str.size() \n        && str[pos] == '>'\n        && str[pos+1] == '>'\n        && isdigit(str[pos+2])){\n    while(str[pos] == '>') pos++; //for '>'\n    P p2 = term(pos,str);\n    p1.second >>= min(p2.second,63LL);\n    pos = p2.first;\n  }\n  return P(pos,p1.second);\n}\n\nP term(int pos,const string& str){\n  if(str[pos] == 'S'){\n    pos+=2; // for \"S<\"\n    P p1 = expr(pos,str);\n    pos = p1.first;\n    pos++; // for \">\"\n    return P(pos,((p1.second % MOD) * (p1.second % MOD)) % MOD);\n  }\n  \n  else{\n    return number(pos,str);\n  }\n}\n\nP number(int pos,const string& str){\n  \n  string tmp = \"0\";\n  while(pos < str.size() && isdigit(str[pos])){\n    tmp.push_back(str[pos]);\n    pos++;\n  }\n  return P(pos,atol(tmp.c_str()));\n}\n\nint main(){\n  string str;\n  while(getline(cin,str)){\n    if(str == \"#\") continue;\n\n    string tmp = \"\";\n    for(int i=0;i<str.size();i++){\n      if(str[i] != ' '){\n        tmp.push_back(str[i]);\n      }\n    }\n    str = tmp;\n    P p = expr(0,str);\n    cout << p.second << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint N;\nstring S;\n\nLL expr(int&);\nLL term(int&);\n\nLL expr(int &i){\n  LL res = term(i);\n\n  while(i < N){\n\tif(!(i+1 < N && S[i] == '$' && S[i+1] == '$')) break;\n\ti += 2;\n\tLL t = term(i);\n\twhile(res>0 && t > 0){\n\t  res /= 2;\n\t  --t;\n\t}\n  }\n  return res;\n}\n\nLL term(int& i){\n  LL res = 0;\n  if(isdigit(S[i])){\n\twhile(i < N && isdigit(S[i])){\n\t  res = res * 10 + (S[i] - '0');\n\t  ++i;\n\t}\n\treturn res;\n  }\n\n  assert(S[i] == 'S');\n  ++i;\n  assert(S[i] == '<');\n  ++i;\n  res = expr(i);\n  assert(S[i] == '>');\n  ++i;\n  res %= MOD;\n  res = res * res % MOD;\n\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(getline(cin,S), S != \"#\"){\n\tN = SZ(S);\n\tstring tmp;\n\tREP(i,N) if(S[i] != ' ') tmp += S[i];\n\n\tS = tmp;\n\tN = SZ(S);\n\tFOR(i,2,N){\n\t  if((S[i] == 'S' || isdigit(S[i])) && S[i-1] == '>' && S[i-2] == '>'){\n\t\tS[i-1] = S[i-2] = '$';\n\t  }\n\t}\n\n\tint i = 0;\n\tcout << expr(i) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint MOD=1000000007LL;\nstring s;\nint expr(int &p);\nint term(int &p);\nvoid sp(int &p);\nint number(int &p); \nint expr(int &p){\n  int res=term(p);\n  sp(p);\n  int q=p;\n  while(q+1<(int)s.size()&&s[q]=='>'&&s[q+1]=='>'){\n    q+=2;\n    sp(q);\n    if(q>=(int)s.size()||s[q]=='>') break;\n    p+=2;\n    sp(p);\n    int y=term(p);\n    if(y>31) res=0;\n    else res>>=y;\n    sp(p);\n    q=p;\n  }\n  return res;\n}\nint term(int &p){\n  int res;\n  if(s[p]=='S'){\n    p++;\n    sp(p);\n    assert(s[p]=='<');\n    p++;\n    sp(p);\n    int x=expr(p);\n    sp(p);\n    assert(s[p]=='>');\n    p++;\n    res=(x*x)%MOD;\n  }else{\n    res=number(p);\n  }\n  return res;\n}\nvoid sp(int &p){\n  while(p<(int)s.size()&&s[p]==' ') p++;\n}\nint number(int &p){\n  int res=0;\n  while(p<(int)s.size()&&isdigit(s[p]))\n    res=(res*10+s[p++]-'0')%MOD;\n  return res;\n}\nsigned main(){\n  while(getline(cin,s),s!=\"#\"){\n    int p=0;\n    cout<<expr(p)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n\ntypedef long long lint;\ntypedef pair<int, int> pii;\n\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\nconst lint MOD = 1e9 + 7;\n\nstring S;\n\nvector<string> split_str(string _s, string _t) {\n\tvector<string> res;\n\tfor (int p = 0; (p = _s.find(_t)) != -1;) {\n\t\tres.push_back(_s.substr(0, p));\n\t\t_s = _s.substr(p + size_of(_t));\n\t}\n\tres.push_back(_s);\n\treturn res;\n}\n\nlint parse(int left, int right, int depth=25000) {\n\t//cout << left << \" \" << right << endl;\n\t//if (left > right) return -1;\n\t\n\tint lcnt = 0, rcnt = 0;\n\tint n_left = -1;\n\tqueue<lint> q;\n\tbool d_flag = false;\n\tint d_pos = -1;\n\tif (depth < 0) {\n\t\treturn MOD;\n\t}\n\tfor_(i,left,right) {\n\t\tif (S[i] == '<') {\n\t\t\tif (lcnt == 0) n_left = i + 1;\n\t\t\tlcnt++;\n\t\t}\n\t\tif (S[i] == '>') {\n\t\t\trcnt++;\n\t\t}\n\t\t\n\t\tif ((S[i] == '<' || S[i] == '|') && d_flag) {\n\t\t\tstring ress = S.substr(d_pos, i - d_pos);\n\t\t\tstringstream ss(ress);\n\t\t\tlint res; ss >> res;\n\t\t\tq.push(res);\n\t\t\td_flag = false;\n\t\t}\n\t\t\n\t\tif (!d_flag && lcnt == 0 && isdigit(S[i])) {\n\t\t\td_pos = i;\n\t\t\td_flag = true;\n\t\t}\n\t\t\n\t\tif (lcnt > 0 && rcnt > 0 && lcnt == rcnt) {\n\t\t\tlint res = parse(n_left, i, depth-1);\n\t\t\t/*\n\t\t\tif (res == -1) {\n\t\t\t\tlcnt = rcnt = 0;\n\t\t\t\tcontinue;\n\t\t\t}*/\n\t\t\tres *= res;\n\t\t\tres %= MOD;\n\t\t\tq.push(res);\n\t\t\tlcnt = rcnt = 0;\n\t\t}\n\t}\n\t\n\tif (d_flag) {\n\t\tstring ress = S.substr(d_pos, right - d_pos);\n\t\tstringstream ss(ress);\n\t\tlint res; ss >> res;\n\t\tq.push(res);\n\t}\n\t\n\tlint res = q.front(); q.pop();\n\twhile (!q.empty()) {\n\t\tlint d = q.front(); q.pop();\n\t\twhile (d > 0 && res > 0) {\n\t\t\tres /= 2;\n\t\t\td--;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nvoid solve() {\n\tint n = size_of(S);\n\tint i = 0;\n\twhile (i < size_of(S)) {\n\t\tif (i > 2 && (S[i] == 'S' || isdigit(S[i]))) {\n\t\t\tif (S[i - 1] == '>' && S[i - 2] == '>') {\n\t\t\t\tS = S.substr(0, i - 2) + \"|\" + S.substr(i);\n\t\t\t\ti = i - 2;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tcout << S << endl;\n\tn = size_of(S);\n\tcout << parse(0, n) << endl;\n}\n\nint main() {\n\tstring input;\n\twhile (getline(cin, input)) {\n\t\tif (input[0] == '#') break;\n\t\tvector< string > split = split_str(input, \" \");\n\t\tint v_size = size_of(split);\n\t\tS = \"\";\n\t\tfor_(i,0,v_size) S += split[i];\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nstring s;\nint p;\nint bns();\nint g_A(){\n  int a=0;\n  if(s[p]=='S'){\n    p+=2;\n    a=bns();\n    a=a*a%1000000007;\n    p++;\n  }\n  else if(isdigit(s[p])){\n    while(isdigit(s[p])){\n      a=a*10+(s[p]-'0');\n      p++;\n    }\n  }\n  return a;\n}\nint bns(){\n  int a=g_A();\n  while(s[p]=='>'&&s[p+1]=='>'&&(isdigit(s[p+2])||s[p+2]=='S')){\n    p+=2;\n    int b=g_A();\n    a>>=min(b,63LL);\n  }\n  return a;\n}\nmain(){\n  while(getline(cin,s),s[0]!='#'){\n    p=0;\n    s.erase(remove(s.begin(),s.end(),' '),s.end());\n    cout<<bns()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n \ntypedef long long LL;\n \n#define MOD 1000000007LL\n \nLL expr();\nLL term();\n \nconst char *P;\n \nLL expr(){\n    LL x = term();\n    while(*P == '>' && P[1] == '>' && (P[2] == 'S' || isdigit(P[2]))){\n        P += 2;\n        LL y = term();\n        x >>= min(y, 63LL);\n    }\n    return x;\n}\n \nLL term(){\n    LL x = 0;\n    if(*P == 'S'){\n        P += 2;\n        x = expr();\n        x = x * x % MOD;\n        ++P;\n    }\n    else{\n        char *endp;\n        x = strtoll(P, &endp, 10);\n        P = endp;\n    }\n    return x;\n}\n \nint main(){\n    string s;\n    while(getline(cin, s), s[0] != '#'){\n        s.erase(remove(s.begin(), s.end(), ' '), s.end());\n        P = s.c_str();\n        cout << expr() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n\ntypedef long long lint;\ntypedef pair<int, int> pii;\n\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\nconst lint MOD = 1e9 + 7;\n\nstring S;\n\nvector<string> split_str(string _s, string _t) {\n\tvector<string> res;\n\tfor (int p = 0; (p = _s.find(_t)) != -1;) {\n\t\tres.push_back(_s.substr(0, p));\n\t\t_s = _s.substr(p + size_of(_t));\n\t}\n\tres.push_back(_s);\n\treturn res;\n}\n\nlint parse(int left, int right) {\n\t//cout << left << \" \" << right << endl;\n\tif (left > right) return -1;\n\t\n\tint lcnt = 0, rcnt = 0;\n\tint n_left = -1;\n\tqueue<lint> q;\n\tbool d_flag = false;\n\tint d_pos = -1;\n\t\n\tfor_(i,left,right) {\n\t\tif (S[i] == '<') {\n\t\t\tif (lcnt == 0) n_left = i + 1;\n\t\t\tlcnt++;\n\t\t}\n\t\tif (S[i] == '>') {\n\t\t\trcnt++;\n\t\t}\n\t\t\n\t\tif ((S[i] == '<' || S[i] == '|') && d_flag) {\n\t\t\tstring ress = S.substr(d_pos, i - d_pos);\n\t\t\tstringstream ss(ress);\n\t\t\tlint res; ss >> res;\n\t\t\tq.push(res);\n\t\t\td_flag = false;\n\t\t}\n\t\t\t\n\t\tif (!d_flag && lcnt == 0 && isdigit(S[i])) {\n\t\t\td_pos = i;\n\t\t\td_flag = true;\n\t\t}\n\t\t\n\t\tif (lcnt > 0 && rcnt > 0 && lcnt == rcnt) {\n\t\t\tlint res = parse(n_left, i);\n\t\t\tif (res == -1) {\n\t\t\t\tlcnt = rcnt = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres *= res;\n\t\t\tres %= MOD;\n\t\t\tq.push(res);\n\t\t\tlcnt = rcnt = 0;\n\t\t}\n\t}\n\t\n\tif (d_flag) {\n\t\tstring ress = S.substr(d_pos, right - d_pos);\n\t\tstringstream ss(ress);\n\t\tlint res; ss >> res;\n\t\tq.push(res);\n\t}\n\t\n\tlint res = q.front(); q.pop();\n\twhile (!q.empty()) {\n\t\tlint d = q.front(); q.pop();\n\t\twhile (d > 0 && res > 0) {\n\t\t\tres /= 2;\n\t\t\td--;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nvoid solve() {\n\tint n = size_of(S);\n\tint i = 0;\n\twhile (i < size_of(S)) {\n\t\tif (i > 2 && (S[i] == 'S' || isdigit(S[i]))) {\n\t\t\tif (S[i - 1] == '>' && S[i - 2] == '>') {\n\t\t\t\tS = S.substr(0, i - 2) + \"|\" + S.substr(i);\n\t\t\t\ti = i - 2;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\t//cout << S << endl;\n\tn = size_of(S);\n\tcout << parse(0, n) << endl;\n}\n\nint main() {\n\tstring input;\n\twhile (getline(cin, input)) {\n\t\tif (input[0] == '#') break;\n\t\tvector< string > split = split_str(input, \" \");\n\t\tint v_size = size_of(split);\n\t\tS = \"\";\n\t\tfor_(i,0,v_size) S += split[i];\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld eps = 1e-9;\n\nusing State = string::const_iterator;\n\nll number(State &begin) {\n    ll num = 0, tmp = 1;\n    while ('0' <= *begin and *begin <= '9') {\n        (num += (*begin - '0') * tmp) %= MOD;\n        (tmp *= 10) %= MOD;\n        ++begin;\n    }\n    return num;\n}\n\nll expression(State& begin);\n\nll term(State &begin) {\n    if (*begin == '>') {\n        ++begin;\n        ll exp = expression(begin);\n        assert(*begin == '<');\n        ++begin;\n        assert(*begin == 'S');\n        ++begin;\n        return (exp * exp) % MOD;\n    }\n    assert('0' <= *begin and *begin <= '9');\n    return number(begin);\n}\n\nll expression(State& begin) {\n    vll result;\n    result.push_back(term(begin));\n    while (*begin == '>') {\n        ++begin;\n        assert(*begin == '>');\n        ++begin;\n        result.push_back(term(begin));\n    }\n    reverse(all(result));\n    ll ret = result[0];\n    REP(i, SZ(result)-1) {\n        ret >>= min(result[i+1], 60LL);\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    for (;;) {\n        string s; getline(cin, s);\n        if (s == \"#\") break;\n\n        string t;\n        for (char c : s) {\n            if (c != ' ') t += c;\n        }\n\n        reverse(all(t));\n        State begin = t.begin();\n        ll ans = expression(begin);\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing ll = long long;\nconstexpr ll MOD = (1e9) + 7;\n\nclass Parser {\n  private:\n    std::string s;\n    std::string::const_iterator it;\n    \n  public:\n    Parser (std::string s) {\n        this->s = s;\n        it = s.begin();\n    }\n\n    ll number()\n    {\n        ll res = 0;\n        while (isdigit(*it)) {\n            res *= 10;\n            res += *it - '0';\n            ++it;\n        }\n        return res;\n    }\n    \n    ll term()\n    {\n        ll res = 0;\n        if (isdigit(*it)) {\n            res = number();\n        } else if (*it == 'S') {\n            it += 2; // S <            \n            res = expr() % MOD;            \n            res = (res * res) % MOD;\n            ++it; // >\n        }\n        return res;\n    }\n\n    bool is_term(char ch)\n    {\n        return (isdigit(ch) || ch == 'S');\n    }\n\n    ll mod_pow(ll x, ll n, ll mod)\n    {\n        if (n == 0) {\n            return 1;\n        }\n        ll res = mod_pow(x * x % mod, n / 2, mod);\n        if (n & 1) {\n            res = res * x % mod;\n        }\n        return res;\n    }\n\n    void shift(ll &x, ll y)\n    {\n        for (ll i = 0; i < y; i++) {\n            if (x == 0) {\n                return;\n            }\n            x >>= 1;\n        }\n    }\n    \n    ll expr()\n    {\n        ll res = term();\n        while (*it == '>' && *(it + 1) == '>' && is_term(*(it + 2))) {\n            it += 2;\n            shift(res, term());            \n            res %= MOD;\n        }\n        return res;\n    }\n};\n\nstd::string remove_spaces(const std::string &s)\n{\n    std::string res;\n    for (char c : s) {\n        if (c != ' ') {\n            res += c;\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    std::string s;\n    while (1) {\n        std::getline(std::cin, s);\n        if (s == \"#\") {\n            break;\n        }\n        s = remove_spaces(s);\n        \n        Parser p{s};\n        std::cout << p.expr() << std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\nint const MOD = 1e9+7;\n\nstring line; string::iterator iter;\ninline void debug() { cout << \"Remain: \\\"\" <<string(iter, line.end())<<'\"' << endl; }\n\nvoid consume(char e) {\n  if(*iter == e) { iter++; }\n  else { assert(0); }\n}\n\nbool ifconsume(char e) {\n  if(*iter == e) { consume(e); return 1; }\n  return 0;\n}\n\nbool strcons(string s) {\n  string::iterator is = s.begin();\n  string::iterator tmpiter = iter;\n  \n  while(is!=s.end() &&\n        tmpiter!=line.end() &&\n        *is == *tmpiter) { tmpiter++; is++; }\n\n  if(is == s.end()) {\n    iter = tmpiter;\n    return true;\n  }\n  return false;\n}\n\nll get_num() {\n  ll ret = 0;\n  while(isdigit(*iter)) { ret *= 10; ret += (*iter)-'0'; consume(*iter); }\n  return ret;\n}\n\nll expr();\nll term() {\n  if(isdigit(*iter)) { return get_num(); }\n  else if(ifconsume('S')) {\n    consume('<');\n    ll r = expr(); (r*=r) %= MOD;\n    consume('>');\n    return r;\n  }\n  else {\n    debug();assert(0&&\"term\");\n  }\n}\n\nll expr() {\n  ll t1 = term();\n  while(strcons(\">>\")) {\n    if(*iter != 'S' && !isdigit(*iter)) { iter -= 2; break; }\n    int k = term();\n    while(k--) { t1 >>= 1; if(t1 == 0) break; }\n  }\n  return t1;\n}\n\nint main() {\n  for(string s;getline(cin, s);) {\n    if(s == \"#\") break;\n    line.clear();\n    int sz=s.size(); rep(i,sz) if(s[i]!=' ') { line.push_back(s[i]); }\n    iter = line.begin();\n    cout << expr() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntypedef string::const_iterator State;\nclass ParseError {};\nvoid sp(State&);\nint expr(State&);\nint term(State&);\nint number(State&);\n\nstring s;\nint expr(State &begin) {\n\tint ret = term(begin);\n\twhile(1) {\n\t\t//cout << *begin << \" \" << begin-s.begin() << \" \" << ret << endl;\n\t\tif(*begin == '>' && *(begin+1) == '>' && *(begin+2) != '>') {\n\t\t\tbegin++; // >\n\t\t\tbegin++; // >\n\t\t\tint y = term(begin);\n\t\t\tret >>= min(y, (ll)31);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t//cout << \"expr:\" << ret << endl;\n\treturn ret;\n}\n\nint term(State &begin) {\n\tif(*begin == 'S') {\n\t\tbegin++;\n\t\tbegin++;\n\t\t//cout << \"s \" << *begin << \" \" << begin-s.begin() << endl;\n\t\tint ret = expr(begin);\n\t\tret = (ret*ret) % MOD;\n\t\tbegin++;\n\t\t//cout << \"te:\" << ret << endl;\n\t\treturn ret;\n\t} else {\n\t\t//cout << \"tn:\" << *begin << \" \" << begin - s.begin() << endl;\n\t\tint ret = number(begin);\n\t\t//cout << \"tenum:\" << ret << endl;\n\t\treturn ret;\n\t}\n}\n\nint number(State &begin) {\n\tint ret = 0;\n\twhile(isdigit(*begin)) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nsigned main(void)\n{\n\twhile(true) {\n\t\tstring t;\n\t\tgetline(cin, t);\n\t\tif(t == \"#\") break;\n\n\t\ts = \"\";\n\t\tREP(i, t.size()) if(t[i] != ' ') s += t[i];\n\t\t//cout << s << endl;\n\t\tState begin = s.begin();\n\t\tcout << expr(begin) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ntypedef long long ll;\n#define pb push_back\n#define rep(i,j) for(int i=0;i<j;i++)\n\n\nint l, r;\nstring s;\nstring elim_sp(string str){\n\tstring res = \"\";\n\trep(i,str.length()){\n\t\tif(str[i] != ' ')res += str[i];\n\t}\n\treturn res;\n}\nll st(ll val, ll shift){\n\tif(shift > 31) return 0;\n\telse return val >> shift;\n}\n\nll eval(){\n//\tcout << l << \", \" << r << endl;\n//\tcout << s[l] << \", \" << s[r] << endl;\n\tif(s[l] == 'S'){\n\t\tl+=2;\n\t\tvector<ll> v;\n\t\twhile(s[r] >= '0' && s[r] <= '9'){\n\t\t\tll val = 0, dig = 1;\n\t\t\tfor(;s[r] >= '0' && s[r] <= '9';r--){\n\t\t\t\tval += dig * (s[r] - '0');\n\t\t\t\tdig *= 10;\n\t\t\t}\n\t\t\tr -= 2;\n\t\t\tv.pb(val);\n//\t\t\tcout << \"val : \" << val << endl;\n\t\t}\n\t\tr--;\n\t\tll val = eval();\n\t\tval = (val * val) % 1000000007;\n//\t\tcout << \"S<> val : \" << val << endl;\n\n\t\trep(i, v.size()){\n\t\t\tval = st(val, v[i]);\n\t\t}\n//\t\tcout << \"shift \";\n//\t\trep(i, v.size()) cout << v[i] << \", \"; cout << endl;\n\n//\t\tcout << \" >> val : \" << val << endl;\n\t\treturn val;\n\t}else{\n\t\tstd::vector<ll> v;\n\t\twhile(l <= r && s[l] >= '0' && s[l] <= '9'){\n\t\t\tll tmp = 0;\n\t\t\tfor(;s[l] >= '0' && s[l] <= '9'; l++){\n\t\t\t\ttmp = tmp * 10 + s[l] - '0';\n\t\t\t}\n\t\t\tv.pb(tmp);\n\t\t\tl += 2;\n\t\t}\n//\t\trep(i, v.size()-1) cout << v[i+1] << \", \"; cout << endl;\n\n\t\tll val = v[0];\n\t\trep(i, v.size()-1){\n\t\t\tval = st(val, v[i+1]);\n\t\t}\n//\t\tcout << \" >> val : \" << val << endl;\n\t\treturn val;\n\t}\n}\n\nll sq(ll v) { return v * v; }\nint main(){\n\tstring str;\n\twhile(getline(cin, str), str[0] != '#'){\n\t\ts = elim_sp(str);\n\t\tl = 0;\n\t\tr = s.length() - 1;\n\t\tll res = eval();\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar s[2100000], t[2100000];\nint len;\n\nlong long calc(int &en)\n{\n    if (t[en] == '>'){\n        en--;\n        long long l = calc(en);\n        l = (l * l) % 1000000007;\n        en -= 2;\n        if (en < 0 || t[en] == '<') return (l);\n        en -= 2;\n        \n        long long l2 = calc(en);\n        while (l-- && l2){\n            l2 /= 2;\n        }\n        return (l2);\n    }\n    else {\n        long long l = 0, b = 1;\n        while (isdigit(t[en])){\n            l = l + (t[en--] - '0') * b;\n            b *= 10;\n        }\n        \n        if (en < 0 || t[en] == '<') return (l);\n        en -= 2;\n        \n        long long l2 = calc(en);\n        while (l-- && l2){\n            l2 /= 2;\n        }\n        \n        return (l2);\n    }\n}\n\nint main()\n{\n    while (fgets(s, sizeof(s), stdin) && s[0] != '#'){\n        len = 0;\n        for (int i = 0; s[i]; i++){\n            if (s[i] != ' ' && s[i] != '\\n') t[len++] = s[i];\n        }\n        \n        --len;\n        printf(\"%lld\\n\", calc(len));\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cctype>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <deque>\n\nvoid preprocess(const std::string &s, std::string &t) {\n  std::string u;\n  for (char ch: s)\n    if (!isspace(ch)) u += ch;\n\n  for (size_t i=0; i<u.length(); ++i) {\n    if (u[i] == 'S') {\n      ++i;\n      assert(u[i] == '<');\n      t += '(';\n    } else if (isdigit(u[i])) {\n      t += u[i];\n    } else if (u[i] == '>') {\n      if (i+2 < u.length() && u[i+1] == '>' && isdigit(u[i+2])) {\n        t += '>';\n        t += u[i+=2];\n      } else {\n        t += ')';\n      }\n    } else {\n      assert(false);\n    }\n  }\n  fprintf(stderr, \"t: %s\\n\", t.c_str());\n}\n\nconst intmax_t MOD=1e9+7;\n\nintmax_t parse(const std::string &s, size_t &i, size_t preced=0) {\n  if (preced == 1) {\n    if (s[i] == '(') {\n      intmax_t res=parse(s, ++i, 0);\n      assert(s[i] == ')');\n      ++i;\n      return res*res%MOD;\n    } else if (isdigit(s[i])) {\n      intmax_t res=s[i]-'0';\n      while (++i < s.length() && isdigit(s[i]))\n        res = res*10+s[i]-'0';\n      return res;\n    }\n    assert(false);\n  }\n  intmax_t lhs=parse(s, i, preced+1);\n  while (i < s.length()) {\n    char op=s[i];\n    if (op != '>') break;\n    intmax_t rhs=parse(s, ++i, preced+1);\n    (rhs<63? lhs>>=rhs:lhs=0);\n  }\n  return lhs;\n}\n\nint testcase_ends() {\n  char buf[2000010];\n  fgets(buf, sizeof buf, stdin);\n  std::string s=std::move(buf), t;\n  if (s == \"#\\n\") return 1;\n\n  preprocess(s, t);\n  size_t i=0;\n  printf(\"%jd\\n\", parse(t, i));\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cctype>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <deque>\n\nvoid preprocess(const std::string &s, std::string &t) {\n  std::string u;\n  for (char ch: s)\n    if (!isspace(ch)) u += ch;\n\n  t.clear();\n  for (size_t i=0; i<u.length(); ++i) {\n    if (u[i] == 'S') {\n      ++i;\n      assert(u[i] == '<');\n      t += '(';\n    } else if (isdigit(u[i])) {\n      t += u[i];\n    } else if (u[i] == '>') {\n      if (i+2 < u.length() && u[i+1] == '>') {\n        if (isdigit(u[i+2])) {\n          t += '>';\n          t += u[i+=2];\n        } else if (u[i+2] == 'S') {\n          t += '>';\n          ++i;\n        } else {\n          t += ')';\n        }\n      } else {\n        t += ')';\n      }\n    } else {\n      assert(false);\n    }\n  }\n}\n\nconst intmax_t MOD=1e9+7;\n\nintmax_t parse(const std::string &s, size_t &i, size_t preced=0) {\n  if (preced == 1) {\n    if (s[i] == '(') {\n      intmax_t res=parse(s, ++i, 0);\n      assert(s[i] == ')');\n      ++i;\n      return res*res%MOD;\n    } else if (isdigit(s[i])) {\n      intmax_t res=s[i]-'0';\n      while (++i < s.length() && isdigit(s[i]))\n        res = res*10+s[i]-'0';\n      return res;\n    }\n    assert(false);\n  }\n  intmax_t lhs=parse(s, i, preced+1);\n  while (i < s.length()) {\n    char op=s[i];\n    if (op != '>') break;\n    intmax_t rhs=parse(s, ++i, preced+1);\n    (rhs<63? lhs>>=rhs:lhs=0);\n  }\n  return lhs;\n}\n\nint testcase_ends() {\n  char buf[2000010];\n  fgets(buf, sizeof buf, stdin);\n  std::string s=std::move(buf), t;\n  if (s == \"#\\n\") return 1;\n\n  preprocess(s, t);\n  size_t i=0;\n  printf(\"%jd\\n\", parse(t, i));\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\n\ntypedef long long ll;\n\nstring f1(string a){\n  ll x=(ll)atoi(a.c_str());\n  x=(x*x)%mod;\n  ostringstream os;\n  os<<x;\n  return os.str();\n}\n\nstring f2(string a,string b){\n  ll x=atoi(a.c_str()),y=atoi(b.c_str()),c=1;\n  for(int i=0;i<y;i++){\n    c*=2;\n    if(x<c)return \"0\";\n  }\n  x=x/c;\n  ostringstream os;\n  os<<x;\n  return os.str();\n}\n\nstring rec(vector<string> a){\n  for(int i=0;i<a.size();i++){\n    if(a[i]==\"S<\"){\n      int l=1,r=0;\n      vector<string> b;\n      for(int j=i+1;j<a.size();j++){\n\tif(a[j]==\"S<\")l++;\n\tif(a[j]==\">\")r++;\n\tif(l==r){\n\t  a[j-1]=rec(b);\n\t  i=j-1;\n\t  break;\n\t}\n        b.push_back(a[j]);\n      }\n    }\n    else if(a[i]==\">>\"){\n      if(a[i+1]==\"S<\"){\n\tint l=0,r=0;\n\tvector<string> b;\n\tfor(int j=i+1;j<a.size();j++){\n\t  b.push_back(a[j]);\n\t  if(a[j]==\"S<\")l++;\n\t  if(a[j]==\">\")r++;\n\t  if(l==r){\n\t    a[j]=f2(a[i-1],rec(b));\n\t    i=j;\n\t    break;\n\t  }\n\t}\n      }\n      else a[i+1]=f2(a[i-1],a[i+1]);\n    }\n    else if(a[i]==\">\")a[i]=f1(a[i-1]);\n  }\n  return a[a.size()-1];\n}\n\nint main()\n{\n  while(1){\n    string s,t;\n    vector<string> a,b;\n    t=\"\";\n    getline(cin,s);\n    if(s[0]=='#')break;\n    for(int i=0;i<s.length();i++)if(s[i]!=' ')t+=s[i];\n    string tmp=\"\";\n    for(int i=0;i<t.length();i++){\n      if(t[i]=='S'){\n\ta.push_back(\"S<\");\n\ti++;\n      }\n      else if(t[i]=='>'){\n\tif(tmp!=\"\")a.push_back(tmp);\n\ttmp=\"\";\n\ta.push_back(\">\");\n      }\n      else tmp+=t[i];\n      if(i==t.length()-1 && tmp!=\"\")a.push_back(tmp);\n    }\n\n    for(int i=a.size()-1;0<i;i--){\n      if(a[i]!=\">\"){\n\tb.push_back(a[i]);\n\tif(a[i-1]==\">\"){\n\t  i-=2;\n\t  b.push_back(\">>\");\n\t}\n      }\n      else b.push_back(a[i]);\n    }\n    b.push_back(a[0]);\n    reverse(b.begin(),b.end());\n    cout<<rec(b)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nchar first_buf[2000001],buf[2000001];\n\nll POW[30];\nint length;\n\nll recursive(int left,int right){\n\n\tll ret;\n\n\tint depth = 0;\n\tqueue<int> Q;\n\n\tfor(int i = left; i <= right; i++){\n\t\tif(buf[i] == ' ')continue;\n\n\t\tswitch(buf[i]){\n\t\tcase 'S':\n\t\t\t//Do notghin\n\t\t\tbreak;\n\t\tcase '<':\n\t\t\tdepth++;\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tdepth--;\n\t\t\tbreak;\n\t\tcase '@':\n\t\t\tif(depth == 0){\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t\ti++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//Do nothing\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tll tmp;\n\tint pre = 0,tmp_left,tmp_right;\n\n\tif(Q.empty()){\n\t\tint S_loc = -1;\n\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tif(buf[i] == 'S'){\n\t\t\t\tS_loc = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(S_loc == -1){\n\t\t\tret = 0;\n\n\t\t\tfor(int i = left; i <= right; i++){\n\t\t\t\tif(buf[i] == ' ')continue;\n\t\t\t\tret = 10*ret+(buf[i]-'0');\n\t\t\t}\n\n\t\t}else{\n\t\t\tdepth = 0;\n\n\t\t\tfor(int i = S_loc; i <= right; i++){\n\t\t\t\tif(buf[i] == ' ')continue;\n\n\n\t\t\t\tif(buf[i] == '<'){\n\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\ttmp_left = i;\n\t\t\t\t\t}\n\t\t\t\t\tdepth++;\n\t\t\t\t}else if(buf[i] == '>'){\n\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\ttmp_right = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\ttmp = recursive(tmp_left+1,tmp_right-1);\n\n\t\t\tret = (tmp*tmp)%MOD;\n\t\t}\n\n\t}else{\n\n\t\twhile(!Q.empty()){\n\t\t\ttmp_right = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tif(pre == 0){\n\t\t\t\tret = recursive(left,tmp_right-1);\n\t\t\t}else{\n\t\t\t\ttmp = recursive(pre+2,tmp_right-1);\n\t\t\t\tif(tmp >= 30 || POW[tmp] > ret){\n\t\t\t\t\tret = 0;\n\t\t\t\t}else{\n\t\t\t\t\tret /= POW[tmp];\n\t\t\t\t}\n\t\t\t}\n\t\t\tpre = tmp_right;\n\t\t}\n\t\ttmp = recursive(pre+2,right);\n\n\t\tif(tmp >= 30 || POW[tmp] > ret){\n\t\t\tret = 0;\n\t\t}else{\n\t\t\tret /= POW[tmp];\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid func(){\n\n\tlength = 0;\n\tfor(int i = 0; first_buf[i] != '\\0' && first_buf[i] != '\\n'; i++){\n\t\tif(first_buf[i] == ' ')continue;\n\t\tbuf[length++] = first_buf[i];\n\t}\n\n\tbool is_pre_num = false,is_pre_S = false;\n\n\tfor(int i = length-1; i >= 0; i--){\n\t\tif(buf[i] == ' ')continue;\n\n\t\tif(buf[i] == 'S'){\n\t\t\tis_pre_num = false;\n\t\t\tis_pre_S = true;\n\t\t}else if(buf[i] >= '0' && buf[i] <= '9'){\n\t\t\tis_pre_num = true;\n\t\t\tis_pre_S = false;\n\t\t}else if(buf[i] == '<'){\n\t\t\tis_pre_num = false;\n\t\t\tis_pre_S = false;\n\t\t}else if(buf[i] == '>'){\n\t\t\tif(is_pre_num == true || is_pre_S == true){\n\t\t\t\tbuf[i] = '@';\n\t\t\t\tbuf[i-1] = '@';\n\t\t\t\ti--;\n\t\t\t}\n\t\t\tis_pre_num = false;\n\t\t\tis_pre_S = false;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",recursive(0,length-1));\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 30; i++)POW[i] = (ll)pow(2,i);\n\n\twhile(true){\n\t\tfgets(first_buf,2000000,stdin);\n\t\tif(first_buf[0] == '#')break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\ntypedef long long int lli;\nconst lli mod = 1e9+7;\n\nlli read_term(int &p, string &s);\nlli read_expr(int &p, string &s);\n\nlli read_term(int &p, string &s){\n    if(s[p] == 'S'){\n        p += 2;\n        lli ret = read_expr(p, s);\n        p++;\n        return ret*ret %mod;\n    }\n    lli res = 0;\n    while(p<(int)s.length() and '0'<=s[p] and s[p]<='9'){\n        res *= 10;\n        res += s[p]-'0';\n        res %= mod;\n        p++;\n    }\n    return res;\n}\n\nlli read_expr(int &p, string &s){\n    lli res = read_term(p, s);\n    while(p<(int)s.length() and s[p]!='>'){\n        assert(s[p] == '#');\n        p++;\n        lli ret = read_term(p, s);\n        res >>= min(ret, 32LL);\n    }\n    return res;\n}\n\nlli parse(string s){\n    string tmp = \"\";\n    for(char c: s){\n        if(c != ' '){\n            tmp += c;\n        }\n    }\n    s = \"\";\n    bool is_followed_by_num = false;\n    for(int i=tmp.length()-1; i>=0; i--){\n        if(tmp[i] == '>' and is_followed_by_num){\n            s += '#';\n            i--;\n            is_followed_by_num = false;\n        }else{\n            s += tmp[i];\n            if(('0'<=tmp[i] and tmp[i]<='9') or tmp[i]=='S'){\n                is_followed_by_num = true;\n            }\n        }\n    }\n    reverse(s.begin(), s.end());\n    //cerr << s << endl;\n    int p = 0;\n    return read_expr(p, s);\n}\n\nint main(){\n    while(1){\n        string s;\n        getline(cin, s);\n        if(s == \"#\") break;\n        cout << parse(s) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint MOD=1000000007LL;\nstring s;\nint expr(int &p);\nint term(int &p);\nvoid sp(int &p);\nint number(int &p); \nint expr(int &p){\n  int res=term(p);\n  sp(p);\n  int q=p;\n  while(q+1<(int)s.size()&&s[q]=='>'&&s[q+1]=='>'){\n    q+=2;\n    sp(q);\n    if(q>=(int)s.size()||!isdigit(s[q])) break;\n    p+=2;\n    sp(p);\n    int y=term(p);\n    if(y>31) res=0;\n    else res>>=y;\n    sp(p);\n    q=p;\n  }\n  return res;\n}\nint term(int &p){\n  int res;\n  if(s[p]=='S'){\n    p++;\n    sp(p);\n    assert(s[p]=='<');\n    p++;\n    sp(p);\n    int x=expr(p);\n    sp(p);\n    assert(s[p]=='>');\n    p++;\n    res=(x*x)%MOD;\n  }else{\n    res=number(p);\n  }\n  return res;\n}\nvoid sp(int &p){\n  while(p<(int)s.size()&&s[p]==' ') p++;\n}\nint number(int &p){\n  int res=0;\n  while(p<(int)s.size()&&isdigit(s[p]))\n    res=(res*10+s[p++]-'0')%MOD;\n  return res;\n}\nsigned main(){\n  while(getline(cin,s),s!=\"#\"){\n    int p=0;\n    cout<<expr(p)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\nconst int MOD = (int)1e9 + 7;\n\ntemplate<class T> struct Parser {\n    typedef string::const_iterator State;\n    State end;\n\n    T solve(const string &S) {\n        State begin = S.begin();\n        end = S.end();\n        return expr(begin);\n    }\n\n    // expr ::= term | expr \">>\" term\n    // expr ::= term { \">>\" term }\n    T expr(State &begin) {\n        T ret = term(begin);\n        while (end - begin >= 2) {\n            if (*begin == '>' && *(begin + 1) == '>' && *(begin + 2) != '>') {\n                begin += 2;\n                ret = ret >> min(term(begin), 31);\n            } else {\n                break;\n            }\n        }\n        return ret;\n    }\n\n    // term ::= number | \"S\" \"<\" expr \">\"\n    T term(State &begin) {\n        if (*begin == 'S') {\n            begin += 2;\n            T ret = expr(begin);\n            begin++;\n            return 1LL * ret * ret % MOD;\n        } else {\n            return number(begin);\n        }\n    }\n\n    // number ::= digit | number digit\n    // digit  ::= \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\"\n    T number(State &begin) {\n        T ret = 0;\n        while (isdigit(*begin)) {\n            ret *= 10;\n            ret += *begin - '0';\n            begin++;\n        }\n        return ret;\n    }\n};\n\nint main() {\n    Parser<int> ps;\n    string tmp;\n    while (getline(cin, tmp) , tmp != \"#\") {\n        string S = \"\";\n        for (auto &it : tmp) if (it != ' ') S += it;\n        cout << ps.solve(S) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing ll = long long;\n\nconst ll MOD = 1000000007;\n\n/*\nexpr   ::= term | expr sp \">>\" sp term\nterm   ::= number | \"S\" sp \"<\" sp expr sp \">\"\nsp     ::= \"\" | sp \" \"\nnumber ::= digit | number digit\ndigit  ::= \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\"\n*/\n\nstring s;\nint it;\n\nint dfs_expr();\nint dfs_term();\nint dfs_sp();\n\nint dfs_expr(){\n\t// printf(\"expr(%d)\\n\",it);\n\tint t = dfs_term();\n\tdfs_sp();\n\tif(it>=1 && s[it]=='>' && s[it-1]=='>'){\n\t\tit-=2;\n\t\tdfs_sp();\n\t\tint e = dfs_expr();\n\t\t// printf(\"expr ret %d = %d>>%d\\n\",t>>e,t,e);\n\t\tif(t>=30)return 0;\n\t\treturn e>>t;\n\t}else{\n\t\t// printf(\"expr ret %d\\n\",t);\n\t\treturn t;\n\t}\n}\nint dfs_term(){\n\t// printf(\"term(%d)\\n\",it);\n\tif(s[it]=='>'){\n\t\tit--;\t// >\n\t\tdfs_sp();\n\t\tint e = dfs_expr();\n\t\tdfs_sp();\n\t\tit--;\t// <\n\t\tdfs_sp();\n\t\tit--;\t// S\n\t\t// printf(\"term ret %d = %d*%d\\n\",(int)(1ll*e*e%MOD),e,e);\n\t\treturn 1ll*e*e%MOD;\n\t}else{\n\t\tint ret = 0;\n\t\tint b = 1;\n\t\twhile(it>=0 && isdigit(s[it])){\n\t\t\tret += (s[it]-'0') * b;\n\t\t\tit--;\n\t\t\tb *= 10;\n\t\t}\n\t\t// printf(\"term ret %d\\n\",ret);\n\t\treturn ret;\n\t}\n}\nint dfs_sp(){\n\twhile(it>=0 && s[it]==' ')it--;\n\treturn 0;\n}\n\nint main(){\n\twhile(true){\n\t\tgetline(cin,s);\n\t\tif(s==\"#\")break;\n\t\tit = s.size() - 1;\n\t\tint ans = dfs_expr();\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\nusing ll = long long;\nconstexpr ll MOD = 1000000007;\nclass SyntaxAnalysis\n{\n    using T = ll;\n\npublic:\n    SyntaxAnalysis(const string& S) : S{S} {}\n    T Expression() { return pos = 0, expression(); }\n\nprivate:\n    static constexpr char PLUS = '+';\n    static constexpr char MINUS = '-';\n    static constexpr char PRODUCT = '%';\n    static constexpr char DIVIDE = '/';\n    static constexpr char BRACE = '<';\n    static T plus(const ll n, const ll k) { return n + k; }\n    static T minus(const ll n, const ll k) { return n - k; }\n    static T product(const ll n, const ll k) { return k >= 64 ? 0LL : n >> k; }\n    static T divide(const ll n, const ll k) { return n / k; }\n    static T brace(const ll n) { return n * n % MOD; }\n    static bool is_digit(const char c) { return '0' <= c and c <= '9'; }\n    static T encode(const char c) { return c - '0'; }\n    ll number()\n    {\n        ll ans = 0;\n        for (; pos < S.size() and is_digit(S[pos]); pos++) { ans = ans * 10LL + encode(S[pos]); }\n        return ans;\n    }\n    ll factor()\n    {\n        if (S[pos] == BRACE) {\n            ll ans = 0;\n            return pos++, ans = brace(expression()), pos++, ans;\n        } else {\n            return number();\n        }\n    }\n    ll term()\n    {\n        ll ans = factor();\n        for (; pos < S.size();) {\n            if (S[pos] == PRODUCT) {\n                pos++, ans = product(ans, factor());\n            } else if (S[pos] == DIVIDE) {\n                pos++, ans = divide(ans, factor());\n            } else {\n                break;\n            }\n        }\n        return ans;\n    }\n    ll expression()\n    {\n        ll ans = term();\n        for (ll f = 0; pos < S.size();) {\n            if (S[pos] == PLUS) {\n                pos++, f = term(), ans = plus(ans, f);\n            } else if (S[pos] == MINUS) {\n                pos++, f = term(), ans = minus(ans, f);\n            } else {\n                break;\n            }\n        }\n        return ans;\n    }\n    int pos = 0;\n    string S;\n};\n\nint main()\n{\n    while (true) {\n        auto input = []() {\n            string s;\n            getline(cin, s);\n            string ans;\n            for (ll i = s.size() - 1, st = 0, v = false; i >= 0; i--) {\n                const char c = s[i];\n                if (isdigit(c)) { ans.push_back(c), v = true; }\n                if (c == '>') {\n                    if (v) {\n                        ans.push_back('%'), v = false, i--;\n                    } else {\n                        ans.push_back('>'), st++;\n                    }\n                }\n                if (c == '<') { ans.push_back('<'), v = true, st--; }\n            }\n            reverse(ans.begin(), ans.end());\n            return ans;\n        };\n        const string S = input();\n        show(S);\n        if (S.empty()) { break; }\n        SyntaxAnalysis sy(S);\n        cout << sy.Expression() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).*begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 150000000;\nconst long long M = 1000000007;\n\n\ntypedef string::const_iterator State;\nint number(State&);\nint term(State&);\nint expression(State&);\n\nstring s;\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    if (*begin == 'S') {\n        begin++; // '('????£???°??????\n        begin++;\n        long long ret = expression(begin);\n        begin++; // ')'????£???°??????\n        return ret * ret % M;\n    } else {\n        return number(begin);\n    }\n    return INF;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    int ret = term(begin);\n\n    for (;begin - s.begin() < s.size() ;) {\n        if (*begin == '>' && *(begin + 1) == '>' && *(begin + 2) != '>'){\n            begin++;\n            begin++;\n            ret = ret >> min(term(begin), 31);\n        } else {\n            return ret;\n        }\n    }\n\n    return ret;\n}\n\ninline void deleteSpace(string &a){\n    size_t pos;\n    while((pos = a.find_first_of(\" \")) != string::npos){\n        a.erase(pos, 1);\n    }\n}\n\nint main(){\n    std::ifstream ifs(\"/Users/noy/Downloads/2570_in1.txt.html\");\n    while(getline(cin,s),s != \"#\"){\n        deleteSpace(s);\n        State tmp = s.begin();\n        cout << expression(tmp) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconstexpr ll M = 1e9+7;\n\nvector<bool> f;\n\nll expr(string const& s, int& p);\nll term(string const& s, int& p);\nvoid sp(string const& s, int& p);\nll number(string const& s, int& p);\n\nll expr(string const& s, int& p) {\n    sp(s, p);\n    ll v1 = term(s, p);\n    sp(s, p);\n    while(p+1 < s.size() && f[p]) {\n        p += 2;\n        sp(s, p);\n        ll v2 = term(s, p);\n        if(v2 > 63) {\n            v1 = 0;\n        } else {\n            v1 >>= v2;\n        }\n        sp(s, p);\n    }\n    return v1;\n}\n\nll term(string const& s, int& p) {\n    sp(s, p);\n    if(s[p] == 'S') {\n        sp(s, ++p);\n        p++; // <\n        sp(s, p);\n        ll v = expr(s, p);\n        sp(s, p);\n        p++; // >\n        v = (v * v) % M;\n        return v;\n    }\n    return number(s, p);\n}\n\nvoid sp(string const& s, int& p) {\n    while(p < s.size() && s[p] == ' ') {\n        p++;\n    }\n}\n\nll number(string const& s, int& p) {\n    int res = 0;\n    while(p < s.size() && isdigit(s[p])) {\n        res *= 10;\n        res += s[p++] - '0';\n    }\n    return res;\n}\n\nint main() {\n    while(true) {\n        string s;\n        getline(cin, s);\n        if(s[0] == '#') {\n            break;\n        }\n        int p = 0;\n        f.assign(s.size(), false);\n        for(int i=s.size()-1; i>=0; --i) {\n            if(isdigit(s[i]) || s[i] == 'S') {\n                if(isdigit(s[i])) {\n                    while(i > 0 && isdigit(s[i])) {\n                        --i;\n                    }\n                } else if(s[i] == 'S') {\n                    i--;\n                }\n                while(i > 0 && s[i] == ' ') {\n                    i--;\n                }\n                if(s[i] == '>') {\n                    i--;\n                    f[i] = true;\n                }\n            }\n        }\n        cout << expr(s, p) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\n\ntypedef long long ll;\n\nstring f1(string a){\n  ll x=(ll)atoi(a.c_str());\n  x=(x*x)%mod;\n  ostringstream os;\n  os<<x;\n  return os.str();\n}\n\nstring f2(string a,string b){\n  ll x=atoi(a.c_str()),y=atoi(b.c_str()),c=1;\n  for(int i=0;i<y;i++){\n    c*=2;\n    if(x<c)return \"0\";\n  }\n  x=x/c;\n  ostringstream os;\n  os<<x;\n  return os.str();\n}\n\nstring rec(vector<string> a){\n  for(int i=0;i<a.size();i++){\n    if(a[i]==\"S<\"){\n      int l=1,r=0;\n      vector<string> b;\n      for(int j=i+1;j<a.size();j++){\n\tif(a[j]==\"S<\")l++;\n\tif(a[j]==\">\")r++;\n\tif(l==r){\n\t  a[j-1]=rec(b);\n\t  i=j-1;\n\t  break;\n\t}\n        b.push_back(a[j]);\n      }\n    }\n    else if(a[i]==\">>\"){\n      a[i+1]=f2(a[i-1],a[i+1]);\n    }\n    else if(a[i]==\">\")a[i]=f1(a[i-1]);\n  }\n  return a[a.size()-1];\n}\n\nint main()\n{\n  while(1){\n    string s,t;\n    vector<string> a,b;\n    t=\"\";\n    getline(cin,s);\n    if(s[0]=='#')break;\n    for(int i=0;i<s.length();i++)if(s[i]!=' ')t+=s[i];\n    string tmp=\"\";\n    for(int i=0;i<t.length();i++){\n      if(t[i]=='S'){\n\ta.push_back(\"S<\");\n\ti++;\n      }\n      else if(t[i]=='>'){\n\tif(tmp!=\"\")a.push_back(tmp);\n\ttmp=\"\";\n\ta.push_back(\">\");\n      }\n      else tmp+=t[i];\n      if(i==t.length()-1 && tmp!=\"\")a.push_back(tmp);\n    }\n    for(int i=a.size()-1;0<i;i--){\n      if(a[i]!=\">\" && a[i]!=\"S<\"){\n\tb.push_back(a[i]);\n\tif(a[i-1]==\">\"){\n\t  i-=2;\n\t  b.push_back(\">>\");\n\t}\n      }\n      else b.push_back(a[i]);\n    }\n    b.push_back(a[0]);\n    reverse(b.begin(),b.end());\n    cout<<rec(b)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n#define int ll\nconst ll MOD = 1e9+7;\ntypedef string::const_iterator state;\n\nstring t;\nint expr(state &end);\n\nll power(ll a,ll b/*,ll mod*/){\n    ll ret=1;\n    if(b>0){\n        ret = power(a,b/2/*,mod*/);\n        if(b%2==0)ret = (ret*ret)/*%mod*/;\n        else ret = (((ret*ret)/*%mod*/)*a)/*%mod*/;\n    }\n    return ret;\n}\n\nint number(state &end){\n    string str=\"\";\n    while(isdigit(*end)){\n        str+=*end;\n        end--;\n    }\n    reverse(all(str));\n    \n    int ret = 0;\n    rep(i,str.size()){\n        ret*=10;\n        ret+=str[i]-'0';\n    }\n    return ret;\n}\n\nint term(state &end){\n    if(*end=='>'){\n        end--;\n        int res = expr(end);\n        end-=2;\n        return (res*res)%MOD;\n    }else if(isdigit(*end)){\n        int res = number(end);\n        return res;\n    }else{\n        throw\"impossible\";\n        return -1;\n    }\n}\n\nint expr(state &end){\n    if(end+1==t.begin())throw \"empty\";\n    \n    vector<int> res;\n    res.pb( term(end) );\n    \n    while(end+1!=t.begin()&&*end!='<'){\n        end-=2;\n        res.pb( term(end) );\n    }\n    \n    reverse(all(res));\n    int tmp = res[0];\n    \n    for(int i=1;i<res.size();i++){\n        rep(j,res[i]){\n            if(tmp==0)break;\n            tmp/=2;\n        }\n    }\n    \n    return tmp;\n}\n\nsigned main(){\n    string s;\n    while(getline(cin,s)&&s!=\"#\"){\n        t = \"\";\n        rep(i,s.size())if(s[i]!=' ')t+=s[i];\n        \n        state st = t.end()-1;\n        int ans;\n        try{\n            ans = expr(st);\n        }catch(char const* e){\n            cout<<\"error\"<<e<<endl;\n            exit(-1);\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <cassert>\n\nusing namespace std;\n\ntypedef unsigned long long LL;\nconst LL MOD = 1000000007LL;\n\nvoid skip(const string &s, int &pos) {\n    while(pos >= 0 && s[pos] == ' ') --pos;\n}\n\nLL number(const string &s, int &pos) {\n    skip(s, pos);\n    LL val = 0;\n    LL ord = 1;\n    while(pos >= 0 && isdigit(s[pos])) {\n        val += ord * (s[pos] - '0');\n        ord *= 10;\n        --pos;\n    }\n    return val;\n}\n\nLL expr(const string &s, int &pos) {\n    skip(s, pos);\n    LL val = 0;\n    if(isdigit(s[pos])) {\n        val = number(s, pos);\n    } else if(s[pos] == '>') {\n        --pos;\n        val = expr(s, pos);\n        val = (val*val) % MOD;\n    } else {\n        cerr << s << ' ' << pos << endl;\n        assert(false);\n    }\n    skip(s, pos);\n    if(pos >= 0) {\n        if(s[pos] == '>' && s[pos-1] == '>') {\n            pos -= 2;\n            const LL lhs = expr(s, pos);\n            if(val > 63) val = 0;\n            else val = lhs >> val;\n        } else if(s[pos] == '<') {\n            --pos;\n        } else {\n            assert(false);\n        }\n    }\n    //cout << val << \"(\" << pos << \")\" << endl;\n    return val;\n}\n\nbool solve() {\n    string str;\n    getline(cin, str);\n    if(str == \"#\") return false;\n\n    int pos = str.size()-1;\n    for(char &c : str) {\n        if(c == 'S') c = ' ';\n    }\n    cout << expr(str, pos) << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n#define ll long long\n\nconst ll MOD = 1000000007;\nusing namespace std;\nstring str;\n\nbool isnum(char c){ return c >= '0' && c <= '9'; }\n\nll tonum(int &idx){\n    int start = idx,size = 0;\n    for(; idx < str.size() && isnum(str[idx]);idx++)size++;\n    idx--;\n    return stoll(str.substr(start, size));\n}\n\npair<ll, int> calc(int idx){\n    ll val = 0;\n    cerr << \"call\" <<  idx << endl;\n    for(;idx < str.size(); idx++){\n        if(str[idx] == 'S'){\n            auto temp = calc(idx+1);\n            val = temp.first;\n            assert(idx < temp.second);\n            idx = temp.second;\n            cerr << \"S\";\n            cerr << val << \" \" << idx << endl;\n        }\n        else if(str[idx] == '>'){\n            cerr << str[idx] << str[idx+1] << str[idx+2] << endl;\n            if(idx < str.size()-2 && str[idx+1] == '>' && str[idx+2] != '>'){\n                if(isnum(str[idx+2])){\n                    idx += 2;\n                    ll dec = tonum(idx);\n                    cerr << \"dec :\" << dec << endl;\n                    val = dec >= 64 ? 0 : (val >> dec);\n                }\n                else{\n                    auto temp = calc(idx+2);\n                    val = (val >> temp.first);\n                    assert(idx <= temp.second);\n                    idx = temp.second;\n                }\n                cerr << \"D\";\n                cerr << val << \" \" << idx << endl;\n            }\n            else{\n                return make_pair((val*val)%MOD, idx);\n            }\n        }\n        else if(str[idx] >= '0' && str[idx] <= '9'){\n            val = tonum(idx);\n        }\n    }\n    return make_pair(val,idx);\n}\n\nint main(){\n    while(true){\n        str.clear();\n        string raw;getline(cin, raw);\n        for(auto e : raw)if(e != ' ' && e != '<')str.push_back(e);\n        cerr << str << endl;\n        if(str == \"#\")break;\n        cout << calc(0).first << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint N;\nstring S;\n\nbool expr(int&, LL&);\nbool term(int&, LL&);\n\nbool expr(int &i, LL& res){\n  int bk = i;\n  if(!term(i, res)){\n\ti = bk;\n\treturn false;\n  }\n  while(i < N){\n\tif(!(i+1 < N && S[i] == '>' && S[i+1] == '>')) break;\n\tbk = i;\n\ti += 2;\n\tLL t;\n\tif(!term(i,t)){\n\t  i = bk;\n\t  break;\n\t}\n\twhile(res>0 && t > 0){\n\t  res /= 2;\n\t  --t;\n\t}\n  }\n  return true;\n}\n\nbool term(int& i, LL& res){\n  res = 0;\n  if(isdigit(S[i])){\n\twhile(i < N && isdigit(S[i])){\n\t  res = res * 10 + (S[i] - '0');\n\t  ++i;\n\t}\n\treturn true;\n  }\n  int bk = i;\n  if(i < N && S[i] == 'S'){\n\t++i;\n\tif(i < N && S[i] == '<'){\n\t  ++i;\n\t  if(expr(i, res)){\n\t\tif(i < N && S[i] == '>'){\n\t\t  ++i;\n\t\t  res %= MOD;\n\t\t  res = res * res % MOD;\n\t\t  return true;\n\t\t}\n\t  }\n\t}\n  }\n\n  i = bk;\n  return false;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(getline(cin,S), S != \"#\"){\n\tN = SZ(S);\n\tstring tmp;\n\tREP(i,N) if(S[i] != ' ') tmp += S[i];\n\n\tS = tmp;\n\tN = SZ(S);\n\n\tint i = 0;\n\tLL ans = 0;\n\tassert(expr(i, ans));\n\tcout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\nusing ll = long long;\nconstexpr ll MOD = 1000000007;\ninline ll sf(const ll k, const ll n) { return k > 32 ? 0 : n >> k; }\ninline ll sq(const long long n) { return n * n % MOD; }\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\n\nint main()\n{\n    while (true) {\n        auto input = []() {\n            string s;\n            getline(cin, s);\n            string ans;\n            for (ll i = s.size() - 1, st = 0, v = false; i >= 0; i--) {\n                const char c = s[i];\n                if (isdigit(c)) { ans.push_back(c), v = true; }\n                if (c == '>') {\n                    if (v) {\n                        ans.push_back('%'), v = false, i--;\n                    } else {\n                        ans.push_back('<'), st++;\n                    }\n                }\n                if (c == '<') { ans.push_back('>'), v = true, st--; }\n            }\n            return ans;\n        };\n        const string S = input();\n        if (S.empty()) { break; }\n        ll pos = 0, ans = 0;\n        auto dfs = fix([&](auto&& self) -> ll {\n            if (pos >= S.size()) { return ans; }\n            const char c = S[pos];\n            if (c == '<') {\n                pos++;\n                const ll sub = self(self);\n                ans = sq(sub);\n                return self(self);\n            } else if (c == '%') {\n                pos++;\n                const ll prev = ans;\n                const ll next = self(self);\n                ans = sf(prev, next);\n                return self(self);\n            } else if (isdigit(c)) {\n                ll num = 0;\n                for (ll d = 1; pos < S.size() and isdigit(S[pos]); d *= 10, pos++) { num += d * (S[pos] - '0'); }\n                ans = num;\n                return self(self);\n            } else {\n                pos++;\n                return self(self);\n            }\n        });\n        dfs();\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nstring s;\n\nbool isDigit(char c)\n{\n\treturn c >= '0' && c <= '9';\n}\nllint parseNumber(int &p)\n{\n\tllint ret = 0;\n\twhile(isDigit(s[p])) ret *= 10, ret += s[p]-'0', p++;\n\treturn ret;\n}\nllint parseExp(int &p);\nllint parseTerm(int &p)\n{\n\tif(s[p] == '['){\n\t\tp++;\n\t\tllint ret = parseExp(p);\n\t\tret = ret*ret%mod;\n\t\tp++;\n\t\treturn ret;\n\t}\n\tif(isDigit(s[p])) return parseNumber(p);\n}\nllint parseExp(int &p)\n{\n\tllint ret = parseTerm(p);\n\twhile(1){\n\t\tif(s[p] == '/'){\n\t\t\tp++;\n\t\t\tllint tmp = parseTerm(p);\n\t\t\tif(tmp > 40) ret = 0;\n\t\t\telse ret >>= tmp;\n\t\t}\n\t\telse break;\n\t}\n\treturn ret;\n}\n\n\nint main(void)\n{\n\twhile(1){\n\t\tgetline(cin, s);\n\t\tif(s == \"#\") break;\n\t\ts += \"=\";\n\t\t\n\t\tstring t;\n\t\tfor(int i = 0; i < s.size(); i++){\n\t\t\tif(s[i] == ' ') continue;\n\t\t\tt += s[i];\n\t\t}\n\t\ts = t;\n\t\t\n\t\tt = \"\";\n\t\tfor(int i = 0; i < s.size(); i++){\n\t\t\tif(s[i] == 'S'){\n\t\t\t\tt += '[';\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if(s[i] == '>'){\n\t\t\t\tif(s[i+1] != '>') t += ']';\n\t\t\t\telse{\n\t\t\t\t\tif(s[i+2] != 'S' && !isDigit(s[i+2])) t += ']';\n\t\t\t\t\telse t += '/', i++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse t += s[i];\n\t\t}\n\t\ts = t;\n\t\t\n\t\tint p = 0;\n\t\tcout << parseExp(p) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef string::const_iterator State;\nDef expr(State &i);\nDef term(State &i);\nDef factor(State &i);\nDef number(State &i);\nll MOD=1000000007;\nstring s;\nvoid consume(State &i,char expected){\n\tif(*i==expected)i++;\n\telse{\n\t\texit(0);\n\t}\n}\nDef expr(State &i){\n\tDef out=term(i);\n\twhile(*i=='>'&&*(i+1)=='>'&&(*(i+2)=='S'||isdigit(*(i+2)))){\n\t\ti+=2;\n\t\tDef out1=term(i);\n\t\tout>>=min(out1,70ll);\n\t}\n\treturn out;\n}\nDef term(State &i){\n\tif(isdigit(*i))return number(i);\n\ti++;\n\ti++;\n\tDef out=expr(i);\n\tout=out*out%MOD;\n\tcout<<out<<endl;\n\ti++;\n\treturn out;\n}\nDef number(State &i){\n\tDef out=0;\n\twhile(isdigit(*i))out=out*10+*(i++)-'0';\n\treturn out;\n}\nint main(){\n\twhile(1){\n\t\tgetline(cin,s);\n\t\tif(s==\"#\")break;\n\t\ts.erase(remove(s.begin(),s.end(),' '),s.end());\n\t\tState begin=s.begin();\n\t\tcout<<expr(begin)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstring str;\nint idx;\n\nint expr();\nint term();\nint number();\n\nint number() {\n  string res = \"\";\n  while(idx < (int)str.size() && isdigit(str[idx])) res += str[idx++];\n  reverse(all(res));\n  return stoll(res);\n}\n\nint term() {\n  if(isdigit(str[idx])) return number();\n  if(str[idx] == '>') {\n    idx++;\n    int x = expr();\n    assert(str[idx++] == '<');\n    assert(str[idx++] == 'S');\n    return x*x % mod;\n  } else {\n    assert(false);\n    return 0;\n  }\n}\n\nint expr() {\n  int x = term();\n  if(idx >= (int)str.size()) return x;\n  if(str[idx] == '<') return x;\n  else if(str[idx] == '>') {\n    idx++;\n    assert(str[idx] == '>');\n    idx++;\n    return x > 30 ? 0 : expr()>>x;\n  } else {\n    assert(false);\n    return 0;\n  }\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  string buf;\n  while(getline(cin, buf), buf != \"#\") {\n    str = \"\";\n    rep(i, buf.size()) if(buf[i] != ' ') str += buf[i];\n    reverse(all(str));\n    idx = 0;\n    cout << expr() << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconstexpr ll MOD = 1000000007;\n\nclass SyntaxAnalysis\n{\npublic:\n    SyntaxAnalysis(const string& S) : S{S} {}\n    ll Expression() { return pos = 0, expression(); }\n\nprivate:\n    static ll sf(const ll n, const ll k) { return k >= 64 ? 0 : n >> k; }\n    static ll sq(const ll n) { return n * n % MOD; }\n    ll number()\n    {\n        ll ans = 0;\n        for (; pos < S.size() and isdigit(S[pos]); pos++) { ans = ans * 10 + S[pos] - '0'; }\n        return ans;\n    }\n    ll factor()\n    {\n        if (S[pos] == '<') {\n            ll ans;\n            return pos++, ans = sq(expression()), pos++, ans;\n        } else {\n            return number();\n        }\n    }\n    ll term()\n    {\n        ll ans = factor();\n        for (ll f = 0; pos < S.size() and S[pos] == '%';) { pos++, f = factor(), ans = sf(ans, f); }\n        return ans;\n    }\n    ll expression() { return term(); }\n    int pos = 0;\n    string S;\n};\n\nint main()\n{\n    while (true) {\n        auto input = []() {\n            string s;\n            getline(cin, s);\n            string ans;\n            for (ll i = s.size() - 1, st = 0, v = false; i >= 0; i--) {\n                const char c = s[i];\n                if (isdigit(c)) { ans.push_back(c), v = true; }\n                if (c == '>') {\n                    if (v) {\n                        ans.push_back('%'), v = false, i--;\n                    } else {\n                        ans.push_back('>'), st++;\n                    }\n                }\n                if (c == '<') { ans.push_back('<'), v = true, st--; }\n            }\n            reverse(ans.begin(), ans.end());\n            return ans;\n        };\n        const string S = input();\n        if (S.empty()) { break; }\n        SyntaxAnalysis sy(S);\n        cout << sy.Expression() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nconst ll MOD = 1e9 + 7;\n\nll to_num(int& i,const string& S){\n    ll res = 0;\n    while(true){\n        if(S[i] >= '0' && S[i] <= '9'){\n            res = res*10 + (S[i] - '0');\n            i++;\n        }else{\n            break;\n        }\n    }\n    return res;\n}\n\nvoid brank(int& i, const string& S){\n    while(S[i] == ' ')i++;\n}\n\nll calc(ll T){\n    ll cnt = 1;\n    while(T/2){\n        cnt++;\n        T>>=1;\n    }\n    return cnt;\n}\n\nll expr(int& i,const string& S){\n    ll res = 0;\n    brank(i,S);\n    bool expr_flag = false;\n    for(;i < S.length();){\n        brank(i,S);\n        if(S[i] == 'S'){\n            i++;\n            brank(i,S);\n            i++;\n            if(!expr_flag){\n                ll tmp = expr(i,S);\n                (tmp*=tmp)%=MOD;\n                res = tmp;\n                expr_flag = true;\n            }else{\n                ll tmp = expr(i,S);\n                (tmp*=tmp)%=MOD;\n                \n                ll digit = calc(res);\n                if(tmp > digit)res = 0;\n                else res >>= tmp;\n            }\n            i++;\n            continue;\n        }\n        if(S[i] >= '0' && S[i] <= '9'){\n            if(!expr_flag){\n                res = to_num(i,S);\n                expr_flag = true;\n            }else{\n                ll tmp = to_num(i,S);\n                \n                ll digit = calc(res);\n                if(tmp > digit) res = 0;\n                else res >>=tmp;\n            }\n            continue;\n        }\n        if(S[i] == '>'){\n            if(i < S.length() - 1){\n                if(S[i] == '>' && S[i+1] == '>'){\n                    i+=2;\n                    continue;\n                }\n            }\n            return res;\n        }\n    }\n    return res;\n}\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    string S;\n    cout << calc(8) << endl;\n    while(true){\n        getline(cin,S);\n        if(S == \"#\") break;\n        int i = 0;\n        cout << expr(i,S)<< endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nusing msi = map<string, int>;\nusing mii = map<int, int>;\nusing psi = pair<string, int>;\nusing pii = pair<int, int>;\nusing vlai = valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1E9\n#define EPS 1E-9\n#define MOD (1E9+7)\n#define PI 3.1415926535897932384\n\nstd::ostream &operator<<(std::ostream &out, const vector<int> &tgt)\n{\n\tstring s;\n\tfor (int i = 0; i<tgt.size(); i++) {\n\t\ts += (to_string(tgt[i]) + ((i != tgt.size() - 1) ? \" \" : \"\"));\n\t}\n\tout << s;\n\treturn out;\n}\n\nll ans(string s) {\n\t//cout << s << endl;\n\tint t = 0;\n\tif (s.back() == '>') {\n\t\tt = 1;\n\t\tbool sw = true,tsw=true;\n\t\tfor (int i = s.size() - 2; i >= 0; i--) {\n\t\t\tif (!sw&&s[i] == '>') {\n\t\t\t\tsw = true;\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (s[i] != '>')sw = false;\n\t\t\telse {\n\t\t\t\tsw = true;\n\t\t\t\tt++;\n\t\t\t}\n\t\t\tif (s[i] == '<')t--;\n\t\t\tif (t == 0) {\n\t\t\t\tll res = ans(s.substr(i+1, s.size() - i - 2));\n\t\t\t\tif (i == 1) {\n\t\t\t\t\treturn (res * res) % (int)MOD;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tll x = ans(s.substr(0, i - 1));\n\t\t\t\t\tll y = res;\n\t\t\t\t\treturn x >> y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = s.size() - 2; i >= 0; i--) {\n\t\tif (s[i] == '>') {\n\t\t\tll x = ans(s.substr(0,i-1));\n\t\t\tll y = 0;\n\t\t\tfor (int j = i+1; j < s.size(); j++) {\n\t\t\t\ty *= 10;\n\t\t\t\ty += s[j] - '0';\n\t\t\t}\n\t\t\treturn x >> y;\n\t\t}\n\t}\n\tll res = 0;\n\trep (i,s.size()) {\n\t\tres *= 10;\n\t\tres += (s[i] - '0');\n\t}\n\treturn res;\n\n}\n\nvoid solve(string s) {\n\tstring ss;\n\tfor (auto c : s) {\n\t\tif(c!=' ')ss.push_back(c);\n\t}\n\tcout << ans(ss) << endl;\n}\n\nint main() {\n\tstring s;\n\twhile (getline(cin,s), s != \"#\") {\n\t\tsolve(s);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\nint const MOD = 1e9+7;\n\nstring line; string::iterator iter;\ninline void debug() { cout << \"Remain: \\\"\" <<string(iter, line.end())<<'\"' << endl; }\n\nvoid consume(char e) {\n  if(*iter == e) { iter++; }\n  else { assert(0); }\n}\n\nbool ifconsume(char e) {\n  if(*iter == e) { consume(e); return 1; }\n  return 0;\n}\n\nbool strcons(string s) {\n  string::iterator is = s.begin();\n  string::iterator tmpiter = iter;\n  \n  while(is!=s.end() &&\n        tmpiter!=line.end() &&\n        *is == *tmpiter) { tmpiter++; is++; }\n\n  if(is == s.end()) {\n    iter = tmpiter;\n    return true;\n  }\n  return false;\n}\n\nll get_num() {\n  ll ret = 0;\n  while(isdigit(*iter)) { ret *= 10; ret += (*iter)-'0'; consume(*iter); }\n  return ret;\n}\n\nll expr();\nll term() {\n  if(isdigit(*iter)) { return get_num(); }\n  else if(ifconsume('S')) {\n    consume('<');\n    ll r = expr(); (r*=r) %= MOD;\n    consume('>');\n    return r;\n  }\n  else {\n    debug();assert(0&&\"term\");\n  }\n}\n\nll expr() {\n  ll t1 = term();\n  while(strcons(\">>\")) {\n    if(*iter != 'S' && !isdigit(*iter)) { iter -= 2; break; }\n    int k = term();\n    while(k--) { t1 >>= 1; }\n  }\n  return t1;\n}\n\nint main() {\n  for(string s;getline(cin, s);) {\n    if(s == \"#\") break;\n    line.clear();\n    int sz=s.size(); rep(i,sz) if(s[i]!=' ') { line.push_back(s[i]); }\n    iter = line.begin();\n    cout << expr() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nstring s;\nint p;\nint bns();\nint g_A(){\n  int a=0;\n  if(s[p]=='S'){\n    p+=2;\n    a=bns();\n    a=a*a%1000000007;\n    p++;\n  }\n  else if(isdigit(s[p])){\n    while(isdigit(s[p])){\n      a=a*10+(s[p]-'0');\n      p++;\n    }\n  }\n  return a;\n}\nint bns(){\n  int a=g_A();\n  while(s[p]=='>'&&s[p+1]=='>'&&(isdigit(s[p+2])||s[p+2]=='S')){\n    p+=2;\n    int b=g_A();\n    a>>=min(b,60LL);\n  }\n  return a;\n}\nmain(){\n  while(getline(cin,s),s[0]!='#'){\n    p=0;\n    s.erase(remove(s.begin(),s.end(),' '),s.end());\n    cout<<bns()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\null term(string& e, int& idx);\null expr(string& e, int& idx);\n\null number(string& e, int& idx) {\n    ull number = 0;\n    for (; idx < e.size(); idx++) {\n        if (!isdigit(e[idx])) {\n            break;\n        }\n        number *= 10;\n        number += e[idx] - '0';\n    }\n//    LOG(\"--> number %d\\n\", number);\n    return number;\n}\n\null term(string& e, int& idx) {\n    switch (e[idx]) {\n    case '(': {\n        idx++; // (\n        ull n = expr(e, idx);\n        ull val = (n * n) % 1000000007;\n//        LOG(\"--> pow %d = %d\\n\", n, val);\n        idx++; // )\n        return val;\n    }\n    default:\n        return number(e, idx);\n    }\n    assert(0);\n}\n\null expr(string& e, int& idx) {\n    ull val = term(e, idx);\n    for (; idx < e.size(); idx++) {\n        switch (e[idx]) {\n        case '>': {\n            idx++;\n            ull n = term(e, idx);\n//            LOG(\"--> shift %d %d = \", val, n);\n            for (int i = n; i > 0; i--) {\n                val >>= 1;\n            }\n//            LOG(\"%d\\n\", val);\n            idx--;\n            break;\n        }\n        case ')':\n            return val;\n        }\n    }\n    return val;\n}\n\nint main() {\n    string s;\n    while (getline(cin, s), s != \"#\") {\n        stringstream ss;\n        REP(i, s.size()) {\n            if (s[i] != ' ') {\n                ss << s[i];\n            }\n        }\n        s = ss.str();\n        stringstream ss2;\n        REP(i, s.size()) {\n            switch (s[i]) {\n            case 'S':\n                i++;\n                ss2 << '(';\n                break;\n            case '>':\n                if (i+2 < s.size() && isdigit(s[i+2])) {\n                    ss2 << '>';\n                    i += 1;\n                } else {\n                    ss2 << ')';\n                }\n                break;\n            case ' ':\n                break;\n            default:\n                ss2 << s[i];\n            }\n        }\n\n        string e = ss2.str();\n//        LOG(\"%s\\n\", e.c_str());\n\n        int idx = 0;\n        cout << expr(e, idx) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstdio>\nusing namespace std;\n\ntypedef long long Int;\nstring str;\n#define MOD 1000000007\nbool s[2160000];\nvoid getstr(){\n\tstr = \"\";\n\tchar c = 'a';\n\twhile(c != '\\n'){\n\t\tc = getchar();\n\t\tif(c == ' ' || c == '\\n')continue;\n\t\tstr += c;\n\t}\n}\n\nInt getnum(Int &x){\n\tInt res = 0;\n\tInt base = 1;            \n\twhile(x >= 0 && '0' <= str[x] && str[x] <= '9'){\n\t\tres += base * (str[x] - '0');\n\t\tbase *= 10;\n\t\tx--;\n\t}\n\treturn res;\n}\n\nInt solve(Int &x){\n\tInt res;\n\tif(str[x] == '>'){\n\t\tx--;\n\t\tres = solve(x);\n\t\tres = (res * res) % MOD;\n\t\tx -= 2;\n\t}\n\telse{\n\t\tres = getnum(x);\n\t}\n\t\n\t\n\tif(x >= 0 && str[x] == '>'){\n\t\tx -= 2;\n\t\treturn solve(x) >> min(32LL, res);\n\t}\n\treturn res;\n\n}\n\n\nint main(){\n\twhile(true){\n\t\tgetstr();\n\t\tif(str == \"#\")return 0;\n\t\tInt x = str.size() - 1;\n\t\tcout << solve(x) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst ll MOD = 1000000007;\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(2e5 + 5);\nconst double EPS = 1e-10;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define ALL(v) (v).begin(), (v).end()\n\nstring s;\nint f, k, cnt = 0;\n\nll rec(){\n    ll res = 0, tmp=0;\n    while(k<s.size()){\n        if(s[k]=='<' || s[k] == ' '){\n            k++;\n            continue;\n        }\n        if(s[k]=='S'){\n            f++;\n            k++;\n            if(cnt>=2){\n                cnt -= 2;\n                tmp = rec();\n                if(tmp < 32){\n                    res >>= tmp;\n                }\n                else res = 0;\n            }\n            else res += rec();\n        }\n        else if(s[k] == '>'){\n            cnt++;\n            if(cnt>=3){\n                cnt--;\n                f--;\n                return res*res %MOD;\n            }\n        }\n        else{\n            tmp = 0;\n            while(k < s.size() && s[k]>='0' && s[k]<='9'){\n                tmp = tmp*10 + s[k] - '0';\n                k++;\n            }\n            k--;\n            if(cnt>=2){\n                cnt -= 2;\n                if(tmp < 32)res >>= tmp;\n                else res = 0;\n            }\n            else res += tmp;\n        }\n        if(s[k] != '>') cnt = 0;\n        k++;\n    }\n    if(f>0){\n        f--;\n        res = res*res %MOD;\n    }\n    return res;\n}\n\nint main() {\n    \n    while(1){\n        getline(cin,s);\n        if(s==\"#\")break;\n        k = 0;\n        cout << rec() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<sstream>\n#include <cctype>\n#include <stack>\n#define fuck(x) cerr<<#x<<\" <- \"<<x <<endl;\n\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\nstring s, t;\n\nstack<char> op;\nstack<ll> num;\n\nvoid pop() {\n    char c = op.top(); op.pop();\n//    printf(\"pop(%c)\\n\", c);\n\n    if (c == '$') {\n//        printf(\"numsz = %d\\n\", num.size());\n        ll b = num.top(); num.pop();\n        ll a = num.top(); num.pop();\n        b = min(b, 100LL);\n//        printf(\"%lld$%lld\\n\", a, b);\n        ll res = (a >> b);\n        num.push(res);\n    }\n    else {\n        ll a = num.top();\n        num.pop();\n        num.push((a * a) % mod);\n    }\n}\n\nll work() {\n    int n = s.length();\n    ll x = 0;\n    char la = 0;\n    for (int i = 0; i < n; i++) {\n//        printf(\"i = %d, %c\\n\", i, s[i]);\n        if (s[i] == '[') {\n            op.push(s[i]);\n            x = 0;\n        }\n        else if (s[i] == '$') {\n            if (isdigit(la)) num.push(x);\n            while (!op.empty() && op.top() != '[') pop();\n            op.push(s[i]);\n            x = 0;\n        }\n        else if (s[i] == ']') {\n            if (isdigit(la)) num.push(x);\n            while (op.top() != '[') pop();\n            pop();\n            x = 0;\n        }\n        else {\n            x = (x * 10 + s[i] - '0') % mod;\n        }\n        la = s[i];\n    }\n    if (isdigit(la)) num.push(x);\n    while (!op.empty()) pop();\n}\n\n\n\nint main() {\n//    freopen(\"F.in\", \"r\", stdin);\n    string line;\n    while (1) {\n        while (!num.empty()) num.pop();\n        while (!op.empty()) op.pop();\n        getline(cin, line);\n        if (line[0] == '#') break;\n        int len = line.length();\n        bool flag = 0;\n        s = \"\";\n        char la = 0;\n        for (int i = len-1; i >= 0; i--) {\n//            printf(\"i = %d, la=%c\\n\", i, la);\n            if (line[i] == '>') {\n                if (la == '[' || isdigit(la)) {\n                    la = '$';\n                    i--;\n                }\n                else {\n                    la = ']';\n                }\n            }\n            else if (line[i] == '<') {\n                la = '[';\n            }\n            else if (isdigit(line[i])) {\n                la = line[i];\n            }\n            else continue;\n\n            s += la;\n        }\n        reverse(s.begin(), s.end());\n\n//        cout << \"org: \" << line << endl;\n//        cout << \"new: \" << s << endl;\n        work();\n        while (op.size()!=0);\n        while (num.size()!=1);\n//        printf(\"op: %d, num: %d, ans: %lld\\n\", op.size(), num.size(), num.top());\n        printf(\"%lld\\n\", num.top());\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing ll = long long;\nconstexpr ll MOD = (1e9) + 7;\n\nclass Parser {\n  private:\n    std::string s;\n    std::string::const_iterator it;\n    \n  public:\n    Parser (std::string s) : s{s} {\n        it = s.begin();\n    }\n\n    ll number()\n    {\n        ll res = 0;\n        while (isdigit(*it)) {\n            res *= 10;\n            res += *it - '0';\n            ++it;\n        }\n        return res;\n    }\n    \n    ll term()\n    {\n        ll res = 0;\n        if (isdigit(*it)) {\n            res = number();\n        } else if (*it == 'S') {\n            it += 2; // S <            \n            res = expr() % MOD;            \n            res = (res * res) % MOD;\n            ++it; // >\n        }\n        return res;\n    }\n\n    bool is_term(char ch)\n    {\n        return (isdigit(ch) || ch == 'S');\n    }\n\n    ll mod_pow(ll x, ll n, ll mod)\n    {\n        if (n == 0) {\n            return 1;\n        }\n        ll res = mod_pow(x * x % mod, n / 2, mod);\n        if (n & 1) {\n            res = res * x % mod;\n        }\n        return res;\n    }\n\n    void shift(ll &x, ll y)\n    {\n        for (ll i = 0; i < y; i++) {\n            if (x == 0) {\n                return;\n            }\n            x >>= 1;\n        }\n    }\n    \n    ll expr()\n    {\n        ll res = term();\n        while (*it == '>' && *(it + 1) == '>' && is_term(*(it + 2))) {\n            it += 2;\n            shift(res, term());            \n            res %= MOD;\n        }\n        return res;\n    }\n};\n\nstd::string remove_spaces(const std::string &s)\n{\n    std::string res;\n    for (char c : s) {\n        if (c != ' ') {\n            res += c;\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    std::string s;\n    while (1) {\n        std::getline(std::cin, s);\n        if (s == \"#\") {\n            break;\n        }\n        s = remove_spaces(s);\n        \n        Parser p{s};\n        std::cout << p.expr() << std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntypedef string::const_iterator State;\nclass ParseError {};\nvoid sp(State&);\nint expr(State&);\nint term(State&);\nint number(State&);\n\nstring s;\nint expr(State &begin) {\n\tint ret = term(begin);\n\twhile(1) {\n\t\t//cout << *begin << \" \" << begin-s.begin() << \" \" << ret << endl;\n\t\tif(*begin == '>' && *(begin+1) == '>' && *(begin+2) != '>') {\n\t\t\tbegin++; // >\n\t\t\tbegin++; // >\n\t\t\tret >>= term(begin);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t//cout << \"expr:\" << ret << endl;\n\treturn ret;\n}\n\nint term(State &begin) {\n\tif(*begin == 'S') {\n\t\tbegin++;\n\t\tbegin++;\n\t\t//cout << \"s \" << *begin << \" \" << begin-s.begin() << endl;\n\t\tint ret = expr(begin);\n\t\tret = (ret*ret) % MOD;\n\t\tbegin++;\n\t\t//cout << \"te:\" << ret << endl;\n\t\treturn ret;\n\t} else {\n\t\t//cout << \"tn:\" << *begin << \" \" << begin - s.begin() << endl;\n\t\tint ret = number(begin);\n\t\t//cout << \"tenum:\" << ret << endl;\n\t\treturn ret;\n\t}\n}\n\nint number(State &begin) {\n\tint ret = 0;\n\twhile(isdigit(*begin)) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nsigned main(void)\n{\n\twhile(true) {\n\t\tstring t;\n\t\tgetline(cin, t);\n\t\tif(t == \"#\") break;\n\n\t\ts = \"\";\n\t\tREP(i, t.size()) if(t[i] != ' ') s += t[i];\n\t\t//cout << s << endl;\n\t\tState begin = s.begin();\n\t\tcout << expr(begin) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define LOG(...) fprintf(stderr,__VA_ARGS__)\n#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\null term(string& e, int& idx);\null expr(string& e, int& idx);\n\null number(string& e, int& idx) {\n    ull number = 0;\n    for (; idx < e.size(); idx++) {\n        if (!isdigit(e[idx])) {\n            break;\n        }\n        number *= 10;\n        number += e[idx] - '0';\n    }\n    LOG(\"--> number %d\\n\", number);\n    return number;\n}\n\null term(string& e, int& idx) {\n    switch (e[idx]) {\n    case '(': {\n        idx++; // (\n        ull n = expr(e, idx);\n        ull val = (n * n) % 1000000007;\n        LOG(\"--> pow %d = %d\\n\", n, val);\n        idx++; // )\n        return val;\n    }\n    default:\n        return number(e, idx);\n    }\n    assert(0);\n}\n\null expr(string& e, int& idx) {\n    ull val = term(e, idx);\n    for (; idx < e.size(); idx++) {\n        switch (e[idx]) {\n        case '>': {\n            idx++;\n            ull n = term(e, idx);\n            LOG(\"--> shift %d %d = \", val, n);\n            for (int i = n; i > 0 && val != 0; i--) {\n                val >>= 1;\n            }\n            LOG(\"%d\\n\", val);\n            idx--;\n            break;\n        }\n        case ')':\n            return val;\n        }\n    }\n    return val;\n}\n\nint main() {\n    string s;\n    while (getline(cin, s), s != \"#\") {\n        stringstream ss;\n        REP(i, s.size()) {\n            if (s[i] != ' ') {\n                ss << s[i];\n            }\n        }\n        s = ss.str();\n        stringstream ss2;\n        REP(i, s.size()) {\n            switch (s[i]) {\n            case 'S':\n                i++;\n                ss2 << '(';\n                break;\n            case '>':\n                if (i+2 < s.size() && (isdigit(s[i+2]) || s[i+2] == 'S')) {\n                    ss2 << '>';\n                    i += 1;\n                } else {\n                    ss2 << ')';\n                }\n                break;\n            case ' ':\n                break;\n            default:\n                ss2 << s[i];\n            }\n        }\n\n        string e = ss2.str();\n        LOG(\"%s\\n\", e.c_str());\n\n        int idx = 0;\n        cout << expr(e, idx) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reep(i,a,b) for(int i=a; i<b; i++)\n#define INF 0x3f3f3f3f\n#define MOD 1000000007LL\n\ntypedef vector<int> vint;\ntypedef long long ll;\n\nstring s;\nint idx;\n\nvoid sp(){\n\twhile(s[idx] == ' ') idx++;\n}\n\nll number(){\n\tll ret = 0;\n\twhile(isdigit(s[idx])){\n\t\tret *= 10;\n\t\tret += s[idx]-'0';\n\t\tidx++;\n\t}\n\treturn ret;\n}\n\nll RS(ll x, ll y){\n\tif(y>=100) return 0;\n\telse return x>>y;\t\n}\n\nll S(ll y){\n\ty *= y;\n\treturn y % MOD;\t\n}\n\n/*\nbool isRS(){\n\tint tmp = idx;\n\tbool ret = true;\n\tif(s.substr(idx,2) != \">>\") ret = false;\n\tidx += 2;\n\tsp();\n\tif(!(s[idx] == 'S' || isdigit(s[idx]))) ret = false; \n\tidx = tmp;\n\treturn ret;\n}\n*/\nll term();\n\nll expr(ll x=0){\n\t//sp();\n\t//assert(idx<20);\n\tif(idx == s.size()) return x;\n\t// cout<<\"solve \"<<x<<\" \"<<idx<<\" \"<<s[idx]<<endl;\n\tx = term();\n\twhile(s[idx] == '>'){\n\t\tidx+=2;\n\t\tll y = term();\n\t\tx = RS(x, y);\n\t}\n\t/*\n\tif(isdigit(s[idx])) x = number();\n\telse if(s[idx] == '>'){\n\t\tidx+=2;\n\t\tll y = solve();\n\t\tcout<<\"RS \"<<x<<\" \"<<y<<endl;\n\t\tx = RS(x, y);\n\t}\n\telse{\n\t\tassert(s[idx] == ')');\n\t\treturn x;\n\t}\n\t*/\n\treturn x;\n}\n\nll term(){\n\tll x;\n\tif(isdigit(s[idx])) x = number();\n\tif(s[idx] == 'S'){\n\t\tidx++;\n\t\tidx++;\n\t\tll y = expr();\n\t\tidx++;\n\t\tx = S(y);\n\t\t// cout<<\"S \"<<x<<endl;\n\t}\n\treturn x;\n}\n\n\n\nint main(){\n\twhile(getline(cin,s), s!=\"#\"){\n\t\tstring tmp;\n\t\trep(i,s.size()){\n\t\t\tif(s[i] != ' ') tmp += s[i];\n\t\t}\n\t\ts = tmp;\n\t\trep(i,s.size()){\n\t\t\tif(s[i] == '<') s[i] = '(';\n\t\t\tif(s[i] == '>'){\n\t\t\t\tif(i+2<s.size() && s[i+1] == '>' && (s[i+2] == 'S' || isdigit(s[i+2]))) i+=1;\n\t\t\t\telse s[i] = ')';\n\t\t\t}\n\t\t}\n\t\tidx = 0;\n\t\t// cout<<s<<endl;\n\t\tcout<<expr()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nconst ll MOD = 1e9 + 7;\n\nll to_num(int& i,const string& S){\n    ll res = 0;\n    while(true){\n        if(S[i] >= '0' && S[i] <= '9'){\n            res = res*10 + (S[i] - '0');\n            i++;\n        }else{\n            break;\n        }\n    }\n    return res;\n}\n\nvoid brank(int& i, const string& S){\n    while(S[i] == ' ')i++;\n}\n\nll calc(ll T){\n    ll cnt = 1;\n    while(T/2){\n        cnt++;\n        T>>=1;\n    }\n    return cnt;\n}\n\nll expr(int& i,const string& S){\n    ll res = 0;\n    brank(i,S);\n    bool expr_flag = false;\n    for(;i < S.length();){\n        brank(i,S);\n        if(S[i] == 'S'){\n            i++;\n            brank(i,S);\n            i++;\n            if(!expr_flag){\n                ll tmp = expr(i,S)%MOD;\n                (tmp*=tmp)%=MOD;\n                res = tmp;\n                expr_flag = true;\n            }else{\n                ll tmp = expr(i,S)%MOD;\n                (tmp*=tmp)%=MOD;\n                \n                ll digit = calc(res);\n                if(tmp > digit)res = 0;\n                else res >>= tmp;\n            }\n            i++;\n            continue;\n        }\n        if(S[i] >= '0' && S[i] <= '9'){\n            if(!expr_flag){\n                res = to_num(i,S);\n                expr_flag = true;\n            }else{\n                ll tmp = to_num(i,S);\n                ll digit = calc(res);\n \n                if(tmp > digit) res = 0;\n                else res >>=tmp;\n            }\n            continue;\n        }\n        if(S[i] == '>'){\n            if(i < S.length() - 2){\n                if(S[i] == '>' && S[i+1] == '>' && S[i+2] == '>'){\n                    return res;\n                }else{\n                    i+=2;\n                    continue;\n                }\n            }\n            return res;\n        }\n    }\n    return res;\n}\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    string S;\n    while(true){\n        getline(cin,S);\n        if(S == \"#\") break;\n        int i = 0;\n        cout << expr(i,S)<< endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst long long INF = 1e15;\nconst long long M = 1000000007LL;\n\n//x^n mod M\nlong long power(long long x, long long n){\n    long long res = 1;\n    if(n > 0){\n        res = power(x, n / 2);\n        if(n % 2 == 0) res = (res * res) % M;\n        else res = (((res * res) % M) * x ) %M;\n    }\n    return res;\n}\n\ntypedef string::const_iterator State;\nlong long number(State&);\nlong long term(State&);\nlong long expression(State&);\n\n// ??°??????????????????????????????????????°????????????\nlong long number(State &begin) {\n    long long ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n\n// ?????????????????????????????????????????????????????????????????????\nlong long term(State &begin) {\n    if (*begin == 'S') {\n        begin++; // '('????£???°??????\n        begin++;\n        long long ret = expression(begin);\n        begin++; // ')'????£???°??????\n        return (ret * ret) % M;\n    } else {\n        return number(begin);\n    }\n    return INF;\n\n    //long long ret = factor(begin);\n\n    //for (;;) {\n    //    if (*begin == '*') {\n    //        begin++;\n    //        ret *= factor(begin);\n    //    } else if (*begin == '/') {\n    //        begin++;\n    //        ret /= factor(begin);\n    //    } else {\n    //        break;\n    //    }\n    //}\n\n    //return ret;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nlong long expression(State &begin) {\n    long long ret = term(begin);\n\n    for (;;) {\n        if (*begin == '>' && *(begin + 1) == '>' && *(begin + 2) != '>') {\n            begin++;\n            begin++;\n            long long tmp = term(begin);\n            if(log(static_cast<double>(ret)) * 3.3223 < static_cast<double>(tmp)) ret = 0;\n            else ret = ret / power(2,tmp);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\ninline void deleteSpace(string &a){\n    size_t pos;\n    while((pos = a.find_first_of(\" \")) != string::npos){\n        a.erase(pos, 1);\n    }\n}\n\nint main(){\n    string s;\n    while(getline(cin,s),s[0] != '#'){\n        deleteSpace(s);\n        State tmp = s.begin();\n        cout << expression(tmp) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,ll> P;\n  \nstatic const double EPS = 1e-8;\nstatic const ll MOD = 1000000007;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nP expr(int pos,const string& str);\nP term(int pos,const string& str);\nP number(int pos,const string& str);\n\nP expr(int pos,const string& str){\n  P p1 = term(pos,str);\n  pos = p1.first;\n\n  while(pos + 2 < str.size() \n        && str[pos] == '>'\n        && str[pos+1] == '>'\n        && isdigit(str[pos+2])){\n    while(str[pos] == '>') pos++; //for '>'\n    P p2 = term(pos,str);\n    p1.second >>= min(p2.second,63LL);\n    pos = p2.first;\n  }\n  return P(pos,p1.second);\n}\n\nP term(int pos,const string& str){\n  if(str[pos] == 'S'){\n    pos+=2; // for \"S<\"\n    P p1 = expr(pos,str);\n    pos = p1.first;\n    pos++; // for \">\"\n    return P(pos,((p1.second % MOD) * (p1.second % MOD)) % MOD);\n  }\n  \n  else{\n    return number(pos,str);\n  }\n}\n\nP number(int pos,const string& str){\n  \n  string tmp = \"0\";\n  while(pos < str.size() && isdigit(str[pos])){\n    tmp.push_back(str[pos]);\n    pos++;\n  }\n  return P(pos,atol(tmp.c_str()));\n}\n\nint main(){\n  string str;\n  while(getline(cin,str)){\n    if(str == \"#\") continue;\n\n    string tmp = \"\";\n    for(int i=0;i<str.size();i++){\n      if(str[i] != ' '){\n        tmp.push_back(str[i]);\n      }\n    }\n    str = tmp;\n    P p = expr(0,str);\n    cout << p.second % MOD << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdlib>\n#include<sstream>\n#include<algorithm>\n#include<stack>\n#include<map>\n#define mod 1000000007\nusing namespace std;\n\ntypedef unsigned long long ll;\n\nvector<string> a;\nmap<int,int> m;\n\nstring f1(string a){\n  ll x=(ll)atoi(a.c_str());\n  x=(x*x)%mod;\n  ostringstream os;\n  os<<x;\n  return os.str();\n}\n\nstring f2(string a,string b){\n  ll x=atoi(a.c_str()),y=atoi(b.c_str()),c=1;\n  for(int i=0;i<y;i++){\n    if(x<c)return \"0\";\n    c*=2;\n  }\n  x=x/c;\n  ostringstream os;\n  os<<x;\n  return os.str();\n}\n\nvoid rec(int s,int t){\n  for(int i=s;i<t;i++){\n    if(a[i]==\"<\"){\n      int l=i+1,r=m[i];\n      rec(l,r);\n      i=r-1;\n    }\n    else if(a[i]==\">>\"){\n      if(a[i+1]==\"<\"){\n\tint l=i+1,r=m[i+1];\n\trec(l,r+1);\n        a[l]=f2(a[i-1],a[l]);\n\ti=r;\n      }\n      else a[i+1]=f2(a[i-1],a[i+1]);\n    }\n    else if(a[i]==\">\")a[i]=f1(a[i-1]);\n    else {}\n  }\n}\n\nint main()\n{\n  while(1){\n    char c;\n    string s,t=\"\";\n    vector<string> b;\n    getline(cin,s);\n    if(s[0]=='#')break;\n    a.clear();\n    for(int i=0;i<s.length();i++)if(s[i]!=' ')t+=s[i];\n    string tmp=\"\";\n    for(int i=0;i<t.length();i++){\n      if(t[i]=='S'){\n\tb.push_back(\"<\");\n\ti++;\n      }\n      else if(t[i]=='>'){\n\tif(tmp!=\"\")b.push_back(tmp);\n\ttmp=\"\";\n\tb.push_back(\">\");\n      }\n      else tmp+=t[i];\n      if(i==t.length()-1 && tmp!=\"\")b.push_back(tmp);\n    }\n\n    for(int i=b.size()-1;0<i;i--){\n      if(b[i]!=\">\"){\n\ta.push_back(b[i]);\n\tif(b[i-1]==\">\"){\n\t  i-=2;\n\t  a.push_back(\">>\");\n\t}\n      }\n      else a.push_back(b[i]);\n    }\n    a.push_back(b[0]);\n    reverse(a.begin(),a.end());\n    stack<int> st;\n    for(int i=0;i<a.size();i++){\n      if(a[i]==\"<\")st.push(i);\n      if(a[i]==\">\"){\n\tint a=st.top();\n\tst.pop();\n\tm[a]=i;\n      }\n    }\n    rec(0,a.size());\n    cout<<a[a.size()-1]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing ll = long long;\nconstexpr ll MOD = (1e9) + 7;\n\nclass Parser {\n  private:\n    std::string s;\n    std::string::const_iterator it;\n    \n  public:\n    Parser (std::string s) {\n        this->s = s;\n        it = this->s.begin();\n    }\n\n    ll number()\n    {\n        ll res = 0;\n        while (isdigit(*it)) {\n            res *= 10;\n            res += *it - '0';\n            ++it;\n        }\n        return res;\n    }\n    \n    ll term()\n    {\n        ll res = 0;\n        if (isdigit(*it)) {\n            res = number();\n        } else if (*it == 'S') {\n            it += 2; // S <            \n            res = expr() % MOD;            \n            res = (res * res) % MOD;\n            ++it; // >\n        }\n        return res;\n    }\n\n    bool is_term(char ch)\n    {\n        return (isdigit(ch) || ch == 'S');\n    }\n\n    ll mod_pow(ll x, ll n, ll mod)\n    {\n        if (n == 0) {\n            return 1;\n        }\n        ll res = mod_pow(x * x % mod, n / 2, mod);\n        if (n & 1) {\n            res = res * x % mod;\n        }\n        return res;\n    }\n\n    void shift(ll &x, ll y)\n    {\n        for (ll i = 0; i < y; i++) {\n            if (x == 0) {\n                return;\n            }\n            x >>= 1;\n        }\n    }\n    \n    ll expr()\n    {\n        ll res = term();\n        while (*it == '>' && *(it + 1) == '>' && is_term(*(it + 2))) {\n            it += 2;\n            shift(res, term());            \n            res %= MOD;\n        }\n        return res;\n    }\n};\n\nstd::string remove_spaces(const std::string &s)\n{\n    std::string res;\n    for (char c : s) {\n        if (c != ' ') {\n            res += c;\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    std::string s;\n    while (1) {\n        std::getline(std::cin, s);\n        if (s == \"#\") {\n            break;\n        }\n        s = remove_spaces(s);\n        \n        Parser p{s};\n        std::cout << p.expr() << std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef string::const_iterator State;\nDef expr(State &i);\nDef term(State &i);\nDef factor(State &i);\nDef number(State &i);\nll MOD=1000000007;\nstring s;\nvoid consume(State &i,char expected){\n\tif(*i==expected)i++;\n\telse{\n\t\texit(0);\n\t}\n}\nDef expr(State &i){\n\tDef out=term(i);\n\twhile(*i=='>'&&*(i+1)=='>'&&(*(i+2)=='S'||isdigit(*(i+2)))){\n\t\ti+=2;\n\t\tDef out1=term(i);\n\t\tout>>=min(out1,70ll);\n\t}\n\treturn out;\n}\nDef term(State &i){\n\tif(isdigit(*i))return number(i);\n\ti++;\n\ti++;\n\tDef out=expr(i);\n\tout=out*out%MOD;\n\ti++;\n\treturn out;\n}\nDef number(State &i){\n\tDef out=0;\n\twhile(isdigit(*i))out=out*10+*(i++)-'0';\n\treturn out;\n}\nint main(){\n\twhile(1){\n\t\tgetline(cin,s);\n\t\tif(s==\"#\")break;\n\t\ts.erase(remove(s.begin(),s.end(),' '),s.end());\n\t\tState begin=s.begin();\n\t\tcout<<expr(begin)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstring s;\nint p;\n\nll expr();\n\nll num()\n{\n\tll res;\n\tif (isdigit(s[p]))\n\t{\n\t\tres = 0;\n\t\twhile (isdigit(s[p]))\n\t\t{\n\t\t\tres *= 10;\n\t\t\tres += s[p] - '0';\n\t\t\tp++;\n\t\t}\n\t}\n\telse res = expr();\n\treturn res;\n}\n\nll term()\n{\n\tll lhs = num();\n\twhile (s[p] == '#')\n\t{\n\t\tp++;\n\t\tll rhs = num();\n\t\tif (rhs > 32) lhs = 0;\n\t\telse lhs >>= rhs;\n\t}\n\treturn lhs;\n}\n\nll expr()\n{\n\tll res;\n\tif (s[p] == 'S')\n\t{\n\t\tp += 2;\n\t\tll tmp = term();\n\t\tp++;\n\t\tres = tmp * tmp % MOD;\n\t}\n\telse res = term();\n\treturn res;\n}\n\nll parse()\n{\n\tp = 0;\n\treturn expr();\n}\n\nvoid convert(string &t)\n{\n\ts.clear();\n\tREP(i, t.size())\n\t{\n\t\tif (t[i] != ' ') s += t[i];\n\t}\n\tbool update = true;\n\twhile (update)\n\t{\n\t\tupdate = false;\n\t\tREP(i, s.size() - 2)\n\t\t{\n\t\t\tif (s[i] == '>'&&s[i + 1] == '>' && (s[i + 2] == 'S' || isdigit(s[i + 2])))\n\t\t\t{\n\t\t\t\ts.erase(i, 1);\n\t\t\t\ts[i] = '#';\n\t\t\t\tupdate = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstring t;\n\twhile (getline(cin, t))\n\t{\n\t\tif (t == \"#\") break;\n\t\tconvert(t);\n\t\tcout << parse() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n// Shrotening\n#define fst first\n#define snd second\n#define pb push_back\n\n// Loop\n#define FOR(i,a,b) for(long i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(long i=(a);i>=(b);--i)\n\n#define REP(i,a) for(long i=0;i<(a);++i)\n#define RREP(i,a) for(long i=(a);i>=0;--i)\n\n#define EACH(i,a) for(auto (i)=(a).begin(),_END=(a).end();i!=_END;++i)\n#define REACH(i,a) for(auto (i)=(a).rbegin(),_END=(a).rend();i!=_END;++i)\n\n//Algorithm\n#define ALL(a) (a).begin(), a.end()\n#define RALL(a) (a).rbegin(), a.rend()\n#define EXIST(a,x) ((a).find(x)!=(a).end())\n#define SORT(a) std::sort((a).begin(), (a).end())\n#define UNIQUE(a) std::sort((a).begin(), a.end()), a.erase(std::unique((a).begin(), a.end()), a.end());\n#define SUM(a) std::accumulate((a).begin(), (a).end(), 0);\n\n//alias\ntypedef long long LL;\ntypedef std::vector<char> VC;\ntypedef std::vector<int>  VI;\ntypedef std::vector<long> VL;\ntypedef std::vector<long long> VLL;\n\ntypedef std::vector< VC > VC2;\ntypedef std::vector< VI > VI2;\ntypedef std::vector< VL > VL2;\ntypedef std::vector< VLL > VLL2;\n\ntypedef std::pair<int,int> PII;\n\ntypedef struct ParseState {\n    int pos;\n    int len;\n    std::string str;\n    std::deque<int> stack;\n\n    //EOF\n    bool isEOF() { return pos >= len; }\n    bool isNotEOF() { return pos < len; }\n\n    //advance\n    void eat(char ch) {\n        assert(pos < len && str[pos] == ch);\n        pos++;\n    }\n    char getCh() {\n        assert(pos < len);\n        return pos < len ? str[pos++] : -1; \n    }\n    //lookahead\n    char seek() {\n        return pos < len ? str[pos] : -1; \n    }\n    char seek(int offset) {\n        return (pos+offset) < len ? str[pos+offset] : -1;\n    }\n\n    //backtrack\n    void setBacktrack() { stack.push_front(pos); }\n    void delBacktrack() {\n        assert(!stack.empty());\n        stack.pop_front();\n    }\n    void backtrack() {\n        assert(!stack.empty());\n        pos = stack.front();\n        stack.pop_front();\n    }\n\n    //test\n    bool isDigit() {\n        return isDigit(0);\n    }\n    bool isDigit(int offset) {\n        char c = seek(offset);\n        return c >= '0' && c <= '9';\n    }\n    bool isUpperAlpha() {\n        return isUpperAlpha(0);\n    }\n    bool isUpperAlpha(int offset) {\n        char c = seek(offset);\n        return c >= 'A' && c <= 'Z';\n    }\n    bool isLowerAlpha() {\n        return isLowerAlpha(0);\n    }\n    bool isLowerAlpha(int offset) {\n        char c = seek(offset);\n        return c >= 'a' && c <= 'z';\n    }\n\n    //test2\n    bool isAlpha() {\n        return isLowerAlpha(0) || isUpperAlpha(0);\n    }\n    bool isAlpha(int offset) {\n        return isLowerAlpha(offset) || isUpperAlpha(offset);\n    }\n    bool isAlphaNum() {\n        return isLowerAlpha(0) || isUpperAlpha(0) || isDigit(0);\n    }\n    bool isAlphaNum(int offset) {\n        return isLowerAlpha(offset) || isUpperAlpha(offset) || isDigit(offset);\n    }\n} State;\n\nlong MOD = 1000000007;\n/*\nexpr   ::= term | expr sp \">>\" sp term\nterm   ::= number | \"S\" sp \"<\" sp expr sp \">\"\nsp     ::= \"\" | sp \" \"\nnumber ::= digit | number digit\n\nexpr ::= term (\">>\" term)*;\n*/\n\nlong expr(State*);\nlong term(State*);\nvoid sp(State*);\nlong number(State*);\n\nint depth = 0;\nlong expr(State* s) {\n    sp(s);\n    long x = term(s);\n    sp(s);\n\n    while(s->seek() == '>' && s->seek(1) == '>') {\n        s->setBacktrack();\n        s->eat('>');\n        s->eat('>');\n\n        sp(s);\n\n        long y = term(s);\n        if(y < 0) {\n            s->backtrack();\n            return x;\n        }\n        s->delBacktrack();\n\n        sp(s);\n\n        int xl2 = std::log2(x);\n        x = xl2 < y ? 0 : (x >> y);\n    }\n\n    return x;\n}\n\nlong term(State* s) {\n    sp(s);\n\n    if(s->isDigit()) return number(s);\n    if(s->seek() == 'S') {\n        s->eat('S');\n        sp(s);\n        s->eat('<');\n        sp(s);\n\n        long e = expr(s);\n\n        sp(s);\n        if(s->seek() != '>') return -1;\n        s->eat('>');\n\n        return ((LL)e * e) % MOD;\n    }\n    return -1;\n}\n\nvoid sp(State* s) {\n    while(s->isNotEOF() && s->seek() == ' ') {\n        s->eat(' ');\n    }\n}\n\nlong number(State* s) {\n    long val = 0;\n    while(s->isDigit()) {\n        val *= 10;\n        val += (int)(s->getCh() - '0');\n    }\n    return val;\n}\n\nint main() {\n    std::string S;\n    while(std::getline(std::cin, S) && S != \"#\") {\n        State state = State{0, (int)S.length(), S};\n        long res = expr(&state);\n        std::cout << res << std::endl;\n    }\n\n}\n    \n    "
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntypedef string::const_iterator State;\nclass ParseError {};\nvoid sp(State&);\nint expr(State&);\nint term(State&);\nint number(State&);\n\nstring s;\nint expr(State &begin) {\n\tint ret = term(begin);\n\twhile(1) {\n\t\t//cout << *begin << \" \" << begin-s.begin() << \" \" << ret << endl;\n\t\tif(*begin == '>' && *(begin+1) == '>' && *(begin+2) != '>') {\n\t\t\tbegin++; // >\n\t\t\tbegin++; // >\n\t\t\tint y = term(begin);\n\t\t\tREP(i, y) ret /= 2;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t//cout << \"expr:\" << ret << endl;\n\treturn ret;\n}\n\nint term(State &begin) {\n\tif(*begin == 'S') {\n\t\tbegin++;\n\t\tbegin++;\n\t\t//cout << \"s \" << *begin << \" \" << begin-s.begin() << endl;\n\t\tint ret = expr(begin);\n\t\tret = (ret*ret) % MOD;\n\t\tbegin++;\n\t\t//cout << \"te:\" << ret << endl;\n\t\treturn ret;\n\t} else {\n\t\t//cout << \"tn:\" << *begin << \" \" << begin - s.begin() << endl;\n\t\tint ret = number(begin);\n\t\t//cout << \"tenum:\" << ret << endl;\n\t\treturn ret;\n\t}\n}\n\nint number(State &begin) {\n\tint ret = 0;\n\twhile(isdigit(*begin)) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nsigned main(void)\n{\n\twhile(true) {\n\t\tstring t;\n\t\tgetline(cin, t);\n\t\tif(t == \"#\") break;\n\n\t\ts = \"\";\n\t\tREP(i, t.size()) if(t[i] != ' ') s += t[i];\n\t\t//cout << s << endl;\n\t\tState begin = s.begin();\n\t\tcout << expr(begin) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,ll> P;\n  \nstatic const double EPS = 1e-8;\nstatic const ll MOD = 1000000007;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nP expr(int pos,const string& str);\nP term(int pos,const string& str);\nP number(int pos,const string& str);\n\nP expr(int pos,const string& str){\n  P p1 = term(pos,str);\n  pos = p1.first;\n\n  while(pos + 2 < str.size() \n        && str[pos] == '>'\n        && str[pos+1] == '>'\n        && (isdigit(str[pos+2]) || str[pos+2] == 'S')){\n    while(str[pos] == '>') pos++; //for '>'\n    P p2 = term(pos,str);\n    p1.second >>= min(p2.second,63LL);\n    pos = p2.first;\n  }\n  return P(pos,p1.second);\n}\n\nP term(int pos,const string& str){\n  if(str[pos] == 'S'){\n    pos+=2; // for \"S<\"\n    P p1 = expr(pos,str);\n    pos = p1.first;\n    pos++; // for \">\"\n    return P(pos,((p1.second % MOD) * (p1.second % MOD)) % MOD);\n  }\n  \n  else{\n    return number(pos,str);\n  }\n}\n\nP number(int pos,const string& str){\n  \n  string tmp = \"0\";\n  while(pos < str.size() && isdigit(str[pos])){\n    tmp.push_back(str[pos]);\n    pos++;\n  }\n  return P(pos,atol(tmp.c_str()));\n}\n\nint main(){\n  string str;\n  while(getline(cin,str)){\n    if(str == \"#\") continue;\n\n    string tmp = \"\";\n    for(int i=0;i<str.size();i++){\n      if(str[i] != ' '){\n        tmp.push_back(str[i]);\n      }\n    }\n    str = tmp;\n    P p = expr(0,str);\n    cout << p.second % MOD << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).*begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int M = 1000000007;\n\nstring s;\n\ntypedef string::const_iterator State;\nint number(State&);\nint term(State&);\nint expression(State&);\n\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    if (*begin == 'S') {\n        begin++; begin++;\n        long long ret = expression(begin);\n        begin++;\n        return ret * ret % M;\n    } else {\n        return number(begin);\n    }\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    int ret = term(begin);\n\n    while(s.end() - begin >= 2){\n        if (*begin ==  '>' && *(begin + 1) == '>' && *(begin + 2) != '>'){\n            begin++; begin++;\n            ret = ret >> min(term(begin), 31);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint main(){\n    string tmp;\n    while(getline(cin,tmp),tmp != \"#\"){\n        s=\"\";\n        for(auto it:tmp) if(it != ' ') s+=it;\n        State state = s.begin();\n        cout << expression(state) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n\ntypedef long long lint;\ntypedef pair<int, int> pii;\n\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\nconst lint MOD = 1e9 + 7;\n\nstring S;\n\nvector<string> split_str(string _s, string _t) {\n\tvector<string> res;\n\tfor (int p = 0; (p = _s.find(_t)) != -1;) {\n\t\tres.push_back(_s.substr(0, p));\n\t\t_s = _s.substr(p + size_of(_t));\n\t}\n\tres.push_back(_s);\n\treturn res;\n}\n\nlint parse(int left, int right, int depth=50000) {\n\t//cout << left << \" \" << right << endl;\n\t//if (left > right) return -1;\n\t\n\tint lcnt = 0, rcnt = 0;\n\tint n_left = -1;\n\tqueue<lint> q;\n\tbool d_flag = false;\n\tint d_pos = -1;\n\tif (depth < 0) {\n\t\treturn MOD;\n\t}\n\tfor_(i,left,right) {\n\t\tif (S[i] == '<') {\n\t\t\tif (lcnt == 0) n_left = i + 1;\n\t\t\tlcnt++;\n\t\t}\n\t\tif (S[i] == '>') {\n\t\t\trcnt++;\n\t\t}\n\t\t\n\t\tif ((S[i] == '<' || S[i] == '|') && d_flag) {\n\t\t\tstring ress = S.substr(d_pos, i - d_pos);\n\t\t\tstringstream ss(ress);\n\t\t\tlint res; ss >> res;\n\t\t\tq.push(res);\n\t\t\td_flag = false;\n\t\t}\n\t\t\n\t\tif (!d_flag && lcnt == 0 && isdigit(S[i])) {\n\t\t\td_pos = i;\n\t\t\td_flag = true;\n\t\t}\n\t\t\n\t\tif (lcnt > 0 && rcnt > 0 && lcnt == rcnt) {\n\t\t\tlint res = parse(n_left, i, depth-1);\n\t\t\t/*\n\t\t\tif (res == -1) {\n\t\t\t\tlcnt = rcnt = 0;\n\t\t\t\tcontinue;\n\t\t\t}*/\n\t\t\tres *= res;\n\t\t\tres %= MOD;\n\t\t\tq.push(res);\n\t\t\tlcnt = rcnt = 0;\n\t\t}\n\t}\n\t\n\tif (d_flag) {\n\t\tstring ress = S.substr(d_pos, right - d_pos);\n\t\tstringstream ss(ress);\n\t\tlint res; ss >> res;\n\t\tq.push(res);\n\t}\n\t\n\tlint res = q.front(); q.pop();\n\twhile (!q.empty()) {\n\t\tlint d = q.front(); q.pop();\n\t\twhile (d > 0 && res > 0) {\n\t\t\tres /= 2;\n\t\t\td--;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nvoid solve() {\n\tint n = size_of(S);\n\tint i = 0;\n\twhile (i < size_of(S)) {\n\t\tif (i > 2 && (S[i] == 'S' || isdigit(S[i]))) {\n\t\t\tif (S[i - 1] == '>' && S[i - 2] == '>') {\n\t\t\t\tS = S.substr(0, i - 2) + \"|\" + S.substr(i);\n\t\t\t\ti = i - 2;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tcout << S << endl;\n\tn = size_of(S);\n\tcout << parse(0, n) << endl;\n}\n\nint main() {\n\tstring input;\n\twhile (getline(cin, input)) {\n\t\tif (input[0] == '#') break;\n\t\tvector< string > split = split_str(input, \" \");\n\t\tint v_size = size_of(split);\n\t\tS = \"\";\n\t\tfor_(i,0,v_size) S += split[i];\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reep(i,a,b) for(int i=a; i<b; i++)\n#define INF 0x3f3f3f3f\n#define MOD 1000000007LL\n\ntypedef vector<int> vint;\ntypedef long long ll;\n\nstring s;\nint idx;\n\nvoid sp(){\n\twhile(s[idx] == ' ') idx++;\n}\n\nll number(){\n\tll ret = 0;\n\twhile(isdigit(s[idx])){\n\t\tret *= 10;\n\t\tret += s[idx]-'0';\n\t\tidx++;\n\t}\n\treturn ret;\n}\n\nll RS(ll x, ll y){\n\tif(y>=100) return 0;\n\telse return x>>y;\t\n}\n\nll S(ll y){\n\ty *= y;\n\treturn y % MOD;\t\n}\n\n/*\nbool isRS(){\n\tint tmp = idx;\n\tbool ret = true;\n\tif(s.substr(idx,2) != \">>\") ret = false;\n\tidx += 2;\n\tsp();\n\tif(!(s[idx] == 'S' || isdigit(s[idx]))) ret = false; \n\tidx = tmp;\n\treturn ret;\n}\n*/\nll term();\n\nll expr(){\n\tll x = term();\n\twhile(idx < s.size() && s[idx] == '>'){\n\t\tidx+=2;\n\t\tll y = term();\n\t\tx = RS(x, y);\n\t}\n\treturn x;\n}\n\nll term(){\n\tll x;\n\tif(isdigit(s[idx])) x = number();\n\tif(s[idx] == 'S'){\n\t\tidx++;\n\t\tidx++;\n\t\tll y = expr();\n\t\tidx++;\n\t\tx = S(y);\n\t\t// cout<<\"S \"<<x<<endl;\n\t}\n\treturn x;\n}\n\n\n\nint main(){\n\twhile(getline(cin,s), s!=\"#\"){\n\t\tstring tmp;\n\t\trep(i,s.size()){\n\t\t\tif(s[i] != ' ') tmp += s[i];\n\t\t}\n\t\ts = tmp;\n\t\trep(i,s.size()){\n\t\t\tif(s[i] == '<') s[i] = '(';\n\t\t\tif(s[i] == '>'){\n\t\t\t\tif(i+2<s.size() && s[i+1] == '>' && (s[i+2] == 'S' || isdigit(s[i+2]))) i+=1;\n\t\t\t\telse s[i] = ')';\n\t\t\t}\n\t\t}\n\t\tidx = 0;\n\t\t// cout<<s<<endl;\n\t\tcout<<expr()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<utility>\n#include<map>\n#include<complex>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define stop char nyaa;cin>>nyaa;\n#define per(i,n) for(int i=n-1;i>=0;i--)\ntypedef long double ld;\n\nbool isnum(char t) {\n\treturn ('0' <= t && t <= '9');\n}\nstring s;\nvoid solve() {\n\tstring t;\n\trep(i, s.length()) {\n\t\tif (s[i] == ' ')continue;\n\t\tif (s[i] == 'S' || isnum(s[i])) {\n\t\t\tif (t.size() >= 2 && t[t.length() - 1] == '>'&&t[t.length() - 2] == '>') {\n\t\t\t\trep(j, 2)t.pop_back();\n\t\t\t\tt.push_back('*');\n\t\t\t}\n\t\t\tt.push_back(s[i]);\n\t\t}\n\t\telse t.push_back(s[i]);\n\t}\n\tll cur = 0;\n\tstack<ll> st;\n\tint len = t.length(); bool f = false;\n\tstack<bool> b;\n\t//cout << t << endl;\n\trep(i, len) {\n\t\t//cout << i << \" \" << cur << endl;\n\t\tif (t[i] == 'S') {\n\t\t\tst.push(cur);\n\t\t\tb.push(f);\n\t\t\tcur = 0;\n\t\t\tf = false;\n\t\t\ti++;\n\t\t}\n\t\telse if (isnum(t[i])) {\n\t\t\tint le = i;\n\t\t\twhile (i + 1 < len&&isnum(t[i + 1]))i++;\n\t\t\tstring u = t.substr(le, i - le + 1);\n\t\t\tll val = stoll(u);\n\t\t\tif (f) {\n\t\t\t\tif (val > 32)val = 32;\n\t\t\t\tcur >>= val;\n\t\t\t\tf = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcur = val;\n\t\t\t}\n\t\t}\n\t\telse if(t[i]=='>'){\n\t\t\tll pre = st.top(); st.pop();\n\t\t\tf = b.top(); b.pop();\n\t\t\tcur = cur * cur%mod;\n\t\t\tif (f) {\n\t\t\t\tif (cur > 32)cur = 32;\n\t\t\t\tpre >>= cur;\n\t\t\t\tf = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpre = cur;\n\t\t\t}\n\t\t\tcur = pre;\n\t\t}\n\t\telse if (t[i] == '*') {\n\t\t\tf = true;\n\t\t}\n\t}\n\tcout << cur << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\twhile (getline(cin, s)) {\n\t\tif (s == \"#\")break;\n\t\tsolve();\n\t}\n\t//stop\n\t\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<sstream>\n#include <cctype>\n#include <stack>\n#define fuck(x) cerr<<#x<<\" <- \"<<x <<endl;\n\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\nstring s, t;\n\nstack<char> op;\nstack<ll> num;\n\nvoid pop() {\n    char c = op.top(); op.pop();\n//    printf(\"pop(%c)\\n\", c);\n\n    if (c == '$') {\n//        printf(\"numsz = %d\\n\", num.size());\n        ll b = num.top(); num.pop();\n        ll a = num.top(); num.pop();\n        b = min(b, 100LL);\n//        printf(\"%lld$%lld\\n\", a, b);\n        ll res = (a >> b);\n        num.push(res);\n    }\n    else {\n        ll a = num.top();\n        num.pop();\n        num.push((a * a) % mod);\n    }\n}\n\nll work() {\n    int n = s.length();\n    ll x = 0;\n    char la = 0;\n    for (int i = 0; i < n; i++) {\n//        printf(\"i = %d, %c\\n\", i, s[i]);\n        if (s[i] == '[') {\n            op.push(s[i]);\n            x = 0;\n        }\n        else if (s[i] == '$') {\n            if (isdigit(la)) num.push(x);\n            while (!op.empty() && op.top() != '[') pop();\n            op.push(s[i]);\n            x = 0;\n        }\n        else if (s[i] == ']') {\n            if (isdigit(la)) num.push(x);\n            while (op.top() != '[') pop();\n            pop();\n            x = 0;\n        }\n        else {\n            x = (x * 10 + s[i] - '0') % mod;\n        }\n        la = s[i];\n    }\n    if (isdigit(la)) num.push(x);\n    while (!op.empty()) pop();\n}\n\n\n\nint main() {\n//    freopen(\"F.in\", \"r\", stdin);\n    string line;\n    while (1) {\n        while (!num.empty()) num.pop();\n        while (!op.empty()) op.pop();\n        getline(cin, line);\n        if (line[0] == '#') break;\n        int len = line.length();\n        bool flag = 0;\n        s = \"\";\n        char la = 0;\n        for (int i = len-1; i >= 0; i--) {\n//            printf(\"i = %d, la=%c\\n\", i, la);\n            if (line[i] == '>') {\n                if (la == '[' || isdigit(la)) {\n                    la = '$';\n                    i--;\n                }\n                else {\n                    la = ']';\n                }\n            }\n            else if (line[i] == '<') {\n                la = '[';\n            }\n            else if (isdigit(line[i])) {\n                la = line[i];\n            }\n            else continue;\n\n            s += la;\n        }\n        reverse(s.begin(), s.end());\n\n//        cout << \"org: \" << line << endl;\n//        cout << \"new: \" << s << endl;\n        work();\n        while (op.size()!=0);\n        while (num.size()!=1);\n//        printf(\"op: %d, num: %d, ans: %lld\\n\", op.size(), num.size(), num.top());\n        printf(\"%lld\\n\", num.top());\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <cstdio>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <algorithm>\n#include <limits>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MD = 1e9+7.1;\n\nint n;\nchar s[2000030];\n\nll expr(char **begin);\n\nll numb(char **begin) {\n    ll r = 0;\n    while (isdigit(**begin)) {\n        r *= 10;\n        r += **begin - '0';\n        *begin += 1;\n    }\n    return r;\n}\n\nll term(char **begin) {\n    if (**begin == 'S') {\n        *begin += 2;\n        ll r = expr(begin)%MD;\n        *begin += 1;\n        return (r*r)%MD;\n    } else {\n        return numb(begin);\n    }\n}\n\nll expr(char **begin) {\n    ll r = term(begin);\n    while (true) {\n        if (**begin == '>' && *(*begin + 2) != '>') {\n            *begin += 2;\n            r >>= min(60LL, term(begin));\n        } else {\n            break;\n        }\n    }\n    return r;\n}\n\nint main() {\n    while (true) {\n        string ss;\n        getline(cin, ss);\n        if (ss[0] == '#') break;\n        n = 0;\n        for (char c: ss) {\n            if (c != ' ') {\n                s[n] = c;\n                n++;\n            }\n        }\n        s[n] = '@';\n        char *beg = s;\n        ll ans = expr(&beg);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\ntypedef long long ll;\nusing namespace std;\nll mod = 1000000007;\nll expr(string &s,int a,int b);\nll term(string &s,int a,int b);\nll number(string &s,int a,int b);\n\n\nll expr(string &s,int a,int b){\n    int tmp = -1;\n    int dep = 0;\n    for(int i=b;i>=a;i--){\n        if(s[i]=='<'){\n            dep++;\n        }\n        if(s[i]=='>'){\n            dep--;\n        }\n        if(s[i]=='p'&&dep==0){\n            tmp =i;\n            break;\n        }\n    }\n    if(tmp==-1){\n        return term(s,a,b);\n    }else{\n        ll x = expr(s,a,tmp-1);\n        ll y = expr(s,tmp+1,b);\n        if(y>=30)x=0;\n        else for(ll i=0;i<y;i++){\n            x /=2;\n        }\n        return x;\n    }\n}\n\nll term(string &s,int a,int b){\n    if(s[a]=='S'){\n        ll x = expr(s,a+2,b-1);\n        return x*x%mod;\n    }else{\n        return number(s,a,b);\n    }\n}\n\n\nll number(string &s,int a,int b){\n    ll ans = 0;\n    for(int i=a;i<=b;i++){\n        ans *=(ll)10;\n        ans += (ll)(s[i]-'0');\n    }\n    return ans;\n}\n\n\nint main(){\n    while(1){\n        string s1,s;\n        getline(cin,s1);\n        if(s1[0]=='#')break;\n        for(int i=0;i<s1.size();i++){\n            if(s1[i]!=' '){\n                s.push_back(s1[i]);\n            }\n        }\n        vector<bool> p((int)s.size());\n        for(int i=0;i<s.size();i++){\n            if(s[i]!='<'&&s[i]!='>'){\n                if(i==0)continue;\n                if(s[i-1]=='>'){\n                    p[i-1]=1;\n                    p[i-2]= 1;\n                }\n            }\n        }\n        string ss;\n        int tmp = 0;\n        while(tmp<(int)s.size()){\n            if(p[tmp]){\n                ss.push_back('p');\n                tmp+=2;\n            }else{\n                ss.push_back(s[tmp]);\n                tmp++;\n            }\n        }\n        cout << expr(ss,0,(int)ss.size()-1) << endl; \n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\nusing namespace std;\n\ntypedef long long ll;\n\nstring f1(string a){\n  ll x=(ll)atoi(a.c_str());\n  x=(x*x)%mod;\n  ostringstream os;\n  os<<x;\n  //cout<<a<<\" \"<<x<<\" \"<<os.str()<<endl;\n  return os.str();\n}\n\nstring f2(string a,string b){\n  int x=atoi(a.c_str()),y=atoi(b.c_str()),c=1;\n  for(int i=0;i<y;i++){\n    c*=2;\n    if(x<c)return \"0\";\n  }\n  x=x/c;\n  ostringstream os;\n  os<<x;\n  return os.str();\n}\n\nvoid p(vector<string> a){\n  for(int i=0;i<a.size();i++)cout<<a[i]<<\" \";\n  cout<<endl;\n}\n\nstring rec(vector<string> a){\n  //p(a);\n  for(int i=0;i<a.size();i++){\n    if(a[i]==\"S<\"){\n      int l=1,r=0;\n      vector<string> b;\n      for(int j=i+1;j<a.size();j++){\n\tif(a[j]==\"S<\")l++;\n\tif(a[j]==\">\")r++;\n\tif(l==r){\n\t  a[j-1]=rec(b);\n\t  i=j-1;\n\t  break;\n\t}\n        b.push_back(a[j]);\n      }\n    }\n    else if(a[i]==\">>\"){\n      a[i+1]=f2(a[i-1],a[i+1]);\n    }\n    else if(a[i]==\">\")a[i]=f1(a[i-1]);\n  }\n  return a[a.size()-1];\n}\n\nint main()\n{\n  while(1){\n    string s,t;\n    vector<string> a,b;\n    t=\"\";\n    getline(cin,s);\n    if(s[0]=='#')break;\n    for(int i=0;i<s.length();i++)if(s[i]!=' ')t+=s[i];\n    string tmp=\"\";\n    for(int i=0;i<t.length();i++){\n      if(t[i]=='S'){\n\ta.push_back(\"S<\");\n\ti++;\n      }\n      else if(t[i]=='>'){\n\tif(tmp!=\"\")a.push_back(tmp);\n\ttmp=\"\";\n\ta.push_back(\">\");\n      }\n      else tmp+=t[i];\n      if(i==t.length()-1 && tmp!=\"\")a.push_back(tmp);\n    }\n    for(int i=a.size()-1;0<i;i--){\n      if(a[i]!=\">\" && a[i]!=\"S<\"){\n\tb.push_back(a[i]);\n\tif(a[i-1]==\">\"){\n\t  i-=2;\n\t  b.push_back(\">>\");\n\t}\n      }\n      else b.push_back(a[i]);\n    }\n    b.push_back(a[0]);\n    reverse(b.begin(),b.end());\n    cout<<rec(b)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nchar buf[2000001];\n\nll POW[30];\nint length;\n\nll recursive(int left,int right){\n\n\tll ret;\n\n\tint depth = 0;\n\tqueue<int> Q;\n\n\tfor(int i = left; i <= right; i++){\n\t\tif(buf[i] == ' ')continue;\n\n\t\tswitch(buf[i]){\n\t\tcase 'S':\n\t\t\t//Do notghin\n\t\t\tbreak;\n\t\tcase '<':\n\t\t\tdepth++;\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tdepth--;\n\t\t\tbreak;\n\t\tcase '@':\n\t\t\tif(depth == 0){\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t\ti++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//Do nothing\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tll tmp;\n\tint pre = 0,tmp_left,tmp_right;\n\n\tif(Q.empty()){\n\n\t\tint S_loc = -1;\n\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tif(buf[i] == 'S'){\n\t\t\t\tS_loc = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(S_loc == -1){\n\t\t\tret = 0;\n\n\t\t\tfor(int i = left; i <= right; i++){\n\t\t\t\tif(buf[i] == ' ')continue;\n\t\t\t\tret = 10*ret+(buf[i]-'0');\n\t\t\t}\n\n\t\t}else{\n\t\t\tdepth = 0;\n\n\t\t\tfor(int i = S_loc; i <= right; i++){\n\t\t\t\tif(buf[i] == ' ')continue;\n\n\n\t\t\t\tif(buf[i] == '<'){\n\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\ttmp_left = i;\n\t\t\t\t\t}\n\t\t\t\t\tdepth++;\n\t\t\t\t}else if(buf[i] == '>'){\n\n\t\t\t\t\tdepth--;\n\t\t\t\t\tif(depth == 0){\n\t\t\t\t\t\ttmp_right = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\ttmp = recursive(tmp_left+1,tmp_right-1);\n\n\t\t\tret = (tmp*tmp)%MOD;\n\t\t}\n\n\t}else{\n\n\t\twhile(!Q.empty()){\n\t\t\ttmp_right = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tif(pre == 0){\n\t\t\t\tret = recursive(left,tmp_right-1);\n\t\t\t}else{\n\t\t\t\ttmp = recursive(pre+2,tmp_right-1);\n\t\t\t\tif(tmp >= 30 || POW[tmp] > ret){\n\t\t\t\t\tret = 0;\n\t\t\t\t}else{\n\t\t\t\t\tret /= POW[tmp];\n\t\t\t\t}\n\t\t\t}\n\t\t\tpre = tmp_right;\n\t\t}\n\t\ttmp = recursive(pre+2,right);\n\n\t\tif(tmp >= 30 || POW[tmp] > ret){\n\t\t\tret = 0;\n\t\t}else{\n\t\t\tret /= POW[tmp];\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid func(){\n\n\tfor(length = 0; buf[length] != '\\0' && buf[length] != '\\n'; length++);\n\n\tbool is_pre_num = false,is_pre_S = false;\n\n\tfor(int i = length-1; i >= 0; i--){\n\t\tif(buf[i] == ' ')continue;\n\n\t\tif(buf[i] == 'S'){\n\t\t\tis_pre_num = false;\n\t\t\tis_pre_S = true;\n\t\t}else if(buf[i] >= '0' && buf[i] <= '9'){\n\t\t\tis_pre_num = true;\n\t\t\tis_pre_S = false;\n\t\t}else if(buf[i] == '<'){\n\t\t\tis_pre_num = false;\n\t\t\tis_pre_S = false;\n\t\t}else if(buf[i] == '>'){\n\t\t\tif(is_pre_num == true || is_pre_S == true){\n\t\t\t\tbuf[i] = '@';\n\t\t\t\tbuf[i-1] = '@';\n\t\t\t\ti--;\n\t\t\t}\n\t\t\tis_pre_num = false;\n\t\t\tis_pre_S = false;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",recursive(0,length-1));\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 30; i++)POW[i] = (ll)pow(2,i);\n\n\twhile(true){\n\t\tfgets(buf,2000000,stdin);\n\t\tif(buf[0] == '#')break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef string::const_iterator State;\nDef expr(State &i);\nDef term(State &i);\nDef factor(State &i);\nDef number(State &i);\nll MOD=1000000007;\nvoid consume(State &i,char expected){\n\tif(*i==expected)i++;\n\telse{\n\t\texit(0);\n\t}\n}\nDef expr(State &i){\n\tDef out=term(i);\n\twhile(*i=='>'&&*(i+1)=='>'&&(*(i+2)=='S'||isdigit(*(i+2)))){\n\t\ti+=2;\n\t\tDef out1=term(i);\n\t\tout>>=out1;\n\t}\n\treturn out;\n}\nDef term(State &i){\n\tif(isdigit(*i))return number(i);\n\ti++;\n\ti++;\n\tDef out=expr(i);\n\tout=out*out%MOD;\n\ti++;\n\treturn out;\n}\nDef number(State &i){\n\tDef out=0;\n\twhile(isdigit(*i))out=out*10+*(i++)-'0';\n\treturn out;\n}\nint main(){\n\twhile(1){\n\t\tstring s;\n\t\tgetline(cin,s);\n\t\tif(s==\"#\")break;\n\t\ts.erase(remove(s.begin(),s.end(),' '),s.end());\n\t\tState begin=s.begin();\n\t\tcout<<expr(begin)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).*begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 150000000;\nconst long long M = 1000000007;\n\n\ntypedef string::const_iterator State;\nint number(State&);\nint term(State&);\nint expression(State&);\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    if (*begin == 'S') {\n        begin++; // '('????£???°??????\n        begin++;\n        long long ret = expression(begin);\n        begin++; // ')'????£???°??????\n        return ret * ret % M;\n    } else {\n        return number(begin);\n    }\n    return INF;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    int ret = term(begin);\n\n    for (;;) {\n        if(*begin == 'E') return ret;\n        if (*begin == '>' && *(begin + 1) == '>' && *(begin + 2) != '>' && *(begin + 2) != 'E'){\n            begin++;\n            begin++;\n            ret = ret >> min(term(begin), 31);\n        } else {\n            return ret;\n        }\n    }\n\n    return ret;\n}\n\ninline void deleteSpace(string &a){\n    size_t pos;\n    while((pos = a.find_first_of(\" \")) != string::npos){\n        a.erase(pos, 1);\n    }\n}\n\nint main(){\n    std::ifstream ifs(\"/Users/noy/Downloads/2570_in1.txt.html\");\n    string s;\n    while(getline(cin,s),s != \"#\"){\n        deleteSpace(s);\n        s+=\"EEEEE\";\n        State tmp = s.begin();\n        cout << expression(tmp) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n#define int ll\nconst ll MOD = 1e9+7;\ntypedef string::const_iterator state;\n\nstring t;\nint expr(state &end);\n\nll power(ll a,ll b/*,ll mod*/){\n    ll ret=1;\n    if(b>0){\n        ret = power(a,b/2/*,mod*/);\n        if(b%2==0)ret = (ret*ret)/*%mod*/;\n        else ret = (((ret*ret)/*%mod*/)*a)/*%mod*/;\n    }\n    return ret;\n}\n\nint number(state &end){\n    string str=\"\";\n    while(isnumber(*end)){\n        str+=*end;\n        end--;\n    }\n    reverse(all(str));\n    \n    int ret = 0;\n    rep(i,str.size()){\n        ret*=10;\n        ret+=str[i]-'0';\n    }\n    return ret;\n}\n\nint term(state &end){\n    if(*end=='>'){\n        end--;\n        int res = expr(end);\n        end-=2;\n        return (res*res)%MOD;\n    }else if(isnumber(*end)){\n        int res = number(end);\n        return res;\n    }else{\n        throw\"impossible\";\n        return -1;\n    }\n}\n\nint expr(state &end){\n    if(end+1==t.begin())throw \"empty\";\n    \n    vector<int> res;\n    res.pb( term(end) );\n    \n    while(end+1!=t.begin()&&*end!='<'){\n        end-=2;\n        res.pb( term(end) );\n    }\n    \n    reverse(all(res));\n    int tmp = res[0];\n    \n    for(int i=1;i<res.size();i++){\n        rep(j,res[i]){\n            if(tmp==0)break;\n            tmp/=2;\n        }\n    }\n    \n    return tmp;\n}\n\nsigned main(){\n    string s;\n    while(getline(cin,s)&&s!=\"#\"){\n        t = \"\";\n        rep(i,s.size())if(s[i]!=' ')t+=s[i];\n        \n        state st = t.end()-1;\n        int ans;\n        try{\n            ans = expr(st);\n        }catch(char const* e){\n            cout<<\"error\"<<e<<endl;\n            exit(-1);\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint expr();\n\nstring S;\nint idx;\n\nint number()\n{\n  int ret = 0;\n  while(idx < S.size() && isdigit(S[idx])) {\n    ret = ret * 10 + S[idx++] - '0';\n  }\n  return (ret);\n}\n\nint term()\n{\n  if(isdigit(S[idx])) return (number());\n  idx += 2;\n  auto ret = expr();\n  ret = 1LL * ret * ret % mod;\n  idx++;\n  return (ret);\n}\n\nint expr()\n{\n  auto ret = term();\n  int buff = idx;\n  while(buff + 1 < S.size() && S[buff] == '>' && S[buff + 1] == '>') {\n    buff += 2;\n    if(buff >= S.size() || S[buff] == '>') break;\n    idx += 2;\n    auto get = term();\n    for(int i = 0; i < get && ret > 0; i++) ret >>= 1;\n    buff = idx;\n  }\n  return (ret);\n}\n\nint main()\n{\n  string T;\n  while(getline(cin, T), T != \"#\") {\n    idx = 0;\n    S = \"\";\n    for(int i = 0; i < T.size(); i++) if(T[i] != ' ') S += T[i];\n    cout << expr() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n#define ll long long\n\nconst ll MOD = 1000000007;\nusing namespace std;\nstring str;\n\nbool isnum(int idx){ return str[idx] >= '0' && str[idx] <= '9'; }\n\nll dec(ll left, ll right){\n    if(right >= 64 || (1 << right) > left)return 0LL;\n    else return (left >> right);\n}\n\nint getend(int idx){\n    int depth = 1;idx++;\n    for(;depth > 0 && idx < str.size();idx++){\n        switch(str[idx]){\n            case 'S': depth++;\n                      break;\n            case '>': if(idx < str.size()-2 && str[idx+1] == '>' && str[idx+2] != '>'){\n                          idx++;\n                          break;\n                      }\n                      depth--;\n                      break;\n        }\n    }\n    return idx-1;\n}\n\nll tonum(int idx){\n    int start = idx,size = 0;\n    for(;idx < str.size() && isnum(idx); idx++)size++;\n    return stoll(str.substr(start, size));\n}\n\nll calc(int start, int end){\n    //cerr << \"call\" << start << \" : \" << end << endl;\n    bool flag = false;\n    ll val = 0;\n    for(int i = start; i < end; i++){\n        ll temp = 0;\n        if(str[i] == 'S'){\n            int cend = getend(i);\n            temp = calc(i+1, cend);\n            temp = (temp*temp)%MOD;\n            //cerr << \"S\" << temp << \" \" << i << endl;\n            i = cend;\n            //cerr << i << endl;\n        }\n        else if(str[i] == '>'){\n            //cerr << \"flag\" << endl;\n            flag = true;\n            i++;\n            continue;\n        }\n        else{\n            temp = tonum(i);\n            //cerr << \"N\" << temp << \" \" << i << endl;\n            while(i < str.size() && isnum(i)) i++;\n            i--;\n        }\n        if(flag){\n            val = dec(val, temp);\n            //cerr << \"D\" << val << endl;\n            flag = false;\n        }\n        else{\n            val = temp;\n        }\n    }\n    return val;\n}\n\nint main(){\n    while(true){\n        str.clear();\n        string raw;getline(cin, raw);\n        for(auto e : raw)if(e != ' ' && e != '<')str.push_back(e);\n        //cerr << str << endl;\n        if(str == \"#\")break;\n        cout << calc(0, str.size()) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-5L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\n// geometry library\n\n#define int long long\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < eps) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < eps);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist + eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n            (aa * target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor() {\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a) {\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this->data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this->data[i][0]) * (obj.data[0][q]);\n                for (int t = 1; t < obj.data[i].size(); ++t) {\n                    hoge += this->data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix& operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\ntemplate <std::uint_fast64_t mod>\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    modint(ll a) : value(((a% mod) + 2 * mod) % mod) {\n\n    }\n\n    constexpr modint operator+(const modint rhs) const {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint& operator+=(const modint rhs) {\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    constexpr modint& operator-=(const modint rhs) {\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    constexpr modint& operator*=(const modint rhs) {\n        value = (value * rhs.value) % mod;\n        return *this;\n    }\n    constexpr modint& operator/=(modint rhs) {\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    bool operator <(modint rhs) const {\n        return value < rhs.value;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nclass Dice {\npublic:\n    vector<ll> vertexs;\n    //Up: 0,Left: 1,Center: 2,Right: 3,Adj: 4, Down: 5\n    Dice(vector<ll> init) :vertexs(init) {\n\n    }\n    //Look from Center\n    void RtoL() {\n        for (int q = 1; q < 4; ++q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void LtoR() {\n        for (int q = 3; q >= 1; --q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void UtoD() {\n        swap(vertexs[5], vertexs[4]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[0], vertexs[2]);\n    }\n    void DtoU() {\n        swap(vertexs[0], vertexs[2]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[5], vertexs[4]);\n    }\n    bool ReachAble(Dice now) {\n        set<Dice> hoge;\n        queue<Dice> next;\n        next.push(now);\n        hoge.insert(now);\n        while (next.empty() == false) {\n            Dice seeing = next.front();\n            next.pop();\n            if (seeing == *this) return true;\n            seeing.RtoL();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.LtoR();\n            seeing.LtoR();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.RtoL();\n            seeing.UtoD();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.DtoU();\n            seeing.DtoU();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n        }\n        return false;\n    }\n    bool operator ==(const Dice& a) {\n        for (int q = 0; q < 6; ++q) {\n            if (a.vertexs[q] != (*this).vertexs[q]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool operator <(const Dice& a) const {\n        return (*this).vertexs < a.vertexs;\n    }\n};\n\npair<Dice, Dice> TwoDimDice(int center, int up) {\n    int target = 1;\n    while (true) {\n        if (center != target && 7 - center != target && up != target && 7 - up != target) {\n            break;\n        }\n        target++;\n    }\n    return mp(Dice(vector<ll>{up, target, center, 7 - target, 7 - center, 7 - up}), Dice(vector<ll>{up, 7 - target, center, target, 7 - center, 7 - up}));\n}\n\ntuple<Dice, Dice, Dice, Dice> OneDimDice(int center) {\n    int bo = min(center, 7 - center);\n    pair<int, int> goa;\n    if (bo == 1) {\n        goa = mp(2, 3);\n    }\n    else if (bo == 2) {\n        goa = mp(1, 3);\n    }\n    else if (bo == 3) {\n        goa = mp(1, 2);\n    }\n    tuple<Dice, Dice, Dice, Dice> now = make_tuple(Dice(vector<ll>{goa.first, goa.second, center, 7 - goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{goa.first, 7 - goa.second, center, goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{7 - goa.first, goa.second, center, 7 - goa.second, 7 - center, goa.first}),\n        Dice(vector<ll>{7 - goa.first, 7 - goa.second, center, goa.second, 7 - center, goa.first}));\n    return now;\n}\n\ntemplate<typename A, typename B>\nclass Dijkstra {\npublic:\n    vector<vector<pair<int, A>>> vertexs;\n    B Cost_Function;\n    Dijkstra(int n, B cost) : Cost_Function(cost) {\n        vertexs = vector<vector<pair<int, A>>>(n, vector<pair<int, A>>{});\n    }\n    ~Dijkstra() {\n        vertexs.clear();\n    }\n    void add_edge(int a, int b, A c) {\n        vertexs[a].push_back(mp(b, c));\n    }\n    vector<ll> build_result(int StartPoint) {\n        vector<ll> dist(vertexs.size(), 2e18);\n        dist[StartPoint] = 0;\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> next;\n        next.push(make_pair(0, StartPoint));\n        while (next.empty() == false) {\n            pair<ll, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (auto x : vertexs[now.second]) {\n                ll now_cost = now.first + Cost_Function(x.second);\n                if (dist[x.first] > now_cost) {\n                    dist[x.first] = now_cost;\n                    next.push(mp(now_cost, x.first));\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nclass Dinic {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n    vector<vector<edge>> Graph;\n    vector<int> level;\n    vector<int> itr;\n    Dinic(int n) {\n        Graph = vector<vector<edge>>(n, vector<edge>());\n    }\n    void add_edge(int a, int b, int cap) {\n        Graph[a].push_back(edge{ b, cap ,(int)Graph[b].size() });\n        Graph[b].push_back(edge{ a,0,(int)Graph[a].size() - 1 });\n    }\n    void bfs(int s) {\n        level = vector<int>(Graph.size(), -1);\n        level[s] = 0;\n        queue<int> next;\n        next.push(s);\n        while (next.empty() == false) {\n            int now = next.front();\n            next.pop();\n            for (auto x : Graph[now]) {\n                if (x.cap == 0) continue;\n                if (level[x.to] == -1) {\n                    level[x.to] = level[now] + 1;\n                    next.push(x.to);\n                }\n            }\n        }\n    }\n    int dfs(int now, int goal, int val) {\n        if (goal == now) return val;\n        for (int& i = itr[now]; i < (int)Graph[now].size(); ++i) {\n            edge& target = Graph[now][i];\n            if (target.cap > 0 && level[now] < level[target.to]) {\n                int d = dfs(target.to, goal, min(val, target.cap));\n                if (d > 0) {\n                    target.cap -= d;\n                    Graph[target.to][target.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int run(int s, int t) {\n        int ans = 0;\n        int f = 0;\n        while (bfs(s), level[t] >= 0) {\n            itr = vector<int>(Graph.size(), 0);\n            while ((f = dfs(s, t, 1e9)) > 0) {\n                ans += f;\n            }\n        }\n        return ans;\n    }\n};\n\n\nclass HLDecomposition {\npublic:\n    vector<vector<int>> vertexs;\n    vector<int> depth;\n    vector<int> backs;\n    vector<int> connections;\n    vector<int> zip, unzip;\n    HLDecomposition(int n) {\n        vertexs = vector<vector<int>>(n, vector<int>());\n        depth = vector<int>(n);\n        zip = vector<int>(n);\n        unzip = zip;\n    }\n    void add_edge(int a,int b) {\n        vertexs[a].push_back(b);\n        vertexs[b].push_back(a);\n    }\n    int depth_dfs(int now, int back) {\n        depth[now] = 0;\n        for (auto x : vertexs[now]) {\n            if (x == back) continue;\n            depth[now] = max(depth[now], 1 + depth_dfs(x, now));\n        }\n        return depth[now];\n    }\n    void dfs(int now,int backing) {\n        zip[now] = backs.size();\n        unzip[backs.size()] = now;\n        backs.push_back(backing);\n        int now_max = -1;\n        int itr = -1;\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (now_max < depth[x]) {\n                now_max = depth[x];\n                itr = x;\n            }\n        }\n        if (itr == -1) return;\n        connections.push_back(connections.back());\n        dfs(itr,backing);\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (x == itr) continue;\n            connections.push_back(zip[now]);\n            dfs(x, backs.size());\n        }\n        return;\n    }\n    void build() {\n        depth_dfs(0, -1);\n        connections.push_back(-1);\n        dfs(0, -1);\n    }\n    vector<pair<int,int>> query(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        vector<pair<int, int>> ans;\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            ans.push_back(mp(backs[a], a + 1));\n            a = connections[a];\n        }\n        if (a > b) swap(a, b);\n        ans.push_back(mp(a, b + 1));\n        return ans;\n    } \n    int lca(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            a = connections[a];\n        }\n        return unzip[min(a, b)];\n    }\n};\n//by ei1333\n//https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz + 1, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n    using G = function< Monoid(Monoid, OperatorMonoid,int) >;\n    using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n\n    int sz, height;\n    vector< Monoid > data;\n    vector< OperatorMonoid > lazy;\n    const F f;\n    const G g;\n    const H h;\n    const Monoid M1;\n    const OperatorMonoid OM0;\n\n\n    LazySegmentTree(int n, const F f, const G g, const H h,\n        const Monoid& M1, const OperatorMonoid OM0)\n        : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n        sz = 1;\n        height = 0;\n        while (sz < n) sz <<= 1, height++;\n        data.assign(2 * sz, M1);\n        lazy.assign(2 * sz, OM0);\n    }\n\n    void set(int k, const Monoid& x) {\n        data[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n        }\n    }\n\n    inline void propagate(int k) {\n        if (lazy[k] != OM0) {\n            lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n            data[k] = reflect(k);\n            lazy[k] = OM0;\n        }\n    }\n\n    inline Monoid reflect(int k) {\n        if (lazy[k] == OM0) return data[k];\n        for (int q = sz; q >= 0; q /= 2) {\n            if (q & k) {\n                return g(data[k], lazy[k], sz / q);\n            }\n        }\n    }\n\n    inline void recalc(int k) {\n        while (k >>= 1) data[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n    }\n\n    inline void thrust(int k) {\n        for (int i = height; i > 0; i--) propagate(k >> i);\n    }\n\n    void update(int a, int b, const OperatorMonoid& x) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) lazy[l] = h(lazy[l], x), ++l;\n            if (r & 1) --r, lazy[r] = h(lazy[r], x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n\n    Monoid query(int a, int b) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        Monoid L = M1, R = M1;\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) L = f(L, reflect(l++));\n            if (r & 1) R = f(reflect(--r), R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) {\n        return query(k, k + 1);\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            propagate(a);\n            Monoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, reflect(1)))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        thrust(a + sz);\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, reflect(a));\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(reflect(1), R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        thrust(b + sz - 1);\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(reflect(--b), R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\n\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\nint num(State& now) {\n    int ans = 0;\n    while (*now >= '0'&&*now <= '9') {\n        ans *= 10LL;\n        ans += *now - '0';\n        now++;\n    }\n    return ans;\n}\n\nint calc(State& now) {\n    int ans = 0;\n    if (*now == 'S') {\n        now++;\n        now++;\n        ans = calc(now);\n        now++;\n        ans *= ans;\n        ans %= MAX_MOD;\n    }\n    else {\n        ans = num(now);\n    }\n    while (*now == '>' && *(now + 1) == '>' && *(now + 2) != '>') {\n        now += 2;\n        int right = 0;\n        if (*now == 'S') {\n            now++;\n            now++;\n            right = calc(now);\n            right *= right;\n            right %= MAX_MOD;\n            now++;\n        }\n        else {\n            right = num(now);\n        }\n        right = min(right, 50LL);\n        ans >>= right;\n    }\n    return ans;\n}\n\nvoid solve() {\n    while (true) {\n        string s;\n        getline(cin, s);\n        if (s == \"#\") return;\n        string a;\n        REP(q, s.length()) {\n            if (s[q] != ' ') a.push_back(s[q]);\n        }\n        a.push_back('>');\n        a.push_back('>');\n        a.push_back('>');\n        a.push_back('>');\n        a.push_back('>');\n        a.push_back('>');\n        State be = a.begin();\n        cout << calc(be) << endl;\n    }\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\ntypedef long long ll;\nusing namespace std;\nll mod = 1000000007;\nll expr(string &s,int a,int b);\nll term(string &s,int a,int b);\nll number(string &s,int a,int b);\n\n\nll expr(string &s,int a,int b){\n    int tmp = -1;\n    int dep = 0;\n    for(int i=b;i>=a;i--){\n        if(s[i]=='<'){\n            dep++;\n        }\n        if(s[i]=='>'){\n            dep--;\n        }\n        if(s[i]=='p'&&dep==0){\n            tmp =i;\n            break;\n        }\n    }\n    if(tmp==-1){\n        return term(s,a,b);\n    }else{\n        ll x = expr(s,a,tmp-1);\n        ll y = expr(s,tmp+1,b);\n        for(ll i=0;i<y;i++){\n            x /=2;\n        }\n        return x;\n    }\n}\n\nll term(string &s,int a,int b){\n    if(s[a]=='S'){\n        ll x = expr(s,a+2,b-1);\n        return x*x%mod;\n    }else{\n        return number(s,a,b);\n    }\n}\n\n\nll number(string &s,int a,int b){\n    ll ans = 0;\n    for(int i=a;i<=b;i++){\n        ans *=(ll)10;\n        ans += (ll)(s[i]-'0');\n    }\n    return ans;\n}\n\n\nint main(){\n    string s1,s;\n    while(1){\n        getline(cin,s1);\n        s.clear();\n        if(s1[0]=='#')break;\n        for(int i=0;i<s1.size();i++){\n            if(s1[i]!=' '){\n                s.push_back(s1[i]);\n            }\n        }\n        vector<bool> p((int)s.size());\n        for(int i=0;i<s.size();i++){\n            if(s[i]!='<'&&s[i]!='>'){\n                if(i==0)continue;\n                if(s[i-1]=='>'){\n                    p[i-1]=1;\n                    p[i-2]= 1;\n                }\n            }\n        }\n        string ss;\n        int tmp = 0;\n        while(tmp<(int)s.size()){\n            if(p[tmp]){\n                ss.push_back('p');\n                tmp+=2;\n            }else{\n                ss.push_back(s[tmp]);\n                tmp++;\n            }\n        }\n        cout << expr(ss,0,(int)ss.size()-1) << endl; \n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// LL(3)\n\n#include <cctype>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int M=1000000007;\n\nint len;\nchar s[2000010];\n\nint idx;\n\nint expr();\n\nint number(){\n\tint a=0;\n\tassert(isdigit(s[idx]));\n\twhile(isdigit(s[idx])) a=10*a+(s[idx++]-'0');\n\treturn a;\n}\n\nint term(){\n\tif(isdigit(s[idx])){\n\t\treturn number();\n\t}\n\telse{\n\t\tassert(s[idx++]=='S');\n\t\tassert(s[idx++]=='<');\n\t\tint a=expr();\n\t\tassert(s[idx++]=='>');\n\t\treturn ((ll)a*a)%M;\n\t}\n}\n\nint expr(){\n\tint a=term();\n\twhile(s[idx]=='>'\n\t\t&& idx+1<len && s[idx+1]=='>'\n\t\t&& idx+2<len && (s[idx+2]=='S' || isdigit(s[idx+2]))\n\t){\n\t\tidx+=2;\n\t\tint b=term();\n\t\tif(b<32) a>>=b;\n\t\telse     a=0;\n\t}\n\treturn a;\n}\n\nint main(){\n\tfor(;fgets(s,2000010,stdin),s[0]!='#';){\n\t\tlen=strlen(s)-1;\n\t\ts[len]='\\0';\n\n\t\t// trim spaces\n\t\tint k=0;\n\t\trep(i,len) if(s[i]!=' ') s[k++]=s[i];\n\t\tlen=k;\n\t\ts[len]='\\0';\n\n\t\tidx=0;\n\t\tprintf(\"%d\\n\",expr());\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define INF 1e9\n#define EPS 1e-9\n#define MOD (ll)(1e9+7)\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\n\ntemplate<class T>string bitstr(T x){return typeid(T)==typeid(int)?bitset<32>(x).to_string('_','#'):bitset<64>(x).to_string();}\ntemplate<class T>int bitcnt(T x){return typeid(T)==typeid(int)?__builtin_popcount(x):__builtin_popcountll(x);}\ntemplate<class T>int bitdig(T x){return x?typeid(T)==typeid(int)?32-__builtin_clz(x):64-__builtin_clzll(x):0;}\ntemplate<class T>int bitpow(T x){return x?typeid(T)==typeid(int)?__builtin_ctz(x):__builtin_ctzll(x):0;}\n\nll solve(string s){\n\ts+=\"_\";\n\tstack<stack<ll>> num;\n\tstack<bool> sft;\n\tstring n=\"\";\n\tnum.emplace();\n\tsft.push(false);\n\tfor(int i=0;i<s.size();i++){\n\t\t/*\n\t\tcout<<\"=========\"<<endl;\n\t\tcout<<s[i]<<endl;\n\t\tcout<<\"num:\"<<num.size()<<endl;\n\t\tcout<<\"sft:\"<<sft.size()<<\"(\"<<(sft.top()?\"true\":\"false\")<<\")\"<<endl;\n\t\t*/\n\t\tif(!isdigit(s[i])){\n\t\t\tif(n!=\"\"){\n\t\t\t\tif(sft.top()){\n\t\t\t\t\tnum.top().top()>>=min(stoll(n),32ll);\n\t\t\t\t\tsft.top()=false;\n\t\t\t\t}else{\n\t\t\t\t\tnum.top().push(stoll(n));\n\t\t\t\t}\n\t\t\t\tn=\"\";\n\t\t\t}\t\t\t\n\t\t}\n\t\tif(s[i]=='<'){\n\t\t\tnum.emplace();\n\t\t\tsft.push(false);\n\t\t}else if(s[i]=='-'){\n\t\t\tsft.top()=true;\n\t\t\t//cout<<\"shift\"<<endl;\n\t\t}else if(s[i]=='>'){\n\t\t\t//cout<<num.top().top()<<\"(\"<<sft.top()<<\")\"<<endl;\n\t\t\tll r=num.top().top();\n\t\t\tr=r*r%MOD;\n\t\t\tnum.pop();\n\t\t\tsft.pop();\n\t\t\tnum.top().push(r);\n\t\t}else if(s[i]!=' '){\n\t\t\tn+=s[i];\n\t\t\t//cout<<\"n:\"<<n<<endl;\n\t\t}\n\t}\n\treturn num.top().top();\n}\n\n\nint main(){\n\tstring s;\n\twhile(getline(cin,s), s!=\"#\"){\n\t\tfor(auto c=s.find_first_of(\" \");c!=-1;c=s.find_first_of(\" \")){\n\t\t\ts.erase(c,1);\n\t\t}\n\t\tfor(int i=1;i<s.size()-1;i++){\n\t\t\tif(s[i-1]=='>' and s[i]=='>' and s[i+1]!='<' and s[i+1]!='>'){\n\t\t\t\ts.replace(i-1,2,\"-\");\n\t\t\t}\n\t\t}\n\t\tfor(auto c=s.find_first_of(\"S\");c!=-1;c=s.find_first_of(\"S\")){\n\t\t\ts.erase(c,1);\n\t\t}\n\t\tfor(auto c=s.find(\"-0\");c!=-1;c=s.find(\"-0\")){\n\t\t\ts.erase(c,2);\n\t\t}\n\t\tint p=0;\n\t\trep(i,s.size()-1){\n\t\t\tif(s[i]=='<') p++;\n\t\t\tif(s[i]=='>') p--;\n\t\t\tif(p<0){\n\t\t\t\tp=0;\n\t\t\t\ts[i]='-';\n\t\t\t}\n\t\t}\n\t\t//cout<<s<<endl;\n\t\tcout<<solve(s)<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 2000005\ntypedef unsigned long long ll;\nll mod=1e9+7;\n \nbool isNum(char ch){\n  return ('0'<=ch&&ch<='9');\n}\n \nbool check(char ch){\n  return (ch=='\\0'||ch=='>');\n}\n \nint n,a;\nint p;\n \nchar t[MAX];\n \n \nll solve();\n \nll getNum(){\n  if(t[p]=='S'){\n    p+=2;\n    ll res=solve();\n    p++;\n    return (res*res)%mod; \n  }\n  ll res=0;\n  while(isNum(t[p])){\n    res=res*10LL+(t[p]-'0');\n    p++;\n  }\n  return res;\n}\n \nll solve(){\n  ll res=getNum();\n  while(1){\n    if(check(t[p])&&check(t[p+1])&&check(t[p+2])){\n      break;\n    }\n    p+=2;\n    ll num=min(63ULL,getNum());\n \n    res=(res>>num);\n    //cout<<res<<endl;\n  }\n  return res;\n}\n \nint main(){\n  while(1){\n    n=0;\n    while(1){\n      scanf(\"%c\",&t[n]);\n      if(t[n]==' ')continue;\n      if(t[n]=='\\n')break;\n      n++;\n    }\n    if(t[0]=='#')break;\n \n    while(n<MAX){\n      t[n]='\\0';\n      n++;\n    }\n    // printf(\"%s\\n\",t);\n    p=0;\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing P = pair<int, int>;\nusing namespace std;\n\n/*\n<四則演算の式> ::= <乗算除算の式> (+ or -) <乗算除算の式> (+ or -) ...\n<乗算除算の式> ::= <括弧か数> (* or /) <括弧か数> (* or /) ...\n<括弧か数>     ::= '(' <四則演算の式> ')' or <数>\n<数>           ::= ...\n*/\n\nstring ss;\nconst int mod = 1e9 + 7;\n\n// 構文解析\nusing State = string::const_iterator;\nclass ParseError{};\n\nint number(State &begin);\nint term(State &begin);\nint factor(State &begin);\nint expression(State &begin);\n\n// 数字の列をパースして，その数を返す\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n// 乗算除算の式をパースして，その評価結果を返す\nint term(State &begin) {\n    if (*begin == 'S') {\n        begin++; begin++;\n        ll ret = expression(begin);\n        begin++;\n        return ret * ret % mod;\n    }\n    else {\n        return number(begin);\n    }\n}\n\n// 四則演算の式をパースして，その評価結果を返す\nint expression(State &begin) {\n    int ret = term(begin);\n\n    while (ss.end() - begin >= 2) {\n        if (*begin == '>' and *(begin + 1) == '>' and *(begin + 2) != '>') {\n            begin++; begin++;\n            ret = ret >> min(term(begin), 31);\n        }\n        else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint main() {\n    string s;\n    while (getline(cin, s) and s != \"#\") {\n        ss = \"\";\n        for (auto tmp : s) if (tmp != ' ') ss += tmp;\n        State begin = ss.begin();\n        cout << expression(begin) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n\nint l = 0;\nint r;\nvector<int>nums;\nstring st;\nstring nspace() {\n\tstring ans;\n\tfor (auto c : st) {\n\t\tif (c != ' ')ans.push_back(c);\n\t}\n\treturn ans;\n}\nint a = 0;\nlong long int getnum() {\n\tlong long int num = 0;\n\twhile (a!=st.size()&&isdigit(st[a])) {\n\t\tnum = num * 10 + st[a] - '0';\n\t\ta++;\n\t}\n\treturn num;\n}\nlong long int getexpr(bool need,const int ba) {\n\tlong long int num;\n\twhile (a != st.size()) {\n\t\tif (st[a] == 'S') {\n\t\t\ta++;\n\t\t\tassert(st[a] == '<');\n\t\t\ta++;\n\t\t\tnum = getexpr(true, nums[a - 1]);\n\t\t\tnum = num*num % 1000000007;\n\t\t\ta++;\n\t\t}\n\t\telse if (st[a] == '>') {\n\t\t\tif (a == ba) {\n\t\t\t\treturn num;\n\t\t\t}\n\t\t\telse if (nums[a] == -1) {\n\t\t\t\tif (need) {\n\n\t\t\t\t\ta++;\n\t\t\t\t\tassert(st[a] == '>');\n\t\t\t\t\ta++;\n\t\t\t\t\tconst int eva = int(min(31ll, getexpr(false, nums[a - 1])));\n\t\t\t\t\tnum = num >> eva;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn num;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!need) {\n\t\t\t\t\treturn num;\n\t\t\t\t}\n\t\t\t\tassert(false);\n\t\t\t}\n\t\t}\n\t\telse if (isdigit(st[a])) {\n\t\t\tnum = getnum();\n\t\t\tif (!need)return num;\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn num;\n\n}\nint main() {\n\twhile (1) {\n\n\t\tgetline(cin, st);\n\t\tif (st == \"#\")break;\n\t\tst = nspace();\n\t\tl = 0;\n\t\tr = st.size() - 1;\n\t\tnums.resize(st.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\n\t\tint count = 0;\n\t\tvector<bool>rels(st.size(),true);\n\t\tfor (int i = 3; i < st.size(); ++i) {\n\t\t\tif (st[i] == 'S' || isdigit(st[i])) {\n\t\t\t\tif (st[i - 1] == '>'&&st[i - 2] == '>') {\n\t\t\t\t\trels[i - 1] = false;\n\t\t\t\t\trels[i - 2] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstack<int>sta;\n\t\tfor (int i = 0; i < st.size(); ++i) {\n\t\t\tif (st[i] == '<') {\n\t\t\t\tif (rels[i]) {\n\t\t\t\t\tsta.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (st[i] == '>') {\n\t\t\t\tif (rels[i]) {\n\t\t\t\t\tint f = sta.top();\n\t\t\t\t\tnums[f] = i;\n\t\t\t\t\tnums[i] = f;\n\t\t\t\t\tsta.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ta = 0;\n\t\tlong long int ans=getexpr(true,-1);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nstring s;\nint p;\n\nll expr();\n\nll num()\n{\n\tll res;\n\tif (isdigit(s[p]))\n\t{\n\t\tres = 0;\n\t\twhile (isdigit(s[p]))\n\t\t{\n\t\t\tres *= 10;\n\t\t\tres += s[p] - '0';\n\t\t\tp++;\n\t\t}\n\t}\n\telse res = expr();\n\treturn res % MOD;\n}\n\nll term()\n{\n\tll lhs = num();\n\twhile (s[p] == '#')\n\t{\n\t\tp++;\n\t\tll rhs = num();\n\t\tif (rhs > 32) lhs = 0;\n\t\telse lhs >>= rhs;\n\t}\n\treturn lhs;\n}\n\nll expr()\n{\n\tll res;\n\tif (s[p] == 'S')\n\t{\n\t\tp += 2;\n\t\tll tmp = term();\n\t\tp++;\n\t\tres = tmp * tmp % MOD;\n\t}\n\telse res = term();\n\treturn res;\n}\n\nll parse()\n{\n\tp = 0;\n\tll res = term();\n\treturn res;\n}\n\nvoid convert(string &t)\n{\n\ts.clear();\n\tREP(i, t.size())\n\t{\n\t\tif (t[i] != ' ') s += t[i];\n\t}\n\tbool update = true;\n\twhile (update)\n\t{\n\t\tupdate = false;\n\t\tREP(i, s.size() - 2)\n\t\t{\n\t\t\tif (s[i] == '>'&&s[i + 1] == '>' && (s[i + 2] == 'S' || isdigit(s[i + 2])))\n\t\t\t{\n\t\t\t\ts.erase(i, 1);\n\t\t\t\ts[i] = '#';\n\t\t\t\tupdate = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstring t;\n\twhile (getline(cin, t))\n\t{\n\t\tif (t == \"#\") break;\n\t\tconvert(t);\n\t\tcout << parse() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n\ntypedef long long lint;\ntypedef pair<int, int> pii;\n\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\nconst lint MOD = 1e9 + 7;\n\nstring S;\n\nvector<string> split_str(string _s, string _t) {\n\tvector<string> res;\n\tfor (int p = 0; (p = _s.find(_t)) != -1;) {\n\t\tres.push_back(_s.substr(0, p));\n\t\t_s = _s.substr(p + size_of(_t));\n\t}\n\tres.push_back(_s);\n\treturn res;\n}\n\nlint parse(int left, int right, int depth=1000) {\n\t//cout << left << \" \" << right << endl;\n\t//if (left > right) return -1;\n\t\n\tint lcnt = 0, rcnt = 0;\n\tint n_left = -1;\n\tqueue<lint> q;\n\tbool d_flag = false;\n\tint d_pos = -1;\n\tif (depth < 0) {\n\t\treturn MOD;\n\t}\n\tfor_(i,left,right) {\n\t\tif (S[i] == '<') {\n\t\t\tif (lcnt == 0) n_left = i + 1;\n\t\t\tlcnt++;\n\t\t}\n\t\tif (S[i] == '>') {\n\t\t\trcnt++;\n\t\t}\n\t\t\n\t\tif ((S[i] == '<' || S[i] == '|') && d_flag) {\n\t\t\tstring ress = S.substr(d_pos, i - d_pos);\n\t\t\tstringstream ss(ress);\n\t\t\tlint res; ss >> res;\n\t\t\tq.push(res);\n\t\t\td_flag = false;\n\t\t}\n\t\t\n\t\tif (!d_flag && lcnt == 0 && isdigit(S[i])) {\n\t\t\td_pos = i;\n\t\t\td_flag = true;\n\t\t}\n\t\t\n\t\tif (lcnt > 0 && rcnt > 0 && lcnt == rcnt) {\n\t\t\tlint res = parse(n_left, i, depth-1);\n\t\t\t/*\n\t\t\tif (res == -1) {\n\t\t\t\tlcnt = rcnt = 0;\n\t\t\t\tcontinue;\n\t\t\t}*/\n\t\t\tres *= res;\n\t\t\tres %= MOD;\n\t\t\tq.push(res);\n\t\t\tlcnt = rcnt = 0;\n\t\t}\n\t}\n\t\n\tif (d_flag) {\n\t\tstring ress = S.substr(d_pos, right - d_pos);\n\t\tstringstream ss(ress);\n\t\tlint res; ss >> res;\n\t\tq.push(res);\n\t}\n\t\n\tlint res = q.front(); q.pop();\n\twhile (!q.empty()) {\n\t\tlint d = q.front(); q.pop();\n\t\twhile (d > 0 && res > 0) {\n\t\t\tres /= 2;\n\t\t\td--;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nvoid solve() {\n\tint n = size_of(S);\n\tint i = 0;\n\twhile (i < size_of(S)) {\n\t\tif (i > 2 && (S[i] == 'S' || isdigit(S[i]))) {\n\t\t\tif (S[i - 1] == '>' && S[i - 2] == '>') {\n\t\t\t\tS = S.substr(0, i - 2) + \"|\" + S.substr(i);\n\t\t\t\ti = i - 2;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tcout << S << endl;\n\tn = size_of(S);\n\tcout << parse(0, n) << endl;\n}\n\nint main() {\n\tstring input;\n\twhile (getline(cin, input)) {\n\t\tif (input[0] == '#') break;\n\t\tvector< string > split = split_str(input, \" \");\n\t\tint v_size = size_of(split);\n\t\tS = \"\";\n\t\tfor_(i,0,v_size) S += split[i];\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar s[2000001], t[2000001];\nint len;\n\nlong long calc(int &en)\n{\n    if (t[en] == '>'){\n        en--;\n        long long l = calc(en);\n        l = (l * l) % 1000000007;\n        en -= 2;\n        if (en < 0 || t[en] == '<') return (l);\n        en -= 2;\n        return (calc(en) >> l);\n    }\n    else {\n        long long l = 0, b = 1;\n        while (isdigit(t[en])){\n            l = l + (t[en--] - '0') * b;\n            b *= 10;\n        }\n        \n        if (en < 0 || t[en] == '<') return (l);\n        en -= 2;\n        \n        long long l2 = calc(en);\n        while (l-- && l2){\n            l2 /= 2;\n        }\n        \n        return (l2);\n    }\n}\n\nint main()\n{\n    while (fgets(s, sizeof(s), stdin) && s[0] != '#'){\n        len = 0;\n        for (int i = 0; s[i]; i++){\n            if (s[i] != ' ' && s[i] != '\\n') t[len++] = s[i];\n        }\n        \n        --len;\n        printf(\"%lld\\n\", calc(len));\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).*begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int M = 1000000007;\n\nstring s;\n\ntypedef string::const_iterator State;\nint number(State&);\nint term(State&);\nint expression(State&);\n\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    if (*begin == 'S') {\n        begin++; begin++;\n        long long ret = expression(begin);\n        begin++;\n        return ret * ret % M;\n    } else {\n        return number(begin);\n    }\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    int ret = term(begin);\n\n    while(s.end() - begin >= 2){\n        if (*begin ==  '>' && *(begin + 1) == '>' && *(begin + 2) != '>'){\n            begin++; begin++;\n            ret = ret >> min(term(begin), 31);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint main(){\n    string tmp;\n    while(getline(cin,tmp),tmp != \"#\"){\n        s=\"\";\n        for(auto it:tmp) if(it != ' ') s+=it;\n        State state = s.begin();\n        cout << expression(state) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define NDEBUG\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cstdlib>\n#include <iostream>\nusing namespace std;\n\nconstexpr long long mod = 1000000007;\n\nlong long expr(string::const_reverse_iterator &it);\nlong long term(string::const_reverse_iterator &it);\nlong long number(string::const_reverse_iterator &it);\n\nlong long expr(string::const_reverse_iterator &it) {\n\tlong long res = term(it);\n\tif(*it == '>') {\n\t\t++it;\n\t\tassert(*it == '>');\n\t\t++it;\n\t\tres = (expr(it) >> min(32ll, res));\n\t}\n\treturn res;\n}\n\nlong long term(string::const_reverse_iterator &it) {\n\tif(isdigit(*it)) return number(it);\n\n\tassert(*it == '>');\n\t++it;\n\tlong long res = expr(it);\n\tassert(*it == '<');\n\t++it;\n\tassert(*it == 'S');\n\t++it;\n\treturn (res * res) % mod;\n}\n\nlong long number(string::const_reverse_iterator &it) {\n\tlong long res = 0;\n\tfor(int d = 1; isdigit(*it); d *= 10, ++it) {\n\t\tres += d * (*it - '0');\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(string expression; getline(cin, expression) && expression != \"#\";) {\n\t\texpression.erase(remove(expression.begin(), expression.end(), ' '), expression.end());\n\t\tauto it = expression.crbegin();\n\t\tcout << expr(it) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cctype>\n#include <cassert>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nvoid preprocess(const std::string &s, std::string &t) {\n  std::string u;\n  for (char ch: s)\n    if (!isspace(ch))\n      u += ch;\n\n  t.clear();\n  for (size_t i=0; i<u.length(); ++i) {\n    if (u[i] == 'S') {\n      assert(u[++i] == '<');\n      t += \"(\";\n    } else if (isdigit(u[i])) {\n      t += u[i];\n    } else if (u[i] == '>') {\n      if (i+1 < u.length() && u[i+1] == '>'\n          && i+2 < u.length() && isdigit(u[i+2])) {\n\n        t += '>';\n        t += u[i+=2];\n      } else {\n        t += ')';\n      }\n    } else {\n      assert(false);\n    }\n  }\n}\n\nstatic const intmax_t MOD=1e9+7;\n\nintmax_t parse(const std::string &s, size_t &i, size_t preced=0) {\n\n  if (preced == 1) {\n    if (s[i] == '(') {\n      intmax_t tmp=parse(s, ++i, 0);\n      assert(s[i] == ')');\n      ++i;\n      return tmp*tmp % MOD;\n    }\n    if (isdigit(s[i])) {\n      intmax_t res=s[i]-'0';\n      while (++i < s.length() && isdigit(s[i]))\n        res = res*10+s[i]-'0';\n      return res;\n    }\n    assert(false);\n  }\n  intmax_t res=parse(s, i, 1);\n  while (i < s.length()) {\n    if (s[i] != '>') break;\n    intmax_t tmp=parse(s, ++i, 1);\n    if (tmp >= 63) {\n      res = 0;\n    } else {\n      res >>= tmp;\n    }\n  }\n  return res;\n}\n\nint testcase_ends() {\n  char buf[2000010];\n  fgets(buf, sizeof buf, stdin);\n  std::string s=std::move(buf), t;\n  if (s == \"#\\n\") return 1;\n  preprocess(s, t);\n  size_t i=0;\n  printf(\"%jd\\n\", parse(t, i));\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n\ntypedef long long lint;\ntypedef pair<int, int> pii;\n\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\nconst lint MOD = 1e9 + 7;\n\nstring S;\n\nvector<string> split_str(string _s, string _t) {\n\tvector<string> res;\n\tfor (int p = 0; (p = _s.find(_t)) != -1;) {\n\t\tres.push_back(_s.substr(0, p));\n\t\t_s = _s.substr(p + size_of(_t));\n\t}\n\tres.push_back(_s);\n\treturn res;\n}\n\nlint parse(int left, int right, int depth=100000) {\n\t//cout << left << \" \" << right << endl;\n\t//if (left > right) return -1;\n\t\n\tint lcnt = 0, rcnt = 0;\n\tint n_left = -1;\n\tqueue<lint> q;\n\tbool d_flag = false;\n\tint d_pos = -1;\n\tif (depth < 0) {\n\t\treturn MOD;\n\t}\n\tfor_(i,left,right) {\n\t\tif (S[i] == '<') {\n\t\t\tif (lcnt == 0) n_left = i + 1;\n\t\t\tlcnt++;\n\t\t}\n\t\tif (S[i] == '>') {\n\t\t\trcnt++;\n\t\t}\n\t\t\n\t\tif ((S[i] == '<' || S[i] == '|') && d_flag) {\n\t\t\tstring ress = S.substr(d_pos, i - d_pos);\n\t\t\tstringstream ss(ress);\n\t\t\tlint res; ss >> res;\n\t\t\tq.push(res);\n\t\t\td_flag = false;\n\t\t}\n\t\t\n\t\tif (!d_flag && lcnt == 0 && isdigit(S[i])) {\n\t\t\td_pos = i;\n\t\t\td_flag = true;\n\t\t}\n\t\t\n\t\tif (lcnt > 0 && rcnt > 0 && lcnt == rcnt) {\n\t\t\tlint res = parse(n_left, i, depth-1);\n\t\t\t/*\n\t\t\tif (res == -1) {\n\t\t\t\tlcnt = rcnt = 0;\n\t\t\t\tcontinue;\n\t\t\t}*/\n\t\t\tres *= res;\n\t\t\tres %= MOD;\n\t\t\tq.push(res);\n\t\t\tlcnt = rcnt = 0;\n\t\t}\n\t}\n\t\n\tif (d_flag) {\n\t\tstring ress = S.substr(d_pos, right - d_pos);\n\t\tstringstream ss(ress);\n\t\tlint res; ss >> res;\n\t\tq.push(res);\n\t}\n\t\n\tlint res = q.front(); q.pop();\n\twhile (!q.empty()) {\n\t\tlint d = q.front(); q.pop();\n\t\twhile (d > 0 && res > 0) {\n\t\t\tres /= 2;\n\t\t\td--;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nvoid solve() {\n\tint n = size_of(S);\n\tint i = 0;\n\twhile (i < size_of(S)) {\n\t\tif (i > 2 && (S[i] == 'S' || isdigit(S[i]))) {\n\t\t\tif (S[i - 1] == '>' && S[i - 2] == '>') {\n\t\t\t\tS = S.substr(0, i - 2) + \"|\" + S.substr(i);\n\t\t\t\ti = i - 2;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tcout << S << endl;\n\tn = size_of(S);\n\tcout << parse(0, n) << endl;\n}\n\nint main() {\n\tstring input;\n\twhile (getline(cin, input)) {\n\t\tif (input[0] == '#') break;\n\t\tvector< string > split = split_str(input, \" \");\n\t\tint v_size = size_of(split);\n\t\tS = \"\";\n\t\tfor_(i,0,v_size) S += split[i];\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n\nint l = 0;\nint r;\nvector<int>nums;\nstring st;\nstring nspace() {\n\tstring ans;\n\tfor (auto c : st) {\n\t\tif (c != ' ')ans.push_back(c);\n\t}\n\treturn ans;\n}\nint a = 0;\nlong long int getnum() {\n\tlong long int num = 0;\n\twhile (a!=st.size()&&isdigit(st[a])) {\n\t\tnum = num * 10 + st[a] - '0';\n\t\ta++;\n\t}\n\treturn num;\n}\nlong long int getexpr(bool need,const int ba) {\n\tlong long int num;\n\twhile (a != st.size()) {\n\t\tif (st[a] == 'S') {\n\t\t\ta++;\n\t\t\tassert(st[a] == '<');\n\t\t\ta++;\n\t\t\tnum = getexpr(true, nums[a - 1]);\n\t\t\tnum = num*num % 1000000007;\n\t\t\ta++;\n\t\t}\n\t\telse if (st[a] == '>') {\n\t\t\tif (a == ba) {\n\t\t\t\treturn num;\n\t\t\t}\n\t\t\telse if (nums[a] == -1) {\n\t\t\t\ta++;\n\t\t\t\tassert(st[a] == '>');\n\t\t\t\ta++;\n\t\t\t\tconst int eva = int(min(64ll, getnum()));\n\t\t\t\tnum=num >> eva;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassert(false);\n\t\t\t}\n\t\t}\n\t\telse if (isdigit(st[a])) {\n\t\t\tnum = getnum();\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn num;\n\n}\nint main() {\n\twhile (1) {\n\n\t\tgetline(cin, st);\n\t\tif (st == \"#\")break;\n\t\tst = nspace();\n\t\tl = 0;\n\t\tr = st.size() - 1;\n\t\tnums.resize(st.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\n\t\tint count = 0;\n\t\tvector<bool>rels(st.size(),true);\n\t\tfor (int i = 3; i < st.size(); ++i) {\n\t\t\tif (st[i] == 'S' || isdigit(st[i])) {\n\t\t\t\tif (st[i - 1] == '>'&&st[i - 2] == '>') {\n\t\t\t\t\trels[i - 1] = false;\n\t\t\t\t\trels[i - 2] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstack<int>sta;\n\t\tfor (int i = 0; i < st.size(); ++i) {\n\t\t\tif (st[i] == '<') {\n\t\t\t\tif (rels[i]) {\n\t\t\t\t\tsta.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (st[i] == '>') {\n\t\t\t\tif (rels[i]) {\n\t\t\t\t\tint f = sta.top();\n\t\t\t\t\tnums[f] = i;\n\t\t\t\t\tnums[i] = f;\n\t\t\t\t\tsta.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ta = 0;\n\t\tlong long int ans=getexpr(true,-1);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nstring s;\nint p;\nint bns();\nint g_A(){\n  int a=0;\n  if(s[p]=='S'){\n    p+=2;\n    a=bns();\n    a=a*a%1000000007;\n    p++;\n  }\n  else if(isdigit(s[p])){\n    while(isdigit(s[p])){\n      a=a*10+(s[p]-'0');\n      p++;\n    }\n  }\n  return a;\n}\nint bns(){\n  int a=g_A();\n  while(s[p]=='>'&&s[p+1]=='>'&&isdigit(s[p+2])){\n    p+=2;\n    int b=g_A();\n    a>>=min(b,60LL);\n  }\n  return a;\n}\nmain(){\n  while(getline(cin,s),s[0]!='#'){\n    p=0;\n    s.erase(remove(s.begin(),s.end(),' '),s.end());\n    cout<<bns()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef string::const_iterator State;\nDef expr(State &i);\nDef term(State &i);\nDef factor(State &i);\nDef number(State &i);\nll MOD=1000000007;\nstring s;\nvoid consume(State &i,char expected){\n\tif(*i==expected)i++;\n\telse{\n\t\texit(0);\n\t}\n}\nDef expr(State &i){\n\tDef out=term(i);\n\twhile(*i=='>'&&*(i+1)=='>'&&(*(i+2)=='S'||isdigit(*(i+2)))){\n\t\ti+=2;\n\t\tDef out1=term(i);\n\t\tout>>=out1;\n\t}\n\treturn out;\n}\nDef term(State &i){\n\tif(isdigit(*i))return number(i);\n\ti++;\n\ti++;\n\tDef out=expr(i);\n\tout=out*out%MOD;\n\ti++;\n\treturn out;\n}\nDef number(State &i){\n\tDef out=0;\n\twhile(isdigit(*i))out=out*10+*(i++)-'0';\n\treturn out;\n}\nint main(){\n\twhile(1){\n\t\tgetline(cin,s);\n\t\tif(s==\"#\")break;\n\t\ts.erase(remove(s.begin(),s.end(),' '),s.end());\n\t\tState begin=s.begin();\n\t\tcout<<expr(begin)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nconst ll MOD = 1e9 + 7;\n\nll to_num(int& i,const string& S){\n    ll res = 0;\n    while(true){\n        if(S[i] >= '0' && S[i] <= '9'){\n            res = res*10 + (S[i] - '0');\n            i++;\n        }else{\n            break;\n        }\n    }\n    return res;\n}\n\nvoid brank(int& i, const string& S){\n    while(S[i] == ' ')i++;\n}\n\nll calc(ll T){\n    ll cnt = 1;\n    while(T/2){\n        cnt++;\n        T>>=1;\n    }\n    return cnt;\n}\n\nll expr(int& i,const string& S){\n    ll res = 0;\n    brank(i,S);\n    bool expr_flag = false;\n    for(;i < S.length();){\n        brank(i,S);\n        if(S[i] == 'S'){\n            i++;\n            brank(i,S);\n            i++;\n            if(!expr_flag){\n                ll tmp = expr(i,S);\n                (tmp*=tmp)%=MOD;\n                res = tmp;\n                expr_flag = true;\n            }else{\n                ll tmp = expr(i,S);\n                (tmp*=tmp)%=MOD;\n                \n                ll digit = calc(res);\n                if(tmp > digit)res = 0;\n                else res >>= tmp;\n            }\n            i++;\n            continue;\n        }\n        if(S[i] >= '0' && S[i] <= '9'){\n            if(!expr_flag){\n                res = to_num(i,S);\n                expr_flag = true;\n            }else{\n                ll tmp = to_num(i,S);\n                \n                ll digit = calc(res);\n                if(tmp > digit) res = 0;\n                else res >>=tmp;\n            }\n            continue;\n        }\n        if(S[i] == '>'){\n            if(i < S.length() - 1){\n                if(S[i] == '>' && S[i+1] == '>'){\n                    i+=2;\n                    continue;\n                }\n            }\n            return res;\n        }\n    }\n    return res;\n}\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    string S;\n    cout << calc(8) << endl;\n    while(true){\n        getline(cin,S);\n        if(S == \"#\") break;\n        int i = 0;\n        cout << expr(i,S)<< endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\n\nstring s;\nint i;\n\n/*\n * expr   ::= term [ \"-\" term]*\n * term   ::= number | \"S<\" expr \">\"\n * number ::= [0-9]+\n */\n\nll expr();\nll term();\nll number();\n\nll expr(){\n    ll val=term();\n    while(s[i]=='-'){\n        i++;\n        val=val>>min(term(),32ll);\n    }\n    return val;\n}\nll term(){\n    if(isdigit(s[i])) return number();\n    i+=2;\n    ll val=expr();\n    val=val*val%1'000'000'007;\n    i++;\n    return val;\n}\nll number(){\n    ll val=0;\n    while(isdigit(s[i])){\n        val=val*10+s[i++]-'0';\n    }\n    return val;\n}\n\nbool input(){return getline(cin,s) and s!=\"#\";}\n\nll solve(){\n    string t=\"\";\n    for(auto c:s) if(c!=' ') t+=c;\n    s=t;\n    for(int i=2;i<s.size();i++){\n        if(isdigit(s[i]) or s[i]=='S'){\n            if(s[i-1]=='>' and s[i-2]=='>'){\n                s[i-1]='-';\n                s.erase(s.begin()+i-2);\n            }\n        }\n    }\n    i=0;\n    return expr();\n}\n\n\nint main(void){\n    while(input()){\n        cout<<solve()<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,ll> P;\n  \nstatic const double EPS = 1e-8;\nstatic const ll MOD = 1000000007;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nP expr(int pos,const string& str);\nP term(int pos,const string& str);\nP number(int pos,const string& str);\n\nP expr(int pos,const string& str){\n  P p1 = term(pos,str);\n  pos = p1.first;\n\n  while(pos + 2 < str.size() \n        && str[pos] == '>'\n        && str[pos+1] == '>'\n        && isdigit(str[pos+2])){\n    while(str[pos] == '>') pos++; //for '>'\n    P p2 = term(pos,str);\n    p1.second >>= min(p2.second,50LL);\n    pos = p2.first;\n  }\n  return P(pos,p1.second);\n}\n\nP term(int pos,const string& str){\n  if(str[pos] == 'S'){\n    pos+=2; // for \"S<\"\n    P p1 = expr(pos,str);\n    pos = p1.first;\n    pos++; // for \">\"\n    return P(pos,((p1.second % MOD) * (p1.second % MOD)) % MOD);\n  }\n  \n  else{\n    return number(pos,str);\n  }\n}\n\nP number(int pos,const string& str){\n  \n  string tmp = \"0\";\n  while(pos < str.size() && isdigit(str[pos])){\n    tmp.push_back(str[pos]);\n    pos++;\n  }\n  return P(pos,atol(tmp.c_str()));\n}\n\nint main(){\n  string str;\n  while(getline(cin,str)){\n    if(str == \"#\") continue;\n\n    string tmp = \"\";\n    for(int i=0;i<str.size();i++){\n      if(str[i] != ' '){\n        tmp.push_back(str[i]);\n      }\n    }\n    str = tmp;\n    P p = expr(0,str);\n    cout << p.second << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\nchar tmp[1000];\n#define nextInt(n) scanf(\"%d\",&n)\n#define nextLong(n) scanf(\"%lld\",&n)//I64d\n#define nextDouble(n) scanf(\"%lf\",&n)  \n#define nextChar(n) scanf(\"%c\",&n)\n#define nextString(n) scanf(\"%s\",tmp);n=tmp\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\nll MOD=1000000007;\n\nnamespace SyntaxAnalysis{\n\ttypedef string::const_iterator Cursor;\n\t\n\tclass ParseError{};\n\t\n\tmap<char,int> vmap;\n\tmap<char,bool> used;\n\n\tclass Syntax{\n\tpublic:\n\t\tconst string& s;\n\t\tCursor& c;\n\t\tSyntax(const string& s,Cursor& c):s(s),c(c){}\n\n\t\tll expression(){\n\t\t\tll r=term();\n\t\t\tif(c==s.end())return r;\n\t\t\tif(*c=='<')return r;\n\t\t\tc++;c++;\n\t\t\tll l =expression();\t\n\t\t\treturn l>>min(r,31LL);\n\t\t}\n\n\t\tll term(){\n\t\t\tif(*c=='>'){\n\t\t\t\tc++;\n\t\t\t\tll t=expression();\n\t\t\t\tc++;c++;\n\t\t\t\treturn t*t%MOD;\n\t\t\t}\n\t\t\tll v=number();//DUMP(v);\n\t\t\treturn v;\n\t\t}\n\t\tll number(){\n\t\t    stringstream ss;\n\t\t    while(isdigit(*c)){\n\t\t        ss << *c;c++;\n\t\t    }\n\t\t  \tstring tmp;ss>> tmp;ss.clear();reverse(ALL(tmp));ss<<tmp;\n\t\t\tll ret;ss >> ret;return ret;\n\t\t}\n\t};\n}\nusing namespace SyntaxAnalysis;\n\n\nclass Main{\npublic:\n\n\tstring l;\t\t\n\tbool input(){\n\t\tgetline(cin,l);\n\t\tif(l==\"#\")return false;\n\t\tl.erase(remove(l.begin(), l.end(), ' '), l.end());//空白除去\n\t\treturn true;\n\t}\n\n\tvoid run(){\n\t\twhile(input()){\n\t\t\treverse(ALL(l));\n\t\t\tCursor s=l.begin();\n\t\t\tSyntax sy(l,s);\n\t\t\tcout <<sy.expression()<<endl;\n\t\t}\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntypedef string::const_iterator State;\nclass ParseError {};\nvoid sp(State&);\nint expr(State&);\nint term(State&);\nint number(State&);\n\nstring s;\nint expr(State &begin) {\n\tint ret = term(begin);\n\twhile(s.end()-begin>=2) {\n\t\t//cout << *begin << \" \" << begin-s.begin() << \" \" << ret << endl;\n\t\tif(*begin == '>' && *(begin+1) == '>' && *(begin+2) != '>') {\n\t\t\tbegin++; // >\n\t\t\tbegin++; // >\n\t\t\tret >>= min(term(begin), 31);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\t//cout << \"expr:\" << ret << endl;\n\treturn ret;\n}\n\nint term(State &begin) {\n\tif(*begin == 'S') {\n\t\tbegin++;\n\t\tbegin++;\n\t\t//cout << \"s \" << *begin << \" \" << begin-s.begin() << endl;\n\t\tll ret = expr(begin);\n\t\tret = (ret*ret) % MOD;\n\t\tbegin++;\n\t\t//cout << \"te:\" << ret << endl;\n\t\treturn ret;\n\t} else {\n\t\t//cout << \"tn:\" << *begin << \" \" << begin - s.begin() << endl;\n\t\tint ret = number(begin);\n\t\t//cout << \"tenum:\" << ret << endl;\n\t\treturn ret;\n\t}\n}\n\nint number(State &begin) {\n\tint ret = 0;\n\twhile(isdigit(*begin)) {\n\t\tret *= 10;\n\t\tret += *begin - '0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nsigned main(void)\n{\n\twhile(true) {\n\t\tstring t;\n\t\tgetline(cin, t);\n\t\tif(t == \"#\") break;\n\n\t\ts = \"\";\n\t\tREP(i, t.size()) if(t[i] != ' ') s += t[i];\n\t\t//cout << s << endl;\n\t\tState begin = s.begin();\n\t\tcout << expr(begin) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\nusing ll = long long;\nconstexpr ll MOD = 1000000007;\ninline ll sf(const ll k, const ll n) { return k > 32 ? 0 : n >> k; }\ninline ll sq(const long long n) { return n * n % MOD; }\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\n\nint main()\n{\n    while (true) {\n        auto input = []() {\n            string s;\n            getline(cin, s);\n            string ans;\n            for (ll i = s.size() - 1, st = 0, v = false; i >= 0; i--) {\n                const char c = s[i];\n                if (isdigit(c)) { ans.push_back(c), v = true; }\n                if (c == '>') {\n                    if (v) {\n                        ans.push_back('%'), v = false, i--;\n                    } else {\n                        ans.push_back('<'), st++;\n                    }\n                }\n                if (c == '<') { ans.push_back('>'), v = true, st--; }\n            }\n            return ans;\n        };\n        const string S = input();\n        if (S.empty()) { break; }\n        ll pos = 0, ans = 0;\n        auto dfs = fix([&](auto&& self) -> ll {\n            if (pos >= S.size()) { return ans; }\n            const char c = S[pos];\n            if (c == '<') {\n                pos++;\n                const ll sub = self(self);\n                ans = sq(sub);\n                return self(self);\n            } else if (c == '%') {\n                pos++;\n                const ll prev = ans;\n                const ll next = self(self);\n                ans = sf(prev, next);\n                return self(self);\n            } else if (isdigit(c)) {\n                ll num = 0;\n                for (ll d = 1; pos < S.size() and isdigit(S[pos]); d *= 10, pos++) { num += d * (S[pos] - '0'); }\n                ans = num;\n                return self(self);\n            } else {\n                pos++;\n                return self(self);\n            }\n        });\n        dfs();\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define _A_ 1\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll MOD = 1000000007LL;\n\nint len;\n//string parse;\nconst int MAX = 2000010;\nchar parse[MAX];\nint pos;\n\nll expression();\n  \nll fact(){\n  if( parse[pos] == 'S' ) {\n    pos+=2; // S<xx>\n    ll p = expression();\n    if( pos >= len ) return -1LL;\n    pos++;\n    return ( ( p % MOD ) * ( p % MOD ) ) % MOD;\n  } else {\n    if( pos >= len || !isdigit(parse[pos]) ) return -1LL;\n    ll p = 0;\n    while( '0' <= parse[pos] && parse[pos] <= '9' ){\n      p *= 10LL;\n      p += (ll)(parse[pos] - '0');\n      pos++;\n    }\n    return p;\n  }\n}\n\nll expression(){\n\n  ll p = fact();\n\n  if( p == -1LL ) return -1LL;\n\n  //\n\n  while( parse[pos] == '>' && ( pos + 1 < len && parse[pos+1] == '>' ) ){\n    int temp = pos;\n    ll  temp_v = p;      \n    pos += 2;\n    \n    ll q = fact();\n    if( q == -1LL ) {\n      pos = temp;\n      return temp_v;\n    }\n    for(ll i=0;i<q;i++) {\n      p >>= 1LL;\n      if( p == 0LL ) break;\n    }\n    \n  }\n  return p;\n}\n\n\nint main(){\n  string s;\n  while( _A_ ){\n    getline(cin,s);\n    if( s == \"#\" ) break;\n    string temp = \"\";\n    len = 0;\n    rep(i,(int)s.size()) if( s[i] != ' ' ) {\n      parse[len] = s[i];\n      len++;\n    }\n    pos = 0;\n    parse[len] = '\\0';\n    assert( len < MAX );\n    //cout << expression() << endl;\n    printf(\"%lld\\n\",expression());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nconst ll MOD = 1e9 + 7;\n\nll to_num(int& i,const string& S){\n    ll res = 0;\n    while(true){\n        if(S[i] >= '0' && S[i] <= '9'){\n            res = res*10 + (S[i] - '0');\n            i++;\n        }else{\n            break;\n        }\n    }\n    return res;\n}\n\nvoid brank(int& i, const string& S){\n    while(S[i] == ' ')i++;\n}\n\nll calc(ll T){\n    ll cnt = 1;\n    while(T/2){\n        cnt++;\n        T>>=1;\n    }\n    return cnt;\n}\n\nll expr(int& i,const string& S){\n    ll res = 0;\n    brank(i,S);\n    bool expr_flag = false;\n    for(;i < S.length();){\n        brank(i,S);\n        if(S[i] == 'S'){\n            i++;\n            brank(i,S);\n            i++;\n            if(!expr_flag){\n                ll tmp = expr(i,S);\n                (tmp*=tmp)%=MOD;\n                res = tmp;\n                expr_flag = true;\n            }else{\n                ll tmp = expr(i,S);\n                (tmp*=tmp)%=MOD;\n                \n                ll digit = calc(res);\n                if(tmp > digit)res = 0;\n                else res >>= tmp;\n            }\n            i++;\n            continue;\n        }\n        if(S[i] >= '0' && S[i] <= '9'){\n            if(!expr_flag){\n                res = to_num(i,S);\n                expr_flag = true;\n            }else{\n                ll tmp = to_num(i,S);\n                \n                ll digit = calc(res);\n                if(tmp > digit) res = 0;\n                else res >>=tmp;\n            }\n            continue;\n        }\n        if(S[i] == '>'){\n            if(i < S.length() - 1){\n                if(S[i] == '>' && S[i+1] == '>'){\n                    i+=2;\n                    continue;\n                }\n            }\n            return res;\n        }\n    }\n    return res;\n}\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    string S;\n    while(true){\n        getline(cin,S);\n        if(S == \"#\") break;\n        int i = 0;\n        cout << expr(i,S)<< endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n#define ll long long\n\nconst ll MOD = 1000000007;\nusing namespace std;\nstring str;\n\nbool isnum(char c){ return c >= '0' && c <= '9'; }\n\nll tonum(int &idx){\n    int start = idx,size = 0;\n    for(; idx < str.size() && isnum(str[idx]);idx++)size++;\n    idx--;\n    return stoll(str.substr(start, size));\n}\n\npair<ll, int> calc(int idx){\n    ll val = 0;\n    //cerr << \"call\" <<  idx << endl;\n    for(;idx < str.size(); idx++){\n        if(str[idx] == 'S'){\n            auto temp = calc(idx+1);\n            val = temp.first;\n            assert(idx < temp.second);\n            idx = temp.second;\n            //cerr << \"S\";\n            //cerr << val << \" \" << idx << endl;\n        }\n        else if(str[idx] == '>'){\n            //cerr << str[idx] << str[idx+1] << str[idx+2] << endl;\n            if(idx < str.size()-2 && str[idx+1] == '>' && str[idx+2] != '>'){\n                if(isnum(str[idx+2])){\n                    idx += 2;\n                    ll dec = tonum(idx);\n                    //cerr << \"dec :\" << dec << endl;\n                    val = dec >= 64 ? 0 : (val >> dec);\n                }\n                else{\n                    auto temp = calc(idx+2);\n                    val = (val >> temp.first);\n                    assert(idx <= temp.second);\n                    idx = temp.second;\n                }\n                //cerr << \"D\";\n                //cerr << val << \" \" << idx << endl;\n            }\n            else{\n                return make_pair((val*val)%MOD, idx);\n            }\n        }\n        else if(str[idx] >= '0' && str[idx] <= '9'){\n            val = tonum(idx);\n        }\n    }\n    return make_pair(val,idx);\n}\n\nint main(){\n    while(true){\n        str.clear();\n        string raw;getline(cin, raw);\n        for(auto e : raw)if(e != ' ' && e != '<')str.push_back(e);\n        //cerr << str << endl;\n        if(str == \"#\")break;\n        cout << calc(0).first << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define _A_ 1\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll MOD = 1000000007LL;\n\nint len;\n//string parse;\nconst int MAX = 2000010;\nchar parse[MAX];\nint pos;\n\nll expression();\n  \nll fact(){\n  if( parse[pos] == 'S' ) {\n    pos+=2; // S<xx>\n    ll p = expression();\n    if( pos >= len ) return -1LL;\n    pos++;\n    return ( ( p % MOD ) * ( p % MOD ) ) % MOD;\n  } else {\n    if( pos >= len || !isdigit(parse[pos]) ) return -1LL;\n    ll p = 0;\n    while( '0' <= parse[pos] && parse[pos] <= '9' ){\n      p *= 10LL;\n      p += (ll)(parse[pos] - '0');\n      pos++;\n    }\n    return p;\n  }\n}\n\nll expression(){\n\n  ll p = fact();\n\n  if( p == -1LL ) return -1LL;\n\n  //\n\n\n  while( parse[pos] == '>' && ( pos + 1 < len && parse[pos+1] == '>' ) ){\n    int temp = pos;\n      ll  temp_v = p;      \n      pos += 2;\n\n      ll q = fact();\n      if( q == -1LL ) {\n\n\tpos = temp;\n\treturn temp_v;\n      }\n      for(ll i=0;i<q;i++) p >>= 1LL;\n    }\n    return p;\n  }\n\n\nint main(){\n  string s;\n  while( _A_ ){\n    getline(cin,s);\n    if( s == \"#\" ) break;\n    string temp = \"\";\n    len = 0;\n    rep(i,(int)s.size()) if( s[i] != ' ' ) {\n      parse[len] = s[i];\n      len++;\n    }\n    pos = 0;\n    parse[len] = '\\0';\n    assert( len < MAX );\n    //cout << expression() << endl;\n    printf(\"%lld\\n\",expression());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint number(string &S, int &i);\nint term(string &S, int &i);\nint expr(string &S, int &i);\n\nint number(string &S, int &i){\n    int ret = 0;\n    while(isdigit(S[i])){\n        ret*=10;\n        ret+=S[i]-'0';\n        i++;\n    }\n    return ret;\n}\n\nint term(string &S, int &i){\n    const int64_t mod=1000000007;\n    if(S[i]=='S'){\n        i+=2;//\"S<\"\n        int64_t x = expr(S,i);\n        i++;//'>'\n        x=x*x%mod;\n        return x;\n    }else{\n        return number(S,i);\n    }\n}\n\nint expr(string &S, int &i){\n    int ret = term(S,i);\n    while(i<S.size()){\n        int cnt=0;\n        for(int j=i;j<S.size();j++){\n            if(S[j]=='>')cnt++;\n            else break;\n        }\n        if(cnt==2&&i+2<S.size()){\n            i+=2;//\">>\"\n            int y = term(S,i);\n            if(y>=31){\n                ret=0;\n            }else{\n                ret>>=y;\n            }\n            continue;\n        }else{\n            return ret;\n        }\n    }\n    return ret;\n}\n\nint main(){\n    string S;\n    while(getline(cin,S)){\n        if(S[0]=='#') break;\n        int i=0;\n        string ss;\n        for(auto c:S){\n            if(c!=' ') ss.push_back(c);\n        }\n        // cout<<ss<<endl;\n        cout<<expr(ss,i)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cctype>\n#include<cstdio>\n\nusing namespace std;\n\nchar s[2345678];\nchar *p;\n\nint term();\n\nint expr(){\n  int rv=term();\n  for(;;){\n    bool f=false;\n    char *r=p;\n    while(*r==' '){\n      r++;\n    }\n    if(r[0]=='>'&&r[1]=='>'){\n      r+=2;\n      while(*r==' '){\n\tr++;\n      }\n      if(*r=='S'||isdigit(*r)){\n\tf=true;\n\tp=r;\n\tint sw=term();\n\tif(sw>32){\n\t  rv=0;\n\t}else{\n\t  rv>>=sw;\n\t}\n      }\n    }\n    if(!f)break;\n  }\n  return rv;\n}\n\nint term(){\n  if(isdigit(*p)){\n    int d,n;\n    sscanf(p,\"%d%n\",&d,&n);\n    p+=n;\n    return d;\n  }else{\n    p++;\n    while(*p==' '){\n      p++;\n    }\n    p++;\n    while(*p==' '){\n      p++;\n    }\n    int rv=expr();\n    while(*p==' '){\n      p++;\n    }\n    p++;\n    return 1LL*rv*rv%1000000007;\n  }\n}\n\nint main(){\n  while(cin.getline(s,sizeof(s)),s[0]!='#'){\n    p=s;\n    cout<<expr()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\nusing ll = long long;\nconstexpr ll MOD = 1000000007;\ninline ll sf(const ll k, const ll n) { return k > 32 ? 0 : n >> k; }\ninline ll sq(const long long n) { return n * n % MOD; }\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\n\nint main()\n{\n    while (true) {\n        auto input = []() {\n            string s;\n            getline(cin, s);\n            string ans;\n            for (ll i = s.size() - 1, st = 0, v = false; i >= 0; i--) {\n                const char c = s[i];\n                if (isdigit(c)) { ans.push_back(c), v = true; }\n                if (c == '>') {\n                    if (v) {\n                        ans.push_back('%'), v = false, i--;\n                    } else {\n                        ans.push_back('<'), st++;\n                    }\n                }\n                if (c == '<') { ans.push_back('>'), v = true, st--; }\n            }\n            return ans;\n        };\n        const string S = input();\n        if (S.empty()) { break; }\n        ll pos = 0, ans = 0;\n        auto dfs = fix([&](auto&& self) -> ll {\n            if (pos >= S.size()) { return ans; }\n            const char c = S[pos];\n            if (c == '<') {\n                pos++;\n                const ll sub = self(self);\n                ans = sq(sub);\n                return self(self);\n            } else if (c == '%') {\n                pos++;\n                const ll prev = ans;\n                const ll next = self(self);\n                ans = sf(prev, next);\n                return self(self);\n            } else if (isdigit(c)) {\n                ll num = 0;\n                for (ll d = 1; pos < S.size() and isdigit(S[pos]); d *= 10, pos++) { num += d * (S[pos] - '0'); }\n                ans = num;\n                return self(self);\n            } else {\n                pos++;\n                return self(self);\n            }\n        });\n        dfs();\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst long long INF = 1e15;\nconst long long M = 1000000007LL;\n\n//x^n mod M\nlong long power(long long x, long long n){\n    long long res = 1;\n    if(n > 0){\n        res = power(x, n / 2);\n        if(n % 2 == 0) res = (res * res) % M;\n        else res = (((res * res) % M) * x ) %M;\n    }\n    return res;\n}\n\ntypedef string::const_iterator State;\nlong long number(State&);\nlong long term(State&);\nlong long expression(State&);\n\n// ??°??????????????????????????????????????°????????????\nlong long number(State &begin) {\n    long long ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n\n// ?????????????????????????????????????????????????????????????????????\nlong long term(State &begin) {\n    if (*begin == 'S') {\n        begin++; // '('????£???°??????\n        begin++;\n        long long ret = expression(begin);\n        begin++; // ')'????£???°??????\n        return (ret * ret) % M;\n    } else {\n        return number(begin);\n    }\n    return INF;\n\n    //long long ret = factor(begin);\n\n    //for (;;) {\n    //    if (*begin == '*') {\n    //        begin++;\n    //        ret *= factor(begin);\n    //    } else if (*begin == '/') {\n    //        begin++;\n    //        ret /= factor(begin);\n    //    } else {\n    //        break;\n    //    }\n    //}\n\n    //return ret;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nlong long expression(State &begin) {\n    long long ret = term(begin);\n\n    for (;;) {\n        if (*begin == '>' && *(begin + 1) == '>' && *(begin + 2) != '>') {\n            begin++;\n            begin++;\n            long long tmp = term(begin);\n            if(log(static_cast<double>(ret)) * 3.3223 < static_cast<double>(tmp)) ret = 0;\n            else ret = ret / power(2,tmp);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\ninline void deleteSpace(string &a){\n    size_t pos;\n    while((pos = a.find_first_of(\" \")) != string::npos){\n        a.erase(pos, 1);\n    }\n}\n\nint main(){\n    string s;\n    while(getline(cin,s),s[0] != '#'){\n        deleteSpace(s);\n        State tmp = s.begin();\n        cout << expression(tmp) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<sstream>\n#include <cctype>\n#include <stack>\n#define fuck(x) cerr<<#x<<\" <- \"<<x <<endl;\n\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\nstring s, t;\n\nstack<char> op;\nstack<ll> num;\n\nvoid pop() {\n    char c = op.top(); op.pop();\n//    printf(\"pop(%c)\\n\", c);\n\n    if (c == '$') {\n//        printf(\"numsz = %d\\n\", num.size());\n        ll b = num.top(); num.pop();\n        ll a = num.top(); num.pop();\n        b = min(b, 100LL);\n//        printf(\"%lld$%lld\\n\", a, b);\n        ll res = (a >> b);\n        num.push(res);\n    }\n    else {\n        ll a = num.top();\n        num.pop();\n        num.push((a * a) % mod);\n    }\n}\n\nll work() {\n    int n = s.length();\n    ll x = 0;\n    char la = 0;\n    for (int i = 0; i < n; i++) {\n//        printf(\"i = %d, %c\\n\", i, s[i]);\n        if (s[i] == '[') {\n            op.push(s[i]);\n            x = 0;\n        }\n        else if (s[i] == '$') {\n            if (isdigit(la)) num.push(x);\n            while (!op.empty() && op.top() != '[') pop();\n            op.push(s[i]);\n            x = 0;\n        }\n        else if (s[i] == ']') {\n            if (isdigit(la)) num.push(x);\n            while (op.top() != '[') pop();\n            pop();\n            x = 0;\n        }\n        else {\n            x = (x * 10 + s[i] - '0') % mod;\n        }\n        la = s[i];\n    }\n    if (isdigit(la)) num.push(x);\n    while (!op.empty()) pop();\n}\n\n\n\nint main() {\n//    freopen(\"F.in\", \"r\", stdin);\n    string line;\n    while (1) {\n        while (!num.empty()) num.pop();\n        while (!op.empty()) op.pop();\n        getline(cin, line);\n        if (line[0] == '#') break;\n        int len = line.length();\n        bool flag = 0;\n        s = \"\";\n        char la = 0;\n        for (int i = len-1; i >= 0; i--) {\n//            printf(\"i = %d, la=%c\\n\", i, la);\n            if (line[i] == '>') {\n                if (la == '[' || isdigit(la)) {\n                    la = '$';\n                    i--;\n                }\n                else {\n                    la = ']';\n                }\n            }\n            else if (line[i] == '<') {\n                la = '[';\n            }\n            else if (isdigit(line[i])) {\n                la = line[i];\n            }\n            else continue;\n\n            s += la;\n        }\n        reverse(s.begin(), s.end());\n\n//        cout << \"org: \" << line << endl;\n//        cout << \"new: \" << s << endl;\n        work();\n        while (op.size()!=0);\n        while (num.size()!=1);\n//        printf(\"op: %d, num: %d, ans: %lld\\n\", op.size(), num.size(), num.top());\n        printf(\"%lld\\n\", num.top());\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define INF 1e9\n#define EPS 1e-9\n#define MOD (ll)(1e9+7)\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\n\ntemplate<class T>string bitstr(T x){return typeid(T)==typeid(int)?bitset<32>(x).to_string('_','#'):bitset<64>(x).to_string();}\ntemplate<class T>int bitcnt(T x){return typeid(T)==typeid(int)?__builtin_popcount(x):__builtin_popcountll(x);}\ntemplate<class T>int bitdig(T x){return x?typeid(T)==typeid(int)?32-__builtin_clz(x):64-__builtin_clzll(x):0;}\ntemplate<class T>int bitpow(T x){return x?typeid(T)==typeid(int)?__builtin_ctz(x):__builtin_ctzll(x):0;}\n\nstring solve(string s,bool f=false){\n\tint open=0,len=0;\n\tif(f){\n\t\tif(s.find(\"--\")==-1) return s;\n\t\tstring a=\"\",b=\"\";\n\t\tfor(int i=s.size()-1;i>=0;i--){\n\t\t\tif(s[i]=='-'){\n\t\t\t\ta=s.substr(0,i-1);\n\t\t\t\tb=s.substr(i+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tauto ans=to_string(stoll(solve(a,true))>>min(32ll,stoll(b)));\n\t\t//cout<<a<<\">>\"<<b<<\"=\"<<ans<<endl;\n\t\treturn ans;\n\t}\n\tfor(int i=0;i<s.size();i++){\n\t\tif(s[i]=='<') open=i,len=0;\n\t\telse if(s[i]=='>'){\n\t\t\t//cout<<s.substr(open+1,len)<<endl;\n\t\t\tll inner=stoll(solve(s.substr(open+1,len),true));\n\t\t\t//cout<<inner<<endl;\n\t\t\tinner=inner*inner%MOD;\n\t\t\tint l=to_string(inner).length();\n\t\t\ts.replace(open-1, len+3, to_string(inner));\n\t\t\ti=0, open=0, len=0;\n\t\t}else len++;\n\t\t//cout<<\"fin:\"<<s<<endl;\n\t}\n\treturn solve(s,true);\n}\n\n\nint main(){\n\tstring s;\n\twhile(getline(cin,s), s!=\"#\"){\n\t\tfor(auto c=s.find_first_of(\" \");c!=-1;c=s.find_first_of(\" \")){\n\t\t\ts.erase(c,1);\n\t\t}\n\t\tfor(int i=1;i<s.size()-1;i++){\n\t\t\tif(s[i-1]=='>' and s[i]=='>' and s[i+1]!='<' and s[i+1]!='>' and s[i+1]!='S'){\n\t\t\t\ts[i-1]=s[i]='-';\n\t\t\t}\n\t\t}\n\t\tcout<<solve(s)<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <cstdio>\n#include <stack>\n#include <map>\n#define rep(i,n) for(long long i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll MOD = 1000000007;\n\nstring str;\nmap<ll,ll> ma;\n\nll f1(ll x, ll y){\n\trep(i,y){\n\t\tx /= 2;\n\t\tif(x == 0) break;\n\t}\n\treturn x;\n}\n\nll f2(ll x){\t\n\treturn (x*x)%MOD;\n} \n\nP dfs(ll st, ll en, bool start){\n\tll ret = 0;\n\tif('0' <= str[st] && str[st] <= '9'){\n\t\tret = str[st]-'0';\n\t\twhile(st+1 <= en && '0' <= str[st+1] && str[st+1] <= '9'){\n\t\t\tst++;\n\t\t\tret = ret*10+str[st]-'0';\n\t\t}\n\t} else{\n\t\tret = f2(dfs(st+2,ma[st+1]-1,0).first);\n\t\tst = ma[st+1];\n\t}\n\tif(start) return P(ret,st);\n\twhile(st+3 <= en){\n\t\tP acc = dfs(st+3,en,1);\n\t\tret = f1(ret,acc.first);\n\t\tst = acc.second;\n\t}\n\treturn P(ret,st);\n}\n\nvoid solve(){\n\tma.clear();\n\tstring s;\n\trep(i,str.size()) if(str[i] != ' ') s.push_back(str[i]);\n\tstr  = s;\n\tstr += \">>\";\n\tcout << str << endl;\n\tstack<ll> sta;\n\trep(i,str.size()){\n\t\tif(str[i] == '<'){\n\t\t\tsta.push(i);\n\t\t}\n\t\tif(i+2 <= str.size()-1 && str[i] == '>' && str[i+1] == '>' && str[i+2] == '>'){\n\t\t\tma[sta.top()] = i;\n\t\t\tsta.pop();\n\t\t}\n\t}\n\tcout << dfs(0,str.size()-3,0).first << endl;\n}\n\nint main(){\n\twhile(true){\n\t\tgetline(cin,str);\n\t\tif(str == \"#\") break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\ntypedef string::const_iterator State;\nll expression(State &begin);\nll number(State &begin);\n\nstring str;\n\nll number(State &begin){\n\tll ret=0;\n\twhile(isdigit(*begin)){\n\t\tret*=10LL;\n\t\tret%=MOD;\n\t\tret+=*begin-'0';\n\t\tbegin++;\n\t}\n\treturn ret;\n}\n\nll calc(ll a,ll b){\n\tif(b>35LL){\n\t\treturn 0;\n\t}else{\n\t\tll v=1;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tv*=2LL;\n\t\t}\n\t\treturn a/v;\n\t}\n}\n\nll term(State &begin){\n\tll ret=number(begin);\n\twhile(1){\n\t\tif(*begin=='S'){\n\t\t\tbegin++;\n\t\t\twhile(*begin==' ')begin++;\n\t\t\tbegin++;\n\t\t\twhile(*begin==' ')begin++;\n\t\t\tret=expression(begin);\n\t\t\tret=ret*ret%MOD;\n\t\t\twhile(*begin==' ')begin++;\n\t\t\tbegin++;\n\t\t}else{\n\t\t\treturn ret;\n\t\t}\n\t}\n}\n\nll expression(State &begin){\n\tll ret=term(begin);\n\twhile(1){\n\t\t//cout << ret << *begin << endl;\n\t\tif(*begin=='S'){\n\t\t\tbegin++;\n\t\t\twhile(*begin==' ')begin++;\n\t\t\tbegin++;\n\t\t\twhile(*begin==' ')begin++;\n\t\t\tret=expression(begin);\n\t\t\tret=ret*ret%MOD;\n\t\t\twhile(*begin==' ')begin++;\n\t\t\tbegin++;\n\t\t}else if(*begin=='b'){\n\t\t\tbegin++;\n\t\t\tbegin++;\n\t\t\twhile(*begin==' ')begin++;\n\t\t\tret=calc(ret,term(begin));\n\t\t}else if(*begin==' '){\n\t\t\tbegin++;\n\t\t}else{\n\t\t\treturn ret;\n\t\t}\n\t}\n}\n\n\nint main(void){\n\twhile(1){\n\t\tgetline(cin,str);\n\t\tif(str==\"#\")break;\n\t\tfor(int i=0;i<str.size();i++){\n\t\t\tif(isdigit(str[i]) || str[i]=='S'){\n\t\t\t\tint v=i-1;\n\t\t\t\twhile(v>=0){\n\t\t\t\t\tif(isdigit(str[v]) || str[v]=='S')break;\n\t\t\t\t\tif(str[v]=='<')break;\n\t\t\t\t\tif(str[v]=='>'){\n\t\t\t\t\t\tstr[v]='b';\n\t\t\t\t\t\tstr[v-1]='b';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tv--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tState begin=str.begin();\n\t\tprintf(\"%lld\\n\",expression(begin));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n\ntypedef long long lint;\ntypedef pair<int, int> pii;\n\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\nconst lint MOD = 1e9 + 7;\n\nstring S;\n\nvector<string> split_str(string _s, string _t) {\n\tvector<string> res;\n\tfor (int p = 0; (p = _s.find(_t)) != -1;) {\n\t\tres.push_back(_s.substr(0, p));\n\t\t_s = _s.substr(p + size_of(_t));\n\t}\n\tres.push_back(_s);\n\treturn res;\n}\n\nlint parse(int left, int right, int depth=12500) {\n\t//cout << left << \" \" << right << endl;\n\t//if (left > right) return -1;\n\t\n\tint lcnt = 0, rcnt = 0;\n\tint n_left = -1;\n\tqueue<lint> q;\n\tbool d_flag = false;\n\tint d_pos = -1;\n\tif (depth < 0) {\n\t\treturn MOD;\n\t}\n\tfor_(i,left,right) {\n\t\tif (S[i] == '<') {\n\t\t\tif (lcnt == 0) n_left = i + 1;\n\t\t\tlcnt++;\n\t\t}\n\t\tif (S[i] == '>') {\n\t\t\trcnt++;\n\t\t}\n\t\t\n\t\tif ((S[i] == '<' || S[i] == '|') && d_flag) {\n\t\t\tstring ress = S.substr(d_pos, i - d_pos);\n\t\t\tstringstream ss(ress);\n\t\t\tlint res; ss >> res;\n\t\t\tq.push(res);\n\t\t\td_flag = false;\n\t\t}\n\t\t\n\t\tif (!d_flag && lcnt == 0 && isdigit(S[i])) {\n\t\t\td_pos = i;\n\t\t\td_flag = true;\n\t\t}\n\t\t\n\t\tif (lcnt > 0 && rcnt > 0 && lcnt == rcnt) {\n\t\t\tlint res = parse(n_left, i, depth-1);\n\t\t\t/*\n\t\t\tif (res == -1) {\n\t\t\t\tlcnt = rcnt = 0;\n\t\t\t\tcontinue;\n\t\t\t}*/\n\t\t\tres *= res;\n\t\t\tres %= MOD;\n\t\t\tq.push(res);\n\t\t\tlcnt = rcnt = 0;\n\t\t}\n\t}\n\t\n\tif (d_flag) {\n\t\tstring ress = S.substr(d_pos, right - d_pos);\n\t\tstringstream ss(ress);\n\t\tlint res; ss >> res;\n\t\tq.push(res);\n\t}\n\t\n\tlint res = q.front(); q.pop();\n\twhile (!q.empty()) {\n\t\tlint d = q.front(); q.pop();\n\t\twhile (d > 0 && res > 0) {\n\t\t\tres /= 2;\n\t\t\td--;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nvoid solve() {\n\tint n = size_of(S);\n\tint i = 0;\n\twhile (i < size_of(S)) {\n\t\tif (i > 2 && (S[i] == 'S' || isdigit(S[i]))) {\n\t\t\tif (S[i - 1] == '>' && S[i - 2] == '>') {\n\t\t\t\tS = S.substr(0, i - 2) + \"|\" + S.substr(i);\n\t\t\t\ti = i - 2;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tcout << S << endl;\n\tn = size_of(S);\n\tcout << parse(0, n) << endl;\n}\n\nint main() {\n\tstring input;\n\twhile (getline(cin, input)) {\n\t\tif (input[0] == '#') break;\n\t\tvector< string > split = split_str(input, \" \");\n\t\tint v_size = size_of(split);\n\t\tS = \"\";\n\t\tfor_(i,0,v_size) S += split[i];\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing ll = long long;\nconstexpr ll MOD = (1e9) + 7;\n\nclass Parser {\n  private:\n    std::string s;\n    std::string::const_iterator it;\n    \n  public:\n    Parser (std::string s) {\n        this->s = s;\n        it = this->s.begin();\n    }\n\n    ll number()\n    {\n        ll res = 0;\n        while (isdigit(*it)) {\n            res *= 10;\n            res += *it - '0';\n            ++it;\n        }\n        return res;\n    }\n    \n    ll term()\n    {\n        ll res = 0;\n        if (isdigit(*it)) {\n            res = number();\n        } else if (*it == 'S') {\n            it += 2; // S <            \n            res = expr() % MOD;            \n            res = (res * res) % MOD;\n            ++it; // >\n        }\n        return res;\n    }\n\n    bool is_term(char ch)\n    {\n        return (isdigit(ch) || ch == 'S');\n    }\n\n    void shift(ll &x, ll y)\n    {\n        for (ll i = 0; i < y; i++) {\n            if (x == 0) {\n                return;\n            }\n            x >>= 1;\n        }\n    }\n    \n    ll expr()\n    {\n        ll res = term();\n        while (*it == '>' && *(it + 1) == '>' && is_term(*(it + 2))) {\n            it += 2;\n            shift(res, term());            \n            res %= MOD;\n        }\n        return res;\n    }\n};\n\nstd::string remove_spaces(const std::string &s)\n{\n    std::string res;\n    for (char c : s) {\n        if (c != ' ') {\n            res += c;\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    std::string s;\n    while (1) {\n        std::getline(std::cin, s);\n        if (s == \"#\") {\n            break;\n        }\n        s = remove_spaces(s);\n        \n        Parser p{s};\n        std::cout << p.expr() << std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cctype>\n#include <cmath>\n \nusing namespace std;\n \ntypedef string::const_iterator iter;\ntypedef long long lint;\n \n#define DEBUG(s,x) // cerr << s << \" : \" << x << endl\n \nlint term(iter &it);\nlint number(iter &it);\n \nlint expr(iter &it) {\n    lint res = term(it);\n    while('>' == *it && '>' == *(it + 1) && (isdigit(*(it + 2)) || *(it + 2) == 'S')) {\n        it++;\n        it++;\n        int res2 = term(it);\n        res = res / pow(2.0, res2);\n    }\n    return res;\n}\n \nlint term(iter &it) {\n    if(isdigit(*it)) return number(it);\n    it++; // skip S\n    it++; // skip <\n    lint res = expr(it);\n    it++; // skip >\n    res = (res * res) % 1000000007LL;\n    return res;\n}\n \nlint number(iter &it) {\n    lint res = 0;\n    while(isdigit(*it)) {\n        res *= 10;\n        res += (*it - '0');\n        it++;\n    }\n    return res;\n}\n \nstring replaceAll(string s, string f, string t) {\n    string r;\n    for(size_t p = 0; (p = s.find(f)) != string::npos; ){\n        r += s.substr(0, p) + t;\n        s = s.substr(p + f.size());\n    }\n    return r + s;\n}\n \nint main() {\n    while(true) {\n        string s;\n        getline(cin, s);\n        if(s == \"#\") break;\n        s = replaceAll(s, \" \", \"\");\n        s += \"@@@\";\n        iter it = s.begin();\n        lint res = expr(it);\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<string>\n#include<queue>\ntypedef long long ll;\nusing namespace std;\nll mod = 1000000007;\nll expr(string &s,int a,int b);\nll term(string &s,int a,int b);\nll number(string &s,int a,int b);\n\n\nll calc(string &s,int &t){\n    ll ans;\n    bool flag =0;\n    while(t<s.size()){\n        if(s[t]=='>'||s[t]=='$'){\n            t++;\n            break;\n        }\n        if(s[t]>='0'&&s[t]<='9'){\n            ll tmp = 0;\n            while(s[t]>='0'&&s[t]<='9'){\n                tmp *=10;\n                tmp +=(ll)(s[t]-'0');\n                t++;\n            }\n            if(!flag){\n                ans = tmp;\n                flag = 1;\n            }else{\n                if(tmp>=30)ans= 0;\n                for(int i=0;i<tmp;i++){\n                    ans/=2;\n                }\n            }\n        }\n        if(s[t]=='p'){\n            t++;\n        }\n        if(s[t]=='S'){\n            t += 2;\n            ll tmp = calc(s,t);\n            tmp = tmp*tmp%mod;\n            if(!flag){\n                ans = tmp;\n                flag = 1;\n            }else{\n                if(tmp>=30)ans= 0;\n                for(int i=0;i<tmp;i++){\n                    ans/=2;\n                }\n            }\n        }\n    }\n    return ans;\n}\n\n\nint main(){\n    while(1){\n        string s1,s;\n        getline(cin,s1);\n        if(s1[0]=='#')break;\n        for(int i=0;i<s1.size();i++){\n            if(s1[i]!=' '){\n                s.push_back(s1[i]);\n            }\n        }\n        vector<bool> p((int)s.size());\n        for(int i=0;i<s.size();i++){\n            if(s[i]!='<'&&s[i]!='>'){\n                if(i==0)continue;\n                if(s[i-1]=='>'){\n                    p[i-1]=1;\n                    p[i-2]= 1;\n                }\n            }\n        }\n        string ss;\n        int tmp = 0;\n        while(tmp<(int)s.size()){\n            if(p[tmp]){\n                ss.push_back('p');\n                tmp+=2;\n            }else{\n                ss.push_back(s[tmp]);\n                tmp++;\n            }\n        }\n        ss.push_back('$');\n        int cnt = 0;\n        cout << calc(ss,cnt) << endl; \n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconstexpr ll MOD = 1000000007;\nclass SyntaxAnalysis\n{\n    using T = ll;\n\npublic:\n    SyntaxAnalysis(const string& S) : S{S} {}\n    T Expression() { return pos = 0, expression(); }\n\nprivate:\n    static constexpr char PLUS = '+';\n    static constexpr char MINUS = '-';\n    static constexpr char PRODUCT = '%';\n    static constexpr char DIVIDE = '/';\n    static constexpr char BRACE = '<';\n    static T plus(const ll n, const ll k) { return n + k; }\n    static T minus(const ll n, const ll k) { return n - k; }\n    static T product(const ll n, const ll k) { return k >= 64 ? 0LL : n >> k; }\n    static T divide(const ll n, const ll k) { return n / k; }\n    static T brace(const ll n) { return n * n % MOD; }\n    static bool is_digit(const char c) { return '0' <= c and c <= '9'; }\n    static T encode(const char c) { return c - '0'; }\n    ll number()\n    {\n        ll ans = 0;\n        for (; pos < S.size() and is_digit(S[pos]); pos++) { ans = ans * 10LL + encode(S[pos]); }\n        return ans;\n    }\n    ll factor()\n    {\n        if (S[pos] == BRACE) {\n            ll ans = 0;\n            return pos++, ans = brace(expression()), pos++, ans;\n        } else {\n            return number();\n        }\n    }\n    ll term()\n    {\n        ll ans = factor();\n        for (; pos < S.size();) {\n            if (S[pos] == PRODUCT) {\n                pos++, ans = product(ans, factor());\n            } else if (S[pos] == DIVIDE) {\n                pos++, ans = divide(ans, factor());\n            } else {\n                break;\n            }\n        }\n        return ans;\n    }\n    ll expression()\n    {\n        ll ans = term();\n        for (ll f = 0; pos < S.size();) {\n            if (S[pos] == PLUS) {\n                pos++, f = term(), ans = plus(ans, f);\n            } else if (S[pos] == MINUS) {\n                pos++, f = term(), ans = minus(ans, f);\n            } else {\n                break;\n            }\n        }\n        return ans;\n    }\n    int pos = 0;\n    string S;\n};\n\nint main()\n{\n    while (true) {\n        auto input = []() {\n            string s;\n            getline(cin, s);\n            string ans;\n            for (ll i = s.size() - 1, st = 0, v = false; i >= 0; i--) {\n                const char c = s[i];\n                if (isdigit(c)) { ans.push_back(c), v = true; }\n                if (c == '>') {\n                    if (v) {\n                        ans.push_back('%'), v = false, i--;\n                    } else {\n                        ans.push_back('>'), st++;\n                    }\n                }\n                if (c == '<') { ans.push_back('<'), v = true, st--; }\n            }\n            reverse(ans.begin(), ans.end());\n            return ans;\n        };\n        const string S = input();\n        if (S.empty()) { break; }\n        SyntaxAnalysis sy(S);\n        cout << sy.Expression() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\n\n\nint l = 0;\nint r;\nvector<int>nums;\nstring st;\nstring nspace() {\n\tstring ans;\n\tfor (auto c : st) {\n\t\tif (c != ' ')ans.push_back(c);\n\t}\n\treturn ans;\n}\nint a = 0;\nlong long int getnum() {\n\tlong long int num = 0;\n\twhile (a!=st.size()&&isdigit(st[a])) {\n\t\tnum = num * 10 + st[a] - '0';\n\t\ta++;\n\t}\n\treturn num;\n}\nlong long int getexpr(bool need,const int ba) {\n\tlong long int num;\n\twhile (a != st.size()) {\n\t\tif (st[a] == 'S') {\n\t\t\ta++;\n\t\t\tassert(st[a] == '<');\n\t\t\ta++;\n\t\t\tnum = getexpr(true, nums[a - 1]);\n\t\t\tnum = num*num % 1000000007;\n\t\t\ta++;\n\t\t}\n\t\telse if (st[a] == '>') {\n\t\t\tif (a == ba) {\n\t\t\t\treturn num;\n\t\t\t}\n\t\t\telse if (nums[a] == -1) {\n\t\t\t\tif (need) {\n\n\t\t\t\t\ta++;\n\t\t\t\t\tassert(st[a] == '>');\n\t\t\t\t\ta++;\n\t\t\t\t\tconst int eva = int(min(64ll, getexpr(false, nums[a - 1])));\n\t\t\t\t\tnum = num >> eva;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn num;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!need) {\n\t\t\t\t\treturn num;\n\t\t\t\t}\n\t\t\t\tassert(false);\n\t\t\t}\n\t\t}\n\t\telse if (isdigit(st[a])) {\n\t\t\tnum = getnum();\n\t\t\tif (!need)return num;\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\treturn num;\n\n}\nint main() {\n\twhile (1) {\n\n\t\tgetline(cin, st);\n\t\tif (st == \"#\")break;\n\t\tst = nspace();\n\t\tl = 0;\n\t\tr = st.size() - 1;\n\t\tnums.resize(st.size());\n\t\tfill(nums.begin(), nums.end(), -1);\n\n\t\tint count = 0;\n\t\tvector<bool>rels(st.size(),true);\n\t\tfor (int i = 3; i < st.size(); ++i) {\n\t\t\tif (st[i] == 'S' || isdigit(st[i])) {\n\t\t\t\tif (st[i - 1] == '>'&&st[i - 2] == '>') {\n\t\t\t\t\trels[i - 1] = false;\n\t\t\t\t\trels[i - 2] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstack<int>sta;\n\t\tfor (int i = 0; i < st.size(); ++i) {\n\t\t\tif (st[i] == '<') {\n\t\t\t\tif (rels[i]) {\n\t\t\t\t\tsta.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (st[i] == '>') {\n\t\t\t\tif (rels[i]) {\n\t\t\t\t\tint f = sta.top();\n\t\t\t\t\tnums[f] = i;\n\t\t\t\t\tnums[i] = f;\n\t\t\t\t\tsta.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ta = 0;\n\t\tlong long int ans=getexpr(true,-1);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define INF 1e9\n#define EPS 1e-9\n#define MOD (ll)(1e9+7)\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\n\ntemplate<class T>string bitstr(T x){return typeid(T)==typeid(int)?bitset<32>(x).to_string('_','#'):bitset<64>(x).to_string();}\ntemplate<class T>int bitcnt(T x){return typeid(T)==typeid(int)?__builtin_popcount(x):__builtin_popcountll(x);}\ntemplate<class T>int bitdig(T x){return x?typeid(T)==typeid(int)?32-__builtin_clz(x):64-__builtin_clzll(x):0;}\ntemplate<class T>int bitpow(T x){return x?typeid(T)==typeid(int)?__builtin_ctz(x):__builtin_ctzll(x):0;}\n\nstring solve(string s,bool f=false){\n\tint open=0,len=0;\n\tif(f){\n\t\tif(s.find(\"--\")==-1) return s;\n\t\tstring a=\"\",b=\"\";\n\t\tfor(int i=s.size()-1;i>=0;i--){\n\t\t\tif(s[i]=='-'){\n\t\t\t\ta=s.substr(0,i-1);\n\t\t\t\tb=s.substr(i+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//cout<<a<<\",\"<<b<<endl;\n\t\tif(b==\"0\"){\n\t\t\treturn solve(a,true);\n\t\t}\n\t\tauto ans=to_string(stoll(solve(a,true))>>min(32ll,stoll(b)));\n\t\t//cout<<a<<\">>\"<<b<<\"=\"<<ans<<endl;\n\t\treturn ans;\n\t}\n\tfor(int i=0;i<s.size();i++){\n\t\tif(s[i]=='<') open=i,len=0;\n\t\telse if(s[i]=='>'){\n\t\t\t//cout<<s.substr(open+1,len)<<endl;\n\t\t\tll inner=stoll(solve(s.substr(open+1,len),true));\n\t\t\t//cout<<inner<<endl;\n\t\t\tinner=inner*inner%MOD;\n\t\t\tint l=to_string(inner).length();\n\t\t\ts.replace(open-1, len+3, to_string(inner));\n\t\t\ti=0, open=0, len=0;\n\t\t}else len++;\n\t\t//cout<<\"fin:\"<<s<<endl;\n\t}\n\treturn solve(s,true);\n}\n\n\nint main(){\n\tstring s;\n\twhile(getline(cin,s), s!=\"#\"){\n\t\tfor(auto c=s.find_first_of(\" \");c!=-1;c=s.find_first_of(\" \")){\n\t\t\ts.erase(c,1);\n\t\t}\n\t\tfor(int i=1;i<s.size()-1;i++){\n\t\t\tif(s[i-1]=='>' and s[i]=='>' and s[i+1]!='<' and s[i+1]!='>'){\n\t\t\t\ts[i-1]=s[i]='-';\n\t\t\t}\n\t\t}\n\t\tfor(auto c=s.find(\"--0\");c!=-1;c=s.find(\"--0\")){\n\t\t\ts.erase(c,3);\n\t\t}\n\n\t\tint p=0;\n\t\trep(i,s.size()-1){\n\t\t\tif(s[i]=='<') p++;\n\t\t\tif(s[i]=='>') p--;\n\t\t\tif(p<0){\n\t\t\t\tp=0;\n\t\t\t\ts[i]='-';\n\t\t\t\tif(s[i+1]!='>') s[i-1]--;\n\t\t\t}\n\t\t}\n\t\tcout<<solve(s,(s.find(\"S\")==-1))<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cstdio>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef pair<LL, LL> PLL;\n\ntypedef string::iterator State;\n\nconst LL MOD = 1000000007;\n\nstring expression;\n\nvoid sp(State&);\nLL number(State&);\nLL term(State&);\nLL sExpr(State&);\nLL expr(State&);\n\nvoid sp(State& s) {\n    while (s != end(expression) && *s == ' ') ++s;\n}\n\nLL number(State& s) {\n    sp(s);\n    LL ret = 0;\n    for (; s != end(expression) && isdigit(*s); ++s) {\n        ret *= 10;\n        ret += *s - '0';\n    }\n    return ret;\n}\n\nLL sExpr(State& s) {\n    sp(s);\n    ++s; // S\n    sp(s);\n    ++s; // <\n    LL v = expr(s);\n    sp(s);\n    ++s; // >\n    return (v * v) % MOD;\n}\n\nLL term(State& s) {\n    sp(s);\n    if (isdigit(*s)) {\n        return number(s);\n    }\n    return sExpr(s);\n}\n\nbool nextRShift(State s) {\n    int count = 0;\n    sp(s);\n    while(s != end(expression) && *s == '>') {\n        ++count;\n        ++s;\n    }\n    sp(s);\n    return s != end(expression) && *s != '>' && count == 2;\n}\n\nLL expr(State& s) {\n    sp(s);\n    LL t = term(s);\n    sp(s);\n    while (s != end(expression) && *s == '>') {\n        if (!nextRShift(s)) {\n            return t;\n        }\n        ++s; ++s; // >>\n\n        LL u = term(s);\n        if (u >= 32) {\n            t = 0;\n        } else {\n            t /= pow(2LL, u);\n        }\n        sp(s);\n    }\n    return t;\n}\n\nbool solve() {\n    getline(cin, expression);\n    if (expression == \"#\") { return false; }\n    State iter = begin(expression);\n    cout << expr(iter) << endl;\n    return true;\n}\n\nint main() {\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string.h>\nusing namespace std;\nint len;\nchar STR[5000000];\nchar str[5000000];\nlong long mod=1000000007;\npair<long long,int> state(int a){\n\tlong long ret=0;\n\tint at=a;\n\tdo{\n\t\tif('0'<=str[at]&&str[at]<='9'){\n\t\t\tint val=0;\n\t\t\tint v=at;\n\t\t\twhile('0'<=str[v]&&str[v]<='9'){\n\t\t\t\tval*=10;\n\t\t\t\tval+=str[v]-'0';\n\t\t\t\tv++;\n\t\t\t}\n\t\t\tif(at==a){\n\t\t\t\tret=val;\n\t\t\t}else{\n\t\t\t\tif(val>=31)ret=0LL;\n\t\t\t\telse{\n\t\t\t\t\tfor(int i=0;i<val;i++)ret/=2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tat=v+2;\n\t\t}else if(str[at]=='S'){\n\t\t\tpair<long long,int> dat=state(at+2);\n\t\t\tlong long val=dat.first*dat.first%mod;\n\t\t\tif(at==a){\n\t\t\t\tret=val;\n\t\t\t}else{\n\t\t\t\tif(val>=31LL)ret=0LL;\n\t\t\t\telse{\n\t\t\t\t\tfor(int i=0;i<val;i++)ret/=2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tat=dat.second+3;\n\t\t}\n\t}while(at<len&&str[at]!='>');\n\t//printf(\"%d %d: %lld\\n\",a,at-2,ret);\n\treturn make_pair(ret,at-2);\n}\nint main(){\n\twhile(1){\n\t\tgets(STR);\n\t\tif(STR[0]=='#')return 0;\n\t\tlen=0;\n\t\tfor(int i=0;STR[i];i++){\n\t\t\tif(STR[i]!=' '){\n\t\t\t\tif((i==0&&'0'<=STR[i]&&STR[i]<='9')||('0'<=STR[i]&&STR[i]<='9'&&!('0'<=STR[i-1]&&STR[i-1]<='9'))){\n\t\t\t\t\tstr[len++]='0';\n\t\t\t\t\tstr[len++]='0';\n\t\t\t\t}\n\t\t\t\tstr[len++]=STR[i];\n\t\t\t}\n\t\t}\n\t\tstr[len]=0;\n\t\tprintf(\"%lld\\n\",state(0).first);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nstring f;\nint idx, len;\n\nconst ll NG = -1;\n\nll shift(ll a, ll b){\n    rep(loop, b){\n        a >>= 1;\n        if(a == 0) return 0;\n    }\n    return a;\n}\n\nll S(ll x){\n    return MUL(x, x, mod);\n}\n\nll expr();\nll term();\n\nll expr(){\n    ll ret = term();\n    while(f.substr(idx, 2) == \">>\"){\n        int tmp = idx;\n        idx += 2;\n        ll rhs = term();\n        if(rhs == NG){\n            idx = tmp;\n            break;\n        }\n        ret = shift(ret, rhs);\n    }\n    return ret;\n}\n\nll term(){\n    ll ret;\n\n    if(f[idx] == 'S'){\n        idx++;\n        assert(f[idx++] == '<');\n        ret = S(expr());\n        assert(f[idx++] == '>');\n    }\n    else if(isdigit(f[idx])){\n        ret = 0;\n        while(isdigit(f[idx])){\n            ret = 10 * ret + (f[idx] - '0');\n            idx++;\n        }\n    }\n    else ret = NG;\n\n    return ret;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(true){\n        getline(cin, f);\n        if(f == \"#\") break;\n\n        string t;\n        for(auto& c : f) if(c != ' ') t += c;\n        f = t;\n\n        idx = 0;\n        cout << expr() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2570.cc: Shipura\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\ntypedef long long ll;\nconst ll MAX_Y = 30;\nconst ll MOD = 1000000007;\n\n/* typedef */\n\n/* global variables */\n\n/* subroutines */\n\nll expr(string &s, int &pos);\n\nvoid sp(string &s, int &pos) {\n  while (pos >= 0 && s[pos] == ' ') pos--;\n}\n\nll term(string &s, int &pos) {\n  sp(s, pos);\n  if (s[pos] == '>') {\n    pos--; // '>'\n    sp(s, pos);\n    ll x = expr(s, pos);\n    sp(s, pos);\n    pos--; // '<'\n    sp(s, pos);\n    pos--; // 'S'\n\n    x %= MOD;\n    x = x * x % MOD;\n    return x;\n  }\n\n  ll num = 0, t = 1;\n  while (pos >= 0 && s[pos] >= '0' && s[pos] <= '9')\n    num += t * (s[pos--] - '0'), t *= 10;\n  return num;\n}\n\nll expr(string &s, int &pos) {\n  sp(s, pos);\n  ll x = term(s, pos);\n  sp(s, pos);\n\n  if (pos > 0 && s[pos] == '>' && s[pos - 1] == '>') {\n    pos -= 2; // '>>'\n    sp(s, pos);\n    ll y = x;\n    x = expr(s, pos);\n    sp(s, pos);\n\n    if (y >= MAX_Y) x = 0;\n    else x /= (1 << y);\n  }\n\n  return x;\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    string s;\n    getline(cin, s);\n    if (s == \"#\") break;\n\n    int pos = s.size() - 1;\n    ll x = expr(s, pos);\n    printf(\"%lld\\n\", x);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\nusing ll = long long;\nconstexpr ll MOD = 1000000007;\ninline ll sf(const ll k, const ll n) { return k > 64 ? 0 : n >> k; }\ninline ll sq(const long long n) { return n * n % MOD; }\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\n\nint main()\n{\n    while (true) {\n        auto input = []() {\n            string s;\n            getline(cin, s);\n            string ans;\n            for (ll i = s.size() - 1, st = 0, v = false; i >= 0; i--) {\n                const char c = s[i];\n                if (isdigit(c)) { ans.push_back(c), v = true; }\n                if (c == '>') {\n                    if (v) {\n                        ans.push_back('%'), v = false, i--;\n                    } else {\n                        ans.push_back('<'), st++;\n                    }\n                }\n                if (c == '<') { ans.push_back('>'), v = true, st--; }\n            }\n            return ans;\n        };\n        const string S = input();\n        if (S.empty()) { break; }\n        ll pos = 0, ans = 0;\n        auto dfs = fix([&](auto&& self) -> ll {\n            if (pos >= S.size()) { return ans; }\n            const char c = S[pos];\n            if (c == '<') {\n                pos++;\n                const ll sub = self(self);\n                ans = sq(sub);\n                return self(self);\n            } else if (c == '%') {\n                pos++;\n                const ll prev = ans;\n                const ll next = self(self);\n                ans = sf(prev, next);\n                return self(self);\n            } else if (isdigit(c)) {\n                ll num = 0;\n                for (ll d = 1; pos < S.size() and isdigit(S[pos]); d *= 10, pos++) { num += d * (S[pos] - '0'); }\n                ans = num;\n                return self(self);\n            } else {\n                pos++;\n                return self(self);\n            }\n        });\n        dfs();\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int64_t mod = 1000000007;\nchar *code;\n\nbool consume(char c){\n    if(*code != c) return false;\n    ++code;\n    return true;\n}\n\nint64_t expr();\nint64_t term();\nint64_t num();\n\nint64_t expr(){\n    int64_t value = term();\n    while(true){\n        if(\n            strncmp(code, \">>\", 2) == 0\n        &&  ( *(code+2) == 'S' || isdigit(*(code+2)) )\n        ){\n            code += 2;\n            int64_t rhs = term();\n            if(rhs >= 64) value = 0;\n            else value >>= rhs;\n        }else break;\n    }\n    return value;\n}\n\nint64_t term(){\n    if(consume('S')){\n        assert(consume('<'));\n        int64_t value = expr();\n        assert(consume('>'));\n        return value * value % mod;\n    }else return num();\n}\n\nint64_t num(){\n    int64_t value = 0;\n    while(isdigit(*code)){\n        value = value * 10 + (*code - '0');\n        ++code;\n    }\n    return value;\n}\n\nint main(){\n    string s;\n    while(true){\n        getline(cin, s);\n        if(s[0] == '#') break;\n        code = new char[s.size()+1];\n        size_t j = 0;\n        for(size_t i=0;i<s.size();++i){\n            if(s[i] != ' ') code[j++] = s[i];\n        }\n        code[j] = '\\0';\n        cout << expr() << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\n\nstring s;\nint i;\n\n/*\n * expr   ::= term [ \"-\" term]*\n * term   ::= number | \"S<\" expr \">\"\n * number ::= [0-9]+\n */\n\nll expr();\nll term();\nll number();\n\nll expr(){\n    ll val=term();\n    while(s[i]=='-'){\n        i++;\n        val=val>>min(term(),32ll);\n    }\n    return val;\n}\nll term(){\n    if(isdigit(s[i])) return number();\n    i+=2;\n    ll val=expr();\n    val=val*val%1'000'000'007;\n    i++;\n    return val;\n}\nll number(){\n    string val;\n    while(isdigit(s[i])){\n        val.push_back(s[i++]);\n    }\n    return stoll(val);\n}\n\nbool input(){return getline(cin,s) and s!=\"#\";}\n\nll solve(){\n    for(auto c=s.begin();c!=s.end();){\n        if(*c==' ') c=s.erase(c);\n        else c++;\n    }\n    for(int i=2;i<s.size();i++){\n        if(isdigit(s[i]) or s[i]=='S'){\n            if(s[i-1]=='>' and s[i-2]=='>'){\n                s[i-1]='-';\n                s.erase(s.begin()+i-2);\n            }\n        }\n    }\n    i=0;\n    return expr();\n}\n\n\nint main(void){\n    while(input()){\n        cout<<solve()<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reep(i,a,b) for(int i=a; i<b; i++)\n#define INF 0x3f3f3f3f\n#define MOD 1000000007LL\n\ntypedef vector<int> vint;\ntypedef long long ll;\n\nstring s;\nint idx;\n\nvoid sp(){\n\twhile(s[idx] == ' ') idx++;\n}\n\nll number(){\n\tll ret = 0;\n\twhile(isdigit(s[idx])){\n\t\tret *= 10;\n\t\tret += s[idx]-'0';\n\t\tidx++;\n\t}\n\treturn ret;\n}\n\nll RS(ll x, ll y){\n\tif(y>=100) return 0;\n\telse return x>>y;\t\n}\n\nll S(ll y){\n\ty *= y;\n\treturn y % MOD;\t\n}\n\n/*\nbool isRS(){\n\tint tmp = idx;\n\tbool ret = true;\n\tif(s.substr(idx,2) != \">>\") ret = false;\n\tidx += 2;\n\tsp();\n\tif(!(s[idx] == 'S' || isdigit(s[idx]))) ret = false; \n\tidx = tmp;\n\treturn ret;\n}\n*/\nll term();\n\nll expr(ll x=0){\n\t//sp();\n\t//assert(idx<20);\n\tif(idx == s.size()) return x;\n\t// cout<<\"solve \"<<x<<\" \"<<idx<<\" \"<<s[idx]<<endl;\n\tx = term();\n\twhile(idx < s.size() && s[idx] == '>'){\n\t\tidx+=2;\n\t\tll y = term();\n\t\tx = RS(x, y);\n\t}\n\t/*\n\tif(isdigit(s[idx])) x = number();\n\telse if(s[idx] == '>'){\n\t\tidx+=2;\n\t\tll y = solve();\n\t\tcout<<\"RS \"<<x<<\" \"<<y<<endl;\n\t\tx = RS(x, y);\n\t}\n\telse{\n\t\tassert(s[idx] == ')');\n\t\treturn x;\n\t}\n\t*/\n\treturn x;\n}\n\nll term(){\n\tll x;\n\tif(isdigit(s[idx])) x = number();\n\tif(s[idx] == 'S'){\n\t\tidx++;\n\t\tidx++;\n\t\tll y = expr();\n\t\tidx++;\n\t\tx = S(y);\n\t\t// cout<<\"S \"<<x<<endl;\n\t}\n\treturn x;\n}\n\n\n\nint main(){\n\twhile(getline(cin,s), s!=\"#\"){\n\t\tstring tmp;\n\t\trep(i,s.size()){\n\t\t\tif(s[i] != ' ') tmp += s[i];\n\t\t}\n\t\ts = tmp;\n\t\trep(i,s.size()){\n\t\t\tif(s[i] == '<') s[i] = '(';\n\t\t\tif(s[i] == '>'){\n\t\t\t\tif(i+2<s.size() && s[i+1] == '>' && (s[i+2] == 'S' || isdigit(s[i+2]))) i+=1;\n\t\t\t\telse s[i] = ')';\n\t\t\t}\n\t\t}\n\t\tidx = 0;\n\t\tcout<<s<<endl;\n\t\tcout<<expr()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdlib>\n#include<sstream>\n#include<algorithm>\n#include<stack>\n#include<map>\n#define mod 1000000007\nusing namespace std;\n\ntypedef unsigned long long ll;\n\nvector<string> a;\nmap<int,int> m;\n\nstring f1(string a){\n  ll x=(ll)atoi(a.c_str());\n  x=(x*x)%mod;\n  ostringstream os;\n  os<<x;\n  return os.str();\n}\n\nstring f2(string a,string b){\n  ll x=atoi(a.c_str()),y=atoi(b.c_str()),c=1;\n  for(int i=0;i<y;i++){\n    if(x<c)return \"0\";\n    c*=2;\n  }\n  x=x/c;\n  ostringstream os;\n  os<<x;\n  return os.str();\n}\n\nvoid rec(int s,int t){\n  for(int i=s;i<t;i++){\n    if(a[i]==\"<\"){\n      int l=i+1,r=m[i];\n      rec(l,r);\n      i=r-1;\n    }\n    else if(a[i]==\">>\"){\n      if(a[i+1]==\"<\"){\n\tint l=i+1,r=m[i+1];\n\trec(l,r+1);\n        a[r]=f2(a[i-1],a[r]);\n\ti=r;\n      }\n      else a[i+1]=f2(a[i-1],a[i+1]);\n    }\n    else if(a[i]==\">\")a[i]=f1(a[i-1]);\n    else {}\n  }\n}\n\nint main()\n{\n  while(1){\n    char c;\n    string s,t=\"\";\n    vector<string> b;\n    getline(cin,s);\n    if(s[0]=='#')break;\n    a.clear();\n    for(int i=0;i<s.length();i++)if(s[i]!=' ')t+=s[i];\n    string tmp=\"\";\n    for(int i=0;i<t.length();i++){\n      if(t[i]=='S'){\n\tb.push_back(\"<\");\n\ti++;\n      }\n      else if(t[i]=='>'){\n\tif(tmp!=\"\")b.push_back(tmp);\n\ttmp=\"\";\n\tb.push_back(\">\");\n      }\n      else tmp+=t[i];\n      if(i==t.length()-1 && tmp!=\"\")b.push_back(tmp);\n    }\n\n    for(int i=b.size()-1;0<i;i--){\n      if(b[i]!=\">\"){\n\ta.push_back(b[i]);\n\tif(b[i-1]==\">\"){\n\t  i-=2;\n\t  a.push_back(\">>\");\n\t}\n      }\n      else a.push_back(b[i]);\n    }\n    a.push_back(b[0]);\n    reverse(a.begin(),a.end());\n    stack<int> st;\n    for(int i=0;i<a.size();i++){\n      if(a[i]==\"<\")st.push(i);\n      if(a[i]==\">\"){\n\tint a=st.top();\n\tst.pop();\n\tm[a]=i;\n      }\n    }\n    rec(0,a.size());\n    cout<<a[a.size()-1]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).*begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 150000000;\nconst long long M = 1000000007;\n\n\ntypedef string::const_iterator State;\nint number(State&);\nint term(State&);\nint expression(State&);\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    if (*begin == 'S') {\n        begin++; // '('????£???°??????\n        begin++;\n        long long ret = expression(begin);\n        begin++; // ')'????£???°??????\n        return ret * ret % M;\n    } else {\n        return number(begin);\n    }\n    return INF;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    int ret = term(begin);\n\n    for (;;) {\n        if(*begin == 'E') return ret;\n        if (*begin == '>' && *(begin + 1) == '>' && *(begin + 2) != '>') {\n            begin++;\n            begin++;\n            ret = ret >> min(term(begin), 31);\n        } else {\n            return ret;\n        }\n    }\n\n    return ret;\n}\n\ninline void deleteSpace(string &a){\n    size_t pos;\n    while((pos = a.find_first_of(\" \")) != string::npos){\n        a.erase(pos, 1);\n    }\n}\n\nint main(){\n    std::ifstream ifs(\"/Users/noy/Downloads/2570_in1.txt.html\");\n    string s;\n    while(getline(cin,s),s != \"#\"){\n        deleteSpace(s);\n        s+=\"E\";\n        State tmp = s.begin();\n        cout << expression(tmp) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdlib>\n#include<sstream>\n#include<algorithm>\n#define mod 1000000007\nusing namespace std;\n\ntypedef unsigned long long ll;\n\nstring f1(string a){\n  ll x=(ll)atoi(a.c_str());\n  x=(x*x)%mod;\n  ostringstream os;\n  os<<x;\n  return os.str();\n}\n\nstring f2(string a,string b){\n  ll x=atoi(a.c_str()),y=atoi(b.c_str()),c=1;\n  for(int i=0;i<y;i++){\n    if(x<c)return \"0\";\n    c*=2;\n  }\n  x=x/c;\n  ostringstream os;\n  os<<x;\n  return os.str();\n}\n\nstring rec(vector<string> a){\n  for(int i=0;i<a.size();i++){\n    if(a[i]==\"<\"){\n      int l=1,r=0;\n      vector<string> b;\n      for(int j=i+1;j<a.size();j++){\n\tif(a[j]==\"<\")l++;\n\tif(a[j]==\">\")r++;\n\tif(l==r){\n\t  a[j-1]=rec(b);\n\t  i=j-1;\n\t  break;\n\t}\n        b.push_back(a[j]);\n      }\n    }\n    else if(a[i]==\">>\"){\n      if(a[i+1]==\"<\"){\n\tint l=1,r=0;\n\tvector<string> b;\n\tfor(int j=i+2;j<a.size();j++){\n\t  b.push_back(a[j]);\n\t  if(a[j]==\"<\")l++;\n\t  if(a[j]==\">\")r++;\n\t  if(l==r){\n\t    a[j]=f2(a[i-1],rec(b));\n\t    i=j;\n\t    break;\n\t  }\n\t}\n      }\n      else a[i+1]=f2(a[i-1],a[i+1]);\n    }\n    else if(a[i]==\">\")a[i]=f1(a[i-1]);\n    else {}\n  }\n  return a[a.size()-1];\n}\n\nint main()\n{\n  while(1){\n    char c;\n    string s,t=\"\";\n    vector<string> a,b;\n    getline(cin,s);\n    if(s[0]=='#')break;\n    for(int i=0;i<s.length();i++)if(s[i]!=' ')t+=s[i];\n    string tmp=\"\";\n    for(int i=0;i<t.length();i++){\n      if(t[i]=='S'){\n\ta.push_back(\"<\");\n\ti++;\n      }\n      else if(t[i]=='>'){\n\tif(tmp!=\"\")a.push_back(tmp);\n\ttmp=\"\";\n\ta.push_back(\">\");\n      }\n      else tmp+=t[i];\n      if(i==t.length()-1 && tmp!=\"\")a.push_back(tmp);\n    }\n\n    for(int i=a.size()-1;0<i;i--){\n      if(a[i]!=\">\"){\n\tb.push_back(a[i]);\n\tif(a[i-1]==\">\"){\n\t  i-=2;\n\t  b.push_back(\">>\");\n\t}\n      }\n      else b.push_back(a[i]);\n    }\n    b.push_back(a[0]);\n    reverse(b.begin(),b.end());\n    cout<<rec(b)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cstdlib>\n#include <iostream>\nusing namespace std;\n\nconstexpr long long mod = 1000000007;\n\nlong long expr(string::const_reverse_iterator &it);\nlong long term(string::const_reverse_iterator &it);\nlong long number(string::const_reverse_iterator &it);\n\nlong long expr(string::const_reverse_iterator &it) {\n\tlong long res = term(it);\n\tif(*it == '>') {\n\t\t++it;\n\t\tassert(*it == '>');\n\t\t++it;\n\t\tres = (expr(it) >> min(32ll, res));\n\t}\n\treturn res;\n}\n\nlong long term(string::const_reverse_iterator &it) {\n\tif(isdigit(*it)) return number(it);\n\n\tassert(*it == '>');\n\t++it;\n\tlong long res = expr(it);\n\tassert(*it == '<');\n\t++it;\n\tassert(*it == 'S');\n\t++it;\n\treturn (res * res) % mod;\n}\n\nlong long number(string::const_reverse_iterator &it) {\n\tlong long res = 0;\n\tfor(int d = 1; isdigit(*it); d *= 10, ++it) {\n\t\tres += d * (*it - '0');\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(string expression; getline(cin, expression) && expression != \"#\";) {\n\t\texpression.erase(remove(expression.begin(), expression.end(), ' '), expression.end());\n\t\tauto it = expression.crbegin();\n\t\tcout << expr(it) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cctype>\nusing namespace std;\n\ntypedef string::iterator State;\ntypedef long long ll;\n\n#define MOD 1000000007\n\nstring s;\n\nll expr(State &begin);\n\nll fast_pow_limit(ll x, ll n, ll lim) {\n\tll ret = 1;\n\twhile(n>0) {\n\t\tif(x > lim) return x;\n\t\tif(n&1) {\n\t\t\tret *= x;\n\t\t\tif(ret > lim) return ret;\n\t\t}\n\t\tx = x * x;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nll number(State &begin) {\n\tll ret = 0; bool ok = false;\n\tState bak = begin;\n\twhile(isdigit(*begin)){\n\t\tret = 10*ret + (*begin - '0');\n\t\t++begin; ok = true;\n\t}\n\treturn ok ? ret : -1;\n}\n\nvoid sp(State &begin) {\n\twhile(*begin==' ') ++begin;\n}\n\nll term(State &begin) {\n\tif(begin==s.end()) return -1;\n\tll ret = 0, r;\n\tif(*begin=='S') {\n\t\t++begin; // 'S'\n\t\tsp(begin);\n\t\t++begin; // '<'\n\t\tsp(begin);\n\t\tr = expr(begin);\n\t\tret = (r * r) % MOD;\n\t\tsp(begin);\n\t\t++begin;\n\t}else {\n\t\tret = number(begin);\n\t}\n\treturn ret;\n}\n\nll expr(State &begin) {\n\tll ret = term(begin), r;\n\twhile(begin!=s.end()) {\n\t\tState bak = begin;\n\t\tsp(begin);\n\t\tif(begin!=s.end() && begin+1!=s.end() && *begin=='>' && *(begin+1)=='>') {\n\t\t\tbegin += 2;\n\t\t\tsp(begin);\n\t\t\tr = term(begin);\n\t\t\tif(r==-1) {\n\t\t\t\tbegin = bak;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = ret / fast_pow_limit(2, r, ret);\n\t\t}else {\n\t\t\tbegin = bak;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\twhile(1) {\n\t\tgetline(cin, s);\n\t\tif(s[0]=='#') break;\n\t\tState begin = s.begin();\n\t\tcout << expr(begin) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//test copy file\n\n#include <iostream>\n#include <cctype>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n \nint number(string &S, int &i);\nint term(string &S, int &i);\nint expr(string &S, int &i);\n \nint number(string &S, int &i){\n    int ret = 0;\n    while(isdigit(S[i])){\n        ret*=10;\n        ret+=S[i]-'0';\n        i++;\n    }\n    return ret;\n}\n \nint term(string &S, int &i){\n    const int64_t mod=1000000007;\n    if(S[i]=='S'){\n        i+=2;//\"S<\"\n        int64_t x = expr(S,i);\n        i++;//'>'\n        x=x*x%mod;\n        return x;\n    }else{\n        return number(S,i);\n    }\n}\n \nint expr(string &S, int &i){\n    int ret = term(S,i);\n    while(i<S.size()){\n        int cnt=0;\n        for(int j=i;j<S.size();j++){\n            if(S[j]=='>')cnt++;\n            else break;\n        }\n        if(cnt==2&&i+2<S.size()){\n            i+=2;//\">>\"\n            int y = term(S,i);\n            if(y>=31){\n                ret=0;\n            }else{\n                ret>>=y;\n            }\n            continue;\n        }else{\n            return ret;\n        }\n    }\n    return ret;\n}\n \nint main(){\n    string S;\n    while(getline(cin,S)){\n        if(S[0]=='#') break;\n        int i=0;\n        string ss;\n        for(auto c:S){\n            if(c!=' ') ss.push_back(c);\n        }\n        // cout<<ss<<endl;\n        cout<<expr(ss,i)<<endl;\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n\ntypedef long long lint;\ntypedef pair<int, int> pii;\n\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\nconst lint MOD = 1e9 + 7;\n\nstring S;\n\nvector<string> split_str(string _s, string _t) {\n\tvector<string> res;\n\tfor (int p = 0; (p = _s.find(_t)) != -1;) {\n\t\tres.push_back(_s.substr(0, p));\n\t\t_s = _s.substr(p + size_of(_t));\n\t}\n\tres.push_back(_s);\n\treturn res;\n}\n\nlint parse(int left, int right, int depth=10000) {\n\t//cout << left << \" \" << right << endl;\n\t//if (left > right) return -1;\n\t\n\tint lcnt = 0, rcnt = 0;\n\tint n_left = -1;\n\tqueue<lint> q;\n\tbool d_flag = false;\n\tint d_pos = -1;\n\tif (depth < 0) {\n\t\treturn MOD;\n\t}\n\tfor_(i,left,right) {\n\t\tif (S[i] == '<') {\n\t\t\tif (lcnt == 0) n_left = i + 1;\n\t\t\tlcnt++;\n\t\t}\n\t\tif (S[i] == '>') {\n\t\t\trcnt++;\n\t\t}\n\t\t\n\t\tif ((S[i] == '<' || S[i] == '|') && d_flag) {\n\t\t\tstring ress = S.substr(d_pos, i - d_pos);\n\t\t\tstringstream ss(ress);\n\t\t\tlint res; ss >> res;\n\t\t\tq.push(res);\n\t\t\td_flag = false;\n\t\t}\n\t\t\n\t\tif (!d_flag && lcnt == 0 && isdigit(S[i])) {\n\t\t\td_pos = i;\n\t\t\td_flag = true;\n\t\t}\n\t\t\n\t\tif (lcnt > 0 && rcnt > 0 && lcnt == rcnt) {\n\t\t\tlint res = parse(n_left, i, depth-1);\n\t\t\t/*\n\t\t\tif (res == -1) {\n\t\t\t\tlcnt = rcnt = 0;\n\t\t\t\tcontinue;\n\t\t\t}*/\n\t\t\tres *= res;\n\t\t\tres %= MOD;\n\t\t\tq.push(res);\n\t\t\tlcnt = rcnt = 0;\n\t\t}\n\t}\n\t\n\tif (d_flag) {\n\t\tstring ress = S.substr(d_pos, right - d_pos);\n\t\tstringstream ss(ress);\n\t\tlint res; ss >> res;\n\t\tq.push(res);\n\t}\n\t\n\tlint res = q.front(); q.pop();\n\twhile (!q.empty()) {\n\t\tlint d = q.front(); q.pop();\n\t\twhile (d > 0 && res > 0) {\n\t\t\tres /= 2;\n\t\t\td--;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nvoid solve() {\n\tint n = size_of(S);\n\tint i = 0;\n\twhile (i < size_of(S)) {\n\t\tif (i > 2 && (S[i] == 'S' || isdigit(S[i]))) {\n\t\t\tif (S[i - 1] == '>' && S[i - 2] == '>') {\n\t\t\t\tS = S.substr(0, i - 2) + \"|\" + S.substr(i);\n\t\t\t\ti = i - 2;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tcout << S << endl;\n\tn = size_of(S);\n\tcout << parse(0, n) << endl;\n}\n\nint main() {\n\tstring input;\n\twhile (getline(cin, input)) {\n\t\tif (input[0] == '#') break;\n\t\tvector< string > split = split_str(input, \" \");\n\t\tint v_size = size_of(split);\n\t\tS = \"\";\n\t\tfor_(i,0,v_size) S += split[i];\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 2000005\ntypedef unsigned long long ll;\nll mod=1e9+7;\n\nbool isNum(char ch){\n  return ('0'<=ch&&ch<='9');\n}\n\nbool check(char ch){\n  return (ch=='\\0'||ch=='>');\n}\n\nint n,a;\nint p;\n\nchar t[MAX];\n\n\nll solve();\n\nll getNum(){\n  if(t[p]=='S'){\n    p+=2;\n    ll res=solve();\n    p++;\n    return (res*res)%mod; \n  }\n  ll res=0;\n  while(isNum(t[p])){\n    res=res*10LL+(t[p]-'0');\n    p++;\n  }\n  return res;\n}\n\nll solve(){\n  ll res=getNum();\n  while(1){\n    if(check(t[p])&&check(t[p+1])&&check(t[p+2])){\n      break;\n    }\n    p+=2;\n    ll num=min(63ULL,getNum());\n\n    res=(res>>num);\n    //cout<<res<<endl;\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    n=0;\n    while(1){\n      scanf(\"%c\",&t[n]);\n      if(t[n]==' ')continue;\n      if(t[n]=='\\n')break;\n      n++;\n    }\n    if(t[0]=='#')break;\n\n    while(n<MAX){\n      t[n]='\\0';\n      n++;\n    }\n    // printf(\"%s\\n\",t);\n    p=0;\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).*begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int M = 1000000007;\n\nstring s;\n\ntypedef string::const_iterator State;\nint number(State&);\nint term(State&);\nint expression(State&);\n\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    if (*begin == 'S') {\n        begin++; begin++;\n        long long ret = expression(begin);\n        begin++;\n        return ret * ret % M;\n    } else {\n        return number(begin);\n    }\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    int ret = term(begin);\n\n    while(s.end() - begin >= 2){\n        if (*begin ==  '>' && *(begin + 1) == '>'/* && *(begin + 2) != '>'*/){\n            begin++; begin++;\n            ret = ret >> min(term(begin), 31);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint main(){\n    string tmp;\n    while(getline(cin,tmp),tmp != \"#\"){\n        s=\"\";\n        for(auto it:tmp) if(it != ' ') s+=it;\n        State state = s.begin();\n        cout << expression(state) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <cstdio>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <algorithm>\n#include <limits>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MD = 1e9+7.1;\n\nint n;\nchar s[2000030];\n\nll expr(char **begin);\n\nll numb(char **begin) {\n    ll r = 0;\n    while (isdigit(**begin)) {\n        r *= 10;\n        r += **begin - '0';\n        *begin += 1;\n    }\n    return r;\n}\n\nll term(char **begin) {\n    if (**begin == 'S') {\n        *begin += 2;\n        ll r = expr(begin)%MD;\n        *begin += 1;\n        return (r*r)%MD;\n    } else {\n        return numb(begin);\n    }\n}\n\nll expr(char **begin) {\n    ll r = term(begin);\n    while (true) {\n        if (**begin == '>' && *(*begin + 1) == '>' && *(*begin + 2) != '>') {\n            *begin += 2;\n            r >>= min(60LL, term(begin));\n        } else {\n            break;\n        }\n    }\n    return r;\n}\n\nint main() {\n    while (true) {\n        string ss;\n        getline(cin, ss);\n        if (ss[0] == '#') break;\n        n = 0;\n        for (char c: ss) {\n            if (c != ' ') {\n                s[n] = c;\n                n++;\n            }\n        }\n        s[n] = '@';\n        char *beg = s;\n        ll ans = expr(&beg);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <cstdio>\n#include <stack>\n#include <map>\n#define rep(i,n) for(long long i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll MOD = 1000000007;\n\nstring str;\nmap<ll,ll> ma;\n\nll f1(ll x, ll y){\n\trep(i,y){\n\t\tx /= 2;\n\t\tif(x == 0) break;\n\t}\n\treturn x;\n}\n\nll f2(ll x){\t\n\treturn (x*x)%MOD;\n} \n\nP dfs(ll st, ll en, bool start){\n\tll ret = 0;\n\tif('0' <= str[st] && str[st] <= '9'){\n\t\tret = str[st]-'0';\n\t\twhile(st+1 <= en && '0' <= str[st+1] && str[st+1] <= '9'){\n\t\t\tst++;\n\t\t\tret = ret*10+str[st]-'0';\n\t\t}\n\t} else{\n\t\tret = f2(dfs(st+2,ma[st+1]-1,0).first);\n\t\tst = ma[st+1];\n\t}\n\tif(start) return P(ret,st);\n\twhile(st+3 <= en){\n\t\tP acc = dfs(st+3,en,1);\n\t\tret = f1(ret,acc.first);\n\t\tst = acc.second;\n\t}\n\treturn P(ret,st);\n}\n\nvoid solve(){\n\tma.clear();\n\tstring s;\n\trep(i,str.size()) if(str[i] != ' ') s.push_back(str[i]);\n\tstr  = s;\n\tstr += \">>\";\n\tstack<ll> sta;\n\trep(i,str.size()){\n\t\tif(str[i] == '<'){\n\t\t\tsta.push(i);\n\t\t}\n\t\tif(i+2 <= str.size()-1 && str[i] == '>' && str[i+1] == '>' && str[i+2] == '>'){\n\t\t\tma[sta.top()] = i;\n\t\t\tsta.pop();\n\t\t}\n\t}\n\tcout << dfs(0,str.size()-3,0).first << endl;\n}\n\nint main(){\n\twhile(true){\n\t\tgetline(cin,str);\n\t\tif(str == \"#\") break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst ll mod = 1000000007;\nconst ll LIM = 33;\n\nstring delsp(string s){\n    string t = \"\";\n    for(char c:s)if(c!=' ') t+=c;\n    return t;\n}\n\nstring s;\nint n;\nmap<int,vector<int>> pos;\n\nll E(int &idx, int dep, int RR);\nll T(int &idx, int dep, int RR);\n\ninline ll sq(ll x){\n    return (x*x)%mod;\n}\n\nll N(int &idx){\n    ll ret = 0;\n    while(idx<n && isdigit(s[idx])){\n        ret = ret*10 + (s[idx]-'0');\n        ret %= mod;\n        ++idx;\n    }\n    return ret;\n}\n\nll E(int &idx, int dep, int RR){\n    if(pos[dep].empty()){\n        return T(idx,dep,RR);\n    }\n    else{\n        auto itr = lower_bound(all(pos[dep]), RR);\n        if(itr != pos[dep].begin()){\n            --itr;\n            int rx = *itr;\n            if(idx < rx){\n                ll L = E(idx,dep,rx-1);\n                assert(idx == rx);\n                idx += 2;\n                ll R = T(idx,dep,RR);\n\n                if(R>LIM) return 0;\n                else return L>>R;\n            }\n            else return T(idx,dep,RR);\n        }\n        else return T(idx,dep,RR);\n    }\n}\n\nll T(int &idx, int dep, int RR){\n    if(isdigit(s[idx])){\n        return N(idx);\n    }\n    else if(s[idx]=='S'){\n        ++idx;\n        assert(s[idx]=='<');\n        ++idx;\n        ll v = sq(E(idx,dep+1,RR));\n        assert(s[idx]=='>');\n        ++idx;\n        return v;\n    }\n    else assert(false);\n}\n\nint main(){\n    while(getline(cin,s),(s!=\"#\")){\n        pos.clear();\n\n        s = delsp(s);\n\n        n = s.size();\n        int idx = n-1;\n        while(idx>0){\n            if(idx>0 && idx<n-1 && s[idx]=='>' && s[idx-1]=='>'){\n                if(s[idx+1]=='S' || isdigit(s[idx+1])){\n                    s[idx-1] = 'x';\n                    s[idx] = 'x';\n                }\n            }\n            --idx;\n        }\n\n        n = s.size();\n\n        int d = 0;\n        idx = 0;\n        while(idx<n){\n            if(s[idx]=='x'){\n                pos[d].pb(idx);\n                idx += 2;\n            }\n            else{\n                if(s[idx]=='S') ++d;\n                else if(s[idx]=='>') --d;\n\n                ++idx;\n            }\n        }\n\n        idx = 0;\n        cout << E(idx,0,n) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint number(string &S, int &i);\nint term(string &S, int &i);\nint expr(string &S, int &i);\n\nint number(string &S, int &i){\n    int ret = 0;\n    while(isdigit(S[i])){\n        ret*=10;\n        ret+=S[i]-'0';\n        i++;\n    }\n    return ret;\n}\n\nint term(string &S, int &i){\n    const int64_t mod=1000000007;\n    if(S[i]=='S'){\n        i+=2;//\"S<\"\n        int64_t x = expr(S,i);\n        i++;//'>'\n        x=x*x%mod;\n        return x;\n    }else{\n        return number(S,i);\n    }\n}\n\nint expr(string &S, int &i){\n    int ret = term(S,i);\n    while(i<S.size()){\n        int cnt=0;\n        for(int j=i;j<S.size();j++){\n            if(S[j]=='>')cnt++;\n            else break;\n        }\n        if(cnt==2&&i+2<S.size()){\n            i+=2;//\">>\"\n            int y = term(S,i);\n            if(y>=63){\n                ret=0;\n            }else{\n                ret>>=y;\n            }\n            continue;\n        }else{\n            return ret;\n        }\n    }\n    return ret;\n}\n\nint main(){\n    string S;\n    while(getline(cin,S)){\n        if(S[0]=='#') break;\n        int i=0;\n        string ss;\n        for(auto c:S){\n            if(c!=' ') ss.push_back(c);\n        }\n        // cout<<ss<<endl;\n        cout<<expr(ss,i)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nconst ll MOD = 1e9 + 7;\n\nll term(int& i,const string& S);\nll term(int& i,const string& S);\nll expr(int& i,const string& S);\nvoid brank(int& i, const string& S){\n    while(S[i] == ' ')i++;\n}\n\nll to_num(int& i,const string& S){\n    ll res = 0;\n    while(true){\n        if(S[i] >= '0' && S[i] <= '9'){\n            res = res*10 + (S[i] - '0');\n            i++;\n        }else{\n            break;\n        }\n    }\n    return res;\n}\n\nll term(int& i,const string& S){\n    ll res = 0;\n    if(isdigit(S[i])){\n        res = to_num(i,S);\n    }else{\n        i+=2;\n        res = expr(i,S)%MOD;\n        (res*=res)%=MOD;\n        i++;\n    }\n    return res;\n}\n\nll expr(int& i,const string& S){\n    ll res = term(i,S);\n    while(S[i] == 'X' && S[i+1] == 'X'){\n        i+=2;\n        ll tmp = term(i,S);\n        res >>= min(60LL,tmp);\n    }\n    return res;\n}\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    string S;\n    while(true){\n        getline(cin,S);\n        if(S == \"#\") break;\n        \n        string tmp;\n        for(int i = 0; i < S.length() ;i++){\n            if(S[i] == ' ')continue;\n            tmp += S[i];\n        }\n        S = tmp;\n        for(int i = (int)S.length()-1; i>= 2; i--){\n            if((isdigit(S[i]) || S[i] == 'S') && S[i-1] == '>' && S[i-2] == '>' ){\n                S[i-1] = S[i-2] = 'X';\n            }\n        }\n        int i = 0;\n        cout << expr(i,S)<< endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int lli;\n\nstring s;\nint idx;\n\nlli term();\n\nlli number() {\n    lli ret = 0;\n    while (isdigit(s[idx])) {\n        ret = ret * 10 + (s[idx] - '0');\n        idx++;\n    }\n    return ret;\n}\n\nlli expr() {\n    lli left = term();\n    while (s[idx] == '/') {\n        idx += 2; // skip \">>\"\n\n        double val = left;\n        lli right = term();\n        for (int i = 0; val + 1e-5 > 1 && i < right; i++)\n            val /= 2;\n        left = floor(val);\n    }\n    return left;\n}\n\nlli term() {\n    if (s[idx] == 'S') {\n        idx += 2; // skip 'S<'\n\n        lli val = expr();\n        val %= 1000000007;\n        val = (val * val) % 1000000007;\n\n        idx++; // skip \">\"\n        return val;\n    }\n    return number();\n}\n\nstring preproc(string s) {\n    string ret = \"\";\n    reverse(s.begin(), s.end());\n    bool pre_term = false;\n    for (int i = 0; i < s.size(); i++) {\n        while (s[i] == ' ') i++;\n        if (pre_term && i + 1 < s.size() && s[i] == '>' && s[i+1] == '>') {\n            i++; // skip \">>\"\n            ret += \"//\";\n            pre_term = false;\n            continue;\n        }\n        if (s[i] == 'S' || isdigit(s[i]))\n            pre_term = true;\n        else\n            pre_term = false;\n        ret += s[i];\n    }\n    reverse(ret.begin(), ret.end());\n    return ret;\n}\n\nint main() {\n    while (true) {\n        idx = 0;\n        getline(cin, s);\n        if (s == \"#\") break;\n        s = preproc(s);\n        // cerr << s << endl;\n        cout << expr() << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).*begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int M = 1000000007;\n\nstring s;\n\ntypedef string::const_iterator State;\nint number(State&);\nint term(State&);\nint expression(State&);\n\n\n// ??°??????????????????????????????????????°????????????\nint number(State &begin) {\n    int ret = 0;\n\n    while (isdigit(*begin)) {\n        ret *= 10;\n        ret += *begin - '0';\n        begin++;\n    }\n\n    return ret;\n}\n\n\n// ?????????????????????????????????????????????????????????????????????\nint term(State &begin) {\n    if (*begin == 'S') {\n        begin++; begin++;\n        long long ret = expression(begin);\n        begin++;\n        return ret * ret % M;\n    } else {\n        return number(begin);\n    }\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(State &begin) {\n    int ret = term(begin);\n\n    while(s.end() - begin >= 2){\n        if (*begin ==  '>' && *(begin + 1) == '>' && *(begin + 2) != '>'){\n            begin++; begin++;\n            ret = ret >> term(begin);\n        } else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint main(){\n    string tmp;\n    while(getline(cin,tmp),tmp != \"#\"){\n        s=\"\";\n        for(auto it:tmp) if(it != ' ') s+=it;\n        State state = s.begin();\n        cout << expression(state) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define MOD (1000000007ULL)\n \nusing namespace std;\n \ntypedef unsigned long long ull;\n \nstring line,parse;\nint pos;\nint n;\n \null exp();\n \null fact()\n{\n  ull res = 0;\n  if(line[pos] == 'S')\n    {\n      pos+=2;\n      res = exp();\n      res = res * res % MOD;\n      pos++;//now, the position is '>' and go to next\n    }\n  else\n    {\n      while(pos < n && '0' <= line[pos] && line[pos] <= '9')\n\t{\n\t  res *= 10ULL;\n\t  res += (line[pos]-'0');\n\t  pos++;\n\t}\n    }\n  return res;\n}\n \null exp()\n{\n  ull p = fact();\n  while(line[pos] == '*' && line[pos+1] == '*')\n    {\n      pos += 2;\n      ull q = fact();\n      //here, the variable 'pos' indicates the position after the 'S' or 'num'\n      //cout << \"calc : \" << p << \" >> \" << q << endl;\n      p = p >> (ull)min(q,(ull)(log2(p))+1ULL);\n      //cout << \"p \" << p << endl;\n    }\n \n  return p;\n}\n \nvoid preDo(string &line)\n{\n  stringstream ss;\n  ss << line;\n  line.clear();\n  string pre;\n  while(!(ss>>pre).fail())line += pre;\n \n  rep(i,n)\n    {\n      if(('0' <= line[i] && line[i] <= '9') || line[i] == 'S')\n\t{\n\t  if(i-2 >= 0)\n\t    {\n\t      if(line[i-1] == '>' && line[i-2] == '>')\n\t\t{\n\t\t  line[i-1] = line[i-2] = '*';\n\t\t  while(i < n && '0' <= line[i] && line[i] <= '9')i++;\n\t\t}\n\t    }\n\t}\n    }\n  //cout << \"before : \" << line << endl; \n}\n \nint main()\n{\n  while(true)\n    {\n      getline(cin,line);\n      if(line[0] == '#')break;\n      preDo(line);\n      pos = 0;\n      n = line.size();\n      preDo(line);\n      cout << exp() << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n#define int ll\nconst ll MOD = 1e9+7;\ntypedef string::const_iterator state;\n\nstring t;\nint expr(state &end);\n\nint number(state &end){\n    string str=\"\";\n    while(isdigit(*end)){\n        str+=*end;\n        end--;\n    }\n    reverse(all(str));\n    \n    int ret = 0;\n    rep(i,str.size()){\n        ret*=10;\n        ret+=str[i]-'0';\n    }\n    return ret;\n}\n\nint term(state &end){\n    if(*end=='>'){\n        end--;\n        int res = expr(end);\n        end-=2;\n        return (res*res)%MOD;\n    }else if(isdigit(*end)){\n        int res = number(end);\n        return res;\n    }else{\n        throw\"impossible\";\n        return -1;\n    }\n}\n\nint expr(state &end){\n    if(end+1==t.begin())throw \"empty\";\n    \n    vector<int> res;\n    res.pb( term(end) );\n    \n    while(end+1!=t.begin()&&*end!='<'){\n        end-=2;\n        res.pb( term(end) );\n    }\n    \n    reverse(all(res));\n    int tmp = res[0];\n    \n    for(int i=1;i<res.size();i++){\n        rep(j,res[i]){\n            if(tmp==0)break;\n            tmp/=2;\n        }\n    }\n    \n    return tmp;\n}\n\nsigned main(){\n    string s;\n    while(getline(cin,s)&&s!=\"#\"){\n        t = \"\";\n        rep(i,s.size())if(s[i]!=' ')t+=s[i];\n        \n        state st = t.end()-1;\n        int ans;\n        try{\n            ans = expr(st);\n        }catch(char const* e){\n            cout<<\"error\"<<e<<endl;\n            exit(-1);\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\nusing namespace std;\ntypedef string::const_iterator State;\ntypedef long long ll;\nll mod=1000000007;\nstring s;\nll expression(State &begin);\t\t\t//term or expr >> term\nll term(State &begin);\t\t\t\t\t//num or S<expr>\nll number(State &begin);\t\t\t\t//\nstring as(State &begin){\n\tstring hoge;\n\tfor(State st=s.begin();st!=s.end();st++){\n\t\tif(st==begin) hoge=hoge+\" \"+(*st)+\" \"; \n\t\telse hoge+=(*st);\n\t}\n\treturn hoge;\n}\nll expression(State &begin){\n//\tcout << \"expr  \" << as(begin) << endl;\n\tll ret=term(begin);\n\tif(*begin == '>'){\n\t\tbegin--;\t//>\n//\t\tif(*begin!='>') cout << \"> \" << as(begin) << endl;\n\t\tbegin--;\n\t\tif(ret>40) ret=0*expression(begin);\n\t\telse ret=expression(begin) >> ret;\n\t}\n\treturn ret;\n}\nll term(State &begin){\n//\tcout << \"term  \" << as(begin) << endl;\n\tif(*begin == '>'){\n\t\tbegin--;\n\t\tll ret=expression(begin);\n\t\tret*=ret;\n\t\tret%=mod;\n//\t\tif(*begin!='<') cout << \"< \" << as(begin) << endl;\n\t\tbegin--;\t//S\n//\t\tif(*begin!='S') cout << \"S \" << as(begin) << endl;\n//\t\tcout << \"t erm \" << as(begin) << endl;\n\t\tbegin--;\n\t\treturn ret;\n\t}else{\n\t\treturn number(begin);\n\t}\n}\nll number(State &begin){\n//\tcout << \"num   \" << as(begin) << endl;\n\tll ret=0,dig=1;\n\twhile(isdigit(*begin)){\n\t\tret+=dig*(*begin-'0');\n\t\tbegin--;\n\t\tdig*=10;\n\t}\n//\tcout << \"n um  \" << as(begin) << endl;\n\treturn ret;\n}\nint main(){\n\tfor(;;){\n\t\tgetline(cin,s);\n\t\tif(s[0]=='#') break;\n\t\ts=\"?\"+s;\n\t\tstring::iterator it;\n\t\tfor(it=s.begin();it!=s.end();it++){\n\t\t\tif((*it)==' '){\n\t\t\t\ts.erase(it);\n\t\t\t\tit--;\n\t\t\t}\n\t\t}\n\t\tState begin=s.end();\n\t\tbegin--;\n\t\tll ans=expression(begin);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\nconstexpr int MOD = 1000000007;\ninline int sf(const int k, const int n) { return k > 32 ? 0 : n >> k; }\ninline int sq(const long long n) { return n * n % MOD; }\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\n\nint main()\n{\n    while (true) {\n        auto input = []() {\n            string s;\n            getline(cin, s);\n            string ans;\n            for (int i = s.size() - 1, st = 0, v = false; i >= 0; i--) {\n                const char c = s[i];\n                if (isdigit(c)) { ans.push_back(c), v = true; }\n                if (c == '>') {\n                    if (v) {\n                        ans.push_back('%'), v = false, i--;\n                    } else {\n                        ans.push_back('<'), st++;\n                    }\n                }\n                if (c == '<') { ans.push_back('>'), v = true, st--; }\n            }\n            return ans;\n        };\n        const string S = input();\n        if (S.empty()) { break; }\n        // show(S);\n        int pos = 0, ans = 0;\n        auto dfs = fix([&](auto&& self) -> int {\n            if (pos >= S.size()) { return ans; }\n            const char c = S[pos];\n            if (c == '<') {\n                pos++;\n                const int sub = self(self);\n                show(sub);\n                ans = sq(sub);\n                return self(self);\n            } else if (c == '%') {\n                pos++;\n                const int prev = ans;\n                const int next = self(self);\n                ans = sf(prev, next);\n                return self(self);\n            } else if (isdigit(c)) {\n                int num = 0;\n                for (int d = 1; pos < S.size() and isdigit(S[pos]); d *= 10, pos++) { num += d * (S[pos] - '0'); }\n                ans = num;\n                return self(self);\n            } else {\n                pos++;\n                return self(self);\n            }\n        });\n        dfs();\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).*begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 150000000;\nconst long long M = 1000000007;\n\n\ntypedef string::const_iterator State;\nint number(int&);\nint term(int&);\nint expression(int&);\n\nstring s;\n\n// ??°??????????????????????????????????????°????????????\nint number(int &i) {\n    int ret = 0;\n\n    while (isdigit(s[i])) {\n        ret *= 10;\n        ret += s[i] - '0';\n        i++;\n    }\n\n    return ret;\n}\n\n\n// ?????????????????????????????????????????????????????????????????????\nint term(int &i) {\n    if (s[i] == 'S') {\n        i+=2;\n        long long ret = expression(i);\n        i++;\n        return ret * ret % M;\n    } else {\n        return number(i);\n    }\n    return INF;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(int &i) {\n    int ret = term(i);\n\n    while(i < s.size() - 2){\n        if (s[i] ==  '>' && s[i + 1] == '>' && s[i + 2] != '>'){\n            i+=2;\n            ret = ret >> min(term(i), 31);\n        } else {\n            return ret;\n        }\n    }\n\n    return ret;\n}\n\ninline void deleteSpace(string &a){\n    size_t pos;\n    while((pos = a.find_first_of(\" \")) != string::npos){\n        a.erase(pos, 1);\n    }\n}\n\nint main(){\n    std::ifstream ifs(\"/Users/noy/Downloads/2570_in1.txt.html\");\n    while(getline(cin,s),s != \"#\"){\n        deleteSpace(s);\n        int i = 0;\n        cout << expression(i) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <sstream>\n#include <bitset>\nusing namespace std;\n#define MP(a, b) make_pair(a, b)\n#define VT vector\n#define FI first\n#define SE second\n#define FOR(i, n) for (int i = 0; i < n; ++i)\n#define REP(i, n) for (int i = 1; i <= n; ++i)\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst char *P;\nconst ll mod = 1000000007;\nll expr();\nll term();\n\nll term() {\n    ll x = 0;\n    if (P[0] == 'S') {\n        P += 2;\n        x = expr();\n        x = x * x % mod;\n        P++;\n    }\n    else {\n        char *endp;\n        x = strtoll(P, &endp, 10);\n        P = endp;\n    }\n    return x;\n}\n\nll expr() {\n    ll x = term();\n    ll b;\n    while (P[0] == '>' && P[1] == '>' && (P[2] == 'S' || isdigit(P[2]))) {\n        P += 2;\n        x >>= min(term(), 63LL);\n    }\n    return x;\n}\n\nint main() {\n    string s;\n    while (1) {\n        getline(cin, s);\n        if (s[0] == '#') break;\n        s.erase(remove(s.begin(), s.end(), ' '), s.end());\n        P = s.c_str();\n        // cout << s << endl;\n        cout << expr() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cctype>\n#include <cassert>\n\nusing namespace std;\n\ntypedef unsigned long long LL;\nconst LL MOD = 1000000007LL;\n\nvoid skip(const string &s, int &pos) {\n    while(pos >= 0 && s[pos] == ' ') --pos;\n}\n\nLL number(const string &s, int &pos) {\n    LL val = 0;\n    LL ord = 1;\n    while(pos >= 0 && isdigit(s[pos])) {\n        val += ord * (s[pos] - '0');\n        ord *= 10;\n        --pos;\n    }\n    return val;\n}\n\nLL expr(const string &s, int &pos) {\n    skip(s, pos);\n    if(isdigit(s[pos])) {\n        LL val = number(s, pos);\n        skip(s, pos);\n        if(pos >= 0) {\n            if(s[pos] == '>' && s[pos-1] == '>') {\n                pos -= 2;\n                const LL lhs = expr(s, pos);\n                val = lhs >> (val > 63 ? 63 : val);\n            } else {\n                assert(false);\n            }\n        }\n        return val;\n    } else if(s[pos] == '>') {\n        --pos;\n        LL val = expr(s, pos);\n        return (val*val) % MOD;\n    } else {\n        cerr << s << ' ' << pos << endl;\n        assert(false);\n    }\n}\n\nbool solve() {\n    string str;\n    getline(cin, str);\n    if(str == \"#\") return false;\n\n    int pos = str.size()-1;\n    for(char &c : str) {\n        if(c == 'S' || c == '<') c = ' ';\n    }\n    cout << expr(str, pos) << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nstruct Parser{\n    typedef long long LL;\n    static const LL MOD = 1000000007;\n    struct Result{\n        int idx;\n        LL val;\n        Result(int i, LL v) : idx(i), val(v) {}\n    };\n    string s;\n    Parser(string s_) {\n        stringstream ss(s_);\n        string t;\n        while(ss >> t){\n            s += t;\n        }\n    }\n    inline void inc(int& k, char c) const {\n        if(s[k] != c){\n            printf(\"assert s[%d] = %c but %c\\n\", k, c, s[k]);\n            exit(1);\n        }\n        k++;\n    }\n    inline bool is_term(char c) const {\n        if(isdigit(c)) return true;\n        return c == 'S';\n    }\n    int parse() const {\n        return expr(0).val;\n    }\n    Result expr(int k) const {\n        // printf(\"into expr(%d)\\n\", k);\n        Result r = term(k);\n        while(s[r.idx] == '>' && r.idx + 2 < s.size() && is_term(s[r.idx + 2])){\n            inc(r.idx, '>');\n            inc(r.idx, '>');\n            // printf(\"expr(%d) call term(%d)\\n\", k, r.idx);\n            Result t = term(r.idx);\n            // printf(\"back expr(%d)\\n\", k);\n            r.val = r.val >> min(60LL, t.val);\n            r.idx = t.idx;\n        }\n        return r;\n    }\n    Result term(int k) const {\n        // int fk = k;\n        // printf(\"into term(%d)\\n\", k);\n        if(s[k] == 'S'){\n            inc(k, 'S');\n            inc(k, '<');\n            // printf(\"term(%d) call expr(%d)\\n\", fk, k);\n            Result r = expr(k);\n            // printf(\"back term(%d) (%d, %d)\\n\", fk);\n            r.val = r.val * r.val % MOD;\n            inc(r.idx, '>');\n            return r;\n        }else{\n            LL num = 0;\n            while(isdigit(s[k])){\n                num = num * 10 + s[k++] - '0';\n            }\n            return Result(k, num);\n        }\n    }\n};\n\nint main(){\n    string s;\n    while(getline(cin, s) && s != \"#\"){\n        cout << Parser(s).parse() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nll MOD=1e9+7;\n\nll formula(string &s,int& p);\n\nll num(string &s,int& p){\n  ll res=0;\n  while(p!=s.size() && isdigit(s[p])){\n    res*=10;\n    res+=s[p]-'0';\n    p++;\n  }\n  return res;\n}\n\nll term(string &s,int &p){\n  if(s[p]=='S'){\n    p++;\n    assert(s[p]=='<');\n    p++;\n    ll res=formula(s,p);\n    assert(s[p]=='>');\n    p++;\n    return (res*res)%MOD;\n  }\n  if(isdigit(s[p])){\n    return num(s,p);\n  }\n  throw \"unexpected\";\n}\n\n\n\nll formula(string &s,int &p){\n  ll res=term(s,p);\n  while(p!=s.size() && s[p]!='>'){\n    assert(s[p]=='@');\n    p++;\n    ll rhs=term(s,p);\n    res=(rhs>32) ? 0LL : res>>rhs;\n  }\n  return res;\n}\n\nstring killSpace(string &s){\n  string res=\"\";\n  for(int i=0;i<s.size();i++){\n    if(s[i]!=' ') res.push_back(s[i]);\n  }\n  return res;\n}\n\nbool isShift(char x0,char x1,char x2){\n  return x0=='>' && x1=='>' && x2!='>';\n}\nstring shiftParse(string &s){\n  string res=\"\";\n  for(int i=0;i<s.size();i++){\n    if(i+2>=s.size()){\n      res+=s[i];\n    }\n    else if(isShift(s[i],s[i+1],s[i+2])){\n\tres+='@';\n\ti++;\n    }\n    else{\n      res+=s[i];\n    }\n  }\n  return res;\n}\nint main(){\n  string s;\n  while(getline(cin,s),s!=\"#\"){\n    s=killSpace(s);\n    s=shiftParse(s);\n    int p=0;\n    cout<<formula(s,p)<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cctype>\nusing namespace std;\ntypedef long long ll;\n \nconst ll mod = 1000000007;\nstring t;\nvector<int> table;\n \nll parse(int l,int r){\n  //cout << t.substr(l,r-l) << endl;\n  vector<ll> v;\n  for(int i=l;i<r;i++){\n    if(t[i] == 'S'){\n      int k = 1, pos = i+2;\n      while(pos<r){\n\tif(t[pos] == 'S')k++;\n\tif(t[pos] == '>' && !table[pos])k--;\n\tif(!k){\n\t  ll tmp = parse(i+2,pos);\n\t  v.push_back(tmp*tmp%mod);\n\t  i = pos;\n\t  break;\n\t}\n\tpos++;\n      }\n      i = pos;\n    }else if(isdigit(t[i])){\n      ll tmp = 0;\n      while(isdigit(t[i]))tmp = tmp*10 + t[i]-'0', i++;\n      v.push_back(tmp);\n      i--;\n    }\n  }\n \n  //for(int i=0;i<v.size();i++)cout << v[i] << \" \"; cout << endl;\n  ll res = v[0];\n  for(int i=1;i<v.size();i++)res >>= min(63ll,v[i]);\n  return res;\n}\n \nint main(){\n  string s;\n  while(getline(cin,s),s!=\"#\"){\n    t = \"\";\n    for(int i=0;i<s.size();i++){\n      if(s[i]!=' ')t+=s[i];\n    }\n    table.resize(t.size());\n    for(int i=0;i<t.size();i++)table[i] = 0;\n    for(int i=0;i<t.size();i++){\n      if(i!=0 && isdigit(t[i])){\n\tif(t[i-1]=='>')table[i-1] = table[i-2] = 1;\n      }\n      if(i!=0 && t[i] == 'S'){\n\tif(t[i-1]=='>')table[i-1] = table[i-2] = 1;\n      }\n    }\n \n    cout << parse(0,t.size()) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdlib>\n#include<sstream>\n#include<algorithm>\n#define mod 1000000007\nusing namespace std;\n\ntypedef unsigned long long ll;\n\nvector<string> a;\n\nstring f1(string a){\n  ll x=(ll)atoi(a.c_str());\n  x=(x*x)%mod;\n  ostringstream os;\n  os<<x;\n  return os.str();\n}\n\nstring f2(string a,string b){\n  ll x=atoi(a.c_str()),y=atoi(b.c_str()),c=1;\n  for(int i=0;i<y;i++){\n    if(x<c)return \"0\";\n    c*=2;\n  }\n  x=x/c;\n  ostringstream os;\n  os<<x;\n  return os.str();\n}\n\nvoid rec(int s,int t){\n  for(int i=s;i<t;i++){\n    if(a[i]==\"<\"){\n      int l=1,r=0;\n      for(int j=i+1;j<a.size();j++){\n\tif(a[j]==\"<\")l++;\n\tif(a[j]==\">\")r++;\n\tif(l==r){\n\t  rec(i+1,j);\n\t  i=j-1;\n\t  break;\n\t}\n      }\n    }\n    else if(a[i]==\">>\"){\n      if(a[i+1]==\"<\"){\n\tint l=0,r=0;\n\tvector<string> b;\n\tfor(int j=i+1;j<a.size();j++){\n\t  b.push_back(a[j]);\n\t  if(a[j]==\"<\")l++;\n\t  if(a[j]==\">\")r++;\n\t  if(l==r){\n\t    rec(i+1,j+1);\n\t    a[j]=f2(a[i-1],a[j]);\n\t    i=j;\n\t    break;\n\t  }\n\t}\n      }\n      else a[i+1]=f2(a[i-1],a[i+1]);\n    }\n    else if(a[i]==\">\")a[i]=f1(a[i-1]);\n    else {}\n  }\n}\n\nint main()\n{\n  while(1){\n    char c;\n    string s,t=\"\";\n    vector<string> b;\n    getline(cin,s);\n    if(s[0]=='#')break;\n    a.clear();\n    for(int i=0;i<s.length();i++)if(s[i]!=' ')t+=s[i];\n    string tmp=\"\";\n    for(int i=0;i<t.length();i++){\n      if(t[i]=='S'){\n\tb.push_back(\"<\");\n\ti++;\n      }\n      else if(t[i]=='>'){\n\tif(tmp!=\"\")b.push_back(tmp);\n\ttmp=\"\";\n\tb.push_back(\">\");\n      }\n      else tmp+=t[i];\n      if(i==t.length()-1 && tmp!=\"\")b.push_back(tmp);\n    }\n\n    for(int i=b.size()-1;0<i;i--){\n      if(b[i]!=\">\"){\n\ta.push_back(b[i]);\n\tif(b[i-1]==\">\"){\n\t  i-=2;\n\t  a.push_back(\">>\");\n\t}\n      }\n      else a.push_back(b[i]);\n    }\n    a.push_back(b[0]);\n    reverse(a.begin(),a.end());\n    rec(0,a.size());\n    cout<<a[a.size()-1]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef string::const_iterator State;\nDef expr(State &i);\nDef term(State &i);\nDef factor(State &i);\nDef number(State &i);\nll MOD=1000000007;\nstring s;\nvoid consume(State &i,char expected){\n\tif(*i==expected)i++;\n\telse{\n\t\texit(0);\n\t}\n}\nDef expr(State &i){\n\tDef out=term(i);\n\twhile(*i=='>'&&*(i+1)=='>'&&(*(i+2)=='S'||isdigit(*(i+2)))){\n\t\ti+=2;\n\t\tDef out1=term(i);\n\t\tout>>=min(out1,33ll);\n\t}\n\treturn out;\n}\nDef term(State &i){\n\tif(isdigit(*i))return number(i);\n\ti++;\n\ti++;\n\tDef out=expr(i);\n\tout=out*out%MOD;\n\ti++;\n\treturn out;\n}\nDef number(State &i){\n\tDef out=0;\n\twhile(isdigit(*i))out=out*10+*(i++)-'0';\n\treturn out;\n}\nint main(){\n\twhile(1){\n\t\tgetline(cin,s);\n\t\tif(s==\"#\")break;\n\t\ts.erase(remove(s.begin(),s.end(),' '),s.end());\n\t\tState begin=s.begin();\n\t\tcout<<expr(begin)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n\ntypedef long long lint;\ntypedef pair<int, int> pii;\n\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\nconst lint MOD = 1e9 + 7;\n\nstring S;\n\nvector<string> split_str(string _s, string _t) {\n\tvector<string> res;\n\tfor (int p = 0; (p = _s.find(_t)) != -1;) {\n\t\tres.push_back(_s.substr(0, p));\n\t\t_s = _s.substr(p + size_of(_t));\n\t}\n\tres.push_back(_s);\n\treturn res;\n}\n\nlint parse(int left, int right) {\n\t//cout << left << \" \" << right << endl;\n\t//if (left > right) return -1;\n\t\n\tint lcnt = 0, rcnt = 0;\n\tint n_left = -1;\n\tqueue<lint> q;\n\tbool d_flag = false;\n\tint d_pos = -1;\n\t\n\tfor_(i,left,right) {\n\t\tif (S[i] == '<') {\n\t\t\tif (lcnt == 0) n_left = i + 1;\n\t\t\tlcnt++;\n\t\t}\n\t\tif (S[i] == '>') {\n\t\t\trcnt++;\n\t\t}\n\t\t\n\t\tif ((S[i] == '<' || S[i] == '|') && d_flag) {\n\t\t\tstring ress = S.substr(d_pos, i - d_pos);\n\t\t\tstringstream ss(ress);\n\t\t\tlint res; ss >> res;\n\t\t\tq.push(res);\n\t\t\td_flag = false;\n\t\t}\n\t\t\n\t\tif (!d_flag && lcnt == 0 && isdigit(S[i])) {\n\t\t\td_pos = i;\n\t\t\td_flag = true;\n\t\t}\n\t\t\n\t\tif (lcnt > 0 && rcnt > 0 && lcnt == rcnt) {\n\t\t\tlint res = parse(n_left, i);\n\t\t\t/*\n\t\t\tif (res == -1) {\n\t\t\t\tlcnt = rcnt = 0;\n\t\t\t\tcontinue;\n\t\t\t}*/\n\t\t\tres *= res;\n\t\t\tres %= MOD;\n\t\t\tq.push(res);\n\t\t\tlcnt = rcnt = 0;\n\t\t}\n\t}\n\t\n\tif (d_flag) {\n\t\tstring ress = S.substr(d_pos, right - d_pos);\n\t\tstringstream ss(ress);\n\t\tlint res; ss >> res;\n\t\tq.push(res);\n\t}\n\t\n\tassert(!q.empty());\n\tlint res = q.front(); q.pop();\n\twhile (!q.empty()) {\n\t\tlint d = q.front(); q.pop();\n\t\twhile (d > 0 && res > 0) {\n\t\t\tres /= 2;\n\t\t\td--;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nvoid solve() {\n\tint n = size_of(S);\n\tint i = 0;\n\twhile (i < size_of(S)) {\n\t\tif (i > 2 && (S[i] == 'S' || isdigit(S[i]))) {\n\t\t\tif (S[i - 1] == '>' && S[i - 2] == '>') {\n\t\t\t\tS = S.substr(0, i - 2) + \"|\" + S.substr(i);\n\t\t\t\ti = i - 2;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tcout << S << endl;\n\tn = size_of(S);\n\tcout << parse(0, n) << endl;\n}\n\nint main() {\n\tstring input;\n\twhile (getline(cin, input)) {\n\t\tif (input[0] == '#') break;\n\t\tvector< string > split = split_str(input, \" \");\n\t\tint v_size = size_of(split);\n\t\tS = \"\";\n\t\tfor_(i,0,v_size) S += split[i];\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <cstdio>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <algorithm>\n#include <limits>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MD = 1e9+7.1;\n\nint n;\nchar s[2000030];\n\nll expr(char **begin);\n\nll numb(char **begin) {\n    ll r = 0;\n    while (isdigit(**begin)) {\n        r *= 10;\n        r += **begin - '0';\n        *begin += 1;\n    }\n    return r;\n}\n\nll term(char **begin) {\n    if (**begin == 'S') {\n        *begin += 2;\n        ll r = expr(begin)%MD;\n        *begin += 1;\n        return (r*r)%MD;\n    } else {\n        return numb(begin);\n    }\n}\n\nbool ist(char c) {\n    return (isdigit(c) || c == 'S') ;\n}\nll expr(char **begin) {\n    ll r = term(begin);\n    while (true) {\n        if (**begin == '>' && *(*begin + 1) == '>' && ist(*(*begin + 2))) {\n            *begin += 2;\n            r >>= min(60LL, term(begin));\n        } else {\n            break;\n        }\n    }\n    return r;\n}\n\nint main() {\n    while (true) {\n        string ss;\n        getline(cin, ss);\n        if (ss[0] == '#') break;\n        n = 0;\n        for (char c: ss) {\n            if (c != ' ') {\n                s[n] = c;\n                n++;\n            }\n        }\n        s[n] = '@';\n        char *beg = s;\n        ll ans = expr(&beg);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\ntypedef long long LL;\n\n#define MOD 1000000007LL\n\nLL expr();\nLL term();\n\nconst char *P;\n\nLL expr(){\n\tLL x = term();\n\twhile(*P == '>' && P[1] == '>' && (P[2] == 'S' || isdigit(P[2]))){\n\t\tP += 2;\n\t\tLL y = term();\n\t\tx >>= min(y, 63LL);\n\t}\n\treturn x;\n}\n\nLL term(){\n\tLL x = 0;\n\tif(*P == 'S'){\n\t\tP += 2;\n\t\tx = expr();\n\t\tx = x * x % MOD;\n\t\t++P;\n\t}\n\telse{\n\t\tchar *endp;\n\t\tx = strtoll(P, &endp, 10);\n\t\tP = endp;\n\t}\n\treturn x;\n}\n\nint main(){\n\tstring s;\n\twhile(getline(cin, s), s[0] != '#'){\n\t\ts.erase(remove(s.begin(), s.end(), ' '), s.end());\n\t\tP = s.c_str();\n\t\tcout << expr() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) cerr << #x << \" = \" << (x) << endl\nusing namespace std;\nconstexpr int MOD = 1000000007;\ninline int sf(const int k, const int n) { return k > 32 ? 0 : n >> k; }\ninline int sq(const long long n) { return n * n % MOD; }\ntemplate <typename Functor>\nstruct fix_type\n{\n    Functor functor;\n    template <typename... Args>\n    decltype(auto) operator()(Args&&... args) const& { return functor(functor, std::forward<Args>(args)...); }\n};\ntemplate <typename Functor>\nfix_type<typename std::decay<Functor>::type> fix(Functor&& functor) { return {std::forward<Functor>(functor)}; }\n\nint main()\n{\n    while (true) {\n        auto input = []() {\n            string s;\n            getline(cin, s);\n            string ans;\n            for (int i = s.size() - 1, st = 0, v = false; i >= 0; i--) {\n                const char c = s[i];\n                if (isdigit(c)) { ans.push_back(c), v = true; }\n                if (c == '>') {\n                    if (v) {\n                        ans.push_back('%'), v = false, i--;\n                    } else {\n                        ans.push_back('<'), st++;\n                    }\n                }\n                if (c == '<') { ans.push_back('>'), v = true, st--; }\n            }\n            return ans;\n        };\n        const string S = input();\n        if (S.empty()) { break; }\n        // show(S);\n        int pos = 0, ans = 0;\n        auto dfs = fix([&](auto&& self) -> int {\n            if (pos >= S.size()) { return ans; }\n            const char c = S[pos];\n            if (c == '<') {\n                pos++;\n                const int sub = self(self);\n                // show(sub);\n                ans = sq(sub);\n                return self(self);\n            } else if (c == '%') {\n                pos++;\n                const int prev = ans;\n                const int next = self(self);\n                ans = sf(prev, next);\n                return self(self);\n            } else if (isdigit(c)) {\n                int num = 0;\n                for (int d = 1; pos < S.size() and isdigit(S[pos]); d *= 10, pos++) { num += d * (S[pos] - '0'); }\n                ans = num;\n                return self(self);\n            } else {\n                pos++;\n                return self(self);\n            }\n        });\n        dfs();\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n\ntypedef long long lint;\ntypedef pair<int, int> pii;\n\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\nconst lint MOD = 1e9 + 7;\n\nstring S;\n\nvector<string> split_str(string _s, string _t) {\n\tvector<string> res;\n\tfor (int p = 0; (p = _s.find(_t)) != -1;) {\n\t\tres.push_back(_s.substr(0, p));\n\t\t_s = _s.substr(p + size_of(_t));\n\t}\n\tres.push_back(_s);\n\treturn res;\n}\n\nlint parse(int left, int right) {\n\t//cout << left << \" \" << right << endl;\n\t//if (left > right) return -1;\n\t\n\tint lcnt = 0, rcnt = 0;\n\tint n_left = -1;\n\tqueue<lint> q;\n\tbool d_flag = false;\n\tint d_pos = -1;\n\t\n\tfor_(i,left,right) {\n\t\tif (S[i] == '<') {\n\t\t\tif (lcnt == 0) n_left = i + 1;\n\t\t\tlcnt++;\n\t\t}\n\t\tif (S[i] == '>') {\n\t\t\trcnt++;\n\t\t}\n\t\t\n\t\tif ((S[i] == '<' || S[i] == '|') && d_flag) {\n\t\t\tstring ress = S.substr(d_pos, i - d_pos);\n\t\t\tstringstream ss(ress);\n\t\t\tlint res; ss >> res;\n\t\t\tq.push(res);\n\t\t\td_flag = false;\n\t\t}\n\t\t\n\t\tif (!d_flag && lcnt == 0 && isdigit(S[i])) {\n\t\t\td_pos = i;\n\t\t\td_flag = true;\n\t\t}\n\t\t\n\t\tif (lcnt > 0 && rcnt > 0 && lcnt == rcnt) {\n\t\t\tlint res = parse(n_left, i);\n\t\t\t/*\n\t\t\tif (res == -1) {\n\t\t\t\tlcnt = rcnt = 0;\n\t\t\t\tcontinue;\n\t\t\t}*/\n\t\t\tres *= res;\n\t\t\tres %= MOD;\n\t\t\tq.push(res);\n\t\t\tlcnt = rcnt = 0;\n\t\t}\n\t}\n\t\n\tif (d_flag) {\n\t\tstring ress = S.substr(d_pos, right - d_pos);\n\t\tstringstream ss(ress);\n\t\tlint res; ss >> res;\n\t\tq.push(res);\n\t}\n\t\n\tif (q.empty()) return MOD;\n\tlint res = q.front(); q.pop();\n\twhile (!q.empty()) {\n\t\tlint d = q.front(); q.pop();\n\t\twhile (d > 0 && res > 0) {\n\t\t\tres /= 2;\n\t\t\td--;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nvoid solve() {\n\tint n = size_of(S);\n\tint i = 0;\n\twhile (i < size_of(S)) {\n\t\tif (i > 2 && (S[i] == 'S' || isdigit(S[i]))) {\n\t\t\tif (S[i - 1] == '>' && S[i - 2] == '>') {\n\t\t\t\tS = S.substr(0, i - 2) + \"|\" + S.substr(i);\n\t\t\t\ti = i - 2;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tcout << S << endl;\n\tn = size_of(S);\n\tcout << parse(0, n) << endl;\n}\n\nint main() {\n\tstring input;\n\twhile (getline(cin, input)) {\n\t\tif (input[0] == '#') break;\n\t\tvector< string > split = split_str(input, \" \");\n\t\tint v_size = size_of(split);\n\t\tS = \"\";\n\t\tfor_(i,0,v_size) S += split[i];\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).*begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 150000000;\nconst long long M = 1000000007;\n\n\ntypedef string::const_iterator State;\nint number(int&);\nint term(int&);\nint expression(int&);\n\nstring s;\n\n// ??°??????????????????????????????????????°????????????\nint number(int &i) {\n    int ret = 0;\n\n    while (isdigit(s[i])) {\n        ret *= 10;\n        ret += s[i] - '0';\n        i++;\n    }\n\n    return ret;\n}\n\n\n// ?????????????????????????????????????????????????????????????????????\nint term(int &i) {\n    if (s[i] == 'S') {\n        i+=2;\n        long long ret = expression(i);\n        i++;\n        return ret * ret % M;\n    } else {\n        return number(i);\n    }\n    return INF;\n}\n\n// ?????????????????????????????????????????????????????????????????????\nint expression(int &i) {\n    int ret = term(i);\n\n    while(i < s.size() - 2){\n        if (s[i] ==  '>' && s[i + 1] == '>' && s[i + 2] != '>'){\n            i+=2;\n            ret = ret >> min(term(i), 31);\n        } else {\n            return ret;\n        }\n    }\n\n    return ret;\n}\n\ninline void deleteSpace(string &a){\n    size_t pos;\n    while((pos = a.find_first_of(\" \")) != string::npos){\n        a.erase(pos, 1);\n    }\n}\n\nint main(){\n    std::ifstream ifs(\"/Users/noy/Downloads/2570_in1.txt.html\");\n    while(getline(cin,s),s != \"#\"){\n        //deleteSpace(s);\n        string tmp;\n        for(auto it:s){\n            if(it != ' ') tmp+=it;\n        }\n        s = tmp;\n        int i = 0;\n        cout << expression(i) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nusing i64=int64_t;\n\ni64 eval_number(const string& expr,int& i){\n    i64 res=0;\n    while(i<expr.size() and isdigit(expr[i])){\n        res*=10;\n        res+=expr[i]-'0';\n        ++i;\n    }\n    return res;\n}\n\nvoid consume(const string& s,int& i,char c){\n    assert(s[i]==c);\n    ++i;\n}\n\ni64 eval_term(const string&,int&);\ni64 eval_expr(const string&,int&);\n\ni64 eval_term(const string& term,int& i){\n    if(isdigit(term[i])) return eval_number(term,i);\n    consume(term,i,'S');\n    while(term[i]==' ') consume(term,i,' ');\n    consume(term,i,'<');\n    while(term[i]==' ') consume(term,i,' ');\n    i64 x=eval_expr(term,i);\n    while(term[i]==' ') consume(term,i,' ');\n    consume(term,i,'>');\n    return x*x%1000000007;\n}\n\ni64 eval_expr(const string& expr,int& i){\n    i64 x=eval_term(expr,i);\n    for(;;){\n        if(i==expr.size()) break;\n        int j=i;\n\n        while(j<expr.size() and expr[j]==' ') consume(expr,j,' ');\n        if(j==expr.size() or expr[j]!='>') return x;\n        consume(expr,j,'>');\n        if(j==expr.size() or expr[j]!='>') return x;\n        consume(expr,j,'>');\n        while(j<expr.size() and expr[j]==' ') consume(expr,j,' ');\n        if(j==expr.size() or (expr[j]!='S' and !isdigit(expr[j]))) return x;\n        i=j;\n        i64 y=eval_term(expr,i);\n        rep(i,0,y){\n            if(x==0) break;\n            x>>=1;\n        }\n    }\n    return x;\n}\n\nvoid solve(string expr){\n    int i=0;\n    cout << eval_expr(expr,i) << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    for(;;){\n        string expr;\n        getline(cin,expr);\n        if(expr==\"#\") break;\n        solve(expr);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n);i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(a);i>=(int)(b);--i)\n#define ALL(a) (a).begin(),(a).end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\n\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\n\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n  if(a < b) {a = b; return true;}\n  return false;\n}\n\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n  if(a > b) {a = b; return true;}\n  return false;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  REP(i, SZ(v)) {\n    if(i) os << \" \";\n    os << v[i];\n  }\n  return os;\n}\n\nbool solve() {\n  string in;\n  getline(cin, in);\n  if (in == \"#\") return false;\n  string s;\n  REP(i, SZ(in)) {\n    if (in[i] != ' ') {\n      s += in[i];\n    }\n  }\n  s += \">>0\";\n\n  vll val = {-1};\n  vll num = {0};\n\n  REP(i, SZ(s)) {\n    /*\n    cout << i << endl;\n    cout << val << endl;\n    cout << num << endl;\n    cout << endl;\n     */\n    if('0' <= s[i] && s[i] <= '9') {\n      num.back() *= 10;\n      num.back() += s[i] - '0';\n    } else if(s[i] == 'S') {\n      val.push_back(-1);\n      num.push_back(0);\n      i++;\n    } else if(s[i] == '>' && i < SZ(s)-2 && s[i+1] == '>' && (('0' <= s[i+2] && s[i+2] <= '9') || s[i+2] == 'S')) {\n      if(val.back() == -1) {\n        val.back() = num.back();\n        num.back() = 0;\n      } else {\n        while(val.back() > 0 && num.back() > 0) {\n          val.back() /= 2;\n          num.back()--;\n        }\n        num.back() = 0;\n      }\n      i++;\n    } else if(s[i] == '>') {\n      if(val.back() == -1) {\n        val.back() = num.back();\n        num.back() = 0;\n      } else {\n        while(val.back() > 0 && num.back() > 0) {\n          val.back() /= 2;\n          num.back()--;\n        }\n        num.back() = 0;\n      }\n      ll tmp = val.back();\n      tmp *= tmp;\n      tmp %= MOD;\n      val.pop_back();\n      num.pop_back();\n      if(val.back() == -1) {\n        val.back() = tmp;\n      } else {\n        while(val.back() > 0 && tmp > 0) {\n          val.back() /= 2;\n          tmp--;\n        }\n      }\n    }\n  }\n\n  cout << val[0] << endl;\n  return true;\n}\n\nint main() {\n\n  while(solve()) {}\n\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nint number(string& s, int & i) {\n    int ret = 0;\n    while (isdigit(s[i])) {\n        ret = ret * 10 + (s[i++] - '0');\n    }\n    return ret;\n}\nint exp1(string& s, int & i);\nint exp2(string& s, int & i);\nint exp1(string& s, int & i) {\n    int acc = exp2(s, i);\n    while (i < s.size()) {\n        if (s[i] == '>' && i + 2 < s.size() && s[i + 1] == '>' && s[i + 2] != '>') {\n            i += 2;\n            int rhs = exp2(s, i);\n            acc = rhs < 32 ? acc / (1LL << rhs) : 0;\n        } else break;\n    }\n    return acc;\n}\nint exp2(string& s, int & i) {\n    if (s[i] == 'S') {\n        assert(s[++i] == '<');\n        int ret = exp1(s, ++i);\n        assert(s[i++] == '>');\n        return ret * ret % MOD;\n    } else {\n        return number(s, i);\n    }\n}\nvoid solve() {\n    string s;\n    {\n        string t;\n        getline(cin, t);\n        if (t == \"#\") exit(0);\n        for (char c : t) {\n            if (c != ' ') s.push_back(c);\n        }\n    }\n    int i = 0;\n    cout << exp1(s, i) << endl;\n}\n\nsigned main() {\n    while (1) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\nconst int mod = 1000000007;\n\nstruct Mod {\n  int num;\n  Mod () : num(0) {;}\n  Mod (int n) : num(n) {;}\n  operator int() { return num; }\n};\n\nMod operator+(Mod a, Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator-(Mod a, Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator*(Mod a, Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator+=(Mod &a, Mod b) { return a = a + b; }\nMod operator-=(Mod &a, Mod b) { return a = a - b; }\n\nint sp(const string &s, int i) {\n  while(i < s.size() && s[i] == ' ') ++i;\n  return i;\n}\n\npair<Mod, int> num(const string &s, int i) {\n  Mod val;\n  Mod p10 = 1;\n  while(i < s.size() && '0' <= s[i] && s[i] <= '9') {\n    val += p10 * Mod(s[i] - '0');\n    p10 = p10 * Mod(10);\n    ++i;\n  }\n  return make_pair(val, i);\n}\n\npair<Mod, int> expr(const string &s, int i);\n\npair<Mod, int> term(const string &s, int i) {\n  if (s[i] == '>') {\n    ++i;\n    i = sp(s, i);\n    Mod val;\n    tie(val, i) = expr(s, i);\n    i = sp(s, i);\n    ++i;\n    i = sp(s, i);\n    ++i;\n    return make_pair(val * val, i);\n  } else {\n    return num(s, i);\n  }\n}\n\npair<Mod, int> expr(const string &s, int i) {\n  Mod val;\n  tie(val, i) = term(s, i);\n  i = sp(s, i);\n  if (i < s.size() && s[i] == '>') {\n    i += 2;\n    i = sp(s, i);\n    auto rhs = expr(s, i);\n    //cout<<val<<' '<<rhs.first<<endl;\n    if (val < 31)\n      val = (int)rhs.first >> (int)val;\n    else\n      val = 0;\n    i = rhs.second;\n  }\n  return make_pair(val, i);\n}\n\nint main() {\n  while(1){\n    string s;\n    getline(cin,s);\n    if(s[0]=='#')break;\n    reverse(begin(s),end(s));\n    cout << expr(s, 0).first << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nusing i64=int64_t;\n\ni64 eval_number(const string& expr,int& i){\n    i64 res=0;\n    while(i<expr.size() and isdigit(expr[i])){\n        res*=10;\n        res+=expr[i]-'0';\n        ++i;\n    }\n    return res;\n}\n\ni64 eval_term(const string&,int&);\ni64 eval_expr(const string&,int&);\n\ni64 eval_term(const string& term,int& i){\n    if(isdigit(term[i])) return eval_number(term,i);\n    \n    assert(term[i]=='S');\n    ++i;\n\n    while(term[i]==' ') ++i;\n    \n    assert(term[i]=='<');\n    ++i;\n    \n    while(term[i]==' ') ++i;\n    \n    i64 x=eval_expr(term,i);\n    \n    while(term[i]==' ') ++i;\n    \n    assert(term[i]=='>');\n    ++i;\n    \n    return x*x%1000000007;\n}\n\ni64 eval_expr(const string& expr,int& i){\n    i64 x=eval_term(expr,i);\n    for(;;){\n        if(i==expr.size()) break;\n        int j=i;\n\n        while(j<expr.size() and expr[j]==' ') ++j;\n        if(j==expr.size() or expr[j]!='>') return x;\n        \n        ++j;\n        \n        if(j==expr.size() or expr[j]!='>') return x;\n        ++j;\n\n        while(j<expr.size() and expr[j]==' ') ++j;\n        \n        if(j==expr.size() or (expr[j]!='S' and !isdigit(expr[j]))) return x;\n        \n        i=j;\n        i64 y=eval_term(expr,i);\n        rep(i,0,y){\n            if(x==0) break;\n            x>>=1;\n        }\n    }\n    return x;\n}\n\nvoid solve(string expr){\n    int i=0;\n    cout << eval_expr(expr,i) << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    for(;;){\n        string expr;\n        getline(cin,expr);\n        if(expr==\"#\") break;\n        solve(expr);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2570: Shipura\n// 2017.12.1 bal4u@uu\n\n#include <stdio.h>\n#include <ctype.h>\n\n#define M  1000000007\n#define BASE -1\n#define SFT  -2\n#define S    -3\n\nchar buf[2000002], *p;\nint stack[2000002], *top;\n\nint main()\n{\n\tint x, y;\n\tchar *q;\n\n\twhile (fgets(p=buf, sizeof(buf), stdin) && *p != '#') {\n\t\ttop = stack, *top++ = BASE;\n\t\twhile (*p >= ' ') {\n\t\t\twhile (*p == ' ' || *p == '<') p++;\n\t\t\tif (*p == 'S') { p++, *top++ = S; continue; }\n\t\t\tif (*p == '>' && *(p+1) == '>') {\n\t\t\t\tq = p+2;\n\t\t\t\twhile (*q == ' ') q++;\n\t\t\t\tif (*q == '>' || *q == '<' || *q < ' ');\n\t\t\t\telse { p = q, *top++ = SFT; continue; }\n\t\t\t}\n\t\t\tif (*p >= '0' && *p <= '9') {\n\t\t\t\tx = 0; while (*p >= '0' && *p <= '9')\n\t\t\t\t\tx = (x<<3) + (x<<1) + (*p++ & 0xf);\n\t\t\t} else {\t\t//  '>'\n\t\t\t\tp++;\n\t\t\t\tx = *--top;\n\t\t\t\tx = (long long)x * x % M;\n\t\t\t\ttop--;\n\t\t\t}\n\t\t\tif (*(top-1) == SFT) {\n\t\t\t\ttop -= 2;\n\t\t\t\ty = *top;\n\t\t\t\tif (x > 31) y = 0; else y >>= x;\n\t\t\t\tx = y;\n\t\t\t}\n\t\t\t*top++ = x;\n\t\t}\n\t\tprintf(\"%d\\n\", x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n\n#define MOD_BY 1000000007\n#define SIZE_MAX 2000000\n\n#define ESU (-1)\n#define SIFUTO (-2)\n#define KAKKO (-3)\n\nint expr[SIZE_MAX];\nint expr_num;\nint stack[SIZE_MAX];\nint stack_num;\n\nvoid compile(const char* expr_str) {\n\tint i;\n\tint digit_flag=0;\n\tint current_number=0;\n\texpr_num=stack_num=0;\n\tfor(i=0;expr_str[i]!='\\0';i++) {\n\t\tif(isdigit(expr_str[i])) {\n\t\t\tcurrent_number=current_number*10+expr_str[i]-'0';\n\t\t\tdigit_flag=1;\n\t\t} else {\n\t\t\tif(digit_flag) {\n\t\t\t\texpr[expr_num++]=current_number;\n\t\t\t\tcurrent_number=0;\n\t\t\t\tdigit_flag=0;\n\t\t\t}\n\t\t\tswitch(expr_str[i]) {\n\t\t\t\tcase 'S':\n\t\t\t\t\tstack[stack_num++]=ESU;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<':\n\t\t\t\t\tstack[stack_num++]=KAKKO;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\twhile(stack_num>0 && stack[stack_num-1]!=KAKKO) {\n\t\t\t\t\t\texpr[expr_num++]=stack[--stack_num];\n\t\t\t\t\t}\n\t\t\t\t\tstack[stack_num++]=SIFUTO;\n\t\t\t\t\ti++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ')':\n\t\t\t\t\twhile(stack_num>0 && stack[--stack_num]!=KAKKO) {\n\t\t\t\t\t\texpr[expr_num++]=stack[stack_num];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(digit_flag) {\n\t\texpr[expr_num++]=current_number;\n\t\tdigit_flag=0;\n\t}\n\twhile(stack_num>0) {\n\t\texpr[expr_num++]=stack[--stack_num];\n\t}\n}\n\nint run(void) {\n\tint i;\n\tstack_num=0;\n\tfor(i=0;i<expr_num;i++) {\n\t\tif(expr[i]==ESU) {\n\t\t\tint ret=0,now=stack[stack_num-1],left=stack[stack_num-1];\n\t\t\twhile(left>0) {\n\t\t\t\tif(left&1) {\n\t\t\t\t\tret+=now;\n\t\t\t\t\tif(ret>=MOD_BY)ret-=MOD_BY;\n\t\t\t\t}\n\t\t\t\tnow+=now;\n\t\t\t\tif(now>=MOD_BY)now-=MOD_BY;\n\t\t\t\tleft>>=1;\n\t\t\t}\n\t\t\tstack[stack_num-1]=ret;\n\t\t} else if(expr[i]==SIFUTO) {\n\t\t\tif(stack[stack_num-1]<32) {\n\t\t\t\tstack[stack_num-2]>>=stack[stack_num-1];\n\t\t\t} else {\n\t\t\t\tstack[stack_num-2]=0;\n\t\t\t}\n\t\t\tstack_num--;\n\t\t} else if(expr[i]>=0) {\n\t\t\tstack[stack_num++]=expr[i];\n\t\t}\n\t}\n\treturn stack[0];\n}\n\nint main(void) {\n\tstatic char input[SIZE_MAX];\n\twhile(fgets(input,sizeof(input),stdin)!=NULL && input[0]!='#') {\n\t\tint i;\n\t\tint expect_number=1;\n\t\tfor(i=0;input[i];i++);\n\t\tfor(i--;i>=0;i--) {\n\t\t\tif(input[i]=='>') {\n\t\t\t\tif(expect_number) {\n\t\t\t\t\tinput[i]=')';\n\t\t\t\t} else {\n\t\t\t\t\ti--;\n\t\t\t\t\texpect_number=1;\n\t\t\t\t}\n\t\t\t} else if(isdigit(input[i])) {\n\t\t\t\texpect_number=0;\n\t\t\t} else if(input[i]=='S') {\n\t\t\t\texpect_number=0;\n\t\t\t}\n\t\t}\n\t\tcompile(input);\n\t\tprintf(\"%d\\n\",run());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2570: Shipura\n// 2017.12.1 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\n#define M  1000000007\n#define TOP -1\n#define SFT -2\n#define S   -3\n\nchar b1[2000002];\nint stack[2000002], top;\n\nint main()\n{\n\tint x, y;\n\tchar *p;\n\n\twhile (fgets(b1+1, sizeof(b1), stdin) && *(b1+1) != '#') {\n\t\tp = b1, *p++ = 0; while (*p >= ' ') *p++; *p-- = 0;\n\t\twhile (*p) {\n\t\t\tif (*p == '<') { *p-- = ' '; continue; }\n\t\t\tif (!isdigit(*p) && *p != 'S') { p--; continue; }\n\t\t\tif (*p == 'S') p--;\n\t\t\telse while (isdigit(*p)) p--;\n\t\t\twhile (*p == ' ') p--;\n\t\t\tif (*p == '>' && *(p-1) == '>') *p = 'R', *(p-1) = ' ', p-=2;\n\t\t}\n\n\t\tp++, stack[0] = TOP, top = 1;\n\t\twhile (*p) {\n\t\t\twhile (*p == ' ') p++;\n\t\t\tif (*p == 'S') { p++, stack[top++] = S; continue; }\n\t\t\tif (*p == 'R') { p++, stack[top++] = SFT; continue; }\n\t\t\tif (isdigit(*p)) {\n\t\t\t\tx = 0; while (isdigit(*p)) x = (x<<3)+(x<<1) + (*p++ & 0xf);\n\t\t\t} else {\t\t//  '>'\n\t\t\t\tp++;\n\t\t\t\tx = stack[--top];\n\t\t\t\tx = (long long)x * x % M;\n\t\t\t\ttop--;\n\t\t\t}\n\t\t\tif (stack[top-1] == SFT) {\n\t\t\t\ttop -= 2;\n\t\t\t\ty = stack[top];\n\t\t\t\tif (x > 31) y = 0;\n\t\t\t\telse y >>= x;\n\t\t\t\tx = y;\n\t\t\t}\n\t\t\tstack[top++] = x;\n\t\t}\n\t\tprintf(\"%d\\n\", x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2570: Shipura\n// 2017.12.1 bal4u@uu\n\n#include <stdio.h>\n#include <ctype.h>\n\n#define M  1000000007\n#define BASE -1\n#define SFT  -2\n#define S    -3\n\nchar b1[2000002];\nint stack[2000002], *top;\n\nint main()\n{\n\tint x, y;\n\tchar *p;\n\n\twhile (fgets(b1+1, sizeof(b1), stdin) && *(b1+1) != '#') {\n\t\tp = b1, *p++ = 0; while (*p >= ' ') *p++; *p-- = 0;\n\t\twhile (*p) {\n\t\t\tif (*p == '<') { *p-- = ' '; continue; }\n\t\t\tif (!isdigit(*p) && *p != 'S') { p--; continue; }\n\t\t\tif (*p == 'S') p--;\n\t\t\telse while (isdigit(*p)) p--;\n\t\t\twhile (*p == ' ') p--;\n\t\t\tif (*p == '>' && *(p-1) == '>') *p = 'R', *(p-1) = ' ', p-=2;\n\t\t}\n\n\t\tp++, top = stack, *top++ = BASE;\n\t\twhile (*p) {\n\t\t\twhile (*p == ' ') p++;\n\t\t\tif (*p == 'S') { p++, *top++ = S; continue; }\n\t\t\tif (*p == 'R') { p++, *top++ = SFT; continue; }\n\t\t\tif (isdigit(*p)) {\n\t\t\t\tx = 0;\n\t\t\t\twhile (isdigit(*p)) x = (x<<3)+(x<<1) + (*p++ & 0xf);\n\t\t\t} else {\t\t//  '>'\n\t\t\t\tp++;\n\t\t\t\tx = *--top;\n\t\t\t\tx = (long long)x * x % M;\n\t\t\t\ttop--;\n\t\t\t}\n\t\t\tif (*(top-1) == SFT) {\n\t\t\t\ttop -= 2;\n\t\t\t\ty = *top;\n\t\t\t\tif (x > 31) y = 0; else y >>= x;\n\t\t\t\tx = y;\n\t\t\t}\n\t\t\t*top++ = x;\n\t\t}\n\t\tprintf(\"%d\\n\", x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2570: Shipura\n// 2017.12.1 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\n#define M  1000000007\n\nchar buf[2000002], *p;\n\nunsigned parse();\n\nunsigned factor()\n{\n\tunsigned n;\n\tunsigned long long x;\n\n\twhile (*p == ' ') p++;\n\tif (*p == 'S') {\n\t\twhile (*++p == ' ');\n\t\tx = parse(++p);\n\t\tx = x*x % M;\n\t\twhile (*p == ' ') p++;\n\t\tp++;\n\t\treturn (unsigned)x;\n\t} else {\n\t\tn = 0; while (isdigit(*p)) n = (n<<3)+(n<<1) + (*p++ & 0xf);\n\t\treturn n;\n\t}\n}\n\nunsigned parse()\n{\n\tunsigned x, y;\n\n\tx = factor();\n\twhile (*p) {\n\t\twhile (*p == ' ') p++;\n\t\tif (*p != '!') break;\n\t\tp++, y = factor();\n\t\tif (y > 31) x = 0; else x = x >> y;\n\t}\n\treturn x;\n}\n\nint main()\n{\n\twhile (fgets(buf+1, sizeof(buf), stdin) && *(buf+1) != '#') {\n\t\tp = buf, *p++ = 0; while (*p >= ' ') *p++; *p-- = 0;\n\t\twhile (*p) {\n\t\t\tif (!isdigit(*p)) { p--; continue; }\n\t\t\twhile (isdigit(*p)) p--;\n\t\t\twhile (*p == ' ') p--;\n\t\t\tif (*p == '>' && *(p-1) == '>') *p = '!', *(p-1) = ' ', p-=2;\n\t\t}\n\t\tp++, printf(\"%u\\n\", parse());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNextLine()) {\n\t\t\tString ss = sc.nextLine();\n\t\t\tif (ss.equals(\"#\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tss = ss.replace(\" \", \"\");\n\t\t\tchar[] s = ss.toCharArray();\n\t\t\tint n = s.length;\n\t\t\tint i = 0;\n\t\t\tlong num = -1;\n\t\t\tDeque<Long> stack = new ArrayDeque<Long>();\n\t\t\tstack.offer(-1L);\n\t\t\twhile(i < n) {\n\t\t\t\tif (s[i] == 'S') {\n\t\t\t\t\ti+=2;\n\t\t\t\t\tstack.push(-1L);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Character.isDigit(s[i])) {\n\t\t\t\t\tnum = 0;\n\t\t\t\t\twhile(i<n) {\n\t\t\t\t\t\tif (Character.isDigit(s[i])) {\n\t\t\t\t\t\t\tnum*=10;\n\t\t\t\t\t\t\tnum+=s[i]-'0';\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((i < n) && (i+2 >= n || s[i+2] == '>')) {\n\t\t\t\t\tlong b = stack.pop();\n\t\t\t\t\tif (b >= 0) {\n\t\t\t\t\t\tif (num < 32) {\n\t\t\t\t\t\t\tnum = b >> num;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tnum = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnum = (num * num) % 1000000007;\n\t\t\t\t\t//stack.push(num);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tif (i >= n || (i+2 < n && s[i+2] != '>')) {\n\t\t\t\t\tlong b = stack.pop();\n\t\t\t\t\tif (b >= 0) {\n\t\t\t\t\t\tif (num < 32) {\n\t\t\t\t\t\t\tnum = b >> num;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tnum = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstack.push(num);\n\t\t\t\t\ti+=2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(num);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tString s = sc.nextLine();\n\t\t\tif (s.equals(\"#\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts = s.replaceAll(\" \", \"\");\n\t\t\tSystem.out.println(value(s));\n\t\t}\n\t}\n\t\n\tpublic static int index = 0;\n\tpublic static long value(String s) {\n\t\tindex = 0;\n\t\treturn expr(s);\n\t}\n\tpublic static long expr(String s) {\n\t\tlong ret = term(s);\n\t\twhile(index+2 < s.length()) {\n\t\t\tindex+=2;\n\t\t\tif (s.charAt(index) == '>') {\n\t\t\t\tindex-=2;\n\t\t\t\treturn ret;\n\t\t\t}else{\n\t\t\t\tlong y = term(s);\n\t\t\t\tif (y<64) {\n\t\t\t\t\tret >>= y;\n\t\t\t\t}else{\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic static long term(String s) {\n\t\tchar c = s.charAt(index);\n\t\tif (c == 'S') {\n\t\t\tindex+=2;\n\t\t\tlong num = expr(s);\n\t\t\tindex+=1;\n\t\t\treturn (num*num)%1000000007L;\n\t\t}else{\n\t\t\treturn number(s);\n\t\t}\n\t}\n\tpublic static long number(String s) {\n\t\tlong ret = 0;\n\t\ttry {\n\t\t\twhile(index < s.length()) {\n\t\t\t\tlong n = Long.parseLong(s.substring(index,index+1));\n\t\t\t\tret = ret * 10 + n;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t} catch (NumberFormatException e) {\n\t\t\treturn ret;\n\t\t}\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNextLine()) {\n\t\t\tString s = sc.nextLine();\n\t\t\tif (s.equals(\"#\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts = s.replace(\" \", \"\");\n\t\t\tExpression exp = new Expression(s);\n\t\t\tSystem.out.println(exp.value());\n\t\t}\n\t}\n\n}\nclass Expression {\n\tprivate String expression;\n\tprivate int begin = 0;\n\tpublic Expression(String expression) {\n\t\tthis.expression = expression;\n\t}\n\tpublic long value() {\n\t\tlong num = term();\n\t\twhile(begin+2<expression.length()) {\n\t\t\tif (expression.charAt(begin+2) == '>') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbegin += 2;\n\t\t\tlong t = term();\n\t\t\tif (t < 32) {\n\t\t\t\tnum = (num >> t);\n\t\t\t}else{\n\t\t\t\tnum = 0;\n\t\t\t}\n\t\t}\n\t\treturn num;\n\t}\n\tprivate long term() {\n\t\tlong num;\n\t\tif (expression.charAt(begin) == 'S') {\n\t\t\tbegin+=2;\n\t\t\tnum = value();\n\t\t\tnum = (num * num) % 1000000007;\n\t\t\tbegin++;\n\t\t}else{\n\t\t\tnum = number();\n\t\t}\n\t\treturn num;\n\t}\n\tprivate long number() {\n\t\tlong num = 0;\n\t\twhile(begin<expression.length()) {\n\t\t\tif (Character.isDigit(expression.charAt(begin))) {\n\t\t\t\tnum*=10;\n\t\t\t\tnum+=expression.charAt(begin)-'0';\n\t\t\t\tbegin++;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn num;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNextLine()) {\n\t\t\tString ss = sc.nextLine();\n\t\t\tif (ss.equals(\"#\")) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tss = ss.replace(\" \", \"\");\n\t\t\tchar[] s = ss.toCharArray();\n\t\t\tint n = s.length;\n\t\t\tint i = 0;\n\t\t\tlong num = -1;\n\t\t\tDeque<Long> stack = new ArrayDeque<Long>();\n\t\t\tstack.offer(-1L);\n\t\t\twhile(i < n) {\n\t\t\t\tif (s[i] == 'S') {\n\t\t\t\t\ti+=2;\n\t\t\t\t\tstack.offer(-1L);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (Character.isDigit(s[i])) {\n\t\t\t\t\tnum = 0;\n\t\t\t\t\twhile(i<n) {\n\t\t\t\t\t\tif (Character.isDigit(s[i])) {\n\t\t\t\t\t\t\tnum*=10;\n\t\t\t\t\t\t\tnum+=s[i]-'0';\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((i < n) && (i+2 >= n || s[i+2] == '>')) {\n\t\t\t\t\tlong b = stack.pop();\n\t\t\t\t\tif (b >= 0) {\n\t\t\t\t\t\tif (num < 32) {\n\t\t\t\t\t\t\tnum = b >> num;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tnum = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnum = (num * num) % 1000000007;\n\t\t\t\t\ti++;\n\t\t\t\t}else{\n\t\t\t\t\tlong b = stack.pop();\n\t\t\t\t\tif (b >= 0) {\n\t\t\t\t\t\tif (num < 32) {\n\t\t\t\t\t\t\tnum = b >> num;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tnum = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstack.push(num);\n\t\t\t\t\ti+=2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(num);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "JavaScript",
    "code": "/*\n\t?§£????????????:Shipura\n\t(http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2570)\n\n\t-status:\n\n\t-comment:\n        \n*/\nvar log = console.log;\nif (typeof process != \"undefined\") {\n    var input = \"\";\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    process.stdin.on('data', function(chunk) {\n        input += chunk;\n    });\n    process.stdin.on('end', function() {\n        var lines = input.split(\"\\n\");\n        main(lines);\n    });\n}\n\n\nfunction main(lines) {\n    lines.forEach(function(line) {\n        if (line != \"#\") {\n            processLine(line);\n        }\n    }, this);\nlog('');\n}\n\nfunction recM(x, y) {\n    var d = 1000000007;\n    if (x > 90000000 && y > 1) {\n        var mod = y % 2;\n        var k = Math.floor(y / 2);\n        var n = recM(x, k);\n        if (mod) {\n            var s = (2 * n + x) % d;\n        } else {\n            var s = (2 * n) % d;\n        }\n        return s % d;\n    }\n    return (x * y) % d;\n}\n\n\n//S<x>?????????\nfunction S(x) {\n    return recM(x, x);\n}\n//x>>y?????????\nfunction T(x, y) {\n    return Math.floor(x / Math.pow(2, y));\n}\n\n//remove s and spaces\nfunction eliminate(line) {\n    return line.replace(/\\s|S/g, '');\n}\n\n//x ??? string\nfunction is_number(x) {\n    var n = Number(x);\n    var s = n.toString();\n    //?????£??????true\n    return Boolean(s !== \"NaN\");\n}\n\n//<,>,??°????????????\nfunction divide_1st(line) {\n    line = line.split('');\n    var len = line.length;\n    var start = 0;\n    var end = 0;\n    var new_line = [];\n    var is_now_number = false;\n    for (var i = 0; i < len; i++) {\n        var e = line[i];\n        if (!is_now_number && is_number(e)) {\n            //??°??????????????§??????????????°????????£??????????????????\n            start = i;\n            is_now_number = true;\n        } else if (is_now_number && !is_number(e)) {\n            //????????????????????§elseif??§?????????\n            //??°???????????????????????????\n            end = i;\n            is_now_number = false;\n            //??°???????????¨??????push\n            var a = line.slice(start, end);\n            var s = a.join('');\n            var p = Number(s);\n            new_line.push(p);\n        }\n        if (!is_number(e)) {\n            //??°?????§????????????push\n            new_line.push(e);\n        }\n    }\n    //for???????????????????????????is_now_number???????¶????????????????\n    if (is_now_number) {\n        end = len;\n        var a = line.slice(start, end);\n        var s = a.join('');\n        var p = Number(s);\n        new_line.push(p);\n    }\n    return new_line;\n}\n\n//>??????S<>????????¨?????????>>????????¨?????????????????????\n/*\n??????????????????????¨???????\np...S<x>???<\nq...S<x>???>\nL...19,331???????????°???(literal)\nt...>>????????¨\n??????t????¬???????????????????p???L????????\\????????¨????????§???????????¨?????????????????????\n??????????????????>????¬??????????>???L?????????????????????????????????????????§????????°??????>????????????..??????\n */\nfunction is_q(i, line) {\n    var ret = true;\n    if (line[i + 1] == '>') {\n        if (is_number(line[i + 2]) || line[i + 2] == '<') {\n            //t??§??????\n            ret = false;\n        }\n    }\n    return ret;\n}\n\n//token????????????<???p??????>???q??????>>???t?????????\n//[p,p,p,10,q,t,10,q,t,10,q]?????????????????????\nfunction tokenizer(line) {\n    //q_* ??£????????? > ???????????¨???????????¨???\n    var q_start = 0;\n    var q_end = 0;\n    //??´???\n    //?????????\n    var new_line = [];\n\n    var len = line.length;\n    for (var i = 0; i < len; i++) {\n        var e = line[i];\n        if (is_number(e)) {\n            new_line.push(e);\n        } else if (e === '<') {\n            new_line.push('p');\n        } else if (e === '>') {\n            //???????????????????????????\n            if (is_q(i, line)) {\n                //q?????£??????\n                new_line.push('q');\n            } else {\n                new_line.push('t');\n                i += 1; //t??§???????????????????£???¶\n            }\n        }\n    }\n\n    return new_line;\n}\n\n//?¨?????????¨?????¢?????????\nfunction treenize(line) {\n    var len = line.length;\n    var i = 0;\n    while (line.length > 1) {\n        var e = line[i];\n        if (is_number(e)) {\n            if (i > 0 && line[i - 1] == 't') {\n                line[i - 2] = T(line[i - 2], line[i]);\n                line.splice(i - 1, 2);\n                i = i - 3;\n            }\n        } else if (e == 'p') {\n\n        } else if (e == 'q') {\n            line[i - 2] = S(line[i - 1]);\n            line.splice(i - 1, 2);\n            i = i - 3;\n        } else if (e == 't') {\n\n        }\n        i++;\n        //log(line);\n    }\n    return line;\n}\n\nfunction processLine(line) {\n    line = eliminate(line);\n    if (!line) { log(''); return; }\n    line = divide_1st(line);\n    if (!line) { log(''); return; }\n    line = tokenizer(line);\n    if (!line) { log(''); return; }\n    line = treenize(line);\n    if (!line) { log(''); return; }\n    line = line[0];\n    log(line);\n}"
  },
  {
    "language": "JavaScript",
    "code": "/*\n\t?§£????????????:Shipura\n\t(http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2570)\n\n\t-status:\n\n\t-comment:\n        \n*/\nvar log = console.log;\nif (typeof process != \"undefined\") {\n    var input = \"\";\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    process.stdin.on('data', function(chunk) {\n        input += chunk;\n    });\n    process.stdin.on('end', function() {\n        var lines = input.split(\"\\n\");\n        main(lines);\n    });\n}\n\n\nfunction main(lines) {\n    lines.forEach(function(line) {\n        if (line != \"#\") {\n            processLine(line);\n        }\n    }, this);\n}\n\nfunction recM(x, y) {\n    var d = 1000000007;\n    if (x > 90000000 && y > 1) {\n        var mod = y % 2;\n        var k = Math.floor(y / 2);\n        var n = recM(x, k);\n        if (mod) {\n            var s = (2 * n + x) % d;\n        } else {\n            var s = (2 * n) % d;\n        }\n        return s % d;\n    }\n    return (x * y) % d;\n}\n\n\n//S<x>?????????\nfunction S(x) {\n    return recM(x, x);\n}\n//x>>y?????????\nfunction T(x, y) {\n    return Math.floor(x / Math.pow(2, y));\n}\n\n//remove s and spaces\nfunction eliminate(line) {\n    return line.replace(/\\s|S/g, '');\n}\n\n//x ??? string\nfunction is_number(x) {\n    var n = Number(x);\n    var s = n.toString();\n    //?????£??????true\n    return Boolean(s !== \"NaN\");\n}\n\n//<,>,??°????????????\nfunction divide_1st(line) {\n    line = line.split('');\n    var len = line.length;\n    var start = 0;\n    var end = 0;\n    var new_line = [];\n    var is_now_number = false;\n    for (var i = 0; i < len; i++) {\n        var e = line[i];\n        if (!is_now_number && is_number(e)) {\n            //??°??????????????§??????????????°????????£??????????????????\n            start = i;\n            is_now_number = true;\n        } else if (is_now_number && !is_number(e)) {\n            //????????????????????§elseif??§?????????\n            //??°???????????????????????????\n            end = i;\n            is_now_number = false;\n            //??°???????????¨??????push\n            var a = line.slice(start, end);\n            var s = a.join('');\n            var p = Number(s);\n            new_line.push(p);\n        }\n        if (!is_number(e)) {\n            //??°?????§????????????push\n            new_line.push(e);\n        }\n    }\n    //for???????????????????????????is_now_number???????¶????????????????\n    if (is_now_number) {\n        end = len;\n        var a = line.slice(start, end);\n        var s = a.join('');\n        var p = Number(s);\n        new_line.push(p);\n    }\n    return new_line;\n}\n\n//>??????S<>????????¨?????????>>????????¨?????????????????????\n/*\n??????????????????????¨???????\np...S<x>???<\nq...S<x>???>\nL...19,331???????????°???(literal)\nt...>>????????¨\n??????t????¬???????????????????p???L????????\\????????¨????????§???????????¨?????????????????????\n??????????????????>????¬??????????>???L?????????????????????????????????????????§????????°??????>????????????..??????\n */\nfunction is_q(i, line) {\n    var ret = true;\n    if (line[i + 1] == '>') {\n        if (is_number(line[i + 2]) || line[i + 2] == '<') {\n            //t??§??????\n            ret = false;\n        }\n    }\n    return ret;\n}\n\n//token????????????<???p??????>???q??????>>???t?????????\n//[p,p,p,10,q,t,10,q,t,10,q]?????????????????????\nfunction tokenizer(line) {\n    //q_* ??£????????? > ???????????¨???????????¨???\n    var q_start = 0;\n    var q_end = 0;\n    //??´???\n    //?????????\n    var new_line = [];\n\n    var len = line.length;\n    for (var i = 0; i < len; i++) {\n        var e = line[i];\n        if (is_number(e)) {\n            new_line.push(e);\n        } else if (e === '<') {\n            new_line.push('p');\n        } else if (e === '>') {\n            //???????????????????????????\n            if (is_q(i, line)) {\n                //q?????£??????\n                new_line.push('q');\n            } else {\n                new_line.push('t');\n                i += 1; //t??§???????????????????£???¶\n            }\n        }\n    }\n\n    return new_line;\n}\n\n//?¨?????????¨?????¢?????????\nfunction treenize(line) {\n    var len = line.length;\n    var i = 0;\n    while (line.length > 1) {\n        var e = line[i];\n        if (is_number(e)) {\n            if (i > 0 && line[i - 1] == 't') {\n                line[i - 2] = T(line[i - 2], line[i]);\n                line.splice(i - 1, 2);\n                i = i - 3;\n            }\n        } else if (e == 'p') {\n\n        } else if (e == 'q') {\n            line[i - 2] = S(line[i - 1]);\n            line.splice(i - 1, 2);\n            i = i - 3;\n        } else if (e == 't') {\n\n        }\n        i++;\n        //log(line);\n    }\n    return line;\n}\n\nfunction processLine(line) {\n    line = eliminate(line);\n    line = divide_1st(line);\n    line = tokenizer(line);\n    line = treenize(line);\n    if (line.length === 0) return;\n    log(line[0]);\n}"
  },
  {
    "language": "JavaScript",
    "code": "/*\n\t?§£????????????:Shipura\n\t(http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2570)\n\n\t-status:\n\n\t-comment:\n        \n*/\nvar log = console.log;\nif (typeof process != \"undefined\") {\n    var input = \"\";\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    process.stdin.on('data', function(chunk) {\n        input += chunk;\n    });\n    process.stdin.on('end', function() {\n        var lines = input.split(\"\\n\");\n        main(lines);\n    });\n}\n\n\nfunction main(lines) {\n    lines.forEach(function(line) {\n        if (line != \"#\") {\n            processLine(line);\n        }\n    }, this);\n}\n\nfunction recM(x, y) {\n    var d = 1000000007;\n    if (x > 90000000 && y > 1) {\n        var mod = y % 2;\n        var k = Math.floor(y / 2);\n        var n = recM(x, k);\n        if (mod) {\n            var s = (2 * n + x) % d;\n        } else {\n            var s = (2 * n) % d;\n        }\n        return s % d;\n    }\n    return (x * y) % d;\n}\n\n\n//S<x>?????????\nfunction S(x) {\n    return recM(x, x);\n}\n//x>>y?????????\nfunction T(x, y) {\n    return Math.floor(x / Math.pow(2, y));\n}\n\n//remove s and spaces\nfunction eliminate(line) {\n    return line.replace(/\\s|S/g, '');\n}\n\n//x ??? string\nfunction is_number(x) {\n    var n = Number(x);\n    var s = n.toString();\n    //?????£??????true\n    return Boolean(s !== \"NaN\");\n}\n\n//<,>,??°????????????\nfunction divide_1st(line) {\n    line = line.split('');\n    var len = line.length;\n    var start = 0;\n    var end = 0;\n    var new_line = [];\n    var is_now_number = false;\n    for (var i = 0; i < len; i++) {\n        var e = line[i];\n        if (!is_now_number && is_number(e)) {\n            //??°??????????????§??????????????°????????£??????????????????\n            start = i;\n            is_now_number = true;\n        } else if (is_now_number && !is_number(e)) {\n            //????????????????????§elseif??§?????????\n            //??°???????????????????????????\n            end = i;\n            is_now_number = false;\n            //??°???????????¨??????push\n            var a = line.slice(start, end);\n            var s = a.join('');\n            var p = Number(s);\n            new_line.push(p);\n        }\n        if (!is_number(e)) {\n            //??°?????§????????????push\n            new_line.push(e);\n        }\n    }\n    //for???????????????????????????is_now_number???????¶????????????????\n    if (is_now_number) {\n        end = len;\n        var a = line.slice(start, end);\n        var s = a.join('');\n        var p = Number(s);\n        new_line.push(p);\n    }\n    return new_line;\n}\n\n//>??????S<>????????¨?????????>>????????¨?????????????????????\n/*\n??????????????????????¨???????\np...S<x>???<\nq...S<x>???>\nL...19,331???????????°???(literal)\nt...>>????????¨\n??????t????¬???????????????????p???L????????\\????????¨????????§???????????¨?????????????????????\n??????????????????>????¬??????????>???L?????????????????????????????????????????§????????°??????>????????????..??????\n */\nfunction is_q(i, line) {\n    var ret = true;\n    if (line[i + 1] == '>') {\n        if (is_number(line[i + 2]) || line[i + 2] == '<') {\n            //t??§??????\n            ret = false;\n        }\n    }\n    return ret;\n}\n\n//token????????????<???p??????>???q??????>>???t?????????\n//[p,p,p,10,q,t,10,q,t,10,q]?????????????????????\nfunction tokenizer(line) {\n    //q_* ??£????????? > ???????????¨???????????¨???\n    var q_start = 0;\n    var q_end = 0;\n    //??´???\n    //?????????\n    var new_line = [];\n\n    var len = line.length;\n    for (var i = 0; i < len; i++) {\n        var e = line[i];\n        if (is_number(e)) {\n            new_line.push(e);\n        } else if (e === '<') {\n            new_line.push('p');\n        } else if (e === '>') {\n            //???????????????????????????\n            if (is_q(i, line)) {\n                //q?????£??????\n                new_line.push('q');\n            } else {\n                new_line.push('t');\n                i += 1; //t??§???????????????????£???¶\n            }\n        }\n    }\n\n    return new_line;\n}\n\n//?¨?????????¨?????¢?????????\nfunction treenize(line) {\n    var len = line.length;\n    var i = 0;\n    while (line.length > 1) {\n        var e = line[i];\n        if (is_number(e)) {\n            if (i > 0 && line[i - 1] == 't') {\n                line[i - 2] = T(line[i - 2], line[i]);\n                line.splice(i - 1, 2);\n                i = i - 3;\n            }\n        } else if (e == 'p') {\n\n        } else if (e == 'q') {\n            line[i - 2] = S(line[i - 1]);\n            line.splice(i - 1, 2);\n            i = i - 3;\n        } else if (e == 't') {\n\n        }\n        i++;\n        //log(line);\n    }\n    return line;\n}\n\nfunction processLine(line) {\n    line = eliminate(line);\n    if (!line) { log(''); return; }\n    line = divide_1st(line);\n    if (!line) { log(''); return; }\n    line = tokenizer(line);\n    if (!line) { log(''); return; }\n    line = treenize(line);\n    if (!line) { log(''); return; }\n    line = line[0];\n    log(line);\n}"
  },
  {
    "language": "JavaScript",
    "code": "/*\n\t?§£????????????:Shipura\n\t(http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2570)\n\n\t-status:\n\n\t-comment:\n        \n*/\nvar log = console.log;\nif (typeof process != \"undefined\") {\n    var input = \"\";\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    process.stdin.on('data', function(chunk) {\n        input += chunk;\n    });\n    process.stdin.on('end', function() {\n        var lines = input.split(\"\\n\");\n        main(lines);\n    });\n}\n\n\nfunction main(lines) {\n    lines.forEach(function(line) {\n        if (line != \"#\") {\n            processLine(line);\n        }\n    }, this);\n}\n\n//S<x>?????????\nfunction S(x) {\n    var d = 1000000007;\n    if (x > 500000000) {\n        //overflow??????\n        x = x - d;\n    }\n    var p = x * x;\n    return p % d;\n}\n//x>>y?????????\nfunction T(x, y) {\n    return Math.floor(x / Math.pow(2, y));\n}\n\n//remove s and spaces\nfunction eliminate(line) {\n    return line.replace(/\\s|S/g, '');\n}\n\n//x ??? string\nfunction is_number(x) {\n    var n = Number(x);\n    var s = n.toString();\n    //?????£??????true\n    return Boolean(s !== \"NaN\");\n}\n\n//<,>,??°????????????\nfunction divide_1st(line) {\n    line = line.split('');\n    var len = line.length;\n    var start = 0;\n    var end = 0;\n    var new_line = [];\n    var is_now_number = false;\n    for (var i = 0; i < len; i++) {\n        var e = line[i];\n        if (!is_now_number && is_number(e)) {\n            //??°??????????????§??????????????°????????£??????????????????\n            start = i;\n            is_now_number = true;\n        } else if (is_now_number && !is_number(e)) {\n            //????????????????????§elseif??§?????????\n            //??°???????????????????????????\n            end = i;\n            is_now_number = false;\n            //??°???????????¨??????push\n            var a = line.slice(start, end);\n            var s = a.join('');\n            var p = Number(s);\n            new_line.push(p);\n        }\n        if (!is_number(e)) {\n            //??°?????§????????????push\n            new_line.push(e);\n        }\n    }\n    //for???????????????????????????is_now_number???????¶????????????????\n    if (is_now_number) {\n        end = len;\n        var a = line.slice(start, end);\n        var s = a.join('');\n        var p = Number(s);\n        new_line.push(p);\n    }\n    return new_line;\n}\n\n//>??????S<>????????¨?????????>>????????¨?????????????????????\n/*\n??????????????????????¨???????\np...S<x>???<\nq...S<x>???>\nL...19,331???????????°???(literal)\nt...>>????????¨\n??????t????¬???????????????????p???L????????\\????????¨????????§???????????¨?????????????????????\n??????????????????>????¬??????????>???L?????????????????????????????????????????§????????°??????>????????????..??????\n */\nfunction is_q(i, line) {\n    var ret = true;\n    if (line[i + 1] == '>') {\n        if (is_number(line[i + 2]) || line[i + 2] == '<') {\n            //t??§??????\n            ret = false;\n        }\n    }\n    return ret;\n}\n\n//token????????????<???p??????>???q??????>>???t?????????\n//[p,p,p,10,q,t,10,q,t,10,q]?????????????????????\nfunction tokenizer(line) {\n    //q_* ??£????????? > ???????????¨???????????¨???\n    var q_start = 0;\n    var q_end = 0;\n    //??´???\n    //?????????\n    var new_line = [];\n\n    var len = line.length;\n    for (var i = 0; i < len; i++) {\n        var e = line[i];\n        if (is_number(e)) {\n            new_line.push(e);\n        } else if (e === '<') {\n            new_line.push('p');\n        } else if (e === '>') {\n            //???????????????????????????\n            if (is_q(i, line)) {\n                //q?????£??????\n                new_line.push('q');\n            } else {\n                new_line.push('t');\n                i += 1; //t??§???????????????????£???¶\n            }\n        }\n    }\n\n    return new_line;\n}\n\n//?¨?????????¨?????¢?????????\nfunction treenize(line) {\n    var len = line.length;\n    var i = 0;\n    while (line.length > 1) {\n        var e = line[i];\n        if (is_number(e)) {\n\n        } else if (e == 'p') {\n\n        } else if (e == 'q') {\n            line[i - 2] = S(line[i - 1]);\n            line.splice(i - 1, 2);\n            i = i - 2;\n        } else if (e == 't') {\n            line[i - 1] = T(line[i - 1], line[i + 1]);\n            line.splice(i, 2);\n            i = i - 1;\n        }\n        i++;\n    }\n    return line;\n}\n\nfunction processLine(line) {\n    line = eliminate(line);\n    line = divide_1st(line);\n    line = tokenizer(line);\n    line = treenize(line);\n    line = line[0];\n    log(line);\n}"
  },
  {
    "language": "JavaScript",
    "code": "/*\n\t?§£????????????:Shipura\n\t(http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2570)\n\n\t-status:\n\n\t-comment:\n        \n*/\nvar log = console.log;\nif (typeof process != \"undefined\") {\n    var input = \"\";\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    process.stdin.on('data', function(chunk) {\n        input += chunk;\n    });\n    process.stdin.on('end', function() {\n        var lines = input.split(\"\\n\");\n        main(lines);\n    });\n}\n\n\nfunction main(lines) {\n    lines.forEach(function(line) {\n        if (line != \"#\") {\n            processLine(line);\n        }\n    }, this);\n}\n\nfunction recM(x, y) {\n    var d = 1000000007;\n    if (x > 90000000 && y > 1) {\n        var mod = y % 2;\n        var k = Math.floor(y / 2);\n        var n = recM(x, k);\n        if (mod) {\n            var s = (2 * n + x) % d;\n        } else {\n            var s = (2 * n) % d;\n        }\n        return s % d;\n    }\n    return (x * y) % d;\n}\n\n\n//S<x>?????????\nfunction S(x) {\n    return recM(x, x);\n}\n//x>>y?????????\nfunction T(x, y) {\n    return Math.floor(x / Math.pow(2, y));\n}\n\n//remove s and spaces\nfunction eliminate(line) {\n    return line.replace(/\\s|S/g, '');\n}\n\n//x ??? string\nfunction is_number(x) {\n    var n = Number(x);\n    var s = n.toString();\n    //?????£??????true\n    return Boolean(s !== \"NaN\");\n}\n\n//<,>,??°????????????\nfunction divide_1st(line) {\n    line = line.split('');\n    var len = line.length;\n    var start = 0;\n    var end = 0;\n    var new_line = [];\n    var is_now_number = false;\n    for (var i = 0; i < len; i++) {\n        var e = line[i];\n        if (!is_now_number && is_number(e)) {\n            //??°??????????????§??????????????°????????£??????????????????\n            start = i;\n            is_now_number = true;\n        } else if (is_now_number && !is_number(e)) {\n            //????????????????????§elseif??§?????????\n            //??°???????????????????????????\n            end = i;\n            is_now_number = false;\n            //??°???????????¨??????push\n            var a = line.slice(start, end);\n            var s = a.join('');\n            var p = Number(s);\n            new_line.push(p);\n        }\n        if (!is_number(e)) {\n            //??°?????§????????????push\n            new_line.push(e);\n        }\n    }\n    //for???????????????????????????is_now_number???????¶????????????????\n    if (is_now_number) {\n        end = len;\n        var a = line.slice(start, end);\n        var s = a.join('');\n        var p = Number(s);\n        new_line.push(p);\n    }\n    return new_line;\n}\n\n//>??????S<>????????¨?????????>>????????¨?????????????????????\n/*\n??????????????????????¨???????\np...S<x>???<\nq...S<x>???>\nL...19,331???????????°???(literal)\nt...>>????????¨\n??????t????¬???????????????????p???L????????\\????????¨????????§???????????¨?????????????????????\n??????????????????>????¬??????????>???L?????????????????????????????????????????§????????°??????>????????????..??????\n */\nfunction is_q(i, line) {\n    var ret = true;\n    if (line[i + 1] == '>') {\n        if (is_number(line[i + 2]) || line[i + 2] == '<') {\n            //t??§??????\n            ret = false;\n        }\n    }\n    return ret;\n}\n\n//token????????????<???p??????>???q??????>>???t?????????\n//[p,p,p,10,q,t,10,q,t,10,q]?????????????????????\nfunction tokenizer(line) {\n    //q_* ??£????????? > ???????????¨???????????¨???\n    var q_start = 0;\n    var q_end = 0;\n    //??´???\n    //?????????\n    var new_line = [];\n\n    var len = line.length;\n    for (var i = 0; i < len; i++) {\n        var e = line[i];\n        if (is_number(e)) {\n            new_line.push(e);\n        } else if (e === '<') {\n            new_line.push('p');\n        } else if (e === '>') {\n            //???????????????????????????\n            if (is_q(i, line)) {\n                //q?????£??????\n                new_line.push('q');\n            } else {\n                new_line.push('t');\n                i += 1; //t??§???????????????????£???¶\n            }\n        }\n    }\n\n    return new_line;\n}\n\n//?¨?????????¨?????¢?????????\nfunction treenize(line) {\n    var len = line.length;\n    var i = 0;\n    while (line.length > 1) {\n        var e = line[i];\n        if (is_number(e)) {\n            if (i > 0 && line[i - 1] == 't') {\n                line[i - 2] = T(line[i - 2], line[i]);\n                line.splice(i - 1, 2);\n                i = i - 3;\n            }\n        } else if (e == 'p') {\n\n        } else if (e == 'q') {\n            line[i - 2] = S(line[i - 1]);\n            line.splice(i - 1, 2);\n            i = i - 3;\n        } else if (e == 't') {\n\n        }\n        i++;\n        //log(line);\n    }\n    return line;\n}\n\nfunction processLine(line) {\n    line = eliminate(line);\n    if (!line) { log(''); return; }\n    line = divide_1st(line);\n    if (!line) { log(''); return; }\n    line = tokenizer(line);\n    if (!line) { log(''); return; }\n    line = treenize(line);\n    if (!line) { log(''); return; }\n    line = line[0];\n    if (!line) { log(''); return; }\n    log(line);\n}"
  },
  {
    "language": "JavaScript",
    "code": "/*\n\t?§£????????????:Shipura\n\t(http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2570)\n\n\t-status:\n\n\t-comment:\n        \n*/\nvar log = console.log;\nif (typeof process != \"undefined\") {\n    var input = \"\";\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    process.stdin.on('data', function(chunk) {\n        input += chunk;\n    });\n    process.stdin.on('end', function() {\n        var lines = input.split(\"\\n\");\n        main(lines);\n    });\n}\n\n\nfunction main(lines) {\n    lines.forEach(function(line) {\n        if (line != \"#\") {\n            processLine(line);\n        }\n    }, this);\n}\n\nfunction recM(x, y) {\n    var d = 1000000007;\n    if (x > 90000000 && y > 1) {\n        var mod = y % 2;\n        var k = Math.floor(y / 2);\n        var n = recM(x, k);\n        if (mod) {\n            var s = (2 * n + x) % d;\n        } else {\n            var s = (2 * n) % d;\n        }\n        return s % d;\n    }\n    return (x * y) % d;\n}\n\n\n//S<x>?????????\nfunction S(x) {\n    return recM(x, x);\n}\n//x>>y?????????\nfunction T(x, y) {\n    return Math.floor(x / Math.pow(2, y));\n}\n\n//remove s and spaces\nfunction eliminate(line) {\n    return line.replace(/\\s|S/g, '');\n}\n\n//x ??? string\nfunction is_number(x) {\n    var n = Number(x);\n    var s = n.toString();\n    //?????£??????true\n    return Boolean(s !== \"NaN\");\n}\n\n//<,>,??°????????????\nfunction divide_1st(line) {\n    line = line.split('');\n    var len = line.length;\n    var start = 0;\n    var end = 0;\n    var new_line = [];\n    var is_now_number = false;\n    for (var i = 0; i < len; i++) {\n        var e = line[i];\n        if (!is_now_number && is_number(e)) {\n            //??°??????????????§??????????????°????????£??????????????????\n            start = i;\n            is_now_number = true;\n        } else if (is_now_number && !is_number(e)) {\n            //????????????????????§elseif??§?????????\n            //??°???????????????????????????\n            end = i;\n            is_now_number = false;\n            //??°???????????¨??????push\n            var a = line.slice(start, end);\n            var s = a.join('');\n            var p = Number(s);\n            new_line.push(p);\n        }\n        if (!is_number(e)) {\n            //??°?????§????????????push\n            new_line.push(e);\n        }\n    }\n    //for???????????????????????????is_now_number???????¶????????????????\n    if (is_now_number) {\n        end = len;\n        var a = line.slice(start, end);\n        var s = a.join('');\n        var p = Number(s);\n        new_line.push(p);\n    }\n    return new_line;\n}\n\n//>??????S<>????????¨?????????>>????????¨?????????????????????\n/*\n??????????????????????¨???????\np...S<x>???<\nq...S<x>???>\nL...19,331???????????°???(literal)\nt...>>????????¨\n??????t????¬???????????????????p???L????????\\????????¨????????§???????????¨?????????????????????\n??????????????????>????¬??????????>???L?????????????????????????????????????????§????????°??????>????????????..??????\n */\nfunction is_q(i, line) {\n    var ret = true;\n    if (line[i + 1] == '>') {\n        if (is_number(line[i + 2]) || line[i + 2] == '<') {\n            //t??§??????\n            ret = false;\n        }\n    }\n    return ret;\n}\n\n//token????????????<???p??????>???q??????>>???t?????????\n//[p,p,p,10,q,t,10,q,t,10,q]?????????????????????\nfunction tokenizer(line) {\n    //q_* ??£????????? > ???????????¨???????????¨???\n    var q_start = 0;\n    var q_end = 0;\n    //??´???\n    //?????????\n    var new_line = [];\n\n    var len = line.length;\n    for (var i = 0; i < len; i++) {\n        var e = line[i];\n        if (is_number(e)) {\n            new_line.push(e);\n        } else if (e === '<') {\n            new_line.push('p');\n        } else if (e === '>') {\n            //???????????????????????????\n            if (is_q(i, line)) {\n                //q?????£??????\n                new_line.push('q');\n            } else {\n                new_line.push('t');\n                i += 1; //t??§???????????????????£???¶\n            }\n        }\n    }\n\n    return new_line;\n}\n\n//?¨?????????¨?????¢?????????\nfunction treenize(line) {\n    var len = line.length;\n    var i = 0;\n    while (line.length > 1) {\n        var e = line[i];\n        if (is_number(e)) {\n            if (i > 0 && line[i - 1] == 't') {\n                line[i - 2] = T(line[i - 2], line[i]);\n                line.splice(i - 1, 2);\n                i = i - 3;\n            }\n        } else if (e == 'p') {\n\n        } else if (e == 'q') {\n            line[i - 2] = S(line[i - 1]);\n            line.splice(i - 1, 2);\n            i = i - 3;\n        } else if (e == 't') {\n\n        }\n        i++;\n        //log(line);\n    }\n    return line;\n}\n\nfunction processLine(line) {\n    line = eliminate(line);\n    if (!line) { log(''); return; }\n    line = divide_1st(line);\n    if (!line) { log(''); return; }\n    line = tokenizer(line);\n    if (!line) { log(''); return; }\n    line = treenize(line);\n    if (!line) { log(''); return; }\n    //line = line[0];\n    if (!line) { log(''); return; }\n    log(line);\n}"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    exp = gets.chomp\n    break if exp =~ /^#/\n    while exp =~ /S|>/\n        exp.gsub!(/\\d+\\s*>>\\s*\\d+/){|shift| eval(shift).to_s}\n        exp.gsub!(/S\\s*<\\s*\\d+\\s*>/){|square| square =~ /\\d+/; ($&.to_i ** 2 % 1_000_000_007).to_s}\n    end\n    puts exp\nend"
  },
  {
    "language": "Ruby",
    "code": "def expr( str, i )\n  s, i, value = term( str, i )\n\n  loop do\n    s, ni = sp( str, i )\n    break unless s\n\n    break if str[ni...ni+2] != \">>\"\n    ni = ni + 2\n\n    s, ni = sp( str, ni )\n    s, ni, v = term( str, ni )\n    break unless s\n\n    value = value / (2 ** v)\n\n    i = ni\n  end\n\n  return true, i, value\nend\n\ndef term( str, i )\n  s, i, v = number( str, i )\n  return s, i, v if s\n\n  return false, i, nil if str[i] != \"S\"\n  i = i + 1 #str[i] == \"S\"\n\n  s, i = sp( str, i )\n  i = i + 1 #str[i] == \"<\"\n  s, i = sp( str, i )\n  s, i, v = expr( str, i )\n  s, i = sp( str, i )\n  i = i + 1 #str[i] == \">\"\n\n  return true, i, v ** 2 % 1000000007\nend\n\ndef sp( str, i )\n  loop do\n    return false, i if i >= str.length\n    break if str[i] != \" \"\n    i = i + 1\n  end\n\n  return true, i\nend\n\ndef number( str, i )\n  value = \"\"\n\n  s, i, v = digit( str, i )\n  return false, i, nil unless s\n  value << v\n\n  loop do\n    s, i, v = digit( str, i )\n    break unless s\n    value << v\n  end\n\n  return true, i, value.to_i\nend\n\ndef digit( str, i )\n  return false, i, nil if i >= str.length\n\n  if str[i].ord >= '0'.ord && str[i].ord <= '9'.ord\n    return true, i + 1, str[i]\n\n  else\n    return false, i, nil\n  end\nend\n\n\ndef eval( str )\n  _, _, v = expr( str, 0 )\n\n  puts v.to_s\nend\n\nSTDIN.each_line.map(&:chomp).each do |line|\n  break if line == \"#\"\n\n  eval line\nend"
  },
  {
    "language": "Ruby",
    "code": "def eval_shifts(s)\n    s.split(\">>\").map(&:to_i).inject(:>>)\nend\n\nloop.with_index do |_, i|\n    e = gets.chomp\n    break if e =~ /#/ \n    e.gsub!(/\\s/, \"\") \n    while i = e.rindex(?S)\n        e[i] = ?T\n        e.sub!(/T<\\d+(>>\\d+)*>/){|s| (eval_shifts(s[2..-2]) ** 2 % 1_000_000_007).to_s}\n    end \n    p eval_shifts(e)\nend"
  },
  {
    "language": "Ruby",
    "code": "def expr( str, i )\n  s, i, value = term( str, i )\n\n  loop do\n    s, ni = sp( str, i )\n    break unless s\n\n    break if str[ni...ni+2] != \">>\"\n    ni = ni + 2\n\n    s, ni = sp( str, ni )\n    s, ni, v = term( str, ni )\n    break unless s\n\n    value = value / (2 ** v)\n\n    i = ni\n  end\n\n  return true, i, value\nend\n\ndef term( str, i )\n  s, i, v = number( str, i )\n  return s, i, v if s\n\n  return false, i, nil if str[i] != \"S\"\n  i = i + 1 #str[i] == \"S\"\n\n  s, i = sp( str, i )\n  i = i + 1 #str[i] == \"<\"\n  s, i = sp( str, i )\n  s, i, v = expr( str, i )\n  s, i = sp( str, i )\n  i = i + 1 #str[i] == \">\"\n\n  return true, i, v ** 2 % 1000000007\nend\n\ndef sp( str, i )\n  loop do\n    return false, i if i >= str.length\n    break if str[i] != \" \"\n    i = i + 1\n  end\n\n  return true, i\nend\n\ndef number( str, i )\n  value = \"\"\n\n  s, i, v = digit( str, i )\n  return false, i, nil unless s\n  value << v\n\n  loop do\n    s, i, v = digit( str, i )\n    break unless s\n    value << v\n  end\n\n  return true, i, value.to_i\nend\n\ndef digit( str, i )\n  return false, i, nil if i >= str.length\n\n  if str[i] >= '0' && str[i] <= '9'\n    return true, i + 1, str[i]\n\n  else\n    return false, i, nil\n  end\nend\n\n\ndef eval( str )\n  _, _, v = expr( str, 0 )\n\n  puts v.to_s\nend\n\nSTDIN.each_line.map(&:chomp).each do |line|\n  break if line == \"#\"\n\n  eval line\nend"
  },
  {
    "language": "Ruby",
    "code": "def exp(s, i)\n\treturn nil if i >= s.size\n\ta = term(s, i) or return nil\n\tx, i = a\n\tts = [x]\n\twhile a = term(s, i+2)\n\t\tx, i = a\n\t\tts << x\n\tend\n\treturn [ts.inject(:>>), i]\nend\n\ndef term(s, i)\n\treturn nil if i >= s.size\n\tif s[i] == ?S\n\t\treturn nil if i+1 >= s.size || s[i+1] != ?<\n\t\ta = exp(s, i+2) or return nil\n\t\tx, i = a\n\t\treturn nil if i >= s.size || s[i] != ?>\n\t\treturn [x ** 2 % 1_000_000_007, i+1]\n\telsif s[i] =~ /\\d/\n\t\tj = i + 1\n\t\tj += 1 while j < s.size && s[j] =~ /\\d/\n\t\tx = s[i..j-1].to_i\n\t\treturn [x, j]\n\telse \n\t\treturn nil\n\tend\nend\n\nloop do\n\te = gets.chomp\n\tbreak if e =~ /#/\n\te.gsub!(/\\s/, \"\")\n\tp exp(e, 0)[0]\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nstatic const D = false;\n\nchar isDigit(char c) {\n    return '0' <= c && c <= '9';\n}\n\nstring rmSpace(string s) {\n    string ret;\n    foreach (c; s) {\n        if (c == ' ') continue;\n        ret ~= c;\n    }\n    return ret;\n}\n\nvoid main() {\n    string _;\n    while (_ = readln.chomp, _ != \"#\") {\n        struct Parser {\n            int index;\n            string s;\n            static const ulong C = 1000000007;\n            this(string s) {\n                this.s = s;\n                this.index = cast(int)s.length - 1;\n            }\n            ulong expr() {\n                ulong x = term();\n                if (index == -1 || s[index] == '<') return x;\n                assert(s[index] == '>'); index--;\n                assert(s[index] == '>'); index--;\n                ulong y = expr();\n                //writeln(\"expr(): \", y, \" \", x);\n                if (x > 70) return 0;\n                return y >> x;\n            }\n            ulong term() {\n                static if (D) \"term\".writeln(index);\n                if (s[index] == '>') {\n                    index--;\n                    ulong x = expr();\n                    assert(s[index] == '<'); index--;\n                    assert(s[index] == 'S'); index--;\n                    return x * x % C;\n                } else {\n                    assert(s[index].isDigit);\n                    return number();\n                }\n            }\n            ulong number() {\n                assert(s[index].isDigit);\n                int i = index - 1;\n                while (i >= 0 && s[i].isDigit) i--;\n                //s[i + 1 .. index + 1].writeln;\n                ulong ret = to!ulong(s[i + 1 .. index + 1]);\n                index = i;\n                return ret % C;\n            }\n        }\n        auto parser = Parser(rmSpace(_));\n        parser.expr().writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nstatic const D = false;\n\nchar isDigit(char c) {\n    return '0' <= c && c <= '9';\n}\n\nstring rmSpace(string s) {\n    string ret;\n    foreach (c; s) {\n        if (c == ' ') continue;\n        ret ~= c;\n    }\n    return ret;\n}\n\nvoid main() {\n    string _;\n    while (_ = readln.chomp, _ != \"#\") {\n        struct Parser {\n            int index;\n            string s;\n            static const ulong C = 1000000007;\n            this(string s) {\n                this.s = s;\n                this.index = cast(int)s.length - 1;\n            }\n            ulong expr() {\n                ulong x = term();\n                if (index == -1 || s[index] == '<') return x % C;\n                assert(s[index] == '>'); index--;\n                assert(s[index] == '>'); index--;\n                ulong y = expr();\n                //writeln(\"expr(): \", y, \" \", x);\n                if (x > 63) return 0;\n                return y >> x;\n            }\n            ulong term() {\n                static if (D) \"term\".writeln(index);\n                if (s[index] == '>') {\n                    index--;\n                    ulong x = expr();\n                    assert(s[index] == '<'); index--;\n                    assert(s[index] == 'S'); index--;\n                    return x * x % C;\n                } else {\n                    assert(s[index].isDigit);\n                    return number();\n                }\n            }\n            ulong number() {\n                assert(s[index].isDigit);\n                int i = index - 1;\n                while (i >= 0 && s[i].isDigit) i--;\n                //s[i + 1 .. index + 1].writeln;\n                ulong ret = to!ulong(s[i + 1 .. index + 1]);\n                index = i;\n                return ret % C;\n            }\n        }\n        auto parser = Parser(rmSpace(_));\n        parser.expr().writeln;\n    }\n}"
  },
  {
    "language": "Python",
    "code": "import re\nS = lambda x: x*x%int(1e9+7)\ns = input()\nwhile s != '#':\n    s = s.replace(' ', '')\n    s = re.sub(r'>>(\\d+)', r'XX\\1', s)\n    s = s.translate(str.maketrans('<>X', '()>'))\n    print(eval(s))\n    s = input()\n"
  },
  {
    "language": "Python",
    "code": "MOD = 10**9 + 7\ns = \"\"; l = 0; pos = 0;\n\ndef number():\n    global pos\n    ret = 0\n    x = pos\n    while pos<l and s[pos].isdigit():\n        ret = 10*ret + int(s[pos])\n        pos += 1\n    return ret if x!=pos else -1\n\ndef sp():\n    global pos\n    while pos<l and s[pos]==' ':\n        pos += 1\n    return 0\n\ndef term():\n    global pos\n    if pos>=l:\n        return -1\n    ret = 0\n    if s[pos]=='S':\n        pos += 1 # 'S'\n        sp()\n        pos += 1 # '<'\n        sp()\n        ret = (expr() ** 2) % MOD\n        sp()\n        pos += 1 # '>'\n    else:\n        ret = number()\n    return ret\n\ndef expr():\n    global pos\n    ret = term()\n    while pos<l:\n        x = pos\n        sp()\n        if pos<l-1 and s[pos:pos+2]==\">>\":\n            pos += 2\n            sp()\n            r = term()\n            if r==-1:\n                pos = x\n                break\n            ret = int( ret / (2 ** r) )\n        else:\n            pos = x\n            break\n    return ret\n\nwhile True:\n    s = raw_input();\n    if s==\"#\":\n        break\n    l = len(s); pos = 0;\n    print expr()"
  },
  {
    "language": "Python",
    "code": "MOD = 10**9 + 7\ns = \"\"; l = 0; pos = 0;\n\ndef number():\n    global pos\n    x = pos\n    while pos<l and s[pos].isdigit():\n        pos += 1\n    return int(s[x:pos]) if x!=pos else -1\n\ndef sp():\n    global pos\n    while pos<l and s[pos]==' ':\n        pos += 1\n    return 0\n\ndef term():\n    global pos\n    if pos>=l:\n        return -1\n    ret = 0\n    if s[pos]=='S':\n        pos += 1 # 'S'\n        sp()\n        pos += 1 # '<'\n        sp()\n        ret = (expr() ** 2) % MOD\n        sp()\n        pos += 1 # '>'\n    else:\n        ret = number()\n    return ret\n\ndef expr():\n    global pos\n    ret = term()\n    while pos<l:\n        x = pos\n        sp()\n        if s[pos:pos+2]==\">>\":\n            pos += 2\n            sp()\n            r = term()\n            if r==-1:\n                pos = x\n                break\n            ret = int( ret / (2 ** r) )\n        else:\n            break\n    return ret\n\nwhile True:\n    s = raw_input();\n    if s==\"#\":\n        break\n    l = len(s); pos = 0;\n    print expr()"
  },
  {
    "language": "Python",
    "code": "MOD = 10**9 + 7\ns = \"\"; l = 0; pos = 0;\n\ndef number():\n    global pos\n    x = pos\n    while pos<l and s[pos].isdigit():\n        pos += 1\n    return int(s[x:pos]) if x!=pos else -1\n\ndef sp():\n    global pos\n    while pos<l and s[pos]==' ':\n        pos += 1\n    return 0\n\ndef term():\n    global pos\n    if pos>=l:\n        return -1\n    ret = 0\n    if s[pos]=='S':\n        pos += 1 # 'S'\n        sp()\n        pos += 1 # '<'\n        sp()\n        ret = (expr() ** 2) % MOD\n        sp()\n        pos += 1 # '>'\n    else:\n        ret = number()\n    return ret\n\ndef expr():\n    global pos\n    ret = term()\n    while pos<l:\n        x = pos\n        sp()\n        if pos<l-1 and s[pos:pos+2]==\">>\":\n            pos += 2\n            sp()\n            r = term()\n            if r==-1:\n                pos = x\n                break\n            ret = int( ret / (2 ** r) )\n        else:\n            pos = x\n            break\n    return ret\n\nwhile True:\n    s = raw_input();\n    if s==\"#\":\n        break\n    l = len(s); pos = 0;\n    print expr()"
  }
]