[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n#define MAX_N 100\n#define MAX_LEN 100\n\nint n;\nchar words[MAX_N][MAX_LEN + 1];\nlong long dp[MAX_N][26];\n\nint is_less_or_equal(char* s1, char* s2) {\n    for (int i = 0; s1[i] && s2[i]; i++) {\n        if (s1[i] != '?' && s2[i] != '?' && s1[i] != s2[i]) {\n            return s1[i] < s2[i];\n        }\n    }\n    return 1;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", words[i]);\n    }\n\n    for (int j = 0; j < 26; j++) {\n        dp[0][j] = 1;\n    }\n\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < 26; j++) {\n            dp[i][j] = 0;\n            for (int k = 0; k < 26; k++) {\n                words[i-1][strlen(words[i-1])-1] = k + 'a';\n                words[i][strlen(words[i])-1] = j + 'a';\n                \n                if (is_less_or_equal(words[i-1], words[i])) {\n                    dp[i][j] = (dp[i][j] + dp[i-1][k]) % MOD;\n                }\n            }\n        }\n    }\n\n    long long total = 0;\n    for (int j = 0; j < 26; j++) {\n        total = (total + dp[n-1][j]) % MOD;\n    }\n\n    printf(\"%lld\\n\", total);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:50:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MOD 1000000007\n#define MAX_N 5005\n#define MAX_LEN 5005\n\nint n;\nchar s[MAX_N][MAX_LEN];\nint len[MAX_N];\nlong long dp[MAX_N][MAX_LEN];\nlong long sum[MAX_N][MAX_LEN];\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%s\", s[i]);\n        len[i] = strlen(s[i]);\n    }\n\n    for (int j = 0; j <= len[0]; ++j) {\n        dp[0][j] = 1;\n        sum[0][j] = j + 1;\n    }\n\n    for (int i = 1; i < n; ++i) {\n        int max_len = len[i] > len[i-1] ? len[i] : len[i-1];\n        for (int j = 0; j <= len[i]; ++j) {\n            if (j > len[i-1]) {\n                dp[i][j] = sum[i-1][len[i-1]];\n            } else {\n                dp[i][j] = sum[i-1][j];\n                if (j > 0) {\n                    int ok = 1;\n                    for (int k = 0; k < j; ++k) {\n                        char c1 = s[i][k] == '?' ? s[i-1][k] : s[i][k];\n                        char c2 = s[i-1][k];\n                        if (c1 != c2) {\n                            ok = 0;\n                            break;\n                        }\n                    }\n                    if (ok && j <= len[i-1]) {\n                        dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD;\n                    }\n                }\n            }\n            sum[i][j] = ((j > 0 ? sum[i][j-1] : 0) + dp[i][j]) % MOD;\n        }\n    }\n\n    printf(\"%lld\\n\", sum[n-1][len[n-1]]);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:50:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<string> s(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> s[i];\n    }\n\n    vector<vector<long long>> dp(n, vector<long long>(26, 0));\n    vector<vector<long long>> sum(n, vector<long long>(27, 0));\n\n    // Initialize the first word\n    string &first = s[0];\n    for (int c = 0; c < 26; ++c) {\n        if (first[0] == '?' || first[0] == 'a' + c) {\n            dp[0][c] = 1;\n        }\n    }\n    for (int j = 0; j < 26; ++j) {\n        sum[0][j + 1] = sum[0][j] + dp[0][j];\n    }\n\n    for (int i = 1; i < n; ++i) {\n        string &prev = s[i - 1];\n        string &curr = s[i];\n        int len_prev = prev.size();\n        int len_curr = curr.size();\n\n        // Precompute prefix sums for previous word\n        vector<long long> prev_sum(27, 0);\n        for (int j = 0; j < 26; ++j) {\n            prev_sum[j + 1] = (prev_sum[j] + dp[i - 1][j]) % MOD;\n        }\n\n        for (int c = 0; c < 26; ++c) {\n            if (curr[0] != '?' && curr[0] != 'a' + c) {\n                dp[i][c] = 0;\n                continue;\n            }\n\n            if (len_curr > len_prev) {\n                dp[i][c] = prev_sum[26];\n            } else if (len_curr < len_prev) {\n                dp[i][c] = 0;\n            } else {\n                // Same length, need to compare characters\n                bool ok = true;\n                for (int k = 0; k < len_curr; ++k) {\n                    char pc = prev[k];\n                    char cc = curr[k];\n                    if (pc != '?' && cc != '?') {\n                        if (pc < cc) {\n                            break;\n                        } else if (pc > cc) {\n                            ok = false;\n                            break;\n                        }\n                    } else if (pc == '?' && cc == '?') {\n                        if (k == 0) {\n                            dp[i][c] = (dp[i][c] + prev_sum[c]) % MOD;\n                            ok = false;\n                            break;\n                        }\n                    } else if (pc == '?') {\n                        if (k == 0) {\n                            int max_pc = cc - 'a';\n                            dp[i][c] = (dp[i][c] + prev_sum[max_pc]) % MOD;\n                            ok = false;\n                            break;\n                        } else {\n                            // Need to handle more carefully\n                        }\n                    } else if (cc == '?') {\n                        if (k == 0) {\n                            int min_cc = pc - 'a' + 1;\n                            dp[i][c] = (dp[i][c] + (prev_sum[26] - prev_sum[min_cc] + MOD) % MOD) % MOD;\n                            ok = false;\n                            break;\n                        } else {\n                            // Need to handle more carefully\n                        }\n                    }\n                }\n                if (ok) {\n                    dp[i][c] = prev_sum[26];\n                }\n            }\n        }\n\n        for (int j = 0; j < 26; ++j) {\n            sum[i][j + 1] = (sum[i][j] + dp[i][j]) % MOD;\n        }\n    }\n\n    long long ans = 0;\n    for (int c = 0; c < 26; ++c) {\n        ans = (ans + dp[n - 1][c]) % MOD;\n    }\n    cout << ans << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:51:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static final int MOD = 1_000_000_007;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        String[] s = new String[n];\n        for (int i = 0; i < n; i++) {\n            s[i] = sc.next();\n        }\n        System.out.println(solve(s));\n    }\n\n    static int solve(String[] s) {\n        int n = s.length;\n        int m = s[0].length();\n        long[][] dp = new long[n + 1][m + 1];\n        Arrays.fill(dp[0], 1);\n\n        for (int i = 1; i <= n; i++) {\n            String prevStr = s[i - 2];\n            String currStr = s[i - 1];\n            int prevLen = prevStr.length();\n            int currLen = currStr.length();\n\n            for (int j = 0; j <= m; j++) {\n                if (j > currLen) {\n                    dp[i][j] = 0;\n                    continue;\n                }\n                if (i == 1) {\n                    dp[i][j] = 1;\n                    continue;\n                }\n\n                long sum = 0;\n                for (int k = 0; k <= Math.min(j, prevLen); k++) {\n                    if (k == 0) {\n                        if (j == 0) {\n                            sum = (sum + dp[i - 1][k]) % MOD;\n                        }\n                        continue;\n                    }\n                    if (j < k) continue;\n                    char pc = prevStr.charAt(k - 1);\n                    char cc = currStr.charAt(k - 1);\n                    if (pc != '?' && cc != '?') {\n                        if (pc < cc) {\n                            sum = (sum + dp[i - 1][k]) % MOD;\n                            break;\n                        } else if (pc > cc) {\n                            continue;\n                        }\n                    } else if (pc == '?' && cc == '?') {\n                        sum = (sum + dp[i - 1][k]) % MOD;\n                    } else if (pc == '?') {\n                        sum = (sum + ('a' <= cc - 1 ? dp[i - 1][k] : 0)) % MOD;\n                    } else if (cc == '?') {\n                        sum = (sum + (pc + 1 <= 'z' ? dp[i - 1][k] : 0)) % MOD;\n                    }\n                }\n                dp[i][j] = sum;\n            }\n        }\n\n        long res = 0;\n        for (int j = 0; j <= m; j++) {\n            res = (res + dp[n][j]) % MOD;\n        }\n        return (int) res;\n    }\n}",
    "timestamp": "2025-08-05 21:52:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SunukeDictionary {\n    static final int MOD = 1_000_000_007;\n\n    public static int countValidRestorations(String[] words) {\n        int n = words.length;\n        return dfs(words, 0, null);\n    }\n\n    private static int dfs(String[] words, int index, String prevWord) {\n        if (index == words.length) {\n            return 1;\n        }\n\n        int ways = 0;\n        String currWord = words[index];\n\n        for (char c = 'a'; c <= 'z'; c++) {\n            String newWord = replaceQuestionMarks(currWord, c);\n            \n            if (prevWord == null || newWord.compareTo(prevWord) > 0) {\n                ways = (ways + dfs(words, index + 1, newWord)) % MOD;\n            }\n        }\n\n        return ways;\n    }\n\n    private static String replaceQuestionMarks(String word, char c) {\n        char[] chars = word.toCharArray();\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] == '?') {\n                chars[i] = c;\n            }\n        }\n        return new String(chars);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        String[] words = new String[n];\n        \n        for (int i = 0; i < n; i++) {\n            words[i] = scanner.next();\n        }\n        \n        System.out.println(countValidRestorations(words));\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:52:23"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\nconst int MOD = 1e9 + 7;\n\nclass Solution {\npublic:\n    int countValidRestorations(vector<string>& dictionary) {\n        int n = dictionary.size();\n        return solve(dictionary, 0, \"\");\n    }\n\nprivate:\n    int solve(vector<string>& dict, int index, string prev) {\n        if (index == dict.size()) {\n            return 1;\n        }\n        \n        int total = 0;\n        string current = dict[index];\n        \n        for (char c = 'a'; c <= 'z'; c++) {\n            for (int i = 0; i < current.length(); i++) {\n                if (current[i] == '?') {\n                    current[i] = c;\n                }\n            }\n            \n            if (index == 0 || current > prev) {\n                total = (total + solve(dict, index + 1, current)) % MOD;\n            }\n            \n            for (int i = 0; i < current.length(); i++) {\n                if (dict[index][i] == '?') {\n                    current[i] = '?';\n                }\n            }\n        }\n        \n        return total;\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<string> dictionary(n);\n    for (int i = 0; i < n; i++) {\n        cin >> dictionary[i];\n    }\n    \n    Solution solution;\n    cout << solution.countValidRestorations(dictionary) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:52:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 1000000007\n\ndef count_valid_restorations(n, words):\n    def is_valid_replacement(u, v):\n        for a, b in zip(u, v):\n            if a != '?' and b != '?' and a > b:\n                return False\n        return True\n\n    dp = [1] + [0] * n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if is_valid_replacement(words[j], words[i-1]):\n                dp[i] = (dp[i] + dp[j]) % MOD\n    return dp[n]\n\n# Example usage\nn = 3\nwords = ['a?c', '?b', 'ab?']\nprint(count_valid_restorations(n, words))",
    "timestamp": "2025-08-13 07:48:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class SunukeDictionary {\n    private static final int MOD = 1_000_000_007;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        String[] words = new String[n];\n        \n        for (int i = 0; i < n; i++) {\n            words[i] = scanner.next();\n        }\n\n        long result = countValidRestorations(words, n);\n        System.out.println(result);\n    }\n\n    private static long countValidRestorations(String[] words, int n) {\n        long result = 1;\n        \n        for (int i = 0; i < n; i++) {\n            words[i] = words[i].replace('?', '{');\n        }\n\n        for (int i = 1; i < n; i++) {\n            int prevLen = words[i - 1].length();\n            int currLen = words[i].length();\n            int minLen = Math.min(prevLen, currLen);\n            boolean isComplicated = true;\n\n            for (int j = 0; j < minLen; j++) {\n                char prevChar = words[i - 1].charAt(j);\n                char currChar = words[i].charAt(j);\n\n                if (prevChar != '{' && currChar != '{') {\n                    if (prevChar < currChar) {\n                        isComplicated = false;\n                        break;\n                    } else if (prevChar > currChar) {\n                        return 0;\n                    }\n                } else if (prevChar == '{' && currChar == '{') {\n                    return 0;\n                }\n            }\n\n            if (isComplicated) {\n                if (prevLen > currLen) {\n                    return 0;\n                } else if (prevLen == currLen) {\n                    for (int j = 0; j < prevLen; j++) {\n                        char prevChar = words[i - 1].charAt(j);\n                        char currChar = words[i].charAt(j);\n                        \n                        if (prevChar == '{' && currChar == '{') {\n                            result = (result * 25) % MOD;\n                        }\n                    }\n                } else {\n                    return 0;\n                }\n            }\n        }\n        \n        return result;\n    }\n}",
    "timestamp": "2025-08-13 07:48:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nint countWays(char previous[], char current[], int prelen, int curlen) {\n    int dp[prelen + 1][curlen + 1];\n    memset(dp, 0, sizeof(dp));\n    \n    dp[0][0] = 1;\n\n    for (int i = 0; i <= prelen; i++) {\n        for (int j = 0; j <= curlen; j++) {\n            if (i < prelen || j < curlen) {\n                char pc = i < prelen ? previous[i] : 'z' + 1;\n                char cc = j < curlen ? current[j] : 'z' + 1;\n                \n                if (pc == '?') pc = 'a';\n                if (cc == '?') cc = 'a';\n                \n                if ((i < prelen && j < curlen && pc == cc) || (i == prelen && j == curlen && i + j > 0)) {\n                    dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j]) % MOD;\n                }\n                if (i < prelen) {\n                    dp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % MOD;\n                }\n                if (j < curlen) {\n                    dp[i][j + 1] = (dp[i][j + 1] + dp[i][j]) % MOD;\n                }\n            }\n        }\n    }\n    return dp[prelen][curlen];\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    char words[n][1001];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", words[i]);\n    }\n\n    long long result = 1;\n    for (int i = 1; i < n; i++) {\n        result = (result * countWays(words[i - 1], words[i], strlen(words[i - 1]), strlen(words[i]))) % MOD;\n    }\n    printf(\"%lld\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-13 07:48:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_restorations(words):\n    MOD = 10**9 + 7\n    n = len(words)\n    \n    def is_valid_pair(s1, s2):\n        for c1, c2 in zip(s1, s2):\n            if c1 != '?' and c2 != '?' and c1 != c2:\n                return c1 < c2\n        return len(s1) <= len(s2)\n    \n    def count_ways(words):\n        dp = [1] * len(words)\n        \n        for i in range(1, len(words)):\n            dp[i] = 0\n            for j in range(i):\n                if is_valid_pair(words[j], words[i]):\n                    ways = 1\n                    for k in range(len(words[j])):\n                        if words[j][k] == '?' and words[i][k] == '?':\n                            ways *= 26\n                        elif words[j][k] == '?' and words[i][k] != '?':\n                            ways *= 1\n                        elif words[j][k] != '?' and words[i][k] == '?':\n                            ways *= 1\n                        elif words[j][k] != words[i][k]:\n                            ways = 0\n                            break\n                    dp[i] += dp[j] * ways\n                    dp[i] %= MOD\n        \n        return sum(dp) % MOD\n    \n    return count_ways(words)",
    "timestamp": "2025-08-13 07:48:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef solve():\n    import sys\n    n = int(sys.stdin.readline())\n    words = [sys.stdin.readline().strip() for _ in range(n)]\n    \n    max_len = max(len(word) for word in words)\n    # Pad words with a character that is smaller than 'a' to handle different lengths\n    padded_words = []\n    for word in words:\n        padded = word.ljust(max_len, chr(ord('a') - 1))\n        padded_words.append(padded)\n    \n    dp = [[0] * 26 for _ in range(n)]\n    # Initialize the first word\n    first_word = padded_words[0]\n    for j in range(max_len):\n        c = first_word[j]\n        if c == '?':\n            if j == 0:\n                for k in range(26):\n                    dp[0][k] = 1\n            else:\n                total = sum(dp[0][k] for k in range(26))\n                for k in range(26):\n                    dp[0][k] = total\n        else:\n            if c == chr(ord('a') - 1):\n                pass  # padding, no constraints\n            else:\n                k = ord(c) - ord('a')\n                if j == 0:\n                    dp[0][k] = 1\n                else:\n                    total = sum(dp[0][m] for m in range(k + 1))\n                    for m in range(26):\n                        if m == k:\n                            dp[0][m] = total\n                        else:\n                            dp[0][m] = 0\n                break  # rest are padding\n    \n    for i in range(1, n):\n        prev_word = padded_words[i-1]\n        curr_word = padded_words[i]\n        new_dp = [0] * 26\n        # Precompute prefix sums for previous dp\n        prefix = [0] * (26 + 1)\n        for k in range(26):\n            prefix[k+1] = prefix[k] + dp[i-1][k]\n            prefix[k+1] %= MOD\n        \n        # Process current word\n        for j in range(max_len):\n            pc = prev_word[j]\n            cc = curr_word[j]\n            if pc == '?' and cc == '?':\n                # Both are ?, so current must be >= previous\n                # The total is sum_{k} (dp_prev[k] * (26 - k))\n                total = 0\n                for k in range(26):\n                    cnt = (prefix[26] - prefix[k]) % MOD\n                    total += dp[i-1][k] * cnt % MOD\n                    total %= MOD\n                new_dp = [total] * 26\n                break\n            elif pc == '?':\n                if cc == '?':\n                    pass  # handled above\n                else:\n                    if cc == chr(ord('a') - 1):\n                        pass  # padding, but previous is ?, so invalid\n                    else:\n                        k_curr = ord(cc) - ord('a')\n                        # previous can be any <= k_curr\n                        total = prefix[k_curr + 1] % MOD\n                        new_dp = [0] * 26\n                        new_dp[k_curr] = total\n                        break\n            elif cc == '?':\n                if pc == chr(ord('a') - 1):\n                    pass  # padding, current can be anything\n                else:\n                    k_prev = ord(pc) - ord('a')\n                    # current must be >= k_prev\n                    total = (prefix[26] - prefix[k_prev]) % MOD\n                    new_dp = [total] * 26\n                    break\n            else:\n                # Both are fixed\n                if pc == chr(ord('a') - 1) and cc == chr(ord('a') - 1):\n                    continue  # padding, no constraints\n                elif pc == chr(ord('a') - 1):\n                    # current can be anything, but since previous is padding, current must be >= (but padding is smaller than 'a')\n                    pass\n                elif cc == chr(ord('a') - 1):\n                    # current is padding, but previous is not, so invalid\n                    new_dp = [0] * 26\n                    break\n                else:\n                    k_prev = ord(pc) - ord('a')\n                    k_curr = ord(cc) - ord('a')\n                    if k_prev < k_curr:\n                        # current is larger, so the rest can be anything\n                        total = sum(dp[i-1][k] for k in range(26)) % MOD\n                        new_dp = [0] * 26\n                        new_dp[k_curr] = total\n                        break\n                    elif k_prev == k_curr:\n                        # need to check next character\n                        continue\n                    else:\n                        # invalid\n                        new_dp = [0] * 26\n                        break\n        else:\n            # All characters are equal, which is invalid since s1 < s2 < ... < sn\n            new_dp = [0] * 26\n        \n        dp[i] = new_dp\n    \n    result = sum(dp[n-1][k] for k in range(26)) % MOD\n    print(result)\n\nsolve()",
    "timestamp": "2025-08-13 07:49:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nbool is_less(const string &a, const string &b) {\n    int len = min(a.length(), b.length());\n    for (int i = 0; i < len; i++) {\n        if (a[i] != '?' && b[i] != '?') {\n            if (a[i] < b[i]) return true;\n            if (a[i] > b[i]) return false;\n        }\n    }\n    return a.length() < b.length();\n}\n\nint count_options(char c1, char c2) {\n    if (c1 == '?' && c2 == '?') return 26 * 26;\n    if (c1 == '?') return 26;\n    if (c2 == '?') return 26;\n    return c1 < c2 ? 1 : 0;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<string> words(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> words[i];\n    }\n    \n    long long result = 1;\n\n    for (int i = 0; i < n - 1; ++i) {\n        string &current = words[i];\n        string &next = words[i + 1];\n        \n        if (!is_less(current, next)) {\n            long long count = 1;\n            bool valid = false;\n            for (int j = 0; j < current.length(); j++) {\n                if (current[j] != '?' && next[j] != '?') {\n                    if (current[j] < next[j]) {\n                        valid = true;\n                        break;\n                    }\n                    if (current[j] > next[j]) {\n                        count = 0;\n                        break;\n                    }\n                }\n                else {\n                    count = count * count_options(current[j], next[j]) % MOD;\n                }\n            }\n            if (!valid) {\n                if (current.length() < next.length()) {\n                    valid = true;\n                }\n            }\n            if (!valid) {\n                count = 0;\n            }\n            result = result * count % MOD;\n        }\n    }\n    cout << result << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:40:57"
  }
]