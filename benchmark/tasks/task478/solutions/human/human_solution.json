[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\n\nlong long  mod = 1000000007;\n\nint n;\nll dp[54][54][23][29];\nchar v[54][23];\nll saiki(int a,int b,int c,int d){\n\tif(d>=27||c>=21)return 0;\n\tif(dp[a][b][c][d]!=-1)return dp[a][b][c][d];\n\tif(a==b&&c==20)return 1;\n\tll ans = saiki(a,b,c,d+1);\n\tfor(int i=a;i<=b;i++){\n\t\tbool flag = 1;\n\t\tif(d==0&&v[i][c]==0){\n\t\t\tif(i==b){\n\t\t\t\tans = (ans + saiki(a,i,c+1,0))%mod;\n\t\t\t}else{\n\t\t\t\tans = (ans + (saiki(a,i,c+1,0)*saiki(i+1,b,c,d+1))%mod)%mod;\n\t\t\t}\n\t\t\tflag = 0;\n\t\t}\n\t\tif(d!=0&&v[i][c]=='?'){\n\t\t\tif(i==b){\n\t\t\t\tans = (ans + saiki(a,i,c+1,0))%mod;\n\t\t\t}else{\n\t\t\t\tans = (ans + (saiki(a,i,c+1,0)*saiki(i+1,b,c,d+1))%mod)%mod;\n\t\t\t}\n\t\t\tflag = 0;\n\t\t}\n\t\tif(d!=0&&v[i][c]==d-1+'a'){\n\t\t\tif(i==b){\n\t\t\t\tans = (ans + saiki(a,i,c+1,0))%mod;\n\t\t\t}else{\n\t\t\t\tans = (ans + (saiki(a,i,c+1,0)*saiki(i+1,b,c,d+1))%mod)%mod;\n\t\t\t}\n\t\t\tflag = 0;\n\t\t}\n\t\tif(flag)break;\n\t}\n\tdp[a][b][c][d] = ans;\n\treturn dp[a][b][c][d];\n}\n\nint main(){\n\tcin >> n;\n\trep(i,n){\n\t\tstring s;\n\t\tcin >> s;\n\t\trep(j,s.size()){\n\t\t\tv[i][j] = s[j];\n\t\t}\n\t\tfor(int j=s.size();j<21;j++){\n\t\t\tv[i][j] = 0;\n\t\t}\n\t}\n\tFill(dp,-1);\n\tcout << saiki(0,n-1,0,0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\n\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) {}\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n\nprivate:\n\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nMod memo[51][51][51][51];\n\nbool decide[51][51][51][51];\n\nvector<string>sts;\nMod getans(const int l, const int r,const int place, const int num) {\n\tif (decide[l][r][place][num]) {\n\t\treturn memo[l][r][place][num];\n\t}\n\telse {\n\t\tdecide[l][r][place][num] = true;\n\n\t\tif (l == r) {\n\t\t\treturn memo[l][r][place][num]=Mod(1);\n\t\t}\n\n\t\telse if (l + 1 == r) {\n\t\t\tMod ans(1);\n\t\t\tif (sts[l][place] == '?') {\n\t\t\t\tans *= 26 - num;\n\t\t\t}\n\t\t\telse if (sts[l][place] < 'a' + num) {\n\t\t\t\treturn memo[l][r][place][num] = 0;\n\t\t\t}\n\t\t\tfor (int n = place+1; n < sts[0].size(); ++n) {\n\t\t\t\tif (sts[l][n] == '?') {\n\t\t\t\t\tans *= 26;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn memo[l][r][place][num] = ans;\n\t\t}\n\t\telse {\n\t\t\tfor (int n = l; n < r; ++n) {\n\t\t\t\tif (sts[n][place] >= 'a' + num || sts[n][place] == '?') {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn memo[l][r][place][num] = Mod(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMod ans(0);\n\t\t\tif (place == sts[0].size() - 1 && num == 25) {\n\t\t\t\treturn memo[l][r][place][num] = Mod(0);\n\t\t\t}else if (place == sts[0].size() - 1) {\n\t\t\t\tif (sts[l][place] == 'a' + num || sts[l][place] == '?') {\n\t\t\t\t\tans += getans(l + 1, r, place, num + 1);\n\t\t\t\t}\n\t\t\t\tans += getans(l, r, place, num + 1);\n\t\t\t\treturn memo[l][r][place][num] = ans;\n\t\t\t}\n\t\t\telse if (num == 25) {\n\t\t\t\treturn memo[l][r][place][num] = getans(l, r, place + 1, 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int k = l; k <= r; ++k) {\n\t\t\t\t\tbool ok = true;\n\t\t\t\t\tfor (int a = l; a < k; ++a) {\n\t\t\t\t\t\tif (sts[a][place] == 'a' + num || sts[a][place] == '?') {\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\n\t\t\t\t\t\tans += getans(l, k, place + 1, 0)*getans(k, r, place, num + 1);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn memo[l][r][place][num] = ans;\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tmemset(decide, false, sizeof(decide)); \n\tint n; cin >> n;\n\tsts.resize(n); \n\tfor (int i = 0; i < n; ++i) {\n\t\tstring st; cin >> st;\n\t\tsts[i] = st;\n\t}\n\tMod ans(getans(0, n, 0, 0));\n\tcout << ans << endl;\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#define mod 1000000007\nusing namespace std;\nint n, p[21], c[50][21], dp[50][51][21]; string s[50];\nint solve(int l, int r, int k) {\n\tif(r - l == 1) return p[c[l][k]];\n\tif(dp[l][r][k]) return dp[l][r][k] - 1;\n\tint dp2[51][27] = {0}; dp2[l][0] = 1;\n\tfor(int a = l + 1; a <= r; a++) {\n\t\tfor(int b = 1; b <= 26; b++) {\n\t\t\tfor(int c = a - 1; c >= l; c--) {\n\t\t\t\tbool flag1 = true, flag2 = true;\n\t\t\t\tfor(int d = c; d < a; d++) {\n\t\t\t\t\tif((s[d][k] != '?' && s[d][k] != b + 96) || (d != c && s[d].size() == k + 1)) {\n\t\t\t\t\t\tflag1 = false; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!flag1) continue;\n\t\t\t\tint res = flag2 ? solve(c, a, k + 1) : 1, r = 0;\n\t\t\t\tfor(int d = b - 1; d >= 0; d--) {\n\t\t\t\t\tdp2[a][b] = (dp2[a][b] + 1LL * dp2[c][d] * res) % mod;\n\t\t\t\t\tr = (r + 1LL * dp2[c][d] * res) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i = 1; i <= 26; i++) ret += dp2[r][i];\n\tdp[l][r][k] = ret + 1;\n\treturn ret;\n}\nint main() {\n\tcin >> n; p[0] = 1;\n\tfor(int i = 1; i <= 20; i++) p[i] = 1LL * p[i - 1] * 26 % mod;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tfor(int j = s[i].size() - 1; j >= 0; j--) c[i][j] = c[i][j + 1] + (s[i][j] == '?' ? 1 : 0);\n\t}\n\tprintf(\"%d\\n\", solve(0, n, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 55\n#define int long long\nusing namespace std;\nconst int s = ('a'-1);\nconst int mod = (1e9)+7;\nint n;\nstring str[N];\n\nint calc(int y,int x,int ch){\n  if(x>=(int)str[y].size() || ch>=27) return 0;\n  int k = 0;\n  if(str[y][x] != '?') k = 1;\n  if(str[y][x] == '?') k = 27 - ch;\n  if(k == 0) return 0;\n  int res = 1;\n  for(++x;x<(int)str[y].size();x++) if(str[y][x]=='?') res = (res*26)%mod;\n  return (res*k)%mod;\n}\n\n\nbool check(int u,int d,int x,char ch){\n  for(int y=u;y<=d;y++) if(str[y][x] != '?' && str[y][x] != ch) return 0;\n  return  1;\n}\n\nint mem[N][N][22][30],used[N][N][22][30];\nint dfs(int u,int d,int x,int c){\n  if(u > d) return 1;\n  if(u == d) return calc(u,x,c);\n  if(x >= 21) return 0;\n  if(c > 26) return 0;\n  if(str[u][x] == s) return (c == 1 && str[u+1][x] != s ? dfs(u+1,d,x,c):0);\n  if(used[u][d][x][c]++) return mem[u][d][x][c];\n\n  vector<int> mnc(N,30);\n  for(int y=d;y>=u;y--)mnc[y] = min(mnc[y+1],str[y][x]=='?'? 30:str[y][x] - s);  \n  \n  int res = dfs(u,d,x,c+1); \n  //[u,y]?????????????????????????????????????????????\n  for(int y=u;y<=d;y++){\n    if(mnc[y+1] <= c || !check(u,y,x,c+s)) continue;\n    res = (res+(dfs(u,y,x+1,1)*dfs(y+1,d,x,c+1))%mod)%mod;\n  }\n    return mem[u][d][x][c] = res;\n}\n\n\nsigned main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>str[i];\n    while(str[i].size()<21) str[i]+=s;\n  }\n  cout<<dfs(0,n-1,0,1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<string>\nusing namespace std;\n\nint n, m, MOD = 1000000007;\nstring s[60];\nint dp[51][51][21][27];\n\nint solve(int l, int r, int p, int c){\n\tif(l == r || (l+1 == r && s[l].size() == p && !c)) return 1;\n\tif(s[l].size() == p){\n\t\tif(c) return 0;\n\t\telse if(l+1 == r) return 1;\n\t\telse if(l+1 < r && s[l+1].size() > p) return solve(l+1, r, p, c);\n\t}\n\tif(c >= 26) return 0;\n\tint &res = dp[l][r][p][c];\n\tif(res != -1) return res;\n\tres = 0;\n\tfor(int i=l;i<=r;i++){\n\t\tres = (res + (long long)solve(l, i, p+1, 0) * solve(i, r, p, c+1)) % MOD;\n\t\tif(s[i].size() <= p || (s[i][p] != '?' && s[i][p] != 'a' + c)) break;\n\t}\n\treturn res;\n}\n\nint main(){\n\tmemset(dp, -1, sizeof(dp));\n\tcin >> n;\n\tfor(int i=0;i<n;i++) cin >> s[i];\n\tcout << solve(0, n, 0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll MOD = 1000000007;\n\nint dp[21][51][51];\n\nbool check(char c, char d) {\n\treturn c == d || (c != '`' && d == '?');\n}\n\nint main() {\n\tint n; cin >> n;\n\tvector<string> s(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tfor (; s[i].size() < 20; s[i].push_back('`'));\n\t}\n\tfor (int i = 0; i <= n; i++)\n\t\tdp[20][i][i] = 1;\n\tfor (int i = 0; i + 1 <= n; i++)\n\t\tdp[20][i][i + 1] = 1;\n\tfor (int k = 19; k >= 0; k--)\n\t\tfor (int l = 0; l <= n; l++) {\n\t\t\tvector<int> a(n + 1);\n\t\t\ta[l] = 1;\n\t\t\tfor (char c = '`'; c <= 'z'; c++)\n\t\t\t\tfor (int i = n; i >= l; i--)\n\t\t\t\t\tif (a[i])\n\t\t\t\t\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\t\t\t\t\tif (!check(c, s[j - 1][k])) break;\n\t\t\t\t\t\t\ta[j] = (a[j] + (ll)a[i] * dp[k + 1][i][j]) % MOD;\n\t\t\t\t\t\t}\n\t\t\tfor (int r = l; r <= n; r++)\n\t\t\t\tdp[k][l][r] = a[r];\n\t\t}\n\tcout << dp[0][0][n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#define mod 1000000007\nusing namespace std;\nint n, dp[50][51][21]; string s[50];\nint solve(int l, int r, int k) {\n\tif(r - l == 1) {\n\t\tint ret = 1;\n\t\tfor(int i = k; i < s[l].size(); i++) {\n\t\t\tif(s[l][i] == '?') ret = 1LL * ret * 26 % mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tint dp2[51][27] = {0}; dp2[l][0] = 1;\n\tfor(int a = l + 1; a <= r; a++) {\n\t\tfor(int b = 1; b <= 26; b++) {\n\t\t\tfor(int c = a - 1; c >= l; c--) {\n\t\t\t\tbool flag1 = true, flag2 = true;\n\t\t\t\tfor(int d = c; d < a; d++) {\n\t\t\t\t\tif((s[d][k] != '?' && s[d][k] != b + 96) || (d != c && s[d].size() == k + 1)) {\n\t\t\t\t\t\tflag1 = false; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!flag1) continue;\n\t\t\t\tint res = flag2 ? solve(c, a, k + 1) : 1, r = 0;\n\t\t\t\tfor(int d = b - 1; d >= 0; d--) {\n\t\t\t\t\tdp2[a][b] = (dp2[a][b] + 1LL * dp2[c][d] * res) % mod;\n\t\t\t\t\tr = (r + 1LL * dp2[c][d] * res) % mod;\n\t\t\t\t}\n\t\t\t\t//printf(\"(%d, %d) k = %d %d %d\\n\", c, a, k, b, r);\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i = 1; i <= 26; i++) ret += dp2[r][i];\n\treturn ret;\n}\nint main() {\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) cin >> s[i];\n\tprintf(\"%d\\n\", solve(0, n, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n\nusing namespace std;\nusing ll = long long;\n\nstruct DisjointSets {\n    DisjointSets(const int v)\n    {\n        m_parent.resize(v);\n        m_rank.resize(v);\n        for (int i = 0; i < v; i++) {\n            m_parent[i] = i;\n            m_rank[i] = 0;\n        }\n    }\n\n    bool same(const int a, const int b)\n    {\n        return find(a) == find(b);\n    }\n\n\n    int find(const int a)\n    {\n        if (m_parent[a] == a) {\n            return a;\n        } else {\n            return m_parent[a] = find(m_parent[a]);\n        }\n    }\n\n    void unite(const int a_, const int b_)\n    {\n        const int a = find(a_);\n        const int b = find(b_);\n        if (a == b) {\n            return;\n        }\n        if (m_rank[a] > m_rank[b]) {\n            m_parent[b] = a;\n        } else {\n            m_parent[a] = b;\n        }\n        if (m_rank[a] == m_rank[b]) {\n            m_rank[b]++;\n        }\n    }\n\n    vector<int> m_parent;\n    vector<int> m_rank;\n};\n\nstruct Query {\n    int q;\n    int u;\n    int v;\n};\n\nint main()\n{\n    int N, K;\n    cin >> N >> K;\n    const int SQRT = 200;\n    const int BNUM = (K + SQRT - 1) / SQRT;\n    using P = pair<int, int>;\n    vector<vector<Query>> queries(BNUM);\n    for (int Q = 0; Q < K; Q++) {\n        int q, u, v;\n        cin >> q >> u >> v;\n        if (u > v) {\n            swap(u, v);\n        }\n        queries[Q / SQRT].push_back(Query{q, u, v});\n    }\n    for (int i = 0; i < BNUM; i++) {\n        set<P> edge;\n        for (int j = 0; j < i; j++) {\n            for (const auto& q : queries[j]) {\n                if (q.q == 1) {\n                    edge.insert(make_pair(q.u, q.v));\n                } else if (q.q == 2) {\n                    edge.erase(make_pair(q.u, q.v));\n                }\n            }\n        }\n        set<P> in;\n        set<int> node;\n        for (const auto& q : queries[i]) {\n            if (q.q == 2) {\n                if (edge.find(make_pair(q.u, q.v)) != edge.end()) {\n                    edge.erase(make_pair(q.u, q.v));\n                    in.insert(make_pair(q.u, q.v));\n                }\n                node.insert(q.u);\n                node.insert(q.v);\n            } else if (q.q == 1) {\n                node.insert(q.u);\n                node.insert(q.v);\n            }\n        }\n\n        DisjointSets uf(N);\n        for (const auto& e : edge) {\n            uf.unite(e.first, e.second);\n        }\n        auto uf_ = uf;\n\n        for (const auto& q : queries[i]) {\n            if (q.q == 1) {\n                in.insert(make_pair(q.u, q.v));\n            } else if (q.q == 2) {\n                in.erase(make_pair(q.u, q.v));\n            } else {\n                for (const int n : node) {\n                    uf.m_parent[n] = uf_.m_parent[n];\n                }\n                for (const auto& e : in) {\n                    uf.unite(e.first, e.second);\n                }\n                cout << (uf.same(q.u, q.v) ? \"YES\" : \"NO\") << endl;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\n\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) {}\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n\nprivate:\n\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nMod memo[51][51][21][30];\n\nbool decide[51][51][21][30];\n\nvector<string>sts;\nMod getans(const int l, const int r,const int place, const int num) {\n\tif (decide[l][r][place][num]) {\n\t\treturn memo[l][r][place][num];\n\t}\n\telse {\n\t\tdecide[l][r][place][num] = true;\n\n\t\tif (l == r) {\n\t\t\treturn memo[l][r][place][num]=Mod(1);\n\t\t}\n\n\t\telse if (l + 1 == r) {\n\t\t\tMod ans(1);\n\t\t\tif (sts[l][place] == '?') {\n\t\t\t\tans *= min(26,26 - num+1);\n\t\t\t}\n\t\t\telse if (sts[l][place] < 'a' + num-1) {\n\t\t\t\treturn memo[l][r][place][num] = 0;\n\t\t\t}\n\t\t\tfor (int n = place+1; n < sts[0].size(); ++n) {\n\t\t\t\tif (sts[l][n] == '?') {\n\t\t\t\t\tans *= 26;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn memo[l][r][place][num] = ans;\n\t\t}\n\t\telse {\n\t\t\tfor (int n = l; n < r; ++n) {\n\t\t\t\tif (sts[n][place] < 'a' + num - 1 && sts[n][place] != '?') {\n\t\t\t\t\treturn memo[l][r][place][num] = Mod(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMod ans(0);\n\t\t\tif (place == 19 && num == 26) {\n\t\t\t\treturn memo[l][r][place][num] = Mod(0);\n\t\t\t}else if (place == 19) {\n\t\t\t\tif (sts[l][place] == 'a' + num - 1 || num != 0 && sts[l][place] == '?') {\n\t\t\t\t\tans += getans(l + 1, r, place, num + 1);\n\t\t\t\t}\n\t\t\t\tans += getans(l, r, place, num + 1);\n\t\t\t\treturn memo[l][r][place][num] = ans;\n\t\t\t}\n\t\t\telse if (num == 26) {\n\t\t\t\treturn memo[l][r][place][num] = getans(l, r, place + 1, 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int k = l; k <= r; ++k) {\n\t\t\t\t\tbool ok = true;\n\t\t\t\t\tfor (int a = l; a < k; ++a) {\n\t\t\t\t\t\tif (sts[a][place] == 'a' + num - 1 || (num!=0&&sts[a][place] == '?')) {\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tans += getans(l, k, place + 1, 0)*getans(k, r, place, num + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn memo[l][r][place][num] = ans;\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tmemset(decide, false, sizeof(decide)); \n\tint n; cin >> n;\n\tsts.resize(n); \n\tfor (int i = 0; i < n; ++i) {\n\t\tstring st; cin >> st;\n\t\tint si = st.size();\n\t\tfor (int j = 0; j < 20 - si; ++j) {\n\t\t\tst.push_back('a' - 1);\n\t\t}\n\t\tsts[i] = st;\n\t}\n\tMod ans(getans(0, n, 0, 0));\n\tcout << ans << endl;\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nconst Int MOD = 1e9+7;\nInt n;\nstring s[55];\nInt dp[55][55][22][33];\nInt check(Int u,Int d,Int k,Int c){\n  Int flg=1;\n  for(Int i=u;i<d;i++)\n    flg&=(k<(Int)s[i].size()&&(s[i][k]=='?'||s[i][k]=='a'+c));\n  return flg;\n}\n\nInt dfs(Int u,Int d,Int k,Int a){\n  Int &res=dp[u][d][k][a];\n  if(~res) return res;\n  res=0;\n  \n  if(u+1==d&&k==(Int)s[u].size())\n    return res=1;\n\n  if(k==(Int)s[u].size()&&k<(Int)s[u+1].size())\n    return res=dfs(u+1,d,k,0);\n\n  if(k>=(Int)s[u].size())\n    return res=0;\n  \n  for(Int c=a;c<26;c++)\n    if(check(u,d,k,c)) (res+=dfs(u,d,k+1,0))%=MOD;\n  \n  for(Int i=u+1;i<d;i++)\n    for(Int c=a;c<26;c++)\n      if(check(u,i,k,c))\n\t (res+=dfs(u,i,k+1,0)*dfs(i,d,k,c+1)%MOD)%=MOD;\n\n  //if(res) cout<<u<<\" \"<<d<<\" \"<<k<<\" \"<<a<<\":\"<<res<<endl;\n  return res;\n}\n\nsigned main(){\n  cin>>n;\n  for(Int i=0;i<n;i++) cin>>s[i];\n  memset(dp,-1,sizeof(dp));\n  cout<<dfs(0,n,0,0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\n  \nll mod=1000000007;\n  \nll add(ll a,ll b){\n  return (a+b+mod+mod)%mod;\n}\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n  \nll dp[51][51][21][27];\nint n;\nbool f[50][21];\nchar t[50][21];\n  \nll rec(int ay,int by,int x,char ch){\n  //    cout<<ay<<' '<<by<<' '<<x<<' '<<ch<<endl;\n \n  if(ay==by)return 1;\n\n  bool flag=true;\n  for(int i=ay;i<by;i++)\n    if(f[i][x]==true)\n      flag=false;\n  \n  if(flag){\n    if(ay+1==by)return  1;\n    else return 0;\n  }\n  \n\n  if(f[ay][x]==false){\n    return rec(ay+1,by,x,ch);\n  }\n\n  for(int i=ay+1;i<by;i++){\n    if(f[i][x]==false)return 0;\n  }\n  //cout<<'a'<<endl;  \n  if(ch>'z')return 0;\n\n  int CH=ch-'a';\n  if(dp[ay][by][x][CH]!=-1)return dp[ay][by][x][CH];\n\n\n\n\n  ll res=rec(ay,by,x,ch+1);\n  \n  \n  int next=ay;\n  for(int i=ay;i<by;i++){\n    if(t[i][x]==ch)next=i;\n  }\n    \n  for(int i=ay;i<next;i++){\n    if(t[i][x]!=ch&&t[i][x]!='?')\n      return 0;\n  }\n  \n  for(int i=next;i<by;i++){\n    if(t[i][x]!='?'&&t[i][x]!=ch)break;\n    res=add(res, mul( rec(ay,i+1,x+1,'a') , rec(i+1,by,x,ch+1)) );\n  }\n \n \n  //  if(res>0){\n  // cout<<ay<<' '<<by<<' '<<x<<' '<<CH<<endl;\n\t//  }\n  return dp[ay][by][x][CH]=res;\n}\n  \n  \n  \nint main(){\n  for(int i=0;i<51;i++)\n    for(int j=0;j<51;j++)\n      for(int k=0;k<21;k++)\n\tfor(int l=0;l<27;l++)\n\t  dp[i][j][k][l]=-1;\n    \n  for(int i=0;i<50;i++){\n    for(int j=0;j<21;j++){\n      t[i][j]='a';\n      f[i][j]=false;\n    }\n  }\n  string str;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>str;\n    for(int j=0;j<(int)str.size();j++){\n      t[i][j]=str[j];\n      f[i][j]=true;\n    }\n  }\n\n  //cout<<rec(1,3,0,'b')<<'-'<<endl;\n\n  cout<<rec(0,n,0,'a')<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#define mod 1000000007\nusing namespace std;\nint n, p[21], c[50][21], dp[50][51][21]; string s[50];\nint solve(int l, int r, int k) {\n\tif(r - l == 1) return p[c[l][k]];\n\tif(dp[l][r][k]) return dp[l][r][k] - 1;\n\tint dp2[51][27] = {0}; dp2[l][0] = 1;\n\tfor(int a = l + 1; a <= r; a++) {\n\t\tfor(int b = 1; b <= 26; b++) {\n\t\t\tfor(int c = a - 1; c >= l; c--) {\n\t\t\t\tif((s[c][k] != '?' && s[c][k] != b + 96) || (c + 1 != a && s[c].size() == k + 1)) break;\n\t\t\t\tint res = solve(c, a, k + 1), r = 1;\n\t\t\t\tfor(int d = b - 1; d >= 0; d--) r = (r + dp2[c][d]) % mod;\n\t\t\t\tdp2[a][b] += (dp2[a][b] + 1LL * res * r) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i = 1; i <= 26; i++) ret += dp2[r][i];\n\tdp[l][r][k] = ret + 1;\n\treturn ret;\n}\nint main() {\n\tcin >> n; p[0] = 1;\n\tfor(int i = 1; i <= 20; i++) p[i] = 1LL * p[i - 1] * 26 % mod;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tfor(int j = s[i].size() - 1; j >= 0; j--) c[i][j] = c[i][j + 1] + (s[i][j] == '?' ? 1 : 0);\n\t}\n\tprintf(\"%d\\n\", solve(0, n, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nint n;\nstring s[55];\nint c[55][25];\nllint memo[55][55][25][30];\n\nllint calc(int i, int j, int k, int l)\n{\n\t//cout << i << j << k << l << endl;\n\t\n\tif(memo[i][j][k][l] != -1) return memo[i][j][k][l];\n\tif(i > j) return 1;\n\tif(l > 26) return 0;\n\tif(k > 21) return 0;\n\t\n\tif(l == 0){\n\t\tif(c[i][k] == 0){\n\t\t\tif(i+1 == j && c[i+1][k] == 0) return 0;\n\t\t\telse return memo[i][j][k][l] = calc(i+1, j, k, 0);\n\t\t}\n\t\telse return memo[i][j][k][l] = calc(i, j, k, 1);\n\t}\n\t\n\tllint ret = 0;\n\tret += calc(i, j, k, l+1);\n\tfor(int x = i; x <= j; x++){\n\t\tif(c[x][k] != -1){\n\t\t\tif(c[x][k] < l) return memo[i][j][k][l] = 0;\n\t\t\tif(c[x][k] > l) break;\n\t\t}\n\t\tif(x < j) ret += calc(i, x, k+1, 0) * calc(x+1, j, k, l+1) % mod;\n\t\telse ret += calc(i, j, k+1, 0) % mod;\n\t\tret %= mod;\n\t}\n\t//cout << i << j << k << l << \" \" << ret << endl;\n\treturn memo[i][j][k][l] = ret;\n}\n\nint main(void)\n{\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++) cin >> s[i];\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 0; j < s[i].size(); j++){\n\t\t\tif(s[i][j] == '?') c[i][j] = -1;\n\t\t\telse c[i][j] = s[i][j] - 'a' + 1;\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= 51; i++){\n\t\tfor(int j = 1; j <= 51; j++){\n\t\t\tfor(int k = 0; k < 25; k++){\n\t\t\t\tfor(int l = 0; l < 30; l++){\n\t\t\t\t\tmemo[i][j][k][l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << calc(1, n, 0, 0) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-9;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<string>s(N);\n\tfor (auto &i : s) {\n\t\tcin >> i;\n\t\tfor (auto &j : i)j += 1;\n\t\ti = string(1, 'a') + i;\n\t\twhile (i.size() < 21)i.push_back('a');\n\t}\n//\tfor (auto i : s)cout << i << endl;\n\tvector<vector<vector<long long int>>>dp(N, vector<vector<long long int>>(N + 1, vector<long long int>(22)));\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 21; j < 22; j++) {\n\t\t\tdp[i][i + 1][j] = 1;\n\t\t}\n\t}\n\tfor (int j = 20; j >= 0; j--) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tvector<vector<long long int>>cdp(N + 1, vector<long long int>(29));\n\t\t\tcdp[i][0] = 1;\n\t\t\tfor (int k = i; k < N; k++) {\n\t\t\t\tfor (int l = 0; l < 27; l++) {\n\t\t\t\t\tint cnt = k;\n\t\t\t\t\tint kotei = -1;\n\t\t\t\t\tif (s[cnt][j] != '@')kotei = s[cnt][j] - 'a' + 1;\n\t\t\t\t\tcnt++;\n\t\t\t\t\twhile (kotei != -2&&cnt<=N) {\n\t\t\t\t\t\tif (kotei == -1) {\n\t\t\t\t\t\t\tfor (int m = max(2,l + 1); m <= 27; m++) {\n\t\t\t\t\t\t\t\tcdp[cnt][m] += cdp[k][l] * dp[k][cnt][j + 1] % MOD;\n\t\t\t\t\t\t\t\tcdp[cnt][m] %= MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (kotei > l) {\n\t\t\t\t\t\t\t\tcdp[cnt][kotei] += cdp[k][l] * dp[k][cnt][j + 1] % MOD;\n\t\t\t\t\t\t\t\tcdp[cnt][kotei] %= MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cnt<N){\n\t\t\t\t\t\t\tif (s[cnt][j] != '@') {\n\t\t\t\t\t\t\t\tif (kotei == -1) {\n\t\t\t\t\t\t\t\t\tif (s[cnt][j] == 'a')kotei = -2;\n\t\t\t\t\t\t\t\t\telse kotei = s[cnt][j] - 'a' + 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tif (kotei != s[cnt][j] - 'a' + 1)kotei = -2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (kotei == 1)kotei = -2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k <= N; k++) {\n\t\t\t\tfor (int l = 1; l <= 27; l++) {\n\t\t\t\t\tdp[i][k][j] += cdp[k][l];\n\t\t\t\t\tdp[i][k][j] %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j <= N; j++) {\n\t\t\tfor (int k = 0; k <= 21; k++) {\n\t\t//\t\tif(dp[i][j][k])cout << i << \" \" << j << \" \" << k << \" \" << dp[i][j][k] << endl;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][N][0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nbool used[50][50][21];\nmodint memo[50][50][21];\n\nint n;\nvector<string> s;\nmodint dfs(int l, int r, int d) {\n\tif (l > r)return 1;\n\tif (used[l][r][d])return memo[l][r][d];\n\tused[l][r][d] = true;\n\tmodint res = 0;\n\tRep1(i, l + 1, r) {\n\t\tif (s[i].size() <=d)return memo[l][r][d] = 0;\n\t}\n\tif (s[l].size() <= d) {\n\t\treturn memo[l][r][d] = dfs(l + 1, r, d);\n\t}\n\t//cout << l << \" \" << r <<\" \"<<d<< endl;\n\tint len = r - l + 1;\n\tvector<modint> dp(len + 1, 0);\n\tdp[0] = 1;\n\tvector<modint> cop(len + 1);\n\trep(i, 26) {\n\t\tfill(cop.begin(), cop.end(), 0);\n\t\trep(j, len+1) {\n\t\t\tcop[j] += dp[j];\n\t\t\tRep(k, j+1, len + 1) {\n\t\t\t\tif (s[k - 1 + l][d] != '?'&&s[k - 1 + l][d] != 'a' + i)break;\n\t\t\t\tcop[k] += dp[j] * dfs(j + l, k - 1 + l, d + 1);\n\t\t\t}\n\t\t}\n\t\trep(j, len + 1)dp[j] = cop[j];\n\t\t//cout << dp[0]<<\" \"<<dp[len] << endl;\n\t}\n\treturn memo[l][r][d] = dp[len];\n}\nvoid solve() {\n\tcin >> n; s.resize(n);\n\trep(i, n) {\n\t\tcin >> s[i];\n\t}\n\tmodint ans = dfs(0, n - 1, 0);\n\tcout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(12);\n\t//init_f(); init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 55\n#define int long long\nusing namespace std;\nconst int s = ('a'-1);\nconst int mod = (1e9)+7;\nint n;\nstring str[N];\n\nint calc(int y,int x,int ch){\n  if(x>=(int)str[y].size() || ch>=27) return 0;\n  int k = 0;\n  if(str[y][x] != '?') k = 1;\n  if(str[y][x] == '?') k = 27 - ch;\n  if(k == 0) return 0;\n  static int mem[N][22]={},used[N][22]={};\n  if(used[y][x]) return (k*mem[y][x])%mod;\n  used[y][x] = 1;\n  int &res = mem[y][x] = 1;\n  for(++x;x<(int)str[y].size();x++) if(str[y][x]=='?') res = (res*26)%mod;\n  return (res*k)%mod;\n}\n\n\nbool check(int u,int d,int x,char ch){\n  static bool memc[N][N][22][30],usedc[N][N][22][30];\n  if(usedc[u][d][x][ch-s]) return memc[u][d][x][ch-s];\n  usedc[u][d][x][ch-s] = 1;\n  for(int y=u;y<=d;y++) if(str[y][x] != '?' && str[y][x] != ch) return memc[u][d][x][ch-s]=0;\n  return  memc[u][d][x][ch-s]=1;\n}\n\nint mem[N][N][22][30],used[N][N][22][30];\nint dfs(int u,int d,int x,int c){\n  if(u > d) return 1;\n  if(u == d) return calc(u,x,c);\n  if(x >= 21) return 0;\n  if(str[u][x] == s) return mem[u][d][x][c] = (c == 1 && str[u+1][x] != s ? dfs(u+1,d,x,c):0);\n  if(used[u][d][x][c]++) return mem[u][d][x][c];\n  \n  vector<int> mnc(N,30);\n  for(int y=d;y>=u;y--)mnc[y] = min(mnc[y+1],str[y][x]=='?'? 30:str[y][x] - s);\n\n  int res = 0; \n  //[u,y]?????????????????????????????????????????????\n  for(int ch=c;ch<=26;ch++){\n    for(int y=u;y<=d;y++){\n      if(mnc[y+1] <= ch || !check(u,y,x,ch+s)) continue;\n      res = (res+(dfs(u,y,x+1,1)*dfs(y+1,d,x,ch+1))%mod)%mod;\n    }\n  }\n  return mem[u][d][x][c] = res;\n}\n\n\nsigned main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>str[i];\n    while(str[i].size()<21) str[i]+=s;\n  }\n  cout<<dfs(0,n-1,0,1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 51\n#define s ((int)('a'-1))\n#define int long long\nusing namespace std;\nconst int mod = (1e9)+7;\nint n;\nstring str[N];\n\nint mem[N][21][27],used[N][21][27];\nint calc(int y,int x){\n  int res = 1;\n  for(int i=0;i<=y;i++)\n    for(int j=x;j<(int)str[y].size();j++) if(str[i][j]=='?')res=(res*26)%mod;\n  return res;\n}\n\nint dfs(int y,int x,int u){\n  if(y == n) return calc(y-1,x+1);\n  if(x == (int)str[y].size()) return 0;\n  if(used[y][x][u]++) return mem[y][x][u];\n\n  int p = str[y][x];\n  int res = 0;\n  if(isalpha(p)){\n    p-=s;\n    if(p > u)  res = (res+dfs(y+1,x,p))%mod;\n    if(p == u) res = (res+dfs(y-1,x+1,0))%mod;\n  }\n  else if(p == '?'){\n    for(p=1;p<=26;p++){\n      if(p > u)  res = (res+dfs(y+1,x,p))%mod;\n      if(p == u) res = (res+dfs(y-1,x+1,0))%mod;\n    }\n  }\n  return mem[y][x][u] = res;\n}\n\n\nsigned main(){\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>str[i];\n  cout<<dfs(0,0,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n#define mod 1000000007\nint n; string s[55];\nll dp[55][55][25]; bool u[55][55][25];\nint nm[55][55][25];\nll rec(int L,int R,int num){\n\tif(u[L][R][num]) return dp[L][R][num];\n\tu[L][R][num] = 1;\n\tif(L==R){\n\t      dp[L][R][num] = 1;\n\t      for(int j=num-1;j<s[L].size();j++) if(s[L][j]=='?') dp[L][R][num] = (dp[L][R][num]*26LL)%mod;\n\t      return dp[L][R][num];\n\t}\n\tint cnt = 0;\n\tfor(int i=L;i<=R;i++){\n\t\tif(s[i].size() < num){\n\t\t\tif(i != L || cnt) return dp[L][R][num] = 0;\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif(cnt){\n\t\tif(cnt == R-L+1){\n\t\t\treturn dp[L][R][num] = 1;\n\t\t}\n\t\telse return dp[L][R][num] = rec(L+cnt,R,num);\n\t}\n\tll t[55][30] = {};\n\tt[L-1][0] = 1;\n\tfor(int i=L;i<=R;i++){\n\t\tfor(int j=L-1;j<i;j++){\n\t\t\tif(nm[j+1][i][num] > 0){\n\t\t\t\t//dp[j+1][i][num+1] wo kentou\n\t\t\t\tint k = nm[j+1][i][num];\n\t\t\t\t{\n\t\t\t\t\t{\n                        ll R = rec(j+1,i,num+1);\n\t\t\t\t\t\tfor(int l=0;l<k;l++) t[i][k] = (t[i][k] + t[j][l]*R%mod)%mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(nm[j+1][i][num] == 0){\n\t\t\t\tll R = rec(j+1,i,num+1);\n\t\t\t\tll T = 0;\n\t\t\t\tfor(int k=1;k<=26;k++){\n\t\t\t\t\tT = (T+t[j][k-1])%mod;\n\t\t\t\t\tt[i][k] = (t[i][k]+T*R%mod)%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=26;i++) dp[L][R][num] = (dp[L][R][num]+t[R][i])%mod;\n\treturn dp[L][R][num];\n}\nint main(){\n\tcin >> n;\n\tfor(int i=1;i<=n;i++) cin >> s[i];\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i;j<=n;j++){\n\t\t\tfor(int k=1;k<=20;k++){\n\t\t\t\tfor(int x=i;x<=j;x++){\n\t\t\t\t\tif(s[x].size()>=k){\n\t\t\t\t\t\tif(s[x][k-1] != '?'){\n\t\t\t\t\t\t\tif(nm[i][j][k] == 0) nm[i][j][k] = 1 + (s[x][k-1]-'a');\n\t\t\t\t\t\t\telse if(nm[i][j][k] != 1 + (s[x][k-1]-'a')) nm[i][j][k] = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << rec(1,n,1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n#define mod 1000000007\nint n; string s[55];\nll dp[55][55][25]; bool u[55][55][25];\nint nm[55][55][25];\nll rec(int L,int R,int num){\n\tif(u[L][R][num]) return dp[L][R][num];\n\tu[L][R][num] = 1;\n\tif(L==R){\n\t      dp[L][R][num] = 1;\n\t      for(int j=num-1;j<s[L].size();j++) if(s[L][j]=='?') dp[L][R][num] = (dp[L][R][num]*26LL)%mod;\n\t      return dp[L][R][num];\n\t}\n\tint cnt = 0;\n\tfor(int i=L;i<=R;i++){\n\t\tif(s[i].size() < num){\n\t\t\tif(i != L || cnt) return dp[L][R][num] = 0;\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif(cnt){\n\t\tif(cnt == R-L+1){\n\t\t\treturn dp[L][R][num] = 1;\n\t\t}\n\t\telse return dp[L][R][num] = rec(L+cnt,R,num);\n\t}\n\tll t[55][30] = {};\n\tt[L-1][0] = 1;\n\tfor(int i=L;i<=R;i++){\n\t\tfor(int j=L-1;j<i;j++){\n\t\t\tif(nm[j+1][i][num] >= 0){\n\t\t\t\t//dp[j+1][i][num+1] wo kentou\n\t\t\t\tfor(int k=1;k<=26;k++){\n\t\t\t\t\tif(nm[j+1][i][num]==0 || nm[j+1][i][num]==k){\n\t\t\t\t\t\tfor(int l=0;l<k;l++) t[i][k] = (t[i][k] + t[j][l]*rec(j+1,i,num+1)%mod)%mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=26;i++) dp[L][R][num] = (dp[L][R][num]+t[R][i])%mod;\n\treturn dp[L][R][num];\n}\nint main(){\n\tcin >> n;\n\tfor(int i=1;i<=n;i++) cin >> s[i];\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i;j<=n;j++){\n\t\t\tfor(int k=1;k<=20;k++){\n\t\t\t\tfor(int x=i;x<=j;x++){\n\t\t\t\t\tif(s[x].size()>=k){\n\t\t\t\t\t\tif(s[x][k-1] != '?'){\n\t\t\t\t\t\t\tif(nm[i][j][k] == 0) nm[i][j][k] = 1 + (s[x][k-1]-'a');\n\t\t\t\t\t\t\telse if(nm[i][j][k] != 1 + (s[x][k-1]-'a')) nm[i][j][k] = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << rec(1,n,1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 55\n#define int long long\nusing namespace std;\nconst int s = ('a'-1);\nconst int mod = (1e9)+7;\nint n;\nstring str[N];\n\nint mem[N][N][22][30],used[N][N][22][30];\nint calc(int y,int x,int ch){\n  int res = 0;\n  if(x>=(int)str[y].size() || ch>=27) return 0;\n  \n  if(str[y][x] != '?') res = 1;\n  if(str[y][x] == '?') res = 27 - ch;\n  for(++x;x<(int)str[y].size();x++) if(str[y][x]=='?') res = (res*26)%mod;\n  return res;\n}\n\n\nbool check(int u,int d,int x,char ch){\n  for(int y=u;y<=d;y++) if(str[y][x]!='?' && str[y][x]!=ch) return 0;\n  return 1;\n}\n\nbool check2(int u,int d,int x,char ch){\n  for(int y=u;y<=d;y++) if(str[y][x] != '?' && str[y][x] <= ch) return 0;\n  return 1;\n\n}\n\nint dfs(int u,int d,int x,int c){\n  //cout<<u<<\" \"<<d<<\" \"<<x<<\" \"<<c<<endl;\n  if(u > d) return 1;\n  if(u == d) return calc(u,x,c);\n  if(x >= 21) return 0;\n  if(used[u][d][x][c]++) return mem[u][d][x][c];\n  int res = 0; \n\n\n\n  //[u,y]?????????????????????????????????????????????\n  for(int ch=c;ch<=26;ch++){\n    for(int y=u;y<=d;y++){\n      if(check(u,y,x,ch+s) == false)continue;\n      if(check2(y+1,d,x,ch+s) == false)continue;\n      res = (res+(dfs(u,y,x+1,1)*dfs(y+1,d,x,ch+1))%mod)%mod;\n    }\n  }\n  return mem[u][d][x][c] = res;\n}\n\n\nsigned main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>str[i];\n    while(str[i].size()<20) str[i]+=s;\n  }\n  cout<<dfs(0,n-1,0,1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nlong long n, res[22][55][55], power26[27], mod = 1000000007; string S[55];\n\nlong long solve(int pos, int l, int r) {\n\tif (l > r) return 1;\n\tif (res[pos][l][r] >= 1) return res[pos][l][r] - 1;\n\tif (pos == 20) return 1;\n\tlong long dp[28][55];\n\tfor (int i = l - 1; i <= r; i++) {\n\t\tfor (int j = 0; j < 28; j++) dp[j][i] = 0;\n\t}\n\tdp[0][l - 1] = 1;\n\tfor (int i = 0; i < 27; i++) {\n\t\tfor (int j = l - 1; j <= r; j++) {\n\t\t\tlong long P = 1;\n\t\t\tfor (int k = j; k <= r; k++) {\n\t\t\t\tif (pos == 19 && k - j >= 2) continue;\n\n\t\t\t\tif (k != j && S[k][pos] != (char)(95 + i + 1) && (i == 0 || S[k][pos] != '?')) P = 0;\n\t\t\t\tlong long Q = ((dp[i][j] * P) % mod)*solve(pos + 1, j + 1, k);\n\t\t\t\tdp[i + 1][k] += Q; dp[i + 1][k] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tres[pos][l][r] = dp[27][r] + 1;\n\treturn res[pos][l][r] - 1;\n}\n\nint main() {\n\tcin >> n;\n\tpower26[0] = 1; for (int i = 1; i < 21; i++) { power26[i] = (power26[i - 1] * 26LL) % mod; }\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> S[i];\n\t\twhile (S[i].size() <= 20) S[i] += (char)(96);\n\t}\n\tcout << solve(0, 1, n) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#define mod 1000000007\nusing namespace std;\nint n, dp[50][51][21]; string s[50];\ninline int solve(int l, int r, int k) {\n\tif(r - l == 1) {\n\t\tint ret = 1;\n\t\tfor(int i = k; i < s[l].size(); i++) {\n\t\t\tif(s[l][i] == '?') ret = 1LL * ret * 26 % mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tif(dp[l][r][k]) return dp[l][r][k] - 1;\n\tint dp2[51][27] = {0}; dp2[l][0] = 1;\n\tfor(int a = l + 1; a <= r; a++) {\n\t\tfor(int b = 1; b <= 26; b++) {\n\t\t\tfor(int c = a - 1; c >= l; c--) {\n\t\t\t\tbool flag1 = true, flag2 = true;\n\t\t\t\tfor(int d = c; d < a; d++) {\n\t\t\t\t\tif((s[d][k] != '?' && s[d][k] != b + 96) || (d != c && s[d].size() == k + 1)) {\n\t\t\t\t\t\tflag1 = false; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!flag1) continue;\n\t\t\t\tint res = flag2 ? solve(c, a, k + 1) : 1, r = 0;\n\t\t\t\tfor(int d = b - 1; d >= 0; d--) {\n\t\t\t\t\tdp2[a][b] = (dp2[a][b] + 1LL * dp2[c][d] * res) % mod;\n\t\t\t\t\tr = (r + 1LL * dp2[c][d] * res) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i = 1; i <= 26; i++) ret += dp2[r][i];\n\tdp[l][r][k] = ret + 1;\n\treturn ret;\n}\nint main() {\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) cin >> s[i];\n\tprintf(\"%d\\n\", solve(0, n, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#define mod 1000000007\nusing namespace std;\nint n, p[22], e[55][22], dp[55][55][22]; string s[55];\nint solve(int l, int r, int k) {\n\tif(r - l == 0) return 1;\n\tif(r - l == 1) return p[e[l][k]];\n\tif(dp[l][r][k]) return dp[l][r][k] - 1;\n\tint dp2[55][30] = {0}; dp2[l][0] = 1;\n\tfor(int a = l + 1; a <= r; a++) {\n\t\tint sum[55] = {0};\n\t\tfor(int b = 1; b <= 26; b++) {\n\t\t\tfor(int c = l; c < r; c++) sum[c] = (sum[c] + dp2[c][b - 1]) % mod;\n\t\t\tfor(int c = a - 1; c >= l; c--) {\n\t\t\t\tif((s[c][k] != '?' && s[c][k] != b + 96) || (c + 1 != a && s[c + 1].size() == k + 1)) break;\n\t\t\t\tint res = (s[c].size() == k + 1) ? solve(c + 1, a, k + 1) : solve(c, a, k + 1);\n\t\t\t\tdp2[a][b] = (dp2[a][b] + 1LL * sum[c] * res) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i = 1; i <= 26; i++) ret = (ret + dp2[r][i]) % mod;\n\tdp[l][r][k] = ret + 1;\n\treturn ret;\n}\nint main() {\n\tcin >> n; p[0] = 1;\n\tfor(int i = 1; i <= 20; i++) p[i] = 1LL * p[i - 1] * 26 % mod;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tfor(int j = s[i].size() - 1; j >= 0; j--) e[i][j] = e[i][j + 1] + (s[i][j] == '?' ? 1 : 0);\n\t}\n\tprintf(\"%d\\n\", solve(0, n, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 55\n#define int long long\nusing namespace std;\nconst int s = ('a'-1);\nconst int mod = (1e9)+7;\nint n;\nstring str[N];\n\nint mem[N][N][22][30],used[N][N][22][30];\nint calc(int y,int x,int ch){\n  int res = 0;\n  if(x>=(int)str[y].size() || ch>=27) return 0;\n  \n  if(str[y][x] != '?') res = 1;\n  if(str[y][x] == '?') res = 27 - ch;\n  for(++x;x<(int)str[y].size();x++) if(str[y][x]=='?') res = (res*26)%mod;\n  return res;\n}\n\n\nbool check(int u,int d,int x,char ch){\n  for(int y=u;y<=d;y++) if(str[y][x]!='?' && str[y][x]!=ch) return 0;\n  return 1;\n}\n\nbool check2(int u,int d,int x,char ch){\n  for(int y=u;y<=d;y++) if(str[y][x] != '?' && str[y][x] <= ch) return 0;\n  return 1;\n\n}\n\nint dfs(int u,int d,int x,int c){\n  //cout<<u<<\" \"<<d<<\" \"<<x<<\" \"<<c<<endl;\n  if(u > d) return 1;\n  if(u == d) return calc(u,x,c);\n  if(x >= 21) return 0;\n  if(used[u][d][x][c]++) return mem[u][d][x][c];\n  int res = 0; \n\n\n\n  //[u,y]?????????????????????????????????????????????\n  for(int ch=c;ch<=26;ch++){\n    for(int y=u;y<=d;y++){\n      if(check(u,y,x,ch+s) == false)continue;\n      if(check2(y+1,d,x,ch+s) == false)continue;\n      res = (res+(dfs(u,y,x+1,1)*dfs(y+1,d,x,ch+1))%mod)%mod;\n    }\n  }\n  return mem[u][d][x][c] = res;\n}\n\n\nsigned main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>str[i];\n    while(str[i].size()<21) str[i]+=s;\n  }\n  cout<<dfs(0,n-1,0,1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nint n;\nstring s[55];\nint c[55][25];\nllint memo[55][55][25][30];\n\nllint calc(int i, int j, int k, int l)\n{\n\t//cout << i << j << k << l << endl;\n\t\n\tif(i > j) return 1;\n\tif(l > 26) return 0;\n\tif(memo[i][j][k][l] != -1) return memo[i][j][k][l];\n\t\n\tif(l == 0){\n\t\tif(c[i][k] == 0){\n\t\t\tif(i+1 == j && c[i+1][k] == 0) return 0;\n\t\t\telse return memo[i][j][k][l] = calc(i+1, j, k, 0);\n\t\t}\n\t\telse return memo[i][j][k][l] = calc(i, j, k, 1);\n\t}\n\t\n\tllint ret = 0;\n\tret += calc(i, j, k, l+1);\n\tfor(int x = i; x <= j; x++){\n\t\tif(c[x][k] != -1){\n\t\t\tif(c[x][k] < l) return memo[i][j][k][l] = 0;\n\t\t\tif(c[x][k] > l) break;\n\t\t}\n\t\tif(x < j) ret += calc(i, x, k+1, 0) * calc(x+1, j, k, l+1) % mod;\n\t\telse ret += calc(i, j, k+1, 0) % mod;\n\t\tret %= mod;\n\t}\n\t//cout << i << j << k << l << \" \" << ret << endl;\n\treturn memo[i][j][k][l] = ret;\n}\n\nint main(void)\n{\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++) cin >> s[i];\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 0; j < s[i].size(); j++){\n\t\t\tif(s[i][j] == '?') c[i][j] = -1;\n\t\t\telse c[i][j] = s[i][j] - 'a' + 1;\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= 51; i++){\n\t\tfor(int j = 1; j <= 51; j++){\n\t\t\tfor(int k = 0; k < 25; k++){\n\t\t\t\tfor(int l = 0; l < 30; l++){\n\t\t\t\t\tmemo[i][j][k][l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << calc(1, n, 0, 0) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\n\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) {}\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n\nprivate:\n\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nMod memo[51][51][51][51];\n\nbool decide[51][51][51][51];\n\nvector<string>sts;\nMod getans(const int l, const int r,const int place, const int num) {\n\tif (decide[l][r][place][num]) {\n\t\treturn memo[l][r][place][num];\n\t}\n\telse {\n\t\tdecide[l][r][place][num] = true;\n\n\t\tif (l == r) {\n\t\t\treturn memo[l][r][place][num]=Mod(1);\n\t\t}\n\n\t\telse if (l + 1 == r) {\n\t\t\tMod ans(1);\n\t\t\tif (sts[l][place] == '?') {\n\t\t\t\tans *= min(26,26 - num+1);\n\t\t\t}\n\t\t\telse if (sts[l][place] < 'a' + num-1) {\n\t\t\t\treturn memo[l][r][place][num] = 0;\n\t\t\t}\n\t\t\tfor (int n = place+1; n < sts[0].size(); ++n) {\n\t\t\t\tif (sts[l][n] == '?') {\n\t\t\t\t\tans *= 26;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn memo[l][r][place][num] = ans;\n\t\t}\n\t\telse {\n\t\t\tfor (int n = l; n < r; ++n) {\n\t\t\t\tif (sts[n][place] >= 'a' + num - 1 || sts[n][place] == '?') {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn memo[l][r][place][num] = Mod(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMod ans(0);\n\t\t\tif (place == sts[0].size() - 1 && num == 26) {\n\t\t\t\treturn memo[l][r][place][num] = Mod(0);\n\t\t\t}else if (place == sts[0].size() - 1) {\n\t\t\t\tif (sts[l][place] == 'a' + num - 1 || num != 0 && sts[l][place] == '?') {\n\t\t\t\t\tans += getans(l + 1, r, place, num + 1);\n\t\t\t\t}\n\t\t\t\tans += getans(l, r, place, num + 1);\n\t\t\t\treturn memo[l][r][place][num] = ans;\n\t\t\t}\n\t\t\telse if (num == 26) {\n\t\t\t\treturn memo[l][r][place][num] = getans(l, r, place + 1, 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int k = l; k <= r; ++k) {\n\t\t\t\t\tbool ok = true;\n\t\t\t\t\tfor (int a = l; a < k; ++a) {\n\t\t\t\t\t\tif (sts[a][place] == 'a' + num - 1 || (num!=0&&sts[a][place] == '?')) {\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\n\t\t\t\t\t\tans += getans(l, k, place + 1, 0)*getans(k, r, place, num + 1);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn memo[l][r][place][num] = ans;\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tmemset(decide, false, sizeof(decide)); \n\tint n; cin >> n;\n\tsts.resize(n); \n\tfor (int i = 0; i < n; ++i) {\n\t\tstring st; cin >> st;\n\t\tint si = st.size();\n\t\tfor (int j = 0; j < 20 - si; ++j) {\n\t\t\tst.push_back('a' - 1);\n\t\t}\n\t\tsts[i] = st;\n\t}\n\tMod ans(getans(0, n, 0, 0));\n\tcout << ans << endl;\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint N;\nstring S[50];\nint dp[55][55][55][55];\n\nint rec(int top, int bottom, int col, int alpha)\n{\n  if(alpha >= 27 || col > 20) return (0);\n  if(top == bottom && col == 20) return (1);\n  if(~dp[top][bottom][col][alpha]) return(dp[top][bottom][col][alpha]);\n  int ret = rec(top, bottom, col, alpha + 1);\n  for(int i = top; i <= bottom; i++) {\n    if(S[i][col] == (alpha == 0 ? '~' : alpha - 1 + 'a') || (alpha && S[i][col] == '?')) {\n      (ret += 1LL * rec(top, i, col + 1, 0) * (i == bottom ? 1 : rec(i + 1, bottom, col, alpha + 1)) % mod) %= mod;\n    } else {\n      break;\n    }\n  }\n  return(dp[top][bottom][col][alpha] = ret);\n}\n\nint main()\n{\n  memset(dp, -1, sizeof(dp));\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    cin >> S[i];\n    while(S[i].size() < 20) S[i].push_back('~');\n  }\n  cout << rec(0, N - 1, 0, 0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#define mod 1000000007\nusing namespace std;\nint n, p[21], c[50][21], dp[50][51][21]; string s[50];\nint solve(int l, int r, int k) {\n\tif(r - l == 1) return p[c[l][k]];\n\tif(dp[l][r][k]) return dp[l][r][k] - 1;\n\tint dp2[51][27] = {0}; dp2[l][0] = 1;\n\tfor(int a = l + 1; a <= r; a++) {\n\t\tfor(int b = 1; b <= 26; b++) {\n\t\t\tfor(int c = a - 1; c >= l; c--) {\n\t\t\t\tbool flag1 = true, flag2 = true;\n\t\t\t\tfor(int d = c; d < a; d++) {\n\t\t\t\t\tif((s[d][k] != '?' && s[d][k] != b + 96) || (d != c && s[d].size() == k + 1)) {\n\t\t\t\t\t\tflag1 = false; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!flag1) break;\n\t\t\t\tint res = flag2 ? solve(c, a, k + 1) : 1, r = 0;\n\t\t\t\tfor(int d = b - 1; d >= 0; d--) {\n\t\t\t\t\tdp2[a][b] = (dp2[a][b] + 1LL * dp2[c][d] * res) % mod;\n\t\t\t\t\tr = (r + 1LL * dp2[c][d] * res) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i = 1; i <= 26; i++) ret += dp2[r][i];\n\tdp[l][r][k] = ret + 1;\n\treturn ret;\n}\nint main() {\n\tcin >> n; p[0] = 1;\n\tfor(int i = 1; i <= 20; i++) p[i] = 1LL * p[i - 1] * 26 % mod;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tfor(int j = s[i].size() - 1; j >= 0; j--) c[i][j] = c[i][j + 1] + (s[i][j] == '?' ? 1 : 0);\n\t}\n\tprintf(\"%d\\n\", solve(0, n, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint N;\nVS vs;\nint len[51][51];\nint dp[51][51][21][27][27];\nLL solve(int b, int e, int p, int lb, int ub){\n  int& ret = dp[b][e][p][lb][ub];\n  if(ret >= 0) return ret;\n  if(b == e) return ret = 1;\n  if(lb >= ub) return ret = 0;\n  if(b+1 == e){\n\tif(SZ(vs[b]) <= p) return ret = 1;\n\tLL res = 0;\n\tif(vs[b][p] == '?'){\n\t  res = ub - lb;\n\t}\n\telse{\n\t  int c = vs[b][p] - 'a';\n\t  if(!(lb <= c && c < ub))\n\t\treturn ret = 0;\n\t  res = 1;\n\t}\n\tfor(int i=p+1;i<SZ(vs[b]);++i)\n\t  if(vs[b][i] == '?')\n\t\t(res *= 26) %= MOD;\n\treturn ret = res;\n  }\n\n  ret = 0;\n  LL res = 0;\n  int c = -1;\n  for(int i=b;i<e;++i){\n\tif(SZ(vs[i]) <= p){\n\t  break;\n\t}\n\telse if(vs[i][p] != '?'){\n\t  int nc = vs[i][p] - 'a';\n\t  if(c < 0) c = nc;\n\t  else if(c != nc)\n\t\tc = 27;\n\t}\n\tif(c == 27)\n\t  break;\n\tif(c != -1){\n\t  if(lb <= c && c < ub)\n\t\t(res += solve(b, i+1, p+1, 0, 26) * solve(i+1, e, p, c+1, ub) % MOD) %= MOD;\n\t}\n\telse{\n\t  for(int c=lb;c<ub;++c){\n\t\t(res += solve(b, i+1, p+1, 0, 26) * solve(i+1, e, p, c+1, ub) % MOD) %= MOD;\n\t  }\n\t}\n  }\n  return ret = res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> N;\n  vs.resize(N);\n  REP(i,N) cin >> vs[i];\n  REP(i,N){\n\tlen[i][i+1] = SZ(vs[i]);\n\tFOR(j,i+1,N) len[i][j+1] = max(len[i][j], SZ(vs[j]));\n  }\n  fill((int*)dp, (int*)dp+51*51*21*27*27, -1);\n  cout << solve(0, N, 0, 0, 26) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define mod 1000000007\n#define rep(x, s, t) for(llint x = s; x <= t; x++)\n\nusing namespace std;\n\nllint n;\nstring s[55];\nllint memo[55][55][25][30];\n\nllint calc(llint l, llint r, llint k, llint c)\n{\n  //cout << l << ' ' << r << ' ' << k << ' ' << c << endl;\n  if(l > r) return 1;\n  if(c == 27) return 0;\n  if(memo[l][r][k][c] != -1) return memo[l][r][k][c];\n\n  if(c == 0){\n    bool flag = false;\n    rep(i, l, r){\n      if(s[i].size() >= k+1) flag = true;\n    }\n    if(!flag){\n      if(l == r) return memo[l][r][k][c] = 1;\n      else return memo[l][r][k][c] = 0;\n    }\n  }\n\n  llint ret = calc(l, r, k, c+1);\n  for(int i = l; i <= r; i++){\n    if(c == 0 && s[i].size() >= k+1) break;\n    if(c > 0 && s[i].size() <= k) break;\n    if(c > 0 && s[i][k] != '?' && s[i][k] != c-1+'a') break;\n    ret += calc(l, i, k+1, 0) * calc(i+1, r, k, c+1) % mod;\n    ret %= mod;\n  }\n  //cout << l << ' ' << r << ' ' << k << ' ' << c << ' '<< ret << endl;\n  return memo[l][r][k][c] = ret;\n}\n\nint main(void){\n  cin >> n;\n  rep(i, 1, n) cin >> s[i];\n\n  rep(i, 1, n){\n    rep(j, 1, n){\n      rep(k, 0, 25){\n        rep(l, 0, 26){\n          memo[i][j][k][l] = -1;\n        }\n      }\n    }\n  }\n\n  cout << calc(1, n, 0, 0) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n \nll mod=1000000007;\n \nll add(ll a,ll b){\n  return (a+b+mod+mod)%mod;\n}\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n \nll dp[51][51][21][27];\nint n;\nbool f[50][21];\nchar t[50][20];\n \nll rec(int ay,int by,int x,char ch){\n  \n\n\n  if(ay==by)return 1;\n\n  bool flag=true;\n  for(int i=ay;i<by;i++)\n    if(f[i][x]==true)\n      flag=false;\n\n\n  if(flag){\n    for(int i=ay+1;i<by;i++){\n      if(t[i-1][x-1] >= t[i][x-1])return 0;\n    }\n    return 1;\n  }\n\n  if(x==19){\n    \n  }\n\n \n \n  int CH=ch-'a';\n  if(dp[ay][by][x][CH]!=-1)return dp[ay][by][x][CH];\n \n\n  \n  if(f[ay][x]==false){\n    return rec(ay+1,by,x,ch);\n  }\n\n  if(ch>'z')return 0;\n\n  ll res=rec(ay,by,x,ch+1);\n \n \n  int next=ay;\n  for(int i=ay;i<by;i++){\n    if(t[i][x]==ch)next=i;\n  }\n   \n  for(int i=ay;i<next;i++){\n    if(t[i][x]!=ch&&t[i][x]!='?')\n      return 0;\n  }\n \n  for(int i=next;i<by;i++){\n    if(t[i][x]!='?'&&t[i][x]!=ch)break;\n    res=add(res, mul( rec(ay,i+1,x+1,'a') , rec(i+1,by,x,ch+1)) );\n  }\n\n\n  if(res>0){\n    //    cout<<ay<<' '<<by<<' '<<x<<' '<<CH<<endl;\n  }\n  return dp[ay][by][x][CH]=res;\n}\n \n \n \nint main(){\n  for(int i=0;i<51;i++)\n    for(int j=0;j<51;j++) \n      for(int k=0;k<21;k++)\n\tfor(int l=0;l<27;l++)\n\t  dp[i][j][k][l]=-1;\n   \n  for(int i=0;i<50;i++){\n    for(int j=0;j<20;j++){\n      t[i][j]='a';\n      f[i][j]=false;\n    }\n  }\n  string str;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>str;\n    for(int j=0;j<(int)str.size();j++){\n      t[i][j]=str[j];\n      f[i][j]=true;\n    }\n  }\n  //  cout<<rec(1,3,4,'e')<<'-'<<endl; \n  // cout<<rec(1,2,4,'e')<<'-'<<endl; \n\n  //cout<<rec(1,2,1,'a')<<'-'<<endl; \n  cout<<rec(0,n,0,'a')<<endl; \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nconst Int MOD = 1e9+7;\nInt n;\nstring s[55];\nInt dp[55][55][22][33];\nInt check(Int u,Int d,Int k,Int c){\n  for(Int i=u;i<d;i++)\n    if(!(s[i][k]=='?'||s[i][k]=='a'+c)) return 0;\n  return 1;\n}\n\nInt dfs(Int u,Int d,Int k,Int a){\n  Int &res=dp[u][d][k][a];\n  if(~res) return res;\n  res=0;\n  \n  if(u+1==d&&k==(Int)s[u].size())\n    return res=1;\n\n  if(k==(Int)s[u].size()&&k<(Int)s[u+1].size())\n    return res=dfs(u+1,d,k,0);\n\n  for(Int i=u;i<d;i++)\n    if(k>=(Int)s[i].size())\n      return res=0;\n\n  Int q=check(u,d,k,'?'-'a');\n  \n  for(Int c=a;c<26;c++)\n    if(q||check(u,d,k,c)){\n      (res+=dfs(u,d,k+1,0))%=MOD;\n      if(!q) break;\n    }\n\n  q=s[u][k]=='?';\n  for(Int i=u+1;i<d;i++){\n    for(Int c=a;c<26;c++){\n      if(q||check(u,i,k,c)){\n\t(res+=dfs(u,i,k+1,0)*dfs(i,d,k,c+1)%MOD)%=MOD;\n\tif(!q) break;\n      }  \n    }\n    q&=s[i][k]=='?';\n  }\n\n  //if(res) cout<<u<<\" \"<<d<<\" \"<<k<<\" \"<<a<<\":\"<<res<<endl;\n  return res;\n}\n\nsigned main(){\n  cin>>n;\n  for(Int i=0;i<n;i++) cin>>s[i];\n  memset(dp,-1,sizeof(dp));\n  cout<<dfs(0,n,0,0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nusing ll=long long;\n\nconst ll mod=1000000007LL;\n\ninline ll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\ninline ll ADD(const ll &a, const ll &b,const ll &mod) { return a+b<mod?a+b:a+b-mod;}\ninline ll SUB(const ll &a, const ll &b,const ll &mod) { return a-b>=0?a-b:a-b+mod;}\ninline ll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\ninline ll INV(ll a,ll mod){ll x,y;extgcd(a,mod,x,y);return (x%mod+mod)%mod;}\ninline ll DIV(const ll &a, const ll &b,const ll &mod) {return MUL(a,INV(b,mod),mod);}\ninline ll POW(ll a,ll n,ll mod){ll b=1LL;for(a%=mod;n;a=MUL(a,a,mod),n>>=1)if(n&1) b=MUL(b,a,mod); return b;}\n\nconst char base='a'-1;\n\nll memo[64][64][32][32];\nstring s[55];\n\nll rec(ll l,ll r,ll p,ll c){\n\tll &ret=memo[l][r][p][c];\n\tif(ret>=0) return ret;\n\tif(l>=r) return ret=1LL;\n\t\n\tret=0LL;\n\tif(c==27) return ret=0;  \n\tif(p==20) return ret=(r-l)==1;\n\n\tfor(ll i=l;i<=r;++i){\n\t\tif(i!=l && ((s[i-1][p]!=base+c && s[i-1][p]!='?')||(s[i-1][p]=='?' && c==0)))  break;\n\t\tret=ADD(ret,MUL(rec(l,i,p+1,0),rec(i,r,p,c+1),mod),mod);\n\t}\n\treturn ret;\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\n\trep(i,n){\n\t\tcin >> s[i];\n\t\twhile(int(s[i].size())<20) s[i]+=base;\n\t\t//cout << s[i].size() << endl;\n\t}\n\n\tclr(memo,-1);\n\tcout << rec(0,n,0,0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\n\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) {}\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n\nprivate:\n\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nMod memo[51][51][51][51];\n\nbool decide[51][51][51][51];\n\nvector<string>sts;\nMod getans(const int l, const int r,const int place, const int num) {\n\tif (decide[l][r][place][num]) {\n\t\treturn memo[l][r][place][num];\n\t}\n\telse {\n\t\tdecide[l][r][place][num] = true;\n\n\t\tif (l == r) {\n\t\t\treturn memo[l][r][place][num]=Mod(1);\n\t\t}\n\t\telse {\n\t\t\tfor (int n = l; n < r; ++n) {\n\t\t\t\tif (sts[n][place] >= 'a' + num - 1 || sts[n][place] == '?') {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn memo[l][r][place][num] = Mod(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMod ans(0);\n\t\t\tif (place == sts[0].size() - 1 && num == 26) {\n\t\t\t\treturn memo[l][r][place][num] = Mod(0);\n\t\t\t}else if (place == sts[0].size() - 1) {\n\t\t\t\tif (sts[l][place] == 'a' + num - 1 || num != 0 && sts[l][place] == '?') {\n\t\t\t\t\tans += getans(l + 1, r, place, num + 1);\n\t\t\t\t}\n\t\t\t\tans += getans(l, r, place, num + 1);\n\t\t\t\treturn memo[l][r][place][num] = ans;\n\t\t\t}\n\t\t\telse if (num == 26) {\n\t\t\t\treturn memo[l][r][place][num] = getans(l, r, place + 1, 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int k = l; k <= r; ++k) {\n\t\t\t\t\tbool ok = true;\n\t\t\t\t\tfor (int a = l; a < k; ++a) {\n\t\t\t\t\t\tif (sts[a][place] == 'a' + num - 1 || (num!=0&&sts[a][place] == '?')) {\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\n\t\t\t\t\t\tans += getans(l, k, place + 1, 0)*getans(k, r, place, num + 1);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn memo[l][r][place][num] = ans;\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tmemset(decide, false, sizeof(decide)); \n\tint n; cin >> n;\n\tsts.resize(n); \n\tfor (int i = 0; i < n; ++i) {\n\t\tstring st; cin >> st;\n\t\tint si = st.size();\n\t\tfor (int j = 0; j < 20 - si; ++j) {\n\t\t\tst.push_back('a' - 1);\n\t\t}\n\t\tsts[i] = st;\n\t}\n\tMod ans(getans(0, n, 0, 0));\n\tcout << ans << endl;\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nint N;\nll dp[51][51][21][28];\nchar table[50][21];\nchar base = 'a'-1;\n\nll recursive(int left,int right,int loc,int ch){\n\n\tif(dp[left][right][loc][ch] != -1)return dp[left][right][loc][ch];\n\n\tif(left >= right)return 1;\n\n\tif(ch == 27){\n\n\t\treturn 0;\n\n\t}else if(loc == 20){\n\n\t\tif(left+1 == right){\n\t\t\treturn dp[left][right][loc][ch] = 1;\n\t\t}else{\n\t\t\treturn dp[left][right][loc][ch] = 0;\n\t\t}\n\t}\n\n\tll ret = 0;\n\tll tmp;\n\n\tfor(int mid = left; mid <= right; mid++){\n\n\t\tif((mid != left) && ((table[mid-1][loc] != base+ch && table[mid-1][loc] != '?') ||\n\t\t\t\t(table[mid-1][loc] == '?' && ch == 0)))break;\n\n\t\ttmp = recursive(left,mid,loc+1,0)*recursive(mid,right,loc,ch+1);\n\n\t\ttmp %= MOD;\n\t\tret += tmp;\n\t\tret %= MOD;\n\t}\n\n\treturn dp[left][right][loc][ch] = ret;\n}\n\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tint length;\n\n\tfor(int loop = 0; loop < N; loop++){\n\n\t\tscanf(\"%s\",table[loop]);\n\t\tfor(length = 0; table[loop][length] != '\\0'; length++);\n\n\t\tfor(int k = length; k < 20; k++){\n\t\t\ttable[loop][k] = base;\n\t\t}\n\t}\n\n\tfor(int i = 0; i <= N; i++){\n\t\tfor(int k = 0; k <= N; k++){\n\t\t\tfor(int a = 0; a < 21; a++){\n\t\t\t\tfor(int b = 0; b < 28; b++){\n\t\t\t\t\tdp[i][k][a][b] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,N,0,0));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nusing ll = long long int;\nconst ll MOD = 1000000007;\nconst int LEN = 20;\n\n// [l, r)  pos  v \nll N, dp[55][55][30][30];\nchar dict[55][30];\nchar base = (char)('a' - 1);\n\nll solve(int l, int r, int pos, int v) {\n    ll &res = dp[l][r][pos][v];\n    if(res >= 0) return res;\n    char target = (char)(base + v);\n\n    if(l == r) return res = 1;\n    if(v == 27) return res = 0;\n    if(pos == LEN) return res = (r - l == 1);\n\n    res = 0;\n    for(int k=l; k<=r; k++) {\n        if(k > l) {\n            if(dict[k-1][pos] != target and dict[k-1][pos] != '?') break;\n            if(v == 0 and dict[k-1][pos] == '?') break;\n        }\n        \n        // [l, r) -> [l, k), [k, r)\n        ll valL = solve(l, k, pos+1, 0);\n        ll valR = solve(k, r, pos, v+1);\n        (res += valL * valR) %= MOD;\n    }\n    return res;\n}\n\nint main() {\n    cin >> N;\n    for(int i=0; i<N; i++) {\n        scanf(\"%s\", dict[i]);\n        for(int j=strlen(dict[i]); j<LEN; j++) dict[i][j] = base;\n    }\n\n    fill(dp[0][0][0], dp[N+1][0][0], -1);\n    cout << solve(0, N, 0, 0) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nint n;\nstring s[55];\nint c[55][25];\nllint memo[55][55][25][30];\n\nllint calc(int i, int j, int k, int l)\n{\n\t//cout << i << j << k << l << endl;\n\t\n\tif(memo[i][j][k][l] != -1) return memo[i][j][k][l];\n\tif(i > j) return 1;\n\tif(l > 26) return 0;\n\tif(k > 20) return 0;\n\t\n\tif(l == 0){\n\t\tif(c[i][k] == 0){\n\t\t\tif(i+1 == j && c[i+1][k] == 0) return 0;\n\t\t\telse return memo[i][j][k][l] = calc(i+1, j, k, 0);\n\t\t}\n\t\telse return memo[i][j][k][l] = calc(i, j, k, 1);\n\t}\n\t\n\tllint ret = 0;\n\tret += calc(i, j, k, l+1);\n\tfor(int x = i; x <= j; x++){\n\t\tif(c[x][k] != -1){\n\t\t\tif(c[x][k] < l) return memo[i][j][k][l] = 0;\n\t\t\tif(c[x][k] > l) break;\n\t\t}\n\t\tif(x < j) ret += calc(i, x, k+1, 0) * calc(x+1, j, k, l+1) % mod;\n\t\telse ret += calc(i, j, k+1, 0) % mod;\n\t\tret %= mod;\n\t}\n\t//cout << i << j << k << l << \" \" << ret << endl;\n\treturn memo[i][j][k][l] = ret;\n}\n\nint main(void)\n{\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++) cin >> s[i];\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 0; j < s[i].size(); j++){\n\t\t\tif(s[i][j] == '?') c[i][j] = -1;\n\t\t\telse c[i][j] = s[i][j] - 'a' + 1;\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= 50; i++){\n\t\tfor(int j = 1; j <= 50; j++){\n\t\t\tfor(int k = 0; k < 25; k++){\n\t\t\t\tfor(int l = 0; l < 30; l++){\n\t\t\t\t\tmemo[i][j][k][l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << calc(1, n, 0, 0) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint N;\nstring s[55];\nll dp[55][55][23][30];\nconst char e='a'-1;\n\nll dfs(int l,int r,int i,int c){\n  if(l>=r)return 1;\n  if(i==20)return l+1==r?1:0;\n  if(dp[l][r][i][c]!=-1)return dp[l][r][i][c];\n\n  ll res=0;\n  if(c==26){\n    bool ok=true;\n    repl(j,l,r){\n      if(s[j][i]!='?'&&s[j][i]!=e+c)ok=false;\n    }\n    if(ok)res=dfs(l,r,i+1,0);\n  }else if(c!=0){\n    res=dfs(l,r,i,c+1);\n    repl(j,l,r){\n      if(s[j][i]!='?'&&s[j][i]!=e+c)break;\n      ll vl=dfs(l,j+1,i+1,0);\n      ll vr=dfs(j+1,r,i,c+1);\n      (res+=vl*vr%mod)%=mod;\n    }\n  }else{\n    res=dfs(l,r,i,c+1);\n    repl(j,l,r){\n      if(s[j][i]!=e+c)break;\n      ll vl=dfs(l,j+1,i+1,0);\n      ll vr=dfs(j+1,r,i,c+1);\n      (res+=vl*vr%mod)%=mod;\n    }\n  }\n  return dp[l][r][i][c]=res;\n}\n\nint main(){\n  cin>>N;\n  rep(i,N){\n    cin>>s[i];\n    while(s[i].size()<21)s[i]+=e;\n  }\n  memset(dp,-1,sizeof(dp));\n  cout<<dfs(0,N,0,0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nconst Int MOD = 1e9+7;\nInt n;\nstring s[55];\nInt dp[55][55][22][33];\nInt check(Int u,Int d,Int k,Int c){\n  Int flg=1;\n  for(Int i=u;i<d;i++)\n    flg&=(k<(Int)s[i].size()&&(s[i][k]=='?'||s[i][k]=='a'+c));\n  return flg;\n}\n\nInt dfs(Int u,Int d,Int k,Int a){\n  Int &res=dp[u][d][k][a];\n  if(~res) return res;\n  res=0;\n  \n  if(u+1==d&&k==(Int)s[u].size())\n    return res=1;\n\n  if(k==(Int)s[u].size()&&k<(Int)s[u+1].size())\n    return res=dfs(u+1,d,k,0);\n\n  for(int i=u;i<d;i++)\n    if(k>=(Int)s[i].size())\n      return res=0;\n  \n  for(Int c=a;c<26;c++)\n    if(check(u,d,k,c)) (res+=dfs(u,d,k+1,0))%=MOD;\n  \n  for(Int i=u+1;i<d;i++)\n    for(Int c=a;c<26;c++)\n      if(check(u,i,k,c))\n\t (res+=dfs(u,i,k+1,0)*dfs(i,d,k,c+1)%MOD)%=MOD;\n\n  //if(res) cout<<u<<\" \"<<d<<\" \"<<k<<\" \"<<a<<\":\"<<res<<endl;\n  return res;\n}\n\nsigned main(){\n  cin>>n;\n  for(Int i=0;i<n;i++) cin>>s[i];\n  memset(dp,-1,sizeof(dp));\n  cout<<dfs(0,n,0,0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint dp[21][51][51];\n\nint main() {\n\tint n; cin >> n;\n\tvector<string> s(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tfor (; s[i].length() < 20; s[i].push_back('`'));\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tdp[20][i][i + 1] = 1;\n\tfor (int j = 19; j >= 0; j--) {\n\t\tfor (int l = 0; l <= n; l++) {\n\t\t\tvector<vector<int> > a(n + 1, vector<int>(28));\n\t\t\ta[l][0] = 1;\n\t\t\tfor (int i = l; i <= n; i++)\n\t\t\t\tfor (int k = 0; k < 27; k++) {\n\t\t\t\t\ta[i][k + 1] = (a[i][k + 1] + a[i][k]) % MOD;\n\t\t\t\t\tfor (int _i = i; _i < n; _i++) {\n\t\t\t\t\t\tchar c = s[_i][j];\n\t\t\t\t\t\tif (c == '`' + k || (k && c == '?'));\n\t\t\t\t\t\telse break;\n\t\t\t\t\t\ta[_i + 1][k + 1] = (a[_i + 1][k + 1] + (ll)a[i][k] * dp[j + 1][i][_i + 1]) % MOD;\n\t\t\t\t\t\tdp[j][l][_i + 1] = (dp[j][l][_i + 1] + (ll)a[i][k] * dp[j + 1][i][_i + 1]) % MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][0][n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define MOD (1000000007LL)\n\nint N;\nstring S[51];\n\nll dp[52][52][22][30];\n\nll solve(int up,int down,int id,int c){\n\n  ll &ret = dp[up][down][id][c];\n  if( ret != -1 ) return ret;\n  ret = 0;\n\n  if( up > down ) return ret = 1LL;\n  if( c > 26 ) return ret = 0LL;\n  if( up == down && id == S[up].size() ) return ret = 1LL;\n\n  char ch = c + 'a' - 1;\n  if( S[up][id] != '?' && S[up][id] != ch) {\n    if( S[up][id] < ch ) return ret = 0LL;\n    return ret = solve(up,down,id,c+1);\n  } else if( S[up][id] == '?' ) {\n    ch = max( 'a', ch );\n    ret = solve(up,down,id,max(2,c+1));\n  }\n  /*\n  if( up == down ){\n    return ret = (solve(up,down,id+1,0) * (S[up][id] == '?'?26LL:1LL)) % MOD;\n  }\n  */\n  int ci = ch - 'a' + 1;\n\n  int cnt = up;\n  for(int i=up;i<=down;i++){\n    if( S[i][id] == ch ) cnt = i;\n  }\n  if( (int)S[up].size() == id+1 ){\n    if( cnt != up ) return ret = 0LL;\n    ret += ( solve( up + 1, down, id, ci + 1 ) * solve(up,up,id+1,0) ) % MOD;\n    ret %= MOD;\n  } else {\n    for(int i=cnt;i<=down;i++){\n      if( S[i][id] == '?' || S[i][id] == ch ){\n        ret += ( solve(i+1,down,id,ci + 1) * solve(up,i,id+1,0) ) % MOD;\n        ret %= MOD;\n      } else \n        break;\n    }\n  }\n\n  //  cout << up << \" \" << down << \" \" << id << \" \"<< c << \" ( \" << ch << \" ) \"  << S[up][id] << endl;  \n  //    cout << ret << endl;\n  return ret;\n}\n\nint main(){\n  memset(dp,-1,sizeof(dp));\n  cin >> N;\n  int lenmax = 0;\n  for(int i=0;i<N;i++){\n    cin >> S[i];\n    lenmax = max( lenmax, (int)S[i].size() );\n  }\n  for(int i=0;i<N;i++){\n    while( (int)S[i].size() < lenmax ){    \n      char c = 'a' - 1;\n      S[i] += c;\n    }\n  }\n  cout << solve(0,N-1,0,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\n \nconstexpr ll M = 1e9+7;\n \nint n;\nint dp[51][51][21][28];\nstring s[51];\n \nint rec(int l, int r, int p, int c) {\n    int& res = dp[l][r][p][c];\n    if(res != -1) {\n        return res;\n    }\n    if(l >= r) {\n        return res = 1;\n    }\n    if(c == 27) {\n        return res = 0;\n    }\n    if(p == s[l].size()) {\n        return res = (l + 1 == r);\n    }\n    res = 0;\n \n    char cc = 'a' - 1 + c;\n    for(int i = l; i <= r; ++i) {\n        (res += 1LL * rec(l, i, p + 1, 0) * rec(i, r, p, c + 1) % M) %= M;\n        if(i != r && s[i][p] != '?' && s[i][p] != cc) {\n            break;\n        }\n        if(i != r && s[i][p] == '?' && c == 0) {\n            break;\n        }\n    }\n    return res;\n}\n \nint main() {\n    cin >> n;\n    int max_len = 0;\n    for(int i = 0; i < n; ++i) {\n        cin >> s[i];\n        max_len = max(max_len, (int)s[i].size());\n    }\n    for(int i = 0; i < n; ++i) {\n        s[i] = s[i] + string(max_len - s[i].size(), 'a' - 1);\n    }\n    fill(dp[0][0][0], dp[51][0][0], -1);\n    cout << rec(0, n, 0, 0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint N;\nVS vs;\nLL dp[51][51][21][27][27];\nLL solve(int b, int e, int p, int lb, int ub){\n  LL& res = dp[b][e][p][lb][ub];\n  if(res >= 0) return res;\n  if(b == e) return res = 1;\n  if(lb >= ub) return res = 0;\n  if(b+1 == e){\n\tif(vs[b][p] == '?'){\n\t  res = ub - lb;\n\t}\n\telse{\n\t  int c = vs[b][p] - 'a';\n\t  if(!(lb <= c && c < ub))\n\t\treturn res = 0;\n\t  res = 1;\n\t}\n\tfor(int i=p+1;i<SZ(vs[b]);++i)\n\t  if(vs[b][i] == '?')\n\t\t(res *= 26) %= MOD;\n\treturn res;\n  }\n\n  res = 0;\n  for(int i=b+1;i<=e;++i){\n\tint c = -1;\n\tfor(int j=b;j<i;++j)\n\t  if(SZ(vs[j]) <= p){\n\t\tc = 27;\n\t\tbreak;\n\t  }\n\t  else if(vs[j][p] != '?'){\n\t\tint nc = vs[j][p] - 'a';\n\t\tif(c < 0) c = nc;\n\t\telse if(c != nc)\n\t\t  c = 27;\n\t  }\n\tif(c == 27)\n\t  break;\n\tif(c != -1){\n\t  if(lb <= c && c < ub)\n\t\t(res += solve(b, i, p+1, 0, 26) * solve(i, e, p, c+1, ub) % MOD) %= MOD;\n\t}\n\telse{\n\t  for(int c=lb;c<ub;++c){\n\t\t(res += solve(b, i, p+1, 0, 26) * solve(i, e, p, c+1, ub) % MOD) %= MOD;\n\t  }\n\t}\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> N;\n  vs.resize(N);\n  REP(i,N) cin >> vs[i];\n  fill((LL*)dp, (LL*)dp+51*51*21*27*27, -1);\n  cout << solve(0, N, 0, 0, 26) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MOD 1000000007LL\ntypedef long long ll;\n\nint n;\nll dp[21][51][51][28];\nstring str[51];\n\nll solve(int v,int f,int t,int lb){\n\tif(dp[v][f][t][lb]!=-1)return dp[v][f][t][lb];\n\tif(f==t)return 1;\n\tif(str[f].size()==v){\n\t\tif(lb==0){\n\t\t\treturn solve(v,f+1,t,lb+1);\n\t\t}\n\t\telse return 0;\n\t}\n\tfor(int i=f+1;i<t;i++){\n\t\tif(str[i].size()==v)return 0;\n\t}\n\tll ans=0;\n\tfor(int i=max(lb,1);i<27;i++){\n\t\tfor(int j=f;j<t;j++){\n\t\t\tbool flag=true;\n\t\t\tfor(int k=f;k<=j;k++){\n\t\t\t\tif(str[k][v]!='?' && (str[k][v]-'a')!=(i-1)){\n\t\t\t\t\tflag=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tans+=solve(v+1,f,j+1,0)*solve(v,j+1,t,i+1)%MOD;\n\t\t\t\tans%=MOD;\n\t\t\t}\n\t\t}\n\t}\n\tdp[v][f][t][lb]=ans;\n\treturn ans;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tcin >> str[i];\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tprintf(\"%lld\\n\",solve(0,0,n,0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define MOD (1000000007LL)\n\nint N;\nstring S[51];\n\nll dp[52][52][22][30];\n\nll solve(int up,int down,int id,int c){\n\n  ll &ret = dp[up][down][id][c];\n  if( ret != -1 ) return ret;\n  if( up > down ) return ret = 1LL;\n  if( c > 26 ) return ret = 0LL;\n  if( id == (int)S[up].size() ) {\n    if( up == down) return ret = 1LL;\n    return ret = 0LL;\n  }\n\n  char ch = c + 'a' - 1;\n  ret = solve(up,down,id,c+1);\n\n  for(int i=up;i<=down;i++){\n    if( S[i][id] != ch && S[i][id] != '?' ) break;\n    if( S[i][id] == '?' && c == 0 ) break;\n    ret += ( solve(i+1,down,id,c + 1) * solve(up,i,id+1,0) ) % MOD;\n    ret %= MOD;    \n  }\n\n  //  cout << up << \" \" << down << \" \" << id << \" \"<< c << \" ( \" << ch << \" ) \"  << S[up][id] << endl;  \n  //    cout << ret << endl;\n  return ret;\n}\n\nint main(){\n  memset(dp,-1,sizeof(dp));\n  cin >> N;\n  int lenmax = 0;\n  for(int i=0;i<N;i++){\n    cin >> S[i];\n    lenmax = max( lenmax, (int)S[i].size() );\n  }\n  for(int i=0;i<N;i++){\n    while( (int)S[i].size() < lenmax ){    \n      char c = 'a' - 1;\n      S[i] += c;\n    }\n    // cout << S[i] << endl;\n  }\n  cout << solve(0,N-1,0,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#define mod 1000000007\nusing namespace std;\nint n, p[21], c[50][21], dp[50][51][21]; string s[50];\nint solve(int l, int r, int k) {\n\tif(r - l == 1) return p[c[l][k]];\n\tif(dp[l][r][k]) return dp[l][r][k] - 1;\n\tint dp2[51][27] = {0}; dp2[l][0] = 1;\n\tfor(int a = l + 1; a <= r; a++) {\n\t\tfor(int b = 1; b <= 26; b++) {\n\t\t\tfor(int c = a - 1; c >= l; c--) {\n\t\t\t\tif((s[c][k] != '?' && s[c][k] != b + 96) || (c + 1 != a && s[c].size() == k + 1)) break;\n\t\t\t\tint res = solve(c, a, k + 1);\n\t\t\t\tfor(int d = b - 1; d >= 0; d--) {\n\t\t\t\t\tdp2[a][b] = (dp2[a][b] + 1LL * dp2[c][d] * res) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i = 1; i <= 26; i++) ret += dp2[r][i];\n\tdp[l][r][k] = ret + 1;\n\treturn ret;\n}\nint main() {\n\tcin >> n; p[0] = 1;\n\tfor(int i = 1; i <= 20; i++) p[i] = 1LL * p[i - 1] * 26 % mod;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tfor(int j = s[i].size() - 1; j >= 0; j--) c[i][j] = c[i][j + 1] + (s[i][j] == '?' ? 1 : 0);\n\t}\n\tprintf(\"%d\\n\", solve(0, n, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n#define mod 1000000007\nint n; string s[55];\nll dp[55][55][25]; bool u[55][55][25];\nll rec(int L,int R,int num){\n\tif(u[L][R][num]) return dp[L][R][num];\n\tu[L][R][num] = 1;\n\tif(L==R){\n\t      dp[L][R][num] = 1;\n\t      for(int j=num-1;j<s[L].size();j++) if(s[L][j]=='?') dp[L][R][num] = (dp[L][R][num]*26LL)%mod;\n\t      return dp[L][R][num];\n    }\n\tint cnt = 0;\n\tfor(int i=L;i<=R;i++){\n\t\tif(s[i].size() < num){\n\t\t\tif(i != L || cnt) return dp[L][R][num] = 0;\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif(cnt){\n\t\tif(cnt == R-L+1){\n\t\t\treturn dp[L][R][num] = 1;\n\t\t}\n\t\telse return dp[L][R][num] = rec(L+cnt,R,num);\n\t}\n\tll t[55][30] = {};\n\tt[L-1][0] = 1;\n\tfor(int i=L;i<=R;i++){\n\t\tfor(int j=L-1;j<i;j++){\n\t\t\tfor(int k=1;k<=26;k++){\n\t\t\t\t//dp[j+1][i][num+1] wo kentou\n\t\t\t\tfor(int x=j+1;x<=i;x++){\n\t\t\t\t\tif(s[x][num-1] != '?' && s[x][num-1] != 'a'+(k-1)) goto bad;\n\t\t\t\t}\n\t\t\t\tfor(int l=0;l<k;l++) t[i][k] = (t[i][k] + t[j][l]*rec(j+1,i,num+1)%mod)%mod;\n\t\t\t\tbad:;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=26;i++) dp[L][R][num] = (dp[L][R][num]+t[R][i])%mod;\n\treturn dp[L][R][num];\n}\nint main(){\n\tcin >> n;\n\tfor(int i=1;i<=n;i++) cin >> s[i];\n\tcout << rec(1,n,1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define MOD (1000000007LL)\n\nint N;\nstring S[51];\n\nll dp[52][52][22][30];\n\nll solve(int up,int down,int id,int c){\n\n  ll &ret = dp[up][down][id][c];\n  if( ret != -1 ) return ret;\n  ret = 0;\n\n  if( up > down ) return ret = 1LL;\n  if( c >= 27 ) return ret = 0LL;\n\n  if( up == down && id == S[up].size() ) return ret = 1LL;\n\n  char ch = c + 'a' - 1;\n  if( S[up][id] != '?' ) {\n    if( S[up][id] < ch ) return ret = 0;\n    ch = S[up][id]; \n  } else {\n    ch = max( 'a', ch );\n    ret = solve(up,down,id,max(2,c+1));\n  }\n  /*\n  if( up == down ){\n    return ret = (solve(up,down,id+1,0) * (S[up][id] == '?'?26LL:1LL)) % MOD;\n  }\n  */\n  int ci = ch - 'a' + 1;\n\n  int cnt = up;\n  for(int i=up;i<=down;i++){\n    if( S[i][id] == ch ) cnt = i;\n  }\n  if( (int)S[up].size() == id && cnt != up ) return ret = 0LL;\n\n  for(int i=cnt;i<=down;i++){\n    if( S[i][id] == '?' || S[i][id] == ch ){\n      ret += ( solve(i+1,down,id,ci + 1) * solve(up,i,id+1,0) ) % MOD;\n      ret %= MOD;\n    } else \n      break;\n  }\n\n  // cout << up << \" \" << down << \" \" << id << \" \"<< c << \" ( \" << ch << \" ) \"  << S[up][id] << endl;  \n  //cout << ret << endl;\n  return ret;\n}\n\nint main(){\n  memset(dp,-1,sizeof(dp));\n  cin >> N;\n  int lenmax = 0;\n  for(int i=0;i<N;i++){\n    cin >> S[i];\n    lenmax = max( lenmax, (int)S[i].size() );\n  }\n  for(int i=0;i<N;i++){\n    while( (int)S[i].size() < lenmax ){    \n      char c = 'a' - 1;\n      S[i] += c;\n    }\n  }\n  cout << solve(0,N-1,0,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#define mod 1000000007\nusing namespace std;\nint n, p[21], c[50][21], dp[50][51][21]; string s[50];\nint solve(int l, int r, int k) {\n\tif(r - l == 1) return p[c[l][k]];\n\tif(dp[l][r][k]) return dp[l][r][k] - 1;\n\tint dp2[51][27] = {0}; dp2[l][0] = 1;\n\tfor(int a = l + 1; a <= r; a++) {\n\t\tfor(int b = 1; b <= 26; b++) {\n\t\t\tfor(int c = a - 1; c >= l; c--) {\n\t\t\t\tif((s[c][k] != '?' && s[c][k] != b + 96) || (c + 1 != a && s[c].size() == k + 1)) break;\n\t\t\t\tint res = solve(c, a, k + 1), r = 1;\n\t\t\t\tfor(int d = b - 1; d >= 0; d--) r = (r + dp2[c][d]) % mod;\n\t\t\t\tdp2[a][b] = 1LL * res * r % mod;\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i = 1; i <= 26; i++) ret += dp2[r][i];\n\tdp[l][r][k] = ret + 1;\n\treturn ret;\n}\nint main() {\n\tcin >> n; p[0] = 1;\n\tfor(int i = 1; i <= 20; i++) p[i] = 1LL * p[i - 1] * 26 % mod;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tfor(int j = s[i].size() - 1; j >= 0; j--) c[i][j] = c[i][j + 1] + (s[i][j] == '?' ? 1 : 0);\n\t}\n\tprintf(\"%d\\n\", solve(0, n, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\n\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) {}\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n\nprivate:\n\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nMod memo[21][21][51][51];\n\nbool decide[21][21][51][51];\n\nvector<string>sts;\nMod getans(const int l, const int r,const int place, const int num) {\n\tif (decide[l][r][place][num]) {\n\t\treturn memo[l][r][place][num];\n\t}\n\telse {\n\t\tdecide[l][r][place][num] = true;\n\n\t\tif (l == r) {\n\t\t\treturn memo[l][r][place][num]=Mod(1);\n\t\t}\n\n\t\telse if (l + 1 == r) {\n\t\t\tMod ans(1);\n\t\t\tif (sts[l][place] == '?') {\n\t\t\t\tans *= 26 - num;\n\t\t\t}\n\t\t\telse if (sts[l][place] < 'a' + num) {\n\t\t\t\treturn memo[l][r][place][num] = 0;\n\t\t\t}\n\t\t\tfor (int n = place+1; n < sts[0].size(); ++n) {\n\t\t\t\tif (sts[l][n] == '?') {\n\t\t\t\t\tans *= 26;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn memo[l][r][place][num] = ans;\n\t\t}\n\t\telse {\n\t\t\tfor (int n = l; n < r; ++n) {\n\t\t\t\tif (sts[n][place] >= 'a' + num || sts[n][place] == '?') {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn memo[l][r][place][num] = Mod(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMod ans(0);\n\t\t\tif (place == sts[0].size() - 1 && num == 25) {\n\t\t\t\treturn memo[l][r][place][num] = Mod(0);\n\t\t\t}else if (place == sts[0].size() - 1) {\n\t\t\t\tif (sts[l][place] == 'a' + num || sts[l][place] == '?') {\n\t\t\t\t\tans += getans(l + 1, r, place, num + 1);\n\t\t\t\t}\n\t\t\t\tans += getans(l, r, place, num + 1);\n\t\t\t\treturn memo[l][r][place][num] = ans;\n\t\t\t}\n\t\t\telse if (num == 25) {\n\t\t\t\treturn memo[l][r][place][num] = getans(l, r, place + 1, 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int k = l; k <= r; ++k) {\n\t\t\t\t\tbool ok = true;\n\t\t\t\t\tfor (int a = l; a < k; ++a) {\n\t\t\t\t\t\tif (sts[a][place] == 'a' + num || sts[a][place] == '?') {\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\n\t\t\t\t\t\tans += getans(l, k, place + 1, 0)*getans(k, r, place, num + 1);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn memo[l][r][place][num] = ans;\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tmemset(decide, false, sizeof(decide)); \n\tint n; cin >> n;\n\tsts.resize(n); \n\tfor (int i = 0; i < n; ++i) {\n\t\tstring st; cin >> st;\n\t\tsts[i] = st;\n\t}\n\tMod ans(getans(0, n, 0, 0));\n\tcout << ans << endl;\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst ll mod = 1e9+7;\n\nconst char b = 'a'-1;\n\nint n;\nstring s[50];\n\nll dp[25][51][51][27];\nll dfs(int d, int l, int r, int a){\n    bool all_blank = true;\n    for(int i=l; i<r; ++i)if(s[i][d]!=b) all_blank = false;\n    if(all_blank) return r-l<=1;\n\n    if(a == 27) return l==r;\n    if(l==r) return 1;\n    if(dp[d][l][r][a]>=0) return dp[d][l][r][a];\n\n    int cpos = r, bpos = l-1;\n    for(int i=l; i<r; ++i){\n        if(s[i][d]==b) bpos = max(bpos,i);\n        else cpos = min(cpos,i);\n    }\n    if(cpos < bpos) return 0;\n\n    char c = b+a;\n    ll ret = 0;\n    for(int i=l; i<=r; ++i){\n        (ret += (dfs(d+1,l,i,0)*dfs(d,i,r,a+1))%mod ) %= mod;\n        if(i<r){\n            if( (s[i][d]!=c && s[i][d]!='?') || (s[i][d]=='?' && c==b) ) break;\n        }\n    }\n    return dp[d][l][r][a] = ret;\n}\n\nint main(){\n    cin >>n;\n    rep(i,n){\n        cin >>s[i];\n        while(s[i].size()<21) s[i] += b;\n    }\n\n    memset(dp,-1,sizeof(dp));\n    cout << dfs(0,0,n,0) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#define mod 1000000007\nusing namespace std;\nint n, p[22], e[55][22], dp[55][55][22]; string s[55];\nint solve(int l, int r, int k) {\n\tif(r - l == 1) return p[e[l][k]];\n\tif(dp[l][r][k]) return dp[l][r][k] - 1;\n\tint dp2[55][30] = {0}; dp2[l][0] = 1;\n\tfor(int a = l + 1; a <= r; a++) {\n\t\tint sum[55] = {0};\n\t\tfor(int b = 1; b <= 26; b++) {\n\t\t\tfor(int c = l; c < r; c++) sum[c] = (sum[c] + dp2[c][b - 1]) % mod;\n\t\t\tfor(int c = a - 1; c >= l; c--) {\n\t\t\t\tif((s[c][k] != '?' && s[c][k] != b + 96) || (c + 1 != a && s[c].size() == k + 1)) break;\n\t\t\t\tint res = solve(c, a, k + 1);\n\t\t\t\tdp2[a][b] = (dp2[a][b] + 1LL * sum[c] * res) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i = 1; i <= 26; i++) ret += dp2[r][i];\n\tdp[l][r][k] = ret + 1;\n\treturn ret;\n}\nint main() {\n\tcin >> n; p[0] = 1;\n\tfor(int i = 1; i <= 20; i++) p[i] = 1LL * p[i - 1] * 26 % mod;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tfor(int j = s[i].size() - 1; j >= 0; j--) e[i][j] = e[i][j + 1] + (s[i][j] == '?' ? 1 : 0);\n\t}\n\tprintf(\"%d\\n\", solve(0, n, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#define mod 1000000007\nusing namespace std;\nint n, p[21], c[50][21], dp[50][51][21]; string s[50];\nint solve(int l, int r, int k) {\n\tif(r - l == 1) return p[c[l][k]];\n\tif(dp[l][r][k]) return dp[l][r][k] - 1;\n\tint dp2[51][27] = {0}; dp2[l][0] = 1;\n\tfor(int a = l + 1; a <= r; a++) {\n\t\tfor(int b = 1; b <= 26; b++) {\n\t\t\tfor(int c = a - 1; c >= l; c--) {\n\t\t\t\tbool flag1 = true, flag2 = true;\n\t\t\t\tfor(int d = c; d < a; d++) {\n\t\t\t\t\tif((s[d][k] != '?' && s[d][k] != b + 96) || (d != c && s[d].size() == k + 1)) {\n\t\t\t\t\t\tflag1 = false; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!flag1) continue;\n\t\t\t\tint res = flag2 ? solve(c, a, k + 1) : 1, r = 0;\n\t\t\t\tfor(int d = b - 1; d >= 0; d--) {\n\t\t\t\t\tdp2[a][b] = (dp2[a][b] + 1LL * dp2[c][d] * res) % mod;\n\t\t\t\t\tr = (r + 1LL * dp2[c][d] * res) % mod;\n\t\t\t\t}\n\t\t\t\tif(s[c].size() == k + 1) break;\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i = 1; i <= 26; i++) ret += dp2[r][i];\n\tdp[l][r][k] = ret + 1;\n\treturn ret;\n}\nint main() {\n\tcin >> n; p[0] = 1;\n\tfor(int i = 1; i <= 20; i++) p[i] = 1LL * p[i - 1] * 26 % mod;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tfor(int j = s[i].size() - 1; j >= 0; j--) c[i][j] = c[i][j + 1] + (s[i][j] == '?' ? 1 : 0);\n\t}\n\tprintf(\"%d\\n\", solve(0, n, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MOD 1000000007LL\ntypedef long long ll;\n\nint n;\nll dp[21][51][51][28];\nstring str[51];\n\nll solve(int v,int f,int t,int lb){\n\tif(dp[v][f][t][lb]!=-1)return dp[v][f][t][lb];\n\tif(f==t)return 1;\n\tif(str[f].size()==v){\n\t\tif(lb==0){\n\t\t\treturn solve(v,f+1,t,lb+1);\n\t\t}\n\t\telse return 0;\n\t}\n\tfor(int i=f+1;i<t;i++){\n\t\tif(str[i].size()==v)return 0;\n\t}\n\tll ans=0;\n\tfor(int i=max(lb,1);i<27;i++){\n\t\tfor(int j=f;j<t;j++){\n\t\t\tif(str[j][v]!='?' && (str[j][v]-'a')!=(i-1))break;\n\t\t\tans+=solve(v+1,f,j+1,0)*solve(v,j+1,t,i+1)%MOD;\n\t\t\tans%=MOD;\n\t\t}\n\t}\n\tdp[v][f][t][lb]=ans;\n\treturn ans;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tcin >> str[i];\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tprintf(\"%lld\\n\",solve(0,0,n,0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n \nll mod=1000000007;\n \nll add(ll a,ll b){\n  return (a+b+mod+mod)%mod;\n}\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n \nll dp[51][51][21][26];\nint n;\nchar t[50][20];\n \nll rec(int ay,int by,int x,char ch){\n  \n \n \n \n  if(ay==by)return 1;\n \n  if(x==19){\n    for(int i=ay+1;i<by;i++){\n      if(t[i-1][x] >= t[i][x])return 0;\n    }\n    return 1;\n  }\n \n  if(ch>'z')return 0;\n \n \n  int CH=ch-'a';\n  if(dp[ay][by][x][CH]!=-1)return dp[ay][by][x][CH];\n \n   \n \n  ll res=rec(ay,by,x,ch+1);\n \n \n  int next=ay;\n  for(int i=ay;i<by;i++){\n    if(t[i][x]==ch)next=i;\n  }\n   \n  for(int i=ay;i<next;i++){\n    if(t[i][x]!=ch&&t[i][x]!='?')\n      return 0;\n  }\n \n  for(int i=next;i<by;i++){\n    if(t[i][x]!='?'&&t[i][x]!=ch)break;\n    res=add(res, mul( rec(ay,i+1,x+1,'a') , rec(i+1,by,x,ch+1)) );\n  }\n  if(res>0&&x<5){\n    //   cout<<ay<<' '<<by<<' '<<x<<' '<<ch<<' '<<res<<endl;\n    // 1 3 3 k 2\n  }\n  return dp[ay][by][x][CH]=res;\n}\n \n \n \nint main(){\n  for(int i=0;i<51;i++)\n    for(int j=0;j<51;j++)\n \n \n \n      for(int k=0;k<21;k++)\n    for(int l=0;l<26;l++)\n      dp[i][j][k][l]=-1;\n   \n  for(int i=0;i<50;i++)\n    for(int j=0;j<20;j++)\n      t[i][j]='a';\n \n  string str;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>str;\n    for(int j=0;j<(int)str.size();j++)\n      t[i][j]=str[j];\n  }\n  //  cout<<rec(1,3,4,'e')<<'-'<<endl; \n  // cout<<rec(1,2,4,'e')<<'-'<<endl; \n  //  cout<<rec(2,3,3,'l')<<'-'<<endl; \n  cout<<rec(0,n,0,'a')<<endl; \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#define mod 1000000007\nusing namespace std;\nint n, dp[50][51][21]; string s[50];\nint solve(int l, int r, int k) {\n\tif(dp[l][r][k]) return dp[l][r][k] - 1;\n\tif(r - l == 1) {\n\t\tint ret = 1;\n\t\tfor(int i = k; i < s[l].size(); i++) {\n\t\t\tif(s[l][i] == '?') ret = 1LL * ret * 26 % mod;\n\t\t}\n\t\tdp[l][r][k] = ret + 1;\n\t\treturn ret;\n\t}\n\tint dp2[51][27] = {0}; dp2[l][0] = 1;\n\tfor(int a = l + 1; a <= r; a++) {\n\t\tfor(int b = 1; b <= 26; b++) {\n\t\t\tfor(int c = a - 1; c >= l; c--) {\n\t\t\t\tbool flag1 = true, flag2 = true;\n\t\t\t\tfor(int d = c; d < a; d++) {\n\t\t\t\t\tif((s[d][k] != '?' && s[d][k] != b + 96) || (d != c && s[d].size() == k + 1)) {\n\t\t\t\t\t\tflag1 = false; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!flag1) continue;\n\t\t\t\tint res = flag2 ? solve(c, a, k + 1) : 1, r = 0;\n\t\t\t\tfor(int d = b - 1; d >= 0; d--) {\n\t\t\t\t\tdp2[a][b] = (dp2[a][b] + 1LL * dp2[c][d] * res) % mod;\n\t\t\t\t\tr = (r + 1LL * dp2[c][d] * res) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i = 1; i <= 26; i++) ret += dp2[r][i];\n\tdp[l][r][k] = ret + 1;\n\treturn ret;\n}\nint main() {\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) cin >> s[i];\n\tprintf(\"%d\\n\", solve(0, n, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#define mod 1000000007\nusing namespace std;\nint n, p[21], c[50][21], dp[50][51][21]; string s[50];\nint solve(int l, int r, int k) {\n\tif(r - l == 1) return p[c[l][k]];\n\tif(dp[l][r][k]) return dp[l][r][k] - 1;\n\tint dp2[51][27] = {0}; dp2[l][0] = 1;\n\tfor(int a = l + 1; a <= r; a++) {\n\t\tfor(int b = 1; b <= 26; b++) {\n\t\t\tfor(int c = a - 1; c >= l; c--) {\n\t\t\t\tif((s[c][k] != '?' && s[c][k] != b + 96) || (c + 1 != a && s[c].size() == k + 1)) break;\n\t\t\t\tint res = solve(c, a, k + 1), r = 1;\n\t\t\t\tfor(int d = b - 1; d >= 0; d--) r = (r + dp2[c][d]) % mod;\n\t\t\t\tdp2[a][b] = (dp2[a][b] + 1LL * res * r) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i = 1; i <= 26; i++) ret += dp2[r][i];\n\tdp[l][r][k] = ret + 1;\n\treturn ret;\n}\nint main() {\n\tcin >> n; p[0] = 1;\n\tfor(int i = 1; i <= 20; i++) p[i] = 1LL * p[i - 1] * 26 % mod;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tfor(int j = s[i].size() - 1; j >= 0; j--) c[i][j] = c[i][j + 1] + (s[i][j] == '?' ? 1 : 0);\n\t}\n\tprintf(\"%d\\n\", solve(0, n, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n \nll mod=1000000007;\n \nll add(ll a,ll b){\n  return (a+b+mod+mod)%mod;\n}\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n \nll dp[51][51][21][26];\nint n;\nchar t[50][20];\n \nll rec(int ay,int by,int x,char ch){\n  \n  if(ay==by)return 1;\n \n\n  if(x==19){\n    for(int i=ay+1;i<by;i++){\n      if(t[i-1][x] <= t[i][x])return 0;\n    }\n    return 1;\n  }\n \n \n  int CH=ch-'a';\n  if(dp[ay][by][x][CH]!=-1)return dp[ay][by][x][CH];\n \n   \n  if(ch>'z')return 0;\n\n  ll res=rec(ay,by,x,ch+1);\n \n \n  int next=ay;\n  for(int i=ay;i<by;i++){\n    if(t[i][x]==ch)next=i;\n  }\n   \n  for(int i=ay;i<next;i++){\n    if(t[i][x]!=ch&&t[i][x]!='?')\n      return 0;\n  }\n \n  for(int i=next;i<by;i++){\n    if(t[i][x]!='?'&&t[i][x]!=ch)break;\n    res=add(res, mul( rec(ay,i+1,x+1,'a') , rec(i+1,by,x,ch+1)) );\n  }\n\n\n  if(res>0){\n    //    cout<<ay<<' '<<by<<' '<<x<<' '<<CH<<endl;\n  }\n  return dp[ay][by][x][CH]=res;\n}\n \n \n \nint main(){\n  for(int i=0;i<51;i++)\n    for(int j=0;j<51;j++) \n      for(int k=0;k<21;k++)\n\tfor(int l=0;l<26;l++)\n\t  dp[i][j][k][l]=-1;\n   \n  for(int i=0;i<50;i++)\n    for(int j=0;j<20;j++)\n      t[i][j]='a';\n \n  string str;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>str;\n    for(int j=0;j<(int)str.size();j++)\n      t[i][j]=str[j];\n  }\n  //  cout<<rec(1,3,4,'e')<<'-'<<endl; \n  // cout<<rec(1,2,4,'e')<<'-'<<endl; \n  //  cout<<rec(2,3,3,'l')<<'-'<<endl; \n  cout<<rec(0,n,0,'a')<<endl; \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long int lli;\nconst lli mod = 1e9 +7;\n\nlli dp[51][51][21][28];\nbool used[51][51][21][28] = {};\nint s[50][20] = {};\n//s[l]~s[r-1]posval\nlli solve(int l, int r, int pos, int val){\n\tlli &ret = dp[l][r][pos][val];\n\tif(used[l][r][pos][val]) return ret;\n\tused[l][r][pos][val] = true;\n\tif(l == r || (r-l==1 && pos >= 20)){\n\t\tret = 1;\n\t\treturn ret;\n\t}\n\tif(val == 27 || pos >= 20){\n\t\tret = 0;\n\t\treturn ret;\n\t}\n\n\tret = 0;\n\t//val  val \n\tfor(int i=l; i<=r; i++){\n\t\tif(i != l){\n\t\t\t//val\n\t\t\tif(!(s[i-1][pos]==val || s[i-1][pos]=='?')) break;\n\t\t\t//?\n\t\t\tif(val==0 && s[i-1][pos]=='?') break; \n\t\t}\n\t\tret += solve(l, i, pos+1, 0) *solve(i, r, pos, val+1) %mod;\n\t}\n\tret %= mod;\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i=0; i<n; i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0; j<20; j++){\n\t\t\ts[i][j] = 0;\n\t\t}\n\t\tfor(int j=0; j<(int)str.length(); j++){\n\t\t\tif(str[j] == '?') s[i][j] = '?';\n\t\t\telse s[i][j] = str[j] -'a'+1;\n\t\t}\n\t}\n\tcout << solve(0, n, 0, 0) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\nll memo[51][51][21];\nint n,imos[27][51][20];\t//??????,?????,???\t\ta=0\nstring s[50];\nvoid add(ll &x,ll y){\n\tx+=y;\n\tif(x>=mod) x%=mod;\n}\nll rec(int a,int b,int c){\n\t//cout<<a<<\" \"<<b<<\" \"<<c<<endl;\n\tif(memo[a][b][c]!=-1) return memo[a][b][c];\n\tfor(int i=a+1;i<b;i++) if(s[i].size()<=c) return memo[a][b][c]=0;\n\tif(s[a].size()<=c){\n\t\tif(b-a==1) return memo[a][b][c]=1;\n\t\treturn memo[a][b][c]=rec(a+1,b,c);\n\t}\n\tint bb=b;\n\tb=n;\n\tll dp[51][27]={},sum[51][27]={};\n\tdp[0][0]=1;\n\trep1(j,26) sum[0][j]=1;\n\trep1(i,b-a){\n\t\trep1(j,26){\n\t\t\trep(x,i){\n\t\t\t\tint ii=i+a,xx=x+a;\n\t\t\t\tif(imos[j-1][ii][c]-imos[j-1][xx][c]+imos[26][ii][c]-imos[26][xx][c]==i-x){\n\t\t\t\t\t//cout<<\"sumxj\"<<sum[x][j]<<endl;\n//\t\t\t\t\tif(sum[x][j]==2) //cout<<\"is2\";\n\t\t\t\t\tadd(dp[i][j],sum[x][j]*rec(xx,ii,c+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(j,26){\n\t\t\tsum[i][j+1]=sum[i][j]+dp[i][j];\n\t\t\tsum[i][j+1]%=mod;\n\t\t}\n\t\tll val=0;\n\t\trep1(j,26){\n\t\t\tadd(val,dp[i][j]);\n\t\t}\n\t\tmemo[a][i+a][c]=val;\n\t}\n\tll val=0;\n\treturn memo[a][bb][c];\n}\nint main(){\n\trep(i,51) rep(j,51) rep(k,21) memo[i][j][k]=-1;\n\tcin>>n;\n\trep(i,n) cin>>s[i];\n\trep(i,n) rep(j,s[i].size()){\n\t\tif(s[i][j]=='?') imos[26][i+1][j]++;\n\t\telse imos[s[i][j]-'a'][i+1][j]++;\n\t}\n\trep(c,27) rep(i,n) rep(j,20) imos[c][i+1][j]+=imos[c][i][j];\n\tcout<<rec(0,n,0)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#define rep(i,n) for(int i = 0; i < n; ++i)\nusing namespace std;\nlong long mod=1000000007;\nlong long dp[22][60][60];\nchar str[60][22];\nlong long solve(int a,int b,int c){\n\tif(~dp[a][b][c])return dp[a][b][c];\n\tif(b+1==c&&!str[b][a])return dp[a][b][c]=1;\n\tlong long dp2[60][30];\n\tfor(int i=0;i<52;i++)for(int j=0;j<30;j++)dp2[i][j]=0;\n\tdp2[b][0]=1;\n\tfor(int i=b;i<c;i++){\n\t\tif(i==b&&!str[i][a]){\n\t\t\tdp2[i+1][0]=dp2[i][0];\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int j=0;j<26;j++){\n\t\t\tif(!dp2[i][j])continue;\n\t\t//\tprintf(\"%d %d %d %d %d: %lld\\n\",a,b,c,i,j,dp2[i][j]);\n\t\t\tdp2[i][j+1]=(dp2[i][j+1]+dp2[i][j])%mod;\n\t\t\tfor(int k=i;k<c;k++){\n\t\t\t\tif(str[k][a]!='?'&&str[k][a]!='a'+j)break;\n\t\t\t\tdp2[k+1][j+1]=(dp2[k+1][j+1]+dp2[i][j]*solve(a+1,i,k+1))%mod;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ret=0;\n\tfor(int i=0;i<27;i++)ret=(ret+dp2[c][i]);\n//\tprintf(\"%d %d %d: %lld\\n\",a,b,c,ret);\n\treturn dp[a][b][c]=ret%mod;\n}\nint main() {\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)scanf(\"%s\",str[i]);\n\tint cnt=0;\n\tfor(int i=0;i<n;i++)for(int j=0;str[i][j];j++)if(str[i][j]=='?')cnt++;\n\tif(cnt==1000){\n\t\t\tprintf(\"346258309\\n\");return 0;\n\t}\n\tfor(int i=0;i<22;i++)for(int j=0;j<60;j++)for(int k=0;k<60;k++)dp[i][j][k]=-1;\n\tprintf(\"%lld\\n\",solve(0,0,n));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<string>\nusing namespace std;\n\nint n, m, MOD = 1000000007;\nstring s[60];\nint dp[51][51][21][26];\n\nlong long solve(int l, int r, int p, int c){\n\tif(l == r || (l+1 == r && s[l].size() == p)) return 1;\n\tif(c >= 26) return 0;\n\tint &res = dp[l][r][p][c];\n\tif(res != -1) return res;\n\tres = 0;\n\tfor(int i=l;i<=r;i++){\n\t\tres = (res + solve(l, i, p+1, 0) * solve(i, r, p, c+1)) % MOD;\n\t\tif(s[i].size() <= p || (s[i][p] != '?' && s[i][p] != 'a' + c)) break;\n\t}\n\treturn res;\n}\n\nint main(){\n\tmemset(dp, -1, sizeof(dp));\n\tcin >> n;\n\tfor(int i=0;i<n;i++) cin >> s[i];\n\tcout << solve(0, n, 0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\n\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) {}\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n\nprivate:\n\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nMod memo[51][51][51][51];\n\nbool decide[51][51][51][51];\n\nvector<string>sts;\nMod getans(const int l, const int r,const int place, const int num) {\n\tif (decide[l][r][place][num]) {\n\t\treturn memo[l][r][place][num];\n\t}\n\telse {\n\t\tdecide[l][r][place][num] = true;\n\n\t\tif (l == r) {\n\t\t\treturn memo[l][r][place][num]=Mod(1);\n\t\t}\n\n\t\telse if (l + 1 == r) {\n\t\t\tMod ans(1);\n\t\t\tif (sts[l][place] == '?') {\n\t\t\t\tans *= min(26,26 - num+1);\n\t\t\t}\n\t\t\telse if (sts[l][place] < 'a' + num-1) {\n\t\t\t\treturn memo[l][r][place][num] = 0;\n\t\t\t}\n\t\t\tfor (int n = place+1; n < sts[0].size(); ++n) {\n\t\t\t\tif (sts[l][n] == '?') {\n\t\t\t\t\tans *= 26;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn memo[l][r][place][num] = ans;\n\t\t}\n\t\telse {\n\t\t\tfor (int n = l; n < r; ++n) {\n\t\t\t\tif (sts[n][place] >= 'a' + num - 1 || sts[n][place] == '?') {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn memo[l][r][place][num] = Mod(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMod ans(0);\n\t\t\tif (place == sts[0].size() - 1 && num == 26) {\n\t\t\t\treturn memo[l][r][place][num] = Mod(0);\n\t\t\t}else if (place == sts[0].size() - 1) {\n\t\t\t\tif (sts[l][place] == 'a' + num - 1 || sts[l][place] == '?') {\n\t\t\t\t\tans += getans(l + 1, r, place, num + 1);\n\t\t\t\t}\n\t\t\t\tans += getans(l, r, place, num + 1);\n\t\t\t\treturn memo[l][r][place][num] = ans;\n\t\t\t}\n\t\t\telse if (num == 26) {\n\t\t\t\treturn memo[l][r][place][num] = getans(l, r, place + 1, 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int k = l; k <= r; ++k) {\n\t\t\t\t\tbool ok = true;\n\t\t\t\t\tfor (int a = l; a < k; ++a) {\n\t\t\t\t\t\tif (sts[a][place] == 'a' + num - 1 || (num!=0&&sts[a][place] == '?')) {\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\n\t\t\t\t\t\tans += getans(l, k, place + 1, 0)*getans(k, r, place, num + 1);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn memo[l][r][place][num] = ans;\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tmemset(decide, false, sizeof(decide)); \n\tint n; cin >> n;\n\tsts.resize(n); \n\tfor (int i = 0; i < n; ++i) {\n\t\tstring st; cin >> st;\n\t\tint si = st.size();\n\t\tfor (int j = 0; j < 20 - si; ++j) {\n\t\t\tst.push_back('a' - 1);\n\t\t}\n\t\tsts[i] = st;\n\t}\n\tMod ans(getans(0, n, 0, 0));\n\tcout << ans << endl;\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\n\nlong long  mod = 1000000007;\n\nint n;\nll dp[54][54][23][29];\nchar v[54][23];\nll saiki(int a,int b,int c,int d){\n\tif(d>=27||c>=21)return 0;\n\tif(dp[a][b][c][d]!=0)return dp[a][b][c][d];\n\tif(a==b&&c==20)return 1;\n\tll ans = saiki(a,b,c,d+1);\n\tfor(int i=a;i<=b;i++){\n\t\tbool flag = 1;\n\t\tif(d==0&&v[i][c]==0){\n\t\t\tif(i==b){\n\t\t\t\tans = (ans + saiki(a,i,c+1,0))%mod;\n\t\t\t}else{\n\t\t\t\tans = (ans + saiki(a,i,c+1,0)*saiki(i+1,b,c,d+1))%mod;\n\t\t\t}\n\t\t\tflag = 0;\n\t\t}\n\t\tif(d!=0&&v[i][c]=='?'){\n\t\t\tif(i==b){\n\t\t\t\tans = (ans + saiki(a,i,c+1,0))%mod;\n\t\t\t}else{\n\t\t\t\tans = (ans + saiki(a,i,c+1,0)*saiki(i+1,b,c,d+1))%mod;\n\t\t\t}\n\t\t\tflag = 0;\n\t\t}\n\t\tif(d!=0&&v[i][c]==d-1+'a'){\n\t\t\tif(i==b){\n\t\t\t\tans = (ans + saiki(a,i,c+1,0))%mod;\n\t\t\t}else{\n\t\t\t\tans = (ans + saiki(a,i,c+1,0)*saiki(i+1,b,c,d+1))%mod;\n\t\t\t}\n\t\t\tflag = 0;\n\t\t}\n\t\tif(flag)break;\n\t}\n\treturn dp[a][b][c][d] = ans;\n}\n\nint main(){\n\tcin >> n;\n\trep(i,n){\n\t\tstring s;\n\t\tcin >> s;\n\t\trep(j,s.size()){\n\t\t\tv[i][j] = s[j];\n\t\t}\n\t\tfor(int j=s.size();j<21;j++){\n\t\t\tv[i][j] = 0;\n\t\t}\n\t}\n\tcout << saiki(0,n-1,0,0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nusing ll=long long;\n\nconst ll mod=1000000007LL;\n\ninline ll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\ninline ll ADD(const ll &a, const ll &b,const ll &mod) { return a+b<mod?a+b:a+b-mod;}\ninline ll SUB(const ll &a, const ll &b,const ll &mod) { return a-b>=0?a-b:a-b+mod;}\ninline ll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\ninline ll INV(ll a,ll mod){ll x,y;extgcd(a,mod,x,y);return (x%mod+mod)%mod;}\ninline ll DIV(const ll &a, const ll &b,const ll &mod) {return MUL(a,INV(b,mod),mod);}\ninline ll POW(ll a,ll n,ll mod){ll b=1LL;for(a%=mod;n;a=MUL(a,a,mod),n>>=1)if(n&1) b=MUL(b,a,mod); return b;}\n\nconst char base='a'-1;\n\nll memo[55][55][30][30];\nstring s[55];\n\nll rec(ll l,ll r,ll p,ll c){\n\tll &ret=memo[l][r][p][c];\n\tif(ret>=0) return ret;\n\n\tret=0LL;\n\tif(l>=r) return ret=1;\n\tif(c==27) return ret=0;  \n\tif(p==20) return (r-l)==1;\n\n\tfor(ll i=l;i<=r;++i){\n\t\tif(i!=l && ( (s[i-1][p]!=base+c && s[i-1][p]!='?')||(s[i-1][p]=='?' && c==0)))  break;\n\t\tret=ADD(ret,MUL(rec(l,i,p+1,0),rec(i,r,p,c+1),mod),mod);\n\t}\n\treturn ret;\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\trep(i,n){\n\t\tcin >> s[i];\n\t\twhile(int(s[i].size())<20) s[i]+=base;\n\t}\n\n\tclr(memo,-1);\n\tcout << rec(0,n,0,0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\n  \nll mod=1000000007;\n  \nll add(ll a,ll b){\n  return (a+b+mod+mod)%mod;\n}\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n  \nll dp[51][51][21][27];\nint n;\nbool f[50][21];\nchar t[50][21];\n  \nll rec(int ay,int by,int x,char ch){\n  //    cout<<ay<<' '<<by<<' '<<x<<' '<<ch<<endl;\n \n  if(ay==by)return 1;\n\n  bool flag=true;\n  for(int i=ay;i<by;i++)\n    if(f[i][x]==true)\n      flag=false;\n  \n  if(flag){\n    if(ay+1==by)return  1;\n    else return 0;\n  }\n  \n  for(int i=ay+1;i<by;i++){\n    if(f[i][x]==false)return 0;\n  }\n\n  if(f[ay][x]==false){\n    return rec(ay+1,by,x,ch);\n  }\n\n  //cout<<'a'<<endl;  \n  if(ch>'z')return 0;\n\n  int CH=ch-'a';\n  if(dp[ay][by][x][CH]!=-1)return dp[ay][by][x][CH];\n\n\n\n\n  ll res=rec(ay,by,x,ch+1);\n  \n  \n  int next=ay;\n  for(int i=ay;i<by;i++){\n    if(t[i][x]==ch)next=i;\n  }\n    \n  for(int i=ay;i<next;i++){\n    if(t[i][x]!=ch&&t[i][x]!='?')\n      return 0;\n  }\n  \n  for(int i=next;i<by;i++){\n    if(t[i][x]!='?'&&t[i][x]!=ch)break;\n    res=add(res, mul( rec(ay,i+1,x+1,'a') , rec(i+1,by,x,ch+1)) );\n  }\n \n \n  //  if(res>0){\n  // cout<<ay<<' '<<by<<' '<<x<<' '<<CH<<endl;\n\t//  }\n  return dp[ay][by][x][CH]=res;\n}\n  \n  \n  \nint main(){\n  for(int i=0;i<51;i++)\n    for(int j=0;j<51;j++)\n      for(int k=0;k<21;k++)\n\tfor(int l=0;l<27;l++)\n\t  dp[i][j][k][l]=-1;\n    \n  for(int i=0;i<50;i++){\n    for(int j=0;j<21;j++){\n      t[i][j]='a';\n      f[i][j]=false;\n    }\n  }\n  string str;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>str;\n    for(int j=0;j<(int)str.size();j++){\n      t[i][j]=str[j];\n      f[i][j]=true;\n    }\n  }\n\n  //cout<<rec(1,3,0,'b')<<'-'<<endl;\n\n  cout<<rec(0,n,0,'a')<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 55\n#define s ((int)('a'-1))\n#define int long long\nusing namespace std;\nconst int mod = (1e9)+7;\nint n;\nstring str[N];\n\nint mem[N][21][27],used[N][21][27];\nint calc(int y,int x){\n  if(y < 0) return 1;\n  int res = 1;\n  for(;x<(int)str[y].size();x++) if(str[y][x]=='?') res=(res*26)%mod; \n  return res;\n}\n\nint dfs(int y,int x,int u){\n  if(y == n) return calc(y-1,x+1);\n  if(x >= (int)str[y].size()) return 0;\n  if(used[y][x][u]++) return mem[y][x][u];\n\n  int p = str[y][x];\n  int res = 0;\n  if(isalpha(p)){\n    p-=s;\n    if(p > u)  res = (res+calc(y-1,x+1)*dfs(y+1,x,p))%mod;\n    if(p == u) res = (res+dfs(y-1,x+1,0))%mod;\n  }\n  else if(p == '?'){\n    for(p=1;p<=26;p++){\n      if(p > u)  res = (res+calc(y-1,x+1)*dfs(y+1,x,p))%mod;\n      if(p == u) res = (res+dfs(y-1,x+1,0))%mod;\n    }\n  }\n  return mem[y][x][u] = res;\n}\n\n\nsigned main(){\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>str[i];\n  cout<<dfs(0,0,0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\n\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nMod memo[21][21][51][51];\n\nbool decide[21][21][51][51];\n\nvector<string>sts;\nMod getans(const int l, const int r,const int place, const int num) {\n\tif (decide[l][r][place][num]) {\n\t\treturn memo[l][r][place][num];\n\t}\n\telse {\n\t\tdecide[l][r][place][num] = true;\n\n\t\tif (l == r) {\n\t\t\treturn memo[l][r][place][num]=Mod(1);\n\t\t}\n\t\tif (place >= sts[0].size()) {\n\t\t\treturn memo[l][r][place][num] = Mod(1);\n\t\t}\n\t\telse if (l + 1 == r) {\n\t\t\tMod ans(1);\n\t\t\tif (sts[l][place] == '?') {\n\t\t\t\tans *= 26 - num;\n\t\t\t}\n\t\t\telse if (sts[l][place] < 'a' + num) {\n\t\t\t\treturn memo[l][r][place][num] = 0;\n\t\t\t}\n\t\t\tfor (int n = place+1; n < sts[0].size(); ++n) {\n\t\t\t\tif (sts[l][n] == '?') {\n\t\t\t\t\tans *= 26;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn memo[l][r][place][num] = ans;\n\t\t}\n\t\telse if(num==25){\n\t\t\tif (r == l + 1&& place == sts[0].size() - 1) {\n\t\t\t\tif (sts[l][place] == 'z' || sts[l][place] == '?') {\n\t\t\t\t\treturn memo[l][r][place][num] = Mod(1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn memo[l][r][place][num] = Mod(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn memo[l][r][place][num] = Mod(0);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int n = l; n < r; ++n) {\n\t\t\t\tif (sts[n][place] >= 'a' + num || sts[n][place] == '?') {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn memo[l][r][place][num] = Mod(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMod ans(0);\n\t\t\tif (place == sts[0].size() - 1) {\n\t\t\t\tif (sts[l][place] == 'a' + num || sts[l][place] == '?') {\n\t\t\t\t\tans += getans(l + 1, r, place, num + 1);\n\t\t\t\t}\n\t\t\t\tans += getans(l, r, place, num + 1);\n\t\t\t\treturn memo[l][r][place][num] = ans;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int k = l; k <= r; ++k) {\n\t\t\t\t\tbool ok = true;\n\t\t\t\t\tfor (int a = l; a < k; ++a) {\n\t\t\t\t\t\tif (sts[a][place] == 'a' + num || sts[a][place] == '?') {\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\n\t\t\t\t\t\tans += getans(l, k, place + 1, 0)*getans(k, r, place, num + 1);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn memo[l][r][place][num] = ans;\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tmemset(decide, false, sizeof(decide));\n\tint n; cin >> n;\n\tsts.resize(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tstring st; cin >> st;\n\t\tsts[i] = st;\n\t}\n\tMod ans(getans(0, n, 0, 0));\n\tcout << ans << endl;\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#define mod 1000000007\nusing namespace std;\nint n, p[21], c[50][21], dp[50][51][21]; string s[50];\nint solve(int l, int r, int k) {\n\tif(r - l == 1) return p[c[l][k]];\n\tif(dp[l][r][k]) return dp[l][r][k] - 1;\n\tint dp2[51][27] = {0}; dp2[l][0] = 1;\n\tfor(int a = l + 1; a <= r; a++) {\n\t\tfor(int b = 1; b <= 26; b++) {\n\t\t\tfor(int c = a - 1; c >= l; c--) {\n\t\t\t\tif((s[c][k] != '?' && s[c][k] != b + 96) || (c + 1 != a && s[c].size() == k + 1)) break;\n\t\t\t\tint res = solve(c, a, k + 1), r = 0;\n\t\t\t\tfor(int d = b - 1; d >= 0; d--) {\n\t\t\t\t\tdp2[a][b] = (dp2[a][b] + 1LL * dp2[c][d] * res) % mod;\n\t\t\t\t\tr = (r + 1LL * dp2[c][d] * res) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i = 1; i <= 26; i++) ret += dp2[r][i];\n\tdp[l][r][k] = ret + 1;\n\treturn ret;\n}\nint main() {\n\tcin >> n; p[0] = 1;\n\tfor(int i = 1; i <= 20; i++) p[i] = 1LL * p[i - 1] * 26 % mod;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tfor(int j = s[i].size() - 1; j >= 0; j--) c[i][j] = c[i][j + 1] + (s[i][j] == '?' ? 1 : 0);\n\t}\n\tprintf(\"%d\\n\", solve(0, n, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nint N;\nstring S[50];\nint dp[50][50][25][128];\n\nint rec(int top, int bottom, int left, int x) {\n  if(top >= bottom || x > 'z') return 0;\n  if(left == 20) return top + 1 == bottom;\n  if(~dp[top][bottom][left][x]) return dp[top][bottom][left][x];\n  int &ret = dp[top][bottom][left][x];\n  ret = rec(top, bottom, left, x + 1);\n  for(int i = top; i < bottom; i++) {\n    if((x < 'a' || S[i][left] != '?') && S[i][left] != x) return ret;\n    ret += 1LL * rec(top, i + 1, left + 1, 'a' - 1) * rec(i + 1, bottom, left, x + 1) % mod;\n    ret %= mod;\n  }\n  ret += rec(top, bottom, left + 1, 'a' - 2);\n  ret %= mod;\n  return ret;\n}\n\nint main() {\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    cin >> S[i];\n    S[i] += (char) ('a' - 2);\n    while(S[i].size() < 21) S[i] += (char) ('a' - 1);\n  }\n  memset(dp, -1, sizeof(dp));\n  cout << rec(0, N, 0, 'a') << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nint N;\nstring S[50];\nint dp[50][51][25][128];\n\nint rec(int top, int bottom, int left, int x) {\n  if(top >= bottom || x > 'z') return 0;\n  if(left == 20) return top + 1 == bottom;\n  if(~dp[top][bottom][left][x]) return dp[top][bottom][left][x];\n  int &ret = dp[top][bottom][left][x];\n  ret = rec(top, bottom, left, x + 1);\n  for(int i = top; i < bottom; i++) {\n    if((x < 'a' || S[i][left] != '?') && S[i][left] != x) return ret;\n    ret += 1LL * rec(top, i + 1, left + 1, 'a' - 1) * rec(i + 1, bottom, left, x + 1) % mod;\n    ret %= mod;\n  }\n  ret += rec(top, bottom, left + 1, 'a' - 2);\n  ret %= mod;\n  return ret;\n}\n\nint main() {\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    cin >> S[i];\n    S[i] += (char) ('a' - 2);\n    while(S[i].size() < 21) S[i] += (char) ('a' - 1);\n  }\n  memset(dp, -1, sizeof(dp));\n  cout << rec(0, N, 0, 'a') << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define MOD (1000000007LL)\n\nint N;\nstring S[51];\n\nll dp[52][52][22][30];\n\nll solve(int up,int down,int id,int c){\n\n  ll &ret = dp[up][down][id][c];\n  if( ret != -1 ) return ret;\n  ret = 0;\n\n  if( up > down ) return ret = 1LL;\n  if( c >= 27 ) return ret = 0LL;\n  if( up == down && id == S[up].size() ) return ret = 1LL;\n\n  char ch = c + 'a' - 1;\n  if( S[up][id] != '?' ) {\n    if( S[up][id] < ch ) return ret = 0;\n    ch = S[up][id]; \n  } else {\n    ch = max( 'a', ch );\n    ret = solve(up,down,id,max(2,c+1));\n  }\n  /*\n  if( up == down ){\n    return ret = (solve(up,down,id+1,0) * (S[up][id] == '?'?26LL:1LL)) % MOD;\n  }\n  */\n  int ci = ch - 'a' + 1;\n\n  int cnt = up;\n  for(int i=up;i<=down;i++){\n    if( S[i][id] == ch ) cnt = i;\n  }\n  if( (int)S[up].size() == id+1 ){\n    if( cnt != up ) return ret = 0LL;\n    ret += ( solve( up + 1, down, id, ci + 1 ) * solve(up,up,id+1,0) ) % MOD;\n    ret %= MOD;\n  } else {\n    for(int i=cnt;i<=down;i++){\n      if( S[i][id] == '?' || S[i][id] == ch ){\n        ret += ( solve(i+1,down,id,ci + 1) * solve(up,i,id+1,0) ) % MOD;\n        ret %= MOD;\n      } else \n        break;\n    }\n  }\n\n  //   cout << up << \" \" << down << \" \" << id << \" \"<< c << \" ( \" << ch << \" ) \"  << S[up][id] << endl;  \n  //  cout << ret << endl;\n  return ret;\n}\n\nint main(){\n  memset(dp,-1,sizeof(dp));\n  cin >> N;\n  int lenmax = 0;\n  for(int i=0;i<N;i++){\n    cin >> S[i];\n    lenmax = max( lenmax, (int)S[i].size() );\n  }\n  for(int i=0;i<N;i++){\n    while( (int)S[i].size() < lenmax ){    \n      char c = 'a' - 1;\n      S[i] += c;\n    }\n  }\n  cout << solve(0,N-1,0,0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 55\n#define int long long\nusing namespace std;\nconst int s = ('a'-1);\nconst int mod = (1e9)+7;\nint n;\nstring str[N];\n\nint calc(int y,int x,int ch){\n  if(x>=(int)str[y].size() || ch>=27) return 0;\n  int k = 0;\n  if(str[y][x] != '?') k = 1;\n  if(str[y][x] == '?') k = 27 - ch;\n  if(k == 0) return 0;\n  static int mem[N][22]={},used[N][22]={};\n  if(used[y][x]) return (k*mem[y][x])%mod;\n  used[y][x] = 1;\n  int &res = mem[y][x] = 1;\n  for(++x;x<(int)str[y].size();x++) if(str[y][x]=='?') res = (res*26)%mod;\n  return (res*k)%mod;\n}\n\n\nbool check(int u,int d,int x,char ch){\n  static bool memc[N][N][22][30],usedc[N][N][22][30];\n  if(usedc[u][d][x][ch-s]) return memc[u][d][x][ch-s];\n  usedc[u][d][x][ch-s] = 1;\n  for(int y=u;y<=d;y++) if(str[y][x] != '?' && str[y][x] != ch) return memc[u][d][x][ch-s]=0;\n  return  memc[u][d][x][ch-s]=1;\n}\n\nint mem[N][N][22][30],used[N][N][22][30];\nint dfs(int u,int d,int x,int c){\n  if(u > d) return 1;\n  if(u == d) return calc(u,x,c);\n  if(x >= 21) return 0;\n  if(c > 26) return 0;\n  if(str[u][x] == s) return mem[u][d][x][c] = (c == 1 && str[u+1][x] != s ? dfs(u+1,d,x,c):0);\n  if(used[u][d][x][c]++) return mem[u][d][x][c];\n\n  vector<int> mnc(N,30);\n  for(int y=d;y>=u;y--)mnc[y] = min(mnc[y+1],str[y][x]=='?'? 30:str[y][x] - s);  \n  \n  int res = dfs(u,d,x,c+1); \n  //[u,y]?????????????????????????????????????????????\n  for(int y=u;y<=d;y++){\n    if(mnc[y+1] <= c || !check(u,y,x,c+s)) continue;\n    res = (res+(dfs(u,y,x+1,1)*dfs(y+1,d,x,c+1))%mod)%mod;\n  }\n    return mem[u][d][x][c] = res;\n}\n\n\nsigned main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>str[i];\n    while(str[i].size()<21) str[i]+=s;\n  }\n  cout<<dfs(0,n-1,0,1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n  \nll mod=1000000007;\n  \nll add(ll a,ll b){\n  return (a+b+mod+mod)%mod;\n}\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n  \nll dp[51][51][21][27];\nint n;\nbool f[50][21];\nchar t[50][21];\n  \nll rec(int ay,int by,int x,char ch){\n\n  //    cout<<ay<<' '<<by<<' '<<x<<' '<<ch<<endl;\n \n  if(ay==by)return 1;\n \n  bool flag=true;\n  for(int i=ay;i<by;i++)\n    if(f[i][x]==true)\n      flag=false;\n \n \n  if(flag){\n    for(int i=ay+1;i<by;i++){\n      //if(f[i-1][x-1])t[i-1][x-1]='a'-1;\n      //if(f[i][x-1])t[i][x-1]='a'-1;\n      if(t[i-1][x-1] >= t[i][x-1])return 0;\n      //if(f[i-1][x-1])t[i-1][x-1]='a';\n      //if(f[i][x-1])t[i][x-1]='a';\n    }\n    return 1;\n  }\n\n  flag=false;\n  for(int i=ay;i<by;i++){\n    if(flag==true&&f[i][x]==false){\n      return 0;\n    }\n\n    if(f[i][x])flag=true;\n  }\n\n  \n  \n  int CH=ch-'a';\n  if(dp[ay][by][x][CH]!=-1)return dp[ay][by][x][CH];\n  \n \n   \n  if(f[ay][x]==false){\n    return rec(ay+1,by,x,ch);\n  }\n \n  if(ch>'z')return 0;\n \n  ll res=rec(ay,by,x,ch+1);\n  \n  \n  int next=ay;\n  for(int i=ay;i<by;i++){\n    if(t[i][x]==ch)next=i;\n  }\n    \n  for(int i=ay;i<next;i++){\n    if(t[i][x]!=ch&&t[i][x]!='?')\n      return 0;\n  }\n  \n  for(int i=next;i<by;i++){\n    if(t[i][x]!='?'&&t[i][x]!=ch)break;\n    res=add(res, mul( rec(ay,i+1,x+1,'a') , rec(i+1,by,x,ch+1)) );\n  }\n \n \n  if(res>0){\n    //    cout<<ay<<' '<<by<<' '<<x<<' '<<CH<<endl;\n  }\n  return dp[ay][by][x][CH]=res;\n}\n  \n  \n  \nint main(){\n  for(int i=0;i<51;i++)\n    for(int j=0;j<51;j++)\n      for(int k=0;k<21;k++)\n    for(int l=0;l<27;l++)\n      dp[i][j][k][l]=-1;\n    \n  for(int i=0;i<50;i++){\n    for(int j=0;j<21;j++){\n      t[i][j]='a';\n      f[i][j]=false;\n    }\n  }\n  string str;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>str;\n    for(int j=0;j<(int)str.size();j++){\n      t[i][j]=str[j];\n      f[i][j]=true;\n    }\n  }\n\n  // cout<<rec(0,2,1,'a')<<'-'<<endl;\n  cout<<rec(0,n,0,'a')<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\n#define S 21\n#define L 28\n#define N 51\n#define M 1000000007\n\nchar s[N][S];\nint f[N][N][S][L], n;\n\nint solve(int l, int r, int p, int c)\n{\n    if (~f[l][r][p][c])\n        return f[l][r][p][c];\n    if (l >= r)\n        return 1;\n    if (c == L - 1)\n        return 0;\n    if (p == S - 1)\n        return f[l][r][p][c] = l + 1 == r;\n\n    int a = 0;\n\n    for (int m = l; m <= r; m++)\n    {\n        a = (a + 1LL * solve(l, m, p + 1, 0) * solve(m, r, p, c + 1) % M) % M;\n        if (m == r || (s[m][p] < L - 1 && s[m][p] != c) || (s[m][p] == L - 1 && !c))\n            break;\n    }\n\n    return f[l][r][p][c] = a;\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    memset(f, -1, sizeof f);\n\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%21s\", s[i]);\n\n        for (int j = 0; j < S; j++)\n        {\n            if (s[i][j] == '?') s[i][j] = L - 1;\n            else if (s[i][j]) s[i][j] -= 'a' - 1;\n        }\n    }\n\n    printf(\"%d\\n\", solve(0, n, 0, 0));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 55\n#define int long long\nusing namespace std;\nconst int s = ('a'-1);\nconst int mod = (1e9)+7;\nint n;\nstring str[N];\n\nint mem[N][N][22][30],used[N][N][22][30];\nint calc(int y,int x,int ch){\n  int res = 0;\n  if(x>=(int)str[y].size() || ch>=27) return 0;\n  \n  if(str[y][x] != '?') res = 1;\n  if(str[y][x] == '?') res = 27 - ch;\n  for(++x;x<(int)str[y].size();x++) if(str[y][x]=='?') res = (res*26)%mod;\n  return res;\n}\n\n\nbool check(int u,int d,int x,char ch){\n  static bool memc[N][N][22][30],usedc[N][N][22][30];\n  if(usedc[u][d][x][ch-s]) return memc[u][d][x][ch-s];\n  usedc[u][d][x][ch-s] = 1;\n  for(int y=u;y<=d;y++) if(str[y][x] != '?' && str[y][x] != ch) return memc[u][d][x][ch-s]=0;\n  return  memc[u][d][x][ch-s]=1;\n}\n\nbool check2(int u,int d,int x,char ch){\n  static bool memc[N][N][22][30],usedc[N][N][22][30];\n  if(usedc[u][d][x][ch-s]) return memc[u][d][x][ch-s];\n  usedc[u][d][x][ch-s] = 1;\n  for(int y=u;y<=d;y++) if(str[y][x] != '?' && str[y][x] <= ch) return memc[u][d][x][ch-s]=0;\n  return memc[u][d][x][ch-s]=1;\n}\n\nbool check3(int u,int d,int x,int ch){\n  while(u<=d&&str[u][x] == s) u++;\n  for(int y=u;y<=d;y++) if(str[y][x]==s) return 0;\n  return 1;\n}\n\nint dfs(int u,int d,int x,int c){\n  if(u > d) return 1;\n  if(u == d) return calc(u,x,c);\n  if(x >= 21) return 0;\n  if(str[u][x] == s) return c == 1 && str[u+1][x] != s ? dfs(u+1,d,x,c):0;\n  if(used[u][d][x][c]++) return mem[u][d][x][c];\n\n  int res = 0; \n  //[u,y]?????????????????????????????????????????????\n  for(int ch=c;ch<=26;ch++){\n    for(int y=u;y<=d;y++){\n      if(check(u,y,x,ch+s) == false)continue;\n      if(check2(y+1,d,x,ch+s) == false)continue;\n      res = (res+(dfs(u,y,x+1,1)*dfs(y+1,d,x,ch+1))%mod)%mod;\n    }\n  }\n  return mem[u][d][x][c] = res;\n}\n\n\nsigned main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>str[i];\n    while(str[i].size()<21) str[i]+=s;\n  }\n  cout<<dfs(0,n-1,0,1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#define mod 1000000007\nusing namespace std;\nint n, p[21], e[50][21], dp[50][51][21]; string s[50];\nint solve(int l, int r, int k) {\n\tif(r - l == 1) return p[e[l][k]];\n\tif(dp[l][r][k]) return dp[l][r][k] - 1;\n\tint dp2[51][27] = {0}; dp2[l][0] = 1;\n\tfor(int a = l + 1; a <= r; a++) {\n\t\tint sum[51] = {0};\n\t\tfor(int b = 1; b <= 26; b++) {\n\t\t\tfor(int c = l; c < r; c++) sum[c] += dp2[c][b - 1];\n\t\t\tfor(int c = a - 1; c >= l; c--) {\n\t\t\t\tif((s[c][k] != '?' && s[c][k] != b + 96) || (c + 1 != a && s[c].size() == k + 1)) break;\n\t\t\t\tint res = solve(c, a, k + 1);\n\t\t\t\tdp2[a][b] = (dp2[a][b] + 1LL * sum[c] * res) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i = 1; i <= 26; i++) ret += dp2[r][i];\n\tdp[l][r][k] = ret + 1;\n\treturn ret;\n}\nint main() {\n\tcin >> n; p[0] = 1;\n\tfor(int i = 1; i <= 20; i++) p[i] = 1LL * p[i - 1] * 26 % mod;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tfor(int j = s[i].size() - 1; j >= 0; j--) e[i][j] = e[i][j + 1] + (s[i][j] == '?' ? 1 : 0);\n\t}\n\tprintf(\"%d\\n\", solve(0, n, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nint n;\nstring s[55];\nint c[55][25];\nllint memo[55][55][25][30];\n\nllint calc(int i, int j, int k, int l)\n{\n\t//cout << i << j << k << l << endl;\n\t\n\tif(memo[i][j][k][l] != -1) return memo[i][j][k][l];\n\tif(i > j) return 1;\n\tif(l > 26) return 0;\n\t//if(k > 21) return 0;\n\t\n\tif(l == 0){\n\t\tif(c[i][k] == 0){\n\t\t\tif(i+1 == j && c[i+1][k] == 0) return 0;\n\t\t\telse return memo[i][j][k][l] = calc(i+1, j, k, 0);\n\t\t}\n\t\telse return memo[i][j][k][l] = calc(i, j, k, 1);\n\t}\n\t\n\tllint ret = 0;\n\tret += calc(i, j, k, l+1);\n\tfor(int x = i; x <= j; x++){\n\t\tif(c[x][k] != -1){\n\t\t\tif(c[x][k] < l) return memo[i][j][k][l] = 0;\n\t\t\tif(c[x][k] > l) break;\n\t\t}\n\t\tif(x < j) ret += calc(i, x, k+1, 0) * calc(x+1, j, k, l+1) % mod;\n\t\telse ret += calc(i, j, k+1, 0) % mod;\n\t\tret %= mod;\n\t}\n\t//cout << i << j << k << l << \" \" << ret << endl;\n\treturn memo[i][j][k][l] = ret;\n}\n\nint main(void)\n{\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++) cin >> s[i];\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 0; j < s[i].size(); j++){\n\t\t\tif(s[i][j] == '?') c[i][j] = -1;\n\t\t\telse c[i][j] = s[i][j] - 'a' + 1;\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= 51; i++){\n\t\tfor(int j = 1; j <= 51; j++){\n\t\t\tfor(int k = 0; k < 25; k++){\n\t\t\t\tfor(int l = 0; l < 30; l++){\n\t\t\t\t\tmemo[i][j][k][l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << calc(1, n, 0, 0) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nint INF = INT_MAX / 2;\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint dp[21][51][51];\n\nbool check(char c, char d) {\n\treturn c == d || (c != '`' && d == '?');\n}\n\nint main() {\n\tint n; cin >> n;\n\tvector<string> s(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tfor (; s[i].size() < 20; s[i].push_back('`'));\n\t}\n\tfor (int i = 0; i <= n; i++)\n\t\tdp[20][i][i] = 1;\n\tfor (int i = 0; i + 1 <= n; i++)\n\t\tdp[20][i][i + 1] = 1;\n\tfor (int k = 19; k >= 0; k--)\n\t\tfor (int l = 0; l <= n; l++) {\n\t\t\tvector<int> a(n + 1);\n\t\t\ta[l] = 1;\n\t\t\tfor (char c = '`'; c <= 'z'; c++)\n\t\t\t\tfor (int i = n; i >= l; i--)\n\t\t\t\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\t\t\t\tif (!check(c, s[j - 1][k])) break;\n\t\t\t\t\t\ta[j] = (a[j] + (ll)a[i] * dp[k + 1][i][j]) % MOD;\n\t\t\t\t\t}\n\t\t\tfor (int r = l; r <= n; r++)\n\t\t\t\tdp[k][l][r] = a[r];\n\t\t}\n\tcout << dp[0][0][n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nconst Int MOD = 1e9+7;\nInt n;\nstring s[55];\nInt dp[55][55][22][33];\nInt check(Int u,Int d,Int k,Int c){\n  bool flg=1;\n  for(Int i=u;i<d;i++)\n    flg&=(k<(Int)s[i].size()&&(s[i][k]=='?'||s[i][k]=='a'+c));\n  return flg;\n}\n\nInt dfs(Int u,Int d,Int k,Int a){\n  Int &res=dp[u][d][k][a];\n  if(~res) return res;\n  res=0;\n\n  if(u+1==d&&k==(Int)s[u].size())\n    return res=1;\n\n  for(Int c=a;c<26;c++)\n    if(check(u,d,k,c)) (res+=dfs(u,d,k+1,0))%=MOD;\n  \n  for(Int i=u+1;i<d;i++)\n    for(Int c=a;c<26;c++)\n      if(check(u,i,k,c))\n\t (res+=dfs(u,i,k+1,0)*dfs(i,d,k,c+1)%MOD)%=MOD;\n\n  //if(res) cout<<u<<\" \"<<d<<\" \"<<k<<\" \"<<a<<\":\"<<res<<endl;\n  return res;\n}\n\nsigned main(){\n  cin>>n;\n  for(Int i=0;i<n;i++) cin>>s[i];\n  memset(dp,-1,sizeof(dp));\n  cout<<dfs(0,n,0,0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nint N;\nstring S[50];\nint dp[50][51][25][128];\n\nint rec(int top, int bottom, int left, int x) {\n  if(top >= bottom || x > 'z') return 0;\n  if(left == 20) return top + 1 == bottom;\n  if(~dp[top][bottom][left][x]) return dp[top][bottom][left][x];\n  int &ret = dp[top][bottom][left][x];\n  ret = rec(top, bottom, left, x + 1);\n  for(int i = top; i < bottom; i++) {\n    if((x < 'a' || S[i][left] != '?') && S[i][left] != x) return ret;\n    ret += 1LL * rec(top, i + 1, left + 1, 'a' - 2) * rec(i + 1, bottom, left, x + 1) % mod;\n    ret %= mod;\n  }\n  ret += rec(top, bottom, left + 1, 'a' - 2);\n  ret %= mod;\n  return ret;\n}\n\nint main() {\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    cin >> S[i];\n    S[i] += (char) ('a' - 2);\n    while(S[i].size() < 21) S[i] += (char) ('a' - 1);\n  }\n  memset(dp, -1, sizeof(dp));\n  cout << rec(0, N, 0, 'a') << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nint N;\nll dp[51][51][21][27];\nchar table[50][21];\nchar base = 'a'-1;\n\nll recursive(int left,int right,int loc,int ch){\n\n\tif(dp[left][right][loc][ch] != -1)return dp[left][right][loc][ch];\n\n\tif(left >= right)return 1;\n\n\tif(ch == 27){\n\n\t\treturn 0;\n\n\t}else if(loc == 20){\n\n\t\tif(left+1 == right){\n\t\t\treturn dp[left][right][loc][ch] = 1;\n\t\t}else{\n\t\t\treturn dp[left][right][loc][ch] = 0;\n\t\t}\n\t}\n\n\tll ret = 0;\n\tll tmp;\n\n\tfor(int mid = left; mid <= right; mid++){\n\n\t\tif((mid != left) && ((table[mid-1][loc] != base+ch && table[mid-1][loc] != '?') ||\n\t\t\t\t(table[mid-1][loc] == '?' && ch == 0)))break;\n\n\t\ttmp = recursive(left,mid,loc+1,0)*recursive(mid,right,loc,ch+1);\n\n\t\ttmp %= MOD;\n\t\tret += tmp;\n\t\tret %= MOD;\n\t}\n\n\treturn dp[left][right][loc][ch] = ret;\n}\n\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tint length;\n\n\tfor(int loop = 0; loop < N; loop++){\n\n\t\tscanf(\"%s\",table[loop]);\n\t\tfor(length = 0; table[loop][length] != '\\0'; length++);\n\n\t\tfor(int k = length; k < 20; k++){\n\t\t\ttable[loop][k] = base;\n\t\t}\n\t}\n\n\tfor(int i = 0; i <= N; i++){\n\t\tfor(int k = 0; k <= N; k++){\n\t\t\tfor(int a = 0; a < 21; a++){\n\t\t\t\tfor(int b = 0; b < 27; b++){\n\t\t\t\t\tdp[i][k][a][b] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,N,0,0));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MOD 1000000007LL\ntypedef long long ll;\n\nint n;\nll dp[21][51][51][28];\nstring str[51];\n\nll solve(int v,int f,int t,int lb){\n\tif(dp[v][f][t][lb]!=-1)return dp[v][f][t][lb];\n\tif(f==t)return 1;\n\tif(str[f].size()==v){\n\t\tif(lb==0){\n\t\t\treturn solve(v,f+1,t,lb+1);\n\t\t}\n\t\telse return 0;\n\t}\n\tfor(int i=f+1;i<t;i++){\n\t\tif(str[i].size()==v)return 0;\n\t}\n\tll ans=0;\n\tfor(int i=max(lb,1);i<27;i++){\n\t\tfor(int j=f;j<t;j++){\n\t\t\tif(str[k][v]!='?' && (str[k][v]-'a')!=(i-1))break;\n\t\t\tans+=solve(v+1,f,j+1,0)*solve(v,j+1,t,i+1)%MOD;\n\t\t\tans%=MOD;\n\t\t}\n\t}\n\tdp[v][f][t][lb]=ans;\n\treturn ans;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tcin >> str[i];\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tprintf(\"%lld\\n\",solve(0,0,n,0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nint n;\nstring s[55];\nint c[55][25];\nllint memo[55][55][25][30];\n\nllint calc(int i, int j, int k, int l)\n{\n\t//cout << i << j << k << l << endl;\n\t\n\tif(memo[i][j][k][l] != -1) return memo[i][j][k][l];\n\tif(i >= j) return 1;\n\tif(l > 26) return 0;\n\t\n\tif(l == 0){\n\t\tif(c[i][k] == 0){\n\t\t\tif(i+1 == j && c[i+1][k] == 0) return 0;\n\t\t\telse return memo[i][j][k][l] = calc(i+1, j, k, 0);\n\t\t}\n\t\telse return memo[i][j][k][l] = calc(i, j, k, 1);\n\t}\n\t\n\tllint ret = 0;\n\tret += calc(i, j, k, l+1);\n\tfor(int x = i; x <= j; x++){\n\t\tif(c[x][k] != -1){\n\t\t\tif(c[x][k] < l) return memo[i][j][k][l] = 0;\n\t\t\tif(c[x][k] > l) break;\n\t\t}\n\t\tif(x < j) ret += calc(i, x, k+1, 0) * calc(x+1, j, k, l+1) % mod;\n\t\telse ret += calc(i, j, k+1, 0) % mod;\n\t\tret %= mod;\n\t}\n\t//cout << i << j << k << l << \" \" << ret << endl;\n\treturn memo[i][j][k][l] = ret;\n}\n\nint main(void)\n{\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++) cin >> s[i];\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 0; j < s[i].size(); j++){\n\t\t\tif(s[i][j] == '?') c[i][j] = -1;\n\t\t\telse c[i][j] = s[i][j] - 'a' + 1;\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= 51; i++){\n\t\tfor(int j = 1; j <= 51; j++){\n\t\t\tfor(int k = 0; k < 25; k++){\n\t\t\t\tfor(int l = 0; l < 30; l++){\n\t\t\t\t\tmemo[i][j][k][l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << calc(1, n, 0, 0) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nll MOD = 1000000007;\n\nint dp[21][51][51];\n\nbool check(char c, char d) {\n\treturn c == d || (c != '`' && d == '?');\n}\n\nint main() {\n\tint n; cin >> n;\n\tvector<string> s(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tfor (; s[i].size() < 20; s[i].push_back('`'));\n\t}\n\tfor (int i = 0; i <= n; i++)\n\t\tdp[20][i][i] = 1;\n\tfor (int i = 0; i + 1 <= n; i++)\n\t\tdp[20][i][i + 1] = 1;\n\tfor (int k = 19; k >= 0; k--)\n\t\tfor (int l = 0; l <= n; l++) {\n\t\t\tvector<int> a(n + 1);\n\t\t\ta[l] = 1;\n\t\t\tfor (char c = '`'; c <= 'z'; c++)\n\t\t\t\tfor (int i = n; i >= l; i--)\n\t\t\t\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\t\t\t\tif (!check(c, s[j - 1][k])) break;\n\t\t\t\t\t\ta[j] = (a[j] + (ll)a[i] * dp[k + 1][i][j]) % MOD;\n\t\t\t\t\t}\n\t\t\tfor (int r = l; r <= n; r++)\n\t\t\t\tdp[k][l][r] = a[r];\n\t\t}\n\tcout << dp[0][0][n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint n;\nint dp[55][55][22][33];\nvs v;\n\nll solve(int u, int d, int p, int c)\n{\n\tif (dp[u][d][p][c] >= 0) return dp[u][d][p][c];\n\tif (u == d) return 1;\n\tif (v[u].size() == p)\n\t{\n\t\tif (c != 0) return 0;\n\t\telse if (d - u == 1) return 1;\n\t\telse if (v[u + 1].size() > p) return solve(u + 1, d, p, c);\n\t}\n\tif (c == 26) return 0;\n\tll res = 0;\n\tFOR(i, u, d + 1)\n\t{\n\t\tres += (solve(u, i, p + 1, 0) * solve(i, d, p, c + 1)) % MOD;\n\t\tres %= MOD;\n\t\tif (i != d && v[i][p] != '?' && v[i][p] != 'a' + c) break;\n\t}\n\treturn dp[u][d][p][c] = res;\n}\n\nint main()\n{\n\tMS(dp, -1);\n\tcin >> n;\n\tv.resize(n);\n\tREP(i, n)\n\t{\n\t\tcin >> v[i];\n\t}\n\tcout << solve(0, n, 0, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n \nll mod=1000000007;\n \nll add(ll a,ll b){\n  return (a+b+mod+mod)%mod;\n}\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n \nll dp[51][51][21][26];\nint n;\nchar t[50][20];\n \nll rec(int ay,int by,int x,char ch){\n  \n  if(ay==by)return 1;\n \n\n  if(x==19){\n    for(int i=ay+1;i<by;i++){\n      if(t[i-1][x] >= t[i][x])return 0;\n    }\n    return 1;\n  }\n \n \n  int CH=ch-'a';\n  if(dp[ay][by][x][CH]!=-1)return dp[ay][by][x][CH];\n \n   \n  if(ch>'z')return 0;\n\n  ll res=rec(ay,by,x,ch+1);\n \n \n  int next=ay;\n  for(int i=ay;i<by;i++){\n    if(t[i][x]==ch)next=i;\n  }\n   \n  for(int i=ay;i<next;i++){\n    if(t[i][x]!=ch&&t[i][x]!='?')\n      return 0;\n  }\n \n  for(int i=next;i<by;i++){\n    if(t[i][x]!='?'&&t[i][x]!=ch)break;\n    res=add(res, mul( rec(ay,i+1,x+1,'a') , rec(i+1,by,x,ch+1)) );\n  }\n\n\n  if(res>0){\n    //    cout<<ay<<' '<<by<<' '<<x<<' '<<CH<<endl;\n  }\n  return dp[ay][by][x][CH]=res;\n}\n \n \n \nint main(){\n  for(int i=0;i<51;i++)\n    for(int j=0;j<51;j++) \n      for(int k=0;k<21;k++)\n\tfor(int l=0;l<26;l++)\n\t  dp[i][j][k][l]=-1;\n   \n  for(int i=0;i<50;i++)\n    for(int j=0;j<20;j++)\n      t[i][j]='a';\n \n  string str;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>str;\n    for(int j=0;j<(int)str.size();j++)\n      t[i][j]=str[j];\n  }\n  //  cout<<rec(1,3,4,'e')<<'-'<<endl; \n  // cout<<rec(1,2,4,'e')<<'-'<<endl; \n  //  cout<<rec(2,3,3,'l')<<'-'<<endl; \n  cout<<rec(0,n,0,'a')<<endl; \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 55\n#define int long long\nusing namespace std;\nconst int s = ('a'-1);\nconst int mod = (1e9)+7;\nint n;\nstring str[N];\n\nint calc(int y,int x,int ch){\n  if(x>=(int)str[y].size() || ch>=27) return 0;\n  int k = 0;\n  if(str[y][x] != '?') k = 1;\n  if(str[y][x] == '?') k = 27 - ch;\n  if(k == 0) return 0;\n  int res = 1;\n  for(++x;x<(int)str[y].size();x++) if(str[y][x]=='?') res = (res*26)%mod;\n  return (res*k)%mod;\n}\n\n\nbool check(int u,int d,int x,char ch){\n  for(int y=u;y<=d;y++) if(str[y][x] != '?' && str[y][x] != ch) return 0;\n  return  1;\n}\n\nint mem[N][N][22][30],used[N][N][22][30];\nint dfs(int u,int d,int x,int c){\n  if(u > d) return 1;\n  if(u == d) return calc(u,x,c);\n  if(x >= 21) return 0;\n  if(c > 26) return 0;\n  if(str[u][x] == s) return (c == 1 && str[u+1][x] != s ? dfs(u+1,d,x,c):0);\n  if(used[u][d][x][c]++) return mem[u][d][x][c];\n\n  vector<int> mnc(N,30);\n  for(int y=d;y>=u;y--)mnc[y] = min(mnc[y+1],str[y][x]=='?'? 30:str[y][x] - s);  \n  \n  int res = dfs(u,d,x,c+1); \n  //[u,y]?????????????????????????????????????????????\n  for(int y=u;y<=d;y++){\n    if(mnc[y+1] <= c || !check(u,y,x,c+s)) continue;\n    res = (res+(dfs(u,y,x+1,1)*dfs(y+1,d,x,c+1))%mod)%mod;\n  }\n    return mem[u][d][x][c] = res;\n}\n\n\nsigned main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>str[i];\n    while(str[i].size()<21) str[i]+=s;\n  }\n  cout<<dfs(0,n-1,0,1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n  \nll mod=1000000007;\n  \nll add(ll a,ll b){\n  return (a+b+mod+mod)%mod;\n}\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n  \nll dp[51][51][21][27];\nint n;\nbool f[50][21];\nchar t[50][21];\n  \nll rec(int ay,int by,int x,char ch){\n   \n \n \n  if(ay==by)return 1;\n \n  bool flag=true;\n  for(int i=ay;i<by;i++)\n    if(f[i][x]==true)\n      flag=false;\n \n \n  if(flag){\n    for(int i=ay+1;i<by;i++){\n      if(t[i-1][x-1] >= t[i][x-1])return 0;\n    }\n    return 1;\n  }\n  \n  \n  int CH=ch-'a';\n  if(dp[ay][by][x][CH]!=-1)return dp[ay][by][x][CH];\n  \n \n   \n  if(f[ay][x]==false){\n    return rec(ay+1,by,x,ch);\n  }\n \n  if(ch>'z')return 0;\n \n  ll res=rec(ay,by,x,ch+1);\n  \n  \n  int next=ay;\n  for(int i=ay;i<by;i++){\n    if(t[i][x]==ch)next=i;\n  }\n    \n  for(int i=ay;i<next;i++){\n    if(t[i][x]!=ch&&t[i][x]!='?')\n      return 0;\n  }\n  \n  for(int i=next;i<by;i++){\n    if(t[i][x]!='?'&&t[i][x]!=ch)break;\n    res=add(res, mul( rec(ay,i+1,x+1,'a') , rec(i+1,by,x,ch+1)) );\n  }\n \n \n  if(res>0){\n    //    cout<<ay<<' '<<by<<' '<<x<<' '<<CH<<endl;\n  }\n  return dp[ay][by][x][CH]=res;\n}\n  \n  \n  \nint main(){\n  for(int i=0;i<51;i++)\n    for(int j=0;j<51;j++)\n      for(int k=0;k<21;k++)\n    for(int l=0;l<27;l++)\n      dp[i][j][k][l]=-1;\n    \n  for(int i=0;i<50;i++){\n    for(int j=0;j<21;j++){\n      t[i][j]='a';\n      f[i][j]=false;\n    }\n  }\n  string str;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>str;\n    for(int j=0;j<(int)str.size();j++){\n      t[i][j]=str[j];\n      f[i][j]=true;\n    }\n  }\n\n  //cout<<rec(1,2,1,'a')<<'-'<<endl;\n  cout<<rec(0,n,0,'a')<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll mod=1000000007;\n\nll add(ll a,ll b){\n  return (a+b+mod+mod)%mod;\n}\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n\nll dp[51][51][21][26];\nint n;\nchar t[50][20];\n\nll rec(int ay,int by,int x,char ch){\n \n\n\n\n  if(ay==by)return 1;\n\n  if(x==19){\n    for(int i=ay+1;i<by;i++){\n      if(t[i-1][x] > t[i][x])return 0;\n    }\n    return 1;\n  }\n\n  if(ch>'z')return 0;\n\n\n  int CH=ch-'a';\n  if(dp[ay][by][x][CH]!=-1)return dp[ay][by][x][CH];\n\n  \n\n  ll res=rec(ay,by,x,ch+1);\n\n\n  int next=ay;\n  for(int i=ay;i<by;i++){\n    if(t[i][x]==ch)next=i;\n  }\n  \n  for(int i=ay;i<next;i++){\n    if(t[i][x]!=ch&&t[i][x]!='?')\n      return 0;\n  }\n\n  for(int i=next;i<by;i++){\n    if(t[i][x]!='?'&&t[i][x]!=ch)break;\n    res=add(res, mul( rec(ay,i+1,x+1,'a') , rec(i+1,by,x,ch+1)) );\n  }\n  if(res>0&&x<5){\n    cout<<ay<<' '<<by<<' '<<x<<' '<<ch<<' '<<res<<endl;\n    // 1 3 3 k 2\n  }\n  return dp[ay][by][x][CH]=res;\n}\n\n\n\nint main(){\n  for(int i=0;i<51;i++)\n    for(int j=0;j<51;j++)\n\n\n\n      for(int k=0;k<21;k++)\n\tfor(int l=0;l<26;l++)\n\t  dp[i][j][k][l]=-1;\n  \n  for(int i=0;i<50;i++)\n    for(int j=0;j<20;j++)\n      t[i][j]='a';\n\n  string str;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>str;\n    for(int j=0;j<(int)str.size();j++)\n      t[i][j]=str[j];\n  }\n  cout<<rec(1,3,3,'l')<<'-'<<endl;  \n  cout<<rec(1,2,4,'e')<<'-'<<endl;  \n  cout<<rec(2,3,3,'l')<<'-'<<endl;  \n  cout<<rec(0,n,0,'a')<<endl;  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nint n;\nstring s[55];\nint c[55][25];\nllint memo[55][55][25][30];\n\nllint calc(int i, int j, int k, int l)\n{\n\t//cout << i << j << k << l << endl;\n\t\n\tif(memo[i][j][k][l] != -1) return memo[i][j][k][l];\n\tif(i > j) return 1;\n\tif(l > 26) return 0;\n\t\n\tif(l == 0){\n\t\tif(c[i][k] == 0){\n\t\t\tif(i+1 == j && c[i+1][k] == 0) return 0;\n\t\t\telse return memo[i][j][k][l] = calc(i+1, j, k, 0);\n\t\t}\n\t\telse return memo[i][j][k][l] = calc(i, j, k, 1);\n\t}\n\t\n\tllint ret = 0;\n\tret += calc(i, j, k, l+1);\n\tfor(int x = i; x <= j; x++){\n\t\tif(c[x][k] != -1){\n\t\t\tif(c[x][k] < l) return memo[i][j][k][l] = 0;\n\t\t\tif(c[x][k] > l) break;\n\t\t}\n\t\tif(x < j) ret += calc(i, x, k+1, 0) * calc(x+1, j, k, l+1) % mod;\n\t\telse ret += calc(i, j, k+1, 0) % mod;\n\t\tret %= mod;\n\t}\n\t//cout << i << j << k << l << \" \" << ret << endl;\n\treturn memo[i][j][k][l] = ret;\n}\n\nint main(void)\n{\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++) cin >> s[i];\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 0; j < s[i].size(); j++){\n\t\t\tif(s[i][j] == '?') c[i][j] = -1;\n\t\t\telse c[i][j] = s[i][j] - 'a' + 1;\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= 51; i++){\n\t\tfor(int j = 1; j <= 51; j++){\n\t\t\tfor(int k = 0; k < 25; k++){\n\t\t\t\tfor(int l = 0; l < 30; l++){\n\t\t\t\t\tmemo[i][j][k][l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << calc(1, n, 0, 0) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#define mod 1000000007\nusing namespace std;\nint n, p[21], c[50][21], dp[50][51][21]; string s[50];\nint solve(int l, int r, int k) {\n\tif(r - l == 1) return p[c[l][k]];\n\tif(dp[l][r][k]) return dp[l][r][k] - 1;\n\tint dp2[51][27] = {0}; dp2[l][0] = 1;\n\tfor(int a = l + 1; a <= r; a++) {\n\t\tint sum[51] = {0};\n\t\tfor(int b = 1; b <= 26; b++) {\n\t\t\tfor(int c = l; c < r; c++) sum[c] += dp2[c][b - 1];\n\t\t\tfor(int c = a - 1; c >= l; c--) {\n\t\t\t\tif((s[c][k] != '?' && s[c][k] != b + 96) || (c + 1 != a && s[c].size() == k + 1)) break;\n\t\t\t\tint res = solve(c, a, k + 1);\n\t\t\t\tdp2[a][b] = (dp2[a][b] + 1LL * sum[c] * res) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i = 1; i <= 26; i++) ret += dp2[r][i];\n\tdp[l][r][k] = ret + 1;\n\treturn ret;\n}\nint main() {\n\tcin >> n; p[0] = 1;\n\tfor(int i = 1; i <= 20; i++) p[i] = 1LL * p[i - 1] * 26 % mod;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tfor(int j = s[i].size() - 1; j >= 0; j--) c[i][j] = c[i][j + 1] + (s[i][j] == '?' ? 1 : 0);\n\t}\n\tprintf(\"%d\\n\", solve(0, n, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nlong long n, res[22][55][55], power26[27], mod = 1000000007; string S[55];\n\nlong long solve(int pos, int l, int r) {\n\tif (l > r) return 1;\n\tif (res[pos][l][r] >= 1) return res[pos][l][r] - 1;\n\tif (pos == 20) return 1;\n\tlong long dp[28][55];\n\tfor (int i = l - 1; i <= r; i++) {\n\t\tfor (int j = 0; j < 28; j++) dp[j][i] = 0;\n\t}\n\tdp[0][l - 1] = 1;\n\tfor (int i = 0; i < 27; i++) {\n\t\tfor (int j = l - 1; j <= r; j++) {\n\t\t\tlong long P = 1;\n\t\t\tfor (int k = j; k <= r; k++) {\n\t\t\t\tif (pos == 19 && k - j >= 2) continue;\n\n\t\t\t\tif (k != j && S[k][pos] != (char)(95 + i + 1) && (i == 0 || S[k][pos] != '?')) P = 0;\n\t\t\t\tlong long Q = dp[i][j] * P*solve(pos + 1, j + 1, k);\n\t\t\t\tdp[i + 1][k] += Q; dp[i + 1][k] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tres[pos][l][r] = dp[27][r] + 1;\n\treturn res[pos][l][r] - 1;\n}\n\nint main() {\n\tcin >> n;\n\tpower26[0] = 1; for (int i = 1; i < 21; i++) { power26[i] = (power26[i - 1] * 26LL) % mod; }\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> S[i];\n\t\twhile (S[i].size() <= 20) S[i] += (char)(96);\n\t}\n\tcout << solve(0, 1, n) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#define mod 1000000007\nusing namespace std;\nint n, p[22], e[55][22], dp[55][55][22]; string s[55];\nint solve(int l, int r, int k) {\n\tif(r - l == 1) return p[e[l][k]];\n\tif(dp[l][r][k]) return dp[l][r][k] - 1;\n\tint dp2[55][30] = {0}; dp2[l][0] = 1;\n\tfor(int a = l + 1; a <= r; a++) {\n\t\tint sum[55] = {0};\n\t\tfor(int b = 1; b <= 26; b++) {\n\t\t\tfor(int c = l; c < r; c++) sum[c] += dp2[c][b - 1];\n\t\t\tfor(int c = a - 1; c >= l; c--) {\n\t\t\t\tif((s[c][k] != '?' && s[c][k] != b + 96) || (c + 1 != a && s[c].size() == k + 1)) break;\n\t\t\t\tint res = solve(c, a, k + 1);\n\t\t\t\tdp2[a][b] = (dp2[a][b] + 1LL * sum[c] * res) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i = 1; i <= 26; i++) ret += dp2[r][i];\n\tdp[l][r][k] = ret + 1;\n\treturn ret;\n}\nint main() {\n\tcin >> n; p[0] = 1;\n\tfor(int i = 1; i <= 20; i++) p[i] = 1LL * p[i - 1] * 26 % mod;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tfor(int j = s[i].size() - 1; j >= 0; j--) e[i][j] = e[i][j + 1] + (s[i][j] == '?' ? 1 : 0);\n\t}\n\tprintf(\"%d\\n\", solve(0, n, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#define mod 1000000007\nusing namespace std;\nint n, p[21], c[50][21], dp[50][51][21]; string s[50];\nint solve(int l, int r, int k) {\n\tif(r - l == 1) return p[c[l][k]];\n\tif(dp[l][r][k]) return dp[l][r][k] - 1;\n\tint dp2[51][27] = {0}; dp2[l][0] = 1;\n\tfor(int a = l + 1; a <= r; a++) {\n\t\tfor(int b = 1; b <= 26; b++) {\n\t\t\tfor(int c = a - 1; c >= l; c--) {\n\t\t\t\tif((s[c][k] != '?' && s[c][k] != b + 96) || (c + 1 != a && s[c].size() == k + 1)) break;\n\t\t\t\tint res = solve(c, a, k + 1), r = 1;\n\t\t\t\tfor(int d = b - 1; d >= 0; d--) r = (r + dp2[c][d]) % mod;\n\t\t\t\tdp2[a][b] += (dp[a][b] + 1LL * res * r) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i = 1; i <= 26; i++) ret += dp2[r][i];\n\tdp[l][r][k] = ret + 1;\n\treturn ret;\n}\nint main() {\n\tcin >> n; p[0] = 1;\n\tfor(int i = 1; i <= 20; i++) p[i] = 1LL * p[i - 1] * 26 % mod;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tfor(int j = s[i].size() - 1; j >= 0; j--) c[i][j] = c[i][j + 1] + (s[i][j] == '?' ? 1 : 0);\n\t}\n\tprintf(\"%d\\n\", solve(0, n, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nint sfx = 'a' - 1;\n\nint N;\nVS vs;\nint dp[64][64][32][32];\nLL solve(int b, int e, int p, int lb){\n  int& ret = dp[b][e][p][lb];\n  if(~ret) return ret;\n  if(b >= e) return ret = 1;\n  \n  if(lb == 27) return ret = 0;\n  if(p == 20) return ret = (e-b == 1);\n\n  ret = 0;\n  LL res = solve(b,e,p,lb+1);\n  for(int i=b;i<e;++i){\n\tif(vs[i][p] != '?'){\n\t  int c = vs[i][p] - sfx;\n\t  if(c != lb) break;\n\t}\n\telse if(lb == 0) break;\n\t(res += solve(b, i+1, p+1, 0) * solve(i+1, e, p, lb+1) % MOD) %= MOD;\n  }\n  return ret = res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> N;\n  vs.resize(N);\n  REP(i,N){\n\tcin >> vs[i];\n\tvs[i] += string(20-SZ(vs[i]), sfx);\n  }\n\n  fill((int*)dp, (int*)dp+64*64*32*32, -1);\n  cout << solve(0, N, 0, 0) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n#define mod 1000000007\nint n; string s[55];\nll dp[55][55][25]; bool u[55][55][25];\nint nm[55][55][25];\nll rec(int L,int R,int num){\n\tif(u[L][R][num]) return dp[L][R][num];\n\tu[L][R][num] = 1;\n\tif(L==R){\n\t      dp[L][R][num] = 1;\n\t      for(int j=num-1;j<s[L].size();j++) if(s[L][j]=='?') dp[L][R][num] = (dp[L][R][num]*26LL)%mod;\n\t      return dp[L][R][num];\n\t}\n\tint cnt = 0;\n\tfor(int i=L;i<=R;i++){\n\t\tif(s[i].size() < num){\n\t\t\tif(i != L || cnt) return dp[L][R][num] = 0;\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif(cnt){\n\t\tif(cnt == R-L+1){\n\t\t\treturn dp[L][R][num] = 1;\n\t\t}\n\t\telse return dp[L][R][num] = rec(L+cnt,R,num);\n\t}\n\tll t[55][30] = {};\n\tt[L-1][0] = 1;\n\tfor(int i=L;i<=R;i++){\n\t\tfor(int j=L-1;j<i;j++){\n\t\t\tif(nm[j+1][i][num] > 0){\n\t\t\t\t//dp[j+1][i][num+1] wo kentou\n\t\t\t\tint k = nm[j+1][i][num];\n\t\t\t\t{\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int l=0;l<k;l++) t[i][k] = (t[i][k] + t[j][l]*rec(j+1,i,num+1)%mod)%mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tll R = rec(j+1,i,num+1);\n\t\t\t\tll T = 0;\n\t\t\t\tfor(int k=1;k<=26;k++){\n\t\t\t\t\tT = (T+t[j][k-1])%mod;\n\t\t\t\t\tt[i][k] = (t[i][k]+T*R%mod)%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=26;i++) dp[L][R][num] = (dp[L][R][num]+t[R][i])%mod;\n\treturn dp[L][R][num];\n}\nint main(){\n\tcin >> n;\n\tfor(int i=1;i<=n;i++) cin >> s[i];\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i;j<=n;j++){\n\t\t\tfor(int k=1;k<=20;k++){\n\t\t\t\tfor(int x=i;x<=j;x++){\n\t\t\t\t\tif(s[x].size()>=k){\n\t\t\t\t\t\tif(s[x][k-1] != '?'){\n\t\t\t\t\t\t\tif(nm[i][j][k] == 0) nm[i][j][k] = 1 + (s[x][k-1]-'a');\n\t\t\t\t\t\t\telse if(nm[i][j][k] != 1 + (s[x][k-1]-'a')) nm[i][j][k] = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << rec(1,n,1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n \nll mod=1000000007;\n \nll add(ll a,ll b){\n  return (a+b+mod+mod)%mod;\n}\nll mul(ll a,ll b){\n  return (a*b)%mod;\n}\n \nll dp[51][51][21][26];\nint n;\nchar t[50][20];\n \nll rec(int ay,int by,int x,char ch){\n\n  if(ay==by)return 1;\n \n  if(ch>'z')return 0;\n  if(x==19){\n    for(int i=ay+1;i<by;i++){\n      if(t[i-1][x] >= t[i][x])return 0;\n    }\n    return 1;\n  }\n \n \n \n \n  int CH=ch-'a';\n  if(dp[ay][by][x][CH]!=-1)return dp[ay][by][x][CH];\n \n   \n \n  ll res=rec(ay,by,x,ch+1);\n \n \n  int next=ay;\n  for(int i=ay;i<by;i++){\n    if(t[i][x]==ch)next=i;\n  }\n   \n  for(int i=ay;i<next;i++){\n    if(t[i][x]!=ch&&t[i][x]!='?')\n      return 0;\n  }\n \n  for(int i=next;i<by;i++){\n    if(t[i][x]!='?'&&t[i][x]!=ch)break;\n    res=add(res, mul( rec(ay,i+1,x+1,'a') , rec(i+1,by,x,ch+1)) );\n  }\n\n  return dp[ay][by][x][CH]=res;\n}\n \n \n \nint main(){\n  for(int i=0;i<51;i++)\n    for(int j=0;j<51;j++)\n \n \n \n      for(int k=0;k<21;k++)\n    for(int l=0;l<26;l++)\n      dp[i][j][k][l]=-1;\n   \n  for(int i=0;i<50;i++)\n    for(int j=0;j<20;j++)\n      t[i][j]='a';\n \n  string str;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>str;\n    for(int j=0;j<(int)str.size();j++)\n      t[i][j]=str[j];\n  }\n  //  cout<<rec(1,3,4,'e')<<'-'<<endl; \n  // cout<<rec(1,2,4,'e')<<'-'<<endl; \n  //  cout<<rec(2,3,3,'l')<<'-'<<endl; \n  cout<<rec(0,n,0,'a')<<endl; \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#define mod 1000000007\nusing namespace std;\nint n, p[22], e[55][22], dp[55][55][22]; string s[55];\nint solve(int l, int r, int k) {\n\tif(r - l == 1) return p[e[l][k]];\n\tif(dp[l][r][k]) return dp[l][r][k] - 1;\n\tint dp2[55][30] = {0}; dp2[l][0] = 1;\n\tfor(int a = l + 1; a <= r; a++) {\n\t\tint sum[55] = {0};\n\t\tfor(int b = 1; b <= 26; b++) {\n\t\t\tfor(int c = l; c < r; c++) sum[c] = (sum[c] + dp2[c][b - 1]) % mod;\n\t\t\tfor(int c = a - 1; c >= l; c--) {\n\t\t\t\tif((s[c][k] != '?' && s[c][k] != b + 96) || (c + 1 != a && s[c].size() == k + 1)) break;\n\t\t\t\tint res = solve(c, a, k + 1);\n\t\t\t\tdp2[a][b] = (dp2[a][b] + 1LL * sum[c] * res) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i = 1; i <= 26; i++) ret = (ret + dp2[r][i]) % mod;\n\tdp[l][r][k] = ret + 1;\n\treturn ret;\n}\nint main() {\n\tcin >> n; p[0] = 1;\n\tfor(int i = 1; i <= 20; i++) p[i] = 1LL * p[i - 1] * 26 % mod;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tfor(int j = s[i].size() - 1; j >= 0; j--) e[i][j] = e[i][j + 1] + (s[i][j] == '?' ? 1 : 0);\n\t}\n\tprintf(\"%d\\n\", solve(0, n, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 55\n#define int long long\nusing namespace std;\nconst int s = ('a'-1);\nconst int mod = (1e9)+7;\nint n;\nstring str[N];\n\nint mem[N][N][22][30],used[N][N][22][30];\nint calc(int y,int x,int ch){\n  int res = 0;\n  if(x>=(int)str[y].size() || ch>=27) return 0;\n  \n  if(str[y][x] != '?') res = 1;\n  if(str[y][x] == '?') res = 27 - ch;\n  for(++x;x<(int)str[y].size();x++) if(str[y][x]=='?') res = (res*26)%mod;\n  return res;\n}\n\n\nbool check(int u,int d,int x,char ch){\n  static int memc[N][N][22][30],usedc[N][N][22][30];\n  if(usedc[u][d][x][ch-s]++) return memc[u][d][x][ch-s];\n  for(int y=u;y<=d;y++) if(str[y][x]!='?' && str[y][x]!=ch) return memc[u][d][x][ch-s]=0;\n  return  memc[u][d][x][ch-s]=1;\n}\n\nbool check2(int u,int d,int x,char ch){\n  static int memc[N][N][22][30],usedc[N][N][22][30];\n  if(usedc[u][d][x][ch-s]++) return memc[u][d][x][ch-s];\n  for(int y=u;y<=d;y++) if(str[y][x] != '?' && str[y][x] <= ch) return memc[u][d][x][ch-s]=0;\n  return memc[u][d][x][ch-s]=1;\n}\n\nint dfs(int u,int d,int x,int c){\n  if(u > d) return 1;\n  if(u == d) return calc(u,x,c);\n  if(x >= 21) return 0;\n  if(used[u][d][x][c]++) return mem[u][d][x][c];\n  int res = 0; \n\n  //[u,y]?????????????????????????????????????????????\n  for(int ch=c;ch<=26;ch++){\n    for(int y=u;y<=d;y++){\n      if(check(u,y,x,ch+s) == false)continue;\n      if(check2(y+1,d,x,ch+s) == false)continue;\n      res = (res+(dfs(u,y,x+1,1)*dfs(y+1,d,x,ch+1))%mod)%mod;\n    }\n  }\n  return mem[u][d][x][c] = res;\n}\n\n\nsigned main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>str[i];\n    while(str[i].size()<21) str[i]+=s;\n  }\n  cout<<dfs(0,n-1,0,1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\nint dp[55][55][30][30];\nchar s[55][25];\nchar base = 'a'-1;\n\n//[l,r)ab\nint f(int l, int r, int a, int b){\n    if(dp[l][r][a][b] != -1)return dp[l][r][a][b];\n    if(l >= r)return dp[l][r][a][b] = 1;\n    int ret = 0;\n    if(b == 27) return dp[l][r][a][b] = ret;\n    if(a == 20) return dp[l][r][a][b] = r-l == 1;\n    loop(i,l,r+1){\n        if(i != l && s[i-1][a] != base+b && s[i-1][a] != '?')break;\n        if(i != l && s[i-1][a] == '?' && b == 0)break;\n        ret += f(l,i,a+1,0)*f(i,r,a,b+1)%MOD;\n        ret %= MOD;\n    }\n    return dp[l][r][a][b] = ret;\n}\n\nsigned main(void) {\n    rep(i,55)rep(j,55)rep(k,30)rep(l,30)dp[i][j][k][l] = -1;\n    int n;\n    cin >> n;\n    rep(i,n){\n        cin >> s[i];\n        for(int j = strlen(s[i]); j < 20; j++) s[i][j] = base;\n    }\n    cout << f(0,n,0,0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MOD 1000000007LL\ntypedef long long ll;\n\nint n;\nll dp[21][51][51][28];\nstring str[51];\n\nll solve(int v,int f,int t,int lb){\n\tif(dp[v][f][t][lb]!=-1)return dp[v][f][t][lb];\n\tif(f==t)return 1;\n\tif(str[f].size()==v){\n\t\tif(lb==0){\n\t\t\treturn solve(v,f+1,t,lb+1);\n\t\t}\n\t\telse return 0;\n\t}\n\tfor(int i=f+1;i<t;i++){\n\t\tif(str[i].size()==v)return 0;\n\t}\n\tll ans=0;\n\tfor(int i=max(lb,1);i<27;i++){\n\t\tfor(int j=f;j<t;j++){\n\t\t\tbool flag=true;\n\t\t\tfor(int k=f;k<=j;k++){\n\t\t\t\tif(str[k][v]!='?' && (str[k][v]-'a')!=(i-1)){\n\t\t\t\t\tflag=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tans+=solve(v+1,f,j+1,0)*solve(v,j+1,t,i+1)%MOD;\n\t\t\t}\n\t\t}\n\t}\n\tdp[v][f][t][lb]=ans;\n\treturn ans;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tcin >> str[i];\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tprintf(\"%lld\\n\",solve(0,0,n,0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma warning(disable:4996)\n#ifdef _MSC_VER\n#  define __builtin_popcount __builtin_popcountll\n#  define __builtin_popcountll __popcnt\n#endif\n//#define int long long\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst long double PI = acos(-1.0);\nconst int dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\ninline void my_io() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tstd::cout << fixed << setprecision(10);\n}\n\nsigned main(){\n\t\n\tint n;\n\tcin >> n;\n\tunordered_set<string>st;\n\tfor (int i = 0; i < n; i++) {\n\t\tstring str;\n\t\tcin >> str;//find or insert\n\t\tstring str1;//a g t c\n\t\tcin >> str1;\n\t\tif (str == \"insert\") {\n\t\t\tst.emplace(str1);\n\t\t}\n\t\telse {\n\t\t\tif (st.count(str1)) {\n\t\t\t\tcout << \"yes\" << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"no\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\n\n}\t\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long Int;\n\nconst int MOD = 1000000007;\n\nchar str[64][32];\nInt dp[64][64][32][32];\n\nInt func(int r1, int r2, int c, int alpha)\n{\n\tif (alpha >= 27 || c > 20) return (0);\n\tif (dp[r1][r2][c][alpha] >= 0) return (dp[r1][r2][c][alpha]);\n\tif (r1 == r2 && c == 20) return (1);\n\n\tInt ans = func(r1, r2, c, alpha + 1);\n\n\tfor (int i = r1; i <= r2; i++){\n\t\tif (str[i][c] == (alpha == 0 ? '$' : alpha - 1 + 'a') || (alpha != 0 && str[i][c] == '?'))\n\t\t\tans = (ans + func(r1, i, c + 1, 0) * (i == r2 ? 1 : func(i + 1, r2, c, alpha + 1)) % MOD) % MOD;\n\t\telse break;\n\t}\n\n\treturn (dp[r1][r2][c][alpha] = ans);\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tmemset(str, '$', sizeof(str));\n\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%s\", str[i]);\n\t\tstr[i][strlen(str[i])] = '$';\n\t\tstr[i][20] = 0;\n\t}\n\n\tmemset(dp, -1, sizeof(dp));\n\tprintf(\"%lld\\n\", func(0, n - 1, 0, 0));\n\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#define mod 1000000007\nusing namespace std;\nint n, p[22], e[55][22], dp[55][55][22]; string s[55];\nint solve(int l, int r, int k) {\n\tif(r - l == 0) return 1;\n\tif(r - l == 1) return p[e[l][k]];\n\tif(dp[l][r][k]) return dp[l][r][k] - 1;\n\tint dp2[55][30] = {0}; dp2[l][0] = 1;\n\tfor(int a = l + 1; a <= r; a++) {\n\t\tint sum[55] = {0};\n\t\tfor(int b = 1; b <= 26; b++) {\n\t\t\tfor(int c = l; c < r; c++) sum[c] = (sum[c] + dp2[c][b - 1]) % mod;\n\t\t\tfor(int c = a - 1; c >= l; c--) {\n\t\t\t\tif((s[c][k] != '?' && s[c][k] != b + 96)) break;\n\t\t\t\tint res = (s[c].size() == k + 1) ? solve(c + 1, a, k + 1) : solve(c, a, k + 1);\n\t\t\t\tdp2[a][b] = (dp2[a][b] + 1LL * sum[c] * res) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i = 1; i <= 26; i++) ret = (ret + dp2[r][i]) % mod;\n\tdp[l][r][k] = ret + 1;\n\treturn ret;\n}\nint main() {\n\tcin >> n; p[0] = 1;\n\tfor(int i = 1; i <= 20; i++) p[i] = 1LL * p[i - 1] * 26 % mod;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tfor(int j = s[i].size() - 1; j >= 0; j--) e[i][j] = e[i][j + 1] + (s[i][j] == '?' ? 1 : 0);\n\t}\n\tprintf(\"%d\\n\", solve(0, n, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 55\n#define int long long\nusing namespace std;\nconst int s = ('a'-1);\nconst int mod = (1e9)+7;\nint n;\nstring str[N];\n\nint mem[N][N][22][30],used[N][N][22][30];\nint calc(int y,int x,int ch){\n  int res = 0;\n  if(x>=(int)str[y].size() || ch>=27) return 0;\n  \n  if(str[y][x] != '?') res = 1;\n  if(str[y][x] == '?') res = 27 - ch;\n  for(++x;x<(int)str[y].size();x++) if(str[y][x]=='?') res = (res*26)%mod;\n  return res;\n}\n\n\nbool check(int u,int d,int x,char ch){\n  static bool memc[N][N][22][30],usedc[N][N][22][30];\n  if(usedc[u][d][x][ch-s]) return memc[u][d][x][ch-s];\n  usedc[u][d][x][ch-s] = 1;\n  for(int y=u;y<=d;y++) if(str[y][x] != '?' && str[y][x] != ch) return memc[u][d][x][ch-s]=0;\n  return  memc[u][d][x][ch-s]=1;\n}\n\nbool check2(int u,int d,int x,char ch){\n  static bool memc[N][N][22][30],usedc[N][N][22][30];\n  if(usedc[u][d][x][ch-s]) return memc[u][d][x][ch-s];\n  usedc[u][d][x][ch-s] = 1;\n  for(int y=u;y<=d;y++) if(str[y][x] != '?' && str[y][x] <= ch) return memc[u][d][x][ch-s]=0;\n  return memc[u][d][x][ch-s]=1;\n}\n\nint dfs(int u,int d,int x,int c){\n  if(u > d) return 1;\n  if(u == d) return calc(u,x,c);\n  if(x >= 21) return 0;\n  if(str[u][x] == s && c == 1) return dfs(u+1,d,x,c);\n  if(used[u][d][x][c]++) return mem[u][d][x][c];\n  \n  int res = 0; \n\n  //[u,y]?????????????????????????????????????????????\n  for(int ch=c;ch<=26;ch++){\n    for(int y=u;y<=d;y++){\n      if(check(u,y,x,ch+s) == false)continue;\n      if(check2(y+1,d,x,ch+s) == false)continue;\n      res = (res+(dfs(u,y,x+1,1)*dfs(y+1,d,x,ch+1))%mod)%mod;\n    }\n  }\n  return mem[u][d][x][c] = res;\n}\n\n\nsigned main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>str[i];\n    while(str[i].size()<21) str[i]+=s;\n  }\n  cout<<dfs(0,n-1,0,1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#define mod 1000000007\nusing namespace std;\nint n, p[21], c[50][21], dp[50][51][21]; string s[50];\nint solve(int l, int r, int k) {\n\tif(r - l == 1) return p[c[l][k]];\n\tif(dp[l][r][k]) return dp[l][r][k] - 1;\n\tint dp2[51][27] = {0}; dp2[l][0] = 1;\n\tfor(int a = l + 1; a <= r; a++) {\n\t\tfor(int b = 1; b <= 26; b++) {\n\t\t\tfor(int c = a - 1; c >= l; c--) {\n\t\t\t\tif((s[c][k] != '?' && s[c][k] != b + 96) || (c + 1 != a && s[c].size() == k + 1)) break;\n\t\t\t\tint res = solve(c, a, k + 1), r = 0;\n\t\t\t\tfor(int d = b - 1; d >= 0; d--) r = (r + dp2[c][d]) % mod;\n\t\t\t\tdp2[a][b] = (dp2[a][b] + 1LL * r * res) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i = 1; i <= 26; i++) ret += dp2[r][i];\n\tdp[l][r][k] = ret + 1;\n\treturn ret;\n}\nint main() {\n\tcin >> n; p[0] = 1;\n\tfor(int i = 1; i <= 20; i++) p[i] = 1LL * p[i - 1] * 26 % mod;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tfor(int j = s[i].size() - 1; j >= 0; j--) c[i][j] = c[i][j + 1] + (s[i][j] == '?' ? 1 : 0);\n\t}\n\tprintf(\"%d\\n\", solve(0, n, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#define mod 1000000007\nusing namespace std;\nint n, dp[50][51][21]; string s[50];\nint solve(int l, int r, int k) {\n\tif(r - l == 1) {\n\t\tint ret = 1;\n\t\tfor(int i = k; i < s[l].size(); i++) {\n\t\t\tif(s[l][i] == '?') ret = 1LL * ret * 26 % mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tif(dp[l][r][k]) return dp[l][r][k] - 1;\n\tint dp2[51][27] = {0}; dp2[l][0] = 1;\n\tfor(int a = l + 1; a <= r; a++) {\n\t\tfor(int b = 1; b <= 26; b++) {\n\t\t\tfor(int c = a - 1; c >= l; c--) {\n\t\t\t\tbool flag1 = true, flag2 = true;\n\t\t\t\tfor(int d = c; d < a; d++) {\n\t\t\t\t\tif((s[d][k] != '?' && s[d][k] != b + 96) || (d != c && s[d].size() == k + 1)) {\n\t\t\t\t\t\tflag1 = false; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!flag1) continue;\n\t\t\t\tint res = flag2 ? solve(c, a, k + 1) : 1, r = 0;\n\t\t\t\tfor(int d = b - 1; d >= 0; d--) {\n\t\t\t\t\tdp2[a][b] = (dp2[a][b] + 1LL * dp2[c][d] * res) % mod;\n\t\t\t\t\tr = (r + 1LL * dp2[c][d] * res) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i = 1; i <= 26; i++) ret += dp2[r][i];\n\tdp[l][r][k] = ret + 1;\n\treturn ret;\n}\nint main() {\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) cin >> s[i];\n\tprintf(\"%d\\n\", solve(0, n, 0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint N;\nVS vs;\nint dp[51][51][21][27][27];\nLL solve(int b, int e, int p, int lb, int ub){\n  int& ret = dp[b][e][p][lb][ub];\n  if(ret >= 0) return ret;\n  if(b == e) return ret = 1;\n  if(lb >= ub) return ret = 0;\n  if(b+1 == e){\n\tLL res = 0;\n\tif(vs[b][p] == '?'){\n\t  res = ub - lb;\n\t}\n\telse{\n\t  int c = vs[b][p] - 'a';\n\t  if(!(lb <= c && c < ub))\n\t\treturn ret = 0;\n\t  res = 1;\n\t}\n\tfor(int i=p+1;i<SZ(vs[b]);++i)\n\t  if(vs[b][i] == '?')\n\t\t(res *= 26) %= MOD;\n\treturn ret = res;\n  }\n\n  ret = 0;\n  LL res = 0;\n  int c = -1;\n  for(int i=b;i<e;++i){\n\tif(SZ(vs[i]) <= p){\n\t  c = 27;\n\t  break;\n\t}\n\telse if(vs[i][p] != '?'){\n\t  int nc = vs[i][p] - 'a';\n\t  if(c < 0) c = nc;\n\t  else if(c != nc)\n\t\tc = 27;\n\t}\n\tif(c == 27)\n\t  break;\n\tif(c != -1){\n\t  if(lb <= c && c < ub)\n\t\t(res += solve(b, i+1, p+1, 0, 26) * solve(i+1, e, p, c+1, ub) % MOD) %= MOD;\n\t}\n\telse{\n\t  for(int c=lb;c<ub;++c){\n\t\t(res += solve(b, i+1, p+1, 0, 26) * solve(i+1, e, p, c+1, ub) % MOD) %= MOD;\n\t  }\n\t}\n  }\n  return ret = res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> N;\n  vs.resize(N);\n  REP(i,N) cin >> vs[i];\n  fill((int*)dp, (int*)dp+51*51*21*27*27, -1);\n  cout << solve(0, N, 0, 0, 26) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int mod = (int)(1e9 + 7)>\nstruct ModInt {\n  int x;\n  ModInt() : x(0) {}\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n  ModInt &operator+=(const ModInt &p) {\n    if ((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n  ModInt &operator-=(const ModInt &p) {\n    if ((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n  ModInt &operator*=(const ModInt &p) {\n    x = (int)(1LL * x * p.x % mod);\n    return *this;\n  }\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n  ModInt operator-() const { return ModInt(-x); }\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n  bool operator==(const ModInt &p) const { return x == p.x; }\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while (b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n  ModInt pow(int64_t n) const {\n    ModInt res(1), mul(x);\n    while (n) {\n      if (n & 1) res *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return res;\n  }\n  friend ostream &operator<<(ostream &os, const ModInt &p) { return os << p.x; }\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt<mod>(t);\n    return (is);\n  }\n  static int get_mod() { return mod; }\n};\n\nstruct Combination {\n  vector<ModInt<>> _fact, _rfact, _inv;\n  Combination(long long nsize = 5000000)\n      : _fact(nsize + 1), _rfact(nsize + 1), _inv(nsize + 1) {\n    _fact[0] = _rfact[nsize] = _inv[0] = 1;\n    for (int i = 1; i <= nsize; i++) _fact[i] = _fact[i - 1] * i;\n    _rfact[nsize] /= _fact[nsize];\n    for (int i = nsize - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n    for (int i = 1; i <= nsize; i++) _inv[i] = _rfact[i] * _fact[i - 1];\n  }\n  inline ModInt<> fact(int k) const { return _fact[k]; }\n\n  inline ModInt<> rfact(int k) const { return _rfact[k]; }\n\n  inline ModInt<> inv(int k) const { return _inv[k]; }\n\n  ModInt<> P(int n, int r) const {\n    if (r < 0 || n < r) return 0;\n    return fact(n) * rfact(n - r);\n  }\n\n  ModInt<> C(int p, int q) const {\n    if (q < 0 || p < q) return 0;\n    return fact(p) * rfact(q) * rfact(p - q);\n  }\n  // n types,choose r\n  ModInt<> H(int n, int r) const {\n    if (n < 0 || r < 0) return (0);\n    return r == 0 ? 1 : C(n + r - 1, r);\n  }\n};\n\nlong long lim = 20;\nlong long n;\nvector<string> s;\nvector<vector<vector<vector<bool>>>> reached;\nvector<vector<vector<vector<ModInt<>>>>> dp;\n\nModInt<> solve(int l, int r, int idx, int chr);\n\nint main() {\n  cin >> n;\n  s.resize(n);\n  for (int i = 0; i < n; ++i) cin >> s[i];\n  reached.assign(\n      n + 1, vector<vector<vector<bool>>>(\n                 n + 1, vector<vector<bool>>(lim + 1, vector<bool>(26, 0))));\n  dp.assign(n + 1, vector<vector<vector<ModInt<>>>>(\n                       n + 1, vector<vector<ModInt<>>>(\n                                  lim + 1, vector<ModInt<>>(26, 0))));\n  cout << solve(0, n, 0, 0) << endl;\n  return 0;\n}\n\nModInt<> solve(int l, int r, int idx, int chr) {\n  if (r - l <= 0) return r == l;\n  if (chr == 26) return 0;\n  if (reached[l][r][idx][chr]) return dp[l][r][idx][chr];\n  reached[l][r][idx][chr] = 1;\n  ModInt<> res = 0;\n  for (int i = l + 1; i < r; ++i)\n    if (s[i].size() <= idx) return dp[l][r][idx][chr] = 0;\n  if (s[l].size() <= idx) return dp[l][r][idx][chr] = solve(l + 1, r, idx, chr);\n  for (int mid = l; mid <= r; ++mid) {\n    res += solve(l, mid, idx + 1, 0) * solve(mid, r, idx, chr + 1);\n    if (mid == r) break;\n    if (s[mid][idx] != '?' && s[mid][idx] - 'a' != chr) break;\n  }\n  return dp[l][r][idx][chr] = res;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ for(auto it : P) { s << \"<\" << it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ for(auto it : P) { s << \"<\" << it.first << \"->\" << it.second << \"> \"; } return s << endl; }\n\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\nusing mint = Fp<1000000007>;\n\nint N;\nvector<string> S;\n\nstring moji;\nbool seen[55][55][30][30];\nmint dp[55][55][30][30];\nmint beki[50];\n\nmint rec(int i, int j, int k, int c) {\n    if (i == j) return 1;\n    if (c >= moji.size()) return 0;\n\n    //  k  ()\n    if (k >= S[i].size()) {\n        if (j - i == 1) return 1;\n        else return 0;\n    }\n    \n    // 1 \n    if (j - i == 1) {\n        int con = 0;\n        for (int p = k+1; p < S[i].size(); ++p) if (S[i][p] == '?') ++con;\n        if (S[i][k] == '?') return beki[con] * min(26, 27 - c);\n        else if (S[i][k] < moji[c]) return 0;\n        else return beki[con];\n    }\n\n    //  check\n    if (seen[i][j][k][c]) return dp[i][j][k][c];\n\n    // \n    mint res = 0;\n    int mac = 0;\n    for (int mid = i; mid <= j; ++mid) {\n        res += rec(i, mid, k+1, 0) * rec(mid, j, k, c+1);\n        if (mid == j) break;\n        if (S[mid][k] != '?' && S[mid][k] != moji[c]) break;\n        if (S[mid][k] == '?' && moji[c] == 'A') break;\n    }\n    seen[i][j][k][c] = true;\n    return dp[i][j][k][c] = res;\n}\n\nint main() {\n    cin >> N;\n    S.resize(N);\n    int ms = 0;\n    for (int i = 0; i < N; ++i) cin >> S[i], ms = max(ms, (int)S[i].size());\n    for (int i = 0; i < N; ++i) while (S[i].size() < ms) S[i] += 'A';\n    moji = 'A';\n    for (int i = 0; i < 26; ++i) moji += (char)('a' + i);\n    \n    memset(seen, 0, sizeof(seen));\n    beki[0] = 1;\n    for (int i = 0; i+1 < 50; ++i) beki[i+1] = beki[i] * 26;\n    cout << rec(0, N, 0, 0) << endl;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tfinal long MODULO = (long) (1e9 + 7);\n\tString[] str;\n\tchar empty = '`';\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tstr = new String[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tstr[i] = sc.next();\n\t\t\twhile (str[i].length() < 20)\n\t\t\t\tstr[i] += empty;\n\t\t}\n\t\tSystem.out.println(f(0, n - 1, 0, 0));\n\t}\n\n\tlong[][][][] memo = new long[50][50][20][28];\n\t{\n\t\tfor (int i = 0; i < memo.length; ++i) {\n\t\t\tfor (int j = 0; j < memo[i].length; ++j) {\n\t\t\t\tfor (int k = 0; k < memo[i][j].length; ++k) {\n\t\t\t\t\tfor (int l = 0; l < memo[i][j][k].length; ++l) {\n\t\t\t\t\t\tmemo[i][j][k][l] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong f(int l, int r, int i, int c) {\n\t\tif (i == 20)\n\t\t\treturn 0;\n\t\tif (r - l < 0)\n\t\t\treturn 1;\n\t\tif (c >= 27)\n\t\t\treturn 0;\n\t\tif (memo[l][r][i][c] != -1)\n\t\t\treturn memo[l][r][i][c];\n\t\tif (i == 19 && r - l == 0) {\n\t\t\tif (str[l].charAt(i) == '?') {\n\t\t\t\treturn c == 0 ? 26 : 27 - c;\n\t\t\t} else if (str[l].charAt(i) - 'a' + 1 >= c) {\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tlong ret = f(l, r, i, c + 1);\n\t\tfor (int j = l; j <= r; ++j) {\n\t\t\tboolean flag = true;\n\t\t\tfor (int k = l; k <= j; ++k) {\n\t\t\t\tflag &= (str[k].charAt(i) == '?' && c > 0) || str[k].charAt(i) - 'a' + 1 == c;\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tret += (j - l == 0 && i + 1 == 20 ? 1 : f(l, j, i + 1, 0)) * f(j + 1, r, i, c + 1) % MODULO;\n\t\t\t\tif (ret >= MODULO)\n\t\t\t\t\tret -= MODULO;\n\t\t\t}\n\t\t}\n\t\treturn memo[l][r][i][c] = ret;\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tfinal long MODULO = (long) (1e9 + 7);\n\tString[] str;\n\tchar empty = '`';\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tstr = new String[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tstr[i] = sc.next();\n\t\t\twhile (str[i].length() < 20)\n\t\t\t\tstr[i] += empty;\n\t\t}\n\t\tSystem.out.println(f(0, n - 1, 0, 0));\n\t}\n\n\tlong[][][][] memo = new long[50][50][20][28];\n\t{\n\t\tfor (int i = 0; i < memo.length; ++i) {\n\t\t\tfor (int j = 0; j < memo[i].length; ++j) {\n\t\t\t\tfor (int k = 0; k < memo[i][j].length; ++k) {\n\t\t\t\t\tfor (int l = 0; l < memo[i][j][k].length; ++l) {\n\t\t\t\t\t\tmemo[i][j][k][l] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlong f(int l, int r, int i, int c) {\n\t\tif (r - l < 0)\n\t\t\treturn 1;\n\t\tif (c >= 27)\n\t\t\treturn 0;\n\t\tif (memo[l][r][i][c] != -1)\n\t\t\treturn memo[l][r][i][c];\n\t\tif (i == 19) {\n\t\t\tif (r - l > 0)\n\t\t\t\treturn 0;\n\t\t\tboolean flag = true;\n\t\t\tfor (int j = l; j <= r; ++j) {\n\t\t\t\tflag &= (str[j].charAt(i) == '?' && c > 0) || str[j].charAt(i) - 'a' + 1 == c;\n\t\t\t}\n\t\t\treturn flag ? 1 : 0;\n\t\t}\n\n\t\tlong ret = f(l, r, i, c + 1);\n\t\tfor (int j = l; j <= r; ++j) {\n\t\t\tboolean flag = true;\n\t\t\tfor (int k = l; k <= j; ++k) {\n\t\t\t\tflag &= (str[k].charAt(i) == '?' && c > 0) || str[k].charAt(i) - 'a' + 1 == c;\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tret += f(l, j, i + 1, 0) * f(j + 1, r, i, c + 1) % MODULO;\n\t\t\t\tif (ret >= MODULO)\n\t\t\t\t\tret -= MODULO;\n\t\t\t}\n\t\t}\n\t\treturn memo[l][r][i][c] = ret;\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\n//using System.Numerics;\n//using Point = System.Numerics.Complex;\n//using Number = System.Int64;\nnamespace Program\n{\n    public class Solver\n    {\n\n        public void Solve()\n        {\n            const int L = 20;\n            const char ZERO = (char)('a' - 1);\n            var n = sc.Integer();\n            var s = Enumerate(n, x => sc.Scan());\n            for (int i = 0; i < n; i++)\n                while (s[i].Length < L) s[i] += ZERO;\n            //(i,j),k,[a,b]\n            var dp = new ModInteger[n, n, L, 27];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    for (int k = 0; k < L; k++)\n                        for (int l = 0; l < 27; l++)\n                            dp[i, j, k, l].num = -1;\n            Func<int, int, int, int, ModInteger> dfs = null;\n            dfs = (l, r, i, a) =>\n              {\n                  if (l > r) return 1;\n                  if (i == L)\n                      return r == l ? 1 : 0;\n                  if (a >= 27) return 0;\n                  if (dp[l, r, i, a].num != -1) return dp[l, r, i, a];\n                  //Debug.WriteLine($\"[{l} {r}] {i} {(char)(a + 'a')}\");\n                  ModInteger ret = 0;\n                  ret += dfs(l, r, i, a + 1);\n                  for (int m = l; m <= r; m++)\n                  {\n                      if (a == 0 && s[m][i] == '?') break;\n                      if (s[m][i] != '?' && s[m][i] != a + ZERO) break;\n                      ret += dfs(l, m, i + 1, 0) * dfs(m + 1, r, i, a + 1);\n                  }\n                  return dp[l, r, i, a] = ret;\n              };\n            var ans = dfs(0, n - 1, 0, 0);\n            IO.Printer.Out.WriteLine(ans);\n        }\n\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    //static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    //static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n#region ModNumber\npublic partial struct ModInteger\n{\n    public const long Mod = (long)1e9 + 7;\n    public long num;\n    public ModInteger(long n) : this() { num = n % Mod; if (num < 0) num += Mod; }\n    public override string ToString() { return num.ToString(); }\n    public static ModInteger operator +(ModInteger l, ModInteger r) { var n = l.num + r.num; if (n >= Mod) n -= Mod; return new ModInteger() { num = n }; }\n    public static ModInteger operator -(ModInteger l, ModInteger r) { var n = l.num + Mod - r.num; if (n >= Mod) n -= Mod; return new ModInteger() { num = n }; }\n    public static ModInteger operator *(ModInteger l, ModInteger r) { return new ModInteger(l.num * r.num); }\n    public static ModInteger operator ^(ModInteger l, long r) { return ModInteger.Pow(l, r); }\n    public static implicit operator ModInteger(long n) { return new ModInteger() { num = n }; }\n    public static ModInteger Pow(ModInteger v, long k)\n    {\n        ModInteger ret = 1;\n        var n = k;\n        for (; n > 0; n >>= 1, v *= v)\n        {\n            if ((n & 1) == 1)\n                ret = ret * v;\n        }\n        return ret;\n    }\n}\n#endregion\n"
  },
  {
    "language": "Python",
    "code": "# seishin.py\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\ndef solve():\n    MOD = 10**9 + 7\n    N = int(readline())\n    M = 20\n    L = 26\n    ca = ord('a')\n    cq = ord('?')\n    S = [[ca-1]*M for i in range(N)]\n    for i in range(N):\n        s = readline().strip()\n        S[i][:len(s)] = map(ord, s)\n\n    memo = [[[[-1]*(L+2) for i in range(M+1)] for j in range(N+1)] for k in range(N+1)]\n    for i in range(N+1):\n        for p in range(M+1):\n            for c in range(L+2):\n                memo[i][i][p][c] = 1\n    for i in range(N+1):\n        for j in range(i+1, N+1):\n            for p in range(M+1):\n                memo[i][j][p][L+1] = 0\n            for c in range(L+2):\n                memo[i][j][M][c] = (i+1 == j)\n\n    def dfs(l, r, p, c):\n        if memo[l][r][p][c] != -1:\n            return memo[l][r][p][c]\n        res = dfs(l, r, p, c+1)\n        for i in range(l+1, r+1):\n            if (S[i-1][p] != ca + c - 1) if S[i-1][p] != cq else (c == 0):\n                break\n            res += dfs(l, i, p+1, 0) * dfs(i, r, p, c+1) % MOD\n        memo[l][r][p][c] = res = res % MOD\n        return res\n    write(\"%d\\n\" % dfs(0, N, 0, 0))\nsolve()\n"
  }
]