[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void* a, const void* b) {\n    return (*(int*)a - *(int*)b);\n}\n\nlong long minimal_sort_cost(int* arr, int n) {\n    long long total_cost = 0;\n    int* sorted = malloc(n * sizeof(int));\n    \n    for (int i = 0; i < n; i++) {\n        sorted[i] = arr[i];\n    }\n    \n    qsort(sorted, n, sizeof(int), compare);\n    \n    for (int i = 0; i < n; i++) {\n        if (arr[i] != sorted[i]) {\n            for (int j = i + 1; j < n; j++) {\n                if (arr[j] == sorted[i]) {\n                    total_cost += arr[i] + arr[j];\n                    int temp = arr[i];\n                    arr[i] = arr[j];\n                    arr[j] = temp;\n                    break;\n                }\n            }\n        }\n    }\n    \n    free(sorted);\n    return total_cost;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    int* arr = malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    long long result = minimal_sort_cost(arr, n);\n    printf(\"%lld\\n\", result);\n    \n    free(arr);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:12:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAXN 1000\n\ntypedef struct {\n    int value;\n    int index;\n} Element;\n\nint compare(const void *a, const void *b) {\n    return ((Element*)a)->value - ((Element*)b)->value;\n}\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    Element arr[MAXN];\n    bool visited[MAXN] = {false};\n    int original[MAXN];\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &original[i]);\n        arr[i].value = original[i];\n        arr[i].index = i;\n    }\n    \n    qsort(arr, n, sizeof(Element), compare);\n    \n    int total_cost = 0;\n    \n    for (int i = 0; i < n; i++) {\n        if (visited[i] || arr[i].index == i) {\n            continue;\n        }\n        \n        int cycle_size = 0;\n        int j = i;\n        int cycle_min = arr[i].value;\n        int cycle_sum = 0;\n        \n        while (!visited[j]) {\n            visited[j] = true;\n            cycle_sum += arr[j].value;\n            cycle_min = min(cycle_min, arr[j].value);\n            j = arr[j].index;\n            cycle_size++;\n        }\n        \n        int option1 = cycle_sum + (cycle_size - 2) * cycle_min;\n        int option2 = cycle_sum + cycle_min + (cycle_size + 1) * arr[0].value;\n        total_cost += min(option1, option2);\n    }\n    \n    printf(\"%d\\n\", total_cost);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:12:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\n#include <climits>\n\nusing namespace std;\n\nlong long minimalSwapCost(vector<int>& nums) {\n    vector<int> sorted_nums = nums;\n    sort(sorted_nums.begin(), sorted_nums.end());\n    \n    unordered_map<int, int> pos_in_sorted;\n    for (int i = 0; i < sorted_nums.size(); ++i) {\n        pos_in_sorted[sorted_nums[i]] = i;\n    }\n    \n    long long total_cost = 0;\n    vector<bool> visited(nums.size(), false);\n    \n    for (int i = 0; i < nums.size(); ++i) {\n        if (visited[i] || pos_in_sorted[nums[i]] == i) {\n            continue;\n        }\n        \n        int cycle_size = 0;\n        long long cycle_sum = 0;\n        int current = i;\n        int min_in_cycle = INT_MAX;\n        \n        while (!visited[current]) {\n            visited[current] = true;\n            cycle_size++;\n            cycle_sum += nums[current];\n            min_in_cycle = min(min_in_cycle, nums[current]);\n            current = pos_in_sorted[nums[current]];\n        }\n        \n        long long cost1 = cycle_sum + (cycle_size - 2) * min_in_cycle;\n        long long cost2 = cycle_sum + min_in_cycle + (cycle_size + 1) * sorted_nums[0];\n        total_cost += min(cost1, cost2);\n    }\n    \n    return total_cost;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> nums(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> nums[i];\n    }\n    cout << minimalSwapCost(nums) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:13:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MinimalSwapCost {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = scanner.nextInt();\n        }\n        \n        int[] sortedArr = arr.clone();\n        Arrays.sort(sortedArr);\n        Map<Integer, Integer> positionMap = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            positionMap.put(sortedArr[i], i);\n        }\n        \n        boolean[] visited = new boolean[n];\n        int totalCost = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                int current = i;\n                int cycleSize = 0;\n                int cycleSum = 0;\n                int minInCycle = Integer.MAX_VALUE;\n                \n                while (!visited[current]) {\n                    visited[current] = true;\n                    cycleSize++;\n                    cycleSum += arr[current];\n                    minInCycle = Math.min(minInCycle, arr[current]);\n                    current = positionMap.get(arr[current]);\n                }\n                \n                int method1 = cycleSum + (cycleSize - 2) * minInCycle;\n                int method2 = cycleSum + minInCycle + (cycleSize + 1) * sortedArr[0];\n                totalCost += Math.min(method1, method2);\n            }\n        }\n        \n        System.out.println(totalCost);\n    }\n}",
    "timestamp": "2025-08-05 22:14:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MinCostSort {\n    public static long minimumCost(int[] nums) {\n        int n = nums.length;\n        Integer[] indices = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            indices[i] = i;\n        }\n        \n        Arrays.sort(indices, (a, b) -> Integer.compare(nums[a], nums[b]));\n        \n        long totalCost = 0;\n        boolean[] visited = new boolean[n];\n        \n        for (int i = 0; i < n; i++) {\n            if (visited[i] || indices[i] == i)\n                continue;\n            \n            int cycle = 0;\n            int j = i;\n            int minIndex = i;\n            int minElement = nums[i];\n            \n            while (!visited[j]) {\n                visited[j] = true;\n                cycle++;\n                j = indices[j];\n                \n                if (nums[j] < minElement) {\n                    minIndex = j;\n                    minElement = nums[j];\n                }\n            }\n            \n            if (cycle > 1) {\n                int start = i;\n                int end = minIndex;\n                \n                if (nums[start] > nums[end]) {\n                    totalCost += (long)nums[start] + nums[end];\n                    int temp = nums[start];\n                    nums[start] = nums[end];\n                    nums[end] = temp;\n                }\n                \n                for (int k = 0; k < cycle - 1; k++) {\n                    start = indices[start];\n                    end = indices[end];\n                    \n                    totalCost += (long)nums[start] + nums[end];\n                    \n                    int tempNum = nums[start];\n                    nums[start] = nums[end];\n                    nums[end] = tempNum;\n                }\n            }\n        }\n        \n        return totalCost;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] nums = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            nums[i] = scanner.nextInt();\n        }\n        \n        System.out.println(minimumCost(nums));\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 22:14:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    long long minCost(vector<int>& nums) {\n        int n = nums.size();\n        vector<pair<int, int>> indexed_nums(n);\n        \n        for (int i = 0; i < n; i++) {\n            indexed_nums[i] = {nums[i], i};\n        }\n        \n        sort(indexed_nums.begin(), indexed_nums.end());\n        \n        vector<bool> visited(n, false);\n        long long total_cost = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (visited[i] || indexed_nums[i].second == i)\n                continue;\n            \n            int cycle_size = 0;\n            int j = i;\n            int min_element = INT_MAX;\n            long long cycle_sum = 0;\n            \n            while (!visited[j]) {\n                visited[j] = true;\n                cycle_size++;\n                cycle_sum += indexed_nums[j].first;\n                min_element = min(min_element, indexed_nums[j].first);\n                j = indexed_nums[j].second;\n            }\n            \n            if (cycle_size > 1) {\n                total_cost += min(\n                    cycle_sum + (cycle_size - 2) * min_element, \n                    cycle_sum + min_element + (cycle_size + 1) * min_element\n                );\n            }\n        }\n        \n        return total_cost;\n    }\n};\n\nint main() {\n    Solution solution;\n    int n;\n    cin >> n;\n    \n    vector<int> nums(n);\n    for (int i = 0; i < n; i++) {\n        cin >> nums[i];\n    }\n    \n    cout << solution.minCost(nums) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:14:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_cost_to_sort(nums):\n    sorted_nums = sorted(nums)\n    if nums == sorted_nums:\n        return 0\n\n    total_cost = 0\n    visited = [False] * len(nums)\n    num_to_pos = {num: pos for pos, num in enumerate(nums)}\n    for i in range(len(nums)):\n        if visited[i] or nums[i] == sorted_nums[i]:\n            continue\n        \n        cycle_cost = 0\n        cycle_length = 0\n        current = i\n        \n        while not visited[current]:\n            visited[current] = True\n            next_pos = num_to_pos[sorted_nums[current]]\n            cycle_cost += nums[current]\n            cycle_length += 1\n            current = next_pos\n        \n        cycle_cost += sorted_nums[i]\n        total_cost += cycle_cost * (cycle_length - 1)\n    \n    return total_cost\n\n# Example usage:\nnums = [5, 3, 2, 1, 4]\nprint(min_cost_to_sort(nums))  # Output the minimal total cost",
    "timestamp": "2025-08-13 09:30:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Arrays;\n\npublic class MinimumSwapCost {\n    public static int minimalTotalSwapCost(int[] nums) {\n        int n = nums.length;\n        int[] sorted = nums.clone();\n        Arrays.sort(sorted);\n\n        boolean[] visited = new boolean[n];\n        int totalCost = 0;\n\n        for (int i = 0; i < n; i++) {\n            if (visited[i] || nums[i] == sorted[i]) {\n                continue;\n            }\n            \n            int cycleSum = 0;\n            int cycleSize = 0;\n            int j = i;\n\n            while (!visited[j]) {\n                visited[j] = true;\n                cycleSize++;\n                cycleSum += nums[j];\n                j = Arrays.binarySearch(sorted, nums[j]);\n            }\n\n            if (cycleSize > 1) {\n                int minInCycle = Integer.MAX_VALUE;\n                for (int k = 0; k < n; k++) {\n                    if (Arrays.binarySearch(sorted, nums[k]) < 0) continue;\n                    minInCycle = Math.min(minInCycle, nums[k]);\n                }\n                totalCost += Math.min(cycleSum + (cycleSize - 2) * minInCycle,\n                                      cycleSum + sorted[0] + (cycleSize + 1) * sorted[0]);\n            }\n        }\n\n        return totalCost;\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {3, 6, 5, 2};\n        System.out.println(minimalTotalSwapCost(nums));\n    }\n}",
    "timestamp": "2025-08-13 09:30:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX(x, y) (((x) > (y)) ? (x) : (y))\n\nint compare(const void* a, const void* b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint findMinCost(int* arr, int n) {\n    int sortedArr[n];\n    int visited[n];\n    int i;\n\n    for (i = 0; i < n; ++i) {\n        sortedArr[i] = arr[i];\n        visited[i] = 0;\n    }\n\n    qsort(sortedArr, n, sizeof(int), compare);\n\n    int minCost = 0;\n    int globalMinElem = sortedArr[0];\n\n    for (i = 0; i < n; ++i) {\n        if (visited[i] || sortedArr[i] == arr[i])\n            continue;\n\n        int cycleSize = 0;\n        int cycleSum = 0;\n        int cycleMinElem = MAX(sortedArr[i], globalMinElem);\n        int j = i;\n\n        while (!visited[j]) {\n            visited[j] = 1;\n            cycleSum += arr[j];\n            cycleMinElem = (arr[j] < cycleMinElem) ? arr[j] : cycleMinElem;\n            cycleSize++;\n            j = (int)(qsort_bsearch((void*)&arr[j], sortedArr, n, sizeof(int), compare) - sortedArr);\n        }\n\n        if (cycleSize > 1) {\n            int option1 = cycleSum + (cycleSize - 2) * cycleMinElem;\n            int option2 = cycleSum + cycleMinElem + (cycleSize + 1) * globalMinElem;\n            minCost += (option1 < option2) ? option1 : option2;\n        }\n    }\n\n    return minCost;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    int arr[n];\n    for(int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    int result = findMinCost(arr, n);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 09:30:28"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_sort_cost(arr):\n    n = len(arr)\n    total_cost = 0\n    \n    for i in range(n):\n        min_idx = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        \n        if min_idx != i:\n            total_cost += arr[i] + arr[min_idx]\n            arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    \n    return total_cost\n\n# Example usage\nn = int(input())\narr = list(map(int, input().split()))\nprint(min_sort_cost(arr))",
    "timestamp": "2025-08-13 09:30:33"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def minimal_swap_cost(arr):\n    n = len(arr)\n    visited = [False] * n\n    total_cost = 0\n    \n    # Create a list of tuples (value, original index) for sorting\n    sorted_with_indices = sorted((val, idx) for idx, val in enumerate(arr))\n    sorted_arr = [val for val, idx in sorted_with_indices]\n    index_map = {idx: sorted_idx for sorted_idx, (val, idx) in enumerate(sorted_with_indices)}\n    \n    for i in range(n):\n        if not visited[i]:\n            if index_map[i] == i:\n                visited[i] = True\n                continue\n                \n            cycle_size = 0\n            cycle_sum = 0\n            j = i\n            while not visited[j]:\n                visited[j] = True\n                cycle_sum += arr[j]\n                cycle_size += 1\n                j = index_map[j]\n            \n            # Calculate cost using the two possible methods\n            method1 = cycle_sum + (cycle_size - 2) * arr[i]\n            method2 = cycle_sum + arr[i] + (cycle_size + 1) * sorted_arr[0]\n            total_cost += min(method1, method2)\n    \n    return total_cost\n\nn = int(input())\narr = list(map(int, input().split()))\nprint(minimal_swap_cost(arr))",
    "timestamp": "2025-08-13 09:30:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint minSwapCost(vector<int>& nums) {\n    int n = nums.size();\n    vector<int> sorted(nums);\n    sort(sorted.begin(), sorted.end());\n    \n    vector<bool> visited(n, false);\n    \n    int totalCost = 0;\n    for (int i = 0; i < n; ++i) {\n        if (visited[i] || sorted[i] == nums[i])\n            continue;\n        \n        int cycleCost = 0, cycleSize = 0;\n        int j = i;\n        while (!visited[j]) {\n            visited[j] = true;\n            cycleCost += nums[j];\n            j = lower_bound(sorted.begin(), sorted.end(), nums[j]) - sorted.begin();\n            ++cycleSize;\n        }\n        \n        int cycleMin = INT_MAX;\n        for (j = i; !visited[j];) {\n            cycleMin = min(cycleMin, nums[j]);\n            j = lower_bound(sorted.begin(), sorted.end(), nums[j]) - sorted.begin();\n        }\n        \n        totalCost += min(cycleCost + (cycleSize - 2) * cycleMin,\n                         cycleCost + cycleMin + (cycleSize + 1) * sorted[0]);\n    }\n    \n    return totalCost;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> nums(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> nums[i];\n    }\n    \n    cout << minSwapCost(nums) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:51:55"
  }
]