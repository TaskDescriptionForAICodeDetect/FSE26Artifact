[
  {
    "language": "Scala",
    "code": "import scala.collection.mutable\n\nobject ALDS1_6_D extends App {\n  implicit val ordering: Ordering[(Int, Vector[Int])] = Ordering.by(- _._1)\n  val heap = mutable.PriorityQueue.empty[(Int, Vector[Int])]\n\n  def isSorted(s: Seq[Int]): Boolean =\n    (0 until s.length-1).dropWhile(i => s(i) < s(i+1)).isEmpty\n\n  def solution(a: Vector[Int]): Int = {\n    def loop(i: Int): Int = {\n      val e@(cost, seq) = heap.dequeue()\n      if (isSorted(seq)) cost\n      else {\n        if (i < seq.length && seq.slice(i, seq.length).min == seq(i)) heap.enqueue(e)\n        for (j <- i+1 until seq.length)\n          heap.enqueue((cost + seq(i) + seq(j), seq.updated(i,seq(j)).updated(j, seq(i))))\n        loop(i+1)\n      }\n    }\n    loop(0)\n  }\n\n  val _ = io.StdIn.readLine()\n  val init: Vector[Int] = io.StdIn.readLine().split(\" \").map(_.toInt).toVector\n  heap.enqueue((0, init))\n  println(solution(init))\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt, readLine}\n\nobject Main extends App {\n  import Solver.solve\n\n  val n   = readInt()\n  val xs  = readLine().split(' ').map { _.toInt }\n  val ans = solve(xs, n)\n  println(ans)\n}\n\nobject Solver {\n  val VMAX: Int = 10000\n\n  def solve(xs: Array[Int], n: Int): Int = {\n    val ys   = xs.sorted\n    val minV = ys.head\n    val zs   = Array.fill(n)(false)\n    val ts = {\n      val ts = new Array[Int](VMAX + 1)\n      var i  = 0\n      while (i < n) {\n        ts(ys(i)) = i\n        i += 1\n      }\n      ts\n    }\n\n    var ans, i = 0\n    while (i < n) {\n      if (!zs(i)) {\n        var cur   = i\n        var m     = VMAX\n        var s, an = 0\n        do {\n          zs(cur) = true\n          an += 1\n          val v = xs(cur)\n          m = math.min(m, v)\n          s += v\n          cur = ts(v)\n        } while (!zs(cur))\n        ans += math.min(s + (an - 2) * m, m + s + (an + 1) * minV)\n      }\n      i += 1\n    }\n\n    ans\n  }\n}\n\n"
  },
  {
    "language": "Scala",
    "code": "object Main extends App {\n  val _ = io.StdIn.readInt()\n  val arr: Array[Int] = io.StdIn.readLine().split(\" \").map(_.toInt)\n  val min = arr.min\n\n  def mkGroup(s: IndexedSeq[Int]): Seq[Seq[Int]] = {\n    val sorted: Seq[Int] = s.sorted\n    val m: collection.mutable.Map[Int, Int] = collection.mutable.Map.empty\n    s.indices.foreach(i => m.update(i, sorted.indexOf(s(i))))\n    def getCycle(n: Int): List[Int] = m.get(n) match {\n      case None => List()\n      case Some(x) => m.remove(n); n :: getCycle(x)\n    }\n    s.indices.map(i => getCycle(i)).filterNot(_.isEmpty)\n  }\n\n  def cost(inds: Seq[Int]): Int = {\n    val s = inds.map(arr(_))\n    ((s.length - 2) * s.min + s.sum).min((s.length+1) * min + s.min + s.sum)\n  }\n\n  val groups = mkGroup(arr)\n  println((groups map cost).sum)\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readInt, readLine}\n\nobject Main extends App {\n  val n = readInt\n  val A = readLine.split(\" \").map(_.toInt)\n  val totalCost = calcTotalCost(n, A, A.sorted)\n  println(totalCost)\n\n  def calcTotalCost(n: Int, A: Array[Int], B: Array[Int]): Int = {\n    val visited = Array.fill[Boolean](n)(false)\n    val pos = Array.fill[Int](B.max + 1)(-1)\n    B.zipWithIndex.map{ case(e, i) => pos(e) = i }\n\n    val minOfAll = B(0)\n    var totalCost = 0\n    A.foreach(e => {\n      var v = e\n      if (!visited(pos(v))) {\n        var sum = 0\n        var count = 0\n        var min = Integer.MAX_VALUE\n        while (!visited(pos(v))) {\n          visited(pos(v)) = true\n          sum += v\n          count += 1\n          min = Math.min(min, v)\n          v = A(pos(v))\n        }\n        val cost1 = (min * (count - 2)) + sum\n        val cost2 = (minOfAll * (count + 1)) + (min * 2) + (sum - min)\n        totalCost += Math.min(cost1, cost2)\n      }\n    })\n    totalCost\n  }\n}\n\n"
  },
  {
    "language": "Scala",
    "code": "import scala.collection.mutable\n\nobject Main extends App {\n  implicit val ordering: Ordering[(Int, Vector[Int])] = Ordering.by(- _._1)\n  val heap = mutable.PriorityQueue.empty[(Int, Vector[Int])]\n\n  def isSorted(s: Seq[Int]): Boolean =\n    (0 until s.length-1).dropWhile(i => s(i) < s(i+1)).isEmpty\n\n  def solution(a: Vector[Int]): Int = {\n    def loop(i: Int): Int = {\n      val e@(cost, seq) = heap.dequeue()\n      if (isSorted(seq)) cost\n      else {\n        if (i < seq.length && seq.slice(i, seq.length).min == seq(i)) heap.enqueue(e)\n        for (j <- i+1 until seq.length)\n          heap.enqueue((cost + seq(i) + seq(j), seq.updated(i,seq(j)).updated(j, seq(i))))\n        loop(i+1)\n      }\n    }\n    loop(0)\n  }\n\n  val _ = io.StdIn.readInt()\n  val init: Vector[Int] = io.StdIn.readLine().split(\" \").map(_.toInt).toVector\n  heap.enqueue((0, init))\n  println(solution(init))\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readLine,readInt}\n\nobject Main {\n  val t = new Array[Int](10001)\n\n  def getMin(x:Int,y:Int) = if(x<y) x else y\n\n  def scan(a:Array[Int], used:Array[Boolean],i:Int, size:Int, min:Int, sum:Int):(Int,Int,Int) = {\n    if(used(i)) (size,sum,min)\n    else {\n      used(i) = true\n      val w = a(i)\n      scan(a, used, t(w), size+1, getMin(min, w), sum+w)\n    }\n  }\n\n  def getCost(a:Array[Int],min:Int,n:Int) = {\n    var ans = 0\n    val used = (0 until a.length).map(_=>false).toArray\n    val b = a.sorted.clone\n\n    (0 until n).foreach{ i => t(b(i))=i }\n\n    for(i<-0 until n) {\n      if(!used(i)) {\n        val (size, s, m) = scan(a,used,i,0,10000,0)\n        ans += getMin(s+(size-2)*m, m+s+(size+1)*s)\n      }\n    }\n    ans\n  }\n\n  def main(args:Array[String]) = {\n    val n = readInt\n    val a = readLine.split(\" \").map(_.toInt)\n    val min = a.min\n    println(getCost(a,min,n))\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readLine,readInt}\n\nobject Main {\n  val t = new Array[Int](10000)\n\n  def getMin(x:Int,y:Int) = if(x<y) x else y\n\n  def scan(a:Array[Int], used:Array[Boolean],i:Int, size:Int, min:Int, sum:Int):(Int,In\\\nt,Int) = {\n    if(used(i)) (size,sum,min)\n    else {\n      used(i) = true\n      val w = a(i)\n      scan(a, used, t(w), size+1, getMin(min, w), sum+w)\n    }\n  }\n\n  def getCost(a:Array[Int],min:Int,n:Int) = {\n    var ans = 0\n    val used = (0 until a.length).map(_=>false).toArray\n    val b = a.sorted.clone\n\n    (0 until n).foreach{ i => t(b(i))=i }\n\n    for(i<-0 until n) {\n      if(!used(i)) {\n        val (size, s, m) = scan(a,used,i,0,10000,0)\n        ans += getMin(s+(size-2)*m, m+s+(size+1)*s)\n      }\n    }\n    ans\n  }\n\n  def main(args:Array[String]) = {\n    val n = readInt\n    val a = readLine.split(\" \").map(_.toInt)\n    val min = a.min\n    println(getCost(a,min,n))\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readLine,readInt}\n\nobject Main {\n  val t = new Array[Int](10000)\n\n  def getMin(x:Int,y:Int) = if(x<y) x else y\n\n  def scan(a:Array[Int], used:Array[Boolean],i:Int, size:Int, min:Int, sum:Int):(Int,Int,Int) = {\n    if(used(i)) (size,sum,min)\n    else {\n      used(i) = true\n      val w = a(i)\n      scan(a, used, t(w), size+1, getMin(min, w), sum+w)\n    }\n  }\n\n  def getCost(a:Array[Int],min:Int,n:Int) = {\n    var ans = 0\n    val used = (0 until a.length).map(_=>false).toArray\n    val b = a.sorted.clone\n\n    (0 until n).foreach{ i => t(b(i))=i }\n\n    for(i<-0 until n) {\n      if(!used(i)) {\n        val (size, s, m) = scan(a,used,i,0,10000,0)\n        ans += getMin(s+(size-2)*m, m+s+(size+1)*s)\n      }\n    }\n    ans\n  }\n\n  def main(args:Array[String]) = {\n    val n = readInt\n    val a = readLine.split(\" \").map(_.toInt)\n    val min = a.min\n    println(getCost(a,min,n))\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.collection.mutable\n\nobject Main extends App {\n  implicit val ordering: Ordering[(Int, Vector[Int])] = Ordering.by(- _._1)\n  val heap = mutable.PriorityQueue.empty[(Int, Vector[Int])]\n\n  def isSorted(s: Seq[Int]): Boolean =\n    (0 until s.length-1).dropWhile(i => s(i) < s(i+1)).isEmpty\n\n  def solution(a: Vector[Int]): Int = {\n\n    def loop(): Int = {\n      val (cost, seq) = heap.dequeue()\n      if(isSorted(seq)) cost\n      else {\n        for{\n          i <- seq.indices\n          j <- i+1 until seq.length\n          si = seq(i)\n          sj = seq(j)\n        } heap.enqueue((cost + si + sj, seq.updated(i, sj).updated(j, si)))\n        loop()\n      }\n    }\n\n    loop()\n  }\n\n  val _ = io.StdIn.readInt()\n  val init: Vector[Int] = io.StdIn.readLine().split(\" \").map(_.toInt).toVector\n  heap.enqueue((0, init))\n  println(solution(init))\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn.{readLine,readInt}\n\nobject Main {\n  val t = new Array[Int](10001)\n\n  def getMin(x:Int,y:Int) = if(x<y) x else y\n\n  def scan(a:Array[Int], used:Array[Boolean],i:Int, size:Int, min:Int, sum:Int):(Int,Int,Int) = {\n    if(used(i)) (size,sum,min)\n    else {\n      used(i) = true\n      val w = a(i)\n      scan(a, used, t(w), size+1, getMin(min, w), sum+w)\n    }\n  }\n\n  def getCost(a:Array[Int],min:Int,n:Int) = {\n    var ans = 0\n    val used = (0 until a.length).map(_=>false).toArray\n    val b = a.sorted.clone\n\n    (0 until n).foreach{ i => t(b(i))=i }\n\n    for(i<-0 until n) {\n      if(!used(i)) {\n        val (size, s, m) = scan(a,used,i,0,10000,0)\n        ans += getMin(s+(size-2)*m, m+s+(size+1)*min)\n      }\n    }\n    ans\n  }\n\n  def main(args:Array[String]) = {\n    val n = readInt\n    val a = readLine.split(\" \").map(_.toInt)\n    val min = a.min\n    println(getCost(a,min,n))\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.collection.mutable\n\nobject Main extends App {\n  implicit val ordering: Ordering[(Int, Vector[Int])] = Ordering.by(- _._1)\n  val heap = mutable.PriorityQueue.empty[(Int, Vector[Int])]\n\n  def isSorted(s: Seq[Int]): Boolean =\n    (0 until s.length-1).dropWhile(i => s(i) < s(i+1)).isEmpty\n\n  def solution(a: Vector[Int]): Int = {\n\n    def loop(): Int = {\n      val (cost, seq) = heap.dequeue()\n      if(isSorted(seq)) cost\n      else {\n        for{\n          i <- seq.indices\n          j <- seq.indices if j != i\n          si = seq(i)\n          sj = seq(j)\n        } heap.enqueue((cost + si + sj, seq.updated(i, sj).updated(j, si)))\n        loop()\n      }\n    }\n\n    loop()\n  }\n\n  val _ = io.StdIn.readInt()\n  val init: Vector[Int] = io.StdIn.readLine().split(\" \").map(_.toInt).toVector\n  heap.enqueue((0, init))\n  println(solution(init))\n}"
  },
  {
    "language": "Scala",
    "code": "object Main extends App {\n  val _ = io.StdIn.readInt()\n  val arr: Array[Int] = io.StdIn.readLine().split(\" \").map(_.toInt)\n  val min = arr.min\n\n  def mkGroup(s: IndexedSeq[Int]): Seq[Seq[Int]] = {\n    val sorted: Seq[Int] = s.sorted\n    val m: collection.mutable.Map[Int, Int] = collection.mutable.Map.empty\n    s.indices.foreach(i => m.update(i, sorted.indexOf(s(i))))\n    def getCycle(n: Int): List[Int] = m.get(n) match {\n      case None => List()\n      case Some(x) => m.remove(n); n :: getCycle(x)\n    }\n    s.indices.map(i => getCycle(i)).filterNot(_.isEmpty)\n  }\n\n  def cost(inds: Seq[Int]): Int = {\n    val s = inds.map(arr(_))\n    val sum = s.sum\n    val smin = s.min\n    ((s.length - 2) * smin + sum) min ((s.length+1) * min + smin + sum)\n  }\n\n  val groups = mkGroup(arr)\n  println((groups map cost).sum)\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nlong long n, mina = 10000, ans = 0;\n\nclass nim{\npublic:\n  long long v, id;\n  bool operator<(const nim &another) const{\n    return v < another.v;\n  }\n};\n\nlong long func(vector<long long> t){\n  long long mint = 10000, sum = 0, ret;\n  for(int i = 0; i < t.size(); i++){\n    sum += t[i];\n    mint = min(t[i], mint);\n  }\n  ret = sum + mint * (t.size() - 2);\n  return ret;\n}\n\nlong long func2(vector<long long> t){\n  long long mint = 10000, sum = 0, ret;\n  for(int i = 0; i < t.size(); i++){\n    sum += t[i];\n    mint = min(t[i], mint);\n  }\n  ret = sum + mina * (t.size()) + mina + mint;\n  return ret;\n}\n\nvoid solve(){\n  cin >> n;\n  vector<nim> a(n);\n  for(int i = 0; i < n; i++){\n    cin >> a[i].v;\n    a[i].id = i;\n    mina = min(a[i].v, mina);\n  }\n  sort(a.begin(), a.end());\n  for(int i = 0; i < n; i++){\n    if(a[i].v == -1) continue;\n    int y = a[i].id;\n    vector<long long> t;\n    t.push_back(a[i].v);\n    while(a[y].v != a[i].v){\n      t.push_back(a[y].v);\n      a[y].v = -1;\n      y = a[y].id;\n    }\n    a[i].v = -1;\n    ans += min(func(t), func2(t));\n  }\n  cout << ans << endl;\n\n  return;\n}\n\nint main(){\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define MAX 200000\n#define SENTINEL 2000000000\ntypedef long long llong;\n\nint L[MAX / 2 + 2], R[MAX / 2 + 2];\n\nllong merge (int A[], int n, int left, int mid, int right){\n  int i, j, k;\n  llong cnt = 0;\n  int n1 = mid -left;\n  int n2 = right -mid;\n  for (int i = 0; i < n1; ++i) L[i] = A[left +i];\n  for (int i = 0; i < n2; ++i) R[i] = A[mid +i];\n  L[n1] = R[n2] = SENTINEL;\n  i = j = 0;\n  for (int k = 0; k < right; ++k)\n   {\n     if(L[i] <= R[j]){\n      A[k] = L[i++];\n     }else{\n      A[k] =R[j++];\n      cnt += n1 - i ; \n     }\n   } \n\nreturn cnt;\n\n\n}\n\nllong mergeSort(int A[],int n, int left, int right){\n\n  int mid;\n  llong v1, v2, v3;\n  if( left + 1 < right ){\n    mid =(left +right)/2;\n    v1 =mergeSort(A,n,left,mid);\n    v2 =mergeSort(A,n,mid,right);\n    v3 =merge(A,n,left,mid, right);\n    return v1 +v2 +v3;\n  }else return 0;\n\n}\n\nint main(){\n  int A[MAX], n, i;\n\n  cin >> n;\n  for (int i = 0; i < n; ++i)\n  {\n    cin >> A[i];\n  }\n\n  llong ans = mergeSort(A,n,0,n);\n  cout << ans << endl;\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) (a)>(b)?(b):(a)\n#define max(a,b) (a)>(b)?(a):(b)\n\nusing namespace std;\n\nint A[1000];\nint dupA[1000];\nint pos[10001];\n\nint main()\n{\n\tint N;\n\tscanf(\"%d\", &N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> A[i];\n\t\tdupA[i] = A[i];\n\t\tpos[A[i]] = i;\n\t}\n\n\tsort(A, A + N);\n\n\tint cost = 0;\n\tint i = 0;\n\twhile (i < N)\n\t{\n\t\tif (pos[A[i]] != i)\n\t\t{\n\t\t\tcost += (A[i] + A[pos[A[i]]]);\n\t\t\tint temp = pos[A[i]];\n\t\t\tpos[A[i]] = pos[A[temp]];\n\t\t\tpos[A[temp]] = temp;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti++;\n\t\t}\n\t}\n\n\tcout << cost << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int INF = 1000000;\n\nint partition(int *A,int p,int r)\n{\n\tint j,x,temp;\n\n\tx = A[r];\n\tj = p-1;\n\n\tfor(int i = p; i < r; i++)\n\t{\n\t\tif (A[i] <= x)\n\t\t{\n\t\t\tj++;\n\t\t\ttemp = A[i];\n\t\t\tA[i] = A[j];\n\t\t\tA[j] = temp;\n\t\t}\n\t}\n\n\ttemp = A[j+1];\n\tA[j+1] = A[r];\n\tA[r] = temp;\n\n\treturn j+1;\n}\n\nvoid quicksort(int *A,int p,int r)\n{\n\tint q;\n\n\tif (p < r)\n\t{\n\t\tq = partition(A,p,r);\n\t\tquicksort(A,p,q-1);\n\t\tquicksort(A,q+1,r);\n\t}\n}\n\nint solve_swap(int *a,int *b,int n)\n{\n\tint sum,temp;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (a[i] != b[i])\n\t\t{\n\t\t\tfor(int j = i+1; j < n; j++)\n\t\t\t{\n\t\t\t\tif (b[j] == a[i] && b[i] == a[j])\n\t\t\t\t{\n\t\t\t\t\ttemp = a[i];\n\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\ta[j] = temp;\n\n\t\t\t\t\tsum += a[i] + a[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n\nint solve1(int *a,int *b,int n)\n{\n\tbool check;\n\tint min,num,temp,sum,start;\n\n\tsum = 0;\n\tstart = 0;\n\n\twhile(1)\n\t{\n\t\tmin = INF;\n\t\t\n\t\tcheck = true;\n\n\t\t//printf(\"start = %d\\n\", start);\n\n\t\tfor(int i = start; i < n; i++)\n\t\t{\n\t\t\tif (min > a[i] && a[i] != b[i])\n\t\t\t{\n\t\t\t\tnum = i;\n\t\t\t\tmin = a[num];\n\t\t\t}\n\t\t}\n\n\t\t//printf(\"num = %d\\n\", num);\n\t\t//printf(\"min = %d\\n\", min);\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (a[i] == b[num])\n\t\t\t{\n\t\t\t\t//printf(\"%d and %d are swapped\\n\", a[num],a[i]);\n\t\t\t\tsum += a[num] + a[i];\n\t\t\t\ttemp = a[i];\n\t\t\t\ta[i] = min; // min = a[num]\n\t\t\t\ta[num] = temp;\n\t\t\t\tnum = i;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (a[i] != b[i])\n\t\t\t{\n\t\t\t\tcheck = false;\n\t\t\t\tstart = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\t//printf(\"a[i] = %d\\n\", a[i]);\n\t\t}\n\n\t\tif (check)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn sum;\n}\n\nbool check(int *A,int *B,int n)\n{\n\tbool c = true;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (A[i] != B[i])\n\t\t{\n\t\t\tc = false;\n\t\t}\n\t}\n\n\treturn c;\n}\n\nint main()\n{\n\tint n,a[1000] = {0},b[1000] = {0},a2[1000] = {0};\n\tint sum1 = 0,sum2 = 0,pivot = 0,pivot1 = 0,pivot2= 0,min = 0,start=0,temp=0,k=0;\n\n\tscanf(\"%d\", &n);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\tb[i] = a[i];\n\t}\n\n\tquicksort(b,0,n-1);\n\n\tsum1 = solve_swap(a,b,n);\n\n\t//printf(\"sum = %d\\n\", sum1);\n\n\t\n\tif (check(a,b,n))\n\t{\n\t\tprintf(\"%d\\n\", sum1);\n\t\treturn 0;\n\t}\n\n\n\tsum2 = sum1;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\ta2[i] = a[i];\n\t}\n\n\t//printf(\"\\nhere is sum1\\n\");\n\n\tsum1 += solve1(a,b,n);\n\n\t//printf(\"sum1 = %d\\n\",sum1);\n\n\n\tif (check(a,b,n))\n\t{\n\t\tprintf(\"%d\\n\", sum1);\n\t\treturn 0;\n\t}\n\n\n\n\tfor(int i = 1; i < n - start; i++)\n\t{\n\t\tk = start;\n\n\t\t\n\t\twhile(1)\n\t\t{\n\t\t\tif (b[pivot1] == a[k])\n\t\t\t{\n\t\t\t\tprintf(\"%d and %d are swapped\\n\", a[pivot1],a[k]);\n\t\t\t\ttemp = a[pivot1];\n\t\t\t\ta[pivot1] = a[k];\n\t\t\t\ta[k] = temp;\n\n\t\t\t\tsum1 += a[pivot1] + a[k];\n\t\t\t\tpivot1 = k;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tprintf(\"%d \", a[i]);\n\t\t}\n\t\tcout << endl;\n\t}\n\n\n\tif (!check(a,b,n))\n\t{\n\t\tprintf(\"\\nhere is sum2\\n\");\n\t\ttemp = a2[pivot2];\n\t\ta2[pivot2] = a2[0];\n\t\ta2[0] = temp;\n\n\t\tfor(int i = 1; i < n - start; i++)\n\t\t{\n\t\t\tint j = start;\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif (b[pivot2] == a2[j])\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d and %d are swapped\\n\", a2[pivot2],a2[j]);\n\t\t\t\t\ttemp = a2[pivot2];\n\t\t\t\t\ta2[pivot2] = a2[j];\n\t\t\t\t\ta2[j] = temp;\n\n\t\t\t\t\tsum2 += a2[pivot2] + a2[j];\n\t\t\t\t\tpivot2 = j;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tprintf(\"%d \", a2[i]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\n\t\tif (sum1 < sum2)\n\t\t{\n\t\t\tprintf(\"sum1 = %d\\n\", sum1);\n\t\t}else\n\t\t{\n\t\t\tprintf(\"sum2 = %d\\n\", sum2);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\n\tprintf(\"%d\\n\", sum1);\n\t\n\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <cstdint>\n#include <map>\n\nusing namespace std;\n\ntemplate<typename T>\nint32_t merge(vector<T> &A, int32_t left, int32_t mid, int32_t right) {\n    int32_t n1 = mid - left;\n    int32_t n2 = right - mid;\n\n    vector<T> L(n1+1);\n    vector<T> R(n2+1);\n    for (int32_t i = 0; i < n1; i++) {\n        L[i] = A[left+i];\n    }\n    for (int32_t i = 0; i < n2; i++) {\n        R[i] = A[mid+i];\n    }\n    L[n1] = INT32_MAX;\n    R[n2] = INT32_MAX;\n\n    int32_t i = 0, j = 0, count = 0;\n    for (int32_t k = left; k < right; k++) {\n        if (L[i] <= R[j]) {\n            A[k] = L[i];\n            i++;\n        } else {\n            A[k] = R[j];\n            j++;\n        }\n        count++;\n    }\n\n    return count;\n}\n\ntemplate<typename T>\nint32_t merge_sort(vector<T> &A, int32_t left, int32_t right) {\n    if (left + 1 < right) {\n        int32_t mid = left + (right - left) / 2;\n        int32_t count1 = merge_sort(A, left, mid);\n        int32_t count2 = merge_sort(A, mid, right);\n        int32_t count3 = merge(A, left, mid, right);\n        return count1 + count2 + count3;\n    }\n\n    return 0;\n}\n\ntemplate<typename T>\nint32_t cost(const vector<T> &unsorted, const vector<T> &sorted, map<vector<int32_t>, int32_t> &mp, int32_t d) {\n    auto itr = mp.find(unsorted);\n    if (itr != mp.end()) {\n        return itr->second;\n    }\n\n    bool is_sorted = true;\n    int32_t c = INT32_MAX;\n\n    for (int32_t i = 0; i < unsorted.size(); i++) {\n        if (unsorted[i] != sorted[i]) {\n            is_sorted = false;\n\n            int32_t j = 0;\n            while (unsorted[i] != sorted[j]) j++;\n\n            vector<T> unsorted2(unsorted);\n            swap(unsorted2[i], unsorted2[j]);\n\n            c = min(c, unsorted2[i] + unsorted2[j] + cost(unsorted2, sorted, mp, d+1));\n        }\n    }\n\n    mp[unsorted] = (is_sorted ? 0 : c);\n    return (is_sorted ? 0 : c);\n}\n\nint main() {\n    int32_t n;\n\n    cin >> n;\n    vector<int32_t> w1(n);\n    for (int32_t i = 0; i < n; i++) {\n        cin >> w1[i];\n    }\n\n    vector<int32_t> w2(w1);\n    merge_sort(w2, 0, n);\n\n    map<vector<int32_t>, int32_t> mp;\n    cout << cost(w1, w2, mp, 1) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <cstdint>\n#include <map>\n\nusing namespace std;\n\ntemplate<typename T>\nint32_t merge(vector<T> &A, int32_t left, int32_t mid, int32_t right) {\n    int32_t n1 = mid - left;\n    int32_t n2 = right - mid;\n\n    vector<T> L(n1+1);\n    vector<T> R(n2+1);\n    for (int32_t i = 0; i < n1; i++) {\n        L[i] = A[left+i];\n    }\n    for (int32_t i = 0; i < n2; i++) {\n        R[i] = A[mid+i];\n    }\n    L[n1] = INT32_MAX;\n    R[n2] = INT32_MAX;\n\n    int32_t i = 0, j = 0, count = 0;\n    for (int32_t k = left; k < right; k++) {\n        if (L[i] <= R[j]) {\n            A[k] = L[i];\n            i++;\n        } else {\n            A[k] = R[j];\n            j++;\n        }\n        count++;\n    }\n\n    return count;\n}\n\ntemplate<typename T>\nint32_t merge_sort(vector<T> &A, int32_t left, int32_t right) {\n    if (left + 1 < right) {\n        int32_t mid = left + (right - left) / 2;\n        int32_t count1 = merge_sort(A, left, mid);\n        int32_t count2 = merge_sort(A, mid, right);\n        int32_t count3 = merge(A, left, mid, right);\n        return count1 + count2 + count3;\n    }\n\n    return 0;\n}\n\ntemplate<typename T>\nint32_t cost(const vector<T> &unsorted, const vector<T> &sorted, map<vector<int32_t>, int32_t> &mp) {\n    bool is_sorted = true;\n    int32_t c = INT32_MAX;\n\n    for (int32_t i = 0; i < unsorted.size(); i++) {\n        if (unsorted[i] != sorted[i]) {\n            is_sorted = false;\n\n            int32_t j = 0;\n            while (unsorted[i] != sorted[j]) j++;\n\n            vector<T> unsorted2(unsorted);\n            swap(unsorted2[i], unsorted2[j]);\n\n            auto itr = mp.find(unsorted2);\n            int32_t c2;\n            if (itr != mp.end()) {\n                c2 = itr->second;\n            } else {\n                c2 = unsorted2[i] + unsorted2[j] + cost(unsorted2, sorted, mp);\n                mp[unsorted2] = c2;\n            }\n            c = min(c, c2);\n        }\n    }\n\n    return (is_sorted ? 0 : c);\n}\n\nint main() {\n    int32_t n;\n\n    cin >> n;\n    vector<int32_t> w1(n);\n    for (int32_t i = 0; i < n; i++) {\n        cin >> w1[i];\n    }\n\n    vector<int32_t> w2(w1);\n    merge_sort(w2, 0, n);\n\n    map<vector<int32_t>, int32_t> mp;\n    cout << cost(w1, w2, mp) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\nusing namespace std;\n#define M 1001\n#define MAX 10000\n\nint n,A[M],s;\nint B[M],T[MAX+1];\nbool V[M];\n\nint solve(){\n\tint ans = 0;\n\tint i;\n\tfor( i=0 ; i < n; i++ ){\n\t\tB[i]=A[i];\n\t}\n\tsort(B,B+n);\n\tfor( i = 0; i < n; i++ ) T[B[i]]=i;\n\tfor( i = 0; i < n; i++ ){\n\t\tif(V[i]) continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = MAX;\n\t\tint an = 0;\n\t\twhile(!V[cur]){\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m,v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t}\n\t\tans += min(S+(an-2)*m,S+m+(an+1)*s);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\ts = MAX;\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\",&A[i]);\n\t\ts = min(s,A[i]);\n\t}\n\tprintf(\"%d\\n\",solve());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace  std;\n\nvoid fnInput(int &rnMaxSiz, vector<int> &rvnSort)\n{\n  cin >> rnMaxSiz;\n\n  rvnSort.resize(rnMaxSiz);\n  for (int i = 0; i < rnMaxSiz; i++)\n    cin >> rvnSort[i];\n}\n\nint fnPartition(vector<int> &rvnSort, int &nSwpCnt, int nFront, int nBack)\n{\n  int nMid = nFront;\n\n  for (int i = nFront; i < nBack; i++)\n    if (rvnSort[i] <= rvnSort[nBack])\n    {\n      if (rvnSort[nMid] != rvnSort[i])\n        nSwpCnt += rvnSort[nMid] + rvnSort[i];\n      swap(rvnSort[nMid++], rvnSort[i]);\n    }\n\n  if (rvnSort[nMid] != rvnSort[nBack])\n    nSwpCnt += rvnSort[nMid] + rvnSort[nBack];\n  swap(rvnSort[nMid], rvnSort[nBack]);\n  return nMid;\n}\n\nvoid fnQuickSort(vector<int> &rvnSort, int &nSwpCnt, int nFront, int nBack)\n{\n  if (nFront < nBack)\n  {\n    int nMid = fnPartition(rvnSort, nSwpCnt, nFront, nBack);\n    fnQuickSort(rvnSort, nSwpCnt, nFront, nMid - 1);\n    fnQuickSort(rvnSort, nSwpCnt, nMid + 1, nBack);\n  }\n}\n\nvoid fnResult(int nSwpCnt)\n{\n  cout << nSwpCnt << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int nMaxSiz;\n  vector<int> vnSort;\n  int nSwpCnt = 0;\n\n  fnInput(nMaxSiz, vnSort);\n  fnQuickSort(vnSort, nSwpCnt, 0, vnSort.size() - 1);\n  fnResult(nSwpCnt);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<math.h>\n#define Lens 1000\n\nusing namespace std;\nint N,mini;\nint A[Lens], B[Lens],C[Lens];\nbool V[Lens];\n\nint solve()\n{\n\tint total=0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B, B + N);\n\tmini = B[0];\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tC[B[i]] = i;\n\t\tif (B[i] == A[i]) V[i] = true;\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\twhile (V[i] == false)\n\t\t{\n\t\t\tint tmp = A[i];\n\t\t\tint min_tmp;\n\t\t\tint next = C[A[i]];\n\t\t\tint sum =A[i];\n\t\t\tint n = 0;\n\t\t\tV[i] = true;\n\t\t\tmin_tmp= min(A[i], A[next]);\n\t\t\twhile (!V[next])\n\t\t\t{\n\t\t\t\tn++;\n\t\t\t\tV[next] = true;\n\t\t\t\tsum = sum + A[next];\n\t\t\t\tif (A[next] < min_tmp) \n\t\t\t\t\tmin_tmp = A[next];\n\t\t\t\tnext= C[A[next]];\n\t\t\t}\n\t\t\ttotal = total + min(sum + (n - 1)*min_tmp, sum + min_tmp + (n + 2)*mini);\n\t\t}\n\t\t\n\t}\n\treturn total;\n}\n\nint main()\n{\n\tcin >> N;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> A[i];\n\t}\n\tint s = solve();\n\tcout << s << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "let quick_sort a n cmp =\n  let swap i j = let tmp = a.(i) in a.(i) <- a.(j); a.(j) <- tmp in\n  let partition p r =\n    let i = ref p in\n    for j = p to r - 1 do\n      if cmp a.(j) a.(r) <= 0 then (swap !i j; incr i)\n    done;\n    swap !i r;\n    !i in\n  let rec doit p r =\n    if p >= r then () else\n    let q = partition p r in\n    doit p (q - 1);\n    doit (q + 1) r in\n  doit 0 (n - 1)\n\nlet calc_cost a n =\n  let b = Array.copy a in\n  quick_sort b n compare;\n  let t = Array.make (b.(n-1) + 1) 0 in\n  Array.iteri (fun i e -> t.(e) <- i) b;\n  let p = Array.make n false in\n  let rec cycle i acc =\n    p.(i) <- true;\n    let j = t.(a.(i)) in\n    if p.(j) then a.(i) :: acc\n    else cycle j (a.(i) :: acc) in\n  let cycle i = cycle i [] in\n  let rec doit i acc =\n    if i = n then acc\n    else if p.(i) then doit (i + 1) acc\n    else\n      let ws = cycle i in\n      let m = List.length ws in\n      let s = List.fold_left (+) 0 ws in\n      let z = List.fold_left min max_int ws in\n      doit (i + 1) (acc + (min (s + (m - 2)*z) (s + z + (m + 1)*b.(0)))) in\n  doit 0 0\n\nlet () =\n  let n = read_int () in\n  let a = Array.init n (fun _ -> Scanf.scanf \"%d \" (fun e -> e)) in\n  calc_cost a n |> Printf.printf \"%d\\n\"\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <cstdio>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nint sorting(vector<short> v)\n{\n\tmap<vector<short>, int> d;\n\t\n\tvector<short> sorted(v.begin(), v.end());\n\t\n\tsort(v.begin(), v.end());\n\t\n\tqueue<pair<vector<short>, int> > que;\n\t\n\tque.push(make_pair(v, 1)); d[v] = 1; // pair(vector, cost + 1)\n\t\n\twhile(!que.empty())\n\t{\n\t\tvector<short> v1 = que.front().first;\n\t\t\n\t\tint cost = que.front().second; que.pop();\n\t\t\n\t\tfor(int i = 0; i < v.size(); i++)\n\t\t{\n\t\t    for(int j = i + 1; j < v.size(); j++)\n\t\t    {\n\t\t        vector<short> v2(v1.begin(), v1.end());\n\t\t        \n\t\t        int cost2 = cost + v1[i] + v1[j];\n\t\t        \n\t\t        swap(v2[i], v2[j]);\n\t\t        \n\t\t        if(d[v2] == 0 || d[v2] > cost2)\n\t\t        {\n\t\t            d[v2] = cost2;\n\t\t            \n\t\t            que.push(make_pair(v2, cost2));\n\t\t        }\n\t\t    }\n\t\t}\n\t}\n\t\n\treturn d[sorted] - 1;\n}\n\nint main()\n{\n\tvector<short> v; int n;\n\t\n\tscanf(\"%d\", &n); v = vector<short>(n);\n\t\n\tfor(int i = 0; i < n; i++) { cin >> v[i]; }\n\t\n\tprintf(\"%d\\n\", sorting(v));\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\nusing namespace std;\nstatic const int MAX = 200000;\n\nvoid trace(int data[], int n) {\n  cout << data[0];\n  for (int i = 1; i < n; i++) {\n    //cout << \" \" << data[i];\n    printf(\"%2d \", data[i]);\n  }\n  cout << endl;\n}\n\nint bsearch(int data[], int target, int left, int right) {\n  // target in [left, ... ,right]\n  int mid;\n  while (left <= right) {\n    mid = (left + right) / 2;\n    if (data[mid] == target) {\n      return mid;\n    } else if (data[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  return -1;\n}\n\nint main() {\n  int n;\n  int data[MAX];\n  int sorted[MAX];\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> data[i];\n    sorted[i] = data[i];\n  }\n  sort(sorted, sorted + n);\n  int allmin = sorted[0];\n  int total = 0;\n  for (int i = 0; i < n; i++) {\n    int ans = sorted[i];\n    int x = data[i];\n    if (ans == x)\n      continue;\n\n    int count = 0;\n    int cyclemin = x;\n    int sum = x;\n    while (ans != x) {\n      int j = bsearch(sorted, x, 0, n - 1);\n      swap(x, data[j]);\n      sum += x;\n      cyclemin = min(x, cyclemin);\n      count++;\n    }\n    data[i] = x;\n    int cost1 = sum + (count - 1) * cyclemin;\n    int cost2 = cost1 + 2*(cyclemin+allmin) - count*(cyclemin - allmin);\n    total += min(cost1, cost2);\n  }\n\n  cout << total << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// 12:41\n//\n\n// w[0], w[1], ..., w[n-1]\n// ex. 9 7 6 1\n//  -> 1 6 7 9 \n// このように 1, 9の交換, 6,7の交換のようにペアの交換で済む場合は,\n// ex. 2 3 1\n//  -> 1 2 3 \n// このように, 1, 2, 3の3つ以上の巡回置換の場合は,\n// ...\n// まとめると, 辿っていくと問題がある. \n\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <unordered_set>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\nusing ll = long long;\n\nstruct Value {\n\tll v;\n\tll idx;\n};\n\nclass lesserValue{\npublic:\n\tbool operator()(const Value &x, const Value &y) {\n\t\treturn x.v < y.v;\n\t}\n};\n\nvoid print(const vector<Value> &x) {\n\tfor (ll i=0;i<x.size();++i) {\n\t\tif (i!=0) cout << \" \";\n\t\tcout << x[i].v << \",\" << x[i].idx;\n\t}\n\tcout << endl;\n}\n\nint main() {\n\tll n;\n\tcin >> n;\n\tvector<Value> w(n);\n\tfor (ll i=0;i<n;++i) {\n\t\tscanf(\"%lld\", &w[i].v);\n\t\tw[i].idx = i;\n\t}\n\t//print(w);\n\tvector<Value> orig(w);\n\t//print(orig);\n\t// sort by ascending order\n\tsort(w.begin(), w.end(), lesserValue()); \n\t//print(w);\n\tunordered_set<ll> memo;\n\tll ans = 0;\n\tfor (ll i=0;i<n;++i) {\n\t\t// orig: 4 2 3\n\t\t// 0 1 2\n\t\t// w:    2 3 4\n\t\t// 1 2 0\n\t\t// w[0].v = 2;\n\t\t// i = 0; \n\t\t// j = w[i].idx;\n\t\t// w[0].idx = 1;\n\t\t// w[1].idx = 2;\n\t\t// w[2].idx = 0;\n\t\t//cout << \"[\" << i << \"]: \"; \n\t\tif (memo.end() != memo.find(i)) {\n\t\t\t//cout << \"skipped \" << i << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tmemo.insert(i);\n\t\t//cout << \"inserted \" << i << \" \";\n\t\tvector<ll> t;\n\t\tll j = i;\n\t\tdo {\n\t\t\tt.push_back(orig[j].v + w[j].v);\n\t\t\tmemo.insert(j);\n\t\t\t//cout << \"inserted \" << j << \" \" << endl;\n\t\t \tj\t= w[j].idx;\n\t\t} while (i != j);\n\t\tans += accumulate(t.begin(), t.end(), 0);\n\t\tif (t.size() > 0) {\n\t\t\tans -= *max_element(t.begin(), t.end());\n\t\t}\n\t\t//cout << \"ans[\" << i << \"] = \" << ans << endl;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tint n, res = 0;\n\tcin >> n;\n\tvector<int> w(n), s(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> w[i];\n\t\ts[i] = w[i];\n\t}\n\tsort(s.begin(), s.end());\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (w[j] == s[i]){\n\t\t\t\tif (j != i) {\n\t\t\t\t\tres += w[i] + w[j];\n\t\t\t\t\tswap(w[i], w[j]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <map>\n#include <memory>\n#include <set>\n#include <vector>\n#include <deque>\n#include <list>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\nclass MinCostSort\n{\npublic:\n  int w[1000];\n  int sw[1000];\n  int solve();\n};\n\nint MinCostSort::solve()\n{\n  int cost = 0;\n  int n;\n  cin >> n;\n  \n  for ( int i = 0; i < n; ++i )\n    {\n      cin >> w[i];\n      sw[i] = w[i];\n    }\n\n  sort( sw, sw + n );\n\n  int j, k;\n  \n  for ( int i = 0; i < n; ++i )\n    {\n      for ( j = 0; j < n; ++j )\n        {\n          if ( sw[i] == w[j] )\n            break;\n        }\n      for ( k = 0; k < n; ++k )\n        {\n          if ( sw[j] == w[k] )\n            break;\n        }\n\n      if ( j != k )\n        {\n          cost += (w[j] + w[k]);\n          swap( w[j], w[k] );\n        }\n    }\n  \n  cout << cost << endl;\n  \n  return 0;\n}\n\nint main()\n{\n\n  MinCostSort mcs;\n\n  mcs.solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint solve() {\n  int ans = 0;\n\n  bool V[MAX];\n  for ( int i = 0; i < n; i++ ) {\n    B[i] = A[i];\n    V[i] = false;\n  }\n\n  sort(B, B+n);\n  for ( int i = 0; i < n; i++ ) T[B[i]] = i;\n  for ( int i = 0; i < n; i++ ) {\n    if ( V[i] ) continue;\n    int cur = i;\n    int S = 0;\n    int m = VMAX;\n    int an = 0;\n    while ( 1 ) {\n      V[cur] = true;\n      an++;\n      int v = A[cur];\n      m = min(m, v);\n      S += v;\n      cur = T[v];\n      if ( V[cur] ) break;\n    }\n    ans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n  }\n\n  return ans;\n}\n\nint main() {\n  cin >> n;\n  s = VMAX;\n  for ( int i = 0; i < n; i++ ) {\n    cin >> A[i];\n    s = min(s, A[i]);\n  }\n  int ans = solve();\ncout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nint main() {\n\tint n, ans = 0;\n\tcin >> n;\n\tint arr[n], sorted[n];\n\tbool visit[n] = { false };\n\tmap<int, int> mp;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i];\n\t\tsorted[i] = arr[i];\n\t}\n\tsort(sorted, sorted + n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (arr[i] == sorted[j]) {\n\t\t\t\tmp[i] = j;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tint suffix = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (visit[i] == false) {\n\t\t\t\tsuffix = i;\n\t\t\t}\n\t\t}\n\t\tif (suffix == -1) {\n\t\t\tbreak;\n\t\t}\n\n\t\tint m = 0, min_in = 10001, min_out = 10001, sum = 0;\n\t\tbool used[n] = { false };\n\t\twhile (used[suffix] == false) {\n\t\t\tm++;\n\t\t\tsum += arr[suffix];\n\t\t\tmin_in = min(min_in, arr[suffix]);\n\n\t\t\tused[suffix] = visit[suffix] = true;\n\t\t\tsuffix = mp[suffix];\n\t\t}\n\n\t\tif (m > 1) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (used[i] == false) {\n\t\t\t\t\tmin_out = min(min_out, arr[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tans += sum + min((m - 2) * min_in, min_in + (m + 1) * min_out);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve(){\n\tint ans = 0;\n\n\tbool V[MAX];\n\tfor (int i = 0; i < n; i++) {\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; i++)T[B[i]] = i;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (V[i])continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile (1) {\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS+= v;\n\t\t\tcur = T[[v];\n\t\t\tif (V[cur])break;\n\t\t}\n\t\tans += min(S + (an - 2)*m, m + S + (an + 1)*s);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tcin >> n;\n\ts = VMAX;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tint ans = solve();\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <cstdio>\n#include <vector>\n#include <utility>\n#include <algorithm>\n \nusing namespace std;\n \nint sorting(vector<short> v)\n{\n    unsigned char size_ = v.size();\n    \n    map<vector<short>, int> d;\n     \n    vector<short> sorted(v.begin(), v.end());\n     \n    sort(v.begin(), v.end());\n     \n    queue<pair<vector<short>, int> > que;\n     \n    que.push(make_pair(v, 1)); d[v] = 1; // pair(vector, cost + 1)\n     \n    while(!que.empty())\n    {\n        vector<short> v1 = que.front().first;\n         \n        int cost = que.front().second; que.pop();\n         \n        for(char i = 0; i < size_; i++)\n        {\n            for(char j = i + 1; j < size_; j++)\n            {\n                vector<short> v2(v1.begin(), v1.end());\n                 \n                int cost2 = cost + v1[i] + v1[j];\n                 \n                swap(v2[i], v2[j]);\n                 \n                if(d[v2] == 0 || d[v2] > cost2)\n                {\n                    d[v2] = cost2;\n                     \n                    que.push(make_pair(v2, cost2));\n                }\n            }\n        }\n    }\n     \n    return d[sorted] - 1;\n}\n \nint main()\n{\n    vector<short> v; int n;\n     \n    scanf(\"%d\", &n); v = vector<short>(n);\n     \n    for(int i = 0; i < n; i++) { scanf(\"%d\", &v[i]); }\n     \n    printf(\"%d\\n\", sorting(v));\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : MinCostSort.cpp\n// Author      : Ken\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_W = 10001;\n\nvoid writeVector(vector<int>& v){\n\tfor(int i=0; i<v.size(); i++){\n\t\tcout << v.at(i) << \"\\n\";\n\t}\n}\n\nvoid writeVector(vector<bool>& v){\n\tfor(int i=0; i<v.size(); i++){\n\t\tcout << v.at(i) << \"\\n\";\n\t}\n}\n\nint main() {\n\tint n, input, min_all=MAX_W, total_sum=0;\n\tcin >> n;\n\tvector<int> v, inv_v(MAX_W);\n\tvector<bool> isIterated(n);\n\n\tfor(int i=0; i<isIterated.size(); i++){\n\t\tisIterated.at(i) = false;\n\t}\n\n\n\tfor(int i=0; i<n; i++){\n\t\tcin >> input;\n\t\tv.push_back(input);\n\t\tinv_v.at(input) = i;\n\t\tif(input<min_all){\n\t\t\tmin_all = input;\n\t\t}\n\t}\n\n\tsort(v.begin(), v.end());\n\n\t//cout << \"v:\\n\";\n\t//writeVector(v);\n\t//cout << \"inv_v:\\n\";\n\t//writeVector(inv_v);\n\t//cout << \"isIterated:\\n\";\n\t//writeVector(isIterated);\n\n\tfor(int i=0; i<v.size(); i++){\n\t\tint min_in_loop = MAX_W;\n\t\tint sum_loop = 0;\n\t\tint pos = i;\n\t\tint elem = v.at(i);\n\t\tint loop_size = 0;\n\n\t\tif(not isIterated.at(pos)){\n\t\t\tisIterated.at(pos) = true;\n\n\t\t\tif(inv_v.at(v.at(pos)) == pos){\n\t\t\t\t//cout << \"single loop: \" << v.at(pos) << \"\\n\";\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//cout << \"multi loop: \";\n\t\t\twhile(true){\n\t\t\t\tloop_size++;\n\t\t\t\tisIterated.at(pos) = true;\n\t\t\t\t//cout << elem << \" \";\n\n\t\t\t\tsum_loop += elem;\n\n\t\t\t\tif(elem < min_in_loop){\n\t\t\t\t\tmin_in_loop = elem;\n\t\t\t\t}\n\n\t\t\t\tpos = inv_v.at(elem);\n\t\t\t\telem = v.at(pos);\n\n\t\t\t\tif(isIterated.at(pos)){\n\t\t\t\t\t//cout << \"sum_loop: \" << sum_loop << \", min_in_loop: \" << min_in_loop << \" \"\n\t\t\t\t\t//\t << \"loop_size: \" << loop_size << \"\\n\";\n\t\t\t\t\t//cout << \"\\n\";\n\n\t\t\t\t\tint add = min(min_in_loop*(loop_size-2), min_in_loop + min_all*(loop_size+1));\n\n\t\t\t\t\ttotal_sum += sum_loop + add;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << total_sum << \"\\n\";\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, a[1009], c[1009]; bool vis[1009];\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (a[i] > a[j]) c[i]++;\n\t\t}\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (vis[i]) continue;\n\t\tint pos = i, m = 0;\n\t\twhile (!vis[pos]) {\n\t\t\tvis[pos] = true;\n\t\t\tret += a[pos] * 2;\n\t\t\tm = max(m, a[pos] + a[c[pos]]);\n\t\t\tpos = c[pos];\n\t\t}\n\t\tret -= m;\n\t}\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n;\nvoid merge(int A[],int left, int mid, int right) {\n  int n1 = mid - left;\n  int n2 = right - mid;\n  int L[n1+1]; int R[n2+1];\n  for(int i=0;i<n1;i++) {\n    L[i] = A[left+i];\n  }\n  for(int i=0;i<n2;i++) {\n    R[i] = A[mid+i];\n  }\n  L[n1] = R[n2] = 0x7FFFFFFF;\n  int i = 0; int j = 0;\n  for(int k=left;k<right;k++) {\n    if(L[i] <= R[j]) {\n      A[k] = L[i];\n      i++;\n    }\n    else {\n      A[k] = R[j];\n      j++;\n    }\n  }\n}\nvoid merge_sort(int A[],int left, int right) {\n  if(right - left > 1) {\n    int mid = (left + right) / 2;\n    merge_sort(A,left, mid);\n    merge_sort(A,mid, right);\n    merge(A,left, mid, right);\n  }\n}\n\nint search(int W[],int left,int right, int key) {\n  for(int i=0;i<n;i++) {\n    if(W[i] == key)\n      return i;\n  }\n  return -1;\n}\nint binary_search(int Sorted[],int left,int right, int key) {\n  while(right >= left) {\n    int mid = (left+right)/2;\n    if(Sorted[mid] == key)\n      return mid;\n    else if(Sorted[mid] < key)\n      left = mid + 1;\n    else\n      right = mid - 1;\n  }\n  return -1;\n}\n\n\nint main() {\n  cin >> n;\n  int W[n]; int Sorted[n];\n  for(int i=0;i<n;i++) {\n    int num; cin >> num;\n    W[i] = Sorted[i] = num;\n  }\n  merge_sort(Sorted,0,n);\n\n  // algorithm : https://www.ipsj.or.jp/07editj/promenade/4506.pdf\n  vector<int> R;\n  for(int i=0;i<n;i++) {\n    if(binary_search(Sorted,i,n,W[i]) != i)\n      R.push_back(Sorted[i]);\n  }\n  int Smin = Sorted[0];\n  int Rmin = R[0];\n  int sum = 0;\n  for(int i=0;i<R.size();i++) {\n    sum += R[i];\n  }\n  int cost;\n  if(R.size() > 1)\n    cost = min(sum+Rmin*(R.size()-2),sum+Rmin+Smin*(R.size()+1));\n  else\n    cost = 0;\n\n  cout << cost << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n\n\nusing namespace std;\n\nint main() {\n\t\n\tint const N_MAX = 1000;\n\tint const W_MAX = 10000;\n\n\tint n = 0;\n\tcin >> n;\n\n\tvector<int> W, S, T;\n\tvector<bool> C;\n\t\n\tW.resize(n, 0);     // idx -> W\n\tS.resize(n, 0);     // sorted Wi\n\tT.resize(W_MAX, 0); // W -> idx\n\tC.resize(n, false); // flag for searched or not\n\n\tint g_min = W_MAX; // global_min of Wi\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> W[i];\n\t\tg_min = (W[i] < g_min) ? W[i] : g_min;\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tT[W[i]] = i;\n\t}\n\n\tS = W;\n\tstable_sort(S.begin(), S.end());\n\n\tint cost = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!C[T[S[i]]]) {\n\t\t\tint l_min = W_MAX;\n\t\t\tint sum = 0;\n\t\t\tint cnt = 0;\n\t\t\tvector<int> L;\n\t\t\tfor(int j = S[i]; !C[T[j]]; j = S[T[j]] ) {\n\t\t\t\tC[T[j]] = true;\n\t\t\t\tcnt++;\n\t\t\t\tsum += j;\n\t\t\t\tl_min = (j < l_min) ? j : l_min;\n\t\t\t}\n\t\t\tcost += min(sum + l_min*(cnt - 2), sum+g_min*(cnt-2)+l_min);\n\t\t}\n\t}\n\n\tcout << cost << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "const int MAXN = 1010;\nint w[MAXN];\nbool done[MAXN];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, mini = 100000;\n    cin >> n;\n    map<int, int> mp;\n    for (int i = 0; i < n; i++) {\n        cin >> w[i];\n        mp[w[i]] = 0;\n        mini = min(mini, w[i]);\n    }\n    {\n        int k = 0;\n        for (auto& p : mp) p.second = k++;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (done[i]) continue;\n        int cnt = 0, now = i, mi = 100000, sum = 0;\n        while (1) {\n            if (done[now]) break;\n            cnt++;\n            done[now] = true;\n            mi = min(mi, w[now]);\n            sum += w[now];\n            now = mp[w[now]];\n        }\n        int tmp = sum+(cnt-2)*mi;\n        tmp = min(tmp, sum+mi+mini*(cnt+1));\n        ans += tmp;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define MYDEBUG\n//\n#include <bits/stdc++.h>\n#ifdef MYDEBUG\n#define dbp(x) cout<<#x<<\": \"<<x<<endl\n#define dbp2(x,y) cout<<#x<<\",\"<<#y<<\": \"<<x<<\",\"<<y<<endl\n#define dbp3(x,y,z) cout<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<x<<\",\"<<y<<\",\"<<z<<endl\n#define dbp4(w,x,y,z) cout<<#w<<\",\"<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<w<<\",\"<<x<<\",\"<<y<<\",\"<<z<<endl\n#define ifcin(x) std::ifstream cin(x)\n#else\n#define dbp(x)\n#define dbp2(x,y)\n#define dbp3(x,y,z)\n#define dbp4(w,x,y,z)\n#define ifcin(x)\n#endif\n#define ll long long\n#define all(x) x.begin(), x.end()\n#define rep(i, from, to) for(int i=from; i<to; ++i)\n#define REP(i, from, to) for(int i=from; i<=to; ++i)\nusing namespace std;\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n\tout << \"[\";\n\tsize_t last = v.size() - 1;\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i];\n\t\tif (i != last) {\n\t\t\tout << \",\";\n\t\t}\n\t}\n\tout << \"]\";\n\treturn out;\n}\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T> >& v) {\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i] << endl;\n\t}\n\treturn out;\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& out, const pair<T1, T2>& p) {\n\tout << \"{\" << p.first << \",\" << p.second << \"}\";\n\treturn out;\n}\n\nstatic const int MAX_N = 1000;\nstatic const int MAX_W = 10000 + 1;\nstatic const int INF = 1000000;\nint n;\n\nvoid merge(vector<pair<int, int> > &v, int left, int mid, int right) {\n\tint n1 = mid - left, n2 = right - mid;\n\tvector<pair<int, int> > l = vector<pair<int, int> >(n1 + 1);\n\tvector<pair<int, int> > r = vector<pair<int, int> >(n2 + 1);\n\trep(i,0,n1)\n\t{\n\t\tl[i] = v[left + i];\n\t}\n\trep(j,0,n2)\n\t{\n\t\tr[j] = v[mid + j];\n\t}\n\tl[n1] = r[n2] = make_pair(INF, right);\n\tint i = 0, j = 0;\n\trep(k,0,right-left)\n\t{\n\t\tif (l[i].first <= r[j].first) {\n\t\t\tv[k + left] = l[i++];\n\t\t} else {\n\t\t\tv[k + left] = r[j++];\n\t\t}\n\t}\n}\n\nvoid mergeSort(vector<pair<int, int> > &v, int left, int right) {\n\tif (left + 1 < right) {\n\t\tint mid = (left + right) / 2;\n\t\tmergeSort(v, left, mid);\n\t\tmergeSort(v, mid, right);\n\t\tmerge(v, left, mid, right);\n\t}\n}\n\nvoid getCycle(vector<vector<int> > &cyc, vector<pair<int, int> > &a) {\n\tvector<bool> used(MAX_W);\n\tfill(all(used), false);\n\trep(i,0,(int)a.size())\n\t{\n\t\tif (used[a[i].first]) {\n\t\t\tcontinue;\n\t\t}\n\t\tused[a[i].first] = true;\n\t\tcyc.push_back(vector<int>());\n\t\tint j = a[i].second, tail = cyc.size() - 1;\n\t\twhile (true) {\n\t\t\tused[a[j].first] = true;\n\t\t\tcyc[tail].push_back(a[j].first);\n\t\t\tj = a[j].second;\n\t\t\tif (a[j].first == cyc[tail][0]) { //1巡した\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsort(all(cyc[tail]));\n\t}\n}\n\nint getSmallerCost(vector<int> v, int minW) {\n\tint n = v.size();\n\tif (n == 1) {\n\t\treturn 0;\n\t}\n\tint c1 = 0, c2 = 0;\n\trep(i,0,n)\n\t{\n\t\tc1 += v[i];\n\t\tc2 += v[i];\n\t}\n\tc1 += (n - 2) * v[0];\n\tc2 += (n - 2) * v[0]; //あとから差分を加減して調整\n\t//minWを外から借りてくる\n\t//minW <= v[0]\n\t//得: (n-2) * (v[0] - minW)\n\t//損: 2 * (v[0] + minW)\n\tc2 -= (n - 1) * (v[0] - minW);\t//借り物なのでn-2より1回多い\n\tc2 += 2 * (v[0] + minW);\n\tdbp3(v, c1, c2);\n\treturn min(c1, c2);\n}\n\nvoid solve() {\n\tscanf(\"%d\", &n);\n\t//pair: 値, 元の位置\n\tvector<pair<int, int> > a = vector<pair<int, int> >(n);\n\tvector<vector<int> > cycle = vector<vector<int> >();\n\tint minW = MAX_W;\n\trep(i,0,n)\n\t{\n\t\ta[i] = make_pair(0, i);\n\t\tscanf(\"%d\", &a[i].first);\n\t\tminW = min(minW, a[i].first);\n\t}dbp(a);\n\tmergeSort(a, 0, n);\n\tdbp(a);\n\tgetCycle(cycle, a);\n\tdbp(cycle);\n\tint sum = 0;\n\trep(i,0,(int)cycle.size())\n\t{\n\t\tsum += getSmallerCost(cycle[i], minW);\n\t}\n\tprintf(\"%d\\n\", sum);\n}\n\nvoid printTestCase() {\n\tint n = 1000;\n\tint ins = 0;\n\tprintf(\"%d\\n\", n);\n\trep(i,0,n)\n\t{\n\t\tif (ins++ > 0) {\n\t\t\tprintf(\" \");\n\t\t}\n\t\tprintf(\"%d\", (n - i));\n\t}\n}\n\nint main() {\n\tsolve();\n//\tprintTestCase();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n\n#define MAX 1000\n#define WMAX 10000\n\nint main() {\n    int n;\n    int A[MAX], B[MAX], V[MAX], T[WMAX+1];\n\n    scanf(\"%d\", &n);\n    int min = WMAX;\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &A[i]);\n        B[i] = A[i];\n        V[i] = false;\n        min = std::min(min, A[i]);\n    }\n    std::sort(B, B+n);\n    for (int i = 0; i < n; ++i) T[B[i]] = i;\n\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        if (V[i]) continue;\n\n        int cur = i;\n        int num = 0;\n        int sum = 0;\n        int m = WMAX;\n        while (true) {\n            V[cur] = true;\n            num++;\n            sum += A[cur];\n            m = std::min(m, A[cur]);\n            cur = T[A[cur]];\n            if (V[cur]) break;\n        }\n        ans += std::min(sum + (num - 2) * m, sum + (num - 2) * m + (m + min) * 2 - (m - min) * (num - 1));\n    }\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cctype>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\nconst int inf = 0x3f3f3f3f;\nconst ll INF = 0x3f3f3f3f3f3f3f3f;\nconst ll mod = 1000000007;\nconst int maxn = 1005;\nconst int maxw = 10005;\n\nint a[maxn], b[maxn];\nint Index[maxw];\nbool vis[maxw];\n\n\nint main() {\n\tint n; scanf(\"%d\", &n);\n\n\tint min_w = inf;\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tb[i] = a[i];\n\t\tmin_w = min(min_w, a[i]);\n\t}\n\tsort(b, b + n);\n\n\tfor (int i = 0; i < n; ++i) Index[b[i]] = i;\n\n\tint res = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (vis[i]) continue;\n\n\t\tint cnt = 0, sum = 0;\n\t\tint cur = i;\n\t\tint minm = inf;\n\n\t\twhile (true) {\n\t\t\tif (vis[cur]) break;\n\t\t\tint x = a[cur];\n\t\t\t++cnt; sum += x;\n\t\t\tminm = min(minm, x);\n\t\t\tvis[cur] = true;\n\t\t\tcur = Index[x];\n\t\t}\n\n\t\tres += min(sum + (cnt - 2) * minm, sum + minm + (cnt + 1) * min_w);\n\t}\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve() {\n    int ans = 0;\n\n    bool V[MAX];\n    for (int i = 0; i < n; i++) {\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B, B+n);\n    for (int i = 0; i < n; i++) {\n        T[B[i]] = i;\n    }\n    for (int i = 0; i < n; i++) {\n        if ( V[i] ) continue;\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while (1) {\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m, v);\n            S += v;\n            cur = T[v];\n            if (V[cur] ) break;\n        }\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n    }\n    return ans;\n}\n\nint main() {\n    cin >> n;\n    s = VMAX;\n    for (int i = 0; i < n; i++) {\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n    int ans = solve();\n    cout << ans << '\\n';\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define N 40\n\nbool comp1(const pair<int, int> &a, const pair<int, int> &b)\n{\n    return a.first < b.first;\n}\nbool comp2(const pair<int, int> &a, const pair<int, int> &b)\n{\n    return a.second < b.second;\n}\nint main()\n{\n    int n;\n    cin >> n;\n    int w[n], x[n];\n    for (int i = 0; i < n; i++)\n    {\n        cin >> w[i];\n        x[i] = w[i];\n    }\n\n    sort(x, x + n);\n    for (int i = 0; i < n; i++)\n    {\n        if (i != 0)\n            cout << \" \";\n        cout << x[i];\n    }\n    cout << endl;\n    int *p, *q;\n    int sum = 0, tmp;\n \n    for (int i = 0; i < n; i++)\n    {\n        p = find(w, w + n, x[i]);\n        while (i != p - w)\n        {\n            q = find(w, w + n, x[p - w]);\n            tmp = *p;\n            *p = *q;\n            *q = tmp;\n            sum += *p + *q;\n            p = q;\n        }\n    }\n\n    cout << sum << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX=1000;\nstatic const int VMAX=10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint solve(){\n    int ans = 0;\n    bool V[MAX];\n    \n    for(int i=0;i<n; i++){\n        B[i]=A[i];\n        V[i]=false;\n    }\n    sort(B,B+n);\n    for(int i=0;i<n;i++) T[B[i]] = i;\n    for(int i=0; i<n; i++){\n        if(V[i]) continue;\n        int cur = i;\n        int S=0;\n        int m=VMAX;\n        int an = 0;\n        while (1){\n            V[cur] = true;\n            an++;\n            int v=A[cur];\n            m=min(m,v);\n            S +=v;\n            cur=T[v];\n            if(V[cur]) break;\n        }\n        ans += min(S+(an-2)*m,m+S+(an+1)*s);\n    }\n    return ans;\n}\n\nint main(){\n    cin>>n;\n    s=VMAX;\n    for(int i=0;i<n;i++){\n        cin>>A[i];\n        s=min(s,A[i]);\n    }\n    int ans=solve();\n    cout<<ans<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstatic const int MAX=1000;\nstatic const int VMAX=10000;\n\nint n, A[MAX],s;\nint B[MAX], T[VMAX+1];\n\nint solve(){\n    int ans = 0;\n\n    bool V[MAX];\n    for(int i=0; i<n; ++i){\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B,B+n);\n    for(int i=0; i<n; ++i)\n        T[B[i]] = i;\n    \n    for(int i=0; i<n; ++i){\n        if(V[i])\n            continue;\n        int cur = i;\n        int S=0;\n        int m=VMAX;\n        int an = 0;\n        while( true ){\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m,v);\n            S += v;\n            cur = T[v];\n            if( V[cur] )\n                break;\n        }\n        ans += min(S+(an-2)*m,m+S+(an+1)*s);\n    }\n    return ans;\n}\n\nint main(){\n    cin >> n;\n    s = VMAX;\n    for(int i=0; i<n; i++){\n        cin >> A[i];\n        s= min(s,A[i]);\n    }\n    int ans = solve();\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\n\nint main() {\n\tint n;\n  scanf(\"%d\", &n);\n  int A[n], B[n], C[n];\n  for ( int i = 0; i < n; i++ ) scanf(\"%d\", &A[i]);\n  for ( int i = 0; i < n; i++ ) B[i] = A[i];\n  sort(B, B+n);\n  for ( int i = 0; i < n; i++ ) {\n    for ( int j = 0; j < n; j++ ) {\n      if (A[i] == B[j]) {\n        C[i] = j;\n        break;\n      }\n    }\n  }\n  int k = 0, count = 0;\n  while ( k < n ) {\n    int i, j;\n    for (i = 0; i < n; i++) if (C[i] == k) break;\n    for (j = 0; j < n; j++) if (C[j] == i) break;\n    if (C[k] == k) {\n      k++;\n    } else {\n      count += A[i]+A[j];\n      swap(A[i], A[j]);\n      swap(C[i], C[j]);  \n    }\n  }\n\n  printf(\"%d\\n\", count);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n#include <algorithm>\n#include <cmath>\n\nconst int Wmax = pow(10, 4) + 1;\nint s;\n\nint solve(int A[], int n){\n    bool T[n];\n    int B[n], Index[Wmax];\n    for(int i=0; i<n; i++){\n        T[i] = false;\n        B[i] = A[i];\n    }\n    int total_w = 0;\n    sort(B, B+n);\n    for(int i=0; i<n; i++){ Index[B[i]] = i;}\n    for(int j=0; j<n; j++){\n        if(T[j] == false){\n            T[j] = true;\n            int wmin, sum = 0, cur, cnt=1;\n            wmin = A[j];\n            sum += A[j];\n            cur = Index[wmin];\n            while(cur != j){\n                T[cur] = true;\n                cnt++;\n                sum += A[cur];\n                wmin = min(wmin, A[cur]);\n                cur = Index[A[cur]];\n            }\n            total_w += min(sum+(cnt-2)*wmin, sum+wmin+(cnt+1)*s);\n        }\n    }\n\n    return total_w;\n}\n\nint main(){\n    int n;\n    s = Wmax;\n    scanf(\"%d\", &n);\n    int A[n];\n    for(int i=0; i<n; i++){\n        scanf(\"%d\", &A[i]);\n        s = min(s, A[i]);\n    }\n\n    int ans = solve(A, n);\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int MAXN=1000+2;\nint n,ans;\nint a[MAXN];\n\nstruct fbg{\n\tint val,sit;\n} w[MAXN];\n\nint check(){\n\tfor(int i=0;i<n;++i) if(w[i].val!=a[i]) return 0;\n\treturn 1;\n}\n\nint main(){\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>w[i].val; a[i]=w[i].val;\n\t}\n\tsort(a,a+n);\n\twhile(1){\n\t\tif(check()) break;\n\t\tint now=0x7f7f7f;\n\t\tint i=0;\n\t\tfor(;i<n;++i){\n\t\t\tint j=0;\n\t\t\tfor(;j<n;++j){\n\t\t\t\tif(a[j]==w[i].val){\n\t\t\t\t\tw[i].sit=j;\n\t\t\t\t\tif(i!=j && w[i].val<w[now].val) now=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint x=now;\n\t\twhile(1){\n\t\t\tx=w[x].sit;\n\t\t\tif(w[x].sit==x || w[x].sit==now) break;\n\t\t}\n\t\tswap(w[x].val,w[now].val); ans+=w[x].val+w[now].val;\n\t}\n\tcout<<ans<<endl;\n\treturn 1;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nbool visited[1010];\nint n;\nint w[1010], c[1010];\n\nint partition(int a[], int p, int r) {\n    int x = a[r];\n    int i = p - 1;\n    for (int j = p; j < r; ++j) if (a[j] <= x)swap(a[++i], a[j]);\n    swap(a[++i], a[r]);\n    return i;\n}\n\nvoid quickSort(int a[], int p, int r) {\n    if (p >= r) return;\n    int q = partition(a, p, r);\n    quickSort(a, p, q - 1);\n    quickSort(a, q + 1, r);\n}\n\nint search(int x) {\n    int l = 0, r = n, m;\n    while (r - l > 1) {\n        m = (l + r) / 2;\n        if (c[m] <= x) l = m; else r = m;\n    }\n    return l;\n}\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n        c[i] = w[i];\n    }\n    quickSort(c, 0, n - 1);\n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n        int j = i, cnt = 0, sum = 0, mn = 114514;\n        while (!visited[j]) {\n            visited[j] = true;\n            cnt++;\n            sum += w[j];\n            mn = min(mn, w[j]);\n            j = search(w[j]);\n        }\n        if (cnt > 1) res += sum + mn + min(mn * (cnt - 3), c[0] * (cnt + 1));\n    }\n    cout << res << endl;\n    return 0;\n}\n\n/*--------- TO SOLVE ---------*/\n/*\n * comparing sorted sequence with origin that, you would find that some number are looped in the group.\n * so, calculate sums and minimums of number groups and the cost to do so will be\n *      sum + minimum * (number of group - 2)\n *          or\n *      sum + minimum + (minimum number in the sequence) * (number of group + 1)\n */\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <limits>\n#include <fstream>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int N;cin>>N;\n  int w[N];\n  int mini = 2e9;\n  map<int, int> mp;\n  FOR(i,0,N){\n    cin>>w[i];\n    mini = min(mini, w[i]);\n    mp[w[i]] = 0;\n  }\n  int k = 0;\n  for(auto& m : mp) m.second = k++;\n  bool done[N];\n  CLR(done);\n  int ans = 0;\n  FOR(i,0,N){\n    if(done[i]) continue;\n    int cnt = 0, now = i, mi = 2e9, sum = 0;\n    // 巡回\n    while(!done[now]){\n      cnt++;\n      done[now] = true;\n      sum += w[now];\n      now = mp[w[now]];\n    }\n    if(cnt <= 1) continue;\n    ans += min(sum + mi * (cnt - 2), sum + mi + mini * (cnt + 1));\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1000\n#define MAX_D 10001\n\nint main(){\n  int N, arr[MAX], _arr[MAX], dest[MAX_D];\n  bool used[MAX];\n\n  cin >> N;\n  for(int i = 0 ; i < N ; i++){\n    cin >> arr[i];\n    used[i] = false;\n    _arr[i] = arr[i];\n  }\n  sort(_arr, _arr+N);\n\n  for(int i = 0 ; i < N ; i++){\n    dest[_arr[i]] = i;\n  }\n\n  int ans = 0;\n  for(int i = 0 ; i < N ; i++){\n    if(dest[arr[i]] == i || used[i]){\n      used[i] = true;\n      continue;\n    }\n\n    int cnt = -1, sum = 0, min = arr[i], next = i;\n    for( ; !used[next] ; ){\n      sum += arr[next]; cnt++;\n      min = std::min(min, arr[next]);\n      used[next] = true;\n      next = dest[arr[next]];\n    }\n    sum -= min;\n    ans += sum + min*cnt;\n\n    if(2*(min+_arr[0]) < (min-_arr[0])*cnt){\n      ans -= (min-_arr[0])*cnt - 2*(min+_arr[0]);\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<unordered_map>\n\nstd::vector<int> A, B;\nstd::unordered_map<int, int> map;\nstd::vector<bool> V;\nint n;\nint mmin;\nint minCostSort(){\n    int ans = 0;\n    int min, cnt, tmp;\n    for(int i = 0; i < n; i++){\n\tmin = A[i];\n\tcnt = 0;\n\tif(V[i] == 1) continue;\n\tif(map[A[i]] == i){\n\t    V[i] = 1;\n\t    continue;\n\t}\n\ttmp = i;\n\twhile(1){\n\t    if(V[tmp] == 1){\n\t\tbreak;\n\t    }\n\t    ans += A[tmp];\n\t    V[tmp] = 1;\n\t    cnt++;\n\t    min = std::min(min, A[tmp]);\n\t    tmp = map[A[tmp]];\n\t}\n\tans += std::min((cnt - 2) * min, (cnt + 1) * mmin + min);\n    }\n    return ans;\n}\n\nint main(void){\n    int ans;\n    std::cin >> n;\n    A.resize(n);\n    V.resize(n);\n    for(int i = 0; i < n; i++){\n\tstd::cin >> A[i];\n    }\n    for(int i = 0; i < n; i++){\n\tV[i] = 0;\n    }\n\n    B = A;\n\n\n    std::sort(B.begin(), B.end());\n\n    mmin = B[0];\n    for(int i = 0; i < n; i++){\n\tmap[B[i]] = i;\n    }\n\n    ans = minCostSort();\n\n    std::cout << ans << std::endl;\n\n    return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\n#include<cmath>\nusing namespace std;\n\nvoid show_mincost( int arr[], size_t arr_s, int swap_l_val, int swap_r_val )\n{\n\tcout<<arr[0]<<flush;\n    for( size_t i=1; i<arr_s; i++ ){\n\t\tif( arr[i] == swap_l_val || arr[i] == swap_r_val ){\n\t\t\tcout<<\"(\"<<arr[i]<<')';\n\t\t}else{\n\t\t\tcout<<' '<<arr[i]<<' ';\n\t\t}\n    }\n\tcout<<' '<<\"COST : \"<<swap_l_val<<\" + \"<<swap_r_val<<\" == \"<<swap_l_val+swap_r_val<<endl;\n}\n\nvoid show( int arr[], size_t size )\n{\n\n\tcout<<arr[0]<<flush;\n    for( size_t i=1; i<size; i++ ){\n\t    cout<<' '<<arr[i]<<flush;\n    }\n    cout<<endl;\n}\n\n\n\n\nint merge( int arr[], unsigned int arr_s, unsigned int lft, unsigned int md, unsigned int rgt )\n{\n\tint cnt=0;\n\n\tint left_s=md-lft+1, right_s=rgt-md+1, *left=new int[left_s], *right=new int[right_s];\n\tfor( int i=0; i<left_s-1; i++ ){\n\t\tleft[i]=arr[lft+i];\n\t}\n\tleft[left_s-1]=INT_MAX;\n\tfor( int i=0; i<right_s-1; i++ ){\n\t\tright[i]=arr[md+i];\n\t}\n\tright[right_s-1]=INT_MAX; \n\n\n\tfor( int i=0, left_i=0, right_i=0; i<left_s+right_s-2; i++, cnt++ ){\n\t\tif( left[left_i] <= right[right_i] ){ \n\t\t\tarr[lft+i]=left[left_i];\n\t\t\t++left_i;\n\t\t}else{\n\t\t\tarr[lft+i]=right[right_i];\n\t\t\t++right_i;\n\t\t}\n\t}\n\n\tdelete[] right;delete[] left;\n\treturn cnt;\n}\nint mergeSort( int arr[], unsigned int arr_s, unsigned int lft, unsigned int rgt ) \n{\n\tstatic int cnt=0;\n\t\tunsigned int md=(lft + rgt)/2;\n\tif( rgt - lft >=2 ){\n\n\t\tmergeSort(arr, arr_s, lft, md);  \n\t\tmergeSort(arr, arr_s, md, rgt);\n\t\tcnt+= merge(arr, arr_s, lft, md, rgt); \n\t\n\t}\n\treturn cnt;\n}\nsize_t idxKey( int arr[], size_t arr_s, int key )\n{\n\tfor( size_t i=0; i!=arr_s; i++ ){\n\t\tif( arr[i] == key ) return i;\n\t}\n\treturn arr_s;\n}\n\nunsigned int minCost( int arr[], size_t arr_s )\n{\n\tint *sorted=new int[arr_s];\n\tfor( size_t i=0; i<arr_s; i++ ){\n\t\tsorted[i]=arr[i];\n\t}\n\tmergeSort(sorted, arr_s, 0, arr_s); //????????????????????¶?????¨???????????¨\n\tshow(sorted, arr_s);\n\n\tunsigned int cost=0;\n\tint swap_l_val, swap_l_idx, swap_r_val, swap_r_idx;\n\tfor( size_t i=0; ; ){ \n\t\twhile( idxKey( arr, arr_s, sorted[i] ) == i ){\n\t\t\ti++;\n\t\t}\n\t\tswap_l_idx= idxKey(arr, arr_s, sorted[i]);//?°????????????????i?????????????????\\??£???????????????????????????\n\t\tswap_r_idx= idxKey( arr, arr_s, sorted[idxKey(arr, arr_s, sorted[i] ) ] );\n//?°????????????????i???????????\\??£?????????,arr???????????????????????¨???????????????????????????sorted???????????\\??£?????????arr?????????????????????\n\t\tif( swap_l_idx == swap_r_idx ) break;\n\n\t\tswap_l_val=arr[ swap_l_idx];\n\t\tswap_r_val=arr[ swap_r_idx];\n//\t\tcout<<\"swap_l_val : \"<<swap_l_val<<' '<<\"swap_r_val : \"<<swap_r_val<<endl;\n\n\t\tswap( arr[ idxKey(arr, arr_s, sorted[i]) ], arr[ idxKey( arr, arr_s, sorted[idxKey(arr, arr_s, sorted[i])] )]);\n\t\tcost+=swap_l_val + swap_r_val; \n\n\t\tshow_mincost(arr, arr_s, swap_l_val, swap_r_val);\n\t}\n\treturn cost;\n}\n\nint main()\n{\n\tsize_t arr_s;cin>>arr_s;\n\tint *arr=new int[arr_s];\n\tfor( size_t i=0; i<arr_s; i++ ){\n\t\tcin>>arr[i];\n\t}\n\n\tlong long mincst=minCost( arr, arr_s );\n//\tshow(arr, arr_s);\n\tcout<<mincst<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define fordebug int hoge;cin>>hoge;\n#define DEKAI 1000000007;\n#define INF 200000000\n#define int long long\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,j,n) for(int i=j;i<n;i++)\npair<int,char> a[100000],b[100000];\npair<int,char> rr[100000],ll[100000];\n\nsigned main(){\n\tint n;\n\tcin>>n;\n\tint a[1000],b[1000];\n\tint mini=INF;\n\tlp(i,n){\n\t\tcin>>a[i];\n\t\tb[i]=a[i];\n\t\tmini=min(mini,a[i]);\n\t}\n\tsort(b,b+n);\n\tint x[100000];\n\tlp(i,n){\n\t\tx[b[i]]=i;\n\t}\n\tint ans=0;\n\tbool done[1000]={false};\n\tlp(i,n){\n\t\tif(done[i]||a[i]==b[i]) continue;\n\t\tint sum=0,mini2=INF;\n\t\tint count=0;\n\t\tint j=i;\n\t\twhile(!done[j]){\n\t\t\tmini2=min(mini2,a[j]);\n\t\t\tsum+=a[j];\n\t\t\tdone[j]=true;\n\t\t\tj=x[a[j]];\n\t\t\tcount++;\n\t\t}\n\t\tint memo=sum;\n\t\tsum=sum-mini2+mini2*(count-1);\n\t\tmemo=memo+mini2+mini*2+mini*(count-1);\n\t\tans+=min(sum,memo);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MOD = 1e9+7,MAX = 1e5;\n\nint n;\nint b[1000],a[1000];\nint Par[10001],Rank[10001];\nbool sorted[1000];\n\nvoid init(int n)\n{\n\tfor(int i =0;i<n;i++)\n\t{\n\t\tPar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\nint find(int x)\n{\n\tif(Par[x]==x)return x;\n\treturn Par[x] = find(Par[x]);\n}\n\nvoid unite(int x,int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif(x==y)return;\n\tif(Rank[x]>Rank[y])\n\t{\n\t\tPar[y] = x; \n\t}\n\telse\n\t{\n\t\tPar[x] = y;\n\t\tif(Rank[x]==Rank[y])Rank[y]++;\n\t}\n}\n\n\n\nvoid marge_sort(int l,int r)\n{\n\tif(r-l==1)return;\n\n\tint mid = (l+r)/2;\n\t//cout<<mid<<endl;\n\tmarge_sort(l,mid);\n\tmarge_sort(mid,r);\n\tvector<int> v;\n\tvector<char> v2;\n\tint i = l,j=mid;\n\twhile(i!=mid&&j!=r)\n\t{\n\t\tif(b[i]<=b[j])\n\t\t{\n\t\t\tv.push_back(b[i]);\n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv.push_back(b[j]);\n\t\t\tj++;\n\t\t}\n\t}\n\tfor(;i<mid;i++){v.push_back(b[i]);}\n\tfor(;j<r;++j){v.push_back(b[j]);}\n\tfor(int k = l;k<r;k++)\n\t{\n\t\tb[k]=v[k-l];\n\t}\n}\n\n\nint main()\n{\n\tcin >> n;\n\tfor(int i = 0;i<n;i++)\n\t{\n\t\tcin >> a[i];\n\t}\n\tint minimam = 1000000;\n\tfor(int i = 0;i<n;i++)\n\t{\n\t\tb[i] = a[i];\n\t\tminimam = min(minimam,a[i]);\n\t}\n\tinit(10001);\n\t//for(int i = 0;i<n;i++)cout<<b[i]<<';'<<find(b[i])<<endl;\n\tmarge_sort(0,n);\n\tfor(int i = 0;i<n;++i)\n\t{\n\t\tif(a[i]==b[i])continue;\n\t\tunite(a[i],b[i]);\n\t}\n\t\n\tint ans  = 0;\n\tfor(int i =0;i<n;i++)\n\t{\n\t\tif(sorted[i])continue;\n\t\tint grope = find(a[i]);\n\t\tvector<int> now;\n\t\tnow.push_back(a[i]);\n\t\tsorted[i]=true;\n\t\tfor(int j =0;j<n;j++)\n\t\t{\n\t\t\tif(grope==find(a[j])&&a[i]!=a[j])\n\t\t\t{\n\t\t\t\tnow.push_back(a[j]);\n\t\t\t\tsorted[j] = true;\n\t\t\t}\n\t\t}\n\t\tif(now.size()==1)continue;\n\t\tint mi = MAX,sum = 0;\n\t\t//for(auto i = now.begin();i!=now.end();i++)cout<<*i<<endl;cout<<endl;\n\t\tfor(int j = 0;j<now.size();j++)\n\t\t{\n\t\t\tsum+= now[j];\n\t\t\tmi = min(mi,now[j]);\n\t\t}\n\t\tans += min(sum+(now.size()-2)*mi,sum+mi+(now.size()+1)*minimam);\n\t}\n\tcout<<ans<<endl;\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm> // next_permutation\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <list>\n#include <numeric> //accumulate\n//#include <unordered_map> //???????????\\??¢??°\n#include <fstream> //ifstream, ofstream\n\n#define NDEBUG //NDEBUG???#include <cassert>???????????????????????????????????´???assert?????????????????????????????????NDEBUG????????????????????¨\n#include <cassert> //assert\n\n\nusing namespace std;\n\n//???????????°??????TEST????????????????????¬???????????????????????????????????¢????????????\n#define TEST //*******************************************************************************************************************************************\n//?????????????????¨??§?????\\????????????????????????????????°?????????????¨???????????????????dout???????????????????????§???????????¬??????????????????????????????????????????\n//??????????????????????????????????????????????????????????§?CPU???????£??????????????????§???TLE?????????????????????????????????????????§????????¨???                           ????????????????????????cerr????????£????????????????????????????????????\n#ifdef TEST\n#define dout cout\n#else\nstringstream dummy; //???????????°??????dout?????????????????????????????????\n#define dout dummy.str(\"\"); dummy.clear(stringstream::goodbit); dummy //dummy?????????????????????????????????????????¨?????¢?????¢???????????????\n//???????????¨??????????????????goodbit?????????????????????????????¨???????????´????????????????????????????????¨?????°?????????????????§???????????????????????????????????? http://d.hatena.ne.jp/linden/20060427/p1\n#endif\n\n//?¨??????????????????????????????????????????????????????´??????OUTPUT2TEXTFILE????????????????????¬???????????????????????????????????¢????????????\n//#define OUTPUT2TEXTFILE //*******************************************************************************************************************************************\n#ifdef OUTPUT2TEXTFILE\n#define dout outputfile //??¨????????????TLE????????§?????????dout?????¨??¨??????????????¢????????????????????????????????????????????§????¨????????????´??????????????£??????????????????????¨?????????????????????????????????????????????§?????????????????????\n//TEST??????????????????????????¨???outputfile??????????????????????????????\n#define OUTPUTFILENAME \"output.txt\"\nofstream outputfile(OUTPUTFILENAME);\n#define OutputFilePath \"/Users/Nag/Documents/Prgm/Test/DerivedData/Test/Build/Products/Debug/output.txt\"\n#endif\n\n#define disp(A) dout << #A << \" = \" << (A) << endl\n#define disP(A) dout << setw(3) << (A) << \" \" // << setw(3) ??????????????\\????????????\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n\n#define dispAll(A,n) dout << #A << \" = \"; rep(j, 0, (n)) {disP(A[j]);} dout << endl\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef unsigned long long ll;\n\nconst int INF = 1e9-1;\n\nvi a, b;\nvector<char> c;\n\n\n\n\n\n\n\nint main(){\n    int N; cin >> N;\n    \n    int aa;\n    rep(i,0,N) { cin >> aa; a.push_back(aa); }\n   \n    b = a;\n    sort(b.begin(), b.end());\n    \n    rep(i,0,N) { c.push_back( a[i] == b[i] ? 'o' : 'x' ); }\n    \n    \n    \n    \n    ll cost = 0;\n    int i, x, y, key;\n    \n    for(i=0; i<N; i++ ) {\n        if(a[i]==b[i]) continue; //a[i]!=b[i]??¨???????????????i????????????????????§i++\n\n        //???????????????????°???????a[x]???????§???????\n        key = b[i];\n        x = find(a.begin(), a.end(), key) - a.begin();\n\n        do { //a[x]==b[x]??¨???????????§?????????????????°??????????????????\n            key = b[x];\n            y = find(a.begin(), a.end(), key) - a.begin();\n            \n            \n//            //test display\n//            dout << \"---------------------\\n\";\n//            disp(i); disp(x); disp(y);\n//            dout << \"---\\n    \";\n//            rep(i,0,N) disP(i); dout << \"\\n   \";\n//            rep(i,0,N) dout << \"   -\"; dout << endl;\n//            dispAll(a, N);\n//            rep(i,0,N) { c[i] = (a[i] == b[i] ? 'o' : 'x' ); }\n//            dispAll(c, N);\n//            dispAll(b, N);\n//            disp(cost);\n            \n            \n            //swap a[x] & a[y]\n            int tmp = a[x];\n            a[x] = a[y];\n            a[y] = tmp;\n            \n            cost += a[x] + a[y];\n            \n            x = y;\n        } while ( a[x] != b[x] );\n        \n    }\n    \n    \n//    dout << \"=====================\\n\";\n//    \n//    //test display\n//    dout << \"---------------------\\n\";\n//    disp(i); disp(x); disp(y);\n//    dout << \"---\\n    \";\n//    rep(i,0,N) disP(i); dout << \"\\n   \";\n//    rep(i,0,N) dout << \"   -\"; dout << endl;\n//    dispAll(a, N);\n//    rep(i,0,N) { c[i] = (a[i] == b[i] ? 'o' : 'x' ); }\n//    dispAll(c, N);\n//    dispAll(b, N);\n//    disp(cost);\n    \n    cout << cost << endl;\n    \n    \n    \n    \n#ifdef OUTPUT2TEXTFILE\n    outputfile.close();\n    cout << \"\\\"\" << OutputFilePath << \"\\\"\" << endl;\n#endif\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint main(){\n    int n, w[1000], a[1000];\n    cin >> n;\n    for(int i=0;i<n;i++){\n        cin >> w[i];\n        a[i]=w[i];\n    }\n    sort(a, a+n);\n    unordered_map<int, deque<int>> idx;\n    for(int i=0;i<n;i++) if(w[i]!=a[i]) idx[w[i]].push_back(i);\n\n    ll cost = 0;\n    for(int i=0;i<n;i++){\n        if(a[i]==w[i]) continue;\n        int j=idx[a[i]].front();\n        int s=w[j];\n        while(true){\n            int k=idx[a[j]].back();\n            idx[a[j]].pop_back();\n            cost += w[j]+w[k];\n            w[j]=w[k];\n            w[k]=s;\n            j=k;\n            if(w[k]==a[k]) break;\n        }\n    }\n    std::cout << cost << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int INF = 1000000;\n\nint partition(int *A,int p,int r)\n{\n\tint j,x,temp;\n\n\tx = A[r];\n\tj = p-1;\n\n\tfor(int i = p; i < r; i++)\n\t{\n\t\tif (A[i] <= x)\n\t\t{\n\t\t\tj++;\n\t\t\ttemp = A[i];\n\t\t\tA[i] = A[j];\n\t\t\tA[j] = temp;\n\t\t}\n\t}\n\n\ttemp = A[j+1];\n\tA[j+1] = A[r];\n\tA[r] = temp;\n\n\treturn j+1;\n}\n\nvoid quicksort(int *A,int p,int r)\n{\n\tint q;\n\n\tif (p < r)\n\t{\n\t\tq = partition(A,p,r);\n\t\tquicksort(A,p,q-1);\n\t\tquicksort(A,q+1,r);\n\t}\n}\n\nint solve_swap(int *a,int *b,int n)\n{\n\tint sum,temp;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (a[i] != b[i])\n\t\t{\n\t\t\tfor(int j = i+1; j < n; j++)\n\t\t\t{\n\t\t\t\tif (b[j] == a[i] && b[i] == a[j])\n\t\t\t\t{\n\t\t\t\t\ttemp = a[i];\n\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\ta[j] = temp;\n\n\t\t\t\t\tsum += a[i] + a[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n\nint solve1(int *a,int *b,int n)\n{\n\tbool check;\n\tint min,num,temp,sum,start;\n\n\tsum = 0;\n\tstart = 0;\n\n\twhile(1)\n\t{\n\t\tmin = INF;\n\t\t\n\t\tcheck = true;\n\n\t\t//printf(\"start = %d\\n\", start);\n\n\t\tfor(int i = start; i < n; i++)\n\t\t{\n\t\t\tif (min > a[i] && a[i] != b[i])\n\t\t\t{\n\t\t\t\tnum = i;\n\t\t\t\tmin = a[num];\n\t\t\t}\n\t\t}\n\n\t\t//printf(\"num = %d\\n\", num);\n\t\t//printf(\"min = %d\\n\", min);\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (a[i] == b[num])\n\t\t\t{\n\t\t\t\t//printf(\"%d and %d are swapped\\n\", a[num],a[i]);\n\t\t\t\tsum += a[num] + a[i];\n\t\t\t\ttemp = a[i];\n\t\t\t\ta[i] = min; // min = a[num]\n\t\t\t\ta[num] = temp;\n\t\t\t\tnum = i;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (a[i] != b[i])\n\t\t\t{\n\t\t\t\tcheck = false;\n\t\t\t\tstart = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t\n\n\t\tif (check)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn sum;\n}\n\nbool check(int *A,int *B,int n)\n{\n\tbool c = true;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (A[i] != B[i])\n\t\t{\n\t\t\tc = false;\n\t\t}\n\t}\n\n\treturn c;\n}\n\nint main()\n{\n\tint n,a[1000] = {0},b[1000] = {0};//,a2[1000] = {0};\n\tint sum1 = 0;\n\t//int sum2 = 0,pivot = 0,pivot1 = 0,pivot2= 0,min = 0,start=0,temp=0,k=0;\n\n\tscanf(\"%d\", &n);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\tb[i] = a[i];\n\t}\n\n\tquicksort(b,0,n-1);\n\n\tsum1 = solve_swap(a,b,n);\n\n\t//printf(\"sum = %d\\n\", sum1);\n\n\tif (check(a,b,n))\n\t{\n\t\tcout << sum1 <<endl;\n\t\treturn 0;\n\t}\n\n/*\n\tsum2 = sum1;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\ta2[i] = a[i];\n\t}\n\n\t//printf(\"\\nhere is sum1\\n\");\n\n\tsum1 += solve1(a,b,n);\n\n\t//printf(\"sum1 = %d\\n\",sum1);\n\n\n\tif (check(a,b,n))\n\t{\n\t\tprintf(\"%d\\n\", sum1);\n\t\treturn 0;\n\t}\n\n\n\n\tfor(int i = 1; i < n - start; i++)\n\t{\n\t\tk = start;\n\n\t\t\n\t\twhile(1)\n\t\t{\n\t\t\tif (b[pivot1] == a[k])\n\t\t\t{\n\t\t\t\tprintf(\"%d and %d are swapped\\n\", a[pivot1],a[k]);\n\t\t\t\ttemp = a[pivot1];\n\t\t\t\ta[pivot1] = a[k];\n\t\t\t\ta[k] = temp;\n\n\t\t\t\tsum1 += a[pivot1] + a[k];\n\t\t\t\tpivot1 = k;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tprintf(\"%d \", a[i]);\n\t\t}\n\t\tcout << endl;\n\t}\n\n\n\tif (!check(a,b,n))\n\t{\n\t\tprintf(\"\\nhere is sum2\\n\");\n\t\ttemp = a2[pivot2];\n\t\ta2[pivot2] = a2[0];\n\t\ta2[0] = temp;\n\n\t\tfor(int i = 1; i < n - start; i++)\n\t\t{\n\t\t\tint j = start;\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif (b[pivot2] == a2[j])\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d and %d are swapped\\n\", a2[pivot2],a2[j]);\n\t\t\t\t\ttemp = a2[pivot2];\n\t\t\t\t\ta2[pivot2] = a2[j];\n\t\t\t\t\ta2[j] = temp;\n\n\t\t\t\t\tsum2 += a2[pivot2] + a2[j];\n\t\t\t\t\tpivot2 = j;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tprintf(\"%d \", a2[i]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\n\t\tif (sum1 < sum2)\n\t\t{\n\t\t\tprintf(\"sum1 = %d\\n\", sum1);\n\t\t}else\n\t\t{\n\t\t\tprintf(\"sum2 = %d\\n\", sum2);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\n\tprintf(\"%d\\n\", sum1);\n*/\n\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint MIN=10010,n;\nint a[1010],b[1010],t[10010];\nbool V[1010];\nint solve(){\n\tint ans=0;\n\tsort(b,b+n);\n\tfor(int i=0;i<n;++i) t[b[i]]=i;\n\tfor(int i=0;i<n;++i){\n\t\tif(V[i]) continue;\n\t\tint cur=i;\n\t\tint S=0;\n\t\tint m=10010;\n\t\tint an=0;\n\t\twhile(1){\n\t\t\tV[cur]=1;\n\t\t\t++an;\n\t\t\tint v=a[cur];\n\t\t\tm=min(m,v);\n\t\t\tS+=v;\n\t\t\tcur=t[v];\n\t\t\tif(V[cur]) break;\n\t\t}\n\t\tans+=min(S+(an-2)*m,m+S+(an+1)*MIN);\n\t}\n\treturn ans;\n}\nint main(){\n\tcin>>n;\n\tfor(int i=0;i<n;++i){\n\t\tcin>>a[i];\n\t\tb[i]=a[i];\n\t\tV[i]=0;\n\t\tMIN=min(MIN,a[i]);\n\t}\n\tcout<<solve()<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 最小コストどーと\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<vector>\n\nusing namespace std;\n\n#define MAX_N 1000\n//const int INFTY = 2147483647;\n\nint minCostSort(int A[], int n);\n\nint main(void)\n{\n    int n;\n    int baggage[MAX_N];\n\n    cin >> n;\n\n    for(int i = 0; i < n; i++)\n    {\n        cin >> baggage[i];\n    }\n\n    int cost;\n    cost = minCostSort(&baggage[0], n);\n\n    cout << cost << endl;\n\n    return 0;\n}\n\n// 選択ソートを実施する関数\nint minCostSort(int A[], int n)\n{\n\n    int cost = 0;\n    int count = 0;\n    // 最小値の存在する配列の要素No.\n    int min_pos;\n\n    for(int i = 0; i < n - 1; i++)\n    {\n        min_pos = i;\n\n        for(int j = i; j < n; j++)\n        {\n            if( A[j] < A[min_pos] )\n            {\n                // 最小値の存在する位置を保存する\n                min_pos = j;\n            }\n        }\n\n        if( i != min_pos )\n        {\n            // 最小値を交換する\n            swap(A[i], A[min_pos]);\n\n            count++;\n\n            cost += A[i] + A[min_pos];\n        }\n    }\n\n    return cost;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef struct D{\n\tint c;\n\tvector<P>W;\n\tbool operator <(const D &a)const{return c<a.c;}\n}D;\nint N,W[1005],C[1005],c=0,t,p,res=1000000000;\nmap<int,int>H;\nmap<int,int>rH;\nmap<vector<P>,int>MC;\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++)\n\t\tscanf(\"%d\",C+i);\n\tmemcpy(W,C,sizeof(C));\n\tsort(C,C+N);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tH[C[i]]=i;\n\t\trH[i]=C[i];\n\t}\n\tD tmp={0};\n\tfor(int i=0;i<N;i++)\n\t\ttmp.W.push_back(make_pair(W[i],H[W[i]]));\n\tMC[tmp.W]=0;\n\tpriority_queue<D>Q;\n\tQ.push(tmp);\n\tfor(;!Q.empty();)\n\t{\n\t\ttmp=Q.top();Q.pop();\n\t\tif(MC[tmp.W]!=0&&MC[tmp.W]<tmp.c)continue;\n\t\tint f=1;\n\t\tfor(int i=0;i<tmp.W.size();i++)\n\t\t{\n\t\t\tif(tmp.W[i].second!=i)\n\t\t\t{\n\t\t\t\tf=0;\n\t\t\t\tD ins=tmp;\n\t\t\t\tins.c+=tmp.W[i].first+tmp.W[tmp.W[i].second].first;\n\t\t\t\tswap(ins.W[i],ins.W[ins.W[i].second]);\n\t\t\t\tif(MC[ins.W]==0||MC[ins.W]>ins.c)\n\t\t\t\t{\n\t\t\t\t\tMC[ins.W]=ins.c;\n\t\t\t\t\tQ.push(ins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(f)\n\t\t\tres=min(res,tmp.c);\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nint solve( int w[], int n, int wmin , int wmax ){\n\n    int i, buffer, ans = 0;\n\n    int V[n];\n\n    int A[n], T[ wmax + 1 ];\n\n    for( i = 0 ; i < n ; i++ ){\n\n        V[i] = 0;\n\n        A[i] = w[i];\n\n    }\n\n    sort( A, A + n );\n\n    for( i = 0 ; i < n ; i++ ){\n\n        T[ A[i] ] = i;\n\n    }\n\n    int an, wsum, m, cursor;\n\n    for( i = 0 ; i < n ; i++ ){\n\n        if( V[i] ) continue;\n\n        cursor = i;\n\n        an = 0;\n        wsum = 0;\n        m = 1000000;\n\n        \n\n        while(1){\n\n            V[ cursor ] = 1;\n\n            an++;\n\n            buffer = w[cursor];\n\n            m = min( m , buffer );\n\n            wsum += buffer;\n\n            cursor = T[ buffer ];\n\n\n\n            if( V[cursor] ) break;\n\n        }\n\n        ans += min( ( wsum + (an - 2 ) * m ) , ( wsum + m + ( an + 1 ) * wmin ) );\n\n\n    }\n\n    return ans;\n\n}\n\n\n\nint main(){\n\n    int n , i;\n\n    scanf(\"%d\", &n);\n\n    int w[n], wmax = 0, wmin = 1000000;\n\n    for( i = 0 ; i < n ; i++ ){\n        \n        scanf(\"%d\", &w[i]);\n\n        wmax = max( wmax, w[i] );\n\n        wmin = min( wmin, w[i] );\n\n    }\n\n\n    int answer;\n\n    answer = solve( w, n , wmin, wmax);\n\n    printf(\"%d\\n\", answer);\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\nusing namespace std;\n\nint do_cycle(vector<int> &v,int x){\n\tint s=0,m=1<<30;\n\tfor(auto &e:v)s+=e,m=min(m,e);\n\treturn min(s+(v.size()-2)*m,s+m+(v.size()+1)*x);\n}\n\nint main(){\n\tint N,x=1<<30,r;\n\tscanf(\"%d\",&N);\n\tvector<int>v(N+1),b(N+1);\n\tvector<vector<int> >cycles;\n\tfor(int i=1;i<=N;i++)scanf(\"%d\",&v[i]),x=min(x,v[i]);\n\tfor(int i=1;i<=N;i++)if(!b[i]){\n\t\tvector<int>cycle;\n\t\tint k=i;\n\t\tdo{\n\t\t\tcycle.push_back(k);\n\t\t\tb[k]=1;\n\t\t\tk=v[k];\n\t\t}while(k!=cycle[0]);\n\t\tr+=do_cycle(cycle,x);\n\t}\n\tprintf(\"%d\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint solve() {\n  int ans = 0;\n\n  bool V[MAX];\n  for ( int i = 0; i < n; i++ ) {\n    B[i] = A[i];\n    V[i] = false;\n  }\n  sort(B, B+n);\n  for ( int i = 0; i < n; i++ ) T[B[i]] = i;\n  for ( int i = 0; i < n; i++ ) {\n    if ( V[i] ) continue;\n    int cur = i;\n    int S = 0;\n    int m = VMAX;\n    int an = 0;\n    while ( 1 ) {\n      V[cur] = true;\n      an++;\n      int v = A[cur];\n      m = min(m, v);\n      S += v;\n      cur = T[v];\n      if ( V[cur] ) break;\n    }\n    ans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n  }\n\n  return ans;\n}\n\nint main() {\n  cin >> n;\n  s = VMAX;\n  for ( int i = 0; i < n; i++ ) {\n    cin >> A[i];\n    s = min(s, A[i]);\n  }\n  int ans = solve();\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(void){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n; cin >> n;\n  vector<int> w(n), v(n);\n  int map[1000];\n  memset(map, -1, sizeof(map));\n  for(int i = 0; i < n; i++) cin >> w[i];\n  for(int i = 0; i < n; i++) map[w[i]] = i;\n\n  v = w;\n  sort(v.begin(), v.end());\n\n  int ans = 0;\n  for(int i = 0; i < n; i++){\n    /*\n    for(int j = 0; j < n; j++) cout << v[j] << \" \";\n    cout << endl;\n    */\n    if(v[i] == w[i]){\n      continue;\n    }else{\n      ans += v[i] + w[i];\n      swap(v[i], v[ map[v[i]] ]);\n      cout << i << \" \" << map[v[i]] << endl;\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdint.h>\n#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <climits>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define DEBUG (0)\n\n#if DEBUG\n#define DPRINTF(...) do { \\\n    printf(\"D(L%d) %s: \", __LINE__, __func__); \\\n    printf(__VA_ARGS__); \\\n  } while (false)\n#else\n#define DPRINTF(...)\n#endif // DEBUG\n\nint g_cost = 0;\n\nvoid swap(int array[], int i0, int i1)\n{\n  int temp = array[i1];\n  array[i1] = array[i0];\n  array[i0] = temp;\n}\n\n\nint findIndexOf(int val, const int array[], int numOfArray)\n{\n  for (int i = 0; i < numOfArray; i++)\n    if (array[i] == val)\n      return i;\n\n  // if cannot find the val, call assertion error.\n  assert(0);\n\n  return -1;\n}\n\n\n// The formula is : Sigma(Wi) + min(Wi) * (N-2)\nint calcCostSimple(const int array[], const vector<int> &l)\n{\n  int s = 0;\n  int minimum = INT_MAX;\n  for (uint32_t i = 0; i < l.size(); i++)\n  {\n    int idx = l[i];\n    s += array[idx];\n    minimum = min(minimum, array[idx]);\n  }\n\n  DPRINTF(\"s %d  minimum %d\\n\", s, minimum);\n\n  return s + minimum * (l.size() - 2);\n}\n\n\n// The formula is : Signma(Wi) + min(Wi) + x * (N+1)\nint calcCostSwap(const int array[], const vector<int> &l, int x)\n{\n  if (array == nullptr || l.size() < 1 || x < 0)\n  {\n    assert(1);\n    return INT_MAX;\n  }\n\n  int s = 0;\n  int minimum = INT_MAX;\n  for (uint32_t i = 0; i < l.size(); i++)\n  {\n    int idx = l[i];\n    s += array[idx];\n    minimum = min(minimum, array[idx]);\n  }\n\n  DPRINTF(\"s %d  minimum %d  x %d\\n\", s, minimum, x);\n\n  return s + minimum + x * (l.size() - 1);\n}\n\n\nint findMinOutsideLoop(vector<int> indices, int max, const int sortedArray[])\n{\n  sort(indices.begin(), indices.end());\n\n  for (int i = 0; i < max; i++)\n    if (indices[i] != i)\n      return sortedArray[i];\n\n  // the case l and sortedArray are the same\n  return INT_MAX;\n}\n\n\nint main()\n{\n  int numOfArray;\n  cin >> numOfArray; cin.ignore();\n\n  int array[numOfArray];\n  for (int i = 0; i < numOfArray; i++)\n    cin >> array[i];\n\n#if DEBUG\n  for (int i = 0; i < numOfArray; i++)\n    if (i == 0) DPRINTF(\"%2d\", array[i]);\n    else        printf(\" %2d\", array[i]);\n  cout << endl;\n#endif // DEBUG\n\n  int sortedArray[numOfArray];\n  for (int i = 0; i < numOfArray; i++)\n    sortedArray[i] = array[i];\n\n  sort(sortedArray, sortedArray + numOfArray);\n\n#if DEBUG\n  for (int i = 0; i < numOfArray; i++)\n    if (i == 0) DPRINTF(\"%2d\", sortedArray[i]);\n    else        printf(\" %2d\", sortedArray[i]);\n  cout << endl;\n#endif // DEBUG\n\n  // First, find a loop where each element is sorted\n  //   Suppose array of { 2 1 8 10 7 9 }\n  //   then, sorted array should be { 1 2 7 8 9 10 }\n  //   In this case, we could find two loops;\n  //     Loop 1 : { 2 1 } - { 1 2 }\n  //     Loop 2 : { 8 10 7 9 } - { 7 8 9 10 }\n\n  bool visited[numOfArray];\n  fill(visited, visited + numOfArray, 0);\n\n  vector<vector<int>> loops;\n\n  for (int i = 0; i < numOfArray; i++)\n  {\n    if (visited[i])\n      continue;\n\n    int idx = i;\n    vector<int> loop;\n\n    while (!visited[idx])\n    {\n      loop.push_back(idx);\n      visited[idx] = true;\n\n      int num = array[idx];\n      idx = findIndexOf(num, sortedArray, numOfArray);\n    }\n\n    loops.push_back(loop);\n  }\n\n  // Let's calculate a cost when we will need to sort out\n  // Note that we have to check two cases in a way of sorting, and compare of which is light\n  // Take a look at loop 2 case;\n  //   { 8 10 7 9 } will sorted, and it becomes { 7 8 9 10 }\n  //   The cost should be 48;\n  //   The general formula will be : Sigma(Wi) + min(Wi) * (N-2)\n  //\n  //   Be careful that we could swap with a number of another loop;\n  //   Let's say swap 1 of loop 1 with 7 of loop 2\n  //   and sort { 8 10 1 9 }, and it will be { 1 8 9 10 }\n  //   then swap again, 1 and 7, finally the array will be sorted properly as { 7 8 9 10 }\n  //   In this case, the cost should be 45\n  //   The general formula should be : Signma(Wi) + min(Wi) + x * (N+1)\n\n  for (uint32_t i = 0; i < loops.size(); i++)\n  {\n\n    const vector<int> l = loops[i];\n\n#if DEBUG\n    DPRINTF(\"Loop %d : \",i);\n    for (uint32_t j = 0; j < l.size(); j++) {\n      printf(\" %d\", array[l[j]]);\n    }\n    cout << endl;\n#endif\n\n    if (l.size() < 2)\n      continue; // means the number will be alredy sorted, no need to consider\n\n    int costA, costB;\n    costA = calcCostSimple(array, l);\n    int x = findMinOutsideLoop(l, numOfArray, sortedArray);\n    if (x == INT_MAX)\n      costB = INT_MAX;\n    else\n      costB = calcCostSwap(array, l, x);\n\n    g_cost += min(costA, costB);\n\n    DPRINTF(\"Loop %d : Simple %d  Swap %d  g_cost %d\\n\", i, costA, costB, g_cost);\n  }\n\n  cout << g_cost << endl;\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint solve() {\n    int ans = 0;\n    \n    bool V[MAX];\n    for (int i=0; i<n; i++) {\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B, B+n);\n    for (int i=0; i<n; i++) T[B[i]] = i;\n    for (int i=0; i<n; i++) {\n        if (V[i]) continue;\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while(1) {\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m, v);\n            S += v;\n            cur = T[v];\n            if (V[cur]) break;\n        }\n        ans += min(S + (an-2) * m, m + S + (an+1) * s);\n    }\n    \n    return ans;\n}\n\nint main() {\n    cin >> n;\n    s = VMAX;\n    for (int i=0; i<n; i++) {\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n    \n    int ans = solve();\n    cout << ans << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define MAX_SIZE 1001\n#define MAX_VALUE 10001\n\nint solve(int* A, int n) {\n    int B[MAX_SIZE];\n    int T[MAX_VALUE];\n    bool Check[MAX_SIZE];\n    int s = MAX_VALUE;\n    int ans = 0;\n    \n    // Tに各値の正しい位置の添え字を保存\n    for(int i = 0; i < n; ++i) {\n        B[i] = A[i];\n        s = min(s, A[i]);\n    }\n    sort(B, B + n);\n    for(int i = 0; i < n; ++i) {\n        T[B[i]] = i;\n    }\n    \n    for(int i = 0; i < n; ++i) {\n        Check[i] = false;\n    }\n    \n    for(int i = 0; i < n; ++i) {\n        int an = 0;   // サイクルサイズ\n        int S = 0;   // サイクル内の要素の合計値\n        int m = MAX_VALUE;\n        int cur = i;\n        if(Check[cur]) {\n            continue;\n        }\n        while(!Check[cur]) {\n            Check[cur] = true;\n            ++an;\n            S += A[cur];\n            m = min(m, A[cur]);\n            cur = T[A[cur]];\n        }\n        ans += min((S + (an - 2) * m), (S + m + (an + 1) * s)); \n    }\n    \n    return ans;\n}\n\nint main(void) {\n    int n;\n    int A[MAX_VALUE];\n    \n    cin >> n;\n    for(int i = 0; i < n; ++i) {\n        cin >> A[i];\n    }\n    \n    cout << solve(A, n) << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nint main() {\n\tint n,w,l;\n\tvector<pair< int, pair<int,int> > > a; \n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>w;\n\t\ta.push_back(make_pair(w,make_pair(i,0)));\n\t}\n\tsort(a.begin(), a.end());\n\tfor(int i=0;i<n;i++){\n\t\t(a[i].second).second=i;\n\t\tl=a[i].first;\n\t\ta[i].first=(a[i].second).first;\n\t\t(a[i].second).first=l;\n//\tcout<<\"a[i]\"<<a[i].first<<\" \"<<(a[i].second).first<<endl;\n\t}\n\tsort(a.begin(),a.end());\n//for(int i=0;i<n;i++) cout<<\"a[i]\"<<a[i].first<<\" \"<<(a[i].second).first<<\" \"<<(a[i].second).second<<endl;\n\tint mi=a[0].first;\n\tbool b[1010]={0};\n\tint ans=0;\n\tfor(int i=0;i<n;i++){\n\t\tif (b[i]!=0) continue;\n\t//\tcout<<i<<\" \"<<b[i]<<endl;\n\t\tb[i]=1;\n\t\tint j=i,k=1,sum=(a[i].second).first,mini=(a[i].second).first;\n\t\twhile(1){\n\t\t\tif(i==(a[j].second).second) break;\n\t\t\tj=(a[j].second).second;\n\t\t\tb[j]=1;\n\t\t\tsum=sum+(a[j].second).first;\n\t\t\tk++;\n\t\t\tif(mini>(a[j].second).first) mini=(a[j].second).first;\n\t\t}\n//\t\tcout<<k<<endl;\n\t\tif(k>1) ans=ans+min(sum+(k-2)*mini,sum+(k+1)*mi+mini); \n\t\t\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n\nusing namespace std;\n\nstatic const int MAX = 1000;\nstatic const int MAXS = 10005;\n\nint s = MAXS;\nint C[MAXS] = {0};\nint minCostSort(int A[], int n)\n{\n\tint cost = 0;\n\tint i,B[MAX];\n\tbool V[MAX];\n\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tV[i] = false;\n\t\tB[i] = A[i];\n\t}\n\tsort(&B[0],&B[n]);\n\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tC[B[i]] = i;\n\t}\n\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tint a = i;\n\t\tint S = 0;\n\t\tint mini = MAXS;\n\t\tint num = 0;\n\t\twhile (1)\n\t\t{\n\t\t\tV[a] = true;\n\t\t\tnum++;\n\t\t\tmini = min(mini, A[a]);\n\t\t\tS = S + A[a];\n\t\t\ta = C[A[a]];\n\t\t\tif (V[a]==true)\n\t\t\t\tbreak;\t\t\t\t\n\t\t}\n\n\t\tcost += min(S+mini*(num-2),S+mini+(num+1)*s);\n\t}\n\n\treturn cost;\n}\n\nint main()\n{\n\tint cost;\n\tint n,i, A[MAX];\n\tscanf(\"%d\",&n);\n\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &A[i]);\n\t\ts = min(A[i],s);\n\t}\n\n\tcost = minCostSort(A,n);\n\tprintf(\"%d\\n\", cost);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct QuickFind{\n  vector<int> r,p;\n  vector<vector<int> > v;\n  QuickFind(){}\n  QuickFind(int size){init(size);}\n  void init(int size){\n    r.resize(size,0);\n    p.resize(size,0);\n    v.resize(size);\n    for(int i=0;i<size;i++){\n      r[i]=1,p[i]=i;\n      v[i].resize(1,i);\n    }\n  }\n  bool same(int x,int y){\n    return p[x]==p[y];\n  }\n  void unite(int x,int y){\n    x=p[x];y=p[y];\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    for(int i=0;i<(int)v[y].size();i++){\n      p[v[y][i]]=x;\n      v[x].push_back(v[y][i]);\n    }\n    v[y].clear();\n  }\n};\nsigned main(){\n  int n;\n  cin>>n;\n  vector<int>a(n);\n  for(int i=0;i<n;i++) cin>>a[i];\n  vector<int>b(a);\n  sort(b.begin(),b.end());\n  map<int,int>p,q;\n  for(int i=0;i<n;i++){\n    p[a[i]]=i;\n    q[b[i]]=i;\n  }\n  QuickFind qf(n);\n  for(int i=0;i<n;i++)\n    qf.unite(i,p[b[i]]);\n  int ans=0;\n  for(int i=0;i<n;i++){\n    int k=qf.v[i].size();\n    if(qf.p[i]!=i||k==1) continue;\n    int m=a[qf.v[i][0]];\n    int tmp=0;\n    for(int j=0;j<k;j++){\n      tmp+=a[qf.v[i][j]];\n      m=min(m,a[qf.v[i][j]]);\n    }\n    ans+=min(tmp+m*(k-2),tmp+m+b[0]*(k+1));\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve()\n{\n    int ans = 0;\n\n    bool V[MAX];\n    for (int i = 0; i < n; i++) {\n        B[i] = A[i];  // 配列Aを配列Bにコピーする\n        V[i] = false;  // 配列Vのすべての要素をfalseとする\n    }\n    sort(B, B+n);  // 配列Aをコピーした配列Bをソートする\n    for (int i = 0; i < n; i++) {\n        // 配列TではBの要素をはじめから記録する\n        // 添字はBの要素，値は何番目の要素か\n        T[B[i]] = i;  // 配列TでBのi番目の要素の部分をiとする\n    }\n    for (int i = 0; i < n; i++) {\n        if (V[i]) continue;  // Vの要素がfalseのときは下の処理を行う(サイクルに登場するとtrueになる)\n        int cur = i;  // curは現在iの添字\n        int S = 0;  // Sはコストの合計\n        int m = VMAX;\n        int an = 0;\n        while(1) {\n            // ここではサイクルを探す\n            V[cur] = true;  // 現在iの添字の要素のVをtrueとする\n            an++;  // anをインクリメント\n            int v = A[cur];  // vをAの現在の添字の要素\n            m = min(m, v);  // mをm(= VMAX)とv(= Aの現在の要素)の小さい方とする\n            S += v;  // Sにvを加算する\n            cur = T[v];  // curをTのv番目の要素とする\n            if (V[cur]) break;  // もしがすでに触れた部分ならばwhileから抜ける\n        }\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n    }\n\n    return ans;\n}\n\nint main()\n{\n    cin >> n;\n    s = VMAX;\n    for (int i = 0; i < n; i++) {\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n    int ans = solve();\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nconst char dir[4] = { 'u','l','d','r' };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        (wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nint n;\nint w[1010];\nvector<pair<int, int>> v;\nvector<int> G[1010];\nbool used[1010];\nint main() {\n\tcin >> n;\n\tint minl = INF<int>();\n\tREP(i, n) {\n\t\tcin >> w[i];\n\t\tminl = min(minl, w[i]);\n\t}\n\tREP(i, n) {\n\t\tv.emplace_back(w[i], i);\n\t}\n\tsort(ALL(v));\n\tREP(i, n) {\n\t\tG[v[i].second].emplace_back(i);\n\t}\n\tqueue<int> q;\n\tint sum = 0;\n\tint cnt = 0;\n\tLL ans = 0;\n\tint minll = INF<int>();\n\tREP(i, n) {\n\t\tif (!used[i])q.push(i);\n\t\twhile (!q.empty()) {\n\t\t\tint cur = q.front();\n\t\t\tq.pop();\n\t\t\tused[cur] = true;\n\t\t\tsum += v[cur].first;\n\t\t\tminll = min(minll, v[cur].first);\n\t\t\tcnt++;\n\t\t\tif (!used[G[cur][0]])q.push(G[cur][0]);\n\t\t\telse {\n\t\t\t\tans += min(sum + (cnt - 2)*minll, sum + minll + minl*(cnt + 1));\n\t\t\t\tsum = 0;\n\t\t\t\tcnt = 0;\n\t\t\t\tminll = INF<int>();\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <climits>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nclass Item {\n  public:\n    int init_pos;\n    int val;\n    bool is_visited;\n};\n\nbool is_smaller(const Item& a, const Item& b)\n{\n  return a.val < b.val;\n}\n\nint main()\n{\n  int n;\n  std::cin >> n;\n  std::vector<Item> item(n);\n  int whole_min = INT_MAX;\n  for (int i = 0; i < (int)item.size(); i++) {\n    int val;\n    std::cin >> val;\n    item.at(i).init_pos = i;\n    item.at(i).val = val;\n    whole_min = std::min(whole_min, val);\n  }\n  std::stable_sort(item.begin(), item.end(), is_smaller);\n  int total_cost = 0;\n  for (int i = 0; i < (int)item.size(); i++) {\n    if (item.at(i).is_visited) {\n      continue;\n    }\n    item.at(i).is_visited = true;\n    if (item.at(i).init_pos == i) { // swap operation is not needed\n      continue;\n    }\n    // traverse the loop\n    int loop_min = item.at(i).val;\n    int total = item.at(i).val;\n    int init = i;\n    int head = item.at(i).init_pos;\n    int cnt = 1;\n    while (head != init) {\n      item.at(head).is_visited = true;\n      total += item.at(head).val;\n      loop_min = std::min(loop_min, item.at(head).val);\n      head = item.at(head).init_pos;\n      cnt++;\n    }\n    total += std::min(loop_min * (cnt - 2), whole_min * cnt + whole_min + loop_min);\n    total_cost += total;\n  }\n  std::cout << total_cost << std::endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 10000\nint main(void){\n    int n, mmin, min, ans, sum;\n    ans = 0;\n    std::cin >> n;\n    std::vector<int> A(n), B(n);\n    for(int i = 0; i < n; i++){\n        std::cin >> A[i];\n    }\n\n    B = A;\n    std::sort(B.begin(), B.end());\n\n    std::vector<bool> flag(n, false);\n    std::vector<int> order(MAX + 1);\n\n    \n    for(int i = 0; i < n; i++){\n        order[B[i]] = i;\n    }\n    mmin = B[0];\n    for(int i = 0; i < n; i++){\n        if(B[i] == A[i]) continue;\n        int cur = i;\n        int a = 0;\n        sum = 0;\n\n        \n        if(flag[cur] == true){\n            continue;\n        }\n\n        min = 1001001001;\n        while(true){\n            a++;\n            flag[cur] = true;\n            int v = A[cur];\n            min = std::min(min, v);\n            sum += v;\n\n            \n            cur = order[v];\n            if(flag[cur] == true){\n                break;\n            }\n        }\n\n        \n        ans += std::min(sum + (a - 2) * min, sum + min + (a + 1) * mmin);\n        \n    }\n\n    std::cout << ans << std::endl;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<algorithm>\n#include<iostream>\n#include<map>\n#include<vector>\nint main(void) {\n\tstd::ios_base::sync_with_stdio(false);\n\tint n, input;\n\tstd::cin >> n;\n\tstd::map<int, int>w;\n\tstd::vector<int>vector(n);\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tstd::cin >> input;\n\t\tvector[i] = input-1;\n\t}\n\tstd::vector<int>vector_min= vector;\n\n\tstd::sort(vector_min.begin(), vector_min.end());\n\tfor (int i = 0; i < n; ++i) {\n\t\tw[vector[i]] = vector_min[i];\n\t}\n\tstd::map<int, int>w_1(w);\n\tint cnt = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint temp = 0;\n\t\twhile (vector_min[i] != w[vector_min[i]]) {\n\t\t\ttemp += vector_min[i] + w[vector_min[i]] + 2;\n\t\t\tstd::swap(w[vector_min[i]],w[w[vector_min[i]]] );\n\t\t}\n\t\tint temp_1 = static_cast<int>(1e5);\n\t\tif (i>0&&vector_min[i] != w_1[vector_min[i]]) {\n\t\t\ttemp_1 =  w_1[vector_min[i]]+ w_1[vector_min[0]] + 2;\n\t\t\tstd::swap(w_1[vector_min[0]], w_1[vector_min[i]]);\n\t\t\twhile (vector_min[0] !=w_1[vector_min[0]]) {\n\t\t\t\ttemp_1 += w_1[vector_min[i]]+ w_1[vector_min[0]] + 2;\n\t\t\t\tstd::swap(w_1[vector_min[0]], w_1[w_1[vector_min[0]]]); }\n\t\t}\n\t\tcnt += std::min(temp, temp_1);\n\t}\n\tstd::cout << cnt << std::endl;\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define INFTY 1000000001\n\nstruct card{\n\tint w;\n};\n\nvoid swap(card &a, card &b){\n\tcard x = a;\n\ta = b;\n\tb = x;\n\treturn;\n}\n\nint partition(vector<card> &A, int p, int r){\n\tint x = A[r].w;\n\tint i = p - 1;\n\tfor (int j = p; j < r; j++){\n\t\tif (A[j].w <= x){\n\t\t\ti++;\n\t\t\tswap(A[i], A[j]);\n\t\t}\n\t}\n\tswap(A[i + 1], A[r]);\n\treturn i + 1;\n}\n\nvoid quicksort(vector<card> &A, int p, int r){\n\tif (p < r){\n\t\tint q = partition(A, p, r);\n\t\tquicksort(A, p, q - 1);\n\t\tquicksort(A, q + 1, r);\n\t}\n\treturn;\n}\n\nint main(){\n\n\tint n;\n\tcin >> n;\n\tvector<card> A(n), A_old(n);\n\tfor (int j = 0; j < n; j++){\n\t\tcin >> A[j].w;\n\t\tA_old[j] = A[j];\n\t}\n\n\tquicksort(A, 0, n - 1);\n\n\tvector<int> pair(n, 0);\n\tint curpair = 0;\n\tint cur;\n\tint min = A[0].w;\n\tfor (int j = 0; j < n; j++){\n\t\tif (pair[j] == 0){\n\t\t\tcurpair++;\n\t\t\tcur = j;\n\t\t\twhile (true){\n\t\t\t\tfor (int k = 0; k < n; k++){\n\t\t\t\t\tif (A[k].w == A_old[cur].w){\n\t\t\t\t\t\tcur = k;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpair[cur] = curpair;\n\t\t\t\tif (cur == j) break;\n\t\t\t}\n\t\t}\n\t\tif (min > A[j].w) min = A[j].w;\n\t}\n\n\tbool isFirstCurpair;\n\tint firstcurpairw, curpairnum, curpairw;\n\tint cost = 0;\n\tfor (int j = 1; j < curpair + 1; j++){\n\t\tisFirstCurpair = true;\n\t\tfirstcurpairw = 0;\n\t\tcurpairnum = 0;\n\t\tcurpairw = 0;\n\t\tfor (int k = 0; k < n; k++){\n\t\t\tif (pair[k] == j){\n\t\t\t\tif (isFirstCurpair){\n\t\t\t\t\tfirstcurpairw = A[k].w;\n\t\t\t\t\tisFirstCurpair = false;\n\t\t\t\t}\n\t\t\t\tcurpairw += A[k].w;\n\t\t\t\tcurpairnum++;\n\t\t\t}\n\t\t}\n\t\tif (curpairnum >= 2){\n\t\t\tif (firstcurpairw + min * (curpairnum + 1) < (curpairnum - 2) * firstcurpairw){\n\t\t\t\tcost += curpairw + firstcurpairw + min * (curpairnum + 1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcost += curpairw + (curpairnum - 2) * firstcurpairw;\n\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << cost << endl;\n\t\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint N;\nint W[11111];\nint U[11111];\nint R[11111];\nint T[11111];\n\nvoid view(){\n  for(int i=0;i<N;i++) cout << U[i] << \" \";\n  cout << endl;\n}\n\nint main(){\n  cin >> N;  \n  for(int i=0;i<N;i++){\n    cin >> U[i];\n    W[i] = U[i];\n    T[U[i]] = i;\n  }\n  sort(W,W+N);\n  for(int i=0;i<N;i++){\n    R[W[i]]=i;\n  }\n  int res = 0;\n  for(int i=0;i<N;i++){\n    if( W[i] == U[i] ) continue;\n    int id = T[W[i]];\n    int nd = T[W[id]];\n    while( U[id] != U[nd] ){\n      swap(U[id],U[nd]);\n\n      //      cout << id << \" - \" << nd << endl;\n      //view();\n      \n      T[U[id]] = id;\n      T[U[nd]] = nd;\n      res += U[id] + U[nd];\n      id = nd;\n      nd = T[W[id]];\n    }\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve() {\n\tint ans = 0;\n\t\n\tbool V[VMAX];\n\tfor(int i = 0; i < n; i++) {\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B, B + n);\n\tfor(int i = 0; i < n; i++) T[B[i]] = i;\n\tfor(int i = 0; i < n; i++) {\n\t\tif( V[i] ) continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint an = 0;\n\t\tint m = VMAX;\n\t\twhile(1) {\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif( V[cur] ) break;\t\t\t\n\t\t}\n\t\tans += min(S + (an - 2) * m, S + m +(an + 1) * s);\n\t}\n\t\n\treturn ans;\n} \n\nint main() {\n\tcin >> n;\n\ts = VMAX;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tint ans = solve();\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "/**\n * @file main.cpp\n * @author Kentaro Sugimoto (tarotene@gmail.com)\n * @brief Output the cost (to stdout) for an unordered set with its size (from stdin) according to \"silly sort\".\n * For more detail, please refer https://www.ipsj.or.jp/07editj/promenade/4506.pdf (Japanese only).\n * @version 0.1\n * @date 2019-03-21\n * \n * @copyright Copyright (c) 2019\n * \n */\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n    // input elements from stdin\n    int n = 0;\n    cin >> n;\n    vector<int> elements(n, 0);\n    for (int i = 0; i < n; ++i)\n    {\n        cin >> elements[i];\n    }\n\n    // pre-sort\n    auto elements_sorted = elements;\n    sort(elements_sorted.begin(), elements_sorted.end());\n\n    // construct loop\n    map<int, int> loop;\n    for (int i = 0; i < n; ++i)\n    {\n        loop[elements_sorted[i]] = elements[i];\n    }\n\n    // construct subloops and their inverses\n    vector<map<int, int>> subloop(n), subloop_inv(n);\n\n    map<int, bool> checked;\n    for (int i = 0; i < n; ++i)\n    {\n        checked[elements[i]] = false;\n    }\n\n    for (int i = 0; i < n; ++i)\n    {\n        int k = elements[i];\n        while (checked[k] == false)\n        {\n            checked[k] = true;\n            subloop[i][k] = loop[k];\n            subloop_inv[i][loop[k]] = k;\n            k = loop[k];\n        }\n    }\n\n    // find the minimum for each subloop\n    vector<int> submin(n, 0);\n    for (int i = 0; i < n; ++i)\n    {\n        auto itr = subloop[i].begin();\n        submin[i] = itr->first;\n    }\n\n    // derive the sum of elements for each subloop\n    vector<int> subsum(n, 0);\n    for (int i = 0; i < n; ++i) {\n        for (auto itr = subloop[i].begin(); itr != subloop[i].end(); ++itr)\n        {\n            subsum[i] += itr->first;\n        }\n    }\n\n    // calculate the cost for whole loops\n    int cost = 0;\n    for (int i = 0; i < n; ++i)\n    {\n        if (subloop[i].size() <= 1)\n        {\n            continue;\n        }\n        else\n        {\n            cost += min(subsum[i] + (subloop[i].size() - 2) * submin[i], subsum[i] + submin[i] + (subloop[i].size() + 1) * elements_sorted[0]);\n        }\n    }\n\n    cout << cost << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<map>\n#include<vector>\nint main(void) {\n\tstd::ios_base::sync_with_stdio(false);\n\tint n, input;\n\tstd::cin >> n;\n\tstd::map<int, int>w;\n\tstd::vector<int>vector(n+1,0);\t\n\tfor (int i = 1; i <= n; ++i) {\n\t\tstd::cin >> input;\n\t\tvector[i] = input;\n\t}\n\tstd::vector<int>vector_min= vector;\n\tstd::sort(vector_min.begin(), vector_min.end());\n\tfor (int i = 1; i <= n; ++i) {\n\t\tw[vector[i]] = vector_min[i];\n\t}\n\tstd::map<int, int>w_1(w);\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint temp =0;\n\t\twhile (vector_min[i] != w[vector_min[i]]) {\n\t\t\ttemp += vector_min[i] + w[vector_min[i]] ;\n\t\t\tstd::swap(w[vector_min[i]],w[w[vector_min[i]]] );\n\t\t}\n\t\tint temp_1 = static_cast<int>(1e5);\n\t\tif (i>1&&vector_min[i] != w_1[vector_min[i]]) {\n\t\t\ttemp_1 =  vector_min[i]+ vector_min[1] ;\n\n\t\t\tstd::swap(w_1[vector_min[i]], w_1[vector_min[1]]);\n\t\t\twhile (vector_min[1] !=w_1[vector_min[1]]) {\n\t\t\t\ttemp_1 += vector_min[1]+ w_1[vector_min[1]] ;\n\t\t\t\tstd::swap(w_1[vector_min[1]], w_1[w_1[vector_min[1]]]); }\n\t\t}\n\t\telse if (i == 1 ) {\n\t\t\twhile (vector_min[1] != w_1[vector_min[1]]) {\n\t\t\t\ttemp_1 += vector_min[i] + w_1[vector_min[i]];\n\t\t\t\tstd::swap(w_1[vector_min[i]], w_1[w_1[vector_min[i]]]);\n\t\t\t}\t\t\t\n\t\t}\n\t\tcnt += std::min(temp, temp_1);\n\t}\n\tstd::cout << cnt << std::endl;\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nstruct unionfind\n{\n\t//rankのオーバーフローに注意\n\tvector<int> par, rank;\n\tunionfind(int n)\n\t{\n\t\tpar.resize(n);\n\t\trank.resize(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 1;\n\t\t}\n\t}\n\n\tbool same(int u, int v)\n\t{\n\t\treturn root(u) == root(v);\n\t}\n\n\tvoid unite(int u, int v)\n\t{\n\t\tif (same(u, v)) return;\n\t\tu = root(u), v = root(v);\n\t\tif (rank[u] > rank[v]) swap(u, v);\n\t\tpar[u] = v;\n\t\trank[v] += rank[u];\n\t}\n\n\tint root(int v)\n\t{\n\t\tif (par[v] == v) return v;\n\t\treturn par[v] = root(par[v]);\n\t}\n};\n\nvoid solve()\n{\n\tint N;\n\tcin >> N;\n\tvector<int> ws(N), cs(N);\n\tset<int> s;\n\tmap<int, int> mp;\n\tint m = INT_MAX;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> ws[i];\n\t\ts.insert(ws[i]);\n\t\tm = min(m, ws[i]);\n\t}\n\n\tint cnt = 0;\n\tfor (int v : s)\n\t{\n\t\tmp[v] = cnt++;\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcs[i] = mp[ws[i]];\n\t}\n\n\tunionfind uf(N);\n\tvector<int> es[N];\n\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tuf.unite(i, cs[i]);\n\t}\n\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tes[uf.root(cs[i])].push_back(ws[cs[i]]);\n\t\t//cout << cs[i] << ' ';\n\t}\n\t//cout << endl;\n\n\tint ans = 0;\n\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tauto e = es[i];\n\t\tint n = e.size(), x = INT_MAX, sum = 0;\n\t\tif (n < 2) continue;\n\t\tfor (int v : e)\n\t\t{\n\t\t\tsum += v;\n\t\t\tx = min(v, x);\n\t\t}\n\t\tsum -= x;\n\t\tsum += min((n-1)*x, 2*(x+m)+(n-1)*m);\n\t\tans += sum;\n\t\t//cout << ans << endl;\n\t}\n\n\tcout << ans << endl;\n\n}\n\nint main(void)\n{\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n\n//?£wi + (n - 2) * min(wi)\n//or\n//?£wi + min(wi) + (n+1) * x\n\nint main() {\n\tint MAX = 1000;\n\tint VMAX = 10000;\n\n\tint A[MAX];\n\tint B[MAX];\n\tbool V[MAX];\n\tint T[VMAX];\n\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint s = VMAX;\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &A[i]);\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t\ts = min(s, A[i]);\n\t}\n\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tT[B[i]] = i;\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (V[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile (1) {\n\t\t\tV[cur] = true;\n\t\t\tm = min(m, A[cur]);\n\t\t\tint v = A[cur];\n\t\t\tS += v;\n\t\t\t++an;\n\t\t\tcur = T[v];\n\t\t\tif (V[cur] == true) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tans += min(S + (an - 2) * m, S + m + (an + 1) * s);\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "const int MAXN = 1010;\nint w[MAXN];\nbool done[MAXN];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, mini = 100000;\n    cin >> n;\n    map<int, int> mp;\n    for (int i = 0; i < n; i++) {\n        cin >> w[i];\n        mp[w[i]] = 0;\n        mini = min(mini, w[i]);\n    }\n    {\n        int k = 0;\n        for (auto& p : mp) p.second = k++;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (done[i]) continue;\n        int cnt = 0, now = i, mi = 100000, sum = 0;\n        while (1) {\n            if (done[now]) break;\n            cnt++;\n            done[now] = true;\n            mi = min(mi, w[now]);\n            sum += w[now];\n            now = mp[w[now]];\n        }\n        int tmp = sum+(cnt-2)*mi;\n        tmp = min(tmp, sum+mi+mini*(cnt+1));\n        ans += tmp;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <unordered_map>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nnamespace std{\n\ttemplate<typename T>\n\tinline void hash_combine(size_t& seed, T const& v){\n\t\tseed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n\t}\n    template<typename It>\n    inline size_t hash_range(It first, It last){\n\t\tsize_t seed=0;\n\t\thash_range(seed,first,last);\n\t\treturn seed;\n\t}\n\ttemplate<typename It>\n\tinline void hash_range(size_t& seed, It first, It last){\n\t\tfor(;first!=last;++first)hash_combine(seed, *first);\n\t}\n\ttemplate<typename A,typename B>\n\tclass hash<pair<A,B>>{\n\t\tpublic:\n\t\tsize_t operator()(pair<A,B> const &p) const{\n\t\t\tsize_t seed=0;\n\t\t\thash_combine(seed,p.first);\n\t\t\thash_combine(seed,p.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\ttemplate<typename T,size_t N>\n\tclass hash<array<T,N>>{\n\t\tpublic:\n\t\tsize_t operator()(array<T,N> const &container) const{\n\t\t\treturn hash_range(container.begin(),container.end());\n\t\t}\n\t};\n\ttemplate<typename T,typename A>\n\tclass hash<vector<T,A>>{\n\t\tpublic:\n\t\tsize_t operator()(vector<T,A> const &container) const{\n\t\t\treturn hash_range(container.begin(),container.end());\n\t\t}\n\t};\n}\n\nint main(){\n\tint N;\n\tscanf(\"%d\",&N);\n\tvector<short>v(N);\n\tfor(int i=0;i<N;i++)scanf(\"%d\",&v[i]);\n\tpriority_queue<pair<int,vector<short> > >q;\n\tunordered_map<vector<short>,int>depth;\n\n\tq.push(make_pair(0,v));\n\tint R;\n\tfor(;!q.empty();){\n\t\tpair<int,vector<int> >cur=q.top();\n\t\tq.pop();\n\t\tif(depth.find(cur.second)!=depth.end())continue;\n\t\tdepth[cur.second]=cur.first;\n\t\tbool f=false;\n\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++)if(i!=j&&cur.second[i]>cur.second[j]){\n\t\t\tif(i<j)f=true;\n\t\t\tswap(cur.second[i],cur.second[j]);\n\t\t\tq.push(make_pair(cur.first-cur.second[i]-cur.second[j],cur.second));\n\t\t\tswap(cur.second[i],cur.second[j]);\n\t\t}\n\t\tif(!f){\n\t\t\tR=-cur.first;\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",R);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\nconst int INF = INT_MAX/3;\n\nint main(){\n    //??\\???\n    int n;\n    cin >> n;\n    int input[n];\n    for (int i=0;i<n;i++){\n        cin >> input[i];\n    }\n\n    //?????§????????¨??????\n    int checked[n];\n    for (int i=0;i<n;i++){\n        checked[i] = 0;\n    }\n\n    //??\\???????????????????????????????±???????\n    vector< pair<int, int > >inputSorted;\n    for(int i=0;i<n;i++){\n        inputSorted.push_back(make_pair(input[i], i));\n    }\n    sort(inputSorted.begin(), inputSorted.end());\n    int toMove[n];\n    for (int i=0;i<n;i++){\n        toMove[inputSorted[i].second] = i;\n    }\n    int totalMini = inputSorted[0].first;\n\n    //??¢?????´?????????\n    int result = 0;\n    for (int i=0;i<n;i++){\n        if (checked[i] == 0 and i != toMove[i]){\n            checked[i] = 1;\n            int mini = input[i];\n            int count = 1;\n            int sum = input[i];\n            int now = toMove[i];\n            while(i!=now){\n                checked[now] = 1;\n                mini = min(mini, input[now]);\n                count++;\n                sum += input[now];\n                now = toMove[now];\n            }\n            sum += mini*(count - 2);\n            int sum2 = sum + (mini+totalMini)*2 -mini*(count-1)+totalMini*(count-1);\n            result += min(sum, sum2);\n        }\n    }\n\n    cout << result << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n        int n, ans=0, amin=10000;\n        cin>>n;\n        int a[n], b[n], T[10000];\n        bool V[n];\n        for(int i=0;i<n;i++) V[i] = true;\n        for(int i=0;i<n;i++) {\n                cin>>a[i];\n                b[i]=a[i];\n                amin=min(a[i], amin);\n        }\n        sort(b, b+n);\n        for(int i=0;i<n;i++) T[b[i]] = i;\n\n        for(int i=0;i<n;i++) {\n                if(!V[i]) continue;\n                int j = i, tmpmin = a[i], c=0;\n                int S = 0;\n                while(V[j]){\n                        c++;\n                        tmpmin = min(tmpmin, a[j]);\n                        S += a[j];\n                        V[j] = false;\n                        j = T[a[j]];\n                }\n                ans += min(S+(c-2)*tmpmin, S+tmpmin+(c+1)*amin);\n        }\n\n        cout<<ans<<endl;\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define NMAX 1000\n#define VMAX 10000\n\nint main() {\n    int A[NMAX + 10], C[VMAX + 10], V[NMAX + 10], n;\n    int m = VMAX + 10; // smallest element in A\n    scanf(\"%d\", &n);\n    for (int i = 0; i <= VMAX; i++) {\n        C[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &A[i]);\n        V[i] = 0;\n        C[A[i]]++;\n        if (A[i] < m) {\n            m = A[i];\n        }\n    }\n    for (int i = 1; i <= VMAX; i++) {\n        C[i] += C[i - 1];\n    }\n    int cost = 0;\n\n    for (int i = 1; i <= n; i++) {\n        if (V[i]) {\n            continue;\n        }\n        // found a new ring, whose head is A[i]\n        V[i] = 1;\n        int k = C[A[i]]; // iterator\n        int len = 1;     // length of the ring\n        int min = A[i];  // smallest element of the ring\n        int sum = A[i];  // sum of the ring\n        while (k != i) {\n            V[k] = 1;\n            len++;\n            sum += A[k];\n            if (A[k] < min) {\n                min = A[k];\n            }\n            k = C[A[k]];\n        }\n        if (len > 1) {\n            int v1 = sum + (len - 2) * min;\n            int v2 = sum + (len + 1) * m + min;\n            cost += (v1 < v2 ? v1 : v2);\n        }\n    }\n\n    printf(\"%d\\n\", cost);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <string>\n#define MAX 1000\n#define INFTY 1<<30 // 2^30\nusing namespace std;\ntypedef long long llong;\n \nstatic const int VMAX = 10000;\nint n, A[MAX+10], s;\nint B[MAX+10], T[VMAX+10];\n \nint solve()\n{\n  int ans = 0;\n  bool V[MAX+10];\n  for(int i = 0; i < n; i++)\n  {\n    B[i] = A[i];\n    V[i] = false;\n  }\n  sort(B,B+n);\n  for(int i = 0; i < n; i++) T[B[i]] = i; // ????????????????????????????????????????????????\n  for(int i = 0; i < n; i++)\n  {\n    if(V[i]) continue;\n    int cur = i; // current point\n    int S = 0; // sum of mass\n    int m = VMAX; // min of the cycle\n    int an = 0; // the number of material the cycle have\n    while(1)\n    {\n      V[cur] = true; //already visited\n      an++;\n      int v = A[cur];\n      m = min(m, v);\n      S += v;\n      cur = T[v];\n      if(V[cur]) break;\n    }\n    ans += min(S+(an-2)*m, S+(an+1)*s+m);\n  }\n  return ans;\n}\n \nint main()\n{\n  cin >> n;\n  s = VMAX;\n  for(int i = 0; i < n; i++)\n  {\n    cin >> A[i];\n    s = min(s,A[i]);\n  }\n  cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define MAX 1100\n#define MAX_W 11000\n\n\nint n, mimi = MAX_W;\nbool used[MAX];\npair<int,int> w[MAX];\n\nint hoge(int x,int sum, int mi,int count){\n\tif(used[x]){\n\t\treturn min(sum+mi*(count-2), mi + sum + (count+1)*mimi);\n\t} else {\n\t\tused[x] = true;\n\t\treturn hoge(w[x].second,sum+w[x].first,min(mi,w[x].first),count+1);\n\t}\n}\n\nint main(){\n\tint W, sum = 0;\n\t\n\tcin>>n;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tcin>>W;\n\t\tw[i] = make_pair(W,i);\n\t\tmimi = min(W, mimi);\n\t}\n\t\n\tsort(w, w + n);\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tif(!used[i]) sum +=  hoge(i,0,w[i].first,0);\n\t}\n\t\n\tcout<<sum<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n\tint N; cin >> N;\n\tvector<int> v(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> v[i];\n\t}\n\tmap<int, int> now;\n\tfor (int i = 0; i < N; ++i) {\n\t\tnow[v[i]] = i;\n\t}\n\tvector<int> to = v;\n\tsort(to.begin(), to.end());\n\tll ans = 0;\n\tfor (int i = N-1; i >= 0; --i) {\n\t\tif (v[i] == to[i]) continue;\n\t\tint j = now[to[i]];\n\t\tswap(v[i], v[j]);\n\t\tnow[v[i]] = j;\n\t\tnow[v[j]] = i;\n\t\tans += v[i]+v[j];\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint n, w[1010], a[1010], b[1010], mi=100000;\nbool used[1010];\n\nint partition(int *A, int p, int r){\n  int x = A[r];\n  int i = p - 1;\n    for(int j = p;j < r;j++){\n      if(A[j] <= x){\n        i++;\n        swap(A[i], A[j]);\n      }\n    }\n    swap(A[i + 1], A[r]);\n  return i + 1;\n}\n\nvoid quicksort(int *A, int p, int r){\n  if(p < r){\n    int q = partition(A, p, r);\n    quicksort(A, p, q - 1);\n    quicksort(A, q + 1, r);\n  }\n}\n\nint solve(){\n  \n  int ans = 0;\n  \n  for(int i = 0;i < n;i++) b[a[i]] = i;\n  \n  for(int i = 0;i < n;i++){\n    int cnt = 0, sum = 0, now = i, mimi = 100000;\n    \n    if(used[i]) continue;\n    \n    while(true){\n      if(used[now]) break;\n      cnt++;\n      used[now] = true;\n      mimi = min(mimi, w[now]);\n      sum += w[now];\n      now = b[w[now]];\n    }\n    \n    ans += min(sum + (cnt - 2) * mimi, sum + mi + (cnt + 1) * mimi);\n  }\n  \n  return ans;\n}\n\nint main(){\n  \n  cin >> n;\n  for(int i = 0;i < n;i++){\n    cin >> w[i];\n    a[i] = w[i];\n    mi = min(mi, w[i]);\n  }\n  \n  quicksort(a, 0, n - 1);\n  \n  cout << solve() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,a[1111],tmp[1111],b[1111]={},mina=10000,ans=0;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>a[i];\n    tmp[i]=a[i];\n    mina=min(a[i],mina);\n  }\n  \n  sort(tmp,tmp+n);\n  \n  for(int i=0;i<n;i++){\n    int l=0,r=n,m;\n    while(1){\n      m=(l+r)/2;\n      if(tmp[m]>a[i])r=m;\n      else if(tmp[m]<a[i])l=m;\n      else {\n\ta[i]=m;\n\tbreak;\n      }\n    }\n  }\n  \n  for(int i=0;i<n;i++){\n    if(a[i]!=i&&b[i]==0){\n      int t=i,mint=10000,sum=0,cnt=0;\n      while(1){\n\tcnt++;\n\tsum+=tmp[a[t]];\n\tmint=min(mint,tmp[a[t]]);\n\tb[t]++;\n\tt=a[t];\n\tif(t==i){\n\t  ans+=min(sum+mint*(cnt-2),sum-mint+mina*(cnt-1)+(mina+mint)*2);\n\t  break;\n\t}\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//????????°???????????°????????????????????\\??????????????¢?????´???????????¨??????????§???? P181-182(Google Books?????¬?????\\???)?????????.\n\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint do_cycle(vector<int> &v,int x){\n\tint s=0,m=1<<30;\n\tfor(auto &e:v)s+=e,m=min(m,e);\n\treturn min(s+(v.size()-2)*m,s+m+(v.size()+1)*x);\n}\n\nint main(){\n\tint N,x=1<<30,r=0;\n\tscanf(\"%d\",&N);\n\tvector<int>v(N),b(N),se(N);\n\tmap<int,int>m;\n\tvector<vector<int> >cycles;\n\tfor(int i=0;i<N;i++)scanf(\"%d\",&v[i]),x=min(x,v[i]),se[i]=v[i];\n\tsort(se.begin(),se.end());\n\tint i=0;for(auto &e:se){m[e]=i++;}\n\tfor(int i=0;i<N;i++)if(!b[i]){\n\t\tvector<int>cycle;\n\t\tint k=i;\n\t\tdo{\n\t\t\tcycle.push_back(se[k]);\n\t\t\tb[k]=1;\n\t\t\tk=m[v[k]];\n\t\t}while(k!=i);\n\t\tr+=do_cycle(cycle,x);\n\t}\n\tprintf(\"%d\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define rep(i, n) for (ll i = 0; i < n; ++i)\n#define ALL(a) a.begin(), a.end()\nll dx[4] = { 0, 1, 0, -1 };\nll dy[4] = { 1, 0, -1, 0 };\nconst ll INF = 1e14;\nconst ll MOD = 1e9 + 7;\n#define MAX 1000\n#define VMAX 10000\nint w[MAX];\nbool done[MAX];\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, mini = VMAX;\n    cin >> n;\n    map<int, int> mp;\n    for (int i = 0; i < n; i++) {\n        cin >> w[i];\n        mp[w[i]] = 0;\n        mini = min(mini, w[i]);\n    }\n\n    int k = 0;\n    for (auto& p : mp) {\n        p.second = k++;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (done[i]) {\n            continue;\n        }\n        int cnt = 0, cur = i, sum = 0, mi = VMAX;\n        while (true) {\n            if (done[cur]) {\n                break;\n            }\n            cnt++;\n            done[cur] = true;\n            mi = min(mi, w[cur]);\n            sum += w[cur];\n            cur = mp[w[cur]];\n        }\n        int tmp = sum + (cnt - 2) * mi;\n        tmp = min(tmp, sum + mi + mini * (cnt + 1));\n        ans += tmp;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve(){\n\tint ans = 0;\n\t\n\tbool V[MAX];\n\tfor(int i=0;i<n;i++){\n\t\tB[i]=A[i];\n\t\tV[i]=false;\n\t}\n\t\n\tsort(B,B+n);\n\tfor(int i=0;i<n;i++)  T[B[i]]=i;\n\tfor(int i=0;i<n;i++){\n\t\tif(V[i]) continue;\n\t\tint cur = i;\n\t\tint S=0;\n\t\tint m=VMAX;\n\t\tint an=0;\n\t\twhile(1){\n\t\t\tV[cur]=true;\n\t\t\tan++;\n\t\t\tint v=A[cur];\n\t\t\tm=min(m,v);\n\t\t\tS+=v;\n\t\t\tcur=T[v];\n\t\t\tif(V[cur]) break;\n\t\t}\n\t\tans+=min(S+(an-2)*m,m+S+(an+1)*s);\n\t}\n\treturn ans;\n}\n\nint main() {\n\t\n\tcin>>n;\n\ts=VMAX;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>A[i];\n\t\ts=min(s,A[i]);\n\t}\n\t\n\tint ans=solve();\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nint N,W[1005],C[1005],c=0,t,p,res=0;\nmap<int,int>H;//number2order\nmap<int,int>rH;//order2number\nvector<int>S;\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++)\n\t\tscanf(\"%d\",C+i);\n\tmemcpy(W,C,sizeof(C));\n\tsort(C,C+N);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tH[C[i]]=i;\n\t\trH[i]=C[i];\n\t}\n\tfor(int i=0;i<N;i++)\n\t\tS.push_back(W[i]);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tint nn=rH[i];\n\t\tint np=find(S.begin(),S.end(),nn)-S.begin();\n\t\tfor(;np!=H[nn];)\n\t\t{\n\t\t\tint dn=rH[np];\n\t\t\tint dp=find(S.begin(),S.end(),dn)-S.begin();\n\t\t\tswap(S[np],S[dp]);\n\t\t\tres+=nn+dn;\n\t\t\tnp=dp;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 10000;\nstatic const int VMAX = 100000;\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve(){\n    int i,ans = 0;\n    \n    bool V[MAX];\n    for(i=0;i<n;i++){\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B,B+n);\n    for(i=0;i<n;i++)\n        T[B[i]] = i;\n    for(i=0;i<n;i++){\n        if(V[i])\n               continue;\n        int cur=i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while(1){\n            V[cur] = true;\n            an++;\n            int v=A[cur];\n            m = min(m,v);\n            S+=v;\n            cur = T[v];\n            if(V[cur]) \n                   break;\n        }\n        ans += min(S+(an-2)*m,m+S+(an+1)*s);\n    }\n    return ans;\n}\n\n\nint main(){\n    cin>>n;\n    s=VMAX;\n    for(int i=0;i<n;i++){\n        cin>>A[i];\n        s=min(s,A[i]);\n    }\n    int ans = solve();\n\n    cout<<ans<<endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <stdlib.h>\nusing namespace std;\n\n#define MAX_NUM 1000\n\nint W[MAX_NUM];\nint N;\n\nint Compare(const void *a, const void *b)\n{\n    return *(int*)a - *(int*)b;\n}\n\nvoid Swap(int idx1, int idx2) {\n\tint tmp = W[idx1];\n\tW[idx1] = W[idx2];\n\tW[idx2] = tmp;\n}\n\nint SearchIdx(int wi)\n{\t\n\tfor (int i = 0; i < N; i++) {\n\t\tif (W[i] == wi) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void)\n{\n\t//input\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> W[i];\n\t}\n\n\t//minimum cost?\n\tint cost = 0;\n\tint w2[MAX_NUM];\n\tmemcpy(w2, W, sizeof(int) * N);\n\tqsort(w2, N, sizeof(int), Compare);\n\tfor (int i = 0; i < N; i++) {\n\t\tint idx1 = SearchIdx(w2[i]);\n\t\twhile (idx1 != i) {\n\t\t\tint idx2 = SearchIdx(w2[idx1]);\n\t\t\tSwap(idx1, idx2);\n\t\t\tcost = cost + W[idx1] + W[idx2];\n\t\t\tidx1 = idx2;\n\t\t}\n\t}\n\n\t//output\n\tcout << cost << \"\\n\";\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve()\n{\n    int ans = 0;\n\n    bool V[MAX];\n    for (int i = 0; i < n; i++) {\n        B[i] = A[i];\n        V[i] = false;\n    }\n\n    sort(B, B+n);\n    for (int i = 0; i < n; i++) {\n        T[B[i]] = i;\n    }\n    for (int i = 0; i < n; i++) {\n        if (V[i]) continue;\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while (1) {\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m, v);\n            S += v;\n            cur = T[v];\n            if (V[cur]) break;\n        }\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n    }\n\n    return ans;\n}\n\n\nint main(int argc, char const *argv[])\n{\n    cin >> n;\n    s = VMAX;\n    for (int i = 0; i < n; i++) {\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n    int ans = solve();\n    cout << ans << endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nconst int MAX_W = 10000;\nusing namespace std;\n\nint s = MAX_W;\n\nint minCostSort(vector<int>& A) {\n    int ret = 0;\n\n    vector<bool> V(A.size());\n    vector<int> B = A;\n    vector<int> T(MAX_W+1);\n    for (auto i = 0; i < A.size(); i++) {\n        V[i] = false;\n    }\n    sort(B.begin(), B.end());\n    for (auto i = 0; i < A.size(); i++) {\n        T[B[i]] = i;\n    }\n\n    for (auto i = 0; i < A.size(); i++) {\n        if (V[i]) continue;\n\n        int cur = i;\n        int S = 0;\n        int m = MAX_W;\n        int an = 0;\n        while (1) {\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m, v);\n            S += v;\n            cur = T[v];\n            if (V[cur]) break;\n        }\n        ret += min(S + (an-2)*m, m + S + (an+1)*s);\n    }\n    return ret;\n}\n\nint main(void) {\n    int n;\n    cin >> n;\n\n    vector<int> W(n);\n    for (int i = 0; i < n; i++) {\n        cin >> W[i];\n        s = min(s, W[i]);\n    }\n\n    int ans = minCostSort(W);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <algorithm>\n#include <numeric>\n#include <bitset>\n\nconstexpr int ElementNumMax {1000};\nconstexpr int ValueMax {10000};\n\n//数値に対応したインデックスを保持\nstd::array<int, ValueMax> table;\n\nclass Cycle\n{\npublic:\n    \n    static constexpr int nil = -1;\n\n    void add(int x)\n    {\n        c.emplace_back(x);\n        \n        if (localMin == nil || x < localMin)\n            localMin = x;\n    }\n\n    const std::vector<int>& cycle() const\n    {\n        return c;\n    }\n\n    int minValue() const\n    {\n        return localMin;\n    }\n\n    int minCost(int globalMin) const\n    {\n        if (c.size() == 1)\n            return 0;\n\n        int sum {std::accumulate(c.begin(), c.end(), 0)};\n        return sum + \n            std::min(localMin + (c.size() + 1) * globalMin, (c.size() - 2) * localMin);\n    }\n\nprivate:\n\n    std::vector<int>    c;\n    int                 localMin = nil;\n};\n\nvoid solve();\n\nint main()\n{\n    solve();\n    return 0;\n}\n\nvoid solve()\n{\n    using namespace std;\n\n    int n;\n    cin >> n;\n\n    vector<int> vec(n);\n\n    for (int i = 0; i < n; ++i)\n    {\n        cin >> vec[i];\n        //テーブルに数値のインデックスを記録\n        table[vec[i]] = i;\n    }\n\n    sort(vec.begin(), vec.end());\n\n    vector<Cycle> cycles;\n    \n    bitset<ElementNumMax> reached {};\n\n    int globalMin {vec[0]};\n\n    for (int i = 0; i < vec.size(); ++i)\n    {\n        if (vec[i] < globalMin)\n            globalMin = vec[i];\n\n        if (reached[i])\n            continue;\n        \n        //サイクルを作成する\n        Cycle c;\n        c.add(vec[i]);\n\n        int nextIndex = table[vec[i]];\n        reached[i] = true;\n\n        //1周するまで\n        while (nextIndex != i)\n        {\n            c.add(vec[nextIndex]);\n            reached[nextIndex] = true;\n            nextIndex = table[vec[nextIndex]];\n        }\n        \n        cycles.push_back(move(c));\n    }\n\n    int sum = accumulate(cycles.begin(), cycles.end(), 0, \n        [globalMin](int init, const Cycle& c)\n    {\n        return init + c.minCost(globalMin);\n    });\n\n    cout << sum << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <unordered_map>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nnamespace std{\n\ttemplate<typename T>\n\tinline void hash_combine(size_t& seed, T const& v){\n\t\tseed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n\t}\n    template<typename It>\n    inline size_t hash_range(It first, It last){\n\t\tsize_t seed=0;\n\t\thash_range(seed,first,last);\n\t\treturn seed;\n\t}\n\ttemplate<typename It>\n\tinline void hash_range(size_t& seed, It first, It last){\n\t\tfor(;first!=last;++first)hash_combine(seed, *first);\n\t}\n\ttemplate<typename A,typename B>\n\tclass hash<pair<A,B>>{\n\t\tpublic:\n\t\tsize_t operator()(pair<A,B> const &p) const{\n\t\t\tsize_t seed=0;\n\t\t\thash_combine(seed,p.first);\n\t\t\thash_combine(seed,p.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\ttemplate<typename T,size_t N>\n\tclass hash<array<T,N>>{\n\t\tpublic:\n\t\tsize_t operator()(array<T,N> const &container) const{\n\t\t\treturn hash_range(container.begin(),container.end());\n\t\t}\n\t};\n\ttemplate<typename T,typename A>\n\tclass hash<vector<T,A>>{\n\t\tpublic:\n\t\tsize_t operator()(vector<T,A> const &container) const{\n\t\t\treturn hash_range(container.begin(),container.end());\n\t\t}\n\t};\n}\n\nint main(){\n\tint N;\n\tscanf(\"%d\",&N);\n\tvector<int>v(N);\n\tfor(int i=0;i<N;i++)scanf(\"%d\",&v[i]);\n\tpriority_queue<pair<int,vector<int> > >q;\n\tunordered_map<vector<int>,int>depth;\n\n\tq.push(make_pair(0,v));\n\tint R;\n\tfor(;!q.empty();){\n\t\tauto cur=q.top();\n\t\tq.pop();\n\t\tif(depth.find(cur.second)!=depth.end())continue;\n\t\tdepth[cur.second]=cur.first;\n\t\tbool f=false;\n\t\tfor(int i=0;i<N-1;i++)for(int j=i+1;j<N;j++){\n\t\t\tif(cur.second[i]>cur.second[j])f=true;\n\t\t\tswap(cur.second[i],cur.second[j]);\n\t\t\tif(depth.find(cur.second)==depth.end())q.push(make_pair(cur.first-cur.second[i]-cur.second[j],cur.second));\n\t\t\tswap(cur.second[i],cur.second[j]);\n\t\t}\n\t\tif(!f){\n\t\t\tR=-cur.first;\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",R);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(void){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n; cin >> n;\n  vector<int> w(n);\n  vector<int> sorted;\n  vector<int> idx(10001, -1);\n  for(int i = 0; i < n; i++){\n    cin >> w[i];\n  }\n  sorted = w;\n  sort(sorted.begin(), sorted.end());\n  for(int i = 0; i < n; i++){\n    idx[ w[i] ] = i;\n  }\n\n  int ans = 0;\n  //swapping pairs are paired\n  for(int i = 0; i < n; i++){\n    if(w[i] == sorted[i]) continue;\n\n    /*\n    for(int l = 0; l < n; l++) cout << sorted[l] << \" \";\n    cout << endl;\n    */\n\n\n    if( sorted[i] == w[idx[ sorted[i] ] ]){\n      ans += sorted[i] + sorted[ idx[ sorted[i] ] ];\n      swap(sorted[i], sorted[ idx[ sorted[i] ] ]);\n    }\n  }\n\n  vector<int> chk(w);\n  sort(chk.begin(), chk.end());\n  for(int i = n-1; i >= 0; i--){\n    int v = chk[i];\n    int sortedind = -1;\n    for(int j = 0; j < n; j++){\n      if(sorted[j] == v){\n        sortedind = j;\n        break;\n      }\n    }\n    if(sortedind == idx[v]) continue;\n    ans += sorted[sortedind] + sorted[idx[v]];\n    swap(sorted[sortedind], sorted[idx[v]]);\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n#define rep(i, n) for(int i=0; i<n; ++i)\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\nusing namespace std;\nusing ll = int64_t;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vs = vector<string>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nconst int INF = 100010001;\nconst ll LINF = (ll)INF*INF*10;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    vi a(n), b(n);\n    map<int, int> mp;\n    int mi = INF;\n    rep(i, n) {\n        cin >> a[i];\n        b[i] = a[i];\n        mi = min(mi, a[i]);\n    }\n    sort(all(b));\n    rep(i, n) {\n        mp[b[i]] = i;\n    }\n\n    int ans = 0;\n    vi check(n);\n    rep(i, n) {\n        if(check[i]) continue;\n        int cnt = 0;\n        int now = i;\n        int sum = 0;\n        int nmi = a[i];\n        while(true) {\n            check[now] = 1;\n            nmi = min(nmi, a[now]);\n            cnt++;\n            sum += a[now];\n            now = mp[a[now]];\n            if(check[now]) break;\n        }\n        ans += min(sum+(cnt-2)*nmi, (cnt+1)*mi+sum+nmi);\n    }\n\n    cout << ans << endl;\n}  \n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\nusing std::scanf;\nusing std::printf;\n\nconst int kMaxN = 1000;\nconst int kMaxWi = 10000;\n\nint BinarySearch(int A[], int n, int key) {\n  int left = 0, right = n, mid;\n  while (left < right) {\n    mid = (left + right) / 2;\n    if (A[mid] == key) { return mid; }\n    if (key < A[mid]) { right = mid; }\n    if (A[mid] < key) { left = mid + 1; }\n  }\n  return -1;\n}\n\n// w[i]?????????????????????????????????cycle???????????????????????????remain????????£?????????????¨????\n// ????????????cycle?????????\nint MakeCycle(int w[], int i, int n, int index_sorted[], int remain[], int cycle[]) {\n  int j = 0;\n  cycle[0] = -1; //?????????while?????????????????????\n  while(w[i] != cycle[0]) {\n    cycle[j] = w[i];\n    ++j;\n    remain[i] = 0;\n    i = index_sorted[w[i]];\n  }\n  return j;\n}\n\nint CompareCosts(int cycle[], int n_cycle, int min_cycle, int min_w) {\n  if (n_cycle == 1) {\n    return 0;\n  } else if (n_cycle == 2) {\n    return cycle[0] + cycle[1];\n  } else {\n    int cycle_sum, i, cost1, cost2;\n    cycle_sum = 0;\n    for (i = 0; i < n_cycle; ++i) { cycle_sum += cycle[i]; }\n    cost1 = cycle_sum + (n_cycle - 2) * min_cycle;\n    cost2 = cycle_sum + min_cycle + (n_cycle + 1) * min_w;\n    return std::min(cost1, cost2);\n  }\n}\n\nint main() {\n  int n, i, j, min_w, n_cycle, min_cycle, cnt;\n  int index_sorted[kMaxWi + 1];\n  scanf(\"%d\", &n);\n  int w[n], sorted[n], remain[n], cycle[n];\n  for (i = 0; i < n; ++i) { scanf(\"%d\", &w[i]); }\n  min_w = kMaxWi;\n  for (i = 0; i < n; ++i) { min_w = std::min(min_w, w[i]); }\n  for (i = 0; i < n; ++i) { sorted[i] = w[i]; }\n  std::sort(sorted, sorted + n);\n  for (i = 0; i < n; ++i) { index_sorted[sorted[i]] = i; }\n  for (i = 0; i < n; ++i) { remain[i] = 1; }\n  cnt = 0;\n  for (i = 0; i < n; ++i) {\n    if (remain[i]) {\n      n_cycle = MakeCycle(w, i, n, index_sorted, remain, cycle);\n      min_cycle = kMaxWi;\n      for (j = 0; j < n_cycle; ++j) { min_cycle = std::min(min_cycle, cycle[j]); }\n      cnt += CompareCosts(cycle, n_cycle, min_cycle, min_w);\n    }\n  }\n  printf(\"%d\\n\", cnt);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int INF = 1000000;\n\nstruct node\n{\n\tint num;\n\tint place;  \n};\n\nint partition(node *A,int p,int r)\n{\n\tint j,temp;\n\tnode x;\n\n\tx = A[r];\n\tj = p-1;\n\n\tfor(int i = p; i < r; i++)\n\t{\n\t\tif (A[i].num <= x.num)\n\t\t{\n\t\t\tj++;\n\t\t\ttemp = A[i].num;\n\t\t\tA[i].num = A[j].num;\n\t\t\tA[j].num = temp;\n\t\t}\n\t}\n\n\ttemp = A[j+1].num;\n\tA[j+1].num = A[r].num;\n\tA[r].num = temp;\n\n\treturn j+1;\n}\n\nvoid quicksort(node *A,int p,int r)\n{\n\tint q;\n\n\tif (p < r)\n\t{\n\t\tq = partition(A,p,r);\n\t\tquicksort(A,p,q-1);\n\t\tquicksort(A,q+1,r);\n\t}\n}\n\n\nint main()\n{\n\tint n,sum,minall,mini,sol,cnt,j;\n\tnode a[1000] = {0},b[1000] = {0};\n\n\tsol = 0;\n\tminall = INF;\n\n\tscanf(\"%d\", &n);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i].num);\n\t\ta[i].place = i;\n\t\tb[i] = a[i];\n\t\tb[i].place = i;\n\n\t\tif (minall > a[i].num)\n\t\t{\n\t\t\tminall = a[i].num;\n\t\t}\n\t}\n\n\tquicksort(b,0,n-1);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tsum = 0;\n\n\t\tif (a[i].num >= 0)\n\t\t{\n\t\t\tsum += a[i].num;\n\t\t\tmini = a[i].num;\n\t\t\tcnt = 1;\n\t\t\tj = i;\n\n\t\t\twhile(b[a[j].place].num != a[i].num)\n\t\t\t{\n\t\t\t\tfor(int k = 0; k < n; k++)\n\t\t\t\t{\n\t\t\t\t\tif (a[k].num == b[a[j].place].num)\n\t\t\t\t\t{\n\t\t\t\t\t\tj = k;\n\t\t\t\t\t\tsum += a[k].num;\n\t\t\t\t\t\tcnt++;\n\n\t\t\t\t\t\tif (mini > a[k].num)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmini = a[k].num;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ta[k].num = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ta[i].num = -1;\n\n\t\t\tsol += min(sum + mini * (cnt -2), sum + mini + (cnt + 1) * minall);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", sol);\n\n\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <utility>\n\nusing namespace std;\n\nint main() {\n    size_t n;\n    scanf(\"%zu\", &n);\n\n    vector<int> w(n);\n    map<int, size_t> m;\n    int minw=1e8;\n    for (size_t i=0; i<n; ++i) {\n        scanf(\"%d\", &w[i]);\n        m[w[i]] = 0;\n        if (minw > w[i])\n            minw = w[i];\n    }\n\n    {\n        size_t k=0;\n        for (pair<const int, size_t> &p: m)\n            p.second = k++;\n    }\n\n    int res=0;\n    vector<bool> done(n);\n    for (size_t i=0; i<n; ++i) {\n        if (done[i]) continue;\n\n        int count_=0, minc=1e8, sum=0;\n        size_t cur=i;\n        for (count_=0; ; ++count_) {\n            if (done[cur]) break;\n\n            done[cur] = true;\n            if (minc > w[cur])\n                minc = w[cur];\n\n            sum += w[cur];\n            cur = m[w[cur]];\n        }\n\n        res += sum + min((count_-2)*minc, minc+minw*(count_+1));\n    }\n\n    printf(\"%d\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\nint solve(){\nint ans = 0;\nbool V[MAX];\nfor(int i = 0; i < n; i++){\nB[i] = A[i];\nV[i] = false;\n}\nsort(B, B+n);\nfor(int i = 0; i < n; i++) T[B[i]] = i;\nfor(int i = 0; i < n; i++){ \nif(V[i]) continue;\nint cur = i;\nint S = 0;\nint m = VMAX;\nint an = 0;\nwhile(1){\nV[cur] = true;\nan++;\nint v = A[cur];\nm = min(m, v);\nS += v;\nif(V[cur]) break;\n}\nans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n}\nreturn ans;\n}\nint main(){\ncin >> n;\ns = VMAX;\n}\nint ans = solve();\ncount << ans << endl;\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ALDS1_6_D.cpp\n// Sort II - Minimum Cost Sort\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int MAXW = 10005;\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<int> w(n);\n\tvector<int> w_sorted(MAXW, -1);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> w[i];\n\t\tw_sorted[w[i]]++;\n\t}\n\t\n\tint w_cnt = 0;\n\tfor (int i = 0; i < w_sorted.size(); i++) {\n\t\tif (w_sorted[i] >= 0) {\n\t\t\tw_sorted[i] += w_cnt;\n\t\t\tw_cnt++;\n\t\t}\n\t}\n\n\tint w_min = MAXW;\n\t// int w_max = -1;\n\tint w_sum = 0;\n\tint w_cnt1 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (w_sorted[w[i]] != i) {\n\t\t\tw_sum += w[i];\n\t\t\tw_min = min(w_min, w[i]);\n\t\t\t// w_max = max(w_max, w[i]);\n\t\t\tint tmp = w[w_sorted[w[i]]];\n\t\t\tif (w[w_sorted[tmp]] != w[i])\n\t\t\t\tw_cnt1++;\n\t\t}\n\t}\n\tint res = w_sum + w_min * max(w_cnt1 - 2, 0);\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(void){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n; cin >> n;\n  vector<int> w(n);\n  vector<int> sorted;\n  vector<int> idx(10001, -1);\n  for(int i = 0; i < n; i++){\n    cin >> w[i];\n  }\n  sorted = w;\n  sort(sorted.begin(), sorted.end());\n  for(int i = 0; i < n; i++){\n    idx[ w[i] ] = i;\n  }\n\n  int ans = 0;\n  //swapping pairs are paired\n  for(int i = 0; i < n; i++){\n    if(w[i] == sorted[i]) continue;\n\n    /*\n    for(int l = 0; l < n; l++) cout << sorted[l] << \" \";\n    cout << endl;\n    */\n\n    int opposite = sorted[ idx[ sorted[i] ] ];\n    if(w[i] == opposite){\n      ans += w[i] + sorted[i];\n      swap(sorted[i], sorted[ idx[ sorted[i] ] ]);\n    }\n  }\n\n  vector<int> chk(w);\n  sort(chk.begin(), chk.end());\n  for(int i = n-1; i >= 0; i--){\n    //for(int l = 0; l < n; l++) cout << sorted[l] << \" \";\n    //cout << endl;\n    int v = chk[i];\n    int sortedind = -1;\n    for(int j = 0; j < n; j++){\n      if(sorted[j] == v){\n        sortedind = j;\n        break;\n      }\n    }\n    if(sortedind == idx[v]) continue;\n    ans += sorted[sortedind] + sorted[idx[v]];\n    swap(sorted[sortedind], sorted[idx[v]]);\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint A[MAX], n, s;\nint B[MAX], T[VMAX + 1];\n\nint solve() {\n    int ans = 0;\n\n    bool V[MAX];\n    for (int i = 0; i < n; i++) {\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B, B + n);\n    for (int i = 0; i < n; i++) {\n        T[B[i]] = i;\n    }\n    for (int i = 0; i < n; i++) {\n        if (V[i]) continue;\n        int cur = i;\n        int an = 0;\n        int S = 0;\n        int m = VMAX;\n        while (1) {\n            int v = A[cur];\n            V[cur] = true;\n            S += v;\n            an++;\n            m = min(m, v);\n            cur = T[A[cur]];\n            if (V[cur]) break;\n        }\n        ans += min(S + m + (an + 1) * s, S + (an - 2) * m);\n    }\n    return ans;\n}\n\n\nint main(int argc, char const *argv[])\n{\n    cin >> n;\n    s = VMAX;\n    for (int i = 0; i < n; i++) {\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n    int ans = solve();\n    cout << ans << endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nconst int MAX_W = 1000;\nusing namespace std;\n\nint s = MAX_W;\n\nint minCostSort(vector<int>& A) {\n    int ret = 0;\n\n    vector<bool> V(A.size());\n    vector<int> B = A;\n    vector<int> T(MAX_W+1);\n    for (auto i = 0; i < A.size(); i++) {\n        V[i] = false;\n    }\n    sort(B.begin(), B.end());\n    for (auto i = 0; i < A.size(); i++) {\n        T[B[i]] = i;\n    }\n\n    for (auto i = 0; i < A.size(); i++) {\n        if (V[i]) continue;\n\n        int cur = i;\n        int S = 0;\n        int m = MAX_W;\n        int an = 0;\n        while (1) {\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m, v);\n            S += v;\n            cur = T[v];\n            if (V[cur]) break;\n        }\n        ret += min(S + (an-2)*m, m + S + (an+1)*s);\n    }\n    return ret;\n}\n\nint main(void) {\n    int n;\n    cin >> n;\n\n    vector<int> W(n);\n    for (int i = 0; i < n; i++) {\n        cin >> W[i];\n        s = min(s, W[i]);\n    }\n\n    int ans = minCostSort(W);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n\n//?£wi + (n - 2) * min(wi)\n//or\n//?£wi + min(wi) + (n+1) * x\n\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint A[MAX];\nint B[MAX];\nbool V[MAX];\nint T[VMAX];\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint s = VMAX;\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &A[i]);\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t\ts = min(s, A[i]);\n\t\tT[A[i]] = i;\n\t}\n\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tT[B[i]] = i;\n\t}\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (V[i] == true) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\n\t\twhile (1) {\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif (V[cur] == true) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tans += min(S + (an - 2) * m, S + m + (an + 1) * s);\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstatic const int N_MAX=1000;\nstatic const int W_MAX=10000;\n\nint n; //??°???\nint A[N_MAX],B[N_MAX]; //A?????±?????°??????B?????????????\\?????????°???\nint s;//s?????¨?????°??????????°????\nint T[W_MAX+1]; //??\\??°????????????????\\?????????°???????????????\n\nint solve()\n{\n    int ans=0; //?????¬???\n    bool V[N_MAX]; //???????¢??????????\n    for(int i=0;i<n;i++)\n    {\n        B[i]=A[i]; //?????°????????¶??????\n        V[i]=false; //????§????\n    }\n    sort(B,B+n); //??????\n    for(int i=0;i<n;i++) T[B[i]]=i; //????§???????????????????????\\?????????°????????????\n    for(int i=0;i<n;i++)\n    {\n        if(V[i]) continue; //???????¢??????????????????????\n        int cur=i; //????????????\n        int S=0; //S??°???????????????????????????????????????\n        int m=W_MAX; //m?????¨?????°?????\\??????????????????????°????\n        int an=0; //an?????????????´???°???\n        while(1) //????§???????\n        {\n            V[cur]=true; //????§??????°\n            an++; //??°?????????\n            int v=A[cur]; //v?????????????????????\n            m=min(m,v); //??°????????????????°????\n            S+=v; //??\\???????????????????????????????????????????????????\n            cur=T[v]; //??????????????????????????????????????°???????????????\n            if(V[cur]) break; //????????????????????????????¢??????????????????\\?????????????????????????????¨??¨?¢???????\n        }\n        ans+=min(S+(an-2)*m,m+S+(an+1)*s);\n    }\n    return ans;\n}\nint main()\n{\n    cin>>n;\n    s=W_MAX;\n    for(int i=0;i<n;i++)\n    {\n        cin>>A[i];\n        s=min(s,A[i]);\n    }\n    cout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define N 40\n\nbool comp1(const pair<int, int> &a, const pair<int, int> &b)\n{\n    return a.first < b.first;\n}\nbool comp2(const pair<int, int> &a, const pair<int, int> &b)\n{\n    return a.second < b.second;\n}\nint main()\n{\n    int n;\n    cin >> n;\n    int w[n], x[n];\n    for (int i = 0; i < n; i++)\n    {\n        cin >> w[i];\n        x[i] = w[i];\n    }\n\n    sort(x, x + n);\n    int *p, *q;\n    int sum = 0, tmp;\n    for (int i = 0; i < n; i++)\n    {\n        p = find(w, w + n, x[i]);\n        while (i != p - w)\n        {\n            q = find(w, w + n, x[p - w]);\n            tmp = *p;\n            *p = *q;\n            *q = tmp;\n            sum += *p + *q;\n            p = q;\n        }\n    }\n\n    cout << sum << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate int[] a;\n\tprivate int[] b;\n\t\n\tprivate Scanner sc;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\tint lim = Integer.parseInt(sc.nextLine());\n\t\t\n\t\ta = new int[lim];\t\t\n\t\tb = new int[lim];\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\ta[i] = Integer.parseInt(sc.next());\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tArrays.sort(b);\n\t\t\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\tif (a[i] != b[i]) {\n\t\t\t\tfor (int j = (i + 1); j < lim; j++) {\n\t\t\t\t\tif ((a[j] == b[i]) && (a[i] == b[j])) {\n\t\t\t\t\t\ta[i] = b[i];\n\t\t\t\t\t\ta[j] = b[j];\n\t\t\t\t\t\t\n\t\t\t\t\t\tans = ans + a[i] + a[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.print(ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, a, b) for (int i = a; i < (int)(b); ++i)\n#define rrep(i, a, b) for (int i = b - 1; i >= (int)(a); --i)\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\n\nconstexpr int MAX_W = 100000;\n\nint main() {\n    int n;\n    cin >> n;\n\n    vi A(n), B(n), T(MAX_W + 1, -1);\n    int min_w = MAX_W;\n\n    rep(i, 0, n) {\n        cin >> A[i];\n        B[i] = A[i];\n        min_w = min(min_w, A[i]);\n    }\n\n    sort(A.begin(), A.end());\n\n    // Hash table to the original index.\n    rep(i, 0, n) {\n        T[A[i]] = i;\n    }\n\n    // A : dist_index -> val\n    // B : orig_index -> val\n    // T : val -> dist_index\n\n    vector<bool> seen(n, false);\n    int ans = 0;\n\n    rep(i, 0, n) {\n        if (seen[i]) { continue; }\n        seen[i] = true;\n\n        int v = i;\n        int n = 1;\n        ans += A[v];\n\n        while (true) {\n            int next_v = T[B[v]];\n\n            if (seen[next_v]) { break; }\n            seen[next_v] = true;\n\n            ++n;\n            ans += A[next_v];\n\n            v = next_v;\n        }\n\n        ans += min((n - 2) * A[i], A[i] + (n + 1) * min_w);\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nstatic const int MAX = 100000;\nstatic const int VMAX = 100000;\n\nint n,s,A[MAX];\nint B[MAX], T[VMAX];\n\nint solve()\n{\n\tint ans = 0;\n\tbool V[MAX];\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\n\tsort(B,B+n);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tT[B[i]] = i;\n\t}\n\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tif(V[i]==true) continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile(1)\n\t\t{\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m , v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif(V[cur]) break;\n\t\t}\n\t\tans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tcin>>n;\n\ts = VMAX;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tcin>>A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tint ans = solve();\n\tcout<<ans<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<queue>\n#include<vector>\n\n#define MAX 1000\n#define INF 100000\n\nusing namespace std;\n\n//[0] = id, [1] = cost\nint A[MAX][2],SortedA[MAX][2],NumT[MAX];\nbool comp[MAX] = {};\nvector<int> Typelist[MAX];\nint MIN = INF;\n\nvoid sorts(int n){\n    priority_queue<pair<int, int> > PQ;\n    for (int i = 0; i < n; i++) {\n        PQ.push(make_pair(-1*A[i][1], A[i][0]));\n    }\n    for (int i = 0; i < n; i++) {\n        SortedA[i][0] = PQ.top().second;\n        SortedA[i][1] = (-1)*PQ.top().first;\n        PQ.pop();\n    }\n}\n\nvoid trace(int i,int type){\n    while (!comp[i]) {\n        comp[i] = true;\n        Typelist[type-1].push_back(i);\n        i = SortedA[i][0];\n    }\n}\n\nint makeType(int n){\n    int type = 0;\n    for (int i = 0; i < n; i++) {\n        if (!comp[i]) {\n            type++;\n            trace(i,type);\n        }\n    }\n    return type;\n}\n\nint rec(int type){\n    if (Typelist[type].size() == 1) return 0;\n    if (Typelist[type].size() == 2) {\n        return A[Typelist[type][0]][1] + A[Typelist[type][1]][1];\n    }\n    int minc = INF,sum = 0;\n    int n = Typelist[type].size();\n    for (int i = 0; i < n; i++) {\n        sum += A[Typelist[type][i]][1];\n        if (minc > A[Typelist[type][i]][1]) minc = A[Typelist[type][i]][1];\n    }\n    sum -= minc;\n    return sum + min((n-1)*minc, (n-1)*MIN+2*(MIN+minc));\n}\n\nint main(){\n    int N,NofT;\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\",&A[i][1]);\n        A[i][0] = i;\n        if (MIN > A[i][1]) MIN = A[i][1];\n    }\n    sorts(N);\n    NofT = makeType(N);\n    \n    int cost = 0;\n    \n    for (int i = 0; i < NofT; i++) {\n        cost += rec(i);\n    }\n    \n    printf(\"cost = %d\\n\",cost);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int> W(n);\n    for (auto& w : W) cin >> w;\n\n    vector<int> Ws = W;\n    sort(Ws.begin(), Ws.end());\n\n    int cost = 0;\n    int left = 0;\n    while (left < n - 1) {\n        int min_i = min_element(W.begin() + left, W.end()) - W.begin();\n        int cnt = 0;\n        while (1) {\n            int tgt_i = find(W.begin() + left, W.end(), Ws[min_i])\n                        - W.begin();\n            if (tgt_i == min_i) break;\n            cost += W[min_i] + W[tgt_i];\n            swap(W[min_i], W[tgt_i]);\n            cnt++;\n            min_i = tgt_i;\n        }\n        int compare = cnt * W[min_i] - 2 * (W[min_i] + Ws[0]) - cnt * Ws[0];\n        if (compare > 0) cost -= compare;\n        left++;\n    }\n    cout << cost << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint N;\nint W[1111];\nint U[1111];\nint R[1111];\nint T[1111];\n\nvoid view(){\n  for(int i=0;i<N;i++) cout << U[i] << \" \";\n  cout << endl;\n}\n\nint main(){\n  cin >> N;  \n  for(int i=0;i<N;i++){\n    cin >> U[i];\n    W[i] = U[i];\n    T[U[i]] = i;\n  }\n  sort(W,W+N);\n  for(int i=0;i<N;i++){\n    R[W[i]]=i;\n  }\n  int res = 0;\n  for(int i=0;i<N;i++){\n    if( W[i] == U[i] ) continue;\n    int id = T[W[i]];\n    int nd = T[W[id]];\n    while( U[id] != U[nd] ){\n      swap(U[id],U[nd]);\n\n      //      cout << id << \" - \" << nd << endl;\n      //view();\n      \n      T[U[id]] = id;\n      T[U[nd]] = nd;\n      res += U[id] + U[nd];\n      id = nd;\n      nd = T[W[id]];\n    }\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <climits>\nusing namespace  std;\n\nstruct StCst\n{\n  int m_nNo;\n  int m_nSeq;\n  bool m_bDone;\n\n  static bool AsdNo(const StCst &cnroLeft, const StCst &cnroRight) \n  { return cnroLeft.m_nNo < cnroRight.m_nNo; }\n};\n\nvoid fnInput(vector<StCst> &rvoSort)\n{\n  int nMaxSiz, nCnt = 0;\n  cin >> nMaxSiz;\n\n  rvoSort.resize(nMaxSiz);\n  for (int i = 0; i < nMaxSiz; i++)\n  {\n    cin >> rvoSort[i].m_nNo;\n    rvoSort[i].m_nSeq = nCnt++;\n  }\n}\n\nvoid fnMinCostSort(vector<StCst> &rvoSort, int &rnSwpCnt)\n{\n  sort(begin(rvoSort), end(rvoSort), StCst::AsdNo);\n  int nMinNo = rvoSort[0].m_nNo;\n\n  int nCost;\n  for (int i = 0; i < rvoSort.size(); i++)\n  {\n    if (rvoSort[i].m_bDone)  continue;\n\n    int nTotal = rvoSort[i].m_nNo;\n    int nCurSize = 1;\n    int nCurMin = rvoSort[i].m_nNo; \n    rvoSort[i].m_bDone = true;\n\n    int j = rvoSort[i].m_nSeq;\n    while  (rvoSort[j].m_nNo != rvoSort[i].m_nNo)\n    {\n      nTotal += rvoSort[j].m_nNo;\n      nCurSize++;\n      nCurMin = min(nCurMin, rvoSort[j].m_nNo);\n      rvoSort[j].m_bDone = true;\n      j = rvoSort[j].m_nSeq;\n    }\n\n    if (nCurSize == 1)\n        nCost = 0;\n    else\n        nCost = min(nTotal + (nCurSize - 2) * nCurMin, \n                    nTotal + nCurMin + (nCurSize + 1) * nMinNo);\n    rnSwpCnt += nCost;\n  }\n}\n\nvoid fnResult(int nSwpCnt)\n{\n  cout << nSwpCnt << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vector<StCst> voSort;\n\n  fnInput(voSort);\n\n  int nSwpCnt = 0;\n  fnMinCostSort(voSort, nSwpCnt);\n\n  fnResult(nSwpCnt);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint Min(int a, int b){\n    return a>b?b:a;\n}\n void bubble_sort(int a[], int n)\n { \n    int res = 0; \n    for(int i = 0; i<n; i++){ \n        for(int j=n-1; j>=i+1;j--){ \n            if(a[j] < a[j-1]) { \n                int temp = a[j]; \n                a[j] = a[j-1]; \n                a[j-1] = temp; \n                res++; \n                \n            } \n            \n        } \n        \n    }\n }\n int find(int a[], int b[], int i, int n){\n     for(int k = 0; k < n; k++){\n         if(a[i] == b[k]) return k;\n     }\n     \n }\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    int a[n+1];\n    int b[n];\n    int v[n+1];\n    for(int i = 0; i<n; i++){\n        scanf(\"%d\",&a[i]);\n        b[i] = a[i];\n        v[i] = 0;\n    }\n    bubble_sort(b,n);\n    int total_cost = 0;\n    int min = 10005;\n    for(int i = 0; i<n; i++){\n        if(min>a[i]) min = a[i];\n        int cost = 0;\n        int length = 0;\n        int min_cycle = 10005;\n        if(v[i] == 1) continue;\n        int temp = i;\n        if(a[i] == b[i]) continue;\n        while(a[temp]!=b[i]){\n            v[temp] = 1;\n            length++;\n            cost+=a[temp];\n            if(min_cycle>a[temp]) min_cycle = a[temp];\n            temp = find(a,b,temp,n);\n            \n        }\n        v[temp] = 1;\n        length++;\n        cost+=a[temp];\n        if(min_cycle>a[temp]) min_cycle = a[temp];\n        //printf(\"min:%d\\n\",min);\n        //printf(\"min_cycle:%d\\n\",min_cycle);\n        if(length>2)\n        {cost = cost+Min((length-2)*min_cycle, min_cycle+min*(length+1));}\n        total_cost += cost;\n        if(min>min_cycle) min = min_cycle;\n        \n    }\n    printf(\"%d\\n\",total_cost);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define MAX 200000\n#define SENTINEL 2000000000\ntypedef long long llong;\n\nint L[MAX / 2 + 2], R[MAX / 2 + 2];\n\nllong merge (int A[], int n, int left, int mid, int right){\n  int i, j, k;\n  llong cnt = 0;\n  int n1 = mid -left;\n  int n2 = right -mid;\n  for (int i = 0; i < n1; ++i) L[i] = A[left +1];\n  for (int i = 0; i < n2; ++i) R[i] = A[left +1];\n  L[n1] = R[n2] = SENTINEL;\n  i = j = 0;\n  for (int k = 0; k < right; ++k)\n   {\n     if(L[i] <= R[j]){\n      A[k] = L[i++];\n     }else{\n      A[k] =R[j++];\n      cnt += n1 - i ; \n     }\n   } \n\nreturn cnt;\n\n\n}\n\nllong mergeSort(int A[],int n, int left, int right){\n\n  int mid;\n  llong v1, v2, v3;\n  if( left + 1 < right ){\n    mid =(left +right)/2;\n    v1 =mergeSort(A,n,left,mid);\n    v2 =mergeSort(A,n,mid,right);\n    v3 =merge(A,n,left,mid, right);\n    return v1 +v2 +v3;\n  }else return 0;\n\n}\n\nint main(){\n  int A[MAX], n, i;\n\n  cin >> n;\n  for (int i = 0; i < n; ++i)\n  {\n    cin >> A[i];\n  }\n\n  llong ans = mergeSort(A,n,0,n);\n  cout << ans << endl;\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n//#include \"libs.h\"\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n//#include <opencv2/core.hpp>\n//#include <opencv2/highgui.hpp>\n//#include <opencv2/imgproc.hpp>\n\nusing namespace std;\n\n//呪文\n#define DUMPOUT cerr\n#define dump(...) DUMPOUT<<\"  \";DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl;DUMPOUT<<\"    \";dump_func(__VA_ARGS__)\n\ntypedef unsigned uint; typedef long long ll; typedef unsigned long long ull; typedef pair<int, int> pii; typedef pair<ll, ll> pll; typedef pair<double, double> pdd; typedef pair<string, string> pss;\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const pair<_KTy, _Ty>& m) { o << \"{\" << m.first << \", \" << m.second << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const unordered_map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const vector<_Ty>& v) { if (v.empty()) { o << \"{ }\"; return o; } o << \"{\" << v.front(); for (auto itr = ++v.begin(); itr != v.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const unordered_set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; }\to << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const stack<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } stack<_Ty> t(s); o << \"{\" << t.top(); t.pop(); while (!t.empty()) { o << \", \" << t.top(); t.pop(); } o << \"}\";\treturn o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const list<_Ty>& l) { if (l.empty()) { o << \"{ }\"; return o; } o << \"{\" << l.front(); for (auto itr = ++l.begin(); itr != l.end(); ++itr) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> istream& operator >> (istream& is, pair<_KTy, _Ty>& m) { is >> m.first >> m.second; return is; }\ntemplate <typename _Ty> istream& operator >> (istream& is, vector<_Ty>& v) { for (size_t i = 0; i < v.size(); i++) is >> v[i]; return is; }\nnamespace aux { // print tuple\n\ttemplate<typename Ty, unsigned N, unsigned L> struct tp { static void print(ostream& os, const Ty& v) { os << get<N>(v) << \", \"; tp<Ty, N + 1, L>::print(os, v); } };\n\ttemplate<typename Ty, unsigned N> struct tp<Ty, N, N> { static void print(ostream& os, const Ty& v) { os << get<N>(v); } };\n}\ntemplate<typename... Tys> ostream& operator<<(ostream& os, const tuple<Tys...>& t) { os << \"{\"; aux::tp<tuple<Tys...>, 0, sizeof...(Tys)-1>::print(os, t); os << \"}\"; return os; }\n\ntemplate<typename A, size_t N, typename T> inline void Fill(A(&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\n\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) { DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(std::move(tail)...); }\n\n#define PI 3.14159265358979323846\n#define EPS 1e-10\n#define FOR(is,a,n) for(int is=(a);is<(n);++is)\n#define REP(is,n)  FOR(is,0,n)\n#define all(j) (j).begin(), (j).end()\n#define SZ(j) ((int)(j).size())\n#define fake false\n\n\n\nint main() {\n\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\tvector<int> w(n);\n\tcin >> w;\n\n\tvector<pii> wpos(n);\n\tfor (int i = 0; i < n; i++) {\n\t\twpos[i].first = w[i];\n\t\twpos[i].second = i;\n\t}\n\tsort(all(wpos));\n\n\tmap<int, int> mp;\n\tfor (int i = 0; i < n; i++)\n\t\tmp[wpos[i].second] = i;\n\n\tvector<bool> used(n, false);\n\tvector<vector<int>> cycles;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (used[i])\n\t\t\tcontinue;\n\t\tvector<int> cycle;\n\t\tint j = i;\n\t\twhile (!used[j]) {\n\t\t\tcycle.push_back(w[j]);\n\t\t\tused[j] = true;\n\t\t\tj = mp[j];\n\t\t}\n\t\tcycles.push_back(cycle);\n\t}\n\n\tvector<int> cycles_min(cycles.size());\n\tfor (int i = 0; i < cycles.size(); i++)\n\t\tcycles_min[i] = *min_element(all(cycles[i]));\n\n\tint min_w = *min_element(all(w));\n\n\tint cost = 0;\n\tfor (int i = 0; i < cycles.size(); i++) {\n\t\tint c1 = accumulate(all(cycles[i]), 0) + (cycles[i].size() - 2) * cycles_min[i];\n\t\tint c2 = (min_w + cycles_min[i]) * 2 + (cycles[i].size() - 1) * min_w + accumulate(all(cycles[i]), 0) - cycles_min[i];\n\t\tcost += min(c1, c2);\n\t}\n\n\tcout << cost << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 12:41\n//\n\n// w[0], w[1], ..., w[n-1]\n// ex. 9 7 6 1\n//  -> 1 6 7 9 \n//\n\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nusing ll = long long;\n\nstruct Value {\n\tll v;\n\tll idx;\n};\n\nclass lesserValue{\npublic:\n\tbool operator()(const Value &x, const Value &y) {\n\t\treturn x.v < y.v;\n\t}\n};\n\nvoid print(const vector<Value> &x) {\n\tfor (ll i=0;i<x.size();++i) {\n\t\tif (i!=0) cout << \" \";\n\t\tcout << x[i].v << \",\" << x[i].idx;\n\t}\n\tcout << endl;\n}\n\nint main() {\n\tll n;\n\tcin >> n;\n\tvector<Value> w(n);\n\tfor (ll i=0;i<n;++i) {\n\t\tscanf(\"%lld\", &w[i].v);\n\t\tw[i].idx = i;\n\t}\n\t//print(w);\n\tvector<Value> orig(w);\n\t//print(orig);\n\t// sort by ascending order\n\tsort(w.begin(), w.end(), lesserValue()); \n\t//print(w);\n\tll ans = 0;\n\tfor (ll i=0;i<n;++i) {\n\t\tif (w[i].idx == i) continue;\n\t\tans += orig[i].v + w[i].v;\n\t}\n\tans /= 2;\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nvoid show( int arr[], size_t size )\n{\n\n\tcout<<arr[0]<<flush;\n    for( size_t i=1; i<size; i++ ){\n\t    cout<<' '<<arr[i]<<flush;\n    }\n    cout<<endl;\n}\n\nint selectionSort(int* arr, size_t arr_s){\n\n\tsize_t imin,cost=0;\n\tfor(size_t i=0; i<arr_s-1; i++) {\n\t\timin=i;\n\n\t\tfor(size_t j=i+1; j<arr_s; j++) {\n\n\t\t\timin= (arr[imin] > arr[j])? j : imin;\n\n\t\t}\n\n\t\tif(imin != i){\n\t\t\tswap( arr[imin], arr[i] );\n\t\t\tcost+= arr[imin] + arr[i];\n\t\t}\n\t}\n\treturn cost;\n}\n\nint main()\n{\n\tsize_t arr_s;cin>>arr_s;\n\tint *arr=new int[arr_s];\n\tfor( size_t i=0; i<arr_s; i++ ){\n\t\tcin>>arr[i];\n\t}\n\n\tlong long minCost=selectionSort(arr, arr_s);\n//\tshow(arr, arr_s);\n\tcout<<minCost<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n\n  long long int n;\n  cin >> n;\n\n  vector< long long int > v, vs;\n\n  for ( long long int i = 0; i < n; i++ ) {\n\n    long long int in;\n    cin >> in;\n    v.push_back( in );\n    vs.push_back( in );\n\n  }\n\n  sort( vs.begin(), vs.end() );\n\n  vector< long long int > t;\n\n  for ( long long int i = 0; i < n; i++ ) {\n    for ( long long int j = 0; j < n; j++ ) {\n      if ( v[i] == vs[j] ) {\n\tt.push_back( j );\n\tbreak;\n      }\n    }\n  }\n\n  long long int ans = 0;\n  long long int c = -1;\n  long long int m = 0;\n\n  for ( long long int i = 0; i < n; i++ ) {\n\n    for ( long long int j = 0; j < n; j++ ) {\n\n      if ( vs[j] != v[j] ) {\n\n\tlong long int k = v[j] + v[ t[j] ];\n\tif ( c == -1 || m > k ) {\n\t  c = j;\n\t  m = k;\n\t}\n\n      }\n\n    }\n\n    if ( c == -1 ) break;\n\n    ans += v[c] + v[ t[c] ];\n    swap( v[c], v[ t[c] ] );\n    swap( t[c], t[ t[c] ] );\n    c = -1;\n\n  }\n\n  cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <map>\n#include <memory>\n#include <set>\n#include <vector>\n#include <deque>\n#include <list>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\nclass MinCostSort\n{\npublic:\n  int w[1000];\n  int sw[1000];\n  int solve();\n};\n\nint MinCostSort::solve()\n{\n  int cost = 0;\n  int n;\n  cin >> n;\n  \n  for ( int i = 0; i < n; ++i )\n    {\n      cin >> w[i];\n      sw[i] = w[i];\n    }\n\n  sort( sw, sw + n );\n\n  int j, k;\n  \n  for ( int i = 0; i < n; ++i )\n    {\n      while ( true )\n        {\n          for ( j = 0; j < n; ++j )\n            {\n              if ( sw[i] == w[j] )\n                break;\n            }\n          for ( k = 0; k < n; ++k )\n            {\n              if ( sw[j] == w[k] )\n                break;\n            }\n          \n          if ( j == k )\n            break;\n          else\n            {\n              cost += (w[j] + w[k]);\n              swap( w[j], w[k] );\n            }\n        }\n    }\n  \n  cout << cost << endl;\n  \n  return 0;\n}\n\nint main()\n{\n\n  MinCostSort mcs;\n\n  mcs.solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n\nint cost=0;\n\nint SortCost(int A[], int n,int min)\n{\n\tint i;\n\tfor(i=0;i<=n-1;i++)\n\t{\n\t\tif(A[i]!=min) cost+=A[i]+min;\n\t}\n}\n\nint partition(int A[], int p, int r)\n{\n\tint i,j;\n\tint x,temp;\n\t\n\tx=A[r];\n\ti=p-1;\n\tfor(j=p;j<=r-1;j++)\n\t{\n\t\tif(A[j]<=x)\n\t\t{\n\t\t\ti++;\n\t\t\ttemp=A[j];\n\t\t\tA[j]=A[i];\n\t\t\tA[i]=temp;\n\t\t}\n\t}\n\ttemp=A[r];\n\tA[r]=A[i+1];\n\tA[i+1]=temp;\n\treturn i+1;\n}\n\nint quickSort(int A[], int p, int r)\n{\n\tint q;\n\t\n\tif(p<r)\n\t{\n\t\tq=partition(A,p,r);\n\t\tquickSort(A,p,q-1);\n\t\tquickSort(A,q+1,r);\n\t}\n}\n\nint bs (int A[], int n, int c) \n {\n    int j,k,l;\n    j=0;\n    k=n-1;\n    while(1)\n    {\n        if(j<=k)\n        {\n            l=(j+k)/2;\n            if(A[l] > c)\n            {\n                k=l-1;\n            }\n            else if(A[l] < c)\n            {\n                j=l+1;\n            }\n            else\n            {\n                return l;\n            }\n        }\n    }\n}\n\n\nint main()\n{\n\tint i,j,n,k;\n\tint A[1000];\n\tint B[1000];\n\tint S[1000];\n\tint a[1000];\n\t\n\tscanf(\"%d\",&n);\n\t\n\tfor(i=0;i<=n-1;i++) \n\t{\n\t\tscanf(\"%d\",&A[i]);\n\t\tS[i]=A[i];\n\t\ta[i]=0;\n\t}\n\t\n\tquickSort(S,0,n-1);\n\t\n\tfor(i=0;i<=n-1;i++)\n\t{\n\t\tj=0;\n\t\tif(a[i]==0 && A[i]!=S[i])\n\t\t{\n\t\t\tB[j]=A[i];\n\t\t\tj++;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tk=bs(S,n,B[j-1]);\n\t\t\t\tB[j]=A[k];\n\t\t\t\ta[k]=1;\n\t\t\t\tj++;\n\t\t\t} while(B[j-1]!=B[0]);\n\t\t\tSortCost(B,j-1,S[i]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",cost);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nconst char dir[4] = { 'u','l','d','r' };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        (wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nint n;\nint w[1010];\nvector<pair<int, int>> v;\nvector<int> G[1010];\nbool used[1010];\nint main() {\n\tcin >> n;\n\tint minl = INF<int>();\n\tREP(i, n) {\n\t\tcin >> w[i];\n\t\tminl = min(minl, w[i]);\n\t}\n\tREP(i, n) {\n\t\tv.emplace_back(w[i], i);\n\t}\n\tsort(ALL(v));\n\tREP(i, n) {\n\t\tG[v[i].second].emplace_back(i);\n\t}\n\tqueue<int> q;\n\tint sum = 0;\n\tint cnt = 0;\n\tLL ans = 0;\n\tint minll = INF<int>();\n\tREP(i, n) {\n\t\tif (!used[i])q.push(i);\n\t\twhile (!q.empty()) {\n\t\t\tint cur = q.front();\n\t\t\tq.pop();\n\t\t\tused[cur] = true;\n\t\t\tsum += v[cur].first;\n\t\t\tminll = min(minll, v[cur].first);\n\t\t\tcnt++;\n\t\t\tif (!used[G[cur][0]])q.push(G[cur][0]);\n\t\t\telse {\n\t\t\t\tans += min(sum + (cnt - 2)*minll, sum + minl*(cnt + 1));\n\t\t\t\tsum = 0;\n\t\t\t\tcnt = 0;\n\t\t\t\tminll = INF<int>();\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<algorithm>\n#include<iostream>\n#include<map>\n#include<vector>\nint main(void) {\n\tstd::ios_base::sync_with_stdio(false);\n\tint n, input;\n\tstd::cin >> n;\n\tstd::map<int, int>w;\n\tstd::vector<int>vector(n);\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tstd::cin >> input;\n\t\tw[input - 1] = i;\n\t\tvector[i] = input-1;\n\t}\n\tstd::vector<int>vector_min= vector;\n\tstd::map<int, int>w_1(w);\n\tstd::sort(vector_min.begin(), vector_min.end());\n\tfor (int i = 0; i < n; ++i) {\n\t\tw[vector[i]] = vector_min[i];\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint temp = 0;\n\t\twhile (vector_min[i] != w[vector_min[i]]) {\n\t\t\ttemp += vector_min[i] + w[vector_min[i]] + 2;\n\t\t\tstd::swap(w[vector_min[i]],w[w[vector_min[i]]] );\n\t\t}\n\t\tint temp_1 = 0;\n\t\tif (vector_min[i] != w_1[vector_min[i]]) {\n\t\t\ttemp_1 +=  w_1[vector_min[i]]+ w_1[vector_min[0]] + 2;\n\t\t\tstd::swap(w_1[vector_min[0]], w_1[vector_min[i]]);\n\t\t\twhile (vector_min[0] !=w_1[vector_min[i]]) {\n\t\t\t\ttemp_1 += w_1[vector_min[i]]+ w_1[vector_min[0]] + 2;\n\t\t\t\tstd::swap(w_1[vector_min[0]], w_1[w_1[vector_min[i]]]); }\n\t\t}\n\t\tcnt += std::min(temp, temp_1);\n\t}\n\tstd::cout << cnt << std::endl;\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define MAX 1000\n#define VMAX 10000\n\nint A[MAX], n, m, ans;\nint B[MAX], T[VMAX + 1];\n\nvoid solve(){\n    bool V[MAX];\n    ans = 0;\n    \n    sort(B, B+n);\n    for(int i = 0; i < n; i++){\n        T[B[i]] = i;\n        V[i] = false;\n    }\n    for(int i = 0; i < n; i++){\n        if(V[i]) continue;\n        int cur = i;\n        int s = VMAX;\n        int sum = 0;\n        int num_men = 0;\n        while(1){\n            V[cur] = true;\n            num_men++;\n            sum += A[cur];\n            s = min(A[cur], s);\n            cur = T[A[cur]];\n            if(V[cur]) break;\n        }\n        \n        ans += min((sum + (num_men -  2) * s), (sum + s + (num_men + 1) * m));\n    }\n}\n\nint main(void){\n    cin >> n;\n    m = VMAX;\n    \n    for(int i = 0; i < n; i++){\n        cin >> A[i];\n        B[i] = A[i];\n        m = min(m, A[i]);\n    }\n    \n    solve();\n    \n    cout << ans << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\nusing namespace std;\nstatic const int MAX = 200000;\n\nvoid trace(int data[], int n) {\n  cout << data[0];\n  for (int i = 1; i < n; i++) {\n    //cout << \" \" << data[i];\n    printf(\"%2d \", data[i]);\n  }\n  cout << endl;\n}\n\nint bsearch(int data[], int target, int left, int right) {\n  // target in [left, ... ,right]\n  int mid;\n  while (left <= right) {\n    mid = (left + right) / 2;\n    if (data[mid] == target) {\n      return mid;\n    } else if (data[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  return -1;\n}\n\nint main() {\n  int n;\n  int data[MAX];\n  int sorted[MAX];\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> data[i];\n    sorted[i] = data[i];\n  }\n  sort(sorted, sorted + n);\n  int total = 0;\n  for (int i = 0; i < n; i++) {\n    int ans = sorted[i];\n    int x = data[i];\n    if (ans == x)\n      continue;\n\n    int count = 0;\n    int min = x;\n    int sum = x;\n    while (ans != x) {\n      int j = bsearch(sorted, x, 0, n - 1);\n      swap(x, data[j]);\n      sum += x;\n      if (x < min)\n        min = x;\n      count++;\n    }\n    data[i] = x;\n    total += sum + (count - 1) * min;\n  }\n\n  cout << total << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main(void) {\n\tint num;\n\tcin >> num;\n\tvector<int> a(num);\n\tvector<int> sorted(num);\n\tint pos[1000];\n\tint order[1000];\n\tint cost = 0;\n\n\tfor (int i = 0; i < num; i++) {\n\t\tcin >> a[i];\n\t}\n\n\tfor (int i = 0; i < num; i++)\n\t\tsorted[i] = a[i];\n\tsort(sorted.begin(), sorted.begin() + num);\n\tfor (int i = 0; i < num; i++)\n\t\tpos[sorted[i]] = i;\n\n\tfor (int i = 0; i < num; i++) {\n\t\tint x = order[0] = i;\n\t\tint minn = 1000;\n\t\tint start = 0;\n\n\t\tif (i == pos[a[i]])\n\t\t\tcontinue;\n\n\t\tfor (int j = 1;; j++) {\n\t\t\tx = pos[a[x]];\n\t\t\tif (x == i)\n\t\t\t\tbreak;\n\t\t\tif (a[x] < minn) {\n\t\t\t\tminn = a[x];\n\t\t\t\tstart = j;\n\t\t\t}\n\t\t\torder[j] = x;\n\t\t}\n\n\t\tfor (int j = start - 1; j >= 0; j--) {\n\t\t\tcost += (minn + a[order[j]]);\n\t\t\ta[order[j + 1]] = a[order[j]];\n\t\t\ta[order[j]] = minn;\n\t\t}\n\t}\n\n\tcout << cost << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nstatic const int MAX=1000;\nstatic const int VMAX=10000;\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve(){\n\tint ans=0;\n\tbool V[MAX];\n\tfor (int i = 0; i < n; ++i) {\n\t\tB[i]=A[i];\n\t\tV[i]=false;\n\t}\n\tsort(B,B+n);\n\tfor (int i = 0; i < n; ++i) {T[B[i]]=i;\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tif(V[i])continue;\n\t\tint cur=i;\n\t\tint S=0;\n\t\tint m=VMAX;\n\t\tint an=0;\n\t\twhile(1){\n\t\t\tV[cur]=true;\n\t\t\tan++;\n\t\t\tint v=A[cur];\n\t\t\tm=min(m,v);\n\t\t\tS+=v;\n\t\t\tcur=T[v];\n\t\t\tif(V[cur])break;\n\t\t}\n\t\tans+=min(S+(an-2)*m,m+S+(an+1)*s);\n\t}\n\treturn ans;\n}\n\n\n\n\nint main(){\n\tcin>>n;\n\ts=VMAX;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin>>A[i];\n\t\ts=min(s,A[i]);\n\t}\n\tint ans =solve();\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nstruct unionfind\n{\n\t//rankのオーバーフローに注意\n\tvector<int> par, rank;\n\tunionfind(int n)\n\t{\n\t\tpar.resize(n);\n\t\trank.resize(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 1;\n\t\t}\n\t}\n\n\tbool same(int u, int v)\n\t{\n\t\treturn root(u) == root(v);\n\t}\n\n\tvoid unite(int u, int v)\n\t{\n\t\tif (same(u, v)) return;\n\t\tu = root(u), v = root(v);\n\t\tif (rank[u] > rank[v]) swap(u, v);\n\t\tpar[u] = v;\n\t\trank[v] += rank[u];\n\t}\n\n\tint root(int v)\n\t{\n\t\tif (par[v] == v) return v;\n\t\treturn par[v] = root(par[v]);\n\t}\n};\n\nvoid solve()\n{\n\tint N;\n\tcin >> N;\n\tvector<int> ws(N), cs(N);\n\tset<int> s;\n\tmap<int, int> mp;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> ws[i];\n\t\ts.insert(ws[i]);\n\t}\n\tint cnt = 0;\n\tfor (int v : s)\n\t{\n\t\tmp[v] = cnt++;\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcs[i] = mp[ws[i]];\n\t}\n\n\tunionfind uf(N);\n\tvector<int> es[N];\n\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tuf.unite(i, cs[i]);\n\t}\n\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tes[uf.root(cs[i])].push_back(cs[i]);\n\t}\n\n\tint ans = 0;\n\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tauto e = es[i];\n\t\tint n = e.size(), x = INT_MAX;\n\t\tif (n < 2) continue;\n\t\tfor (int v : e)\n\t\t{\n\t\t\tans += ws[v];\n\t\t\tx = min(ws[v], x);\n\t\t}\n\t\tans += (n-2) * x;\n\t}\n\n\tcout << ans << endl;\n\n}\n\nint main(void)\n{\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s,B[MAX],T[VMAX+1];\n\nint solve(){\n  int ans = 0;\n\n  bool V[MAX];\n  for(int i=0;i<n;i++){\n    B[i] = A[i];\n    V[i] = false;\n  }\n  sort(B,B+n);\n  for(int i=0;i<n;i++) T[B[i]] = i;\n  for(int i=0;i<n;i++){\n    if(V[i]) continue;\n    int cur = i;\n    int S = 0;\n    int m = VMAX;\n    int an = 0;\n    while(1){\n      V[cur] = true;\n      an++;\n      int v = A[cur];\n      m = min(m,v);\n      S += v;\n      cur = T[v];\n      if(V[cur]) break;\n    }\n    ans += min(S + (an - 2)*m,m + S + (an + 1)*s);\n  }\n\n  return ans;\n}\n\nint main(){\n  cin >> n;\n  s = VMAX;\n  for(int i=0;i<n;i++){\n    cin >> A[i];\n    s = min(s,A[i]);\n  }\n  int ans = solve();\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int INF = 1000000;\n\nstruct node\n{\n\tint num;\n\tint place;  \n};\n\nint partition(node *A,int p,int r)\n{\n\tint j,temp;\n\tnode x;\n\n\tx = A[r];\n\tj = p-1;\n\n\tfor(int i = p; i < r; i++)\n\t{\n\t\tif (A[i].num <= x.num)\n\t\t{\n\t\t\tj++;\n\t\t\ttemp = A[i].num;\n\t\t\tA[i].num = A[j].num;\n\t\t\tA[j].num = temp;\n\t\t}\n\t}\n\n\ttemp = A[j+1].num;\n\tA[j+1].num = A[r].num;\n\tA[r].num = temp;\n\n\treturn j+1;\n}\n\nvoid quicksort(node *A,int p,int r)\n{\n\tint q;\n\n\tif (p < r)\n\t{\n\t\tq = partition(A,p,r);\n\t\tquicksort(A,p,q-1);\n\t\tquicksort(A,q+1,r);\n\t}\n}\n\n\nint main()\n{\n\tint n,sum,minall,mini,sol,cnt,j;\n\tnode a[1000] = {0},b[1000] = {0};\n\n\tsol = 0;\n\tminall = INF;\n\n\tscanf(\"%d\", &n);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i].num);\n\t\ta[i].place = i;\n\t\tb[i] = a[i];\n\t\tb[i].place = i;\n\n\t\tif (minall > a[i].num)\n\t\t{\n\t\t\tminall = a[i].num;\n\t\t}\n\t}\n\n\t//cout << \"minall = \" << minall << endl;\n\n\tquicksort(b,0,n-1);\n\n\t/*for(int i = 0; i < n; i++)\n\t{\n\t\tcout << b[i].num << \" \";\n\t}\n\n\tcout << endl <<endl;\n*/\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tsum = 0;\n\n\t\tif (a[i].num >= 0)\n\t\t{\n\t\t\tsum += a[i].num;\n\t\t\tmini = a[i].num;\n\t\t\tcnt = 1;\n\t\t\tj = i;\n\n\t\t\twhile(b[a[j].place].num != a[i].num)\n\t\t\t{\n\t\t\t\tfor(int k = 0; k < n; k++)\n\t\t\t\t{\n\t\t\t\t\tif (a[k].num == b[a[j].place].num)\n\t\t\t\t\t{\n\t\t\t\t\t\tj = k;\n\t\t\t\t\t\tsum += a[k].num;\n\t\t\t\t\t\t//cout << \" sum =\" <<sum << endl;\n\t\t\t\t\t\tcnt++;\n\n\t\t\t\t\t\tif (mini > a[k].num)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmini = a[k].num;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ta[k].num = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\ta[i].num = -1;\n\n\t\t\tsol += min(sum + mini * (cnt -2), sum + mini + (cnt + 1) * minall);\n\n\t\t\t//cout << \"sum1=\" << sum + mini * (cnt -2)  << \"  sum2=\" << sum + mini + (cnt + 1) * minall << endl;\n\n\t\t\t/*for(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tcout << a[i].num << \" \";\n\t\t\t}\n\t\t\tcout << \"sol=\" << sol << \" \" << \"cnt=\" <<cnt << \" mini=\" << mini;\n\t\t\tcout << endl <<endl;*/\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", sol);\n\n\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint n, w[1010], a[1010], b[10010] = {}, mi=100000;\nbool used[1010];\n\n//sorting\nint partition(int *A, int p, int r){\n  int x = A[r];\n  int i = p - 1;\n    for(int j = p;j < r;j++){\n      if(A[j] <= x){\n        i++;\n        swap(A[i], A[j]);\n      }\n    }\n    swap(A[i + 1], A[r]);\n  return i + 1;\n}\n\nvoid quicksort(int *A, int p, int r){\n  if(p < r){\n    int q = partition(A, p, r);\n    quicksort(A, p, q - 1);\n    quicksort(A, q + 1, r);\n  }\n}\n\nint solve(){\n  \n  int ans = 0; //answer\n  \n  quicksort(a, 0, n - 1); //sorting\n  for(int i = 0;i < n;i++) b[a[i]] = i; //record a position\n  \n  for(int i = 0;i < n;i++){\n    int cnt = 0, sum = 0, now = i, mimi = 100000;\n    \n    if(used[i]) continue; //if i is already used, continue\n    \n    while(true){\n      if(used[now]) break; //if now is already used, break\n      cnt++; //count up\n      used[now] = true; //now is used\n      mimi = min(mimi, w[now]); //minimun weight in cyclic group\n      sum += w[now]; //add a weight to sum\n      now = b[w[now]]; //update now\n    }\n    \n    ans += min(sum + (cnt - 2) * mimi, sum + mimi + (cnt + 1) * mi); //add minimum cost to ans variable\n  }\n  \n  return ans;\n}\n\nint main(){\n\n  //input\n  cin >> n;\n  for(int i = 0;i < n;i++){\n    cin >> w[i];\n    a[i] = w[i];\n    mi = min(mi, w[i]); //minimum weight\n  }\n\n  //output\n  cout << solve() << endl;\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<sstream>\nusing namespace std;\nconst int MAX=1000;\nconst int VMAX=10000;\nint n,A[MAX],s,B[MAX],T[VMAX+1];\n\nint solve()\n{\n\tint ans=0;\n\tbool V[MAX];\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tB[i]=A[i];\n\t\tV[i]=false;\n\t}\n\tsort(B,B+n);\n\tfor(int i=0;i<n;i++)T[B[i]]=i;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(V[i])continue;\n\t\tint cur=i;\n\t\tint S=0;\n\t\tint m=VMAX;\n\t\tint an=0;\n\t\twhile(1)\n\t\t{\n\t\t\tV[cur]=true;\n\t\t\tan++;\n\t\t\tint v=A[cur];\n\t\t\tm=min(m,v);\n\t\t\tS+=v;\n\t\t\tcur=T[v];\n\t\t\tif(V[cur])break;\n\t\t}\n\t\tans+=min(S+(an-2)*m,m+S+(an+1)*s);\n\t}\n\treturn ans;\n}\nint main()\n{\n\tcin>>n;\n\ts=VMAX;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>A[i];\n\t\ts=min(s,A[i]);\n\t}\n\tcout<<solve()<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nint n, A[1010], min_num = INF;\nint B[1010], num[10010];\nvoid Mergesort(int A[], int left, int right)\n{\n    if(right - left == 1) return;\n    int mid = left + (right - left) / 2;\n    Mergesort(A, left, mid);\n    Mergesort(A, mid, right);\n    int buf[1010], pos = 0;\n    for(int i = left; i < mid; i++)\n    {\n        buf[pos] = A[i];\n        pos++;\n    }\n    for(int i = right - 1; i >= mid; i--)\n    {\n        buf[pos] = A[i];\n        pos++;\n    }\n    int itel = 0;\n    int iter = pos - 1;\n    for(int i = left; i < right; i++)\n    {\n        if(buf[itel] <= buf[iter]) A[i] = buf[itel++];\n        else A[i] = buf[iter--];\n    }\n}\nint solve()\n{\n    int ret = 0;\n    bool flag[1010];\n    for(int i = 0; i < n; i++)\n    {\n        B[i] = A[i];\n        flag[i] = false;\n    }\n    Mergesort(B, 0, n);\n    for(int i = 0; i < n; i++) num[B[i]] = i;\n    for(int i = 0; i < n; i++)\n    {\n        if(flag[i]) continue;\n        int pos = i, sum = 0, m = INF, alpha = 0;\n        while(1)\n        {\n            flag[pos] = true;\n            int tmp = A[pos];\n            m = min(m, tmp);\n            sum += tmp;\n            alpha++;\n            pos = num[tmp];\n            if(flag[pos]) break;\n        }\n        ret += min(sum + (alpha - 2) * m, m + sum + (alpha + 1) * min_num);\n    }\n    return ret;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n;\n    for(int i = 0; i < n; i++)\n    {\n        cin >> A[i];\n        min_num = min(min_num, A[i]);\n    }\n    cout << solve() << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX=1000;\nstatic const int VMAX=10000;\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\nint solve(){\n int ans=0;\n bool V[MAX];\n for(int i=0;i<n;i++){\n  B[i]=A[i];\n  V[i]=false;\n }\n sort(B,B+n);\n for(int i=0;i<n;i++)T[B[i]]=i;\n for(int i=0;i<n;i++){\n  if(V[i])continue;\n  int cur=i;\n  int S=0;\n  int m=VMAX;\n  int an=0;\n  while(1){\n   V[cur]=true;\n   an++;\n   int v=A[cur];\n   m=min(m,v);\n   S+=v;\n   cur=T[v];\n   if(V[cur])break;\n  }\n  ans+=min(S+(an-2)*m,m+S+(an+1)*s);\n }\n return ans;\n}\nint main(){\n cin>>n;\n s=VMAX;\n for(int i=0;i<n;i++){\n  cin>>A[i];\n  s=min(s,A[i]);\n }\n int ans=solve();\n cout<<ans<<endl;\n return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) (a)>(b)?(b):(a)\n#define max(a,b) (a)>(b)?(a):(b)\n\nusing namespace std;\n\nint A[1000];\nint dupA[1000];\nint pos[10001];\nint dupPos[10001];\nbool checked[1000];\n\nint main()\n{\n\tint N;\n\tint mini = 100000;\n\tscanf(\"%d\", &N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> A[i];\n\t\tdupA[i] = A[i];\n\t\tpos[A[i]] = i;\n\t\tdupPos[A[i]] = pos[A[i]];\n\t\tmini = min(mini, A[i]);\n\t}\n\n\tsort(A, A + N);\n\n\tint cost = 0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (checked[i])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tint mini2 = 100000, counter = 0, now = i, sum = 0;\n\t\t\n\t\twhile (true)\n\t\t{\n\t\t\tif (checked[now])\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tchecked[now] = true;\n\t\t\tmini2 = min(mini2, A[now]);\n\t\t\tsum += A[now];\n\t\t\tcounter++;\n\t\t\tnow = pos[A[now]];\n\t\t}\n\t\tcost += min(sum + mini2*(counter - 2), sum + mini + mini2 + mini*counter);\n\t}\n\n\tcout << cost << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nconst int MAXN = 1010;\nint w[MAXN];\nbool done[MAXN];\nusing namespace std;\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, mini = 100000;\n    cin >> n;\n    map<int, int> mp;\n    for (int i = 0; i < n; i++) {\n        cin >> w[i];\n        mp[w[i]] = 0;\n        mini = min(mini, w[i]);\n    }\n    {\n        int k = 0;\n        for (auto& p : mp) p.second = k++;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (done[i]) continue;\n        int cnt = 0, now = i, mi = 100000, sum = 0;\n        while (1) {\n            if (done[now]) break;\n            cnt++;\n            done[now] = true;\n            mi = min(mi, w[now]);\n            sum += w[now];\n            now = mp[w[now]];\n        }\n        int tmp = sum+(cnt-2)*mi;\n        tmp = min(tmp, sum+mi+mini*(cnt+1));\n        ans += tmp;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int num = 1001,num1 = 10000, INF = 2000000000;\nint n, a[num], b[num], c[num1], tf[num], s = INF;\ninline int mini() {\n    int an = 0;\n    int cu = 0;\n    for (int i = 0; i < n; i++) {\n        if (tf[i]) continue;\n        cu = i;\n        int m = INF;\n        int sum = 0;\n        int cnt = 0;\n        while (true) {\n            tf[cu] = 1;\n            int v = a[cu];\n            cnt++;\n            m = min(v, m);\n            sum += v;\n            cu = c[v];\n            if (tf[cu]) break;\n        }\n        an += min(sum + m*(cnt - 2), sum + m*(cnt - 2) + 2 * (m + s) - (m - s)*(cnt - 1));\n    }\n    return an;\n}\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        s = min(a[i], s);\n        b[i] = a[i];\n        tf[i] = 0;\n    }\n    sort(b, b + n);\n    for (int i = 0; i < n; i++) \n        c[b[i]] = i;\n    int ans = mini();\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstatic const int MAX=1000;\nstatic const int VMAX=10000;\n\nint n, A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve() {\n  int ans=0;\n  bool V[MAX];\n  for (int i=0; i<n; i++) {\n    B[i]=A[i];\n    V[i]=false;\n  }\n  sort(B,B+n);\n  for (int i=0; i<n; i++) {\n    T[B[i]]=i;\n  }\n  for (int i=0; i<n; i++) {\n    if (V[i]) {\n      continue;\n    }\n    int cur=i;\n    int S=0;\n    int m=VMAX;\n    int an=0;\n    while (true) {\n      V[cur]=true;\n      an++;\n      int v=A[cur];\n      m=min(m,v);\n      S+=v;\n      cur=T[v];\n      if (V[cur]) {\n        break;\n      }\n    }\n    ans+=min(S+(an-2)*m,m+S+(an+1)*s);\n  }\n  return ans;\n}\nint main() {\n  cin>>n;\n  s=VMAX;\n  for (int i=0; i<n; i++) {\n    cin>>A[i];\n    s=min(s,A[i]);\n  }\n  int ans=solve();\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint solve() {\n    int ans = 0;\n    \n    bool V[MAX];\n    for (int i=0; i<n; i++) {\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B, B+n);\n    for (int i=0; i<n; i++) T[B[i]] = i;\n    for (int i=0; i<n; i++) {\n        if (V[i]) continue;\n        int cur = 1;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while(1) {\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m, v);\n            S += v;\n            cur = T[v];\n            if (V[cur]) break;\n        }\n        ans += min(S + (an-2) * m, m + S + (an+1) * s);\n    }\n    \n    return ans;\n}\n\nint main() {\n    cin >> n;\n    s = VMAX;\n    for (int i=0; i<n; i++) {\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n    \n    int ans = solve();\n    cout << ans << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<algorithm>\n#include<iostream>\n#include<map>\n#include<vector>\nint main(void) {\n\tstd::ios_base::sync_with_stdio(false);\n\tint n, input;\n\tstd::cin >> n;\n\tstd::map<int, int>w;\n\tstd::vector<int>vector(n);\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tstd::cin >> input;\n\t\tw[input - 1] = i;\n\t\tvector[i] = input-1;\n\t}\n\tstd::vector<int>vector_min= vector;\n\tstd::map<int, int>w_1(w);\n\tstd::sort(vector_min.begin(), vector_min.end());\n\tfor (int i = 0; i < n; ++i) {\n\t\tw[vector[i]] = vector_min[i];\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint temp = 0;\n\t\twhile (vector_min[i] != w[vector_min[i]]) {\n\t\t\ttemp += vector_min[i] + w[vector_min[i]] + 2;\n\t\t\tstd::swap(w[vector_min[i]],w[w[vector_min[i]]] );\n\t\t}\n\t\tint temp_1 = static_cast<int>(1e5);\n\t\tif (i>0&&vector_min[i] != w_1[vector_min[i]]) {\n\t\t\ttemp_1 =  w_1[vector_min[i]]+ w_1[vector_min[0]] + 2;\n\t\t\tstd::swap(w_1[vector_min[0]], w_1[vector_min[i]]);\n\t\t\twhile (vector_min[0] !=w_1[vector_min[0]]) {\n\t\t\t\ttemp_1 += w_1[vector_min[i]]+ w_1[vector_min[0]] + 2;\n\t\t\t\tstd::swap(w_1[vector_min[0]], w_1[w_1[vector_min[0]]]); }\n\t\t}\n\t\tcnt += std::min(temp, temp_1);\n\t}\n\tstd::cout << cnt << std::endl;\n//\tsystem(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<algorithm>\n#include<iostream>\n#include<map>\n#include<vector>\nint main(void) {\n\tstd::ios_base::sync_with_stdio(false);\n\tint n, input;\n\tstd::cin >> n;\n\tstd::map<int, int>w;\n\tstd::vector<int>vector(n+1,0);\n\t\n\tfor (int i = 1; i <= n; ++i) {\n\t\tstd::cin >> input;\n\t\tvector[i] = input;\n\t}\n\tstd::vector<int>vector_min= vector;\n\n\tstd::sort(vector_min.begin(), vector_min.end());\n\tfor (int i = 1; i <= n; ++i) {\n\t\tw[vector[i]] = vector_min[i];\n\t}\n\tstd::map<int, int>w_1(w);\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint temp =0;\n\t\twhile (vector_min[i] != w[vector_min[i]]) {\n\t\t\ttemp += vector_min[i] + w[vector_min[i]] ;\n\t\t\tstd::swap(w[vector_min[i]],w[w[vector_min[i]]] );\n\t\t}\n\t\tint temp_1 = static_cast<int>(1e5);\n\t\tif (i>1&&vector_min[i] != w_1[vector_min[i]]) {\n\t\t\ttemp_1 =  w_1[vector_min[i]]+ w_1[vector_min[1]] ;\n\t\t\tstd::swap(w_1[vector_min[i]], w_1[vector_min[1]]);\n\t\t\twhile (vector_min[1] !=w_1[vector_min[1]]) {\n\t\t\t\ttemp_1 += w_1[vector_min[i]]+ w_1[vector_min[1]] ;\n\t\t\t\tstd::swap(w_1[vector_min[1]], w_1[w_1[vector_min[1]]]); }\n\t\t}\n\t\tcnt += std::min(temp, temp_1);\n\t}\n\tstd::cout << cnt << std::endl;\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\n#define MAX 100000\n\nbool cmp(const int n1, const int n2) {\n\treturn n1 < n2;\n}\n\nstruct Data {\n\tint num;\n\tint i;\n};\n\nint main() {\n\tint n;\n\tint minValue = MAX;\n\tint sortAry[1000];\n\tData ary[1000];\n\tvector<vector<int> > groups;\n\tint cost = 0;\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint temp;\n\t\tcin >> temp;\n\t\tsortAry[i] = ary[i].num = temp;\n\t\tminValue = min(minValue, temp);\n\t}\n\n\tsort(sortAry, sortAry + n, cmp);\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (ary[i].num == sortAry[j]) {\n\t\t\t\tary[i].i = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tvector<int> group;\n\t\tint j = i;\n\t\tint s = i;\n\t\twhile (j != ary[j].i) {\n\t\t\tgroup.push_back(ary[j].num);\n\n\t\t\tint temp = ary[j].i;\n\t\t\tary[j].i = j;\n\t\t\tj = temp;\n\t\t}\n\t\tif (!group.empty()) {\n\t\t\tgroups.push_back(group);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < groups.size(); i++) {\n\t\tint sum = 0;\n\t\tint m = MAX;\n\t\tint num = groups[i].size();\n\n\t\tfor (int j = 0; j < num; j++) {\n\t\t\tsum += groups[i][j];\n\t\t\tm = min(groups[i][j], m);\n\t\t}\n\n\t\tint c1, c2;\n\t\tc1 = sum + (num - 2) * m;\n\t\tc2 = sum + (num + 1) * minValue + m;\n\t\tcost += min(c1, c2);\n\t}\n\n\tcout << cost << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <list>\n#include <cmath>\n#include <vector>\n#include <stack>\n#include <set>\n#include <map>\n#define sf scanf\n#define pf printf\n#define show(x) cout<<\"x:\"<<x<<endl;\nusing namespace std;\ntypedef long long ll;\nconst int maxn=1e3+5;\nconst int inf=1e9+5;\nint a[maxn],b[maxn],s,n,p[maxn];\nbool v[maxn];\n\nll solve()\n{\n    ll an=0,ans=0;\n    int mi=inf;\n    for(int i=0;i<n;i++)p[a[i]]=i;\n\n    for(int i=0;i<n;i++){\n        if(a[i]==i) v[i]=1;\n        else v[i]=0;\n    }\n\n    for(int i=0;i<n;i++)\n    {\n        int k=i;\n        an=0;\n        mi=inf;\n        if(v[k])continue;\n        int r=1;\n        while(1)\n        {\n            if(v[k])break;\n            v[k]=1,++r;\n            an+=a[k]+1;\n            mi=min(mi,a[k]+1);\n            k=a[p[k]];\n           // pf(\"...%d\\n\",r);\n        }\n\n        if(r>=3)\n            ans+=min(an+(n-2)*mi,an+(n-2)*mi+2*(mi+s)-(n-1)*(mi-s));\n        else\n            if(r==2)\n                ans+=an;\n    }\n\n    return ans;\n\n}\n\nint main()\n{\n    sf(\"%d\",&n);\n    s=inf;\n    for(int i=0;i<n;i++){\n        sf(\"%d\",&a[i]),--a[i];\n        s=min(s,a[i]);\n    }\n    ll ans=solve();\n    cout<<ans<<endl;\n\n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve() {\n\tint ans = 0;\n\n\tbool V[MAX];\n\tfor (int i = 0; i < n; i++) {\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; i++) T[B[i]] = i;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (V[i]) continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile (true) {\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif (V[cur])break;\n\t\t}\n\t\tans += min(S + (an - 2)*m, m + S + (an + 1)*s);\n\t}\n\treturn ans;\n}\n\nint main(void) {\n\tcin >> n;\n\ts = VMAX;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tint ans = solve();\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nint N,W[1005],C[1005],c=0,t,p;\nmap<int,int>H;\nmap<int,int>rH;\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++)\n\t\tscanf(\"%d\",C+i);\n\tmemcpy(W,C,sizeof(C));\n\tsort(C,C+N);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tH[C[i]]=i;\n\t\trH[i]=C[i];\n\t}\n\tfor(int i=0;i<N;i++)\n\t\tW[i]=H[W[i]];\n\tfor(;;)\n\t{\n\t\tint mc=10000000,cp=-1;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tif(W[i]!=i&&rH[W[i]]+rH[W[W[i]]]<mc)\n\t\t\t{\n\t\t\t\tcp=i;\n\t\t\t\tmc=rH[W[i]]+rH[W[W[i]]];\n\t\t\t}\n\t\t}\n\t\tif(cp==-1)break;\n\t\tc+=rH[W[cp]]+rH[W[W[cp]]];\n\t\tt=W[cp];\n\t\tp=W[cp];\n\t\tW[cp]=W[p];\n\t\tW[p]=t;\n\t}\n\tprintf(\"%d\\n\",c);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <stdlib.h>\nusing namespace std;\n\n#define MAX_NUM 1000\n\nint W[MAX_NUM];\nint N;\n\nint Compare(const void *a, const void *b)\n{\n    return *(int*)a - *(int*)b;\n}\n\nvoid Swap(int idx1, int idx2) {\n\tint tmp = W[idx1];\n\tW[idx1] = W[idx2];\n\tW[idx2] = tmp;\n}\n\nint SearchIdx(int wi)\n{\t\n\tfor (int i = 0; i < N; i++) {\n\t\tif (W[i] == wi) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void)\n{\n\t//input\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> W[i];\n\t}\n\n\t//minimum cost?\n\tint cost = 0;\n\tint w2[MAX_NUM];\n\tmemcpy(w2, W, sizeof(int) * N);\n\tqsort(w2, N, sizeof(int), Compare);\n\tfor (int i = 0; i < N; i++) {\n\t\tint idx1 = SearchIdx(w2[i]);\n\t\tif (idx1 == -1) return -1;\n\t\twhile (idx1 != i) {\n\t\t\tint idx2 = SearchIdx(w2[idx1]);\n\t\t\tSwap(idx1, idx2);\n\t\t\tcost = cost + W[idx1] + W[idx2];\n\t\t\tidx1 = idx2;\n\t\t}\n\t}\n\n\t//output\n\tcout << cost << \"\\n\";\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve()\n{\n\tint ans = 0;\n\tbool V[MAX];\n\n\tfor (int i = 0; i < n; i++) {\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\n\tsort(B, B + n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tT[B[i]] = i;\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (V[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile (true) {\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif (V[cur]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tans += min(S + (an - 2)*m, m + S + (an + 1)*s);\n\t}\n\n\treturn ans;\n}\n\nint main()\n{\n\tcin >> n;\n\ts = VMAX;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tint ans = solve();\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<list>\nusing namespace std;\n\ntypedef struct{int a;int b;int c;} arr;\ntypedef pair<long long,long long> logg;\n\narr L[510],R[510];\n\nint merge(arr a[],int l,int m,int r,char c)\n{\n\tint n1=m-l;\n\tint n2=r-m;\n\tfor(int i=0;i<n1;i++)\n\t{\n\t\tL[i]=a[l+i];\n\t}\n\tfor(int i=0;i<n2;i++)\n\t{\n\t\tR[i]=a[m+i];\n\t}\n\tint i=0,j=0;\n\tif(c=='a')\n\t{\n\t\tL[n1].a=100000;R[n2].a=100000;\n\t\tfor(int k=l;k<r;k++)\n\t\t{\n\t\t\tif(L[i].a<=R[j].a)\n\t\t\t{\n\t\t\t\ta[k]=L[i++];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta[k]=R[j++];\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tL[n1].c=100000;R[n2].c=100000;\n\t\tfor(int k=l;k<r;k++)\n\t\t{\n\t\t\tif(L[i].c<=R[j].c)\n\t\t\t{\n\t\t\t\ta[k]=L[i++];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta[k]=R[j++];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint mergeS(arr a[],int l,int r,char c)\n{\n\tif(l+1<r)\n\t{\n\t\tint m=(l+r)/2;\n\t\tmergeS(a,l,m,c);\n\t\tmergeS(a,m,r,c);\n\t\tmerge(a,l,m,r,c);\n\t}\n}\n\n\nint main()\n{\n\tint n,j=1;cin>>n;\n\tarr a[1010];\n\tlogg c[1010];\n\tfor(int i=1;i<=n;cin>>a[i++].a);a[n+1].a==1;\n\t\n\t\n\tfor(int i=1;i<=n;a[i].c=i,i++);\n\tmergeS(a,1,n+1,'a');\n\tfor(int i=1;i<=n;a[i].b=i,i++);\n\tmergeS(a,1,n+1,'c');\n\t\n\t/*for(int i=1;i<=n;i++)\n\t{\n\t\tcout<<a[i].a<<\" \"<<a[i].b<<\" \"<<a[i].c<<endl;\n\t}*/\n\t\n\tfor(int i=1,m=100000;;)\n\t{\n\t\tif(a[i].b!=0)//.b\n\t\t{\n\t\t\tc[j].first++;\n\t\t\tc[j].second+=a[i].a;\n\t\t\tif(a[i].a<m)m=a[i].a;\n\t\t\tint l=a[i].b;//.b\n\t\t\ta[i].b=0;//.b\n\t\t\ti=l;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(c[j].first==1)\n\t\t\t{\n\t\t\t\tc[j].second=0;\n\t\t\t}\n\t\t\telse if(c[j].first>=3)\n\t\t\t{\n\t\t\t\tc[j].second+=m*(c[j].first-2);\n\t\t\t}\n\t\t\tm=100000;\n\t\t\tj++;\n\t\t\tint s=0;\n\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t{\n\t\t\t\ts+=a[k].b;//a\n\t\t\t\tif(a[k].b!=0)i=k;//a\n\t\t\t}\n\t\t\tif(s==0)break;\n\t\t}\n\t}\n\tlong long s=0;\n\tfor(int i=1;i<=j;i++)\n\t{\n\t\ts+=c[i].second;\n\t}\n\tcout<<s<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int num = 1001,num1 = 10000, INF = 2000000000;\nint n, a[num], b[num], c[num1], tf[num], s = INF;\ninline int mini() {\n    int an = 0;\n    int cu = 0;\n    for (int i = 0; i < n; i++) {\n        if (tf[i]) continue;\n        cu = i;\n        int m = INF;\n        int sum = 0;\n        int cnt = 0;\n        while (true) {\n            tf[cu] = 1;\n            int v = a[cu];\n            cnt++;\n            m = min(v, m);\n            sum += v;\n            cu = c[v];\n            if (tf[cu]) break;\n        }\n        an += min(sum + m*(cnt - 2), sum + m*(cnt - 2) + 2 * (m + s) - (m - s)*(cnt - 1));\n    }\n    return an;\n}\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        s = min(a[i], s);\n        b[i] = a[i];\n        tf[i] = 0;\n    }\n    sort(b, b + n);\n    for (int i = 0; i < n; i++) \n        c[b[i]] = i;\n    int ans = mini();\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nconst int MAX = 5000;\nconst int maxnum = 10010;\nbool V[MAX];\n\nint n, A[MAX], s;\nint B[MAX], T[maxnum];\nint solve() {\n\tint ans = 0;\n\n\t// T??°???????????????????´????????????????????????????????????\\??¨??????????????¢???\n\tfor (int i = 0; i < n; i++)\n\t\tT[B[i]] = i;\n\tfor (int i = 0; i < n; i++) {\n\t\t// ????????¨???????????¢????????¨??????\n\t\tif (V[i])\n\t\t\tcontinue;\n\n\t\tint cur = i;\n\t\tint S = 0, m = maxnum, an = 0;\n\t\t// ?????¢?????????\n\t\twhile (!V[cur]) {\n\t\t\tV[cur] = true;\n\t\t\t// ?????¢?????°????´????\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\t// ??????????????¢??????????°????\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\t// ?????¢??????????????????\n\t\t\tcur = T[v];\n\t\t}\n\t\tans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n\t}\n\treturn ans;\n\n}\nint main() {\n\n\tscanf(\"%d\", &n);\n\ts = maxnum;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &A[i]);\n\t\ts = min(s, A[i]);\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B, B + n);\n\tprintf(\"%d\\n\", solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define MAX 1000\n#define VMAX 10000\n\n/**\n * 4 -> 7 -> 5 -> 1 -> 4\n * => sum = 17\n * => cycle = 4\n * => min = 1\n * => sum + (cycle - 2) * min = 17 + (4 - 2) * 1 = 17 + 2 = 19\n * \n * (i-i)   1 and 4: swap 1 and 4 => 4 -> 7 -> 5 -> 4: cost 5\n * (i-ii)  4 and 7: swap 4 and 7 => 4 -> 5 -> 4: cost 11\n * (i-iii) 4 and 5: swap 4 and 5 => cost 9\n * sum: 5 + 11 + 9 = 25\n * \n * (ii-i)   1 and 5: swap 1 and 5 => 4 -> 7 -> 1 -> 4: cost 6\n * (ii-ii)  1 and 7: swap 1 and 7 => 4 -> 1 -> 4:      cost 8\n * (ii-iii) 1 and 4: swap 1 and 4 =>                   cost 5\n * sum: 6 + 8 + 5 = 19\n * \n * swap count:\n * => at least one exchange occurs for each element: sum of element's number\n * => exchange with min value occurs n - 1 times (but reduce once because first time is counted by the above step): (n - 2) * min value\n * \n * first part:  1 -> 2 -> 1\n * second part: 7 -> 8 -> 10 -> 9 -> 7\n * \n * 7 * (n - 2) = 14 (i)\n * 1 * (n - 2) = 2  (ii)\n * 1 + 7 = 8        (iii)\n * (i) < (ii) + (iii)\n * 2 -> 7 -> 8 -> 10 -> 9 -> 1 -> 2\n * \n * (2 * (min(w_i) + x)) - ((n-1) * (min(w_i) - x))\n * \n * cost = sum(w_i) + (n - 2) * min(w_i)  + 2 * (min(w_i) + X) - (n - 1) * (min(w_i) - x)\n *      = sum(w_i) + ((n - 2) - (n - 1) + 2) * min(w_i) + (2 + (n - 1)) * x\n *      = sum(w_i) + min(w_i) + (n + 1) * x\n **/\nint min(int a, int b) {\n    return (a < b) ? a : b;\n}\n\nint cycle_cost(int sum, int min_w, int min_v, int length) {\n    int single_cost = sum + (length - 2) * min_w;\n    int cost_with_min = sum + min_w + (length + 1) * min_v;\n    return min(single_cost, cost_with_min);\n}\n\nint solve(int A[], int B[], int T[], int N, int min_v) {\n    int ans = 0;\n\n    bool V[MAX];\n    for (int i = 0; i < N; i++) {\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B, B+N);\n    for (int i = 0; i < N; i++) T[B[i]] = i;\n    for (int i = 0; i < N; i++) {\n        if (V[i]) continue;\n        int cur = i;\n        int sum_of_cycle = 0;\n        int min_w = VMAX;\n        int length = 0;\n        while (true) {\n            V[cur] = true;\n            length++;\n            int cur_val = A[cur];\n            min_w = min(min_w, cur_val);\n            sum_of_cycle += cur_val;\n            cur = T[cur_val];\n            if (V[cur]) break;\n        }\n        ans += cycle_cost(sum_of_cycle, min_w, min_v, length);\n    }\n    return ans;\n}\n\nint main() {\n    int A[MAX], B[MAX], T[VMAX+1], N, sum, min_w, min_v = VMAX, length;\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        cin >> A[i];\n        min_v = min(min_v, A[i]);\n    }\n    int ans = solve(A, B, T, N, min_v);\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "a\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<limits.h>\n\nint k = 0;\nstruct val_pos{\n\tint val;\n\tint pos;\n};\n\nvoid Merge(val_pos a[], int left, int mid, int right){\n\tint n1 = mid - left;\n\tint n2 = right - mid;\n\tval_pos* L = new val_pos[n1+1];\n\tval_pos* R = new val_pos[n2+1];\n\tfor ( int i = 0; i < n1; i++) L[i] = a[left + i];\n\tL[n1].val = INT_MAX;\n\tfor (int i = 0; i < n2; i++) R[i] = a[mid + i];\n\tR[n2].val = INT_MAX;\n\tint i = 0;\n\tint j = 0;\n\twhile(i < n1 || j < n2){\n\t\tif (L[i].val <= R[j].val){\n\t\t\ta[left + i + j] = L[i];\n\t\t\ti++;\n\t\t}\n\t\telse{\n\t\t\ta[left + i + j] = R[j];\n\t\t\tj++;\n\t\t}\n\t}\n}\n\nvoid MergeSort(val_pos a[], int left, int right){\n\tif (left + 1 < right){\n\t\tint mid = (left + right) / 2;\n\t\tMergeSort(a, left, mid);\n\t\tMergeSort(a, mid, right);\n\t\tMerge(a, left, mid, right);\n\t}\n}\n\nvoid MinCost(val_pos a[], int n, int min){\n\tfor (int i = 0; i < n; i++){\n\t\tif (i != a[i].pos){\n\t\t\tint k_st = 0;\n\t\t\tint k_ex = 2 * (min + a[i].val);\n\t\t\twhile(i != a[i].pos){\n\t\t\t\tk_st += a[i].val + a[a[i].pos].val;\n\t\t\t\tk_ex += min + a[a[i].pos].val;\n\t\t\t\tint tmp = a[a[i].pos].pos;\n\t\t\t\ta[a[i].pos].pos = a[i].pos;\n\t\t\t\ta[i].pos = tmp;\n\t\t\t}\n\t\t\tk += k_st < k_ex ? k_st : k_ex;\n\t\t\tbreak;\n\t\t}\n\t\tif (i == n-1) return;\n\t}\n\tMinCost(a, n, min);\n\treturn;\n}\n\nint main(){\n\tint n = 0;\n\tscanf(\"%d\", &n);\n\tval_pos a[1000];\n\tint min = INT_MAX;\n\tfor (int i = 0; i < n; i++) {\n\t\ta[i].pos = i;\n\t\tscanf(\"%d\", &a[i].val);\n\t\tif (a[i].val < min) min = a[i].val;\n\t}\n\tMergeSort(a, 0, n);\n\tMinCost(a, n, min);\n\tprintf(\"%d\\n\", k);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\n#include<climits>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\nconst int INF = INT_MAX/3;\n\nint main(){\n    //??\\???\n    int n;\n    cin >> n;\n    int input[n];\n    for (int i=0;i<n;i++){\n        cin >> input[i];\n    }\n\n    //?????§????????¨??????\n    int checked[n];\n    for (int i=0;i<n;i++){\n        checked[i] = 0;\n    }\n\n    //??\\???????????????????????????????±???????\n    vector< pair<int, int > >inputSorted;\n    for(int i=0;i<n;i++){\n        inputSorted.push_back(make_pair(input[i], i));\n    }\n    sort(inputSorted.begin(), inputSorted.end());\n    int toMove[n];\n    for (int i=0;i<n;i++){\n        toMove[inputSorted[i].second] = i;\n    }\n\n    //??¢?????´?????????\n    int result = 0;\n    for (int i=0;i<n;i++){\n        if (checked[i] == 0 and i != toMove[i]){\n            checked[i] = 1;\n            int mini = input[i];\n            int count = 1;\n            int sum = input[i];\n            int now = toMove[i];\n            while(i!=now){\n                checked[now] = 1;\n                mini = min(mini, input[now]);\n                count++;\n                sum += input[now];\n                now = toMove[now];\n            }\n            sum += mini*(count - 2);\n            result += sum;\n        }\n    }\n\n    cout << result << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint solve(){\n    int ans = 0;\n\n    bool V[MAX];\n    for(int i=0; i<n; i++){\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B, B+n);\n    for(int i=0; i<n; i++) T[B[i]] = i;\n    for(int i=0; i<n; i++){\n        if(V[i]) continue;\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while(1){\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m, v);\n            S += v;\n            cur = T[v];\n            if(V[cur]) break;\n        }\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n    }\n\n    return ans;\n}\n\nint main(){\n    cin >> n;\n    s = VMAX;\n    for(int i=0; i<n; i++){\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n    int ans = solve();\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Ref. https://book.mynavi.jp/ec/products/detail/id=35408\n\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve() {\n\tint ans = 0;\n\n\tbool V[MAX];\n\tfor (int i = 0; i < n; i++) {\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; i++) T[B[i]] = i;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (V[i]) continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile (1) {\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif (V[cur]) break;\n\t\t}\n\t\tans += min(S + (an - 2)*m, m + S + (an + 1)*s);\n\t}\n\treturn ans;\n}\n\nint main() {\n\tcin >> n;\n\ts = VMAX;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tint ans = solve();\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n\n\nusing namespace std;\n\nint main() {\n\t\n\tint const N_MAX = 1000;\n\tint const W_MAX = 10000;\n\n\tint n = 0;\n\tcin >> n;\n\n\tvector<int> W, S, T;\n\tvector<bool> C;\n\t\n\tW.resize(n, 0);     // idx -> W\n\tS.resize(n, 0);     // sorted Wi\n\tT.resize(W_MAX, 0); // W -> idx\n\tC.resize(n, false); // flag for searched or not\n\n\tint g_min = W_MAX; // global_min of Wi\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> W[i];\n\t\tg_min = (W[i] < g_min) ? W[i] : g_min;\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tT[W[i]] = i;\n\t}\n\n\tS = W;\n\tstable_sort(S.begin(), S.end());\n\n\tint score = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!C[T[S[i]]]) {\n\t\t\tint l_min = W_MAX;\n\t\t\tint sum = 0;\n\t\t\tint cnt = 0;\n\t\t\tfor(int j = S[i]; !C[T[j]]; j = S[T[j]] ) {\n\t\t\t\tC[T[j]] = true;\n\t\t\t\tcnt++;\n\t\t\t\tsum += j;\n\t\t\t\tl_min = (j < l_min) ? j : l_min;\n\t\t\t}\n\t\t\tscore += min(sum + l_min*(cnt - 2), sum+g_min*cnt+2*l_min);\n\t\t}\n\t}\n\n\tcout << score << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n;\n    cin>>n;\n    vector<int> w(n),c(n),j(10001),index(10001);\n    for(int i=0;i<n;i++){\n        cin>>w[i];\n    }\n\n    c=w;\n    for(int i=0;i<10001;i++){\n        j[i]=1;\n    }\n    int m=10001,ans=0;\n    for(int i=0;i<n;i++){\n        m=min(m,w[i]);\n    }\n    sort(c.begin(),c.end());\n    for(int i=0;i<n;i++){\n        index[c[i]]=i;\n    }\n    for(int i=0;i<n;i++){\n        if(j[w[i]]){\n            int cnt=0,x=w[i],min1=10001;\n            do{\n                j[x]=0;\n                min1=(min1,x);\n                ans+=x;\n                x=w[index[x]];\n                cnt++;\n            }while(x!=w[i]);\n            if(cnt==1) ans-=x;\n            else if(cnt>=3){\n                ans+=min(min1*(cnt-2),min1+m*(cnt+1));\n            }            \n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nstatic const int MAX = 1000;\nstatic const int VMAX=10000;\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve(){\n  int ans=0;\n  bool V[MAX];\n  for(int i=0;i<n;i++){\n    B[i]=A[i];\n    V[i]=false;\n  }\n  sort(B,B+n);\n  for(int i=0;i<n;i++)T[B[i]]=i;\n  for(int i=0;i<n;i++){\n    if(V[i])continue;\n    int cur=i;\n    int S=0;\n    int m=VMAX;\n    int an=0;\n    while(1){\n      V[cur]=true;\n      an++;\n      int v=A[cur];\n      m=min(m,v);\n      S+=v;\n      cur=T[v];\n      if(V[cur])break;\n    }\n    ans+=min(S+(an-2)*m,m+S+(an+1)*s);\n  }\n  return ans;\n}\n\nint main(){\n  cin>>n;\n  s=VMAX;\n  for(int i=0;i<n;i++){\n    cin>> A[i];\n    s=min(s,A[i]);\n  }\n  int ans=solve();\n  cout <<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstatic const int MAX=1000;\nstatic const int VMAX=10000;\n\nint n, A[MAX],s;\nint B[MAX],T[MAX+1];\n\nint solve() {\n  int ans=0;\n  bool V[MAX];\n  for (int i=0; i<n; i++) {\n    B[i]=A[i];\n    V[i]=false;\n  }\n  sort(B,B+n);\n  for (int i=0; i<n; i++) {\n    T[B[i]]=i;\n  }\n  for (int i=0; i<n; i++) {\n    if (V[i]) {\n      continue;\n    }\n    int cur=i;\n    int S=0;\n    int m=VMAX;\n    int an=0;\n    while (true) {\n      V[cur]=true;\n      an++;\n      int v=A[cur];\n      m=min(m,v);\n      S+=v;\n      cur=T[v];\n      if (V[cur]) {\n        break;\n      }\n    }\n    ans+=min(S+(an-2)*m,m+S+(an+1)*S);\n  }\n  return ans;\n}\nint main() {\n  cin>>n;\n  s=VMAX;\n  for (int i=0; i<n; i++) {\n    cin>>A[i];\n    s=min(s,A[i]);\n  }\n  int ans=solve();\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst int MAXN = 200005;\n\nint w[1005], B[1005], L[1005], flag[1005];\n\nint main(){\n\tint n, ans = 0, Min = INF;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> w[i];\n\t\tB[i] = w[i];\n\t\tMin = min(Min, w[i]);\n\t}\n\tsort(B, B + n);\n\tfor(int i = 0; i < n; i++)\t\n\t\tL[B[i]] = i;\n\tfor(int i = 0; i < n; i++){\n\t\tif(flag[i])\n\t\t\tcontinue;\n\t\tint temp = i, S = INF, m = 0, cnt = 0;\n\t\twhile(!flag[temp]){\n\t\t\tcnt++;\n\t\t\tflag[temp] = 1;\n\t\t\tS = min(S, w[temp]);\n\t\t\tm += w[temp];\n\t\t\ttemp = L[w[temp]];\n\t\t}\n\t\tans += min(m + (cnt - 2) * S, m + (cnt + 1) * Min + S);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int> W(n);\n    for (auto& w : W) cin >> w;\n    int cnt = 0;\n    for (int i = n - 1; i >= 1; i--) {\n        int max_i = max_element(W.begin(), W.begin() + i + 1) - W.begin();\n        if (i == max_i) continue;\n        cnt += W[i] + W[max_i];\n        swap(W[i], W[max_i]);\n    }\n    cout << cnt << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define FOR(i, s, e) for(int i = s; i < e; ++i)\nusing namespace std;\nstruct Data\n{\n\tData() :w(0), from(0), to(0), load(0){}\n\tint w;\n\tint from;\n\tint to;\n\tint load;\n};\nstruct DataWeightComparator\n{\n\tbool operator()(const Data* d1, const Data* d2)\n\t{\n\t\treturn (d1->w < d2->w);\n\t}\n};\nstruct DataLoadComparator\n{\n\tbool operator()(const Data* d1, const Data* d2)\n\t{\n\t\treturn (d1->load < d2->load);\n\t}\n};\n\nstatic Data* \nGetMinLoadData(Data* d1, Data* d2)\n{\n\tif (0 == d1) return d2;\n\tif (0 == d2) return d1;\n\treturn (d1->load > d2->load ? d2 : d1);\n}\n\nstruct SegmentTree\n{\n\tint base;\n\tvector<Data*> vS;\n\tvoid init(int n)\n\t{\n\t\tbase = 1;\n\t\twhile (base < n) base *= 2;\n\t\tint s = 2 * base - 1;\n\t\tvS.reserve(s);\n\t\twhile(s--) vS.push_back(0);\n\t}\n\n\tvoid update(int t, Data* d){\n\t\tint r = t + base - 1;\n\t\tvS[r] = d;\n\t\twhile (r > 0){\n\t\t\tr = (r - 1) / 2;\n\t\t\tvS[r] = GetMinLoadData(vS[2 * r + 1], vS[2 * r + 2]);\n\t\t}\n\t}\n\n\tData* query(int a, int b, int k, int l, int r)\n\t{\n\t\tif (r <= a || b <= l)\n\t\t\treturn 0;\n\t\telse if (a <= l && r <= b)\n\t\t\treturn vS[k];\n\t\telse{\n\t\t\tint m = (l + r) / 2;\n\t\t\tData* lm = query(a, b, 2 * k + 1, l, m);\n\t\t\tData* mr = query(a, b, 2 * k + 2, m, r);\n\t\t\treturn GetMinLoadData(lm, mr);\n\t\t}\n\t}\n\n\tData* query(int a, int b)\n\t{\n\t\treturn query(a, b + 1, 0, 0, base);\n\t}\n};\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<Data*> vD, vW, vL;\n\tvD.reserve(n);\n\tFOR(i, 0, n){\n\t\tData* d = new Data();\n\t\tcin >> d->w;\n\t\td->from = i;\n\t\tvD.push_back(d);\n\t}\n\tvW = vD;\n\tsort(vW.begin(), vW.end(), DataWeightComparator());\n\n\tSegmentTree tree;\n\ttree.init(n);\n\tFOR(i, 0, n){\n\t\tvW[i]->to = i;\n\t\tif (vW[i]->from == vW[i]->to){\n\t\t\tvW[i]->load = 0;\n\t\t\ttree.update(i, 0);\n\t\t}else{\n\t\t\tvW[i]->load = vD[vW[i]->from]->w + vD[vW[i]->to]->w;\n\t\t\ttree.update(i, vW[i]);\n\t\t}\n\t}\n\n\tint c = 0, from, to;\n\tData* d;\n\twhile ((d = tree.query(0, n - 1)) != 0)\n\t{\n\t\tto = d->to;\n\t\tfrom = d->from;\n\t\tc += d->load;\n\t\tswap(vD[to], vD[from]);\n\t\tvD[to]->from = to;\n\t\tvD[from]->from = from;\n\t\tvD[to]->load = 0;\n\t\ttree.update(to, 0);\n\t\tif (vW[from]->from == vW[from]->to){\n\t\t\tvD[from]->load = 0;\n\t\t\ttree.update(from, 0);\n\t\t}else{\n\t\t\tvD[from]->load = vD[from]->w + vD[vD[from]->to]->w;\n\t\t\tvW[from]->load = vW[from]->w + vD[vW[from]->to]->w;\n\t\t\ttree.update(from, vW[from]);\n\t\t\ttree.update(vD[from]->to, vD[from]);\n\t\t}\n\t}\n\n\tcout << c << \"\\n\";\n\tFOR(i, 0, n) delete vD[i];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint do_cycle(vector<int> &v,int x){\n\tint s=0,m=1<<30;\n\tfor(auto &e:v)s+=e,m=min(m,e);\n\treturn min(s+(v.size()-2)*m,s+m+(v.size()+1)*x);\n}\n\nint main(){\n\tint N,x=1<<30,r=0;\n\tscanf(\"%d\",&N);\n\tvector<int>v(N),b(N),se(N);\n\tmap<int,int>m;\n\tvector<vector<int> >cycles;\n\tfor(int i=0;i<N;i++)scanf(\"%d\",&v[i]),x=min(x,v[i]),se[i]=v[i];\n\tsort(se.begin(),se.end());\n\tint i=0;for(auto &e:se){m[e]=i++;}\n\tfor(int i=0;i<N;i++)if(!b[i]){\n\t\tvector<int>cycle;\n\t\tint k=i;\n\t\tdo{\n\t\t\tcycle.push_back(se[k]);\n\t\t\tb[k]=1;\n\t\t\tk=m[v[k]];\n\t\t}while(k!=i);\n\t\tr+=do_cycle(cycle,x);\n\t}\n\tprintf(\"%d\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n \nusing namespace std;\n \nint silly_sort(vector<int> v, int n){\n    vector<pair<int, int> > temp(n);\n    for (int i = 0; i < n; i++){\n        temp[i].first = v[i];\n        temp[i].second = i;\n    }\n    sort(temp.begin(), temp.end());\n \n    int cost = 0, s = temp[0].first;\n    for (int i = 0; i < n; i++){\n        int j = temp[i].second;\n        if (j != i && j >= 0){\n            int n = 1, amin, sum;\n            amin = sum = temp[i].first;\n            while (j != i){\n                int next = temp[j].second;\n                sum += temp[j].first;\n                n++;\n                temp[j].second = -1;\n                j = next;\n            }\n            cost += min(sum + (n - 2) * amin, sum + amin + (n + 1) * s);\n        }\n    }\n    return cost;\n}\nint main(){\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    for (int i = 0; i < n; i++) cin >> v[i];\n    cout << silly_sort(v, n) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <climits>\n\nconst int MAX_N = 1000;\n\nvoid print_array(std::vector<int> *A, int left, int right) {\n  for (int i = left; i <= right; i++) {\n    std::cout << A->at(i) << \" \";\n  }\n\n  std::cout << std::endl;\n}\n\nlong swap(std::vector<int> *A, int i, int j) {\n  int tmp = A->at(i);\n  A->at(i) = A->at(j);\n  A->at(j) = tmp;\n\n  return A->at(i) + A->at(j);\n}\n\nlong sort(std::vector<int> *A, std::vector<int> *B) {\n  long cost = 0;\n\n  for (int i = 0; i < B->size(); i++) {\n    int v = B->at(i);\n\n    for (int j = i; j < A->size(); j++) {\n      if (A->at(j) != v) {\n\tcontinue;\n      }\n      \n      if ((A->at(j) == v) && (i == j)) {\n\tcontinue;\n      } else {\n\tcost += swap(A, i, j);\n      }\n    }\n  }\n\n  return cost;\n}\n\nint partition(std::vector<int> *A, int p, int r) {\n  int x = A->at(r);\n  int i = p - 1;\n\n  for (int j = p; j <= r - 1; j++) {\n    if (A->at(j) <= x) {\n      i++;\n      \n      swap(A, i, j);\n    }\n  }\n\n  swap(A, i + 1, r);\n\n  return i + 1;\n}\n\nvoid quick_sort(std::vector<int> *A, int p, int r) {\n  if (p < r) {\n    int q = partition(A, p, r);\n    quick_sort(A, p, q - 1);\n    quick_sort(A, q + 1, r);\n  }\n}\n\nint main(void) {\n  std::ios_base::sync_with_stdio(false);\n\n  int n = 0;\n\n  std::cin >> n;\n\n  std::vector<int> *A = new std::vector<int>();\n  A->reserve(MAX_N);\n\n  for (int i = 0; i < n; i++) {\n    int v = 0;\n\n    std::cin >> v;\n    \n    A->push_back(v);\n  }\n\n  std::vector<int> *B = new std::vector<int>();\n\n  for (int i = 0; i < A->size(); i++) {\n    B->push_back(A->at(i));\n  }\n  \n  quick_sort(B, 0, A->size() - 1);\n  long weight = sort(A, B);\n\n  std::cout << weight << std::endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint solve() {\n    int ans = 0;\n    \n    bool V[MAX];\n    for (int i=0; i<n; i++) {\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B, B+n);\n    for (int i=0; i<n; i++) T[B[i]] = i;\n    for (int i=0; i<n; i++) {\n        if (V[i]) continue;\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while(1) {\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m, v);\n            S += v;\n            cur = T[v];\n            if (V[cur]) break;\n        }\n        ans += min(S + (an-2) * m, m + S + (an+1) * s);\n    }\n    \n    return ans;\n}\n\nint main() {\n    cin >> n;\n    s = VMAX;\n    for (int i=0; i<n; i++) {\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n    \n    int ans = solve();\n    cout << ans << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n    int n;\n    cin >> n;\n    int A[n];\n    int B[n];\n    for (int i = 0; i < n; i++) {\n        cin >> A[i];\n        B[i] = A[i];\n    }\n    sort(B, B + n);\n    int cnt = 0;\n    int i = 0;\n    while (i < n) {\n        if (A[i] == B[i]) {\n            i++;\n            continue;\n        }\n        int tgt_idx = find(A, A + n, B[i]) - A;\n        int n_cycle = 1;\n        while (tgt_idx != i) {\n            int dst_idx = find(A, A + n, B[tgt_idx]) - A;\n            cnt += A[tgt_idx] + A[dst_idx];\n            swap(A[tgt_idx], A[dst_idx]);\n            tgt_idx = dst_idx;\n            n_cycle++;\n        }\n        if ((n_cycle - 3) * B[i] > (n_cycle + 1) * B[0]) {\n            cnt -= (n_cycle - 3) * B[i] - (n_cycle + 1) * B[0];\n        }\n    }\n    cout << cnt << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define MAX 1000\n#define SENTINEL 2000000000\ntypedef long long ll;\n\nint L[MAX/2+2], R[MAX/2+2];\n\nll merge(int A[], int n, int left, int mid, int right){\n  int i, j, k;\n  ll cnt = 0;\n  int n1 = mid - left;\n  int n2 = right - mid;\n  for ( i = 0; i < n1; i++ ) L[i] = A[left + i];\n  for ( i = 0; i < n2; i++ ) R[i] = A[mid + i];\n  L[n1] = R[n2] = SENTINEL;\n  i = j = 0;\n  for ( k = left; k < right; k++ ){\n\n    if ( L[i] <= R[j] ){\n      A[k] = L[i++];\n    } else {\n      A[k] = R[j++];\n      cnt += mid + j - k -1;\n    }\n  }\n  return cnt;\n}\n\nll mergeSort(int A[], int n, int left, int right ){\n  int mid;\n  ll v1, v2, v3;\n  if ( left+1 < right ){\n    mid = (left + right)/2;\n    v1 = mergeSort(A, n, left, mid);\n    v2 = mergeSort(A, n, mid, right);\n    v3 = merge(A, n, left, mid, right);\n    return v1 + v2 + v3;\n  } else return 0;\n}\n\nint main(){\n  int A[MAX], n, i;\n\n  cin >> n;\n  for ( i = 0; i < n; i++ ) {\n    cin >> A[i];\n  }\n\n  ll ans = mergeSort(A, n, 0, n);\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\n\nint main() {\n\tint n;\n  scanf(\"%d\", &n);\n  int A[n], B[n], C[n];\n  for ( int i = 0; i < n; i++ ) scanf(\"%d\", &A[i]);\n  for ( int i = 0; i < n; i++ ) B[i] = A[i];\n  sort(B, B+n);\n  for ( int i = 0; i < n; i++ ) {\n    for ( int j = 0; j < n; j++ ) {\n      if (A[i] == B[j]) {\n        C[i] = j;\n        break;\n      }\n    }\n  }\n  int k = 0, count = 0, min = B[0], count1 = 0, count2 = 0;\n  while ( k < n ) {\n    int i, j;\n    for (i = 0; i < n; i++) if (C[i] == k) break;\n    for (j = 0; j < n; j++) if (C[j] == i) break;\n    if (C[k] == k) {\n\t\t\tif (count1 > count2+2*(min+B[k])) {\n\t\t\t\tcount += count2+2*(min+B[k]);\n\t\t\t} else {\n\t\t\t\tcount += count1;\n\t\t\t}\n\t\t\tcount1 = 0;\n\t\t\tcount2 = 0;\n      k++;\n    } else {\n      count1 += A[i]+A[j];\n\t\t\tcount2 += min+A[j];\n      swap(A[i], A[j]);\n      swap(C[i], C[j]);\n    }\n  }\n\n  printf(\"%d\\n\", count);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define FOR(i, s, e) for(int i = s; i < e; ++i)\nusing namespace std;\nstruct Data\n{\n\tData() :w(0), from(0), to(0), toW(0){}\n\tint w;\n\tint from;\n\tint to;\n\tint toW;\n};\nstruct DataWeightComparator\n{\n\tbool operator()(const Data* d1, const Data* d2)\n\t{\n\t\treturn (d1->w < d2->w);\n\t}\n};\n\nstatic Data* GetMinToWeightData(Data* d1, Data* d2)\n{\n\tif (0 == d1) return d2;\n\tif (0 == d2) return d1;\n\n\n\treturn (d1->toW > d2->toW ? d2 : d1);\n}\n\nstruct SegmentTree\n{\n\tint base;\n\tvector<Data*> vS;\n\tvoid init(int n)\n\t{\n\t\tbase = 1;\n\t\twhile (base < n) base *= 2;\n\t\tint s = 2 * base - 1;\n\t\tvS.reserve(s);\n\t\twhile (s--) vS.push_back(0);\n\t}\n\n\tvoid update(int t, Data* d){\n\t\tint r = t + base - 1;\n\t\tvS[r] = d;\n\t\twhile (r > 0){\n\t\t\tr = (r - 1) / 2;\n\t\t\tvS[r] = GetMinToWeightData(vS[2 * r + 1], vS[2 * r + 2]);\n\t\t}\n\t}\n\n\tData* query(int a, int b, int k, int l, int r)\n\t{\n\t\tif (r <= a || b <= l)\n\t\t\treturn 0;\n\t\telse if (a <= l && r <= b)\n\t\t\treturn vS[k];\n\t\telse{\n\t\t\tint m = (l + r) / 2;\n\t\t\tData* lm = query(a, b, 2 * k + 1, l, m);\n\t\t\tData* mr = query(a, b, 2 * k + 2, m, r);\n\t\t\treturn GetMinToWeightData(lm, mr);\n\t\t}\n\t}\n\n\tData* query(int a, int b)\n\t{\n\t\treturn query(a, b + 1, 0, 0, base);\n\t}\n};\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<Data*> vD, vW, vL;\n\tvD.reserve(n);\n\tFOR(i, 0, n){\n\t\tData* d = new Data();\n\t\tcin >> d->w;\n\t\td->from = i;\n\t\tvD.push_back(d);\n\t}\n\tvW = vD;\n\tsort(vW.begin(), vW.end(), DataWeightComparator());\n\n\tSegmentTree tree;\n\ttree.init(n);\n\tFOR(i, 0, n){\n\t\tvW[i]->to = i;\n\t\tif (vW[i]->from == vW[i]->to){\n\t\t\tvW[i]->toW = 0;\n\t\t\ttree.update(i, 0);\n\t\t}\n\t\telse{\n\t\t\tvW[i]->toW = vD[vW[i]->to]->w;\n\t\t\ttree.update(i, vW[i]);\n\t\t}\n\t}\n\n\tint c = 0, from, to;\n\tData* d;\n\twhile ((d = tree.query(0, n - 1)) != 0)\n\t{\n\t\tto = d->to;\n\t\tfrom = d->from;\n\t\tc += vD[from]->w + vD[to]->w;\n\t\tswap(vD[to], vD[from]);\n\t\tvD[to]->from = to;\n\t\tvD[from]->from = from;\n\t\tvD[to]->toW = 0;\n\t\ttree.update(to, 0);\n\t\tif (vW[from]->from == vW[from]->to){\n\t\t\tvD[from]->toW = 0;\n\t\t\ttree.update(from, 0);\n\t\t}\n\t\telse{\n\t\t\tvD[from]->toW = vD[vD[from]->to]->w;\n\t\t\tvW[from]->toW = vD[vW[from]->to]->w;\n\t\t\ttree.update(from, vW[from]);\n\t\t\ttree.update(vD[from]->to, vD[from]);\n\t\t}\n\t}\n\n\tcout << c << \"\\n\";\n\tFOR(i, 0, n) delete vD[i];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\nint a[MAX];\nint b[MAX], t[VMAX+1];\n\nint main(){\n\n  int n;\n  cin >> n;\n  int s = VMAX;\n  for(int i = 0; i < n; i++){\n    cin >> a[i];\n    s = min(s, a[i]);\n  }\n  int ans = 0;\n  bool v[MAX];\n  for(int i = 0; i < n; i++){\n    b[i] = a[i];\n    v[i] = false;\n  }\n  sort(b, b+n);\n  for(int i = 0; i < n; i++) t[b[i]] = i;\n  for(int i = 0; i < n; i++){\n    if(v[i]) continue;\n    int cur = i;\n    int ss = 0, an = 0;\n    int m = VMAX;\n    while(true){\n      v[cur] = true;\n      an++;\n      m = min(m, a[cur]);\n      ss += a[cur];\n      cur = t[a[cur]];\n      if(v[cur]) break;\n    }\n    ans += min(ss + (an - 2) * m, m + ss + (an + 1) * s);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define MAX 1000\n#define VMAX 10000\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve() {\n  int ans = 0;\n\n  bool V[MAX];\n  for(int i = 0; i < n; i++) {\n    B[i] = A[i];\n    V[i] = false;\n  }\n  sort(B, B + n);\n  for( int i = 0; i < n; i++) T[B[i]] = i;\n  for(int i = 0; i < n; i++) {\n    if(V[i]) continue;\n    int cur = i;\n    int S = 0;\n    int m = VMAX;\n    int an = 0;\n    while(1) {\n      V[cur] = true;\n      an++;\n      int v = A[cur];\n      m = min(m, v);\n      S += v;\n      cur = T[v];\n      if(V[cur]) break;\n    }\n\n    ans += min(S + (an - 2)*m, m + S +(an + 1)*s);\n  }\n  return ans;\n}\n\nint main() {\n  cin >> n;\n  s = VMAX;\n  for(int i = 0; i < n; i++) {\n    cin >> A[i];\n    s = min(s, A[i]);\n  }\n  int ans = solve();\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing vector = std::vector<int>;\nusing iterator = vector::iterator;\n\nauto print_vector = [](iterator begin, iterator end){\n                      while (begin != end)\n                        {\n                          std::cout << *begin;\n                          if (begin+1 == end) std::cout << std::endl;\n                          else std::cout << \" \";\n                          begin++;\n                        }\n                    };\n\nauto find_correct_pos = [](int key, vector vec_sorted){\n                          for (int i=0; i<vec_sorted.size(); ++i)\n                            {\n                              if (vec_sorted[i] == key)\n                                return i;\n                            }\n                          return -1;\n                        };\n\nint minimumCost(std::vector<int> vec)\n{\n  std::vector<std::vector<int> > cycles;\n  std::vector<int> vec_sorted = vec;\n  std::sort(vec_sorted.begin(), vec_sorted.end());\n\n  const int NIL = -1;\n  const int n = vec.size();\n\n  \n  for (int i=0; i<n; ++i)\n    {\n      if (vec[i] != vec_sorted[i])\n        {\n          int pos = i;\n          std::vector<int> tmp;\n          while (vec[pos] != NIL)\n            {\n              tmp.push_back(vec[pos]);\n              vec[pos] = NIL;\n              pos = find_correct_pos(*(tmp.end()-1), vec_sorted);\n              //std::cout << \"next=\" << pos << std::endl;\n            }\n          if (tmp.size() != 0) cycles.push_back(tmp);\n        }\n      // print_vector(vec.begin(), vec.end());\n    }\n\n  // std::cout << \"size = \" << cycles.size() << std::endl;\n\n  int cost = 0;\n  int min_in_vec = vec_sorted[0];\n\n  for (int i=0; i<cycles.size(); ++i)\n    {\n      // print_vector(cycles[i].begin(), cycles[i].end());\n\n      auto cycle = cycles[i];\n      int min = 10000;\n      for (int j=0; j<cycle.size(); ++j)\n        {\n          cost += cycle[j];\n          if (cycle[j] < min) min = cycle[j];\n        }\n      if (( min_in_vec*(cycle.size()-1) + (min_in_vec+min)*2 ) < ( min*(cycle.size()-1) ))\n        {\n          cost -= min;\n          cost += min_in_vec*(cycle.size()-1) + (min_in_vec+min)*2;\n        }\n      else\n        cost += min*(cycle.size()-2);\n    }\n\n\n  return cost;\n\n}\n\nint main ()\n{\n  int n;\n  std::cin >> n;\n\n  std::vector<int> vec;\n  for (int i=0; i<n; ++i)\n    {\n      int tmp;\n      std::cin >> tmp;\n      vec.push_back(tmp);\n    }\n\n    std::cout << minimumCost(vec) << std::endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\n\nint main() {\n\tint n;\n  scanf(\"%d\", &n);\n  int A[n], B[n], C[n];\n  for ( int i = 0; i < n; i++ ) scanf(\"%d\", &A[i]);\n  for ( int i = 0; i < n; i++ ) B[i] = A[i];\n  sort(B, B+n);\n  for ( int i = 0; i < n; i++ ) {\n    for ( int j = 0; j < n; j++ ) {\n      if (A[i] == B[j]) {\n        C[i] = j;\n        break;\n      }\n    }\n  }\n  int k = 0, count = 0, min = C[0], count1 = 0, count2 = 0;\n  while ( k < n ) {\n    int i, j;\n    for (i = 0; i < n; i++) if (C[i] == k) break;\n    for (j = 0; j < n; j++) if (C[j] == i) break;\n    if (C[k] == k) {\n\t\t\tif (count1 > count2+2*(min+k)) {\n\t\t\t\tcount += count2+2*(min+k);\n\t\t\t} else {\n\t\t\t\tcount += count1;\n\t\t\t}\n\t\t\tcount1 = 0;\n\t\t\tcount2 = 0;\n      k++;\n    } else {\n      count1 += A[i]+A[j];\n\t\t\tcount2 += min+A[j];\n      swap(A[i], A[j]);\n      swap(C[i], C[j]);\n    }\n  }\n\n  printf(\"%d\\n\", count);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX 10000\nusing namespace std;\nint main(){\n    int n,mini=MAX,data[1000],x[1000],pos[MAX+1]; cin>>n;\n    for(int i=0;i<n;++i){\n\tcin>>data[i];\n\tx[i]=data[i];\n\tif(mini>data[i]) mini=data[i];\n    }\n    for(int i=0;i<n-1;++i)\n\tfor(int j=n-1;j>i;--j)\n\t    if(x[j-1]>x[j]) swap(x[j-1],x[j]);\n    for(int i=0;i<n;++i) pos[x[i]]=i;\n    int sumn=0,flag[1000]={};\n    for(int i=0;i<n;++i){\n\tif(flag[i]) continue;\n\tint m=MAX,sum=0,cnt=0,cur=i;\n\tdo{\n\t    int val=data[cur];\n\t    flag[cur]=1;\n\t    sum+=val;\n\t    cur=pos[val];\n\t    if(m>val) m=val;\n\t    ++cnt;\n\t}while(!flag[cur]);\n\tif(sum+(cnt-2)*m<m+sum+(cnt+1)*mini) sumn+=sum+(cnt-2)*m;\n\telse sumn+=m+sum+(cnt+1)*mini;\n    }\n    cout<<sumn<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\n\nint num[1005],n,rev[1005];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&num[i]);\n\t\trev[num[i]] = i;\n\t}\n\tint res = 0;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tif(rev[i] == i) continue;\n\t\tint x = rev[i];\n\t\tswap(rev[i],rev[num[i]]);\n\t\tswap(num[i],num[x]);\n\t\tres += num[i]+num[x];\n\t}\n\tprintf(\"%d\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint A[1001],B[1001];\n\nint getIdx(){\n  int idx = n;\n  for(int i=0;i<n;i++)if(A[i]!=B[i] && A[idx]>A[i]) idx = i;  \n  return idx;\n}\n\nint Sort(int pos){\n  int sum=0,cnt=0;\n  while(A[pos]!=B[pos]){\n    cnt++;\n    int idx=0;\n    while(B[pos]!=A[idx]) idx++;\n    sum += A[idx];\n    swap(A[pos],A[idx]);\n    pos = idx;\n  }\n  return min(sum+A[pos]*cnt,sum+A[pos]*2+(cnt+2)*B[0]);\n}\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++)cin>>A[i],B[i] = A[i];\n  A[n] = B[n] = 1e9;\n  sort(B,B+n);\n\n  int ans = 0;  \n  for(int i=0;i<n;i++)ans+=Sort(getIdx());\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1000\n#define MAX_D 10001\n\nint main(){\n  int N, arr[MAX], _arr[MAX], dest[MAX_D];\n  bool used[MAX];\n\n  cin >> N;\n  for(int i = 0 ; i < N ; i++){\n    cin >> arr[i];\n    used[i] = false;\n    _arr[i] = arr[i];\n  }\n  sort(_arr, _arr+N);\n\n  for(int i = 0 ; i < N ; i++){\n    dest[_arr[i]] = i;\n  }\n\n  int ans = 0;\n  for(int i = 0 ; i < N ; i++){\n    if(dest[arr[i]] == i || used[i]){\n      used[i] = true;\n      continue;\n    }\n\n    int cnt = -1, sum = 0, min = arr[i], next = i;\n    for( ; !used[next] ; ){\n      sum += arr[next]; cnt++;\n      min = std::min(min, arr[next]);\n      used[next] = true;\n      next = dest[arr[next]];\n    }\n    sum -= min;\n    ans += sum + min*cnt;\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n\tint n, cost1 = 0, cost2 = 0;\n\tcin >> n;\n\t\n\tint arr1[n], arr2[n], sorted[n];\n\tbool visited[n] = { false };\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr1[i];\n\t\tarr2[i] = sorted[i] = arr1[i];\n\t}\n\tsort(sorted, sorted + n);\n\n\tvector<pair<int, int> > vec;\n\tint mini = 0, s1, s2;\n\twhile (mini < n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (arr1[i] == sorted[mini]) {\n\t\t\t\ts1 = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (arr1[i] == sorted[s1]) {\n\t\t\t\ts2 = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (s1 != s2) {\n\t\t\tvisited[mini] = visited[s1] = true;\n\t\t\tcost1 += arr1[s1] + arr1[s2];\n\t\t\tvec.push_back(make_pair(s1, s2));\n\t\t\tswap(arr1[s1], arr1[s2]);\n\t\t}\n\t\telse {\n\t\t\tmini++;\n\t\t}\n\t}\n\n\tcout << cost1 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#define MAX 10001\n\nusing namespace std;\n\ntypedef struct weight{\n    int w;\n    int id;\n} weight_t;\n\nvoid weight_swap(weight_t *a,weight_t *b){\n    weight_t tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n\nvoid pp_weight(weight_t *w, int w_size){\n    for(int i=0;i<w_size;i++){\n        cout << \"i: \" << i;\n        cout << \" w: \" << w[i].w;\n        cout << \" id: \" << w[i].id << endl;\n    }\n}\n\nint maxW(weight_t *w, int w_size){\n    int ans = w[0].w;\n    for(int i=0;i<w_size;i++){\n        if(ans < w[i].w){\n            ans = w[i].w;\n        }\n    }\n    return ans;\n}\n\nint minW(weight_t *w, int w_size){\n    int ans = w[0].w;\n    for(int i=0;i<w_size;i++){\n        if(ans > w[i].w){\n            ans = w[i].w;\n        }\n    }\n    return ans;\n}\n\nvoid countingSort(weight_t *w, int w_size){\n    int max_w = maxW(w, w_size) + 1;\n    int *c = NULL;\n    c= new int[max_w];\n    for(int i=0;i<max_w;i++) c[i] = 0;\n    for(int i=0;i<w_size;i++) c[w[i].w]++;\n    for(int i=1;i<max_w;i++) c[i] = c[i] + c[i-1];\n    for(int i=w_size-1;i>=0;i--){\n        w[i].id = c[w[i].w]-1;\n        c[w[i].w]--;\n    }\n    delete [] c;\n}\n\nint checkmin(weight_t *w, int w_size){\n    int ans = -1;\n    int min_weight =MAX;\n    for(int i=0;i<w_size;i++){\n        if(i != w[i].id){\n            if(min_weight > w[i].w){\n                min_weight = w[i].w;\n                ans = i;\n            }\n        }\n    }\n    return ans;\n}\n\nint changed_ahead(weight_t *w, int w_size, int id){\n    for(int i=0;i<w_size;i++){\n        if(id == w[i].id){\n            return i;\n        }\n    }\n    return -1;\n}\n\nint swap_cost = 0;\n\nvoid circuitExchange(weight_t *w, int w_size, int changed_id, int counting){\n    // cout << \"circuit\"<<endl;\n    int goal = w[changed_id].id;\n    int ahead = changed_ahead(w,w_size,changed_id);\n    // cout << \"id: \" << changed_id << \" goal: \" << goal;\n    // cout << \" ahead: \" << ahead << endl;\n    if(ahead == goal){\n        // cout << \"calc\" << endl;\n        swap_cost += w[ahead].w;\n        counting++;\n        int no_use_min = counting * w[changed_id].w;\n        int use_min = (counting + 2) * minW(w,w_size) + 2* w[changed_id].w;\n        // cout << \"no_use: \" << no_use_min;\n        // cout << \" use: \" << use_min <<endl;\n        // cout << \"swap :\" << swap_cost << endl;\n        swap_cost += (no_use_min < use_min) ? no_use_min : use_min;\n                // cout << \"swap :\" << swap_cost << endl;\n        weight_swap(w+ahead,w+changed_id);\n        // pp_weight(w,w_size);\n        // cout << \"finish cals\" << endl;\n    }else{\n        swap_cost += w[ahead].w;\n        weight_swap(w+ahead,w+changed_id);\n        // pp_weight(w,w_size);\n        // cout << \"next\" << endl;\n        circuitExchange(w,w_size,ahead,counting + 1);\n    }\n\n}\n\nvoid minimumCostSort(weight_t *w, int w_size){\n    int min_w = minW(w,w_size);\n    int prev_min = -1;\n    int change_min;\n    while((change_min = checkmin(w,w_size)) != -1){\n        // cout << \"start cost\" <<endl;\n        circuitExchange(w,w_size,change_min,0);\n        // cout << \"end cost\" <<endl;\n    }\n}\n\nint main(){\n    int n;\n    cin >> n;\n    weight_t *w = new weight_t[n];\n    for(int i=0;i<n;i++) cin >> w[i].w;\n    countingSort(w,n);\n    // pp_weight(w,n);\n    minimumCostSort(w,n);\n    cout << swap_cost << endl;\n    \n    delete [] w;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(void){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n; cin >> n;\n  vector<int> w(n), v(n);\n  int map[1000];\n  memset(map, -1, sizeof(map));\n  for(int i = 0; i < n; i++) cin >> w[i];\n  for(int i = 0; i < n; i++) map[w[i]] = i;\n\n  v = w;\n  sort(v.begin(), v.end());\n\n  int ans = 0;\n  for(int i = 0; i < n; i++){\n    /*\n    for(int j = 0; j < n; j++) cout << v[j] << \" \";\n    cout << endl;\n    */\n    if(v[i] == w[i]){\n      continue;\n    }else{\n      ans += v[i] + w[i];\n      swap(v[i], v[ map[v[i]] ]);\n      //cout << i << \" \" << map[v[i]] << endl;\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define FOR(i, s, e) for(int i = s; i < e; ++i)\nusing namespace std;\nstruct Data\n{\n\tData() :w(0), from(0), to(0), load(0){}\n\tint w;\n\tint from;\n\tint to;\n\tint load;\n};\nstruct DataWeightComparator\n{\n\tbool operator()(const Data* d1, const Data* d2)\n\t{\n\t\treturn (d1->w < d2->w);\n\t}\n};\nstruct DataLoadComparator\n{\n\tbool operator()(const Data* d1, const Data* d2)\n\t{\n\t\treturn (d1->load < d2->load);\n\t}\n};\n\nstatic Data* \nGetMinLoadData(Data* d1, Data* d2)\n{\n\tif (0 == d1) return d2;\n\tif (0 == d2) return d1;\n\treturn (d1->load > d2->load ? d2 : d1);\n}\n\nstruct SegmentTree\n{\n\tint base;\n\tvector<Data*> vS;\n\tvoid init(int n)\n\t{\n\t\tbase = 1;\n\t\twhile (base < n) base *= 2;\n\t\tint s = 2 * base - 1;\n\t\tvS.reserve(s);\n\t\twhile(s--) vS.push_back(0);\n\t}\n\n\tvoid update(int t, Data* d){\n\t\tint r = t + base - 1;\n\t\tvS[r] = d;\n\t\twhile (r > 0){\n\t\t\tr = (r - 1) / 2;\n\t\t\tvS[r] = GetMinLoadData(vS[2 * r + 1], vS[2 * r + 2]);\n\t\t}\n\t}\n\n\tData* query(int a, int b, int k, int l, int r)\n\t{\n\t\tif (r <= a || b <= l)\n\t\t\treturn 0;\n\t\telse if (a <= l && r <= b)\n\t\t\treturn vS[k];\n\t\telse{\n\t\t\tint m = (l + r) / 2;\n\t\t\tData* lm = query(a, b, 2 * k + 1, l, m);\n\t\t\tData* mr = query(a, b, 2 * k + 2, m, r);\n\t\t\treturn GetMinLoadData(lm, mr);\n\t\t}\n\t}\n\n\tData* query(int a, int b)\n\t{\n\t\treturn query(a, b + 1, 0, 0, base);\n\t}\n};\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<Data*> vD, vW, vL;\n\tvD.reserve(n);\n\tFOR(i, 0, n){\n\t\tData* d = new Data();\n\t\tcin >> d->w;\n\t\td->from = i;\n\t\tvD.push_back(d);\n\t}\n\tvW = vD;\n\tsort(vW.begin(), vW.end(), DataWeightComparator());\n\n\tSegmentTree tree;\n\ttree.init(n);\n\tFOR(i, 0, n){\n\t\tvW[i]->to = i;\n\t\tif (vW[i]->from == vW[i]->to){\n\t\t\tvW[i]->load = 0;\n\t\t\ttree.update(i, 0);\n\t\t}else{\n\t\t\tvW[i]->load = vD[vW[i]->from]->w + vD[vW[i]->to]->w;\n\t\t\ttree.update(i, vW[i]);\n\t\t}\n\t}\n\n\tint c = 0, from, to;\n\tData* d;\n\twhile ((d = tree.query(0, n - 1)) != 0)\n\t{\n\t\tto = d->to;\n\t\tfrom = d->from;\n\t\tc += d->load;\n\t\tswap(vD[to], vD[from]);\n\t\tvD[to]->from = to;\n\t\tvD[from]->from = from;\n\t\ttree.update(to, 0);\n\t\tif (vW[from]->from == vW[from]->to){\n\t\t\tvD[from]->load = 0;\n\t\t\ttree.update(from, 0);\n\t\t}else{\n\t\t\tvD[from]->load = vD[from]->w + vD[vW[from]->from]->w;\n\t\t\ttree.update(from, vD[from]);\n\t\t}\n\t}\n\n\tcout << c << \"\\n\";\n\tFOR(i, 0, n) delete vD[i];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint solve(){\n    int ans=0;\n\n    bool V[MAX];\n    for(int i=0; i<n; i++){\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B, B+n); // クイックソート\n\n    for(int i=0; i<n; i++) T[B[i]] = i; // 重さごとのインデックス\n    for(int i=0; i<n; i++){\n        if(V[i]) continue;\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while(1){\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m,v);\n            S += v;\n            cur = T[v];\n            if(V[cur]) break;\n        }\n        ans += min(S+(an-2)*m, m+S+(an+1)*s);\n    }\n    return ans;\n}\n\nint main(){\n    scanf(\"%d\", &n);\n    s = VMAX;\n    for(int i=0; i<n; i++){\n        scanf(\"%d\", &A[i]);\n        s = min(s, A[i]);\n    }\n    int ans = solve();\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve(){\n\tint ans = 0;\n\n\tbool V[MAX];\n\tfor (int i = 0; i < n; i++) {\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; i++)T[B[i]] = i;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (V[i])continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile (1) {\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS+= v;\n\t\t\tcur = T[[v];\n\t\t\tif (V[cur])break;\n\t\t}\n\t\tans += min(S + (an - 2)*m, m + S + (an + 1)*s);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tcin >> n;\n\ts = VMAX;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tint ans = solve();\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 10000;\nstatic const int VMAX = 100000;\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve(){\n    int i,ans = 0;\n    \n    bool V[MAX];\n    for(i=0;i<n;i++){\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B,B+n);\n    for(i=0;i<n;i++) T[B[i]] = i;\n    for(i=0;i<n;i++){\n        if(V[i]) continue;\n        int cur=i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while(1){\n            V[cur] = true;\n            an++;\n            int v=A[cur];\n            m = min(m,v);\n            S+=v;\n            cur = T[v];\n            if(V[cur]) break;\n        }\n        ans += min(S+(an-2)*m,m+S+(an+1)*s);\n    }\n    return ans;\n}\n\nint main(){\n    int i;\n    cin>>n;\n    s=VMAX;\n    for(i=0;i<n;i++){\n        cin>>A[i];\n        s=min(s,A[i]);\n    }\n    int ans = solve();\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nstruct unionfind\n{\n\t//rankのオーバーフローに注意\n\tvector<int> par, rank;\n\tunionfind(int n)\n\t{\n\t\tpar.resize(n);\n\t\trank.resize(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 1;\n\t\t}\n\t}\n\n\tbool same(int u, int v)\n\t{\n\t\treturn root(u) == root(v);\n\t}\n\n\tvoid unite(int u, int v)\n\t{\n\t\tif (same(u, v)) return;\n\t\tu = root(u), v = root(v);\n\t\tif (rank[u] > rank[v]) swap(u, v);\n\t\tpar[u] = v;\n\t\trank[v] += rank[u];\n\t}\n\n\tint root(int v)\n\t{\n\t\tif (par[v] == v) return v;\n\t\treturn par[v] = root(par[v]);\n\t}\n};\n\nvoid solve()\n{\n\tint N;\n\tcin >> N;\n\tvector<int> ws(N), cs(N);\n\tset<int> s;\n\tmap<int, int> mp;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> ws[i];\n\t\ts.insert(ws[i]);\n\t}\n\tint cnt = 0;\n\tfor (int v : s)\n\t{\n\t\tmp[v] = cnt++;\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcs[i] = mp[ws[i]];\n\t}\n\n\tunionfind uf(N);\n\tvector<int> es[N];\n\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tuf.unite(i, cs[i]);\n\t}\n\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tes[uf.root(cs[i])].push_back(ws[cs[i]]);\n\t\t//cout << cs[i] << ' ';\n\t}\n\t//cout << endl;\n\n\tint ans = 0;\n\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tauto e = es[i];\n\t\tint n = e.size(), x = INT_MAX;\n\t\tif (n < 2) continue;\n\t\tfor (int v : e)\n\t\t{\n\t\t\tans += v;\n\t\t\tx = min(v, x);\n\t\t}\n\t\tans += (n-2) * x;\n\t\t//cout << ans << endl;\n\t}\n\n\tcout << ans << endl;\n\n}\n\nint main(void)\n{\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * @copyright (c) 2020 Daisuke Hashimoto\n */\n\n#include <cstdint>\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nconstexpr int32_t kMaxArraySize = 1000;\nconstexpr int32_t kMaxValue = 10000;\n\nvoid CallMinimumCostSort(std::istream &input_stream);\n\nclass MinimumCostSort {\n public:\n  MinimumCostSort() noexcept;\n  ~MinimumCostSort() noexcept;\n  void AddData(const int32_t value);\n  void ResetData() noexcept;\n  void Sort();\n  int32_t CalculateMinimumCost();\n  void GenerateMapping();\n  int32_t CalculateMinimumCostOfLoop(const int32_t index_start);\n\n private:\n  MinimumCostSort(const MinimumCostSort &obj) noexcept = delete;\n  MinimumCostSort &operator=(const MinimumCostSort &obj) noexcept = delete;\n  MinimumCostSort(MinimumCostSort &&obj) = delete;\n  MinimumCostSort &operator=(MinimumCostSort &&obj) = delete;\n\n  int32_t CalculateCost(const int32_t end_index);\n  static int32_t MinimumCostUsingMinimumInLoop(const int32_t sum_of_weights_in_loop,\n                                               const int32_t number_of_nodes_in_loop,\n                                               const int32_t minimum_value_in_loop) noexcept;\n  int32_t MinimumCostUsingSharedMinimum(const int32_t sum_of_weights_in_loop, const int32_t number_of_nodes_in_loop,\n                                        const int32_t minimum_value_in_loop) const noexcept;\n\n  void ComputeMergeSort(const int32_t left_end, const int32_t right_end);\n  void MergeLeftAndRight(const int32_t left_end, const int32_t center, const int32_t right_end);\n  int32_t GetCenterIndex(const int32_t left_end, const int32_t right_end) const;\n\n private:\n  int32_t size_;\n  int32_t smallest_value_;\n  int32_t sorted_values_[kMaxArraySize];\n  int32_t input_values_[kMaxArraySize];\n  bool evaluated_[kMaxArraySize];\n  int32_t next_index_[kMaxValue + 1];\n\n  int32_t left_values_[kMaxArraySize / 2 + 1];   //< 作業領域\n  int32_t right_values_[kMaxArraySize / 2 + 1];  //< 作業領域\n};\n\nvoid CallMinimumCostSort(std::istream &input_stream) {\n  input_stream.tie(0);\n  std::ios::sync_with_stdio(false);\n  MinimumCostSort *minimum_cost_sort = new MinimumCostSort();\n  try {\n    int32_t count;\n    input_stream >> count;\n    for (int32_t index = 0; index < count; ++index) {\n      int32_t cvalue;\n      input_stream >> cvalue;\n      minimum_cost_sort->AddData(cvalue);\n    }\n    int32_t cost = minimum_cost_sort->CalculateMinimumCost();\n    std::cout << cost << std::endl;\n  } catch (...) {\n    std::cout << \"ERROR: CallMinimumCostSort()\" << std::endl;\n    throw;\n  }\n  delete minimum_cost_sort;\n}\n\n// ****************************************************\n\nMinimumCostSort::MinimumCostSort() noexcept\n    : size_(0),\n      smallest_value_(INT32_MAX),\n      sorted_values_{},\n      input_values_{},\n      evaluated_{},\n      next_index_{},\n      left_values_{},\n      right_values_{} {\n  for (bool &e : evaluated_) {\n    e = false;\n  }\n}\nMinimumCostSort::~MinimumCostSort() noexcept {}\n\nint32_t MinimumCostSort::CalculateMinimumCost() {\n  int32_t total_cost = 0;\n  try {\n    Sort();\n    GenerateMapping();\n    for (int32_t index_start = 0; index_start < size_; ++index_start) {\n      if (evaluated_[index_start]) {\n        // DO NOTHING\n      } else {\n        total_cost += CalculateMinimumCostOfLoop(index_start);\n      }\n    }\n  } catch (...) {\n    std::cout << \"ERROR: CalculateMinimumCost()\" << std::endl;\n    throw;\n  }\n  return total_cost;\n}\n\nint32_t MinimumCostSort::CalculateMinimumCostOfLoop(const int32_t index_start) {\n  if ((index_start < 0) || (index_start >= kMaxArraySize)) {\n    std::cout << \"ERROR: CalculateMinimumCostOfLoop(): invalid arg index_start = \" << index_start << std::endl;\n    throw 1;\n  }\n  int32_t current_index = index_start;\n  int32_t sum_of_weights_in_loop = 0;\n  int32_t minimum_value_in_loop = INT32_MAX;\n  int32_t number_of_nodes_in_loop = 0;\n  for (int32_t i = 0; i < size_; ++i) {\n    evaluated_[current_index] = true;\n    ++number_of_nodes_in_loop;\n    const int32_t cvalue = input_values_[current_index];\n    minimum_value_in_loop = std::min(cvalue, minimum_value_in_loop);\n    sum_of_weights_in_loop += cvalue;\n    current_index = next_index_[cvalue];\n    if ((current_index < 0) || (current_index >= kMaxArraySize)) {\n      std::cout << \"ERROR: CalculateMinimumCostOfLoop(): invalid current_index = \" << current_index << std::endl;\n      throw 1;\n    } else if (evaluated_[current_index]) {\n      break;\n    } else {\n      // DO NOTHING\n    }\n  }\n  const int32_t cost_of_loop =\n      std::min(MinimumCostUsingMinimumInLoop(sum_of_weights_in_loop, number_of_nodes_in_loop, minimum_value_in_loop),\n               MinimumCostUsingSharedMinimum(sum_of_weights_in_loop, number_of_nodes_in_loop, minimum_value_in_loop));\n  return cost_of_loop;\n}\n\nint32_t MinimumCostSort::MinimumCostUsingMinimumInLoop(const int32_t sum_of_weights_in_loop,\n                                                       const int32_t number_of_nodes_in_loop,\n                                                       const int32_t minimum_value_in_loop) noexcept {\n  const int32_t cost = sum_of_weights_in_loop + (number_of_nodes_in_loop - 2) * minimum_value_in_loop;\n  return cost;\n}\n\nint32_t MinimumCostSort::MinimumCostUsingSharedMinimum(const int32_t sum_of_weights_in_loop,\n                                                       const int32_t number_of_nodes_in_loop,\n                                                       const int32_t minimum_value_in_loop) const noexcept {\n  const int32_t cost = sum_of_weights_in_loop + minimum_value_in_loop + (number_of_nodes_in_loop + 1) * smallest_value_;\n  return cost;\n}\n\nvoid MinimumCostSort::GenerateMapping() {\n  for (int32_t index = 0; index < size_; ++index) {\n    const int32_t value = sorted_values_[index];\n    if ((value < 0) || (value > kMaxValue)) {\n      std::cout << \"ERROR: GenerateMapping(): Invalid value = \" << value << std::endl;\n      throw 1;\n    }\n    next_index_[value] = index;\n  }\n}\n\nvoid MinimumCostSort::AddData(const int32_t value) {\n  if (size_ >= kMaxArraySize) {\n    std::cout << \"ERROR: AddData(): Data size exceeded a limit = \" << kMaxArraySize << std::endl;\n    throw 1;\n  }\n  sorted_values_[size_] = value;\n  input_values_[size_] = value;\n  smallest_value_ = std::min(value, smallest_value_);\n  size_++;\n}\n\nvoid MinimumCostSort::Sort() {\n  try {\n    ComputeMergeSort(0, size_);\n  } catch (...) {\n    std::cout << \"ERROR: Sort()\" << std::endl;\n    throw;\n  }\n}\n\nvoid MinimumCostSort::ComputeMergeSort(const int32_t left_end, const int32_t right_end) {\n  if ((right_end < left_end) || ((left_end < 0) || (right_end > size_))) {\n    std::cout << \"ERROR: ComputeMergeSort: invalid args. left_end=\" << left_end << \", right_end=\" << right_end\n              << std::endl;\n    throw 1;\n  }\n  try {\n    if (left_end + 1 < right_end) {\n      const int32_t center = GetCenterIndex(left_end, right_end);\n      ComputeMergeSort(left_end, center);\n      ComputeMergeSort(center, right_end);\n      MergeLeftAndRight(left_end, center, right_end);\n    } else {\n      // DO NOTHING\n    }\n  } catch (...) {\n    std::cout << \"ERROR: ComputeMergeSort()\" << std::endl;\n    throw;\n  }\n}\n\nvoid MinimumCostSort::MergeLeftAndRight(const int32_t left_end, const int32_t center, const int32_t right_end) {\n  // endは右端indexの右一つ隣のindex (無効領域の先頭)left_end(有効) < center(有効) < right_end(無効)\n  if (((left_end < 0) || (right_end > size_) || (center <= left_end) || (right_end <= center))) {\n    std::cout << \"ERROR: MergeLeftAndRight: invalid args. left_end=\" << left_end << \", center=\" << center\n              << \", right_end=\" << right_end << std::endl;\n    throw 1;\n  }\n  const int32_t left_size = center - left_end;\n  const int32_t right_size = right_end - center;\n  if (left_size > kMaxArraySize / 2) {\n    std::cout << \"ERROR: MergeLeftAndRight: Invalid left_size. left_size=\" << left_size << std::endl;\n    throw 1;\n  } else if (right_size > kMaxArraySize / 2) {\n    std::cout << \"ERROR: MergeLeftAndRight: Invalid right_size. right_size=\" << right_size << std::endl;\n    throw 1;\n  }\n  try {\n    for (int32_t index_left = 0; index_left < left_size; ++index_left) {\n      left_values_[index_left] = sorted_values_[left_end + index_left];\n    }\n    left_values_[left_size] = INT32_MAX;\n    for (int32_t index_right = 0; index_right < right_size; ++index_right) {\n      right_values_[index_right] = sorted_values_[center + index_right];\n    }\n    right_values_[right_size] = INT32_MAX;\n\n    int32_t index_left = 0;\n    int32_t index_right = 0;\n    for (int32_t index_target = left_end; index_target < right_end; ++index_target) {\n      if (left_values_[index_left] <= right_values_[index_right]) {\n        sorted_values_[index_target] = left_values_[index_left];\n        ++index_left;\n      } else {\n        sorted_values_[index_target] = right_values_[index_right];\n        ++index_right;\n      }\n    }\n  } catch (...) {\n    std::cout << \"ERROR: MergeLeftAndRight()\" << std::endl;\n    throw;\n  }\n}\n\nint32_t MinimumCostSort::GetCenterIndex(const int32_t left_end, const int32_t right_end) const {\n  // endは右端indexの右一つ隣のindex (無効領域の先頭)left_end(有効) < center(有効) < right_end(無効)\n  if ((right_end <= left_end + 1) || ((left_end < 0) || (right_end > size_))) {\n    std::cout << \"ERROR: GetCenterIndex: invalid args. left_end=\" << left_end << \", right_end=\" << right_end\n              << std::endl;\n    throw 1;\n  }\n  return (left_end + right_end) / 2;\n}\n\nvoid MinimumCostSort::ResetData() noexcept {\n  size_ = 0;\n}\n\nint main(int argc, char *argv[]) {\n  try {\n    CallMinimumCostSort(std::cin);\n  } catch (...) {\n    std::cout << \"ERROR: main()\" << std::endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <queue>\n#include <string>\n#include <set>\n#include <vector>\n\n#define FOR(i, l, r) for (i = (l); i < r; i++ )\n\nusing namespace std;\ntypedef long long ll;\n#define MAX_N (1010)\n#define MAX_V (10010)\n\nint n;\nint A[MAX_N];\nint g_min = MAX_V;\t\t// global min\nint B[MAX_N];\t\t\t// sorted array\nint T[MAX_V];\t\t\t// index of sorted array\nbool V[MAX_N];\t\t\t// check whether it is already used.\n\nint solve() {\n    for ( int i = 0; i < n; i++ ) {\n\tV[i] = false;\n\tB[i] = A[i];\n    }\n\n    sort(B, B + n);\n\n    for ( int i = 0; i < n; i++ ) {\n\tT[B[i]] = i;\n    }\n\n    int ret = 0;\n    for ( int i = 0; i < n; i++ ) {\n\tif ( V[i] ) continue;\n\t// has not visited yet.\n\tint cur = i;\n\tint num = 0;\n\tint l_min = MAX_V;\t// local min\n\tint sum_l = 0;\n\twhile ( 1 ) {\n\t    V[cur] = true;\n\t    num++;\n\t    l_min = min(l_min, A[cur]);\n\t    sum_l += A[cur];\n\t    cur = T[A[i]];\n\t    if ( V[cur] ) break; // \n\t}\n\tint c0 = sum_l + (num - 2) * l_min;\n\tint c1 = sum_l + l_min + (num + 1) * g_min;\n\tret += min(c0, c1);\n    }\n    return ret;\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    \n    for ( int i = 0; i < n; i++ ) {\n\tscanf(\"%d\", &A[i]);\n\tg_min = min(g_min, A[i]);\n    }\n\n    int ans = solve();\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n\n  long long int n;\n  cin >> n;\n\n  vector< long long int > v, vs;\n\n  for ( long long int i = 0; i < n; i++ ) {\n\n    long long int in;\n    cin >> in;\n    v.push_back( in );\n    vs.push_back( in );\n\n  }\n\n  sort( vs.begin(), vs.end() );\n\n  vector< long long int > t;\n\n  for ( long long int i = 0; i < n; i++ ) {\n    for ( long long int j = 0; j < n; j++ ) {\n      if ( vs[i] == v[j] ) {\n\tt.push_back( j );\n\tbreak;\n      }\n    }\n  }\n\n  long long int ans = 0;\n  long long int c = -1;\n  long long int m = 0;\n\n  for ( long long int i = 0; i < n; i++ ) {\n\n    for ( long long int j = 0; j < n; j++ ) {\n\n      if ( vs[j] != v[j] ) {\n\n\tlong long int k = v[j];\n\tif ( c == -1 || m > k ) {\n\t  c = j;\n\t  m = k;\n\t}\n\n      }\n\n    }\n\n    if ( c == -1 ) break;\n\n    ans += v[c] + v[ t[c] ];\n    swap( v[c], v[ t[c] ] );\n    for ( long long int j = 0; j < n; j++ ) {\n      if ( t[j] == c ) {\n\tt[j] = t[c];\n      }\n    }\n    c = -1;\n\n    /*\n    for ( long long int j = 0; j < n; j++ ) {\n      cout << \" \" << v[j];\n    }\n    cout << endl;\n    */\n\n  }\n\n  cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\n#include <cstdint>\n\nusing namespace std;\n\nint main() {\n    int32_t n;\n\n    cin >> n;\n    vector<int32_t> w(n);\n    for (int32_t i = 0; i < n; i++) {\n        cin >> w[i];\n    }\n\n    vector<int32_t> sorted(w);\n    sort(sorted.begin(), sorted.end());\n\n    unordered_map<int32_t, int32_t> index;\n    for (int32_t i = 0; i < n; i++) {\n        index[sorted[i]] = i;\n    }\n\n    int32_t cost = 0;\n    for (int32_t i = 0; i < n; i++) {\n        if (w[i] != sorted[i]) {\n            int32_t size = 1, sum = w[i], minval = INT32_MAX;\n            int32_t j = index[w[i]], j_new;\n            while (j != i) {\n                size++;\n                sum += w[j];\n                minval = min(minval, w[j]);\n                j_new = index[w[j]];\n                w[j] = sorted[j];\n                j = j_new;\n            }\n\n            cost += sum + minval * (size - 2);\n        }\n    }\n\n    cout << cost << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int MAXN=1000+2;\nint ans,n;\nint w[MAXN],a[MAXN];\n\nint check(){\n\tfor(int i=0;i<n;++i) if(w[i]!=a[i]) return 0;\n\treturn 1;\n}\n\nint main(){\n\tcin>>n;\n\tfor(int i=0;i<n;++i){\n\t\tcin>>w[i]; a[i]=w[i];\n\t}\n\tsort(a,a+n);\n\twhile(1){\n\t\tif(check()) break;\n\t\tint now=10001,m1,m2;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tint j=0;\n\t\t\tfor(;j<n;++j) if(a[j]==w[i]) break;\n\t\t\tif(i!=j && w[i]+w[j]<now) now=w[i]+w[j],m1=i,m2=j;\n\t\t}\n\t\tans+=now;\n\t\tswap(w[m1],w[m2]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint do_cycle(vector<int> &v,int x){\n\tint s=0,m=1<<30;\n\tfor(auto &e:v)s+=e,m=min(m,e);\n\treturn min(s+(v.size()-2)*m,s+m+(v.size()+1)*x);\n}\n\nint main(){\n\tint N,x=1<<30,r;\n\tscanf(\"%d\",&N);\n\tvector<int>v(N),b(N),se(N);\n\tmap<int,int>m;\n\tvector<vector<int> >cycles;\n\tfor(int i=0;i<N;i++)scanf(\"%d\",&v[i]),x=min(x,v[i]),se[i]=v[i];\n\tsort(se.begin(),se.end());\n\tint i=0;for(auto &e:se){m[e]=i++;}\n\tfor(int i=0;i<N;i++)if(!b[i]){\n\t\tvector<int>cycle;\n\t\tint k=i;\n\t\tdo{\n\t\t\tcycle.push_back(se[k]);\n\t\t\tb[k]=1;\n\t\t\tk=m[v[k]];\n\t\t}while(k!=i);\n\t\tr+=do_cycle(cycle,x);\n\t}\n\tprintf(\"%d\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef vector<lli> vll;\n\nlli n;\nvll w;\nvll w_;\nlli ans = 0;\nmap<lli,lli> m;\n\n\n\nint main(){\n\tcin >> n;\n\tw = vll(n);\n\tw_ = vll(n);\n\tfor(lli i = 0;i < n;i++) cin >> w[i];\n\tfor(lli i = 0;i < n;i++) w_[i] = i;\n\tsort(w_.begin(),w_.end(),[](lli a,lli b){\n\t\treturn w[a] < w[b];\n\t});\n\tfor(lli i = 0;i < n;i++){\n\t\twhile(w_[i] != i){\n\t\t\tans += w[w_[i]] + w[w_[w_[i]]];\n\t\t\t//cout << w[w_[i]] << \" \" << w[w_[w_[i]]] << endl;\n\t\t\tswap(w[w_[i]],w[w_[w_[i]]]);\n\t\t\tswap(w_[i],w_[w_[i]]);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstatic const int MAX=1000;\nstatic const int VMAX=10000;\n\nint n, A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve() {\n  int ans=0;\n  bool V[MAX];\n  for (int i=0; i<n; i++) {\n    B[i]=A[i];\n    V[i]=false;\n  }\n  sort(B,B+n);\n  for (int i=0; i<n; i++) {\n    T[B[i]]=i;\n  }\n  for (int i=0; i<n; i++) {\n    if (V[i]) {\n      continue;\n    }\n    int cur=i;\n    int S=0;\n    int m=VMAX;\n    int an=0;\n    while (true) {\n      V[cur]=true;\n      an++;\n      int v=A[cur];\n      m=min(m,v);\n      S+=v;\n      cur=T[v];\n      if (V[cur]) {\n        break;\n      }\n    }\n    ans+=min(S+(an-2)*m,m+S+(an+1)*S);\n  }\n  return ans;\n}\nint main() {\n  cin>>n;\n  s=VMAX;\n  for (int i=0; i<n; i++) {\n    cin>>A[i];\n    s=min(s,A[i]);\n  }\n  int ans=solve();\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <iostream>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#define INTINF 2147483647\n#define LLINF 9223372036854775807\n#define MAX 1000\n#define VMAX 10000\ntypedef long long ll;\nusing namespace std;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint solve(){\n  int ans=0;\n\n  bool V[MAX];\n  for (size_t i = 0; i < n; i++) {\n    B[i]=A[i];\n    V[i]=false;\n  }\n  sort(B, B+n);\n\n  for (size_t i = 0; i < n; i++) T[B[i]]=i;\n  for (size_t i = 0; i < n; i++) {\n    if (V[i]) continue;\n    int cur = i;\n    int S = 0;\n    int m = VMAX;\n    int A_n = 0;\n    while (1) {\n      V[cur] = true;\n      A_n++;\n      int v = A[cur];\n      m = min(m, v);\n      S += v;\n      cur = T[v];\n      if (V[cur]) break;\n    }\n    ans += min(S + (A_n-2) * m, S + m + (A_n + 1)*s );\n  }\n\n\n}\n\nint main(int argc, char const *argv[]) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  std::cin >> n;\n  s = VMAX;\n\n  for (size_t i = 0; i < n; i++) {\n    std::cin >> A[i];\n    s = min(s, A[i]);\n  }\n  int cost = solve();\n\n  std::cout << cost << '\\n';\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n \nvoid qsort(int a[],int left,int right){\n     \n    int p=(left+right)/2;\n    int pivot=a[p];\n    int i,temp;\n    if(left<right){\n        p=left;\n        pivot=a[p];\n        for(i=left+1;i<=right;i++){\n            if(a[i]<pivot){\n                p++;\n                temp=a[i];a[i]=a[p];a[p]=temp;//swap\n            }\n        }\n        temp=a[left];a[left]=a[p];a[p]=temp;//swap\n        qsort(a,left,p-1);\n        qsort(a,p+1,right);\n    }\n \n}\n \nint search(int key,int a[],int n){\n    int i;\n    for(i=0;i<n;i++){\n        if(key==a[i])return i;\n    }\n     \n    return i;\n}\n \nint isVisited(int v[],int n){\n    int i;\n    for(i=0;i<n;i++){\n        if(v[i]!=1)return -1;\n    }\n    return 1;\n}\n     \nint min(int a,int b){\n    if(a<b)return a;\n    return b;\n}\n \n \nint main(void){\n    int n,i,j,minW,cost=0,w;\n    int a[1000],b[1000],v[1000];\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&a[i]);\n        b[i]=a[i];\n        v[i]=0;\n    }\n    qsort(b,0,n-1);\n     \n    for(i=0;i<n;i++){    \n        int x=i;\n        int sum=0;\n        int count=0;\n        minW=10000;\n        while(v[x]==0){\n            v[x]=1;\n            sum+=a[x];\n            count++;\n            if(minW>a[x])minW=a[x];\n            x=search(a[x],b,n);\n        }\n        if(count<2)continue;\n         \n        cost+=min(b[0]*(count+1)+sum+minW,sum+(count-2)*minW);\n        if(isVisited(v,n)==1)break;\n    }\n     \n    printf(\"%d\\n\",cost);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define MAX_N 10000\n#define MAX_V 100000000\n#define INF 1000000000\n\nint n, A[MAX_N], s, B[MAX_N], T[MAX_V];\n\nint minimum_cost_sort() {\n\tint ans = 0;\n\tbool V[MAX_N];\n\tfor (int i = 0; i < MAX_V; i++) { V[i] = false; }\n\tfor (int i = 0; i < n; i++) { B[i] = A[i]; }\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; i++) { T[B[i]] = i; }\n\tfor (int i = 0; i < n; i++) {\n\t\tif (V[i]) { goto owata; }\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = INF;\n\t\tint x = 0;\n\t\twhile (1) {\n\t\t\tV[cur] = true;\n\t\t\tx++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif (V[cur]) { break; }\n\t\t}\n\t\tans += min(S + (x - 2)*m, m + S + (x + 1)*s);\n\towata:;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tcin >> n;\n\ts = INF;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tcout << minimum_cost_sort() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\n\nint num[1005],n,a[1005];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&num[i]);\n\t\ta[i] = num[i];\n\t}\n\tsort(a+1,a+n+1);\n\tint res = 0;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tif(num[i] == a[i]) continue;\n\t\tint id;\n\t\tfor(int j=1;j<=n;j++) if(num[j] == a[i]) id = j;\n\t\tswap(num[id],num[i]);\n\t\tres += (num[id]+num[i]);\n\t}\n\tprintf(\"%d\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdlib.h>\n#include <iostream>\n#include <climits>\nusing namespace std;\n\nstruct weight{\n\tint val;\n\tint id;\n\tweight(){\n\t\tval = 0;\n\t\tid  = 0;\n\t}\n\tweight(weight *w){\n\t\tval = w->val;\n\t\tid  = w->id;\n\t}\n\tvoid set(weight *w){\n\t\tval = w->val;\n\t\tid  = w->id;\n\t}\n};\n\nvoid merge_sort(weight *array, int left, int right);\nvoid merge(weight *array, int left, int mid, int right);\nvoid swap(weight *a, weight *b);\nint cal_min_swap(weight *original, weight *sorted, int num);\nint linear_search(weight *array, int size, int num);\n\nint main(){\n\tint n;\n\n\tcin >> n;\n\n\tweight* original = (weight*)malloc(n * sizeof(weight));\n\tweight* sorted   = (weight*)malloc(n * sizeof(weight));\n\tint result = 0;\n\n\tif(n < 1){\n\t\treturn 0;\n\t}\n\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> original[i].val;\n\t\toriginal[i].id = i;\n\t\tsorted[i].set(&original[i]);\n\t}\n\n\tmerge_sort(sorted, 0, n);\n\tcout << cal_min_swap(original, sorted, n) << endl;\n\treturn 0;\n}\n\nvoid merge_sort(weight *array, int left, int right){\n\tif(left+1 < right){\n\t\tint mid = (left + right) >> 1;\n\t\tmerge_sort(array, mid, right);\n\t\tmerge_sort(array, left, mid);\n\t\tmerge(array, left, mid, right);\n\t}\n\n}\n\nvoid merge(weight *array, int left, int mid, int right){\n\tint n1 = mid - left;\n\tint n2 = right - mid;\n\n\tweight* L = (weight*)malloc((n1+1) * sizeof(weight));\n\tweight* R = (weight*)malloc((n2+1) * sizeof(weight));\n\n\tfor(int i = 0; i < n1; ++i){\n\t\tL[i].set(&array[left+i]);\n\t}\n\tL[n1].val = INT_MAX;\n\tfor(int i = 0; i < n2; ++i){\n\t\tR[i].set(&array[mid+i]);\n\t}\n\tR[n2].val = INT_MAX;\n\n\tint i = 0;\n\tint j = 0;\n\tfor(int k = left; k < right; ++k){\n\t\tif(L[i].val <= R[j].val){\n\t\t\tarray[k].set(&L[i]);\n\t\t\t++i;\n\t\t}else{\n\t\t\tarray[k].set(&R[j]);\n\t\t\t++j;\n\t\t}\n\t}\n}\n\nvoid swap(weight *a, weight *b){\n\tweight *temp = new weight(b);\n\tb->set(a);\n\ta->set(temp);\n\tfree(temp);\n}\n\nint cal_min_swap(weight *original, weight *sorted, int num){\n\tint total_swap_w = 0;\n\tint temp_i = 0;\n\tbool is_swap = false;\n\tint swap_num = 0;\n\tint min = sorted[0].val;\n\tint this_min = 0;\n\tint this_total_swap_num = 0;\n\tstring test;\n\tfor(int i = 0; i < num; ++i){\n\t\t//???????????¨??´????????°??????\n\t\tif(original[i].id != sorted[i].id){\n\t\t\tif(!is_swap){\n\t\t\t\ttemp_i = i;\n\t\t\t\tswap_num = 0;\n\t\t\t\tthis_min = sorted[i].val;\n\t\t\t\tthis_total_swap_num = 0;\n\t\t\t}\n\t\t\tthis_total_swap_num += original[i].val;\n\t\t\tint swap_i = linear_search(sorted, num, original[i].val);\n\t\t\tswap(&sorted[i], &sorted[swap_i]);\n\t\t\ti = swap_i - 1;\n\t\t\tis_swap = true;\n\t\t\tswap_num++;\n\t\t\tcontinue;\n\t\t}\n\t\t//???????????¨????????´???\n\t\tif(!is_swap){\n\t\t\tcontinue;\n\t\t}\n\t\tthis_total_swap_num += this_min;\n\n\t\t//???????????°???2?????\\?????????????°??????¨????????????????¨?\n\t\tif(swap_num != 1){\n\t\t\tif(min*swap_num + 2*(min + this_min) < this_min*swap_num){\n\t\t\t\tthis_total_swap_num += min*swap_num + 2*min + this_min;\n\t\t\t}else{\n\t\t\t\tthis_total_swap_num += this_min*(swap_num-1);\n\t\t\t}\n\t\t}\n\t\ttotal_swap_w += this_total_swap_num;\n\t\tthis_total_swap_num = 0;\n\t\ti = temp_i;\n\t\tis_swap = false;\n\t}\n\treturn total_swap_w;\n}\nint linear_search(weight *array, int size, int num){\n\tfor(int i = 0; i < size; ++i){\n\t\tif(array[i].val == num){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing ll = long long;\nusing namespace std;\n\n/* initialize */\nint n, A[1010], cost =0;\npair<int, int> P[1010], Q[1010];\n/* main */\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; ++i) scanf(\"%d\", &A[i]);\n    for (int i = 0; i < n; ++i) {\n        P[i].first = A[i]; P[i].second = i;\n    }\n    sort(P, P+n);\n    for (int i = 0; i < n; ++i) {\n        Q[i].first = A[i];\n        Q[P[i].second].second = i;\n    }\n    int s = P[1].first;\n    for (int i = 0; i < n; ++i) {\n        int j = Q[i].second;\n        if(j >= 0 && j != 1){\n            int m = 1, amin, sum;\n            amin=sum=Q[i].first;\n            while(j!=i){\n                int next = Q[j].second;\n                if(next<amin) amin = Q[j].first;\n                sum +=Q[j].first;\n                m++;\n                Q[j].second=-1;\n                j=next;\n            }\n            cost += min(sum+(m-2)*amin, sum+amin+(n+1)*s);\n        }\n    }\n    cout << cost << \"\\n\";\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <unordered_map>\n#include <vector>\n#include <algorithm>\n\nint main(){\n    int n;\n    std::scanf(\"%d\", &n);\n    std::vector<int> a(n, 0);\n    std::vector<int> b(n, 0);\n    std::unordered_map<int, int> hash;\n    for(int i = 0; i < n; ++i){\n        std::scanf(\"%d\", &a[i]);\n        b[i] = a[i];\n        hash.insert(std::make_pair(a[i], i));\n    }\n    std::sort(b.begin(), b.end());\n\n    int totalCost = 0;\n    int i = 0;\n    int s = b[0];\n    for(int i = 0; i < n; ++i){\n        if(a[i] == b[i]) continue;\n        int sum = 0;\n        int op = 0;\n        while(1){\n            ++op;\n            std::pair<int, int> minp;\n            minp.first = hash.find(b[i])->second;\n            minp.second = hash.find(b[minp.first])->second;\n            sum += a[minp.second];\n            std::swap(a[minp.first], a[minp.second]);\n            hash.find(b[i])->second = minp.second;\n            hash.find(b[minp.first])->second = minp.first;\n            if(a[i] == b[i]) break;\n        }\n        totalCost += std::min(sum + op * b[i], sum + (op + 2) * s + 2 * b[i]);\n    }\n    std::printf(\"%d\\n\", totalCost);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nint n;\nint w[10001];\nint f[10001];\nint edge[10001];\nbool used[10001];\nvector<int> vs;\n\nvoid dfs(int v){\n\tused[v]=true;\n\tvs.push_back(w[v]);\n\tif(!used[edge[v]])dfs(edge[v]);\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&w[i]);\n\t\tf[i]=w[i];\n\t}\n\tsort(f,f+n);\n\tll res=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(f[i]==w[i])edge[i]=i;\n\t\telse edge[i]=lower_bound(f,f+n,w[i])-f;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(edge[i]!=i){\n\t\t\tvs.clear();\n\t\t\tdfs(i);\n\t\t\tint all=vs[0];\n\t\t\tint minx=vs[0];\n\t\t\tfor(int j=1;j<vs.size();j++){\n\t\t\t\tminx=min(minx,vs[j]);\n\t\t\t\tall+=vs[j];\n\t\t\t}\n\t\t\tres+=min(all+(vs.size()-2)*minx,all+(vs.size()+2)*f[0]+minx);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n\n//?£wi + (n - 2) * min(wi)\n//or\n//?£wi + min(wi) + (n+1) * x\n\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint A[MAX];\nint B[MAX];\nbool V[MAX];\nint T[VMAX];\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint s = VMAX;\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &A[i]);\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t\ts = min(s, A[i]);\n\t}\n\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tT[B[i]] = i;\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (V[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile (1) {\n\t\t\tV[cur] = true;\n\t\t\tm = min(m, A[cur]);\n\t\t\tint v = A[cur];\n\t\t\tS += v;\n\t\t\t++an;\n\t\t\tcur = T[v];\n\t\t\tif (V[cur] == true) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tans += min(S + (an - 2) * m, S + m + (an + 1) * s);\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<algorithm>\n#include<iostream>\n#include<map>\n#include<vector>\nint main(void) {\n\tstd::ios_base::sync_with_stdio(false);\n\tint n, input;\n\tstd::cin >> n;\n\tstd::map<int, int>w;\n\tstd::vector<int>vector(n);\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tstd::cin >> input;\n\t\tw[input - 1] = i;\n\t\tvector[i] = input-1;\n\t}\n\tstd::vector<int>vector_min= vector;\n\tstd::map<int, int>w_1(w);\n\tstd::sort(vector_min.begin(), vector_min.end());\n\tfor (int i = 0; i < n; ++i) {\n\t\tw[vector[i]] = vector_min[i];\n\t}\n\tint cnt = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint temp = 0;\n\t\twhile (vector_min[i] != w[vector_min[i]]) {\n\t\t\ttemp += vector_min[i] + w[vector_min[i]] + 2;\n\t\t\tstd::swap(w[vector_min[i]],w[w[vector_min[i]]] );\n\t\t}\n\t\tint temp_1 = 0;\n\t\tif (i>0&&vector_min[i] != w_1[vector_min[i]]) {\n\t\t\ttemp_1 +=  w_1[vector_min[i]]+ w_1[vector_min[0]] + 2;\n\t\t\tstd::swap(w_1[vector_min[0]], w_1[vector_min[i]]);\n\t\t\twhile (vector_min[0] !=w_1[vector_min[i]]) {\n\t\t\t\ttemp_1 += w_1[vector_min[i]]+ w_1[vector_min[0]] + 2;\n\t\t\t\tstd::swap(w_1[vector_min[0]], w_1[w_1[vector_min[i]]]); }\n\t\t}\n\t\tcnt += std::min(temp, temp_1);\n\t}\n\tstd::cout << cnt << std::endl;\n//\tsystem(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n,A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint solve(){\n\tint ans = 0;\n\t\n\tbool V[MAX];\n\tfor(int i=0; i<n; i++){\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B, B+n);\n\tfor(int i = 0; i<n; i++) T[B[i]] = i;\n\tfor(int i = 0; i<n; i++){\n\t\tif( V[i] ) continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile( 1 ){\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m,v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif ( V[cur] ) break;\n\t\t}\n\t\tans += min(S + (an - 2)* m, m+S+(an+1)*s);\n\t}\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> n;\n\ts = VMAX;\n\tfor(int i=0; i<n; i++){\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tint ans = solve();\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nint n;\nint w[10001];\nint f[10001];\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&w[i]);\n\t\tf[i]=w[i];\n\t}\n\tsort(f,f+n);\n\tll res=0;\n\tfor(int i=n-1;i>=1;i--){\n\t\tif(w[i]==f[i])continue;\n\t\tfor(int j=0;j<i;j++){\n\t\t\tif(w[j]==f[i]){\n\t\t\t\tswap(w[j],w[i]);\n\t\t\t\tres+=w[j]+w[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX = 1000, VMAX = 100001;\nint n, mn, A[MAX], B[MAX], T[VMAX];\nbool V[MAX];\n\nint solve() {\n    int res = 0;\n\n    for (int i = 0; i < n; i++) {\n        B[i] = A[i];\n        V[i] = false;\n    }\n\n    sort(B, B + n);\n\n    for (int i = 0; i < n; i++) T[B[i]] = i;\n    for (int i = 0; i < n; i++) {\n        if (V[i]) continue;\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while (1) {\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m, v);\n            S += v;\n            cur = T[v];\n            if (V[cur]) break;\n        }\n        res += min(S + (an - 2) * m, m + S + (an + 1) * mn);\n    }\n    return res;\n}\n\nint main(void) {\n    mn = VMAX;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> A[i];\n        mn = min(mn, A[i]);\n    }\n\n    cout << solve() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define MIN(X,Y) ((X)>(Y)?(Y):(X))\n\nusing namespace std;\nint w[2000],sa[2000],idx[2000];\nchar sorted[2000];\n\nint main(void) {\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=0; i<n; i++)\n        scanf(\"%d\",&w[i]), sa[i]=w[i];\n    sort(sa,sa+n);\n    for(int i=0; i<n; i++)\n        idx[i] = lower_bound(sa,sa+n,w[i])-sa;\n\n//    for(int i=0; i<n; i++)\n//        printf(\"%d \", idx[i]);\n//    printf(\"\\n\");\n\n    int min = sa[0];\n    int res = 0;\n    for(int i=0; i<n; i++) {\n        int rescur=0, j=i, localmin=30000, cnt=0;\n        if(sorted[j]) continue;\n        while(!sorted[j]) {\n            sorted[j]=1;\n            cnt++;\n            if(localmin > w[j]) localmin = w[j];\n            rescur+=w[j];\n            j = idx[j];\n        }\n//        printf(\"%d, %d, %d\\n\", rescur, localmin, cnt);\n//        printf(\"%d : %d\\n\",rescur+(cnt-2)*localmin, rescur+localmin+2*min+(cnt-1)*min);\n        res += MIN(rescur+(cnt-2)*localmin, rescur+localmin+2*min+(cnt-1)*min);\n    }\n    printf(\"%d\\n\",res);\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma warning (disable :4996)\n#include <iostream>\n#include <cstdio>\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1e9 + 7;\nconst int N = 2e5 + 10;\n\nconst int MAX = 1010;\nconst int VMAX = 10010;\n\nint n;       //本次最小成本排序所需应当所有元素均不相等 便于T记录\nint s;       //s记录序列A中最小元素，以便于进行“借整体最小元素”操作\nint A[MAX],B[MAX];  //A[MAX]记录元素读入的初始位置顺序，B[MAX]记录升序排序后元素\nint T[VMAX + 1]; //T[VMAX+1]记录出现元素A[i]的目标位置（B中所处位置） T[B[i]]=i;\n\n\nint solve() {\n\tbool V[MAX];  //V[MAX]记录序列中元素是否已发生交换到正确位置\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) { B[i] = A[i]; V[i] = false; }\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; i++) { T[B[i]] = i; }  //记录初始元素应到位置\n\tfor (int i = 0; i < n; i++) {\n\t\tif (V[i]) continue; //已正确摆放\n\t\tint cur = i;  //记录闭圆（需要交换所构成的圆）起点\n\t\tint S = 0; //闭圆中元素值的和\n\t\tint minn = VMAX; //记录闭圆中最小元素以便进行通过最小元素来移其他元素 （一共n个元素，移n-1次）\n\t\tint an = 0;  //记录闭圆中元素个数\n\t\twhile (1) {\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur]; //当前位置的元素值\n\t\t\tminn = min(minn, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];   //指向下一个元素\n\t\t\tif (V[cur]) break; //形成闭圆\n\t\t}\n\t\tans += min(S + (an - 2) * minn, minn + S + (an + 1) * s);\n\t\t//公式 ： 不借整体最小元素   S + (an - 2) * minn\n\t\t//借： S+(an-2)*minn+2*(minn+s)-(an-1)*(minn-s);\n\t}\n\treturn ans;\n}\n\nint main() {\n\tcin >> n;\n\ts = VMAX;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tint ans = solve();\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define Vi vector<int>\n#define FOR(i,s,e) for (int i=s; i<e; i++)\n#define ITER(v) v.begin(), v.end()\n\nconstexpr int MAX_N = 1000;\nconstexpr int MAX_VAL = 10001;\n\nint minCostSort(int* w, int* ref, int n, int minval) {\n    bool isfixed[MAX_N] = {0};\n    int cost = 0;\n    FOR(i,0,n) {\n        if (isfixed[i]) { continue; }\n        int fromindex = i;\n        int n_chain = 0;\n        int minelm_in_chain = MAX_VAL;\n        int sum = 0;\n        while (true) {\n            sum += w[fromindex];\n            isfixed[fromindex] = true;\n            ++n_chain;\n            if (minelm_in_chain > w[fromindex]) { minelm_in_chain = w[fromindex]; }\n            int destindex = distance(ref, lower_bound(ref, ref+n, w[fromindex]));\n            if (destindex == i) { break; }\n            fromindex = destindex;\n        }\n        if (n_chain < 2) { continue; }\n        cost += min(\n            sum + (n_chain-2) * minelm_in_chain,\n            sum + n_chain * minval + 2 * minelm_in_chain\n        );\n    }\n    return cost;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n\n    int w[MAX_N];\n    int ref[MAX_N];\n    int minval = MAX_VAL;\n    FOR(i,0,n) {\n        cin >> w[i];\n        ref[i] = w[i];\n        if (minval > w[i]) { minval = w[i]; }\n    }\n\n    sort(ref, ref+n);\n    int cost = minCostSort(w, ref, n, minval);\n    cout << cost << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iterator>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<map>\nusing namespace std;\n\nstruct val {\n  int n;\n  size_t i;\n  size_t rank;\n};\n\nbool operator<(val v1, val v2) {\n  return v1.n < v2.n;\n}\n\nval make_val(int n, size_t i) {\n  val v;\n  v.n = n;\n  v.i = i;\n  return v;\n}\n\nvector<val> ns;  // (value, orig_idx) pairs\nmap<vector<val>, int> costs;\nint min_cost(vector<val>);\n\nint main() {\n  size_t n; cin >> n;\n  int v;\n  for (size_t i = 0; i < n; ++i) {\n    cin >> v;\n    ns.push_back(make_val(v, i));\n  }\n  vector<val> ns_uns = ns;\n  sort(ns.begin(), ns.end());\n  costs[ns] = 0;  // cost of sorting sorted array is 0\n  for (size_t i = 0; i < n; ++i) {  // fine, because n is small (~1000)\n    ns_uns[ns[i].i].rank = i;\n  }\n  int cost = 0;\n  // preprocess: swap all \"free pairs\"\n  for (size_t i = 0; i < n; ++i) {\n    size_t r = ns_uns[i].rank;\n    if (r != i and ns_uns[r].rank == i) {\n      cost += ns_uns[i].n + ns_uns[r].n;\n      swap(ns_uns[i], ns_uns[r]);\n    }\n  }\n  cost += min_cost(ns_uns);\n  cout << cost << endl;\n}\n\n// returns min cost of sorting given vector\nint min_cost(vector<val> vv) {\n//  cout << \"Finding min cost for\";\n//  for (auto v : vv) cout << ' ' << v.n;\n//  cout << \"...\" << endl;\n  if (costs.count(vv)) {\n//    cout << \"Matched, returning cost \" << costs[vv] << endl;\n    return costs[vv];\n  }\n\n  map<size_t, int> costs_by_swap_choice;\n  for (size_t i = 0; i < vv.size(); ++i) {\n    size_t i_rank = vv[i].rank;\n    if (i_rank != i) {\n      swap(vv[i], vv[i_rank]);\n      costs_by_swap_choice[i] = vv[i].n + vv[i_rank].n + min_cost(vv);\n//      cout << \"Swapping index \" << i << \" would cost \" << costs_by_swap_choice[i] << endl;\n      swap(vv[i], vv[i_rank]);\n    }\n  }\n\n  int min_cost = numeric_limits<int>::max();\n  for (auto entry : costs_by_swap_choice) {\n//    cout << \"Considering index \" << entry.first << \" with cost \" << entry.second << endl << flush;\n    min_cost = min(entry.second, min_cost);\n  }\n\n  costs[vv] = min_cost;\n  return min_cost;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n//#define int long long\n\n#define upper(n,m) (n+m-1)/m\n#define rounding(n) (int)((double)n+0.5)\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define REAP(i,a,n) for(int i=(a);i<(n);i++)\n#define ALL(a) a.begin(),a.end()\n\n#define coutALL(i,a) {int i=0;for(int e:a) cout<<(i++?\" \":\"\")<<e; cout<<endl;}\n#define coutYN(a) cout<<(a?\"Yes\":\"No\")<<endl;\n#define coutyn(a) cout<<(a?\"yes\":\"no\")<<endl;\n\n#define deb cout<<\"debug\"<<endl\n#define debn(n) cout<<\"debug: \"<<n<<endl\n\nconst int INF=INT_MAX;\nconst int MOD=(int)1e9+7;\nconst double EPS=1e-12;\n//const int dx[]={0,1,0,-1},dy[]={-1,0,1,0};\nconst int dx[]={-1,-1,-1,0,1,1,1,0},dy[]={-1,0,1,1,1,0,-1,-1};\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef long long LL;\n\nsigned main(){\n\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin>>n;\n\n  int flag[1000]={};\n  int where[10010]={};\n  vector <int> a(n),sorted_a;\n  REP(i,n) cin>>a[i],where[a[i]]=i;\n\n  sorted_a=a;\n  sort(ALL(sorted_a));\n\n  vector<vector<int>> cost_list;\n\n  REP(i,n){\n\n    if(flag[i]) continue;\n\n    int now=i;\n    vector <int> cost;\n\n    for(;!flag[now];){\n\n      cost.pb(a[now]);\n      flag[now]=1;\n      now=where[sorted_a[now]];\n\n    }\n\n    cost_list.pb(cost);\n\n  }\n\n  int ans=0,min_a=sorted_a[0];\n\n  for(auto e:cost_list){\n\n    int r1=accumulate(ALL(e),0)+(e.size()-2)**min_element(ALL(e));\n    int r2=accumulate(ALL(e),0)+*min_element(ALL(e))+(e.size()-1)*min_a;\n\n    ans+=min(r1,r2);\n\n  }\n\n  cout<<ans<<endl;\n\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\nusing namespace std;\nconst int MAXN = 1010;\nint w[MAXN];\nbool done[MAXN];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, mini = 100000;\n    cin >> n;\n    map<int, int> mp;\n    for (int i = 0; i < n; i++) {\n        cin >> w[i];\n        mp[w[i]] = 0;\n        mini = min(mini, w[i]);\n    }\n    {\n        int k = 0;\n        for (auto& p : mp) p.second = k++;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (done[i]) continue;\n        int cnt = 0, now = i, mi = 100000, sum = 0;\n        while (1) {\n            if (done[now]) break;\n            cnt++;\n            done[now] = true;\n            mi = min(mi, w[now]);\n            sum += w[now];\n            now = mp[w[now]];\n        }\n        int tmp = sum+(cnt-2)*mi;\n        tmp = min(tmp, sum+mi+mini*(cnt+1));\n        ans += tmp;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<stdlib.h>\n#include<cstdio>\n#include<stdio.h>\n#include<set>\n#include<map>\n#include<deque>\n#include<stack>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<sstream>\n#include<fstream>\n#include<time.h>\nusing namespace std;\nconst int maxn = 1010;\nint a[maxn], id[maxn], pos[maxn];\ninline bool cmp(int x, int y) { return a[x] < a[y]; }\nint main()\n{\n\tint n;long long ans = 0;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1;i <= n;i++)\n\t{\n\t\tscanf(\"%d\", a + i);\n\t\tid[i] = i;\n\t}\n\tsort(id + 1, id + 1 + n,cmp);//id[x]表示第x小的数排在第几个\n\tfor (int i = 1;i <= n;i++)pos[id[i]] = i;//pos[x]表示第x个数是第几小\n\tfor (int i = n;i;i--)\n\t{\n\t\tif (id[i] != i)\n\t\t\tans = ans + a[id[pos[i]]] + a[id[i]];\n\t\tswap(a[id[pos[i]]], a[id[i]]);\n\t\tid[pos[i]] = id[i];\n\t\tpos[id[i]] = pos[i];\n\t\tpos[i] = id[i] = i;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n\nint main() {\n    int w[1000], a[1000], n, i, j, cost;\n\n    cin >> n;\n    for (i = 0; i < n; i++) {\n        cin >> w[i];\n        a[i] = w[i];\n    }\n    sort(a, a+n);\n\n    cost = 0;\n    for (i = 0; i < n - 1; i++) {\n        if (a[i] != w[i]) {\n            for (j = i + 1; j < n; j++) {\n                if (a[i] == w[j]) {\n                    int t = w[j];\n                    w[j] = w[i];\n                    w[i] = t;\n                    cost += w[i] + w[j];\n                    break;\n                }\n            }\n        }\n    }\n    cout << cost << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\nconst ll mod2 = 998244353;\nconst int INF = 1000000005;\nconst int MAX = 1005;\n\nbool seen[MAX];\nint minw = INF;\nvector<pair<int, int>> w;\n\nll solve(int x) {\n  int idx = x, minr = INF, sumr = 0;\n  vector<int> r;\n  while (1) {\n    r.push_back(w[idx].first);\n    minr = min(minr, w[idx].first);\n    sumr += w[idx].first;\n    seen[idx] = true;\n    if (x == w[idx].second) break;\n    idx = w[idx].second;\n  }\n  if (r.empty()) return 0;\n\n  int n = r.size();\n  ll sum1, sum2;\n  sum1 = sumr + (n-2) * minr;\n  sum2 = sumr + minr + (n+1) * minw;\n\n  return min(sum1, sum2);\n  \n\n}\n\nint main() {\n  int n;\n  cin >> n;\n  pair<int, int> p;\n  rep(i, n) {\n    cin >> p.first;\n    minw = min(minw, p.first);\n    p.second = i;\n    w.push_back(p);\n    seen[i] = false;\n  }\n\n  sort(w.begin(), w.end());\n\n  ll ans = 0;\n  rep(i, n) {\n    if (!seen[i]) {\n      ans += solve(i);\n    }\n  }\n\n  cout << ans << endl;\n\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nsigned main() {\n  int n;\n  cin >> n;\n\n  vector<int> w(n);\n  for ( int i = 0; i < n; i++ ) cin >> w[i];\n\n  vector<int> sorted_w = w;\n  sort(sorted_w.begin(), sorted_w.end());\n\n  int ans = 0;\n  for ( int i = 0; i < n; i++ ) {\n    int x = sorted_w[i];\n    int y = w[i];\n    int j;\n    for ( j = i+1; j < n; j++ ) {\n      if ( w[j] == x ) break;\n    }\n\n    if ( j == n ) continue;\n\n    for ( ; j >= 1 && y < w[j-1]; j-- ) {\n      swap(w[j-1], w[j]);\n      ans += w[j-1]+w[j];      \n    }\n\n    if ( w[j] < w[i] ) {\n      swap(w[i], w[j]);\n      ans += w[i]+w[j];\n    }\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n//#define ll long long\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n#define rep(i, n) REP(i, 0, n)\n#define rep_rev(i, n) for (int (i) = (int)(n) - 1 ; (i) >= 0 ; --(i))\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define all(x) (x).begin(),(x).end()\nll t1,t2,t3;\nconst ll mod = 1000000007;\nconst int INF = 1e9;\nconst ll INFLONG = 1e18;\nll n;\nint main(){\n  cin >> n;\n  vector<ll> vec(n),vec_sorted(n),move(10000,0);\n  ll minnum = INFLONG;\n  rep(i,n){\n    cin >> vec[i];\n    chmin(minnum,vec[i]);\n  }\n  vec_sorted = vec;\n  sort(all(vec_sorted));\n  rep(i,n){\n    move[vec_sorted[i]] = i;\n  }\n\n  ll ans = 0;\n  vector<ll> rem;\n  rep(i,n){\n    if(i != move[vec[i]]){\n      //cout << i << endl;\n      ll piv = i;\n      ll sum = 0;\n      ll cou = 0;\n      ll mini = INFLONG;\n      while(piv != move[vec[piv]]){\n        chmin(mini,vec[piv]);\n        //cout << piv << endl;\n        sum += vec[piv];\n        cou++;\n        ll tmp = piv;\n        piv = move[vec[piv]];\n        move[vec[tmp]] = tmp;\n      }\n      ll t1 = 0;\n      //cout << mini << \" \" << sum << endl;\n      t1 = (cou-2) *  mini + sum;\n      //chmin(t1,(cou-2) * minnum + sum + (mini + minnum) * 2);\n      chmin(t1,mini + sum + (cou+1) * minnum);\n      ans += t1;\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// -*- mode:c++; coding:utf-8; c-basic-offset:2; -*-\n// ALDS1_6-D: Minimum Cost Sort\n\n#include <algorithm>\n#include <cstdio>\n\nusing uint = unsigned int;\n\nstatic void make_indices(const uint as[], const uint n, uint indices[])\n{\n  uint bs[n];\n  std::copy(as, as+n, bs);\n  std::sort(bs, bs+n);\n  for (auto i = 0u; i < n; ++i) {\n    indices[bs[i]] = i;\n  }\n}\n\nstatic const uint MAX_VALUE = 10000;\n\nstatic uint minimum_cost_sort(const uint as[], const uint n)\n{\n  auto cost = 0u;\n\n  uint indices[MAX_VALUE+1];\n  make_indices(as, n, indices);\n\n  bool visited[n];\n  std::fill(visited, visited+n, false);\n\n  auto min = *std::min_element(as, as+n);\n\n  for (auto i = 0u; i < n; ++i) {\n    if (visited[i]) continue;\n    auto c_n = 0u, c_min = MAX_VALUE, c_sum = 0u;\n    auto j = i;\n    while (!visited[j]) {\n      visited[j] = true;\n      auto a = as[j];\n      ++c_n;\n      c_min = std::min(c_min, a);\n      c_sum += a;\n      j = indices[a];\n    }\n    cost += std::min(c_sum + (c_n-2) * c_min,\n                     c_sum + (c_n+1) * min + c_min);\n  }\n  return cost;\n}\n\nint main()\n{\n  uint n;\n  std::scanf(\"%u\", &n);\n  uint as[n];\n  for (auto i = 0u; i < n; ++i) {\n    std::scanf(\"%u\", &as[i]);\n  }\n\n  auto cost = minimum_cost_sort(as, n);\n  std::printf(\"%u\\n\", cost);\n}\n\n// eof"
  },
  {
    "language": "C++",
    "code": "///\n// File:  alds1_6_d.cpp\n// Author: ymiyamoto\n//\n// Created on Thu Oct 12 23:39:32 2017\n//\n\n#include <algorithm>\n#include <cstdint>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n#define SIZE 10000\n\nstatic vector<uint32_t> array;\nstatic uint32_t T[SIZE + 1];\n\nstatic uint32_t solve(uint32_t min_val)\n{\n  uint32_t count = 0;\n\n  vector<bool> V(array.size(), false);\n  vector<uint32_t> B(array);\n\n  sort(B.begin(), B.end());\n\n  for (uint32_t i = 0; i < array.size(); i++) {\n    T[B[i]] = i;\n  }\n\n  for (uint32_t i = 0; i < array.size(); i++) {\n    if (V[i]) continue;\n    uint32_t cur = i;\n    uint32_t S = 0;\n    uint32_t m = UINT32_MAX;\n    uint32_t an = 0;\n    while (true) {\n      V[cur] = true;\n      an++;\n      uint32_t v = array[cur];\n      m = min(v, v);\n      S += v;\n      cur = T[v];\n      if (V[cur]) break;\n    }\n    count += min(S + (an - 2) * m, m + S + (an + 1) * min_val);\n  }\n\n  return count;\n}\n\nint32_t main()\n{\n  uint32_t n;\n  cin >> n;\n\n  uint32_t s = UINT32_MAX;\n  for (uint32_t i = 0; i < n; i++) {\n    uint32_t val;\n    cin >> val;\n    array.push_back(val);\n    s = min(s, val);\n  }\n\n  uint32_t count = solve(s);\n\n  cout << count << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main(void) {\n\tint num;\n\tcin >> num;\n\tvector<int> a(num);\n\tvector<int> sorted(num);\n\tint pos[1000];\n\tint order[1000];\n\tint cost = 0;\n\n\tfor (int i = 0; i < num; i++) {\n\t\tcin >> a[i];\n\t}\n\n\tfor (int i = 0; i < num; i++)\n\t\tsorted[i] = a[i];\n\tsort(sorted.begin(), sorted.begin() + num);\n\tfor (int i = 0; i < num; i++)\n\t\tpos[sorted[i]] = i;\n\n\tfor (int i = 0; i < num; i++) {\n\t\tint x = order[0] = i;\n\t\tint minn = 1000;\n\t\tint start = 0;\n\n\t\tif (i == pos[a[i]])\n\t\t\tcontinue;\n\n\t\tfor (int j = 1;; j++) {\n\t\t\tx = pos[a[x]];\n\t\t\tif (x == i)\n\t\t\t\tbreak;\n\t\t\tif (a[x] < minn) {\n\t\t\t\tminn = a[x];\n\t\t\t\tstart = j;\n\t\t\t}\n\t\t\torder[j] = x;\n\t\t}\n\n\t\tfor (int j = start - 1; j >= 0; j--) {\n\t\t\tcost += (minn + a[order[j]]);\n\t\t\ta[order[j + 1]] = a[order[j]];\n\t\t\ta[order[j]] = minn;\n\t\t}\n\t}\n\n\tcout << cost << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint minimumCostSort(int *W, int n) {\n  int X[1000], R[1000];\n  for (int i = 0; i < n; i++) {\n    X[i] = W[i];\n  }\n  sort(X, X + n);\n  for (int i = 0; i < n; i++) R[X[i]] = i;\n  int m = X[0];\n  int sum = 0;\n\n  for (int i = 0; i < n; i++) {\n    int cur = i;\n    if (X[cur] == -1) break;\n    int s = 0;\n    int mm = 10000;\n    int nn = 0;\n    int v;\n    while (true) {\n      nn++;\n      X[cur] = -1;\n      v = W[cur];\n      mm = min(v, mm);\n      s += v;\n      cur = R[v];\n      if (X[cur] == -1) break;\n    }\n    sum += min(s + (nn - 2) * mm, s + mm + (nn + 1) * m);\n  }\n\n  return sum;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  int W[1000];\n\n  cin >> n;\n\n  for (int i = 0; i < n; i++) {\n    cin >> W[i];\n  }\n\n  int c = minimumCostSort(W, n);\n\n  cout << c << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint n, w[1010], s[1010], ind[10001];\n\nint main() {\n\tcin >> n;\n\t\n\tfor_(i,0,n) {\n\t\tcin >> w[i];\n\t\ts[i] = w[i];\n\t\tind[w[i]] = i;\n\t}\n\t\n\tsort(s, s + n);\n\t\n\tint ans = 0;\n\t\n\tfor_(i,0,n) {\n\t\tif (w[i] == s[i]) continue;\n\t\t\n\t\tint piv = w[i], cur = i, sum = w[i], cnt = 0;\n\t\tw[i] = s[i];\n\t\t\n\t\twhile ((cur = ind[s[cur]]) != i) {\n\t\t\tpiv = min(piv, w[cur]);\n\t\t\tsum += w[cur];\n\t\t\t++cnt;\n\t\t\tw[cur] = s[cur];\n\t\t}\n\t\t\n\t\tans += min((sum - piv) + piv * cnt, 2 * (piv + s[0]) + (sum - piv) + s[0] * cnt);\n\t}\n\t\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vl = vector<ll>;\ntemplate<class T> using vc = vector<T>;\ntemplate<class T> using vvc = vector<vector<T>>;\n\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define repr(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define repe(i, l, r) for (ll i = (l); i < (r); i++)\n#define reper(i, l, r) for (ll i = (r)-1; i >= (l); i--)\n#define repa(i,n) for (auto& i: n)\n\ntemplate<class T> inline bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nvoid init() {cin.tie(0);ios::sync_with_stdio(false);cout << fixed << setprecision(15);}\n\n#ifdef DEBUG\ntemplate <class T, class N> void verr(const T& a, const N& n) { rep(i, n) cerr << a[i] << \" \"; cerr << \"\\n\" << flush; }\nll dbgt = 1; void err() { cerr << \"passed \" << dbgt++ << \"\\n\" << flush; }\ntemplate<class H, class... T> void err(H&& h,T&&... t){ cerr<< h << (sizeof...(t)?\" \":\"\\n\") << flush; if(sizeof...(t)>0) err(forward<T>(t)...); }\n#endif\n\nconst ll INF = 4e18;\nconst ld EPS = 1e-11;\nconst ld PI = acos(-1.0L);\nconst ll MOD = 1e9 + 7;\n// const ll MOD = 998244353;\n//--------------------------------------------------------------------------------//\n\nint main() {\n    init();\n    ll N;\n    cin >> N;\n    vl A(N), ID(10001), SA;\n    rep(i, N) cin >> A[i];\n    SA = A;\n    sort(all(SA));\n    rep(i, N) ID[SA[i]] = i;\n\n    ll m = *min_element(all(A)), ans = 0;\n    vc<bool> B(N);\n    \n    rep(i, N){\n        if (B[i] or ID[A[i]] == i) continue;\n        ll sum = 0, mv = INF, ti = i, cnt = 0;\n        while(!B[ti]){\n            B[ti] = true, sum += A[ti], cnt++;\n            chmin(mv, A[ti]);\n            ti = ID[A[ti]];\n        }\n        sum -= mv;\n\n        ans += sum + min(2 * (mv + m) + (cnt - 1) * m, (cnt - 1) * mv);\n    }\n    \n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\nusing std::scanf;\nusing std::printf;\n\nconst int kMaxN = 1000;\nconst int kMaxWi = 10000;\n\n// w[i]?????????????????????????????????cycle???????????????????????????remain????????£?????????????¨????\n// ????????????cycle?????????\nint MakeCycle(int w[], int i, int remain[], int cycle[]) {\n  int j = 0;\n  cycle[0] = -1; //?????????while?????????????????????\n  while(w[i] != cycle[0]) {\n    cycle[j] = w[i];\n    ++j;\n    remain[i] = 0;\n    i = w[i] - 1;\n  }\n  return j;\n}\n\nint CompareCosts(int cycle[], int cycle_n, int cycle_min, int w_min) {\n  if (cycle_n == 1) {\n    return 0;\n  } else if (cycle_n == 2) {\n    return cycle[0] + cycle[1];\n  } else {\n    int cycle_sum, i, cost1, cost2;\n    cycle_sum = 0;\n    for (i = 0; i < cycle_n; ++i) { cycle_sum += cycle[i]; }\n    cost1 = cycle_sum + (cycle_n - 2) * cycle_min;\n    cost2 = cycle_sum + cycle_min + (cycle_n + 1) * w_min;\n    return std::min(cost1, cost2);\n  }\n}\n\nint main() {\n  int n, i, j, cycle_n, cycle_min, w_min, cnt;\n  scanf(\"%d\", &n);\n  int w[n], remain[n], cycle[n];\n  for (i = 0; i < n; ++i) { scanf(\"%d\", &w[i]); }\n  w_min = kMaxWi;\n  for (i = 0; i < n; ++i) { w_min = std::min(w_min, w[i]); }\n  for (i = 0; i < n; ++i) { remain[i] = 1; }\n  cnt = 0;\n  for (i = 0; i < n; ++i) {\n    if (remain[i]) {\n      cycle_n = MakeCycle(w, i, remain, cycle);\n      cycle_min = kMaxWi;\n      for (j = 0; j < cycle_n; ++j) { cycle_min = std::min(cycle_min, cycle[j]); }\n      cnt += CompareCosts(cycle, cycle_n, cycle_min, w_min);\n    }\n  }\n  printf(\"%d\\n\", cnt);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\nusing namespace std;\n\nint do_cycle(vector<int> &v,int x){\n\tint s=0,m=1<<30;\n\tfor(auto &e:v)s+=e,m=min(m,e);\n\treturn min(s+(v.size()-2)*m,s+m+(v.size()+1)*x);\n}\n\nint main(){\n\tint N,x=1<<30,r;\n\tscanf(\"%d\",&N);\n\tvector<int>v(N+1),b(N+1);\n\tvector<vector<int> >cycles;\n\tfor(int i=1;i<=N;i++)scanf(\"%d\",&v[i]),x=min(x,v[i]);\n\tfor(int i=1;i<=N;i++)if(!b[i]){\n\t\tvector<int>cycle;\n\t\tint k=i;\n\t\tdo{\n\t\t\tcycle.push_back(k);\n\t\t\tb[k]=1;\n\t\t\tk=v[k];\n\t\t}while(k!=cycle[0]);\n\t\tr+=do_cycle(cycle,x);\n\t}\n\tprintf(\"%d\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_6_D&lang=jp>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n\n ================================================================\n */\n\nll solve(){\n    ll res = 0;\n    int n; cin >> n;\n    vector<ll> w(n); for(auto& in:w) cin >> in;\n    auto w2 = w; sort(w2.begin(),w2.end());\n    for(int i = n-1;i >= 0; i--){\n        if(w2[i] == w[i]) continue;\n        for(int j = i-1; j>= 0;j--){\n            if(w2[i] != w[j]) continue;\n            res += w[i] + w[j];\n            swap(w[i],w[j]);\n        }\n    }\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": " /********   All Required Header Files ********/\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <iterator>\n#include <list>\n#include <stack>\n#include <map>\n#include <set>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <limits>\n#include <time.h>\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <unordered_set>\n\nusing namespace std;\n\n/*******  All Required define Pre-Processors and typedef Constants *******/\n#define SCD(t) scanf(\"%d\",&t)\n#define SCLD(t) scanf(\"%ld\",&t)\n#define SCLLD(t) scanf(\"%lld\",&t)\n#define SCC(t) scanf(\"%c\",&t)\n#define SCS(t) scanf(\"%s\",t)\n#define SCF(t) scanf(\"%f\",&t)\n#define SCLF(t) scanf(\"%lf\",&t)\n#define MEM(a, b) memset(a, (b), sizeof(a))\n#define FOR(i, j, k, in) for (int i=j ; i<k ; i+=in)\n#define RFOR(i, j, k, in) for (int i=j ; i>=k ; i-=in)\n#define REP(i, j) FOR(i, 0, j, 1)\n#define RREP(i, j) RFOR(i, j, 0, 1)\n#define all(cont) cont.begin(), cont.end()\n#define rall(cont) cont.end(), cont.begin()\n#define FOREACH(it, l) for (auto it = l.begin(); it != l.end(); it++)\n#define IN(A, B, C) assert( B <= A && A <= C)\n#define MP make_pair\n#define PB push_back\n#define INF (int)1e9\n#define EPS 1e-9\n#define PI 3.1415926535897932384626433832795\n#define MOD 1000000007\n#define read(type) readInt<type>()\nconst double pi=acos(-1.0);\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef map<int,int> MPII;\ntypedef set<int> SETI;\ntypedef multiset<int> MSETI;\ntypedef long int int32;\ntypedef unsigned long int uint32;\ntypedef long long int int64;\ntypedef unsigned long long int  uint64;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n\n/****** Template of some basic operations *****/\ntemplate<typename T, typename U> inline void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> inline void amax(T &x, U y) { if(x < y) x = y; }\n/**********************************************/\n\n\n/**************************************/\n\nint n;\nint arr[1001];\n/******** User-defined Function *******/\n\nint64 solve(){\n  int64 res = 0;\n\n  int sorted[n];\n  bool in_loop[n];\n  int min_arr = INF;\n  map<int,int> ind;\n  for(int i = 0; i  <n; i++){\n    sorted[i] = arr[i];\n    amin(min_arr, arr[i]);\n    in_loop[i] = false;\n    ind[arr[i]]=i;\n  }\n\n  sort(sorted, sorted+n);\n  map<int,int> rank;\n  int out_of_place = 0;\n  for(int i = 0; i  < n; i++){\n    if(sorted[i]!=arr[i]){\n      out_of_place++;\n    }\n    rank[sorted[i]] =i;\n  }\n\n  for(int i =0;i < n; i++){\n    if(in_loop[i]){\n      continue;\n    } else {\n      // not yet visited\n      // find the length, min val of the loop\n      int curr = i;\n      int min_loop = INF;\n      int min_len = 0;\n      int64 sum_loop = 0;\n      while(true){\n        // cout << curr << endl;\n        if(in_loop[curr]){\n          break;\n        }\n        min_len++;\n        in_loop[curr] = true;\n        //cout << arr[curr] << \" \";\n        amin(min_loop, arr[curr]);\n        sum_loop += arr[curr];\n        curr = ind[sorted[curr]];\n       \n      }\n\n      res += min(sum_loop + (min_len-2)*min_loop, sum_loop + min_loop + min_arr + (min_len)*min_arr );\n    }\n  }\n\n\n  return res;\n}\n\n\n\n/********** Main()  function **********/\nint main()\n{\n  cin >> n;\n  for(int i = 0; i < n; i++){\n    cin >> arr[i];\n  }\n\n cout << solve() << endl;\n\n\n    return 0;\n}\n/********  Main() Ends Here *************/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream> \n#include<algorithm>\nusing namespace std;\n\nint solve(int A[], int n, int minw) {\n\tint cnt = 0;\n\tint B[n], T[10001];\n\tbool V[n];\n\tfor (int i = 0; i < n; i++) {\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tT[B[i]] = i; //?????????????????????????????§?????????????????????????????????????????????\n\t}\n\tfor (int i = 0; i < n; i++)\t{\n\t\tif (V[i]) continue;\n\t\tint cur = i, S = 0, m = 10000, an = 0;\n\t\twhile(1) {\n\t\t\tV[cur] = true; //????????????\n\t\t\tan++;???//?°???°?????????????????°\n\t\t\tint v = A[cur];???\n\t\t\tm = min(m, v); //?°???°???????????????????°????\n\t\t\tS += v; //????????????\n\t\t\tcur = T[v]; //??¬??\\??????????????\\????????????\n\t\t\tif (V[cur]) break; //????????????????????????????????????\n\t\t}\n\t\tcnt += min(S + (an - 2) * m, S + m + (an + 1) * minw); //????????§????????????while????????§??£?¨?\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tint A[n];\n\tint minw = 10000;\n\tfor (int i = 0; i < n; i++)\t{\n\t\tcin >> A[i];\n\t\tminw = min(minw, A[i]);\n\t}\n\n\tint min = solve(A, n, minw);\n\n\tcout << min << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define MAX_N 10000\n#define MAX_V 100000000\n#define INF 1000000000\n\nint n, A[MAX_N], s, B[MAX_N], T[MAX_V], cur, S, m, x; bool V[MAX_N];\n\nint minimum_cost_sort() {\n\tint ans = 0;\n\tfor (int i = 0; i < MAX_V; i++) { V[i] = false; }\n\tfor (int i = 0; i < n; i++) { B[i] = A[i]; }\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; i++) { T[B[i]] = i; }\n\tfor (int i = 0; i < n; i++) {\n\t\tif (V[i] == true) { goto owata; }\n\t\tcur = i;\n\t\tS = 0;\n\t\tm = INF;\n\t\tx = 0;\n\t\twhile (1) {\n\t\t\tV[cur] = true;\n\t\t\tx++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif (V[cur]) { break; }\n\t\t}\n\t\tans += min(S + (x - 2)*m, m + S + (x + 1)*s);\n\towata:;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tcin >> n;\n\ts = INF;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tcout << minimum_cost_sort() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint cmp(const int n1, const int n2) {\n\treturn n1 < n2;\n}\n\nint main() {\n\tint n;\n\tint ary[1000];\n\tint sortAry[1000];\n\tint cost = 0;\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint temp;\n\t\tcin >> temp;\n\t\tary[i] = sortAry[i] = temp;\n\t}\n\n\tsort(sortAry, sortAry + n);\n\n\twhile (true) {\n\t\tint c = 100000;\n\t\tint index = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (ary[i] < sortAry[i]) {\n\t\t\t\tif (c > ary[i]) {\n\t\t\t\t\tc = ary[i];\n\t\t\t\t\tindex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (index < 0)break;\n\t\tcost += c + sortAry[index];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (ary[i] == sortAry[index]) {\n\t\t\t\tswap(ary[i], ary[index]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << cost << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\nusing std::scanf;\nusing std::printf;\n\nconst int kMaxN = 1000;\nconst int kMaxWi = 10000;\n\n// w[i]?????????????????????????????????cycle???????????????????????????remain????????£?????????????¨????\n// ????????????cycle?????????\nint MakeCycle(int w[], int i, int remain[], int cycle[]) {\n  int j = 0;\n  cycle[0] = -1; //?????????while?????????????????????\n  while(w[i] != cycle[0]) {\n    cycle[j] = w[i];\n    ++j;\n    remain[i] = 0;\n    i = w[i] - 1;\n  }\n  return j;\n}\n\nint CompareCosts(int cycle[], int cycle_n, int cycle_min, int w_min) {\n  if (cycle_n == 1) {\n    return 0;\n  } else if (cycle_n == 2) {\n    return cycle[0] + cycle[1];\n  } else {\n    int cycle_sum, i, cost1, cost2;\n    cycle_sum = 0;\n    for (i = 0; i < cycle_n; ++i) { cycle_sum += cycle[i]; }\n    cost1 = cycle_sum + (cycle_n - 2) * cycle_min;\n    cost2 = cycle_sum + cycle_min + (cycle_n + 1) * w_min;\n    return std::min(cost1, cost2);\n  }\n}\n\nint main() {\n  int n, i, j, cycle_n, cycle_min, w_min, cnt;\n  scanf(\"%d\", &n);\n  int w[n], remain[n], cycle[n];\n  for (i = 0; i < n; ++i) { scanf(\"%d\", &w[i]); }\n  w_min = kMaxWi;\n  for (i = 0; i < n; ++i) { w_min = std::min(w_min, w[i]); }\n  for (i = 0; i < n; ++i) { remain[i] = 1; }\n  cnt = 0;\n  for (i = 0; i < n; ++i) {\n    if (remain[i]) {\n      cycle_n = MakeCycle(w, i, remain, cycle);\n      cycle_min = kMaxWi;\n      for (j = 0; j < cycle_n; ++j) { cycle_min = std::min(cycle_min, cycle[j]); }\n      cnt += CompareCosts(cycle, cycle_n, cycle_min, w_min);\n    }\n  }\n  printf(\"%d\\n\", cnt);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef struct D{\n\tint c;\n\tvector<P>W;\n\tbool operator <(const D &a)const{return c>a.c;}\n}D;\nint N,W[1005],C[1005],c=0,t,p,res=1000000000;\nmap<int,int>H;\nmap<int,int>rH;\nmap<vector<P>,int>MC;\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++)\n\t\tscanf(\"%d\",C+i);\n\tmemcpy(W,C,sizeof(C));\n\tsort(C,C+N);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tH[C[i]]=i;\n\t\trH[i]=C[i];\n\t}\n\tD tmp={0};\n\tfor(int i=0;i<N;i++)\n\t\ttmp.W.push_back(make_pair(W[i],H[W[i]]));\n\tMC[tmp.W]=0;\n\tpriority_queue<D>Q;\n\tQ.push(tmp);\n\tfor(;!Q.empty();)\n\t{\n\t\ttmp=Q.top();Q.pop();\n\t\tif(MC[tmp.W]!=0&&MC[tmp.W]<tmp.c)continue;\n\t\tint f=1;\n\t\tfor(int i=0;i<tmp.W.size();i++)\n\t\t{\n\t\t\tif(tmp.W[i].second!=i)\n\t\t\t{\n\t\t\t\tf=0;\n\t\t\t\tD ins=tmp;\n\t\t\t\tins.c+=tmp.W[i].first+tmp.W[tmp.W[i].second].first;\n\t\t\t\tswap(ins.W[i],ins.W[ins.W[i].second]);\n\t\t\t\tif(MC[ins.W]==0||MC[ins.W]>ins.c)\n\t\t\t\t{\n\t\t\t\t\tMC[ins.W]=ins.c;\n\t\t\t\t\tQ.push(ins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(f)\n\t\t{\n\t\t\tres=min(res,tmp.c);\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define MAX 10000\n\nint main(){\n  int n;\n  cin >> n;\n  int tmp, w1[n+1], w2[n+1], idx[MAX+1], x = MAX, color[MAX+1];\n  for ( int i = 0; i < n; i++){\n    cin >> tmp ;\n    w1[i] = w2[i] = tmp;\n    x = min(x, tmp);\n    color[i] = 0;\n  }\n\n  sort(w2, w2+n);\n  for ( int i = 0; i < n; i++ ){\n    idx[w2[i]] = i;\n  }\n\n  int aSum = 0;\n  for ( int i = 0; i < n; i++){\n    if ( w1[i] == w2[i] || color[i]) continue;\n    int cur = i;\n    int Min = w2[i], lSum = 0, lN = 0, nextCorrect = 0;;\n    while( 1 ){\n      color[cur] = 1;\n      Min = min(Min, w2[cur]);\n      lSum += w2[cur];\n      lN ++;\n      cur = idx[w1[cur]];\n      if (color[cur]) break;\n    }\n    aSum += min( Min * (lN - 2) + lSum, x * (lN + 1) + Min + lSum );\n  }\n\n  cout << aSum << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define NMAX 1000\n#define WMAX 10000\n\nint mincost(short *, int, int);\n\nint main(){\n\n  int i, j, n, d, wtemp, wmin=WMAX, cost=0;\n  short w[NMAX], s[NMAX], l[NMAX];\n  char c[WMAX+1]={0}, flag[NMAX]={0};\n\n  scanf(\"%d\",&n);\n\n  for (i=0; i<n; i++) {\n    scanf(\"%d\",&w[i]);\n    if (wmin > w[i]) wmin = w[i];\n    c[w[i]]++;\n  }\n\n  j=0;\n\n  for (i=0; i<=WMAX; i++) {\n    if(c[i]) {\n      s[j] = i;\n      j++;\n    }\n  }\n\n  for (i=0; i<n; i++) {\n    if( flag[i]==0 ) {\n      d = 0;\n      flag[i]++;\n      l[d] = w[i];\n      d++;\n      wtemp = w[i];\n      while (1) {\n        j = 0;\n        while (s[j] != wtemp) j++;\n        if(j == i) break;\n        flag[j]++;\n        l[d] = w[j];\n        d++;\n        wtemp = w[j];\n      }\n      cost += mincost(l, d, wmin);\n    }\n  }\n\n  printf(\"%d\\n\",cost);\n\n  return 0;\n}\n\nint mincost(short *l, int d, int wmin)\n{\n    int i, c1=0, c2, lmin=WMAX, imin;\n\n    for (i=0; i<d; i++) {\n        c1 += l[i];\n        if(lmin > l[i]) {\n            lmin = l[i];\n        }\n    }\n\n    c2 = c1;\n    c1 += (d-2)*lmin;\n    c2 += lmin + (d+1)*wmin;\n\n    if (c1 < c2) return c1;\n    else return c2;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdint.h>\n#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <climits>\n#include <algorithm>\n#include <float.h>\nusing namespace std;\n\n#define DEBUG (0)\n\n#if DEBUG\n#define DPRINTF(...) do { \\\n    printf(\"D(L%d) %s: \", __LINE__, __func__); \\\n    printf(__VA_ARGS__); \\\n  } while (false)\n#else\n#define DPRINTF(...)\n#endif // DEBUG\n\nint g_cost = 0;\n\nvoid swap(int array[], int i0, int i1)\n{\n  int temp = array[i1];\n  array[i1] = array[i0];\n  array[i0] = temp;\n}\n\n\ninline bool isSortedAtIndex(int idx, const int array0[], const int array1[])\n{\n  return array0[idx] == array1[idx];\n}\n\n/* Assum all elements in array[] are distinct */\nint getIdxOf(int num, const int array[], int numOfArray)\n{\n  for (int i = 0; i < numOfArray; i++)\n  {\n    if (array[i] == num)\n      return i;\n  }\n\n  const int error = -1;\n  return error;\n}\n\nvoid calculateCost(int idx, int numOfArray, const int array[], const int sortedArray[], int &swapIdx, float &cost)\n{\n  const int targetNum = sortedArray[idx];\n  swapIdx = getIdxOf(targetNum, array, numOfArray);  // run time : O(n)\n\n  cost = static_cast<float>(array[idx] + array[swapIdx]);\n\n  // If both elements, of which index is \"idx\" and \"swapIdx\", are sorted at one time,\n  // we could think of the cost of swap being half\n  if (sortedArray[swapIdx] == array[idx])\n    cost /= 2.f;\n\n  DPRINTF(\"swap %d and %d with cost of %f\\n\", idx, swapIdx, cost);\n}\n\nint main()\n{\n  int numOfArray;\n  cin >> numOfArray; cin.ignore();\n\n  int array[numOfArray];\n  for (int i = 0; i < numOfArray; i++)\n    cin >> array[i];\n\n#if DEBUG\n  for (int i = 0; i < numOfArray; i++)\n    if (i == 0) DPRINTF(\"%d\", array[i]);\n    else        printf(\" %d\", array[i]);\n  cout << endl;\n#endif // DEBUG\n\n  int sortedArray[numOfArray];\n  for (int i = 0; i < numOfArray; i++)\n    sortedArray[i] = array[i];\n\n  sort(sortedArray, sortedArray + numOfArray);\n\n#if DEBUG\n  for (int i = 0; i < numOfArray; i++)\n    if (i == 0) DPRINTF(\"%d\", sortedArray[i]);\n    else        printf(\" %d\", sortedArray[i]);\n  cout << endl;\n#endif // DEBUG\n\n  {\n    bool needSort = true;\n\n    do {\n\n      needSort = false;\n\n      float minCost = FLT_MAX;\n      pair<int, int> swapIndcies = make_pair(-1, -1);\n\n      // find a pair of array elements that can be swapped with minimum cost\n      for (int i = 0; i < numOfArray; i++)\n      {\n        if (isSortedAtIndex(i, array, sortedArray))\n          continue;\n\n        needSort = true;\n\n        int swapIdx;\n        float cost;\n        calculateCost(i, numOfArray, array, sortedArray, swapIdx, cost);\n\n        if (minCost > cost)\n        {\n          minCost = cost;\n          swapIndcies = make_pair(i, swapIdx);\n        }\n      }\n\n      if (needSort)\n      {\n\n        DPRINTF(\"Swap array[%d] (%d) and array[%d] (%d)\\n\",\n            swapIndcies.first, array[swapIndcies.first],\n            swapIndcies.second, array[swapIndcies.second]);\n\n        swap(array, swapIndcies.first, swapIndcies.second);\n\n        g_cost += array[swapIndcies.first] + array[swapIndcies.second];\n\n#if DEBUG\n      for (int i = 0; i < numOfArray; i++)\n        if (i == 0) DPRINTF(\"%d\", array[i]);\n        else        printf(\" %d\", array[i]);\n      cout << endl;\n#endif // DEBUG\n\n      }\n\n    } while (needSort);\n  }\n\n  cout << g_cost << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\n//s:与えられた数列の中での最小値\n//A:与えられた数列\n//B:ソート済みの数列\n//T:与えられた数列の中の数字がソート済みの数列のなかで来る位置（イテレータ）\n\nint solve(){\n    int ans = 0;\n\n    bool V[MAX];  //V:各数字がどのループに属するか判明したかどうか\n    for (int i = 0; i < n; i++){\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B, B+n);\n    for (int i = 0; i < n; i++) T[B[i]] = i;\n    for (int i = 0; i < n; i++){\n        if (V[i]) continue;\n        int cur = i; //検討する数字がソート後に来る位置\n        int S = 0; //各ループの要素の数字の和\n        int m = VMAX; //各ループの最小値\n        int an = 0; //各ループの要素数\n        while (1) {\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m, v);\n            S += v;\n            cur = T[v];\n            if (V[cur]) break;\n        }\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n    }\n\n    return ans;\n}\n\nint main(){\n    cin >> n;\n    s = VMAX;\n    for (int i = 0; i < n; i++){\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n    int ans = solve();\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tint n;\n\tcin >> n;\n\tint *w = new int[n];\n\tint pos[10001];\n\tfor (int i = 0; i < 10001; ++i) {\n\t\tpos[i] = -1;\n\t}\n\n\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> w[i];\n\t\tpos[w[i]] = i;\n\t}\n\n\t//for (int i = 10000; i >= 0; --i) {\n\t//\tif (pos[i] != -1) {\n\t//\t\tcout << i << \" \";\n\t//\t}\n\t//}\n\t//cout << endl;\n\n\tunsigned long long cost = 0;\n\tint j = n - 1;\n\tfor (int i = 10000; i >= 0; --i) {\n\t\tif (pos[i] != -1) {\n\t\t\tif (pos[i] != j) {\n\t\t\t\tcost += w[j];\n\t\t\t\tcost += i;\n\n\t\t\t\tint temp = w[j];\n\t\t\t\tw[j] = i;\n\t\t\t\tw[pos[i]] = temp;\n\n\t\t\t\tpos[temp] = pos[i];\n\t\t\t\tpos[i] = j;\n\t\t\t}\n\t\t\t--j;\n\t\t\tif (j == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t}\n\t\tcout << cost << endl;\n\n\n\n\t\tdelete[] w;\n\t\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint solve(int n, vector<int> & ws);\n\nint main()\n{\n    int n = 0;\n    cin >> n;\n    vector<int> ws(n);\n    for (auto & w : ws) cin >> w;\n    cout << solve(n, ws) << endl;\n    return 0;\n}\n\nint solve(int n, vector<int> & ws){\n    vector<int> i2w;\n    int w2i[10001] = {0};\n    for (auto w : ws) w2i[w] = 1;\n    int cum = 0;\n    for (int w = 0; w != 10001; ++w){\n        if (w2i[w]){\n            w2i[w] = cum++;\n            i2w.push_back(w);\n        }\n    }\n    vector<int> as;\n    for (auto w : ws) as.push_back(w2i[w]);\n    // loop ???????????????????§?????????????????¨???????\n    vector<bool> visited(n);\n    for (int i = 0; i != n; ++i) visited[i] = false;\n    int cum_cost = 0;\n    for (int i = 0; i != n; ++i){\n        if (visited[i] || as[i] == i) continue;\n        int start = i;\n        int pos = as[i];\n        int cost = 0;\n        int swap_counts = 0;\n        while (pos != start){\n            ++swap_counts;\n            cost += i2w[pos];\n            visited[pos] = true;\n            pos = as[pos];\n        }\n        int cost_original = cost + i2w[start] * swap_counts;\n        int cost_with_swap = cost + i2w[0] * swap_counts + (i2w[start] + i2w[0]) * 2;\n        cum_cost += min(cost_original, cost_with_swap);\n    }\n    return cum_cost;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <sstream>\n#include <stack>\n#include <queue>\n#include <list>\n#include <stdio.h>\n#include <algorithm>\n#define MAX 100000\nusing namespace std;\ntypedef long long ll;\nll ans;\nvoid solve(int a[],int n)\n{\n\tint b[1000],t[10005],vmin,vmax=10000;\n\tbool vis[1000];\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tb[i]=a[i];\n\t\tvis[i]=false;\n\t}\n\tsort(b,b+n);\n\tvmin=b[0];\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tt[b[i]]=i;//得出移动够各个元素（值不同）应该在数组中位置 \n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint cur=i,m=vmax,sum=0,num=0;//查找新的环 \n\t\twhile(1)//开始搜索下一个环 \n\t\t{ \n\t\t\tvis[cur]=true;//将这个元素加入当前环 \n\t\t\tnum++;//这个环的个数加1 \n\t\t\tsum+=a[cur];//环的weight加1 \n\t\t\tm=min(a[cur],m);//更新最小值，最终得到该环的最小值 \n\t\t\tcur=t[a[cur]];//得到将要移动到的位置 \n\t\t\tif(vis[cur]) break;//将要移动到的位置的元素已经在环中，环已经闭合，一个环已经找到 \n\t\t}\n\t\tans+=min(sum+(num-2)*m,sum+m+(num+1)*vmin);//如果已经在某个环中或者根本不需要移动，那么成本为0，不影响结果 \n\t}\n}\nint main()\n{\t\n\tint n,a[1000];\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tsolve(a,n);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int INF = 1000000;\n\nstruct node\n{\n\tint num;\n\tint place;  \n};\n\nint partition(node *A,int p,int r)\n{\n\tint j,temp;\n\tnode x;\n\n\tx = A[r];\n\tj = p-1;\n\n\tfor(int i = p; i < r; i++)\n\t{\n\t\tif (A[i].num <= x.num)\n\t\t{\n\t\t\tj++;\n\t\t\ttemp = A[i].num;\n\t\t\tA[i].num = A[j].num;\n\t\t\tA[j].num = temp;\n\t\t}\n\t}\n\n\ttemp = A[j+1].num;\n\tA[j+1].num = A[r].num;\n\tA[r].num = temp;\n\n\treturn j+1;\n}\n\nvoid quicksort(node *A,int p,int r)\n{\n\tint q;\n\n\tif (p < r)\n\t{\n\t\tq = partition(A,p,r);\n\t\tquicksort(A,p,q-1);\n\t\tquicksort(A,q+1,r);\n\t}\n}\n\n\nint main()\n{\n\tint n,sum,minall,mini,sol,cnt,j;\n\tnode a[1000] = {0},b[1000] = {0};\n\n\tsol = 0;\n\tminall = INF;\n\n\tscanf(\"%d\", &n);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i].num);\n\t\ta[i].place = i;\n\t\tb[i] = a[i];\n\t\tb[i].place = i;\n\t}\n\n\tquicksort(b,0,n-1);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tsum = 0;\n\n\t\tif (a[i].num >= 0)\n\t\t{\n\t\t\tsum += a[i].num;\n\t\t\tmini = a[i].num;\n\t\t\tcnt = 1;\n\t\t\tj = i;\n\n\t\t\twhile(b[a[j].place].num != a[i].num)\n\t\t\t{\n\t\t\t\tfor(int k = 0; k < n; k++)\n\t\t\t\t{\n\t\t\t\t\tif (a[k].num == b[a[j].place].num)\n\t\t\t\t\t{\n\t\t\t\t\t\tj = k;\n\t\t\t\t\t\tsum += a[k].num;\n\t\t\t\t\t\tcnt++;\n\n\t\t\t\t\t\tif (mini > a[k].num)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmini = a[k].num;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ta[k].num = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ta[i].num = -1;\n\n\t\t\tsol += min(sum + mini * (cnt -2), sum + mini + (cnt + 1) * b[0].num);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", sol);\n\n\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n\n// Perform cycle decomposition of the original array regarded as a permutation.\n// Let\n//   cycle length: l\n//   cycle members: x1,...,xl\n//   cycle minimum: m\n//   global minimum: M\n// Repositioning the elements of a cycle takes either\n//   (x1 + ... + xl - m) + m * (l - 1) (swapping within the cycle) or\n//   (x1 + ... + xl - m) + M * (l - 1) + 2 * (m + M) (swapping using the global minimum)\n// Take the smaller of the two.\n\nstatic const size_t n_max = 1000;\nstatic std::pair<int, size_t> A[n_max];\nstatic size_t C[n_max];\nstatic bool visited[n_max];\n\nint main() {\n  size_t n;\n  scanf(\"%zu\\n\", &n);\n  for (size_t i = 0; i < n; i++) {\n    scanf(\"%d\", &A[i].first);\n    A[i].second = i;\n  }\n  std::sort(A, A + n);\n  int M = A[0].first;\n  int cost = 0;\n  for (size_t i = 0; i < n; i++) {\n    if (visited[i])\n      continue;\n    visited[i] = true;\n    C[0] = i;\n    size_t l = 1;\n    auto m = A[i].first, s = A[i].first;\n    while (!visited[A[C[l-1]].second]) {\n      C[l] = A[C[l-1]].second;\n      visited[C[l]] = true;\n      m = std::min(m, A[C[l]].first);\n      s += A[C[l]].first;\n      l++;\n    }\n    if (l == 1)\n      continue;\n    cost += std::min((s - m) + m * (l - 1), (s - m) + M * (l - 1) + 2 * (m + M));\n  }\n  printf(\"%d\\n\", cost);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ALDS1_6_D.cpp\n// Sort II - Minimum Cost Sort\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int MAXW = 10005;\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<int> w(n);\n\tvector<int> w_sorted(MAXW, -1);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> w[i];\n\t\tw_sorted[w[i]]++;\n\t}\n\t\n\tint w_cnt = 0;\n\tfor (int i = 0; i < w_sorted.size(); i++) {\n\t\tif (w_sorted[i] >= 0) {\n\t\t\tw_sorted[i] += w_cnt;\n\t\t\tw_cnt++;\n\t\t}\n\t}\n\n\tint w_min = MAXW;\n\t// int w_max = -1;\n\tint w_sum = 0;\n\tw_cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (w_sorted[w[i]] != i) {\n\t\t\tw_sum += w[i];\n\t\t\tw_min = min(w_min, w[i]);\n\t\t\t// w_max = max(w_max, w[i]);\n\t\t\tint tmp = w[w_sorted[w[i]]];\n\t\t\tif (w[w_sorted[tmp]] != w[i])\n\t\t\t\tw_cnt++;\n\t\t}\n\t}\n\tint res = w_sum + w_min * w_cnt;\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<math.h>\n#define Lens 1000\n#define Maxi 10005\n\nusing namespace std;\nint N,mini;\nint A[Lens], B[Lens],C[Maxi];\nbool V[Lens];\n\nint solve()\n{\n\tint total=0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B, B + N);\n\tmini = B[0];\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tC[B[i]] = i;\n\t\tif (B[i] == A[i]) V[i] = true;\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\twhile (V[i] == false)\n\t\t{\n\t\t\tint tmp = A[i];\n\t\t\tint min_tmp;\n\t\t\tint next = C[A[i]];\n\t\t\tint sum =A[i];\n\t\t\tint n = 0;\n\t\t\tV[i] = true;\n\t\t\tmin_tmp= min(A[i], A[next]);\n\t\t\twhile (!V[next])\n\t\t\t{\n\t\t\t\tn++;\n\t\t\t\tV[next] = true;\n\t\t\t\tsum = sum + A[next];\n\t\t\t\tif (A[next] < min_tmp) \n\t\t\t\t\tmin_tmp = A[next];\n\t\t\t\tnext= C[A[next]];\n\t\t\t}\n\t\t\ttotal = total + min(sum + (n - 1)*min_tmp, sum + min_tmp + (n + 2)*mini);\n\t\t}\n\t\t\n\t}\n\treturn total;\n}\n\nint main()\n{\n\tcin >> N;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> A[i];\n\t}\n\tint s = solve();\n\tcout << s << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\nusing std::scanf;\nusing std::printf;\n\nconst int kMaxN = 1000;\nconst int kMaxWi = 10000;\nconst int kSentinel = kMaxWi + 1;\n\n// w[i]?????????????????????????????????cycle???????????????????????????remain????????£?????????????¨????\n// ????????????cycle?????????\nint MakeCycle(int w[], int i, int remain[], int cycle[]) {\n  int j = 0;\n  cycle[0] = -1; //?????????while?????????????????????\n  while(w[i] != cycle[0]) {\n    cycle[j] = w[i];\n    ++j;\n    remain[i] = 0;\n    i = w[i] - 1;\n  }\n  return j;\n}\n\nint CompareCosts(int cycle[], int cycle_n, int cycle_min, int w_min) {\n  if (cycle_n == 1) {\n    return 0;\n  } else if (cycle_n == 2) {\n    return cycle[0] + cycle[1];\n  } else {\n    int cycle_sum, i, cost1, cost2;\n    cycle_sum = 0;\n    for (i = 0; i < cycle_n; ++i) { cycle_sum += cycle[i]; }\n    cost1 = cycle_sum + (cycle_n - 2) * cycle_min;\n    cost2 = cycle_sum + cycle_min + (cycle_n + 1) * w_min;\n    return std::min(cost1, cost2);\n  }\n}\n\nint main() {\n  int n, i, j, cycle_n, cycle_min, w_min, cnt;\n  scanf(\"%d\", &n);\n  int w[n], remain[n], cycle[n];\n  for (i = 0; i < n; ++i) { scanf(\"%d\", &w[i]); }\n  w_min = kMaxWi;\n  for (i = 0; i < n; ++i) { w_min = std::min(w_min, w[i]); }\n  for (i = 0; i < n; ++i) { remain[i] = 1; }\n  cnt = 0;\n  for (i = 0; i < n; ++i) {\n    if (remain[i]) {\n      cycle_n = MakeCycle(w, i, remain, cycle);\n      cycle_min = kMaxWi;\n      for (j = 0; j < cycle_n; ++j) { cycle_min = std::min(cycle_min, cycle[j]); }\n      cnt += CompareCosts(cycle, cycle_n, cycle_min, w_min);\n    }\n  }\n  printf(\"%d\", cnt);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\nconst ll mod2 = 998244353;\n\nint minw = 10005;\nbool seen[1005];\n\n\nll calcost(vector<pair<int, int> >& w, int id) {\n  if (seen[id] || id == w[id].second) {\n    seen[id] = true;\n    return 0;\n  }\n  int k = id;\n  int wsum = 0;\n  int n = 0;\n  int minpw = 100005;\n  while(!seen[k]) {\n    seen[k] = true;\n    int value = w[k].first;\n    minpw = min(minpw, value);\n    wsum += value;\n    k = w[k].second;\n    n++;\n  }\n  ll cost1 = wsum + (n-2) * minpw;\n  ll cost2 = wsum + minpw + (n+1) * minw;\n  ll cost = min(cost1, cost2);\n  return cost;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  vector<pair<int, int> > w(n);\n  rep(i, n) {\n    cin >> w[i].first;\n    minw = min(minw, w[i].first);\n    w[i].second = i;\n  }\n  sort(w.begin(), w.end());\n  ll ans = 0;\n  rep(i, n) {\n    ans += calcost(w, i);\n  }\n  cout << ans << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAX 1000\n#define VMAX 10000\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint solve() {\n  int ans = 0;\n\n  bool V[MAX];\n  for( int i = 0; i < n; i ++ ) {\n    B[i] = A[i];\n    V[i] = false;\n  }\n  sort(B, B+n);\n  for (int i = 0;i<n;i++)T[B[i]] = i;\n  // for (int i = 0;i<n;i++)cout << A[i]<< \" \" << B[i]<< \" \"<< T[B[i]] << endl;\n  for (int i =0;i < n; i ++) {\n    if (V[i]) continue;\n    int cur = i;\n    int S = 0;\n    int m = VMAX;\n    int an = 0;//サイクルの要素数\n    while (1) {\n      V[cur] = true;\n      an++;\n      int v = A[cur];\n      m = min(m,v);\n      S += v;//サイクルのコストの総和\n      cur = T[v];//上記で正しい順序のIndexバケツ？でサイクルができる\n      if ( V[cur] ) break;\n    }\n    ans += min(S + (an - 2)*m, m+S + (an+1)*s);//左:サイクル内の最小値\n  }\n  return ans;\n}\n\nint main() {\n  cin >> n;\n  s = VMAX;\n  for (int i = 0; i < n; i++) {\n    cin >> A[i];\n    s = min(s, A[i]);\n  }\n  int ans = solve();\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#define MAX 1010\n#define INF 1e+5\nusing namespace std;\n\nint Minimum_Cost_Sort(int A[], int n)\n{\n\tint B[MAX], visited[MAX], x = INF, ans = 0;\n\tmap<int, int> M;\n\t\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tB[i] = A[i];\n\t\tvisited[i] = false;\n\t\tx = min(x, A[i]);\n\t}\n\t\n\tsort(B, B+n);\n\t\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tM[B[i]] = i;\n\t}\n\t\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tint tmp = i;\n\t\tint circle_size = 0;\n\t\tint weight = 0;\n\t\tint mini = INF;\n\t\t\n\t\tdo\n\t\t{\n\t\t\tvisited[tmp] = true;\n\t\t\tweight += A[tmp];\n\t\t\tmini = min(mini, A[tmp]);\n\t\t\ttmp = M[A[tmp]];\n\t\t\tcircle_size++;\n\t\t}while(!visited[tmp]);\n\t\t\n\t\tans += min(weight + (circle_size-2) * mini, weight + (circle_size+1) * x + mini);\n\t}\n\treturn ans;\n}\n\nint main ()\n{\n\tint n, A[MAX];\n\tcin >> n;\n\tfor (int i = 0;i < n;i++)\n\t{\n\t\tcin >> A[i];\n\t}\n\t\n\tint mini_cost = Minimum_Cost_Sort(A, n);\n\t\n\tcout << mini_cost << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int VMAX=10001;\nint T[VMAX+1];\nint solve(int A[],int n,int Min){\n  int ans=0;\n  int *B=new int[n];\n  bool *v=new bool[n];\n  for(int i=0;i<n;i++){\n  \tB[i]=A[i];\n  \tv[i]=false;\n  }\n\n  sort(B,B+n);\n  for(int i=0;i<n;i++) T[B[i]]=i;\n  for(int i=0;i<n;i++){\n  \tif(v[i])continue;\n  \tint an = 0;\n\tint m = VMAX;//\n\tint cur = i;\n\tint s = 0;\n\tif(i!=T[A[i]]){\n\twhile(1){\n\t  \t  an++;\n\t      v[cur]=true;\n\t      int t=A[cur];\n\t      m=min(m,t);\n\t      s+=t;\n\t      cur=T[t];\n\t      if(v[cur])break;\n\t   }\n\n\t   ans+=min(s+(an-2)*m,s+m+(an+1)*Min);    \n\n  \t}\n  }\n   return ans;\n}\nint main(){\n\tint n;\n\tint Min=VMAX;//\n\tcin>>n;\n\tint *A=new int[n];\n\tfor(int i=0;i<n;i++){\n\t\tcin>>A[i];\n\t\tMin=min(Min,A[i]);\n\t}\n\tint ans=solve(A,n,Min);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst int mod=998244353;\nconst llint big=2.19e18+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n\nint main(void){\n\tcin.tie(0);ios::sync_with_stdio(false);\n\tllint n,i,ans=0,sai=mod;cin>>n;\n\tvector<pair<llint,int>>w(n);\n\tfor(i=0;i<n;i++){cin>>w[i].fir;w[i].sec=i;mineq(sai,w[i].fir);}\n\tSO(w);\n\tvector<bool>nao(n);\n\tfor(i=0;i<n;i++){\n\t\tif(nao[i]){continue;}\n\t\tllint sma=mod,wa=0,x=i,m=0;\n\t\tdo{\n\t\t\tm++;\n\t\t\tmineq(sma,w[x].fir);\n\t\t\twa+=w[x].fir;\n\t\t\tnao[x]=1;\n\t\t\tx=w[x].sec;\n\t\t}while(x!=i);\n\t\tans+=min((m-2)*sma+wa,wa+sma+(m+1)*sai);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst int MAXN = 200005;\n\nint w[1005], B[1005], L[100005], flag[1005];\n\nint main(){\n\tint n, ans = 0, Min = INF;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> w[i];\n\t\tB[i] = w[i];\n\t\tMin = min(Min, w[i]);\n\t}\n\tsort(B, B + n);\n\tfor(int i = 0; i < n; i++)\t\n\t\tL[B[i]] = i;\n\tfor(int i = 0; i < n; i++){\n\t\tif(flag[i])\n\t\t\tcontinue;\n\t\tint temp = i, S = INF, m = 0, cnt = 0;\n\t\twhile(!flag[temp]){\n\t\t\tcnt++;\n\t\t\tflag[temp] = 1;\n\t\t\tS = min(S, w[temp]);\n\t\t\tm += w[temp];\n\t\t\ttemp = L[w[temp]];\n\t\t}\n\t\tans += min(m + (cnt - 2) * S, m + (cnt + 1) * Min + S);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(void) {\n\tint n,a[1000];\n\tlong ans = 0;\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint min = a[i];\n\t\tint pos = i;\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (min > a[j]) {\n\t\t\t\tmin = a[j];\n\t\t\t\tpos = j;\n\t\t\t}\n\t\t}\n\t\tif (pos != i) {\n\t\t\tswap(a[pos], a[i]);\n\t\t\tans += a[pos] + a[i];\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nbool done[1000];\nint w[1000];\nint s[1000];\nint pos[10000];\n\ninline void swap(int *a, int i, int j){\n    int tmp = a[i];\n    a[i] = a[j];\n    a[j] = tmp;\n    return;\n}\n\nint partition(int *a, int n){\n    int x = a[n-1];\n    int i,j;\n    i=0;\n    for(j=0;j<n-1;j++){\n        if(a[j]<x){\n            swap(a,i,j);\n            i++;\n        }\n    }\n    swap(a,i,j);\n    return i;\n}\n\nvoid quickSort(int *a, int n){\n    if(n<1)return;\n\n    int q = partition(a,n);\n    quickSort(a,q);\n    quickSort(a+q+1,n-q-1);\n\n    return;\n}\n\nint researchPass(int p, int min){\n    done[p] = true;\n    if(pos[w[p]]==p)return 0;\n\n    int l=0,sum=0;\n    int i = p;\n    int lmin = 10001;\n\n    while(true){\n        done[i] = true;\n\n        l++;\n        sum+=w[i];\n        if(w[i]<lmin)lmin=w[i];\n\n        i = pos[w[i]];\n        if(i==p)break;\n    }\n\n    int c1 = (l-2) * lmin + sum;\n    int c2 = (l+1) * min + lmin + sum;\n    return std::min(c1,c2);\n}\n\nint solve(int n, int min){\n    int i,cost=0;\n    for(i=0;i<n;i++){\n        if(done[i])continue;\n        cost += researchPass(i,min);\n    }\n    return cost;\n}\n\nint main(){\n    int i,n,min=10001;\n\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++){\n        scanf(\"%d\",w+i);\n        if(w[i]<min)min=w[i];\n        s[i]=w[i];\n        done[i] = false;\n    }\n\n    quickSort(s,n);\n\n    for(i=0;i<n;i++){\n        pos[s[i]]=i;\n    }\n\n    printf(\"%d\\n\",solve(n,min));\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nvoid merge(int A[],int left, int mid, int right) {\n  int n1 = mid - left;\n  int n2 = right - mid;\n  int L[n1+1]; int R[n2+1];\n  for(int i=0;i<n1;i++) {\n    L[i] = A[left+i];\n  }\n  for(int i=0;i<n2;i++) {\n    R[i] = A[mid+i];\n  }\n  L[n1] = R[n2] = 0x7FFFFFFF;\n  int i = 0; int j = 0;\n  for(int k=left;k<right;k++) {\n    if(L[i] <= R[j]) {\n      A[k] = L[i];\n      i++;\n    }\n    else {\n      A[k] = R[j];\n      j++;\n    }\n  }\n}\nvoid merge_sort(int A[],int left, int right) {\n  if(right - left > 1) {\n    int mid = (left + right) / 2;\n    merge_sort(A,left, mid);\n    merge_sort(A,mid, right);\n    merge(A,left, mid, right);\n  }\n}\n\nint search(int Sorted[],int left,int right, int key) {\n  while(right >= left) {\n    int mid = (left + right) / 2;\n    if(Sorted[mid] == key) {\n      return mid;\n    }\n    if(Sorted[mid] < key) {\n      left = mid + 1;\n    }\n    else {\n      right = mid - 1;\n    }\n  }\n  return -1;\n}\n\nint main() {\n  int n; cin >> n;\n  int W[n]; int Sorted[n];\n  for(int i=0;i<n;i++) {\n    int num; cin >> num;\n    W[i] = Sorted[i] = num;\n  }\n  merge_sort(Sorted,0,n);\n\n  // ??¢?????°??????Swap????????´??????????°???¨??????\n  int weight = 0;\n  for(int i=0;i<n;i++) {\n    int it = search(Sorted,i,n,W[i]);\n    if(it < 0 || it >= n) cout << \"Oops!\" << endl;\n\n    if(it != i) {\n      weight += W[i] + W[it];\n      swap(W[i],W[it]);\n    }\n  }\n  cout << weight << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nint n, w[1000], s;\nint a[1000], d[1001]; //destination \n\nlong solve(){\n\tlong ret=0;\t\n\t\n\tbool v[1000];\n\tfor(int i=0; i<n; ++i){\n\t\ta[i]=w[i];\n\t\tv[i]=false;\t\n\t}\n\tsort(a, a+n); //a[]??????w[]???????????¢?????\\???\n\t\n\t//??????a[i]??????????????????????????´??????d[]?????\\??????\n\tfor(int i=0; i<n; ++i) d[a[i]]=i;\n\t\n\tfor(int i=0; i<n; ++i){\n\t\tif(v[i]) continue; //??¢???????????????????????????????????????????????§???????????????????????£?????????\n\t\t\n\t\t//?????????????????¢???\n\t\tint cur=i; //?????¨??????\n\t\tint sum=0;\n\t\tint m=10000; //???????????????????????????????°????\n\t\tint an=0; //?????????????????§??????\n\t\t\n\t\twhile(1){\n\t\t\tv[cur]=true; //?¨??????????????¨????\n\t\t\tan++;\n\t\t\tint z=w[cur];\n\t\t\tsum+=z;\n\t\t\tm=min(m, z);\n\t\t\tcur=d[z]; //?¬??????????\n\t\t\tif(v[cur]) break; //?????¨??????\n\t\t}\n\t\t\n\t\tret += min(sum+(an-2)*m , m+sum+(an+1)*s);\t\n\t}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\" %d\", &n);\n\t\n\ts=10000;\n\tfor(int i=0; i<n; ++i){\n\t\tscanf(\" %d\", &w[i]);\n\t\ts=min(s, w[i]); //s???w[]?????????????°????????´?\n\t}\n\t\n\tprintf(\"%ld\\n\", solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n\n\nusing namespace std;\n\nvoid trace(vector<int> v) {\n\tfor (auto it = v.begin(); it != v.end(); ++it) {\n\t\tcout << setw(3) << *it << \" \";\n\t}\n\tcout << endl;\n}\n\nint main() {\n\t\n\tint const N_MAX = 1000;\n\tint const W_MAX = 10000;\n\n\tint n = 0;\n\tcin >> n;\n\n\tvector<int> W, S, T;\n\tvector<bool> C;\n\t\n\tW.resize(n, 0);     // idx -> W\n\tS.resize(n, 0);     // sorted Wi\n\tT.resize(W_MAX, 0); // W -> idx\n\tC.resize(n, false); // flag for searched or not\n\n\tint g_min = W_MAX; // global_min of Wi\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> W[i];\n\t\tg_min = (W[i] < g_min) ? W[i] : g_min;\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tT[W[i]] = i;\n\t}\n\n\tS = W;\n\tstable_sort(S.begin(), S.end());\n\n\tint score = 0;\n\n\t//cout << \"<<W>> \";\n\t//trace(W);\n\t//cout << \"<<S>> \";\n\t//trace(S);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!C[T[S[i]]]) {\n\t\t\tint l_min = W_MAX;\n\t\t\tint sum = 0;\n\t\t\tint cnt = 0;\n\t\t\t//vector<int> L;\n\t\t\tfor(int j = S[i]; !C[T[j]]; j = S[T[j]] ) {\n\t\t\t\t//L.push_back(j);\n\t\t\t\tC[T[j]] = true;\n\t\t\t\tcnt++;\n\t\t\t\tsum += j;\n\t\t\t\tl_min = (j < l_min) ? j : l_min;\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t\t//cout << \"<<L>> \";\n\t\t\t//trace(L);\n\t\t\t//cout << \"sum:\" << sum << \" N:\" << cnt << \" l_min:\" << l_min << \" g_min\" << g_min << endl;\n\t\t\t//cout << sum + l_min*(cnt - 2) << \" or \" << sum + g_min*(cnt + 1) + l_min << endl;\n\t\t\tscore += min(sum + l_min*(cnt - 2), sum+g_min*(cnt+1)+l_min);\n\t\t\t//cout << \"Now, Cost is \" << score << endl;\n\t\t\t//L.clear();\n\t\t}\n\t}\n\n\tcout << score << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve() {\n    int ans = 0;\n\n    bool V[MAX];\n    for (int i = 0; i < n; ++i) {\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B, B + n);\n    for (int i = 0; i < n; ++i) {\n        T[B[i]] = i;\n    }\n    for (int i = 0; i < n; ++i) {\n        if (V[i]) {\n            continue;\n        }\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while (true) {\n            V[cur] = true;\n            ++an;\n            int v = A[cur];\n            m = min(m, v);\n            S += v;\n            cur = T[v];\n            if (V[cur]) {\n                break;\n            }\n        }\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n    }\n\n    return ans;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    s = VMAX;\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &A[i]);\n        s = min(s, A[i]);\n    }\n    int ans = solve();\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstatic void inputArray(int A[], int num) {\n  for (int i = 0; i < num; i++) {\n    cin >> A[i];\n   }\n}\n\nstatic void printArray(int A[], int num) {\n  for (int i = 0; i < num; i++) {\n    cout << ((i != 0) ? \" \" : \"\") << A[i];\n  }\n  cout << endl;\n}\n\nstatic const size_t NMAX = 1000;\nstatic const size_t VMAX = 10000;\n\nstatic vector<int> A(NMAX), B(NMAX);\nstatic vector<int> TABLE(VMAX + 1, 0);\nstatic vector<bool> SORTED(NMAX, false);\n\nstatic inline void printArray(vector<bool>& A, int num) {\n  for (int i = 0; i < num; i++) {\n    cout << ((i == 0) ? \"\" : \" \") << A[i];\n  } \n  cout << endl;\n}\n\nstatic inline int solve(int A[], int num) {\n  B.assign(&A[0], &A[num]);\n  sort(B.begin(), B.end());\n\n  for (int i = 0; i < num; i++) {\n    TABLE[B[i]] = i;\n  }\n//  printArray(&TABLE[0], B[num - 1] + 1);\n\n  int ans = 0;\n  for (int i = 0; i < num; i++) {\n    if (SORTED[i]) {\n      continue;\n    }\n    \n    int cursor = i;\n    int total = 0;\n    int min = VMAX;\n    int numInCycle = 0;\n    while (true) {\n      SORTED[cursor] = true;\n      numInCycle++;\n      min = std::min(min, A[cursor]);\n      total += A[cursor];\n      cursor = TABLE[A[cursor]];\n      if (SORTED[cursor]) {\n        break;     \n      }\n    }\n    ans += std::min(total + (numInCycle - 2) * min, min + total + (numInCycle + 1) * B[0]);\n/*\n    cout << \"total = \" << total << \", numInCycle = \" << numInCycle << \", min = \" << min << \", B[0] = \" << B[0] << endl; \n    cout << \"ans = \" << ans << endl;\n    printArray(SORTED, num);\n*/\n  }\n\n  return ans;\n}\n\nint main() {\n  int n;\n  cin >> n;\n\n  inputArray(&A[0], n);\n\n  const int ans = solve(&A[0], n);\n  \n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <unordered_map>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nnamespace std{\n\ttemplate<typename T>\n\tinline void hash_combine(size_t& seed, T const& v){\n\t\tseed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n\t}\n    template<typename It>\n    inline size_t hash_range(It first, It last){\n\t\tsize_t seed=0;\n\t\thash_range(seed,first,last);\n\t\treturn seed;\n\t}\n\ttemplate<typename It>\n\tinline void hash_range(size_t& seed, It first, It last){\n\t\tfor(;first!=last;++first)hash_combine(seed, *first);\n\t}\n\ttemplate<typename A,typename B>\n\tclass hash<pair<A,B>>{\n\t\tpublic:\n\t\tsize_t operator()(pair<A,B> const &p) const{\n\t\t\tsize_t seed=0;\n\t\t\thash_combine(seed,p.first);\n\t\t\thash_combine(seed,p.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\ttemplate<typename T,size_t N>\n\tclass hash<array<T,N>>{\n\t\tpublic:\n\t\tsize_t operator()(array<T,N> const &container) const{\n\t\t\treturn hash_range(container.begin(),container.end());\n\t\t}\n\t};\n\ttemplate<typename T,typename A>\n\tclass hash<vector<T,A>>{\n\t\tpublic:\n\t\tsize_t operator()(vector<T,A> const &container) const{\n\t\t\treturn hash_range(container.begin(),container.end());\n\t\t}\n\t};\n}\n\nint main(){\n\tint N;\n\tscanf(\"%d\",&N);\n\tvector<int>v(N);\n\tfor(int i=0;i<N;i++)scanf(\"%d\",&v[i]);\n\tpriority_queue<pair<int,vector<int> > >q;\n\tunordered_map<vector<int>,int>depth;\n\n\tq.push(make_pair(0,v));\n\tint R;\n\tfor(;!q.empty();){\n\t\tauto cur=q.top();\n\t\tq.pop();\n\t\tif(depth.find(cur.second)!=depth.end())continue;\n\t\tdepth[cur.second]=cur.first;\n\t\tbool f=false;\n\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++)if(i!=j&&cur.second[i]>cur.second[j]){\n\t\t\tif(i<j)f=true;\n\t\t\tswap(cur.second[i],cur.second[j]);\n\t\t\tif(depth.find(cur.second)==depth.end())q.push(make_pair(cur.first-cur.second[i]-cur.second[j],cur.second));\n\t\t\tswap(cur.second[i],cur.second[j]);\n\t\t}\n\t\tif(!f){\n\t\t\tR=-cur.first;\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",R);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define MAX_N 10000\n#define MAX_V 100000000\n#define INF 1000000000\n\nint n, A[MAX_N], s, B[MAX_N], T[MAX_V];\n\nint minimum_cost_sort() {\n\tint ans = 0;\n\tbool V[MAX_N];\n\tfor (int i = 0; i < MAX_V; i++) { V[i] = false; }\n\tfor (int i = 0; i < n; i++) { B[i] = A[i]; }\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; i++) { T[B[i]] = i; }\n\tfor (int i = 0; i < n; i++) {\n\t\tif (V[i]==true) { goto owata; }\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = INF;\n\t\tint x = 0;\n\t\twhile (1) {\n\t\t\tV[cur] = true;\n\t\t\tx++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif (V[cur]) { break; }\n\t\t}\n\t\tans += min(S + (x - 2)*m, m + S + (x + 1)*s);\n\towata:;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tcin >> n;\n\ts = INF;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tcout << minimum_cost_sort() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 12:41\n//\n\n// w[0], w[1], ..., w[n-1]\n// ex. 9 7 6 1\n//  -> 1 6 7 9 \n// このように 1, 9の交換, 6,7の交換のようにペアの交換で済む場合は,\n// ex. 2 3 1\n//  -> 1 2 3 \n// このように, 1, 2, 3の3つ以上の巡回置換の場合は,\n// ...\n// まとめると, 辿っていくと問題がある. \n// \n// 10 7  8  9\n// 7  8  9 10\n// 7+10\n// 7+8\n// 8+9\n// 9+10\n\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <unordered_set>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\nusing ll = long long;\n\nstruct Value {\n\tll v;\n\tll idx;\n};\n\nclass lesserValue{\npublic:\n\tbool operator()(const Value &x, const Value &y) {\n\t\treturn x.v < y.v;\n\t}\n};\n\nvoid print(const vector<Value> &x) {\n\tfor (ll i=0;i<x.size();++i) {\n\t\tif (i!=0) cout << \" \";\n\t\tcout << x[i].v << \",\" << x[i].idx;\n\t}\n\tcout << endl;\n}\n\nint main() {\n\tll n;\n\tcin >> n;\n\tvector<Value> w(n);\n\tfor (ll i=0;i<n;++i) {\n\t\tscanf(\"%lld\", &w[i].v);\n\t\tw[i].idx = i;\n\t}\n\t//print(w);\n\tvector<Value> orig(w);\n\t//print(orig);\n\t// sort by ascending order\n\tsort(w.begin(), w.end(), lesserValue()); \n\t//print(w);\n\tunordered_set<ll> memo;\n\tll ans = 0;\n\tfor (ll i=0;i<n;++i) {\n\t\t// orig: 4 2 3\n\t\t// 0 1 2\n\t\t// w:    2 3 4\n\t\t// 1 2 0\n\t\t// w[0].v = 2;\n\t\t// i = 0; \n\t\t// j = w[i].idx;\n\t\t// w[0].idx = 1;\n\t\t// w[1].idx = 2;\n\t\t// w[2].idx = 0;\n\t\t//cout << \"[\" << i << \"]: \"; \n\t\tif (memo.end() != memo.find(i)) {\n\t\t\t//cout << \"skipped \" << i << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tmemo.insert(i);\n\t\t//cout << \"inserted \" << i << \" \";\n\t\t//vector<ll> t;\n\t\tll j = w[i].idx;\n\t\twhile (i != j) {\n\t\t\tmemo.insert(j);\n\t\t\t//t.push_back(w[i].v + w[j].v);\n\t\t\tans += w[i].v + w[j].v;\n\t\t \tj\t= w[j].idx;\n\t\t\t//cout << \"inserted \" << j << \" \" << endl;\n\t\t}\n//\t\tans += accumulate(t.begin(), t.end(), 0);\n//\t\tif (t.size() > 0) {\n//\t\t\tans -= *max_element(t.begin(), t.end());\n//\t\t}\n\t\t//cout << \"ans[\" << i << \"] = \" << ans << endl;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main(){\n\tint n;\n\tcin >> n;\n\t\n\tvector<int> vec(n);\n\tvector<P> sorted(n);\n\t\n\tfor (int i=0;i<n;i++){\n\t\tsorted[i].second = i;\n\t\tcin >> sorted[i].first;\n\t\tvec[i]=sorted[i].first;\n\t}\n\t\n\tsort(sorted.rbegin(),sorted.rend());\n\t\n\tint count=0;\n\t\n\t\n\tfor (int i=0 ; i<n-1 ; i++){\n\t\tint j;\n\t\tfor (j=0;j<n;j++){\n\t\t\tif(sorted[j].first==vec[n-i-1]){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint max_ind = sorted[i].second;\n\t\t//update vec\n  \t\tswap(vec[n-i-1],vec[max_ind]);\n\t\tif(vec[n-i-1]!=vec[max_ind]){\n\t\t\tcount=count+vec[n-i-1]+vec[max_ind];\n\t\t}\n\t\t// update sorted\n\t\tsorted[j].second=sorted[i].second;\n\t\tsorted[i].second=n-i-1;\n\t}\n\t/*\n\tfor(int k=0;k<n;k++){\n\t\tcout << vec[k] <<\" \";\n\t}\n\t*/\n\tcout << count << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int INF = 1000000;\n\nstruct node\n{\n\tint num;\n\tint place;  \n};\n\nint partition(node *A,int p,int r)\n{\n\tint j,temp;\n\tnode x;\n\n\tx = A[r];\n\tj = p-1;\n\n\tfor(int i = p; i < r; i++)\n\t{\n\t\tif (A[i].num <= x.num)\n\t\t{\n\t\t\tj++;\n\t\t\ttemp = A[i].num;\n\t\t\tA[i].num = A[j].num;\n\t\t\tA[j].num = temp;\n\t\t}\n\t}\n\n\ttemp = A[j+1].num;\n\tA[j+1].num = A[r].num;\n\tA[r].num = temp;\n\n\treturn j+1;\n}\n\nvoid quicksort(node *A,int p,int r)\n{\n\tint q;\n\n\tif (p < r)\n\t{\n\t\tq = partition(A,p,r);\n\t\tquicksort(A,p,q-1);\n\t\tquicksort(A,q+1,r);\n\t}\n}\n\n\nint main()\n{\n\tint n,sum,minall,mini,sol,cnt,j;\n\tnode a[1000] = {0},b[1000] = {0};\n\n\tsol = 0;\n\tminall = INF;\n\n\tscanf(\"%d\", &n);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i].num);\n\t\ta[i].place = i;\n\t\tb[i] = a[i];\n\t\tb[i].place = i;\n\t}\n\n\tquicksort(b,0,n-1);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tsum = 0;\n\n\t\tif (a[i].num >= 0)\n\t\t{\n\t\t\tsum += a[i].num;\n\t\t\tmini = a[i].num;\n\t\t\tcnt = 1;\n\t\t\tj = i;\n\n\t\t\twhile(b[a[j].place].num != a[i].num)\n\t\t\t{\n\t\t\t\tfor(int k = 0; k < n; k++)\n\t\t\t\t{\n\t\t\t\t\tif (a[k].num == b[a[j].place].num)\n\t\t\t\t\t{\n\t\t\t\t\t\tj = k;\n\t\t\t\t\t\tsum += a[k].num;\n\t\t\t\t\t\tcnt++;\n\n\t\t\t\t\t\tif (mini > a[k].num)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmini = a[k].num;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ta[k].num = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ta[i].num = -1;\n\n\t\t\tsol += min(sum + mini * (cnt -2), sum + mini + (cnt + 1) * b[0]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", sol);\n\n\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\nint n;\nint w[1000];\nint k[1000];\nint u[1000];\n\nint main(){\n\tscanf(\"%d\", &n);\n\trep(i, n){\n\t\tscanf(\"%d\", &w[i]);\n\t}\n\n\tvector<int> v(w, w + n);\n\tsort(v.begin(), v.end());\n\trep(i, n){\n\t\tk[i] = lower_bound(v.begin(), v.end(), w[i]) - v.begin();\n\t}\n\n\tint x = *min_element(w, w + n);\n\tint ans = 0;\n\trep(i, n){\n\t\tif(u[i]){\n\t\t\tcontinue;\n\t\t}\n\t\tint c = 1;\n\t\tint s = w[i];\n\t\tint m = w[i];\n\t\tu[i] = true;\n\t\tint j = k[i];\n\t\twhile(!u[j]){\n\t\t\t++c;\n\t\t\ts += w[j];\n\t\t\tm = min(m, w[j]);\n\t\t\tu[j] = true;\n\t\t\tj = k[j];\n\t\t}\n\t\tans += min(s + m * (c - 2), s + x * (c - 2) + (m + x));\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nstruct QuickFind{\n  vector<int> r,p;\n  vector<vector<int> > v;\n  QuickFind(){}\n  QuickFind(int size){init(size);}\n  void init(int size){\n    r.resize(size,0);\n    p.resize(size,0);\n    v.resize(size);\n    for(int i=0;i<size;i++){\n      r[i]=1,p[i]=i;\n      v[i].resize(1,i);\n    }\n  }\n  bool same(int x,int y){\n    return p[x]==p[y];\n  }\n  void unite(int x,int y){\n    x=p[x];y=p[y];\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    for(int i=0;i<(int)v[y].size();i++){\n      p[v[y][i]]=x;\n      v[x].push_back(v[y][i]);\n    }\n    v[y].clear();\n  }\n};\nsigned main(){\n  int n;\n  cin>>n;\n  vector<int> a(n);\n  for(int i=0;i<n;i++) cin>>a[i];\n  vector<int> b(a);\n  sort(b.begin(),b.end());\n  map<int,int> p,q;\n  for(int i=0;i<n;i++){\n    p[a[i]]=i;\n    q[b[i]]=i;\n  }\n  QuickFind qf(n);\n  for(int i=0;i<n;i++) \n    qf.unite(i,p[b[i]]);\n  //for(int i=0;i<n;i++) cout<<i<<\" \"<<p[b[i]]<<endl;\n  int ans=0;\n  for(int i=0;i<n;i++){\n    int k=qf.v[i].size();\n    if(qf.p[i]!=i||k==1) continue;\n    int m=a[qf.v[i][0]];\n    int tmp=0;\n    for(int j=0;j<k;j++){\n      //cout<<\" \"<<a[qf.v[i][j]];\n      tmp+=a[qf.v[i][j]];\n      m=min(m,a[qf.v[i][j]]);\n    }\n    //cout<<endl;\n    ans+=min(tmp+m*(k-2),tmp+m+b[0]*(k+1));\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdlib.h>\n#include <iostream>\n#include <climits>\nusing namespace std;\n\nstruct weight{\n\tint val;\n\tint id;\n\tweight(){\n\t\tval = 0;\n\t\tid  = 0;\n\t}\n\tweight(weight *w){\n\t\tval = w->val;\n\t\tid  = w->id;\n\t}\n\tvoid set(weight *w){\n\t\tval = w->val;\n\t\tid  = w->id;\n\t}\n};\n\nvoid merge_sort(weight *array, int left, int right);\nvoid merge(weight *array, int left, int mid, int right);\nvoid swap(weight *a, weight *b);\nint cal_min_swap(weight *original, weight *sorted, int num);\nint linear_search(weight *array, int size, int num);\n\nint main(){\n\tint n;\n\n\tcin >> n;\n\n\tweight* original = (weight*)malloc(n * sizeof(weight));\n\tweight* sorted   = (weight*)malloc(n * sizeof(weight));\n\tint result = 0;\n\n\tif(n < 1){\n\t\treturn 0;\n\t}\n\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> original[i].val;\n\t\toriginal[i].id = i;\n\t\tsorted[i].set(&original[i]);\n\t}\n\n\tmerge_sort(sorted, 0, n);\n\tcout << cal_min_swap(original, sorted, n) << endl;\n\treturn 0;\n}\n\nvoid merge_sort(weight *array, int left, int right){\n\tif(left+1 < right){\n\t\tint mid = (left + right) >> 1;\n\t\tmerge_sort(array, mid, right);\n\t\tmerge_sort(array, left, mid);\n\t\tmerge(array, left, mid, right);\n\t}\n\n}\n\nvoid merge(weight *array, int left, int mid, int right){\n\tint n1 = mid - left;\n\tint n2 = right - mid;\n\n\tweight* L = (weight*)malloc((n1+1) * sizeof(weight));\n\tweight* R = (weight*)malloc((n2+1) * sizeof(weight));\n\n\tfor(int i = 0; i < n1; ++i){\n\t\tL[i].set(&array[left+i]);\n\t}\n\tL[n1].val = INT_MAX;\n\tfor(int i = 0; i < n2; ++i){\n\t\tR[i].set(&array[mid+i]);\n\t}\n\tR[n2].val = INT_MAX;\n\n\tint i = 0;\n\tint j = 0;\n\tfor(int k = left; k < right; ++k){\n\t\tif(L[i].val <= R[j].val){\n\t\t\tarray[k].set(&L[i]);\n\t\t\t++i;\n\t\t}else{\n\t\t\tarray[k].set(&R[j]);\n\t\t\t++j;\n\t\t}\n\t}\n}\n\nvoid swap(weight *a, weight *b){\n\tweight *temp = new weight(b);\n\tb->set(a);\n\ta->set(temp);\n\tfree(temp);\n}\n\nint cal_min_swap(weight *original, weight *sorted, int num){\n\tint total_swap_w = 0;\n\tint temp_i = 0;\n\tbool is_swap = false;\n\tint swap_num = 0;\n\tint min = sorted[0].val;\n\tint this_min = 0;\n\tint this_total_swap_num = 0;\n\tstring test;\n\tfor(int i = 0; i < num; ++i){\n\t\tif(original[i].id != sorted[i].id){\n\t\t\tif(!is_swap){\n\t\t\t\ttemp_i = i;\n\t\t\t\tswap_num = 0;\n\t\t\t\tthis_min = sorted[i].val;\n\t\t\t\tthis_total_swap_num = 0;\n\t\t\t}\n\t\t\tthis_total_swap_num += original[i].val;\n\t\t\tint swap_i = linear_search(sorted, num, original[i].val);\n\t\t\tswap(&sorted[i], &sorted[swap_i]);\n\t\t\ti = swap_i - 1;\n\t\t\tis_swap = true;\n\t\t\tswap_num++;\n\t\t}else{\n\t\t\tif(is_swap){\n\t\t\t\tif(swap_num != 1){\n\t\t\t\t\tif(min*swap_num + 2*(min + this_min) < this_min*swap_num){\n\t\t\t\t\t\tthis_total_swap_num += min*swap_num + 2*(min + this_min);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tthis_total_swap_num += this_min*swap_num;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tthis_total_swap_num += this_min;\n\t\t\t\t}\n\t\t\t\ttotal_swap_w += this_total_swap_num;\n\t\t\t\tthis_total_swap_num = 0;\n\t\t\t\ti = temp_i;\n\t\t\t\tis_swap = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn total_swap_w;\n}\nint linear_search(weight *array, int size, int num){\n\tfor(int i = 0; i < size; ++i){\n\t\tif(array[i].val == num){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdlib.h> \nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, s;\nint A[MAX], B[MAX], T[VMAX + 1]; //\"+ 1\" is important.\n\nint solve()\n{\n\tint ans = 0;\n\t\n\tbool V[MAX];\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\t\n\tsort(B, B+n);\n\t\n\t//Build a map from value to ideal order. \n\tfor(int i = 0; i < n; i++) T[B[i]] = i;\n\t//Tranverse.\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(V[i]) continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile(1)\n\t\t{\n\t\t\tV[cur] = true;\n\t\t\tan++; \n\t\t\tint v = A[cur];\n\t\t\tm = min(v, m);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif(V[cur]) break;\n\t\t}\n\t\tans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n\t}\n\t\n\treturn ans;\n}\nint main() {\n\t\n\tcin >> n;\n\ts = VMAX;\n\tfor( int i = 0; i < n; i++)\n\t{\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\t\n\tint ans = solve();\n\tcout << ans << endl;\n\t\n//\tsystem(\"pause\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nstruct QuickFind {\n    vector<int>          r, p;\n    vector<vector<int> > v;\n    QuickFind() {}\n    QuickFind(int size) { init(size); }\n    void init(int size) {\n        r.resize(size, 0);\n        p.resize(size, 0);\n        v.resize(size);\n        for (int i = 0; i < size; i++) {\n            r[i] = 1, p[i] = i;\n            v[i].resize(1, i);\n        }\n    }\n    bool same(int x, int y) { return p[x] == p[y]; }\n    void unite(int x, int y) {\n        x = p[x];\n        y = p[y];\n        if (x == y) return;\n        if (r[x] < r[y]) swap(x, y);\n        r[x] += r[y];\n        for (int i = 0; i < (int)v[y].size(); i++) {\n            p[v[y][i]] = x;\n            v[x].push_back(v[y][i]);\n        }\n        v[y].clear();\n    }\n};\nsigned main() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) cin >> a[i];\n    vector<int> b(a);\n    sort(b.begin(), b.end());\n    map<int, int> p, q;\n    for (int i = 0; i < n; i++) {\n        p[a[i]] = i;\n        q[b[i]] = i;\n    }\n    QuickFind qf(n);\n    for (int i = 0; i < n; i++) qf.unite(i, p[b[i]]);\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        int k = qf.v[i].size();\n        if (qf.p[i] != i || k == 1) continue;\n        int m   = a[qf.v[i][0]];\n        int tmp = 0;\n        for (int j = 0; j < k; j++) {\n            tmp += a[qf.v[i][j]];\n            m = min(m, a[qf.v[i][j]]);\n        }\n        ans += min(tmp + m * (k - 2), tmp + m + b[0] * (k + 1));\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nvoid merge(vector<pair<int,int> >& w, int left, int mid, int right) {\n\tvector<pair<int,int> > L,R;\n\tint n1=mid-left;\n\tint n2=right-mid;\n\tint i=0,j=0,k;\n\tL.resize(n1+1);\n\tR.resize(n2+1);\n\tfor(i=0; i<n1; ++i) {\n\t\tL[i]=w[left+i];\n\t}\n\tL[n1].first = -1;\n\tL[n1].second = 1000000001;\n\tfor(i=0; i<n2; ++i) {\n\t\tR[i]=w[mid+i];\n\t}\n\tR[n2].first = -1;\n\tR[n2].second = 1000000001;\n\n\ti=j=0;\n\tfor(k=left; k<right; ++k) {\n\t\tif(L[i].second < R[j].second) {\n\t\t\tw[k]=L[i];\n\t\t\t++i;\n\t\t} else {\n\t\t\tw[k]=R[j];\n\t\t\t++j;\n\t\t}\n\t}\n\treturn;\n}\n\nvoid mergeSort(vector<pair<int,int> >& w, int left, int right) {\n\tif(left+1<right) {\n\t\tint mid=left+(right-left)/2;\n\t\tmergeSort(w,left,mid);\n\t\tmergeSort(w,mid,right);\n\t\tmerge(w,left,mid,right);\n\t}\n\treturn;\n}\n\nint main() {\n\tint n;\n\tint i,j;\n\tint total=0;\n\tvector<int> checker;\n\tvector<pair<int,int> > w; // first=original_index, second =weight_value will be sorted.\n\tscanf(\"%d\",&n);\n\tw.resize(n);\n\tchecker.resize(n);\n\tfor(i=0; i<n; ++i) {\n\t\tchecker[i]=0;\n\t\tw[i].first=i;\n\t\tscanf(\"%d\",&w[i].second);\n\t}\n\tmergeSort(w,0,n);\n\tfor(i=0; i<n; ++i) {\n\t\tif(checker[i]==1 || w[i].first==i) {\n\t\t\tcontinue; // already checked or unmoved\n\t\t}\n\t\tchecker[i]=1;\n\t\tj=w[i].first;\n\t\twhile(j!=i) {\n\t\t\ttotal+=w[i].second+w[j].second;\n\t\t\tchecker[j]=1;\n\t\t\tj=w[j].first;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",total);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX = 1000;\nconst int VMAX = 100000;\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX +1];\n\nint solve(){\n    int ans = 0;\n    bool V[MAX];\n    for (int i = 0; i < n ; ++i) {\n        B[i] = A[i];\n        v[i] = false;\n    }\n    sort (B,B+n);\n    for (int i = 0; i < n ; ++j) T[B[i]] = i;\n    for (int i = 0; i < n ; ++i) {\n        if(V[i]) continue;\n        int cur = i, S = 0, m = VMAX,an =0;\n        while(1){\n            V[cur] = true;\n            an ++;\n            long v = A[cur];\n            m = min (m,v);\n            s += v;\n            cur = T[v];\n            if(V[cur]) break;\n        }\n        ans += min(S + (an -2) *m ,m + S + (an + 1)*s);\n    }\n    return ans;\n}\n\nint main (){\n    cin >> n;\n    s = VMAX;\n    for (int i = 0; i < n ; ++i) {\n        cin >> A[i];\n        s = min(s,A[i]);\n    }\n    int ans = solve();\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define WEIGHT_MAX 10000\n\nint partition(int *a, int p, int r){\n    int x = a[r];\n    int i = p - 1;\n    int tmp1;\n    for(int j=p;j<r;j++){\n        if(a[j]<=x){\n            i++;\n            tmp1 = a[j];\n            a[j] = a[i];\n            a[i] = tmp1;\n        }\n    }\n    a[r] = a[i+1];\n    a[i+1] = x;\n    return i + 1;\n}\n\nvoid quickSort(int *a, int p, int r){\n    if(p>=r)return;\n    int q = partition(a, p, r);\n    quickSort(a, p, q-1);\n    quickSort(a, q+1, r);\n}\n\nint calc(int *w, int *s, int *p, int hoge, int n){\n    if(hoge==n)return 0;\n    int p0 = p[s[hoge]];\n    if(p0==hoge)return calc(w,s,p,hoge+1,n);\n    int p1 = p[s[p0]];\n    p[s[hoge]] = p1;\n    p[s[p0]] = p0;\n    if(p1==hoge)return s[hoge]+s[p0]+calc(w,s,p,hoge+1,n);\n    else return s[hoge]+s[p0]+calc(w,s,p,hoge,n);\n}\n\nint main(){\n    int i, n;\n    int p[WEIGHT_MAX+1];\n    scanf(\"%d\",&n);\n    int w[n];\n    int s[n];\n    for(i=0;i<n;i++){\n        scanf(\"%d\",w+i);\n        s[i]=w[i];\n        p[w[i]]=i;\n    }\n    quickSort(s,0,n-1);\n    int cost = calc(w,s,p,0,n);\n    printf(\"%d\\n\",cost);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\tint n, c = 0;\n\tint a[1000], b[1000];\n\tbool f[1000];\n\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\n\tmemcpy(b, a, sizeof(a));\n\tsort(b, b + n);\n\tmemset(f, 0, sizeof(f));\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] == b[i])\n\t\t\tf[i] = 1;\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (f[i] == 0){\n\t\t\twhile (a[i] != b[i]) {\n\t\t\t\tint j = i, k = i;\n\t\t\t\twhile (f[j] == 1 || a[j] != b[i])\n\t\t\t\t\tj++;\n\t\t\t\twhile (f[k] == 1 || a[k] != b[j])\n\t\t\t\t\tk++;\n\t\t\t\tswap(a[j], a[k]);\n\t\t\t\tc += a[j] + a[k];\n\t\t\t\tf[j] = 1;\n\t\t\t}\n\t\t\tf[i] = 1;\n\t\t}\n\t}\n\n\tcout << c << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = 1e9;\n\nint G[10010];\nint w[1010];\nint a[1010];\n\nvoid swap( int& a, int& b ){\n  int tmp = a;\n  a = b;\n  b = tmp;\n}\n\nint Partition( int p, int r ){\n  int x = a[r];\n  int i = p - 1;\n  for( int j = p; j < r; j++ ){\n    if( a[j] <= x ){\n      i++;\n      ::swap( a[i], a[j] ); \n    }\n  }\n  ::swap( a[i + 1], a[r] );\n\n  return i + 1;\n}\n\nvoid QuickSort( int p, int r ){\n  if( p < r ){\n    int q = Partition( p, r );\n    QuickSort( p, q - 1 );\n    QuickSort( q + 1, r );\n  }\n}\n\nbool seen[10010];\nint sum = 0, cnt = 0, pmin = INF;\nvoid rec( int s ){\n  if( seen[s] ) return;\n\n  seen[s] = true;\n  sum += s;\n  pmin = min( pmin, s );\n  cnt++;\n  rec( G[s] ); \n}\n\nint main(){\n  int N; cin >> N;\n  for( int i = 0; i < N; i++ ){\n    cin >> w[i];\n    a[i] = w[i];\n  }\n\n  QuickSort( 0, N - 1 );\n\n  for( int i = 0; i < N; i++ ){\n    int j;\n    for( j = 0; j < N; j++ ){\n      if( w[i] == a[j] ) break;\n    }\n    G[w[i]] = w[j];\n  }\n\n  int ans = 0;\n  int smin = a[0];\n  for( int i = 0; i < N; i++ ){\n    sum = 0;\n    pmin = INF;\n    cnt = 0;\n\n    rec( w[i] );\n    if( cnt >= 2 ){\n      ans += min( sum + ( cnt - 2 ) * pmin, sum + pmin + ( cnt + 1 ) * smin );\n    }\n  }\n\n  cout << ans << endl;\n  \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve(){\n    int ans = 0;\n\n    bool V[MAX];\n    for(int i = 0; i < n; i++){\n        B[i] = A[i];\n        V[i] = false;\n    }\n\n    sort(B, B + n);\n    for(int i = 0; i < n; i++) T[B[i]] = i;\n    for(int i = 0; i < n; i++){\n        if(V[i]) continue;\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while(1){\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m, v);\n            S += v;\n            cur = T[v];\n            if(V[cur]) break;\n        }\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n    }\n\n    return ans;\n}\n\nint main(){\n    cin >> n;\n    s = VMAX;\n    for(int i = 0; i < n; i++){\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n    int ans = solve();\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n void bubble_sort(int a[], int n)\n { \n    int res = 0; \n    for(int i = 0; i<n; i++){ \n        for(int j=n-1; j>=i+1;j--){ \n            if(a[j] < a[j-1]) { \n                int temp = a[j]; \n                a[j] = a[j-1]; \n                a[j-1] = temp; \n                res++; \n                \n            } \n            \n        } \n        \n    }\n }\n int find(int a[], int b[], int i, int n){\n     for(int k = 0; k < n; k++){\n         if(a[i] == b[k]) return k;\n     }\n     \n }\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    int a[n+1];\n    int b[n];\n    int v[n+1];\n    for(int i = 0; i<n; i++){\n        scanf(\"%d\",&a[i]);\n        b[i] = a[i];\n        v[i] = 0;\n    }\n    bubble_sort(b,n);\n    int total_cost = 0;\n    for(int i = 0; i<n; i++){\n        int cost = 0;\n        int length = 0;\n        int min_cycle = 10005;\n        if(v[i] == 1) continue;\n        int temp = i;\n        while(a[temp]!=b[i]){\n            v[temp] = 1;\n            length++;\n            cost+=a[temp];\n            if(min_cycle>a[temp]) min_cycle = a[temp];\n            temp = find(a,b,temp,n);\n            \n        }\n        v[temp] = 1;\n        length++;\n        cost+=a[temp];\n        if(min_cycle>a[temp]) min_cycle = a[temp];\n        cost = cost+(length-2)*min_cycle;\n        total_cost += cost;\n        \n    }\n    printf(\"%d\\n\",total_cost);\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(), (x).end()\n\nusing namespace std;\n\ntemplate <typename T> T &chmin(T &a, const T &b) {return a = min(a, b);}\ntemplate <typename T> T &chmax(T &a, const T &b) {return a = max(a, b);}\n\nusing ll = long long;\nusing ld = long double;\n\nconst int INF = 1e9;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nstruct UnionFind{\n  vector<int> parent;\n  UnionFind(int N) : parent(N, -1) {};\n  int root(int n) { return parent[n] < 0 ? n : parent[n] = root(parent[n]); }\n  bool merge(int x, int y){\n    x=root(x); y=root(y);\n    if(x==y) return false;\n    if(parent[x]>parent[y]) swap(x, y);\n    if(parent[x]==parent[y]) parent[x]--;\n    parent[y] = x;\n    return true;\n  }\n  bool judge(int a, int b){\n    return root(a) == root(b);\n  }\n};\n\nint binarySearch(int* target, int num, int l, int r){\n  if(l==r) return l;\n  int pivot=(l+r)/2;\n  if (*(target+pivot)==num) return pivot;\n  return *(target+pivot) > num ? binarySearch(target, num, l, pivot) : binarySearch(target, num, pivot+1, r);\n}\n\nint main(){\n  int n;\n  cin >> n;\n  int a[n], org[n];\n  int res = 0;\n  UnionFind grp = UnionFind(n);\n  REP(i, n) { cin >> a[i]; org[i] = a[i]; }\n  sort(a, a+n);\n  REP(i, n){\n    int place = binarySearch(a, org[i], 0, n-1);\n    grp.merge(i, place);\n  }\n  REP(i, n){\n    if(grp.parent[i]==-1) continue;\n    if(grp.parent[i]<0) {\n      vector<int> target;\n      REP(j, n) if(grp.judge(i,j)) target.push_back(a[j]);\n      sort(target.begin(), target.end());\n      res += accumulate(target.begin(), target.end(), target[0] * (target.size()-2));\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// class point\tの練習（クラスの高度な実装）\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n\ntypedef long long llong;\nusing namespace std;\n\n\nint main() {\n\tint n;\n\tint w[1000];\n\tint sorted_w[1000];\n\tbool has_arrived[1000] = { false };\n\tint pos_save[10010];\n\tllong sumcost = 0;\n\tint min_cycle;\n\tint min_all;\n\tint origin_pos;\n\tint move_pos;\n\tint num_cycle;\n\tint sum_cycle;\n\tint plan_inside, plan_outside;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> w[i];\n\t\tsorted_w[i] = w[i];\n\t\tpos_save[w[i]] = i;\n\t}\n\tsort(sorted_w, sorted_w + n);\n\tmin_all = sorted_w[0];\n\n\n\tfor (int i = 0; i < n; i++) {\n\t\tmin_cycle = w[i];\n\t\tsum_cycle = w[i];\n\t\torigin_pos = i;\n\t\tmove_pos = pos_save[sorted_w[i]];\n\t\tnum_cycle = 0;\n\t\twhile (move_pos != origin_pos&&!has_arrived[i]) {\n\t\t\tnum_cycle++;\n\t\t\tmin_cycle = min(min_cycle, w[move_pos]);\n\t\t\tsum_cycle += w[move_pos];\n\n\t\t\thas_arrived[move_pos] = true;\n\t\t\tmove_pos = pos_save[sorted_w[move_pos]];\n\t\t\t\n\t\t}\n\t\tif (num_cycle) {\n\n\t\t\tplan_inside = num_cycle * min_cycle + sum_cycle - min_cycle;\n\t\t\tplan_outside = 2 * min_all + 2 * min_cycle + min_all * num_cycle + sum_cycle - min_cycle;\n\t\t\tsumcost += min(plan_inside, plan_outside);\n\t\t}\n\t\thas_arrived[i] = true;\n\t}\n\tcout << sumcost << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define VMAX 10000\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<int> w( n );\n\tvector<int> b( n );\n\tint s = VMAX;\n\tfor( int i = 0; i < n; i++ ) {\n\t\tcin >> w[i];\n\t\ts = min( s, w[i] );\n\t\tb[i] = w[i];\n\t}\n\n\tvector<bool> V( n );\n\tvector<int> T( VMAX + 1 );\n\tsort( b.begin(), b.end() );\n\tfor( int i = 0; i < n; i++ ) {\n\t\tT[ b[i] ] = i;\n\t}\n\tint ans = 0;\n\tfor( int i = 0; i < n; i++ ) {\n\t\tif( V[i] ) continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile( 1 ) {\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = w[cur];\n\t\t\tm = min( m, v );\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif( V[cur] ) break;\n\t\t}\n\t\tans += min( S + (an - 2)*m, m + S + (an + 1)*s );\n\t}\n\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nstatic const int MAX  = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint MinimumCostSort(int A[], int B[], int n) {\n  int ans = 0;\n\n  bool V[MAX];\n  for ( int i = 0; i< n; i++ ) {\n    V[i] = false;\n  }\n\n  for ( int i = 0; i < n; i++ ) T[B[i]] = i;\n  for ( int i = 0; i < n; i++ ) {\n    if ( V[i] ) continue;\n    int cur = i;\n    int S = 0;\n    int m = VMAX;\n    int an = 0;\n    while ( 1 ) {\n      V[cur] = true;\n      an++;\n      int v = A[cur];\n      m = min(m, v);\n      S+= v;\n      cur = T[v];\n      if ( V[cur] ) break;\n    }\n    ans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n  }\n\n  return ans;\n}\n\nint main() {\n  cin >> n;\n  s = VMAX;\n  for ( int i = 0; i < n; i++ ) {\n    scanf(\"%d\", &A[i]);\n    s = min(s, A[i]);\n    B[i] = A[i];\n  }\n  sort(B, B + n);\n\n  int ans = MinimumCostSort(A, B, n);\n\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define MAX_N 10000\n#define MAX_V 65000000\n#define INF 10000000000\n\nint n, A[MAX_N], s, B[MAX_N], T[MAX_V], cur, S, m, x; bool V[MAX_N];\n\nint minimum_cost_sort() {\n\tint ans = 0;\n\tfor (int i = 0; i < MAX_V; i++) { V[i] = false; }\n\tfor (int i = 0; i < n; i++) { B[i] = A[i]; }\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; i++) { T[B[i]] = i; }\n\tfor (int i = 0; i < n; i++) {\n\t\tif (V[i] == true) { goto owata; }\n\t\tcur = i;\n\t\tS = 0;\n\t\tm = INF;\n\t\tx = 0;\n\t\twhile (1) {\n\t\t\tV[cur] = true;\n\t\t\tx++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif (V[cur]) { break; }\n\t\t}\n\t\tans += min(S + (x - 2)*m, m + S + (x + 1)*s);\n\towata:;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tcin >> n;\n\ts = INF;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tcout << minimum_cost_sort() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n;\nvoid merge(int A[],int left, int mid, int right) {\n  int n1 = mid - left;\n  int n2 = right - mid;\n  int L[n1+1]; int R[n2+1];\n  for(int i=0;i<n1;i++) {\n    L[i] = A[left+i];\n  }\n  for(int i=0;i<n2;i++) {\n    R[i] = A[mid+i];\n  }\n  L[n1] = R[n2] = 0x7FFFFFFF;\n  int i = 0; int j = 0;\n  for(int k=left;k<right;k++) {\n    if(L[i] <= R[j]) {\n      A[k] = L[i];\n      i++;\n    }\n    else {\n      A[k] = R[j];\n      j++;\n    }\n  }\n}\nvoid merge_sort(int A[],int left, int right) {\n  if(right - left > 1) {\n    int mid = (left + right) / 2;\n    merge_sort(A,left, mid);\n    merge_sort(A,mid, right);\n    merge(A,left, mid, right);\n  }\n}\n\nint search(int W[],int left,int right, int key) {\n  for(int i=0;i<n;i++) {\n    if(W[i] == key)\n      return i;\n  }\n  return -1;\n}\nint binary_search(int Sorted[],int left,int right, int key) {\n  while(right >= left) {\n    int mid = (left+right)/2;\n    if(Sorted[mid] == key)\n      return mid;\n    else if(Sorted[mid] < key)\n      left = mid + 1;\n    else\n      right = mid - 1;\n  }\n  return -1;\n}\n\n\nint main() {\n  cin >> n;\n  int W[n]; int Sorted[n];\n  for(int i=0;i<n;i++) {\n    int num; cin >> num;\n    W[i] = Sorted[i] = num;\n  }\n  merge_sort(Sorted,0,n);\n\n  // algorithm : https://www.ipsj.or.jp/07editj/promenade/4506.pdf\n  vector<int> R;\n  for(int i=0;i<n;i++) {\n    if(binary_search(Sorted,i,n,W[i]) != i)\n      R.push_back(Sorted[i]);\n  }\n  int Smin = Sorted[0];\n  int Rmin = R[0];\n  int sum = 0;\n  for(int i=0;i<R.size();i++) {\n    sum += R[i];\n  }\n  int cost;\n  if(R.size() > 1)\n    cost = min(sum+Rmin*(R.size()-2),sum+Rmin+Smin*(R.size()+1));\n  else\n    cost = 0;\n\n  cout << cost << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "const int MAXN = 1010;\nint w[MAXN];\nbool done[MAXN];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, mini = 100000;\n    cin >> n;\n    map<int, int> mp;\n    for (int i = 0; i < n; i++) {\n        cin >> w[i];\n        mp[w[i]] = 0;\n        mini = min(mini, w[i]);\n    }\n    {\n        int k = 0;\n        for (auto& p : mp) p.second = k++;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (done[i]) continue;\n        int cnt = 0, now = i, mi = 100000, sum = 0;\n        while (1) {\n            if (done[now]) break;\n            cnt++;\n            done[now] = true;\n            mi = min(mi, w[now]);\n            sum += w[now];\n            now = mp[w[now]];\n        }\n        int tmp = sum+(cnt-2)*mi;\n        tmp = min(tmp, sum+mi+mini*(cnt+1));\n        ans += tmp;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int Max = 1005;\nconst int M = 10005;\nint w[Max], s;\nint b[Max];\nint t[M];\nint visit[Max];\n\nint solve(int w[], int b[], int n)\n{\n    memset(visit, 0, sizeof(visit));\n    for(int i=0; i<n; i++)\n        t[b[i]] = i;\n    int result = 0;\n    for(int i=0; i<n; i++)\n    {\n        if(visit[i]) continue;\n        int cur = i, sum = 0, num = 0, m = M;\n        while(!visit[cur])\n        {\n            visit[cur] = 1;\n            m = min(m, w[cur]);\n            sum += w[cur];\n            num++;\n            cur = t[w[cur]];\n        }\n        if(num)\n        {\n            result += min(sum+(num-2)*m, sum+m+(num+1)*s);\n        }\n    }\n    return result;\n}\nint main()\n{\n    int n;\n    s = M;\n    cin >> n;\n    for(int i=0; i<n; i++)\n    {\n        cin >> w[i];\n        b[i] = w[i];\n        s = min(s, w[i]);\n    }\n    sort(b, b+n);\n    cout << solve(w, b, n) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <climits>\nusing namespace  std;\n\nstruct StCst\n{\n  int m_nNo;\n  int m_nSeq;\n  bool m_bDone;\n\n  static bool AsdNo(const StCst &cnroLeft, const StCst &cnroRight) \n  { return cnroLeft.m_nNo < cnroRight.m_nNo; }\n};\n\nvoid fnInput(int &rnMaxSiz, vector<StCst> &rvoSort)\n{\n  int nCnt = 0;\n  cin >> rnMaxSiz;\n\n  rvoSort.resize(rnMaxSiz);\n  for (int i = 0; i < rnMaxSiz; i++)\n  {\n    cin >> rvoSort[i].m_nNo;\n    rvoSort[i].m_nSeq = nCnt++;\n  }\n}\n\nvoid fnMinCostSort(vector<StCst> &rvoSort, int &rnSwpCnt)\n{\n  sort(begin(rvoSort), end(rvoSort), StCst::AsdNo);\n  int nMinNo = rvoSort[0].m_nNo;\n\n  int nCost;\n  for (int i = 0; i < rvoSort.size(); i++)\n  {\n    if (rvoSort[i].m_bDone)  continue;\n\n    int nTotal = rvoSort[i].m_nNo;\n    int nCurSize = 1;\n    int nCurMin = rvoSort[i].m_nNo; \n    rvoSort[i].m_bDone = true;\n\n    int j = rvoSort[i].m_nSeq;\n    while  (rvoSort[j].m_nNo != rvoSort[i].m_nNo)\n    {\n      nTotal += rvoSort[j].m_nNo;\n      nCurSize++;\n      nCurMin = min(nCurMin, rvoSort[j].m_nNo);\n      rvoSort[j].m_bDone = true;\n      j = rvoSort[j].m_nSeq;\n    }\n\n    if (nCurSize == 1)\n        nCost = 0;\n    else\n      if (nMinNo == nCurMin)\n        nCost = nTotal + (nCurSize - 2) * nCurMin;\n      else\n        nCost = min(nTotal + (nCurSize - 2) * nCurMin, \n                    nTotal + nCurMin + (nCurSize + 1) * nMinNo);\n    rnSwpCnt += nCost;\n  }\n}\n\nvoid fnResult(int nSwpCnt)\n{\n  cout << nSwpCnt << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int nMaxSiz;\n  vector<StCst> voSort;\n\n  fnInput(nMaxSiz, voSort);\n\n  int nSwpCnt = 0;\n  fnMinCostSort(voSort, nSwpCnt);\n\n  fnResult(nSwpCnt);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstatic const int MAX=1000;\nstatic const int VMAX=10000;\n\nint n, A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve() {\n  int ans=0;\n  bool V[MAX];\n  for (int i=0; i<n; i++) {\n    B[i]=A[i];\n    V[i]=false;\n  }\n  sort(B,B+n);\n  for (int i=0; i<n; i++) {\n    T[B[i]]=i;\n  }\n  for (int i=0; i<n; i++) {\n    if (V[i]) {\n      continue;\n    }\n    int cur=i;\n    int S=0;\n    int m=VMAX;\n    int an=0;\n    while (true) {\n      V[cur]=true;\n      an++;\n      int v=A[cur];\n      m=min(m,v);\n      S+=v;\n      cur=T[v];\n      if (V[cur]) {\n        break;\n      }\n    }\n    ans+=min(S+(an-2)*m,m+S+(an+1)*s);\n  }\n  return ans;\n}\nint main() {\n  cin>>n;\n  s=VMAX;\n  for (int i=0; i<n; i++) {\n    cin>>A[i];\n    s=min(s,A[i]);\n  }\n  int ans;\n  ans = solve();\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <unordered_map>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nnamespace std{\n\ttemplate<typename T>\n\tinline void hash_combine(size_t& seed, T const& v){\n\t\tseed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n\t}\n    template<typename It>\n    inline size_t hash_range(It first, It last){\n\t\tsize_t seed=0;\n\t\thash_range(seed,first,last);\n\t\treturn seed;\n\t}\n\ttemplate<typename It>\n\tinline void hash_range(size_t& seed, It first, It last){\n\t\tfor(;first!=last;++first)hash_combine(seed, *first);\n\t}\n\ttemplate<typename A,typename B>\n\tclass hash<pair<A,B>>{\n\t\tpublic:\n\t\tsize_t operator()(pair<A,B> const &p) const{\n\t\t\tsize_t seed=0;\n\t\t\thash_combine(seed,p.first);\n\t\t\thash_combine(seed,p.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\ttemplate<typename T,size_t N>\n\tclass hash<array<T,N>>{\n\t\tpublic:\n\t\tsize_t operator()(array<T,N> const &container) const{\n\t\t\treturn hash_range(container.begin(),container.end());\n\t\t}\n\t};\n\ttemplate<typename T,typename A>\n\tclass hash<vector<T,A>>{\n\t\tpublic:\n\t\tsize_t operator()(vector<T,A> const &container) const{\n\t\t\treturn hash_range(container.begin(),container.end());\n\t\t}\n\t};\n}\n\nint main(){\n\tint N;\n\tscanf(\"%d\",&N);\n\tvector<char>v(N);\n\tfor(int i=0;i<N;i++)scanf(\"%d\",&v[i]);\n\tpriority_queue<pair<int,vector<char> > >q;\n\tunordered_map<vector<char>,int>depth;\n\n\tq.push(make_pair(0,v));\n\tint R;\n\tfor(;!q.empty();){\n\t\tauto cur=q.top();\n\t\tq.pop();\n\t\tif(depth.find(cur.second)!=depth.end())continue;\n\t\tdepth[cur.second]=cur.first;\n\t\tbool f=false;\n\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++)if(i!=j&&cur.second[i]>cur.second[j]){\n\t\t\tif(i<j)f=true;\n\t\t\tswap(cur.second[i],cur.second[j]);\n\t\t\tq.push(make_pair(cur.first-cur.second[i]-cur.second[j],cur.second));\n\t\t\tswap(cur.second[i],cur.second[j]);\n\t\t}\n\t\tif(!f){\n\t\t\tR=-cur.first;\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",R);\n}"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\nint n;\nint w[1000];\nint k[1000];\nint u[1000];\n\nint main(){\n\tscanf(\"%d\", &n);\n\trep(i, n){\n\t\tscanf(\"%d\", &w[i]);\n\t}\n\n\tvector<int> v(w, w + n);\n\tsort(v.begin(), v.end());\n\trep(i, n){\n\t\tk[i] = lower_bound(v.begin(), v.end(), w[i]) - v.begin();\n\t}\n\n\tint x = *min_element(w, w + n);\n\tint ans = 0;\n\trep(i, n){\n\t\tif(u[i]){\n\t\t\tcontinue;\n\t\t}\n\t\tint c = 1;\n\t\tint s = w[i];\n\t\tint m = w[i];\n\t\tu[i] = true;\n\t\tint j = k[i];\n\t\twhile(!u[j]){\n\t\t\t++c;\n\t\t\ts += w[j];\n\t\t\tm = min(m, w[j]);\n\t\t\tu[j] = true;\n\t\t\tj = k[j];\n\t\t}\n\t\tans += min(s + m * (c - 2), (s - m + x) + x * (c - 2) + 2 * (m + x));\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nint Min(int a, int b){\n    return a>b?b:a;\n}\n void bubble_sort(int a[], int n)\n { \n    int res = 0; \n    for(int i = 0; i<n; i++){ \n        for(int j=n-1; j>=i+1;j--){ \n            if(a[j] < a[j-1]) { \n                int temp = a[j]; \n                a[j] = a[j-1]; \n                a[j-1] = temp; \n                res++; \n                \n            } \n            \n        } \n        \n    }\n }\n int find(int a[], int b[], int i, int n){\n     for(int k = 0; k < n; k++){\n         if(a[i] == b[k]) return k;\n     }\n     \n }\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    int a[n+1];\n    int b[n];\n    int v[n+1];\n    for(int i = 0; i<n; i++){\n        scanf(\"%d\",&a[i]);\n        b[i] = a[i];\n        v[i] = 0;\n    }\n    bubble_sort(b,n);\n    int total_cost = 0;\n    int min = 10005;\n    for(int i = 0; i<n; i++){\n        if(min>a[i]) min = a[i];\n        int cost = 0;\n        int length = 0;\n        int min_cycle = 10005;\n        if(v[i] == 1) continue;\n        int temp = i;\n        if(a[i] == b[i]) continue;\n        while(a[temp]!=b[i]){\n            v[temp] = 1;\n            length++;\n            cost+=a[temp];\n            if(min_cycle>a[temp]) min_cycle = a[temp];\n            temp = find(a,b,temp,n);\n            \n        }\n        v[temp] = 1;\n        length++;\n        cost+=a[temp];\n        if(min_cycle>a[temp]) min_cycle = a[temp];\n        //printf(\"min:%d\\n\",min);\n        //printf(\"min_cycle:%d\\n\",min_cycle);\n        if(length>2)\n        {cost = cost+Min((length-2)*min_cycle, min_cycle+min*(length+1));}\n        total_cost += cost;\n        \n    }\n    printf(\"%d\\n\",total_cost);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int INF = 1000000;\n\nstruct node\n{\n\tint num;\n\tint place;  \n};\n\nint partition(node *A,int p,int r)\n{\n\tint j,temp;\n\tnode x;\n\n\tx = A[r];\n\tj = p-1;\n\n\tfor(int i = p; i < r; i++)\n\t{\n\t\tif (A[i].num <= x.num)\n\t\t{\n\t\t\tj++;\n\t\t\ttemp = A[i].num;\n\t\t\tA[i].num = A[j].num;\n\t\t\tA[j].num = temp;\n\t\t}\n\t}\n\n\ttemp = A[j+1].num;\n\tA[j+1].num = A[r].num;\n\tA[r].num = temp;\n\n\treturn j+1;\n}\n\nvoid quicksort(node *A,int p,int r)\n{\n\tint q;\n\n\tif (p < r)\n\t{\n\t\tq = partition(A,p,r);\n\t\tquicksort(A,p,q-1);\n\t\tquicksort(A,q+1,r);\n\t}\n}\n\n\nint main()\n{\n\tint n,sum,minall,mini,sol,cnt,j;\n\tnode a[1000] = {0},b[1000] = {0};\n\n\tsol = 0;\n\tminall = INF;\n\n\tscanf(\"%d\", &n);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i].num);\n\t\ta[i].place = i;\n\t\tb[i] = a[i];\n\t\tb[i].place = i;\n\n\t\tif (minall > a[i].num)\n\t\t{\n\t\t\tminall = a[i].num;\n\t\t}\n\t}\n\n\t//cout << \"minall = \" << minall << endl;\n\n\tquicksort(b,0,n-1);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcout << b[i].num << \" \";\n\t}\n\n\tcout << endl <<endl;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tsum = 0;\n\n\t\tif (a[i].num >= 0)\n\t\t{\n\t\t\tsum += a[i].num;\n\t\t\tmini = a[i].num;\n\t\t\tcnt = 1;\n\t\t\tj = i;\n\n\t\t\twhile(b[a[j].place].num != a[i].num)\n\t\t\t{\n\t\t\t\tfor(int k = 0; k < n; k++)\n\t\t\t\t{\n\t\t\t\t\tif (a[k].num == b[a[j].place].num)\n\t\t\t\t\t{\n\t\t\t\t\t\tj = k;\n\t\t\t\t\t\tsum += a[k].num;\n\t\t\t\t\t\t//cout << \" sum =\" <<sum << endl;\n\t\t\t\t\t\tcnt++;\n\n\t\t\t\t\t\tif (mini > a[k].num)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmini = a[k].num;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ta[k].num = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\ta[i].num = -1;\n\n\t\t\tsol += min(sum + mini * (cnt -2), sum + mini + (cnt + 1) * minall);\n\n\t\t\t//cout << \"sum1=\" << sum + mini * (cnt -2)  << \"  sum2=\" << sum + mini + (cnt + 1) * minall << endl;\n\n\t\t\t/*for(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tcout << a[i].num << \" \";\n\t\t\t}\n\t\t\tcout << \"sol=\" << sol << \" \" << \"cnt=\" <<cnt << \" mini=\" << mini;\n\t\t\tcout << endl <<endl;*/\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", sol);\n\n\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <queue>\n#include <string>\n#include <set>\n#include <vector>\n\n#define FOR(i, l, r) for (i = (l); i < r; i++ )\n\nusing namespace std;\ntypedef long long ll;\n#define MAX_N (1010)\n#define MAX_V (10010)\n\nint n;\nint A[MAX_N];\nint g_min = MAX_V;\t\t// global min\nint B[MAX_N];\t\t\t// sorted array\nint T[MAX_V];\t\t\t// index of sorted array\nbool V[MAX_N];\t\t\t// check whether it is already used.\n\nint solve() {\n\n    for ( int i = 0; i < n; i++ ) {\n\tV[i] = false;\n\tB[i] = A[i];\n    }\n\n    sort(B, B + n);\n\n    for ( int i = 0; i < n; i++ ) {\n\tT[B[i]] = i;\n    }\n\n    int ret = 0;\n    for ( int i = 0; i < n; i++ ) {\n\tif ( V[i] ) continue;\n\t// has not visited yet.\n\tint cur = i;\n\tint num = 0;\n\tint l_min = MAX_V;\t// local min\n\tint sum_l = 0;\n\twhile ( 1 ) {\n\t    V[cur] = true;\n\t    num++;\n\t    l_min = min(l_min, A[cur]);\n\t    sum_l += A[cur];\n\t    cur = T[A[cur]];\n\t    if ( V[cur] ) break; // \n\t}\n\n\tint c0 = sum_l + (num - 2) * l_min;\n\tint c1 = sum_l + l_min + (num + 1) * g_min;\n\tret += min(c0, c1);\n    }\n    return ret;\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    \n    for ( int i = 0; i < n; i++ ) {\n\tscanf(\"%d\", &A[i]);\n\tg_min = min(g_min, A[i]);\n    }\n\n    int ans = solve();\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define MAX 1000\nint n,x,a[MAX],b[MAX],t[10001];\n\nint solve(){\n\tint ans=0;\n\tbool v[MAX];\n\tfor(int i=0;i<n;i++){\n\t\tb[i]=a[i];\tv[i]=false;\n\t}\n\tsort(b,b+n);\n\tfor(int i=0;i<n;i++)\tt[b[i]]=i;//ソート後の位置を記録\n\tfor(int i=0;i<n;i++){\n\t\tif(v[i])\tcontinue;\n\t\tint current=i;\n\t\tint s=0;\n\t\tint m=10000;\n\t\tint count=0;\n\t\twhile(1){\n\t\t\tv[current]=true;\n\t\t\tcount++;\n\t\t\tm=min(m,a[current]);\n\t\t\ts+=a[current];\n\t\t\tcurrent=t[a[current]];\n\t\t\tif(v[current])\tbreak;\n\t\t}\n\t\tans+=min(s+(count-2)*m,s+m+(count+1)*x);\n\t}\n\treturn ans;\n}\n\t\t\n\nint main(){\n\tcin>>n;\n\tx=10000;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t\tx=min(x,a[i]);\n\t}\n\tcout<<solve()<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstatic const int MAX=1000;\nstatic const int VMAX=10000;\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve()\n{\n    int ans=0;\n\n    bool V[MAX];\n    for(int i=0;i<n;++i)\n    {\n        B[i]=A[i];\n        V[i]=false;\n    }\n    sort(B,B+n);\n    for(int i=0;i<n;i++)\n    {\n        T[B[i]]=i;\n    }\n    for(int i=0;i<n;i++)\n    {\n        if(V[i])continue;\n        int cur=i;\n        int S=0;\n        int m=VMAX;\n        int an=0;\n        while(1)\n        {\n            V[cur]=true;\n            an++;\n            int v=A[cur];\n            m=min(m,v);\n            S+=v;\n            cur=T[v];\n            if(V[cur])break;\n        }\n        ans+=min(S+(an-2)*m,m+S+(n+1)*s);\n    }\n    return ans;\n}\n\nint main()\n{\n\tcin>>n;\n\ts=VMAX;\n\tfor(int i=0;i<n;i++)\n    {\n        cin>>A[i];\n        s=min(s,A[i]);\n    }\n    int ans=solve();\n    cout<<ans<<endl;\n \treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define PB push_back\n\nvoid Mergesort(vector<int>&);\n\nint main(int argc,char* argv[]){\n  std::ios_base::sync_with_stdio(false);\n  \n  vector<int> vi;\n  int n,x,ans=0;\n\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>x;\n    vi.PB(x);\n  }\n\n  vector<int> merges(vi.begin(),vi.end());\n\n  Mergesort(merges);\n  for(int i=0;i<n;i++){\n    if(merges[i]!=vi[i])\n      ans+=vi[i];\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n\nvoid Mergesort(vector<int>& merges){\n  int vecsize=merges.size();\n\n  if(vecsize>1){\n    vector<int> lft(merges.begin(),merges.begin()+vecsize/2);\n    vector<int> rht(merges.begin()+vecsize/2,merges.end());\n\n    Mergesort(lft);\n    Mergesort(rht);\n\n    for(int i=0,l=0,r=0;i<vecsize;i++){\n      if(l==(int)lft.size())\n\tmerges[i]=rht[r++];\n      else if(r==(int)rht.size())\n\tmerges[i]=lft[l++];\n      else if(lft[l]<=rht[r])\n\tmerges[i]=lft[l++];\n      else\n\tmerges[i]=rht[r++];\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int INF = 1000000;\n\nint partition(int *A,int p,int r)\n{\n\tint j,x,temp;\n\n\tx = A[r];\n\tj = p-1;\n\n\tfor(int i = p; i < r; i++)\n\t{\n\t\tif (A[i] <= x)\n\t\t{\n\t\t\tj++;\n\t\t\ttemp = A[i];\n\t\t\tA[i] = A[j];\n\t\t\tA[j] = temp;\n\t\t}\n\t}\n\n\ttemp = A[j+1];\n\tA[j+1] = A[r];\n\tA[r] = temp;\n\n\treturn j+1;\n}\n\nvoid quicksort(int *A,int p,int r)\n{\n\tint q;\n\n\tif (p < r)\n\t{\n\t\tq = partition(A,p,r);\n\t\tquicksort(A,p,q-1);\n\t\tquicksort(A,q+1,r);\n\t}\n}\n\nint solve_swap(int *a,int *b,int n)\n{\n\tint sum,temp;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (a[i] != b[i])\n\t\t{\n\t\t\tfor(int j = i+1; j < n; j++)\n\t\t\t{\n\t\t\t\tif (b[j] == a[i] && b[i] == a[j])\n\t\t\t\t{\n\t\t\t\t\ttemp = a[i];\n\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\ta[j] = temp;\n\n\t\t\t\t\tsum += a[i] + a[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n\nint solve1(int *a,int *b,int n)\n{\n\tbool check;\n\tint min,num,temp,sum,start;\n\n\tsum = 0;\n\tstart = 0;\n\n\twhile(1)\n\t{\n\t\tmin = INF;\n\t\t\n\t\tcheck = true;\n\n\t\t//printf(\"start = %d\\n\", start);\n\n\t\tfor(int i = start; i < n; i++)\n\t\t{\n\t\t\tif (min > a[i] && a[i] != b[i])\n\t\t\t{\n\t\t\t\tnum = i;\n\t\t\t\tmin = a[num];\n\t\t\t}\n\t\t}\n\n\t\t//printf(\"num = %d\\n\", num);\n\t\t//printf(\"min = %d\\n\", min);\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (a[i] == b[num])\n\t\t\t{\n\t\t\t\t//printf(\"%d and %d are swapped\\n\", a[num],a[i]);\n\t\t\t\tsum += a[num] + a[i];\n\t\t\t\ttemp = a[i];\n\t\t\t\ta[i] = min; // min = a[num]\n\t\t\t\ta[num] = temp;\n\t\t\t\tnum = i;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (a[i] != b[i])\n\t\t\t{\n\t\t\t\tcheck = false;\n\t\t\t\tstart = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\t//printf(\"a[i] = %d\\n\", a[i]);\n\t\t}\n\n\t\tif (check)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn sum;\n}\n\nbool check(int *A,int *B,int n)\n{\n\tbool c = true;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (A[i] != B[i])\n\t\t{\n\t\t\tc = false;\n\t\t}\n\t}\n\n\treturn c;\n}\n\nint main()\n{\n\tint n,a[1000] = {0},b[1000] = {0},a2[1000] = {0};\n\tint sum1 = 0,sum2 = 0,pivot = 0,pivot1 = 0,pivot2= 0,min = 0,start=0,temp=0,k=0;\n\n\tscanf(\"%d\", &n);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\tb[i] = a[i];\n\t}\n\n\tquicksort(b,0,n-1);\n\n\tsum1 = solve_swap(a,b,n);\n\n\t//printf(\"sum = %d\\n\", sum1);\n\n\tif (check(a,b,n))\n\t{\n\t\tprintf(\"%d\\n\", sum1);\n\t\treturn 0;\n\t}\n\n/*\n\tsum2 = sum1;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\ta2[i] = a[i];\n\t}\n\n\t//printf(\"\\nhere is sum1\\n\");\n\n\tsum1 += solve1(a,b,n);\n\n\t//printf(\"sum1 = %d\\n\",sum1);\n\n\n\tif (check(a,b,n))\n\t{\n\t\tprintf(\"%d\\n\", sum1);\n\t\treturn 0;\n\t}\n\n\n\n\tfor(int i = 1; i < n - start; i++)\n\t{\n\t\tk = start;\n\n\t\t\n\t\twhile(1)\n\t\t{\n\t\t\tif (b[pivot1] == a[k])\n\t\t\t{\n\t\t\t\tprintf(\"%d and %d are swapped\\n\", a[pivot1],a[k]);\n\t\t\t\ttemp = a[pivot1];\n\t\t\t\ta[pivot1] = a[k];\n\t\t\t\ta[k] = temp;\n\n\t\t\t\tsum1 += a[pivot1] + a[k];\n\t\t\t\tpivot1 = k;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tprintf(\"%d \", a[i]);\n\t\t}\n\t\tcout << endl;\n\t}\n\n\n\tif (!check(a,b,n))\n\t{\n\t\tprintf(\"\\nhere is sum2\\n\");\n\t\ttemp = a2[pivot2];\n\t\ta2[pivot2] = a2[0];\n\t\ta2[0] = temp;\n\n\t\tfor(int i = 1; i < n - start; i++)\n\t\t{\n\t\t\tint j = start;\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif (b[pivot2] == a2[j])\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d and %d are swapped\\n\", a2[pivot2],a2[j]);\n\t\t\t\t\ttemp = a2[pivot2];\n\t\t\t\t\ta2[pivot2] = a2[j];\n\t\t\t\t\ta2[j] = temp;\n\n\t\t\t\t\tsum2 += a2[pivot2] + a2[j];\n\t\t\t\t\tpivot2 = j;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tprintf(\"%d \", a2[i]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\n\t\tif (sum1 < sum2)\n\t\t{\n\t\t\tprintf(\"sum1 = %d\\n\", sum1);\n\t\t}else\n\t\t{\n\t\t\tprintf(\"sum2 = %d\\n\", sum2);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\n\tprintf(\"%d\\n\", sum1);\n*/\n\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int INF = 1000000;\n\nint partition(int *A,int p,int r)\n{\n\tint j,x,temp;\n\n\tx = A[r];\n\tj = p-1;\n\n\tfor(int i = p; i < r; i++)\n\t{\n\t\tif (A[i] <= x)\n\t\t{\n\t\t\tj++;\n\t\t\ttemp = A[i];\n\t\t\tA[i] = A[j];\n\t\t\tA[j] = temp;\n\t\t}\n\t}\n\n\ttemp = A[j+1];\n\tA[j+1] = A[r];\n\tA[r] = temp;\n\n\treturn j+1;\n}\n\nvoid quicksort(int *A,int p,int r)\n{\n\tint q;\n\n\tif (p < r)\n\t{\n\t\tq = partition(A,p,r);\n\t\tquicksort(A,p,q-1);\n\t\tquicksort(A,q+1,r);\n\t}\n}\n\nint solve_swap(int *a,int *b,int n)\n{\n\tint sum,temp;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (a[i] != b[i])\n\t\t{\n\t\t\tfor(int j = i+1; j < n; j++)\n\t\t\t{\n\t\t\t\tif (b[j] == a[i] && b[i] == a[j])\n\t\t\t\t{\n\t\t\t\t\ttemp = a[i];\n\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\ta[j] = temp;\n\n\t\t\t\t\tsum += a[i] + a[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n\nint solve1(int *a,int *b,int n)\n{\n\tbool check;\n\tint min,num,temp,sum,start;\n\tint cnt=0;\n\n\tsum = 0;\n\tstart = 0;\n\n\twhile(1)\n\t{\n\t\tmin = INF;\n\t\tcnt++;\n\t\tcheck = true;\n\n\t\t//printf(\"start = %d\\n\", start);\n\n\t\tfor(int i = start; i < n; i++)\n\t\t{\n\t\t\tif (min > a[i] && a[i] != b[i])\n\t\t\t{\n\t\t\t\tnum = i;\n\t\t\t\tmin = a[num];\n\t\t\t}\n\t\t}\n\n\t\t//printf(\"num = %d\\n\", num);\n\t\t//printf(\"min = %d\\n\", min);\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (a[i] == b[num])\n\t\t\t{\n\t\t\t\t//printf(\"%d and %d are swapped\\n\", a[num],a[i]);\n\t\t\t\tsum += a[num] + a[i];\n\t\t\t\ttemp = a[i];\n\t\t\t\ta[i] = min; // min = a[num]\n\t\t\t\ta[num] = temp;\n\t\t\t\tnum = i;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (a[i] != b[i])\n\t\t\t{\n\t\t\t\tcheck = false;\n\t\t\t\tstart = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\t//printf(\"a[i] = %d\\n\", a[i]);\n\t\t}\n\n\t\tif (check)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cnt ==10)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn sum;\n}\n\nbool check(int *A,int *B,int n)\n{\n\tbool c = true;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (A[i] != B[i])\n\t\t{\n\t\t\tc = false;\n\t\t}\n\t}\n\n\treturn c;\n}\n\nint main()\n{\n\tint n,a[1000] = {0},b[1000] = {0},a2[1000] = {0};\n\tint sum1 = 0,sum2 = 0,pivot = 0,pivot1 = 0,pivot2= 0,min = 0,start,temp,k;\n\n\tscanf(\"%d\", &n);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\tb[i] = a[i];\n\t}\n\n\tquicksort(b,0,n-1);\n\n\tsum1 = solve_swap(a,b,n);\n\n\t//printf(\"sum = %d\\n\", sum1);\n\n\t\n\tif (check(a,b,n))\n\t{\n\t\tprintf(\"%d\\n\", sum1);\n\t\treturn 0;\n\t}\n\n\n\tsum2 = sum1;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\ta2[i] = a[i];\n\t}\n\n\t//printf(\"\\nhere is sum1\\n\");\n\n\tsum1 += solve1(a,b,n);\n\n\t//printf(\"sum1 = %d\\n\",sum1);\n\n\n\tif (check(a,b,n))\n\t{\n\t\tprintf(\"%d\\n\", sum1);\n\t\treturn 0;\n\t}\n\n\n\n\tfor(int i = 1; i < n - start; i++)\n\t{\n\t\tk = start;\n\n\t\t\n\t\twhile(1)\n\t\t{\n\t\t\tif (b[pivot1] == a[k])\n\t\t\t{\n\t\t\t\tprintf(\"%d and %d are swapped\\n\", a[pivot1],a[k]);\n\t\t\t\ttemp = a[pivot1];\n\t\t\t\ta[pivot1] = a[k];\n\t\t\t\ta[k] = temp;\n\n\t\t\t\tsum1 += a[pivot1] + a[k];\n\t\t\t\tpivot1 = k;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tprintf(\"%d \", a[i]);\n\t\t}\n\t\tcout << endl;\n\t}\n\n\n\tif (!check(a,b,n))\n\t{\n\t\tprintf(\"\\nhere is sum2\\n\");\n\t\ttemp = a2[pivot2];\n\t\ta2[pivot2] = a2[0];\n\t\ta2[0] = temp;\n\n\t\tfor(int i = 1; i < n - start; i++)\n\t\t{\n\t\t\tint j = start;\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif (b[pivot2] == a2[j])\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d and %d are swapped\\n\", a2[pivot2],a2[j]);\n\t\t\t\t\ttemp = a2[pivot2];\n\t\t\t\t\ta2[pivot2] = a2[j];\n\t\t\t\t\ta2[j] = temp;\n\n\t\t\t\t\tsum2 += a2[pivot2] + a2[j];\n\t\t\t\t\tpivot2 = j;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tprintf(\"%d \", a2[i]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\n\t\tif (sum1 < sum2)\n\t\t{\n\t\t\tprintf(\"sum1 = %d\\n\", sum1);\n\t\t}else\n\t\t{\n\t\t\tprintf(\"sum2 = %d\\n\", sum2);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\n\tprintf(\"%d\\n\", sum1);\n\t\n\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "const int MAXN = 1010;\nint w[MAXN];\nbool done[MAXN];\n\nint void main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, mini = 100000;\n    cin >> n;\n    map<int, int> mp;\n    for (int i = 0; i < n; i++) {\n        cin >> w[i];\n        mp[w[i]] = 0;\n        mini = min(mini, w[i]);\n    }\n    {\n        int k = 0;\n        for (auto& p : mp) p.second = k++;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (done[i]) continue;\n        int cnt = 0, now = i, mi = 100000, sum = 0;\n        while (1) {\n            if (done[now]) break;\n            cnt++;\n            done[now] = true;\n            mi = min(mi, w[now]);\n            sum += w[now];\n            now = mp[w[now]];\n        }\n        int tmp = sum+(cnt-2)*mi;\n        tmp = min(tmp, sum+mi+mini*(cnt+1));\n        ans += tmp;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<list>\nusing namespace std;\n\ntypedef struct{int a;int b;int c;} arr;\ntypedef pair<long long,long long> logg;\n\narr L[510],R[510];\n\nint merge(arr a[],int l,int m,int r,char c)\n{\n\tint n1=m-l;\n\tint n2=r-m;\n\tfor(int i=0;i<n1;i++)\n\t{\n\t\tL[i]=a[l+i];\n\t}\n\tfor(int i=0;i<n2;i++)\n\t{\n\t\tR[i]=a[m+i];\n\t}\n\tint i=0,j=0;\n\tif(c=='a')\n\t{\n\t\tL[n1].a=100000;R[n2].a=100000;\n\t\tfor(int k=l;k<r;k++)\n\t\t{\n\t\t\tif(L[i].a<=R[j].a)\n\t\t\t{\n\t\t\t\ta[k]=L[i++];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta[k]=R[j++];\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tL[n1].c=100000;R[n2].c=100000;\n\t\tfor(int k=l;k<r;k++)\n\t\t{\n\t\t\tif(L[i].c<=R[j].c)\n\t\t\t{\n\t\t\t\ta[k]=L[i++];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta[k]=R[j++];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint mergeS(arr a[],int l,int r,char c)\n{\n\tif(l+1<r)\n\t{\n\t\tint m=(l+r)/2;\n\t\tmergeS(a,l,m,c);\n\t\tmergeS(a,m,r,c);\n\t\tmerge(a,l,m,r,c);\n\t}\n}\n\n\nint main()\n{\n\tint n,j=1;cin>>n;\n\tarr a[1010];\n\tlogg c[1010];\n\tfor(int i=1;i<=n;cin>>a[i++].a);a[n+1].a==1;\n\t\n\t\n\tfor(int i=1;i<=n;a[i].c=i,i++);\n\tmergeS(a,1,n+1,'a');\n\tfor(int i=1;i<=n;a[i].b=i,i++);\n\tmergeS(a,1,n+1,'c');\n\t\n\t\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcout<<a[i].a<<a[i].b<<a[i].c<<endl;\n\t}\n\t\n\tfor(int i=1,m=0;;)\n\t{\n\t\tif(a[i].b!=0)//.b\n\t\t{\n\t\t\tc[j].first++;\n\t\t\tc[j].second+=a[i].a;\n\t\t\tif(a[i].a>m)m=a[i].a;\n\t\t\tint l=a[i].b;//.b\n\t\t\ta[i].b=0;//.b\n\t\t\ti=l;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(c[j].first==1)\n\t\t\t{\n\t\t\t\tc[j].second=0;\n\t\t\t}\n\t\t\telse if(c[j].first>=3)\n\t\t\t{\n\t\t\t\tc[j].second-=m;\n\t\t\t\tc[j].second*=2;\n\t\t\t}\n\t\t\tm=0;\n\t\t\tj++;\n\t\t\tint s=0;\n\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t{\n\t\t\t\ts+=a[k].b;//a\n\t\t\t\tif(a[k].b!=0)i=k;//a\n\t\t\t}\n\t\t\tif(s==0)break;\n\t\t}\n\t}\n\tlong long s=0;\n\tfor(int i=1;i<=j;i++)\n\t{\n\t\ts+=c[i].second;\n\t}\n\tcout<<s<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\nusing namespace std;\n#define MAX 1000\n#define VMAX 10000\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint solve(){\n    int ans = 0;\n\n    bool V[MAX];\n    for(int i=0; i<n; i++){\n        B[i] = A[i]; //複製\n        V[i] = false; //全部falseにする\n    }\n    sort(B, B+n); //第一引数が先頭イテレータ、第二引数が末尾イテレータ\n    for(int i=0; i<n; i++) T[B[i]] = i;\n    for(int i=0; i<n; i++){\n        if(V[i]) continue;\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while(1){\n            V[cur] = true;\n            an++; //サイクル要素数カウント\n            int v = A[cur];\n            m = min(m,v); //サイクル内最小値更新\n            S += v; //サイクル内の総和\n            cur = T[v];\n            if(V[cur] == true) break;\n        }\n        ans += min(S+(an-2)*m, m+S+(an+1)*s); //sは最小値(mainで定義)\n    }\n    return ans;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0); //この2行はより速度を向上させる\n    cin >> n;\n    s = VMAX;\n    for(int i=0; i<n; i++){\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n    int ans = solve();\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\tint x = 10000, y = 0;\n\tint n = 0;\n\tcin >> n;\n\tint* W = new int[n];\n\tint* B = new int[n];\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tcin >> W[i];\n\t\tB[i] = W[i];\n\t\tx = min(x, W[i]);\n\t\ty = max(y, W[i]);\n\t}\n\tint* T = new int[y + 1];\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tT[B[i]] = i;\n\t}\n\tbool* visit = new bool[n];\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tvisit[i] = false;\n\t}\n\tint result = 0;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tif (visit[i])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tint cur = i, sum = 0, num = 0, m = y;\n\t\twhile (!visit[cur])\n\t\t{\n\t\t\tvisit[cur] = true;\n\t\t\tm = min(m, W[cur]);\n\t\t\tsum = sum + W[cur];\n\t\t\tnum++;\n\t\t\tcur = T[W[cur]];\n\t\t}\n\t\tif (num)\n\t\t{\n\t\t\tint a = sum + (num - 2) * m;\n\t\t\tint b = sum + m + (num + 1) * x;\n\t\t\tresult = result + min(sum + (num - 2) * m, sum + m + (num + 1) * x);\n\t\t}\n\t}\n\tcout << result << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint main(){\n    int n, w[1000], a[1000];\n    cin >> n;\n    for(int i=0;i<n;i++){\n        cin >> w[i];\n        a[i]=w[i];\n    }\n    sort(a, a+n);\n    unordered_map<int, deque<int>> idx;\n    for(int i=0;i<n;i++) idx[w[i]].push_back(i);\n\n    ll cost = 0;\n    for(int i=n-1;i>=0;i--){\n        idx[w[i]].pop_front();\n        if(w[i]==a[i]) continue;\n        int j = idx[a[i]].back();\n        idx[a[i]].pop_back();\n        idx[w[i]].push_back(j);\n        sort(idx[w[i]].begin(), idx[w[i]].end());\n        cost += w[i]+a[i];\n        w[j]=w[i];\n    }\n\n    cout << cost << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing ll = long long;\nusing namespace std;\n\n/* initialize */\nint n, A[1010], cost =0;\npair<int, int> P[1010], Q[1010];\n/* main */\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; ++i) scanf(\"%d\", &A[i]);\n    for (int i = 0; i < n; ++i) {\n        P[i].first = A[i]; P[i].second = i;\n    }\n    sort(P, P+n);\n    for (int i = 0; i < n; ++i) {\n        Q[i].first = A[i];\n        Q[P[i].second].second = i;\n    }\n    int s = P[1].first;\n    for (int i = 0; i < n; ++i) {\n        int j = Q[i].second;\n        if(j >= 0 && j != 1){\n            int m = 1, amin, sum;\n            amin=sum=Q[i].first;\n            while(j!=i){\n                int next = Q[j].second;\n                if(next<amin) amin = Q[j].first;\n                sum +=Q[j].first;\n                m++;\n                Q[j].second=-1;\n                j=next;\n            }\n            cost += min(sum+(m-2)*amin, sum+amin+(n+1)*s);\n        }\n    }\n    cout << cost << \"\\n\";\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define REPA(i,n) for(int i=1;i<(n);++i)\n#define PII pair<int,int>\n#define PLI pair<long long, int>\n#define PLL pair<long long, long long>\n#define PDD pair<double, double>\n#define MOD ((int)1e9 + 7)\n#define INF ((int)1e9)\n#define INFLL ((LL)1e18)\n#define ALL(x) (x).begin(),(x).end()\n#define ctoi(x) (x - 'a') \n#define CTOI(x) (x - 'A')\n#define BIT(x) (1 << (x))\nusing namespace std;\n\nLL modinv(LL a){\n    LL b = MOD, u = 1, v = 0;\n    while(b){\n        LL t = a / b;\n        a -= t * b;swap(a, b);\n        u -= t * v;swap(u, v);\n    }\n    u%=MOD;\n    if(u < 0) u += MOD;\n    return u;\n\n}\n\nLL exp(LL a, LL b){\n    LL res = 1;\n    LL sum = a;\n    while(b){\n        if(b&1)res = (res * sum);\n        sum = (sum * sum);\n        b>>=1;\n    }\n    return res;\n}\n\ndouble exp(double a, LL b){\n    double res = 1;\n    double sum = a;\n    while(b){\n        if(b&1)res = (res * sum);\n        sum = (sum * sum);\n        b>>=1;\n    }\n    return res;\n}\n\nsigned  main(){\n    int N;\n    cin >> N;\n    vector<int> line(N);\n    int mincost=INF;\n    REP(i, N){\n        cin >> line[i];\n        mincost = min(mincost, line[i]);\n    }\n    vector<PII> sorted(N);\n    REP(i, N){\n        sorted[i].first = line[i];\n        sorted[i].second = i;\n    }\n    sort(ALL(sorted));\n    vector<int> place(N);\n    REP(i, N){\n        place[sorted[i].second] = i;\n    }\n    int ans = 0;\n    vector<char> used(N, false);\n    REP(i, N){\n        if(used[i])continue;\n        if(i == place[i])continue;\n        int nmin = line[i];\n        int sum = 0;\n        int count = 0;\n        int p = i;\n        while(!used[p]){\n            nmin = min(nmin, line[p]);\n            sum += line[p];\n            used[p] = true;\n            p = place[p];\n            ++count;\n        }\n        int dans = sum + (count - 2) * nmin;\n        dans = min(dans, mincost * (1 + count) + nmin + sum);\n        ans += dans;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<queue>\n#include<vector>\n\n#define MAX 1000\n#define INF 100000\n\nusing namespace std;\n\n//[0] = id, [1] = cost\nint A[MAX][2],SortedA[MAX][2],NumT[MAX];\nbool comp[MAX] = {};\nvector<int> Typelist[MAX];\nint MIN = INF;\n\nvoid sorts(int n){\n    priority_queue<pair<int, int> > PQ;\n    for (int i = 0; i < n; i++) {\n        PQ.push(make_pair(-1*A[i][1], A[i][0]));\n    }\n    for (int i = 0; i < n; i++) {\n        SortedA[i][0] = PQ.top().second;\n        SortedA[i][1] = (-1)*PQ.top().first;\n        PQ.pop();\n    }\n}\n\nvoid trace(int i,int type){\n    while (!comp[i]) {\n        comp[i] = true;\n        Typelist[type-1].push_back(i);\n        i = SortedA[i][0];\n    }\n}\n\nint makeType(int n){\n    int type = 0;\n    for (int i = 0; i < n; i++) {\n        if (!comp[i]) {\n            type++;\n            trace(i,type);\n        }\n    }\n    return type;\n}\n\nint rec(int type){\n    if (Typelist[type].size() == 1) return 0;\n    if (Typelist[type].size() == 2) {\n        return A[Typelist[type][0]][1] + A[Typelist[type][1]][1];\n    }\n    int minc = INF,sum = 0;\n    int n = Typelist[type].size();\n    for (int i = 0; i < n; i++) {\n        sum += A[Typelist[type][i]][1];\n        if (minc > A[Typelist[type][i]][1]) minc = A[Typelist[type][i]][1];\n    }\n    sum -= minc;\n    return sum + min((n-1)*minc, (n-1)*MIN+2*(MIN+minc));\n}\n\nint main(){\n    int N,NofT;\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\",&A[i][1]);\n        A[i][0] = i;\n        if (MIN > A[i][1]) MIN = A[i][1];\n    }\n    sorts(N);\n    NofT = makeType(N);\n    \n    int cost = 0;\n    \n    for (int i = 0; i < NofT; i++) {\n        cost += rec(i);\n    }\n    \n    printf(\"%d\\n\",cost);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#include <cmath>\n#include <stack>\n#include <algorithm>\n#include <random>\n#include <iomanip>\n#include <map>\n#include <queue>\n#include <functional>\n#include <numeric>\n#include <chrono>\n#include <cstdlib>\nusing ll = long long;\nusing namespace std;\n\nconst ll MOD = 1e9 + 7;\nconst double pi = acos(-1);\ntypedef pair<int, int> P;\n#define REP(i, n) for (int(i) = 0; (i) < (n); ++(i))\n#define repi(i, a, b) for (int i = int(a); i < int(b); ++i)\n#define EPS 1e-4\n#define OUTPUT(i) (cout << (ll)i << endl)\n#define ALL(a) ((a).begin(), (a).end())\n\nbool operator<(const pair<ll, ll> &a, const pair<ll, ll> &b)\n{\n\n    if (a.first == b.first)\n        return a.second < b.second;\n\n    return a.first < b.first;\n}\nint n;\nint arr[1010], R[1010], T[10100];\nint s = 10000;\n\nint solvisitede()\n{\n    int ans = 0;\n    bool visited[10100];\n    int B[1010];\n\n    for (int i = 0; i < n; ++i)\n        visited[i] = false;\n    for (int i = 0; i < n; ++i)\n    {\n        B[i] = arr[i];\n    }\n    sort(B, B + n);\n\n    for (int i = 0; i < n; ++i)\n        T[B[i]] = i;\n\n    for (int i = 0; i < n; ++i)\n    {\n        if (visited[i])\n            continue;\n        int cur = i;\n        int S = 0;\n        int m = 10000;\n        int an = 0;\n        while (1)\n        {\n            visited[cur] = true;\n            an++;\n            int v = arr[cur];\n            m = min(m, v);\n            S += v;\n            cur = T[v];\n            if (visited[cur])\n                break;\n        }\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n    }\n    return ans;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //cout << fixed << setprecision(15);\n\n    cin >> n;\n\n    for (int i = 0; i < n; ++i)\n    {\n        cin >> arr[i];\n        s = min(s, arr[i]);\n    }\n\n    int ans = solvisitede();\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int> W(n);\n    for (auto& w : W) cin >> w;\n    int cnt = 0;\n    for (int i = n - 1; i >= 1; i--) {\n        int max_i = max_element(W.begin(), W.begin() + i + 1) - W.begin();\n        if (i == max_i) continue;\n        cnt += W[i] + W[max_i];\n        swap(W[i], W[max_i]);\n    }\n    cout << cnt << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n#include <string>\n#include <utility>\n\nusing namespace std;\n\nint main(){\n  int n; // 1..1000\n  cin >> n;\n  vector<int> w, s;\n  for(int i=0;i<n;++i){int w_i; cin >> w_i; w.push_back(w_i);}\n  s = w;\n  sort(s.begin(), s.end());\n\n\n  int cost=0;\n  for(int i=n-1; i>=0; --i){\n    auto tgt_itr = find(w.begin(), w.end(), s[i]);\n    int tgt_idx = tgt_itr - w.begin();\n\n    if(i!=tgt_idx){\n      cost += (w[i] + w[tgt_idx]);\n      swap(w[i], w[tgt_idx]);\n    }\n  }\n\n  cout << cost << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n\n\nusing namespace std;\n\nint main() {\n\t\n\tint const N_MAX = 1000;\n\tint const W_MAX = 10000;\n\n\tint n = 0;\n\tcin >> n;\n\n\tvector<int> W, S, T;\n\tvector<bool> C;\n\t\n\tW.resize(n, 0);     // idx -> W\n\tS.resize(n, 0);     // sorted Wi\n\tT.resize(W_MAX, 0); // W -> idx\n\tC.resize(n, false); // flag for searched or not\n\n\tint g_min = W_MAX; // global_min of Wi\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> W[i];\n\t\tg_min = (W[i] < g_min) ? W[i] : g_min;\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tT[W[i]] = i;\n\t}\n\n\tS = W;\n\tstable_sort(S.begin(), S.end());\n\n\tint score = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!C[T[S[i]]]) {\n\t\t\tint l_min = W_MAX;\n\t\t\tint sum = 0;\n\t\t\tint cnt = 0;\n\t\t\tfor(int j = S[i]; !C[T[j]]; j = S[T[j]] ) {\n\t\t\t\tC[T[j]] = true;\n\t\t\t\tcnt++;\n\t\t\t\tsum += j;\n\t\t\t\tl_min = (j < l_min) ? j : l_min;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\tscore += min(sum + l_min*(cnt - 2), sum+g_min*cnt+2*l_min);\n\t\t}\n\t}\n\n\tcout << score << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define MAX_W 10000\n\nclass wi {\n    public:\n    int w, i;\n    bool done;\n};\n\nbool cmp(wi& wi1, wi& wi2)\n{\n    if (wi1.w < wi2.w) return true;\n    else return false;\n}\n\nint solve(vector<wi> w)\n{\n    int ans = 0, count = 0;\n    sort(w.begin(), w.end(), cmp);\n    for (vector<wi>::iterator itr = w.begin(); itr != w.end(); ++itr) {\n        if (itr->done) continue;\n        vector<wi>::iterator cur = itr;\n        int an = 0, S = 0;\n        while (!cur->done) {\n            cur->done = true;\n            an++;\n            S += cur->w;\n            cur = w.begin() + cur->i;\n        }\n        ans += min(S + (an - 2) * itr->w, itr->w + S + (an + 1) * w.begin()->w);\n    }\n    return ans;\n}\n\nint main()\n{\n    int i = 0, n;\n    cin >> n;\n    vector<wi> w(n);\n    for (vector<wi>::iterator itr = w.begin(); itr != w.end(); ++itr) {\n        cin >> itr->w;\n        itr->i = i++;\n        itr->done = false;\n    }\n    int ans = solve(w);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\n#define W_MAX 1000001\n#define MAX 1001\n\nint array[MAX];\nint sorted[MAX];\n\nvoid swap(int* a, int* b){\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nint calc_cost(int n, int min_pos, int flag = 0){\n  int loop_pos = min_pos;\n  int i, sum = 0;\n  int min = array[min_pos];\n\n  do{\n    //printf(\"%d %d %d\\n\", loop_pos, sum, min);\n\n    for(i = 0; i < n; i++){\n      if(array[i] == sorted[loop_pos]){\n\tsum += array[i] + array[loop_pos];\n\tif(flag){ swap(&array[i], &array[loop_pos]); }\n\tloop_pos = i;\n\t\n\tbreak;\n      }\n    }\n  }while(min != sorted[loop_pos]);\n\n  return sum;\n}\n\nint greedy(int n){\n  int i, j;\n  int absolute_min = array[0], absolute_min_pos = -1;\n  int min = W_MAX, min_pos = -1;\n  int loop_pos = -1;\n  int direct_sum = 0;\n  int indirect_sum = 0;\n\n  for(i = 0; i < n; i++){\n    if(array[i] == absolute_min){\n      absolute_min_pos = i;\n      break;\n    }\n  }\n\n  for(i = 0; i < n; i++){\n    if(min > array[i] && sorted[i] != array[i]){\n      min = array[i];\n      min_pos = i;\n    }\n  }\n\n  if(min_pos == -1){\n    return 0;\n  }\n\n  direct_sum += calc_cost(n, min_pos);\n  \n  swap(&array[min_pos], &array[absolute_min_pos]);\n  indirect_sum += array[min_pos] + array[absolute_min_pos];\n  indirect_sum += calc_cost(n, min_pos);\n  indirect_sum += array[min_pos] + array[absolute_min_pos];\n  swap(&array[min_pos], &array[absolute_min_pos]);\n\n  //printf(\"direct_sum = %d, indirect_sum = %d\\n\", direct_sum, indirect_sum);\n\n  if(direct_sum <= indirect_sum){\n    calc_cost(n, min_pos, 1);\n    \n    return direct_sum + greedy(n);\n  }else{\n    swap(&array[min_pos], &array[absolute_min_pos]);\n    calc_cost(n, min_pos, 1);\n    swap(&array[min_pos], &array[absolute_min_pos]);\n\n    return indirect_sum + greedy(n);\n  }\n\n  return 0;\n}\n\nint main(int argc, char* argv[]){\n  int i, j, n;\n  scanf(\"%d\", &n);\n\n  for(i = 0; i < n; i++){\n    scanf(\"%d\", &array[i]);\n    sorted[i] = array[i];\n  }\n  \n  for(i = 0; i < n; i++){\n    int min = sorted[i];\n    int min_pos = i;\n    \n    for(j = i + 1; j < n; j++){\n      if(min > sorted[j]){\n\tmin = sorted[j];\n\tmin_pos = j;\n      }\n    }\n\n    if(min_pos != i){\n      swap(&sorted[i], &sorted[min_pos]);\n    }\n  }\n\n\n  printf(\"%d\\n\", greedy(n));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : MinCostSort.cpp\n// Author      : Ken\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_W = 10000;\n\nvoid writeVector(vector<int>& v){\n\tfor(int i=0; i<v.size(); i++){\n\t\tcout << v.at(i) << \"\\n\";\n\t}\n}\n\nvoid writeVector(vector<bool>& v){\n\tfor(int i=0; i<v.size(); i++){\n\t\tcout << v.at(i) << \"\\n\";\n\t}\n}\n\nint main() {\n\tint n, input, min_all=MAX_W, total_sum=0;\n\tcin >> n;\n\tvector<int> v, inv_v(MAX_W);\n\tvector<bool> isIterated(n);\n\n\tfor(int i=0; i<isIterated.size(); i++){\n\t\tisIterated.at(i) = false;\n\t}\n\n\n\tfor(int i=0; i<n; i++){\n\t\tcin >> input;\n\t\tv.push_back(input);\n\t\tinv_v.at(input) = i;\n\t\tif(input<min_all){\n\t\t\tmin_all = input;\n\t\t}\n\t}\n\n\tsort(v.begin(), v.end());\n\n\t//cout << \"v:\\n\";\n\t//writeVector(v);\n\t//cout << \"inv_v:\\n\";\n\t//writeVector(inv_v);\n\t//cout << \"isIterated:\\n\";\n\t//writeVector(isIterated);\n\n\tfor(int i=0; i<v.size(); i++){\n\t\tint min_in_loop = MAX_W;\n\t\tint sum_loop = 0;\n\t\tint pos = i;\n\t\tint elem = v.at(i);\n\t\tint loop_size = 0;\n\n\t\tif(not isIterated.at(pos)){\n\t\t\tisIterated.at(pos) = true;\n\n\t\t\tif(inv_v.at(v.at(pos)) == pos){\n\t\t\t\t//cout << \"single loop: \" << v.at(pos) << \"\\n\";\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//cout << \"multi loop: \";\n\t\t\twhile(true){\n\t\t\t\tloop_size++;\n\t\t\t\tisIterated.at(pos) = true;\n\t\t\t\t//cout << elem << \" \";\n\n\t\t\t\tsum_loop += elem;\n\n\t\t\t\tif(elem < min_in_loop){\n\t\t\t\t\tmin_in_loop = elem;\n\t\t\t\t}\n\n\t\t\t\tpos = inv_v.at(elem);\n\t\t\t\telem = v.at(pos);\n\n\t\t\t\tif(isIterated.at(pos)){\n\t\t\t\t\t//cout << \"sum_loop: \" << sum_loop << \", min_in_loop: \" << min_in_loop << \" \"\n\t\t\t\t\t//\t << \"loop_size: \" << loop_size << \"\\n\";\n\t\t\t\t\t//cout << \"\\n\";\n\n\t\t\t\t\tint add = min(min_in_loop*(loop_size-2), min_all*(loop_size));\n\n\t\t\t\t\ttotal_sum += sum_loop + add;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << total_sum << \"\\n\";\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\n#define SIZE 1005\n\nint N;\nint table[SIZE];\nbool check[SIZE];\nmap<int,int> MAP;\n\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\tint minimum = BIG_NUM;\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tcheck[i] = false;\n\t}\n\n\tvector<int> V;\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tscanf(\"%d\",&table[i]);\n\t\tV.push_back(table[i]);\n\t\tminimum = min(minimum,table[i]);\n\t}\n\n\tsort(V.begin(),V.end());\n\tfor(int i = 0; i < N; i++){\n\n\t\tMAP[V[i]] = i;\n\t}\n\n\tint ans = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tif(check[i] == true || MAP[table[i]] == i)continue;\n\n\t\tint num = 1;\n\t\tint group_min = BIG_NUM;\n\t\tint tmp_sum = 0;\n\t\tint index = i;\n\n\t\twhile(true){\n\t\t\ttmp_sum += table[index];\n\t\t\tgroup_min = min(group_min,table[index]);\n\t\t\tcheck[index] = true;\n\n\t\t\tindex = MAP[table[index]];\n\t\t\tif(check[index]){\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnum++;\n\t\t}\n\n\t\tif(num == 2){\n\t\t\tans += tmp_sum;\n\t\t\tcontinue;\n\t\t}\n\n\t\tans += min(tmp_sum+(num-2)*group_min,tmp_sum+(num+1)*minimum+group_min);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\nusing namespace std;\nint main(){\n  int n,ans=0,t[1000],u[1000];\n  bool visited[1000];\n  map<int,int> change;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>t[i];\n    change[t[i]]=i;\n    u[i]=t[i];\n    visited[i]=false;\n  }\n  sort(u,u+n);\n  for(int i=0;i<n;i++){   \n    int w=i,x=0,y=0,z=10000;\n    while(!visited[w]){\n      z=min(z,t[w]);\n      y+=t[w];\n      x++;\n      visited[w]=true;\n      w=change[u[w]];\n    }\n    if(x>=2)ans+=min(y+z+u[0]*(x+1),y+z*(x-2));\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <limits>\n#include <fstream>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int N;cin>>N;\n  int w[N];\n  int mini = 2e9;\n  map<int, int> mp;\n  FOR(i,0,N){\n    cin>>w[i];\n    mini = min(mini, w[i]);\n    mp[w[i]] = 0;\n  }\n  int k = 0;\n  for(auto& m : mp) m.second = k++;\n  bool done[N];\n  CLR(done);\n  int ans = 0;\n  FOR(i,0,N){\n    if(done[i]) continue;\n    int cnt = 0, now = i, mi = 2e9, sum = 0;\n    // 巡回\n    while(!done[now]){\n      cnt++;\n      done[now] = true;\n      mi = min(mi, w[now]);\n      sum += w[now];\n      now = mp[w[now]];\n    }\n    if(cnt <= 1) continue;\n    ans += min(sum + mi * (cnt - 2), sum + mi + mini * (cnt + 1));\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n#define rrep(ri,n) for(int ri = (int)(n-1); ri >= 0; ri--)\n#define rep2(i,x,n) for(int i = (int)(x); i < (int)(n); i++)\n#define repit(itr,x) for(auto itr = x.begin(); itr != x.end(); itr++)\n#define rrepit(ritr,x) for(auto ritr = x.rbegin(); ritr != x.rend(); ritr++)\n#define ALL(n) begin(n), end(n)\nusing ll = long long;\nusing namespace std;\n\nint main(){\n\tint n, mn = 1001001001;\n\tcin >> n;\n\tvector<int> w(n);\n\trep(snip_i, n){\n\t\tcin >> w.at(snip_i);\n\t\tmn = min(mn, w.at(snip_i));\n\t}\n\tvector<int> w2 = w;\n\tsort(w2.begin(), w2.end());\n\tvector<int> ww;\n\trep(i, n){\n\t\tif(w.at(i) != w2.at(i)){\n\t\t\tww.push_back(w.at(i));\n\t\t}\n\t}\n\tvector<int> ww2 = ww;\n\tsort(ww2.begin(), ww2.end());\n\tvector<int> wn(ww.size());\n\trep(i, ww.size()){\n\t\tint now = ww.at(i);\n\t\trep(j, ww2.size()){\n\t\t\tif(ww2.at(j) == now){\n\t\t\t\twn.at(i) = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> grp(ww.size(), -1);\n\tint count = 0;\n\tbool end = false;\n\tll ans = 0;\n\twhile(!end){\n\t\tll grpmn, grpsum = 0, grpc = 0;\n\t\trep(i, wn.size()){\n\t\t\tif(grp.at(i) == -1){\n\t\t\t\tgrpc++;\n\t\t\t\tgrp.at(i) = count;\n\t\t\t\tgrpsum = ww.at(i);\n\t\t\t\tgrpmn = ww.at(i);\n\t\t\t\tint nx = wn.at(i);\n\t\t\t\twhile(nx != i){\n\t\t\t\t\tgrpc++;\n\t\t\t\t\tgrp.at(nx) = count;\n\t\t\t\t\tgrpsum += ww.at(nx);\n\t\t\t\t\tgrpmn = min(grpmn, (ll)ww.at(nx));\n\t\t\t\t\tnx = wn.at(nx);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(grpc == 0) break;\n\t\tll add1 = grpsum + grpmn * (grpc - 2);\n\t\tgrpsum = grpsum - grpmn + mn;\n\t\tll add2 =grpsum + mn * (grpc - 2) + 2 * (grpmn + mn);\n\t\tans += min(add1, add2);\n\t\tcount++;\n\t\t// cerr << add1 << \" \" << add2 << \" \" << grpmn << \" \" << grpc << endl;\n\t}\n\t\n\t// rep(i, ww2.size()){\n\t// \tprintf(\"%2d \", i);\n\t// }\n\t// cout << endl;\n\t// rep(i, ww.size()){\n\t// \tprintf(\"%2d \", ww.at(i));\n\t// }\n\t// cout << endl;\n\t// rep(i, wn.size()){\n\t// \tprintf(\"%2d \", wn.at(i));\n\t// }\n\t// cout << endl;\n\t// rep(i, ww2.size()){\n\t// \tprintf(\"%2d \", ww2.at(i));\n\t// }\n\t// cout << endl;\n\t// rep(i, grp.size()){\n\t// \tprintf(\"%2d \", grp.at(i));\n\t// }\n\t// cout << endl;\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve() {\n\tint ans = 0;\n\t\n\tbool V[VMAX];\n\tfor(int i = 0; i < n; i++) {\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B, B + n);\n\tfor(int i = 0; i < n; i++) T[B[i]] = i;\n\tfor(int i = 0; i < n; i++) {\n\t\tif( V[i] ) continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint as = 1;\n\t\tint m = VMAX;\n\t\twhile(1) {\n\t\t\tV[cur] = false;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\ts += v;\n\t\t\tcur = T[v];\n\t\t\tif( V[cur] ) break;\t\t\t\n\t\t}\n\t\tans += min(S + (an - 2) * m, S + m +(an + 1) * s);\n\t}\n\t\n\treturn ans;\n} \n\nint main() {\n\tcin >> n;\n\ts = VMAX;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tint ans = solve();\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<list>\nusing namespace std;\n\ntypedef struct{int a;int b;int c;} arr;\ntypedef pair<long long,long long> logg;\n\narr L[510],R[510];\n\nint merge(arr a[],int l,int m,int r,char c)\n{\n\tint n1=m-l;\n\tint n2=r-m;\n\tfor(int i=0;i<n1;i++)\n\t{\n\t\tL[i]=a[l+i];\n\t}\n\tfor(int i=0;i<n2;i++)\n\t{\n\t\tR[i]=a[m+i];\n\t}\n\tint i=0,j=0;\n\tif(c=='a')\n\t{\n\t\tL[n1].a=100000;R[n2].a=100000;\n\t\tfor(int k=l;k<r;k++)\n\t\t{\n\t\t\tif(L[i].a<=R[j].a)\n\t\t\t{\n\t\t\t\ta[k]=L[i++];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta[k]=R[j++];\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tL[n1].c=100000;R[n2].c=100000;\n\t\tfor(int k=l;k<r;k++)\n\t\t{\n\t\t\tif(L[i].c<=R[j].c)\n\t\t\t{\n\t\t\t\ta[k]=L[i++];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta[k]=R[j++];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint mergeS(arr a[],int l,int r,char c)\n{\n\tif(l+1<r)\n\t{\n\t\tint m=(l+r)/2;\n\t\tmergeS(a,l,m,c);\n\t\tmergeS(a,m,r,c);\n\t\tmerge(a,l,m,r,c);\n\t}\n}\n\n\nint main()\n{\n\tint n,j=1;cin>>n;\n\tarr a[1010];\n\tlogg c[1010];\n\tfor(int i=1;i<=n;cin>>a[i++].a);a[n+1].a==1;\n\t\n\t\n\tfor(int i=1;i<=n;a[i].c=i,i++);\n\tmergeS(a,1,n+1,'a');\n\tint mm=a[1].a;\n\tfor(int i=1;i<=n;a[i].b=i,i++);\n\tmergeS(a,1,n+1,'c');\n\tfor(int i=1,m=100000;;)\n\t{\n\t\tif(a[i].b!=0)//.b\n\t\t{\n\t\t\tc[j].first++;\n\t\t\tc[j].second+=a[i].a;\n\t\t\tif(a[i].a<m)m=a[i].a;\n\t\t\tint l=a[i].b;//.b\n\t\t\ta[i].b=0;//.b\n\t\t\ti=l;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(c[j].first==1)\n\t\t\t{\n\t\t\t\tc[j].second=0;\n\t\t\t}\n\t\t\telse if(c[j].first>=3)\n\t\t\t{\n\t\t\t\tint ss=c[j].second;\n\t\t\t\tc[j].second+=m*(c[j].first-2);\n\t\t\t\tif(ss+m+(c[j].first+1)*mm<c[j].second)c[j].second=ss+m+(c[j].first+1)*mm;\n\t\t\t}\n\t\t\tm=100000;\n\t\t\tj++;\n\t\t\tint s=0;\n\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t{\n\t\t\t\ts+=a[k].b;//a\n\t\t\t\tif(a[k].b!=0)i=k;//a\n\t\t\t}\n\t\t\tif(s==0)break;\n\t\t}\n\t}\n\tlong long s=0;\n\tfor(int i=1;i<=j;i++)\n\t{\n\t\ts+=c[i].second;\n\t}\n\tcout<<s<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <iostream>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#define INTINF 2147483647\n#define LLINF 9223372036854775807\ntypedef long long ll;\nusing namespace std;\n\nint main(int argc, char const *argv[]) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int N, tmp, cost=0; std::cin >> N;\n\n  std::vector<int> w, sorted;\n  w.reserve(1000); sorted.reserve(1000);\n\n  for (size_t i = 0; i < N; i++) {\n    std::cin >> tmp;\n    w.push_back(tmp);\n    sorted.push_back(tmp);\n  }\n\n  sort(sorted.begin(), sorted.end());\n\n  for (size_t i = 0; i < N; i++) {\n    for (size_t j = i; j < N; j++) {\n      if (w[i]==sorted[j] && i!=j) {\n        cost += w[i]+w[j];\n      }\n    }\n  }\n\n  std::cout << cost << '\\n';\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nstatic const int MAX_N = 1000;\nstatic const u_short MAX_ELEM = 10000;\n\nint costToSort(u_short In[], u_short Sorted[], u_short size) {\n    int i;\n    bool visited[size];\n    int cost = 0;\n    u_short all_min = *min_element(In, In + size);\n\n    for (i = 0; i < size; i++)\n    {\n        visited[i] = false;\n    }\n\n    for (i = 0; i < size; i++)\n    {\n        auto elem = In[i];\n        auto cycle_min = elem;\n        int cycle_sum = elem;\n        u_short cycle_size = 1;\n        auto cycle_idx = i;\n\n        if (visited[cycle_idx])\n            continue;\n\n        while(true) {      \n            visited[cycle_idx] = true;\n            cycle_idx = lower_bound(Sorted, Sorted + size, elem) - Sorted;\n\n            if (visited[cycle_idx])\n                break;\n\n            elem = In[cycle_idx];\n            cycle_min = min(cycle_min, elem);\n            cycle_sum += elem;\n            cycle_size += 1;\n        }\n\n        cost += cycle_sum + min((cycle_size - 2) * cycle_min, cycle_min + (cycle_size + 1) * all_min);\n    }\n\n    return cost;\n}\n\nint main() {\n    int N;\n\n    cin >> N;\n\n    u_short A[N];\n    u_short B[N];\n\n    for (int i = 0; i < N; i++)\n    {\n        cin >> A[i];\n        B[i] = A[i];\n    }\n\n    sort(B, B + N);\n\n    auto cost = costToSort(A, B, N);\n\n    cout << cost;\n    cout << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 1000\n#define MMAX 10000\n\nint n,a[MAX],s;\nint b[MAX],t[MMAX+1];\n\nint solve(){\n  int ans=0;\n  bool v[MAX];\n  for(int i=0;i<n;i++){\n    b[i]=a[i];\n    v[i]=false;\n  }\n  sort(b,b+n);\n  for(int i=0;i<n;i++) t[b[i]]=i;\n  for(int i=0;i<n;i++){\n    if(v[i]) continue;\n    int cur=i;\n    int S=0;\n    int m=MMAX;\n    int an=0;\n    while(1){\n      v[cur]=true;\n      an++;\n      int V=a[cur];\n      m=min(m,V);\n      S+=V;\n      cur=t[V];\n      if(v[cur]) break;\n    }\n    ans+=min(S+(an-2)*m,m+S+(an+1)*s);\n  }\n  return ans;\n}\n\n  \nint main(){\n  cin>>n;\n  s=MMAX;\n  for(int i=0;i<n;i++){\n    cin>>a[i];\n    s=min(s,a[i]);\n  }\n  cout<<solve()<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cmath>\n#include <stack>\n#include <set>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n); (i)++)\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b); (i)++)\n#define PUSH(n,v) for(int i=0; i<(n); i++) {int j; cin >> j; v.push_back(j);}\n#define ALL(v) v.begin(), v.end()\n\nvector<int> sorted;\n\nint minimumCostSort(vector<int> &v) {\n    int n = v.size();\n    int cost = 0;\n    REP(i,n) {\n        if (v[n-i-1] != sorted[n-i-1]) {\n            int indexOfBiggest = find(v.begin(), v.end(), sorted[n-i-1]) - v.begin();\n            v[indexOfBiggest] = v[n-i-1];\n            cost += v[n-i-1] + sorted[n-i-1];\n            v[n-i-1] = sorted[n-i-1];\n        }\n    }\n    return cost;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> v;\n    PUSH(n,v);\n    copy(v.begin(), v.end(), back_inserter(sorted));\n    sort(sorted.begin(), sorted.end());\n    \n    cout << minimumCostSort(v) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * ALDS1_6_D.cpp\n *\n *  Created on: May 2, 2018\n *      Author: 13743\n */\n\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main() {\n\tint n;\n\tint A[1000];\n\tint B[1000];\n\tint aW[10001] = {-1};\n\tcin >> n;\n\tfor(int i=0; i<n; i++) {\n\t\tcin >> A[i];\n\t\tB[i] = A[i];\n\t\taW[A[i]] = i;\n\t}\n\n\tsort(B, B+n);\n\tint glMin = B[0];\n\tint rm = 0;\n\n\tfor(int i=0; i<n; i++) {\n\t\tif(aW[B[i]] == -1) continue;\n\t\tint c = 0;\n\t\tint lcMin = B[i];\n\t\tint j = aW[lcMin];\n\t\taW[lcMin] = -1;\n\t\trm -= lcMin;\n\t\twhile(j != -1) {\n\t\t\trm += A[j];\n\t\t\tc++;\n\t\t\tj = aW[B[j]];\n\t\t}\n\t\trm += min(lcMin*(c-1), 2*(lcMin+glMin)+glMin*(c-1));\n\t}\n\n\tcout << rm << endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int INF = 1000000;\n\nint partition(int *A,int p,int r)\n{\n\tint j,x,temp;\n\n\tx = A[r];\n\tj = p-1;\n\n\tfor(int i = p; i < r; i++)\n\t{\n\t\tif (A[i] <= x)\n\t\t{\n\t\t\tj++;\n\t\t\ttemp = A[i];\n\t\t\tA[i] = A[j];\n\t\t\tA[j] = temp;\n\t\t}\n\t}\n\n\ttemp = A[j+1];\n\tA[j+1] = A[r];\n\tA[r] = temp;\n\n\treturn j+1;\n}\n\nvoid quicksort(int *A,int p,int r)\n{\n\tint q;\n\n\tif (p < r)\n\t{\n\t\tq = partition(A,p,r);\n\t\tquicksort(A,p,q-1);\n\t\tquicksort(A,q+1,r);\n\t}\n}\n\nint solve_swap(int *a,int *b,int n)\n{\n\tint sum,temp;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (a[i] != b[i])\n\t\t{\n\t\t\tfor(int j = i+1; j < n; j++)\n\t\t\t{\n\t\t\t\tif (b[j] == a[i] && b[i] == a[j])\n\t\t\t\t{\n\t\t\t\t\ttemp = a[i];\n\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\ta[j] = temp;\n\n\t\t\t\t\tsum += a[i] + a[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n\nint solve1(int *a,int *b,int n)\n{\n\tbool check;\n\tint min,num,temp,sum,start;\n\n\tsum = 0;\n\tstart = 0;\n\n\twhile(1)\n\t{\n\t\tmin = INF;\n\t\t\n\t\tcheck = true;\n\n\t\t//printf(\"start = %d\\n\", start);\n\n\t\tfor(int i = start; i < n; i++)\n\t\t{\n\t\t\tif (min > a[i] && a[i] != b[i])\n\t\t\t{\n\t\t\t\tnum = i;\n\t\t\t\tmin = a[num];\n\t\t\t}\n\t\t}\n\n\t\t//printf(\"num = %d\\n\", num);\n\t\t//printf(\"min = %d\\n\", min);\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (a[i] == b[num])\n\t\t\t{\n\t\t\t\t//printf(\"%d and %d are swapped\\n\", a[num],a[i]);\n\t\t\t\tsum += a[num] + a[i];\n\t\t\t\ttemp = a[i];\n\t\t\t\ta[i] = min; // min = a[num]\n\t\t\t\ta[num] = temp;\n\t\t\t\tnum = i;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (a[i] != b[i])\n\t\t\t{\n\t\t\t\tcheck = false;\n\t\t\t\tstart = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\t//printf(\"a[i] = %d\\n\", a[i]);\n\t\t}\n\n\t\tif (check)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn sum;\n}\n\nbool check(int *A,int *B,int n)\n{\n\tbool c = true;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (A[i] != B[i])\n\t\t{\n\t\t\tc = false;\n\t\t}\n\t}\n\n\treturn c;\n}\n\nint main()\n{\n\tint n,a[1000] = {0},b[1000] = {0},a2[1000] = {0};\n\tint sum1 = 0;\n\t//int sum2 = 0,pivot = 0,pivot1 = 0,pivot2= 0,min = 0,start=0,temp=0,k=0;\n\n\tscanf(\"%d\", &n);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\tb[i] = a[i];\n\t}\n\n\tquicksort(b,0,n-1);\n\n\tsum1 = solve_swap(a,b,n);\n\n\t//printf(\"sum = %d\\n\", sum1);\n\n\tif (check(a,b,n))\n\t{\n\t\tprintf(\"%d\\n\", sum1);\n\t\treturn 0;\n\t}\n\n/*\n\tsum2 = sum1;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\ta2[i] = a[i];\n\t}\n\n\t//printf(\"\\nhere is sum1\\n\");\n\n\tsum1 += solve1(a,b,n);\n\n\t//printf(\"sum1 = %d\\n\",sum1);\n\n\n\tif (check(a,b,n))\n\t{\n\t\tprintf(\"%d\\n\", sum1);\n\t\treturn 0;\n\t}\n\n\n\n\tfor(int i = 1; i < n - start; i++)\n\t{\n\t\tk = start;\n\n\t\t\n\t\twhile(1)\n\t\t{\n\t\t\tif (b[pivot1] == a[k])\n\t\t\t{\n\t\t\t\tprintf(\"%d and %d are swapped\\n\", a[pivot1],a[k]);\n\t\t\t\ttemp = a[pivot1];\n\t\t\t\ta[pivot1] = a[k];\n\t\t\t\ta[k] = temp;\n\n\t\t\t\tsum1 += a[pivot1] + a[k];\n\t\t\t\tpivot1 = k;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tprintf(\"%d \", a[i]);\n\t\t}\n\t\tcout << endl;\n\t}\n\n\n\tif (!check(a,b,n))\n\t{\n\t\tprintf(\"\\nhere is sum2\\n\");\n\t\ttemp = a2[pivot2];\n\t\ta2[pivot2] = a2[0];\n\t\ta2[0] = temp;\n\n\t\tfor(int i = 1; i < n - start; i++)\n\t\t{\n\t\t\tint j = start;\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif (b[pivot2] == a2[j])\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d and %d are swapped\\n\", a2[pivot2],a2[j]);\n\t\t\t\t\ttemp = a2[pivot2];\n\t\t\t\t\ta2[pivot2] = a2[j];\n\t\t\t\t\ta2[j] = temp;\n\n\t\t\t\t\tsum2 += a2[pivot2] + a2[j];\n\t\t\t\t\tpivot2 = j;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tprintf(\"%d \", a2[i]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\n\t\tif (sum1 < sum2)\n\t\t{\n\t\t\tprintf(\"sum1 = %d\\n\", sum1);\n\t\t}else\n\t\t{\n\t\t\tprintf(\"sum2 = %d\\n\", sum2);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\n\tprintf(\"%d\\n\", sum1);\n*/\n\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define Vi vector<int>\n#define FOR(i,s,e) for (int i=s; i<e; i++)\n#define ITER(v) v.begin(), v.end()\n\nconstexpr int MAX_N = 1000;\nconstexpr int MAX_VAL = 10001;\n\nint minCostSort(int* w, int* ref, int n, int minval) {\n    bool isfixed[MAX_N] = {0};\n    int cost = 0;\n    FOR(i,0,n) {\n        if (isfixed[i]) { continue; }\n        int fromindex = i;\n        int n_chain = 0;\n        int minelm_in_chain = MAX_VAL;\n        int sum = 0;\n        while (true) {\n            sum += w[fromindex];\n            isfixed[fromindex] = true;\n            ++n_chain;\n            if (minelm_in_chain > w[fromindex]) { minelm_in_chain = w[fromindex]; }\n            int destindex = distance(ref, lower_bound(ref, ref+n, w[fromindex]));\n            if (destindex == i) { break; }\n            fromindex = destindex;\n        }\n        if (n_chain < 2) { continue; }\n        cost += min(\n            sum + (n_chain-2) * minelm_in_chain,\n            sum + (n_chain+1) * minval + minelm_in_chain\n        );\n    }\n    return cost;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n\n    int w[MAX_N];\n    int ref[MAX_N];\n    int minval = MAX_VAL;\n    FOR(i,0,n) {\n        cin >> w[i];\n        ref[i] = w[i];\n        if (minval > w[i]) { minval = w[i]; }\n    }\n\n    sort(ref, ref+n);\n    int cost = minCostSort(w, ref, n, minval);\n    cout << cost << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n\n//?£wi + (n - 2) * min(wi)\n//or\n//?£wi + min(wi) + (n+1) * x\n\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint A[MAX];\nint B[MAX];\nbool V[MAX];\nint T[VMAX];\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint s = VMAX;\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &A[i]);\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t\ts = min(s, A[i]);\n\t\tT[A[i]] = i;\n\t}\n\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tT[B[i]] = i;\n\t}\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (V[i] == true) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\n\t\twhile (1) {\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif (V[cur] == true) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tans += min(S + (an - 2) * m, S + m + (an + 1) * s);\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_6_D\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint\nmain()\n{\n    ios_base::sync_with_stdio(false);\n\n    int n;\n    cin >> n; cin.ignore();\n\n    vector<int> A(n);\n    vector<int> B(n);\n    for (int i = 0; i < n; i++) {\n        cin >> A[i]; cin.ignore();\n        B[i] = A[i];\n    }\n    sort(B.begin(), B.end());\n\n    int sum = 0;\n    auto ita = A.cbegin();\n    auto itb = B.cbegin();\n    while (ita != A.end()) {\n        if (*ita != *itb) { sum += *ita; }\n        ita++; itb++;\n    }\n\n    cout << sum << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve();\n\nint main()\n{\n  cin >> n;\n  s = VMAX;\n  for (int i = 0; i < n; i++)\n  {\n    cin >> A[i];\n    s = min(s, A[i]);\n  }\n  cout << solve() << endl;\n  return 0;\n}\n\nint solve()\n{\n  int ans = 0;\n  bool V[MAX];\n  for (int i = 0; i < n; i++)\n  {\n    B[i] = A[i];\n    V[i] = false;\n  }\n  sort(B, B + n);\n  for (int i = 0; i < n; i++)\n  {\n    T[B[i]] = i;\n  }\n  for (int i = 0; i < n; i++)\n  {\n    if (V[i])\n    {\n      continue;\n    }\n    int cur = i, S = 0, m = VMAX, an = 0;\n    while (1)\n    {\n      V[cur] = true;\n      an++;\n      int v = A[cur];\n      m = min(m, v);\n      S += v;\n      cur = T[v];\n      if (V[cur])\n      {\n        break;\n      }\n    }\n    ans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n  }\n  return ans;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <string>\n#define MAX 1000\n#define INFTY 1<<30 // 2^30\nusing namespace std;\ntypedef long long llong;\n\nstatic const int VMAX = 10000;\nint n, A[MAX+10], s;\nint B[MAX+10], T[VMAX+10];\n\nint solve()\n{\n  int ans = 0;\n  bool V[MAX+10];\n  for(int i = 0; i < n; i++)\n  {\n    B[i] = A[i];\n    V[i] = false;\n  }\n  sort(B,B+n);\n  for(int i = 0; i < n; i++) T[B[i]] = i; // ????????????????????????????????????????????????\n  for(int i = 0; i < n; i++)\n  {\n    if(V[i]) continue;\n    int cur = i; // current point\n    int S = 0; // sum of mass\n    int m = VMAX; // min of the cycle\n    int an = 0; // the number of material the cycle have\n    while(1)\n    {\n      V[cur] = true; //already visited\n      an++;\n      int v = A[cur];\n      m = min(m, v);\n      S += v;\n      cur = T[v];\n      if(V[cur]) break;\n    }\n    ans += min(S+(an-2)*m, S+(an+1)*s+m);\n  }\n  return ans;\n}\n\nint main()\n{\n  cin >> n;\n  s = VMAX;\n  for(int i = 0; i < n; i++)\n  {\n    cin >> A[i];\n    s = min(s,A[i]);\n  }\n  cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nstruct QuickFind{\n  vector<int> r,p;\n  vector<vector<int> > v;\n  QuickFind(){}\n  QuickFind(int size){init(size);}\n  void init(int size){\n    r.resize(size,0);\n    p.resize(size,0);\n    v.resize(size);\n    for(int i=0;i<size;i++){\n      r[i]=1,p[i]=i;\n      v[i].resize(1,i);\n    }\n  }\n  bool same(int x,int y){\n    return p[x]==p[y];\n  }\n  void unite(int x,int y){\n    x=p[x];y=p[y];\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    for(int i=0;i<(int)v[y].size();i++){\n      p[v[y][i]]=x;\n      v[x].push_back(v[y][i]);\n    }\n    v[y].clear();\n  }\n};\nsigned main(){\n  int n;\n  cin>>n;\n  vector<int> a(n);\n  for(int i=0;i<n;i++) cin>>a[i];\n  vector<int> b(a);\n  sort(b.begin(),b.end());\n  map<int,int> p,q;\n  for(int i=0;i<n;i++){\n    p[a[i]]=i;\n    q[b[i]]=i;\n  }\n  QuickFind qf(n);\n  for(int i=0;i<n;i++) \n    qf.unite(i,p[b[i]]);\n  //for(int i=0;i<n;i++) cout<<i<<\" \"<<p[b[i]]<<endl;\n  int ans=0;\n  for(int i=0;i<n;i++){\n    int k=qf.v[i].size();\n    if(qf.p[i]!=i||k==1) continue;\n    int m=a[qf.v[i][0]];\n    int tmp=0;\n    for(int j=0;j<k;j++){\n      //cout<<\" \"<<a[qf.v[i][j]];\n      tmp+=a[qf.v[i][j]];\n      m=min(m,a[qf.v[i][j]]);\n    }\n    //cout<<endl;\n    ans+=min(tmp+m*(k-2),tmp+(m+b[0])*2+b[0]*(k-2));\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint minimumCostSort(int *W, int n) {\n  int X[1000], R[1000];\n  for (int i = 0; i < n; i++) {\n    X[i] = W[i];\n  }\n  sort(X, X + n);\n  for (int i = 0; i < n; i++) R[X[i]] = i;\n  int m = X[0];\n  int sum = 0;\n\n  for (int i = 0; i < n; i++) {\n    int cur = i;\n    if (X[cur] == -1) continue;\n    int s = 0;\n    int mm = 10000;\n    int nn = 0;\n    int v;\n    while (true) {\n      nn++;\n      X[cur] = -1;\n      v = W[cur];\n      mm = min(v, mm);\n      s += v;\n      cur = R[v];\n      if (X[cur] == -1) break;\n    }\n    sum += min(s + (nn - 2) * mm, s + mm + (nn + 1) * m);\n  }\n\n  return sum;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  int W[1000];\n\n  cin >> n;\n\n  for (int i = 0; i < n; i++) {\n    cin >> W[i];\n  }\n\n  int c = minimumCostSort(W, n);\n\n  cout << c << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll =long long;\nusing db = double;\n\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\n\n#define che(a,string) cout<<\"//\"<<string <<\"==\"<<(a)<<\"//\" <<endl;\n#define SORT(a) sort((a).begin(),(a).end())\n#define rSORT(a) reverse((a).begin(),(a).end())\n#define For(i, a, b)    for(int i = (a) ; i < (b) ; ++i)\n#define rep(i, n)       For(i, 0, n)\nbool IsInt(double a){int b = a/1;if(a==b){return true;}else {return false;}}\nconst int mod = 1e9 + 7;\n\n//ここから書き始める\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve()\n{\n\tint ans = 0;\n\n\tbool V[MAX];\n\trep(i,n){\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B,B+n);\n\trep(i,n)\n\t\tT[B[i]]= i ;\n\trep(i,n){\n\t\tif (V[i]) continue;\n\n\t\tint cur = i ;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile(1){\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v =A[cur];\n\t\t\tm = min(m,v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif( V[cur] ) break;\n\t\t}\n\t\tans += min(S + (an - 2 )*m, m + S+(an + 1 ) * s);\n\t}\n\treturn ans;\n}\n\nint main ()\n{\n\tcin >> n;\n\ts = VMAX;\n\trep(i,n){\n\t\tcin >> A[i];\n\t\ts = min(s,A[i]);\n\t}\n\tint ans = solve();\n\tcout << ans << endl; \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\n\nint partition(int *A,int p,int r)\n{\n\tint j,x,temp;\n\n\tx = A[r];\n\tj = p-1;\n\n\tfor(int i = p; i < r; i++)\n\t{\n\t\tif (A[i] <= x)\n\t\t{\n\t\t\tj++;\n\t\t\ttemp = A[i];\n\t\t\tA[i] = A[j];\n\t\t\tA[j] = temp;\n\t\t}\n\t}\n\n\ttemp = A[j+1];\n\tA[j+1] = A[r];\n\tA[r] = temp;\n\n\treturn j+1;\n}\n\nvoid quicksort(int *A,int p,int r)\n{\n\tint q;\n\n\tif (p < r)\n\t{\n\t\tq = partition(A,p,r);\n\t\tquicksort(A,p,q-1);\n\t\tquicksort(A,q+1,r);\n\t}\n}\n\nint main()\n{\n\tbool check;\n\tint n,a[1000] = {0},b[1000] = {0};\n\tint sum1 = 0,sum2 = 0,pivot = 0,pivot1 = 0,pivot2= 0,min = 0,start,temp,k;\n\n\tscanf(\"%d\", &n);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\tb[i] = a[i];\n\t}\n\n\tquicksort(b,0,n-1);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (a[i] != b[i])\n\t\t{\n\t\t\tfor(int j = i+1; j < n; j++)\n\t\t\t{\n\t\t\t\tif (b[j] == a[i] && b[i] == a[j])\n\t\t\t\t{\n\t\t\t\t\ttemp = a[i];\n\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\ta[j] = temp;\n\t\t\t\t\tsum1 += a[i] + a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//cout << \"sum=\" << sum1 << endl;\n\n\tsum2 = sum1;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (a[i] != b[i])\n\t\t{\n\t\t\tif (i == 0)\n\t\t\t{\n\t\t\t\tcheck = true;\n\t\t\t}\n\n\t\t\tstart = i;\n\t\t\tmin = a[i];\n\n\t\t\tfor(int j = i+1; j < n; j++)\n\t\t\t{\n\t\t\t\tif (min > a[j])\n\t\t\t\t{\n\t\t\t\t\tmin = a[j];\n\t\t\t\t\tpivot = j;\n\t\t\t\t\tpivot1 = pivot;\n\t\t\t\t\tpivot2 = pivot;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i == n-1)\n\t\t{\n\t\t\tprintf(\"%d\\n\", sum1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t\n\n\tfor(int i = 0; i < n - start; i++)\n\t{\n\t\tk = start;\n\n\t\t\n\t\twhile(1)\n\t\t{\n\t\t\tif (b[pivot1] == a[k])\n\t\t\t{\n\t\t\t\ttemp = a[pivot1];\n\t\t\t\ta[pivot1] = a[k];\n\t\t\t\ta[k] = temp;\n\n\t\t\t\tsum1 += a[pivot1] + a[k];\n\t\t\t\tpivot1 = k;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t}\n\n\t//cout <<\"ok\";\n\n\tif (!check)\n\t{\n\t\ttemp = a[pivot2];\n\t\ta[pivot2] = a[0];\n\t\ta[0] = temp;\n\n\t\tfor(int i = 1; i < n - start; i++)\n\t\t{\n\t\t\tint j = start;\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif (b[pivot2] == a[j])\n\t\t\t\t{\n\t\t\t\t\ttemp = a[pivot2];\n\t\t\t\t\ta[pivot2] = a[j];\n\t\t\t\t\ta[j] = temp;\n\n\t\t\t\t\tsum2 += a[pivot2] + a[j];\n\t\t\t\t\tpivot2 = j;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif (sum1 < sum2)\n\t{\n\t\tprintf(\"%d\\n\", sum1);\n\t}else\n\t{\n\t\tprintf(\"%d\\n\", sum2);\n\t}\n\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid doc(){\n    freopen(\"OB.inp\",\"r\", stdin);\n    freopen(\"OB.out\",\"w\", stdout);\n}\n\ntypedef pair<int, int> ii;\n\nvoid solve(){\n    int n;\n    cin >> n;\n    int a[n + 1], d[(int)1e5], b[n + 1];\n    for(int i = 1; i <= n; i++){\n        cin >> a[i];\n        d[a[i]] = i;\n        b[i] = a[i];\n       // cout << a[i] << \" \" << i << \" \" << d[10] << '\\n';\n    }\n\n    bool KT[n + 1];\n    memset(KT, true, sizeof(KT));\n    sort(b + 1, b + n + 1);\n    int res = 0;\n   // cerr << \"PK\";\n    for(int i = 1; i <= n; i++){\n        int cnt = 0, sum = 0, m = 1e5, t = i;\n        while(KT[t]){\n            m = min(m, a[t]);\n            sum += a[t];\n            cnt++;\n            KT[t] = false;\n           // cout << t << \" \";\n            t = d[b[t]];\n           // cout << t << \"*\" << '\\n';\n        }\n\n        if (cnt >= 2) res += min(sum + m + b[1] * (cnt + 1), sum + m * (cnt - 2));\n        // cout << sum << \" \" << m << \" \" << cnt << \" \" <<  sum + m + b[0] * (cnt + 1) << '\\n';\n    }\n    cout << res << '\\n';\n}\n\nint main(){\n//    ios_base::sync_with_stdio(0);cin.tie(nullptr);cout.tie(nullptr);\n //   doc();\n\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\nusing namespace std;\n\n#define MAX_NUM 1000\n\nint W[MAX_NUM];\nint N;\n\nint Compare(const void *a, const void *b)\n{\n    return *(int*)a - *(int*)b;\n}\n\nvoid Swap(int idx1, int idx2) {\n\tint tmp = W[idx1];\n\tW[idx1] = W[idx2];\n\tW[idx2] = tmp;\n}\n\nint SearchIdx(int wi)\n{\t\n\tfor (int i = 0; i < N; i++) {\n\t\tif (W[i] == wi) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid Copy(int *ary)\n{\n\tfor (int i = 0; i < N; i++) {\n\t\tary[i] = W[i];\n\t}\n}\n\nint main(void)\n{\n\t//input\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> W[i];\n\t}\n\n\t//minimum cost?\n\tint cost = 0;\n\tint w2[MAX_NUM];\n\tCopy(w2);\n\tqsort(w2, N, sizeof(int), Compare);\n\n\tfor (int i = 0; i < N; i++) {\n\t\tint local_cost = 0;\n\t\tint local_change_num = 0;\n\t\tint idx1 = SearchIdx(w2[i]);\n\t\twhile (idx1 != i) {\n\t\t\tint idx2 = SearchIdx(w2[idx1]);\n\t\t\tSwap(idx1, idx2);\n\t\t\tlocal_cost = local_cost + W[idx1] + W[idx2];\n\t\t\tlocal_change_num++;\n\t\t\tidx1 = idx2;\n\t\t}\n\t\tif (w2[i] * local_change_num > w2[0] * local_change_num + (w2[i] + w2[0]) * 2) {\n\t\t\tlocal_cost -= (w2[i] * local_change_num) - (w2[0] * local_change_num + (w2[i] + w2[0]) * 2);\n\t\t}\n\t\tcost += local_cost;\n\t}\n\n\t//output\n\tcout << cost << \"\\n\";\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstatic const int N_MAX=1000;\nstatic const int W_MAX=10000;\n\nint n; //??°???\nint A[N_MAX],B[N_MAX]; //A?????±?????°??????B?????????????\\?????????°???\nint s;//s?????¨?????°??????????°????\nint T[W_MAX+1]; //??\\??°????????????????\\?????????°???????????????\n\nint solve()\n{\n    int ans=0; //?????¬???\n    bool V[N_MAX]; //???????¢??????????\n    for(int i=0;i<n;i++)\n    {\n        B[i]=A[i]; //?????°????????¶??????\n        V[i]=false; //????§????\n    }\n    sort(B,B+n); //??????\n    for(int i=0;i<n;i++) T[B[i]]=i; //????§???????????????????????\\?????????°????????????\n    for(int i=0;i<n;i++)\n    {\n        if(V[i]) continue; //???????¢??????????????????????\n        int cur=i; //????????????\n        int S=0; //S??°???????????????????????????????????????\n        int m=W_MAX; //m?????¨?????°?????\\??????????????????????°????\n        int an=0; //an?????????????´???°???\n        while(1) //????§???????\n        {\n            V[cur]=true; //????§??????°\n            an++; //??°?????????\n            int v=A[cur]; //v?????????????????????\n            m=min(m,v); //??°????????????????°????\n            S+=v; //??\\???????????????????????????????????????????????????\n            cur=T[v]; //??????????????????????????????????????°???????????????\n            if(V[cur]) break; //????????????????????????????¢??????????????????\\?????????????????????????????¨??¨?¢???????\n        }\n        ans+=min(S+(an-2)*m,m+S+(an+1)*s);\n    }\n    return ans;\n}\nint main()\n{\n    cin>>n;\n    s=W_MAX;\n    for(int i=0;i<n;i++)\n    {\n        cin>>A[i];\n        s=min(s,A[i]);\n    }\n    cout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int INF = 1000000;\n\nint partition(int *A,int p,int r)\n{\n\tint j,x,temp;\n\n\tx = A[r];\n\tj = p-1;\n\n\tfor(int i = p; i < r; i++)\n\t{\n\t\tif (A[i] <= x)\n\t\t{\n\t\t\tj++;\n\t\t\ttemp = A[i];\n\t\t\tA[i] = A[j];\n\t\t\tA[j] = temp;\n\t\t}\n\t}\n\n\ttemp = A[j+1];\n\tA[j+1] = A[r];\n\tA[r] = temp;\n\n\treturn j+1;\n}\n\nvoid quicksort(int *A,int p,int r)\n{\n\tint q;\n\n\tif (p < r)\n\t{\n\t\tq = partition(A,p,r);\n\t\tquicksort(A,p,q-1);\n\t\tquicksort(A,q+1,r);\n\t}\n}\n\nint solve_swap(int *a,int *b,int n)\n{\n\tint sum,temp;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (a[i] != b[i])\n\t\t{\n\t\t\tfor(int j = i+1; j < n; j++)\n\t\t\t{\n\t\t\t\tif (b[j] == a[i] && b[i] == a[j])\n\t\t\t\t{\n\t\t\t\t\ttemp = a[i];\n\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\ta[j] = temp;\n\n\t\t\t\t\tsum += a[i] + a[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n\nint solve1(int *a,int *b,int n)\n{\n\tbool check;\n\tint min,num,temp,sum,start;\n\tint cnt=0;\n\n\tsum = 0;\n\tstart = 0;\n\n\twhile(1)\n\t{\n\t\tmin = INF;\n\t\tcnt++;\n\t\tcheck = true;\n\n\t\t//printf(\"start = %d\\n\", start);\n\n\t\tfor(int i = start; i < n; i++)\n\t\t{\n\t\t\tif (min > a[i] && a[i] != b[i])\n\t\t\t{\n\t\t\t\tnum = i;\n\t\t\t\tmin = a[num];\n\t\t\t}\n\t\t}\n\n\t\t//printf(\"num = %d\\n\", num);\n\t\t//printf(\"min = %d\\n\", min);\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (a[i] == b[num])\n\t\t\t{\n\t\t\t\t//printf(\"%d and %d are swapped\\n\", a[num],a[i]);\n\t\t\t\tsum += a[num] + a[i];\n\t\t\t\ttemp = a[i];\n\t\t\t\ta[i] = min; // min = a[num]\n\t\t\t\ta[num] = temp;\n\t\t\t\tnum = i;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (a[i] != b[i])\n\t\t\t{\n\t\t\t\tcheck = false;\n\t\t\t\tstart = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\t//printf(\"a[i] = %d\\n\", a[i]);\n\t\t}\n\n\t\tif (check)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cnt ==10)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn sum;\n}\n\nbool check(int *A,int *B,int n)\n{\n\tbool c = true;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (A[i] != B[i])\n\t\t{\n\t\t\tc = false;\n\t\t}\n\t}\n\n\treturn c;\n}\n\nint main()\n{\n\tint n,a[1000] = {0},b[1000] = {0},a2[1000] = {0};\n\tint sum1 = 0,sum2 = 0,pivot = 0,pivot1 = 0,pivot2= 0,min = 0,start,temp,k;\n\n\tscanf(\"%d\", &n);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\tb[i] = a[i];\n\t}\n\n\tquicksort(b,0,n-1);\n\n\tsum1 = solve_swap(a,b,n);\n\n\t//printf(\"sum = %d\\n\", sum1);\n\n\t\n\tif (check(a,b,n))\n\t{\n\t\tprintf(\"%d\\n\", sum1);\n\t\treturn 0;\n\t}\n\n\n\tsum2 = sum1;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\ta2[i] = a[i];\n\t}\n\n\t//printf(\"\\nhere is sum1\\n\");\n\n\tsum1 += solve1(a,b,n);\n\n\t//printf(\"sum1 = %d\\n\",sum1);\n\n\n\tif (check(a,b,n))\n\t{\n\t\tprintf(\"%d\\n\", sum1);\n\t\treturn 0;\n\t}\n\n\n\n\tfor(int i = 1; i < n - start; i++)\n\t{\n\t\tk = start;\n\n\t\t\n\t\twhile(1)\n\t\t{\n\t\t\tif (b[pivot1] == a[k])\n\t\t\t{\n\t\t\t\tprintf(\"%d and %d are swapped\\n\", a[pivot1],a[k]);\n\t\t\t\ttemp = a[pivot1];\n\t\t\t\ta[pivot1] = a[k];\n\t\t\t\ta[k] = temp;\n\n\t\t\t\tsum1 += a[pivot1] + a[k];\n\t\t\t\tpivot1 = k;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tprintf(\"%d \", a[i]);\n\t\t}\n\t\tcout << endl;\n\t}\n\n\n\tif (!check(a,b,n))\n\t{\n\t\tprintf(\"\\nhere is sum2\\n\");\n\t\ttemp = a2[pivot2];\n\t\ta2[pivot2] = a2[0];\n\t\ta2[0] = temp;\n\n\t\tfor(int i = 1; i < n - start; i++)\n\t\t{\n\t\t\tint j = start;\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif (b[pivot2] == a2[j])\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d and %d are swapped\\n\", a2[pivot2],a2[j]);\n\t\t\t\t\ttemp = a2[pivot2];\n\t\t\t\t\ta2[pivot2] = a2[j];\n\t\t\t\t\ta2[j] = temp;\n\n\t\t\t\t\tsum2 += a2[pivot2] + a2[j];\n\t\t\t\t\tpivot2 = j;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tprintf(\"%d \", a2[i]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\n\t\tif (sum1 < sum2)\n\t\t{\n\t\t\tprintf(\"sum1 = %d\\n\", sum1);\n\t\t}else\n\t\t{\n\t\t\tprintf(\"sum2 = %d\\n\", sum2);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\n\tprintf(\"%d\\n\", sum1);\n\t\n\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n\tint n, cost = 0;\n\tcin >> n;\n\tint a[n], b[n];\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tb[i] = a[i];\n\t}\n\tsort(b, b + n);\n\n\tint mini = 0;\n\twhile (mini < n) {\n\t\tint ai, bi;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (a[i] == b[mini]) {\n\t\t\t\tai = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (a[i] == b[ai]) {\n\t\t\t\tbi = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ai != bi) {\n\t\t\tcost += a[ai] + a[bi];\n\t\t\tswap(a[ai], a[bi]);\n\t\t}\n\t\telse {\n\t\t\tmini++;\n\t\t}\n\t}\n\n\tcout << cost << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve() {\n    int ans = 0;\n    \n    bool V[MAX];\n    for (int i = 0; i < n; i++) {\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B, B + n);\n    for (int i = 0; i < n; i++) T[B[i]] = i;\n    for (int i = 0; i < n; i++) {\n        if (V[i]) continue;\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while (1) {\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m, v);\n            S += v;\n            cur = T[v];\n            if (V[cur]) break;\n        }\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n    }\n    return ans;\n}\n\nint main() {\n    cin >> n;\n    s = VMAX;\n    for (int i = 0; i < n; i++) {\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n    int ans = solve();\n    cout << ans << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\n\nusing namespace std;\n\ntypedef long long LL;\n\nint INF = (1 << 14);\ntypedef vector<int> VI;\n\ntemplate<typename T>\nostream& operator << (ostream& os, const vector<T>& vec) {\n    os << \"[ \";\n    REP(i, vec.size()) {\n        os << vec[i] << \" \";\n    }\n    os << \"]\";\n\n    return os;\n}\n\nvoid print(int* A, int n) {\n    REP(i, n) {\n        if (i > 0) cout << \" \";\n        cout << A[i];\n    }\n    cout << endl;\n}\n\nint partition(VI &A, int p, int r) {\n    int pivot = A[r];\n    int i = p - 1;\n\n    FOR(j, p, r) {\n        if(A[j] <= pivot) {\n            ++i;\n            swap(A[i], A[j]);\n        }\n    }\n    swap(A[++i], A[r]);\n\n    return i;\n}\n\nvoid quickSort(VI &A, int p, int r) {\n    if (p < r) {\n        int q = partition(A, p, r);\n        quickSort(A, p, q-1);\n        quickSort(A, q + 1, r);\n    }\n}\n\nbool check_index_in_groups(vector<VI> A, int index) {\n    bool ret = false;\n    REP(i, A.size()) {\n        if (find(A[i].begin(), A[i].end(), index) != A[i].end()) {\n            ret = true;\n            break;\n        }\n    }\n\n    return ret;\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n\n    VI A(n);\n    REP(i, n) cin >> A[i];\n\n    VI S(A);\n    quickSort(S, 0, n - 1);\n//    cout << A << endl << S << endl;\n\n    // extract groups\n    int i = 0;\n    vector<VI> groups;\n    REP(i, A.size()) {\n        if (A[i] == S[i]) continue;\n\n        // continue if current index is already added to a group.\n        if (check_index_in_groups(groups, i)) continue;\n\n        VI group = {i};\n\n        int index = i;\n        while (true) {\n            REP(j, A.size()) {\n                if (A[index] == S[j]) {\n                    index = j;\n                    break;\n                }\n            }\n            if (index == i) break;\n            group.push_back(index);\n        }\n\n        groups.push_back(group);\n    }\n\n    // get min values for all groups\n    vector<pair<int, int>> mins(groups.size());\n    VI sums(groups.size());\n    REP(i, groups.size()) {\n        int m1 = INF, m2 = INF;\n        int s = 0;\n        VI g = groups[i];\n        REP(j, A.size()) {\n            if (find(g.begin(), g.end(), j) != g.end()) {\n                m1 = min(m1, A[j]);\n                s += A[j];\n            } else {\n                m2 = min(m2, A[j]);\n            }\n        }\n\n        mins[i] = make_pair(m1, m2);\n        sums[i] = s;\n    }\n\n//    REP(i, groups.size()) {\n//        cout << groups[i] << endl << sums[i] << \" \" << mins[i].first << \" \" << mins[i].second << endl;\n//    }\n\n    // cost\n    int cost = 0;\n    REP(i, groups.size()) {\n        pair<int, int> m = mins[i];\n        int n = groups[i].size();\n        int s = sums[i];\n\n        cost += min(m.first * (n - 2) + s, m.second * (n + 1) + s + m.first);\n    }\n\n    cout << cost << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstatic const int W_MAX = 10000;\n\nint min_all = W_MAX;\n\nint solve(int weight[], int n)\n{\n    int ans = 0;\n\n    /* 準備 */\n    int sorted_array[n]; // 元の配列をソートした配列を別途用意\n    bool is_used[n]; // 各要素が使われたかどうか\n    int point[W_MAX + 1]; // 元の配列の各要素の行き先(添え字)を表す\n    for(int i = 0; i < n; i++) // 初期化\n    {\n        sorted_array[i] = weight[i];\n        is_used[i] = false;\n    }\n    sort(sorted_array, sorted_array + n);\n    for(int i = 0; i < n; i++)\n    {\n        point[sorted_array[i]] = i;\n    }\n\n    /* 各要素に対しサイクルを求める */\n    for(int i = 0; i < n; i++)\n    {\n        if(!is_used[i]) // 未使用である要素だけサイクルを調べる\n        {\n            int sum_cycle = 0; // サイクル内の重みの総和\n            int min_cycle = W_MAX; // サイクル内の重みの最小値\n            int size_cycle = 0; // サイクル内の要素数\n            int current = i; // 現在の要素のindex\n\n            /* サイクル開始(1.と2.を繰り返し，3.で終了) */\n            while(true)\n            {\n                is_used[current] = true; // 1.現在の要素を使用するので二度とこないようにtrueに\n                size_cycle++;\n                int w = weight[current]; // 1.現在の要素の重みを調べる\n                sum_cycle += w;\n                min_cycle = min(min_cycle, w);\n                current = point[w]; // 2.現在の要素の重みの行き先へ移動\n                if(is_used[current]) // 3.元に戻ってきたらloopを抜ける(サイクル完了)\n                    break;\n            }\n            ans += min(sum_cycle + (size_cycle - 2) * min_cycle,\n                    sum_cycle + min_cycle + (size_cycle + 1) * min_all);\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    int weight[n];\n    for(int i = 0; i < n; i++)\n    {\n        cin >> weight[i];\n        min_all = min(min_all, weight[i]);\n    }\n    cout << solve(weight, n) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nstruct unionfind\n{\n\t//rankのオーバーフローに注意\n\tvector<int> par, rank;\n\tunionfind(int n)\n\t{\n\t\tpar.resize(n);\n\t\trank.resize(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 1;\n\t\t}\n\t}\n\n\tbool same(int u, int v)\n\t{\n\t\treturn root(u) == root(v);\n\t}\n\n\tvoid unite(int u, int v)\n\t{\n\t\tif (same(u, v)) return;\n\t\tu = root(u), v = root(v);\n\t\tif (rank[u] > rank[v]) swap(u, v);\n\t\tpar[u] = v;\n\t\trank[v] += rank[u];\n\t}\n\n\tint root(int v)\n\t{\n\t\tif (par[v] == v) return v;\n\t\treturn par[v] = root(par[v]);\n\t}\n};\n\nvoid solve()\n{\n\tint N;\n\tcin >> N;\n\tvector<int> ws(N), cs(N);\n\tset<int> s;\n\tmap<int, int> mp;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> ws[i];\n\t\ts.insert(ws[i]);\n\t}\n\tint cnt = 0;\n\tfor (int v : s)\n\t{\n\t\tmp[v] = cnt++;\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcs[i] = mp[ws[i]];\n\t}\n\n\tunionfind uf(N);\n\tvector<int> es[N];\n\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tuf.unite(i, cs[i]);\n\t}\n\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tes[uf.root(cs[i])].push_back(cs[i]);\n\t}\n\n\tint ans = 0;\n\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tauto e = es[i];\n\t\tint n = e.size();\n\t\tif (n < 2) continue;\n\t\tfor (int v : e)\n\t\t{\n\t\t\tans += ws[v];\n\t\t}\n\t\tans += (n-2) * ws[*min_element(e.begin(), e.end())];\n\t}\n\n\tcout << ans << endl;\n\n}\n\nint main(void)\n{\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef vector<lli> vll;\n\nlli n;\nvll w;\nvll w_;\nlli ans = 0;\n\nint main(){\n\tcin >> n;\n\tw = vll(n);\n\tfor(lli i = 0;i < n;i++) cin >> w[i];\n\tw_ = w;\n\tsort(w.begin(),w.end());\n\tfor(lli i = 0;i < n;i++){\n\t\tif(w[i] != w_[i]) ans += w_[i];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint cmp(const int n1, const int n2) {\n\treturn n1 < n2;\n}\n\nint main() {\n\tint n;\n\tint ary[1000];\n\tint sortAry[1000];\n\tint cost = 0;\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint temp;\n\t\tcin >> temp;\n\t\tary[i] = sortAry[i] = temp;\n\t}\n\n\tsort(sortAry, sortAry + n);\n\n\twhile (true) {\n\t\tint c = 100000;\n\t\tint index = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (ary[i] < sortAry[i]) {\n\t\t\t\tif (c > ary[i] + sortAry[i]) {\n\t\t\t\t\tc = ary[i] + sortAry[i];\n\t\t\t\t\tindex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (index < 0)break;\n\t\tcost += c;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (ary[i] == sortAry[index]) {\n\t\t\t\tswap(ary[i], ary[index]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << cost << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\n#define MAX 100005\n#define INF INT_MAX\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint main(int, char**)\n{\n    int n;\n    cin >> n;\n\n    vector<P> w;\n    int tmp;\n    rep(i,n) {\n        cin >> tmp;\n        w.emplace_back(tmp, i);\n    }\n    sort(w.begin(), w.end());\n\n    vector<bool> used(n, false);\n    vector< vector<P> > loops; // 巡回群のリスト\n    rep(i,n) {\n        if (used[i]) continue;\n        int now = i;\n        vector<P> lp;\n        while (!used[now]) {\n            lp.push_back(w[now]);\n            used[now] = true;\n            now = w[now].second;\n        }\n        loops.push_back(lp);\n    }\n    int wmin = (*min_element(w.begin(), w.end())).first;\n    int cost = 0;\n    for (auto l : loops) {\n        int lmin = (*min_element(l.begin(), l.end())).first;\n        int sum = accumulate(l.begin(), l.end(), 0,[] (int a, P b) { return a + b.first; });\n        int c1 = (sum-lmin) + lmin * (l.size()-1);    // 巡回群そのままのコスト\n        int c2 = (sum-lmin) + wmin * (l.size()-1) + (lmin+wmin) * 2; // wminを使った場合のコスト\n        cost += min(c1, c2);\n    }\n\n    cout << cost << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main(void) {\n\tint num;\n\tcin >> num;\n\tvector<int> a(num);\n\tvector<int> sorted(num);\n\tvector<int> pos(num);\n\tvector<int> order(num);\n\tint cost = 0;\n\n\tfor (int i = 0; i < num; i++) {\n\t\tcin >> a[i];\n\t}\n\n\tfor (int i = 0; i < num; i++)\n\t\tsorted[i] = a[i];\n\tsort(sorted.begin(), sorted.begin() + num);\n\tfor (int i = 0; i < num; i++)\n\t\tpos[sorted[i]] = i;\n\n\tfor (int i = 0; i < num; i++) {\n\t\tint x = order[0] = i;\n\t\tint minn = 1000;\n\t\tint start = 0;\n\n\t\tif (i == pos[a[i]])\n\t\t\tcontinue;\n\n\t\tfor (int j = 1;; j++) {\n\t\t\tx = pos[a[x]];\n\t\t\tif (x == i)\n\t\t\t\tbreak;\n\t\t\tif (a[x] < minn) {\n\t\t\t\tminn = a[x];\n\t\t\t\tstart = j;\n\t\t\t}\n\t\t\torder[j] = x;\n\t\t}\n\n\t\tfor (int j = start - 1; j >= 0; j--) {\n\t\t\tcost += (minn + a[order[j]]);\n\t\t\ta[order[j + 1]] = a[order[j]];\n\t\t\ta[order[j]] = minn;\n\t\t}\n\t}\n\n\tcout << cost << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn=10000+5;\nconst int minn=1000+5;\nconst int inf=2e9+2;\nint n,a[minn],po[maxn];\nvoid solve()\n{\n\n    sort(a+1,a+n+1);\n    int f=0,tp=inf,t=0,tmin=a[1];\n    ll w=0,ans=0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if(po[a[i]]==i){continue;}\n        tp=inf;t=1;w=0;\n        int f=po[a[i]];\n        w+=a[i];\n        tp=a[i];\n        while(f!=i)\n        {\n            t++;tp=min(a[f],tp);\n            w+=a[f];\n            int tm=f;\n            f=po[a[f]];\n            po[a[tm]]=tm;\n        }\n        ans+=min(w+(t-2)*tp,w+tp+(t+1)*tmin);\n    }\n    printf(\"%lld\\n\",ans);\n}\nint main()\n{\n    scanf(\"%d\",&n);\n\tfor (int i = 1; i <= n; ++i)\n    {\n        scanf(\"%d\",&a[i]);\n        po[a[i]]=i;\n    }\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint solve(){\n\n  int i, ans = 0;\n  bool V[MAX];\n\n  for (i=0; i<n; i++){\n    B[i] = A[i];\n    V[i] = false;\n  }\n\n  sort(B, B+n);\n\n  for (i=0; i<n; i++) T[B[i]] = i;\n\n  for (i=0; i<n; i++){\n    if (V[i]) continue;\n    int an = 0;\n    int S = 0;\n    int cur = i;\n    int m = VMAX;\n    while (1){\n      V[cur] = true;\n      an++;\n      int v = A[cur];\n      S += v;\n      m = min(m, v);\n      cur = T[v];\n      if (V[cur]) break;\n    }\n    ans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n  }\n  return ans;\n}\n\nint main(){\n  s = VMAX;\n  cin >> n;\n\n  for (int i=0; i<n; i++){\n    cin >> A[i];\n    s = min(s, A[i]);\n  }\n\n  int ans = solve();\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<list>\nusing namespace std;\n\ntypedef pair<long long,long long> logg;\n\nint main()\n{\n\tint n,j=1;cin>>n;\n\tint a[1010];\n\tlogg c[1010];\n\tfor(int i=1;i<=n;cin>>a[i++]);a[n+1]==1;\n\tfor(int i=1,m=0;;)\n\t{\n\t\tif(a[i]!=0)\n\t\t{\n\t\t\tc[j].first++;\n\t\t\tc[j].second+=a[i];\n\t\t\tif(a[i]>m)m=a[i];\n\t\t\tint l=a[i];\n\t\t\ta[i]=0;\n\t\t\ti=l;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(c[j].first==1)\n\t\t\t{\n\t\t\t\tc[j].second=0;\n\t\t\t}\n\t\t\telse if(c[j].first>=3)\n\t\t\t{\n\t\t\t\tc[j].second-=m;\n\t\t\t\tc[j].second*=2;\n\t\t\t}\n\t\t\tm=0;\n\t\t\tj++;\n\t\t\tint s=0;\n\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t{\n\t\t\t\ts+=a[k];\n\t\t\t\tif(a[k]!=0)i=k;\n\t\t\t}\n\t\t\tif(s==0)break;\n\t\t}\n\t}\n\tlong long s=0;\n\tfor(int i=1;i<=j;i++)\n\t{\n\t\ts+=c[i].second;\n\t}\n\tcout<<s<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nstruct Mono {\n\tint num, order;\n\tbool check = 0;\n};\n\nvoid merge(Mono*, int, int, int);\nvoid mergesort(Mono*, int, int);\n\nint main()\n{\n\tint n, tmp, cnt = 0, sum = 0;\n\tMono *w;\n\tvector<Mono> vvm[500];\n\n\tscanf(\"%d\", &n);\n\tw = new Mono[n];\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &w[i].num);\n\t\tw[i].order = i;\n\t}\n\n\tmergesort(w, 0, n);\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tif (!w[i].check)\n\t\t{\n\t\t\ttmp = i;\n\t\t\twhile (!w[tmp].check)\n\t\t\t{\n\t\t\t\tw[tmp].check = true;\n\t\t\t\tif (w[tmp].order == tmp)\n\t\t\t\t\tbreak;\n\t\t\t\tvvm[cnt].push_back(w[tmp]);\n\t\t\t\ttmp = w[tmp].order;\n\t\t\t}\n\t\t\tif (vvm[cnt].size())\n\t\t\t\tcnt++;\n\t\t}\n\n\tfor (int i = 0; i < cnt; i++)\n\t{\n\t\tfor (int j = 1; j < vvm[i].size(); j++)\n\t\t\tsum += vvm[i][j].num;\n\t\tif (w[0].num * (vvm[i].size() + 1) + vvm[i][0].num * 2 > vvm[i][0].num * (vvm[i].size() - 1))\n\t\t\tsum += vvm[i][0].num * (vvm[i].size() - 1);\n\t\telse\n\t\t\tsum += w[0].num * (vvm[i].size() + 1) + vvm[i][0].num * 2;\n\t}\n\tprintf(\"%d\\n\", sum);\n\tdelete[] w;\n\n\treturn 0;\n}\n\nvoid merge(Mono *a, int left, int mid, int right)\n{\n\tint n1, n2, i = 0, j = 0;\n\tMono *l, *r;\n\tn1 = mid - left;\n\tn2 = right - mid;\n\tl = new Mono[n1 + 1];\n\tr = new Mono[n2 + 1];\n\n\tfor (int i = 0; i < n1; i++)\n\t\tl[i] = a[left + i];\n\tfor (int i = 0; i < n2; i++)\n\t\tr[i] = a[mid + i];\n\tl[n1].num = r[n2].num = 20000000;\n\n\tfor (int k = left; k < right; k++)\n\t{\n\t\tif (l[i].num <= r[j].num)\n\t\t{\n\t\t\ta[k] = l[i];\n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ta[k] = r[j];\n\t\t\tj++;\n\t\t}\n\t}\n\tdelete[] l;\n\tdelete[] r;\n\treturn;\n}\n\nvoid mergesort(Mono *a, int left, int right)\n{\n\tif (left + 1 < right)\n\t{\n\t\tint mid;\n\t\tmid = (left + right) / 2;\n\t\tmergesort(a, left, mid);\n\t\tmergesort(a, mid, right);\n\t\tmerge(a, left, mid, right);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\n#define MAX 100000\n\nbool cmp(const int n1, const int n2) {\n\treturn n1 < n2;\n}\n\nstruct Data {\n\tint num;\n\tint i;\n};\n\nint main() {\n\tint n;\n\tint minValue = MAX;\n\tint sortAry[1000];\n\tData ary[1000];\n\tvector<vector<int>> groups;\n\tint cost = 0;\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint temp;\n\t\tcin >> temp;\n\t\tsortAry[i] = ary[i].num = temp;\n\t\tminValue = min(minValue, temp);\n\t}\n\n\tsort(sortAry, sortAry + n, cmp);\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (ary[i].num == sortAry[j]) {\n\t\t\t\tary[i].i = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tvector<int> group;\n\t\tint j = i;\n\t\tint s = i;\n\t\twhile (j != ary[j].i) {\n\t\t\tgroup.push_back(ary[j].num);\n\n\t\t\tint temp = ary[j].i;\n\t\t\tary[j].i = j;\n\t\t\tj = temp;\n\t\t}\n\t\tif (!group.empty()) {\n\t\t\tgroups.push_back(group);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < groups.size(); i++) {\n\t\tint sum = 0;\n\t\tint m = MAX;\n\t\tint num = groups[i].size();\n\n\t\tfor (int j = 0; j < num; j++) {\n\t\t\tsum += groups[i][j];\n\t\t\tm = min(groups[i][j], m);\n\t\t}\n\n\t\tint c1, c2;\n\t\tc1 = sum + (num - 2) * m;\n\t\tc2 = sum + (num + 1) * minValue + m;\n\t\tcost += min(c1, c2);\n\t}\n\n\tcout << cost << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int MAXN = 1010;\nint w[MAXN];\nbool done[MAXN];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, mini = 100000;\n    cin >> n;\n    map<int, int> mp;\n    for (int i = 0; i < n; i++) {\n        cin >> w[i];\n        mp[w[i]] = 0;\n        mini = min(mini, w[i]);\n    }\n    {\n        int k = 0;\n        for (auto& p : mp) p.second = k++;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (done[i]) continue;\n        int cnt = 0, now = i, mi = 100000, sum = 0;\n        while (1) {\n            if (done[now]) break;\n            cnt++;\n            done[now] = true;\n            mi = min(mi, w[now]);\n            sum += w[now];\n            now = mp[w[now]];\n        }\n        int tmp = sum+(cnt-2)*mi;\n        tmp = min(tmp, sum+mi+mini*(cnt+1));\n        ans += tmp;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <climits>\nusing namespace  std;\n\nstruct StCst\n{\n  int m_nNo;\n  int m_nInSeq;\n  bool m_bDone;\n\n  static bool AsdNo(const StCst& cnroLeft, const StCst& cnroRight) { return cnroLeft.m_nNo < cnroRight.m_nNo; }\n};\n\nvoid fnInput(int &rnMaxSiz, vector<StCst> &rvoSort, int &rnMinNo)\n{\n  int nCnt = 0;\n  cin >> rnMaxSiz;\n\n  rvoSort.resize(rnMaxSiz);\n  for (int i = 0; i < rnMaxSiz; i++)\n  {\n    cin >> rvoSort[i].m_nNo;\n    rnMinNo = min(rnMinNo, rvoSort[i].m_nNo);\n    rvoSort[i].m_nInSeq = nCnt++;\n  }\n}\n\nvoid fnMinCostSort(vector<StCst> &rvoSort, int nMinNo, int &rnSwpCnt)\n{\n  sort(begin(rvoSort), end(rvoSort), StCst::AsdNo);\n\n  int nCost;\n  for (int i = 0; i < rvoSort.size(); i++)\n  {\n    if (rvoSort[i].m_bDone)  continue;\n\n    int nTotal = rvoSort[i].m_nNo;\n    int nCurSize = 1;\n    int nCurMin = rvoSort[i].m_nNo; \n    rvoSort[i].m_bDone = true;\n\n    int j = rvoSort[i].m_nInSeq;\n    while  (rvoSort[j].m_nNo != rvoSort[i].m_nNo)\n    {\n      nTotal += rvoSort[j].m_nNo;\n      nCurSize++;\n      nCurMin = min(nCurMin, rvoSort[j].m_nNo);\n      rvoSort[j].m_bDone = true;\n      j = rvoSort[j].m_nInSeq;\n    }\n\n    if (nCurSize == 1)\n        nCost = 0;\n    else\n      if (nMinNo == nCurMin)\n        nCost = nTotal + (nCurSize - 2) * nCurMin;\n      else\n        nCost = min(nTotal + (nCurSize - 2) * nCurMin, \n                    nTotal + nCurMin + (nCurSize + 1) * nMinNo);\n    rnSwpCnt += nCost;\n  }\n}\n\nvoid fnResult(int nSwpCnt)\n{\n  cout << nSwpCnt << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int nMaxSiz;\n  vector<StCst> voSort;\n  int nMinNo = INT_MAX;\n\n  fnInput(nMaxSiz, voSort, nMinNo);\n\n  int nSwpCnt = 0;\n  fnMinCostSort(voSort, nMinNo, nSwpCnt);\n\n  fnResult(nSwpCnt);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define maxn 1005\n#define maxv 10005\nint n,a[maxn],s;\nint b[maxn],t[maxv];\nint solve()\n{\n    int ans=0;\n    bool v[maxn];\n    for(int i=0;i<n;++i)\n    {\n        b[i]=a[i];\n        v[i]=false;\n    }\n    sort(b,b+n);\n    for(int i=0;i<n;++i) t[b[i]]=i;\n    for(int i=0;i<n;++i)\n    {\n        if(v[i]) continue;\n        int cur=i;\n        int S=0;\n        int m=maxv;\n        int an=0;\n        while(true)\n        {\n            v[cur]=true;\n            an++;\n            int V=a[cur];\n            m=min(m,V);\n            S+=V;\n            cur=t[V];\n            if(v[cur]) break;\n        }\n        ans+=min(S+(an-2)*m,m+S+(an+1)*s);\n    }\n    return ans;\n}\nint main()\n{\n    cin>>n;\n    s=maxv;\n    for(int i=0;i<n;++i)\n    {\n        cin>>a[i];\n        s=min(a[i],s);\n    }\n    int ans=solve();\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n\tint n, cost1 = 0, cost2 = 0;\n\tcin >> n;\n\t\n\tint arr1[n], arr2[n], sorted[n];\n\tbool visited[n] = { false };\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr1[i];\n\t\tarr2[i] = sorted[i] = arr1[i];\n\t}\n\tsort(sorted, sorted + n);\n\n\tvector<pair<int, int> > vec;\n\tint mini = 0, s1, s2;\n\twhile (mini < n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (arr1[i] == sorted[mini]) {\n\t\t\t\ts1 = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (arr1[i] == sorted[s1]) {\n\t\t\t\ts2 = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (s1 != s2) {\n\t\t\tvisited[mini] = visited[s1] = true;\n\t\t\tcost1 += arr1[s1] + arr1[s2];\n\t\t\tvec.push_back(make_pair(s1, s2));\n\t\t\tswap(arr1[s1], arr1[s2]);\n\t\t}\n\t\telse {\n\t\t\tmini++;\n\t\t}\n\t}\n\n\tcout << cost1 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint sorting(vector<int> v)\n{\n\tmap<vector<int>, int> d;\n\t\n\tvector<int> sorted(v.begin(), v.end());\n\t\n\tsort(v.begin(), v.end());\n\t\n\tqueue<pair<vector<int>, int> > que;\n\t\n\tque.push(make_pair(v, 1)); d[v] = 1; // pair(vector, cost + 1)\n\t\n\twhile(!que.empty())\n\t{\n\t\tvector<int> v1 = que.front().first;\n\t\t\n\t\tint cost = que.front().second; que.pop();\n\t\t\n\t\tfor(int i = 0; i < v.size(); i++)\n\t\t{\n\t\t    for(int j = i + 1; j < v.size(); j++)\n\t\t    {\n\t\t        vector<int> v2(v1.begin(), v1.end());\n\t\t        \n\t\t        int cost2 = cost + v1[i] + v1[j];\n\t\t        \n\t\t        swap(v2[i], v2[j]);\n\t\t        \n\t\t        if(d[v2] == 0 || d[v2] > cost2)\n\t\t        {\n\t\t            d[v2] = cost2;\n\t\t            \n\t\t            que.push(make_pair(v2, cost2));\n\t\t        }\n\t\t    }\n\t\t}\n\t}\n\t\n\treturn d[sorted] - 1;\n}\n\nint main()\n{\n\tvector<int> v; int n;\n\t\n\tcin >> n; v = vector<int>(n);\n\t\n\tfor(int i = 0; i < n; i++) { cin >> v[i]; }\n\t\n\tcout << sorting(v) << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <array>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <utility>\n#include <tuple>\n#include <algorithm>\n#include <limits>\n#include <fstream>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <list>\n#include <cstring>\n#include <unordered_set>\n#include <cmath>\n#include <iomanip>\n\nnamespace\n{\n\ttemplate<int N>\n\tstd::array<int, N> GetValue(std::istream& stream)\n\t{\n\t\tstd::string buf;\n\t\tstd::getline(stream, buf);\n\n\t\tstd::stringstream sstr(buf);\n\t\tstd::array<int, N> retval;\n\n\t\tfor (int i = 0; i < N; ++i)\n\t\t{\n\t\t\tstd::getline(sstr, buf, ' ');\n\t\t\tretval[i] = std::stoi(buf);\n\t\t}\n\n\t\treturn retval;\n\t}\n\n\tstd::vector<int> GetValue(std::istream& stream, int num, char delim)\n\t{\n\t\tstd::string buf;\n\t\tstd::getline(stream, buf);\n\t\tstd::stringstream sstr(buf);\n\n\t\tstd::vector<int> retval;\n\t\tretval.reserve(num);\n\n\t\tstd::string input;;\n\t\tfor (int i = 0; i < num && std::getline(sstr, input, delim); ++i)\n\t\t{\n\t\t\tretval.push_back(std::stoi(input));\n\t\t}\n\n\t\treturn retval;\n\t}\n\n\tint GetValue(std::istream& stream)\n\t{\n\t\tint in;\n\t\tstream >> in;\n\n\t\treturn in;\n\t}\n\n\tstd::vector<std::string> GetValueString(std::istream& stream, int num, char delim)\n\t{\n\t\tstd::string buf;\n\t\tstd::vector<std::string> retval;\n\t\tretval.reserve(num);\n\n\t\tstd::getline(stream, buf);\n\t\tstd::stringstream sstr(buf);\n\n\t\tfor (int i = 0; i < num && std::getline(sstr, buf, delim); ++i)\n\t\t{\n\t\t\tretval.push_back(std::move(buf));\n\t\t}\n\n\t\treturn retval;\n\t}\n\n\ttemplate<typename Itr>\n\tvoid PrintLine(Itr begin, Itr end)\n\t{\n\t\tbool first = true;\n\n\t\tfor (int i = 0; begin != end; ++begin, ++i)\n\t\t{\n\t\t\tif (!first)\n\t\t\t{\n\t\t\t\tstd::cout << ' ';\n\t\t\t}\n\n\t\t\tstd::cout << (*begin);\n\n\t\t\tfirst = false;\n\t\t}\n\t\tstd::cout << std::endl;\n\t}\n\n\ttemplate<typename T>\n\tvoid Print(const std::vector<T>& sequence)\n\t{\n\t\tfor (const auto& e : sequence)\n\t\t{\n\t\t\tstd::cout << e << '\\n';\n\t\t}\n\n\t\tstd::cout << std::flush;\n\t}\n\n\tstd::vector<std::vector<int>> GetCycles(const std::vector<int>& sequence)\n\t{\n\t\tstd::vector<int> sorted(sequence);\n\t\tstd::sort(sorted.begin(), sorted.end());\n\t\tstd::vector<int> place;\n\t\tplace.reserve(sequence.size());\n\n\t\tfor (int e : sequence)\n\t\t{\n\t\t\tfor (size_t i = 0; i < sorted.size(); ++i)\n\t\t\t{\n\t\t\t\tif (e == sorted[i])\n\t\t\t\t{\n\t\t\t\t\tplace.push_back(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstd::vector<bool> already(sequence.size(), false);\n\t\tstd::vector<std::vector<int>> retval;\n\t\tfor (size_t i = 0; i < place.size(); ++i)\n\t\t{\n\t\t\tif (place[i] == static_cast<int>(i))\n\t\t\t\tcontinue;\n\n\t\t\tif (already[i])\n\t\t\t\tcontinue;\n\n\t\t\tstd::vector<int> cycle;\n\t\t\tfor (int index = place[i], num = sequence[index];\n\t\t\t\t!already[i];\n\t\t\t\tindex = place[index], num = sequence[index])\n\t\t\t{\n\t\t\t\tcycle.push_back(num);\n\t\t\t\talready[index] = true;\n\t\t\t}\n\n\t\t\tretval.push_back(std::move(cycle));\n\t\t}\n\n\t\treturn retval;\n\t}\n\n\tint GetCost(const std::vector<int>& cycle, int min)\n\t{\n\t\tint cycle_min = *(std::min_element(cycle.begin(), cycle.end()));\n\n\t\tint cost1 = std::accumulate(cycle.begin(), cycle.end(), 0) + (cycle.size() - 2) * cycle_min;\n\n\t\tint cost2 = (cycle_min + min) * 2 - (cycle_min - min) * (cycle.size() - 1);\n\n\t\treturn cost1 + std::min(0, cost2);\n\t}\n}\n\nint main(int argc, char* argv[])\n{\n\tauto file = (argc == 1) ? std::ifstream() : std::ifstream(argv[1]);\n\tstd::istream& stream = (argc == 1) ? std::cin : file;\n\tif (argc == 1)\n\t{\n\t\tstd::cin.tie(0);\n\t\tstd::ios::sync_with_stdio(false);\n\t}\n\n\tint num = GetValue<1>(stream)[0];\n\tstd::vector<int> sequence = GetValue(stream, num, ' ');\n\n\tauto cycles = GetCycles(sequence);\n\n\tint cost = 0;\n\tint min = *(std::min_element(sequence.begin(), sequence.end()));\n\n\tfor (const auto& e : cycles)\n\t{\n\t\tcost += GetCost(e, min);\n\t}\n\n\tstd::cout << cost << std::endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <list>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cmath>\n#include <string>\n#define N 1005\n#define INF (1 << 30)\ntypedef long long ll;\nusing namespace std;\n\nint main()\n{\n\tint weight[N];\n\tint sorted[N];\n\tint idx[N];\n\tint n, x = INF, ans = 0;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tscanf(\"%d\", weight + i);\n\t\tsorted[i] = weight[i];\n\t\tif (x > weight[i])\n\t\t\tx = weight[i];\n\t}\n\tsort(sorted, sorted + n);\n\tfor (int i = 0; i < n; ++i)\n\t\tidx[sorted[i]] = i;\n\tbool visited[N]{ false };\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tif (visited[i] || i == idx[weight[i]])\n\t\t\tcontinue;\n\t\tint Min = weight[i], num = 1, sum1 = weight[i];\n\t\tint j = i;\n\t\twhile (true)\n\t\t{\n\t\t\tvisited[j] = true;\n\t\t\tj = idx[weight[j]];\n\t\t\tif (visited[j])\n\t\t\t\tbreak;\n\t\t\tMin = min(Min, weight[j]);\n\t\t\tsum1 += weight[j];\n\t\t\t++num;\n\t\t\t\n\t\t}\n\t\tans += min(Min + (num + 1) * x, (num - 2) * Min) + sum1;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n#define USE_LLONG_AS_INT\n#ifdef USE_LLONG_AS_INT\n#define int long long\n#define inf (1ll<<60)\n#else\n#define inf (1<<30)\n#endif\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define Rep(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a,b) for(int i=(a);i<=(b);i++)\n#define rev(i,n) for(int i=(n)-1;i>=0;i--)\n#define vi vector<int>\n#define vvi vector<vi>\n#define pb push_back\n#define eb emplace_back\n#define pi pair<int,int>\n#define vp vector<pair<int,int>>\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define MEMSET(a) memset(a,0,sizeof(a))\n#define Yes(f) cout<<(f?\"Yes\":\"No\")<<endl\n#define yes(f) cout<<(f?\"yes\":\"no\")<<endl\n#define YES(f) cout<<(f?\"YES\":\"NO\")<<endl\n#define SORT(v) sort(all(v))\n#define RSORT(v) sort(all(v), greater<int>())\n\nusing namespace std;\n\nconst int mod=1e9+7;\nconst string sp=\" \";\n\nvoid run();\n\nvoid init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(12);\n}\n\nsigned main(){\n    init();\n    run();\n    return 0;\n}\n\nint n,m;\nvi a;\n\nint solve(){\n    int ans=0;\n    vi b(all(a));\n    map<int,int> t;\n    vector<bool> v(n);\n    SORT(b);\n    rep(i,n)t[b[i]]=i;\n    rep(i,n){\n        if(v[i])continue;\n        int j=i;\n        int s=0;\n        int mm=10000;\n        int nn=0;\n        while(true){\n            v[j]=true;\n            nn++;\n            int x=a[j];\n            mm=min(mm,x);\n            s+=x;\n            j=t[x];\n            if(v[j])break;\n        }\n        ans+=s+min((nn-2)*mm,mm+(nn+1)*m);\n    }\n    return ans;\n}\n\nvoid run(){\n    cin>>n;\n    a=vi(n);\n    rep(i,n)cin>>a[i];\n    m=*min_element(all(a));\n    cout<<solve()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint solve(){\nint ans = 0;\n\nbool V[MAX];\nfor(int i = 0; i < n; i++){\nB[i] = A[i];\nV[i] = false;\n}\nsort(B, B+n);\nfor(int i = 0; i < n; i++) T[B[i]] = i;\nfor(int i = 0; i < n; i++){ \nif(V[i]) continue;\nint cur = i;\nint S = 0;\nint m = VMAX;\nint an = 0;\nwhile(1){\nV[cur} = true;\nan++;\nint v = A[cur];\nm = min(m, v);\nS += v;\nif(V[cur]) break;\n}\nans += min(S + (an - 2) * m, m + S + (an + 1) * S);\n}\nreturn ans;\n}\n\nint main(){\ncin >> n;\nS = VMAX;\n}\nint ans = solve();\ncount << ans << Ende;\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdint.h>\n#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <climits>\n#include <algorithm>\n#include <float.h>\nusing namespace std;\n\n#define DEBUG (0)\n\n#if DEBUG\n#define DPRINTF(...) do { \\\n    printf(\"D(L%d) %s: \", __LINE__, __func__); \\\n    printf(__VA_ARGS__); \\\n  } while (false)\n#else\n#define DPRINTF(...)\n#endif // DEBUG\n\nint g_cost = 0;\n\nvoid swap(int array[], int i0, int i1)\n{\n  int temp = array[i1];\n  array[i1] = array[i0];\n  array[i0] = temp;\n}\n\n\ninline bool isSortedAtIndex(int idx, const int array0[], const int array1[])\n{\n  return array0[idx] == array1[idx];\n}\n\n/* Assum all elements in array[] are distinct */\nint getIdxOf(int num, const int array[], int numOfArray)\n{\n  for (int i = 0; i < numOfArray; i++)\n  {\n    if (array[i] == num)\n      return i;\n  }\n\n  const int error = -1;\n  return error;\n}\n\nvoid calculateCost(int idx, int numOfArray, const int array[], const int sortedArray[], int &swapIdx, float &cost)\n{\n  const int targetNum = sortedArray[idx];\n  swapIdx = getIdxOf(targetNum, array, numOfArray);  // run time : O(n)\n\n  cost = static_cast<float>(array[idx] + array[swapIdx]);\n\n  // If both elements, of which index is \"idx\" and \"swapIdx\", are sorted at one time,\n  // we could think of the cost of swap being half\n  if (sortedArray[swapIdx] == array[idx])\n    cost /= 2.f;\n\n  DPRINTF(\"swap %d and %d with cost of %f\\n\", idx, swapIdx, cost);\n}\n\nint main()\n{\n  int numOfArray;\n  cin >> numOfArray; cin.ignore();\n\n  int array[numOfArray];\n  for (int i = 0; i < numOfArray; i++)\n    cin >> array[i];\n\n#if DEBUG\n  for (int i = 0; i < numOfArray; i++)\n    if (i == 0) DPRINTF(\"%d\", array[i]);\n    else        printf(\" %d\", array[i]);\n  cout << endl;\n#endif // DEBUG\n\n  int sortedArray[numOfArray];\n  for (int i = 0; i < numOfArray; i++)\n    sortedArray[i] = array[i];\n\n  sort(sortedArray, sortedArray + numOfArray);\n\n#if DEBUG\n  for (int i = 0; i < numOfArray; i++)\n    if (i == 0) DPRINTF(\"%d\", sortedArray[i]);\n    else        printf(\" %d\", sortedArray[i]);\n  cout << endl;\n#endif // DEBUG\n\n  {\n    bool needSort = true;\n\n    do {\n\n      needSort = false;\n\n      float minCost = FLT_MAX;\n      pair<int, int> swapIndcies = make_pair(-1, -1);\n\n      // find a pair of array elements that can be swapped with minimum cost\n      for (int i = 0; i < numOfArray; i++)\n      {\n        if (isSortedAtIndex(i, array, sortedArray))\n          continue;\n\n        needSort = true;\n\n        int swapIdx;\n        float cost;\n        calculateCost(i, numOfArray, array, sortedArray, swapIdx, cost);\n\n        if (minCost > cost)\n        {\n          minCost = cost;\n          swapIndcies = make_pair(i, swapIdx);\n        }\n      }\n\n      if (needSort)\n      {\n\n        DPRINTF(\"Swap array[%d] (%d) and array[%d] (%d)\\n\",\n            swapIndcies.first, array[swapIndcies.first],\n            swapIndcies.second, array[swapIndcies.second]);\n\n        swap(array, swapIndcies.first, swapIndcies.second);\n\n        g_cost += array[swapIndcies.first] + array[swapIndcies.second];\n\n#if DEBUG\n      for (int i = 0; i < numOfArray; i++)\n        if (i == 0) DPRINTF(\"%d\", array[i]);\n        else        printf(\" %d\", array[i]);\n      cout << endl;\n#endif // DEBUG\n\n      }\n\n    } while (needSort);\n  }\n\n  cout << g_cost << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n, min_w = 10000;\n  cin >> n;\n  vector<int> W(n), W_origin(n);\n  deque<int> w_cycle;\n  for (size_t i = 0; i < n; i++) {\n    cin >> W[i];\n    min_w = min(min_w, W[i]);\n  }\n\n  copy(W.begin(), W.end(), W_origin.begin());\n  sort(W.begin(), W.end());\n\n  int cost = 0;\n  for (size_t i = 0; i < n; i++) {\n    if (W[i] == -1) continue;\n    int idx = i;\n    while (true) {\n      auto correspond_w = find(W.begin(), W.end(), W_origin[idx]);\n      if (correspond_w == W.end()) break;\n      w_cycle.push_back(*correspond_w);\n\n      idx = distance(W.begin(), correspond_w);\n      *correspond_w = -1;\n    }\n\n    int cost_inter, cost_ext;\n    auto min_w_cycle = min_element(w_cycle.begin(), w_cycle.end());\n\n    cost_inter = accumulate(w_cycle.begin(), w_cycle.end(), 0) +\n                 *min_w_cycle * (w_cycle.size() - 2);\n    cost_ext = accumulate(w_cycle.begin(), w_cycle.end(), 0) + *min_w_cycle +\n               min_w * (w_cycle.size() + 1);\n\n    cost += min(cost_ext, cost_inter);\n\n    w_cycle.clear();\n  }\n\n  cout << cost << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint main(){\n    int n, w[1000], a[1000], mi=1e6;\n    cin >> n;\n    for(int i=0;i<n;i++){\n        cin >> w[i];\n        a[i]=w[i];\n        mi=min(mi, w[i]);\n    }\n    sort(a, a+n);\n    int idx[100001];\n    for(int i=0;i<n;i++) idx[w[i]]=i;\n\n    ll cost = 0;\n    ll ccost, cnt;\n    for(int i=0;i<n;i++){\n        if(a[i]==w[i]) continue;\n        int j=idx[a[i]];\n        int s=w[j];\n        ccost = 0;\n        cnt = 0;\n        while(true){\n            int k=idx[a[j]];\n            ccost += w[k];\n            cnt++;\n            w[j]=w[k];\n            w[k]=s;\n            j=k;\n            if(w[k]==a[k]) break;\n        }\n        cost += min(ccost + cnt*a[i], ccost + (a[i]+mi)*2 + cnt*mi);\n    }\n    std::cout << cost << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n        int n, ans=0, amin=10000;\n        cin>>n;\n        int a[n], b[n], T[n];\n        bool V[n];\n        for(int i=0;i<n;i++) V[i] = true;\n        for(int i=0;i<n;i++) {\n                cin>>a[i];\n                b[i]=a[i];\n                amin=min(a[i], amin);\n        }\n        sort(b, b+n);\n        for(int i=0;i<n;i++) T[b[i]] = i;\n\n        for(int i=0;i<n;i++) {\n                if(!V[i]) continue;\n                int j = i, tmpmin = a[i], c=1;\n                while(V[j]){\n                        c++;\n                        tmpmin = min(tmpmin, a[j]);\n                        ans += a[j];\n                        V[j] = false;\n                        j = T[a[j]];\n                }\n                ans += min((c-2)*tmpmin, tmpmin+(c+1)*amin);\n        }\n\n        cout<<ans<<endl;\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint const MAX=1000000000;\n\ntypedef pair<int, int> P;\n\nint main(){\n\tint n;\n\tcin >> n;\n\t\n\tvector<int> vec(n),sorted(n);\n\t\n\tfor (int i=0;i<n;i++){\n\t\tcin >> vec[i];\n\t\tsorted[i]=vec[i];\n\t}\n\t\n \tsort(sorted.begin(),sorted.end());\n\t\n\tint count=0;\n\tint min=0;\n\tint mini=0;\n\tint T;\n\twhile(1){\n\t\tmin=MAX;\n\t\tfor (int i=0;i<n;i++){\n\t\t\tif(vec[i]==sorted[i]){\n\t\t\t\tT=MAX;\n\t\t\t}else{\n\t\t\t\tT=vec[i]+sorted[i];\n\t\t\t}\n\t\t\tif (min>T){\n\t\t\t\tmin=T;\n\t\t\t\tmini=i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(min==MAX){break;}\n\t\t\n\t\tint iswap=0;\n\t\tfor (int i=0;i<n;i++){\n\t\t\tif (sorted[mini]==vec[i]){\n\t\t\t\tiswap=i;\n\t\t\t}\n\t\t}\n\t\tswap(vec[mini],vec[iswap]);\n\t\tcount+=(vec[mini]+vec[iswap]);\n\t}\n\n\tcout << count << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\nusing namespace std;\n\n#define MAX_NUM 1000\n\nint W[MAX_NUM];\nint N;\n\nint Compare(const void *a, const void *b)\n{\n    return *(int*)a - *(int*)b;\n}\n\nvoid Swap(int idx1, int idx2) {\n\tint tmp = W[idx1];\n\tW[idx1] = W[idx2];\n\tW[idx2] = tmp;\n}\n\nint SearchIdx(int wi)\n{\t\n\tfor (int i = 0; i < N; i++) {\n\t\tif (W[i] == wi) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid Copy(int *ary)\n{\n\tfor (int i = 0; i < N; i++) {\n\t\tary[i] = W[i];\n\t}\n}\n\nint main(void)\n{\n\t//input\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> W[i];\n\t}\n\n\t//minimum cost?\n\tint cost = 0;\n\tint w2[MAX_NUM];\n\tCopy(w2);\n\tqsort(w2, N, sizeof(int), Compare);\n\n\tfor (int i = 0; i < N; i++) {\n\t\tint local_cost = 0;\n\t\tint local_change_num = 0;\n\t\tint idx1 = SearchIdx(w2[i]);\n\t\twhile (idx1 != i) {\n\t\t\tint idx2 = SearchIdx(w2[idx1]);\n\t\t\tSwap(idx1, idx2);\n\t\t\tlocal_cost = local_cost + W[idx1] + W[idx2];\n\t\t\tlocal_change_num++;\n\t\t\tidx1 = idx2;\n\t\t}\n\t\tif (w2[i] * local_change_num > w2[0] * local_change_num + (w2[i] + w2[0]) * 2) {\n\t\t\tlocal_cost -= (w2[i] * local_change_num) - (w2[0] * local_change_num + (w2[i] + w2[0]) * 2);\n\t\t}\n\t\tcost += local_cost;\n\t}\n\n\t//output\n\tcout << cost << \"\\n\";\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <unordered_map>\n#include <climits>\nusing namespace std;\n\n#define si static inline\n#define gcu getchar_unlocked\nsi int in() {\n\tint n = 0, c = gcu();\n\t// bool minus = false; if (c == '-') minus = true, c = gcu();\n\tdo {n = 10 * n + (c - '0'), c = gcu();} while (c >= '0');\n\treturn n; }\n\t// return minus ? -n : n; }\nsi void scan(char *s) {while (!isspace(*s++ = gcu()));}\n#define pcu putchar_unlocked\n#define svo si void out\ntemplate <typename T>\nsvo(T n) {\n\tstatic char buf[20];\n\tchar *p = buf;\n\t//if(n < 0) pcu('-'), n *= -1;\n\tif (!n) *p++ = '0';\n\telse while (n) *p++ = n % 10 + '0', n /= 10;\n\twhile (p != buf) pcu(*--p); }\nsvo(const char *s){while(*s)pcu(*s++);}\nsvo(char *s){while(*s)pcu(*s++);}\nsvo(char c){pcu(c);}\ntemplate <typename T>\n//svo(vector<T> &v){for(T &x:v)out(' '),out(x);out('\\n');}\nsvo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);out('\\n');}\ntemplate <typename head, typename... tail>\nsvo(head&& h, tail&&... t){out(h);out(move(t)...);}\n#undef svo\n#undef si\n\nint main()\n{\n\tint n = in();\n\tvector<int> W(n), S;\n\tvector<bool> V(n);\n\tunordered_map<int, int> M;\n\tfor (int &w: W)\n\t\tw = in();\n\tS = W;\n\tsort(S.begin(), S.end());\n\tfor (int i = 0; i < n; i++)\n\t\tM[S[i]] = i;\n\tint r = 0, s = S[0];\n\tfor (int i = 0; i < n; i++) {\n\t\tif (V[i])\n\t\t\tcontinue;\n\t\tint S = 0, l = 0, m = INT_MAX;\n\t\tfor (int c = i, v; !V[c]; c = M[v]) {\n\t\t\tV[c] = true;\n\t\t\tv = W[c];\n\t\t\tS += v;\n\t\t\tl++;\n\t\t\tm = min(m, v);\n\t\t}\n\t\tr += min(S + (l - 2) * m, m + S + (l + 1) * s);\n\t}\n\tout(r, '\\n');\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nint a[1001],b[1001],c[10001];\nbool used[1001];\nint main(){\n    int n;\n    cin>>n;\n    int mn=10001;\n    rep(i,n){\n        cin>>a[i];\n        b[i]=a[i];\n        mn=min(mn,a[i]);\n    }\n    sort(b,b+n);\n    rep(i,n) c[b[i]]=i;\n    ll ans=0;\n    rep(i,n){\n        if(used[i]) continue;\n        ll sum=0;\n        int mm=10001,cur=i,cnt=0;\n        while(!used[cur]){\n            used[cur]=true;\n            mm=min(mm,a[cur]);\n            sum+=a[cur];\n            cur=c[a[cur]];++cnt;\n        }\n        ans+=min(sum+(cnt-2)*mm,mm+sum+(cnt+1)*mn);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint researchRoop(int *s, int *pos, int p, int min){\n    int tmp;\n    int rmin = 10000;\n    int size = 0;\n    int sum = 0;\n\n    while(s[p]>=0){\n        tmp = s[p];\n        if(tmp<rmin)rmin = tmp;\n        sum += tmp;\n        size++;\n        s[p] = -1;\n        p = pos[tmp];\n    }\n\n    int ans1 = rmin + sum + (size+1)*min;\n    int ans2 = (size-2)*rmin + sum;\n    return std::min(ans1,ans2);\n}\n\nvoid quickSort(int *s, int n){\n    if(n<=1)return;\n    int i=0;\n    int tmp;\n    int key = s[n-1];\n    for(int j=0;j<n;j++){\n        if(s[j]>key)continue;\n        if(i<j){\n            tmp = s[i];\n            s[i] = s[j];\n            s[j] = tmp;\n        }\n        i++;\n    }\n\n    quickSort(s,i-1);\n    quickSort(s+i-1,n-i+1);\n}\n\nint main(){\n    int w[1000];\n    int s[1000];\n    int pos[10001];\n    int i,n,c=0;\n    int min = 10000;\n\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++){\n        scanf(\"%d\",w+i);\n        s[i] = w[i];\n        pos[w[i]] = i;\n        if(w[i]<min)min=w[i];\n    }\n    quickSort(s,n);\n    for(i=0;i<n;i++)if(s[i]==w[i])s[i]=-1;\n\n    for(i=0;i<n;i++){\n        if(s[i]<0)continue;\n        c += researchRoop(s,pos,i,min);\n    }\n\n    printf(\"%d\\n\",c);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<utility>\n#include<vector>\n#include<queue>\n#include<functional>\n#include<map>\n#include<set>\n#include<cstring>\n#include<string>\n#include<stack>\n#include<malloc.h>\n#include<math.h>\nusing namespace std;\n//#define int long long\ntypedef pair<int, int> pii;\ntypedef pair<int, char> pic;\ntypedef priority_queue<pii, vector<pii>, greater<pii> > RPQ;\n#define mk make_pair\n#define INF (1 << 30)\n#define INFL (1ll << 60ll)\n#define mod 1000000007\n\nint N, w[1010], to[10100], a[1010];\nvector<int> G[10100];\nbool used[10100];\n\nsigned main(){\n    cin >> N;\n    int mn = INF;\n    for(int i = 0; i < N; i++){\n        cin >> w[i];\n        a[i] = w[i];\n        mn = min(mn, w[i]);\n    }\n    sort(a, a + N);\n    for(int i = 0; i < N; i++){\n        to[a[i]] = i;\n        //printf(\"%d to %d\\n\", a[i], w[i]);\n    }\n    for(int i = 0; i < N; i++){\n        if(i != to[w[i]]){\n            G[w[i]].push_back(w[to[w[i]]]);\n        }\n    }\n    int ans = 0;\n    for(int i = 0; i < N; i++){\n        if(used[w[i]])continue;\n        used[w[i]] = true;\n        queue<int> que;\n        que.push(w[i]);\n        int V = 0, m = INF, S = 0;\n        while(!que.empty()){\n            int pos = que.front();\n            que.pop();\n            V++;\n            S += pos;\n            m = min(m, pos);\n            //printf(\"%d: %d\\n\", i, pos);\n            for(int j = 0; j < (int)G[pos].size(); j++){\n                int eto = G[pos][j];\n                if(!used[eto]){\n                    que.push(eto);\n                    used[eto] = true;\n                }\n            }\n        }\n        //printf(\"%d: V:%d m:%d S:%d res:%d\\n\", i, V, m, S, (V - 1) * m + S - m);\n        int res1 = (V - 1) * m + S - m;\n        int res2 = (V - 1) * mn + S - m + (m + mn) * 2;\n        ans += min(res1, res2);\n    }\n    cout << ans << endl;\n\n\n    return 0;\n}\n\n/*\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint solve(){\n  int ans = 0;\n\n  bool V[MAX];\n  for(int i=0; i<n; i++){\n    B[i] = A[i];\n    V[i] = false;\n  }\n  sort(B, B+n);\n  for(int i=0; i<n; i++) T[B[i]] = i;\n  for(int i=0; i<n; i++){\n    if(V[i]) continue;\n    int cur = i;\n    int S = 0;\n    int m = VMAX;\n    int an = 0;\n    while(1){\n      V[cur] = true;\n      an++;\n      int v = A[cur];\n      m = min(m, v);\n      S += v;\n      cur = T[v];\n      if(V[cur]) break;\n    }\n    ans += min(S + (an-2)*m, m+S+(an+1)*s);\n  }\n  return ans;\n}\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin >> n;\n    s = VMAX;\n    for(int i=0; i<n; i++){\n      cin >> A[i];\n      s = min(s, A[i]);\n    }\n    int ans = solve();\n    cout << ans << endl;\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main(void) {\n\tint num;\n\tcin >> num;\n\tvector<int> a(num);\n\tvector<int> sorted(num);\n\tint pos[1000];\n\tint order[1000];\n\tint cost = 0;\n\n\tfor (int i = 0; i < num; i++) {\n\t\tcin >> a[i];\n\t}\n\n\tfor (int i = 0; i < num; i++)\n\t\tsorted[i] = a[i];\n\tsort(sorted.begin(), sorted.begin() + num);\n\tfor (int i = 0; i < num; i++)\n\t\tpos[sorted[i]] = i;\n\n\tfor (int i = 0; i < num; i++) {\n\t\tint x = order[0] = i;\n\t\tint minn = 1000;\n\t\tint start = 0;\n\n\t\tif (i == pos[a[i]])\n\t\t\tcontinue;\n\n\t\tfor (int j = 1;; j++) {\n\t\t\tx = pos[a[x]];\n\t\t\tif (x == i)\n\t\t\t\tbreak;\n\t\t\tif (a[x] < minn) {\n\t\t\t\tminn = a[x];\n\t\t\t\tstart = j;\n\t\t\t}\n\t\t\torder[j] = x;\n\t\t}\n\n\t\tfor (int j = start - 1; j >= 0; j--) {\n\t\t\tcost += (minn + a[order[j]]);\n\t\t\ta[order[j + 1]] = a[order[j]];\n\t\t\ta[order[j]] = minn;\n\t\t}\n\t}\n\n\tcout << cost << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <climits>\nusing namespace  std;\n\nstruct StCst\n{\n  int m_nNo;\n  int m_nSeq;\n  bool m_bDone;\n\n  static bool AsdNo(const StCst& cnroLeft, const StCst& cnroRight) \n  { return cnroLeft.m_nNo < cnroRight.m_nNo; }\n};\n\nvoid fnInput(vector<StCst>& rvoSort)\n{\n  int nMaxSiz, nCnt = 0;\n  cin >> nMaxSiz;\n\n  rvoSort.resize(nMaxSiz);\n  for (int i = 0; i < nMaxSiz; i++)\n  {\n    cin >> rvoSort[i].m_nNo;\n    rvoSort[i].m_nSeq = nCnt++;\n  }\n}\n\nvoid fnMinCostSort(vector<StCst>& rvoSort, int& rnSwpCnt)\n{\n  sort(begin(rvoSort), end(rvoSort), StCst::AsdNo);\n  int nMinNo = rvoSort[0].m_nNo;\n\n  int nCost;\n  for (int i = 0; i < rvoSort.size(); i++)\n  {\n    if (rvoSort[i].m_bDone)  continue;\n\n    int nTotal  = rvoSort[i].m_nNo;\n    int nCurMin = rvoSort[i].m_nNo; \n    int nCurSize = 1;\n    rvoSort[i].m_bDone = true;\n\n    int j = rvoSort[i].m_nSeq;\n    while  (rvoSort[j].m_nNo != rvoSort[i].m_nNo)\n    {\n      nTotal += rvoSort[j].m_nNo;\n      nCurSize++;\n      rvoSort[j].m_bDone = true;\n      j = rvoSort[j].m_nSeq;\n    }\n\n    if (nCurSize == 1)\n        nCost = 0;\n    else\n        nCost = min(nTotal + (nCurSize - 2) * nCurMin, \n                    nTotal + nCurMin + (nCurSize + 1) * nMinNo);\n    rnSwpCnt += nCost;\n  }\n}\n\nvoid fnResult(int nSwpCnt)\n{\n  cout << nSwpCnt << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vector<StCst> voSort;\n\n  fnInput(voSort);\n\n  int nSwpCnt = 0;\n  fnMinCostSort(voSort, nSwpCnt);\n\n  fnResult(nSwpCnt);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<int> w(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> w[i];\n\t}\n\tauto a = w;\n\tsort(a.begin(), a.end());\n\tvector<int> p(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint it = lower_bound(a.begin(), a.end(), w[i]) - a.begin();\n\t\tp[it] = i;\n\t}\n\tint res = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (p[i] != i) {\n\t\t\tres += w[i] + a[i];\n\t\t\tint it = lower_bound(a.begin(), a.end(), w[i]) - a.begin();\n\t\t\tswap(w[p[it]], w[i]);\n\t\t\tswap(p[it], p[i]);\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nint main()\n{\n  int N;\n  cin >> N;\n  vector< int > W(N), nums(N), rev(N);\n  for(int i = 0; i < N; i++) {\n    cin >> W[i];\n    nums[i] = W[i];\n  }\n  sort(begin(nums), end(nums));\n  nums.erase(unique(begin(nums), end(nums)), end(nums));\n  for(int i = 0; i < N; i++) {\n    W[i] = lower_bound(begin(nums), end(nums), W[i]) - begin(nums);\n    rev[W[i]] = i;\n  }\n\n  int ret = 0;\n  for(int i = 0; i < N; i++) {\n    if(i != W[i]) {\n      rev[W[i]] = rev[i];\n      swap(W[i], W[rev[i]]);\n      ret += nums[W[i]];\n      ret += nums[rev[i]];\n    }\n  }\n\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define DOF 0x7f7f7f7f\n#define mem(a,b) memset(a,b,sizeof(a))\n#define IO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\ntypedef long long ll;\nusing namespace std;\nconst int maxn=1e5+10;\n\nint n;\nint a[maxn],b[maxn],vis[maxn];\n\nll solve()\n{\n    map<int,int>mt;\n    int x=INF;\n    for(int i=1;i<=n;++i)\n    {\n        b[i]=a[i];\n        x=min(x,a[i]);\n    }\n    sort(b+1,b+1+n);\n    for(int i=1;i<=n;++i)\n        mt[b[i]]=i;\n    ll ans=0;\n    for(int i=1;i<=n;++i)\n    {\n        ll cnt=0,sum=0,minn=INF,tmp=i;\n        while(1)\n        {\n            vis[tmp]=1;\n            ++cnt;\n            minn=min(minn,a[tmp]*1ll);\n            sum+=a[tmp];\n            tmp=mt[a[tmp]];\n            if(vis[tmp]) break;\n\n\n        }\n        ans=ans+min(sum+(cnt-2)*minn,sum+(cnt-2)*minn+2*(minn+x)-(cnt-1)*(minn-x));\n    }\n    return ans;\n}\n\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;++i) cin>>a[i];\n    ll ans=solve();\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\n\nint partition(int *A,int p,int r)\n{\n\tint j,x,temp;\n\n\tx = A[r];\n\tj = p-1;\n\n\tfor(int i = p; i < r; i++)\n\t{\n\t\tif (A[i] <= x)\n\t\t{\n\t\t\tj++;\n\t\t\ttemp = A[i];\n\t\t\tA[i] = A[j];\n\t\t\tA[j] = temp;\n\t\t}\n\t}\n\n\ttemp = A[j+1];\n\tA[j+1] = A[r];\n\tA[r] = temp;\n\n\treturn j+1;\n}\n\nvoid quicksort(int *A,int p,int r)\n{\n\tint q;\n\n\tif (p < r)\n\t{\n\t\tq = partition(A,p,r);\n\t\tquicksort(A,p,q-1);\n\t\tquicksort(A,q+1,r);\n\t}\n}\n\nint main()\n{\n\tbool check;\n\tint n,a[1000] = {0},b[1000] = {0};\n\tint sum1 = 0,sum2 = 0,pivot = 0,pivot1 = 0,pivot2= 0,min = 0,start,temp,k;\n\n\tscanf(\"%d\", &n);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\tb[i] = a[i];\n\t}\n\n\tquicksort(b,0,n-1);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (a[i] != b[i])\n\t\t{\n\t\t\tfor(int j = i+1; j < n; j++)\n\t\t\t{\n\t\t\t\tif (b[j] == a[i] && b[i] == a[j])\n\t\t\t\t{\n\t\t\t\t\ttemp = a[i];\n\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\ta[j] = temp;\n\t\t\t\t\tsum1 += a[i] + a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//cout << \"sum=\" << sum1 << endl;\n\n\tsum2 = sum1;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (a[i] != b[i])\n\t\t{\n\t\t\tif (i == 0)\n\t\t\t{\n\t\t\t\tcheck = true;\n\t\t\t}\n\n\t\t\tstart = i;\n\t\t\tmin = a[i];\n\n\t\t\tfor(int j = i+1; j < n; j++)\n\t\t\t{\n\t\t\t\tif (min > a[j])\n\t\t\t\t{\n\t\t\t\t\tmin = a[j];\n\t\t\t\t\tpivot = j;\n\t\t\t\t\tpivot1 = pivot;\n\t\t\t\t\tpivot2 = pivot;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i == n-1)\n\t\t{\n\t\t\tprintf(\"%d\\n\", sum1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t\n\n\tfor(int i = 1; i < n - start; i++)\n\t{\n\t\tk = start;\n\n\t\t\n\t\twhile(1)\n\t\t{\n\t\t\tif (b[pivot1] == a[k])\n\t\t\t{\n\t\t\t\t//cout << \"pivot = \" << pivot1 << \" \" << \"k = \" << k << endl;\n\n\t\t\t\ttemp = a[pivot1];\n\t\t\t\ta[pivot1] = a[k];\n\t\t\t\ta[k] = temp;\n\n\t\t\t\tsum1 += a[pivot1] + a[k];\n\t\t\t\tpivot1 = k;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t}\n\n\n\tif (!check)\n\t{\n\t\ttemp = a[pivot2];\n\t\ta[pivot2] = a[0];\n\t\ta[0] = temp;\n\n\t\tfor(int i = 1; i < n - start; i++)\n\t\t{\n\t\t\tint j = start;\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif (b[pivot2] == a[j])\n\t\t\t\t{\n\t\t\t\t\ttemp = a[pivot2];\n\t\t\t\t\ta[pivot2] = a[j];\n\t\t\t\t\ta[j] = temp;\n\n\t\t\t\t\tsum2 += a[pivot2] + a[j];\n\t\t\t\t\tpivot2 = j;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\n\n\t\tif (sum1 < sum2)\n\t\t{\n\t\t\tprintf(\"%d\\n\", sum1);\n\t\t}else\n\t\t{\n\t\t\tprintf(\"%d\\n\", sum2);\n\t\t}\n\t}\n\n\n\tprintf(\"%d\\n\", sum1);\n\t\n\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nint n, w[1000], s;\nint a[1000], d[10001]; //destination \n\nlong solve(){\n\tlong ret=0;\t\n\t\n\tbool v[1000];\n\tfor(int i=0; i<n; ++i){\n\t\ta[i]=w[i];\n\t\tv[i]=false;\t\n\t}\n\tsort(a, a+n); //a[]??????w[]???????????¢?????\\???\n\t\n\t//??????a[i]??????????????????????????´??????d[]?????\\??????\n\tfor(int i=0; i<n; ++i) d[a[i]]=i;\n\t\n\tfor(int i=0; i<n; ++i){\n\t\tif(v[i]) continue; //??¢???????????????????????????????????????????????§???????????????????????£?????????\n\t\t\n\t\t//?????????????????¢???\n\t\tint cur=i; //?????¨??????\n\t\tint sum=0;\n\t\tint m=10000; //???????????????????????????????°????\n\t\tint an=0; //?????????????????§??????\n\t\t\n\t\twhile(1){\n\t\t\tv[cur]=true; //?¨??????????????¨????\n\t\t\tan++;\n\t\t\tint z=w[cur];\n\t\t\tsum+=z;\n\t\t\tm=min(m, z);\n\t\t\tcur=d[z]; //?¬??????????\n\t\t\tif(v[cur]) break; //?????¨??????\n\t\t}\n\t\t\n\t\tret += min(sum+(an-2)*m , m+sum+(an+1)*s);\t\n\t}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\" %d\", &n);\n\t\n\ts=10000;\n\tfor(int i=0; i<n; ++i){\n\t\tscanf(\" %d\", &w[i]);\n\t\ts=min(s, w[i]); //s???w[]?????????????°????????´?\n\t}\n\t\n\tprintf(\"%ld\\n\", solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nstatic const int Max = 10000;\nint s;\n\nint main(){\n    int n,A[1000],B[1000],T[10001],ans=0;\n    bool flag[1000];\n    s=Max;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>A[i];\n        B[i]=A[i];\n        s=min(s,A[i]);\n        flag[i]=false;\n    }\n    //cout<<s<<endl;\n    sort(B,B+n);\n    for(int i=0;i<n;i++)\n        T[B[i]]=i;\n    for(int i=0;i<n;i++)\n    {\n        if(flag[i])continue;\n        int x=i,m=Max,sum=0,cnt=0;\n        while(1){\n            flag[x]=true;\n            sum+=A[x];\n            m=min(m,A[x]);\n            x=T[A[x]];\n            cnt++;\n            if(flag[x])\n                break;\n        }\n        ans += min(sum + m * (cnt - 2), sum + m + (cnt + 1) * s);\n\n\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint solve(int a[], int n, int vmin) {\n    int ans = 0;\n    int b[MAX], t[VMAX+1];\n    bool p[MAX];\n    for (int i = 0; i < n; i++) {\n        b[i] = a[i];\n        p[i] = false;\n    }\n    sort(b, b + n);\n    for (int i = 0; i < n; i++) t[b[i]] = i;\n    for (int i = 0; i < n; i++) {\n        if (p[i]) continue;\n        int cur = i;\n        int sum = 0;\n        int m = VMAX;\n        int an = 0;\n        while (true) {\n            p[cur] = true;\n            an++;\n            int v = a[cur];\n            m = min(m, v);\n            sum += v;\n            cur = t[v];\n            if (p[cur]) break;\n        }\n        ans += min(sum + (an - 2) * m, m + sum + (an + 1) * vmin);\n    }\n\n    return ans;\n}\n\nint main() {\n    int n, a[MAX];\n    int vmin = VMAX;\n\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        vmin = min(vmin, a[i]);\n    }\n    cout << solve(a, n, vmin) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve(){\n    int ans = 0;\n\n    bool V[MAX];\n    for(int i = 0;i<n;i++){\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B,B+n);\n    for(int i = 0;i<n;i++)\n        T[B[i]] = i;\n    for(int i = 0;i<n;i++){\n        if(V[i])\n            continue;\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while(1){\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m,v);\n            S += v;\n            cur = T[v];\n            if(V[cur])\n                break;\n        }\n        ans += min(S + (an - 2)*m, m+S+(an+1)*S);\n    }\n    return ans;\n}\n\nint main(){\n    cin>>n;\n    s = VMAX;\n    for(int i = 0;i<n;i++){\n        cin>>A[i];\n        s = min(s,A[i]);\n    }\n    int ans = solve();\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, b) for (int i = (a), i##_max = (b); i < i##_max; ++i)\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define ALL(obj) (obj).begin(), (obj).end()\n\nusing namespace std;\nusing vi = vector<int>;\nusing i64 = int64_t;\n\nconstexpr int INF = 1 << 30;\nconstexpr int MOD = 1000000007;\n\ntemplate <typename T>\nvoid print(vector<T> v) {\n  REP(i, v.size()) {\n    if (i) cout << \" \";\n    cout << v[i];\n  }\n  cout << endl;\n}\n\nint solve(vi &A, int s) {\n  int ans{0};\n  vector<bool> V(A.size(), false);\n  vi T(10001);\n  auto B = A;\n  sort(ALL(B));\n  REP(i, A.size()) T[B[i]] = i;\n  REP(i, A.size()) {\n    if (V[i]) continue;\n    int cur{i};\n    int num{0}, sum{0}, min_{INF};\n    while (!V[cur]) {\n      V[cur] = true;\n      auto w = A[cur];\n      ++num;\n      sum += w;\n      min_ = min(min_, w);\n      cur = T[w];\n    }\n    ans += min(sum + (num - 2) * min_, min_ + sum + (num + 1) * s);\n  }\n  return ans;\n}\n\nint main() {\n  int n, s{INF};\n  cin >> n;\n  vi A(n);\n  REP(i, n) {\n    cin >> A[i];\n    s = min(s, A[i]);\n  }\n  cout << solve(A, s) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX=1000;\nstatic const int VMAX=10000;\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve(){\n    int ans=0;\n    bool V[MAX];\n    for(int i=0;i<n;i++){\n        B[i]=A[i];\n        V[i]=false;\n    }   \n    sort(B,B+n);        \n    for(int i=0;i<n;i++)T[B[i]]=i;\n    for(int i=0;i<n;i++){\n        if(V[i])continue;\n        int S=0;\n        int cur=i;\n        int m=VMAX;\n        int an=0;\n        while(1){\n            V[cur]=true;\n            an++;\n            m=min(m,A[cur]);\n            S+=A[cur];\n            cur=T[A[cur]];\n            if(V[cur])break;                                              \n        }   \n        ans+=min(S+(an-2)*m,m+S+(an+1)*s);\n    }   \n    return ans;\n\n}\nint main(){\n    cin>>n;\n    s=VMAX;\n    for(int i=0;i<n;i++){\n        cin>>A[i];\n        s=min(s,A[i]);\n    }   \n    int ans=solve();\n    cout<<ans<<\"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint solve(){\n    int ans = 0;\n\n    bool V[MAX];\n    for(int i=0; i<n; ++i){\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B, B+n);\n    for(int i=0; i<n; ++i) T[B[i]] = i;\n    for(int i=0; i<n; ++i){\n        if(V[i]) continue;\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while(true){\n            V[cur] = true;\n            ++an;\n            int v = A[cur];\n            m = min(m, v);\n            S += v;\n            cur = T[v];\n            if(V[cur]) break;\n        }\n        ans += min(S + (an - 2)*m, m + S + (an + 1)*s);\n    }\n\n    return ans;\n}\n\nint main(){\n    cin >> n;\n    s = VMAX;\n    for(int i=0; i<n; ++i){\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n\n    cout << solve() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve(){\n    int ans = 0;\n\n    bool V[MAX];\n    for(int i = 0;i<n;i++){\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B,B+n);\n    for(int i = 0;i<n;i++)\n        T[B[i]] = i;\n    for(int i = 0;i<n;i++){\n        if(V[i])\n            continue;\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        do{\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m,v);\n            S += v;\n            cur = T[v];\n        }while(!V[cur]);\n        ans += min(S + (an - 2)*m, m+S+(an+1)*s);\n    }\n    return ans;\n}\n\nint main(){\n    cin>>n;\n    s = VMAX;\n    for(int i = 0;i<n;i++){\n        cin>>A[i];\n        s = min(s,A[i]);\n    }\n    int ans = solve();\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <climits>\nusing namespace  std;\n\nstruct StCst\n{\n  int m_nNo;\n  int m_nSeq;\n  bool m_bDone;\n\n  static bool AsdNo(const StCst &cnroLeft, const StCst &cnroRight) \n  { return cnroLeft.m_nNo < cnroRight.m_nNo; }\n};\n\nvoid fnInput(int &rnMaxSiz, vector<StCst> &rvoSort)\n{\n  int nCnt = 0;\n  cin >> rnMaxSiz;\n\n  rvoSort.resize(rnMaxSiz);\n  for (int i = 0; i < rnMaxSiz; i++)\n  {\n    cin >> rvoSort[i].m_nNo;\n    rvoSort[i].m_nSeq = nCnt++;\n  }\n}\n\nvoid fnMinCostSort(vector<StCst> &rvoSort, int &rnSwpCnt)\n{\n  sort(begin(rvoSort), end(rvoSort), StCst::AsdNo);\n  int nMinNo = rvoSort[0].m_nNo;\n\n  int nCost;\n  for (int i = 0; i < rvoSort.size(); i++)\n  {\n    if (rvoSort[i].m_bDone)  continue;\n\n    int nTotal = rvoSort[i].m_nNo;\n    int nCurSize = 1;\n    int nCurMin = rvoSort[i].m_nNo; \n    rvoSort[i].m_bDone = true;\n\n    int j = rvoSort[i].m_nSeq;\n    while  (rvoSort[j].m_nNo != rvoSort[i].m_nNo)\n    {\n      nTotal += rvoSort[j].m_nNo;\n      nCurSize++;\n      nCurMin = min(nCurMin, rvoSort[j].m_nNo);\n      rvoSort[j].m_bDone = true;\n      j = rvoSort[j].m_nSeq;\n    }\n\n    if (nCurSize == 1)\n        nCost = 0;\n    else\n        nCost = min(nTotal + (nCurSize - 2) * nCurMin, \n                    nTotal + nCurMin + (nCurSize + 1) * nMinNo);\n    rnSwpCnt += nCost;\n  }\n}\n\nvoid fnResult(int nSwpCnt)\n{\n  cout << nSwpCnt << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int nMaxSiz;\n  vector<StCst> voSort;\n\n  fnInput(nMaxSiz, voSort);\n\n  int nSwpCnt = 0;\n  fnMinCostSort(voSort, nSwpCnt);\n\n  fnResult(nSwpCnt);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\n    int n , i , j ;\n    int min, minj, wsum = 0;\n\n    scanf(\"%d\", &n);\n\n    int w[n], A[n];\n\n    for( i = 0 ; i < n ; i++ ){\n        \n        scanf(\"%d\", &w[i]);\n\n        A[i] = w[i];\n        \n    }\n\n    sort( A, A + n );\n\n    for( i = 0 ; i < n ; i++ ){\n\n        min = w[i];\n\n        minj = i;\n\n        for( j = i + 1 ; j < n ; j++ ){\n\n            if( min > w[j] ){\n\n                min = w[j];\n                minj = j;\n\n            }\n\n        }\n\n        for( j = i + 1 ; j < n ; j++ ){\n\n            if( w[j] == A[minj] && j != minj ){\n\n                wsum += w[j] + min;\n                swap( w[j], w[minj] );\n\n                minj = j;\n\n                j = 0;\n\n                if( minj == i ) break;\n\n            }\n\n        }\n\n\n        if( minj != i ){\n\n            wsum = wsum + w[i] + w[minj];\n\n            swap( w[i], w[minj] ); \n\n        } else {}\n\n    }\n\n    printf(\"%d\\n\", wsum);\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// returns the index of the element in list which should be in sorted_index\nint getIndex(vector< int > list,\n\t     vector< int > sorted_list,\n\t     int sorted_index) {\n  for (int i = 0; i < list.size(); i++)\n    if (list[i] == sorted_list[sorted_index])\n      return i;\n}\n\npair< vector< int >, int > getCycleCost(vector< int > list,\n\t\t\t\t\tvector< int > sorted_list,\n\t\t\t\t\tint sorted_index) {\n  int cost = 0;\n  while (getIndex(list, sorted_list, sorted_index) != sorted_index) {\n    int first_swap = getIndex(list, sorted_list, sorted_index);\n    int second_swap = getIndex(list, sorted_list, first_swap);\n    int holder = list[first_swap];\n    list[first_swap] = list[second_swap];\n    list[second_swap] = holder;\n    cost += list[first_swap] + list[second_swap];\n  }\n  return pair< vector< int >, int > (list, cost);\n}\n\npair< vector< int >, int > getCycleCostWithGlobalMinSwap(vector< int > list,\n\t\t\t\t\t\t\t vector< int > sorted_list,\n\t\t\t\t\t\t\t int sorted_index) {\n  int holder = list[0];\n  int swap_index = getIndex(list, sorted_list, sorted_index);\n  list[0] = list[swap_index];\n  list[swap_index] = holder;\n  int cost = list[0] + list[swap_index];\n  pair< vector< int >, int > cycle_sol = getCycleCost(list, sorted_list, 0);\n  cycle_sol.second += cost;\n  return cycle_sol;\n}\n\nint main(int argc, char **argv) {\n  ios_base::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  vector< int > list (n, 0);\n  for (int i = 0; i < n; i++)\n    cin >> list[i];\n  // sort the list\n  vector< int > sorted_list (list);\n  sort(sorted_list.begin(), sorted_list.end());\n  int sort_index = 0;\n  int totalcost = 0;\n  while (sort_index < n) {\n    if (getIndex(list, sorted_list, sort_index) == sort_index)\n      sort_index++;\n    // if the lowest value after sort_index isn't in the right spot\n    else {\n      pair< vector< int >, int > holder = getCycleCost(list, sorted_list, sort_index);\n      // if the globally lowest value is not in the correct spot\n      if (!sort_index) {\n\tlist = holder.first;\n\ttotalcost += holder.second;\n      } else {\n\tpair< vector< int >, int > gholder = getCycleCostWithGlobalMinSwap(list, sorted_list, sort_index);\n\tif (gholder.second < holder.second) {\n\t  list = gholder.first;\n\t  totalcost += gholder.second;\n\t} else {\n\t  list = holder.first;\n\t  totalcost += holder.second;\n\t}\n      }\n    }\n  }\n  cout << totalcost << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\nint solve(){\nint ans = 0;\nbool V[MAX];\nfor(int i = 0; i < n; i++){\nB[i] = A[i];\nV[i] = false;\n}\nsort(B, B+n);\nfor(int i = 0; i < n; i++) T[B[i]] = i;\nfor(int i = 0; i < n; i++){ \nif(V[i]) continue;\nint cur = i;\nint S = 0;\nint m = VMAX;\nint an = 0;\nwhile(1){\nV[cur] = true;\nan++;\nint v = A[cur];\nm = min(m, v);\nS += v;\nif(V[cur]) break;\n}\nans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n}\nreturn ans;\n}\nint main(){\ncin >> n;\ns = VMAX;\n}\nint ans = solve();\ncout << ans << endl;\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <climits>\nusing namespace  std;\n\nstruct StCst\n{\n  int m_nNo;\n  int m_nInSeq;\n  bool m_bDone;\n\n  static bool AsdNo(const StCst& roLeft, const StCst& roRight) { return roLeft.m_nNo < roRight.m_nNo; }\n};\n\nvoid fnInput(int &rnMaxSiz, vector<StCst> &rvoSort, int &rnMinNo)\n{\n  int nCnt = 0;\n  cin >> rnMaxSiz;\n\n  rvoSort.resize(rnMaxSiz);\n  for (int i = 0; i < rnMaxSiz; i++)\n  {\n    cin >> rvoSort[i].m_nNo;\n    rnMinNo = min(rnMinNo, rvoSort[i].m_nNo);\n    rvoSort[i].m_nInSeq = nCnt++;\n  }\n}\n\nvoid fnMinCostSort(vector<StCst> &rvoSort, int nMinNo, int &rnSwpCnt)\n{\n  sort(begin(rvoSort), end(rvoSort), StCst::AsdNo);\n\n  int nCost;\n  for (int i = 0; i < rvoSort.size(); i++)\n  {\n    if (rvoSort[i].m_bDone)  continue;\n\n    int nTotal = rvoSort[i].m_nNo;\n    int nCurSize = 1;\n    int nCurMin = rvoSort[i].m_nNo; \n    rvoSort[i].m_bDone = true;\n\n    int j = rvoSort[i].m_nInSeq;\n    while  (rvoSort[j].m_nInSeq != rvoSort[i].m_nInSeq)\n    {\n      nTotal += rvoSort[j].m_nNo;\n      nCurSize++;\n      nCurMin = min(nCurMin, rvoSort[j].m_nInSeq);\n      rvoSort[j].m_bDone = true;\n      j = rvoSort[j].m_nInSeq;\n    }\n\n    if (nCurSize == 1)\n        nCost = 0;\n    else\n      if (nMinNo == nCurMin)\n        nCost = nTotal + (nCurSize - 2) * nCurMin;\n      else\n        nCost = min(nTotal + (nCurSize - 2) * nCurMin, \n                    nTotal + nCurMin + (nCurSize + 1) * nMinNo);\n    rnSwpCnt += nCost;\n  }\n}\n\nvoid fnResult(int nSwpCnt)\n{\n  cout << nSwpCnt << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int nMaxSiz;\n  vector<StCst> voSort;\n  int nMinNo = INT_MAX;\n\n  fnInput(nMaxSiz, voSort, nMinNo);\n\n  int nSwpCnt = 0;\n  fnMinCostSort(voSort, nMinNo, nSwpCnt);\n\n  fnResult(nSwpCnt);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve() {\n\tint ans = 0;\n\n\tbool V[MAX];\n\tfor (int i = 0; i < n; i++) {\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; i++)T[B[i]] = i;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (V[i])continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile (1) {\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif (V[cur])break;\n\t\t}\n\t\tans += min(S + (an - 2)*m, m + S + (an + 1)*s);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tcin >> n;\n\ts = VMAX;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tint ans = solve();\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n \nstatic const long MAX = 1000;\nstatic const long VMAX = 10000;\n \nlong n, A[MAX], s;\nlong B[MAX], T[VMAX + 1];\n \nlong solve(){\n    long ans = 0;\n    bool V[MAX];\n    for (long i = 0; i < n; i++){\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B, B + n);\n    for (long i = 0; i < n; i++) T[B[i]] = i;\n    for (long i = 0; i < n; i++){\n        if (V[i]) continue;\n        long cur = i, S = 0, m = VMAX, an = 0;\n        while (1){\n            V[cur] = true;\n            an++;\n            long v = A[cur];\n            m = min(m, v);\n            S += v;\n            cur = T[v];\n            if (V[cur]) break;\n        }\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n    }\n    return ans;\n}\n \nint main(){\n    cin >> n;\n    s = VMAX;\n    for (long i = 0; i < n; i++){\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n    long ans = solve();\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve(){\n\tint ans = 0;\n\n\tbool V[MAX];\n\tfor (int i = 0; i < n; i++) {\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; i++)T[B[i]] = i;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (V[i])continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile (1) {\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\t{\n\t\t\tcur = T[[v];\n\t\t\tif (V[cur])break;\n\t\t}\n\t\tans += min(S + (an - 2)*m, m + S + (an + 1)*s);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tcin >> n;\n\ts = VMAX;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tint ans = solve();\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int VMAX = 10000 + 1;\nconst int MAX = 1000;\nint s;\nint W[MAX];\nint B[MAX], T[VMAX];\n\nint solve(int n) {\n  int ans {0};\n  bool V[MAX];\n\n  for (int i = 0; i < n; i++) {\n    B[i] = W[i];\n    V[i] = false;\n  }\n\n  sort(B, B+n);\n  for (int i = 0; i < n; i++) T[B[i]] = i;\n\n  for (int i = 0; i < n; i++) {\n    int currrent_index = i;\n    int S = 0;\n    int m = VMAX;\n    int an = 0;\n    if ( V[i] ) continue;\n    while (true) {\n      V[currrent_index] = true;\n      an++;\n      int v = W[currrent_index];\n      m = min(m, v);\n      S += v;\n      currrent_index = T[v];\n      if (V[currrent_index]) break;\n    }\n    ans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n  }\n  return ans;\n}\n\nint main() {\n  int n {0};\n  cin >> n;\n  s = VMAX;\n  for (int i = 0; i < n; i++) {\n    cin >> W[i];\n    s = min(s, W[i]);\n  }\n  int ans = solve(n);\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\n\tint n;\n\tcin >> n;\n\n\tvector<vector<int>> a(n, vector<int> (2,0));\n\tint minval = 100000;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i][0];\n\t\tminval = min(minval, a[i][0]);\n\t}\n\n\tbool finflg = false;\n\tint total = 0;\n\tvector < vector<int>> b(n, vector<int>(2, 0));\n\tb = a;\n\tvector < vector<int>> c(n, vector<int>(2, 0));\n\tc = a;\n\n\tsort(b.begin(), b.end());\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (c[i][0] == b[j][0]) {\n\t\t\t\ta[i][0] = j + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tint i = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (a[i][1] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i == n - 1) { finflg = true; }\n\t\t}\n\t\tif (finflg == true) { break; }\n\n\n\t\tvector<int> subar;\n\t\tsubar.push_back(c[i][0]);\n\t\tint j;\n\t\tj= a[i][0]-1;\n\t\tif (j != 0 && j+1!=a[j][0]) {\n\t\t\twhile (subar[0] !=c[j][0]) {\n\t\t\t\tsubar.push_back(c[j][0]);\n\t\t\t\tj = a[j][0]-1;\n\t\t\t}\n\t\t\tsort(subar.begin(), subar.end());\n\n\t\t\tint cand1= accumulate(subar.begin(), subar.end(), 0) + subar[0] * (subar.size() - 2);\n\t\t\tint cand2 = accumulate(subar.begin(), subar.end(), 0) + subar[0] + (subar.size() + 1)*minval;\n\t\t\ttotal += min(cand1, cand2);\n\t\t}\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = 0; j < subar.size(); j++) {\n\t\t\t\tif (c[i][0] == subar[j]) {\n\t\t\t\t\ta[i][1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tcout << total << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct QuickFind {\n  vint i2g;\n  vector<vint> g2i;\n  QuickFind(int n) {\n    i2g.clear(); i2g.resize(n);\n    g2i.clear(); g2i.resize(n);\n    rep(i, n) i2g[i] = i, g2i[i].assign(1, i);\n  }\n  void merge(int ia, int ib) {\n    if(g2i[i2g[ia]].size() < g2i[i2g[ib]].size()) swap(ia, ib);\n\n    int ga = i2g[ia], gb = i2g[ib];\n    if(ga == gb) return;\n    for(int j : g2i[gb]) i2g[j] = ga;\n    g2i[ga].insert(g2i[ga].end(), all(g2i[gb]));\n    g2i[gb].clear();\n  }\n  bool is_same_group(int ia, int ib) {\n    return i2g[ia] == i2g[ib];\n  }\n};\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n;\n  cin >> n;\n  vint w(n);\n  rep(i, n) cin >> w[i];\n  vint v = w;\n  sort(all(v));\n  QuickFind qf(n);\n  rep(i, n) qf.merge(lower_bound(all(v), w[i])-v.begin(), i);\n  int ans = 0;\n  rep(i, n) {\n    int sum = 0;\n    int mn = inf;\n    int sz = qf.g2i[i].size();\n    if(sz == 0) continue;\n    rep(j, sz) {\n      sum += v[qf.g2i[i][j]];\n      chmin(mn, v[qf.g2i[i][j]]);\n    }\n    ans += min((sum-mn)+(sz-1)*mn, (sum-mn)+(sz-1)*v[0]+(v[0]+mn)*2);\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint solve(int n, vector<int> & ws);\n\nint main()\n{\n    int n = 0;\n    cin >> n;\n    vector<int> ws(n);\n    for (auto & w : ws) cin >> w;\n    cout << solve(n, ws) << endl;\n    return 0;\n}\n\nint solve(int n, vector<int> & ws){\n    vector<int> i2w;\n    int w2i[10001] = {0};\n    for (auto w : ws) w2i[w] = 1;\n    int cum = 0;\n    for (int w = 0; w != 10001; ++w){\n        if (w2i[w]){\n            w2i[w] = cum++;\n            i2w.push_back(w);\n        }\n    }\n    vector<int> as;\n    for (auto w : ws) as.push_back(w2i[w]);\n    \n    // loop ???????????????????§?????????????????¨???????\n    int cum_cost = 0;\n    for (int i = 0; i != n; ++i){\n        int start = i;\n        int pos = as[i];\n        int cost = 0;\n        int swap_counts = 0;\n        while (pos != start){\n            ++swap_counts;\n            cost += i2w[pos];\n            pos = as[pos];\n        }\n        int cost_original = i2w[start] * swap_counts;\n        int cost_with_swap = i2w[0] * swap_counts + (i2w[start] + i2w[0]) * 2;\n        cum_cost += min(cost_original, cost_with_swap);\n    }\n    return cum_cost;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\tint n, c = 0;\n\tint a[1000], b[1000];\n\tbool f[1000];\n\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\n\tmemcpy(b, a, sizeof(a));\n\tsort(b, b + n);\n\tmemset(f, 0, sizeof(f));\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] == b[i])\n\t\t\tf[i] = 1;\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (f[i] == 0){\n\t\t\tfor (int j = i; j < n; j++) {\n\t\t\t\tif (f[j] == 0 && a[j] == b[i]) {\n\t\t\t\t\tfor (int k = i; k < n; k++) {\n\t\t\t\t\t\tif (f[k] == 0 && b[j] == a[k]) {\n\t\t\t\t\t\t\tswap(a[j], a[k]);\n\t\t\t\t\t\t\tc += a[j] + a[k];\n\t\t\t\t\t\t\tf[j] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << c << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n;\n  cin >> n;\n\n  vector<int> a(n);\n  for(int i=0;i<n;i++)cin >> a[i];\n\n  vector<int> order = a, p = a;\n  sort(order.begin(), order.end());\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(a[i] == order[j])p[i] = j;\n    }\n  }\n\n  long long ans = 0;\n  vector<bool> use(n,0);\n  for(int i=0;i<n;i++){\n    if(!use[i]){\n      int cur = i, maxv = 0, sum = 0;\n      do{\n\tuse[cur] = 1;\n\tint cost = a[p[cur]] + a[cur];\n\tmaxv = max(maxv, cost);\n\tsum += cost;\n\tcur = p[cur];\n      }while(cur!=i);\n      ans += sum - maxv;\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\nconst int maxn=1e3+5;\nconst int N=1e4+5;\n\nint s[maxn],b[maxn],n,minn=N,book[maxn],weizhi[N];\n\nint solve()\n{\n    int ans=0;\n    for(int i=0;i<n;i++){\n        b[i]=s[i];\n    }\n    sort(b,b+n);\n    for(int i=0;i<n;i++){\n        weizhi[b[i]]=i;\n    }\n//    for(int i=1;i<=10;i++){\n//        cout<<weizhi[i]<<\" \";\n//    }\n//    cout<<endl;\n    for(int i=0;i<n;i++){\n        if(book[i]){\n            continue;\n        }\n        int cnt=0,cixiao=N,cur=i,temp=0;\n        while(1){\n            book[cur]=1;\n            int v=s[cur];\n            temp+=v;\n            cnt++;\n            cixiao=min(cixiao,s[cur]);\n            cur=weizhi[s[cur]];\n            if(book[cur]){\n                break;\n            }\n        }\n        ans+=min(temp+(cnt-2)*cixiao,cixiao+temp+(cnt+1)*minn);\n    }\n    return ans;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&s[i]);\n        minn=min(s[i],minn);\n    }\n  //  cout<<minn<<endl;\n    int ans=solve();\n    cout<<ans<<endl;\n    return 0;\n}\n/*\n5\n1 5 3 4 2\n6\n2 1 8 10 7 9\n7\n4 3 2 7 1 6 5\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main(){\n\tint n;\n\tcin >> n;\n\t\n\tvector<int> inp(n);\n\tvector<P> input(n);\n\t\n\tfor (int i=0;i<n;i++){\n\t\tinput[i].second = i;\n\t\tcin >> input[i].first;\n\t\tinp[i]=input[i].first;\n\t}\n\t\n\tsort(input.rbegin(),input.rend());\n\t\n\tint count=0;\n\t\n\tfor (int i=0;i<n-1;i++){\n\t\tif(input[i].second>n-i-1){\n\t\t\tswap(inp[input[i].second],inp[n-i-1]);\n\t\t\tcount+=(inp[input[i].second]+inp[n-i-1]);\n\t\t\tswap(input[input[i].second].second,input[n-i-1].second);\n\t\t}\n\t\t\n\t}\n\t\n\tcout << count <<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nstruct QuickFind{\n  vector<int> r,p;\n  vector<vector<int> > v;\n  QuickFind(){}\n  QuickFind(int size){init(size);}\n  void init(int size){\n    r.resize(size,0);\n    p.resize(size,0);\n    v.resize(size);\n    for(int i=0;i<size;i++){\n      r[i]=1,p[i]=i;\n      v[i].resize(1,i);\n    }\n  }\n  bool same(int x,int y){\n    return p[x]==p[y];\n  }\n  void unite(int x,int y){\n    x=p[x];y=p[y];\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    for(int i=0;i<(int)v[y].size();i++){\n      p[v[y][i]]=x;\n      v[x].push_back(v[y][i]);\n    }\n    v[y].clear();\n  }\n};\nsigned main(){\n  int n;\n  cin>>n;\n  vector<int> a(n);\n  for(int i=0;i<n;i++) cin>>a[i];\n  vector<int> b(a);\n  sort(b.begin(),b.end());\n  map<int,int> p,q;\n  for(int i=0;i<n;i++){\n    p[a[i]]=i;\n    q[b[i]]=i;\n  }\n  QuickFind qf(n);\n  for(int i=0;i<n;i++) \n    qf.unite(i,p[b[i]]);\n  //for(int i=0;i<n;i++) cout<<i<<\" \"<<p[b[i]]<<endl;\n  int ans=0;\n  for(int i=0;i<n;i++){\n    int k=qf.v[i].size();\n    if(qf.p[i]!=i||k==1) continue;\n    int m=a[qf.v[i][0]];\n    int tmp=0;\n    for(int j=0;j<k;j++){\n      //cout<<\" \"<<a[qf.v[i][j]];\n      tmp+=a[qf.v[i][j]];\n      m=min(m,a[qf.v[i][j]]);\n    }\n    //cout<<endl;\n    ans+=min(tmp+m*(k-2),tmp+m+b[0]*(k+1));\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define N 40\n\nbool comp1(const pair<int, int> &a, const pair<int, int> &b)\n{\n    return a.first < b.first;\n}\nbool comp2(const pair<int, int> &a, const pair<int, int> &b)\n{\n    return a.second < b.second;\n}\nint main()\n{\n    int n;\n    cin >> n;\n    int w[n], x[n];\n    for (int i = 0; i < n; i++)\n    {\n        cin >> w[i];\n        x[i] = w[i];\n    }\n\n    sort(x, x + n);\n\n    int *p, *q, *r;\n    int sum = 0, tmp;\n    for (int i = 0; i < n; i++)\n    {\n        p = find(w, w + n, x[i]);\n        if (w[i] == x[p - w] && i != p - w)\n        {\n            tmp = w[i];\n            w[i] = *p;\n            *p = tmp;\n            sum += w[i] + *p;\n        }\n    }\n\n    r = find(w, w + n, x[0]);\n\n    for (int i = 0; i < n; i++)\n    {\n        p = find(w, w + n, x[i]);\n        if (i == p - w)\n            continue;\n        if (r == w)\n        {\n            tmp = *p;\n            *p = *r;\n            *r = tmp;\n            sum += *p + *r;\n        }\n\n        while (p != w)\n        {\n            q = find(w, w + n, x[p - w]);\n            tmp = *p;\n            *p = *q;\n            *q = tmp;\n            sum += *p + *q;\n            p = q;\n        }\n    }\n\n    cout << sum << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n\nconst int INF = 100000;\n\nint main() {\n  cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<int> w;\n  for (auto i = 0; i < n; ++i) {\n    int t;\n    cin >> t;\n    w.push_back(t);\n  }\n\n  vector<int> v = w;\n  sort(v.begin(), v.end());\n\n  map<int, int> m;\n  for (auto i = 0; i < n; ++i) {\n    m[v[i]] = i;\n  }\n\n  vector<int> u;\n  for (auto i = 0; i < n; ++i) {\n    u.push_back(false);\n  }\n\n  int p = 0;\n  int s = 0;\n  while (p < n) {\n    if (u[p]) {\n      ++p;\n      continue;\n    }\n    u[p] = true;\n    int t = w[p];\n    int r = INF;\n    int c = 1;\n    int q = m[w[p]];\n    if (p == q) {\n      continue;\n    }\n    while (p != q) {\n      u[q] = true;\n      t += w[q];\n      if (w[q] < r) {\n        r = w[q];\n      }\n      q = m[w[q]];\n      ++c;\n    }\n    s += min(t + (c - 2) * r, t + r + (c + 1) * v[0]);\n  }\n\n  cout << s << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint solve () {\n\tint ans = 0;\n\tbool V[MAX];\n\tfor ( int  i = 0; i < n; i++ ) {\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B,B+n);\n\tfor ( int i = 0; i < n; i++ ) T[B[i]] = i;\n\tfor ( int i = 0; i < n; i++ ) {\n\t\tif ( V[i] ) continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile ( 1 ) {\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m,v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif ( V[cur] ) break;\n\t\t}\n\t\tans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n\t} \n\treturn ans;\n}\n\nint main(){\n\tcin >> n;\n\ts = VMAX;\n\tfor ( int i = 0; i < n; i++ ) {\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tint ans = solve();\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdlib>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nconst int MAXN = (int) 1e3 + 10;\nconst int INF = (int) 0x3f3f3f3f;\ntypedef long long LL;\n\nint N;\nint arr[MAXN],b[MAXN];\nint p[MAXN];\nint siz[MAXN],mi[MAXN],sum[MAXN];\n\nint Find(int x){\n    return x==p[x] ? x : p[x]=Find(p[x]);\n}\n\nvoid work(){\n    scanf(\"%d\",&N);\n    for(int i=1;i<=N;i++) scanf(\"%d\",&arr[i]);\n    for(int i=1;i<=N;i++) b[i]=arr[i];\n    sort(b+1,b+1+N);\n//    for(int i=1;i<=N;i++) printf(\"%d \",b[i]);\n//    printf(\"\\n\");\n    for(int i=1;i<=N;i++) p[i]=i,siz[i]=1,mi[i]=sum[i]=arr[i];\n    for(int i=1;i<=N;i++){\n        int x=Find(i);\n        int id=lower_bound(b+1,b+1+N,arr[i])-b;\n        int y=Find(id);\n        if(x!=y){\n            p[x]=y;\n            mi[y]=min(mi[y],mi[x]);\n            siz[y]+=siz[x];\n            sum[y]+=sum[x];\n        }\n    }\n    int ans=0;\n    for(int i=1;i<=N;i++)if(p[i]==i){\n        if(siz[i]==2) ans+=sum[i];\n        else if(siz[i]>2){\n            int tmpmi=min(mi[i]+sum[i]+(siz[i]+1)*b[1],sum[i]+(siz[i]-2)*mi[i]);\n            ans+=tmpmi;\n        }\n    }\n    printf(\"%d\\n\",ans);\n}\n\nint main(){\n    work();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\nconst int maxn=1e3+5;\nconst int N=1e4+5;\n\nint s[maxn],b[maxn],n,minn=N,book[maxn],weizhi[N];\n\nint solve()\n{\n    int ans=0;\n    for(int i=0;i<n;i++){\n        b[i]=s[i];\n    }\n    sort(b,b+n);\n    for(int i=0;i<n;i++){\n        weizhi[b[i]]=i;\n    }\n//    for(int i=1;i<=10;i++){\n//        cout<<weizhi[i]<<\" \";\n//    }\n//    cout<<endl;\n    for(int i=0;i<n;i++){\n        if(book[i]){\n            continue;\n        }\n        int cnt=0,cixiao=N,cur=i,temp=0;\n        while(1){\n            book[cur]=1;\n            temp+=s[cur];\n            cnt++;\n            cixiao=min(cixiao,s[cur]);\n            cur=weizhi[s[cur]];\n            if(book[cur]){\n                break;\n            }\n        }\n        ans+=min(temp+(cnt-2)*cixiao,cixiao+temp+(cnt-1)*minn);\n    }\n    return ans;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&s[i]);\n        minn=min(s[i],minn);\n    }\n  //  cout<<minn<<endl;\n    int ans=solve();\n    cout<<ans<<endl;\n    return 0;\n}\n/*\n5\n1 5 3 4 2\n6\n2 1 8 10 7 9\n7\n4 3 2 7 1 6 5\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define WEIGHT_MAX 10000\n\nint partition(int *a, int p, int r){\n    int x = a[r];\n    int i = p - 1;\n    int tmp1;\n    for(int j=p;j<r;j++){\n        if(a[j]<=x){\n            i++;\n            tmp1 = a[j];\n            a[j] = a[i];\n            a[i] = tmp1;\n        }\n    }\n    a[r] = a[i+1];\n    a[i+1] = x;\n    return i + 1;\n}\n\nvoid quickSort(int *a, int p, int r){\n    if(p>=r)return;\n    int q = partition(a, p, r);\n    quickSort(a, p, q-1);\n    quickSort(a, q+1, r);\n}\n\nint calc(int *w, int *s, int *p, int hoge, int n){\n    if(hoge==n)return 0;\n    int p0 = p[s[hoge]];\n    if(p0==hoge)return calc(w,s,p,hoge+1,n);\n    int p1 = p[s[p0]];\n    p[s[hoge]] = p1;\n    p[s[p0]] = p0;\n    if(p1==hoge)return s[hoge]+s[p0]+calc(w,s,p,hoge+1,n);\n    else return s[hoge]+s[p0]+calc(w,s,p,hoge,n);\n}\n\nint main(){\n    int i, n;\n    int p[WEIGHT_MAX+1];\n    scanf(\"%d\",&n);\n    int w[n];\n    int s[n];\n    for(i=0;i<n;i++){\n        scanf(\"%d\",w+i);\n        s[i]=w[i];\n        p[w[i]]=i;\n    }\n    quickSort(s,0,n-1);\n    int cost = calc(w,s,p,0,n);\n    printf(\"%d\\n\",cost);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#define _USE_MATH_DEFINES\n#include <cmath>\n\n#define rep(i, n)     for (int (i) = 0; (i) < (n); (i)++)\n#define rep1(i, n)    for (int i = 1; i <= (int)(n); i++)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1000;\nconst int MAXV = 10100;\n\nint main() {\n   int n, W[MAXN], W_sort[MAXN], cnt[MAXN], num[MAXV];\n   int min_w = 10100;\n   int ans = 0;\n\n   cin >> n;\n   rep(i, n) {\n      scanf(\"%d\", &W[i]);\n      min_w = min(min_w, W[i]);\n      W_sort[i] = W[i];\n   }\n   rep(i, MAXN) {\n      cnt[i] = 0;\n   }\n   sort(W_sort, W_sort + n);\n   rep(i, n) {\n      num[W_sort[i]] = i;\n   }\n\n\n   for (int i = 0; i < n; i++) {\n      if (cnt[i] == 1) continue;\n      int j = i;\n      int csum = 0;\n      int cmin = 10100;\n      int cntl = 0;\n      do {\n         cntl++;\n         csum += W[j];\n         cmin  = min(cmin, W[j]);\n         cnt[j] = 1;\n         j = num[W[j]];\n      } while (i != j);\n      ans += min(csum + cmin * (cntl - 2), csum + min_w * (cntl + 1) + cmin);\n   }\n\n   cout << ans << endl;\n   return(0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <unordered_map>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nnamespace std{\n\ttemplate<typename T>\n\tinline void hash_combine(size_t& seed, T const& v){\n\t\tseed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n\t}\n    template<typename It>\n    inline size_t hash_range(It first, It last){\n\t\tsize_t seed=0;\n\t\thash_range(seed,first,last);\n\t\treturn seed;\n\t}\n\ttemplate<typename It>\n\tinline void hash_range(size_t& seed, It first, It last){\n\t\tfor(;first!=last;++first)hash_combine(seed, *first);\n\t}\n\ttemplate<typename A,typename B>\n\tclass hash<pair<A,B>>{\n\t\tpublic:\n\t\tsize_t operator()(pair<A,B> const &p) const{\n\t\t\tsize_t seed=0;\n\t\t\thash_combine(seed,p.first);\n\t\t\thash_combine(seed,p.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\ttemplate<typename T,size_t N>\n\tclass hash<array<T,N>>{\n\t\tpublic:\n\t\tsize_t operator()(array<T,N> const &container) const{\n\t\t\treturn hash_range(container.begin(),container.end());\n\t\t}\n\t};\n\ttemplate<typename T,typename A>\n\tclass hash<vector<T,A>>{\n\t\tpublic:\n\t\tsize_t operator()(vector<T,A> const &container) const{\n\t\t\treturn hash_range(container.begin(),container.end());\n\t\t}\n\t};\n}\n\nint main(){\n\tint N;\n\tscanf(\"%d\",&N);\n\tvector<char>v(N);\n\tfor(int i=0;i<N;i++)scanf(\"%d\",&v[i]);\n\tpriority_queue<pair<int,vector<char> > >q;\n\tunordered_map<vector<char>,int>depth;\n\n\tq.push(make_pair(0,v));\n\tint R;\n\tfor(;!q.empty();){\n\t\tauto cur=q.top();\n\t\tq.pop();\n\t\tif(depth.find(cur.second)!=depth.end())continue;\n\t\tdepth[cur.second]=cur.first;\n\t\tbool f=false;\n\t\tfor(int i=0;i<N-1;i++)for(int j=i+1;j<N;j++){\n\t\t\tif(cur.second[i]>cur.second[j])f=true;\n\t\t\tswap(cur.second[i],cur.second[j]);\n\t\t\tif(depth.find(cur.second)==depth.end())q.push(make_pair(cur.first-cur.second[i]-cur.second[j],cur.second));\n\t\t\tswap(cur.second[i],cur.second[j]);\n\t\t}\n\t\tif(!f){\n\t\t\tR=-cur.first;\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",R);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n    int n;\n    cin >> n;\n    int A[n];\n    int B[n];\n    for (int i = 0; i < n; i++) {\n        cin >> A[i];\n        B[i] = A[i];\n    }\n    sort(B, B + n);\n    int cnt = 0;\n    int i = 0;\n    while (i < n) {\n        if (A[i] == B[i]) {\n            i++;\n            continue;\n        }\n        int tgt_idx = find(A, A + n, B[i]) - A;\n        int n_cycle = 1;\n        while (tgt_idx != i) {\n            int dst_idx = find(A, A + n, B[tgt_idx]) - A;\n            cnt += A[tgt_idx] + A[dst_idx];\n            swap(A[tgt_idx], A[dst_idx]);\n            tgt_idx = dst_idx;\n            n_cycle++;\n        }\n        if ((n - 3) * B[i] > (n + 1) * B[0]) {\n            cnt -= (n - 3) * B[i] - (n + 1) * B[0];\n        }\n    }\n    cout << cnt << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//https://onlinejudge.u-aizu.ac.jp/problems/ALDS1_6_D\n//p187.cpp\n\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n , A[MAX] , s ;\nint B[MAX] , T[VMAX + 1];\n\nint solve(){\n\tint ans = 0;\n\n\tbool V[MAX];\n\tfor(int i = 0; i < n; i++){\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B,B+n);\n\tfor(int i = 0; i < n ; i++) T[B[i]] = i;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (V[i])continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile (1) {\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif (V[cur])break;\n\t\t}\n\t\tans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tcin >> n;\n\ts = VMAX;\n\tfor( int i = 0 ; i < n ; i++ ){\n\t\tcin >> A[i];\n\t\ts = min( s , A[i]);\n\t}\n\tint ans = solve();\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n\nconst int INF = 100000;\n\nint main() {\n  cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<int> w;\n  for (auto i = 0; i < n; ++i) {\n    int t;\n    cin >> t;\n    w.push_back(t);\n  }\n\n  vector<int> v = w;\n  sort(v.begin(), v.end());\n\n  map<int, int> m;\n  for (auto i = 0; i < n; ++i) {\n    m[v[i]] = i;\n  }\n\n  vector<int> u;\n  for (auto i = 0; i < n; ++i) {\n    u.push_back(false);\n  }\n\n  int p = 0;\n  int s = 0;\n  while (p < n) {\n    if (u[p]) {\n      ++p;\n      continue;\n    }\n    u[p] = true;\n    int t = w[p];\n    int r = INF;\n    int c = 1;\n    int q = m[w[p]];\n    if (p == q) {\n      continue;\n    }\n    while (p != q) {\n      u[q] = true;\n      t += w[q];\n      if (w[q] < r) {\n        r = w[q];\n      }\n      q = m[w[q]];\n      ++c;\n    }\n    s += min(t + (c - 2) * r, t + r + c * v[0]);\n  }\n\n  cout << s << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 1010;\npii P[MAXN];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> P[i].first;\n        P[i].second = i;\n    }\n    sort(P, P+n);\n    int ans = 0;\n    for (int i = n-1; i >= 0; i--) {\n        if (P[i].second == i) continue;\n        int j;\n        for (j = 0; j < n; j++) {\n            if (P[j].second == i) break;\n        }\n        ans += P[i].first + P[j].first;\n        swap(P[j].second, P[i].second);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nstatic const int MAX=1000;\nstatic const int VMAX=10000;\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve() {\n  int ans=0;\n  bool V[MAX];\n  for (int i=0; i<n; i++) {\n    B[i]=A[i];\n    V[i]=false;\n  }\n  sort(B,B+n);\n  for (int i=0; i<n; i++) {\n    T[B[i]]=i;\n  }\n  for (int i=0; i<n; i++) {\n    if (V[i]) {\n      continue;\n    }\n    int cur=i;\n    int S=0;\n    int m=VMAX;\n    int an=0;\n    while (true) {\n      V[cur]=true;\n      an++;\n      int v=A[cur];\n      m=min(m,v);\n      S+=v;\n      cur=T[v];\n      if (V[cur]) {\n        break;\n      }\n    }\n    ans+=min(S+(an-2)*m,m+S+(an+1)*s);\n  }\n  return ans;\n}\nint main() {\n  cin>>n;\n  s=VMAX;\n  for (int i=0; i<n; i++) {\n    cin>>A[i];\n    s=min(s,A[i]);\n  }\n  int ans=solve();\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define MIN(a,b) ((a)<(b)?(a):(b))\n\nvoid merge(vector<pair<int,int> >& w, int left, int mid, int right) {\n\tvector<pair<int,int> > L,R;\n\tint n1=mid-left;\n\tint n2=right-mid;\n\tint i=0,j=0,k;\n\tL.resize(n1+1);\n\tR.resize(n2+1);\n\tfor(i=0; i<n1; ++i) {\n\t\tL[i]=w[left+i];\n\t}\n\tL[n1].first = -1;\n\tL[n1].second = 1000000001;\n\tfor(i=0; i<n2; ++i) {\n\t\tR[i]=w[mid+i];\n\t}\n\tR[n2].first = -1;\n\tR[n2].second = 1000000001;\n\n\ti=j=0;\n\tfor(k=left; k<right; ++k) {\n\t\tif(L[i].second < R[j].second) {\n\t\t\tw[k]=L[i];\n\t\t\t++i;\n\t\t} else {\n\t\t\tw[k]=R[j];\n\t\t\t++j;\n\t\t}\n\t}\n\treturn;\n}\n\nvoid mergeSort(vector<pair<int,int> >& w, int left, int right) {\n\tif(left+1<right) {\n\t\tint mid=left+(right-left)/2;\n\t\tmergeSort(w,left,mid);\n\t\tmergeSort(w,mid,right);\n\t\tmerge(w,left,mid,right);\n\t}\n\treturn;\n}\n\nint main() {\n\tint n;\n\tint i,j;\n\tint total=0;\n\tint subtotal,c;\n\tvector<int> checker;\n\tvector<pair<int,int> > w; // first=original_index, second =weight_value will be sorted.\n\tscanf(\"%d\",&n);\n\tw.resize(n);\n\tchecker.resize(n);\n\tfor(i=0; i<n; ++i) {\n\t\tchecker[i]=0;\n\t\tw[i].first=i;\n\t\tscanf(\"%d\",&w[i].second);\n\t}\n\tmergeSort(w,0,n);\n\tfor(i=0; i<n; ++i) {\n\t\tif(checker[i]==1 || w[i].first==i) {\n\t\t\tcontinue; // already checked or unmoved\n\t\t}\n\t\tc=subtotal=0;\n\t\tchecker[i]=1;\n\t\tj=w[i].first;\n\t\twhile(j!=i) {\n\t\t\tsubtotal+=w[i].second+w[j].second;\n\t\t\tchecker[j]=1;\n\t\t\tj=w[j].first;\n\t\t\t++c;\n\t\t}\n\t\ttotal+=MIN(subtotal,subtotal-w[j].second*(c-2)+w[0].second*(c+2));\n\t}\n\tprintf(\"%d\\n\",total);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nint N,W[1005],C[1005],c=0,t,p;\nlong long res=0;\nmap<int,int>H;//number2order\nmap<int,int>rH;//order2number\nvector<int>S;\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++)\n\t\tscanf(\"%d\",C+i);\n\tmemcpy(W,C,sizeof(C));\n\tsort(C,C+N);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tH[C[i]]=i;\n\t\trH[i]=C[i];\n\t}\n\tfor(int i=0;i<N;i++)\n\t\tS.push_back(W[i]);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tint nn=rH[i];\n\t\tint np=find(S.begin(),S.end(),nn)-S.begin();\n\t\tfor(;np!=H[nn];)\n\t\t{\n\t\t\tint dn=rH[np];\n\t\t\tint dp=find(S.begin(),S.end(),dn)-S.begin();\n\t\t\tswap(S[np],S[dp]);\n\t\t\tres+=nn+dn;\n\t\t\tnp=dp;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve() {\n\tint ans = 0;\n\n\tbool V[MAX];\n\tfor (int i = 0; i < n; i++) {\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; i++) T[B[i]] = i;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (V[i]) continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile (1) {\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif (V[cur]) break;\n\t\t}\n\t\tans += min(S + (an - 2)*m, m + S + (an + 1)*s);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tcin >> n;\n\ts = VMAX;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tint ans = solve();\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define MAX_N 10000\n#define MAX_V 100000000\n#define INF 1000000000\n\nint n, A[MAX_N], s, B[MAX_N], T[MAX_V];\n\nint minimum_cost_sort() {\n\tint ans = 0;\n\tbool V[MAX_N];\n\tfor (int i = 0; i < MAX_V; i++) { V[i] = false; }\n\tfor (int i = 0; i < n; i++) { B[i] = A[i]; }\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; i++) { T[B[i]] = i; }\n\tfor (int i = 0; i < n; i++) {\n\t\tif (V[i]) { goto owata; }\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = INF;\n\t\tint x = 0;\n\t\twhile (1) {\n\t\t\tV[cur] = true;\n\t\t\tx++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif (V[cur]) { break; }\n\t\t}\n\t\tans += min(S + (x - 2)*m, m + S + (x + 1)*s);\n\towata:;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tcin >> n;\n\ts = INF;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tcout << minimum_cost_sort() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    pair<int,int> w[1000];\n    cin>>n;\n    for(int i=0; i<n; i++) {\n        cin>>w[i].first;\n        w[i].second=i;\n    }\n    sort(w, w+n);\n    int c, cost=0;\n    for(int i=0; i<n; i++) {\n        if(w[i].first!=-1 && w[i].second!=i) {\n            c=w[i].second;\n            while(c!=i) {\n                cost+=w[i].first;\n                cost+=w[c].first;\n                w[c].first=-1;\n                c=w[c].second;\n            }\n        }\n    }\n    cout<<cost<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <map>\n#include <memory>\n#include <set>\n#include <vector>\n#include <deque>\n#include <list>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\nclass MinCostSort\n{\npublic:\n  int solve();\n};\n\nint MinCostSort::solve()\n{\n  int cost = 0;\n  int n;\n  cin >> n;\n  \n  vector<int> w(n, -1);\n  vector<int> sw(n);\n  \n  for ( int i = 0; i < n; ++i )\n    {\n      cin >> w[i];\n      sw[i] = w[i];\n    }\n\n  sort( sw.begin(), sw.end() );\n\n  int mw = sw[0];\n  \n  for ( auto i = 0; i < n; ++i )\n    {\n      if ( w[i] < 0 ) continue;\n      \n      if ( w[i] == sw[i] )\n        {\n          w[i] = -1;\n          sw[i] = -1;\n          continue;\n        }\n      \n      int mlw = 2000;\n      int ii = i;\n      int j;\n      int sm = 0;\n      int ct = 0;\n      \n      while ( true )\n        {\n          for ( j = 0; j < n; ++j )\n            {\n              if ( sw[j] == w[ii] ) break;\n            }\n          if ( mlw > w[ii] ) mlw = w[ii];\n          sm += w[ii];\n          ++ct;\n          w[ii] = -1;\n          sw[j] = -1;\n          ii = j;\n          if ( ii == i ) break;\n        }\n\n      cost += min( sm + (ct - 2) * mlw, sm + (ct + 1) * mw + mlw );\n    }\n  \n  cout << cost << endl;\n  \n  return 0;\n}\n\nint main()\n{\n\n  MinCostSort mcs;\n\n  mcs.solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve() {\n\tint ans = 0;\n\t\n\tbool V[VMAX];\n\tfor(int i = 0; i < n; i++) {\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B, B + n);\n\tfor(int i = 0; i < n; i++) T[B[i]] = i;\n\tfor(int i = 0; i < n; i++) {\n\t\tif( V[i] ) continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint an = 0;\n\t\tint m = VMAX;\n\t\twhile(1) {\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\ts += v;\n\t\t\tcur = T[v];\n\t\t\tif( V[cur] ) break;\t\t\t\n\t\t}\n\t\tans += min(S + (an - 2) * m, S + m +(an + 1) * s);\n\t}\n\t\n\treturn ans;\n} \n\nint main() {\n\tcin >> n;\n\ts = VMAX;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tint ans = solve();\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include<iostream> \n#include<algorithm>\nusing namespace std;\n\nint solve(int A[], int n, int minw) {\n\tint cnt = 0;\n\tint B[n], T[10001];\n\tbool V[n];\n\tfor (int i = 0; i < n; i++) {\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tT[B[i]] = i; //?????????????????????????????§?????????????????????????????????????????????\n\t}\n\tfor (int i = 0; i < n; i++)\t{\n\t\tif (V[i]) continue;\n\t\tint cur = i, S = 0, m = 10000, an = 0;\n\t\twhile(1) {\n\t\t\tV[cur] = true; //????????????\n\t\t\tan++; //?°???°?????????????????°\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v); //?°???°???????????????????°????\n\t\t\tS += v; //????????????\n\t\t\tcur = T[v]; //??¬??\\??????????????\\????????????\n\t\t\tif (V[cur]) break; //????????????????????????????????????\n\t\t}\n\t\tcnt += min(S + (an - 2) * m, S + m + (an + 1) * minw); //????????§????????????while????????§??£?¨?\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tint A[n];\n\tint minw = 10000;\n\tfor (int i = 0; i < n; i++)\t{\n\t\tcin >> A[i];\n\t\tminw = min(minw, A[i]);\n\t}\n\n\tint min = solve(A, n, minw);\n\n\tcout << min << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int num = 1001,num1 = 10000, INF = 2000000000;\nint n, a[num], b[num], c[num1], tf[num], s = INF;\ninline int mini() {\n    int an = 0;\n    int cu = 0;\n    for (int i = 0; i < n; i++) {\n        if (tf[i]) continue;\n        cu = i;\n        int m = INF;\n        int sum = 0;\n        int cnt = 0;\n        while (true) {\n            tf[cu] = 1;\n            int v = a[cu];\n            cnt++;\n            m = min(v, m);\n            sum += v;\n            cu = c[v];\n            if (tf[cu]) break;\n        }\n        an += min(sum + m*(cnt - 2), sum + m*(cnt - 2) + 2 * (m + s) - (m - s)*(cnt - 1));\n    }\n    return an;\n}\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        s = min(a[i], s);\n        b[i] = a[i];\n        tf[i] = 0;\n    }\n    sort(b, b + n);\n    for (int i = 0; i < n; i++) \n        c[b[i]] = i;\n    int ans = mini();\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n\tint n, cost1 = 0, cost2 = 0;\n\tcin >> n;\n\t\n\tint arr1[n], arr2[n], sorted[n];\n\tbool visited[n] = { false };\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr1[i];\n\t\tarr2[i] = sorted[i] = arr1[i];\n\t}\n\tsort(sorted, sorted + n);\n\n\tvector<pair<int, int> > vec;\n\tint mini = 0, s1, s2;\n\twhile (mini < n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (arr1[i] == sorted[mini]) {\n\t\t\t\ts1 = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (arr1[i] == sorted[s1]) {\n\t\t\t\ts2 = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (s1 != s2) {\n\t\t\tvisited[mini] = visited[s1] = true;\n\t\t\tcost1 += arr1[s1] + arr1[s2];\n\t\t\tvec.push_back(make_pair(s1, s2));\n\t\t\tswap(arr1[s1], arr1[s2]);\n\t\t}\n\t\telse {\n\t\t\tmini++;\n\t\t}\n\t}\n\n\ts1 = s2 = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s1 == -1 && visited[i] == true) {\n\t\t\ts1 = i;\n\t\t}\n\t\tif (s2 == -1 && visited[i] == false) {\n\t\t\ts2 = i;\n\t\t}\n\t}\n\n\tif (s1 != -1 && s2 != -1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (arr2[i] == sorted[s1]) {\n\t\t\t\ts1 = i;\n\t\t\t}\n\t\t\tif (arr2[i] == sorted[s2]) {\n\t\t\t\ts2 = i;\n\t\t\t}\n\t\t}\n\n\t\tcost2 += (arr2[s1] + arr2[s2]) * 2;\n\t\tswap(arr2[s1], arr2[s2]);\n\n\t\tint size = vec.size();\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tcost2 += arr2[vec[i].first] + arr2[vec[i].second];\n\t\t\tswap(arr2[vec[i].first], arr2[vec[i].second]);\n\t\t}\n\n\t\tcout << min(cost1, cost2) << endl;\n\t}\n\telse {\n\t\tcout << cost1 << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint solve() {\n    int ans = 0;\n    \n    bool V[MAX];\n    for (int i = 0; i < n; i++) {\n        B[i] = A[i];\n        V[i] = false;\n    } \n    sort(B, B+n);\n    for (int i = 0; i < n; i++)  T[B[i]] = i;\n    for (int i = 0; i < n; i++) {\n        if (V[i] ) continue;\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while(1) {\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m, v);\n         \n           S += v;\n            cur = T[v];\n            if ( V[cur] ) break;\n        }\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n    }\n    \n    return ans;\n}\n\nint main() {\n    cin >> n;\n    s = VMAX;\n    for (int i = 0; i < n; i++) {\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n    int ans = solve();\n    cout << ans << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\nint t,n,a[1009],p,l,m;\ncin>>n;\np=0;l=0;\nfor(int i=0;i<n;i++) cin>>a[i];\nfor(int i=0;i< n; i++){\nm=a[i];\nfor(int j=i+1;j<n;j++){\nif(m > a[j]){\nm=a[j];\nl=j;\n}\n}\nif(a[i]!=m){\np=p+a[i]+a[l];\nswap(a[i],a[l]);\n}\n}\ncout<<p<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nstatic const int MAX=1000;\nstatic const int VAMX=10000;\n\nint n,A[MAX],s;\nint B[MAX],T[VAMX+1];\n\n\nint solve(){\n    int ans=0;\n    bool V[MAX];\n    for(int i=0;i<n;i++){\n        B[i]=A[i];\n        V[i]=false;\n    }\n    sort(B,B+n);//sort(排序数组头,排序数组尾)\n    for(int i=0;i<n;i++) T[B[i]] = i;\n    for(int i=0; i<n; i++){\n        if(V[i]) continue;\n        int cur=i;\n        int S=0;\n        int m=VAMX;\n        int an = 0;\n        while(1){\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m,v);\n            S+=v;\n            cur = T[v];\n            if(V[cur]) break;\n        }\n        ans +=min(S + (an - 2)*m,m + S+(an+1)*s);\n    }\n\n    return ans;\n}\n\n\nint main(){\n    cin >> n;\n    s  = VAMX;\n    for(int i=0; i<n; i++){\n        cin>>A[i];\n        s=min(s,A[i]);\n    }\n    int ans =solve();\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nconst int MAXN = 1010;\nint w[MAXN];\nbool done[MAXN];\nusing namespace std;\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, mini = 100000;\n    cin >> n;\n    map<int, int> mp;\n    for (int i = 0; i < n; i++) {\n        cin >> w[i];\n        mp[w[i]] = 0;\n        mini = min(mini, w[i]);\n    }\n    {\n        int k = 0;\n        for (auto& p : mp) p.second = k++;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (done[i]) continue;\n        int cnt = 0, now = i, mi = 100000, sum = 0;\n        while (1) {\n            if (done[now]) break;\n            cnt++;\n            done[now] = true;\n            mi = min(mi, w[now]);\n            sum += w[now];\n            now = mp[w[now]];\n        }\n        int tmp = sum+(cnt-2)*mi;\n        tmp = min(tmp, sum+mi+mini*(cnt+1));\n        ans += tmp;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<int> w(n), s(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> w[i];\n\t\ts[i] = w[i];\n\t}\n\tsort(s.begin(), s.end());\n\tlong long res = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\twhile (s[i] != w[i]) {\n\t\t\tint wmin, srig;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (w[j] == s[i]) {\n\t\t\t\t\twmin = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (w[j] == s[wmin]) {\n\t\t\t\t\tsrig = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres += w[wmin] + w[srig];\n\t\t\tswap(w[wmin], w[srig]);\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <vector>\n\nint min(int x, int y)\n{\n\treturn x>y ? y : x;\n}\n\nvoid stable_merge(int* perm, int *A, int left, int mid, int right)\n{\n\tint n1 = mid - left;\n\tint n2 = right - mid;\n\tint* L = new int[n1+1];\n\tint* R = new int[n2+1];\n\tint* Lperm = new int[n1];\n\tint* Rperm = new int[n2];\n\tfor (int i=left; i<mid; i++) {\n\t\tL[i-left] = A[i]; Lperm[i-left] = perm[i];\n\t}\n\tfor (int i=mid; i<right; i++) {\n\t\tR[i-mid] = A[i]; Rperm[i-mid] = perm[i];\n\t}\n\tL[n1] = R[n2] = INT_MAX;\n\tint l = 0, r = 0;\n\tfor (int k=left; k<right; k++) {\n\t\tif (L[l] > R[r]) {\n\t\t\tA[k] = R[r]; perm[k] = Rperm[r]; \n\t\t\tr++;\n\t\t} else {\n\t\t\tA[k] = L[l]; perm[k] = Lperm[l];\n\t\t\tl++;\n\t\t}\n\t}\n\tdelete[] L;\n\tdelete[] R;\n\tdelete[] Lperm;\n\tdelete[] Rperm;\n}\n\nvoid stable_mergeSort(int* perm, int *A, int left, int right)\n{\n\tif (left+1 < right) {\n\t\tint mid = (left + right) / 2;\n\t\tstable_mergeSort(perm, A, left, mid);\n\t\tstable_mergeSort(perm, A, mid, right);\n\t\tstable_merge(perm, A, left, mid, right);\n\t}\n}\n\n\nint main()\n{\n\tint n;\n\tstd::cin >> n;\n\t\n\tint* w = new int[n];\n\tfor (int i=0; i<n; i++) std::cin >> w[i];\n\t\n\tint* perm = new int[n];\n\tfor (int i=0; i<n; i++) perm[i] = i;\n\t\t\n\tstable_mergeSort(perm, w, 0, n);\n\t\n\tbool* visited = new bool[n];\n\tfor (int i=0; i<n; i++) visited[i] = false;\n\t\n\tint total_cost = 0;\n\tfor (int i=0; i<n; i++) {\n\t\tif (visited[i]) continue;\n\t\tif (i == perm[i]) continue;\n\t\tstd::vector<int> cycle;\n\t\tint k = i;\n\t\tdo {\n\t\t\tcycle.push_back(k);\n\t\t\tvisited[k] = true;\n\t\t\tk = perm[k];\n\t\t} while (!visited[k]);\n\t\tint cost_of_cycle = min( (cycle.size()-1) * w[i], 2 * w[i] + (cycle.size()+1) * w[0]);\n\t\tfor (int j=1; j<cycle.size(); j++) {\n\t\t\tcost_of_cycle += w[cycle[j]];\n\t\t}\n\t\ttotal_cost += cost_of_cycle;\n\t}\n\t\n\tstd::cout << total_cost << std::endl;\n\t\n\tdelete[] w;\n\tdelete[] perm;\n\tdelete[] visited;\n\t\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<stack>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nconst int MAX=1000;\nconst int VMAX=10000;\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\nint solve()\n{\n\tint ans=0;\n\tbool V[MAX];\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tB[i]=A[i];\n\t\tV[i]=false;\n\t}\n\tsort(B,B+n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tT[B[i]]=i;\n\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(V[i])\n\t\t\tcontinue;\n\t\t\tint cur=i;\n\t\t\tint S=0;\n\t\t\tint m=VMAX;\n\t\t\tint an=0;\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tV[cur]=true;\n\t\t\t\tan++;\n\t\t\t\tint v=A[cur];\n\t\t\t\tm=min(m,v);\n\t\t\t\tS=S+v;\n\t\t\t\tcur=T[v];\n\t\t\t\tif(V[cur])\n\t\t\t\tbreak; \n\t\t\t}\n\t\t\tans=ans+min(S+(an-2)*m,m+S+(an+1)*s);\n\t\t}\t\n\treturn ans;\n}\nint main()\n{\n  cin>>n;\n  s=VMAX;\n  for(int i=0;i<n;i++)\n  {\n  cin>>A[i];\n  s=min(s,A[i]);\n}\nint ans=solve();\ncout<<ans<<endl;\n   \nreturn 0;\n }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n\n  long long int n;\n  cin >> n;\n\n  vector< long long int > v, vs;\n\n  for ( long long int i = 0; i < n; i++ ) {\n\n    long long int in;\n    cin >> in;\n    v.push_back( in );\n    vs.push_back( in );\n\n  }\n\n  sort( vs.begin(), vs.end() );\n\n  vector< long long int > t;\n\n  for ( long long int i = 0; i < n; i++ ) {\n    for ( long long int j = 0; j < n; j++ ) {\n      if ( vs[i] == v[j] ) {\n\tt.push_back( j );\n\tbreak;\n      }\n    }\n  }\n\n  long long int ans = 0;\n  long long int c = -1;\n  long long int m = 0;\n\n  for ( long long int i = 0; i < n; i++ ) {\n\n    for ( long long int j = 0; j < n; j++ ) {\n\n      if ( vs[j] != v[j] ) {\n\n\tlong long int k = v[j];\n\tif ( c == -1 || m > k ) {\n\t  c = j;\n\t  m = k;\n\t}\n\n      }\n\n    }\n\n    if ( c == -1 ) break;\n\n    ans += v[c] + v[ t[c] ];\n    swap( v[c], v[ t[c] ] );\n    for ( long long int j = 0; j < n; j++ ) {\n      if ( t[j] == c ) {\n\tt[j] = t[c];\n      }\n    }\n    c = -1;\n\n    /*\n    for ( long long int j = 0; j < n; j++ ) {\n      cout << \" \" << v[j];\n    }\n    cout << endl;\n    */\n\n  }\n\n  cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int INF = 1000000;\n\nint partition(int *A,int p,int r)\n{\n\tint j,x,temp;\n\n\tx = A[r];\n\tj = p-1;\n\n\tfor(int i = p; i < r; i++)\n\t{\n\t\tif (A[i] <= x)\n\t\t{\n\t\t\tj++;\n\t\t\ttemp = A[i];\n\t\t\tA[i] = A[j];\n\t\t\tA[j] = temp;\n\t\t}\n\t}\n\n\ttemp = A[j+1];\n\tA[j+1] = A[r];\n\tA[r] = temp;\n\n\treturn j+1;\n}\n\nvoid quicksort(int *A,int p,int r)\n{\n\tint q;\n\n\tif (p < r)\n\t{\n\t\tq = partition(A,p,r);\n\t\tquicksort(A,p,q-1);\n\t\tquicksort(A,q+1,r);\n\t}\n}\n\nint solve_swap(int *a,int *b,int n)\n{\n\tint sum,temp;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (a[i] != b[i])\n\t\t{\n\t\t\tfor(int j = i+1; j < n; j++)\n\t\t\t{\n\t\t\t\tif (b[j] == a[i] && b[i] == a[j])\n\t\t\t\t{\n\t\t\t\t\ttemp = a[i];\n\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\ta[j] = temp;\n\n\t\t\t\t\tsum += a[i] + a[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n\nint solve1(int *a,int *b,int n)\n{\n\tbool check;\n\tint min,num,temp,sum,start;\n\n\tsum = 0;\n\tstart = 0;\n\n\twhile(1)\n\t{\n\t\tmin = INF;\n\t\t\n\t\tcheck = true;\n\n\t\t//printf(\"start = %d\\n\", start);\n\n\t\tfor(int i = start; i < n; i++)\n\t\t{\n\t\t\tif (min > a[i] && a[i] != b[i])\n\t\t\t{\n\t\t\t\tnum = i;\n\t\t\t\tmin = a[num];\n\t\t\t}\n\t\t}\n\n\t\t//printf(\"num = %d\\n\", num);\n\t\t//printf(\"min = %d\\n\", min);\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (a[i] == b[num])\n\t\t\t{\n\t\t\t\t//printf(\"%d and %d are swapped\\n\", a[num],a[i]);\n\t\t\t\tsum += a[num] + a[i];\n\t\t\t\ttemp = a[i];\n\t\t\t\ta[i] = min; // min = a[num]\n\t\t\t\ta[num] = temp;\n\t\t\t\tnum = i;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (a[i] != b[i])\n\t\t\t{\n\t\t\t\tcheck = false;\n\t\t\t\tstart = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\t//printf(\"a[i] = %d\\n\", a[i]);\n\t\t}\n\n\t\tif (check)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn sum;\n}\n\nbool check(int *A,int *B,int n)\n{\n\tbool c = true;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (A[i] != B[i])\n\t\t{\n\t\t\tc = false;\n\t\t}\n\t}\n\n\treturn c;\n}\n\nint main()\n{\n\tint n,a[1000] = {0},b[1000] = {0},a2[1000] = {0};\n\tint sum1 = 0;\n\t//int sum2 = 0,pivot = 0,pivot1 = 0,pivot2= 0,min = 0,start=0,temp=0,k=0;\n\n\tscanf(\"%d\", &n);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\tb[i] = a[i];\n\t}\n\n\tquicksort(b,0,n-1);\n\n\tsum1 = solve_swap(a,b,n);\n\n\t//printf(\"sum = %d\\n\", sum1);\n\n\tif (check(a,b,n))\n\t{\n\t\tcout << sum1 <<endl;\n\n\t\treturn 0;\n\t}\n\n/*\n\tsum2 = sum1;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\ta2[i] = a[i];\n\t}\n\n\t//printf(\"\\nhere is sum1\\n\");\n\n\tsum1 += solve1(a,b,n);\n\n\t//printf(\"sum1 = %d\\n\",sum1);\n\n\n\tif (check(a,b,n))\n\t{\n\t\tprintf(\"%d\\n\", sum1);\n\t\treturn 0;\n\t}\n\n\n\n\tfor(int i = 1; i < n - start; i++)\n\t{\n\t\tk = start;\n\n\t\t\n\t\twhile(1)\n\t\t{\n\t\t\tif (b[pivot1] == a[k])\n\t\t\t{\n\t\t\t\tprintf(\"%d and %d are swapped\\n\", a[pivot1],a[k]);\n\t\t\t\ttemp = a[pivot1];\n\t\t\t\ta[pivot1] = a[k];\n\t\t\t\ta[k] = temp;\n\n\t\t\t\tsum1 += a[pivot1] + a[k];\n\t\t\t\tpivot1 = k;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tprintf(\"%d \", a[i]);\n\t\t}\n\t\tcout << endl;\n\t}\n\n\n\tif (!check(a,b,n))\n\t{\n\t\tprintf(\"\\nhere is sum2\\n\");\n\t\ttemp = a2[pivot2];\n\t\ta2[pivot2] = a2[0];\n\t\ta2[0] = temp;\n\n\t\tfor(int i = 1; i < n - start; i++)\n\t\t{\n\t\t\tint j = start;\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif (b[pivot2] == a2[j])\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d and %d are swapped\\n\", a2[pivot2],a2[j]);\n\t\t\t\t\ttemp = a2[pivot2];\n\t\t\t\t\ta2[pivot2] = a2[j];\n\t\t\t\t\ta2[j] = temp;\n\n\t\t\t\t\tsum2 += a2[pivot2] + a2[j];\n\t\t\t\t\tpivot2 = j;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tprintf(\"%d \", a2[i]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\n\t\tif (sum1 < sum2)\n\t\t{\n\t\t\tprintf(\"sum1 = %d\\n\", sum1);\n\t\t}else\n\t\t{\n\t\t\tprintf(\"sum2 = %d\\n\", sum2);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\n\tprintf(\"%d\\n\", sum1);\n*/\n\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX = 1000;\nconst int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve() {\n    int ans = 0;\n    bool V[MAX];\n\n    for (int i = 0; i < n; ++i) {\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B, B + n);\n\n    for (int i = 0; i < n; ++i) {\n        T[B[i]] = i;\n    }\n\n    for (int i = 0; i < n; ++i) {\n        if (V[i]) {\n            continue;\n        }\n\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while (true) {\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m, v);\n            S += v;\n            cur = T[v];\n            if (V[cur]) {\n                break;\n            }\n        }\n\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n    }\n\n    return ans;\n}\n\nint main() {\n    cin >> n;\n    s = VMAX;\n    for (int i = 0; i < n; ++i) {\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve()\n{\n  int ans = 0;\n\n  bool V[MAX];\n  for (int i=0;i<n;i++)\n    {\n      B[i]=A[i];\n      V[i]=false;\n    }\n  sort(B,B+n);\n  for(int i=0;i<n;i++)\n    T[B[i]]=i;\n  for(int i=0;i<n;i++)\n    {\n      if(V[i]) continue;\n      int cur = i;\n      int S = 0;\n      int m = VMAX;\n      int an = 0;\n      while(1)\n\t{\n\t  V[cur] = true;\n\t  an++;\n\t  int v = A[cur];\n\t  m=min(m,v);\n\t  S +=v;\n\t  cur = T[v];\n\t  if(V[cur]) break;\n\t}\n      ans += min(S + (an-2)*m,m+S+(an+1)*s);\n    }\n  return ans;\n}\n\nint main()\n{\n  cin >> n;\n  s = VMAX;\n  for(int i=0;i<n;i++)\n    {\n      cin >> A[i];\n      s=min(s,A[i]);\n    }\n  int ans = solve();\n  cout << ans <<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <sstream>\n#include <stack>\n#include <queue>\n#include <list>\n#include <stdio.h>\n#include <algorithm>\n#define MAX 100000\nusing namespace std;\ntypedef long long ll;\nll ans;\nvoid solve(int a[],int n)\n{\n\tint b[1000],t[1000],vmin,vmax=1000;\n\tbool vis[1000];\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tb[i]=a[i];\n\t\tvis[i]=false;\n\t}\n\tsort(b,b+n);\n\tvmin=b[0];\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tt[b[i]]=i;//得出移动够各个元素（值不同）应该在数组中位置 \n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint cur=i,m=vmax,sum=0,num=0;//查找新的环 \n\t\twhile(1)//开始搜索下一个环 \n\t\t{ \n\t\t\tvis[cur]=true;//将这个元素加入当前环 \n\t\t\tnum++;//这个环的个数加1 \n\t\t\tsum+=a[cur];//环的weight加1 \n\t\t\tm=min(a[cur],m);//更新最小值，最终得到该环的最小值 \n\t\t\tcur=t[a[cur]];//得到将要移动到的位置 \n\t\t\tif(vis[cur]) break;//将要移动到的位置的元素已经在环中，环已经闭合，一个环已经找到 \n\t\t}\n\t\tans+=min(sum+(num-2)*m,sum+m+(num+1)*vmin);//如果已经在某个环中或者根本不需要移动，那么成本为0，不影响结果 \n\t}\n}\nint main()\n{\t\n\tint n,a[1000];\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tsolve(a,n);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass UnionFind {\n\tvector<int> v;\n\tvector<int> mini;\npublic:\n\tUnionFind(const vector<int>& val) : v(val.size(), -1), mini(val) {}\n\tint find(int a) {\n\t\treturn v[a] < 0 ? a : v[a] = find(v[a]);\n\t}\n\tbool same(int a, int b) {\n\t\treturn find(a) == find(b);\n\t}\n\tvoid unite(int a, int b) {\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif (a == b) return;\n\t\tif (v[a] < v[b]) {\n\t\t\tmini[a] = min(mini[a], mini[b]);\n\t\t\tv[a] += v[b];\n\t\t\tv[b] = a;\n\t\t}\n\t\telse {\n\t\t\tmini[b] = min(mini[a], mini[b]);\n\t\t\tv[b] += v[a];\n\t\t\tv[a] = b;\n\t\t}\n\t}\n\tint get(int a) {\n\t\treturn mini[find(a)];\n\t}\n\tint size(int a) {\n\t\treturn -v[find(a)];\n\t}\n};\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<int> w(n);\n\tint mini = 1e4 + 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> w[i];\n\t\tmini = min(mini, w[i]);\n\t}\n\tauto a = w;\n\tsort(a.begin(), a.end());\n\tUnionFind uf(w);\n\tfor (int i = 0; i < n; i++) {\n\t\tint it = lower_bound(a.begin(), a.end(), w[i]) - a.begin();\n\t\tuf.unite(i, it);\n\t}\n\tint res = 0;\n\tvector<int> rts;\n\tfor (int i = 0; i < n; i++) {\n\t\tres += w[i] + (uf.get(i) == w[i] ? -w[i] : uf.get(i));\n\t\tif (i == uf.find(i)) rts.push_back(i);\n\t}\n\tfor (auto rt : rts) {\n\t\tif (uf.get(rt) == mini) continue;\n\t\tint dis = (uf.get(rt) - mini) * (uf.size(rt) - 1) - uf.get(rt) * 2 - mini;\n\t\tif (dis > 0) {\n\t\t\tres -= dis;\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\nint solve(){\nint ans = 0;\nbool V[MAX];\nfor(int i = 0; i < n; i++){\nB[i] = A[i];\nV[i] = false;\n}\nsort(B, B+n);\nfor(int i = 0; i < n; i++) T[B[i]] = i;\nfor(int i = 0; i < n; i++){ \nif(V[i]) continue;\nint cur = i;\nint S = 0;\nint m = VMAX;\nint an = 0;\nwhile(1){\nV[cur] = true;\nan++;\nint v = A[cur];\nm = min(m, v);\nS += v;\ncur = T[v];\nif(V[cur]) break;\n}\nans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n}\nreturn ans;\n}\nint main(){\ncin >> n;\ns = VMAX;\nfor(int i = 0; i < n; i++){\ncin >> A[i];\ns = min(s, A[i]);\n}\nint ans = solve();\ncout << ans << endl;\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <cstdint>\n\nusing namespace std;\n\ntemplate<typename T>\nint32_t merge(vector<T> &A, int32_t left, int32_t mid, int32_t right) {\n    int32_t n1 = mid - left;\n    int32_t n2 = right - mid;\n\n    vector<T> L(n1+1);\n    vector<T> R(n2+1);\n    for (int32_t i = 0; i < n1; i++) {\n        L[i] = A[left+i];\n    }\n    for (int32_t i = 0; i < n2; i++) {\n        R[i] = A[mid+i];\n    }\n    L[n1] = INT32_MAX;\n    R[n2] = INT32_MAX;\n\n    int32_t i = 0, j = 0, count = 0;\n    for (int32_t k = left; k < right; k++) {\n        if (L[i] <= R[j]) {\n            A[k] = L[i];\n            i++;\n        } else {\n            A[k] = R[j];\n            j++;\n        }\n        count++;\n    }\n\n    return count;\n}\n\ntemplate<typename T>\nint32_t cost(const vector<T> &unsorted, const vector<T> &sorted) {\n    bool is_sorted = true;\n    int32_t c = INT32_MAX;\n\n    for (int32_t i = 0; i < unsorted.size(); i++) {\n        if (unsorted[i] != sorted[i]) {\n            is_sorted = false;\n\n            for (int32_t j = i + 1; j < sorted.size(); j++) {\n                if (unsorted[i] == sorted[j]) {\n                    vector<T> unsorted2(unsorted);\n                    swap(unsorted2[i], unsorted2[j]);\n                    c = min(c, unsorted2[i] + unsorted2[j] + cost(unsorted2, sorted));\n                }\n            }\n        }\n    }\n\n    return (is_sorted ? 0 : c);\n}\n\ntemplate<typename T>\nint32_t merge_sort(vector<T> &A, int32_t left, int32_t right) {\n    if (left + 1 < right) {\n        int32_t mid = left + (right - left) / 2;\n        int32_t count1 = merge_sort(A, left, mid);\n        int32_t count2 = merge_sort(A, mid, right);\n        int32_t count3 = merge(A, left, mid, right);\n        return count1 + count2 + count3;\n    }\n\n    return 0;\n}\n\nint main() {\n    int32_t n;\n\n    cin >> n;\n    vector<int32_t> w1(n);\n    for (int32_t i = 0; i < n; i++) {\n        cin >> w1[i];\n    }\n\n    vector<int32_t> w2(w1);\n    merge_sort(w2, 0, n);\n\n    cout << cost(w1, w2) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate int[] a;\n\tprivate int[] b;\n\t\n\tprivate Scanner sc;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\tint lim = Integer.parseInt(sc.nextLine());\n\t\t\n\t\ta = new int[lim];\t\t\n\t\tb = new int[lim];\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\ta[i] = Integer.parseInt(sc.next());\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tArrays.sort(b);\n\t\t\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\tif (a[i] != b[i]) {\n\t\t\t\tfor (int j = (i + 1); j < lim; j++) {\n\t\t\t\t\tif ((a[j] == b[i]) && (a[i] == b[j])) {\n\t\t\t\t\t\ta[i] = b[i];\n\t\t\t\t\t\ta[j] = b[j];\n\t\t\t\t\t\t\n\t\t\t\t\t\tans = ans + a[i] + a[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.print(ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int INF = 1000000;\n\nint partition(int *A,int p,int r)\n{\n\tint j,x,temp;\n\n\tx = A[r];\n\tj = p-1;\n\n\tfor(int i = p; i < r; i++)\n\t{\n\t\tif (A[i] <= x)\n\t\t{\n\t\t\tj++;\n\t\t\ttemp = A[i];\n\t\t\tA[i] = A[j];\n\t\t\tA[j] = temp;\n\t\t}\n\t}\n\n\ttemp = A[j+1];\n\tA[j+1] = A[r];\n\tA[r] = temp;\n\n\treturn j+1;\n}\n\nvoid quicksort(int *A,int p,int r)\n{\n\tint q;\n\n\tif (p < r)\n\t{\n\t\tq = partition(A,p,r);\n\t\tquicksort(A,p,q-1);\n\t\tquicksort(A,q+1,r);\n\t}\n}\n\nint solve_swap(int *a,int *b,int n)\n{\n\tint sum,temp;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (a[i] != b[i])\n\t\t{\n\t\t\tfor(int j = i+1; j < n; j++)\n\t\t\t{\n\t\t\t\tif (b[j] == a[i] && b[i] == a[j])\n\t\t\t\t{\n\t\t\t\t\ttemp = a[i];\n\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\ta[j] = temp;\n\n\t\t\t\t\tsum += a[i] + a[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n\nint solve1(int *a,int *b,int n)\n{\n\tbool check;\n\tint min,num,temp,sum,start;\n\n\tsum = 0;\n\tstart = 0;\n\n\twhile(1)\n\t{\n\t\tmin = INF;\n\t\t\n\t\tcheck = true;\n\n\t\t//printf(\"start = %d\\n\", start);\n\n\t\tfor(int i = start; i < n; i++)\n\t\t{\n\t\t\tif (min > a[i] && a[i] != b[i])\n\t\t\t{\n\t\t\t\tnum = i;\n\t\t\t\tmin = a[num];\n\t\t\t}\n\t\t}\n\n\t\t//printf(\"num = %d\\n\", num);\n\t\t//printf(\"min = %d\\n\", min);\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (a[i] == b[num])\n\t\t\t{\n\t\t\t\t//printf(\"%d and %d are swapped\\n\", a[num],a[i]);\n\t\t\t\tsum += a[num] + a[i];\n\t\t\t\ttemp = a[i];\n\t\t\t\ta[i] = min; // min = a[num]\n\t\t\t\ta[num] = temp;\n\t\t\t\tnum = i;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (a[i] != b[i])\n\t\t\t{\n\t\t\t\tcheck = false;\n\t\t\t\tstart = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\t//printf(\"a[i] = %d\\n\", a[i]);\n\t\t}\n\n\t\tif (check)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn sum;\n}\n\nbool check(int *A,int *B,int n)\n{\n\tbool c = true;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (A[i] != B[i])\n\t\t{\n\t\t\tc = false;\n\t\t}\n\t}\n\n\treturn c;\n}\n\nint main()\n{\n\tint n,a[1000] = {0},b[1000] = {0},a2[1000] = {0};\n\tint sum1 = 0;\n\t//int sum2 = 0,pivot = 0,pivot1 = 0,pivot2= 0,min = 0,start=0,temp=0,k=0;\n\n\tscanf(\"%d\", &n);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\tb[i] = a[i];\n\t}\n\n\tquicksort(b,0,n-1);\n\n\tsum1 = solve_swap(a,b,n);\n\n\t//printf(\"sum = %d\\n\", sum1);\n\n\tif (check(a,b,n))\n\t{\n\t\tcout << sum1 <<endl;\n\n\t\treturn 0\t}\n\n/*\n\tsum2 = sum1;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\ta2[i] = a[i];\n\t}\n\n\t//printf(\"\\nhere is sum1\\n\");\n\n\tsum1 += solve1(a,b,n);\n\n\t//printf(\"sum1 = %d\\n\",sum1);\n\n\n\tif (check(a,b,n))\n\t{\n\t\tprintf(\"%d\\n\", sum1);\n\t\treturn 0;\n\t}\n\n\n\n\tfor(int i = 1; i < n - start; i++)\n\t{\n\t\tk = start;\n\n\t\t\n\t\twhile(1)\n\t\t{\n\t\t\tif (b[pivot1] == a[k])\n\t\t\t{\n\t\t\t\tprintf(\"%d and %d are swapped\\n\", a[pivot1],a[k]);\n\t\t\t\ttemp = a[pivot1];\n\t\t\t\ta[pivot1] = a[k];\n\t\t\t\ta[k] = temp;\n\n\t\t\t\tsum1 += a[pivot1] + a[k];\n\t\t\t\tpivot1 = k;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tprintf(\"%d \", a[i]);\n\t\t}\n\t\tcout << endl;\n\t}\n\n\n\tif (!check(a,b,n))\n\t{\n\t\tprintf(\"\\nhere is sum2\\n\");\n\t\ttemp = a2[pivot2];\n\t\ta2[pivot2] = a2[0];\n\t\ta2[0] = temp;\n\n\t\tfor(int i = 1; i < n - start; i++)\n\t\t{\n\t\t\tint j = start;\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif (b[pivot2] == a2[j])\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d and %d are swapped\\n\", a2[pivot2],a2[j]);\n\t\t\t\t\ttemp = a2[pivot2];\n\t\t\t\t\ta2[pivot2] = a2[j];\n\t\t\t\t\ta2[j] = temp;\n\n\t\t\t\t\tsum2 += a2[pivot2] + a2[j];\n\t\t\t\t\tpivot2 = j;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tprintf(\"%d \", a2[i]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\n\t\tif (sum1 < sum2)\n\t\t{\n\t\t\tprintf(\"sum1 = %d\\n\", sum1);\n\t\t}else\n\t\t{\n\t\t\tprintf(\"sum2 = %d\\n\", sum2);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\n\tprintf(\"%d\\n\", sum1);\n*/\n\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n\nusing namespace std;\n\nint main(){\n\n    int n , i , j ;\n    int min, minj, wsum = 0;\n\n    scanf(\"%d\", &n);\n\n    int w[n];\n\n    for( i = 0 ; i < n ; i++ ) scanf(\"%d\", &w[i]);\n\n    for( i = 0 ; i < n ; i++ ){\n\n        min = w[i];\n\n        minj = i;\n\n        for( j = i + 1 ; j < n ; j++ ){\n\n            if( min > w[j] ){\n\n                min = w[j];\n                minj = j;\n\n            }\n\n        }\n\n\n        if( minj != i ){\n\n            wsum = wsum + w[i] + w[minj];\n\n            swap( w[i], w[minj] ); \n\n        } else {}\n\n    }\n\n    printf(\"%d\\n\", wsum);\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\nint main(){\n\tint N,r=0;\n\tscanf(\"%d\",&N);\n\tstd::vector<int>v(N);\n\tfor(int i=0;i<N;i++)scanf(\"%d\",&v[i]);\n\tfor(int i=0;i<N;i++){\n\t\tauto ma=max_element(v.begin(),v.end()-i);\n\t\tif(ma!=v.begin()+(N-1-i)){\n\t\t\tr+=*ma+v[N-1-i];\n\t\t\tswap(*ma,v[N-1-i]);\n\t\t}\n\t\tauto mi=min_element(v.begin()+i,v.end());\n\t\tif(mi!=v.begin()+i){\n\t\t\tr+=*mi+v[i];\n\t\t\tswap(*mi,v[i]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tint n; cin >> n;\n\tvi v(n);\n\tREP(i, n)\n\t{\n\t\tcin >> v[i];\n\t}\n\tvi w = v;\n\tsort(ALL(w));\n\tint mn = *min_element(ALL(v));\n\tvector<vi> g; vector<bool> f(n);\n\tREP(i, n)\n\t{\n\t\tif (!f[i])\n\t\t{\n\t\t\tf[i] = true;\n\t\t\tvi tmp; int t = find(ALL(w), v[i]) - w.begin();\n\t\t\ttmp.push_back(v[i]);\n\t\t\twhile (t != i)\n\t\t\t{\n\t\t\t\tint nx = find(ALL(w), v[t]) - w.begin();\n\t\t\t\tf[t] = true;\n\t\t\t\ttmp.push_back(v[t]);\n\t\t\t\tt = nx;\n\t\t\t}\n\t\t\tg.push_back(tmp);\n\t\t}\n\t}\n\tint ans = 0;\n\tREP(i, g.size())\n\t{\n\t\tint m = *min_element(ALL(g[i]));\n\t\tint s = 0;\n\t\tREP(j, g[i].size()) s += g[i][j];\n\t\tans += min(s + m*(g[i].size() - 2), mn*(g[i].size() + 1) + m + s);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nstatic const int VMAX = 10000;\nint solve(int* arr, int len){\n  int ans = 0, tmin = VMAX;\n  int* narr = new int[len];\n  int pos[VMAX+1];\n  int* marked = new int[len];\n  for(int i=0;i<len;i++){\n    narr[i] = arr[i];\n    marked[i] = 0;\n    (arr[i]<tmin)?(tmin=arr[i]):(tmin);\n  }\n  sort(narr,narr+len);\n  // record the position of values in sorted array\n  for(int i=0;i<len;i++)\n    pos[narr[i]]=i;\n  // check the cycle of transform\n  for(int i=0;i<len;i++){\n    if(marked[i]==0){\n      int sum = 0, min = VMAX, n = 0;\n      for(int j = i; marked[j]==0 ; j = pos[arr[j]]){\n        marked[j] = 1;\n        n++;\n        sum+=arr[j];\n        (arr[j]<min)?(min = arr[j]):(min);\n      }\n      int a = sum + (n-2)*min;\n      int b = sum + (n+1)*tmin + min;\n      ans += (a<b)?a:b;\n    }\n  }\n  delete[] narr;\n  delete[] marked;\n  return ans;\n}\n\nint main(){\n  int len;\n  cin >> len;\n  int* arr = new int[len];\n  for(int i=0;i<len;i++)\n    cin>>arr[i];\n  cout << solve(arr,len) << endl;\n  delete[] arr;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define MAX 200005\n#define INF -100000\n\nint A[MAX], B[MAX];\nint n;\nint mina = 1 << 24;\n\nint main() {\n  scanf(\"%d\", &n);\n  for ( int i = 1; i <= n; i++ ) {\n    scanf(\"%d\", &A[i]);\n    mina = min(mina, A[i]);\n    B[i] = INF;\n  }\n\n  long ans = 0;\n  for ( int i = 1; i <= n; i++ ) {\n    int ming = 1 << 24;\n    int sum = 0;\n    int n = 0;\n    int j = i;\n    if ( B[i] == 0 ) continue;\n    while ( B[j] != 0 ) {\n      B[j] = 0;\n      ming = min(ming, A[j]);\n      sum += A[j];\n      n++;\n      j = A[j];\n    }\n    ans += min(ming * (n - 2) + sum, mina * (n + 1) + ming + sum);\n  }\n\n  printf(\"%ld\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nint W[1111];\nint U[1111];\nint main(){\n  cin >> N;  \n  for(int i=0;i<N;i++){\n    cin >> W[i]; U[i] = W[i];\n  }\n  sort(W,W+N);\n  int res = 0;\n  for(int i=N-1;i>-1;i--){\n    if( W[i] == U[i] ) continue;\n    for(int j=i-1;j>-1;j--){\n      if( W[i] == U[j] ){\n        swap(U[i],U[j]); res += U[i] + U[j];\n        break;\n      }\n    }\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstdint>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i, start, end) for(int i = (start); i < (end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n\nvoid read_problem(vector<int>& ws)\n{\n    int n;\n    scanf(\"%d\\n\", &n);\n\n    ws.reserve(n);\n    REP(i, n) {\n        int w;\n        scanf(\"%d\", &w);\n        ws.emplace_back(w);\n    }\n}\n\nvector<int> get_ranks(const vector<int>& ws)\n{\n    vector<int> ranks(10000+1, -1);\n\n    vector<int> bin(10000+1);\n    for(int e : ws) {\n        bin[e] = 1;\n    }\n    int rnk = 0;\n    for(int i = 0; i <= 10000; ++i) {\n        if(bin[i]) {\n            ranks[i] = rnk++;\n        }\n    }\n\n    return ranks;\n}\n\nint loop_cost(const vector<int>& loop, int min_global)\n{\n    int m = loop.size();\n    int min_local = *min_element(loop.begin(), loop.end());\n\n    int cost1 = accumulate(loop.begin(), loop.end(), 0) + (m-2)*min_local;\n    int cost2 = accumulate(loop.begin(), loop.end(), 0) - min_local + min_global + (m-2)*min_global + 2*(min_local + min_global);\n\n    return min(cost1, cost2);\n}\n\nint solve(const vector<int>& ws)\n{\n    int n = ws.size();\n\n    vector<int> ranks = get_ranks(ws);\n#if 0\n    REP(i, ranks.size()) {\n        if(ranks[i] >= 0)\n            printf(\"%d %d\\n\", i, ranks[i]);\n    }\n#endif\n\n    int min_global = *min_element(ws.begin(), ws.end());\n\n    int cost = 0;\n    vector<int> visited(n);\n    REP(i, n) {\n        if(visited[i]) continue;        // ????????????\n        if(i == ranks[ws[i]]) continue; // ??¢?????£?????????????????????\n\n        vector<int> loop;\n        for(int j = i; ; ) {\n            int e = ws[j];\n            visited[j] = 1;\n            loop.emplace_back(e);\n\n            j = ranks[e];\n            if(j == i) { // ???????????????\n#if 0\n                REP(k, loop.size()) {\n                    printf(\"%d \", loop[k]);\n                }\n                puts(\"\");\n#endif\n                cost += loop_cost(loop, min_global);\n                break;\n            }\n        }\n    }\n\n    return cost;\n}\n\nint main()\n{\n    vector<int> ws;\n    read_problem(ws);\n    int n = ws.size();\n#if 0\n    REP(i, n) {\n        printf(\"%d \", ws[i]);\n    }\n#endif\n\n    int cost = solve(ws);\n    printf(\"%d\\n\", cost);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <list>\n#include <cmath>\n#include <vector>\n#include <stack>\n#include <set>\n#include <map>\n#define sf scanf\n#define pf printf\n#define show(x) cout<<\"x:\"<<x<<endl;\nusing namespace std;\ntypedef long long ll;\nconst int maxn=1000;\nconst int vmaxn=10000;\nconst int inf=1e9+5;\nint n,a[maxn],s;\nint b[maxn],t[vmaxn+1];\n\nll solve()\n{\n    int ans=0;\n\n    bool V[maxn];\n    for(int i=0;i<n;i++) b[i]=a[i],V[i]=false;\n    sort(b,b+n);\n    for(int i=0;i<n;i++)t[b[i]]=i;\n    for(int i=0;i<n;i++)\n    {\n        if(V[i])continue;\n        int cur=i;\n        int S=0;\n        int m=vmaxn;\n        int an=0;\n        while(1)\n        {\n            V[cur]=true;\n            an++;\n            int v=a[cur];\n            m=min(m,v);\n            S+=v;\n            cur=t[v];\n            if(V[cur])break;\n        }\n        ans+=min(S+(an-2)*m,m+S+(an+1)*s);\n    }\n\n    return ans;\n}\n\nint main()\n{\n    cin>>n;\n    s=vmaxn;\n    for(int i=0;i<n;i++)\n    {\n        cin>>a[i];\n        s=min(s,a[i]);\n    }\n    int ans=solve();\n    cout<<ans<<endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX_N = 1000;\nconst int MAX_W = 10000;\n\nint n, s, A[MAX_N], B[MAX_N], T[MAX_W+1];\n\nint solve(){\n    int sum = 0;\n    bool V[MAX_N];\n    \n    for (int i = 0; i < n; i++)\n    {\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B, B+n);\n    for (int i = 0; i < n; i++) T[B[i]] = i;\n    for (int i = 0; i < n; i++)\n    {\n        if(V[i]) continue;\n        int cur = i, S = 0, m = MAX_W, an =  0;\n        while(!V[cur]){\n            V[cur] = true;\n            an++;\n            m = min(m, A[cur]);\n            S += A[cur];\n            cur = T[A[cur]];\n        }\n        sum += min(S + (an - 2) * m, m + S + (an + 1) * s);\n    }\n    return sum;\n}\n\nint main(){\n    s = MAX_W;\n    cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n    cout << solve() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\n\nint main() {\n\tint n;\n  scanf(\"%d\", &n);\n  int A[n], B[n], C[n];\n  for ( int i = 0; i < n; i++ ) scanf(\"%d\", &A[i]);\n  for ( int i = 0; i < n; i++ ) B[i] = A[i];\n  sort(B, B+n);\n  for ( int i = 0; i < n; i++ ) {\n    for ( int j = 0; j < n; j++ ) {\n      if (A[i] == B[j]) {\n        C[i] = j;\n        break;\n      }\n    }\n  }\n  int k = 0, count = 0, min = B[0], count1 = 0, count2 = 0;\n  while ( k < n ) {\n    int i, j;\n    for (i = 0; i < n; i++) if (C[i] == k) break;\n    for (j = 0; j < n; j++) if (C[j] == i) break;\n    if (C[k] == k) {\n\t\t\tif (count1 > count2+2*(min+k)) {\n\t\t\t\tcount += count2+2*(min+k);\n\t\t\t} else {\n\t\t\t\tcount += count1;\n\t\t\t}\n\t\t\tcount1 = 0;\n\t\t\tcount2 = 0;\n      k++;\n    } else {\n      count1 += A[i]+A[j];\n\t\t\tcount2 += min+A[j];\n      swap(A[i], A[j]);\n      swap(C[i], C[j]);\n    }\n  }\n\n  printf(\"%d\\n\", count);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint vmax=10000;\nint A[1005],B[1005],T[20000];\nbool M[1005];\nint main()\n{\n\tint S;//记录每个环内元素值的总和\n\tint Min;//记录整个数组的最小值 \n\tint num=0;//记录最小成本 \n\tint m;//记录整个环内最小值，方便调换元素 \n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&A[i]);\n\t\tB[i]=A[i];\n\t\tM[i]=false;//false表示该位置的元素没有合理归为 \n\t}\n\tsort(B,B+n);\n\tMin=B[0]; \n\tfor(int i=0;i<n;i++) T[B[i]]=i;//B[i]这个数排序后的位置 \n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint weizhi=i;\n\t\tint S=0;//记录环内元素总值 \n\t\tint m=vmax;\n\t\tint ans=0;//记录环内元素个数\n\t\tif(M[weizhi]) continue;//该位置元素归为则跳过 \n\t\t \n\t\twhile(1)\n\t\t{\n\t\t\tM[weizhi]=true;//没有归为\n\t\t\tans++;\n\t\t\tint cur=A[weizhi];\n\t\t\tS+=cur;\n\t\t\tm=min(m,cur);\n\t\t\tweizhi=T[cur];\n\t\t\tif(M[weizhi]) break;\n\t\t }\n\t\t  num+=min((S+(ans-2)*m),S+m+(ans+1)*Min);\n\t}\n\tprintf(\"%d\\n\",num);\n\t\n\t\n} \n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nstruct unionfind\n{\n\t//rankのオーバーフローに注意\n\tvector<int> par, rank;\n\tunionfind(int n)\n\t{\n\t\tpar.resize(n);\n\t\trank.resize(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 1;\n\t\t}\n\t}\n\n\tbool same(int u, int v)\n\t{\n\t\treturn root(u) == root(v);\n\t}\n\n\tvoid unite(int u, int v)\n\t{\n\t\tif (same(u, v)) return;\n\t\tu = root(u), v = root(v);\n\t\tif (rank[u] > rank[v]) swap(u, v);\n\t\tpar[u] = v;\n\t\trank[v] += rank[u];\n\t}\n\n\tint root(int v)\n\t{\n\t\tif (par[v] == v) return v;\n\t\treturn par[v] = root(par[v]);\n\t}\n};\n\nvoid solve()\n{\n\tint N;\n\tcin >> N;\n\tvector<int> ws(N), cs(N);\n\tset<int> s;\n\tmap<int, int> mp;\n\tbool zero = 0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> ws[i];\n\t\ts.insert(ws[i]);\n\t\tzero |= ws[i] == 0;\n\t}\n\n\tint cnt = 0;\n\tfor (int v : s)\n\t{\n\t\tmp[v] = cnt++;\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcs[i] = mp[ws[i]];\n\t}\n\n\tunionfind uf(N);\n\tvector<int> es[N];\n\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tuf.unite(i, cs[i]);\n\t}\n\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tes[uf.root(cs[i])].push_back(ws[cs[i]]);\n\t\t//cout << cs[i] << ' ';\n\t}\n\t//cout << endl;\n\n\tint ans = 0;\n\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tauto e = es[i];\n\t\tint n = e.size(), x = INT_MAX;\n\t\tif (n < 2) continue;\n\t\tfor (int v : e)\n\t\t{\n\t\t\tans += v;\n\t\t\tx = min(v, x);\n\t\t}\n\t\tif (zero) ans += min((n-2) * x, x);\n\t\telse ans += (n-2) * x;\n\t\t//cout << ans << endl;\n\t}\n\n\tcout << ans << endl;\n\n}\n\nint main(void)\n{\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint minimumCostSort(int *W, int n) {\n  int X[1000], R[10001];\n  for (int i = 0; i < n; i++) {\n    X[i] = W[i];\n  }\n  sort(X, X + n);\n  for (int i = 0; i < n; i++) R[X[i]] = i;\n  int m = X[0];\n  int sum = 0;\n\n  for (int i = 0; i < n; i++) {\n    int cur = i;\n    if (X[cur] == -1) continue;\n    int s = 0;\n    int mm = 10000;\n    int nn = 0;\n    int v;\n    while (true) {\n      nn++;\n      X[cur] = -1;\n      v = W[cur];\n      mm = min(v, mm);\n      s += v;\n      cur = R[v];\n      if (X[cur] == -1) break;\n    }\n    sum += min(s + (nn - 2) * mm, s + mm + (nn + 1) * m);\n  }\n\n  return sum;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  int W[1000];\n\n  cin >> n;\n\n  for (int i = 0; i < n; i++) {\n    cin >> W[i];\n  }\n\n  int c = minimumCostSort(W, n);\n\n  cout << c << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\nusing namespace std;\n\n#define MAX_NUM 1000\n\nint W[MAX_NUM];\nint N;\n\nint Compare(const void *a, const void *b)\n{\n    return *(int*)a - *(int*)b;\n}\n\nvoid Swap(int idx1, int idx2) {\n\tint tmp = W[idx1];\n\tW[idx1] = W[idx2];\n\tW[idx2] = tmp;\n}\n\nint SearchIdx(int wi)\n{\t\n\tfor (int i = 0; i < N; i++) {\n\t\tif (W[i] == wi) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid Copy(int *ary)\n{\n\tfor (int i = 0; i < N; i++) {\n\t\tary[i] = W[i];\n\t}\n}\n\nint main(void)\n{\n\t//input\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> W[i];\n\t}\n\n\t//minimum cost?\n\tint cost = 0;\n\tint w2[MAX_NUM];\n\tCopy(w2);\n\tqsort(w2, N, sizeof(int), Compare);\n\tfor (int i = 0; i < N; i++) {\n\t\tint idx1 = SearchIdx(w2[i]);\n\t\twhile (idx1 != i) {\n\t\t\tint idx2 = SearchIdx(w2[idx1]);\n\t\t\tSwap(idx1, idx2);\n\t\t\tcost = cost + W[idx1] + W[idx2];\n\t\t\tidx1 = idx2;\n\t\t}\n\t}\n\n\t//output\n\tcout << cost << \"\\n\";\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdlib.h>\n#include <iostream>\n#include <climits>\nusing namespace std;\n\nstruct weight{\n\tint val;\n\tint id;\n\tweight(){\n\t\tval = 0;\n\t\tid  = 0;\n\t}\n\tweight(weight *w){\n\t\tval = w->val;\n\t\tid  = w->id;\n\t}\n\tvoid set(weight *w){\n\t\tval = w->val;\n\t\tid  = w->id;\n\t}\n};\n\nvoid merge_sort(weight *array, int left, int right);\nvoid merge(weight *array, int left, int mid, int right);\nvoid swap_id(weight *a, weight *b);\nvoid swap(weight *a, weight *b);\nint cal_min_swap(weight *original, weight *sorted, int num);\nint linear_search(weight *array, int size, int num);\n\nint main(){\n\tint n;\n\n\tcin >> n;\n\n\tweight* original = (weight*)malloc(n * sizeof(weight));\n\tweight* sorted   = (weight*)malloc(n * sizeof(weight));\n\tint result = 0;\n\n\tif(n < 1){\n\t\treturn 0;\n\t}\n\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> original[i].val;\n\t\toriginal[i].id = i;\n\t\tsorted[i].set(&original[i]);\n\t}\n\n\tmerge_sort(sorted, 0, n);\n\tcout << cal_min_swap(original, sorted, n) << endl;\n\treturn 0;\n}\n\nvoid merge_sort(weight *array, int left, int right){\n\tif(left+1 < right){\n\t\tint mid = (left + right) >> 1;\n\t\tmerge_sort(array, mid, right);\n\t\tmerge_sort(array, left, mid);\n\t\tmerge(array, left, mid, right);\n\t}\n\n}\n\nvoid merge(weight *array, int left, int mid, int right){\n\tint n1 = mid - left;\n\tint n2 = right - mid;\n\n\tweight* L = (weight*)malloc((n1+1) * sizeof(weight));\n\tweight* R = (weight*)malloc((n2+1) * sizeof(weight));\n\n\tfor(int i = 0; i < n1; ++i){\n\t\tL[i].set(&array[left+i]);\n\t}\n\tL[n1].val = INT_MAX;\n\tfor(int i = 0; i < n2; ++i){\n\t\tR[i].set(&array[mid+i]);\n\t}\n\tR[n2].val = INT_MAX;\n\n\tint i = 0;\n\tint j = 0;\n\tfor(int k = left; k < right; ++k){\n\t\tif(L[i].val <= R[j].val){\n\t\t\tarray[k].set(&L[i]);\n\t\t\t++i;\n\t\t}else{\n\t\t\tarray[k].set(&R[j]);\n\t\t\t++j;\n\t\t}\n\t\t// array[k].id = k;\n\t}\n}\nvoid swap_id(weight *a, weight *b){\n\tint temp = b->id;\n\tb->id = a->id;\n\ta->id = temp;\n}\nvoid swap(weight *a, weight *b){\n\tweight *temp = new weight(b);\n\tb->set(a);\n\ta->set(temp);\n\tfree(temp);\n}\n\nint cal_min_swap(weight *original, weight *sorted, int num){\n\tint total_swap_w = 0;\n\tint temp_i = 0;\n\tbool is_swap = false;\n\tint swap_num = 0;\n\tint min = sorted[0].val;\n\tint this_min = 0;\n\tint this_total_swap_num = 0;\n\tstring test;\n\tfor(int i = 0; i < num; ++i){\n\t\tif(original[i].id != sorted[i].id){\n\t\t\tif(!is_swap){\n\t\t\t\ttemp_i = i;\n\t\t\t\tswap_num = 0;\n\t\t\t\tthis_min = sorted[i].val;\n\t\t\t\tthis_total_swap_num = 0;\n\t\t\t}\n\t\t\tthis_total_swap_num += original[i].val;\n\t\t\tint swap_i = linear_search(sorted, num, original[i].val);\n\t\t\tswap(&sorted[i], &sorted[swap_i]);\n\t\t\ti = swap_i - 1;\n\t\t\tis_swap = true;\n\t\t\tswap_num++;\n\t\t}else{\n\t\t\tif(is_swap){\n\t\t\t\tif(swap_num != 1){\n\t\t\t\t\tif(min*swap_num + 2*(min + this_min) < this_min*swap_num){\n\t\t\t\t\t\tthis_total_swap_num += min*swap_num + 2*(min + this_min);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tthis_total_swap_num += this_min*swap_num;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tthis_total_swap_num += this_min;\n\t\t\t\t}\n\t\t\t\ttotal_swap_w += this_total_swap_num;\n\t\t\t\tthis_total_swap_num = 0;\n\t\t\t\ti = temp_i;\n\t\t\t\tis_swap = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn total_swap_w;\n}\nint linear_search(weight *array, int size, int num){\n\tfor(int i = 0; i < size; ++i){\n\t\tif(array[i].val == num){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define N 40\n\nbool comp1(const pair<int, int> &a, const pair<int, int> &b)\n{\n    return a.first < b.first;\n}\nbool comp2(const pair<int, int> &a, const pair<int, int> &b)\n{\n    return a.second < b.second;\n}\nint main()\n{\n    int n;\n    cin >> n;\n    int w[n], x[n];\n    for (int i = 0; i < n; i++)\n    {\n        cin >> w[i];\n        x[i] = w[i];\n    }\n\n    sort(x, x + n);\n    for (int i = 0; i < n; i++)\n    {\n        if (i != 0)\n            cout << \" \";\n        cout << x[i];\n    }\n    cout << endl;\n    int *p, *q;\n    int sum = 0, tmp;\n }\n    for (int i = 0; i < n; i++)\n    {\n        p = find(w, w + n, x[i]);\n        while (i != p - w)\n        {\n            q = find(w, w + n, x[p - w]);\n            tmp = *p;\n            *p = *q;\n            *q = tmp;\n            sum += *p + *q;\n            p = q;\n        }\n    }\n\n    cout << sum << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n//#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\n//typedef pair<ll, ll> P;\n//const double INF = 1e10;\n//const ll INF = LONG_LONG_MAX / 10;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\nconst int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n\nbool contain(set<char> &s, int a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\n\ntypedef pair<char, int> P;\n\nvoid print_line(vector<P> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i].second;\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\n\ntypedef priority_queue<long long, vector<long long>, greater<long long> > PQ_ASK;\nconst int mod = 1000000007;\n\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> a(n);\n    rep(i, n) cin >> a[i];\n\n    int min_e = *min_element(a.begin(), a.end());\n    int max_e = *max_element(a.begin(), a.end());\n    vector<int> b = a;\n    sort(b.begin(), b.end());\n\n    vector<bool> used(n, false);\n    vector<int> index_cache(max_e + 1);\n    rep(i, n) index_cache[b[i]] = i;\n\n    int ans = 0;\n    rep(i, n) {\n        if (used[i]) continue;\n        int cur = i;\n        int cost = 0;\n        int mi = INF;\n        int cycle_len = 0;\n\n        while (true) {\n            used[cur] = true;\n            cycle_len++;\n            int v = a[cur];\n            cmin(mi, v);\n            cost += v;\n            cur = index_cache[v];\n            if (used[cur]) break;\n        }\n        int c1 = cost + (cycle_len - 2) * mi;\n        int c2 = mi + cost + (cycle_len + 1) * min_e;\n\n        ans += min(c1, c2);\n    }\n\n    cout << ans << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) for(ll i=0; i<(n); i++)\n#define REP2(i,x,n) for(ll i=x; i<(n); i++)\n#define REP3(i,x,n) for(ll i=x; i>(n); i--)\n#define ALL(n) begin(n),end(n)\n#define MAX 1000\n#define VMAX 10000\n#define SENTINEL 2000000000\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\nconst long long INF = numeric_limits<long long>::max();\nll N,A[MAX],B[MAX],T[VMAX+1],s;\n\nll solve(){\n    ll ans = 0;\n    bool V[MAX];\n    REP(i,N){\n        B[i]=A[i];\n        V[i]=false;\n    }\n    sort(B,B+N);\n    REP(i,N)T[B[i]]=i;\n    REP(i,N){\n        if(V[i])continue;\n        ll cur = i;\n        ll S = 0;\n        ll m = VMAX;\n        ll an = 0;\n        while(1){\n            V[cur] = true;\n            an++;\n            ll v = A[cur];\n            m = min(m,v);\n            S +=v;\n            cur = T[v];\n            if(V[cur])break;\n        }\n        ans += min(S+(an-2)*m,m+S+(an+1)*s);\n    }\n    return ans;\n}\nint main(){\n    cin >> N;\n    s = VMAX;\n    REP(i,N){\n        cin >> A[i];\n        s = min(s,A[i]);\n    }\n    ll ans = solve();\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n \nusing namespace std;\n \n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n \n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n \n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\n  int x = 100000;\n  VI ws(N), order(N), nxt(N);\n  REP(i,N){\n\tcin >> ws[i];\n\torder[i] = ws[i];\n\tx = min(x, ws[i]);\n  }\n  SORT(order);\n  REP(i,N) REP(j,N){\n\tif(order[i] == ws[j])\n\t  nxt[j] = i;\n  }\n\n  int ans = 0;\n  vector<bool> used(N, false);\n  for(int i=0;i<N;++i){\n\tif(used[i]) continue;\n\tint cur = i, n = 0, m = ws[i], sum = 0;\n\twhile(!used[cur]){\n\t  used[cur] = true;\n\t  ++n;\n\t  m = min(m, ws[cur]);\n\t  sum += ws[cur];\n\t  cur = nxt[cur];\n\t}\n\tans += min((n-2)*m+sum, (n+1)*x+m+sum);\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\n\nusing namespace std;\n\npair<int,long long> partition(int* a, int p, int r) {\n\tint x = a[r - 1];\n\tint cnt = p - 1;\n\tlong long cost = 0;\n\tfor (int i = p;i < r;i++) {\n\t\tif (a[i] <= x) {\n\t\t\tcnt++;\n\t\t\tif (cnt != i) {\n\t\t\t\tswap(a[cnt], a[i]);\n\t\t\t\tcost += a[cnt] + a[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn make_pair(cnt, cost);\n}\n\nlong long quicksort( int *a, int l, int r) {\n\tlong long cost = 0;\n\tif (l < r) {\n\t\t\n\t\tpair<int,long long> q = partition(a, l, r);\n\t\tcost += q.second;\n\t\tcost += quicksort(a, l, q.first);\n\t\tcost +=quicksort(a, q.first + 1, r);\n\t}\n\treturn cost;\n}\n\nvoid set(int*a,int*b,int n){\n\tfor (int i = 0;i < n;i++) {\n\t\ta[i] = b[i];\n\t}\n}\n\n\n\n\nint main() {\n\tint n;\n\tlong long cost=0;\n\tcin >> n;\n\tmap<int, int> ma;\n\tint* a = new int[n];\n\tint* ori = new int[n];\n\tbool *s = new bool[n];\n\n\tfor (int i = 0;i < n;i++) {\n\t\tcin >> a[i];\n\t\tori[i] = a[i];\n\t\ts[i] = false;\n\t}\n\tquicksort(a, 0, n);\n\tint minimum = a[0];\n\tfor (int i = 0;i < n;i++) {\n\t\tma[a[i]] = i;\n\t}\n\tfor (int i = 0;i < n;i++) {\n\t\tif (!s[i]) {\n\t\t\tint first = i;\n\t\t\tvector<int> v;\n\t\t\tv.push_back(ori[i]);\n\t\t\tint index = ma[ori[i]];\n\t\t\tint mini = ori[i];\n\t\t\ts[i] = true;\n\t\t\twhile (index != i) {\n\t\t\t\ts[index] = true;\n\t\t\t\tmini = min(mini, ori[index]);\n\t\t\t\tv.push_back(ori[index]);\n\t\t\t\tindex = ma[ori[index]];\n\t\t\t}\n\t\t\tint a, b;\n\t\t\ta = b = 0;\n\t\t\tfor (int i = 0;i < v.size();i++) {\n\t\t\t\ta += v[i];\n\t\t\t}\n\t\t\tb = a;\n\t\t\ta += mini * (v.size() - 2);\n\t\t\tb += mini + (v.size() + 1) * minimum;\n\t\t\tcost += min(a, b);\n\t\t}\n\t}\n\tcout << cost << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\nconst int maxn = 1010;\nint a[maxn], id[maxn];\ninline bool cmp(int x, int y) { return a[x] < a[y]; }\nint main()\n{\n\tint n;long long ans = 0;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1;i <= n;i++)\n\t{\n\t\tscanf(\"%d\", a + i);\n\t\tid[i] = i;\n\t}\n\tsort(id + 1, id + 1 + n,cmp);\n\tid[n + 1] = n + 1;\n\tfor (int i = n;i;i--)\n\t{\n\t\tif (id[i] != i)\n\t\t\tans = ans + a[id[i]] + a[i];\n\t\tid[id[i]] = id[i];\n\t\tid[i] = i;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct point{\n\tint a,i;\n\tbool operator<(const point&p)const{\n\t\treturn a<p.a;\n\t}\n}b[2005];\nint a[2005];\nint k[2005];\nbool ok[2005];\nint n;\nint main(){\n\tios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\tint n;cin>>n;\n\tfor(int i=0;i<n;i++)cin>>a[i];\n\tfor(int i=0;i<n;i++){\n\t\tb[i].a=a[i];\n\t\tb[i].i=i;\n\t}\n\tsort(b,b+n);\n\tfor(int i=0;i<n;i++)k[b[i].i]=i;\n\tint res=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(ok[i])continue;\n\t\tint j=i;\n\t\tint t=0;\n\t\tint s=0;\n\t\twhile(k[j]!=i){\n\t\t\tok[j]=1;\n\t\t\ts+=a[j];\n\t\t\tj=k[j];\n\t\t\tt++;\n\t\t}\n//\t\ts+=t*a[j];\n\t\tok[j]=1;\n\t\tres+=min(s+t*a[j],s+t*b[0].a+2*(b[0].a+a[j]));\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n  int n;\n  int cost = 0;\n  cin >> n;\n  int w[n], a[n], b[n];\n  int min_val = numeric_limits<int>::max();\n  for (int i = 0; i < n; i++) {\n    cin >> w[i];\n    a[i] = w[i];\n    b[i] = 0;\n    min_val = min(w[i], min_val);\n  }\n  sort(a, a+n);\n  for (int i = 0; i < n; i++) {\n    if (b[i] == 0 && a[i] != w[i]) {\n      int index = find(a, a+n, w[i]) - a;\n      if (w[index] == a[i]) {\n        cost += w[i] + w[index];\n        b[index]++;\n      } else {\n        int first_value = w[i];\n        int local_min = w[i];\n        int local_cost = w[i];\n        int local_n = 1;\n        while (w[index] != first_value) {\n          local_min = min(local_min, w[index]);\n          local_cost += w[index];\n          local_n++;\n          b[index]++;\n          index = find(a, a+n, w[index]) - a;\n        }\n        int local_cost2 = local_cost;\n        local_cost += (local_n - 2) * local_min;\n        local_cost2 += local_min + (local_n + 1) * min_val;\n        cost += min(local_cost, local_cost2);\n      }\n    }\n  }\n  cout << cost << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main(){\n\tint n;\n\tcin >> n;\n\t\n\tvector<int> inp(n);\n\tvector<P> input(n);\n\t\n\tfor (int i=0;i<n;i++){\n\t\tinput[i].second = i;\n\t\tcin >> input[i].first;\n\t\tinp[i]=input[i].first;\n\t}\n\t\n\tsort(input.rbegin(),input.rend());\n\t\n\tint count=0;\n\t\n\tfor (int i=0;i<n-1;i++){\n\t\tif(input[i].second>n-i-1){\n\t\t\tswap(inp[input[i].second],inp[n-i-1]);\n\t\t\tcount+=(inp[input[i].second]+inp[n-i-1]);\n\t\t\tswap(input[input[i].second].second,input[n-i-1].second);\n\t\t}\n\t\t\n\t}\n\t\n\tcout << count;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n \n\nint solve(int *w,int n) {\n\tint g_m = w[0]; //整个数组中的最小值 \n\t \n\tmap<int,int> address; //元素在排序后的数组中的下标映射 \n\tint *tmp = new int[n];\n\tbool *T = new bool[n]; //标记当前位置是否被访问 \n\t\n\tint ans = 0; //最终结果 \n\t\n\tfor (int i=0;i<n;i++) {\n\t\t//找出最小值 \n\t\tif (w[i] < g_m) {\n\t\t\tg_m = w[i];\n\t\t}\n\t\t//初始化 \n\t\tT[i] = false;\n\t\ttmp[i] = w[i];\n\t}\n\t//对临时数组排序 \n\tsort(tmp,tmp+n);\n\t//建立映射 \n\tfor (int i=0;i<n;i++) {\n\t\tpair<int, int> pair_map(tmp[i],i);\n\t\taddress.insert(pair_map);\n\t}\n\tfor (int i = 0;i<n;i++) {\n\t\tif (T[i]) { //当前位置已被访问过了 \n\t\t\tcontinue;\n\t\t}\n\t\tint m = w[i]; //当前圈里的最小值 \n\t\tint cur = i;//当前所处的位置\n\t\tint S = 0; //当前所需的花费\n\t\tint count = 0; //当前圈里的元素个数\n\t\t \n\t\twhile (1) {\n\t\t\tcount++;\n\t\t\tint v = w[cur];\n\t\t\tm = min(v,m);\n\t\t\tS += v;\n\t\t\tT[cur] = true;\n\t\t\tcur = address.at(v); \n\t\t\tif (T[cur]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint r = min(ans + S + (count - 2) * m,ans + S + m + (1+m) * g_m);\n\t\tans = r; \n\t}\n\treturn ans;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tint *w = new int[n];\n\tfor (int i = 0;i<n;i++) {\n\t\tcin >> w[i];\n\t}\n\tint ans = solve(w,n);\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 10000;\nstatic const int VMAX = 100000;\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve(){\n    int i,ans = 0;\n    \n    bool V[MAX];\n    for(i=0;i<n;i++){\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B,B+n);\n    for(i=0;i<n;i++) T[B[i]] = i;\n    for(i=0;i<n;i++){\n        if(V[i]) continue;\n        int cur=i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while(1){\n            V[cur] = true;\n            an++\n            int v=A[cur];\n            m = min(m,v);\n            S+=v;\n            cur = T[v];\n            if(V[cur]) break;\n        }\n        ans += min(S+(an-2)*m,m+S+(an+1)*s);\n    }\n    return ans;\n}\n\nint main(){\n    int i;\n    cin>>n;\n    s=VMAX;\n    for(i=0;i<n;i++){\n        cin>>A[i];\n        s=min(s,A[i]);\n    }\n    int ans = solve();\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve(){\n    int ans = 0;\n    \n    bool V[MAX];\n    for(int i = 0;i<n;i++){\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B,B+n);\n    for(int i = 0;i<n;i++)\n        T[B[i]] = i;\n    for(int i = 0;i<n;i++){\n        if(V[i])\n            continue;\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        do{\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m,v);\n            S += v;\n            cur = T[v];\n        }while(V[cur]);\n        ans += min(S + (an - 2)*m, m+S+(an+1)*S);\n    }\n    return ans;\n}\n\nint main(){\n    cin>>n;\n    s = VMAX;\n    for(int i = 0;i<n;i++){\n        cin>>A[i];\n        s = min(s,A[i]);\n    }\n    int ans = solve();\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct QuickFind{\n  vector<int> r,p;\n  vector<vector<int> > v;\n  QuickFind(){}\n  QuickFind(int size){init(size);}\n  void init(int size){\n    r.resize(size,0);\n    p.resize(size,0);\n    v.resize(size);\n    for(int i=0;i<size;i++){\n      r[i]=1,p[i]=i;\n      v[i].resize(1,i);\n    }\n  }\n  bool same(int x,int y){\n    return p[x]==p[y];\n  }\n  void unite(int x,int y){\n    x=p[x];y=p[y];\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    for(auto e:v[y]){\n      p[e]=x;\n      v[x].push_back(e);\n    }\n    v[y].clear();\n  }\n};\nsigned main(){\n  int n;\n  cin>>n;\n  vector<int>a(n);\n  for(int i=0;i<n;i++) cin>>a[i];\n  vector<int>b(a);\n  sort(b.begin(),b.end());\n  map<int,int>p,q;\n  for(int i=0;i<n;i++){\n    p[a[i]]=i;\n    q[b[i]]=i;\n  }\n  QuickFind qf(n);\n  for(int i=0;i<n;i++)\n    qf.unite(i,p[b[i]]);\n  int ans=0;\n  for(int i=0;i<n;i++){\n    int k=qf.v[i].size();\n    if(qf.p[i]!=i||k==1) continue;\n    int m=a[qf.v[i][0]];\n    int tmp=0;\n    for(int j=0;j<k;j++){\n      tmp+=a[qf.v[i][j]];\n      m=min(m,a[qf.v[i][j]]);\n    }\n    ans+=min(tmp+m*(k-2),tmp+m+b[0]*(k+1));\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\nint n, s, A[MAX], B[MAX], T[VMAX+1];\n\nint solve() {\n    int i, ans = 0;\n    bool V[MAX];\n    for(i=0; i<n; ++i) {B[i] = A[i]; V[i] = false;}\n    sort(B, B+n);\n    for(i=0; i<n; ++i) T[B[i]] = i;\n    for(i=0; i<n; ++i) {\n        if(V[i]) continue;\n        int S = 0, an = 0, cur = i, m = VMAX;\n        while(1) {\n            V[cur] = true; ++an;\n            int v = A[cur]; m = min(m, v);\n            S += v; cur = T[v];\n            if(V[cur]) break; \n        }\n        ans += min(S+(an-2)*m, m+S+(an+1)*s);\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> n;\n    s = VMAX;\n    for(int i=0; i<n; ++i) {\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n    int ans = solve();\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <limits>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\n\n\nint main(){\n  ios::sync_with_stdio(false);\n  int n; // 1 .. 1000\n  vector<int> w; // 1 .. 10^4\n  cin >> n;\n  for(int i = 0; i<n; ++i){int w_i; cin >> w_i; w.push_back(w_i);}\n  \n  vector<int> w2i(10000, -1);\n  vector<int> w_sorted(w);\n  sort(w_sorted.begin(), w_sorted.end());\n  for(int i=0; i<n; ++i){\n    w2i[w_sorted[i]] = i;\n  }\n  \n  vector<bool> checked(10000, false);\n  \n  const int gm = *min_element(w.begin(), w.end()); //global minimum\n  \n  int ans = 0;\n  for(int i = 0; i<n; ++i){\n    if(checked[w[i]]) continue;\n    else{\n      checked[w[i]]=true;\n      //cout << \">>\" <<  w[i] << endl;\n      \n      int w_nxt  = w[w2i[w[i]]];\n      int cm = w[i]; //minimum in cycle\n      int c_size = 1;\n      int c_wght = w[i];\n\n      for(;w_nxt != w[i]; w_nxt=w[w2i[w_nxt]]){\n\tchecked[w_nxt]=true;\n\t//cout << \">>\" <<  w_nxt << endl;\n\tc_wght += w_nxt;\n\t++c_size;\n\tcm = min(cm, w_nxt);\n      }\n      \n      int without_borrowing\n\t= cm * (c_size-2) + c_wght;\n      int with_borrowing\n\t= gm * (c_size-2) + (c_wght-cm+gm) + 2 * (cm + gm);\n\t\n      ans += min (with_borrowing, without_borrowing);\n      //cout << \": \"  << ans << endl;\n    }\n  }\n  \n\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint n,mi;\nvector<int> w;\n\nint solve(){\n\n    int ret = 0;\n    vector<int> sub(w);\n    sort(sub.begin(),sub.end());\n    vector<int> cir(10001);\n    vector<bool> bol(n);\n\n    for(int i=0;i<n;i++){\n        cir[sub[i]] = i;\n        bol[i]=false;\n    }\n    for(int i=0;i<n;i++){\n        int sum=0,sn=0;\n        int loc=i;\n        int mmi=1e9;\n\n        for(;;){\n            bol[loc]=true;\n            sn++;\n            mmi=min(w[loc],mmi);\n            sum+=w[loc];\n            loc=cir[w[loc]];\n            if(bol[loc])break;\n        }\n        ret+=min(sum+(sn-2)*mmi,sum+mmi+mi*(sn+1));\n    }\n    return ret;\n}\n\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n;\n    mi = 1e9;\n    for(int i=0;i<n;i++){\n        int a;\n        cin >> a;\n        mi = min(mi,a);\n        w.push_back(a);\n    }\n    int ans = solve();\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "let quick_sort a n cmp =\n  let swap i j = let tmp = a.(i) in a.(i) <- a.(j); a.(j) <- tmp in\n  let partition p r =\n    let i = ref p in\n    for j = p to r - 1 do\n      if cmp a.(j) a.(r) <= 0 then (swap !i j; incr i)\n    done;\n    swap !i r;\n    !i in\n  let rec doit p r =\n    if p >= r then () else\n    let q = partition p r in\n    doit p (q - 1);\n    doit (q + 1) r in\n  doit 0 (n - 1)\n\nlet calc_cost a n =\n  let b = Array.copy a in\n  quick_sort b n compare;\n  let t = Array.make (b.(n-1) + 1) 0 in\n  Array.iteri (fun i e -> t.(e) <- i) b;\n  let p = Array.make n false in\n  let rec cycle i acc =\n    p.(i) <- true;\n    let j = t.(a.(i)) in\n    if p.(j) then a.(i) :: acc\n    else cycle j (a.(i) :: acc) in\n  let cycle i = cycle i [] in\n  let rec doit i acc =\n    if i = n then acc\n    else if p.(i) then doit (i + 1) acc\n    else\n      let ws = cycle i in\n      let m = List.length ws in\n      let s = List.fold_left (+) 0 ws in\n      let z = List.fold_left min max_int ws in\n      doit (i + 1) (acc + (min (s + (m - 2)*z) (s + z + (m + 1)*b.(0)))) in\n  doit 0 0\n\nlet () =\n  let n = read_int () in\n  let a = Array.init n (fun _ -> Scanf.scanf \"%d \" (fun e -> e)) in\n  calc_cost a n |> Printf.printf \"%d\\n\"\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define MAX_N 10000\n#define MAX_V 60000000\n#define INF 100000000\n\nint n, A[MAX_N], s, B[MAX_N], T[MAX_V], cur, S, m, x; bool V[MAX_N];\n\nint minimum_cost_sort() {\n\tint ans = 0;\n\tfor (int i = 0; i < MAX_V; i++) { V[i] = false; }\n\tfor (int i = 0; i < n; i++) { B[i] = A[i]; }\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; i++) { T[B[i]] = i; }\n\tfor (int i = 0; i < n; i++) {\n\t\tif (V[i] == true) { goto owata; }\n\t\tcur = i;\n\t\tS = 0;\n\t\tm = INF;\n\t\tx = 0;\n\t\twhile (1) {\n\t\t\tV[cur] = true;\n\t\t\tx++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif (V[cur]) { break; }\n\t\t}\n\t\tans += min(S + (x - 2)*m, m + S + (x + 1)*s);\n\towata:;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tcin >> n;\n\ts = INF;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tcout << minimum_cost_sort() << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<list>\nusing namespace std;\n\ntypedef struct{int a;int b;int c;} arr;\ntypedef pair<long long,long long> logg;\n\narr L[510],R[510];\n\nint merge(arr a[],int l,int m,int r,char c)\n{\n\tint n1=m-l;\n\tint n2=r-m;\n\tfor(int i=0;i<n1;i++)\n\t{\n\t\tL[i]=a[l+i];\n\t}\n\tfor(int i=0;i<n2;i++)\n\t{\n\t\tR[i]=a[m+i];\n\t}\n\tint i=0,j=0;\n\tif(c=='a')\n\t{\n\t\tL[n1].a=100000;R[n2].a=100000;\n\t\tfor(int k=l;k<r;k++)\n\t\t{\n\t\t\tif(L[i].a<=R[j].a)\n\t\t\t{\n\t\t\t\ta[k]=L[i++];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta[k]=R[j++];\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tL[n1].c=100000;R[n2].c=100000;\n\t\tfor(int k=l;k<r;k++)\n\t\t{\n\t\t\tif(L[i].c<=R[j].c)\n\t\t\t{\n\t\t\t\ta[k]=L[i++];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta[k]=R[j++];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint mergeS(arr a[],int l,int r,char c)\n{\n\tif(l+1<r)\n\t{\n\t\tint m=(l+r)/2;\n\t\tmergeS(a,l,m,c);\n\t\tmergeS(a,m,r,c);\n\t\tmerge(a,l,m,r,c);\n\t}\n}\n\n\nint main()\n{\n\tint n,j=1;cin>>n;\n\tarr a[1010];\n\tlogg c[1010];\n\tfor(int i=1;i<=n;cin>>a[i++].a);a[n+1].a==1;\n\t\n\t\n\tfor(int i=1;i<=n;a[i].c=i,i++);\n\tmergeS(a,1,n+1,'a');\n\tfor(int i=1;i<=n;a[i].b=i,i++);\n\tmergeS(a,1,n+1,'c');\n\t\n\t\n\tfor(int i=1,m=100000;;)\n\t{\n\t\tif(a[i].b!=0)//.b\n\t\t{\n\t\t\tc[j].first++;\n\t\t\tc[j].second+=a[i].a;\n\t\t\tif(a[i].a<m)m=a[i].a;\n\t\t\tint l=a[i].b;//.b\n\t\t\ta[i].b=0;//.b\n\t\t\ti=l;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(c[j].first==1)\n\t\t\t{\n\t\t\t\tc[j].second=0;\n\t\t\t}\n\t\t\telse if(c[j].first>=3)\n\t\t\t{\n\t\t\t\tc[j].second+=m*(c[j].first-2);\n\t\t\t}\n\t\t\tm=100000;\n\t\t\tj++;\n\t\t\tint s=0;\n\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t{\n\t\t\t\ts+=a[k].b;//a\n\t\t\t\tif(a[k].b!=0)i=k;//a\n\t\t\t}\n\t\t\tif(s==0)break;\n\t\t}\n\t}\n\tlong long s=0;\n\tfor(int i=1;i<=j;i++)\n\t{\n\t\ts+=c[i].second;\n\t}\n\tcout<<s<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<list>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\nint main(void)\n{\n\tint n, W, MIN = 100001, sum = 0, p = 0, pp, cost = 0, k = 0, min = 100001;\n\tcin >> n;\n\tvector<int> box, list;\n\tvector<bool> mark;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> W;\n\t\tbox.push_back(W);\n\t\tlist.push_back(W);\n\t\tmark.push_back(false);\n\t\tif (W < MIN)\n\t\t\tMIN = W;\n\t}\n\tsort(list.begin(), list.end());\n\twhile (p < n) {\n\t\tif (mark[p] == false) {\n\t\t\tsum = 0;\n\t\t\tk = 0;\n\t\t\tmin = 100001;\n\t\t\tpp = p;\n\t\t\twhile (mark[pp] == false) {\n\t\t\t\tmark[pp] = true;\n\t\t\t\tsum += box[pp];\n\t\t\t\tk++;\n\t\t\t\tif (box[pp] < min)\n\t\t\t\t\tmin = box[pp];\n\t\t\t\tpp = find(list.begin(), list.end(), box[pp]) - list.begin();\n\t\t\t}\n\t\t\tif (sum + (k - 2) * min > sum + min + (k + 1) * MIN)\n\t\t\t\tcost += sum + min + (k + 1) * MIN;\n\t\t\telse\n\t\t\t\tcost += sum + (k - 2) * min;\n\t\t\tp++;\n\t\t}\n\t\telse\n\t\t\tp++;\n\t}\n\tcout << cost << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm> \nusing namespace std;\nint a[1000],b[1000],c[10000],min1=100000,min2=100000,x[1000];\nint main(){\n\tint n,sum=0,s,n1;\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t  {cin>>a[i];\n\t  if(min1>a[i]) min1=a[i];\n\t  b[i]=a[i];\n\t  }\n\t  sort(b,b+n);\n\t  for(int i=0;i<n;i++)\n\t  c[b[i]]=i;\n\t  for(int i=0;i<n;i++){\n\t  \ts=0;min2=100000;n1=0;\n\t  \t   while(a[i]!=b[i]&&x[i]==0)\n\t  \t     { x[i]=1;n1++;\n\t\t\t   s+=a[i];\n\t  \t    min2=min(a[i],min2);\n\t\t\t   i=c[a[i]];\n\t  \t      if(x[i]) sum+=min(s+(n1-2)*min2,s+min2+(n1+1)*min1);\n\t  \t    }  \t    \t  \n\t  }\n\t  cout<<sum<<endl;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\nint n;\nint w[1000];\nint k[1000];\nint u[1000];\n\nint main(){\n\tscanf(\"%d\", &n);\n\trep(i, n){\n\t\tscanf(\"%d\", &w[i]);\n\t}\n\n\tvector<int> v(w, w + n);\n\tsort(v.begin(), v.end());\n\trep(i, n){\n\t\tk[i] = lower_bound(v.begin(), v.end(), w[i]) - v.begin();\n\t}\n\n\tint ans = 0;\n\trep(i, n){\n\t\tif(u[i]){\n\t\t\tcontinue;\n\t\t}\n\t\tint c = 1;\n\t\tint s = w[i];\n\t\tint m = w[i];\n\t\tu[i] = true;\n\t\tint j = k[i];\n\t\twhile(!u[j]){\n\t\t\t++c;\n\t\t\ts += w[j];\n\t\t\tm = min(m, w[j]);\n\t\t\tu[j] = true;\n\t\t\tj = k[j];\n\t\t}\n\t\tans += s + m * (c - 2);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\n#include<cmath>\nusing namespace std;\n\nvoid show_mincost( int arr[], size_t arr_s, int swap_l_val, int swap_r_val )\n{\n\tcout<<arr[0]<<flush;\n    for( size_t i=1; i<arr_s; i++ ){\n\t\tif( arr[i] == swap_l_val || arr[i] == swap_r_val ){\n\t\t\tcout<<\"(\"<<arr[i]<<')';\n\t\t}else{\n\t\t\tcout<<' '<<arr[i]<<' ';\n\t\t}\n    }\n\tcout<<' '<<\"COST : \"<<swap_l_val<<\" + \"<<swap_r_val<<\" == \"<<swap_l_val+swap_r_val<<endl;\n}\n\nvoid show( int arr[], size_t size )\n{\n\n\tcout<<arr[0]<<flush;\n    for( size_t i=1; i<size; i++ ){\n\t    cout<<' '<<arr[i]<<flush;\n    }\n    cout<<endl;\n}\n\n\n\n\nint merge( int arr[], unsigned int arr_s, unsigned int lft, unsigned int md, unsigned int rgt )\n{\n\tint cnt=0;\n\n\tint left_s=md-lft+1, right_s=rgt-md+1, *left=new int[left_s], *right=new int[right_s];\n\tfor( int i=0; i<left_s-1; i++ ){\n\t\tleft[i]=arr[lft+i];\n\t}\n\tleft[left_s-1]=INT_MAX;\n\tfor( int i=0; i<right_s-1; i++ ){\n\t\tright[i]=arr[md+i];\n\t}\n\tright[right_s-1]=INT_MAX; \n\n\n\tfor( int i=0, left_i=0, right_i=0; i<left_s+right_s-2; i++, cnt++ ){\n\t\tif( left[left_i] <= right[right_i] ){ \n\t\t\tarr[lft+i]=left[left_i];\n\t\t\t++left_i;\n\t\t}else{\n\t\t\tarr[lft+i]=right[right_i];\n\t\t\t++right_i;\n\t\t}\n\t}\n\n\tdelete[] right;delete[] left;\n\treturn cnt;\n}\nint mergeSort( int arr[], unsigned int arr_s, unsigned int lft, unsigned int rgt ) \n{\n\tstatic int cnt=0;\n\t\tunsigned int md=(lft + rgt)/2;\n\tif( rgt - lft >=2 ){\n\n\t\tmergeSort(arr, arr_s, lft, md);  \n\t\tmergeSort(arr, arr_s, md, rgt);\n\t\tcnt+= merge(arr, arr_s, lft, md, rgt); \n\t\n\t}\n\treturn cnt;\n}\nsize_t idxKey( int arr[], size_t arr_s, int key )\n{\n\tfor( size_t i=0; i!=arr_s; i++ ){\n\t\tif( arr[i] == key ) return i;\n\t}\n\treturn arr_s;\n}\n\nunsigned int minCost( int arr[], size_t arr_s )\n{\n\tint *sorted=new int[arr_s];\n\tfor( size_t i=0; i<arr_s; i++ ){\n\t\tsorted[i]=arr[i];\n\t}\n\tmergeSort(sorted, arr_s, 0, arr_s); //????????????????????¶?????¨???????????¨\n//\tshow(sorted, arr_s);\n\n\tunsigned int cost=0;\n\tint swap_l_val, swap_l_idx, swap_r_val, swap_r_idx;\n\tfor( size_t i=0; ; ){ \n\t\twhile( idxKey( arr, arr_s, sorted[i] ) == i ){\n\t\t\ti++;\n\t\t}\n\t\tswap_l_idx= idxKey(arr, arr_s, sorted[i]);//?°????????????????i?????????????????\\??£???????????????????????????\n\t\tswap_r_idx= idxKey( arr, arr_s, sorted[idxKey(arr, arr_s, sorted[i] ) ] );\n//?°????????????????i???????????\\??£?????????,arr???????????????????????¨???????????????????????????sorted???????????\\??£?????????arr?????????????????????\n\t\tif( swap_l_idx == swap_r_idx ) break;\n\n\t\tswap_l_val=arr[ swap_l_idx];\n\t\tswap_r_val=arr[ swap_r_idx];\n//\t\tcout<<\"swap_l_val : \"<<swap_l_val<<' '<<\"swap_r_val : \"<<swap_r_val<<endl;\n\n\t\tswap( arr[ idxKey(arr, arr_s, sorted[i]) ], arr[ idxKey( arr, arr_s, sorted[idxKey(arr, arr_s, sorted[i])] )]);\n\t\tcost+=swap_l_val + swap_r_val; \n\n//\t\tshow_mincost(arr, arr_s, swap_l_val, swap_r_val);\n\t}\n\treturn cost;\n}\n\nint main()\n{\n\tsize_t arr_s;cin>>arr_s;\n\tint *arr=new int[arr_s];\n\tfor( size_t i=0; i<arr_s; i++ ){\n\t\tcin>>arr[i];\n\t}\n\n\tlong long mincst=minCost( arr, arr_s );\n//\tshow(arr, arr_s);\n\tcout<<mincst<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <clocale>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(false); cin.tie(0);\n#define FOR(i, s, n) for(int i = (s), i##_len=(n); i < i##_len; ++i)\n#define FORS(i, s, n) for(int i = (s), i##_len=(n); i <= i##_len; ++i)\n#define VFOR(i, s, n) for(int i = (s); i < (n); ++i)\n#define VFORS(i, s, n) for(int i = (s); i <= (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPS(i, n) FORS(i, 0, n)\n#define VREP(i, n) VFOR(i, 0, n)\n#define VREPS(i, n) VFORS(i, 0, n)\n#define RFOR(i, s, n) for(int i = (s), i##_len=(n); i >= i##_len; --i)\n#define RFORS(i, s, n) for(int i = (s), i##_len=(n); i > i##_len; --i)\n#define RREP(i, n) RFOR(i, n, 0)\n#define RREPS(i, n) RFORS(i, n, 0)\n#define ALL(v) (v).begin(), (v).end()\n#define SORT(v) sort(ALL(v))\n#define RSORT(v) sort(ALL(v), greater<decltype(v[0])>())\n#define SZ(x) ((int)(x).size())\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define GRAYCODE(i) ((i) ^ ((i) >> 1))\n\nusing ll = long long;\nusing Pi_i = pair<int, int>;\nusing VB = vector<bool>;\nusing VC = vector<char>;\nusing VD = vector<double>;\nusing VI = vector<int>;\nusing VLL = vector<ll>;\nusing VS = vector<string>;\nusing VSH = vector<short>;\n\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\n\ntemplate<class T>\nbool chmax(T &a, const T &b){\n    if(a < b){\n        a = b; return true;\n    }\n    return false;\n}\ntemplate<class T>\nbool chmin(T &a, const T &b){\n    if(b < a){\n        a = b; return true;\n    }\n    return false;\n}\n\n\n\n\nint main(){\n    int n, minv = INF, maxv = 0; cin >> n;\n    VI w(n), s(n);\n    REP(i, n){\n        cin >> w[i]; chmin(minv, w[i]);\n        s[i] = w[i]; chmax(maxv, w[i]);\n    }\n    VI nextidx(maxv + 1);\n    SORT(s);\n    int ans = 0;\n    VB used(n, false);\n    REP(i, n) nextidx[s[i]] = i;\n    REP(i, n){\n        if(used[i]) continue;\n        int cur = i, sum = 0, minincircle = maxv, cirmem = 0;\n        while(1){\n            used[cur] = true; ++cirmem;\n            int v = w[cur]; chmin(minincircle, v);\n            sum += v;\n            cur = nextidx[v];\n            if(used[cur]) break;\n        }\n        ans += min(sum + (cirmem-2)*minincircle,\n                   sum + minincircle + (cirmem+1)*minv);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nvoid merge(vector<pair<int,int> >& w, int left, int mid, int right) {\n\tvector<pair<int,int> > L,R;\n\tint n1=mid-left;\n\tint n2=right-mid;\n\tint i=0,j=0,k;\n\tL.resize(n1+1);\n\tR.resize(n2+1);\n\tfor(i=0; i<n1; ++i) {\n\t\tL[i]=w[left+i];\n\t}\n\tL[n1].first = -1;\n\tL[n1].second = 1000000001;\n\tfor(i=0; i<n2; ++i) {\n\t\tR[i]=w[mid+i];\n\t}\n\tR[n2].first = -1;\n\tR[n2].second = 1000000001;\n\n\ti=j=0;\n\tfor(k=left; k<right; ++k) {\n\t\tif(L[i].second < R[j].second) {\n\t\t\tw[k]=L[i];\n\t\t\t++i;\n\t\t} else {\n\t\t\tw[k]=R[j];\n\t\t\t++j;\n\t\t}\n\t}\n\treturn;\n}\n\nvoid mergeSort(vector<pair<int,int> >& w, int left, int right) {\n\tif(left+1<right) {\n\t\tint mid=left+(right-left)/2;\n\t\tmergeSort(w,left,mid);\n\t\tmergeSort(w,mid,right);\n\t\tmerge(w,left,mid,right);\n\t}\n\treturn;\n}\n\nint main() {\n\tint n;\n\tint i;\n\tint total=0;\n\tvector<pair<int,int> > w;\n\tscanf(\"%d\",&n);\n\tw.resize(n);\n\tfor(i=0; i<n; ++i) {\n\t\tw[i].first=i;\n\t\tscanf(\"%d\",&w[i].second);\n\t}\n\tmergeSort(w,0,n);\n\tfor(i=0; i<n; ++i) {\n\t\ttotal+=(w[i].first!=i?w[i].second:0);\n\t}\n\tprintf(\"%d\\n\",total);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <cstdio>\nint main(){\n\tint N,r=0;\n\tscanf(\"%d\",&N);\n\tstd::vector<int>v(N);\n\tfor(int i=0;i<N;i++)scanf(\"%d\",&v[i]);\n\tfor(int i=N-1;i>=0;i--){\n\t\tint ma=v[i],idx=i;\n\t\tfor(int j=i-1;j>=0;j--)if(ma<v[j])ma=v[j],idx=j;\n\t\tif(ma>v[i]){\n\t\t\tr+=v[i]+v[idx];\n\t\t\tstd::swap(v[i],v[idx]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int VMAX=10001;\\\nint T[VMAX+1];\nint solve(int A[],int n,int Min){\n  int ans=0;\n\n  int *B=new int[n];\n  bool *v=new bool[n];\n  for(int i=0;i<n;i++){\n  \tB[i]=A[i];\n  \tv[i]=false;\n  }\n\n  sort(B,B+n);\n  for(int i=0;i<n;i++)T[B[i]]=i;\n  for(int i=0;i<n;i++){\n  \tif(v[i])continue;\n  \tint an = 0;\n\tint m = VMAX;//\n\tint cur = i;\n\tint s = 0;\n\twhile(1){\n\t  \t  an++;\n\t      v[cur]=true;\n\t      int t=A[cur];\n\t      m=min(m,t);\n\t      s+=t;\n\t      cur=T[t];\n\t      if(v[cur])break;\n\t   }\n\t   ans+=min(s+(an-2)*m,s+m+(n-1)*Min);    \n\n  \t}\n  \n  \n\n  return ans;\n}\nint main(){\n\tint n;\n\tint Min=VMAX;//\n\tcin>>n;\n\tint *A=new int[n];\n\tfor(int i=0;i<n;i++){\n\t\tcin>>A[i];\n\t\tMin=min(Min,A[i]);\n\t}\n\tint ans=solve(A,n,Min);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdint.h>\n#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <climits>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define DEBUG (0)\n\n#if DEBUG\n#define DPRINTF(...) do { \\\n    printf(\"D(L%d) %s: \", __LINE__, __func__); \\\n    printf(__VA_ARGS__); \\\n  } while (false)\n#else\n#define DPRINTF(...)\n#endif // DEBUG\n\nint g_cost = 0;\n\nvoid swap(int array[], int i0, int i1)\n{\n  int temp = array[i1];\n  array[i1] = array[i0];\n  array[i0] = temp;\n}\n\n\nint findIndexOf(int val, const int array[], int numOfArray)\n{\n  for (int i = 0; i < numOfArray; i++)\n    if (array[i] == val)\n      return i;\n\n  // if cannot find the val, call assertion error.\n  assert(0);\n\n  return -1;\n}\n\n\n// The formula is : Sigma(Wi) + min(Wi) * (N-2)\nint calcCostSimple(const int array[], const vector<int> &l)\n{\n  int s = 0;\n  int minimum = INT_MAX;\n  for (uint32_t i = 0; i < l.size(); i++)\n  {\n    int idx = l[i];\n    s += array[idx];\n    minimum = min(minimum, array[idx]);\n  }\n\n  DPRINTF(\"s %d  minimum %d\\n\", s, minimum);\n\n  return s + minimum * (l.size() - 2);\n}\n\n\n// The formula is : Sigma(Wi) + min(Wi) + x * (N+1)\nint calcCostSwap(const int array[], const vector<int> &l, int x)\n{\n  if (array == nullptr || l.size() < 1 || x < 0)\n  {\n    assert(1);\n    return INT_MAX;\n  }\n\n  int s = 0;\n  int minimum = INT_MAX;\n  for (uint32_t i = 0; i < l.size(); i++)\n  {\n    int idx = l[i];\n    s += array[idx];\n    minimum = min(minimum, array[idx]);\n  }\n\n  DPRINTF(\"s %d  minimum %d  x %d\\n\", s, minimum, x);\n\n  return s + minimum + x * (l.size() + 1);\n}\n\n\nint findMinOutsideLoop(vector<int> indices, int max, const int sortedArray[])\n{\n  sort(indices.begin(), indices.end());\n\n  for (int i = 0; i < max; i++)\n    if (indices[i] != i)\n      return sortedArray[i];\n\n  // the case l and sortedArray are the same\n  return INT_MAX;\n}\n\n\nint main()\n{\n  int numOfArray;\n  cin >> numOfArray; cin.ignore();\n\n  int array[numOfArray];\n  for (int i = 0; i < numOfArray; i++)\n    cin >> array[i];\n\n#if DEBUG\n  for (int i = 0; i < numOfArray; i++)\n    if (i == 0) DPRINTF(\"%2d\", array[i]);\n    else        printf(\" %2d\", array[i]);\n  cout << endl;\n#endif // DEBUG\n\n  int sortedArray[numOfArray];\n  for (int i = 0; i < numOfArray; i++)\n    sortedArray[i] = array[i];\n\n  sort(sortedArray, sortedArray + numOfArray);\n\n#if DEBUG\n  for (int i = 0; i < numOfArray; i++)\n    if (i == 0) DPRINTF(\"%2d\", sortedArray[i]);\n    else        printf(\" %2d\", sortedArray[i]);\n  cout << endl;\n#endif // DEBUG\n\n  // First, find a loop where each element is sorted\n  //   Suppose array of { 2 1 8 10 7 9 }\n  //   then, sorted array should be { 1 2 7 8 9 10 }\n  //   In this case, we could find two loops;\n  //     Loop 1 : { 2 1 } - { 1 2 }\n  //     Loop 2 : { 8 10 7 9 } - { 7 8 9 10 }\n\n  bool visited[numOfArray];\n  fill(visited, visited + numOfArray, 0);\n\n  vector<vector<int>> loops;\n\n  for (int i = 0; i < numOfArray; i++)\n  {\n    if (visited[i])\n      continue;\n\n    int idx = i;\n    vector<int> loop;\n\n    while (!visited[idx])\n    {\n      loop.push_back(idx);\n      visited[idx] = true;\n\n      int num = array[idx];\n      idx = findIndexOf(num, sortedArray, numOfArray);\n    }\n\n    loops.push_back(loop);\n  }\n\n  // Let's calculate a cost when we will need to sort out\n  // Note that we have to check two cases in a way of sorting, and compare of which is light\n  // Take a look at loop 2 case;\n  //   { 8 10 7 9 } will sorted, and it becomes { 7 8 9 10 }\n  //   The cost should be 48;\n  //   The general formula will be : Sigma(Wi) + min(Wi) * (N-2)\n  //\n  //   Be careful that we could swap with a number of another loop;\n  //   Let's say swap 1 of loop 1 with 7 of loop 2\n  //   and sort { 8 10 1 9 }, and it will be { 1 8 9 10 }\n  //   then swap again, 1 and 7, finally the array will be sorted properly as { 7 8 9 10 }\n  //   In this case, the cost should be 45\n  //   The general formula should be : Signma(Wi) + min(Wi) + x * (N+1)\n\n  for (uint32_t i = 0; i < loops.size(); i++)\n  {\n\n    const vector<int> l = loops[i];\n\n#if DEBUG\n    DPRINTF(\"Loop %d : \",i);\n    for (uint32_t j = 0; j < l.size(); j++) {\n      printf(\" %d\", array[l[j]]);\n    }\n    cout << endl;\n#endif\n\n    if (l.size() < 2)\n      continue; // means the number will be alredy sorted, no need to consider\n\n    int costA, costB;\n    costA = calcCostSimple(array, l);\n    int x = findMinOutsideLoop(l, numOfArray, sortedArray);\n    if (x == INT_MAX)\n      costB = INT_MAX;\n    else\n      costB = calcCostSwap(array, l, x);\n\n    g_cost += min(costA, costB);\n\n    DPRINTF(\"Loop %d : Simple %d  Swap %d  g_cost %d\\n\", i, costA, costB, g_cost);\n  }\n\n  cout << g_cost << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <tuple>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n#define square(x) (x) * (x)\n#define cube(x) (x) * (x) * (x)\n\nconst int INF = 1e9;\n\nusing namespace std;\n\nbool stable = true;\n\nint main() {\n    int n;\n    int cost = 0;\n    cin >> n;\n    vector<int> a(n);\n    vector<bool> miss(n);\n    REP(i, n) cin >> a[i];\n    auto b = a;\n    sort(ALL(a));\n    REP(i, n){\n        miss[i] = (a[i] != b[i]);\n    }\n    REP(i, n){\n        if(miss[n-1-i]){\n            int replace = find(ALL(b), a[n-1-i]) - b.begin();\n            if(b[n-1-i] == a[replace]){\n                swap(b[n-1-i], b[replace]);\n                cost += b[n-1-i] + b[replace];\n                miss[n-1-i] = false;\n                miss[replace] = false;\n            }\n        }\n    }\n    REP(i, n){\n        if(miss[n-1-i]){\n            int replace = find(ALL(b), a[n-1-i]) - b.begin();\n            miss[n-1-i] = false;\n            if(b[n-1-i] == a[replace])\n                miss[replace] = false;\n            swap(b[n-1-i], b[replace]);\n            cost += b[n-1-i] + b[replace];\n        }\n    }\n\n    cout << cost << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    pair<int,int> w[1000];\n    vector<pair<int,int> > block;\n    cin>>n;\n    for(int i=0; i<n; i++) {\n        cin>>w[i].first;\n        w[i].second=i;\n    }\n    sort(w, w+n);\n    int cost=0;\n    for(int i=0; i<n; i++) {\n        if(w[i].first!=-1) {\n            int m=0;\n            for(int c=w[i].second; c!=i; c=w[c].second) {\n                m++;\n                cost+=w[c].first;\n                w[c].first=-1;\n            }\n            block.push_back(make_pair<int,int>(w[i].first, m));\n        }\n    }\n    for(int i=0; i<block.size(); i++) cost+=min(block[i].first*block[i].second, block[i].first*2+w[0].first*(block[i].second+2));\n    cout<<cost<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define MAX 200000\n#define SENTINEL 2000000000\ntypedef long long llong;\n\nint L[MAX / 2 + 2], R[MAX / 2 + 2];\n\nllong merge (int A[], int n, int left, int mid, int right){\n  int i, j, k;\n  llong cnt = 0;\n  int n1 = mid -left;\n  int n2 = right -mid;\n  for (int i = 0; i < n1; ++i) L[i] = A[left +i];\n  for (int i = 0; i < n2; ++i) R[i] = A[mid +i];\n  L[n1] = R[n2] = SENTINEL;\n  i = j = 0;\n  for (int k = 0; k < right; ++k)\n   {\n     if(L[i] <= R[j]){\n      A[k] = L[i++];\n     }else{\n      A[k] =R[j++];\n      cnt += n1 - i ; \n     }\n   } \n\nreturn cnt;\n\n\n}\n\nllong mergeSort(int A[],int n, int left, int right){\n\n  int mid;\n  llong v1, v2, v3;\n  if( left + 1 < right ){\n    mid =(left +right)/2;\n    v1 =mergeSort(A,n,left,mid);\n    v2 =mergeSort(A,n,mid,right);\n    v3 =merge(A,n,left,mid, right);\n    return v1 +v2 +v3;\n  }else return 0;\n\n}\n\nint main(){\n  int A[MAX], n, i;\n\n  cin >> n;\n  for (int i = 0; i < n; ++i)\n  {\n    cin >> A[i];\n  }\n\n  llong ans = mergeSort(A,n,0,n);\n  cout << ans << endl;\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <sstream>\n#include <string.h>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <deque>\n#include <limits>\n#include <iomanip>\n#include <ctype.h>\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <math.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, char> pic;\n#define bit(x,v) ((ll)x << v)\n\nconst ll INF = 1000000007;\nconst int MAX = 210000;\nconst int MOD = 1000000007;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit() {\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i < MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t}\n}\n\n// 二項係数計算\nlong long COM(int n, int k) {\n\tif (n < k) return 0;\n\tif (n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\nint pr[100010];\nvoid uini(int n) {\n\tfor (size_t i = 0; i <= n; i++)\n\t{\n\t\tpr[i] = i;\n\t}\n}\n\nint parent(int x) {\n\tif (x == pr[x]) return x;\n\treturn pr[x] = parent(pr[x]);\n}\n\nbool unit(int x, int y) {\n\tint px = parent(x);\n\tint py = parent(y);\n\n\tif (px == py) return false;\n\tif (px < py) {\n\t\tpr[py] = px;\n\t}\n\telse {\n\t\tpr[px] = py;\n\t}\n\treturn true;\n}\n\nll bit[200010];\nint max_n = 200000;\nint pm = 0;\nvoid add(int x) {\n\n\twhile (max_n >= x)\n\t{\n\t\tbit[x]++;\n\t\tx += x & -x;\n\t}\n}\nvoid sub(int x) {\n\twhile (max_n >= x)\n\t{\n\t\tbit[x]--;\n\t\tx += x & -x;\n\t}\n}\nll merge(ll *a, int left, int mid, int right) {\n\tll n1 = mid - left;\n\tll n2 = right - mid;\n\tvector<int> L(n1 + 1);\n\tvector<int> R(n2 + 1);\n\tfor (size_t i = 0; i < n1; i++)\n\t{\n\t\tL[i] = a[left + i];\n\t}\n\tfor (size_t i = 0; i < n2; i++)\n\t{\n\t\tR[i] = a[mid + i];\n\t}\n\n\tL[n1] = INF;\n\tR[n2] = INF;\n\tll i = 0;\n\tll j = 0;\n\tll r = 0;\n\tfor (size_t k = left; k < right; k++)\n\t{\n\t\tif (L[i] <= R[j]) {\n\t\t\ta[k] = L[i];\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\ta[k] = R[j];\n\t\t\tr += n1 - i;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn r;\n}\nll merge2(pair<int,char> *a, int left, int mid, int right) {\n\tll n1 = mid - left;\n\tll n2 = right - mid;\n\tvector<pair<int, char>> L(n1 + 1);\n\tvector<pair<int, char>> R(n2 + 1);\n\tfor (size_t i = 0; i < n1; i++)\n\t{\n\t\tL[i] = a[left + i];\n\t}\n\tfor (size_t i = 0; i < n2; i++)\n\t{\n\t\tR[i] = a[mid + i];\n\t}\n\n\tL[n1] = make_pair(INF,' ');\n\tR[n2] = make_pair(INF,' ');\n\tll i = 0;\n\tll j = 0;\n\tll r = 0;\n\tfor (size_t k = left; k < right; k++)\n\t{\n\t\tif (L[i].first <= R[j].first) {\n\t\t\ta[k] = L[i];\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\ta[k] = R[j];\n\t\t\tr += n1 - i;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn r;\n}\nll mergeSort2(pair<int, char> *a, int left, int right) {\n\tll res = 0;\n\tif (left + 1 < right) {\n\t\tint mid = (left + right) / 2;\n\t\tres = mergeSort2(a, left, mid);\n\t\tres += mergeSort2(a, mid, right);\n\t\tres += merge2(a, left, mid, right);\n\t}\n\treturn res;\n}\nll mergeSort(ll *a, int left, int right) {\n\tll res = 0;\n\tif (left + 1 < right) {\n\t\tint mid = (left + right) / 2;\n\t\tres = mergeSort(a, left, mid);\n\t\tres += mergeSort(a, mid, right);\n\t\tres += merge(a, left, mid, right);\n\t}\n\treturn res;\n}\nint partition(pair<int,char> *a, int p, int r) {\n\tpair<int, char> x = a[r];\n\tint i = p - 1;\n\tfor (size_t j = p; j < r; j++)\n\t{\n\t\tif (a[j].first <= x.first) {\n\t\t\ti++;\n\t\t\tswap(a[i], a[j]);\n\t\t}\n\t}\n\tswap(a[i + 1], a[r]);\n\treturn i + 1;\n}\nvoid quick(pair<int, char> *a, int p, int r) {\n\tif (p < r) {\n\t\tint q = partition(a, p, r);\n\t\tquick(a, p, q - 1);\n\t\tquick(a, q + 1, r);\n\t}\n}\nint n;\nll calc(vector<int> a, vector<int> b,vector<int> ind) {\n\tll res = 0;\n\tvector<int> at(a.begin(), a.end());\n\tvector<int> bt(b.begin(), b.end());\n\tvector<int> indt(ind.begin(), ind.end());\n\tfor (size_t i = 0; i < n; i++)\n\t{\n\t\tll tm = 0;\n\t\twhile (a[i] != b[i]) {\n\n\t\t\tint v = b[i];\n\t\t\tint fr = ind[v];\n\t\t\tint com = b[fr];\n\t\t\tint to = ind[com];\n\t\t\tswap(ind[v], ind[com]);\n\t\t\ttm += v + com;\n\t\t\tswap(a[fr], a[to]);\n\t\t}\n\n\t\tll t2 = 0;\n\t\tif (i > 0 && at[i] != bt[i]) {\n\t\t\tt2 += at[indt[bt[i]]] + at[0];\n\t\t\tint id = bt[i];\n\t\t\tswap(at[indt[id]], at[0]);\n\t\t\tswap(indt[bt[i]], indt[b[0]]);\n\t\t}\n\t\twhile (at[0] != bt[0]) {\n\t\t\tint v = bt[0];\n\t\t\tint fr = indt[v];\n\t\t\tint com = bt[fr];\n\t\t\tint to = indt[com];\n\t\t\tswap(indt[v], indt[com]);\n\t\t\tt2 += v + com;\n\t\t\tswap(at[fr], at[to]);\n\t\t}\n\n\t\tres += min(tm, t2);\n\t}\n\treturn res;\n}\nll calcz(vector<int> a, int *b, vector<int> ind) {\n\tll res = 0;\n\tfor (size_t i = 0; i < n; i++)\n\t{\n\n\t\tif (i > 0 && a[0] == 0 && a[i] != b[i]) {\n\t\t\tres += a[ind[b[i]]];\n\t\t\tint id = b[i];\n\t\t\tswap(a[ind[id]], a[0]);\n\t\t\tswap(ind[b[i]], ind[0]);\n\t\t}\n\t\twhile (a[0] != b[0]) {\n\t\t\tint v = b[0];\n\t\t\tint fr = ind[v];\n\t\t\tint com = b[fr];\n\t\t\tint to = ind[com];\n\t\t\tswap(ind[v], ind[com]);\n\t\t\tres += v + com;\n\t\t\tswap(a[fr], a[to]);\n\t\t}\n\t}\n\treturn res;\n}\nvoid solv() {\n\tcin >> n;\n\tvector<int> a(n);\n\tvector<int> b(n);\n\tvector<int> ind(10010);\n\tfor (size_t i = 0; i < n; i++)\n\t{\n\t\tcin >> b[i];\n\t\ta[i] = b[i];\n\t\tind[a[i]] = i;\n\t}\n\tsort(b.begin(), b.end());\n\tll r1 = calc(a, b,ind);\n\tcout << r1 << endl;\n\n}\nint main() {\n\t//\tCOMinit();\n\tsolv();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n \nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n \nint solve(){\nint ans = 0;\n \nbool V[MAX];\nfor(int i = 0; i < n; i++){\nB[i] = A[i];\nV[i] = false;\n}\nsort(B, B+n);\nfor(int i = 0; i < n; i++) T[B[i]] = i;\nfor(int i = 0; i < n; i++){ \nif(V[i]) continue;\nint cur = i;\nint S = 0;\nint m = VMAX;\nint an = 0;\nwhile(1){\nV[cur] = true;\nan++;\nint v = A[cur];\nm = min(m, v);\nS += v;\nif(V[cur]) break;\n}\nans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n}\nreturn ans;\n}\n \nint main(){\ncin >> n;\ns = VMAX;\n}\nint ans = solve();\ncount << ans << endl;\n \nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\nint t,n,a[1009],p,l,m;\ncin>>n;\np=0;l=0;\nfor(int i=0;i<n;i++) cin>>a[i];\nfor(int i=0;i< n; i++){\nm=a[i];\nfor(int j=i+1;j<n;j++){\nif(m > a[j]){\nm=a[j];\nl=j;\n}\n}\nif(a[i]!=m){\np=p+a[i]+a[l];\nswap(a[i],a[l]);\n\n}\n}\ncout<<p<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\n#include <cstdint>\n\nusing namespace std;\n\nint main() {\n    int32_t n;\n\n    cin >> n;\n    vector<int32_t> w(n);\n    for (int32_t i = 0; i < n; i++) {\n        cin >> w[i];\n    }\n\n    vector<int32_t> sorted(w);\n    sort(sorted.begin(), sorted.end());\n\n    unordered_map<int32_t, int32_t> index;\n    for (int32_t i = 0; i < n; i++) {\n        index[sorted[i]] = i;\n    }\n\n    int32_t cost = 0;\n    for (int32_t i = 0; i < n; i++) {\n        if (w[i] != sorted[i]) {\n            int32_t size = 1, sum = w[i], minval = INT32_MAX;\n            int32_t j = index[w[i]], j_new;\n            while (j != i) {\n                size++;\n                sum += w[j];\n                minval = min(minval, w[j]);\n                j_new = index[w[j]];\n                w[j] = sorted[j];\n                j = j_new;\n            }\n\n            cost += min(sum + minval * (size - 2), 2 * (sorted[0] + minval) + (sum - minval + sorted[0]) + sorted[0] * (size - 2));\n        }\n    }\n\n    cout << cost << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn=10000+5;\nconst int minn=1000+5;\nconst int inf=2e9+2;\nint n,a[minn],po[maxn];\nvoid solve()\n{\n\n    sort(a+1,a+n+1);\n    int f=0,tp=inf,t=0,tmin=a[1];\n    ll w=0,ans=0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if(po[a[i]]==i){continue;}\n        tp=inf;t=1;w=0;\n        int f=po[a[i]];\n        w+=a[i];\n        tp=a[i];\n        while(f!=i)\n        {\n            t++;tp=min(a[f],tp);\n            w+=a[f];\n            int tm=f;\n            f=po[a[f]];\n            po[a[tm]]=tm;\n        }\n        ans+=min(w+(t-2)*tp,w+tp+(t+1)*tmin);\n    }\n    printf(\"%lld\\n\",ans);\n}\nint main()\n{\n    scanf(\"%d\",&n);\n\tfor (int i = 1; i <= n; ++i)\n    {\n        scanf(\"%d\",&a[i]);\n        po[a[i]]=i;\n    }\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve() {\n\tint ans = 0;\n\n\tbool V[MAX];\n\tfor (int i = 0; i < n; i++) {\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; i++)T[B[i]] = i;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (V[i])continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile (1) {\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif (V[cur])break;\n\t\t}\n\t\t\tans += min(S + (an - 2)*m, m + S + (an + 1)*s);\n\t}\n\n\t\treturn ans;\n}\n\n\tint main() {\n\t\tcin >> n;\n\t\ts = VMAX;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> A[i];\n\t\t\ts = min(s, A[i]);\n\t\t}\n\t\tint ans = solve();\n\t\tcout << ans << endl;\n\n\t\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "//\n// Created by 李青坪 on 2018/10/15.\n//\n\n#include \"cstdio\"\n#include \"algorithm\"\nusing namespace std;\n#define MAXN 1000\n#define MAXV 10000\n\nint a[MAXN], b[MAXN];\nint T[MAXV+1]; //记录排序过后原来的元素应该移动到的位置\nint m = MAXV;\n\nint findMinimumCost(int n){\n    bool v[n];\n    for (int i = 0; i < n; ++i) {\n        b[i] = a[i];\n        v[i] = false;\n    }\n    sort(b, b+n);\n    for (int j = 0; j < n; ++j) {\n        T[b[j]] = j;\n    }\n    int S = 0;\n    for (int k = 0; k < n; ++k) {\n        if (v[k]) continue;\n        int cur = k;\n        int nn = 0; //记录圆中有多少个元素\n        int sm = MAXV; //记录圆中的最小元素\n        int sum = 0; //记录圆中各元素的和\n        while (true){\n            v[cur] = true;\n            int value = a[cur];\n            ++nn;\n            sum += value;\n            sm = min(sm, value);\n            cur = T[value];\n            if (cur == k) break;\n        }\n        S += min(sum + (nn-2)*sm, sum + sm + (nn+1)*m); //是圆内交换代价更小还是借用外来元素的代价更小\n    }\n    return S;\n}\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &a[i]);\n        m = min(m, a[i]);\n    }\n    int ans = findMinimumCost(n);\n    printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define INF (2e9)\n\nint main() {\n  int n; cin >> n;\n  int A[1000];\n  int s = 10000;\n\n  for(int i = 0; i < n; ++i){\n    cin >> A[i];\n    s = min(s, A[i]);\n  }\n\n  int B[1000];\n  bool V[1000];\n  for(int i = 0; i < n; ++i){\n    B[i] = A[i];\n    V[i] = false;\n  }\n\n  sort(B, B+n);\n\n  int T[10001];\n  for(int i = 0; i < n; ++i){\n    T[B[i]] = i;\n  }\n\n  int ans = 0;\n  for(int i = 0; i < n; ++i){\n    if(V[i]) continue;\n    int an = 0;\n    int m = 10000;\n    int S = 0;\n    int cur = i;\n\n    while(1){\n      V[cur] = true;\n      an++;\n      int v = A[cur];\n      m = min(m, v);\n      S += v;\n      cur = T[v];\n      if(V[cur]) break;\n    }\n    ans += min(S+(an-2)*m, m+S+(an+1)*s);\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#incldue<map>\nusing namespace std;\nconst int MAXN = 1010;\nint w[MAXN];\nbool done[MAXN];\n \nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, mini = 100000;\n    cin >> n;\n    map<int, int> mp;\n    for (int i = 0; i < n; i++) {\n        cin >> w[i];\n        mp[w[i]] = 0;\n        mini = min(mini, w[i]);\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (done[i]) continue;\n        int cnt = 0, now = i, mi = 100000, sum = 0;\n        while (1) {\n            if (done[now]) break;\n            cnt++;\n            done[now] = true;\n            mi = min(mi, w[now]);\n            sum += w[now];\n            now = mp[w[now]];\n        }\n        int tmp = sum+(cnt-2)*mi;\n        tmp = min(tmp, sum+mi+mini*(cnt+1));\n        ans += tmp;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define MIN(a,b) ((a)<(b)?(a):(b))\n\nvoid merge(vector<pair<int,int> >& w, int left, int mid, int right) {\n\tvector<pair<int,int> > L,R;\n\tint n1=mid-left;\n\tint n2=right-mid;\n\tint i=0,j=0,k;\n\tL.resize(n1+1);\n\tR.resize(n2+1);\n\tfor(i=0; i<n1; ++i) {\n\t\tL[i]=w[left+i];\n\t}\n\tL[n1].first = -1;\n\tL[n1].second = 1000000001;\n\tfor(i=0; i<n2; ++i) {\n\t\tR[i]=w[mid+i];\n\t}\n\tR[n2].first = -1;\n\tR[n2].second = 1000000001;\n\n\ti=j=0;\n\tfor(k=left; k<right; ++k) {\n\t\tif(L[i].second < R[j].second) {\n\t\t\tw[k]=L[i];\n\t\t\t++i;\n\t\t} else {\n\t\t\tw[k]=R[j];\n\t\t\t++j;\n\t\t}\n\t}\n\treturn;\n}\n\nvoid mergeSort(vector<pair<int,int> >& w, int left, int right) {\n\tif(left+1<right) {\n\t\tint mid=left+(right-left)/2;\n\t\tmergeSort(w,left,mid);\n\t\tmergeSort(w,mid,right);\n\t\tmerge(w,left,mid,right);\n\t}\n\treturn;\n}\n\nint main() {\n\tint n;\n\tint i,j;\n\tint total=0;\n\tint subtotal,c;\n\tvector<int> checker;\n\tvector<pair<int,int> > w; // first=original_index, second =weight_value will be sorted.\n\tscanf(\"%d\",&n);\n\tw.resize(n);\n\tchecker.resize(n);\n\tfor(i=0; i<n; ++i) {\n\t\tchecker[i]=0;\n\t\tw[i].first=i;\n\t\tscanf(\"%d\",&w[i].second);\n\t}\n\tmergeSort(w,0,n);\n\tfor(i=0; i<n; ++i) {\n\t\tif(checker[i]==1 || w[i].first==i) {\n\t\t\tcontinue; // already checked or unmoved\n\t\t}\n\t\tc=subtotal=0;\n\t\tchecker[i]=1;\n\t\tj=w[i].first;\n\t\twhile(j!=i) {\n\t\t\tsubtotal+=w[i].second+w[j].second;\n\t\t\tchecker[j]=1;\n\t\t\tj=w[j].first;\n\t\t\t++c;\n\t\t}\n\t\ttotal+=MIN(subtotal,subtotal-w[j].second*(c-2)+w[i].second*(c+2));\n\t}\n\tprintf(\"%d\\n\",total);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n** 本题算法分析很有借鉴的必要，详见本书 p143-145\n*/\n\n# include <iostream>\n# include <algorithm>\n# include <cstdio>\n# include <cstring>\nusing namespace std;\n\nconst int maxn = 1000 + 5;\nconst int vmax = 10000 + 10;\n\nint a[maxn], b[maxn], n, t[maxn], minv;\n\nint solve() {\n    int ans = 0;\n    sort(b, b + n);\n    for (int i = 0; i < n; i++) {\n        if (t[i] != 0 || a[i] == b[i]) {\n            continue;\n        }\n\n        int m = vmax, an = 0, sum = 0;\n        int j = i;\n        while (true) {\n            t[j] = 1;\n            m = min(m, a[j]);\n            ++an;\n            sum += a[j];\n            j = lower_bound(b, b + n, a[j]) - b;\n            if (j == i) {\n                ans += min(sum + (an - 2) * m, sum + m + (an + 1) * minv);\n                break;\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    // freopen(\"infile\", \"r\", stdin);\n    // freopen(\"outfile\", \"w\", stdout);\n    cin >> n;\n    minv = vmax;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        minv = min(minv, a[i]);\n        b[i] = a[i];\n    }\n    memset(t, 0, sizeof(t));\n\n    cout << solve() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n        int n, ans=0, amin=10000;\n        cin>>n;\n        int a[n], b[n], T[n];\n        bool V[n];\n        for(int i=0;i<n;i++) V[i] = true;\n        for(int i=0;i<n;i++) {\n                cin>>a[i];\n                b[i]=a[i];\n                amin=min(a[i], amin);\n        }\n        sort(b, b+n);\n        for(int i=0;i<n;i++) T[b[i]] = i;\n\n        for(int i=0;i<n;i++) {\n                if(!V[i]) continue;\n                int j = i, tmpmin = a[i], c=0;\n                while(V[j]){\n                        c++;\n                        tmpmin = min(tmpmin, a[j]);\n                        ans += a[j];\n                        V[j] = false;\n                        j = T[a[j]];\n                }\n                ans += min((c-2)*tmpmin, tmpmin+(c+1)*amin);\n        }\n\n        cout<<ans<<endl;\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define fordebug int hoge;cin>>hoge;\n#define DEKAI 1000000007;\n#define INF 200000000\n#define int long long\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,j,n) for(int i=j;i<n;i++)\npair<int,char> a[100000],b[100000];\npair<int,char> rr[100000],ll[100000];\n\nsigned main(){\n\tint n;\n\tcin>>n;\n\tint a[1000],b[1000];\n\tint mini=INF;\n\tlp(i,n){\n\t\tcin>>a[i];\n\t\tb[i]=a[i];\n\t\tmini=min(mini,a[i]);\n\t}\n\tsort(b,b+n);\n\tint x[100000];\n\tlp(i,n){\n\t\tx[b[i]]=i;\n\t}\n\tint ans=0;\n\tbool done[1000]={false};\n\tlp(i,n){\n\t\tif(done[i]||a[i]==b[i]) continue;\n\t\tint sum=0,mini2=INF;\n\t\tint count=0;\n\t\tint j=i;\n\t\twhile(!done[j]){\n\t\t\tmini2=min(mini2,a[j]);\n\t\t\tsum+=a[j];\n\t\t\tdone[j]=true;\n\t\t\tj=x[a[j]];\n\t\t\tcount++;\n\t\t}\n\t\tint memo=sum;\n\t\tsum=sum-mini2+mini2*(count-1);\n\t\tmemo=memo+mini2+mini-2+mini*(count-1);\n\t\tans+=min(sum,memo);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n\nint minimumCountSort(int n, int* a)\n{\n    int sum_a = 0;\n    int min = 100000;\n    int B[1000], T[10001];\n    bool V[1000];\n    int ans = 0;\n    int min_a = 10000;\n\n    //?????????\n    for (int i = 0; i < n; i++) {\n\tB[i] = a[i];\n\tV[i] = false;\n\tif (min_a > a[i]) {\n\t    min_a = a[i];\n\t}\n    }\n    std::sort(B, B + n);\n    for (int i = 0; i < n; i++) {\n\tT[B[i]] = i;\n    }\n    int minSolve = sum_a + (n - 2) * min;\n    int* b = (int*)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n\tif (V[i]) {\n\t    continue;\n\t}\n\tint cur = i;\n\tint sum = 0;\n\tint min = 10000;\n\tint an = 0;\n\twhile (1) {\n\t    V[cur] = true;\n\t    an++;\n\t    int v = a[cur];\n\t    min = std::min(min, v);\n\t    sum += a[cur];\n\t    cur = T[v];\n\t    if (V[cur]) {\n\t\tbreak;\n\t    }\n\t}\n\tans += std::min(sum + (an - 2) * min, min + sum + (an + 1) * min_a);\n    }\n    return ans;\n}\n\nint main()\n{\n    int n = 0;\n    std::cin >> n;\n    int* a = (int*)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n\tstd::cin >> a[i];\n    }\n    int answer = minimumCountSort(n, a);\n    std::cout << answer << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int My_Inf=2147483647;\nconst long long int My_LInf=9223372036854775807;\n\n\n\n\n#define Seg_Max_N (1<<18) \n\nint dat[2 * Seg_Max_N];\nstruct segtree {\n\tint N;\n\tsegtree() {}\n\tsegtree(int n) {\n\t\tN = 1;\n\t\twhile (N < n) N *= 2;\n\t\tfor (int i = 0; i < 2 * N - 1; i++)\n\t\t\tdat[i] = My_Inf;\n\t}\n\t// update k th element\n\tvoid update(int k, int n) {\n\t\tk += N - 1; // leaf\n\t\tdat[k] = n;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tint al(dat[k * 2 + 1]);\n\t\t\tint ar(dat[k * 2 + 2]);\n\t\t\tdat[k] = min(al, ar);\n\t\t}\n\t}\n\t// min [a, b)\n\tint query(int a, int b) { return query(a, b, 0, 0, N); }\n\tint query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a or b <= l) return My_Inf;\n\t\tif (a <= l and r <= b) return dat[k];\n\t\tint m = (l + r) / 2;\n\t\tint al(query(a, b, k * 2 + 1, l, m));\n\t\tint ar(query(a, b, k * 2 + 2, m, r));\n\t\treturn min(al,ar);\n\t}\n};\n\nstruct bag {\n\tint place;\n\tint goodplace;\n\tint weight;\n};\nint main() {\n\tint n; cin >> n;\n\tvector<bag>bags;\n\tvector<int>heavys;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint a; cin >> a;\n\t\tbags.push_back(bag{ i,0,a });\n\t\theavys.push_back(a);\n\t}\n\n\tsort(bags.begin(), bags.end(), [](const bag&l, const bag&r) {return l.weight < r.weight; });\n\tfor (int i = 0; i < bags.size(); ++i) {\n\t\tbags[i].goodplace = i;\n\t}\n\tsegtree seg(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (bags[i].place != bags[i].goodplace) {\n\t\t\tseg.update(i, i);\n\t\t}\n\t}\n\tlong long int ans = 0;\n\twhile (1) {\n\t\tint a = seg.query(0, n);\n\t\tif (a == My_Inf) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (bags[a].place == i) {\n\t\t\t\t\tans += bags[i].weight + bags[a].weight;\n\t\t\t\t\tswap(bags[a].place, bags[i].place);\n\t\t\t\t\t\n\t\t\t\t\tseg.update(i, My_Inf);\n\t\t\t\t\tif (bags[a].place == bags[a].goodplace) {\n\t\t\t\t\t\tseg.update(a, My_Inf);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX=1000;\nstatic const int VMAX=10000;\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve(){\n  int ans=0;\n\n  bool V[MAX];\n  int i;\n  for(i=0;i<n;i++){\n    B[i]=A[i];\n    V[i]=false;\n  }\n  sort(B,B+n);\n\n  for(i=0;i<n;i++) T[B[i]]=i;\n  for(i=0;i<n;i++){\n    if(V[i]) continue;\n    int cur=i;\n    int S=0;\n    int m=VMAX;\n    int an=0;\n    while(1){\n      V[cur]=true;\n      an++;\n      int v=A[cur];\n      m=min(m,v);\n      S+=v;\n      cur=T[v];\n      if(V[cur]) break;\n    }\n    ans+=min(S+(an-2)*m,m+S+(an+1)*s);\n  }\n  return ans;\n}\n\nint main(){\n  cin>>n;\n  s=VMAX;\n  int i;\n  for(i=0;i<n;i++){\n    cin>>A[i];\n    s=min(s,A[i]);\n  }\n  int ans=solve();\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<algorithm>\n#include<iostream>\n#include<map>\n#include<vector>\nint main(void) {\n\tstd::ios_base::sync_with_stdio(false);\n\tint n, input;\n\tstd::cin >> n;\n\tstd::map<int, int>w;\n\tstd::vector<int>vector(n+1,0);\n\t\n\tfor (int i = 1; i <= n; ++i) {\n\t\tstd::cin >> input;\n\t\tvector[i] = input;\n\t}\n\tstd::vector<int>vector_min= vector;\n\n\tstd::sort(vector_min.begin(), vector_min.end());\n\tfor (int i = 1; i <= n; ++i) {\n\t\tw[vector[i]] = vector_min[i];\n\t}\n\tstd::map<int, int>w_1(w);\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint temp =0;\n\t\twhile (vector_min[i] != w[vector_min[i]]) {\n\t\t\ttemp += vector_min[i] + w[vector_min[i]] ;\n\t\t\tstd::swap(w[vector_min[i]],w[w[vector_min[i]]] );\n\t\t}\n\t\tint temp_1 = static_cast<int>(1e5);\n\t\tif (i>1&&vector_min[i] != w_1[vector_min[i]]) {\n\t\t\ttemp_1 =  vector_min[i]+ vector_min[1] ;\n\t\t\tstd::swap(w_1[vector_min[i]], w_1[vector_min[1]]);\n\t\t\twhile (vector_min[1] !=w_1[vector_min[1]]) {\n\t\t\t\ttemp_1 += vector_min[1]+ w_1[vector_min[1]] ;\n\t\t\t\tstd::swap(w_1[vector_min[1]], w_1[w_1[vector_min[1]]]); }\n\t\t}\n\t\tcnt += std::min(temp, temp_1);\n\t}\n\tstd::cout << cnt << std::endl;\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tint n, res = 0;\n\tcin >> n;\n\tvector<int> w(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> w[i];\n\t}\n\tfor (int i = n; i >= 1; i--) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (w[j] == i){\n\t\t\t\tif (j != i - 1) {\n\t\t\t\t\tres += w[i - 1] + w[j];\n\t\t\t\t\tswap(w[i - 1], w[j]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF=1e9;\n\nint main()\n{\n    int n;\n    int a[1010];\n    int b[1010];\n    bool visit[1010];\n\n    while(cin>>n)\n    {\n        int mi=INF;\n        for(int i=0;i<n;i++)\n        {\n            cin>>a[i];\n            b[i]=a[i];\n            mi=min(mi,a[i]);\n        }\n\n        int ans=0;\n\n        sort(b,b+n);\n\n        map<int,int> mp;\n        for(int i=0;i<n;i++)\n        {\n            mp[b[i]]=i;\n        }\n\n        memset(visit,0,sizeof(visit));\n\n        for(int i=0;i<n;i++)\n        {\n            if(visit[i])\n                continue;\n\n            int cur=i;\n            int sum=0,s=INF;\n            int cnt=0;\n            while(true)\n            {\n                visit[cur]=true;\n                s=min(s,a[cur]);\n                sum+=a[cur];\n                cnt++;\n\n                cur=mp[a[cur]];\n\n                if(visit[cur])\n                    break;\n            }\n            ans+=min(sum+(cnt-2)*s,sum+s+(cnt+1)*mi);\n        }\n        cout<<ans<<endl;\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define MIN(a,b) ((a)<(b)?(a):(b))\n\nvoid merge(vector<pair<int,int> >& w, int left, int mid, int right) {\n\tvector<pair<int,int> > L,R;\n\tint n1=mid-left;\n\tint n2=right-mid;\n\tint i=0,j=0,k;\n\tL.resize(n1+1);\n\tR.resize(n2+1);\n\tfor(i=0; i<n1; ++i) {\n\t\tL[i]=w[left+i];\n\t}\n\tL[n1].first = -1;\n\tL[n1].second = 1000000001;\n\tfor(i=0; i<n2; ++i) {\n\t\tR[i]=w[mid+i];\n\t}\n\tR[n2].first = -1;\n\tR[n2].second = 1000000001;\n\n\ti=j=0;\n\tfor(k=left; k<right; ++k) {\n\t\tif(L[i].second < R[j].second) {\n\t\t\tw[k]=L[i];\n\t\t\t++i;\n\t\t} else {\n\t\t\tw[k]=R[j];\n\t\t\t++j;\n\t\t}\n\t}\n\treturn;\n}\n\nvoid mergeSort(vector<pair<int,int> >& w, int left, int right) {\n\tif(left+1<right) {\n\t\tint mid=left+(right-left)/2;\n\t\tmergeSort(w,left,mid);\n\t\tmergeSort(w,mid,right);\n\t\tmerge(w,left,mid,right);\n\t}\n\treturn;\n}\n\nint main() {\n\tint n;\n\tint i,j;\n\tint total=0;\n\tint subtotal,c;\n\tvector<int> checker;\n\tvector<pair<int,int> > w; // first=original_index, second =weight_value will be sorted.\n\tscanf(\"%d\",&n);\n\tw.resize(n);\n\tchecker.resize(n);\n\tfor(i=0; i<n; ++i) {\n\t\tchecker[i]=0;\n\t\tw[i].first=i;\n\t\tscanf(\"%d\",&w[i].second);\n\t}\n\tmergeSort(w,0,n);\n\tfor(i=0; i<n; ++i) {\n\t\tif(checker[i]==1 || w[i].first==i) {\n\t\t\tcontinue; // already checked or unmoved\n\t\t}\n\t\tc=subtotal=0;\n\t\tchecker[i]=1;\n\t\tj=w[i].first;\n\t\twhile(j!=i) {\n\t\t\tsubtotal+=w[i].second+w[j].second;\n\t\t\tchecker[j]=1;\n\t\t\tj=w[j].first;\n\t\t\t++c;\n\t\t}\n\t\ttotal+=MIN(subtotal,subtotal-w[j].second*(c-2)+w[0].second*(c+2));\n\t}\n\tprintf(\"%d\\n\",total);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#pragma GCC optimize (\"O0\")\n#else\n#pragma GCC optimize (\"O3\")\n#endif\n\n\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\nusing ll = long long;\nconst int INF = 1e9 + 7;\nconst int MOD = INF;\nconst ll INF_LL = 1e18 + 7;\n\n#define __overload3(_1, _2, _3, name,...) name\n#define rep(...) __overload3(__VA_ARGS__, repFromUntil, repUntil, repeat)(__VA_ARGS__)\n#define repeat(times) repFromUntil(__name, 0, times)\n#define repUntil(name, times) repFromUntil(name, 0, times)\n#define repFromUntil(name, from, until) for (int name = from, name##__until = (until); name < name##__until; name++)\n#define repFromTo(name, from, to) repFromUntil(name, from, to + 1)\n#define repr(...) __overload3(__VA_ARGS__, reprFromUntil, reprUntil, repeat)(__VA_ARGS__)\n#define reprUntil(name, times) reprFromUntil(name, 0, times)\n#define reprFromUntil(name, from, until) for (int name = until - 1, name##__from = (from); name >= name##__from; name--)\n#define reprFromTo(name, from, to) reprFromUntil(name, from, to + 1)\n\n#define debugos OUT\n#ifdef LOCAL\n#define debug(v) {printf(\"L%d %s > \",__LINE__,#v);debugos<<(v)<<newl;}\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:(v)){debugos<<e<<\" \";}debugos<<newl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){debugos<<(m)[x]<<\" \";}debugos<<newl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){debugos<<(m)[y][x]<<\" \";}debugos<<newl;}}\n#else\n#define debug(v) {\n#define debugv(v) {}\n#define debuga(m,w) {}\n#define debugaa(m,h,w) {}\n#endif\n\n#define newl \"\\n\"\n\n#define all(iter) begin(iter), end(iter)\n\n\ntemplate <class T> bool chmin(T& var, T x) {\n  if (var > x) {\n    var = x;\n    return true;\n  } else return false;\n}\ntemplate <class T> bool chmax(T& var, T x) {\n  if (var < x) {\n    var = x;\n    return true;\n  } else return false;\n}\n\nclass MyScanner {\n  public:\n    template<typename T> void input_integer(T& var) {\n        var = 0; T sign = 1;\n        int cc = getchar();\n        for (; cc<'0' || '9'<cc; cc = getchar())\n            if (cc == '-') sign = -1;\n        for (; '0' <= cc && cc <= '9'; cc = getchar())\n            var = (var << 3) + (var << 1) + cc - '0';\n        var = var * sign;\n    }\n    int c() { char c; while (c = getchar(), c == ' ' or c == '\\n'); return c; }\n    MyScanner& operator>>(char& var) { var = c(); return *this; }\n    MyScanner& operator>>(int& var) { input_integer<int>(var); return *this; }\n    MyScanner& operator>>(ll& var) { input_integer<ll>(var); return *this; }\n    MyScanner& operator>>(string& var) {\n        int cc = getchar();\n        for (; !isvisiblechar(cc); cc = getchar());\n        for (; isvisiblechar(cc); cc = getchar())\n            var.push_back(cc);\n        return *this;\n    }\n    operator int() {\n      int n;\n      *this >> n;\n      return n;\n    }\n    operator ll() {\n      ll n;\n      *this >> n;\n      return n;\n    }\n    private:\n      int isvisiblechar(int c) {\n        return 0x21 <= c && c <= 0x7E;\n      }\n};\nclass MyPrinter {\n  public:\n    template<typename T>\n    void output_integer(T var) {\n        if (var == 0) { putchar('0'); return; }\n        if (var < 0)\n            putchar('-'),\n            var = -var;\n        char stack[32]; int stack_p = 0;\n        while (var)\n            stack[stack_p++] = '0' + (var % 10),\n            var /= 10;\n        while (stack_p)\n            putchar(stack[--stack_p]);\n    }\n    MyPrinter& operator<<(char c) { putchar(c); return *this; }\n    template <typename T>\n    MyPrinter& operator<<(T var) { output_integer<T>(var); return *this; }\n    MyPrinter& operator<<(char* str_p) { while (*str_p) putchar(*(str_p++)); return *this; }\n    MyPrinter& operator<<(const char* str_p) { while (*str_p) putchar(*(str_p++)); return *this; }\n    MyPrinter& operator<<(const string& str) {\n        const char* p = str.c_str();\n        const char* l = p + str.size();\n        while (p < l) putchar(*p++);\n        return *this;\n    }\n    // MyPrinter& operator<<(const modint& var) { output_integer<ll>(var.value); return *this; }\n    template <typename T>\n    void operator()(T x) {\n        *this << x << newl;\n    }\n    template <typename T>\n    void iter(T x, size_t l) {\n      rep(i, l) *this << x[i] << \" \\n\"[i == l-1];\n    }\n};\nMyScanner IN;\nMyPrinter OUT;\n\nint main() {\n  int n = IN;\n  vector<int> w(n);\n  rep(i, n) IN >> w[i];\n\n  int min_w = *min_element(all(w));\n\n  map<int, int> goal;\n  rep(i, n) goal[w[i]] = 0;\n  int k = 0; for(auto &p : goal) p.second = k++;\n\n  vector<bool> done(n, false);\n  int res = 0;\n  rep(i, n) {\n    if (done[i]) continue;\n\n    int cnt = 0, sum = 0, m = INF, now = i;\n    while (true) {\n      if (done[now]) break;\n\n      done[now] = true;\n      cnt++;\n      sum += w[now];\n      chmin(m, w[now]);\n      now = goal[w[now]];\n    }\n    res += min(sum + m * (cnt - 2), (min_w + m) + (sum - m) + (min_w * (cnt - 1)) + (min_w + m));\n  }\n  OUT(res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\n#include <cstring>\n#define MAX 1000\n#define W 10000\nusing namespace std;\n\nint n,a[MAX],b[MAX],V[MAX],T[W+1],ans=0,mi=W;\n\nvoid solve(){\n    int i;\n    for(i=0;i<n;i++){\n        b[i]=a[i];\n    }\n    sort(b,b+n);\n    for(i=0;i<n;i++){T[b[i]]=i;}\n    for(i=0;i<n;i++){\n        if(V[i])continue;\n        int S=0;\n        int an=0;\n        int cur=i;\n        int m=MAX;\n        while(1){\n            V[cur]=1;\n            an++;\n            m=min(m,a[cur]);\n            S+=a[cur];\n            cur=T[a[cur]];\n            if(V[cur])break;\n        }\n        ans+=min(S+(an-2)*m,S+m+(an+1)*mi);\n    }\n}\n\nint main()\n{\n    memset(V,0,sizeof(V));\n    cin>>n;\n    int i;\n    for(i=0;i<n;i++){cin>>a[i];mi=min(mi,a[i]);}\n    solve();\n    cout<<ans<<endl;\n    return 0;\n}\n//int main(){\n//    int a=4;\n//    if(a){\n//        cout<<\"ok\";\n//    }\n//}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <algorithm>\nusing namespace std;\n\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint A[MAX], B[MAX], T[VMAX+1];\nint s, n;\n\nint solve() {\n    int ans = 0;\n    bool V[MAX];\n    for (int i = 0; i < n; i++){\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B, B + n);\n    for (int i = 0; i < n; i++)\n        T[B[i]] = i;\n    for (int i = 0; i < n; i++) {\n        if (V[i])\n            continue;\n        int an = 0;\n        int S = 0;\n        int cur = i;\n        int m = VMAX;\n        int v;\n        while (true) {\n            V[cur] = true;\n            an++;\n            v = A[cur];\n            m = min(v, m);\n            S += v;\n            cur = T[A[cur]];\n            if (V[cur]) break;\n        }\n        ans += min(S + (an - 2) * v, S + v + (an + 1) * s);\n    }\n    return ans;\n}\n\nint main() {\n    cin >> n;\n\n    s = VMAX;\n\n    for (int i = 0; i < n; i++) {\n        cin >> A[i];\n        s = min(A[i], s);\n    }\n    int ans = solve();\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nconst int N = 1e5;\nint a[N],b[N],check[N];\nmap<int,int> mp;\n\nsigned main(){\n\n  int n; cin >> n;\n  for(int i = 0; i < n; i++){\n    cin >> a[i];\n    b[i] = a[i];\n    mp[a[i]] = i;\n  }\n\n  sort(b,b+n);\n  int ans = 0;\n  for(int i = 0; i < n; i++){\n    int cost = 0,u = i,m = 1e9;\n    int j = 0;\n    for(; !check[u]; j++){\n      m = min(m,a[u]);\n      cost += a[u];\n      check[u] = 1;\n      u = mp[b[u]];\n    }\n    if(j >= 2){\n      ans += min(cost+m+(j+1)*b[0],cost+(j-2)*m);\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define maxn 1005\n#define maxv 10005\nint n,a[maxn],s;\nint b[maxn],c[maxn];\nint main()\n{\n    int ans=0,pos=0,mi=maxv,sum=0;\n    cin>>n;\n    s=maxv;\n    for(int i=0;i<n;++i)\n    {\n        cin>>a[i];\n        b[i]=a[i];\n        s=min(a[i],s);\n    }\n    sort(b,b+n);\n    for(int i=0;i<n;++i)\n    {\n        if(a[i]!=b[i])\n        {\n            c[pos++]=a[i];\n            mi=min(mi,a[i]);\n        }\n    }\n    for(int i=0;i<pos;++i)\n    {\n        sum+=c[i];\n    }\n    ans=min(sum+(pos-2)*mi,sum+mi+(pos+1)*s);\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n, mini = 10000, w[1000], A[1000], T[10001];\nbool used[1000];\n\nint solve() {\n\tint res = 0;\n\tfor (int i = 0; i < n; ++i) A[i] = w[i];\n\tsort(A, A + n);\n\tfor (int i = 0; i < n; ++i) T[A[i]] = i;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (used[i]) continue;\n\t\tint now = i, S = 0, m = 10000, an = 0;\n\t\twhile (true) {\n\t\t\tused[now] = true;\n\t\t\tan++;\n\t\t\tint v = w[now];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tnow = T[v];\n\t\t\tif (used[now]) break;\n\t\t}\n\t\tres += min(S + (an - 2) * m, m + S + (an + 1) * mini);\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> w[i];\n\t\tmini = min(mini, w[i]);\n\t}\n\tcout << solve() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\n\nvoid printarray(int n, int a[]){\n  for (int i=0; i<n; i++){\n    cout << a[i] << \" \";\n  }\n  cout << endl;\n}\n\nvoid swap(int a[], int i, int j){\n  int tmp;\n  tmp = a[i];\n  a[i] = a[j];\n  a[j] = tmp;\n}\n\nint partition(int a[], int p, int r){\n  int x;\n  x = a[r];\n  int i;\n  i = p-1;\n  for (int j=p; j<r; j++){\n    if (a[j] <= x){\n      i++;\n      swap(a,i,j);\n    }\n  }\n  swap(a,i+1,r);\n  return i+1;\n}\n\nvoid quicksort(int a[], int p, int r){\n  if (p<r){\n    int q;\n    q = partition(a,p,r);\n    quicksort(a,p,q-1);\n    quicksort(a,q+1,r);\n  }\n}\n\nint main(){\n  int n;\n  cin >> n;\n\n  int a[n];\n  int b[n];\n  int tmp;\n  for (int i=0; i<n; i++){\n    cin >> tmp;\n    a[i] = tmp;\n    b[i] = tmp;\n  }\n\n  quicksort(a,0,n-1);\n\n  int ans = 0;\n  for (int i=n-1; i>=0; i--){\n    for (int j=0; j<n; j++){\n      if (a[i]==b[j] && i!=j){\n        ans += b[i] + b[j];\n        swap(b,i,j);\n      }\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <tuple>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n#define square(x) (x) * (x)\n#define cube(x) (x) * (x) * (x)\n\nconst int INF = 1e9;\n\nusing namespace std;\n\nbool stable = true;\n\nint main() {\n    int n;\n    int cost = 0;\n    cin >> n;\n    vector<int> a(n);\n    vector<bool> miss(n);\n    REP(i, n) cin >> a[i];\n    auto b = a;\n    sort(ALL(a));\n    REP(i, n){\n        miss[i] = (a[i] != b[i]);\n    }\n    REP(i, n){\n        REP(i, n){\n            if(miss[n-1-i]){\n                int replace = find(ALL(b), a[n-1-i]) - b.begin();\n                if(b[n-1-i] == a[replace]){\n                    swap(b[n-1-i], b[replace]);\n                    cost += b[n-1-i] + b[replace];\n                    miss[n-1-i] = false;\n                    miss[replace] = false;\n                }\n            }\n        }\n        {\n            if(miss[n-1-i]){\n                int replace = find(ALL(b), a[n-1-i]) - b.begin();\n                miss[n-1-i] = false;\n                if(b[n-1-i] == a[replace])\n                    miss[replace] = false;\n                swap(b[n-1-i], b[replace]);\n                cost += b[n-1-i] + b[replace];\n            }\n        }\n    }\n\n    cout << cost << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdint.h>\n#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <climits>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define DEBUG (0)\n\n#if DEBUG\n#define DPRINTF(...) do { \\\n    printf(\"D(L%d) %s: \", __LINE__, __func__); \\\n    printf(__VA_ARGS__); \\\n  } while (false)\n#else\n#define DPRINTF(...)\n#endif // DEBUG\n\nint g_cost = 0;\n\nvoid swap(int array[], int i0, int i1)\n{\n  int temp = array[i1];\n  array[i1] = array[i0];\n  array[i0] = temp;\n}\n\n\nint findIndexOf(int val, const int array[], int numOfArray)\n{\n  for (int i = 0; i < numOfArray; i++)\n    if (array[i] == val)\n      return i;\n\n  // if cannot find the val, call assertion error.\n  assert(0);\n\n  return -1;\n}\n\n\n// The formula is : Sigma(Wi) + min(Wi) * (N-2)\nint calcCostSimple(const int array[], const vector<int> &l)\n{\n  int s = 0;\n  int minimum = INT_MAX;\n  for (uint32_t i = 0; i < l.size(); i++)\n  {\n    int idx = l[i];\n    s += array[idx];\n    minimum = min(minimum, array[idx]);\n  }\n\n  DPRINTF(\"s %d  minimum %d\\n\", s, minimum);\n\n  return s + minimum * (l.size() - 2);\n}\n\n\n// The formula is : Signma(Wi) + min(Wi) + x * (N+1)\nint calcCostSwap(const int array[], const vector<int> &l, int x)\n{\n  if (array == nullptr || l.size() < 1 || x < 0)\n  {\n    assert(1);\n    return INT_MAX;\n  }\n\n  int s = 0;\n  int minimum = INT_MAX;\n  for (uint32_t i = 0; i < l.size(); i++)\n  {\n    int idx = l[i];\n    s += array[idx];\n    minimum = min(minimum, array[idx]);\n  }\n\n  DPRINTF(\"s %d  minimum %d  x %d\\n\", s, minimum, x);\n\n  return s + minimum + x * (l.size() - 1);\n}\n\n\nint findMinOutsideLoop(vector<int> indices, int max, const int sortedArray[])\n{\n  sort(indices.begin(), indices.end());\n\n  for (int i = 0; i < max; i++)\n    if (indices[i] != i)\n      return sortedArray[i];\n\n  // the case l and sortedArray are the same\n  return INT_MAX;\n}\n\n\nint main()\n{\n  int numOfArray;\n  cin >> numOfArray; cin.ignore();\n\n  int array[numOfArray];\n  for (int i = 0; i < numOfArray; i++)\n    cin >> array[i];\n\n#if DEBUG\n  for (int i = 0; i < numOfArray; i++)\n    if (i == 0) DPRINTF(\"%2d\", array[i]);\n    else        printf(\" %2d\", array[i]);\n  cout << endl;\n#endif // DEBUG\n\n  int sortedArray[numOfArray];\n  for (int i = 0; i < numOfArray; i++)\n    sortedArray[i] = array[i];\n\n  sort(sortedArray, sortedArray + numOfArray);\n\n#if DEBUG\n  for (int i = 0; i < numOfArray; i++)\n    if (i == 0) DPRINTF(\"%2d\", sortedArray[i]);\n    else        printf(\" %2d\", sortedArray[i]);\n  cout << endl;\n#endif // DEBUG\n\n  // First, find a loop where each element is sorted\n  //   Suppose array of { 2 1 8 10 7 9 }\n  //   then, sorted array should be { 1 2 7 8 9 10 }\n  //   In this case, we could find two loops;\n  //     Loop 1 : { 2 1 } - { 1 2 }\n  //     Loop 2 : { 8 10 7 9 } - { 7 8 9 10 }\n\n  bool visited[numOfArray];\n  fill(visited, visited + numOfArray, 0);\n\n  vector<vector<int>> loops;\n\n  for (int i = 0; i < numOfArray; i++)\n  {\n    if (visited[i])\n      continue;\n\n    int idx = i;\n    vector<int> loop;\n\n    while (!visited[idx])\n    {\n      loop.push_back(idx);\n      visited[idx] = true;\n\n      int num = array[idx];\n      idx = findIndexOf(num, sortedArray, numOfArray);\n    }\n\n    loops.push_back(loop);\n  }\n\n  // Let's calculate a cost when we will need to sort out\n  // Note that we have to check two cases in a way of sorting, and compare of which is light\n  // Take a look at loop 2 case;\n  //   { 8 10 7 9 } will sorted, and it becomes { 7 8 9 10 }\n  //   The cost should be 48;\n  //   The general formula will be : Sigma(Wi) + min(Wi) * (N-2)\n  //\n  //   Be careful that we could swap with a number of another loop;\n  //   Let's say swap 1 of loop 1 with 7 of loop 2\n  //   and sort { 8 10 1 9 }, and it will be { 1 8 9 10 }\n  //   then swap again, 1 and 7, finally the array will be sorted properly as { 7 8 9 10 }\n  //   In this case, the cost should be 45\n  //   The general formula should be : Signma(Wi) + min(Wi) + x * (N+1)\n\n  for (uint32_t i = 0; i < loops.size(); i++)\n  {\n\n    const vector<int> l = loops[i];\n\n#if DEBUG\n    DPRINTF(\"Loop %d : \",i);\n    for (uint32_t j = 0; j < l.size(); j++) {\n      printf(\" %d\", array[l[j]]);\n    }\n    cout << endl;\n#endif\n\n    if (l.size() < 2)\n      continue; // means the number will be alredy sorted, no need to consider\n\n    int costA, costB;\n    costA = calcCostSimple(array, l);\n    int x = findMinOutsideLoop(l, numOfArray, sortedArray);\n    if (x < 0)\n      costB = INT_MAX;\n    else\n      costB = calcCostSwap(array, l, x);\n\n    g_cost += min(costA, costB);\n\n    DPRINTF(\"Loop %d : Simple %d  Swap %d  g_cost %d\\n\", i, costA, costB, g_cost);\n  }\n\n  cout << g_cost << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\nint solve(){\nint ans = 0;\nbool V[MAX];\nfor(int i = 0; i < n; i++){\nB[i] = A[i];\nV[i] = false;\n}\nsort(B, B+n);\nfor(int i = 0; i < n; i++) T[B[i]] = i;\nfor(int i = 0; i < n; i++){ \nif(V[i]) continue;\nint cur = i;\nint S = 0;\nint m = VMAX;\nint an = 0;\nwhile(1){\nV[cur] = true;\nan++;\nint v = A[cur];\nm = min(m, v);\nS += v;\ncur = T[v]\nif(V[cur]) break;\n}\nans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n}\nreturn ans;\n}\nint main(){\ncin >> n;\ns = VMAX;\nfor(int i = 0; i < n; i++){\ncin >> A[i]\ns = min(s, A[i]\n}\nint ans = solve();\ncout << ans << endl;\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <climits>\nusing namespace  std;\n\nstruct StCst\n{\n  int m_nNo;\n  int m_nInSeq;\n  bool m_bDone;\n\n  static bool AsdNo(const StCst& roLeft, const StCst& roRight) { return roLeft.m_nNo < roRight.m_nNo; }\n};\n\nvoid fnInput(int &rnMaxSiz, vector<StCst> &rvoSort, int &rnMinNo)\n{\n  int nCnt = 0;\n  cin >> rnMaxSiz;\n\n  rvoSort.resize(rnMaxSiz);\n  for (int i = 0; i < rnMaxSiz; i++)\n  {\n    cin >> rvoSort[i].m_nNo;\n    rnMinNo = min(rnMinNo, rvoSort[i].m_nNo);\n    rvoSort[i].m_nInSeq = nCnt++;\n  }\n}\n\nvoid fnMinCostSort(vector<StCst> &rvoSort, int nMinNo, int &rnSwpCnt)\n{\n  sort(begin(rvoSort), end(rvoSort), StCst::AsdNo);\n\n  int nCost;\n  for (int i = 0; i < rvoSort.size(); i++)\n  {\n    if (rvoSort[i].m_bDone)  continue;\n\n    int nTotal = rvoSort[i].m_nNo;\n    int nCurSize = 1;\n    int nCurMin = rvoSort[i].m_nNo; \n    rvoSort[i].m_bDone = true;\n\n    int j = rvoSort[i].m_nInSeq;\n    while  (rvoSort[j].m_nInSeq != rvoSort[i].m_nInSeq)\n    {\n      nTotal += rvoSort[j].m_nNo;\n      nCurSize++;\n      nCurMin = min(nCurMin, rvoSort[j].m_nNo);\n      rvoSort[j].m_bDone = true;\n      j = rvoSort[j].m_nInSeq;\n    }\n\n    if (nCurSize == 1)\n        nCost = 0;\n    else\n      if (nMinNo == nCurMin)\n        nCost = nTotal + (nCurSize - 2) * nCurMin;\n      else\n        nCost = min(nTotal + (nCurSize - 2) * nCurMin, \n                    nTotal + nCurMin + (nCurSize + 1) * nMinNo);\n    rnSwpCnt += nCost;\n  }\n}\n\nvoid fnResult(int nSwpCnt)\n{\n  cout << nSwpCnt << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int nMaxSiz;\n  vector<StCst> voSort;\n  int nMinNo = INT_MAX;\n\n  fnInput(nMaxSiz, voSort, nMinNo);\n\n  int nSwpCnt = 0;\n  fnMinCostSort(voSort, nMinNo, nSwpCnt);\n\n  fnResult(nSwpCnt);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX = 1000;\nconst int VMAX = 100000;\n\nint solve(){\n    int ans = 0;\n    bool V[MAX];\n    for (int i = 0; i < n ; ++i) {\n        B[i] = A[i];\n        v[i] = false;\n    }\n    sort (B,B+n);\n    for (int i = 0; i < n ; ++j) T[B[i]] = i;\n    for (int i = 0; i < n ; ++i) {\n        if(V[i]) continue;\n        int cur = i, S = 0, m = VMAX,an =0;\n        while(1){\n            V[cur] = true;\n            an ++;\n            long v = A[cur];\n            m = min (m,v);\n            s += v;\n            cur = T[v];\n            if(V[cur]) break;\n        }\n        ans += min(S + (an -2) *m ,m + S + (an + 1)*s);\n    }\n    return ans;\n}\n\nint main (){\n    cin >> n;\n    s = VMAX;\n    for (int i = 0; i < n ; ++i) {\n        cin >> A[i];\n        s = min(s,A[i]);\n    }\n    int ans = solve();\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nbool cmp(const int n1, const int n2) {\n\treturn n1 < n2;\n}\n\nstruct Data {\n\tint num;\n\tint i;\n};\n\nint main() {\n\tint n;\n\tint minValue = INT_MAX;\n\tint sortAry[1000];\n\tData ary[1000];\n\tvector<vector<int>> groups;\n\tint cost = 0;\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint temp;\n\t\tcin >> temp;\n\t\tsortAry[i] = ary[i].num = temp;\n\t\tminValue = min(minValue, temp);\n\t}\n\n\tsort(sortAry, sortAry + n, cmp);\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (ary[i].num == sortAry[j]) {\n\t\t\t\tary[i].i = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tvector<int> group;\n\t\tint j = i;\n\t\tint s = i;\n\t\twhile (j != ary[j].i) {\n\t\t\tgroup.push_back(ary[j].num);\n\n\t\t\tint temp = ary[j].i;\n\t\t\tary[j].i = j;\n\t\t\tj = temp;\n\t\t}\n\t\tif (!group.empty()) {\n\t\t\tgroups.push_back(group);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < groups.size(); i++) {\n\t\tint sum = 0;\n\t\tint m = INT_MAX;\n\t\tint num = groups[i].size();\n\n\t\tfor (int j = 0; j < num; j++) {\n\t\t\tsum += groups[i][j];\n\t\t\tm = min(groups[i][j], m);\n\t\t}\n\n\t\tint c1, c2;\n\t\tc1 = sum + (num - 2) * m;\n\t\tc2 = sum + (num + 1) * minValue + m;\n\t\tcost += min(c1, c2);\n\t}\n\n\tcout << cost << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nconst int MAXN = 1010;\nint w[MAXN];\nbool done[MAXN];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, mini = 100000;\n    cin >> n;\n    map<int, int> mp;\n    for (int i = 0; i < n; i++) {\n        cin >> w[i];\n        mp[w[i]] = 0;\n        mini = min(mini, w[i]);\n    }\n    {\n        int k = 0;\n        for (auto& p : mp) p.second = k++;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (done[i]) continue;\n        int cnt = 0, now = i, mi = 100000, sum = 0;\n        while (1) {\n            if (done[now]) break;\n            cnt++;\n            done[now] = true;\n            mi = min(mi, w[now]);\n            sum += w[now];\n            now = mp[w[now]];\n        }\n        int tmp = sum+(cnt-2)*mi;\n        tmp = min(tmp, sum+mi+mini*(cnt+1));\n        ans += tmp;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nint main() {\n\tint n, ans = 0;\n\tcin >> n;\n\tint arr[n], sorted[n];\n\tbool visit[n] = { false };\n\tmap<int, int> mp;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr[i];\n\t\tsorted[i] = arr[i];\n\t}\n\tsort(sorted, sorted + n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (arr[i] == sorted[j]) {\n\t\t\t\tmp[i] = j;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tint suffix = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (visit[i] == false) {\n\t\t\t\tsuffix = i;\n\t\t\t}\n\t\t}\n\t\tif (suffix == -1) {\n\t\t\tbreak;\n\t\t}\n\n\t\tint m = 0, min_in = 10001, min_out = 10001, sum = 0;\n\t\tbool used[n] = { false };\n\t\twhile (used[suffix] == false) {\n\t\t\tm++;\n\t\t\tsum += arr[suffix];\n\t\t\tmin_in = min(min_in, arr[suffix]);\n\n\t\t\tused[suffix] = visit[suffix] = true;\n\t\t\tsuffix = mp[suffix];\n\t\t}\n\n\t\tif (m > 1) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (used[i] == false) {\n\t\t\t\t\tmin_out = min(min_out, arr[suffix]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tans += sum + min((m - 2) * min_in, min_in + (m + 1) * min_out);\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n  \nvoid qsort(int a[],int left,int right){\n      \n    int p=(left+right)/2;\n    int pivot=a[p];\n    int i,temp;\n    if(left<right){\n        p=left;\n        pivot=a[p];\n        for(i=left+1;i<=right;i++){\n            if(a[i]<pivot){\n                p++;\n                temp=a[i];a[i]=a[p];a[p]=temp;//swap\n            }\n        }\n        temp=a[left];a[left]=a[p];a[p]=temp;//swap\n        qsort(a,left,p-1);\n        qsort(a,p+1,right);\n    }\n  \n}\n  \nint search(int key,int a[],int n){\n    int i;\n    for(i=0;i<n;i++){\n        if(key==a[i])return i;\n    }\n      \n    return i;\n}\n  \nint isVisited(int v[],int n){\n    int i;\n    for(i=0;i<n;i++){\n        if(v[i]!=1)return -1;\n    }\n    return 1;\n}\n      \nint min(int a,int b){\n    if(a<b)return a;\n    return b;\n}\n  \n  \nint main(void){\n    int n,i,j,minW,cost=0,w;\n    int a[1000],b[1000],v[1000];\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&a[i]);\n        b[i]=a[i];\n        v[i]=0;\n    }\n    qsort(b,0,n-1);\n      \n    for(i=0;i<n;i++){    \n        int x=i;\n        int sum=0;\n        int count=0;\n        minW=10000;\n        while(v[x]==0){\n            v[x]=1;\n            sum+=a[x];\n            count++;\n            if(minW>a[x])minW=a[x];\n            x=search(a[x],b,n);\n        }\n        if(count<2)continue;\n          \n        cost+=min(b[0]*(count+1)+sum+minW,sum+(count-2)*minW);\n        if(isVisited(v,n)==1)break;\n    }\n    printf(\"%d\\n\",cost);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdlib.h>\n#include <iostream>\n#include <climits>\nusing namespace std;\n\nstruct weight{\n\tint val;\n\tint id;\n\tweight(){\n\t\tval = 0;\n\t\tid  = 0;\n\t}\n\tweight(weight *w){\n\t\tval = w->val;\n\t\tid  = w->id;\n\t}\n\tvoid set(weight *w){\n\t\tval = w->val;\n\t\tid  = w->id;\n\t}\n};\n\nvoid merge_sort(weight *array, int left, int right);\nvoid merge(weight *array, int left, int mid, int right);\nvoid swap_id(weight *a, weight *b);\nint cal_min_swap(weight *original, weight *sorted, int num);\nint main(){\n\tint n;\n\n\tcin >> n;\n\n\tweight* original = (weight*)malloc(n * sizeof(weight));\n\tweight* sorted   = (weight*)malloc(n * sizeof(weight));\n\tint result = 0;\n\n\tif(n < 1){\n\t\treturn 0;\n\t}\n\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> original[i].val;\n\t\toriginal[i].id = i;\n\t\tsorted[i].set(&original[i]);\n\t}\n\n\tmerge_sort(sorted, 0, n);\n\tcout << cal_min_swap(sorted, sorted, n) << endl;\n\treturn 0;\n}\n\nvoid merge_sort(weight *array, int left, int right){\n\tif(left+1 < right){\n\t\tint mid = (left + right) >> 1;\n\t\tmerge_sort(array, mid, right);\n\t\tmerge_sort(array, left, mid);\n\t\tmerge(array, left, mid, right);\n\t}\n\n}\n\nvoid merge(weight *array, int left, int mid, int right){\n\tint n1 = mid - left;\n\tint n2 = right - mid;\n\n\tweight* L = (weight*)malloc((n1+1) * sizeof(weight));\n\tweight* R = (weight*)malloc((n2+1) * sizeof(weight));\n\n\tfor(int i = 0; i < n1; ++i){\n\t\tL[i].set(&array[left+i]);\n\t}\n\tL[n1].val = INT_MAX;\n\tfor(int i = 0; i < n2; ++i){\n\t\tR[i].set(&array[mid+i]);\n\t}\n\tR[n2].val = INT_MAX;\n\n\tint i = 0;\n\tint j = 0;\n\tfor(int k = left; k < right; ++k){\n\t\tif(L[i].val <= R[j].val){\n\t\t\tarray[k].set(&L[i]);\n\t\t\t++i;\n\t\t}else{\n\t\t\tarray[k].set(&R[j]);\n\t\t\t++j;\n\t\t}\n\t}\n}\nvoid swap_id(weight *a, weight *b){\n\tint temp = b->id;\n\tb->id = a->id;\n\ta->id = temp;\n}\nint cal_min_swap(weight *original, weight *sorted, int num){\n\tint total_swap_w = 0;\n\tfor(int i = 0; i < num; ++i){\n\t\tif(i != sorted[i].id){\n\t\t\ttotal_swap_w += sorted[i].val + original[sorted[i].id].val;\n\t\t\tswap_id(&sorted[i], &sorted[sorted[i].id]);\n\t\t\t--i;\n\t\t}\n\n\t}\n\treturn total_swap_w;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 999999999\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 1000;\n\nint w[MAX_N];\nint a[MAX_N];\nint pos[10001];\t\t//?????????????????????????????????????????¢???????????????????????????\nbool flag[MAX_N];\t//???????????????i???????????°???????????????????????????????????????\nvector<int> loop;\n\nint main()\n{\n\tint n,ans=0;\n\tcin >> n;\n\trep(i,n){\n\t\tscanf(\"%d\",&w[i]);\n\t\ta[i] = w[i];\n\t\tpos[w[i]] = i;\n\t}\n\tfill(flag,flag+n,false);\n\tsort(a,a+n);\n\trep(i,n){\n\t\tloop.clear();\n\t\tint x = i;\n\t\twhile(1){\n\t\t\tif(flag[x] == false){\n\t\t\t\tloop.push_back(w[x]);\n\t\t\t\tflag[x] = true;\n\t\t\t\tx = pos[a[x]];\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\t\n\t\t}\n\t\tint suml = 0;\n\t\tint minl = INF;\n\t\tif(loop.size() >= 2){\n\t\t\trep(j,loop.size()){\n\t\t\t\tsuml += loop[j];\n\t\t\t\tminl = min(minl,loop[j]);\n\t\t\t}\n\t\t\tans += min(suml+minl*(loop.size()-2),suml+minl+a[0]*(loop.size()+1));\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstatic const long MAX = 1000;\nstatic const long VMAX = 10000;\n\nlong n, A[MAX], s;\nlong B[MAX], T[VMAX + 1];\n\nlong solve(){\n\tlong ans = 0;\n\tbool V[MAX];\n\tfor (long i = 0; i < n; i++){\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B, B + n);\n\tfor (long i = 0; i < n; i++) T[B[i]] = i;\n\tfor (long i = 0; i < n; i++){\n\t\tif (V[i]) continue;\n\t\tlong cur = i, S = 0, m = VMAX, an = 0;\n\t\twhile (1){\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tlong v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif (V[cur]) break;\n\t\t}\n\t\tans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tcin >> n;\n\ts = VMAX;\n\tfor (long i = 0; i < n; i++){\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tlong ans = solve();\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n \nstruct QuickFind{\n  vector<int> r,p;\n  vector<vector<int> > v;\n  QuickFind(){}\n  QuickFind(int size){init(size);}\n  void init(int size){\n    r.resize(size,0);\n    p.resize(size,0);\n    v.resize(size);\n    for(int i=0;i<size;i++){\n      r[i]=1,p[i]=i;\n      v[i].resize(1,i);\n    }\n  }\n  bool same(int x,int y){\n    return p[x]==p[y];\n  }\n  void unite(int x,int y){\n    x=p[x];y=p[y];\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    for(int i=0;i<(int)v[y].size();i++){\n      p[v[y][i]]=x;\n      v[x].push_back(v[y][i]);\n    }\n    v[y].clear();\n  }\n};\nsigned main(){\n  int n;\n  cin>>n;\n  vector<int> a(n);\n  for(int i=0;i<n;i++) cin>>a[i];\n  vector<int> b(a);\n  sort(b.begin(),b.end());\n  map<int,int> p,q;\n  for(int i=0;i<n;i++){\n    p[a[i]]=i;\n    q[b[i]]=i;\n  }\n  QuickFind qf(n);\n  for(int i=0;i<n;i++) \n    qf.unite(i,p[b[i]]);\n  //for(int i=0;i<n;i++) cout<<i<<\" \"<<p[b[i]]<<endl;\n  int ans=0;\n  for(int i=0;i<n;i++){\n    int k=qf.v[i].size();\n    if(qf.p[i]!=i||k==1) continue;\n    int m=a[qf.v[i][0]];\n    int tmp=0;\n    for(int j=0;j<k;j++){\n      //cout<<\" \"<<a[qf.v[i][j]];\n      tmp+=a[qf.v[i][j]];\n      m=min(m,a[qf.v[i][j]]);\n    }\n    //cout<<endl;\n    ans+=min(tmp+m*(k-2),tmp+m+b[0]*(k+1));\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint silly_sort(vector<int> v, int n){\n\tvector<pair<int, int> > temp(n);\n\tfor (int i = 0; i < n; i++){\n\t\ttemp[i].first = v[i];\n\t\ttemp[i].second = i;\n\t}\n\tsort(temp.begin(), temp.end());\n\n\tint cost = 0, s = temp[0].first;\n\tfor (int i = 0; i < n; i++){\n\t\tint j = temp[i].second;\n\t\tif (j != i && j >= 0){\n\t\t\tint n = 1, amin, sum;\n\t\t\tamin = sum = temp[i].first;\n\t\t\twhile (j != i){\n\t\t\t\tint next = temp[j].second;\n\t\t\t\tsum += temp[j].first;\n\t\t\t\tn++;\n\t\t\t\ttemp[j].second = -1;\n\t\t\t\tj = next;\n\t\t\t}\n\t\t\tcost += min(sum + (n - 2) * amin, sum + amin + (n + 1) * s);\n\t\t}\n\t}\n\treturn cost;\n}\n\nvoid main(){\n\tint n;\n\tcin >> n;\n\tvector<int> v(n);\n\tfor (int i = 0; i < n; i++) cin >> v[i];\n\tcout << silly_sort(v, n) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\n\n\n\n\n\n\n\n\nint main(){\n    ll n;\n    cin>>n;\n    vector<ll> a(n),b(n);\n    ll mi=E;\n    for(int i=0;i<n;i++){\n        cin>>a[i];\n        b[i]=a[i];\n        mi=min(mi,a[i]);\n    }\n    sort(b.begin(),b.end());\n    map<ll,ll> M;\n    for(int i=0;i<n;i++){\n        M[b[i]]=i;\n    }\n    vector<bool> used(n,false);\n    ll cost=0;\n    for(int i=0;i<n;i++){\n        if(used[i] || a[i]==b[i]){continue;}\n        ll sum=0;\n        ll MIN=E;\n        ll w=i;\n        ll L=0;\n        while(!used[w]){\n            MIN=min(MIN,a[w]);\n            sum+=a[w];\n            used[w]=true;\n            w=M[a[w]];\n            L++;\n        }\n        ll D=sum;\n        sum-=MIN;\n        sum+=(L-1)*MIN;\n        D-=MIN;\n        D+=MIN*2+mi*2;\n        D+=(L-1)*mi;\n        cost+=min(sum,D);\n    }\n    cout<<cost<<endl;\n    \n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//The Number of Inversions\n#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Weight {\n    int id = 0;\n    int weight = 0;\n    bool searched = false;\n    bool operator < (const Weight &w) const {\n        return weight < w.weight;\n    }\n};\n\nint main() {\n    int n, s = INT_MAX;\n    cin >> n;\n    Weight W[n];\n    for(int i=0; i<n; i++) {\n        cin >> W[i].weight;\n        W[i].id = i;\n        s = min(s, W[i].weight);\n    }\n\n    sort(W, W+n);\n\n    int cost = 0;\n    for(int i=0; i<n; i++) {\n        if(W[i].searched) continue;\n        int id = i, c = 0, size = 0;\n        while(1) {\n            W[id].searched = true;\n            c += W[id].weight;\n            id = W[id].id;\n            size++;\n            if(id == i) break;\n        }\n        if(size != 1)\n            cost += c + min((size-2)*W[i].weight, W[i].weight+(size+1)*s);\n    }\n    cout << cost << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(), (x).end()\n\nusing namespace std;\n\ntemplate <typename T> T &chmin(T &a, const T &b) {return a = min(a, b);}\ntemplate <typename T> T &chmax(T &a, const T &b) {return a = max(a, b);}\n\nusing ll = long long;\nusing ld = long double;\n\nconst int INF = 1e9;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nstruct UnionFind{\n  vector<int> parent;\n  UnionFind(int N) : parent(N, -1) {};\n  int root(int n) { return parent[n] < 0 ? n : parent[n] = root(parent[n]); }\n  bool merge(int x, int y){\n    x=root(x); y=root(y);\n    if(x==y) return false;\n    if(parent[x]>parent[y]) swap(x, y);\n    if(parent[x]==parent[y]) parent[x]--;\n    parent[y] = x;\n    return true;\n  }\n  bool judge(int a, int b){\n    return root(a) == root(b);\n  }\n};\n\nint binarySearch(int* target, int num, int l, int r){\n  if(l==r) return l;\n  int pivot=(l+r)/2;\n  if (*(target+pivot)==num) return pivot;\n  return *(target+pivot) > num ? binarySearch(target, num, l, pivot) : binarySearch(target, num, pivot+1, r);\n}\n\nint main(){\n  int n;\n  cin >> n;\n  int a[n], org[n];\n  int res = 0;\n  UnionFind grp = UnionFind(n);\n  REP(i, n) { cin >> a[i]; org[i] = a[i]; }\n  sort(a, a+n);\n  REP(i, n){\n    int place = binarySearch(a, org[i], 0, n-1);\n    grp.merge(i, place);\n  }\n  REP(i, n){\n    if(grp.parent[i]==-1) continue;\n    if(grp.parent[i]<0) {\n      vector<int> target;\n      REP(j, n) if(grp.judge(i,j)) target.push_back(a[j]);\n      sort(target.begin(), target.end());\n      if((target[0]-a[0]) * (target.size()-1) > 2 * (target[0]+a[0])){\n        res += accumulate(target.begin(), target.end(), a[0] * (target.size()+1) + target[0]);\n      } else {\n        res += accumulate(target.begin(), target.end(), target[0] * (target.size()-2));\n      }\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#define N 1003\n#define MAX 20000\n\nusing namespace std;\ntypedef long long llong;\nstruct card{\n    int loc;\n    int d;\n};\nint n;\nint mmin;\nbool B[N];\n\nvoid QuickSort(card A[],int head,int tail){\n    card x=A[tail];\n    int i=head-1,j=head;\n    card temp;\n    if(head>=tail) return;  //!(tail-head>1) 改了  就是这里的问题！！！\n    for(j=head;j<tail;j++){\n        if(A[j].d<=x.d){\n            i++;\n            temp=A[j]; A[j]=A[i]; A[i]=temp;\n        }\n    }\n    A[tail]=A[i+1]; A[i+1]=x;\n    QuickSort(A,head,i);\n    QuickSort(A,i+2,tail);\n}\n\nllong deal(card A[],int n){\n    llong ans=0;\n    llong tempans=0;\n    int origin_loc=0;\n    for(int i=0;i<n;i++){\n        if(B[i]) continue;\n        origin_loc=i;\n        vector<int> temp;\n        int loc_min=MAX;\n        int num=0;\n        while(!B[origin_loc]){\n            num+=1;\n            temp.push_back(A[origin_loc].d);\n            tempans+=A[origin_loc].d;\n            loc_min=min(loc_min,A[origin_loc].d);\n            B[origin_loc]=true;\n            origin_loc=A[origin_loc].loc;\n        }\n\n        ans+=min(tempans+(num-2)*loc_min,loc_min+tempans+(num+1)*mmin);\n\n        temp.clear();\n        num=0;\n        loc_min=MAX;\n        tempans=0;\n    }\n    return ans;\n}\n\nint main(){\n    int td;\n    card A[N];\n    mmin=MAX;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>td;\n        mmin=min(mmin,td);\n        A[i].d=td;\n        A[i].loc=i;\n        B[i]=false;\n    }\n\n    QuickSort(A,0,n-1);\n\n    cout<<deal(A,n)<<endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint a[1005],b[1005],to[10005];\nbool vis[1005];\nint main () {\n\tint n,ans=0;\n\tscanf (\"%d\",&n);\n\tfor (int i=0;i<n;i++) {\n\t\tscanf (\"%d\",&a[i]);\n\t\tb[i]=a[i];\n\t}\n\tsort (b,b+n);\n\tfor (int i=0;i<n;i++) {\n\t\tto[b[i]]=i;\n\t}\n\tfor (int i=0;i<n;i++) {\n\t\tif (vis[i]) continue;\n\t\tint pos=i,sum=0,mn=1e4+7,cnt=0;\n\t\twhile (!vis[pos]) {\n\t\t\tvis[pos]=true;\n\t\t\tsum+=a[pos];\n\t\t\tmn=min(mn,a[pos]);\n\t\t\tcnt++;\n\t\t\tpos=to[a[pos]];\n\t\t}\n\t\tans+=min(sum+(cnt-2)*mn,sum+mn+(cnt+1)*b[0]);\n\t}\n\tprintf (\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 12:41\n//\n\n// w[0], w[1], ..., w[n-1]\n// ex. 9 7 6 1\n//  -> 1 6 7 9 \n// このように 1, 9の交換, 6,7の交換のようにペアの交換で済む場合は,\n// ex. 2 3 1\n//  -> 1 2 3 \n// このように, 1, 2, 3の3つ以上の巡回置換の場合は,\n// ...\n// まとめると, 辿っていくと問題がある. \n// \n// 10 7  8  9\n// 7  8  9 10\n// 7+10\n// 7+8\n// 8+9\n// 9+10\n\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <unordered_set>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\nusing ll = long long;\n\nstruct Value {\n\tll v;\n\tll idx;\n};\n\nclass lesserValue{\npublic:\n\tbool operator()(const Value &x, const Value &y) {\n\t\treturn x.v < y.v;\n\t}\n};\n\nvoid print(const vector<Value> &x) {\n\tfor (ll i=0;i<x.size();++i) {\n\t\tif (i!=0) cout << \" \";\n\t\t//cout << x[i].v << \",\" << x[i].idx;\n\t\tcout << x[i].v;\n\t}\n\tcout << endl;\n}\n\nint main() {\n\tll n;\n\tcin >> n;\n\tvector<Value> w(n);\n\tfor (ll i=0;i<n;++i) {\n\t\tscanf(\"%lld\", &w[i].v);\n\t\tw[i].idx = i;\n\t}\n\t//print(w);\n\tvector<Value> orig(w);\n\t//print(orig);\n\t// sort by ascending order\n\tsort(w.begin(), w.end(), lesserValue()); \n\t//print(w);\n\tunordered_set<ll> memo;\n\tll ans = 0;\n\tfor (ll i=0;i<n;++i) {\n\t\t// orig: 4 2 3\n\t\t// 0 1 2\n\t\t// w:    2 3 4\n\t\t// 1 2 0\n\t\t// w[0].v = 2;\n\t\t// i = 0; \n\t\t// j = w[i].idx;\n\t\t// w[0].idx = 1;\n\t\t// w[1].idx = 2;\n\t\t// w[2].idx = 0;\n\t\t//cout << \"[\" << i << \"]: \"; \n\t\tif (memo.end() != memo.find(i)) {\n\t\t\t//cout << \"skipped \" << i << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tmemo.insert(i);\n\t\t//cout << \"inserted \" << i << \" \";\n\t\tll cnt = 0;\n\t\tll j = w[i].idx;\n\t\twhile (i != j) {\n\t\t\tcnt++;\n\t\t\tmemo.insert(j);\n\t\t\tans += w[i].v + w[j].v;\n\t\t \tj\t= w[j].idx;\n\t\t\t//cout << \"inserted \" << j << \" \" << endl;\n\t\t}\n\t\tif (cnt > 1 && w[i].v != w[0].v) {\n\t\t\tans += 2 * (w[i].v + w[0].v);\n\t\t\tans += cnt * (w[0].v - w[i].v);\n\t\t}\n//\t\tans += accumulate(t.begin(), t.end(), 0);\n//\t\tif (t.size() > 0) {\n//\t\t\tans -= *max_element(t.begin(), t.end());\n//\t\t}\n\t\t//cout << \"ans[\" << i << \"] = \" << ans << endl;\n\t}\n\t//print(w);\n\tcout << ans << endl;\n\treturn 0;\n}\n\n//\t3 2 1\n//\t1 2 3 \n//\t1 + 3 = 4\n//\n//  3 2 1 5 4 \t\n//  1 2 3 4 5\n//\n//  4 1 5 3 2\n//  1 2 3 4 5\n//\n//  4 2 5 3 1 : 1 + 2 = 3\n//  4 2 1 3 5 : 1 + 5 = 6 \n//  4 2 3 1 5 : 1 + 3 = 4 \n//  1 2 3 4 5 : 1 + 4 = 5\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <utility>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\ntypedef pair<int,int> pi;\n#define F first\n#define S second\n#define MP make_pair\nconst int N=1e3+10;\nbitset<N> went;\nint bot,tot,a[N],t;\npi b[N];\nvoid dfs(int n){\n    if(went[n])return ;\n    went[n]=true;\n    t++;\n    tot+=b[a[n]].F;\n    bot=min(bot,b[a[n]].F);\n    dfs(a[n]);\n    return ;\n}\nint main(){\n    int n,low=1e5+10;;\n    long long int ans=0;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&b[i].F);\n        low=min(low,b[i].F);\n        b[i].S=i;\n    }\n    sort(b,b+n);\n    for(int i=0;i<n;i++)a[b[i].S]=i;\n    went.reset();\n    for(int i=0;i<n;i++)if(!went[i]&&a[i]!=i){\n        tot=0;\n        bot=1e5+10;\n        t=0;\n        dfs(i);\n        ans+=min(tot+(t+1)*low+bot,tot+(t-2)*bot);\n    }\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF = 1e9;\n\nint main()\n{\n  int n = 0;\n  fscanf(stdin, \"%d\", &n);\n  vector<int> w(n);\n  int smallest = INF;\n  for (int i = 0; i < n; ++i) {\n    fscanf(stdin, \"%d\", &w[i]);\n    smallest = min(smallest, w[i]);\n  }\n  vector<int> seen(n, 0);\n  vector<int> v(w);\n  sort(v.begin(), v.end());\n  vector<int> pos(10005, -1);\n  int ans = 0;\n  for (int i = 0; i < n; ++i) { pos[v[i]] = i; }\n  for (int i = 0; i < n; ++i) {\n    if (seen[i]) { continue; }\n    int next_pos = i;\n    int cur = w[i];\n    int least = w[i], sum = 0, len = 0;\n    while (!seen[next_pos]) {\n      // fprintf(stderr, \"DEBUG: cur=%d\\n\", cur);\n      seen[next_pos] = 1;\n      ++len;\n      sum += cur;\n      least = min(least, cur);\n      next_pos = pos[cur];\n      cur = w[next_pos];\n    }\n    int cost = sum - least + (len - 1) * least;\n    cost = min(cost, sum + least + (len + 1) * smallest);\n    ans += cost;\n  }\n  fprintf(stdout, \"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n \n\nint solve(int *w,int n) {\n\tint g_m = w[0]; //整个数组中的最小值 \n\t \n\tmap<int,int> address; //元素在排序后的数组中的下标映射 \n\tint *tmp = new int[n];\n\tbool *T = new bool[n]; //标记当前位置是否被访问 \n\t\n\tint ans = 0; //最终结果 \n\t\n\tfor (int i=0;i<n;i++) {\n\t\t//找出最小值 \n\t\tif (w[i] < g_m) {\n\t\t\tg_m = w[i];\n\t\t}\n\t\t//初始化 \n\t\tT[i] = false;\n\t\ttmp[i] = w[i];\n\t}\n\t//对临时数组排序 \n\tsort(tmp,tmp+n);\n\t//建立映射 \n\tfor (int i=0;i<n;i++) {\n\t\tpair<int, int> pair_map(tmp[i],i);\n\t\taddress.insert(pair_map);\n\t}\n\tfor (int i = 0;i<n;i++) {\n\t\tif (T[i]) { //当前位置已被访问过了 \n\t\t\tcontinue;\n\t\t}\n\t\tint m = w[i]; //当前圈里的最小值 \n\t\tint cur = i;//当前所处的位置\n\t\tint S = 0; //当前所需的花费\n\t\tint count = 0; //当前圈里的元素个数\n\t\t \n\t\twhile (1) {\n\t\t\tcount++;\n\t\t\tint v = w[cur];\n\t\t\tm = min(v,m);\n\t\t\tS += v;\n\t\t\tT[cur] = true;\n\t\t\tcur = address.at(v); \n\t\t\tif (T[cur]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tans += min(S + (count - 2) * m,S + m + (1+count) * g_m);\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tint *w = new int[n];\n\tfor (int i = 0;i<n;i++) {\n\t\tcin >> w[i];\n\t}\n\tint ans = solve(w,n);\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <string>\n#define MAX 1000\n#define INFTY 1<<30 // 2^30\nusing namespace std;\ntypedef long long llong;\n \nstatic const int VMAX = 10000;\nint n, A[MAX+10], s;\nint B[MAX+10], T[VMAX+10];\n \nint solve()\n{\n  int ans = 0;\n  bool V[MAX+10];\n  for(int i = 0; i < n; i++)\n  {\n    B[i] = A[i];\n    V[i] = false;\n  }\n  sort(B,B+n);\n  for(int i = 0; i < n; i++) T[B[i]] = i; // ????????????????????????????????????????????????\n  for(int i = 0; i < n; i++)\n  {\n    if(V[i]) continue;\n    int cur = i; // current point\n    int S = 0; // sum of mass\n    int m = VMAX; // min of the cycle\n    int an = 0; // the number of material the cycle have\n    while(1)\n    {\n      V[cur] = true; //already visited\n      an++;\n      int v = A[cur];\n      m = min(m, v);\n      S += v;\n      cur = T[v];\n      if(V[cur]) break;\n    }\n    ans += min(S+(an-2)*m, S+(an+1)*s+m);\n  }\n  return ans;\n}\n \nint main()\n{\n  cin >> n;\n  s = VMAX;\n  for(int i = 0; i < n; i++)\n  {\n    cin >> A[i];\n    s = min(s,A[i]);\n  }\n  cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ALDS1_6_D.cpp\n// Sort II - Minimum Cost Sort\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int MAXW = 10005;\nint main()\n{\n    int n;\n    cin >> n;\n    vector<int> w(n);\n    vector<int> w_sorted(MAXW, -1);\n    int w_min = MAXW;\n    for (int i = 0; i < n; i++) {\n        cin >> w[i];\n        w_sorted[w[i]]++;\n        w_min = min(w_min, w[i]);\n    }\n\n    int w_cnt = 0;\n    for (int i = 0; i < w_sorted.size(); i++) {\n        if (w_sorted[i] >= 0) {\n            w_sorted[i] += w_cnt;\n            w_cnt++;\n        }\n    }\n\n    int w_sum = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (w_sorted[w[i]] == -1) continue;\n        int w_cnt1 = 0;\n        int w_min_partial = w[i];\n        for (int j = i; w_sorted[w[j]] != -1; ) {\n            w_min_partial = min(w_min_partial, w[j]);\n            w_cnt1++;\n            w_sum += w[j];\n            int tmp = j;\n            j = w_sorted[w[j]];\n            w_sorted[w[tmp]] = -1;\n        }\n        w_sum += min((w_cnt1 - 2) * w_min_partial, (w_cnt1 + 1) * w_min + w_min_partial);\n    }\n\n    cout << w_sum << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int INF = 1000000;\n\nint partition(int *A,int p,int r)\n{\n\tint j,x,temp;\n\n\tx = A[r];\n\tj = p-1;\n\n\tfor(int i = p; i < r; i++)\n\t{\n\t\tif (A[i] <= x)\n\t\t{\n\t\t\tj++;\n\t\t\ttemp = A[i];\n\t\t\tA[i] = A[j];\n\t\t\tA[j] = temp;\n\t\t}\n\t}\n\n\ttemp = A[j+1];\n\tA[j+1] = A[r];\n\tA[r] = temp;\n\n\treturn j+1;\n}\n\nvoid quicksort(int *A,int p,int r)\n{\n\tint q;\n\n\tif (p < r)\n\t{\n\t\tq = partition(A,p,r);\n\t\tquicksort(A,p,q-1);\n\t\tquicksort(A,q+1,r);\n\t}\n}\n\nint solve_swap(int *a,int *b,int n)\n{\n\tint sum,temp;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (a[i] != b[i])\n\t\t{\n\t\t\tfor(int j = i+1; j < n; j++)\n\t\t\t{\n\t\t\t\tif (b[j] == a[i] && b[i] == a[j])\n\t\t\t\t{\n\t\t\t\t\ttemp = a[i];\n\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\ta[j] = temp;\n\n\t\t\t\t\tsum += a[i] + a[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n\nint solve1(int *a,int *b,int n)\n{\n\tbool check;\n\tint min,num,temp,sum,start;\n\n\tsum = 0;\n\tstart = 0;\n\n\twhile(1)\n\t{\n\t\tmin = INF;\n\t\t\n\t\tcheck = true;\n\n\t\t//printf(\"start = %d\\n\", start);\n\n\t\tfor(int i = start; i < n; i++)\n\t\t{\n\t\t\tif (min > a[i] && a[i] != b[i])\n\t\t\t{\n\t\t\t\tnum = i;\n\t\t\t\tmin = a[num];\n\t\t\t}\n\t\t}\n\n\t\t//printf(\"num = %d\\n\", num);\n\t\t//printf(\"min = %d\\n\", min);\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (a[i] == b[num])\n\t\t\t{\n\t\t\t\t//printf(\"%d and %d are swapped\\n\", a[num],a[i]);\n\t\t\t\tsum += a[num] + a[i];\n\t\t\t\ttemp = a[i];\n\t\t\t\ta[i] = min; // min = a[num]\n\t\t\t\ta[num] = temp;\n\t\t\t\tnum = i;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (a[i] != b[i])\n\t\t\t{\n\t\t\t\tcheck = false;\n\t\t\t\tstart = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t\n\n\t\tif (check)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn sum;\n}\n\nbool check(int *A,int *B,int n)\n{\n\tbool c = true;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (A[i] != B[i])\n\t\t{\n\t\t\tc = false;\n\t\t}\n\t}\n\n\treturn c;\n}\n\nint main()\n{\n\tint n,a[1000] = {0},b[1000] = {0},a2[1000] = {0};\n\tint sum1 = 0;\n\t//int sum2 = 0,pivot = 0,pivot1 = 0,pivot2= 0,min = 0,start=0,temp=0,k=0;\n\n\tscanf(\"%d\", &n);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\tb[i] = a[i];\n\t}\n\n\tquicksort(b,0,n-1);\n\n\tsum1 = solve_swap(a,b,n);\n\n\t//printf(\"sum = %d\\n\", sum1);\n\n\tif (check(a,b,n))\n\t{\n\t\tcout << sum1 <<endl;\n\t\treturn 0;\n\t}\n\n/*\n\tsum2 = sum1;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\ta2[i] = a[i];\n\t}\n\n\t//printf(\"\\nhere is sum1\\n\");\n\n\tsum1 += solve1(a,b,n);\n\n\t//printf(\"sum1 = %d\\n\",sum1);\n\n\n\tif (check(a,b,n))\n\t{\n\t\tprintf(\"%d\\n\", sum1);\n\t\treturn 0;\n\t}\n\n\n\n\tfor(int i = 1; i < n - start; i++)\n\t{\n\t\tk = start;\n\n\t\t\n\t\twhile(1)\n\t\t{\n\t\t\tif (b[pivot1] == a[k])\n\t\t\t{\n\t\t\t\tprintf(\"%d and %d are swapped\\n\", a[pivot1],a[k]);\n\t\t\t\ttemp = a[pivot1];\n\t\t\t\ta[pivot1] = a[k];\n\t\t\t\ta[k] = temp;\n\n\t\t\t\tsum1 += a[pivot1] + a[k];\n\t\t\t\tpivot1 = k;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tprintf(\"%d \", a[i]);\n\t\t}\n\t\tcout << endl;\n\t}\n\n\n\tif (!check(a,b,n))\n\t{\n\t\tprintf(\"\\nhere is sum2\\n\");\n\t\ttemp = a2[pivot2];\n\t\ta2[pivot2] = a2[0];\n\t\ta2[0] = temp;\n\n\t\tfor(int i = 1; i < n - start; i++)\n\t\t{\n\t\t\tint j = start;\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif (b[pivot2] == a2[j])\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d and %d are swapped\\n\", a2[pivot2],a2[j]);\n\t\t\t\t\ttemp = a2[pivot2];\n\t\t\t\t\ta2[pivot2] = a2[j];\n\t\t\t\t\ta2[j] = temp;\n\n\t\t\t\t\tsum2 += a2[pivot2] + a2[j];\n\t\t\t\t\tpivot2 = j;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tprintf(\"%d \", a2[i]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\n\t\tif (sum1 < sum2)\n\t\t{\n\t\t\tprintf(\"sum1 = %d\\n\", sum1);\n\t\t}else\n\t\t{\n\t\t\tprintf(\"sum2 = %d\\n\", sum2);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\n\tprintf(\"%d\\n\", sum1);\n*/\n\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <stdlib.h>\nusing namespace std;\n\n#define MAX_NUM 1000\n\nint W[MAX_NUM];\nint N;\n\nint Compare(const void *a, const void *b)\n{\n    return *(int*)a - *(int*)b;\n}\n\nvoid Swap(int idx1, int idx2) {\n\tint tmp = W[idx1];\n\tW[idx1] = W[idx2];\n\tW[idx2] = tmp;\n}\n\nint SearchIdx(int wi)\n{\t\n\tfor (int i = 0; i < N; i++) {\n\t\tif (W[i] == wi) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void)\n{\n\t//input\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> W[i];\n\t}\n\n\t//minimum cost?\n\tint cost = 0;\n\tint w2[MAX_NUM];\n\tmemcpy(w2, W, sizeof(int) * N);\n\tqsort(w2, N, sizeof(int), Compare);\n\tfor (int i = 0; i < N; i++) {\n\t\tint idx1 = SearchIdx(w2[i]);\n\t\twhile (idx1 != i) {\n\t\t\tint idx2 = SearchIdx(w2[idx1]);\n\t\t\tSwap(idx1, idx2);\n\t\t\tcost = cost + W[idx1] + W[idx2];\n\t\t\tidx1 = idx2;\n\t\t}\n\t}\n\n\t//output\n\tcout << cost << \"\\n\";\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n;\n  cin >> n;\n\n  vector<int> a(n);\n  for(int i=0;i<n;i++)cin >> a[i];\n  int MinV = *min_element(a.begin(),a.end());\n\n  vector<int> order = a, p = a;\n  sort(order.begin(), order.end());\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(a[i] == order[j])p[i] = j;\n    }\n  }\n\n  long long ans = 0;\n  vector<bool> use(n,0);\n  for(int i=0;i<n;i++){\n    if(!use[i]){\n      int cur = i, minv = 1e8, sum = 0, len = 0;\n      do{\n\tuse[cur] = 1;\n\tminv = min(minv, a[cur]);\n\tsum += a[cur];\n\tcur = p[cur];\n\tlen++;\n      }while(cur!=i);\n      ans += min(sum + minv*(len-2), sum + MinV*len + minv + MinV);\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   for(int i=0;i<(n);++i)\n#define SORT(c)    sort((c).begin(),(c).end())\n#define EPS 1e-10;//sample:if((double)>=(double)+EPS)\n#define CLR(a) memset((&a), 0 ,sizeof(a))//clear memory\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;//debug\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n//cin,cout release\n//std::cin.tie(0);\n//ios::sync_with_stdio(false);\n\nusing namespace std;\n\n#define MAX 1000\n#define VMAX 10000\n\nint main(){\n  int n,w[1000],ans=0,s=INT_MAX;\n  cin>>n;\n  rep(i,n){\n    scanf(\"%d\",&w[i]);\n    s=min(s,w[i]);\n  }\n  bool V[VMAX]={};\n  int B[MAX]={},T[VMAX]={};\n  rep(i,n)B[i] = w[i];\n  sort(B,B+n);\n  rep(i,n)T[B[i]]=i;\n  rep(i,n){\n    if(V[i]) continue;\n    int cur=i,S=0,m=VMAX,an=0;\n    do{\n      V[cur]=true;\n      an++;\n      int v=w[cur];\n      m=min(m,v);\n      S+=v;\n      cur = T[v];\n    }while(!V[cur]);\n    ans+=min(S+(an-2)*m,m+S+(an+1)*s);\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nvector<vector<int> > getCycle(vector<int> v) {\n    v.insert(v.begin(), -1e9);\n\n    int n = v.size();\n    vector<int> sorted = v, used(n, 0);\n    vector<pair<int, int> > vp(n);\n    vector<vector<int> > res;\n    map<int, int> mp;\n\n    sort(sorted.begin(), sorted.end());\n    for (int i = 1; i < n; i++)\n        mp[sorted[i]] = i;\n    for (int i = 1; i < n; i++) {\n        vp[i].first = v[i];\n        vp[i].second = mp[v[i]];\n    }\n\n    for (int i = 1; i < n; i++) {\n        if (used[i]) continue;\n        used[i] = 1;\n\n        vector<int> sub(1, vp[i].first);\n        int j = vp[i].second;\n        if (j != i) {\n            while (!used[j]) {\n                used[j] = 1;\n                sub.push_back(vp[j].first);\n                j = vp[j].second;\n            }\n        }\n        res.push_back(sub);\n    }\n\n    return res;\n}\n\nint main(void) {\n    int n, min_of_all = 1e9, min_of_sub;\n    cin >> n;\n    vector<int> w(n);\n    for (int i = 0; i < n; i++) {\n        cin >> w[i];\n        min_of_all = min(min_of_all, w[i]);\n    }\n    \n    int sz, sum;\n    ll ans = 0;\n    vector<vector<int> > v = getCycle(w);\n    for (int i = 0; i < v.size(); i++) {\n        sz = v[i].size();\n        if (sz == 1) continue;\n        min_of_sub = 1e9;\n        sum = 0;\n        for (int j = 0; j < sz; j++) {\n            min_of_sub = min(min_of_sub, v[i][j]);\n            sum += v[i][j];\n        }\n        ans += sum + min((sz - 2) * min_of_sub, (sz + 1) * min_of_all + min_of_sub);\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define Vi vector<int>\n#define FOR(i,s,e) for (int i=s; i<e; i++)\n#define ITER(v) v.begin(), v.end()\n\nconstexpr int MAX_N = 1000;\nconstexpr int MAX_VAL = 10001;\n\nint merge(int* A, const int& left, const int& mid, const int& right) {\n    const int n1 = mid - left;\n    const int n2 = right - mid;\n\n    auto L = new int[n1+1];\n    auto R = new int[n2+1];\n    for (int i = 0; i < n1; i++) {\n        L[i] = A[left + i];\n    }\n    for (int i = 0; i < n2; i++) {\n        R[i] = A[mid + i];\n    }\n\n    L[n1] = MAX_VAL;\n    R[n2] = MAX_VAL;\n\n    int i = 0, j = 0;\n    for (int k = left; k < right; k++) {\n        if (L[i] <= R[j]) {\n            A[k] = L[i];\n            i++;\n        } else {\n            A[k] = R[j];\n            j++;\n        }\n    }\n    delete[] L;\n    delete[] R;\n    return right - left;\n}\n\nint mergeSort(int* A, const int& left, const int& right) {\n    int count = 0;\n    if (left + 1 < right) {\n        const int mid = (left + right) / 2;\n        count += mergeSort(A, left, mid);\n        count += mergeSort(A, mid, right);\n        return count + merge(A, left, mid, right);\n    }\n    return 0;\n}\n\nint minCostSort(int* w, int n) {\n    int j = n;\n    int cost = 0;\n    for (int j = n; j > 0; --j) {\n        int* maxelm = max_element(w, w+j);\n        if (w[j-1] == *maxelm) { continue; }\n        cost += w[j-1] + *maxelm;\n        swap(w[j-1], *maxelm);\n    }\n    return cost;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int w[MAX_N];\n    int n;\n\n    cin >> n;\n    FOR(i,0,n) { cin >> w[i]; }\n    int cost = minCostSort(w, n);\n    cout << cost << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int INF = 1000000;\n\nint partition(int *A,int p,int r)\n{\n\tint j,x,temp;\n\n\tx = A[r];\n\tj = p-1;\n\n\tfor(int i = p; i < r; i++)\n\t{\n\t\tif (A[i] <= x)\n\t\t{\n\t\t\tj++;\n\t\t\ttemp = A[i];\n\t\t\tA[i] = A[j];\n\t\t\tA[j] = temp;\n\t\t}\n\t}\n\n\ttemp = A[j+1];\n\tA[j+1] = A[r];\n\tA[r] = temp;\n\n\treturn j+1;\n}\n\nvoid quicksort(int *A,int p,int r)\n{\n\tint q;\n\n\tif (p < r)\n\t{\n\t\tq = partition(A,p,r);\n\t\tquicksort(A,p,q-1);\n\t\tquicksort(A,q+1,r);\n\t}\n}\n\nint solve_swap(int *a,int *b,int n)\n{\n\tint sum,temp;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (a[i] != b[i])\n\t\t{\n\t\t\tfor(int j = i+1; j < n; j++)\n\t\t\t{\n\t\t\t\tif (b[j] == a[i] && b[i] == a[j])\n\t\t\t\t{\n\t\t\t\t\ttemp = a[i];\n\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\ta[j] = temp;\n\n\t\t\t\t\tsum += a[i] + a[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n\nint solve1(int *a,int *b,int n)\n{\n\tbool check;\n\tint min,num,temp,sum,start;\n\tint cnt=0;\n\n\tsum = 0;\n\tstart = 0;\n\n\twhile(1)\n\t{\n\t\tmin = INF;\n\t\tcnt++;\n\t\tcheck = true;\n\n\t\t//printf(\"start = %d\\n\", start);\n\n\t\tfor(int i = start; i < n; i++)\n\t\t{\n\t\t\tif (min > a[i] && a[i] != b[i])\n\t\t\t{\n\t\t\t\tnum = i;\n\t\t\t\tmin = a[num];\n\t\t\t}\n\t\t}\n\n\t\t//printf(\"num = %d\\n\", num);\n\t\t//printf(\"min = %d\\n\", min);\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (a[i] == b[num])\n\t\t\t{\n\t\t\t\t//printf(\"%d and %d are swapped\\n\", a[num],a[i]);\n\t\t\t\tsum += a[num] + a[i];\n\t\t\t\ttemp = a[i];\n\t\t\t\ta[i] = min; // min = a[num]\n\t\t\t\ta[num] = temp;\n\t\t\t\tnum = i;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (a[i] != b[i])\n\t\t\t{\n\t\t\t\tcheck = false;\n\t\t\t\tstart = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\t//printf(\"a[i] = %d\\n\", a[i]);\n\t\t}\n\n\t\tif (check)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cnt ==10)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn sum;\n}\n\nbool check(int *A,int *B,int n)\n{\n\tbool c = true;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (A[i] != B[i])\n\t\t{\n\t\t\tc = false;\n\t\t}\n\t}\n\n\treturn c;\n}\n\nint main()\n{\n\tint n,a[1000] = {0},b[1000] = {0},a2[1000] = {0};\n\tint sum1 = 0,sum2 = 0,pivot = 0,pivot1 = 0,pivot2= 0,min = 0,start,temp,k;\n\n\tscanf(\"%d\", &n);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\tb[i] = a[i];\n\t}\n\n\tquicksort(b,0,n-1);\n\n\tsum1 = solve_swap(a,b,n);\n\n\t//printf(\"sum = %d\\n\", sum1);\n\n\t\n\tif (check(a,b,n))\n\t{\n\t\tprintf(\"%d\\n\", sum1);\n\t\treturn 0;\n\t}\n\n\n\tsum2 = sum1;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\ta2[i] = a[i];\n\t}\n\n\t//printf(\"\\nhere is sum1\\n\");\n\n\tsum1 += solve1(a,b,n);\n\n\t//printf(\"sum1 = %d\\n\",sum1);\n\n\n\tif (check(a,b,n))\n\t{\n\t\tprintf(\"%d\\n\", sum1);\n\t\treturn 0;\n\t}\n\n\n\n\tfor(int i = 1; i < n - start; i++)\n\t{\n\t\tk = start;\n\n\t\t\n\t\twhile(1)\n\t\t{\n\t\t\tif (b[pivot1] == a[k])\n\t\t\t{\n\t\t\t\tprintf(\"%d and %d are swapped\\n\", a[pivot1],a[k]);\n\t\t\t\ttemp = a[pivot1];\n\t\t\t\ta[pivot1] = a[k];\n\t\t\t\ta[k] = temp;\n\n\t\t\t\tsum1 += a[pivot1] + a[k];\n\t\t\t\tpivot1 = k;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tprintf(\"%d \", a[i]);\n\t\t}\n\t\tcout << endl;\n\t}\n\n\n\tif (!check(a,b,n))\n\t{\n\t\tprintf(\"\\nhere is sum2\\n\");\n\t\ttemp = a2[pivot2];\n\t\ta2[pivot2] = a2[0];\n\t\ta2[0] = temp;\n\n\t\tfor(int i = 1; i < n - start; i++)\n\t\t{\n\t\t\tint j = start;\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif (b[pivot2] == a2[j])\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d and %d are swapped\\n\", a2[pivot2],a2[j]);\n\t\t\t\t\ttemp = a2[pivot2];\n\t\t\t\t\ta2[pivot2] = a2[j];\n\t\t\t\t\ta2[j] = temp;\n\n\t\t\t\t\tsum2 += a2[pivot2] + a2[j];\n\t\t\t\t\tpivot2 = j;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tprintf(\"%d \", a2[i]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\n\t\tif (sum1 < sum2)\n\t\t{\n\t\t\tprintf(\"%d\\n\", sum1);\n\t\t}else\n\t\t{\n\t\t\tprintf(\"sum2 = %d\\n\", sum2);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\n\tprintf(\"%d\\n\", sum1);\n\t\n\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nstruct QuickFind{\n  vector<int> r,p;\n  vector<vector<int> > v;\n  QuickFind(){}\n  QuickFind(int size){init(size);}\n  void init(int size){\n    r.resize(size,0);\n    p.resize(size,0);\n    v.resize(size);\n    for(int i=0;i<size;i++){\n      r[i]=1,p[i]=i;\n      v[i].resize(1,i);\n    }\n  }\n  bool same(int x,int y){\n    return p[x]==p[y];\n  }\n  void unite(int x,int y){\n    x=p[x];y=p[y];\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    for(int i=0;i<(int)v[y].size();i++){\n      p[v[y][i]]=x;\n      v[x].push_back(v[y][i]);\n    }\n    v[y].clear();\n  }\n};\nsigned main(){\n  int n;\n  cin>>n;\n  vector<int> a(n);\n  for(int i=0;i<n;i++) cin>>a[i];\n  vector<int> b(a);\n  sort(b.begin(),b.end());\n  map<int,int> p,q;\n  for(int i=0;i<n;i++){\n    p[a[i]]=i;\n    q[b[i]]=i;\n  }\n  QuickFind qf(n);\n  for(int i=0;i<n;i++) \n    qf.unite(i,p[b[i]]);\n  //for(int i=0;i<n;i++) cout<<i<<\" \"<<p[b[i]]<<endl;\n  int ans=0;\n  for(int i=0;i<n;i++){\n    int k=qf.v[i].size();\n    if(qf.p[i]!=i||k==1) continue;\n    int m=a[qf.v[i][0]];\n    int tmp=0;\n    for(int j=0;j<k;j++){\n      //cout<<\" \"<<a[qf.v[i][j]];\n      tmp+=a[qf.v[i][j]];\n      m=min(m,a[qf.v[i][j]]);\n    }\n    //cout<<endl;\n    ans+=min(tmp+m*(k-2),tmp+m+b[0]*(k+1));\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 1000;\nconst int MAX_W = 10001;\n\nint a[MAX_N];\nint b[MAX_N];\t//?????????????????????\nint c[MAX_W];\t//??´???????????????????????????\n\nint main()\n{\n\tint n,res=0;\n\tcin >> n;\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tb[i] = a[i];\n\t\tc[b[i]] = i;\n\t}\n\tsort(a,a+n);\n\tfor(int i=n-1;i>=0;i--){\n\t\tif(a[i] != b[i]){\n\t\t\tres += a[i] + b[i];\n\t\t\tb[c[a[i]]] = b[i];\n\t\t}\n\t}\n\tcout << res << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nstruct node{\n    int value;\n    int place;\n};\nint sillysort(int m, int *seq){\n    int cost=0;\n    node nodes[1000],temp[1000];\n    //nodes={(value=数列の値,place=ソート後の数列における位置)}\n    for(int i=0;i<m;i++){\n        temp[i].value=seq[i];\n        temp[i].place=i;\n    }\n    std::sort(temp,temp+m,[](const node& a,const node& b){return a.value<b.value;});\n    for(int i=0;i<m;i++){\n        nodes[i].value=seq[i];\n        nodes[temp[i].place].place=i;\n    }\n    //s=数列の最小値\n    int s=temp[0].value;\n\n    for(int i=0;i<m;i++){\n        int j=nodes[i].place;\n        //i番目をまだ走査したことない、かつi番目がソート済みではないなら\n        //iから始まる巡回置換に対してそのコストの最小値を求める\n        if(j>=0 && j!=i){\n            int n=1, amin=nodes[i].value, sum=nodes[i].value;\n            while(j!=i){\n                int next=nodes[j].place;\n                if(nodes[j].value<amin){\n                    amin=nodes[j].value;\n                }\n                sum+=nodes[j].value;\n                n++;\n                nodes[j].place=-1; //以後j番目はnodesの走査で無視する\n                j=next;\n            }\n            //巡回置換(a_1,...,a_n)のコストの最小値は、\n            //(1)a_minの場所に正しい数を置くことを繰り返す（交換回数n-1回）\n            //(2)a_minとsを入れ替える→(1)と同じ操作をする→a_minとsを入れ替える\n            cost+=std::min(\n                sum+(n-2)*amin,     // = sum_{i|a_i!=a_min}(a_i)+(n-1)*a_min ... (1)\n                sum+amin+(n+1)*s);  // = 2*(a_min+s)+(sum-a_min+s)+(n-2)*s   ... (2)\n        }\n    }\n    return cost;\n}\nint main(){\n    int n,w[1000];\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++)scanf(\"%d\",&w[i]);\n    printf(\"%d\\n\",sillysort(n,w));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_6_D&lang=jp>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n \n ================================================================\n */\n\nll solve(){\n    ll res = 0;\n    ll n; cin >> n;\n    vector<ll> w(n); for(auto& in:w) cin >> in;\n    auto tmp_w = w;\n    sort(tmp_w.begin(),tmp_w.end());\n    for(int i = 0; i < n;i++){\n        if(tmp_w[i] == w[i]) continue;\n        res += tmp_w[i] + w[i];\n    }\n    return res/2;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX],s;\nint B[MAX], T[VMAX+1];\n\nint solve() {\n    int ans = 0;\n    \n    bool V[MAX];\n    for(int i=0; i<n; i++) {\n        B[i] = A[i];\n        V[i] = false;\n    }\n    \n    sort(B, B+n);\n    for (int i=0; i<n; i++) T[B[i]] = i;\n    for (int i=0; i<n; i++) {\n        if (V[i] ) continue;\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while (1) {\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m,v);\n            S += v;\n            cur = T[v];\n            if (V[cur]) break;\n        }\n        ans += min(S+(an-2)*m, m+S+(an+1)*s);\n    }\n    return ans;\n}\n\nint main() {\n    cin >> n;\n    s = VMAX;\n    for(int i= 0; i<n; i++) {\n        cin >> A[i];\n        s= min (s,A[i]);\n    }\n    int ans = solve();\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<algorithm>\n#include<iostream>\n#include<map>\n#include<vector>\nint main(void) {\n\tstd::ios_base::sync_with_stdio(false);\n\tint n, input;\n\tstd::cin >> n;\n\tstd::map<int, int>w;\n\t\n\tstd::vector<int>vector_min(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tstd::cin >> input;\n\t\tw[input - 1] = i;\n\t\tvector_min[i] = input-1;\n\t}\n\tstd::map<int, int>w_1(w);\n\tstd::sort(vector_min.begin(), vector_min.end());\n\tint cnt = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint temp = 0;\n\t\twhile (vector_min[i] != w[vector_min[i]]) {\n\t\t\ttemp += vector_min[i] + w[vector_min[i]] + 2;\n\t\t\tstd::swap(w[vector_min[i]],w[w[vector_min[i]]] );\n\t\t}\n\t\tint temp_1 = 0;\n\t\tif (vector_min[i] != w_1[vector_min[i]]) {\n\t\t\ttemp_1 +=  w_1[vector_min[i]] + 2;\n\t\t\tstd::swap(w_1[0], w_1[vector_min[i]]);\n\t\t\twhile (0!=w_1[0]) { \n\t\t\t\ttemp_1 += w_1[0] + 2;\n\t\t\t\tstd::swap(w_1[0], w_1[w_1[0]]); }\n\t\t}\n\t\tcnt += std::min(temp, temp_1);\n\t}\n\tstd::cout << cnt << std::endl;\n//\tsystem(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\nusing std::scanf;\nusing std::printf;\n\nconst int kMaxN = 1000;\nconst int kMaxWi = 10000;\n\nint BinarySearch(int A[], int n, int key) {\n  int left = 0, right = n, mid;\n  while (left < right) {\n    mid = (left + right) / 2;\n    if (A[mid] == key) { return mid; }\n    if (key < A[mid]) { right = mid; }\n    if (A[mid] < key) { left = mid + 1; }\n  }\n  return -1;\n}\n\n// w[i]?????????????????????????????????cycle???????????????????????????remain????????£?????????????¨????\n// ????????????cycle?????????\nint MakeCycle(int w[], int i, int n, int sorted[], int remain[], int cycle[]) {\n  int j = 0;\n  cycle[0] = -1; //?????????while?????????????????????\n  while(w[i] != cycle[0]) {\n    cycle[j] = w[i];\n    ++j;\n    remain[i] = 0;\n    i = BinarySearch(sorted, n, w[i]);\n  }\n  return j;\n}\n\nint CompareCosts(int cycle[], int cycle_n, int cycle_min, int w_min) {\n  if (cycle_n == 1) {\n    return 0;\n  } else if (cycle_n == 2) {\n    return cycle[0] + cycle[1];\n  } else {\n    int cycle_sum, i, cost1, cost2;\n    cycle_sum = 0;\n    for (i = 0; i < cycle_n; ++i) { cycle_sum += cycle[i]; }\n    cost1 = cycle_sum + (cycle_n - 2) * cycle_min;\n    cost2 = cycle_sum + cycle_min + (cycle_n + 1) * w_min;\n    return std::min(cost1, cost2);\n  }\n}\n\nint main() {\n  int n, i, j, cycle_n, cycle_min, w_min, cnt;\n  scanf(\"%d\", &n);\n  int w[n], sorted[n], remain[n], cycle[n];\n  for (i = 0; i < n; ++i) { scanf(\"%d\", &w[i]); }\n  w_min = kMaxWi;\n  for (i = 0; i < n; ++i) { w_min = std::min(w_min, w[i]); }\n  for (i = 0; i < n; ++i) { sorted[i] = w[i]; }\n  std::sort(sorted, sorted + n);\n  for (i = 0; i < n; ++i) { remain[i] = 1; }\n  cnt = 0;\n  for (i = 0; i < n; ++i) {\n    if (remain[i]) {\n      cycle_n = MakeCycle(w, i, n, sorted, remain, cycle);\n      cycle_min = kMaxWi;\n      for (j = 0; j < cycle_n; ++j) { cycle_min = std::min(cycle_min, cycle[j]); }\n      cnt += CompareCosts(cycle, cycle_n, cycle_min, w_min);\n    }\n  }\n  printf(\"%d\\n\", cnt);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define MAX 1100\n#define MAX_W 11000\n \n \nint n, mimi = MAX_W;\nbool used[MAX];\npair<int,int> w[MAX];\n \nint hoge(int x,int sum, int mi,int count){\n    if(used[x]){\n        return min(sum+mi*(count-2), mi + sum + (count+1)*mimi);\n    } else {\n        used[x] = true;\n        return hoge(w[x].second,sum+w[x].first,min(mi,w[x].first),count+1);\n    }\n}\n \nint main(){\n    int W, sum = 0;\n     \n    cin>>n;\n     \n    for(int i = 0; i < n; i++){\n        cin>>W;\n        w[i] = make_pair(W,i);\n        mimi = min(W, mimi);\n    }\n     \n    sort(w, w + n);\n     \n    for(int i = 0; i < n; i++){\n        if(!used[i]) sum +=  hoge(i,0,w[i].first,0);\n    }\n     \n    cout<<sum<<endl;\n     \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <climits>\n#include <cmath>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntemplate <typename T>\nclass Array\n{\nprivate:\n  void merge(int l, int m, int r)\n  {\n    int n1 = m - l;\n    int n2 = r - m;\n    vector<T> L, R;\n    L.resize(n1+1);\n    R.resize(n2+1);\n    for(int i = 0; i < n1; i++) L[i] = A[l + i];\n    for(int i = 0; i < n2; i++) R[i] = A[m + i];\n    L[n1] = INT_MAX;\n    R[n2] = INT_MAX;\n    int a = 0;\n    int b = 0;\n    for(int i = l; i < r; i++)\n    {\n      if(L[a] <= R[b])\n      {\n        A[i] = L[a];\n        a++;\n      }\n      else\n      {\n        A[i] = R[b];\n        b++;\n      }\n    }\n  }\n  int partition(int p, int r)\n  {\n    T x = A[r];\n    int i = p-1;\n    T tmp;\n    for(int j = p; j < r; j++)\n    {\n      if(A[j] <= x)\n      {\n        i++;\n        tmp = A[i];\n        A[i] = A[j];\n        A[j] = tmp;\n      }\n    }\n    tmp = A[i+1];\n    A[i+1] = A[r];\n    A[r] = tmp;\n    return i+1;\n  }\npublic:\n  Array();\n  Array(vector<T> &arr){A = arr;}\n  vector<T> A;\n  T operator [] (int x)\n  {\n    return A[x];\n  }\n  void dispArr()\n  {\n    for(int i = 0; i < A.size()-1 ; i++) cout << A[i] << \" \";\n    cout << A[A.size()-1] << endl;\n  }\n  void swap(int i, int j)\n  {\n    T tmp = A[i];\n    A[i] = A[j];\n    A[j] = tmp;\n  }\n\n  /*\n  l : ?????????index\n  r : ?????????index + 1 or ?????° + ?????????index\n  */\n  void mergeSort(int l, int r)\n  {\n    if(l + 1 < r){\n      int m = (l + r) / 2;\n      mergeSort(l, m);\n      mergeSort(m, r);\n      merge(l, m ,r);\n    }\n  }\n  /*\n  l : ?????????index\n  r : ?????????index\n  */\n  void quicksort(int p, int r)\n  {\n    if(p < r)\n    {\n      int q = partition(p,r);\n      quicksort(p, q-1);\n      quicksort(q+1, r);\n    }\n  }\n};\n\nint main()\n{\n  int n;\n  cin >> n;\n  vector<int> v;\n  v.resize(n);\n  for(int i = 0; i < n; i++)\n    cin >> v[i];\n  Array <int> x(v);\n  Array <int> y(v);\n  y.mergeSort(0,n);\n  //y.dispArr();\n  int cnt = 0;\n  int cost = 0;\n  for(int i = n-1; i >= 0; i--)\n  {\n    if(x[i] != y[i])\n    {\n      for(int j = i; j >= 0; j--)\n      {\n        if(x[i] == y[j])\n        {\n          x.swap(i,j);\n          cost += (x[i] + x[j]);\n          break;\n        }\n      }\n    }\n  }\n  cout << cost << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define N 10001\n\ntypedef struct {\n  int sum;\n  int flag;\n} CC;\n\nCC C[N];\nint A[1000], B[1000];\n\nint main(){\n\n  int i, n, min=0, m, k, now, sum=0, minx, sum1, sum2;\n\n  scanf(\"%d\", &n);\n\n  for(i=1; i<n+1; i++){\n    scanf(\"%d\",&A[i]);\n  }\n\n  minx=A[1];\n\n  for(i=1; i<n+1; i++)\n    if(minx>A[i]) minx=A[i];\n\n  for(i=0; i<N; i++){\n    C[i].sum=0;\n    C[i].flag=0;\n  }\n\n  for(i=1; i<n+1; i++){\n    C[A[i]].sum+=1;\n    C[A[i]].flag+=1;\n  }\n\n  for(i=0; i<N; i++)\n    C[i].sum+=C[i-1].sum;\n\n  for(i=n+1; i>0; i--){\n    if(C[A[i]].flag==1){\n      k=i;\n      now=k;\n      m=0;\n      B[C[A[k]].sum]=A[k];\n      C[A[i]].flag=0;\n      min=A[k];\n      k=C[A[k]].sum;\n      while(A[now]!=A[k]){\n        if(m==0) sum+=A[now];\n        B[C[A[k]].sum]=A[k];\n        C[A[k]].flag=0;\n        sum+=A[k];\n        if(min>A[k]) min=A[k];\n        k=C[A[k]].sum;\n        m+=1;\n      }\n      sum2=min*(m-1);\n      sum1=min+(m+2)*minx;\n      if(m>1){\n    if(sum1<sum2){\n      sum+=sum1;\n    }else sum+=sum2;\n    m=0;\n    min=0;\n      }\n    }\n  }\n\n  printf(\"%d\\n\",sum);\n\n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin >> n;\n\n    int w[n], sorted[n], minimum = 10000;\n    bool visited[n];\n    for (int i = 0; i < n; i++)\n    {\n        cin >> w[i];\n        sorted[i] = w[i];\n        visited[i] = false;\n        minimum = min(minimum, w[i]);\n    }\n\n    sort(sorted, sorted + n);\n    int inv[10001];\n    for (int i = 0; i < n; i++)\n        inv[sorted[i]] = i;\n\n    int ans = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (visited[i])\n            continue;\n        int sum = 0, c = 0, minw = 10000, j = i;\n        while (!visited[j])\n        {\n            sum += w[j];\n            c++;\n            minw = min(minw, w[j]);\n            visited[j] = true;\n            j = inv[w[j]];\n        }\n        ans += min(sum + (c - 2) * minw, sum + minw + (c + 1) * minimum);\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include    <bits/stdc++.h>\nusing   namespace   std;\n\n#define MAX_A   10000\n\nint get_g(int i, vector<int> &grp) {\n    if (i==grp.at(i)) return i;\n    return get_g(grp.at(i), grp);\n}\n\nint main() {\n    int N;\n    cin >>N;\n    vector<int> w(N+1, 0);\n    vector<vector<int>> ww={{-1, 0}};\n    for (int i=1; i<=N; i++) {\n        int W=0;\n        cin >>W;\n        w.at(i)=W;\n        ww.push_back({W, i});\n    }\n    sort(ww.begin()+1, ww.end());\n    int MIN=ww.at(1).at(0);\n    // Data store\n    // grp: Group#\n    // grp_depth: Steps to the group root\n    vector<int> grp(N+1, 0);\n    vector<int> grp_depth(N+1, 0);\n    // Initialize group# as each own\n    for (int i=1; i<=N; i++) {\n        grp.at(i)=i;\n    }\n    // Grouping\n    for (int i=1; i<=N; i++) {\n        int xx=i;\n        int yy=ww.at(i).at(1);\n        xx=get_g(xx, grp);\n        yy=get_g(yy, grp);\n        // Already in same group, do nothing\n        if (xx==yy) continue;\n        // Put into one group\n        if (grp_depth.at(xx)==grp_depth.at(yy)) {\n            // Groups have same height\n            // Merge into less-number-group\n            grp.at(max(xx, yy)) = get_g(min(xx, yy), grp);\n            grp_depth.at(min(xx, yy))++;\n        } else if (grp_depth.at(xx)>grp_depth.at(yy)) {\n            // x is higher\n            // Merge into x so that the hight will not increase\n            // (height for y will be +1)\n            grp.at(yy) = xx;\n        } else\n            // y is higher\n            // Merget into y\n            grp.at(xx) = yy;\n    }\n    vector<vector<int>> G(N+1);\n    for (int i=1; i<=N; i++)\n        G.at(get_g(i, grp)).push_back(w.at(i));\n    int S=0;\n    for (int i=1; i<=N; i++) {\n        if (1<G.at(i).size()) {\n            int M=10001;\n            int SS=0;\n            for (int j=0; j<G.at(i).size(); j++) {\n                SS +=G.at(i).at(j);\n                M=min(M, G.at(i).at(j));\n            }\n            S +=min(SS+M*(G.at(i).size()-2), SS+M+MIN*(G.at(i).size()+1));\n        }\n    }\n    cout <<S <<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstatic const int MAX=1000;\nstatic const int VMAX=10000;\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve()\n{\n    int ans=0;\n\n    bool V[MAX];\n    for(int i=0;i<n;++i)\n    {\n        B[i]=A[i];\n        V[i]=false;\n    }\n    sort(B,B+n);\n    for(int i=0;i<n;i++)\n    {\n        T[B[i]]=i;\n    }\n    for(int i=0;i<n;i++)\n    {\n        if(V[i])continue;\n        int cur=i;\n        int S=0;\n        int m=VMAX;\n        int an=0;\n        while(1)\n        {\n            V[cur]=true;\n            an++;\n            int v=A[cur];\n            m=min(m,v);\n            S+=v;\n            cur=T[v];\n            if(V[cur])break;\n        }\n        ans+=min(S+(an-2)*m,m+S+(n+1)*s);\n    }\n    return ans;\n}\n\nint main()\n{\n\tcin>>n;\n\ts=VMAX;\n\tfor(int i=0;i<n;i++)\n    {\n        cin>>A[i];\n        s=min(s,A[i]);\n    }\n    int ans=solve();\n    cout<<ans<<endl;\n \treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<list>\nusing namespace std;\n\ntypedef struct{int a;int b;int c;} arr;\ntypedef pair<long long,long long> logg;\n\narr L[510],R[510];\n\nint merge(arr a[],int l,int m,int r,char c)\n{\n\tint n1=m-l;\n\tint n2=r-m;\n\tfor(int i=0;i<n1;i++)\n\t{\n\t\tL[i]=a[l+i];\n\t}\n\tfor(int i=0;i<n2;i++)\n\t{\n\t\tR[i]=a[m+i];\n\t}\n\tint i=0,j=0;\n\tif(c=='a')\n\t{\n\t\tL[n1].a=100000;R[n2].a=100000;\n\t\tfor(int k=l;k<r;k++)\n\t\t{\n\t\t\tif(L[i].a<=R[j].a)\n\t\t\t{\n\t\t\t\ta[k]=L[i++];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta[k]=R[j++];\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tL[n1].c=100000;R[n2].c=100000;\n\t\tfor(int k=l;k<r;k++)\n\t\t{\n\t\t\tif(L[i].c<=R[j].c)\n\t\t\t{\n\t\t\t\ta[k]=L[i++];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta[k]=R[j++];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint mergeS(arr a[],int l,int r,char c)\n{\n\tif(l+1<r)\n\t{\n\t\tint m=(l+r)/2;\n\t\tmergeS(a,l,m,c);\n\t\tmergeS(a,m,r,c);\n\t\tmerge(a,l,m,r,c);\n\t}\n}\n\n\nint main()\n{\n\tint n,j=1;cin>>n;\n\tarr a[1010];\n\tlogg c[1010];\n\tfor(int i=1;i<=n;cin>>a[i++].a);a[n+1].a==1;\n\t\n\t\n\tfor(int i=1;i<=n;a[i].c=i,i++);\n\tmergeS(a,1,n+1,'a');\n\tfor(int i=1;i<=n;a[i].b=i,i++);\n\tmergeS(a,1,n+1,'c');\n\t\n\t\n\tfor(int i=1,m=0;;)\n\t{\n\t\tif(a[i].b!=0)//.b\n\t\t{\n\t\t\tc[j].first++;\n\t\t\tc[j].second+=a[i].a;\n\t\t\tif(a[i].a>m)m=a[i].a;\n\t\t\tint l=a[i].b;//.b\n\t\t\ta[i].b=0;//.b\n\t\t\ti=l;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(c[j].first==1)\n\t\t\t{\n\t\t\t\tc[j].second=0;\n\t\t\t}\n\t\t\telse if(c[j].first>=3)\n\t\t\t{\n\t\t\t\tc[j].second-=m;\n\t\t\t\tc[j].second*=2;\n\t\t\t}\n\t\t\tm=0;\n\t\t\tj++;\n\t\t\tint s=0;\n\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t{\n\t\t\t\ts+=a[k].b;//a\n\t\t\t\tif(a[k].b!=0)i=k;//a\n\t\t\t}\n\t\t\tif(s==0)break;\n\t\t}\n\t}\n\tlong long s=0;\n\tfor(int i=1;i<=j;i++)\n\t{\n\t\ts+=c[i].second;\n\t}\n\tcout<<s<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "const int MAXN = 1010;\nint w[MAXN];\nbool done[MAXN];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, mini = 100000;\n    cin >> n;\n    map<int, int> mp;\n    for (int i = 0; i < n; i++) {\n        cin >> w[i];\n        mp[w[i]] = 0;\n        mini = min(mini, w[i]);\n    }\n    {\n        int k = 0;\n        for (auto& p : mp) p.second = k++;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (done[i]) continue;\n        int cnt = 0, now = i, mi = 100000, sum = 0;\n        while (1) {\n            if (done[now]) break;\n            cnt++;\n            done[now] = true;\n            mi = min(mi, w[now]);\n            sum += w[now];\n            now = mp[w[now]];\n        }\n        int tmp = sum+(cnt-2)*mi;\n        tmp = min(tmp, sum+mi+mini*(cnt+1));\n        ans += tmp;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n\nusing namespace std;\n\nconst double PI = 3.14159265358979;\n\nlong long SUM = 0;\n\nvoid printArr(int a[], int len) {\n\n\tfor (int i = 0; i < len; i++)\n\t{\n\t\tif (i == 0) cout << a[0];\n\t\telse cout << \" \" << a[i];\n\t}\n\tcout << endl;\n}\n\n\nint solve(int a[], int len, int MINX, int MAXX) {\n\n\tbool* visited = new bool[len];\n\tint* b = new int[len];\n\tfor (int i = 0; i < len; i++) {\n\t\tb[i] = a[i];\n\t\tvisited[i] = false;\n\t}\n\tsort(b, b + len);\n\n\tint* book = new int[MAXX + 1];\n\tfor (int i = 0; i < len; i++) {\n\t\tbook[b[i]] = i;\n\t}\n\n\tint res = 0;\n\tfor (int i = 0; i < len; i++) {\n\t\tif (visited[i]) continue;\n\n\t\tint sum = 0;\n\t\tint minw = INT_MAX;\n\t\tint next = i;\n\t\tint count = 0;\n\t\twhile (!visited[next]) {\t\t// 一个圈\n\t\t\tvisited[next] = true;\n\t\t\tint weight = a[next];\n\t\t\tnext = book[a[next]];\n\n\t\t\tif (minw > weight) minw = weight;\n\t\t\tsum += weight;\n\t\t\tcount++;\n\t\t}\n\t\tres += min(sum + (count - 2) * minw, sum + minw + (count + 1) * MINX);\n\t}\n\t\n\n\tdelete[] b;\n\tdelete[] visited;\n\tdelete[] book;\n\treturn res;\n}\n\nint main() {\n\n\tint n; cin >> n;\n\n\tint* a = new int[n];\n\tint MINX = INT_MAX;\n\tint MAXX = INT_MIN;\n\tfor (int i = 0; i < n; i++)\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\tif (MINX > a[i]) MINX = a[i];\n\t\tif (MAXX < a[i]) MAXX = a[i];\n\t}\n\n\tint res = solve(a, n, MINX, MAXX);\n\n\tcout << res << endl;\n\t\n\tdelete[] a;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdlib>\n#define _USE_MATH_DEFINES // M_PI????????????????????????\n#include<math.h>\n#pragma warning(disable:4996)\nusing namespace std;\n\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve(){\n\tint ans=0;\n\tbool V[MAX];\n\n\tfor(int i=0; i<n; i++){\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\n\tsort(B,B+n);\n\tfor(int i=0; i<n; i++) T[B[i]] = i;\n\tfor(int i=0; i<n; i++){\n\t\tif(V[i]) continue;\n\t\tint cur = i;\n\t\tint S=0;\n\t\tint m = VMAX;\n\t\tint an=0;\n\t\twhile(1){\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m,v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif( V[cur] ) break;\n\t\t}\n\t\tans += min(S+(an-2)*m,m+S+(an+1)*s);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tcin >> n;\n\ts = VMAX;\n\tfor(int i=0; i<n; i++){\n\t\tcin >> A[i];\n\t\ts = min(s,A[i]);\n\t}\n\tint ans = solve();\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\nint main(){\n\tint N,r=0;\n\tscanf(\"%d\",&N);\n\tstd::vector<int>v(N);\n\tfor(int i=0;i<N;i++)scanf(\"%d\",&v[i]);\n\tfor(int i=0;i<N;i++){\n\t\tauto ma=max_element(v.begin(),v.end()-i);\n\t\tif(ma!=v.begin()+(N-1-i)){\n\t\t\tr+=*ma+v[N-1-i];\n\t\t\tswap(*ma,v[N-1-i]);\n\t\t}\n\t\tauto mi=min_element(v.begin()+i,v.end());\n\t\tif(mi!=v.begin()+i){\n\t\t\tr+=*mi+v[i];\n\t\t\tswap(*mi,v[i]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int Inf = 1e9;\n\nint main(int argc, char const *argv[]) {\n  int n;  cin >> n;\n  int ans = 0;\n  int mini = Inf;\n  vector<int> w, b, t(10001);\n  vector<bool> visit(n, false);\n  for (int i = 0; i < n; ++i) {\n    int a;  cin >> a;\n    mini = min(mini, a);\n    w.push_back(a);\n    b.push_back(a);\n  }\n  sort(b.begin(), b.end());\n  for (int i = 0; i < n; ++i) {\n    t[b[i]] = i;\n  }\n  for (int i = 0; i < n; ++i) {\n    if (visit[i]) continue;\n    int current = i;\n    int sum = 0;\n    int e = 0;\n    int m = Inf;\n    while (1) {\n      visit[current] = true;\n      e++;\n      int value = w[current];\n      sum += value;\n      m = min(m, value);\n      current = t[value];\n      if (visit[current]) break;\n    }\n    ans += min(sum + m + (e + 1) * mini, sum + (e - 2) * m);\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 1000\n#define VMAX 10000\nusing namespace std;\nint A[MAX],B[MAX],n,s;\nint T[VMAX+1];\nint solve(){\n    bool V[MAX];\n    int ans=0;\n    for(int i=0;i<n;i++){\n        B[i]=A[i];\n        V[i]=false;\n    }\n    sort(B,B+n);\n    for(int i=0;i<n;i++){\n        T[B[i]]=i;\n    }\n    for(int i=0;i<n;i++){\n        if(V[i])    \n            continue;\n        int cur=i;\n        int S=0;\n        int an=0;\n        int m=VMAX;\n        while(1){\n            V[cur]=true;\n            int v=A[cur];\n            S+=v;\n            an++;\n            m=min(m,v);\n            cur=T[v];\n            if(V[cur])  \n                break;\n        }\n        ans+=min(S+(an-2)*m,S+m+(an+1)*s);\n    }\n    return ans;\n}\nint main(){\n    cin>>n;\n    s=VMAX;\n    for(int i=0;i<n;i++){\n          cin>>A[i];\n          s=min(s,A[i]);\n    }\n    int ans=solve();\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <climits>\nusing namespace  std;\n\nstruct StCst\n{\n  int m_nNo;\n  int m_nSeq;\n  bool m_bDone;\n\n  static bool AsdNo(const StCst &cnroLeft, const StCst &cnroRight) \n  { return cnroLeft.m_nNo < cnroRight.m_nNo; }\n};\n\nvoid fnInput(int &rnMaxSiz, vector<StCst> &rvoSort, int &rnMinNo)\n{\n  int nCnt = 0;\n  cin >> rnMaxSiz;\n\n  rvoSort.resize(rnMaxSiz);\n  for (int i = 0; i < rnMaxSiz; i++)\n  {\n    cin >> rvoSort[i].m_nNo;\n    rnMinNo = min(rnMinNo, rvoSort[i].m_nNo);\n    rvoSort[i].m_nSeq = nCnt++;\n  }\n}\n\nvoid fnMinCostSort(vector<StCst> &rvoSort, int nMinNo, int &rnSwpCnt)\n{\n  sort(begin(rvoSort), end(rvoSort), StCst::AsdNo);\n\n  int nCost;\n  for (int i = 0; i < rvoSort.size(); i++)\n  {\n    if (rvoSort[i].m_bDone)  continue;\n\n    int nTotal = rvoSort[i].m_nNo;\n    int nCurSize = 1;\n    int nCurMin = rvoSort[i].m_nNo; \n    rvoSort[i].m_bDone = true;\n\n    int j = rvoSort[i].m_nSeq;\n    while  (rvoSort[j].m_nNo != rvoSort[i].m_nNo)\n    {\n      nTotal += rvoSort[j].m_nNo;\n      nCurSize++;\n      nCurMin = min(nCurMin, rvoSort[j].m_nNo);\n      rvoSort[j].m_bDone = true;\n      j = rvoSort[j].m_nSeq;\n    }\n\n    if (nCurSize == 1)\n        nCost = 0;\n    else\n      if (nMinNo == nCurMin)\n        nCost = nTotal + (nCurSize - 2) * nCurMin;\n      else\n        nCost = min(nTotal + (nCurSize - 2) * nCurMin, \n                    nTotal + nCurMin + (nCurSize + 1) * nMinNo);\n    rnSwpCnt += nCost;\n  }\n}\n\nvoid fnResult(int nSwpCnt)\n{\n  cout << nSwpCnt << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int nMaxSiz;\n  vector<StCst> voSort;\n  int nMinNo = INT_MAX;\n\n  fnInput(nMaxSiz, voSort, nMinNo);\n\n  int nSwpCnt = 0;\n  fnMinCostSort(voSort, nMinNo, nSwpCnt);\n\n  fnResult(nSwpCnt);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cmath>\n#include <stack>\n#include <set>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n); (i)++)\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b); (i)++)\n#define PUSH(n,v) for(int i=0; i<(n); i++) {int j; cin >> j; v.push_back(j);}\n#define ALL(v) v.begin(), v.end()\n\nvector<int> sorted;\n\nint minimumCostSort(vector<int> &v) {\n    int n = v.size();\n    int cost = 0;\n    int vindex = 0;\n    int indexOfSmallest = find(v.begin(), v.end(), sorted[vindex]) - v.begin();\n    while(vindex < n) {\n        if (v[indexOfSmallest] == v[vindex]) {\n            vindex++;\n            indexOfSmallest = find(v.begin(), v.end(), sorted[vindex]) - v.begin();\n        }else {\n            int indexOfTarget = find(v.begin(), v.end(), sorted[indexOfSmallest]) - v.begin();\n            cost += v[indexOfSmallest] + v[indexOfTarget];\n            int temp = v[indexOfSmallest];\n            v[indexOfSmallest] = v[indexOfTarget];\n            indexOfSmallest = indexOfTarget;\n            v[indexOfTarget] = temp;\n        }\n    }\n    return cost;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> v;\n    PUSH(n,v);\n    copy(v.begin(), v.end(), back_inserter(sorted));\n    sort(sorted.begin(), sorted.end());\n    \n    cout << minimumCostSort(v) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nvoid show( int arr[], size_t size )\n{\n\n\tcout<<arr[0]<<flush;\n    for( size_t i=1; i<size; i++ ){\n\t    cout<<' '<<arr[i]<<flush;\n    }\n    cout<<endl;\n}\n\nint selectionSort(int* arr, size_t arr_s){\n\n\tsize_t imin,cost=0;\n\tfor(size_t i=0; i<arr_s-1; i++) {\n\t\timin=i;\n\n\t\tfor(size_t j=i+1; j<arr_s; j++) {\n\n\t\t\timin= (arr[imin] > arr[j])? j : imin;\n\n\t\t}\n\n\t\tif(imin != i){\n\t\t\tswap( arr[imin], arr[i] );\n\t\t\tcost+= arr[imin] + arr[i];\n\t\t}\n\t}\n\treturn cost;\n}\n\nint main()\n{\n\tsize_t arr_s;cin>>arr_s;\n\tint *arr=new int[arr_s];\n\tfor( size_t i=0; i<arr_s; i++ ){\n\t\tcin>>arr[i];\n\t}\n\n\tlong long minCost=selectionSort(arr, arr_s);\n\tshow(arr, arr_s);\n\tcout<<minCost<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint sorting(vector<short> v)\n{\n\tmap<vector<short>, int> d;\n\t\n\tvector<short> sorted(v.begin(), v.end());\n\t\n\tsort(v.begin(), v.end());\n\t\n\tqueue<pair<vector<short>, int> > que;\n\t\n\tque.push(make_pair(v, 1)); d[v] = 1; // pair(vector, cost + 1)\n\t\n\twhile(!que.empty())\n\t{\n\t\tvector<short> v1 = que.front().first;\n\t\t\n\t\tint cost = que.front().second; que.pop();\n\t\t\n\t\tfor(int i = 0; i < v.size(); i++)\n\t\t{\n\t\t    for(int j = i + 1; j < v.size(); j++)\n\t\t    {\n\t\t        vector<short> v2(v1.begin(), v1.end());\n\t\t        \n\t\t        int cost2 = cost + v1[i] + v1[j];\n\t\t        \n\t\t        swap(v2[i], v2[j]);\n\t\t        \n\t\t        if(d[v2] == 0 || d[v2] > cost2)\n\t\t        {\n\t\t            d[v2] = cost2;\n\t\t            \n\t\t            que.push(make_pair(v2, cost2));\n\t\t        }\n\t\t    }\n\t\t}\n\t}\n\t\n\treturn d[sorted] - 1;\n}\n\nint main()\n{\n\tvector<short> v; int n;\n\t\n\tcin >> n; v = vector<short>(n);\n\t\n\tfor(int i = 0; i < n; i++) { cin >> v[i]; }\n\t\n\tcout << sorting(v) << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i) \n#define PI acos(-1)\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\nll minCostSort(int n, vector<int> as) {\n    vector<int> bs(n);\n    copy(as.begin(), as.end(), bs.begin());\n    sort(bs.begin(), bs.end());\n    vector<bool> visited(n);\n\n    int gm = bs[0];\n    ll cost = 0;\n    rep(i, n) {\n        if (visited[i]) continue;\n\n        int cur = i;\n        ll s = 0;\n        int m = INT_MAX;\n        int hop = 0;\n        while (!visited[cur]) {\n            if (as[cur] < m) m = as[cur];\n            s += as[cur];\n            visited[cur] = true;\n            hop++;\n            cur = distance(bs.begin(), lower_bound(bs.begin(), bs.end(), as[cur]));\n        }\n        cost += min(s + m * (hop - 2), s + m + gm * (hop + 1));\n    }\n    return cost;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin>>n;\n    vector<int> as(n);\n    rep(i, n) cin>>as[i];\n\n    ll ans = minCostSort(n, as);\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n\n\nusing namespace std;\n\nint main() {\n\t\n\tint const N_MAX = 1000;\n\tint const W_MAX = 10000;\n\n\tint n = 0;\n\tcin >> n;\n\n\tvector<int> W, S, T;\n\tvector<bool> C;\n\t\n\tW.resize(n, 0);     // idx -> W\n\tS.resize(n, 0);     // sorted Wi\n\tT.resize(W_MAX, 0); // W -> idx\n\tC.resize(n, false); // flag for searched or not\n\n\tint g_min = W_MAX; // global_min of Wi\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> W[i];\n\t\tg_min = (W[i] < g_min) ? W[i] : g_min;\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tT[W[i]] = i;\n\t}\n\n\tS = W;\n\tstable_sort(S.begin(), S.end());\n\n\tint score = 0;\n\n\t//cout << \"<<W>> \";\n\t//trace(W);\n\t//cout << \"<<S>> \";\n\t//trace(S);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!C[T[S[i]]]) {\n\t\t\tint l_min = W_MAX;\n\t\t\tint sum = 0;\n\t\t\tint cnt = 0;\n\t\t\t//vector<int> L;\n\t\t\tfor(int j = S[i]; !C[T[j]]; j = S[T[j]] ) {\n\t\t\t\t//L.push_back(j);\n\t\t\t\tC[T[j]] = true;\n\t\t\t\tcnt++;\n\t\t\t\tsum += j;\n\t\t\t\tl_min = (j < l_min) ? j : l_min;\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t\t//cout << \"<<L>> \";\n\t\t\t//trace(L);\n\t\t\t//cout << \"sum:\" << sum << \" N:\" << cnt << \" l_min:\" << l_min << \" g_min\" << g_min << endl;\n\t\t\t//cout << sum + l_min*(cnt - 2) << \" or \" << sum + g_min*(cnt + 1) + l_min << endl;\n\t\t\tscore += min(sum + l_min*(cnt - 2), sum+g_min*(cnt+1)+l_min);\n\t\t\t//cout << \"Now, Cost is \" << score << endl;\n\t\t\t//L.clear();\n\t\t}\n\t}\n\n\tcout << score << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n   int n, ans=0, t[1000], u[1000];\n   bool visited[1000];\n   map<int, int> change;\n   cin >> n;\n   for(int i=0; i<n; i++){\n      cin >> t[i];\n      change[t[i]]=i; //キーt[i]の値をiに設定\n      u[i]=t[i];\n      visited[i]=false;\n   }\n   sort(u, u+n);\n   for(int i=0; i<n; i++){\n      int w=i, x=0, y=0, z=10000;\n      while(!visited[w]){\n         z=min(z, t[w]);\n         y+=t[w];\n         x++;\n         visited[w]=true;\n         w=change[u[w]];\n      }\n      if(x>=2)ans+=min(y+z+u[0]*(x+1), y+z*(x-2)); //最小値を使うか\n   }\n   cout << ans << endl;\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define MAX 1000\nint n,x,a[MAX],b[MAX],t[10001];\n \nint solve(){\n    int ans=0;\n    bool v[MAX];\n    for(int i=0;i<n;i++){\n        b[i]=a[i];  v[i]=false;\n    }\n    sort(b,b+n);\n    for(int i=0;i<n;i++) t[b[i]]=i;\n    for(int i=0;i<n;i++){\n        if(v[i])    continue;\n        int current=i;\n        int s=0;\n        int m=10000;\n        int count=0;\n        while(1){\n            v[current]=true;\n            count++;\n            m=min(m,a[current]);\n            s+=a[current];\n            current=t[a[current]];\n            if(v[current])  break;\n        }\n        ans+=min(s+(count-2)*m,s+m+(count+1)*x);\n    }\n    return ans;\n}\n         \n \nint main(){\n    cin>>n;\n    x=10000;\n    for(int i=0;i<n;i++){\n        cin>>a[i];\n        x=min(x,a[i]);\n    }\n    cout<<solve()<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, a[1009], c[1009]; bool vis[1009];\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (a[i] > a[j]) c[i]++;\n\t\t}\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (vis[i]) continue;\n\t\tint pos = i, m = 1012345678, cnt = 0;\n\t\twhile (!vis[pos]) {\n\t\t\tvis[pos] = true;\n\t\t\tret += a[pos];\n\t\t\tm = min(m, a[pos]);\n\t\t\tpos = c[pos];\n\t\t\tcnt++;\n\t\t}\n\t\tret += m * (cnt - 2);\n\t}\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<algorithm>\n#include<iostream>\n#include<map>\n#include<vector>\nint main(void) {\n\tstd::ios_base::sync_with_stdio(false);\n\tint n, input;\n\tstd::cin >> n;\n\tstd::map<int, int>w;\n\t\n\tstd::vector<int>vector_min(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tstd::cin >> input;\n\t\tw[input - 1] = i;\n\t\tvector_min[i] = input-1;\n\t}\n\tstd::map<int, int>w_1(w);\n\tstd::sort(vector_min.begin(), vector_min.end());\n\tint cnt = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint temp = 0;\n\t\twhile (vector_min[i] != w[vector_min[i]]) {\n\t\t\ttemp += vector_min[i] + w[vector_min[i]] + 2;\n\t\t\tstd::swap(w[vector_min[i]],w[w[vector_min[i]]] );\n\t\t}\n\t\tint temp_1 = 0;\n\t\tif (vector_min[i] != w_1[vector_min[i]]) {\n\t\t\ttemp_1 +=  w_1[vector_min[i]] + 2;\n\t\t\tstd::swap(w_1[0], w_1[vector_min[i]]);\n\t\t\twhile (0!=w_1[0]) { \n\t\t\t\ttemp_1 += w_1[0] + 2;\n\t\t\t\tstd::swap(w_1[0], w_1[w_1[0]]); }\n\t\t}\n\t\tcnt += std::min(temp, temp_1);\n\t}\n\tstd::cout << cnt << std::endl;\n//\tsystem(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n    int n;\n    cin >> n;\n    int A[n];\n    int B[n];\n    for (int i = 0; i < n; i++) {\n        cin >> A[i];\n        B[i] = A[i];\n    }\n    sort(B, B + n);\n    int cnt = 0;\n    int i = 0;\n    while (i < n) {\n        if (A[i] == B[i]) {\n            i++;\n            continue;\n        }\n        int tgt_idx = find(A, A + n, B[i]) - A;\n        int dst_idx = find(A, A + n, B[tgt_idx]) - A;\n        cnt += A[tgt_idx] + A[dst_idx];\n        swap(A[tgt_idx], A[dst_idx]);\n    }\n    cout << cnt << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//ALDS1_5_D_InversionNumber.cpp\n\n#include<bits/stdc++.h>\nusing namespace std;\nconst int INF=2E9;\ntypedef pair<int,int> Pair;\ntypedef long long LL;\n\n\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int> w;\n    map<int,int> mp;\n    int minV=INF;\n    for(int i=0;i<n;i++){\n        int tmp;\n        cin >> tmp;\n        w.push_back(tmp);\n        minV=min(minV,tmp);\n    }\n    vector<int> sw=w;\n    sort(sw.begin(),sw.end());\n    for(int i=0;i<n;i++){\n        mp[sw[i]]=i;\n    }\n    int *L=new int[n];\n    for(int i=0;i<n;i++){\n        L[i]=0;\n    }\n    int MCOST1=0;\n    int MCOST2=0;\n    int minW=INF;\n    int sum=0;\n    int totalcost=0;\n    int cnt=0;\n\n    for(int i=0;i<n;i++){\n        cnt=0;\n        minW=INF;\n        sum=0;\n        if(L[i]!=1){\n            if(mp[w[i]]==i) continue;\n            int j=i;\n            do {\n                sum+=w[j];\n                minW=min(minW,w[j]);\n                cnt++;\n                L[j]=1;\n                j=mp[w[j]];\n            }while(L[j]!=1);\n            MCOST1=sum+(cnt-2)*minW;\n            MCOST2=sum+minW+(cnt+1)*minV;\n\n            totalcost+=min(MCOST1,MCOST2);\n        }\n    }\n    cout << totalcost << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#define MAX 1000\n#define VMAX 10000\nusing namespace std;\nint n, s, A[MAX], B[MAX], T[VMAX+1];\n\nint solve()\n{\n  int ans = 0;\n  int m, an, S;\n  bool V[MAX];\n  sort(B, B+n);\n  for(int i=0; i<n; i++)\n  {\n    T[B[i]] = i;\n    V[i] = false;\n  }\n  for(int i=0; i<n; i++)\n  {\n    if(V[i]) continue;\n    m = VMAX;\n    an = 0;\n    S = 0;\n    int cur = i;\n    while(1)\n    {\n      V[cur] = true;\n      an++;\n      int v = A[cur];\n      m = min(v, m);\n      S += v;\n      cur = T[v];\n      if(V[cur]) break;\n    }\n    ans += min(S + (an - 2)*m, S + m + (an+1)*s);\n  }\n  return ans;\n}\nint main()\n{\n  cin >> n;\n  s = VMAX;\n  for(int i=0; i<n; i++)\n  {\n    cin >> A[i];\n    B[i] = A[i];\n    s = min(s, A[i]);\n  }\n  int ans = solve();\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve() {\n\tint ans = 0;\n\n\n\tbool V[MAX];\n\tfor (int i = 0; i < n; i++) {\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\n\n\t}\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; i++) T[B[i]] = i;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (V[i])continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile (1) {\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif (V[cur])break;\n\n\t\t}\n\t\tans += min(S + (an - 2)*m, m + S + (an + 1)*s);\n\t}\n\treturn ans;\n}\n\n\nint main() {\n\tcin >> n;\n\ts = VMAX;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\n\t}\n\n\tint ans = solve();\n\tcout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve(){\n  int ans=0;\n\n  bool V[MAX];\n  for(int i=0;i<n;i++){\n    B[i]=A[i];\n    V[i]=false;\n  }\n\n  sort(B,B+n);\n  for(int i=0;i<n;i++) T[B[i]]=i;\n   for(int i=0;i<n;i++){\n     if(V[i]) continue;\n     int cur =i;\n     int S=0;\n     int m=VMAX;\n     int an=0;\n     while(1){\n       V[cur]=true;\n       an++;\n       int v=A[cur];\n       m=min(m,v);\n       S += v;\n       cur=T[v];\n       if(V[cur]) break;\n     }\n     ans+= min(S+(an-2)*m,m+S+(an+1)*s);\n   }\n   return ans;\n}\n\n\n\nint main(){\n  cin >> n;\n  s=VMAX;\n   for(int i=0;i<n;i++){\n     cin >> A[i];\n     s=min(s,A[i]);\n   }\n   int ans=solve();\n   cout << ans << endl;\n\n   return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <map>\n#include <memory>\n#include <set>\n#include <vector>\n#include <deque>\n#include <list>\n#include <stack>\n#include <queue>\n\nusing namespace std;\n\nclass MinCostSort\n{\npublic:\n  int solve();\n};\n\nint MinCostSort::solve()\n{\n  int cost = 0;\n  int n;\n  cin >> n;\n  \n  vector<int> w(n);\n  vector<int> sw(n);\n  \n  for ( int i = 0; i < n; ++i )\n    {\n      cin >> w[i];\n      sw[i] = w[i];\n    }\n\n  sort( sw.begin(), sw.end() );\n\n  int mw = sw[0];\n  \n  for ( auto i = 0; i < n; ++i )\n    {\n      if ( w[i] < 0 ) continue;\n      \n      if ( w[i] == sw[i] )\n        {\n          w[i] = -1;\n          sw[i] = -1;\n          continue;\n        }\n      \n      int mlw = 20000;\n      int ii = i;\n      int j;\n      int sm = 0;\n      int ct = 0;\n      \n      while ( true )\n        {\n          for ( j = 0; j < n; ++j )\n            {\n              if ( sw[j] == w[ii] ) break;\n            }\n          if ( mlw > w[ii] ) mlw = w[ii];\n          sm += w[ii];\n          ++ct;\n          w[ii] = -1;\n          sw[j] = -1;\n          ii = j;\n          if ( ii == i ) break;\n        }\n      cost += min( sm + (ct - 2) * mlw, sm + (ct + 1) * mw + mlw );\n    }\n  \n  cout << cost << endl;\n  \n  return 0;\n}\n\nint main()\n{\n\n  MinCostSort mcs;\n\n  mcs.solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\nusing std::scanf;\nusing std::printf;\n\nconst int kMaxN = 1000;\nconst int kMaxWi = 10000;\nconst int kSentinel = kMaxWi + 1;\n\n// w[i]?????????????????????????????????cycle???????????????????????????remain????????£?????????????¨????\n// ????????????cycle?????????\nint MakeCycle(int w[], int i, int remain[], int cycle[]) {\n  int j = 0;\n  cycle[0] = -1; //?????????while?????????????????????\n  while(w[i] != cycle[0]) {\n    cycle[j] = w[i];\n    ++j;\n    remain[i] = 0;\n    i = w[i] - 1;\n  }\n  return j;\n}\n\nint CompareCosts(int cycle[], int cycle_n, int cycle_min, int w_min) {\n  if (cycle_n == 1) {\n    return 0;\n  } else if (cycle_n == 2) {\n    return cycle[0] + cycle[1];\n  } else {\n    int cycle_sum, i, cost1, cost2;\n    cycle_sum = 0;\n    for (i = 0; i < cycle_n; ++i) { cycle_sum += cycle[i]; }\n    cost1 = cycle_sum + (cycle_n - 2) * cycle_min;\n    cost2 = cycle_sum + cycle_min + (cycle_n + 1) * w_min;\n    return std::min(cost1, cost2);\n  }\n}\n\nint main() {\n  int n, i, j, cycle_n, cycle_min, w_min, cnt;\n  scanf(\"%d\", &n);\n  int w[n], remain[n], cycle[n];\n  for (i = 0; i < n; ++i) { scanf(\"%d\", &w[i]); }\n  w_min = kMaxWi;\n  for (i = 0; i < n; ++i) { w_min = std::min(w_min, w[i]); }\n  for (i = 0; i < n; ++i) { remain[i] = 1; }\n  cnt = 0;\n  for (i = 0; i < n; ++i) {\n    if (remain[i]) {\n      cycle_n = MakeCycle(w, i, remain, cycle);\n      cycle_min = kMaxWi;\n      for (j = 0; j < cycle_n; ++j) { cycle_min = std::min(cycle_min, cycle[j]); }\n      cnt += CompareCosts(cycle, cycle_n, cycle_min, w_min);\n    }\n  }\n  printf(\"%d\\n\", cnt);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define Vi vector<int>\n#define FOR(i,s,e) for (int i=s; i<e; i++)\n#define ITER(v) v.begin(), v.end()\n\nconstexpr int MAX_N = 1000;\nconstexpr int MAX_VAL = 10001;\n\nint merge(int* A, const int& left, const int& mid, const int& right) {\n    const int n1 = mid - left;\n    const int n2 = right - mid;\n\n    auto L = new int[n1+1];\n    auto R = new int[n2+1];\n    for (int i = 0; i < n1; i++) {\n        L[i] = A[left + i];\n    }\n    for (int i = 0; i < n2; i++) {\n        R[i] = A[mid + i];\n    }\n\n    L[n1] = MAX_VAL;\n    R[n2] = MAX_VAL;\n\n    int i = 0, j = 0;\n    for (int k = left; k < right; k++) {\n        if (L[i] <= R[j]) {\n            A[k] = L[i];\n            i++;\n        } else {\n            A[k] = R[j];\n            j++;\n        }\n    }\n    delete[] L;\n    delete[] R;\n    return right - left;\n}\n\nint mergeSort(int* A, const int& left, const int& right) {\n    int count = 0;\n    if (left + 1 < right) {\n        const int mid = (left + right) / 2;\n        count += mergeSort(A, left, mid);\n        count += mergeSort(A, mid, right);\n        return count + merge(A, left, mid, right);\n    }\n    return 0;\n}\n\nint minCostSort(int* w, int* ref, int n) {\n    int fixed = 0;\n    FOR(i,0,n) {\n        if (w[i] == ref[i]) {\n            w[i] = MAX_VAL;\n            ++fixed;\n        }\n    }\n    int cost = 0;\n    while (fixed < n) {\n        int* minelm = min_element(w, w+n);\n        int minelm_dest = distance(ref, lower_bound(ref, ref+n, *minelm));\n        int repl_dest = distance(w, minelm);\n        int* repl = lower_bound(w, w+n, ref[repl_dest]);\n        cost += *repl + *minelm;\n        *repl = *minelm;\n        *minelm = MAX_VAL;\n        ++fixed;\n        if (distance(w, repl) == minelm_dest) {\n            *repl = MAX_VAL;\n            ++fixed;\n        }\n    }\n    return cost;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int w[MAX_N];\n    int ref[MAX_N];\n    int n;\n\n    cin >> n;\n    FOR(i,0,n) {\n        cin >> w[i];\n        ref[i] = w[i];\n    }\n\n    sort(ref, ref+n);\n    int cost = minCostSort(w, ref, n);\n    cout << cost << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint p[10001];\n\nint partition(int *a, int p, int r){\n    int x = a[r];\n    int i = p - 1;\n    int tmp1;\n    for(int j=p;j<r;j++){\n        if(a[j]<=x){\n            i++;\n            tmp1 = a[j];\n            a[j] = a[i];\n            a[i] = tmp1;\n        }\n    }\n    a[r] = a[i+1];\n    a[i+1] = x;\n    return i + 1;\n}\n\nvoid quickSort(int *a, int p, int r){\n    if(p>=r)return;\n    int q = partition(a, p, r);\n    quickSort(a, p, q-1);\n    quickSort(a, q+1, r);\n}\n\nint calc(int *w, int *a, int n){\n    int c=0;\n    int p0, p1, w0, w1;\n    for(int i=0;i<n;i++){\n        while(a[i]!=w[i]){\n            w0 = a[i];\n            p0 = p[w0];\n            w1 = a[p0];\n            p1 = p[w1];\n            w[p0] = w1;\n            w[p1] = w0;\n            p[w0] = p1;\n            p[w1] = p0;\n            c+=w0+w1;\n        }\n    }\n    return c;\n}\n\nint main(){\n    int i, n;\n    scanf(\"%d\",&n);\n    int w[n];\n    int a[n];\n    for(i=0;i<n;i++){\n        scanf(\"%d\",w+i);\n        a[i]=w[i];\n        p[w[i]]=i;\n    }\n    quickSort(a, 0, n-1);\n    printf(\"%d\\n\",calc(w,a,n));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define SENTINEL 1000000001\n\n#define min(a,b) (a)>(b)?(b):(a)\n#define max(a,b) (a)>(b)?(a):(b)\n\nusing namespace std;\n\nint A[1000];\nint dupA[1000];\nint pos[10001];\nint dupPos[10001];\n\nint main()\n{\n\tint N;\n\tscanf(\"%d\", &N);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> A[i];\n\t\tdupA[i] = A[i];\n\t\tpos[A[i]] = i;\n\t\tdupPos[A[i]] = pos[A[i]];\n\t}\n\n\tsort(A, A + N);\n\n\tint temp1 = -1, temp2 = -1;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (pos[A[i]] == i)\n\t\t{\n\t\t\tif (temp1 == -1)\n\t\t\t{\n\t\t\t\ttemp1 = A[i];\n\t\t\t}\n\t\t\telse if (temp1 > A[i])\n\t\t\t{\n\t\t\t\ttemp1 = A[i];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (pos[A[i]] != i)\n\t\t{\n\t\t\tif (temp2 == -1)\n\t\t\t{\n\t\t\t\ttemp2 = A[i];\n\t\t\t}\n\t\t\telse if (temp2 > A[i])\n\t\t\t{\n\t\t\t\ttemp2 = pos[A[i]];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (temp1 != -1 && temp2 != -1 && temp1 < temp2)\n\t{\n\t\t//printf(\"temp1:%d pos:%d temp2:%d pos:%d\\n\", temp1, dupPos[temp1], temp2, dupPos[temp2]);\n\t\tint temp = dupPos[temp1];\n\t\tdupPos[temp1] = dupPos[temp2];\n\t\tdupPos[temp2] = temp;\n\t}\n\n\tint cost1 = 0, cost2 = 0;\n\t{\n\t\tint i = 0;\n\n\t\twhile (i < N)\n\t\t{\n\t\t\tif (pos[A[i]] != i)\n\t\t\t{\n\t\t\t\tcost1 += (A[i] + A[pos[A[i]]]);\n\t\t\t\tint temp = pos[A[i]];\n\t\t\t\tpos[A[i]] = pos[A[temp]];\n\t\t\t\tpos[A[temp]] = temp;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tint i = 0;\n\n\t\twhile (i < N)\n\t\t{\n\t\t\tif (dupPos[A[i]] != i)\n\t\t\t{\n\t\t\t\tcost2 += (A[i] + A[dupPos[A[i]]]);\n\t\t\t\tint temp = dupPos[A[i]];\n\t\t\t\tdupPos[A[i]] = dupPos[A[temp]];\n\t\t\t\tdupPos[A[temp]] = temp;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << (min(cost1, cost2)) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define FOR(i, s, e) for(int i = s; i < e; ++i)\n#define FOR_M(i, s, e) for(int i = s; i >= e; --i)\nusing namespace std;\nstruct Data\n{\n\tData() :w(0), i(0){}\n\tint w;\n\tint i;\n};\nstruct DataComparator\n{\n\tbool operator()(const Data* d1, const Data* d2)\n\t{\n\t\treturn (d1->w < d2->w);\n\t}\n};\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<Data*> vD, vW;\n\tvD.reserve(n);\n\tFOR(i, 0, n){\n\t\tData* d = new Data();\n\t\tcin >> d->w;\n\t\td->i = i;\n\t\tvD.push_back(d);\n\t}\n\tvW = vD;\n\tsort(vW.begin(), vW.end(), DataComparator());\n\tint c = 0;\n\tFOR_M(i, n - 1, 0){\n\t\tif (i == vW[i]->i)\n\t\t\tcontinue;\n\t\tc += vD[i]->w + vD[vW[i]->i]->w;\n\t\tswap(vD[i]->i, vD[vW[i]->i]->i);\n\t\tswap(vD[i], vD[vW[i]->i]);\n\t}\n\tcout << c << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define MAX_N 10000\n#define MAX_V 60000000\n#define INF 10000000000\n\nint n, A[MAX_N], s, B[MAX_N], T[MAX_V], cur, S, m, x; bool V[MAX_N];\n\nint minimum_cost_sort() {\n\tint ans = 0;\n\tfor (int i = 0; i < MAX_V; i++) { V[i] = false; }\n\tfor (int i = 0; i < n; i++) { B[i] = A[i]; }\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; i++) { T[B[i]] = i; }\n\tfor (int i = 0; i < n; i++) {\n\t\tif (V[i] == true) { goto owata; }\n\t\tcur = i;\n\t\tS = 0;\n\t\tm = INF;\n\t\tx = 0;\n\t\twhile (1) {\n\t\t\tV[cur] = true;\n\t\t\tx++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif (V[cur]) { break; }\n\t\t}\n\t\tans += min(S + (x - 2)*m, m + S + (x + 1)*s);\n\towata:;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tcin >> n;\n\ts = INF;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tcout << minimum_cost_sort() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define int(x) int x; scanf(\"%d\",&x)\n#define input(x) scanf(\"%d\",&x)\n#define rep(x,n) for(int x = 0; x < n; x++)\n#define _br printf(\"\\n\")\n#define INF 2000000000\n\nint A[1000],SortA[1000],Type[1000],NoT[1000] = {},NNot = 0;\n\n//sum,min\nint Typesum_min[1000][2];\nbool Complete[1000] = {};\nint MIN;\n\nvoid typing(int type, int iro){\n    while (!Complete[type]) {\n        Type[type] = iro;\n        Typesum_min[iro][0] += A[type];\n        if (Typesum_min[iro][1] > A[type]) {\n            Typesum_min[iro][1] = A[type];\n        }\n        NoT[iro]++;\n        Complete[type] = true;\n        \n        type = SortA[type];\n    }\n}\n\nvoid DecideType(int n){\n    int T = 0;\n    rep(i,n){\n        if (!Complete[i]) {\n            typing(i,T);\n            Typesum_min[i][0] -= Typesum_min[i][1];\n            NNot++;\n            T++;\n        }\n    }\n}\n\nvoid solve(){\n    int SSum = 0;\n    rep(i,NNot){\n        if(NoT[i] == 1){\n            \n        }else if(MIN*(NoT[i]-1)+2*(Typesum_min[i][1] + MIN) >= Typesum_min[i][1]*(NoT[i]-1)) {\n            SSum += Typesum_min[i][0] + Typesum_min[i][1]*(NoT[i]-1);\n        }else{\n            SSum += Typesum_min[i][0] + MIN*(NoT[i]-1)+2*(Typesum_min[i][1] + MIN);\n        }\n    }\n    printf(\"%d\\n\",SSum);\n}\n\nint main(){\n    priority_queue<pair<int,int> > PQ;\n    int(n);\n    rep(i,n){\n        input(A[i]);\n        PQ.push(make_pair(-A[i],i));\n        Typesum_min[i][0] = 0;\n        Typesum_min[i][1] = INF;\n    }\n    rep(i,n){\n        SortA[i] = PQ.top().second;\n        PQ.pop();\n    }\n    MIN = A[SortA[0]];\n    DecideType(n);\n    \n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <tuple>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n#define square(x) (x) * (x)\n#define cube(x) (x) * (x) * (x)\n\nconst int INF = 1e9;\n\nusing namespace std;\n\nbool stable = true;\n\nint main() {\n    int n;\n    int cost = 0;\n    cin >> n;\n    vector<int> a(n);\n    REP(i, n) cin >> a[i];\n    auto p = a.end();\n    for(int max = n-1; max > 0; max--){\n        int max_index = max_element(a.begin(), p) - a.begin();\n        if(max_index != max){\n            swap(a[max_index], a[max]);\n            cost += a[max_index] + a[max];\n        }\n        p--;\n    }\n    cout << cost << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass UnionFind {\n\tvector<int> v;\n\tvector<int> mini;\npublic:\n\tUnionFind(const vector<int>& val) : v(val.size(), -1), mini(val) {}\n\tint find(int a) {\n\t\treturn v[a] < 0 ? a : v[a] = find(v[a]);\n\t}\n\tbool same(int a, int b) {\n\t\treturn find(a) == find(b);\n\t}\n\tvoid unite(int a, int b) {\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif (a == b) return;\n\t\tif (v[a] < v[b]) {\n\t\t\tmini[a] = min(mini[a], mini[b]);\n\t\t\tv[a] += v[b];\n\t\t\tv[b] = a;\n\t\t}\n\t\telse {\n\t\t\tmini[b] = min(mini[a], mini[b]);\n\t\t\tv[b] += v[a];\n\t\t\tv[a] = b;\n\t\t}\n\t}\n\tint get(int a) {\n\t\treturn mini[find(a)];\n\t}\n\tint size(int a) {\n\t\treturn -v[find(a)];\n\t}\n};\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<int> w(n);\n\tint mini = 1e4 + 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> w[i];\n\t\tmini = min(mini, w[i]);\n\t}\n\tauto a = w;\n\tsort(a.begin(), a.end());\n\tUnionFind uf(w);\n\tfor (int i = 0; i < n; i++) {\n\t\tint it = lower_bound(a.begin(), a.end(), w[i]) - a.begin();\n\t\tuf.unite(i, it);\n\t}\n\tint res = 0;\n\tvector<int> rts;\n\tfor (int i = 0; i < n; i++) {\n\t\tres += w[i] + (uf.get(i) == w[i] ? -w[i] : uf.get(i));\n\t\tif (i == uf.find(i)) rts.push_back(i);\n\t}\n\tfor (auto rt : rts) {\n\t\tif (uf.get(rt) == mini) continue;\n\t\tint dis = (uf.get(rt) - mini) * (uf.size(rt) - 1) - (uf.get(rt) + mini) * 2;\n\t\tif (dis > 0) {\n\t\t\tres -= dis;\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\tint n, c = 0;\n\tint a[1000], b[1000];\n\tbool f[1000];\n\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\n\tmemcpy(b, a, sizeof(a));\n\tsort(b, b + n);\n\tmemset(f, 0, sizeof(f));\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] == b[i])\n\t\t\tf[i] = 1;\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (f[i] == 0){\n\t\t\tint s = 0;\n\t\t\twhile (a[i] != b[i]) {\n\t\t\t\tint j = i, k = i;\n\t\t\t\twhile (f[j] == 1 || a[j] != b[i])\n\t\t\t\t\tj++;\n\t\t\t\twhile (f[k] == 1 || a[k] != b[j])\n\t\t\t\t\tk++;\n\t\t\t\tswap(a[j], a[k]);\n\t\t\t\tc += a[j] + a[k];\n\t\t\t\tf[j] = 1;\n\t\t\t\ts++;\n\t\t\t}\n\t\t\tif ((s - 2) * b[i] > (s + 2) * b[0])\n\t\t\t\tc -= (s - 2) * b[i] - (s + 2) * b[0];\n\t\t\tf[i] = 1;\n\t\t}\n\t}\n\n\tcout << c << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\n\t// step #1. input\n\tint N;\n\tcin >> N;\n\tvector<int> w(N);\n\tfor(int i = 0; i < N; ++i) {\n\t\tcin >> w[i];\n\t}\n\t// step #2. make functional graph\n\tvector<int> p(N);\n\tfor(int i = 0; i < N; ++i) {\n\t\tp[i] = i;\n\t}\n\tsort(p.begin(), p.end(), [&](int i, int j) { return w[i] < w[j]; });\n\t// step #3. calculate minimum cost\n\tint lightest = w[p[0]];\n\tvector<bool> vis(N, false);\n\tint ans = 0;\n\tfor(int i = 0; i < N; ++i) {\n\t\tif(vis[i]) continue;\n\t\tint pos = i, sum = 0, sz = 0, sublight = w[pos];\n\t\twhile(!vis[pos]) {\n\t\t\tsublight = min(sublight, w[pos]);\n\t\t\tsum += w[pos];\n\t\t\t++sz;\n\t\t\tvis[pos] = true;\n\t\t\tpos = p[pos];\n\t\t}\n\t\tint costA = sum + sublight * (sz - 2);\n\t\tint costB = sum + sublight + lightest * (sz + 1);\n\t\tans += min(costA, costB);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\n\nint B[MAX], T[VMAX + 1];\n\nint slove() {\n    int ans = 0;\n    bool V[MAX];\n\n    for (int i = 0; i < n; i++) {\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B, B + n);\n    for (int i = 0; i < n; i++) {\n        T[B[i]] = i;\n    }\n    for (int i = 0; i < n; i++) {\n        if (V[i]) continue;\n\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while (true) {\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m, v);\n            S += v;\n            cur = T[v];\n            if (V[cur]) break;\n        }\n        ans+=min(S+(an-2)*m,m+S+(an+1)*s);\n    }\n    return ans;\n}\n\nint main() {\n    cin >> n;\n    s = VMAX;\n    for (int i = 0; i < n; i++) {\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n\n    int ans = slove();\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nint W[1111];\nint U[1111];\nint main(){\n  cin >> N;  \n  for(int i=0;i<N;i++){\n    cin >> W[i]; U[i] = W[i];\n  }\n  sort(W,W+N);\n  int res = 0;\n  for(int i=0;i<N;i++){\n    if( W[i] == U[i] ) continue;\n    for(int j=i+1;j<N;j++){\n      if( W[i] == U[j] ){\n        swap(U[i],U[j]); res += U[i] + U[j];\n        break;\n      }\n    }\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<ll, ll> pll;\n\n#define FOR(i, n, m) for(ll (i)=(m);(i)<(n);++(i))\n#define REP(i, n) FOR(i,n,0)\n#define OF64 std::setprecision(10)\n\nconst ll MOD = 1000000007;\nconst ll INF = (ll) 1e15;\n\nll A[1005];\nll B[1005];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N;\n    cin >> N;\n    REP(i, N) {\n        cin >> A[i];\n        B[i] = A[i];\n    }\n    sort(B, B + N);\n    ll index = -1;\n    REP(i, N) {\n        if (A[i] == B[i])\n            continue;\n        if (index < 0 || A[index] > A[i])\n            index = i;\n    }\n\n    ll ans = 0;\n    if (index >= 0) {\n        while (true) {\n            ll cnt = 0;\n            while (A[index] != B[index]) {\n                REP(i, N) {\n                    if (B[index] == A[i]) {\n                        ans += A[i];\n                        cnt++;\n                        swap(A[index], A[i]);\n                        index = i;\n                        break;\n                    }\n                }\n            }\n\n            ans += std::min(A[index] * cnt, B[0] * cnt + 2 * (B[0] + A[index]));\n\n            index = -1;\n            REP(i, N) {\n                if (A[i] == B[i])\n                    continue;\n                if (index < 0 || A[index] > A[i])\n                    index = i;\n            }\n            if (index < 0)\n                break;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <unordered_map>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nnamespace std{\n\ttemplate<typename T>\n\tinline void hash_combine(size_t& seed, T const& v){\n\t\tseed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n\t}\n    template<typename It>\n    inline size_t hash_range(It first, It last){\n\t\tsize_t seed=0;\n\t\thash_range(seed,first,last);\n\t\treturn seed;\n\t}\n\ttemplate<typename It>\n\tinline void hash_range(size_t& seed, It first, It last){\n\t\tfor(;first!=last;++first)hash_combine(seed, *first);\n\t}\n\ttemplate<typename A,typename B>\n\tclass hash<pair<A,B>>{\n\t\tpublic:\n\t\tsize_t operator()(pair<A,B> const &p) const{\n\t\t\tsize_t seed=0;\n\t\t\thash_combine(seed,p.first);\n\t\t\thash_combine(seed,p.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\ttemplate<typename T,size_t N>\n\tclass hash<array<T,N>>{\n\t\tpublic:\n\t\tsize_t operator()(array<T,N> const &container) const{\n\t\t\treturn hash_range(container.begin(),container.end());\n\t\t}\n\t};\n\ttemplate<typename T,typename A>\n\tclass hash<vector<T,A>>{\n\t\tpublic:\n\t\tsize_t operator()(vector<T,A> const &container) const{\n\t\t\treturn hash_range(container.begin(),container.end());\n\t\t}\n\t};\n}\n\nint main(){\n\tint N;\n\tscanf(\"%d\",&N);\n\tvector<char>v(N);\n\tfor(int i=0;i<N;i++)scanf(\"%d\",&v[i]);\n\tpriority_queue<pair<int,vector<char> > >q;\n\tunordered_map<vector<char>,int>depth;\n\n\tq.push(make_pair(0,v));\n\tint R;\n\tfor(;!q.empty();){\n\t\tauto cur=q.top();\n\t\tq.pop();\n\t\tif(depth.find(cur.second)!=depth.end())continue;\n\t\tdepth[cur.second]=cur.first;\n\t\tbool f=false;\n\t\tfor(int i=0;i<N-1;i++)for(int j=i+1;j<N;j++)/*if(&&cur.second[i]>cur.second[j])*/{\n\t\t\tif(i<j)f=true;\n\t\t\tswap(cur.second[i],cur.second[j]);\n\t\t\tif(depth.find(cur.second)==depth.end())q.push(make_pair(cur.first-cur.second[i]-cur.second[j],cur.second));\n\t\t\tswap(cur.second[i],cur.second[j]);\n\t\t}\n\t\tif(!f){\n\t\t\tR=-cur.first;\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",R);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\ntypedef std::vector<int> TList;\nvoid CountingSort(const TList& A, TList& B, int k)\n{\n    std::vector<int> C(k+1, 0);\n    \n    /* C[i] ??? i ???????????°????¨?????????? */\n    for(int j = 0; j < A.size(); ++j){\n        C[A[j]]++;\n    }\n    \n    /* C[i] ??? i ??\\????????°???????????°????¨??????????*/\n    for(int i = 1; i <= k; ++i){\n        C[i] = C[i] + C[i-1];\n    }\n\n    for(int j = 0; j < A.size(); ++j){\n        B[C[A[j]]-1] = A[j];\n        C[A[j]]--;\n    }\n}\nint GetCost(const TList& Source, const TList& Sorted)\n{\n    int Cost = 0;\n    assert(Source.size() == Sorted.size());\n    TList List = Source;\n    for(int i = (int)Sorted.size() - 1; i >= 0; --i){\n        TList::iterator It = std::find(List.begin(), List.end(), Sorted.at(i));\n        assert(It != List.end());\n        if(std::distance(List.begin(), It) == i) continue;\n        Cost += *It + *(List.begin() + i);\n        std::swap(*It, *(List.begin() + i));\n    }\n    return Cost;\n}\nint main()\n{\n    int n;\n    std::cin >> n;\n    std::vector<int> A(n);\n    for(int i = 0; i < n; ++i){\n        std::cin >> A[i];\n    }\n    int k = *std::max_element(A.begin(), A.end());\n    std::vector<int> B(n);\n    CountingSort(A, B, k);\n\n    std::cout << GetCost(A, B) << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<stdlib.h>\n#include<cstdio>\n#include<stdio.h>\n#include<set>\n#include<map>\n#include<deque>\n#include<stack>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<sstream>\n#include<fstream>\n#include<time.h>\nusing namespace std;\nconst int maxn = 1010;\nint a[maxn], id[maxn], pos[maxn];\ninline bool cmp(int x, int y) { return a[x] < a[y]; }\nint main()\n{\n\tint n;long long ans = 0;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1;i <= n;i++)\n\t{\n\t\tscanf(\"%d\", a + i);\n\t\tid[i] = i;\n\t}\n\tsort(id + 1, id + 1 + n,cmp);\n\tfor (int i = 1;i <= n;i++)pos[id[i]] = i;\n\tfor (int i = n;i;i--)\n\t{\n\t\tif (id[i] != i)\n\t\t\tans = ans + a[id[i]] + a[i];\n\t\tid[pos[i]] = id[i];\n\t\tpos[id[pos[i]]] = pos[i];\n\t\tswap(pos[i], pos[id[pos[i]]]);\n\t\tid[i] = i;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n \n/* attention\n    long longのシフト演算には気をつけよう\n    タイポした時のデバッグが死ぬほどきつくなるので変数名は最低3字くらい使った方がいいかも\n    sizeは(int)とキャストしよう\n    ごちゃごちゃ場合分けを考える前に全探索は考えましたか？\n*/\n\n\nconst int MAX = 1000;\nconst int VMAX = 10000;\n\nint n, A[MAX], s; // s 全体の中での最小値\nint B[MAX], T[VMAX+1];\n\nint solve(){\n    int ans = 0;\n\n    bool seen[MAX];\n    for(int i=0; i<n; ++i){\n        B[i] = A[i];\n        seen[i] = false;\n    }\n    sort(B, B+n);\n    for(int i=0; i<n; ++i) T[B[i]] = i;\n    for(int i=0; i<n; ++i){\n        if(seen[i]) continue;\n\n        int cur = i;\n        int S = 0; // S:= サイクル内の重さの和\n        int m = VMAX; // m := サイクル内の重さの最小値\n        int an = 0; // an := サイクルの要素数\n\n        while(1){\n            seen[cur] = true;\n            ++an;\n            int v = A[cur];\n            m = min(m, v);\n            S += v;\n            cur = T[v];\n            if(seen[cur]) break;\n        }\n\n        ans += min(S+(an-2)*m, m+S+(an+1)*s);\n    }\n\n    return ans;\n}\n\nint main(){\n    cin >> n;\n    s = VMAX;\n    for(int i=0; i<n; ++i){\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n    int ans = solve();\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <unordered_map>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nnamespace std{\n\ttemplate<typename T>\n\tinline void hash_combine(size_t& seed, T const& v){\n\t\tseed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n\t}\n    template<typename It>\n    inline size_t hash_range(It first, It last){\n\t\tsize_t seed=0;\n\t\thash_range(seed,first,last);\n\t\treturn seed;\n\t}\n\ttemplate<typename It>\n\tinline void hash_range(size_t& seed, It first, It last){\n\t\tfor(;first!=last;++first)hash_combine(seed, *first);\n\t}\n\ttemplate<typename A,typename B>\n\tclass hash<pair<A,B>>{\n\t\tpublic:\n\t\tsize_t operator()(pair<A,B> const &p) const{\n\t\t\tsize_t seed=0;\n\t\t\thash_combine(seed,p.first);\n\t\t\thash_combine(seed,p.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\ttemplate<typename T,size_t N>\n\tclass hash<array<T,N>>{\n\t\tpublic:\n\t\tsize_t operator()(array<T,N> const &container) const{\n\t\t\treturn hash_range(container.begin(),container.end());\n\t\t}\n\t};\n\ttemplate<typename T,typename A>\n\tclass hash<vector<T,A>>{\n\t\tpublic:\n\t\tsize_t operator()(vector<T,A> const &container) const{\n\t\t\treturn hash_range(container.begin(),container.end());\n\t\t}\n\t};\n}\n\nint main(){\n\tint N;\n\tscanf(\"%d\",&N);\n\tvector<short>v(N);\n\tfor(int i=0;i<N;i++)scanf(\"%d\",&v[i]);\n\tpriority_queue<pair<int,vector<short> > >q;\n\tunordered_map<vector<short>,int>depth;\n\n\tq.push(make_pair(0,v));\n\tint R;\n\tfor(;!q.empty();){\n\t\tpair<int,vector<short> >cur=q.top();\n\t\tq.pop();\n\t\tif(depth.find(cur.second)!=depth.end())continue;\n\t\tdepth[cur.second]=cur.first;\n\t\tbool f=false;\n\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++)if(i!=j&&cur.second[i]>cur.second[j]){\n\t\t\tif(i<j)f=true;\n\t\t\tswap(cur.second[i],cur.second[j]);\n\t\t\tq.push(make_pair(cur.first-cur.second[i]-cur.second[j],cur.second));\n\t\t\tswap(cur.second[i],cur.second[j]);\n\t\t}\n\t\tif(!f){\n\t\t\tR=-cur.first;\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",R);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <climits>\nusing namespace  std;\n\nstruct StCst\n{\n  int m_nNo;\n  int m_nSeq;\n  bool m_bDone;\n\n  static bool AsdNo(const StCst &cnroLeft, const StCst &cnroRight) \n  { return cnroLeft.m_nNo < cnroRight.m_nNo; }\n};\n\nvoid fnInput(vector<StCst> &rvoSort)\n{\n  int nMaxSiz, nCnt = 0;\n  cin >> nMaxSiz;\n\n  rvoSort.resize(nMaxSiz);\n  for (int i = 0; i < nMaxSiz; i++)\n  {\n    cin >> rvoSort[i].m_nNo;\n    rvoSort[i].m_nSeq = nCnt++;\n  }\n}\n\nvoid fnMinCostSort(vector<StCst> &rvoSort, int &rnSwpCnt)\n{\n  sort(begin(rvoSort), end(rvoSort), StCst::AsdNo);\n  int nMinNo = rvoSort[0].m_nNo;\n\n  int nCost;\n  for (int i = 0; i < rvoSort.size(); i++)\n  {\n    if (rvoSort[i].m_bDone)  continue;\n\n    int nTotal  = rvoSort[i].m_nNo;\n    int nCurMin = rvoSort[i].m_nNo; \n    int nCurSize = 1;\n    rvoSort[i].m_bDone = true;\n\n    int j = rvoSort[i].m_nSeq;\n    while  (rvoSort[j].m_nNo != rvoSort[i].m_nNo)\n    {\n      nTotal += rvoSort[j].m_nNo;\n      nCurSize++;\n      rvoSort[j].m_bDone = true;\n      j = rvoSort[j].m_nSeq;\n    }\n\n    if (nCurSize == 1)\n        nCost = 0;\n    else\n        nCost = min(nTotal + (nCurSize - 2) * nCurMin, \n                    nTotal + nCurMin + (nCurSize + 1) * nMinNo);\n    rnSwpCnt += nCost;\n  }\n}\n\nvoid fnResult(int nSwpCnt)\n{\n  cout << nSwpCnt << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  vector<StCst> voSort;\n\n  fnInput(voSort);\n\n  int nSwpCnt = 0;\n  fnMinCostSort(voSort, nSwpCnt);\n\n  fnResult(nSwpCnt);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//????????°???????????°????????????????????\\??????????????¢?????´???????????¨??????????§???? P181-182(Google Books?????¬?????\\???)?????????.\n\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint do_cycle(vector<int> &v,int x){\n\tint s=0,m=1<<30;\n\tfor(auto &e:v)s+=e,m=min(m,e);\n\treturn min(s+(v.size()-2)*m,s+m+(v.size()+1)*x);\n}\n\nint main(){\n\tint N,x=1<<30,r=0;\n\tscanf(\"%d\",&N);\n\tvector<int>v(N),b(N),se(N);\n\tmap<int,int>m;\n\tvector<vector<int> >cycles;\n\tfor(int i=0;i<N;i++)scanf(\"%d\",&v[i]),x=min(x,v[i]),se[i]=v[i];\n\tsort(se.begin(),se.end());\n\tint i=0;for(auto &e:se){m[e]=i++;}\n\tfor(int i=0;i<N;i++)if(!b[i]){\n\t\tvector<int>cycle;\n\t\tint k=i;\n\t\tdo{\n\t\t\tcycle.push_back(se[k]);\n\t\t\tb[k]=1;\n\t\t\tk=m[v[k]];\n\t\t}while(k!=i);\n\t\tr+=do_cycle(cycle,x);\n\t}\n\tprintf(\"%d\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define fordebug int hoge;cin>>hoge;\n#define DEKAI 1000000007;\n#define INF 200000000\n#define int long long\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,j,n) for(int i=j;i<n;i++)\npair<int,char> a[100000],b[100000];\npair<int,char> rr[100000],ll[100000];\n\nsigned main(){\n\tint n;\n\tcin>>n;\n\tint a[1000],b[1000];\n\tint mini=INF;\n\tlp(i,n){\n\t\tcin>>a[i];\n\t\tb[i]=a[i];\n\t\tmini=min(mini,a[i]);\n\t}\n\tsort(b,b+n);\n\tint x[100000];\n\tlp(i,n){\n\t\tx[b[i]]=i;\n\t}\n\tint ans=0;\n\tbool done[1000]={false};\n\tlp(i,n){\n\t\tif(done[i]||a[i]==b[i]) continue;\n\t\tint sum=0,mini2=INF;\n\t\tint count=0;\n\t\tint j=i;\n\t\twhile(!done[j]){\n\t\t\tmini2=min(mini2,a[j]);\n\t\t\tsum+=a[j];\n\t\t\tdone[j]=true;\n\t\t\tj=x[a[j]];\n\t\t\tcount++;\n\t\t}\n\t\tint memo=sum;\n\t\tsum=sum-mini2+mini*(count-1);\n\t\tmemo=memo+mini2+mini-2+mini*(count-1);\n\t\tans+=min(sum,memo);\n\t}\n\tcout<<ans+1<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint solve() {\n    int ans = 0;\n\n    bool V[MAX];\n    for ( int i = 0; i < n; i++) {\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B, B+n);\n    for (int i=0; i<n; i++) T[B[i]] = i;\n    for (int i=0; i<n; i++) {\n        if (V[i]) continue;\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while (1) {\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m, v);\n            S += v;\n            cur = T[v];\n            if (V[cur]) break;\n        }\n        ans += min(S+(an-2)*m, m+S+(an+1)*s);\n    }\n    return ans;\n}\n\nint main() {\n    cin >> n;\n    s = VMAX;\n    for ( int i=0; i<n; i++) {\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n    int ans = solve();\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define N 40\n\nbool comp1(const pair<int, int> &a, const pair<int, int> &b)\n{\n    return a.first < b.first;\n}\nbool comp2(const pair<int, int> &a, const pair<int, int> &b)\n{\n    return a.second < b.second;\n}\nint main()\n{\n    int n;\n    cin >> n;\n    int w[n], x[n];\n    for (int i = 0; i < n; i++)\n    {\n        cin >> w[i];\n        x[i] = w[i];\n    }\n\n    sort(x, x + n);\n\n    int *p, *q;\n    int sum = 0, tmp;\n \n    for (int i = 0; i < n; i++)\n    {\n        p = find(w, w + n, x[i]);\n        while (i != p - w)\n        {\n            q = find(w, w + n, x[p - w]);\n            tmp = *p;\n            *p = *q;\n            *q = tmp;\n            sum += *p + *q;\n            p = q;\n        }\n    }\n\n    cout << sum << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve() {\n    int ans = 0;\n\n    bool V[MAX];\n    for (int i = 0; i < n; ++i) {\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B, B + n);\n    for (int i = 0; i < n; ++i) {\n        T[B[i]] = i;\n    }\n    for (int i = 0; i < n; ++i) {\n        if (V[i]) {\n            continue;\n        }\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while (true) {\n            V[cur] = true;\n            ++an;\n            int v = A[cur];\n            m = min(m, v);\n            S += v;\n            cur = T[v];\n            if (V[cur]) {\n                break;\n            }\n        }\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n    }\n    \n    return ans;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    s = VMAX;\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &A[i]);\n        s = min(s, A[i]);\n    }\n    int ans = solve();\n    printf(\"%d\\n\", ans);    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define FOR(i, s, e) for(int i = s; i < e; ++i)\nusing namespace std;\nstruct Data\n{\n\tData() :w(0), i(0){}\n\tint w;\n\tint i;\n};\nstruct DataComparator\n{\n\tbool operator()(const Data* d1, const Data* d2)\n\t{\n\t\treturn (d1->w < d2->w);\n\t}\n};\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<Data*> vD, vW;\n\tvD.reserve(n);\n\tFOR(i, 0, n){\n\t\tData* d = new Data();\n\t\tcin >> d->w;\n\t\td->i = i;\n\t\tvD.push_back(d);\n\t}\n\tvW = vD;\n\tsort(vW.begin(), vW.end(), DataComparator());\n\tint c = 0, j = 0;\n\tint from, to;\n\twhile(j < n){\n\t\tto = vW[j]->i;\n\t\tfrom = vW[to]->i;\n\t\tif (to == from){\n\t\t\t++j;\n\t\t\tcontinue;\n\t\t}\n\t\tc += vD[to]->w + vD[from]->w;\n\t\tswap(vD[to], vD[from]);\n\t\tvD[to]->i = to;\n\t\tvD[from]->i = from;\n\t}\n\tcout << c << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n \nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n \nint solve() {\n  int ans = 0;\n \n  bool V[MAX];\n  for ( int i = 0; i < n; i++ ) {\n    B[i] = A[i];\n    V[i] = false;\n  }\n  sort(B, B + n);\n  for ( int i = 0; i < n; i++ ) T[B[i]] = i;\n  for ( int i = 0; i < n; i++ ) {\n    if ( V[i] ) continue;\n    int cur = i;\n    int S = 0;\n    int m = VMAX;\n    int an = 0;\n    while ( 1 ) {\n      V[cur] = true;\n      an++;\n      int v = A[cur];\n      m = min(m, v);\n      S += v;\n      cur = T[v];\n      if ( V[cur] ) break;\n    }\n    ans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n  }\n  return ans;\n}\n \nint main() {\n  cin >> n;\n  s = VMAX;\n  for ( int i = 0; i < n; i++ ) {\n    cin >> A[i];\n    s = min(s, A[i]);\n  }\n  int ans = solve();\n  cout << ans << endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\n#define MAX_N (1010)\n#define MAX_W (10010)\ntypedef long long ll;\n\nint CountingSort( int A[], int B[] );\n\nint A[MAX_N];\nint B[MAX_N];\nint C[MAX_W + 1];\nbool used[MAX_N];\nint n;\n\nint main()\n{\n    ll ans = 0;\n    int min_v = MAX_W;\n    scanf(\"%d\", &n);\n\n    for ( int i = 0; i < n; i++ ) {\n\tscanf(\"%d\", &A[i]);\n\tmin_v = min( min_v, A[i] );\n    }\n\n    CountingSort( A, B );\n\n    for ( int i = 0; i < n; i++ ) {\n\tif ( !used[i] ) {\n\t    int cur_i = i;\n\t    int part_min_v = MAX_W;\n\t    ll sum_w = 0;\n\t    int num = 0;\n\t    ll v0, v1;\n\n\t    while ( true ) {\n\t\tif ( used[cur_i] ) break;\n\t\tused[cur_i] = true;\n\t\tnum++;\n\t\tpart_min_v = min( part_min_v, A[cur_i] );\n\t\tsum_w += A[cur_i];\n\t\tcur_i = C[A[cur_i]];\n\t    }\n\n\t    v0 = sum_w + ( num - 2 ) * part_min_v;\n\t    v1 = sum_w + part_min_v + ( num + 1 ) * min_v;\n\n\t    ans += min( v0, v1 );\n\t}\n    }\n\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}\n\n\nint CountingSort( int A[], int B[] )\n{\n    for ( int i = 0; i < n; i++ ) {\n\tC[A[i]]++;\n    }\n\n    for ( int i = 1; i < MAX_W; i++ ) {\n\tC[i] = C[i] + C[i-1];\n    }\n\n    for ( int i = n-1; i >= 0; i-- ) {\n\tB[C[A[i]] - 1] = A[i];\n\tC[A[i]]--;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n//#define int long long\n\n#define upper(n,m) (n+m-1)/m\n#define rounding(n) (int)((double)n+0.5)\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define REAP(i,a,n) for(int i=(a);i<(n);i++)\n#define ALL(a) a.begin(),a.end()\n\n#define coutALL(i,a) {int i=0;for(int e:a) cout<<(i++?\" \":\"\")<<e; cout<<endl;}\n#define coutYN(a) cout<<(a?\"Yes\":\"No\")<<endl;\n#define coutyn(a) cout<<(a?\"yes\":\"no\")<<endl;\n\n#define deb cout<<\"debug\"<<endl\n#define debn(n) cout<<\"debug: \"<<n<<endl\n\nconst int INF=INT_MAX;\nconst int MOD=(int)1e9+7;\nconst double EPS=1e-12;\n//const int dx[]={0,1,0,-1},dy[]={-1,0,1,0};\nconst int dx[]={-1,-1,-1,0,1,1,1,0},dy[]={-1,0,1,1,1,0,-1,-1};\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef long long LL;\n\nsigned main(){\n\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin>>n;\n\n  int flag[1000]={};\n  int where[10010]={};\n  vector <int> a(n),sorted_a;\n  REP(i,n) cin>>a[i],where[a[i]]=i;\n\n  sorted_a=a;\n  sort(ALL(sorted_a));\n\n  vector<vector<int>> cost_list;\n\n  REP(i,n){\n\n    if(flag[i]) continue;\n\n    int now=i;\n    vector <int> cost;\n\n    for(;!flag[now];){\n\n      cost.pb(a[now]);\n      flag[now]=1;\n      now=where[sorted_a[now]];\n\n    }\n\n    cost_list.pb(cost);\n\n  }\n\n  int ans=0,min_a=sorted_a[0];\n\n  for(auto e:cost_list){\n\n    int r1=accumulate(ALL(e),0)+(e.size()-2)**min_element(ALL(e));\n    int r2=accumulate(ALL(e),0)+*min_element(ALL(e))+(e.size()+1)*min_a;\n\n    ans+=min(r1,r2);\n\n  }\n\n  cout<<ans<<endl;\n\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdint.h>\n#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <climits>\nusing namespace std;\n\n#define DEBUG (0)\n\n#if DEBUG\n#define DPRINTF(...) do { \\\n    printf(\"D(L%d) %s: \", __LINE__, __func__); \\\n    printf(__VA_ARGS__); \\\n  } while (false)\n#else\n#define DPRINTF(...)\n#endif // DEBUG\n\nint g_cost = 0;\n\nvoid swap(int array[], int i0, int i1)\n{\n  int temp = array[i1];\n  array[i1] = array[i0];\n  array[i0] = temp;\n}\n\nvoid selectionSort(int array[], int start, int end)\n{\n  for (int i = start; i < end - 1; i++)\n  {\n\n    int min = array[i];\n    int minIdx = i;\n\n    for (int j = i + 1; j < end; j++)\n    {\n      if (min > array[j])\n      {\n        min = array[j];\n        minIdx = j;\n      }\n    }\n\n    if (minIdx != i)\n    {\n      DPRINTF(\"swap array[%d] (%d) and array[%d] (%d)\\n\",\n          i, array[i], minIdx, array[minIdx]);\n      swap(array, i, minIdx);\n      g_cost += array[i] + array[minIdx];\n    }\n  }\n}\n\nint main()\n{\n  int numOfArray;\n  cin >> numOfArray; cin.ignore();\n\n  int array[numOfArray];\n  for (int i = 0; i < numOfArray; i++)\n    cin >> array[i];\n\n#if DEBUG\n  for (int i = 0; i < numOfArray; i++)\n    if (i == 0) DPRINTF(\"%d\", array[i]);\n    else        printf(\" %d\", array[i]);\n  cout << endl;\n#endif // DEBUG\n\n  // selection sort\n  const int start = 0;\n  const int end = numOfArray;\n  selectionSort(array, start, end);\n\n  cout << g_cost << endl;\n\n#if DEBUG\n  for (int i = 0; i < numOfArray; i++)\n    if (i == 0) DPRINTF(\"%d\", array[i]);\n    else        printf(\" %d\", array[i]);\n  cout << endl;\n#endif // DEBUG\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n\nusing namespace std;\n\nconst int MAXN = 1010;\nint w[MAXN];\nbool done[MAXN];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, mini = 100000;\n    cin >> n;\n    map<int, int> mp;\n    for (int i = 0; i < n; i++) {\n        cin >> w[i];\n        mp[w[i]] = 0;\n        mini = min(mini, w[i]);\n    }\n    int k = 0;\n    for (auto& p : mp) p.second = k++;\n    \n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (done[i]) continue;\n        int cnt = 0, now = i, mi = 100000, sum = 0;\n        while (1) {\n            if (done[now]) break;\n            cnt++;\n            done[now] = true;\n            mi = min(mi, w[now]);\n            sum += w[now];\n            now = mp[w[now]];\n        }\n        int tmp = sum+(cnt-2)*mi;\n        tmp = min(tmp, sum+mi+mini*(cnt+1));\n        ans += tmp;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\nusing std::scanf;\nusing std::printf;\n\nconst int kMaxN = 1000;\nconst int kMaxWi = 10000;\n\n// w[i]?????????????????????????????????cycle???????????????????????????remain????????£?????????????¨????\n// ????????????cycle?????????\nint MakeCycle(int w[], int i, int remain[], int cycle[]) {\n  int j = 0;\n  cycle[0] = -1; //?????????while?????????????????????\n  while(w[i] != cycle[0]) {\n    cycle[j] = w[i];\n    ++j;\n    remain[i] = 0;\n    i = w[i] - 1;\n  }\n  return j;\n}\n\nint CompareCosts(int cycle[], int cycle_n, int cycle_min, int w_min) {\n  if (cycle_n == 1) {\n    return 0;\n  } else if (cycle_n == 2) {\n    return cycle[0] + cycle[1];\n  } else {\n    int cycle_sum, i, cost1, cost2;\n    cycle_sum = 0;\n    for (i = 0; i < cycle_n; ++i) { cycle_sum += cycle[i]; }\n    cost1 = cycle_sum + (cycle_n - 2) * cycle_min;\n    cost2 = cycle_sum + cycle_min + (cycle_n + 1) * w_min;\n    return std::min(cost1, cost2);\n  }\n}\n\nint main() {\n  int n, i, j, cycle_n, cycle_min, w_min, cnt;\n  scanf(\"%d\", &n);\n  int w[n], remain[n], cycle[n];\n  for (i = 0; i < n; ++i) { scanf(\"%d\", &w[i]); }\n  w_min = kMaxWi;\n  for (i = 0; i < n; ++i) { w_min = std::min(w_min, w[i]); }\n  for (i = 0; i < n; ++i) { remain[i] = 1; }\n  cnt = 0;\n  for (i = 0; i < n; ++i) {\n    if (remain[i]) {\n      cycle_n = MakeCycle(w, i, remain, cycle);\n      cycle_min = kMaxWi;\n      for (j = 0; j < cycle_n; ++j) { cycle_min = std::min(cycle_min, cycle[j]); }\n      cnt += CompareCosts(cycle, cycle_n, cycle_min, w_min);\n    }\n  }\n  printf(\"%d\\n\", cnt);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\nusing namespace std;\n\n#define REPR(i,n) for(int i=(n); i >= 0; --i)\n#define FOR(i, m, n) for(int i = (m); i < (n); ++i)\n#define REP(i, n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define ALL(a)  (a).begin(),(a).end()\n#define endl \"\\n\"\n\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntypedef long long ll;\n\nvector<int> v,sorted;\nvoid solve() {\n    int n; cin >> n;\n    v.resize(n); sorted.resize(n);\n\n    // value, sorted index\n    map<int,int> mp;\n\n    REP(i,n) {\n        cin >> v[i];\n        sorted[i] = v[i];\n    }\n\n    sort(ALL(sorted));\n    REP(i,n) mp[sorted[i]] = i;\n\n    // find cycle\n    vector<int> used(n);\n\n    ll cost = 0;\n    REP(i,n) {\n        if(used[i]) continue;\n        int target = v[i];\n        used[mp[v[i]]] = true;\n        int seeing = v[mp[v[i]]];\n        int cycle = 1;\n        int minimum_element = target;\n        int sm = target;\n        while (target != seeing) {\n            cycle++;\n            used[mp[seeing]] = true;\n            sm+=seeing;\n            chmin(minimum_element,seeing);\n            seeing = v[mp[seeing]];\n        }\n\n        if(cycle == 1) continue;\n        cost += min(sm + (cycle-2) * minimum_element, sm + minimum_element+ (cycle+1) * sorted[0]);\n    }\n    cout << cost << endl;\n\n\n}\n\nint main() {\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nclass UnionFind {\nprivate:\n\tint height[1000], parent[1000];\n\tint size;\npublic:\n\tUnionFind(int size) : size(size) {\n\t\tfor (int i = 0; i < size; ++i) {\n\t\t\tparent[i] = i;\n\t\t}\n\t\tfill(height, height+size, 0);\n\t}\n\tbool isUnited(int a, int b) {\n\t\treturn root(a) == root(b);\n\t}\n\tint root(int n) {\n\t\tif (n == parent[n]) return n;\n\t\treturn root(parent[n]);\n\t}\n\tvoid unite(int a, int b) {\n\t\ta = root(a), b = root(b);\n\t\tif (height[a] < height[b]) {\n\t\t\tparent[a] = b;\n\t\t}\n\t\telse if (height[a] > height[b]) {\n\t\t\tparent[b] = a;\n\t\t}\n\t\telse {\n\t\t\tparent[b] = a;\n\t\t\theight[b]++;\n\t\t}\n\t}\n};\n\nconst int inf = 1e9;\n\nint main() {\n\tint N; cin >> N;\n\tvector<int> v(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> v[i];\n\t}\n\tmap<int, int> m;\n\tfor (int i = 0; i < N; ++i) {\n\t\tm[v[i]] = i;\n\t}\n\tvector<int> to = v;\n\tsort(to.begin(), to.end());\n\n\tUnionFind uf(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tuf.unite(i, m[to[i]]);\n\t}\n\tmap<int, int> g;\n\tvector<int> sum(N);\n\tvector<int> mn(N, inf);\n\tfor (int i = 0; i < N; ++i) {\n\t\tint id = uf.root(i);\n\t\tsum[id] += v[i];\n\t\tmn[id] = min(mn[id], v[i]);\n\t\tg[id]++;\n\t}\n\tll ans = 0;\n\tfor (const pair<int, int>& p : g) {\n\t\tint i = p.first, n = p.second;\n\t\tans += sum[i]-mn[i] + min(mn[i]*(n-1), (to[0]+mn[i])*2+to[0]*(n-1));\n\t}\n/*\n\tll ans = 0;\n\tfor (int i = N-1; i >= 0; --i) {\n\t\tif (v[i] == to[i]) continue;\n\t\tint j = now[to[i]];\n\t\tswap(v[i], v[j]);\n\t\tnow[v[i]] = j;\n\t\tnow[v[j]] = i;\n\t\tans += v[i]+v[j];\n\t}\n*/\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<map>\n#include<vector>\nint main(void) {\n\tstd::ios_base::sync_with_stdio(false);\n\tint n, input;\n\tstd::cin >> n;\n\tstd::map<int, int>w;\n\tstd::vector<int>vector(n+1,0);\t\n\tfor (int i = 1; i <= n; ++i) {\n\t\tstd::cin >> input;\n\t\tvector[i] = input;\n\t}\n\tstd::vector<int>vector_min= vector;\n\tstd::sort(vector_min.begin(), vector_min.end());\n\tfor (int i = 1; i <= n; ++i) {\n\t\tw[vector[i]] = vector_min[i];\n\t}\n\tstd::map<int, int>w_1(w);\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint temp =0;\n\t\twhile (vector_min[i] != w[vector_min[i]]) {\n\t\t\ttemp += vector_min[i] + w[vector_min[i]] ;\n\t\t\tstd::swap(w[vector_min[i]],w[w[vector_min[i]]] );\n\t\t}\n\t\tint temp_1 = static_cast<int>(1e5);\n\t\tif (i>1&&vector_min[i] != w_1[vector_min[i]]) {\n\t\t\ttemp_1 =  vector_min[i]+ vector_min[1] ;\n\t\t\tstd::swap(w_1[vector_min[i]], w_1[vector_min[1]]);\n\t\t\twhile (vector_min[1] !=w_1[vector_min[1]]) {\n\t\t\t\ttemp_1 += vector_min[1]+ w_1[vector_min[1]] ;\n\t\t\t\tstd::swap(w_1[vector_min[1]], w_1[w_1[vector_min[1]]]); }\n\t\t}\n\t\tcnt += std::min(temp, temp_1);\n\t}\n\tstd::cout << cnt << std::endl;\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\nusing namespace std;\nint main(){\n  int n,ans=0,t[1000],u[1000];\n  bool visited[1000];\n  map<int,int> change;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>t[i];\n    change[t[i]]=i;\n    u[i]=t[i];\n    visited[i]=false;\n  }\n  sort(u,u+n);\n  for(int i=0;i<n;i++){   \n    int w=i,x=0,y=0,z=10000;\n    while(!visited[w]){\n      z=min(z,t[w]);\n      y+=t[w];\n      x++;\n      visited[w]=true;\n      w=change[u[w]];\n    }\n    if(x>=2)ans+=min(y+z+u[0]*(x+1),y+z*(x-2));\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nint n;\nint w[10001];\nint f[10001];\nint edge[10001];\nbool used[10001];\nvector<int> vs;\n\nvoid dfs(int v){\n\tused[v]=true;\n\tvs.push_back(w[v]);\n\tif(!used[edge[v]])dfs(edge[v]);\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&w[i]);\n\t\tf[i]=w[i];\n\t}\n\tsort(f,f+n);\n\tll res=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(f[i]==w[i])edge[i]=i;\n\t\telse edge[i]=lower_bound(f,f+n,w[i])-f;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(edge[i]!=i){\n\t\t\tvs.clear();\n\t\t\tdfs(i);\n\t\t\tint all=vs[0];\n\t\t\tint minx=vs[0];\n\t\t\tfor(int j=1;j<vs.size();j++){\n\t\t\t\tminx=min(minx,vs[j]);\n\t\t\t\tall+=vs[j];\n\t\t\t}\n\t\t\tres+=min(all+(vs.size()-2)*minx,all+(vs.size())*f[0]+minx);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconstexpr int di[] = { 0, 1, 0, -1 }, dj[] = { 1, 0, -1, 0 };\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define repr(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define SORTR(v) sort((v).rbegin(), (v).rend())\n#define all(v) (v).begin(), (v).end()\n#define MAX 200001\n#define vmax 10000\n#define sentinel 2000000000\nconstexpr long long int inf = 1000000000000;\nconstexpr long long int rinf = -(INT64_MAX);\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\n\nint n,a[1000],b[1000],t[10001],s;\n\nint solve(){\n    int ans=0;\n\n    bool V[1000];\n    rep(i,n){\n        b[i]=a[i];\n        V[i]=false;\n    }\n    sort(b,b+n);\n    rep(i,n) t[b[i]]=i;\n    rep(i,n){\n        if(V[i]) continue;\n        int cur=i;\n        int S=0;\n        int m=1000000;\n        int an=0;\n        while(1){\n            V[cur]=true;\n            an++;\n            int v=a[cur];\n            m=min(m,v);\n            S+=v;\n            cur=t[v];\n            if(V[cur]) break;\n        }\n        ans+=min(S+(an-2)*m,m+S+(an+1)*s);\n    }\n    return ans;\n}\n\nint main() {\n    cin>>n;\n    s=100000;\n    rep(i,n){\n        cin>>a[i];\n        s=min(s,a[i]);\n    }\n    int ans=solve();\n    cout<<ans<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <tuple>\n\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n#define square(x) (x) * (x)\n#define cube(x) (x) * (x) * (x)\n\nconst int INF = 1e9;\n\nusing namespace std;\n\nbool stable = true;\n\nint main() {\n    int n;\n    int cost = 0;\n    cin >> n;\n    vector<int> a(n);\n    vector<bool> miss(n);\n    REP(i, n) cin >> a[i];\n    auto b = a;\n    sort(ALL(a));\n    REP(i, n){\n        miss[i] = (a[i] != b[i]);\n    }\n    REP(j, n){\n        for(int i = n - j - 1; i > 0; i--){\n            if(miss[i]){\n                int replace = find(ALL(b), a[i]) - b.begin();\n                if(b[i] == a[replace]){\n                    swap(b[i], b[replace]);\n                    cost += b[i] + b[replace];\n                    miss[i] = false;\n                    miss[replace] = false;\n                }\n            }\n        }\n        if(miss[n-1-j]){\n            int replace = find(ALL(b), a[n-1-j]) - b.begin();\n            miss[n-1-j] = false;\n            if(b[n-1-j] == a[replace])\n                miss[replace] = false;\n            swap(b[n-1-j], b[replace]);\n            cost += b[n-1-j] + b[replace];\n        }\n    }\n\n    cout << cost << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int INF = 1000000;\n\nint partition(int *A,int p,int r)\n{\n\tint j,x,temp;\n\n\tx = A[r];\n\tj = p-1;\n\n\tfor(int i = p; i < r; i++)\n\t{\n\t\tif (A[i] <= x)\n\t\t{\n\t\t\tj++;\n\t\t\ttemp = A[i];\n\t\t\tA[i] = A[j];\n\t\t\tA[j] = temp;\n\t\t}\n\t}\n\n\ttemp = A[j+1];\n\tA[j+1] = A[r];\n\tA[r] = temp;\n\n\treturn j+1;\n}\n\nvoid quicksort(int *A,int p,int r)\n{\n\tint q;\n\n\tif (p < r)\n\t{\n\t\tq = partition(A,p,r);\n\t\tquicksort(A,p,q-1);\n\t\tquicksort(A,q+1,r);\n\t}\n}\n\nint solve_swap(int *a,int *b,int n)\n{\n\tint sum,temp;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (a[i] != b[i])\n\t\t{\n\t\t\tfor(int j = i+1; j < n; j++)\n\t\t\t{\n\t\t\t\tif (b[j] == a[i] && b[i] == a[j])\n\t\t\t\t{\n\t\t\t\t\ttemp = a[i];\n\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\ta[j] = temp;\n\n\t\t\t\t\tsum += a[i] + a[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n\nint solve1(int *a,int *b,int n)\n{\n\tbool check;\n\tint min,num,temp,sum,start;\n\n\tsum = 0;\n\tstart = 0;\n\n\twhile(1)\n\t{\n\t\tmin = INF;\n\t\t\n\t\tcheck = true;\n\n\t\t//printf(\"start = %d\\n\", start);\n\n\t\tfor(int i = start; i < n; i++)\n\t\t{\n\t\t\tif (min > a[i] && a[i] != b[i])\n\t\t\t{\n\t\t\t\tnum = i;\n\t\t\t\tmin = a[num];\n\t\t\t}\n\t\t}\n\n\t\t//printf(\"num = %d\\n\", num);\n\t\t//printf(\"min = %d\\n\", min);\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (a[i] == b[num])\n\t\t\t{\n\t\t\t\t//printf(\"%d and %d are swapped\\n\", a[num],a[i]);\n\t\t\t\tsum += a[num] + a[i];\n\t\t\t\ttemp = a[i];\n\t\t\t\ta[i] = min; // min = a[num]\n\t\t\t\ta[num] = temp;\n\t\t\t\tnum = i;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (a[i] != b[i])\n\t\t\t{\n\t\t\t\tcheck = false;\n\t\t\t\tstart = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\t//printf(\"a[i] = %d\\n\", a[i]);\n\t\t}\n\n\t\tif (check)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn sum;\n}\n\nbool check(int *A,int *B,int n)\n{\n\tbool c = true;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (A[i] != B[i])\n\t\t{\n\t\t\tc = false;\n\t\t}\n\t}\n\n\treturn c;\n}\n\nint main()\n{\n\tint n,a[1000] = {0},b[1000] = {0},a2[1000] = {0};\n\tint sum1 = 0,sum2 = 0,pivot = 0,pivot1 = 0,pivot2= 0,min = 0,start,temp,k;\n\n\tscanf(\"%d\", &n);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\tb[i] = a[i];\n\t}\n\n\tquicksort(b,0,n-1);\n\n\tsum1 = solve_swap(a,b,n);\n\n\t//printf(\"sum = %d\\n\", sum1);\n\n\t\n\tif (check(a,b,n))\n\t{\n\t\tprintf(\"%d\\n\", sum1);\n\t\treturn 0;\n\t}\n\n\n\tsum2 = sum1;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\ta2[i] = a[i];\n\t}\n\n\t//printf(\"\\nhere is sum1\\n\");\n\n\tsum1 += solve1(a,b,n);\n\n\t//printf(\"sum1 = %d\\n\",sum1);\n\n\n\tif (check(a,b,n))\n\t{\n\t\tprintf(\"%d\\n\", sum1);\n\t\treturn 0;\n\t}\n\n\n\n\tfor(int i = 1; i < n - start; i++)\n\t{\n\t\tk = start;\n\n\t\t\n\t\twhile(1)\n\t\t{\n\t\t\tif (b[pivot1] == a[k])\n\t\t\t{\n\t\t\t\tprintf(\"%d and %d are swapped\\n\", a[pivot1],a[k]);\n\t\t\t\ttemp = a[pivot1];\n\t\t\t\ta[pivot1] = a[k];\n\t\t\t\ta[k] = temp;\n\n\t\t\t\tsum1 += a[pivot1] + a[k];\n\t\t\t\tpivot1 = k;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tprintf(\"%d \", a[i]);\n\t\t}\n\t\tcout << endl;\n\t}\n\n\n\tif (!check(a,b,n))\n\t{\n\t\tprintf(\"\\nhere is sum2\\n\");\n\t\ttemp = a2[pivot2];\n\t\ta2[pivot2] = a2[0];\n\t\ta2[0] = temp;\n\n\t\tfor(int i = 1; i < n - start; i++)\n\t\t{\n\t\t\tint j = start;\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif (b[pivot2] == a2[j])\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d and %d are swapped\\n\", a2[pivot2],a2[j]);\n\t\t\t\t\ttemp = a2[pivot2];\n\t\t\t\t\ta2[pivot2] = a2[j];\n\t\t\t\t\ta2[j] = temp;\n\n\t\t\t\t\tsum2 += a2[pivot2] + a2[j];\n\t\t\t\t\tpivot2 = j;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tprintf(\"%d \", a2[i]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\n\t\tif (sum1 < sum2)\n\t\t{\n\t\t\tprintf(\"sum1 = %d\\n\", sum1);\n\t\t}else\n\t\t{\n\t\t\tprintf(\"sum2 = %d\\n\", sum2);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\n\tprintf(\"%d\\n\", sum1);\n\t\n\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include<time.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = int;\nusing ULL = unsigned long long;\nlong long MOD = 1000000000 + 7;\nconstexpr long long INF = numeric_limits<LL>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\nstruct Fll { LL first, second, third, fourd; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\nLL h, w, n, m, k, t, s, q, last, cnt, sum, ans, dp[10000], a[2000000], b[2000000];\nstring str, ss;\nbool f[1100][1100];\nchar c;\nint di[4][2] = { { 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 } };\nstruct Edge { LL to, cost; };\nvector<Edge>vec[200000];\nvector<LL>v,pick[200000];\nmap<string, vector<LL>>ma;\nmultiset<LL>st[3];\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\n\n\nvector<int> kosaraju() {\n\tint sz = 0;\n\tvector<Edge> rg[50000];\n\tvector<int> stk, cmp(n, -1), added(n), visited(n), ord(n);\n\trep(i, n) {\n\t\tsz += vec[i].size();\n\t\tfor (const Edge &e : vec[i])\n\t\t\trg[e.to].push_back(Edge{ (int)i, e.cost });\n\t}\n\tstk.resize(n + sz); sz = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (visited[i]) continue;\n\t\tint s = 0; stk[s++] = i;\n\t\twhile (s != 0) {\n\t\t\tint v = stk[s - 1];\n\t\t\tvisited[v] = true;\n\t\t\tbool pushed = false;\n\t\t\tfor (auto &e : vec[v]) {\n\t\t\t\tint dst = e.to;\n\t\t\t\tif (!visited[dst]) { stk[s++] = dst; pushed = true; }\n\t\t\t}\n\t\t\tif (pushed) continue;\n\t\t\tint t = stk[s - 1];\n\t\t\tif (!added[t]) { added[t] = true; ord[n - ++sz] = t; }\n\t\t\t--s;\n\t\t}\n\t}\n\tint k = 0;\n\tfor (int &u : ord) {\n\t\tif (cmp[u] != -1) continue;\n\t\tint s = 0; stk[s++] = u;\n\t\twhile (s != 0) {\n\t\t\tint v = stk[--s]; cmp[v] = k;\n\t\t\tfor (auto &e : rg[v]) {\n\t\t\t\tint d = e.to;\n\t\t\t\tif (cmp[d] == -1) stk[s++] = d;\n\t\t\t}\n\t\t}\n\t\t++k;\n\t}\n\treturn cmp;\n}\n\nmap<int, int> zip;\nint unzip[200000];\n\nint compress(vector<int> &x) {\n\tsort(x.begin(), x.end());\n\tx.erase(unique(x.begin(), x.end()), x.end());\n\tfor (int i = 0; i < x.size(); i++) {\n\t\tzip[x[i]] = i;\n\t\tunzip[i] = x[i];\n\t}\n\treturn x.size();\n}\n\nint main() {\n\tcin >> n;\n\trep(i, n) {\n\t\tcin >> a[i];\n\t\tv.push_back(a[i]);\n\t}\n\tcompress(v);\n\tv.clear();\n\trep(i,n){\n\t\tvec[i].push_back(Edge{ zip[a[i]],1 });\n\t}\n\tv=kosaraju();\n\trep(i, v.size()) {\n\t\tpick[v[i]].push_back(i);\n\t}\n\trep(i, n) {\n\t\tsum = 0;\n\t\tLL mn = INF;\n\t\tif (pick[i].size() > 1) {\n\t\t\trep(j, pick[i].size()) {\n\t\t\t\tsum += unzip[pick[i][j]];\n\t\t\t\tmn = min(mn, pick[i][j]);\n\t\t\t}\n\t\t\tans += min(sum + unzip[mn] * (pick[i].size() -\t2),sum+unzip[0] * (pick[i].size())+unzip[mn]);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\n\nint partition(int *A,int p,int r)\n{\n\tint j,x,temp;\n\n\tx = A[r];\n\tj = p-1;\n\n\tfor(int i = p; i < r; i++)\n\t{\n\t\tif (A[i] <= x)\n\t\t{\n\t\t\tj++;\n\t\t\ttemp = A[i];\n\t\t\tA[i] = A[j];\n\t\t\tA[j] = temp;\n\t\t}\n\t}\n\n\ttemp = A[j+1];\n\tA[j+1] = A[r];\n\tA[r] = temp;\n\n\treturn j+1;\n}\n\nvoid quicksort(int *A,int p,int r)\n{\n\tint q;\n\n\tif (p < r)\n\t{\n\t\tq = partition(A,p,r);\n\t\tquicksort(A,p,q-1);\n\t\tquicksort(A,q+1,r);\n\t}\n}\n\nint main()\n{\n\tbool check;\n\tint n,a[1000] = {0},b[1000] = {0};\n\tint sum1 = 0,sum2 = 0,pivot,pivot1,pivot2,min,start,temp;\n\n\tscanf(\"%d\", &n);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\tb[i] = a[i];\n\t}\n\n\tquicksort(b,0,n-1);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (a[i] != b[i])\n\t\t{\n\t\t\tfor(int j = i+1; j < n; j++)\n\t\t\t{\n\t\t\t\tif (b[j] == a[i] && b[i] == a[j])\n\t\t\t\t{\n\t\t\t\t\ttemp = a[i];\n\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\ta[j] = temp;\n\t\t\t\t\tsum1 += a[i] + a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//cout << \"sum=\" << sum1 << endl;\n\n\tsum2 = sum1;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (a[i] != b[i])\n\t\t{\n\t\t\tif (i == 0)\n\t\t\t{\n\t\t\t\tcheck = true;\n\t\t\t}\n\t\t\tstart = i;\n\t\t\tmin = a[i];\n\n\t\t\tfor(int j = i+1; j < n; j++)\n\t\t\t{\n\t\t\t\tif (min > a[j])\n\t\t\t\t{\n\t\t\t\t\tmin = a[j];\n\t\t\t\t\tpivot = j;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i == n-1)\n\t\t{\n\t\t\tprintf(\"%d\\n\", sum1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpivot1 = pivot;\n\tpivot2 = pivot;\n\n\tfor(int i = 1; i < n - start; i++)\n\t{\n\t\tint j = start;\n\t\twhile(1)\n\t\t{\n\t\t\tif (b[pivot1] == a[j])\n\t\t\t{\n\t\t\t\ttemp = a[pivot1];\n\t\t\t\ta[pivot1] = a[j];\n\t\t\t\ta[j] = temp;\n\n\t\t\t\tsum1 += a[pivot1] + a[j];\n\t\t\t\tpivot1 = j;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t}\n\n\tif (!check)\n\t{\n\t\ttemp = a[pivot2];\n\t\ta[pivot2] = a[0];\n\t\ta[0] = temp;\n\n\t\tfor(int i = 1; i < n - start; i++)\n\t\t{\n\t\t\tint j = start;\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif (b[pivot2] == a[j])\n\t\t\t\t{\n\t\t\t\t\ttemp = a[pivot2];\n\t\t\t\t\ta[pivot2] = a[j];\n\t\t\t\t\ta[j] = temp;\n\n\t\t\t\t\tsum2 += a[pivot2] + a[j];\n\t\t\t\t\tpivot2 = j;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif (sum1 < sum2)\n\t{\n\t\tprintf(\"%d\\n\", sum1);\n\t}else\n\t{\n\t\tprintf(\"%d\\n\", sum2);\n\t}\n\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <stdlib.h>\n#include <iostream>\n#include <climits>\nusing namespace std;\n\nstruct weight{\n\tint val;\n\tint id;\n\tweight(){\n\t\tval = 0;\n\t\tid  = 0;\n\t}\n\tweight(weight *w){\n\t\tval = w->val;\n\t\tid  = w->id;\n\t}\n\tvoid set(weight *w){\n\t\tval = w->val;\n\t\tid  = w->id;\n\t}\n};\n\nvoid merge_sort(weight *array, int left, int right);\nvoid merge(weight *array, int left, int mid, int right);\nvoid swap_id(weight *a, weight *b);\nvoid swap(weight *a, weight *b);\nvoid print_weight(weight *a, int num);\nint cal_min_swap(weight *original, weight *sorted, int num);\nint linear_search(weight *array, int size, int num);\n\nint main(){\n\tint n;\n\n\tcin >> n;\n\n\tweight* original = (weight*)malloc(n * sizeof(weight));\n\tweight* sorted   = (weight*)malloc(n * sizeof(weight));\n\tint result = 0;\n\n\tif(n < 1){\n\t\treturn 0;\n\t}\n\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> original[i].val;\n\t\toriginal[i].id = i;\n\t\tsorted[i].set(&original[i]);\n\t}\n\n\tmerge_sort(sorted, 0, n);\n\tprint_weight(sorted, n);\n\tcout << cal_min_swap(original, sorted, n) << endl;\n\treturn 0;\n}\n\nvoid merge_sort(weight *array, int left, int right){\n\tif(left+1 < right){\n\t\tint mid = (left + right) >> 1;\n\t\tmerge_sort(array, mid, right);\n\t\tmerge_sort(array, left, mid);\n\t\tmerge(array, left, mid, right);\n\t}\n\n}\n\nvoid merge(weight *array, int left, int mid, int right){\n\tint n1 = mid - left;\n\tint n2 = right - mid;\n\n\tweight* L = (weight*)malloc((n1+1) * sizeof(weight));\n\tweight* R = (weight*)malloc((n2+1) * sizeof(weight));\n\n\tfor(int i = 0; i < n1; ++i){\n\t\tL[i].set(&array[left+i]);\n\t}\n\tL[n1].val = INT_MAX;\n\tfor(int i = 0; i < n2; ++i){\n\t\tR[i].set(&array[mid+i]);\n\t}\n\tR[n2].val = INT_MAX;\n\n\tint i = 0;\n\tint j = 0;\n\tfor(int k = left; k < right; ++k){\n\t\tif(L[i].val <= R[j].val){\n\t\t\tarray[k].set(&L[i]);\n\t\t\t++i;\n\t\t}else{\n\t\t\tarray[k].set(&R[j]);\n\t\t\t++j;\n\t\t}\n\t\t// array[k].id = k;\n\t}\n}\nvoid swap_id(weight *a, weight *b){\n\tint temp = b->id;\n\tb->id = a->id;\n\ta->id = temp;\n}\nvoid swap(weight *a, weight *b){\n\tweight *temp = new weight(b);\n\tb->set(a);\n\ta->set(temp);\n\tfree(temp);\n}\n\nvoid print_weight(weight *a, int num){\n\tfor(int i = 0; i < num; ++i){\n\t\tcout << a[i].val << \" \";\n\t}\n\tcout << endl;\n}\n\nint cal_min_swap(weight *original, weight *sorted, int num){\n\tint total_swap_w = 0;\n\tint temp_i = 0;\n\tbool is_swap = false;\n\tint swap_num = 0;\n\tint min = sorted[0].val;\n\tint this_min = 0;\n\tint this_total_swap_num = 0;\n\tstring test;\n\tfor(int i = 0; i < num; ++i){\n\t\tif(original[i].id != sorted[i].id){\n\t\t\tif(!is_swap){\n\t\t\t\ttemp_i = i;\n\t\t\t\tswap_num = 0;\n\t\t\t\tthis_min = sorted[i].val;\n\t\t\t\tthis_total_swap_num = 0;\n\t\t\t}\n\t\t\tthis_total_swap_num += original[i].val;\n\t\t\tint swap_i = linear_search(sorted, num, original[i].val);\n\t\t\tswap(&sorted[i], &sorted[swap_i]);\n\t\t\ti = swap_i - 1;\n\t\t\tis_swap = true;\n\t\t\tswap_num++;\n\t\t}else{\n\t\t\tif(is_swap){\n\t\t\t\tif(swap_num != 1){\n\t\t\t\t\tif(min*swap_num + 2*(min + this_min) < this_min*swap_num){\n\t\t\t\t\t\tthis_total_swap_num += min*swap_num + 2*(min + this_min);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tthis_total_swap_num += this_min*swap_num;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tthis_total_swap_num += this_min;\n\t\t\t\t}\n\t\t\t\ttotal_swap_w += this_total_swap_num;\n\t\t\t\tthis_total_swap_num = 0;\n\t\t\t\ti = temp_i;\n\t\t\t\tis_swap = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn total_swap_w;\n}\nint linear_search(weight *array, int size, int num){\n\tfor(int i = 0; i < size; ++i){\n\t\tif(array[i].val == num){\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n\n  long long int n;\n  cin >> n;\n\n  vector< long long int > v, vs;\n\n  for ( long long int i = 0; i < n; i++ ) {\n\n    long long int in;\n    cin >> in;\n    v.push_back( in );\n    vs.push_back( in );\n\n  }\n\n  sort( vs.begin(), vs.end() );\n\n  vector< long long int > t;\n\n  for ( long long int i = 0; i < n; i++ ) {\n    for ( long long int j = 0; j < n; j++ ) {\n      if ( v[i] == vs[j] ) {\n\tt.push_back( j );\n\tbreak;\n      }\n    }\n  }\n\n  long long int ans = 0;\n\n  for ( long long int i = 0; i < n; i++ ) {\n\n    if ( vs[i] != v[i] ) {\n\n      long long int k = t[i];\n      long long int m = 100000;\n      long long int cnt = v[i];\n      long long int num = 1;\n\n      while( k != i ) {\n\tnum++;\n\tcnt += v[k];\n\tswap( v[i], v[k] );\n\tm = min( m, v[k] );\n\tk = t[k];\n      }\n\n      ans += min( ( num - 2 ) * m, m ) + cnt;\n\n    }\n    /*\n    for ( long long int j = 0; j < n; j++ ) {\n      cout << \" \" << v[j];\n    }\n    cout << endl;\n    */\n  }\n\n  cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\n#include<cmath>\nusing namespace std;\n\nvoid show( int arr[], size_t size )\n{\n\n\tcout<<arr[0]<<flush;\n    for( size_t i=1; i<size; i++ ){\n\t    cout<<' '<<arr[i]<<flush;\n    }\n    cout<<endl;\n}\n\nint min( int arr[], size_t left, size_t right )\n{\n\tif( left +1 < right ){ //????´????????????\\???????????¨???\n\t\tsize_t mid=(left+right)/2;\n\t\treturn min( min(arr, left, mid), min(arr, mid, right) );\n\t}else{\n\t\treturn arr[left];\n\t}\n}\n\n\n/*\nvoid swap( int &a, int &b )\n{\n\tint t=a;\n\ta=b;\n\tb=t;\n}\n\nsize_t partition(int arr[], size_t arr_s, size_t left, size_t right)\n{\n\tif( right >= arr_s ){\n\t\tcout<<\"Error\"<<endl;\n\t\treturn -1;\n\t}\n\n\n\tsize_t below=left-1;\n\n\tfor( size_t above=left; above<right; above++ ){\n\t\tif( arr[above] <= arr[right] ){\n\t\t\t++below;\n\t\t\tswap( arr[above], arr[below] );\n\t\t}\n\t}\n\tswap( arr[right], arr[below+1] ); \n\treturn below+1; \n}\n\n\nvoid quickSort( int *arr, size_t arr_s, size_t left, size_t right )\n{\n\tif( left < right ){\n\t\tsize_t pivot_i=partition( arr, arr_s, left, right );\n\t\tquickSort( arr, arr_s, left, pivot_i-1 );\n\t\tquickSort( arr, arr_s, pivot_i+1, right );\n\t}\n}\n*/\nint merge( int arr[], unsigned int arr_s, unsigned int lft, unsigned int md, unsigned int rgt )\n{\n\tint cnt=0;\n\n\tint left_s=md-lft+1, right_s=rgt-md+1, *left=new int[left_s], *right=new int[right_s];\n\tfor( int i=0; i<left_s-1; i++ ){\n\t\tleft[i]=arr[lft+i];\n\t}\n\tleft[left_s-1]=INT_MAX;\n\tfor( int i=0; i<right_s-1; i++ ){\n\t\tright[i]=arr[md+i];\n\t}\n\tright[right_s-1]=INT_MAX; \n\n\n\tfor( int i=0, left_i=0, right_i=0; i<left_s+right_s-2; i++, cnt++ ){\n\t\tif( left[left_i] <= right[right_i] ){ \n\t\t\tarr[lft+i]=left[left_i];\n\t\t\t++left_i;\n\t\t}else{\n\t\t\tarr[lft+i]=right[right_i];\n\t\t\t++right_i;\n\t\t}\n\t}\n\n\tdelete[] right;delete[] left;\n\treturn cnt;\n}\nint mergeSort( int arr[], unsigned int arr_s, unsigned int lft, unsigned int rgt ) \n{\n\tstatic int cnt=0;\n\t\tunsigned int md=(lft + rgt)/2;\n\tif( rgt - lft >=2 ){\n\n\t\tmergeSort(arr, arr_s, lft, md);  \n\t\tmergeSort(arr, arr_s, md, rgt);\n\t\tcnt+= merge(arr, arr_s, lft, md, rgt); \n\t\n\t}\n\treturn cnt;\n}\nsize_t findidx( int arr[], size_t arr_s, int key )\n{\n\tfor( size_t i=0; i!=arr_s; i++ ){\n\t\tif( arr[i] == key ) return i;\n\t}\n\treturn arr_s;\n}\n\nunsigned int minCost( int arr[], size_t arr_s )\n{\n\tint *sorted=new int[arr_s];\n\tfor( size_t i=0; i<arr_s; i++ ){\n\t\tsorted[i]=arr[i];\n\t}\n\tmergeSort(sorted, arr_s, 0, arr_s); //????????????????????¶?????¨???????????¨\n//\tshow(sorted, arr_s);\n\n\n\t/*\n\t(????°???????????????????)= findptr(arr, arr_s, sorted[0])\n\t(?°????????????????3?????????????????????)= findptr(arr, arr_s, sorted[3])\n\t*/\n\n\tunsigned int cost=0;\n\tint swap_l_val, swap_l_idx, swap_r_val, swap_r_idx;\n\tfor( size_t i=0; ; ){ \n\t\twhile( findidx( arr, arr_s, sorted[i] ) == i ){\n\t\t\ti++;\n\t\t}\n\t\tswap_l_idx= findidx(arr, arr_s, sorted[i]);\n\t\tswap_r_idx= findidx( arr, arr_s, sorted[findidx(arr, arr_s, sorted[i] ) ] );\n\t\tif( swap_l_idx == swap_r_idx ) break;\n\n\t\tswap_l_val=arr[ swap_l_idx];\n\t\tswap_r_val=arr[ swap_r_idx];\n//\t\tcout<<\"swap_l_val : \"<<swap_l_val<<' '<<\"swap_r_val : \"<<swap_r_val<<endl;\n\n\t\tswap( arr[ findidx(arr, arr_s, sorted[i]) ], arr[ findidx( arr, arr_s, sorted[findidx(arr, arr_s, sorted[i])] )]);\n\t\tcost+=swap_l_val + swap_r_val; \n\t}\n\treturn cost;\n}\n\nint main()\n{\n\tsize_t arr_s;cin>>arr_s;\n\tint *arr=new int[arr_s];\n\tfor( size_t i=0; i<arr_s; i++ ){\n\t\tcin>>arr[i];\n\t}\n\n\tlong long mincst=minCost( arr, arr_s );\n//\tshow(arr, arr_s);\n\tcout<<mincst<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint n = 0, a[1000] = { 0 }, c = 0;\n\nint partition(int a[1000], int p, int r) {\n\tint x = a[r - 1];\n\tint i = p - 1;\n\n\tfor (int j = p; j < r; j++) {\n\t\tif (a[j - 1] <= x) {\n\t\t\ti++;\n\t\t\tswap(a[i - 1], a[j - 1]);\n\t\t\tif(i != j)\n\t\t\t\tc += a[i - 1] + a[j - 1];\n\t\t}\n\t}\n\tswap(a[i], a[r - 1]);\n\tif(i != r - 1)\n\t\tc += a[i] + a[r - 1];\n\n\treturn i + 1;\n}\n\nvoid QuickSort(int a[1000], int p, int r) {\n\tif (p < r) {\n\t\tint q = partition(a, p, r);\n\t\tQuickSort(a, p, q - 1);\n\t\tQuickSort(a, q + 1, r);\n\t}\n}\n\nint main()\n{\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\n\tQuickSort(a, 1, n);\n\n\tcout << c << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n\tint n, cost1 = 0, cost2 = 0;\n\tcin >> n;\n\t\n\tint arr1[n], arr2[n], sorted[n];\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> arr1[i];\n\t\tarr2[i] = sorted[i] = arr1[i];\n\t}\n\tsort(sorted, sorted + n);\n\n\tvector<pair<int, int> > vec;\n\tint mini = 0;\n\twhile (mini < n) {\n\t\tint s1, s2;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (arr1[i] == sorted[mini]) {\n\t\t\t\ts1 = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (arr1[i] == sorted[s1]) {\n\t\t\t\ts2 = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (s1 != s2) {\n\t\t\tcost1 += arr1[s1] + arr1[s2];\n\t\t\tvec.push_back(make_pair(s1, s2));\n\t\t\tswap(arr1[s1], arr1[s2]);\n\t\t}\n\t\telse {\n\t\t\tmini++;\n\t\t}\n\t}\n\n\tcout << cost1 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\ntypedef pair<LL, LL> pii;\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nconst char dir[4] = { 'u','l','d','r' };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nconst int MAXN = 1010;\nint w[MAXN];\nbool done[MAXN];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, mini = 100000;\n\tcin >> n;\n\tmap<int, int> mp;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> w[i];\n\t\tmp[w[i]] = 0;\n\t\tmini = min(mini, w[i]);\n\t}\n\t{\n\t\tint k = 0;\n\t\tfor (auto& p : mp) p.second = k++;\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (done[i]) continue;\n\t\tint cnt = 0, now = i, mi = 100000, sum = 0;\n\t\twhile (1) {\n\t\t\tif (done[now]) break;\n\t\t\tcnt++;\n\t\t\tdone[now] = true;\n\t\t\tmi = min(mi, w[now]);\n\t\t\tsum += w[now];\n\t\t\tnow = mp[w[now]];\n\t\t}\n\t\tint tmp = sum + (cnt - 2)*mi;\n\t\ttmp = min(tmp, sum + mi + mini*(cnt + 1));\n\t\tans += tmp;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * ?????????????????§?????§??????????±?????????????\n * ???????????????????????????????????§???????????????????????????????????§????????§??????????????????\n * ???????????¨??????????????§????????¢????????´??????????????¨???????????????????????????????????????\n * ??????????????°?????????????????°?????§??????????±????????????????????????§???????????????\n */\n\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstdint>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i, start, end) for(int i = (start); i < (end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nvoid read_problem(vector<int>& ws)\n{\n    int n;\n    scanf(\"%d\\n\", &n);\n\n    ws.reserve(n);\n    REP(i, n) {\n        int w;\n        scanf(\"%d\", &w);\n        ws.emplace_back(w);\n    }\n}\n\nint argmax(const vector<int>& ws, int start, int end)\n{\n    int maxi = start;\n    for(int i = start; i < end; ++i) {\n        if(ws[i] > ws[maxi]) {\n            maxi = i;\n        }\n    }\n    return maxi;\n}\n\nint selsort(vector<int>& ws)\n{\n    int n = ws.size();\n\n    int cost = 0;\n    for(int cnt = n; cnt >= 2; --cnt) {\n        int i = argmax(ws, 0, cnt);\n        if(i != cnt-1) {\n            cost += ws[i] + ws[cnt-1];\n            swap(ws[i], ws[cnt-1]);\n        }\n    }\n\n    return cost;\n}\n\nint main()\n{\n    vector<int> ws;\n    read_problem(ws);\n    int n = ws.size();\n#if 0\n    REP(i, n) {\n        printf(\"%d \", ws[i]);\n    }\n#endif\n\n    int cost = selsort(ws);\n    printf(\"%d\\n\", cost);\n#if 0\n    REP(i, n) {\n        printf(\"%d \", ws[i]);\n    }\n    puts(\"\");\n#endif\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "///\n// File:  alds1_6_d.cpp\n// Author: ymiyamoto\n//\n// Created on Thu Oct 12 23:39:32 2017\n//\n\n#include <algorithm>\n#include <cstdint>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n#define SIZE 10000\n\nstatic vector<uint32_t> array;\nstatic uint32_t T[SIZE + 1];\n\nstatic uint32_t solve(uint32_t array_min)\n{\n  uint32_t count = 0;\n\n  vector<bool> visited(array.size(), false);\n  vector<uint32_t> array1(array);\n\n  sort(array1.begin(), array1.end());\n\n  for (uint32_t i = 0; i < array1.size(); i++) {\n    T[array1[i]] = i;\n  }\n\n  for (uint32_t i = 0; i < visited.size(); i++) {\n    if (visited[i]) continue;\n    uint32_t index = i;\n    uint32_t cycle_weight = 0;\n    uint32_t cycle_min = UINT32_MAX;\n    uint32_t cycle_len = 0;\n    while (true) {\n      visited[index] = true;\n      cycle_len++;\n      uint32_t v = array[index];\n      cycle_min = min(cycle_min, v);\n      cycle_weight += v;\n      index = T[v];\n      if (visited[index]) break;\n    }\n    count += min(cycle_weight + (cycle_len - 2) * cycle_min, cycle_min + cycle_weight + (cycle_len + 1) * array_min);\n  }\n\n  return count;\n}\n\nint32_t main()\n{\n  uint32_t n;\n  cin >> n;\n\n  uint32_t s = UINT32_MAX;\n  for (uint32_t i = 0; i < n; i++) {\n    uint32_t val;\n    cin >> val;\n    array.push_back(val);\n    s = min(s, val);\n  }\n\n  uint32_t count = solve(s);\n\n  cout << count << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<algorithm>\n#include<iostream>\n#include<map>\n#include<vector>\nint main(void) {\n\tstd::ios_base::sync_with_stdio(false);\n\tint n, input;\n\tstd::cin >> n;\n\tstd::map<int, int>w;\n\tstd::vector<int>vector(n+1,0);\n\t\n\tfor (int i = 1; i <= n; ++i) {\n\t\tstd::cin >> input;\n\t\tvector[i] = input;\n\t}\n\tstd::vector<int>vector_min= vector;\n\n\tstd::sort(vector_min.begin(), vector_min.end());\n\tfor (int i = 1; i <= n; ++i) {\n\t\tw[vector[i]] = vector_min[i];\n\t}\n\tstd::map<int, int>w_1(w);\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint temp = 0;\n\t\twhile (vector_min[i] != w[vector_min[i]]) {\n\t\t\ttemp += vector_min[i] + w[vector_min[i]] ;\n\t\t\tstd::swap(w[vector_min[i]],w[w[vector_min[i]]] );\n\t\t}\n\t\tint temp_1 = static_cast<int>(1e5);\n\t\tif (i>1&&vector_min[i] != w_1[vector_min[i]]) {\n\t\t\ttemp_1 =  w_1[vector_min[i]]+ w_1[vector_min[1]] ;\n\t\t\tstd::swap(w_1[vector_min[1]], w_1[vector_min[1]]);\n\t\t\twhile (vector_min[1] !=w_1[vector_min[1]]) {\n\t\t\t\ttemp_1 += w_1[vector_min[i]]+ w_1[vector_min[1]] ;\n\t\t\t\tstd::swap(w_1[vector_min[1]], w_1[w_1[vector_min[1]]]); }\n\t\t}\n\t\tcnt += std::min(temp, temp_1);\n\t}\n\tstd::cout << cnt << std::endl;\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <iostream>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#define INTINF 2147483647\n#define LLINF 9223372036854775807\n#define MAX 1000\n#define VMAX 10000\ntypedef long long ll;\nusing namespace std;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint solve(){\n  int ans=0;\n\n  bool V[MAX];\n  for (size_t i = 0; i < n; i++) {\n    B[i]=A[i];\n    V[i]=false;\n  }\n  sort(B, B+n);\n\n  for (size_t i = 0; i < n; i++) T[B[i]]=i;\n  for (size_t i = 0; i < n; i++) {\n    if (V[i]) continue;\n    int cur = i;\n    int S = 0;\n    int m = VMAX;\n    int A_n = 0;\n    while (1) {\n      V[cur] = true;\n      A_n++;\n      int v = A[cur];\n      m = min(m, v);\n      S += v;\n      cur = T[v];\n      if (V[cur]) break;\n    }\n    ans += min(S + (A_n-2) * m, S + m + (A_n + 1)*s );\n  }\n  return ans;\n}\n\nint main(int argc, char const *argv[]) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  std::cin >> n;\n  s = VMAX;\n\n  for (size_t i = 0; i < n; i++) {\n    std::cin >> A[i];\n    s = min(s, A[i]);\n  }\n  int cost = solve();\n\n  std::cout << cost << '\\n';\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint solve(){\n\tint ans = 0;\n\n\tbool V[MAX];\n\tfor(int i=0;i<n;i++){\n\t\tB[i] = A[i];\n\t\tV[i] =false;\n\t}\n\tsort(B, B+n);\n\tfor(int i=0;i<n;i++) T[B[i]] = i;\n\tfor(int i=0;i<n;i++){\n\t\tif(V[i]) continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile(1){\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m,v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif(V[cur]) break;\n\t\t}\n\t\tans += min(S+(an-2)*m,m+S+(an+1)*s);\n\t}\n\n\treturn ans;\n}\n\nint main(){\n\tcin >> n;\n\ts = VMAX;\n\tfor(int i=0;i<n;i++){\n\t\tcin >> A[i];\n\t\ts = min(s,A[i]);\n\t}\n\tint ans = solve();\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int Max =1000;\nstatic const int Vmax=10000;\n\nint n,A[Max],s;\nint B[Max],T[Vmax+1];\n\nint solve(){\n  int ans=0;\n  bool V[Max];\n\n  for(int i=0;i<n;i++){\n    B[i]=A[i];\n    V[i]=false;\n  }\n  sort(B,B+n);\n  for(int i=0;i<n;i++)T[B[i]]=i;\n  for(int i=0;i<n;i++){\n    if(V[i])continue;\n    int cur=i;\n    int S=0;\n    int m=Vmax;\n    int an=0;\n    while(1){\n      V[cur]=true;\n      an++;\n      int v=A[cur];\n      m=min(m,v);\n      S+=v;\n      cur=T[v];\n      if(V[cur])break;\n    }\n    ans+=min(S+(an-2)*m,m+S+(an+1)*s);\n  }\n  return ans;\n}\n\nint main(){\n  cin>>n;\n  s=Vmax;\n  for(int i=0;i<n;i++){\n    cin>>A[i];\n    s=min(s,A[i]);\n  }\n  int ans=solve();\n  cout<<ans<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nclass UnionFind {\nprivate:\n\tint height[1000], parent[1000];\n\tint size;\npublic:\n\tUnionFind(int size) : size(size) {\n\t\tfor (int i = 0; i < size; ++i) {\n\t\t\tparent[i] = i;\n\t\t}\n\t\tfill(height, height+size, 0);\n\t}\n\tbool isUnited(int a, int b) {\n\t\treturn root(a) == root(b);\n\t}\n\tint root(int n) {\n\t\tif (n == parent[n]) return n;\n\t\treturn root(parent[n]);\n\t}\n\tvoid unite(int a, int b) {\n\t\ta = root(a), b = root(b);\n\t\tif (height[a] < height[b]) {\n\t\t\tparent[a] = b;\n\t\t}\n\t\telse if (height[a] > height[b]) {\n\t\t\tparent[b] = a;\n\t\t}\n\t\telse {\n\t\t\tparent[b] = a;\n\t\t\theight[b]++;\n\t\t}\n\t}\n};\n\nconst int inf = 1e9;\n\nint main() {\n\tint N; cin >> N;\n\tvector<int> v(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> v[i];\n\t}\n\tmap<int, int> m;\n\tfor (int i = 0; i < N; ++i) {\n\t\tm[v[i]] = i;\n\t}\n\tvector<int> to = v;\n\tsort(to.begin(), to.end());\n\n\tUnionFind uf(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tuf.unite(i, m[to[i]]);\n\t}\n\tmap<int, int> g;\n\tvector<int> sum(N);\n\tvector<int> mn(N, inf);\n\tfor (int i = 0; i < N; ++i) {\n\t\tint id = uf.root(i);\n\t\tsum[id] += v[i];\n\t\tmn[id] = min(mn[id], v[i]);\n\t\tg[id]++;\n\t}\n\tll ans = 0;\n\tfor (const pair<int, int>& p : g) {\n\t\tint i = p.first, n = p.second;\n\t\tans += sum[i]-mn[i] + min(mn[i]*(n-1), (to[0]+mn[i])*2+to[0]*(n-1));\n\t}\n/*\n\tll ans = 0;\n\tfor (int i = N-1; i >= 0; --i) {\n\t\tif (v[i] == to[i]) continue;\n\t\tint j = now[to[i]];\n\t\tswap(v[i], v[j]);\n\t\tnow[v[i]] = j;\n\t\tnow[v[j]] = i;\n\t\tans += v[i]+v[j];\n\t}\n*/\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//The Number of Inversions\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct weight {\n    int id;\n    int weight;\n    bool searched = false;\n};\n\nint partition(weight A[], int p, int r) {\n    int x = A[r].weight;\n    int i = p - 1;\n    for(int j = p; j < r; j++) {\n        if(x >= A[j].weight) {\n            i++;\n            swap(A[i], A[j]);\n        }\n    }\n    swap(A[i + 1], A[r]);\n    return i + 1;\n}\n\nvoid quickSort(weight A[], int p, int r) {\n    if(p < r) {\n        int x = partition(A, p, r);\n        quickSort(A, p, x - 1);\n        quickSort(A, x + 1, r);\n    }\n}\n\n\nint main() {\n    int n, s = 10000;\n    cin >> n;\n    weight W[n];\n    for(int i = 0; i < n; i++) {cin >> W[i].weight; W[i].id = i; s = min(s, W[i].weight);}\n\n    quickSort(W, 0, n - 1);\n\n    int cost = 0;\n    for(int i = 0; i < n; i++) {\n        if(!W[i].searched) {\n            int id = i, c = 0, size = 0;\n            while(1) {\n                W[id].searched = true;\n                c += W[id].weight;\n                size++;\n                id = W[id].id;\n                if(id == i) break;\n            }\n            if(size != 1) cost += (c + min((size - 2) * W[i].weight, W[i].weight + (size + 1) * s));\n        }\n    }\n    cout << cost << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nint main() {\n    int n, ans = 0, t[1000], u[1000];\n    bool visited[1000];\n    map<int, int> change;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> t[i];\n        change[t[i]] = i;\n        u[i] = t[i];\n        visited[i] = false;\n    }\n    sort(u, u + n);\n    for (int i = 0; i < n; i++) {\n        int w = i, x = 0, y = 0, z = 10000;\n        while (!visited[w]) {\n            z = min(z, t[w]);\n            y += t[w];\n            x++;\n            visited[w] = true;\n            w = change[u[w]];\n        }\n        if (x >= 2)ans += min(y + z + u[0] * (x + 1), y + z * (x - 2));\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve() {\n  int ans = 0;\n\n  bool V[MAX];\n  for ( int i = 0; i < n; i++ ) {\n    B[i] = A[i];\n    V[i] = false;\n  }\n  sort(B, B + n);\n  for ( int i = 0; i < n; i++ ) T[B[i]] = i;\n  for ( int i = 0; i < n; i++ ) {\n    if ( V[i] ) continue;\n    int cur = i;\n    int S = 0;\n    int m = VMAX;\n    int an = 0;\n    while ( 1 ) {\n      V[cur] = true;\n      an++;\n      int v = A[cur];\n      m = min(m, v);\n      S += v;\n      cur = T[v];\n      if ( V[cur] ) break;\n    }\n    ans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n  }\n  return ans;\n}\n\nint main() {\n  cin >> n;\n  s = VMAX;\n  for ( int i = 0; i < n; i++ ) {\n    cin >> A[i];\n    s = min(s, A[i]);\n  }\n  int ans = solve();\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\nconst int MAXN = 1010;\nint w[MAXN];\nbool done[MAXN];\n \nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, mini = 100000;\n    cin >> n;\n    map<int, int> mp;\n    for (int i = 0; i < n; i++) {\n        cin >> w[i];\n        mp[w[i]] = 0;\n        mini = min(mini, w[i]);\n    }\n    {\n        int k = 0;\n        for (auto& p : mp) p.second = k++;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (done[i]) continue;\n        int cnt = 0, now = i, mi = 100000, sum = 0;\n        while (1) {\n            if (done[now]) break;\n            cnt++;\n            done[now] = true;\n            mi = min(mi, w[now]);\n            sum += w[now];\n            now = mp[w[now]];\n        }\n        int tmp = sum+(cnt-2)*mi;\n        tmp = min(tmp, sum+mi+mini*(cnt+1));\n        ans += tmp;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <cstdint>\n\nusing namespace std;\n\ntemplate<typename T>\nint32_t merge(vector<T> &A, int32_t left, int32_t mid, int32_t right) {\n    int32_t n1 = mid - left;\n    int32_t n2 = right - mid;\n\n    vector<T> L(n1+1);\n    vector<T> R(n2+1);\n    for (int32_t i = 0; i < n1; i++) {\n        L[i] = A[left+i];\n    }\n    for (int32_t i = 0; i < n2; i++) {\n        R[i] = A[mid+i];\n    }\n    L[n1] = INT32_MAX;\n    R[n2] = INT32_MAX;\n\n    int32_t i = 0, j = 0, count = 0;\n    for (int32_t k = left; k < right; k++) {\n        if (L[i] <= R[j]) {\n            A[k] = L[i];\n            i++;\n        } else {\n            A[k] = R[j];\n            j++;\n        }\n        count++;\n    }\n\n    return count;\n}\n\ntemplate<typename T>\nint32_t cost(const vector<T> &unsorted, const vector<T> &sorted) {\n    bool is_sorted = true;\n    int32_t c = INT32_MAX;\n\n    for (int32_t i = 0; i < unsorted.size(); i++) {\n        if (unsorted[i] != sorted[i]) {\n            is_sorted = false;\n\n            int32_t j = 0;\n            while (unsorted[i] != sorted[j]) j++;\n\n            vector<T> unsorted2(unsorted);\n            swap(unsorted2[i], unsorted2[j]);\n            c = min(c, unsorted2[i] + unsorted2[j] + cost(unsorted2, sorted));\n        }\n    }\n\n    return (is_sorted ? 0 : c);\n}\n\ntemplate<typename T>\nint32_t merge_sort(vector<T> &A, int32_t left, int32_t right) {\n    if (left + 1 < right) {\n        int32_t mid = left + (right - left) / 2;\n        int32_t count1 = merge_sort(A, left, mid);\n        int32_t count2 = merge_sort(A, mid, right);\n        int32_t count3 = merge(A, left, mid, right);\n        return count1 + count2 + count3;\n    }\n\n    return 0;\n}\n\nint main() {\n    int32_t n;\n\n    cin >> n;\n    vector<int32_t> w1(n);\n    for (int32_t i = 0; i < n; i++) {\n        cin >> w1[i];\n    }\n\n    vector<int32_t> w2(w1);\n    merge_sort(w2, 0, n);\n\n    cout << cost(w1, w2) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve(){\n  int ans = 0;\n\n  bool V[MAX];\n  for(int i=0;i<n;i++){\n    B[i] = A[i];\n    V[i] = false;\n  }\n  sort(B,B+n);\n  for(int i=0;i<n;i++) T[B[i]] = i;\n\n  for(int i=0;i<n;i++){\n    if(V[i]) continue;\n    int cur = i;\n    int S = 0;\n    int m = VMAX;\n    int an = 0;\n\n    // 1ループを求めるプログラム\n    while(1){\n      // 辿ったという証拠をのこす\n      V[cur] = true;\n      // ループの中の端末数を増やす\n      an++;\n      // 数を保存\n      int v = A[cur];\n      // ループの中の最小値を保存\n      m = min(m,v);\n      // ループ全体のコストを記録\n      S += v;\n      // 並べ変えたときにいるべき場所にいる場所を保存\n      cur = T[v];\n      // すでにたどった場所なら(ループが完了したなら)while脱出\n      if(V[cur]) break;\n    }\n    ans += min(S+(an-2)*m , m+S+(an+1)*s);\n  }\n  return ans;\n}\n\nint main(){\n  cin >> n;\n  s = VMAX;\n  for(int i=0;i<n;i++){\n    cin >> A[i];\n    s = min(s,A[i]);\n  }\n\n  int ans = solve();\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "let quick_sort a n cmp =\n  let swap i j = let tmp = a.(i) in a.(i) <- a.(j); a.(j) <- tmp in\n  let partition p r =\n    let i = ref p in\n    for j = p to r - 1 do\n      if cmp a.(j) a.(r) <= 0 then (swap !i j; incr i)\n    done;\n    swap !i r;\n    !i in\n  let rec doit p r =\n    if p >= r then () else\n    let q = partition p r in\n    doit p (q - 1);\n    doit (q + 1) r in\n  doit 0 (n - 1)\n\nlet calc_cost a n =\n  let b = Array.copy a in\n  quick_sort b n compare;\n  let t = Array.make (b.(n-1) + 1) 0 in\n  Array.iteri (fun i e -> t.(e) <- i) b;\n  let p = Array.make n false in\n  let rec cycle i acc =\n    p.(i) <- true;\n    let j = t.(a.(i)) in\n    if p.(j) then a.(i) :: acc\n    else cycle j (a.(i) :: acc) in\n  let cycle i = cycle i [] in\n  let rec doit i acc =\n    if i = n then acc\n    else if p.(i) then doit (i + 1) acc\n    else\n      let ws = cycle i in\n      let m = List.length ws in\n      let s = List.fold_left (+) 0 ws in\n      let z = List.fold_left min max_int ws in\n      doit (i + 1) (acc + (min (s + (m - 2)*z) (s + z + (m + 1)*b.(0)))) in\n  doit 0 0\n\nlet () =\n  let n = read_int () in\n  let a = Array.init n (fun _ -> Scanf.scanf \"%d \" (fun e -> e)) in\n  calc_cost a n |> Printf.printf \"%d\\n\"\n"
  },
  {
    "language": "C++",
    "code": "//\n// Created by ?????°?????? on 2016/04/14.\n//\n\n\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX = 1000;\nconst int VMAX = 100000;\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX +1];\n\nint solve(){\n    int ans = 0;\n    bool V[MAX];\n    for (int i = 0; i < n ; ++i) {\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort (B,B+n);\n    for (int i = 0; i < n ; ++i) T[B[i]] = i;\n    for (int i = 0; i < n ; ++i) {\n        if(V[i]) continue;\n        int cur = i, S = 0, m = VMAX,an =0;\n        while(1){\n            V[cur] = true;\n            an ++;\n            int v = A[cur];\n            m = min (m,v);\n            S += v;\n            cur = T[v];\n            if(V[cur]) break;\n        }\n        ans += min(S + (an -2) *m ,m + S + (an + 1)*s);\n    }\n    return ans;\n}\n\nint main (){\n    cin >> n;\n    s = VMAX;\n    for (int i = 0; i < n ; ++i) {\n        cin >> A[i];\n        s = min(s,A[i]);\n    }\n    int ans = solve();\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace ext {\n\ttemplate <class T>\n\tstruct vec_type;\n\ttemplate <class T>\n\tconstexpr bool is_vec_v;\n\tusing namespace std;\n\ttemplate<class T>\n\tstruct Vector : std::vector<T> {\n\t\tusing std::vector<T>::vector;\n\t\tchar dil = ' ';\n\t\tVector<T> accum() {\n\t\t\tVector<T> res(this->size() + 1);\n\t\t\tfor (size_t i = 0; i < this->size(); i++) {\n\t\t\t\tres[i+1] = (*this)[i] + res[i];\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\ttemplate<class U = T>\n\t\ttypename enable_if<is_vec_v<U>, Vector<T>>::type accum2D() {\n\t\t\tconst size_t H = this->size();\n\t\t\tconst size_t W = (*this)[0].size();\n\t\t\tusing S = typename vec_type<U>::type;\n\t\t\tVector<T> res(H + 1, Vector<S>(W + 1));\n\t\t\tfor (size_t i = 0; i < H; i++) {\n\t\t\t\tfor (size_t j = 0; j < W; j++) {\n\t\t\t\t\tres[i+1][j+1] = (*this)[i][j];\n\t\t\t\t\tres[i+1][j+1] += res[i][j+1];\n\t\t\t\t\tres[i+1][j+1] += res[i+1][j];\n\t\t\t\t\tres[i+1][j+1] -= res[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tVector<T> zaatsu() {\n\t\t\tmap<T, int> m;\n\t\t\tfor (auto& e: *this) m[e] = 1;\n\t\t\tint count = 0;\n\t\t\tfor (auto& e: m) e.second = count++;\n\t\t\tVector<T> res = *this;\n\t\t\tfor (auto& e: res) e = m[e];\n\t\t\treturn res;\n\t\t}\n\t\tVector<T> zaatsu(map<T, int>& r) {\n\t\t\tr.clear();\n\t\t\tmap<T, int> m;\n\t\t\tfor (auto& e: *this) m[e] = 1;\n\t\t\tint count = 0;\n\t\t\tfor (auto& e: m) e.second = count++;\n\t\t\tVector<T> res = *this;\n\t\t\tfor (auto& e: res) r[m[e]] = e, e = m[e];\n\t\t\treturn res;\n\t\t}\n\t\tfriend istream& operator>>(istream& is, Vector<T>& t) {\n\t\t\tfor (auto& e: t) cin >> e;\n\t\t\treturn is;\n\t\t}\n\t\tfriend ostream& operator<<(ostream& os, Vector<T>& t) {\n\t\t\tt.print(' ', os);\n\t\t\treturn os;\n\t\t}\n\t\tvoid print(char del = ' ', ostream& os = cout) {\n\t\t\tfor (size_t i = 0; i < this->size(); i++) {\n\t\t\t\tos << (*this)[i];\n\t\t\t\tif (i + 1 != this->size()) os << del;\n\t\t\t\tos.flush();\n\t\t\t}\n\t\t}\n\t\tvoid println(char del = ' ', ostream& os = cout) {\n\t\t\tprint(del, os);\n\t\t\tcout << endl;\n\t\t}\n\t\tlong long crossing_merge() {\n\t\t\tauto t = *this;\n\t\t\treturn t.crossing_merge_sub();\n\t\t}\n\t\t// [min_v, max_v)\n\t\tlong long crossing_bit(T min_v = -1, T max_v = -1) {\n\t\t\tif (min_v == -1) min_v = this->min();\n\t\t\tif (max_v == -1) max_v = this->max() + 1;\n\t\t\tVector<T> bit(max_v - min_v + 1, 0);\n\t\t\tlong long res = 0;\n\t\t\tfor (auto e: *this) {\n\t\t\t\te = max_v - e;\n\t\t\t\tfor (size_t x = e - 1; x; x -= x & -x) {\n\t\t\t\t\tres += bit[x];\n\t\t\t\t}\n\t\t\t\tfor (size_t x = e; x < bit.size() ; x += x & -x) {\n\t\t\t\t\tbit[x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tbool permutation() {\n\t\t\treturn next_permutation(this->begin(), this->end());\n\t\t}\n\t\tT& max() {\n\t\t\treturn *max_element(this->begin(), this->end());\n\t\t}\n\t\tT& min() {\n\t\t\treturn *min_element(this->begin(), this->end());\n\t\t}\nprivate:\n\t\tlong long crossing_merge_sub() {\n\t\t\tif (this->size() == 1) return 0;\n\t\t\tint x = this->size() / 2;\n\t\t\tVector<T> left(this->begin(), this->begin() + x);\n\t\t\tVector<T> right(this->begin() + x, this->end());\n\t\t\tlong long res = left.crossing_merge_sub() + right.crossing_merge_sub();\n\t\t\tleft.push_back(numeric_limits<T>::max()); right.push_back(numeric_limits<T>::max());\n\t\t\tsize_t l = 0, r = 0;\n\t\t\twhile (l + r < this->size()) {\n\t\t\t\tif (left[l] < right[r]) {\n\t\t\t\t\t(*this)[l+r] = left[l];\n\t\t\t\t\tl++;\n\t\t\t\t} else {\n\t\t\t\t\t(*this)[l+r] = right[r];\n\t\t\t\t\tr++;\n\t\t\t\t\tres += x - l;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t};\n\ttemplate <class T>\n\tstruct vec_type : std::false_type {};\n\ttemplate <class T>\n\tstruct vec_type<Vector<T>> : std::true_type {\n\t\tusing type = T;\n\t};\n\ttemplate <class T>\n\tconstexpr bool is_vec_v = vec_type<T>::value;\n}\nusing namespace ext;\nusing ll = long long;\n\nstruct UnionFind {\n\tint sz;\n\tvector<int> par;\n\tUnionFind(int a) : sz(a), par(sz, -1) {}\n\tint root(int x) { return par[x] < 0 ? x : par[x] = root(par[x]);}\n\tbool same(int x, int y) { return root(x) == root(y);}\n\tbool unite(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) return false;\n\t\tif (size(x) < size(y)) swap(x, y);\n\t\tpar[x] += par[y];\n\t\tpar[y] = x;\n\t\treturn true;\n\t}\n\tint size(int x) { return -par[root(x)];}\n\tint size() { return sz;}\n};\n\nint main() {\n\tint n; cin >> n;\n\tVector<ll> v(n); cin >> v;\n\tmap<ll, int> m;\n\tauto z = v.zaatsu(m);\n\tll res = 0;\n\tfor (auto& x : v) res += x;\n\tUnionFind U(n);\n\tll mi = v.min();\n\tfor (int i = 0; i < n; i++) {\n\t\tU.unite(i, z[i]);\n\t}\n\tvector<set<int>> vs(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tvs[U.root(i)].insert(i);\n\t}\n\tfor (auto& x : vs) {\n\t\tif (x.size() == 0) continue;\n\t\tll a = m[*(x.begin())] * (x.size() - 2);\n\t\tll b = mi * (x.size() + 1)+ m[*(x.begin())];\n\t\tres += min(a, b);\n\t}\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve()\n{\n  int ans = 0;\n\n  bool V[MAX];\n  for (int i = 0; i < n; i++)\n  {\n    B[i] = A[i];\n    V[i] = false;\n  }\n  sort(B, B + n);\n  for (int i = 0; i < n; i++)\n  {\n    T[B[i]] = i;\n  }\n  for (int i = 0; i < n; i++)\n  {\n    if (V[i])\n      continue;\n    int cur = i;\n    int S = 0;\n    int m = VMAX;\n    int an = 0;\n    while (1)\n    {\n      V[cur] = true;\n      an++;\n      int v = A[cur];\n      m = min(m, v);\n      S += v;\n      cur = T[v];\n      if (V[cur])\n        break;\n    }\n    ans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n  }\n  return ans;\n}\n\nint main()\n{\n  cin >> n;\n  s = VMAX;\n  for (int i = 0; i < n; i++)\n  {\n    cin >> A[i];\n    s = min(s, A[i]);\n  }\n\n  int ans = solve();\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <limits>\n#include <fstream>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int N;cin>>N;\n  int w[N];\n  int mini = 2e9;\n  map<int, int> mp;\n  FOR(i,0,N){\n    cin>>w[i];\n    mini = min(mini, w[i]);\n    mp[w[i]] = 0;\n  }\n  int k = 0;\n  for(auto& m : mp) m.second = k++;\n  bool done[N];\n  CLR(done);\n  int ans = 0;\n  FOR(i,0,N){\n    if(done[i]) continue;\n    int cnt = 0, now = i, mi = 2e9, sum = 0;\n    // 巡回\n    while(!done[now]){\n      cnt++;\n      done[now] = true;\n      sum += w[now];\n      now = mp[w[now]];\n    }\n    if(cnt <= 1) continue;\n    ans += min(sum + mi * (cnt - 2), sum + mi + mini * (cnt + 1));\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\nint w[131072],sum[131072],n,k,l,r,mid;\nchar c;\nbool is_digit(){\n    return c<='9'&&c>='0';\n}\nvoid read(int &a){\n    a=0;\n    while((c=getchar())&&(is_digit())) a=a*10+c-'0';\n}\nbool pc(int a){\n    memset(sum,0,sizeof(sum));\n    int j=0;\n    for(int i=0,t=0;i<n;i++){\n        if(t+w[i]>a) j++,t=w[i];\n        else t+=w[i];\n    }\n    return j<k;\n}\nint main(){\n    read(n);\n    read(k);\n    for(int i=0;i<n;i++){\n        read(w[i]);\n        l=max(w[i],l);\n        r+=w[i];\n    }\n    while(l!=r){\n        mid=(l+r)/2;\n        if(pc(mid)) r=mid;\n        else l=mid+1;\n    }\n    cout<<l<<\"\\n\";\n    return 0;\n}\n \n\n "
  },
  {
    "language": "C++",
    "code": "int do_cycle(vector<int> &v,int x){\n\tint s=0,m=1<<30;\n\tfor(auto &e:v)s+=e,m=min(m,e);\n\treturn min(s+(v.size()-2)*m,s+m+(v.size()+1)*x);\n}\n\nint main(){\n\tint N,x=1<<30,r;\n\tscanf(\"%d\",&N);\n\tvector<int>v(N+1),b(N+1);\n\tvector<vector<int> >cycles;\n\tfor(int i=1;i<=N;i++)scanf(\"%d\",&v[i]),x=min(x,v[i]);\n\tfor(int i=1;i<=N;i++)if(!b[i]){\n\t\tvector<int>cycle;\n\t\tint k=i;\n\t\tdo{\n\t\t\tcycle.push_back(k);\n\t\t\tb[k]=1;\n\t\t\tk=v[k];\n\t\t}while(k!=cycle[0]);\n\t\tr+=do_cycle(cycle,x);\n\t}\n\tprintf(\"%d\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint A[1005],B[1005],T[10005],V[1005];\nint solve(int mini,int n)\n{\n\tint ans=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(V[i]) continue;\n\t\tint cur=i,ssum=0,mmini=1e5,cnt=0;\n\t\tdo{\n\t\t\tV[cur] = 1;\n\t\t\tint v = A[cur];\n\t\t\tssum += v;\n\t\t\tmmini = min(mmini,v);\n\t\t\tcur = T[v];\n\t\t\tcnt++;\n\t\t} while (!V[cur]);\n\t\tans += min(ssum+(cnt-2)*mmini,mmini+ssum+(cnt+1)*mini);\n\t}\n\treturn ans;\n}\nint main()\n{\n\tint n,mini=1e5; \n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&A[i]);\n\t\tB[i] = A[i];\n\t\tmini = min(A[i],mini);\n\t}\n\n\tsort(B,B+n);\n\tfor(int i=0;i<n;i++) T[B[i]] = i;\n\tmemset(V,0,sizeof(V));\n\n\tint ans = solve(mini,n);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n;\nvoid merge(int A[],int left, int mid, int right) {\n  int n1 = mid - left;\n  int n2 = right - mid;\n  int L[n1+1]; int R[n2+1];\n  for(int i=0;i<n1;i++) {\n    L[i] = A[left+i];\n  }\n  for(int i=0;i<n2;i++) {\n    R[i] = A[mid+i];\n  }\n  L[n1] = R[n2] = 0x7FFFFFFF;\n  int i = 0; int j = 0;\n  for(int k=left;k<right;k++) {\n    if(L[i] <= R[j]) {\n      A[k] = L[i];\n      i++;\n    }\n    else {\n      A[k] = R[j];\n      j++;\n    }\n  }\n}\nvoid merge_sort(int A[],int left, int right) {\n  if(right - left > 1) {\n    int mid = (left + right) / 2;\n    merge_sort(A,left, mid);\n    merge_sort(A,mid, right);\n    merge(A,left, mid, right);\n  }\n}\n\nint search(int W[],int left,int right, int key) {\n  for(int i=0;i<n;i++) {\n    if(W[i] == key)\n      return i;\n  }\n  return -1;\n}\nint binary_search(int Sorted[],int left,int right, int key) {\n  while(right >= left) {\n    int mid = (left+right)/2;\n    if(Sorted[mid] == key)\n      return mid;\n    else if(Sorted[mid] < key)\n      left = mid + 1;\n    else\n      right = mid - 1;\n  }\n  return -1;\n}\n\n\nint main() {\n  cin >> n;\n  int W[n]; int Sorted[n];\n  for(int i=0;i<n;i++) {\n    int num; cin >> num;\n    W[i] = Sorted[i] = num;\n  }\n  merge_sort(Sorted,0,n);\n\n  // algorithm : https://www.ipsj.or.jp/07editj/promenade/4506.pdf\n  vector<int> R;\n  for(int i=0;i<n;i++) {\n    if(binary_search(Sorted,i,n,W[i]) != i)\n      R.push_back(Sorted[i]);\n  }\n  int Smin = Sorted[0];\n  int Rmin = R[0];\n  int sum = 0;\n  for(int i=0;i<R.size();i++) {\n    sum += R[i];\n  }\n  int cost;\n  if(R.size() > 1)\n    cost = min(sum+Rmin*(R.size()-2),sum+Rmin+Smin*(R.size()+1));\n  else\n    cost = 0;\n\n  cout << cost << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n    int n;\n    cin >> n;\n    int A[n];\n    int B[n];\n    for (int i = 0; i < n; i++) {\n        cin >> A[i];\n        B[i] = A[i];\n    }\n    sort(B, B + n);\n    int cnt = 0;\n    // int i = 0;\n    for (int i = 0; i < n; i++) {\n        // if (A[i] == B[i]) {\n        //     i++;\n        //     continue;\n        // }\n        int tgt_idx = find(A, A + n, B[i]) - A;\n        int n_cycle = 1;\n        while (tgt_idx != i) {\n            int dst_idx = find(A, A + n, B[tgt_idx]) - A;\n            cnt += A[tgt_idx] + A[dst_idx];\n            swap(A[tgt_idx], A[dst_idx]);\n            tgt_idx = dst_idx;\n            n_cycle++;\n        }\n        if ((n_cycle - 3) * B[i] > (n_cycle + 1) * B[0]) {\n            cnt -= (n_cycle - 3) * B[i] - (n_cycle + 1) * B[0];\n        }\n    }\n    cout << cnt << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define MAX 1000\n// 最大入力値\n#define VMAX 10001\n\nint n;\n//数列入力用\nint A[MAX];\n// 入力数列の中の最小値\nint s;\n// 入力したAをソートした配列\nint B[MAX];\n// 数値をINDEXとしてソートした数列がどの位置に置かれるのかを記録する\nint T[VMAX];\n\nint solve(){\n    // コスト\n    int ans = 0;\n    // 交換終了フラグ\n    bool V[MAX] = {};\n    for(int i = 0;i < n;++i){\n        B[i] = A[i];\n    }\n    // Bをソートする\n    sort(B,B + n);\n    \n    for(int i = 0;i < n;++i){\n        // ソートされた並び順ごとに順番を入れておく\n        // ソートされた数列が1 3 5 7 9とするとT[1] = 0,T[3] = 1のように順番が入る\n        T[B[i]] = i;\n    }\n    \n    for(int i = 0;i < n;++i){\n        if(V[i]) continue;\n        // 初回は0が対象になる\n        int cursor = i;\n        // 1サイクルでかかるコスト\n        int S = 0;\n        // 1サイクルにおける最小コスト、取りうる最大数値にしておく\n        int m = VMAX;\n        // サイクルの長さ\n        int an = 0;\n        // 1サイクル処理\n        while(1){\n            // ソート済みフラグ\n            V[cursor] = true;\n            an++;\n            // 対象のコスト\n            int v = A[cursor];\n            // 最小コスト\n            m = min(m,v);\n            // コストに加算\n            S += v;\n            // 対象が置かれるべき位置を割り出すT[v]に置かれるべき1を入れています。\n            cursor = T[v];\n            // サイクルが終了していたら、次に移る\n            if(V[cursor]) break;\n        }\n        // サイクル内の最小値を利用したコスト計算\n        int cost1 = S + (an - 2) * m;\n        // 数列の最小コストを借りた場合のコスト\n        int cost2 = m + S + (an + 1) * s;\n        // 最小値のコストを外から借りた場合とコストを比較する\n        ans += min(cost1,cost2);\n    }\n    return ans;\n}\n\nint main(){\n    cin >> n;\n    // 最小値\n    s = VMAX;\n    for(int i = 0;i < n;++i){\n        cin >> A[i];\n        s = min(s,A[i]);\n    }\n    int ans = solve();\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 1010;\nint w[MAXN];\nbool done[MAXN];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, mini = 100000;\n    cin >> n;\n    map<int, int> mp;\n    for (int i = 0; i < n; i++) {\n        cin >> w[i];\n        mp[w[i]] = 0;\n        mini = min(mini, w[i]);\n    }\n    {\n        int k = 0;\n        for (auto& p : mp) p.second = k++;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (done[i]) continue;\n        int cnt = 0, now = i, mi = 100000, sum = 0;\n        while (1) {\n            if (done[now]) break;\n            cnt++;\n            done[now] = true;\n            mi = min(mi, w[now]);\n            sum += w[now];\n            now = mp[w[now]];\n        }\n        int tmp = sum+(cnt-2)*mi;\n        tmp = min(tmp, sum+mi+mini*(cnt+1));\n        ans += tmp;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\n\n#define MAX_N 1000\n\nstruct P {\n\tint index;\n\tint value;\n\tbool done;\n\tP(int i, int v) : index(i), value(v), done(false) {}\n\tP() : index(-1), value(-1), done(false) {}\n};\n\nbool compareP(P a, P b)\n{\n\treturn (a.value < b.value);\n}\n\nint A[MAX_N];\nP S[MAX_N];\nint D[MAX_N];\n\nstd::vector<std::vector<int> > Groups;\n\nint main(void) {\n\tint n;\n\tscanf(\"%d\", &n);\n\tint min = 10000;\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &A[i]);\n\t\tS[i].index = i;\n\t\tS[i].value = A[i];\n\t\tif (min > A[i]) {\n\t\t\tmin = A[i];\n\t\t}\n\t}\n\tstd::sort(S, S+n, compareP);\n\tfor (int i = 0; i < n; ++i) {\n\t\tD[S[i].index] = i;\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (S[i].done == true) continue;\n\t\tif (S[i].index == i) {\n\t\t\t//printf(\"%d don't move\\n\", S[i].value);\n\t\t\tS[i].done = true;\n\t\t\tcontinue;\n\t\t}\n\t\tstd::vector<int> group;\n\t\t//printf(\"start loop %d \", S[i].value);\n\t\tint idx = S[i].index;\n\t\tS[i].done = true;\n\t\tgroup.push_back(S[i].value);\n\t\twhile (true) {\n\t\t\tif (S[idx].done) break;\n\t\t\t//printf(\"%d \", S[idx].value);\n\t\t\tgroup.push_back(S[idx].value);\n\t\t\tS[idx].done = true;\n\t\t\tidx = S[idx].index;\n\t\t}\n\t\t//printf(\"\\n\");\n\t\tGroups.push_back(group);\n\t}\n\tint totalCost = 0;\n\tfor (size_t i = 0; i < Groups.size(); ++i) {\n\t\tstd::sort(Groups[i].begin(), Groups[i].end());\n\t\tint gn = Groups[i].size();\n\t\tint cost1 = 0;\n\t\tint cost2 = 0;\n\t\tfor (size_t j = 1; j < gn; ++j) {\n\t\t\tcost1 += Groups[i][j];\n\t\t\tcost1 += Groups[i][0];\n\t\t\tcost2 += Groups[i][j];\n\t\t\tcost2 += min;\n\t\t}\n\t\tcost2 += (min + Groups[i][0]) * 2;\n\t\tint cost = cost1 > cost2 ? cost2 : cost1;\n\t\ttotalCost += cost;\n\t}\n\tprintf(\"%d\\n\", totalCost);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<iomanip>\n#include<string.h>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<algorithm>\n\nusing namespace std;\n\nint cost = 0;\n\nvoid mincost(int c[], int a[], int k, int mina){\n  int minc = 10000;\n  int sum = 0;\n  for(int i = 0; i < k; i++){\n    minc = min(a[c[i]], minc);\n    sum += a[c[i]];\n  }\n  cost += min(sum + (k - 2) * minc, sum + minc + (k + 1) * mina);\n}\n\nint main(){\n\n  int n, mina = 10000;\n  cin >> n;\n\n  int a[n], b[n], c[n];\n  for(int i = 0; i < n; i++){\n    cin >> a[i];\n    b[i] = a[i];\n    mina = min(mina, a[i]);\n  }\n\n  sort(b, b + n);\n\n  int k = 0, i = 0, flag = 0;\n\n  while(flag != n){\n\n\n    c[k] = i;\n\n    for(i = 0; i < n; i++){\n      if(a[c[k]] == b[i]){\n        k++;\n        if(c[0] == i){\n          if(k > 1) mincost(c, a, k, mina);\n          for(int j = 0; j < k; j++){\n            a[c[j]] = -1;\n          }\n          k = 0;\n\n          flag  = 0;\n          for(int l = 0; l < n; l++){\n            if(a[l] == -1) flag++;\n            else{\n              i = l;\n              break;\n            }\n          }\n        }\n        break;\n      }\n    }\n  }\n\n\n\n\n\ncout << cost << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n,A[1010],O[1010];\nbool used[1010]; \n\nbool cmp(int a,int b)\n{\n\treturn A[a]<A[b];\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tint mi=INT_MAX;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&A[i]);\n\t\tO[i]=i;\n\t\tmi=min(mi,A[i]);\n\t}\n\tsort(O,O+n,cmp);\n\t//for(int i=0;i<n;i++) printf(\"%d\\n\",O[i]);\n\tmemset(used,false,sizeof(used));\n\tint ans=0;\n\tfor(int i=0;i<n;i++)\n\t\tif(!used[i])\n\t\t{\n\t\t\tint tot=0,tn=0,tmi=INT_MAX;\n\t\t\tfor(int j=i;!used[j];used[j]=true,j=O[j])\n\t\t\t{\n\t\t\t\ttmi=min(tmi,A[j]);\n\t\t\t\ttot+=A[j];\n\t\t\t\ttn++;\n\t\t\t}\n\t\t\tans+=min(tot+(tn-2)*tmi,tot+tmi+(tn+1)*mi);\n\t\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\n\nint num[1005],n,a[1005];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&num[i]);\n\t\ta[i] = num[i];\n\t}\n\tsort(a+1,a+n+1);\n\tint res = 0;\n\twhile(1)\n\t{\n\t\tbool ok = false;\n\t\tfor(int i=n;i>=1;i--)\n\t\t{\n\t\t\tif(num[i] == a[i]) continue;\n\t\t\tok = true;\n\t\t\tint id;\n\t\t\tfor(int j=1;j<=n;j++) if(num[j] == a[i]) id = j;\n\t\t\tswap(num[id],num[i]);\n\t\t\tres += (num[id]+num[i]);\n\t\t}\n\t\tif(!ok) break;\n\t}\n\tprintf(\"%d\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstatic const int MAX=1000;\nstatic const int VMAX=10000;\n\nint n, A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve() {\n  int ans=0;\n  bool V[MAX];\n  for (int i=0; i<n; i++) {\n    B[i]=A[i];\n    V[i]=false;\n  }\n  sort(B,B+n);\n  for (int i=0; i<n; i++) {\n    T[B[i]]=i;\n  }\n  for (int i=0; i<n; i++) {\n    if (V[i]) {\n      continue;\n    }\n    int cur=i;\n    int S=0;\n    int m=VMAX;\n    int an=0;\n    while (true) {\n      V[cur]=true;\n      an++;\n      int v=A[cur];\n      m=min(m,v);\n      S+=v;\n      cur=T[v];\n      if (V[cur]) {\n        break;\n      }\n    }\n    ans+=min(S+(an-2)*m,m+S+(an+1)*S);\n  }\n  return ans;\n}\nint main() {\n  cin>>n;\n  s=VMAX;\n  for (int i=0; i<n; i++) {\n    cin>>A[i];\n    s=min(s,A[i]);\n  }\n  int ans=solve();\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint getMinCost(int n, int a[]){\n\t\n\tbool flag[n];\n\tint b[n];\n\tint mn = 1 << 30;\n\tint mx = mn * -1;\n\tfor(int i=0; i<n; i++){\n\t\tflag[i]=false;\n\t\tb[i] = a[i];\n\t\tmn = min(mn, a[i]);\n\t\tmx = max(mx, a[i]);\n\t}\n\tsort(b, b+n);\n\t\n\tint p[mx+1];\n\tfor(int i=0;i<n;i++){\n\t\tp[b[i]] = i;\n\t}\n\t\n\tint cost=0;\n\tfor(int i=0; i<n; i++){\n\t\tif(flag[i]) continue;\n\t\tint idx=i;\n\t\tint m=mx;\n\t\tint sum=0;\n\t\tint cnt=0;\n\t\twhile(true){\n\t\t\tflag[idx]=true;\n\t\t\tint val=a[idx];\n\t\t\tsum+=val;\n\t\t\tcnt++;\n\t\t\tm=min(m,val);\n\t\t\tidx=p[val];\n\t\t\tif(flag[idx]) break;\n\t\t}\n\t\tint c1=sum+(cnt-2)*m;\n\t\tint c2=c1+(2*(m+mn));\n\t\tc2 -= (cnt-1)*(m-mn);\n\t\tcost+=min(c1, c2);\n\t}\n\treturn cost;\n}\n\nint main(){\n\t\n\tint n;\n\tcin >> n;\n\tint a[n];\n\tfor(int i=0; i<n; i++){\n\t\tcin >> a[i];\n\t}\n\t\n\tcout << getMinCost(n, a) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\nusing namespace std;\nstatic const int MAX = 200000;\n\nint bsearch(int data[], int target, int left, int right) {\n  // target in [left, ... ,right]\n  int mid;\n  while (left <= right) {\n    mid = (left + right) / 2;\n    if (data[mid] == target) {\n      return mid;\n    } else if (data[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  return -1;\n}\n\nint main() {\n  int n;\n  int data[MAX];\n  int sorted[MAX];\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> data[i];\n    sorted[i] = data[i];\n  }\n  sort(sorted, sorted + n);\n  int total = 0;\n  for (int i = 0; i < n; i++) {\n    int ans = sorted[i];\n    int x = data[i];\n    if (ans == x)\n      continue;\n\n    int count = 0;\n    int min = x;\n    int sum = x;\n    while (ans != x) {\n      int j = bsearch(sorted, x, 0, n - 1);\n      swap(x, data[j]);\n      sum += x;\n      if (x < min)\n        min = x;\n      count++;\n    }\n    data[i] = x;\n    total += sum + (count - 1) * min;\n  }\n\n  cout << total << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define repr(i, n) for (int i = (int)(n); i >= 0; i--)\n#define REP(i, m, n) for (int i = (int)(m); i <= (int)(n); i++)\n#define REPR(i, m, n) for (int i = (int)(m); i >= (int)(n); i--)\n#define all(v) v.begin(), v.end()\ntypedef long long ll;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst int INF = 1001001001;\n\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n;\nint A[MAX], B[MAX];\nbool V[MAX];\nint mi;\nint T[VMAX+1];\n\nint solve(){\n  rep(i, n){\n    B[i] = A[i];\n    V[i] = false;\n  }\n  sort(B, B+n);\n  rep(i, n) T[B[i]] = i;\n\n  int ans = 0;\n  rep(i, n){\n    if(V[i]) continue;\n    int cur = i;\n    int sum = 0;\n    int m = INF;\n    int an = 0;\n    while(1){\n      V[cur] = true;\n      an++;\n      int v = A[cur];\n      chmin(m, v);\n      sum += v;\n      cur = T[v];\n      if(V[cur]) break;\n    }\n    ans += min(sum+(an-2)*m, sum+m+(an+1)*mi);\n  }\n\n  return ans;\n}\n\nint main(){\n  cin >> n;\n  mi = INF;\n  rep(i, n){\n    cin >> A[i];\n    chmin(mi, A[i]);\n  }\n\n  cout << solve() << endl;\n\n  return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nint N,C[1005],c=0,t,p,cost=0;\nlong long res=0;\nmap<int,int>H;//number2order\nmap<int,int>rH;//order2number\nP nodes[1005],tmp[1005];\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++)\n\t\tscanf(\"%d\",C+i);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\ttmp[i].first=C[i];\n\t\ttmp[i].second=i;\n\t}\n\tsort(tmp,tmp+N);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tnodes[i].first=C[i];\n\t\tnodes[tmp[i].second].second=i;\n\t}\n\tint s=tmp[0].first;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tint j=nodes[i].second;\n\t\tif(j>=0&&j!=1)\n\t\t{\n\t\t\tint n=1,amin,sum;\n\t\t\tamin=sum=nodes[i].first;\n\t\t\twhile(j!=i)\n\t\t\t{\n\t\t\t\tint next=nodes[j].second;\n\t\t\t\tif(nodes[j].second<amin)\n\t\t\t\t\tamin=nodes[j].first;\n\t\t\t\tsum+=nodes[j].first;\n\t\t\t\tn++;\n\t\t\t\tnodes[j].second=-1;\n\t\t\t\tj=next;\n\t\t\t}\n\t\t\tcost+=min(sum+(n-2)*amin,sum+amin+(n+1)*s);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",cost);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\n#include<cmath>\nusing namespace std;\n\nvoid show( int arr[], size_t size )\n{\n\n\tcout<<arr[0]<<flush;\n    for( size_t i=1; i<size; i++ ){\n\t    cout<<' '<<arr[i]<<flush;\n    }\n    cout<<endl;\n}\n\nint min( int arr[], size_t left, size_t right )\n{\n\tif( left +1 < right ){ //????´????????????\\???????????¨???\n\t\tsize_t mid=(left+right)/2;\n\t\treturn min( min(arr, left, mid), min(arr, mid, right) );\n\t}else{\n\t\treturn arr[left];\n\t}\n}\n\n\nvoid swap( int &a, int &b )\n{\n\tint t=a;\n\ta=b;\n\tb=t;\n}\n\nsize_t partition(int arr[], size_t arr_s, size_t left, size_t right)\n{\n\tif( right >= arr_s ){\n\t\tcout<<\"Error\"<<endl;\n\t\treturn -1;\n\t}\n\n\n\tsize_t below=left-1;\n\n\tfor( size_t above=left; above<right; above++ ){\n\t\tif( arr[above] <= arr[right] ){\n\t\t\t++below;\n\t\t\tswap( arr[above], arr[below] );\n\t\t}\n\t}\n\tswap( arr[right], arr[below+1] ); \n\treturn below+1; \n}\n\n\nvoid quickSort( int *arr, size_t arr_s, size_t left, size_t right )\n{\n\tif( left < right ){\n\t\tsize_t pivot_i=partition( arr, arr_s, left, right );\n\t\tquickSort( arr, arr_s, left, pivot_i-1 );\n\t\tquickSort( arr, arr_s, pivot_i+1, right );\n\t}\n}\n\n\n/*\nint* findptr( int arr[], size_t arr_s, int key )\n{\n\tfor( size_t i=0; i!=arr_s; i++ ){\n\t\tif( arr[i] == key ) return *arr[i];\n\t}\n\treturn nullptr;\n}\n*/\nsize_t findidx( int arr[], size_t arr_s, int key )\n{\n\tfor( size_t i=0; i!=arr_s; i++ ){\n\t\tif( arr[i] == key ) return i;\n\t}\n\treturn arr_s;\n}\n\nunsigned int minCost( int arr[], size_t arr_s )\n{\n\tint *sorted=new int[arr_s];\n\tfor( size_t i=0; i<arr_s; i++ ){\n\t\tsorted[i]=arr[i];\n\t}\n\tquickSort(sorted, arr_s, 0, arr_s-1); //????????????????????¶?????¨???????????¨\n\n\n\t/*\n\t(????°???????????????????)= findptr(arr, arr_s, sorted[0])\n\t(?°????????????????3?????????????????????)= findptr(arr, arr_s, sorted[3])\n\t*/\n\n\tunsigned int cost=0;\n\tint swap_l_val, swap_l_idx, swap_r_val, swap_r_idx;\n\tfor( size_t i=0; ; ){ //?????¶???????¨?\n\t\tif( findidx( arr, arr_s, sorted[i] ) == i ){\n\t\t\ti++;\n\t\t}\n\t\tswap_l_idx= findidx(arr, arr_s, sorted[i]);\n\t\tswap_r_idx= findidx( arr, arr_s, sorted[findidx(arr, arr_s, sorted[i] ) ] );\n\t\tif( swap_l_idx == swap_r_idx ) break;\n\n\t\tswap_l_val=arr[ swap_l_idx];\n\t\tswap_r_val=arr[ swap_r_idx];\n//\t\tcout<<\"swap_l_val : \"<<swap_l_val<<' '<<\"swap_r_val : \"<<swap_r_val<<endl;\n\n\t\tswap( arr[ findidx(arr, arr_s, sorted[i]) ], arr[ findidx( arr, arr_s, sorted[findidx(arr, arr_s, sorted[i])] )]);\n\t\tcost+=swap_l_val + swap_r_val; \n\t}\n\treturn cost;\n}\n\nint main()\n{\n\tsize_t arr_s;cin>>arr_s;\n\tint *arr=new int[arr_s];\n\tfor( size_t i=0; i<arr_s; i++ ){\n\t\tcin>>arr[i];\n\t}\n\n\tlong long mincst=minCost( arr, arr_s );\n\tshow(arr, arr_s);\n\tcout<<mincst<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nconst int MAXN = 1010;\nint w[MAXN];\nbool done[MAXN];\nusing namespace std;\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, mini = 100000;\n    cin >> n;\n    map<int, int> mp;\n    for (int i = 0; i < n; i++) {\n        cin >> w[i];\n        mp[w[i]] = 0;\n        mini = min(mini, w[i]);\n    }\n    {\n        int k = 0;\n        for (auto& p : mp) p.second = k++;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (done[i]) continue;\n        int cnt = 0, now = i, mi = 100000, sum = 0;\n        while (1) {\n            if (done[now]) break;\n            cnt++;\n            done[now] = true;\n            mi = min(mi, w[now]);\n            sum += w[now];\n            now = mp[w[now]];\n        }\n        int tmp = sum+(cnt-2)*mi;\n        tmp = min(tmp, sum+mi+mini*(cnt+1));\n        ans += tmp;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n  \nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n  \nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n  \nint solve(){\n    int ans = 0;\n    bool V[MAX];\n    for (int i = 0; i < n; i++){\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B, B + n);\n    for (int i = 0; i < n; i++) T[B[i]] = i;\n    for (int i = 0; i < n; i++){\n        if (V[i]) continue;\n        int cur = i;\n    \tint S = 0;\n    \tint m = VMAX;\n    \tint an = 0;\n        while (1){\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m, v);\n            S += v;\n            cur = T[v];\n            if (V[cur]) break;\n        }\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n    }\n    return ans;\n}\n  \nint main(){\n    cin >> n;\n    s = VMAX;\n    for (int i = 0; i < n; i++){\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n    int ans = solve();\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve(){\n    int ans = 0;\n\n    bool V[MAX];\n    for(int i = 0;i<n;i++){\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B,B+n);\n    for(int i = 0;i<n;i++)\n        T[B[i]] = i;\n    for(int i = 0;i<n;i++){\n        if(V[i])\n            continue;\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        do{\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m,v);\n            S += v;\n            cur = T[v];\n        }while(!V[cur]);\n        ans += min(S + (an - 2)*m, m+S+(an+1)*S);\n    }\n    return ans;\n}\n\nint main(){\n    cin>>n;\n    s = VMAX;\n    for(int i = 0;i<n;i++){\n        cin>>A[i];\n        s = min(s,A[i]);\n    }\n    int ans = solve();\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define maxx 1010\n#define maxn 10010\n\nint C[maxn];\n\nint main(){\n\tint n,ans=0;\n\tint A[maxx],B[maxx];\n\tbool V[maxx];\n\tcin>>n;\n\tfor(int i =0;i<n;i++) {\n\t\tcin>>A[i];\n\t\tB[i]=A[i];\n\t\tV[i]=false;\n\t}\n\tsort(B,B+n);\n\tfor(int i=0;i<n;i++) C[B[i]]=i;\n\tint x=*min_element(A,A+n);\n\tfor(int i=0;i<n;i++){\n\t\tif(V[i]==true) continue;\n\t\tint s=0,minn=maxn,c_len=0;\n\t\tint cur=i;\n\t\twhile(V[cur]==false){\n\t\t\tc_len++;\n\t\t\ts+=A[cur];\n\t\t\tminn=min(minn,A[cur]);\n\t\t\tV[cur]=true;\n\t\t\tcur=C[A[cur]];\n\t\t}\n\t\tans+=min(s+(c_len-2)*minn,s+minn+(c_len+1)*x);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <cstdio>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\ninline int sorting(vector<short> v)\n{\n\tmap<vector<short>, int> d;\n\t\n\tvector<short> sorted(v.begin(), v.end());\n\t\n\tsort(v.begin(), v.end());\n\t\n\tqueue<pair<vector<short>, int> > que;\n\t\n\tque.push(make_pair(v, 1)); d[v] = 1; // pair(vector, cost + 1)\n\t\n\twhile(!que.empty())\n\t{\n\t\tvector<short> v1 = que.front().first;\n\t\t\n\t\tint cost = que.front().second; que.pop();\n\t\t\n\t\tfor(int i = 0; i < v.size(); i++)\n\t\t{\n\t\t    for(int j = i + 1; j < v.size(); j++)\n\t\t    {\n\t\t        vector<short> v2(v1.begin(), v1.end());\n\t\t        \n\t\t        int cost2 = cost + v1[i] + v1[j];\n\t\t        \n\t\t        swap(v2[i], v2[j]);\n\t\t        \n\t\t        if(d[v2] == 0 || d[v2] > cost2)\n\t\t        {\n\t\t            d[v2] = cost2;\n\t\t            \n\t\t            que.push(make_pair(v2, cost2));\n\t\t        }\n\t\t    }\n\t\t}\n\t}\n\t\n\treturn d[sorted] - 1;\n}\n\nint main()\n{\n\tvector<short> v; int n;\n\t\n\tscanf(\"%d\", &n); v = vector<short>(n);\n\t\n\tfor(int i = 0; i < n; i++) { scanf(\"%d\", &v[i]); }\n\t\n\tprintf(\"%d\\n\", sorting(v));\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    std::vector< int > ws(n);\n    for (auto &w: ws) std::cin >> w;\n\n    const int inf = 1001001001;\n    int min_w = inf;\n    for (auto w: ws) {\n        min_w = std::min(min_w, w);\n    }\n\n    std::vector< int > ps(n);\n    for (int i = 0; i < n; ++i) {\n        ps[i] = i;\n    }\n\n    std::sort(ps.begin(), ps.end(), [ws](int a, int b) { return ws[a] < ws[b]; });\n\n    int ans = 0;\n    std::vector< bool > used(n);\n    for (int i = 0; i < n; ++i) {\n        if (used[i]) continue;\n\n        used[i] = true;\n        int min_c = ws[i];\n        int sum_c = ws[i]; \n        int cnt = 1;\n        for (int j = ps[i]; j != i; j = ps[j]) {\n            min_c = std::min(min_c, ws[j]);\n            sum_c += ws[j];\n            cnt++;\n            used[j] = true;\n        }\n\n        ans += (sum_c - min_c) + std::min((cnt - 1) * min_c, (cnt + 1) * min_w + 2 * min_c);\n    }\n\n    std::cout << ans << std::endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <unordered_map>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nnamespace std{\n\ttemplate<typename T>\n\tinline void hash_combine(size_t& seed, T const& v){\n\t\tseed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n\t}\n    template<typename It>\n    inline size_t hash_range(It first, It last){\n\t\tsize_t seed=0;\n\t\thash_range(seed,first,last);\n\t\treturn seed;\n\t}\n\ttemplate<typename It>\n\tinline void hash_range(size_t& seed, It first, It last){\n\t\tfor(;first!=last;++first)hash_combine(seed, *first);\n\t}\n\ttemplate<typename A,typename B>\n\tclass hash<pair<A,B>>{\n\t\tpublic:\n\t\tsize_t operator()(pair<A,B> const &p) const{\n\t\t\tsize_t seed=0;\n\t\t\thash_combine(seed,p.first);\n\t\t\thash_combine(seed,p.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\ttemplate<typename T,size_t N>\n\tclass hash<array<T,N>>{\n\t\tpublic:\n\t\tsize_t operator()(array<T,N> const &container) const{\n\t\t\treturn hash_range(container.begin(),container.end());\n\t\t}\n\t};\n\ttemplate<typename T,typename A>\n\tclass hash<vector<T,A>>{\n\t\tpublic:\n\t\tsize_t operator()(vector<T,A> const &container) const{\n\t\t\treturn hash_range(container.begin(),container.end());\n\t\t}\n\t};\n}\n\nint main(){\n\tint N;\n\tscanf(\"%d\",&N);\n\tvector<int>v(N);\n\tfor(int i=0;i<N;i++)scanf(\"%d\",&v[i]);\n\tpriority_queue<pair<int,vector<int> > >q;\n\tunordered_map<vector<int>,int>depth;\n\n\tq.push(make_pair(0,v));\n\tint R;\n\tfor(;!q.empty();){\n\t\tpair<int,vector<int> >cur=q.top();\n\t\tq.pop();\n\t\tif(depth.find(cur.second)!=depth.end())continue;\n\t\tdepth[cur.second]=cur.first;\n\t\tbool f=false;\n\t\tfor(int i=0;i<N-1;i++)for(int j=i+1;j<N;j++)if(cur.second[i]>cur.second[j]){\n\t\t\tf=true;\n\t\t\tswap(cur.second[i],cur.second[j]);\n\t\t\tq.push(make_pair(cur.first-cur.second[i]-cur.second[j],cur.second));\n\t\t\tswap(cur.second[i],cur.second[j]);\n\t\t}\n\t\tif(!f){\n\t\t\tR=-cur.first;\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",R);\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : MinCostSort.cpp\n// Author      : Ken\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_W = 10000;\n\nvoid writeVector(vector<int>& v){\n\tfor(int i=0; i<v.size(); i++){\n\t\tcout << v.at(i) << \"\\n\";\n\t}\n}\n\nvoid writeVector(vector<bool>& v){\n\tfor(int i=0; i<v.size(); i++){\n\t\tcout << v.at(i) << \"\\n\";\n\t}\n}\n\nint main() {\n\tint n, input, min_all=MAX_W, total_sum=0;\n\tcin >> n;\n\tvector<int> v, inv_v(MAX_W);\n\tvector<bool> isIterated(n);\n\n\tfor(int i=0; i<isIterated.size(); i++){\n\t\tisIterated.at(i) = false;\n\t}\n\n\n\tfor(int i=0; i<n; i++){\n\t\tcin >> input;\n\t\tv.push_back(input);\n\t\tinv_v.at(input) = i;\n\t\tif(input<min_all){\n\t\t\tmin_all = input;\n\t\t}\n\t}\n\n\tsort(v.begin(), v.end());\n\n\t//cout << \"v:\\n\";\n\t//writeVector(v);\n\t//cout << \"inv_v:\\n\";\n\t//writeVector(inv_v);\n\t//cout << \"isIterated:\\n\";\n\t//writeVector(isIterated);\n\n\tfor(int i=0; i<v.size(); i++){\n\t\tint min_in_loop = MAX_W;\n\t\tint sum_loop = 0;\n\t\tint pos = i;\n\t\tint elem = v.at(i);\n\t\tint loop_size = 0;\n\n\t\tif(not isIterated.at(pos)){\n\t\t\tisIterated.at(pos) = true;\n\n\t\t\tif(inv_v.at(v.at(pos)) == pos){\n\t\t\t\t//cout << \"single loop: \" << v.at(pos) << \"\\n\";\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//cout << \"multi loop: \";\n\t\t\twhile(true){\n\t\t\t\tloop_size++;\n\t\t\t\tisIterated.at(pos) = true;\n\t\t\t\t//cout << elem << \" \";\n\n\t\t\t\tsum_loop += elem;\n\n\t\t\t\tif(elem < min_in_loop){\n\t\t\t\t\tmin_in_loop = elem;\n\t\t\t\t}\n\n\t\t\t\tpos = inv_v.at(elem);\n\t\t\t\telem = v.at(pos);\n\n\t\t\t\tif(isIterated.at(pos)){\n\t\t\t\t\t//cout << \"sum_loop: \" << sum_loop << \", min_in_loop: \" << min_in_loop << \" \"\n\t\t\t\t\t//\t << \"loop_size: \" << loop_size << \"\\n\";\n\t\t\t\t\t//cout << \"\\n\";\n\n\t\t\t\t\tint add = min(min_in_loop*(loop_size-2), min_in_loop + min_all*(loop_size+1));\n\n\t\t\t\t\ttotal_sum += sum_loop + add;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << total_sum << \"\\n\";\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define Vi vector<int>\n#define FOR(i,s,e) for (int i=s; i<e; i++)\n#define ITER(v) v.begin(), v.end()\n\nconstexpr int MAX_N = 1000;\nconstexpr int MAX_VAL = 10001;\n\nint merge(int* A, const int& left, const int& mid, const int& right) {\n    const int n1 = mid - left;\n    const int n2 = right - mid;\n\n    auto L = new int[n1+1];\n    auto R = new int[n2+1];\n    for (int i = 0; i < n1; i++) {\n        L[i] = A[left + i];\n    }\n    for (int i = 0; i < n2; i++) {\n        R[i] = A[mid + i];\n    }\n\n    L[n1] = MAX_VAL;\n    R[n2] = MAX_VAL;\n\n    int i = 0, j = 0;\n    for (int k = left; k < right; k++) {\n        if (L[i] <= R[j]) {\n            A[k] = L[i];\n            i++;\n        } else {\n            A[k] = R[j];\n            j++;\n        }\n    }\n    delete[] L;\n    delete[] R;\n    return right - left;\n}\n\nint mergeSort(int* A, const int& left, const int& right) {\n    int count = 0;\n    if (left + 1 < right) {\n        const int mid = (left + right) / 2;\n        count += mergeSort(A, left, mid);\n        count += mergeSort(A, mid, right);\n        return count + merge(A, left, mid, right);\n    }\n    return 0;\n}\n\nint minCostSort(int* w, int* ref, int n) {\n    int fixed = 0;\n    FOR(i,0,n) {\n        if (w[i] == ref[i]) {\n            w[i] = MAX_VAL;\n            ++fixed;\n        }\n    }\n    int cost = 0;\n    while (fixed < n) {\n        int* first = min_element(w, w+n);\n        int first_dest = distance(ref, lower_bound(ref, ref+n, *first));\n        int minval = *first;\n        *first = MAX_VAL;\n\n        int second_dest = distance(w, first);\n        int* second = find(w, w+n, ref[second_dest]);\n        int second_cur = distance(w, second);\n\n        cost += minval + *second;\n        *second = minval;\n        ++fixed;\n        if (second_cur == first_dest) {\n            *second = MAX_VAL;\n            ++fixed;\n        }\n    }\n    return cost;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int w[MAX_N];\n    int ref[MAX_N];\n    int n;\n\n    cin >> n;\n    FOR(i,0,n) {\n        cin >> w[i];\n        ref[i] = w[i];\n    }\n\n    sort(ref, ref+n);\n    int cost = minCostSort(w, ref, n);\n    cout << cost << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <iostream>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#define INTINF 2147483647\n#define LLINF 9223372036854775807\n#define MAX 1000\n#define VMAX 10000\ntypedef long long ll;\nusing namespace std;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint solve(){\n  int ans=0;\n\n  bool V[MAX];\n  for (size_t i = 0; i < n; i++) {\n    B[i]=A[i];\n    V[i]=false;\n  }\n  sort(B.begin(), B.end());\n\n  for (size_t i = 0; i < n; i++) T[B[i]]=i;\n  for (size_t i = 0; i < n; i++) {\n    if (V[i]) continue;\n    int cur = i;\n    int S = 0;\n    int m = VMAX;\n    int A_n = 0;\n    while (1) {\n      V[cur] = true;\n      A_n++;\n      int v = A[cur];\n      m = min(m, v);\n      S += v;\n      cur = T[v];\n      if (V[cur]) break;\n    }\n    ans += min(S + (A_n-2) * m, S + m + (A_n + 1)*s );\n  }\n\n  \n}\n\nint main(int argc, char const *argv[]) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  std::cin >> n;\n  s = VMAX;\n\n  for (size_t i = 0; i < n; i++) {\n    std::cin >> A[i];\n    s = min(s, A[i]);\n  }\n  int cost = solve();\n\n  std::cout << cost << '\\n';\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 1002\n\nint A[N], B[N], C[N];\nint minValue;\nlong cnt;\n\nstruct circleX {\n\tint n;\n\tint sum;\n\tint minOfThis;\n\tcircleX() {\n\t\tclear();\n\t}\n\tvoid clear() {\n\t\tn = 0;\n\t\tsum = 0;\n\t\tminOfThis = INT_MAX;\n\t}\n};\n\nint main(void) {\n\tcnt = 0;\n\tint n, i, index;\n\tcin >> n;\n\tfor (i = 0; i < n; i++) {\n\t\tcin >> A[i];\n\t\tB[i] = A[i];\n\t\tC[i] = 0;\n\t}\n\tsort(B, B + n);\n\tminValue = B[0];\n\tcircleX cir;\n\tint *p;\n\tfor (i = 0; i < n; i++) {\n\t\tindex = i;\n\t\tcir.clear();\n\t\twhile (C[index] == 0) {\n\t\t\tC[index] = 1;\n\t\t\tcir.n++;\n\t\t\tcir.sum += A[index];\n\t\t\tcir.minOfThis = min(cir.minOfThis, A[index]);\n\t\t\tp = lower_bound(B, B + n, A[index]);\n\t\t\tindex = distance(B, p);\n\t\t}\n\t\tif (cir.n > 1) {\n\t\t\tint x1 = (cir.sum + (cir.n - 2) * cir.minOfThis);\n\t\t\tint x2 = (cir.sum + cir.minOfThis + (cir.n + 1) * minValue);\n\t\t\tif (x1 <= x2)\n\t\t\t\tcnt += x1;\n\t\t\telse \n\t\t\t\tcnt += x2;\n\t\t}\n\t}\n\tcout << cnt << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define rep(i,k,n) for(int i=(int)(k);i<(int)(n);i++)\nusing namespace std;\nstatic const int MAX=1000;\nstatic const int VMAX=10000;\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve(){\n    int ans=0;\n\n    bool V[MAX];\n    rep(i,0,n){\n        B[i]=A[i];\n        V[i]=false;\n    }\n    sort(B,B+n);\n    rep(i,0,n) T[B[i]]=i;\n    rep(i,0,n){\n        if(V[i]) continue;\n        int cur=i;\n        int S=0;\n        int m=VMAX;\n        int an=0;\n        while(1){\n            V[cur]=true;\n            an++;\n            int v=A[cur];\n            m=min(m,v);\n            S+=v;\n            cur=T[v];\n            if(V[cur]) break;\n        }\n        ans+=min(S+(an-2)*m,m+S+(an+1)*s);\n    }\n    return ans;\n}\n\nint main(){\n    cin>>n;\n    s=VMAX;\n    rep(i,0,n){\n        cin>>A[i];\n        s=min(s,A[i]);\n    }\n    int ans=solve();\n    cout<<ans<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//  atcodder.xcode\n//  main.cpp\n//  Created by conan1024hao on 2019/11/11.\n//  Copyright © 2019 conan1024hao. All rights reserved.\n//  専用ライブラリ\n#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll>P;\n#define INF 10e16\n#define MOD 1000000007\n#define rep(i, a, n) for (ll i = a; i < (ll)(n); i++)\n#define fi first\n#define se second\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define PI acos(-1.0)\nlong long GCD(long long a, long long b) { return b ? GCD(b, a%b) : a; }\nlong long LCM(long long a, long long b)  {return a/GCD(a,b)*b;}\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nll cmp(pair<ll,string>a,pair<ll,string> b){\n        if(a.fi!=b.fi)\n        return a.fi<b.fi;\n        else\n        return a.se<b.se;\n}\n//---------------------------------------------------------------------------\nll n,s;\nvector<ll>a(10001);\nvector<ll>b(10001);\nvector<ll>t(100100);\nll solve(){\n    b.resize(n);\n    ll ans=0;\n    bool v[100001];\n    for(int i=0;i<n;i++){\n        b[i]=a[i];\n        v[i]=false;\n    }\n    sort(all(b));\n    for(int i=0;i<n;i++)\n        t[b[i]]=i;\n    for(int i=0;i<n;i++){\n        if(v[i])continue;\n        ll cur=i;\n        ll S=0;\n        ll m=INF;\n        ll an=0;\n        while(1){\n            v[cur]=true;\n            an++;\n            ll V=a[cur];\n            chmin(m,V);\n            S+=V;\n            cur=t[V];\n            if(v[cur])break;\n        }\n        ans+=mmin(S+(an-2)*m,m+S+(an+1)*s);\n    }\n    return ans;\n}\n//---------------------------------------------------------------------------\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------\n    cin>>n;\n    s=INF;\n    \n    for(int i=0;i<n;i++)\n    { cin>>a[i];\n        chmin(s,a[i]);}\n    ll ans=solve();\n    cout<<ans<<endl;\n    \n    //-------------------------------\n    return 0;\n}\n//---------------------------------------------------------------------------\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N; cin >> N;\n\tvector<int> w(N); rep(i, 0, N) { cin >> w[i]; }\n\tvector<int>v(w);\n\tsort(all(v));\n\tvector<int>T(10101);\n\trep(i, 0, N)T[v[i]] = i;\n\tvector<bool>f(N, false);\n\tint min_w = *min_element(all(w));\n\tint ans(0);\n\trep(i, 0, N) {\n\t\tif (f[i])continue;\n\t\tint sum(0),n(0),small(INF);\n\t\tint j = i;\n\t\twhile (!f[j]) {\n\t\t\tdump(j);\n\t\t\tchmin(small, w[j]);\n\t\t\tn++;\n\t\t\tf[j] = true;\n\t\t\tsum += w[j];\n\t\t\tj = T[w[j]];\n\t\t}\n\t\tans += min(sum + (n - 2)*small, 2 * (min_w + small) + sum - small + min_w + (n - 2)*min_w);\n\t\tdump(ans);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n\n\nusing namespace std;\n\nint main() {\n\t\n\tint const N_MAX = 1000;\n\tint const W_MAX = 10000;\n\n\tint n = 0;\n\tcin >> n;\n\n\tvector<int> W, S, T;\n\tvector<bool> C;\n\t\n\tW.resize(n, 0);     // idx -> W\n\tS.resize(n, 0);     // sorted Wi\n\tT.resize(W_MAX, 0); // W -> idx\n\tC.resize(n, false); // flag for searched or not\n\n\tint g_min = W_MAX; // global_min of Wi\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> W[i];\n\t\tg_min = (W[i] < g_min) ? W[i] : g_min;\n\t}\n\tif (g_min == 0) {\n\t\tint t = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tt += W[i];\n\t\t}\n\t\tcout << t << endl;\n\t\treturn 0;\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tT[W[i]] = i;\n\t}\n\n\tS = W;\n\tstable_sort(S.begin(), S.end());\n\n\tint score = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!C[T[S[i]]]) {\n\t\t\tint l_min = W_MAX;\n\t\t\tint sum = 0;\n\t\t\tint cnt = 0;\n\t\t\tfor(int j = S[i]; !C[T[j]]; j = S[T[j]] ) {\n\t\t\t\tC[T[j]] = true;\n\t\t\t\tcnt++;\n\t\t\t\tsum += j;\n\t\t\t\tl_min = (j < l_min) ? j : l_min;\n\t\t\t}\n\t\t\tscore += min(sum + l_min*(cnt - 2), sum+g_min*cnt+2*l_min);\n\t\t}\n\t}\n\n\tcout << score << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef struct D{\n\tint c;\n\tvector<P>W;\n\tbool operator <(const D &a)const{return c>a.c;}\n}D;\nint N,W[1005],C[1005],c=0,t,p,res=1000000000;\nmap<int,int>H;\nmap<int,int>rH;\nmap<vector<P>,int>MC;\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++)\n\t\tscanf(\"%d\",C+i);\n\tmemcpy(W,C,sizeof(C));\n\tsort(C,C+N);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tH[C[i]]=i;\n\t\trH[i]=C[i];\n\t}\n\tD tmp={0};\n\tfor(int i=0;i<N;i++)\n\t\ttmp.W.push_back(make_pair(W[i],H[W[i]]));\n\tMC[tmp.W]=0;\n\tpriority_queue<D>Q;\n\tQ.push(tmp);\n\tfor(;!Q.empty();)\n\t{\n\t\ttmp=Q.top();Q.pop();\n\t\tif(MC[tmp.W]!=0&&MC[tmp.W]<tmp.c)continue;\n\t\tint f=1;\n\t\tfor(int i=0;i<tmp.W.size();i++)\n\t\t{\n\t\t\tif(tmp.W[i].second!=i)\n\t\t\t{\n\t\t\t\tf=0;\n\t\t\t\tD ins=tmp;\n\t\t\t\tins.c+=tmp.W[i].first+tmp.W[tmp.W[i].second].first;\n\t\t\t\tswap(ins.W[i],ins.W[ins.W[i].second]);\n\t\t\t\tif(MC[ins.W]==0||MC[ins.W]>ins.c)\n\t\t\t\t{\n\t\t\t\t\tMC[ins.W]=ins.c;\n\t\t\t\t\tQ.push(ins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(f)\n\t\t\tres=min(res,tmp.c);\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minimumcostsort(int A[],int n){\n    pair<int,int> B[n];\n    int globalmin=A[0],Check[n]={0}\n    ,D[n],sum=0,localsum,localmin,lnum;\n    for(int i=0;i<n;i++){\n        B[i].second=i;\n        B[i].first=A[i];\n        globalmin=min(globalmin,A[i]);\n    }\n    sort(B,B+n);\n    for(int i=0;i<n;i++)D[B[i].second]=i;\n    for(int i=0;i<n;i++){\n        if(Check[i]==0){\n            localmin=A[i];\n            lnum=1;\n            localsum=A[i];\n            Check[i]=1;\n            int j=D[i];\n            while(j!=i){\n                localmin=min(localmin,A[j]);\n                localsum+=A[j];\n                lnum++;\n                Check[j]=1;\n                j=D[j];\n            }\n            sum+=min(localsum+(lnum-2)*localmin,localsum+(lnum+1)*globalmin+localmin);\n        }\n    }\n    return sum;\n}\n\nint main(){\n    int n;cin>>n;\n    int A[n];\n    for(int i=0;i<n;i++)scanf(\"%d\",&A[i]);\n    cout<<minimumcostsort(A,n)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX 1000\n#define VMAX 10000\n\nint n, A[MAX], s;\nint B[VMAX], T[VMAX + 1];\n\nint solve()\n{\n\tint ans = 0;\n\tbool V[MAX];\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tV[i] = false;\n\t\tB[i] = A[i];\n\t}\n\n\tsort(B, B + n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tT[B[i]] = i;\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (V[i])\n\t\t\tcontinue;\n\t\tint an = 0;//记录圈内元素个数\n\t\tint m = VMAX;//记录圈内最小元素\n\t\tint S = 0;//记录圈内所有元素之和\n\t\tint cur = i;//记录当前下标位置\n\t\twhile (1)\n\t\t{\n\t\t\tV[cur] = true;\n\t\t\tint v = A[cur];\n\t\t\tan++;\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif (V[cur])\n\t\t\t\tbreak;\n\t\t}\n\t\tans += min(S + (an - 2) * m, S + m + (an + 1) * s);\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tcin >> n;\n\ts = VMAX;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\n\tint ans = solve();\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n\n\nusing namespace std;\n\nint main() {\n\t\n\tint const N_MAX = 1000;\n\tint const W_MAX = 10000;\n\n\tint n = 0;\n\tcin >> n;\n\n\tvector<int> W, S, T;\n\tvector<bool> C;\n\t\n\tW.resize(n, 0);     // idx -> W\n\tS.resize(n, 0);     // sorted Wi\n\tT.resize(W_MAX, 0); // W -> idx\n\tC.resize(n, false); // flag for searched or not\n\n\tint g_min = 0; // global_min of Wi\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> W[i];\n\t\tg_min = (W[i] < g_min) ? W[i] : g_min;\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tT[W[i]] = i;\n\t}\n\n\tS = W;\n\tstable_sort(S.begin(), S.end());\n\n\tint score = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!C[T[S[i]]]) {\n\t\t\tint l_min = 0;\n\t\t\tint sum = 0;\n\t\t\tint cnt = 0;\n\t\t\tfor (int j = S[i];S[i] != S[T[j]]; j = S[T[j]] ) {\n\t\t\t\tC[T[j]] = true;\n\t\t\t\tcnt++;\n\t\t\t\tsum += j;\n\t\t\t\tl_min = (j < l_min) ? j : l_min;\n\t\t\t}\n\t\t\tscore += min(sum + l_min*(cnt - 2), sum+g_min*cnt+2*l_min);\n\t\t}\n\t}\n\n\tcout << score << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <bitset>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\n#define IINF 10e8\n#define INF 1<<30\n#define MOD 1000000007\n#define mod 1000000007\n#define REP(i, a, n) for (ll i = a; i < (ll)(n); i++)\n#define REPE(i, a, n) for (ll i = a; i <= (ll)(n); i++)\n#define Endl endl\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define eb emplace_back\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define siz(x) (ll)(x).size()\n#define PI acos(-1.0)\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef long double ld;\ntypedef pair<int,int>Pin;\ntypedef pair<ll,ll>Pll;\ntemplate<class T> using V=vector<T>;\nlong long GCD(long long a, long long b) {return b?GCD(b,a%b):a;}\nlong long LCM(long long a, long long b) {return a/GCD(a,b)*b;}\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\nint ddx[8]={-1,0,1,0,1,1,-1,-1};\nint ddy[8]={0,-1,0,1,1,-1,1,-1};\nll cmp(pair<ll,ll>a,pair<ll,ll> b){\n        if(a.se!=b.se)\n        return a.se<b.se;\n        else\n        return a.fi<b.fi;\n}\n//----------------------------------------------------------------------\nint color[1100];int ans=0;\n//----------------------------------------------------------------------\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------  \n    //ll begin_time=clock();\n    //------------------------------\n    int n;cin>>n;\n    V<int>w(n);\n    for(int i=0;i<n;i++)cin>>w[i];\n    V<int>cm(n);\n    for(int i=0;i<n;i++)cm[i]=w[i];sort(all(cm));\n    //for(int i=0;i<n;i++)cout<<cm[i]<<\" \";cout<<endl;\n    int minel=cm[0];\n    map<int,int>m,m2;\n    for(int i=0;i<n;i++){m[cm[i]]=i;m2[i]=cm[i];}\n    int ans=0;\n    for(int i=0;i<n;i++){\n        if(color[i])continue;\n        if(i!=m[w[i]]){\n            //cout<<w[i]<<endl;\n            V<int>chikan;\n            chikan.pb(w[i]);\n            int start=w[i];\n            int cmm = w[m[w[i]]];\n            //cout<<cmm<<endl;\n            chikan.pb(cmm);\n            int now=m[w[i]];\n            color[m[w[i]]]++;\n            color[i]++;\n            while(cmm!=start){\n                //cout<<m[cmm]<<\" \"<<now<<endl;\n                if(m[cmm]!=now){\n                    int should = m[cmm];\n                    int butis=w[should];\n                    cmm=butis;\n                    color[should]++;\n                    if(cmm!=start)chikan.pb(cmm);\n                }\n            }\n            sort(all(chikan));\n            //for(int i=0;i<chikan.size();i++)cout<<chikan[i]<<\" \";cout<<endl;\n            int tmp=0;\n            for(int i=0;i<chikan.size();i++){\n                if(i==0)tmp+=(chikan.size()-1)*chikan[i];\n                else tmp+=chikan[i];\n            }\n            int tmp2=0;\n            for(int i=0;i<chikan.size();i++){\n                tmp2+=chikan[i];\n                if(i==0)tmp2+=chikan[i];\n            }\n            tmp2+=(chikan.size()+1)*minel;\n            chmin(tmp,tmp2);\n            //cout<<tmp<<endl;\n            ans+=tmp;\n        }\n    }\n    cout<<ans<<endl;\n    //-------------------------------  \n    //ll end_time=clock();cout<<\"time=\"<<end_time-begin_time<<\"ms\"<<endl;\n    //-------------------------------\n    return 0;\n}\n//----------------------------------------------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint do_cycle(vector<int> &v,int x){\n\tint s=0,m=1<<30;\n\tfor(auto &e:v)s+=e,m=min(m,e);\n\treturn min(s+(v.size()-2)*m,s+m+(v.size()+1)*x);\n}\n\nint main(){\n\tint N,x=1<<30,r;\n\tscanf(\"%d\",&N);\n\tvector<int>v(N),b(N),se(N);\n\tmap<int,int>m;\n\tvector<vector<int> >cycles;\n\tfor(int i=0;i<N;i++)scanf(\"%d\",&v[i]),x=min(x,v[i]),se[i]=v[i];\n\tsort(se.begin(),se.end());\n\tint i=0;for(auto &e:se){m[e]=i++;}\n\tfor(int i=0;i<N;i++)if(!b[i]){\n\t\tvector<int>cycle;\n\t\tint k=i;\n\t\tdo{\n\t\t\tcycle.push_back(se[k]);\n\t\t\tb[k]=1;\n\t\t\tk=m[v[k]];\n\t\t}while(k!=i);\n\t\tr+=do_cycle(cycle,x);\n\t}\n\tprintf(\"%d\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n\n#include <cstdio>\nusing namespace std;\n\n\nint a1();\nvoid a2();\nint a3();\nint a4();\nint a5();\nint a6();\nint a7();\nint a8();\nint a9();\nint a10();\nint main()\n{\n\t//cout << a1() << endl;\n\t//a2();\n\t//a3();\n\t//a4();\n\ta10();\n\treturn 0;\n}\n//******************************10\n//最小成本排序\nint a10()\n{\n\tint Max = 10001;//元素最大值\n\tint Max1 = 1000;//元素数最大值\n\tint n;\n\tcin >> n;\n\tvector<int> vn;\n\tint temp;\n\tfor (int i = 0; i < n; i++)//原始vn\n\t{\n\t\tcin >> temp;\n\t\tvn.push_back(temp);\n\n\t}\n\tvector<int> bn;\n\tfor (int i = 0; i < n; i++)//\n\t{\n\t\tbn.push_back(vn[i]);\n\t}\n\tsort(bn.begin(), bn.end());//排序bn\n\n\t//for (int i = 0; i < n; i++)//打印调试\n\t//{\n\t//\tcout << bn[i] << \" \";\n\t//}\n\t//cout << endl;\n\n\tvector<int> cn(Max,0);\n\t\n\tfor (int i = 0; i < n; i++)//排序后数的索引\n\t{\n\t\t\n\t\tcn[(bn[i])] = i;\n\t\t//cout << cn[(bn[i])] << \" kk \" << endl;\n\t}\n\t/*\n\tfor (int i = 0; i < Max; i++)//打印调试\n\t{\n\t\tif (cn[i])\n\t\t\tcout << cn[i] << \" hh \";\n\t}\n\tcout << endl;\n\t*/\n\tvector<int> dn(Max1,0);\n\tvector<bool> f(Max1,0);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdn[i] = cn[vn[i]];//vn的i位置变为bn的dn[i]位置\n\t}\n\t/*\n\tfor (int i = 0; i < n; i++)//打印调试\n\t{\n\t\tcout << dn[i] << \" hh1 \";\n\t}\n\tcout << endl;\n\t*/\n\tint s = 0;//总和\n\tint s1 = 0;//每个环的和\n\t\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (f[i] == true)continue;//如果被遍历过就下一个元素\n\t\tint y = 0;//每个环元素个数\n\t\tint x = 0;//每个环的和\n\t\tint m = 10000;//每个环的最小值\n\t\tint t=i;\n\t\twhile (1)\n\t\t{\n\t\t\t//cout << t << \"tt\" << endl;\n\t\t\ty++;\n\t\t\tx = x + vn[t];\n\t\t\tm = min(m, vn[t]);\n\t\t\t//cout << y << \" \" << x << \" \" << m << \" \" << endl;\n\t\t\tf[t] = true;\n\t\t\tt = dn[t];\n\t\t\t\n\n\t\t\tif (f[t] == true) break;\n\t\t}\n\t\ts1 = min((x + (y - 2)*m), (x + m + (y + 1)*bn[0]));\n\t\t//cout << s1 << \"nn\" << endl;\n\t\ts += s1;\n\t}\n\tcout << s << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n\n//?£wi + (n - 2) * min(wi)\n//or\n//?£wi + min(wi) + (n+1) * x\n\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint A[MAX];\nint B[MAX];\nbool V[MAX];\nint T[VMAX];\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint s = VMAX;\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &A[i]);\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t\ts = min(s, A[i]);\n\t\tT[A[i]] = i;\n\t}\n\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tT[B[i]] = i;\n\t}\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (V[i] == true) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\n\t\twhile (1) {\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif (V[cur] == true) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tans += min(S + (an - 2) * m, S + m + (an + 1) * s);\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <climits>\nusing namespace  std;\n\nstruct StCst\n{\n  int m_nNo;\n  int m_nInSeq;\n  bool m_bDone;\n\n  static bool AsdNo(const StCst& cnroLeft, const StCst& cnroRight) \n  { return cnroLeft.m_nNo < cnroRight.m_nNo; }\n};\n\nvoid fnInput(int &rnMaxSiz, vector<StCst> &rvoSort, int &rnMinNo)\n{\n  int nCnt = 0;\n  cin >> rnMaxSiz;\n\n  rvoSort.resize(rnMaxSiz);\n  for (int i = 0; i < rnMaxSiz; i++)\n  {\n    cin >> rvoSort[i].m_nNo;\n    rnMinNo = min(rnMinNo, rvoSort[i].m_nNo);\n    rvoSort[i].m_nInSeq = nCnt++;\n  }\n}\n\nvoid fnMinCostSort(vector<StCst> &rvoSort, int nMinNo, int &rnSwpCnt)\n{\n  sort(begin(rvoSort), end(rvoSort), StCst::AsdNo);\n\n  int nCost;\n  for (int i = 0; i < rvoSort.size(); i++)\n  {\n    if (rvoSort[i].m_bDone)  continue;\n\n    int nTotal = rvoSort[i].m_nNo;\n    int nCurSize = 1;\n    int nCurMin = rvoSort[i].m_nNo; \n    rvoSort[i].m_bDone = true;\n\n    int j = rvoSort[i].m_nInSeq;\n    while  (rvoSort[j].m_nNo != rvoSort[i].m_nNo)\n    {\n      nTotal += rvoSort[j].m_nNo;\n      nCurSize++;\n      nCurMin = min(nCurMin, rvoSort[j].m_nNo);\n      rvoSort[j].m_bDone = true;\n      j = rvoSort[j].m_nInSeq;\n    }\n\n    if (nCurSize == 1)\n        nCost = 0;\n    else\n      if (nMinNo == nCurMin)\n        nCost = nTotal + (nCurSize - 2) * nCurMin;\n      else\n        nCost = min(nTotal + (nCurSize - 2) * nCurMin, \n                    nTotal + nCurMin + (nCurSize + 1) * nMinNo);\n    rnSwpCnt += nCost;\n  }\n}\n\nvoid fnResult(int nSwpCnt)\n{\n  cout << nSwpCnt << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int nMaxSiz;\n  vector<StCst> voSort;\n  int nMinNo = INT_MAX;\n\n  fnInput(nMaxSiz, voSort, nMinNo);\n\n  int nSwpCnt = 0;\n  fnMinCostSort(voSort, nMinNo, nSwpCnt);\n\n  fnResult(nSwpCnt);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nint n;\nint w[10001];\nint f[10001];\nint edge[10001];\nbool used[10001];\nvector<int> vs;\n\nvoid dfs(int v){\n\tused[v]=true;\n\tvs.push_back(w[v]);\n\tif(!used[edge[v]])dfs(edge[v]);\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&w[i]);\n\t\tf[i]=w[i];\n\t}\n\tsort(f,f+n);\n\tll res=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(f[i]==w[i])edge[i]=i;\n\t\telse edge[i]=lower_bound(f,f+n,w[i])-f;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(edge[i]!=i){\n\t\t\tvs.clear();\n\t\t\tdfs(i);\n\t\t\tint all=vs[0];\n\t\t\tint minx=vs[0];\n\t\t\tfor(int j=1;j<vs.size();j++){\n\t\t\t\tminx=min(minx,vs[j]);\n\t\t\t\tall+=vs[j];\n\t\t\t}\n\t\t\tres+=all+(vs.size()-2)*minx;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Macro_and_Function\n#pragma region Basic\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define FOR(i, a, b) for (int i = (a), i##_len = (b); i < i##_len; i++)\n#define FORD(i, a, b) for (int i = (a), i##_len = (b); i > i##_len; i--)\n#define FORR(t, a) for (auto t : a)\n#define ALL(x) (x).begin(), (x).end()  // sortなどの引数を省略したい\n#define INSERTER(x) inserter((x), (x).end())  // inserter\n#define GET(i, j) get<j>(i)\n#define MT(x, ...) make_tuple(x, __VA_ARGS__)\n#define SZ(x) ((int)(x).size())\n#define PB push_back\n#ifdef _DEBUG\n#define PRE_COMMAND             \\\n    std::cin.rdbuf(in.rdbuf()); \\\n    cout << fixed << setprecision(15);\n#else\n#define PRE_COMMAND cout << fixed << setprecision(15);\n#endif\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\ntemplate <class T>\nT DEG_2_RAD(T deg) {\n    return deg * PI / 180;\n}\ntemplate <class T>\nT RAD_2_DEG(T rad) {\n    return rad * 180 / PI;\n}\ntemplate <class T>\nauto MAX(T& seq) {\n    return *max_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto MIN(T& seq) {\n    return *min_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto SUM(T& seq) {\n    T temp{0};\n    auto& temp2 = temp[0];\n    return accumulate(seq.begin(), seq.end(), temp2);\n}\ntemplate <class T>\nvoid SORT(T& seq) {\n    sort(seq.begin(), seq.end());\n}\ntemplate <class T, class S>\nvoid SORT(T& seq, S& sort_order) {\n    sort(seq.begin(), seq.end(), sort_order);\n}\ntemplate <class T>\nvoid SORTR(vector<T>& seq) {\n    sort(seq.begin(), seq.end(), greater<T>());\n}\ntemplate <class T>\nvoid CHMAX(T& a, const T& b) {\n    if (a < b) { a = b; }\n}\ntemplate <class T>\nvoid CHMIN(T& a, const T& b) {\n    if (b < a) { a = b; }\n}\ntemplate <class T>\nset<T> VECTOR_2_SET(vector<T>& v) {\n    set<T> s;\n    for (auto ele : v) { s.insert(ele); }\n    return s;\n}\ntemplate <class T>\nvector<T> SET_2_VECTOR(set<T>& s) {\n    vector<T> v;\n    for (auto ele : s) { v.push_back(ele); }\n    return v;\n}\ntemplate <class T, class S, class R>\nlong long pow(T n_0, S k_0, R mod_0) {\n    long long n = n_0;\n    long long k = k_0;\n    long long mod = mod_0;\n    long long now = 1;\n    while (true) {\n        if (k & 1) { now = now * n % mod; }\n        k >>= 1;\n        if (k == 0) { return now; }\n        n = (n * n) % mod;\n    }\n}\n#pragma endregion Basic\n#pragma region overload\ntemplate <class T, class S>\nvoid operator+=(vector<T>& l, S& r) {\n    for (auto i : r) { l.push_back(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(set<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(multiset<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\nvoid operator*=(string& l, const size_t& r) {\n    string str = l;\n    for (size_t i = 0; i < r - 1; i++) { l += str; }\n}\ntemplate <class T, class S>\nvector<T> operator+(vector<T>& l, S& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T>\nvector<T> operator+(const vector<T> l, const vector<T>& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nset<T> operator+(set<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nset<T> operator+(const set<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nmultiset<T> operator+(multiset<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nmultiset<T> operator+(const multiset<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\nstring operator*(const string l, const size_t& r) {\n    string str = l;\n    for (size_t i = 0; i < r - 1; i++) { str += l; }\n    return str;\n}\n#pragma endregion overload\n#pragma region Input\ntemplate <class Head>\nvoid INPUT(vector<Head>& head);\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head);\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t);\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t);\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t);\ntemplate <class Head>\nvoid INPUT(Head& head);\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail);\n//本体\ntemplate <class Head>\nvoid INPUT(vector<Head>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t) {\n    cin >> get<0>(t);\n}\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t) {\n    cin >> get<0>(t) >> get<1>(t);\n}\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t);\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t);\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);\n}\ntemplate <class Head>\nvoid INPUT(Head& head) {\n    cin >> head;\n}\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail) {\n    INPUT(head);\n    INPUT((tail)...);\n}\n#pragma endregion Input\n#pragma region Print\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t);\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t);\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t);\ntemplate <class Head>\nvoid PRINT2(vector<Head> head);\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head);\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head);\ntemplate <class Head>\nvoid PRINT2(Head head);\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail);\ntemplate <class Head>\nvoid PRINT(Head head);\ntemplate <class... Head>\nvoid PRINT(Head... head);\ntemplate <int N, class Head>\nvoid PRINT(Head head);\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t) {\n    PRINT2(get<0>(t));\n}\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t) {\n    PRINT2(get<0>(t), get<1>(t));\n}\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t));\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t));\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t), get<4>(t));\n}\ntemplate <class Head>\nvoid PRINT2(vector<Head> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(Head head) {\n    cout << head;\n}\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail) {\n    PRINT2(head);\n    cout << \" \";\n    PRINT2((tail)...);\n}\ntemplate <class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\ntemplate <class... Head>\nvoid PRINT(Head... head) {\n    PRINT2((head)...);\n    cout << endl;\n}\ntemplate <int N, class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\n#pragma endregion Print\n#pragma endregion Macro_and_Function\n\nint main() {\n    PRE_COMMAND\n    int n;\n    INPUT(n);\n    vector<int> a(n), a_sort;\n    map<int, int> b;\n    set<int> c;\n    int ans = 0;\n    INPUT(a);\n    int m = MIN(a);\n    a_sort = a;\n    SORT(a_sort);\n    REP(i, n) { b[a_sort[i]] = i; }\n    REP(i, n) {\n        if (c.count(i)) { continue; }\n        int j = i;\n        vector<int> e;\n        while (true) {\n            c.insert(j);\n            e.PB(a[j]);\n            j = b[a[j]];\n            if (c.count(j)) { break; }\n        }\n        int sz = SZ(e);\n        int m2 = MIN(e);\n        int s = SUM(e);\n        ans += min(m2 * (sz - 2) + s, m2 + m * (sz + 1) + s);\n    }\n    PRINT(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\tmap<int,int> NP;\n\tvector<int> A(n),B(n);\n\tint nmin = (1 << 28);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> A[i];\n\t\tB[i] = A[i];\n\t\tnmin = min(A[i],nmin);\n\t\tNP[A[i]] = i;\n\t}\n\tsort(B.begin(),B.end());\n\tmap<int,int> TP;\n\tfor (int i = 0; i < n; ++i) {\n\t\tTP[B[i]] = i;\n\t}\n\n\tint ind = 0;\n\tvector<int> WPN(n,0);\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (A[i] != B[i]) {\n\t\t\tWPN[ind] = -A[i];\n\t\t\t++ind;\n\t\t}\n\t}\n\tsort(WPN.begin(),WPN.end());\n\n\tint res = 0;\n\tfor (int i = 0; WPN[i] < 0; ++i) {\n\t\tWPN[i] = -WPN[i];\n\t\tif (TP[WPN[i]] != NP[WPN[i]]) {\n\t\t\tint next = A[TP[WPN[i]]];\n\t\t\tif (TP[next] == NP[WPN[i]]) {\n\t\t\t\tres += next+WPN[i];\n\t\t\t\tNP[WPN[i]] = TP[WPN[i]];\n\t\t\t\tNP[next] = TP[next];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint nos = 0;\n\t\t\t\tint cost = WPN[i];\n\t\t\t\tint mc = (1 << 28);\n\t\t\t\tNP[WPN[i]] = TP[WPN[i]];\n\t\t\t\twhile (next != WPN[i]) {\n\t\t\t\t\tmc = min(next,mc);\n\t\t\t\t\tcost += next;\n\t\t\t\t\tNP[next] = TP[next];\n\t\t\t\t\tnext = A[TP[next]];\n\t\t\t\t\t++nos;\n\t\t\t\t}\n\t\t\t\tres += cost + min(mc*(nos-1),(nmin*nos)+(2*nmin)+mc);\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <utility>\n#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n\nusing namespace std;\n\ntypedef uint64_t u64;\ntypedef int64_t s64;\ntypedef uint32_t u32;\ntypedef int32_t s32;\ntypedef vector<s32> vs32;\ntypedef vector<u32> vu32;\ntypedef vector<s64> vs64;\ntypedef vector<u64> vu64;\n\nconst double PI=3.14159265358979323846;\n\n#define MAX(x, y) ((x) < (y) ? (y) : (x))\n#define MIN(x, y) ((x) > (y) ? (y) : (x))\n\n#define rep(i, N) for(int i = 0; i < N; ++i)\n\n#define CEIL(x, y) (((x) + (y) - 1) / (y))\n#define MOD 1000000007ULL\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n\n    vs32 w(n);\n    vs32 A(n);\n    vector< bool > done(n, false);\n    rep (i, n)\n    {\n      cin >> w[i];\n      A[i] = w[i];\n    }\n\n    sort(A.begin(), A.end());\n\n    map<int, int> m;\n    int gmin = A[0];\n    rep (i, n)\n    {\n      m[A[i]] = i;\n    }\n\n    int ans = 0;\n    rep (i, n)\n    {\n      if (done[i]) continue;\n      int first = w[i];\n      int now = w[m[first]];\n\n      int lmin = first;\n      int cnt = 0;\n\n      ans += first;\n      done[m[first]] = true;\n      while (now != first)\n      {\n\tans += now;\n\tdone[m[now]] = true;\n\tlmin = MIN(lmin, now);\n\tnow = w[m[now]];\n\t++cnt;\n      }\n      if (cnt - 1 > 0)\n      {\n\tans += MIN((cnt - 1) * lmin, (cnt + 2) * gmin + lmin);\n      }\n      else\n      {\n\tans += (cnt - 1) * lmin;\n      }\n      done[i] = true;\n    }\n\n    cout << ans << \"\\n\";\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <climits>\n\nconst int MAX_N = 1000;\n\nlong swap(std::vector<int> *A, int i, int j) {\n  int tmp = A->at(i);\n  A->at(i) = A->at(j);\n  A->at(j) = tmp;\n\n  return A->at(i) + A->at(j);\n}\n\nint partition(std::vector<int> *A, int left, int right, int pivot, int *weight) {\n  int l = left;\n  int r = right;\n\n  while (l <= r) {\n    while ((l <= right) && (A->at(l) < pivot)) {\n      l++;\n    }\n    \n    while ((r >= left) && (A->at(r) > pivot)) {\n      r--;\n    }\n\n    if (l >= r) {\n      break;\n    }\n\n    (*weight) += swap(A, l, r);\n    \n    l++;\n    r--;\n  }\n\n  return l;\n}\n\nvoid print_array(std::vector<int> *A, int left, int right) {\n  for (int i = left; i <= right; i++) {\n    std::cout << A->at(i) << \" \";\n  }\n\n  std::cout << std::endl;\n}\n\nlong quick_sort(std::vector<int> *A, int left, int right) {\n  if (left >= right) {\n    return 0;\n  }\n  \n  std::vector<int> *O = new std::vector<int>();\n  O->reserve(MAX_N);\n\n  for (int i = left; i <= right; i++) {\n    O->push_back(A->at(i));\n  }\n\n  long minWeight = LONG_MAX;\n\n  for (int i = left + 1; i < right; i++) {\n    int weight = 0;\n\n    //std::cout << \"########################\" << std::endl;\n    \n    //    print_array(A, left, right);\n    //    print_array(A, i, i);\n    int q = partition(A, left, right, A->at(i), &weight);\n    //    print_array(A, 0, A->size() - 1);    \n    //    std::cout << weight << \" \" << q << std::endl;\n      \n    weight += quick_sort(A, left, q - 1);\n    weight += quick_sort(A, q + 1, right);\n\n    if (weight < minWeight) {\n      minWeight = weight;\n    }\n\n    for (int j = left; j <= right; j++) {\n      A->at(j) = O->at(j - left);\n    }\n  }\n\n  if (minWeight == LONG_MAX) {\n    minWeight = 0;\n  }\n\n  return minWeight;\n}\n\nint main(void) {\n  std::ios_base::sync_with_stdio(false);\n\n  int n = 0;\n\n  std::cin >> n;\n\n  std::vector<int> *A = new std::vector<int>();\n  A->reserve(MAX_N);\n\n  for (int i = 0; i < n; i++) {\n    int w = 0;\n\n    std::cin >> w;\n    \n    A->push_back(w);\n  }\n\n  long weight = quick_sort(A, 0, A->size() - 1);\n\n  std::cout << weight << std::endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve() {\n    int ans = 0;\n    \n    bool V[MAX];\n    for(int i = 0; i < n; i++) {\n        B[i] = A[i];\n        V[i] = false;\n    }\n    \n    sort(B, B + n);\n    for(int i = 0; i < n; i++) T[B[i]] = i;\n    for(int i = 0; i < n; i++) {\n        if(V[i]) continue;\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while(1) {\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m, v);\n            S += v;\n            cur = T[v];\n            if(V[cur]) break;\n        }\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n    }\n    \n    return ans;\n}\n\nint main() {\n    cin >> n;\n    s = VMAX;\n    for(int i = 0; i < n; i++) {\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n    int ans = solve();\n    cout << ans << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n    int n;\n    cin >> n;\n    int A[n];\n    int B[n];\n    for (int i = 0; i < n; i++) {\n        cin >> A[i];\n        B[i] = A[i];\n    }\n    sort(B, B + n);\n    int cnt = 0;\n    for (int i = 0; i < n; i++) {\n        if (A[i] == B[i]) continue;\n        int* target = find(A, A + n, B[i]);\n        cnt += A[i] + *target;\n        swap(A[i], *target);\n    }\n    cout << cnt << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 100000;\n\nint n;\nvector<int> w;\nvector<bool> seen;\nvector<int> a;\nvector<int> t;\nint min_w = MAX;\n\nint calc_cycle(int s) {\n  seen[s] = true;\n  int cycle_min_w = w[s];\n  int cycle_len = 1;\n  int next =  t[w[s]];\n  int cycle_sum = w[s];\n  if (next == s) return 0;\n  while (!seen[next]) {\n    seen[next] = true;\n    cycle_min_w = min(cycle_min_w, w[next]);\n    cycle_len ++;\n    cycle_sum += w[next];\n    next = t[w[next]];\n  }\n  return min(cycle_sum + (cycle_len - 2) * cycle_min_w, cycle_sum + cycle_min_w + (cycle_len + 1) * min_w);\n}\n\nint main() {\n  cin >> n;\n  w.resize(n);\n  seen.resize(n, false);\n  t.resize(MAX);\n  for (int i = 0; i < n; i++) {\n    cin >> w[i];\n    min_w = min(min_w, w[i]);\n  }\n\n  a = w;\n  sort(a.begin(), a.end());\n  for (int i = 0; i < n; i++) {\n    t[a[i]] = i;\n  }\n\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    if (seen[i]) continue;\n    ans += calc_cycle(i);\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint n,mi;\nvector<int> w;\n\nint solve(){\n\n    int ret = 0;\n    vector<int> sub(w);\n    sort(sub.begin(),sub.end());\n    vector<int> cir(10001);\n    vector<bool> bol(n);\n\n    for(int i=0;i<n;i++){\n        cir[sub[i]] = i;\n        bol[i]=false;\n    }\n    for(int i=0;i<n;i++){\n        int sum=0,sn=0;\n        int loc=i;\n        int mmi=1e9;\n\n        for(;;){\n            bol[loc]=true;\n            sn++;\n            mmi=min(w[loc],mmi);\n            sum+=w[loc];\n            loc=cir[w[loc]];\n            if(bol[loc])break;\n        }\n        ret+=min(sum+(sn-2)*mmi,sum+mmi+mi*(sn+1));\n    }\n    return ret;\n}\n\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n;\n    mi = 1e9;\n    for(int i=0;i<n;i++){\n        int a;\n        cin >> a;\n        mi = min(mi,a);\n        w.push_back(a);\n    }\n    int ans = solve();\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstatic const int MAX=1000;\nstatic const int VMAX=10000;\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve()\n{\n    int ans=0;\n\n    bool V[MAX];\n    for(int i=0;i<n;++i)\n    {\n        B[i]=A[i];\n        V[i]=false;\n    }\n    sort(B,B+n);\n    for(int i=0;i<n;i++)\n    {\n        T[B[i]]=i;\n    }\n    for(int i=0;i<n;i++)\n    {\n        if(V[i])continue;\n        int cur=i;\n        int S=0;\n        int m=VMAX;\n        int an=0;\n        while(1)\n        {\n            V[cur]=true;\n            an++;\n            int v=A[cur];\n            m=min(m,v);\n            S+=v;\n            cur=T[v];\n            if(V[cur])break;\n        }\n        ans+=min(S+(an-2)*m,m+S+(an+1)*s);\n    }\n    return ans;\n}\n\nint main()\n{\n\tcin>>n;\n\ts=VMAX;\n\tfor(int i=0;i<n;i++)\n    {\n        cin>>A[i];\n        s=min(s,A[i]);\n    }\n    int ans=solve();\n    cout<<ans<<endl;\n \treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(void) {\n\tint n,a[1000];\n\tlong ans = 0;\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint max = a[0];\n\t\tint pos = 0;\n\t\tfor (int j = 0; j < n - i; j++) {\n\t\t\tif (max < a[j]) {\n\t\t\t\tmax = a[j];\n\t\t\t\tpos = j;\n\t\t\t}\n\t\t}\n\t\tif (pos != n - i - 1) {\n\t\t\tswap(a[pos], a[n - i - 1]);\n\t\t\tans += a[pos] + a[n - i - 1];\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define MAX_N 10000\n#define MAX_V 100000000\n#define INF 1000000000\n\nint n, A[MAX_N], s, B[MAX_N], T[MAX_V];\n\nint minimum_cost_sort() {\n\tint ans = 0;\n\tbool V[MAX_N];\n\tmemset(V, false, sizeof(V));\n\tfor (int i = 0; i < n; i++) { B[i] = A[i]; }\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; i++) { T[B[i]] = i; }\n\tfor (int i = 0; i < n; i++) {\n\t\tif (V[i]) { goto owata; }\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = INF;\n\t\tint x = 0;\n\t\twhile (1) {\n\t\t\tV[cur] = true;\n\t\t\tx++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif (V[cur]) { break; }\n\t\t}\n\t\tans += min(S + (x - 2)*m, m + S + (x + 1)*s);\n\towata:;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tcin >> n;\n\ts = INF;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tcout << minimum_cost_sort() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int num = 1001,num1 = 10000, INF = 2000000000;\nint n, a[num], b[num], c[num1], tf[num], s = INF;\ninline int mini() {\n\tint an = 0;\n\tint cu = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (tf[i]) continue;\n\t\tcu = i;\n\t\tint m = INF;\n\t\tint sum = 0;\n\t\tint cnt = 0;\n\t\twhile (true) {\n\t\t\ttf[cu] = 1;\n\t\t\tint v = a[cu];\n\t\t\tcnt++;\n\t\t\tm = min(v, m);\n\t\t\tsum += v;\n\t\t\tcu = c[v];\n\t\t\tif (tf[cu]) break;\n\t\t}\n\t\tan += min(sum + m*(cnt - 2), sum + m*(cnt - 2) + 2 * (m + s) - (m - s)*(cnt - 1));\n\t}\n\treturn an;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\ts = min(a[i], s);\n\t\tb[i] = a[i];\n\t\ttf[i] = 0;\n\t}\n\tsort(b, b + n);\n\tfor (int i = 0; i < n; i++) \n\t\tc[b[i]] = i;\n\tint ans = mini();\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long int;\nusing ULL = unsigned long long int;\nusing D = double;\nusing LD = long double;\n#define int LL\n// #define double LD\ntemplate <typename T> using V = std::vector<T>;\nusing VI = V<int>;\nusing VS = V<std::string>;\nusing VVI = V<V<int>>;\nusing VVVI = V<V<V<int>>>;\nusing VD = V<double>;\nusing VVD = V<V<double>>;\n#define VIIN(A) VI A(read()); for(auto&& e: A) { e = read(); }\n#define VSIN(A) VS A(read()); for(auto&& e: A) { e = readS(); }\n#define PB push_back\n#define RSV reserve\n#define EB emplace_back\n#define ALL(A) std::begin(A), std::end(A)\n#define SUM(A) std::accumulate(ALL(A), int(0))\n#define SUMD(A) std::accumulate(ALL(A), double(0))\n#define AVE(A) SUM(A)/(A).size()\n#define AVED(A) SUMD(A)/(A).size()\n#define MAX(A) *std::max_element(ALL(A))\n#define MIN(A) *std::min_element(ALL(A))\n#define SORT(A) std::sort(ALL(A))\n#define SSORT(A) std::stable_sort(ALL(A))\n#define SORTG(A) std::sort(ALL(A), std::greater<>())\n#define REV(A) std::reverse(ALL(A))\n#define UNQ(A) SORT(A); (A).erase(std::unique(ALL(A)), std::end(A))\n#define UNQG(A) SORTG(A); (A).erase(std::unique(ALL(A)), std::end(A))\nusing CD = std::complex<double>;\ntemplate <typename T1, typename T2> using P = std::pair<T1, T2>;\ntemplate <typename T> using PI = P<int, T>;\nusing PII = PI<int>;\nusing PIS = PI<std::string>;\nusing PSI = P<std::string, int>;\n#define MP std::make_pair\n#define F first\n#define S second\n#define FOR(var,a,b)  for (auto var=(a); var<(b); ++var)\n#define RFOR(var,a,b)  for (auto var=(b)-1; var!=(a); --var)\n#define REP(var,n)  for (decltype(n) var=0; var<(n); ++var)\n#define RREP(var,n)  for (auto var = n-1; var!=static_cast<decltype(var)>(-1); --var)\n#define YES(A) ((A) ? \"yes\" : \"no\")\nconstexpr int kMOD = 1e9+7;\nconst double kPI = std::acos(-1);\nstruct Read {\n\tauto operator()(void) { int d; std::cin >> d; return d; }\n}read;\nstruct ReadReal {\n\tauto operator()(void) { double d; std::cin >> d; return d; }\n}readR;\nstruct ReadString {\n\tauto operator()(void) { std::string s; std::cin >> s; return s; }\n}readS;\nstruct ReadEof {\n\tauto operator()(void) { return std::cin.eof(); }\n}readEof;\nstruct Print {\n\tvoid operator()(void) { std::cout << \" \"; }\n\tvoid operator()(double lf) {\n\t\tstd::cout << std::fixed << std::setprecision(8) << lf;\n\t}\n\ttemplate <typename T> void operator()(T t) {\n\t\tstd::cout << t;\n\t}\n\ttemplate <typename T>\n\tvoid operator()(const std::complex<T> &c, const std::string &sep = \" \") {\n\t\tPrint()(c.real());\n\t\tPrint()(sep);\n\t\tPrint()(c.imag());\n\t}\n\ttemplate <typename T1, typename T2>\n\tvoid operator()(const std::pair<T1, T2> &pair, const std::string &sep = \" \") {\n\t\tPrint()(pair.first);\n\t\tPrint()(sep);\n\t\tPrint()(pair.second);\n\t}\n\ttemplate <typename T>\n\tvoid operator()(T begin, T end, const std::string &sep = \" \") {\n\t\tif (begin == end) return;\n\t\tPrint()(*begin);\n\t\tfor(auto it = ++begin;  it != end; ++it) {\n\t\t\tPrint()(sep);\n\t\t\tPrint()(*it);\n\t\t}\n\t}\n\ttemplate <typename T>\n\tvoid operator()(const std::vector<T> &v, const std::string &sep = \" \") {\n\t\tPrint()(std::begin(v), std::end(v), sep);\n\t}\n\ttemplate <typename T>\n\tvoid operator()(std::initializer_list<T> list, const std::string &sep = \" \") {\n\t\tPrint()(std::begin(list), std::end(list), sep);\n\t}\n}print;\nstruct Println {\n\tvoid operator()(void) { std::cout << \"\\n\"; }\n\tvoid operator()(double lf) {\n\t\tPrint()(lf);\n\t\tPrintln()();\n\t}\n\ttemplate <typename T> void operator()(T t) {\n\t\tPrint()(t);\n\t\tPrintln()();\n\t}\n\ttemplate <typename T>\n\tvoid operator()(const std::complex<T> &c, const std::string &sep = \" \") {\n\t\tPrint()(c, sep);\n\t\tPrintln()();\n\t}\n\ttemplate <typename T1, typename T2>\n\tvoid operator()(const std::pair<T1, T2> &pair, const std::string &sep = \" \") {\n\t\tPrint()(pair, sep);\n\t\tPrintln()();\n\t}\n\ttemplate <typename T>\n\tvoid operator()(T begin, T end, const std::string &sep = \" \") {\n\t\tPrint()(begin, end, sep);\n\t\tPrintln()();\n\t\treturn;\n\t}\n\ttemplate <typename T>\n\tvoid operator()(const std::vector<T> &v, const std::string &sep = \" \") {\n\t\tPrint()(std::begin(v), std::end(v), sep);\n\t\tPrintln()();\n\t}\n\ttemplate <typename T>\n\tvoid operator()(std::initializer_list<T> list, const std::string &sep = \" \") {\n\t\tPrint()(std::begin(list), std::end(list), sep);\n\t\tPrintln()();\n\t}\n}println;\ninline void Main(void);\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tMain();\n\tstd::cout << std::flush;\n\treturn 0;\n}\n\nstruct MinimumCostSort {\n\tauto operator()(const std::vector<int> &weights) {\n\t\tconst auto weight_max\n\t\t\t= *std::max_element(weights.begin(), weights.end());\n\t\tstd::vector<int> weight_to_sorted_index(weight_max + 1);\n\t\t{\n\t\t\tauto sorted_weights(weights);\n\t\t\tstd::sort(sorted_weights.begin(), sorted_weights.end());\n\t\t\tfor (int i = 0; i < sorted_weights.size(); ++i) {\n\t\t\t\tweight_to_sorted_index[sorted_weights[i]] = i;\n\t\t\t}\n\t\t}\n\t\tstd::vector<bool> counted(weights.size(), false);\n\t\tint cost = 0;\n\t\tconst auto weight_min\n\t\t\t= *std::min_element(weights.begin(), weights.end());\n\t\tfor (int i = 0; i < weights.size(); ++i) {\n\t\t\tif (counted[i]) continue;\n\t\t\tint group_weight_all = 0;\n\t\t\tint group_weight_min = weight_max;\n\t\t\tint group_length = 0;\n\t\t\tint cursor = i;\n\t\t\twhile(!counted[cursor]) {\n\t\t\t\tcounted[cursor] = true;\n\t\t\t\tgroup_length++;\n\t\t\t\tconst auto weight = weights[cursor];\n\t\t\t\tgroup_weight_all += weight;\n\t\t\t\tgroup_weight_min = std::min(group_weight_min, weight);\n\t\t\t\tcursor = weight_to_sorted_index[weight];\n\t\t\t}\n\t\t\tconst int group_round_cost // グループ巡回時の移動コスト\n\t\t\t\t= group_weight_all + (group_length - 2) * group_weight_min;\n\t\t\tconst int min_rent_cost // グループ巡回時にグループ外の最小荷物を使った移動コスト\n\t\t\t\t= group_weight_all + group_weight_min + (group_length + 1) * weight_min;\n\t\t\tcost += std::min(group_round_cost, min_rent_cost);\n\t\t}\n\t\treturn cost;\n\t}\n}mincost_sort;\n\ninline void Main(void) {\n\tVIIN(v);\n\tint cost = mincost_sort(v);\n\tprintln(cost);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint n = 0, a[1000] = { 0 }, c = 0;\n\nint partition(int a[1000], int p, int r) {\n\tint x = a[r - 1];\n\tint i = p - 1;\n\n\tfor (int j = p; j < r; j++) {\n\t\tif (a[j - 1] <= x) {\n\t\t\ti++;\n\t\t\tswap(a[i - 1], a[j - 1]);\n\t\t\tif(i != j)\n\t\t\t\tc += a[i - 1] + a[j - 1];\n\t\t}\n\t}\n\tswap(a[i], a[r - 1]);\n\tif(i != r - 1)\n\t\tc += a[i] + a[r - 1];\n\n\treturn i + 1;\n}\n\nvoid QuickSort(int a[1000], int p, int r) {\n\tif (p < r) {\n\t\tint q = partition(a, p, r);\n\t\tQuickSort(a, p, q - 1);\n\t\tQuickSort(a, q + 1, r);\n\t}\n}\n\nint main()\n{\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\n\tQuickSort(a, 1, n);\n\n\tcout << c << endl;\n\n\tfor (int i = 0; i < n - 1; i++)\n\t\tcout << a[i] << \" \";\n\tcout << a[n - 1] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N; cin >> N;\n\tvector<int> v(N); rep(i, 0, N) { cin >> v[i]; }\n\tvector<int>w(v);\n\tsort(all(w));\n\tvector<int>T(10101, 0);\n\trep(i, 0, N)T[w[i]] = i;\n\tvector<bool>f(N, false);\n\tint ans(0);\n\tint min_value = *min_element(all(v));\n\trep(i, 0, N) {\n\t\tif (f[i])continue;\n\t\tint m = INF;\n\t\tint sum(0);\n\t\tint j = i;\n\t\tint n(0);\n\t\twhile (!f[j]) {\n\t\t\tf[j] = true;\n\t\t\tn++;\n\t\t\tsum += v[j];\n\t\t\tchmin(m, v[j]);\n\t\t\tj = T[v[j]];\n\t\t}\n\t\tans += min(sum + (n - 2)*m, 2 * (m + min_value) + sum - m + min_value + min_value*(n - 2));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int> W(n);\n    for (auto& w : W) cin >> w;\n\n    vector<int> Ws = W;\n    sort(Ws.begin(), Ws.end());\n\n    int cnt = 0;\n    int left = 0;\n    while (left < n - 1) {\n        int min_i = min_element(W.begin() + left, W.end()) - W.begin();\n        while (1) {\n            int tgt_i = find(W.begin() + left, W.end(), Ws[min_i])\n                        - W.begin();\n            if (tgt_i == min_i) break;\n            cnt += W[min_i] + W[tgt_i];\n            swap(W[min_i], W[tgt_i]);\n            min_i = tgt_i;\n        }\n        left++;\n    }\n    cout << cnt << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass UnionFind {\n\tvector<int> v;\npublic:\n\tUnionFind(int n) : v(n, -1) {}\n\tint find(int a) {\n\t\treturn v[a] < 0 ? a : v[a] = find(v[a]);\n\t}\n\tbool same(int a, int b) {\n\t\treturn find(a) == find(b);\n\t}\n\tvoid unite(int a, int b) {\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif (a == b) return;\n\t\tif (v[a] < v[b]) {\n\t\t\tv[a] += v[b];\n\t\t\tv[b] = a;\n\t\t}\n\t\telse {\n\t\t\tv[b] += v[a];\n\t\t\tv[a] = b;\n\t\t}\n\t}\n\tint size(int a) {\n\t\treturn -v[find(a)];\n\t}\n};\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<int> w(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> w[i];\n\t}\n\tauto a = w;\n\tsort(a.begin(), a.end());\n\tUnionFind uf(n);\n\tauto m = w;\n\tfor (int i = 0; i < n; i++) {\n\t\tint it = lower_bound(a.begin(), a.end(), w[i]) - a.begin();\n\t\tint a = uf.find(i), b = uf.find(it);\n\t\tuf.unite(a, b);\n\t\tm[uf.find(a)] = min(m[a], m[b]);\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (uf.size(i) > 1 && w[i] != m[uf.find(i)]) res += w[i] + m[uf.find(i)];\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int VMAX=10001;\nint T[VMAX+1];\nint solve(int A[],int n,int Min){\n  int ans=0;\n  int *B=new int[n];\n  bool *v=new bool[n];\n  for(int i=0;i<n;i++){\n  \tB[i]=A[i];\n  \tv[i]=false;\n  }\n\n  sort(B,B+n);\n  for(int i=0;i<n;i++) T[B[i]]=i;\n  for(int i=0;i<n;i++){\n  \tif(v[i])continue;\n  \tint an = 0;\n\tint m = VMAX;//\n\tint cur = i;\n\tint s = 0;\n\twhile(1){\n\t  \t  an++;\n\t      v[cur]=true;\n\t      int t=A[cur];\n\t      m=min(m,t);\n\t      s+=t;\n\t      cur=T[t];\n\t      if(v[cur])break;\n\t   }\n\n\t   ans+=min(s+(an-2)*m,s+m+(an+1)*Min);    \n\n  \t}\n   return ans;\n}\nint main(){\n\tint n;\n\tint Min=VMAX;//\n\tcin>>n;\n\tint *A=new int[n];\n\tfor(int i=0;i<n;i++){\n\t\tcin>>A[i];\n\t\tMin=min(Min,A[i]);\n\t}\n\tint ans=solve(A,n,Min);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * ALDS1_6_D.cpp\n *\n *  Created on: May 2, 2018\n *      Author: 13743\n */\n\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main() {\n\tint n;\n\tint A[1000];\n\tint B[1000];\n\tint aW[10001] = {-1};\n\tcin >> n;\n\tfor(int i=0; i<n; i++) {\n\t\tcin >> A[i];\n\t\tB[i] = A[i];\n\t\taW[A[i]] = i;\n\t}\n\n\tsort(B, B+n);\n\tint glMin = B[0];\n\tint rm = 0;\n\n\tfor(int i=0; i<n; i++) {\n\t\tif(aW[B[i]] == -1) continue;\n\t\tint c = 0;\n\t\tint lcMin = B[i];\n\t\tint j = aW[lcMin];\n\t\taW[lcMin] = -1;\n\t\trm -= lcMin;\n\t\twhile(j != -1) {\n\t\t\trm += A[j];\n\t\t\tc++;\n\t\t\tint a = B[j];\n\t\t\tj = aW[B[j]];\n\t\t\taW[a] = -1;\n\t\t}\n\t\trm += min(lcMin*(c-1), 2*(lcMin+glMin)+glMin*(c-1));\n\t}\n\n\tcout << rm << endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\n#include<cmath>\nusing namespace std;\n\nvoid show( int arr[], size_t size )\n{\n\n\tcout<<arr[0]<<flush;\n    for( size_t i=1; i<size; i++ ){\n\t    cout<<' '<<arr[i]<<flush;\n    }\n    cout<<endl;\n}\n\nint min( int arr[], size_t left, size_t right )\n{\n\tif( left +1 < right ){ //????´????????????\\???????????¨???\n\t\tsize_t mid=(left+right)/2;\n\t\treturn min( min(arr, left, mid), min(arr, mid, right) );\n\t}else{\n\t\treturn arr[left];\n\t}\n}\n\n\nvoid swap( int &a, int &b )\n{\n\tint t=a;\n\ta=b;\n\tb=t;\n}\n\nsize_t partition(int arr[], size_t arr_s, size_t left, size_t right)\n{\n\tif( right >= arr_s ){\n\t\tcout<<\"Error\"<<endl;\n\t\treturn -1;\n\t}\n\n\n\tsize_t below=left-1;\n\n\tfor( size_t above=left; above<right; above++ ){\n\t\tif( arr[above] <= arr[right] ){\n\t\t\t++below;\n\t\t\tswap( arr[above], arr[below] );\n\t\t}\n\t}\n\tswap( arr[right], arr[below+1] ); \n\treturn below+1; \n}\n\n\nvoid quickSort( int *arr, size_t arr_s, size_t left, size_t right )\n{\n\tif( left < right ){\n\t\tsize_t pivot_i=partition( arr, arr_s, left, right );\n\t\tquickSort( arr, arr_s, left, pivot_i-1 );\n\t\tquickSort( arr, arr_s, pivot_i+1, right );\n\t}\n}\n\n\n/*\nint* findptr( int arr[], size_t arr_s, int key )\n{\n\tfor( size_t i=0; i!=arr_s; i++ ){\n\t\tif( arr[i] == key ) return *arr[i];\n\t}\n\treturn nullptr;\n}\n*/\nsize_t findidx( int arr[], size_t arr_s, int key )\n{\n\tfor( size_t i=0; i!=arr_s; i++ ){\n\t\tif( arr[i] == key ) return i;\n\t}\n\treturn arr_s;\n}\n\nunsigned int minCost( int arr[], size_t arr_s )\n{\n\tint *sorted=new int[arr_s];\n\tfor( size_t i=0; i<arr_s; i++ ){\n\t\tsorted[i]=arr[i];\n\t}\n\tquickSort(sorted, arr_s, 0, arr_s-1); //????????????????????¶?????¨???????????¨\n\n\n\t/*\n\t(????°???????????????????)= findptr(arr, arr_s, sorted[0])\n\t(?°????????????????3?????????????????????)= findptr(arr, arr_s, sorted[3])\n\t*/\n\n\tunsigned int cost=0;\n\tint swap_l_val, swap_l_idx, swap_r_val, swap_r_idx;\n\tfor( size_t i=0; ; ){ //?????¶???????¨?\n\t\tif( findidx( arr, arr_s, sorted[i] ) == i ){\n\t\t\ti++;\n\t\t}\n\t\tswap_l_idx= findidx(arr, arr_s, sorted[i]);\n\t\tswap_r_idx= findidx( arr, arr_s, sorted[findidx(arr, arr_s, sorted[i] ) ] );\n\t\tif( swap_l_idx == swap_r_idx ) break;\n\n\t\tswap_l_val=arr[ swap_l_idx];\n\t\tswap_r_val=arr[ swap_r_idx];\n//\t\tcout<<\"swap_l_val : \"<<swap_l_val<<' '<<\"swap_r_val : \"<<swap_r_val<<endl;\n\n\t\tswap( arr[ findidx(arr, arr_s, sorted[i]) ], arr[ findidx( arr, arr_s, sorted[findidx(arr, arr_s, sorted[i])] )]);\n\t\tcost+=swap_l_val + swap_r_val; \n\t}\n\treturn cost;\n}\n\nint main()\n{\n\tsize_t arr_s;cin>>arr_s;\n\tint *arr=new int[arr_s];\n\tfor( size_t i=0; i<arr_s; i++ ){\n\t\tcin>>arr[i];\n\t}\n\n\tlong long mincst=minCost( arr, arr_s );\n//\tshow(arr, arr_s);\n\tcout<<mincst<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<stdlib.h>\n#include<cstdio>\n#include<stdio.h>\n#include<set>\n#include<map>\n#include<deque>\n#include<stack>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<sstream>\n#include<fstream>\n#include<time.h>\nusing namespace std;\nconst int maxn = 1010;\nint a[maxn], id[maxn], pos[maxn];\ninline bool cmp(int x, int y) { return a[x] < a[y]; }\nint main()\n{\n\tint n;long long ans = 0;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1;i <= n;i++)\n\t{\n\t\tscanf(\"%d\", a + i);\n\t\tid[i] = i;\n\t}\n\tsort(id + 1, id + 1 + n,cmp);\n\tfor (int i = 1;i <= n;i++)pos[id[i]] = i;\n\tfor (int i = n;i;i--)\n\t{\n\t\tif (id[i] != i)\n\t\t\tans = ans + a[id[i]] + a[i];\n\t\tid[pos[i]] = id[i];\n\t\tswap(pos[i], pos[id[pos[i]]]);\n\t\tid[i] = i;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass UnionFind {\n\tvector<int> v;\n\tvector<int> mini;\npublic:\n\tUnionFind(const vector<int>& val) : v(val.size(), -1), mini(val) {}\n\tint find(int a) {\n\t\treturn v[a] < 0 ? a : v[a] = find(v[a]);\n\t}\n\tbool same(int a, int b) {\n\t\treturn find(a) == find(b);\n\t}\n\tvoid unite(int a, int b) {\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif (a == b) return;\n\t\tif (v[a] < v[b]) {\n\t\t\tmini[a] = min(mini[a], mini[b]);\n\t\t\tv[a] += v[b];\n\t\t\tv[b] = a;\n\t\t}\n\t\telse {\n\t\t\tmini[b] = min(mini[a], mini[b]);\n\t\t\tv[b] += v[a];\n\t\t\tv[a] = b;\n\t\t}\n\t}\n\tint get(int a) {\n\t\treturn mini[find(a)];\n\t}\n\tint size(int a) {\n\t\treturn -v[find(a)];\n\t}\n};\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<int> w(n);\n\tint mini = 1e4 + 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> w[i];\n\t\tmini = min(mini, w[i]);\n\t}\n\tauto a = w;\n\tsort(a.begin(), a.end());\n\tUnionFind uf(w);\n\tfor (int i = 0; i < n; i++) {\n\t\tint it = lower_bound(a.begin(), a.end(), w[i]) - a.begin();\n\t\tuf.unite(i, it);\n\t}\n\tint res = 0;\n\tvector<int> rts;\n\tfor (int i = 0; i < n; i++) {\n\t\tres += w[i] + (uf.get(i) == w[i] ? -w[i] : uf.get(i));\n\t\tif (i == uf.find(i)) rts.push_back(i);\n\t}\n\tfor (auto rt : rts) {\n\t\tif (uf.get(rt) == mini) continue;\n\t\tint dis = (uf.get(rt) - mini) * (uf.size(rt) - 1) - (uf.get(rt) + mini) * 2;\n\t\tif (dis > 0) {\n\t\t\tcout << uf.get(rt) << ' ' << uf.size(rt) << ' ' << dis << endl;\n\t\t\tres -= dis;\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define MIN(a,b) ((a)<(b)?(a):(b))\n\nvoid merge(vector<pair<int,int> >& w, int left, int mid, int right) {\n\tvector<pair<int,int> > L,R;\n\tint n1=mid-left;\n\tint n2=right-mid;\n\tint i=0,j=0,k;\n\tL.resize(n1+1);\n\tR.resize(n2+1);\n\tfor(i=0; i<n1; ++i) {\n\t\tL[i]=w[left+i];\n\t}\n\tL[n1].first = -1;\n\tL[n1].second = 1000000001;\n\tfor(i=0; i<n2; ++i) {\n\t\tR[i]=w[mid+i];\n\t}\n\tR[n2].first = -1;\n\tR[n2].second = 1000000001;\n\n\ti=j=0;\n\tfor(k=left; k<right; ++k) {\n\t\tif(L[i].second < R[j].second) {\n\t\t\tw[k]=L[i];\n\t\t\t++i;\n\t\t} else {\n\t\t\tw[k]=R[j];\n\t\t\t++j;\n\t\t}\n\t}\n\treturn;\n}\n\nvoid mergeSort(vector<pair<int,int> >& w, int left, int right) {\n\tif(left+1<right) {\n\t\tint mid=left+(right-left)/2;\n\t\tmergeSort(w,left,mid);\n\t\tmergeSort(w,mid,right);\n\t\tmerge(w,left,mid,right);\n\t}\n\treturn;\n}\n\nint main() {\n\tint n;\n\tint i,j;\n\tint total=0;\n\tint subtotal,c;\n\tvector<int> checker;\n\tvector<pair<int,int> > w; // first=original_index, second =weight_value will be sorted.\n\tscanf(\"%d\",&n);\n\tw.resize(n);\n\tchecker.resize(n);\n\tfor(i=0; i<n; ++i) {\n\t\tchecker[i]=0;\n\t\tw[i].first=i;\n\t\tscanf(\"%d\",&w[i].second);\n\t}\n\tmergeSort(w,0,n);\n\tfor(i=0; i<n; ++i) {\n\t\tif(checker[i]==1 || w[i].first==i) {\n\t\t\tcontinue; // already checked or unmoved\n\t\t}\n\t\tc=subtotal=0;\n\t\tchecker[i]=1;\n\t\tj=w[i].first;\n\t\twhile(j!=i) {\n\t\t\tsubtotal+=w[i].second+w[j].second;\n\t\t\tchecker[j]=1;\n\t\t\tj=w[j].first;\n\t\t\t++c;\n\t\t}\n\t\ttotal+=MIN(subtotal,subtotal-w[j].second*(c-2)+w[0].second*(c+2));\n\t}\n\tprintf(\"%d\\n\",total);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 最小コストどーと\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<vector>\n\nusing namespace std;\n\n#define MAX_N 1000\n//const int INFTY = 2147483647;\n\nint minCostSort(int A[], int n);\n\nint main(void)\n{\n    int n;\n    int baggage[MAX_N];\n\n    cin >> n;\n\n    for(int i = 0; i < n; i++)\n    {\n        cin >> baggage[i];\n    }\n\n    int cost;\n    cost = minCostSort(&baggage[0], n);\n\n    cout << cost << endl;\n\n    return 0;\n}\n\n// 選択ソートを実施する関数\nint minCostSort(int A[], int n)\n{\n\n    int cost = 0;\n    int count = 0;\n    // 最小値の存在する配列の要素No.\n    int min_pos;\n\n    for(int i = 0; i < n - 1; i++)\n    {\n        min_pos = i;\n\n        for(int j = i; j < n; j++)\n        {\n            if( A[j] < A[min_pos] )\n            {\n                // 最小値の存在する位置を保存する\n                min_pos = j;\n            }\n        }\n\n        if( i != min_pos )\n        {\n            // 最小値を交換する\n            swap(A[i], A[min_pos]);\n\n            count++;\n\n            cost = A[i] + A[min_pos];\n        }\n    }\n\n    return cost;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n \n#define MAX 100000\n \nbool cmp(const int n1, const int n2) {\n    return n1 < n2;\n}\n \nstruct Data {\n    int num;\n    int i;\n};\n \nint main() {\n    int n;\n    int minValue = MAX;\n    int sortAry[1000];\n    Data ary[1000];\n    vector<vector<int> > groups;\n    int cost = 0;\n \n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        int temp;\n        cin >> temp;\n        sortAry[i] = ary[i].num = temp;\n        minValue = min(minValue, temp);\n    }\n \n    sort(sortAry, sortAry + n, cmp);\n     \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (ary[i].num == sortAry[j]) {\n                ary[i].i = j;\n                break;\n            }\n        }\n    }\n \n    for (int i = 0; i < n; i++) {\n        vector<int> group;\n        int j = i;\n        int s = i;\n        while (j != ary[j].i) {\n            group.push_back(ary[j].num);\n \n            int temp = ary[j].i;\n            ary[j].i = j;\n            j = temp;\n        }\n        if (!group.empty()) {\n            groups.push_back(group);\n        }\n    }\n \n    for (int i = 0; i < groups.size(); i++) {\n        int sum = 0;\n        int m = MAX;\n        int num = groups[i].size();\n \n        for (int j = 0; j < num; j++) {\n            sum += groups[i][j];\n            m = min(groups[i][j], m);\n        }\n \n        int c1, c2;\n        c1 = sum + (num - 2) * m;\n        c2 = sum + (num + 1) * minValue + m;\n        cost += min(c1, c2);\n    }\n \n    cout << cost << endl;\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n;\n  cin >> n;\n\n  vector<int> a(n);\n  for(int i=0;i<n;i++)cin >> a[i];\n\n  vector<int> order = a, p = a;\n  sort(order.begin(), order.end());\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(a[i] == order[j])p[i] = j;\n    }\n  }\n\n  long long ans = 0;\n  vector<bool> use(n,0);\n  for(int i=0;i<n;i++){\n    if(!use[i]){\n      int cur = i, minv = 1e8, sum = 0, len = 0;\n      do{\n\tuse[cur] = 1;\n\tminv = min(minv, a[cur]);\n\tsum += a[cur];\n\tcur = p[cur];\n\tlen++;\n      }while(cur!=i);\n      ans += sum + minv*(len-2);\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nstatic const int Max = 1000;\nstatic const int Vmax = 10000;\n\nint n, s, A[Max], B[Max], T[Vmax + 1];\n\nint solve(){\n  int ans = 0;\n\n  bool V[Max];\n\n  for(int i = 0; i < n; i++){\n    B[i] = A[i];\n    V[i] = false;\n  }\n  sort(B, B + n);\n\n  for(int i = 0; i < n; i++){\n    T[B[i]] = i;\n  }\n  for(int i = 0; i < n; i++){\n    if(V[i]) continue;\n\n    int cur = i, S = 0, m = Vmax, an = 0;\n\n    while(1){\n      V[cur] = true;\n      an++;\n\n      int v = A[cur];\n\n      m = min(m, v);\n      S += v;\n      cur = T[v];\n\n      if(V[cur]) break;\n    }\n    ans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n  }\n\n  return ans;\n}\n\nint main(){\n  cin >> n;\n\n  s = Vmax;\n  for(int i = 0; i < n; i++){\n    cin >> A[i];\n    s = min(s, A[i]);\n  }\n  int ans = solve();\n  \n  cout << ans << endl;\n\n  return 0;\n}\n   \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass UnionFind {\n\tvector<int> v;\n\tvector<int> mini;\npublic:\n\tUnionFind(const vector<int>& val) : v(val.size(), -1), mini(val) {}\n\tint find(int a) {\n\t\treturn v[a] < 0 ? a : v[a] = find(v[a]);\n\t}\n\tbool same(int a, int b) {\n\t\treturn find(a) == find(b);\n\t}\n\tvoid unite(int a, int b) {\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif (a == b) return;\n\t\tif (v[a] < v[b]) {\n\t\t\tmini[a] = min(mini[a], mini[b]);\n\t\t\tv[a] += v[b];\n\t\t\tv[b] = a;\n\t\t}\n\t\telse {\n\t\t\tmini[b] = min(mini[a], mini[b]);\n\t\t\tv[b] += v[a];\n\t\t\tv[a] = b;\n\t\t}\n\t}\n\tint get(int a) {\n\t\treturn mini[find(a)];\n\t}\n\tint size(int a) {\n\t\treturn -v[find(a)];\n\t}\n};\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<int> w(n);\n\tint mini = 1e4 + 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> w[i];\n\t\tmini = min(mini, w[i]);\n\t}\n\tauto a = w;\n\tsort(a.begin(), a.end());\n\tUnionFind uf(w);\n\tfor (int i = 0; i < n; i++) {\n\t\tint it = lower_bound(a.begin(), a.end(), w[i]) - a.begin();\n\t\tuf.unite(i, it);\n\t}\n\tint res = 0;\n\tvector<int> rts;\n\tfor (int i = 0; i < n; i++) {\n\t\tres += w[i] + (uf.get(i) == w[i] ? -w[i] : uf.get(i));\n\t\tif (i == uf.find(i)) rts.push_back(i);\n\t}\n\tfor (auto rt : rts) {\n\t\tif (uf.get(rt) == mini) continue;\n\t\tint dis = (uf.get(rt) - mini) * (uf.size(rt) - 1) - (uf.get(rt) + mini) * 2;\n\t\tif (dis > 0) {\n\t\t\tres -= dis;\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<math.h>\n#define Lens 1000\n\nusing namespace std;\nint N,mini;\nint A[Lens], B[Lens],C[Lens];\nbool V[Lens];\n\nint solve()\n{\n\tint total=0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B, B + N);\n\tmini = B[0];\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tC[B[i]] = i;\n\t\tif (B[i] == A[i]) V[i] = true;\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\twhile (V[i] == false)\n\t\t{\n\t\t\tint tmp = A[i];\n\t\t\tint min_tmp;\n\t\t\tint next = C[A[i]];\n\t\t\tint sum =A[i];\n\t\t\tint n = 0;\n\t\t\tV[i] = true;\n\t\t\tmin_tmp= min(A[i], A[next]);\n\t\t\twhile (!V[next])\n\t\t\t{\n\t\t\t\tn++;\n\t\t\t\tV[next] = true;\n\t\t\t\tsum = sum + A[next];\n\t\t\t\tif (A[next] < min_tmp) \n\t\t\t\t\tmin_tmp = A[next];\n\t\t\t\tnext= C[A[next]];\n\t\t\t}\n\t\t\ttotal = total + min(sum + (n - 1)*min_tmp, sum + min_tmp + (n + 2)*mini);\n\t\t}\n\t\t\n\t}\n\treturn total;\n}\n\nint main()\n{\n\tcin >> N;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> A[i];\n\t}\n\tint s = solve();\n\tcout << s << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<int> v(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%d\", &v[i]);\n\t}\n\tint ans = 0;\n\tfor(int i = n - 1; i > 0; --i){\n\t\tint j = max_element(v.begin(), v.begin() + (i + 1)) - v.begin();\n\t\tif(i != j){\n\t\t\tans += v[i] + v[j];\n\t\t\tv[j] = v[i];\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n \nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n \nint solve(){\n    int ans = 0;\n \n    bool V[MAX];\n    for(int i=0;i<n;i++){\n        B[i] = A[i];\n        V[i] =false;\n    }\n    sort(B, B+n);\n    for(int i=0;i<n;i++) T[B[i]] = i;\n    for(int i=0;i<n;i++){\n        if(V[i]) continue;\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while(1){\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m,v);\n            S += v;\n            cur = T[v];\n            if(V[cur]) break;\n        }\n        ans += min(S+(an-2)*m,m+S+(an+1)*s);\n    }\n \n    return ans;\n}\n \nint main(){\n    cin >> n;\n    s = VMAX;\n    for(int i=0;i<n;i++){\n        cin >> A[i];\n        s = min(s,A[i]);\n    }\n    int ans = solve();\n    cout << ans << endl;\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_6_D\n// Sort II - Minimum Cost Sort\n\n#define SUBMIT\n\n#include <utility>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <limits>\n#include <numeric>\n#include <set>\n#include <cmath>\n#include <cstring>\n#include <climits>\n\nusing namespace std;\nusing ui64 = unsigned long long;\nusing i64 = long long;\n\nconst int MAX_N = 1000;\n\nui64 n;\nint w[MAX_N];\nint w_copy[MAX_N];\nbool moved[MAX_N];\n\nui64 solve() {\n    for (int i = 0; i < n; ++i) moved[i] = false;\n    copy(w, w + n, w_copy);\n    sort(w_copy, w_copy + n);\n\n    auto min_all_cost = w_copy[0];\n\n    ui64 min_total_cost = 0;\n\n    const ui64 not_found = n + 1;\n    while (true) {\n        // find cycle start index\n        ui64 cycle_index = not_found;\n        for (ui64 i = 0; i < n; ++i) {\n            if (!moved[i]) {\n                cycle_index = i;\n                break;\n            }\n        }\n\n        // all elements are moved\n        if (cycle_index == not_found) break;\n\n        // find cycle\n        vector<ui64> cycle_indices;\n        while (true) {\n            if (find(cycle_indices.begin(), cycle_indices.end(), cycle_index) != cycle_indices.end()) break;\n            cycle_indices.push_back(cycle_index);\n            cycle_index = find(w_copy, w_copy + n, w[cycle_index]) - w_copy;\n        }\n\n        // compute minimum cost in the cycle\n        vector<int> cycle_costs;\n        for (const auto& i : cycle_indices) cycle_costs.push_back(w[i]);\n\n        auto min_cycle_cost = *min_element(cycle_costs.begin(), cycle_costs.end());\n        auto sum_cycle_cost = accumulate(cycle_costs.begin(), cycle_costs.end(), 0);\n        min_total_cost += min(\n                (cycle_costs.size() - 2) * min_cycle_cost + sum_cycle_cost, // in cycle\n                min_cycle_cost + sum_cycle_cost + (cycle_costs.size() + 1) * min_all_cost // borrow min element in w\n        );\n\n        // memorize moved elements\n        for (const auto& i : cycle_indices) moved[i] = true;\n    }\n\n    return min_total_cost;\n}\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; i++) cin >> w[i];\n    auto min_total_cost = solve();\n    cout << min_total_cost << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX 2000\n#define SENTINEL 20000\ntypedef long long llong;\nint L[MAX/2+2],R[MAX/2+2];\n\nllong merge(int A[],int left,int right,int mid){\n    int i=0,j=0;\n    int n1=mid-left,n2=right-mid;\n    llong cnt=0;\n    for(int k=0;k<n1;k++)L[k]=A[left+k];\n    for(int k=0;k<n2;k++)R[k]=A[mid+k];\n    L[n1]=R[n2]=SENTINEL;\n    for(int k=left;k<right;k++){\n        if(L[i] <= R[j]){\n            A[k] = L[i++];\n        }else{\n            cnt += A[k]+R[j];\n            A[k] = R[j];\n            j++;\n        }\n    }\n    return cnt;\n}\n\n\nllong inversion(int A[],int left,int right){\n    llong cnt1,cnt2,m;\n    int mid;\n    if(left+1<right){\n        mid=(left+right)/2;\n        cnt1 = inversion(A,left,mid);\n        cnt2 = inversion(A,mid,right);\n        m = merge(A,left,right,mid);\n        return cnt1 + cnt2 + m;\n    }else{\n        return 0;\n    }\n}\n\nint main(){\n    int n,A[MAX],B[MAX],C[MAX];\n    cin >> n;\n    for(int i=0;i<n;i++){\n        cin >> A[i];\n        B[i] = C[i] = A[i];\n    }\n    inversion(A,0,n);\n    int j=0;\n    for(int i=0;i<n;i++){\n        if(B[i]!=A[i]) C[j++]=B[i];\n    }\n    llong ans = inversion(C,0,j);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef vector<lli> vll;\n\nlli n;\nvll w;\nvll w_;\nlli ans = 0;\nlli mini;\n\n\nint main(){\n\tcin >> n;\n\tw = vll(n);\n\tw_ = vll(n);\n\tfor(lli i = 0;i < n;i++) cin >> w[i];\n\tfor(lli i = 0;i < n;i++) w_[i] = i;\n\tsort(w_.begin(),w_.end(),[](lli a,lli b){\n\t\treturn w[a] < w[b];\n\t});\n\tmini = w[w_[0]];\n\tfor(lli i = 0;i < n;i++){\n\t\tlli ans_ = 0,c = 0;\n\t\twhile(w_[i] != i){\n\t\t\tans_ += w[w_[i]] + w[w_[w_[i]]];\n\t\t\tswap(w[w_[i]],w[w_[w_[i]]]);\n\t\t\tswap(w_[i],w_[w_[i]]);\n\t\t\tc++;\n\t\t}\n\t\tif(c*(w[i]-mini) > 2*(w[i]+mini)){\n\t\t\tans_ -= c*(w[i]-mini) - 2*(w[i]+mini);\n\t\t}\n\t\tans += ans_;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\nusing namespace std;\nint main(){\n  int n,ans=0,t[1000],u[1000];\n  bool visited[1000];\n  map<int,int> change;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>t[i];\n    change[t[i]]=i;\n    u[i]=t[i];\n    visited[i]=false;\n  }\n  sort(u,u+n);\n  for(int i=0;i<n;i++){   \n    int w=i,x=0,y=0,z=10000;\n    while(!visited[w]){\n      z=min(z,t[w]);\n      y+=t[w];\n      x++;\n      visited[w]=true;\n      w=change[u[w]];\n    }\n    if(x>=2)ans+=min(y+z+u[0]*(x+1),y+z*(x-2));\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstatic const long MAX = 1000;\nstatic const long VMAX = 10000;\n\nlong n, A[MAX], s;\nlong B[MAX], T[VMAX + 1];\n\nlong solve(){\n\tlong ans = 0;\n\tbool V[MAX];\n\tfor (long i = 0; i < n; i++){ // ?????????\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B, B + n);\n\tfor (long i = 0; i < n; i++) T[B[i]] = i; // ??????????????????\n\tfor (long i = 0; i < n; i++){\n\t\tif (V[i]) continue; // True?????¨??????????£???°???\n\t\tlong cur = i, S = 0, m = VMAX, an = 0;\n\t\twhile (1){\n\t\t\tV[cur] = true; // ???????????????????????\\??£?????????\n\t\t\tan++; // ?????????????????¨??????1?????°???\n\t\t\tlong v = A[cur]; // ???????????????????´?\n\t\t\tm = min(m, v); // ???????????????????°????????¨????\n\t\t\tS += v; // ?????????????????°?????????????¨????\n\t\t\tcur = T[v]; // ??????index??????????????¢??????\n\t\t\tif (V[cur]) break; // ?????£??????????????????\n\t\t}\n\t\tans += min(S + (an - 2) * m, m + S + (an + 1) * s); // ?°???????????????????\n\t}\n\treturn ans;\n}\n\nint main(){\n\tcin >> n;\n\ts = VMAX;\n\tfor (long i = 0; i < n; i++){\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tlong ans = solve();\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// minimum cost sort alg (bubble sort + marge sort)\n#include<iostream>\n#include<climits>\n#define INF INT_MAX;\nint merge(int*, int, int, int);\nint mergeSort(int*, int, int);\nint cnt=0;\nint main(){\n  int n;\n  std::cin >> n;\n  int A[n];\n  for(int i=0; i<n; i++) std::cin >> A[i];\n  int ans = mergeSort(A, 0, n);\n  for(int i=0; i<n;i ++) std::cout << A[i] << (i != n-1 ? \" \" : \"\\n\");\n  std::cout << ans << \"\\n\";\n  return 0;\n}\nint merge(int *A, int l, int m, int r){\n  int n1=m-l, n2=r-m, i, j, L[n1+1], R[n2+1], count=0;\n  for(i=0; i<n1; i++) L[i] = A[l+i];\n  for(i=0; i<n2; i++) R[i] = A[m+i];\n  i = j = 0, L[n1] = R[n2] = INF;\n  for(int k=l;k<r;k++){\n    if(L[i] <= R[j]) A[k] = L[i++], cnt++;\n    else A[k] = R[j++], cnt++, count += n1 - i;\n  }\n  return count;\n}\nint mergeSort(int *A, int l, int r){\n  int m;\n  if(l+1 < r){\n    m = (l + r) / 2;\n    int i=mergeSort(A, l, m), j=mergeSort(A, m, r);\n    int k=merge(A, l, m, r);\n    return i+j+k;\n  }\n  else return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <stack>\n#include <queue>\n#include <map>\n#include <list>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <climits>\nusing namespace std;\n\nstruct node {\n\tlong prev;\n\tlong next;\n\tint val;\n};\n\nqueue<int> merge(queue<int> q1, queue<int> q2){\n\tqueue<int> ma;\n\twhile(q1.size() || q2.size()){\n\t\tif(!q2.size() || (q1.size() && q1.front() < q2.front())){\n\t\t\tma.push(q1.front());\n\t\t\tq1.pop();\n\t\t}else{\n\t\t\tma.push(q2.front());\n\t\t\tq2.pop();\n\t\t}\n\t}\n\treturn ma;\n}\nqueue<int> sort(queue<int> q){\n\tqueue<int> nq;\n\twhile(q.size() - nq.size() > 1){\n\t\tnq.push(q.front());\n\t\tq.pop();\n\t}\n\tif(!nq.size()) return q;\n\treturn merge(sort(nq), sort(q));\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\t\n\tint wholeMin = INT_MAX;\n\tint v[n];\n\tqueue<int> q;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> v[i];\n\t\tq.push(v[i]);\n\t\twholeMin = min(wholeMin, v[i]);\n\t}\n\t\n\tqueue<node> nodes;\n\tq = sort(q);\n\twhile(q.size()){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(q.front() == v[i]){\n\t\t\t\tnode no;\n\t\t\t\tno.prev = i;\n\t\t\t\tno.next = n - q.size();\n\t\t\t\tno.val = v[i];\n\t\t\t\tnodes.push(no);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tq.pop();\n\t}\n\t\n\tvector<vector<node> > groups;\n\tvector<node> sub;\n\twhile(nodes.size()){\n\t\tsub.clear();\n\t\tnode topNode = nodes.front();\n\t\tnodes.pop();\n\t\tsub.push_back(topNode);\n\t\t\n\t\tnode curNode = topNode;\n\t\twhile(curNode.prev != curNode.next){\n\t\t\tif(curNode.next == nodes.front().prev){\n\t\t\t\tcurNode = nodes.front();\n\t\t\t\tnodes.pop();\n\t\t\t\tsub.push_back(curNode);\n\t\t\t\tif(curNode.next == topNode.prev) break;\n\t\t\t}else{\n\t\t\t\tnodes.push(nodes.front());\n\t\t\t\tnodes.pop();\n\t\t\t}\n\t\t}\n\t\t\n\t\tgroups.push_back(sub);\n\t}\n\t\n\tlong cost = 0;\n\tfor(int i = 0; i < groups.size(); i++){\n\t\tif(groups[i].size() == 1) continue;\n\t\telse if(groups[i].size() == 2) cost += groups[i][0].val + groups[i][1].val;\n\t\telse{\n\t\t\tint min = INT_MAX;\n\t\t\tlong total = 0;\n\t\t\tfor(int k = 0; k < groups[i].size(); k++){\n\t\t\t\tmin = min < groups[i][k].val ? min : groups[i][k].val;\n\t\t\t\ttotal += groups[i][k].val;\n\t\t\t}\n\t\t\t\n\t\t\tlong costInternal = total + min * (groups[i].size() - 2);\n\t\t\tlong costExternal = total + wholeMin * (groups[i].size() - 2) + (min + wholeMin) * 2;\n\t\t\tcost += costInternal > costExternal ? costExternal : costInternal;\n\t\t}\n\t}\n\tcout << cost << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n//#include \"libs.h\"\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n//#include <opencv2/core.hpp>\n//#include <opencv2/highgui.hpp>\n//#include <opencv2/imgproc.hpp>\n\nusing namespace std;\n\n//呪文\n#define DUMPOUT cerr\n#define dump(...) DUMPOUT<<\"  \";DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl;DUMPOUT<<\"    \";dump_func(__VA_ARGS__)\n\ntypedef unsigned uint; typedef long long ll; typedef unsigned long long ull; typedef pair<int, int> pii; typedef pair<ll, ll> pll; typedef pair<double, double> pdd; typedef pair<string, string> pss;\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const pair<_KTy, _Ty>& m) { o << \"{\" << m.first << \", \" << m.second << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const unordered_map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const vector<_Ty>& v) { if (v.empty()) { o << \"{ }\"; return o; } o << \"{\" << v.front(); for (auto itr = ++v.begin(); itr != v.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const unordered_set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; }\to << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const stack<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } stack<_Ty> t(s); o << \"{\" << t.top(); t.pop(); while (!t.empty()) { o << \", \" << t.top(); t.pop(); } o << \"}\";\treturn o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const list<_Ty>& l) { if (l.empty()) { o << \"{ }\"; return o; } o << \"{\" << l.front(); for (auto itr = ++l.begin(); itr != l.end(); ++itr) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> istream& operator >> (istream& is, pair<_KTy, _Ty>& m) { is >> m.first >> m.second; return is; }\ntemplate <typename _Ty> istream& operator >> (istream& is, vector<_Ty>& v) { for (size_t i = 0; i < v.size(); i++) is >> v[i]; return is; }\nnamespace aux { // print tuple\n\ttemplate<typename Ty, unsigned N, unsigned L> struct tp { static void print(ostream& os, const Ty& v) { os << get<N>(v) << \", \"; tp<Ty, N + 1, L>::print(os, v); } };\n\ttemplate<typename Ty, unsigned N> struct tp<Ty, N, N> { static void print(ostream& os, const Ty& v) { os << get<N>(v); } };\n}\ntemplate<typename... Tys> ostream& operator<<(ostream& os, const tuple<Tys...>& t) { os << \"{\"; aux::tp<tuple<Tys...>, 0, sizeof...(Tys)-1>::print(os, t); os << \"}\"; return os; }\n\ntemplate<typename A, size_t N, typename T> inline void Fill(A(&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\n\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) { DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(std::move(tail)...); }\n\n#define PI 3.14159265358979323846\n#define EPS 1e-10\n#define FOR(is,a,n) for(int is=(a);is<(n);++is)\n#define REP(is,n)  FOR(is,0,n)\n#define all(j) (j).begin(), (j).end()\n#define SZ(j) ((int)(j).size())\n#define fake false\n\n\n\nint main() {\n\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\tvector<int> w(n);\n\tcin >> w;\n\n\tint cost = 0;\n\tfor (int i = n - 1; i >= 1; i--) {\n\t\tint max_w = -1, max_idx = -1;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (max_w < w[j]) {\n\t\t\t\tmax_w = w[j];\n\t\t\t\tmax_idx = j;\n\t\t\t}\n\t\t}\n\t\tif (max_w > w[i]) {\n\t\t\tswap(w[max_idx], w[i]);\n\t\t\tcost += w[max_idx] + w[i];\n\t\t}\n\t}\n\tcout << cost << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define MIN(a,b) ((a)<(b)?(a):(b))\n\nvoid merge(vector<pair<int,int> >& w, int left, int mid, int right) {\n\tvector<pair<int,int> > L,R;\n\tint n1=mid-left;\n\tint n2=right-mid;\n\tint i=0,j=0,k;\n\tL.resize(n1+1);\n\tR.resize(n2+1);\n\tfor(i=0; i<n1; ++i) {\n\t\tL[i]=w[left+i];\n\t}\n\tL[n1].first = -1;\n\tL[n1].second = 1000000001;\n\tfor(i=0; i<n2; ++i) {\n\t\tR[i]=w[mid+i];\n\t}\n\tR[n2].first = -1;\n\tR[n2].second = 1000000001;\n\n\ti=j=0;\n\tfor(k=left; k<right; ++k) {\n\t\tif(L[i].second < R[j].second) {\n\t\t\tw[k]=L[i];\n\t\t\t++i;\n\t\t} else {\n\t\t\tw[k]=R[j];\n\t\t\t++j;\n\t\t}\n\t}\n\treturn;\n}\n\nvoid mergeSort(vector<pair<int,int> >& w, int left, int right) {\n\tif(left+1<right) {\n\t\tint mid=left+(right-left)/2;\n\t\tmergeSort(w,left,mid);\n\t\tmergeSort(w,mid,right);\n\t\tmerge(w,left,mid,right);\n\t}\n\treturn;\n}\n\nint main() {\n\tint n;\n\tint i,j;\n\tint total=0;\n\tint subtotal,c;\n\tvector<int> checker;\n\tvector<pair<int,int> > w; // first=original_index, second =weight_value will be sorted.\n\tscanf(\"%d\",&n);\n\tw.resize(n);\n\tchecker.resize(n);\n\tfor(i=0; i<n; ++i) {\n\t\tchecker[i]=0;\n\t\tw[i].first=i;\n\t\tscanf(\"%d\",&w[i].second);\n\t}\n\tmergeSort(w,0,n);\n\tfor(i=0; i<n; ++i) {\n\t\tif(checker[i]==1 || w[i].first==i) {\n\t\t\tcontinue; // already checked or unmoved\n\t\t}\n\t\tc=subtotal=0;\n\t\tchecker[i]=1;\n\t\tj=w[i].first;\n\t\twhile(j!=i) {\n\t\t\tsubtotal+=w[i].second+w[j].second;\n\t\t\tchecker[j]=1;\n\t\t\tj=w[j].first;\n\t\t\t++c;\n\t\t}\n\t\ttotal+=MIN(subtotal,subtotal-(w[i].second-w[0].second)*(c-1));\n\t}\n\tprintf(\"%d\\n\",total);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nint main() {\n\tint n,w,l;\n\tvector<pair< int, pair<int,int> > > a; \n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>w;\n\t\ta.push_back(make_pair(w,make_pair(i,0)));\n\t}\n\tsort(a.begin(), a.end());\n\tfor(int i=0;i<n;i++){\n\t\t(a[i].second).second=i;\n\t\tl=a[i].first;\n\t\ta[i].first=(a[i].second).first;\n\t\t(a[i].second).first=l;\n//\tcout<<\"a[i]\"<<a[i].first<<\" \"<<(a[i].second).first<<endl;\n\t}\n\tint mi=(a[0].second).first;\n\tsort(a.begin(),a.end());\n//for(int i=0;i<n;i++) cout<<\"a[i]\"<<a[i].first<<\" \"<<(a[i].second).first<<\" \"<<(a[i].second).second<<endl;\n\t\n\tbool b[1010]={0};\n\tint ans=0;\n\tfor(int i=0;i<n;i++){\n\t\tif (b[i]!=0) continue;\n\t//\tcout<<i<<\" \"<<b[i]<<endl;\n\t\tb[i]=1;\n\t\tint j=i,k=1,sum=(a[i].second).first,mini=(a[i].second).first;\n\t\twhile(1){\n\t\t\tif(i==(a[j].second).second) break;\n\t\t\tj=(a[j].second).second;\n\t\t\tb[j]=1;\n\t\t\tsum=sum+(a[j].second).first;\n\t\t\tk++;\n\t\t\tif(mini>(a[j].second).first) mini=(a[j].second).first;\n\t\t}\n//\t\tcout<<k<<\" \"<<mini <<\" \"<<sum<<\" \"<<mi<<endl;\n\t\tif(k>1) ans=ans+min(sum+(k-2)*mini,sum+(k+1)*mi+mini); \n\t\t\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\n\n#define VMAX 10001\nint n, _min = VMAX;\nint A[1000];\nint B[1000];  //計数カウンタ\nint T[10001]; //添え字と要素でサイクル先を示す\nint solve(){\n\n    int ans = 0;\n\n    bool V[1000]; //訪れたかどうかを示す\n    for(int i=0; i<n; i++){\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B, B+n);\n    for(int i=0; i<n; i++) T[B[i]] = i; //計数カウンタ\n    for(int i=0; i<n; i++){\n        if(V[i]) continue; //ほかのサイクルを探す\n        int cur = i; //サイクルのスタート地点\n        int S = 0; //サイクル内の要素の合計\n        int m = VMAX; //サイクル内の要素の最小値\n        int an = 0; //サイクル内の要素の数\n        while(1){\n            V[cur] = true;\n            an++;\n            int v = A[cur]; //要素\n            m = min(m, v);\n            S += v;\n            cur = T[v]; //サイクル内の次の要素！\n            if(V[cur]) break; //サイクルを一周した\n        }\n        ans += min(S+(an-2)*m, m+S+(an+1)*_min);\n    }\n    return ans;\n}\n\nint main(){\n\n    scanf(\"%d\", &n);\n    for(int i=0; i<n; i++){\n        scanf(\"%d\", &A[i]);\n        if(A[i] < _min) _min = A[i];\n    }\n\n    int ans = solve();\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\n#include <cstring>\n#define MAX 1000\n#define W 10000\nusing namespace std;\n\nint n,a[MAX],b[MAX],V[MAX],T[W+1],ans=0,mi=W;\n\nint solve(){\n    int i;\n    for(i=0;i<n;i++){\n        b[i]=a[i];\n    }\n    sort(b,b+n);\n    for(i=0;i<n;i++){T[b[i]]=i;}\n    for(i=0;i<n;i++){\n        if(V[i])continue;\n        int S=0;\n        int an=0;\n        int cur=i;\n        int m=MAX;\n        while(1){\n            V[cur]=1;\n            an++;\n            m=min(m,a[cur]);\n            S+=a[cur];\n            cur=T[a[cur]];\n            if(V[cur])break;\n        }\n        ans+=min(S+(an-2)*m,S+m+(an+1)*mi);\n    }\n    return ans;\n}\n\nint main()\n{\n    memset(V,0,sizeof(V));\n    cin>>n;\n    int i;\n    for(i=0;i<n;i++){cin>>a[i];mi=min(mi,a[i]);}\n    ans=solve();\n    cout<<ans<<endl;\n    return 0;\n}\n//int main(){\n//    int a=4;\n//    if(a){\n//        cout<<\"ok\";\n//    }\n//}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint swap_log[1000][2];\n\nvoid swap(int *A, int i, int j) {\n  int temp;\n  temp = A[i];\n  A[i] = A[j];\n  A[j] = temp;\n}\n\nvoid Merge(int *A, int left, int mid, int right) {\n  int n1,n2,*L,*R,i,j,k;\n  n1 = mid -left;\n  n2 = right - mid;\n  L = (int*)malloc(sizeof(int) * (n1+1));\n  R = (int*)malloc(sizeof(int) * (n2+1));\n  for (i = 0; i< n1; i++) L[i] = A[left+i];\n  for (i = 0; i < n2; i++) R[i] = A[mid+i];\n  L[n1] = INT_MAX; R[n2] = INT_MAX;\n  i = 0;j = 0;\n  for(k = left; k < right; k++) {\n    if (L[i] < R[j]) {\n      A[k] = L[i];\n      i++;\n    }else {\n      A[k] = R[j];\n      j++;\n    }\n  }\n  free(L);\n  free(R);\n}\n\nvoid Merge_Sort(int *A, int left, int right) {\n  if(left+1 < right) {\n    int mid = (left + right)/2;\n    Merge_Sort(A,left,mid);\n    Merge_Sort(A,mid,right);\n    Merge(A,left,mid,right);\n  }\n}\nlong step_sort(int *w, int *w1, int i) {\n  int j,k;\n  long sum = 0;\n  k = 0;\n  while(w[i] != w1[i]) {\n    j = 0;\n    while (w[j] != w1[i]) j++;\n    sum += w[i]+w[j];\n    swap(w,i,j);\n    swap_log[k][0] = i; swap_log[k][1] = j;\n    i = j;\n    k++;\n  }\n  swap_log[k][0] = 0; swap_log[k][1] = 0;\n  return sum;\n}\n\nint search_min(int *w, int *w1,int n) {\n  int i,j;\n  i = 0;\n  while(1) {\n    j = 0;\n    while(w[j] != w1[i]) j++;\n    if(i != j) break;\n    i++;\n    if(i >= n) return n;\n  }\n  return j;\n}\n\nlong run_log(int *w) {\n  int i = 0;\n  long sum = 0;\n  while(swap_log[i][0] != swap_log[i][1]) {\n    sum += w[swap_log[i][0]]+w[swap_log[i][1]];\n    swap(w,swap_log[i][0],swap_log[i][1]);\n    i++;\n  }\n  return sum;\n}\n\nlong sub_sort(int *w, int *w1, int i) {\n  long sum;\n\n  if(w[0] != w1[0]) return LONG_MAX;\n  int j = 0;\n  while(w[i] != w1[j]) j++;\n  sum = w[i] + w[0];\n  swap(w,i,0);\n  sum += run_log(w);\n  sum += w[0] + w[j];\n  swap(w,0,j);\n  \n  return sum;\n}\n\nlong repeat_sort(int *w, int *w1, int n,long now) {\n  int i;\n  int a1[n];\n  long v1,v2;\n  for (i = 0; i < n; i++) a1[i]=w[i];\n  i = search_min(w,w1,n);\n  if(i == n) return now;\n  v1 = step_sort(w,w1,i);\n  v2 = sub_sort(a1,w1,i);\n  long min = (v1 < v2) ? v1:v2;\n  return repeat_sort(w,w1,n,now+min);\n}\n\nlong much_sort(int *w, int *w1, int n) {\n  int i,j;\n  long sum = 0;\n  char *checked = (char*)calloc(n,sizeof(char));\n  i = 0;\n  while(i < n) {\n    j = 0;\n    while(w[j] != w1[i]) j++;\n    if(i != j) {\n      if(w1[j] ==  w[i]) {\n\tsum += w[i] + w[j];\n\tswap(w,i,j);\n      }\n    }\n    checked[i]=1;checked[j]=1;\n    while(i < n && checked[i]!=0)i++;\n  }\n  free(checked);\n  return sum;\n}\n\nint main()\n{\n  int i,n,*w,*w2;\n  long sum;\n  scanf(\"%d\",&n);\n  w = (int*)malloc(sizeof(int) * n);\n  w2 = (int*)malloc(sizeof(int) * n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\",w+i);\n    w2[i] = w[i];\n  }\n  Merge_Sort(w2,0,n);\n  \n  sum = much_sort(w,w2,n);\n  sum += repeat_sort(w,w2,n,0);\n  printf(\"%ld\\n\",sum);\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n#define MAX_N 1000\n#define MAX_W 10000\n\nint n, A[MAX_N], s, B[MAX_N], T[MAX_W];\n\nint solve()\n{\n\tint ans = 0, count = 0;\n\tbool V[MAX_N];\n    memset(V, false, sizeof(V));\n    memcpy(B, A, sizeof(int) * n);\n    sort(B, B + n);\n    for (int i = 0; i < n; i++) T[B[i]] = i;\n    for (int i = 0; i < n; i++) {\n        if (V[i]) continue;\n        int cur = i;\n        int S = 0;\n        int m = MAX_W;\n        int an = 0;\n        while (1) {\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m, v);\n            S += v;\n            cur = T[v];\n            if (V[cur]) break;\n        }\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> n;\n    s = MAX_W;\n    for (int i = 0; i < n; i++) {\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n    int ans = solve();\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve() {\n\tint ans = 0;\n\t\n\tbool V[VMAX];\n\tfor(int i = 0; i < n; i++) {\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B, B + n);\n\tfor(int i = 0; i < n; i++) T[B[i]] = i;\n\tfor(int i = 0; i < n; i++) {\n\t\tif( V[i] ) continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint an = 0;\n\t\tint m = VMAX;\n\t\twhile(1) {\n\t\t\tV[cur] = false;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\ts += v;\n\t\t\tcur = T[v];\n\t\t\tif( V[cur] ) break;\t\t\t\n\t\t}\n\t\tans += min(S + (an - 2) * m, S + m +(an + 1) * s);\n\t}\n\t\n\treturn ans;\n} \n\nint main() {\n\tcin >> n;\n\ts = VMAX;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tint ans = solve();\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<string>\nusing namespace std;\nconst int MAX=1005,VMAX=10005;\nint a[1005],b[1005];\nint T[10005];\nbool v[1005];\nint main()\n{\n    int n;\n    cin>>n;\n    int s=VMAX+5,ans=0;\n    for(int i=0;i<n;i++)cin>>a[i],b[i]=a[i],s=min(s,a[i]);\n    sort(b,b+n);\n    for(int i=0;i<n;i++)T[b[i]]=i;      //构造Cytle的必要方法\n    for(int i=0;i<n;i++)\n    {\n        if(v[i])continue;\n        int an=0;\n        int sn=0;\n        int m=VMAX+1;\n        int cur=i;\n        while(1)\n        {\n            v[cur]=true;\n            an++;\n            int V=a[cur];\n            m=min(m,V);\n            sn+=V;\n            cur=T[V];\n            if(v[cur])break;\n        }\n        ans+=min(sn+(an-2)*m,m+sn+(an+1)*s);\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n//4 3 1 2 5\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm> // next_permutation\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <list>\n#include <numeric> //accumulate\n//#include <unordered_map> //???????????\\??¢??°\n#include <fstream> //ifstream, ofstream\n\n#define NDEBUG //NDEBUG???#include <cassert>???????????????????????????????????´???assert?????????????????????????????????NDEBUG????????????????????¨\n#include <cassert> //assert\n\n\nusing namespace std;\n\n//???????????°??????TEST????????????????????¬???????????????????????????????????¢????????????\n#define TEST //*******************************************************************************************************************************************\n//?????????????????¨??§?????\\????????????????????????????????°?????????????¨???????????????????dout???????????????????????§???????????¬??????????????????????????????????????????\n//??????????????????????????????????????????????????????????§?CPU???????£??????????????????§???TLE?????????????????????????????????????????§????????¨???                           ????????????????????????cerr????????£????????????????????????????????????\n#ifdef TEST\n#define dout cout\n#else\nstringstream dummy; //???????????°??????dout?????????????????????????????????\n#define dout dummy.str(\"\"); dummy.clear(stringstream::goodbit); dummy //dummy?????????????????????????????????????????¨?????¢?????¢???????????????\n//???????????¨??????????????????goodbit?????????????????????????????¨???????????´????????????????????????????????¨?????°?????????????????§???????????????????????????????????? http://d.hatena.ne.jp/linden/20060427/p1\n#endif\n\n//?¨??????????????????????????????????????????????????????´??????OUTPUT2TEXTFILE????????????????????¬???????????????????????????????????¢????????????\n//#define OUTPUT2TEXTFILE //*******************************************************************************************************************************************\n#ifdef OUTPUT2TEXTFILE\n#define dout outputfile //??¨????????????TLE????????§?????????dout?????¨??¨??????????????¢????????????????????????????????????????????§????¨????????????´??????????????£??????????????????????¨?????????????????????????????????????????????§?????????????????????\n//TEST??????????????????????????¨???outputfile??????????????????????????????\n#define OUTPUTFILENAME \"output.txt\"\nofstream outputfile(OUTPUTFILENAME);\n#define OutputFilePath \"/Users/Nag/Documents/Prgm/Test/DerivedData/Test/Build/Products/Debug/output.txt\"\n#endif\n\n#define disp(A) dout << #A << \" = \" << (A) << endl\n#define disP(A) dout << setw(3) << (A) << \" \" // << setw(3) ??????????????\\????????????\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n\n#define dispAll(A,n) dout << #A << \" = \"; rep(j, 0, (n)) {disP(A[j]);} dout << endl\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef unsigned long long ll;\n\nconst int INF = 1e9-1;\n\n\n\n\n\n\n\n\nint main(){\n    int N; cin >> N;\n    \n    vi a, b;\n    vector<char> c; //a[i]??¨b[i]????????????????????????ox??§??¨???\n    vector<bool> o(N); //????????????????????????????????????????????????????????¨??????????????????????????????????????????true\n    \n    int aa;\n    rep(i,0,N) { cin >> aa; a.push_back(aa); }\n   \n    b = a;\n    sort(b.begin(), b.end());\n    \n    rep(i,0,N) { c.push_back( a[i] == b[i] ? 'o' : 'x' ); }\n    \n//    //test display\n//    dout << \"---------------------\\n\";\n//    dout << \"    \"; rep(i,0,N) disP(i); dout << \"\\n   \";\n//    rep(i,0,N) dout << \"   -\"; dout << endl;\n//    dispAll(b, N);\n//    dispAll(a, N);\n//    rep(i,0,N) { c[i] = (a[i] == b[i] ? 'o' : 'x' ); }\n//    dispAll(c, N);\n//    dispAll(o, N);\n    \n    \n    ll sumOfCost = 0;\n    ll cost, cost1, cost2;\n    int t, i, x, y, key, z, numOfNumbersInLoop;\n    \n    for(i=0; i<N; i++ ) {\n        if(a[i]==b[i]) continue; //a[i]!=b[i]??¨???????????????i????????????????????§i++\n\n        //???????????????????°???????key=a[x]?????¢???????????????????????¨??????\n        key = b[i]; //b[i]???!=a[i]??¨???????????????i????????§????????????????????¨??????\n        x = find(a.begin(), a.end(), key) - a.begin();\n\n        \n        //??????????????????\n        rep(j,0,N) o[j]=false; //o[]???????????????\n        t = x; //t?????????????????????????????§??????tmp?????°\n        o[t] = true;\n        while( b[t]!= key ) { //??????key??????????????§??????\n            t = find(a.begin(), a.end(), b[t]) - a.begin();\n            o[t] = true;\n        }\n        \n        \n        //???????????????????°??????°??????index z?????¢???\n        for(z=0; z<N; z++) { //????????????????????????????????°??????index???????????????????????????????????°?????????????????°??????????????????????????°????????????????????§????????°???z=N??¨??????\n            if(o[z]==false) break;\n        }\n        \n        numOfNumbersInLoop = 0; //?????????????????????????????°????????°???????????????\n        if( z!=N ) {\n            rep(j,0,N) {\n                if( o[j]==true ) numOfNumbersInLoop++;\n                \n                if(o[j]==false && a[j]<a[z]) {\n                    z = j;\n                }\n            }\n        }\n        \n\n        //swap phase\n        cost = 0;\n        do { //a[x]==b[x]??¨???????????§?????????????????°??????????????????\n            y = find(a.begin(), a.end(), b[x]) - a.begin();\n            \n            \n//            dout<<\"----\\n\";\n//            disp(x);\n//            disp(a[x]);\n//            disp(y);\n//            disp(a[y]);\n            \n            //swap a[x] & a[y]\n            int tmp = a[x];\n            a[x] = a[y];\n            a[y] = tmp;\n            \n            cost += a[x] + a[y];\n            \n            x = y;\n        } while ( a[x] != b[x] );\n        \n        \n        //??????1. ??????????????????????????????????????????????????? (????¨????swap phase???????????????)\n        //??????2. ???????????? key(???????????????????°??????°???) ??¨ a[z](???????????????????°??????°???) ?????\\?????????????????????????????????????????????????????????key??¨a[z]??????????????????\n        //???????????????????????????????????????????????????\n        \n        cost1 = cost;\n        cost2 = (z==N ? INF : cost - key*(numOfNumbersInLoop-1) + a[z]*(numOfNumbersInLoop+1) + 2*key);\n        \n        cost = (cost1 < cost2 ? cost1 : cost2);\n        \n        sumOfCost += cost;\n        \n        \n//        //test display\n//        dout << \"---------------------\\n\";\n//        disp(i);\n//        dout << \"---\\n    \";\n//        rep(i,0,N) disP(i); dout << \"\\n   \";\n//        rep(i,0,N) dout << \"   -\"; dout << endl;\n//        dispAll(b, N);\n//        dispAll(a, N);\n//        rep(i,0,N) { c[i] = (a[i] == b[i] ? 'o' : 'x' ); }\n//        dispAll(c, N);\n//        dispAll(o, N);\n//        disp(cost1);\n//        disp(numOfNumbersInLoop);\n//        disp(key);\n//        disp(z);\n//        disp(a[z]);\n//        disp(cost2);\n//        disp(cost);\n//        disp(sumOfCost);\n    }\n    \n    \n//    dout << \"=====================\\n\";\n//    \n//    //test display\n//    dout << \"---------------------\\n\";\n//    disp(i); disp(x); disp(y);\n//    dout << \"---\\n    \";\n//    rep(i,0,N) disP(i); dout << \"\\n   \";\n//    rep(i,0,N) dout << \"   -\"; dout << endl;\n//    dispAll(a, N);\n//    rep(i,0,N) { c[i] = (a[i] == b[i] ? 'o' : 'x' ); }\n//    dispAll(c, N);\n//    dispAll(b, N);\n//    disp(cost);\n    \n    cout << sumOfCost << endl;\n    \n    \n    \n    \n#ifdef OUTPUT2TEXTFILE\n    outputfile.close();\n    cout << \"\\\"\" << OutputFilePath << \"\\\"\" << endl;\n#endif\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include<time.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = int;\nusing ULL = unsigned long long;\nlong long MOD = 1000000000 + 7;\nconstexpr long long INF = numeric_limits<LL>::max();\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\nstruct Fll { LL first, second, third, fourd; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\nLL h, w, n, m, k, t, s, q, last, cnt, sum, ans, dp[10000], a[2000000], b[2000000];\nstring str, ss;\nbool f[1100][1100];\nchar c;\nint di[4][2] = { { 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 } };\nstruct Edge { LL to, cost; };\nvector<Edge>vec[200000];\nvector<LL>v,pick[200000];\nmap<string, vector<LL>>ma;\nmultiset<LL>st[3];\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\n\n\nvector<int> kosaraju() {\n\tint sz = 0;\n\tvector<Edge> rg[50000];\n\tvector<int> stk, cmp(n, -1), added(n), visited(n), ord(n);\n\trep(i, n) {\n\t\tsz += vec[i].size();\n\t\tfor (const Edge &e : vec[i])\n\t\t\trg[e.to].push_back(Edge{ (int)i, e.cost });\n\t}\n\tstk.resize(n + sz); sz = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (visited[i]) continue;\n\t\tint s = 0; stk[s++] = i;\n\t\twhile (s != 0) {\n\t\t\tint v = stk[s - 1];\n\t\t\tvisited[v] = true;\n\t\t\tbool pushed = false;\n\t\t\tfor (auto &e : vec[v]) {\n\t\t\t\tint dst = e.to;\n\t\t\t\tif (!visited[dst]) { stk[s++] = dst; pushed = true; }\n\t\t\t}\n\t\t\tif (pushed) continue;\n\t\t\tint t = stk[s - 1];\n\t\t\tif (!added[t]) { added[t] = true; ord[n - ++sz] = t; }\n\t\t\t--s;\n\t\t}\n\t}\n\tint k = 0;\n\tfor (int &u : ord) {\n\t\tif (cmp[u] != -1) continue;\n\t\tint s = 0; stk[s++] = u;\n\t\twhile (s != 0) {\n\t\t\tint v = stk[--s]; cmp[v] = k;\n\t\t\tfor (auto &e : rg[v]) {\n\t\t\t\tint d = e.to;\n\t\t\t\tif (cmp[d] == -1) stk[s++] = d;\n\t\t\t}\n\t\t}\n\t\t++k;\n\t}\n\treturn cmp;\n}\n\nmap<int, int> zip;\nint unzip[200000];\n\nint compress(vector<int> &x) {\n\tsort(x.begin(), x.end());\n\tx.erase(unique(x.begin(), x.end()), x.end());\n\tfor (int i = 0; i < x.size(); i++) {\n\t\tzip[x[i]] = i;\n\t\tunzip[i] = x[i];\n\t}\n\treturn x.size();\n}\n\nint main() {\n\tcin >> n;\n\trep(i, n) {\n\t\tcin >> a[i];\n\t\tv.push_back(a[i]);\n\t}\n\tcompress(v);\n\tv.clear();\n\trep(i,n){\n\t\tvec[i].push_back(Edge{ zip[a[i]],1 });\n\t}\n\tv=kosaraju();\n\trep(i, v.size()) {\n\t\tpick[v[i]].push_back(i);\n\t}\n\trep(i, n) {\n\t\tsum = 0;\n\t\tLL mn = INF;\n\t\tif (pick[i].size() > 1) {\n\t\t\trep(j, pick[i].size()) {\n\t\t\t\tsum += unzip[pick[i][j]];\n\t\t\t\tmn = min(mn, pick[i][j]);\n\t\t\t}\n\t\t\tans += min(sum + unzip[mn] * (pick[i].size() -\t2),sum+unzip[0] * (pick[i].size()+1)+unzip[mn]);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define scanf_s scanf\n#include <string>\n#include <stdio.h>\n#include <math.h>\n#include <stack>\n#include <queue>\n#include <list>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\n#define MAX 1000\n//#define MAX_ 1000\n\nint cou = 0;\n\nint main(void)\n{\n\tint n, x, sum = 0;\n\tint w[MAX] = { 0 }, _w[MAX] = { 0 };\n\tscanf_s(\"%d\", &n);\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf_s(\"%d\", &x);\n\t\tw[i] = x;\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (w[i] > w[j]) {\n\t\t\t\t++_w[i];\n\t\t\t}\n\t\t}\n\t\t_w[i] = i - _w[i];\n\t}\n\tint min, max;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = n - 1; j >= 0; --j) {\n\t\t\tif (_w[j] == 0) { ++cou; }\n\t\t\telse {\n\t\t\t\tif (j == n - 1) { min = max = j; }\n\t\t\t\tif (_w[min] > _w[j]) { min = j; }\n\t\t\t\tif (_w[max] < _w[j]) { max = j; }\n\t\t\t}\n\t\t}\n\t\tif (cou == n) break;\n\t\tcou = 0;\n\t\tsum += w[max] + w[min];\n\t\tx = w[min]; w[min] = w[max]; w[max] = x;\n\t\t_w[max] -= max - min; _w[min] += max - min;\n\t}\n\tprintf(\"%d\\n\", sum);\n}"
  },
  {
    "language": "C++",
    "code": "#include <boost/multi_array.hpp>\n#include <boost/optional.hpp>\n#include <boost/range/adaptors.hpp>\n#include <boost/range/algorithm.hpp>\n#include <boost/range/irange.hpp>\n#include \"bits/stdc++.h\"\n\nnamespace adaptor = boost::adaptors;\n\nconst int64_t nmax = 1000;\nconst int64_t vmax = 1e4;\n\nint64_t n, A[nmax], s;\nint64_t B[nmax], T[vmax + 1];\n\nint64_t calcCost() {\n    int64_t ans = 0;\n\n    bool V[nmax];\n    for (int64_t i = 0; i < n; i++) {\n        B[i] = A[i];\n        V[i] = false;\n    }\n    std::sort(B, B + n);\n    for (int64_t i = 0; i < n; i++) T[B[i]] = i;\n    for (int64_t i = 0; i < n; i++) {\n        if (V[i]) continue;\n        int64_t cur = i;\n        int64_t S = 0;     // サイクル内の要素の和\n        int64_t m = vmax;  // サイクル内の最小値\n        int64_t an = 0;    // サイクル内の個数\n        while (true) {\n            V[cur] = true;\n            an++;\n            int64_t v = A[cur];\n            m = std::min(m, v);\n            S += v;\n            cur = T[v];\n            if (V[cur]) break;\n        }\n        ans += std::min(S + (an - 2) * m, m + S + (an + 1) * s);\n    }\n    return ans;\n}\n\nvoid solve() {\n    std::cin >> n;\n    s = vmax;\n    for (int64_t i = 0; i < n; i++) {\n        std::cin >> A[i];\n        s = std::min(s, A[i]);\n    }\n    int64_t ans = calcCost();\n    std::cout << ans << std::endl;\n\n    return;\n}\n\nint main() {\n    std::cin.tie(0);\n    std::ios_base::sync_with_stdio(false);\n    std::cout << std::fixed << std::setprecision(15);\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <cstdio>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nint sorting(vector<short> v)\n{\n\tmap<vector<short>, int> d;\n\t\n\tvector<short> sorted(v.begin(), v.end());\n\t\n\tsort(v.begin(), v.end());\n\t\n\tqueue<pair<vector<short>, int> > que;\n\t\n\tque.push(make_pair(v, 1)); d[v] = 1; // pair(vector, cost + 1)\n\t\n\twhile(!que.empty())\n\t{\n\t\tvector<short> v1 = que.front().first;\n\t\t\n\t\tint cost = que.front().second; que.pop();\n\t\t\n\t\tfor(int i = 0; i < v.size(); i++)\n\t\t{\n\t\t    for(int j = i + 1; j < v.size(); j++)\n\t\t    {\n\t\t        vector<short> v2(v1.begin(), v1.end());\n\t\t        \n\t\t        int cost2 = cost + v1[i] + v1[j];\n\t\t        \n\t\t        swap(v2[i], v2[j]);\n\t\t        \n\t\t        if(d[v2] == 0 || d[v2] > cost2)\n\t\t        {\n\t\t            d[v2] = cost2;\n\t\t            \n\t\t            que.push(make_pair(v2, cost2));\n\t\t        }\n\t\t    }\n\t\t}\n\t}\n\t\n\treturn d[sorted] - 1;\n}\n\nint main()\n{\n\tvector<short> v; int n;\n\t\n\tscanf(\"%d\", &n); v = vector<short>(n);\n\t\n\tfor(int i = 0; i < n; i++) { scanf(\"%d\", &v[i]); }\n\t\n\tprintf(\"%d\\n\", sorting(v));\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\n#define P(x) cout << (x) << endl\n#define p(x) cout << (x)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define vv(type, c, m, n, i) vector<vector<type>> c(m, vector<type>(n, i));\n#define rep(i,a,n) for(int i=(a), i##_len=(n); i<i##_len; ++i)\n#define rrep(i,a,n) for(int i=(a), i##_len=(n); i>i##_len; --i)\n#define len(x) ((int)(x).size())\n#define mp make_pair\n#define eb emplace_back\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\nconstexpr int MAX = 1e3;\nconstexpr int VMAX = 1e4;\nint n, s, ans{0};\nvi a;\nvb V(MAX, false);\ninline void solve() {\n\tvi b(all(a)), t(VMAX + 1);\n\tsort(all(b));\n\trep(i, 0, n) t[b[i]] = i;\n\trep(i, 0, n) {\n\t\tif(V[i]) continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile(true) {\n\t\t\tV[cur] = true;\n\t\t\t++an;\n\t\t\tint v = a[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = t[v];\n\t\t\tif(V[cur]) break;\n\t\t}\n\t\tans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n\t}\n}\nint main() {\n\tcin >> n;\n\ta.resize(n);\n\trep(i, 0, n) cin >> a[i];\n\ts = min(VMAX, *min_element(all(a)));\n\tsolve();\n\tP(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define MAX 1000\nusing namespace std;\n\nint n, W[MAX], s;\nint T[MAX*10+1],A[MAX+1];\n\nint solve()\n{\n\tint ans = 0;\n\tbool V[MAX];\n\tfor(int i = 0; i < n; i++){\n\t\tA[i] = W[i];V[i] = false;\n\t}\n\tsort(A, A+n);\n\tfor(int i = 0; i < n; i++)\tT[A[i]] = i;\n\tfor(int i = 0; i < n; i++){\n\t\tint cur = i; \n\t\tint S = 0; \n\t\tint an = 0; \n\t\tint m = MAX*10+1;\n\t\twhile(1){\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = W[cur];\n\t\t\tS += v;\n\t\t\tm = min(m, v);\n\t\t\tcur = T[v];\n\t\t\tif(V[cur])\tbreak;\n\t\t}\n\t\tans += min(S+m*(an-2), (an+1)*s+m+S);\n\t}\n\treturn ans;\n}\nint main(){\n\ts = MAX*10+1;\n\tcin>>n;\n\tfor(int i = 0; i < n; i++){\n\t\tcin>>W[i]; s = min(s, W[i]);\n\t}\n\tcout<<solve()<<endl;\n\treturn 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <unordered_map>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nnamespace std{\n\ttemplate<typename T>\n\tinline void hash_combine(size_t& seed, T const& v){\n\t\tseed ^= hash<T>()(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n\t}\n    template<typename It>\n    inline size_t hash_range(It first, It last){\n\t\tsize_t seed=0;\n\t\thash_range(seed,first,last);\n\t\treturn seed;\n\t}\n\ttemplate<typename It>\n\tinline void hash_range(size_t& seed, It first, It last){\n\t\tfor(;first!=last;++first)hash_combine(seed, *first);\n\t}\n\ttemplate<typename A,typename B>\n\tclass hash<pair<A,B>>{\n\t\tpublic:\n\t\tsize_t operator()(pair<A,B> const &p) const{\n\t\t\tsize_t seed=0;\n\t\t\thash_combine(seed,p.first);\n\t\t\thash_combine(seed,p.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\ttemplate<typename T,size_t N>\n\tclass hash<array<T,N>>{\n\t\tpublic:\n\t\tsize_t operator()(array<T,N> const &container) const{\n\t\t\treturn hash_range(container.begin(),container.end());\n\t\t}\n\t};\n\ttemplate<typename T,typename A>\n\tclass hash<vector<T,A>>{\n\t\tpublic:\n\t\tsize_t operator()(vector<T,A> const &container) const{\n\t\t\treturn hash_range(container.begin(),container.end());\n\t\t}\n\t};\n}\n\nint main(){\n\tint N;\n\tscanf(\"%d\",&N);\n\tvector<int>v(N);\n\tfor(int i=0;i<N;i++)scanf(\"%d\",&v[i]);\n\tpriority_queue<pair<int,vector<int> > >q;\n\tunordered_map<vector<int>,int>depth;\n\n\tq.push(make_pair(0,v));\n\tint R;\n\tfor(;!q.empty();){\n\t\tpair<int,vector<int> >cur=q.top();\n\t\tq.pop();\n\t\tif(depth.find(cur.second)!=depth.end())continue;\n\t\tdepth[cur.second]=cur.first;\n\t\tbool f=false;\n\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++)if(i!=j&&cur.second[i]>cur.second[j]){\n\t\t\tif(i<j)f=true;\n\t\t\tswap(cur.second[i],cur.second[j]);\n\t\t\tq.push(make_pair(cur.first-cur.second[i]-cur.second[j],cur.second));\n\t\t\tswap(cur.second[i],cur.second[j]);\n\t\t}\n\t\tif(!f){\n\t\t\tR=-cur.first;\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",R);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n\tint n, min, mini, w = 0;\n\tcin >> n;\n\tint arr[n];\n\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tcin >> arr[i];\n\t}\n\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tmin = arr[i];\n\t\tmini = i;\n\t\tfor (int j = i; j < n; j++) {\n\t\t\tif (min > arr[j]) {\n\t\t\t\tmin = arr[j];\n\t\t\t\tmini = j;\n\t\t\t}\n\t\t}\n\t\tif (i != mini) {\n\t\t\tw += arr[i] + arr[mini];\n\t\t\tswap(arr[i], arr[mini]);\n\t\t}\n\t}\n\n\tcout << w << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdint.h>\n#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <climits>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define DEBUG (0)\n\n#if DEBUG\n#define DPRINTF(...) do { \\\n    printf(\"D(L%d) %s: \", __LINE__, __func__); \\\n    printf(__VA_ARGS__); \\\n  } while (false)\n#else\n#define DPRINTF(...)\n#endif // DEBUG\n\nint g_cost = 0;\n\nvoid swap(int array[], int i0, int i1)\n{\n  int temp = array[i1];\n  array[i1] = array[i0];\n  array[i0] = temp;\n}\n\n\nint findIndexOf(int val, const int array[], int numOfArray)\n{\n  for (int i = 0; i < numOfArray; i++)\n    if (array[i] == val)\n      return i;\n\n  // if cannot find the val, call assertion error.\n  assert(0);\n\n  return -1;\n}\n\n\n// The formula is : Sigma(Wi) + min(Wi) * (N-2)\nint calcCostSimple(const int array[], const vector<int> &l)\n{\n  int s = 0;\n  int minimum = INT_MAX;\n  for (uint32_t i = 0; i < l.size(); i++)\n  {\n    int idx = l[i];\n    s += array[idx];\n    minimum = min(minimum, array[idx]);\n  }\n\n  return s + minimum * (l.size() - 2);\n}\n\n\n// The formula is : Signma(Wi) + min(Wi) + x * (N+1)\nint calcCostSwap(const int array[], const vector<int> &l, int x)\n{\n  if (array == nullptr || l.size() < 1 || x < 0)\n  {\n    assert(1);\n    return INT_MAX;\n  }\n\n  int s = 0;\n  int minimum = INT_MAX;\n  for (uint32_t i = 0; i < l.size(); i++)\n  {\n    int idx = l[i];\n    s += array[idx];\n    minimum = min(minimum, array[idx]);\n  }\n\n  return s + minimum + x * (l.size() - 1);\n}\n\n\n// TODO: debug\nint findMinOutsideLoop(vector<int> l, const int array[], const int sortedArray[])\n{\n  sort(l.begin(), l.end());\n\n#if 0\n  for (int i = 0; i < l.size(); i++)\n    DPRINTF(\"%d %d\\n\", i, l[i]);\n#endif\n\n  for (int i = 0; i < l.size(); i++)\n  {\n#if 0\n    DPRINTF(\"i %d  idxArray %d\\n\", i, l[i]);\n#endif\n    if (sortedArray[i] != array[l[i]])\n      return sortedArray[l[i]];\n  }\n\n  // the case l and sortedArray are the same\n  return INT_MAX;\n}\n\n\nint main()\n{\n  int numOfArray;\n  cin >> numOfArray; cin.ignore();\n\n  int array[numOfArray];\n  for (int i = 0; i < numOfArray; i++)\n    cin >> array[i];\n\n#if DEBUG\n  for (int i = 0; i < numOfArray; i++)\n    if (i == 0) DPRINTF(\"%d\", array[i]);\n    else        printf(\" %d\", array[i]);\n  cout << endl;\n#endif // DEBUG\n\n  int sortedArray[numOfArray];\n  for (int i = 0; i < numOfArray; i++)\n    sortedArray[i] = array[i];\n\n  sort(sortedArray, sortedArray + numOfArray);\n\n#if DEBUG\n  for (int i = 0; i < numOfArray; i++)\n    if (i == 0) DPRINTF(\"%d\", sortedArray[i]);\n    else        printf(\" %d\", sortedArray[i]);\n  cout << endl;\n#endif // DEBUG\n\n  // First, find a loop where each element is sorted\n  //   Suppose array of { 2 1 8 10 7 9 }\n  //   then, sorted array should be { 1 2 7 8 9 10 }\n  //   In this case, we could find two loops;\n  //     Loop 1 : { 2 1 } - { 1 2 }\n  //     Loop 2 : { 8 10 7 9 } - { 7 8 9 10 }\n\n  bool visited[numOfArray];\n  fill(visited, visited + numOfArray, 0);\n\n  vector<vector<int>> loops;\n\n  for (int i = 0; i < numOfArray; i++)\n  {\n    if (visited[i])\n      continue;\n\n    int idx = i;\n    vector<int> loop;\n\n    while (!visited[idx])\n    {\n      loop.push_back(idx);\n      visited[idx] = true;\n\n      int num = array[idx];\n      idx = findIndexOf(num, sortedArray, numOfArray);\n    }\n\n    loops.push_back(loop);\n  }\n\n#if DEBUG\n  for (uint32_t i = 0; i < loops.size(); i++) {\n    DPRINTF(\"Loop %d : \",i);\n    const vector<int> l = loops[i];\n    for (uint32_t j = 0; j < l.size(); j++) {\n      printf(\" %d\", l[j]);\n    }\n    cout << endl;\n  }\n#endif\n\n  // Let's calculate a cost when we will need to sort out\n  // Note that we have to check two cases in a way of sorting, and compare of which is light\n  // Take a look at loop 2 case;\n  //   { 8 10 7 9 } will sorted, and it becomes { 7 8 9 10 }\n  //   The cost should be 48;\n  //   The general formula will be : Sigma(Wi) + min(Wi) * (N-2)\n  //\n  //   Be careful that we could swap with a number of another loop;\n  //   Let's say swap 1 of loop 1 with 7 of loop 2\n  //   and sort { 8 10 1 9 }, and it will be { 1 8 9 10 }\n  //   then swap again, 1 and 7, finally the array will be sorted properly as { 7 8 9 10 }\n  //   In this case, the cost should be 45\n  //   The general formula should be : Signma(Wi) + min(Wi) + x * (N+1)\n\n  for (uint32_t i = 0; i < loops.size(); i++)\n  {\n    vector<int> l = loops[i];\n\n    if (l.size() < 2)\n      continue; // means the number will be alredy sorted, no need to consider\n\n    int costA, costB;\n    costA = calcCostSimple(array, l);\n    int x = findMinOutsideLoop(l, array, sortedArray);\n    if (x < 0)\n      costB = INT_MAX;\n    else\n      costB = calcCostSwap(array, l, x);\n\n    DPRINTF(\"Loop %d : Simple cost %d  Swap cost %d  x %d\\n\", i, costA, costB, x);\n\n    g_cost += min(costA, costB);\n  }\n\n  cout << g_cost << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(auto i=0;i<n;i++)\n\nint main(){\n\tint n;\n\tcin >> n;\n\tint A[n], B[n], T[10001], minw = 10000;\n\tr(i, n){\n\t\tcin >> A[i];\n\t\tminw = min(minw, A[i]);\n\t}\n\n\tint ans = 0;\n\tbool V[n];\n\tr(i, n){\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B, B+n);\n\tr(i, n) T[B[i]] = i;\n\tr(i, n){\n\t\tif(V[i]) continue;\n\t\tint cur = i, S = 0, m = 10000, an = 0;\n\t\twhile(true){\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif(V[cur])break;\n\t\t}\n\t\tans += min(S + (an-2)*m, m + S + (an+1)*minw);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define max 1000\n#define vmax 10000\nint n,A[max],allMin;\nint B[max];//定义排序之后的货物\nint T[vmax];//值每一个货物应该摆放的位置\nint sum;//存储总成本\nbool Flag[max];//标志当前货物是否被摆放到正确位置\nint deal(){\nint fsum=0;\nfor(int i=0;i<n;i++){//从0开始检索当前位置是否被摆放\n    if(Flag[i]==true) continue;\n    int now=i;\n    int sinCirvalue=0;\n    int sinMin=vmax;\n    int sNum=0;\n    while(1){\n        Flag[now]=true;\n        sNum++;\n        sinMin=min(sinMin,A[now]);\n        sinCirvalue+=A[now];\n        now=T[A[now]];\n        if(Flag[now]==true) break;\n    }\n    fsum+=min(sinCirvalue+(sNum-2)*sinMin,sinCirvalue+sinMin+(sNum+1)*allMin);\n}\nreturn fsum;\n}\nint main(){\n    cin>>n;\n    allMin=vmax;\n    for(int i=0;i<n;i++){\n    cin>>A[i];\n    B[i]=A[i];\n    allMin=min(allMin,A[i]);\n    Flag[i]=false;\n    }\n    sort(B,B+n);//得到最后的排序结果\n    for(int i=0;i<n;i++){\n    T[B[i]]=i;//索引是货物的重量，值是这个货物应该摆放的位置\n    }\n    sum=deal();\n    cout<<sum<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// class point\tの練習（クラスの高度な実装）\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n\ntypedef long long llong;\nusing namespace std;\n\n\nint main() {\n\tint n;\n\tint w[1000];\n\tint sorted_w[1000];\n\tbool has_arrived[1000] = { false };\n\tint pos_save[10010];\n\tllong sumcost = 0;\n\tint min_cycle;\n\tint min_all;\n\tint origin_pos;\n\tint move_pos;\n\tint num_cycle;\n\tint sum_cycle;\n\tint plan_inside, plan_outside;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> w[i];\n\t\tsorted_w[i] = w[i];\n\t\tpos_save[w[i]] = i;\n\t}\n\tsort(sorted_w, sorted_w + n);\n\tmin_all = sorted_w[0];\n\n\n\tfor (int i = 0; i < n; i++) {\n\t\tmin_cycle = w[i];\n\t\tsum_cycle = w[i];\n\t\torigin_pos = i;\n\t\tmove_pos = pos_save[sorted_w[i]];\n\t\tnum_cycle = 0;\n\t\twhile (move_pos != origin_pos&&!has_arrived[i]) {\n\t\t\tnum_cycle++;\n\t\t\tmin_cycle = min(min_cycle, w[move_pos]);\n\t\t\tsum_cycle += w[move_pos];\n\n\t\t\thas_arrived[origin_pos] = true;\n\t\t\thas_arrived[move_pos] = true;\n\t\t\tmove_pos = pos_save[sorted_w[move_pos]];\n\t\t\t\n\t\t}\n\t\tif (num_cycle) {\n\n\t\t\tplan_inside = num_cycle * min_cycle + sum_cycle - min_cycle;\n\t\t\tplan_outside = 2 * min_all + 2 * min_cycle + min_all * num_cycle + sum_cycle - min_cycle;\n\t\t\tsumcost += min(plan_inside, plan_outside);\n\t\t}\n\t}\n\tcout << sumcost << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define PB push_back\n\nint Bubblesort(vector<int>&);\n\nint main(int argc,char* argv[]){\n  int n,x;\n  vector<int> vi;\n\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>x;\n    vi.PB(x);\n  }\n\n  cout<<Bubblesort(vi)<<endl;\n  return 0;\n}\n\nint Bubblesort(vector<int>& vi){\n  int cnt=0;\n  int key,vecsize=vi.size();\n\n  for(int i=vecsize-1;i>0;i--){\n    key=i;\n    for(int j=i-1;j>=0;j--){\n      if(vi[key]<vi[j])\n\tkey=j;\n    }\n    if(key!=i)\n      cnt+=vi[key]+vi[i];\n    swap(vi[key],vi[i]);\n  }\n  return cnt;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n\nint cost=0;\n\n\nint SortCost(int A[], int n, int min, int min1)\n{\n\tint i,c=0,d;\n\tfor(i=0;i<=n-1;i++)\n\t{\n\t\tif(A[i]!=min) c+=A[i]+min;\n\t}\n\td=c+2*(min+min1)-(n-1)*(min-min1);\n\tif(c<d) cost+=c;\n\telse cost+=d;\n}\n\nint partition(int A[], int p, int r)\n{\n\tint i,j;\n\tint x,temp;\n\t\n\tx=A[r];\n\ti=p-1;\n\tfor(j=p;j<=r-1;j++)\n\t{\n\t\tif(A[j]<=x)\n\t\t{\n\t\t\ti++;\n\t\t\ttemp=A[j];\n\t\t\tA[j]=A[i];\n\t\t\tA[i]=temp;\n\t\t}\n\t}\n\ttemp=A[r];\n\tA[r]=A[i+1];\n\tA[i+1]=temp;\n\treturn i+1;\n}\n\nint quickSort(int A[], int p, int r)\n{\n\tint q;\n\t\n\tif(p<r)\n\t{\n\t\tq=partition(A,p,r);\n\t\tquickSort(A,p,q-1);\n\t\tquickSort(A,q+1,r);\n\t}\n}\n\nint bs (int A[], int n, int c) \n {\n    int j,k,l;\n    j=0;\n    k=n-1;\n    while(1)\n    {\n        if(j<=k)\n        {\n            l=(j+k)/2;\n            if(A[l] > c)\n            {\n                k=l-1;\n            }\n            else if(A[l] < c)\n            {\n                j=l+1;\n            }\n            else\n            {\n                return l;\n            }\n        }\n    }\n}\n\n\nint main()\n{\n\tint i,j,n,k;\n\tint A[1000];\n\tint B[1000];\n\tint S[1000];\n\tint a[1000];\n\t\n\tscanf(\"%d\",&n);\n\t\n\tfor(i=0;i<=n-1;i++) \n\t{\n\t\tscanf(\"%d\",&A[i]);\n\t\tS[i]=A[i];\n\t\ta[i]=0;\n\t}\n\t\n\tquickSort(S,0,n-1);\n\t\n\tfor(i=0;i<=n-1;i++)\n\t{\n\t\tj=0;\n\t\tif(a[i]==0 && A[i]!=S[i])\n\t\t{\n\t\t\tB[j]=A[i];\n\t\t\tj++;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tk=bs(S,n,B[j-1]);\n\t\t\t\tB[j]=A[k];\n\t\t\t\ta[k]=1;\n\t\t\t\tj++;\n\t\t\t} while(A[k]!=B[0]);\n\t\t\tSortCost(B,j-1,S[i],S[0]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",cost);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\nusing namespace std;\nint n;\nint s;\nint a[1001];\nint v[1001];\nint t[10001];\nint all2=0;\nvoid solve() {\n\tint b[1001];\n\tfor (int i = 0; i < n; i++) {\n\t\tb[i] = a[i];\n\t}\n\tsort(b, b + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tt[b[i]] = i;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tint key = 0;\n\t\tint all = 0;\n\t\tint j = i;\n\t\tint count = 0;\n\t\twhile (!v[i])\n\t\t{\n\t\t\tkey = a[j];\n\t\t\tif (key == b[i])\n\t\t\t{\n\t\t\t\tv[i] = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tall += b[i] + a[j];\n\t\t\tv[t[a[j]]] = 1;\n\t\t\tj = t[a[j]];\n\t\t\tcount++;\n\t\t}\n\t\tall2 += min(all,all+2*(b[i]+b[0])-count*(b[i]-b[0]));\n\t}\n}\nint main() {\n\tcin >> n;\n\ts = 10000;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\ts = min(s, a[i]);\n\t}\n\tsolve();\n\tcout << all2<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n* Note: This template uses some c++11 functions , so you have to compile it with c++11 flag.\n*       Example:-   $ g++ -std=c++11 c++Template.cpp\n*\n* Author : Akshay Pratap Singh\n* Handle: code_crack_01\n*\n*/\n \n/********   All Required Header Files ********/\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <iterator>\n#include <list>\n#include <stack>\n#include <map>\n#include <set>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <limits>\n#include <time.h>\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\nusing namespace std;\n\n/*******  All Required define Pre-Processors and typedef Constants *******/\n#define SCD(t) scanf(\"%d\",&t)\n#define SCLD(t) scanf(\"%ld\",&t)\n#define SCLLD(t) scanf(\"%lld\",&t)\n#define SCC(t) scanf(\"%c\",&t)\n#define SCS(t) scanf(\"%s\",t)\n#define SCF(t) scanf(\"%f\",&t)\n#define SCLF(t) scanf(\"%lf\",&t)\n#define MEM(a, b) memset(a, (b), sizeof(a))\n#define FOR(i, j, k, in) for(int i=j ; i<k ; i+=in)\n#define RFOR(i, j, k, in) for(int i=j ; i>=k ; i-=in)\n#define REP(i, j) FOR(i, 0, j, 1)\n#define RREP(i, j) RFOR(i, j, 0, 1)\n#define all(cont) cont.begin(), cont.end()\n#define rall(cont) cont.end(), cont.begin()\n#define FOREACH(it, l) for (auto it = l.begin(); it != l.end(); it++)\n#define IN(A, B, C) assert( B <= A && A <= C)\n#define MP make_pair\n#define PB push_back\n#define INF (int)1e9\n#define EPS 1e-9\n#define PI 3.1415926535897932384626433832795\n#define MOD 1000000007\n#define read(type) readInt<type>()\ntypedef long long int ll;\ntypedef unsigned long long int  ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<pii> vii;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\n\nint main(){\n\n  int N; SCD(N);\n  vi W(N);\n  REP(i, N) SCD(W[i]);\n\n  vi W_sorted(W);\n  sort(W_sorted.begin(), W_sorted.end());\n\n  ll ans = 0;\n\n  for(int i=W.size()-1; i>=0; --i){\n\n    auto itr = find(W.begin(), W.end(), W_sorted[i]);\n    if( itr-W.begin() == i ) continue;\n\n    ans += *itr + W[i];\n    swap(W[itr-W.begin()], W[i]);\n\n  }\n  \n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint n, w[1010], a[1010], b[10010], mi=100000;\nbool used[1010];\n\nint partition(int *A, int p, int r){\n  int x = A[r];\n  int i = p - 1;\n    for(int j = p;j < r;j++){\n      if(A[j] <= x){\n        i++;\n        swap(A[i], A[j]);\n      }\n    }\n    swap(A[i + 1], A[r]);\n  return i + 1;\n}\n\nvoid quicksort(int *A, int p, int r){\n  if(p < r){\n    int q = partition(A, p, r);\n    quicksort(A, p, q - 1);\n    quicksort(A, q + 1, r);\n  }\n}\n\nint solve(){\n  \n  int ans = 0;\n  \n  for(int i = 0;i < n;i++) b[a[i]] = i;\n  \n  for(int i = 0;i < n;i++){\n    int cnt = 0, sum = 0, now = i, mimi = 100000;\n    \n    if(used[i]) continue;\n    \n    while(true){\n      if(used[now]) break;\n      cnt++;\n      used[now] = true;\n      mimi = min(mimi, w[now]);\n      sum += w[now];\n      now = b[w[now]];\n    }\n    \n    ans += min(sum + (cnt - 2) * mimi, sum + mi + (cnt + 1) * mimi);\n  }\n  \n  return ans;\n}\n\nint main(){\n  \n  cin >> n;\n  for(int i = 0;i < n;i++){\n    cin >> w[i];\n    a[i] = w[i];\n    mi = min(mi, w[i]);\n  }\n  \n  quicksort(a, 0, n - 1);\n  \n  cout << solve() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nint sum(vi &a) {\n  int s = 0;\n  for (auto i: a) s += i;\n\n  return s;\n}\n\nint mincost_sort(vi &a, int k) {\n  vector<pair<int, int>> b(a.size()), c(k + 1, make_pair(-1, 0));\n\n  rep(i, a.size()) {\n    // from, current index\n    c[a[i]].first = i;\n    // to\n    c[a[i]].second++;\n  }\n\n  for (int i = 1; i <= k; i++) c[i].second += c[i - 1].second;\n\n  for (int i = (int)a.size() - 1; i >= 0; i--) {\n    auto &p = c[a[i]];\n    b[p.second - 1] = make_pair(p.first, a[i]); // from, value\n    // p.second--;\n  }\n  \n  int total = 0;\n  for (auto bp: b) {\n    int cost = 0;\n    auto &p = c[bp.second];\n\n    int &x = p.first;\n    vi cycle;\n    cycle.push_back(a[x]);\n    while (x != p.second - 1) {\n      int y = b[x].first;\n      cycle.push_back(a[y]);\n\n      swap(a[x], a[y]);\n      cost += a[x] + a[y];\n\n      c[a[x]].first = x;\n      x = y;\n    }\n    \n    if (cycle.size() > 1) {\n      int cost1 = sum(cycle) + ((int)cycle.size() - 2) * cycle[0], cost2 = INT_MAX;\n      \n      if (cycle[0] != b[0].second)\n        cost2 = sum(cycle) + cycle[0] + ((int)cycle.size() + 1) * b[0].second;\n      \n      total += min(cost1, cost2);\n    }\n  }\n\n  return total;\n}\n\nint main() {\n  int n, k = 0;\n  cin >> n;\n\n  vi w(n);\n  rep(i, n) {\n    scanf(\"%d\", &w[i]);\n    k = max(k, w[i]);\n  }\n  \n  int total = mincost_sort(w, k);\n\n  cout << total << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint n, w[1010], a[1010], b[10010] = {}, mi=100000;\nbool used[1010];\n\nint partition(int *A, int p, int r){\n  int x = A[r];\n  int i = p - 1;\n    for(int j = p;j < r;j++){\n      if(A[j] <= x){\n        i++;\n        swap(A[i], A[j]);\n      }\n    }\n    swap(A[i + 1], A[r]);\n  return i + 1;\n}\n\nvoid quicksort(int *A, int p, int r){\n  if(p < r){\n    int q = partition(A, p, r);\n    quicksort(A, p, q - 1);\n    quicksort(A, q + 1, r);\n  }\n}\n\nint solve(){\n  \n  int ans = 0;\n  \n  quicksort(a, 0, n - 1);\n  for(int i = 0;i < n;i++) b[a[i]] = i;\n  \n  for(int i = 0;i < n;i++){\n    int cnt = 0, sum = 0, now = i, mimi = 100000;\n    \n    if(used[i]) continue;\n    \n    while(true){\n      if(used[now]) break;\n      cnt++;\n      used[now] = true;\n      mimi = min(mimi, w[now]);\n      sum += w[now];\n      now = b[w[now]];\n    }\n    \n    ans += min(sum + (cnt - 2) * mimi, sum + mimi + (cnt + 1) * mi);\n  }\n  \n  return ans;\n}\n\nint main(){\n  \n  cin >> n;\n  for(int i = 0;i < n;i++){\n    cin >> w[i];\n    a[i] = w[i];\n    mi = min(mi, w[i]);\n  }\n  \n  cout << solve() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdint.h>\n#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <climits>\nusing namespace std;\n\n#define DEBUG (0)\n\n#if DEBUG\n#define DPRINTF(...) do { \\\n    printf(\"D(L%d) %s: \", __LINE__, __func__); \\\n    printf(__VA_ARGS__); \\\n  } while (false)\n#else\n#define DPRINTF(...)\n#endif // DEBUG\n\nint g_cost = 0;\n\nvoid swap(int array[], int i0, int i1)\n{\n  int temp = array[i1];\n  array[i1] = array[i0];\n  array[i0] = temp;\n}\n\nvoid selectionSort(int array[], int start, int end)\n{\n  for (int i = start; i < end - 1; i++)\n  {\n\n    int min = array[i];\n    int minIdx = i;\n\n    for (int j = i + 1; j < end; j++)\n    {\n      if (min > array[j])\n      {\n        min = array[j];\n        minIdx = j;\n      }\n    }\n\n    if (minIdx != i)\n    {\n      DPRINTF(\"swap array[%d] (%d) and array[%d] (%d)\\n\",\n          i, array[i], minIdx, array[minIdx]);\n      swap(array, i, minIdx);\n      g_cost += array[i] + array[minIdx];\n    }\n  }\n}\n\nint main()\n{\n  int numOfArray;\n  cin >> numOfArray; cin.ignore();\n\n  int array[numOfArray];\n  for (int i = 0; i < numOfArray; i++)\n    cin >> array[i];\n\n#if DEBUG\n  for (int i = 0; i < numOfArray; i++)\n    if (i == 0) DPRINTF(\"%d\", array[i]);\n    else        printf(\" %d\", array[i]);\n  cout << endl;\n#endif // DEBUG\n\n  // selection sort\n  const int start = 0;\n  const int end = numOfArray;\n  selectionSort(array, start, end);\n\n  cout << g_cost << endl;\n\n#if DEBUG\n  for (int i = 0; i < numOfArray; i++)\n    if (i == 0) DPRINTF(\"%d\", array[i]);\n    else        printf(\" %d\", array[i]);\n  cout << endl;\n#endif // DEBUG\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst int MAXN = 200005;\n\nint w[1005], B[1005], L[1005], flag[1005];\n\nint main(){\n\tint n, ans = 0, Min = INF;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> w[i];\n\t\tB[i] = w[i];\n\t\tMin = min(Min, w[i]);\n\t}\n\tsort(B, B + n);\n\tfor(int i = 0; i < n; i++)\t\n\t\tL[B[i]] = i;\n\tfor(int i = 0; i < n; i++){\n\t\tif(flag[i])\n\t\t\tcontinue;\n\t\tint temp = i, S = INF, m = 0, cnt = 0;\n\t\twhile(!flag[temp]){\n\t\t\tcnt++;\n\t\t\tflag[temp] = 1;\n\t\t\tS = min(S, w[temp]);\n\t\t\tm += w[temp];\n\t\t\ttemp = L[w[temp]];\n\t\t}\n\t\tans += min(m + (cnt - 2) * S, m + (cnt + 1) * Min + S);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint silly_sort(vector<int> v, int n){\n\tvector<pair<int, int> > temp(n);\n\tfor (int i = 0; i < n; i++){\n\t\ttemp[i].first = v[i];\n\t\ttemp[i].second = i;\n\t}\n\tsort(temp.begin(), temp.end());\n\n\tint cost = 0, s = temp[0].first;\n\tfor (int i = 0; i < n; i++){\n\t\tint j = temp[i].second;\n\t\tif (j != i && j >= 0){\n\t\t\tint n = 1, amin, sum;\n\t\t\tamin = sum = temp[i].first;\n\t\t\twhile (j != i){\n\t\t\t\tint next = temp[j].second;\n\t\t\t\tsum += temp[j].first;\n\t\t\t\tn++;\n\t\t\t\ttemp[j].second = -1;\n\t\t\t\tj = next;\n\t\t\t}\n\t\t\tcost += min(sum + (n - 2) * amin, sum + amin + (n + 1) * s);\n\t\t}\n\t}\n\treturn cost;\n}\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<int> v(n);\n\tfor (int i = 0; i < n; i++) cin >> v[i];\n\tcout << silly_sort(v, n) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\nusing namespace std;\n\n#define MAX_NUM 1000\n\nint W[MAX_NUM];\nint N;\n\nint Compare(const void *a, const void *b)\n{\n    return *(int*)a - *(int*)b;\n}\n\nvoid Swap(int idx1, int idx2) {\n\tint tmp = W[idx1];\n\tW[idx1] = W[idx2];\n\tW[idx2] = tmp;\n}\n\nint SearchIdx(int wi)\n{\t\n\tfor (int i = 0; i < N; i++) {\n\t\tif (W[i] == wi) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid Copy(int *ary)\n{\n\tfor (int i = 0; i < N; i++) {\n\t\tary[i] = W[i];\n\t}\n}\n\nint main(void)\n{\n\t//input\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> W[i];\n\t}\n\n\t//minimum cost?\n\tint cost = 0;\n\tint w2[MAX_NUM];\n\tCopy(w2);\n\tqsort(w2, N, sizeof(int), Compare);\n\tfor (int i = 0; i < N; i++) {\n\t\tint idx1 = SearchIdx(w2[i]);\n\t\twhile (idx1 != i) {\n\t\t\tint idx2 = SearchIdx(w2[idx1]);\n\t\t\tSwap(idx1, idx2);\n\t\t\tcost = cost + W[idx1] + W[idx2];\n\t\t\tidx1 = idx2;\n\t\t}\n\t}\n\n\t//output\n\tcout << cost << \"\\n\";\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n#include<complex>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 1010;\nint w[MAXN];\nbool done[MAXN];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, mini = 100000;\n    cin >> n;\n    map<int, int> mp;\n    for (int i = 0; i < n; i++) {\n        cin >> w[i];\n        mp[w[i]] = 0;\n        mini = min(mini, w[i]);\n    }\n    {\n        int k = 0;\n        for (auto& p : mp) p.second = k++;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (done[i]) continue;\n        int cnt = 0, now = i, mi = 100000, sum = 0;\n        while (1) {\n            if (done[now]) break;\n            cnt++;\n            done[now] = true;\n            mi = min(mi, w[now]);\n            sum += w[now];\n            now = mp[w[now]];\n        }\n        int tmp = sum+(cnt-2)*mi;\n        tmp = min(tmp, sum+mini*(cnt-2)+2*(mini+mi));\n        ans += tmp;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// include\n//------------------------------------------\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// conversion\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\ntemplate <class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\n// math\n//-------------------------------------------\ntemplate <class T>\ninline T sqr(T x) {\n    return x * x;\n}\n\n// typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n// container util\n//------------------------------------------\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i, c) \\\n    for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort((c).begin(), (c).end())\n\n// repetition\n//------------------------------------------\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(itr, ds) for (auto itr = ds.begin(); itr != ds.end(); itr++)\n\n// constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF_INT = 2147483647;\nconst LL INF_LL = 9223372036854775807;\n\n// clear memory\n//--------------------------------------------\n#define CLR(a) memset((a), 0, sizeof(a))\n\n// vector\n//--------------------------------------------\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n\n// pair\n//--------------------------------------------\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, pair<T, U> &pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\n// vector\n//--------------------------------------------\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"{\";\n    for (int i = 0; i < vec.size(); i++) {\n        os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");\n    }\n    os << \"}\";\n    return os;\n}\n\n// list\n//--------------------------------------------\ntemplate <typename T>\nostream &operator<<(ostream &os, const list<T> &lst) {\n    os << \"{\";\n    REPI(itr, lst) {\n        os << *itr;\n        itr++;\n        if (itr != lst.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n// map\n//--------------------------------------------\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, map<T, U> &map_var) {\n    os << \"{\";\n    REPI(itr, map_var) {\n        os << *itr;\n        itr++;\n        if (itr != map_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n// set\n//--------------------------------------------\ntemplate <typename T>\nostream &operator<<(ostream &os, set<T> &set_var) {\n    os << \"{\";\n    REPI(itr, set_var) {\n        os << *itr;\n        itr++;\n        if (itr != set_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n// dump\n//--------------------------------------------\n#define DUMPOUT cerr\n\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail>\nvoid dump_func(Head &&head, Tail &&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) > 0) {\n        DUMPOUT << \", \";\n    }\n    dump_func(std::move(tail)...);\n}\n#ifdef DEBUG_\n#define DEB\n#define dump(...)                                                       \\\n    DUMPOUT << \"  \" << string(#__VA_ARGS__) << \": \"                     \\\n            << \"[\" << to_string(__LINE__) << \":\" << __FUNCTION__ << \"]\" \\\n            << endl                                                     \\\n            << \"    \",                                                  \\\n        dump_func(__VA_ARGS__)\n#else\n#define DEB if (false)\n#define dump(...)\n#endif\n\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n;\nint a[MAX];\n\nint main(void) {\n    cin >> n;\n    int s = VMAX;\n    REP(i, n) {\n        cin >> a[i];\n        s = min(s, a[i]);\n    };\n\n    int ans = 0;\n\n    int b[MAX];\n    bool v[MAX];\n    REP(i, n) {\n        b[i] = a[i];\n        v[i] = false;\n    }\n\n    sort(b, b + n);\n\n    int t[VMAX + 1];\n    REP(i, n) t[b[i]] = i;\n    REP(i, n) {\n        if (v[i]) continue;\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while (true) {\n            v[cur] = true;\n            an++;\n            int x = a[cur];\n            m = min(m, x);\n            S += x;\n            cur = t[x];\n            if (v[cur]) break;\n        }\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n\n  long long int n;\n  cin >> n;\n\n  vector< long long int > v, vs;\n\n  for ( long long int i = 0; i < n; i++ ) {\n\n    long long int in;\n    cin >> in;\n    v.push_back( in );\n    vs.push_back( in );\n\n  }\n\n  sort( vs.begin(), vs.end() );\n\n  vector< long long int > t;\n\n  long long int mi = 100000;\n\n  for ( long long int i = 0; i < n; i++ ) {\n    mi = min( mi, v[i] );\n    for ( long long int j = 0; j < n; j++ ) {\n      if ( v[i] == vs[j] ) {\n\tt.push_back( j );\n\tbreak;\n      }\n    }\n  }\n\n  long long int ans = 0;\n\n  for ( long long int i = 0; i < n; i++ ) {\n\n    if ( vs[i] != v[i] ) {\n\n      long long int k = t[i];\n      long long int m = v[i];\n      long long int cnt = v[i];\n      long long int num = 1;\n\n      while( k != i ) {\n\tnum++;\n\tcnt += v[k];\n\tm = min( m, v[k] );\n\tswap( v[i], v[k] );\n\tk = t[k];\n      }\n\n      ans += min( ( num - 2 ) * m, m + ( num + 1 ) * mi ) + cnt;\n\n    }\n    /*\n    for ( long long int j = 0; j < n; j++ ) {\n      cout << \" \" << v[j];\n    }\n    cout << endl;\n    */\n  }\n\n  cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <list>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cmath>\n#include <string>\n#define N 1005\n#define INF (1 << 30)\ntypedef long long ll;\nusing namespace std;\n\nint main()\n{\n\tint weight[N];\n\tint sorted[N];\n\tint idx[40005];\n\tint n, x = INF, ans = 0;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tscanf(\"%d\", weight + i);\n\t\tsorted[i] = weight[i];\n\t\tif (x > weight[i])\n\t\t\tx = weight[i];\n\t}\n\tsort(sorted, sorted + n);\n\tfor (int i = 0; i < n; ++i)\n\t\tidx[sorted[i]] = i;\n\tbool visited[N]{ false };\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tif (visited[i] || i == idx[weight[i]])\n\t\t\tcontinue;\n\t\tint Min = weight[i], num = 1, sum1 = weight[i];\n\t\tint j = i;\n\t\twhile (true)\n\t\t{\n\t\t\tvisited[j] = true;\n\t\t\tj = idx[weight[j]];\n\t\t\tif (visited[j])\n\t\t\t\tbreak;\n\t\t\tMin = min(Min, weight[j]);\n\t\t\tsum1 += weight[j];\n\t\t\t++num;\n\t\t\t\n\t\t}\n\t\tans += min(Min + (num + 1) * x, (num - 2) * Min) + sum1;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int INF = 1000000;\n\nstruct node\n{\n\tint num;\n\tint place;  \n};\n\nint partition(node *A,int p,int r)\n{\n\tint j,temp;\n\tnode x;\n\n\tx = A[r];\n\tj = p-1;\n\n\tfor(int i = p; i < r; i++)\n\t{\n\t\tif (A[i].num <= x.num)\n\t\t{\n\t\t\tj++;\n\t\t\ttemp = A[i].num;\n\t\t\tA[i].num = A[j].num;\n\t\t\tA[j].num = temp;\n\t\t}\n\t}\n\n\ttemp = A[j+1].num;\n\tA[j+1].num = A[r].num;\n\tA[r].num = temp;\n\n\treturn j+1;\n}\n\nvoid quicksort(node *A,int p,int r)\n{\n\tint q;\n\n\tif (p < r)\n\t{\n\t\tq = partition(A,p,r);\n\t\tquicksort(A,p,q-1);\n\t\tquicksort(A,q+1,r);\n\t}\n}\n\n\nint main()\n{\n\tint n,sum,minall,mini,sol,cnt,j;\n\tnode a[1000] = {0},b[1000] = {0};\n\n\tsol = 0;\n\tminall = INF;\n\n\tscanf(\"%d\", &n);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i].num);\n\t\ta[i].place = i;\n\t\tb[i] = a[i];\n\t\tb[i].place = i;\n\n\t\tif (minall > a[i].num)\n\t\t{\n\t\t\tminall = a[i].num;\n\t\t}\n\t}\n\n\tquicksort(b,0,n-1);\n\n\t\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tsum = 0;\n\n\t\tif (a[i].num > 0)\n\t\t{\n\t\t\tsum = a[i].num;\n\t\t\tmini = a[i].num;\n\t\t\tcnt = 1;\n\t\t\tj = i;\n\n\t\t\twhile(b[a[j].place].num != a[i].num)\n\t\t\t{\n\t\t\t\tfor(int k = 0; k < n; k++)\n\t\t\t\t{\n\t\t\t\t\tif (a[k].num == b[a[j].place].num)\n\t\t\t\t\t{\n\t\t\t\t\t\tj = k;\n\t\t\t\t\t\tsum += a[k].num;\n\t\t\t\t\t\tcnt++;\n\n\t\t\t\t\t\tif (mini > a[k].num)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmini = a[k].num;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ta[k].num = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\ta[i].num = -1;\n\n\t\t\tsol += min(sum + mini * (cnt -2), sum + minall + cnt * mini);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", sol);\n\n\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n,A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint solve(){\n\tint ans = 0;\n\t\n\tbool V[MAX];\n\tfor(int i=0; i<n; i++){\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B, B+n);\n\tfor(int i = 0; i<n; i++) T[B[i]] = i;\n\tfor(int i = 0; i<n; i++){\n\t\tif( V[i] ) continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile( 1 ){\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m,v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif ( V[cur] ) break;\n\t\t}\n\t\tans += min(S + (an - 2)* m, m+S+(an+1)*s);\n\t}\n\treturn ans;\n}\n\n\nint main(){\n\tcin >> n;\n\ts = VMAX;\n\tfor(int i=0; i<n; i++){\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tint ans = solve();\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define int(x) int x; scanf(\"%d\",&x)\n#define input(x) scanf(\"%d\",&x)\n#define rep(x,n) for(int x = 0; x < n; x++)\n#define _br printf(\"\\n\")\n#define INF 2000000000\n\nint A[1000],SortA[1000],Type[1000],NoT[1000] = {},NNot = 0;\n\n//sum,min\nint Typesum_min[1000][2] = {};\nbool Complete[1000] = {};\nint MIN;\n\nvoid typing(int type, int iro){\n    while (!Complete[type]) {\n        Type[type] = iro;\n        Typesum_min[iro][0] += A[type];\n        if (Typesum_min[iro][1] > A[type]) {\n            Typesum_min[iro][1] = A[type];\n        }\n        NoT[iro]++;\n        Complete[type] = true;\n        \n        type = SortA[type];\n    }\n}\n\nvoid DecideType(int n){\n    int T = 0;\n    rep(i,n){\n        if (!Complete[i]) {\n            typing(i,T);\n            Typesum_min[T][0] -= Typesum_min[T][1];//????¨???????????°??????????????????????\n            NNot++;\n            T++;\n        }\n    }\n}\n\nvoid solve(){\n    int SSum = 0;\n    rep(i,NNot){\n        if(NoT[i] != 1){\n            if(MIN*(NoT[i]-1)+2*(Typesum_min[i][1] + MIN) >= Typesum_min[i][1]*(NoT[i]-1)) {\n                SSum += Typesum_min[i][0] + Typesum_min[i][1]*(NoT[i]-1);\n            }else{\n                SSum += Typesum_min[i][0] + MIN*(NoT[i]-1)+2*(Typesum_min[i][1] + MIN);\n            }\n        }\n    }\n    printf(\"%d\\n\",SSum);\n}\n\nint main(){\n    priority_queue<pair<int,int> > PQ;\n    int(n);\n    rep(i,n){\n        input(A[i]);\n        PQ.push(make_pair(-A[i],i));\n        Typesum_min[i][1] = INF;\n    }\n    \n    rep(i,n){\n        SortA[i] = PQ.top().second;\n        PQ.pop();\n    }\n    MIN = A[SortA[0]];\n    DecideType(n);\n    \n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nconstexpr int MAX_WEIGHT = 10000; // 重さの最大値\n\nint calc_cost(vector<int>& weight, int n, int min_weight){\n    int cost = 0;\n\n    vector<int> sorted_wight = weight;\n    sort(sorted_wight.begin(), sorted_wight.end());   // ソートされた状態を作る\n\n    vector<int> idx_record(MAX_WEIGHT + 1);\n    for(int i = 0; i < n; ++i){\n        // ソート済みの要素のインデックスがどこにあるか記録\n        idx_record[sorted_wight[i]] = i;\n    }\n\n    vector<bool> verified(n, false);  // コストを確認済みかどうか\n    for(int i = 0; i < n; ++i){\n        if(verified[i]){\n            continue;   // 確認済みなら次へ\n        }\n        int cur = i;        // 自分の現在地（カーソル）\n        int sum_in_loop = 0;          // ループ内の重さ合計  \n        int min_in_loop = MAX_WEIGHT; // ループ内での重さ最小値\n        int count = 0;      // 交換回数\n        while(true){\n            verified[cur] = true;\n            count++;\n            int current_weight = weight[cur];    // \n            min_in_loop = min(min_in_loop, current_weight);\n            sum_in_loop += current_weight;\n            cur = idx_record[current_weight];\n            if(verified[cur]){\n                break;  // 一周回ったら終わり\n            }\n        }\n        // sum_in_loop に min_in_loop が含まれている. 自分は入れ替える必要ない. なので count - 2 \n        int not_borrow_weight = sum_in_loop + (count - 2) * min_in_loop;\n        \n        // min_weight を取ってくるのに 1回 必要なので count + 1\n        int borrow_min_weight = min_in_loop + sum_in_loop + (count + 1) * min_weight;\n        \n        cost += min(not_borrow_weight, borrow_min_weight);\n    }\n    return cost;\n}\n\nint main(){\n\n    int n;\n    cin >> n;\n    \n    int min_weight = MAX_WEIGHT; // 荷物の中での重さ最小値\n    vector<int> weight(n);\n    for(int i = 0; i < n; ++i){\n        cin >> weight[i];\n        min_weight = min(min_weight, weight[i]);\n    }\n\n    int cost = calc_cost(weight, n, min_weight);\n\n    cout << cost << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 10000;\nstatic const int VMAX = 100000;\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve(){\n    int i,ans = 0;\n    \n    bool V[MAX];\n    for(i=0;i<n;i++){\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B,B+n);\n    for(i=0;i<n;i++) T[B[i]] = i;\n    for(i=0;i<n;i++){\n        if(V[i]) continue;\n        int cur=i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while(1){\n            V[cur] = true;\n            an++;\n            int v=A[cur];\n            m = min(m,v);\n            S+=v;\n            cur = T[v];\n            if(V[cur]) break;\n        }\n        ans += min(S+(an-2)*m,m+S+(an+1)*s);\n    }\n    return ans;\n}\n\nint main(){\n    int i;\n    cin>>n;\n    s=VMAX;\n    for(i=0;i<n;i++){\n        cin>>A[i];\n        s=min(s,A[i]);\n    }\n    int ans = solve();\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define MIN(a,b) ((a)<(b)?(a):(b))\n\nvoid merge(vector<pair<int,int> >& w, int left, int mid, int right) {\n\tvector<pair<int,int> > L,R;\n\tint n1=mid-left;\n\tint n2=right-mid;\n\tint i=0,j=0,k;\n\tL.resize(n1+1);\n\tR.resize(n2+1);\n\tfor(i=0; i<n1; ++i) {\n\t\tL[i]=w[left+i];\n\t}\n\tL[n1].first = -1;\n\tL[n1].second = 1000000001;\n\tfor(i=0; i<n2; ++i) {\n\t\tR[i]=w[mid+i];\n\t}\n\tR[n2].first = -1;\n\tR[n2].second = 1000000001;\n\n\ti=j=0;\n\tfor(k=left; k<right; ++k) {\n\t\tif(L[i].second < R[j].second) {\n\t\t\tw[k]=L[i];\n\t\t\t++i;\n\t\t} else {\n\t\t\tw[k]=R[j];\n\t\t\t++j;\n\t\t}\n\t}\n\treturn;\n}\n\nvoid mergeSort(vector<pair<int,int> >& w, int left, int right) {\n\tif(left+1<right) {\n\t\tint mid=left+(right-left)/2;\n\t\tmergeSort(w,left,mid);\n\t\tmergeSort(w,mid,right);\n\t\tmerge(w,left,mid,right);\n\t}\n\treturn;\n}\n\nint main() {\n\tint n;\n\tint i,j;\n\tint total=0;\n\tint subtotal,c;\n\tvector<int> checker;\n\tvector<pair<int,int> > w; // first=original_index, second =weight_value will be sorted.\n\tscanf(\"%d\",&n);\n\tw.resize(n);\n\tchecker.resize(n);\n\tfor(i=0; i<n; ++i) {\n\t\tchecker[i]=0;\n\t\tw[i].first=i;\n\t\tscanf(\"%d\",&w[i].second);\n\t}\n\tmergeSort(w,0,n);\n\tfor(i=0; i<n; ++i) {\n\t\tif(checker[i]==1 || w[i].first==i) {\n\t\t\tcontinue; // already checked or unmoved\n\t\t}\n\t\tc=subtotal=0;\n\t\tchecker[i]=1;\n\t\tj=w[i].first;\n\t\twhile(j!=i) {\n\t\t\tsubtotal+=w[i].second+w[j].second;\n\t\t\tchecker[j]=1;\n\t\t\tj=w[j].first;\n\t\t\t++c;\n\t\t}\n\t\ttotal+=MIN(subtotal,subtotal-(w[i].second-w[0].second)*c);\n\t}\n\tprintf(\"%d\\n\",total);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n    int n;\n    cin >> n;\n    int A[n];\n    int B[n];\n    for (int i = 0; i < n; i++) {\n        cin >> A[i];\n        B[i] = A[i];\n    }\n    sort(B, B + n);\n    int cnt = 0;\n    for (int i = 0; i < n; i++) {\n        int tgt_idx = find(A, A + n, B[i]) - A;\n        int n_cycle = 1;\n        while (tgt_idx != i) {\n            int dst_idx = find(A, A + n, B[tgt_idx]) - A;\n            cnt += A[tgt_idx] + A[dst_idx];\n            swap(A[tgt_idx], A[dst_idx]);\n            tgt_idx = dst_idx;\n            n_cycle++;\n        }\n        if ((n_cycle - 3) * B[i] > (n_cycle + 1) * B[0]) {\n            cnt -= (n_cycle - 3) * B[i] - (n_cycle + 1) * B[0];\n        }\n    }\n    cout << cnt << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <stack>\n#include <queue>\n#include <map>\n#include <list>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <climits>\nusing namespace std;\n\nstruct node {\n\tlong prev;\n\tlong next;\n\tint val;\n};\n\nqueue<int> merge(queue<int> q1, queue<int> q2){\n\tqueue<int> ma;\n\twhile(q1.size() || q2.size()){\n\t\tif(!q2.size() || (q1.size() && q1.front() < q2.front())){\n\t\t\tma.push(q1.front());\n\t\t\tq1.pop();\n\t\t}else{\n\t\t\tma.push(q2.front());\n\t\t\tq2.pop();\n\t\t}\n\t}\n\treturn ma;\n}\nqueue<int> sort(queue<int> q){\n\tqueue<int> nq;\n\twhile(q.size() - nq.size() > 1){\n\t\tnq.push(q.front());\n\t\tq.pop();\n\t}\n\tif(!nq.size()) return q;\n\treturn merge(sort(nq), sort(q));\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\t\n\tint wholeMin = INT_MAX;\n\tint v[n];\n\tqueue<int> q;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> v[i];\n\t\tq.push(v[i]);\n\t\twholeMin = min(wholeMin, v[i]);\n\t}\n\t\n\tqueue<node> nodes;\n\tq = sort(q);\n\twhile(q.size()){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(q.front() == v[i]){\n\t\t\t\tnode no;\n\t\t\t\tno.prev = i;\n\t\t\t\tno.next = n - q.size();\n\t\t\t\tno.val = v[i];\n\t\t\t\tnodes.push(no);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tq.pop();\n\t}\n\t\n\tvector<vector<node> > groups;\n\tvector<node> sub;\n\twhile(nodes.size()){\n\t\tsub.clear();\n\t\tnode topNode = nodes.front();\n\t\tnodes.pop();\n\t\tsub.push_back(topNode);\n\t\t\n\t\tnode curNode = topNode;\n\t\twhile(curNode.prev != curNode.next){\n\t\t\tif(curNode.next == nodes.front().prev){\n\t\t\t\tcurNode = nodes.front();\n\t\t\t\tnodes.pop();\n\t\t\t\tsub.push_back(curNode);\n\t\t\t\tif(curNode.next == topNode.prev) break;\n\t\t\t}else{\n\t\t\t\tnodes.push(nodes.front());\n\t\t\t\tnodes.pop();\n\t\t\t}\n\t\t}\n\t\t\n\t\tgroups.push_back(sub);\n\t}\n\t\n\tlong cost = 0;\n\tfor(int i = 0; i < groups.size(); i++){\n\t\tif(groups[i].size() == 1) continue;\n\t\telse if(groups[i].size() == 2) cost += groups[i][0].val + groups[i][1].val;\n\t\telse{\n\t\t\tint min = INT_MAX;\n\t\t\tlong total = 0;\n\t\t\tfor(int k = 0; k < groups[i].size(); k++){\n\t\t\t\tmin = min < groups[i][k].val ? min : groups[i][k].val;\n\t\t\t\ttotal += groups[i][k].val;\n\t\t\t}\n\t\t\t\n\t\t\ttotal -= min;\n\t\t\tlong costInternal = total + min * (groups[i].size() - 1);\n\t\t\tlong costExternal = total + wholeMin * (groups[i].size() - 1) + (min + wholeMin) * 2;\n\t\t\tcost += costInternal > costExternal ? costExternal : costInternal;\n\t\t}\n\t}\n\tcout << cost << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX],T[VMAX + 1];\n\nint solve(){\n  int ans = 0;\n  bool V[VMAX];\n  for( int i = 0 ; i < n ; i++ ){\n    B[i] = A[i];\n    V[i] = false;\n  }\n  sort( B, B + n );\n  for( int i = 0 ; i < n ; i++ )T[B[i]] = i;\n  for( int i = 0 ; i < n ; i++ ){\n    if( V[i] )continue;\n    int cur = i;\n    int S = 0;\n    int m = VMAX;\n    int an = 0;\n    while( 1 ){\n      V[cur] = true;\n      an++;\n      int v = A[cur];\n      m = min( m, v);\n      S += v;\n      cur = T[v];\n      if( V[cur] )break;\n    }\n    ans += min( S + ( an - 2 ) * m, m + S  + ( an + 1 ) * s);\n  }\n  return ans;\n}\n\nint main( void ){\n  cin >> n;\n  s = VMAX;\n \n  for( int i = 0 ; i < n ; i++ ){\n    cin >> A[i];\n    s = min(s,A[i]);\n  }\n  int ans = solve();\n  cout << ans << endl;\n\n  return 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\n\nint num[1005],n,rev[1005];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&num[i]);\n\t}\n\tint res = 0;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tif(num[i] == i) continue;\n\t\tint id;\n\t\tfor(int j=1;j<=n;j++) if(num[j] == i) id = j;\n\t\tswap(num[id],num[i]);\n\t\tres += (num[id]+num[i]);\n\t}\n\tprintf(\"%d\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\n\nint B[MAX], T[VMAX + 1];\n\nint slove() {\n    int ans = 0;\n    bool V[MAX];\n\n    for (int i = 0; i < n; i++) {\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B, B + n);\n    for (int i = 0; i < n; i++) {\n        T[B[i]] = i;\n    }\n    for (int i = 0; i < n; i++) {\n        if (V[i]) continue;\n\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while (true) {\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m, v);\n            S += v;\n            cur = T[v];\n            if (V[cur]) break;\n        }\n        ans+=min(S+(an-2)*m,m+S+(an+1)*s);\n    }\n    return ans;\n}\n\nint main() {\n    cin >> n;\n    s = VMAX;\n    for (int i = 0; i < n; i++) {\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n\n    int ans = slove();\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\nint n, s, A[MAX], B[MAX], T[VMAX+1];\n\nint solve() {\n    int i, ans = 0;\n    bool V[MAX];\n    for(i=0; i<n; ++i) {B[i] = A[i]; V[i] = false;}\n    sort(B, B+n);\n    for(i=0; i<n; ++i) T[B[i]] = i;\n    for(i=0; i<n; ++i) {\n        if(V[i]) continue;\n        int S = 0, an = 0, cur = i, m = VMAX;\n        while(1) {\n            V[cur] = true; ++an;\n            int v = A[cur]; m = min(m, v);\n            S += v; cur = T[v];\n            if(V[cur]) break;\n        }\n        ans += min(S+(an-2)*m, m+S+(an+1)*s);\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> n;\n    s = VMAX;\n    for(int i=0; i<n; ++i) {\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n    int ans = solve();\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint n, A[1000], s;\nint B[1000], T[10001];\n\nint solve(){\n    int ans = 0;\n\n    bool V[1000] = {};\n    for(int i = 0; i < n; i++){\n        B[i] = A[i];\n    }\n\n    sort(B, B+n);\n\n    // 配列Tは要素->ソート後の位置をO(1)で取得するためのもの\n    for(int i = 0; i < n; i++)  T[B[i]] = i;\n    for(int i = 0; i < n; i++){\n        if(V[i])    continue;\n        int cur = i;\n        int sum = 0;\n        int tmpmin = 10000;\n        int an = 0;\n        while(1){\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            tmpmin = min(tmpmin,v);\n            sum += v;\n            cur = T[v];\n            if(V[cur])  break;\n        }\n        ans += min(sum + (an-2)*tmpmin, tmpmin + sum + (an+1) * s);\n    }\n\n    return ans;\n}\n\nint main(){\n    cin >> n;\n\n    s = 10000;\n    for(int i = 0; i < n; i++){\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n\n    cout << solve() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n     \n     \n     \nint n,cost;\nint A[1001],B[1001];\nint L[501],R[502];\n     \n     \nvoid merge(int left,int mid,int right){\n  int i,j,n1=mid-left,n2=right-mid;\n  for(i=0;i<n1;i++) L[i]=A[left+i];\n  L[n1]=INT_MAX;\n  for(i=0;i<n2;i++) R[i]=A[mid+i];\n  R[n2]=INT_MAX;\n  int l=0,r=0;\n  for(i=left;i<right;i++){\n    if(L[l]<=R[r]){\n      A[i]=L[l];\n      l++;\n    }\n    else{\n      A[i]=R[r];\n      r++;\n    }\n  }\n}\n     \n     \nvoid m_sort(int left,int right){\n  int mid;\n  if( left+1 >= right) return;\n  mid=(left+right)/2;\n  m_sort(left,mid);\n  m_sort(mid,right);\n  merge(left,mid,right);\n}\n     \n     \nvoid swap(int a,int b,int *C){\n  int swap;\n  swap=C[a];\n  C[a]=C[b];\n  C[b]=swap;\n}\n     \n     \n     \n     \n     \n     \n       \n      \n       \n     \nint main(){\n  scanf(\"%d\",&n);\n  int i,j;\n  int cnt,sum,min,start,x;\n  int C[1001]={};\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n  m_sort(0,n);\n  for(i=0;i<n;i++){\n    if(A[i]==B[i]) C[i]=1;\n  }\n  cost=0;\n  for(i=0;i<n;i++){\n    if(C[i]!=1){\n      C[i]=1;\n      cnt=0;\n      sum=0;\n      min=B[i];\n      x=i;\n      while(1){\n        for(j=0;j<n;j++){\n          if(B[x]==A[j]){\n            C[j]=1;\n            cnt++;\n            sum+=B[j];\n            if(min > B[j]) min=B[j];\n            x=j;\n            break;\n          }\n        }\n        if(x==i) break;\n      }\n      sum-=min;\n      if( (cnt -1)*min > (cnt -1)*A[0]+2*(min +A[0])) cost+=sum+(cnt-1)*A[0]+2*(min +A[0]);\n      else cost+=sum+(cnt-1)*min;\n    }\n  }\n  printf(\"%d\\n\",cost);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nint N,W[1005],c=0,t,p;\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=1;i<=N;i++)\n\t\tscanf(\"%d\",W+i);\n\tfor(;;)\n\t{\n\t\tint mc=10000000,cp=-1;\n\t\tfor(int i=1;i<=N;i++)\n\t\t{\n\t\t\tif(W[i]!=i&&W[i]+W[W[i]]<mc)\n\t\t\t{\n\t\t\t\tcp=i;\n\t\t\t\tmc=W[i]+W[W[i]];\n\t\t\t}\n\t\t}\n\t\tif(cp==-1)break;\n\t\tc+=W[cp]+W[W[cp]];\n\t\tt=W[cp];\n\t\tp=W[cp];\n\t\tW[cp]=W[p];\n\t\tW[p]=t;\n\t}\n\tprintf(\"%d\\n\",c);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10001;\nint n, x;\nint A[MAX], B[MAX];\nbool V[MAX];\n\nint solve()\n{\n    int T[VMAX];\n    int ans = 0;\n\n    for (int i = 0; i != n; ++i)\n    {\n        B[i] = A[i];\n        V[i] = false;\n    }\n\n    sort(B, B+n);\n\n    for (int i = 0; i != n; ++i)\n    {\n        T[B[i]] = i;\n    }\n\n    for (int i = 0; i != n; ++i)\n    {\n        if (V[i]) continue;\n        int s = 0;\n        int an = 0;\n        int cur = i;\n        int m = VMAX;\n\n        while (true)\n        {\n            int v = A[cur];   \n            V[cur] = true;\n            ++an;\n            m = min(m, v);\n            s += v;\n            cur = T[v];\n            \n            if (V[cur] == true) break;\n        }\n        ans += min(s +(an -2) * m, s + m + (an + 1) * x);\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> n;\n\n    x = VMAX;\n\n    for (int i = 0; i != n; ++i)\n    {\n        cin >> A[i];\n        x = min(A[i], x);\n    }\n\n    cout << solve() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nint n;\nint w[10001];\nint f[10001];\nint edge[10001];\nbool used[10001];\nvector<int> vs;\n\nvoid dfs(int v){\n\tused[v]=true;\n\tvs.push_back(w[v]);\n\tif(!used[edge[v]])dfs(edge[v]);\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&w[i]);\n\t\tf[i]=w[i];\n\t}\n\tsort(f,f+n);\n\tll res=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(f[i]==w[i])edge[i]=i;\n\t\telse edge[i]=lower_bound(f,f+n,w[i])-f;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(edge[i]!=i){\n\t\t\tvs.clear();\n\t\t\tdfs(i);\n\t\t\tint all=vs[0];\n\t\t\tint minx=vs[0];\n\t\t\tfor(int j=1;j<vs.size();j++){\n\t\t\t\tminx=min(minx,vs[j]);\n\t\t\t\tall+=vs[j];\n\t\t\t}\n\t\t\tres+=min(all+(vs.size()-2)*minx,all+(vs.size()+1)*f[0]+minx);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define scanf_s scanf\n#include <string>\n#include <stdio.h>\n#include <math.h>\n#include <stack>\n#include <queue>\n#include <list>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\n#define MAX 1000\n//#define MAX_ 1000\n\nint cou = 0;\n\nint main(void)\n{\n\tint n, x, sum = 0;\n\tint w[MAX] = { 0 }, _w[MAX] = { 0 };\n\tscanf_s(\"%d\", &n);\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf_s(\"%d\", &x);\n\t\tw[i] = x;\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (w[i] > w[j]) {\n\t\t\t\t++_w[i];\n\t\t\t}\n\t\t}\n\t\t_w[i] = i - _w[i];\n\t}\n\tint min, max;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (_w[j] == 0) { ++cou; }\n\t\t\telse {\n\t\t\t\tif (cou == j) { min = max = j; }\n\t\t\t\tif (_w[min] > _w[j]) { min = j; }\n\t\t\t\tif (_w[max] < _w[j]) { max = j; }\n\t\t\t}\n\t\t}\n\t\tif (cou == n) break;\n\t\tcou = 0;\n\t\tsum += w[max] + w[min];\n\t\tx = w[min]; w[min] = w[max]; w[max] = x;\n\t\t_w[max] -= max - min; _w[min] += max - min;\n\t}\n\tprintf(\"%d\\n\", sum);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nconst int N = 1e5;\nint a[N],b[N],check[N];\n\nsigned main(){\n\n  int n; cin >> n;\n  int m = 114514,m2 = 1919810;\n  for(int i = 0; i < n; i++){\n    cin >> a[i];\n    b[i] = a[i];\n    m = min(m,a[i]);\n  }\n\n  sort(b,b+n);\n  int cost = 0,cost2 = 0,cnt = 0;\n  for(int i = 0; i < n; i++){\n    if(b[i] == a[i]) check[i] = 1;\n    if(b[a[i]-1] == a[i] && a[a[i]-1] == b[i] && !check[i]){\n      check[i] = check[a[i]-1] = 1;\n      cost += b[i] + b[a[i]-1];\n    }\n    if(!check[i]){\n      cost2 += b[i];\n      cnt++;\n      m2 = min(m2,b[i]);\n    }\n  }\n  if(cnt == 0) cout << cost << endl;\n  else cout << cost + min(cost2+(cnt-2)*m2,cost2+m2+(cnt+1)*m) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef vector<lli> vll;\n\nlli n;\nvll w;\nvll w_;\nlli ans = 0;\nlli mini;\n\n\nint main(){\n\tcin >> n;\n\tw = vll(n);\n\tw_ = vll(n);\n\tfor(lli i = 0;i < n;i++) cin >> w[i];\n\tfor(lli i = 0;i < n;i++) w_[i] = i;\n\tsort(w_.begin(),w_.end(),[](lli a,lli b){\n\t\treturn w[a] < w[b];\n\t});\n\tfor(lli i = 0;i < n;i++){\n\t\tlli ans_ = 0,c = 0;\n\t\twhile(w_[i] != i){\n\t\t\tans_ += w[w_[i]] + w[w_[w_[i]]];\n\t\t\tswap(w[w_[i]],w[w_[w_[i]]]);\n\t\t\tswap(w_[i],w_[w_[i]]);\n\t\t\tc++;\n\t\t}\n\t\tif(c*(w[i]-mini) > 2*(w[i]+mini)){\n\t\t\tans_ -= c*(w[i]-mini) - 2*(w[i]+mini);\n\t\t}\n\t\tans += ans_;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint solve(int n, int A[], int B[], int mn, int mx) {\n\tint ans = 0;\n\tint T[mx+1];\n\tsort(B, B+n);\n\tfor (int i = 0; i < n; i++) T[B[i]] = i;\n\tbool V[n] = {false};\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (V[i]) continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint an = 0;\n\t\tint m = 1<<30;\n\t\twhile (1) {\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif (V[cur]) break;\n\t\t}\n\t\tans += min(S + (an - 2) * m, m + S + (an + 1) * mn);\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint n, mn=1<<30, mx=(1<<30)*-1;\n\tcin >> n;\n\tint A[n], B[n];\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> A[i];\n\t\tB[i] = A[i];\n\t\tmn = min(mn, A[i]);\n\t\tmx = max(mx, A[i]);\n\t}\n\tint ans = solve(n, A, B, mn, mx);\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int MAXN=1000+2;\nint n,ans;\nint a[MAXN];\n\nstruct fbg{\n\tint val,sit;\n} w[MAXN];\n\nint check(){\n\tfor(int i=1;i<n;++i) if(w[i].val<w[i-1].val) return 0;\n\treturn 1;\n}\n\nint main(){\n\tw[1000].val=0x7f7f7f;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>w[i].val; a[i]=w[i].val;\n\t}\n\tsort(a,a+n);\n\twhile(1){\n\t\tif(check()) break;\n\t\tint now=1000;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tfor(int j=0;j<n;++j){\n\t\t\t\tif(a[j]==w[i].val){\n\t\t\t\t\tw[i].sit=j;\n\t\t\t\t\tif(i!=j && w[i].val<w[now].val) now=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint x=now;\n\t\twhile(1){\n\t\t\tx=w[x].sit;\n\t\t\tif(w[x].sit==x || w[x].sit==now) break;\n\t\t}\n\t\tswap(w[x].val,w[now].val); ans+=w[x].val+w[now].val;\n\t}\n\tcout<<ans<<endl; \n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nsigned main() {\n  int n;\n  cin >> n;\n\n  vector<int> w(n);\n  for ( int i = 0; i < n; i++ ) cin >> w[i];\n\n  vector<int> sorted_w = w;\n  sort(sorted_w.begin(), sorted_w.end());\n\n  int ans = 0;\n  for ( int i = 0; i < n; i++ ) {\n    int x = sorted_w[i];\n    int y = w[i];\n    int j;\n    for ( j = i+1; j < n; j++ ) {\n      if ( w[j] == x ) break;\n    }\n\n    if ( j == n ) continue;\n\n    for ( ; j >= 1 && y < w[j-1]; j-- ) {\n      swap(w[j-1], w[j]);\n      // cout << w[j-1] << \" \" << w[j] << endl;\n      ans += w[j-1]+w[j];      \n    }\n\n    for ( ; j < n-1 && y > w[j+1]; j++ ) {\n      swap(w[j+1], w[j]);\n      // cout << w[j+1] << \" \" << w[j] << endl;\n      ans += w[j+1]+w[j];      \n    }\n\n    if ( w[j] < w[i] ) {\n      swap(w[i], w[j]);\n      // cout << w[i] << \" \" << w[j] << endl;\n      ans += w[i]+w[j];\n    }\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nstatic const int MAX = 1005;\nstatic const int VMAX = 10005;\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve(){\n    int ans = 0;\n\n    bool V[MAX];\n    for(int i = 0;i<n;i++){\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B,B+n);\n    for(int i = 0;i<n;i++)\n        T[B[i]] = i;\n    for(int i = 0;i<n;i++){\n        if(V[i])\n            continue;\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while(1){\n            V[cur] = true;\n            an++;\n            int v = A[cur];\n            m = min(m,v);\n            S += v;\n            cur = T[v];\n            if(V[cur])\n                break;\n        }\n        ans += min(S + (an - 2)*m, m+S+(an+1)*S);\n    }\n    return ans;\n}\n\nint main(){\n    cin>>n;\n    s = VMAX;\n    for(int i = 0;i<n;i++){\n        cin>>A[i];\n        s = min(s,A[i]);\n    }\n    int ans = solve();\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n    int n;\n    cin >> n;\n    int A[n], B[n];\n    for(int i = 0; i < n; i++){\n        cin >> A[i];\n        B[i] = A[i];\n    }\n    sort(A, A+n);\n    int j = 0, s = 0, cnt, t, s1, s2;\n    while(j < n){\n        if(A[j] != B[j]){\n            s1 = s2 = cnt = 0;\n            int l = j;\n            while(B[l] != A[j]){\n               l++;\n            }\n            int k = j;\n            while(B[k] != A[l]){\n                k++;\n            }\n            t = B[l]; B[l] = B[k]; B[k] = t; cnt++;\n            s1 += B[k] + B[l];\n            while(A[k] != B[k]){\n                l = j;\n                while(B[l] != A[k]){\n                    l++;\n                }\n                t = B[l]; B[l] = B[k]; B[k] = t; cnt++;\n                s1 += B[l] + B[k];\n                k = l;\n            }\n            s2 = (A[0] + A[j])*2 + s1 - cnt*(A[j] - A[0]);\n            if(s1 >= s2) s = s + s2;\n            else s = s + s1;\n        }\n        j++;\n    }\n\n    cout << s << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n\nstatic const size_t n_max = 1000;\nstatic std::pair<int, size_t> A[n_max];\nstatic size_t C[n_max];\nstatic bool visited[n_max];\n\nint main() {\n  size_t n;\n  scanf(\"%zu\\n\", &n);\n  for (size_t i = 0; i < n; i++) {\n    scanf(\"%d\", &A[i].first);\n    A[i].second = i;\n  }\n  std::sort(A, A + n);\n  int M = A[0].first;\n  int cost = 0;\n  for (size_t i = 0; i < n; i++) {\n    if (visited[i])\n      continue;\n    visited[i] = true;\n    C[0] = i;\n    size_t l = 1;\n    auto m = A[i].first, s = A[i].first;\n    while (!visited[A[C[l-1]].second]) {\n      C[l] = A[C[l-1]].second;\n      visited[C[l]] = true;\n      m = std::min(m, A[C[l]].first);\n      s += A[C[l]].first;\n      l++;\n    }\n    if (l == 1)\n      continue;\n    cost += std::min((s - m) + m * (l - 1), (s - m) + M * (l - 1) + 2 * (m + M));\n  }\n  printf(\"%d\\n\", cost);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <list>\n#include <cmath>\n#include <vector>\n#include <stack>\n#include <set>\n#include <map>\n#define sf scanf\n#define pf printf\n#define show(x) cout<<\"x:\"<<x<<endl;\nusing namespace std;\ntypedef long long ll;\nconst int maxn=1e3+5;\nll a[maxn],p[maxn],n;\nvector<int>v;\nll sum=0;\n\nvoid solve()\n{\n    vector<int>::iterator it=v.begin();\n    int t=*it;\n    v.erase(v.begin());\n    if(!v.empty())\n        it=v.begin();\n    while(!v.empty())\n    {\n        int f=0;\n        int b=*it;\n        if(b==p[t])\n        {\n            if(t==p[b])\n                f=1;\n            swap(a[p[t]],a[p[b]]);\n            sum+=t+ *it + 2;\n            v.erase(it);\n            if(f==1&&!v.empty())\n                t=v[0],v.erase(v.begin());\n            if(!v.empty())\n                it=v.begin();\n        }\n        else\n        {\n            it++;\n            if(it==v.end())it=v.begin();\n        }\n        //pf(\"--t= %d , *it = %d\\n\",t,*it);\n        //cout<<sum<<endl;\n    }\n}\n\nint main()\n{\n    sf(\"%d\",&n);\n    for(int i=0;i<n;i++)\n    {\n        sf(\"%d\",&a[i]);\n        --a[i];\n        p[a[i]]=i;\n        if(a[i]!=i)v.push_back(a[i]);\n    }\n    sort(v.begin(),v.end());\n\n    solve();\n\n    pf(\"%d\\n\",sum);\n\n    return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\nint a[1005], b[1005], c[10005];\nbool ifs[1005];\nint mins = 10005;\nlong cost = 0;\n\n\n\nint main() {\n\tlong c1, c2, cmin;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tif (a[i] < mins) {\n\t\t\tmins = a[i];\n\t\t}\n\t\tb[i] = a[i];\n\t\tifs[i] = false;\n\t}\n\n\tsort(b, b+n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tc[b[i]] = i;\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (ifs[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tint j = i;\n\t\tint t = 0;\n\t\tc1  = 0;\n\t\tc2 = 0;\n\t\tcmin = a[j];\n\t\twhile (1) {\n\t\t\tifs[j] = true;\n\t\t\tc1 += a[j];\n\t\t\tt++;\n\t\t\tj = c[a[j]];\n\t\t\tif (cmin > a[j]) {\n\t\t\t\tcmin = a[j];\n\t\t\t}\n\t\t\tif (ifs[j]) break;\n\t\t}\n\t\tc2 = cmin + c1 + (t + 1) * mins;\n\t\tc1 = c1 + (t - 2)*cmin;\n\t\tcost += min(c1, c2);\n\t}\n\n\tcout << cost << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve(){\n\tint ans = 0;\n\n\tbool V[MAX];\n\tfor (int i = 0; i < n; i++) {\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; i++)T[B[i]] = i;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (V[i])continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile (1) {\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS+= v;\n\t\t\tcur = T[[v];\n\t\t\tif (V[cur])break;\n\t\t}\n\t\tans += min(S + (an - 2)*m, m + S + (an + 1)*s);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tcin >> n;\n\ts = VMAX;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tint ans = solve();\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, a[1009], c[1009]; bool vis[1009];\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (a[i] > a[j]) c[i]++;\n\t\t}\n\t}\n\tint z = *min_element(a, a + n);\n\tint ret = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (vis[i]) continue;\n\t\tint pos = i, m = 1012345678, cnt = 0;\n\t\twhile (!vis[pos]) {\n\t\t\tvis[pos] = true;\n\t\t\tret += a[pos];\n\t\t\tm = min(m, a[pos]);\n\t\t\tpos = c[pos];\n\t\t\tcnt++;\n\t\t}\n\t\tret += min(m * (cnt - 2), z * (cnt + 1) + m);\n\t}\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n\n  long long int n;\n  cin >> n;\n\n  vector< long long int > v, vs;\n\n  for ( long long int i = 0; i < n; i++ ) {\n\n    long long int in;\n    cin >> in;\n    v.push_back( in );\n    vs.push_back( in );\n\n  }\n\n  sort( vs.begin(), vs.end() );\n\n  long long int ans = 0;\n\n  for ( long long int i = n - 1; i >= 0; i-- ) {\n\n    if ( vs[i] != v[i] ) {\n\n      for ( long long int j = i - 1; j >= 0; j-- ) {\n\n\tif ( vs[j] == v[i] ) {\n\n\t  swap( v[i], v[j] );\n\t  ans += v[i] + v[j];\n\n\t}\n\n      }\n\n    }\n\n  }\n\n  cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\n#define MAX_N 1000\n#define MAX_W 10001\n\ntypedef int int32_t;\n\n/*????????????\n * ?????????????????°???????????????????????????????????????????????????????????????????????????????§?????????¢??°???????????¨??????????¨?????????°????????????????????¨???????????????\n * ????????§??????????????°?????????????????????????°????????????????\n *   1. ?????°??????????°???????local min.?????¨??????????????°????????????\n *   2. ??°??????????°???????global min.?????¨??????????°???????????????????????????????????????°???????????????????????????\n * ?????????????????§????????????????????????????????????????¨????????????¨???????????°??????????????????????°??????????????????????????????¨?????????????????°?????????????????????????°????????????¨????????????????????????????????£?????????\n */\n\nint main(void) {\n    int n;\n    int w[MAX_N];\n    int index[MAX_W];\n    bool moved[MAX_N] = {};\n\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &w[i]);\n        index[w[i]] = i;\n    }\n\n    sort(w, w + n);\n\n    int gmin = w[0]; // global minimum\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n        int j = index[w[i]];\n        if (moved[j] || i == j) {\n            continue;\n        }\n        int t = 0;\n        int c = 0;\n        int lmin = w[i]; // local minimum of given cyclic group\n        for (; !moved[j]; j = index[w[j]], c++) {\n            t += w[j];\n            moved[j] = true;\n        }\n\n        sum += min((c-2)*lmin + t, 2 * (gmin + lmin) + (c-1)*gmin + (t - lmin));\n    }\n\n    printf(\"%d\\n\", sum);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nstatic int n, A[MAX], s;\nstatic int B[MAX], T[VMAX + 1];\n\nstatic int solve()\n{\n    int ans = 0;\n    \n    bool V[MAX];\n    for (int i = 0; i < n; i++) {\n        B[i] = A[i];\n        V[i] = false;\n    }\n    \n    sort(B, B + n);\n    \n    for (int i = 0; i < n; i++) {\n        T[B[i]] = i;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        if (V[i])\n            continue;\n        int cur = i;\n        int S = 0;\n        int m = VMAX;\n        int count = 0;\n        while (true) {\n            V[cur] = true;\n            count++;\n            int v = A[cur];\n            m = min(m, v);\n            S += v;\n            cur = T[v];\n            if (V[cur])\n                break;\n        }\n        ans += min(S + (count - 2) * m, m + S + (count + 1) * s);\n    }\n    \n    return ans;\n}\n\nint main()\n{\n    cin >> n;\n    s = VMAX;\n    \n    for (int i = 0; i < n; i++) {\n        cin >> A[i];\n        s = min(s, A[i]);\n    }\n    \n    cout << solve() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<iostream>\n#include<stack>\n#include<vector>\n#include<queue>\n#define MAX 2000\n#define VMAX 20000\nusing namespace std;\n#define WHITE 0\n#define BLACK 1\n\ntypedef long long ll;\n\nint A[MAX],B[MAX],n,mini=2000000000,C[VMAX];\n\nint color[MAX],myans;\n\nvoid start(int x){\n  color[x]=BLACK;\n  int xvalue=A[x];\n  int xsort=C[xvalue];\n  int sum=xvalue,num=1,s=xvalue;\n  while(true){\n    xvalue=A[xsort];\n    if(xsort==x) break;\n    num++;\n    s=min(s,xvalue);\n    sum+=xvalue;\n    color[xsort]=BLACK;\n    xsort=C[xvalue];\n  }\n  if(num==1) return;\n  else myans+=min(sum+s*(num-2),sum+mini*(num+1)+s);\n  \n}\n\n\nvoid go(){\n  for(int i=0;i<n;i++){\n    if(color[i]==0) start(i);\n  }\n  cout<<myans<<endl;\n}\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>A[i];\n    mini=min(A[i],mini);\n    B[i]=A[i];\n  }\n  sort(B,B+n);\n  for(int i=0;i<n;i++){\n    C[B[i]]=i;\n  }\n\n  go();\n\n\n\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#incldue<map>\nusing namespace std;\nconst int MAXN = 1010;\nint w[MAXN];\nbool done[MAXN];\n \nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, mini = 100000;\n    cin >> n;\n    map<int, int> mp;\n    for (int i = 0; i < n; i++) {\n        cin >> w[i];\n        mp[w[i]] = 0;\n        mini = min(mini, w[i]);\n    }\n    {\n        int k = 0;\n        for (auto& p : mp) p.second = k++;\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (done[i]) continue;\n        int cnt = 0, now = i, mi = 100000, sum = 0;\n        while (1) {\n            if (done[now]) break;\n            cnt++;\n            done[now] = true;\n            mi = min(mi, w[now]);\n            sum += w[now];\n            now = mp[w[now]];\n        }\n        int tmp = sum+(cnt-2)*mi;\n        tmp = min(tmp, sum+mi+mini*(cnt+1));\n        ans += tmp;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 12:41\n//\n\n// w[0], w[1], ..., w[n-1]\n// ex. 9 7 6 1\n//  -> 1 6 7 9 \n// このように 1, 9の交換, 6,7の交換のようにペアの交換で済む場合は,\n// ex. 2 3 1\n//  -> 1 2 3 \n// このように, 1, 2, 3の3つ以上の巡回置換の場合は,\n// ...\n// まとめると, 辿っていくと問題がある. \n// \n// 10 7  8  9\n// 7  8  9 10\n// 7+10\n// 7+8\n// 8+9\n// 9+10\n\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <unordered_set>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\nusing ll = long long;\n\nstruct Value {\n\tll v;\n\tll idx;\n};\n\nclass lesserValue{\npublic:\n\tbool operator()(const Value &x, const Value &y) {\n\t\treturn x.v < y.v;\n\t}\n};\n\nvoid print(const vector<Value> &x) {\n\tfor (ll i=0;i<x.size();++i) {\n\t\tif (i!=0) cout << \" \";\n\t\t//cout << x[i].v << \",\" << x[i].idx;\n\t\tcout << x[i].v;\n\t}\n\tcout << endl;\n}\n\nint main() {\n\tll n;\n\tcin >> n;\n\tvector<Value> w(n);\n\tfor (ll i=0;i<n;++i) {\n\t\tscanf(\"%lld\", &w[i].v);\n\t\tw[i].idx = i;\n\t}\n\t//print(w);\n\tvector<Value> orig(w);\n\t//print(orig);\n\t// sort by ascending order\n\tsort(w.begin(), w.end(), lesserValue()); \n\t//print(w);\n\tunordered_set<ll> memo;\n\tll ans = 0;\n\tfor (ll i=0;i<n;++i) {\n\t\t// orig: 4 2 3\n\t\t// 0 1 2\n\t\t// w:    2 3 4\n\t\t// 1 2 0\n\t\t// w[0].v = 2;\n\t\t// i = 0; \n\t\t// j = w[i].idx;\n\t\t// w[0].idx = 1;\n\t\t// w[1].idx = 2;\n\t\t// w[2].idx = 0;\n\t\t//cout << \"[\" << i << \"]: \"; \n\t\tif (memo.end() != memo.find(i)) {\n\t\t\t//cout << \"skipped \" << i << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tmemo.insert(i);\n\t\t//cout << \"inserted \" << i << \" \";\n\t\tll cnt = 0;\n\t\tll j = w[i].idx;\n\t\twhile (i != j) {\n\t\t\tcnt++;\n\t\t\tmemo.insert(j);\n\t\t\tans += w[i].v + w[j].v;\n\t\t \tj\t= w[j].idx;\n\t\t\t//cout << \"inserted \" << j << \" \" << endl;\n\t\t}\n\t\tif (cnt > 1 && w[i].v != w[0].v) {\n\t\t\tans += min(0LL, 2 * (w[i].v + w[0].v) + cnt * (w[0].v - w[i].v));\n\t\t}\n//\t\tans += accumulate(t.begin(), t.end(), 0);\n//\t\tif (t.size() > 0) {\n//\t\t\tans -= *max_element(t.begin(), t.end());\n//\t\t}\n\t\t//cout << \"ans[\" << i << \"] = \" << ans << endl;\n\t}\n\t//print(w);\n\tcout << ans << endl;\n\treturn 0;\n}\n\n//\t3 2 1\n//\t1 2 3 \n//\t1 + 3 = 4\n//\n//  3 2 1 5 4 \t\n//  1 2 3 4 5\n//\n//  4 1 5 3 2\n//  1 2 3 4 5\n//\n//  4 2 5 3 1 : 1 + 2 = 3\n//  4 2 1 3 5 : 1 + 5 = 6 \n//  4 2 3 1 5 : 1 + 3 = 4 \n//  1 2 3 4 5 : 1 + 4 = 5\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\n#include <cstring>\n#define MAX 1000\n#define W 10000\nusing namespace std;\n\nint n,a[MAX],b[MAX],V[MAX],T[W+1],ans=0,mi=W;\n\nint solve(){\n    int i;\n    for(i=0;i<n;i++){\n        b[i]=a[i];\n    }\n    sort(b,b+n);\n    for(i=0;i<n;i++){T[b[i]]=i;}\n    for(i=0;i<n;i++){\n        if(V[i])continue;\n        int S=0;\n        int an=0;\n        int cur=i;\n        int m=MAX;\n        while(1){\n            V[cur]=1;\n            an++;\n            m=min(m,a[cur]);\n            S+=a[cur];\n            cur=T[a[cur]];\n            if(V[cur])break;\n        }\n        ans+=min(S+(an-2)*m,S+m+(an+1)*mi);\n    }\n    return ans;\n}\n\nint main()\n{\n    memset(V,0,sizeof(V));\n    cin>>n;\n    int i;\n    for(i=0;i<n;i++){cin>>a[i];mi=min(mi,a[i]);}\n    ans=solve();\n    cout<<ans<<endl;\n    return 0;\n}\n//int main(){\n//    int a=4;\n//    if(a){\n//        cout<<\"ok\";\n//    }\n//}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <stack>\n#include <queue>\n#include <map>\n#include <list>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <climits>\nusing namespace std;\n\nstruct node {\n\tlong prev;\n\tlong next;\n\tint val;\n};\n\nqueue<int> merge(queue<int> q1, queue<int> q2){\n\tqueue<int> ma;\n\twhile(q1.size() || q2.size()){\n\t\tif(!q2.size() || (q1.size() && q1.front() < q2.front())){\n\t\t\tma.push(q1.front());\n\t\t\tq1.pop();\n\t\t}else{\n\t\t\tma.push(q2.front());\n\t\t\tq2.pop();\n\t\t}\n\t}\n\treturn ma;\n}\nqueue<int> sort(queue<int> q){\n\tqueue<int> nq;\n\twhile(q.size() - nq.size() > 1){\n\t\tnq.push(q.front());\n\t\tq.pop();\n\t}\n\tif(!nq.size()) return q;\n\treturn merge(sort(nq), sort(q));\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\t\n\tint wholeMin = INT_MAX;\n\tint v[n];\n\tqueue<int> q;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> v[i];\n\t\tq.push(v[i]);\n\t\twholeMin = min(wholeMin, v[i]);\n\t}\n\t\n\tqueue<node> nodes;\n\tq = sort(q);\n\twhile(q.size()){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(q.front() == v[i]){\n\t\t\t\tnode no;\n\t\t\t\tno.prev = i;\n\t\t\t\tno.next = n - q.size();\n\t\t\t\tno.val = v[i];\n\t\t\t\tnodes.push(no);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tq.pop();\n\t}\n\t\n\tvector<vector<node>> groups;\n\tvector<node> sub;\n\twhile(nodes.size()){\n\t\tsub.clear();\n\t\tnode topNode = nodes.front();\n\t\tnodes.pop();\n\t\tsub.push_back(topNode);\n\t\t\n\t\tnode curNode = topNode;\n\t\twhile(curNode.prev != curNode.next){\n\t\t\tif(curNode.next == nodes.front().prev){\n\t\t\t\tcurNode = nodes.front();\n\t\t\t\tnodes.pop();\n\t\t\t\tsub.push_back(curNode);\n\t\t\t\tif(curNode.next == topNode.prev) break;\n\t\t\t}else{\n\t\t\t\tnodes.push(nodes.front());\n\t\t\t\tnodes.pop();\n\t\t\t}\n\t\t}\n\t\t\n\t\tgroups.push_back(sub);\n\t}\n\t\n\tlong cost = 0;\n\tfor(int i = 0; i < groups.size(); i++){\n\t\tif(groups[i].size() == 1) continue;\n\t\telse if(groups[i].size() == 2) cost += groups[i][0].val + groups[i][1].val;\n\t\telse{\n\t\t\tint min = INT_MAX;\n\t\t\tlong total = 0;\n\t\t\tfor(int k = 0; k < groups[i].size(); k++){\n\t\t\t\tmin = min < groups[i][k].val ? min : groups[i][k].val;\n\t\t\t\ttotal += groups[i][k].val;\n\t\t\t}\n\t\t\t\n\t\t\tlong costInternal = total + min * (groups[i].size() - 2);\n\t\t\tlong costExternal = total + wholeMin * (groups[i].size() - 2) + (min + wholeMin) * 2;\n\t\t\tcost += costInternal > costExternal ? costExternal : costInternal;\n\t\t}\n\t}\n\tcout << cost << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n \nusing namespace std;\n \n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n \n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n \n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N; cin >> N;\n  VI ws(N), tmp(N);\n  REP(i,N){\n\tcin >> ws[i];\n\ttmp[i] = ws[i];\n  }\n\n  SORT(tmp);\n  int ans = 0;\n  for(int i=N-1;i>=0;--i){\n\tREP(j,i){\n\t  if(ws[j] == tmp[i]){\n\t\tans += ws[j] + ws[i];\n\t\tswap(ws[j], ws[i]);\n\t  }\n\t}\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <utility>\n#include <algorithm>\n#include <bitset>\nusing namespace std;\ntypedef pair<int,int> pi;\n#define F first\n#define S second\n#define MP make_pair\nconst int N=1e3+10;\nbitset<N> went;\nint bot,tot,a[N],t;\npi b[N];\nvoid dfs(int n){\n    if(went[n])return ;\n    went[n]=true;\n    t++;\n    tot+=b[a[n]].F;\n    bot=min(bot,b[a[n]].F);\n    dfs(a[n]);\n    return ;\n}\nint main(){\n    int n,low=1e5+10;;\n    long long int ans=0;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&b[i].F);\n        low=min(low,b[i].F);\n        b[i].S=i;\n    }\n    sort(b,b+n);\n    for(int i=0;i<n;i++)a[b[i].S]=i;\n    went.reset();\n    for(int i=0;i<n;i++)if(!went[i]&&a[i]!=i){\n        tot=0;\n        bot=1e5+10;\n        t=0;\n        dfs(i);\n        ans+=min(tot+t*low,tot+(t-2)*bot);\n    }\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\n//????°???????????????????\n//????????? v[i]+v[j] ??????????????¨???????????????????????´??????????°??????????\n//??????????????????????????¨??? v[i]!=v[j]\ntemplate<class T>\nT minimum_cost_sort(const vector<T> &v) {\n\tint n = v.size();\n\tT total_cost = 0;\n\tvector<pair<T, int>> sorted(n);\n\tfor (int i = 0; i < n; i++)sorted[i] = make_pair(v[i], i);\n\tsort(sorted.begin(), sorted.end());\n\tT mini = sorted[0].first;\n\tvector<bool> is_sorted(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (is_sorted[sorted[i].second])continue;\n\t\tT loop_cost = 0;\n\t\tT loop_sum = 0;\n\t\tT loop_mini = sorted[i].first;\n\t\tT loop_n = 0;\n\t\tfor (int j = i;;) {\n\t\t\tT cost = sorted[j].first;\n\t\t\tint dst = sorted[j].second;\n\t\t\tis_sorted[j] = true;\n\t\t\tchmin(loop_mini, cost);\n\t\t\tloop_sum += cost;\n\t\t\tloop_n++;\n\t\t\tj = dst;\n\t\t\tif (is_sorted[dst])break;\n\t\t}\n\t\ttotal_cost += min(\n\t\t\tloop_sum + (loop_n - 2)*loop_mini,\n\t\t\tloop_sum + loop_mini + (loop_n + 1)*mini\n\t\t);\n\t}\n\treturn total_cost;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n; cin >> n;\n\tvector<int> w(n); rep(i, 0, n) { cin >> w[i]; }\n\tcout << minimum_cost_sort(w) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\nint n, A[MAX], s;// n???????´???°???A?????\\??????s?????\\??????????°????\nint B[MAX], T[VMAX + 1];\nint solve() {\n\tint ans(0);\n\tbool V[MAX];\n\tfor (int i = 0; i < n; i++) {\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B, B + n);\n\tfor (int i = 0; i < n; i++)T[B[i]] = i;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (V[i])continue;\n\t\tint cur = i;\n\t\tint S = 0;// sum of values in a cycle\n\t\tint m = VMAX;//minimum value in a cycle\n\t\tint an = 0;// number of values in a cycle\n\t\twhile (1) {\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif (V[cur])break;\n\t\t}\n\t\tans += min(S + (an - 2)*m, m + S + (an + 1)*s);\n\t}\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\ts = VMAX;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> A[i];\n\t\ts = min(s, A[i]);\n\t}\n\tcout << solve() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL_BUILD\n#include \"pch.h\"\n#define DLOG(msg) cout << \"#\" << __LINE__ << \":\" << msg << endl;\n#define DLOG_V(var)\\\n  cout << \"#\" << __LINE__ << \":\" << #var << \" : \" << var << endl;\n#else\n#include <bits/stdc++.h>\n#define DLOG(msg)\n#define DLOG_V(var)\n#endif\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n  if (n == 0) return 0;\n  vector<int> nums;\n  int min_ = numeric_limits<int>::max();\n  for (int i = 0; i < n ; ++i) {\n    int t;\n    cin >> t;\n    nums.push_back(t);\n    min_ = min(min_, t);\n  }\n  // set<int> sorted(nums.begin(), nums.end());\n  vector<int> sorted(nums.begin(), nums.end());\n  sort(sorted.begin(), sorted.end());\n  unordered_map<int, size_t> indices;\n  for (size_t i = 0; i < sorted.size(); ++i) {\n    indices.insert(make_pair(sorted[i], i));\n  }\n  vector<bool> done(nums.size(), false);\n  unordered_set<int> cycle;\n  int cost = 0;\n  for (size_t i = 0; i < nums.size(); ++i) {\n    if (done[i]) continue;\n    done[i] = true;\n    cycle.clear();\n    auto value = nums[i];\n    int cycle_min = value;\n    cycle.clear();\n    while (cycle.insert(value).second) {\n      cycle_min = min(cycle_min, value);\n      auto index = indices[value];\n      value = nums[index];\n      done[index] = true;\n    }\n\n    if (cycle.size() > 1) {\n      cycle.erase(cycle_min);\n      auto sum_ = accumulate(cycle.begin(), cycle.end(), 0);\n      auto v1 = sum_ + cycle_min * cycle.size();\n      auto v2 = sum_ + (cycle_min + min_) * 2 + min_ * cycle.size();\n      cost += min(v1, v2);\n    }\n  }\n\n  cout << cost << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\nconst int INF = 1000000;\n\nint partition(int *A,int p,int r)\n{\n\tint j,x,temp;\n\n\tx = A[r];\n\tj = p-1;\n\n\tfor(int i = p; i < r; i++)\n\t{\n\t\tif (A[i] <= x)\n\t\t{\n\t\t\tj++;\n\t\t\ttemp = A[i];\n\t\t\tA[i] = A[j];\n\t\t\tA[j] = temp;\n\t\t}\n\t}\n\n\ttemp = A[j+1];\n\tA[j+1] = A[r];\n\tA[r] = temp;\n\n\treturn j+1;\n}\n\nvoid quicksort(int *A,int p,int r)\n{\n\tint q;\n\n\tif (p < r)\n\t{\n\t\tq = partition(A,p,r);\n\t\tquicksort(A,p,q-1);\n\t\tquicksort(A,q+1,r);\n\t}\n}\n\nint solve_swap(int *a,int *b,int n)\n{\n\tint sum,temp;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (a[i] != b[i])\n\t\t{\n\t\t\tfor(int j = i+1; j < n; j++)\n\t\t\t{\n\t\t\t\tif (b[j] == a[i] && b[i] == a[j])\n\t\t\t\t{\n\t\t\t\t\ttemp = a[i];\n\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\ta[j] = temp;\n\n\t\t\t\t\tsum += a[i] + a[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n\nint solve1(int *a,int *b,int n)\n{\n\tbool check;\n\tint min,num,temp,sum,start;\n\n\tsum = 0;\n\tstart = 0;\n\n\twhile(1)\n\t{\n\t\tmin = INF;\n\t\t\n\t\tcheck = true;\n\n\t\t//printf(\"start = %d\\n\", start);\n\n\t\tfor(int i = start; i < n; i++)\n\t\t{\n\t\t\tif (min > a[i] && a[i] != b[i])\n\t\t\t{\n\t\t\t\tnum = i;\n\t\t\t\tmin = a[num];\n\t\t\t}\n\t\t}\n\n\t\t//printf(\"num = %d\\n\", num);\n\t\t//printf(\"min = %d\\n\", min);\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (a[i] == b[num])\n\t\t\t{\n\t\t\t\t//printf(\"%d and %d are swapped\\n\", a[num],a[i]);\n\t\t\t\tsum += a[num] + a[i];\n\t\t\t\ttemp = a[i];\n\t\t\t\ta[i] = min; // min = a[num]\n\t\t\t\ta[num] = temp;\n\t\t\t\tnum = i;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (a[i] != b[i])\n\t\t\t{\n\t\t\t\tcheck = false;\n\t\t\t\tstart = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\t//printf(\"a[i] = %d\\n\", a[i]);\n\t\t}\n\n\t\tif (check)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn sum;\n}\n\nbool check(int *A,int *B,int n)\n{\n\tbool c = true;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif (A[i] != B[i])\n\t\t{\n\t\t\tc = false;\n\t\t}\n\t}\n\n\treturn c;\n}\n\nint main()\n{\n\tint n,a[1000] = {0},b[1000] = {0},a2[1000] = {0};\n\tint sum1 = 0,sum2 = 0,pivot = 0,pivot1 = 0,pivot2= 0,min = 0,start,temp,k;\n\n\tscanf(\"%d\", &n);\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\tb[i] = a[i];\n\t}\n\n\tquicksort(b,0,n-1);\n\n\tsum1 = solve_swap(a,b,n);\n\n\t//printf(\"sum = %d\\n\", sum1);\n\n\t\n\tif (check(a,b,n))\n\t{\n\t\tprintf(\"%d\\n\", sum1);\n\t\treturn 0;\n\t}\n\n\n\tsum2 = sum1;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\ta2[i] = a[i];\n\t}\n\n\t//printf(\"\\nhere is sum1\\n\");\n\n\tsum1 += solve1(a,b,n);\n\n\t//printf(\"sum1 = %d\\n\",sum1);\n\n\n\tif (check(a,b,n))\n\t{\n\t\tprintf(\"%d\\n\", sum1);\n\t\treturn 0;\n\t}\n\n\n\n\tfor(int i = 1; i < n - start; i++)\n\t{\n\t\tk = start;\n\n\t\t\n\t\twhile(1)\n\t\t{\n\t\t\tif (b[pivot1] == a[k])\n\t\t\t{\n\t\t\t\tprintf(\"%d and %d are swapped\\n\", a[pivot1],a[k]);\n\t\t\t\ttemp = a[pivot1];\n\t\t\t\ta[pivot1] = a[k];\n\t\t\t\ta[k] = temp;\n\n\t\t\t\tsum1 += a[pivot1] + a[k];\n\t\t\t\tpivot1 = k;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tprintf(\"%d \", a[i]);\n\t\t}\n\t\tcout << endl;\n\t}\n\n\n\tif (!check(a,b,n))\n\t{\n\t\tprintf(\"\\nhere is sum2\\n\");\n\t\ttemp = a2[pivot2];\n\t\ta2[pivot2] = a2[0];\n\t\ta2[0] = temp;\n\n\t\tfor(int i = 1; i < n - start; i++)\n\t\t{\n\t\t\tint j = start;\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif (b[pivot2] == a2[j])\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d and %d are swapped\\n\", a2[pivot2],a2[j]);\n\t\t\t\t\ttemp = a2[pivot2];\n\t\t\t\t\ta2[pivot2] = a2[j];\n\t\t\t\t\ta2[j] = temp;\n\n\t\t\t\t\tsum2 += a2[pivot2] + a2[j];\n\t\t\t\t\tpivot2 = j;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tprintf(\"%d \", a2[i]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\n\t\tif (sum1 < sum2)\n\t\t{\n\t\t\tprintf(\"sum1 = %d\\n\", sum1);\n\t\t}else\n\t\t{\n\t\t\tprintf(\"sum2 = %d\\n\", sum2);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\n\tprintf(\"%d\\n\", sum1);\n\t\n\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\n#include<cmath>\nusing namespace std;\n\nvoid show( int arr[], size_t size )\n{\n\n\tcout<<arr[0]<<flush;\n    for( size_t i=1; i<size; i++ ){\n\t    cout<<' '<<arr[i]<<flush;\n    }\n    cout<<endl;\n}\n\nint min( int arr[], size_t left, size_t right )\n{\n\tif( left +1 < right ){ //????´????????????\\???????????¨???\n\t\tsize_t mid=(left+right)/2;\n\t\treturn min( min(arr, left, mid), min(arr, mid, right) );\n\t}else{\n\t\treturn arr[left];\n\t}\n}\n\n\n/*\nvoid swap( int &a, int &b )\n{\n\tint t=a;\n\ta=b;\n\tb=t;\n}\n\nsize_t partition(int arr[], size_t arr_s, size_t left, size_t right)\n{\n\tif( right >= arr_s ){\n\t\tcout<<\"Error\"<<endl;\n\t\treturn -1;\n\t}\n\n\n\tsize_t below=left-1;\n\n\tfor( size_t above=left; above<right; above++ ){\n\t\tif( arr[above] <= arr[right] ){\n\t\t\t++below;\n\t\t\tswap( arr[above], arr[below] );\n\t\t}\n\t}\n\tswap( arr[right], arr[below+1] ); \n\treturn below+1; \n}\n\n\nvoid quickSort( int *arr, size_t arr_s, size_t left, size_t right )\n{\n\tif( left < right ){\n\t\tsize_t pivot_i=partition( arr, arr_s, left, right );\n\t\tquickSort( arr, arr_s, left, pivot_i-1 );\n\t\tquickSort( arr, arr_s, pivot_i+1, right );\n\t}\n}\n*/\nint merge( int arr[], unsigned int arr_s, unsigned int lft, unsigned int md, unsigned int rgt )\n{\n\tint cnt=0;\n\n\tint left_s=md-lft+1, right_s=rgt-md+1, *left=new int[left_s], *right=new int[right_s];\n\tfor( int i=0; i<left_s-1; i++ ){\n\t\tleft[i]=arr[lft+i];\n\t}\n\tleft[left_s-1]=INT_MAX;\n\tfor( int i=0; i<right_s-1; i++ ){\n\t\tright[i]=arr[md+i];\n\t}\n\tright[right_s-1]=INT_MAX; \n\n\n\tfor( int i=0, left_i=0, right_i=0; i<left_s+right_s-2; i++, cnt++ ){\n\t\tif( left[left_i] <= right[right_i] ){ \n\t\t\tarr[lft+i]=left[left_i];\n\t\t\t++left_i;\n\t\t}else{\n\t\t\tarr[lft+i]=right[right_i];\n\t\t\t++right_i;\n\t\t}\n\t}\n\n\tdelete[] right;delete[] left;\n\treturn cnt;\n}\nint mergeSort( int arr[], unsigned int arr_s, unsigned int lft, unsigned int rgt ) \n{\n\tstatic int cnt=0;\n\t\tunsigned int md=(lft + rgt)/2;\n\tif( rgt - lft >=2 ){\n\n\t\tmergeSort(arr, arr_s, lft, md);  \n\t\tmergeSort(arr, arr_s, md, rgt);\n\t\tcnt+= merge(arr, arr_s, lft, md, rgt); \n\t\n\t}\n\treturn cnt;\n}\nsize_t findidx( int arr[], size_t arr_s, int key )\n{\n\tfor( size_t i=0; i!=arr_s; i++ ){\n\t\tif( arr[i] == key ) return i;\n\t}\n\treturn arr_s;\n}\n\nunsigned int minCost( int arr[], size_t arr_s )\n{\n\tint *sorted=new int[arr_s];\n\tfor( size_t i=0; i<arr_s; i++ ){\n\t\tsorted[i]=arr[i];\n\t}\n\tmergeSort(sorted, arr_s, 0, arr_s); //????????????????????¶?????¨???????????¨\n\n\n\t/*\n\t(????°???????????????????)= findptr(arr, arr_s, sorted[0])\n\t(?°????????????????3?????????????????????)= findptr(arr, arr_s, sorted[3])\n\t*/\n\n\tunsigned int cost=0;\n\tint swap_l_val, swap_l_idx, swap_r_val, swap_r_idx;\n\tfor( size_t i=0; ; ){ \n\t\tif( findidx( arr, arr_s, sorted[i] ) == i ){\n\t\t\ti++;\n\t\t}\n\t\tswap_l_idx= findidx(arr, arr_s, sorted[i]);\n\t\tswap_r_idx= findidx( arr, arr_s, sorted[findidx(arr, arr_s, sorted[i] ) ] );\n\t\tif( swap_l_idx == swap_r_idx ) break;\n\n\t\tswap_l_val=arr[ swap_l_idx];\n\t\tswap_r_val=arr[ swap_r_idx];\n//\t\tcout<<\"swap_l_val : \"<<swap_l_val<<' '<<\"swap_r_val : \"<<swap_r_val<<endl;\n\n\t\tswap( arr[ findidx(arr, arr_s, sorted[i]) ], arr[ findidx( arr, arr_s, sorted[findidx(arr, arr_s, sorted[i])] )]);\n\t\tcost+=swap_l_val + swap_r_val; \n\t}\n\treturn cost;\n}\n\nint main()\n{\n\tsize_t arr_s;cin>>arr_s;\n\tint *arr=new int[arr_s];\n\tfor( size_t i=0; i<arr_s; i++ ){\n\t\tcin>>arr[i];\n\t}\n\n\tlong long mincst=minCost( arr, arr_s );\n//\tshow(arr, arr_s);\n\tcout<<mincst<<endl;\n\n}"
  },
  {
    "language": "Haskell",
    "code": "module Main where\n-- import Debug.Trace\nimport Data.List\nimport qualified Data.Sequence as S\nimport qualified Data.ByteString.Char8 as B\nimport Data.Int\nimport Data.Char\nimport Data.Array\nimport Data.Maybe\nimport qualified Data.Map as M\nimport Data.Ord\nimport Data.Functor\nimport Control.Applicative\nimport Control.Monad\n\nsolve :: [Int] -> Int\nsolve l = iter cycles where\n    iter [] = 0\n    iter (c:cs) = cost c + iter cs \n\n    cost = iter 0 0 maxBound where\n        iter c s m [] -- c: length of this cycle, s:sum of this cycle, m: minimum in this cycle.\n            | c < 2 = s\n            | otherwise = s + min (m*(c-2)) (ma*(c+1) + m)\n        iter c s m (x:xs) = iter (c+1) (s+x) (min m x) xs\n\n    sl = sort l\n    ma = head sl  -- minimum in all\n    permutation = M.fromList $ zip l sl\n\n    cycles = iter [] l where\n        iter cl [] = cl\n        iter cl (x:xs)\n            | elem x ul = iter cl xs\n            | otherwise = iter (cycle:cl) xs where\n                ul = concat cl\n                cycle = iter [x] where\n                    iter cl@(c:cs)\n                        | v == c = [] \n                        | elem v cl = cl\n                        | otherwise = iter (v:cl) where\n                            v =  permutation M.! c \n\nreadIntLn:: IO Int\nreadIntLn = (fst . fromJust . B.readInt) <$> B.getLine\n\nreadIntList:: IO [Int]\nreadIntList = map (fst . fromJust . B.readInt) . B.words <$> B.getLine\n\nmain :: IO() \nmain = do\n    _ <- readIntLn\n    l <- readIntList\n\n    print $ solve l \n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}\n{-# OPTIONS_GHC -fno-warn-unused-imports #-}\n{-# OPTIONS_GHC -fno-warn-missing-signatures #-}\n{-# OPTIONS_GHC -fno-warn-unused-binds #-}\n{-# OPTIONS_GHC -fno-warn-incomplete-patterns #-}\n{-# OPTIONS_GHC -fno-warn-name-shadowing #-}\n{-# LANGUAGE OverloadedStrings #-}\n-- {-# LANGUAGE FlexibleContexts #-}\n-- {-# LANGUAGE MultiWayIf #-}\n-- {-# LANGUAGE BangPatterns #-}\n-- {-# LANGUAGE ViewPatterns #-}\n-- {-# LANGUAGE TupleSections #-}\n\nimport           System.IO hiding (char8)\nimport           Control.Applicative\nimport           Control.Monad\nimport           Data.List\nimport           Data.Tuple\nimport           Data.Int\nimport           Data.Char\nimport           Data.Function (on)\nimport           Data.Ord (comparing)\nimport           Data.Monoid (mappend)\nimport           Data.Array\n-- import           Data.Array.Unboxed\n-- import           Data.Array.IArray\n-- import           Data.Array.ST\n-- import           Data.Array.MArray\n-- import           Data.Array.Unsafe\n-- import           Data.Array.Base(unsafeRead, unsafeWrite)\n-- import           Data.Array.IO\nimport           Data.Ix\nimport           Data.Maybe\n-- import           Data.Monoid hiding ((<>))\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Lazy.Char8 as BL\nimport           Data.ByteString.Builder\nimport           Data.Graph\nimport           Data.Tree\n-- import           Data.Vector.Unboxed ((//), (++), (!), (!?))\n-- import qualified Data.Vector.Unboxed as U\n-- import           Data.IntSet (IntSet)\n-- import qualified Data.IntSet as IntSet\nimport           Data.IntMap.Strict (IntMap)\nimport qualified Data.IntMap.Strict as IntMap\nimport           Data.Sequence ((|>), (<|), (><),ViewR(..), ViewL(..), Seq)\nimport qualified Data.Sequence              as Seq\n-- import           Data.Foldable (toList, minimumBy)\n-- import           Debug.Trace\n\nmain = solve <$ getInt1 <*> getInts >>= print\n\nsolve :: [Int] -> Int\nsolve = sum . map cost . cycleNotation\n\ncost :: [Int] -> Int\ncost xs = minimum xs * (length xs - 2) + sum xs\n\ncycleNotation :: [Int] -> [[Int]]\ncycleNotation ns = filter ((1<) . length) . map flatten $ components graph where\n  graph = buildG (1, length ns) . zip ns $ sort ns\n\n--  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --\n\ngetInt1 :: IO Int\ngetInt1 = readInt1 <$> BS.getLine\n\ngetInt2 :: IO (Int, Int)\ngetInt2 = readInt2 <$> BS.getLine\n\ngetInt3 :: IO (Int, Int, Int)\ngetInt3 = readInt3 <$> BS.getLine\n\ngetInts :: IO [Int]\ngetInts = readInts <$> BS.getLine\n\ngetIntN :: Int -> IO [Int]\ngetIntN n = map readInt1 <$> replicateM n BS.getLine\n\nformat :: Show a => Maybe a -> IO ()\nformat Nothing = putStrLn \"NO\"\nformat (Just a) = putStrLn \"YES\" >> print a\n\n-- [1,2,3] -> 1 2 3\nputInts :: [Int] -> IO ()\nputInts [] = return ()\nputInts xs = BL.putStrLn . toLazyByteString . foldl1 mappend . intersperse (char8 ' ') $ map intDec xs\n\nreadInt1 :: BS.ByteString -> Int\nreadInt1 = fst . fromJust . BS.readInt\n\nreadInt2 :: BS.ByteString -> (Int,Int)\nreadInt2 = toTuple . readInts\n\nreadInt3 :: BS.ByteString -> (Int,Int,Int)\nreadInt3 = toTriple . readInts\n\nreadInts :: BS.ByteString -> [Int]\nreadInts =  map readInt1 . BS.words\n\nreadInt641 :: BS.ByteString -> Int64\nreadInt641 = fromIntegral . fst . fromJust . BS.readInteger\n\nreadInt642 :: BS.ByteString -> (Int64,Int64)\nreadInt642 = toTuple . readInt64s\n\nreadInt643 :: BS.ByteString -> (Int64,Int64,Int64)\nreadInt643 = toTriple . readInt64s\n\nreadInt64s :: BS.ByteString -> [Int64]\nreadInt64s =  map readInt641 . BS.words\n\nreadInteger1 :: BS.ByteString -> Integer\nreadInteger1 = fst . fromJust . BS.readInteger\n\nreadInteger2 :: BS.ByteString -> (Integer,Integer)\nreadInteger2 = toTuple . readIntegers\n\nreadInteger3 :: BS.ByteString -> (Integer,Integer,Integer)\nreadInteger3 = toTriple . readIntegers\n\nreadIntegers :: BS.ByteString -> [Integer]\nreadIntegers =  map readInteger1 . BS.words\n\ntoTuple :: [a] -> (a, a)\ntoTuple [x, y] = (x, y)\n\ntoTriple :: [a] -> (a, a, a)\ntoTriple [x, y, z] =(x, y, z)\n\nfromTuple :: (a, a) -> [a]\nfromTuple (x, y) = [x, y]\n\nfromTriple :: (a, a, a) -> [a]\nfromTriple (x, y, z) = [x, y, z]\n\n-- if not applying, use \"const\"\n\napplyTuple :: (a -> a') -> (b -> b') -> (a, b) -> (a', b')\napplyTuple f g (x, y) = (f x, g y)\n\napplyTriple :: (a -> a') -> (b -> b') -> (c -> c') -> (a, b, c) -> (a', b', c')\napplyTriple f g h (x, y, z) = (f x, g y, h z)\n\n-- @since 4.8.0.0\nsortOn' :: Ord b => (a -> b) -> [a] -> [a]\nsortOn' f =\n  map snd . sortBy (comparing fst) . map (\\x -> let y = f x in y `seq` (y, x))"
  },
  {
    "language": "Haskell",
    "code": "{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}\n{-# OPTIONS_GHC -fno-warn-unused-imports #-}\n{-# OPTIONS_GHC -fno-warn-missing-signatures #-}\n{-# OPTIONS_GHC -fno-warn-unused-binds #-}\n{-# OPTIONS_GHC -fno-warn-incomplete-patterns #-}\n{-# OPTIONS_GHC -fno-warn-name-shadowing #-}\n{-# LANGUAGE OverloadedStrings #-}\n-- {-# LANGUAGE FlexibleContexts #-}\n-- {-# LANGUAGE MultiWayIf #-}\n-- {-# LANGUAGE BangPatterns #-}\n-- {-# LANGUAGE ViewPatterns #-}\n-- {-# LANGUAGE TupleSections #-}\n\nimport           System.IO hiding (char8)\nimport           Control.Applicative\nimport           Control.Monad\nimport           Data.List\nimport           Data.Tuple\nimport           Data.Int\nimport           Data.Char\nimport           Data.Function (on)\nimport           Data.Ord (comparing)\nimport           Data.Monoid (mappend)\nimport           Data.Array\n-- import           Data.Array.Unboxed\n-- import           Data.Array.IArray\n-- import           Data.Array.ST\n-- import           Data.Array.MArray\n-- import           Data.Array.Unsafe\n-- import           Data.Array.Base(unsafeRead, unsafeWrite)\n-- import           Data.Array.IO\nimport           Data.Ix\nimport           Data.Maybe\n-- import           Data.Monoid hiding ((<>))\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Lazy.Char8 as BL\nimport           Data.ByteString.Builder\nimport           Data.Graph\nimport           Data.Tree\n-- import           Data.Vector.Unboxed ((//), (++), (!), (!?))\n-- import qualified Data.Vector.Unboxed as U\n-- import           Data.IntSet (IntSet)\n-- import qualified Data.IntSet as IntSet\nimport           Data.IntMap.Strict (IntMap)\nimport qualified Data.IntMap.Strict as IntMap\nimport           Data.Sequence ((|>), (<|), (><),ViewR(..), ViewL(..), Seq)\nimport qualified Data.Sequence              as Seq\n-- import           Data.Foldable (toList, minimumBy)\n-- import           Debug.Trace\n\nmain = solve <$ getInt1 <*> getInts >>= print\n\nsolve :: [Int] -> Int\nsolve = sum . map cost . cycleNotation\n\ncost :: [Int] -> Int\ncost xs = minimum xs * (length xs - 2) + sum xs\n\ncycleNotation :: [Int] -> [[Int]]\ncycleNotation ns = filter ((1<) . length) . map flatten $ components graph where\n  graph = buildG (minimum ns, maximum ns) . zip ns $ sort ns\n\n--  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --\n\ngetInt1 :: IO Int\ngetInt1 = readInt1 <$> BS.getLine\n\ngetInt2 :: IO (Int, Int)\ngetInt2 = readInt2 <$> BS.getLine\n\ngetInt3 :: IO (Int, Int, Int)\ngetInt3 = readInt3 <$> BS.getLine\n\ngetInts :: IO [Int]\ngetInts = readInts <$> BS.getLine\n\ngetIntN :: Int -> IO [Int]\ngetIntN n = map readInt1 <$> replicateM n BS.getLine\n\nformat :: Show a => Maybe a -> IO ()\nformat Nothing = putStrLn \"NO\"\nformat (Just a) = putStrLn \"YES\" >> print a\n\n-- [1,2,3] -> 1 2 3\nputInts :: [Int] -> IO ()\nputInts [] = return ()\nputInts xs = BL.putStrLn . toLazyByteString . foldl1 mappend . intersperse (char8 ' ') $ map intDec xs\n\nreadInt1 :: BS.ByteString -> Int\nreadInt1 = fst . fromJust . BS.readInt\n\nreadInt2 :: BS.ByteString -> (Int,Int)\nreadInt2 = toTuple . readInts\n\nreadInt3 :: BS.ByteString -> (Int,Int,Int)\nreadInt3 = toTriple . readInts\n\nreadInts :: BS.ByteString -> [Int]\nreadInts =  map readInt1 . BS.words\n\nreadInt641 :: BS.ByteString -> Int64\nreadInt641 = fromIntegral . fst . fromJust . BS.readInteger\n\nreadInt642 :: BS.ByteString -> (Int64,Int64)\nreadInt642 = toTuple . readInt64s\n\nreadInt643 :: BS.ByteString -> (Int64,Int64,Int64)\nreadInt643 = toTriple . readInt64s\n\nreadInt64s :: BS.ByteString -> [Int64]\nreadInt64s =  map readInt641 . BS.words\n\nreadInteger1 :: BS.ByteString -> Integer\nreadInteger1 = fst . fromJust . BS.readInteger\n\nreadInteger2 :: BS.ByteString -> (Integer,Integer)\nreadInteger2 = toTuple . readIntegers\n\nreadInteger3 :: BS.ByteString -> (Integer,Integer,Integer)\nreadInteger3 = toTriple . readIntegers\n\nreadIntegers :: BS.ByteString -> [Integer]\nreadIntegers =  map readInteger1 . BS.words\n\ntoTuple :: [a] -> (a, a)\ntoTuple [x, y] = (x, y)\n\ntoTriple :: [a] -> (a, a, a)\ntoTriple [x, y, z] =(x, y, z)\n\nfromTuple :: (a, a) -> [a]\nfromTuple (x, y) = [x, y]\n\nfromTriple :: (a, a, a) -> [a]\nfromTriple (x, y, z) = [x, y, z]\n\n-- if not applying, use \"const\"\n\napplyTuple :: (a -> a') -> (b -> b') -> (a, b) -> (a', b')\napplyTuple f g (x, y) = (f x, g y)\n\napplyTriple :: (a -> a') -> (b -> b') -> (c -> c') -> (a, b, c) -> (a', b', c')\napplyTriple f g h (x, y, z) = (f x, g y, h z)\n\n-- @since 4.8.0.0\nsortOn' :: Ord b => (a -> b) -> [a] -> [a]\nsortOn' f =\n  map snd . sortBy (comparing fst) . map (\\x -> let y = f x in y `seq` (y, x))"
  },
  {
    "language": "Haskell",
    "code": "import           Control.Applicative\nimport           Control.Monad\nimport qualified Data.ByteString.Char8 as B\n\nimport           Data.IntMap.Lazy      (IntMap, (!))\nimport qualified Data.IntMap.Lazy      as M\nimport           Data.List\nimport           Data.Sequence         (Seq (..), ViewL (..), ViewR (..), (<|),\n                                        (><), (|>))\nimport qualified Data.Sequence         as S\n\nread' :: B.ByteString -> Int\nread' bs | Just (n, _) <- B.readInt bs = n\n\ngetCycle :: (Int, Int)\n         -> Seq Int    -- read only\n         -> IntMap Int -- read only\n         -> Seq Bool   -- update\n         -> ([Int], Seq Bool)\ngetCycle (n, w) sa mb sc = go (n, w) [] sc\n  where\n    go (i, k) ws bs\n        | bs `S.index` i = (ws, bs) -- already checked\n        | otherwise      = go (i', k') (k:ws) bs'\n      where\n        bs' = S.update i True bs\n        i' = mb ! k\n        k' = sa `S.index` i'\n\ngetCycles :: [(Int, Int)]\n          -> Seq Int    -- read only\n          -> IntMap Int -- read only\n          -> Seq Bool   -- update\n          -> [[Int]]\ngetCycles [] _ _ _ = []\ngetCycles (w:ws) sa mb sc\n    | null cs   = getCycles ws sa mb sc'\n    | otherwise = cs : getCycles ws sa mb sc'\n  where\n    (cs, sc') = getCycle w sa mb sc\n\ncalcCost :: Int   -- minimum weight\n         -> [Int] -- cycle\n         -> Int\ncalcCost w cs = min (sumc + (n - 2) * mc) (sumc + mc + (n + 1) * w)\n  where\n    n = length cs\n    mc = minimum cs\n    sumc = sum cs\n\nmain :: IO ()\nmain = do\n    n <- read' <$> B.getLine\n    ws <- fmap read' . B.words <$> B.getLine\n\n    let wseq = S.fromList ws\n    let imap = M.fromList $ zip (sort ws) [0..]\n    let bseq = S.replicate n False\n\n    let minw = minimum ws\n    let cycles = getCycles (zip [0..] ws) wseq imap bseq\n\n    print $ sum $ fmap (calcCost minw) cycles\n\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative ((<$>))\nimport Control.Monad (forM_)\nimport Data.List (sort)\nimport Data.IntMap.Strict\nimport Data.Vector.Unboxed (Vector)\nimport Data.Vector.Unboxed.Mutable (IOVector, unsafeRead, unsafeWrite)\nimport qualified Data.List as L\nimport qualified Data.IntMap.Strict as M\nimport qualified Data.Vector.Unboxed as V\nimport qualified Data.Vector.Unboxed.Mutable as MV\n\ntype Cost   = Int\ntype Costs  = Vector Cost\ntype Sorted = IntMap Int\ntype Flags  = IOVector Bool\n\nmain :: IO ()\nmain = do\n    getLine\n    inputs <- L.map read . words <$> getLine :: IO [Int]\n    flags  <- MV.replicate 10000 True\n    forM_ inputs (write False flags)\n    cycles <- getCycles inputs flags\n    print . sum . L.map (getCost (minimum inputs)) $ cycles\n  where\n    write v vs i = MV.unsafeWrite vs i v\n\ngetCycles :: [Int] -> Flags -> IO [[Int]]\ngetCycles inputs flags =\n    mapM (getCycle costs sorted flags []) inputs\n  where\n    costs  = V.fromList inputs\n    sorted = M.fromList $ zip (sort inputs) [0..]\n\ngetCycle :: Costs -> Sorted -> Flags -> [Int] -> Int -> IO [Int]\ngetCycle costs sorted flags cycle c = do\n    isValid <- unsafeRead flags c\n    if isValid then\n        return cycle\n    else do\n        unsafeWrite flags c True\n        getCycle costs sorted flags (c:cycle) (costs V.! (sorted M.! c))\n\ngetCost :: Int -> [Int] -> Int\ngetCost _ []      = 0\ngetCost _ (c:[])  = 0\ngetCost min costs =\n    if min `elem` costs then\n        sum1\n    else\n        minimum [sum1, sum2]\n  where\n    sum1 = sum costs + (n - 2) * mc\n    sum2 = sum costs + mc + (n + 1) * min\n    n  = length costs\n    mc = minimum costs\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# OPTIONS_GHC -O2 -funbox-strict-fields #-}\n{-# OPTIONS_GHC -fno-warn-unused-imports #-}\n{-# OPTIONS_GHC -fno-warn-missing-signatures #-}\n{-# OPTIONS_GHC -fno-warn-unused-binds #-}\n{-# OPTIONS_GHC -fno-warn-incomplete-patterns #-}\n{-# OPTIONS_GHC -fno-warn-name-shadowing #-}\n{-# LANGUAGE OverloadedStrings #-}\n-- {-# LANGUAGE FlexibleContexts #-}\n-- {-# LANGUAGE MultiWayIf #-}\n-- {-# LANGUAGE BangPatterns #-}\n-- {-# LANGUAGE ViewPatterns #-}\n-- {-# LANGUAGE TupleSections #-}\n\nimport           System.IO hiding (char8)\nimport           Control.Applicative\nimport           Control.Monad\nimport           Data.List\nimport           Data.Tuple\nimport           Data.Int\nimport           Data.Char\nimport           Data.Function (on)\nimport           Data.Ord (comparing)\nimport           Data.Monoid (mappend)\nimport           Data.Array\n-- import           Data.Array.Unboxed\n-- import           Data.Array.IArray\n-- import           Data.Array.ST\n-- import           Data.Array.MArray\n-- import           Data.Array.Unsafe\n-- import           Data.Array.Base(unsafeRead, unsafeWrite)\n-- import           Data.Array.IO\nimport           Data.Ix\nimport           Data.Maybe\n-- import           Data.Monoid hiding ((<>))\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Lazy.Char8 as BL\nimport           Data.ByteString.Builder\nimport           Data.Graph\nimport           Data.Tree\n-- import           Data.Vector.Unboxed ((//), (++), (!), (!?))\n-- import qualified Data.Vector.Unboxed as U\n-- import           Data.IntSet (IntSet)\n-- import qualified Data.IntSet as IntSet\nimport           Data.IntMap.Strict (IntMap)\nimport qualified Data.IntMap.Strict as IntMap\nimport           Data.Sequence ((|>), (<|), (><),ViewR(..), ViewL(..), Seq)\nimport qualified Data.Sequence              as Seq\n-- import           Data.Foldable (toList, minimumBy)\n-- import           Debug.Trace\n\nmain = solve <$ getInt1 <*> getInts >>= print\n\nsolve :: [Int] -> Int\nsolve xs = sum . map (cost $ minimum xs) $ cycleNotation xs\n\ncost :: Int -> [Int] -> Int\ncost m xs = min a b where\n  m' = minimum xs\n  a = m' * (length xs - 1) + sum xs - m'\n  b = m * (length xs - 1) + sum xs - m' + (m + m') * 2\n\ncycleNotation :: [Int] -> [[Int]]\ncycleNotation ns = filter ((1<) . length) . map flatten $ components graph where\n  graph = buildG (minimum ns, maximum ns) . zip ns $ sort ns\n-- trace(show ns ++ \"\\n\" ++ show (sort ns)) .\n--  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --\n\ngetInt1 :: IO Int\ngetInt1 = readInt1 <$> BS.getLine\n\ngetInt2 :: IO (Int, Int)\ngetInt2 = readInt2 <$> BS.getLine\n\ngetInt3 :: IO (Int, Int, Int)\ngetInt3 = readInt3 <$> BS.getLine\n\ngetInts :: IO [Int]\ngetInts = readInts <$> BS.getLine\n\ngetIntN :: Int -> IO [Int]\ngetIntN n = map readInt1 <$> replicateM n BS.getLine\n\nformat :: Show a => Maybe a -> IO ()\nformat Nothing = putStrLn \"NO\"\nformat (Just a) = putStrLn \"YES\" >> print a\n\n-- [1,2,3] -> 1 2 3\nputInts :: [Int] -> IO ()\nputInts [] = return ()\nputInts xs = BL.putStrLn . toLazyByteString . foldl1 mappend . intersperse (char8 ' ') $ map intDec xs\n\nreadInt1 :: BS.ByteString -> Int\nreadInt1 = fst . fromJust . BS.readInt\n\nreadInt2 :: BS.ByteString -> (Int,Int)\nreadInt2 = toTuple . readInts\n\nreadInt3 :: BS.ByteString -> (Int,Int,Int)\nreadInt3 = toTriple . readInts\n\nreadInts :: BS.ByteString -> [Int]\nreadInts =  map readInt1 . BS.words\n\nreadInt641 :: BS.ByteString -> Int64\nreadInt641 = fromIntegral . fst . fromJust . BS.readInteger\n\nreadInt642 :: BS.ByteString -> (Int64,Int64)\nreadInt642 = toTuple . readInt64s\n\nreadInt643 :: BS.ByteString -> (Int64,Int64,Int64)\nreadInt643 = toTriple . readInt64s\n\nreadInt64s :: BS.ByteString -> [Int64]\nreadInt64s =  map readInt641 . BS.words\n\nreadInteger1 :: BS.ByteString -> Integer\nreadInteger1 = fst . fromJust . BS.readInteger\n\nreadInteger2 :: BS.ByteString -> (Integer,Integer)\nreadInteger2 = toTuple . readIntegers\n\nreadInteger3 :: BS.ByteString -> (Integer,Integer,Integer)\nreadInteger3 = toTriple . readIntegers\n\nreadIntegers :: BS.ByteString -> [Integer]\nreadIntegers =  map readInteger1 . BS.words\n\ntoTuple :: [a] -> (a, a)\ntoTuple [x, y] = (x, y)\n\ntoTriple :: [a] -> (a, a, a)\ntoTriple [x, y, z] =(x, y, z)\n\nfromTuple :: (a, a) -> [a]\nfromTuple (x, y) = [x, y]\n\nfromTriple :: (a, a, a) -> [a]\nfromTriple (x, y, z) = [x, y, z]\n\n-- if not applying, use \"const\"\n\napplyTuple :: (a -> a') -> (b -> b') -> (a, b) -> (a', b')\napplyTuple f g (x, y) = (f x, g y)\n\napplyTriple :: (a -> a') -> (b -> b') -> (c -> c') -> (a, b, c) -> (a', b', c')\napplyTriple f g h (x, y, z) = (f x, g y, h z)\n\n-- @since 4.8.0.0\nsortOn' :: Ord b => (a -> b) -> [a] -> [a]\nsortOn' f =\n  map snd . sortBy (comparing fst) . map (\\x -> let y = f x in y `seq` (y, x))"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint cost;\n\nvoid swap(int *,int,int);\nvoid Quicksort(int *,int,int);\nint Partition(int *,int,int);\n\nint main(){\n\n  int W[1000],W2[1000],i,j,n;\n  int min = 100000000;\n\n  //入力作業\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)  scanf(\"%d\",&W[i]);\n\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++) W2[j]=W[j];\n    swap(W2,i,n-1);\n\n    cost=0;\n    Quicksort(W2,0,n-1);\n    if( cost < min) min=cost; \n  }\n  printf(\"%d\\n\",cost);\n\n  return 0;\n}\n\n\n\nvoid swap(int *n,int p,int q){\n  int box;\n  \n  box = n[p];\n  n[p]=n[q];\n  n[q]=box;\n}\n\nvoid Quicksort(int *n,int p,int r){\n  int q;\n  if(p < r){\n    q = Partition(n,p,r);\n    Quicksort(n,p,q-1);\n    Quicksort(n,q+1,r);\n  }\n\n}\n\nint Partition(int *n,int p,int r){\n  int i,j,x;\n  \n  x=n[r];\n  j=p-1;\n  \n  for(i=p;i<r;i++){\n    if( n[i] <= x){\n      j++;\n      swap(n,j,i);\n    }\n  }\n  if(j + 1 != r) cost+=(n[j+1] + n[r]);\n  swap(n,j+1,r);\n  \n  return j+1;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n\n\n\nint n,cost;\nint A[1001],B[1001];\nint L[501],R[502];\n\n\nvoid merge(int left,int mid,int right){\n  int i,j,n1=mid-left,n2=right-mid;\n  for(i=0;i<n1;i++) L[i]=A[left+i];\n  L[n1]=INT_MAX;\n  for(i=0;i<n2;i++) R[i]=A[mid+i];\n  R[n2]=INT_MAX;\n  int l=0,r=0;\n  for(i=left;i<right;i++){\n    if(L[l]<=R[r]){\n      A[i]=L[l];\n      l++;\n    }\n    else{\n      A[i]=R[r];\n      r++;\n    }\n  }\n}\n\n\nvoid m_sort(int left,int right){\n  int mid;\n  if( left+1 >= right) return;\n  mid=(left+right)/2;\n  m_sort(left,mid);\n  m_sort(mid,right);\n  merge(left,mid,right);\n}\n\n\nvoid swap(int a,int b,int *C){\n  int swap;\n  swap=C[a];\n  C[a]=C[b];\n  C[b]=swap;\n}\n\n\n\n\n\n\n  \n \n  \n\nint main(){\n  scanf(\"%d\",&n);\n  int i,j;\n  int cnt,sum,min,start,x;\n  int C[1001]={};\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n  m_sort(0,n);\n  for(i=0;i<n;i++){\n    if(A[i]==B[i]) C[i]=1;\n  }\n  cost=0;\n  for(i=0;i<n;i++){\n    if(C[i]!=1){\n      C[i]=1;\n      cnt=0;\n      sum=0;\n      min=B[i];\n      x=i;\n      while(1){\n        for(j=0;j<n;j++){\n          if(B[x]==A[j]){\n            C[j]=1;\n            cnt++;\n            sum+=B[j];\n            if(min > B[j]) min=B[j];\n            x=j;\n            break;\n          }\n        }\n        if(x==i) break;\n      }\n      sum-=min;\n      if( (cnt -1)*min > (cnt -1)*A[0]+2*(min +A[0])) cost+=sum+(cnt-1)*A[0]+2*(min +A[0]);\n      else cost+=sum+(cnt-1)*min;\n    }\n  }\n  printf(\"%d\\n\",cost);\n  return 0;\n}\n\n          \n          \n    "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 1001\ntypedef struct {\n  int sum;\n  int flag;\n} CC;\nCC C[N];\nint A[2000],B[2000];\nint main()\n{\n  int i,n,min=0,m,k,now,sum=0;\n  scanf(\"%d\",&n);\n  for(i=1;i<n+1;i++){\n    scanf(\"%d\",&A[i]);\n  }\n  \n  for(i=0;i<N;i++){\n    C[i].sum=0;\n    C[i].flag=0;\n  }\n  for(i=1;i<n+1;i++){\n    C[A[i]].sum+=1;\n    C[A[i]].flag+=1;\n  }\n  for(i=0;i<N;i++){\n    C[i].sum+=C[i-1].sum;\n  }\n\n  for(i=n+1;i>0;i--){\n    if(C[A[i]].flag==1){\n      k=i;\n      now=k;\n      m=0;\n      B[C[A[k]].sum]=A[k];\n      C[A[i]].flag=0;\n      min=A[k];\n      k=C[A[k]].sum;\n      while(now!=k){\n        if(m==0)sum+=A[now];\n        B[C[A[k]].sum]=A[k];\n        C[A[k]].flag=0;\n        sum+=A[k];\n        if(min>A[k])min=A[k];\n        k=C[A[k]].sum;\n        m+=1;\n      }\n      if(m>1)sum+=min*(m-1);\n      m=0;\n      min=0;\n    }\n  }\n  /*for(i=1;i<n;i++){\n    printf(\"%d \",B[i]);\n  }\n  printf(\"%d\",B[i]);*/\n  printf(\"%d\\n\",sum);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdbool.h>\n\n#define MAX 1000\n#define VMAX 10000\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint min(int a, int b){\n    if(a>b) return b;\n    else return a;\n}\n\n\nint solve(){\n    int ans=0,i,j;\n    bool V[MAX];\n    \n    for( i=0; i<n; i++){\n        B[i]=A[i];\n        V[i]=false;\n    }\n    \n    for (i=0; i<n; i++) {\n        for (j=i+1; j<n; j++) {\n            if (B[i] > B[j]) {\n                 int tmp =  B[i];\n                B[i] = B[j];\n                B[j] = tmp;\n            }\n        }\n    }\n\n    \n    for(int i=0; i<n; i++) T[B[i]] =i;\n    for(int i=0; i<n; i++){\n        if(V[i]) continue;\n        int cur=i;\n        int S=0;\n        int m=VMAX;\n        int an=0;\n        while(1){\n            V[cur]=true;\n            an++;\n            int v=A[cur];\n            m=min(m,v);\n            S += v;\n            cur=T[v];\n            if( V[cur] ) break;\n        }\n        ans += min(S + (an-2) * m, m+S+ (an+1) * s);\n    }\n    return ans;\n}\n\n\n\nint main(){\n    scanf(\"%d\",&n);\n    s=VMAX;\n    for(int i=0; i<n; i++){\n        scanf(\"%d\",&A[i]);\n        s=min(s,A[i]);\n    }\n    int ans = solve();\n    printf(\"%d\\n\",ans);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid qsort(int a[],int left,int right){\n\t\n\tint p=(left+right)/2;\n\tint pivot=a[p];\n\tint i,temp;\n\tif(left<right){\n\t\tp=left;\n\t\tpivot=a[p];\n\t\tfor(i=left+1;i<=right;i++){\n\t\t\tif(a[i]<pivot){\n\t\t\t\tp++;\n\t\t\t\ttemp=a[i];a[i]=a[p];a[p]=temp;//swap\n\t\t\t}\n\t\t}\n\t\ttemp=a[left];a[left]=a[p];a[p]=temp;//swap\n\t\tqsort(a,left,p-1);\n\t\tqsort(a,p+1,right);\n\t}\n\n}\n\nint check(int a[],int b[],int n){\n\tint i;\n\tfor(i=0;i<n;i++){\n\t\tif(a[i]!=b[i])return -1;\n\t}\n\treturn 1;\n}\n\nint main(void){\n\tint n,i,j,mini,minj,min,cost=0,w;\n\tint a[1000],b[1000];\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++)scanf(\"%d\",&a[i]);\n\tfor(i=0;i<n;i++)b[i]=a[i];\n\t\n\tqsort(b,0,n-1);\n\t\n\t\n\twhile(check(a,b,n)==-1){\n\t\tmin=20000;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;a[i]!=b[j] && j<n;j++);\n\t\t\tif(j==n || j==i)continue;\n\t\t\tw=a[i]+a[j];\n\t\t\tif(min>w){\n\t\t\t\tmin=w;\n\t\t\t\tmini=i;minj=j;\n\t\t\t}\n\t\t}\n\t\tcost+=(a[mini]+a[minj]);\n\t\t//printf(\"%d %d \\n\",mini,minj);\n\t\tint temp=a[mini];\n\t\ta[mini]=a[minj];\n\t\ta[minj]=temp;\n\t}\n\tprintf(\"%d\\n\",cost);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\n//============================================================================\n#define pred(x) ((x)-1)\n#define succ(x) ((x)+1)\n//============================================================================\ntypedef unsigned char  INT8U;\ntypedef unsigned short INT16U;\ntypedef   signed short INT16S;\ntypedef long INT32;\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nINT16U *C;\n//----------------------------------------------------------------------------\nvoid CountingSort(INT16U *A, INT16U *B,  INT16U n, INT16U k)\n{\n    long i;\n\n    for (i = 0; i<n; i++)\n        C[A[i]]++;\n    for (i = 1; i<=k; i++)\n        C[i] += C[i-1];\n    /*for (i = 1; i<=k; i++)\n        printf(\"%d \", C[i]);\n    printf(\"\\n\");\n    printf(\"B[C[A[i]]-1] = A[i];\\n\");\n    for (i=n-1; 0<=i; i--){\n        B[C[A[i]]-1] = A[i];\n        printf(\"B[%d]=%d C[%d]=%d A[%d]=%d\\n\", C[A[i]]-1, B[C[A[i]]-1],\n                            A[i], C[A[i]], i, A[i]);\n        C[A[i]]--;\n    }*/\n}\n//----------------------------------------------------------------------------\nINT16S getminptr(INT16U *A, INT16U N)\n{\n    INT16U i,min; INT16S ptr;\n\n    for (i=0, ptr=-1, min=32767; i<N; i++){\n        if (A[i]<min && pred(C[A[i]])!=i){\n            min=A[i];\n            ptr=i;\n        }\n    }\n    return ptr;\n}\n//----------------------------------------------------------------------------\nlong sum;\nvoid exchange(INT16U *x, INT16U *y)\n{\n    INT16U z;\n\n    z=*x, *x=*y, *y=z;\n    sum+=*x;\n    sum+=*y;\n    //printf(\"ex: %d<-->%d, sum:%ld\\n\", *y, *x, sum);\n}\n//----------------------------------------------------------------------------\nlong mincostsort(INT16U *A, INT16U N)\n{\n    int ptr,i,j,min;\n\n    for (i=sum=0; i<pred(N); i++)\n    for (j=succ(i); j<N; j++)\n        if (pred(C[A[j]])==i && pred(C[A[i]])==j)\n            exchange(&A[i], &A[j]);\n    for (i=0,j=32000; i<N; i++)\n        if (A[i]<j)\n            j=A[i],min=i;\n    for (; 0<=(ptr=getminptr(A, N));){\n        if (!A[min]){\n            exchange(&A[min], &A[ptr]);\n            //ptr=min;\n        }\n        while (pred(C[A[ptr]])!=ptr){\n            for (i=0; i<N; i++)\n                if (C[A[i]]==succ(ptr)){\n                    if (!A[ptr]) min=i;\n                    exchange(&A[ptr], &A[i]);\n                    ptr=i;\n#ifdef DESKTOP\n                    for (j=0; j<N; j++)\n                        printf(\"%2d \", A[j]);\n                    printf(\" sum:%ld\\n\", sum);\n#endif\n                    break;\n                }\n        }\n    }\n    return sum;\n}\n//----------------------------------------------------------------------------\n/*\n*                                         *     *\n0 62 33 29 72 52 43 19 5  93 51 32  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51  5  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51 47  8 11 56  5 66 69 30 17 68  5\n0  5 33 29 72 52 43 19 32 93 51 47  8 11 56 62 66 69 30 17 68  0\n0  5 33 29 72 52 43 19 32 93  8 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 29 72 52  8 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33  8 72 52 29 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 11 72 52 29 19 32 93 43 47 51  8 56 62 66 69 30 17 68  8\n0  5 33 11 72  8 29 19 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29  8 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 69  8 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66  8 69 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 68 69 17  8  8\n0  5 33 11 72 19 29 30 32  8 43 47 51 52 56 62 66 68 69 17 93  8\n0  5  8 11 72 19 29 30 32 33 43 47 51 52 56 62 66 68 69 72 93  0\n0  5  8 11 17 19 29 30 32 33 43 47 51 52 56 62 66 68 69 17 93  0\n\n\n\n\n5\n1 5 3 4 2\n7\n\n4\n4 3 2 1\n10\n*/\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nvoid input(FILE *file)\n{\n    long i,n,max,ave; INT16U *A, *B; char buffer[20];\n\n    fgets(buffer, sizeof(buffer)-1, file);\n    sscanf(buffer, \"%ld\", &n);\n    A = malloc(succ(n)*sizeof(INT16U));\n    B = malloc(succ(n)*sizeof(INT16U));\n    for (i=ave=max=0; i<n; i++){\n        fscanf(file, \"%hd\",  &A[i]);\n        if (max<A[i])\n            max=A[i];\n        ave+=A[i];\n    }\n    ave/=n;\n    C = malloc(succ(max)*sizeof(INT16U));\n    memset(C, 0, sizeof(INT16U)*succ(max));\n    CountingSort(A, B, n, max);\n    printf(\"%ld\\n\", mincostsort(A, n));\n#ifdef DESKTOP\n    for (i=0; i<n; i++){\n        if (i) printf(\" \");\n        printf(\"%hd\", A[i]);\n    }\n    printf(\"\\n\");\n#endif\n    free(A);\n    free(B);\n    free(C);\n}\n//============================================================================\n#ifndef DESKTOP\nint main()\n{\n    input(stdin);\n    return 0;\n}\n#endif"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX_N  1000\n\nvoid QuickSort(int, int);\nint Partition(int, int);\nint MinimumCost(int);\n\nstruct rist\n{\n  int n;\n  int p;\n} typedef rist;\n\nrist A[MAX_N];\n\nint main()\n{\n\tint i;\n\tint n;\n\tint cost;\n\t\n\tscanf(\"%d\", &n);\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &A[i].n);\n\t\tA[i].p = i;\n\t}\n\t\n\tQuickSort(0, n - 1);\n\tcost = MinimumCost(n);\n\t\n\tprintf(\"%d\\n\", cost);\n\t\n\treturn 0;\n}\n\nvoid QuickSort(int p, int r)\n{\n  int q;\n\n  if(p < r)\n    {\n      q = Partition(p, r);\n      QuickSort(p, q - 1);\n      QuickSort(q + 1, r);\n    }\n}\n\nint Partition(int p, int r)\n{\n\tint i, j;\n\trist tmp;\n\n\ti = p - 1;\n\tfor(j = p; j < r; j++)\n    {\n    \tif(A[j].n <= A[r].n)\n\t\t{\n\t \t\t i = i + 1;\n\t \t\t tmp = A[i];\n\t  \t\tA[i] = A[j];\n\t  \t\tA[j] = tmp;\n\t\t}\n    }\n\ttmp = A[i + 1];\n  \tA[i + 1] = A[r];\n  \tA[r] = tmp;\n  \n  \treturn i + 1;\n}\n\nint MinimumCost(int n)\n{\n\tint i;\n\tint tmp;\n\tint cost;\n\t\n\tfor(i = n - 1; i >= 0; i--)\n\t{\n\t\tif(A[i].p != i)\n\t\t{\n\t\t\tcost += A[i].n + A[A[i].p].n;\n\n\t\t\ttmp = A[A[i].p].p;\n\t\t\tA[A[i].p].p = A[i].p;\n\t\t\tA[i].p = tmp;\n\t\t}\n\t}\n\treturn cost;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX 1000\n#define MAXWEIGHT2 20000\n\nstruct MCS {\n\tint cost;\n\tint sorder;\n\tint order;\n};\n\nvoid exchange( struct MCS *pa, struct MCS *pb )\n{\n   \tstruct MCS t;\n     \n\tt=*pa;\n\t*pa=*pb;\n\t*pb=t;\n\t \n\t return;\n}\n \nint Partition( struct MCS A[], int p, int r )\n{\n    struct MCS x;\n    int i,j;\n \n    x=A[r];\n    i=p-1;\n    for( j=p; j<r; j++ ) {\n        if( A[j].cost < x.cost ) {\n            i++;\n            exchange( &A[i], &A[j] );\n         }\n    }\n    exchange( &A[i+1], &A[r] );\n\n    return i+1;\n}\nvoid QuickSort( struct MCS A[], int p, int r )\n{\n    int q;\n     \n    if( p < r ) {\n        q=Partition( A, p, r );\n        QuickSort( A, p, q-1 );\n        QuickSort( A, q+1, r );\n    }\n    return;\n}\n\nint tryChange( int n, struct MCS W[] )\n{\n\tint cost,miniCost;\n\tint i;\n\tint maxi,mini;\n\tint max;\n\tint min,mostmin;\n\tint minorder,maxorder,mostminorder;\n\tint limitN;\n\t\n\tmaxi=mini=0;\n\tminiCost=cost=MAXWEIGHT2;\n\n\tlimitN=n;\t\n\tmaxorder=max=-1;\n\tmostmin=min=mostminorder=minorder=n;\n    while( 1 ) {\n\t\tfor( i=0; i<limitN; i++ ) {\n\t\t\tif( i != W[i].order ) {\n\t\t\t\tif( max < W[i].sorder ) {\n    \t\t\t\tmax=W[i].sorder;\n    \t\t\t\tmaxorder=i;\n    \t\t\t}\n\t\t\t\tif( W[i].sorder < min ) {\n\t\t\t\t\tmin=W[i].sorder;\n\t\t\t\t\tminorder=i;\t\n\t\t\t\t}\n    \t\t\t\n\t\t\t}\n\t\t\tif( W[i].sorder < mostmin ) {\n\t\t\t\tmostmin=W[i].sorder;\n\t\t\t\tmostminorder=i;\t\n\t\t\t}\n\t\t}\n\t\tif( -1 == maxorder ) { break; }\n\t\t\n\t\tif( W[maxorder].order != minorder ) {\n\t\t\tif( 2*(W[minorder].order+W[mostminorder].order) < (W[maxorder].order+W[minorder].order)  ) {\n\t\t\t\tminorder=mostminorder;\n\t\t\t}\n\t\t}\n   \t\tif( W[maxorder].order == minorder ) { \n\t\t\tcost=( W[minorder].cost+W[maxorder].cost );\n\t\t\tminiCost=cost;\n\t\t\tmini=minorder;\n\t\t\tmaxi=maxorder;\n\t\t\tbreak;\n\t\t}\n\t\tlimitN--;\n\t\tmax=-1;\n\t\tif( -1 == limitN ) {\n\t\t\tif( MAXWEIGHT2 == miniCost ) {\n\t\t\t\tcost=( W[minorder].cost+W[maxorder].cost );\n\t\t\t\tminiCost=cost;\n\t\t\t\tmini=minorder;\n\t\t\t\tmaxi=maxorder;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n    }\n\n\n\n    if( MAXWEIGHT2 != miniCost ) {\n\t\texchange( &W[mini], &W[maxi] );\n    } else {\n    \tminiCost=0;\n    }\n\n\treturn miniCost;\n}\n\nint main( void ) \n{   \n    int n,i;\n    struct MCS W[MAX+1];\n    int cost;\n        \n    scanf( \"%d\", &n );\n    for( i=0; i<n; i++ ) {\n        scanf( \"%d\", &W[i].cost );\n        W[i].order=i;\n    }\n\n    QuickSort( W, 0, n-1 ); \n     for( i=0; i<n; i++ ) {\n        W[i].sorder=i;\n    }\n   cost=i=0;\n    while( (i = tryChange( n, W ) ) ) {\n   \t\tcost+=i;\n    }\n   \tprintf( \"%d\\n\", cost );\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 1000\n \nint n,A[N],B[N],C[N],con,res,min;\n \nvoid swap(int* A,int* B)\n{\n  int ch;\n  ch=*A;\n  *A=*B;\n  *B=ch;\n}\nint small(int a,int b)\n{\n  if(a<b)return a;\n  \n  else return b;\n}\n \nint search(int a)\n{\n  int m;\n  for(m=0; m<n; m++){\n    if(A[m]==a)return m;\n  }\n  \n}\n \nint main()\n{\n  int i,j,sum=0,k;\n \n  scanf(\"%d\",&n);\n \n  for(i=0; i<n; i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n \n  for(i=n-1; i>0; i--){\n    for(j=0; j<i; j++){\n      if(B[j]>B[j+1]) swap(&B[j],&B[j+1]);\n    }\n  }\n \n  for(i=0; i<n; i++)C[i]=0;\n \n  for(i=0; i<n; i++){\n    k=i;\n    con=res=0;\n    min=(1<<24);\n \n    while(C[k]==0){\n      C[k]=1;\n      con++;\n      res+=A[k];\n      min=small(min,A[k]);\n      k=search(B[k]);\n    }\n \n    if(con<2)continue;\n    sum+=small(res+B[0]*(con+1)+min,res+min*(con-2));\n  }\n \n  printf(\"%d\\n\",sum);\n   \n  return 0;\n  \n}\n\n\n"
  },
  {
    "language": "C",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n\n\n\n\n// -- Quick Sort\nvoid swap( int *a, int *b ){\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n\nint partition( int *a, int p, int r ){\n\n    int i, j;\n    int x;\n\n    x = a[r];\n    i = p-1;\n\n\n    for( j=p; j<r; j++ ){\n\n        if( a[j] <= x ){\n            i++;\n            swap( &a[i], &a[j] );\n        }\n    }\n    i++;\n    swap( &a[i], &a[r] );\n\n\n    return i;\n\n}\n\nvoid quicksort( int *a, int p, int r ){\n\n    int q;\n\n    if( p<r ){\n        q = partition( a, p, r );\n        quicksort( a, p, q-1 );\n        quicksort( a, q+1, r );\n    }\n}\n\n\n\nint main(){\n\n    int n, w[10000];\n    int x[10000];\n    int i;\n    int c = 0;\n\n    scanf( \"%d\", &n);\n\n    for( i=0; i<n; i++ ){\n        scanf( \"%d\", &w[i] );\n        x[i] = w[i];\n    }\n\n    quicksort( x, 0, n-1 );\n\n    for( i=0; i<n; i++){\n        if( x[i] != w[i] ) c += w[i];\n    }\n\n\n    printf( \"%d\\n\", c );\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "include<stdio.h>\n//toriaezu\nint sort(int *A,int n){\n  int i,j;\n  int min=1000,max=0;\n  int cost=0;\n  \n  for(i=1;i<n;i++){\n    if(A[i]>max) max=A[i];\n    else if(A[i]<min) min=A[i];\n  }\n  cost+=max+min;\n  return cost;\n}\nint main(){\n\n  int i,n,cost;\n  int A[1000];\n\n  scanf(\"%d\",&n);\n\n  for(i=0;i<n;i++) scanf(\"%d\",&A[i]);\n  cost=sort(&A[0],n);\n  \n  printf(\"%d\\n\",cost);\nreturn 0;\n}"
  },
  {
    "language": "C",
    "code": "\t//\t????°???????????????????\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define DEF_ELEM_MAX 1000\n#define DEF_VMAX 10000\n\n//  ????°?????????????\n#ifndef min\n#define min(a, b)            (((a) < (b)) ? (a) : (b))\n#endif\n\ntypedef struct _node {\n\tint value;\n\tint place;\n} node;\n\nint A[DEF_ELEM_MAX];\n\n/////////////////////////////////////////////////////////////////////////////////\n//\n/////////////////////////////////////////////////////////////////////////////////\nint int_sort( const void * a , const void * b )\n{\n\tint p = (( node * )a)->value;\n\tint q = (( node * )b)->value;\n  if( p < q ) {\n    return -1;\n  }  else if( p == q  ) {\n    return 0;\n  }\n  return 1;\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n//\n/////////////////////////////////////////////////////////////////////////////////\nint sillysort( int *A, int m )\n{\n\tint s;\n\tint cost = 0;\n\tint i;\n\tint j;\n\tint n;\n\tint amin;\n\tint sum;\n\tint next;\n\n\tnode nodes[1000] = {0};\n\tnode temp[1000] = {0};\n\t// init\n\tfor ( i = 0 ; i < m ; i++ ) {\n\t\tnodes[i].value = A[i];\n\t\ttemp[i].value = A[i];\n\t\ttemp[i].place = i;\n\t}\n\n\tqsort(&temp, m , sizeof( node ), int_sort );\n\n\tfor ( i = 0 ; i < m ; i++ ) {\n\t\tnodes[temp[i].place].place = i;\n\t}\n\ts = temp[0].value;\n\t// compute\n\tfor ( i = 0 ; i < m ; i++ ) {\n\t\tj = nodes[i].place;\n\t\tif ( j >= 0 && j != i ) {\n\t\t\tn = 1;\n\t\t\tamin = sum = nodes[i].value;\n\t\t\twhile ( j != i ) {\n\t\t\t\tnext = nodes[j].place;\n\t\t\t\tif ( nodes[j].value < amin ) {\n\t\t\t\t\tamin = nodes[j].value;\n\t\t\t\t}\n\t\t\t\tsum += nodes[j].value;\n\t\t\t\tn++;\n\t\t\t\tnodes[j].place = -1;\n\t\t\t\tj = next;\n\t\t\t}\n\t\t\tcost += min(sum+(n-2)*amin, sum+amin+(n-1)*s);\n\t\t}\n\t}\n\treturn cost;\n}\n/////////////////////////////////////////////////////////////////////////////////\n//\n/////////////////////////////////////////////////////////////////////////////////\nint main(void)\n{\n\tint i;\n\tint N;\n\tint ans;\n//\n\tscanf(\"%d\", &N);\n\tfor ( i = 0 ; i < N ; i++ ) {\n\t\tscanf(\"%d\", &A[i] );\n\t}\n\n\tans = sillysort( A, N );\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define Max  1000\n#define vMax 10000\n\nint n, a[Max], s;\nint b[Max], t[vMax + 1];\n\n\nint partition(int a[], int p, int r){\n  int i, j;\n  int t, x;\n  x = a[r];\n  i = p - 1;\n\n  for(j = p ; j < r ; j++){\n    if(a[j] <= x){\n      i++;\n      t = a[i];\n      a[i] = a[j];\n      a[j] = t;\n    }\n  }\n\n  t = a[i + 1];\n  a[i + 1] = a[r];\n  a[r] = t;\n\n  return i + 1;\n}\n\nvoid quickSort(int a[], int p, int r){\n  int q;\n  if(p < r){\n    q = partition(a, p, r);\n    quickSort(a, p, q - 1);\n    quickSort(a, q + 1, r);\n  }\n}\n\n\n\nint solve(){\n  int i,ans = 0, cur, S, m, an, v;\n\n  int V[Max];\n  for(i = 0 ; i < n ; i++){\n    b[i] = a[i];\n    V[Max] = 0;\n  }\n\n  quickSort(b, 0, n - 1);\n\n  for(i = 0 ; i < n ; i++) t[b[i]] = i;\n  for(i = 0 ; i < n ; i++){\n    if(V[i]) continue;\n    cur = i;\n    S = 0;\n    m = vMax;\n    an = 0;\n    while(1){\n      V[cur] = 1;\n      an++;\n      v = a[cur];\n\n      if(v < m) m = v;\n\n      S += v;\n      cur = t[v];\n      if(V[cur]) break;\n    }\n    if(S + (an -2) * m < m + S + (an + 1) * s) ans += S + (an -2) * m;\n    if(S + (an -2) * m > m + S + (an + 1) * s) ans +=  m + S + (an + 1) * s;\n  }\n  return ans;\n}\n\n\nint main(){\n  int i;\n\n  scanf(\"%d\", &n);\n  s = vMax;\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\", &a[i]);\n    if(a[i] < s) s = a[i];\n}\n\n  int ans = solve();\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nvoid swap(int *A, int i, int j) {\n  int temp;\n  temp = A[i];\n  A[i] = A[j];\n  A[j] = temp;\n}\n\nvoid Merge(int *A, int left, int mid, int right) {\n  int n1,n2,*L,*R,i,j,k;\n  n1 = mid -left;\n  n2 = right - mid;\n  L = (int*)malloc(sizeof(int) * (n1+1));\n  R = (int*)malloc(sizeof(int) * (n2+1));\n  for (i = 0; i< n1; i++) {\n    L[i] = A[left+i];\n  }\n  for (i = 0; i < n2; i++) {\n    R[i] = A[mid+i];\n  }\n  L[n1] = INT_MAX; R[n2] = INT_MAX;\n  i = 0;j = 0;\n  for(k = left; k < right; k++) {\n    if (L[i] < R[j]) {\n      A[k] = L[i];\n      i++;\n    }else {\n      A[k] = R[j];\n      j++;\n    }\n  }\n  free(L);\n  free(R);\n}\n\nvoid Merge_Sort(int *A, int left, int right) {\n  if(left+1 < right) {\n    int mid = (left + right)/2;\n    Merge_Sort(A,left,mid);\n    Merge_Sort(A,mid,right);\n    Merge(A,left,mid,right);\n  }\n}\n\nint sort_step(int *w, int *w1, int n) {\n  int i,j,mini,minj,min;\n  min = INT_MAX;\n  for (i = 0; i < n; i++) {\n    j = 0;\n    while(w1[i] != w[j]) j++;\n    if(i != j) {\n      if(min > w[i]+w[j]) {\n\tmini = i;\n\tminj = j;\n\tmin = w[i]+w[j];\n      }\n    }\n  }\n  if(min == INT_MAX) return 0;\n  swap(w,mini,minj);\n  return min;\n}\n\nlong min_sort(int *w, int *w1, int n) {\n  long sum = 0,tmp = 0;\n  while(1) {\n    sum += sort_step(w,w1,n);\n    if(sum == tmp) break;\n    tmp = sum;\n  }\n  return sum;\n}\n\nint main()\n{\n  int i,n,*w,*w2;\n  long sum;\n  scanf(\"%d\",&n);\n  w = (int*)malloc(sizeof(int) * n);\n  w2 = (int*)malloc(sizeof(int) * n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\",w+i);\n    w2[i] = w[i];\n  }\n  Merge_Sort(w2,0,n);\n  \n  sum = min_sort(w,w2,n);\n  printf(\"%ld\\n\",sum);\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n   \n   \n   \nint n,cost;\nint A[1001],B[1001];\nint L[501],R[502];\n   \n   \nvoid merge(int left,int mid,int right){\n  int i,j,n1=mid-left,n2=right-mid;\n  for(i=0;i<n1;i++) L[i]=A[left+i];\n  L[n1]=INT_MAX;\n  for(i=0;i<n2;i++) R[i]=A[mid+i];\n  R[n2]=INT_MAX;\n  int l=0,r=0;\n  for(i=left;i<right;i++){\n    if(L[l]<=R[r]){\n      A[i]=L[l];\n      l++;\n    }\n    else{\n      A[i]=R[r];\n      r++;\n    }\n  }\n}\n   \n   \nvoid m_sort(int left,int right){\n  int mid;\n  if( left+1 >= right) return;\n  mid=(left+right)/2;\n  m_sort(left,mid);\n  m_sort(mid,right);\n  merge(left,mid,right);\n}\n   \n   \nvoid swap(int a,int b,int *C){\n  int swap;\n  swap=C[a];\n  C[a]=C[b];\n  C[b]=swap;\n}\n   \n   \n   \n   \n   \n   \n     \n    \n     \n   \nint main(){\n  scanf(\"%d\",&n);\n  int i,j;\n  int cnt,sum,min,start,x;\n  int C[1001]={};\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n  m_sort(0,n);\n  for(i=0;i<n;i++){\n    if(A[i]==B[i]) C[i]=1;\n  }\n  cost=0;\n  for(i=0;i<n;i++){\n    if(C[i]!=1){\n      C[i]=1;\n      cnt=0;\n      sum=0;\n      min=B[i];\n      x=i;\n      while(1){\n        for(j=0;j<n;j++){\n          if(B[x]==A[j]){\n            C[j]=1;\n            cnt++;\n            sum+=B[j];\n            if(min > B[j]) min=B[j];\n            x=j;\n            break;\n          }\n        }\n        if(x==i) break;\n      }\n      sum-=min;\n      if( (cnt -1)*min > (cnt -1)*A[0]+2*(min +A[0])) cost+=sum+(cnt-1)*A[0]+2*(min +A[0]);\n      else cost+=sum+(cnt-1)*min;\n    }\n  }\n  printf(\"%d\\n\",cost);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX_N  1000\n\nvoid QuickSort(int, int);\nint Partition(int, int);\nint MinimumCost(int);\n\nstruct rist\n{\n  int n;\n  int p;\n} typedef rist;\n\nrist A[MAX_N];\n\nint main()\n{\n\tint i;\n\tint n;\n\tint cost;\n\t\n\tscanf(\"%d\", &n);\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &A[i].n);\n\t\tA[i].p = i;\n\t}\n\t\n\tQuickSort(0, n - 1);\n\tcost = MinimumCost(n);\n\t\n\tprintf(\"%d\\n\", cost);\n\t\n\treturn 0;\n}\n\nvoid QuickSort(int p, int r)\n{\n\tint q;\n\n\tif(p < r)\n    {\n      q = Partition(p, r);\n      QuickSort(p, q - 1);\n      QuickSort(q + 1, r);\n    }\n}\n\nint Partition(int p, int r)\n{\n\tint i, j;\n\trist tmp;\n\n\ti = p - 1;\n\tfor(j = p; j < r; j++)\n    {\n    \tif(A[j].n < A[r].n)\n\t\t{\n\t \t\ti = i + 1;\n\t \t\ttmp = A[i];\n\t  \t\tA[i] = A[j];\n\t  \t\tA[j] = tmp;\n\t\t}\n    }\n\ttmp = A[i + 1];\n  \tA[i + 1] = A[r];\n  \tA[r] = tmp;\n  \n  \treturn i + 1;\n}\n\nint MinimumCost(int n)\n{\n\tint i;\n\tint tmp;\n\tint cost = 0;\n\t\n\tfor(i = n - 1; i >= 0; i--)\n\t{\n\t\tif(A[i].p != i)\n\t\t{\n\t\t\tcost += A[i].n + A[A[i].p].n;\n\n\t\t\ttmp = A[A[i].p].p;\n\t\t\tA[A[i].p].p = A[i].p;\n\t\t\tA[i].p = tmp;\n\t\t}\n\t}\n\treturn cost;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid qsort(int a[],int left,int right){\n\t\n\tint p=(left+right)/2;\n\tint pivot=a[p];\n\tint i,temp;\n\tif(left<right){\n\t\tp=left;\n\t\tpivot=a[p];\n\t\tfor(i=left+1;i<=right;i++){\n\t\t\tif(a[i]<pivot){\n\t\t\t\tp++;\n\t\t\t\ttemp=a[i];a[i]=a[p];a[p]=temp;//swap\n\t\t\t}\n\t\t}\n\t\ttemp=a[left];a[left]=a[p];a[p]=temp;//swap\n\t\tqsort(a,left,p-1);\n\t\tqsort(a,p+1,right);\n\t}\n\n}\n\nint search(int key,int a[],int n){\n\tint i;\n\tfor(i=0;i<n;i++){\n\t\tif(key==a[i])return i;\n\t}\n\t\n\treturn i;\n}\n\nint isVisited(int v[],int n){\n\tint i;\n\tfor(i=0;i<n;i++){\n\t\tif(v[i]!=1)return -1;\n\t}\n\treturn 1;\n}\n\t\nint min(int a,int b){\n\tif(a<b)return a;\n\treturn b;\n}\n\n\nint main(void){\n\tint n,i,j,minW,cost=0,w;\n\tint a[1000],b[1000],v[1000];\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tb[i]=a[i];\n\t\tv[i]=0;\n\t}\n\tqsort(b,0,n-1);\n\t\n\tfor(i=0;i<n;i++){\t\n\t\tint x=i;\n\t\tint sum=0;\n\t\tint count=0;\n\t\tminW=10000;\n\t\twhile(v[x]==0){\n\t\t\tv[x]=1;\n\t\t\tsum+=a[x];\n\t\t\tcount++;\n\t\t\tif(minW>a[x])minW=a[x];\n\t\t\tx=search(a[x],b,n);\n\t\t}\n\t\tif(count<2)continue;\n\t\t\n\t\tcost+=min(b[0]*(count+1)+sum+minW,sum+(count-2)*minW);\n\t\tif(isVisited(v,n)==1)break;\n\t}\n\t\n\tprintf(\"%d\\n\",cost);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid swap(int* a,int* b){\n  int tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\n\nint n;\nint A[1000];\nint B[1000];\n\nint search(int x){\n  int i;\n  for(i=0;i<n;i++){\n    if(A[i]==x)return i;\n  }\n}\n\nint main(){\n  int i,j,ans,x,y,xa,yb;\n\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n  \n  for(i=n-1;i>0;i--){\n    for(j=0;j<i;j++){\n      if(B[j]>B[j+1])swap(&B[j],&B[j+1]);\n    }\n  }\n \n  ans=0;\n  \n  while(1){\n    x=(1<<24);\n    for(i=0;i<n;i++){\n      if(A[i]==B[i])continue;\n      if(x>A[i]){\n\tx=A[i];\n\ty=i;\n      }\n    }\n    if(x==(1<<24))break;\n\n    x=search(B[y]);\n\n    swap(&A[x],&A[y]);\n    ans+=(A[x]+A[y]);\n  }\n  printf(\"%d\\n\",ans);\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX 1000\n#define VMAX 10000\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nvoid sort(int A[]){\n\tint f = 1;\n\tint tmp;\n\twhile(f){\n\t\tf = 0;\n\t\tfor(int j = n-1; j >= 1; j--){\n\t\t\tif(A[j] < A[j-1]){\n\t\t\t\ttmp = A[j-1];\n\t\t\t\tA[j-1] = A[j];\n\t\t\t\tA[j] = tmp;\n\t\t\t\tf = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint min(int a, int b){\n\tif(a <= b) return a;\n\telse return b;\n}\n\nint solve(){\n\tint ans=0;\n\tint i;\n\t\n\tint V[MAX];\n\tfor(i = 0; i < n; i++){\n\t\tB[i] = A[i];\n\t\tV[i] = 0;\n\t}\n\tsort(B);\n\tfor(i = 0; i < n; i++)T[B[i]] = i;\n\tfor(i = 0; i < n; i++){\n\t\tif(V[i]) continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile(1){\n\t\t\tV[cur] = 1;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif(V[cur])break;\n\t\t}\n\t\tans += min(S+(an-2)*m, m+S+(an+1)*s);\n\t}\n\treturn ans;\n}\n\nint main(void){\n\tscanf(\"%d\", &n);\n\ts = VMAX;\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &A[i]);\n\t\ts = min(s, A[i]);\n\t}\n\tint ans = solve();\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n\n#define MAX 1000\n#define VMAX 10000\n#define N 2000000000\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nvoid merge(int A[], int left, int mid, int right){\n    int n1 = mid - left;\n    int n2 = right - mid;\n    int L[n1];\n    int R[n2];\n    for(int i=0; i<n1; i++){\n        L[i] = A[left+i];\n    }\n    for(int i=0; i<n2; i++){\n        R[i] = A[mid+i];\n    }\n    L[n1]=N;\n    R[n2]=N;\n    int i=0;\n    int j=0;\n\n    for(int k=left; k<right; k++){\n        \n        if(L[i] <= R[j]){\n            A[k] = L[i];\n            i++;\n        }\n        else{\n            A[k] = R[j];\n            j++;\n        }\n    }\n}\n\n\n\nint min(int a, int b){\n    if(a>b){\n        return b;\n    }\n    else{\n        return a;\n    }\n}\n\nvoid mergeSort(int A[], int left, int right){\n    int mid;\n    if(left+1 < right){\n        mid = (left+right)/2;\n        mergeSort(A, left, mid);\n        mergeSort(A, mid, right);\n        merge(A, left, mid, right);\n    }\n}\n\nint solve(){\n    int ans=0;\n\n    int V[MAX];\n    for(int i=0; i<n; i++){\n        B[i]=A[i];\n        V[i]=0;\n    }\n\n    mergeSort(B, 0, n);\n   \n    for(int i=0; i<n; i++){\n        T[B[i]]=i;\n\n    }\n    for(int i=0; i<n; i++){\n       if(V[i]){\n           continue;\n       }\n       int cur=i;\n       int S=0;\n       int m=VMAX;\n       int an=0;\n       while(1){\n           V[cur]=1;\n           an++;\n           int v=A[cur];\n           m=min(m,v);\n           S+=v;\n           cur=T[v];\n           if(V[cur]){\n               break;\n           }\n           \n\n       }\n       ans+=min(S+(an-2)*m, m+S+(an+1)*s);\n       \n\n    }\n    return ans;\n\n\n\n}\n\nint main(void){\n    scanf(\"%d\", &n);\n    s=VMAX;\n    for(int i=0; i<n; i++){\n        scanf(\"%d\", &A[i]);\n        s=min(s, A[i]);\n    }\n    int ans=solve();\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint pertition(int a[],int left,int right){\n    int i,j,k,l;\n    k=left-1;\n    for(i=left;i<right-1;i++){\n        if(a[i]<=a[right-1]){\n            k++;\n            l=a[i]; a[i]=a[k]; a[k]=l;\n        }\n    }\n    l=a[k+1]; a[k+1]=a[right-1]; a[right-1]=l;\n    return k+1;\n}\n\nvoid quicksort(int a[],int left,int right){\n    int mid;\n    if(left+1<right){\n        mid = pertition(a,left,right);\n        quicksort(a,left,mid);\n        quicksort(a,mid+1,right);\n    }\n}\n\nint minn(int a,int b){\n    if(a<b){return a;}\n    return b;\n}\n\nint solve(int a[1000],int b[1000],int min,int n){\n    int v[1000];\n    int t[10001];\n    int i,cur,s,lmin,an,ans;\n    ans=0;\n    for(i=0;i<n;i++){v[i]=0;}\n    quicksort(b,0,n);\n    for(i=0;i<n;i++){t[b[i]]=i;}\n    for(i=0;i<n;i++){\n        if(v[i]==1){continue;}\n        cur=i; s=0; lmin=10001; an=0;\n        while(1){\n            v[cur]=1; an++;\n            if(lmin>a[cur]){lmin=a[cur];}\n            s+=a[cur];\n            cur=t[a[cur]];\n            if(v[cur]==1){break;}\n        }\n        ans += minn(s+(an-2)*lmin,lmin+s+(an+1)*min);\n    }\n    return ans;\n}\n\nint main(void){\n    int n,i,min;\n    int a[1000];\n    int b[1000];\n    scanf(\"%d\",&n);\n    min=100000;\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&a[i]);\n        b[i]=a[i];\n        if(min>a[i]){min=a[i];}\n    }\n    printf(\"%d\\n\",solve(a,b,min,n));\n    \n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define Max  1000\n#define vMax 10000\n\nint n, a[Max], s;\nint b[Max], t[vMax + 1];\n\n\nint partition(int a[], int p, int r){\n  int i, j;\n  int t, x;\n  x = a[r];\n  i = p - 1;\n\n  for(j = p ; j < r ; j++){\n    if(a[j] <= x){\n      i++;\n      t = a[i];\n      a[i] = a[j];\n      a[j] = t;\n    }\n  }\n\n  t = a[i + 1];\n  a[i + 1] = a[r];\n  a[r] = t;\n\n  return i + 1;\n}\n\nvoid quickSort(int a[], int p, int r){\n  int q;\n  if(p < r){\n    q = partition(a, p, r);\n    quickSort(a, p, q - 1);\n    quickSort(a, q + 1, r);\n  }\n}\n\n\n\nint solve(){\n  int i,ans = 0, cur, S, m, an, v;\n\n  int V[Max];\n  for(i = 0 ; i < n ; i++){\n    b[i] = a[i];\n    V[i] = 0;\n  }\n\n  quickSort(b, 0, n - 1);\n\n  for(i = 0 ; i < n ; i++) t[b[i]] = i;\n  for(i = 0 ; i < n ; i++){\n    if(V[i]) continue;\n    cur = i;\n    S = 0;\n    m = vMax;\n    an = 0;\n    while(1){\n      V[cur] = 1;\n      an++;\n      v = a[cur];\n\n      if(v < m) m = v;\n\n      S += v;\n      cur = t[v];\n      if(V[cur]) break;\n    }\n    if(S + (an -2) * m < m + S + (an + 1) * s) ans += S + (an -2) * m;\n    if(S + (an -2) * m > m + S + (an + 1) * s) ans +=  m + S + (an + 1) * s;\n  }\n  return ans;\n}\n\n\nint main(){\n  int i;\n\n  scanf(\"%d\", &n);\n  s = vMax;\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\", &a[i]);\n    if(a[i] < s) s = a[i];\n}\n\n  int ans = solve();\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n//toriaezu\nint sort(int *A,int n){\n  int i,j;\n  int min=1000,max=0;\n  int cost=0;\n  \n  for(i=1;i<n;i++){\n    if(A[i]>max) max=A[i];\n    else if(A[i]<min) min=A[i];\n  }\n  cost+=max+min;\n  return cost;\n}\nint main(){\n\n  int i,n,cost;\n  int A[1000];\n\n  scanf(\"%d\",&n);\n\n  for(i=0;i<n;i++) scanf(\"%d\",&A[i]);\n  cost=sort(&A[0],n);\n  \n  printf(\"%d\\n\",cost);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\n//============================================================================\n#define pred(x) ((x)-1)\n#define succ(x) ((x)+1)\n//============================================================================\ntypedef unsigned char  INT8U;\ntypedef unsigned short INT16U;\ntypedef   signed short INT16S;\ntypedef long INT32;\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nINT16U *C;\n//----------------------------------------------------------------------------\nvoid CountingSort(INT16U *A, INT16U *B,  INT16U n, INT16U k)\n{\n    long i;\n\n    for (i = 0; i<n; i++)\n        C[A[i]]++;\n    for (i = 1; i<=k; i++)\n        C[i] += C[i-1];\n    // C holds position of A\n    // C[A[val]] = pred val position\n\n    /*for (i = 1; i<=k; i++)\n        printf(\"%d \", C[i]);\n    printf(\"\\n\");*/\n    /*printf(\"B[C[A[i]]-1] = A[i];\\n\");\n    for (i=n-1; 0<=i; i--){\n        //B[C[A[i]]-1] = A[i];\n        printf(\"B[%d]=%d C[%d]=%d A[%d]=%d\\n\", C[A[i]]-1, A[i],\n                            A[i], C[A[i]], i, A[i]);\n        //C[A[i]]--;\n    }*/\n}\n//----------------------------------------------------------------------------\nINT16S getminptr(INT16U *A, INT16U N)\n{\n    INT16U i,min; INT16S ptr;\n\n    for (i=0, ptr=-1, min=32767; i<N; i++){\n        if (A[i]<min && pred(C[A[i]])!=i){\n            min=A[i];\n            ptr=i;\n        }\n    }\n    return ptr;\n}\n//----------------------------------------------------------------------------\nlong sum;\nvoid exchange(INT16U *x, INT16U *y)\n{\n    INT16U z;\n\n    z=*x, *x=*y, *y=z;\n    sum+=*x;\n    sum+=*y;\n    //printf(\"ex: %d<-->%d, sum:%ld\\n\", *y, *x, sum);\n}\n//----------------------------------------------------------------------------\nvoid prnary(INT16U *A, INT16U N)\n{\n    int j;\n\n    for (j=0; j<N; j++)\n        printf(\"%2d \", A[j]);\n    printf(\" sum:%ld\\n\", sum);\n}\n//----------------------------------------------------------------------------\nshort linklen(INT16U *A, INT16U val)\n{\n    int idx,n;\n\n    for (n=0, idx=val; ; n++){\n        idx=A[pred(C[idx])];\n        if (idx==val)\n            return n;\n    }\n}\n//----------------------------------------------------------------------------\nshort bgnlink(INT16U *A, INT16U val)\n{\n    int sum,idx,start;\n\n    for (start=idx=val; ; ){\n        idx=A[pred(C[idx])];\n        if (idx<start)\n            start=idx;\n        if (idx==val)\n            return start;\n    }\n}\n//----------------------------------------------------------------------------\nshort revcost(INT16U *A, INT16U val)\n{\n    int sum,idx,start;\n\n    val=bgnlink(A, val);\n    for (sum=0, idx=val; ; ){\n        idx=A[pred(C[idx])];\n        if (idx==val)\n            return sum;\n        sum+=(idx+val);\n    }\n}\n//----------------------------------------------------------------------------\nshort exccost(INT16U *A, INT16U val, INT16U min)\n{\n    int sum,idx,porn;\n\n    if (val!=min)\n        sum=val+min;\n    else\n        sum=0;\n    for (porn=min, idx=val; ; ){\n        idx=A[pred(C[idx])];\n        sum+=(idx+porn);\n        if (idx==val)\n            return sum;\n    }\n}\n//----------------------------------------------------------------------------\nvoid duplication(INT16U *A, INT16U N)\n{\n    int i,j,k,n,a,ary[3];\n\n#ifdef DESKTOP\n    prnary(A, N);\n#endif\n    for (i=sum=0; i<pred(N); i++){\n        n=linklen(A, A[i]);\n        if (n==1){\n            j=pred(C[A[i]]);\n            exchange(&A[i], &A[j]);\n            //printf(\"ex:(%d<->%d), \", A[i], A[j]);\n        }\n#ifdef DESKTOP\n    }\n    printf(\"\\n\");\n#else\n    }\n#endif\n}\n//----------------------------------------------------------------------------\nlong mincostsort(INT16U *A, INT16U N)\n{\n    int ptr,i,j,min,ordptr,order[100];\n\n    duplication(A, N);\n    for (i=0,j=32000; i<N; i++)\n        if (A[i]<j)\n            j=A[i],min=i;\n    for (ordptr=0; 0<=(ptr=getminptr(A, N));){\n#ifdef DESKTOP\n    printf(\"[%d]\\n\", A[ptr]);\n#endif\n        order[ordptr++]=A[ptr];\n        //if (A[min]*2<A[ptr]){\n        if (exccost(A, A[ptr], A[min])<revcost(A, A[ptr])){\n            exchange(&A[min], &A[ptr]);\n            min=ptr;\n        }\n        while (pred(C[A[ptr]])!=ptr){\n            for (i=0; i<N; i++)\n                if (C[A[i]]==succ(ptr)){\n                    order[ordptr++]=A[i];\n                    if (ptr==min) min=i;\n                    exchange(&A[ptr], &A[i]);\n                    ptr=i;\n#ifdef DESKTOP\n                    //prnary(A, N);\n#endif\n                    break;\n                }\n        }\n    }\n#ifdef DESKTOP\n    for (i=0; i<ordptr; i++){\n        if (i) printf(\"->\");\n            printf(\"%d\", order[i]);\n    }\n    printf(\"\\n\");\n#endif\n    return sum;\n}\n//----------------------------------------------------------------------------\n/*\n*                                         *     *\n0 62 33 29 72 52 43 19 5  93 51 32  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51  5  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51 47  8 11 56  5 66 69 30 17 68  5\n0  5 33 29 72 52 43 19 32 93 51 47  8 11 56 62 66 69 30 17 68  0\n0  5 33 29 72 52 43 19 32 93  8 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 29 72 52  8 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33  8 72 52 29 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 11 72 52 29 19 32 93 43 47 51  8 56 62 66 69 30 17 68  8\n0  5 33 11 72  8 29 19 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29  8 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 69  8 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66  8 69 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 68 69 17  8  8\n0  5 33 11 72 19 29 30 32  8 43 47 51 52 56 62 66 68 69 17 93  8\n0  5  8 11 72 19 29 30 32 33 43 47 51 52 56 62 66 68 69 72 93  0\n0  5  8 11 17 19 29 30 32 33 43 47 51 52 56 62 66 68 69 17 93  0\n\n 1 80 50 70 40 20\n20 80 50 70 40  1\n20  1 50 70 40 80\n 1 20 50 70 40 80 21        20 40 50 70  1 80   41\n40 20 50 70  1 80 41        20 40 50  1 70 80   71\n40 20 50  1 70 80 71        20 40  1 50 70 80   51\n40 20  1 50 70 80 51        20  1 40 50 70 80   41\n 1 20 40 50 70 80 41         1 20 40 50 70 80   21\n\n\n5\n1 5 3 4 2\n7\n\n4\n4 3 2 1\n10\n*/\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nvoid input(FILE *file)\n{\n    long i,n,max,ave; INT16U *A, *B; char buffer[20];\n\n    fgets(buffer, sizeof(buffer)-1, file);\n    sscanf(buffer, \"%ld\", &n);\n    A = malloc(succ(n)*sizeof(INT16U));\n    B = malloc(succ(n)*sizeof(INT16U));\n    for (i=ave=max=0; i<n; i++){\n        fscanf(file, \"%hd\",  &A[i]);\n        if (max<A[i])\n            max=A[i];\n        ave+=A[i];\n    }\n    ave/=n;\n    C = malloc(succ(max)*sizeof(INT16U));\n    memset(C, 0, sizeof(INT16U)*succ(max));\n    CountingSort(A, B, n, max);\n    printf(\"%ld\\n\", mincostsort(A, n));\n#ifdef DESKTOP\n    for (i=0; i<n; i++){\n        if (i) printf(\" \");\n        printf(\"%hd\", A[i]);\n    }\n    printf(\"\\n\");\n#endif\n    free(A);\n    free(B);\n    free(C);\n}\n//============================================================================\n#ifndef DESKTOP\nint main()\n{\n    input(stdin);\n    return 0;\n}\n#endif"
  },
  {
    "language": "C",
    "code": "//?????´???????????????????°??????????(min)?????´????????¬??\\????????¨??????????????????\n//??????????????????min??????????°??????????(s0)??¨????????????min?????£?????????s0??§??????????????????????????????min??¨s0???????????????????????????????????????????????´??????????????????????????????????????????????????????\n#include<stdio.h>\n#include<limits.h>\n\nvoid swap(int *a, int *b){\n\tint temp = *a;\n\t*a = *b;\n\t*b = temp;\n\treturn;\n}\n\nvoid show(int A[], int n){\n\tint i;\n\tfor( i = 0; i < n; i++ ){ printf(\"%5d\", A[i]); }\n\tprintf(\"\\n\");\n\treturn;\n}\n\nvoid merge(int A[], int left, int mid, int right){\n\tint n1 = mid - left;\n\tint n2 = right - mid;\n\tint L[n1+1], R[n2+1];\n\tint i, j, k;\n\tfor( i = 0; i < n1; i++ ){ L[i] = A[left+i]; }\n\tfor( i = 0; i < n2; i++ ){ R[i] = A[mid+i]; }\n\tL[n1] = INT_MAX;\n\tR[n2] = INT_MAX;\n\ti = 0;\n\tj = 0;\n\tfor( k = left; k < right; k++ ){\n\t\tif( L[i] <= R[j] ){\n\t\t\tA[k] = L[i++];\n\t\t}else{\n\t\t\tA[k] = R[j++];\n\t\t}\n\t}\n\treturn;\n}\n\nvoid mergeSort(int A[], int left, int right){\n\tif( left+1 <  right ){\n\t\tint mid = (left + right) / 2;\n\t\tmergeSort(A, left, mid);\n\t\tmergeSort(A, mid, right);\n\t\tmerge(A, left, mid, right);\n\t}\n\treturn;\n}\n\nint minimumCostSort(int A[], int sorted[], int n){\n\tint i, j;\n\tint min, minj, target, targetj;\n\tint cost = 0, addCost, addCost2;\t//???????????????????´????????????????min?????£?????????s0???????????´??????????????????\n\tfor( i = 0; i < n; i++ ){\n\t\tmin = sorted[i];\n\t\t//sorted???i?????????????´????A??????????????????(minj)????????????\n\t\tfor( j = 0; j < n; j++ ){\n\t\t\tif( A[j] == min ){\n\t\t\t\tminj = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\taddCost = 0;\n\t\taddCost2 = 2 * (A[minj] + sorted[0]);\n\t\twhile( minj != i ){\n\t\t\ttarget = sorted[minj];\n\t\t\tfor( j = 0; j < n; j++ ){\n\t\t\t\tif( A[j] == target ){\n\t\t\t\t\ttargetj = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\taddCost += A[minj] + A[targetj];\n\t\t\taddCost2 += sorted[0] + A[targetj];\n\t\t\tswap(&A[minj], &A[targetj]);\n\t\t\tminj = targetj;\n\t\t\t//show(A, n);\n\t\t}\n\t\t//?????????????????????????????????\n\t\tcost += (addCost<addCost2?addCost:addCost2);\n\t}\n\treturn cost;\n}\n\nint main(){\n\tint n, i;\n\tint w[1000], sorted[1000];\n\tscanf(\"%d\", &n);\n\tfor( i = 0; i < n; i++ ){\n\t\tscanf(\"%d\", &w[i]);\n\t\tsorted[i] = w[i];\n\t}\n\tmergeSort(sorted, 0, n);\n\t//show(w, n);\n\t//show(sorted, n);\n\tprintf(\"%d\\n\", minimumCostSort(w, sorted, n));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define vMAX 10001\n#define INF (1<<30)\n#define min(a,b) (a<b? a:b)\nint n;\n\nint A[1000],B[1000],L[550],R[550],sortedPos[vMAX], visited[1000];\n\n//{{{ merge\nvoid merge(int* A, int l, int mid, int r){\n\tint n1,n2,i,j,k;\n\tn1=mid-l;\tn2=r-mid;\n\tfor(i=0;i<n1;i++){\n\t\tL[i]=A[l+i];\n\t}\n\tfor(int i=0;i<n2;i++){\n\t\tR[i]=A[mid+i];\n\t}\n\tL[n1]=R[n2]=INF;\n\n\ti=j=0;\n\tfor(k=l;k<r;k++){\n\t\tif(L[i]<=R[j]){\n\t\t\tA[k]=L[i++];\n\t\t}else{\n\t\t\tA[k]=R[j++];\n\t\t}\n\t}\n}\n\nvoid MergeSort(int* A, int l, int r){\n\tint mid;\n\tif(r-l>1){\n\t\tmid=(l+r)/2;\n\t\tMergeSort(A,l,mid);\n\t\tMergeSort(A,mid,r);\n\t\tmerge(A,l,mid,r);\n\t}\n}\n\n//}}}\n\nint main(){\n\tint i,now,sum,cnt,m,smallest=INF,ans=0;\n\tfor(i=0;i<vMAX;i++)sortedPos[vMAX]=-1;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&A[i]);\n\t\tsmallest=min(A[i],smallest);\n\t\tB[i]=A[i];\n\t}\n\tMergeSort(B,0,n);\n\tfor(i=0;i<n;i++){\n\t\tsortedPos[B[i]]=i;\n\t}\n\n\t\n\tfor(int i=0;i<n;i++){\n\t\tnow=i;\tsum=0;\tcnt=0;\tm=INF;\n\t\tif(visited[now])continue;\n\t\twhile(1){\n\t\t\t//printf(\"%d->\",A[now]);\n\t\t\tvisited[now]=1;\n\t\t\tsum+=A[now];\tcnt++;\n\t\t\tm=min(m,A[now]);\n\n\t\t\tnow=sortedPos[A[now]];\n\t\t\tif(visited[now])break;\n\t\t}\n\t\t//printf(\"\\n\");\n\t\t/*\n\t\t\tA:sum+(cnt-2)*m\n\n\t\t\tB:sum+(cnt-2)*m\n\t\t\t\t+2*(smallest+m)\n\t\t\t\t\t-(cnt-1)(m-smallest)\n\n\t\t\t\t=sum+(cnt+1)*smallest + m\n\t\t*/\n\t\tans+=min(sum+(cnt-2)*m, sum+(cnt+1)*smallest+m);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint cost;\n\nint sort(int *A,int n){\n  int i,j;\n  int tmp;\n  int min=1000,max=0;\n  int im,iM;\n  for(i=0;i<n-1;i++){\n    if(A[i]>max){\n      max=A[i];\n      iM=i;\n    }\n  }\n  for(i=1;i<n;i++){\n    if(A[i]<min){\n      min=A[i];\n      im=i;\n    }\n  }\n  //printf(\"%d %d\\n\",im,iM); \n    if(iM>im || im<0) return 1;\n    tmp=A[im];\n    A[im]=A[iM];\n    A[iM]=tmp;\n\n    cost=cost+max+min;\n    sort(&A[0],n);\n\n}\nint main(){\n  \n  int i,n,a;\n  int A[1000];\n  cost=0;\n  scanf(\"%d\",&n);\n\n  for(i=0;i<n;i++) scanf(\"%d\",&A[i]);\n  a=sort(&A[0],n);\n  \n  printf(\"%d\\n\",cost);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint cost;\n\nvoid swap(int *,int,int);\nvoid Quicksort(int *,int,int);\nint Partition(int *,int,int);\n\nint main(){\n\n  int W[1000],W2[1000],i,j,n;\n  int min = 100000000;\n\n  //入力作業\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)  scanf(\"%d\",&W[i]);\n\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++) W2[j]=W[j];\n    swap(W2,i,n-1);\n\n    cost=0;\n    Quicksort(W2,0,n-1);\n    if( cost < min) min=cost; \n  }\n  printf(\"%d\\n\",cost);\n}\n\n\n\nvoid swap(int *n,int p,int q){\n  int box;\n  \n  box = n[p];\n  n[p]=n[q];\n  n[q]=box;\n}\n\nvoid Quicksort(int *n,int p,int r){\n  int q;\n  if(p < r){\n    q = Partition(n,p,r);\n    Quicksort(n,p,q-1);\n    Quicksort(n,q+1,r);\n  }\n\n}\n\nint Partition(int *n,int p,int r){\n  int i,j,x;\n  \n  x=n[r];\n  j=p-1;\n  \n  for(i=p;i<r;i++){\n    if( n[i] <= x){\n      j++;\n      swap(n,j,i);\n    }\n  }\n  if(j + 1 != r) cost+=(n[j+1] + n[r]);\n  swap(n,j+1,r);\n  \n  return j+1;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n \n#define MAX  1000\n#define WIMAX 10000\n \nint n, a[MAX], s;\nint b[MAX], T[WIMAX + 1];\n \n \nint partition(int a[], int p, int r){\n  int i, j;\n  int t, x;\n  x = a[r];\n  i = p - 1;\n \n  for(j = p ; j < r ; j++){\n    if(a[j] <= x){\n      i++;\n      t = a[i];\n      a[i] = a[j];\n      a[j] = t;\n    }\n  }\n \n  t = a[i + 1];\n  a[i + 1] = a[r];\n  a[r] = t;\n \n  return i + 1;\n}\nvoid quickSort(int a[], int p, int r){\n  int q;\n  if(p < r){\n    q = partition(a, p, r);\n    quickSort(a, p, q - 1);\n    quickSort(a, q + 1, r);\n  }\n}\n\n    \nint solve(){\n  int i, cur, S, m, an, v,   ans = 0 ;\n \n  int V[MAX];\n  for(i = 0 ; i < n ; i++){\n    b[i] = a[i];\n    V[i] = 0;\n  }\n \n  quickSort(b, 0, n - 1);\n \n  for(i = 0 ; i < n ; i++) T[b[i]] = i;\n  for(i = 0 ; i < n ; i++){\n    if(V[i]) continue;\n    cur = i;\n    S = 0;\n    m = WIMAX;\n    an = 0;\n    while(1){\n      V[cur] = 1;\n      an++;\n      v = a[cur];\n \n      if(v < m) m = v;\n \n      S += v;\n      cur = T[v];\n      if(V[cur]) break;\n    }\n    if(S + (an -2) * m < m + S + (an + 1) * s) ans += S + (an -2) * m;\n    else ans +=  m + S + (an + 1) * s;\n  }\n  return ans;\n}\n \n        \n    \nint main(){\n  int i;\n \n  scanf(\"%d\", &n);\n  s = WIMAX;\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\", &a[i]);\n    if(a[i] < s) s = a[i];\n}\n \n  int ans = solve();\n  printf(\"%d\\n\", ans);\n \n  return 0;\n}\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n    \n    \n    \nint n,cost;\nint A[1001],B[1001];\nint L[501],R[502];\n    \n\nvoid M(int left,int mid,int right);\nvoid MS(int left,int right);\nvoid swap(int a,int b,int *C);\n\n\nint n,cost, A[1001],B[1001],L[501],R[502];\n    \nint main(){\n  scanf(\"%d\",&n);\n  int i,j;\n  int cnt,sum,min,start,x;\n  int C[1001]={};\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n  MS(0,n);\n  for(i=0;i<n;i++){\n    if(A[i]==B[i]) C[i]=1;\n  }\n  cost=0;\n  for(i=0;i<n;i++){\n    if(C[i]!=1){\n      C[i]=1;\n      cnt=0;\n      sum=0;\n      min=B[i];\n      x=i;\n      while(1){\n        for(j=0;j<n;j++){\n          if(B[x]==A[j]){\n            C[j]=1;\n            cnt++;\n            sum+=B[j];\n            if(min > B[j]) min=B[j];\n            x=j;\n            break;\n          }\n        }\n        if(x==i) break;\n      }\n      sum-=min;\n      if( (cnt -1)*min > (cnt -1)*A[0]+2*(min +A[0])) cost+=sum+(cnt-1)*A[0]+2*(min +A[0]);\n      else cost+=sum+(cnt-1)*min;\n    }\n  }\n  printf(\"%d\\n\",cost);\n  return 0;\n}\n\n\nvoid M(int left,int mid,int right){\n  int i,j,n1=mid-left,n2=right-mid;\n  for(i=0;i<n1;i++) L[i]=A[left+i];\n  L[n1]=INT_MAX;\n  for(i=0;i<n2;i++) R[i]=A[mid+i];\n  R[n2]=INT_MAX;\n  int l=0,r=0;\n  for(i=left;i<right;i++){\n    if(L[l]<=R[r]){\n      A[i]=L[l];\n      l++;\n    }\n    else{\n      A[i]=R[r];\n      r++;\n    }\n  }\n}\n\n\nvoid MS(int left,int right){\n  int mid;\n  if( left+1 >= right) return;\n  mid=(left+right)/2;\n  MS(left,mid);\n  MS(mid,right);\n  M(left,mid,right);\n}\n\nvoid swap(int a,int b,int *C){\n  int swap;\n  swap=C[a];\n  C[a]=C[b];\n  C[b]=swap;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main() {\n  /* a[0] to a[n-1] is the array to sort */\n  int i,j;\n  int n, swapTotal = 0;\n\n  scanf(\"%d\", &n);\n\n  int a[n];\n\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n\n  /* advance the position through the entire array */\n  /*   (could do j < n-1 because single element is also min element) */\n  for (j = 0; j < n-1; j++)  {\n      /* find the min element in the unsorted a[j .. n-1] */\n\n      /* assume the min is the first element */\n    int iMin = j;\n      /* test against elements after j to find the smallest */\n    for (i = j+1; i < n; i++) {\n          /* if this element is less, then it is the new minimum */\n      if (a[i] < a[iMin]) {\n        /* found new minimum; remember its index */\n        iMin = i;\n      }\n    }\n\n    if (iMin != j) {\n      int temp = a[j];\n      a[j] = a[iMin];\n      a[iMin] = temp;\n      swapTotal += a[j] + a[iMin];\n    }\n  }\n\n  printf(\"%d\\n\", swapTotal);\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n\n\n\nint n,cost;\nint A[1001],B[1001];\nint L[501],R[502];\n\n\nvoid merge(int left,int mid,int right){\n  int i,j,n1=mid-left,n2=right-mid;\n  for(i=0;i<n1;i++) L[i]=A[left+i];\n  L[n1]=INT_MAX;\n  for(i=0;i<n2;i++) R[i]=A[mid+i];\n  R[n2]=INT_MAX;\n  int l=0,r=0;\n  for(i=left;i<right;i++){\n    if(L[l]<=R[r]){\n      A[i]=L[l];\n      l++;\n    }\n    else{\n      A[i]=R[r];\n      r++;\n    }\n  }\n}\n\n\nvoid m_sort(int left,int right){\n  int mid;\n  if( left+1 >= right) return;\n  mid=(left+right)/2;\n  m_sort(left,mid);\n  m_sort(mid,right);\n  merge(left,mid,right);\n}\n\n\nvoid swap(int a,int b,int *C){\n  int swap;\n  swap=C[a];\n  C[a]=C[b];\n  C[b]=swap;\n}\n\n\n/*??£????????´??????????????°???????????§????°??????????????????¢?????????????????????*/\nint min_search(int *C){\n  int res=n,i;\n  C[n]=INT_MAX;\n  for(i=0;i<n;i++){\n    if(A[i]!=C[i]){\n      if(C[res] >C[i]) res =i;\n    }\n  }\n  return res;\n}\n\n\n\n\n\n\nint quest(int *C,int num){\n  int D[1001],E[1001],i,x,ans,ans2;\n  for(i=0;i<n;i++){\n    D[i]=C[i];\n    E[i]=C[i];\n  }\n  x=min_search(C);\n  if(x==n) return num;\n  i=0;\n  while(1){\n    if(D[i]==A[x]){\n      swap(i,x,D);\n      ans=quest(D,num+D[i]+D[x]);\n      break;\n    }\n    i++;  \n  }\n  if(E[x]!=A[0]){\n    swap(0,x,E);\n    ans2=quest(E,num+E[0]+E[x]);\n    if(ans > ans2) ans=ans2;\n  }\n  return ans;\n}\n  \n \n  \n\nint main(){\n  scanf(\"%d\",&n);\n  int i,j,min=n;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n  m_sort(0,n);\n  cost=0;\n  for(i=0;i<n;i++){\n    for(j=i+1;j<n;j++){\n      if(B[i]==A[j]){\n        if(B[j]==A[i]){\n          swap(i,j,B);\n          cost+=B[i]+B[j];\n        }\n        break;\n      }\n    } \n  }\n  while(1){\n    if(min==n) min=min_search(B);\n    if(B[min]!=A[0]){\n      break;\n    }\n    else{\n      if(min==n) break;\n      for(i=0;i<n;i++){\n        if(A[min]==B[i]){\n          if(min==i){\n            min=n;\n            break;\n          }\n          swap(min,i,B);\n          cost+=B[min]+B[i];\n          min=i;\n          break;\n        }\n      }\n    }\n  }\n  cost=quest(B,cost);\n  printf(\"%d\\n\",cost);\n  return 0;\n}\n   \n          \n          \n    "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nvoid swap(int *A, int i, int j) {\n  int temp;\n  temp = A[i];\n  A[i] = A[j];\n  A[j] = temp;\n}\n\nvoid Merge(int *A, int left, int mid, int right) {\n  int n1,n2,*L,*R,i,j,k;\n  n1 = mid -left;\n  n2 = right - mid;\n  L = (int*)malloc(sizeof(int) * (n1+1));\n  R = (int*)malloc(sizeof(int) * (n2+1));\n  for (i = 0; i< n1; i++) {\n    L[i] = A[left+i];\n  }\n  for (i = 0; i < n2; i++) {\n    R[i] = A[mid+i];\n  }\n  L[n1] = INT_MAX; R[n2] = INT_MAX;\n  i = 0;j = 0;\n  for(k = left; k < right; k++) {\n    if (L[i] < R[j]) {\n      A[k] = L[i];\n      i++;\n    }else {\n      A[k] = R[j];\n      j++;\n    }\n  }\n  free(L);\n  free(R);\n}\n\nvoid Merge_Sort(int *A, int left, int right) {\n  if(left+1 < right) {\n    int mid = (left + right)/2;\n    Merge_Sort(A,left,mid);\n    Merge_Sort(A,mid,right);\n    Merge(A,left,mid,right);\n  }\n}\n\nlong clime_sort(int *w, int *w1, int n, char *check, int i) {\n  int j,k;\n  long sum,min,v;\n  sum = 0;\n  if(w[i] != w1[i]) {\n    k = 0;\n    while(w1[i] != w[k]) k++;\n    sum += w[i] + w[k];\n    swap(w,i,k);\n  }\n  check[i] = 1;\n  min = LONG_MAX;\n  for (j = 0; j < n; j++) {\n    if(check[j] == 0) {\n      v = clime_sort(w,w1,n,check,j);\n      if(min > v) min = v;\n    }\n  }\n  if(min == LONG_MAX) min = 0;\n  if(sum > 0) swap(w,i,k);\n  check[i] = 0;\n  return min+sum;\n}\n\nlong min_sort(int *w, int *w1, int n) {\n  int i;\n  char *checked;\n  long v,min;\n  checked = (char*)calloc(n,sizeof(char));\n  min = LONG_MAX;\n  for (i = 0; i < n; i++) {\n    v = clime_sort(w,w1,n,checked,i);\n    if(min > v) min = v;\n  }\n  return min;\n}\n\nint main()\n{\n  int i,n,*w,*w2;\n  long sum;\n  scanf(\"%d\",&n);\n  w = (int*)malloc(sizeof(int) * n);\n  w2 = (int*)malloc(sizeof(int) * n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\",w+i);\n    w2[i] = w[i];\n  }\n  Merge_Sort(w2,0,n);\n  \n  sum = min_sort(w,w2,n);\n  printf(\"%ld\\n\",sum);\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 1000\n\nint n, i, j, sum, minj, count;\nint A[MAX], B[MAX], C[MAX];\n\nint min(int x, int y)\n{\n  if(x < y) return x;\n  else return y;\n}\n\nint solve(int x)\n{\n  for(i = 0; i < n; i++){\n    if(A[i] == x) return i;\n  }\n}\n\nint main()\n{\n  int ans = 0, x, tmp;\n\n  scanf(\"%d\", &n);\n\n  for(i = 0; i < n; i++){\n    scanf(\"%d\", &A[i]);\n    B[i] = A[i];\n  }\n\n  for(i = n - 1; i > 0; i--){\n    for(j = 0; j < i; j++){\n      if(B[j + 1] < B[j]){\n        tmp = B[j];\n        B[j] = B[j + 1];\n        B[j + 1] = tmp;\n      }\n    }\n  }\n\n  for(i = 0; i < n; i++){\n    C[i] = 0;\n  }\n\n  for(i = 0; i < n; i++){\n    x = i;\n    count = 0;\n    sum = 0;\n    minj = (1 << 24);\n    while(C[x] == 0){\n      C[x] = 1;\n      count++;\n      sum += A[x];\n      minj = min(minj, A[x]);\n      x = solve(B[x]);\n    }\n    if(count < 2) continue;\n    ans += min(sum + B[0] * (count + 1) + minj, sum + minj * (count - 2));\n\n  }\n\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n  \nvoid swap(int* a,int* b){\n  int tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\n  \nint n;\nint a[1000];\nint b[1000];\nint vd[1000];\nint cnt,sum,mini;\n  \nint min(int x,int y){\n  if(x<y)return x;\n  else return y;\n}\n  \nint search(int x){\n  int i;\n  for(i=0;i<n;i++)if(a[i]==x) return i;\n}\n  \nint main(){\n  int i,j,ans,x;\n  \n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&a[i]);\n    b[i]=a[i];\n  }\n  \n  for(i=n-1;i>0;i--)\n    for(j=0;j<i;j++)\n      if(B[j]>B[j+1])swap(&b[j],&b[j+1]);\n    \n  ans=0;\n  for(i=0;i<n;i++)vd[i]=0;\n  \n  for(i=0;i<n;i++){   \n    x=i;\n    cnt=sum=0;\n    mini=(1<<24);\n    while(vd[x]==0){\n      vd[x]=1;\n      cnt++;\n      sum+=a[x];\n      mini=min(mini,a[x]);\n      x=search(b[x]);\n    }\n    if(cnt<2)continue;\n    ans+=min(sum+b[0]*(cnt+1)+mini,sum+mini*(cnt-2));\n  \n  }\n  \n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n \n#define MAX 1000\n\nstruct MCS {\n\tint cost;\n\tint order;\n};\n\nvoid exchange( struct MCS *pa, struct MCS *pb )\n{\n   \tstruct MCS t;\n     \n\tt=*pa;\n\t*pa=*pb;\n\t*pb=t;\n\t \n\t return;\n}\n \nint Partition( struct MCS A[], int p, int r )\n{\n    struct MCS x;\n    int i,j;\n \n    x=A[r];\n    i=p-1;\n    for( j=p; j<r; j++ ) {\n        if( A[j].cost < x.cost ) {\n            i++;\n            exchange( &A[i], &A[j] );\n         }\n    }\n    exchange( &A[i+1], &A[r] );\n\n    return i+1;\n}\nvoid QuickSort( struct MCS A[], int p, int r )\n{\n    int q;\n     \n    if( p < r ) {\n        q=Partition( A, p, r );\n        QuickSort( A, p, q-1 );\n        QuickSort( A, q+1, r );\n    }\n    return;\n}\n\nint main( void ) \n{   \n    int n,i;\n    struct MCS W[MAX+1];\n    int cnt;\n        \n    scanf( \"%d\", &n );\n    for( i=0; i<n; i++ ) {\n        scanf( \"%d\", &W[i].cost );\n        W[i].order=i;\n    }\n    QuickSort( W, 0, n-1 );\n    \n    cnt=0;    \n    for( i=0; i<n; i++ ) {\n    \tif( i != W[i].order ) {\n    \t\tcnt+=W[i].cost;\n        }\n    }\n    printf( \"%d\\n\", cnt );\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#define true 1\n#define false 0\n#define MAX 1000\n#define VMAX 10000\n\nint n , A[MAX] , s;\nint B[MAX] , T[VMAX+1];\n\nvoid sort(int C[])\n{\n\tint flag = 1;\n\tint tmp;\n\twhile(flag == 1)\n\t{\n\t\tflag = 0;\n\t\tfor( int j = n-1; j >= 1; j--)\n\t\t{\n\t\t\tif(C[j] < C[j-1])\n\t\t\t{\n\t\t\t\ttmp = C[j];\n\t\t\t\tC[j] = C[j-1];\n\t\t\t\tC[j-1] = tmp;\n\t\t\t\tflag = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint min(int a , int b)\n{\n\tif(a < b) return a;\n\telse return b;\n}\n\nint solve()\n{\n\tint ans = 0;\n\t\n\tbool V[MAX];\n\tfor( int i = 0; i < n; i++)\n\t{\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B);\n\tfor( int i = 0; i < n; i++) T[B[i]] = i;\n\tfor( int i = 0; i < n; i++) {\n\t\tif(V[i])continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile(1){\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m,v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif(V[cur])break;\n\t\t}\n\t\tans += min(S+(an-2)*m,m+S+(an+1)*s);\n\t}\n\treturn ans;\n}\n\nint main(void)\n{\n\tscanf(\"%d\",&n);\n\ts = VMAX;\n\tfor( int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\",&A[i]);\n\t\ts = min(s,A[i]);\n\t}\n\tint ans = solve();\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX 1000\n#define INF INT_MAX\n\nint solve(int*, int);\nint check(int*,int);\n\nint main(){\n  int n, i, arr[MAX];\n\n  scanf(\"%d\" ,&n);\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\" ,arr + i);\n    arr[i]--;\n  }\n  printf(\"%d\\n\" ,solve(arr, n));\n\n  return 0;\n}\n\nint check(int arr[], int n){\n  int i;\n\n  for(i = 0 ; i < n ; i++){\n    if(arr[i] != i){\n      return 0;\n    }\n  }\n  return 1;\n}\n\nint solve(int arr[], int n){\n  int i, j, res = 0, tmp, pos, min = INF;\n\n  for(i = 0 ; i < n-1 ; i++){\n    if(arr[i] != i){\n      for(j = i+1 ; j < n ; j++){\n        if(arr[j] != j && arr[i] == j && arr[j] == i){\n          res += arr[i] + arr[j] + 2;     \n          tmp = arr[i];\n          arr[i] = arr[j];\n          arr[j] = tmp;\n        }\n      }\n    }\n  }\n\n  for(i = 0 ; i < n-1 ; i++){\n    if(arr[i] != i){\n      pos = -1;\n      for(j = i+1 ; j < n ; j++){\n        if(arr[j] != j){\n          if(arr[i] + arr[j] + 2 < min){\n            min = arr[i] + arr[j] + 2;      \n            pos = j;\n          }\n        }\n      }\n\n      if(pos != -1){\n        res += arr[i] + arr[pos] + 2;\n        tmp = arr[i];\n        arr[i] = arr[pos];\n        arr[pos] = tmp;\n      }\n    }\n  }\n\n  if(check(arr, n)){\n    return res;\n  }else{\n    return res += solve(arr, n);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint n;\n\nint search(int *A, int w);\n\nint main(int argc, char *argv[])\n{\n  int i, j, k, l, t;\n  int *A, *R, *g, tmp, g_minj, minj, change, g_minw;\n  int cost = 0;\n\n  scanf(\"%d\", &n);\n  A = (int *)malloc(sizeof(int) * n);\n  R = (int *)malloc(sizeof(int) * n);\n  g = (int *)malloc(sizeof(int) * n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &A[i]);\n    R[i] = A[i];\n    g[i] = 0;\n  }\n\n  for (i = 0; i < n; i++) {\n    minj = i;\n    for (j = i; j < n; j++) {\n      if (R[minj] > R[j]) minj = j;\n    }\n    tmp = R[minj];\n    R[minj] = R[i];\n    R[i] = tmp;\n  }\n\n  for (i = 0; i < n; i++) {\n    if (A[i] == R[i]) continue;\n\n    g_minj = i;\n    g[0] = i;\n    k = 1;\n    j = i;\n    while (A[j] != R[i]) {\n      j = search(R, A[j]);\n      if (A[j] < A[g_minj]) g_minj = j;\n      g[k++] = j;\n    }\n    g_minw = A[g_minj];\n    l = search(g, g_minj);\n\n    minj = search(A, R[0]);\n\n    if (k >= 4) {\n      if ((k+1) * A[minj] < (k-3) * A[g_minj]) change = 1;\n      else change = 0;\n    } else change = 0;\n\n    if (change == 1) {\n      cost += A[g_minj] + A[minj];\n      tmp = A[g_minj];\n      A[g_minj] = A[minj];\n      A[minj] = tmp;\n    }\n\n    for (j = k; j > 1; j--) {\n      t = (l + j - 1) % k;\n      cost += A[g[t]] + A[g[t+1]];\n      tmp = A[g[t+1]];\n      A[g[t+1]] = A[g[t]];\n      A[g[t]] = tmp;\n    }\n\n    if (change == 1) {\n      g_minj = search(A, g_minw);\n      minj = search(A, R[0]);\n      cost += A[g_minj] + A[minj];\n      tmp = A[g_minj];\n      A[g_minj] = A[minj];\n      A[minj] = tmp;\n    }\n  }\n\n  printf(\"%d\\n\", cost);\n\n  return 0;\n}\n\nint search(int *A, int w)\n{\n  int i;\n  int found;\n\n  found = 0;\n  for (i = 0; i < n; i++) {\n    if (A[i] == w) {\n      found = 1;\n      break;\n    }\n  }\n\n  if (found == 1) return i;\n  else return -1;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define NOT_CHECK 0\n#define CHECK 1\n\ntypedef struct element_ {\n\tint idx, val;\n} element;\n\nint element_sort(void *a, void *b) {\n\treturn (*(element*)a).val - (*(element*)b).val;\n}\n\nint main(void) {\n\tint i, n, costs;\n\tint A[1005];\n\tint W[10005];\n\tint chk[1005];\n\telement sortedA[1005];\n\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%d\\n\", &A[i]);\n\t\tsortedA[i].idx = i;\n\t\tsortedA[i].val = A[i];\n\t\tchk[i] = NOT_CHECK;\n\t}\n\n\tqsort((void*)sortedA, n, sizeof(element), element_sort);\n\t// 荷物の重さから元々の位置を取得できるように値を設定\n\tfor(i=0;i<n;i++) W[sortedA[i].val] = i;\n\n\tfor(i=0;i<n;i++) {\n\t\tint p, cost, min;\n\t\tp = sortedA[i].idx;\n\t\tmin = sortedA[i].val;\n\n\t\tif(sortedA[i].idx == i) {\n\t\t\t// ソート後と同じ位置のため入れ替える必要がない\n\t\t\tchk[i] = CHECK;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// 軽い荷物を使って、正しい場所に入れ替えていく\n\t\tcost = 0;\n\t\twhile(!chk[p]) {\n\t\t\tchk[p] = CHECK;\n\t\t\tcost = cost + A[p] + min;\n\t\t\tp = W[A[p]];\n\t\t}\n\t\tcosts += cost;\n\t}\n\n\tprintf(\"%d\\n\", costs);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "//?????´???????????????????°???????????????´????????¬??\\????????¨??????????????????\n#include<stdio.h>\n#include<limits.h>\n\nvoid swap(int *a, int *b){\n\tint temp = *a;\n\t*a = *b;\n\t*b = temp;\n\treturn;\n}\n\nvoid show(int A[], int n){\n\tint i;\n\tfor( i = 0; i < n; i++ ){ printf(\"%5d\", A[i]); }\n\tprintf(\"\\n\");\n\treturn;\n}\n\nvoid merge(int A[], int left, int mid, int right){\n\tint n1 = mid - left;\n\tint n2 = right - mid;\n\tint L[n1+1], R[n2+1];\n\tint i, j, k;\n\tfor( i = 0; i < n1; i++ ){ L[i] = A[left+i]; }\n\tfor( i = 0; i < n2; i++ ){ R[i] = A[mid+i]; }\n\tL[n1] = INT_MAX;\n\tR[n2] = INT_MAX;\n\ti = 0;\n\tj = 0;\n\tfor( k = left; k < right; k++ ){\n\t\tif( L[i] <= R[j] ){\n\t\t\tA[k] = L[i++];\n\t\t}else{\n\t\t\tA[k] = R[j++];\n\t\t}\n\t}\n\treturn;\n}\n\nvoid mergeSort(int A[], int left, int right){\n\tif( left+1 <  right ){\n\t\tint mid = (left + right) / 2;\n\t\tmergeSort(A, left, mid);\n\t\tmergeSort(A, mid, right);\n\t\tmerge(A, left, mid, right);\n\t}\n\treturn;\n}\n\nint minimumCostSort(int A[], int sorted[], int n){\n\tint i, j;\n\tint min, minj, target, targetj;\n\tint cost = 0, addCost = 0;\n\tint swaptimes = 0;\n\tfor( i = 0; i < n; i++ ){\n\t\tmin = sorted[i];\n\t\t//sorted???i?????????????´????A??????????????????(minj)????????????\n\t\tfor( j = 0; j < n; j++ ){\n\t\t\tif( A[j] == min ){\n\t\t\t\tminj = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\taddCost = 0;\n\t\twhile( minj != i ){\n\t\t\ttarget = sorted[minj];\n\t\t\tfor( j = 0; j < n; j++ ){\n\t\t\t\tif( A[j] == target ){\n\t\t\t\t\ttargetj = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\taddCost += A[minj] + A[targetj];\n\t\t\tswap(&A[minj], &A[targetj]);\n\t\t\tswaptimes++;\n\t\t\tminj = targetj;\n\t\t\tshow(A, n);\n\t\t}\n\t\t//????°???????????????£??????????????£????????????????????????????????????????????????????????????????????§?????????????????§?????????\n\t\tif( 2 * (sorted[i]+sorted[0]) + swaptimes * sorted[0] < addCost ){\n\t\t\tcost += 2 * (sorted[i]+sorted[0]) + swaptimes * sorted[0];\n\t\t}else{\n\t\t\tcost += addCost;\n\t\t}\n\t\tswaptimes = 0;\n\t}\n\treturn cost;\n}\n\nint main(){\n\tint n, i;\n\tint w[1000], sorted[1000];\n\tscanf(\"%d\", &n);\n\tfor( i = 0; i < n; i++ ){\n\t\tscanf(\"%d\", &w[i]);\n\t\tsorted[i] = w[i];\n\t}\n\tmergeSort(sorted, 0, n);\n\tshow(w, n);\n\tshow(sorted, n);\n\tprintf(\"\\n\");\n\tprintf(\"%d\\n\", minimumCostSort(w, sorted, n));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n#include <stdlib.h>         // qsort()\n#include <stdbool.h>\n\n#define MAX_N 1000\n#define MAX_V 10000\n#define min(a, b) ((a) < (b) ? a : b)\n\nint a[MAX_N];\nint n;\n\nint\ncmp_func(const void *l_, const void *r_)\n{\n\tconst int* l = (const int*) l_;\n\tconst int* r = (const int*) r_;\n\n\tif (*l < *r)\n\t\treturn -1;\n\n\tif (*l > *r)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nint\nsolve()\n{\n\tint b[MAX_N];\n\tint t[MAX_V + 1];\n\tbool v[MAX_N];\n\tint i;\n\n\tint ans = 0;\n\tfor (i = 0; i < n; ++i)\n\t{\n\t\tb[i] = a[i];\n\t\tv[i] = false;\n\t}\n\n\tqsort(b, n, sizeof(int), cmp_func);\n\tfor (i = 0; i < n; ++i)\n\t\tt[b[i]] = i;\n\n\tfor (i = 0; i < n; ++i)\n\t{\n\t\tif (v[i])\n\t\t\tcontinue;\n\n\t\tint cur = i;\n\t\tint s = 0;\n\t\tint m = MAX_V;\n\t\tint an = 0;\n\t\twhile (true)\n\t\t{\n\t\t\tv[cur] = true;\n\t\t\tan++;\n\t\t\tint u = a[cur];\n\t\t\tif (u < m)\n\t\t\t\tm = u;\n\n\t\t\ts += u;\n\t\t\tcur = t[u];\n\t\t\tif (v[cur])\n\t\t\t\tbreak;\n\t\t}\n\n\t\tans += min(s + (an - 2) * m, s + m + (an + 1) * b[0]);\n\t}\n\n\treturn ans;\n}\n\nint\nmain(int argc, char** argv)\n{\n\tint i;\n\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; ++i)\n\t\tscanf(\"%d\", &a[i]);\n\n\tprintf(\"%d\\n\", solve());\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n \nvoid swap(int* a,int* b){\n  int tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\n \nint n;\nint A[1000];\nint B[1000];\nint vd[1000];\nint cnt,sum,mini;\n \nint min(int x,int y){\n  if(x<y)return x;\n  else return y;\n}\n \nint search(int x){\n  int i;\n  for(i=0;i<n;i++)if(A[i]==x)return i;\n}\n \nint main(){\n  int i,j,ans,x;\n \n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n \n  for(i=n-1;i>0;i--)\n    for(j=0;j<i;j++)\n      if(B[j]>B[j+1])swap(&B[j],&B[j+1]);\n   \n  ans=0;\n  for(i=0;i<n;i++)vd[i]=0;\n \n  for(i=0;i<n;i++){   \n    x=i;\n    cnt=sum=0;\n    mini=(1<<24);\n    while(vd[x]==0){\n      vd[x]=1;\n      cnt++;\n      sum+=A[x];\n      mini=min(mini,A[x]);\n      x=search(B[x]);\n    }\n    if(cnt<2)continue;\n    ans+=min(sum+B[0]*(cnt+1)+mini,sum+mini*(cnt-2));\n \n  }\n \n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid qsort(int a[],int left,int right){\n\t\n\tint p=(left+right)/2;\n\tint pivot=a[p];\n\tint i,temp;\n\tif(left<right){\n\t\tp=left;\n\t\tpivot=a[p];\n\t\tfor(i=left+1;i<=right;i++){\n\t\t\tif(a[i]<pivot){\n\t\t\t\tp++;\n\t\t\t\ttemp=a[i];a[i]=a[p];a[p]=temp;//swap\n\t\t\t}\n\t\t}\n\t\ttemp=a[left];a[left]=a[p];a[p]=temp;//swap\n\t\tqsort(a,left,p-1);\n\t\tqsort(a,p+1,right);\n\t}\n\n}\n\nint search(int key,int a[],int n){\n\tint i;\n\tfor(i=0;i<n;i++){\n\t\tif(key==a[i])return i;\n\t}\n\t\n\treturn i;\n}\n\nint isVisited(int v[],int n){\n\tint i;\n\tfor(i=0;i<n;i++){\n\t\tif(v[i]!=1)return -1;\n\t}\n\treturn 1;\n}\n\t\nint min(int a,int b){\n\tif(a<b)return a;\n\treturn b;\n}\n\n\nint main(void){\n\tint n,i,j,minW,cost=0,w;\n\tint a[1000],b[1000],v[1000];\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tb[i]=a[i];\n\t\tv[i]=0;\n\t}\n\tqsort(b,0,n-1);\n\t\n\tfor(i=0;i<n;i++){\t\n\t\tint x=i;\n\t\tint sum=0;\n\t\tint count=0;\n\t\tminW=1000;\n\t\twhile(v[x]==0){\n\t\t\tv[x]=1;\n\t\t\tsum+=a[x];\n\t\t\tcount++;\n\t\t\tif(minW>a[x])minW=a[x];\n\t\t\tx=search(a[x],b,n);\n\t\t}\n\t\tif(count<2)continue;\n\t\t\n\t\tcost+=min(b[0]*(count+1)+sum+minW,sum+(count-2)*minW);\n\t\tif(isVisited(v,n)==1)break;\n\t}\n\t\n\tprintf(\"%d\\n\",cost);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "\t//\t????°???????????????????\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define DEF_ELEM_MAX 1000\n#define DEF_VMAX 10000\n\n//  ????°?????????????\n#ifndef min\n#define min(a, b)            (((a) < (b)) ? (a) : (b))\n#endif\n\nint A[DEF_ELEM_MAX];\nint B[DEF_ELEM_MAX];\nint VD[DEF_ELEM_MAX];\nint N;\n\n/////////////////////////////////////////////////////////////////////////////////\n//\n/////////////////////////////////////////////////////////////////////////////////\nint search(int x)\n{\n  int i;\n  for ( i = 0 ; i < N ; i++ ) {\n\t  if ( A[i] == x ) {\n\t\t  break;\n\t  }\n  }\n  return i;\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n//\n/////////////////////////////////////////////////////////////////////////////////\nint int_sort( const void * a , const void * b )\n{\n\tint p = *( int * )a;\n\tint q = *( int * )b;\n  if( p < q ) {\n    return -1;\n  }  else if( p == q  ) {\n    return 0;\n  }\n  return 1;\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n//\n/////////////////////////////////////////////////////////////////////////////////\nint sillysort( void )\n{\n\tint s;\n\tint cost = 0;\n\tint i;\n\tint amin;\n\tint sum;\n\tint n;\n\tint x;\n\n\t// init\n\ts = B[0];\n\t// compute\n\tfor ( i = 0 ; i < N ; i++ ) {\n\t\tx = i;\n\t\tn = sum = 0;\n\t\tamin = DEF_VMAX;\n\t\twhile ( VD[x] == 0 ) {\n\t\t\tVD[x] = 1;\n\t\t\tn++;\n\t\t\tsum += A[x];\n\t\t\tamin = min(amin, A[x]);\n\t\t\tx = search(B[x]);\n\t\t}\n\t\tif ( n > 1 ) { \n\t\t\tcost += min(sum+(n-2)*amin, sum+amin+(n+1)*s);\n\t\t}\n\t}\n\treturn cost;\n}\n/////////////////////////////////////////////////////////////////////////////////\n//\n/////////////////////////////////////////////////////////////////////////////////\nint main(void)\n{\n\tint i;\n\tint ans;\n//\n\tscanf(\"%d\", &N);\n\tfor ( i = 0 ; i < N ; i++ ) {\n\t\tscanf(\"%d\", &A[i] );\n\t\tB[i] = A[i];\n\t}\n\n\tqsort(B, N , sizeof( int ), int_sort );\n\n\tans = sillysort();\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define MAX 2000001\n#define VMAX 10000\n\nint main() {\n  unsigned short *A, *B;\n  \n  int C[VMAX+ 1];\n  int n, i, j;\n  scanf(\"%d\", &n);\n  \n  A = malloc(sizeof(short) * n + 1);\n  B = malloc(sizeof(short) * n + 1);\n  \n  for ( i = 0; i <= VMAX; i++ ) C[i] = 0;\n  \n  for ( i = 0; i < n; i++ ) {\n    scanf(\"%hu\", &A[i + 1]);\n    C[A[i + 1]]++;\n  }\n  \n  for ( i = 1; i <= VMAX; i++ ) C[i] = C[i] + C[i - 1];\n  \n  for ( j = 1; j <= n; j++ ) {\n    B[C[A[j]]] = A[j];\n    C[A[j]]--;\n  }\n  \n  for ( i = 1; i <= n; i++ ) {\n    if ( i > 1 ) printf(\" \");\n    printf(\"%d\", B[i]);\n  }\n  printf(\"\\n\");\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <string.h>\n\n#define MAX 1000\n#define INF INT_MAX\n\nint solve(int*, int);\nint check(int*,int);\n\nint used[MAX];\n\nint main(){\n  int n, i, arr[MAX];\n\n  scanf(\"%d\" ,&n);\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\" ,arr + i);\n  }\n  memset(used, 0, sizeof(used));\n  printf(\"%d\\n\" ,solve(arr, n));\n\n  return 0;\n}\n\nint check(int arr[], int n){\n  int i;\n\n  for(i = 0 ; i < n ; i++){\n    if(arr[i] != i+1){\n      return 0;\n    }\n  }\n  return 1;\n}\n\nint solve(int arr[], int n){\n  int i, j, res = 0, tmp, min = INF, pos, flg;\n\n  for(i = 0 ; i < n-1 ; i++){\n    flg = 0;\n    if(arr[i] == i+1){\n      used[i] = 1;\n      continue;\n    }\n\n    for(j = i+1 ; j < n ; j++){\n      if(arr[j] == j+1 || used[j]){\n        used[j] = 1;\n        continue;\n      }\n\n      pos = -1;\n      if(arr[i] == j+1 && arr[j] == i+1){\n        tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n        res += arr[i] + arr[j];\n        flg = 1;\n        break;\n      }else{\n        if(arr[i] + arr[j] < min){\n          min = arr[i] + arr[j];\n          pos = j;\n        }\n      }\n    }\n    if(pos != -1 && !flg){\n      tmp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = tmp;\n      res += arr[i] + arr[j];\n    }\n  }\n\n  if(check(arr, n)){\n    return res;\n  }else{\n    return res += solve(arr, n);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX_N  1000\n#define INF 200000001\n\nint Partition(int, int);\nvoid QuickSort(int, int);\nint Cost(int);\nvoid Swap(int, int);\nint MinimumCostOfSort(int);\n\nstruct rist\n{\n  int w;\n  int p;\n} typedef rist;\n\nrist A[MAX_N];\n\nint main()\n{\n\tint i;\n\tint n;\n\tint cost;\n\t\n\tscanf(\"%d\", &n);\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &A[i].w);\n\t\tA[i].p = i;\n\t}\n\t\n\tQuickSort(0, n - 1);\n\tcost = MinimumCostOfSort(n);\n\n\tprintf(\"%d\\n\", cost);\n\t\n\treturn 0;\n}\n\nint Partition(int p, int r)\n{\n  int i, j;\n  rist tmp;\n\n  i = p - 1;\n  for(j = p; j < r; j++)\n    {\n      if(A[j].w <= A[r].w)\n\t{\n\t  i = i + 1;\n\t  tmp = A[i];\n\t  A[i] = A[j];\n\t  A[j] = tmp;\n\t}\n    }\n  tmp = A[i + 1];\n  A[i + 1] = A[r];\n  A[r] = tmp;\n  \n  return i + 1;\n}\n\nvoid QuickSort(int p, int r)\n{\n  int q;\n\n  if(p < r)\n    {\n      q = Partition(p, r);\n      QuickSort(p, q - 1);\n      QuickSort(q + 1, r);\n    }\n}\n\nint Cost(int i)\n{\n\treturn A[i].w + A[A[i].p].w;\n}\n\nvoid swap(int i1, int i2)\n{\n\tint tmp;\n\t\n\ttmp = A[i2].p;\n\tA[i2].p = A[i1].p;\n\tA[i1].p = tmp;\n}\n\nint MinimumCostOfSort(int n)\n{\n\tint i, j;\n\tint mini;\n\tint swap_j;\n\tint cost = 0;\n\t\n\tfor(i = 0 ; i < n; i++)\n\t{\n\t\tmini = INF;\n\t\tfor(j = 0; j < n; j++)\n\t\t{\n\t\t\tif(Cost(j) < mini && j != A[j].p)\n\t\t\t{\n\t\t\t\tmini = Cost(j);\n\t\t\t\tswap_j = j;\n\t\t\t}\n\t\t}\n\t\tif(mini != INF)\n\t\t{\n\t\t\tcost += Cost(swap_j);\n\t\t\tswap(swap_j, A[swap_j].p);\n\t\t}\n\t}\n\n\treturn cost;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n\n\n\nint n,cost;\nint A[1001],B[1001];\nint L[501],R[502];\n\n\nvoid merge(int left,int mid,int right){\n  int i,j,n1=mid-left,n2=right-mid;\n  for(i=0;i<n1;i++) L[i]=A[left+i];\n  L[n1]=INT_MAX;\n  for(i=0;i<n2;i++) R[i]=A[mid+i];\n  R[n2]=INT_MAX;\n  int l=0,r=0;\n  for(i=left;i<right;i++){\n    if(L[l]<=R[r]){\n      A[i]=L[l];\n      l++;\n    }\n    else{\n      A[i]=R[r];\n      r++;\n    }\n  }\n}\n\n\nvoid m_sort(int left,int right){\n  int mid;\n  if( left+1 >= right) return;\n  mid=(left+right)/2;\n  m_sort(left,mid);\n  m_sort(mid,right);\n  merge(left,mid,right);\n}\n\n\nvoid swap(int a,int b,int *C){\n  int swap;\n  swap=C[a];\n  C[a]=C[b];\n  C[b]=swap;\n}\n\n\n/*??£????????´??????????????°???????????§????°??????????????????¢?????????????????????*/\nint min_search(int *C){\n  int res=n,i;\n  C[n]=INT_MAX;\n  for(i=0;i<n;i++){\n    if(A[i]!=C[i]){\n      if(C[res] >C[i]) res =i;\n    }\n  }\n  return res;\n}\n\n\n\n\n\n\nint quest(int *C,int num,int jud,int nokorii){\n  int D[1001],E[1001],i,x,ans,ans2,judd,nokori;\n  if(jud==n) x=min_search(C);\n  else x=jud;\n  if(x==n) return num;\n  for(i=0;i<n;i++){\n    D[i]=C[i];\n    E[i]=C[i];\n  }\n  i=0;\n  while(1){\n    if(D[i]==A[x]){\n      swap(i,x,D);\n      nokori=nokorii-1;\n      judd=i;\n      if(D[i]==A[i]){\n        judd=n;\n        nokori--;\n      }\n      ans=quest(D,num+D[i]+D[x],judd,nokori);\n      break;\n    }\n    i++;  \n  }\n  if(E[x]!=A[0] && nokorii>=5){\n    swap(0,x,E);\n    nokori=nokorii+2;\n    ans2=quest(E,num+E[0]+E[x],x,nokori);\n    if(ans > ans2) ans=ans2;\n  }\n  return ans;\n}\n  \n \n  \n\nint main(){\n  scanf(\"%d\",&n);\n  int nokori=n;\n  int i,j,min=n;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n  m_sort(0,n);\n  for(i=0;i<n;i++){\n    if(A[i]==B[i]) nokori--;\n  }\n  cost=0;\n  for(i=0;i<n;i++){\n    for(j=i+1;j<n;j++){\n      if(B[i]==A[j]){\n        if(B[j]==A[i]){\n          swap(i,j,B);\n          nokori-=2;\n          cost+=B[i]+B[j];\n        }\n        break;\n      }\n    } \n  }\n  while(1){\n    if(min==n) min=min_search(B);\n    if(B[min]!=A[0]){\n      break;\n    }\n    else{\n      if(min==n) break;\n      for(i=0;i<n;i++){\n        if(A[min]==B[i]){\n          if(min==i){\n            min=n;\n            break;\n          }\n          swap(min,i,B);\n          nokori--;\n          cost+=B[min]+B[i];\n          min=i;\n          break;\n        }\n      }\n    }\n  }\n  cost=quest(B,cost,n,nokori);\n  printf(\"%d\\n\",cost);\n  return 0;\n}\n   \n          \n          \n    "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<algorithm>\nstatic const int MAX = 10000;\nstatic const int VMAX = 100000;\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve(){\n    int i,ans = 0;\n    \n    bool V[MAX];\n    for(i=0;i<n;i++){\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B,B+n);\n    for(i=0;i<n;i++) T[B[i]] = i;\n    for(i=0;i<n;i++){\n        if(V[i]) continue;\n        int cur=i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while(1){\n            V[cur] = true;\n            an++\n            int v=A[cur];\n            m = min(m,v);\n            S+=v;\n            cur = T[v];\n            if(V[cur]) break;\n        }\n        ans += min(S+(an-2)*m,m+S+(an+1)*s);\n    }\n    return ans;\n}\n\nint main(){\n    int i;\n    scanf(\"%d\",&n);\n    s=VMAX;\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&A[i]);\n        s=min(s,A[i]);\n    }\n    int ans = solve();\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n \n#define MAX 1000\n#define MAXWEIGHTIJ 20000\n \nstruct MCS {\n    int cost;\n    int order;\n};\n \nvoid exchange( struct MCS *pa, struct MCS *pb )\n{\n    struct MCS t;\n      \n    t=*pa;\n    *pa=*pb;\n    *pb=t;\n      \n     return;\n}\n  \nint Partition( struct MCS A[], int p, int r )\n{\n    struct MCS x;\n    int i,j;\n  \n    x=A[r];\n    i=p-1;\n    for( j=p; j<r; j++ ) {\n        if( A[j].cost < x.cost ) {\n            i++;\n            exchange( &A[i], &A[j] );\n         }\n    }\n    exchange( &A[i+1], &A[r] );\n \n    return i+1;\n}\nvoid QuickSort( struct MCS A[], int p, int r )\n{\n    int q;\n      \n    if( p < r ) {\n        q=Partition( A, p, r );\n        QuickSort( A, p, q-1 );\n        QuickSort( A, q+1, r );\n    }\n    return;\n}\n \nint tryChange( int n, struct MCS W[] )\n{\n    int cnt;\n    int fixedcost,profit;\n    int from, to, togoal;\n     \n    int cost,lowestCost;\n    int i,j;\n    int lowW,lowestW;\n    int low,high,lowest;\n \n    lowestW=lowW=lowestCost=cost=MAXWEIGHTIJ;\n    lowest=high=low=-1;\n    for( i=0; i<n; i++ ) {\n        if( i != W[i].order && W[i].cost < lowW ) {\n            lowW=W[i].cost;\n            low=i;\n            for( j=0; j<n; j++ ) {\n                if( low == W[j].order ) {\n                    high=j;\n                    break;\n                }\n            }\n        }\n        if( W[i].cost < lowestW ) {\n            lowestW=W[i].cost;\n            lowest=i;  \n        }      \n    }\n \n    if( W[high].order == low && W[low].order == high ) {\n        lowestCost = W[low].cost + W[high].cost;\n    } else if( low != lowest ) {   \n        fixedcost = W[low].cost + W[lowest].cost;\n        profit = W[low].cost - W[lowest].cost;\n        from=high;\n        to=low;\n        togoal = W[low].order;\n        cnt=0;\n        while( 1 ) {\n            if( W[from].order == to ) {\n                if( togoal == to ) { break; }\n                to=from;\n                cnt++;\n            } else {\n                break;\n            }\n            for( i=0; i<n; i++ ) {\n                if( i != W[i].order ) {\n                    if( to == W[i].order ) {\n                        from=i;\n                        break;\n                    }\n                }\n            }\n        }\n        profit = ( profit * cnt ) - ( 2 * fixedcost );\n        if( 0 < profit ) {\n            high=low;\n            low=lowest;\n            lowestCost = fixedcost;\n        }\n    }\n    if( W[high].order == low ) {\n        lowestCost = W[low].cost + W[high].cost;\n    }\n \n    if( MAXWEIGHTIJ != lowestCost ) {\n        exchange( &W[low], &W[high] );\n    } else {\n        lowestCost=0;\n    }\n    return lowestCost;\n}\n \nint main( void )\n{  \n    int n,i;\n    struct MCS W[MAX+1];\n    int cost;\n         \n    scanf( \"%d\", &n );\n    for( i=0; i<n; i++ ) {\n        scanf( \"%d\", &W[i].cost );\n        W[i].order=i;\n    }\n \n    QuickSort( W, 0, n-1 );\n    cost=i=0;\n    while( (i = tryChange( n, W ) ) ) {\n        cost+=i;\n    }\n    printf( \"%d\\n\", cost );\n \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX 1000\n#define MAXWEIGHT 10000\n#define MAXWEIGHT2 20000\n\nstruct MCS {\n\tint cost;\n\tint order;\n};\n\nvoid exchange( struct MCS *pa, struct MCS *pb )\n{\n   \tstruct MCS t;\n     \n\tt=*pa;\n\t*pa=*pb;\n\t*pb=t;\n\t \n\t return;\n}\n \nint Partition( struct MCS A[], int p, int r )\n{\n    struct MCS x;\n    int i,j;\n \n    x=A[r];\n    i=p-1;\n    for( j=p; j<r; j++ ) {\n        if( A[j].cost < x.cost ) {\n            i++;\n            exchange( &A[i], &A[j] );\n         }\n    }\n    exchange( &A[i+1], &A[r] );\n\n    return i+1;\n}\nvoid QuickSort( struct MCS A[], int p, int r )\n{\n    int q;\n     \n    if( p < r ) {\n        q=Partition( A, p, r );\n        QuickSort( A, p, q-1 );\n        QuickSort( A, q+1, r );\n    }\n    return;\n}\nint tryChange( int n, struct MCS W[] )\n{\n\tint cnt,min;\n\tint i,j;\n\tint prei,prej;\n\tint hi,lo;\n\t\n\tprei=prej=0;\n\tmin=cnt=MAXWEIGHT2;\n    for( i=n-1; 0<i; i-- ) {\n    \tif( i != W[i].order ) {\n    \t\tlo=hi=i;\n    \t\tfor( j=0; j<n; j++ ) {\n    \t\t\tif(  W[i].order == j  ) {\n\t\t\t\t\tif( W[j].cost <= W[lo].cost ) {\n    \t\t\t\t\tlo=j;\t\t\t\t\n\t    \t\t\t\tcnt=W[j].cost+W[i].cost;\n\t\t\t    \t\tif( cnt < min ) {\n\t\t\t    \t\t\tmin=cnt;\n\t\t\t    \t\t\tprei=i;\n\t\t\t    \t\t\tprej=j;\n\t\t\t    \t\t}\n\t\t    \t\t}\n    \t\t\t}\n     \t\t}\n     \t\tif( W[i].order == prej  && W[prej].order == i ) { break; }\n        }\n    }\n\n    if( MAXWEIGHT2 != min ) {\n\t\texchange( &W[prej], &W[prei] );\n    } else {\n    \tmin=0;\n    }\n\n\treturn min;\n}\n\nint main( void ) \n{   \n    int n,i;\n    struct MCS W[MAX+1];\n    int cnt;\n        \n    scanf( \"%d\", &n );\n    for( i=0; i<n; i++ ) {\n        scanf( \"%d\", &W[i].cost );\n        W[i].order=i;\n    }\n\n    QuickSort( W, 0, n-1 );\n    cnt=i=0;\n    while( (i = tryChange( n, W ) ) ) {\n   \t\tcnt+=i;\n    }   \n    printf( \"%d\\n\", cnt );\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n\ntypedef struct Ans{\n  int x;\n  int y;\n}Ans;\n\nvoid Sort(int*,int,int);\nAns Cost_Sort(int*,int,int);\n\nint sum=0,c=0;\n\nmain(){\n  int i,n,*A;\n\n  scanf(\"%d\",&n);\n\n  A=(int *)malloc(sizeof(int)*n);\n\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n  }\n \n  Sort(A,0,n-1);\n\n  printf(\"%d\\n\",sum);\n\n  return 0;\n}\n\nvoid Sort(int *A,int i,int n){\n  Ans ans;\n\n  if(c<n){\n    ans=Cost_Sort(A,i,n);\n\n    Sort(A,ans.x,ans.y);\n  }\n}\n\nAns Cost_Sort(int *A,int i,int n){\n  int j,tmp,min=A[i],k=0,l=0,submin;\n  Ans ans;\n  c++;\n  for(j=i+1;j<=n;j++){\n    if(min>A[j]){\n      min=A[j];\n      k=j;\n    }\n  }\n\n  if(min==A[i]){\n    ans.x=i+1;\n    ans.y=n;\n    return ans;\n  }\n\n  if(min==A[n]){\n    sum+=A[i]+A[n];\n    tmp=A[i];\n    A[i]=A[n];\n    A[n]=tmp;\n    ans.x=i+1;\n    ans.y=n-1;\n    return ans;\n    \n  }\n  else{\n    submin=A[i];\n    for(j=i;j<=n;j++){\n      if(min<A[j] && submin>A[j] && k<j){\n\tsubmin=A[j];\n\tl=j;\n      }\n    }\n    if(min<submin){\n      sum+=A[k]+A[l];\n      tmp=A[l];\n      A[l]=A[k];\n      A[k]=tmp;\n    }\n    ans.x=i;\n    ans.y=n;\n    return ans;\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX_N  1000\n#define INF 200000001\n\nint Partition(int, int);\nvoid QuickSort(int, int);\nint Cost(int);\nvoid Swap(int, int);\nint MinimumCostOfSort(int);\n\nstruct rist\n{\n  int w;\n  int p;\n} typedef rist;\n\nrist A[MAX_N];\n\nint main()\n{\n\tint i;\n\tint n;\n\tint cost;\n\t\n\tscanf(\"%d\", &n);\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &A[i].w);\n\t\tA[i].p = i;\n\t}\n\t\n\tQuickSort(0, n - 1);\n\tcost = MinimumCostOfSort(n);\n\n\tprintf(\"%d\\n\", cost);\n\t\n\treturn 0;\n}\n\nint Partition(int p, int r)\n{\n  int i, j;\n  rist tmp;\n\n  i = p - 1;\n  for(j = p; j < r; j++)\n    {\n      if(A[j].w <= A[r].w)\n\t{\n\t  i = i + 1;\n\t  tmp = A[i];\n\t  A[i] = A[j];\n\t  A[j] = tmp;\n\t}\n    }\n  tmp = A[i + 1];\n  A[i + 1] = A[r];\n  A[r] = tmp;\n  \n  return i + 1;\n}\n\nvoid QuickSort(int p, int r)\n{\n  int q;\n\n  if(p < r)\n    {\n      q = Partition(p, r);\n      QuickSort(p, q - 1);\n      QuickSort(q + 1, r);\n    }\n}\n\nint Cost(int i)\n{\n\treturn A[i].w + A[A[i].p].w;\n}\n\nvoid swap(int i1, int i2)\n{\n\tint tmp;\n\t\n\ttmp = A[i2].p;\n\tA[i2].p = A[i1].p;\n\tA[i1].p = tmp;\n}\n\nint MinimumCostOfSort(int n)\n{\n\tint i, j;\n\tint mini;\n\tint swap_j;\n\tint cost = 0;\n\t\n\tfor(i = 0 ; i < n; i++)\n\t{\n\t\tmini = INF;\n\t\tfor(j = 0; j < n; j++)\n\t\t{\n\t\t\tif(Cost(j) < mini && j != A[j].p)\n\t\t\t{\n\t\t\t\tmini = Cost(j);\n\t\t\t\tswap_j = j;\n\t\t\t}\n\t\t}\n\t\tif(mini != INF)\n\t\t{\n\t\t\tcost += Cost(swap_j);\n\t\t\tswap(swap_j, A[swap_j].p);\n\t\t}\n\t}\n\n\treturn cost;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX 1000\n#define VMAX 10000\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve(){\n  int i,cur,S,m,an,v,ans = 0;\n  int V[MAX];\n  for(i=0;i<n;i++){\n    B[i] = A[i];\n    V[i] = 0;\n  }\n  sort(B,B+n);\n  for(i=0;i<n;i++) T[B[i]] = i;\n  for(i=0;i<n;i++){\n    if(V[i]) continue;\n    cur = i;\n    S = 0;\n    m = VMAX;\n    an = 0;\n    while(1){\n      V[cur] = 1;\n      an++;\n      v = A[cur];\n      m = min(m,v);\n      S += v;\n      cur = T[v];\n      if(V[cur]) break;\n    }\n    ans += min(S + (an - 2)*m,m + S + (an + 1) * S);\n  }\n  return ans;\n}\n\nint main(){\n  int i,ans;\n  scanf(\"%d\",&n);\n  s = VMAX;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",A[i]);\n    s = min(s,A[i]);\n  }\n  ans = solve();\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 10001\ntypedef struct {\n  int sum;\n  int flag;\n} CC;\nCC C[N];\nint A[1000],B[1000];\nint main()\n{\n  int i,n,min=0,m,k,now,sum=0,minx,sum1,sum2;\n  scanf(\"%d\",&n);\n  for(i=1;i<n+1;i++){\n    scanf(\"%d\",&A[i]);\n  }\n  minx=A[1];\n  for(i=1;i<n+1;i++){\n    if(minx>A[i])minx=A[i];\n  }\n  for(i=0;i<N;i++){\n    C[i].sum=0;\n    C[i].flag=0;\n  }\n  for(i=1;i<n+1;i++){\n    C[A[i]].sum+=1;\n    C[A[i]].flag+=1;\n  }\n  for(i=0;i<N;i++){\n    C[i].sum+=C[i-1].sum;\n  }\n\n  for(i=n+1;i>0;i--){\n    if(C[A[i]].flag==1){\n      k=i;\n      now=k;\n      m=0;\n      B[C[A[k]].sum]=A[k];\n      C[A[i]].flag=0;\n      min=A[k];\n      k=C[A[k]].sum;\n      while(A[now]!=A[k]){\n        if(m==0){\n          sum+=A[now];\n\t  //printf(\"%d \",A[now]);\n        }\n        //printf(\"%d \",A[k]);\n        B[C[A[k]].sum]=A[k];\n        C[A[k]].flag=0;\n        sum+=A[k];\n        if(min>A[k])min=A[k];\n        k=C[A[k]].sum;\n        m+=1;\n      }\n      sum2=min*(m-1);\n      sum1=min+(m+2)*minx;\n      if(m>1){      \n\tif(sum1<sum2){\n\t  sum+=sum1;\n\t}\n\telse sum+=sum2;     \n\tm=0;\n\tmin=0;\n      }\n    }\n    \n  }\n  /* printf(\"\\n\");\n  for(i=1;i<n;i++){\n    printf(\"%d \",B[i]);\n  }\n  printf(\"%d\",B[i]);*/\n  printf(\"%d\\n\",sum);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX  1000\n#define VMAX 10000\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint min(int a,int b){\n  if(a>b) return b;\n  else return a;\n}\n\nint partition(int A[],int p,int r){\n  int i,j;\n  int t,x;\n  x = A[r];\n  i = p - 1;\n\n  for(j=p;j<r;j++){\n    if(A[j]<=x){\n      i++;\n      t = A[i];\n      A[i] = A[j];\n      A[j] = t;\n    }\n  }\n\n  t = A[i+1];\n  A[i+1] = A[r];\n  A[r] = t;\n\n  return i+1;\n}\nvoid quickSort(int A[],int p,int r){\n  int q;\n  if(p<r){\n    q = partition(A,p,r);\n    quickSort(A,p,q-1);\n    quickSort(A,q+1,r);\n  }\n}\n\n\nint solve(){\n  int ans=0,i,cur,S,m,an,v;\n\n  int V[MAX];\n  for(i=0;i<n;i++){\n    B[i] = A[i];\n    V[i] = 0;\n  }\n  quickSort(B,0,n-1);\n  for(i=0;i<n;i++) T[B[i]] = i;\n  for(i=0;i<n;i++){\n    if(V[i]) continue;\n    cur = i;\n    S = 0;\n    m = VMAX;\n    an = 0;\n    while(1){\n      V[cur] = 1;\n      an++;\n      v = A[cur];\n      m = min(m,v);\n      S += v;\n      cur = T[v];\n      if(V[cur]) break;\n    }\n    ans += min(S+(an-2)*m,m+S+(an+1)*s);\n  }\n  return ans;\n}\n\n\n\nint main(){\n  int i;\n\n  scanf(\"%d\", &n);\n  \n  s = VMAX;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    s = min(s,A[i]);\n  }\n\n  int ans = solve();\n  printf(\"%d\\n\",ans);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX_N  1000\n\nvoid QuickSort(int, int);\nint Partition(int, int);\nint MinimumCost(int);\n\nstruct rist\n{\n  int n;\n  int p;\n} typedef rist;\n\nrist A[MAX_N];\n\nint main()\n{\n\tint i;\n\tint n;\n\tint cost;\n\t\n\tscanf(\"%d\", &n);\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &A[i].n);\n\t\tA[i].p = i;\n\t}\n\t\n\tQuickSort(0, n - 1);\n\tcost = MinimumCost(n);\n\t\n\tprintf(\"%d\\n\", cost);\n\t\n\treturn 0;\n}\n\nvoid QuickSort(int p, int r)\n{\n\tint q;\n\n\tif(p < r)\n    {\n      q = Partition(p, r);\n      QuickSort(p, q - 1);\n      QuickSort(q + 1, r);\n    }\n}\n\nint Partition(int p, int r)\n{\n\tint i, j;\n\trist tmp;\n\n\ti = p - 1;\n\tfor(j = p; j < r; j++)\n    {\n    \tif(A[j].n < A[r].n)\n\t\t{\n\t \t\ti = i + 1;\n\t \t\ttmp = A[i];\n\t  \t\tA[i] = A[j];\n\t  \t\tA[j] = tmp;\n\t\t}\n    }\n\ttmp = A[i + 1];\n  \tA[i + 1] = A[r];\n  \tA[r] = tmp;\n  \n  \treturn i + 1;\n}\n\nint MinimumCost(int n)\n{\n\tint i;\n\tint tmp;\n\tint cost = 0;\n\t\n\tfor(i = n - 1; i >= 0; i--)\n\t{\n\t\tif(A[i].p != i)\n\t\t{\n\t\t\tcost += A[i].n + A[A[i].p].n;\n\n\t\t\ttmp = A[A[i].p].p;\n\t\t\tA[A[i].p].p = A[i].p;\n\t\t\tA[i].p = tmp;\n\t\t}\n\t}\n\treturn cost;\n}"
  },
  {
    "language": "C",
    "code": "#define dbg(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#define dpri(x) dbg(#x \": %d\\n\", x)\n#define dprs(x) dbg(#x \": %s\\n\", x)\n#include <stdio.h>\n#include <stdlib.h>\ntypedef long long ll;\nconst int MYINF = 1e9+7;\ntypedef int bool;\nconst bool true = 1;\nconst bool false = 0;\n\n#define MAX_N 1010\n\ntypedef struct {\n\tint w;\n\tint o;\n} baggage;\n\nint n;\nint cost;\nbaggage W[MAX_N];\nint visited[MAX_N];\n\nint cmp(const void *a, const void *b) {\n\treturn ((const baggage *)a)->w - ((const baggage *)b)->w;\n}\n\nvoid calc() {\n\tint i;\n\tqsort(W, n, sizeof(baggage), cmp);\n\tfor (i = 0; i < n; i++) {\n\t\tif (visited[i]) continue;\n\t\tvisited[i] = 1;\n\n\t\tint c1, c2, j;\n\t\tfor (c1 = 0, j = W[i].o; j != i; j = W[j].o) {\n\t\t\tc1 += W[i].w + W[j].w;\n\t\t\tvisited[j] = 1;\n\t\t}\n\t\tfor (c2 = 2*(W[0].w+W[i].w), j=W[i].o; j != i; j = W[j].o) {\n\t\t\tc2 += W[0].w + W[j].w;\n\t\t}\n\n\t\tif (c1 < c2) cost += c1;\n\t\telse cost += c2;\n\t}\n}\n\nint main(int argc, char **argv)\n{\n\tint i;\n\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &W[i].w);\n\t\tW[i].o = i;\n\t}\n\tcalc();\n\n\tprintf(\"%d\\n\", cost);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define N 10000\n#define MIN(a, b) (a < b ? a : b)\n\nint partition(int *A, int  p, int r){\n\tint i, j, x, temp;\n\tx = A[r];\n\t//printf(\"x:%d\\n\", x);\n\ti = p-1;\n\tfor(j=p; j<r; j++){\n\t\tif(A[j]<=x){\n\t\t\ti=i+1;\n\t\t\t//A[i] と A[j] を交換\n\t\t\ttemp=A[i];\n\t\t\tA[i]=A[j];\n\t\t\tA[j]=temp;\n\t\t}\n\t}\n\t//A[i+1] と A[r] を交換\n\ttemp=A[i+1];\n\tA[i+1]=A[r];\n\tA[r]=temp;\n\t\n\treturn i+1;\n}\n\nvoid quicksort(int *A, int  p, int r){\n\tint q;\n\tif(p<r){\n\t\tq = partition(A, p, r);\n\t\tquicksort(A, p, q-1);\n\t\tquicksort(A, q+1, r);\n\t}\n}\n\nint solve(int *A, int *B, int min, int n){\n\tint i, sum, c, m, ans=0;\n\tint X[N+1], C[N];\n\tfor(i=0; i<n; i++) C[i]=0;\n\tquicksort(B, 0, n-1);\n\t\n\tfor(i=0; i<n; i++) X[B[i]]=i;\n\tfor(i=0; i<n; i++){\n\t\tif(C[i]) continue;\n\t\tint x=i;\n\t\tsum=0;\n\t\tm=N;\n\t\tc=0;\n\t\twhile(1){\n\t\t\tC[x]=1;\n\t\t\tc++;\n\t\t\tint a=A[x];\n\t\t\tm=MIN(m, a);\n\t\t\tsum+=a;\n\t\t\tx=X[a];\n\t\t\tif(C[x]) break;\n\t\t}\n\t\tans+=MIN(sum+(c-2)*m, m+sum+(c+1)*min);\n\t}\n\treturn ans;\n}\n\nint main(void){\n\tint n, i, j, A[N], B[N], min=N;\tscanf(\"%d\", &n);\n\tfor(i=0; i<n; i++){\n\t\tscanf(\"%d\", &A[i]);\n\t\tif(min>A[i]) min=A[i];\n\t\tB[i]=A[i];\n\t}\n\tprintf(\"%d\\n\", solve(A, B, min, n));\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX  1000\n#define MAX_1 10000\n\n\nint n, a[MAX], s;\nint b[MAX], T[MAX_1 + 1];\n\n\nint partition(int a[], int p, int r){\n  int i, j;\n  int t, x;\n  x = a[r];\n  i = p - 1;\n\n  for( j = p ; j < r ; j++ ){\n    if(a[j] <= x){\n      i++;\n      t = a[i];\n      a[i] = a[j];\n      a[j] = t;\n    }\n  }\n\n  t = a[i + 1];\n  a[i + 1] = a[r];\n  a[r] = t;\n\n  return i + 1;\n}\nvoid quickSort(int a[], int p, int r){\n  int q;\n  if(p < r){\n    q = partition(a, p, r);\n    quickSort(a, p, q - 1);\n    quickSort(a, q + 1, r);\n  }\n}\n\n\nint solve(){\n  int i, cur, S, m, an, v,   ans = 0 ;\n\n  int V[MAX];\n  for(i = 0 ; i < n ; i++){\n    b[i] = a[i];\n    V[i] = 0;\n  }\n\n  quickSort(b, 0, n - 1);\n\n  for(i = 0 ; i < n ; i++) T[b[i]] = i;\n  for(i = 0 ; i < n ; i++){\n    if(V[i]) continue;\n    cur = i;\n    S = 0;\n    m = MAX_1;\n    an = 0;\n    while(1){\n      V[cur] = 1;\n      an++;\n      v = a[cur];\n\n      if(v < m) m = v;\n\n      S += v;\n      cur = T[v];\n      if(V[cur]) break;\n    }\n    if(S + (an -2) * m < m + S + (an + 1) * s) ans += S + (an -2) * m;\n    else ans +=  m + S + (an + 1) * s;\n  }\n  return ans;\n}\n\n\n\nint main(){\n  int i;\n\n  scanf(\"%d\", &n);\n  s = MAX_1;\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\", &a[i]);\n    if(a[i] < s) s = a[i];\n  }\n\n  int ans = solve();\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#define true 1\n#define false 0\n#define MAX 1000\n#define VMAX 10000\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nvoid sort(int C[])\n{\n\t\n\tint tmp;\n\tint flag = 1;\n\twhile(flag == 1)\n\t{\n\t\tflag = 0;\n\t\tfor( int j = n-1; j >= 1; j--)\n\t\t{\n\t\t\tif(C[j] < C[j-1])\n\t\t\t{\n\t\t\t\ttmp = C[j];\n\t\t\t\tC[j] = C[j-1];\n\t\t\t\tC[j-1] = tmp;\n\t\t\t\tflag = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint min(int a , int b)\n{\n\tif(a < b) return a;\n\telse return b;\n}\n\nint solve()\n{\n\tint ans = 0;\n\t\n\tbool V[MAX];\n\tfor( int i = 0; i < n; i++)\n\t{\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B);\n\tfor( int i = 0; i < n; i++) T[B[i]] = i;\n\tfor( int i = 0; i < n; i++) \n\t{\n\t\tif(V[i])continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint count = 0;\n\t\twhile(1)\n\t\t{\n\t\t\tV[cur] = true;\n\t\t\tcount++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m,v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif(V[cur])break;\n\t\t}\n\t\tans += min(S+(count-2)*m,m+S+(count+1)*s);\n\t}\n\treturn ans;\n}\n\nint main(void)\n{\n\tscanf(\"%d\",&n);\n\ts = VMAX;\n\tfor( int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\",&A[i]);\n\t\ts = min(s,A[i]);\n\t}\n\tint ans = solve();\n\tprintf(\"%d\\n\",ans);\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\n//============================================================================\n#define pred(x) ((x)-1)\n#define succ(x) ((x)+1)\n//============================================================================\ntypedef unsigned char  INT8U;\ntypedef unsigned short INT16U;\ntypedef   signed short INT16S;\ntypedef long INT32;\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nINT16U *C;\n//----------------------------------------------------------------------------\nvoid CountingSort(INT16U *A, INT16U *B,  INT16U n, INT16U k)\n{\n    long i;\n\n    for (i = 0; i<n; i++)\n        C[A[i]]++;\n    for (i = 1; i<=k; i++)\n        C[i] += C[i-1];\n    // C holds position of A\n    // C[A[val]] = pred val position\n\n    /*for (i = 1; i<=k; i++)\n        printf(\"%d \", C[i]);\n    printf(\"\\n\");*/\n    /*printf(\"B[C[A[i]]-1] = A[i];\\n\");\n    for (i=n-1; 0<=i; i--){\n        //B[C[A[i]]-1] = A[i];\n        printf(\"B[%d]=%d C[%d]=%d A[%d]=%d\\n\", C[A[i]]-1, A[i],\n                            A[i], C[A[i]], i, A[i]);\n        //C[A[i]]--;\n    }*/\n}\n//----------------------------------------------------------------------------\nINT16S getminptr(INT16U *A, INT16U N)\n{\n    INT16U i,min; INT16S ptr;\n\n    for (i=0, ptr=-1, min=32767; i<N; i++){\n        if (A[i]<min && pred(C[A[i]])!=i){\n            min=A[i];\n            ptr=i;\n        }\n    }\n    return ptr;\n}\n//----------------------------------------------------------------------------\nlong sum;\nvoid exchange(INT16U *x, INT16U *y)\n{\n    INT16U z;\n\n    z=*x, *x=*y, *y=z;\n    sum+=*x;\n    sum+=*y;\n    //printf(\"ex: %d<-->%d, sum:%ld\\n\", *y, *x, sum);\n}\n//----------------------------------------------------------------------------\nvoid prnary(INT16U *A, INT16U N)\n{\n    int j;\n\n    for (j=0; j<N; j++)\n        printf(\"%2d \", A[j]);\n    printf(\" sum:%ld\\n\", sum);\n}\n//----------------------------------------------------------------------------\nshort linklen(INT16U *A, INT16U N, INT16U val)\n{\n    int idx,n;\n\n\n    for (n=0, idx=val; ; n++){\n        idx=A[pred(C[idx])];\n        if (idx==val)\n            return n;\n    }\n}\n//----------------------------------------------------------------------------\nvoid duplication(INT16U *A, INT16U N)\n{\n    int i,j,k,n,a,ary[3];\n\n#ifdef DESKTOP\n    prnary(A, N);\n#endif\n    for (i=sum=0; i<pred(N); i++){\n        n=linklen(A, N, A[i]);\n        if (n==1){\n            j=pred(C[A[i]]);\n            exchange(&A[i], &A[j]);\n            //printf(\"ex:(%d<->%d), \", A[i], A[j]);\n        }else\n        if (n==2 && 10<A[i]){\n            ary[0]=i;\n            ary[1]=pred(C[A[i]]);\n            ary[2]=pred(C[A[ary[1]]]);\n            for (j=a=0,k=20000; j<3; j++)\n            if (A[ary[j]]<k){\n                k=A[ary[j]];\n                a=ary[j];\n            }\n            j=pred(C[A[a]]);\n            k=pred(C[A[j]]);\n            if (A[j]<A[k]){\n                //printf(\"ex:(%d<->%d), \", A[a], A[k]); // 44<>96\n                exchange(&A[a], &A[k]);\n            }else{\n                //printf(\"ex:(%d<->%d), \", A[a], A[j]); // 44<>96\n                exchange(&A[a], &A[j]);\n            }\n            //printf(\"ex:(%d<->%d), \", A[k], A[j]); // 44<>96\n            exchange(&A[k], &A[j]);\n        }\n#ifdef DESKTOP\n    }\n    printf(\"\\n\");\n#else\n    }\n#endif\n}\n//----------------------------------------------------------------------------\nlong mincostsort(INT16U *A, INT16U N)\n{\n    int ptr,i,j,min,ordptr,order[100];\n\n    duplication(A, N);\n    for (i=0,j=32000; i<N; i++)\n        if (A[i]<j)\n            j=A[i],min=i;\n    for (ordptr=0; 0<=(ptr=getminptr(A, N));){\n#ifdef DESKTOP\n    printf(\"[%d]\\n\", A[ptr]);\n#endif\n        order[ordptr++]=A[ptr];\n        if (A[min]*2<A[ptr]){\n            exchange(&A[min], &A[ptr]);\n            min=ptr;\n        }\n        while (pred(C[A[ptr]])!=ptr){\n            for (i=0; i<N; i++)\n                if (C[A[i]]==succ(ptr)){\n                    order[ordptr++]=A[i];\n                    if (ptr==min) min=i;\n                    exchange(&A[ptr], &A[i]);\n                    ptr=i;\n#ifdef DESKTOP\n                    //prnary(A, N);\n#endif\n                    break;\n                }\n        }\n    }\n#ifdef DESKTOP\n    for (i=0; i<ordptr; i++){\n        if (i) printf(\"->\");\n            printf(\"%d\", order[i]);\n    }\n    printf(\"\\n\");\n#endif\n    return sum;\n}\n//----------------------------------------------------------------------------\n/*\n*                                         *     *\n0 62 33 29 72 52 43 19 5  93 51 32  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51  5  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51 47  8 11 56  5 66 69 30 17 68  5\n0  5 33 29 72 52 43 19 32 93 51 47  8 11 56 62 66 69 30 17 68  0\n0  5 33 29 72 52 43 19 32 93  8 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 29 72 52  8 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33  8 72 52 29 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 11 72 52 29 19 32 93 43 47 51  8 56 62 66 69 30 17 68  8\n0  5 33 11 72  8 29 19 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29  8 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 69  8 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66  8 69 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 68 69 17  8  8\n0  5 33 11 72 19 29 30 32  8 43 47 51 52 56 62 66 68 69 17 93  8\n0  5  8 11 72 19 29 30 32 33 43 47 51 52 56 62 66 68 69 72 93  0\n0  5  8 11 17 19 29 30 32 33 43 47 51 52 56 62 66 68 69 17 93  0\n\n 1 80 50 70 40 20\n20 80 50 70 40  1\n20  1 50 70 40 80\n 1 20 50 70 40 80 21        20 40 50 70  1 80   41\n40 20 50 70  1 80 41        20 40 50  1 70 80   71\n40 20 50  1 70 80 71        20 40  1 50 70 80   51\n40 20  1 50 70 80 51        20  1 40 50 70 80   41\n 1 20 40 50 70 80 41         1 20 40 50 70 80   21\n\n\n5\n1 5 3 4 2\n7\n\n4\n4 3 2 1\n10\n*/\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nvoid input(FILE *file)\n{\n    long i,n,max,ave; INT16U *A, *B; char buffer[20];\n\n    fgets(buffer, sizeof(buffer)-1, file);\n    sscanf(buffer, \"%ld\", &n);\n    A = malloc(succ(n)*sizeof(INT16U));\n    B = malloc(succ(n)*sizeof(INT16U));\n    for (i=ave=max=0; i<n; i++){\n        fscanf(file, \"%hd\",  &A[i]);\n        if (max<A[i])\n            max=A[i];\n        ave+=A[i];\n    }\n    ave/=n;\n    C = malloc(succ(max)*sizeof(INT16U));\n    memset(C, 0, sizeof(INT16U)*succ(max));\n    CountingSort(A, B, n, max);\n    printf(\"%ld\\n\", mincostsort(A, n));\n#ifdef DESKTOP\n    for (i=0; i<n; i++){\n        if (i) printf(\" \");\n        printf(\"%hd\", A[i]);\n    }\n    printf(\"\\n\");\n#endif\n    free(A);\n    free(B);\n    free(C);\n}\n//============================================================================\n#ifndef DESKTOP\nint main()\n{\n    input(stdin);\n    return 0;\n}\n#endif"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 101\ntypedef struct {\n  int sum;\n  int flag;\n} CC;\nCC C[N];\nint A[1000],B[1000];\nint main()\n{\n  int i,n,min=0,m,k,now,sum=0,minx,sum1,sum2;\n  scanf(\"%d\",&n);\n  for(i=1;i<n+1;i++){\n    scanf(\"%d\",&A[i]);\n  }\n  minx=A[1];\n  for(i=1;i<n+1;i++){\n    if(minx>A[i])minx=A[i];\n  }\n  for(i=0;i<N;i++){\n    C[i].sum=0;\n    C[i].flag=0;\n  }\n  for(i=1;i<n+1;i++){\n    C[A[i]].sum+=1;\n    C[A[i]].flag+=1;\n  }\n  for(i=0;i<N;i++){\n    C[i].sum+=C[i-1].sum;\n  }\n\n  for(i=n+1;i>0;i--){\n    if(C[A[i]].flag==1){\n      k=i;\n      now=k;\n      m=0;\n      B[C[A[k]].sum]=A[k];\n      C[A[i]].flag=0;\n      min=A[k];\n      k=C[A[k]].sum;\n      while(A[now]!=A[k]){\n        if(m==0){\n          sum+=A[now];\n\t  //printf(\"%d \",A[now]);\n        }\n        //printf(\"%d \",A[k]);\n        B[C[A[k]].sum]=A[k];\n        C[A[k]].flag=0;\n        sum+=A[k];\n        if(min>A[k])min=A[k];\n        k=C[A[k]].sum;\n        m+=1;\n      }\n      sum2=min*(m-1);\n      sum1=min+(m+2)*minx;\n      if(m>1){      \n\tif(sum1<sum2){\n\t  sum+=sum1;\n\t}\n\telse sum+=sum2;     \n\tm=0;\n\tmin=0;\n      }\n    }\n    \n  }\n  /* printf(\"\\n\");\n  for(i=1;i<n;i++){\n    printf(\"%d \",B[i]);\n  }\n  printf(\"%d\",B[i]);*/\n  printf(\"%d\\n\",sum);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n\n\n\nint n,cost;\nint A[1001],B[1001];\nint L[501],R[502];\n\n\nvoid merge(int left,int mid,int right){\n  int i,j,n1=mid-left,n2=right-mid;\n  for(i=0;i<n1;i++) L[i]=A[left+i];\n  L[n1]=INT_MAX;\n  for(i=0;i<n2;i++) R[i]=A[mid+i];\n  R[n2]=INT_MAX;\n  int l=0,r=0;\n  for(i=left;i<right;i++){\n    if(L[l]<=R[r]){\n      A[i]=L[l];\n      l++;\n    }\n    else{\n      A[i]=R[r];\n      r++;\n    }\n  }\n}\n\n\nvoid m_sort(int left,int right){\n  int mid;\n  if( left+1 >= right) return;\n  mid=(left+right)/2;\n  m_sort(left,mid);\n  m_sort(mid,right);\n  merge(left,mid,right);\n}\n\n\nvoid swap(int a,int b){\n  int swap;\n  swap=B[a];\n  B[a]=B[b];\n  B[b]=swap;\n  cost+=B[a]+B[b];\n}\n\n\n/*??£????????´??????????????°???????????§????°??????????????????¢?????????????????????*/\nint min_search(){\n  int res=n,i;\n  for(i=0;i<n;i++){\n    if(A[i]!=B[i]){\n      if(B[res] >B[i]) res =i;\n    }\n  }\n  return res;\n}\n\n\nint main(){\n  scanf(\"%d\",&n);\n  int i,j,min=n;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n  B[n]=INT_MAX;\n  m_sort(0,n);\n  cost=0;\n  for(i=0;i<n;i++){\n    for(j=i+1;j<n;j++){\n      if(B[i]==A[j]){\n        if(B[j]==A[i]) swap(i,j);\n        break;\n      }\n    } \n  }\n  while(1){\n    if(min==n) min=min_search();\n    if(min==n) break;\n    for(i=0;i<n;i++){\n      if(A[min]==B[i]){\n        if(min==i){\n          min=n;\n          break;\n        }\n        swap(min,i);\n        min=i;\n        break;\n      }\n    }\n  }\n  printf(\"%d\\n\",cost);\n  return 0;\n}\n   \n          \n          \n    "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define M 1000\n#define VM 10000\n\nint n,l;\nint a[M],b[M],T[VM+1];\n\nint sol(){\n  int i,ans=0,an1,cur,s,m,v;\n  bool V[M];\n\n  for(i=0;i<n;i++){\n    b[i]=a[i];\n    V[i]=false;\n  }\n\n  asort(b);\n\n  for(i=0;i<n;i++) T[b[i]]=i;\n  for(i=0;i<n;i++){\n    if(V[i]) continue;\n    cur=i;\n    s=0;\n    m=VM;\n    an1=0;\n    while(1){\n      V[cur]=true;\n      an1++;\n      v=a[cur];\n      m=min(m,v);\n      s+=v;\n      cur=T[v];\n      if(V[cur]) break;\n    }\n    ans+=min(s+(an1-2)*m,m+s+(an1+1)*l);\n  }\n  return ans;\n}\n\nint min(int a,int b){\n  if(a>b) return b;\n  else return a;\n}\n      \nvoid asort(int b[]){\n    int i,j,tmp;\n    \n    for (i=0;i<n;i++) {\n    for (j=i+1;j<n;j++) {\n      if (b[i]>b[j]) {\n        tmp=b[i];\n        b[i]=b[j];\n        b[j]=tmp;\n      }\n    }\n  }\n\n  }\n\nint main(){\n  int i,ans;\n  \n  scanf(\"%d\",&n);\n\n  l=VM;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&a[i]);\n    l=min(l,a[i]);\n\t  }\n\n  ans=sol();\n  printf(\"%d\\n\",ans);\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX 1000\n#define VMAX 10000\n\nint A[MAX],B[MAX],T[VMAX+1];\nint n,s;\nint merge(int A[],int left,int mid,int right)\n{\n\tint L[500000],R[500000];\n\tint n1,n2,i,j,k;\n\tn1=mid-left;\n\tn2=right-mid;\n\tfor(i=0;i<n1;i++)\n\t{\n\t\tL[i]=A[left+i];\n\t}\n\tfor(i=0;i<n2;i++)\n\t{\n\t\tR[i]=A[mid+i];\n\t}\n\tL[n1]=999999999;\n\tR[n2]=999999999;\n\ti=0;\n\tj=0;\n\tfor(k=left;k<right;k++)\n\t{\n\t\tif(L[i]<=R[j])\n\t\t{\n\t\t\tA[k]=L[i];\n\t\t\ti=i+1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tA[k]=R[j];\n\t\t\tj=j+1;\n\t\t\n\t\t}\n\t}\n}\nint mergesort(int A[],int left,int right)\n{\n\tint mid;\n\tif(left+1<right)\n\t{\n\t\tmid=(left+right)/2;\n\t\tmergesort(A,left,mid);\n\t\tmergesort(A,mid,right);\n\t\tmerge(A,left,mid,right);\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n}\nint min(int a,int b)\n{\n\tif(a<=b)\n\t{\n\t\treturn a;\n\t}\n\telse \n\t{\n\t\treturn b;\n\t}\n}\n\nint solve()\n{\n\tint V[MAX];\n\tint result=0;\n\tint i;\n\tfor(i=0;i<n;i++)\n\t{\n\t\tB[i]=A[i];\n\t\tV[i]=0;\n\t}\n\tmergesort(B,0,n);\n\tfor(i=0;i<n;i++)\n\t{\n\t\tT[B[i]]=i;\n\t}\n\tfor(i=0;i<n;i++)\n\t{\n\t\tif(V[i])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tint cur=i;\n\t\tint S=0;\n\t\tint m=VMAX;\n\t\tint a=0;\n\t\twhile(1)\n\t\t{\n\t\t\tV[cur]=1;\n\t\t\ta++;\n\t\t\tint v=A[cur];\n\t\t\tm=min(m,v);\n\t\t\tS+=v;\n\t\t\tcur=T[v];\n\t\t\tif(V[cur])\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tresult+=min(S+(a-2)*m,m+S+(a+1)*s);\n\t}\n\treturn result;\n}\nint main(void)\n{\t\n\tint i;\n\ts=VMAX;\n\tscanf(\"%d\",&n);\n\t\n\tfor(i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&A[i]);\n\t\ts=min(s,A[i]);\n\t}\n\tint result=solve();\n\t\n\tprintf(\"%d\\n\",result);\n\t\n\treturn 0;\n}\n\t\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define Max  1000\n#define vMax 10000\n\nint n, a[Max], s;\nint b[Max], t[vMax + 1];\n\n\nint partition(int a[], int p, int r){\n  int i, j;\n  int t, x;\n  x = a[r];\n  i = p - 1;\n\n  for(j = p ; j < r ; j++){\n    if(a[j] <= x){\n      i++;\n      t = a[i];\n      a[i] = a[j];\n      a[j] = t;\n    }\n  }\n\n  t = a[i + 1];\n  a[i + 1] = a[r];\n  a[r] = t;\n\n  return i + 1;\n}\n\nvoid quickSort(int a[], int p, int r){\n  int q;\n  if(p < r){\n    q = partition(a, p, r);\n    quickSort(a, p, q - 1);\n    quickSort(a, q + 1, r);\n  }\n}\n\n\n\nint solve(){\n  int i,ans = 0, cur, S, m, an, v;\n\n  int V[Max];\n  for(i = 0 ; i < n ; i++){\n    b[i] = a[i];\n    V[i] = 0;\n  }\n\n  quickSort(b, 0, n - 1);\n\n  for(i = 0 ; i < n ; i++) t[b[i]] = i;\n  for(i = 0 ; i < n ; i++){\n    if(V[i]) continue;\n    cur = i;\n    S = 0;\n    m = vMax;\n    an = 0;\n    while(1){\n      V[cur] = 1;\n      an++;\n      v = a[cur];\n\n      if(v < m) m = v;\n\n      S += v;\n      cur = t[v];\n      if(V[cur]) break;\n    }\n    if(S + (an -2) * m < m + S + (an + 1) * s) ans += S + (an -2) * m;\n    else ans +=  m + S + (an + 1) * s;\n  }\n  return ans;\n}\n\n\nint main(){\n  int i;\n\n  scanf(\"%d\", &n);\n  s = vMax;\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\", &a[i]);\n    if(a[i] < s) s = a[i];\n}\n\n  int ans = solve();\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint n;\n\nint search(int *A, int w);\n\nint main(int argc, char *argv[])\n{\n  int i, j, k, l, t;\n  int *A, *R, *g, tmp, g_minj, minj, wm;\n  int cost = 0;\n\n  scanf(\"%d\", &n);\n  A = (int *)malloc(sizeof(int) * n);\n  R = (int *)malloc(sizeof(int) * n);\n  g = (int *)malloc(sizeof(int) * n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &A[i]);\n    R[i] = A[i];\n    g[i] = 0;\n  }\n\n  for (i = 0; i < n; i++) {\n    minj = i;\n    for (j = i; j < n; j++) {\n      if (R[minj] > R[j]) minj = j;\n    }\n    tmp = R[minj];\n    R[minj] = R[i];\n    R[i] = tmp;\n  }\n\n  for (i = 0; i < n; i++) {\n    if (A[i] == R[i]) continue;\n\n    g_minj = i;\n    g[0] = i;\n    k = 1;\n    j = i;\n    while (A[j] != R[i]) {\n      j = search(R, A[j]);\n      if (A[j] < A[g_minj]) {\n\tg_minj = j;\n\twm = A[g_minj];\n      }\n      g[k++] = j;\n    }\n    l = search(g, g_minj);\n    if (k >= 3) {\n      minj = search(A, R[0]);\n      if (minj != g_minj) {\n\tcost += A[minj] + A[g_minj];\n\ttmp = A[minj];\n\tA[minj] = A[g_minj];\n\tA[g_minj] = tmp;\n      }\n      g_minj = minj;\n    }\n\n    for (j = k; j > 1; j--) {\n      t = (l + j - 1) % k;\n      cost += A[g[t]] + A[g[t+1]];\n      tmp = A[g[t+1]];\n      A[g[t+1]] = A[g[t]];\n      A[g[t]] = tmp;\n    }\n\n    if (k >= 3) {\n      minj = search(A, R[0]);\n      if (minj != g_minj) {\n\tcost += A[minj] + A[g_minj];\n\ttmp = A[g_minj];\n\tA[g_minj] = A[minj];\n\tA[minj] = tmp;\n      }\n    }\n  }\n\n  printf(\"%d\\n\", cost);\n\n  return 0;\n}\n\nint search(int *A, int w)\n{\n  int i;\n  int found;\n\n  found = 0;\n  for (i = 0; i < n; i++) {\n    if (A[i] == w) {\n      found = 1;\n      break;\n    }\n  }\n\n  if (found == 1) return i;\n  else return -1;\n}"
  },
  {
    "language": "C",
    "code": "include<stdio.h>\n//とりあえず\nint sort(int *A,int n){\n  int i,j;\n  int min=1000,max=0;\n  int cost=0;\n  \n  for(i=1;i<n;i++){\n    if(A[i]>max) max=A[i];\n    else if(A[i]<min) min=A[i];\n  }\n  cost+=max+min;\n  return cost;\n}\nint main(){\n\n  int i,n,cost;\n  int A[1000];\n\n  scanf(\"%d\",&n);\n\n  for(i=0;i<n;i++) scanf(\"%d\",&A[i]);\n  cost=sort(&A[0],n);\n  \n  printf(\"%d\\n\",cost);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX_N  1000\n\nvoid QuickSort(int, int);\nint Partition(int, int);\nint MinimumCostOfSort(int);\n\nstruct rist\n{\n  int w;\n  int p;\n} typedef rist;\n\nrist A[MAX_N];\n\nint main()\n{\n\tint i;\n\tint n;\n\tint cost;\n\t\n\tscanf(\"%d\", &n);\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &A[i].w);\n\t\tA[i].p = i;\n\t}\n\t\n\tQuickSort(0, n - 1);\n\t\n\tcost = MinimumCostOfSort(n);\n\n\tprintf(\"%d\\n\", cost);\n\t\n\treturn 0;\n}\n\nvoid QuickSort(int p, int r)\n{\n\tint q;\n\n\tif(p < r)\n    {\n      q = Partition(p, r);\n      QuickSort(p, q - 1);\n      QuickSort(q + 1, r);\n    }\n}\n\nint Partition(int p, int r)\n{\n\tint i, j;\n\trist tmp;\n\n\ti = p - 1;\n\tfor(j = p; j < r; j++)\n    {\n    \tif(A[j].w < A[r].w)\n\t\t{\n\t \t\ti = i + 1;\n\t \t\ttmp = A[i];\n\t  \t\tA[i] = A[j];\n\t  \t\tA[j] = tmp;\n\t\t}\n    }\n\ttmp = A[i + 1];\n  \tA[i + 1] = A[r];\n  \tA[r] = tmp;\n  \n  \treturn i + 1;\n}\n\nint MinimumCostOfSort(int n)\n{\n\tint i;\n\tint tmp;\n\tint cost = 0;\n\t\n\twhile(i != n)\n\t{\n\t\tfor(i = 0; i < n; i++)\n\t\t{\n\t\t\tif(A[i].p != i)\n\t\t\t{\n\t\t\t\tcost += A[i].w + A[A[i].p].w;\n\n\t\t\t\ttmp = A[A[i].p].p;\n\t\t\t\tA[A[i].p].p = A[i].p;\n\t\t\t\tA[i].p = tmp;\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn cost;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nvoid swap(int *A, int i, int j) {\n  int temp;\n  temp = A[i];\n  A[i] = A[j];\n  A[j] = temp;\n}\n\nvoid Merge(int *A, int left, int mid, int right) {\n  int n1,n2,*L,*R,i,j,k;\n  n1 = mid -left;\n  n2 = right - mid;\n  L = (int*)malloc(sizeof(int) * (n1+1));\n  R = (int*)malloc(sizeof(int) * (n2+1));\n  for (i = 0; i< n1; i++) {\n    L[i] = A[left+i];\n  }\n  for (i = 0; i < n2; i++) {\n    R[i] = A[mid+i];\n  }\n  L[n1] = INT_MAX; R[n2] = INT_MAX;\n  i = 0;j = 0;\n  for(k = left; k < right; k++) {\n    if (L[i] < R[j]) {\n      A[k] = L[i];\n      i++;\n    }else {\n      A[k] = R[j];\n      j++;\n    }\n  }\n  free(L);\n  free(R);\n}\n\nvoid Merge_Sort(int *A, int left, int right) {\n  if(left+1 < right) {\n    int mid = (left + right)/2;\n    Merge_Sort(A,left,mid);\n    Merge_Sort(A,mid,right);\n    Merge(A,left,mid,right);\n  }\n}\nlong step_sort(int *w, int *w1, int i) {\n  int j;\n  long sum = 0;\n  while(w[i] != w1[i]) {\n    j = 0;\n    while (w[j] != w1[i]) j++;\n    sum += w[i]+w[j];\n    swap(w,i,j);\n    i = j;\n  }\n  return sum;\n}\n\nlong normal_sort(int *w, int *w1,int n) {\n  int i,j;\n  i = 0;\n  while(1) {\n    j = 0;\n    while(w[j] != w1[i]) j++;\n    if(i != j) break;\n    i++;\n    if(i >= n) return 0;\n  }\n  return step_sort(w,w1,j);\n}\n\nlong sub_sort(int *w, int *w1, int n) {\n  int i,j,sum;\n  i = 0;\n  while(1) {\n    j = 0;\n    while(w[j] != w1[i]) j++;\n    if(i != j) break;\n    i++;\n    if(i >= n) return 0;\n  }\n  if(i == 0) return step_sort(w,w1,j);\n  sum = w[0] + w[j];\n  swap(w,0,j);\n  return sum+step_sort(w,w1,j);\n}\n\nlong repeat_sort(int *w, int *w1, int n) {\n  int i;\n  int a1[n];\n  long v1,v2;\n  for (i = 0; i < n; i++) a1[i]=w[i];\n  v1 = normal_sort(w,w1,n);\n  if(v1 == 0) return 0;\n  v1 += repeat_sort(w,w1,n);\n  v2 = sub_sort(a1,w1,n);\n  if(v1 < v2) return v1;\n  v2 += repeat_sort(a1,w1,n);\n\n  return (v1 < v2)? v1:v2;\n}\n\nlong much_sort(int *w, int *w1, int n) {\n  int i,j;\n  long sum = 0;\n  char *checked = (char*)calloc(n,sizeof(char));\n  i = 0;\n  while(i < n) {\n    j = 0;\n    while(w[j] != w1[i]) j++;\n    if(i != j) {\n      if(w1[j] ==  w[i]) {\n\tsum += w[i] + w[j];\n\tswap(w,i,j);\n      }\n    }\n    checked[i]=1;checked[j]=1;\n    while(i < n && checked[i]!=0)i++;\n  }\n  free(checked);\n  return sum;\n}\n\nint main()\n{\n  int i,n,*w,*w2;\n  long sum;\n  scanf(\"%d\",&n);\n  w = (int*)malloc(sizeof(int) * n);\n  w2 = (int*)malloc(sizeof(int) * n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\",w+i);\n    w2[i] = w[i];\n  }\n  Merge_Sort(w2,0,n);\n  \n sum = much_sort(w,w2,n);\n  sum += repeat_sort(w,w2,n);\n  printf(\"%ld\\n\",sum);\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <math.h>\n#include <stdbool.h>\n\n#define WMAX 10000\n\nint n , allmin ,*arr ,*sortarr ,*nextarr;\nbool *booarr;\nint part ( int [],int ,int);\nvoid quickSort( int [],int ,int);\n\nint main(){\n\tscanf(\"%d\",&n);\n\tarr = malloc (n * sizeof(int));\n\tsortarr = malloc (n * sizeof(int));\n\tnextarr = malloc (WMAX * sizeof(int));\n\tbooarr = malloc (n * sizeof(bool));\n\tallmin = INT_MAX;\n\tfor(int i = 0;i<n;i++){\n\t\tscanf(\"%d\",&arr[i]);\n\t\tsortarr[i] = arr[i];\n\t\tallmin = allmin < arr[i] ? allmin : arr[i];\n\t\tbooarr[i] = false;\n\t}\n\t\n\tint outp =0;\n\tquickSort(sortarr, 0,n-1);\n\tmakeNextArr();\n\t\n\tfor(int i= 0 ; i <n ; i++)\n\t{\n\tif(booarr[i] == true){continue;}\n\tint csum = 0 ,cn =0 , cmin = INT_MAX , nowi = i ;\n\tdo\t{\n\tbooarr[nowi] = true;\n\tcsum += arr[nowi];\n\tcn++;\n\tcmin = cmin < arr[nowi] ? cmin : arr[nowi];\n\tnowi = nextarr[arr[nowi]];\n\t}while(booarr[nowi] == false);\n\n\tint incr = (cn - 2) * cmin + csum;\n\tint lent = cmin + (cn + 1) * allmin + csum;\t\n\toutp += incr < lent ? incr : lent;\n\n\t}\n\t\n\tprintf(\"%d\\n\",outp);\n\treturn 0;\n}\n\nvoid makeNextArr()\n{\n\tfor( int i = 0 ; i < n;i++ ){\n\t\tnextarr[sortarr[i]] = i;\n\t}\n}\n\nvoid quickSort( int a[],int p,int r){\n  if ( p < r){\n    int q = part(a , p ,r);\n    quickSort(a,p,q-1);\n    quickSort(a,q+1,r);\n  }\n}\n\nint  part (int a[] ,int p ,int r){\n  int x = a[r] ,t ;\n  int j, i = p-1;\n  for ( j = p ; j < r ; j++ ){\n    if ( a[j]  <= x){\n      i++;\n      t = a[i]; a[i] = a[j]; a[j] =t;\n    }\n  }\n  t = a[i+1]; a[i+1] = a[r] ; a[r]=t;\n  return i+1;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\n//============================================================================\n#define pred(x) ((x)-1)\n#define succ(x) ((x)+1)\n//============================================================================\ntypedef unsigned char  INT8U;\ntypedef unsigned short INT16U;\ntypedef   signed short INT16S;\ntypedef long INT32;\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nINT16U *C;\n//----------------------------------------------------------------------------\nvoid CountingSort(INT16U *A, INT16U *B,  INT16U n, INT16U k)\n{\n    long i;\n\n    for (i = 0; i<n; i++)\n        C[A[i]]++;\n    for (i = 1; i<=k; i++)\n        C[i] += C[i-1];\n    /*for (i = 1; i<=k; i++)\n        printf(\"%d \", C[i]);\n    printf(\"\\n\");\n    printf(\"B[C[A[i]]-1] = A[i];\\n\");\n    for (i=n-1; 0<=i; i--){\n        B[C[A[i]]-1] = A[i];\n        printf(\"B[%d]=%d C[%d]=%d A[%d]=%d\\n\", C[A[i]]-1, B[C[A[i]]-1],\n                            A[i], C[A[i]], i, A[i]);\n        C[A[i]]--;\n    }*/\n}\n//----------------------------------------------------------------------------\nINT16S getminptr(INT16U *A, INT16U N)\n{\n    INT16U i,min; INT16S ptr;\n\n    for (i=0, ptr=-1, min=32767; i<N; i++){\n        if (A[i]<min && pred(C[A[i]])!=i){\n            min=A[i];\n            ptr=i;\n        }\n    }\n    return ptr;\n}\n//----------------------------------------------------------------------------\nlong sum;\nvoid exchange(INT16U *x, INT16U *y)\n{\n    INT16U z;\n\n    z=*x, *x=*y, *y=z;\n    sum+=*x;\n    sum+=*y;\n    //printf(\"ex: %d<-->%d, sum:%ld\\n\", *y, *x, sum);\n}\n//----------------------------------------------------------------------------\nlong mincostsort(INT16U *A, INT16U N)\n{\n    int ptr,i,j,min;\n\n    for (i=sum=0; i<pred(N); i++)\n    for (j=succ(i); j<N; j++)\n        if (pred(C[A[j]])==i && pred(C[A[i]])==j)\n            exchange(&A[i], &A[j]);\n    for (i=0; !C[i]; i++);\n        min=i;\n    for (; 0<=(ptr=getminptr(A, N));){\n        if (min<ptr){\n            exchange(&A[min], &A[ptr]);\n            //ptr=min;\n        }\n        while (pred(C[A[ptr]])!=ptr){\n            for (i=0; i<N; i++)\n                if (C[A[i]]==succ(ptr)){\n                    exchange(&A[ptr], &A[i]);\n                    ptr=i;\n#ifdef DESKTOP\n                    for (j=0; j<N; j++)\n                        printf(\"%2d \", A[j]);\n                    printf(\" sum:%ld\\n\", sum);\n#endif\n                    break;\n                }\n        }\n    }\n    return sum;\n}\n//----------------------------------------------------------------------------\n/*\n*                                         *     *\n0 62 33 29 72 52 43 19 5  93 51 32  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51  5  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51 47  8 11 56  5 66 69 30 17 68  5\n0  5 33 29 72 52 43 19 32 93 51 47  8 11 56 62 66 69 30 17 68  0\n0  5 33 29 72 52 43 19 32 93  8 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 29 72 52  8 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33  8 72 52 29 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 11 72 52 29 19 32 93 43 47 51  8 56 62 66 69 30 17 68  8\n0  5 33 11 72  8 29 19 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29  8 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 69  8 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66  8 69 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 68 69 17  8  8\n0  5 33 11 72 19 29 30 32  8 43 47 51 52 56 62 66 68 69 17 93  8\n0  5  8 11 72 19 29 30 32 33 43 47 51 52 56 62 66 68 69 72 93  0\n0  5  8 11 17 19 29 30 32 33 43 47 51 52 56 62 66 68 69 17 93  0\n\n\n\n\n5\n1 5 3 4 2\n7\n\n4\n4 3 2 1\n10\n*/\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nvoid input(FILE *file)\n{\n    long i,n,max,ave; INT16U *A, *B; char buffer[20];\n\n    fgets(buffer, sizeof(buffer)-1, file);\n    sscanf(buffer, \"%ld\", &n);\n    A = malloc(succ(n)*sizeof(INT16U));\n    B = malloc(succ(n)*sizeof(INT16U));\n    for (i=ave=max=0; i<n; i++){\n        fscanf(file, \"%hd\",  &A[i]);\n        if (max<A[i])\n            max=A[i];\n        ave+=A[i];\n    }\n    ave/=n;\n    C = malloc(succ(max)*sizeof(INT16U));\n    memset(C, 0, sizeof(INT16U)*succ(max));\n    CountingSort(A, B, n, max);\n    printf(\"%ld\\n\", mincostsort(A, n));\n#ifdef DESKTOP\n    for (i=0; i<n; i++){\n        if (i) printf(\" \");\n        printf(\"%hd\", A[i]);\n    }\n    printf(\"\\n\");\n#endif\n    free(A);\n    free(B);\n    free(C);\n}\n//============================================================================\n#ifndef DESKTOP\nint main()\n{\n    input(stdin);\n    return 0;\n}\n#endif"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX_N 1000\n#define MAX_W 10000\n\nint n;\nint w[MAX_N];\nint sorted_w[MAX_N];\nint idx[MAX_W+1];\nint used[MAX_N];\n\nint min(int a, int b) {\n  return a > b ? b : a;\n}\n\nvoid swap(int *a, int *b) {\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nvoid bubbleSort() {\n  int i, j;\n  for(i = 0; i < n-1; i++) {\n    for(j = n-1; j > i; j--) {\n      if(sorted_w[j] < sorted_w[j-1]) {\n\tswap(&sorted_w[j], &sorted_w[j-1]);\n      }\n    }\n  }\n}\n\nint main() {\n  int i;\n  scanf(\"%d\", &n);\n  for(i = 0; i < n; i++) {\n    scanf(\"%d\", w+i);\n    sorted_w[i] = w[i];\n  }\n  bubbleSort();\n  for(i = 0; i < n; i++) idx[sorted_w[i]] = i;\n  int minimam = sorted_w[0];\n  int ans = 0;\n  for(i = 0; i < n; i++) {\n    if(used[i]) continue;\n    int pos = i;\n    int minimal = MAX_W;\n    int sum = 0;\n    int cnt = 0;\n    while(!used[pos]) {\n      used[pos] = 1;\n      if(w[pos] < minimal) minimal = w[pos];\n      sum += w[pos];\n      cnt++;\n      pos = idx[w[pos]];\n    }\n    //printf(\"%d %d %d\\n\", pos, minimal, sum);\n    ans += min(sum-minimal+(cnt-1)*minimal,\n\t       sum-minimal+(cnt-1)*minimam+(minimam+minimal)*2);\n  }\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nvoid swap(int *A, int i, int j) {\n  int temp;\n  temp = A[i];\n  A[i] = A[j];\n  A[j] = temp;\n}\n\nvoid Merge(int *A, int left, int mid, int right) {\n  int n1,n2,*L,*R,i,j,k;\n  n1 = mid -left;\n  n2 = right - mid;\n  L = (int*)malloc(sizeof(int) * (n1+1));\n  R = (int*)malloc(sizeof(int) * (n2+1));\n  for (i = 0; i< n1; i++) {\n    L[i] = A[left+i];\n  }\n  for (i = 0; i < n2; i++) {\n    R[i] = A[mid+i];\n  }\n  L[n1] = INT_MAX; R[n2] = INT_MAX;\n  i = 0;j = 0;\n  for(k = left; k < right; k++) {\n    if (L[i] < R[j]) {\n      A[k] = L[i];\n      i++;\n    }else {\n      A[k] = R[j];\n      j++;\n    }\n  }\n  free(L);\n  free(R);\n}\n\nvoid Merge_Sort(int *A, int left, int right) {\n  if(left+1 < right) {\n    int mid = (left + right)/2;\n    Merge_Sort(A,left,mid);\n    Merge_Sort(A,mid,right);\n    Merge(A,left,mid,right);\n  }\n}\n\nint main()\n{\n  int i,j,n,*w,*w2;\n  long sum;\n  scanf(\"%d\",&n);\n  w = (int*)malloc(sizeof(int) * n);\n  w2 = (int*)malloc(sizeof(int) * n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\",w+i);\n    w2[i] = w[i];\n  }\n  Merge_Sort(w2,0,n);\n  sum = 0;\n  for (i = 0; i < n; i++) {\n    j = i;\n    while(w[j] != w2[i]) j++;\n    if(j != i) {\n      sum += w[i] + w[j];\n      swap(w,i,j);\n    }\n  }\n  printf(\"%ld\\n\",sum);\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int n,i,j,ans = 0,mi,cnt,now,sum,tmp;\n    int mini = 10000; /* 最大値は10の4乗 */\n\n    \n    scanf(\"%d\",&n); /* n個(1<=n<=1000)で全て異なる値 */\n    \n    int *W = malloc(sizeof(int)*n);\n    memset(W,0,n);\n    \n    int *done = malloc(sizeof(int)*n);\n    memset(done,0,n);\n//    int mp[1010];\n    int mp[1000];\n    \n    for( i=0 ; i<n ; i++ )\n    {\n        scanf(\"%d\",&W[i]);\n        if(W[i] < mini)\n        {\n            mini = W[i]; /* 最小に設定 */\n        }\n//        mp[W[i]] = 0;\n        mp[i] = W[i]; /* W[i]は全て異なる値 */\n    }\n    \n    /* mp[]を昇順にバブルソート */\n    for( i=0 ; i<n; i++ )\n    {\n        for( j=1; j<n-i; j++ )\n        {\n            if( mp[j] < mp[j-1] )\n            {\n                tmp = mp[j];\n                mp[j] = mp[j-1];\n                mp[j-1] = tmp;\n            }\n        }\n    }\n    \n    for( i=0 ; i<n ; i++)\n    {\n        if (done[i]==1) continue; /* 処理済なら次 */\n        \n//        cnt = 0,now = i, mi = 100000, sum = 0;\n        cnt = 0;\n        now = i;\n        mi = 10000;\n        sum = 0;\n\n        while(1)\n        {\n            if (done[now]==1) break; /* 処理済ならループを抜ける */\n            cnt++;\n            done[now] = 1; /* 処理済 */\n            if(W[now] < mi)\n            {\n                mi = W[now]; /* 最小値に設定 */\n            }\n            sum += W[now];\n\n            for( j=0 ; j<n ; j++ )\n            {\n                if( mp[j] == W[now] )\n                {\n                    /* 検索 */\n                    now = j;\n                    break;\n                }\n            }\n//            now = mp[W[now]];\n        }\n\n        if( (sum+(cnt-2)*mi) < (sum+mi+mini*(cnt+1)) )\n        {\n            tmp = sum+(cnt-2)*mi;\n        }\n        else\n        {\n            tmp = sum+mi+mini*(cnt+1);\n        }\n        ans += tmp;\n    }\n    \n    printf(\"%d\\n\",ans);\n\n    free(done);\n    free(W);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nvoid quicksort(int ,int );\nint n,W[1000];\nint main(void){\n  int i,cost1,cost2,total_cost=0,now,S,min,x=10000,rate;//S is sum\n  int Copy[1000],Element[10001],Bool[1000];\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&W[i]);\n    Copy[i]=W[i];\n    Bool[i]=0;\n    if(x>W[i])x=W[i];\n  }\n\n  quicksort(0,n-1);\n  //calculate cost\n  i=0;\n  while(i<n){\n    Element[W[i]]=i;\n    i++;\n  }\n  \n  i=0;\n  while(i<n){\n    if(Bool[i]==0){\n      now=i;\n      S=0;\n      min=10000;\n      rate=0;\n      while(1){\n        Bool[now]=1;\n        rate++;\n        if(min>Copy[now])\n          min=Copy[now];\n        S+=Copy[now];\n        now=Element[Copy[now]];\n        if(Bool[now]==1)break;\n      }\n      cost1=S+(rate-2)*min;\n      cost2=S+min+(rate+1)*x;\n      if(cost1<cost2)\n        total_cost+=cost1;\n      else total_cost+=cost2;\n    }\n    i++;\n  }\n  //finish calculate cost\n\n  printf(\"%d\\n\",total_cost);\n  return 0;\n}\n//quicksort include partition\nvoid quicksort(int head,int last){\n  int element;\n  if(last-head>0){\n    element=partition(head,last);\n    quicksort(head,element-1);\n    quicksort(element+1,last);\n  }\n}\nint partition(int head,int last){\n  int i,temp,last_number;\n  last_number=W[last];\n  for(i=head;i<last;i++){\n    if(W[i]<=last_number){\n      temp=W[head];\n      W[head++]=W[i];\n      W[i]=temp;\n    }\n  }\n  temp=W[head];\n  W[head]=W[last];\n  W[last]=temp;\n  return head;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n \n#define MAX 1000\n#define MAXWEIGHTIJ 20000\n \nstruct MCS {\n    int cost;\n    int order;\n};\n \nvoid exchange( struct MCS *pa, struct MCS *pb )\n{\n    struct MCS t;\n      \n    t=*pa;\n    *pa=*pb;\n    *pb=t;\n      \n     return;\n}\n  \nint Partition( struct MCS A[], int p, int r )\n{\n    struct MCS x;\n    int i,j;\n  \n    x=A[r];\n    i=p-1;\n    for( j=p; j<r; j++ ) {\n        if( A[j].cost < x.cost ) {\n            i++;\n            exchange( &A[i], &A[j] );\n         }\n    }\n    exchange( &A[i+1], &A[r] );\n \n    return i+1;\n}\nvoid QuickSort( struct MCS A[], int p, int r )\n{\n    int q;\n      \n    if( p < r ) {\n        q=Partition( A, p, r );\n        QuickSort( A, p, q-1 );\n        QuickSort( A, q+1, r );\n    }\n    return;\n}\n \nint tryChange( int n, struct MCS W[] )\n{\n    int cnt;\n    int fixedcost,profit;\n    int from, to, togoal;\n     \n    int cost,lowestCost;\n    int i,j;\n    int lowW,lowestW;\n    int low,high,lowest;\n \n    lowestW=lowW=lowestCost=cost=MAXWEIGHTIJ;\n    lowest=high=low=-1; \n    for( i=0; i<n; i++ ) {\n        if( i != W[i].order && W[i].cost < lowW ) {\n            lowW=W[i].cost;\n            low=i;\n            for( j=0; j<n; j++ ) {\n                if( low == W[j].order ) {\n                    high=j;\n                    break;\n                }\n            }\n        }\n        if( W[i].cost < lowestW ) {\n            lowestW=W[i].cost;\n            lowest=i;   \n        }       \n    }\n \n    if( W[high].order == low && W[low].order == high ) { \n        lowestCost = W[low].cost + W[high].cost;\n    } else if( low != lowest ) {    \n        fixedcost = W[low].cost + W[lowest].cost;\n        profit = W[low].cost - W[lowest].cost;\n        from=high;\n        to=low;\n        togoal = W[low].order;\n        cnt=0;\n        while( 1 ) {\n            if( W[from].order == to ) {\n                if( togoal == to ) { break; }\n                to=from;\n                cnt++;\n            } else {\n                break;\n            }\n            for( i=0; i<n; i++ ) {\n                if( i != W[i].order ) {\n                    if( to == W[i].order ) {\n                        from=i;\n                        break;\n                    }\n                }\n            }\n        }\n        profit = ( profit * cnt ) - ( 2 * fixedcost );\n        if( 0 < profit ) {\n            high=low;\n            low=lowest;\n            lowestCost = fixedcost;\n        }\n    }\n    if( W[high].order == low ) { \n        lowestCost = W[low].cost + W[high].cost;\n    }\n \n    if( MAXWEIGHTIJ != lowestCost ) {\n        exchange( &W[low], &W[high] );\n    } else {\n        lowestCost=0;\n    }\n    return lowestCost;\n}\n \nint main( void ) \n{   \n    int n,i;\n    struct MCS W[MAX+1];\n    int cost;\n         \n    scanf( \"%d\", &n );\n    for( i=0; i<n; i++ ) {\n        scanf( \"%d\", &W[i].cost );\n        W[i].order=i;\n    }\n \n    QuickSort( W, 0, n-1 ); \n    cost=i=0;\n    while( (i = tryChange( n, W ) ) ) {\n        cost+=i;\n    }\n    printf( \"%d\\n\", cost );\n \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define N 1000\n#define M 10000\n#define O 0\n#define I 1\n#define W 2\n\nint n,s,a[N],b[N],T[M+I];\n\n\nint partition(int a[],int p,int r){\n  int i,j,t,x;\n  x=a[r];\n  i=p-I;\n  for(j=p;j<r;j++){\n    if(a[j]<=x){\n      i++;\n      t=a[i];\n      a[i]=a[j];\n      a[j]=t;\n    }\n  }\n  t=a[i+I];\n  a[i+I]=a[r];\n  a[r]=t;\n  return i+I;\n}\nvoid quickSort(int a[],int p,int r){\n  int q;\n  if(p<r){\n    q=partition(a,p,r);\n    quickSort(a,p,q-I);\n    quickSort(a,q+I,r);\n  }\n}\n\n\nint solve(){\n  int i,c,S,m,A,v,ans=O;\n\n  int V[N];\n  for(i=O;i<n;i++){\n    b[i]=a[i];\n    V[i]=O;\n  }\n  quickSort(b,0,n-I);\n\n  for(i=O;i<n;i++){\n    T[b[i]]=i;\n  }\n  for(i=O;i<n;i++){\n    if(V[i]){\n      continue;\n    }\n    c=i;\n    S=O;\n    m=M;\n    A=0;\n    while(I){\n      V[c]=I;\n      A++;\n      v=a[c];\n      if(v<m){\n\tm=v;\n      }\n      S+=v;\n      c=T[v];\n      if(V[c]){\n\tbreak;\n      }\n    }\n    if(S+(A-W)*m<m+S+(A+I)*s){\n      ans+=S+(A-W)*m;\n    }\n    else{\n      ans+=m+S+(A+I)*s;\n    }\n  }\n  return ans;\n}\n\nint main(){\n  int i;\n\n  scanf(\"%d\",&n);\n  s=M;\n  for(i=O;i<n;i++){\n    scanf(\"%d\",&a[i]);\n    if(a[i]<s){\n      s=a[i];\n    }\n  }\n  int ans=solve();\n  printf(\"%d\\n\",ans);\n  return O;\n}\n\n"
  },
  {
    "language": "C",
    "code": "//?????´???????????????????°???????????????´????????¬??\\????????¨??????????????????\n#include<stdio.h>\n#include<limits.h>\n\nvoid swap(int *a, int *b){\n\tint temp = *a;\n\t*a = *b;\n\t*b = temp;\n\treturn;\n}\n\nvoid merge(int A[], int left, int mid, int right){\n\tint n1 = mid - left;\n\tint n2 = right - mid;\n\tint L[n1+1], R[n2+1];\n\tint i, j, k;\n\tfor( i = 0; i < n1; i++ ){ L[i] = A[left+i]; }\n\tfor( i = 0; i < n2; i++ ){ R[i] = A[mid+i]; }\n\tL[n1] = INT_MAX;\n\tR[n2] = INT_MAX;\n\ti = 0;\n\tj = 0;\n\tfor( k = left; k < right; k++ ){\n\t\tif( L[i] <= R[j] ){\n\t\t\tA[k] = L[i++];\n\t\t}else{\n\t\t\tA[k] = R[j++];\n\t\t}\n\t}\n\treturn;\n}\n\nvoid mergeSort(int A[], int left, int right){\n\tif( left+1 <  right ){\n\t\tint mid = (left + right) / 2;\n\t\tmergeSort(A, left, mid);\n\t\tmergeSort(A, mid, right);\n\t\tmerge(A, left, mid, right);\n\t}\n\treturn;\n}\n\nint minimumCostSort(int A[], int sorted[], int n){\n\tint i, j;\n\tint min, minj, target, targetj;\n\tint cost = 0;\n\tfor( i = 0; i < n; i++ ){\n\t\tmin = sorted[i];\n\t\t//sorted???i?????????????´????A??????????????????(minj)????????????\n\t\tfor( j = 0; j < n; j++ ){\n\t\t\tif( A[j] == min ){\n\t\t\t\tminj = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twhile( minj != i ){\n\t\t\ttarget = sorted[minj];\n\t\t\tfor( j = 0; j < n; j++ ){\n\t\t\t\tif( A[j] == target ){\n\t\t\t\t\ttargetj = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcost += A[minj] + A[targetj];\n\t\t\tswap(&A[minj], &A[targetj]);\n\t\t\tminj = targetj;\n\t\t}\n\t}\n\treturn cost;\n}\n\nint main(){\n\tint n, i;\n\tint w[1000], sorted[1000];\n\tscanf(\"%d\", &n);\n\tfor( i = 0; i < n; i++ ){\n\t\tscanf(\"%d\", &w[i]);\n\t\tsorted[i] = w[i];\n\t}\n\tmergeSort(sorted, 0, n);\n\tprintf(\"%d\\n\", minimumCostSort(w, sorted, n));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n \nvoid swap(int* a,int* b){\n  int tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\n \nint n;\nint A[1000];\nint B[1000];\nint vd[1000];\nint cnt,sum,mini;\n \nint min(int x,int y){\n  if(x<y)return x;\n  else return y;\n}\n \nint search(int x){\n  int i;\n  for(i=0;i<n;i++)if(A[i]==x)return i;\n}\n \nint main(){\n  int i,j,ans,x;\n \n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n \n  for(i=n-1;i>0;i--)\n    for(j=0;j<i;j++)\n      if(B[j]>B[j+1])swap(&B[j],&B[j+1]);\n   \n  ans=0;\n  for(i=0;i<n;i++)vd[i]=0;\n \n  for(i=0;i<n;i++){   \n    x=i;\n    cnt=sum=0;\n    mini=(1<<24);\n    while(vd[x]==0){\n      vd[x]=1;\n      cnt++;\n      sum+=A[x];\n      mini=min(mini,A[x]);\n      x=search(B[x]);\n    }\n    if(cnt<2)continue;\n    ans+=min(sum+B[0]*(cnt+1)+mini,sum+mini*(cnt-2));\n \n  }\n \n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#define true 1\n#define false 0\n#define MAX 1000\n#define VMAX 10000\n\nint n , A[MAX] , s;\nint B[MAX] , T[VMAX+1];\n\nvoid sort(int C[])\n{\n\tint flag = 1;\n\tint tmp;\n\twhile(flag == 1)\n\t{\n\t\tflag = 0;\n\t\tfor( int j = n-1; j >= 1; j--)\n\t\t{\n\t\t\tif(C[j] < C[j-1])\n\t\t\t{\n\t\t\t\ttmp = C[j];\n\t\t\t\tC[j] = C[j-1];\n\t\t\t\tC[j-1] = tmp;\n\t\t\t\tflag = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint min(int a , int b)\n{\n\tif(a < b) return a;\n\telse return b;\n}\n\nint solve()\n{\n\tint ans = 0;\n\t\n\tbool V[MAX];\n\tfor( int i = 0; i < n; i++)\n\t{\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B);\n\tfor( int i = 0; i < n; i++) T[B[i]] = i;\n\tfor( int i = 0; i < n; i++) {\n\t\tif(V[i])continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile(1){\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m,v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif(V[cur])break;\n\t\t}\n\t\tans += min(S+(an-2)*m,m+S+(an+1)*s);\n\t}\n\treturn ans;\n}\n\nint main(void)\n{\n\tscanf(\"%d\",&n);\n\ts = VMAX;\n\tfor( int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\",&A[i]);\n\t\ts = min(s,A[i]);\n\t}\n\tint ans = solve();\n\tprintf(\"%d\\n\",ans);\n}\n\n"
  },
  {
    "language": "C",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n\n\n\n\n// -- Quick Sort\nvoid swap( int *a, int *b ){\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n\nint partition( int *a, int p, int r ){\n\n    int i, j;\n    int x;\n\n    x = a[r];\n    i = p-1;\n\n\n    for( j=p; j<r; j++ ){\n\n        if( a[j] <= x ){\n            i++;\n            swap( &a[i], &a[j] );\n        }\n    }\n    i++;\n    swap( &a[i], &a[r] );\n\n\n    return i;\n\n}\n\nvoid quicksort( int *a, int p, int r ){\n\n    int q;\n\n    if( p<r ){\n        q = partition( a, p, r );\n        quicksort( a, p, q-1 );\n        quicksort( a, q+1, r );\n    }\n}\n\n\n\nint main(){\n\n    int n, w[10000];\n    int x[10000];\n    int i, j, k;\n    int c = 0;\n\n    scanf( \"%d\", &n);\n\n    for( i=0; i<n; i++ ){\n        scanf( \"%d\", &w[i] );\n        x[i] = w[i];\n    }\n\n    quicksort( x, 0, n-1 );\n\n    for( i=(n-1)/2,j=i+1; i>=0; i--,j++){\n        if( i >= 0 ){\n            if( x[i] != w[i] ){\n                for( k=0; k<n&&(x[i]!=w[k]); k++ );\n                swap( &w[i], &w[k] );\n                c += w[i]; c += w[k];\n            }\n        }\n        if( j < n ){\n            if( x[j] != w[j] ){\n                for( k=0; k<n&&(x[j]!=w[k]); k++ );\n                swap( &w[j], &w[k] );\n                c += w[j]; c += w[k];\n            }\n        }\n    }\n\n    printf( \"%d\\n\", c );\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define min(p,q)((p)<(q)?(p):(q))\nint upll(const void*a, const void*b){return*(ll*)a<*(ll*)b?-1:*(ll*)a>*(ll*)b?1:0;}\nvoid sortup(ll*a,int n){qsort(a,n,sizeof(ll),upll);}\n\n//座圧(破壊的)\nint cocomp(ll*a,int n){\n\t//0～cnt-1に圧縮\n\tll*b=(ll*)malloc(sizeof(ll)*n);\n\tmemcpy(b,a,sizeof(ll)*n);\n\tsortup(b,n);\n\tint cnt=1;\n\trep(r,1,n)if(b[r]!=b[cnt-1])b[cnt++]=b[r];\n\trep(i,0,n){\n\t\tint l=0,r=cnt;\n\t\twhile(r-l>1){int m=(l+r)/2;if(b[m]>a[i])r=m;else l=m;}\n\t\ta[i]=l;\n\t}\n\tfree(b);\n\treturn cnt;\n}\n\nll a[1010],b[1010];\nll sum[1010],mm[1010],len[1010],cnt;\n\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",a+i);\n\t\tb[i]=a[i];\n\t}\n\tcocomp(b,n);\n\t\n\tfor(int i=0;i<n;i++)if(b[i]!=-1){\n\t\tint tsum=0;\n\t\tint tlen=0;\n\t\tint tmm=1e9;\n\t\tint crr=i;\n\t\tdo{\n\t\t\ttsum+=a[crr];\n\t\t\ttmm=min(tmm,a[crr]);\n\t\t\ttlen++;\n\t\t\tint temp=b[crr];\n\t\t\tb[crr]=-1;\n\t\t\tcrr=temp;\n\t\t}while(crr!=i);\n\t\tsum[cnt]=tsum;\n\t\tmm[cnt]=tmm;\n\t\tlen[cnt]=tlen;\n\t\tcnt++;\n\t}\n\t\n\tint ans=1e9;\n\trep(i,0,cnt){\n\t\t//mm[i]を使う\n\t\tint tans=0;\n\t\trep(j,0,cnt)tans+=min((sum[j]-mm[j])+(len[j]-1)*mm[j],(sum[j]-mm[j])+(len[j]-1)*mm[i]+(mm[i]+mm[j])*2);\n\t\tans=min(ans,tans);\n\t}\t\n\t\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint cost;\n\nvoid swap(int *,int,int);\nvoid Quicksort(int *,int,int);\nint Partition(int *,int,int);\n\nint main(){\n\n  int W[1000],W2[1000],i,j,n;\n  int min = 100000000;\n\n  //入力作業\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)  scanf(\"%d\",&W[i]);\n\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++) W2[j]=W[j];\n    swap(W2,i,n-1);\n\n    cost=0;\n    Quicksort(W2,0,n-1);\n    if( cost < min) min=cost; \n  }\n  printf(\"%d\\n\",cost);\n}\n\n\n\nvoid swap(int *n,int p,int q){\n  int box;\n  \n  box = n[p];\n  n[p]=n[q];\n  n[q]=box;\n}\n\nvoid Quicksort(int *n,int p,int r){\n  int q;\n  if(p < r){\n    q = Partition(n,p,r);\n    Quicksort(n,p,q-1);\n    Quicksort(n,q+1,r);\n  }\n\n}\n\nint Partition(int *n,int p,int r){\n  int i,j,x;\n  \n  x=n[r];\n  j=p-1;\n  \n  for(i=p;i<r;i++){\n    if( n[i] <= x){\n      j++;\n      swap(n,j,i);\n    }\n  }\n  if(j + 1 != r) cost+=(n[j+1] + n[r]);\n  swap(n,j+1,r);\n  \n  return j+1;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\n//============================================================================\n#define pred(x) ((x)-1)\n#define succ(x) ((x)+1)\n//============================================================================\ntypedef unsigned char  INT8U;\ntypedef unsigned short INT16U;\ntypedef   signed short INT16S;\ntypedef long INT32;\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nINT16U *C;\n//----------------------------------------------------------------------------\nvoid CountingSort(INT16U *A, INT16U *B,  INT16U n, INT16U k)\n{\n    long i;\n\n    for (i = 0; i<n; i++)\n        C[A[i]]++;\n    for (i = 1; i<=k; i++)\n        C[i] += C[i-1];\n    // C holds position of A\n    // C[A[val]] = pred val position\n\n    /*for (i = 1; i<=k; i++)\n        printf(\"%d \", C[i]);\n    printf(\"\\n\");*/\n    /*printf(\"B[C[A[i]]-1] = A[i];\\n\");\n    for (i=n-1; 0<=i; i--){\n        //B[C[A[i]]-1] = A[i];\n        printf(\"B[%d]=%d C[%d]=%d A[%d]=%d\\n\", C[A[i]]-1, A[i],\n                            A[i], C[A[i]], i, A[i]);\n        //C[A[i]]--;\n    }*/\n}\n//----------------------------------------------------------------------------\nINT16S getminptr(INT16U *A, INT16U N)\n{\n    INT16U i,min; INT16S ptr;\n\n    for (i=0, ptr=-1, min=32767; i<N; i++){\n        if (A[i]<min && pred(C[A[i]])!=i){\n            min=A[i];\n            ptr=i;\n        }\n    }\n    return ptr;\n}\n//----------------------------------------------------------------------------\nlong sum;\nvoid exchange(INT16U *x, INT16U *y)\n{\n    INT16U z;\n\n    z=*x, *x=*y, *y=z;\n    sum+=*x;\n    sum+=*y;\n    //printf(\"ex: %d<-->%d, sum:%ld\\n\", *y, *x, sum);\n}\n//----------------------------------------------------------------------------\nvoid prnary(INT16U *A, INT16U N)\n{\n    int j;\n\n    for (j=0; j<N; j++)\n        printf(\"%2d \", A[j]);\n    printf(\" sum:%ld\\n\", sum);\n}\n//----------------------------------------------------------------------------\nshort linklen(INT16U *A, INT16U N, INT16U val)\n{\n    int idx,n;\n\n\n    for (n=0, idx=val; ; n++){\n        idx=A[pred(C[idx])];\n        if (idx==val)\n            return n;\n    }\n}\n//----------------------------------------------------------------------------\nvoid duplication(INT16U *A, INT16U N)\n{\n    int i,j,k,n,a,ary[3];\n\n#ifdef DESKTOP\n    prnary(A, N);\n#endif\n    for (i=sum=0; i<pred(N); i++){\n        n=linklen(A, N, A[i]);\n        if (n==1){\n            j=pred(C[A[i]]);\n            exchange(&A[i], &A[j]);\n            //printf(\"ex:(%d<->%d), \", A[i], A[j]);\n        }else\n        if (n==2){\n            ary[0]=i;\n            ary[1]=pred(C[A[i]]);\n            ary[2]=pred(C[A[ary[1]]]);\n            for (j=a=0,k=20000; j<3; j++)\n            if (A[ary[j]]<k){\n                k=A[ary[j]];\n                a=ary[j];\n            }\n            j=pred(C[A[a]]);\n            k=pred(C[A[j]]);\n            if (A[j]<A[k]){\n                //printf(\"ex:(%d<->%d), \", A[a], A[k]); // 44<>96\n                exchange(&A[a], &A[k]);\n            }else{\n                //printf(\"ex:(%d<->%d), \", A[a], A[j]); // 44<>96\n                exchange(&A[a], &A[j]);\n            }\n            //printf(\"ex:(%d<->%d), \", A[k], A[j]); // 44<>96\n            exchange(&A[k], &A[j]);\n        }\n#ifdef DESKTOP\n    }\n    printf(\"\\n\");\n#else\n    }\n#endif\n}\n//----------------------------------------------------------------------------\nlong mincostsort(INT16U *A, INT16U N)\n{\n    int ptr,i,j,min,ordptr,order[100];\n\n    duplication(A, N);\n    for (i=0,j=32000; i<N; i++)\n        if (A[i]<j)\n            j=A[i],min=i;\n    for (ordptr=0; 0<=(ptr=getminptr(A, N));){\n#ifdef DESKTOP\n    printf(\"[%d]\\n\", A[ptr]);\n#endif\n        order[ordptr++]=A[ptr];\n        if (A[min]*2<A[ptr]){\n            exchange(&A[min], &A[ptr]);\n            min=ptr;\n        }\n        while (pred(C[A[ptr]])!=ptr){\n            for (i=0; i<N; i++)\n                if (C[A[i]]==succ(ptr)){\n                    order[ordptr++]=A[i];\n                    if (ptr==min) min=i;\n                    exchange(&A[ptr], &A[i]);\n                    ptr=i;\n#ifdef DESKTOP\n                    //prnary(A, N);\n#endif\n                    break;\n                }\n        }\n    }\n#ifdef DESKTOP\n    for (i=0; i<ordptr; i++){\n        if (i) printf(\"->\");\n            printf(\"%d\", order[i]);\n    }\n    printf(\"\\n\");\n#endif\n    return sum;\n}\n//----------------------------------------------------------------------------\n/*\n*                                         *     *\n0 62 33 29 72 52 43 19 5  93 51 32  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51  5  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51 47  8 11 56  5 66 69 30 17 68  5\n0  5 33 29 72 52 43 19 32 93 51 47  8 11 56 62 66 69 30 17 68  0\n0  5 33 29 72 52 43 19 32 93  8 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 29 72 52  8 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33  8 72 52 29 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 11 72 52 29 19 32 93 43 47 51  8 56 62 66 69 30 17 68  8\n0  5 33 11 72  8 29 19 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29  8 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 69  8 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66  8 69 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 68 69 17  8  8\n0  5 33 11 72 19 29 30 32  8 43 47 51 52 56 62 66 68 69 17 93  8\n0  5  8 11 72 19 29 30 32 33 43 47 51 52 56 62 66 68 69 72 93  0\n0  5  8 11 17 19 29 30 32 33 43 47 51 52 56 62 66 68 69 17 93  0\n\n 1 80 50 70 40 20\n20 80 50 70 40  1\n20  1 50 70 40 80\n 1 20 50 70 40 80 21        20 40 50 70  1 80   41\n40 20 50 70  1 80 41        20 40 50  1 70 80   71\n40 20 50  1 70 80 71        20 40  1 50 70 80   51\n40 20  1 50 70 80 51        20  1 40 50 70 80   41\n 1 20 40 50 70 80 41         1 20 40 50 70 80   21\n\n\n5\n1 5 3 4 2\n7\n\n4\n4 3 2 1\n10\n*/\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nvoid input(FILE *file)\n{\n    long i,n,max,ave; INT16U *A, *B; char buffer[20];\n\n    fgets(buffer, sizeof(buffer)-1, file);\n    sscanf(buffer, \"%ld\", &n);\n    A = malloc(succ(n)*sizeof(INT16U));\n    B = malloc(succ(n)*sizeof(INT16U));\n    for (i=ave=max=0; i<n; i++){\n        fscanf(file, \"%hd\",  &A[i]);\n        if (max<A[i])\n            max=A[i];\n        ave+=A[i];\n    }\n    ave/=n;\n    C = malloc(succ(max)*sizeof(INT16U));\n    memset(C, 0, sizeof(INT16U)*succ(max));\n    CountingSort(A, B, n, max);\n    printf(\"%ld\\n\", mincostsort(A, n));\n#ifdef DESKTOP\n    for (i=0; i<n; i++){\n        if (i) printf(\" \");\n        printf(\"%hd\", A[i]);\n    }\n    printf(\"\\n\");\n#endif\n    free(A);\n    free(B);\n    free(C);\n}\n//============================================================================\n#ifndef DESKTOP\nint main()\n{\n    input(stdin);\n    return 0;\n}\n#endif"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX 1000\n#define MAXWEIGHTIJ 20000\n\nstruct MCS {\n\tint cost;\n\tint sorder;\n\tint order;\n};\n\nvoid exchange( struct MCS *pa, struct MCS *pb )\n{\n   \tstruct MCS t;\n     \n\tt=*pa;\n\t*pa=*pb;\n\t*pb=t;\n\t \n\t return;\n}\n \nint Partition( struct MCS A[], int p, int r )\n{\n    struct MCS x;\n    int i,j;\n \n    x=A[r];\n    i=p-1;\n    for( j=p; j<r; j++ ) {\n        if( A[j].cost < x.cost ) {\n            i++;\n            exchange( &A[i], &A[j] );\n         }\n    }\n    exchange( &A[i+1], &A[r] );\n\n    return i+1;\n}\nvoid QuickSort( struct MCS A[], int p, int r )\n{\n    int q;\n     \n    if( p < r ) {\n        q=Partition( A, p, r );\n        QuickSort( A, p, q-1 );\n        QuickSort( A, q+1, r );\n    }\n    return;\n}\n\nint tryChange( int n, struct MCS W[] )\n{\n\tint cnt;\n\tint fixedcost,profit;\n\tint from, to, togoal;\n\tint ti;\n\n\n\tint cost,miniCost;\n\tint i;\n\tint maxi,mini;\n\tint max,min,mostmin;\n\tint minorder,maxorder,mostorder;\n\tint limitN;\n\n\t\n\tmaxi=mini=0;\n\tminiCost=cost=MAXWEIGHTIJ;\n\tlimitN=n;\t\n\tmaxorder=max=-1;\n\tmostmin=min=mostorder=minorder=n;\n    while( 1 ) {\n\t\tfor( i=0; i<limitN; i++ ) {\n\t\t\tif( i != W[i].order ) {\n\t\t\t\tif( max < W[i].sorder ) {\n    \t\t\t\tmax=W[i].sorder;\n    \t\t\t\tmaxorder=i;\n    \t\t\t}\n\t\t\t\tif( W[i].sorder < min ) {\n\t\t\t\t\tmin=W[i].sorder;\n\t\t\t\t\tminorder=i;\t\n\t\t\t\t}\t\n\t\t\t}\n\t\t\tif( W[i].sorder < mostmin ) {\n\t\t\t\tmostmin=W[i].sorder;\n\t\t\t\tmostorder=i;\t\n\t\t\t}\n\t\t}\n\t\tif( -1 == maxorder ) { break; }\n\n  \t\tif( W[maxorder].order == minorder && W[minorder].order == maxorder ) { \n\t\t\tcost = W[minorder].cost + W[maxorder].cost;\n\t\t\tminiCost=cost;\n\t\t\tmini=minorder;\n\t\t\tmaxi=maxorder;\n\t\t\tbreak;\n\t\t}\n\t\t\t\t\n\t\tif( minorder != mostorder ) {\t\n\t\t\tfixedcost = W[minorder].cost + W[mostorder].cost;\n\t\t\tprofit = W[minorder].cost - W[mostorder].cost;\n\t\t\tfrom=maxorder;\n\t\t\tto=minorder;\n\t\t\ttogoal = W[minorder].order;\n\t\t\tcnt=0;\n\t\t\twhile( 1 ) {\n\t\t\t\tif( W[from].order == to ) {\n\t\t\t\t\tif( togoal == to ) { break; }\n\t\t\t\t\tto=from;\n\t\t\t\t\tcnt++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor( ti=0; ti<n; ti++ ) {\n\t\t\t\t\tif( ti != W[ti].order ) {\n\t\t\t\t\t\tif( to ==  W[ti].order ) {\n\t\t    \t\t\t\tfrom=ti;\n\t\t    \t\t\t\tbreak;\n\t\t    \t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprofit = ( profit * cnt ) - ( 2 * fixedcost );\n\t\t\tif( 0 < profit ) {\n\t\t\t\tminorder=mostorder;\n\t\t\t}\n\t\t}\n\t\t\n   \t\tif( W[maxorder].order == minorder ) { \n\t\t\tcost = W[minorder].cost + W[maxorder].cost;\n\t\t\tminiCost=cost;\n\t\t\tmini=minorder;\n\t\t\tmaxi=maxorder;\n\t\t\tbreak;\n\t\t}\n\t\tlimitN--;\n\t\tmax=-1;\n\t\tif( -1 == limitN ) {\n\t\t\tif( MAXWEIGHTIJ == miniCost ) {\n\t\t\t\tcost = W[minorder].cost + W[maxorder].cost;\n\t\t\t\tminiCost=cost;\n\t\t\t\tmini=minorder;\n\t\t\t\tmaxi=maxorder;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n    }\n\n\n    if( MAXWEIGHTIJ != miniCost ) {\n\t\texchange( &W[mini], &W[maxi] );\n\t} else {\n    \tminiCost=0;\n    }\n\n\treturn miniCost;\n}\n\nint main( void ) \n{   \n    int n,i;\n    struct MCS W[MAX+1];\n    int cost;\n        \n    scanf( \"%d\", &n );\n    for( i=0; i<n; i++ ) {\n        scanf( \"%d\", &W[i].cost );\n        W[i].order=i;\n    }\n\n    QuickSort( W, 0, n-1 ); \n     for( i=0; i<n; i++ ) {\n        W[i].sorder=i;\n    }\n   cost=i=0;\n    while( (i = tryChange( n, W ) ) ) {\n   \t\tcost+=i;\n    }\n   \tprintf( \"%d\\n\", cost );\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n  \nvoid swap(int* a,int* b){\n  int tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\n  \nint n;\nint a[1000];\nint b[1000];\nint vd[1000];\nint cnt,sum,mini;\n  \nint min(int x,int y){\n  if(x<y)return x;\n  else return y;\n}\n  \nint search(int x){\n  int i;\n  for(i=0;i<n;i++)if(a[i]==x) return i;\n}\n  \nint main(){\n  int i,j,ans,x;\n  \n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&a[i]);\n    b[i]=a[i];\n  }\n  \n  for(i=n-1;i>0;i--)\n    for(j=0;j<i;j++)\n      if(b[j]>b[j+1])swap(&b[j],&b[j+1]);\n    \n  ans=0;\n  for(i=0;i<n;i++)vd[i]=0;\n  \n  for(i=0;i<n;i++){   \n    x=i;\n    cnt=sum=0;\n    mini=(1<<24);\n    while(vd[x]==0){\n      vd[x]=1;\n      cnt++;\n      sum+=a[x];\n      mini=min(mini,a[x]);\n      x=search(b[x]);\n    }\n    if(cnt<2)continue;\n    ans+=min(sum+b[0]*(cnt+1)+mini,sum+mini*(cnt-2));\n  \n  }\n  \n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\n//============================================================================\n#define pred(x) ((x)-1)\n#define succ(x) ((x)+1)\n//============================================================================\ntypedef unsigned char  INT8U;\ntypedef unsigned short INT16U;\ntypedef   signed short INT16S;\ntypedef long INT32;\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nINT16U *C;\n//----------------------------------------------------------------------------\nvoid CountingSort(INT16U *A, INT16U *B,  INT16U n, INT16U k)\n{\n    long i;\n\n    for (i = 0; i<n; i++)\n        C[A[i]]++;\n    for (i = 1; i<=k; i++)\n        C[i] += C[i-1];\n    // C holds position of A\n    // C[A[val]] = pred val position\n\n    /*for (i = 1; i<=k; i++)\n        printf(\"%d \", C[i]);\n    printf(\"\\n\");*/\n    /*printf(\"B[C[A[i]]-1] = A[i];\\n\");\n    for (i=n-1; 0<=i; i--){\n        //B[C[A[i]]-1] = A[i];\n        printf(\"B[%d]=%d C[%d]=%d A[%d]=%d\\n\", C[A[i]]-1, A[i],\n                            A[i], C[A[i]], i, A[i]);\n        //C[A[i]]--;\n    }*/\n}\n//----------------------------------------------------------------------------\nINT16S getminptr(INT16U *A, INT16U N)\n{\n    INT16U i,min; INT16S ptr;\n\n    for (i=0, ptr=-1, min=32767; i<N; i++){\n        if (A[i]<min && pred(C[A[i]])!=i){\n            min=A[i];\n            ptr=i;\n        }\n    }\n    return ptr;\n}\n//----------------------------------------------------------------------------\nlong sum;\nvoid exchange(INT16U *x, INT16U *y)\n{\n    INT16U z;\n\n    z=*x, *x=*y, *y=z;\n    sum+=*x;\n    sum+=*y;\n    //printf(\"ex: %d<-->%d, sum:%ld\\n\", *y, *x, sum);\n}\n//----------------------------------------------------------------------------\nvoid prnary(INT16U *A, INT16U N)\n{\n    int j;\n\n    for (j=0; j<N; j++)\n        printf(\"%2d \", A[j]);\n    printf(\" sum:%ld\\n\", sum);\n}\n//----------------------------------------------------------------------------\nshort linklen(INT16U *A, INT16U val)\n{\n    int idx,n;\n\n    for (n=0, idx=val; ; n++){\n        idx=A[pred(C[idx])];\n        if (idx==val)\n            return n;\n    }\n}\n//----------------------------------------------------------------------------\nshort bgnlink(INT16U *A, INT16U val)\n{\n    int sum,idx,start;\n\n    for (start=idx=val; ; ){\n        idx=A[pred(C[idx])];\n        if (idx<start)\n            start=idx;\n        if (idx==val)\n            return start;\n    }\n}\n//----------------------------------------------------------------------------\nshort revcost(INT16U *A, INT16U val)\n{\n    int sum,idx,start;\n\n    val=bgnlink(A, val);\n    for (sum=idx=val; ; ){\n        idx=A[pred(C[idx])];\n        if (idx==val)\n            return sum;\n        sum+=idx;\n    }\n}\n//----------------------------------------------------------------------------\nshort exccost(INT16U *A, INT16U val, INT16U min)\n{\n    int sum,idx,porn;\n\n    if (val!=min)\n        sum=val+min;\n    else\n        sum=0;\n    for (porn=min, idx=val; ; ){\n        idx=A[pred(C[idx])];\n        if (idx==val)\n            return sum;\n        sum+=(idx+porn);\n    }\n}\n//----------------------------------------------------------------------------\nvoid duplication(INT16U *A, INT16U N)\n{\n    int i,j,k,n,a,ary[3];\n\n#ifdef DESKTOP\n    prnary(A, N);\n#endif\n    for (i=sum=0; i<pred(N); i++){\n        n=linklen(A, A[i]);\n        if (n==1){\n            j=pred(C[A[i]]);\n            exchange(&A[i], &A[j]);\n            //printf(\"ex:(%d<->%d), \", A[i], A[j]);\n        }\n#ifdef DESKTOP\n    }\n    printf(\"\\n\");\n#else\n    }\n#endif\n}\n//----------------------------------------------------------------------------\nlong mincostsort(INT16U *A, INT16U N)\n{\n    int ptr,i,j,min,ordptr,order[100];\n\n    duplication(A, N);\n    for (i=0,j=32000; i<N; i++)\n        if (A[i]<j)\n            j=A[i],min=i;\n    for (ordptr=0; 0<=(ptr=getminptr(A, N));){\n#ifdef DESKTOP\n    printf(\"[%d]\\n\", A[ptr]);\n#endif\n        order[ordptr++]=A[ptr];\n        //if (A[min]*2<A[ptr]){\n        if (exccost(A, A[ptr], min)<revcost(A, A[ptr])){\n            exchange(&A[min], &A[ptr]);\n            min=ptr;\n        }\n        while (pred(C[A[ptr]])!=ptr){\n            for (i=0; i<N; i++)\n                if (C[A[i]]==succ(ptr)){\n                    order[ordptr++]=A[i];\n                    if (ptr==min) min=i;\n                    exchange(&A[ptr], &A[i]);\n                    ptr=i;\n#ifdef DESKTOP\n                    //prnary(A, N);\n#endif\n                    break;\n                }\n        }\n    }\n#ifdef DESKTOP\n    for (i=0; i<ordptr; i++){\n        if (i) printf(\"->\");\n            printf(\"%d\", order[i]);\n    }\n    printf(\"\\n\");\n#endif\n    return sum;\n}\n//----------------------------------------------------------------------------\n/*\n*                                         *     *\n0 62 33 29 72 52 43 19 5  93 51 32  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51  5  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51 47  8 11 56  5 66 69 30 17 68  5\n0  5 33 29 72 52 43 19 32 93 51 47  8 11 56 62 66 69 30 17 68  0\n0  5 33 29 72 52 43 19 32 93  8 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 29 72 52  8 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33  8 72 52 29 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 11 72 52 29 19 32 93 43 47 51  8 56 62 66 69 30 17 68  8\n0  5 33 11 72  8 29 19 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29  8 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 69  8 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66  8 69 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 68 69 17  8  8\n0  5 33 11 72 19 29 30 32  8 43 47 51 52 56 62 66 68 69 17 93  8\n0  5  8 11 72 19 29 30 32 33 43 47 51 52 56 62 66 68 69 72 93  0\n0  5  8 11 17 19 29 30 32 33 43 47 51 52 56 62 66 68 69 17 93  0\n\n 1 80 50 70 40 20\n20 80 50 70 40  1\n20  1 50 70 40 80\n 1 20 50 70 40 80 21        20 40 50 70  1 80   41\n40 20 50 70  1 80 41        20 40 50  1 70 80   71\n40 20 50  1 70 80 71        20 40  1 50 70 80   51\n40 20  1 50 70 80 51        20  1 40 50 70 80   41\n 1 20 40 50 70 80 41         1 20 40 50 70 80   21\n\n\n5\n1 5 3 4 2\n7\n\n4\n4 3 2 1\n10\n*/\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nvoid input(FILE *file)\n{\n    long i,n,max,ave; INT16U *A, *B; char buffer[20];\n\n    fgets(buffer, sizeof(buffer)-1, file);\n    sscanf(buffer, \"%ld\", &n);\n    A = malloc(succ(n)*sizeof(INT16U));\n    B = malloc(succ(n)*sizeof(INT16U));\n    for (i=ave=max=0; i<n; i++){\n        fscanf(file, \"%hd\",  &A[i]);\n        if (max<A[i])\n            max=A[i];\n        ave+=A[i];\n    }\n    ave/=n;\n    C = malloc(succ(max)*sizeof(INT16U));\n    memset(C, 0, sizeof(INT16U)*succ(max));\n    CountingSort(A, B, n, max);\n    printf(\"%ld\\n\", mincostsort(A, n));\n#ifdef DESKTOP\n    for (i=0; i<n; i++){\n        if (i) printf(\" \");\n        printf(\"%hd\", A[i]);\n    }\n    printf(\"\\n\");\n#endif\n    free(A);\n    free(B);\n    free(C);\n}\n//============================================================================\n#ifndef DESKTOP\nint main()\n{\n    input(stdin);\n    return 0;\n}\n#endif"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 10001\ntypedef struct {\n  int sum;\n  int flag;\n} CC;\nCC C[N];\nint A[2000],B[2000];\nint main()\n{\n  int i,n,min=0,m,k,now,sum=0;\n  scanf(\"%d\",&n);\n  for(i=1;i<n+1;i++){\n    scanf(\"%d\",&A[i]);\n  }\n  \n  for(i=0;i<N;i++){\n    C[i].sum=0;\n    C[i].flag=0;\n  }\n  for(i=1;i<n+1;i++){\n    C[A[i]].sum+=1;\n    C[A[i]].flag+=1;\n  }\n  for(i=0;i<N;i++){\n    C[i].sum+=C[i-1].sum;\n  }\n\n  for(i=n+1;i>0;i--){\n    if(C[A[i]].flag==1){\n      k=i;\n      now=k;\n      m=0;\n      B[C[A[k]].sum]=A[k];\n      C[A[i]].flag=0;\n      min=A[k];\n      k=C[A[k]].sum;\n      while(now!=k){\n        if(m==0)sum+=A[now];\n        B[C[A[k]].sum]=A[k];\n        C[A[k]].flag=0;\n        sum+=A[k];\n        if(min>A[k])min=A[k];\n        k=C[A[k]].sum;\n        m+=1;\n      }\n      if(m>1)sum+=min*(m-1);\n      m=0;\n      min=0;\n    }\n  }\n  /*for(i=1;i<n;i++){\n    printf(\"%d \",B[i]);\n  }\n  printf(\"%d\",B[i]);*/\n  printf(\"%d\\n\",sum);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX 1000\n#define VMAX 10001\n\nint n,a[MAX],s;\nint b[MAX],t[VMAX];\n\nint min(int a,int b){\n    if(a<b)return a;\n    else return b;\n}\n\nint partition(int* a,int p,int r){\n    int i,j,x,t;\n    x=a[r];\n    i=p-1;\n    for(j=p;j<r;j++){\n        if(a[j]<=x){\n            i++;\n            t=a[i];\n            a[i]=a[j];\n            a[j]=t;\n        }\n    }\n    t=a[i+1];\n    a[i+1]=a[r];\n    a[r]=t;\n    return i+1;\n}\n\nvoid quicksort(int* a,int p,int r){\n    int q;\n    if(p<r){\n        q=partition(a,p,r);\n        quicksort(a,p,q-1);\n        quicksort(a,q+1,r);\n    }\n}\n\nint solve(){\n    int ans=0,v[MAX];\n    for(int i=0;i<n;i++){\n        b[i]=a[i];\n        v[i]=0;\n    }\n    quicksort(b,0,n-1);\n    for(int i=0;i<n;i++){\n        t[b[i]]=i;\n    }\n    for(int i=0;i<n;i++){\n        if(v[i])continue;\n        int cur=i;\n        int d=0;\n        int m=VMAX;\n        int an=0;\n        while(1){\n            v[cur]=1;\n            an++;\n            int e= a[cur];\n            m=min(m,e);\n            d+=e;\n            cur=t[e];\n            if(v[cur])break;\n        }\n        ans+=min(d+(an-2)*m,m+d+(an+1)*s);\n    }\n    return ans;\n}\n\nint main(void){\n\n    scanf(\"%d\",&n);\n    s=VMAX;\n    for(int  i=0;i<n;i++){\n        scanf(\"%d\",&a[i]);\n        s=min(s,a[i]);\n    }\n    printf(\"%d\\n\",solve());\n\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 1000\n#define VMAX 10000\n#define TRUE 1\n#define FALSE 0\n \nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\nvoid sort(){\n  int j,i,v;\n  for(i=1;i<n;i++){\n    v=B[i];\n    j=i-1;\n    while(j>=0 && B[j]>v){\n      B[j+1]=B[j];\n      j--;\n    }\n    B[j+1]=v;\n  }\n}\nint smini(int x,int y){\n  if(x>y)return y;\n  else return x;\n}\nint solve(){\n  int ans=0,V[MAX],i;\n  int cur,S,m,an,v;\n  for(i=0;i<n;i++){\n    B[i]=A[i];\n    V[i]=FALSE; // 0\n  }\n  sort();\n  for(i=0;i<n;i++)T[B[i]]=i;\n  for(i=0;i<n;i++){\n    if(V[i])continue;\n    cur=i;\n    S=0;\n    m=VMAX;\n    an=0;\n    while(1){\n      V[cur]=TRUE;\n      an++;\n      v=A[cur];\n      m=smini(m,v);\n      S+=v;\n      cur=T[v];\n      if(V[cur])break;\n    }\n    ans+=smini(S+(an-2)*m,m+S+(an+1)*s);\n}\n  return ans;\n}\n\n\n\nint main(){\n  int i,ans;\n  scanf(\"%d\",&n);\n  s=VMAX;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    s=smini(s,A[i]);//minimam\n}\n  ans=solve();\n  printf(\"%d\\n\",ans);\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX_N  1000\n\nvoid QuickSort(int, int);\nint Partition(int, int);\nint MinimumCost(int);\n\nstruct rist\n{\n  int n;\n  int p;\n} typedef rist;\n\nrist A[MAX_N];\n\nint main()\n{\n\tint i;\n\tint n;\n\tint cost;\n\t\n\tscanf(\"%d\", &n);\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &A[i].n);\n\t\tA[i].p = i;\n\t}\n\t\n\tQuickSort(0, n - 1);\n\tcost = MinimumCost(n);\n\t\n\tprintf(\"%d\\n\", cost);\n\t\n\treturn 0;\n}\n\nvoid QuickSort(int p, int r)\n{\n  int q;\n\n  if(p < r)\n    {\n      q = Partition(p, r);\n      QuickSort(p, q - 1);\n      QuickSort(q + 1, r);\n    }\n}\n\nint Partition(int p, int r)\n{\n\tint i, j;\n\trist tmp;\n\n\ti = p - 1;\n\tfor(j = p; j < r; j++)\n    {\n    \tif(A[j].n <= A[r].n)\n\t\t{\n\t \t\t i = i + 1;\n\t \t\t tmp = A[i];\n\t  \t\tA[i] = A[j];\n\t  \t\tA[j] = tmp;\n\t\t}\n    }\n\ttmp = A[i + 1];\n  \tA[i + 1] = A[r];\n  \tA[r] = tmp;\n  \n  \treturn i + 1;\n}\n\nint MinimumCost(int n)\n{\n\tint i;\n\tint tmp;\n\tint cost;\n\t\n\tfor(i = n - 1; i >= 0; i--)\n\t{\n\t\tif(A[i].p != i)\n\t\t{\n\t\t\tcost += A[i].n + A[A[i].p].n;\n\n\t\t\ttmp = A[A[i].p].p;\n\t\t\tA[A[i].p].p = A[i].p;\n\t\t\tA[i].p = tmp;\n\t\t}\n\t}\n\treturn cost;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\n//============================================================================\n#define pred(x) ((x)-1)\n#define succ(x) ((x)+1)\n//============================================================================\ntypedef unsigned char  INT8U;\ntypedef unsigned short INT16U;\ntypedef   signed short INT16S;\ntypedef long INT32;\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nINT16U *C;\n//----------------------------------------------------------------------------\nvoid CountingSort(INT16U *A, INT16U *B,  INT16U n, INT16U k)\n{\n    long i;\n\n    for (i = 0; i<n; i++)\n        C[A[i]]++;\n    for (i = 1; i<=k; i++)\n        C[i] += C[i-1];\n    // C holds position of A\n    // C[A[val]] = pred val position\n\n    /*for (i = 1; i<=k; i++)\n        printf(\"%d \", C[i]);\n    printf(\"\\n\");*/\n    /*printf(\"B[C[A[i]]-1] = A[i];\\n\");\n    for (i=n-1; 0<=i; i--){\n        //B[C[A[i]]-1] = A[i];\n        printf(\"B[%d]=%d C[%d]=%d A[%d]=%d\\n\", C[A[i]]-1, A[i],\n                            A[i], C[A[i]], i, A[i]);\n        //C[A[i]]--;\n    }*/\n}\n//----------------------------------------------------------------------------\nINT16S getminptr(INT16U *A, INT16U N)\n{\n    INT16U i,min; INT16S ptr;\n\n    for (i=0, ptr=-1, min=32767; i<N; i++){\n        if (A[i]<min && pred(C[A[i]])!=i){\n            min=A[i];\n            ptr=i;\n        }\n    }\n    return ptr;\n}\n//----------------------------------------------------------------------------\nlong SumValue;\nvoid exchange(INT16U *x, INT16U *y)\n{\n    INT16U z;\n\n    z=*x, *x=*y, *y=z;\n    SumValue+=*x;\n    SumValue+=*y;\n    //printf(\"ex: %d<-->%d, sum:%ld\\n\", *y, *x, sum);\n}\n//----------------------------------------------------------------------------\nvoid prnary(INT16U *A, INT16U N)\n{\n    int j;\n\n    for (j=0; j<N; j++)\n        printf(\"%2d \", A[j]);\n    printf(\" sum:%ld\\n\", SumValue);\n}\n//----------------------------------------------------------------------------\nshort linklen(INT16U *A, INT16U val)\n{\n    int idx,n;\n\n    for (n=0, idx=val; ; n++){\n        idx=A[pred(C[idx])];\n        if (idx==val)\n            return n;\n    }\n}\n//----------------------------------------------------------------------------\nshort bgnlink(INT16U *A, INT16U val)\n{\n    int sum,idx,start;\n\n    for (start=idx=val; ; ){\n        idx=A[pred(C[idx])];\n        if (idx<start)\n            start=idx;\n        if (idx==val)\n            return start;\n    }\n}\n//----------------------------------------------------------------------------\nlong revcost(INT16U *A, INT16U val)\n{\n    int sum,idx,start;\n\n    val=bgnlink(A, val);\n    for (sum=0, idx=val; ; ){\n        idx=A[pred(C[idx])];\n        if (idx==val)\n            return sum;\n        sum+=(idx+val);\n    }\n}\n//----------------------------------------------------------------------------\nlong exccost(INT16U *A, INT16U val, INT16U min)\n{\n    int sum,idx,porn;\n\n    if (val!=min)\n        sum=val+min;\n    else\n        sum=0;\n    for (porn=min, idx=val; ; ){\n        idx=A[pred(C[idx])];\n        sum+=(idx+porn);\n        if (idx==val)\n            return sum;\n    }\n}\n//----------------------------------------------------------------------------\nvoid duplication(INT16U *A, INT16U N)\n{\n    int i,j,k,n,a,ary[3];\n\n#ifdef DESKTOP\n    prnary(A, N);\n#endif\n    for (i=SumValue=0; i<pred(N); i++){\n        n=linklen(A, A[i]);\n        if (n==1){\n            j=pred(C[A[i]]);\n            exchange(&A[i], &A[j]);\n            //printf(\"ex:(%d<->%d), \", A[i], A[j]);\n        }\n#ifdef DESKTOP\n    }\n    printf(\"\\n\");\n#else\n    }\n#endif\n}\n//----------------------------------------------------------------------------\nlong mincostsort(INT16U *A, INT16U N)\n{\n    int ptr,i,j,min,ordptr,order[100];\n\n    duplication(A, N);\n    for (i=0,j=32000; i<N; i++)\n        if (A[i]<j)\n            j=A[i],min=i;\n    for (ordptr=0; 0<=(ptr=getminptr(A, N));){\n#ifdef DESKTOP\n    printf(\"[%d]\\n\", A[ptr]);\n        //order[ordptr++]=A[ptr];\n#endif\n        //if (A[min]*2<A[ptr]){\n        if (exccost(A, A[ptr], A[min])<revcost(A, A[ptr])){\n            exchange(&A[min], &A[ptr]);\n            min=ptr;\n        }\n        while (pred(C[A[ptr]])!=ptr){\n            for (i=0; i<N; i++)\n                if (C[A[i]]==succ(ptr)){\n                    order[ordptr++]=A[i];\n                    if (ptr==min) min=i;\n                    exchange(&A[ptr], &A[i]);\n                    ptr=i;\n#ifdef DESKTOP\n                    //prnary(A, N);\n#endif\n                    break;\n                }\n        }\n    }\n#ifdef DESKTOP\n    /*for (i=0; i<ordptr; i++){\n        if (i) printf(\"->\");\n            printf(\"%d\", order[i]);\n    }\n    printf(\"\\n\");*/\n#endif\n    return SumValue;\n}\n//----------------------------------------------------------------------------\n/*\n*                                         *     *\n0 62 33 29 72 52 43 19 5  93 51 32  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51  5  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51 47  8 11 56  5 66 69 30 17 68  5\n0  5 33 29 72 52 43 19 32 93 51 47  8 11 56 62 66 69 30 17 68  0\n0  5 33 29 72 52 43 19 32 93  8 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 29 72 52  8 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33  8 72 52 29 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 11 72 52 29 19 32 93 43 47 51  8 56 62 66 69 30 17 68  8\n0  5 33 11 72  8 29 19 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29  8 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 69  8 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66  8 69 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 68 69 17  8  8\n0  5 33 11 72 19 29 30 32  8 43 47 51 52 56 62 66 68 69 17 93  8\n0  5  8 11 72 19 29 30 32 33 43 47 51 52 56 62 66 68 69 72 93  0\n0  5  8 11 17 19 29 30 32 33 43 47 51 52 56 62 66 68 69 17 93  0\n\n 1 80 50 70 40 20\n20 80 50 70 40  1\n20  1 50 70 40 80\n 1 20 50 70 40 80 21        20 40 50 70  1 80   41\n40 20 50 70  1 80 41        20 40 50  1 70 80   71\n40 20 50  1 70 80 71        20 40  1 50 70 80   51\n40 20  1 50 70 80 51        20  1 40 50 70 80   41\n 1 20 40 50 70 80 41         1 20 40 50 70 80   21\n\n\n5\n1 5 3 4 2\n7\n\n4\n4 3 2 1\n10\n*/\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nvoid input(FILE *file)\n{\n    long i,n,max,ave; INT16U *A, *B; char buffer[20];\n\n    fgets(buffer, sizeof(buffer)-1, file);\n    sscanf(buffer, \"%ld\", &n);\n    A = malloc(succ(n)*sizeof(INT16U));\n    B = malloc(succ(n)*sizeof(INT16U));\n    for (i=ave=max=0; i<n; i++){\n        fscanf(file, \"%hd\",  &A[i]);\n        if (max<A[i])\n            max=A[i];\n        ave+=A[i];\n    }\n    ave/=n;\n    C = malloc(succ(max)*sizeof(INT16U));\n    memset(C, 0, sizeof(INT16U)*succ(max));\n    CountingSort(A, B, n, max);\n    printf(\"%ld\\n\", mincostsort(A, n));\n#ifdef DESKTOP\n    for (i=0; i<n; i++){\n        if (i) printf(\" \");\n        printf(\"%hd\", A[i]);\n    }\n    printf(\"\\n\");\n#endif\n    free(A);\n    free(B);\n    free(C);\n}\n//============================================================================\n#ifndef DESKTOP\nint main()\n{\n    input(stdin);\n    return 0;\n}\n#endif"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define MAX 1000\n#define VMAX 10000\n\nint n,A[MAX],s,B[MAX],T[VMAX+1];\n\nint partition(int A[],int p,int r){\n  int i,j,x,t;\n  x=A[r];\n  i=p-1;\n  for(j=p;j<r;j++){\n    if(A[j]<=x){\n      i=i+1;\n      t=A[i];\n      A[i]=A[j];\n      A[j]=t;\n    }\n  }\n  t=A[i+1];\n  A[i+1]=A[r];\n  A[r]=t;\n  return i+1;\n}\n\nvoid quicksort(int A[],int p,int r){\n  int q;\n  if(p<r){\n    q=partition(A,p,r);\n    quicksort(A,p,q-1);\n    quicksort(A,q+1,r);\n  }\n}\n\nint solve(){\n  int i,S,c,an,ans=0,m,v;\n  int V[MAX];\n\n  for(i=0;i<n;i++){\n    B[i]=A[i];\n    V[i]=0;\n  }\n  quicksort(B,0,n-1);\n  for(i=0;i<n;i++){\n    T[B[i]]=i;\n  }\n  for(i=0;i<n;i++){\n    if(V[i])continue;\n    c=i;\n    S=0;\n    m=VMAX;\n    an=0;\n    while(1){\n      V[c]=1;\n      an++;\n      v=A[c];\n      m=fmin(m,v);\n      S+=v;\n      c=T[v];\n      if(V[c])break;\n    }\n    ans+=fmin(S+(an-2)*m,m+S+(an+1)*s);\n  }\n  return ans;\n}\n\nint main(){\n  int i,ans;\n\n  scanf(\"%d\",&n);\n  s=VMAX;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    s=fmin(s,A[i]);\n  }\n  ans=solve();\n  printf(\"%d\\n\",ans);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define true 1\n#define false 0\n#define MAX 1000\n#define VMAX 10000\n\nint n, A[MAX],s;\nint B[MAX], T[VMAX+1];\n\nvoid sort(int A[]){\n\tint flag = 1;\n\tint tmp;\n\twhile(flag == 1){\n\t\tflag = 0;\n\t\tfor(int j = n-1; j >= 1; j--){\n\t\t\tif(A[j] < A[j-1]){\n\t\t\t\ttmp = A[j];\n\t\t\t\tA[j] = A[j-1];\n\t\t\t\tA[j-1] = tmp;\n\t\t\t\tflag = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint min(int a, int b){\n\tif(a < b){return a;}\n\telse {return b;}\n}\n\nint solve(){\n\tint ans = 0;\n\t\n\tbool V[MAX];\n\tfor(int i = 0; i < n; i++){\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B);\n\tfor(int i = 0; i< n; i++){\n\t\tT[B[i]] = i;\n\t}\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tif(V[i]){continue;}\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an=0;\n\t\twhile(1){\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif(V[cur]){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n\t}\n\t\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\ts = VMAX;\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &A[i]);\n\t\ts = min(s, A[i]);\n\t}\n\tint ans = solve();\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\n//============================================================================\n#define pred(x) ((x)-1)\n#define succ(x) ((x)+1)\n//============================================================================\ntypedef unsigned char  INT8U;\ntypedef unsigned short INT16U;\ntypedef   signed short INT16S;\ntypedef long INT32;\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nINT16U *C;\n//----------------------------------------------------------------------------\nvoid CountingSort(INT16U *A, INT16U *B,  INT16U n, INT16U k)\n{\n    long i;\n\n    for (i = 0; i<n; i++)\n        C[A[i]]++;\n    for (i = 1; i<=k; i++)\n        C[i] += C[i-1];\n    // C holds position of A\n    // C[A[val]] = pred val position\n\n    /*for (i = 1; i<=k; i++)\n        printf(\"%d \", C[i]);\n    printf(\"\\n\");*/\n    /*printf(\"B[C[A[i]]-1] = A[i];\\n\");\n    for (i=n-1; 0<=i; i--){\n        //B[C[A[i]]-1] = A[i];\n        printf(\"B[%d]=%d C[%d]=%d A[%d]=%d\\n\", C[A[i]]-1, A[i],\n                            A[i], C[A[i]], i, A[i]);\n        //C[A[i]]--;\n    }*/\n}\n//----------------------------------------------------------------------------\nINT16S getminptr(INT16U *A, INT16U N)\n{\n    INT16U i,min; INT16S ptr;\n\n    for (i=0, ptr=-1, min=32767; i<N; i++){\n        if (A[i]<min && pred(C[A[i]])!=i){\n            min=A[i];\n            ptr=i;\n        }\n    }\n    return ptr;\n}\n//----------------------------------------------------------------------------\nlong SumValue;\nvoid exchange(INT16U *x, INT16U *y)\n{\n    INT16U z;\n\n    z=*x, *x=*y, *y=z;\n    SumValue+=*x;\n    SumValue+=*y;\n    //printf(\"ex: %d<-->%d, sum:%ld\\n\", *y, *x, sum);\n}\n//----------------------------------------------------------------------------\nvoid prnary(INT16U *A, INT16U N)\n{\n    int j;\n\n    for (j=0; j<N; j++)\n        printf(\"%2d \", A[j]);\n    printf(\" sum:%ld\\n\", SumValue);\n}\n//----------------------------------------------------------------------------\nshort linklen(INT16U *A, INT16U val)\n{\n    int idx,n;\n\n    for (n=0, idx=val; ; n++){\n        idx=A[pred(C[idx])];\n        if (idx==val)\n            return n;\n    }\n}\n//----------------------------------------------------------------------------\nshort bgnlink(INT16U *A, INT16U val)\n{\n    int sum,idx,start;\n\n    for (start=idx=val; ; ){\n        idx=A[pred(C[idx])];\n        if (idx<start)\n            start=idx;\n        if (idx==val)\n            return start;\n    }\n}\n//----------------------------------------------------------------------------\nshort revcost(INT16U *A, INT16U val)\n{\n    int sum,idx,start;\n\n    val=bgnlink(A, val);\n    for (sum=0, idx=val; ; ){\n        idx=A[pred(C[idx])];\n        if (idx==val)\n            return sum;\n        sum+=(idx+val);\n    }\n}\n//----------------------------------------------------------------------------\nshort exccost(INT16U *A, INT16U val, INT16U min)\n{\n    int sum,idx,porn;\n\n    if (val!=min)\n        sum=val+min;\n    else\n        sum==0;\n    for (porn=min, idx=val; ; ){\n        idx=A[pred(C[idx])];\n        if (idx==val)\n            return sum;\n        sum+=(idx+porn);\n    }\n}\n//----------------------------------------------------------------------------\nvoid duplication(INT16U *A, INT16U N)\n{\n    int i,j,k,n,a,ary[3];\n\n#ifdef DESKTOP\n    prnary(A, N);\n#endif\n    for (i=SumValue=0; i<pred(N); i++){\n        n=linklen(A, A[i]);\n        if (n==1){\n            j=pred(C[A[i]]);\n            exchange(&A[i], &A[j]);\n            //printf(\"ex:(%d<->%d), \", A[i], A[j]);\n        }\n#ifdef DESKTOP\n    }\n    printf(\"\\n\");\n#else\n    }\n#endif\n}\n//----------------------------------------------------------------------------\nlong mincostsort(INT16U *A, INT16U N)\n{\n    int ptr,i,j,min,ordptr,order[100];\n\n    duplication(A, N);\n    for (i=0,j=32000; i<N; i++)\n        if (A[i]<j)\n            j=A[i],min=i;\n    for (ordptr=0; 0<=(ptr=getminptr(A, N));){\n#ifdef DESKTOP\n        printf(\"[%d]\\n\", A[ptr]);\n#endif\n        order[ordptr++]=A[ptr];\n        if (exccost(A, A[ptr], A[min])<revcost(A, A[ptr])){\n            exchange(&A[min], &A[ptr]);\n            min=ptr;\n        }\n        while (pred(C[A[ptr]])!=ptr){\n            for (i=0; i<N; i++)\n                if (C[A[i]]==succ(ptr)){\n                    order[ordptr++]=A[i];\n                    if (ptr==min) min=i;\n                    exchange(&A[ptr], &A[i]);\n                    ptr=i;\n#ifdef DESKTOP\n                    //prnary(A, N);\n#endif\n                    break;\n                }\n        }\n    }\n#ifdef DESKTOP\n    for (i=0; i<ordptr; i++){\n        if (i) printf(\"->\");\n            printf(\"%d\", order[i]);\n    }\n    printf(\"\\n\");\n#endif\n    return SumValue;\n}\n//----------------------------------------------------------------------------\n/*\n*                                         *     *\n0 62 33 29 72 52 43 19 5  93 51 32  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51  5  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51 47  8 11 56  5 66 69 30 17 68  5\n0  5 33 29 72 52 43 19 32 93 51 47  8 11 56 62 66 69 30 17 68  0\n0  5 33 29 72 52 43 19 32 93  8 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 29 72 52  8 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33  8 72 52 29 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 11 72 52 29 19 32 93 43 47 51  8 56 62 66 69 30 17 68  8\n0  5 33 11 72  8 29 19 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29  8 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 69  8 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66  8 69 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 68 69 17  8  8\n0  5 33 11 72 19 29 30 32  8 43 47 51 52 56 62 66 68 69 17 93  8\n0  5  8 11 72 19 29 30 32 33 43 47 51 52 56 62 66 68 69 72 93  0\n0  5  8 11 17 19 29 30 32 33 43 47 51 52 56 62 66 68 69 17 93  0\n\n 1 80 50 70 40 20\n20 80 50 70 40  1\n20  1 50 70 40 80\n 1 20 50 70 40 80 21        20 40 50 70  1 80   41\n40 20 50 70  1 80 41        20 40 50  1 70 80   71\n40 20 50  1 70 80 71        20 40  1 50 70 80   51\n40 20  1 50 70 80 51        20  1 40 50 70 80   41\n 1 20 40 50 70 80 41         1 20 40 50 70 80   21\n\n\n5\n1 5 3 4 2\n7\n\n4\n4 3 2 1\n10\n*/\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nvoid input(FILE *file)\n{\n    long i,n,max,ave; INT16U *A, *B; char buffer[20];\n\n    fgets(buffer, sizeof(buffer)-1, file);\n    sscanf(buffer, \"%ld\", &n);\n    A = malloc(succ(n)*sizeof(INT16U));\n    B = malloc(succ(n)*sizeof(INT16U));\n    for (i=ave=max=0; i<n; i++){\n        fscanf(file, \"%hd\",  &A[i]);\n        if (max<A[i])\n            max=A[i];\n        ave+=A[i];\n    }\n    ave/=n;\n    C = malloc(succ(max)*sizeof(INT16U));\n    memset(C, 0, sizeof(INT16U)*succ(max));\n    CountingSort(A, B, n, max);\n    printf(\"%ld\\n\", mincostsort(A, n));\n#ifdef DESKTOP\n    for (i=0; i<n; i++){\n        if (i) printf(\" \");\n        printf(\"%hd\", A[i]);\n    }\n    printf(\"\\n\");\n#endif\n    free(A);\n    free(B);\n    free(C);\n}\n//============================================================================\n#ifndef DESKTOP\nint main()\n{\n    input(stdin);\n    return 0;\n}\n#endif"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint swap_log[1000][2];\n\nvoid swap(int *A, int i, int j) {\n  int temp;\n  temp = A[i];\n  A[i] = A[j];\n  A[j] = temp;\n}\n\nvoid Merge(int *A, int left, int mid, int right) {\n  int n1,n2,*L,*R,i,j,k;\n  n1 = mid -left;\n  n2 = right - mid;\n  L = (int*)malloc(sizeof(int) * (n1+1));\n  R = (int*)malloc(sizeof(int) * (n2+1));\n  for (i = 0; i< n1; i++) L[i] = A[left+i];\n  for (i = 0; i < n2; i++) R[i] = A[mid+i];\n  L[n1] = INT_MAX; R[n2] = INT_MAX;\n  i = 0;j = 0;\n  for(k = left; k < right; k++) {\n    if (L[i] < R[j]) {\n      A[k] = L[i];\n      i++;\n    }else {\n      A[k] = R[j];\n      j++;\n    }\n  }\n  free(L);\n  free(R);\n}\n\nvoid Merge_Sort(int *A, int left, int right) {\n  if(left+1 < right) {\n    int mid = (left + right)/2;\n    Merge_Sort(A,left,mid);\n    Merge_Sort(A,mid,right);\n    Merge(A,left,mid,right);\n  }\n}\nlong step_sort(int *w, int *w1, int i) {\n  int j,k;\n  long sum = 0;\n  k = 0;\n  while(w[i] != w1[i]) {\n    j = 0;\n    while (w[j] != w1[i]) j++;\n    sum += w[i]+w[j];\n    swap(w,i,j);\n    swap_log[k][0] = i; swap_log[k][1] = j;\n    i = j;\n    k++;\n  }\n  swap_log[k][0] = 0; swap_log[k][1] = 0;\n  return sum;\n}\n\nint search_min(int *w, int *w1,int n) {\n  int i,j;\n  i = 0;\n  while(1) {\n    j = 0;\n    while(w[j] != w1[i]) j++;\n    if(i != j) break;\n    i++;\n    if(i >= n) return n;\n  }\n  return j;\n}\n\nlong run_log(int *w) {\n  int i = 0;\n  long sum = 0;\n  while(swap_log[i][0] != swap_log[i][1]) {\n    sum += w[swap_log[i][0]]+w[swap_log[i][1]];\n    swap(w,swap_log[i][0],swap_log[i][1]);\n    i++;\n  }\n  return sum;\n}\n\nlong sub_sort(int *w, int *w1, int i) {\n  long sum;\n\n  if(w[0] != w1[0]) return LONG_MAX;\n  int j = 0;\n  while(w[i] != w1[j]) j++;\n  sum = w[i] + w[0];\n  swap(w,i,0);\n  sum += run_log(w);\n  sum += w[0] + w[j];\n  swap(w,0,j);\n  \n  return sum;\n}\n\nlong repeat_sort(int *w, int *w1, int n,long now) {\n  int i;\n  int a1[n];\n  long v1,v2;\n  for (i = 0; i < n; i++) a1[i]=w[i];\n  i = search_min(w,w1,n);\n  if(i == n) return now;\n  v1 = step_sort(w,w1,i);\n  v2 = sub_sort(a1,w1,i);\n  long min = (v1 < v2) ? v1:v2;\n  return repeat_sort(w,w1,n,now+min);\n}\n\nlong much_sort(int *w, int *w1, int n) {\n  int i,j;\n  long sum = 0;\n  char *checked = (char*)calloc(n,sizeof(char));\n  i = 0;\n  while(i < n) {\n    j = 0;\n    while(w[j] != w1[i]) j++;\n    if(i != j) {\n      if(w1[j] ==  w[i]) {\n\tsum += w[i] + w[j];\n\tswap(w,i,j);\n      }\n    }\n    checked[i]=1;checked[j]=1;\n    while(i < n && checked[i]!=0)i++;\n  }\n  free(checked);\n  return sum;\n}\n\nint main()\n{\n  int i,n,*w,*w2;\n  long sum;\n  scanf(\"%d\",&n);\n  w = (int*)malloc(sizeof(int) * n);\n  w2 = (int*)malloc(sizeof(int) * n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\",w+i);\n    w2[i] = w[i];\n  }\n  Merge_Sort(w2,0,n);\n  \n  sum = much_sort(w,w2,n);\n  sum += repeat_sort(w,w2,n,0);\n  printf(\"%ld\\n\",sum);\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 10001\ntypedef struct {\n  int sum;\n  int flag;\n} CC;\nCC C[N];\nint A[1000],B[1000];\nint main()\n{\n  int i,n,min=0,m,k,now,sum=0;\n  scanf(\"%d\",&n);\n  for(i=1;i<n+1;i++){\n    scanf(\"%d\",&A[i]);\n  }\n  \n  for(i=0;i<N;i++){\n    C[i].sum=0;\n    C[i].flag=0;\n  }\n  for(i=1;i<n+1;i++){\n    C[A[i]].sum+=1;\n    C[A[i]].flag+=1;\n  }\n  for(i=0;i<N;i++){\n    C[i].sum+=C[i-1].sum;\n  }\n\n  for(i=0;i<n;i++){\n    if(C[A[i]].flag==1){\n      k=i;\n      now=k;\n      m=0;\n      B[C[A[k]].sum]=A[k];\n      C[A[i]].flag=0;\n      min=A[k];\n      k=C[A[k]].sum;\n      while(A[now]!=A[k]){\n        if(m==0)sum+=A[now];\n        B[C[A[k]].sum]=A[k];\n        C[A[k]].flag=0;\n        sum+=A[k];\n        if(min>A[k])min=A[k];\n        k=C[A[k]].sum;\n        m+=1;\n      }\n      if(m>1)sum+=min*(m-1);\n      m=0;\n      min=0;\n    }\n  }\n  /*for(i=1;i<n;i++){\n    printf(\"%d \",B[i]);\n  }\n  printf(\"%d\",B[i]);*/\n  printf(\"%d\\n\",sum);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid swap(int* a,int* b){\n  int tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\n\nint n;\nint A[1000];\nint B[1000];\n\nint search(int x){\n  int i;\n  for(i=0;i<n;i++){\n    if(A[i]==x)return i;\n  }\n}\n\nint main(){\n  int i,j,ans,x,y;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n  \n  for(i=n-1;i>0;i--){\n    for(j=0;j<i;j++){\n      if(B[j]>B[j+1])swap(&B[j],&B[j+1]);\n    }\n  }\n \n  ans=0;\n  \n  while(1){\n    x=1001;\n    for(i=0;i<n;i++){\n      if(A[i]==B[i])continue;\n      if(x>A[i])x=A[i];\n    }\n    if(x==1001)break;\n\n    x=search(x);\n    y=search(B[x]);\n\n    swap(&A[x],&A[y]);\n    ans+=(A[x]+A[y]);\n  }\n  printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C",
    "code": "\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define Max  1000\n#define vMax 10000\n\nint n, a[Max], s;\nint b[Max], t[vMax + 1];\n\n\nint partition(int a[], int p, int r){\n  int i, j;\n  int t, x;\n  x = a[r];\n  i = p - 1;\n\n  for(j = p ; j < r ; j++){\n    if(a[j] <= x){\n      i++;\n      t = a[i];\n      a[i] = a[j];\n      a[j] = t;\n    }\n  }\n\n  t = a[i + 1];\n  a[i + 1] = a[r];\n  a[r] = t;\n\n  return i + 1;\n}\n\nvoid quickSort(int a[], int p, int r){\n  int q;\n  if(p < r){\n    q = partition(a, p, r);\n    quickSort(a, p, q - 1);\n    quickSort(a, q + 1, r);\n  }\n}\n\n\n\nint solve(){\n  int i,ans = 0, cur, S, m, an, v;\n\n  int V[Max];\n  for(i = 0 ; i < n ; i++){\n    b[i] = a[i];\n    V[i] = 0;\n  }\n\n  quickSort(b, 0, n - 1);\n\n  for(i = 0 ; i < n ; i++) t[b[i]] = i;\n  for(i = 0 ; i < n ; i++){\n    if(V[i]) continue;\n    cur = i;\n    S = 0;\n    m = vMax;\n    an = 0;\n    while(1){\n      V[cur] = 1;\n      an++;\n      v = a[cur];\n\n      if(v < m) m = v;\n\n      S += v;\n      cur = t[v];\n      if(V[cur]) break;\n    }\n    if(S + (an -2) * m < m + S + (an + 1) * s) ans += S + (an -2) * m;\n    else if(S + (an -2) * m > m + S + (an + 1) * s) ans +=  m + S + (an + 1) * s;\n  }\n  return ans;\n}\n\n\nint main(){\n  int i;\n\n  scanf(\"%d\", &n);\n  s = vMax;\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\", &a[i]);\n    if(a[i] < s) s = a[i];\n}\n\n  int ans = solve();\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\nusing namespace std;\nint main(){\n  int n,ans=0,t[1000],u[1000];\n  bool visited[1000];\n  map<int,int> change;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>t[i];\n    change[t[i]]=i;\n    u[i]=t[i];\n    visited[i]=false;\n  }\n  sort(u,u+n);\n  for(int i=0;i<n;i++){   \n    int w=i,x=0,y=0,z=10000;\n    while(!visited[w]){\n      z=min(z,t[w]);\n      y+=t[w];\n      x++;\n      visited[w]=true;\n      w=change[u[w]];\n    }\n    if(x>=2)ans+=min(y+z+u[0]*(x+1),y+z*(x-2));\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX 1000\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\n\nint A[MAX] = {0};\nint B[MAX] = {0};\nint T[10000 + 1];\nint n, s;\n\nint partition(int A[], int p, int r) {\n\tint x, i, j, tmp;\n\tx = A[r];\n\ti = p - 1;\n\n\tfor (j = p; j < r; ++j) {\n\t\tif (A[j] <= x) {\n\t\t\t++i;\n\t\t\ttmp = A[i];\n\t\t\tA[i] = A[j];\n\t\t\tA[j] = tmp;\n\t\t}\n\t}\n\ttmp = A[i+1];\n\tA[i+1] = A[r];\n\tA[r] = tmp;\n\treturn i + 1;\n}\n\nvoid quicksort(int A[], int p, int r) {\n\tint q;\n\tif (p < r) {\n\t\tq = partition(A, p, r);\n\t\tquicksort(A, p, q-1);\n\t\tquicksort(A, q+1, r);\n\t}\n}\n\nint solve() {\n\tint ans = 0;\n\tint i, cur, S, m, an, v;\n\tshort V[MAX] = {0};\n\n\tfor (i = 0; i < n; ++i) {\n\t\tB[i] = A[i];\n\t\tV[i] = 0;\n\t}\n\tquicksort(B, 0, n-1);\n\t/* for (i = 0; i < n; ++i) { */\n\t/* \tprintf(\"%d \", B[i]); */\n\t/* } */\n\tprintf(\"\\n\");\n\n\tfor (i = 0; i < n; ++i) T[B[i]] = i;\n\tfor (i = 0; i < n; ++i) {\n\t\tif (V[i]) continue;\n\t\tcur = i;\n\t\tS = 0;\n\t\tm = INT_MAX;\n\t\tan = 0;\n\t\twhile (1) {\n\t\t\tV[cur] = 1;\n\t\t\tan++;\n\t\t\tv = A[cur];\n\t\t\tm = MIN(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\t//\tprintf(\"i = %d, cur = %d, v = %d, S = %d, an = %d, ans = %d\\n\", i, cur, v, S, an, ans);\n\t\t\tif (V[cur]) break;\n\t\t}\n\t\tans += MIN(S + (an - 2) * m, m + S + (an + 1) * s);\n\t}\n\n\treturn ans;\n}\n\nint main(void) {\n\tint i;\n\tscanf(\"%d\", &n);\n\ts = INT_MAX;\n\t\n\tfor (i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &A[i]);\n\t\tif (s > A[i]) s = A[i];\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "21\n0 62 33 29 72 52 43 19 5 93 51 32 8 11 56 47 66 69 30 17 68"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nvoid swap(int *,int *);\n\nint main(int argc, char const *argv[]) {\n\n  int i,j;\n  int n;\n  int w[10000];\n  int min = 200000;\n  int key;\n  int memj;\n  int flag = 0;\n  int min_sum = 0;\n\n  scanf(\"%d\",&n);\n\n  for( i = 0 ; i < n ; i++ ){\n    scanf(\"%d\",&w[i]);\n  }\n\n  for( i = 0 ; i < n ; i++ ){\n    key = w[i];\n\n    for( j = i+1 ; j < n ; j++ ){\n\n      if( key > w[j] ){\n        memj = j;\n        key = w[j];\n\n        flag = 1;\n      }\n\n\n    }\n\n\n    if( flag ){\n      min_sum += w[i]+w[memj];\n      swap(&w[i],&w[memj]);\n      flag = 0;\n    }\n\n\n  }\n\n  printf(\"%d\\n\",min_sum);\n\n  return 0;\n}\n\n\n\nvoid swap(int *x,int *y){\n\n  int temp;\n\n  temp = *x;\n  *x = *y;\n  *y = temp;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define min(a, b) (a)<(b)?(a):(b)\n\nint compar(const void *a, const void *b){\n  return *((int*)a)-*((int*)b);\n}\n\nint main()\n{\n  int i, j, k, n, wmin, cost = 0;\n  scanf(\"%d\", &n);\n  int w[n], c[n], u[n];\n  for (i=0; i<n; i++) {\n    scanf(\"%d\", w+i);\n    u[i] = w[i];\n    c[i] = 0;\n    if (i==0 || wmin>w[i]) wmin=w[i];\n  }\n  qsort((void*)u, n, sizeof(int), compar);\n  int loop[n], xi;\n  k = n;\n  while (k>0) {\n    for (i=0; c[i]==1; i++);\n    c[i]=1;\n    k--;\n    loop[0]=i;\n    int len=1;\n    while (1) {\n      for (xi=0; u[xi]!=w[i]; xi++);   // xi = u.index(w[i])\n      if (c[xi]==1) break;\n      c[xi] = 1;\n      k--;\n      loop[len++]=xi;\n      i = xi;\n    }\n\n    if (len==1) continue;\n    int lmin=w[loop[0]];\n\n    for (i=0; i<len; i++) {\n      if (lmin>w[loop[i]]) lmin=w[loop[i]];\n      cost += w[loop[i]];\n    }\n    if (lmin==wmin) cost += lmin*(len-2);\n    else            cost += min(lmin+(len+1)*wmin, lmin*(len-2));\n  }\n  printf(\"%d\\n\", cost);\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX  1000\n#define MAX_1 10000\n\n\nint n, a[MAX], s;\nint b[MAX], T[MAX_1 + 1];\n\n\nint partition(int a[], int p, int r){\n  int i, j;\n  int t, x;\n  x = a[r];\n  i = p - 1;\n\n  for( j = p ; j < r ; j++ ){\n    if(a[j] <= x){\n      i++;\n      t = a[i];\n      a[i] = a[j];\n      a[j] = t;\n    }\n  }\n\n  t = a[i + 1];\n  a[i + 1] = a[r];\n  a[r] = t;\n\n  return i + 1;\n}\nvoid quickS(int a[], int p, int r){\n  int q;\n  if(p < r){\n    q = partition(a, p, r);\n    quickS(a, p, q - 1);\n    quickS(a, q + 1, r);\n  }\n}\n\n\nint solve(){\n  int i, c, S, m, an, v,   ans = 0 ;\n\n  int V[MAX];\n  for(i = 0 ; i < n ; i++){\n    b[i] = a[i];\n    V[i] = 0;\n  }\n\n  quickS(b, 0, n - 1);\n\n  for(i = 0 ; i < n ; i++) T[b[i]] = i;\n  for(i = 0 ; i < n ; i++){\n    if(V[i]) continue;\n    c = i;\n    S = 0;\n    m = MAX_1;\n    an = 0;\n    while(1){\n      V[c] = 1;\n      an++;\n      v = a[c];\n\n      if(v < m) m = v;\n\n      S += v;\n      c = T[v];\n      if(V[c]) break;\n    }\n    if(S + (an -2) * m < m + S + (an + 1) * s) ans += S + (an -2) * m;\n    else ans +=  m + S + (an + 1) * s;\n  }\n  return ans;\n}\n\n\n\nint main(){\n  int i;\n\n  scanf(\"%d\", &n);\n  s = MAX_1;\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\", &a[i]);\n    if(a[i] < s) s = a[i];\n  }\n\n  int ans = solve();\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n \nint swap_log[1000][2];\n \nvoid swap(int *A, int i, int j) {\n  int temp;\n  temp = A[i];\n  A[i] = A[j];\n  A[j] = temp;\n}\n \nvoid Merge(int *A, int left, int mid, int right) {\n  int n1,n2,*L,*R,i,j,k;\n  n1 = mid -left;\n  n2 = right - mid;\n  L = (int*)malloc(sizeof(int) * (n1+1));\n  R = (int*)malloc(sizeof(int) * (n2+1));\n  for (i = 0; i< n1; i++) L[i] = A[left+i];\n  for (i = 0; i < n2; i++) R[i] = A[mid+i];\n  L[n1] = INT_MAX; R[n2] = INT_MAX;\n  i = 0;j = 0;\n  for(k = left; k < right; k++) {\n    if (L[i] < R[j]) {\n      A[k] = L[i];\n      i++;\n    }else {\n      A[k] = R[j];\n      j++;\n    }\n  }\n  free(L);\n  free(R);\n}\n \nvoid Merge_Sort(int *A, int left, int right) {\n  if(left+1 < right) {\n    int mid = (left + right)/2;\n    Merge_Sort(A,left,mid);\n    Merge_Sort(A,mid,right);\n    Merge(A,left,mid,right);\n  }\n}\nlong step_sort(int *w, int *w1, int i) {\n  int j,k;\n  long sum = 0;\n  k = 0;\n  while(w[i] != w1[i]) {\n    j = 0;\n    while (w[j] != w1[i]) j++;\n    sum += w[i]+w[j];\n    swap(w,i,j);\n    swap_log[k][0] = i; swap_log[k][1] = j;\n    i = j;\n    k++;\n  }\n  swap_log[k][0] = 0; swap_log[k][1] = 0;\n  return sum;\n}\n \nint search_min(int *w, int *w1,int n) {\n  int i,j;\n  i = 0;\n  while(1) {\n    j = 0;\n    while(w[j] != w1[i]) j++;\n    if(i != j) break;\n    i++;\n    if(i >= n) return n;\n  }\n  return j;\n}\n \nlong run_log(int *w) {\n  int i = 0;\n  long sum = 0;\n  while(swap_log[i][0] != swap_log[i][1]) {\n    sum += w[swap_log[i][0]]+w[swap_log[i][1]];\n    swap(w,swap_log[i][0],swap_log[i][1]);\n    i++;\n  }\n  return sum;\n}\n \nlong sub_sort(int *w, int *w1, int i) {\n  long sum;\n \n  if(w[0] != w1[0]) return LONG_MAX;\n  int j = 0;\n  while(w[i] != w1[j]) j++;\n  sum = w[i] + w[0];\n  swap(w,i,0);\n  sum += run_log(w);\n  sum += w[0] + w[j];\n  swap(w,0,j);\n   \n  return sum;\n}\n \nlong repeat_sort(int *w, int *w1, int n,long now) {\n  int i;\n  int a1[n];\n  long v1,v2;\n  for (i = 0; i < n; i++) a1[i]=w[i];\n  i = search_min(w,w1,n);\n  if(i == n) return now;\n  v1 = step_sort(w,w1,i);\n  v2 = sub_sort(a1,w1,i);\n  long min = (v1 < v2) ? v1:v2;\n  return repeat_sort(w,w1,n,now+min);\n}\n \nlong much_sort(int *w, int *w1, int n) {\n  int i,j;\n  long sum = 0;\n  char *checked = (char*)calloc(n,sizeof(char));\n  i = 0;\n  while(i < n) {\n    j = 0;\n    while(w[j] != w1[i]) j++;\n    if(i != j) {\n      if(w1[j] ==  w[i]) {\n    sum += w[i] + w[j];\n    swap(w,i,j);\n      }\n    }\n    checked[i]=1;checked[j]=1;\n    while(i < n && checked[i]!=0)i++;\n  }\n  free(checked);\n  return sum;\n}\n \nint main()\n{\n  int i,n,*w,*w2;\n  long sum;\n  scanf(\"%d\",&n);\n  w = (int*)malloc(sizeof(int) * n);\n  w2 = (int*)malloc(sizeof(int) * n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\",w+i);\n    w2[i] = w[i];\n  }\n  Merge_Sort(w2,0,n);\n   \n  sum = much_sort(w,w2,n);\n  sum += repeat_sort(w,w2,n,0);\n  printf(\"%ld\\n\",sum);\n   \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n\n\n\nint n,cost;\nint A[1001],B[1001];\nint L[501],R[502];\n\n\nvoid merge(int left,int mid,int right){\n  int i,j,n1=mid-left,n2=right-mid;\n  for(i=0;i<n1;i++) L[i]=A[left+i];\n  L[n1]=INT_MAX;\n  for(i=0;i<n2;i++) R[i]=A[mid+i];\n  R[n2]=INT_MAX;\n  int l=0,r=0;\n  for(i=left;i<right;i++){\n    if(L[l]<=R[r]){\n      A[i]=L[l];\n      l++;\n    }\n    else{\n      A[i]=R[r];\n      r++;\n    }\n  }\n}\n\n\nvoid m_sort(int left,int right){\n  int mid;\n  if( left+1 >= right) return;\n  mid=(left+right)/2;\n  m_sort(left,mid);\n  m_sort(mid,right);\n  merge(left,mid,right);\n}\n\n\nvoid swap(int a,int b,int *C){\n  int swap;\n  swap=C[a];\n  C[a]=C[b];\n  C[b]=swap;\n}\n\n\n/*??£????????´??????????????°???????????§????°??????????????????¢?????????????????????*/\nint min_search(int *C){\n  int i,j;\n  for(i=0;i<n;i++){\n    if(A[i]!=C[i]) break;\n  }\n  for(j=i+1;j<n;j++){\n    if(A[i]==C[j]) return j;\n  }\n  return n;\n}\n\n\n\n\n\n\nint quest(int *C,int num,int jud){\n  int D[1001],E[1001],i,x,ans,ans2,judd;\n  if(jud==n) x=min_search(C);\n  else x=jud;\n  if(x==n) return num;\n  for(i=0;i<n;i++) D[i]=C[i];\n  i=0;\n  while(1){\n    if(D[i]==A[x]){\n      swap(i,x,D);\n      judd=i;\n      if(D[i]==A[i]) judd=n;\n      ans=quest(D,num+D[i]+D[x],judd);\n      break;\n    }\n    i++;  \n  }\n  if(C[x]!=A[0]){\n    for(i=0;i<n;i++) E[i]=C[i];\n    swap(0,x,E);\n    ans2=quest(E,num+E[0]+E[x],x);\n    if(ans > ans2) ans=ans2;\n  }\n  return ans;\n}\n  \n \n  \n\nint main(){\n  scanf(\"%d\",&n);\n  int i,j,min=n;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n  m_sort(0,n);\n  cost=0;\n  for(i=0;i<n;i++){\n    for(j=i+1;j<n;j++){\n      if(B[i]==A[j]){\n        if(B[j]==A[i]){\n          swap(i,j,B);\n          cost+=B[i]+B[j];\n        }\n        break;\n      }\n    } \n  }\n  while(1){\n    if(min==n) min=min_search(B);\n    if(B[min]!=A[0]){\n      break;\n    }\n    else{\n      if(min==n) break;\n      for(i=0;i<n;i++){\n        if(A[min]==B[i]){\n          if(min==i){\n            min=n;\n            break;\n          }\n          swap(min,i,B);\n          cost+=B[min]+B[i];\n          min=i;\n          break;\n        }\n      }\n    }\n  }\n  cost=quest(B,cost,n);\n  printf(\"%d\\n\",cost);\n  return 0;\n}\n   \n          \n          \n    "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid swap(int* a,int* b){\n  int tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\n\nint n;\nint A[1000];\nint B[1000];\n\nint search(int x){\n  int i;\n  for(i=0;i<n;i++){\n    if(A[i]==x)return i;\n  }\n}\n\nint main(){\n  int i,j,ans,x,y;\n\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n  \n  for(i=n-1;i>0;i--){\n    for(j=0;j<i;j++){\n      if(B[j]>B[j+1])swap(&B[j],&B[j+1]);\n    }\n  }\n \n  ans=0;\n  \n  while(1){\n    x=10001;\n    for(i=0;i<n;i++){\n      if(A[i]==B[i])continue;\n      if(x>A[i])x=A[i];\n    }\n    if(x==10001)break;\n\n    x=search(x);\n    y=search(B[x]);\n\n    swap(&A[x],&A[y]);\n    ans+=(A[x]+A[y]);\n  }\n  printf(\"%d\\n\",ans);\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n    \n    \n    \nint n,cost;\nint A[1001],B[1001];\nint L[501],R[502];\n    \n    \nvoid merge(int left,int mid,int right){\n  int i,j,n1=mid-left,n2=right-mid;\n  for(i=0;i<n1;i++) L[i]=A[left+i];\n  L[n1]=INT_MAX;\n  for(i=0;i<n2;i++) R[i]=A[mid+i];\n  R[n2]=INT_MAX;\n  int l=0,r=0;\n  for(i=left;i<right;i++){\n    if(L[l]<=R[r]){\n      A[i]=L[l];\n      l++;\n    }\n    else{\n      A[i]=R[r];\n      r++;\n    }\n  }\n}\n    \n    \nvoid m_sort(int left,int right){\n  int mid;\n  if( left+1 >= right) return;\n  mid=(left+right)/2;\n  m_sort(left,mid);\n  m_sort(mid,right);\n  merge(left,mid,right);\n}\n    \n    \nvoid swap(int a,int b,int *C){\n  int swap;\n  swap=C[a];\n  C[a]=C[b];\n  C[b]=swap;\n}\n    \n    \n    \n    \n    \n    \n      \n     \n      \n    \nint main(){\n  scanf(\"%d\",&n);\n  int i,j;\n  int cnt,sum,min,start,x;\n  int C[1001]={};\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n  m_sort(0,n);\n  for(i=0;i<n;i++){\n    if(A[i]==B[i]) C[i]=1;\n  }\n  cost=0;\n  for(i=0;i<n;i++){\n    if(C[i]!=1){\n      C[i]=1;\n      cnt=0;\n      sum=0;\n      min=B[i];\n      x=i;\n      while(1){\n        for(j=0;j<n;j++){\n          if(B[x]==A[j]){\n            C[j]=1;\n            cnt++;\n            sum+=B[j];\n            if(min > B[j]) min=B[j];\n            x=j;\n            break;\n          }\n        }\n        if(x==i) break;\n      }\n      sum-=min;\n      if( (cnt -1)*min > (cnt -1)*A[0]+2*(min +A[0])) cost+=sum+(cnt-1)*A[0]+2*(min +A[0]);\n      else cost+=sum+(cnt-1)*min;\n    }\n  }\n  printf(\"%d\\n\",cost);\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#define MAX 1000\n#define VMAX 10000\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint partition(int A[], int p, int r){\n\tint i, j;\n\tint x, t;\n\tx = A[r];\n\ti = p-1;\n\tfor( j = p ; j < r ; j++ ){\n\t\tif( A[j] <= x ){\n\t\t\ti++;\n\t\t\tt = A[i];\n\t\t\tA[i] = A[j];\n\t\t\tA[j] = t;\n\t\t}\n\t}\n\tt = A[i+1];\n\tA[i+1] = A[r];\n\tA[r] = t;\n\t\n\treturn i + 1;\n}\n\nvoid quickSort(int A[], int p, int r){\n\tint q;\n\tif( p < r ){\n\t\tq = partition(A, p, r);\n\t\tquickSort(A, p, q-1);\n\t\tquickSort(A, q+1, r);\n\t}\n}\n\nint solve(){\n\tint i=0, ans=0;\n\tint V[MAX];\n\t\n\tfor( i = 0 ; i < n ; i++ ){\n\t\tB[i] = A[i];\n\t\tV[i] = 0;\n\t}\n\tquickSort(B, 0, n-1);\n\t\n\tfor( i = 0 ; i < n ; i++ ) T[B[i]] = i;\n\tfor( i = 0 ; i < n ; i++ ){\n\t\tif( V[i] ) continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile( 1 ){\n\t\t\tV[cur] = 1;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tif(v < m){ m = v; }\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif( V[cur] ){ break; }\n\t\t}\n\t\tans = ans + fmin(S+(an-2)*m, m+S+(an+1)*s);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tint i;\n\tscanf(\"%d\",&n);\n\ts = VMAX;\n\tfor( i = 0 ; i < n ; i++ ){\n\t\tscanf(\"%d\", &A[i]);\n\t\tif(A[i] < s){ s = A[i]; }\n\t}\n\tint ans = solve();\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX_N  1000\n\nstruct rist\n{\n  int n;\n  int p;\n} typedef rist;\n\nvoid QuickSort(int, int);\nint Partition(int, int);\nint MinimumCost(int);\n\nrist A[MAX_N];\n\nint main()\n{\n\tint i;\n\tint n;\n\tint cost;\n\t\n\tscanf(\"%d\", &n);\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &A[i].n);\n\t\tA[i].p = i;\n\t}\n\t\n\tQuickSort(0, n - 1);\n\tcost = MinimumCost(n);\n\t\n\tprintf(\"%d\\n\", cost);\n\t\n\treturn 0;\n}\n\nvoid QuickSort(int p, int r)\n{\n  int q;\n\n  if(p < r)\n    {\n      q = Partition(p, r);\n      QuickSort(p, q - 1);\n      QuickSort(q + 1, r);\n    }\n}\n\nint Partition(int p, int r)\n{\n\tint i, j;\n\trist tmp;\n\n\ti = p - 1;\n\tfor(j = p; j < r; j++)\n    {\n    \tif(A[j].n <= A[r].n)\n\t\t{\n\t \t\t i = i + 1;\n\t \t\t tmp = A[i];\n\t  \t\tA[i] = A[j];\n\t  \t\tA[j] = tmp;\n\t\t}\n    }\n\ttmp = A[i + 1];\n  \tA[i + 1] = A[r];\n  \tA[r] = tmp;\n  \n  \treturn i + 1;\n}\n\nint MinimumCost(int n)\n{\n\tint i;\n\tint tmp;\n\tint cost;\n\t\n\tfor(i = n - 1; i >= 0; i--)\n\t{\n\t\tif(A[i].p != i)\n\t\t{\n\t\t\tcost += A[i].n + A[A[i].p].n;\n\n\t\t\ttmp = A[A[i].p].p;\n\t\t\tA[A[i].p].p = A[i].p;\n\t\t\tA[i].p = tmp;\n\t\t}\n\t}\n\treturn cost;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(void){\n\tint n,i,j,k,min,cost=0;\n\tint a[1000];\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++)scanf(\"%d\",&a[i]);\n\t\n\tfor(i=0;i<n;i++){\n\t\tmin=a[i];\n\t\tk=i;\n\t\tfor(j=i+1;j<n;j++){\n\t\t\tif(min>a[j]){\n\t\t\t\tmin=a[j];\n\t\t\t\tk=j;\n\t\t\t}\n\t\t}\n\t\tif(i!=k){\n\t\t\tcost+=(a[i]+a[k]);\n\t\t\tint temp=a[i];\n\t\t\ta[i]=a[k];\n\t\t\ta[k]=temp;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",cost);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX1  1000\n#define MAX2 10000\n\n\nint n, a[MAX1], s;\nint b[MAX1], T[MAX2 + 1];\n\n\nint partition(int [], int , int );\nvoid quickSort(int [], int , int );\nint solve();\n \n\nint main(){\n  int i;\n\n  scanf(\"%d\", &n);\n  s = MAX2;\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\", &a[i]);\n    if(a[i] < s) s = a[i];\n  }\n\n  int ans = solve();\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n\nint partition(int a[], int p, int r){\n  int i, j;\n  int t, x;\n  x = a[r];\n  i = p - 1;\n\n  for( j = p ; j < r ; j++ ){\n    if(a[j] <= x){\n      i++;\n      t = a[i];\n      a[i] = a[j];\n      a[j] = t;\n    }\n  }\n\n  t = a[i + 1];\n  a[i + 1] = a[r];\n  a[r] = t;\n\n  return i + 1;\n}\nvoid quickSort(int a[], int p, int r){\n  int q;\n  if(p < r){\n    q = partition(a, p, r);\n    quickSort(a, p, q - 1);\n    quickSort(a, q + 1, r);\n  }\n}\n\n\nint solve(){\n  int i, cur, S, m, an, v,   ans = 0 ;\n\n  int V[MAX1];\n  for(i = 0 ; i < n ; i++){\n    b[i] = a[i];\n    V[i] = 0;\n  }\n\n  quickSort(b, 0, n - 1);\n\n  for(i = 0 ; i < n ; i++) T[b[i]] = i;\n  for(i = 0 ; i < n ; i++){\n    if(V[i]) continue;\n    cur = i;\n    S = 0;\n    m = MAX2;\n    an = 0;\n    while(1){\n      V[cur] = 1;\n      an++;\n      v = a[cur];\n\n      if(v < m) m = v;\n\n      S += v;\n      cur = T[v];\n      if(V[cur]) break;\n    }\n    if(S + (an -2) * m < m + S + (an + 1) * s) ans += S + (an -2) * m;\n    else ans +=  m + S + (an + 1) * s;\n  }\n  return ans;\n}\n\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid swap(int* a,int* b){\n  int tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\n\nint n,m;\nint A[1000];\nint B[1000];\nint vd[1000];\nint cnt,sum,mini;\n\nint min(int x,int y){\n  if(x<y)return x;\n  else return y;\n}\n\nint search(int x){\n  int i;\n  for(i=0;i<n;i++){\n    if(A[i]==x)return i;\n  }\n}\n\nint main(){\n  int i,j,ans,x;\n\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n\n  for(i=n-1;i>0;i--){\n    for(j=0;j<i;j++){\n      if(B[j]>B[j+1])swap(&B[j],&B[j+1]);\n    }\n  }\n\n  m=B[0];\n  ans=0;\n  for(i=0;i<n;i++)vd[i]=0;\n\n  for(i=0;i<n;i++){\n    if(A[i]==B[i])continue;    \n    x=i;\n    cnt=sum=0;\n    mini=(1<<24);\n    while(vd[x]==0){\n      vd[x]=1;\n      cnt++;\n      sum+=A[x];\n      mini=min(mini,A[x]);\n      x=search(B[x]);\n    }\n\n    if(cnt<2)continue;\n    ans+=min(sum+m*cnt+mini,sum+mini*(cnt-2));\n\n  }\n\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <string.h>\n\n#define MAX 1000\n#define INF INT_MAX\n\nint solve(int*, int);\nint check(int*,int);\n\nint main(){\n  int n, i, arr[MAX];\n\n  scanf(\"%d\" ,&n);\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\" ,arr + i);\n  }\n  printf(\"%d\\n\" ,solve(arr, n));\n\n  return 0;\n}\n\nint check(int arr[], int n){\n  int i;\n\n  for(i = 0 ; i < n ; i++){\n    if(arr[i] != i-1){\n      return 0;\n    }\n  }\n  return 1;\n}\n\nint solve(int arr[], int n){\n  int i, j, res = 0, tmp, used[MAX], min = INF, pos, flg;\n\n  memset(used, 0, sizeof(used));\n\n  for(i = 0 ; i < n-1 ; i++){\n    flg = 0;\n    if(arr[i] == i+1){\n      used[i] = 1;\n      continue;\n    }\n\n    for(j = i+1 ; j < n ; j++){\n      if(arr[j] == j+1 || used[j]){\n        used[j] = 1;\n        continue;\n      }\n\n      pos = -1;\n      if(arr[i] == j+1 && arr[j] == i+1){\n        tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n        res += arr[i] + arr[j];\n        flg = 1;\n        break;\n      }else{\n        if(arr[i] + arr[j] < min){\n          min = arr[i] + arr[j];\n          pos = j;\n        }\n      }\n    }\n    if(pos != -1 && !flg){\n      tmp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = tmp;\n      res += arr[i] + arr[j];\n    }\n  }\n\n  return res;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#define true 1\n#define false 0\n#define MAX 1000\n#define VMAX 10000\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nvoid sort(int C[])\n{\n\t\n\tint tmp;\n\tint flag = 1;\n\twhile(flag == 1){\n\t\tflag = 0;\n\t\tfor( int j = n-1; j >= 1; j--){\n\t\t\tif(C[j] < C[j-1])\n\t\t\t{\n\t\t\t\ttmp = C[j];\n\t\t\t\tC[j] = C[j-1];\n\t\t\t\tC[j-1] = tmp;\n\t\t\t\tflag = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint min(int a , int b)\n{\n\tif(a < b) return a;\n\telse return b;\n}\n\n\nint solve()\n{\n\tint ans = 0;\n\t\n\tbool V[MAX];\n\tfor( int i = 0; i < n; i++){\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B);\n\tfor( int i = 0; i < n; i++) T[B[i]] = i;\n\tfor( int i = 0; i < n; i++){\n\t\tif(V[i])continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint c = 0;\n\t\twhile(1){\n\t\t\tV[cur] = true;\n\t\t\tc++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m,v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif(V[cur])break;\n\t\t}\n\t\tans += min(S+(c-2)*m, m+S+(c+1)*s);\n\t} \n\treturn ans; \n}\n\n\nint main(void)\n{\n\tscanf(\"%d\",&n);\n\ts = VMAX;\n\tfor( int i = 0; i < n; i++){\n\t\tscanf(\"%d\",&A[i]);\n\t\ts = min(s, A[i]);\n\t}\n\tint ans = solve();\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 1000\ntypedef struct {\n  int sum;\n  int flag;\n} CC;\nCC C[N];\nint A[2000],B[2000];\nint main()\n{\n  int i,n,min=0,m,k,now,sum=0;\n  scanf(\"%d\",&n);\n  for(i=1;i<n+1;i++){\n    scanf(\"%d\",&A[i]);\n  }\n  \n  for(i=0;i<N;i++){\n    C[i].sum=0;\n    C[i].flag=0;\n  }\n  for(i=1;i<n+1;i++){\n    C[A[i]].sum+=1;\n    C[A[i]].flag+=1;\n  }\n  for(i=0;i<N;i++){\n    C[i].sum+=C[i-1].sum;\n  }\n\n  for(i=n+1;i>0;i--){\n    if(C[A[i]].flag==1){\n      k=i;\n      now=k;\n      m=0;\n      B[C[A[k]].sum]=A[k];\n      C[A[i]].flag=0;\n      min=A[k];\n      k=C[A[k]].sum;\n      while(now!=k){\n        if(m==0)sum+=A[now];\n        B[C[A[k]].sum]=A[k];\n        C[A[k]].flag=0;\n        sum+=A[k];\n        if(min>A[k])min=A[k];\n        k=C[A[k]].sum;\n        m+=1;\n      }\n      if(m>2)sum+=min*(m-1);\n      m=0;\n      min=0;\n    }\n  }\n  for(i=1;i<n;i++){\n    printf(\"%d \",B[i]);\n  }\n  printf(\"%d\",B[i]);\n  printf(\"\\n%d\\n\",sum);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 1000\n \nint n,A[N],B[N],C[N],con,res,min;\n \nvoid swap(int* A,int* B)\n{\n  int ch;\n  ch=*A;\n  *A=*B;\n  *B=ch;\n}\nint small(int a,int b)\n{\n  if(a<b)return a;\n  else return b;\n}\n \nint search(int a)\n{\n  int i;\n  for(i=0; i<n; i++){\n    if(A[i]==a)return i;\n  }\n}\n \nint main()\n{\n  int i,j,sum=0,p;\n \n  scanf(\"%d\",&n);\n \n  for(i=0; i<n; i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n \n  for(i=n-1; i>0; i--){\n    for(j=0; j<i; j++){\n      if(B[j]>B[j+1]) swap(&B[j],&B[j+1]);\n    }\n  }\n \n  for(i=0; i<n; i++)C[i]=0;\n \n  for(i=0; i<n; i++){\n    p=i;\n    con=res=0;\n    min=(1<<24);\n \n    while(C[p]==0){\n      C[p]=1;\n      con++;\n      res+=A[p];\n      min=small(min,A[p]);\n      p=search(B[p]);\n    }\n \n    if(con<2)continue;\n    sum+=small(res+B[0]*(con+1)+min,res+min*(con-2));\n  }\n \n  printf(\"%d\\n\",sum);\n   \n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "//2020.1.18\n//s1270188 xxxmk2\n//alds1_06d\n\n#include<stdio.h>\n#define N 1000\n#define MAX 10000\n\n//prototype\nint partition(int,int);\nvoid q_sort(int,int);\nint cnt(void);\n\n//global\nint data[N], B[N], num, min=MAX; \n\nint main(){\n  int i;\n\n  //input\n  scanf(\"%d\",&num);\n  for(i=0;i<num;i++){\n    scanf(\"%d\",&data[i]);\n    if(min>data[i]) min=data[i];\n  }\n  \n  //output\n  printf(\"%d\\n\",cnt());\n  \n  return 0;\n}\n\nint cnt(void){\n  int cnt=0;\n  int V[N], T[MAX];\n  int i, cur, S, m, an, v;\n  int a, b;\n\n  for(i=0;i<num;i++){\n    B[i]=data[i];\n    V[i]=0;\n  }\n\n  q_sort(0,num-1);\n\n  for(i=0;i<num;i++) T[B[i]]=i;\n  \n  for(i=0;i<num;i++){\n    if(V[i]==1) continue;\n    \n    cur=i;\n    S=an=0;\n    m=MAX;\n    while(1){\n      V[cur]=1;\n      an++;\n      v=data[cur];\n      if(v<m) m=v;\n      S+=v;\n      cur=T[v];\n      if(V[cur]) break;\n    }\n    a=S+(an-2)*m;\n    b=m+S+(an+1)*min;\n    if(a<b) cnt+=a;\n    else cnt+=b;\n  }\n\n  return cnt;\n}\n\n\n\nint partition(int l,int r){\n  int i, j, tmp;\n\n  for(i=l-1,j=l;j<r;j++){\n    if(B[j]<=B[r]){\n      i++;\n      tmp=B[i];\n      B[i]=B[j];\n      B[j]=tmp;\n    }\n  }\n  tmp=B[i+1];\n  B[i+1]=B[r];\n  B[r]=tmp;\n  \n  return i+1;\n}\n  \nvoid q_sort(int l,int r){\n  int m;\n  if(l<r){\n    m=partition(l,r);\n    q_sort(l,m-1);\n    q_sort(m+1,r);\n  }\n}\n\n"
  },
  {
    "language": "C",
    "code": "5\n1 5 3 4 2"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#define DEF_ELEM_MAX 1000\n#define DEF_VMAX 10000\n#ifndef min\n#define min(a, b)            (((a) < (b)) ? (a) : (b))\n#endif\nint A[DEF_ELEM_MAX];\nint B[DEF_ELEM_MAX];\nint VD[DEF_ELEM_MAX];\nint N;\n\nint search(int x)\n{\n  int i;\n  for ( i = 0 ; i < N ; i++ ) {\n    if ( A[i] == x ) {\n      break;\n    }\n  }\n  return i;\n}\n \nint int_sort( const void * a , const void * b ){\n  int p = *( int * )a;\n  int q = *( int * )b;\n  if( p < q ) {\n    return -1;\n  }  else if( p == q  ) {\n    return 0;\n  }\n  return 1;\n}\n\nint sillysort( void ){\n  int s,cost=0,i,amin,sum,n,x;\n  s = B[0];\n  for ( i = 0 ; i < N ; i++ ) {\n    x = i;\n    n = sum = 0;\n    amin = DEF_VMAX;\n    while ( VD[x] == 0 ) {\n      VD[x] = 1;\n            n++;\n            sum += A[x];\n            amin = min(amin, A[x]);\n            x = search(B[x]);\n        }\n        if ( n > 1 ) { \n            cost += min(sum+(n-2)*amin, sum+amin+(n+1)*s);\n        }\n    }\n    return cost;\n}\n\nint main(void){\n  int i,ans;\n    scanf(\"%d\", &N);\n    for ( i = 0 ; i < N ; i++ ) {\n        scanf(\"%d\", &A[i] );\n        B[i] = A[i];\n    }\n    qsort(B, N , sizeof( int ), int_sort );\n    ans = sillysort();\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nvoid swap(int *A, int i, int j) {\n  int temp;\n  temp = A[i];\n  A[i] = A[j];\n  A[j] = temp;\n}\n\nvoid Merge(int *A, int left, int mid, int right) {\n  int n1,n2,*L,*R,i,j,k;\n  n1 = mid -left;\n  n2 = right - mid;\n  L = (int*)malloc(sizeof(int) * (n1+1));\n  R = (int*)malloc(sizeof(int) * (n2+1));\n  for (i = 0; i< n1; i++) {\n    L[i] = A[left+i];\n  }\n  for (i = 0; i < n2; i++) {\n    R[i] = A[mid+i];\n  }\n  L[n1] = INT_MAX; R[n2] = INT_MAX;\n  i = 0;j = 0;\n  for(k = left; k < right; k++) {\n    if (L[i] < R[j]) {\n      A[k] = L[i];\n      i++;\n    }else {\n      A[k] = R[j];\n      j++;\n    }\n  }\n  free(L);\n  free(R);\n}\n\nvoid Merge_Sort(int *A, int left, int right) {\n  if(left+1 < right) {\n    int mid = (left + right)/2;\n    Merge_Sort(A,left,mid);\n    Merge_Sort(A,mid,right);\n    Merge(A,left,mid,right);\n  }\n}\n\nint sort_step(int *w, int *w1, int n) {\n  int i,j,mini,minj,min;\n  min = INT_MAX;\n  for (i = 0; i < n; i++) {\n    j = 0;\n    while(w1[i] != w[j]) j++;\n    if(i != j) {\n      if(min > w[i]+w[j]) {\n\tmini = i;\n\tminj = j;\n\tmin = w[i]+w[j];\n      }\n    }\n  }\n  if(min == INT_MAX) return 0;\n  swap(w,mini,minj);\n  return min;\n}\n\nlong min_sort(int *w, int *w1, int n) {\n  int i,j,k;\n  long sum = 0;\n  for(i = 0; i < n; i++) {\n    j = 0;\n    while (w[j] != w1[i]) j++;\n    while(j != i) {\n      k = 0;\n      while (w[k] != w1[j]) k++;\n      sum += w[j]+w[k];\n      swap(w,j,k);\n      j = k;\n    }\n  }\n  return sum;\n}\n\nint main()\n{\n  int i,n,*w,*w2;\n  long sum;\n  scanf(\"%d\",&n);\n  w = (int*)malloc(sizeof(int) * n);\n  w2 = (int*)malloc(sizeof(int) * n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\",w+i);\n    w2[i] = w[i];\n  }\n  Merge_Sort(w2,0,n);\n  \n  sum = min_sort(w,w2,n);\n  printf(\"%ld\\n\",sum);\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\n//============================================================================\n#define pred(x) ((x)-1)\n#define succ(x) ((x)+1)\n//============================================================================\ntypedef unsigned char  INT8U;\ntypedef unsigned short INT16U;\ntypedef   signed short INT16S;\ntypedef long INT32;\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nINT16U *C;\n//----------------------------------------------------------------------------\nvoid CountingSort(INT16U *A, INT16U *B,  INT16U n, INT16U k)\n{\n    long i;\n\n    for (i = 0; i<n; i++)\n        C[A[i]]++;\n    for (i = 1; i<=k; i++)\n        C[i] += C[i-1];\n    /*for (i = 1; i<=k; i++)\n        printf(\"%d \", C[i]);\n    printf(\"\\n\");\n    printf(\"B[C[A[i]]-1] = A[i];\\n\");\n    for (i=n-1; 0<=i; i--){\n        B[C[A[i]]-1] = A[i];\n        printf(\"B[%d]=%d C[%d]=%d A[%d]=%d\\n\", C[A[i]]-1, B[C[A[i]]-1],\n                            A[i], C[A[i]], i, A[i]);\n        C[A[i]]--;\n    }*/\n}\n//----------------------------------------------------------------------------\nINT16S getminptr(INT16U *A, INT16U N)\n{\n    INT16U i,min; INT16S ptr;\n\n    for (i=0, ptr=-1, min=32767; i<N; i++){\n        if (A[i]<min && pred(C[A[i]])!=i){\n            min=A[i];\n            ptr=i;\n        }\n    }\n    return ptr;\n}\n//----------------------------------------------------------------------------\nlong sum;\nvoid exchange(INT16U *x, INT16U *y)\n{\n    INT16U z;\n\n    z=*x, *x=*y, *y=z;\n    sum+=*x;\n    sum+=*y;\n}\n//----------------------------------------------------------------------------\nlong mincostsort(INT16U *A, INT16U N)\n{\n    int ptr,i,j;\n\n    for (sum=0; 0<=(ptr=getminptr(A, N));){\n        while ((j=pred(C[A[ptr]]))!=ptr){\n            for (i=0; i<N; i++)\n                if (C[A[i]]==succ(ptr)){\n                    exchange(&A[ptr], &A[i]);\n                    ptr=i;\n                    break;\n                }\n        }\n    }\n    return sum;\n}\n//----------------------------------------------------------------------------\n/*\n5\n1 5 3 4 2\n7\n\n4\n4 3 2 1\n10\n*/\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nvoid input(FILE *file)\n{\n    long i,n,max,ave; INT16U *A, *B; char buffer[20];\n\n    fgets(buffer, sizeof(buffer)-1, file);\n    sscanf(buffer, \"%ld\", &n);\n    A = malloc(succ(n)*sizeof(INT16U));\n    B = malloc(succ(n)*sizeof(INT16U));\n    for (i=ave=max=0; i<n; i++){\n        fscanf(file, \"%hd\",  &A[i]);\n        if (max<A[i])\n            max=A[i];\n        ave+=A[i];\n    }\n    ave/=n;\n    C = malloc(succ(max)*sizeof(INT16U));\n    memset(C, 0, sizeof(INT16U)*succ(max));\n    CountingSort(A, B, n, max);\n    printf(\"%ld\\n\", mincostsort(A, n));\n#ifdef DESKTOP\n    for (i=0; i<n; i++){\n        if (i) printf(\" \");\n        printf(\"%hd\", A[i]);\n    }\n    printf(\"\\n\");\n#endif\n    free(A);\n    free(B);\n    free(C);\n}\n//============================================================================\n#ifndef DESKTOP\nint main()\n{\n    input(stdin);\n    return 0;\n}\n#endif"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid Sort(int*,int,int);\nint Cost_Sort(int*,int,int);\n\nint sum=0;\n\nmain(){\n  int i,n,*A;\n\n  scanf(\"%d\",&n);\n\n  A=(int *)malloc(sizeof(int)*n);\n\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n  }\n\n  Sort(A,0,n-1);\n\n  printf(\"%d\\n\",sum);\n\n  return 0;\n}\n\nvoid Sort(int *A,int i,int n){\n  int p,j;\n  \n  if(i<n){\n    p=Cost_Sort(A,i,n);\n\n    Sort(A,i,p);\n  }\n}\n\nint Cost_Sort(int *A,int i,int n){\n  int j,tmp,max=A[i],k=0;\n  for(j=i+1;j<=n;j++){\n    if(max<A[j]){\n      max=A[j];\n      k=j;\n    }\n  }\n  if(k!=n){\n    sum+=A[k]+A[n];\n    tmp=A[k];\n    A[k]=A[n];\n    A[n]=tmp;\n  }\n\n  return n-1;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define MAX 10000\nint B[MAX],T[MAX+1];\n\nvoid sort(int A[], int n){\n\tint f=1;\n\tint tmp;\n\twhile(f==1){\n\t\tf = 0;\n\t\tfor(int j=n-1;j>=1;j--){\n\t\t\tif(A[j]<B[j-1]){\n\t\t\t\ttmp=A[j-1];\n\t\t\t\tA[j-1]=A[j];\n\t\t\t\tA[j]=tmp;\n\t\t\t\tf=1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint min(int a,int b){\n    if(a<b){\n    \treturn a;\n    }\n    return b;\n}\n\nint solve(int A[], int n, int s){\n\t\n\tint ans=0;\n\tint V[MAX];\n\tfor(int i=0;i<n;i++){\n\t\tB[i]=A[i];\n\t\tV[i]=0;\n\t}\n\t\n\tsort(B ,n);\n\t\n\tfor(int i=0;i<n;i++){\n\t\tT[B[i]]=i;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(V[i]==1){\n\t\t\tcontinue;\n\t\t}\n\t\tint cur=i;\n\t\tint S=0;\n\t\tint m=MAX;\n\t\tint an=0;\n\t\t\n\t\twhile(1){\n\t\t\tV[cur]=1;\n\t\t\tan++;\n\t\t\tint v=A[cur];\n\t\t\tm=min(m,v);\n\t\t\tS+=v;\n\t\t\tcur=T[v];\n\t\t\tif(V[cur]){\n\t\t\t\tbreak; \n\t\t\t}\n\t\t}\n\t\tans+=min(S+(an-2)*m,m+S+(an+1)*s);\n\t\t\n\t}\n\t\n\treturn ans;\n\t\n}\n\n\nint main(void){\n\tint n, s=MAX;\n\tscanf(\"%d\", &n);\n\tint A[n];\n\tfor(int i=0 ; i<n ; i++){\n\t\tscanf(\"%d\",&A[i]);\n\t\ts = min(s,A[i]);\n\t}\n\tprintf(\"%d\\n\",solve(A, n, s));\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <memory.h>\n\n#define MIN(x, y) ((x) <= (y) ? (x) : (y))\nint get_uint() {\n    int n = 0;\n    int c = getchar_unlocked();\n    if(c < 48 || 57 < c) return c;\n    while(47 < c && c < 58) {\n        n = 10 * n + (c & 0xf);\n        c = getchar_unlocked();\n    }\n    return n;\n}\nvoid put_uint(int n) {\n    if(!n) {\n        putchar_unlocked('0');\n        return;\n    }\n    char buf[11];\n    int i = 0;\n    while(n) buf[i++] = (char)(n % 10 + '0'), n /= 10;\n    while(i--)putchar_unlocked(buf[i]);\n}\nvoid *partition(int *first, int *last) {\n    int pivot = *(last - 1);\n    int *p = first - 1;\n    for(int *it = first; it != last - 1; ++it) {\n        if(*it <= pivot) {\n            p++;\n            int tmp = *p;\n            *p = *it;\n            *it = tmp;\n        }\n    }\n    int tmp = *++p;\n    *p = pivot;\n    *(last - 1) = tmp;\n    return p;\n}\nvoid quick_sort(void *first, void *last, size_t N) {\n    if(last - first <= N) return;\n    void *mid = partition(first, last);\n    quick_sort(first, mid, N);\n    quick_sort(mid, last, N);\n}\nint mincost_sort(const int *a, const int N, const int minw) {\n    int cnt = 0;\n    int b[N];\n    memcpy(b, a, N * sizeof(int));\n    quick_sort(b, b + N, sizeof(int));\n    int pos[10001];\n    for(int i = 0; i < N; ++i) pos[b[i]] = i;\n    int flag[1001] = {};\n    for(int i = 0; i < N; ++i) {\n        if(flag[i]) continue;\n        int cur = i;\n        int sum = 0;\n        int num = 0;\n        int mina = 1 << 29;\n        while(!flag[cur]) {\n            flag[cur] = 1;\n            num++;\n            sum += a[cur];\n            mina = MIN(mina, a[cur]);\n            cur = pos[a[cur]];\n        }\n        // [ sum + (num-2)*mina + 2(mina+minw) - (num-1)*(mina-minw) ] -> [ sum + mina + (n+1)*minw ]\n        cnt += MIN(sum + (num - 2) * mina, sum + mina + (num + 1) * minw);\n    }\n    return cnt;\n}\nint main(int argc, char **argv) {\n    int n = get_uint();\n    int w[n];\n    int minw = 1 << 29;\n    for(int i = 0; i < n; ++i) {\n        w[i] = get_uint();\n        MIN(minw, w[i]);\n    }\n    put_uint(mincost_sort(w, n, minw));\n    putchar_unlocked('\\n');\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "\t//\t????°???????????????????\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define DEF_ELEM_MAX 1000\n#define DEF_VMAX 10000\n\n//  ????°?????????????\n#ifndef min\n#define min(a, b)            (((a) < (b)) ? (a) : (b))\n#endif\n\nint A[DEF_ELEM_MAX];\nint B[DEF_ELEM_MAX];\nint VD[DEF_ELEM_MAX];\nint N;\n\n/////////////////////////////////////////////////////////////////////////////////\n//\n/////////////////////////////////////////////////////////////////////////////////\nint search(int x)\n{\n  int i;\n  for ( i = 0 ; i < N ; i++ ) {\n\t  if ( A[i] == x ) {\n\t\t  break;\n\t  }\n  }\n  return i;\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n//\n/////////////////////////////////////////////////////////////////////////////////\nint int_sort( const void * a , const void * b )\n{\n\tint p = *( int * )a;\n\tint q = *( int * )b;\n  if( p < q ) {\n    return -1;\n  }  else if( p == q  ) {\n    return 0;\n  }\n  return 1;\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n//\n/////////////////////////////////////////////////////////////////////////////////\nint sillysort( int *A, int m )\n{\n\tint s;\n\tint cost = 0;\n\tint i;\n\tint amin;\n\tint sum;\n\tint n;\n\tint x;\n\n\t// init\n\tfor ( i = 0 ; i < m ; i++ ) {\n\t\tB[i] = A[i];\n\t}\n\n\tqsort(B, m , sizeof( int ), int_sort );\n\n\ts = B[0];\n\t// compute\n\tfor ( i = 0 ; i < m ; i++ ) {\n\t\tx = i;\n\t\tn = sum = 0;\n\t\tamin = DEF_VMAX;\n\t\twhile ( VD[x] == 0 ) {\n\t\t\tVD[x] = 1;\n\t\t\tn++;\n\t\t\tsum += A[x];\n\t\t\tamin = min(amin, A[x]);\n\t\t\tx = search(B[x]);\n\t\t}\n\t\tif ( n > 1 ) { \n\t\t\tcost += min(sum+(n-2)*amin, sum+amin+(n-1)*s);\n\t\t}\n\t}\n\treturn cost;\n}\n/////////////////////////////////////////////////////////////////////////////////\n//\n/////////////////////////////////////////////////////////////////////////////////\nint main(void)\n{\n\tint i;\n\tint ans;\n//\n\tscanf(\"%d\", &N);\n\tfor ( i = 0 ; i < N ; i++ ) {\n\t\tscanf(\"%d\", &A[i] );\n\t}\n\n\tans = sillysort( A, N );\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "//?????´???????????????????°???????????????´????????¬??\\????????¨??????????????????\n#include<stdio.h>\n#include<limits.h>\n\nvoid swap(int *a, int *b){\n\tint temp = *a;\n\t*a = *b;\n\t*b = temp;\n\treturn;\n}\n\nvoid show(int A[], int n){\n\tint i;\n\tfor( i = 0; i < n; i++ ){ printf(\"%5d\", A[i]); }\n\tprintf(\"\\n\");\n\treturn;\n}\n\nvoid merge(int A[], int left, int mid, int right){\n\tint n1 = mid - left;\n\tint n2 = right - mid;\n\tint L[n1+1], R[n2+1];\n\tint i, j, k;\n\tfor( i = 0; i < n1; i++ ){ L[i] = A[left+i]; }\n\tfor( i = 0; i < n2; i++ ){ R[i] = A[mid+i]; }\n\tL[n1] = INT_MAX;\n\tR[n2] = INT_MAX;\n\ti = 0;\n\tj = 0;\n\tfor( k = left; k < right; k++ ){\n\t\tif( L[i] <= R[j] ){\n\t\t\tA[k] = L[i++];\n\t\t}else{\n\t\t\tA[k] = R[j++];\n\t\t}\n\t}\n\treturn;\n}\n\nvoid mergeSort(int A[], int left, int right){\n\tif( left+1 <  right ){\n\t\tint mid = (left + right) / 2;\n\t\tmergeSort(A, left, mid);\n\t\tmergeSort(A, mid, right);\n\t\tmerge(A, left, mid, right);\n\t}\n\treturn;\n}\n\nint minimumCostSort(int A[], int sorted[], int n){\n\tint i, j;\n\tint min, minj, target, targetj;\n\tint cost = 0, addCost = 0;\n\tint swaptimes = 0;\n\tfor( i = 0; i < n; i++ ){\n\t\tmin = sorted[i];\n\t\t//sorted???i?????????????´????A??????????????????(minj)????????????\n\t\tfor( j = 0; j < n; j++ ){\n\t\t\tif( A[j] == min ){\n\t\t\t\tminj = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\taddCost = 0;\n\t\twhile( minj != i ){\n\t\t\ttarget = sorted[minj];\n\t\t\tfor( j = 0; j < n; j++ ){\n\t\t\t\tif( A[j] == target ){\n\t\t\t\t\ttargetj = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcost += A[minj] + A[targetj];\n\t\t\tswap(&A[minj], &A[targetj]);\n\t\t\tswaptimes++;\n\t\t\tminj = targetj;\n\t\t\t//show(A, n);\n\t\t}\n\t\t//????°???????????????£??????????????£????????????????????????????????????????????????????????????????????§?????????????????§?????????\n\t\tif( 2 * (sorted[i]+sorted[0]) + swaptimes * sorted[0] < swaptimes * sorted[i] ){\n\t\t\tcost += 2 * (sorted[i]+sorted[0]) + swaptimes * sorted[0] - swaptimes * sorted[i];\n\t\t}\n\t\tswaptimes = 0;\n\t}\n\treturn cost;\n}\n\nint main(){\n\tint n, i;\n\tint w[1000], sorted[1000];\n\tscanf(\"%d\", &n);\n\tfor( i = 0; i < n; i++ ){\n\t\tscanf(\"%d\", &w[i]);\n\t\tsorted[i] = w[i];\n\t}\n\tmergeSort(sorted, 0, n);\n\t//show(w, n);\n\t//show(sorted, n);\n\tprintf(\"%d\\n\", minimumCostSort(w, sorted, n));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 1001\nvoid swap(int*,int*);\n\nint main(){\n  int i,j,min,sum=0,flag;\n  int n;\n  int W[MAX];\n  scanf(\"%d\",&n);\n  for(i = 0; i < n; i++){\n    scanf(\"%d\",&W[i]);\n  }\n  i = -1;\n  while(i != n-1){\n    flag = 0;\n    i = i+1;\n    min = i;\n    for(j = i+1; j < n; j++){\n      if(W[min] > W[j]){\n        min = j;\n        flag = 1;\n      }\n    }\n    if(flag){\n      swap(&W[min],&W[i]);\n      sum += W[i] + W[min];\n    }\n  }\n  printf(\"%d\\n\",sum);\n  return 0;\n}\n\nvoid swap(int* w,int* min){\n  int tmp;\n  tmp = *w;\n  *w = *min;\n  *min = tmp;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n//toriaezu\n\nint cost;\n\nint sort(int *A,int n){\n  int i,j;\n  int tmp;\n  int min=1000,max=0;\n  int im,iM;\n  for(i=0;i<n-1;i++){\n    if(A[i]>max){\n      max=A[i];\n      iM=i;\n    }\n  }\n  for(i=1;i<n;i++){\n    if(A[i]<min){\n      min=A[i];\n      im=i;\n    }\n  }\n  //printf(\"%d %d\\n\",im,iM); \n    if(iM>im) return 1;\n    tmp=A[im];\n    A[im]=A[iM];\n    A[iM]=tmp;\n\n    cost=cost+max+min;\n    sort(&A[0],n);\n\n}\nint main(){\n  \n  int i,n,a;\n  int A[1000];\n  cost=0;\n  scanf(\"%d\",&n);\n\n  for(i=0;i<n;i++) scanf(\"%d\",&A[i]);\n  a=sort(&A[0],n);\n  \n  printf(\"%d\\n\",cost);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid swap(int* a,int* b){\n  int tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\n\nint n;\nint A[1000];\nint B[1000];\n\nint search(int x){\n  int i;\n  for(i=0;i<n;i++){\n    if(A[i]==x)return i;\n  }\n}\n\nint main(){\n  int i,j,ans,x,y;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n  \n  for(i=n-1;i>0;i--){\n    for(j=0;j<i;j++){\n      if(B[j]>B[j+1])swap(&B[j],&B[j+1]);\n    }\n  }\n \n  ans=0;\n  \n  while(1){\n    x=1001;\n    for(i=0;i<n;i++){\n      if(A[i]==B[i])continue;\n      if(x>A[i])x=A[i];\n    }\n    if(x==1001)break;\n\n    x=search(x);\n    y=search(B[x]);\n\n    swap(&A[x],&A[y]);\n    ans+=(A[x]+A[y]);\n  }\n  printf(\"%d\\n\",ans);\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid swap(int* a,int* b){\n  int tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\n\nint n;\nint A[1000];\nint B[1000];\n\nint search(int x){\n  int i;\n  for(i=0;i<n;i++){\n    if(A[i]==x)return i;\n  }\n}\n\nint main(){\n  int i,j,ans,x,y,xa,yb;\n\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n  \n  for(i=n-1;i>0;i--){\n    for(j=0;j<i;j++){\n      if(B[j]>B[j+1])swap(&B[j],&B[j+1]);\n    }\n  }\n \n  ans=0;\n  \n  while(1){\n    x=(1<<24);\n    for(i=0;i<n;i++){\n      if(A[i]==B[i])continue;\n      if(x>A[i]+B[i]){\n\tx=A[i]+B[i];\n\ty=i;\n      }\n    }\n    if(x==(1<<24))break;\n\n    x=search(B[y]);\n\n    swap(&A[x],&A[y]);\n    ans+=(A[x]+A[y]);\n  }\n  printf(\"%d\\n\",ans);\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n \nint swap_log[1000][2];\n \nvoid swap(int *, int , int );\n\nvoid Merge(int *, int , int , int );\n \nvoid Merge_Sort(int *, int , int );\n\nlong step_sort(int *, int *, int );\n \nint search_min(int *, int *,int );\n\nlong run_log(int *);\n \nlong sub_sort(int *, int *, int );\n \nlong repeat_sort(int *, int *, int ,long );\n \nlong much_sort(int *, int *, int );\n \nint main()\n{\n  int i,n,*w,*w2;\n  \n  long sum;\n  \n  scanf(\"%d\",&n);\n\n  w = (int*)malloc(sizeof(int) * n);\n  w2 = (int*)malloc(sizeof(int) * n);\n\n  for (i = 0;i < n;i ++)\n    {\n      scanf(\"%d\",w+i);\n      w2[i] = w[i];\n    }\n\n  Merge_Sort(w2,0,n);\n   \n  sum = much_sort(w,w2,n);\n  sum += repeat_sort(w,w2,n,0);\n\n  printf(\"%ld\\n\",sum);\n   \n  return 0;\n}\n\nvoid swap(int *A, int i, int j) {\n\n  int temp;\n\n  temp = A[i];\n  A[i] = A[j];\n  A[j] = temp;\n}\n \nvoid Merge(int *A, int left, int mid, int right) {\n\n  int n1,n2,*L,*R,i,j,k;\n\n  n1 = mid -left;\n  n2 = right - mid;\n  L = (int*)malloc(sizeof(int) * (n1+1));\n  R = (int*)malloc(sizeof(int) * (n2+1));\n\n  for (i = 0;i < n1;i ++){\n    L[i] = A[left+i];\n  }\n  for (i = 0;i < n2;i ++){\n    R[i] = A[mid+i];\n  }\n  \n  L[n1] = INT_MAX; R[n2] = INT_MAX;\n\n  i = 0;\n  j = 0;\n\n  for(k = left; k < right;k ++)\n    {\n      if (L[i] < R[j]) {\n\tA[k] = L[i];\n\ti ++;\n      }else {\n\tA[k] = R[j];\n\tj ++;\n      }\n    }\n  free(L);\n  free(R);\n}\n \nvoid Merge_Sort(int *A, int left, int right) {\n  if(left+1 < right)\n    {\n      int mid = (left + right)/2;\n\n      Merge_Sort(A,left,mid);\n      Merge_Sort(A,mid,right);\n      Merge(A,left,mid,right);\n    }\n}\n\nlong step_sort(int *w, int *w1, int i) {\n\n  int j,k;\n\n  long sum = 0;\n\n  k = 0;\n\n  while(w[i] != w1[i]) {\n    j = 0;\n    while (w[j] != w1[i])j ++;\n\n    sum += w[i]+w[j];\n    swap(w,i,j);\n    swap_log[k][0] = i;\n    swap_log[k][1] = j;\n    i = j;\n    k ++;\n  }\n  swap_log[k][0] = 0;\n  swap_log[k][1] = 0;\n  return sum;\n}\n \nint search_min(int *w, int *w1,int n) {\n\n  int i,j;\n\n  i = 0;\n\n  while(1) {\n    j = 0;\n    while(w[j] != w1[i])j ++;\n    if(i != j)break;\n    i ++;\n    if(i >= n)return n;\n  }\n  return j;\n}\n \nlong run_log(int *w) {\n\n  int i = 0;\n\n  long sum = 0;\n\n  while(swap_log[i][0] != swap_log[i][1])\n    {\n      sum += w[swap_log[i][0]]+w[swap_log[i][1]];\n      swap(w,swap_log[i][0],swap_log[i][1]);\n      i ++;\n    }\n  return sum;\n}\n \nlong sub_sort(int *w, int *w1, int i) {\n\n  long sum;\n \n  if(w[0] != w1[0]) return LONG_MAX;\n\n  int j = 0;\n\n  while(w[i] != w1[j])j ++;\n\n  sum = w[i] + w[0];\n  swap(w,i,0);\n  sum += run_log(w);\n  sum += w[0] + w[j];\n  swap(w,0,j);\n   \n  return sum;\n}\n \nlong repeat_sort(int *w, int *w1, int n,long now) {\n\n  int i;\n  int a1[n];\n  long v1,v2;\n\n  for(i = 0;i < n;i ++){\n    a1[i]=w[i];\n  }\n  \n  i = search_min(w,w1,n);\n\n  if(i == n) return now;\n\n  v1 = step_sort(w,w1,i);\n  v2 = sub_sort(a1,w1,i);\n\n  long min = (v1 < v2) ? v1:v2;\n\n  return repeat_sort(w,w1,n,now+min);\n}\n \nlong much_sort(int *w, int *w1, int n) {\n\n  int i,j;\n  long sum = 0;\n  char *checked = (char*)calloc(n,sizeof(char));\n\n  i = 0;\n\n  while(i < n) {\n    j = 0;\n    while(w[j] != w1[i]) j++;\n\n    if(i != j) {\n      if(w1[j] ==  w[i]) {\n\tsum += w[i] + w[j];\n\tswap(w,i,j);\n      }\n    }\n    checked[i] = 1;\n    checked[j] = 1;\n    while(i < n && checked[i]!=0)i ++;\n  }\n  free(checked);\n  return sum;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX_N  1000\n\nstruct rist\n{\n  int n;\n  int p;\n} typedef rist;\n\nvoid QuickSort(int, int);\nint Partition(int, int);\nint MinimumCost(int);\n\nrist A[MAX_N];\n\nint main()\n{\n\tint i;\n\tint n;\n\tint cost;\n\t\n\tscanf(\"%d\", &n);\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &A[i].n);\n\t\tA[i].p = i;\n\t}\n\t\n\tQuickSort(0, n - 1);\n\tcost = MinimumCost(n);\n\t\n\tprintf(\"%d\\n\", cost);\n\t\n\treturn 0;\n}\n\nvoid QuickSort(int p, int r)\n{\n  int q;\n\n  if(p < r)\n    {\n      q = Partition(p, r);\n      QuickSort(p, q - 1);\n      QuickSort(q + 1, r);\n    }\n}\n\nint Partition(int p, int r)\n{\n\tint i, j;\n\trist tmp;\n\n\ti = p - 1;\n\tfor(j = p; j < r; j++)\n    {\n    \tif(A[j].n <= A[r].n)\n\t\t{\n\t \t\t i = i + 1;\n\t \t\t tmp = A[i];\n\t  \t\tA[i] = A[j];\n\t  \t\tA[j] = tmp;\n\t\t}\n    }\n\ttmp = A[i + 1];\n  \tA[i + 1] = A[r];\n  \tA[r] = tmp;\n  \n  \treturn i + 1;\n}\n\nint MinimumCost(int n)\n{\n\tint i;\n\tint tmp;\n\tint cost;\n\t\n\tfor(i = n - 1; i >= 0; i--)\n\t{\n\t\tif(A[i].p != i)\n\t\t{\n\t\t\tcost += A[i].n + A[A[i].p].n;\n\n\t\t\ttmp = A[A[i].p].p;\n\t\t\tA[A[i].p].p = A[i].p;\n\t\t\tA[i].p = tmp;\n\t\t}\n\t}\n\treturn cost;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <memory.h>\n\n#define MIN(x, y) ((x) <= (y) ? (x) : (y))\nint get_uint() {\n    int n = 0;\n    int c = getchar_unlocked();\n    if(c < 48 || 57 < c) return c;\n    while(47 < c && c < 58) {\n        n = 10 * n + (c & 0xf);\n        c = getchar_unlocked();\n    }\n    return n;\n}\nvoid put_uint(int n) {\n    if(!n) {\n        putchar_unlocked('0');\n        return;\n    }\n    char buf[11];\n    int i = 0;\n    while(n) buf[i++] = (char)(n % 10 + '0'), n /= 10;\n    while(i--)putchar_unlocked(buf[i]);\n}\nvoid *partition(int *first, int *last) {\n    int pivot = *(last - 1);\n    int *p = first - 1;\n    for(int *it = first; it != last - 1; ++it) {\n        if(*it <= pivot) {\n            p++;\n            int tmp = *p;\n            *p = *it;\n            *it = tmp;\n        }\n    }\n    int tmp = *++p;\n    *p = pivot;\n    *(last - 1) = tmp;\n    return p;\n}\nvoid quick_sort(void *first, void *last, size_t N) {\n    if(last - first <= N) return;\n    void *mid = partition(first, last);\n    quick_sort(first, mid, N);\n    quick_sort(mid, last, N);\n}\nint mincost_sort(const int *a, const int N, const int minw) {\n    int cnt = 0;\n    // b[]: sorted arr of b\n    int b[N];\n    memcpy(b, a, N * sizeof(int));\n    quick_sort(b, b + N, sizeof(int));\n    // pos[i]: index of i in b\n    int pos[10001];\n    for(int i = 0; i < N; ++i) pos[b[i]] = i;\n    // flag[i]: is pos[i] checked\n    int flag[1001] = {};\n    for(int i = 0; i < N; ++i) {\n        if(flag[i]) continue;\n        int cur = i;\n        int sum = 0;\n        int num = 0;\n        int mina = 1 << 29;\n        while(!flag[cur]) {\n            flag[cur] = 1;\n            num++;\n            sum += a[cur];\n            mina = MIN(mina, a[cur]);\n            cur = pos[a[cur]];\n        }\n        // [ sum + (num-2)*mina + 2(mina+minw) - (num-1)*(mina-minw) ] -> [ sum + mina + (n+1)*minw ]\n        cnt += MIN(sum + (num - 2) * mina, sum + mina + (num + 1) * minw);\n    }\n    return cnt;\n}\nint main(int argc, char **argv) {\n    int n = get_uint();\n    int w[n];\n    int minw = 1 << 29;\n    for(int i = 0; i < n; ++i) {\n        w[i] = get_uint();\n        minw = MIN(minw, w[i]);\n    }\n    put_uint(mincost_sort(w, n, minw));\n    putchar_unlocked('\\n');\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define NOT_CHECK 0\n#define CHECK 1\n\ntypedef struct element_ {\n\tint idx, val;\n} element;\n\nint element_sort(void *a, void *b) {\n\treturn (*(element*)a).val - (*(element*)b).val;\n}\n\nint main(void) {\n\tint i, n, costs;\n\tint A[1005];\n\tint W[10005];\n\tint chk[1005];\n\telement sortedA[1005];\n\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%d\\n\", &A[i]);\n\t\tsortedA[i].idx = i;\n\t\tsortedA[i].val = A[i];\n\t\tchk[i] = NOT_CHECK;\n\t}\n\n\tqsort((void*)sortedA, n, sizeof(element), element_sort);\n\t// 荷物の重さから元々の位置を取得できるように値を設定\n\tfor(i=0;i<n;i++) W[sortedA[i].val] = i;\n\n\tfor(i=0;i<n;i++) {\n\t\tint p, cost;\n\t\tp = sortedA[i].idx;\n\n\t\tif(sortedA[i].idx == i) {\n\t\t\t// ソート後と同じ位置のため入れ替える必要がない\n\t\t\tchk[i] = CHECK;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// 軽い荷物を使って、正しい場所に入れ替えていく\n\t\tcost = 0;\n\t\twhile(!chk[p]) {\n\t\t\tchk[p] = CHECK;\n\t\t\tcost = cost + A[p];\n\t\t\tp = W[A[p]];\n\t\t}\n\t\tcosts += cost;\n\t}\n\n\tprintf(\"%d\\n\", costs);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\n//============================================================================\n#define pred(x) ((x)-1)\n#define succ(x) ((x)+1)\n//============================================================================\ntypedef unsigned char  INT8U;\ntypedef unsigned short INT16U;\ntypedef   signed short INT16S;\ntypedef long INT32;\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nINT16U *C;\n//----------------------------------------------------------------------------\nvoid CountingSort(INT16U *A, INT16U *B,  INT16U n, INT16U k)\n{\n    long i;\n\n    for (i = 0; i<n; i++)\n        C[A[i]]++;\n    for (i = 1; i<=k; i++)\n        C[i] += C[i-1];\n    // C holds position of A\n    // C[A[val]] = pred val position\n\n    /*for (i = 1; i<=k; i++)\n        printf(\"%d \", C[i]);\n    printf(\"\\n\");*/\n    /*printf(\"B[C[A[i]]-1] = A[i];\\n\");\n    for (i=n-1; 0<=i; i--){\n        //B[C[A[i]]-1] = A[i];\n        printf(\"B[%d]=%d C[%d]=%d A[%d]=%d\\n\", C[A[i]]-1, A[i],\n                            A[i], C[A[i]], i, A[i]);\n        //C[A[i]]--;\n    }*/\n}\n//----------------------------------------------------------------------------\nINT16S getminptr(INT16U *A, INT16U N)\n{\n    INT16U i,min; INT16S ptr;\n\n    for (i=0, ptr=-1, min=32767; i<N; i++){\n        if (A[i]<min && pred(C[A[i]])!=i){\n            min=A[i];\n            ptr=i;\n        }\n    }\n    return ptr;\n}\n//----------------------------------------------------------------------------\nlong sum;\nvoid exchange(INT16U *x, INT16U *y)\n{\n    INT16U z;\n\n    z=*x, *x=*y, *y=z;\n    sum+=*x;\n    sum+=*y;\n    //printf(\"ex: %d<-->%d, sum:%ld\\n\", *y, *x, sum);\n}\n//----------------------------------------------------------------------------\nvoid prnary(INT16U *A, INT16U N)\n{\n    int j;\n\n    for (j=0; j<N; j++)\n        printf(\"%2d \", A[j]);\n    printf(\" sum:%ld\\n\", sum);\n}\n//----------------------------------------------------------------------------\nshort linklen(INT16U *A, INT16U N, INT16U val)\n{\n    int idx,n;\n\n\n    for (n=0, idx=val; ; n++){\n        idx=A[pred(C[idx])];\n        if (idx==val)\n            return n;\n    }\n}\n//----------------------------------------------------------------------------\nvoid duplication(INT16U *A, INT16U N)\n{\n    int i,j,k,n,a,ary[3];\n\n#ifdef DESKTOP\n    prnary(A, N);\n#endif\n    for (i=sum=0; i<pred(N); i++){\n        n=linklen(A, N, A[i]);\n        if (n==1){\n            j=pred(C[A[i]]);\n            exchange(&A[i], &A[j]);\n            printf(\"ex:(%d<->%d), \", A[i], A[j]);\n        }else\n        if (n==2){\n            ary[0]=i;\n            ary[1]=pred(C[A[i]]);\n            ary[2]=pred(C[A[ary[1]]]);\n            for (j=a=0,k=20000; j<3; j++)\n            if (A[ary[j]]<k){\n                k=A[ary[j]];\n                a=ary[j];\n            }\n            j=pred(C[A[a]]);\n            k=pred(C[A[j]]);\n            if (A[j]<A[k]){\n                //printf(\"ex:(%d<->%d), \", A[a], A[k]); // 44<>96\n                exchange(&A[a], &A[k]);\n            }else{\n                //printf(\"ex:(%d<->%d), \", A[a], A[j]); // 44<>96\n                exchange(&A[a], &A[j]);\n            }\n            printf(\"ex:(%d<->%d), \", A[k], A[j]); // 44<>96\n            exchange(&A[k], &A[j]);\n        }\n#ifdef DESKTOP\n    }\n    printf(\"\\n\");\n#else\n    }\n#endif\n}\n//----------------------------------------------------------------------------\nlong mincostsort(INT16U *A, INT16U N)\n{\n    int ptr,i,j,min,ordptr,order[100];\n\n    duplication(A, N);\n    for (i=0,j=32000; i<N; i++)\n        if (A[i]<j)\n            j=A[i],min=i;\n    for (ordptr=0; 0<=(ptr=getminptr(A, N));){\n#ifdef DESKTOP\n    printf(\"[%d]\\n\", A[ptr]);\n#endif\n        order[ordptr++]=A[ptr];\n        if (A[min]*2<A[ptr]){\n            exchange(&A[min], &A[ptr]);\n            min=ptr;\n        }\n        while (pred(C[A[ptr]])!=ptr){\n            for (i=0; i<N; i++)\n                if (C[A[i]]==succ(ptr)){\n                    order[ordptr++]=A[i];\n                    if (ptr==min) min=i;\n                    exchange(&A[ptr], &A[i]);\n                    ptr=i;\n#ifdef DESKTOP\n                    //prnary(A, N);\n#endif\n                    break;\n                }\n        }\n    }\n#ifdef DESKTOP\n    for (i=0; i<ordptr; i++){\n        if (i) printf(\"->\");\n            printf(\"%d\", order[i]);\n    }\n    printf(\"\\n\");\n#endif\n    return sum;\n}\n//----------------------------------------------------------------------------\n/*\n*                                         *     *\n0 62 33 29 72 52 43 19 5  93 51 32  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51  5  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51 47  8 11 56  5 66 69 30 17 68  5\n0  5 33 29 72 52 43 19 32 93 51 47  8 11 56 62 66 69 30 17 68  0\n0  5 33 29 72 52 43 19 32 93  8 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 29 72 52  8 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33  8 72 52 29 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 11 72 52 29 19 32 93 43 47 51  8 56 62 66 69 30 17 68  8\n0  5 33 11 72  8 29 19 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29  8 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 69  8 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66  8 69 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 68 69 17  8  8\n0  5 33 11 72 19 29 30 32  8 43 47 51 52 56 62 66 68 69 17 93  8\n0  5  8 11 72 19 29 30 32 33 43 47 51 52 56 62 66 68 69 72 93  0\n0  5  8 11 17 19 29 30 32 33 43 47 51 52 56 62 66 68 69 17 93  0\n\n 1 80 50 70 40 20\n20 80 50 70 40  1\n20  1 50 70 40 80\n 1 20 50 70 40 80 21        20 40 50 70  1 80   41\n40 20 50 70  1 80 41        20 40 50  1 70 80   71\n40 20 50  1 70 80 71        20 40  1 50 70 80   51\n40 20  1 50 70 80 51        20  1 40 50 70 80   41\n 1 20 40 50 70 80 41         1 20 40 50 70 80   21\n\n\n5\n1 5 3 4 2\n7\n\n4\n4 3 2 1\n10\n*/\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nvoid input(FILE *file)\n{\n    long i,n,max,ave; INT16U *A, *B; char buffer[20];\n\n    fgets(buffer, sizeof(buffer)-1, file);\n    sscanf(buffer, \"%ld\", &n);\n    A = malloc(succ(n)*sizeof(INT16U));\n    B = malloc(succ(n)*sizeof(INT16U));\n    for (i=ave=max=0; i<n; i++){\n        fscanf(file, \"%hd\",  &A[i]);\n        if (max<A[i])\n            max=A[i];\n        ave+=A[i];\n    }\n    ave/=n;\n    C = malloc(succ(max)*sizeof(INT16U));\n    memset(C, 0, sizeof(INT16U)*succ(max));\n    CountingSort(A, B, n, max);\n    printf(\"%ld\\n\", mincostsort(A, n));\n#ifdef DESKTOP\n    for (i=0; i<n; i++){\n        if (i) printf(\" \");\n        printf(\"%hd\", A[i]);\n    }\n    printf(\"\\n\");\n#endif\n    free(A);\n    free(B);\n    free(C);\n}\n//============================================================================\n#ifndef DESKTOP\nint main()\n{\n    input(stdin);\n    return 0;\n}\n#endif"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n//toriaezu\n\nint cost;\n\nint sort(int *A,int n){\n  int i,j;\n  int tmp;\n  int min=1000,max=0;\n  int im,iM;\n  for(i=1;i<n;i++){\n    if(i!=n && A[i]>max){\n      max=A[i];\n      iM=i;\n    }\n    else if(A[i]<min){\n      min=A[i];\n      im=i;\n    }\n  }\n    printf(\"%d %d\\n\",im,iM); \n    if(iM>im) return 1;\n    tmp=A[im];\n    A[im]=A[iM];\n    A[iM]=tmp;\n\n    cost+=max+min;\n    sort(&A[0],n);\n\n}\nint main(){\n  \n  int i,n,a;\n  int A[1000];\n  cost=0;\n  scanf(\"%d\",&n);\n\n  for(i=0;i<n;i++) scanf(\"%d\",&A[i]);\n  a=sort(&A[0],n);\n  \n  printf(\"%d\\n\",cost);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\n//============================================================================\n#define pred(x) ((x)-1)\n#define succ(x) ((x)+1)\n//============================================================================\ntypedef unsigned char  INT8U;\ntypedef unsigned short INT16U;\ntypedef   signed short INT16S;\ntypedef long INT32;\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nINT16U *C;\n//----------------------------------------------------------------------------\nvoid CountingSort(INT16U *A, INT16U *B,  INT16U n, INT16U k)\n{\n    long i;\n\n    for (i = 0; i<n; i++)\n        C[A[i]]++;\n    for (i = 1; i<=k; i++)\n        C[i] += C[i-1];\n    /*for (i = 1; i<=k; i++)\n        printf(\"%d \", C[i]);\n    printf(\"\\n\");\n    printf(\"B[C[A[i]]-1] = A[i];\\n\");\n    for (i=n-1; 0<=i; i--){\n        B[C[A[i]]-1] = A[i];\n        printf(\"B[%d]=%d C[%d]=%d A[%d]=%d\\n\", C[A[i]]-1, B[C[A[i]]-1],\n                            A[i], C[A[i]], i, A[i]);\n        C[A[i]]--;\n    }*/\n}\n//----------------------------------------------------------------------------\nINT16S getminptr(INT16U *A, INT16U N)\n{\n    INT16U i,min; INT16S ptr;\n\n    for (i=0, ptr=-1, min=32767; i<N; i++){\n        if (A[i]<min && pred(C[A[i]])!=i){\n            min=A[i];\n            ptr=i;\n        }\n    }\n    return ptr;\n}\n//----------------------------------------------------------------------------\nlong sum;\nvoid exchange(INT16U *x, INT16U *y)\n{\n    INT16U z;\n\n    z=*x, *x=*y, *y=z;\n    sum+=*x;\n    sum+=*y;\n    //printf(\"ex: %d<-->%d, sum:%ld\\n\", *y, *x, sum);\n}\n//----------------------------------------------------------------------------\nlong mincostsort(INT16U *A, INT16U N)\n{\n    int ptr,i,j,min;\n\n    for (i=sum=0; i<pred(N); i++)\n    for (j=succ(i); j<N; j++)\n        if (pred(C[A[j]])==i && pred(C[A[i]])==j)\n            exchange(&A[i], &A[j]);\n    for (i=0,j=32000; i<N; i++)\n        if (A[i]<j)\n            j=A[i],min=i;\n    for (; 0<=(ptr=getminptr(A, N));){\n        if (A[min]*2<A[ptr]){\n            exchange(&A[min], &A[ptr]);\n            min=ptr;\n        }\n        while (pred(C[A[ptr]])!=ptr){\n            for (i=0; i<N; i++)\n                if (C[A[i]]==succ(ptr)){\n                    if (ptr==min) min=i;\n                    exchange(&A[ptr], &A[i]);\n                    ptr=i;\n#ifdef DESKTOP\n                    for (j=0; j<N; j++)\n                        printf(\"%2d \", A[j]);\n                    printf(\" sum:%ld\\n\", sum);\n#endif\n                    break;\n                }\n        }\n    }\n    return sum;\n}\n//----------------------------------------------------------------------------\n/*\n*                                         *     *\n0 62 33 29 72 52 43 19 5  93 51 32  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51  5  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51 47  8 11 56  5 66 69 30 17 68  5\n0  5 33 29 72 52 43 19 32 93 51 47  8 11 56 62 66 69 30 17 68  0\n0  5 33 29 72 52 43 19 32 93  8 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 29 72 52  8 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33  8 72 52 29 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 11 72 52 29 19 32 93 43 47 51  8 56 62 66 69 30 17 68  8\n0  5 33 11 72  8 29 19 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29  8 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 69  8 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66  8 69 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 68 69 17  8  8\n0  5 33 11 72 19 29 30 32  8 43 47 51 52 56 62 66 68 69 17 93  8\n0  5  8 11 72 19 29 30 32 33 43 47 51 52 56 62 66 68 69 72 93  0\n0  5  8 11 17 19 29 30 32 33 43 47 51 52 56 62 66 68 69 17 93  0\n\n\n\n\n5\n1 5 3 4 2\n7\n\n4\n4 3 2 1\n10\n*/\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nvoid input(FILE *file)\n{\n    long i,n,max,ave; INT16U *A, *B; char buffer[20];\n\n    fgets(buffer, sizeof(buffer)-1, file);\n    sscanf(buffer, \"%ld\", &n);\n    A = malloc(succ(n)*sizeof(INT16U));\n    B = malloc(succ(n)*sizeof(INT16U));\n    for (i=ave=max=0; i<n; i++){\n        fscanf(file, \"%hd\",  &A[i]);\n        if (max<A[i])\n            max=A[i];\n        ave+=A[i];\n    }\n    ave/=n;\n    C = malloc(succ(max)*sizeof(INT16U));\n    memset(C, 0, sizeof(INT16U)*succ(max));\n    CountingSort(A, B, n, max);\n    printf(\"%ld\\n\", mincostsort(A, n));\n#ifdef DESKTOP\n    for (i=0; i<n; i++){\n        if (i) printf(\" \");\n        printf(\"%hd\", A[i]);\n    }\n    printf(\"\\n\");\n#endif\n    free(A);\n    free(B);\n    free(C);\n}\n//============================================================================\n#ifndef DESKTOP\nint main()\n{\n    input(stdin);\n    return 0;\n}\n#endif"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nvoid quicksort(int ,int );\nint n,W[1000];\nint main(void){\n  int i,cost1,cost2,total_cost=0,now,S,min,x=10000,rate;//S is sum\n  int Copy[1000],Element[10001],Bool[1000];\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&W[i]);\n    Copy[i]=W[i];\n    Bool[i]=0;\n    if(x>W[i])x=W[i];\n  }\n\n  quicksort(0,n-1);\n  //calculate cost\n  i=0;\n  while(i<n){\n    Element[W[i]]=i;\n    i++;\n  }\n  \n  i=0;\n  while(i<n){\n    if(Bool[i]==0){\n      now=i;\n      S=0;\n      min=10000;\n      rate=0;\n      while(1){\n        Bool[now]=1;\n        rate++;\n        if(min>Copy[now])\n          min=Copy[now];\n        S+=Copy[now];\n        now=Element[Copy[now]];\n        if(Bool[now]==1)break;\n      }\n      cost1=S+(rate-2)*min;\n      cost2=S+min+(rate+1)*x;\n      if(cost1<cost2)\n        total_cost+=cost1;\n      else total_cost+=cost2;\n    }\n    i++;\n  }\n  //finish calculate cost\n\n  printf(\"%d\\n\",total_cost);\n  return 0;\n}\n//quicksort include partition\nvoid quicksort(int head,int last){\n  int element;\n  if(last-head>0){\n    element=partition(head,last);\n    quicksort(head,element-1);\n    quicksort(element+1,last);\n  }\n}\nint partition(int head,int last){\n  int i,temp,last_number;\n  last_number=W[last];\n  for(i=head;i<last;i++){\n    if(W[i]<=last_number){\n      temp=W[head];\n      W[head++]=W[i];\n      W[i]=temp;\n    }\n  }\n  temp=W[head];\n  W[head]=W[last];\n  W[last]=temp;\n  return head;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid Sort(int*,int,int);\nint Cost_Sort(int*,int,int);\n\nint sum=0;\n\nmain(){\n  int i,n,*A;\n\n  scanf(\"%d\",&n);\n\n  A=(int *)malloc(sizeof(int)*n);\n\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n  }\n\n  Sort(A,0,n-1);\n\n  printf(\"%d\\n\",sum);\n\n  return 0;\n}\n\nvoid Sort(int *A,int i,int n){\n  int p,j;\n  \n  if(i<n){\n    p=Cost_Sort(A,i,n);\n\n    Sort(A,i,p);\n  }\n}\n\nint Cost_Sort(int *A,int i,int n){\n  int k,j,tmp,max=A[i];\n\n  for(j=i+1;j<=n;j++){\n    if(max<A[j]){\n      max=A[j];\n      k=j;\n    }\n  }\n  if(k!=n){\n    sum+=A[k]+A[n];\n    tmp=A[k];\n    A[k]=A[n];\n    A[n]=tmp;\n  }\n\n  return n-1;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdbool.h>\n#define MAX 1000\n#define VMAX 10000\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nvoid sort(int A[])\n{\n\tint temp;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif(A[i] > A[j])\n\t\t\t{\n\t\t\t\ttemp = A[i];\n\t\t\t\tA[i] = A[j];\n\t\t\t\tA[j] = temp;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint min(int a, int b)\n{\n\tif(a < b) return a;\n\telse return b;\n}\n\nint solve(){\n\tint ans = 0;\n\t\n\tbool V[MAX];\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B);\n\tfor(int i = 0 ; i < n; i++)\n\t{\n\t\tT[B[i]] = i;\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(V[i]) continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile(1)\n\t\t{\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif(V[cur]) break;\n\t\t}\n\t\tans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n\t}\n\treturn ans;\n}\n\n\nint main(void)\n{\n\tscanf(\"%d\", &n);\n\ts = VMAX;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &A[i]);\n\t\ts = min(s, A[i]);\n\t}\n\tint ans = solve();\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 101\ntypedef struct {\n  int sum;\n  int flag;\n} CC;\nCC C[N];\nint A[1000],B[1000];\nint main()\n{\n  int i,n,min=0,m,k,now,sum=0,minx;\n  scanf(\"%d\",&n);\n  for(i=1;i<n+1;i++){\n    scanf(\"%d\",&A[i]);\n  }\n  minx=A[0];\n  for(i=1;i<n;i++){\n    if(minx>A[i])minx=A[i];\n  }\n  for(i=0;i<N;i++){\n    C[i].sum=0;\n    C[i].flag=0;\n  }\n  for(i=1;i<n+1;i++){\n    C[A[i]].sum+=1;\n    C[A[i]].flag+=1;\n  }\n  for(i=0;i<N;i++){\n    C[i].sum+=C[i-1].sum;\n  }\n\n  for(i=n+1;i>0;i--){\n    if(C[A[i]].flag==1){\n      k=i;\n      now=k;\n      m=0;\n      B[C[A[k]].sum]=A[k];\n      C[A[i]].flag=0;\n      min=A[k];\n      k=C[A[k]].sum;\n      while(A[now]!=A[k]){\n        if(m==0){\n          sum+=A[now];\n\t  //printf(\"%d \",A[now]);\n        }\n        //printf(\"%d \",A[k]);\n        B[C[A[k]].sum]=A[k];\n        C[A[k]].flag=0;\n        sum+=A[k];\n        if(min>A[k]) min=A[k];\n        k=C[A[k]].sum;\n        m+=1;\n      }\n      if(m>1)sum+=min+(m+1)*minx;\n      m=0;\n      min=0;\n    }\n  }\n  /* printf(\"\\n\");\n  for(i=1;i<n;i++){\n    printf(\"%d \",B[i]);\n  }\n  printf(\"%d\",B[i]);*/\n  printf(\"%d\\n\",sum);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1000\n#define MAX_D 10001\n\nint main(){\n  int N, arr[MAX], _arr[MAX], dest[MAX_D];\n  bool used[MAX];\n\n  cin >> N;\n  for(int i = 0 ; i < N ; i++){\n    cin >> arr[i];\n    used[i] = false;\n    _arr[i] = arr[i];\n  }\n  sort(_arr, _arr+N);\n\n  for(int i = 0 ; i < N ; i++){\n    dest[_arr[i]] = i;\n  }\n\n  int ans = 0;\n  for(int i = 0 ; i < N ; i++){\n    if(dest[arr[i]] == i || used[i]){\n      used[i] = true;\n      continue;\n    }\n\n    int cnt = -1, sum = 0, min = arr[i], next = i;\n    for( ; !used[next] ; ){\n      sum += arr[next]; cnt++;\n      min = std::min(min, arr[next]);\n      used[next] = true;\n      next = dest[arr[next]];\n    }\n    sum -= min;\n    ans += sum + min*cnt;\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX 1000\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\n\nint A[MAX] = {0};\nint B[MAX] = {0};\nint T[10000 + 1];\nint n, s;\n\nint partition(int A[], int p, int r) {\n\tint x, i, j, tmp;\n\tx = A[r];\n\ti = p - 1;\n\n\tfor (j = p; j < r; ++j) {\n\t\tif (A[j] <= x) {\n\t\t\t++i;\n\t\t\ttmp = A[i];\n\t\t\tA[i] = A[j];\n\t\t\tA[j] = tmp;\n\t\t}\n\t}\n\ttmp = A[i+1];\n\tA[i+1] = A[r];\n\tA[r] = tmp;\n\treturn i + 1;\n}\n\nvoid quicksort(int A[], int p, int r) {\n\tint q;\n\tif (p < r) {\n\t\tq = partition(A, p, r);\n\t\tquicksort(A, p, q-1);\n\t\tquicksort(A, q+1, r);\n\t}\n}\n\nint solve() {\n\tint ans = 0;\n\tint i, cur, S, m, an, v;\n\tshort V[MAX] = {0};\n\n\tfor (i = 0; i < n; ++i) {\n\t\tB[i] = A[i];\n\t\tV[i] = 0;\n\t}\n\tquicksort(B, 0, n-1);\n\t/* for (i = 0; i < n; ++i) { */\n\t/* \tprintf(\"%d \", B[i]); */\n\t/* } */\n\tprintf(\"\\n\");\n\n\tfor (i = 0; i < n; ++i) T[B[i]] = i;\n\tfor (i = 0; i < n; ++i) {\n\t\tif (V[i]) continue;\n\t\tcur = i;\n\t\tS = 0;\n\t\tm = INT_MAX;\n\t\tan = 0;\n\t\twhile (1) {\n\t\t\tV[cur] = 1;\n\t\t\tan++;\n\t\t\tv = A[cur];\n\t\t\tm = MIN(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\t//\tprintf(\"i = %d, cur = %d, v = %d, S = %d, an = %d, ans = %d\\n\", i, cur, v, S, an, ans);\n\t\t\tif (V[cur]) break;\n\t\t}\n\t\tans += MIN(S + (an - 2) * m, m + S + (an + 1) * s);\n\t}\n\n\treturn ans;\n}\n\nint main(void) {\n\tint i;\n\tscanf(\"%d\", &n);\n\ts = INT_MAX;\n\t\n\tfor (i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &A[i]);\n\t\tif (s > A[i]) s = A[i];\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define NOT_CHECK 0\n#define CHECK 1\n\ntypedef struct element_ {\n\tint idx, val;\n} element;\n\nint element_sort(void *a, void *b) {\n\treturn (*(element*)a).val - (*(element*)b).val;\n}\n\nint main(void) {\n\tint i, n, costs, m;\n\tint A[1005];\n\tint W[10005];\n\tint chk[1005];\n\telement sortedA[1005];\n\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%d\\n\", &A[i]);\n\t\tsortedA[i].idx = i;\n\t\tsortedA[i].val = A[i];\n\t\tW[A[i]] = i;\n\t\tchk[i] = NOT_CHECK;\n\t}\n\n\tqsort((void*)sortedA, n, sizeof(element), element_sort);\n\n\tm = sortedA[0].val;\n\tcosts = 0;\n\tfor(i=0;i<n;i++) {\n\t\tint p, cost, lt, cnt, t;\n\t\tp = i;\n\n\t\tt = 0;\n\t\tcnt = 0;\n\t\tlt = 10005;\n\t\twhile(chk[p]==NOT_CHECK) {\n\t\t\tchk[p] = CHECK;\n\t\t\tt += A[p];\n\t\t\tcnt++;\n\t\t\tif(lt > A[p]) lt = A[p];\n\t\t\tp = W[sortedA[p].val];\n\t\t}\n\t\tif(cnt<2) continue;\t// 入れ替えが発生し始めるのはcntが2以上になってから\n\t\t\n\t\t// 入れ替え中に見つかった最小値を入れ替えに使った方がコストが低いか\n\t\t// 回り道して最小の値を使って入れ替えに使った方がコストが低いか\n\t\tcost = t+m*(cnt+1)+lt;\t// lt -> m ・・ m -> A[k] ・・ m -> lt\n\t\tif(cost>t+lt*(cnt-2)) cost = t+lt*(cnt-2);\n\t\tcosts += cost;\n\t}\n\n\tprintf(\"%d\\n\", costs);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\nint SelectionSort(int * array, int N){\n    \n    int i, j, maxj, tmp, ans;\n    ans = 0;\n    \n    for(i = N-1; i >=0; i--){\n        maxj = i;\n        for(j = i; j >= 0; j--){\n            maxj = array[j] > array[maxj] ? j : maxj;\n        }\n        if(i != maxj){\n            ans += (array[maxj] + array[i]);\n            tmp = array[maxj];\n            array[maxj] = array[i];\n            array[i] = tmp;\n            \n        }\n    }\n    return ans;\n}\n\n\nint partition(int *A, int left, int right){\n    \n    /*pivot??¨?????????????????????????´?????????¶*/\n    int pivot = A[right];\n    int i = left - 1;\n    int j;\n    int tmp;\n    \n    for (j=left; j<right; j++) {\n        if (A[j] <= pivot) {\n            i = i+1;\n            /* A[i] ??¨ A[j] ????????? */\n            tmp = A[i];\n            A[i] = A[j];\n            A[j] = tmp;\n        }\n    }\n    \n    /* A[i+1] ??¨ A[r] ????????? */\n    tmp = A[i+1];\n    A[i+1] = A[right];\n    A[right] = tmp;\n    \n    return i+1;\n}\n\n/*\n * *A int type array\n * left?????????A????????????????´??????????\n * right?????????A????????????????´??????????\n */\nvoid quicksort(int * A, int left, int right){\n    \n    int q;\n    if (left < right) {\n        q = partition(A, left, right);\n        quicksort(A, left, q-1);\n        quicksort(A, q+1, right);\n    }\n    \n}\n\n\nvoid minimumCostSort(int *A, int n){\n    \n}\n\n\nint arraycmp(int * A, int *B, int n){\n    int i, rtn=0;\n    \n    \n    for (i=0; i< n; i++) {\n        if (A[i] != B[i]) {\n            rtn++;\n        }\n    }\n    return rtn;\n}\n\nvoid mkarray(int *A, int *B, int n, int *C){\n    int i;\n    int j = 0;\n    \n    for (i=0; i < n; i++) {\n        if (A[i] != B[i]) {\n            C[j] = A[i];\n            j++;\n        }\n    }\n}\n\nint main( ){\n    \n    int n, m, i, *A, *B, *C, ans;\n    \n    A = (int*)malloc(sizeof(int)*n);\n    B = (int*)malloc(sizeof(int)*n);\n    \n    \n    scanf(\"%d\", &n);\n    \n    for (i=0; i<n; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n    \n    memcpy(B, A, sizeof(int) * n);\n    \n    quicksort(B, 0, n-1);\n    \n    m = arraycmp(A, B, n);\n    \n    if (m == 0) {\n        printf(\"0\\n\");\n        return 0;\n    }\n    \n    C = (int*)malloc(sizeof(int)*m);\n    \n    mkarray(A, B, n, C);\n    \n    ans = SelectionSort(C, m);\n    \n    printf(\"%d\\n\", ans);\n    \n    \n    \n    free(A);\n    free(B);\n    free(C);\n\n    \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid Sort(int*,int,int);\nint Cost_Sort(int*,int,int);\n\nint sum=0/*,s*/;\n\nmain(){\n  int i,n,*A;\n\n  scanf(\"%d\",&n);\n  //s=n;\n  A=(int *)malloc(sizeof(int)*n);\n\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n  }\n\n  Sort(A,0,n-1);\n\n  printf(\"%d\\n\",sum);\n\n  return 0;\n}\n\nvoid Sort(int *A,int i,int n){\n  int p,j;\n  \n  if(i<n){\n    p=Cost_Sort(A,i,n);\n\n    /*for(j=0;j<s;j++){\n      printf(\"%d \",A[j]);\n    }\n    printf(\"\\n\");*/\n\n    Sort(A,i,p);\n  }\n}\n\nint Cost_Sort(int *A,int i,int n){\n  int j,tmp,max=A[i],k=0;\n  for(j=i+1;j<=n;j++){\n    if(max<A[j]){\n      max=A[j];\n      k=j;\n    }\n  }\n  if(k!=n){\n    sum+=A[k]+A[n];\n    tmp=A[k];\n    A[k]=A[n];\n    A[n]=tmp;\n  }\n\n  return n-1;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\n//============================================================================\n#define pred(x) ((x)-1)\n#define succ(x) ((x)+1)\n//============================================================================\ntypedef unsigned char  INT8U;\ntypedef unsigned short INT16U;\ntypedef   signed short INT16S;\ntypedef long INT32;\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nINT16U *C;\n//----------------------------------------------------------------------------\nvoid CountingSort(INT16U *A, INT16U *B,  INT16U n, INT16U k)\n{\n    long i;\n\n    for (i = 0; i<n; i++)\n        C[A[i]]++;\n    for (i = 1; i<=k; i++)\n        C[i] += C[i-1];\n    /*for (i = 1; i<=k; i++)\n        printf(\"%d \", C[i]);\n    printf(\"\\n\");\n    printf(\"B[C[A[i]]-1] = A[i];\\n\");\n    for (i=n-1; 0<=i; i--){\n        B[C[A[i]]-1] = A[i];\n        printf(\"B[%d]=%d C[%d]=%d A[%d]=%d\\n\", C[A[i]]-1, B[C[A[i]]-1],\n                            A[i], C[A[i]], i, A[i]);\n        C[A[i]]--;\n    }*/\n}\n//----------------------------------------------------------------------------\nlong sum;\nvoid exchange(INT16U *x, INT16U *y)\n{\n    INT16U z;\n\n    z=*x, *x=*y, *y=z;\n    sum+=*x;\n    sum+=*y;\n}\n//----------------------------------------------------------------------------\nlong mincostsort(INT16U *A, INT16U N)\n{\n    INT16U i,j;\n\n    for (i=sum=0; i<N; i++){\n        if ((j=pred(C[A[i]]))!=i){\n            exchange(&A[i], &A[j]);\n        }\n    }\n    return sum;\n}\n//----------------------------------------------------------------------------\n/*\n5\n1 5 3 4 2\n7\n\n4\n4 3 2 1\n10\n*/\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nvoid input(FILE *file)\n{\n    long i,n,max,ave; INT16U *A, *B; char buffer[20];\n\n    fgets(buffer, sizeof(buffer)-1, file);\n    sscanf(buffer, \"%ld\", &n);\n    A = malloc(succ(n)*sizeof(INT16U));\n    B = malloc(succ(n)*sizeof(INT16U));\n    for (i=ave=max=0; i<n; i++){\n        fscanf(file, \"%hd\",  &A[i]);\n        if (max<A[i])\n            max=A[i];\n        ave+=A[i];\n    }\n    ave/=n;\n    C = malloc(succ(max)*sizeof(INT16U));\n    memset(C, 0, sizeof(INT16U)*succ(max));\n    CountingSort(A, B, n, max);\n    printf(\"%ld\\n\", mincostsort(A, n));\n#ifdef DESKTOP\n    for (i=0; i<n; i++){\n        if (i) printf(\" \");\n        printf(\"%hd\", A[i]);\n    }\n    printf(\"\\n\");\n#endif\n    free(A);\n    free(B);\n    free(C);\n}\n//============================================================================\n#ifndef DESKTOP\nint main()\n{\n    input(stdin);\n    return 0;\n}\n#endif"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n\n\n\nint n,cost;\nint A[1001],B[1001];\nint L[501],R[502];\n\n\nvoid merge(int left,int mid,int right){\n  int i,j,n1=mid-left,n2=right-mid;\n  for(i=0;i<n1;i++) L[i]=A[left+i];\n  L[n1]=INT_MAX;\n  for(i=0;i<n2;i++) R[i]=A[mid+i];\n  R[n2]=INT_MAX;\n  int l=0,r=0;\n  for(i=left;i<right;i++){\n    if(L[l]<=R[r]){\n      A[i]=L[l];\n      l++;\n    }\n    else{\n      A[i]=R[r];\n      r++;\n    }\n  }\n}\n\n\nvoid m_sort(int left,int right){\n  int mid;\n  if( left+1 >= right) return;\n  mid=(left+right)/2;\n  m_sort(left,mid);\n  m_sort(mid,right);\n  merge(left,mid,right);\n}\n\n\nvoid swap(int a,int b,int *C){\n  int swap;\n  swap=C[a];\n  C[a]=C[b];\n  C[b]=swap;\n}\n\n\n/*??£????????´??????????????°???????????§????°??????????????????¢?????????????????????*/\nint min_search(int *C){\n  int res=n,i;\n  C[n]=INT_MAX;\n  for(i=0;i<n;i++){\n    if(A[i]!=C[i]){\n      if(C[res] >C[i]) res =i;\n    }\n  }\n  return res;\n}\n\n\n\n\n\n\nint quest(int *C,int num,int jud){\n  int D[1001],E[1001],i,x,ans,ans2,judd;\n  if(jud==n) x=min_search(C);\n  else x=jud;\n  if(x==n) return num;\n  for(i=0;i<n;i++) D[i]=C[i];\n  i=0;\n  while(1){\n    if(D[i]==A[x]){\n      swap(i,x,D);\n      judd=i;\n      if(D[i]==A[i]) judd=n;\n      ans=quest(D,num+D[i]+D[x],judd);\n      break;\n    }\n    i++;  \n  }\n  if(E[x]!=A[0]){\n    for(i=0;i<n;i++) E[i]=C[i];\n    swap(0,x,E);\n    ans2=quest(E,num+E[0]+E[x],x);\n    if(ans > ans2) ans=ans2;\n  }\n  return ans;\n}\n  \n \n  \n\nint main(){\n  scanf(\"%d\",&n);\n  int i,j,min=n;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n  m_sort(0,n);\n  cost=0;\n  for(i=0;i<n;i++){\n    for(j=i+1;j<n;j++){\n      if(B[i]==A[j]){\n        if(B[j]==A[i]){\n          swap(i,j,B);\n          cost+=B[i]+B[j];\n        }\n        break;\n      }\n    } \n  }\n  while(1){\n    if(min==n) min=min_search(B);\n    if(B[min]!=A[0]){\n      break;\n    }\n    else{\n      if(min==n) break;\n      for(i=0;i<n;i++){\n        if(A[min]==B[i]){\n          if(min==i){\n            min=n;\n            break;\n          }\n          swap(min,i,B);\n          cost+=B[min]+B[i];\n          min=i;\n          break;\n        }\n      }\n    }\n  }\n  cost=quest(B,cost,n);\n  printf(\"%d\\n\",cost);\n  return 0;\n}\n   \n          \n          \n    "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 101\ntypedef struct {\n  int sum;\n  int flag;\n} CC;\nCC C[N];\nint A[1000],B[1000];\nint main()\n{\n  int i,n,min=0,m,k,now,sum=0,minx,sum1,sum2;\n  scanf(\"%d\",&n);\n  for(i=1;i<n+1;i++){\n    scanf(\"%d\",&A[i]);\n  }\n  minx=A[1];\n  for(i=2;i<n+1;i++){\n    if(minx>A[i])minx=A[i];\n  }\n  for(i=0;i<N;i++){\n    C[i].sum=0;\n    C[i].flag=0;\n  }\n  for(i=1;i<n+1;i++){\n    C[A[i]].sum+=1;\n    C[A[i]].flag+=1;\n  }\n  for(i=0;i<N;i++){\n    C[i].sum+=C[i-1].sum;\n  }\n\n  for(i=n+1;i>0;i--){\n    if(C[A[i]].flag==1){\n      k=i;\n      now=k;\n      m=0;\n      B[C[A[k]].sum]=A[k];\n      C[A[i]].flag=0;\n      min=A[k];\n      k=C[A[k]].sum;\n      while(A[now]!=A[k]){\n        if(m==0){\n          sum+=A[now];\n\t  //printf(\"%d \",A[now]);\n        }\n        //printf(\"%d \",A[k]);\n        B[C[A[k]].sum]=A[k];\n        C[A[k]].flag=0;\n        sum+=A[k];\n        if(min>A[k])min=A[k];\n        k=C[A[k]].sum;\n        m+=1;\n      }\n      sum2=min*(m-1);\n      sum1=min+(m+1)*minx;\n      if(m>1){      \n\tif(sum1<sum2){\n\t  sum+=sum1;\n\t}\n\telse sum+=sum2;     \n\tm=0;\n\tmin=0;\n      }\n    }\n    \n  }\n  /* printf(\"\\n\");\n  for(i=1;i<n;i++){\n    printf(\"%d \",B[i]);\n  }\n  printf(\"%d\",B[i]);*/\n  printf(\"%d\\n\",sum);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n\n\n\nint n,cost;\nint A[1001],B[1001];\nint L[501],R[502];\n\n\nvoid merge(int left,int mid,int right){\n  int i,j,n1=mid-left,n2=right-mid;\n  for(i=0;i<n1;i++) L[i]=A[left+i];\n  L[n1]=INT_MAX;\n  for(i=0;i<n2;i++) R[i]=A[mid+i];\n  R[n2]=INT_MAX;\n  int l=0,r=0;\n  for(i=left;i<right;i++){\n    if(L[l]<=R[r]){\n      A[i]=L[l];\n      l++;\n    }\n    else{\n      A[i]=R[r];\n      r++;\n    }\n  }\n}\n\n\nvoid m_sort(int left,int right){\n  int mid;\n  if( left+1 >= right) return;\n  mid=(left+right)/2;\n  m_sort(left,mid);\n  m_sort(mid,right);\n  merge(left,mid,right);\n}\n\n\nvoid swap(int a,int b,int *C){\n  int swap;\n  swap=C[a];\n  C[a]=C[b];\n  C[b]=swap;\n}\n\n\n/*??£????????´??????????????°???????????§????°??????????????????¢?????????????????????*/\nint min_search(int *C){\n  int res=n,i;\n  C[n]=INT_MAX;\n  for(i=0;i<n;i++){\n    if(A[i]!=C[i]){\n      if(C[res] >C[i]) res =i;\n    }\n  }\n  return res;\n}\n\n\n\n\n\n\nint quest(int *C,int num,int jud,int nokorii){\n  int D[1001],E[1001],i,x,ans,ans2,judd,nokori;\n  if(jud==n) x=min_search(C);\n  else x=jud;\n  if(x==n) return num;\n  for(i=0;i<n;i++){\n    D[i]=C[i];\n    E[i]=C[i];\n  }\n  i=0;\n  while(1){\n    if(D[i]==A[x]){\n      swap(i,x,D);\n      nokori=nokorii-1;\n      judd=i;\n      if(D[i]==A[i]){\n        judd=n;\n        nokori--;\n      }\n      ans=quest(D,num+D[i]+D[x],judd,nokori);\n      break;\n    }\n    i++;  \n  }\n  if(E[x]!=A[0] && nokorii>=6){\n    swap(0,x,E);\n    nokori=nokorii+2;\n    ans2=quest(E,num+E[0]+E[x],x,nokori);\n    if(ans > ans2) ans=ans2;\n  }\n  return ans;\n}\n  \n \n  \n\nint main(){\n  scanf(\"%d\",&n);\n  int nokori=n;\n  int i,j,min=n;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n  m_sort(0,n);\n  for(i=0;i<n;i++){\n    if(A[i]==B[i]) nokori--;\n  }\n  cost=0;\n  for(i=0;i<n;i++){\n    for(j=i+1;j<n;j++){\n      if(B[i]==A[j]){\n        if(B[j]==A[i]){\n          swap(i,j,B);\n          nokori-=2;\n          cost+=B[i]+B[j];\n        }\n        break;\n      }\n    } \n  }\n  while(1){\n    if(min==n) min=min_search(B);\n    if(B[min]!=A[0]){\n      break;\n    }\n    else{\n      if(min==n) break;\n      for(i=0;i<n;i++){\n        if(A[min]==B[i]){\n          if(min==i){\n            min=n;\n            break;\n          }\n          swap(min,i,B);\n          nokori--;\n          cost+=B[min]+B[i];\n          min=i;\n          break;\n        }\n      }\n    }\n  }\n  cost=quest(B,cost,n,nokori);\n  printf(\"%d\\n\",cost);\n  return 0;\n}\n   \n          \n          \n    "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define NOT_CHECK 0\n#define CHECK 1\n\ntypedef struct element_ {\n\tint idx, val;\n} element;\n\nint element_sort(void *a, void *b) {\n\treturn (*(element*)a).val - (*(element*)b).val;\n}\n\nint main(void) {\n\tint i, n, costs;\n\tint A[1005];\n\tint W[10005];\n\tint chk[1005];\n\telement sortedA[1005];\n\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%d\\n\", &A[i]);\n\t\tsortedA[i].idx = i;\n\t\tsortedA[i].val = A[i];\n\t\tW[A[i]] = i;\n\t\tchk[i] = NOT_CHECK;\n\t}\n\n\tqsort((void*)sortedA, n, sizeof(element), element_sort);\n\n\tfor(i=0;i<n;i++) {\n\t\tint p, cost, min;\n\t\tp = sortedA[i].idx;\n\t\tmin = sortedA[i].val;\n\n\t\tif(sortedA[i].idx == i) {\n\t\t\t// ソート後と同じ位置のため入れ替える必要がない\n\t\t\tchk[i] = CHECK;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// 軽い荷物を使って、正しい場所に入れ替えていく\n\t\tcost = 0;\n\t\twhile(!chk[p]) {\n\t\t\tchk[p] = CHECK;\n\t\t\tcost = cost + A[p];\n\t\t\tp = W[A[p]];\n\t\t}\n\t\tcosts += cost;\n\t}\n\n\tprintf(\"%d\\n\", costs);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n//toriaezu\n\nint cost;\n\nint sort(int *A,int n){\n  int i,j;\n  int tmp;\n  int min=1000,max=0;\n  int im,iM;\n  for(i=0;i<n;i++){\n    if(A[i]>max){\n      max=A[i];\n      iM=i;\n    }\n    else if(A[i]<min){\n      min=A[i];\n      im=i;\n    }\n  }\n    //printf(\"%d %d\\n\",im,iM); \n    if(im<0) return 1;\n    tmp=A[im];\n    A[im]=A[iM];\n    A[iM]=tmp;\n\n    cost=cost+max+min;\n    if(iM>im) return 1;\n    sort(&A[0],n);\n\n}\nint main(){\n  \n  int i,n,a;\n  int A[1000];\n  cost=0;\n  scanf(\"%d\",&n);\n\n  for(i=0;i<n;i++) scanf(\"%d\",&A[i]);\n  a=sort(&A[0],n);\n  \n  printf(\"%d\\n\",cost);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define W_MAX 1000001\n#define MAX 1001\n\nint array[MAX];\nint sorted[MAX];\n\nvoid swap(int* a, int* b){\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nint calc_cost(int n, int min_pos, int flag = 0){\n  int loop_pos = min_pos;\n  int i, sum = 0;\n  int min = array[min_pos];\n\n  do{\n    //printf(\"%d %d %d\\n\", loop_pos, sum, min);\n\n    for(i = 0; i < n; i++){\n      if(array[i] == sorted[loop_pos]){\n\tsum += array[i] + array[loop_pos];\n\tif(flag){ swap(&array[i], &array[loop_pos]); }\n\tloop_pos = i;\n\t\n\tbreak;\n      }\n    }\n  }while(min != sorted[loop_pos]);\n\n  return sum;\n}\n\nint greedy(int n){\n  int i, j;\n  int absolute_min = array[0], absolute_min_pos = -1;\n  int min = W_MAX, min_pos = -1;\n  int loop_pos = -1;\n  int direct_sum = 0;\n  int indirect_sum = 0;\n\n  for(i = 0; i < n; i++){\n    if(array[i] == absolute_min){\n      absolute_min_pos = i;\n      break;\n    }\n  }\n\n  for(i = 0; i < n; i++){\n    if(min > array[i] && sorted[i] != array[i]){\n      min = array[i];\n      min_pos = i;\n    }\n  }\n\n  if(min_pos == -1){\n    return 0;\n  }\n\n  direct_sum += calc_cost(n, min_pos);\n  \n  swap(&array[min_pos], &array[absolute_min_pos]);\n  indirect_sum += array[min_pos] + array[absolute_min_pos];\n  indirect_sum += calc_cost(n, min_pos);\n  indirect_sum += array[min_pos] + array[absolute_min_pos];\n  swap(&array[min_pos], &array[absolute_min_pos]);\n\n  //printf(\"direct_sum = %d, indirect_sum = %d\\n\", direct_sum, indirect_sum);\n\n  if(direct_sum <= indirect_sum){\n    calc_cost(n, min_pos, 1);\n    \n    return direct_sum + greedy(n);\n  }else{\n    swap(&array[min_pos], &array[absolute_min_pos]);\n    calc_cost(n, min_pos, 1);\n    swap(&array[min_pos], &array[absolute_min_pos]);\n\n    return indirect_sum + greedy(n);\n  }\n\n  return 0;\n}\n\nint main(int argc, char* argv[]){\n  int i, j, n;\n  scanf(\"%d\", &n);\n\n  for(i = 0; i < n; i++){\n    scanf(\"%d\", &array[i]);\n    sorted[i] = array[i];\n  }\n  \n  for(i = 0; i < n; i++){\n    int min = sorted[i];\n    int min_pos = i;\n    \n    for(j = i + 1; j < n; j++){\n      if(min > sorted[j]){\n\tmin = sorted[j];\n\tmin_pos = j;\n      }\n    }\n\n    if(min_pos != i){\n      swap(&sorted[i], &sorted[min_pos]);\n    }\n  }\n\n\n  printf(\"%d\\n\", greedy(n));\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid swap(int* a,int* b){\n  int tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\n\nint n,m;\nint A[1000];\nint B[1000];\nint vd[1000];\nint cnt,sum,mini;\n\nint min(int x,int y){\n  if(x<y)return x;\n  else return y;\n}\n\nint search(int x){\n  int i;\n  for(i=0;i<n;i++){\n    if(A[i]==x)return i;\n  }\n}\n\nint main(){\n  int i,j,ans,x;\n\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n\n  for(i=n-1;i>0;i--){\n    for(j=0;j<i;j++){\n      if(B[j]>B[j+1])swap(&B[j],&B[j+1]);\n    }\n  }\n\n  m=B[0];\n  ans=0;\n  for(i=0;i<n;i++)vd[i]=0;\n\n  for(i=0;i<n;i++){\n    if(A[i]==B[i])continue;    \n    x=i;\n    cnt=sum=0;\n    mini=(1<<24);\n    while(vd[x]==0){\n      vd[x]=1;\n      cnt++;\n      sum+=A[x];\n      mini=min(mini,A[x]);\n      x=search(B[x]);\n    }\n\n    if(cnt<2)continue;\n\n    ans+=min(sum+m*(cnt+1)+mini,sum+mini*(cnt-2));\n\n  }\n\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n//toriaezu\n\nint cost;\n\nint sort(int *A,int n){\n  int i,j;\n  int tmp;\n  int min=1000,max=0;\n  int im,iM;\n  for(i=1;i<n;i++){\n    if(i!=n && A[i]>max){\n      max=A[i];\n      iM=i;\n    }\n    else if(A[i]<min){\n      min=A[i];\n      im=i;\n    }\n  }\n    //printf(\"%d %d\\n\",im,iM); \n    if(iM>im) return 1;\n    tmp=A[im];\n    A[im]=A[iM];\n    A[iM]=tmp;\n\n    cost+=max+min;\n    sort(&A[0],n);\n\n}\nint main(){\n  \n  int i,n,a;\n  int A[1000];\n  cost=0;\n  scanf(\"%d\",&n);\n\n  for(i=0;i<n;i++) scanf(\"%d\",&A[i]);\n  a=sort(&A[0],n);\n  \n  printf(\"%d\\n\",cost);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX 1000\n#define MAXWEIGHTIJ 20000\n\nstruct MCS {\n\tint cost;\n\tint sorder;\n\tint order;\n};\n\n\nvoid exchange( struct MCS *pa, struct MCS *pb )\n{\n   \tstruct MCS t;\n     \n\tt=*pa;\n\t*pa=*pb;\n\t*pb=t;\n\t \n\t return;\n}\n \nint Partition( struct MCS A[], int p, int r )\n{\n    struct MCS x;\n    int i,j;\n \n    x=A[r];\n    i=p-1;\n    for( j=p; j<r; j++ ) {\n        if( A[j].cost < x.cost ) {\n            i++;\n            exchange( &A[i], &A[j] );\n         }\n    }\n    exchange( &A[i+1], &A[r] );\n\n    return i+1;\n}\nvoid QuickSort( struct MCS A[], int p, int r )\n{\n    int q;\n     \n    if( p < r ) {\n        q=Partition( A, p, r );\n        QuickSort( A, p, q-1 );\n        QuickSort( A, q+1, r );\n    }\n    return;\n}\n\nint tryChange( int n, struct MCS W[] )\n{\n\tint cost,miniCost;\n\tint i;\n\tint maxi,mini;\n\tint max;\n\tint min,mostmin;\n\tint minorder,maxorder,mostminorder;\n\tint limitN;\n\t\n\tmaxi=mini=0;\n\tminiCost=cost=MAXWEIGHTIJ;\n\tlimitN=n;\t\n\tmaxorder=max=-1;\n\tmostmin=min=mostminorder=minorder=n;\n    while( 1 ) {\n\t\tfor( i=0; i<limitN; i++ ) {\n\t\t\tif( i != W[i].order ) {\n\t\t\t\tif( max < W[i].sorder ) {\n    \t\t\t\tmax=W[i].sorder;\n    \t\t\t\tmaxorder=i;\n    \t\t\t}\n\t\t\t\tif( W[i].sorder < min ) {\n\t\t\t\t\tmin=W[i].sorder;\n\t\t\t\t\tminorder=i;\t\n\t\t\t\t}\n    \t\t\t\n\t\t\t}\n\t\t\tif( W[i].sorder < mostmin ) {\n\t\t\t\tmostmin=W[i].sorder;\n\t\t\t\tmostminorder=i;\t\n\t\t\t}\n\t\t}\n\t\tif( -1 == maxorder ) { break; }\n\t\t\n\t\tif( W[maxorder].order != minorder ) {\n\t\t\tif( 2*(W[minorder].cost+W[mostminorder].cost)  < (W[maxorder].cost+W[minorder].cost)  ) {\n\t\t\t\tminorder=mostminorder;\n\t\t\t}\n\t\t}\n   \t\tif( W[maxorder].order == minorder ) { \n\t\t\tcost=( W[minorder].cost+W[maxorder].cost );\n\t\t\tminiCost=cost;\n\t\t\tmini=minorder;\n\t\t\tmaxi=maxorder;\n\t\t\tbreak;\n\t\t}\n\t\tlimitN--;\n\t\tmax=-1;\n\t\tif( -1 == limitN ) {\n\t\t\tif( MAXWEIGHTIJ == miniCost ) {\n\t\t\t\tcost=( W[minorder].cost+W[maxorder].cost );\n\t\t\t\tminiCost=cost;\n\t\t\t\tmini=minorder;\n\t\t\t\tmaxi=maxorder;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n    }\n\n\n\n    if( MAXWEIGHTIJ != miniCost ) {\n\t\texchange( &W[mini], &W[maxi] );\n\t} else {\n    \n    \tminiCost=0;\n    }\n\n\treturn miniCost;\n}\n\nint main( void ) \n{   \n    int n,i;\n    struct MCS W[MAX+1];\n    int cost;\n        \n    scanf( \"%d\", &n );\n    for( i=0; i<n; i++ ) {\n        scanf( \"%d\", &W[i].cost );\n        W[i].order=i;\n    }\n\n    QuickSort( W, 0, n-1 ); \n     for( i=0; i<n; i++ ) {\n        W[i].sorder=i;\n    }\n   cost=i=0;\n    while( (i = tryChange( n, W ) ) ) {\n   \t\tcost+=i;\n    }\n   \tprintf( \"%d\\n\", cost );\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define N 1024\n\nint cost = 0, W[N] = {0}, C[N] = {0};\n\nvoid swap(int *x, int *y) {\n  int tmp;\n\n  tmp = *x;\n  *x = *y;\n  *y = tmp;\n}\n\nint partition(int p, int r) {\n  int i, j, x;\n\n  x = W[r];\n  i = p - 1;\n  for (j = p; j < r; j++) {\n    if (W[j] <= x) {\n      i++;\n      swap(&W[i], &W[j]);\n    }\n  }\n  swap(&W[i + 1], &W[r]);\n  return i + 1;\n}\n\nvoid quickSort(int p, int r) {\n  int q;\n  \n  if (p < r) {\n    q = partition(p, r);\n    quickSort(p, q - 1);\n    quickSort(q + 1, r);\n  }\n}\n\nint main(void) {\n  int i, j, n;\n  const char *sp;\n\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++)\n    scanf(\"%d\", &W[i]);\n  memcpy(C, W, sizeof(W));\n\n  quickSort(0, n - 1);\n  for (i = n - 1; 0 < i; i--) {\n    for (j = 0; j < n; j++) {\n      if (W[i] == C[j] && i != j) {\n\tcost += C[i];\n\tcost += C[j];\n\t//\tprintf(\"swap:%d,%d\\n\", C[i], C[j]);\n\tswap(&C[i], &C[j]);\n\tbreak;\n      }\n    }\n  }\n\n  /* for (i = 0, sp = \"\"; i < n; i++) { */\n  /*   printf(\"%c%d\", *sp, W[i]); */\n  /*   sp = \" \"; */\n  /* } */\n  /* puts(\"\"); */\n  printf(\"%d\\n\", cost);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define NOT_CHECK 0\n#define CHECK 1\n\ntypedef struct element_ {\n\tint idx, val;\n} element;\n\nint element_sort(void *a, void *b) {\n\treturn (*(element*)a).val - (*(element*)b).val;\n}\n\nint main(void) {\n\tint i, n, costs, m;\n\tint A[1005];\n\tint W[10005];\n\tint chk[1005];\n\telement sortedA[1005];\n\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%d\\n\", &A[i]);\n\t\tsortedA[i].idx = i;\n\t\tsortedA[i].val = A[i];\n\t\tW[A[i]] = i;\n\t\tchk[i] = NOT_CHECK;\n\t}\n\n\tqsort((void*)sortedA, n, sizeof(element), element_sort);\n\n\tm = sortedA[0].val;\n\tfor(i=0;i<n;i++) {\n\t\tint p, cost, lt, cnt, t;\n\t\tp = i;\n\n\t\tt = 0;\n\t\tlt = 10005;\n\t\twhile(chk[p]==NOT_CHECK) {\n\t\t\tchk[p] = CHECK;\n\t\t\tt += A[p];\n\t\t\tcnt++;\n\t\t\tif(lt > A[p]) lt = A[p];\n\t\t\tp = W[sortedA[p].val];\n\t\t}\n\t\tif(cnt<2) continue;\t// 入れ替えが発生し始めるのはcntが2以上になってから\n\t\t\n\t\t// 入れ替え中に見つかった最小値を入れ替えに使った方がコストが低いか\n\t\t// 回り道して最小の値を使って入れ替えに使った方がコストが低いか\n\t\tcost = t+m*(cnt+1)+lt;\t// lt -> m ・・ m -> A[k] ・・ m -> lt\n\t\tif(cost>t+lt*(cnt-2)) cost = t+lt*(cnt-2);\n\t\tcosts += t;\n\t}\n\n\tprintf(\"%d\\n\", costs);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstatic const int MAX=1000;\nstatic const int VMAX=10000;\n\nint n, A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve() {\n  int ans=0;\n  bool V[MAX];\n  for (int i=0; i<n; i++) {\n    B[i]=A[i];\n    V[i]=false;\n  }\n  sort(B,B+n);\n  for (int i=0; i<n; i++) {\n    T[B[i]]=i;\n  }\n  for (int i=0; i<n; i++) {\n    if (V[i]) {\n      continue;\n    }\n    int cur=i;\n    int S=0;\n    int m=VMAX;\n    int an=0;\n    while (true) {\n      V[cur]=true;\n      an++;\n      int v=A[cur];\n      m=min(m,v);\n      S+=v;\n      cur=T[v];\n      if (V[cur]) {\n        break;\n      }\n    }\n    ans+=min(S+(an-2)*m,m+S+(an+1)*S);\n  }\n  return ans;\n}\nint main() {\n  cin>>n;\n  s=VMAX;\n  for (int i=0; i<n; i++) {\n    cin>>A[i];\n    s=min(s,A[i]);\n  }\n  int ans=solve();\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdbool.h>\n#include<math.h>\n#define MAX 1000\n#define VMAX 10000\nint n,A[MAX],s;\nint B[MAX], T[VMAX+1];\n \nvoid swap(int *a,int *b) {\n  int temp;\n  temp = *a;\n  *a = *b;\n  *b = temp;\n}\nvoid qsort(int X[], int left, int right){\n  int i,j;\n  int pivot;\n  i=left;j=right;\n  pivot = X[(left+right)/2];\n \n  while(1) {\n    while(X[i]<pivot)i++;\n    while(pivot<X[j])j--;\n    if(i>=j) break;\n \n    swap(&X[i],&X[j]);\n    i++;  j--;\n  }\n  if(left < i-1) qsort(X,left,i-1);\n  if(j+1<right) qsort(X,j+1,right);\n}\nint solve() {\n  int i;\n  int ans = 0;\n \n  bool V[MAX];\n  for(i=0;i<n;i++){\n    B[i] = A[i];\n    V[i]=false;\n  }\n  qsort(B,0,n-1);\n  for(i=0;i<n;i++) T[B[i]] = i;\n  for(i=0;i<n;i++) {\n    if(V[i]) continue;\n    int cur=i;\n    int S=0;\n    int m=VMAX;\n    int an=0;\n    while(1) {\n      V[cur] = true;\n      an++;\n      int v = A[cur];\n      m = fmin(m,v);\n      S+=v;\n      cur=T[v];\n      if(V[cur])break;\n    }\n    ans+=fmin(S+(an - 2) * m , m+S+(an+1)*s);\n \n  }\n  return ans;\n}\nint main(){\n  int i;\n  scanf(\"%d\",&n);\n  s=VMAX;\n  for(i=0;i<n;i++) {\n    scanf(\"%d\",&A[i]);\n    s=fmin(s , A[i]);\n  }\n  int ans = solve();\n  printf(\"%d\\n\", ans);\n \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid Sort(int*,int,int);\nint Cost_Sort(int*,int,int);\n\nint sum=0;\n\nmain(){\n  int i,n,*A;\n\n  scanf(\"%d\",&n);\n\n  A=(int *)malloc(sizeof(int)*n);\n\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n  }\n\n  Sort(A,0,n);\n\n  printf(\"%d\\n\",sum);\n\n  return 0;\n}\n\nvoid Sort(int *A,int i,int n){\n  int p;\n  \n  if(i<n){\n    p=Cost_Sort(A,i,n);\n    Sort(A,p,n);\n  }\n}\n\nint Cost_Sort(int *A,int i,int n){\n  int k,j,tmp,min=A[i];\n\n  for(j=i+1;j<n;j++){\n    if(min>A[j]){\n      min=A[j];\n      k=j;\n    }\n  }\n\n  if(A[i]>min){\n    sum+=A[i]+A[k];\n    tmp=A[i];\n    A[i]=A[k];\n    A[k]=tmp;\n  }\n  return i+1;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX 1000\n\nint solve(int*, int);\nint check(int*,int);\n\nint main(){\n  int n, i, arr[MAX];\n\n  scanf(\"%d\" ,&n);\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\" ,arr + i);\n    arr[i]--;\n  }\n  printf(\"%d\\n\" ,solve(arr, n));\n\n  return 0;\n}\n\nint check(int arr[], int n){\n  int i;\n\n  for(i = 0 ; i < n ; i++){\n    if(arr[i] != i){\n      return 0;\n    }\n  }\n  return 1;\n}\n\nint solve(int arr[], int n){\n  int i, j, res = 0, tmp;\n\n  for(i = 0 ; i < n-1 ; i++){\n    if(arr[i] != i){\n      for(j = i+1 ; j < n ; j++){\n        if(arr[j] != j && arr[i] == j && arr[j] == i){\n          res += arr[i] + arr[j] + 2;     \n          tmp = arr[i];\n          arr[i] = arr[j];\n          arr[j] = tmp;\n        }\n      }\n    }\n  }\n\n  for(i = 0 ; i < n-1 ; i++){\n    if(arr[i] != i){\n      for(j = i+1 ; j < n ; j++){\n        if(arr[i] == j){\n          res += arr[i] + arr[j] + 2;     \n          tmp = arr[i];\n          arr[i] = arr[j];\n          arr[j] = tmp;\n        }\n      }\n    }\n  }\n\n  if(check(arr, n)){\n    return res;\n  }else{\n    return res += solve(arr, n);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define M  1000\n#define M_1 10000\n\n\nint n, A[M], s;\nint b[M], T[M_1 + 1];\n\n\nint partition(int A[], int l, int r){\n  int i, j;\n  int t, x;\n  x = A[r];\n  i = l - 1;\n\n  for( j = l ; j < r ; j++ ){\n    if(A[j] <= x){\n      i++;\n      t = A[i];\n      A[i] = A[j];\n      A[j] = t;\n    }\n  }\n\n  t = A[i + 1];\n  A[i + 1] = A[r];\n  A[r] = t;\n\n  return i + 1;\n}\nvoid quickSort(int A[], int l, int r){\n  int q;\n  if(l < r){\n    q = partition(A, l, r);\n    quickSort(A, l, q - 1);\n    quickSort(A, q + 1, r);\n  }\n}\n\n\nint solve(){\n  int i, cur, S, m, an, v,   ans = 0 ;\n\n  int V[M];\n  for(i = 0 ; i < n ; i++){\n    b[i] = A[i];\n    V[i] = 0;\n  }\n\n  quickSort(b, 0, n - 1);\n\n  for(i = 0 ; i < n ; i++) T[b[i]] = i;\n  for(i = 0 ; i < n ; i++){\n    if(V[i]) continue;\n    cur = i;\n    S = 0;\n    m = M_1;\n    an = 0;\n    while(1){\n      V[cur] = 1;\n      an++;\n      v = A[cur];\n\n      if(v < m) m = v;\n\n      S += v;\n      cur = T[v];\n      if(V[cur]) break;\n    }\n    if(S + (an -2) * m < m + S + (an + 1) * s) ans += S + (an -2) * m;\n    else ans +=  m + S + (an + 1) * s;\n  }\n  return ans;\n}\n\n\n\nint main(){\n  int i;\n\n  scanf(\"%d\", &n);\n  s = M_1;\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\", &A[i]);\n    if(A[i] < s) s = A[i];\n  }\n\n  int ans = solve();\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX_N  1000\n\nstruct rist\n{\n  int n;\n  int p;\n} typedef rist;\n\nvoid QuickSort(int, int);\nint Partition(int, int);\nint MinimumCost(int);\n\nrist A[MAX_N];\n\nint main()\n{\n\tint i;\n\tint n;\n\tint cost;\n\t\n\tscanf(\"%d\", &n);\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &A[i].n);\n\t\tA[i].p = i;\n\t}\n\t\n\tQuickSort(0, n - 1);\n\tcost = MinimumCost(n);\n\t\n\tprintf(\"%d\", cost);\n\t\n\treturn 0;\n}\n\nvoid QuickSort(int p, int r)\n{\n  int q;\n\n  if(p < r)\n    {\n      q = Partition(p, r);\n      QuickSort(p, q - 1);\n      QuickSort(q + 1, r);\n    }\n}\n\nint Partition(int p, int r)\n{\n\tint i, j;\n\trist tmp;\n\n\ti = p - 1;\n\tfor(j = p; j < r; j++)\n    {\n    \tif(A[j].n <= A[r].n)\n\t\t{\n\t \t\t i = i + 1;\n\t \t\t tmp = A[i];\n\t  \t\tA[i] = A[j];\n\t  \t\tA[j] = tmp;\n\t\t}\n    }\n\ttmp = A[i + 1];\n  \tA[i + 1] = A[r];\n  \tA[r] = tmp;\n  \n  \treturn i + 1;\n}\n\nint MinimumCost(int n)\n{\n\tint i;\n\tint tmp;\n\tint cost;\n\t\n\tfor(i = n - 1; i >= 0; i--)\n\t{\n\t\tif(A[i].p != i)\n\t\t{\n\t\t\tcost += A[i].n + A[A[i].p].n;\n\n\t\t\ttmp = A[A[i].p].p;\n\t\t\tA[A[i].p].p = A[i].p;\n\t\t\tA[i].p = tmp;\n\t\t}\n\t}\n\treturn cost;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdbool.h>\n\n#define MAX 1000\n#define VMAX 10000\n\nint j,n,s;\nint A[MAX];\nint B[MAX];\nint T[VMAX+1];\n\nvoid Sort(int C[]){\n\tint flag=1;\n\tint temp;\n\twhile(flag==1){\n\t\tflag=0;\n\t\tfor(j=n-1; j>=1;j--){\n\t\t\tif(C[j]<C[j-1]){\n\t\t\t\ttemp=C[j-1];\n\t\t\t\tC[j-1]=C[j];\n\t\t\t\tC[j]=temp;\n\t\t\t\tflag=1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint min(int a, int b){\n\tif(a<b){return a;}\n\telse{return b;}\n}\n\nint solve(){\n\tint ans=0;\n\tint i;\n\tbool V[MAX];\n\t\n\tfor(i=0;i<n;i++){\n\t\tB[i]=A[i];\n\t\tV[i]=false;\n\t}\n\tSort(B);\n\tfor(i=0;i<n;i++){\n\t\tT[B[i]]=i;\n\t}\n\t\n\tfor(i=0;i<n;i++){\n\t\tif(V[i])continue;\n\t\tint cur=i;\n\t\tint S=0;\n\t\tint m=VMAX;\n\t\tint an=0;\n\t\twhile(1){\n\t\t\tV[cur]=1;\n\t\t\tan++;\n\t\t\tint v=A[cur];\n\t\t\tm=min(m,v);\n\t\t\tS+=v;\n\t\t\tcur=T[v];\n\t\t\tif(V[cur]){break;}\n\t\t}\n\t\tans+=min(S+(an-2)*m,m+S+(an+1)*s);\n\t}\n\t\n\treturn ans;\n}\n\nint main(void){\n\tint i,ans;\n\tscanf(\"%d\",&n);\n\t\n\ts=VMAX;\n\t\n\tfor(i=0; i<n; i++){\n\t\tscanf(\"%d\",&A[i]);\n\t\ts=min(s,A[i]);\n\t}\n\t\n\tans=solve();\n\t\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n\n\n\nint n,cost;\nint A[1001],B[1001];\nint L[501],R[502];\n\n\nvoid merge(int left,int mid,int right){\n  int i,j,n1=mid-left,n2=right-mid;\n  for(i=0;i<n1;i++) L[i]=A[left+i];\n  L[n1]=INT_MAX;\n  for(i=0;i<n2;i++) R[i]=A[mid+i];\n  R[n2]=INT_MAX;\n  int l=0,r=0;\n  for(i=left;i<right;i++){\n    if(L[l]<=R[r]){\n      A[i]=L[l];\n      l++;\n    }\n    else{\n      A[i]=R[r];\n      r++;\n    }\n  }\n}\n\n\nvoid m_sort(int left,int right){\n  int mid;\n  if( left+1 >= right) return;\n  mid=(left+right)/2;\n  m_sort(left,mid);\n  m_sort(mid,right);\n  merge(left,mid,right);\n}\n\n\nvoid swap(int a,int b,int *C){\n  int swap;\n  swap=C[a];\n  C[a]=C[b];\n  C[b]=swap;\n}\n\n\n/*??£????????´??????????????°???????????§????°??????????????????¢?????????????????????*/\nint min_search(int *C){\n  int res=n,i;\n  C[n]=INT_MAX;\n  for(i=0;i<n;i++){\n    if(A[i]!=C[i]){\n      if(C[res] >C[i]) res =i;\n    }\n  }\n  return res;\n}\n\n\n\n\n\n\nint quest(int *C,int num,int jud){\n  int D[1001],E[1001],i,x,ans,ans2,judd;\n  if(jud==n) x=min_search(C);\n  else x=jud;\n  if(x==n) return num;\n  for(i=0;i<n;i++){\n    D[i]=C[i];\n    E[i]=C[i];\n  }\n  i=0;\n  while(1){\n    if(D[i]==A[x]){\n      swap(i,x,D);\n      judd=i;\n      if(D[i]==A[i]) judd=n;\n      ans=quest(D,num+D[i]+D[x],judd);\n      break;\n    }\n    i++;  \n  }\n  if(E[x]!=A[0]){\n    swap(0,x,E);\n    ans2=quest(E,num+E[0]+E[x],x);\n    if(ans > ans2) ans=ans2;\n  }\n  return ans;\n}\n  \n \n  \n\nint main(){\n  scanf(\"%d\",&n);\n  int i,j,min=n;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n  m_sort(0,n);\n  cost=0;\n  for(i=0;i<n;i++){\n    for(j=i+1;j<n;j++){\n      if(B[i]==A[j]){\n        if(B[j]==A[i]){\n          swap(i,j,B);\n          cost+=B[i]+B[j];\n        }\n        break;\n      }\n    } \n  }\n  while(1){\n    if(min==n) min=min_search(B);\n    if(B[min]!=A[0]){\n      break;\n    }\n    else{\n      if(min==n) break;\n      for(i=0;i<n;i++){\n        if(A[min]==B[i]){\n          if(min==i){\n            min=n;\n            break;\n          }\n          swap(min,i,B);\n          cost+=B[min]+B[i];\n          min=i;\n          break;\n        }\n      }\n    }\n  }\n  cost=quest(B,cost,n);\n  printf(\"%d\\n\",cost);\n  return 0;\n}\n   \n          \n          \n    "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\n//============================================================================\n#define pred(x) ((x)-1)\n#define succ(x) ((x)+1)\n//============================================================================\ntypedef unsigned char  INT8U;\ntypedef unsigned short INT16U;\ntypedef   signed short INT16S;\ntypedef long INT32;\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nINT16U *C;\n//----------------------------------------------------------------------------\nvoid CountingSort(INT16U *A, INT16U *B,  INT16U n, INT16U k)\n{\n    long i;\n\n    for (i = 0; i<n; i++)\n        C[A[i]]++;\n    for (i = 1; i<=k; i++)\n        C[i] += C[i-1];\n    // C holds position of A\n    // C[A[val]] = pred val position\n\n    /*for (i = 1; i<=k; i++)\n        printf(\"%d \", C[i]);\n    printf(\"\\n\");*/\n    /*printf(\"B[C[A[i]]-1] = A[i];\\n\");\n    for (i=n-1; 0<=i; i--){\n        //B[C[A[i]]-1] = A[i];\n        printf(\"B[%d]=%d C[%d]=%d A[%d]=%d\\n\", C[A[i]]-1, A[i],\n                            A[i], C[A[i]], i, A[i]);\n        //C[A[i]]--;\n    }*/\n}\n//----------------------------------------------------------------------------\nINT16S getminptr(INT16U *A, INT16U N)\n{\n    INT16U i,min; INT16S ptr;\n\n    for (i=0, ptr=-1, min=32767; i<N; i++){\n        if (A[i]<min && pred(C[A[i]])!=i){\n            min=A[i];\n            ptr=i;\n        }\n    }\n    return ptr;\n}\n//----------------------------------------------------------------------------\nlong SumValue;\nvoid exchange(INT16U *x, INT16U *y)\n{\n    INT16U z;\n\n    z=*x, *x=*y, *y=z;\n    SumValue+=*x;\n    SumValue+=*y;\n    //printf(\"ex: %d<-->%d, sum:%ld\\n\", *y, *x, sum);\n}\n//----------------------------------------------------------------------------\nvoid prnary(INT16U *A, INT16U N)\n{\n    int j;\n\n    for (j=0; j<N; j++)\n        printf(\"%2d \", A[j]);\n    printf(\" sum:%ld\\n\", SumValue);\n}\n//----------------------------------------------------------------------------\nshort linklen(INT16U *A, INT16U val)\n{\n    int idx,n;\n\n    for (n=0, idx=val; ; n++){\n        idx=A[pred(C[idx])];\n        if (idx==val)\n            return n;\n    }\n}\n//----------------------------------------------------------------------------\nshort bgnlink(INT16U *A, INT16U val)\n{\n    int sum,idx,start;\n\n    for (start=idx=val; ; ){\n        idx=A[pred(C[idx])];\n        if (idx<start)\n            start=idx;\n        if (idx==val)\n            return start;\n    }\n}\n//----------------------------------------------------------------------------\nshort revcost(INT16U *A, INT16U val)\n{\n    int sum,idx,start;\n\n    val=bgnlink(A, val);\n    for (sum=0, idx=val; ; ){\n        idx=A[pred(C[idx])];\n        if (idx==val)\n            return sum;\n        sum+=(idx+val);\n    }\n}\n//----------------------------------------------------------------------------\nshort exccost(INT16U *A, INT16U val)\n{\n    int sum,idx,porn;\n\n    for (porn=A[0],sum=porn+val, idx=val; ; ){\n        idx=A[pred(C[idx])];\n        sum+=(idx+porn);\n        if (idx==val)\n            return sum;\n    }\n}\n//----------------------------------------------------------------------------\nvoid duplication(INT16U *A, INT16U N)\n{\n    int i,j,k,n,a,ary[3];\n\n#ifdef DESKTOP\n    prnary(A, N);\n#endif\n    for (i=SumValue=0; i<pred(N); i++){\n        n=linklen(A, A[i]);\n        if (n==1){\n            j=pred(C[A[i]]);\n            exchange(&A[i], &A[j]);\n            //printf(\"ex:(%d<->%d), \", A[i], A[j]);\n        }\n#ifdef DESKTOP\n    }\n    printf(\"\\n\");\n#else\n    }\n#endif\n}\n//----------------------------------------------------------------------------\nlong mincostsort(INT16U *A, INT16U N)\n{\n    int ptr,i,j,min,ordptr,order[100];\n\n    duplication(A, N);\n    for (i=0,j=32000; i<N; i++)\n        if (A[i]<j)\n            j=A[i],min=i;\n    for (ordptr=0; 0<=(ptr=getminptr(A, N));){\n#ifdef DESKTOP\n        printf(\"[%d]\\n\", A[ptr]);\n#endif\n        order[ordptr++]=A[ptr];\n        if (exccost(A, A[ptr])<revcost(A, A[ptr])){\n            exchange(&A[min], &A[ptr]);\n            min=ptr;\n        }\n        while (pred(C[A[ptr]])!=ptr){\n            for (i=0; i<N; i++)\n                if (C[A[i]]==succ(ptr)){\n                    order[ordptr++]=A[i];\n                    if (ptr==min) min=i;\n                    exchange(&A[ptr], &A[i]);\n                    ptr=i;\n#ifdef DESKTOP\n                    //prnary(A, N);\n#endif\n                    break;\n                }\n        }\n    }\n#ifdef DESKTOP\n    for (i=0; i<ordptr; i++){\n        if (i) printf(\"->\");\n            printf(\"%d\", order[i]);\n    }\n    printf(\"\\n\");\n#endif\n    return SumValue;\n}\n//----------------------------------------------------------------------------\n/*\n*                                         *     *\n0 62 33 29 72 52 43 19 5  93 51 32  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51  5  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51 47  8 11 56  5 66 69 30 17 68  5\n0  5 33 29 72 52 43 19 32 93 51 47  8 11 56 62 66 69 30 17 68  0\n0  5 33 29 72 52 43 19 32 93  8 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 29 72 52  8 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33  8 72 52 29 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 11 72 52 29 19 32 93 43 47 51  8 56 62 66 69 30 17 68  8\n0  5 33 11 72  8 29 19 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29  8 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 69  8 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66  8 69 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 68 69 17  8  8\n0  5 33 11 72 19 29 30 32  8 43 47 51 52 56 62 66 68 69 17 93  8\n0  5  8 11 72 19 29 30 32 33 43 47 51 52 56 62 66 68 69 72 93  0\n0  5  8 11 17 19 29 30 32 33 43 47 51 52 56 62 66 68 69 17 93  0\n\n 1 80 50 70 40 20\n20 80 50 70 40  1\n20  1 50 70 40 80\n 1 20 50 70 40 80 21        20 40 50 70  1 80   41\n40 20 50 70  1 80 41        20 40 50  1 70 80   71\n40 20 50  1 70 80 71        20 40  1 50 70 80   51\n40 20  1 50 70 80 51        20  1 40 50 70 80   41\n 1 20 40 50 70 80 41         1 20 40 50 70 80   21\n\n\n5\n1 5 3 4 2\n7\n\n4\n4 3 2 1\n10\n*/\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nvoid input(FILE *file)\n{\n    long i,n,max,ave; INT16U *A, *B; char buffer[20];\n\n    fgets(buffer, sizeof(buffer)-1, file);\n    sscanf(buffer, \"%ld\", &n);\n    A = malloc(succ(n)*sizeof(INT16U));\n    B = malloc(succ(n)*sizeof(INT16U));\n    for (i=ave=max=0; i<n; i++){\n        fscanf(file, \"%hd\",  &A[i]);\n        if (max<A[i])\n            max=A[i];\n        ave+=A[i];\n    }\n    ave/=n;\n    C = malloc(succ(max)*sizeof(INT16U));\n    memset(C, 0, sizeof(INT16U)*succ(max));\n    CountingSort(A, B, n, max);\n    printf(\"%ld\\n\", mincostsort(A, n));\n#ifdef DESKTOP\n    for (i=0; i<n; i++){\n        if (i) printf(\" \");\n        printf(\"%hd\", A[i]);\n    }\n    printf(\"\\n\");\n#endif\n    free(A);\n    free(B);\n    free(C);\n}\n//============================================================================\n#ifndef DESKTOP\nint main()\n{\n    input(stdin);\n    return 0;\n}\n#endif"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX 1000\n#define VMAX 10000\n\nint A[MAX] ,n,s;\nint B[MAX] , T[VMAX+1];\n\nvoid sort(int a[]){\n\tint x=1;\n\tint copy;\n\tint j;\n\t\n\twhile( x== 1 ){\n\t\tx = 0;\n\t\t\n\t\tfor( j = n - 1; j >= 1; j-- ){\n\t\t\tif( a[j] < a[ j - 1 ] ){\n\t\t\t\tcopy = a[j];\n\t\t\t\ta[j] = a[j - 1];\n\t\t\t\ta[j - 1] = copy;\n\t\t\t\tx = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\nint min( int a , int b ){\n\tif( a < b ){ \n\t\treturn a; \n\t}else{ \n\t\treturn b; \n\t}\n}\n\nint solve(){\n\tint ans = 0;\n\tint V[MAX];\n\t\n\tfor( int i = 0; i < n; i++ ){\n\t\tB[i] = A[i];\n\t\tV[i] = 0;\n\t}\n\t\n\tsort(B);\n\t\n\tfor( int i = 0; i < n; i++ ) T[B[i]] = i;\n\tfor( int i = 0; i < n; i++ ){\n\t\tif( V[i] ) continue;\n\t\t\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\t\n\t\twhile(1){\n\t\t\tV[cur] = 1;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m,v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif( V[cur] ){ break; }\n\t\t}\n\t\tans += min( S+(an-2) * m , m + S + (an + 1 ) * s );\n\t}\n\t\n\treturn ans;\n}\n\nint main( void ){\n\tint ans,i;\n\tscanf(\"%d\",&n );\n\t\n\ts = VMAX;\n\t\n\tfor(i=0; i<n;i++ ){\n\t\tscanf( \"%d\", &A[i] );\n\t\ts = min(s,A[i]);\n\t}\n\t\n\tans = solve();\n\t\n\tprintf( \"%d\\n\", ans );\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "\t//\t????°???????????????????\n#include <stdio.h>\n#include <string.h>\n\n#define DEF_ELEM_MAX 1000\n\n//  ????°?????????????\n#ifndef min\n#define min(a, b)            (((a) < (b)) ? (a) : (b))\n#endif\n\nint A[DEF_ELEM_MAX];\nint B[DEF_ELEM_MAX];\nint N;\nint ans;\n/////////////////////////////////////////////////////////////////////////////////\n//\n/////////////////////////////////////////////////////////////////////////////////\nvoid swap(int *x, int *y)\n{\n\tint tmp = *x;\n\t*x = *y;\n\t*y = tmp;\n\treturn;\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n//\n/////////////////////////////////////////////////////////////////////////////////\nint partition(int *A, int p, int r)\n{\n\tint j;\n\tint x = A[r];\n\tint i = p-1;\n\n\tfor ( j = p ; j < r ; j++ ) {\n\t\tif ( A[j] <= x ) {\n\t\t\ti++;\n\t\t\tswap(&A[i], &A[j]);\n\t\t}\n\t}\n\tswap(&A[i+1], &A[r]);\n\treturn i+1;\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n//\n/////////////////////////////////////////////////////////////////////////////////\nvoid quickSort(int *A, int p, int r)\n{\n\tint q;\n\tif ( p < r ) {\n\t\tq = partition(A, p, r);\n\t\tquickSort(A, p, q-1);\n\t\tquickSort(A, q+1, r);\n\t}\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n//\n/////////////////////////////////////////////////////////////////////////////////\nvoid solve( int *A, int *B, int n )\n{\n\tint i;\n\n\tquickSort(B, 0, n-1);\n\n\tfor ( i = 0 ; i < n ; i++ ) {\n\t\tif (B[i] != A[i]) {;\n\t\t\tans += A[i];\n\t\t}\n\t}\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n//\n/////////////////////////////////////////////////////////////////////////////////\nint main(void)\n{\n\tint i;\n//\n\tscanf(\"%d\", &N);\n\tfor ( i = 0 ; i < N ; i++ ) {\n\t\tscanf(\"%d\", &A[i] );\n\t\tB[i] = A[i];\n\t}\n\n\tsolve(A, B, N);\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define W_MAX 1000001\n#define MAX 1001\n\nint array[MAX];\nint sorted[MAX];\n\nvoid swap(int* a, int* b){\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nint calc_cost(int n, int min_pos, int flag){\n  int loop_pos = min_pos;\n  int i, sum = 0;\n  int min = array[min_pos];\n\n  do{\n    for(i = 0; i < n; i++){\n      if(array[i] == sorted[loop_pos]){\n\tsum += array[i] + min;\n\n\tif(flag){ swap(&array[i], &array[loop_pos]); }\n\n\tloop_pos = i;\n\t\n\tbreak;\n      }\n    }\n    \n    \n    if(0){\n      for(i = 0; i < n; i++){\n\tprintf(\"%s%d\", i == 0 ? \"\" : \" \", array[i]);\n      }\n      printf(\" : %d\\n\", sum);\n    }else{\n      //printf(\"%d\\n\", sum);\n    }\n    \n  }while(min != sorted[loop_pos]);\n\n  return sum;\n}\n\nint greedy(int n){\n  int i, j;\n  int absolute_min = sorted[0], absolute_min_pos = -1;\n  int min = W_MAX, min_pos = -1;\n  int loop_pos = -1;\n  int direct_sum = 0;\n  int indirect_sum = 0;\n\n  for(i = 0; i < n; i++){\n    if(array[i] == absolute_min){\n      absolute_min_pos = i;\n      break;\n    }\n  }\n\n  for(i = 0; i < n; i++){\n    if(min > array[i] && sorted[i] != array[i]){\n      min = array[i];\n      min_pos = i;\n    }\n  }\n\n  if(min_pos == -1){\n    return 0;\n  }\n\n  //printf(\"absolute_min = %d(%d)\\n\", absolute_min, absolute_min_pos);\n\n  direct_sum += calc_cost(n, min_pos, 0);\n  \n  swap(&array[min_pos], &array[absolute_min_pos]);\n  indirect_sum += array[min_pos] + array[absolute_min_pos];\n  indirect_sum += calc_cost(n, min_pos, 0);\n  swap(&array[min_pos], &array[absolute_min_pos]);\n\n  //printf(\"min = %d, direct_sum = %d, indirect_sum = %d\\n\", min, direct_sum, indirect_sum);\n\n  if(direct_sum <= indirect_sum){\n    calc_cost(n, min_pos, 1);\n    \n    return direct_sum + greedy(n);\n  }else{\n    swap(&array[min_pos], &array[absolute_min_pos]);\n    //printf(\"%d\\n\", \n    calc_cost(n, min_pos, 1);\n\n    return indirect_sum + greedy(n);\n  }\n\n  return 0;\n}\n\nint main(int argc, char* argv[]){\n  int i, j, n;\n  scanf(\"%d\", &n);\n\n  for(i = 0; i < n; i++){\n    scanf(\"%d\", &array[i]);\n    sorted[i] = array[i];\n  }\n  \n  for(i = 0; i < n; i++){\n    int min = sorted[i];\n    int min_pos = i;\n    \n    for(j = i + 1; j < n; j++){\n      if(min > sorted[j]){\n\tmin = sorted[j];\n\tmin_pos = j;\n      }\n    }\n\n    if(min_pos != i){\n      swap(&sorted[i], &sorted[min_pos]);\n    }\n  }\n\n\n  printf(\"%d\\n\", greedy(n));\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX 1000\n#define MAXWEIGHT 10000\n#define MAXWEIGHT2 20000\n\nstruct MCS {\n\tint cost;\n\tint order;\n};\n\nvoid exchange( struct MCS *pa, struct MCS *pb )\n{\n   \tstruct MCS t;\n     \n\tt=*pa;\n\t*pa=*pb;\n\t*pb=t;\n\t \n\t return;\n}\n \nint Partition( struct MCS A[], int p, int r )\n{\n    struct MCS x;\n    int i,j;\n \n    x=A[r];\n    i=p-1;\n    for( j=p; j<r; j++ ) {\n        if( A[j].cost < x.cost ) {\n            i++;\n            exchange( &A[i], &A[j] );\n         }\n    }\n    exchange( &A[i+1], &A[r] );\n\n    return i+1;\n}\nvoid QuickSort( struct MCS A[], int p, int r )\n{\n    int q;\n     \n    if( p < r ) {\n        q=Partition( A, p, r );\n        QuickSort( A, p, q-1 );\n        QuickSort( A, q+1, r );\n    }\n    return;\n}\nint tryChange( int n, struct MCS W[], struct MCS B[] )\n{\n\tint cnt,min;\n\tint i,j,t;\n\tint prei,prej;\n\t\n\tprei=prej=0;\n\tmin=cnt=MAXWEIGHT2;\n    for( i=0; i<n; i++ ) {\n    \tif( i != W[i].order ) {\n    \t\tfor( j=0; j<n; j++ ) {\n    \t\t\tif( W[j].order != B[j].order && W[i].order == j   ) {\n    \t\t\t\tcnt=B[i].cost+B[ W[i].order ].cost;\n\t\t    \t\tif( cnt < min ) {\n\t\t    \t\t\tmin=cnt;\n\t\t    \t\t\tprei=i;\n\t\t    \t\t\tprej=j;\n\t\t    \t\t}\n    \t\t\t}\n    \t\t}\n        }\n    }\n    if( MAXWEIGHT2 != min ) {\n    \texchange( &B[ W[prei].order ], &B[prei] );\n    \t\n\t\tt = B[ W[prei].order ].order = B[ prei ].order;\n\t\tif( B[ prei ].cost == W[prei].cost ) {\n\t\t\tW[prei].order=B[ prei ].order=prei;\n\t\t}\n\t\tif( B[t].cost == W[t].cost ) {\n\t\t\tW[t].order=t;\n\t\t}\n\t\t\n    } else {\n    \tmin=0;\n    }\n\n\treturn min;\n}\n\nint main( void ) \n{   \n    int n,i;\n    struct MCS W[MAX+1];\n    struct MCS B[MAX+1];\n    int cnt;\n        \n    scanf( \"%d\", &n );\n    for( i=0; i<n; i++ ) {\n        scanf( \"%d\", &W[i].cost );\n        W[i].order=i;\n        B[i]=W[i];\n    }\n\n    QuickSort( W, 0, n-1 );\n    cnt=0;\n    for( i=0; i<n; i++ ) {\n    \tcnt+=tryChange( n, W, B );\n    }   \n    printf( \"%d\\n\", cnt );\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX  1000\n#define VMAX 10000\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint min(int a,int b){\n  if(a>b) return b;\n  else return a;\n}\n\nint partition(int A[],int p,int r){\n  int i,j;\n  int t,x;\n  x = A[r];\n  i = p - 1;\n\n  for(j=p;j<r;j++){\n    if(A[j]<=x){\n      i++;\n      t = A[i];\n      A[i] = A[j];\n      A[j] = t;\n    }\n  }\n\n  t = A[i+1];\n  A[i+1] = A[r];\n  A[r] = t;\n\n  return i+1;\n}\nvoid quickSort(int A[],int p,int r){\n  int q;\n  if(p<r){\n    q = partition(A,p,r);\n    quickSort(A,p,q-1);\n    quickSort(A,q+1,r);\n  }\n}\n\n\nint solve(){\n  int ans=0,i,cur,S,m,an,v;\n\n  int V[MAX];\n  for(i=0;i<n;i++){\n    B[i] = A[i];\n    V[i] = 0;\n  }\n  quickSort(b,0,n-1);\n  for(i=0;i<n;i++) T[B[i]] = i;\n  for(i=0;i<n;i++){\n    if(V[i]) continue;\n    cur = i;\n    S = 0;\n    m = VMAX;\n    an = 0;\n    while(1){\n      V[cur] = 1;\n      an++;\n      v = A[cur];\n      m = min(m,v);\n      S += v;\n      cur = T[v];\n      if(V[cur]) break;\n    }\n    ans += min(S+(an-2)*m,m+S+(an+1)*s);\n  }\n  return ans;\n}\n\n\n\nint main(){\n  int i;\n\n  scanf(\"%d\", &n);\n  \n  s = VMAX;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    s = min(s,A[i]);\n  }\n\n  int ans = solve();\n  printf(\"%d\\n\",ans);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define NMAX 1000\n#define WMAX 10000\n\nint mincost(short *, int, int);\n\nint main(void)\n{\n\tint i, j, n, d, wtemp, wmin=WMAX, cost=0;\n\tshort w[NMAX], s[NMAX], l[NMAX];\n\tchar c[WMAX+1]={0}, flag[NMAX]={0};\n\t\n\tscanf(\"%d\",&n);\n\tfor (i=0; i<n; i++) {\n\t\tscanf(\"%d\",&w[i]);\n\t\tif (wmin > w[i]) wmin = w[i];\n\t\tc[w[i]]++;\n\t}\n\tj=0;\n\tfor (i=0; i<=WMAX; i++) {\n\t\tif(c[i]) {\n\t\t\ts[j] = i;\n\t\t\tj++;\n\t\t}\n\t}\n\t\n\tfor (i=0; i<n; i++) {\n\t\tif( flag[i]==0 ) {\n\t\t\td = 0;\n\t\t\tflag[i]++;\n\t\t\tl[d] = w[i];\n\t\t\td++;\n\t\t\twtemp = w[i];\n\t\t\twhile (1) {\n\t\t\t\tj = 0;\n\t\t\t\twhile (s[j] != wtemp) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif(j == i) break;\n\t\t\t\tflag[j]++;\n\t\t\t\tl[d] = w[j];\n\t\t\t\td++;\n\t\t\t\twtemp = w[j];\n\t\t\t}\n\t\t\tcost += mincost(l, d, wmin);\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\",cost);\n\t\n\treturn 0;\n}\n\nint mincost(short *l, int d, int wmin)\n{\n\tint i, c1=0, c2, lmin=WMAX, imin;\n\t\n\tfor (i=0; i<d; i++) {\n\t\tc1 += l[i];\n\t\tif(lmin > l[i]) {\n\t\t\tlmin = l[i];\n\t\t}\n\t}\n\t\n\tc2 = c1;\n\tc1 += (d-2)*lmin;\n\tc2 += lmin + (d+1)*wmin;\n\t\n\tif (c1 < c2) return c1;\n\telse return c2;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX_N  1000\n\nvoid QuickSort(int, int);\nint Partition(int, int);\nint MinimumCost(int);\n\nstruct rist\n{\n  int n;\n  int p;\n} typedef rist;\n\nrist A[MAX_N];\n\nint main()\n{\n\tint i;\n\tint n;\n\tint cost;\n\t\n\tscanf(\"%d\", &n);\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &A[i].n);\n\t\tA[i].p = i;\n\t}\n\t\n\tQuickSort(0, n - 1);\n\tcost = MinimumCost(n);\n\t\n\tprintf(\"%d\\n\", cost);\n\t\n\treturn 0;\n}\n\nvoid QuickSort(int p, int r)\n{\n  int q;\n\n  if(p < r)\n    {\n      q = Partition(p, r);\n      QuickSort(p, q - 1);\n      QuickSort(q + 1, r);\n    }\n}\n\nint Partition(int p, int r)\n{\n\tint i, j;\n\trist tmp;\n\n\ti = p - 1;\n\tfor(j = p; j < r; j++)\n    {\n    \tif(A[j].n <= A[r].n)\n\t\t{\n\t \t\t i = i + 1;\n\t \t\t tmp = A[i];\n\t  \t\tA[i] = A[j];\n\t  \t\tA[j] = tmp;\n\t\t}\n    }\n\ttmp = A[i + 1];\n  \tA[i + 1] = A[r];\n  \tA[r] = tmp;\n  \n  \treturn i + 1;\n}\n\nint MinimumCost(int n)\n{\n\tint i;\n\tint tmp;\n\tint cost;\n\t\n\tfor(i = n - 1; i >= 0; i--)\n\t{\n\t\tif(A[i].p != i)\n\t\t{\n\t\t\tcost += A[i].n + A[A[i].p].n;\n\n\t\t\ttmp = A[A[i].p].p;\n\t\t\tA[A[i].p].p = A[i].p;\n\t\t\tA[i].p = tmp;\n\t\t}\n\t}\n\treturn cost;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX 1000\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\n\nint A[MAX] = {0};\nint B[MAX] = {0};\nint T[10000 + 1];\nint n, s;\n\nint partition(int A[], int p, int r) {\n\tint x, i, j, tmp;\n\tx = A[r];\n\ti = p - 1;\n\n\tfor (j = p; j < r; ++j) {\n\t\tif (A[j] <= x) {\n\t\t\t++i;\n\t\t\ttmp = A[i];\n\t\t\tA[i] = A[j];\n\t\t\tA[j] = tmp;\n\t\t}\n\t}\n\ttmp = A[i+1];\n\tA[i+1] = A[r];\n\tA[r] = tmp;\n\treturn i + 1;\n}\n\nvoid quicksort(int A[], int p, int r) {\n\tint q;\n\tif (p < r) {\n\t\tq = partition(A, p, r);\n\t\tquicksort(A, p, q-1);\n\t\tquicksort(A, q+1, r);\n\t}\n}\n\nint solve() {\n\tint ans = 0;\n\tint i, cur, S, m, an, v;\n\tshort V[MAX] = {0};\n\n\tfor (i = 0; i < n; ++i) {\n\t\tB[i] = A[i];\n\t\tV[i] = 0;\n\t}\n\tquicksort(B, 0, n-1);\n\tfor (i = 0; i < n; ++i) {\n\t\tprintf(\"%d \", B[i]);\n\t}\n\tprintf(\"\\n\");\n\n\tfor (i = 0; i < n; ++i) T[B[i]] = i;\n\tfor (i = 0; i < n; ++i) {\n\t\tif (V[i]) continue;\n\t\tcur = i;\n\t\tS = 0;\n\t\tm = INT_MAX;\n\t\tan = 0;\n\t\twhile (1) {\n\t\t\tV[cur] = 1;\n\t\t\tan++;\n\t\t\tv = A[cur];\n\t\t\tm = MIN(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\t//\tprintf(\"i = %d, cur = %d, v = %d, S = %d, an = %d, ans = %d\\n\", i, cur, v, S, an, ans);\n\t\t\tif (V[cur]) break;\n\t\t}\n\t\tans += MIN(S + (an - 2) * m, m + S + (an + 1) * s);\n\t}\n\n\treturn ans;\n}\n\nint main(void) {\n\tint i;\n\tscanf(\"%d\", &n);\n\ts = INT_MAX;\n\t\n\tfor (i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &A[i]);\n\t\tif (s > A[i]) s = A[i];\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX 1000\n#define VMAX 10000\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nvoid sort(int *B,int *B_2){\n}\n\nint min(int m,int v){\n  return 1;\n}\nint solve(){\n  int i,cur,S,m,an,v,ans = 0;\n  int V[MAX];\n  for(i=0;i<n;i++){\n    B[i] = A[i];\n    V[i] = 0;\n  }\n  sort(B,B+n);\n  for(i=0;i<n;i++) T[B[i]] = i;\n  for(i=0;i<n;i++){\n    if(V[i]) continue;\n    cur = i;\n    S = 0;\n    m = VMAX;\n    an = 0;\n    while(1){\n      V[cur] = 1;\n      an++;\n      v = A[cur];\n      m = min(m,v);\n      S += v;\n      cur = T[v];\n      if(V[cur]) break;\n    }\n    ans += min(S + (an - 2)*m,m + S + (an + 1) * S);\n  }\n  return ans;\n}\n\nint main(){\n  int i,ans;\n  scanf(\"%d\",&n);\n  s = VMAX;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",A[i]);\n    s = min(s,A[i]);\n  }\n  ans = solve();\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "        #include<stdio.h>\n\n        #define N 1000\n\n\n        int n,A[N],B[N],C[N],con,res,min;\n\n        int small(int a,int b)\n        {\n          if(a<b)return a;\n          else return b;\n        }\n\n        int search(int a)\n        {\n          int i;\n          for(i=0; i<n; i++){\n            if(A[i]==a)return i;\n          }\n        }\n\n        int main()\n        {\n          int i,j,sum=0,p;\n\n          scanf(\"%d\",&n);\n\n          for(i=0; i<n; i++){\n            scanf(\"%d\",&A[i]);\n            B[i]=A[i];\n          }\n\n          for(i=n-1; i>0; i--){\n            for(j=0; j<i; j++){\n              if(B[j]>B[j+1]){\n                int tmp;\n                tmp=B[j];\n                B[j]=B[j+1];\n                B[j+1]=tmp;\n              }\n            }\n          }\n\n          for(i=0; i<n; i++)C[i]=0;\n\n          for(i=0; i<n; i++){\n            p=i;\n            con=res=0;\n            min=(1<<24);\n\n            while(C[p]==0){\n              C[p]=1;\n              con++;\n              res+=A[p];\n              min=small(min,A[p]);\n              p=search(B[p]);\n            }\n\n            if(con<2)continue;\n            sum+=small(res+B[0]*(con+1)+min,res+min*(con-2));\n          }\n\n          printf(\"%d\\n\",sum);\n\n          return 0;\n        }\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define Max  1000\n#define vMax 10000\n\nint n, a[Max], s;\nint b[Max], t[vMax + 1];\n\n\nint partition(int a[], int p, int r){\n  int i, j;\n  int t, x;\n  x = a[r];\n  i = p - 1;\n\n  for(j = p ; j < r ; j++){\n    if(a[j] <= x){\n      i++;\n      t = a[i];\n      a[i] = a[j];\n      a[j] = t;\n    }\n  }\n\n  t = a[i + 1];\n  a[i + 1] = a[r];\n  a[r] = t;\n\n  return i + 1;\n}\n\nvoid quickSort(int a[], int p, int r){\n  int q;\n  if(p < r){\n    q = partition(a, p, r);\n    quickSort(a, p, q - 1);\n    quickSort(a, q + 1, r);\n  }\n}\n\n\n\nint solve(){\n  int i,ans = 0, cur, S, m, an, v;\n\n  int V[Max];\n  for(i = 0 ; i < n ; i++){\n    b[i] = a[i];\n    V[Max] = 0;\n  }\n\n  quickSort(b, 0, n - 1);\n\n  for(i = 0 ; i < n ; i++) t[b[i]] = i;\n  for(i = 0 ; i < n ; i++){\n    if(V[i]) continue;\n    cur = i;\n    S = 0;\n    m = vMax;\n    an = 0;\n    while(1){\n      V[cur] = 1;\n      an++;\n      v = a[cur];\n\n      if(v < m) m = v;\n\n      S += v;\n      cur = t[v];\n      if(V[cur]) break;\n    }\n    if(S + (an -2) * m < m + S + (an + 1) * s) ans += S + (an -2) * m;\n    if(S + (an -2) * m > m + S + (an + 1) * s) ans +=  m + S + (an + 1) * s;\n  }\n  return ans;\n}\n\n\nint main(){\n  int i;\n\n  scanf(\"%d\", &n);\n  s = vMax;\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\", &a[i]);\n    if(a[i] < s) s = a[i];\n}\n\n  int ans = solve();\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX 1001\n\nint array[MAX];\nint sorted[MAX];\nint swap_limit = 0;\nint answer = 0;\n\nvoid swap(int* a, int* b){\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nvoid dfs(int n, int deep, int score){\n  int i, j, flag = 1;\n\n  //printf(\"%d, %d => %d\\n\", deep, score, answer);\n\n  for(i = 0; i < n; i++){\n    if(array[i] == sorted[i]){ continue; }\n\n    for(j = i + 1; j < n; j++){\n      if(array[j] == sorted[j]) { continue; }\n      {\n\tint next_score = score + array[i] + array[j];\n\tflag = 0;\n\t\n\tif(next_score >= answer){\n\t  continue;\n\t}else if(deep + 1 > swap_limit){\n\t  continue;\n\t}else{\n\t  swap(&array[i], &array[j]);\n\t  \n\t  dfs(n, deep + 1, next_score);\n\t  \n\t  swap(&array[i], &array[j]);\n\t}\n      }\n    }\n  }\n\n  if(flag){\n    if(answer > score){\n      answer = score;\n    }\n    \n    if(swap_limit > deep){\n      swap_limit > deep;\n    }\n  }\n}\n\nint main(int argc, char* argv[]){\n  int i, j, n;\n  scanf(\"%d\", &n);\n\n  for(i = 0; i < n; i++){\n    scanf(\"%d\", &array[i]);\n    sorted[i] = array[i];\n  }\n  \n  for(i = 0; i < n; i++){\n    int min = sorted[i];\n    int min_pos = i;\n    \n    for(j = i + 1; j < n; j++){\n      if(min > sorted[j]){\n\tmin = sorted[j];\n\tmin_pos = j;\n      }\n    }\n\n    if(min_pos != i){\n      swap(&sorted[i], &sorted[min_pos]);\n      \n      swap_limit++;\n      answer += sorted[i] + sorted[min_pos];\n    }\n  }\n\n  dfs(n, 0, 0);\n\n  //printf(\"swap_count = %d, answer = %d\", swap_limit, answer);  \n  printf(\"%d\\n\", answer);\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 1000\n#define N 10000\n\nint n,s;\nint a[MAX],b[MAX],T[N+1];\nint partition(int a[],int p,int r);\nvoid quickSort(int a[], int p, int r);\nint partition(int a[], int p, int r);\nint solve();\n\nint main(){\n  int i;\n  int result;\n  scanf(\"%d\",&n);\n  s = N;\n  for(i = 0 ; i<n; i++){\n    scanf(\"%d\",&a[i]);\n    if(a[i] < s){\n      s = a[i];\n    }\n  }\n    result = solve();\n    printf(\"%d\\n\",result);\n    return 0;\n  }\n\nint partition(int a[], int p, int r){\n  int i, j,t,k;\n  k = a[r];\n  i = p-1;\n  for(j = p ;j< r; j++ ){\n    if(a[j] <= k){\n      i++;\n      t = a[i];\n      a[i] = a[j];\n      a[j] = t;\n    }\n  }\n  t = a[i + 1];\n  a[i + 1] = a[r];\n  a[r] = t;\n  return i + 1;\n}\n\nvoid quickSort(int a[], int p, int r){\n  int q;\n  if(p < r){\n    q = partition(a, p, r);\n    quickSort(a, p,q-1);\n    quickSort(a, q + 1, r);\n  }\n}\n\nint solve(){\n  int i, cur;\n  int S,v,m,a1;\n  int result = 0;\n  int V[MAX];\n  for(i = 0 ; i< n; i++){\n    b[i] = a[i];\n    V[i] = 0;\n\t }\n  quickSort(b,0,n-1);\n\n  for(i = 0; i<n; i++){\n    T[b[i]] = i;\n  }\n  for(i = 0; i<n;i++){\n    if(V[i]) continue;\n    cur = i;\n    S = 0;\n    m = N;\n    a1= 0;\n    while(1){\n      V[cur] = 1;\n      a1++;\n      v = a[cur];\n      if(v < m) {\n\tm = v;\n\t  }\n      S += v;\n    cur = T[v];\n    if(V[cur]) break;\n  }\n\n  if(S + (a1 -2)*m<m + S + (a1 +1) *s) {\n    result += S + (a1 -2) * m;\n  }\n  \n  else{\n    result += m + S + (a1 +1) *s;\n  }\n  }\n  return result;\n}\n\n\n\n"
  },
  {
    "language": "C",
    "code": "\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n  \n  \n  \nint n,cost;\nint A[1001],B[1001];\nint L[501],R[502];\n  \n  \nvoid merge(int left,int mid,int right){\n  int i,j,n1=mid-left,n2=right-mid;\n  for(i=0;i<n1;i++) L[i]=A[left+i];\n  L[n1]=INT_MAX;\n  for(i=0;i<n2;i++) R[i]=A[mid+i];\n  R[n2]=INT_MAX;\n  int l=0,r=0;\n  for(i=left;i<right;i++){\n    if(L[l]<=R[r]){\n      A[i]=L[l];\n      l++;\n    }\n    else{\n      A[i]=R[r];\n      r++;\n    }\n  }\n}\n  \n  \nvoid m_sort(int left,int right){\n  int mid;\n  if( left+1 >= right) return;\n  mid=(left+right)/2;\n  m_sort(left,mid);\n  m_sort(mid,right);\n  merge(left,mid,right);\n}\n  \n  \nvoid swap(int a,int b,int *C){\n  int swap;\n  swap=C[a];\n  C[a]=C[b];\n  C[b]=swap;\n}\n  \n  \n  \n  \n  \n  \n    \n   \n    \n  \nint main(){\n  scanf(\"%d\",&n);\n  int i,j;\n  int cnt,sum,min,start,x;\n  int C[1001]={};\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n  m_sort(0,n);\n  for(i=0;i<n;i++){\n    if(A[i]==B[i]) C[i]=1;\n  }\n  cost=0;\n  for(i=0;i<n;i++){\n    if(C[i]!=1){\n      C[i]=1;\n      cnt=0;\n      sum=0;\n      min=B[i];\n      x=i;\n      while(1){\n        for(j=0;j<n;j++){\n          if(B[x]==A[j]){\n            C[j]=1;\n            cnt++;\n            sum+=B[j];\n            if(min > B[j]) min=B[j];\n            x=j;\n            break;\n          }\n        }\n        if(x==i) break;\n      }\n      sum-=min;\n      if( (cnt -1)*min > (cnt -1)*A[0]+2*(min +A[0])) cost+=sum+(cnt-1)*A[0]+2*(min +A[0]);\n      else cost+=sum+(cnt-1)*min;\n    }\n  }\n  printf(\"%d\\n\",cost);\n  return 0;\n}\n \n  "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\n//============================================================================\n#define pred(x) ((x)-1)\n#define succ(x) ((x)+1)\n//============================================================================\ntypedef unsigned char  INT8U;\ntypedef unsigned short INT16U;\ntypedef   signed short INT16S;\ntypedef long INT32;\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nINT16U *C;\n//----------------------------------------------------------------------------\nvoid CountingSort(INT16U *A, INT16U *B,  INT16U n, INT16U k)\n{\n    long i;\n\n    for (i = 0; i<n; i++)\n        C[A[i]]++;\n    for (i = 1; i<=k; i++)\n        C[i] += C[i-1];\n    /*for (i = 1; i<=k; i++)\n        printf(\"%d \", C[i]);\n    printf(\"\\n\");\n    printf(\"B[C[A[i]]-1] = A[i];\\n\");\n    for (i=n-1; 0<=i; i--){\n        B[C[A[i]]-1] = A[i];\n        printf(\"B[%d]=%d C[%d]=%d A[%d]=%d\\n\", C[A[i]]-1, B[C[A[i]]-1],\n                            A[i], C[A[i]], i, A[i]);\n        C[A[i]]--;\n    }*/\n}\n//----------------------------------------------------------------------------\nINT16S getminptr(INT16U *A, INT16U N)\n{\n    INT16U i,min; INT16S ptr;\n\n    for (i=0, ptr=-1, min=32767; i<N; i++){\n        if (A[i]<min && pred(C[A[i]])!=i){\n            min=A[i];\n            ptr=i;\n        }\n    }\n    return ptr;\n}\n//----------------------------------------------------------------------------\nlong sum;\nvoid exchange(INT16U *x, INT16U *y)\n{\n    INT16U z;\n\n    z=*x, *x=*y, *y=z;\n    sum+=*x;\n    sum+=*y;\n    //printf(\"ex: %d<-->%d, sum:%ld\\n\", *y, *x, sum);\n}\n//----------------------------------------------------------------------------\nlong mincostsort(INT16U *A, INT16U N)\n{\n    int ptr,i,j,min;\n\n    for (i=sum=0; i<pred(N); i++)\n    for (j=succ(i); j<N; j++)\n        if (pred(C[A[j]])==i && pred(C[A[i]])==j)\n            exchange(&A[i], &A[j]);\n    for (i=0,j=32000; i<N; i++)\n        if (A[i]<j)\n            j=A[i],min=i;\n    for (; 0<=(ptr=getminptr(A, N));){\n        if (A[min]<A[ptr]){\n            exchange(&A[min], &A[ptr]);\n            //ptr=min;\n        }\n        while (pred(C[A[ptr]])!=ptr){\n            for (i=0; i<N; i++)\n                if (C[A[i]]==succ(ptr)){\n                    exchange(&A[ptr], &A[i]);\n                    ptr=i;\n#ifdef DESKTOP\n                    for (j=0; j<N; j++)\n                        printf(\"%2d \", A[j]);\n                    printf(\" sum:%ld\\n\", sum);\n#endif\n                    break;\n                }\n        }\n    }\n    return sum;\n}\n//----------------------------------------------------------------------------\n/*\n*                                         *     *\n0 62 33 29 72 52 43 19 5  93 51 32  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51  5  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51 47  8 11 56  5 66 69 30 17 68  5\n0  5 33 29 72 52 43 19 32 93 51 47  8 11 56 62 66 69 30 17 68  0\n0  5 33 29 72 52 43 19 32 93  8 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 29 72 52  8 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33  8 72 52 29 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 11 72 52 29 19 32 93 43 47 51  8 56 62 66 69 30 17 68  8\n0  5 33 11 72  8 29 19 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29  8 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 69  8 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66  8 69 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 68 69 17  8  8\n0  5 33 11 72 19 29 30 32  8 43 47 51 52 56 62 66 68 69 17 93  8\n0  5  8 11 72 19 29 30 32 33 43 47 51 52 56 62 66 68 69 72 93  0\n0  5  8 11 17 19 29 30 32 33 43 47 51 52 56 62 66 68 69 17 93  0\n\n\n\n\n5\n1 5 3 4 2\n7\n\n4\n4 3 2 1\n10\n*/\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nvoid input(FILE *file)\n{\n    long i,n,max,ave; INT16U *A, *B; char buffer[20];\n\n    fgets(buffer, sizeof(buffer)-1, file);\n    sscanf(buffer, \"%ld\", &n);\n    A = malloc(succ(n)*sizeof(INT16U));\n    B = malloc(succ(n)*sizeof(INT16U));\n    for (i=ave=max=0; i<n; i++){\n        fscanf(file, \"%hd\",  &A[i]);\n        if (max<A[i])\n            max=A[i];\n        ave+=A[i];\n    }\n    ave/=n;\n    C = malloc(succ(max)*sizeof(INT16U));\n    memset(C, 0, sizeof(INT16U)*succ(max));\n    CountingSort(A, B, n, max);\n    printf(\"%ld\\n\", mincostsort(A, n));\n#ifdef DESKTOP\n    for (i=0; i<n; i++){\n        if (i) printf(\" \");\n        printf(\"%hd\", A[i]);\n    }\n    printf(\"\\n\");\n#endif\n    free(A);\n    free(B);\n    free(C);\n}\n//============================================================================\n#ifndef DESKTOP\nint main()\n{\n    input(stdin);\n    return 0;\n}\n#endif"
  },
  {
    "language": "C",
    "code": "#include <vector>\n#include <algorithm>\n#include <cstdio>\nint main(){\n\tint N,r=0;\n\tscanf(\"%d\",&N);\n\tstd::vector<int>v(N);\n\tfor(int i=0;i<N;i++)scanf(\"%d\",&v[i]);\n\tfor(int i=N-1;i>=0;i--){\n\t\tint ma=v[i],idx=i;\n\t\tfor(int j=i-1;j>=0;j--)if(ma<v[j])ma=v[j],idx=j;\n\t\tif(ma>v[i]){\n\t\t\tr+=v[i]+v[idx];\n\t\t\tstd::swap(v[i],v[idx]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",r);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX  1000\n#define VMAX 10000\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint min(int a,int b){\n  if(a>b) return b;\n  else return a;\n}\n\nint partition(int A[],int p,int r){\n  int i,j;\n  int t,x;\n  x = A[r];\n  i = p - 1;\n\n  for(j=p;j<r;j++){\n    if(A[j]<=x){\n      i++;\n      t = A[i];\n      A[i] = A[j];\n      A[j] = t;\n    }\n  }\n\n  t = A[i+1];\n  A[i+1] = A[r];\n  A[r] = t;\n\n  return i+1;\n}\nvoid quickSort(int A[],int p,int r){\n  int q;\n  if(p<r){\n    q = partition(A,p,r);\n    quickSort(A,p,q-1);\n    quickSort(A,q+1,r);\n  }\n}\n\n\nint solve(){\n  int ans=0,i,cur,S,m,an,V;\n\n  int V[MAX];\n  for(i=0;i<n;i++){\n    B[i] = A[i];\n    V[i] = 0;\n  }\n  quickSort(b,0,n-1);\n  for(i=0;i<n;i++) T[B[i]] = i;\n  for(i=0;i<n;i++){\n    if(V[i]) continue;\n    cur = i;\n    S = 0;\n    m = VMAX;\n    an = 0;\n    while(1){\n      V[cur] = 1;\n      an++;\n      v = A[cur];\n      m = min(m,v);\n      S += v;\n      cur = T[v];\n      if(V[cur]) break;\n    }\n    ans += min(S+(an-2)*m,m+S+(an+1)*s);\n  }\n  return ans;\n}\n\n\n\nint main(){\n  int i;\n\n  scanf(\"%d\", &n);\n  \n  s = VMAX;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    s = min(s,A[i]);\n  }\n\n  int ans = solve();\n  printf(\"%d\\n\",ans);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n  \n#define MAX 1000\n#define MAXWEIGHTIJ 20000\n  \nstruct MCS {\n    int cost;\n    int order;\n};\n  \nvoid exchange( struct MCS *pa, struct MCS *pb )\n{\n    struct MCS t;\n       \n    t=*pa;\n    *pa=*pb;\n    *pb=t;\n       \n     return;\n}\n   \nint Partition( struct MCS A[], int p, int r )\n{\n    struct MCS x;\n    int i,j;\n   \n    x=A[r];\n    i=p-1;\n    for( j=p; j<r; j++ ) {\n        if( A[j].cost < x.cost ) {\n            i++;\n            exchange( &A[i], &A[j] );\n         }\n    }\n    exchange( &A[i+1], &A[r] );\n  \n    return i+1;\n}\nvoid QuickSort( struct MCS A[], int p, int r )\n{\n    int q;\n       \n    if( p < r ) {\n        q=Partition( A, p, r );\n        QuickSort( A, p, q-1 );\n        QuickSort( A, q+1, r );\n    }\n    return;\n}\n  \nint tryChange( int n, struct MCS W[] )\n{\n    int cnt;\n    int fixedcost,profit;\n    int from, to, togoal;\n      \n    int cost,lowestCost;\n    int i,j;\n    int lowW,lowestW;\n    int low,high,lowest;\n  \n    lowestW=lowW=lowestCost=cost=MAXWEIGHTIJ;\n    lowest=high=low=-1;\n    for( i=0; i<n; i++ ) {\n        if( i != W[i].order && W[i].cost < lowW ) {\n            lowW=W[i].cost;\n            low=i;\n            for( j=0; j<n; j++ ) {\n                if( low == W[j].order ) {\n                    high=j;\n                    break;\n                }\n            }\n        }\n        if( W[i].cost < lowestW ) {\n            lowestW=W[i].cost;\n            lowest=i;  \n        }      \n    }\n  \n    if( W[high].order == low && W[low].order == high ) {\n        lowestCost = W[low].cost + W[high].cost;\n    } else if( low != lowest ) {   \n        fixedcost = W[low].cost + W[lowest].cost;\n        profit = W[low].cost - W[lowest].cost;\n        from=high;\n        to=low;\n        togoal = W[low].order;\n        cnt=0;\n        while( 1 ) {\n            if( W[from].order == to ) {\n                if( togoal == to ) { break; }\n                to=from;\n                cnt++;\n            } else {\n                break;\n            }\n            for( i=0; i<n; i++ ) {\n                if( i != W[i].order ) {\n                    if( to == W[i].order ) {\n                        from=i;\n                        break;\n                    }\n                }\n            }\n        }\n        profit = ( profit * cnt ) - ( 2 * fixedcost );\n        if( 0 < profit ) {\n            high=low;\n            low=lowest;\n            lowestCost = fixedcost;\n        }\n    }\n    if( W[high].order == low ) {\n        lowestCost = W[low].cost + W[high].cost;\n    }\n  \n    if( MAXWEIGHTIJ != lowestCost ) {\n        exchange( &W[low], &W[high] );\n    } else {\n        lowestCost=0;\n    }\n    return lowestCost;\n}\n  \nint main( void )\n{  \n    int n,i;\n    struct MCS W[MAX+1];\n    int cost;\n          \n    scanf( \"%d\", &n );\n    for( i=0; i<n; i++ ) {\n        scanf( \"%d\", &W[i].cost );\n        W[i].order=i;\n    }\n  \n    QuickSort( W, 0, n-1 );\n    cost=i=0;\n    while( (i = tryChange( n, W ) ) ) {\n        cost+=i;\n    }\n    printf( \"%d\\n\", cost );\n  \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n \n#define NMAX 1000\n#define WMAX 10000\n\n\nint mincost(short *, int, int);\n\n\n\nint main(){\n  \n  int i, j;\n  int n;\n  int d;\n  int wtemp, wmin=WMAX;\n  int cost=0;\n  short w[NMAX], s[NMAX], l[NMAX];\n  char c[WMAX+1]={0};\n  char flag[NMAX]={0};\n  \n  \n  scanf(\"%d\",&n);\n  \n  for (i = 0; i < n; i++) {\n    \n    scanf(\"%d\",&w[i]);\n    \n    if (wmin > w[i]) wmin = w[i];\n    c[w[i]]++;\n    \n  }\n  \n  j = 0;\n  \n  \n  for (i = 0; i <= WMAX; i++) {\n    \n    if(c[i]) {\n      \n      s[j] = i;\n      j++;\n      \n    }\n  }\n  \n  for (i = 0; i < n; i++) {\n    if( flag[i] == 0 ) {\n      \n      d = 0;\n      flag[i]++;\n      l[d] = w[i];\n      d++;\n      wtemp = w[i];\n      while (1) {\n\tj = 0;\n\twhile (s[j] != wtemp) {\n\t  j++;\n\t}\n\tif(j == i) break;\n\tflag[j]++;\n\tl[d] = w[j];\n\td++;\n\twtemp = w[j];\n      }\n      cost += mincost(l, d, wmin);\n    }\n  }\n  \n  printf(\"%d\\n\",cost);\n  \n  return 0;\n}\n\nint mincost(short *l, int d, int wmin)\n{\n  int i;\n  int c1 = 0, c2;\n  int lmin = WMAX, imin;\n  \n  for (i = 0; i < d; i++) {\n    c1 += l[i];\n    if(lmin > l[i]) {\n      lmin = l[i];\n    }\n  }\n  \n  c2 = c1;\n  c1 += (d - 2)*lmin;\n  c2 += lmin + (d + 1)*wmin;\n  \n  if (c1 < c2) return c1;\n  else return c2;\n  \n}"
  },
  {
    "language": "C",
    "code": "//?????´???????????????????°??????????(min)?????´????????¬??\\????????¨??????????????????\n//??????????????????min??????????°??????????(s0)??¨????????????min?????£?????????s0??§??????????????????????????????min??¨s0???????????????????????????????????????????????´??????????????????????????????????????????????????????\n#include<stdio.h>\n#include<limits.h>\n\nvoid swap(int *a, int *b){\n\tint temp = *a;\n\t*a = *b;\n\t*b = temp;\n\treturn;\n}\n\nvoid show(int A[], int n){\n\tint i;\n\tfor( i = 0; i < n; i++ ){ printf(\"%5d\", A[i]); }\n\tprintf(\"\\n\");\n\treturn;\n}\n\nvoid merge(int A[], int left, int mid, int right){\n\tint n1 = mid - left;\n\tint n2 = right - mid;\n\tint L[n1+1], R[n2+1];\n\tint i, j, k;\n\tfor( i = 0; i < n1; i++ ){ L[i] = A[left+i]; }\n\tfor( i = 0; i < n2; i++ ){ R[i] = A[mid+i]; }\n\tL[n1] = INT_MAX;\n\tR[n2] = INT_MAX;\n\ti = 0;\n\tj = 0;\n\tfor( k = left; k < right; k++ ){\n\t\tif( L[i] <= R[j] ){\n\t\t\tA[k] = L[i++];\n\t\t}else{\n\t\t\tA[k] = R[j++];\n\t\t}\n\t}\n\treturn;\n}\n\nvoid mergeSort(int A[], int left, int right){\n\tif( left+1 <  right ){\n\t\tint mid = (left + right) / 2;\n\t\tmergeSort(A, left, mid);\n\t\tmergeSort(A, mid, right);\n\t\tmerge(A, left, mid, right);\n\t}\n\treturn;\n}\n\nint minimumCostSort(int A[], int sorted[], int n){\n\tint i, j;\n\tint min, minj, target, targetj;\n\tint cost = 0, addCost, addCost2;\n\tint swaptimes = 0;\n\tfor( i = 0; i < n; i++ ){\n\t\tmin = sorted[i];\n\t\t//sorted???i?????????????´????A??????????????????(minj)????????????\n\t\tfor( j = 0; j < n; j++ ){\n\t\t\tif( A[j] == min ){\n\t\t\t\tminj = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\taddCost = 0;\n\t\taddCost2 = 2 * (A[minj] + sorted[0]);\n\t\twhile( minj != i ){\n\t\t\ttarget = sorted[minj];\n\t\t\tfor( j = 0; j < n; j++ ){\n\t\t\t\tif( A[j] == target ){\n\t\t\t\t\ttargetj = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\taddCost += A[minj] + A[targetj];\n\t\t\taddCost2 += sorted[0] + A[targetj];\n\t\t\tswap(&A[minj], &A[targetj]);\n\t\t\tswaptimes++;\n\t\t\tminj = targetj;\n\t\t\t//show(A, n);\n\t\t}\n\t\t//????°???????????????£??????????????£????????????????????????????????????????????????????????????????????§?????????????????§?????????\n\t\t/*\n\t\tif( 2 * (sorted[i]+sorted[0]) + swaptimes * sorted[0] < swaptimes * sorted[i] ){\n\t\t\tcost += 2 * (sorted[i]+sorted[0]) + swaptimes * sorted[0] - swaptimes * sorted[i];\n\t\t}\n\t\t*/\n\t\tcost += (addCost<addCost2?addCost:addCost2);\n\t\tswaptimes = 0;\n\t}\n\treturn cost;\n}\n\nint main(){\n\tint n, i;\n\tint w[1000], sorted[1000];\n\tscanf(\"%d\", &n);\n\tfor( i = 0; i < n; i++ ){\n\t\tscanf(\"%d\", &w[i]);\n\t\tsorted[i] = w[i];\n\t}\n\tmergeSort(sorted, 0, n);\n\t//show(w, n);\n\t//show(sorted, n);\n\tprintf(\"%d\\n\", minimumCostSort(w, sorted, n));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n \nvoid swap(int* a,int* b){\n  int tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\n \nint n;\nint A[1000];\nint B[1000];\nint vd[1000];\nint cnt,sum,mini;\n \nint min(int x,int y){\n  if(x<y)return x;\n  else return y;\n}\n \nint search(int x){\n  int i;\n  for(i=0;i<n;i++)if(A[i]==x)return i;\n}\n \nint main(){\n  int i,j,ans,x;\n \n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n \n  for(i=n-1;i>0;i--)\n    for(j=0;j<i;j++)\n      if(B[j]>B[j+1])swap(&B[j],&B[j+1]);\n   \n  ans=0;\n  for(i=0;i<n;i++)vd[i]=0;\n \n  for(i=0;i<n;i++){   \n    x=i;\n    cnt=sum=0;\n    mini=(1<<24);\n    while(vd[x]==0){\n      vd[x]=1;\n      cnt++;\n      sum+=A[x];\n      mini=min(mini,A[x]);\n      x=search(B[x]);\n    }\n    if(cnt<2)continue;\n    ans+=min(sum+B[0]*(cnt+1)+mini,sum+mini*(cnt-2));\n \n  }\n \n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 10001\ntypedef struct {\n  int sum;\n  int flag;\n} CC;\nCC C[N];\nint A[1000],B[1000];\nint main()\n{\n  int i,n,min=0,m,k,now,sum=0;\n  scanf(\"%d\",&n);\n  for(i=1;i<n+1;i++){\n    scanf(\"%d\",&A[i]);\n  }\n  \n  for(i=0;i<N;i++){\n    C[i].sum=0;\n    C[i].flag=0;\n  }\n  for(i=1;i<n+1;i++){\n    C[A[i]].sum+=1;\n    C[A[i]].flag+=1;\n  }\n  for(i=0;i<N;i++){\n    C[i].sum+=C[i-1].sum;\n  }\n\n  for(i=0;i<n;i++){\n    if(C[A[i]].flag==1){\n      k=i;\n      now=k;\n      m=0;\n      B[C[A[k]].sum]=A[k];\n      C[A[i]].flag=0;\n      min=A[k];\n      k=C[A[k]].sum;\n      while(A[now]!=A[k]){\n        if(m==0)sum+=A[now];\n        B[C[A[k]].sum]=A[k];\n        C[A[k]].flag=0;\n        sum+=A[k];\n        if(min>A[k])min=A[k];\n        k=C[A[k]].sum;\n        m+=1;\n      }\n      /*if(m>1)sum+=min*(m-1);\n      m=0;\n      min=0;*/\n    }\n    if(m>1)sum+=min;\n    m=0;\n    min=0;\n  }\n  /*for(i=1;i<n;i++){\n    printf(\"%d \",B[i]);\n  }\n  printf(\"%d\",B[i]);*/\n  printf(\"%d\\n\",sum);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX 1000\n#define VMAX 10000\n\nint n , A[MAX] , s;\nint B[MAX] , T[VMAX+1];\n\nvoid bubblesort( int a[]  ){\n\t\n\tint temp , flag = 1;\n\tint j;\n\t\n\twhile( flag == 1 ){\n\t\t\n\t\tflag = 0;\n\t\t\n\t\tfor( j = n - 1; j >= 1; j-- ){\n\t\t\t\n\t\t\tif( a[j] < a[ j - 1 ] ){\n\t\t\t\ttemp = a[j];\n\t\t\t\ta[j] = a[j - 1];\n\t\t\t\ta[j - 1] = temp;\n\t\t\t\tflag = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\nint min( int a , int b ){\n\t\n\tif( a < b ){ return a; }\n\telse{ return b; }\n\t\n}\n\nint solve(){\n\t\n\tint ans = 0;\n\t\n\tint V[MAX];\n\t\n\tfor( int i = 0; i < n; i++ ){\n\t\tB[i] = A[i];\n\t\tV[i] = 0;\n\t}\n\t\n\tbubblesort( B );\n\t\n\tfor( int i = 0; i < n; i++ ) T[B[i]] = i;\n\tfor( int i = 0; i < n; i++ ){\n\t\tif( V[i] ) continue;\n\t\t\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\t\n\t\twhile(1){\n\t\t\tV[cur] = 1;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m,v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif( V[cur] ){ break; }\n\t\t}\n\t\tans += min( S+(an-2) * m , m + S + (an + 1 ) * s );\n\t\t\n\t}\n\t\n\treturn ans;\n\t\n}\n\nint main( void ){\n\t\n\tint ans;\n\t\n\tscanf( \"%d\" , &n );\n\t\n\ts = VMAX;\n\t\n\tfor( int i = 0; i < n; i++ ){\n\t\tscanf( \"%d\" , &A[i] );\n\t\ts = min(s,A[i]);\n\t}\n\t\n\tans = solve();\n\t\n\tprintf( \"%d\\n\" , ans );\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(){\n  int n, i, j, sum = 0, temp;\n  int w[1001];\n\n  scanf(\"%d\", &n);\n  for(i=1; i<=n; i++) scanf(\"%d\", &w[i]);\n\n  for(i=1; i<=n; i++){\n    if(w[i] != i){\n      for(j=i+1; j<=n; j++){\n\tif(w[j] == i){\n\t  temp = w[i];\n\t  w[i] = w[j];\n\t  w[j] = temp;\n\t  sum += w[i] + w[j];\n\t}\n      }\n    }\n  }\n\n  printf(\"%d\\n\", sum);\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "\t//\t????°???????????????????\n#include <stdio.h>\n#include <string.h>\n\n#define DEF_ELEM_MAX 1000\n\n//  ????°?????????????\n#ifndef min\n#define min(a, b)            (((a) < (b)) ? (a) : (b))\n#endif\n\nint A[DEF_ELEM_MAX];\nint B[DEF_ELEM_MAX];\nint N;\nint ans;\n/////////////////////////////////////////////////////////////////////////////////\n//\n/////////////////////////////////////////////////////////////////////////////////\nvoid swap(int *x, int *y)\n{\n\tint tmp = *x;\n\t*x = *y;\n\t*y = tmp;\n\treturn;\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n//\n/////////////////////////////////////////////////////////////////////////////////\nint partition(int *A, int p, int r)\n{\n\tint j;\n\tint x = A[r];\n\tint i = p-1;\n\n\tfor ( j = p ; j < r ; j++ ) {\n\t\tif ( A[j] <= x ) {\n\t\t\ti++;\n\t\t\tswap(&A[i], &A[j]);\n\t\t}\n\t}\n\tswap(&A[i+1], &A[r]);\n\treturn i+1;\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n//\n/////////////////////////////////////////////////////////////////////////////////\nvoid quickSort(int *A, int p, int r)\n{\n\tint q;\n\tif ( p < r ) {\n\t\tq = partition(A, p, r);\n\t\tquickSort(A, p, q-1);\n\t\tquickSort(A, q+1, r);\n\t}\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n//\n/////////////////////////////////////////////////////////////////////////////////\nvoid solve( int *A, int *B, int n )\n{\n\tint i;\n\n\tquickSort(B, 0, n-1);\n\n\tfor ( i = 0 ; i < n ; i++ ) {\n\t\tif (B[i] != A[i]) {;\n\t\t\tans += A[i];\n\t\t}\n\t}\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n//\n/////////////////////////////////////////////////////////////////////////////////\nint main(void)\n{\n\tint i;\n//\n\tscanf(\"%d\", &N);\n\tfor ( i = 0 ; i < N ; i++ ) {\n\t\tscanf(\"%d\", &A[i] );\n\t\tB[i] = A[i];\n\t}\n\n\tsolve(A, B, N);\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid Sort(int*,int,int);\nint Cost_Sort(int*,int,int);\n\nint sum=0;\n\nmain(){\n  int i,n,*A;\n\n  scanf(\"%d\",&n);\n\n  A=(int *)malloc(sizeof(int)*n);\n\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n  }\n\n  Sort(A,0,n-1);\n\n  printf(\"%d\\n\",sum);\n\n  return 0;\n}\n\nvoid Sort(int *A,int i,int n){\n  int p,j;\n  \n  if(i<n){\n    p=Cost_Sort(A,i,n);\n\n    Sort(A,i,p);\n  }\n}\n\nint Cost_Sort(int *A,int i,int n){\n  int j,tmp,max=A[i];\n  static int k;\n  for(j=i+1;j<=n;j++){\n    if(max<A[j]){\n      max=A[j];\n      k=j;\n    }\n  }\n  if(k!=n){\n    sum+=A[k]+A[n];\n    tmp=A[k];\n    A[k]=A[n];\n    A[n]=tmp;\n  }\n\n  return n-1;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint arm(int [], int);\nvoid swap(int *, int *);\n\nint main(){\n  int *A;\n  int n, cost=0;\n  int i;\n\n  scanf(\"%d\",&n);\n\n  A = (int *)malloc(n * sizeof(int));\n\n  for(i=0; i<n; i++)\n    scanf(\"%d\",&A[i]);\n\n  cost = arm(A, n);\n  \n  printf(\"%d\\n\",cost);\n\n  free(A);\n  return 0;\n}\n\nint arm(int A[], int n){\n  int cost = 0;\n  int i;\n  \n  for(i=0; i<n; i++){\n    if((i+1) != A[i]){\n      cost += A[i] + A[A[i]-1];\n      swap(&A[i], &A[A[i]-1]);\n    }\n  }\n  \n  return cost;\n}\n\nvoid swap(int *a, int *b){\n  int tmp;\n\n  tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#define true 1\n#define false 0\n#define MAX 1000\n#define VMAX 10000\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nvoid sort(int C[]);\nint min(int a , int b);\nint solve();\n\nint main(void){\n\tscanf(\"%d\",&n);\n\ts = VMAX;\n\tfor( int i = 0; i < n; i++){\n\t\tscanf(\"%d\",&A[i]);\n\t\ts = min(s, A[i]);\n\t}\n\tint ans = solve();\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}\n\nvoid sort(int C[]){\n\tint tmp;\n\tint flag = 1;\n\twhile(flag == 1){\n\t\tflag = 0;\n\t\tfor( int j = n-1; j >= 1; j--){\n\t\t\tif(C[j] < C[j-1])\n\t\t\t{\n\t\t\t\ttmp = C[j];\n\t\t\t\tC[j] = C[j-1];\n\t\t\t\tC[j-1] = tmp;\n\t\t\t\tflag = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint min(int a , int b){\n\tif(a < b) return a;\n\telse return b;\n}\n\n\nint solve(){\n\tint ans = 0;\n\t\n\tbool V[MAX];\n\tfor( int i = 0; i < n; i++){\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B);\n\tfor( int i = 0; i < n; i++) T[B[i]] = i;\n\tfor( int i = 0; i < n; i++){\n\t\tif(V[i])continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint c = 0;\n\t\twhile(1){\n\t\t\tV[cur] = true;\n\t\t\tc++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m,v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif(V[cur])break;\n\t\t}\n\t\tans += min(S+(c-2)*m, m+S+(c+1)*s);\n\t} \n\treturn ans; \n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX 1000\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\n\nint A[MAX] = {0};\nint B[MAX] = {0};\nint T[10000 + 1];\nint n, s;\n\nint partition(int A[], int p, int r) {\n\tint x, i, j, tmp;\n\tx = A[r];\n\ti = p - 1;\n\n\tfor (j = p; j < r; ++j) {\n\t\tif (A[j] <= x) {\n\t\t\t++i;\n\t\t\ttmp = A[i];\n\t\t\tA[i] = A[j];\n\t\t\tA[j] = tmp;\n\t\t}\n\t}\n\ttmp = A[i+1];\n\tA[i+1] = A[r];\n\tA[r] = tmp;\n\treturn i + 1;\n}\n\nvoid quicksort(int A[], int p, int r) {\n\tint q;\n\tif (p < r) {\n\t\tq = partition(A, p, r);\n\t\tquicksort(A, p, q-1);\n\t\tquicksort(A, q+1, r);\n\t}\n}\n\nint solve() {\n\tint ans = 0;\n\tint i, cur, S, m, an, v;\n\tshort V[MAX] = {0};\n\n\tfor (i = 0; i < n; ++i) {\n\t\tB[i] = A[i];\n\t\tV[i] = 0;\n\t}\n\tquicksort(B, 0, n-1);\n\t/* for (i = 0; i < n; ++i) { */\n\t/* \tprintf(\"%d \", B[i]); */\n\t/* } */\n\t//printf(\"\\n\");\n\n\tfor (i = 0; i < n; ++i) T[B[i]] = i;\n\tfor (i = 0; i < n; ++i) {\n\t\tif (V[i]) continue;\n\t\tcur = i;\n\t\tS = 0;\n\t\tm = INT_MAX;\n\t\tan = 0;\n\t\twhile (1) {\n\t\t\tV[cur] = 1;\n\t\t\tan++;\n\t\t\tv = A[cur];\n\t\t\tm = MIN(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\t//\tprintf(\"i = %d, cur = %d, v = %d, S = %d, an = %d, ans = %d\\n\", i, cur, v, S, an, ans);\n\t\t\tif (V[cur]) break;\n\t\t}\n\t\tans += MIN(S + (an - 2) * m, m + S + (an + 1) * s);\n\t}\n\n\treturn ans;\n}\n\nint main(void) {\n\tint i;\n\tscanf(\"%d\", &n);\n\ts = INT_MAX;\n\t\n\tfor (i = 0; i < n; ++i) {\n\t\tscanf(\"%d\", &A[i]);\n\t\tif (s > A[i]) s = A[i];\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nvoid swap(int *A, int i, int j) {\n  int temp;\n  temp = A[i];\n  A[i] = A[j];\n  A[j] = temp;\n}\n\nvoid Merge(int *A, int left, int mid, int right) {\n  int n1,n2,*L,*R,i,j,k;\n  n1 = mid -left;\n  n2 = right - mid;\n  L = (int*)malloc(sizeof(int) * (n1+1));\n  R = (int*)malloc(sizeof(int) * (n2+1));\n  for (i = 0; i< n1; i++) {\n    L[i] = A[left+i];\n  }\n  for (i = 0; i < n2; i++) {\n    R[i] = A[mid+i];\n  }\n  L[n1] = INT_MAX; R[n2] = INT_MAX;\n  i = 0;j = 0;\n  for(k = left; k < right; k++) {\n    if (L[i] < R[j]) {\n      A[k] = L[i];\n      i++;\n    }else {\n      A[k] = R[j];\n      j++;\n    }\n  }\n  free(L);\n  free(R);\n}\n\nvoid Merge_Sort(int *A, int left, int right) {\n  if(left+1 < right) {\n    int mid = (left + right)/2;\n    Merge_Sort(A,left,mid);\n    Merge_Sort(A,mid,right);\n    Merge(A,left,mid,right);\n  }\n}\nlong step_sort(int *w, int *w1, int i) {\n  int j;\n  long sum = 0;\n  while(w[i] != w1[i]) {\n    j = 0;\n    while (w[j] != w1[i]) j++;\n    sum += w[i]+w[j];\n    swap(w,i,j);\n    i = j;\n  }\n  return sum;\n}\n\nlong normal_sort(int *w, int *w1,int n) {\n  int i,j;\n  i = 0;\n  while(1) {\n    j = 0;\n    while(w[j] != w1[i]) j++;\n    if(i != j) break;\n    i++;\n    if(i >= n) return 0;\n  }\n  return step_sort(w,w1,j);\n}\n\nlong sub_sort(int *w, int *w1, int n) {\n  int i,j,sum;\n  i = 0;\n  while(1) {\n    j = 0;\n    while(w[j] != w1[i]) j++;\n    if(i != j) break;\n    i++;\n    if(i >= n) return 0;\n  }\n  if(i == 0) return step_sort(w,w1,j);\n  sum = w[0] + w[j];\n  swap(w,0,j);\n  return sum+step_sort(w,w1,j);\n}\n\nlong repeat_sort(int *w, int *w1, int n) {\n  int i;\n  int a1[n],a2[n];\n  long v1,v2;\n  for (i = 0; i < n; i++) {\n    a1[i]=w[i];\n    a2[i]=w[i];\n  }\n  v1 = normal_sort(a1,w1,n);\n  if(v1 == 0) return 0;\n  v1 += repeat_sort(a1,w1,n);\n  v2 = sub_sort(a2,w1,n);\n  v2 += repeat_sort(a2,w1,n);\n\n  return (v1 < v2)? v1:v2;\n}\n\nint main()\n{\n  int i,n,*w,*w2;\n  long sum;\n  scanf(\"%d\",&n);\n  w = (int*)malloc(sizeof(int) * n);\n  w2 = (int*)malloc(sizeof(int) * n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\",w+i);\n    w2[i] = w[i];\n  }\n  Merge_Sort(w2,0,n);\n  \n  sum = repeat_sort(w,w2,n);\n  printf(\"%ld\\n\",sum);\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\n//============================================================================\n#define pred(x) ((x)-1)\n#define succ(x) ((x)+1)\n//============================================================================\ntypedef unsigned char  INT8U;\ntypedef unsigned short INT16U;\ntypedef   signed short INT16S;\ntypedef long INT32;\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nINT16U *C;\n//----------------------------------------------------------------------------\nvoid CountingSort(INT16U *A, INT16U *B,  INT16U n, INT16U k)\n{\n    long i;\n\n    for (i = 0; i<n; i++)\n        C[A[i]]++;\n    for (i = 1; i<=k; i++)\n        C[i] += C[i-1];\n    /*for (i = 1; i<=k; i++)\n        printf(\"%d \", C[i]);\n    printf(\"\\n\");\n    printf(\"B[C[A[i]]-1] = A[i];\\n\");\n    for (i=n-1; 0<=i; i--){\n        B[C[A[i]]-1] = A[i];\n        printf(\"B[%d]=%d C[%d]=%d A[%d]=%d\\n\", C[A[i]]-1, B[C[A[i]]-1],\n                            A[i], C[A[i]], i, A[i]);\n        C[A[i]]--;\n    }*/\n}\n//----------------------------------------------------------------------------\nINT16S getminptr(INT16U *A, INT16U N)\n{\n    INT16U i,min; INT16S ptr;\n\n    for (i=0, ptr=-1, min=32767; i<N; i++){\n        if (A[i]<min && pred(C[A[i]])!=i){\n            min=A[i];\n            ptr=i;\n        }\n    }\n    return ptr;\n}\n//----------------------------------------------------------------------------\nlong sum;\nvoid exchange(INT16U *x, INT16U *y)\n{\n    INT16U z;\n\n    z=*x, *x=*y, *y=z;\n    sum+=*x;\n    sum+=*y;\n    //printf(\"ex: %d<-->%d, sum:%ld\\n\", *y, *x, sum);\n}\n//----------------------------------------------------------------------------\nlong mincostsort(INT16U *A, INT16U N)\n{\n    int ptr,i,j,min;\n\n    for (i=sum=0; i<pred(N); i++)\n    for (j=succ(i); j<N; j++)\n        if (pred(C[A[j]])==i && pred(C[A[i]])==j)\n            exchange(&A[i], &A[j]);\n    for (i=0,j=32000; i<N; i++)\n        if (A[i]<j)\n            j=A[i],min=i;\n    for (; 0<=(ptr=getminptr(A, N));){\n        if (!A[min]){\n            exchange(&A[min], &A[ptr]);\n            //ptr=min;\n        }\n        while (pred(C[A[ptr]])!=ptr){\n            for (i=0; i<N; i++)\n                if (C[A[i]]==succ(ptr)){\n                    exchange(&A[ptr], &A[i]);\n                    ptr=i;\n#ifdef DESKTOP\n                    for (j=0; j<N; j++)\n                        printf(\"%2d \", A[j]);\n                    printf(\" sum:%ld\\n\", sum);\n#endif\n                    break;\n                }\n        }\n    }\n    return sum;\n}\n//----------------------------------------------------------------------------\n/*\n*                                         *     *\n0 62 33 29 72 52 43 19 5  93 51 32  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51  5  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51 47  8 11 56  5 66 69 30 17 68  5\n0  5 33 29 72 52 43 19 32 93 51 47  8 11 56 62 66 69 30 17 68  0\n0  5 33 29 72 52 43 19 32 93  8 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 29 72 52  8 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33  8 72 52 29 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 11 72 52 29 19 32 93 43 47 51  8 56 62 66 69 30 17 68  8\n0  5 33 11 72  8 29 19 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29  8 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 69  8 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66  8 69 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 68 69 17  8  8\n0  5 33 11 72 19 29 30 32  8 43 47 51 52 56 62 66 68 69 17 93  8\n0  5  8 11 72 19 29 30 32 33 43 47 51 52 56 62 66 68 69 72 93  0\n0  5  8 11 17 19 29 30 32 33 43 47 51 52 56 62 66 68 69 17 93  0\n\n\n\n\n5\n1 5 3 4 2\n7\n\n4\n4 3 2 1\n10\n*/\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nvoid input(FILE *file)\n{\n    long i,n,max,ave; INT16U *A, *B; char buffer[20];\n\n    fgets(buffer, sizeof(buffer)-1, file);\n    sscanf(buffer, \"%ld\", &n);\n    A = malloc(succ(n)*sizeof(INT16U));\n    B = malloc(succ(n)*sizeof(INT16U));\n    for (i=ave=max=0; i<n; i++){\n        fscanf(file, \"%hd\",  &A[i]);\n        if (max<A[i])\n            max=A[i];\n        ave+=A[i];\n    }\n    ave/=n;\n    C = malloc(succ(max)*sizeof(INT16U));\n    memset(C, 0, sizeof(INT16U)*succ(max));\n    CountingSort(A, B, n, max);\n    printf(\"%ld\\n\", mincostsort(A, n));\n#ifdef DESKTOP\n    for (i=0; i<n; i++){\n        if (i) printf(\" \");\n        printf(\"%hd\", A[i]);\n    }\n    printf(\"\\n\");\n#endif\n    free(A);\n    free(B);\n    free(C);\n}\n//============================================================================\n#ifndef DESKTOP\nint main()\n{\n    input(stdin);\n    return 0;\n}\n#endif"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n \n \n \nint n,cost;\nint A[1001],B[1001];\nint L[501],R[502];\n \n \nvoid merge(int left,int mid,int right){\n  int i,j,n1=mid-left,n2=right-mid;\n  for(i=0;i<n1;i++) L[i]=A[left+i];\n  L[n1]=INT_MAX;\n  for(i=0;i<n2;i++) R[i]=A[mid+i];\n  R[n2]=INT_MAX;\n  int l=0,r=0;\n  for(i=left;i<right;i++){\n    if(L[l]<=R[r]){\n      A[i]=L[l];\n      l++;\n    }\n    else{\n      A[i]=R[r];\n      r++;\n    }\n  }\n}\n \n \nvoid m_sort(int left,int right){\n  int mid;\n  if( left+1 >= right) return;\n  mid=(left+right)/2;\n  m_sort(left,mid);\n  m_sort(mid,right);\n  merge(left,mid,right);\n}\n \n \nvoid swap(int a,int b,int *C){\n  int swap;\n  swap=C[a];\n  C[a]=C[b];\n  C[b]=swap;\n}\n \n \n \n \n \n \n   \n  \n   \n \nint main(){\n  scanf(\"%d\",&n);\n  int i,j;\n  int cnt,sum,min,start,x;\n  int C[1001]={};\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n  m_sort(0,n);\n  for(i=0;i<n;i++){\n    if(A[i]==B[i]) C[i]=1;\n  }\n  cost=0;\n  for(i=0;i<n;i++){\n    if(C[i]!=1){\n      C[i]=1;\n      cnt=0;\n      sum=0;\n      min=B[i];\n      x=i;\n      while(1){\n        for(j=0;j<n;j++){\n          if(B[x]==A[j]){\n            C[j]=1;\n            cnt++;\n            sum+=B[j];\n            if(min > B[j]) min=B[j];\n            x=j;\n            break;\n          }\n        }\n        if(x==i) break;\n      }\n      sum-=min;\n      if( (cnt -1)*min > (cnt -1)*A[0]+2*(min +A[0])) cost+=sum+(cnt-1)*A[0]+2*(min +A[0]);\n      else cost+=sum+(cnt-1)*min;\n    }\n  }\n  printf(\"%d\\n\",cost);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 10000\n#define MAX 1000\n\nint su,n;\nint A[MAX],B[MAX],C[N+1],f[MAX];\n\nint res();\nvoid bubbleSort(int b);\nint min(int a,int b);\n\nint main(){\n  int i,t,r;\n  su=10000;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    su=min(su,A[i]);\n  }\n\n  r=res();\n\n  printf(\"%d\\n\",r);\n\n  return 0;\n}\n\nvoid  bubbleSort(int b){\n  int i,j,t,f=1;\n  i=0;\n  while(f==1){\n    f=0;\n    for(j=b-1;j>=i+1;j--){\n      if(B[j]<B[j-1]) {\n\tt=B[j];\n\tB[j]=B[j-1];\n\tB[j-1]=t;\n\tf=1;\n      }\n    }\n    i++;\n  }\n}\n\nint min(int a,int b){\n  if(a<b) return a;\n  else return b;\n}\n\nint res(){\n  int r=0,i,c,s,m,a,v;\n\n  for(i=0;i<n;i++){\n    B[i]=A[i];\n    f[i]=0;\n  }\n\n  bubbleSort(n);\n\n  for(i=0;i<n;i++) C[B[i]]=i;\n  for(i=0;i<n;i++){\n    if(f[i]==1) continue;\n    c=i;\n    s=0;\n    m=10000;\n    a=0;\n    while(1){\n      f[c]=1;\n      a++;\n      v=A[c];\n      m=min(m,v);\n      s=s+v;\n      c=C[v];\n      if(f[c]==1)break;\n    }\n\n    r=r+min(s+(a-2)*m,m+s+(a+1)*su);\n  }\n  return r;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n \nvoid swap(int* a,int* b){\n  int tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\n \nint n;\nint A[1000];\nint B[1000];\nint vd[1000];\nint cnt,sum,mini;\n \nint min(int x,int y){\n  if(x<y)return x;\n  else return y;\n}\n \nint search(int x){\n  int i;\n  for(i=0;i<n;i++)if(A[i]==x)return i;\n}\n \nint main(){\n  int i,j,ans,x;\n \n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n \n  for(i=n-1;i>0;i--)\n    for(j=0;j<i;j++)\n      if(B[j]>B[j+1])swap(&B[j],&B[j+1]);\n   \n  ans=0;\n  for(i=0;i<n;i++)vd[i]=0;\n \n  for(i=0;i<n;i++){   \n    x=i;\n    cnt=sum=0;\n    mini=(1<<24);\n    while(vd[x]==0){\n      vd[x]=1;\n      cnt++;\n      sum+=A[x];\n      mini=min(mini,A[x]);\n      x=search(B[x]);\n    }\n    if(cnt<2)continue;\n    ans+=min(sum+B[0]*(cnt+1)+mini,sum+mini*(cnt-2));\n \n  }\n \n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define W_MAX 1000001\n#define MAX 1001\n\nint array[MAX];\nint sorted[MAX];\n\nvoid swap(int* a, int* b){\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nint greedy(int n){\n  int i, j;\n  int min = W_MAX, min_pos = -1;\n  int next = -1, next_pos = -1;\n\n  int addition = 0;\n  for(i = 0; i < n; i++){\n    if(array[i] == 0){ continue; }\n\n    for(j = i + 1; j < n; j++){\n      if(array[j] == 0) { continue; }\n\n      if(sorted[i] == array[j] && sorted[j] == array[i]){\n\tswap(&array[i], &array[j]);\n\taddition += (array[i] + array[j]);\n      }\n    }\n  }\n\n  for(i = 0; i < n; i++){\n    if(array[i] == 0 || sorted[i] != array[i] && min > array[i]){\n      min = array[i];\n      min_pos = i;\n    }\n  }\n\n  if(min_pos == -1){\n    return addition;\n  }\n\n  if(min == 0 && min_pos == 0){\n    next = W_MAX;\n    \n    for(i = 0; i < n; i++){\n      if(i != min_pos && sorted[i] != array[i] && next > array[i]){\n\tnext = array[i];\n\tnext_pos = i;\n      }\n    }\n  }else{\n    next = sorted[min_pos];\n    \n    for(i = 0; i < n; i++){\n      if(array[i] == next){\n\tnext_pos = i;\n\tbreak;\n      }\n    }\n  }\n\n  if(next_pos == -1){\n    return addition;\n  }\n\n  swap(&array[min_pos], &array[next_pos]);\n  /*\n  for(i = 0; i < n; i++){\n    printf(\"%s%d\", i == 0 ? \"\" : \" \", array[i]);\n  }\n  printf(\"\\n\");\n  */\n  return (next + min) + greedy(n) + addition;\n}\n\nint main(int argc, char* argv[]){\n  int i, j, n;\n  scanf(\"%d\", &n);\n\n  for(i = 0; i < n; i++){\n    scanf(\"%d\", &array[i]);\n    sorted[i] = array[i];\n  }\n  \n  for(i = 0; i < n; i++){\n    int min = sorted[i];\n    int min_pos = i;\n    \n    for(j = i + 1; j < n; j++){\n      if(min > sorted[j]){\n\tmin = sorted[j];\n\tmin_pos = j;\n      }\n    }\n\n    if(min_pos != i){\n      swap(&sorted[i], &sorted[min_pos]);\n    }\n  }\n\n\n  printf(\"%d\\n\", greedy(n));\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 1000\ntypedef struct {\n  int sum;\n  int flag;\n} CC;\nCC C[N];\nint A[2000],B[2000];\nint main()\n{\n  int i,n,min=0,m,k,now,sum=0;\n  scanf(\"%d\",&n);\n  for(i=1;i<n+1;i++){\n    scanf(\"%d\",&A[i]);\n  }\n  \n  for(i=0;i<N;i++){\n    C[i].sum=0;\n    C[i].flag=0;\n  }\n  for(i=1;i<n+1;i++){\n    C[A[i]].sum+=1;\n    C[A[i]].flag+=1;\n  }\n  for(i=0;i<N;i++){\n    C[i].sum+=C[i-1].sum;\n  }\n\n  for(i=n+1;i>0;i--){\n    if(C[A[i]].flag==1){\n      k=i;\n      now=k;\n      m=0;\n      B[C[A[k]].sum]=A[k];\n      C[A[i]].flag=0;\n      min=A[k];\n      k=C[A[k]].sum;\n      while(now!=k){\n        if(m==0)sum+=A[now];\n        B[C[A[k]].sum]=A[k];\n        C[A[k]].flag=0;\n        sum+=A[k];\n        if(min>A[k])min=A[k];\n        k=C[A[k]].sum;\n        m+=1;\n      }\n      if(m>1)sum+=min*(m-1);\n      m=0;\n      min=0;\n    }\n  }\n  /*for(i=1;i<n;i++){\n    printf(\"%d \",B[i]);\n  }\n  printf(\"%d\",B[i]);*/\n  printf(\"%d\\n\",sum);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX = 10000;\nstatic const int VMAX = 100000;\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve(){\n    int i,ans = 0;\n    \n    bool V[MAX];\n    for(i=0;i<n;i++){\n        B[i] = A[i];\n        V[i] = false;\n    }\n    sort(B,B+n);\n    for(i=0;i<n;i++) T[B[i]] = i;\n    for(i=0;i<n;i++){\n        if(V[i]) continue;\n        int cur=i;\n        int S = 0;\n        int m = VMAX;\n        int an = 0;\n        while(1){\n            V[cur] = true;\n            an++\n            int v=A[cur];\n            m = min(m,v);\n            S+=v;\n            cur = T[v];\n            if(V[cur]) break;\n        }\n        ans += min(S+(an-2)*m,m+S+(an+1)*s);\n    }\n    return ans;\n}\n\nint main(){\n    int i;\n    cin>>n;\n    s=VMAX;\n    for(i=0;i<n;i++){\n        cin>>A[i];\n        s=min(s,A[i]);\n    }\n    int ans = solve();\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdbool.h>\n#include<math.h>\nstatic const int MAX = 1000;\nstatic const int VMAX = 10000;\n\nint n,A[MAX],s;\nint B[MAX], T[VMAX+1];\n\nvoid swap(int *a,int *b) {\n  int temp;\n  temp = *a;\n  *a = *b;\n  *b = temp;\n}\n\nvoid qsort(int X[], int left, int right){\n  int i,j;\n  int pivot;\n  i=left;j=right;\n  pivot = X[(left+right)/2];\n\n  while(1) {\n    while(X[i]<pivot)i++;\n    while(pivot<X[j])j--;\n    if(i>=j) break;\n\n    swap(&X[i],&X[j]);\n    i++;  j--;\n  }\n  if(left < i-1) qsort(X,left,i-1);\n  if(j+1<right) qsort(X,j+1,right);\n}\n\n\n\nint solve() {\n  int i;\n  int ans = 0;\n\n  bool V[MAX];\n  for(i=0;i<n;i++){\n    B[i] = A[i];\n    V[i]=false;\n  }\n  qsort(B,0,n-1);\n  for(i=0;i<n;i++) T[B[i]] = i;\n  for(i=0;i<n;i++) {\n    if(V[i]) continue;\n    int cur=i;\n    int S=0;\n    int m=VMAX;\n    int an=0;\n    while(1) {\n      V[cur] = true;\n      an++;\n      int v = A[cur];\n      m = fmin(m,v);\n      S+=v;\n      cur=T[v];\n      if(V[cur])break;\n    }\n    ans+=fmin(S+(an - 2) * m , m+S+(an+1)*s);\n\n  }\n  return ans;\n}\n\nint main(){\n  int i;\n  scanf(\"%d\",&n);\n  s=VMAX;\n  for(i=0;i<n;i++) {\n    scanf(\"%d\",&A[i]);\n    s=fmin(s , A[i]);\n  }\n  int ans = solve();\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "\t//\t????°???????????????????\n#include <stdio.h>\n#include <string.h>\n\n#define DEF_ELEM_MAX 1000\n\n//  ????°?????????????\n#ifndef min\n#define min(a, b)            (((a) < (b)) ? (a) : (b))\n#endif\n\nint A[DEF_ELEM_MAX];\nint B[DEF_ELEM_MAX];\nint N;\nint ans;\n/////////////////////////////////////////////////////////////////////////////////\n//\n/////////////////////////////////////////////////////////////////////////////////\nvoid swap(int *x, int *y)\n{\n\tint tmp = *x;\n\t*x = *y;\n\t*y = tmp;\n\treturn;\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n//\n/////////////////////////////////////////////////////////////////////////////////\nint partition(int *A, int p, int r)\n{\n\tint j;\n\tint x = A[r];\n\tint i = p-1;\n\n\tfor ( j = p ; j < r ; j++ ) {\n\t\tif ( A[j] <= x ) {\n\t\t\ti++;\n\t\t\tswap(&A[i], &A[j]);\n\t\t}\n\t}\n\tswap(&A[i+1], &A[r]);\n\treturn i+1;\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n//\n/////////////////////////////////////////////////////////////////////////////////\nvoid quickSort(int *A, int p, int r)\n{\n\tint q;\n\tif ( p < r ) {\n\t\tq = partition(A, p, r);\n\t\tquickSort(A, p, q-1);\n\t\tquickSort(A, q+1, r);\n\t}\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n//\n/////////////////////////////////////////////////////////////////////////////////\nvoid solve( int *A, int *B, int n )\n{\n\tint i;\n\n\tquickSort(B, 0, n-1);\n\n\tfor ( i = 0 ; i < n ; i++ ) {\n\t\tif (B[i] != A[i]) {;\n\t\t\tans += A[i];\n\t\t}\n\t}\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n//\n/////////////////////////////////////////////////////////////////////////////////\nint main(void)\n{\n\tint i;\n//\n\tscanf(\"%d\", &N);\n\tfor ( i = 0 ; i < N ; i++ ) {\n\t\tscanf(\"%d\", &A[i] );\n\t\tB[i] = A[i];\n\t}\n\n\tsolve(A, B, N);\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX 1000\n#define VMAX 10000;\nint solve(void);\nvoid Ssort(int [],int);\nint min(int,int);\n\nint A[MAX];\nint B[MAX];\nint T[MAX];\nint n,s;\nint kai=0;\n\nint main(){\n  int i,j;\nscanf(\"%d\",&n);\n  s=VMAX;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    s=min(s,A[i]);\n}\n\n  \n  printf(\"%d\\n\",solve());\n\n  return 0;\n}\n\nint solve(){\n  int kai=0;\n  int i;\n  int now;\n  int S,m,v;\n  bool b[MAX];\n  for(i=0;i<n;i++){\nB[i]=A[i];\nb[i]=false;\n  }\n\n  Ssort(B,n);\n  for(i=0;i<n;i++){\n    T[B[i]]=i;\n  }\n  for(i=0;i<n;i++){\n    if(b[i])continue;\n    now=i;\n    S=0;\n    m=VMAX;\n    kai=0;\n    while(1){\n      b[now]=true;\n      kai++;\n      v=A[now];\n      m=min(m,v);\n      S+=v;\n      now=T[v];\n      if(b[now])break;\n    }\n\n    kai+=min(S+(kai-2)*m,m+S+(kai+1)*s);\n  }\n  return kai;\n}\n      \n    \nvoid Ssort(int A[],int N){\n  int i,j;\n  int tmp;\n  for(i=0;i<N-1;i++){\n    for(j=N-1;j>i;j--){\n      if(A[j]<A[j-1]){\n\ttmp=A[j];\n\tA[j]=A[j-1];\n\tA[j-1]=tmp;\n\t\n      }\n    }\n  }\n\n}\n\nint min(int a,int b){\n  if(a<b)return a;\n  else return b;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n     \n     \n     \nint n,cost;\nint A[1001],B[1001];\nint L[501],R[502];\n     \n     \nvoid merge(int left,int mid,int right){\n  int i,j,n1=mid-left,n2=right-mid;\n  for(i=0;i<n1;i++) L[i]=A[left+i];\n  L[n1]=INT_MAX;\n  for(i=0;i<n2;i++) R[i]=A[mid+i];\n  R[n2]=INT_MAX;\n  int l=0,r=0;\n  for(i=left;i<right;i++){\n    if(L[l]<=R[r]){\n      A[i]=L[l];\n      l++;\n    }\n    else{\n      A[i]=R[r];\n      r++;\n    }\n  }\n}\n     \n     \nvoid m_sort(int left,int right){\n  int mid;\n  if( left+1 >= right) return;\n  mid=(left+right)/2;\n  m_sort(left,mid);\n  m_sort(mid,right);\n  merge(left,mid,right);\n}\n     \n     \nvoid swap(int a,int b,int *C){\n  int swap;\n  swap=C[a];\n  C[a]=C[b];\n  C[b]=swap;\n}\n     \n     \n     \n     \n     \n     \n       \n      \n       \n     \nint main(){\n  scanf(\"%d\",&n);\n  int i,j;\n  int cnt,sum,min,start,x;\n  int C[1001]={};\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n  m_sort(0,n);\n  for(i=0;i<n;i++){\n    if(A[i]==B[i]) C[i]=1;\n  }\n  cost=0;\n  for(i=0;i<n;i++){\n    if(C[i]!=1){\n      C[i]=1;\n      cnt=0;\n      sum=0;\n      min=B[i];\n      x=i;\n      while(1){\n        for(j=0;j<n;j++){\n          if(B[x]==A[j]){\n            C[j]=1;\n            cnt++;\n            sum+=B[j];\n            if(min > B[j]) min=B[j];\n            x=j;\n            break;\n          }\n        }\n        if(x==i) break;\n      }\n      sum-=min;\n      if( (cnt -1)*min > (cnt -1)*A[0]+2*(min +A[0])) cost+=sum+(cnt-1)*A[0]+2*(min +A[0]);\n      else cost+=sum+(cnt-1)*min;\n    }\n  }\n  printf(\"%d\\n\",cost);\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <memory.h>\n\n#define MIN(x, y) ((x) <= (y) ? (x) : (y))\nint get_uint() {\n    int n = 0;\n    int c = getchar_unlocked();\n    if(c < 48 || 57 < c) return c;\n    while(47 < c && c < 58) {\n        n = 10 * n + (c & 0xf);\n        c = getchar_unlocked();\n    }\n    return n;\n}\nvoid put_uint(int n) {\n    if(!n) {\n        putchar_unlocked('0');\n        return;\n    }\n    char buf[11];\n    int i = 0;\n    while(n) buf[i++] = (char)(n % 10 + '0'), n /= 10;\n    while(i--)putchar_unlocked(buf[i]);\n}\nvoid *partition(int *first, int *last) {\n    int pivot = *(last - 1);\n    int *p = first - 1;\n    for(int *it = first; it != last - 1; ++it) {\n        if(*it <= pivot) {\n            p++;\n            int tmp = *p;\n            *p = *it;\n            *it = tmp;\n        }\n    }\n    int tmp = *++p;\n    *p = pivot;\n    *(last - 1) = tmp;\n    return p;\n}\nvoid quick_sort(void *first, void *last, size_t N) {\n    if(last - first <= N) return;\n    void *mid = partition(first, last);\n    quick_sort(first, mid, N);\n    quick_sort(mid, last, N);\n}\nint mincost_sort(const int *a, const int N, const int minw) {\n    int cnt = 0;\n    int b[N];\n    memcpy(b, a, N * sizeof(int));\n    quick_sort(b, b + N, sizeof(int));\n    int pos[10001];\n    for(int i = 0; i < N; ++i) pos[b[i]] = i;\n    int flag[1001] = {};\n    for(int i = 0; i < N; ++i) {\n        if(flag[i]) continue;\n        int cur = i;\n        int sum = 0;\n        int num = 0;\n        int mina = 1 << 29;\n        while(!flag[cur]) {\n            flag[cur] = 1;\n            num++;\n            sum += a[cur];\n            mina = MIN(mina, a[cur]);\n            cur = pos[a[cur]];\n        }\n        // [ sum + (num-2)*mina + 2(mina+minw) - (num-1)*(mina-minw) ] -> [ sum + mina + (n+1)*minw ]\n        cnt += MIN(sum + (num - 2) * mina, sum + mina + (num + 1) * minw);\n    }\n    return cnt;\n}\nint main(int argc, char **argv) {\n    int n = get_uint();\n    int w[n];\n    int minw = 1 << 29;\n    for(int i = 0; i < n; ++i) {\n        w[i] = get_uint();\n        minw = MIN(minw, w[i]);\n    }\n    put_uint(mincost_sort(w, n, minw));\n    putchar_unlocked('\\n');\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint n;\nint A[1000], B[1000], data[1000];\nint cnt,sum,minimam;\n\nvoid swap(int* a,int* b){\n  int tmp=*a;\n  *a = *b;\n  *b = tmp;\n}\n\nint min(int x,int y){\n  if(x < y){\n    return x;\n  }else{\n    return y;\n  }\n}\n\nint search(int x){\n  int i;\n  for(i = 0 ; i < n ; i++){\n    if(A[i] == x){\n      return i;\n    }\n  }\n}\n\nint main(){\n  int i, j;\n  int answer, x;\n\n  scanf(\"%d\",&n);\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n\n  for(i = n - 1 ; i > 0 ; i--){\n    for(j = 0 ; j < i ; j++){\n      if(B[j] > B[j + 1])swap(&B[j],&B[j+1]);\n    }\n  }\n\n  answer = 0;\n  for(i = 0 ; i < n ; i++)data[i]=0;\n\n  for(i = 0 ; i < n ; i++){\n    x = i;\n    cnt=sum=0;\n    minimam=(1<<24);\n    while(data[x] == 0){\n      data[x]=1;\n      cnt++;\n      sum+=A[x];\n      minimam = min(minimam,A[x]);\n      x = search(B[x]);\n    }\n    if(cnt<2){\n      continue;\n    }\n    answer+=min(sum+B[0]*(cnt+1)+minimam,sum+minimam*(cnt-2));\n  }\n\n  printf(\"%d\\n\",answer);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define W_MAX 1000001\n#define MAX 1001\n\nint array[MAX];\nint sorted[MAX];\n\nvoid swap(int* a, int* b){\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nint calc_cost(int n, int min_pos, int flag){\n  int loop_pos = min_pos;\n  int i, sum = 0;\n  int min = array[min_pos];\n\n  do{\n    for(i = 0; i < n; i++){\n      if(array[i] == sorted[loop_pos]){\n\tsum += array[i] + min;\n\n\tif(flag){ swap(&array[i], &array[loop_pos]); }\n\n\tloop_pos = i;\n\t\n\tbreak;\n      }\n    }\n    \n    /*\n    if(1){\n      for(i = 0; i < n; i++){\n\tprintf(\"%s%d\", i == 0 ? \"\" : \" \", array[i]);\n      }\n      printf(\" : %d\\n\", sum);\n    }else{\n      printf(\"%d\\n\", sum);\n    }\n    */\n  }while(min != sorted[loop_pos]);\n\n  return sum;\n}\n\nint greedy(int n){\n  int i, j;\n  int absolute_min = sorted[0], absolute_min_pos = -1;\n  int min = W_MAX, min_pos = -1;\n  int loop_pos = -1;\n  int direct_sum = 0;\n  int indirect_sum = 0;\n\n  for(i = 0; i < n; i++){\n    if(array[i] == absolute_min){\n      absolute_min_pos = i;\n      break;\n    }\n  }\n\n  for(i = 0; i < n; i++){\n    if(min > array[i] && sorted[i] != array[i]){\n      min = array[i];\n      min_pos = i;\n    }\n  }\n\n  if(min_pos == -1){\n    return 0;\n  }\n\n  //printf(\"absolute_min = %d(%d)\\n\", absolute_min, absolute_min_pos);\n\n  direct_sum += calc_cost(n, min_pos, 0);\n  \n  swap(&array[min_pos], &array[absolute_min_pos]);\n  indirect_sum += array[min_pos] + array[absolute_min_pos];\n  indirect_sum += calc_cost(n, min_pos, 0);\n  indirect_sum += array[min_pos] + array[absolute_min_pos];\n  swap(&array[min_pos], &array[absolute_min_pos]);\n\n  //printf(\"direct_sum = %d, indirect_sum = %d\\n\", direct_sum, indirect_sum);\n\n  if(direct_sum <= indirect_sum){\n    calc_cost(n, min_pos, 1);\n    \n    return direct_sum + greedy(n);\n  }else{\n    swap(&array[min_pos], &array[absolute_min_pos]);\n    calc_cost(n, min_pos, 1);\n    swap(&array[min_pos], &array[absolute_min_pos]);\n\n    return indirect_sum + greedy(n);\n  }\n\n  return 0;\n}\n\nint main(int argc, char* argv[]){\n  int i, j, n;\n  scanf(\"%d\", &n);\n\n  for(i = 0; i < n; i++){\n    scanf(\"%d\", &array[i]);\n    sorted[i] = array[i];\n  }\n  \n  for(i = 0; i < n; i++){\n    int min = sorted[i];\n    int min_pos = i;\n    \n    for(j = i + 1; j < n; j++){\n      if(min > sorted[j]){\n\tmin = sorted[j];\n\tmin_pos = j;\n      }\n    }\n\n    if(min_pos != i){\n      swap(&sorted[i], &sorted[min_pos]);\n    }\n  }\n\n\n  printf(\"%d\\n\", greedy(n));\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define Max  1000\n#define vMax 10000\n\nint n, a[Max], s;\nint b[Max], T[vMax + 1];\n\n\nint partition(int a[], int p, int r){\n  int i, j;\n  int t, x;\n  x = a[r];\n  i = p - 1;\n\n  for(j = p ; j < r ; j++){\n    if(a[j] <= x){\n      i++;\n      t = a[i];\n      a[i] = a[j];\n      a[j] = t;\n    }\n  }\n\n  t = a[i + 1];\n  a[i + 1] = a[r];\n  a[r] = t;\n\n  return i + 1;\n}\n\nvoid quickSort(int a[], int p, int r){\n  int q;\n  if(p < r){\n    q = partition(a, p, r);\n    quickSort(a, p, q - 1);\n    quickSort(a, q + 1, r);\n  }\n}\n\n\n\nint solve(){\n  int i,ans = 0, cur, S, m, an, v;\n\n  int V[Max];\n  for(i = 0 ; i < n ; i++){\n    b[i] = a[i];\n    V[i] = 0;\n  }\n\n  quickSort(b, 0, n - 1);\n\n  for(i = 0 ; i < n ; i++) T[b[i]] = i;\n  for(i = 0 ; i < n ; i++){\n    if(V[i]) continue;\n    cur = i;\n    S = 0;\n    m = vMax;\n    an = 0;\n    while(1){\n      V[cur] = 1;\n      an++;\n      v = a[cur];\n\n      if(v < m) m = v;\n\n      S += v;\n      cur = T[v];\n      if(V[cur]) break;\n    }\n    if(S + (an -2) * m < m + S + (an + 1) * s) ans += S + (an -2) * m;\n    else ans +=  m + S + (an + 1) * s;\n  }\n  return ans;\n}\n\n\nint main(){\n  int i;\n\n  scanf(\"%d\", &n);\n  s = vMax;\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\", &a[i]);\n    if(a[i] < s) s = a[i];\n}\n\n  int ans = solve();\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid swap(int* a,int* b){\n  int tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\n\nint n;\nint A[1000];\nint B[1000];\nint vd[1000];\nint cnt,sum,mini;\n\nint min(int x,int y){\n  if(x<y)return x;\n  else return y;\n}\n\nint search(int x){\n  int i;\n  for(i=0;i<n;i++)if(A[i]==x)return i;\n}\n\nint main(){\n  int i,j,ans,x;\n\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n\n  for(i=n-1;i>0;i--)\n    for(j=0;j<i;j++)\n      if(B[j]>B[j+1])swap(&B[j],&B[j+1]);\n  \n  ans=0;\n  for(i=0;i<n;i++)vd[i]=0;\n\n  for(i=0;i<n;i++){   \n    x=i;\n    cnt=sum=0;\n    mini=(1<<24);\n    while(vd[x]==0){\n      vd[x]=1;\n      cnt++;\n      sum+=A[x];\n      mini=min(mini,A[x]);\n      x=search(B[x]);\n    }\n    if(cnt<2)continue;\n    ans+=min(sum+B[0]*(cnt+1)+mini,sum+mini*(cnt-2));\n\n  }\n\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include<stdio.h>\n#include<stdlib.h>\ntypedef struct {\n\tint num;\n\tint index;\n}W;\nint main() {\n\tint  n, i, j, jMin, min, cost = 0, iTmp, tmp,max;\n\tW w[1000],c;\n\tscanf(\"%d\", &n);\n\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &w[i].num);\n\t\tif (i == 0)max = w[i].num;\n\t\telse if (max < w[i].num) max = w[i].num;\n\t}\n\tfor (j=n-1; max >= 0; max--) {\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (max == w[i].num) {\n\t\t\t\tw[i].index = j;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < n-1; i++) {\n\t\t//if (w[i].index == i)continue;\n\t\tmin = w[i].index;\n\t\tjMin = i;\n\t\tfor (j = i; j < n; j++) {\n\t\t\tif(min>w[j].index){\n\t\t\t\tmin = w[j].index;\n\t\t\t\tjMin = j;\n\t\t\t}\n\t\t}\n\t\tif (i != jMin) {\n\t\t\tfor (j = 0; j < n; j++) if (jMin == w[j].index) iTmp = j;\n\t\t\tc = w[iTmp]; w[iTmp] = w[jMin]; w[jMin] = c;\n\t\t\tcost += w[iTmp].num + w[jMin].num;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", cost);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#define MAX 1000\n#define VMAX 10000\n \nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n \nint partition(int A[], int p, int r){\n  int i, j;\n  int x, t;\n  x = A[r];\n  i = p-1;\n  for( j = p ; j < r ; j++ ){\n    if( A[j] <= x ){\n      i++;\n      t = A[i];\n      A[i] = A[j];\n      A[j] = t;\n    }\n  }\n  t = A[i+1];\n  A[i+1] = A[r];\n  A[r] = t;\n  return i + 1;\n}\n \nvoid quickSort(int A[], int p, int r){\n  int q;\n  if( p < r ){\n    q = partition(A, p, r);\n    quickSort(A, p, q-1);\n    quickSort(A, q+1, r);\n  }\n}\n \n \nint solve(){\n  int i, ans = 0;\n \n  int V[MAX];\n  for( i = 0 ; i < n ; i++ ){\n    B[i] = A[i];\n    V[i] = 0;\n  }\n  quickSort(B, 0, n-1);\n  for( i = 0 ; i < n ; i++ ) T[B[i]] = i;\n  for( i = 0 ; i < n ; i++ ){\n    if( V[i] ) continue;\n    int cur = i;\n    int S = 0;\n    int m = VMAX;\n    int an = 0;\n    while( 1 ){\n      V[cur] = 1;\n      an++;\n      int v = A[cur];\n      m = fmin(m, v);\n      S += v;\n      cur = T[v];\n      if( V[cur] ) break;\n    }\n    ans += fmin(S+(an-2)*m, m+S+(an+1)*s);\n  }\n \n  return ans;\n}\n \nint main(){\n  int i;\n  scanf(\"%d\",&n);\n  s = VMAX;\n  for( i = 0 ; i < n ; i++ ){\n    scanf(\"%d\", &A[i]);\n    s = fmin(s, A[i]);\n  }\n  int ans = solve();\n  printf(\"%d\\n\", ans);\n \n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#define MAX 1000\n#define VMAX 10000\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint partition(int A[], int p, int r){\n  int i, j;\n  int x, t;\n  x = A[r];\n  i = p-1;\n  for( j = p ; j < r ; j++ ){\n    if( A[j] <= x ){\n      i++;\n      t = A[i];\n      A[i] = A[j];\n      A[j] = t;\n    }\n  }\n  t = A[i+1];\n  A[i+1] = A[r];\n  A[r] = t;\n  return i + 1;\n}\n\nvoid quickSort(int A[], int p, int r){\n  int q;\n  if( p < r ){\n    q = partition(A, p, r);\n    quickSort(A, p, q-1);\n    quickSort(A, q+1, r);\n  }\n}\n\n\nint solve(){\n  int i, ans = 0;\n\n  int V[MAX];\n  for( i = 0 ; i < n ; i++ ){\n    B[i] = A[i];\n    V[i] = 0;\n  }\n  quickSort(B, 0, n-1);\n  for( i = 0 ; i < n ; i++ ) T[B[i]] = i;\n  for( i = 0 ; i < n ; i++ ){\n    if( V[i] ) continue;\n    int cur = i;\n    int S = 0;\n    int m = VMAX;\n    int an = 0;\n    while( 1 ){\n      V[cur] = 1;\n      an++;\n      int v = A[cur];\n      m = fmin(m, v);\n      S += v;\n      cur = T[v];\n      if( V[cur] ) break;\n    }\n    ans += fmin(S+(an-2)*m, m+S+(an+1)*s);\n  }\n\n  return ans;\n}\n\nint main(){\n  int i;\n  scanf(\"%d\",&n);\n  s = VMAX;\n  for( i = 0 ; i < n ; i++ ){\n    scanf(\"%d\", &A[i]);\n    s = fmin(s, A[i]);\n  }\n  int ans = solve();\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint VAR00 [ 1000 ] [ 2 ] ;\n\nvoid FUNC00 ( int * , int , int ) ;\n\nvoid FUNC01 ( int * , int , int , int ) ;\n\nvoid FUNC02 ( int * , int , int ) ;\n\nlong FUNC03 ( int * , int * , int ) ;\n\nint FUNC04 ( int * , int * , int ) ;\n\nlong FUNC05 ( int * ) ;\n\nlong FUNC06 ( int * , int * , int ) ;\n\nlong FUNC07 ( int * , int * , int , long ) ;\n\nlong FUNC08 ( int * , int * , int ) ;\n\nint main ( )\n{\n  int VAR01 , VAR02 , * VAR03 , * VAR04 ;\n\n  long VAR05 ;\n\n  scanf ( \"%d\" , & VAR02 ) ;\n\n  VAR03 = ( int * ) malloc ( sizeof ( int ) * VAR02 ) ;\n  VAR04 = ( int * ) malloc ( sizeof ( int ) * VAR02 ) ;\n\n  for ( VAR01 = 0 ; VAR01 < VAR02 ; VAR01 ++ )\n    {\n      scanf ( \"%d\" , VAR03 + VAR01 ) ;\n      VAR04 [ VAR01 ] = VAR03 [ VAR01 ] ;\n    }\n\n  FUNC02 ( VAR04 , 0 , VAR02 ) ;\n\n  VAR05 = FUNC08 ( VAR03 , VAR04 , VAR02 ) ;\n  VAR05 += FUNC07 ( VAR03 , VAR04 , VAR02 , 0 ) ;\n\n  printf ( \"%ld\\n\" , VAR05 ) ;\n\n  return 0 ;\n}\n\nvoid FUNC00 ( int * ARG00 , int ARG01 , int ARG02 ) {\n\n  int VAR06 ;\n\n  VAR06 = ARG00 [ ARG01 ] ;\n  ARG00 [ ARG01 ] = ARG00 [ ARG02 ] ;\n  ARG00 [ ARG02 ] = VAR06 ;\n}\n\nvoid FUNC01 ( int * ARG03 , int ARG04 , int ARG05 , int ARG06 ) {\n\n  int VAR07 , VAR08 , * VAR09 , * VAR10 , VAR11 , VAR12 , VAR13 ;\n\n  VAR07 = ARG05 - ARG04 ;\n  VAR08 = ARG06 - ARG05 ;\n  VAR09 = ( int * ) malloc ( sizeof ( int ) * ( VAR07 + 1 ) ) ;\n  VAR10 = ( int * ) malloc ( sizeof ( int ) * ( VAR08 + 1 ) ) ;\n\n  for ( VAR11 = 0 ; VAR11 < VAR07 ; VAR11 ++ ) {\n    VAR09 [ VAR11 ] = ARG03 [ ARG04 + VAR11 ] ;\n  }\n  for ( VAR11 = 0 ; VAR11 < VAR08 ; VAR11 ++ ) {\n    VAR10 [ VAR11 ] = ARG03 [ ARG05 + VAR11 ] ;\n  }\n\n  VAR09 [ VAR07 ] = INT_MAX ; VAR10 [ VAR08 ] = INT_MAX ;\n\n  VAR11 = 0 ;\n  VAR12 = 0 ;\n\n  for ( VAR13 = ARG04 ; VAR13 < ARG06 ; VAR13 ++ )\n    {\n      if ( VAR09 [ VAR11 ] < VAR10 [ VAR12 ] ) {\n ARG03 [ VAR13 ] = VAR09 [ VAR11 ] ;\n VAR11 ++ ;\n      } else {\n ARG03 [ VAR13 ] = VAR10 [ VAR12 ] ;\n VAR12 ++ ;\n      }\n    }\n  free ( VAR09 ) ;\n  free ( VAR10 ) ;\n}\n\nvoid FUNC02 ( int * ARG07 , int ARG08 , int ARG09 ) {\n  if ( ARG08 + 1 < ARG09 )\n    {\n      int VAR14 = ( ARG08 + ARG09 ) / 2 ;\n\n      FUNC02 ( ARG07 , ARG08 , VAR14 ) ;\n      FUNC02 ( ARG07 , VAR14 , ARG09 ) ;\n      FUNC01 ( ARG07 , ARG08 , VAR14 , ARG09 ) ;\n    }\n}\n\nlong FUNC03 ( int * ARG10 , int * ARG11 , int ARG12 ) {\n\n  int VAR15 , VAR16 ;\n\n  long VAR17 = 0 ;\n\n  VAR16 = 0 ;\n\n  while ( ARG10 [ ARG12 ] != ARG11 [ ARG12 ] ) {\n    VAR15 = 0 ;\n    while ( ARG10 [ VAR15 ] != ARG11 [ ARG12 ] ) VAR15 ++ ;\n\n    VAR17 += ARG10 [ ARG12 ] + ARG10 [ VAR15 ] ;\n    FUNC00 ( ARG10 , ARG12 , VAR15 ) ;\n    VAR00 [ VAR16 ] [ 0 ] = ARG12 ;\n    VAR00 [ VAR16 ] [ 1 ] = VAR15 ;\n    ARG12 = VAR15 ;\n    VAR16 ++ ;\n  }\n  VAR00 [ VAR16 ] [ 0 ] = 0 ;\n  VAR00 [ VAR16 ] [ 1 ] = 0 ;\n  return VAR17 ;\n}\n\nint FUNC04 ( int * ARG13 , int * ARG14 , int ARG15 ) {\n\n  int VAR18 , VAR19 ;\n\n  VAR18 = 0 ;\n\n  while ( 1 ) {\n    VAR19 = 0 ;\n    while ( ARG13 [ VAR19 ] != ARG14 [ VAR18 ] ) VAR19 ++ ;\n    if ( VAR18 != VAR19 ) break ;\n    VAR18 ++ ;\n    if ( VAR18 >= ARG15 ) return ARG15 ;\n  }\n  return VAR19 ;\n}\n\nlong FUNC05 ( int * ARG16 ) {\n\n  int VAR20 = 0 ;\n\n  long VAR21 = 0 ;\n\n  while ( VAR00 [ VAR20 ] [ 0 ] != VAR00 [ VAR20 ] [ 1 ] )\n    {\n      VAR21 += ARG16 [ VAR00 [ VAR20 ] [ 0 ] ] + ARG16 [ VAR00 [ VAR20 ] [ 1 ] ] ;\n      FUNC00 ( ARG16 , VAR00 [ VAR20 ] [ 0 ] , VAR00 [ VAR20 ] [ 1 ] ) ;\n      VAR20 ++ ;\n    }\n  return VAR21 ;\n}\n\nlong FUNC06 ( int * ARG17 , int * ARG18 , int ARG19 ) {\n\n  long VAR22 ;\n\n  if ( ARG17 [ 0 ] != ARG18 [ 0 ] ) return LONG_MAX ;\n\n  int VAR23 = 0 ;\n\n  while ( ARG17 [ ARG19 ] != ARG18 [ VAR23 ] ) VAR23 ++ ;\n\n  VAR22 = ARG17 [ ARG19 ] + ARG17 [ 0 ] ;\n  FUNC00 ( ARG17 , ARG19 , 0 ) ;\n  VAR22 += FUNC05 ( ARG17 ) ;\n  VAR22 += ARG17 [ 0 ] + ARG17 [ VAR23 ] ;\n  FUNC00 ( ARG17 , 0 , VAR23 ) ;\n\n  return VAR22 ;\n}\n\nlong FUNC07 ( int * ARG20 , int * ARG21 , int ARG22 , long ARG23 ) {\n\n  int VAR24 ;\n  int VAR25 [ ARG22 ] ;\n  long VAR26 , VAR27 ;\n\n  for ( VAR24 = 0 ; VAR24 < ARG22 ; VAR24 ++ ) {\n    VAR25 [ VAR24 ] = ARG20 [ VAR24 ] ;\n  }\n\n  VAR24 = FUNC04 ( ARG20 , ARG21 , ARG22 ) ;\n\n  if ( VAR24 == ARG22 ) return ARG23 ;\n\n  VAR26 = FUNC03 ( ARG20 , ARG21 , VAR24 ) ;\n  VAR27 = FUNC06 ( VAR25 , ARG21 , VAR24 ) ;\n\n  long VAR28 = ( VAR26 < VAR27 ) ? VAR26 : VAR27 ;\n\n  return FUNC07 ( ARG20 , ARG21 , ARG22 , ARG23 + VAR28 ) ;\n}\n\nlong FUNC08 ( int * ARG24 , int * ARG25 , int ARG26 ) {\n\n  int VAR29 , VAR30 ;\n  long VAR31 = 0 ;\n  char * VAR32 = ( char * ) calloc ( ARG26 , sizeof ( char ) ) ;\n\n  VAR29 = 0 ;\n\n  while ( VAR29 < ARG26 ) {\n    VAR30 = 0 ;\n    while ( ARG24 [ VAR30 ] != ARG25 [ VAR29 ] ) VAR30 ++ ;\n\n    if ( VAR29 != VAR30 ) {\n      if ( ARG25 [ VAR30 ] == ARG24 [ VAR29 ] ) {\n VAR31 += ARG24 [ VAR29 ] + ARG24 [ VAR30 ] ;\n FUNC00 ( ARG24 , VAR29 , VAR30 ) ;\n      }\n    }\n    VAR32 [ VAR29 ] = 1 ;\n    VAR32 [ VAR30 ] = 1 ;\n    while ( VAR29 < ARG26 && VAR32 [ VAR29 ] != 0 ) VAR29 ++ ;\n  }\n  free ( VAR32 ) ;\n  return VAR31 ;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdbool.h>\n#include<math.h>\n#define MAX 1000\n#define VMAX 10000\n\n//static const int MAX = 1000;\n//static const int VMAX = 10000;\n\nint n,A[MAX],s;\nint B[MAX], T[VMAX+1];\n\nvoid swap(int *a,int *b) {\n  int temp;\n  temp = *a;\n  *a = *b;\n  *b = temp;\n}\n\nvoid qsort(int X[], int left, int right){\n  int i,j;\n  int pivot;\n  i=left;j=right;\n  pivot = X[(left+right)/2];\n\n  while(1) {\n    while(X[i]<pivot)i++;\n    while(pivot<X[j])j--;\n    if(i>=j) break;\n\n    swap(&X[i],&X[j]);\n    i++;  j--;\n  }\n  if(left < i-1) qsort(X,left,i-1);\n  if(j+1<right) qsort(X,j+1,right);\n}\n\n\n\nint solve() {\n  int i;\n  int ans = 0;\n\n  bool V[MAX];\n  for(i=0;i<n;i++){\n    B[i] = A[i];\n    V[i]=false;\n  }\n  qsort(B,0,n-1);\n  for(i=0;i<n;i++) T[B[i]] = i;\n  for(i=0;i<n;i++) {\n    if(V[i]) continue;\n    int cur=i;\n    int S=0;\n    int m=VMAX;\n    int an=0;\n    while(1) {\n      V[cur] = true;\n      an++;\n      int v = A[cur];\n      m = fmin(m,v);\n      S+=v;\n      cur=T[v];\n      if(V[cur])break;\n    }\n    ans+=fmin(S+(an - 2) * m , m+S+(an+1)*s);\n\n  }\n  return ans;\n}\n\nint main(){\n  int i;\n  scanf(\"%d\",&n);\n  s=VMAX;\n  for(i=0;i<n;i++) {\n    scanf(\"%d\",&A[i]);\n    s=fmin(s , A[i]);\n  }\n  int ans = solve();\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n  \nint n;\nint a[1000];\nint b[1000];\nint vd[1000];\nint cnt,sum,mini;\n\nvoid swap(int* a,int* b){\n  int tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\n \nint min(int x,int y){\n  if(x<y)return x;\n  else return y;\n}\n  \nint search(int x){\n  int i;\n  for(i=0;i<n;i++)if(a[i]==x)return i;\n}\n  \nint main(){\n  int i,j,ans,x;\n  \n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&a[i]);\n    b[i]=a[i];\n  }\n  \n  for(i=n-1;i>0;i--)\n    for(j=0;j<i;j++)\n      if(B[j]>B[j+1])swap(&b[j],&b[j+1]);\n    \n  ans=0;\n  for(i=0;i<n;i++)vd[i]=0;\n  \n  for(i=0;i<n;i++){   \n    x=i;\n    cnt=sum=0;\n    mini=(1<<24);\n    while(vd[x]==0){\n      vd[x]=1;\n      cnt++;\n      sum+=a[x];\n      mini=min(mini,a[x]);\n      x=search(b[x]);\n    }\n    if(cnt<2)continue;\n    ans+=min(sum+b[0]*(cnt+1)+mini,sum+mini*(cnt-2));\n  \n  }\n  \n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n\n\n\nint n,cost;\nint A[1001],B[1001];\nint L[501],R[502];\n\n\nvoid merge(int left,int mid,int right){\n  int i,j,n1=mid-left,n2=right-mid;\n  for(i=0;i<n1;i++) L[i]=A[left+i];\n  L[n1]=INT_MAX;\n  for(i=0;i<n2;i++) R[i]=A[mid+i];\n  R[n2]=INT_MAX;\n  int l=0,r=0;\n  for(i=left;i<right;i++){\n    if(L[l]<=R[r]){\n      A[i]=L[l];\n      l++;\n    }\n    else{\n      A[i]=R[r];\n      r++;\n    }\n  }\n}\n\n\nvoid m_sort(int left,int right){\n  int mid;\n  if( left+1 >= right) return;\n  mid=(left+right)/2;\n  m_sort(left,mid);\n  m_sort(mid,right);\n  merge(left,mid,right);\n}\n\n\nvoid swap(int a,int b,int *C){\n  int swap;\n  swap=C[a];\n  C[a]=C[b];\n  C[b]=swap;\n}\n\n\n/*??£????????´??????????????°???????????§????°??????????????????¢?????????????????????*/\nint min_search(int *C){\n  int res=n,i;\n  C[n]=INT_MAX;\n  for(i=0;i<n;i++){\n    if(A[i]!=C[i]){\n      if(C[res] >C[i]) res =i;\n    }\n  }\n  return res;\n}\n\n\n\n\n\n\nint quest(int *C,int num,int jud,int nokorii){\n  int D[1001],E[1001],i,x,ans,ans2,judd,nokori;\n  if(jud==n) x=min_search(C);\n  else x=jud;\n  if(x==n) return num;\n  for(i=0;i<n;i++){\n    D[i]=C[i];\n    E[i]=C[i];\n  }\n  i=0;\n  while(1){\n    if(D[i]==A[x]){\n      swap(i,x,D);\n      nokori=nokorii-1;\n      judd=i;\n      if(D[i]==A[i]){\n        judd=n;\n        nokori--;\n      }\n      ans=quest(D,num+D[i]+D[x],judd,nokori);\n      break;\n    }\n    i++;  \n  }\n  if(E[x]!=A[0] && nokorii>=8){\n    swap(0,x,E);\n    nokori=nokorii+2;\n    ans2=quest(E,num+E[0]+E[x],x,nokori);\n    if(ans > ans2) ans=ans2;\n  }\n  return ans;\n}\n  \n \n  \n\nint main(){\n  scanf(\"%d\",&n);\n  int nokori=n;\n  int i,j,min=n;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n  m_sort(0,n);\n  for(i=0;i<n;i++){\n    if(A[i]==B[i]) nokori--;\n  }\n  cost=0;\n  for(i=0;i<n;i++){\n    for(j=i+1;j<n;j++){\n      if(B[i]==A[j]){\n        if(B[j]==A[i]){\n          swap(i,j,B);\n          nokori-=2;\n          cost+=B[i]+B[j];\n        }\n        break;\n      }\n    } \n  }\n  while(1){\n    if(min==n) min=min_search(B);\n    if(B[min]!=A[0]){\n      break;\n    }\n    else{\n      if(min==n) break;\n      for(i=0;i<n;i++){\n        if(A[min]==B[i]){\n          if(min==i){\n            min=n;\n            break;\n          }\n          swap(min,i,B);\n          nokori--;\n          cost+=B[min]+B[i];\n          min=i;\n          break;\n        }\n      }\n    }\n  }\n  cost=quest(B,cost,n,nokori);\n  printf(\"%d\\n\",cost);\n  return 0;\n}\n   \n          \n          \n    "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#define true 1\n#define false 0\n#define MAX 1000\n#define VMAX 10000\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nvoid sort(int C[]){\n\tint flag=1;\n\tint tmp;\n\twhile(flag==1){\n\t\tflag=0;\n\t\tfor(int j=n-1;j>=1;j--){\n\t\t\tif(C[j]<C[j-1]){\n\t\t\t\ttmp=C[j];\n\t\t\t\tC[j]=C[j-1];\n\t\t\t\tC[j-1]=tmp;\n\t\t\t\tflag=1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint min(int a,int b){\n\tif(a<b) return a;\n\telse return b;\n}\n\nint solve(){\n\tint ans=0;\n\tbool V[MAX];\n\tfor(int i=0;i<n;i++){\n\t\tB[i]=A[i];\n\t\tV[i]=false;\n\t}\n\tsort(B);\n\tfor(int i=0;i<n;i++)T[B[i]]=i;\n\tfor(int i=0;i<n;i++){\n\t\tif(V[i])continue;\n\t\tint cur=i;\n\t\tint S=0;\n\t\tint m=VMAX;\n\t\tint an=0;\n\t\twhile(1){\n\t\t\tV[cur]=true;\n\t\t\tan++;\n\t\t\tint v=A[cur];\n\t\t\tm=min(m,v);\n\t\t\tS+=v;\n\t\t\tcur=T[v];\n\t\t\tif(V[cur])break;\n\t\t}\n\t\tans+=min(S+(an-2)*m,m+S+(an+1)*s);\n\t}\n\treturn ans;\n}\n\nint main(void){\n\n\tscanf(\"%d\",&n);\n\ts=VMAX;\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&A[i]);\n\t\ts=min(s,A[i]);\n\t}\n\tint ans=solve();\n\tprintf(\"%d\\n\",ans);\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define W_MAX 1000001\n#define MAX 1001\n\nint array[MAX];\nint sorted[MAX];\n\nvoid swap(int* a, int* b){\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nint greedy(int n){\n  int i, j;\n  int min = W_MAX, min_pos = -1;\n  int next = -1, next_pos = -1;\n\n  int addition = 0;\n  for(i = 0; i < n; i++){\n    if(array[i] == 0){ continue; }\n\n    for(j = i + 1; j < n; j++){\n      if(array[j] == 0) { continue; }\n\n      if(sorted[i] == array[j] && sorted[j] == array[i]){\n\tswap(&array[i], &array[j]);\n\taddition += (array[i] + array[j]);\n      }\n    }\n  }\n\n  for(i = 0; i < n; i++){\n    if(array[i] == 0 || sorted[i] != array[i] && min > array[i]){\n      min = array[i];\n      min_pos = i;\n    }\n  }\n\n  if(min_pos == -1){\n    return 0;\n  }\n\n  if(min == 0 && min_pos == 0){\n    next = W_MAX;\n    \n    for(i = 0; i < n; i++){\n      if(i != min_pos && sorted[i] != array[i] && next > array[i]){\n\tnext = array[i];\n\tnext_pos = i;\n      }\n    }\n  }else{\n    next = sorted[min_pos];\n    \n    for(i = 0; i < n; i++){\n      if(array[i] == next){\n\tnext_pos = i;\n\tbreak;\n      }\n    }\n  }\n\n  if(next_pos == -1){\n    return 0;\n  }\n\n  swap(&array[min_pos], &array[next_pos]);\n  /*\n  for(i = 0; i < n; i++){\n    printf(\"%s%d\", i == 0 ? \"\" : \" \", array[i]);\n  }\n  printf(\"\\n\");\n  */\n  return (next + min) + greedy(n) + addition;\n}\n\nint main(int argc, char* argv[]){\n  int i, j, n;\n  scanf(\"%d\", &n);\n\n  for(i = 0; i < n; i++){\n    scanf(\"%d\", &array[i]);\n    sorted[i] = array[i];\n  }\n  \n  for(i = 0; i < n; i++){\n    int min = sorted[i];\n    int min_pos = i;\n    \n    for(j = i + 1; j < n; j++){\n      if(min > sorted[j]){\n\tmin = sorted[j];\n\tmin_pos = j;\n      }\n    }\n\n    if(min_pos != i){\n      swap(&sorted[i], &sorted[min_pos]);\n    }\n  }\n\n\n  printf(\"%d\\n\", greedy(n));\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n \nvoid swap(int* a,int* b){\n  int tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\n \nint n;\nint A[1000];\nint B[1000];\nint vd[1000];\nint cnt,sum,mini;\n \nint min(int x,int y){\n  if(x<y)return x;\n  else return y;\n}\n \nint search(int x){\n  int i;\n  for(i=0;i<n;i++)if(A[i]==x)return i;\n}\n \nint main(){\n  int i,j,ans,x;\n \n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n \n  for(i=n-1;i>0;i--)\n    for(j=0;j<i;j++)\n      if(B[j]>B[j+1])swap(&B[j],&B[j+1]);\n   \n  ans=0;\n  for(i=0;i<n;i++)vd[i]=0;\n \n  for(i=0;i<n;i++){   \n    x=i;\n    cnt=sum=0;\n    mini=(1<<24);\n    while(vd[x]==0){\n      vd[x]=1;\n      cnt++;\n      sum+=A[x];\n      mini=min(mini,A[x]);\n      x=search(B[x]);\n    }\n    if(cnt<2)continue;\n    ans+=min(sum+B[0]*(cnt+1)+mini,sum+mini*(cnt-2));\n \n  }\n \n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#define N 200001\n\n#define MAX 1000\n#define MAXWEIGHTIJ 20000\n\nstruct MC {\n\tint cost,order;\n};\n\nvoid exchange( struct MC *px, struct MC *py )\n{\n  struct MC t;\n\tt=*px;\n\t*px=*py;\n\t*py=t;\n}\n\nint Partition( struct MC A[], int p, int r )\n{\n\n    struct MC x;\n    int i=p-1;\n    x=A[r];\n\n    int j;\n\n    for( j=p; j<r; j++ ) {\n        if( A[j].cost < x.cost ) {\n            i++;\n            exchange( &A[i], &A[j] );\n         }\n    }\n    exchange( &A[i+1], &A[r]);\n    return i+1;\n}\nvoid QuickSort( struct MC A[], int p, int r )\n{\n    int q;\n    if( p < r ) {\n        q=Partition( A, p, r );\n        QuickSort( A, p, q-1 );\n        QuickSort( A, q+1, r );\n    }\n    return;\n}\n\nint tryChange( int n, struct MC W[] )\n{\n\tint cnt, fixedcost,pro, from, to, togoal,cost,lowestCost,i,j,lowW,lowestW,low,high,lowest;\n\tlowestW=lowW=lowestCost=cost=MAXWEIGHTIJ;\n\tlowest=high=low=-1;\n\tfor( i=0; i<n; i++ ) {\n\t\tif( i != W[i].order && W[i].cost < lowW ) {\n\t\t\tlowW=W[i].cost;\n\t\t\tlow=i;\n\t\t\tfor( j=0; j<n; j++ ) {\n\t\t\t\tif( low == W[j].order ) {\n\t\t\t\t\thigh=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( W[i].cost < lowestW ) {\n\t\t\tlowestW=W[i].cost;\n\t\t\tlowest=i;\n\t\t}\n\t}\n\n\tif( W[high].order == low && W[low].order == high ) {\n\t\tlowestCost = W[low].cost + W[high].cost;\n\t  }\n    else if( low != lowest ) {\n\t\tfixedcost = W[low].cost + W[lowest].cost;\n\t\tpro = W[low].cost - W[lowest].cost;\n\t\tfrom=high;\n\t\tto=low;\n\t\ttogoal = W[low].order;\n\t\tcnt=0;\n\t\twhile( 1 ) {\n\t\t\tif( W[from].order == to ) {\n\t\t\t\tif( togoal == to ) { break; }\n\t\t\t\tto=from;\n\t\t\t\tcnt++;\n\t\t\t}\n      else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor( i=0; i<n; i++ ) {\n\t\t\t\tif( i != W[i].order ) {\n\t\t\t\t\tif( to == W[i].order ) {\n\t\t\t\t\t\tfrom=i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpro = ( pro * cnt ) - ( 2 * fixedcost );\n\n\t\tif( 0 < pro ) {\n\t\t\thigh=low;\n\t\t\tlow=lowest;\n\t\t\tlowestCost = fixedcost;\n\t\t}\n\t}\n\n\tif( W[high].order == low ) {\n\t\tlowestCost = W[low].cost + W[high].cost;\n\t}\n\n    if( MAXWEIGHTIJ != lowestCost ) {\n\t\texchange( &W[low], &W[high] );\n\t  }\n    else {\n    \tlowestCost=0;\n    }\n\treturn lowestCost;\n}\n\n\nint main( void )\n{\n    int n,i,cost;\n    struct MC W[MAX+1];\n\n    scanf( \"%d\", &n );\n    for( i=0; i<n; i++ ) {\n        scanf( \"%d\", &W[i].cost );\n        W[i].order=i;\n    }\n\tQuickSort( W, 0, n-1 );\n\tcost=i=0;\n\twhile( (i = tryChange( n, W ) ) ) {\n\t\tcost+=i;\n\t}\n\tprintf( \"%d\\n\", cost );\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define Max  1000\n#define vMax 10000\n\nint n, a[Max], s;\nint b[Max], T[vMax + 1];\n\n\nint partition(int a[], int p, int r){\n  int i, j;\n  int t, x;\n  x = a[r];\n  i = p - 1;\n\n  for(j = p ; j < r ; j++){\n    if(a[j] <= x){\n      i++;\n      t = a[i];\n      a[i] = a[j];\n      a[j] = t;\n    }\n  }\n\n  t = a[i + 1];\n  a[i + 1] = a[r];\n  a[r] = t;\n\n  return i + 1;\n}\n\nvoid quickSort(int a[], int p, int r){\n  int q;\n  if(p < r){\n    q = partition(a, p, r);\n    quickSort(a, p, q - 1);\n    quickSort(a, q + 1, r);\n  }\n}\n\n\n\nint solve(){\n  int i,ans = 0, cur, S, m, an, v;\n\n  int V[Max];\n  for(i = 0 ; i < n ; i++){\n    b[i] = a[i];\n    V[Max] = 0;\n  }\n\n  quickSort(b, 0, n - 1);\n\n  for(i = 0 ; i < n ; i++) t[b[i]] = i;\n  for(i = 0 ; i < n ; i++){\n    if(V[i]) continue;\n    cur = i;\n    S = 0;\n    m = vMax;\n    an = 0;\n    while(1){\n      V[cur] = 1;\n      an++;\n      v = a[cur];\n\n      if(v < m) m = v;\n\n      S += v;\n      cur = T[v];\n      if(V[cur]) break;\n    }\n    if(S + (an -2) * m < m + S + (an + 1) * s) ans += S + (an -2) * m;\n    if(S + (an -2) * m > m + S + (an + 1) * s) ans +=  m + S + (an + 1) * s;\n  }\n  return ans;\n}\n\n\nint main(){\n  int i;\n\n  scanf(\"%d\", &n);\n  s = vMax;\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\", &a[i]);\n    if(a[i] < s) s = a[i];\n}\n\n  int ans = solve();\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid swap(int* a,int* b){\n  int tmp=*a;\n  *a=*b;\n  *b=tmp;\n}\n\nint n;\nint A[1000];\nint B[1000];\n\nint search(int x){\n  int i;\n  for(i=0;i<n;i++){\n    if(A[i]==x)return i;\n  }\n}\n\nint main(){\n  int i,j,ans,x,y;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n  \n  for(i=n-1;i>0;i--){\n    for(j=0;j<i;j++){\n      if(B[j]>B[j+1])swap(&B[j],&B[j+1]);\n    }\n  }\n \n  ans=0;\n  \n  while(1){\n    x=10001;\n    for(i=0;i<n;i++){\n      if(A[i]==B[i])continue;\n      if(x>A[i])x=A[i];\n    }\n    if(x==10001)break;\n\n    x=search(x);\n    y=search(B[x]);\n\n    swap(&A[x],&A[y]);\n    ans+=(A[x]+A[y]);\n  }\n  printf(\"%d\\n\",ans);\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 10001\ntypedef struct {\n  int sum;\n  int flag;\n} CC;\nCC C[N];\nint A[1000],B[1000];\nint main()\n{\n  int i,n,min=0,m,k,now,sum=0,minx;\n  scanf(\"%d\",&n);\n  for(i=1;i<n+1;i++){\n    scanf(\"%d\",&A[i]);\n  }\n  minx=A[1];\n  for(i=2;i<n+1;i++){\n    if(minx>A[i])minx=A[i];\n  }\n  for(i=0;i<N;i++){\n    C[i].sum=0;\n    C[i].flag=0;\n  }\n  for(i=1;i<n+1;i++){\n    C[A[i]].sum+=1;\n    C[A[i]].flag+=1;\n  }\n  for(i=0;i<N;i++){\n    C[i].sum+=C[i-1].sum;\n  }\n\n  for(i=n+1;i>0;i--){\n    if(C[A[i]].flag==1){\n      k=i;\n      now=k;\n      m=0;\n      B[C[A[k]].sum]=A[k];\n      C[A[i]].flag=0;\n      min=A[k];\n      k=C[A[k]].sum;\n      while(A[now]!=A[k]){\n        if(m==0){\n          sum+=A[now];\n\t  //printf(\"%d \",A[now]);\n        }\n        //printf(\"%d \",A[k]);\n        B[C[A[k]].sum]=A[k];\n        C[A[k]].flag=0;\n        sum+=A[k];\n        if(min>A[k])min=A[k];\n        k=C[A[k]].sum;\n        m+=1;\n      }\n      if(m>1)sum+=min+(m-2)*minx;\n      m=0;\n      min=0;\n    }\n  }\n  /* printf(\"\\n\");\n  for(i=1;i<n;i++){\n    printf(\"%d \",B[i]);\n  }\n  printf(\"%d\",B[i]);*/\n  printf(\"%d\\n\",sum);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<time.h>\n#include<math.h>\n#define MAX 2010\n#define Ai 10000\nint A[MAX],B[MAX],C[Ai+10]={0},book[MAX];\nint n;\nvoid swap(int x,int y)\n{\n\tint t=A[x];\n\tA[x]=A[y];\n\tA[y]=t;\n\treturn;\n}\nvoid countingsort()\n{\n\tint i;\n\tfor(i=1;i<=n;i++)\n\t\tC[A[i]]++;\n\tfor(i=1;i<=Ai;i++)\n\t\tC[i]=C[i]+C[i-1];\n\tfor(i=n;i>=1;i--)\n\t{\n\t\tB[C[A[i]]]=A[i];\n\t\tbook[i]=C[A[i]];\n\t\tC[A[i]]--;\n\t}\n\treturn;\n}\nint circlecost(int start,int rn)//start是圆的起始点(可以是圆中的任意点),rn是圆中的点数\n{\n\tif(rn==1)\n\t\treturn 0;\n\tif(rn==2)\n\t\treturn A[start]+A[book[start]];\n\n\t//初始化\n\tint min=start,minA=1,i,h,j,cnt1=0,cnt2=0,k;\n\tint a[MAX];\n\tfor(i=1;i<=n;i++)\n\t\ta[i]=A[i];\n\tj=1;\n\tfor(i=start;;i=book[i])\n\t{\n\t\tif(j>rn)\n\t\t\tbreak;\n\t\tif(A[min]>A[i])\n\t\t\tmin=i;\n\t\tj++;\n\t}\n\t//情况1:不借元素\n\tj=1;\n\tfor(i=start;j<=rn-1;i=book[i])\n\t{\n\t\tfor(k=1;k<=n;k++)\n\t\t\tif(book[k]==min)\n\t\t\t{\n\t\t\t\th=k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tswap(min,h);\n\t\tif(min!=h)\n\t\t\tcnt1=cnt1+A[min]+A[h];\n\t\tmin=h;\n\t\tj++;\n\t}\n\t//还原\n\tfor(i=1;i<=n;i++)\n\t\tA[i]=a[i];\n\tj=1;\n\tfor(i=start;;i=book[i])\n\t{\n\t\tif(j>rn)\n\t\t\tbreak;\n\t\tif(A[min]>A[i])\n\t\t\tmin=i;\n\t\tj++;\n\t}\n\tfor(i=1;i<=n;i++)\n\t\tif(A[minA]>A[i])\n\t\t\tminA=i;\n\t//情况2:借整体最小元素\n\tif(min!=minA)\n\t{\n\t\tswap(min,minA);\n\t\tif(min!=minA)\n\t\t\tcnt2=cnt2+A[min]+A[minA];\n\t\tj=1;\n\t\tfor(i=start;j<=rn-1;i=book[i])\n\t\t{\n\t\t\tfor(k=1;k<=n;k++)\n\t\t\t\tif(book[k]==min)\n\t\t\t\t{\n\t\t\t\t\th=k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tswap(min,h);\n\t\t\tif(min!=h)\n\t\t\t\tcnt2=cnt2+A[min]+A[h];\n\t\t\tmin=h;\n\t\t\tj++;\n\t\t}\n\t\tswap(min,minA);\n\t\tif(min!=minA)\n\t\t\tcnt2=cnt2+A[min]+A[minA];\n\t}\n\telse\n\t\tcnt2=cnt1+1;\n\t//比较\n\tif(cnt1<cnt2)\n\t\treturn cnt1;\n\treturn cnt2;\n}\nint mincost()\n{\n\tcountingsort();\n\n\n\tint book2[MAX]={0},i,t,j,circlen,cnt=0;\n\tfor(i=1;i<=n;i++)\n\t\tif(book2[i]==0)\n\t\t{\n\t\t\tcirclen=1;\n\t\t\tfor(j=i;;)\n\t\t\t{\n\t\t\t\tbook2[j]=1;\n\t\t\t\tj=book[j];\n\t\t\t\tif(j==i)\n\t\t\t\t\tbreak;\n\t\t\t\tcirclen++;\n\t\t\t}\n\t\t\tcnt+=circlecost(i,circlen);\n\t\t}\n\treturn cnt;\n}\nint main()\n{\n\tint i;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%d\",&A[i]);\n\tprintf(\"%d\\n\",mincost());\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdbool.h>\n#define MAX 1000\n#define VMAX 10000\n\nint n,A[MAX],s;\nint B[MAX],T[VMAX+1];\n\n\nvoid sort(int A[]){\n\tint flag = 1;\n\tint tmp;\n\twhile(flag == 1){\n\t\tflag = 0;\n\t\tfor(int j = n-1; j >= 1; j--){\n\t\t\tif(A[j] < A[j-1]){\n\t\t\t\ttmp = A[j];\n\t\t\t\tA[j] = A[j-1];\n\t\t\t\tA[j-1] = tmp;\n\t\t\t\tflag = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint min(int a, int b){\n\tif(a < b)return a;\n\telse return b;\n}\n\nint solve(){\n\tint ans=0;\n\n\t\n\tbool V[MAX];\n\tfor(int i = 0;i < n;i++){\n\tB[i] = A[i];\n\tV[i] = false;\n\t}\n\n\tsort(B);\n\tfor(int i = 0; i< n; i++){\n\t\tT[B[i]] = i;\n\t}\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tif(V[i]){continue;}\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an=0;\n\t\twhile(1){\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m, v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif(V[cur]){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tans += min(S + (an - 2) * m, m + S + (an + 1) * s);\n\n}\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\ts = VMAX;\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &A[i]);\n\t\ts = min(s, A[i]);\n\t}\n\tint ans = solve();\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint solve(int A[]);\nint min(int a,int b);\nvoid sort(int B[]);\n#define MAX 10000\nint A[MAX],B[MAX],T[MAX+1];\nint n,s;\n\nint main(void){\n\tint i;\n\tscanf(\"%d\",&n);\n\tint A[n];\n\ts=MAX;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&A[i]);\n\t\ts=min(s,A[i]);\n\t}\n\t\n\tint ans=solve(A);\n\t\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n\nint solve(int A[]){\n\t\n\tint ans=0;\n\tint V[MAX];\n\tfor(int i=0;i<n;i++){\n\t\tB[i]=A[i];\n\t\tV[i]=0;\n\t}\n\t\n\tsort(B);\n\t\n\tfor(int i=0;i<n;i++){\n\t\tT[B[i]]=i;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(V[i]==1){\n\t\t\tcontinue;\n\t\t}\n\t\tint cur=i;\n\t\tint S=0;\n\t\tint m=MAX;\n\t\tint an=0;\n\t\t\n\t\twhile(1){\n\t\t\tV[cur]=1;\n\t\t\tan++;\n\t\t\tint v=A[cur];\n\t\t\tm=min(m,v);\n\t\t\tS+=v;\n\t\t\tcur=T[v];\n\t\t\tif(V[cur]){\n\t\t\t\tbreak; \n\t\t\t}\n\t\t}\n\t\tans+=min(S+(an-2)*m,m+S+(an+1)*s);\n\t\t\n\t}\n\t\n\treturn ans;\n\t\n}\n\nint min(int a,int b){\n    if(a<b){\n    \treturn a;\n    }\n    return b;\n}\n\nvoid sort(int A[]){\n\tint f=1;\n\tint tmp;\n\twhile(f==1){\n\t\tf = 0;\n\t\tfor(int j=n-1;j>=1;j--){\n\t\t\tif(A[j]<B[j-1]){\n\t\t\t\ttmp=A[j-1];\n\t\t\t\tA[j-1]=A[j];\n\t\t\t\tA[j]=tmp;\n\t\t\t\tf=1;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define Max  1000\n#define vMax 10000\n\nint n, a[Max], s;\nint b[Max], T[vMax + 1];\n\n\nint partition(int a[], int p, int r){\n  int i, j;\n  int t, x;\n  x = a[r];\n  i = p - 1;\n\n  for(j = p ; j < r ; j++){\n    if(a[j] <= x){\n      i++;\n      t = a[i];\n      a[i] = a[j];\n      a[j] = t;\n    }\n  }\n\n  t = a[i + 1];\n  a[i + 1] = a[r];\n  a[r] = t;\n\n  return i + 1;\n}\n\nvoid quickSort(int a[], int p, int r){\n  int q;\n  if(p < r){\n    q = partition(a, p, r);\n    quickSort(a, p, q - 1);\n    quickSort(a, q + 1, r);\n  }\n}\n\n\n\nint solve(){\n  int i,ans = 0, cur, S, m, an, v;\n\n  int V[Max];\n  for(i = 0 ; i < n ; i++){\n    b[i] = a[i];\n    V[Max] = 0;\n  }\n\n  quickSort(b, 0, n - 1);\n\n  for(i = 0 ; i < n ; i++) t[b[i]] = i;\n  for(i = 0 ; i < n ; i++){\n    if(V[i]) continue;\n    cur = i;\n    S = 0;\n    m = vMax;\n    an = 0;\n    while(1){\n      V[cur] = 1;\n      an++;\n      v = a[cur];\n\n      if(v < m) m = v;\n\n      S += v;\n      cur = T[v];\n      if(V[cur]) break;\n    }\n    if(S + (an -2) * m < m + S + (an + 1) * s) ans += S + (an -2) * m;\n    if(S + (an -2) * m > m + S + (an + 1) * s) ans +=  m + S + (an + 1) * s;\n  }\n  return ans;\n}\n\n\nint main(){\n  int i;\n\n  scanf(\"%d\", &n);\n  s = vMax;\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\", &a[i]);\n    if(a[i] < s) s = a[i];\n}\n\n  int ans = solve();\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint n;\n\nint search(int *A, int w);\n\nint main(int argc, char *argv[])\n{\n  int i, j, k, l, t;\n  int *A, *R, *g, tmp, minj;\n  int cost = 0;\n\n  scanf(\"%d\", &n);\n  A = (int *)malloc(sizeof(int) * n);\n  R = (int *)malloc(sizeof(int) * n);\n  g = (int *)malloc(sizeof(int) * n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &A[i]);\n    R[i] = A[i];\n    g[i] = 0;\n  }\n\n  for (i = 0; i < n; i++) {\n    minj = i;\n    for (j = i; j < n; j++) {\n      if (R[minj] > R[j]) minj = j;\n    }\n    tmp = R[minj];\n    R[minj] = R[i];\n    R[i] = tmp;\n  }\n\n  for (i = 0; i < n; i++) {\n    if (A[i] == R[i]) continue;\n\n    minj = i;\n    g[0] = i;\n    k = 1;\n    j = i;\n    while (A[j] != R[i]) {\n      j = search(R, A[j]);\n      if (A[j] < A[minj]) minj = j;\n      g[k++] = j;\n    }\n    l = search(g, minj);\n    for (j = k; j > 1; j--) {\n      t = (l + j - 1) % k;\n      cost += A[g[t]] + A[g[t+1]];\n      tmp = A[g[t+1]];\n      A[g[t+1]] = A[g[t]];\n      A[g[t]] = tmp;\n    }\n  }\n\n  printf(\"%d\\n\", cost);\n\n  return 0;\n}\n\nint search(int *A, int w)\n{\n  int i;\n  int found;\n\n  found = 0;\n  for (i = 0; i < n; i++) {\n    if (A[i] == w) {\n      found = 1;\n      break;\n    }\n  }\n\n  if (found == 1) return i;\n  else return -1;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n\n\n\nint n,cost;\nint A[1001],B[1001];\nint L[501],R[502];\n\n\nvoid merge(int left,int mid,int right){\n  int i,j,n1=mid-left,n2=right-mid;\n  for(i=0;i<n1;i++) L[i]=A[left+i];\n  L[n1]=INT_MAX;\n  for(i=0;i<n2;i++) R[i]=A[mid+i];\n  R[n2]=INT_MAX;\n  int l=0,r=0;\n  for(i=left;i<right;i++){\n    if(L[l]<=R[r]){\n      A[i]=L[l];\n      l++;\n    }\n    else{\n      A[i]=R[r];\n      r++;\n    }\n  }\n}\n\n\nvoid m_sort(int left,int right){\n  int mid;\n  if( left+1 >= right) return;\n  mid=(left+right)/2;\n  m_sort(left,mid);\n  m_sort(mid,right);\n  merge(left,mid,right);\n}\n\n\nvoid swap(int a,int b,int *C){\n  int swap;\n  swap=C[a];\n  C[a]=C[b];\n  C[b]=swap;\n}\n\n\n/*??£????????´??????????????°???????????§????°??????????????????¢?????????????????????*/\nint min_search(int *C){\n  int res=n,i;\n  C[n]=INT_MAX;\n  for(i=0;i<n;i++){\n    if(A[i]!=C[i]){\n      if(C[res] >C[i]) res =i;\n    }\n  }\n  return res;\n}\n\n\n\n\n\n\nint quest(int *C,int num,int jud){\n  int D[1001],E[1001],i,x,ans,ans2,judd;\n  if(jud==n) x=min_search(C);\n  else x=jud;\n  if(x==n) return num;\n  for(i=0;i<n;i++) D[i]=C[i];\n  i=0;\n  while(1){\n    if(D[i]==A[x]){\n      swap(i,x,D);\n      judd=i;\n      if(D[i]==A[i]) judd=n;\n      ans=quest(D,num+D[i]+D[x],judd);\n      break;\n    }\n    i++;  \n  }\n  if(C[x]!=A[0]){\n    for(i=0;i<n;i++) E[i]=C[i];\n    swap(0,x,E);\n    ans2=quest(E,num+E[0]+E[x],x);\n    if(ans > ans2) ans=ans2;\n  }\n  return ans;\n}\n  \n \n  \n\nint main(){\n  scanf(\"%d\",&n);\n  int i,j,min=n;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n  m_sort(0,n);\n  cost=0;\n  for(i=0;i<n;i++){\n    for(j=i+1;j<n;j++){\n      if(B[i]==A[j]){\n        if(B[j]==A[i]){\n          swap(i,j,B);\n          cost+=B[i]+B[j];\n        }\n        break;\n      }\n    } \n  }\n  while(1){\n    if(min==n) min=min_search(B);\n    if(B[min]!=A[0]){\n      break;\n    }\n    else{\n      if(min==n) break;\n      for(i=0;i<n;i++){\n        if(A[min]==B[i]){\n          if(min==i){\n            min=n;\n            break;\n          }\n          swap(min,i,B);\n          cost+=B[min]+B[i];\n          min=i;\n          break;\n        }\n      }\n    }\n  }\n  cost=quest(B,cost,n);\n  printf(\"%d\\n\",cost);\n  return 0;\n}\n   \n          \n          \n    "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define MAX 1000\n#define WEIGHT 10000\n\nint n,A[MAX],s,B[MAX],T[WEIGHT+1];\n\nint partition(int A[],int p,int r){\n  int i,j,m,k;\n  m=A[r];\n  i=p-1;\n  for(j=p;j<r;j++){\n    if(A[j]<=m){\n      i=i+1;\n      k=A[i];\n      A[i]=A[j];\n      A[j]=k;\n    }\n  }\n  k=A[i+1];\n  A[i+1]=A[r];\n  A[r]=k;\n  return i+1;\n}\n\nvoid quickSort(int A[],int p,int r){\n  int q;\n  if(p<r){\n    q=partition(A,p,r);\n    quickSort(A,p,q-1);\n    quickSort(A,q+1,r);\n  }\n}\n\nint solve(){\n  int i,S,c,an,a=0,m,v;\n  int W[MAX];\n\n  for(i=0;i<n;i++){\n    B[i]=A[i];\n    W[i]=0;\n  }\n  quickSort(B,0,n-1);\n  for(i=0;i<n;i++){\n    T[B[i]]=i;\n  }\n  for(i=0;i<n;i++){\n    if(W[i])continue;\n    c=i;\n    S=0;\n    m=WEIGHT;\n    an=0;\n    while(1){\n      W[c]=1;\n      an++;\n      v=A[c];\n      m=fmin(m,v);\n      S+=v;\n      c=T[v];\n      if(W[c])break;\n    }\n    a+=fmin(S+(an-2)*m,m+S+(an+1)*s);\n  }\n  return a;\n}\n\nint main(){\n  int i,a;\n\n  scanf(\"%d\",&n);\n  s=WEIGHT;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    s=fmin(s,A[i]);\n  }\n  a=solve();\n  printf(\"%d\\n\",a);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX_N  1000\n\nvoid QuickSort(int, int);\nint Partition(int, int);\nint MinimumCost(int);\n\nstruct rist\n{\n  int n;\n  int p;\n} typedef rist;\n\nrist A[MAX_N];\n\nint main()\n{\n\tint i;\n\tint n;\n\tint cost;\n\t\n\tscanf(\"%d\", &n);\n\tfor(i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &A[i].n);\n\t\tA[i].p = i;\n\t}\n\t\n\tQuickSort(0, n - 1);\n\tcost = MinimumCost(n);\n\t\n\tprintf(\"%d\\n\", cost);\n\t\n\treturn 0;\n}\n\nvoid QuickSort(int p, int r)\n{\n\tint q;\n\n\tif(p < r)\n    {\n      q = Partition(p, r);\n      QuickSort(p, q - 1);\n      QuickSort(q + 1, r);\n    }\n}\n\nint Partition(int p, int r)\n{\n\tint i, j;\n\trist tmp;\n\n\ti = p - 1;\n\tfor(j = p; j < r; j++)\n    {\n    \tif(A[j].n < A[r].n)\n\t\t{\n\t \t\ti = i + 1;\n\t \t\ttmp = A[i];\n\t  \t\tA[i] = A[j];\n\t  \t\tA[j] = tmp;\n\t\t}\n    }\n\ttmp = A[i + 1];\n  \tA[i + 1] = A[r];\n  \tA[r] = tmp;\n  \n  \treturn i + 1;\n}\n\nint MinimumCost(int n)\n{\n\tint i;\n\tint tmp;\n\tint cost;\n\t\n\tfor(i = n - 1; i >= 0; i--)\n\t{\n\t\tif(A[i].p != i)\n\t\t{\n\t\t\tcost += A[i].n + A[A[i].p].n;\n\n\t\t\ttmp = A[A[i].p].p;\n\t\t\tA[A[i].p].p = A[i].p;\n\t\t\tA[i].p = tmp;\n\t\t}\n\t}\n\treturn cost;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint partition(int [], int, int);\nvoid quicksort(int [], int, int);\n\nint main(){\n  int n, i, j, sum = 0, temp;\n  int w[1000], v[1000];\n\n  scanf(\"%d\", &n);\n  for(i=0; i<n; i++){\n    scanf(\"%d\", &w[i]);\n    v[i] = w[i];\n  }\n\n  quicksort(w, 0, n-1);\n\n  for(i = 0; i < n; i++){\n    if(v[i] != w[i]){\n      for(j = i+1; j < n; j++){\n\tif(v[j] == w[i]){\n\t  temp = v[i];\n\t  v[i] = v[j];\n\t  v[j] = temp;\n\t  sum += v[i] + v[j];\n\t  break;\n\t}\n      }\n    }\n  }\n\n  printf(\"%d\\n\", sum);\n  \n  return 0;\n}\n\nint partition(int A[], int p, int r){\n  int x, i, j;\n  int temp;\n  x = A[r];\n  i = p-1;\n  for(j=p; j<r; j++){\n    if(A[j] <= x){\n      i++;\n      temp = A[i];\n      A[i] = A[j];\n      A[j] = temp;\n    }\n  }\n  temp = A[i+1];\n  A[i+1] = A[r];\n  A[r] = temp;\n  \n  return i+1;\n}\n\nvoid quicksort(int A[], int p, int r){\n  int q;\n  if(p < r){\n    q = partition(A, p, r);\n    quicksort(A, p, q-1);\n    quicksort(A, q+1, r);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdbool.h>\n#include<math.h>\n#define MAX 1000;\n#define VMAX 10000;\n\n//static const int MAX = 1000;\n//static const int VMAX = 10000;\n\nint n,A[MAX],s;\nint B[MAX], T[VMAX+1];\n\nvoid swap(int *a,int *b) {\n  int temp;\n  temp = *a;\n  *a = *b;\n  *b = temp;\n}\n\nvoid qsort(int X[], int left, int right){\n  int i,j;\n  int pivot;\n  i=left;j=right;\n  pivot = X[(left+right)/2];\n\n  while(1) {\n    while(X[i]<pivot)i++;\n    while(pivot<X[j])j--;\n    if(i>=j) break;\n\n    swap(&X[i],&X[j]);\n    i++;  j--;\n  }\n  if(left < i-1) qsort(X,left,i-1);\n  if(j+1<right) qsort(X,j+1,right);\n}\n\n\n\nint solve() {\n  int i;\n  int ans = 0;\n\n  bool V[MAX];\n  for(i=0;i<n;i++){\n    B[i] = A[i];\n    V[i]=false;\n  }\n  qsort(B,0,n-1);\n  for(i=0;i<n;i++) T[B[i]] = i;\n  for(i=0;i<n;i++) {\n    if(V[i]) continue;\n    int cur=i;\n    int S=0;\n    int m=VMAX;\n    int an=0;\n    while(1) {\n      V[cur] = true;\n      an++;\n      int v = A[cur];\n      m = fmin(m,v);\n      S+=v;\n      cur=T[v];\n      if(V[cur])break;\n    }\n    ans+=fmin(S+(an - 2) * m , m+S+(an+1)*s);\n\n  }\n  return ans;\n}\n\nint main(){\n  int i;\n  scanf(\"%d\",&n);\n  s=VMAX;\n  for(i=0;i<n;i++) {\n    scanf(\"%d\",&A[i]);\n    s=fmin(s , A[i]);\n  }\n  int ans = solve();\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n\n\n\nint n,cost,cnt;\nint A[1001],B[1001];\nint L[501],R[502];\n\n\nvoid merge(int left,int mid,int right){\n  int i,j,n1=mid-left,n2=right-mid;\n  for(i=0;i<n1;i++) L[i]=A[left+i];\n  L[n1]=INT_MAX;\n  for(i=0;i<n2;i++) R[i]=A[mid+i];\n  R[n2]=INT_MAX;\n  int l=0,r=0;\n  for(i=left;i<right;i++){\n    if(L[l]<=R[r]){\n      A[i]=L[l];\n      l++;\n    }\n    else{\n      A[i]=R[r];\n      r++;\n    }\n  }\n}\n\n\nvoid m_sort(int left,int right){\n  int mid;\n  if( left+1 >= right) return;\n  mid=(left+right)/2;\n  m_sort(left,mid);\n  m_sort(mid,right);\n  merge(left,mid,right);\n}\n\n\nvoid swap(int a,int b,int *C){\n  int swap;\n  swap=C[a];\n  C[a]=C[b];\n  C[b]=swap;\n}\n\n\n/*??£????????´??????????????°???????????§????°??????????????????¢?????????????????????*/\nint min_search(int *C){\n  int res=n,i;\n  C[n]=INT_MAX;\n  for(i=0;i<n;i++){\n    if(A[i]!=C[i]){\n      if(C[res] >C[i]) res =i;\n    }\n  }\n  return res;\n}\n\n\n\n\n\n\nint quest(int *C,int num,int jud){\n  int D[1001],E[1001],i,x,ans,ans2,judd;\n  if(jud==n) x=min_search(C);\n  else x=jud;\n  if(x==n) return num;\n  for(i=0;i<n;i++) D[i]=C[i];\n  i=0;\n  while(1){\n    if(D[i]==A[x]){\n      swap(i,x,D);\n      judd=i;\n      if(D[i]==A[i]) judd=n;\n      ans=quest(D,num+D[i]+D[x],judd);\n      break;\n    }\n    i++;  \n  }\n  if(E[x]!=A[0]){\n    for(i=0;i<n;i++) E[i]=C[i];\n    swap(0,x,E);\n    ans2=quest(E,num+E[0]+E[x],x);\n    if(ans > ans2) {\n      ans=ans2;\n      cnt+=1;\n    }\n  }\n  return ans;\n}\n  \n \n  \n\nint main(){\n  scanf(\"%d\",&n);\n  int i,j,min=n;\n  cnt=0;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n  m_sort(0,n);\n  cost=0;\n  for(i=0;i<n;i++){\n    for(j=i+1;j<n;j++){\n      if(B[i]==A[j]){\n        if(B[j]==A[i]){\n          swap(i,j,B);\n          cost+=B[i]+B[j];\n        }\n        break;\n      }\n    } \n  }\n  while(1){\n    if(min==n) min=min_search(B);\n    if(B[min]!=A[0]){\n      break;\n    }\n    else{\n      if(min==n) break;\n      for(i=0;i<n;i++){\n        if(A[min]==B[i]){\n          if(min==i){\n            min=n;\n            break;\n          }\n          swap(min,i,B);\n          cost+=B[min]+B[i];\n          min=i;\n          break;\n        }\n      }\n    }\n  }\n  cost=quest(B,cost,n);\n  printf(\"%d\\n,cnt=%d\\n\",cost,cnt);\n  return 0;\n}\n   \n          \n          \n    "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n \n#define N 1001\n#define MAX 10001\n \n#define min(x,y) ( (x) < (y) ? (x) : (y) )\n \nint compare (const void* a, const void* b) {\n  return *(int*)a - *(int*)b;\n}\n \nint main () {\n  int n;\n  int array[N];\n  int sortedArray[N];\n   \n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &array[i]);\n    sortedArray[i] = array[i];\n  }\n  qsort(sortedArray, n, sizeof(int), compare);\n  int gMin = sortedArray[0];\n \n  int index[MAX];\n  for (int i = 0; i < n; i++) {\n    index[sortedArray[i]] = i;\n  }\n \n  bool isUsed[N];  \n  for (int i = 0; i < n; i++) {\n    isUsed[i] = false;\n  }\n \n  int totalCost = 0;\n  for (int i = 0; i < n; i++) {\n    if (isUsed[i]) {\n      continue;\n    }\n \n    int cycleSum  = 0;\n    int cycleCard = 0;\n    int cycleMin  = MAX;\n    int pos = i;\n    while (1) {\n      isUsed[pos] = true;\n \n      cycleCard++;      \n      cycleSum += array[pos];\n      cycleMin  = min(cycleMin, array[pos]);\n \n      pos = index[array[pos]];\n \n      if (isUsed[pos]) {\n    break;\n      }\n    }\n \n    if ( 2*(cycleMin + gMin) < (cycleCard - 1)*(cycleMin - gMin) ) {\n      totalCost += cycleSum + cycleMin + (cycleCard + 1)*gMin;\n    } else {\n      totalCost += cycleSum + (cycleCard - 2)*cycleMin;\n    }\n  }\n \n  printf(\"%d\\n\", totalCost);\n   \n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define MAX 1000\n#define WMAX 10000\n#define miner(x, y) ((x) < (y) ? (x) : (y))\n#define swap(x, y, type) do {type t = x; x = y; y = t;} while(0)\nvoid qsort1(int, int, int*);\nint mcsort(int, int, int*);\nmain()\n{\n        int i, n, min = WMAX, *w;\n        scanf(\"%d\", &n);\n        w = (int*)malloc(sizeof(int) * n);\n        for (i = 0; i < n; i++) {\n                scanf(\"%d\", &w[i]);\n                min = miner(w[i], min);\n        }\n        printf(\"%d\\n\", mcsort(min, n, w));\n        free(w);\n}\nvoid qsort1(int left, int right, int *s){\n        int pivot = s[(left + right) / 2], i = left, j = right;\n    if (left >= right) return;\n    do {\n        while (s[i] < pivot) i++;\n        while (s[j] > pivot) j--;\n        if (i <= j) {\n            swap(s[i], s[j], int);\n            i++;\n            j--;\n        }\n    }while (i <= j);\n    qsort1(left, j, s);\n    qsort1(i, right, s);\n}\nint mcsort(int min, int n, int *w)\n{\n        int i, ans = 0, s[n], f[n], p[WMAX + 1];\n        for (i = 0; i < n; i++) {\n                s[i] = w[i];\n                f[i] = 0;\n        }\n        qsort1(0, n - 1, s);\n        for (i = 0; i < n; i++) {\n        p[s[i]] = i;\n    }\n        for (i = 0; i < n; i++) {\n                int cur = i, m = WMAX, sum = 0, cn = 0;\n                if(f[i]) continue;\n                while (!f[cur]) {\n                        f[cur] = 1;\n                        cn++;\n                        m = miner(w[cur], m);\n                        sum += w[cur];\n                        cur = p[w[cur]];\n                }\n                ans += miner(sum + (cn - 2) * m, sum + m + (cn + 1) * min);\n    }\n        return ans;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX  1000\n#define VMAX 10000\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint min(int a,int b){\n  if(a>b) return b;\n  else return a;\n}\n\nint partition(int A[],int p,int r){\n  int i,j;\n  int t,x;\n  x = A[r];\n  i = p - 1;\n\n  for(j=p;j<r;j++){\n    if(A[j]<=x){\n      i++;\n      t = A[i];\n      A[i] = A[j];\n      A[j] = t;\n    }\n  }\n\n  t = A[i+1];\n  A[i+1] = A[r];\n  A[r] = t;\n\n  return i+1;\n}\n\nvoid quickSort(int A[],int p,int r){\n  int q;\n  if(p<r){\n    q = partition(A,p,r);\n    quickSort(A,p,q-1);\n    quickSort(A,q+1,r);\n  }\n}\n\nint solve(){\n  int ans=0,i,cur,S,m,an,v;\n\n  int V[MAX];\n  for(i=0;i<n;i++){\n    B[i] = A[i];\n    V[i] = 0;\n  }\n  quickSort(B,0,n-1);\n  for(i=0;i<n;i++) T[B[i]] = i;\n  for(i=0;i<n;i++){\n    if(V[i]) continue;\n    cur = i;\n    S = 0;\n    m = VMAX;\n    an = 0;\n    while(1){\n      V[cur] = 1;\n      an++;\n      v = A[cur];\n      m = min(m,v);\n      S += v;\n      cur = T[v];\n      if(V[cur]) break;\n    }\n    ans += min(S+(an-2)*m,m+S+(an+1)*s);\n  }\n  return ans;\n}\n\nint main(){\n  int i;\n\n  scanf(\"%d\", &n);\n  \n  s = VMAX;\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    s = min(s,A[i]);\n  }\n\n  int ans = solve();\n  printf(\"%d\\n\",ans);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define NOT_CHECK 0\n#define CHECK 1\n\ntypedef struct element_ {\n\tint idx, val;\n} element;\n\nint element_sort(void *a, void *b) {\n\treturn (*(element*)a).val - (*(element*)b).val;\n}\n\nint main(void) {\n\tint i, n, costs;\n\tint A[1005];\n\tint W[10005];\n\tint chk[1005];\n\telement sortedA[1005];\n\n\tscanf(\"%d\\n\", &n);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%d\\n\", &A[i]);\n\t\tsortedA[i].idx = i;\n\t\tsortedA[i].val = A[i];\n\t\tW[A[i]] = i;\n\t\tchk[i] = NOT_CHECK;\n\t}\n\n\tqsort((void*)sortedA, n, sizeof(element), element_sort);\n\n\tfor(i=0;i<n;i++) {\n\t\tint p, cost, min;\n\t\tp = i;\n\t\tmin = sortedA[p].val;\n\n\t\tif(sortedA[i].idx == i) {\n\t\t\t// ソート後と同じ位置のため入れ替える必要がない\n\t\t\tchk[i] = CHECK;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// 軽い荷物を使って、正しい場所に入れ替えていく\n\t\tcost = 0;\n\t\t// 相互に置き換え可能かどうか\n\t\twhile(!chk[p] && !chk[W[sortedA[p].val]]) {\n\t\t\tchk[p] = CHECK;\n\t\t\tcost = cost + A[p] + min;\n\t\t\tp = W[sortedA[p].val];\n\t\t}\n\t\tcosts += cost;\n\t}\n\n\tprintf(\"%d\\n\", costs);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n#include <stdlib.h>         // qsort()\n#include <stdbool.h>\n\n#define MAX_N 1000\n#define MAX_V 10000\n#define min(a, b) ((a) < (b) ? a : b)\n\nint a[MAX_N];\nint n;\n\nint\ncmp_func(const void *l_, const void *r_)\n{\n\tconst int* l = (const int*) l_;\n\tconst int* r = (const int*) r_;\n\n\tif (*l < *r)\n\t\treturn -1;\n\n\tif (*l > *r)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nint\nsolve()\n{\n\tint b[MAX_N];\n\tint t[MAX_V + 1];\n\tbool v[MAX_N];\n\tint i;\n\n\tint ans = 0;\n\tfor (i = 0; i < n; ++i)\n\t{\n\t\tb[i] = a[i];\n\t\tv[i] = false;\n\t}\n\n\tqsort(b, n, sizeof(int), cmp_func);\n\tfor (i = 0; i < n; ++i)\n\t\tt[b[i]] = i;\n\n\tfor (i = 0; i < n; ++i)\n\t{\n\t\tif (v[i])\n\t\t\tcontinue;\n\n\t\tint cur = i;\n\t\tint s = 0;\n\t\tint m = MAX_V;\n\t\tint an = 0;\n\t\twhile (true)\n\t\t{\n\t\t\tv[cur] = true;\n\t\t\tan++;\n\t\t\tint u = a[cur];\n\t\t\tif (u < m)\n\t\t\t\tm = u;\n\n\t\t\ts += u;\n\t\t\tcur = t[u];\n\t\t\tif (v[cur])\n\t\t\t\tbreak;\n\t\t}\n\n\t\tans += min(s + (an - 2) * m, s + m + (an + 1) * b[0]);\n\t}\n\n\treturn ans;\n}\n\nint\nmain(int argc, char** argv)\n{\n\tint i;\n\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; ++i)\n\t\tscanf(\"%d\", &a[i]);\n\n\tprintf(\"%d\\n\", solve());\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#define true 1\n#define false 0\n#define MAX 1000\n#define VMAX 10000\n\nint n , A[MAX] , s;\nint B[MAX] , T[VMAX+1];\n\nvoid sort(int C[])\n{\n\tint flag = 1;\n\tint tmp;\n\twhile(flag == 1)\n\t{\n\t\tflag = 0;\n\t\tfor( int j = n-1; j >= 1; j--)\n\t\t{\n\t\t\tif(C[j] < C[j-1])\n\t\t\t{\n\t\t\t\ttmp = C[j];\n\t\t\t\tC[j] = C[j-1];\n\t\t\t\tC[j-1] = tmp;\n\t\t\t\tflag = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint min(int a , int b)\n{\n\tif(a < b) return a;\n\telse return b;\n}\n\nint solve()\n{\n\tint ans = 0;\n\t\n\tbool V[MAX];\n\tfor( int i = 0; i < n; i++)\n\t{\n\t\tB[i] = A[i];\n\t\tV[i] = false;\n\t}\n\tsort(B);\n\tfor( int i = 0; i < n; i++) T[B[i]] = i;\n\tfor( int i = 0; i < n; i++) {\n\t\tif(V[i])continue;\n\t\tint cur = i;\n\t\tint S = 0;\n\t\tint m = VMAX;\n\t\tint an = 0;\n\t\twhile(1){\n\t\t\tV[cur] = true;\n\t\t\tan++;\n\t\t\tint v = A[cur];\n\t\t\tm = min(m,v);\n\t\t\tS += v;\n\t\t\tcur = T[v];\n\t\t\tif(V[cur])break;\n\t\t}\n\t\tans += min(S+(an-2)*m,m+S+(an+1)*s);\n\t}\n\treturn ans;\n}\n\nint main(void)\n{\n\tscanf(\"%d\",&n);\n\ts = VMAX;\n\tfor( int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\",&A[i]);\n\t\ts = min(s,A[i]);\n\t}\n\tint ans = solve();\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define Max  1000\n#define vMax 10000\n\nint n, a[Max], s;\nint b[Max], T[vMax + 1];\n\n\nint partition(int a[], int p, int r){\n  int i, j;\n  int t, x;\n  x = a[r];\n  i = p - 1;\n\n  for(j = p ; j < r ; j++){\n    if(a[j] <= x){\n      i++;\n      t = a[i];\n      a[i] = a[j];\n      a[j] = t;\n    }\n  }\n\n  t = a[i + 1];\n  a[i + 1] = a[r];\n  a[r] = t;\n\n  return i + 1;\n}\n\nvoid quickSort(int a[], int p, int r){\n  int q;\n  if(p < r){\n    q = partition(a, p, r);\n    quickSort(a, p, q - 1);\n    quickSort(a, q + 1, r);\n  }\n}\n\n\n\nint solve(){\n  int i,ans = 0, cur, S, m, an, v;\n\n  int V[Max];\n  for(i = 0 ; i < n ; i++){\n    b[i] = a[i];\n    V[Max] = 0;\n  }\n\n  quickSort(b, 0, n - 1);\n\n  for(i = 0 ; i < n ; i++) T[b[i]] = i;\n  for(i = 0 ; i < n ; i++){\n    if(V[i]) continue;\n    cur = i;\n    S = 0;\n    m = vMax;\n    an = 0;\n    while(1){\n      V[cur] = 1;\n      an++;\n      v = a[cur];\n\n      if(v < m) m = v;\n\n      S += v;\n      cur = T[v];\n      if(V[cur]) break;\n    }\n    if(S + (an -2) * m < m + S + (an + 1) * s) ans += S + (an -2) * m;\n    if(S + (an -2) * m > m + S + (an + 1) * s) ans +=  m + S + (an + 1) * s;\n  }\n  return ans;\n}\n\n\nint main(){\n  int i;\n\n  scanf(\"%d\", &n);\n  s = vMax;\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\", &a[i]);\n    if(a[i] < s) s = a[i];\n}\n\n  int ans = solve();\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint n;\n\nint search(int *A, int w);\n\nint main(int argc, char *argv[])\n{\n  int i, j, k, l, t;\n  int *A, *R, *g, tmp, g_minj, minj;\n  int cost = 0;\n\n  scanf(\"%d\", &n);\n  A = (int *)malloc(sizeof(int) * n);\n  R = (int *)malloc(sizeof(int) * n);\n  g = (int *)malloc(sizeof(int) * n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%d\", &A[i]);\n    R[i] = A[i];\n    g[i] = 0;\n  }\n\n  for (i = 0; i < n; i++) {\n    minj = i;\n    for (j = i; j < n; j++) {\n      if (R[minj] > R[j]) minj = j;\n    }\n    tmp = R[minj];\n    R[minj] = R[i];\n    R[i] = tmp;\n  }\n\n  for (i = 0; i < n; i++) {\n    if (A[i] == R[i]) continue;\n\n    g_minj = i;\n    g[0] = i;\n    k = 1;\n    j = i;\n    while (A[j] != R[i]) {\n      j = search(R, A[j]);\n      if (A[j] < A[g_minj]) g_minj = j;\n      g[k++] = j;\n    }\n    l = search(g, g_minj);\n    if (k >= 3) {\n      minj = search(A, R[0]);\n      if (minj != g_minj) {\n\tcost += A[minj] + A[g_minj];\n\ttmp = A[minj];\n\tA[minj] = A[g_minj];\n\tA[g_minj] = tmp;\n\ttmp = minj;\n\tminj = g_minj;\n\tg_minj = tmp;\n      }\n    }\n\n    for (j = k; j > 1; j--) {\n      t = (l + j - 1) % k;\n      cost += A[g[t]] + A[g[t+1]];\n      tmp = A[g[t+1]];\n      A[g[t+1]] = A[g[t]];\n      A[g[t]] = tmp;\n    }\n\n    if (k >= 3 && g_minj != minj) {\n      minj = search(A, R[0]);\n      if (minj != g_minj) {\n\tcost += A[minj] + A[g_minj];\n\ttmp = A[g_minj];\n\tA[g_minj] = A[minj];\n\tA[minj] = tmp;\n      }\n    }\n  }\n\n  printf(\"%d\\n\", cost);\n\n  return 0;\n}\n\nint search(int *A, int w)\n{\n  int i;\n  int found;\n\n  found = 0;\n  for (i = 0; i < n; i++) {\n    if (A[i] == w) {\n      found = 1;\n      break;\n    }\n  }\n\n  if (found == 1) return i;\n  else return -1;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define CHECK printf(\"check\\n\");\nvoid countingSort(int*,int*,int,int);\nint countMinimumCost(int*,int*,int);\nvoid printArray(int*,int);\nint main(void)\n{\n  int i;//counter\n  int n;//length of array\n  int wholeMax=0;//maximum value of array\n  int *arr;//array sorted by minimum cost sort\n  int *sortedArr;//array sorted by counting sort\n  int cost;\n  scanf(\"%d\",&n);\n  arr=(int*)malloc(sizeof(int)*n);\n  sortedArr=(int*)malloc(sizeof(int)*n);\n  for(i=0;i<n;i++)\n    {\n      scanf(\"%d\",&arr[i]);\n      if(wholeMax<arr[i]) wholeMax=arr[i];\n    }\n  countingSort(arr,sortedArr,n,wholeMax);\n  cost=countMinimumCost(arr,sortedArr,n);\n  printf(\"%d\\n\",cost);\n  return 0;\n}\nvoid countingSort(int *arr,int *sortedArr,int n,int max)\n{\n  int i;//counter\n  int *countArr=(int*)malloc(sizeof(int)*(max+1));\n  for(i=0;i<max+1;i++) countArr[i]=0;\n  for(i=0;i<n;i++) countArr[arr[i]]++;\n  for(i=1;i<max+1;i++) countArr[i]+=countArr[i-1];\n  for(i=n-1;i>=0;i--)\n    {\n      sortedArr[countArr[arr[i]]-1]=arr[i];\n      countArr[arr[i]]--;\n    }\n}\nint countMinimumCost(int *arr,int *sortedArr,int n)\n{\n  int i;//counter\n  int *isSortedArr=(int*)malloc(sizeof(int)*n);\n  int begin;//first index that is not sorted yet\n  int index;//index pointing now\n  int count;//length of loop\n  int sum;//sum of loop\n  int min;//minimum value among loop\n  int wholeMin;//minimum value in the array\n  int currentCost[2];//2 pattern of sorting cost in one loop\n  int sumCost=0;//sum of whole cost;\n  //init isSortedArr\n  wholeMin=arr[0];\n  begin=n;\n  for(i=0;i<n;i++)\n    {\n      if(arr[i]==sortedArr[i]) isSortedArr[i]=1;\n      else isSortedArr[i]=0;\n      if(wholeMin>arr[i]) wholeMin=arr[i];\n      if(isSortedArr[i]==0&&begin==n) begin=i;\n    }\n  \n  for(;begin<n;begin++)\n    {\n      if(isSortedArr[begin]==0)\n\t{\n\t  index=begin;\n\t  sum=0;\n\t  min=arr[index];\n\t  for(count=1;;count++)\n\t    {\n\t      isSortedArr[index]=1;\n\t      sum+=arr[index];\n\t      if(min>arr[index]) min=arr[index];\n\t      for(i=begin+1;i<n;i++)\n\t\t{\n\t\t  if(arr[i]==sortedArr[index]&&isSortedArr[i]==0) break;\n\t\t}\n\t      if(i==n) break;\n\t      index=i;\n\t    }\n\t  currentCost[0]=sum-min+min*(count-1);\n\t  currentCost[1]=(wholeMin+min)*2+(sum-min+wholeMin*(count-1));\n\t  if(currentCost[0]<currentCost[1]) sumCost+=currentCost[0];\n\t  else sumCost+=currentCost[1];\n\t}\n    }\n  return sumCost;\n}\nvoid printArray(int *arr,int n)\n{\n  int i;//counter\n  for(i=0;i<n;i++)\n    {\n      if(i>0) printf(\" \");\n      printf(\"%d\",arr[i]);\n    }\n  printf(\"\\n\");\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#define MAX 1000\n#define VMAX 10000\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX+1];\n\nint partition(int A[], int p, int r){\n  int i, j;\n  int x, t;\n  x = A[r];\n  i = p-1;\n  for( j = p ; j < r ; j++ ){\n    if( A[j] <= x ){\n      i++;\n      t = A[i];\n      A[i] = A[j];\n      A[j] = t;\n    }\n  }\n  t = A[i+1];\n  A[i+1] = A[r];\n  A[r] = t;\n  return i + 1;\n}\n\nvoid quickSort(int A[], int p, int r){\n  int q;\n  if( p < r ){\n    q = partition(A, p, r);\n    quickSort(A, p, q-1);\n    quickSort(A, q+1, r);\n  }\n}\n\n\nint solve(){\n  int i, ans = 0;\n\n  int V[MAX];\n  for( i = 0 ; i < n ; i++ ){\n    B[i] = A[i];\n    V[i] = 0;\n  }\n  quickSort(B, 0, n-1);\n  for( i = 0 ; i < n ; i++ ) T[B[i]] = i;\n  for( i = 0 ; i < n ; i++ ){\n    if( V[i] ) continue;\n    int cur = i;\n    int S = 0;\n    int m = VMAX;\n    int an = 0;\n    while( 1 ){\n      V[cur] = 1;\n      an++;\n      int v = A[cur];\n      m = fmin(m, v);\n      S += v;\n      cur = T[v];\n      if( V[cur] ) break;\n    }\n    ans += fmin(S+(an-2)*m, m+S+(an+1)*s);\n  }\n\n  return ans;\n}\n\nint main(){\n  int i;\n  scanf(\"%d\",&n);\n  s = VMAX;\n  for( i = 0 ; i < n ; i++ ){\n    scanf(\"%d\", &A[i]);\n    s = fmin(s, A[i]);\n  }\n  int ans = solve();\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX 1000\n#define MAXWEIGHTIJ 20000\n\nstruct MCS {\n\tint cost;\n\tint order;\n};\n\nvoid exchange( struct MCS *pa, struct MCS *pb )\n{\n   \tstruct MCS t;\n     \n\tt=*pa;\n\t*pa=*pb;\n\t*pb=t;\n\t \n\t return;\n}\n \nint Partition( struct MCS A[], int p, int r )\n{\n    struct MCS x;\n    int i,j;\n \n    x=A[r];\n    i=p-1;\n    for( j=p; j<r; j++ ) {\n        if( A[j].cost < x.cost ) {\n            i++;\n            exchange( &A[i], &A[j] );\n         }\n    }\n    exchange( &A[i+1], &A[r] );\n\n    return i+1;\n}\nvoid QuickSort( struct MCS A[], int p, int r )\n{\n    int q;\n     \n    if( p < r ) {\n        q=Partition( A, p, r );\n        QuickSort( A, p, q-1 );\n        QuickSort( A, q+1, r );\n    }\n    return;\n}\n\nint tryChange( int n, struct MCS W[] )\n{\n\tint cnt;\n\tint fixedcost,profit;\n\tint from, to, togoal;\n\t\n\tint cost,lowestCost;\n\tint i,j;\n\tint lowW,lowestW;\n\tint low,high,lowest;\n\n\tlowestW=lowW=lowestCost=cost=MAXWEIGHTIJ;\n\tlowest=high=low=-1;\t\n\tfor( i=0; i<n; i++ ) {\n\t\tif( i != W[i].order && W[i].cost < lowW ) {\n\t\t\tlowW=W[i].cost;\n\t\t\tlow=i;\n\t\t\tfor( j=0; j<n; j++ ) {\n\t\t\t\tif( low == W[j].order ) {\n\t\t\t\t\thigh=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( W[i].cost < lowestW ) {\n\t\t\tlowestW=W[i].cost;\n\t\t\tlowest=i;\t\n\t\t}\t\t\n\t}\n\n\tif( W[high].order == low && W[low].order == high ) { \n\t\tlowestCost = W[low].cost + W[high].cost;\n\t} else if( low != lowest ) {\t\n\t\tfixedcost = W[low].cost + W[lowest].cost;\n\t\tprofit = W[low].cost - W[lowest].cost;\n\t\tfrom=high;\n\t\tto=low;\n\t\ttogoal = W[low].order;\n\t\tcnt=0;\n\t\twhile( 1 ) {\n\t\t\tif( W[from].order == to ) {\n\t\t\t\tif( togoal == to ) { break; }\n\t\t\t\tto=from;\n\t\t\t\tcnt++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor( i=0; i<n; i++ ) {\n\t\t\t\tif( i != W[i].order ) {\n\t\t\t\t\tif( to == W[i].order ) {\n\t\t\t\t\t\tfrom=i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprofit = ( profit * cnt ) - ( 2 * fixedcost );\n\t\tif( 0 < profit ) {\n\t\t\thigh=low;\n\t\t\tlow=lowest;\n\t\t\tlowestCost = fixedcost;\n\t\t}\n\t}\n\tif( W[high].order == low ) { \n\t\tlowestCost = W[low].cost + W[high].cost;\n\t}\n\n    if( MAXWEIGHTIJ != lowestCost ) {\n\t\texchange( &W[low], &W[high] );\n\t} else {\n    \tlowestCost=0;\n    }\n\treturn lowestCost;\n}\n\nint main( void ) \n{   \n    int n,i;\n    struct MCS W[MAX+1];\n    int cost;\n        \n    scanf( \"%d\", &n );\n    for( i=0; i<n; i++ ) {\n        scanf( \"%d\", &W[i].cost );\n        W[i].order=i;\n    }\n\n\tQuickSort( W, 0, n-1 ); \n\tcost=i=0;\n\twhile( (i = tryChange( n, W ) ) ) {\n\t\tcost+=i;\n\t}\n\tprintf( \"%d\\n\", cost );\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\n//============================================================================\n#define pred(x) ((x)-1)\n#define succ(x) ((x)+1)\n//============================================================================\ntypedef unsigned char  INT8U;\ntypedef unsigned short INT16U;\ntypedef   signed short INT16S;\ntypedef long INT32;\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nINT16U *C;\n//----------------------------------------------------------------------------\nvoid CountingSort(INT16U *A, INT16U *B,  INT16U n, INT16U k)\n{\n    long i;\n\n    for (i = 0; i<n; i++)\n        C[A[i]]++;\n    for (i = 1; i<=k; i++)\n        C[i] += C[i-1];\n    // C holds position of A\n    // C[A[val]] = pred val position\n\n    /*for (i = 1; i<=k; i++)\n        printf(\"%d \", C[i]);\n    printf(\"\\n\");*/\n    /*printf(\"B[C[A[i]]-1] = A[i];\\n\");\n    for (i=n-1; 0<=i; i--){\n        //B[C[A[i]]-1] = A[i];\n        printf(\"B[%d]=%d C[%d]=%d A[%d]=%d\\n\", C[A[i]]-1, A[i],\n                            A[i], C[A[i]], i, A[i]);\n        //C[A[i]]--;\n    }*/\n}\n//----------------------------------------------------------------------------\nINT16S getminptr(INT16U *A, INT16U N)\n{\n    INT16U i,min; INT16S ptr;\n\n    for (i=0, ptr=-1, min=32767; i<N; i++){\n        if (A[i]<min && pred(C[A[i]])!=i){\n            min=A[i];\n            ptr=i;\n        }\n    }\n    return ptr;\n}\n//----------------------------------------------------------------------------\nlong sum;\nvoid exchange(INT16U *x, INT16U *y)\n{\n    INT16U z;\n\n    z=*x, *x=*y, *y=z;\n    sum+=*x;\n    sum+=*y;\n    //printf(\"ex: %d<-->%d, sum:%ld\\n\", *y, *x, sum);\n}\n//----------------------------------------------------------------------------\nvoid prnary(INT16U *A, INT16U N)\n{\n    int j;\n\n    for (j=0; j<N; j++)\n        printf(\"%2d \", A[j]);\n    printf(\" sum:%ld\\n\", sum);\n}\n//----------------------------------------------------------------------------\nshort linklen(INT16U *A, INT16U N, INT16U val)\n{\n    int idx,n;\n\n\n    for (n=0, idx=val; ; n++){\n        idx=A[pred(C[idx])];\n        if (idx==val)\n            return n;\n    }\n}\n//----------------------------------------------------------------------------\nvoid duplication(INT16U *A, INT16U N)\n{\n    int i,j,k,n,a,ary[3];\n\n#ifdef DESKTOP\n    prnary(A, N);\n#endif\n    for (i=sum=0; i<pred(N); i++){\n        n=linklen(A, N, A[i]);\n        if (n==1){\n            j=pred(C[A[i]]);\n            exchange(&A[i], &A[j]);\n            //printf(\"ex:(%d<->%d), \", A[i], A[j]);\n        }/*else\n        if (n==2 && 10<A[i]){\n            ary[0]=i;\n            ary[1]=pred(C[A[i]]);\n            ary[2]=pred(C[A[ary[1]]]);\n            for (j=a=0,k=20000; j<3; j++)\n            if (A[ary[j]]<k){\n                k=A[ary[j]];\n                a=ary[j];\n            }\n            j=pred(C[A[a]]);\n            k=pred(C[A[j]]);\n            if (A[j]<A[k]){\n                //printf(\"ex:(%d<->%d), \", A[a], A[k]); // 44<>96\n                exchange(&A[a], &A[k]);\n            }else{\n                //printf(\"ex:(%d<->%d), \", A[a], A[j]); // 44<>96\n                exchange(&A[a], &A[j]);\n            }\n            //printf(\"ex:(%d<->%d), \", A[k], A[j]); // 44<>96\n            exchange(&A[k], &A[j]);\n        }*/\n#ifdef DESKTOP\n    }\n    printf(\"\\n\");\n#else\n    }\n#endif\n}\n//----------------------------------------------------------------------------\nlong mincostsort(INT16U *A, INT16U N)\n{\n    int ptr,i,j,min,ordptr,order[100];\n\n    duplication(A, N);\n    for (i=0,j=32000; i<N; i++)\n        if (A[i]<j)\n            j=A[i],min=i;\n    for (ordptr=0; 0<=(ptr=getminptr(A, N));){\n#ifdef DESKTOP\n    printf(\"[%d]\\n\", A[ptr]);\n#endif\n        order[ordptr++]=A[ptr];\n        if (A[min]*2<A[ptr]){\n            exchange(&A[min], &A[ptr]);\n            min=ptr;\n        }\n        while (pred(C[A[ptr]])!=ptr){\n            for (i=0; i<N; i++)\n                if (C[A[i]]==succ(ptr)){\n                    order[ordptr++]=A[i];\n                    if (ptr==min) min=i;\n                    exchange(&A[ptr], &A[i]);\n                    ptr=i;\n#ifdef DESKTOP\n                    //prnary(A, N);\n#endif\n                    break;\n                }\n        }\n    }\n#ifdef DESKTOP\n    for (i=0; i<ordptr; i++){\n        if (i) printf(\"->\");\n            printf(\"%d\", order[i]);\n    }\n    printf(\"\\n\");\n#endif\n    return sum;\n}\n//----------------------------------------------------------------------------\n/*\n*                                         *     *\n0 62 33 29 72 52 43 19 5  93 51 32  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51  5  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51 47  8 11 56  5 66 69 30 17 68  5\n0  5 33 29 72 52 43 19 32 93 51 47  8 11 56 62 66 69 30 17 68  0\n0  5 33 29 72 52 43 19 32 93  8 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 29 72 52  8 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33  8 72 52 29 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 11 72 52 29 19 32 93 43 47 51  8 56 62 66 69 30 17 68  8\n0  5 33 11 72  8 29 19 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29  8 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 69  8 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66  8 69 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 68 69 17  8  8\n0  5 33 11 72 19 29 30 32  8 43 47 51 52 56 62 66 68 69 17 93  8\n0  5  8 11 72 19 29 30 32 33 43 47 51 52 56 62 66 68 69 72 93  0\n0  5  8 11 17 19 29 30 32 33 43 47 51 52 56 62 66 68 69 17 93  0\n\n 1 80 50 70 40 20\n20 80 50 70 40  1\n20  1 50 70 40 80\n 1 20 50 70 40 80 21        20 40 50 70  1 80   41\n40 20 50 70  1 80 41        20 40 50  1 70 80   71\n40 20 50  1 70 80 71        20 40  1 50 70 80   51\n40 20  1 50 70 80 51        20  1 40 50 70 80   41\n 1 20 40 50 70 80 41         1 20 40 50 70 80   21\n\n\n5\n1 5 3 4 2\n7\n\n4\n4 3 2 1\n10\n*/\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nvoid input(FILE *file)\n{\n    long i,n,max,ave; INT16U *A, *B; char buffer[20];\n\n    fgets(buffer, sizeof(buffer)-1, file);\n    sscanf(buffer, \"%ld\", &n);\n    A = malloc(succ(n)*sizeof(INT16U));\n    B = malloc(succ(n)*sizeof(INT16U));\n    for (i=ave=max=0; i<n; i++){\n        fscanf(file, \"%hd\",  &A[i]);\n        if (max<A[i])\n            max=A[i];\n        ave+=A[i];\n    }\n    ave/=n;\n    C = malloc(succ(max)*sizeof(INT16U));\n    memset(C, 0, sizeof(INT16U)*succ(max));\n    CountingSort(A, B, n, max);\n    printf(\"%ld\\n\", mincostsort(A, n));\n#ifdef DESKTOP\n    for (i=0; i<n; i++){\n        if (i) printf(\" \");\n        printf(\"%hd\", A[i]);\n    }\n    printf(\"\\n\");\n#endif\n    free(A);\n    free(B);\n    free(C);\n}\n//============================================================================\n#ifndef DESKTOP\nint main()\n{\n    input(stdin);\n    return 0;\n}\n#endif"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX 1000\n#define INF INT_MAX\n\nint solve(int*, int);\nint check(int*,int);\n\nint main(){\n  int n, i, arr[MAX];\n\n  scanf(\"%d\" ,&n);\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\" ,arr + i);\n    arr[i]--;\n  }\n  printf(\"%d\\n\" ,solve(arr, n));\n\n  return 0;\n}\n\nint check(int arr[], int n){\n  int i;\n\n  for(i = 0 ; i < n ; i++){\n    if(arr[i] != i){\n      return 0;\n    }\n  }\n  return 1;\n}\n\nint solve(int arr[], int n){\n  int i, j, res = 0, tmp, pos, min = INF;\n\n  for(i = 0 ; i < n-1 ; i++){\n    if(arr[i] != i){\n      for(j = i+1 ; j < n ; j++){\n        if(arr[j] != j && arr[i] == j && arr[j] == i){\n          res += arr[i] + arr[j] + 2;     \n          tmp = arr[i];\n          arr[i] = arr[j];\n          arr[j] = tmp;\n        }\n      }\n    }\n  }\n\n  for(i = 0 ; i < n-1 ; i++){\n    if(arr[i] != i){\n      pos = -1;\n      for(j = i+1 ; j < n ; j++){\n        if(arr[j] != j){\n          if(arr[i] + arr[j] + 2 < min){\n            min = arr[i] + arr[j] + 2;      \n            pos = j;\n          }\n        }\n      }\n\n      if(pos != -1){\n        res += arr[i] + arr[pos] + 2;\n        tmp = arr[i];\n        arr[i] = arr[pos];\n        arr[pos] = tmp;\n      }\n    }\n  }\n\n  return res;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define W_MAX 1000001\n#define MAX 1001\n\nint array[MAX];\nint sorted[MAX];\n\nvoid swap(int* a, int* b){\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n}\n\nint greedy(int n){\n  int i, j;\n  int min = W_MAX, min_pos = -1;\n  int next = -1, next_pos = -1;\n\n  for(i = 0; i < n; i++){\n    if(sorted[i] != array[i] && min > array[i]){\n      min = array[i];\n      min_pos = i;\n    }\n  }\n\n  if(min_pos == -1){\n    return 0;\n  }\n\n  next = sorted[min_pos];\n  for(i = 0; i < n; i++){\n    if(array[i] == next){\n      next_pos = i;\n      break;\n    }\n  }\n\n  swap(&array[min_pos], &array[next_pos]);\n\n  return (next + min) + greedy(n);\n}\n\nint main(int argc, char* argv[]){\n  int i, j, n;\n  scanf(\"%d\", &n);\n\n  for(i = 0; i < n; i++){\n    scanf(\"%d\", &array[i]);\n    sorted[i] = array[i];\n  }\n  \n  for(i = 0; i < n; i++){\n    int min = sorted[i];\n    int min_pos = i;\n    \n    for(j = i + 1; j < n; j++){\n      if(min > sorted[j]){\n\tmin = sorted[j];\n\tmin_pos = j;\n      }\n    }\n\n    if(min_pos != i){\n      swap(&sorted[i], &sorted[min_pos]);\n    }\n  }\n\n\n  printf(\"%d\\n\", greedy(n));\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<limits.h>\n\n#define SENTINEL 2000000000\n\ntypedef struct box{\n\tint a;//初期の位置を格納\n\tint b;//重さ\n\tint c;//サイクル別にサイクル番号を格納\n} num;\n\nlong int cnt=0;//case#19で解がint型の最大値を越えるためlongを用いる\n\nvoid merge(num *A,int left,int mid,int right)//分割した配列を小さい順に結合\n{\n  int n1 = mid - left;\n  int n2 = right - mid;\n  num L[n1+1],R[n2+1];\n  int k,i,j;\n  for (i=0;i<n1;i++) {\n  \tL[i].a = A[left + i].a;\n  \tL[i].b = A[left + i].b;\n  }\n  for (i=0;i<n2;i++) {\n  \tR[i].a = A[mid + i].a;\n  \tR[i].b = A[mid + i].b;\n  }\n  L[n1].b = SENTINEL;//EOF\n  R[n2].b = SENTINEL;//EOF\n  i = 0;\n  j = 0;\n    \n  for(k=left;k<right;k++){//iが左の要素番号,jが右の要素番号\n    if(L[i].b<=R[j].b){//左が小さい場合\n      A[k].a = L[i].a;\n      A[k].b = L[i].b;\n      i=i+1;\n    }else{ //右が小さい場合\n      A[k].a = R[j].a;\n       A[k].b = R[j].b;\n      if(L[i].b!=SENTINEL) cnt+=(n1-i);//SENTINELと比較する場合を除いて左側の未ソート部分の要素数をcntに加算\n      j = j + 1;\n    }\n  }\n}\n\n\nvoid mergeSort(num *A,int left,int right)\n{\n  int mid,i;\n  if(left+1<right){//二分探索のように左端が右端を超えたら終了\n    mid = (left + right)/2;\n    mergeSort(A, left, mid);//左半分で再帰\n    mergeSort(A, mid, right);//右半分で再帰\n    merge(A, left, mid, right);//結合\n  }\n}\nint minsearch(num *A,int n,int group)//サイクル外の最小値を返す\n{\n    int i,min=INT_MAX;\n    group--;\n    for(i=0;i<n;i++){\n        if(A[i].c!=group&&min>A[i].b) min=A[i].b;\n    }\n    return min;\n}\n\nint main(void)\n{\n    int n,i,j;\n    num A[500001];//荷物の情報を格納\n    int left,right;\n    int box=0,start,sum=0;\n    int min=INT_MAX,cnt=0,S,T,group=0;\n    \n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++) {\n    \tscanf(\"%d\",&A[i].b);\n    \tA[i].a=i;\n    \tA[i].c=-1;\n    }\n    \n    left=0;\n    right=n;\n    mergeSort(A,left,right);\n    \n    for(i=0;i<n;i++)\n    {\n        if(A[i].c==-1){//サイクルグループに属していない場合\n    \t    if(i!=A[i].a){//入れ替える必要がある場合サイクルを探索\n    \t\t    start=i;\n    \t    \tj=i;\n    \t\t    for(;;){\n    \t\t\t    box+=A[j].b;\n    \t\t\t    if(min>A[j].b) min=A[j].b;\n    \t\t\t    A[j].c=group;\n    \t\t\t    cnt++;\n    \t\t\t    if(start==A[j].a){\n    \t\t\t       group++;\n    \t\t\t       break;\n    \t\t    \t}\n    \t\t\t    j=A[j].a;\n    \t\t    }\n    \t        S=box+min+(cnt+1)*minsearch(A,n,group);// サイクル外から最小値を借りた場合\n    \t        T=min*(cnt-2)+box;//借りない場合\n    \t        if(S>T||S<0) sum+=T;\n    \t        else sum+=S;\n            }else{//移動しない場合\n    \t        A[i].c=group;\n    \t        group++;\n    \t    }\n    \t    min=INT_MAX;\n    \t    box=0;\n    \t    cnt=0;\n        }\n    }\n    printf(\"%d\\n\",sum);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ ALDS1_6_D Minimum Cost Sort\n// 2018.5.4 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\nint in()\n{\n\tint n = 0, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\nint cmp(int *a, int *b) { return *a - *b; }\nint min_cost_sort(int n, int *w, int min, int max)\n{\n\tint i, s, t, t1, t2, m, an, cur, ans;\n\tint *a, *v;\n\tchar *f;\n\n\ta = malloc(n<<2), f = malloc(n), v = malloc((max+1)<<2);\n\tmemcpy(a, w, n<<2), memset(f, 0, n);\n\n\tqsort(a, n, sizeof(int), cmp);\n\tfor (i = 0; i < n; i++) v[a[i]] = i;\n\n\tans = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tif (f[i]) continue;\n\t\tcur = i, s = 0, m = max, an = 0;\n\t\twhile (1) {\n\t\t\tf[cur] = 1, an++, t = w[cur];\n\t\t\tif (t < m) m = t;\n\t\t\ts += t, cur = v[t];\n\t\t\tif (f[cur]) break;\n\t\t}\n\t\tt1 = s+(an-2)*m, t2 = m+s+(an+1)*min;\n\t\tans += (t1 < t2)? t1: t2;\n\t}\n\tfree(a), free(f), free(v);\n\treturn ans;\n}\n\nint w[1002];\n\nint main()\n{\n\tint n, i, _w, min, max;\n\n\tn = in();\n\tmin =  0x10101010;\n\tmax = -0x10101010;\n\tfor (i = 0; i < n; i++) {\n\t\tw[i] = _w = in();\n\t\tif (_w < min) min = _w;\n\t\tif (_w > max) max = _w;\n\t}\n\tprintf(\"%d\\n\", min_cost_sort(n, w, min, max));\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstatic const int MAX=1000;\nstatic const int VMAX=10000;\n\nint n, A[MAX],s;\nint B[MAX],T[VMAX+1];\n\nint solve() {\n  int ans=0;\n  bool V[MAX];\n  for (int i=0; i<n; i++) {\n    B[i]=A[i];\n    V[i]=false;\n  }\n  sort(B,B+n);\n  for (int i=0; i<n; i++) {\n    T[B[i]]=i;\n  }\n  for (int i=0; i<n; i++) {\n    if (V[i]) {\n      continue;\n    }\n    int cur=i;\n    int S=0;\n    int m=VMAX;\n    int an=0;\n    while (true) {\n      V[cur]=true;\n      an++;\n      int v=A[cur];\n      m=min(m,v);\n      S+=v;\n      cur=T[v];\n      if (V[cur]) {\n        break;\n      }\n    }\n    ans+=min(S+(an-2)*m,m+S+(an+1)*s);\n  }\n  return ans;\n}\nint main() {\n  cin>>n;\n  s=VMAX;\n  for (int i=0; i<n; i++) {\n    cin>>A[i];\n    s=min(s,A[i]);\n  }\n  int ans=solve();\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#define TRUE 1\n#define FALSE 0\n#define MAX 1000\n#define VMAX 10000\n\nint n, A[MAX], s;\nint B[MAX], T[VMAX + 1];\n\nint solve(){\n  int i, j, tmp, ans = 0;\n  int V[MAX];\n  for(i = 0; i < n; i++){\n    B[i] = A[i];\n    V[i] = FALSE;\n  }\n  for(i = 0; i < n; ++i){\n    for(j = i + 1; j < n; ++j){\n      if(B[i] > B[j]){\n\ttmp = B[i];\n\tB[i] = B[j];\n\tB[j] = tmp;\n      }\n    }\n  }\n  for(i = 0; i < n; i++) T[B[i]] = i;\n  for(i = 0; i < n; i++){\n    if(V[i] == TRUE) continue;\n    int cur = i;\n    int S = 0;\n    int m = VMAX;\n    int an = 0;\n    while(1){\n      V[cur] = TRUE;\n      an++;\n      int v = A[cur];\n      m = (int)fmin(m, v);\n      S += v;\n      cur = T[v];\n      if(V[cur] == TRUE) break;\n    }\n    ans += (int)fmin(S + (an - 2) * m, m + S + (an + 1) * s);\n  }\n\n  return ans;\n}\n\nint main(){\n  int i;\n  scanf(\"%d\",&n);\n  s = VMAX;\n  for(i = 0; i < n; i++){\n    scanf(\"%d\",&A[i]);\n    s = (int)fmin(s, A[i]);\n  }\n  int ans = solve();\n  printf(\"%d\\n\",ans);\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstatic const int MAX=1000;\nstatic const int VMAX=10000;\n\nint n, A[MAX],s;\nint B[MAX],T[MAX+1];\n\nint solve() {\n  int ans=0;\n  bool V[MAX];\n  for (int i=0; i<n; i++) {\n    B[i]=A[i];\n    V[i]=false;\n  }\n  sort(B,B+n);\n  for (int i=0; i<n; i++) {\n    T[B[i]]=i;\n  }\n  for (int i=0; i<n; i++) {\n    if (V[i]) {\n      continue;\n    }\n    int cur=i;\n    int S=0;\n    int m=VMAX;\n    int an=0;\n    while (true) {\n      V[cur]=true;\n      an++;\n      int v=A[cur];\n      m=min(m,v);\n      S+=v;\n      cur=T[v];\n      if (V[cur]) {\n        break;\n      }\n    }\n    ans+=min(S+(an-2)*m,m+S+(an+1)*S);\n  }\n  return ans;\n}\nint main() {\n  cin>>n;\n  s=VMAX;\n  for (int i=0; i<n; i++) {\n    cin>>A[i];\n    s=min(s,A[i]);\n  }\n  int ans=solve();\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <string.h>\n\n#define MAX 1000\n#define INF INT_MAX\n\nint solve(int*, int);\nint check(int*,int);\n\nint main(){\n  int n, i, arr[MAX];\n\n  scanf(\"%d\" ,&n);\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%d\" ,arr + i);\n  }\n  printf(\"%d\\n\" ,solve(arr, n));\n\n  return 0;\n}\n\nint check(int arr[], int n){\n  int i;\n\n  for(i = 0 ; i < n ; i++){\n    if(arr[i] != i-1){\n      return 0;\n    }\n  }\n  return 1;\n}\n\nint solve(int arr[], int n){\n  int i, j, res = 0, tmp, used[MAX], min = INF, pos, flg;\n\n  memset(used, 0, sizeof(used));\n\n  for(i = 0 ; i < n-1 ; i++){\n    flg = 0;\n    if(arr[i] == i+1){\n      used[i] = 1;\n      continue;\n    }\n\n    for(j = i+1 ; j < n ; j++){\n      if(arr[j] == j+1 || used[j]){\n        used[j] = 1;\n        continue;\n      }\n\n      pos = -1;\n      if(arr[i] == j+1 && arr[j] == i+1){\n        tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n        res += arr[i] + arr[j];\n        flg = 1;\n        break;\n      }else{\n        if(arr[i] + arr[j] < min){\n          min = arr[i] + arr[j];\n          pos = j;\n        }\n      }\n    }\n    if(pos != -1 && !flg){\n      tmp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = tmp;\n      res += arr[i] + arr[j];\n    }\n  }\n\n  if(check(arr, n)){\n    return res;\n  }else{\n    return res += solve(arr, n);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n  \n  \n  \nint n,cost;\nint A[1001],B[1001];\nint L[501],R[502];\n  \n  \nvoid merge(int left,int mid,int right){\n  int i,j,n1=mid-left,n2=right-mid;\n  for(i=0;i<n1;i++) L[i]=A[left+i];\n  L[n1]=INT_MAX;\n  for(i=0;i<n2;i++) R[i]=A[mid+i];\n  R[n2]=INT_MAX;\n  int l=0,r=0;\n  for(i=left;i<right;i++){\n    if(L[l]<=R[r]){\n      A[i]=L[l];\n      l++;\n    }\n    else{\n      A[i]=R[r];\n      r++;\n    }\n  }\n}\n  \n  \nvoid m_sort(int left,int right){\n  int mid;\n  if( left+1 >= right) return;\n  mid=(left+right)/2;\n  m_sort(left,mid);\n  m_sort(mid,right);\n  merge(left,mid,right);\n}\n  \n  \nvoid swap(int a,int b,int *C){\n  int swap;\n  swap=C[a];\n  C[a]=C[b];\n  C[b]=swap;\n}\n  \n  \n  \n  \n  \n  \n    \n   \n    \n  \nint main(){\n  scanf(\"%d\",&n);\n  int i,j;\n  int cnt,sum,min,start,x;\n  int C[1001]={};\n  for(i=0;i<n;i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n  m_sort(0,n);\n  for(i=0;i<n;i++){\n    if(A[i]==B[i]) C[i]=1;\n  }\n  cost=0;\n  for(i=0;i<n;i++){\n    if(C[i]!=1){\n      C[i]=1;\n      cnt=0;\n      sum=0;\n      min=B[i];\n      x=i;\n      while(1){\n        for(j=0;j<n;j++){\n          if(B[x]==A[j]){\n            C[j]=1;\n            cnt++;\n            sum+=B[j];\n            if(min > B[j]) min=B[j];\n            x=j;\n            break;\n          }\n        }\n        if(x==i) break;\n      }\n      sum-=min;\n      if( (cnt -1)*min > (cnt -1)*A[0]+2*(min +A[0])) cost+=sum+(cnt-1)*A[0]+2*(min +A[0]);\n      else cost+=sum+(cnt-1)*min;\n    }\n  }\n  printf(\"%d\\n\",cost);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include<stdio.h>\n#include<stdlib.h>\n\nint main() {\n\tint *W, n,i,j,jTmp,min,tmp,cost=0;\n\n\tscanf(\"%d\", &n);\n\tW = (int*)malloc(sizeof(int)*n);\n\tfor (i = 0; i < n; i++)scanf(\"%d\", &W[i]);\n\n\tfor (i = 0; i < n-1; i++) {\n\t\tmin = W[i];\n\t\tjTmp = i;\n\t\tfor (j = i+1; j < n; j++) {\n\t\t\tif(min>W[j]){\n\t\t\t\tmin = W[j];\n\t\t\t\tjTmp = j;\n\t\t\t}\n\t\t}\n\t\tif (i != jTmp) {\n\t\t\ttmp = W[i]; W[i] = W[jTmp]; W[jTmp] = tmp;\n\t\t\tcost += W[i] + W[jTmp];\n\t\t}\n\t}\n\tprintf(\"%d\\n\", cost);\n\tfree(W);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\n#define MAX 1000\n\nint selectionSort(int *A,int n){\n  int i,j,min,tmp;\n  int cost=0;\n  for(i=0;i<n;i++){\n    min=i;\n    for(j=i;j<n;j++){\n      if(A[j]<A[min]) min=j;\n    }\n      tmp=A[i];\n      A[i]=A[min];\n      A[min]=tmp;\n      if(A[i]!=A[min]) cost+=A[i]+A[min];\n  }\n  return cost;\n}    \n\nint main(){\n  int n,cost,i;\n  int A[MAX];\n\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++) scanf(\"%d\",&A[i]);\n  cost=selectionSort(A,n);\n  printf(\"%d\\n\",cost);\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 1000\n\nint n,A[N],B[N],C[N],con,res,min;\n\nvoid swap(int* A,int* B)\n{\n  int ch;\n  ch=*A;\n  *A=*B;\n  *B=ch;\n}\nint small(int a,int b)\n{\n  if(a<b)return a;\n  else return b;\n}\n\nint search(int a)\n{\n  int i;\n  for(i=0; i<n; i++){\n    if(A[i]==a)return i;\n  }\n}\n\nint main()\n{\n  int i,j,sum=0,p;\n\n  scanf(\"%d\",&n);\n\n  for(i=0; i<n; i++){\n    scanf(\"%d\",&A[i]);\n    B[i]=A[i];\n  }\n\n  for(i=n-1; i>0; i--){\n    for(j=0; j<i; j++){\n      if(B[j]>B[j+1]) swap(&B[j],&B[j+1]);\n    }\n  }\n\n  for(i=0; i<n; i++)C[i]=0;\n\n  for(i=0; i<n; i++){\n    p=i;\n    con=res=0;\n    min=(1<<24);\n\n    while(C[p]==0){\n      C[p]=1;\n      con++;\n      res+=A[p];\n      min=small(min,A[p]);\n      p=search(B[p]);\n    }\n\n    if(con<2)continue;\n    sum+=small(res+B[0]*(con+1)+min,res+min*(con-2));\n  }\n\n  printf(\"%d\\n\",sum);\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 1000\ntypedef struct {\n  int sum;\n  int flag;\n} CC;\nCC C[N];\nint A[2000],B[2000];\nint main()\n{\n  int i,n,min=0,m,k,now,sum=0;\n  scanf(\"%d\",&n);\n  for(i=1;i<n+1;i++){\n    scanf(\"%d\",&A[i]);\n  }\n  \n  for(i=0;i<N;i++){\n    C[i].sum=0;\n    C[i].flag=0;\n  }\n  for(i=1;i<n+1;i++){\n    C[A[i]].sum+=1;\n    C[A[i]].flag+=1;\n  }\n  for(i=0;i<N;i++){\n    C[i].sum+=C[i-1].sum;\n  }\n\n  for(i=n+1;i>0;i--){\n    if(C[A[i]].flag==1){\n      k=i;\n      now=k;\n      m=0;\n      B[C[A[k]].sum]=A[k];\n      C[A[i]].flag=0;\n      min=A[k];\n      k=C[A[k]].sum;\n      while(now!=k){\n        if(m==0)sum+=A[now];\n        B[C[A[k]].sum]=A[k];\n        C[A[k]].flag=0;\n        sum+=A[k];\n        if(min>A[k])min=A[k];\n        k=C[A[k]].sum;\n        m+=1;\n      }\n      if(m>2)sum+=min*(m-1);\n      m=0;\n      min=0;\n    }\n  }\n  /*for(i=1;i<n;i++){\n    printf(\"%d \",B[i]);\n  }\n  printf(\"%d\",B[i]);*/\n  printf(\"%d\\n\",sum);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\n//============================================================================\n#define pred(x) ((x)-1)\n#define succ(x) ((x)+1)\n//============================================================================\ntypedef unsigned char  INT8U;\ntypedef unsigned short INT16U;\ntypedef   signed short INT16S;\ntypedef long INT32;\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nINT16U *C;\n//----------------------------------------------------------------------------\nvoid CountingSort(INT16U *A, INT16U *B,  INT16U n, INT16U k)\n{\n    long i;\n\n    for (i = 0; i<n; i++)\n        C[A[i]]++;\n    for (i = 1; i<=k; i++)\n        C[i] += C[i-1];\n    // C holds position of A\n    // C[A[val]] = pred val position\n\n    /*for (i = 1; i<=k; i++)\n        printf(\"%d \", C[i]);\n    printf(\"\\n\");*/\n    /*printf(\"B[C[A[i]]-1] = A[i];\\n\");\n    for (i=n-1; 0<=i; i--){\n        //B[C[A[i]]-1] = A[i];\n        printf(\"B[%d]=%d C[%d]=%d A[%d]=%d\\n\", C[A[i]]-1, A[i],\n                            A[i], C[A[i]], i, A[i]);\n        //C[A[i]]--;\n    }*/\n}\n//----------------------------------------------------------------------------\nINT16S getminptr(INT16U *A, INT16U N)\n{\n    INT16U i,min; INT16S ptr;\n\n    for (i=0, ptr=-1, min=32767; i<N; i++){\n        if (A[i]<min && pred(C[A[i]])!=i){\n            min=A[i];\n            ptr=i;\n        }\n    }\n    return ptr;\n}\n//----------------------------------------------------------------------------\nlong sum;\nvoid exchange(INT16U *x, INT16U *y)\n{\n    INT16U z;\n\n    z=*x, *x=*y, *y=z;\n    sum+=*x;\n    sum+=*y;\n    //printf(\"ex: %d<-->%d, sum:%ld\\n\", *y, *x, sum);\n}\n//----------------------------------------------------------------------------\nvoid prnary(INT16U *A, INT16U N)\n{\n    int j;\n\n    for (j=0; j<N; j++)\n        printf(\"%2d \", A[j]);\n    printf(\" sum:%ld\\n\", sum);\n}\n//----------------------------------------------------------------------------\nshort linklen(INT16U *A, INT16U N, INT16U val)\n{\n    int idx,n;\n\n\n    for (n=0, idx=val; ; n++){\n        idx=A[pred(C[idx])];\n        if (idx==val)\n            return n;\n    }\n}\n//----------------------------------------------------------------------------\nvoid duplication(INT16U *A, INT16U N)\n{\n    int i,j,k,n,a,ary[3];\n\n#ifdef DESKTOP\n    prnary(A, N);\n#endif\n    for (i=sum=0; i<pred(N); i++){\n        n=linklen(A, N, A[i]);\n        if (n==1){\n            j=pred(C[A[i]]);\n            exchange(&A[i], &A[j]);\n            printf(\"ex:(%d<->%d), \", A[i], A[j]);\n        }else\n        if (n==2){\n            ary[0]=i;\n            ary[1]=pred(C[A[i]]);\n            ary[2]=pred(C[A[ary[1]]]);\n            for (j=a=0,k=20000; j<3; j++)\n            if (A[ary[j]]<k){\n                k=A[ary[j]];\n                a=ary[j];\n            }\n            j=pred(C[A[a]]);\n            k=pred(C[A[j]]);\n            if (A[j]<A[k]){\n                //printf(\"ex:(%d<->%d), \", A[a], A[k]); // 44<>96\n                exchange(&A[a], &A[k]);\n            }else{\n                //printf(\"ex:(%d<->%d), \", A[a], A[j]); // 44<>96\n                exchange(&A[a], &A[j]);\n            }\n            //printf(\"ex:(%d<->%d), \", A[k], A[j]); // 44<>96\n            exchange(&A[k], &A[j]);\n        }\n#ifdef DESKTOP\n    }\n    printf(\"\\n\");\n#else\n    }\n#endif\n}\n//----------------------------------------------------------------------------\nlong mincostsort(INT16U *A, INT16U N)\n{\n    int ptr,i,j,min,ordptr,order[100];\n\n    duplication(A, N);\n    for (i=0,j=32000; i<N; i++)\n        if (A[i]<j)\n            j=A[i],min=i;\n    for (ordptr=0; 0<=(ptr=getminptr(A, N));){\n#ifdef DESKTOP\n    printf(\"[%d]\\n\", A[ptr]);\n#endif\n        order[ordptr++]=A[ptr];\n        if (A[min]*2<A[ptr]){\n            exchange(&A[min], &A[ptr]);\n            min=ptr;\n        }\n        while (pred(C[A[ptr]])!=ptr){\n            for (i=0; i<N; i++)\n                if (C[A[i]]==succ(ptr)){\n                    order[ordptr++]=A[i];\n                    if (ptr==min) min=i;\n                    exchange(&A[ptr], &A[i]);\n                    ptr=i;\n#ifdef DESKTOP\n                    //prnary(A, N);\n#endif\n                    break;\n                }\n        }\n    }\n#ifdef DESKTOP\n    for (i=0; i<ordptr; i++){\n        if (i) printf(\"->\");\n            printf(\"%d\", order[i]);\n    }\n    printf(\"\\n\");\n#endif\n    return sum;\n}\n//----------------------------------------------------------------------------\n/*\n*                                         *     *\n0 62 33 29 72 52 43 19 5  93 51 32  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51  5  8 11 56 47 66 69 30 17 68  5\n0 62 33 29 72 52 43 19 32 93 51 47  8 11 56  5 66 69 30 17 68  5\n0  5 33 29 72 52 43 19 32 93 51 47  8 11 56 62 66 69 30 17 68  0\n0  5 33 29 72 52 43 19 32 93  8 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 29 72 52  8 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33  8 72 52 29 19 32 93 43 47 51 11 56 62 66 69 30 17 68  8\n0  5 33 11 72 52 29 19 32 93 43 47 51  8 56 62 66 69 30 17 68  8\n0  5 33 11 72  8 29 19 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29  8 32 93 43 47 51 52 56 62 66 69 30 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 69  8 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66  8 69 17 68  8\n0  5 33 11 72 19 29 30 32 93 43 47 51 52 56 62 66 68 69 17  8  8\n0  5 33 11 72 19 29 30 32  8 43 47 51 52 56 62 66 68 69 17 93  8\n0  5  8 11 72 19 29 30 32 33 43 47 51 52 56 62 66 68 69 72 93  0\n0  5  8 11 17 19 29 30 32 33 43 47 51 52 56 62 66 68 69 17 93  0\n\n 1 80 50 70 40 20\n20 80 50 70 40  1\n20  1 50 70 40 80\n 1 20 50 70 40 80 21        20 40 50 70  1 80   41\n40 20 50 70  1 80 41        20 40 50  1 70 80   71\n40 20 50  1 70 80 71        20 40  1 50 70 80   51\n40 20  1 50 70 80 51        20  1 40 50 70 80   41\n 1 20 40 50 70 80 41         1 20 40 50 70 80   21\n\n\n5\n1 5 3 4 2\n7\n\n4\n4 3 2 1\n10\n*/\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\nvoid input(FILE *file)\n{\n    long i,n,max,ave; INT16U *A, *B; char buffer[20];\n\n    fgets(buffer, sizeof(buffer)-1, file);\n    sscanf(buffer, \"%ld\", &n);\n    A = malloc(succ(n)*sizeof(INT16U));\n    B = malloc(succ(n)*sizeof(INT16U));\n    for (i=ave=max=0; i<n; i++){\n        fscanf(file, \"%hd\",  &A[i]);\n        if (max<A[i])\n            max=A[i];\n        ave+=A[i];\n    }\n    ave/=n;\n    C = malloc(succ(max)*sizeof(INT16U));\n    memset(C, 0, sizeof(INT16U)*succ(max));\n    CountingSort(A, B, n, max);\n    printf(\"%ld\\n\", mincostsort(A, n));\n#ifdef DESKTOP\n    for (i=0; i<n; i++){\n        if (i) printf(\" \");\n        printf(\"%hd\", A[i]);\n    }\n    printf(\"\\n\");\n#endif\n    free(A);\n    free(B);\n    free(C);\n}\n//============================================================================\n#ifndef DESKTOP\nint main()\n{\n    input(stdin);\n    return 0;\n}\n#endif"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\nint in()\n{\n    int n = 0, c = gc();\n    do n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n    return n;\n}\n \nint cmp(int *a, int *b) { return *a - *b; }\nint min_cost_sort(int n, int *w, int min, int max)\n{\n    int i, s, t, t1, t2, m, an, cur, ans;\n    int *a, *v;\n    char *f;\n \n    a = malloc(n<<2), f = malloc(n), v = malloc((max+1)<<2);\n    memcpy(a, w, n<<2), memset(f, 0, n);\n \n    qsort(a, n, sizeof(int), cmp);\n    for (i = 0; i < n; i++) v[a[i]] = i;\n \n    ans = 0;\n    for (i = 0; i < n; i++) {\n        if (f[i]) continue;\n        cur = i, s = 0, m = max, an = 0;\n        while (1) {\n            f[cur] = 1, an++, t = w[cur];\n            if (t < m) m = t;\n            s += t, cur = v[t];\n            if (f[cur]) break;\n        }\n        t1 = s+(an-2)*m, t2 = m+s+(an+1)*min;\n        ans += (t1 < t2)? t1: t2;\n    }\n    free(a), free(f), free(v);\n    return ans;\n}\n \nint w[1002];\n \nint main()\n{\n    int n, i, _w, min, max;\n \n    n = in();\n    min =  0x10101010;\n    max = -0x10101010;\n    for (i = 0; i < n; i++) {\n        w[i] = _w = in();\n        if (_w < min) min = _w;\n        if (_w > max) max = _w;\n    }\n    printf(\"%d\\n\", min_cost_sort(n, w, min, max));\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX 10001\n\ntypedef struct{\n  int kazu;\n  int hantei;\n}weight;\n  \nint Kosu[MAX],Doko1[MAX],Doko2[MAX+1];\n\nint main()\n{\n  int n,i,j,basho=0,min,min2,hazime,sumW=0,w1,w2,omosa,irekae,kosu,SUM=0;\n\n  scanf(\"%d\",&n);\n\n  int seiretu[n];\n  weight Wi[n];\n\n  /*整列させてる(Counting Sort)*/\n  \n  for(i=0;i<n;i++)\n    {\n      scanf(\"%d\",&Wi[i].kazu);\n      Wi[i].hantei=0;\n      Kosu[Wi[i].kazu]++;\n    }\n  \n  for(i=0;i<10001;i++)\n    {\n      basho+=Kosu[i];\n      Doko1[i]=basho-1;\n      Doko2[i]=Doko1[i];\n    }\n\n  for(i=0;i<n;i++)\n    {\n      seiretu[ Doko1[Wi[i].kazu] ]=Wi[i].kazu;\n      Doko1[Wi[i].kazu]--;\n    }\n\n  /*最小コストをもとめる*/\n\n  min=seiretu[0];\n\n  for(i=0;i<n;i++)\n    {\n      if(Wi[i].kazu!=seiretu[i]&&Wi[i].hantei==0)\n\t{\n\t  /*初期化*/\n\t  j=1001;\n\t  kosu=0;\n\t  sumW=0;\n\t  min2=10001;\n\t  omosa=Wi[i].kazu;\n\t  Wi[i].hantei=1;\n\t  \n\t  while(j!=i)\n\t    {\n\t      kosu++;\n\t      if(min2>omosa)min2=omosa;\n\t      sumW+=omosa;\n\t      for(j=0;j<n;j++)\n\t\t{\n\t\t  if(omosa==seiretu[j])break;\n\t\t}\n\t      Wi[j].hantei=1;\n\t      omosa=Wi[j].kazu;\n\t    }\n\t  \n\t  w1=sumW+( (kosu-2)*min2 );\n\t  w2=sumW+min2+( (kosu+1)*min );\n\t  \n\t  if(w1<w2)SUM+=w1;\n\t  else SUM+=w2;\n\t}\n    }\n\n  printf(\"%d\\n\",SUM);\n\t  \n      \n  return 0;\n}\n\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args: Array<String>) {\n    readLine()\n    val xs = readLine()!!.split(' ').map { it.toInt() }\n    println(minimumCostSort(xs))\n}\n\nprivate const val MAX = 10000\n\nprivate fun minimumCostSort(xs: List<Int>): Int {\n\n    val sorted = xs.sorted()\n    val table = IntArray(MAX + 1)\n    val visited = BooleanArray(xs.size) { false }\n\n    var min = MAX\n\n    for (i in 0 until xs.size) {\n        min = minOf(min, xs[i])\n        table[sorted[i]] = i\n    }\n\n    var ans = 0\n\n    for (i in 0 until xs.size) {\n        if (visited[i]) continue\n\n        var cur = i\n        var s = 0\n        var m = MAX\n        var n = 0\n        while (true) {\n            visited[cur] = true\n            n++\n            val v = xs[cur]\n            m = minOf(m, v)\n            s += v\n            cur = table[v]\n            if (visited[cur]) break\n        }\n\n        ans += minOf(s + (n - 2) * m, s + m + (n + 1) * min)\n    }\n\n    return ans\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Main {\n\t\n\tpublic static class Arr implements Comparable<Arr> {\n\t\tint[] array;\n\t\tint cost;\n\t\t\n\t\tpublic Arr(int[] array, int cost) {\n\t\t\tsuper();\n\t\t\tthis.array = array;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\tpublic boolean is_finished(){\n\t\t\tfor(int i = 1; i < array.length; i++){\n\t\t\t\tif(array[i - 1] > array[i]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Arr arg0) {\n\t\t\treturn this.cost - arg0.cost;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\n\t\tfinal int n = sc.nextInt();\n\t\tint[] array = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tarray[i] = sc.nextInt();\n\t\t}\n\t\t\n\t\t\n\t\tPriorityQueue<Arr> queue = new PriorityQueue<Arr>();\n\t\tqueue.add(new Arr(array, 0));\n\t\t\n\t\twhile(!queue.isEmpty()){\n\t\t\tfinal Arr arr = queue.poll();\n\t\t\t\n\t\t\tif(arr.is_finished()){\n\t\t\t\tSystem.out.println(arr.cost);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < arr.array.length; i++){\n\t\t\t\tfor(int j = i + 1; j < arr.array.length; j++){\n\t\t\t\t\tint[] next = new int[arr.array.length];\n\t\t\t\t\tSystem.arraycopy(arr.array, 0, next, 0, arr.array.length);\n\t\t\t\t\tint tmp = next[i];\n\t\t\t\t\tnext[i] = next[j];\n\t\t\t\t\tnext[j] = tmp;\n\t\t\t\t\t\n\t\t\t\t\tqueue.add(new Arr(next, arr.cost + next[i] + next[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n\tpublic static class Scanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\tstatic final int MAX = 1000;\n\tstatic final int VMAX = 100000;\n\n\tstatic int n, s;\n\tstatic int []A = new int[MAX];\n\tstatic int []B = new int[MAX];\n\tstatic int []T = new int[VMAX + 1];\n\tstatic int solve() {\n\t\tint ans = 0;\n\t\tboolean []V = new boolean[MAX];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tB[i] = A[i];\n\t\t\tV[i] = false;\n\t\t}\n\t\tArrays.sort(B, 0, n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tT[B[i]] = i;\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(V[i]) continue;\n\t\t\tint cur = i;\n\t\t\tint S = 0;\n\t\t\tint  m = VMAX;\n\t\t\tint an = 0;\n\t\t\twhile(true) {\n\t\t\t\tV[cur] = true;\n\t\t\t\tan ++;\n\t\t\t\tint v = A[cur];\n\t\t\t\tm = Math.min(m, v);\n\t\t\t\tS += v;\n\t\t\t\tcur = T[v];\n\t\t\t\tif(V[cur]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tans += Math.min(S + (an - 2) * m, m + S + (an + 1) * s);\n\t\t}\n\t\treturn ans;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tn = scan.nextInt();\n\t\ts = VMAX;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tA[i] = scan.nextInt();\n\t\t\ts = Math.min(s, A[i]);\n\t\t}\n\t\tscan.close();\n\t\tint ans = solve();\n\t\tSystem.out.println(ans);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in); \n\n\t\tint n = sc.nextInt();\n\t\tint[] w = new int[n];\n\t\tHashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();\n\t\t\n    \tfor (int i = 0; i < n; i++) {\n    \t\tw[i] = sc.nextInt();\n    \t\thm.put(w[i], i);\n    \t}\n    \t\n    \tint[] sort = w.clone();\n    \tArrays.sort(sort);\n\n    \tint ret = 0;\n    \tfor (int i = n - 1; i >= 0; i--) {\n    \t\tint max = sort[i];\n    \t\tint maxi = hm.get(sort[i]);\n    \t\tif (maxi != i) {\n    \t\t\tint tmp = w[i];\n//    \t\t\tint tmpi = hm.get(w[i]);\n    \t\t\tw[i] = max;\n    \t\t\thm.put(w[i], i);\n    \t\t\tw[maxi] = tmp;\n    \t\t\thm.put(tmp, maxi);\n    \t\t\t\n    \t\t\tret += max + tmp;\n    \t\t}\n    \t}\n\n    \tSystem.out.println(ret);\n    \t\n        sc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n    public static void main(String [] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int [] W = new int[n];\n        for(int i=0;i<n;i++)W[i] = sc.nextInt();\n        System.out.println(minsort(W));\n    }\n    public static int minsort(int [] W){\n        int cost = 0;\n        int [] sorted = W.clone();\n        Arrays.sort(sorted);\n        for(int i=0;i<W.length;i++){\n            int cnt = 0;\n            int x = getindex(W,sorted[i]);\n            while(x>i){\n                cnt++;\n                int y = getindex(W,sorted[x]);\n                cost+=W[y];\n                swap(W,x,y);\n                x = y;\n            }\n            cost+=Math.min(sorted[i]*cnt,sorted[i]*2+sorted[0]*(cnt+2));\n        }\n        return cost;\n    }\n    public static void swap(int [] W,int i,int j){\n        int w = W[i];\n        W[i] = W[j];\n        W[j] = w;\n    }\n    public static int getindex(int [] L,int num){\n        for(int i=0;i<L.length;i++){\n            if(L[i] == num) return i;\n        }\n        return -1;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int size = scan.nextInt(), r = 0;\n        int arr[][] = new int[size][2];\n        for(int i = 0; i < size; i++){\n            arr[i][0] = scan.nextInt(); arr[i][1] = i;\n        }\n        int arrsorted[][] = arr.clone();\n        Arrays.sort(arrsorted, Comparator.comparing((int[] iarr) -> iarr[0]));\n        for(int i = size - 1; 0 <= i; i--)\n            if(arr[i][1] != arrsorted[i][1]){\n                r += arr[i][0] + arr[arrsorted[i][1]][0];\n                arr[arrsorted[i][1]] = arr[i];\n                arr[i][1] = arrsorted[i][1];\n                arr[i] = arrsorted[i];\n                arr[i][1] = i;\n            }\n        System.out.println(r);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\t// ??°?????????????????¨?????????????????????????????????????????????????´????????????????????????????????????????\n\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\tint n = scanner.nextInt();\n\t\tint count = 0;\n\t\tint[] list = new int[n];\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlist[i] = scanner.nextInt();\n\t\t\t// ????°?????????????????????????????????????????°?????????????\n\t\t\tif (list[i] < min) {\n\t\t\t\tmin = list[i];\n\t\t\t}\n\t\t}\n\t\tint[] sortedList = (int[]) list.clone();\n\t\t// ???????????????????´???°???????????????????????????????????????????????????????????????????????????\n\t\tmergeSort(sortedList, 0, n);\n\t\t// ??????????????????????????¨?????????????´????????´??????????????????????\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmap.put(sortedList[i], i);\n\t\t}\n\t\tboolean flag = true;\n\t\tint time = 1;\n\t\t// ????????¨\n\t\tdo {\n\t\t\tif (min != list[0]) {\n\t\t\t\tflag = true;\n\t\t\t\tint tempIndex = 0;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (list[i] == min) {\n\t\t\t\t\t\ttempIndex = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (sortedList[tempIndex] == list[j]) {\n\t\t\t\t\t\tint temp = list[j];\n\t\t\t\t\t\t//System.out.println(\"\\n\" + temp + \"??¨\" + min + \"?????????\" + time + \"??????\");\n\t\t\t\t\t\tlist[j] = min;\n\t\t\t\t\t\tlist[tempIndex] = temp;\n\t\t\t\t\t\tcount = count + list[j] + list[tempIndex];\n\t\t\t\t\t\ttime++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (k != map.get(list[k])) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t}\n/*\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tSystem.out.print(list[i]);\n\t\t\t\t}*/\n\t\t\t} else {\n\t\t\t\tflag = true;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (i != map.get(list[i])) {\n\t\t\t\t\t\tint temp = list[i];\n\t\t\t\t\t\tint ind = map.get(list[i]);\n\t\t\t\t\t\tint temp2 = list[ind];\n\t\t\t\t\t\tlist[i] = temp2;\n\t\t\t\t\t\tlist[ind] = temp;\n\t\t\t\t\t\tcount = count + temp + temp2;\n\t\t\t\t\t\t//System.out.println(temp + \"??¨\" + temp2 + \"?????????\" + time + \"??????\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (k != map.get(list[k])) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} while (flag != true);\n\t\tSystem.out.println(count);\n\t}\n\n\t// ????¨??????????????????????????????????\n\tstatic void merge(int[] numList, int left, int mid, int right) {\n\t\tint n1 = mid - left;\n\t\tint n2 = right - mid;\n\t\tint[] L = new int[n1 + 1];\n\t\tint[] R = new int[n2 + 1];\n\n\t\tfor (int i = 0; i < n1; i++) {\n\t\t\tL[i] = numList[left + i];\n\t\t}\n\n\t\tfor (int i = 0; i < n2; i++) {\n\t\t\tR[i] = numList[mid + i];\n\t\t}\n\n\t\tL[n1] = Integer.MAX_VALUE;\n\t\tR[n2] = Integer.MAX_VALUE;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\t// L??¨R??????????????????????°????????????????numList???????´??????????\n\t\t// ?°?????????????????????????????????????????¬??????????????????????????????????????´????????????????????????°?????????+1?????????\n\t\tfor (int k = left; k < right; k++) {\n\t\t\tif (L[i] <= R[j]) {\n\t\t\t\tnumList[k] = L[i];\n\t\t\t\ti = i + 1;\n\t\t\t} else {\n\t\t\t\tnumList[k] = R[j];\n\t\t\t\tj = j + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// ????¨????merge???????????????????±??????????????°?????´???????(left)??¨?????§????´???????(right)?????????-1??????????????§??°????????????\n\tstatic void mergeSort(int[] numList, int left, int right) {\n\t\tif ((left + 1) < right) {\n\t\t\tint mid = (left + right) / 2;\n\n\t\t\tmergeSort(numList, left, mid);\n\t\t\t// System.out.println(\"???\");\n\t\t\tmergeSort(numList, mid, right);\n\t\t\t// System.out.println(\"???\");\n\t\t\tmerge(numList, left, mid, right);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\nclass Main{\n    public static void main(String[] args) throws IOException{\n        final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        final int n = Integer.parseInt(br.readLine());\n        final Bug[] A = new Bug[n];\n        final boolean[] found = new boolean[n];\n        final StringTokenizer in = new StringTokenizer(br.readLine(), \" \");\n        for(int i = 0; i<n; i++)\n            A[i] = new Bug(Integer.parseInt(in.nextToken()), i);\n        Arrays.sort(A);\n        int cost = 0;\n        final int min = A[0].weight;\n        for(int i = 0; i<n; i++){\n            if(found[i]) continue;\n            found[i] = true;\n            int m = 0;\n            for(int j = A[i].index; j!=i; j = A[j].index){\n                found[j] = true;\n                cost += A[j].weight;\n                m++;\n            }\n            cost += Math.min(A[i].weight*m, min*(m+2)+A[i].weight*2);\n        }\n        System.out.println(cost);\n    }\n}\n\nclass Bug implements Comparable<Bug>{\n    final int weight;\n    final int index;\n    Bug(int weight, int index){\n        this.weight = weight;\n        this.index = index;\n    }\n    @Override\n    public int compareTo(Bug o){\n        if(weight<o.weight) return -1;\n        else if(weight>o.weight) return 1;\n        else return 0;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tstatic int cost = 0;\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tint n = 0;\n\t\tint tmp = br.read();\n\t\twhile(tmp != 13 && tmp != 10){\n\t\t\tn = n * 10 + (tmp - '0');\n\t\t\ttmp = br.read();\n\t\t}\n\n\t\tint[] array = new int[n];\n\t\tint num = 0;\n\t\tint i1 = 0;\n\t\ttmp = br.read();\n\t\tif(tmp == 13 || tmp == 10){\n\t\t\ttmp = br.read();\n\t\t}\n\t\twhile(tmp != -1 && tmp != 10 && tmp != 13){\n\t\t\tnum = 0;\n\t\t\twhile(tmp >= '0' && tmp <= '9'){\n\t\t\t\tnum = num * 10 + (tmp - '0');\n\t\t\t\ttmp = br.read();\n\t\t\t}\n\t\t\tif(tmp == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tarray[i1] = num;\n\t\t\ti1++;\n\t\t\ttmp = br.read();\n\t\t}\n\t\t\n\t\tquickSort(array, 0, array.length - 1);\n\t\t\n\t\tSystem.out.println(cost);\n\t\t/*\n\t\tStringBuilder sb = new StringBuilder(array.length * 5 / 2);\n\t\tint outLen = array.length;\n\t\tsb.append(array[0]);\n\t\tfor(int i = 1; i < outLen ; i++){\n\t\t\tsb.append(\" \"+array[i]);\n\n\t\t}\n\t\tSystem.out.println(sb);\n\t\t*/\n\t}\n\n\tstatic void quickSort(int[] array, int p, int r){\n\t\tif(p < r){\n\t\t\tint q = partition(array, p, r);\n\t\t\tquickSort(array, p, q - 1);\n\t\t\tquickSort(array, q + 1, r);\n\t\t}\n\t}\n\t\n\tstatic int partition(int[] array, int p, int r){\n\t\tint x = array[r];\n\t\tint i = p - 1;\n\t\tfor(int j = p ; j <= r -1 ;j++){\n\t\t\tif(array[j] <= x){\n\t\t\t\ti++;\n\t\t\t\tint tmp = array[i];\n\t\t\t\tarray[i] = array[j];\n\t\t\t\tarray[j] = tmp;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(array[i + 1] != array[r]){\n\t\t\tcost += array[i + 1] + array[r];\n\t\t\t//System.out.println(\"add cost \" +array[i + 1]+\" \" + array[r]);\n\t\t}\n\t\tint tmp = array[i + 1];\n\t\tarray[i + 1] = array[r];\n\t\tarray[r] = tmp;\n\t\treturn i + 1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in); \n\n\t\tint n = sc.nextInt();\n\t\tint[] w = new int[n];\n\t\tHashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();\n\t\t\n    \tfor (int i = 0; i < n; i++) {\n    \t\tw[i] = sc.nextInt();\n    \t\thm.put(w[i], i);\n    \t}\n    \tint[] sort = w.clone();\n    \tArrays.sort(sort);\n    \t\n    \tint ret = 0;\n    \tint swap = 0;\n    \tint swapi = 0;\n    \tint swapj = 0;\n    \twhile (swap != Integer.MAX_VALUE) {\n    \t\tswap = Integer.MAX_VALUE;\n    \t\tfor (int i = n - 1; i >= 0; i--) {\n    \t\t\tint max = sort[i];\n    \t\t\tint maxi = hm.get(max);\n    \t\t\tif (maxi != i) {\n    \t\t\t\tif (swap > max + w[i]) {\n    \t\t\t\t\tswap = max + w[i];\n    \t\t\t\t\tswapi = i;\n    \t\t\t\t\tswapj = maxi;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tif (swap != Integer.MAX_VALUE) {\n    \t\t\tint max = w[swapi];\n    \t\t\tint tmp = w[swapj];\n    \t\t\tw[swapj] = max;\n    \t\t\thm.put(w[swapj], swapj);\n    \t\t\tw[swapi] = tmp;\n    \t\t\thm.put(w[swapi], swapi);\n    \t\t\t\n    \t\t\tret += swap;\n    \t\t}\n    \t}\n\n\t\tSystem.out.println(ret);\n    \t\n        sc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n\n\tstatic class Data {\n\t\tint point;\n\t\tint data;\n\t}\n\n\tstatic final Comparator<Data> COMPARATOR = new Comp();\n\n\tstatic class Comp implements Comparator<Data> {\n\t\tpublic int compare(Data x,Data y){\n\t\t\tif (x.data > y.data)\n\t\t\t\treturn 1;\n\t\t\telse if(x.data < y.data)\n\t\t\t\treturn -1;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tString s = br.readLine();\n\n\t\tString[] str = s.split(\" \");\n\t\tData[] w = new Data[n];\n\t\tPriorityQueue<Data> pq = new PriorityQueue<Data>(10,COMPARATOR);\n\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tw[i] = new Data();\n\t\t\tw[i].data = Integer.parseInt(str[i]);\n\t\t\tpq.add(w[i]);\n\t\t}\n\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tpq.poll().point = i;\n\t\t}\n\n\n\t\tint count = 0;\n\t\tint sum = 0;\n\n\t\twhile (count < n) {\n\t\t\tboolean flag = false;\n\t\t\tfor (int i=0; i<n; i++) {\n\t\t\t\tif (w[i].point == count) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tif (w[i].point == i) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int j=0; j<n; j++) {\n\t\t\t\t\t\tif (w[j].point == i) {\n\t\t\t\t\t\t\tsum += w[i].data + w[j].data;\n\t\t\t\t\t\t\tw[j].point = w[i].point;\n\t\t\t\t\t\t\tw[j].data = w[i].data;\n\t\t\t\t\t\t\tw[i].point = -1;\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!flag) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(sum);\n\n\t\tbr.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tBufferedReader br =\n\t\t\t\tnew BufferedReader( new InputStreamReader(System.in) );\n\t\tint n = Integer.parseInt( br.readLine() );\n\n\t\tString[] str = br.readLine().split(\" \");\n\t\tBag[] preW = new Bag[n]; // ??´????????????????????? w_i ?????\\????????????\n\t\tBag[] postW = new Bag[n]; // ??´??????????????????????????\\????????????\n\t\tfor (int i=0; i < n; i++) {\n\t\t\tpreW[i] = new Bag( Integer.parseInt(str[i]), i );\n\t\t\tpostW[i] = preW[i];\n\t\t}\n\n\t\tArrays.sort(postW);\n\t\tfor (int i=0; i < n; i++) {\n\t\t\tpostW[i].posti = i;\n\t\t}\n\n\t\t/*\n\t\t * 5, 4, 1, 3, 2, : W  pre\n\t\t *\n\t\t *                  W[0] = 5\n\t\t *  , 4, 1, 3, 2, : bag = 5, nextbag = 2,\n\t\t *             5,\n\t\t *\n\t\t *  , 4, 1, 3, 5, : bag = 2, nextbag = 4,\n\t\t *    2,\n\t\t *\n\t\t *  , 2, 1, 3, 5, : bag = 4, nextbag = 3,\n\t\t *          4,\n\t\t *\n\t\t *  , 2, 1, 4, 5, : bag = 3, nextbag = 1,\n\t\t *       3,\n\t\t *\n\t\t *  , 2, 3, 4, 5, : bag = 1, nextbag = 5,\n\t\t * 1,\n\t\t *                  bag = 5,\n\t\t *                  bag.prei = 0\n\t\t *\n\t\t * 1, 2, 3, 4, 5, : orderedW  post\n\t\t */\n\n\t\tBag bag, nextbag;\n\t\tint count;\n\t\tint ans = 0;\n\t\tint least = postW[0].wei;\n\t\tfor (int i=0; i < n; i++) {\n\t\t\tbag = postW[i];\n\t\t\tif (bag.label == true) continue;\n\t\t\tif (bag.prei == bag.posti) continue;\n\n\t\t\tbag.label = true;\n\t\t\tcount = 0;\n\t\t\tint mini = bag.wei;\n\t\t\twhile (true) {\n\t\t\t\tnextbag = preW[bag.posti]; // nextbag.prei == bag.posti\n\t\t\t\tif (nextbag == postW[i]) break; // postW[i] ??????????????¨??????nextbag????????£??????????????????postW[i]????????£????????????\n\t\t\t\tnextbag.label = true;\n\t\t\t\tcount++;\n\t\t\t\tans += nextbag.wei;\n\t\t\t\tbag = nextbag;\n\t\t\t}\n\t\t\tint nochange = mini * count;\n\t\t\tint change = (least+mini)*2 * least*count;\n\t\t\tans += Math.min(change, nochange);\n\t\t}\n\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic class Bag implements Comparable<Bag> {\n\t\tint wei; // weight\n\n\t\tint prei; // pre index ??´?????????????????????????????????\n\n\t\tint posti; // post index ??´??????????????¨?????????????????????\n\n\t\tboolean label = false;\n\n\t\tBag(int w, int i) {\n\t\t\tthis.wei= w;\n\t\t\tthis.prei = i;\n\t\t}\n\n//\t\tBag next(Bag[] preW, Bag[] postW) {\n//\t\t\tint index = this.posti;\n//\t\t\treturn preW[index];\n//\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Bag b) {\n\t\t\treturn this.wei - b.wei;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"\" + wei;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tint max = 0;\n\t\tint min = 1 << 16;\n\t\tint[] num = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = scanner.nextInt();\n\t\t\tnum[i] = t;\n\t\t\tmax = Math.max(max, t);\n\t\t\tmin = Math.min(min, t);\n\t\t}\n\t\tboolean[] b = new boolean[n];\n\t\tint[] sortnum = Arrays.copyOf(num, n);\n\t\tArrays.sort(sortnum);\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\tfor (int t : sortnum)\n\t\t\tlist.add(t);\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint s = 0;\n\t\t\tint an = 0;\n\t\t\tint cur = i;\n\t\t\tint m = max;\n\t\t\twhile (true) {\n\t\t\t\tb[cur] = true;\n\t\t\t\tan++;\n\t\t\t\tint v = num[cur];\n\t\t\t\tm = Math.min(m, v);\n\t\t\t\ts += v;\n\t\t\t\tcur = list.indexOf(v);\n\t\t\t\tif (b[cur])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint aa = s + (an - 2) * m;\n\t\t\tint bb = s + m + (an + 1) * min;\n\t\t\tans += Math.min(aa, bb);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\n\tpublic static void main(String[] args) throws IOException{\n\t\t\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tint[] W = new int[n];\n\t\tString[] in = br.readLine().split(\" \");\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tW[i] = Integer.parseInt(in[i]);\n\t\t}\n\t\tSystem.out.printf(\"%d\\n\", minCostSort(W));\n\t}\n\n\tpublic static int indexOf(int[] A, int x){\n\t\tfor(int i = 0; i < A.length; i++){\n\t\t\tif(A[i] == x){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic static int minCostSort(int[] W){\n\t\tint[] sorted = W.clone();\n\t\tArrays.sort(sorted);\n\t\tint cost = 0;\n\t\tfor(int i = 0; i < W.length; i++){\n\t\t\tint a = indexOf(W, sorted[i]);\n\t\t\tint j = 0;\n\t\t\twhile(a > i){\n\t\t\t\tj++;\n\t\t\t\tint b = indexOf(W, sorted[a]);\n\t\t\t\tcost += W[b];\n\t\t\t\tint work = W[a];\n\t\t\t\tW[a] = W[b];\n\t\t\t\tW[b] = work;\n\t\t\t\ta = b;\n\t\t\t}\n\t\t\tcost += Math.min(sorted[i] * j, sorted[i] * 2 + sorted[0] * (j+2));\n\t\t}\n\t\treturn cost;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.*;\n\npublic class Main {\n    static final int MAX = 1000;\n    static final int VMAX = 10000;\n\n    public static void main(String[] args) throws Exception {\n        // 入力\n        int n = 0;\n        int[] A = new int[MAX];\n        int min = VMAX;\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in));) {\n            n = Integer.parseInt(br.readLine());\n            String[] lines = br.readLine().split(\" \");\n            for (int i = 0; i < n; i++) {\n                A[i] = Integer.parseInt(lines[i]);\n                min = Math.min(min, A[i]);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 最小コストソート\n        int ans = 0;\n        boolean[] isProcessed = new boolean[MAX];\n        int[] B = new int[MAX];\n        System.arraycopy(A, 0, B, 0, n);\n        // 与えられた数列が昇順でそれぞれ何番目かを\n        // バケット法で調べる\n        Arrays.sort(B, 0, n);\n        int[] order = new int[VMAX + 1];\n        for (int i = 0; i < n; i++) {\n            order[B[i]] = i;\n        }\n\n        for (int i = 0; i < n; i++) {\n            // 真ならばサイクルで計算済みなので飛ばす\n            if (isProcessed[i]) {\n                continue;\n            }\n\n            int cur = i;\n            // サイクル内の合計\n            int cycleSum = 0;\n            // サイクル内の最小値\n            int cycleMin = VMAX;\n            // サイクルに含まれた数\n            int cycleN = 0;\n            // サイクルを一周するまで\n            while (true) {\n                isProcessed[cur] = true;\n                cycleN++;\n                int v = A[cur];\n                cycleMin = Math.min(cycleMin, v);\n                cycleSum += v;// ΣWiの部分\n                cur = order[v];// ソート前の数列Aの値の移動先の添字\n                if (isProcessed[cur]) {\n                    // サイクルを一周したのでループを抜ける\n                    break;\n                }\n            }\n            ans += Math.min(cycleSum + (cycleN - 2) * cycleMin, cycleSum + cycleMin + (cycleN + 1) * min);\n        }\n\n        // 出力\n        System.out.println(ans);\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport javax.xml.crypto.Data;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static int SENTINEL = 100000007;\n    public static int MAX = 1000;\n    public static int VMAX = 10000;\n\n    public static int[] A = new int[MAX];\n    public static int n, s;\n    public static int[] B = new int[MAX];\n    public static int[] T = new int[VMAX + 1];\n\n    public static void main(String[] args) throws IOException {\n\n        //??\\???\n        /*\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] str = br.readLine().split(\" \");\n        */\n\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        s = VMAX;\n        for (int i = 0; i < n; i++) {\n            A[i] = sc.nextInt();\n            s = Math.min(s, A[i]);\n        }\n\n        // ??????\n        System.out.println(solve());\n    }\n\n    public static int solve() {\n        int ans = 0;\n        boolean[] V = new boolean[MAX];\n\n        for(int i = 0; i < n; i++){\n            B[i] = A[i];\n            V[i] = false;\n        }\n        Arrays.sort(B, 0, n );\n        for(int i = 0; i < n; i++) T[B[i]] = i;\n        for(int i = 0; i < n; i++) {\n            if(V[i]) continue;\n            int S = 0;\n            int an = 0;\n            int m = VMAX;\n            int cur = i;\n            while(true) {\n                V[cur] = true;\n                an++;\n                int v = A[cur];\n                m = Math.min(m, v);\n                S += v;\n                cur = T[v];\n                if(V[cur]) break;\n            }\n            ans += Math.min(S + (an - 2) * m, m + S + (an + 1) * s);\n        }\n        return ans;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\n//import java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\nclass Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\t//System.setIn(new FileInputStream(\"./ALDS1_6_D-in15.txt\"));\n\t\t\n\t\t// Input an array\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\n\t\tBaggage[] a = new Baggage[n];\n\t\tString[] strs = br.readLine().split(\" \");\n\t    for(int i = 0; i < n; ++i){\n\t        a[i] = new Baggage(i, Integer.parseInt(strs[i]));\n\t    }\n\t    \n\t    // Number the array\n\t    mergeSort(a, 0, n);\n\t    /*\n\t    for(int i = 0; i < n; ++i) {\n\t    \tSystem.out.printf(\" %3d\", i);\n\t    }\n\t    System.out.println();\n\t    for(int i = 0; i < n; ++i) {\n\t    \tSystem.out.printf(\" %3d\", a[i].weight);\n\t    }\n\t    System.out.println();\n\t    for(int i = 0; i < n; ++i) {\n\t    \tSystem.out.printf(\" %3d\", a[i].org);\n\t    }\n\t    System.out.println();*/\n\t    \n\t    // Calc. cost\n\t    int cost = 0;\n\t    int minw = a[0].weight;\n\t    for(int i = 0; i < n; ++i) {\n\t    \tif(a[i].flag == true){\n\t\t    \t// search group key i\n\t    \t\tcontinue;\n\t    \t}\n\t    \t//System.out.print(\"key \" + i + \" \" + a[i].weight + \": \");\n    \t\t\n\t    \t// count cost for group i\n\t    \tint cnt = 0; // swap count\n\t    \tint j = a[i].org;\n\t    \twhile(j != i) {\n\t    \t\t// swap a[j] and a[i]\n\t    \t    cost += a[j].weight + a[i].weight;\n\t    \t\tcnt += 1;\n\n\t    \t\t//System.out.print(\" \" + a[j].weight);\n\t    \t    a[j].flag = true;\n\t\t    \tj = a[j].org;\n\t   \t    }\n\t    \tint loss = (a[i].weight * cnt) - minw * cnt - 2 * (minw + a[i].weight);\n\t    \tif(loss > 0){\n\t    \t\tcost -= loss;\n\t    \t}\n\t    \t//System.out.println(\" ; cost \" + cost);\n\t    }\n\t    \n\t    System.out.println(cost);\n\t}\n\t\n\tpublic static void mergeSort(Baggage[] s, int left, int right) {\n\t\tif(left + 1 < right) {\n\t\t\tint mid = (left + right) / 2;\n\t\t\tmergeSort(s, left, mid);\n\t\t\tmergeSort(s, mid, right);\n\t\t\tmerge(s, left, mid, right);\n\t\t}\n\t}\n\tpublic static void merge(Baggage[] s, int left, int mid, int right) {\n\t\tBaggage[] s1 = Arrays.copyOfRange(s, left, mid + 1);\n\t\tBaggage[] s2 = Arrays.copyOfRange(s, mid, right + 1);\n\t\t\n\t\ts1[mid - left] = new Baggage(-1, Integer.MAX_VALUE);\n\t\ts2[right - mid] = new Baggage(-1, Integer.MAX_VALUE);\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tfor(int k = left; k < right; ++k) {\n\t\t\tif(s1[i].weight <= s2[j].weight){\n\t\t\t\ts[k] = s1[i];\n\t\t\t\ti += 1;\n\t\t\t}else{\n\t\t\t\ts[k] = s2[j];\n\t\t\t\tj += 1;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n\nclass Baggage {\n\tpublic int org;\n\tpublic int weight;\n\tpublic boolean flag;\n\tpublic Baggage(int o, int w) {\n\t\torg = o;\n\t\tweight = w;\n\t\tflag = false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Main {\n\t\n\tpublic static int dfs(int[] A){\n\t\t\n\t\tint ret = Integer.MAX_VALUE / 2;\n\t\t\n\t\tboolean flag = true;\n\t\tfor(int i = 0; i < A.length; i++){\n\t\t\tfor(int j = i + 1; j < A.length; j++){\n\t\t\t\tif(A[i] > A[j]){\n\t\t\t\t\tflag = false;\n\t\t\t\t\t\n\t\t\t\t\tint tmp = A[i];\n\t\t\t\t\tA[i] = A[j];\n\t\t\t\t\tA[j] = tmp;\n\t\t\t\t\t\n\t\t\t\t\tret = Math.min(ret, dfs(A) + A[i] + A[j]);\n\t\t\t\t\t\n\t\t\t\t\ttmp = A[i];\n\t\t\t\t\tA[i] = A[j];\n\t\t\t\t\tA[j] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn flag ? 0 : ret;\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\n\t\tfinal int n = sc.nextInt();\n\t\tint[] array = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tarray[i] = sc.nextInt();\n\t\t}\n\t\t\n\t\tSystem.out.println(dfs(array));\n\t\t\n\t}\n\n\tpublic static class Scanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic int cost = 0;\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tint n = 0;\n\t\t//int costA = 0;\n\t\t//int costB = 0;\n\t\tint tmp = br.read();\n\t\twhile(tmp != 13 && tmp != 10){\n\t\t\tn = n * 10 + (tmp - '0');\n\t\t\ttmp = br.read();\n\t\t}\n\n\t\tint[] array = new int[n];\n\t\tint[] sortedArray = new int[n];\n\t\tint num = 0;\n\t\tint i1 = 0;\n\t\tint min = Integer.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\ttmp = br.read();\n\t\tif(tmp == 13 || tmp == 10){\n\t\t\ttmp = br.read();\n\t\t}\n\t\twhile(tmp != -1 && tmp != 10 && tmp != 13){\n\t\t\tnum = 0;\n\t\t\twhile(tmp >= '0' && tmp <= '9'){\n\t\t\t\tnum = num * 10 + (tmp - '0');\n\t\t\t\ttmp = br.read();\n\t\t\t}\n\t\t\tif(tmp == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tarray[i1] = num;\n\t\t\tsortedArray[i1] = num;\n\t\t\tif(min > num){\n\t\t\t\tmin = num;\n\t\t\t\tminIndex = i1;\n\t\t\t}\n\t\t\ti1++;\n\t\t\ttmp = br.read();\n\t\t}\n\n\t\tArrays.sort(sortedArray);\n\t\tint[] trueIndex = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ttrueIndex[i] = Arrays.binarySearch(sortedArray, array[i]);\n\t\t}\n\n\t\t//??????????????¢???\n\t\tboolean[] checked = new boolean[n];\n\t\tArrays.fill(checked, false);\n\n\t\tfor(int i = 0; i < n ; i++){\n\t\t\tif(i == trueIndex[i] || checked[i] == true){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tArrayList<Integer> cycle = new ArrayList<Integer>();\n\t\t\tcycle.add(array[i]);\n\t\t\tint j = trueIndex[i];\n\t\t\twhile(j != i){\n\t\t\t\tchecked[j] = true;\n\t\t\t\tcycle.add(array[j]);\n\t\t\t\tj = trueIndex[j];\n\t\t\t}\n\n\t\t\t//????????????????°?????????§??????????????????????????????????¨??¨????\n\t\t\tint minInCycle = cycle.get(0);\n\t\t\tint costA = 0;\n\t\t\tint costB = 0;\n\t\t\tfor(int k = 0; k < cycle.size(); k++){\n\t\t\t\tif(minInCycle > cycle.get(k)){\n\t\t\t\t\tminInCycle = cycle.get(k);\n\t\t\t\t}\n\t\t\t\tcostA+=cycle.get(k);\n\t\t\t\tcostB+=cycle.get(k);\n\t\t\t}\n\t\t\tcostA += minInCycle*(cycle.size() - 2);\n\t\t\tcostB += minInCycle + min*(cycle.size());\n\t\t\t\n\t\t\tcost += Math.min(costA, costB);\n\n\t\t}\n\n\n\t\t//quickSort(array, 0, array.length - 1);\n\n\t\tSystem.out.println(cost);\n\t\t/*\n\t\tStringBuilder sb = new StringBuilder(array.length * 5 / 2);\n\t\tint outLen = array.length;\n\t\tsb.append(array[0]);\n\t\tfor(int i = 1; i < outLen ; i++){\n\t\t\tsb.append(\" \"+array[i]);\n\n\t\t}\n\t\tSystem.out.println(sb);\n\t\t*/\n\t}\n\t/*\n\tstatic void quickSort(int[] array, int p, int r){\n\t\tif(p < r){\n\t\t\tint q = partition(array, p, r);\n\t\t\tquickSort(array, p, q - 1);\n\t\t\tquickSort(array, q + 1, r);\n\t\t}\n\t}*/\n\t/*\n\tstatic int partition(int[] array, int p, int r){\n\t\tint x = array[r];\n\t\tint i = p - 1;\n\t\tfor(int j = p ; j <= r -1 ;j++){\n\t\t\tif(array[j] <= x){\n\t\t\t\ti++;\n\t\t\t\tint tmp = array[i];\n\t\t\t\tarray[i] = array[j];\n\t\t\t\tarray[j] = tmp;\n\n\t\t\t}\n\t\t}\n\n\t\tif(true || array[i + 1] != array[r]){\n\t\t\tcost += array[i + 1] + array[r];\n\t\t\tSystem.out.println(\"add cost \" +array[i + 1]+\" \" + array[r]);\n\t\t}\n\t\tint tmp = array[i + 1];\n\t\tarray[i + 1] = array[r];\n\t\tarray[r] = tmp;\n\t\treturn i + 1;\n\t}\n\t*/\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args)  {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tint[] W = new int[n]; \n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tW[i] = scanner.nextInt();\n\t\t}\n\t\tSystem.out.println(minCostSort(W));\n\t}\n\tpublic static int indexOf(int[] A, int x) {\n\t\tfor (int i = 0; i < A.length; i++) {\n\t\t\tif (A[i] == x) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tpublic static int minCostSort(int[] W) {\n\t\tint sorted[] = W.clone();\n\t\tArrays.sort(sorted);\n\t\tint cost = 0;\n\t\tfor (int i = 0; i < W.length; i++) {\n\t\t\tint a = indexOf(W, sorted[i]);\n\t\t\tint j = 0;\n\t\t\twhile (a > i) {\n\t\t\t\tj++;\n\t\t\t\tint b = indexOf(W, sorted[a]);\n\t\t\t\tcost += W[b];\n\t\t\t\tint t = W[a];\n\t\t\t\tW[a] = W[b];\n\t\t\t\tW[b] = t;\n\t\t\t\ta = b;\n\t\t\t}\n\t\t\tcost += Math.min(sorted[i] * j, sorted[i] * 2 + sorted[0] * (j + 2));\n\t\t}\n\t\treturn cost;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] w = new int[n];\n\t\tboolean[] judge = new boolean[n];\n\n\t\tint AllMin = 10000;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tw[i] = sc.nextInt();\n\t\t\tAllMin = Math.min(AllMin, w[i]);\n\t\t\tjudge[i] = false;\n\t\t}\n\n\t\tint answer = 0;\n\n\t\tint[] copy = w.clone();\n\t\tArrays.sort(copy);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (judge[i] == true || w[i] == copy[i]) {\n\t\t\t\tjudge[i] = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint min = w[i];\n\t\t\tint roop = 0;\n\t\t\tint cost = 0;\n\n\t\t\twhile (true) {\n\t\t\t\tif (judge[i] == true) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\troop++;\n\t\t\t\tjudge[i] = true;\n\n\t\t\t\tmin = Math.min(min, w[Index(copy, w[i])]);\n\n\t\t\t\tcost += w[Index(copy, w[i])];\n\t\t\t\ti = Index(copy, w[i]);\n\t\t\t}\n\n\t\t\tanswer += Math.min(cost + (roop - 2) * min, cost + min + AllMin\n\t\t\t\t\t* (roop + 1));\n\n\t\t}\n\t\t\n\t\tSystem.out.println(answer);\n\n\t}\n\n\tpublic static int Index(int[] w, int X) {\n\t\tint index = 0;\n\t\tfor (int i = 0; i < w.length; i++) {\n\t\t\tif (w[i] == X) {\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate int lim;\n\t\n\tprivate int[] a;\n\tprivate int[] b;\n\t\n\tprivate ArrayList<Integer[]> iset;\n\t\n\tprivate Scanner sc;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\tlim = Integer.parseInt(sc.nextLine());\n\t\t\n\t\ta = new int[lim];\t\t\n\t\tb = new int[lim];\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\ta[i] = Integer.parseInt(sc.next());\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tArrays.sort(b);\n\t\t\n\t\tiset = new ArrayList<Integer[]>();\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\tif (a[i] == b[i]) continue;\n\t\t\tfor (int j = (i + 1); j < lim; j++) {\n\t\t\t\tif (a[j] == b[j]) continue;\n\t\t\t\t\n\t\t\t\tInteger[] ij = {b[i], b[j]};\n\t\t\t\tiset.add(ij);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint min = 0;\n\t\tfor (int i = 0; i < iset.size(); i++) {\n\t\t\tint tmp = swap(i, 0);\n\t\t\t\n\t\t\tif ((tmp != -1) && ((min == 0) || (min > tmp))) min = tmp;\n\t\t}\n\t\t\n\t\tSystem.out.println(min);\n\t}\n\t\n\tpublic int swap(int index, int ans) {\n\t\tInteger[] ij = iset.get(index);\n\t\tiset.remove(index);\n\n\t\tint small = -1;\n\t\tint large = -1;\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\tif (a[i] == ij[0]) {\n\t\t\t\tsmall = i;\n\t\t\t} else if (a[i] == ij[1]) {\n\t\t\t\tlarge = i;\n\t\t\t}\n\t\t\t\n\t\t\tif ((small != -1) && (large != -1)) break;\n\t\t}\n\t\t\n\t\tif ((a[small] == b[large]) || (a[large] == b[small])) {\n\t\t\tint tmp = a[small];\n\t\t\ta[small] = a[large];\n\t\t\ta[large] = tmp;\n\t\t\t\n\t\t\tans = ans + a[small] + a[large];\n\t\t} else {\n\t\t\tiset.add(index, ij);\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tboolean flag = true;\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\tif (a[i] != b[i]) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag) {\n\t\t\tint tmp = a[small];\n\t\t\ta[small] = a[large];\n\t\t\ta[large] = tmp;\n\t\t\t\n\t\t\tiset.add(index, ij);\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\tint min = 0;\n\t\tfor (int i = 0; i < iset.size(); i++) {\n\t\t\tint tmp = swap(i, ans);\n\t\t\t\n\t\t\tif ((tmp != -1) && ((min == 0) || (min > tmp))) min = tmp;\n\t\t}\n\n\t\tint tmp = a[small];\n\t\ta[small] = a[large];\n\t\ta[large] = tmp;\n\t\t\n\t\tiset.add(index, ij);\n\t\treturn min;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.io.IOException;\n\n// ALDS1_6_D\npublic class Main {\n\tint cost = 0;\n\tvoid run() throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] A = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tA[i] = sc.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint min = i;\n\t\t\tfor (int j = i; j < n; j++) {\n\t\t\t\tif (A[min] > A[j]) min = j;\n\t\t\t}\n\t\t\tif (i == min) continue;\n\t\t\tcost += A[i] + A[min];\n\t\t\tint tmp = A[i];\n\t\t\tA[i] = A[min];\n\t\t\tA[min] = tmp;\n\t\t}\n\t\tSystem.out.println(cost);\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in); \n\n\t\tint n = sc.nextInt();\n\t\tint[] w = new int[n];\n\t\tHashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();\n\t\t\n    \tfor (int i = 0; i < n; i++) {\n    \t\tw[i] = sc.nextInt();\n    \t\thm.put(w[i], i);\n    \t}\n    \tint[] sort = w.clone();\n    \tArrays.sort(sort);\n    \t\n    \tint ret = 0;\n    \tint swapi = 0;\n    \tint swapj = 0;\n    \tfor (int i = 0; i < n; i++) {\n    \t\tint min = sort[i];\n    \t\tint mini = hm.get(min);\n    \t\twhile (mini != i) {\n    \t\t\tswapi = mini;\n    \t\t\tswapj = hm.get(sort[mini]);\n    \t\t\tint tmp = w[swapj];\n    \t\t\tw[swapj] = w[swapi];\n    \t\t\tw[swapi] = tmp;\n    \t\t\thm.put(w[swapj], swapj);\n    \t\t\thm.put(w[swapi], swapi);\n    \t\t\t\n    \t\t\tret += w[swapj] + w[swapi];\n    \t\t\tmini = hm.get(min);\n    \t\t}\n    \t}\n\n\t\tSystem.out.println(ret);\n    \t\n        sc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate int[] a;\n\tprivate int[] b;\n\t\n\tprivate Scanner sc;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\tint lim = Integer.parseInt(sc.nextLine());\n\t\t\n\t\ta = new int[lim];\t\t\n\t\tb = new int[lim];\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\ta[i] = Integer.parseInt(sc.next());\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tArrays.sort(b);\n\n\t\tint max = 0;\n\t\tHashMap<Integer, ArrayList<Integer[]>> iset = new HashMap<Integer, ArrayList<Integer[]>>();\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\tfor (int j = (i + 1); j < lim; j++) {\n\t\t\t\tint sum = a[i] + a[j];\n\t\t\t\tInteger[] ij = {a[i], a[j]};\n\n\t\t\t\tArrayList<Integer[]> ijlist;\n\t\t\t\tif (iset.containsKey(sum) == false) {\n\t\t\t\t\tijlist = new ArrayList<Integer[]>();\n\t\t\t\t} else {\n\t\t\t\t\tijlist = iset.get(sum);\n\t\t\t\t}\n\t\t\t\tijlist.add(ij);\n\t\t\t\t\n\t\t\t\tiset.put(sum, ijlist);\n\t\t\t\t\n\t\t\t\tif (max < sum) max = sum;\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tboolean judge = false;\n\t\tfor (int i = 0; i <= max; i++) {\n\t\t\tArrayList<Integer[]> tmp;\n\t\t\tif (iset.containsKey(i) == true) {\n\t\t\t\ttmp = iset.get(i);\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int j = 0; j < tmp.size(); j++) {\n\t\t\t\tInteger[] ij = tmp.get(j);\n\t\t\t\t\n\t\t\t\tint as = ij[0];\n\t\t\t\tint al = ij[1];\n\t\t\t\t\n\t\t\t\tint small = -1;\n\t\t\t\tint large = -1;\n\t\t\t\tfor (int k = 0; k < lim; k++) {\n\t\t\t\t\tif (a[k] == as) {\n\t\t\t\t\t\tsmall = k;\n\t\t\t\t\t} else if (a[k] == al) {\n\t\t\t\t\t\tlarge = k;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ((small != -1) && (large != -1)) break;\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(a[small] + \" * \" + a[large]);\n\t\t\t\tSystem.out.println(small + \" - \" + large);\n\t\t\t\tSystem.out.println(b[small] + \" / \" + b[large]);\n\t\t\t\tif (a[small] == b[large]) {\n\t\t\t\t\ta[small] = a[large];\n\t\t\t\t\ta[large] = b[large];\n\t\t\t\t\t\n\t\t\t\t\tans = ans + i;\n\n\t\t\t\t\ttmp.remove(j);\n\t\t\t\t\tiset.put(i, tmp);\n\t\t\t\t\ti = -1;\n\t\t\t\t\tSystem.out.println(\"swtich\");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t\t\n\t\t\t\tfor (int k = 0; k < lim; k++) {\n\t\t\t\t\tSystem.out.print(a[k] + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t\t\n\t\t\t\tjudge = true;\n\t\t\t\tfor (int k = 0; k < lim; k++) {\n\t\t\t\t\tif (a[k] != b[k]) {\n\t\t\t\t\t\tjudge = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (judge) break;\n\t\t\t}\n\t\t\tif (judge) break;\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n    public static void main (String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        Integer[] w = new Integer[n];\n        for (int i = 0; i < n; i ++) {\n            w[i] = sc.nextInt();\n        }\n        Integer[] sorted = Arrays.copyOf(w, n);\n        Arrays.sort(sorted);\n\n        int cost = 0;\n        while (!Arrays.deepEquals(w, sorted)) {\n            int min = Integer.MAX_VALUE;\n            int minIndex = 0;\n            for (int i = 0; i < n; i++) {\n                if (sorted[i] != w[i] && min > w[i]) {\n                    min = w[i];\n                    minIndex = i;\n                }\n            }\n\n            int index = Arrays.asList(w).indexOf(sorted[minIndex]);\n            if (index == -1) {\n                System.out.println(minIndex + \" \" + w[minIndex] + \" \" + sorted[minIndex]);\n            }\n            int temp = w[minIndex];\n            w[minIndex] = w[index];\n            w[index] = temp;\n            cost = w[minIndex] + w[index];\n        }\n\n        System.out.println(cost);\n\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tint max = 0;\n\t\tint min = 1 << 16;\n\t\tint[] num = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = scanner.nextInt();\n\t\t\tnum[i] = t;\n\t\t\tmax = Math.max(max, t);\n\t\t\tmin = Math.min(min, t);\n\t\t}\n\t\tboolean[] b = new boolean[n];\n\t\tint[] sortnum = Arrays.copyOf(num, n);\n\t\tArrays.sort(sortnum);\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\tfor (int t : sortnum)\n\t\t\tlist.add(t);\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint s = 0;\n\t\t\tint an = 0;\n\t\t\tint cur = i;\n\t\t\tint m = max;\n\t\t\twhile (true) {\n\t\t\t\tb[cur] = true;\n\t\t\t\tan++;\n\t\t\t\tint v = num[cur];\n\t\t\t\tm = Math.min(m, v);\n\t\t\t\ts += v;\n\t\t\t\tcur = list.indexOf(v);\n\t\t\t\tif (b[cur])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint aa = s + (an - 2) * m;\n\t\t\tint bb = s + m + (an + 1) * min;\n\t\t\tans += Math.min(aa, bb);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n\tstatic PrintStream out = System.out;\n\tstatic Scanner in = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\tMain main = new Main();\n\t\tmain.solv();\n\t}\n\tprivate void solv() {\n\t\tint n = in.nextInt();\n\t\tint[] a = new int[n];\n\t\tint[] b = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = in.nextInt();\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tArrays.sort(b);\n\t\tlong cnt = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint m = 0;\n\t\t\twhile (m < b.length && b[m] == a[m])m++;\n\t\t\tif (m >= b.length) break;\n\t\t\tint j, k;\n\t\t\tfor (j = 0; j < n && b[m] != a[j]; j++);\n\t\t\tfor (k = 0; k < n && b[j] != a[k]; k++);\n\t\t\tif (j==k)continue;\n\t\t\tcnt += a[j] + a[k];\n\t\t\tint tmp = a[j];\n\t\t\ta[j] = a[k];\n\t\t\ta[k] = tmp;\n\t\t\t//out.println(Arrays.toString(a));\n\t\t}\n\t\tout.println(cnt);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\n class FS {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readByte() {\n        return hasNextByte() ? buffer[ptr++] : -1;\n    }\n\n    private boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n        skipUnprintable();\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public int nextInt() {\n        return (int) nextLong();\n    }\n\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        FS fs = new FS();\n        int n = fs.nextInt();\n        Stuff a[] = new Stuff[n];\n        boolean b[]  =new boolean[n];\n        for (int i = 0; i < n; i++) {\n            int wei = fs.nextInt();\n            a[i]=new Stuff(i,wei);\n        }\n        Arrays.sort(a);\n        int min=a[0].weight;\n        int wcount=0;\n        for (int i = 0; i < a.length; i++) {\n            if (min>a[i].weight)min=a[i].weight;\n            if (b[i])continue;\n            if (a[i].index==i)continue;\n            int minw=a[i].weight;\n            int k=0;\n            for (int j = a[i].index; !b[j]; j=a[j].index,k++){\n                if (min>a[j].weight)min=a[j].weight;\n                if (minw>a[j].weight)min=a[j].weight;\n                b[j]=true;\n                wcount+=a[j].weight;\n            }\n            wcount+=Math.min((k-2)*minw,minw+(k+1)*min);\n        }\n        System.out.println(wcount);\n    }\n\n   static class Stuff implements Comparable<Stuff> {\n        int index;\n        int weight;\n\n        public Stuff(int index, int weight) {\n            this.index = index;\n            this.weight = weight;\n        }\n\n\n\n       @Override\n       public int compareTo(Stuff o) {\n            if (o.weight>this.weight)return -1;\n            else return 1;\n       }\n   }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\n\npublic class Main {\n\t\n\tpublic static long l=0,l2=0;\n\tpublic static void main(String[] args) throws IOException {\n\t\tl = System.currentTimeMillis();\n\t\tnew Main().exec();\n\t\tl2 = System.currentTimeMillis();\n\t}\n\t\n\tpublic void test() {\n\t}\n\t\n\tpublic void exec() throws IOException {\n\t\tSimpleInputUtil in = new SimpleInputUtil();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = in.nextInt();\n\t\tint[] w = in.nextInt(new int[n], n);\n\t\tint[] sorted_w = Arrays.copyOf(w, n);\n\t\tArrays.sort(sorted_w);\n\t\tHashMap<Integer,Integer> costMap = new HashMap<>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcostMap.put(sorted_w[i], i);\n\t\t}\n\t\tint cost = 0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(w[i]<0) continue;\n\t\t\tint weight = w[i];\n\t\t\tw[i] = -1;\n\t\t\tint firstPos = i;\n\t\t\tint loopCnt = 1;\n\t\t\tint loopCost = weight;\n\t\t\tint loopMinWeight = weight;\n\t\t\tint nextPos = costMap.get(weight);\n\t\t\twhile(firstPos!=nextPos) {\n\t\t\t\tweight = w[nextPos];\n\t\t\t\tw[nextPos] = -1;\n\t\t\t\tloopCnt++;\n\t\t\t\tloopCost += weight;\n\t\t\t\tloopMinWeight = Math.min(loopMinWeight, weight);\n\t\t\t\tnextPos = costMap.get(weight);\n\t\t\t}\n\t\t\tif(loopCnt==1)\n\t\t\t\tcontinue;\n\t\t\telse if (loopCnt==2)\n\t\t\t\tcost += loopCost;\n\t\t\telse\n\t\t\t\tcost += loopCost + loopMinWeight*(loopCnt-2);\n\t\t}\n\t\tout.println(cost);\n\t\tout.flush();\n\t}\n\t\n}\n\nclass SimpleInputUtil {\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n    public String[] readStrArray(String delim) throws NumberFormatException, IOException{\n    \treturn br.readLine().split(delim);\n    }\n    \n    public int nextInt() throws NumberFormatException, IOException{\n    \treturn Integer.parseInt(br.readLine());\n    }\n    \n    public int[] nextInt(int[] a, int num) throws NumberFormatException, IOException{\n        int i=0;\n        while(i<num) {\n            for(String s: br.readLine().split(\" \")){\n            \tif(i<num) {\n                    a[i++] = Integer.parseInt(s);\n            \t}\n            }\n        }\n        return a;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate int[] a;\n\tprivate int[] b;\n\t\n\tprivate Scanner sc;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\tint lim = Integer.parseInt(sc.nextLine());\n\t\t\n\t\ta = new int[lim];\t\t\n\t\tb = new int[lim];\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\ta[i] = Integer.parseInt(sc.next());\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tArrays.sort(b);\n\t\t\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\tif (a[i] != b[i]) {\n\t\t\t\tfor (int j = (i + 1); j < lim; j++) {\n\t\t\t\t\tif ((a[j] == b[i]) && (a[i] == b[j])) {\n\t\t\t\t\t\ta[i] = b[i];\n\t\t\t\t\t\ta[j] = b[j];\n\t\t\t\t\t\t\n\t\t\t\t\t\tans = ans + a[i] + a[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\tif (a[i] != b[i]) {\n\t\t\t\t\n\t\t\t\tfor (int j = (i + 1); j < lim; j++) {\n\t\t\t\t\tif (a[j] != b[j]) {\n\t\t\t\t\t\tint small = -1;\n\t\t\t\t\t\tint large = -1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (int k = 0; k < lim; k++) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (a[k] == b[i]) {\n\t\t\t\t\t\t\t\tsmall = k;\n\t\t\t\t\t\t\t} else if (a[k] == b[j]) {\n\t\t\t\t\t\t\t\tlarge = k;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif ((small != -1) && (large != -1)) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (small == j) {\n\t\t\t\t\t\t\ta[large] = a[small];\n\t\t\t\t\t\t\ta[small] = b[j];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tans = ans + a[small] + a[large];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (large == i) {\n\t\t\t\t\t\t\ta[small] = a[large];\n\t\t\t\t\t\t\ta[large] = b[i];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tans = ans + a[small] + a[large];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[i] != b[i]) i--;\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * Created by zhangrunfeng on 2/18/20\n */\npublic class Main {\n    private int N;\n\n    private int[] arr;\n    private int[] T;\n    private boolean[] v;\n\n    private int minVal;\n\n    public Main(Scanner sc) {\n        N = sc.nextInt();\n        arr = new int[N];\n        for (int i = 0; i < N; i++) {\n            arr[i] = sc.nextInt();\n        }\n        int[] sortedArr = arr.clone();\n        Arrays.sort(sortedArr);\n\n        int VMAX = 10000 + 5;\n        T = new int[VMAX];\n        for (int i = 0; i < N; i++) {\n            T[sortedArr[i]] = i;\n        }\n        minVal = sortedArr[0];\n\n        v = new boolean[N]; // 不用初始化\n        Arrays.fill(v, false);\n    }\n\n    public int minCost() {\n        int sum = 0;\n        for (int i = 0; i < N; i++) {\n            if (v[i]) continue;\n\n            int an = 0;\n            int currSum = 0;\n            int currMin = Integer.MAX_VALUE;\n            int currIx = i;\n            while (!v[currIx]) {\n                v[currIx] = true;\n                currSum += arr[currIx];\n                if (arr[currIx] < currMin) {\n                    currMin = arr[currIx];\n                }\n                an++;\n                currIx = T[arr[currIx]];\n            }\n            if (an >= 2) {\n                sum += (currSum + Math.min((an - 2) * currMin, (an + 1) * minVal + currMin));\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        Main m = new Main(sc);\n        int res = m.minCost();\n        System.out.println(res);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\t// ??°?????????????????¨?????????????????????????????????????????????????´????????????????????????????????????????\n\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\tint n = scanner.nextInt();\n\t\tint count = 0;\n\t\tint[] list = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlist[i] = scanner.nextInt();\n\t\t}\n\t\tint[] sortedList = (int[]) list.clone();\n\t\t// ???????????????????´???°???????????????????????????????????????????????????????????????????????????\n\t\tmergeSort(sortedList, 0, n);\n\t\t// ??????????????????????????¨?????????????´????????´??????????????????????\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmap.put(sortedList[i], i);\n\t\t}\n\n\t\t// ????????¨\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i != map.get(list[i])) {\n\t\t\t\tint temp = list[i];\n\t\t\t\tint ind = map.get(list[i]);\n\t\t\t\tint temp2 = list[ind];\n\t\t\t\tlist[i] = temp2;\n\t\t\t\tlist[ind] = temp;\n\t\t\t\tcount = count + temp + temp2;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n\t\n\tstatic void merge(int[] numList, int left, int mid, int right) {\n\t\tint n1 = mid - left;\n\t\tint n2 = right - mid;\n\t\tint[] L = new int[n1 + 1];\n\t\tint[] R = new int[n2 + 1];\n\n\t\tfor (int i = 0; i < n1; i++) {\n\t\t\tL[i] = numList[left + i];\n\t\t}\n\n\t\tfor (int i = 0; i < n2; i++) {\n\t\t\tR[i] = numList[mid + i];\n\t\t}\n\n\t\tL[n1] = Integer.MAX_VALUE;\n\t\tR[n2] = Integer.MAX_VALUE;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\t// L??¨R??????????????????????°????????????????numList???????´??????????\n\t\t// ?°?????????????????????????????????????????¬??????????????????????????????????????´????????????????????????°?????????+1?????????\n\t\tfor (int k = left; k < right; k++) {\n\t\t\tif (L[i] <= R[j]) {\n\t\t\t\tnumList[k] = L[i];\n\t\t\t\ti = i + 1;\n\t\t\t} else {\n\t\t\t\tnumList[k] = R[j];\n\t\t\t\tj = j + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// ????¨????merge???????????????????±??????????????°?????´???????(left)??¨?????§????´???????(right)?????????-1??????????????§??°????????????\n\tstatic void mergeSort(int[] numList, int left, int right) {\n\t\tif ((left + 1) < right) {\n\t\t\tint mid = (left + right) / 2;\n\n\t\t\tmergeSort(numList, left, mid);\n\t\t\t// System.out.println(\"???\");\n\t\t\tmergeSort(numList, mid, right);\n\t\t\t// System.out.println(\"???\");\n\t\t\tmerge(numList, left, mid, right);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in); \n\n\t\tint n = sc.nextInt();\n\t\tint[] w = new int[n];\n\t\tHashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();\n\t\t\n    \tfor (int i = 0; i < n; i++) {\n    \t\tw[i] = sc.nextInt();\n    \t\thm.put(w[i], i);\n    \t}\n    \tint[] sort = w.clone();\n    \tArrays.sort(sort);\n    \t\n    \tint ret = 0;\n    \tint swapi = 0;\n    \tint swapj = 0;\n    \tfor (int i = 0; i < n; i++) {\n    \t\tint min = sort[i];\n    \t\tint mini = hm.get(min);\n    \t\tint ret2 = 0;\n    \t\tint ret3 = i == 0 ? 0 : (sort[0] + min) * 2;\n    \t\twhile (mini != i) {\n    \t\t\tswapi = mini;\n    \t\t\tswapj = hm.get(sort[mini]);\n    \t\t\tint tmp = w[swapj];\n    \t\t\tw[swapj] = w[swapi];\n    \t\t\tw[swapi] = tmp;\n    \t\t\thm.put(w[swapj], swapj);\n    \t\t\thm.put(w[swapi], swapi);\n    \t\t\t\n    \t\t\tret2 += w[swapj] + w[swapi];\n    \t\t\tret3 += w[0] + w[swapi];\n    \t\t\tmini = hm.get(min);\n    \t\t}\n    \t\t\n    \t\tret += Math.min(ret2, ret3);\n    \t}\n\n\t\tSystem.out.println(ret);\n    \t\n        sc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n \npublic class Main {\n    public static void main(String[] args){\n        Scanner sc=new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i<n; i++) {\n            a[i] = sc.nextInt();\n        }\n        System.out.println(minsort(a));\n         \n    }\n    public static int myindex(int[] a,int b){\n        for (int i=0;i<a.length;i++){\n            if (a[i]==b) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    public static int minsort(int[] a){\n        int [] sorted=a.clone();\n        Arrays.sort(sorted);\n        int n=a.length;\n        int cost=0;\n        for (int i=0;i<n;i++){\n            int cnt=0;\n            int c1= myindex(a,sorted[i]);\n            while (c1!=i){\n                cnt++;\n                int c2= myindex(a,sorted[c1]);\n                cost+=a[c2];\n                int work=a[c2];\n                a[c2]=a[c1];\n                a[c1]=work;\n                c1=c2;\n            }\n            cost+=Math.min(sorted[i]*cnt, sorted[i]*2+sorted[0]*(cnt+2));\n        }\n        return cost;\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main {\n\n  final int VMAX = 10000;\n\n  public static void main(String[] args) {\n\n    new Main().run();\n  }\n\n  public void run() {\n\n    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {\n\n      int n = Integer.parseInt(br.readLine());\n      int[] seq = new int[n];\n      String[] line = br.readLine().split(\" \");\n      int min = VMAX;\n      for (int i=0; i < n; i++) {\n        seq[i] = Integer.parseInt(line[i]);\n        if(seq[i] < min) min = seq[i];\n      }\n      System.out.println( minimumCostSort(seq,min) );\n    }\n    catch(IOException e) {\n      System.err.println(e);\n    }\n  }\n\n  private int minimumCostSort(int[] seq, int s) {\n    int result=0;\n    int n = seq.length;\n    boolean[] v = new boolean[VMAX];\n    int[] b = Arrays.copyOf(seq,n);\n    int[] t = new int[VMAX+1];\n\n    Arrays.sort(b);\n    for(int i=0; i<n; i++)\n      t[b[i]] = i;\n    for(int i=0; i<n; i++) {\n      if(v[i]) continue;\n\n      int cur = i;\n      int S   = 0;\n      int m   = VMAX;\n      int an  = 0;\n      while(true) {\n        v[cur] = true;\n        an++;\n        int iv = seq[cur];\n        m = Math.min(m,iv);\n        S += iv;\n        cur = t[iv];\n\n        if(v[cur]) break;\n      }\n      result += Math.min(S + (an-2) *m, m + S + (an+1) * s);\n    }\n\n    return result;\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.stream.Stream;\n\nclass Main {\n\n\tfinal static int MAX = 1_000;\n\tfinal static int VMAX = 10_000;\n\n\tstatic int n, small;\n\tstatic int[] a;\n\tstatic int[] b = new int[MAX];\n\tstatic int[] truery = new int[VMAX];\n\n\tpublic static void main(String[] args) {\n\n\t\ttry(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {\n\n\t\t\tn = Integer.parseInt(br.readLine());\n\t\t\ta = Stream.of(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tsmall = VMAX;\n\t\tfor(int w : a) {\n\t\t\tsmall = Math.min(small, w);\n\t\t}\n\n\t\tint ans = solve();\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tprivate static int solve() {\n\t\tint ans = 0;\n\t\tb = Arrays.copyOf(a, n);\t\t\t\t\t\t// ??£?????????????????????b\n\t\tboolean[] valid = new boolean[MAX];\t\t\t// ??£?????????????????§?????£???????????????????????£???????????????\n\n\t\tArrays.sort(b);\n\t\tfor (int i = 0; i < n; i++) truery[b[i]] = i;\t// ????????????number?????¬??\\?????????????????????????¨????\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (valid[i]) continue;\n\t\t\tint cur = i;\n\t\t\tint sum = 0;\t\t// ??????????????????????????????\n\t\t\tint min = VMAX;\t\t// ??????????????§????°???????\n\t\t\tint an = 0;\t\t\t// ?????????????´???°\n\n\t\t\twhile(true) {\n\t\t\t\tvalid[cur] = true;\n\t\t\t\tan++;\n\t\t\t\tint val = a[cur];\n\t\t\t\tmin = Math.min(min, val);\n\t\t\t\tsum += val;\n\t\t\t\tcur = truery[val];\n\t\t\t\tif (valid[cur]) break;\n\t\t\t}\n\n\t\t\tans += Math.min( sum + (an-2) * min, min + sum + (an+1) * small );\n\n\t\t}\n\t\treturn ans;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nclass Main{\n  public static void main(String args[]){\n    StringBuilder bl = new StringBuilder();\n    Scanner sc = new Scanner(System.in);\n\n    int max = -1;\n    int min = (int)Double.POSITIVE_INFINITY;\n    int num = 0;\n    int cost = 0;\n    int a,s,cur,m;\n    int n = sc.nextInt();\n    int Array[] = new int[n];\n    int C[] = new int[n];\n    boolean bool[] = new boolean[n];\n\n    for(int i = 0; i<n; i++){\n      num = sc.nextInt();\n      Array[i] = num;\n      C[i] = num;\n      max = Math.max(max,num);\n      min = Math.min(min,num);\n    }\n\n    quicksort(C,0,n-1);\n\n\n    List<Integer> Sorted = new ArrayList<Integer>();\n    for(int i =0; i<n; i++){\n      Sorted.add(C[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n      a = 0;\n      s = 0;\n      cur = i;\n      m = max;\n      while (true) {\n        bool[cur] = true;\n        a++;\n        int v = Array[cur];\n        m = Math.min(m, v);\n        s += v;\n        cur = Sorted.indexOf(v);\n        if (bool[cur]){\n          break;\n        }\n      }\n      int cost1 = s + (a - 2) * m;\n      int cost2 = s + m + (a + 1) * min;\n      cost += Math.min(cost1, cost2);\n    }\n\n    System.out.println(cost);\n    //printでsort確認\n    // for(int i = 0; i < n; i++){\n    //   bl.append(' ').append(Array[i]);\n    // }\n    // bl.append(\"\\n\");\n    // for(int i = 0; i < n; i++){\n    //   bl.append(' ').append(C[i]);\n    // }\n    // bl.append(\"\\n\");\n    // System.out.print(bl);\n\n  }\n  static int partition(int A[], int p, int r){\n    int x = A[r];\n    int i = p-1;\n    int tmp;\n    int s;\n    for(int j =p; j<r; j++){\n      if(A[j]<=x){\n        i = i+1;\n        tmp = A[i];\n        A[i] = A[j];\n        A[j] = tmp;\n      }\n    }\n    tmp = A[i+1];\n    A[i+1] = A[r];\n    A[r] = tmp;\n    return i+1;\n  }\n\n  static void quicksort(int A[], int p, int  r){\n    if(p<r){\n      int q = partition(A, p, r);\n      quicksort(A, p, q-1);\n      quicksort(A, q+1,r);\n    }\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n\tstatic PrintStream out = System.out;\n\tstatic Scanner in = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\tMain main = new Main();\n\t\tmain.solv();\n\t}\n\tprivate void solv() {\n\t\tint n = in.nextInt();\n\t\tint[] a = new int[n];\n\t\tint[] b = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = in.nextInt();\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tArrays.sort(b);\n\t\tlong cnt = 0; \n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint v = a[i];\n\t\t\tif (a[i] == b[i]) continue;\n\n\t\t\tint l = 0, r = n - 1;\n\t\t\twhile (l < r) {\n\t\t\t\tint m = (l + r) / 2;\n\t\t\t\tif (b[m] < v) {\n\t\t\t\t\tl = m + 1;\n\t\t\t\t} else {\n\t\t\t\t\tr = m;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint tmp = a[l];\n\t\t\tcnt += v + tmp;\n\t\t\ta[l] = a[i];\n\t\t\ta[i] = tmp;\n\t\t}\n\t\tout.println(cnt);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tint cost = 0;\n\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint[] m = new int[n];\n\t\tint[] q = new int[n];\n\t\tint[] s = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ts[i] = m[i] = q[i] = scan.nextInt();\n\n\t\tfor (int i = 0; i < 1000000000; i++)\n\t\t\ti *= 1;\n\t\tselectionSort(s, n);\n\t\tSystem.out.println(cost);\n\t}\n\t\n\tvoid selectionSort(int[] a, int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint min_j = i;\n\t\t\tfor (int j = i; j < n; j++) {\n\t\t\t\tif (a[j] < a[min_j])\n\t\t\t\t\tmin_j = j;\n\t\t\t}\n\t\t\tif (i == min_j)\n\t\t\t\tcontinue;\n\t\t\tcost += a[i] + a[min_j];\n\t\t\tint tmp = a[i];\n\t\t\ta[i] = a[min_j];\n\t\t\ta[min_j] = tmp;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate int[] a;\n\tprivate int[] b;\n\t\n\tprivate Scanner sc;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\tint lim = Integer.parseInt(sc.nextLine());\n\t\t\n\t\ta = new int[lim];\t\t\n\t\tb = new int[lim];\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\ta[i] = Integer.parseInt(sc.next());\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tArrays.sort(b);\n\n\t\tint max = 0;\n\t\tHashMap<Integer, ArrayList<Integer[]>> iset = new HashMap<Integer, ArrayList<Integer[]>>();\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\tfor (int j = (i + 1); j < lim; j++) {\n\t\t\t\tint sum = a[i] + a[j];\n\t\t\t\tInteger[] ij = {i, j};\n\n\t\t\t\tArrayList<Integer[]> ijlist;\n\t\t\t\tif (iset.containsKey(sum) == false) {\n\t\t\t\t\tijlist = new ArrayList<Integer[]>();\n\t\t\t\t} else {\n\t\t\t\t\tijlist = iset.get(sum);\n\t\t\t\t}\n\t\t\t\tijlist.add(ij);\n\t\t\t\t\n\t\t\t\tiset.put(sum, ijlist);\n\t\t\t\t\n\t\t\t\tif (max < sum) max = sum;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tboolean judge = false;\n\t\tfor (int i = 0; i < max; i++) {\n\t\t\tArrayList<Integer[]> tmp;\n\t\t\tif (iset.containsKey(i) == true) {\n\t\t\t\ttmp = iset.get(i + 1);\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int j = 0; j < tmp.size(); j++) {\n\t\t\t\tInteger[] ij = tmp.get(j);\n\t\t\t\t\n\t\t\t\tint small = ij[0];\n\t\t\t\tint large = ij[1];\n\t\t\t\t\n\t\t\t\tif (a[small] == b[large]) {\n\t\t\t\t\ta[small] = a[large];\n\t\t\t\t\ta[large] = b[large];\n\t\t\t\t\t\n\t\t\t\t\tans = ans + a[small] + a[large];\n\t\t\t\t}\n\t\t\t\tif (a[large] == b[small]) {\n\t\t\t\t\ta[large] = a[small];\n\t\t\t\t\ta[small] = b[small];\n\t\t\t\t\t\n\t\t\t\t\tans = ans + a[small] + a[large];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tjudge = true;\n\t\t\t\tfor (int k = 0; k < lim; k++) {\n\t\t\t\t\tif (a[k] != b[k]) {\n\t\t\t\t\t\tjudge = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (judge) break;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.IOException;\n\n// ALDS1_6_D\npublic class Main {\n\tint binarySearch(int[] array, int n, int min, int max) {\n\t\tif (min > max) return -1;\n\t\tint mid = (max + min) / 2;\n\t\tif (array[mid] == n) return mid;\n\t\tif (array[mid] > n) return binarySearch(array, n, min, mid-1);\n\t\telse return binarySearch(array, n, mid+1, max);\n\t}\n\t\n\tint SENTINEL = 1234567890;\n\tvoid merge(int[]A, int left, int mid, int right) {\n\t\tint n1 = mid - left + 1;\n\t\tint n2 = right - mid;\n\t\tint[] L = new int[n1 + 1];\n\t\tint[] R = new int[n2 + 1];\n\t\tfor (int i = 0; i < n1; i++) {\n\t\t\tL[i] = A[left + i];\n\t\t}\n\t\tfor (int i = 0; i < n2; i++) {\n\t\t\tR[i] = A[mid + 1 + i];\n\t\t}\n\t\tL[n1] = SENTINEL;\n\t\tR[n2] = SENTINEL;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tfor (int k = left; k <= right; k++) {\n\t\t\tif (L[i] <= R[j]) {\n\t\t\t\tA[k] = L[i];\n\t\t\t\ti = i + 1;\n\t\t\t} else {\n\t\t\t\tA[k] = R[j];\n\t\t\t\tj = j + 1;\n\t\t\t}\n\t    }\n\t}\n\n\tvoid mergeSort(int[] A, int left, int right) {\n\t    \tif (left < right) {\n\t    \t\tint mid = (left + right)/2;\n\t    \t\tmergeSort(A, left, mid);\n\t    \t\tmergeSort(A, mid + 1, right);\n\t    \t\tmerge(A, left, mid, right);\n\t  \t}\n\t}\n\tint cost = 0;\n\tvoid run() throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint min = 10000;\n\t\tint[] A = new int[n];\n\t\tboolean[] check = new boolean[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tA[i] = sc.nextInt();\n\t\t\tcheck[i] = false;\n\t\t\tif (min > A[i]) min = A[i];\n\t\t}\n\t\tint[] B = A.clone();\n\t\tmergeSort(B, 0, n-1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (check[i]) continue;\n\t\t\tcheck[i] = true;\n\t\t\tif (A[i] == B[i]) continue;\n\t\t\tint loopmin = A[i];\n\t\t\tint count = 0;\n\t\t\tint j = i;\n\t\t\twhile(true) {\n\t\t\t\tcost += A[j];\n\t\t\t\tj = binarySearch(B, A[j], 0, n-1);\n\t\t\t\tif (check[j]) break;\n\t\t\t\tif (loopmin > A[j]) loopmin = A[j];\n\t\t\t\tcheck[j] = true;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcost -= loopmin;\n\t\t\tif ((count-1)*(loopmin-min) > 2*(min + loopmin))\n\t\t\t\tcost += 2*(min + loopmin);\n\t\t\telse\n\t\t\t\tcost += count*loopmin;\n\t\t}\n\t\tSystem.out.println(cost);\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate int[] a;\n\tprivate int[] b;\n\t\n\tprivate Scanner sc;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\tint lim = Integer.parseInt(sc.nextLine());\n\t\t\n\t\ta = new int[lim];\t\t\n\t\tb = new int[lim];\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\ta[i] = Integer.parseInt(sc.next());\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tArrays.sort(b);\n\t\t\n\t\tint ans = 0;\n\t\tboolean judge = false;\n\t\twhile (judge == false) {\n\t\t\tfor (int i = 0; i < lim; i++) {\n\t\t\t\tif (a[i] != b[i]) {\n\t\t\t\t\tfor (int j = (i + 1); j < lim; j++) {\n\t\t\t\t\t\tif ((a[j] == b[i]) && (a[i] == b[j])) {\n\t\t\t\t\t\t\ta[i] = b[i];\n\t\t\t\t\t\t\ta[j] = b[j];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tans = ans + a[i] + a[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint i;\n\t\t\tfor (i = 0; i < lim; i++) {\n\t\t\t\tif (a[i] != b[i]) break;\n\t\t\t}\n\t\t\tif (i == lim) judge = true;\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n    public static void main (String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        Baggage[] w = new Baggage[n];\n        boolean[] checked = new boolean[n];\n        for (int i = 0; i < n; i ++) {\n            w[i] = new Baggage(sc.nextInt(), i);\n        }\n        Arrays.sort(w);\n\n        int i, j, swap;\n        int cost = 0;\n        int min = w[0].weight;\n        for (i = 0; i < n; i++) {\n            if (checked[i]) continue;\n            checked[i] = true;\n            swap = 0;\n            j = w[i].index;\n\n            while (j != i) {\n                checked[j] = true;\n                cost += w[j].weight;\n                swap++;\n                j = w[j].index;\n            }\n            cost += Math.min(w[i].weight * swap, min * swap + (min + w[i].weight) * 2);\n        }\n\n        System.out.println(cost);\n    }\n}\n\nclass Baggage implements Comparable<Baggage> {\n    public int weight;\n    public int index;\n\n    public Baggage(int weight, int index) {\n        this.weight = weight;\n        this.index = index;\n    }\n\n    @Override\n    public int compareTo(Baggage b) {\n        if (weight < b.weight) return -1;\n        else if (weight > b.weight) return 1;\n        else return 0;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.IOException;\n\n// ALDS1_6_D\npublic class Main {\n\tint SENTINEL = 1234567890;\n\tvoid merge(int[]A, int left, int mid, int right) {\n\t\tint n1 = mid - left + 1;\n\t\tint n2 = right - mid;\n\t\tint[] L = new int[n1 + 1];\n\t\tint[] R = new int[n2 + 1];\n\t\tfor (int i = 0; i < n1; i++) {\n\t\t\tL[i] = A[left + i];\n\t\t}\n\t\tfor (int i = 0; i < n2; i++) {\n\t\t\tR[i] = A[mid + 1 + i];\n\t\t}\n\t\tL[n1] = SENTINEL;\n\t\tR[n2] = SENTINEL;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tfor (int k = left; k <= right; k++) {\n\t\t\tif (L[i] <= R[j]) {\n\t\t\t\tA[k] = L[i];\n\t\t\t\ti = i + 1;\n\t\t\t} else {\n\t\t\t\tA[k] = R[j];\n\t\t\t\tj = j + 1;\n\t\t\t}\n\t    }\n\t}\n\n\tvoid mergeSort(int[] A, int left, int right) {\n\t    \tif (left < right) {\n\t    \t\tint mid = (left + right)/2;\n\t    \t\tmergeSort(A, left, mid);\n\t    \t\tmergeSort(A, mid + 1, right);\n\t    \t\tmerge(A, left, mid, right);\n\t  \t}\n\t}\n\tint cost = 0;\n\tvoid run() throws IOException {\n\t\tArrayList<Integer> lis = new ArrayList<Integer>();\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] A = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlis.add(i);\n\t\t\tA[i] = sc.nextInt();\n\t\t}\n\t\tint[] B = A.clone();\n\t\tmergeSort(B, 0, n-1);\n\t\twhile (true) {\n\t\t\t// A[i] == B[i] 値の位置が正しい場合を除外\n\t\t\t//if (lis instanceof ArrayList)\n\t\t\tArrayList<Integer> liscopy = (ArrayList<Integer>) lis.clone();\n\t\t\tfor (Integer v : lis) {\n\t\t\t\tif (A[v] == B[v]) liscopy.remove(v);\n\t\t\t}\n\t\t\tlis = (ArrayList<Integer>) liscopy.clone();\n\t\t\t// 基底条件\n\t\t\tif (lis.isEmpty()) break;\n\t\t\t// 交換する組を決める(重さが一番小さい組の交換元をminpoint)\n\t\t\tint minpoint = lis.get(0);\n\t\t\tfor (Integer v : lis) \n\t\t\t\tif (A[minpoint] + B[minpoint] > A[v] + B[v]) minpoint = v;\n\t\t\t// 交換先の値をtmpnum\n\t\t\tint tmppoint = -1;\n\t\t\tfor (Integer v : lis) {\n\t\t\t\tif (minpoint == v) continue;\n\t\t\t\tif (B[minpoint] == A[v]) tmppoint = v;\n\t\t\t}\n\t\t\tif (tmppoint == -1) System.out.println(\"not tmpnum\");\n\t\t\t// 相互\n\t\t\tfor (Integer v : lis) {\n\t\t\t\tif (minpoint == v) continue;\n\t\t\t\tif (B[minpoint] != B[v]) continue;\n\t\t\t\tif (A[v] == B[tmppoint]) minpoint = v;\n\t\t\t}\n\t\t\tcost += A[tmppoint] + A[minpoint];\n\t\t\tint tmp = A[tmppoint];\n\t\t\tA[tmppoint] = A[minpoint];\n\t\t\tA[minpoint] = tmp;\n\t\t}\n\t\tSystem.out.println(cost);\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\n//import java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\nclass Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\t//System.setIn(new FileInputStream(\"./ALDS1_6_D-in15.txt\"));\n\t\t\n\t\t// Input an array\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\n\t\tBaggage[] a = new Baggage[n];\n\t\tString[] strs = br.readLine().split(\" \");\n\t    for(int i = 0; i < n; ++i){\n\t        a[i] = new Baggage(i, Integer.parseInt(strs[i]));\n\t    }\n\t    \n\t    // Number the array\n\t    mergeSort(a, 0, n);\n\t    /*\n\t    for(int i = 0; i < n; ++i) {\n\t    \tSystem.out.printf(\" %3d\", i);\n\t    }\n\t    System.out.println();\n\t    for(int i = 0; i < n; ++i) {\n\t    \tSystem.out.printf(\" %3d\", a[i].weight);\n\t    }\n\t    System.out.println();\n\t    for(int i = 0; i < n; ++i) {\n\t    \tSystem.out.printf(\" %3d\", a[i].org);\n\t    }\n\t    System.out.println();\n\t    */\n\t    // Calc. cost\n\t    int cost = 0;\n\t    int minw = a[0].weight;\n\t    for(int i = 0; i < n; ++i) {\n\t    \tif(a[i].flag == true){\n\t\t    \t// search group key i\n\t    \t\tcontinue;\n\t    \t}\n\t    \t//System.out.print(\"key \" + i + \" \" + a[i].weight + \": \");\n    \t\t\n\t    \t// count cost for group i\n\t    \tint cnt = 0; // swap count\n\t    \tint j = a[i].org;\n\t    \twhile(j != i) {\n\t    \t\t// swap a[j] and a[i]\n\t    \t    cost += a[j].weight + a[i].weight;\n\t    \t\tcnt += 1;\n\n\t    \t\t//System.out.print(\" \" + a[j].weight);\n\t    \t    a[j].flag = true;\n\t\t    \tj = a[j].org;\n\t   \t    }\n\t    \tif(cnt > 2){\n\t    \t\tcost -= (a[i].weight - minw)*(cnt - 2);\n\t    \t}\n\t    \t//System.out.println(\" ; cost \" + cost);\n\t    }\n\t    \n\t    System.out.println(cost);\n\t}\n\t\n\tpublic static void mergeSort(Baggage[] s, int left, int right) {\n\t\tif(left + 1 < right) {\n\t\t\tint mid = (left + right) / 2;\n\t\t\tmergeSort(s, left, mid);\n\t\t\tmergeSort(s, mid, right);\n\t\t\tmerge(s, left, mid, right);\n\t\t}\n\t}\n\tpublic static void merge(Baggage[] s, int left, int mid, int right) {\n\t\tBaggage[] s1 = Arrays.copyOfRange(s, left, mid + 1);\n\t\tBaggage[] s2 = Arrays.copyOfRange(s, mid, right + 1);\n\t\t\n\t\ts1[mid - left] = new Baggage(-1, Integer.MAX_VALUE);\n\t\ts2[right - mid] = new Baggage(-1, Integer.MAX_VALUE);\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tfor(int k = left; k < right; ++k) {\n\t\t\tif(s1[i].weight <= s2[j].weight){\n\t\t\t\ts[k] = s1[i];\n\t\t\t\ti += 1;\n\t\t\t}else{\n\t\t\t\ts[k] = s2[j];\n\t\t\t\tj += 1;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n\nclass Baggage {\n\tpublic int org;\n\tpublic int weight;\n\tpublic boolean flag;\n\tpublic Baggage(int o, int w) {\n\t\torg = o;\n\t\tweight = w;\n\t\tflag = false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate int[] a;\n\tprivate int[] b;\n\t\n\tprivate Scanner sc;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\tint lim = Integer.parseInt(sc.nextLine());\n\t\t\n\t\ta = new int[lim];\t\t\n\t\tb = new int[lim];\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\ta[i] = Integer.parseInt(sc.next());\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tArrays.sort(b);\n\t\t\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\tif (a[i] != b[i]) {\n\t\t\t\tfor (int j = (i + 1); j < lim; j++) {\n\t\t\t\t\tif ((a[j] == b[i]) && (a[i] == b[j])) {\n\t\t\t\t\t\ta[i] = b[i];\n\t\t\t\t\t\ta[j] = b[j];\n\t\t\t\t\t\t\n\t\t\t\t\t\tans = ans + a[i] + a[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static int cost = 0;\n    public static void main (String[] args) {\n\tScanner scan = new Scanner(System.in);\n\tint n = Integer.parseInt(scan.nextLine());\n\tint[] w = new int[n];\n\tString[] inputA = scan.nextLine().split(\" \");\n\tfor (int i = 0; i < n; i++) {\n\t    w[i] = Integer.parseInt(inputA[i]);\n\t}\n\tsort(w, 0, n-1);\n\tSystem.out.println(cost);\n    }\n    static int partition (int[] a, int left, int right) {\n\tint middleIndex = findmiddle(a, left, right);\n\tint x = a[middleIndex];\n\tint i = left;\n\tint j = right;\n\tint tmp;\n\twhile (true) {\n\t    while(a[i] < x) {\n\t\ti++;\n\t    }\n\t    while(a[j] > x) {\n\t\tj--;\n\t    }\n\t    if (i >= j) {\n\t\tbreak;\n\t    }\n\t    cost += a[i] + a[j];\n\t    tmp = a[i];\n\t    a[i] = a[j];\n\t    a[j] = tmp;\n\t    i++;\n\t    j--;\n\t}\n\treturn i;\n    }\n    static void sort (int[] a, int left, int right) {\n\tif (left < right) {\n\t    int q = partition(a, left, right);\n\t    sort(a, left, q-1);\n\t    sort(a, q+1, right);\n\t}\n    }\n    static int findmiddle (int[] array, int left, int right) {\n\tint a = array[left];\n\tint b = array[(left+right) / 2];\n\tint c = array[right];\n\tif (a <= b) {\n\t    if (c < a) return left;\n\t    else if (b < c) return (left + right)/2;\n\t    else return right;\n\t}\n\telse { // a > b\n\t    if (c < b) return left;\n\t    else if (a < c) return (left + right)/2;\n\t    else return right;\n\t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(reader.readLine());\n\t\tint[] a = new int[n];\n\t\tint[] b = new int[n];\n\t\tStringTokenizer st = new StringTokenizer(reader.readLine());\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = Integer.parseInt(st.nextToken());\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tquickSort(a, 0, n - 1);\n\n\t\tint cost = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (a[i] != b[i]) {\n\t\t\t\tcost += (a[i] + b[i]);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(cost / 2);\n\t}\n\n\tprivate static void quickSort(int[] a, int p, int r) {\n\t\tif (p < r) {\n\t\t\tint q = partition(a, p, r);\n\t\t\tquickSort(a, p, q - 1);\n\t\t\tquickSort(a, q + 1, r);\n\t\t}\n\t}\n\n\tprivate static int partition(int[] a, int p, int r) {\n\t\tint x = a[r];\n\t\tint i = p - 1;\n\t\tfor (int j = p; j < r; j++) {\n\t\t\tif (a[j] <= x) {\n\t\t\t\ti++;\n\t\t\t\tswap(a, i, j);\n\t\t\t}\n\t\t}\n\t\tswap(a, i + 1, r);\n\t\treturn i + 1;\n\t}\n\n\tprivate static void swap(int[] a, int i, int j) {\n\t\tint tmp = a[i];\n\t\ta[i] = a[j];\n\t\ta[j] = tmp;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.TreeSet;\n\n \npublic class Main {\n  public static void main(String[] args) {\n    InputReader sc = new InputReader(System.in);\n \n    int n = sc.nextInt();\n    int[] nums = new int[n];\n    int[] sorted = new int[n];\n    for(int i = 0; i < n; i++){\n      nums[i] = sc.nextInt();\n      sorted[i] = nums[i];\n    }\n    Arrays.sort(sorted);\n\n    int cost = 0;\n    while(true){\n      int min = 20000;\n      int minindex = -1;\n      for(int i = 0; i < n; i++){\n        if(min > nums[i] && nums[i] != sorted[i]){\n          min = nums[i];\n          minindex = i;\n        }\n      }\n      if(minindex < 0){break;}\n      int correctind = Arrays.binarySearch(sorted, min);\n      int keep = nums[correctind];\n      nums[correctind] = nums[minindex];\n      nums[minindex] = keep;\n      cost += nums[correctind] + keep;\n    }\n\n    System.out.println(cost);\n  }\n \n  \n// LinkedList<Integer>[] setsu = new LinkedList[n];\n// for(int i = 0; i < n; i++){\n//   setsu[i] = new LinkedList<Integer>();\n// } \n\n //ここからテンプレ\n  static class InputReader {\n      private InputStream stream;\n      private byte[] buf = new byte[1024];\n      private int curChar;\n      private int numChars;\n      private SpaceCharFilter filter;\n\n      public InputReader(InputStream stream) {\n          this.stream = stream;\n      }\n \n      public int next() {\n          if (numChars == -1)\n              throw new InputMismatchException();\n          if (curChar >= numChars) {\n              curChar = 0;\n              try {\n                  numChars = stream.read(buf);\n              } catch (IOException e) {\n                  throw new InputMismatchException();\n              }\n              if (numChars <= 0)\n                  return -1;\n          }\n          return buf[curChar++];\n      }\n \n      public String nextStr() {\n        int c = next();\n        while(isSpaceChar(c)){c = next();}\n        StringBuffer str = new StringBuffer();\n        do{\n          str.append((char)c);\n          c = next();\n        }while(!isSpaceChar(c));\n        return str.toString();\n      }\n\n      public int nextInt() {\n          int c = next();\n          while (isSpaceChar(c))\n              c = next();\n          int sgn = 1;\n          if (c == '-') {\n              sgn = -1;\n              c = next();\n          }\n          int res = 0;\n          do {\n              if (c < '0' || c > '9')\n                  throw new InputMismatchException();\n              res *= 10;\n              res += c - '0';\n              c = next();\n          } while (!isSpaceChar(c));\n          return res * sgn;\n      }\n \n      public boolean isSpaceChar(int c) {\n          if (filter != null)\n              return filter.isSpaceChar(c);\n          return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n      }\n \n      public interface SpaceCharFilter {\n          public boolean isSpaceChar(int ch);\n      }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\t\n\tpublic void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(reader.readLine());\n\t\tint[] a = new int[n];\n\t\tStringTokenizer st = new StringTokenizer(reader.readLine());\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = Integer.parseInt(st.nextToken());\n\t\t}\n\t\treader.close();\n\t\t\n\t\tSystem.out.println(getMinCost(n, a));\n\t}\n\t\n\tprivate int getMinCost(int n, int[] a) {\n\t\t\n\t\tboolean[] flags = new boolean[n];\n\t\tint[] b = new int[n];\n\t\tint mn = Integer.MAX_VALUE;\n\t\tint mx = Integer.MIN_VALUE;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tb[i] = a[i];\n\t\t\tmn = Math.min(mn, a[i]);\n\t\t\tmx = Math.max(mx, a[i]);\n\t\t}\n\t\tArrays.sort(b);\n\t\t\n\t\tint[] p = new int[mx + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tp[b[i]] = i;\n\t\t}\n\t\t\n\t\tint cost = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (flags[i]) continue;\n\t\t\tint idx = i;\n\t\t\tint sum = 0;\n\t\t\tint cnt = 0;\n\t\t\tint m = Integer.MAX_VALUE;\n\t\t\twhile (true) {\n\t\t\t\tflags[idx] = true;\n\t\t\t\tcnt++;\n\t\t\t\tint val = a[idx];\n\t\t\t\tsum += val;\n\t\t\t\tm = Math.min(m, val);\n\t\t\t\tidx = p[val];\n\t\t\t\tif (flags[idx]) break;\n\t\t\t}\n\t\t\tint c1 = sum + (cnt - 2) * m;\n\t\t\tint c2 = c1 + 2 * (m + mn);\n\t\t\tc2 -= (cnt - 1) * (m - mn);\n\t\t\tcost += Math.min(c1, c2);\n\t\t}\n\t\treturn cost;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate int lim;\n\t\n\tprivate int[] a;\n\tprivate int[] b;\n\t\n\tprivate ArrayList<Integer[]> iset;\n\t\n\tprivate Scanner sc;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\tlim = Integer.parseInt(sc.nextLine());\n\t\t\n\t\ta = new int[lim];\t\t\n\t\tb = new int[lim];\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\ta[i] = Integer.parseInt(sc.next());\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tArrays.sort(b);\n\t\t\n\t\tiset = new ArrayList<Integer[]>();\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\tif (a[i] == b[i]) continue;\n\t\t\tfor (int j = (i + 1); j < lim; j++) {\n\t\t\t\tif (a[j] == b[j]) continue;\n\t\t\t\t\n\t\t\t\tInteger[] ij = {b[i], b[j]};\n\t\t\t\tiset.add(ij);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint min = 0;\n\t\tfor (int i = 0; i < iset.size(); i++) {\n\t\t\tint tmp = swap(i, 0);\n\t\t\t\n\t\t\tif ((tmp != -1) && ((min == 0) || (min > tmp))) min = tmp;\n\t\t}\n\t\t\n\t\tSystem.out.println(min);\n\t}\n\t\n\tpublic int swap(int index, int ans) {\n\t\tInteger[] ij = iset.get(index);\n\t\tiset.remove(index);\n\n\t\tint small = -1;\n\t\tint large = -1;\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\tif (a[i] == ij[0]) {\n\t\t\t\tsmall = i;\n\t\t\t} else if (a[i] == ij[1]) {\n\t\t\t\tlarge = i;\n\t\t\t}\n\t\t\t\n\t\t\tif ((small != -1) && (large != -1)) break;\n\t\t}\n\t\t\n\t\tif ((a[small] == b[large]) || (a[large] == b[small])) {\n\t\t\tint tmp = a[small];\n\t\t\ta[small] = a[large];\n\t\t\ta[large] = tmp;\n\t\t\t\n\t\t\tans = ans + a[small] + a[large];\n\t\t} else {\n\t\t\tiset.add(index, ij);\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tboolean flag = true;\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\tif (a[i] != b[i]) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag) {\n\t\t\tiset.add(index, ij);\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\tint min = 0;\n\t\tfor (int i = 0; i < iset.size(); i++) {\n\t\t\tint tmp = swap(i, ans);\n\t\t\t\n\t\t\tif ((tmp != -1) && ((min == 0) || (min > tmp))) min = tmp;\n\t\t}\n\t\t\n\t\tiset.add(index, ij);\n\t\treturn min;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate int lim;\n\tprivate int wall;\n\t\n\tprivate int[] a;\n\tprivate int[] b;\n\t\n\tprivate ArrayList<Integer[]> iset;\n\t\n\tprivate Scanner sc;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\tlim = Integer.parseInt(sc.nextLine());\n\t\t\n\t\ta = new int[lim];\t\t\n\t\tb = new int[lim];\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\ta[i] = Integer.parseInt(sc.next());\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tArrays.sort(b);\n\t\t\n\t\tiset = new ArrayList<Integer[]>();\n\t\tfor (int i = 1; i < lim * 2; i++) {\n\t\t\tfor (int n0 = 0; n0 < i; n0++) {\n\t\t\t\tint n1 = i - n0;\n\t\t\t\tif (n0 >= n1) break;\n\t\t\t\tif (n1 >= lim) continue;\n\n\t\t\t\tif ((a[n0] == b[n0]) || (a[n1] == b[n1])) continue;\n\n\t\t\t\tInteger[] ij = {b[n0], b[n1]};\n\t\t\t\tiset.add(ij);\n\t\t\t}\n\t\t}\n\t\t\n\t\twall = 0;\n\t\tfor (int i = 0; i < iset.size(); i++) {\n\t\t\tInteger[] ij = iset.get(i);\n\t\t\t\n\t\t\tiset.remove(i);\n\t\t\tswap(ij[0], ij[1], 0);\n\t\t\tiset.add(i, ij);\n\t\t}\n\t\t\n\t\tSystem.out.println(wall);\n\t}\n\t\n\tpublic void swap(int n0, int n1, int ans) {\n\t\tint small = -1;\n\t\tint large = -1;\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\tif (a[i] == n0) {\n\t\t\t\tsmall = i;\n\t\t\t} else if (a[i] == n1) {\n\t\t\t\tlarge = i;\n\t\t\t}\n\t\t\t\n\t\t\tif ((small != -1) && (large != -1)) break;\n\t\t}\n\t\t\n\t\tif ((a[small] == b[large]) || (a[large] == b[small])) {\n\t\t\tint tmp = a[small];\n\t\t\ta[small] = a[large];\n\t\t\ta[large] = tmp;\n\t\t\t\n\t\t\tans = ans + a[small] + a[large];\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tboolean flag = true;\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\tif (a[i] != b[i]) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag) {\n\t\t\tint tmp = a[small];\n\t\t\ta[small] = a[large];\n\t\t\ta[large] = tmp;\n\t\t\t\n\t\t\tif ((wall == 0) || (wall > ans)) wall = ans;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < iset.size(); i++) {\n\t\t\tInteger[] ij = iset.get(i);\n\n\t\t\tif ((wall != 0) && (wall < (ans + ij[0] + ij[1]))) {\n\t\t\t\tint tmp = a[small];\n\t\t\t\ta[small] = a[large];\n\t\t\t\ta[large] = tmp;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tiset.remove(i);\n\t\t\t\n\t\t\tswap(ij[0], ij[1], ans);\n\t\t\t\n\t\t\tiset.add(i, ij);\n\t\t}\n\n\t\tint tmp = a[small];\n\t\ta[small] = a[large];\n\t\ta[large] = tmp;\n\t\treturn;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate int[] a;\n\tprivate int[] b;\n\t\n\tprivate Scanner sc;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\tint lim = Integer.parseInt(sc.nextLine());\n\t\t\n\t\ta = new int[lim];\t\t\n\t\tb = new int[lim];\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\ta[i] = Integer.parseInt(sc.next());\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tArrays.sort(b);\n\n\t\tint max = 0;\n\t\tHashMap<Integer, ArrayList<Integer[]>> iset = new HashMap<Integer, ArrayList<Integer[]>>();\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\tfor (int j = (i + 1); j < lim; j++) {\n\t\t\t\tint sum = a[i] + a[j];\n\t\t\t\tInteger[] ij = {a[i], a[j]};\n\n\t\t\t\tArrayList<Integer[]> ijlist;\n\t\t\t\tif (iset.containsKey(sum) == false) {\n\t\t\t\t\tijlist = new ArrayList<Integer[]>();\n\t\t\t\t} else {\n\t\t\t\t\tijlist = iset.get(sum);\n\t\t\t\t}\n\t\t\t\tijlist.add(ij);\n\t\t\t\t\n\t\t\t\tiset.put(sum, ijlist);\n\t\t\t\t\n\t\t\t\tif (max < sum) max = sum;\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tboolean judge = false;\n\t\tfor (int i = 0; i <= max; i++) {\n\t\t\tArrayList<Integer[]> tmp;\n\t\t\tif (iset.containsKey(i) == true) {\n\t\t\t\ttmp = iset.get(i);\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int j = 0; j < tmp.size(); j++) {\n\t\t\t\tInteger[] ij = tmp.get(j);\n\t\t\t\t\n\t\t\t\tint as = ij[0];\n\t\t\t\tint al = ij[1];\n\t\t\t\t\n\t\t\t\tint small = -1;\n\t\t\t\tint large = -1;\n\t\t\t\tfor (int k = 0; k < lim; k++) {\n\t\t\t\t\tif (a[k] == as) {\n\t\t\t\t\t\tsmall = k;\n\t\t\t\t\t} else if (a[k] == al) {\n\t\t\t\t\t\tlarge = k;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ((small != -1) && (large != -1)) break;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (a[small] == b[large]) {\n\t\t\t\t\ta[small] = a[large];\n\t\t\t\t\ta[large] = b[large];\n\t\t\t\t\t\n\t\t\t\t\tans = ans + i;\n\t\t\t\t}\n\t\t\t\tif (a[large] == b[small]) {\n\t\t\t\t\ta[large] = a[small];\n\t\t\t\t\ta[small] = b[small];\n\t\t\t\t\t\n\t\t\t\t\tans = ans + a[small] + a[large];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tjudge = true;\n\t\t\t\tfor (int k = 0; k < lim; k++) {\n\t\t\t\t\tif (a[k] != b[k]) {\n\t\t\t\t\t\tjudge = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (judge) break;\n\t\t\t}\n\t\t\tif (judge) break;\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Main {\n\t\n\tpublic static class Arr implements Comparable<Arr> {\n\t\tint[] array;\n\t\tint cost;\n\t\t\n\t\tpublic Arr(int[] array, int cost) {\n\t\t\tsuper();\n\t\t\tthis.array = array;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\tpublic boolean is_finished(){\n\t\t\tfor(int i = 1; i < array.length; i++){\n\t\t\t\tif(array[i - 1] > array[i]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Arr arg0) {\n\t\t\treturn this.cost - arg0.cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + Arrays.hashCode(array);\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tArr other = (Arr) obj;\n\t\t\tif (!Arrays.equals(array, other.array))\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\n\t\tfinal int n = sc.nextInt();\n\t\tint[] array = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tarray[i] = sc.nextInt();\n\t\t}\n\t\t\n\t\t\n\t\tPriorityQueue<Arr> queue = new PriorityQueue<Arr>();\n\t\tHashSet<Arr> visited = new HashSet<Arr>();\n\t\tqueue.add(new Arr(array, 0));\n\t\t\n\t\twhile(!queue.isEmpty()){\n\t\t\tfinal Arr arr = queue.poll();\n\t\t\t\n\t\t\tif(arr.is_finished()){\n\t\t\t\tSystem.out.println(arr.cost);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(visited.contains(arr)){\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tvisited.add(arr);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < arr.array.length; i++){\n\t\t\t\tfor(int j = i + 1; j < arr.array.length; j++){\n\t\t\t\t\tint[] next = new int[arr.array.length];\n\t\t\t\t\tSystem.arraycopy(arr.array, 0, next, 0, arr.array.length);\n\t\t\t\t\tint tmp = next[i];\n\t\t\t\t\tnext[i] = next[j];\n\t\t\t\t\tnext[j] = tmp;\n\t\t\t\t\t\n\t\t\t\t\tArr next_arr = new Arr(next, arr.cost + next[i] + next[j]);\n\t\t\t\t\t\n\t\t\t\t\tif(!visited.contains(next_arr)){\n\t\t\t\t\t\tqueue.add(next_arr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n\tpublic static class Scanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().exec();\n\t}\n\t\n\tpublic void test() {\n\t}\n\t\n\tpublic void exec() throws IOException {\n\t\tSimpleInputUtil in = new SimpleInputUtil();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = in.nextInt();\n\t\tint[] w = in.nextInt(new int[n], n);\n\t\tint[] sorted_w = Arrays.copyOf(w, n);\n\t\tArrays.sort(sorted_w);\n\t\tHashMap<Integer,Integer> costMap = new HashMap<>();\n\t\tint minWeight = sorted_w[0];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcostMap.put(sorted_w[i], i);\n\t\t\t\n\t\t}\n\t\tint cost = 0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(w[i]<0) continue;\n\t\t\tint weight = w[i];\n\t\t\tw[i] = -1;\n\t\t\tint firstPos = i;\n\t\t\tint loopCnt = 1;\n\t\t\tint loopCost = weight;\n\t\t\tint loopMinWeight = weight;\n\t\t\tint nextPos = costMap.get(weight);\n\t\t\twhile(firstPos!=nextPos) {\n\t\t\t\tweight = w[nextPos];\n\t\t\t\tw[nextPos] = -1;\n\t\t\t\tloopCnt++;\n\t\t\t\tloopCost += weight;\n\t\t\t\tif(loopMinWeight>weight) loopMinWeight = weight;\n\t\t\t\tnextPos = costMap.get(weight);\n\t\t\t}\n\t\t\tif(loopCnt==1)\n\t\t\t\tcontinue;\n\t\t\telse if (loopCnt==2)\n\t\t\t\tcost += loopCost;\n\t\t\telse {\n\t\t\t\tcost +=  loopCost + Math.min(loopMinWeight*(loopCnt-2), loopMinWeight + minWeight*(loopCnt+1));\n\t\t\t}\n\t\t}\n\t\tout.println(cost);\n\t\tout.flush();\n\t}\n\t\n}\n\nclass SimpleInputUtil {\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n    public String[] readStrArray(String delim) throws NumberFormatException, IOException{\n    \treturn br.readLine().split(delim);\n    }\n    \n    public int nextInt() throws NumberFormatException, IOException{\n    \treturn Integer.parseInt(br.readLine());\n    }\n    \n    public int[] nextInt(int[] a, int num) throws NumberFormatException, IOException{\n        int i=0;\n        while(i<num) {\n            for(String s: br.readLine().split(\" \")){\n            \tif(i<num) {\n                    a[i++] = Integer.parseInt(s);\n            \t}\n            }\n        }\n        return a;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Main {\n\t\n\tpublic static int swap_itr(final int n, final int deep, final int next_pos, int[] array){\n\t\tfinal int length = next_pos - deep;\n\t\t\n\t\tif(length == 0){\n\t\t\treturn naive(n, deep + 1, array);\n\t\t}\n\t\t\n\t\tint min = Integer.MAX_VALUE;\n\t\t\n\t\tfor(int prob = 1; prob <= length; prob++){\n\t\t\tfinal int prev_pos = next_pos - prob;\n\t\t\t\n\t\t\tint tmp = array[next_pos];\n\t\t\tarray[next_pos] = array[prev_pos];\n\t\t\tarray[prev_pos] = tmp; \n\t\t\t\n\t\t\tmin = Math.min(min, swap_itr(n, deep, next_pos - prob, array) + array[next_pos] + array[prev_pos]);\n\t\t\t\n\t\t\ttmp = array[next_pos];\n\t\t\tarray[next_pos] = array[prev_pos];\n\t\t\tarray[prev_pos] = tmp;  \n\t\t}\n\t\t\n\t\treturn min;\n\t}\n\t\n\tpublic static int naive(final int n, final int deep, int[] array) {\n\t\tif(deep >= n){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint min = array[deep];\n\t\tint min_pos = deep;\n\n\t\tfor (int next = deep + 1; next < n; next++) {\n\t\t\tif (array[next] < min) {\n\t\t\t\tmin = array[next];\n\t\t\t\tmin_pos = next;\n\t\t\t}\n\t\t}\n\n\t\tif (min_pos != deep) {\n\t\t\treturn swap_itr(n, deep, min_pos, array);\n\t\t}else{\n\t\t\treturn naive(n, deep + 1, array);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tfinal int n = sc.nextInt();\n\t\tint[] array = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarray[i] = sc.nextInt();\n\t\t}\n\t\t\n\t\tSystem.out.println(naive(n, 0, array));\n\t}\n\n\tpublic static class Scanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tNode W[] = new Node[n];\n\t\tint s=Integer.MAX_VALUE; \n\t\tint cost = 0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tW[i] = new Node();\n\t\t\tW[i].value = scanner.nextInt();\n\t\t\tW[i].place = -1;\n\t\t\tif(s > W[i].value) s = W[i].value;\n\t\t}\n\n\t\tfor(int j=0; j<n; j++){\n\t\t\tint min=Integer.MAX_VALUE, place=-1;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(W[i].place != -1) continue;\n\t\t\t\tif(min > W[i].value){\n\t\t\t\t\tmin = W[i].value;\n\t\t\t\t\tplace = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tW[place].place = j;\n\t\t}\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint j=W[i].place;\n\t\t\tif(j != -1 && j != i){\n\t\t\t\tint cnt=1, min, sum;\n\t\t\t\tmin = sum = W[i].value;\n\t\t\t\twhile(j != i){\n\t\t\t\t\tint next = W[j].place;\n\t\t\t\t\tif(min > W[j].value) min = W[j].value;\n\t\t\t\t\tsum += W[j].value;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tW[j].place = -1;\n\t\t\t\t\tj = next;\n\t\t\t\t}\n\t\t\t\tcost += sum+(cnt-2)*min<sum+min+(cnt+1)*s?\n\t\t\t\t        sum+(cnt-2)*min:\n\t\t\t\t        sum+min+(cnt+1)*s;\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(cost);\n\t}\n}\nclass Node{\n\tint value;\n\tint place;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate int[] a;\n\tprivate int[] b;\n\t\n\tprivate Scanner sc;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\tint lim = Integer.parseInt(sc.nextLine());\n\t\t\n\t\ta = new int[lim];\t\t\n\t\tb = new int[lim];\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\ta[i] = Integer.parseInt(sc.next());\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tArrays.sort(b);\n\t\t\n\t\tint ans = 0;\n\t\t/*for (int i = 0; i < lim; i++) {\n\t\t\tif (a[i] != b[i]) {\n\t\t\t\tfor (int j = (i + 1); j < lim; j++) {\n\t\t\t\t\tif ((a[j] == b[i]) && (a[i] == b[j])) {\n\t\t\t\t\t\ta[i] = b[i];\n\t\t\t\t\t\ta[j] = b[j];\n\t\t\t\t\t\t\n\t\t\t\t\t\tans = ans + a[i] + a[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\t\n\t\tboolean judge = false;\n\t\twhile (judge == false) {\n\t\t\tjudge = true;\n\t\t\t\n\t\t\tfor (int i = 0; i < lim; i++) {\n\t\t\t\tif (a[i] != b[i]) {\n\t\t\t\t\tjudge = false;\n\t\t\t\t\tfor (int j = (i + 1); j < lim; j++) {\n\t\t\t\t\t\tif (a[j] == b[i]) {\n\t\t\t\t\t\t\ta[i] = b[i];\n\t\t\t\t\t\t\ta[j] = b[j];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tans = ans + a[i] + a[j];\n\t\t\t\t\t\t\tjudge = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.stream.Stream;\n\nclass Main {\n\n\tfinal static int MAX = 1_000;\n\tfinal static int VMAX = 10_000;\n\n\tstatic int n, small;\n\tstatic int[] a;\n\tstatic int[] b = new int[MAX];\n\tstatic int[] truery = new int[VMAX+1];\n\n\tpublic static void main(String[] args) {\n\n\t\ttry(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {\n\n\t\t\tn = Integer.parseInt(br.readLine());\n\t\t\ta = Stream.of(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tsmall = VMAX;\n\t\tfor(int w : a) {\n\t\t\tsmall = Math.min(small, w);\n\t\t}\n\n\t\tint ans = solve();\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tprivate static int solve() {\n\t\tint ans = 0;\n\t\tb = Arrays.copyOf(a, n);\t\t\t\t\t\t// ??£?????????????????????b\n\t\tboolean[] valid = new boolean[MAX];\t\t\t// ??£?????????????????§?????£???????????????????????£???????????????\n\n\t\tArrays.sort(b);\n\t\tfor (int i = 0; i < n; i++) truery[b[i]] = i;\t// ????????????number?????¬??\\?????????????????????????¨????\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (valid[i]) continue;\n\t\t\tint cur = i;\n\t\t\tint sum = 0;\t\t// ??????????????????????????????\n\t\t\tint min = VMAX;\t\t// ??????????????§????°???????\n\t\t\tint an = 0;\t\t\t// ?????????????´???°\n\n\t\t\twhile(true) {\n\t\t\t\tvalid[cur] = true;\n\t\t\t\tan++;\n\t\t\t\tint val = a[cur];\n\t\t\t\tmin = Math.min(min, val);\n\t\t\t\tsum += val;\n\t\t\t\tcur = truery[val];\n\t\t\t\tif (valid[cur]) break;\n\t\t\t}\n\n\t\t\tans += Math.min( sum + (an-2) * min, min + sum + (an+1) * small );\n\n\t\t}\n\t\treturn ans;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic int MAX = 1000;\n\tstatic int VMAX = 10000;\n\t\n\tstatic int s;\n\tstatic int[] A = new int[MAX];\n\tstatic int[] B = new int[MAX];\n\tstatic int[] T = new int[VMAX + 1];\n\t\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\ts = VMAX;\n\t\tfor (int i=0; i<n; i++){\n\t\t\tA[i] = sc.nextInt();\n\t\t\ts = Math.min(s, A[i]);\n\t\t}\n\t\tint ans = solve(n);\n\t\tSystem.out.println(ans);\n\t}\n\t\n\tstatic int solve(int n){\n\t\tint ans = 0;\n\t\t\n\t\tint[] V = new int[MAX];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tB[i] = A[i];\n\t\t\tV[i] = 1;\n\t\t}\n\t\tArrays.sort(B, 0, n);\n\t\tfor(int i=0; i<n; i++) T[B[i]] = i;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif (V[i] == 0) continue;\n\t\t\tint cur = i;\n\t\t\tint S = 0;\n\t\t\tint  m = VMAX;\n\t\t\tint an = 0;\n\t\t\tfor (;;) {\n\t\t\t\tV[cur] = 0;\n\t\t\t\tan++;\n\t\t\t\tint v = A[cur];\n\t\t\t\tm = Math.min(m,v);\n\t\t\t\tS += v;\n\t\t\t\tcur = T[v];\n\t\t\t\tif (V[cur] == 0) break;\n\t\t\t}\n\t\t\tans += Math.min(S + (an - 2) * m, m + S + (an + 1) * s);\n\t\t}\n\t\treturn ans;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\n//import java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\nclass Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\t//System.setIn(new FileInputStream(\"./ALDS1_6_D-in3.txt\"));\n\t\t\n\t\t// Input an array\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\n\t\tBaggage[] a = new Baggage[n];\n\t\tString[] strs = br.readLine().split(\" \");\n\t    for(int i = 0; i < n; ++i){\n\t        a[i] = new Baggage(i, Integer.parseInt(strs[i]));\n\t    }\n\t    \n\t    // Number the array\n\t    mergeSort(a, 0, n);\n\t    \n\t    // Calc. cost\n\t    int cost = 0;\n\t    for(int i = 0; i < n; ++i) {\n\t    \tif(a[i].flag == true){\n\t\t    \t// search group key i\n\t    \t\tcontinue;\n\t    \t}\n\t    \t// count cost for group i\n\t    \tint j = a[i].org;\n\t    \twhile(j != i) {\n\t    \t\t// swap a[j] and a[i]\n\t    \t    cost += a[j].weight + a[i].weight;\n\t    \t    a[j].flag = true;\n\t\t    \tj = a[j].org;\n\t   \t    }\n\t    }\n\t    \n\t    System.out.println(cost);\n\t}\n\t\n\tpublic static void mergeSort(Baggage[] s, int left, int right) {\n\t\tif(left + 1 < right) {\n\t\t\tint mid = (left + right) / 2;\n\t\t\tmergeSort(s, left, mid);\n\t\t\tmergeSort(s, mid, right);\n\t\t\tmerge(s, left, mid, right);\n\t\t}\n\t}\n\tpublic static void merge(Baggage[] s, int left, int mid, int right) {\n\t\tBaggage[] s1 = Arrays.copyOfRange(s, left, mid + 1);\n\t\tBaggage[] s2 = Arrays.copyOfRange(s, mid, right + 1);\n\t\t\n\t\ts1[mid - left] = new Baggage(-1, Integer.MAX_VALUE);\n\t\ts2[right - mid] = new Baggage(-1, Integer.MAX_VALUE);\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tfor(int k = left; k < right; ++k) {\n\t\t\tif(s1[i].weight <= s2[j].weight){\n\t\t\t\ts[k] = s1[i];\n\t\t\t\ti += 1;\n\t\t\t}else{\n\t\t\t\ts[k] = s2[j];\n\t\t\t\tj += 1;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n\nclass Baggage {\n\tpublic int org;\n\tpublic int weight;\n\tpublic boolean flag;\n\tpublic Baggage(int o, int w) {\n\t\torg = o;\n\t\tweight = w;\n\t\tflag = false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tfinal static int vmax = 10000;\n\tfinal static int max = 1000;\n\t\n\tint n, s;\n\tint[] w;\n\t\n\tint[] B = new int[max];\n\tint[] T = new int[vmax+1];\n\t\n\t//入力\n\tpublic void input() {\n\t\tn = sc.nextInt();\n\t\tw = new int[n];\n\t\ts = vmax;\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tw[i] = sc.nextInt();\n\t\t\ts = Math.min(s, w[i]);\n\t\t}\n\t}\n\t\n\t//出力\n\tpublic void conan() {\n\t\tint ans = solve();\n\t\tSystem.out.println( ans );\n\t}\n\t\n\t//解を求める\n\tpublic int solve() {\n\t\tint ans = 0;\n\t\tboolean[] V = new boolean[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tB[i] = w[i];\n\t\t\tV[i] = false;\n\t\t}\n\t\t//配列Bをソートする\n\t\t//開始と終了のインデックスを指定する\n\t\tArrays.sort(B,0,n);\n\t\t\n\t\tfor(int i=0; i<n; i++) { T[ B[i] ] = i; }\n\t\t\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tif( V[i] ) continue;\n\t\t\tint cur = i;\n\t\t\tint S = 0;\n\t\t\tint m = vmax;\n\t\t\tint an = 0;\n\t\t\twhile( true ) {\n\t\t\t\tV[cur] = true;\n\t\t\t\tan++;\n\t\t\t\tint v = w[cur];\n\t\t\t\tm = Math.min(m, v);\n\t\t\t\tS += v;\n\t\t\t\tcur = T[v];\n\t\t\t\tif( V[cur] ) break;\n\t\t\t}\n\t\t\tans += Math.min( S+(an-2)*m, m+S+(an+1)*s );\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t    Main obj = new Main();\n\t\tobj.input();\n\t\tobj.conan();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tint max = 0;\n\t\tint min = 1 << 16;\n\t\tint[] num = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = scanner.nextInt();\n\t\t\tnum[i] = t;\n\t\t\tmax = Math.max(max, t);\n\t\t\tmin = Math.min(min, t);\n\t\t}\n\t\tboolean[] b = new boolean[n];\n\t\tint[] sortnum = Arrays.copyOf(num, n);\n\t\tArrays.sort(sortnum);\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\tfor (int t : sortnum)\n\t\t\tlist.add(t);\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif(b[i])\n\t\t\t\tcontinue;\n\t\t\tint s = 0;\n\t\t\tint an = 0;\n\t\t\tint cur = i;\n\t\t\tint m = max;\n\t\t\twhile (true) {\n\t\t\t\tb[cur] = true;\n\t\t\t\tan++;\n\t\t\t\tint v = num[cur];\n\t\t\t\tm = Math.min(m, v);\n\t\t\t\ts += v;\n\t\t\t\tcur = list.indexOf(v);\n\t\t\t\tif (b[cur])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint aa = s + (an - 2) * m;\n\t\t\tint bb = s + m + (an + 1) * min;\n\t\t\tans += Math.min(aa, bb);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args)  {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tint[] W = new int[n]; \n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tW[i] = scanner.nextInt();\n\t\t}\n\t\tSystem.out.println(minCostSort(W));\n\t}\n\tpublic static int indexOf(int[] A, int x) {\n\t\tfor (int i = 0; i < A.length; i++) {\n\t\t\tif (A[i] == x) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tpublic static int minCostSort(int[] W) {\n\t\tint sorted[] = W.clone();\n\t\tArrays.sort(sorted);\n\t\tint cost = 0;\n\t\tfor (int i = 0; i < W.length; i++) {\n\t\t\tint a = indexOf(W, sorted[i]);\n\t\t\tint j = 0;\n\t\t\twhile (a > i) {\n\t\t\t\tj++;\n\t\t\t\tint b = indexOf(W, sorted[a]);\n\t\t\t\tcost += W[b];\n\t\t\t\tint t = W[a];\n\t\t\t\tW[a] = W[b];\n\t\t\t\tW[b] = t;\n\t\t\t\ta = b;\n\t\t\t}\n\t\t\tcost += Math.min(sorted[i] * j, sorted[i] * 2 + sorted[0] * (j * 2));\n\t\t}\n\t\treturn cost;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tBufferedReader br =\n\t\t\t\tnew BufferedReader( new InputStreamReader(System.in) );\n\t\tint n = Integer.parseInt( br.readLine() );\n\n\t\tString[] str = br.readLine().split(\" \");\n\t\tBag[] W = new Bag[n]; // ??´????????????????????? w_i ?????\\????????????\n\t\tBag[] orderedW = new Bag[n]; // ??´??????????????????????????\\????????????\n\t\tfor (int i=0; i < n; i++) {\n\t\t\tW[i] = new Bag( Integer.parseInt(str[i]), i );\n\t\t\torderedW[i] = W[i];\n\t\t}\n\n\t\tArrays.sort(orderedW);\n//\t\tfor (int i=0; i < w.length; i++)\n//\t\t\tSystem.out.print(w[i] + \" \");\n\n\t\tfor (int i=0; i < n; i++) {\n\t\t\torderedW[i].posti = i;\n\t\t}\n\n\t\t/*\n\t\t * 5, 4, 1, 3, 2, : W\n\t\t *\n\t\t *                  W[0] = 5\n\t\t *  , 4, 1, 3, 2, : bag = 5, nextbag = 2,\n\t\t *             5,\n\t\t *\n\t\t *  , 4, 1, 3, 5, : bag = 2, nextbag = 4,\n\t\t *    2,\n\t\t *\n\t\t *  , 2, 1, 3, 5, : bag = 4, nextbag = 3,\n\t\t *          4,\n\t\t *\n\t\t *  , 2, 1, 4, 5, : bag = 3, nextbag = 1,\n\t\t *       3,\n\t\t *\n\t\t *  , 2, 3, 4, 5, : bag = 1, nextbag = 5,\n\t\t * 1,\n\t\t *                  bag = 5,\n\t\t *                  bag.prei = 0\n\t\t *\n\t\t * 1, 2, 3, 4, 5, : orderedW\n\t\t */\n\n\t\tBag bag, nextbag;\n\t\tint mini;\n\t\tint count;\n\t\tint ans = 0;\n\n\t\tfor (int i=0; i < n; i++) {\n\t\t\tbag = W[i];\n\t\t\tif (bag.label == true) continue;\n\t\t\tif (bag.prei == bag.posti) continue;\n\n\t\t\tbag.label = true;\n\t\t\tcount = 0;\n\t\t\tmini = bag.wei;\n\t\t\twhile (true) {\n\t\t\t\tnextbag = W[bag.posti]; // nextbag.prei == bag.posti\n\t\t\t\tnextbag.label = true;\n\t\t\t\tcount++;\n\t\t\t\tans += bag.wei;\n\t\t\t\tif (nextbag.wei < mini) mini = nextbag.wei;\n\t\t\t\tbag = nextbag;\n\t\t\t\tif (bag.prei == i) break;\n\t\t\t}\n\t\t\tans += mini * (count-2);\n\t\t}\n\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic class Bag implements Comparable<Bag> {\n\t\tint wei; // weight\n\n\t\tint prei; // pre index ??´?????????????????????????????????\n\n\t\tint posti; // post index ??´??????????????¨?????????????????????\n\n\t\tboolean label = false;\n\n\t\tBag(int w, int i) {\n\t\t\tthis.wei= w;\n\t\t\tthis.prei = i;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Bag b) {\n\t\t\treturn this.wei - b.wei;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"\" + wei;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tfinal boolean DEBUG = false;\n\tfinal int INF = Integer.MAX_VALUE;\n\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint[] w = new int[n];\n\t\tint[] a = new int[n];\n\t\tint[] _a = new int[n];\n\t\tint[] rank = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\trank[i] = INF;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = w[i] = scan.nextInt();\n\t\tArrays.sort(a);\n\t\tint min = a[0];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\t_a[i] = Arrays.binarySearch(a, w[i]);\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(Arrays.toString(w));\n\t\t\tSystem.out.println(Arrays.toString(_a));\n\t\t\tSystem.out.println(Arrays.toString(a));\n\t\t}\n\t\tint index = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint idx = i;\n\t\t\tif (rank[i] != INF)\n\t\t\t\tcontinue;\n\t\t\twhile (rank[i] == INF) {\n\t\t\t\trank[_a[idx]] = index;\n\t\t\t\tidx = _a[idx];\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\tif (DEBUG)\n\t\t\tSystem.out.println(Arrays.toString(rank));\n\t\tHashMap<Integer, LinkedList<Integer>> map = new HashMap<Integer, LinkedList<Integer>>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tLinkedList<Integer> list = map.get(rank[i]);\n\t\t\tif (list == null) {\n\t\t\t\tLinkedList<Integer> l = new LinkedList<Integer>();\n\t\t\t\tl.add(w[i]);\n\t\t\t\tmap.put(rank[i], l);\n\t\t\t} else {\n\t\t\t\tlist.add(w[i]);\n\t\t\t\tmap.put(rank[i], list);\n\t\t\t}\n\t\t}\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(map.size());\n\t\t\tfor (int i = 0; i < map.size(); i++) {\n\t\t\t\tLinkedList<Integer> list = map.get(i);\n\t\t\t\tSystem.out.println(\"map \" + i + \": \" + list.toString());\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < map.size(); i++) {\n\t\t\tLinkedList<Integer> list = map.get(i);\n\t\t\tif (list.size() == 1)\n\t\t\t\tcontinue;\n\t\t\tint sum = 0;\n\t\t\tint m = INF;\n\t\t\tint length = list.size();\n\t\t\tfor (int j = 0; j < length; j++) {\n\t\t\t\tint num = list.get(j);\n\t\t\t\tsum += num;\n\t\t\t\tm = Math.min(m, num);\n\t\t\t}\n\t\t\tif (DEBUG)\n\t\t\t\tSystem.out.println(sum + \" \" + m + \" \" + ((length + 1) * min));\n\t\t\tans += Math.min(sum + (length - 2) * m, sum + m + (length + 1) * min);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate int[] a;\n\tprivate int[] b;\n\t\n\tprivate Scanner sc;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\tint lim = Integer.parseInt(sc.nextLine());\n\t\t\n\t\ta = new int[lim];\t\t\n\t\tb = new int[lim];\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\ta[i] = Integer.parseInt(sc.next());\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tArrays.sort(b);\n\t\t\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\tif (a[i] != b[i]) {\n\t\t\t\tfor (int j = (i + 1); j < lim; j++) {\n\t\t\t\t\tif ((a[j] == b[i]) && (a[i] == b[j])) {\n\t\t\t\t\t\ta[i] = b[i];\n\t\t\t\t\t\ta[j] = b[j];\n\t\t\t\t\t\t\n\t\t\t\t\t\tans = ans + a[i] + a[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.print(ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tprivate static FastScanner sc = new FastScanner();\n\n\tpublic static void main(String[] args) {\n\t\tint n = sc.nextInt();\n\t\t\n\t\tint[] w = new int[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tw[i] = sc.nextInt();\n\t\t}\n\t\t\n\t\tint cost = 0;\n\t\tfor(int i=n-1; i>=1; i--) {\n\t\t\tint max = w[i];\n\t\t\tint idx = i;\n\t\t\tfor(int j=0; j<i; j++) {\n\t\t\t\tif(w[j] > max) {\n\t\t\t\t\tmax = w[j];\n\t\t\t\t\tidx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(i != idx) {\n\t\t\t\tint temp = w[i];\n\t\t\t\tw[i] = w[idx];\n\t\t\t\tw[idx] = temp;\n\t\t\t\tcost += w[i] + w[idx];\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(cost);\n\t}\n\n\tstatic class FastScanner {\n\t    private final InputStream in = System.in;\n\t    private final byte[] buffer = new byte[1024];\n\t    private int ptr = 0;\n\t    private int buflen = 0;\n\t    private boolean hasNextByte() {\n\t        if (ptr < buflen) {\n\t            return true;\n\t        }else{\n\t            ptr = 0;\n\t            try {\n\t                buflen = in.read(buffer);\n\t            } catch (IOException e) {\n\t                e.printStackTrace();\n\t            }\n\t            if (buflen <= 0) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\t    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\t    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t    public String next() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        StringBuilder sb = new StringBuilder();\n\t        int b = readByte();\n\t        while(isPrintableChar(b)) {\n\t            sb.appendCodePoint(b);\n\t            b = readByte();\n\t        }\n\t        return sb.toString();\n\t    }\n\t    public long nextLong() {\n\t        return Long.parseLong(next());\n\t    }\n\t    public int nextInt(){\n\t    \treturn Integer.parseInt(next());\n\t    }\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        Integer[] a = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n        int max = 0, idx = 0;\n        long cost = 0;\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = 0; j <= i; j++) {\n                if (max < a[j]) {\n                    max = a[j];\n                    idx = j;\n                }\n            }\n            if (idx != i) {\n                int tmp = a[i];\n                a[i] = a[idx];\n                a[idx] = tmp;\n                cost += a[i] + a[idx];\n            }\n            max = 0;\n        }\n        System.out.println(cost);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static int swap(int[] array, int a, int b){\n\t\tint tmp = array[a];\n\t\tarray[a] = array[b];\n\t\tarray[b] = tmp;\n\t\t\n\t\treturn array[a] + array[b];\n\t}\n\t\n\tpublic static int do_swap(int[] array, int[] sorted, int min_pos, boolean act){\n\t\tfinal int min = array[min_pos];\n\t\tint loop = min_pos;\n\t\tint sum = 0;\n\t\t\n\t\tdo{\n\t\t\tfor(int i = 0; i < array.length; i++){\n\t\t\t\tif(array[i] == sorted[loop]){\n\t\t\t\t\tif(act){\n\t\t\t\t\t\tsum += swap(array, i, loop);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum += (array[i] + min);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tloop = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}while(min != sorted[loop]);\n\t\t\n\t\treturn sum;\n\t}\n\t\n\tpublic static int swapping(int[] array, int[] sorted){\n\t\tfinal int absolute_min = sorted[0];\n\t\tint absolute_min_pos = -1;\n\t\tint min = Integer.MAX_VALUE, min_pos = -1;\n\t\t\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tif(array[i] == absolute_min){\n\t\t\t\tabsolute_min_pos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tif(sorted[i] != array[i] && min > array[i]){\n\t\t\t\tmin = array[i];\n\t\t\t\tmin_pos = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(min_pos == -1){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tfinal int direct = do_swap(array, sorted, min_pos, false);\n\t\t\n\t\tswap(array, min_pos, absolute_min_pos);\n\t\tfinal int indirect = do_swap(array, sorted, min_pos, false) + min + absolute_min;\n\t\tswap(array, min_pos, absolute_min_pos);\n\t\t\n\t\tif(direct <= indirect){\n\t\t\treturn do_swap(array, sorted, min_pos, true);\n\t\t}else{\n\t\t\tswap(array, min_pos, absolute_min_pos);\n\t\t\treturn do_swap(array, sorted, min_pos, true) + min + absolute_min;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tfinal int n = sc.nextInt();\n\t\tint[] array  = new int[n];\n\t\tint[] sorted = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tarray[i]  = sc.nextInt();\n\t\t\tsorted[i] = array[i];\n\t\t}\n\t\tArrays.sort(sorted);\n\t\t\n\t\tint answer = 0, ret = 0;\n\t\twhile((ret = swapping(array, sorted)) != 0){\n\t\t\tanswer += ret;\n\t\t}\n\t\t\n\t\tSystem.out.println(answer);\n\t}\n\n\tpublic static class Scanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tNode W[] = new Node[n];\n\t\tint s=Integer.MAX_VALUE, cost=0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tW[i] = new Node();\n\t\t\tW[i].value = sc.nextInt();\n\t\t\tW[i].place = -1;\n\t\t\tif(s > W[i].value) s = W[i].value;\n\t\t}\n\n\t\tfor(int j=0; j<n; j++){\n\t\t\tint min=Integer.MAX_VALUE, place=-1;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(W[i].place != -1) continue;\n\t\t\t\tif(min > W[i].value){\n\t\t\t\t\tmin = W[i].value;\n\t\t\t\t\tplace = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tW[place].place = j;\n\t\t}\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint j=W[i].place;\n\t\t\tif(j != -1 && j != i){\n\t\t\t\tint cnt=1, min, sum;\n\t\t\t\tmin = sum = W[i].value;\n\t\t\t\twhile(j != i){\n\t\t\t\t\tint next = W[j].place;\n\t\t\t\t\tif(min > W[j].value) min = W[j].value;\n\t\t\t\t\tsum += W[j].value;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tW[j].place = -1;\n\t\t\t\t\tj = next;\n\t\t\t\t}\n\t\t\t\tcost += sum+(cnt-2)*min<sum+min+(cnt+1)*s?\n\t\t\t\t        sum+(cnt-2)*min:\n\t\t\t\t        sum+min+(cnt+1)*s;\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(cost);\n\t}\n}\nclass Node{\n\tint value;\n\tint place;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tfinal boolean DEBUG = false;\n\tfinal int INF = Integer.MAX_VALUE;\n\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint[] w = new int[n];\n\t\tint[] sortedW = new int[n];\n\t\tint[] transDestIdx = new int[n];\n\t\tint[] rank = new int[n];\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t\trank[i] = INF;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tsortedW[i] = w[i] = scan.nextInt();\n\t\tArrays.sort(sortedW);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ttransDestIdx[i] = Arrays.binarySearch(sortedW, w[i]);\n\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(Arrays.toString(w));\n\t\t\tSystem.out.println(Arrays.toString(transDestIdx));\n\t\t\tSystem.out.println(Arrays.toString(sortedW));\n\t\t}\n\n\t\tint r = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint idx = i;\n\t\t\tif (rank[i] != INF)\n\t\t\t\tcontinue;\n\t\t\twhile (rank[i] == INF) {\n\t\t\t\trank[transDestIdx[idx]] = r;\n\t\t\t\tidx = transDestIdx[idx];\n\t\t\t}\n\t\t\tr++;\n\t\t}\n\t\tif (DEBUG)\n\t\t\tSystem.out.println(Arrays.toString(rank));\n\n\t\tHashMap<Integer, LinkedList<Integer>> map = new HashMap<Integer, LinkedList<Integer>>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tLinkedList<Integer> list = map.get(rank[i]);\n\t\t\tif (list == null) {\n\t\t\t\tLinkedList<Integer> l = new LinkedList<Integer>();\n\t\t\t\tl.add(w[i]);\n\t\t\t\tmap.put(rank[i], l);\n\t\t\t} else {\n\t\t\t\tlist.add(w[i]);\n\t\t\t\tmap.put(rank[i], list);\n\t\t\t}\n\t\t}\n\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(map.size());\n\t\t\tfor (int i = 0; i < map.size(); i++) {\n\t\t\t\tLinkedList<Integer> list = map.get(i);\n\t\t\t\tSystem.out.println(\"map \" + i + \": \" + list.toString());\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < map.size(); i++) {\n\t\t\tLinkedList<Integer> list = map.get(i);\n\t\t\tif (list.size() == 1)\n\t\t\t\tcontinue;\n\t\t\tint sum = 0;\n\t\t\tint min = INF;\n\t\t\tint length = list.size();\n\t\t\tfor (int j = 0; j < length; j++) {\n\t\t\t\tint num = list.get(j);\n\t\t\t\tsum += num;\n\t\t\t\tmin = Math.min(min, num);\n\t\t\t}\n\t\t\tif (DEBUG)\n\t\t\t\tSystem.out.println(sum + \" \" + min + \" \" + length);\n\t\t\tans += Math.min(sum + (length - 2) * min, sum + min + (length + 1) * sortedW[0]);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Set;\n\n\nclass Weight implements Comparable<Weight> {\n\n\tint num, prev;\n\n\tpublic Weight(int num, int prev) {\n\t\tsuper();\n\t\tthis.num = num;\n\t\tthis.prev = prev;\n\t}\n\n\t@Override\n\tpublic int compareTo(Weight o) {\n\n\t\tif (this.num < o.num) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (this.num > o.num) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n}\n\npublic class Main {\n\n\n\tpublic static Set<Weight> checked = new HashSet<>();\n\n\tpublic static int minCostChange(Weight[] arr, int i) {\n\t\tint useMin = 0, useOnlyRange = 0;\n\n\t\tWeight w = arr[i];\n\t\tint min = arr[0].num;\n\t\tList<Weight> list = new ArrayList<>();\n\t\tlist.add(w);\n\t\tuseMin += min + w.num;\n\t\tuseOnlyRange += w.num;\n\t\tchecked.add(w);\n\t\twhile(i != w.prev) {\n\t\t\tw = arr[w.prev];\n\t\t\tlist.add(w);\n\t\t\tuseMin += min + w.num;\n\t\t\tuseOnlyRange += w.num;\n\t\t\tchecked.add(w);\n\t\t}\n\t\tCollections.sort(list);\n\t\tuseMin += min + list.get(0).num;\n\t\tuseOnlyRange += list.get(0).num * (list.size() - 2);\n\t\treturn Math.min(useMin, useOnlyRange);\n\t}\n\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\n\t\tWeight[] arr = new Weight[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i] = new Weight(sc.nextInt(), i);\n\t\t}\n\t\tArrays.sort(arr);\n\n\t\tint min = arr[0].num;\n\t\tint sum = 0;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (arr[i].prev != i && !checked.contains(arr[i])) {\n\t\t\t\tsum += minCostChange(arr, i);\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(sum);\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.IOException;\n\n// ALDS1_6_D\npublic class Main {\n\tint binarySearch(int[] array, int n, int min, int max) {\n\t\tif (min > max) return -1;\n\t\tint mid = (max + min) / 2;\n\t\tif (array[mid] == n) return mid;\n\t\tif (array[mid] > n) return binarySearch(array, n, min, mid-1);\n\t\telse return binarySearch(array, n, mid+1, max);\n\t}\n\t\n\tint SENTINEL = 1234567890;\n\tvoid merge(int[]A, int left, int mid, int right) {\n\t\tint n1 = mid - left + 1;\n\t\tint n2 = right - mid;\n\t\tint[] L = new int[n1 + 1];\n\t\tint[] R = new int[n2 + 1];\n\t\tfor (int i = 0; i < n1; i++) {\n\t\t\tL[i] = A[left + i];\n\t\t}\n\t\tfor (int i = 0; i < n2; i++) {\n\t\t\tR[i] = A[mid + 1 + i];\n\t\t}\n\t\tL[n1] = SENTINEL;\n\t\tR[n2] = SENTINEL;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tfor (int k = left; k <= right; k++) {\n\t\t\tif (L[i] <= R[j]) {\n\t\t\t\tA[k] = L[i];\n\t\t\t\ti = i + 1;\n\t\t\t} else {\n\t\t\t\tA[k] = R[j];\n\t\t\t\tj = j + 1;\n\t\t\t}\n\t    }\n\t}\n\n\tvoid mergeSort(int[] A, int left, int right) {\n\t    \tif (left < right) {\n\t    \t\tint mid = (left + right)/2;\n\t    \t\tmergeSort(A, left, mid);\n\t    \t\tmergeSort(A, mid + 1, right);\n\t    \t\tmerge(A, left, mid, right);\n\t  \t}\n\t}\n\tint cost = 0;\n\tvoid run() throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint min = 10000;\n\t\tint[] A = new int[n];\n\t\tboolean[] check = new boolean[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tA[i] = sc.nextInt();\n\t\t\tcheck[i] = false;\n\t\t\tif (min > A[i]) min = A[i];\n\t\t}\n\t\tint[] B = A.clone();\n\t\tmergeSort(B, 0, n-1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (check[i]) continue;\n\t\t\tcheck[i] = true;\n\t\t\tif (A[i] == B[i]) continue;\n\t\t\tint loopmin = A[i];\n\t\t\tint count = 0;\n\t\t\tint j = i;\n\t\t\twhile(true) {\n\t\t\t\tcost += A[j];\n\t\t\t\tj = binarySearch(B, A[j], 0, n-1);\n\t\t\t\tif (check[j]) break;\n\t\t\t\tif (loopmin > A[j]) loopmin = A[j];\n\t\t\t\tcheck[j] = true;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcost -= loopmin;\n\t\t\tif ((count)*(loopmin-min) > 2*(min + loopmin))\n\t\t\t\tcost += 2*(min + loopmin) + count*min;\n\t\t\telse\n\t\t\t\tcost += count*loopmin;\n\t\t}\n\t\tSystem.out.println(cost);\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args)  {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tint[] W = new int[n]; \n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tW[i] = scanner.nextInt();\n\t\t}\n\t\tSystem.out.println(minCostSort(W, n));\n\t}\n\tpublic static int minCostSort(int[] W, int n) {\n\t\tint cost = 0, min, k, t;\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tmin = W[i + 1];\n\t\t\tk = i + 1;\n\t\t\tfor (int j = i + 2; j < n; j++) {\n\t\t\t\tif (min > W[j]) {\n\t\t\t\t\tmin = W[j];\n\t\t\t\t\tk = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (W[i] > min) {\n\t\t\t\tcost += W[i] + W[k];\n\t\t\t\tt = W[i];\n\t\t\t\tW[i] = W[k];\n\t\t\t\tW[k] = t;\n\t\t\t}\n\t\t}\n\t\treturn cost;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tfinal int INF = Integer.MAX_VALUE;\n\tint cost = 0;\n\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint[] m = new int[n];\n\t\tint[] q = new int[n];\n\t\tint[] s = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ts[i] = m[i] = q[i] = scan.nextInt();\n\n\t\tselectionSort(s, n);\n\t\tSystem.out.println(cost);\n\t}\n\t\n\tvoid selectionSort(int[] a, int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint min_j = i;\n\t\t\tfor (int j = i; j < n; j++) {\n\t\t\t\tif (a[j] < a[min_j])\n\t\t\t\t\tmin_j = j;\n\t\t\t}\n\t\t\tif (i == min_j)\n\t\t\t\tcontinue;\n\t\t\tcost += a[i] + a[min_j];\n\t\t\tint tmp = a[i];\n\t\t\ta[i] = a[min_j];\n\t\t\ta[min_j] = tmp;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main{\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int n = scan.nextInt();\n        Node W[] = new Node[n];\n        int s = Integer.MAX_VALUE, cost = 0;\n        for (int i = 0; i < n; i++) {\n            W[i] = new Node();\n            W[i].value = scan.nextInt();\n            W[i].place = -1;\n            if (s > W[i].value)\n                s = W[i].value;\n        }\n        for (int j = 0; j < n; j++) {\n            int min = Integer.MAX_VALUE, place = -1;\n            for (int i = 0; i < n; i++) {\n                if (W[i].place != -1)\n                    continue;\n                if (min > W[i].value) {\n                    min = W[i].value;\n                    place = i;\n                }\n            }\n            W[place].place = j;\n        }\n        for (int i = 0; i < n; i++) {\n            int j = W[i].place;\n            if (j != -1 && j != i) {\n                int cnt = 1, min, sum;\n                min = sum = W[i].value;\n                while (j != i) {\n                    int next = W[j].place;\n                    if (min > W[j].value)\n                        min = W[j].value;\n                    sum += W[j].value;\n                    cnt++;\n                    W[j].place = -1;\n                    j = next;\n                }\n                if(sum + (cnt - 2) * min < sum + min + (cnt + 1) * s){\n                    cost += sum + (cnt - 2) * min;\n                }\n                else{\n                    cost += sum + min + (cnt + 1) * s;\n                }\n            }\n        }\n        System.out.println(cost);\n    }\n}\nclass Node {\n    int value;\n    int place;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic int cost = 0;\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tint n = 0;\n\t\tint tmp = br.read();\n\t\twhile(tmp != 13 && tmp != 10){\n\t\t\tn = n * 10 + (tmp - '0');\n\t\t\ttmp = br.read();\n\t\t}\n\n\t\tint[] array = new int[n];\n\t\tint[] sortedArray = new int[n];\n\t\tint num = 0;\n\t\tint i1 = 0;\n\t\ttmp = br.read();\n\t\tif(tmp == 13 || tmp == 10){\n\t\t\ttmp = br.read();\n\t\t}\n\t\twhile(tmp != -1 && tmp != 10 && tmp != 13){\n\t\t\tnum = 0;\n\t\t\twhile(tmp >= '0' && tmp <= '9'){\n\t\t\t\tnum = num * 10 + (tmp - '0');\n\t\t\t\ttmp = br.read();\n\t\t\t}\n\t\t\tif(tmp == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tarray[i1] = num;\n\t\t\tsortedArray[i1] = num;\n\t\t\ti1++;\n\t\t\ttmp = br.read();\n\t\t}\n\t\t\n\t\tArrays.sort(sortedArray);\n\t\tint[] trueIndex = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ttrueIndex[i] = Arrays.binarySearch(sortedArray, array[i]);\n\t\t}\n\t\t\n\t\t//??????????????¢???\n\t\tboolean[] checked = new boolean[n];\n\t\tArrays.fill(checked, false);\n\t\t\n\t\tfor(int i = 0; i < n ; i++){\n\t\t\tif(i == trueIndex[i] || checked[i] == true){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tArrayList<Integer> cycle = new ArrayList<Integer>();\n\t\t\tcycle.add(array[i]);\n\t\t\tint j = trueIndex[i];\n\t\t\twhile(j != i){\n\t\t\t\tchecked[j] = true;\n\t\t\t\tcycle.add(array[j]);\n\t\t\t\tj = trueIndex[j];\n\t\t\t}\n\t\t\t\n\t\t\t//????????????????°?????????§??????????????????????????????????¨??¨????\n\t\t\tint min = cycle.get(0);\n\t\t\tfor(int k = 0; k < cycle.size(); k++){\n\t\t\t\tif(min > cycle.get(k)){\n\t\t\t\t\tmin = cycle.get(k);\n\t\t\t\t}\n\t\t\t\tcost+=cycle.get(k);\n\t\t\t}\n\t\t\tcost += min*(cycle.size() - 2);\n\t\t}\n\t\t\n\t\t//quickSort(array, 0, array.length - 1);\n\t\t\n\t\tSystem.out.println(cost);\n\t\t/*\n\t\tStringBuilder sb = new StringBuilder(array.length * 5 / 2);\n\t\tint outLen = array.length;\n\t\tsb.append(array[0]);\n\t\tfor(int i = 1; i < outLen ; i++){\n\t\t\tsb.append(\" \"+array[i]);\n\n\t\t}\n\t\tSystem.out.println(sb);\n\t\t*/\n\t}\n\t/*\n\tstatic void quickSort(int[] array, int p, int r){\n\t\tif(p < r){\n\t\t\tint q = partition(array, p, r);\n\t\t\tquickSort(array, p, q - 1);\n\t\t\tquickSort(array, q + 1, r);\n\t\t}\n\t}*/\n\t/*\n\tstatic int partition(int[] array, int p, int r){\n\t\tint x = array[r];\n\t\tint i = p - 1;\n\t\tfor(int j = p ; j <= r -1 ;j++){\n\t\t\tif(array[j] <= x){\n\t\t\t\ti++;\n\t\t\t\tint tmp = array[i];\n\t\t\t\tarray[i] = array[j];\n\t\t\t\tarray[j] = tmp;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(true || array[i + 1] != array[r]){\n\t\t\tcost += array[i + 1] + array[r];\n\t\t\tSystem.out.println(\"add cost \" +array[i + 1]+\" \" + array[r]);\n\t\t}\n\t\tint tmp = array[i + 1];\n\t\tarray[i + 1] = array[r];\n\t\tarray[r] = tmp;\n\t\treturn i + 1;\n\t}\n\t*/\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.Arrays;\n\nclass Main{\n\n    static final int MAX = 10000+1;\n    static int cost,n, s, x = MAX;\n    static int[] A, B, C = new int[MAX];\n    static boolean[] V = new boolean[1000];\n\n    static void sort(){\n        Arrays.sort(B, 0, n);\n        for(int i = 0; i < n; i++)\n            C[B[i]] = i;\n\n        for(int i = 0; i < n; i++) {\n            if(V[i]) continue;\n            int j = i, s = 0, min = MAX, k = 0;\n            while(!V[j]) {\n                k++;\n                min = Math.min(min,A[j]);\n                s += A[j];\n                V[j] = true;\n                j = C[A[j]];\n            }\n            cost += Math.min(s + (k - 2) * min, min + s + (k + 1) * x);\n        }\n    }\n\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        n = sc.nextInt();\n\n        A = new int[n];\n        B = new int[n];\n\n\n\n        for (int i = 0; i < n; i++) {\n            int next = sc.nextInt();\n            A[i] = next;\n            B[i] = A[i];\n            V[i] = false;\n            x = Math.min(x,next);\n        }\n        sort();\n        System.out.println(cost);\n    }\n\n\n\n    static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() { return Integer.parseInt(next()); }\n        long nextLong() { return Long.parseLong(next()); }\n        double nextDouble() { return Double.parseDouble(next()); }\n\n        String nextLine(){\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t// TODO Auto-generated method stub\n\n\t\tBufferedReader br=new BufferedReader(new  InputStreamReader(System.in));\n\t\tint n=Integer.parseInt(br.readLine());\n\t\tint[] W=new int[n];\n\t\tString[] in=br.readLine().split(\"\\\\s+\");\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tW[i]=Integer.parseInt(in[i]);\n\t\t}\n\t\tSystem.out.println(minCost(W));\n\t}\n\n\tpublic  static int minCost(int[] W){\n\t\tint[] sort=W.clone();\n\t\tArrays.sort(sort);\n\t\tint cost=0;\n\t\tfor(int i=0;i<W.length;i++){\n\t\t\tint a=indexOf(W,sort[i]);\n\t\t\tint j=0;\n\t\t\twhile(a>i){\n\t\t\t\tj++;\n\t\t\t\tint b=indexOf(W, sort[a]);\n\t\t\t\tcost+=W[b];\n\t\t\t\t\n\t\t\t\tint work=W[a];\n\t\t\t\tW[a]=W[b];\n\t\t\t\tW[b]=work;\n\t\t\t\t\n\t\t\t\ta=b;\n\t\t\t}\n\t\t\tcost+=Math.min(sort[i]*j, sort[i]*2+sort[0]*(j+2));\n\t\t}\n\t\treturn cost;\n\t}\n\n\tprivate static int indexOf(int[] A, int x) {\n\t\t// TODO Auto-generated method stub\n\t\tfor(int i=0;i<A.length;i++){\n\t\t\tif(A[i]==x)\n\t\t\t\treturn i;\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tContestScanner scan = new ContestScanner();\n\n\t\tfinal int n = scan.nextInt();\n\t\tfinal int[] wi = scan.nextIntArray(n);\n\n\t\t(new Solve(n, wi)).solve();\n\t}\n}\nclass Solve {\n\tprivate final int n;\n\tprivate final int[] wi;\n\n\tpublic Solve(final int n, final int[] wi)\n\t{\n\t\tthis.n = n;\n\t\tthis.wi = wi;\n\t}\n\n\tpublic void solve()\n\t{\n\t\tint[] swi = new int[n];\n\t\tint[] map = new int[10001];\n\t\tboolean[] flags = new boolean[n];\n\n\t\tArrays.fill(map, 0);\n\t\tArrays.fill(flags, false);\n\n\t\tfor(int i=0; i < n; i++) swi[i] = wi[i];\n\t\tsort(swi);\n\t\tfor(int i=0; i < n; i++) map[swi[i]] = i;\n\n\t\tint answer = 0;\n\t\tint min = swi[0];\n\n\t\tfor(int i=0; i < n; i++)\n\t\t{\n\t\t\tif(flags[i]) continue;\n\n\t\t\tint sum = 0;\n\t\t\tint v = 0;\n\t\t\tint an = 0;\n\t\t\tint cmin = Integer.MAX_VALUE;\n\t\t\tint cur = i;\n\n\t\t\tdo {\n\t\t\t\tflags[cur] = true;\n\t\t\t\tan++;\n\t\t\t\tv = wi[cur];\n\t\t\t\tsum += v;\n\t\t\t\tcmin = Math.min(cmin, v);\n\t\t\t\tcur = map[v];\n\t\t\t} while(!flags[cur]);\n\n\t\t\tif(an > 1)\n\t\t\t{\n\t\t\t\tanswer += Math.min(sum + (an - 2) * cmin, sum + cmin + (an + 1) * min);\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(answer);\n\t}\n\n\tpublic void sort(int[] wi)\n\t{\n\t\tquickSort(wi, 0, wi.length - 1);\n\t}\n\n\tpublic void quickSort(int[] wi, final int p, final int r)\n\t{\n\t\tif(p < r)\n\t\t{\n\t\t\tint q = partition(wi, p, r);\n\n\t\t\tquickSort(wi, p, q - 1);\n\t\t\tquickSort(wi, q + 1, r);\n\t\t}\n\t}\n\n\tpublic int partition(int[] wi, int p, final int r)\n\t{\n\t\tint x = wi[r];\n\t\tint i = p - 1;\n\n\t\tfor(int j=p; j < r; j++)\n\t\t{\n\t\t\tif(wi[j] <= x)\n\t\t\t{\n\t\t\t\t++i;\n\t\t\t\tint tmp = wi[j];\n\t\t\t\twi[j] = wi[i];\n\t\t\t\twi[i] = tmp;\n\t\t\t}\n\t\t}\n\t\tint tmp = wi[r];\n\t\twi[r] = wi[i + 1];\n\t\twi[i + 1] = tmp;\n\n\t\treturn i + 1;\n\t}\n}\nclass ContestScanner {\n\tBufferedReader reader;\n\tString[] line;\n\tint index;\n\tpublic ContestScanner() {\n\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\tpublic ContestScanner(String filename) throws FileNotFoundException {\n\t\treader = new BufferedReader(new InputStreamReader(new FileInputStream(filename)));\n\t}\n\n\tpublic static interface ICreator<T> {\n\t\tpublic T createFromToken(final ContestScanner scanner) throws IOException;\n\t}\n\n\tpublic static interface IArrayInitializer {\n\t\tpublic void initialize(final ContestScanner scanner, final int i) throws IOException;\n\t}\n\n\tpublic static interface IObjectInitializer<T> {\n\t\tpublic T initialValue(final ContestScanner scanner);\n\t}\n\n\tpublic static class ObjectArrayInitializer<T> implements IArrayInitializer {\n\t\tprotected T[] arr;\n\t\tprotected final IObjectInitializer<T> initializer;\n\n\t\tprivate ObjectArrayInitializer(T[] arr, final IObjectInitializer<T> initializer)\n\t\t{\n\t\t\tthis.arr = arr;\n\t\t\tthis.initializer = initializer;\n\t\t}\n\n\t\tpublic static <T> ObjectArrayInitializer<T> create(T[] arr, final IObjectInitializer<T> initializer)\n\t\t{\n\t\t\treturn new ObjectArrayInitializer<T>(arr, initializer);\n\t\t}\n\n\t\tpublic void initialize(final ContestScanner scanner, final int i) throws IOException {\n\t\t\tthis.arr[i] = initializer.initialValue(scanner);\n\t\t}\n\n\t\tpublic T[] getArray()\n\t\t{\n\t\t\treturn this.arr;\n\t\t}\n\t}\n\n\n\tpublic static class ByteArrayInitializer implements IArrayInitializer {\n\t\tprotected byte[] arr;\n\n\t\tprivate ByteArrayInitializer(final int n)\n\t\t{\n\t\t\tthis.arr = new byte[n];\n\t\t}\n\n\t\tpublic void initialize(final ContestScanner scanner, final int i) throws IOException {\n\t\t\tthis.arr[i] = scanner.nextByte();\n\t\t}\n\n\t\tpublic byte[] getArray()\n\t\t{\n\t\t\treturn this.arr;\n\t\t}\n\t}\n\n\tpublic static class ShortArrayInitializer implements IArrayInitializer {\n\t\tprotected short[] arr;\n\n\t\tprivate ShortArrayInitializer(final int n)\n\t\t{\n\t\t\tthis.arr = new short[n];\n\t\t}\n\n\t\tpublic void initialize(final ContestScanner scanner, final int i) throws IOException {\n\t\t\tthis.arr[i] = scanner.nextShort();\n\t\t}\n\n\t\tpublic short[] getArray()\n\t\t{\n\t\t\treturn this.arr;\n\t\t}\n\t}\n\n\tpublic static class IntArrayInitializer implements IArrayInitializer {\n\t\tprotected int[] arr;\n\n\t\tprivate IntArrayInitializer(final int n)\n\t\t{\n\t\t\tthis.arr = new int[n];\n\t\t}\n\n\t\tpublic void initialize(final ContestScanner scanner, final int i) throws IOException {\n\t\t\tthis.arr[i] = scanner.nextInt();\n\t\t}\n\n\t\tpublic int[] getArray()\n\t\t{\n\t\t\treturn this.arr;\n\t\t}\n\t}\n\n\tpublic static class LongArrayInitializer implements IArrayInitializer {\n\t\tprotected long[] arr;\n\n\t\tprivate LongArrayInitializer(final int n)\n\t\t{\n\t\t\tthis.arr = new long[n];\n\t\t}\n\n\t\tpublic void initialize(final ContestScanner scanner, final int i) throws IOException {\n\t\t\tthis.arr[i] = scanner.nextLong();\n\t\t}\n\n\t\tpublic long[] getArray()\n\t\t{\n\t\t\treturn this.arr;\n\t\t}\n\t}\n\n\tpublic static class FloatArrayInitializer implements IArrayInitializer {\n\t\tprotected float[] arr;\n\n\t\tprivate FloatArrayInitializer(final int n)\n\t\t{\n\t\t\tthis.arr = new float[n];\n\t\t}\n\n\t\tpublic void initialize(final ContestScanner scanner, final int i) throws IOException {\n\t\t\tthis.arr[i] = scanner.nextFloat();\n\t\t}\n\n\t\tpublic float[] getArray()\n\t\t{\n\t\t\treturn this.arr;\n\t\t}\n\t}\n\n\tpublic static class DoubleArrayInitializer implements IArrayInitializer {\n\t\tprotected double[] arr;\n\n\t\tprivate DoubleArrayInitializer(final int n)\n\t\t{\n\t\t\tthis.arr = new double[n];\n\t\t}\n\n\t\tpublic void initialize(final ContestScanner scanner, final int i) throws IOException {\n\t\t\tthis.arr[i] = scanner.nextDouble();\n\t\t}\n\n\t\tpublic double[] getArray()\n\t\t{\n\t\t\treturn this.arr;\n\t\t}\n\t}\n\n\tpublic String nextToken() throws IOException {\n\t\tif(line == null || index >= line.length)\n\t\t{\n\t\t\tline = reader.readLine().trim().split(\" \");\n\t\t\tindex = 0;\n\t\t}\n\n\t\treturn line[index++];\n\t}\n\n\tpublic String next() throws IOException {\n\t\treturn nextToken();\n\t}\n\n\tpublic String readLine() throws IOException {\n\t\tline = null;\n\t\tindex = 0;\n\n\t\treturn reader.readLine();\n\t}\n\n\tpublic byte nextByte() throws IOException, NumberFormatException {\n\t\treturn Byte.parseByte(nextToken());\n\t}\n\n\tpublic short nextShort() throws IOException, NumberFormatException {\n\t\treturn Short.parseShort(nextToken());\n\t}\n\n\tpublic int nextInt() throws IOException, NumberFormatException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tpublic long nextLong() throws IOException, NumberFormatException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tpublic float nextFloat() throws IOException, NumberFormatException {\n\t\treturn Float.parseFloat(nextToken());\n\t}\n\n\tpublic double nextDouble() throws IOException, NumberFormatException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tpublic <T> T nextObject(final ICreator<T> creator) throws IOException, NumberFormatException {\n\t\treturn creator.createFromToken(this);\n\t}\n\n\tpublic int[] nextIntArray(final int N) throws IOException, NumberFormatException {\n\t\tint[] result = new int[N];\n\n\t\tfor(int i=0; i < N; i++) result[i] = nextInt();\n\n\t\treturn result;\n\t}\n\n\tpublic long[] nextLongArray(final int N) throws IOException, NumberFormatException {\n\t\tlong[] result = new long[N];\n\n\t\tfor(int i=0; i < N; i++) result[i] = nextLong();\n\n\t\treturn result;\n\t}\n\n\tpublic float[] nexFloatArray(final int N) throws IOException, NumberFormatException {\n\t\tfloat[] result = new float[N];\n\n\t\tfor(int i=0; i < N; i++) result[i] = nextFloat();\n\n\t\treturn result;\n\t}\n\n\tpublic double[] nexDoubleArray(final int N) throws IOException, NumberFormatException {\n\t\tdouble[] result = new double[N];\n\n\t\tfor(int i=0; i < N; i++) result[i] = nextDouble();\n\n\t\treturn result;\n\t}\n\n\tpublic <T> T[] nextObjectArray(T[] result, final ICreator<T> creator) throws IOException, NumberFormatException {\n\t\tfor(int i=0, N=result.length; i < N; i++) result[i] = nextObject(creator);\n\n\t\treturn result;\n\t}\n\n\tpublic <T> ArrayList<T> nextGenericObjectArrayList(final int N, final ICreator<T> creator) throws IOException, NumberFormatException {\n\t\tArrayList<T> result = new ArrayList<T>();\n\t\tfor(int i=0; i < N; i++) result.add(nextObject(creator));\n\n\t\treturn result;\n\t}\n\n\tpublic void nextTable(final int N, IArrayInitializer... arrayInitializers) throws IOException, NumberFormatException {\n\t\tfor(int i=0; i < N; i++) for(IArrayInitializer initializer: arrayInitializers)\n\t\t{\n\t\t\tinitializer.initialize(this, i);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tBufferedReader br =\n\t\t\t\tnew BufferedReader( new InputStreamReader(System.in) );\n\t\tint n = Integer.parseInt( br.readLine() );\n\n\t\tString[] str = br.readLine().split(\" \");\n\t\tBag[] preW = new Bag[n]; // ??´????????????????????? w_i ?????\\????????????\n\t\tBag[] postW = new Bag[n]; // ??´??????????????????????????\\????????????\n\t\tfor (int i=0; i < n; i++) {\n\t\t\tpreW[i] = new Bag( Integer.parseInt(str[i]), i );\n\t\t\tpostW[i] = preW[i];\n\t\t}\n\n\t\tArrays.sort(postW);\n\t\tfor (int i=0; i < n; i++) {\n\t\t\tpostW[i].posti = i;\n\t\t}\n\n\t\t/*\n\t\t * 5, 4, 1, 3, 2, : W  pre\n\t\t *\n\t\t *                  W[0] = 5\n\t\t *  , 4, 1, 3, 2, : bag = 5, nextbag = 2,\n\t\t *             5,\n\t\t *\n\t\t *  , 4, 1, 3, 5, : bag = 2, nextbag = 4,\n\t\t *    2,\n\t\t *\n\t\t *  , 2, 1, 3, 5, : bag = 4, nextbag = 3,\n\t\t *          4,\n\t\t *\n\t\t *  , 2, 1, 4, 5, : bag = 3, nextbag = 1,\n\t\t *       3,\n\t\t *\n\t\t *  , 2, 3, 4, 5, : bag = 1, nextbag = 5,\n\t\t * 1,\n\t\t *                  bag = 5,\n\t\t *                  bag.prei = 0\n\t\t *\n\t\t * 1, 2, 3, 4, 5, : orderedW  post\n\t\t */\n\n\t\tBag bag, nextbag;\n\t\tint count;\n\t\tint ans = 0;\n\t\tint least = postW[0].wei;\n\t\tfor (int i=0; i < n; i++) {\n\t\t\tbag = postW[i];\n\t\t\tif (bag.label == true) continue;\n\t\t\tif (bag.prei == bag.posti) continue;\n\n\t\t\tbag.label = true;\n\t\t\tcount = 0;\n\t\t\tint mini = bag.wei;\n\t\t\twhile (true) {\n\t\t\t\tnextbag = preW[bag.posti]; // nextbag.prei == bag.posti\n\t\t\t\tif (nextbag == postW[i]) break; // postW[i] ??????????????¨??????nextbag????????£??????????????????postW[i]????????£????????????\n\t\t\t\tnextbag.label = true;\n\t\t\t\tcount++;\n\t\t\t\tans += nextbag.wei;\n\t\t\t\tbag = nextbag;\n\t\t\t}\n\t\t\tint nochange = mini * count;\n\t\t\tint change = (least+mini)*2 + least*count;\n\t\t\tans += Math.min(change, nochange);\n\t\t}\n\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic class Bag implements Comparable<Bag> {\n\t\tint wei; // weight\n\n\t\tint prei; // pre index ??´?????????????????????????????????\n\n\t\tint posti; // post index ??´??????????????¨?????????????????????\n\n\t\tboolean label = false;\n\n\t\tBag(int w, int i) {\n\t\t\tthis.wei= w;\n\t\t\tthis.prei = i;\n\t\t}\n\n//\t\tBag next(Bag[] preW, Bag[] postW) {\n//\t\t\tint index = this.posti;\n//\t\t\treturn preW[index];\n//\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Bag b) {\n\t\t\treturn this.wei - b.wei;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"\" + wei;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Arrays;\n\nclass Main {\n\tprivate static\tint num;\n\tprivate static\tint[]  array;\n\t\n\tpublic static void main(String args[]) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tnum = scanner.nextInt();//要素数\n\t\tarray = new int[num];\n\t\t//配列作成\n\t\tfor(int i = 0; i < num; i ++ ){\n\t\t\tarray[i] = scanner.nextInt();\n\t\t}\n\t\t//計算結果を出力\n\t\tSystem.out.println( cost() );\n\t\t\n\t\tscanner.close();\n\t}\n\t//最小コスト\n\tpublic static int cost(){ \n\t\tint sorted[] = array.clone();\t\t//クローンを作って\n        Arrays.sort(sorted);\t\t\t//昇順にしておいて比べる\n\t\tint mincost = 0;\n\t\tint sub;\n\t\tint comp = 0;\n\n\t\tfor(int i = 0; i < num; i ++ ){\n\t\t\tcomp = indexOf(sorted[i]);\t\t//比較結果\n            int count = 0;\n\t\t\t//比較結果によって中へ\n            while (comp > i) {\n                count ++;\t\t\t\t\t\t\t\t//whileの中に入った数\n                sub = indexOf(sorted[comp]);\t//比較結果\n                mincost += array[sub];\n                int work = array[comp];\n                array[comp] = array[sub];\n                array[sub] = work;\n                comp = sub;\t\t\t\t\t\t\t\t//比較対象をずらしていく\n            }\n\t\t\t//値の小さいほうをコストに\n            mincost += Math.min(sorted[i] * count,\n            \t\tsorted[i] * 2 + sorted[0] * (count + 2));\n        }\n\t\treturn mincost;\n\t}\n\t\n\tpublic static int indexOf(int comp) {\n        //一致した場所を返し、一致しなかったら-1\n\t\tfor (int i = 0; i < num; i++) {\n            if (array[i] == comp) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\n\t\tint n = scanner.nextInt();\n\t\tint[] S = new int[n];\n\t\tint[] A = new int[n];\n\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tS[i] = i;\n\t\t\tA[i] = scanner.nextInt();\n\t\t}\n\n\t\tscanner.close();\n\n\t\tquickSort(S, A, 0, n - 1);\n\t\t\n\t\tboolean[] did = new boolean[n];\n\t\tint cost = 0;\n\t\t\n\t\tfor (int i = 0; i < n; i ++) {\n\t\t\tif (did[i]) continue;\n\t\t\tdid[i] = true;\n\t\t\tif (S[i] == i) continue;\n\t\t\t\n\t\t\tint x = 0;\n\t\t\tint y = (A[i] + A[0]) * 2;\n\t\t\tfor (int j = S[i]; S[j] != S[i]; j = S[j]) {\n\t\t\t\tdid[j] = true;\n\t\t\t\tx += A[j] + A[i];\n\t\t\t\ty += A[j] + A[0];\n\t\t\t}\n\t\t\tcost += Math.min(x, y);\n\t\t}\n\t\tSystem.out.println(cost);\n\t}\n\n\tpublic static int partition (int[] S, int[] A, int p, int r) {\n\t\tint x = A[r];\n\t\tint i = p - 1;\n\n\t\tfor (int j = p; j < r; j++) {\n\t\t\tif (A[j] <= x) {\n\t\t\t\ti ++;\n\t\t\t\tint tempc = S[i];\n\t\t\t\tS[i] = S[j];\n\t\t\t\tS[j] = tempc;\n\t\t\t\tint temp = A[i];\n\t\t\t\tA[i] = A[j];\n\t\t\t\tA[j] = temp;\n\t\t\t}\n\t\t}\n\n\t\tint tempc = S[++ i];\n\t\tint temp = A[i];\n\t\tS[i] = S[r];\n\t\tA[i] = A[r];\n\t\tS[r] = tempc;\n\t\tA[r] = temp;\n\n\t\treturn i;\n\t}\n\n\tpublic static void quickSort(int[] S, int[] A, int p, int r) {\n\t\tif (p < r) {\n\t\t\tint q = partition(S, A, p, r);\n\t\t\tquickSort(S, A, p, q - 1);\n\t\t\tquickSort(S, A, q + 1, r);\n\t\t}\n\t}\n} \n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] w = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tw[i] = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(doSort(w));\n\t}\n\t\n\tpublic static int getIndex(int[] l, int x){\n\t\tfor (int i = 0; i < l.length; i++) {\n\t\t\tif(l[i]==x) return i;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tpublic static int doSort(int[] w){\n\t\tint[] sortedList = w.clone();\n\t\tArrays.sort(sortedList);\n\t\t\n\t\tint cost = 0;\n\t\t\n\t\tfor (int i = 0; i < w.length; i++) {\n\t\t\tint x = getIndex(w, sortedList[i]);\n\t\t\tint y = 0;\n\t\t\twhile (x>i) {\n\t\t\t\ty++;\n\t\t\t\tint k = getIndex(w, sortedList[x]);\n\t\t\t\tcost = cost + w[k];\n\t\t\t\tint comp = w[x];\n\t\t\t\tw[x] = w[k];\n\t\t\t\tw[k] = comp;\n\t\t\t\tx = k;\n\t\t\t}\n\t\t\tcost = cost + Math.min(sortedList[i]*y, sortedList[i]*2+sortedList[0]*(y+2));\n\t\t\n\t\t}\n\t\treturn cost;\n\t}\n\t\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic int cost = 0;\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tint n = 0;\n\t\t//int costA = 0;\n\t\t//int costB = 0;\n\t\tint tmp = br.read();\n\t\twhile(tmp != 13 && tmp != 10){\n\t\t\tn = n * 10 + (tmp - '0');\n\t\t\ttmp = br.read();\n\t\t}\n\n\t\tint[] array = new int[n];\n\t\tint[] sortedArray = new int[n];\n\t\tint num = 0;\n\t\tint i1 = 0;\n\t\tint min = Integer.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\ttmp = br.read();\n\t\tif(tmp == 13 || tmp == 10){\n\t\t\ttmp = br.read();\n\t\t}\n\t\twhile(tmp != -1 && tmp != 10 && tmp != 13){\n\t\t\tnum = 0;\n\t\t\twhile(tmp >= '0' && tmp <= '9'){\n\t\t\t\tnum = num * 10 + (tmp - '0');\n\t\t\t\ttmp = br.read();\n\t\t\t}\n\t\t\tif(tmp == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tarray[i1] = num;\n\t\t\tsortedArray[i1] = num;\n\t\t\tif(min > num){\n\t\t\t\tmin = num;\n\t\t\t\tminIndex = i1;\n\t\t\t}\n\t\t\ti1++;\n\t\t\ttmp = br.read();\n\t\t}\n\n\t\tArrays.sort(sortedArray);\n\t\tint[] trueIndex = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ttrueIndex[i] = Arrays.binarySearch(sortedArray, array[i]);\n\t\t}\n\n\t\t//??????????????¢???\n\t\tboolean[] checked = new boolean[n];\n\t\tArrays.fill(checked, false);\n\n\t\tfor(int i = 0; i < n ; i++){\n\t\t\tif(i == trueIndex[i] || checked[i] == true){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tArrayList<Integer> cycle = new ArrayList<Integer>();\n\t\t\tcycle.add(array[i]);\n\t\t\tint j = trueIndex[i];\n\t\t\twhile(j != i){\n\t\t\t\tchecked[j] = true;\n\t\t\t\tcycle.add(array[j]);\n\t\t\t\tj = trueIndex[j];\n\t\t\t}\n\n\t\t\t//????????????????°?????????§??????????????????????????????????¨??¨????\n\t\t\tint minInCycle = cycle.get(0);\n\t\t\tint costA = 0;\n\t\t\tint costB = 0;\n\t\t\tfor(int k = 0; k < cycle.size(); k++){\n\t\t\t\tif(minInCycle > cycle.get(k)){\n\t\t\t\t\tminInCycle = cycle.get(k);\n\t\t\t\t}\n\t\t\t\tcostA+=cycle.get(k);\n\t\t\t\tcostB+=cycle.get(k);\n\t\t\t}\n\t\t\tcostA += minInCycle*(cycle.size() - 2);\n\t\t\tcostB += minInCycle + min*(cycle.size() + 1);\n\n\t\t\tcost += Math.min(costA, costB);\n\n\t\t}\n\n\n\t\t//quickSort(array, 0, array.length - 1);\n\n\t\tSystem.out.println(cost);\n\t\t/*\n\t\tStringBuilder sb = new StringBuilder(array.length * 5 / 2);\n\t\tint outLen = array.length;\n\t\tsb.append(array[0]);\n\t\tfor(int i = 1; i < outLen ; i++){\n\t\t\tsb.append(\" \"+array[i]);\n\n\t\t}\n\t\tSystem.out.println(sb);\n\t\t*/\n\t}\n\t/*\n\tstatic void quickSort(int[] array, int p, int r){\n\t\tif(p < r){\n\t\t\tint q = partition(array, p, r);\n\t\t\tquickSort(array, p, q - 1);\n\t\t\tquickSort(array, q + 1, r);\n\t\t}\n\t}*/\n\t/*\n\tstatic int partition(int[] array, int p, int r){\n\t\tint x = array[r];\n\t\tint i = p - 1;\n\t\tfor(int j = p ; j <= r -1 ;j++){\n\t\t\tif(array[j] <= x){\n\t\t\t\ti++;\n\t\t\t\tint tmp = array[i];\n\t\t\t\tarray[i] = array[j];\n\t\t\t\tarray[j] = tmp;\n\n\t\t\t}\n\t\t}\n\n\t\tif(true || array[i + 1] != array[r]){\n\t\t\tcost += array[i + 1] + array[r];\n\t\t\tSystem.out.println(\"add cost \" +array[i + 1]+\" \" + array[r]);\n\t\t}\n\t\tint tmp = array[i + 1];\n\t\tarray[i + 1] = array[r];\n\t\tarray[r] = tmp;\n\t\treturn i + 1;\n\t}\n\t*/\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main2 {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\t// ??°?????????????????¨?????????????????????????????????????????????????´????????????????????????????????????????\n\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\tint n = scanner.nextInt();\n\t\tint count = 0;\n\t\tint[] list = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlist[i] = scanner.nextInt();\n\t\t}\n\t\tint[] sortedList = (int[]) list.clone();\n\t\t// ???????????????????´???°???????????????????????????????????????????????????????????????????????????\n\t\tmergeSort(sortedList, 0, n);\n\t\t// ??????????????????????????¨?????????????´????????´??????????????????????\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmap.put(sortedList[i], i);\n\t\t}\n\t\tboolean flag = true;\n\t\tint time = 1;\n\t\t// ????????¨\n\t\tdo{\n\t\t\tint temp3 = -1;\n\t\t\tint index2 = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i != map.get(list[i]) && temp3 < list[i]) {\n\t\t\t\t\t//??????????????§?????£??°???????´???????????????????????´????????????????\n\t\t\t\t\ttemp3 = map.get(list[i]);\n\t\t\t\t\tindex2 = i;\n\t\t\t\t}\n\t\t\t}\n\t\tint temp = list[index2];\n\t\tint ind = map.get(list[index2]);\n\t\tint temp2 = list[ind];\n\t\tlist[index2] = temp2;\n\t\tlist[ind] = temp;\n\t\tcount = count + temp + temp2;\n\t\t//System.out.println(temp + \"??¨\" + temp2 +\"?????????\" + time+ \"??????\");\n\t\t//time++;\n\t\tflag = true;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(i != map.get(list[i])){\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\t\t}while(flag != true);\n\t\tSystem.out.println(count);\n\t}\n\t\n\tstatic void merge(int[] numList, int left, int mid, int right) {\n\t\tint n1 = mid - left;\n\t\tint n2 = right - mid;\n\t\tint[] L = new int[n1 + 1];\n\t\tint[] R = new int[n2 + 1];\n\n\t\tfor (int i = 0; i < n1; i++) {\n\t\t\tL[i] = numList[left + i];\n\t\t}\n\n\t\tfor (int i = 0; i < n2; i++) {\n\t\t\tR[i] = numList[mid + i];\n\t\t}\n\n\t\tL[n1] = Integer.MAX_VALUE;\n\t\tR[n2] = Integer.MAX_VALUE;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\t// L??¨R??????????????????????°????????????????numList???????´??????????\n\t\t// ?°?????????????????????????????????????????¬??????????????????????????????????????´????????????????????????°?????????+1?????????\n\t\tfor (int k = left; k < right; k++) {\n\t\t\tif (L[i] <= R[j]) {\n\t\t\t\tnumList[k] = L[i];\n\t\t\t\ti = i + 1;\n\t\t\t} else {\n\t\t\t\tnumList[k] = R[j];\n\t\t\t\tj = j + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// ????¨????merge???????????????????±??????????????°?????´???????(left)??¨?????§????´???????(right)?????????-1??????????????§??°????????????\n\tstatic void mergeSort(int[] numList, int left, int right) {\n\t\tif ((left + 1) < right) {\n\t\t\tint mid = (left + right) / 2;\n\n\t\t\tmergeSort(numList, left, mid);\n\t\t\t// System.out.println(\"???\");\n\t\t\tmergeSort(numList, mid, right);\n\t\t\t// System.out.println(\"???\");\n\t\t\tmerge(numList, left, mid, right);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\n\tpublic static void main(String[] args){\n\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint[] W = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tW[i] = scan.nextInt();\n\t\t}\n\n\t\tSystem.out.printf(\"%d\\n\", minCostSort(W));\n\t}\n\n\tprivate static int indexOf(int[] A, int x){\n\t\tfor(int i = 0; i < A.length; i++){\n\t\t\tif(A[i] == x){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tprivate static int minCostSort(int[] W){\n\t\tint[] sorted = W.clone();\n\t\tArrays.sort(sorted);\n\t\tint cost = 0;\n\t\tfor(int i = 0; i < W.length; i++){\n\t\t\tint a = indexOf(W, sorted[i]); // ??\\??????????????????\n\t\t\tint change = 0;\n\t\t\twhile(i < a){ // ????????????????????????????????\\???????????????????????§?????????\n\t\t\t\tint b = indexOf(W, sorted[a]); // ?????????????????????????????\\??????????????????????????????????????\\?????????\n\t\t\t\tcost += W[b]; // ??????????????????????¶????\n\t\t\t\tint work = W[a]; // ???????????¨??´??\\????????????\n\t\t\t\tW[a] = W[b];\n\t\t\t\tW[b] = work;\n\t\t\t\tchange++;\n\t\t\t\ta = b;\n\t\t\t}\n\t\t\tcost += Math.min(sorted[i] * change,// ?§??????????????????¨???????????°\n\t\t\t\t\t\t\t\t sorted[0] * change + (sorted[i] * 2 + sorted[0] * 2)); // ????????????????????¨?§???????????????????????????????\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ????????????????????¨?§??????????????????????\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ????????????????????¨?§??????????????????????\n\t\t}\n\t\treturn cost;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\ta[i] = sc.nextInt();\n    \t}\n\t\tSystem.out.println(minsort(a));\n\t\t\n\t}\n\tpublic static int myindex(int[] a,int b){\n\t\tfor (int i=0;i<a.length;i++){\n\t\t\tif (a[i]==b) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tpublic static int minsort(int[] a){\n\t\tint [] sorted=a.clone();\n\t\tArrays.sort(sorted);\n\t\tint n=a.length;\n\t\tint cost=0;\n\t\tfor (int i=0;i<n;i++){\n\t\t\tint cnt=0;\n\t\t\tint c1= myindex(a,sorted[i]);\n\t\t\twhile (c1!=i){\n\t\t\t\tcnt++;\n\t\t\t\tint c2= myindex(a,sorted[c1]);\n\t\t\t\tcost+=a[c2];\n\t\t\t\tint work=a[c2];\n\t\t\t\ta[c2]=a[c1];\n\t\t\t\ta[c1]=work;\n\t\t\t\tc1=c2;\n\t\t\t}\n\t\t\tcost+=Math.min(sorted[i]*cnt, sorted[i]*2+sorted[0]*(cnt+2));\n\t\t}\n\t\treturn cost;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\n class FS {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readByte() {\n        return hasNextByte() ? buffer[ptr++] : -1;\n    }\n\n    private boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n        skipUnprintable();\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public int nextInt() {\n        return (int) nextLong();\n    }\n\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        FS fs = new FS();\n        int n = fs.nextInt();\n        Stuff a[] = new Stuff[n];\n        boolean b[]  =new boolean[n];\n        for (int i = 0; i < n; i++) {\n            int wei = fs.nextInt();\n            a[i]=new Stuff(i,wei);\n        }\n        Arrays.sort(a);\n        int min=a[0].weight;\n        int wcount=0;\n        for (int i = 0; i < a.length; i++) {\n            if (min>a[i].weight)min=a[i].weight;\n            if (b[i])continue;\n            if (a[i].index==i)continue;\n            int minw=a[i].weight;\n            int k=0;\n            for (int j = a[i].index; !b[j]; j=a[j].index,k++){\n                if (min>a[j].weight)min=a[j].weight;\n                if (minw>a[j].weight)min=a[j].weight;\n                b[j]=true;\n                wcount+=a[j].weight;\n            }\n            wcount+=Math.min((k-2)*minw,minw+(k+1)*min);\n        }\n        System.out.println(wcount);\n    }\n\n   static class Stuff implements Comparable<Stuff> {\n        int index;\n        int weight;\n\n        public Stuff(int index, int weight) {\n            this.index = index;\n            this.weight = weight;\n        }\n\n\n\n       @Override\n       public int compareTo(Stuff o) {\n            if (o.weight>this.weight)return -1;\n            else return 1;\n       }\n   }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.IOException;\n\n// ALDS1_6_D\npublic class Main {\n\tint SENTINEL = 1234567890;\n\tvoid merge(int[]A, int left, int mid, int right) {\n\t\tint n1 = mid - left + 1;\n\t\tint n2 = right - mid;\n\t\tint[] L = new int[n1 + 1];\n\t\tint[] R = new int[n2 + 1];\n\t\tfor (int i = 0; i < n1; i++) {\n\t\t\tL[i] = A[left + i];\n\t\t}\n\t\tfor (int i = 0; i < n2; i++) {\n\t\t\tR[i] = A[mid + 1 + i];\n\t\t}\n\t\tL[n1] = SENTINEL;\n\t\tR[n2] = SENTINEL;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tfor (int k = left; k <= right; k++) {\n\t\t\tif (L[i] <= R[j]) {\n\t\t\t\tA[k] = L[i];\n\t\t\t\ti = i + 1;\n\t\t\t} else {\n\t\t\t\tA[k] = R[j];\n\t\t\t\tj = j + 1;\n\t\t\t}\n\t    }\n\t}\n\n\tvoid mergeSort(int[] A, int left, int right) {\n\t    \tif (left < right) {\n\t    \t\tint mid = (left + right)/2;\n\t    \t\tmergeSort(A, left, mid);\n\t    \t\tmergeSort(A, mid + 1, right);\n\t    \t\tmerge(A, left, mid, right);\n\t  \t}\n\t}\n\tint cost = 0;\n\tvoid run() throws IOException {\n\t\tArrayList<Integer> lis = new ArrayList<Integer>();\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] A = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlis.add(i);\n\t\t\tA[i] = sc.nextInt();\n\t\t}\n\t\tint[] B = A.clone();\n\t\tmergeSort(B, 0, n-1);\n\t\twhile (true) {\n\t\t\t// A[i] == B[i] 値の位置が正しい場合を除外\n\t\t\tArrayList<Integer> liscopy = new ArrayList<Integer>(lis);\n\t\t\tfor (Integer v : lis) {\n\t\t\t\tif (A[v] == B[v]) liscopy.remove(v);\n\t\t\t}\n\t\t\tlis = new ArrayList<Integer>(liscopy);\n\t\t\t// 基底条件\n\t\t\tif (lis.isEmpty()) break;\n\t\t\t// 交換する組を決める\n\t\t\tint minpoint = lis.get(0);\n\t\t\tfor (Integer v : lis) \n\t\t\t\tif (A[minpoint] > A[v]) minpoint = v;\n\t\t\t// 交換先の値をtmpnum\n\t\t\tint tmppoint = -1;\n\t\t\tfor (Integer v : lis) {\n\t\t\t\tif (minpoint == v) continue;\n\t\t\t\tif (B[minpoint] == A[v]) tmppoint = v;\n\t\t\t}\n\t\t\tif (tmppoint == -1) System.out.println(\"not tmpnum\");\n\t\t\t// 相互\n\t\t\tfor (Integer v : lis) {\n\t\t\t\tif (minpoint == v) continue;\n\t\t\t\tif (B[minpoint] != B[v]) continue;\n\t\t\t\tif (A[v] == B[tmppoint]) minpoint = v;\n\t\t\t}\n\t\t\tcost += A[tmppoint] + A[minpoint];\n\t\t\tint tmp = A[tmppoint];\n\t\t\tA[tmppoint] = A[minpoint];\n\t\t\tA[minpoint] = tmp;\n\t\t}\n\t\tSystem.out.println(cost);\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new\n\t\t// File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\ALDS1_6_A-in9.txt\"));\n\n\t\tint n = scan.nextInt();\n\t\tint[] w = new int[n];\n\t\tint[] sq = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsq[i] = i;\n\t\t\tw[i] = scan.nextInt();\n\t\t}\n\n\t\tQuickSsort(w, sq, 0, n - 1);\n\n\t\tSystem.out.println(CostOf(w, sq));\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n\n\tprivate static int CostOf(int[] w, int[] sq) {\n\t\tint cost = PartCost(w, sq, 0);\n\n\t\tint[] save = new int[sq.length];\n\t\tfor (int i = 1; i < sq.length; i++)\n\t\t\tif (sq[i] != i) {\n\t\t\t\tfor (int j = i; j < sq.length; j++)\n\t\t\t\t\tsave[j] = sq[j];\n\t\t\t\tint savew = w[i];\n\t\t\t\tw[i] = w[0];\n\t\t\t\tint pc1 = PartCost(w, sq, i) + (savew + w[0]) * 2;\n\t\t\t\tw[i] = savew;\n\t\t\t\tfor (int j = i; j < sq.length; j++)\n\t\t\t\t\tsq[j] = save[j];\n\t\t\t\tint pc2 = PartCost(w, sq, i);\n\t\t\t\tcost += Math.min(pc1, pc2);\n\t\t\t}\n\t\treturn cost;\n\t}\n\n\tprivate static int PartCost(int[] w, int[] sq, int fr) {\n\t\tint cost = 0;\n\t\twhile (sq[fr] != fr) {\n\t\t\tint swp = sq[fr];\n\t\t\tcost += (w[fr] + w[swp]);\n\t\t\tsq[fr] = sq[swp];\n\t\t\tsq[swp] = swp;\n\t\t}\n\t\treturn cost;\n\t}\n\n\tprivate static int xxCostOf(int[] w, int[] sq) {\n\t\tint cost = 0;\n\t\tfor (int i = 0; i < sq.length; i++)\n\t\t\twhile (sq[i] != i) {\n\t\t\t\tint swp = sq[i];\n\t\t\t\tcost += (w[i] + w[swp]);\n\t\t\t\tsq[i] = sq[swp];\n\t\t\t\tsq[swp] = swp;\n\t\t\t}\n\t\treturn cost;\n\t}\n\n\tprivate static void QuickSsort(int[] a, int[] sq, int st, int ed) {\n\t\tif (st >= ed)\n\t\t\treturn;\n\t\tint v = Q2sort(a, sq, st, ed);\n\t\tQuickSsort(a, sq, st, v - 1);\n\t\tQuickSsort(a, sq, v + 1, ed);\n\t}\n\n\tprivate static int Q2sort(int[] a, int[] sq, int st, int ed) {\n\t\tint x = a[ed];\n\t\tint i = st - 1;\n\t\tfor (int j = st; j < ed; j++)\n\t\t\tif (a[j] <= x) {\n\t\t\t\ti++;\n\t\t\t\tint tmp = a[j];\n\t\t\t\ta[j] = a[i];\n\t\t\t\ta[i] = tmp;\n\t\t\t\ttmp = sq[j];\n\t\t\t\tsq[j] = sq[i];\n\t\t\t\tsq[i] = tmp;\n\t\t\t}\n\t\tint tmp = a[i + 1];\n\t\ta[i + 1] = a[ed];\n\t\ta[ed] = tmp;\n\t\ttmp = sq[i + 1];\n\t\tsq[i + 1] = sq[ed];\n\t\tsq[ed] = tmp;\n\n\t\treturn i + 1;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static int swap(int[] array, int a, int b){\n\t\tint tmp = array[a];\n\t\tarray[a] = array[b];\n\t\tarray[b] = tmp;\n\t\t\n\t\treturn array[a] + array[b];\n\t}\n\t\n\tpublic static int do_swap(int[] array, int[] sorted, int min_pos, boolean act){\n\t\tfinal int min = array[min_pos];\n\t\tint loop = min_pos;\n\t\tint sum = 0;\n\t\t\n\t\tdo{\n\t\t\tfor(int i = 0; i < array.length; i++){\n\t\t\t\tif(array[i] == sorted[loop]){\n\t\t\t\t\tif(act){\n\t\t\t\t\t\tsum += swap(array, i, loop);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsum += array[i] + min;\n\t\t\t\t\t}\n\t\t\t\t\tloop = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}while(min != sorted[loop]);\n\t\t\n\t\treturn sum;\n\t}\n\t\n\tpublic static int swapping(int[] array, int[] sorted){\n\t\tfinal int absolute_min = sorted[0];\n\t\tint absolute_min_pos = -1;\n\t\tint min = Integer.MAX_VALUE, min_pos = -1;\n\t\t\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tif(array[i] == absolute_min){\n\t\t\t\tabsolute_min_pos = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tif(sorted[i] != array[i] && min > array[i]){\n\t\t\t\tmin = array[i];\n\t\t\t\tmin_pos = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(min_pos == -1){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tfinal int direct = do_swap(array, sorted, min_pos, false);\n\t\t\n\t\tswap(array, min_pos, absolute_min_pos);\n\t\tfinal int indirect = do_swap(array, sorted, min_pos, false) + min + absolute_min;\n\t\tswap(array, min_pos, absolute_min_pos);\n\n\t\tif(direct <= indirect){\n\t\t\treturn do_swap(array, sorted, min_pos, true);\n\t\t}else{\n\t\t\tswap(array, min_pos, absolute_min_pos);\n\t\t\treturn do_swap(array, sorted, min_pos, true);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tfinal int n = sc.nextInt();\n\t\tint[] array  = new int[n];\n\t\tint[] sorted = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tarray[i]  = sc.nextInt();\n\t\t\tsorted[i] = array[i];\n\t\t}\n\t\tArrays.sort(sorted);\n\t\t\n\t\tint answer = 0, ret = 0;\n\t\twhile((ret = swapping(array, sorted)) != 0){\n\t\t\tanswer += ret;\n\t\t}\n\t\t\n\t\tSystem.out.println(answer);\n\t}\n\n\tpublic static class Scanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tprivate static FastScanner sc = new FastScanner();\n\n\tpublic static void main(String[] args) {\n\t\t//??????https://www.ipsj.or.jp/07editj/promenade/4506.pdf\n\t\tint n = sc.nextInt();\n\t\t\n\t\tWeight[] w = new Weight[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tw[i] = new Weight(sc.nextInt());\n\t\t}\n\t\t\n\t\tint min_all = 0;\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tint min = w[i].num;\n\t\t\tint idx = i;\n\t\t\tfor(int j=0; j<n; j++) {\n\t\t\t\tif(i != j && w[i].num > w[j].num) {\n\t\t\t\t\tw[i].idx_sort++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\tSystem.out.println(w[i].num + \" \" + w[i].idx_sort);\n\t\t\tif(i == 0) {\n\t\t\t\tmin_all = w[idx].num;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tint cost = 0;\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tint min_cycle = Integer.MAX_VALUE;\n\t\t\tint sum_cycle = 0;\n\t\t\tint n_cycle = 0;\n\t\t\tint j = i;\n\t\t\t\n\t\t\tif(!w[j].flag) {\n\t\t\t\tif(w[j].idx_sort == j) {\n\t\t\t\t\tw[j].flag = true;\n\t\t\t\t} else {\n\t\t\t\t\twhile(w[j].flag == false) {\n\t\t\t\t\t\tsum_cycle += w[j].num;\n\t\t\t\t\t\tn_cycle++;\n\t\t\t\t\t\tif(w[j].num < min_cycle) {\n\t\t\t\t\t\t\tmin_cycle = w[j].num;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tw[j].flag = true;\n\t\t\t\t\t\tj = w[j].idx_sort;\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tint cost_1 = sum_cycle + (n_cycle - 2) * min_cycle;\n\t\t\t\t\tint cost_2 = sum_cycle + min_cycle + (n_cycle + 1) * min_all;\n\t\t\t\t\t\n\t\t\t\t\tcost += Math.min(cost_1, cost_2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(cost);\n\t}\n\t\n\tstatic class Weight {\n\t\tint num;\n\t\tboolean flag = false;\n\t\tint idx_sort = 0;\n\t\tWeight(int num) {\n\t\t\tthis.num = num;\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t    private final InputStream in = System.in;\n\t    private final byte[] buffer = new byte[1024];\n\t    private int ptr = 0;\n\t    private int buflen = 0;\n\t    private boolean hasNextByte() {\n\t        if (ptr < buflen) {\n\t            return true;\n\t        }else{\n\t            ptr = 0;\n\t            try {\n\t                buflen = in.read(buffer);\n\t            } catch (IOException e) {\n\t                e.printStackTrace();\n\t            }\n\t            if (buflen <= 0) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\t    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\t    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t    public String next() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        StringBuilder sb = new StringBuilder();\n\t        int b = readByte();\n\t        while(isPrintableChar(b)) {\n\t            sb.appendCodePoint(b);\n\t            b = readByte();\n\t        }\n\t        return sb.toString();\n\t    }\n\t    public long nextLong() {\n\t        return Long.parseLong(next());\n\t    }\n\t    public int nextInt(){\n\t    \treturn Integer.parseInt(next());\n\t    }\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\n\tpublic static void main(String[] args){\n\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint[] W = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tW[i] = scan.nextInt();\n\t\t}\n\n\t\tSystem.out.printf(\"%d\\n\", minCostSort(W));\n\t}\n\n\tprivate static int indexOf(int[] A, int x){\n\t\tfor(int i = 0; i < A.length; i++){\n\t\t\tif(A[i] == x){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tprivate static int minCostSort(int[] W){\n\t\tint[] sorted = W.clone();\n\t\tArrays.sort(sorted);\n\t\tint cost = 0;\n\t\tfor(int i = 0; i < W.length; i++){\n\t\t\tint a = indexOf(W, sorted[i]); // ??\\??????????????????\n\t\t\tint change = 0;\n\t\t\twhile(i < a){ // ????????????????????????????????\\???????????????????????§?????????\n\t\t\t\tint b = indexOf(W, sorted[a]); // ?????????????????????????????\\??????????????????????????????????????\\?????????\n\t\t\t\tcost += W[b]; // ??????????????????????¶????\n\t\t\t\tint work = W[a]; // ???????????¨??´??\\????????????\n\t\t\t\tW[a] = W[b];\n\t\t\t\tW[b] = work;\n\t\t\t\tchange++;\n\t\t\t\ta = b;\n\t\t\t}\n\t\t\tcost += Math.min(sorted[i] * change, // ?§????????????????????¶????\n\t\t\t\t\t\t\t\tsorted[i] * change + (sorted[i]  + sorted[0] * 3));\n\t\t\t\t\t\t\t\t// ?§??????????????????¨?????????????????????????????????\n\t\t}\n\t\treturn cost;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\t// ??°?????????????????¨?????????????????????????????????????????????????´????????????????????????????????????????\n\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\tint n = scanner.nextInt();\n\t\tint count = 0;\n\t\tint[] list = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlist[i] = scanner.nextInt();\n\t\t}\n\t\tint[] sortedList = (int[]) list.clone();\n\t\t// ???????????????????´???°???????????????????????????????????????????????????????????????????????????\n\t\tmergeSort(sortedList, 0, n);\n\t\t// ??????????????????????????¨?????????????´????????´??????????????????????\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmap.put(sortedList[i], i);\n\t\t}\n\t\tboolean flag = true;\n\t\tint time = 1;\n\t\t// ????????¨\n\t\tdo{\n\t\t\tint temp3 = -1;\n\t\t\tint index2 = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i != map.get(list[i]) && temp3 < list[i]) {\n\t\t\t\t\t//??????????????§?????£??°???????´???????????????????????´????????????????\n\t\t\t\t\ttemp3 = map.get(list[i]);\n\t\t\t\t\tindex2 = i;\n\t\t\t\t}\n\t\t\t}\n\t\tint temp = list[index2];\n\t\tint ind = map.get(list[index2]);\n\t\tint temp2 = list[ind];\n\t\tlist[index2] = temp2;\n\t\tlist[ind] = temp;\n\t\tcount = count + temp + temp2;\n\t\t//System.out.println(temp + \"??¨\" + temp2 +\"?????????\" + time+ \"??????\");\n\t\t//time++;\n\t\tflag = true;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(i != map.get(list[i])){\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\t\t}while(flag != true);\n\t\tSystem.out.println(count);\n\t}\n\t\n\tstatic void merge(int[] numList, int left, int mid, int right) {\n\t\tint n1 = mid - left;\n\t\tint n2 = right - mid;\n\t\tint[] L = new int[n1 + 1];\n\t\tint[] R = new int[n2 + 1];\n\n\t\tfor (int i = 0; i < n1; i++) {\n\t\t\tL[i] = numList[left + i];\n\t\t}\n\n\t\tfor (int i = 0; i < n2; i++) {\n\t\t\tR[i] = numList[mid + i];\n\t\t}\n\n\t\tL[n1] = Integer.MAX_VALUE;\n\t\tR[n2] = Integer.MAX_VALUE;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\t// L??¨R??????????????????????°????????????????numList???????´??????????\n\t\t// ?°?????????????????????????????????????????¬??????????????????????????????????????´????????????????????????°?????????+1?????????\n\t\tfor (int k = left; k < right; k++) {\n\t\t\tif (L[i] <= R[j]) {\n\t\t\t\tnumList[k] = L[i];\n\t\t\t\ti = i + 1;\n\t\t\t} else {\n\t\t\t\tnumList[k] = R[j];\n\t\t\t\tj = j + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// ????¨????merge???????????????????±??????????????°?????´???????(left)??¨?????§????´???????(right)?????????-1??????????????§??°????????????\n\tstatic void mergeSort(int[] numList, int left, int right) {\n\t\tif ((left + 1) < right) {\n\t\t\tint mid = (left + right) / 2;\n\n\t\t\tmergeSort(numList, left, mid);\n\t\t\t// System.out.println(\"???\");\n\t\t\tmergeSort(numList, mid, right);\n\t\t\t// System.out.println(\"???\");\n\t\t\tmerge(numList, left, mid, right);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main{\n\n\tpublic static void main(String[] args) throws IOException{\n\t\t\n\t\tBufferedReader br = new Bufferedreader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tint[] W = new int[n];\n\t\tString[] in = br.readLine().split(\" \");\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tW[i] = Integer.parseInt(in[i]);\n\t\t}\n\t\tSystem.out.printf(\"%d\\n\", minCostSort(W));\n\t}\n\n\tpublic static int indexOf(int[] A, int x){\n\t\tfor(int i = 0; i < A.length; i++){\n\t\t\tif(A[i] == x){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic static int minCostSort(int[] W){\n\t\tint[] sorted = W.clone();\n\t\tArrays.sort(sorted);\n\t\tint cost = 0;\n\t\tfor(int i = 0; i < W.length; i++){\n\t\t\tint a = indexOf(W, sorted[i]);\n\t\t\tint j = 0;\n\t\t\twhile(a > i){\n\t\t\t\tj++;\n\t\t\t\tint b = indexOf(W, sorted[a]);\n\t\t\t\tcost += W[b];\n\t\t\t\tint work = W[a];\n\t\t\t\tW[a] = W[b];\n\t\t\t\tW[b] = work;\n\t\t\t\ta = b;\n\t\t\t}\n\t\t\tcost += Math.min(sorted[i] * j, sorted[i] * 2 + sorted[0] * (j+2));\n\t\t}\n\t\treturn cost;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        \n        Scanner sc = new Scanner(System.in);\n        \n        int n = Integer.parseInt(sc.next());\n        int[] w = new int[n];\n        int x = 10000;\n        for(int i = 0; i < n; i++){\n            w[i] = Integer.parseInt(sc.next());\n            if(w[i] < x) x = w[i];\n        }\n        \n        int[] w2 = w.clone();\n        Arrays.sort(w2);\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i = 0; i < n; i++){\n            map.put(w2[i], i);\n        }\n        \n        int ans = 0;\n        boolean[] done = new boolean[n];\n        for(int i = 0; i < n; i++){\n            if(done[i]) continue;\n            List<Integer> list = new ArrayList<>();\n            list.add(i);\n            done[i] = true;\n            int j = map.get(w[i]);\n            while(j != i){\n                list.add(j);\n                done[j] = true;\n                j = map.get(w[j]);\n            }\n            int sum = 0;\n            int min = 10000;\n            for (Integer k : list) {\n                sum += w[k];\n                if(w[k] < min) min = w[k];\n            }\n            ans += Math.min(sum + (list.size()-2) * min, sum + min + (list.size()+1) * x);\n        }\n        \n        System.out.println(ans);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.IOException;\n\n// ALDS1_6_D\npublic class Main {\n\tint binarySearch(int[] array, int n, int min, int max) {\n\t\tif (min > max) return -1;\n\t\tint mid = (max + min) / 2;\n\t\tif (array[mid] == n) return mid;\n\t\tif (array[mid] > n) return binarySearch(array, n, min, mid-1);\n\t\telse return binarySearch(array, n, mid+1, max);\n\t}\n\t\n\tint SENTINEL = 1234567890;\n\tvoid merge(int[]A, int left, int mid, int right) {\n\t\tint n1 = mid - left + 1;\n\t\tint n2 = right - mid;\n\t\tint[] L = new int[n1 + 1];\n\t\tint[] R = new int[n2 + 1];\n\t\tfor (int i = 0; i < n1; i++) {\n\t\t\tL[i] = A[left + i];\n\t\t}\n\t\tfor (int i = 0; i < n2; i++) {\n\t\t\tR[i] = A[mid + 1 + i];\n\t\t}\n\t\tL[n1] = SENTINEL;\n\t\tR[n2] = SENTINEL;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tfor (int k = left; k <= right; k++) {\n\t\t\tif (L[i] <= R[j]) {\n\t\t\t\tA[k] = L[i];\n\t\t\t\ti = i + 1;\n\t\t\t} else {\n\t\t\t\tA[k] = R[j];\n\t\t\t\tj = j + 1;\n\t\t\t}\n\t    }\n\t}\n\n\tvoid mergeSort(int[] A, int left, int right) {\n\t    \tif (left < right) {\n\t    \t\tint mid = (left + right)/2;\n\t    \t\tmergeSort(A, left, mid);\n\t    \t\tmergeSort(A, mid + 1, right);\n\t    \t\tmerge(A, left, mid, right);\n\t  \t}\n\t}\n\tint cost = 0;\n\tvoid run() throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint min = 10000;\n\t\tint[] A = new int[n];\n\t\tboolean[] check = new boolean[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tA[i] = sc.nextInt();\n\t\t\tcheck[i] = false;\n\t\t\tif (min > A[i]) min = A[i];\n\t\t}\n\t\tint[] B = A.clone();\n\t\tmergeSort(B, 0, n-1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (check[i]) continue;\n\t\t\tcheck[i] = true;\n\t\t\tif (A[i] == B[i]) continue;\n\t\t\tint loopmin = A[i];\n\t\t\tint count = 0;\n\t\t\tint j = i;\n\t\t\twhile(true) {\n\t\t\t\tcost += A[j];\n\t\t\t\tj = binarySearch(B, A[j], 0, n-1);\n\t\t\t\tif (check[j]) break;\n\t\t\t\tif (loopmin > A[j]) loopmin = A[j];\n\t\t\t\tcheck[j] = true;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcost -= loopmin;\n\t\t\tif ((count)*(loopmin-min) > 2*(min + loopmin))\n\t\t\t\tcost += 2*(min + loopmin);\n\t\t\telse\n\t\t\t\tcost += count*loopmin;\n\t\t}\n\t\tSystem.out.println(cost);\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n        }\n        System.out.println(minimumCost(a));\n    }\n\n    private static long minimumCost(int[] a) {\n        int[] sorted = Arrays.copyOf(a, a.length);\n        Arrays.sort(sorted);\n        int[] indexes = new int[sorted[a.length-1]+1];\n        for (int i = 0; i < a.length; i++) {\n            indexes[sorted[i]] = i;\n        }\n\n        long cost = 0;\n        for (int i = 0; i < a.length; i++) {\n            int goalIndex = indexes[a[i]];\n            if (goalIndex != i && goalIndex >= 0) {\n                int cycleSize = 1;\n                int cycleMin = a[i];\n                int cycleSum = a[i];\n                while (goalIndex != i) {\n                    int nextInCycle = a[goalIndex];\n                    cycleSize++;\n                    if (nextInCycle < cycleMin) cycleMin = nextInCycle;\n                    cycleSum += nextInCycle;\n                    goalIndex = indexes[nextInCycle];\n                    indexes[nextInCycle] = -1;\n                }\n                cost += Math.min(cycleSum + cycleMin * (cycleSize - 2),\n                        cycleSum + cycleMin + sorted[0] * (cycleSize + 1));\n            }\n        }\n        return cost;\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int[] w = new int[n];\n        int maxV = Integer.MIN_VALUE;\n        for (int i = 0; i < n; i++) {\n            w[i] = in.nextInt();\n            if (w[i] > maxV) maxV = w[i];\n        }\n        int result = minCostSort(w, n, maxV);\n        System.out.println(result);\n    }\n\n    public static int minCostSort(int[] w, int n, int maxV) {\n        int ans = 0;  // 初始化结果\n\n        boolean[] visit = new boolean[n];  // 已访问标记数组\n        for (int i = 0; i < n; i++) {\n            visit[i] = false;\n        }\n\n        int[] sortedW = w.clone();  // 有序成本数组\n        Arrays.sort(sortedW);\n\n        int[] T = new int[maxV + 1];  // 某成本对应的顺序序号\n        for (int i = 0; i < n; i++) {\n            T[sortedW[i]] = i;\n        }\n        int x = sortedW[0];\n\n        for (int i = 0; i < n; i++) {\n            if (visit[i]) continue;  // 已访问过，则接着访问下一个\n            int cur = i;  // 当前访问位置\n            int sum = 0;  // 环路内总成本\n            int min = maxV;  // 环路内最小成本\n            int count = 0;  // 环路总长度\n\n            // 寻找该成本在实际顺序中的对应位置，即交换位置\n            while (!visit[cur]) {\n                visit[cur] = true;\n                count++;\n                int v = w[cur];\n                min = Math.min(min, v);\n                sum += v;\n                cur = T[v];\n            }\n\n            ans += Math.min(sum + (count - 2) * min, min + sum + (count + 1) * x);\n        }\n        return ans;\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "// reference https://www.ipsj.or.jp/07editj/promenade/4506.pdf\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Node implements Comparable<Node> {\n    int value;\n    int place;\n\n    Node(int value, int place) {\n        this.value = value;\n        this.place = place;\n    }\n\n    public int compareTo(Node n) {\n        return value - n.value;\n    }\n}\n\npublic class Main {\n    private static int sillysort(int m, int[] seq) {\n        // initialize\n        Node[] nodes = new Node[m];\n        Node[] temp = new Node[m];\n        for(int i = 0; i < m; i++) {\n            temp[i] = new Node(seq[i], i);\n        }\n        Arrays.sort(temp);\n        for(int i = 0; i < m; i++) {\n            nodes[i] = new Node(-1, -1);\n        }\n        for(int i = 0; i < m; i++) {\n            nodes[i].value = seq[i];\n            nodes[temp[i].place].place = i;\n        }\n        int s = temp[0].value;\n\n        // compute\n        int cost = 0;\n        for(int i = 0; i < m; i++) {\n            int j = nodes[i].place;\n            if(j >= 0 && j != i) {\n                int n = 1;\n                int amin = nodes[i].value;\n                int sum = nodes[i].value;\n                while(j != i) {\n                    int next = nodes[j].place;\n                    amin = Math.min(amin, nodes[j].value);\n                    sum += nodes[j].value;\n                    n++;\n                    nodes[j].place = -1;\n                    j = next;\n                }\n                cost += Math.min(sum + (n - 2) * amin, sum + amin + (n + 1) * s);\n            }\n        }\n        return cost;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n \n        int n = sc.nextInt();\n        int[] a = new int[n];\n        for(int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n\n        System.out.println(sillysort(n, a));\n\n        sc.close();\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\n class FS {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readByte() {\n        return hasNextByte() ? buffer[ptr++] : -1;\n    }\n\n    private boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n        skipUnprintable();\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public int nextInt() {\n        return (int) nextLong();\n    }\n\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        FS fs = new FS();\n        int n = fs.nextInt();\n        Stuff a[] = new Stuff[n];\n        boolean b[]  =new boolean[n];\n        for (int i = 0; i < n; i++) {\n            int wei = fs.nextInt();\n            a[i]=new Stuff(i,wei);\n        }\n        Arrays.sort(a);\n        int min=a[0].weight;\n        int wcount=0;\n        for (int i = 0; i < a.length; i++) {\n            if (min>a[i].weight)min=a[i].weight;\n            if (b[i])continue;\n            if (a[i].index==i)continue;\n            int minw=a[i].weight;\n            int k=0;\n            for (int j = a[i].index; !b[j]; j=a[j].index,k++){\n                if (min>a[j].weight)min=a[j].weight;\n                if (minw>a[j].weight)min=a[j].weight;\n                b[j]=true;\n                wcount+=a[j].weight;\n            }\n            wcount+=Math.min((k-2)*minw,minw+(k+1)*min);\n        }\n        System.out.println(wcount);\n    }\n\n   static class Stuff implements Comparable<Stuff> {\n        int index;\n        int weight;\n\n        public Stuff(int index, int weight) {\n            this.index = index;\n            this.weight = weight;\n        }\n\n\n\n       @Override\n       public int compareTo(Stuff o) {\n            if (o.weight>this.weight)return -1;\n            else return 1;\n       }\n   }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\n//import java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nclass Main {\n  public static void main(String[] args) throws IOException {\n\t//System.setIn(new FileInputStream(\"./input2.txt\"));\n\t\t\n\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tint n = Integer.parseInt(br.readLine());\n\n\tint[] a = new int[n];\n\tString[] s = br.readLine().split(\" \");\n    for(int i = 0; i < n; ++i){\n        a[i] = Integer.parseInt(s[i]);\n    }\n    \n    int cost = 0;\n    for(int i = 0; i < n; ++i){\n        int maxj = i;\n        for(int j = i; j < n; ++j){\n            if(a[maxj] > a[j]){\n                maxj = j;\n            }\n        }\n        if(maxj != i){\n            int tmp = a[maxj];\n            a[maxj] = a[i];\n            a[i] = tmp;\n            cost += a[maxj] + a[i];\n        }   \n    }\n    /*\n    for(int i = 0; i < n; ++i){\n    \tSystem.out.print(\" \" + a[i]);\n    }\n    System.out.println();*/\n    System.out.println(cost);\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Main {\n\t\n\tpublic static class Arr implements Comparable<Arr> {\n\t\tint[] array;\n\t\tint cost;\n\t\t\n\t\tpublic Arr(int[] array, int cost) {\n\t\t\tsuper();\n\t\t\tthis.array = array;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\tpublic boolean is_finished(){\n\t\t\tfor(int i = 1; i < array.length; i++){\n\t\t\t\tif(array[i - 1] > array[i]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Arr arg0) {\n\t\t\treturn this.cost - arg0.cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + Arrays.hashCode(array);\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tArr other = (Arr) obj;\n\t\t\tif (!Arrays.equals(array, other.array))\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\n\t\tfinal int n = sc.nextInt();\n\t\tint[] array = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tarray[i] = sc.nextInt();\n\t\t}\n\t\t\n\t\t\n\t\tPriorityQueue<Arr> queue = new PriorityQueue<Arr>();\n\t\tHashSet<Arr> visited = new HashSet<Arr>();\n\t\tqueue.add(new Arr(array, 0));\n\t\t\n\t\twhile(!queue.isEmpty()){\n\t\t\tfinal Arr arr = queue.poll();\n\t\t\t\n\t\t\tif(arr.is_finished()){\n\t\t\t\tSystem.out.println(arr.cost);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(visited.contains(arr)){\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tvisited.add(arr);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < arr.array.length; i++){\n\t\t\t\tfor(int j = i + 1; j < arr.array.length; j++){\n\t\t\t\t\tint[] next = new int[arr.array.length];\n\t\t\t\t\tSystem.arraycopy(arr.array, 0, next, 0, arr.array.length);\n\t\t\t\t\tint tmp = next[i];\n\t\t\t\t\tnext[i] = next[j];\n\t\t\t\t\tnext[j] = tmp;\n\t\t\t\t\t\n\t\t\t\t\tqueue.add(new Arr(next, arr.cost + next[i] + next[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n\tpublic static class Scanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (!hasNext()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tbr.close();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tlong count = 0;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tint min = Integer.MAX_VALUE;\n\t\tint[] A = new int[n];\n\t\tint max = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tA[i] = scanner.nextInt();\n\t\t\tmin = Math.min(min, A[i]);\n\t\t\tmax = Math.max(max, A[i]);\n\t\t}\n\t\tint ans = 0;\n\t\tboolean[] V = new boolean[n];\n\t\tint[] B = Arrays.copyOf(A, A.length);\n\t\tArrays.sort(B);\n\t\tint[] T = new int[max + 1];\n\t\tList<Integer> list  = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlist.add(B[i]);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint cur = i;\n\t\t\tint s = 0;\n\t\t\tint m = max;\n\t\t\tint an = 0;\n\t\t\twhile (true) {\n\t\t\t\tV[cur] = true;\n\t\t\t\tan++;\n\t\t\t\tint v = A[cur];\n\t\t\t\tm = Math.min(m, v);\n\t\t\t\ts += v;\n\t\t\t\tcur = list.indexOf(v);\n\t\t\t\tif (V[cur])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint a = s + (an - 2) * m;\n\t\t\tint b = m + s + (an + 1) * min;\n\t\t\tans += Math.min(a, b);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.stream.Stream;\n\nclass Main {\n\n\tfinal static int MAX = 1_000;\n\tfinal static int VMAX = 10_000;\n\n\tstatic int n, small;\n\tstatic int[] a;\n\tstatic int[] b = new int[MAX];\n\tstatic int[] truery = new int[VMAX];\n\n\tpublic static void main(String[] args) {\n\n\t\ttry(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {\n\n\t\t\tn = Integer.parseInt(br.readLine());\n\t\t\ta = Stream.of(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tsmall = VMAX;\n\t\tfor(int w : a) {\n\t\t\tsmall = Math.min(small, w);\n\t\t}\n\n\t\tint ans = solve();\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tprivate static int solve() {\n\t\tint ans = 0;\n\t\tb = Arrays.copyOf(a, n);\t\t\t\t\t\t// ??£?????????????????????b\n\t\tboolean[] valid = new boolean[MAX];\t\t\t// ??£?????????????????§?????£???????????????????????£???????????????\n\n\t\tArrays.sort(b);\n\t\tfor (int i = 0; i < n; i++) truery[b[i]] = i;\t// ????????????number?????¬??\\?????????????????????????¨????\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (valid[i]) continue;\n\t\t\tint cur = i;\n\t\t\tint sum = 0;\t\t// ??????????????????????????????\n\t\t\tint min = VMAX;\t\t// ??????????????§????°???????\n\t\t\tint an = 0;\t\t\t// ?????????????´???°\n\n\t\t\twhile(true) {\n\t\t\t\tvalid[i] = true;\n\t\t\t\tan++;\n\t\t\t\tint val = a[cur];\n\t\t\t\tmin = Math.min(min, val);\n\t\t\t\tsum += val;\n\t\t\t\tcur = truery[val];\n\t\t\t\tif (valid[cur]) break;\n\t\t\t}\n\n\t\t\tans += Math.min( sum + (an-2) * min, min + sum + (an+1) * sum );\n\n\t\t}\n\t\treturn ans;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    Scanner sc = new Scanner(System.in);\n\n    int[] copyArray(int[] src) {\n        int[] dst = new int[src.length];\n        for (int i = 0; i < src.length; i++) {\n            dst[i] = src[i];\n        }\n        return dst;\n    }\n\n    List<Integer> traverse(int[] W, int[] sorted, boolean[] traversedIndices, int firstIdx, int idx) {\n        traversedIndices[idx] = true;\n        int x = W[idx];\n        int nextIdx = -1;\n        for (int i = 0; i < sorted.length; i++) {\n            if (sorted[i] == x) {\n                nextIdx = i;\n                break;\n            }\n        }\n        if (nextIdx == -1) throw new Error();\n        if (firstIdx == nextIdx) {\n            List<Integer> li = new LinkedList<Integer>();\n            li.add(idx);\n            return li;\n        } else {\n            List<Integer> li = traverse(W, sorted, traversedIndices, firstIdx, nextIdx);\n            li.add(idx);\n            return li;\n        }\n    }\nList<List<Integer>> findCycles(int[] W) {\n        int[] copied = copyArray(W);\n        Arrays.sort(copied);\n        int[] sorted = copied;\n        boolean[] traversedIndices = new boolean[W.length];\n        List<List<Integer>> cycles = new LinkedList<List<Integer>>();\n        for (int i = 0; i < W.length; i++) {\n            if (traversedIndices[i]) continue;\n            cycles.add(traverse(W, sorted, traversedIndices, i, i));\n        }\n        return cycles;\n    }\n\n    void printCycles(List<List<Integer>> cycles) {\n        System.out.println(\"Cycles ---\");\n        for (List<Integer> li : cycles) {\n            for (Integer x : li) {\n                System.out.print(x + \" \");\n            }\n            System.out.println();\n        }\n        System.out.println(\"--- Cycles\");\n    }\n\n    int calcCycleCost(int[] W, List<Integer> cycle, int min) {\n        int sum = 0;\n        int minInACycle = Integer.MAX_VALUE;\n        if (cycle.size() == 1) return 0;\n        for (Integer val : cycle) {\n            sum += W[val];\n            minInACycle = Math.min(minInACycle, W[val]);\n        }\n        int a = sum + (cycle.size() - 2) * minInACycle;\n        int b = sum + minInACycle + (cycle.size()+1) * min;\n        return Math.min(a, b);\n    }\nint calcCost(int[] W, List<List<Integer>> cycles, int min) {\n        int cost = 0;\n        for (List<Integer> cycle : cycles) {\n            int x = calcCycleCost(W, cycle, min);\n            cost += x;\n        }\n        return cost;\n    }\n\n    void run() {\n        int n = sc.nextInt();\n        int[] W = new int[n];\n        int min = Integer.MAX_VALUE;\n        for (int i = 0; i < W.length; i++) {\n            W[i] = sc.nextInt();\n            min = Math.min(min, W[i]);\n        }\n        List<List<Integer>> cycles = findCycles(W);\n        //printCycles(cycles);\n        System.out.println(calcCost(W, cycles, min));\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int size = scan.nextInt(), r = 0;\n        int arr[][] = new int[size][2];\n        for(int i = 0; i < size; i++){\n            arr[i][0] = scan.nextInt(); arr[i][1] = i;\n        }\n        int arrsorted[][] = arr.clone();\n        Arrays.sort(arrsorted, Comparator.comparing((int[] iarr) -> iarr[0]));\n        for(int i = size - 1; 0 <= i; i--)\n            if(arr[i][1] != arrsorted[i][1]){\n                r += arr[i][0] + arr[arrsorted[i][1]][0];\n                int tmp[] = arr[i];\n                arr[i] = arr[arrsorted[i][1]];\n                arr[arrsorted[i][1]] = tmp;\n            }\n        System.out.println(r);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n    public static void main (String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        Integer[] w = new Integer[n];\n        for (int i = 0; i < n; i ++) {\n            w[i] = sc.nextInt();\n        }\n        Integer[] sorted = Arrays.copyOf(w, n);\n        Arrays.sort(sorted);\n\n        int cost = 0;\n        while (!Arrays.deepEquals(w, sorted)) {\n            int min = Integer.MAX_VALUE;\n            int minIndex = 0;\n            for (int i = 0; i < n; i++) {\n                if (sorted[i] != w[i] && min > w[i]) {\n                    min = w[i];\n                    minIndex = i;\n                }\n            }\n\n            int index = Arrays.asList(w).indexOf(sorted[minIndex]);\n            if (index == -1) {\n                System.out.println(minIndex + \" \" + w[minIndex] + \" \" + sorted[minIndex]);\n            }\n            int temp = w[minIndex];\n            w[minIndex] = w[index];\n            w[index] = temp;\n            cost += w[minIndex] + w[index];\n        }\n\n        System.out.println(cost);\n\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate int lim;\n\tprivate int wall;\n\t\n\tprivate int[] a;\n\tprivate int[] b;\n\t\n\tprivate ArrayList<Integer[]> iset;\n\t\n\tprivate Scanner sc;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\tlim = Integer.parseInt(sc.nextLine());\n\t\t\n\t\ta = new int[lim];\t\t\n\t\tb = new int[lim];\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\ta[i] = Integer.parseInt(sc.next());\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tArrays.sort(b);\n\t\t\n\t\tiset = new ArrayList<Integer[]>();\n\t\tfor (int i = 1; i < lim * 2; i++) {\n\t\t\tfor (int n0 = 0; n0 < i; n0++) {\n\t\t\t\tint n1 = i - n0;\n\t\t\t\tif (n0 >= n1) break;\n\t\t\t\tif (n1 >= lim) continue;\n\n\t\t\t\tif ((a[n0] == b[n0]) || (a[n1] == b[n1])) continue;\n\n\t\t\t\tInteger[] ij = {b[n0], b[n1]};\n\t\t\t\tiset.add(ij);\n\t\t\t}\n\t\t}\n\t\t\n\t\twall = 0;\n\t\tfor (int i = 0; i < iset.size(); i++) {\n\t\t\tswap(i, 0);\n\t\t}\n\t\t\n\t\tSystem.out.println(wall);\n\t}\n\t\n\tpublic void swap(int index, int ans) {\n\t\tInteger[] ij = iset.get(index);\n\n\t\tif ((wall != 0) && (wall < (ans + ij[0] + ij[1]))) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tiset.remove(index);\n\n\t\tint small = -1;\n\t\tint large = -1;\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\tif (a[i] == ij[0]) {\n\t\t\t\tsmall = i;\n\t\t\t} else if (a[i] == ij[1]) {\n\t\t\t\tlarge = i;\n\t\t\t}\n\t\t\t\n\t\t\tif ((small != -1) && (large != -1)) break;\n\t\t}\n\t\t\n\t\tif ((a[small] == b[large]) || (a[large] == b[small])) {\n\t\t\tint tmp = a[small];\n\t\t\ta[small] = a[large];\n\t\t\ta[large] = tmp;\n\t\t\t\n\t\t\tans = ans + a[small] + a[large];\n\t\t} else {\n\t\t\tiset.add(index, ij);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tboolean flag = true;\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\tif (a[i] != b[i]) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag) {\n\t\t\tint tmp = a[small];\n\t\t\ta[small] = a[large];\n\t\t\ta[large] = tmp;\n\t\t\t\n\t\t\tiset.add(index, ij);\n\t\t\tif ((wall == 0) || (wall > ans)) wall = ans;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < iset.size(); i++) {\n\t\t\tswap(i, ans);\n\t\t}\n\n\t\tint tmp = a[small];\n\t\ta[small] = a[large];\n\t\ta[large] = tmp;\n\t\t\n\t\tiset.add(index, ij);\n\t\treturn;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.IOException;\n\n// ALDS1_6_D\npublic class Main {\n\tint SENTINEL = 1234567890;\n\tvoid merge(int[]A, int left, int mid, int right) {\n\t\tint n1 = mid - left + 1;\n\t\tint n2 = right - mid;\n\t\tint[] L = new int[n1 + 1];\n\t\tint[] R = new int[n2 + 1];\n\t\tfor (int i = 0; i < n1; i++) {\n\t\t\tL[i] = A[left + i];\n\t\t}\n\t\tfor (int i = 0; i < n2; i++) {\n\t\t\tR[i] = A[mid + 1 + i];\n\t\t}\n\t\tL[n1] = SENTINEL;\n\t\tR[n2] = SENTINEL;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tfor (int k = left; k <= right; k++) {\n\t\t\tif (L[i] <= R[j]) {\n\t\t\t\tA[k] = L[i];\n\t\t\t\ti = i + 1;\n\t\t\t} else {\n\t\t\t\tA[k] = R[j];\n\t\t\t\tj = j + 1;\n\t\t\t}\n\t    }\n\t}\n\n\tvoid mergeSort(int[] A, int left, int right) {\n\t    \tif (left < right) {\n\t    \t\tint mid = (left + right)/2;\n\t    \t\tmergeSort(A, left, mid);\n\t    \t\tmergeSort(A, mid + 1, right);\n\t    \t\tmerge(A, left, mid, right);\n\t  \t}\n\t}\n\tint cost = 0;\n\tvoid run() throws IOException {\n\t\tArrayList<Integer> lis = new ArrayList<Integer>();\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] A = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlis.add(i);\n\t\t\tA[i] = sc.nextInt();\n\t\t}\n\t\tint[] B = A.clone();\n\t\tmergeSort(B, 0, n-1);\n\t\twhile (true) {\n\t\t\t// A[i] == B[i] 値の位置が正しい場合を除外\n\t\t\t//if (lis instanceof ArrayList)\n\t\t\tArrayList<Integer> liscopy = (ArrayList<Integer>) lis.clone();\n\t\t\tfor (Integer v : lis) {\n\t\t\t\tif (A[v] == B[v]) liscopy.remove(v);\n\t\t\t}\n\t\t\tlis = (ArrayList<Integer>) liscopy.clone();\n\t\t\t// 基底条件\n\t\t\tif (lis.isEmpty()) break;\n\t\t\t// 交換する組を決める(重さが一番小さい組の交換元をminpoint)\n\t\t\tint minpoint = lis.get(0);\n\t\t\tfor (Integer v : lis) \n\t\t\t\tif (A[minpoint] + B[minpoint] > A[v] + B[v]) minpoint = v;\n\t\t\t// 交換先の値をtmpnum\n\t\t\tint tmppoint = -1;\n\t\t\tfor (Integer v : lis) {\n\t\t\t\tif (minpoint == v) continue;\n\t\t\t\tif (B[minpoint] == A[v]) tmppoint = v;\n\t\t\t}\n\t\t\tif (tmppoint == -1) System.out.println(\"not tmpnum\");\n\t\t\t// 相互\n\t\t\tfor (Integer v : lis) {\n\t\t\t\tif (minpoint == v) continue;\n\t\t\t\tif (B[minpoint] != B[v]) continue;\n\t\t\t\tif (A[v] == B[tmppoint]) minpoint = v;\n\t\t\t}\n\t\t\tcost += A[tmppoint] + A[minpoint];\n\t\t\tint tmp = A[tmppoint];\n\t\t\tA[tmppoint] = A[minpoint];\n\t\t\tA[minpoint] = tmp;\n\t\t}\n\t\tSystem.out.println(cost);\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tNode W[] = new Node[n];\n\t\tint s=Integer.MAX_VALUE, cost=0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tW[i] = new Node();\n\t\t\tW[i].value = sc.nextInt();\n\t\t\tW[i].place = -1;\n\t\t\tif(s > W[i].value) s = W[i].value;\n\t\t}\n\n\t\tfor(int j=0; j<n; j++){\n\t\t\tint min=Integer.MAX_VALUE, place=-1;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(W[i].place != -1) continue;\n\t\t\t\tif(min > W[i].value){\n\t\t\t\t\tmin = W[i].value;\n\t\t\t\t\tplace = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tW[place].place = j;\n\t\t}\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint j=W[i].place;\n\t\t\tif(j != -1 && j != i){\n\t\t\t\tint cnt=1, min, sum;\n\t\t\t\tmin = sum = W[i].value;\n\t\t\t\twhile(j != i){\n\t\t\t\t\tint next = W[j].place;\n\t\t\t\t\tif(min > W[j].value) min = W[j].value;\n\t\t\t\t\tsum += W[j].value;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tW[j].place = -1;\n\t\t\t\t\tj = next;\n\t\t\t\t}\n\t\t\t\tcost += sum+(cnt-2)*min<sum+min+(cnt+1)*s?\n\t\t\t\t        sum+(cnt-2)*min:\n\t\t\t\t        sum+min+(cnt+1)*s;\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(cost);\n\t}\n}\nclass Node{\n\tint value;\n\tint place;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate int[] a;\n\tprivate int[] b;\n\t\n\tprivate Scanner sc;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\tint lim = Integer.parseInt(sc.nextLine());\n\t\t\n\t\ta = new int[lim];\t\t\n\t\tb = new int[lim];\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\ta[i] = Integer.parseInt(sc.next());\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tArrays.sort(b);\n\t\t\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\tif (a[i] != b[i]) {\n\t\t\t\tfor (int j = (i + 1); j < lim; j++) {\n\t\t\t\t\tif ((a[j] == b[i]) && (a[i] == b[j])) {\n\t\t\t\t\t\ta[i] = b[i];\n\t\t\t\t\t\ta[j] = b[j];\n\t\t\t\t\t\t\n\t\t\t\t\t\tans = ans + a[i] + a[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean judge = false;\n\t\twhile (judge == false) {\n\t\t\tjudge = true;\n\t\t\t\n\t\t\tfor (int i = 0; i < lim; i++) {\n\t\t\t\tif (a[i] != b[i]) {\n\t\t\t\t\tfor (int j = (i + 1); j < lim; j++) {\n\t\t\t\t\t\tif (a[j] != b[j]) {\n\t\t\t\t\t\t\tint small = -1;\n\t\t\t\t\t\t\tint large = -1;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfor (int k = 0; k < lim; k++) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (a[k] == b[i]) {\n\t\t\t\t\t\t\t\t\tsmall = k;\n\t\t\t\t\t\t\t\t} else if (a[k] == b[j]) {\n\t\t\t\t\t\t\t\t\tlarge = k;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif ((small != -1) && (large != -1)) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (a[small] == b[j]) {\n\t\t\t\t\t\t\t\ta[small] = a[large];\n\t\t\t\t\t\t\t\ta[large] = b[j];\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tans = ans + a[small] + a[large];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (a[large] == b[i]) {\n\t\t\t\t\t\t\t\ta[large] = a[small];\n\t\t\t\t\t\t\t\ta[small] = a[i];\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tans = ans + a[small] + a[large];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int n = sc.nextInt();\n\t\tint[] array = new int[n];\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tarray[i] = sc.nextInt();\n\t\t}\n\t\t\n\t\tlong cost = 0;\n\t\tfor(int i = 0; i < n - 1; i++){\n\t\t\tint min = array[i];\n\t\t\tint min_pos = i;\n\t\t\t\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tif(array[j] < min){\n\t\t\t\t\tmin = array[j];\n\t\t\t\t\tmin_pos = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(min_pos != i){\n\t\t\t\tcost += array[i] + min;\n\t\t\t\t\n\t\t\t\tarray[min_pos] = array[i];\n\t\t\t\tarray[i] = min;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(cost);\n\t}\n\t\n\tpublic static class Scanner {\n\t    private BufferedReader br;\n\t    private StringTokenizer tok;\n\n\t    public Scanner(InputStream is) throws IOException {\n\t        br = new BufferedReader(new InputStreamReader(is));\n\t    }\n\n\t    private void getLine() throws IOException {\n\t        while (!hasNext()) { tok = new StringTokenizer(br.readLine()); }\n\t    }\n\n\t    private boolean hasNext() {\n\t        return tok != null && tok.hasMoreTokens();\n\t    }\n\n\t    public String next() throws IOException {\n\t        getLine(); return tok.nextToken();\n\t    }\n\n\t    public int nextInt() throws IOException {\n\t        return Integer.parseInt(next());\n\t    }\n\t    \n\t    public long nextLong() throws IOException {\n\t    \treturn Long.parseLong(next());\n\t    }\n\t    \n\t    public void close() throws IOException {\n\t        br.close();\n\t    }\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\nclass Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\t// Input an array\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\n\t\tBaggage[] a = new Baggage[n];\n\t\tString[] strs = br.readLine().split(\" \");\n\t    for(int i = 0; i < n; ++i){\n\t        a[i] = new Baggage(i, Integer.parseInt(strs[i]));\n\t    }\n\t    \n\t    // Number the array\n\t    mergeSort(a, 0, n);\n\t    \n\t    // Calc. cost\n\t    int cost = 0;\n\t    int minw = a[0].weight;\n\t    int loss, cnt, j;\n\t    for(int i = 0; i < n; ++i) {\n\t    \tif(a[i].flag == true){\n\t\t    \t// search group key i\n\t    \t\tcontinue;\n\t    \t}\n    \t\t\n\t    \t// count cost for group i\n\t    \tcnt = 0; // swap count\n\t    \tj = a[i].org;\n\t    \twhile(j != i) {\n\t    \t\t// swap a[j] and a[i]\n\t    \t    cost += a[j].weight + a[i].weight;\n\t    \t\tcnt += 1;\n\n\t    \t    a[j].flag = true;\n\t\t    \tj = a[j].org;\n\t   \t    }\n\t    \tloss = (a[i].weight * cnt) - minw * cnt - 2 * (minw + a[i].weight);\n\t    \tif(loss > 0){\n\t    \t\tcost -= loss;\n\t    \t}\n\t    }\n\t    \n\t    System.out.println(cost);\n\t}\n\t\n\tpublic static void mergeSort(Baggage[] s, int left, int right) {\n\t\tif(left + 1 < right) {\n\t\t\tint mid = (left + right) / 2;\n\t\t\tmergeSort(s, left, mid);\n\t\t\tmergeSort(s, mid, right);\n\t\t\tmerge(s, left, mid, right);\n\t\t}\n\t}\n\tpublic static void merge(Baggage[] s, int left, int mid, int right) {\n\t\tBaggage[] s1 = Arrays.copyOfRange(s, left, mid + 1);\n\t\tBaggage[] s2 = Arrays.copyOfRange(s, mid, right + 1);\n\t\t\n\t\ts1[mid - left] = new Baggage(-1, Integer.MAX_VALUE);\n\t\ts2[right - mid] = new Baggage(-1, Integer.MAX_VALUE);\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tfor(int k = left; k < right; ++k) {\n\t\t\tif(s1[i].weight <= s2[j].weight){\n\t\t\t\ts[k] = s1[i];\n\t\t\t\ti += 1;\n\t\t\t}else{\n\t\t\t\ts[k] = s2[j];\n\t\t\t\tj += 1;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n\nclass Baggage {\n\tpublic int org;\n\tpublic int weight;\n\tpublic boolean flag;\n\tpublic Baggage(int o, int w) {\n\t\torg = o;\n\t\tweight = w;\n\t\tflag = false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.IOException;\n\n// ALDS1_6_D\npublic class Main {\n\tint SENTINEL = 1234567890;\n\tvoid merge(int[]A, int left, int mid, int right) {\n\t\tint n1 = mid - left + 1;\n\t\tint n2 = right - mid;\n\t\tint[] L = new int[n1 + 1];\n\t\tint[] R = new int[n2 + 1];\n\t\tfor (int i = 0; i < n1; i++) {\n\t\t\tL[i] = A[left + i];\n\t\t}\n\t\tfor (int i = 0; i < n2; i++) {\n\t\t\tR[i] = A[mid + 1 + i];\n\t\t}\n\t\tL[n1] = SENTINEL;\n\t\tR[n2] = SENTINEL;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tfor (int k = left; k <= right; k++) {\n\t\t\tif (L[i] <= R[j]) {\n\t\t\t\tA[k] = L[i];\n\t\t\t\ti = i + 1;\n\t\t\t} else {\n\t\t\t\tA[k] = R[j];\n\t\t\t\tj = j + 1;\n\t\t\t}\n\t    }\n\t}\n\n\tvoid mergeSort(int[] A, int left, int right) {\n\t    \tif (left < right) {\n\t    \t\tint mid = (left + right)/2;\n\t    \t\tmergeSort(A, left, mid);\n\t    \t\tmergeSort(A, mid + 1, right);\n\t    \t\tmerge(A, left, mid, right);\n\t  \t}\n\t}\n\tint cost = 0;\n\tvoid run() throws IOException {\n\t\tArrayList<Integer> lis = new ArrayList<Integer>();\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] A = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlis.add(i);\n\t\t\tA[i] = sc.nextInt();\n\t\t}\n\t\tint[] B = A.clone();\n\t\tmergeSort(B, 0, n-1);\n\t\twhile (true) {\n\t\t\t// A[i] == B[i] 値の位置が正しい場合を除外\n\t\t\tArrayList<Integer> liscopy = new ArrayList<Integer>(lis);\n\t\t\tfor (Integer v : lis) {\n\t\t\t\tif (A[v] == B[v]) liscopy.remove(v);\n\t\t\t}\n\t\t\tlis = new ArrayList<Integer>(liscopy);\n\t\t\t// 基底条件\n\t\t\tif (lis.isEmpty()) break;\n\t\t\t// 交換する組を決める(重さが一番小さい組の交換元をminpoint)\n\t\t\tint minpoint = lis.get(0);\n\t\t\tfor (Integer v : lis) \n\t\t\t\tif (A[minpoint] + B[minpoint] > A[v] + B[v]) minpoint = v;\n\t\t\t// 交換先の値をtmpnum\n\t\t\tint tmppoint = -1;\n\t\t\tfor (Integer v : lis) {\n\t\t\t\tif (minpoint == v) continue;\n\t\t\t\tif (B[minpoint] == A[v]) tmppoint = v;\n\t\t\t}\n\t\t\tif (tmppoint == -1) System.out.println(\"not tmpnum\");\n\t\t\t// 相互\n\t\t\tfor (Integer v : lis) {\n\t\t\t\tif (minpoint == v) continue;\n\t\t\t\tif (B[minpoint] != B[v]) continue;\n\t\t\t\tif (A[v] == B[tmppoint]) minpoint = v;\n\t\t\t}\n\t\t\tcost += A[tmppoint] + A[minpoint];\n\t\t\tint tmp = A[tmppoint];\n\t\t\tA[tmppoint] = A[minpoint];\n\t\t\tA[minpoint] = tmp;\n\t\t}\n\t\tSystem.out.println(cost);\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate int[] a;\n\tprivate int[] b;\n\t\n\tprivate Scanner sc;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\tint lim = Integer.parseInt(sc.nextLine());\n\t\t\n\t\ta = new int[lim];\t\t\n\t\tb = new int[lim];\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\ta[i] = Integer.parseInt(sc.next());\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tArrays.sort(b);\n\t\t\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\tif (a[i] != b[i]) {\n\t\t\t\t\n\t\t\t\tfor (int j = (i + 1); j < lim; j++) {\n\t\t\t\t\tif (a[j] != b[j]) {\n\t\t\t\t\t\tint small = -1;\n\t\t\t\t\t\tint large = -1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (int k = 0; k < lim; k++) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (a[k] == b[i]) {\n\t\t\t\t\t\t\t\tsmall = k;\n\t\t\t\t\t\t\t} else if (a[k] == b[j]) {\n\t\t\t\t\t\t\t\tlarge = k;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif ((small != -1) && (large != -1)) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (small == j) {\n\t\t\t\t\t\t\ta[large] = a[small];\n\t\t\t\t\t\t\ta[small] = b[j];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tans = ans + a[small] + a[large];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (large == i) {\n\t\t\t\t\t\t\ta[small] = a[large];\n\t\t\t\t\t\t\ta[large] = b[i];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tans = ans + a[small] + a[large];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[i] != b[i]) i--;\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\nclass Main{\n\nstatic final PrintWriter out=new PrintWriter(System.out);\n\npublic static void main(Stirng[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString line=\"\";\nwhile((line=br.readLine())!=null&&!line.isEmpty()){\nint n=Integer.parseInt(line);\nint[] w=new int[n];\nStringTokenizer st=new StringTokenizer(br.readLine());\nfor(int i=0;i<n;i++) w[i]=Integer.parseInt(st.nextToken());\nint[] wd=w.clone();\nArrays.sort(wd);\nint ans=0;\nfor(int i=0;i<=n/2;i++){\nif(w[i]!=wd[i]) ans+=w[i]+wd[i];\n}\nout.println(ans);\n}\nout.flush();\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        int[] b = new int[n];\n        countingSort(a, b, 10000);\n        int cnt = 0;\n        for (int i = 0; i < n; i++) {\n            if (a[i] != b[i]) {\n                cnt += a[i];\n            }\n        }\n        System.out.println(cnt);\n    }\n\n    private static int countingSort(int[] a, int[] b, int k) {\n        int cnt = 0;\n        int[] c = new int[k + 1];\n        for (int i = 0; i < a.length; i++) {\n            c[a[i]]++;\n        }\n        for (int i = 1; i < c.length; i++) {\n            c[i] += c[i - 1];\n        }\n        for (int i = a.length - 1; i >= 0; i--) {\n            b[c[a[i]] - 1] = a[i];\n            c[a[i]]--;\n        }\n        return cnt;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tprivate static FastScanner sc = new FastScanner();\n\n\tpublic static void main(String[] args) {\n\t\t//??????https://www.ipsj.or.jp/07editj/promenade/4506.pdf\n\t\tint n = sc.nextInt();\n\t\t\n\t\tWeight[] w = new Weight[n];\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tw[i] = new Weight(sc.nextInt());\n\t\t}\n\t\t\n\t\tint min_all = 0;\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tint idx = i;\n\t\t\tboolean flag = false;\n\t\t\tfor(int j=0; j<n; j++) {\n\t\t\t\tif(i != j && w[i].num > w[j].num) {\n\t\t\t\t\tw[i].idx_sort++;\n\t\t\t\t\tflag = true;\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(!flag) {\n\t\t\t\tmin_all = w[idx].num;\n\t\t\t}\n\t\t\t\n//\t\t\tSystem.out.println(i + \" \" + w[i].num + \" \" + w[i].idx_sort);\n\t\t}\n\t\t\n//\t\tSystem.out.println(min_all);\n\t\t\n\t\t\n\t\tint cost = 0;\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tint min_cycle = Integer.MAX_VALUE;\n\t\t\tint sum_cycle = 0;\n\t\t\tint n_cycle = 0;\n\t\t\tint j = i;\n\t\t\t\n\t\t\tif(!w[j].flag) {\n\t\t\t\tif(w[j].idx_sort == j) {\n\t\t\t\t\tw[j].flag = true;\n\t\t\t\t} else {\n\t\t\t\t\twhile(w[j].flag == false) {\n\t\t\t\t\t\tsum_cycle += w[j].num;\n\t\t\t\t\t\tn_cycle++;\n\t\t\t\t\t\tif(w[j].num < min_cycle) {\n\t\t\t\t\t\t\tmin_cycle = w[j].num;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tw[j].flag = true;\n\t\t\t\t\t\tj = w[j].idx_sort;\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tint cost_1 = sum_cycle + (n_cycle - 2) * min_cycle;\n\t\t\t\t\tint cost_2 = sum_cycle + min_cycle + (n_cycle + 1) * min_all;\n\t\t\t\t\t\n\t\t\t\t\tcost += Math.min(cost_1, cost_2);\n\t\t\t\t\t\n//\t\t\t\t\tSystem.out.println(i + \" \" + n_cycle + \" \" + sum_cycle + \" \" + min_cycle + \" \" + cost_1 + \" \" + cost_2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(cost);\n\t}\n\t\n\tstatic class Weight {\n\t\tint num;\n\t\tboolean flag = false;\n\t\tint idx_sort = 0;\n\t\tWeight(int num) {\n\t\t\tthis.num = num;\n\t\t}\n\t}\n\n\tstatic class FastScanner {\n\t    private final InputStream in = System.in;\n\t    private final byte[] buffer = new byte[1024];\n\t    private int ptr = 0;\n\t    private int buflen = 0;\n\t    private boolean hasNextByte() {\n\t        if (ptr < buflen) {\n\t            return true;\n\t        }else{\n\t            ptr = 0;\n\t            try {\n\t                buflen = in.read(buffer);\n\t            } catch (IOException e) {\n\t                e.printStackTrace();\n\t            }\n\t            if (buflen <= 0) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\t    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\t    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t    public String next() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        StringBuilder sb = new StringBuilder();\n\t        int b = readByte();\n\t        while(isPrintableChar(b)) {\n\t            sb.appendCodePoint(b);\n\t            b = readByte();\n\t        }\n\t        return sb.toString();\n\t    }\n\t    public long nextLong() {\n\t        return Long.parseLong(next());\n\t    }\n\t    public int nextInt(){\n\t    \treturn Integer.parseInt(next());\n\t    }\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new\n\t\t// File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\ALDS1_6_A-in9.txt\"));\n\n\t\tint n = scan.nextInt();\n\t\tint[] w = new int[n];\n\t\tint[] sq = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsq[i] = i;\n\t\t\tw[i] = scan.nextInt();\n\t\t}\n\n\t\tQuickSsort(w, sq, 0, n - 1);\n\n\t\tint cost = 0;\n\t\tfor (int i = 0; i < sq.length; i++)\n\t\t\twhile (sq[i] != i) {\n\t\t\t\tint swp = sq[i];\n\t\t\t\tcost += (w[i] + w[swp]);\n\t\t\t\tsq[i] = sq[swp];\n\t\t\t\tsq[swp] = swp;\n\t\t\t}\n\n\t\tSystem.out.println(cost);\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n\n\tprivate static void QuickSsort(int[] a, int[] sq, int st, int ed) {\n\t\tif (st >= ed)\n\t\t\treturn;\n\t\tint v = Q2sort(a, sq, st, ed);\n\t\tQuickSsort(a, sq, st, v - 1);\n\t\tQuickSsort(a, sq, v + 1, ed);\n\t}\n\n\tprivate static int Q2sort(int[] a, int[] sq, int st, int ed) {\n\t\tint x = a[ed];\n\t\tint i = st - 1;\n\t\tfor (int j = st; j < ed; j++)\n\t\t\tif (a[j] <= x) {\n\t\t\t\ti++;\n\t\t\t\tint tmp = a[j];\n\t\t\t\ta[j] = a[i];\n\t\t\t\ta[i] = tmp;\n\t\t\t\ttmp = sq[j];\n\t\t\t\tsq[j] = sq[i];\n\t\t\t\tsq[i] = tmp;\n\t\t\t}\n\t\tint tmp = a[i + 1];\n\t\ta[i + 1] = a[ed];\n\t\ta[ed] = tmp;\n\t\ttmp = sq[i + 1];\n\t\tsq[i + 1] = sq[ed];\n\t\tsq[ed] = tmp;\n\n\t\treturn i + 1;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.io.IOException;\n\n// ALDS1_6_D\npublic class Main {\n\tint SENTINEL = 1234567890;\n\tvoid merge(int[]A, int left, int mid, int right) {\n\t\tint n1 = mid - left + 1;\n\t\tint n2 = right - mid;\n\t\tint[] L = new int[n1 + 1];\n\t\tint[] R = new int[n2 + 1];\n\t\tfor (int i = 0; i < n1; i++) {\n\t\t\tL[i] = A[left + i];\n\t\t}\n\t\tfor (int i = 0; i < n2; i++) {\n\t\t\tR[i] = A[mid + 1 + i];\n\t\t}\n\t\tL[n1] = SENTINEL;\n\t\tR[n2] = SENTINEL;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tfor (int k = left; k <= right; k++) {\n\t\t\tif (L[i] <= R[j]) {\n\t\t\t\tA[k] = L[i];\n\t\t\t\ti = i + 1;\n\t\t\t} else {\n\t\t\t\tA[k] = R[j];\n\t\t\t\tj = j + 1;\n\t\t\t}\n\t    }\n\t}\n\n\tvoid mergeSort(int[] A, int left, int right) {\n\t    \tif (left < right) {\n\t    \t\tint mid = (left + right)/2;\n\t    \t\tmergeSort(A, left, mid);\n\t    \t\tmergeSort(A, mid + 1, right);\n\t    \t\tmerge(A, left, mid, right);\n\t  \t}\n\t}\n\tint cost = 0;\n\tvoid run() throws IOException {\n\t\tArrayList<Integer> lis = new ArrayList<Integer>();\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] A = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlis.add(i);\n\t\t\tA[i] = sc.nextInt();\n\t\t}\n\t\tint[] B = A.clone();\n\t\tmergeSort(B, 0, n-1);\n\t\twhile (true) {\n\t\t\t// A[i] == B[i] 値の位置が正しい場合を除外\n\t\t\tArrayList<Integer> liscopy = new ArrayList<Integer>(lis);\n\t\t\tfor (Integer v : lis) {\n\t\t\t\tif (A[v] == B[v]) liscopy.remove(v);\n\t\t\t}\n\t\t\tlis = new ArrayList<Integer>(liscopy);\n\t\t\t// 基底条件\n\t\t\tif (lis.isEmpty()) break;\n\t\t\t// 交換する組を決める\n\t\t\tint minpoint = lis.get(0);\n\t\t\tfor (Integer v : lis) \n\t\t\t\tif (B[minpoint] - A[minpoint] < B[v] - A[v]) minpoint = v;\n\t\t\t// 交換先の値をtmpnum\n\t\t\tint tmppoint = -1;\n\t\t\tfor (Integer v : lis) {\n\t\t\t\tif (minpoint == v) continue;\n\t\t\t\tif (B[minpoint] == A[v]) tmppoint = v;\n\t\t\t}\n\t\t\tif (tmppoint == -1) System.out.println(\"not tmpnum\");\n\t\t\t// 相互\n\t\t\tfor (Integer v : lis) {\n\t\t\t\tif (minpoint == v) continue;\n\t\t\t\tif (B[minpoint] != B[v]) continue;\n\t\t\t\tif (A[v] == B[tmppoint]) minpoint = v;\n\t\t\t}\n\t\t\tcost += A[tmppoint] + A[minpoint];\n\t\t\tint tmp = A[tmppoint];\n\t\t\tA[tmppoint] = A[minpoint];\n\t\t\tA[minpoint] = tmp;\n\t\t}\n\t\tSystem.out.println(cost);\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main3 {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\t// ??°?????????????????¨?????????????????????????????????????????????????´????????????????????????????????????????\n\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\tint n = scanner.nextInt();\n\t\tint count = 0;\n\t\tint[] list = new int[n];\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlist[i] = scanner.nextInt();\n\t\t\t// ????°?????????????????????????????????????????°?????????????\n\t\t\tif (list[i] < min) {\n\t\t\t\tmin = list[i];\n\t\t\t}\n\t\t}\n\t\tint[] sortedList = (int[]) list.clone();\n\t\t// ???????????????????´???°???????????????????????????????????????????????????????????????????????????\n\t\tmergeSort(sortedList, 0, n);\n\t\t// ??????????????????????????¨?????????????´????????´??????????????????????\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmap.put(sortedList[i], i);\n\t\t}\n\t\tboolean flag = true;\n\t\tint time = 1;\n\t\t// ????????¨\n\t\tdo {\n\t\t\tif (min != list[0]) {\n\t\t\t\tflag = true;\n\t\t\t\tint tempIndex = 0;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (list[i] == min) {\n\t\t\t\t\t\ttempIndex = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (sortedList[tempIndex] == list[j]) {\n\t\t\t\t\t\tint temp = list[j];\n\t\t\t\t\t\t//System.out.println(\"\\n\" + temp + \"??¨\" + min + \"?????????\" + time + \"??????\");\n\t\t\t\t\t\tlist[j] = min;\n\t\t\t\t\t\tlist[tempIndex] = temp;\n\t\t\t\t\t\tcount = count + list[j] + list[tempIndex];\n\t\t\t\t\t\ttime++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (k != map.get(list[k])) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t}\n/*\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tSystem.out.print(list[i]);\n\t\t\t\t}*/\n\t\t\t} else {\n\t\t\t\tflag = true;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (i != map.get(list[i])) {\n\t\t\t\t\t\tint temp = list[i];\n\t\t\t\t\t\tint ind = map.get(list[i]);\n\t\t\t\t\t\tint temp2 = list[ind];\n\t\t\t\t\t\tlist[i] = temp2;\n\t\t\t\t\t\tlist[ind] = temp;\n\t\t\t\t\t\tcount = count + temp + temp2;\n\t\t\t\t\t\t//System.out.println(temp + \"??¨\" + temp2 + \"?????????\" + time + \"??????\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (k != map.get(list[k])) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} while (flag != true);\n\t\tSystem.out.println(count);\n\t}\n\n\t// ????¨??????????????????????????????????\n\tstatic void merge(int[] numList, int left, int mid, int right) {\n\t\tint n1 = mid - left;\n\t\tint n2 = right - mid;\n\t\tint[] L = new int[n1 + 1];\n\t\tint[] R = new int[n2 + 1];\n\n\t\tfor (int i = 0; i < n1; i++) {\n\t\t\tL[i] = numList[left + i];\n\t\t}\n\n\t\tfor (int i = 0; i < n2; i++) {\n\t\t\tR[i] = numList[mid + i];\n\t\t}\n\n\t\tL[n1] = Integer.MAX_VALUE;\n\t\tR[n2] = Integer.MAX_VALUE;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\t// L??¨R??????????????????????°????????????????numList???????´??????????\n\t\t// ?°?????????????????????????????????????????¬??????????????????????????????????????´????????????????????????°?????????+1?????????\n\t\tfor (int k = left; k < right; k++) {\n\t\t\tif (L[i] <= R[j]) {\n\t\t\t\tnumList[k] = L[i];\n\t\t\t\ti = i + 1;\n\t\t\t} else {\n\t\t\t\tnumList[k] = R[j];\n\t\t\t\tj = j + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// ????¨????merge???????????????????±??????????????°?????´???????(left)??¨?????§????´???????(right)?????????-1??????????????§??°????????????\n\tstatic void mergeSort(int[] numList, int left, int right) {\n\t\tif ((left + 1) < right) {\n\t\t\tint mid = (left + right) / 2;\n\n\t\t\tmergeSort(numList, left, mid);\n\t\t\t// System.out.println(\"???\");\n\t\t\tmergeSort(numList, mid, right);\n\t\t\t// System.out.println(\"???\");\n\t\t\tmerge(numList, left, mid, right);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate int[] a;\n\tprivate int[] b;\n\t\n\tprivate Scanner sc;\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\tint lim = Integer.parseInt(sc.nextLine());\n\t\t\n\t\ta = new int[lim];\t\t\n\t\tb = new int[lim];\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\ta[i] = Integer.parseInt(sc.next());\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tArrays.sort(b);\n\n\t\tint max = 0;\n\t\tHashMap<Integer, ArrayList<Integer[]>> iset = new HashMap<Integer, ArrayList<Integer[]>>();\n\t\tfor (int i = 0; i < lim; i++) {\n\t\t\tfor (int j = (i + 1); j < lim; j++) {\n\t\t\t\tint sum = b[i] + b[j];\n\t\t\t\tInteger[] ij = {b[i], b[j]};\n\n\t\t\t\tArrayList<Integer[]> ijlist;\n\t\t\t\tif (iset.containsKey(sum) == false) {\n\t\t\t\t\tijlist = new ArrayList<Integer[]>();\n\t\t\t\t} else {\n\t\t\t\t\tijlist = iset.get(sum);\n\t\t\t\t}\n\t\t\t\tijlist.add(ij);\n\t\t\t\t\n\t\t\t\tiset.put(sum, ijlist);\n\t\t\t\t\n\t\t\t\tif (max < sum) max = sum;\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tboolean judge = false;\n\t\tfor (int i = 0; i <= max; i++) {\n\t\t\tArrayList<Integer[]> tmp;\n\t\t\tif (iset.containsKey(i) == true) {\n\t\t\t\ttmp = iset.get(i);\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int j = 0; j < tmp.size(); j++) {\n\t\t\t\tInteger[] ij = tmp.get(j);\n\t\t\t\t\n\t\t\t\tint as = ij[0];\n\t\t\t\tint al = ij[1];\n\t\t\t\t\n\t\t\t\tint small = -1;\n\t\t\t\tint large = -1;\n\t\t\t\tfor (int k = 0; k < lim; k++) {\n\t\t\t\t\tif (a[k] == as) {\n\t\t\t\t\t\tsmall = k;\n\t\t\t\t\t} else if (a[k] == al) {\n\t\t\t\t\t\tlarge = k;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ((small != -1) && (large != -1)) break;\n\t\t\t\t}\n\n\t\t\t\tif (a[large] == b[small]) {\n\t\t\t\t\ta[large] = a[small];\n\t\t\t\t\ta[small] = b[small];\n\t\t\t\t\t\n\t\t\t\t\tans = ans + i;\n\n\t\t\t\t\ttmp.remove(j);\n\t\t\t\t\tiset.put(i, tmp);\n\t\t\t\t\ti = -1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tjudge = true;\n\t\t\t\tfor (int k = 0; k < lim; k++) {\n\t\t\t\t\tif (a[k] != b[k]) {\n\t\t\t\t\t\tjudge = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (judge) break;\n\t\t\t}\n\t\t\tif (judge) break;\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\n\nnamespace ALDS1_6_D\n{\n    class Program\n    {\n        int sum;\n\n        public Program ()\n        {\n            this.sum = 0;\n        }\n\n        public void Proc()\n        {\n            int N = int.Parse(Console.ReadLine());\n            int[] list = new int[N];\n            string[] num = Console.ReadLine().Split(' ');\n            for (int i = 0; i < N; i++)\n            {\n                list[i] = int.Parse(num[i]);\n            }\n\n            quickSort(list, 0, N - 1);\n\n            Console.WriteLine(this.sum);\n        }\n\n        static void Main(string[] args)\n        {\n            Program prg = new Program();\n            prg.Proc();\n        }\n\n        public void quickSort(int[] arr_i, int p, int r)\n        {\n            if (p < r)\n            {\n                int q = partition(arr_i, p, r);\n                quickSort(arr_i, p, q - 1);\n                quickSort(arr_i, q + 1, r);\n            }\n        }\n        public int partition(int[] arr_i, int p, int r)\n        {\n            int x = arr_i[r];\n            int i = p - 1;\n            int tmp_i = 0;\n            for (int j = p; j < r; j++)\n            {\n                if (arr_i[j] <= x)\n                {\n                    i++;\n                    tmp_i = arr_i[i];\n                    arr_i[i] = arr_i[j];\n                    arr_i[j] = tmp_i;\n                    if (i != j) this.sum += arr_i[i] + arr_i[j];\n                }\n            }\n            tmp_i = arr_i[i + 1];\n            arr_i[i + 1] = arr_i[r];\n            arr_i[r] = tmp_i;\n            if (i + 1 != r) this.sum += arr_i[i + 1] + arr_i[r];\n            return i + 1;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _20180307_AOJ\n{\n    class ALDS1_6D\n    {\n        static void Main(string[] args)\n        {\n            for (;;)\n            {\n                string line = Console.ReadLine();\n                if (string.IsNullOrEmpty(line))\n                {\n                    break;\n                }\n\n                int n = int.Parse(line);\n                int[] arr = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n                int[] sorted = arr.OrderBy(x => x).ToArray();\n                // <sorted, original>\n                Dictionary<int, int> diff = new Dictionary<int, int>();\n                for(int i=0;i<n;i++)\n                {\n                    if(sorted[i] != arr[i])\n                    {\n                        diff.Add(sorted[i], arr[i]);\n                    }\n                }\n\n                List<int> mutual = new List<int>();\n                foreach (var kvp in diff)\n                {\n                    if (diff[kvp.Value] == kvp.Key)\n                    {\n                        mutual.Add(kvp.Value);\n                    }\n                }\n\n                int cost = 0;\n                cost = mutual.Sum();\n                foreach(var v in mutual)\n                {\n                    diff.Remove(v);\n                }\n\n                while(diff.Count>1)\n                {\n                    var ordered = diff.OrderBy(x => x.Value);\n                    var min = ordered.First();\n                    var max = ordered.Last();\n\n                    cost += min.Value + max.Value;\n                    diff[max.Key] = min.Value;\n                    diff.Remove(max.Value);\n                }\n\n                Console.WriteLine(cost);\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace ALDS1_6_D\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var n = scan[0];\n            var A = scan;\n            var T = new Dictionary<int,int>();\n            var temp = A.OrderBy(i => i).ToArray();\n            for (int i = 0; i < n; i++) T[temp[i]] = i;\n            var V = new bool[n];\n            var s = A.Min();\n            var ans = 0;\n            for (int i = 0; i < n; i++)\n            {\n                if (V[i]) continue;\n                int cur = i;\n                int sum = 0;\n                int min = A[cur];\n                int an = 0;\n                while (!V[cur])\n                {\n                    V[cur] = true;\n                    an++;\n                    if (min > A[cur]) min = A[cur];\n                    sum += A[cur];\n                    cur = T[A[cur]];\n                }\n                ans += Math.Min(sum + (an - 2) * min, min + sum + (an + 1) * s);\n            }\n            Console.WriteLine(ans);\n        }\n\n        static int[] scan\n        {\n            get { return Console.ReadLine().Split().Select(int.Parse).ToArray(); }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\npublic class Test\n{\n\tpublic static void Main()\n\t{\n\t\tint n = int.Parse(Console.ReadLine());\n        int[] A = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n        \n        Dictionary<int, int> T = new Dictionary<int, int>();\n        var tmp = A.OrderBy(a => a).ToArray();\n        for(int i = 0; i < n; i++) { T[tmp[i]] = i; }\n        \n        bool[] V = new bool[n];\n        \n        int s = A.Min();\n        int result = 0;\n        \n        for (int i = 0; i < n; i++) {\n        \tif (V[i]) { continue; }\n        \t\n        \tint cur = i;\n        \tint sum = 0;\n        \tint min = A[cur];\n        \tint an = 0;\n        \t\n        \twhile(!V[cur]) {\n        \t\tV[cur] = true;\n        \t\tan++;\n        \t\t\n        \t\tif (min > A[cur]) min = A[cur];\n        \t\tsum += A[cur];\n        \t\tcur = T[A[cur]];\n        \t}\n        \tresult += Math.Min(sum + (an - 2) * min, min + sum + (an + 1) * s);\n        }\n        Console.WriteLine(result);\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\n\nnamespace aizu1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            int[] w = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            int[] k =new int[n];\n\n            k = w.Clone() as int[];\n\n            Array.Sort(k);\n\n            int cost = 0;\n            int minCost = int.MaxValue;\n\n            minCost = findMin(w,k,n,cost, ref minCost);\n\n            Console.WriteLine(minCost);\n        }\n\n        static int findMin(int[] w,int []k,int n, int cost, ref int minCost)\n        {\n            if (n ==1) minCost= minCost>cost?cost:minCost;\n\n            if(n==2)\n            {\n                int a = 0, b = 0;\n                for(int i=0;i<n;i++)\n                {\n                    if (k[i] == 0 && a == 0) a = k[i];\n                    else if (k[i] == 0) b = k[i];\n                }\n                 cost += (a > b) ? a + b : 0;\n                minCost= minCost > cost ? cost : minCost;\n            }\n\n            for(int i=k.Length-1;i>1;i--)\n            {\n                if (k[i] == 0) continue;\n                int p = findP(k[i], w);\n\n                if (p != i)\n                {\n                    int t = w[i];\n                    w[i] = w[p];\n                    w[p] = t;\n                    k[i] = 0;\n                    cost = cost + w[i] + w[p];\n                    findMin(w, k, n - 1, cost, ref minCost);\n                    t = w[i];\n                    w[i] = w[p];\n                    w[p] = t;\n                    k[i] = w[p];\n                    cost = cost - w[i] - w[p];\n                }\n                else\n                {\n                    k[i] = 0;\n                    findMin(w, k, n - 1, cost, ref minCost);\n                    k[i] = w[p];\n                }\n            }\n\n            return minCost;\n            \n        }\n\n        static int findP(int t,int [] w)\n        {\n            for (int i = 0; i < w.Length; i++)\n                if (t == w[i]) return i;\n            return 0;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "// optional\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Runtime.Serialization.Formatters.Binary;\n\npublic static class Program {\n\n    public static void Main() {\n        #region SetAutoFlushIsFalse\n#if !DEBUG\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        Console.SetOut(sw);\n#endif\n        #endregion\n\n        var n = ReadLib.ReadAsInt();\n        var arr = ReadLib.ReadAsIntArray();\n\n        var sortedArr = arr.DeepCopy();\n        Array.Sort(sortedArr);\n        var sortedInduces = sortedArr.Select((k,i) => new { k, i }).ToDictionary(a => a.k, a => a.i);\n\n        var isPassed = new BitArray(n);\n        for (int i = 0; i < n; i++) {\n            isPassed[i] = sortedArr[i] == arr[i];\n        }\n\n        int cost = 0;\n        var arrMin = arr.Min();\n\n\n        for (int i = 0; i < n; i++) {\n            if (isPassed[i]) {\n                continue;\n            }\n\n            var cycleMin = int.MaxValue;\n            var cycleSum = 0;\n            var curIdx = i;\n            var nCycleElems = 0;\n            while (true) {\n                cycleMin = Math.Min(cycleMin, arr[curIdx]);\n                cycleSum += arr[curIdx];\n                nCycleElems++;\n                isPassed[curIdx] = true;\n\n                curIdx = sortedInduces[arr[curIdx]]; // next\n\n                if (isPassed[curIdx]) {\n                    break;\n                }\n            }\n\n            var notChangeCost = (cycleSum - cycleMin) + ((nCycleElems - 1) * cycleMin);\n            var changeCost = (cycleSum - cycleMin) + (2 * (cycleMin + arrMin)) + ((nCycleElems - 1) * arrMin);\n\n            cost += Math.Min(notChangeCost, changeCost);\n        }\n\n        Console.WriteLine(cost);\n\n        #region Flush\n#if !DEBUG\n        Console.Out.Flush();\n        sw.Close();\n#endif\n        #endregion\n    }\n}\n\nstatic class ReadLib {\n    public static long ReadAsLong() {\n        return long.Parse(Console.ReadLine());\n    }\n\n    public static int ReadAsInt() {\n        return int.Parse(Console.ReadLine());\n    }\n\n    public static int[] ReadAsIntArray(int step = 0) {\n        return Console.ReadLine().Split(' ').Select(s => int.Parse(s) + step).ToArray();\n    }\n\n    public static long[] ReadAsLongArray(int step = 0) {\n        return Console.ReadLine().Split(' ').Select(s => long.Parse(s) + step).ToArray();\n    }\n\n    public static ulong[] ReadAsULongArray() {\n        return Console.ReadLine().Split(' ').Select(s => ulong.Parse(s)).ToArray();\n    }\n\n    public static string[] ReadAsStringArray() {\n        return Console.ReadLine().Split(' ');\n    }\n\n    public static int[] ReadNTimesAsInt(int n, int step = 0) {\n        return Enumerable.Range(1, n).Select(s => int.Parse(Console.ReadLine()) + step).ToArray();\n    }\n\n    public static char[][] ReadNTimesAsCharArray(int n) {\n        return Enumerable.Range(1, n).Select(i => Console.ReadLine().ToArray()).ToArray();\n    }\n\n    public static long[] ReadNTimesAsLong(int n, int step = 0) {\n        return Enumerable.Range(1, n).Select(s => long.Parse(Console.ReadLine()) + step).ToArray();\n    }\n\n    public static int[][] ReadNTimesAsIntArray(int n, int step = 0) {\n        return Enumerable.Range(1, n).Select(s => ReadAsIntArray(step)).ToArray();\n    }\n\n    public static string[] ReadNTimesAsString(int n) {\n        return Enumerable.Range(1, n).Select(s => Console.ReadLine()).ToArray();\n    }\n\n}\n\nnamespace Heaps {\n    /// <summary>優先度付きキュー</summary>\n    public class PriorityQueue<T> : IEnumerable<T>, IReadOnlyCollection<T> where T : IComparable<T> {\n        public List<T> HeapArray { get; }\n        public T NIL { get; }\n        public bool IsMax { get; }\n\n        public int Count => HeapArray.Count;\n\n        /// <param name=\"heapArray\">ヒープ</param>\n        /// <param name=\"NIL\">NILの値</param>\n        /// <param name=\"IsMax\">True時：大きい方から取り出す、False時：小さい方から取り出す</param>\n        public PriorityQueue(T NIL, IEnumerable<T> heapArray = null, bool IsMax = true) {\n            this.HeapArray = heapArray == null ? new List<T>() : heapArray.ToList();\n            this.NIL = NIL;\n            this.IsMax = IsMax;\n            Update();\n        }\n\n        /// <summary>KeyのValueを取得</summary>\n        public T this[int id] {\n            get {\n                if (id <= 0 || id > HeapArray.Count) {\n                    return NIL;\n                }\n\n                return HeapArray[id - 1];\n            }\n        }\n\n        class Node {\n            public int Key { get; }\n            public T Value => outer[Key];\n            readonly PriorityQueue<T> outer;\n\n            public Node(int key, PriorityQueue<T> outer) {\n                Key = key;\n                this.outer = outer;\n            }\n\n            public Node Left {\n                get {\n                    var leftKey = 2 * Key;\n                    return new Node(leftKey, outer);\n                }\n            }\n\n            public Node Right {\n                get {\n                    var rightkey = 2 * Key + 1;\n                    return new Node(rightkey, outer);\n                }\n            }\n\n            public Node Parent {\n                get {\n                    var parentKey = Key / 2;\n                    return new Node(parentKey, outer);\n                }\n            }\n        }\n\n        private Node GetNode(int key) {\n            return new Node(key, this);\n        }\n\n        /// <summary>max Heap木とする O(N)</summary>\n        public void Update() {\n            var n = HeapArray.Count() / 2;\n            /// <summary>葉から順に処理を行う</summary>\n            for (int i = n; i >= 1; i--) {\n                Heapify(i);\n            }\n        }\n\n        /// <summary>idを根とする部分木について、Heap木を維持したまま、idを下降させる</summary>\n        private void Heapify(int key) {\n            var current = GetNode(key);\n\n            var left = current.Left;\n            var right = current.Right;\n\n            var largest = current;\n            var sign = IsMax ? 1 : -1;\n            if (left.Value.CompareTo(NIL) != 0 && left.Value.CompareTo(current.Value) * sign > 0) {\n                largest = left;\n            }\n\n            if (right.Value.CompareTo(NIL) != 0 && right.Value.CompareTo(largest.Value) * sign > 0) {\n                largest = right;\n            }\n\n            if (largest.Key != key) {\n                HeapArray.Swap(key - 1, largest.Key - 1);   // 元と異なるときはSwapする\n                Heapify(largest.Key); // largest.Key は元のkeyの場所。葉で更にMaxHeaptyを行う。\n            }\n        }\n\n        /// <summary>keyの値を挿入する</summary>\n        public void Enqueue(T value) {\n            HeapArray.Add(value);\n\n            var inserted = GetNode(HeapArray.Count);    // 末尾に挿入\n            var parent = inserted.Parent;\n            var sign = IsMax ? 1 : -1;\n\n            // 挿入Nodeが根になる or 親 > 子になるまで親とNodeを交換\n            while (inserted.Key > 1 && value.CompareTo(parent.Value) * sign > 0) {\n                HeapArray.Swap(inserted.Key - 1, parent.Key - 1);\n                inserted = parent;\n                parent = inserted.Parent;\n            }\n        }\n\n        public T Dequeue() {\n            if (HeapArray.Count == 0) {\n                return NIL;\n            }\n\n            var popVal = HeapArray.First();\n            var newRootVal = HeapArray.Last();  // 新しい根となる。\n\n            HeapArray.RemoveAt(HeapArray.Count - 1);    // del last\n\n            if (HeapArray.Count > 0) {\n                HeapArray[0] = newRootVal;\n                Heapify(1);\n            }\n\n            return popVal;\n        }\n\n        public T Peek() {\n            return HeapArray.First();\n        }\n\n        public IEnumerator<T> GetEnumerator() {\n            while (HeapArray.Count > 0) {\n                yield return Dequeue();\n            }\n        }\n\n        IEnumerator IEnumerable.GetEnumerator() {\n            return GetEnumerator();\n        }\n\n        public void Clear() {\n            HeapArray.Clear();\n        }\n\n        public bool Contains(T val) {\n            return HeapArray.Contains(val);\n        }\n\n        public PriorityQueue<T> Clone() {\n            return new PriorityQueue<T>(NIL, HeapArray.DeepCopy());\n        }\n    }\n}\n\n/// <summary>拡張メソッドs</summary>\nstatic class MyExtention {\n    /// <summary>iとjを入れ替える</summary>\n    public static void Swap<T>(this T[] arr, int i, int j) {\n        var buf = arr[i];\n        arr[i] = arr[j];\n        arr[j] = buf;\n    }\n\n    public static void Swap<T>(this List<T> list, int i, int j) {\n        var buf = list[i];\n        list[i] = list[j];\n        list[j] = buf;\n    }\n\n    /// <summary>\n    /// partition。末尾sArr[r]を基準として、左に基準より小さい数、右に基準より大きい数が存在するように配列を並び替える。\n    /// </summary>\n    /// <param name=\"sArr\"></param>\n    /// <param name=\"p\">partitionの先頭の添字</param>\n    /// <param name=\"r\">partitionの末尾の添字</param>\n    /// <returns>partitionの基準が存在する添字</returns>\n    public static int Partition(this int[] sArr, int p, int r) {\n        var x = sArr[r];\n        var i = p - 1;\n        for (int j = p; j < r; j++) {\n            if (sArr[j] <= x) {\n                i++;\n                sArr.Swap(i, j);\n            }\n        }\n        sArr.Swap(i + 1, r);\n        return i + 1;\n    }\n\n    /// <summary>深いコピーをする</summary>\n    public static T DeepCopy<T>(this T obj) {\n        T result;\n        var b = new BinaryFormatter();\n        using (var mem = new MemoryStream()) {\n            b.Serialize(mem, obj); //  binaryFormatterによりobjをmemにserial化して書き出す\n            mem.Position = 0; // memのpotisionを先頭に戻す\n            result = (T)b.Deserialize(mem); // memの内容を読み取る。\n        }\n        return result;\n    }\n\n    public static string Left(this string str, int length) {\n        return str.Substring(0, length);\n    }\n\n    public static string Right(this string str, int length) {\n        return str.Substring(str.Length - length, length);\n    }\n\n    public static int Find<T>(this T[] array, T obj) {\n        return Array.IndexOf(array, obj);\n    }\n\n    public static int LastFind<T>(this T[] array, T obj) {\n        return Array.LastIndexOf(array, obj);\n    }\n}\n\nstatic class MyMath {\n    /// <summary>階乗</summary>\n    public static long Factorial(int n) {\n        if (n == 0) {\n            return 1;\n        }\n\n        return Permutation(n, 0);\n    }\n\n    public static long Permutation(int n, int k) {\n        return Enumerable.Range(0, n - k).Select(i => n - i).Aggregate(1, (b, i) => b * i);\n    }\n\n    #region FullPower\n    /// <summary>総乗、π</summary>\n    public static long FullPower(IEnumerable<long> vs) {\n        return vs.Aggregate(1L, (a, b) => a * b);\n    }\n\n    public static long FullPower(IEnumerable<int> vs) {\n        return vs.Aggregate(1L, (a, b) => a * b);\n    }\n    #endregion\n\n    /// <summary>最大公約数</summary>\n    public static long Gcd(long item1, long item2) {\n        var a = Math.Max(item1, item2);\n        var b = Math.Min(item1, item2);\n\n        while (true) {\n            long mod;\n            Math.DivRem(a, b, out mod);\n            if (mod == 0) {\n                break;\n            }\n\n            a = b;\n            b = mod;\n        }\n        return b;\n    }\n\n    /// <summary>約分。最大公約数で割ったものを返す。</summary>\n    public static Tuple<long, long> DeviedByGcd(long item1, long item2) {\n        var gcd = Gcd(item1, item2);\n        return new Tuple<long, long>(item1 / gcd, item2 / gcd);\n    }\n\n    public static long Lcm(int item1, int item2) {\n        return Math.BigMul(item1, item2) / Gcd(item1, item2);\n    }\n\n    public static ModCombination ModCombination(int maxN, int mod = 1000000007) {\n        return new ModCombination(maxN, mod);\n    }\n\n    /// <summary>a^n mod</summary>\n    public static int ModPow(long a, long n, int mod = 1000000007) {\n        long res = 1;\n        long pow = a;\n\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                res = (pow * res) % mod;    // resにaをかける\n            }\n\n            pow = (pow * pow) % mod;    // 次のaはa^2\n            n >>= 1;\n        }\n\n        return (int)res;\n    }\n}\n\nstatic class MyMethod {\n    /// <summary>数え上げて、key, 出現回数に変換</summary>\n    public static Dictionary<T, int> CountUp<T>(IEnumerable<T> str) {\n        return\n            str\n            .GroupBy(c => c)\n            .Select(g => new KeyValuePair<T, int>(g.Key, g.Count()))\n            .ToDictionary(e => e.Key, e => e.Value);\n    }\n\n    /// <summary>ある要素を持つindexをすべて返す</summary>\n    public static int[] InducesOfValue<T>(this T[] arr, T searchValue) {\n        return arr\n            .Select((v, i) => new { v, i })\n            .Where(o => searchValue.Equals(o.v))\n            .Select(o => o.i)\n            .ToArray();\n    }\n\n    /// <summary>ある要素を持つindexをすべて返す</summary>\n    public static int[] Induces<T>(this IEnumerable<T> arr, T searchValue) {\n        return arr.ToArray().InducesOfValue(searchValue);\n    }\n}\n\n/// <summary>組み合わせ</summary>\nclass ModCombination {\n    private int mod;\n    private int[] fac;\n    private int[] finv;\n    private int[] inv;\n\n    public ModCombination(int max, int mod = 1000000007) {\n        this.mod = mod;\n        fac = new int[max]; // modが法のn!の列\n\n        inv = new int[max]; // indexの逆元の列\n        finv = new int[max]; // modを法とした、invの累積の累積\n\n        fac[0] = 1; fac[1] = 1;\n        finv[0] = 1; finv[1] = 1;\n        inv[1] = 1;\n\n        for (int i = 2; i < max; i++) {\n            fac[i] = (int)(Math.BigMul(fac[i - 1], i) % mod);  // factorを求める\n            var s = Math.BigMul(inv[mod % i], mod / i) % mod;\n            inv[i] = (int)(mod - s);　 // iに対する逆元を求める\n            finv[i] = (int)(Math.BigMul(finv[i - 1], inv[i]) % mod);\n        }\n    }\n    /// <summary>nCk</summary>\n    public int Calculation(int n, int k) {\n        if (n < k) return 0;\n        if (n < 0 || k < 0) return 0;\n\n        return (int)(Math.BigMul(fac[n], (int)(Math.BigMul(finv[k], finv[n - k]) % mod)) % mod);\n    }\n}\n\n/// <summary>あまりを計算するためのintのラッパー</summary>\nstruct ModInt {\n    int Value { get; }\n    int Mod { get; }\n\n    public override string ToString() {\n        return Value.ToString();\n    }\n\n    public static explicit operator ModInt(long value) {\n        return new ModInt(value);\n    }\n\n    public ModInt(long value, int mod = 1000000007) {\n        this.Value = (int)(value % mod);\n        this.Mod = mod;\n    }\n\n    public static explicit operator int(ModInt modInt) {\n        return modInt.Value;\n    }\n\n    private static void CheckNotEqualMod(ModInt item1, ModInt item2) {\n        if (item1.Mod != item2.Mod) {\n            throw new Exception(\"mod not equal\");\n        }\n    }\n\n    public static ModInt operator +(ModInt item1, ModInt item2) {\n        CheckNotEqualMod(item1, item2);\n        long value = item1.Value + item2.Value;\n        return new ModInt(value, item1.Mod);\n    }\n\n    public static ModInt operator *(ModInt item1, ModInt item2) {\n        CheckNotEqualMod(item1, item2);\n        long value = Math.BigMul(item1.Value, item2.Value);\n        return new ModInt(value, item1.Mod);\n    }\n\n    public static ModInt operator -(ModInt item1, ModInt item2) {\n        CheckNotEqualMod(item1, item2);\n        long value = item1.Value - item2.Value;\n        if (value < 0) {\n            value += item1.Mod;\n        }\n        return new ModInt(value, item1.Mod);\n    }\n\n    public static ModInt operator +(ModInt item1, int item2) {\n        return item1 + new ModInt(item2, item1.Mod);\n    }\n\n    public static ModInt operator *(ModInt item1, int item2) {\n        return item1 * new ModInt(item2, item1.Mod);\n    }\n\n    public static ModInt operator -(ModInt item1, int item2) {\n        return item1 - new ModInt(item2, item1.Mod);\n    }\n\n\n    public override int GetHashCode() {\n        return this.Value;\n    }\n\n    public override bool Equals(object obj) {\n        if (obj == null || this.GetType() != obj.GetType()) {\n            return false;\n        }\n\n        var modIntObj = (ModInt)obj;\n        return modIntObj.Value == this.Value;\n    }\n\n    public static bool operator ==(ModInt item1, ModInt item2) {\n        return item1.Value == item2.Value;\n    }\n\n    public static bool operator !=(ModInt item1, ModInt item2) {\n        return !(item1 == item2);\n    }\n\n    public static bool operator ==(ModInt item1, int item2) {\n        return item1.Value == item2;\n    }\n\n    public static bool operator !=(ModInt item1, int item2) {\n        return !(item1.Value == item2);\n    }\n\n    public static bool operator >=(ModInt item1, ModInt item2) {\n        return item1.Value >= item2.Value;\n    }\n\n    public static bool operator <=(ModInt item1, ModInt item2) {\n        return item1.Value <= item2.Value;\n    }\n\n    public static bool operator >=(ModInt item1, int item2) {\n        return item1.Value >= item2;\n    }\n\n    public static bool operator <=(ModInt item1, int item2) {\n        return item1.Value <= item2;\n    }\n\n    public static bool operator >(ModInt item1, ModInt item2) {\n        return item1.Value > item2.Value;\n    }\n\n    public static bool operator <(ModInt item1, ModInt item2) {\n        return item1.Value < item2.Value;\n    }\n\n    public static bool operator >(ModInt item1, int item2) {\n        return item1.Value >= item2;\n    }\n\n    public static bool operator <(ModInt item1, int item2) {\n        return item1.Value <= item2;\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace ALDS1_6_D\n{\n    class Program\n    {\n        private static int n;\n        private static int[] W;\n        private static Tuple[] sortedW;\n        static void Main(string[] args)\n        {\n            Program.n = int.Parse(Console.ReadLine());\n            Program.W = Console.ReadLine()\n                               .Split(' ')\n                               .Select(i => int.Parse(i))\n                               .ToArray();\n            int[] tmpW = new int[n];\n\n            for (int i = 0; i < n; i++)\n            {\n                tmpW[i] = Program.W[i];\n            }\n\n            Program.sortedW = new Tuple[Program.n];\n            for (int i = 0; i < tmpW.Length; i++)\n            {\n                sortedW[i] = new Tuple(tmpW[i], i);\n            }\n\n            Program.MergeSort(0, Program.sortedW.Length - 1);\n\n            List<List<int>> grpList = new List<List<int>>();\n\n            Tuple tuple;\n            \n            for (int i = 0; i < n; i++)\n            {\n                tuple = Program.sortedW[i];\n                if (!tuple.isChecked)\n                {\n                    List<int> tmpGrp = new List<int>();\n                    tmpGrp.Add(tuple.num);\n                    tuple.isChecked = true;\n                    while (tuple.originIndx != i)\n                    {\n                        tuple = Program.sortedW[tuple.originIndx];\n                        tmpGrp.Add(tuple.num);\n                        tuple.isChecked = true;\n                    }\n                    grpList.Add(tmpGrp);\n                }\n            }\n\n            int totalWeight = 0;\n\n            foreach (List<int> list in grpList)\n            {\n                totalWeight += Math.Min((list.Count-2)*list.Min() + list.Sum()\n                                        , (list.Count+1)*Program.W.Min() + list.Sum() + list.Min());\n            }\n\n            Console.WriteLine(totalWeight);\n        }\n\n        private static void MergeSort(int leftIndx, int rightIndx)\n        {\n            if(leftIndx == rightIndx)\n            {\n                return;\n            }\n\n            int midIndx = (leftIndx + rightIndx) / 2;\n\n            Program.MergeSort(leftIndx, midIndx);\n            Program.MergeSort(midIndx + 1, rightIndx);\n            Program.Merge(leftIndx, midIndx, rightIndx);\n\n        }\n\n        private static void Merge(int leftIndx, int midIndx, int rightIndx)\n        {\n            Tuple[] tmpL = new Tuple[midIndx - leftIndx + 1];\n            Tuple[] tmpR = new Tuple[rightIndx - midIndx];\n\n            for (int i = 0; i < tmpL.Length; i++)\n            {\n                tmpL[i] = Program.sortedW[leftIndx + i];\n            }\n\n            for (int i = 0; i < tmpR.Length; i++)\n            {\n                tmpR[i] = Program.sortedW[midIndx + 1 + i];\n            }\n\n            int tmpLIndx = 0;\n            int tmpRIndx = 0;\n\n            for (int i = 0; i < rightIndx - leftIndx + 1; i++)\n            {\n                if (tmpLIndx < tmpL.Length && tmpRIndx < tmpR.Length && tmpL[tmpLIndx].IsSmaller(tmpR[tmpRIndx]) || tmpRIndx >= tmpR.Length)\n                {\n                    Program.sortedW[leftIndx + i] = tmpL[tmpLIndx];\n                    tmpLIndx++;\n                }\n                else\n                {\n                    Program.sortedW[leftIndx + i] = tmpR[tmpRIndx];\n                    tmpRIndx++;\n                }\n            }\n        }\n    }\n\n    class Tuple\n    {\n        public int num { private set; get; }\n        public int originIndx { private set; get; }\n\n        public bool isChecked = false;\n        public Tuple(int num, int originIndx)\n        {\n            this.num = num;\n            this.originIndx = originIndx;\n        }\n\n        public bool IsSmaller(Tuple target)\n        {\n            if (target == null)\n            {\n                return false;\n            }\n\n            return this.num <= target.num;\n        }\n    }\n\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_6_D {\n    public static class Problem {\n        public static int GetMinCost(this int[] source) {\n            int n = source.Length;\n            int minCost = 0;\n            \n            Dictionary<int, int> valueToIndex = Enumerable.Range(0, n)\n                .ToDictionary(i => source[i], i => i);\n            \n            Array.Sort(source);\n\n            int minValue = source[0];\n            bool[] used = new bool[n];\n            \n            for(int i = 0; i < n; i++) {\n                if (used[i])\n                    continue;\n\n                int minValueInGroup = source[i];\n                int curPosition = valueToIndex[minValueInGroup];\n                int sum = minValueInGroup;\n                int groupCount = 1;\n\n                while (curPosition != i) {\n                    used[curPosition] = true;\n                    groupCount++;\n                    int nextValue = source[curPosition];\n                    sum += nextValue;\n                    curPosition = valueToIndex[nextValue];\n                }\n                minCost += Math.Min(\n                    sum + (groupCount - 2) * minValueInGroup,\n                    sum + minValueInGroup + (groupCount + 1) * minValue);\n            }\n            return minCost;\n        }\n    }\n\n    class Program {\n        static void Main(string[] args) {\n            Console.ReadLine();\n            int[] input = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n            Console.WriteLine(input.GetMinCost());\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_6_D\n{\n    class Program\n    {\n        static int n = 0;\n        static bool[] vis = new bool[1001];\n        static void Main(string[] args)\n        {\n            Console.ReadLine();\n            var a = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse).ToList();\n            var b = new List<int>(a);\n            b.Sort();\n            for (int i = 0; i < a.Count; i++)\n            {\n                if (!vis[i])\n                {\n                    vis[i] = true;\n                    Check(a[i], i, a, b, new List<int>() { i });\n                }\n            }\n            Console.WriteLine(n);\n        }\n\n        static void Check(int target, int p, List<int> a, List<int> b, List<int> temp)\n        {\n            var pb = b.IndexOf(a[p]);\n            if (pb == p) return;\n            if (a[pb] == target)\n            {\n                var min = a[temp[0]];\n                var mini = 0;\n                for (int i = 1; i < temp.Count; i++)\n                    if (a[temp[i]] < min)\n                    {\n                        min = a[temp[i]];\n                        mini = temp[i];\n                    }\n                foreach (var i in temp)\n                {\n                    vis[i] = true;\n                    if (i != mini) n += a[i] + min;\n                }\n                return;\n            }\n            else temp.Add(pb);\n            Check(target, pb, a, b, temp);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_6_D {\n    public static class Problem {\n        public static int GetMinCost(this int[] source) {\n            int n = source.Length;\n            int minCost = 0;\n\n            int[] sorted = (int[])source.Clone();\n            Array.Sort(sorted);\n            int minValue = sorted[0];\n\n            Dictionary<int, int> valueToIndex = new Dictionary<int, int>();\n            for (int i = 0; i < n; i++)\n                valueToIndex[source[i]] = i;\n\n            bool[] used = new bool[n];\n            \n            for(int i = 0; i < n; i++) {\n                if (used[i])\n                    continue;\n\n                int minValueInGroup = sorted[i];\n                int curPosition = valueToIndex[minValueInGroup];\n                int sumOriginal = 0;\n                int sumReplace = (minValue + minValueInGroup) * 2;\n\n                while (curPosition != i) {\n                    used[curPosition] = true;\n                    int nextValue = sorted[curPosition];\n                    int nextPosition = valueToIndex[nextValue];\n                    sumOriginal += nextValue + minValueInGroup;\n                    sumReplace += nextValue + minValue;\n                    curPosition = nextPosition;\n                }\n                minCost += Math.Min(sumOriginal, sumReplace);\n            }\n            return minCost;\n        }\n    }\n\n    class Program {\n        static void Main(string[] args) {\n            Console.ReadLine();\n            int[] input = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n            Console.WriteLine(input.GetMinCost());\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\n\nnamespace aizu1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            int[] w = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            int max = w.Max();\n            int[] k =new int[n];\n\n            k = w.Clone() as int[];\n\n            Array.Sort(k);\n\n            int cost = 0;\n            int minCost = int.MaxValue;\n\n            minCost = findMin(w,k,n,cost, ref minCost);\n\n            Console.WriteLine(minCost);\n        }\n\n        static int findMin(int[] w,int []k,int n, int cost, ref int minCost)\n        {\n            if (n ==1) minCost= minCost>cost?cost:minCost;\n\n            if(n==2)\n            {\n                int a = 0, b = 0;\n                for(int i=0;i<n;i++)\n                {\n                    if (k[i] == 0 && a == 0) a = k[i];\n                    else if (k[i] == 0) b = k[i];\n                }\n                 cost += (a > b) ? a + b : 0;\n                minCost= minCost > cost ? cost : minCost;\n            }\n\n            for(int i=k.Length-1;i>1;i--)\n            {\n                if (k[i] == 0) continue;\n                int p = findP(k[i], w);\n\n                if (p != i)\n                {\n                    int t = w[i];\n                    w[i] = w[p];\n                    w[p] = t;\n                    k[i] = 0;\n                    cost = cost + w[i] + w[p];\n                    findMin(w, k, n - 1, cost, ref minCost);\n                    t = w[i];\n                    w[i] = w[p];\n                    w[p] = t;\n                    k[i] = w[p];\n                    cost = cost - w[i] - w[p];\n                }\n                else\n                {\n                    k[i] = 0;\n                    findMin(w, k, n - 1, cost, ref minCost);\n                    k[i] = w[p];\n                }\n            }\n\n            return minCost;\n            \n        }\n\n        static int findP(int t,int [] w)\n        {\n            for (int i = 0; i < w.Length; i++)\n                if (t == w[i]) return i;\n            return 0;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\nclass Program{\n    static void Swap(int[] A, int a, int b){\n        var tmp=A[a];\n        A[a]=A[b];\n        A[b]=tmp;\n    }\n\n    public static void Main(){\n        var n=int.Parse(Console.ReadLine());\n        var s=Console.ReadLine().Split(' ');\n        var ws=new int[n];\n        var positions=new int[10001];\n        for(var i=0; i<positions.Length; i++){\n            positions[i]=-1;\n        }\n        for(var i=0; i<n; i++){\n            ws[i]=int.Parse(s[i]);\n            positions[ws[i]]=i;\n        }\n\n        var result=0;\n        var acc=0;\n        for(var i=positions.Length-1; i>=0; i--){\n            if(positions[i]!=-1){\n                acc++;\n                if(ws[n-acc]!=i){\n                    Swap(ws, n-acc, positions[i]);\n                    result+=(ws[n-acc]+ws[positions[i]]);\n                }\n            }\n        }\n\n        Console.WriteLine(result);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\n\nnamespace aizu1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            int[] w = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            int[] k =new int[n];\n\n            k = w.Clone() as int[];\n\n            Array.Sort(k);\n\n            int cost = 0;\n            int minCost = int.MaxValue;\n\n            minCost = findMin(w,k,n,cost, ref minCost);\n\n            Console.WriteLine(minCost);\n        }\n\n        static int findMin(int[] w,int []k,int n, int cost, ref int minCost)\n        {\n            if (n ==1) minCost= minCost>cost?cost:minCost;\n\n            if(n==2)\n            {\n                int a = 0, b = 0;\n                for(int i=0;i<k.Length;i++)\n                {\n                    if (k[i] != 0 && a == 0) a = k[i];\n                    else if (k[i] != 0) b = k[i];\n\n                }\n                int aP = findP(a, w);\n                int bP = findP(b, w);\n                cost += (aP > bP) ? a + b : 0;\n                minCost= minCost > cost ? cost : minCost;\n                cost -= (aP > bP) ? a + b : 0;\n            }\n\n            for(int i=k.Length-1;i>=1;i--)\n            {\n                if (k[i] == 0) continue;\n                int p = findP(k[i], w);\n\n                if (p != i)\n                {\n                    int t = w[i];\n                    w[i] = w[p];\n                    w[p] = t;\n                    k[i] = 0;\n                    cost = cost + w[i] + w[p];\n                    findMin(w, k, n - 1, cost, ref minCost);\n                    t = w[i];\n                    w[i] = w[p];\n                    w[p] = t;\n                    k[i] = w[p];\n                    cost = cost - w[i] - w[p];\n                }\n                else\n                {\n                    k[i] = 0;\n                    findMin(w, k, n - 1, cost, ref minCost);\n                    k[i] = w[p];\n                }\n            }\n\n            return minCost;\n            \n        }\n\n        static int findP(int t,int [] w)\n        {\n            for (int i = 0; i < w.Length; i++)\n                if (t == w[i]) return i;\n            return 0;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_6_D\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var n = scan[0];\n            var A = scan;\n            var T = new Dictionary<int,int>();\n            var temp = A.OrderBy(i => i).ToArray();\n            for (int i = 0; i < n; i++) T[temp[i]] = i;\n            var V = new bool[n];\n            var s = A.Min();\n            var ans = 0;\n            for (int i = 0; i < n; i++)\n            {\n                if (V[i]) continue;\n                int cur = i;\n                int sum = 0;\n                int min = A[cur];\n                int an = 0;\n                while (!V[cur])\n                {\n                    V[cur] = true;\n                    an++;\n                    if (min > A[cur]) min = A[cur];\n                    sum += A[cur];\n                    cur = T[A[cur]];\n                }\n                ans += Math.Min(sum + (an - 2) * min, min + sum + (an + 1) * s);\n            }\n            Console.WriteLine(ans);\n        }\n\n        static int[] scan\n        {\n            get { return Console.ReadLine().Split().Select(int.Parse).ToArray(); }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            int[] A = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n            Dictionary<int, int> T = new Dictionary<int, int>();\n            var temp = A.OrderBy(a => a).ToArray();\n            for (int i = 0; i < n; i++) T[temp[i]] = i;\n\n            bool[] V = new bool[n];\n\n            int s = A.Min();\n            int result = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                if (V[i]) continue;\n\n                int cur = i;\n                int sum = 0;\n                int min = A[cur];\n                int an = 0;\n\n                while (!V[cur])\n                {\n                    V[cur] = true;\n                    an++;\n\n                    if (min > A[cur]) min = A[cur];\n                    sum += A[cur];\n                    cur = T[A[cur]];\n                }\n                result += Math.Min(sum + (an - 2) * min, min + sum + (an + 1) * s);\n            }\n            Console.WriteLine(result);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _20180307_AOJ\n{\n    class ALDS1_6D\n    {\n        static void Main(string[] args)\n        {\n            for (;;)\n            {\n                string line = Console.ReadLine();\n                if (string.IsNullOrEmpty(line))\n                {\n                    break;\n                }\n\n                int n = int.Parse(line);\n                int[] arr = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n                int[] sorted = new int[n];\n                arr.CopyTo(sorted, 0);\n                Array.Sort(sorted);\n                Dictionary<int, int> dict = new Dictionary<int, int>();\n                for(int i=0;i<n;i++)\n                {\n                    dict.Add(sorted[i], arr[i]);\n                }\n\n                List<List<int>> cyclics = new List<List<int>>();\n                while(dict.Count>0)\n                {\n                    List<int> list = new List<int>();\n                    var kvp = dict.FirstOrDefault();\n                    while(dict.ContainsKey(kvp.Key))\n                    {\n                        list.Add(kvp.Key);\n                        dict.Remove(kvp.Key);\n                        kvp = dict.FirstOrDefault(x=>x.Key == kvp.Value);\n                    }\n\n                    cyclics.Add(list);\n                }\n\n                int min = arr.Min();\n                long sum = 0;\n                foreach(var v in cyclics)\n                {\n                    long sum1 = SingleSum(v);\n                    long sum2 = SumWithX(v, min);\n                    sum += Math.Min(sum1, sum2);\n                }\n\n                Console.WriteLine(sum);\n            }\n        }\n\n        static long SingleSum(List<int> list)\n        {\n            int min = list.Min();\n            int len = list.Count;\n            long sum = (len - 2) * min + list.Sum();\n            return sum;\n        }\n\n        static long SumWithX(List<int> list, int x)\n        {\n            int len = list.Count;\n            long sum = (len + 1) * x + list.Sum() + list.Min();\n            return sum;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\n\nclass Program{\n    static void Swap(int[] A, int a, int b){\n        var tmp=A[a];\n        A[a]=A[b];\n        A[b]=tmp;\n    }\n\n    static void CountingSort(int[] A, int[] B, int k){\n        var C=new int[k+1];\n        for(var j=0; j<A.Length; j++){\n            C[A[j]]++;\n        }\n        var remain=B.Length-1;\n        for(; k>=0; k--){\n            while(C[k]>0){\n                B[remain]=k;\n                remain--;\n                C[k]--;\n            }\n        }\n    }\n\n    public static void Main(){\n        var n=int.Parse(Console.ReadLine());\n        var s=Console.ReadLine().Split(' ');\n        var ws=new int[n];\n        var positions=new int[10001];\n        for(var i=0; i<positions.Length; i++){\n            positions[i]=-1;\n        }\n        var max=0;\n        for(var i=0; i<n; i++){\n            ws[i]=int.Parse(s[i]);\n            positions[ws[i]]=i;\n            if(ws[i]>max){\n                max=ws[i];\n            }\n        }\n\n        var wsSorted=new int[n];\n        CountingSort(ws, wsSorted,max);\n        var result=0;\n        for(var i=0; i<positions.Length; i++){\n            while (positions[i]!=-1) {\n                var srcIdx=positions[i];\n                var dstIdx=positions[wsSorted[srcIdx]];\n                if(srcIdx==dstIdx){\n                    positions[i]=-1;\n                } else{\n                    positions[wsSorted[srcIdx]]=-1;\n                    Swap(ws, srcIdx, dstIdx);\n                    result+=(ws[srcIdx]+ws[dstIdx]);\n                    positions[i]=dstIdx;\n                }\n            }\n        }\n\n        Console.WriteLine(result);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            int[] A = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            bool[] V = new bool[n];\n\n            int s = A[0], result = 0;\n\n            Dictionary<int, int> T = new Dictionary<int, int>();\n            var temp = A.OrderBy(a => a).ToArray();\n            for (int i = 0; i < n; i++)\n            {\n                if (s > A[i]) s = A[i];\n                T[temp[i]] = i;\n            }\n            \n            for (int i = 0; i < n; i++)\n            {\n                if (V[i]) continue;\n\n                int cur = i, sum = 0;\n                int min = A[cur], an = 0;\n\n                while (!V[cur])\n                {\n                    V[cur] = true;\n                    an++;\n\n                    if (min > A[cur]) min = A[cur];\n                    sum += A[cur];\n                    cur = T[A[cur]];\n                }\n                result += Math.Min(sum + (an - 2) * min, min + sum + (an + 1) * s);\n            }\n            Console.WriteLine(result);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\nclass Program{\n    static void Swap(int[] A, int a, int b){\n        var tmp=A[a];\n        A[a]=A[b];\n        A[b]=tmp;\n    }\n\n    static void CountingSort(int[] A, int[] B, int k){\n        var C=new int[k+1];\n        for(var j=0; j<A.Length; j++){\n            C[A[j]]++;\n        }\n        var remain=B.Length-1;\n        for(; k>=0; k--){\n            while(C[k]>0){\n                B[remain]=k;\n                remain--;\n                C[k]--;\n            }\n        }\n    }\n\n    public static void Main(){\n        var n=int.Parse(Console.ReadLine());\n        var s=Console.ReadLine().Split(' ');\n        var ws=new int[n];\n        var positions=new int[10001];\n        for(var i=0; i<positions.Length; i++){\n            positions[i]=-1;\n        }\n        var max=0;\n        for(var i=0; i<n; i++){\n            ws[i]=int.Parse(s[i]);\n            positions[ws[i]]=i;\n            if(ws[i]>max){\n                max=ws[i];\n            }\n        }\n\n        var wsSorted=new int[n];\n        CountingSort(ws, wsSorted,max);\n        var result=0;\n        for(var i=0; i<positions.Length; i++){\n            while (positions[i]!=-1) {\n                var srcIdx=positions[i];\n                var dstIdx=positions[wsSorted[srcIdx]];\n                if(srcIdx==dstIdx){\n                    positions[i]=-1;\n                } else{\n                    positions[wsSorted[srcIdx]]=-1;\n                    Swap(ws, srcIdx, dstIdx);\n                    result+=(ws[srcIdx]+ws[dstIdx]);\n                    positions[i]=dstIdx;\n                }\n            }\n        }\n\n        Console.WriteLine(result);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_6_D {\n    public static class Problem {\n        public static int GetMinCost(this int[] source) {\n            int n = source.Length;\n            int minCost = 0;\n            bool[] used = new bool[n];\n\n            int[] sorted = (int[])source.Clone();\n            Array.Sort(sorted);\n            int minValue = sorted[0];\n\n            Dictionary<int, int> valueToIndex = Enumerable.Range(0, n)\n                .ToDictionary(i => source[i], i => i);\n            \n            for(int i = 0; i < n; i++) {\n                if (used[i] || valueToIndex[sorted[i]] == i)\n                    continue;\n\n                int minValueInGroup = sorted[i];\n                int curPosition = valueToIndex[minValueInGroup];\n                int sumOriginal = 0;\n                int sumReplace = (minValue + minValueInGroup) * 2;\n\n                while (curPosition != i) {\n                    used[curPosition] = true;\n                    int nextValue = sorted[curPosition];\n                    sumOriginal += nextValue + minValueInGroup;\n                    sumReplace += nextValue + minValue;\n                    curPosition = valueToIndex[nextValue];\n                }\n                minCost += Math.Min(sumOriginal, sumReplace);\n            }\n            return minCost;\n        }\n    }\n\n    class Program {\n        static void Main(string[] args) {\n            Console.ReadLine();\n            int[] input = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n            Console.WriteLine(input.GetMinCost());\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass Program\n{\n\n    public void Proc()\n    {\n        this.Num = int.Parse(Console.ReadLine());\n        this.NumS = VMAX;\n\n        string[] inpt = Console.ReadLine().Split(' ');\n        for(int i=0; i<this.Num;i++) {\n            this.ArrA[i] = int.Parse(inpt[i]);\n            this.NumS = Math.Min(this.NumS, this.ArrA[i]);\n        }\n        int ans = this.Solve();\n        Console.WriteLine(ans);\n    }\n\n    private const int MAX = 1000;\n    private const int VMAX = 10000;\n\n    private int[] ArrA = new int[MAX];\n    private int[] ArrB = new int[MAX];\n    private int[] ArrT = new int[VMAX + 1];\n    private int Num = 0;\n    private int NumS = 0;\n\n    private int Solve()\n    {\n        int ans = 0;\n\n        bool[] arrV = new bool[MAX];\n        this.ArrB = new int[this.Num];\n        for(int i=0; i<this.Num; i++) {\n            this.ArrB[i] = this.ArrA[i];\n            arrV[i] = false;\n        }\n        Array.Sort(this.ArrB);\n        for(int i=0; i<this.Num; i++) {\n            this.ArrT[this.ArrB[i]] = i;\n        }\n        for(int i=0; i<this.Num; i++) {\n            if(arrV[i]) {\n                continue;\n            }\n            int cur = i;\n            int S = 0;\n            int m = VMAX;\n            int an = 0;\n            while(true) {\n                arrV[cur] = true;\n                an++;\n                int v = this.ArrA[cur];\n                m = Math.Min(m, v);\n                S += v;\n                cur = this.ArrT[v];\n                if (arrV[cur])\n                {\n                    break;\n                }\n            }\n            ans += Math.Min(S + (an - 2) * m, m + S + (an + 1) * this.NumS);\n        }\n        return ans;\n    }\n\n\n    static void Main(string[] args)\n    {\n        Program prg = new Program();\n        prg.Proc();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\n\nnamespace aizu1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            int[] w = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n            int cost = 0;\n\n            cost = findMin(w,n,cost);\n\n            Console.WriteLine(cost);\n        }\n\n        static int findMin(int[] w, int n, int cost)\n        {\n            if (n ==1) return cost;\n\n            int m=0,p=0;\n            max(w, n,out m, out p);\n\n            if(w[n-1]!=m)\n            {\n                int t = w[n - 1];\n                w[n - 1] = m;\n                w[p] = t;\n                cost += (w[n - 1] + w[p]);\n            }\n\n            return findMin(w, n-1, cost);\n            \n        }\n\n        static void max(int[]w, int n, out int m, out int p)\n        {\n            m = w[0];\n            p = 0;\n            for(int i=1;i<n;i++)\n            {\n                p = (m >= w[i] ? p : i);\n                m =( m >= w[i] ? m : w[i]);\n               \n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_6_D {\n    public static class Problem {\n        public static int GetMinCost(this int[] source) {\n            int n = source.Length;\n            int minCost = 0;\n            \n            Dictionary<int, int> valueToIndex = Enumerable.Range(0, n)\n                .ToDictionary(i => source[i], i => i);\n            \n            Array.Sort(source);\n\n            int minValue = source[0];\n            bool[] used = new bool[n];\n            \n            for(int i = 0; i < n; i++) {\n                if (used[i])\n                    continue;\n\n                int minValueInGroup = source[i];\n                int curPosition = valueToIndex[minValueInGroup];\n                int sumOriginal = 0;\n                int sumReplace = (minValue + minValueInGroup) * 2;\n\n                while (curPosition != i) {\n                    used[curPosition] = true;\n                    int nextValue = source[curPosition];\n                    sumOriginal += nextValue + minValueInGroup;\n                    sumReplace += nextValue + minValue;\n                    curPosition = valueToIndex[nextValue];\n                }\n                minCost += Math.Min(sumOriginal, sumReplace);\n            }\n            return minCost;\n        }\n    }\n\n    class Program {\n        static void Main(string[] args) {\n            Console.ReadLine();\n            int[] input = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n            Console.WriteLine(input.GetMinCost());\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_6_D\n{\n    class Program\n    {\n        static int MIN;\n        static int n = 0;\n        static bool[] vis = new bool[1001];\n        static void Main(string[] args)\n        {\n            Console.ReadLine();\n            var a = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse).ToList();\n            var b = new List<int>(a);\n            b.Sort();\n            MIN = b[0];\n            for (int i = 0; i < a.Count; i++)\n            {\n                if (!vis[i])\n                {\n                    vis[i] = true;\n                    Check(a[i], i, a, b, new List<int>() { i });\n                }\n            }\n            Console.WriteLine(n);\n        }\n\n        static void Check(int target, int p, List<int> a, List<int> b, List<int> temp)\n        {\n            var pb = b.IndexOf(a[p]);\n            if (pb == p) return;\n            if (a[pb] == target)\n            {\n                var min = a[temp[0]];\n                var mini = 0;\n                for (int i = 1; i < temp.Count; i++)\n                    if (a[temp[i]] < min)\n                    {\n                        min = a[temp[i]];\n                        mini = temp[i];\n                    }\n                int sum = 0;\n                foreach (var i in temp)\n                {\n                    vis[i] = true;\n                    if (i != mini) sum += a[i] + min;\n                }\n                int sum2 = 0;\n                foreach (var i in temp)\n                {\n                    sum2 += a[i] + MIN;\n                }\n                sum2 += min + MIN;\n                n += sum < sum2 ? sum : sum2;\n                return;\n            }\n            else temp.Add(pb);\n            Check(target, pb, a, b, temp);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_6_D {\n    public static class Problem {\n        public static int GetMinCost(this int[] source) {\n            int n = source.Length;\n            int minCost = 0;\n            bool[] used = new bool[n];\n\n            int[] sorted = (int[])source.Clone();\n            Array.Sort(sorted);\n            int minValue = sorted[0];\n\n            Dictionary<int, int> valueToIndex = Enumerable.Range(0, n)\n                .ToDictionary(i => source[i], i => i);\n            \n            for(int i = 0; i < n; i++) {\n                if (used[i])\n                    continue;\n\n                int minValueInGroup = sorted[i];\n                int curPosition = valueToIndex[minValueInGroup];\n                int sumOriginal = 0;\n                int sumReplace = (minValue + minValueInGroup) * 2;\n\n                while (curPosition != i) {\n                    used[curPosition] = true;\n                    int nextValue = sorted[curPosition];\n                    sumOriginal += nextValue + minValueInGroup;\n                    sumReplace += nextValue + minValue;\n                    curPosition = valueToIndex[nextValue];\n                }\n                minCost += Math.Min(sumOriginal, sumReplace);\n            }\n            return minCost;\n        }\n    }\n\n    class Program {\n        static void Main(string[] args) {\n            Console.ReadLine();\n            int[] input = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n            Console.WriteLine(input.GetMinCost());\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _20180307_AOJ\n{\n    class ALDS1_6D\n    {\n        static void Main(string[] args)\n        {\n            for (;;)\n            {\n                string line = Console.ReadLine();\n                if (string.IsNullOrEmpty(line))\n                {\n                    break;\n                }\n\n                int n = int.Parse(line);\n                int[] arr = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n                int[] sorted = new int[n];\n                arr.CopyTo(sorted, 0);\n                Array.Sort(sorted);\n                Dictionary<int, int> dict = new Dictionary<int, int>();\n                for(int i=0;i<n;i++)\n                {\n                    dict.Add(sorted[i], arr[i]);\n                }\n\n                List<List<int>> cyclics = new List<List<int>>();\n                while(dict.Count>0)\n                {\n                    List<int> list = new List<int>();\n                    var kvp = dict.FirstOrDefault();\n                    while(dict.ContainsKey(kvp.Key))\n                    {\n                        list.Add(kvp.Key);\n                        dict.Remove(kvp.Key);\n                        kvp = dict.FirstOrDefault(x=>x.Key == kvp.Value);\n                    }\n\n                    cyclics.Add(list);\n                }\n\n                int min = arr.Min();\n                long sum = 0;\n                foreach(var v in cyclics)\n                {\n                    long sum1 = SingleSum(v);\n                    long sum2 = SumWithX(v, min);\n                    sum += Math.Min(sum1, sum2);\n                }\n\n                Console.WriteLine(sum);\n            }\n        }\n\n        static long SingleSum(List<int> list)\n        {\n            int min = list.Min();\n            int len = list.Count;\n            long sum = (len - 2) * min + list.Sum();\n            return sum;\n        }\n\n        static long SumWithX(List<int> list, int x)\n        {\n            int min = x;\n            int len = list.Count;\n            long sum = len * min + list.Sum() + list.Min();\n            return sum;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\n\nnamespace ALDS1_6_D\n{\n    public static class Sort\n    {\n        public delegate void SwapperAction<T>(ref T a, ref T b);\n        public static void SelectionSort<T>(this T[] a, SwapperAction<T> swapper, bool desc = false) where T : IComparable\n        {\n            int n = a.Length;\n            if (!desc)\n            {\n                for (int i = 0; i < n; ++i)\n                {\n                    int t = i;\n                    for (int j = i + 1; j < n; ++j)\n                    {\n                        if (a[t].CompareTo(a[j]) > 0) t = j;\n                    }\n                    if (i != t) swapper.Invoke(ref a[i], ref a[t]);\n                }\n            }\n            else\n            {\n                for (int i = 0; i < n; ++i)\n                {\n                    int t = i;\n                    for (int j = i + 1; j < n; ++j)\n                    {\n                        if (a[t].CompareTo(a[j]) < 0) t = j;\n                    }\n                    if (i != t) swapper.Invoke(ref a[i], ref a[t]);\n                }\n            }\n        }\n    }\n    class Program\n    {\n        static int n = 0;\n        static void Main(string[] args)\n        {\n            Console.ReadLine();\n            var a = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            var b = a.Reverse().ToArray();\n            b.SelectionSort(Swapper,true);\n            Console.WriteLine(n);\n        }\n\n        static void Swapper(ref int a, ref int b)\n        {\n            if (a != b)\n            {\n                a ^= b;\n                b ^= a;\n                a ^= b;\n            }\n            n += a + b;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Sort_II\n{\n    class Minimum_Cost_Sort\n    {\n        static void Main(string[] args)\n        {\n            Console.ReadLine();\n            var A = Console.ReadLine().Split(' ').Select(s => int.Parse(s)).ToArray();\n            var B = (int[])A.Clone();\n            var p = 0;\n            var r = B.Length - 1;\n           \n            QuickSort(B, p, r);\n\n            var cost = MinimumCost(A,B);\n\n            Console.WriteLine(cost);\n        }\n\n        static public int MinimumCost(int[] A,int[] sorted)\n        {\n            var min = 10001;\n            var done = new bool[A.Length];\n            var cycl = new Dictionary<int, int>();\n            for (int i = 0; i < A.Length; i++)\n            {\n                cycl.Add(sorted[i],i);\n                if (A[i] < min) min = A[i];\n            }\n\n            var cost = 0;\n\n            for (int i = 0; i < A.Length; i++)\n            {\n                if (done[i]) continue;\n                var index = i;\n                var c = 0;\n                var lmin = 10001;\n                var sum = 0;\n                while (true)\n                {\n                    if (done[index]) break;\n                    c++;\n                    done[index] = true;\n                    if (A[index] < lmin) lmin = A[index];\n                    sum += A[index];\n                    index = cycl[A[index]];\n                }\n                var temp = sum - lmin * 2 + lmin * c;\n                var alt = sum + lmin + min + min * c;\n                if (alt < temp) cost += alt;\n                else cost += temp;\n            }\n\n            return cost;\n        }\n\n        static public void QuickSort(int[] A, int p, int r)\n        {\n            if (p < r)\n            {\n                var q = Partition(A, p, r);\n                QuickSort(A, p, q - 1);\n                QuickSort(A, q + 1, r);\n            }\n        }\n\n        static public int Partition(int[] A, int p, int r)\n        {\n            var x = A[r];\n            var i = p - 1;\n            for (int j = p; j < r; j++)\n                if (A[j] <= x)\n                {\n                    i++;\n                    var temp = A[i];\n                    A[i] = A[j];\n                    A[j] = temp;\n                }\n            var tmp = A[i + 1];\n            A[i + 1] = A[r];\n            A[r] = tmp;\n\n            return i + 1;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ConsoleApp1\n{\n    class Program\n    {\n        public static void Main()\n        {\n            int n = int.Parse(Console.ReadLine());\n            int[] A = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            var dict = new Dictionary<int, int>();\n            var temp = A.OrderBy(x => x).ToArray();\n            for (int i = 0; i < n; i++) dict[temp[i]] = i;\n            bool[] visted = new bool[n];\n            int s = temp[0];\n            int result = 0;\n            for (int i = 0; i < n; i++) {\n                if (visted[i]) continue;\n                int cur = i, sum = 0, min = A[i], an = 0;\n                while (!visted[cur])\n                {\n                    visted[cur] = true;\n                    an++;\n\n                    if (min > A[cur]) min = A[cur];\n                    sum += A[cur];\n                    cur = dict[A[cur]];\n                }\n                result += Math.Min(sum + (an - 2) * min, min + sum + (an + 1) * s);\n            }\n            Console.WriteLine(result);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _20180307_AOJ\n{\n    class ALDS1_6D\n    {\n        static void Main(string[] args)\n        {\n            for (;;)\n            {\n                string line = Console.ReadLine();\n                if (string.IsNullOrEmpty(line))\n                {\n                    break;\n                }\n\n                int n = int.Parse(line);\n                int[] arr = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n                int[] sorted = arr.OrderBy(x => x).ToArray();\n                // <sorted, original>\n                Dictionary<int, int> diff = new Dictionary<int, int>();\n                for(int i=0;i<n;i++)\n                {\n                    if(sorted[i] != arr[i])\n                    {\n                        diff.Add(sorted[i], arr[i]);\n                    }\n                }\n\n                int cost = 0;\n\n                List<int> mutual = new List<int>();\n                foreach (var kvp in diff)\n                {\n                    if (diff[kvp.Value] == kvp.Key)\n                    {\n                        mutual.Add(kvp.Value);\n                    }\n                }\n\n                cost = mutual.Sum();\n                foreach (var v in mutual)\n                {\n                    diff.Remove(v);\n                }\n\n                while (diff.Count>1)\n                {\n                    var ordered = diff.OrderBy(x => x.Value);\n                    var min = ordered.First();\n                    var second = diff.First(x=>x.Value == min.Key);\n\n                    cost += min.Value + second.Value;\n                    if (diff[second.Key] == min.Value)\n                    {\n                        diff.Remove(second.Key);\n                    }\n                    else\n                    {\n                        diff[second.Key] = min.Value;\n                    }\n                    diff.Remove(second.Value);\n                }\n\n                Console.WriteLine(cost);\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _20180307_AOJ\n{\n    class ALDS1_6D\n    {\n        static void Main(string[] args)\n        {\n            for (;;)\n            {\n                string line = Console.ReadLine();\n                if (string.IsNullOrEmpty(line))\n                {\n                    break;\n                }\n\n                int n = int.Parse(line);\n                int[] arr = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n                int[] sorted = arr.OrderBy(x => x).ToArray();\n                // <sorted, original>\n                Dictionary<int, int> diff = new Dictionary<int, int>();\n                for(int i=0;i<n;i++)\n                {\n                    if(sorted[i] != arr[i])\n                    {\n                        diff.Add(sorted[i], arr[i]);\n                    }\n                }\n\n                int cost = 0;\n\n                List<int> mutual = new List<int>();\n                foreach (var kvp in diff)\n                {\n                    if (diff[kvp.Value] == kvp.Key)\n                    {\n                        mutual.Add(kvp.Value);\n                    }\n                }\n\n                cost = mutual.Sum();\n                foreach (var v in mutual)\n                {\n                    diff.Remove(v);\n                }\n\n                while (diff.Count>1)\n                {\n                    var ordered = diff.OrderBy(x => x.Value);\n                    var min = ordered.First();\n                    var second = diff.First(x=>x.Value == min.Key);\n\n                    cost += min.Value + second.Value;\n                    if (second.Key == min.Value)\n                    {\n                        diff.Remove(second.Key);\n                    }\n                    else\n                    {\n                        diff[second.Key] = min.Value;\n                    }\n                    diff.Remove(second.Value);\n                }\n\n                Console.WriteLine(cost);\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace ConsoleApplication1\n{    \n\n    class Program\n    {\n        const int Inf = int.MaxValue;\n\n        static void Solve(int first)\n        {\n            int cnt = 0;\n            int u = first;\n            int v = 0;\n            int s = 0;\n            int m = Inf;             \n\n            while (true)\n            {\n                V[u] = true;\n                v = A[u];              \n                cnt++;\n                s += v;\n                u = T[v];\n                m = Math.Min(m, v);\n                \n                if (V[u])\n                {                    \n                    break;\n                }\n            }          \n            ans += Math.Min(s + (cnt - 2) * m, s + m + (cnt + 1) * x);          \n        }\n\n        static int[] T; \n        static bool[] V;\n        static int[] B;\n        static int[] A; \n        static int ans;\n        static int x;\n        \n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            A = new int[n];\n            B = new int[n];\n            V = new bool[n];\n            int maxindex = 0;\n            x = Inf;\n\n            string[] input = Console.ReadLine().Split(' ');\n\n            int a = 0;\n            for(int i = 0; i < n; i++)\n            {\n                a = int.Parse(input[i]);\n                A[i] = a;\n                B[i] = a;\n                V[i] = false; \n                if(maxindex < a)\n                {\n                    maxindex = a;\n                }\n                if(x > a)\n                {\n                    x = a;\n                }\n            }\n\n            T = new int[maxindex + 1];\n\n            Array.Sort(B);\n           \n            for(int i = 0; i < n; i++)\n            {\n                T[B[i]] = i;\n            }\n\n            \n            ans = 0;\n            for (int i = 0; i < n; i++)\n            {\n                if (!V[i])\n                {\n                    Solve(i);\n                }           \n            }\n\n            Console.WriteLine(ans);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\n\nnamespace Sort_II\n{\n    class Minimum_Cost_Sort\n    {\n        static int[] sortindex;\n\n        static void Main(string[] args)\n        {\n            Console.ReadLine();\n            var A = Console.ReadLine().Split(' ').Select(s => int.Parse(s)).ToArray();\n            var B = (int[])A.Clone();\n            var p = 0;\n            var r = B.Length - 1;\n            sortindex = new int[B.Length];\n            for (int i = 0; i < sortindex.Length; i++)\n                sortindex[i] = i;\n\n            QuickSort(B, p, r);\n\n            var cost = MinimumCost(A, B);\n\n            Console.WriteLine(cost);\n        }\n\n        static public int MinimumCost(int[] A, int[] sorted)\n        {\n            var c = 0;\n            var minIndex = -1;\n            var min = 10000;\n            for (int i = 0; i < A.Length; i++)\n            {\n                if (A[i] == sorted[i]) continue;\n                else\n                {\n                    var j = sortindex[i];\n                    if (A[i] == sorted[j])\n                    {\n                        c += A[i] + A[j];\n                        var temp = A[i];\n                        A[i] = A[j];\n                        A[j] = temp;\n                        i = 0;\n                    }\n                    else if (A[i] <=min) minIndex = i;\n                }\n            }\n            while (minIndex != -1)\n            {\n                c += A[minIndex] + A[sortindex[minIndex]];\n                var temp = A[minIndex];\n                A[minIndex] = A[sortindex[minIndex]];\n                A[sortindex[minIndex]] = temp;\n\n                minIndex = -1;\n\n                for (int i = 0; i < A.Length; i++)\n                {\n                    if (i == sortindex[i]) continue;\n                    if (A[i] <= min) minIndex = i;\n                }\n            }\n\n            return c;\n        }\n\n        static public void QuickSort(int[] A, int p, int r)\n        {\n            if (p < r)\n            {\n                var q = Partition(A, p, r);\n                QuickSort(A, p, q - 1);\n                QuickSort(A, q + 1, r);\n            }\n        }\n\n        static public int Partition(int[] A, int p, int r)\n        {\n            var x = A[r];\n            var i = p - 1;\n            for (int j = p; j < r; j++)\n                if (A[j] <= x)\n                {\n                    i++;\n                    var temp = A[i];\n                    A[i] = A[j];\n                    A[j] = temp;\n                    sortindex[i] = j;\n                    sortindex[j] = i;\n                }\n            var tmp = A[i + 1];\n            A[i + 1] = A[r];\n            A[r] = tmp;\n            sortindex[i + 1] = r;\n            sortindex[r] = i + 1;\n\n            return i + 1;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "let quick_sort a n cmp =\n  let swap i j = let tmp = a.(i) in a.(i) <- a.(j); a.(j) <- tmp in\n  let partition p r =\n    let i = ref p in\n    for j = p to r - 1 do\n      if cmp a.(j) a.(r) <= 0 then (swap !i j; incr i)\n    done;\n    swap !i r;\n    !i in\n  let rec doit p r =\n    if p >= r then () else\n    let q = partition p r in\n    doit p (q - 1);\n    doit (q + 1) r in\n  doit 0 (n - 1)\n\nlet calc_cost a n =\n  let b = Array.copy a in\n  quick_sort b n compare;\n  let t = Array.make (b.(n-1) + 1) 0 in\n  Array.iteri (fun i e -> t.(e) <- i) b;\n  let p = Array.make n false in\n  let rec cycle i acc =\n    p.(i) <- true;\n    let j = t.(a.(i)) in\n    if p.(j) then a.(i) :: acc\n    else cycle j (a.(i) :: acc) in\n  let cycle i = cycle i [] in\n  let rec doit i acc =\n    if i = n then acc\n    else if p.(i) then doit (i + 1) acc\n    else\n      let ws = cycle i in\n      let m = List.length ws in\n      let s = List.fold_left (+) 0 ws in\n      let z = List.fold_left min max_int ws in\n      doit (i + 1) (acc + (min (s + (m - 2)*z) (s + z + (m + 1)*b.(0)))) in\n  doit 0 0\n\nlet () =\n  let n = read_int () in\n  let a = Array.init n (fun _ -> Scanf.scanf \"%d \" (fun e -> e)) in\n  calc_cost a n |> Printf.printf \"%d\\n\"\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing static System.Console;\nusing System.Text;\nusing System.IO;\n\nnamespace AOJ\n{\n    class Program\n    {\n        static public long[] Sarray() { return ReadLine().Split().Select(long.Parse).ToArray(); }\n        static public List<long> Slist() { return ReadLine().Split().Select(long.Parse).ToList(); }\n\n        struct pair\n        {\n            public long k;\n            public long v;\n            public pair(long K, long V) { k = K; v = V; }\n        }\n        static void Main(string[] args)\n        {\n            var N = Sarray()[0];\n            var Ai = Sarray();\n            var As = new List<pair>();\n            for (var i = 0; i < N; ++i)\n            {\n                var p = new pair(i, Ai[i]);\n                As.Add(p);\n            }\n            As.Sort((l, r) => (int)(l.v - r.v));\n\n            var v = new bool[N];\n            var cst = 0L;\n            for (var i = 0L; i < N; ++i)\n            {\n                if (v[i]) continue;\n                var j = i;\n                var sum = 0L;\n                var cnt = 0L;\n                do\n                {\n                    ++cnt;\n                    sum += As[(int)j].v;\n                    v[j] = true;\n                    j = As[(int)j].k;\n                }\n                while (i != j);\n                if (1 < cnt)\n                    cst += sum + Math.Min((cnt - 2) * As[(int)i].v, As[(int)i].v + (cnt + 1) * As[0].v);\n            }\n            WriteLine(cst);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            int[] A = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            \n            Dictionary<int, int> T = new Dictionary<int, int>();\n            var temp = A.OrderBy(a => a).ToArray();\n            for (int i = 0; i < n; i++) T[temp[i]] = i;\n\n            bool[] V = new bool[n];\n\n            int s = A.Min();\n            int result = 0;\n\n            for(int i = 0; i < n; i++)\n            {\n                if (V[i]) continue;\n\n                int cur = i;\n                int sum = 0;\n                int min = int.MaxValue;\n                int an = 0;\n\n                while (true)\n                {\n                    V[cur] = true;\n                    an++;\n\n                    if (min > A[cur]) min = A[cur];\n                    sum += A[cur];\n                    cur = T[A[cur]];\n\n                    if (V[cur]) break;\n                }\n                result += Math.Min(sum + (an - 2) * min, min + sum + (an + 1) * s);\n            }\n            Console.WriteLine(result);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\n\nnamespace ALDS1_6_D\n{\n    public static class Sort\n    {\n        public delegate void SwapperAction<T>(ref T a, ref T b);\n        public static void SelectionSort<T>(this T[] a, SwapperAction<T> swapper, bool desc = false) where T : IComparable\n        {\n            int n = a.Length;\n            if (!desc)\n            {\n                for (int i = 0; i < n; ++i)\n                {\n                    int t = i;\n                    for (int j = i + 1; j < n; ++j)\n                    {\n                        if (a[t].CompareTo(a[j]) > 0) t = j;\n                    }\n                    if (i != t) swapper.Invoke(ref a[i], ref a[t]);\n                }\n            }\n            else\n            {\n                for (int i = 0; i < n; ++i)\n                {\n                    int t = i;\n                    for (int j = i + 1; j < n; ++j)\n                    {\n                        if (a[t].CompareTo(a[j]) < 0) t = j;\n                    }\n                    if (i != t) swapper.Invoke(ref a[i], ref a[t]);\n                }\n            }\n        }\n    }\n    class Program\n    {\n        static int n = 0;\n        static void Main(string[] args)\n        {\n            Console.ReadLine();\n            var a = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            var b = a.Reverse().ToArray();\n            b.SelectionSort(Swapper,true);\n            Console.WriteLine(n);\n        }\n\n        static void Swapper(ref int a, ref int b)\n        {\n            if (a != b)\n            {\n                a ^= b;\n                b ^= a;\n                a ^= b;\n            }\n            n += a + b;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_6_D {\n    public static class Problem {\n        public static int GetMinCost(this int[] source) {\n            int n = source.Length;\n            int minCost = 0;\n\n            int[] sorted = (int[])source.Clone();\n            Array.Sort(sorted);\n            int minValue = sorted[0];\n\n            Dictionary<int, int> valueToIndex = new Dictionary<int, int>();\n            for (int i = 0; i < n; i++)\n                valueToIndex[source[i]] = i;\n\n            bool[] used = new bool[n];\n            \n            for(int i = 0; i < n; i++) {\n                if (used[i])\n                    continue;\n\n                int minValueInGroup = sorted[i];\n                int curPosition = valueToIndex[minValueInGroup];\n                int sumOriginal = 0;\n                int sumReplace = (minValue + minValueInGroup) * 2;\n\n                while (curPosition != i) {\n                    used[curPosition] = true;\n                    int nextValue = sorted[curPosition];\n                    sumOriginal += nextValue + minValueInGroup;\n                    sumReplace += nextValue + minValue;\n                    curPosition = valueToIndex[nextValue];\n                }\n                minCost += Math.Min(sumOriginal, sumReplace);\n            }\n            return minCost;\n        }\n    }\n\n    class Program {\n        static void Main(string[] args) {\n            Console.ReadLine();\n            int[] input = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n            Console.WriteLine(input.GetMinCost());\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\nclass Program{\n    static void Swap(int[] A, int a, int b){\n        var tmp=A[a];\n        A[a]=A[b];\n        A[b]=tmp;\n    }\n\n    static void CountingSort(int[] A, int[] B, int k){\n        var C=new int[k+1];\n        for(var j=0; j<A.Length; j++){\n            C[A[j]]++;\n        }\n        var remain=B.Length-1;\n        for(; k>=0; k--){\n            while(C[k]>0){\n                B[remain]=k;\n                remain--;\n                C[k]--;\n            }\n        }\n    }\n\n    public static void Main(){\n        var n=int.Parse(Console.ReadLine());\n        var s=Console.ReadLine().Split(' ');\n        var ws=new int[n];\n        var positions=new int[10001];\n        for(var i=0; i<positions.Length; i++){\n            positions[i]=-1;\n        }\n        var max=0;\n        for(var i=0; i<n; i++){\n            ws[i]=int.Parse(s[i]);\n            positions[ws[i]]=i;\n            if(ws[i]>max){\n                max=ws[i];\n            }\n        }\n\n        var wsSorted=new int[n];\n        CountingSort(ws, wsSorted,max);\n        var result=0;\n        for(var i=0; i<positions.Length; i++){\n            while (positions[i]!=-1) {\n                var srcIdx=positions[i];\n                var dstIdx=positions[wsSorted[srcIdx]];\n                if(srcIdx==dstIdx){\n                    positions[i]=-1;\n                } else{\n                    positions[wsSorted[srcIdx]]=-1;\n                    Swap(ws, srcIdx, dstIdx);\n                    result+=(ws[srcIdx]+ws[dstIdx]);\n                    positions[i]=dstIdx;\n                }\n            }\n        }\n\n        Console.WriteLine(result);\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ALDS1_6_D {\n    public static class Problem {\n        public static int GetMinCost(this int[] source) {\n            int n = source.Length;\n            int minCost = 0;\n\n            int[] sorted = (int[])source.Clone();\n            Array.Sort(sorted);\n            int minValue = sorted[0];\n\n            Dictionary<int, int> valueToIndex = new Dictionary<int, int>();\n            for (int i = 0; i < n; i++)\n                valueToIndex[source[i]] = i;\n\n            bool[] used = new bool[n];\n            \n            for(int i = 0; i < n; i++) {\n                if (used[i])\n                    continue;\n\n                int minValueInGroup = sorted[i];\n                int curPosition = valueToIndex[minValueInGroup];\n                int sumOriginal = 0;\n                int sumReplace = (minValue + minValueInGroup) * 2;\n\n                while (curPosition != i) {\n                    used[curPosition] = true;\n                    int nextValue = sorted[curPosition];\n                    int nextPosition = valueToIndex[nextValue];\n                    sumOriginal += nextValue + minValueInGroup;\n                    sumReplace += nextValue + minValue;\n                    curPosition = nextPosition;\n                }\n                minCost += Math.Min(sumOriginal, sumReplace);\n            }\n            return minCost;\n        }\n    }\n\n    class Program {\n        static void Main(string[] args) {\n            int n = int.Parse(Console.ReadLine());\n            int[] input = Console.ReadLine().Split(' ').Select(int.Parse).ToArray();\n            Console.WriteLine(input.GetMinCost());\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\n\nnamespace aizu1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            int[] w = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            int[] k =new int[n];\n\n            k = w.Clone() as int[];\n\n            Array.Sort(k);\n\n            int cost = 0;\n            int minCost = int.MaxValue;\n\n            minCost = findMin(w,k,n,cost, ref minCost);\n\n            Console.WriteLine(minCost);\n        }\n\n        static int findMin(int[] w,int []k,int n, int cost, ref int minCost)\n        {\n            if (n ==1) minCost= minCost>cost?cost:minCost;\n\n            if(n==2)\n            {\n                int a = 0, b = 0;\n                for(int i=0;i<k.Length;i++)\n                {\n                    if (k[i] != -1 && a == 0) a = k[i];\n                    else if (k[i] != -1) b = k[i];\n\n                }\n                int aP = findP(a, w);\n                int bP = findP(b, w);\n                cost += (aP > bP) ? a + b : 0;\n                minCost= minCost > cost ? cost : minCost;\n                cost -= (aP > bP) ? a + b : 0;\n            }\n\n            for(int i=k.Length-1;i>=1;i--)\n            {\n                if (k[i] == -1) continue;\n                int p = findP(k[i], w);\n\n                if (p != i)\n                {\n                    int t = w[i];\n                    w[i] = w[p];\n                    w[p] = t;\n                    k[i] = -1;\n                    cost = cost + w[i] + w[p];\n                    findMin(w, k, n - 1, cost, ref minCost);\n                    t = w[i];\n                    w[i] = w[p];\n                    w[p] = t;\n                    k[i] = w[p];\n                    cost = cost - w[i] - w[p];\n                }\n                else\n                {\n                    k[i] = -1;\n                    findMin(w, k, n - 1, cost, ref minCost);\n                    k[i] = w[p];\n                }\n            }\n\n            return minCost;\n            \n        }\n\n        static int findP(int t,int [] w)\n        {\n            for (int i = 0; i < w.Length; i++)\n                if (t == w[i]) return i;\n            return 0;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ALDS1_6_D\n{\n    public class Program\n\n    {\n        public static void Main(string[] args)\n        {\n            int n = ReadInt();\n            int[] line = ReadIntAr();\n            Console.WriteLine(SillySort(line).ToString());\n        }\n\n        public struct node { public int value; public int place; }\n        public static int SillySort(int[] seq)\n        {\n\n            int cost = 0, s;\n            node[] nodes = new node[seq.Count()];\n            node[] tmp = new node[seq.Count()];\n\n            for (int i = 0 ; i < seq.Count() ; i++) { tmp[i].value = seq[i]; tmp[i].place = i; }\n            tmp = tmp.OrderBy(x => x.value).ToArray<node>();\n            for (int i = 0 ; i < seq.Count() ; i++) { nodes[i].value = seq[i]; nodes[tmp[i].place].place = i; }\n            s = tmp[0].value;\n\n            for (int i = 0 ; i < seq.Count() ; i++)\n            {\n                int j = nodes[i].place;\n                if (j >= 0 && j != i)\n                {\n                    int n = 1, sum, amin;\n                    amin = sum = nodes[i].value;\n                    while (j != i)\n                    {\n                        int next = nodes[j].place;\n                        amin = Math.Min(amin, nodes[j].value);\n                        sum += nodes[j].value;\n                        n++;\n                        nodes[j].place = -1;\n                        j = next;\n                    }\n                    cost += Math.Min(sum + ((n - 2) * amin), sum + amin + (n + 1) * s);\n                }\n            }\n\n            return cost;\n        }\n\n\n        static string ReadSt() { return Console.ReadLine(); }\n        static int ReadInt() { return int.Parse(Console.ReadLine()); }\n        static long ReadLong() { return long.Parse(Console.ReadLine()); }\n        static double ReadDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] ReadStAr(char sep = ' ') { return Console.ReadLine().Split(sep); }\n        static int[] ReadIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => int.Parse(e)); }\n        static long[] ReadLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => long.Parse(e)); }\n        static double[] ReadDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => double.Parse(e)); }\n\n    }\n\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "function createAlignedBaggage(baggage) {\n    const aligned = [];\n    baggage.forEach(e => aligned[e] = e);\n    return aligned.filter(e => e !== undefined);\n}\n\nfunction minimumCostSort(baggage, len, cost, aligned) {\n    let min = aligned[len - 1];\n    let total = 0;\n    let count = 0;\n\n    for (let i = 0; i < len; i++) {\n        if (baggage[i] !== aligned[i]) {\n            total += baggage[i];\n            count++;\n            min = baggage[i] < min ? baggage[i] : min;\n        }\n    }\n\n    const isChangeMin = total + min * count > aligned[0] * (count + 2) + min * 2 + total;\n\n    if(baggage[0] === aligned[0] && isChangeMin){\n        const index = baggage.indexOf(min);\n        baggage[index] = baggage[0]; // 最小値を現在のminの位置に移動\n        baggage[0] = min; // minを一時的に0の位置に移動\n        cost[0] += min + baggage[index];\n        min = baggage[index];\n    }\n\n    if(count) {\n        const index = baggage.indexOf(min);\n        // minの現在地に本来あるべき要素\n        const target = baggage.indexOf(aligned[index]);\n        const temp = baggage[target];\n        baggage[target] = min;\n        baggage[index] = temp;\n        cost[0] += min + temp;\n        minimumCostSort(baggage, len, cost, aligned);\n    }\n}\n\nfunction main(stdin) {\n    const input = stdin.split(\"\\n\");\n    const length = parseInt(input.shift(), 10);\n    const baggage = input[0].split(' ').map((e) => parseInt(e, 10));\n    const cost = [0];\n    const aligned = createAlignedBaggage(baggage);\n\n    minimumCostSort(baggage, length, cost, aligned);\n    console.log(cost[0]);\n}\n\nmain(require(\"fs\").readFileSync(\"/dev/stdin\", \"utf8\"));\n\n"
  },
  {
    "language": "JavaScript",
    "code": "//config = { input: 'tmp', newline: '\\r\\n' }; // win\nconfig = { input: '/dev/stdin', newline: '\\n' }; // linux\n\nline = require('fs').readFileSync(config.input, 'ascii')\n  .split(config.newline, 2);\n\nw = line[1].split(' ').map(Number);\n\nsorted = [].concat(w);\nsorted.sort(function (a, b) { return a - b; });\n\ncost = 0;\nfor (i = w.length - 1; i >= 0; i--) {\n  idx = w.indexOf(sorted[i]);\n  if (idx === i) continue;\n  cost += w[i] + w[idx];\n  tmp = w[i];\n  w[i] = w[idx];\n  w[idx] = tmp;\n}\n\nconsole.log(cost);"
  },
  {
    "language": "JavaScript",
    "code": "let inputString = '';\n\nprocess.stdin.on('data', inputStdin => {\n    inputString += inputStdin;\n});\nprocess.stdin.on('end', function() {\n    const input = inputString.replace(/\\s*$/, '')\n        .split('\\n')\n        .map(str => str.replace(/\\s*$/, ''));\n\n    const nums = input[1].split(' ').map(s => Number(s));\n\n    console.log(minCost(nums));\n});\n\nconst MAX = 1000; // Max length of the array\nconst VMAX = 10000; // Max volume of the stuff\n\nconst minCost = (arr) => {\n  let answer = 0;\n\n  const minimumWeightInAll = Math.min(...arr);\n  const sorted = [...arr].sort((a, b) => a - b);\n  const isUsedInLoops = new Array(arr.length).fill(false);\n  \n  const weightSortedIndexMap = new Array(VMAX + 1);\n  for (let i=0; i<sorted.length; i++) {\n    weightSortedIndexMap[sorted[i]] = i;\n  }\n\n  for (let i=0; i<arr.length; i++) {\n    if (isUsedInLoops[i]) {\n      continue;\n    }\n\n    let currentIndex = i;\n    let sumWeightInLoop = 0;\n    let minimumWeightInLoop = VMAX; // will be the base of swappings\n    let elementNumInCurrentLoop = 0;\n    while (true) {\n      isUsedInLoops[currentIndex] = true;\n      elementNumInCurrentLoop++;\n      const v = arr[currentIndex];\n\n      minimumWeightInLoop = Math.min(minimumWeightInLoop, v);\n\n      sumWeightInLoop += v;\n\n      currentIndex = weightSortedIndexMap[v];\n      if (isUsedInLoops[currentIndex]) {\n        break;\n      }\n    }\n    // swapping only in the loop\n    const costInLoop = sumWeightInLoop + (elementNumInCurrentLoop - 2) * minimumWeightInLoop;\n    // swapping with the num out of the loop\n    const costWithNumOutOfLoop = sumWeightInLoop + minimumWeightInLoop  + (elementNumInCurrentLoop + 1) * minimumWeightInAll;\n    answer += Math.min(costInLoop, costWithNumOutOfLoop);\n  }\n\n  return answer;\n};\n"
  },
  {
    "language": "JavaScript",
    "code": "function createAlignedBaggage(baggage) {\n    const aligned = [];\n    baggage.forEach(e => aligned[e] = e);\n    return aligned.filter(e => e !== undefined);\n}\n\nfunction minimumCostSort(baggage, len, cost, aligned) {\n    let min = aligned[len - 1];\n    let count = 0;\n\n    for (let i = 0; i < len; i++) {\n        if (baggage[i] !== aligned[i]) {\n            count++;\n            min = baggage[i] < min ? baggage[i] : min;\n        }\n    }\n\n    if(baggage[0] === aligned[0] && count > 2){\n        const index = baggage.indexOf(min);\n        baggage[index] = baggage[0]; // 最小値を現在のminの位置に移動\n        baggage[0] = min; // minを一時的に0の位置に移動\n        cost[0] += min + baggage[index];\n        min = baggage[index];\n    }\n\n    if(count) {\n        const index = baggage.indexOf(min);\n        // minの現在地に本来あるべき要素\n        const target = baggage.indexOf(aligned[index]);\n        const temp = baggage[target];\n        baggage[target] = min;\n        baggage[index] = temp;\n        cost[0] += min + temp;\n        minimumCostSort(baggage, len, cost, aligned);\n    }\n}\n\nfunction main(stdin) {\n    const input = stdin.split(\"\\n\");\n    const length = parseInt(input.shift(), 10);\n    const baggage = input[0].split(' ').map((e) => parseInt(e, 10));\n    const cost = [0];\n    const aligned = createAlignedBaggage(baggage);\n\n    minimumCostSort(baggage, length, cost, aligned);\n    console.log(cost[0]);\n}\n\nmain(require(\"fs\").readFileSync(\"/dev/stdin\", \"utf8\"));\n\n"
  },
  {
    "language": "JavaScript",
    "code": "function solve(arr, len) {\n    let ans = 0;\n    const V = [];\n    const sorted = [];\n    const mapTable = [];\n    const min = Math.min(...arr);\n\n    for (let i = 0; i < len; i++) {\n        sorted[i] = arr[i];\n        V[i] = false;\n    }\n\n    sorted.sort((a, b) => a - b);\n\n    for (let i = 0; i < len; i++) {\n        mapTable[sorted[i]] = i;\n    }\n    for (let i = 0; i < len; i++) {\n        if (V[i]) continue;\n        let cur = i;\n        let s = 0;\n        let m = 10000;\n        let an = 0;\n        while (1) {\n            V[cur] = true;\n            an++;\n            let v = arr[cur];\n            m = Math.min(m, v);\n            s += v;\n            cur = mapTable[v];\n            if (V[cur]) break;\n        }\n        ans += Math.min(s + (an - 2) * m, m + s + (an + 1) * min);\n    }\n\n    return ans;\n}\n\n\nfunction main(_stdin) {\n    const stdin = _stdin.split('\\n');\n    const len = parseInt(stdin.shift(), 10);\n    const seq = stdin.shift().split(' ').map(e => parseInt(e, 10));\n\n    const ans = solve(seq, len);\n    console.log(ans);\n}\n\n\nmain(require('fs').readFileSync('/dev/stdin', 'utf8'));\n\n"
  },
  {
    "language": "JavaScript",
    "code": "function createAlignedBaggage(baggage) {\n    const aligned = [];\n    baggage.forEach(e => aligned[e] = e);\n    return aligned.filter(e => e !== undefined);\n}\n\nfunction minimumCostSort(baggage, len, cost, aligned) {\n    let min = aligned[len - 1];\n\n    for (let i = 0; i < len; i++) {\n        if (i !== aligned.indexOf(baggage[i]) && baggage[i] < min) {\n            min = baggage[i];\n        }\n    }\n\n    if(baggage[0] === 0 && min !== aligned[len - 1]){\n        baggage[baggage.indexOf(min)] = 0;\n        baggage[0] = min;\n        cost[0] += min;\n        minimumCostSort(baggage, len, cost, aligned);\n    }\n\n    if(min !== aligned[len - 1]) {\n        const index = baggage.indexOf(min);\n        // minの現在地に本来あるべき要素\n        const target = baggage.indexOf(aligned[index]);\n        const temp = baggage[target];\n        baggage[target] = min;\n        baggage[index] = temp;\n        cost[0] += min + temp;\n        minimumCostSort(baggage, len, cost, aligned);\n    }\n}\n\nfunction main(stdin) {\n    const input = stdin.split(\"\\n\");\n    const length = parseInt(input.shift(), 10);\n    const baggage = input[0].split(' ').map((e) => parseInt(e, 10));\n    const cost = [0];\n    const aligned = createAlignedBaggage(baggage);\n\n    minimumCostSort(baggage, length, cost, aligned);\n    console.log(cost[0]);\n}\n\nmain(require(\"fs\").readFileSync(\"/dev/stdin\", \"utf8\"));\n\n"
  },
  {
    "language": "JavaScript",
    "code": "function createAlignedBaggage(baggage) {\n    const aligned = [];\n    baggage.forEach(e => aligned[e] = e);\n    return aligned.filter(e => e !== undefined);\n}\n\nfunction minimumCostSort(baggage, len, cost, aligned) {\n    let min = aligned[len - 1];\n    let count = 0;\n\n    for (let i = 0; i < len; i++) {\n        if (baggage[i] !== aligned[i]) {\n            count++;\n            min = baggage[i] < min ? baggage[i] : min;\n        }\n    }\n\n    if(baggage[0] === 0 && count > 2){\n        baggage[baggage.indexOf(min)] = 0;\n        baggage[0] = min;\n        cost[0] += min;\n        min = 0;\n    }\n\n    if(count) {\n        const index = baggage.indexOf(min);\n        // minの現在地に本来あるべき要素\n        const target = baggage.indexOf(aligned[index]);\n        const temp = baggage[target];\n        baggage[target] = min;\n        baggage[index] = temp;\n        cost[0] += min + temp;\n        minimumCostSort(baggage, len, cost, aligned);\n    }\n}\n\nfunction main(stdin) {\n    const input = stdin.split(\"\\n\");\n    const length = parseInt(input.shift(), 10);\n    const baggage = input[0].split(' ').map((e) => parseInt(e, 10));\n    const cost = [0];\n    const aligned = createAlignedBaggage(baggage);\n\n    minimumCostSort(baggage, length, cost, aligned);\n    console.log(cost[0]);\n}\n\nmain(require(\"fs\").readFileSync(\"/dev/stdin\", \"utf8\"));\n\n"
  },
  {
    "language": "JavaScript",
    "code": "let quick_sort a n cmp =\n  let swap i j = let tmp = a.(i) in a.(i) <- a.(j); a.(j) <- tmp in\n  let partition p r =\n    let i = ref p in\n    for j = p to r - 1 do\n      if cmp a.(j) a.(r) <= 0 then (swap !i j; incr i)\n    done;\n    swap !i r;\n    !i in\n  let rec doit p r =\n    if p >= r then () else\n    let q = partition p r in\n    doit p (q - 1);\n    doit (q + 1) r in\n  doit 0 (n - 1)\n\nlet calc_cost a n =\n  let b = Array.copy a in\n  quick_sort b n compare;\n  let t = Array.make (b.(n-1) + 1) 0 in\n  Array.iteri (fun i e -> t.(e) <- i) b;\n  let p = Array.make n false in\n  let rec cycle i acc =\n    p.(i) <- true;\n    let j = t.(a.(i)) in\n    if p.(j) then a.(i) :: acc\n    else cycle j (a.(i) :: acc) in\n  let cycle i = cycle i [] in\n  let rec doit i acc =\n    if i = n then acc\n    else if p.(i) then doit (i + 1) acc\n    else\n      let ws = cycle i in\n      let m = List.length ws in\n      let s = List.fold_left (+) 0 ws in\n      let z = List.fold_left min max_int ws in\n      doit (i + 1) (acc + (min (s + (m - 2)*z) (s + z + (m + 1)*b.(0)))) in\n  doit 0 0\n\nlet () =\n  let n = read_int () in\n  let a = Array.init n (fun _ -> Scanf.scanf \"%d \" (fun e -> e)) in\n  calc_cost a n |> Printf.printf \"%d\\n\"\n"
  },
  {
    "language": "JavaScript",
    "code": "fs = require(\"fs\");\n\nbuf = fs.readFileSync('/dev/stdin').toString();\nlines = buf.split('\\n');\nw = lines[1].split(' ').map(Number);\n\nsorted = [].concat(w).sort((a, b) => { return a - b; });\n\nindeces = w.map((x) => { return sorted.indexOf(x); });\n\ngroups = (() => {\n    let done = new Array(w.length); // undefined or true\n    let res = [];\n    for (let i = 0; i < w.length; ++i) {\n        if (done[i]) continue;\n        let g = [];\n        let j = i;\n        while (!done[j]) {\n            done[j] = true;\n            g.push(w[j]);\n            j = indeces[j];\n        }\n        res.push(g);\n    }\n    return res;\n})();\n\ngroups = groups\n    .filter((g) => { return g.length >= 2; })\n    .map((g) => { return g.sort((a, b) => { return a - b; }); });\n\nfunction sum(ary) { return ary.reduce((a, b) => { return a + b; }, 0); }\n\nfunction calc_cost(group, min) {\n    let min1 = sum(group.slice(1)) + group[0] * (group.length - 1);\n    let min2 = sum(group) + group[0] + min * (group.length + 1);\n    //console.log(\"group.slice(1) = \", group.slice(1));\n    //console.log(\"min1 = \", min1, \", min2 = \", min2);\n    return Math.min(min1, min2);\n}\n\ncost = sum(groups.map((g) => { return calc_cost(g, sorted[0]); }));\n\n//console.log(w);\n//console.log(sorted);\n//console.log(indeces);\n//console.log(groups);\nconsole.log(cost);\n"
  },
  {
    "language": "JavaScript",
    "code": "var n;\n\nfunction CS(a,b,k){\n    var c = new Array(k + 1);\n    for(var i = 0;i <= k;i++)\n        c[i] = 0;\n    for(var j = 0;j < n;j++)\n        c[a[j]]++;\n    for(var i = 1;i <= k;i++)\n        c[i] += c[i - 1];\n    for(var j = 0;j < n;j++)\n        b[-1 + c[a[j]]--] = a[j];\n}\n\nfunction Main(input){\n    input = input.split(\"\\n\");\n    n = parseInt(input[0],10);\n    var w = new Array(n),s = new Array(n);\n    input[1] = input[1].split(\" \");\n    for(var i = 0;i < n;i++)\n        w[i] = parseInt(input[1][i],10);\n\n    CS(w,s,10000);\n\n    var sum = 0,pl = new Array(n),pl2 = new Array(n);\n\n    for(var i = 0;i < n;i++)\n        sum += (w[i] == s[i]);\n    for(var i = 0;i < n;i++)\n        for(var j = 0;j < n;j++)\n            if(w[i] == s[j]){\n                pl[i] = j;\n                pl2[j] = i;\n            }\n\n    var ex,ans = 0;;\n    for(var i = 0;i < n;i++)\n        if(pl[pl[i]] == i && pl[i] != i){\n            sum += 2;\n            ans += w[i] + w[pl[i]];\n            ex = w[i];\n            w[i] = w[pl[i]];\n            w[pl[i]] = ex;\n            ex = pl2[i];\n            pl2[i] = pl2[pl[i]];\n            pl2[ex] = ex;\n            ex = pl[i];\n            pl[i] = pl[pl[i]];\n            pl[ex] = ex;\n        }\n\n\n    while(sum < n){\n        var min = 1000000,mini;\n        for(var i = 0;i < n;i++)\n            if(min > w[i] && pl[i] != i){\n                min = w[i];mini = i;\n            }\n\n        while(pl[mini] != mini){\n            ans += w[mini] + w[pl2[mini]];\n            ex = w[mini];\n            w[mini] = w[pl2[mini]];\n            w[pl2[mini]] = ex;\n            ex = pl[mini];\n            pl[mini] = pl[pl2[mini]];\n            pl[pl2[mini]] = ex;\n            ex = pl2[mini];\n            pl2[pl[pl2[mini]]] = pl2[mini];\n            pl2[mini] = mini;\n            mini = ex;\n            sum++;\n            //console.log(w  + \"   \" + pl + \"   \" + pl2 +  \"    \" + mini);break;\n            //console.log(w + \"  \" + pl + \" \" + pl2 + \"  \" + mini);\n        }\n        sum++;\n    }\n\n    console.log(ans);\n}\n\nMain(require(\"fs\").readFileSync(\"/dev/stdin\",\"utf8\"));"
  },
  {
    "language": "Ruby",
    "code": "gets\nw=gets.split.map.with_index{|l,i|[l.to_i,i]}\nx=w.sort_by{|l|l[0]}\nx.map.with_index{|l,i|w[w.index l]<<i}\nc=0\nw.map{|l|_,a,b=l\na==b&&next\nq=*a\n(_,a,b=w.find{|k|b==k[1]}\nq<<a)while q[0]!=b\ns=q.map{|r|w[r][2]=r\nw[r][0]}\nt=s.reduce:+\nc+=[t+s[-1]+x[0][0]*z=-~s.size,t+s[-1]*(z-3)].min}\np c"
  },
  {
    "language": "Ruby",
    "code": "n = gets.chomp.to_i\narr = gets.chomp.split.map(&:to_i)\nt = []\nn.times do |i|\n  t << arr.shift\nend\n\n# swap????????????\ndef swap(list, idx1, idx2)\n  list[idx1], list[idx2] = list[idx2], list[idx1]\n  return list\nend\n\ndef minCostPath(list)\n  sorted = list.sort\n  total = 0\n  \n  # list?????????\n  list.size.times do |i|\n    # ???????????????????????????????????????????????£?????????\n    idx1 =sorted[i]\n   \n    # ??????????????????????????????????±??????????index????????£?????????\n    idx2 = list.index idx1\n    n = 0 \n    while idx2 > i\n      # ??????????????????\n      n += 1\n\n      sortedidx = list.index sorted[idx2]\n      total += list[sortedidx]\n      list = swap(list, idx2, sortedidx) \n      idx2 = sortedidx\n    end\n    total += [idx1 * n, idx2*2+sorted[0]*(n+2)].min\n  end\n  return total\nend\n\ntotal = minCostPath(t)\np total"
  },
  {
    "language": "Ruby",
    "code": "def minimun_cost_sort(array)\n\tare_sorted = Array.new(array.size, false)\n\tsorted_array = array.sort\n\tcost_sum = 0\n\n\tarray.each_index do |i|\n\t\tnext if are_sorted[i]\n\t\tindex = i\n\t\tcycle_sum = 0\n\t\tmin_value = 10000 # enough large value\n\t\tcycle_size = 0\n\t\t# ソートされていない値からサイクルを見つけてソート済みとする\n\t\tloop do\n\t\t\t# 移動コスト計算に必要な値を算出\n\t\t\tcycle_size += 1\n\t\t\tvalue = array[index]\n\t\t\tmin_value = min_value < value ? min_value : value\n\t\t\tcycle_sum += value\n\n\t\t\tare_sorted[index] = true\n\t\t\tindex = sorted_array.index(value) # ソート後の位置を辿ることでサイクルを見つける\n\t\t\tbreak if are_sorted[index]\n\t\tend\n\t\t# サイクル内での最適な移動は数式に落とし込んでいる\n\t\t# 移動の最小コスト候補は２通りあるのでそれぞれ計算して比較する\n\t\tcost1 = cycle_sum + (cycle_size - 2) * min_value\n\t\tcost2 = min_value + cycle_sum + (cycle_size + 1) * cycle_sum\n\t\tcost_sum += cost1 < cost2 ? cost1 : cost2\n\tend\n\tcost_sum\nend\n\nn = STDIN.gets.to_i\narray = STDIN.gets.split[0...n].map(&:to_i)\nputs minimun_cost_sort(array)"
  },
  {
    "language": "Ruby",
    "code": "gets\na = gets.split.map(&:to_i)\nb = a.clone.sort\n\ngmin = b[0]\n\ncost = 0\nloop = {}\n0.upto(b.size-1){|i|\n  if a[i] != b[i] && loop[i] != 1 then\n    sum = 0\n    min = a[i]\n    n = 0\n    idx = b.index(a[i])\n    loop[idx] = 1\n    flag = 0\n    loop do\n      min = a[idx] if min > a[idx]\n      flag = 1 if a[idx] == gmin\n      sum += a[idx]\n      idx = b.index(a[idx])\n#      printf \"idx: %d\\n\", idx\n      n += 1\n      break if loop[idx] == 1\n      loop[idx] = 1\n    end\n    if n == 2 then\n      cost += sum\n    elsif n > 2 then\n      if (n-2) * min < min + (n+1)*gmin then\n        cost += sum + (n-2) * min\n      else\n        cost += sum + min + (n+1) * gmin\n      end\n    end\n#    printf \"%d %d %d %d\\n\", sum, min, n, flag\n  end\n}\n\nputs cost"
  },
  {
    "language": "Ruby",
    "code": "gets\nl=gets.split.map &:to_i\ns=l.sort\nc=0\nl.size.times{|i|\n a=l.index t=s[b=i]\n n=0\n while a>i\n  l[a],l[b]=l[b],l[a]\n  c+=l[a]\n  a=s.index l[b]\n  n+=1\n end\n c+=[t*n,t*2+s[0]*(n+2)].min\n}\np c"
  },
  {
    "language": "Ruby",
    "code": "def solve(orig_arr)\n  sorted_arr = orig_arr.sort\n  smallest = sorted_arr.first\n  cost = 0\n  visited = {}\n  value_to_sorted_index = {}\n\n  sorted_arr.size.times do |i|\n    value_to_sorted_index[sorted_arr[i]] = i\n  end\n\n  orig_arr.size.times do |i|\n    next if visited[i]\n\n    current = i\n    sum = 0\n    min = Float::INFINITY\n    n = 0\n\n    loop do\n      visited[current] = true\n      n += 1\n      value = orig_arr[current]\n      min = [value, min].min\n      sum += value\n      current = value_to_sorted_index[value]\n      break if visited[current]\n    end\n\n    cost1 = sum + (n - 2) * min\n    cost2 = min + sum + (n + 1) * smallest\n\n    cost += [cost1, cost2].min\n  end\n\n  cost\nend\n\nif $PROGRAM_NAME == __FILE__\n  n = gets.to_i\n\n  arr = gets.chomp.split.map(&:to_i)\n\n  puts solve(arr)\nend"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\nbaggage = gets.split.map(&:to_i)\nsorted = baggage.sort\npos = {}\nn.times{ |i| pos[sorted[i]] = i }\ncost = 0\nused = [false] * n\nn.times do |s|\n  next if used[s]\n  cur = s\n  count = 0\n  loop do\n    count += 1\n    used[cur] = true\n    w = baggage[cur]\n    cost += w\n    cur = pos[w]\n    break if used[cur]\n  end\n  cost += [sorted[cur] * (count - 2), sorted[cur] + sorted[0] * (count + 1)].min\nend\np cost"
  },
  {
    "language": "Ruby",
    "code": "def solve(arr)\n  sorted = arr.sort\n  n = arr.length\n  used = Array.new(n, false)\n  minimum = arr.min\n  max = arr.max\n  circle_index = Array.new(max)\n  arr.each_with_index do |v, i|\n    circle_index[v] = i\n  end\n\n  ans = 0\n  arr.each_with_index do |v, i|\n    if used[i]\n      next\n    end\n    if sorted[i] == v\n      used[i] = true\n      next\n    end\n    cur_i = i\n    m = v\n    s = 0\n    cur_n = 1\n    while true\n      cur_i = circle_index[arr[cur_i]]\n      if used[cur_i] \n        break\n      end\n      m = [m, arr[cur_i]].min\n      s += arr[cur_i]\n      cur_n += 1\n      used[cur_i] = true\n    end\n    ans += [(s + (cur_n - 2) * m), (s + m + (cur_n + 1) * minimum)].min\n  end\n  ans\nend\n\nn = gets.to_i\narr = gets.split.map(&:to_i)\nputs solve(arr)\n\n"
  },
  {
    "language": "Ruby",
    "code": "gets\nc=0\nl=gets.split.map &:to_i\nl.sort.reverse.map{|i|(i>j=l.pop)&&c+=i+l[l.index i]=j}\np c"
  },
  {
    "language": "Ruby",
    "code": "N = gets.to_i\na = gets.split.map(&:to_i)\n\nVMAX = 10000\nS = a.min\n\ndef solve(a)\n  ans = 0\n  b = Marshal.load(Marshal.dump(a)).sort\n  v = Array.new(N, false)\n  t = []\n\n  (0...N).each do |i|\n    t[b[i]] = i\n  end\n\n  (0...N).each do |i|\n    next if v[i]\n\n    cur = i\n    s = 0\n    m = VMAX\n    an = 0\n\n    loop do\n      v[cur] = true\n      an += 1\n      val = a[cur]\n      m = [m, val].min\n      s += val\n      cur = t[val]\n\n      break if v[cur]\n    end\n    ans += [s + (an - 2) * m, m + s + (an + 1) * S].min\n  end\n  ans\nend\n\nputs solve(a)\n"
  },
  {
    "language": "Ruby",
    "code": "N = gets.to_i\nA = gets.split.map &:to_i\nmin = A.min\nsorted = Array.new(N, false)\nsortedA = A.sort\ncost=0\n\nA.each_with_index {|e, i|\n    index = sortedA.index(e)\n    next if sorted[i] or index == i\n    sorted[i] = true\n    sum = e\n    cycleMin = e\n    num = 1\n    value = e\n    until index == i\n        sorted[index] = true\n        num+=1\n        value = A[index]\n        sum += value\n        if value < cycleMin\n            cycleMin = value\n        end\n        index = sortedA.index(A[index])\n    end\n    cost1 = cycleMin * (num - 3)\n    cost2 = min * (num + 1)\n    cost += sum + cycleMin + (cost1<=cost2 ? cost1 : cost2)\n}\nputs cost"
  },
  {
    "language": "Ruby",
    "code": "gets\nw=gets.split.map.with_index{|l,i|[l.to_i,i]}\nw.sort_by{|l|l[0]}.map.with_index{|l,i|w[w.index l]<<i}\nc=0\nw.map{|l|_,a,b=l\na==b&&next\nq=*a\n(m=w.find{|m|b==m[1]}\n_,a,b=m\nq<<a)while q[0]!=b\ns=q.map{|r|w[r][2]=r\nw[r][0]}.sort\nc+=s.shift*s.size+s.reduce(:+)}\np c"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\narray=gets.chomp.split(\" \").map(&:to_i)\nsorted = array.sort\n\nret = 0\n\n(0..(n-1)).each do |i|\n    t = sorted[i]\n    t_index = array.index(t)\n    count = 0\n    while t_index > i do\n        count+=1\n        s = sorted[t_index]\n        s_index = array.index(s)\n        ret+=s\n        array[t_index], array[s_index] = array[s_index], array[t_index]\n        t_index = s_index\n    end\n    ret += [t*count, t*2+sorted[0]*(count+2)].min\nend\n\nputs ret\n"
  },
  {
    "language": "Ruby",
    "code": "n = gets.chomp.to_i\nt = []\narr = gets.chomp.split.map(&:to_i)\nn.times do |i|\n  t << arr.shift\nend\n\n\ndef swap(list, a, b)\n  list[a], list[b] = list[b], list[a]\n  return list\nend\n\ndef minCostPath(list)\n  before = (0..list.size-1).to_a\n  sorted = list.sort\n  after = []\n  list.each do |item|\n    after << sorted.index(item) \n  end\n  s = 20000\n  idx1, idx2 = 0\n  before.zip(after).each  do |bef,aft|\n    unless bef == aft\n      sum = list[bef] + list[aft]  \n      s = sum if sum < s\n      idx1 = bef\n      idx2 = aft\n    end\n  end\n\n  return idx1, idx2, s\nend\n\ntotal = 0\n\nwhile true\n  i, j, s = minCostPath(t)\n  break if s == 20000\n  total += s\n  t = swap(t, i,j)\nend\np total"
  },
  {
    "language": "Ruby",
    "code": "n = gets.chomp.to_i\nt = []\narr = gets.chomp.split.map(&:to_i)\nn.times do |i|\n  t << arr.shift\nend\n\n\ndef swap(list, a, b)\n  list[a], list[b] = list[b], list[a]\n  return list\nend\n\ndef minCostPath(list)\n  before = (0..list.size-1).to_a\n  sorted = list.sort\n  after = []\n  list.each do |item|\n    after << sorted.index(item) \n  end\n  s = 20000\n  idx1, idx2 = 0\n  before.zip(after).each  do |bef,aft|\n    unless bef == aft\n      sum = list[bef] + list[aft]  \n      if sum < s\n        s = sum\n        idx1 = bef\n        idx2 = aft\n      end\n    end\n  end\n\n  return idx1, idx2, s\nend\n\ntotal = 0\n\nwhile true\n  i, j, s = minCostPath(t)\n  break if s == 20000\n  total += s\n  t = swap(t, i,j)\nend\np total"
  },
  {
    "language": "Ruby",
    "code": "n = gets.chomp.to_i\narr = gets.chomp.split.map(&:to_i)\nt = []\nn.times do |i|\n  t << arr.shift\nend\n\n# swap????????????\ndef swap(list, idx1, idx2)\n  list[idx1], list[idx2] = list[idx2], list[idx1]\n  return list\nend\n\ndef minCostPath(list)\n  sorted = list.sort\n  total = 0\n  \n  # list?????????\n  list.size.times do |i|\n    # ???????????????????????????????????????????????£?????????\n    idx1 =sorted[i]\n   \n    # ??????????????????????????????????±??????????index????????£?????????\n    idx2 = list.index idx1\n    n = 0 \n    while idx2 > i\n      # ??????????????????\n      n += 1\n\n      sortedidx = list.index sorted[idx2]\n      total += list[b]\n      list = swap(list, idx2, sortedidx) \n      idx2 = sortedidx\n    end\n    total += [idx1 * n, t*2+sorted[0]*(n+2)].min\n  end\n  return total\nend\n\ntotal = minCostPath(t)\np total"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\nw = gets.split.map(&:to_i)\nws = w.sort\npos = {}\n(0...n).each do |i|\n  pos[ws[i]] = i\nend\nmin = ws[0]\nflag = [true]*n\ncost = 0\n(0...n).each do |i|\n  if flag[i]\n    flag[i] = false\n    count = 0\n    startPos = i\n    nextPos = pos[w[i]]\n    while nextPos != startPos do\n      flag[nextPos] = false\n      cost += ws[nextPos]\n      count += 1\n      nextPos = pos[w[nextPos]]\n    end\n    if min*count + 2*(min+ws[i]) < ws[i]*count\n      cost += min*count + 2*(min+ws[i])\n    else\n      cost += ws[i]*count\n    end\n  end\nend\nprintf(\"%d\\n\",cost)\n"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\nbaggage = gets.split.map(&:to_i)\nsorted = baggage.sort\nsorted_index = sorted.map{ |s| baggage.index(s) }\ncost = 0\nused = [false] * n\nn.times do |s|\n  next if used[s]\n  cur = s\n  count = 0\n  loop do\n    count += 1\n    used[cur] = true\n    cost += baggage[cur]\n    cur = sorted_index[cur]\n    break if used[cur]\n  end\n  cost += [sorted[cur] * (count - 2), sorted[cur] + sorted[0] * (count + 1)].min\nend\np cost"
  },
  {
    "language": "Ruby",
    "code": "def calc_cost cycle, min_num\n  x = cycle.sum + (cycle.length - 2) * cycle.min\n  y = cycle.sum + cycle.min + (cycle.length + 1) * min_num\n  [x, y].min\nend\n\nn = gets.chomp.to_i\nas = gets.chomp.split(' ').map(&:to_i)\nmin_num = as.min\nbs = as.sort\ncycles = []\nwhile !as.empty?\n  a = as.shift\n  b = bs.shift\n  next if a == b\n  cs = [a, b]\n  while fb = as.find_index(b)\n    b = bs[fb]\n    cs << b\n    as.delete_at(fb)\n    bs.delete_at(fb)\n  end\n  cycles << cs\nend\n\ncost = 0\ncycles.each do |c|\n  c.pop\n  cost += calc_cost(c, min_num)\nend\nputs cost\n"
  },
  {
    "language": "Ruby",
    "code": "def solve(arr)\n  sorted = arr.sort\n  n = arr.length\n  used = Array.new(n, false)\n  minimum = arr.min\n  max = arr.max\n  circle_index = Array.new(max)\n  arr.each_with_index do |v, i|\n    circle_index[v] = i\n  end\n  # puts circle_index\n\n  ans = 0\n  arr.each_with_index do |v, i|\n    if used[i]\n      next\n    end\n    if sorted[i] == v\n      used[i] = true\n      next\n    end\n    cur_i = i\n    m = v\n    s = v\n    cur_n = 1\n    used[i] = true\n    while true\n      cur_i = circle_index[sorted[cur_i]]\n      if used[cur_i] \n        break\n      end\n      # puts \"i: #{i}, cur_i: #{cur_i}, m: #{m} s: #{s}\"\n      m = [m, arr[cur_i]].min\n      s += arr[cur_i]\n      cur_n += 1\n      used[cur_i] = true\n    end\n    ans += [(s + (cur_n - 2) * m), (s + m + (cur_n + 1) * minimum)].min\n  end\n  ans\nend\n\nn = gets.to_i\narr = gets.split.map(&:to_i)\nputs solve(arr)\n\n"
  },
  {
    "language": "Ruby",
    "code": "class Num\n  include Comparable\n  @@count = 0\n  @@sum_weight = 0\n  attr_accessor :weight, :position, :right_position, :sum_weight\n  def initialize(weight)\n    @weight = weight\n    @position = @@count\n    @@count += 1\n    @right_position = nil\n  end\n  \n  def <=>(other)\n    @weight <=> other.weight\n  end\n  \n  def swap(other)\n    @position, other.position = other.position, @position\n    @@sum_weight += @weight + other.weight\n  end\n  \n  def inspect\n    #return [@weight, @position, @right_position]\n    return @weight\n  end\n  \n  def move(other)\n    if self != other\n      swap(other)\n      return @position == @right_position\n    else\n      return true\n    end\n  end\n  \n  def self.sum_weight\n    return @@sum_weight\n  end\n  \n  def self.add(other)\n    @@sum_weight += other\n  end\nend\nclass String\n  def to_n\n    return Num.new(self.to_i)\n  end\nend\n\ndef main\n  gets\n  arr = gets.split(\" \").map(&:to_n)\n  arr2 = arr.sort\n  arr2.each_with_index{|item, idx|item.right_position = idx}\n  arr2.each{|item|\n    temp = 2 * arr2[0].weight + item.weight\n    until item.move(arr2[item.position])\n      temp -= item.weight\n    end\n    if temp < 0\n      Num.add(temp)\n    end\n    }\n  puts Num.sum_weight\nend\nmain"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\nbaggage = gets.split.map(&:to_i)\nsorted = baggage.sort\nsorted_index = sorted.map{ |s| baggage.index(s) }\ncost = 0\nused = [false] * n\nn.times do |s|\n  next if used[s]\n  cur = s\n  count = 0\n  loop do\n    count += 1\n    t = baggage.index(sorted[cur])\n    used[cur] = true\n    cost += baggage[cur]\n    cur = sorted_index[cur]\n    break if used[cur]\n  end\n  cost += [sorted[cur] * (count - 2), sorted[cur] + sorted[0] * (count + 1)].min\nend\np cost"
  },
  {
    "language": "Ruby",
    "code": "def minimum_cost_sort(ary, n)\n  cost = 0\n  (n-1).downto(0) { |i|\n    max = ary[0..i].max\n    idx = ary.index(max)\n    if i != idx\n      tmp = ary[idx]\n      ary[idx] = ary[i]\n      ary[i] = tmp\n      cost += ary[i] + ary[idx]\n    end\n  }\n  cost\nend\n\n# main\nn = gets.to_i\nary = gets.split(' ').map(&:to_i)\nw = minimum_cost_sort(ary, n)\nputs w"
  },
  {
    "language": "Ruby",
    "code": "n = gets.chomp.to_i\nt = []\narr = gets.chomp.split.map(&:to_i)\nn.times do |i|\n  t << arr.shift\nend\n\n\ndef swap(list, a, b)\n  list[a], list[b] = list[b], list[a]\n  return list\nend\n\ndef minCostPath(list)\n  before = (0..list.size-1).to_a\n  sorted = list.sort\n  after = []\n  list.each do |item|\n    after << sorted.index(item) \n  end\n  s = 20000\n  idx1, idx2 = 0\n  before.zip(after).each  do |bef,aft|\n    unless bef == aft\n      sum = list[bef] + list[aft]  \n      if sum < s\n        s = sum\n        idx1 = bef\n        idx2 = aft\n      end\n    end\n  end\n\n  return idx1, idx2, s\nend\n\ntotal = 0\n\nwhile true\n  i, j, s = minCostPath(t)\n  break if s == 20000\n  total += s\n  t = swap(t, i,j)\nend\np total"
  },
  {
    "language": "Ruby",
    "code": "n = gets.chomp.to_i\nt = []\narr = gets.chomp.split.map(&:to_i)\nn.times do |i|\n  t << arr.shift\nend\n\n\ndef swap(list, a, b)\n  list[a], list[b] = list[b], list[a]\n  return list\nend\n\ndef minCostPath(list)\n  before = (0..list.size-1).to_a\n  sorted = list.sort\n  after = []\n  list.each do |item|\n    after << sorted.index(item) \n  end\n  s = 20000\n  idx1, idx2 = 0\n  p list\n  p before\n  p after\n  before.zip(after).each  do |bef,aft|\n    unless bef == aft\n      sum = list[bef] + list[aft]  \n      if sum < s\n        s = sum\n        idx1 = bef\n        idx2 = aft\n      end\n    end\n  end\n\n  return idx1, idx2, s\nend\n\ntotal = 0\n\nwhile true\n  i, j, s = minCostPath(t)\n  puts i,j,s\n  break if s == 20000\n  total += s\n  p \"total: #{total} p #{t}\"\n  t = swap(t, i,j)\nend\np total"
  },
  {
    "language": "Ruby",
    "code": "n = gets.chomp.to_i\narr = gets.chomp.split.map(&:to_i)\nt = []\nn.times do |i|\n  t << arr.shift\nend\n\n# swap????????????\ndef swap(list, idx1, idx2)\n  list[idx1], list[idx2] = list[idx2], list[idx1]\n  return list\nend\n\ndef minCostPath(list)\n  sorted = list.sort\n  total = 0\n  \n  # list?????????\n  list.size.times do |i|\n    # ???????????????????????????????????????????????£?????????\n    idx1 =sorted[i]\n   \n    # ??????????????????????????????????±??????????index????????£?????????\n    idx2 = list.index idx1\n    n = 0 \n    while idx2 > i\n      # ??????????????????\n      n += 1\n\n      sortedidx = list.index sorted[idx2]\n      total += list[sortedidx]\n      list = swap(list, idx2, sortedidx) \n      idx2 = sortedidx\n    end\n    total += [idx1 * n, idx1*2+sorted[0]*(n+2)].min\n  end\n  return total\nend\n\ntotal = minCostPath(t)\np total"
  },
  {
    "language": "Ruby",
    "code": "gets\nl=gets.split.map &:to_i\ns=l.sort\nc=0\nl.size.times{|i|\n  a=l.index t=s[i]\n  n=0\n  (n+=1;b=l.index s[a];c+=l[b];l[a],l[b]=l[b],l[a];a=b)while a>i\n  c+=[t*n,t*2+s[0]*(n+2)].min\n}\np c"
  },
  {
    "language": "Ruby",
    "code": "class Num\n  include Comparable\n  @@count = 0\n  @@sum_weight = 0\n  attr_accessor :weight, :position, :right_position\n  def initialize(weight)\n    @weight = weight\n    @position = @@count\n    @@count += 1\n    @right_position = nil\n  end\n  \n  def <=>(other)\n    @weight <=> other.weight\n  end\n  \n  def swap(other)\n    @position, other.position = other.position, @position\n    @@sum_weight += @weight + other.weight\n  end\n  \n  def move(other)\n    if self != other\n      swap(other)\n      return @position == @right_position\n    else\n      return true\n    end\n  end\n  \n  def self.sum_weight\n    return @@sum_weight\n  end\nend\nclass String\n  def to_n\n    return Num.new(self.to_i)\n  end\nend\n\ndef main\n  gets\n  arr = gets.split(\" \").map(&:to_n)\n  arr2 = arr.sort\n  arr2.each_with_index{|item, idx|item.right_position = idx}\n  arr2.each{|item|\n    unless item.move(arr2[item.position])\n    end}\n  puts Num.sum_weight\nend\nmain"
  },
  {
    "language": "Ruby",
    "code": "$MAX = 1000\n$VMAX = 10000\n\n$n = gets.to_i\n$a = gets.split.map(&:to_i)\n$b = Array.new($MAX)\n$t = Array.new($VMAX+1)\n$m = $VMAX\n\ndef solve\n  ans = 0\n  v = Array.new($MAX){false}\n  $b = $a.sort\n\n  $b.each_with_index do |item, i|\n    # $tには、各要素が何番目かが入る\n    # $t[item] とすると、itemがソーティングしたときに何番目かが分かる。\n    $t[item] = i\n  end\n\n  0.upto($n-1) do |i|\n    cur = i\n    w = 0\n    m = $VMAX\n    an = 0\n\n    #サイクルを生成するループ\n    loop do\n      #サイクルが閉じたかどうか\n      v[cur] = true\n      #サイクル内の要素数\n      an += 1\n      item = $a[cur]\n      #サイクル内のminを更新\n      m = [m, item].min\n      #コストを足す\n      w += item\n      #次の要素へ\n      cur = $t[item]\n      #サイクルが閉じたらbreak\n      if v[cur]\n        break\n      end\n    end\n\n    ans += [w+(an-2)*m, m+w+(an+1)*$m].min\n  end\n  return ans\nend\n\n$m = $a.min\n\nans = solve\n\nputs ans\n"
  },
  {
    "language": "Ruby",
    "code": "gets\nw=gets.split.map.with_index{|l,i|[l.to_i,i]}\nx=w.sort_by{|l|l[0]}\nx.map.with_index{|l,i|w[w.index l]<<i}\nc=0\nw.map{|l|_,a,b=l\na==b&&next\nq=*a\n(_,a,b=w.find{|k|b==k[1]}\nq<<a)while q[0]!=b\ns=q.map{|r|w[r][2]=r\nw[r][0]}\nt=s.reduce:+\nc+=[t+s[-1]+x[0][0]*z=s.size,t+s[-1]*(z-2)].min}\np c"
  },
  {
    "language": "Ruby",
    "code": "def minimun_cost_sort(array)\n\tare_sorted = Array.new(array.size, false)\n\tsorted_array = array.sort\n\tmin_value = array.min\n\tcost_sum = 0\n\n\tarray.each_index do |i|\n\t\tnext if are_sorted[i]\n\t\tindex = i\n\t\tcycle_cost_sum = 0\n\t\tcycle_min_value = 10000 # enough large value\n\t\tcycle_size = 0\n\t\t# ソートされていない値からサイクルを見つけてソート済みとする\n\t\tloop do\n\t\t\t# 移動コスト計算に必要な値を算出\n\t\t\tcycle_size += 1\n\t\t\tvalue = array[index]\n\t\t\tcycle_min_value = cycle_min_value < value ? cycle_min_value : value\n\t\t\tcycle_cost_sum += value\n\n\t\t\tare_sorted[index] = true\n\t\t\tindex = sorted_array.index(value) # ソート後の位置を辿ることでサイクルを見つける\n\t\t\tbreak if are_sorted[index]\n\t\tend\n\t\t# サイクル内での最適な移動は数式に落とし込んでいる\n\t\t# 移動の最小コスト候補は２通りあるのでそれぞれ計算して比較する\n\t\tcost1 = cycle_cost_sum + (cycle_size - 2) * cycle_min_value\n\t\tcost2 = cycle_min_value + cycle_cost_sum + (cycle_size + 1) * min_value\n\t\tcost_sum += cost1 < cost2 ? cost1 : cost2\n\tend\n\tcost_sum\nend\n\nn = STDIN.gets.to_i\narray = STDIN.gets.split[0...n].map(&:to_i)\nputs minimun_cost_sort(array)"
  },
  {
    "language": "Ruby",
    "code": "n = gets.chomp.to_i\nt = []\narr = gets.chomp.split.map(&:to_i)\nn.times do |i|\n  t << arr.shift\nend\n\n\ndef swap(list, a, b)\n  list[a], list[b] = list[b], list[a]\n  return list\nend\n\ndef minCostPath(list)\n  before = (0..list.size-1).to_a\n  sorted = list.sort\n  after = []\n  list.each do |item|\n    after << sorted.index(item) \n  end\n  s = 20000\n  idx1, idx2 = 0\n#  p list\n # p before\n # p after\n  before.zip(after).each  do |bef,aft|\n    unless bef == aft\n      sum = list[bef] + list[aft]  \n      if sum < s\n        s = sum\n        idx1 = bef\n        idx2 = aft\n      end\n    end\n  end\n\n  return idx1, idx2, s\nend\n\ntotal = 0\n\nwhile true\n  i, j, s = minCostPath(t)\n  puts i,j,s\n  break if s == 20000\n  total += s\n  p \"total: #{total} p #{t}\"\n  t = swap(t, i,j)\nend\np total"
  },
  {
    "language": "Ruby",
    "code": "class Num\n  include Comparable\n  @@count = 0\n  @@sum_weight = 0\n  attr_accessor :weight, :position, :right_position, :sum_weight\n  def initialize(weight)\n    @weight = weight\n    @position = @@count\n    @@count += 1\n    @right_position = nil\n  end\n  \n  def <=>(other)\n    @weight <=> other.weight\n  end\n  \n  def swap(other)\n    #p [@weight, other.weight]\n    @position, other.position = other.position, @position\n    @@sum_weight += @weight + other.weight\n  end\n  \n  def inspect\n    #return [@weight, @position, @right_position]\n    return @weight\n  end\n  \n  def move(other)\n    if self != other\n      swap(other)\n      return @position == @right_position\n    else\n      return true\n    end\n  end\n  \n  def self.sum_weight\n    return @@sum_weight\n  end\n  \n  def self.add(other)\n    @@sum_weight += other\n  end\nend\nclass String\n  def to_n\n    return Num.new(self.to_i)\n  end\nend\n\ndef main\n  gets\n  arr = gets.split(\" \").map(&:to_n)\n  arr2 = arr.sort\n  arr2.each_with_index{|item, idx|item.right_position = idx}\n  arr2.each{|item|\n    temp = 3 * arr2[0].weight + item.weight\n    until item.move(arr2[item.position])\n      temp -= item.weight - arr2[0].weight\n    end\n    if temp < 0\n      Num.add(temp)\n    end\n    }\n  puts Num.sum_weight\nend\nmain"
  },
  {
    "language": "Ruby",
    "code": "n = gets.chomp.to_i\nt = []\narr = gets.chomp.split.map(&:to_i)\nn.times do |i|\n  t << arr.shift\nend\n\n\ndef swap(list, a, b)\n  list[a], list[b] = list[b], list[a]\n  return list\nend\n\ndef minCostPath(list)\n  before = (0..list.size-1).to_a\n  sorted = list.sort\n  after = []\n  list.each do |item|\n    after << sorted.index(item) \n  end\n  s = 20000\n  idx1, idx2 = 0\n#  p list\n # p before\n # p after\n  before.zip(after).each  do |bef,aft|\n    unless bef == aft\n      sum = list[bef] + list[aft]  \n      if sum < s\n        s = sum\n        idx1 = bef\n        idx2 = aft\n      end\n    end\n  end\n\n  return idx1, idx2, s\nend\n\ntotal = 0\n\nwhile true\n  i, j, s = minCostPath(t)\n  puts i,j,s\n  break if s == 20000\n  total += s\n#  p \"total: #{total} p #{t}\"\n  t = swap(t, i,j)\nend\np total"
  },
  {
    "language": "Ruby",
    "code": "n = gets.chomp.to_i\nt = []\narr = gets.chomp.split.map(&:to_i)\nn.times do |i|\n  t << arr.shift\nend\n\ndef minindexvalue(list)\n  min = 10001 \n  idx = 1001\n\n  list.each.with_index do |x,i|\n    if min > x\n      idx = i\n      min = x\n    end\n  end\n  return idx\nend\n\ntotal = 0\n\nres = []\nuntil t.empty?\n  idx = minindexvalue(t) \n  if idx == 0\n    res << t.shift\n  else\n    total += t[0] + t[idx]\n    t[0], t[idx] = t[idx], t[0]\n    res << t.shift\n  end\nend\np total"
  },
  {
    "language": "Ruby",
    "code": "cost=0\nN = gets.to_i\nA = gets.split.map &:to_i\nmin = A.min\nsorted = Array.new(N, false)\nsortedA = A.sort\n\nA.each_with_index {|e, i|\n    index = sortedA.index(e)\n    next if sorted[i] or index == i\n    sorted[i] = true\n    sum = e\n    cycleMin = e\n    num = 1\n    value = e\n    until sorted[index]\n        sorted[index] = true\n        num+=1\n        value = A[index]\n        sum += value\n        if value < cycleMin\n            cycleMin = value\n        end\n        index = sortedA.index(value)\n    end\n    cost1 = cycleMin * (num - 3)\n    cost2 = min * (num + 1)\n    cost += sum + cycleMin + (cost1<=cost2 ? cost1 : cost2)\n}\nputs cost"
  },
  {
    "language": "Ruby",
    "code": "n = gets.chomp.to_i\nt = []\narr = gets.chomp.split.map(&:to_i)\nn.times do |i|\n  t << arr.shift\nend\n\ndef minindexvalue(list)\n  min = 10001 \n  idx = 1001\n\n  list.each.with_index do |x,i|\n    if min > x\n      idx = i\n      min = x\n    end\n  end\n  return idx\nend\n\ntotal = 0\n\nres = []\nuntil t.empty?\n  idx = minindexvalue(t) \n  if idx == 0\n    res << t.shift\n  else\n    total += t[0] + t[idx]\n    t[0], t[idx] = t[idx], t[0]\n    res << t.shift\n  end\nend\np total"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\nbaggage = gets.split.map(&:to_i)\nsorted = baggage.sort\ncost = 0\nused = [false] * n\nn.times do |s|\n  next if used[s]\n  cur = s\n  count = 0\n  loop do\n    count += 1\n    used[cur] = true\n    cost += baggage[cur]\n    cur = sorted.index(baggage[cur])\n    break if used[cur]\n  end\n  cost += [sorted[cur] * (count - 2), sorted[cur] + sorted[0] * (count + 1)].min\nend\np cost"
  },
  {
    "language": "Ruby",
    "code": "class Num\n  include Comparable\n  @@count = 0\n  @@sum_weight = 0\n  attr_accessor :weight, :position, :right_position\n  def initialize(weight)\n    @weight = weight\n    @position = @@count\n    @@count += 1\n    @right_position = nil\n  end\n  \n  def <=>(other)\n    @weight <=> other.weight\n  end\n  \n  def swap(other)\n    @position, other.position = other.position, @position\n    @@sum_weight += @weight + other.weight\n  end\n  \n  def inspect\n    return [@weight, @position, @right_position]\n  end\n  \n  def move(other)\n    if self != other\n      swap(other)\n      return @position == @right_position\n    else\n      return true\n    end\n  end\n  \n  def self.sum_weight\n    return @@sum_weight\n  end\nend\nclass String\n  def to_n\n    return Num.new(self.to_i)\n  end\nend\n\ndef main\n  gets\n  arr = gets.split(\" \").map(&:to_n)\n  arr2 = arr.sort\n  arr2.each_with_index{|item, idx|item.right_position = idx}\n  arr2.each{|item|\n    until item.move(arr2[item.position])\n    end}\n  puts Num.sum_weight\nend\nmain"
  },
  {
    "language": "Ruby",
    "code": "n = gets.chomp.to_i\nt = []\narr = gets.chomp.split.map(&:to_i)\nn.times do |i|\n  t << arr.shift\nend\n\n\ndef swap(list, a, b)\n  list[a], list[b] = list[b], list[a]\n  return list\nend\n\ndef minCostPath(list)\n  before = (0..list.size-1).to_a\n  sorted = list.sort\n  after = []\n  list.each do |item|\n    after << sorted.index(item) \n  end\n  s = 20000\n  idx1, idx2 = 0\n  #p list\n  #p before\n  #p after\n  before.zip(after).each  do |bef,aft|\n    unless bef == aft\n      sum = list[bef] + list[aft]  \n      if sum < s\n        s = sum\n        idx1 = bef\n        idx2 = aft\n      end\n    end\n  end\n\n  return idx1, idx2, s\nend\n\ntotal = 0\n\nwhile true\n  i, j, s = minCostPath(t)\n  #puts i,j,s\n  break if s == 20000\n  total += s\n  #p \"total: #{total} p #{t}\"\n  t = swap(t, i,j)\nend\np total"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"sort\"\n\t\"strconv\"\n)\n\nconst VMAX = 100000\n\nfunc main() {\n\tfmt.Printf(\"%d\\n\", answer(os.Stdin))\n}\n\nfunc answer(r io.Reader) int {\n\tsc := bufio.NewScanner(r)\n\tsc.Split(bufio.ScanWords)\n\tsc.Scan()\n\tn, _ := strconv.Atoi(sc.Text())\n\tA := make([]int, n)\n\ts := VMAX\n\tfor i := 0; i < n; i++ {\n\t\tsc.Scan()\n\t\tA[i], _ = strconv.Atoi(sc.Text())\n\t\ts = min(s, A[i])\n\t}\n\treturn minCostSort(A, n, s)\n}\n\nfunc min(a, b int) int {\n\tif a > b {\n\t\treturn b\n\t}\n\treturn a\n}\n\nfunc minCostSort(A []int, n, s int) int {\n\tans := 0\n\tB, T := make([]int, n), make([]int, VMAX)\n\tV := make([]bool, n) // all elements are \"false\".\n\tcopy(B, A)\n\tsort.Slice(B, func(i, j int) bool {\n\t\treturn B[i] < B[j]\n\t})\n\tfor i := 0; i < n; i++ {\n\t\tT[B[i]] = i\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tif V[i] {\n\t\t\tcontinue\n\t\t}\n\t\tcur := i\n\t\t// S is sum of elements.\n\t\tS := 0\n\t\t// m is minimum value of elements.\n\t\tm := VMAX\n\t\t// an is answer in cycle.\n\t\tan := 0\n\t\tfor {\n\t\t\tV[cur] = true\n\t\t\tan++\n\t\t\tv := A[cur]\n\t\t\tm = min(m, v) // minimum element.\n\t\t\tS += v        // Sum of elements.\n\t\t\tcur = T[v]\n\t\t\tif V[cur] {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tans += min(S+(an-2)*m, m+S+(an+1)*s)\n\t}\n\treturn ans\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\n/*\n最小コストソート\n*/\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc partition(a []int) int {\n\tx := a[len(a)-1]\n\ti := -1\n\tfor j := 0; j < len(a)-1; j++ {\n\t\tif a[j] <= x {\n\t\t\ti++\n\t\t\ta[i], a[j] = a[j], a[i]\n\t\t}\n\t}\n\ta[i+1], a[len(a)-1] = a[len(a)-1], a[i+1]\n\treturn i + 1\n}\nfunc quickSort(a []int) {\n\tif len(a) > 1 {\n\t\tq := partition(a)\n\t\tquickSort(a[:q])\n\t\tquickSort(a[q+1:])\n\t}\n}\n\nfunc countCycleCost(a []int) int {\n\t// n個の要素\n\t// 最小値を使ってn-1回要素を入れ替える．\n\t// min(a) 以外の要素は1回だけのコスト:sum(a) - min(a)\n\t// min(a) は n-1回移動する:min(a) * (n-1)\n\t// sum(a) + min(a) * n-2\n\treturn sum(a) + min(a)*(len(a)-2)\n}\nfunc countCycleCostWithX(a []int, x int) int {\n\t// n個の要素\n\t// 外部のxを使って要素を入れ替える．\n\t// xとmin(a)を入れ替えて元に戻すコスト:(min(a) + x) * 2\n\t// min(a)以外の要素は1回だけのコスト:sum(a) - min(a)\n\t// x は n-1回移動する:x * (n - 1)\n\t// (min(a) + x) * 2 + sum(a) - min(a) + x * (n - 1)\n\t// sum(a) + 2*min(a) -min(a) + 2*x + x*(n-1)\n\t// sum(a) + min(a) + x*(n+1)\n\treturn sum(a) + min(a) + x*(len(a)+1)\n}\n\nfunc collectGroup(a []int) [][]int {\n\tvar result [][]int\n\n\tb := make([]int, len(a))\n\tcopy(b, a)\n\tquickSort(b) // bはソート済み配列\n\n\tc := make([]bool, len(a)) // cはサイクルグループに分別したかどうかを表す．\n\n\tfor i := 0; i < len(a); i++ {\n\t\tif c[i] {\n\t\t\t// すでに分別済み\n\t\t\tcontinue\n\t\t}\n\t\tcur := i\n\t\tvar r []int\n\t\tfor {\n\t\t\tc[cur] = true\n\t\t\tv := a[cur]\n\t\t\tr = append(r, v)\n\t\t\t// 本来あるべき offsetをソート済み配列から取得する\n\t\t\toffset := find(v, b)\n\t\t\tif c[offset] {\n\t\t\t\t// 1つのサイクルグループ完了したので全体結果に追加\n\t\t\t\tresult = append(result, r)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcur = offset\n\t\t}\n\t}\n\treturn result\n}\nfunc solve(a []int) int {\n\tx := min(a)\n\tgroup := collectGroup(a)\n\tcost := 0\n\tfor _, g := range group {\n\t\tif len(g) > 1 {\n\t\t\tc1 := countCycleCost(g)\n\t\t\tc2 := countCycleCostWithX(g, x)\n\t\t\tcost += min([]int{c1, c2})\n\t\t}\n\t}\n\treturn cost\n}\n\nfunc main() {\n\tscanner := makeScanner(6 * 1000)\n\teGetInt(scanner)\n\tintegers := eGetInts(scanner)\n\tfmt.Println(solve(integers))\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// ライブラリ\n////////////////////////////////////////////////////////////////////////////////\nfunc makeScanner(maxByte int) *bufio.Scanner {\n\tscanner := bufio.NewScanner(os.Stdin)\n\tscanner.Buffer(make([]uint8, 0, 8192), maxByte)\n\treturn scanner\n}\nfunc eGetLine(r *bufio.Scanner) string {\n\tif r.Scan() {\n\t\treturn r.Text()\n\t}\n\terr := r.Err()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t// EOF\n\treturn \"\"\n}\nfunc eGetInt(r *bufio.Scanner) int {\n\tline := eGetLine(r)\n\treturn eAtoi(line)\n}\nfunc eGetFields(r *bufio.Scanner) []string {\n\tline := eGetLine(r)\n\treturn strings.Fields(line)\n}\nfunc eGetInts(r *bufio.Scanner) []int {\n\tfields := eGetFields(r)\n\tints := make([]int, len(fields))\n\tfor i := 0; i < len(ints); i++ {\n\t\tints[i] = eAtoi(fields[i])\n\t}\n\treturn ints\n}\nfunc eGetChars(r *bufio.Scanner) []string {\n\tline := eGetLine(r)\n\treturn strings.Split(line, \"\")\n}\nfunc eAtoi(s string) int {\n\tn, err := strconv.Atoi(s)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treturn n\n}\n\ntype ints []int\n\nfunc (s ints) String() string {\n\tvar buf bytes.Buffer\n\tsep := \"\"\n\tfor _, v := range s {\n\t\tbuf.WriteString(fmt.Sprintf(\"%s%d\", sep, v))\n\t\tsep = \" \"\n\t}\n\treturn buf.String()\n}\n\nfunc reverse(a ints) ints {\n\tr := make(ints, len(a))\n\tfor i := 0; i < len(a); i++ {\n\t\tr[i] = a[len(a)-1-i]\n\t}\n\treturn r\n}\nfunc max(a ints) (int, bool) {\n\tif len(a) == 0 {\n\t\treturn 0, false\n\t}\n\tm := a[0]\n\tfor _, e := range a {\n\t\tif e > m {\n\t\t\tm = e\n\t\t}\n\t}\n\treturn m, true\n}\nfunc min(a []int) int {\n\tm := a[0]\n\tfor _, v := range a {\n\t\tif v < m {\n\t\t\tm = v\n\t\t}\n\t}\n\treturn m\n}\n\nfunc sum(a ints) int {\n\tif len(a) == 0 {\n\t\treturn 0\n\t}\n\tsum := 0\n\tfor _, e := range a {\n\t\tsum += e\n\t}\n\treturn sum\n}\nfunc find(n int, a ints) int {\n\tfor i, v := range a {\n\t\tif n == v {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"sort\"\n\t\"strconv\"\n)\n\nconst VMAX = 100000\n\nfunc main() {\n\tfmt.Printf(\"%d\\n\", answer(os.Stdin))\n}\n\nfunc answer(r io.Reader) int {\n\tsc := bufio.NewScanner(r)\n\tsc.Split(bufio.ScanWords)\n\tsc.Scan()\n\tn, _ := strconv.Atoi(sc.Text())\n\tA := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tsc.Scan()\n\t\tA[i], _ = strconv.Atoi(sc.Text())\n\t}\n\treturn minCostSort(A, n)\n}\n\nfunc min(a, b int) int {\n\tif a > b {\n\t\treturn b\n\t}\n\treturn a\n}\n\nfunc minCostSort(A []int, n int) int {\n\tans, s := 0, 0\n\tB, T := make([]int, n), make([]int, VMAX)\n\tV := make([]bool, n) // all elements are \"false\".\n\tcopy(B, A)\n\tsort.Slice(B, func(i, j int) bool {\n\t\treturn B[i] < B[j]\n\t})\n\tfor i := 0; i < n; i++ {\n\t\tT[B[i]] = i\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tif V[i] {\n\t\t\tcontinue\n\t\t}\n\t\tcur := i\n\t\t// S is sum of elements.\n\t\tS := 0\n\t\t// m is minimum value of elements.\n\t\tm := VMAX\n\t\t// an is answer in cycle.\n\t\tan := 0\n\t\tfor {\n\t\t\tV[cur] = true\n\t\t\tan++\n\t\t\tv := A[cur]\n\t\t\tm = min(m, v) // minimum element.\n\t\t\tS += v        // Sum of elements.\n\t\t\tcur = T[v]\n\t\t\tif V[cur] {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tans += min(S+(an-2)*m, m+S+(an+1)*s)\n\t}\n\treturn ans\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\n/*\n最小コストソート\n*/\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc partition(a []int) int {\n\tx := a[len(a)-1]\n\ti := -1\n\tfor j := 0; j < len(a)-1; j++ {\n\t\tif a[j] <= x {\n\t\t\ti++\n\t\t\ta[i], a[j] = a[j], a[i]\n\t\t}\n\t}\n\ta[i+1], a[len(a)-1] = a[len(a)-1], a[i+1]\n\treturn i + 1\n}\nfunc quickSort(a []int) {\n\tif len(a) > 1 {\n\t\tq := partition(a)\n\t\tquickSort(a[:q])\n\t\tquickSort(a[q+1:])\n\t}\n}\n\nfunc countCost1(a, sorted []int) int {\n\tcost := 0\n\tfor i := len(a) - 1; i > 0; i-- {\n\t\tif sorted[i] == a[i] {\n\t\t\tcontinue\n\t\t}\n\t\tfor j := i - 1; j >= 0; j-- {\n\t\t\tif sorted[i] == a[j] {\n\t\t\t\ta[i], a[j] = a[j], a[i]\n\t\t\t\tcost = cost + a[i] + a[j]\n\t\t\t}\n\t\t}\n\t}\n\treturn cost\n}\nfunc countCost(a []int) int {\n\tb := make([]int, len(a))\n\tcopy(b, a)\n\tquickSort(b)\n\treturn countCost1(a, b)\n}\n\nfunc main() {\n\tscanner := makeScanner(6 * 1000)\n\teGetInt(scanner)\n\tintegers := eGetInts(scanner)\n\tfmt.Println(countCost(integers))\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// ライブラリ\n////////////////////////////////////////////////////////////////////////////////\nfunc makeScanner(maxByte int) *bufio.Scanner {\n\tscanner := bufio.NewScanner(os.Stdin)\n\tscanner.Buffer(make([]uint8, 0, 8192), maxByte)\n\treturn scanner\n}\nfunc eGetLine(r *bufio.Scanner) string {\n\tif r.Scan() {\n\t\treturn r.Text()\n\t}\n\terr := r.Err()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t// EOF\n\treturn \"\"\n}\nfunc eGetInt(r *bufio.Scanner) int {\n\tline := eGetLine(r)\n\treturn eAtoi(line)\n}\nfunc eGetFields(r *bufio.Scanner) []string {\n\tline := eGetLine(r)\n\treturn strings.Fields(line)\n}\nfunc eGetInts(r *bufio.Scanner) []int {\n\tfields := eGetFields(r)\n\tints := make([]int, len(fields))\n\tfor i := 0; i < len(ints); i++ {\n\t\tints[i] = eAtoi(fields[i])\n\t}\n\treturn ints\n}\nfunc eGetChars(r *bufio.Scanner) []string {\n\tline := eGetLine(r)\n\treturn strings.Split(line, \"\")\n}\nfunc eAtoi(s string) int {\n\tn, err := strconv.Atoi(s)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treturn n\n}\n\ntype ints []int\n\nfunc (s ints) String() string {\n\tvar buf bytes.Buffer\n\tsep := \"\"\n\tfor _, v := range s {\n\t\tbuf.WriteString(fmt.Sprintf(\"%s%d\", sep, v))\n\t\tsep = \" \"\n\t}\n\treturn buf.String()\n}\n\nfunc reverse(a ints) ints {\n\tr := make(ints, len(a))\n\tfor i := 0; i < len(a); i++ {\n\t\tr[i] = a[len(a)-1-i]\n\t}\n\treturn r\n}\nfunc max(a ints) (int, bool) {\n\tif len(a) == 0 {\n\t\treturn 0, false\n\t}\n\tm := a[0]\n\tfor _, e := range a {\n\t\tif e > m {\n\t\t\tm = e\n\t\t}\n\t}\n\treturn m, true\n}\nfunc sum(a ints) int {\n\tif len(a) == 0 {\n\t\treturn 0\n\t}\n\tsum := 0\n\tfor _, e := range a {\n\t\tsum += e\n\t}\n\treturn sum\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"sort\"\n\t\"strconv\"\n)\n\nfunc getScanner(fp *os.File) *bufio.Scanner {\n\tscanner := bufio.NewScanner(fp)\n\tscanner.Split(bufio.ScanWords)\n\tscanner.Buffer(make([]byte, 500001), 500000)\n\treturn scanner\n}\n\nfunc getNextString(scanner *bufio.Scanner) string {\n\tscanner.Scan()\n\treturn scanner.Text()\n}\n\nfunc getNextInt(scanner *bufio.Scanner) int {\n\ti, _ := strconv.Atoi(getNextString(scanner))\n\treturn i\n}\n\nfunc main() {\n\tfp := os.Stdin\n\tif len(os.Args) > 1 {\n\t\tfp, _ = os.Open(os.Args[1])\n\t}\n\n\tscanner := getScanner(fp)\n\twriter := bufio.NewWriter(os.Stdout)\n\n\tn := getNextInt(scanner)\n\tww := make([]int, n)\n\tsorted := make([]int, n)\n\tvv := make([]bool, n)\n\tmin := 1 << 30\n\tfor i := 0; i < n; i++ {\n\t\tww[i] = getNextInt(scanner)\n\t\tif min > ww[i] {\n\t\t\tmin = ww[i]\n\t\t}\n\t\tsorted[i] = ww[i]\n\t\tvv[i] = false\n\t}\n\tttt := make(map[int]int, 0)\n\tsort.Sort(sort.IntSlice(sorted))\n\tfor i := 0; i < n; i++ {\n\t\tttt[sorted[i]] = i\n\t}\n\tans := 0\n\tfor i := 0; i < n; i++ {\n\t\tif vv[i] {\n\t\t\tcontinue\n\t\t}\n\t\tcur := i\n\t\ts := 0\n\t\tm := 1 << 30\n\t\tan := 0\n\t\tfor {\n\t\t\tvv[cur] = true\n\t\t\tan++\n\t\t\tv := ww[cur]\n\t\t\tif m > v {\n\t\t\t\tm = v\n\t\t\t}\n\t\t\ts += v\n\t\t\tcur = ttt[v]\n\t\t\tif vv[cur] {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tans += minint(s+(an-2)*m, m+s+(an+1)*min)\n\t}\n\n\tfmt.Fprintln(writer, ans)\n\twriter.Flush()\n}\nfunc minint(a int, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nconst MAX = 100000\n\nvar sc = bufio.NewScanner(os.Stdin)\nvar smallest int = MAX\nvar largest int = -1\n\nfunc scanInt() int {\n\tnum, _ := strconv.Atoi(scanString())\n\treturn num\n}\n\nfunc scanString() string {\n\tsc.Scan()\n\treturn sc.Text()\n}\n\nfunc init() {\n\tsc.Split(bufio.ScanWords)\n}\n\nfunc Max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc Min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc countingSort(A []int, n int) []int {\n\tC := make([]int, largest+1)\n\tfor _, e := range A {\n\t\tC[e]++\n\t}\n\tfor i := 1; i <= largest; i++ {\n\t\tC[i] = C[i] + C[i-1]\n\t}\n\tB := make([]int, n)\n\tfor _, e := range A {\n\t\tB[C[e]-1] = e\n\t\tC[e]--\n\t}\n\treturn B\n}\n\nfunc calCost(weights []int) int {\n\tcnt := len(weights)\n\tif cnt == 1 {\n\t\treturn 0\n\t} else if cnt == 2 {\n\t\treturn weights[0] + weights[1]\n\t}\n\n\tcost := 0\n\tmin := MAX\n\tfor _, w := range weights {\n\t\tcost += w\n\t\tmin = Min(w, min)\n\n\t}\n\tcost += (cnt - 2) * min\n\tdiff := ((min - smallest) + (cnt-2)*(min-smallest)) - (2 * (min + smallest))\n\tif diff > 0 {\n\t\tcost -= diff\n\t}\n\treturn cost\n}\n\nfunc main() {\n\tn := scanInt()\n\tA := make([]int, n)\n\tfor i := range A {\n\t\tnum := scanInt()\n\t\tA[i] = num\n\t\tlargest = Max(largest, num)\n\t\tsmallest = Min(smallest, num)\n\t}\n\n\tindexs := make(map[int]int, n)\n\tcost := 0\n\tfor i, e := range countingSort(A, n) {\n\t\tindexs[e] = i\n\t}\n\tseen := make(map[int]bool, n)\n\tfor _, e := range A {\n\t\tif seen[e] {\n\t\t\tcontinue\n\t\t}\n\t\tweights := make([]int, 0)\n\t\tweights = append(weights, e)\n\t\tseen[e] = true\n\n\t\tfor {\n\t\t\te = A[indexs[e]]\n\t\t\tif seen[e] {\n\t\t\t\tcost += calCost(weights)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tweights = append(weights, e)\n\t\t\tseen[e] = true\n\t\t}\n\t}\n\tfmt.Println(cost)\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"os\"\n\t\"sort\"\n\t\"strconv\"\n)\n\n/*********** I/O ***********/\n\nvar (\n\t// ReadString returns a WORD string.\n\tReadString func() string\n\tstdout     *bufio.Writer\n)\n\nfunc init() {\n\tReadString = newReadString(os.Stdin)\n\tstdout = bufio.NewWriter(os.Stdout)\n}\n\nfunc newReadString(ior io.Reader) func() string {\n\tr := bufio.NewScanner(ior)\n\t// r.Buffer(make([]byte, 1024), int(1e+11)) // for AtCoder\n\tr.Buffer(make([]byte, 1024), int(1e+9)) // for Codeforces\n\t// Split sets the split function for the Scanner. The default split function is ScanLines.\n\t// Split panics if it is called after scanning has started.\n\tr.Split(bufio.ScanWords)\n\n\treturn func() string {\n\t\tif !r.Scan() {\n\t\t\tpanic(\"Scan failed\")\n\t\t}\n\t\treturn r.Text()\n\t}\n}\n\n// ReadInt returns an integer.\nfunc ReadInt() int {\n\treturn int(readInt64())\n}\nfunc ReadInt2() (int, int) {\n\treturn int(readInt64()), int(readInt64())\n}\nfunc ReadInt3() (int, int, int) {\n\treturn int(readInt64()), int(readInt64()), int(readInt64())\n}\nfunc ReadInt4() (int, int, int, int) {\n\treturn int(readInt64()), int(readInt64()), int(readInt64()), int(readInt64())\n}\n\n// ReadInt64 returns as integer as int64.\nfunc ReadInt64() int64 {\n\treturn readInt64()\n}\nfunc ReadInt64_2() (int64, int64) {\n\treturn readInt64(), readInt64()\n}\nfunc ReadInt64_3() (int64, int64, int64) {\n\treturn readInt64(), readInt64(), readInt64()\n}\nfunc ReadInt64_4() (int64, int64, int64, int64) {\n\treturn readInt64(), readInt64(), readInt64(), readInt64()\n}\n\nfunc readInt64() int64 {\n\ti, err := strconv.ParseInt(ReadString(), 0, 64)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn i\n}\n\n// ReadIntSlice returns an integer slice that has n integers.\nfunc ReadIntSlice(n int) []int {\n\tb := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tb[i] = ReadInt()\n\t}\n\treturn b\n}\n\n// ReadInt64Slice returns as int64 slice that has n integers.\nfunc ReadInt64Slice(n int) []int64 {\n\tb := make([]int64, n)\n\tfor i := 0; i < n; i++ {\n\t\tb[i] = ReadInt64()\n\t}\n\treturn b\n}\n\n// ReadFloat64 returns an float64.\nfunc ReadFloat64() float64 {\n\treturn float64(readFloat64())\n}\n\nfunc readFloat64() float64 {\n\tf, err := strconv.ParseFloat(ReadString(), 64)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn f\n}\n\n// ReadFloatSlice returns an float64 slice that has n float64.\nfunc ReadFloat64Slice(n int) []float64 {\n\tb := make([]float64, n)\n\tfor i := 0; i < n; i++ {\n\t\tb[i] = ReadFloat64()\n\t}\n\treturn b\n}\n\n// ReadRuneSlice returns a rune slice.\nfunc ReadRuneSlice() []rune {\n\treturn []rune(ReadString())\n}\n\n/*********** Debugging ***********/\n\n// ZeroPaddingRuneSlice returns binary expressions of integer n with zero padding.\n// For debugging use.\nfunc ZeroPaddingRuneSlice(n, digitsNum int) []rune {\n\tsn := fmt.Sprintf(\"%b\", n)\n\n\tresidualLength := digitsNum - len(sn)\n\tif residualLength <= 0 {\n\t\treturn []rune(sn)\n\t}\n\n\tzeros := make([]rune, residualLength)\n\tfor i := 0; i < len(zeros); i++ {\n\t\tzeros[i] = '0'\n\t}\n\n\tres := []rune{}\n\tres = append(res, zeros...)\n\tres = append(res, []rune(sn)...)\n\n\treturn res\n}\n\n/*********** DP sub-functions ***********/\n\n// ChMin accepts a pointer of integer and a target value.\n// If target value is SMALLER than the first argument,\n//\tthen the first argument will be updated by the second argument.\nfunc ChMin(updatedValue *int, target int) bool {\n\tif *updatedValue > target {\n\t\t*updatedValue = target\n\t\treturn true\n\t}\n\treturn false\n}\n\n// ChMax accepts a pointer of integer and a target value.\n// If target value is LARGER than the first argument,\n//\tthen the first argument will be updated by the second argument.\nfunc ChMax(updatedValue *int, target int) bool {\n\tif *updatedValue < target {\n\t\t*updatedValue = target\n\t\treturn true\n\t}\n\treturn false\n}\n\n// NthBit returns nth bit value of an argument.\n// n starts from 0.\nfunc NthBit(num, nth int) int {\n\treturn num >> uint(nth) & 1\n}\n\n// OnBit returns the integer that has nth ON bit.\n// If an argument has nth ON bit, OnBit returns the argument.\nfunc OnBit(num, nth int) int {\n\treturn num | (1 << uint(nth))\n}\n\n// OffBit returns the integer that has nth OFF bit.\n// If an argument has nth OFF bit, OffBit returns the argument.\nfunc OffBit(num, nth int) int {\n\treturn num & ^(1 << uint(nth))\n}\n\n// PopCount returns the number of ON bit of an argument.\nfunc PopCount(num int) int {\n\tres := 0\n\n\tfor i := 0; i < 70; i++ {\n\t\tif ((num >> uint(i)) & 1) == 1 {\n\t\t\tres++\n\t\t}\n\t}\n\n\treturn res\n}\n\n/*********** Arithmetic ***********/\n\n// Max returns the max integer among input set.\n// This function needs at least 1 argument (no argument causes panic).\nfunc Max(integers ...int) int {\n\tm := integers[0]\n\tfor i, integer := range integers {\n\t\tif i == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif m < integer {\n\t\t\tm = integer\n\t\t}\n\t}\n\treturn m\n}\n\n// Min returns the min integer among input set.\n// This function needs at least 1 argument (no argument causes panic).\nfunc Min(integers ...int) int {\n\tm := integers[0]\n\tfor i, integer := range integers {\n\t\tif i == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif m > integer {\n\t\t\tm = integer\n\t\t}\n\t}\n\treturn m\n}\n\n// Sum returns multiple integers sum.\nfunc Sum(integers ...int) int {\n\ts := 0\n\n\tfor _, i := range integers {\n\t\ts += i\n\t}\n\n\treturn s\n}\n\n// PowInt is integer version of math.Pow\n// PowInt calculate a power by Binary Power (二分累乗法(O(log e))).\nfunc PowInt(a, e int) int {\n\tif a < 0 || e < 0 {\n\t\tpanic(errors.New(\"[argument error]: PowInt does not accept negative integers\"))\n\t}\n\n\tif e == 0 {\n\t\treturn 1\n\t}\n\n\tif e%2 == 0 {\n\t\thalfE := e / 2\n\t\thalf := PowInt(a, halfE)\n\t\treturn half * half\n\t}\n\n\treturn a * PowInt(a, e-1)\n}\n\n// AbsInt is integer version of math.Abs\nfunc AbsInt(a int) int {\n\tif a < 0 {\n\t\treturn -a\n\t}\n\treturn a\n}\n\n// Gcd returns the Greatest Common Divisor of two natural numbers.\n// Gcd only accepts two natural numbers (a, b >= 1).\n// 0 or negative number causes panic.\n// Gcd uses the Euclidean Algorithm.\nfunc Gcd(a, b int) int {\n\tif a <= 0 || b <= 0 {\n\t\tpanic(errors.New(\"[argument error]: Gcd only accepts two NATURAL numbers\"))\n\t}\n\tif a < b {\n\t\ta, b = b, a\n\t}\n\n\t// Euclidean Algorithm\n\tfor b > 0 {\n\t\tdiv := a % b\n\t\ta, b = b, div\n\t}\n\n\treturn a\n}\n\n// Lcm returns the Least Common Multiple of two natural numbers.\n// Lcd only accepts two natural numbers (a, b >= 1).\n// 0 or negative number causes panic.\n// Lcd uses the Euclidean Algorithm indirectly.\nfunc Lcm(a, b int) int {\n\tif a <= 0 || b <= 0 {\n\t\tpanic(errors.New(\"[argument error]: Gcd only accepts two NATURAL numbers\"))\n\t}\n\n\t// a = a'*gcd, b = b'*gcd, a*b = a'*b'*gcd^2\n\t// a' and b' are relatively prime numbers\n\t// gcd consists of prime numbers, that are included in a and b\n\tgcd := Gcd(a, b)\n\n\t// not (a * b / gcd), because of reducing a probability of overflow\n\treturn (a / gcd) * b\n}\n\n// Strtoi is a wrapper of strconv.Atoi().\n// If strconv.Atoi() returns an error, Strtoi calls panic.\nfunc Strtoi(s string) int {\n\tif i, err := strconv.Atoi(s); err != nil {\n\t\tpanic(errors.New(\"[argument error]: Strtoi only accepts integer string\"))\n\t} else {\n\t\treturn i\n\t}\n}\n\n// PrintIntsLine returns integers string delimited by a space.\nfunc PrintIntsLine(A ...int) string {\n\tres := []rune{}\n\n\tfor i := 0; i < len(A); i++ {\n\t\tstr := strconv.Itoa(A[i])\n\t\t// str := strconv.FormatInt(A[i], 10)  // 64bit int version\n\t\tres = append(res, []rune(str)...)\n\n\t\tif i != len(A)-1 {\n\t\t\tres = append(res, ' ')\n\t\t}\n\t}\n\n\treturn string(res)\n}\n\n/********** FAU standard libraries **********/\n\n//fmt.Sprintf(\"%b\\n\", 255) \t// binary expression\n\n/********** I/O usage **********/\n\n//str := ReadString()\n//i := ReadInt()\n//X := ReadIntSlice(n)\n//S := ReadRuneSlice()\n//a := ReadFloat64()\n//A := ReadFloat64Slice(n)\n\n//str := ZeroPaddingRuneSlice(num, 32)\n//str := PrintIntsLine(X...)\n\n/*******************************************************************/\n\nconst MOD = 1000000000 + 7\nconst ALPHABET_NUM = 26\nconst INF_INT64 = math.MaxInt64\nconst INF_BIT60 = 1 << 60\n\nconst VMAX = 10000\n\nvar n int\nvar A, B []int\nvar s int\nvar T [VMAX + 1]int\n\nfunc main() {\n\tn = ReadInt()\n\tA = ReadIntSlice(n)\n\ts = Min(A...)\n\tans := solve()\n\tfmt.Println(ans)\n}\n\nfunc solve() int {\n\tans := 0\n\n\tV := make([]bool, n)\n\tB = make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tB[i] = A[i]\n\t\tV[i] = false\n\t}\n\tsort.Sort(sort.IntSlice(B))\n\n\tfor i := 0; i < n; i++ {\n\t\tT[B[i]] = i\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tif V[i] {\n\t\t\tcontinue\n\t\t}\n\n\t\tcur := i\n\t\tS := 0\n\t\tm := VMAX\n\t\tan := 0\n\t\tfor {\n\t\t\tV[cur] = true\n\t\t\tan++\n\t\t\tv := A[cur]\n\t\t\tm = Min(m, v)\n\t\t\tS += v\n\t\t\tcur = T[v]\n\t\t\tif V[cur] {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tans += Min(S+(an-2)*m, m+S+(an+1)*s)\n\t}\n\n\treturn ans\n}\n\n// MODはとったか？\n// 遷移だけじゃなくて最後の最後でちゃんと取れよ？\n\n/*******************************************************************/\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"sort\"\n\t\"strconv\"\n)\n\nfunc nextInt(scanner *bufio.Scanner) int {\n\tscanner.Scan()\n\tnum, _ := strconv.Atoi(scanner.Text())\n\treturn num\n}\n\nfunc scanIntArray() []int {\n\tsc := bufio.NewScanner(os.Stdin)\n\tsc.Split(bufio.ScanWords)\n\tn := nextInt(sc)\n\tresult := []int{}\n\tfor i := 0; i < n; i++ {\n\t\tresult = append(result, nextInt(sc))\n\t}\n\n\treturn result\n}\n\nfunc main() {\n\tinput := scanIntArray()\n\n\t// make sorted array\n\tsortedArray := make([]int, len(input))\n\tcopy(sortedArray, input)\n\tsort.Slice(sortedArray, func(i, j int) bool { return i < j })\n\tsort.Sort(sort.IntSlice(sortedArray))\n\n\t// counted idx array\n\tfinishes := make([]bool, len(input))\n\n\t// minimum value in array\n\tminOfAll := sortedArray[0]\n\n\ttotal := 0\n\n\tfor i := 0; i < len(input)-1; i++ {\n\t\tif finishes[i] {\n\t\t\tcontinue\n\t\t}\n\n\t\tif input[i] == sortedArray[i] {\n\t\t\tfinishes[i] = true\n\t\t\t// already sorted\n\t\t\tcontinue\n\t\t}\n\n\t\tnow := input[i]\n\t\t// total of values in block\n\t\tcounta := 0\n\t\t// number of values in block\n\t\tnum := 0\n\t\t// minimum number in block\n\t\tminOfBlock := math.MaxInt64\n\n\t\tfor {\n\t\t\tidx := findIndexInSorted(now, sortedArray)\n\n\t\t\t// if true, this block is already proccessed\n\t\t\tif finishes[idx] {\n\t\t\t\tr1 := counta + minOfBlock + (num+1)*minOfAll\n\t\t\t\tr2 := counta + (num-2)*minOfBlock\n\t\t\t\tif r1 > r2 {\n\t\t\t\t\ttotal += r2\n\t\t\t\t} else {\n\t\t\t\t\ttotal += r1\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif now < minOfBlock {\n\t\t\t\tminOfBlock = now\n\t\t\t}\n\n\t\t\tnext := input[idx]\n\t\t\tcounta += now\n\t\t\tnum++\n\t\t\tfinishes[idx] = true\n\t\t\tnow = next\n\t\t}\n\t}\n\n\tfmt.Println(total)\n\n}\n\nfunc findIndexInSorted(val int, sorted []int) int {\n\tfor i, v := range sorted {\n\t\tif val == v {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn -1\n}\n\n"
  },
  {
    "language": "OCaml",
    "code": "let quick_sort a cmp =\n  let rec partition p r =\n    let swap i j = let t = a.(i) in a.(i) <- a.(j); a.(j) <- t\n    in\n    let rec exchange i j =\n      if j >= r then (swap (i + 1) r; i + 1)\n      else if cmp a.(j) a.(r) <= 0 then (swap (i + 1) j; exchange (i + 1) (j + 1))\n      else exchange i (j + 1)\n    in exchange (p - 1) p\n  and doit p r =\n    if p < r then begin\n      let q = partition p r in\n      doit p (q - 1);\n      doit q r\n    end in\n  doit 0 (Array.length a - 1)\n\nlet calc_cost a n =\n  let b = Array.copy a in\n  quick_sort b compare;\n  let min_a = b.(0) in\n  let max_a = b.(n - 1) in\n  let b_i = Array.make (max_a + 1) 0 in\n  Array.iteri (fun i e -> b_i.(e) <- i) b;\n  let v = Array.make n false in\n  let rec doit i cost =\n    if i = n then cost\n    else if v.(i) then doit (i + 1) cost\n    else begin\n      let rec aux j ws =\n        v.(j) <- true;\n        let w = a.(j) in\n        if v.(b_i.(w)) then w :: ws\n        else aux b_i.(w) (w :: ws)\n      in\n      let ws = aux i [] in\n      let n_w = List.length ws in\n      let sum_w = List.fold_left (+) 0 ws in\n      let min_w = List.fold_left min max_a ws in\n      doit (i + 1) (cost + (min (sum_w + (n_w - 2) * min_w) (sum_w + min_w + (n_w + 1) * min_a)))\n    end in\n  doit 0 0\n\nlet () =\n  let n = read_int () in\n  let a = Array.init n (fun _ -> Scanf.scanf \"%d \" (fun e -> e)) in\n  Printf.printf \"%d\\n\" (calc_cost a n)"
  },
  {
    "language": "OCaml",
    "code": "let quick_sort a cmp =\n  let partition p r =\n    let x = a.(r) in\n    let swap i j =\n      let t = a.(i) in a.(i) <- a.(j); a.(j) <- t\n    in\n    let rec doit i j =\n      if j >= r then i\n      else begin\n        if cmp a.(j) x <= 0 then (swap (i + 1) j; doit (i + 1) (j + 1))\n        else doit i (j + 1)\n      end\n    in\n    let i = doit (p - 1) p in\n    swap (i + 1) r;\n    i + 1\n  in\n  let rec doit p r =\n    if p < r then begin\n      let q = partition p r in\n      doit p (q - 1);\n      doit q r\n    end\n  in\n  doit 0 (Array.length a - 1)\n\nlet calc_cost a n =\n  let b = Array.copy a in\n  quick_sort b compare;\n  let min_a = b.(0) in\n  let max_a = b.(n - 1) in\n  let b_i = Array.make (max_a + 1) 0 in\n  Array.iteri (fun i e -> b_i.(e) <- i) b;\n  let v = Array.make n false in\n  let rec doit i cost =\n    if i = n then cost\n    else if v.(i) then doit (i + 1) cost\n    else begin\n      let rec aux j ws =\n        v.(j) <- true;\n        let w = a.(j) in\n        if v.(b_i.(w)) then w :: ws\n        else aux b_i.(w) (w :: ws)\n      in\n      let ws = aux i [] in\n      let n_w = List.length ws in\n      let sum_w = List.fold_left (+) 0 ws in\n      let min_w = List.fold_left min max_a ws in\n      let c = min (sum_w + (n_w - 2) * min_w) (sum_w + min_w + (n_w + 1) * min_a) in\n      doit (i + 1) (cost + c)\n    end\n  in\n  doit 0 0\n\nlet () =\n  let n = read_int () in\n  let a = Array.init n (fun _ -> Scanf.scanf \"%d \" (fun e -> e)) in\n  Printf.printf \"%d\\n\" (calc_cost a n)"
  },
  {
    "language": "OCaml",
    "code": "let quick_sort a n cmp =\n  let swap i j = let tmp = a.(i) in a.(i) <- a.(j); a.(j) <- tmp in\n  let partition p r =\n    let i = ref p in\n    for j = p to r - 1 do\n      if cmp a.(j) a.(r) <= 0 then (swap !i j; incr i)\n    done;\n    swap !i r;\n    !i in\n  let rec doit p r =\n    if p >= r then () else\n    let q = partition p r in\n    doit p (q - 1);\n    doit (q + 1) r in\n  doit 0 (n - 1)\n\nlet calc_cost a n =\n  let b = Array.copy a in\n  quick_sort b n compare;\n  let t = Array.make (b.(n-1) + 1) 0 in\n  Array.iteri (fun i e -> t.(e) <- i) b;\n  let p = Array.make n false in\n  let rec cycle i acc =\n    p.(i) <- true;\n    let j = t.(a.(i)) in\n    if p.(j) then a.(i) :: acc\n    else cycle j (a.(i) :: acc) in\n  let cycle i = cycle i [] in\n  let rec doit i acc =\n    if i = n then acc\n    else if p.(i) then doit (i + 1) acc\n    else\n      let ws = cycle i in\n      let m = List.length ws in\n      let s = List.fold_left (+) 0 ws in\n      let z = List.fold_left min max_int ws in\n      doit (i + 1) (acc + (min (s + (m - 2)*z) (s + z + (m + 1)*b.(0)))) in\n  doit 0 0\n\nlet () =\n  let n = read_int () in\n  let a = Array.init n (fun _ -> Scanf.scanf \"%d \" (fun e -> e)) in\n  calc_cost a n |> Printf.printf \"%d\\n\""
  },
  {
    "language": "OCaml",
    "code": "let quick_sort a cmp =\n  let rec partition p r =\n    let swap i j = let t = a.(i) in a.(i) <- a.(j); a.(j) <- t\n    in\n    let rec exchange i j =\n      if j = r then (swap (i + 1) r; i + 1)\n      else if cmp a.(j) a.(r) <= 0 then (swap (i + 1) j; exchange (i + 1) (j + 1))\n      else exchange i (j + 1)\n    in exchange (p - 1) p\n  and doit p r =\n    if p < r then begin\n      let q = partition p r in\n      doit p (q - 1);\n      doit q r\n    end in\n  doit 0 (Array.length a - 1)\n\nlet calc_cost a n =\n  let b = Array.copy a in\n  quick_sort b compare;\n  let min_a = b.(0) in\n  let max_a = b.(n - 1) in\n  let b_i = Array.make (max_a + 1) 0 in\n  Array.iteri (fun i e -> b_i.(e) <- i) b;\n  let v = Array.make n false in\n  let rec doit i cost =\n    if i = n then cost\n    else if v.(i) then doit (i + 1) cost\n    else\n      let rec aux j ws =\n        v.(j) <- true;\n        let w = a.(j) in\n        if v.(b_i.(w)) then w :: ws\n        else aux b_i.(w) (w :: ws)\n      in\n      let ws = aux i [] in\n      let n_w = List.length ws in\n      let sum_w = List.fold_left (+) 0 ws in\n      let min_w = List.fold_left min max_a ws in\n      doit (i + 1) (cost + (min (sum_w + (n_w - 2) * min_w) (sum_w + min_w + (n_w + 1) * min_a)))\n  in doit 0 0\n\nlet () =\n  let n = read_int () in\n  let a = Array.init n (fun _ -> Scanf.scanf \"%d \" (fun e -> e)) in\n  Printf.printf \"%d\\n\" (calc_cost a n)"
  },
  {
    "language": "OCaml",
    "code": "let quick_sort a n cmp =\n  let swap i j = let tmp = a.(i) in a.(i) <- a.(j); a.(j) <- tmp in\n  let partition p r =\n    let i = ref p in\n    for j = p to r - 1 do\n      if cmp a.(j) a.(r) <= 0 then (swap !i j; incr i)\n    done;\n    swap !i r;\n    !i in\n  let rec doit p r =\n    if p >= r then () else\n    let q = partition p r in\n    doit p (q - 1);\n    doit (q + 1) r in\n  doit 0 (n - 1)\n\nlet calc_cost a n =\n  let b = Array.copy a in\n  quick_sort b n compare;\n  let t = Array.make (b.(n-1) + 1) 0 in\n  Array.iteri (fun i e -> t.(e) <- i) b;\n  let p = Array.make n false in\n  let rec duduwa i acc =\n    p.(i) <- true;\n    if p.(t.(a.(i))) then a.(i) :: acc\n    else duduwa t.(a.(i)) (a.(i) :: acc) in\n  let rec doit i acc =\n    if i = n then acc\n    else if p.(i) then doit (i + 1) acc\n    else\n      let ws = duduwa i [] in\n      let m = List.length ws in\n      let s = List.fold_left (+) 0 ws in\n      let z = List.fold_left min max_int ws in\n      doit (i + 1) (acc + (min (s + (m - 2)*z) (s + z + (m + 1)*b.(0)))) in\n  doit 0 0\n\nlet () =\n  let n = read_int () in\n  let a = Array.init n (fun _ -> Scanf.scanf \"%d \" (fun e -> e)) in\n  calc_cost a n |> Printf.printf \"%d\\n\""
  },
  {
    "language": "D",
    "code": "import std.array, std.stdio, std.conv, std.string, std.math, std.random, std.range,std.functional;\nimport std.algorithm.searching, std.algorithm.sorting, std.algorithm.iteration, std.algorithm.comparison;\n \nlong count;\n \nvoid main()\n{\n    readln();\n    int[] list = readln().split.to!(int[]);\n    auto sortedList = list.dup.sort();\n\n    bool[] bList;\n    long[][] cycleList;\n    bList.length = list.length;\n\n    foreach(i; 0..list.length)\n    {\n        if(bList[i])\n            continue;\n        long nextIndex = i;\n        long[] cycle;\n        while(true)\n        {\n            bList[nextIndex] = true;\n            cycle ~= list[nextIndex];\n            nextIndex = sortedList.countUntil(list[nextIndex]);\n            if(i == nextIndex)\n                break;\n        }\n        cycleList ~= cycle;\n    }\n    long min = sortedList[0];\n    foreach(c; cycleList)\n    {\n        long cMin = c.reduce!\"a<b?a:b\";\n        long a = cMin * (c.length - 2) + c.sum();\n        long b = min * (c.length - 1) + c.sum() - cMin + (min+cMin)*2;\n        count += a<b?a:b;\n    }\n    writeln(count);\n}\n \nsizediff_t minIndex(alias pred=\"a<b\", R) (R list)\n    if(isForwardRange!R && !isInfinite!R && is(typeof(binaryFun!pred(list.front, list.front))))\n{\n    assert(!list.empty);\n    typeof(list.front) min = list.front;\n    sizediff_t minPos;\n    sizediff_t curPos;\n    for(list.popFront(); !list.empty; list.popFront())\n    {\n        curPos++;\n \n        if(binaryFun!pred(list.front, min))\n        {\n            min = list.front;\n            minPos = curPos;\n        }\n    }\n    return minPos;\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.array, std.stdio, std.conv, std.string, std.math, std.random, std.range,std.functional;\nimport std.algorithm.searching, std.algorithm.sorting, std.algorithm.iteration, std.algorithm.comparison;\n \nlong count;\n \nvoid main()\n{\n    readln();\n    int[] list = readln().split.to!(int[]);\n    auto sortedList = list.dup.sort();\n\n    bool[] bList;\n    long[][] cycleList;\n    bList.length = list.length;\n\n    foreach(i; 0..list.length)\n    {\n        if(bList[i])\n            continue;\n        long nextIndex = i;\n        long[] cycle;\n        while(true)\n        {\n            bList[nextIndex] = true;\n            cycle ~= list[nextIndex];\n            nextIndex = sortedList.countUntil(list[nextIndex]);\n            if(i == nextIndex)\n                break;\n        }\n        cycleList ~= cycle;\n    }\n    long min = sortedList[0];\n    foreach(c; cycleList)\n    {\n        long cMin = c.reduce!\"a<b?a:b\";\n        long a = cMin * (c.length - 2) + c.sum();\n        long b = min * (c.length - 1) + c.sum() - cMin + (min+cMin)*2;\n        count += a<b?a:b;\n    }\n    writeln(count);\n}\n \nsizediff_t minIndex(alias pred=\"a<b\", R) (R list)\n    if(isForwardRange!R && !isInfinite!R && is(typeof(binaryFun!pred(list.front, list.front))))\n{\n    assert(!list.empty);\n    typeof(list.front) min = list.front;\n    sizediff_t minPos;\n    sizediff_t curPos;\n    for(list.popFront(); !list.empty; list.popFront())\n    {\n        curPos++;\n \n        if(binaryFun!pred(list.front, min))\n        {\n            min = list.front;\n            minPos = curPos;\n        }\n    }\n    return minPos;\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.array, std.stdio, std.conv, std.string, std.math, std.random, std.range,std.functional;\nimport std.algorithm.searching, std.algorithm.sorting, std.algorithm.iteration, std.algorithm.comparison;\n \nlong count;\n \nvoid main()\n{\n    readln();\n    int[] list = readln().split.to!(int[]);\n    auto sortedList = list.dup.sort();\n\n    foreach(i; 0..sortedList.length)\n    {\n        long minIndex = -1;\n        while(sortedList[i] != list[i])\n        {\n            if(minIndex == -1)\n                minIndex = list.countUntil(sortedList[i]);\n            long swapIndex = list.countUntil(sortedList[minIndex]);\n            count += list[minIndex] + list[swapIndex];\n\n            auto tmp = list[minIndex];\n            list[minIndex] = list[swapIndex];\n            list[swapIndex] = tmp;\n            minIndex = swapIndex;\n        }\n    }\n    writeln(count);\n}\n \nsizediff_t minIndex(alias pred=\"a<b\", R) (R list)\n    if(isForwardRange!R && !isInfinite!R && is(typeof(binaryFun!pred(list.front, list.front))))\n{\n    assert(!list.empty);\n    typeof(list.front) min = list.front;\n    sizediff_t minPos;\n    sizediff_t curPos;\n    for(list.popFront(); !list.empty; list.popFront())\n    {\n        curPos++;\n \n        if(binaryFun!pred(list.front, min))\n        {\n            min = list.front;\n            minPos = curPos;\n        }\n    }\n    return minPos;\n}\n"
  },
  {
    "language": "D",
    "code": "let quick_sort a n cmp =\n  let swap i j = let tmp = a.(i) in a.(i) <- a.(j); a.(j) <- tmp in\n  let partition p r =\n    let i = ref p in\n    for j = p to r - 1 do\n      if cmp a.(j) a.(r) <= 0 then (swap !i j; incr i)\n    done;\n    swap !i r;\n    !i in\n  let rec doit p r =\n    if p >= r then () else\n    let q = partition p r in\n    doit p (q - 1);\n    doit (q + 1) r in\n  doit 0 (n - 1)\n\nlet calc_cost a n =\n  let b = Array.copy a in\n  quick_sort b n compare;\n  let t = Array.make (b.(n-1) + 1) 0 in\n  Array.iteri (fun i e -> t.(e) <- i) b;\n  let p = Array.make n false in\n  let rec cycle i acc =\n    p.(i) <- true;\n    let j = t.(a.(i)) in\n    if p.(j) then a.(i) :: acc\n    else cycle j (a.(i) :: acc) in\n  let cycle i = cycle i [] in\n  let rec doit i acc =\n    if i = n then acc\n    else if p.(i) then doit (i + 1) acc\n    else\n      let ws = cycle i in\n      let m = List.length ws in\n      let s = List.fold_left (+) 0 ws in\n      let z = List.fold_left min max_int ws in\n      doit (i + 1) (acc + (min (s + (m - 2)*z) (s + z + (m + 1)*b.(0)))) in\n  doit 0 0\n\nlet () =\n  let n = read_int () in\n  let a = Array.init n (fun _ -> Scanf.scanf \"%d \" (fun e -> e)) in\n  calc_cost a n |> Printf.printf \"%d\\n\"\n"
  },
  {
    "language": "Python",
    "code": "def partition(a, p, r):\n    x = a[r]\n    i = p - 1\n    for j in range(p, r):\n        if a[j] <= x:\n            i += 1\n            tmp = a[i]\n            a[i] = a[j]\n            a[j] = tmp\n    tmp = a[i+1]\n    a[i+1] = a[r]\n    a[r] = tmp\n    return i + 1\n\n\ndef quick_sort(a, p, r):\n    if p < r:\n        q = partition(a, p, r)\n        quick_sort(a, p, q-1)\n        quick_sort(a, q+1, r)\n\n\ndef make_cyclic(w, v):\n    flags = [True] * len(w)\n\n    cyclics = []\n    for i in range(len(w)):\n        if flags[i]:\n            flags[i] = False\n            cycle = [w[i]]\n            now = w[i]\n            while True:\n                j = v.index(now)\n                if j == i:\n                    break\n                cycle.append(w[j])\n                now = w[j]\n                flags[j] = False\n            cyclics.append(cycle)\n\n    return cyclics\n\n\ndef min_cost_sort(w):\n    v = w.copy()\n    quick_sort(v, 0, len(v) - 1)\n\n    cyclics = make_cyclic(w, v)\n\n    ans = 0\n    for cycle in cyclics:\n        inner_cycle = min(cycle) * (len(cycle) - 2) + sum(cycle)\n        if len(set(w) - set(cycle)) >= 1:\n            outer_cycle = min(cycle) + min(set(w) - set(cycle)) * (len(cycle) + 1) + sum(cycle)\n        else:\n            outer_cycle = inner_cycle + 1\n        ans += min(inner_cycle, outer_cycle)\n\n    return ans\n\nn = int(input())\nw = [int(x) for x in input().split()]\n\nprint(min_cost_sort(w))\n"
  },
  {
    "language": "Python",
    "code": "\n\nMAX_NUM = int(1E4 + 1)\n\nif __name__ == '__main__':\n    N = int(input())\n    A = [int(i) for i in input().strip().split()]\n    sorted_A = sorted(A)\n    smallest = sorted_A[0]\n    correct_pos = [0] * MAX_NUM\n    flag_A = [False] * MAX_NUM\n    for i, val in enumerate(sorted_A):\n        correct_pos[val] = i\n\n    ans = 0\n    for i in range(len(A)):\n        if flag_A[A[i]]:\n            continue\n        next_pos = i\n        sum = 0\n        m = 1E4\n        an = 0\n        while True:\n            an += 1\n            val = A[next_pos]\n            sum += val\n            m = min([m, val])\n            flag_A[A[next_pos]] = True\n            next_pos = correct_pos[val]\n            if flag_A[A[next_pos]]:\n                break\n        ans += min([sum + (an - 2) * m, m + sum + (an + 1) * smallest])\n\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_6_D\n#????°???????????????????\ndef partition(target_list, l, r):\n    x = target_list[r]\n    i = l - 1\n\n    for j in range(l, r):\n        if target_list[j] <= x:\n            i = i + 1\n            tmp = target_list[i]\n            target_list[i] = target_list[j]\n            target_list[j] = tmp\n    tmp = target_list[r]\n    target_list[r] = target_list[i + 1]\n    target_list[i + 1] = tmp\n    \n    return  i + 1\n\ndef quick_sort(target_list, l, r):\n    if l < r:\n        c = partition(target_list, l, r)\n        quick_sort(target_list, l, c - 1)\n        quick_sort(target_list, c + 1, r)\n\ndef processA(target_list, correct_list, i):\n\n    cost = 0\n    while not correct_list[i] == target_list[i]:\n        min_i = target_list.index(correct_list[i])\n        change_i = target_list.index(correct_list[min_i])\n        cost += (target_list[min_i] + target_list[change_i])\n        target_list[min_i], target_list[change_i] = target_list[change_i], target_list[min_i]\n    return cost\n    \ndef processB(target_list, correct_list, i):\n    minv = correct_list[0]\n    target = correct_list[i]\n    if minv == target:\n        return 0\n    cost = (minv + target)\n    \n    mmi = target_list.index(minv)\n    smi = target_list.index(target)\n    target_list[mmi], target_list[smi] = target_list[smi], target_list[mmi]\n    \n    while not correct_list[i] == target_list[i]:\n        min_i = target_list.index(correct_list[i])\n        change_i = target_list.index(correct_list[min_i])\n        cost += (target_list[min_i] + target_list[change_i])\n        target_list[min_i], target_list[change_i] = target_list[change_i], target_list[min_i]\n    return cost\n    \ndef minimum_cost_sort(target_list):\n    correct_list = [a for a in target_list]\n    quick_sort(correct_list, 0, len(correct_list) - 1)\n    cost = 0\n    i = 0\n    while not correct_list == target_list:\n        cost_b = processB([a for a in target_list], correct_list, i)\n        cost_a = processA(target_list, correct_list, i)\n        cost += min(cost_a, cost_b)\n        #print(cost_a, cost_b)\n        #print(target_list)\n        i += 1\n    return cost\ndef main():\n    n_list = input()\n    target_list = [int(s) for s in input().split()]\n    print(minimum_cost_sort(target_list))\n    \nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "input()\na=list(map(int,input().split()))\nb=sorted(a)\nc=0\nfor i in range(len(a)):\n x=a.index(b[i])\n j=0\n while x>i:\n  j+=1\n  y=a.index(b[x])\n  c+=a[y]\n  a[x],a[y]=a[y],a[x]\n  x=y\n c+=min(b[i]*j,b[i]*2+b[0]*(j+2))\nprint(c)\n"
  },
  {
    "language": "Python",
    "code": "def solve(a, n):\n    vmax = 10000\n    ans = 0\n    all_min = min(a)\n    b = sorted(a)\n    v = [False] * n\n\n    t = {}\n    for i in range(n):\n        t[b[i]] = i\n    for i in range(n):\n        if v[i]:\n            continue\n        cur = i\n        w_sum = 0\n        w_min = vmax\n        an = 0\n        while True:\n            v[cur] = True\n            an += 1\n            v_cur = a[cur]\n            w_min = min(w_min, v_cur)\n            w_sum += v_cur\n            cur = t[v_cur]\n            if v[cur]:\n                break\n        ans += min(w_sum + (an-2) * w_min, w_min + w_sum + (an+1) * all_min)\n\n    return ans\n\n\nn = int(input())\na = [int(v) for v in input().split()]\n\nans = solve(a, n)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "def get_weights():\n    input()\n    return map(int, raw_input().split())\n\n#weights: list\ndef minimam_cost_sort(weights):\n    lol = []\n    for i in weights:\n        if i !=0:\n            j = i\n            l = [j]\n            while weights[j - 1] != 0:\n                l.append(weights[j - 1])\n                j = weights[j - 1]\n                weights[j - 1] = 0\n            l.sort()\n            lol.append(l)\n\n    lol.sort()\n    s = 0\n    for l in lol:\n        s += get_wol(l)\n\n    print s\n\ndef get_wol(l):\n    sub = (l[0] - 1) * (len(l) - 1) - (l[0] + 1) * 2\n    s = sum(l) + (l[0] * (len(l) - 2))\n    if sub > 0:\n        return s - sub\n    return s\n\nminimam_cost_sort(get_weights())"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nline = input()\nL = [int(x) for x in line.split()]\n\nflags = [False] * n\nloops = []\n\nS = sorted(L)\nI = [S.index(x) for x in L]\nfor idx, x in enumerate(I):\n    if flags[x]:\n        continue\n    if x == idx:\n        flags[idx] = True\n        continue\n\n    ws = []\n    while S[x] not in ws:\n        flags[x] = True\n        ws.append(S[x])\n        x = I[x]\n    loops.append(ws)\n\ncost = 0\nfor loop in loops:\n    a = sum(loop) + (len(loop) - 2) * min(loop)\n    b = sum(loop) + min(loop) + (len(loop) + 1) * min(L)\n    cost += min(a, b)\n\nprint(cost)"
  },
  {
    "language": "Python",
    "code": "n=int(input())\na=list(map(int, input().split()))\nb=sorted(a)\nc=0\nfor i in range(n):\n x=a.index(b[i])\n j=0\n while x>i:\n  j+=1\n  y=a.index(b[x])\n  c+=a[y]\n  a[x],a[y]=a[y],a[x]\n  x=y\n c+=min(b[i]*j,b[i]*2+b[0]*(j+2))\nprint(c)\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    n = int(input())\n    array = [int(x) for x in input().split()]\n    sorted_array = sorted(array)\n\n    groups = []\n    for i in range(len(array)):\n        moving_src_val = array[i]\n        if not moving_src_val:\n            continue\n        group = [moving_src_val]\n        while True:\n            moving_tgt_idx = sorted_array.index(moving_src_val)\n            moving_tgt_val = array[moving_tgt_idx]\n            if moving_tgt_val in group:\n                break\n            group.append(moving_tgt_val)\n            array[moving_tgt_idx] = False\n            moving_src_val = moving_tgt_val\n        array[i] = False\n        groups.append(group)\n\n    #print(groups)\n\n    min_cost = 0\n    min_in_array = sorted_array[0]\n    for group in groups:\n        n_group = len(group)\n        if n_group == 1:\n            continue\n        min_in_group = min(group)\n        sum_without_min = sum(group) - min_in_group\n\n        cost1 = (n_group - 1) * min_in_group\n        cost2 = (n_group + 1) * min_in_array + 2 * min_in_group\n\n        if cost1 < cost2:\n            min_cost += cost1 + sum_without_min\n        else:\n            min_cost += cost2 + sum_without_min\n\n    print(min_cost)\n    return\n\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nW = [[int(i)] for i in input().split()]\nfor ni in range(n):\n    W[ni].append(ni)\nW.sort()\nG = [[] for i in range(n)]\ni = 0\nj = 0\ncnt = 0\nD = []\nwhile cnt < n:\n    if W[i][0] in G[j]:\n        j += 1\n        while i in D:\n            i += 1\n    else:\n        G[j].append(W[i][0])\n        D.append(i)\n        cnt += 1\n        i = W[i][1]\ngroup_num = j + 1\ncost = 0\nW_min = min([min(G[i]) for i in range(group_num)])\nfor gi in range(group_num):\n    if len(G[gi]) > 1:\n        if (min(G[gi])+W_min)*2 > (min(G[gi])-W_min)*(len(G[gi])-1):\n            cost += sum(G[gi])+ (len(G[gi])-2)*min(G[gi])\n        else:\n            cost += sum(G[gi])-min(G[gi])+ (len(G[gi])-1)*W_min+(min(G[gi])+W_min)*2\n\nprint(cost)\n"
  },
  {
    "language": "Python",
    "code": "def calcurate_cost(A, B, n):\n    cost = 0\n    s = min(A)\n    V = [False] * n\n    T = { j:i for i, j in enumerate(B) }\n    for i in range(n):\n        if V[i]:\n            continue\n        cur = i\n        S = 0\n        an = 0\n        m = 10000\n        while True:\n            V[cur] = True\n            an += 1\n            v = A[cur]\n            m = min(m, v)\n            S += v\n            cur = T[v]\n            if V[cur]:\n                break\n        cost += min(S + (an - 2) * m, m + S + (an + 1) * s)\n    return cost\n    \ndef minimum_cost_sort(A, n):\n    B = sorted(A)\n    return calcurate_cost(A, B, n)\n\nn = int(input())\nA = [int(i) for i in input().split()]\nprint(minimum_cost_sort(A, n))\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nA = list(map(int, input().split()))  # ソート前の並び\nB = sorted(A)  # ソート後の並び\nc = 0  # 移動コスト\n\n# 1 3 4 ... N 2 -> 1 2 3 4 ... N\n# パターンa) 移動すべき要素（グループ）の中での最小(2:B[i]） を使って移動させる\n# 1 3 4 2 : スタート\n# 1 3 2 4 : <1>\n# 1 2 3 4 : <2>\n#\n# パターンb) 一旦 最小(1:B[0]) と グループ最小(2:B[i]) を交換して始める\n# 1 3 4 2 : スタート\n# 2 3 4 1 : B[i] + B[0] 追加\n# 2 3 1 4 : <1> - (B[i] - B[0])\n# 2 1 3 4 : <2> - (B[i] - B[0])\n# 1 2 3 4 : B[i] + B[0] 追加\n\nfor i in range(N - 1):  # 最後の一つは、手前が揃っていれば揃っている\n    t = cnt = 0\n    ai = A.index(B[i])  # 並べ替え前の B[i] がいる場所\n\n    while ai != i:  # 並べ替え前と同じでない場合\n        y = A.index(B[ai])  # 更に次の\n        A[ai], A[y] = B[ai], B[i]  # スワップ\n        cnt += 1\n        t += B[ai] + B[i]  # このときのコスト\n        ai = y\n    if cnt:\n        # パターンa と パターンb を比較して、コストが小さい方に決める\n        c += min(t, (B[i] + B[0]) * 2 + t - (B[i] - B[0]) * cnt)\nprint(c)\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\n\nif __name__ == '__main__':\n\n    n = int(input())\n    A = [int(a) for a in input().split(\" \")]\n    B = A.copy()\n    B.sort()\n    V = [False]*n\n    T = {B[i]:i for i in range(n)}\n\n    ans = 0\n    s = min(A)\n\n    for i in range(n):\n        if V[i]:\n            continue\n        cur = i\n        S = 0 # sum of weight\n        m = 10000 # min of cycle(init max weight)\n        an = 0 # length of cycle\n        while not V[cur]:\n            V[cur] = True\n            an += 1\n            v = A[cur]\n            m = min(m, v)\n            S += v\n            cur = T[v]\n        ans += min(S + (an - 2)*m, m + S + (an + 1)*s)\n\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nw = list(map(int, input().split()))\nb = w[:]\nw.sort()\ns = w[0]\n\nclass Solve():\n    def __init__(self, w, b, s):\n        self.w = w\n        self.b = b\n        self.s = s\n        self.ans = 0\n        self.v = [0] * n\n    \n    def sort(self):\n        T = [0] * 10001\n        for i in range(n):\n            T[self.w[i]] = i\n        for i in range(n):\n            if self.v[i]:\n                continue\n            cur = i\n            S = 0\n            m = 10001\n            an = 0\n            while 1:\n                self.v[cur] = 1\n                an += 1\n                l = self.b[cur]\n                m = min(m, l)\n                S += l\n                cur = T[l]\n                if self.v[cur]:\n                    break\n            self.ans += min(S + (an - 2) * m, S + m +(an + 1) * self.s)\n        return self\n\ncost = Solve(w, b, s).sort()\nprint(cost.ans)\n"
  },
  {
    "language": "Python",
    "code": "def partition(a, p, r):\n    x = a[r]\n    i = p - 1\n    for j in range(p, r):\n        if a[j] <= x:\n            i += 1\n            tmp = a[i]\n            a[i] = a[j]\n            a[j] = tmp\n    tmp = a[i+1]\n    a[i+1] = a[r]\n    a[r] = tmp\n    return i + 1\n\n\ndef quick_sort(a, p, r):\n    if p < r:\n        q = partition(a, p, r)\n        quick_sort(a, p, q-1)\n        quick_sort(a, q+1, r)\n\n\ndef make_cyclic(w, v):\n    flags = [True] * len(w)\n\n    cyclics = []\n    for i in range(len(w)):\n        if flags[i]:\n            flags[i] = False\n            cycle = [w[i]]\n            now = w[i]\n            while True:\n                j = v.index(now)\n                if j == i:\n                    break\n                cycle.append(w[j])\n                now = w[j]\n                flags[j] = False\n            cyclics.append(cycle)\n\n    return cyclics\n\n\ndef min_cost_sort(w):\n    v = w.copy()\n    quick_sort(v, 0, len(v) - 1)\n\n    cyclics = make_cyclic(w, v)\n\n    ans = 0\n    for cycle in cyclics:\n        inner_cycle = min(cycle) * (len(cycle) - 2) + sum(cycle)\n        outer_cycle = min(cycle) + min(set(w) - set(cycle)) * (len(cycle) + 1) + sum(cycle)\n        ans += min(inner_cycle, outer_cycle)\n\n    return ans\n\nn = int(input())\nw = [int(x) for x in input().split()]\n\nprint(min_cost_sort(w))\n"
  },
  {
    "language": "Python",
    "code": "def get_weights():\n    input()\n    return raw_input().split()\n\n#weights: list\ndef minimam_cost_sort(weights):\n    lol = []\n    for i in weights:\n        if i !=0:\n            j = i\n            l = [j]\n            while weights[j - 1] != 0:\n                l.append(weights[j - 1])\n                j = weights[j - 1]\n                weights[j - 1] = 0\n            l.sort()\n            lol.append(l)\n\n    lol.sort()\n    s = 0\n    for l in lol:\n        s += get_wol(l)\n\n    print s\n\ndef get_wol(l):\n    sub = (l[0] - 1) * (len(l) - 1) - (l[0] + 1) * 2\n    s = sum(l) + (l[0] * (len(l) - 2))\n    if sub > 0:\n        return s - sub\n    return s\n\nminimam_cost_sort(get_weights())"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nline = input()\nL = [int(x) for x in line.split()]\n\nflags = [False] * n\nloops = []\n\nS = sorted(L)\nfor idx, x in enumerate(L):\n    k = S.index(x)\n    if flags[k]:\n        continue\n    if k == idx:\n        flags[k] = True\n        continue\n\n    ws = []\n    while x not in ws:\n        flags[k] = True\n        ws.append(x)\n        x = L[k]\n        k = S.index(x)\n    loops.append(ws)\n\ncost = 0\nfor ws in loops:\n    n = len(ws)\n    a = sum(ws) + (n - 2) * min(ws)\n    b = sum(ws) + min(ws) + (n + 1) * min(L)\n    cost += min(a, b)\n\nprint(cost)"
  },
  {
    "language": "Python",
    "code": "\ndef resolve():\n    def solve(n, arr):\n\n        def cycles():\n            V = [False]*N\n            B = sorted(A)\n            T = {B[i]:i for i in range(N)}\n            C = []\n            for i in range(N):\n                if V[i]:\n                    continue\n                cur = i\n                cycle = []\n                while not V[cur]:\n                    V[cur] = True\n                    cycle.append(cur)\n                    cur = T[A[cur]]\n                C.append(cycle)\n            return C\n\n        ans = 0\n        minV = min(A)\n        for cycle in cycles():\n            S = sum([A[i] for i in cycle])\n            m = min([A[i] for i in cycle])\n            an = len(cycle)\n            ans += min(S+(an-2)*m, S+(an+1)*minV+m)\n        return ans\n\n    N = int(input())\n    A = list(map(int, input().split()))\n    ans = solve(N, A)\n    print(ans)\n\nif __name__ == '__main__':\n    resolve()\n"
  },
  {
    "language": "Python",
    "code": "#! /usr/local/bin/python3\n# coding: utf-8\n\nfrom bisect import bisect_left\n\n\ndef swap(w, i, j):\n    tmp = w[i]\n    w[i] = w[j]\n    w[j] = tmp\n\n\ndef min_weight(w):\n    ws = sorted(w)\n    # print(ws)\n    # print(w)\n    weight = 0\n    for i in reversed(range(len(w))):\n        j = w.index(ws[i])\n        # print(i, j)\n        if i != j:\n            weight += w[i] + w[j]\n            swap(w, i, j)\n        # print(ws)\n        # print(w)\n    return weight\n\n\ndef main():\n    n = int(input())\n    w = [int(x) for x in input().split()]\n    print(min_weight(w))\n\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "def mklist(B,D,V):\n    min = 10000\n    for key,val in enumerate(B):\n        D[val] = key\n        V[val] = 0\n        if min > val:\n            min = val\n    return min\n\ndef solve(A,V,D,min):\n    cost = 0\n    for key, val in enumerate(A):\n        if V[val] != 0:\n            continue\n        W = []\n        wmin = 10000\n        tw = 0\n        k1 = key\n        v = val\n        while(1):\n            k2 = D[v]\n            if V[v] == 1:\n                break\n            W.append(v)\n            V[v] = 1\n            if wmin > v:\n                wmin = v\n            tw += v\n            #print(\"key={} k1={} k2={} v={} Vv={}\".format(key,k1,k2,v,V[v]))\n            k1 = k2\n            v = A[k1]\n        n = len(W)\n        t1 = tw + ((n - 2) * wmin)\n        t2 = tw + wmin + ((n + 1) * min)\n        if t1 < t2:\n            cost += t1\n        else:\n            cost += t2\n    return cost\n\ndef main():\n    num = int(input())\n    A = list(map(int,input().split()))\n    B = sorted(A)\n    D = {}\n    V = {}\n    min = mklist(B,D,V)\n    cost = solve(A,V,D,min)\n    print(cost)\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "\"\"\"Minimum cost Sort.\"\"\"\n\ndef min_cost_sort(A):\n    \"\"\"Sort list A in ascending order.\n \n    And return the switching cost in sorting.\n    \"\"\"\n    B = list(A)\n    B.sort()\n    cost = 0\n    min_w = B[0]\n    for i, b in enumerate(B):\n        tmp_cost = 0\n        bi = A.index(b)\n        cnt = 0\n        while bi != i:\n            cnt += 1\n            st = B[bi]\n            si = A.index(st)\n            tmp_cost += b + st\n            A[bi], A[si] = st, b\n            bi = si\n        dec = cnt * (b - min_w)\n        inc = 2 * (min_w + b)\n        if dec < inc:\n            cost += tmp_cost\n        else:\n            cost += tmp_cost - dec + inc\n    return cost\n\n\nn = input()\n\nA = list(map(int, input().split()))\n\nans = min_cost_sort(A)\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "\ndef solve(n,num_list,s):\n    ans = 0\n    # Vはループを確認する際に回ったかどうかをチェックする\n    V = [False for _ in range(n)]\n    \n    # sorted_num_listでは数列の最終的なゴールを確認する\n    sorted_num_list = sorted(num_list)\n\n    # ゴールのインデックスを確認する\n    T = [None for _ in range(10000+1)]\n    for i in range(n):\n        T[sorted_num_list[i]] = i\n\n    # 全ての要素に対して\n    for i in range(n):\n\n        # Vが埋まっていれば前ループの要素サイクルで移動済みなので無視\n        if V[i]:\n            continue\n\n        cur = i\n        \n        # Sは サイクル内のバリューの合計\n        S = 0\n\n        # mはサイクルの最小値\n        m = 10000\n\n        # anはサイクルの要素数\n        an = 0\n\n        # ここからサイクルごとのループに入る\n        while True:\n            V[cur] = True\n            an += 1\n            v = num_list[cur]\n            m = min(m,v)\n            S += v\n            cur = T[v]\n            if V[cur]:\n                break\n        ans += min(S + (an - 2)*m,m+S+(an+1)*s)\n    return ans\n\n# 移動先をリストとしてバリューをインデックスにして保管するやり方をマスターすべし，\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    num_list = list(map(int,input().split()))\n    s = min(num_list)\n    ans = solve(n,num_list,s)\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\na=list(map(int,input().split()))\nb=sorted(a)\nm=b[0]\nc=0\nfor i in range(n):\n t=k=0\n x=a.index(b[i])\n while x>i:\n  y=a.index(b[x])\n  a[x],a[y]=b[x],b[i]\n  k+=1\n  t+=b[x]+b[i]\n  x=y\n if k:c+=min(t,(b[i]+m)*2+t-(b[i]-m)*k)\nprint(c)\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\ncache = {}\n\n\ndef remaining_expected_cost(a):\n    global n, b, cache\n    key = tuple(i for i in range(n) if a[i] != b[i])\n    if key in cache:\n        return cache[key]\n    return sum(a[i] for i in key)\n\n\ndef stack(node):\n    global heap, n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            swapped = (i, j)\n            if swapped == node[2]:\n                continue\n            a = node[3][:]\n            w1, w2 = a[i], a[j] = a[j], a[i]\n            spent_cost = node[1] + w1 + w2\n            rec = remaining_expected_cost(a)\n            if not rec:\n                return spent_cost\n            heappush(heap, (spent_cost + rec, spent_cost, swapped, a))\n    return False\n\n\nn, a = int(input()), list(map(int, input().split()))\nb, m, heap = sorted(a), 0, []\n\nheappush(heap, (remaining_expected_cost(a), 0, None, a))\n\nwhile heap:\n    m = stack(heappop(heap))\n    if m is not False:\n        break\nprint(m)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nl = list(map(int, input().split()))\ns = sorted(l)\ncost = 0\nfor i in range(n):\n    a = l.index(s[i])\n    j = 0\n    while a > i:\n        j += 1\n        b = l.index(s[a])\n        cost += l[b]\n        l[a], l[b] = l[b], l[a]\n        a = b\n    cost += min(s[i] * j, s[i] * 2 + s[0] * (j + 2))\nprint(cost)"
  },
  {
    "language": "Python",
    "code": "#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_6_D\n#????°???????????????????\ndef partition(target_list, l, r):\n    x = target_list[r]\n    i = l - 1\n\n    for j in range(l, r):\n        if target_list[j] <= x:\n            i = i + 1\n            tmp = target_list[i]\n            target_list[i] = target_list[j]\n            target_list[j] = tmp\n    tmp = target_list[r]\n    target_list[r] = target_list[i + 1]\n    target_list[i + 1] = tmp\n    \n    return  i + 1\n\ndef quick_sort(target_list, l, r):\n    if l < r:\n        c = partition(target_list, l, r)\n        quick_sort(target_list, l, c - 1)\n        quick_sort(target_list, c + 1, r)\n\ndef processA(target_list, correct_list, i):\n\n    cost = 0\n    while not correct_list[i] == target_list[i]:\n        min_i = target_list.index(correct_list[i])\n        change_i = target_list.index(correct_list[min_i])\n        cost += (target_list[min_i] + target_list[change_i])\n        target_list[min_i], target_list[change_i] = target_list[change_i], target_list[min_i]\n\n    return cost\n    \ndef processB(target_list, correct_list, i):\n    most_min = correct_list[0]\n    second_min = correct_list[i]\n    cost = (most_min + second_min)\n    \n    mmi = target_list.index(most_min)\n    smi = target_list.index(second_min)\n    target_list[mmi], target_list[smi] = target_list[smi], target_list[mmi]\n    \n    while not correct_list[i] == target_list[i]:\n        print(target_list)\n        min_i = target_list.index(correct_list[i])\n        change_i = target_list.index(correct_list[min_i])\n        cost += (target_list[min_i] + target_list[change_i])\n        target_list[min_i], target_list[change_i] = target_list[change_i], target_list[min_i]\n\n    return cost\n    \ndef minimum_cost_sort(target_list):\n    correct_list = [a for a in target_list]\n    quick_sort(correct_list, 0, len(correct_list) - 1)\n    cost = 0\n    i = 0\n    while not correct_list == target_list:\n        cost_a = processA(target_list, correct_list, i)\n        cost_b = processB([a for a in target_list], correct_list, i)\n        cost += min(cost_a, cost_b)\n        print(cost_a, cost_b)\n        #print(target_list)\n        i += 1\n    return cost\ndef main():\n    n_list = input()\n    target_list = [int(s) for s in input().split()]\n    print(minimum_cost_sort(target_list))\n    \nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\nb= sorted(a)\n\nans = 0\nfor i in range(n):\n    w = 0\n    cnt = 0\n    x = a.index(b[i]) # b[i]: sort未済の中で最小値\n    while x != i:\n        y = a.index(b[x]) #位置xに来るべき数の位置\n        a[x], a[y] = b[x], b[i] #b[i] -> 位置yに移動\n        cnt += 1\n        w += b[x] + b[i]\n        x = y\n    if cnt > 0: \n        ans += min(w, (b[i] + b[0]) * 2 + w - (b[i] - b[0]) * cnt) #b[0]が全体の最小値\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "def partition(li, p, r):\n    \"\"\"Separate li with a value of li[r].\n    Returns index of the partition value.\n\n    >>> ax = [13, 19, 9, 5, 12, 8, 7, 4, 21, 2, 6, 11]\n    >>> partition(ax, 0, 11)\n    7\n    >>> ax\n    [9, 5, 8, 7, 4, 2, 6, 11, 21, 13, 19, 12]\n    \"\"\"\n    x = li[r]\n    i = p - 1\n    for j in range(p, r):\n        if li[j] <= x:\n            i += 1\n            li[i], li[j] = li[j], li[i]\n\n    i += 1\n    li[i], li[r] = li[r], li[i]\n\n    return i\n\n\ndef quicksort(li, p, r):\n    \"\"\"sort li by quick sort algorithm.\n\n    >>> li = [3, 2, 1, 3, 2, 1]\n    >>> quicksort(li, 0, 5)\n    >>> li\n    [1, 1, 2, 2, 3, 3]\n    \"\"\"\n    if p < r:\n        q = partition(li, p, r)\n        quicksort(li, p, q-1)\n        quicksort(li, q+1, r)\n\n\ndef min_cost(li1, li2):\n    \"\"\"calculate minimum cost to transform li1 into li2.\n\n    >>> min_cost([1, 5, 3, 4, 2], [1, 2, 3, 4, 5])\n    7\n    >>> min_cost([4, 3, 2, 1], [1, 2, 3, 4])\n    10\n    \"\"\"\n    def find_moves(i, j):\n        start = i\n        elems = [i]\n        mincost = li1[i]\n        minidx = 0\n\n        while j != start:\n            if mincost > li1[j]:\n                mincost = li1[j]\n                minidx = len(elems)\n            elems.append(j)\n            j = li2.index(li1[j])\n\n        elems = elems[minidx+1:] + elems[:minidx+1]\n        if 2 * (mincost + li1[mini]) < len(elems) * (mincost - li1[mini]):\n            elems.append(mini)\n            elems.insert(0, mini)\n\n        q = elems.pop()\n        p = elems.pop()\n        yield (p, q)\n        while len(elems) > 0:\n            q = p\n            p = elems.pop()\n            yield (p, q)\n\n\n    def move(i, j):\n        cost = 0\n        for p, q in find_moves(i, j):\n            li1[p], li1[q] = li1[q], li1[p]\n            cost += li1[p] + li1[q]\n\n        return cost\n\n    assert len(li1) == len(li2)\n    size = len(li1)\n    totalcost = 0\n    mini = li1.index(li2[0])\n\n    for i in reversed(range(size)):\n        if li1[i] != li2[i]:\n            totalcost += move(li1.index(li2[i]), i)\n\n    return totalcost\n\n\ndef run():\n    _ = int(input())  # flake8: noqa\n    li = [int(i) for i in input().split()]\n    sli = li[:]\n    quicksort(sli, 0, len(li)-1)\n\n    print(min_cost(li, sli))\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "VMAX = 10000\nn = int(input())\nA = list(map(int, input().split()))\ns = min(A)\ndef solve():\n    ans = 0\n    V = [False] * n\n    B = sorted(A)\n    T = [0] * (VMAX + 1)\n    for i in range(n):\n        T[B[i]] = i\n    for i in range(n):\n        if V[i]:\n            continue\n        cur = i\n        S = 0\n        m = VMAX\n        an = 0\n        while True:\n            V[cur] = True\n            an += 1\n            v = A[cur]\n            m = min(m, v)\n            S += v\n            cur = T[v]\n            if V[cur]:\n                break\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s)\n    return ans\nprint(solve())\n"
  },
  {
    "language": "Python",
    "code": "# line = \"4 3 2 1\"\n# L = [int(x) for x in line.split()]\n# n = len(L)\n\nn = int(input())\nline = input()\nL = [int(x) for x in line.split()]\n\nflags = [False] * n\nloops = []\n\nfor i, x in enumerate(L):\n    k = x - 1\n    if flags[k]:\n        continue\n    if i == k:\n        flags[i] = True\n        continue\n\n    loop = []\n    while x not in loop:\n        flags[k] = True\n        loop.append(x)\n        x = L[k]\n        k = x - 1\n    loops.append(loop)\n\ncost = 0\nfor loop in loops:\n    m = min(loop)\n    cost += m * (len(loop)-1) + sum(loop) - m\n\nprint(cost)"
  },
  {
    "language": "Python",
    "code": "def perfect_swap():\n    global n, a, b, cost\n    for i in range(1, n - 1):\n        for j in range(i + 1, n):\n            ai, aj = a[i], a[j]\n            if ai == b[j] and aj == b[i]:\n                a[i], a[j] = aj, ai\n                cost += ai + aj\n\n\ndef lowest_swap():\n    global n, a, b, cost\n    for i in range(n - 1):\n        bi, tmp_cost, count = b[i], 0, 0\n        while a[i] != bi:\n            si = a.index(bi)\n            bsi = b[si]\n            sj = a.index(bsi)\n            a[si], a[sj] = bsi, bi\n            tmp_cost += bi + bsi\n            count += 1\n        if count:\n            if i:\n                b0 = b[0]\n                cost += min(tmp_cost, (bi + b0) * 2 + tmp_cost - (bi - b0) * count)\n            else:\n                cost += tmp_cost\n\n\nn, a, cost = int(input()), list(map(int, input().split())), 0\nb = sorted(a)\nprint(b)\nperfect_swap()\nlowest_swap()\nprint(cost)"
  },
  {
    "language": "Python",
    "code": "# line = \"10 7 8 9\"\n# L = [int(x) for x in line.split()]\n# n = len(L)\n\nn = int(input())\nline = input()\nL = [int(x) for x in line.split()]\n\nflags = [False] * n\nloops = []\n\nS = sorted(L)\nfor i, x in enumerate(L):\n    k = S.index(x)\n    if flags[k]:\n        continue\n    if i == k:\n        flags[i] = True\n        continue\n\n    loop = []\n    while x not in loop:\n        flags[k] = True\n        loop.append(x)\n        x = L[k]\n        k = S.index(x)\n    loops.append(loop)\n\ncost = 0\nfor loop in loops:\n    m = min(loop)\n    cost += m * (len(loop)-1) + sum(loop) - m\n\nprint(cost)"
  },
  {
    "language": "Python",
    "code": "input()\nw=list(map(int,input().split()))\nx=min(w)\nm={k:v for k,v in zip(sorted(w),w)if k!=v}\nl=list(m.keys())\np=[]\nwhile l:\n a=l.pop();b=m[a];l.remove(b)\n if a==m[b]:p+=[[a,b]]\n else:\n  t=[a,b]\n  while 1:\n   c=m[b];t+=[c]\n   if c==a:p+=[t];break\n   else:b=c;l.remove(c)\nn=0\nfor s in p:\n n+=sum(s);t=len(s);y=min(s)\n if t>2:n+=min((t-2)*y,y+(t+1)*x)\nprint(n)\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\na=list(map(int,input().split()))\nb=sorted(a);c=0\nfor i in range(n-1):\n    t=cnt=0;x=a.index(b[i])\n    while x!=i:\n        y=a.index(b[x])\n        a[x],a[y]=b[x],b[i];cnt+=1\n        t+=b[x]+b[i]\n        x=y\n    if cnt:c+=min(t,(b[i]+b[0])*2+t-(b[i]-b[0])*cnt)\nprint(c)"
  },
  {
    "language": "Python",
    "code": "import bisect\n\n\ndef sorted_index(A):\n    # Aをソートした後のindexのリスト\n    A_ = sorted(A)\n    B = []\n    for a in A:\n        idx = bisect.bisect_left(A_, a)\n        B.append(idx)\n    return B\n\n\ndef cyclic_factorize(A):\n    # Aを巡回置換分解する\n    B = sorted_index(A)\n    checked = [False] * len(A)\n    cycle_lst = []\n    for i, a in enumerate(A):\n        if checked[i]:\n            continue\n        now = i\n        checked[now] = True\n        cycle = [a]\n        next = B[now]\n        while not checked[next]:\n            now = next\n            next = B[now]\n            cycle.append(A[now])\n            checked[now] = True\n        cycle_lst.append(cycle)\n    return cycle_lst\n\n\nN = int(input())\n*W, = map(int, input().split())\ncycle_lst = cyclic_factorize(W)\nans = 0\nglobal_min = min(W)\nfor cycle in cycle_lst:\n    l = len(cycle)\n    s = sum(cycle)\n    local_min = min(cycle)\n    ans += s + min((l - 2) * local_min, local_min + (l + 1) * global_min)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nimport copy\n\nclass BagsWithWeight(list):\n    def __init__(self, l):\n        super(BagsWithWeight, self).__init__(l)\n        self.sorted_weights = list(sorted(self))\n\n    def get_lists_of_loop(self):\n        \"\"\"???????????????????????????????????????????±??????????\n        ????????\\??????????????????????????????????????¬??\\???????????? index ???????????????????????????\n        ??????????????????????????¬??\\???????????? index ????????£???????????¨?????????????????????????????????\n        ?????????????????§?????????????????????????????¨ 1 ????????????????????????\n        ????????????????????????????????? 1 ????????\\???????????§??????????????????????????????????????????\n        out: ListOfLoops     ??¨?????? loop ????????????\n        \"\"\"\n        c_weights = copy.copy(self)\n        loops = Loops()\n        for i in range(len(self)):\n            loop = []\n            index = i\n            while c_weights[index] != -1:\n                loop.append(c_weights[index])\n                c_weights[index] = -1\n                index = self.get_index_of_sorted_bag(index)\n            if loop:\n                loops.append(loop)\n        return loops\n\n    def get_index_of_sorted_bag(self, index):\n        \"\"\"???????????????????????????????????????????????? index ????????????\n        in:  index    int    ??????????????? index ????±?????????????????????? index\n        out: int    ?????????????????????????????? index\n        \"\"\"\n        return self.sorted_weights.index(self[index])\n\n\nclass Loops(list):\n    def append(self, elm):\n        elm.sort()\n        elm = Loop(elm, self)\n        super(Loops, self).append(elm)\n\n    def get_minimum_element(self):\n        return min(min(self))\n\n    def get_cost(self):\n        return sum(map((lambda loop: loop.get_cost_of_sorting()), self))\n\n\nclass Loop(list):\n    def __init__(self, loop, loops):\n        super(Loop, self).__init__(loop)\n        self.loops = loops\n    \n    def get_minimum_weight_of_outer(self):\n        return self.loops.get_minimum_element()\n\n    def get_cost_of_sorting(self):\n        \"\"\"Loop ?????¨???????°??????????????±??????????\n        \"\"\"\n        cost = sum(self) + min(self) * (len(self) - 2)\n        cost_reduced = self.get_how_much_outer_minimum_weight_bag_reduces_cost()\n        if cost_reduced > 0:\n            return cost - cost_reduced\n        else:\n            return cost\n\n\n    def get_how_much_outer_minimum_weight_bag_reduces_cost(self):\n        \"\"\"Loops ???????°????????????????????????£???????????§???????????????????±??????????\n        List of Loops ??????????°?????????????????´????\n        Loop ??????????°?????????????????´???¨??\\????????????\n        ?????????????????£?????????????????§???????????????????????????\n        ??????????????? len(loop) - 1 ??????????????????????????????????°???????????????????????????????\n        out: int    ????????§???????????????\n        \"\"\"\n        return ((min(self) - self.get_minimum_weight_of_outer()) *\n                    (len(self) - 1) -\n                    (min(self) + self.get_minimum_weight_of_outer()) * 2)\n\n\ndef get_weights():\n    raw_input()\n    return map(int, raw_input().split())\n\nbww = BagsWithWeight(get_weights())\nloops = bww.get_lists_of_loop()\nprint loops.get_cost()"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport sys\n\nMAX_VALUE = int(1e4 + 1)\n\n\ndef min_cost_sort():\n    ans = 0\n    for i in range(array_length):\n        if check_order[i]:\n            continue\n        current_index = i\n        circle_sum, circle_min, circle_size = 0, MAX_VALUE, 0\n        while True:\n            check_order[current_index] = True\n            circle_size += 1\n            current_value = array[current_index]\n            circle_min = min(circle_min, current_value)\n            circle_sum += current_value\n            current_index = value_to_index[current_value]\n            if check_order[current_index]:\n                break\n        ans += min(circle_sum + (circle_size - 2) * circle_min,\n                   circle_sum + circle_min + (circle_size + 1) * min_value)\n    return ans\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    array_length = int(_input[0])\n    array = list(map(int, _input[1].split()))\n    # assert len(array) == array_length\n\n    check_order = [False] * array_length\n    value_to_index = dict()\n    compare_ans = sorted(array)\n    min_value = compare_ans[0]\n    for j in range(array_length):\n        value_to_index[compare_ans[j]] = j\n    print(min_cost_sort())"
  },
  {
    "language": "Python",
    "code": "\ndef solve(A, N):\n    answer = 0\n\n    B = list(A)\n    V = [False] * N\n    T = [None] * 10001\n    s = min(A)\n\n    B.sort()\n\n    # print(A)\n    # print(B)\n\n    for i in range(N):\n        T[B[i]] = i\n\n    for i in range(N):\n        if V[i] is True:  # すでにカーソルが来ていたら飛ばす。\n            continue\n\n        cur = i  # カーソル\n        S = 0\n        m = 10000  # VMAX\n        an = 0  # サイクルの長さ\n\n        while True:\n            V[cur] = True  # まずは今の位置を走査済みにする。\n            an += 1  # サイクルの長さを増やす\n            v = A[cur]  # 入力列の値\n            m = min(m, v)  # このサイクルの最小値\n            S += v  # 今の値の重さを足す。SはΣwi\n            cur = T[v]  # 次のカーソルの位置を決める\n            if V[cur]:  # 次のカーソルの位置がTrueなら\n                break  # サイクルの始まりまで戻ってきたということ。\n\n        # この状態で、\n        # an = サイクルの長さ\n        # S = wiの合計の重さ\n        # m = このサイクルの最小値\n        # の3つが分かっている。\n\n        answer += min(S + (an - 2) * m, m + S + (an + 1) * s)\n\n    return answer\n\n\nN = int(input())\nA = list(map(int, input().split()))\n\nanswer = solve(A, N)\nprint(answer)\n\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nA = list(map(int, input().split()))\n\nB = sorted(A)\nc = 0\n\nfor i in range(n-1):\n    t = cnt = 0\n    x = A.index(B[i])\n    \n    while x != i:\n        y = A.index(B[x])\n        A[x], A[y] = B[x], B[i]\n        cnt += 1\n        t += B[x] + B[i]\n        x = y\n    if cnt:\n        c += min(t, (B[i]+B[0])*2+t-(B[i]-B[0])*cnt)\nprint(c)\n"
  },
  {
    "language": "Python",
    "code": "def solve(w_list, sort_list):\n    ans = 0\n    min_num = sort_list[0]\n    for i in range(len(w_list)):\n        x = sort_list.index(w_list[i])\n        if x == i:\n            continue\n        sum_cost = 0\n        min_loop_n = 10**4 + 1\n        j = i\n        loop_count = 0\n        while True:\n            loop_count += 1 \n            sum_cost += w_list[j]\n            min_loop_n = min(min_loop_n, w_list[j])\n            if x == i:\n                break\n            w_list[x], w_list[j] = w_list[j], w_list[x]\n            x = sort_list.index(w_list[j])\n        ans += min(sum_cost + (loop_count-2)*min_loop_n, sum_cost + min_loop_n + (loop_count+1)*min_num)\n    return ans\n        \n            \n            \nn = int(input())\nw_list = list(map(int, input().split()))\nsort_list = sorted(w_list)\nprint(solve(w_list, sort_list))\n        \n        \n        \n    \n"
  },
  {
    "language": "Python",
    "code": "input()\na=list(map(int,input().split()))\nb=sorted(a)\nc=0\nfor i in range(len(a)):\n x=a.index(b[i])\n j=0\n while x>i:\n  j+=1\n  y=a.index(b[x])\n  c+=a[y]\n  a[x],a[y]=a[y],a[x]\n  x=y\n c+=min(b[i]*j,b[i]*2+b[0]*(j+2))\nprint(c)\n"
  },
  {
    "language": "Python",
    "code": "#coding:utf-8\nn = int(input())\nA = list(map(int, input().split()))\nB = A[:]\nB.sort()\nC = [True for i in range(n)]\nminA = min(A)\n\nj = 0\na = []\ntotal = 0\nfor i in range(n):\n    circle = []\n    j = i\n    while C[j]:\n        C[j] = False\n        j = B.index(A[j])\n        circle.append(A[j])\n    n_c = len(circle)\n    if n_c == 2:\n        total += (circle[0]+circle[1])\n    if n_c > 2:\n        minc = min(circle)\n        cirSum = sum(circle)\n        total += min( cirSum + (n_c-2) * minc , cirSum + minc + (n_c+1)*minA)\n    a.append(circle)\n    \n\nprint(total)\n\n"
  },
  {
    "language": "Python",
    "code": "\"\"\"Minimum cost Sort.\"\"\"\n\ndef min_cost_sort(A):\n    \"\"\"Sort list A in ascending order,\n\n    And return the switching cost in sorting.\n    \"\"\"\n    B = list(A)\n    B.sort()\n    cost = 0\n    for i, b in enumerate(B):\n        while A.index(b) != i:\n            st1 = b\n            si1 = A.index(b)\n            st2 = B[si1]\n            si2 = A.index(st2)\n            cost += st1 + st2\n            A[si1], A[si2] = st2, st1\n    return cost\n\n\nn = int(input())\n\nA = list(map(int, input().split()))\n\nans = min_cost_sort(A)\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "def minimum_cost_sort():\n    sorted_positions = {str(val):i for i, val in enumerate(sorted(W))}\n    is_passed = [False]*n\n    minimum_weight = min(W)\n    ans = 0\n    for i in range(n):\n        if is_passed[i]:\n            continue\n        pointer = i\n        total_weight = 0\n        local_minimum_weight = 10000\n        counter = 0\n        while not is_passed[pointer]:\n            is_passed[pointer] = True\n            total_weight += W[pointer]\n            local_minimum_weight = min(local_minimum_weight, W[pointer])\n            pointer = sorted_positions[str(W[pointer])]\n            counter += 1\n        ans += min(total_weight+local_minimum_weight*(counter-2), total_weight+minimum_weight*(counter+1)+local_minimum_weight)\n    print(ans)\n\nif __name__ == \"__main__\":\n    n = int(input())\n    W = list(map(int, input().split()))\n    minimum_cost_sort()\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nW = list(map(int, input().split()))\n\nW_org = W[:]\nW_org_idx = {w:i for i, w in enumerate(W_org)}\nW_srt = list(sorted(W[:]))\nW_srt_idx = {w:i for i, w in enumerate(W_srt)}\n\n#print(W_org)\n#print(W_org_idx)\n#print(W_srt)\n#print(W_srt_idx)\n\n\ndef rec(idx, ret):\n    if W_org[idx] in ret:\n        return ret\n    \n    ret.append(W_org[idx])\n    idx = W_srt_idx[W_org[idx]]\n    return rec(idx, ret)\n\nans = 0\nsearched = set()\nall_min_r = min(W_org)\nfor i in range(n):    \n    if W_org[i] in searched:\n        continue\n    ret = rec(i, [])\n    for r in ret:\n        searched.add(r)\n    \n    if len(ret) == 1:\n        continue\n    elif len(ret) == 2:\n        ans += sum(ret)\n    else:\n        #print(ret)\n        min_r = min(ret)\n        ans_a = sum(ret) + len(ret)*min_r - 2*min_r\n        \n        ans_b = 2*(all_min_r+min_r) + (sum(ret)-min_r+all_min_r) + len(ret)*all_min_r - 2*all_min_r\n        ans += min(ans_a, ans_b)\n\nprint(ans)\n        \n    \n    \n\n"
  },
  {
    "language": "Python",
    "code": "#最小コストソート\n\nn = int(input())\na = list(map(int, input().split()))\nb = sorted(a)\nc = 0\nfor i in range(n-1):\n    t = cnt = 0\n    #本来i番目にいるべき値はaではどこにいるのか（ループの最小値）\n    x = a.index(b[i])\n    #もしあるべき場所にあったり、あるべき場所に帰ってきたら終了\n    while x != i:\n        #ループで最も小さい値を使いまわしながら整えていく\n        #ループの最小値が入っている場所にいるべき値がaでは何処にいるか\n        y = a.index(b[x])\n        #a[x]とa[y]を入れ替えればよい\n        a[x],a[y] = a[y],a[x];cnt += 1\n        t += a[x] + a[y]\n        x = y\n    if cnt: c += min(t, (b[i]+b[0])*2 + t -(b[i]-b[0])*cnt)\nprint(c)\n# print(a)\n"
  },
  {
    "language": "Python",
    "code": "if __name__ == \"__main__\":\n    n = int(input())\n    elements = list(map(lambda x: int(x), input().split()))\n    sorted_elements = sorted(elements)\n    total_cost = 0\n\n    for i in range(n - 1):\n        cost = 0\n        cnt = 0\n        x_idx = elements.index(sorted_elements[i])\n        while i != x_idx:\n            y_idx = elements.index(sorted_elements[x_idx])\n            elements[x_idx], elements[y_idx] = (sorted_elements[x_idx],\n                                                sorted_elements[i])\n            cnt += 1\n            cost += sorted_elements[x_idx] + sorted_elements[i]\n            x_idx = y_idx\n        if cnt:\n            total_cost += min(cost,\n                              (sorted_elements[i] + sorted_elements[0]) * 2 + cost\n                              - (sorted_elements[i] - sorted_elements[0]) * cnt)\n\n    print(total_cost)\n\n"
  },
  {
    "language": "Python",
    "code": "input()\nw=list(map(int,input().split()))\ns=sorted(w)\nx=s[0]\nm={k:v for k,v in zip(s,w)if k!=v}\nl=list(m.keys())\nn=0\nwhile l:\n a=l.pop();b=m[a];l.remove(b)\n if a==m[b]:n+=a+b\n else:\n  t=[b]\n  while 1:\n   c=m[b];t+=[c]\n   if c==a:p,q=len(t),min(t);n+=sum(t)+min((p-2)*q,q+(p+1)*x);break\n   else:b=c;l.remove(c)\nprint(n)\n"
  },
  {
    "language": "Python",
    "code": "def minimumCostSort(arr, arr_size):\n    cost = 0\n    sortarr = sorted(arr)\n    cyclecontainer = []\n    for i in range(arr_size):\n        cycle = [arr[i]]\n        next = sortarr.index(arr[i])\n        while arr[next] != arr[i]:\n            cycle += [arr[next]]\n            next = sortarr.index(arr[next])\n        cycle = sorted(cycle)\n        if cycle not in cyclecontainer:\n            cyclecontainer.append(cycle)\n            if len(cycle) == 1:\n                pass\n            elif len(cycle) == 2:\n                cost += sum(cycle)\n            elif len(cycle) >= 3:\n                cost += min(sum(cycle)+((len(cycle)-2)*min(cycle)), sum(cycle)+min(cycle)+((len(cycle)+1)*min(arr)))\n    return cost\nn = int(input())\nw = list(map(int, input().split()))\nprint(minimumCostSort(w, n))\n"
  },
  {
    "language": "Python",
    "code": "#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_6_D\n#????°???????????????????\ndef partition(target_list, l, r):\n    x = target_list[r]\n    i = l - 1\n\n    for j in range(l, r):\n        if target_list[j] <= x:\n            i = i + 1\n            tmp = target_list[i]\n            target_list[i] = target_list[j]\n            target_list[j] = tmp\n    tmp = target_list[r]\n    target_list[r] = target_list[i + 1]\n    target_list[i + 1] = tmp\n    \n    return  i + 1\n\ndef quick_sort(target_list, l, r):\n    if l < r:\n        c = partition(target_list, l, r)\n        quick_sort(target_list, l, c - 1)\n        quick_sort(target_list, c + 1, r)\n\ndef processA(target_list, correct_list, i):\n\n    cost = 0\n    while not correct_list[i] == target_list[i]:\n        min_i = target_list.index(correct_list[i])\n        change_i = target_list.index(correct_list[min_i])\n        cost += (target_list[min_i] + target_list[change_i])\n        target_list[min_i], target_list[change_i] = target_list[change_i], target_list[min_i]\n        #print(\"A\", target_list)\n    return cost\n    \ndef processB(target_list, correct_list, i):\n    minv = correct_list[0]\n    target = correct_list[i]\n\n    if minv == target:\n        return 10 ** 9\n    cost = (minv + target)\n    #print(minv, target)\n    mmi = target_list.index(minv)\n    smi = target_list.index(target)\n    target_list[mmi], target_list[smi] = target_list[smi], target_list[mmi]\n    \n    while not correct_list[i] == target_list[i]:\n        min_i = target_list.index(minv)\n        change_i = target_list.index(correct_list[min_i])\n        cost += (target_list[min_i] + target_list[change_i])\n        target_list[min_i], target_list[change_i] = target_list[change_i], target_list[min_i]\n        #print(\"B\",target_list)\n    return cost\n    \ndef minimum_cost_sort(target_list):\n    correct_list = [a for a in target_list]\n    quick_sort(correct_list, 0, len(correct_list) - 1)\n    cost = 0\n    i = 0\n    while not correct_list == target_list:\n        cost_b = processB([a for a in target_list], correct_list, i)\n        cost_a = processA(target_list, correct_list, i)\n        cost += min(cost_a, cost_b)\n        #print(cost_a, cost_b)\n        #print(target_list)\n        i += 1\n    return cost\ndef main():\n    n_list = input()\n    target_list = [int(s) for s in input().split()]\n    print(minimum_cost_sort(target_list))\n    \nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "MAX = 1000\nVMAX = 10000\nn = int(input())\nA = [int(i) for i in input().split()]\nV = [False] * MAX\ndef solve():\n    B = A[:]\n    T = [0] * (VMAX + 1)\n    B.sort()\n    ans = 0\n    s = min(VMAX, min(A))\n    for i in range(n):\n        T[B[i]] = i\n    for i in range(n):\n        if V[i] : continue\n        cur = i\n        S = 0\n        m = VMAX\n        an = 0\n        while True:\n            V[cur] = True\n            an += 1\n            v = A[cur]\n            m = min(m, v)\n            S += v\n            cur = T[v]\n            if V[cur] : break\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s)\n    print(ans)\nsolve()"
  },
  {
    "language": "Python",
    "code": "def partition(li, p, r):\n    \"\"\"Separate li with a value of li[r].\n    Returns index of the partition value.\n\n    >>> ax = [13, 19, 9, 5, 12, 8, 7, 4, 21, 2, 6, 11]\n    >>> partition(ax, 0, 11)\n    7\n    >>> ax\n    [9, 5, 8, 7, 4, 2, 6, 11, 21, 13, 19, 12]\n    \"\"\"\n    x = li[r]\n    i = p - 1\n    for j in range(p, r):\n        if li[j] <= x:\n            i += 1\n            li[i], li[j] = li[j], li[i]\n\n    i += 1\n    li[i], li[r] = li[r], li[i]\n\n    return i\n\n\ndef quicksort(li, p, r):\n    \"\"\"sort li by quick sort algorithm.\n\n    >>> li = [3, 2, 1, 3, 2, 1]\n    >>> quicksort(li, 0, 5)\n    >>> li\n    [1, 1, 2, 2, 3, 3]\n    \"\"\"\n    if p < r:\n        q = partition(li, p, r)\n        quicksort(li, p, q-1)\n        quicksort(li, q+1, r)\n\n\ndef min_cost(li1, li2):\n    \"\"\"calculate minimum cost to transform li1 into li2.\n\n    >>> min_cost([1, 5, 3, 4, 2], [1, 2, 3, 4, 5])\n    7\n    >>> min_cost([4, 3, 2, 1], [1, 2, 3, 4])\n    10\n    \"\"\"\n    def find_moves(i, j):\n        start = i\n        elems = [i]\n        mincost = li1[i]\n        minidx = 0\n\n        while j != start:\n            if mincost > li1[j]:\n                mincost = li1[j]\n                minidx = len(elems)\n            elems.append(j)\n            j = li2.index(li1[j])\n\n        elems = elems[minidx+1:] + elems[:minidx+1]\n        if 2 * (mincost + li1[mini]) < (len(elems) - 1) * (mincost - li1[mini]):\n            elems.append(mini)\n            elems.insert(0, mini)\n\n        q = elems.pop()\n        p = elems.pop()\n        yield (p, q)\n        while len(elems) > 0:\n            q = p\n            p = elems.pop()\n            yield (p, q)\n\n\n    def move(i, j):\n        cost = 0\n        for p, q in find_moves(i, j):\n            li1[p], li1[q] = li1[q], li1[p]\n            cost += li1[p] + li1[q]\n\n        return cost\n\n    assert len(li1) == len(li2)\n    size = len(li1)\n    totalcost = 0\n    mini = li1.index(li2[0])\n\n    for i in reversed(range(size)):\n        if li1[i] != li2[i]:\n            totalcost += move(li1.index(li2[i]), i)\n\n    return totalcost\n\n\ndef run():\n    _ = int(input())  # flake8: noqa\n    li = [int(i) for i in input().split()]\n    sli = li[:]\n    quicksort(sli, 0, len(li)-1)\n\n    print(min_cost(li, sli))\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nloads = list(map(int, input().split()))\nmin_value = 0\nfor i in range(n-1):\n    tmp = (i,i)\n    min = 2 * 10e4 + 1\n    for j in range(i,n):\n        if loads[i] > loads[j]:\n            sum = loads[i] + loads[j]\n            if min > sum:\n                tmp = (i, j)\n                min = sum\n    if(min < 2*10e4 + 1):\n        min_value += min\n    loads[tmp[0]], loads[tmp[1]] = loads[tmp[1]], loads[tmp[0]]\n\nprint(min_value)\n\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nA=list(map(int, input().split()))\n\ndef cycle_search(i):\n    next_search_ind=i\n    ret=[]\n    while 1:\n        now_ind=next_search_ind\n        next_search_ind=sorted_A.index(A[now_ind])\n        ret.append(A[now_ind])\n        cycle_searched[now_ind]=True\n        if cycle_searched[next_search_ind]:\n            break\n    return ret\n\n\nsorted_A=sorted(A)\n\ncycles=[]\ncycle_searched=[False]*n\n\nfor i in range(n):\n    if cycle_searched[i] == False:\n        cycles.append(cycle_search(i))\n\nans=0\nmin_A=sorted_A[0]\nfor cycle in cycles:\n    cycle_len=len(cycle)\n    if cycle_len == 1:\n        continue\n    else:\n        ans1 = sum(cycle)+(cycle_len-2)*min(cycle)\n        min_cycle=min(cycle)\n        ans2 = sum(cycle)-min_cycle+min_A+(cycle_len-2)*min_A+2*(min_A+min_cycle)\n        ans += min(ans1,ans2)\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef minimumCostSort(A):\n    B = sorted(A)\n    V = [False] * len(A)\n    T = [0] * 10001\n    ans = 0\n    s = min(A)\n\n    for i in range(len(A)):\n        T[B[i]] = i\n\n    for i in range(len(A)):\n        if V[i]:\n            continue\n        S = an = 0\n        j = i\n        m = 10000\n        while True:\n            V[j] = True\n            an += 1\n            v = A[j]\n            m = min(m, v)\n            S += v\n            j = T[v]\n            if V[j]:\n                break\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s)\n    return ans\n\nif __name__ == \"__main__\":\n    lines = sys.stdin.readlines()\n    A = map(int, lines[1].split())\n    print minimumCostSort(A)"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\ncache = {}\n\n\ndef remaining_expected_cost(a):\n    global n, b, cache\n    key = tuple(i for i in range(n) if a[i] != b[i])\n    if key in cache:\n        return cache[key]\n    return sum(a[i] for i in key)\n\n\ndef stack(node):\n    global heap, n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            swapped = (i, j)\n            if swapped == node[2]:\n                continue\n            a = node[3][:]\n            w1, w2 = a[i], a[j] = a[j], a[i]\n            spent_cost = node[1] + w1 + w2\n            rec = remaining_expected_cost(a)\n            if not rec:\n                return spent_cost\n            heappush(heap, (spent_cost + rec, spent_cost, swapped, a))\n    return False\n\n\nn, a = int(input()), list(map(int, input().split()))\nb, m, heap = sorted(a), 0, []\n\nheappush(heap, (remaining_expected_cost(a), 0, None, a))\n\nwhile heap:\n    r = stack(heappop(heap))\n    if r is not False:\n        m = r\n        break\nprint(m)"
  },
  {
    "language": "Python",
    "code": "def mincost_sort(ws):\n    cost = 0\n    for i in range(len(ws) - 1, 0, -1):\n        imax = i\n        for j in range(i - 1, -1, -1):\n            if ws[j] > ws[imax]:\n                imax = j\n        if imax != i:\n            ws[imax], ws[i] = ws[i], ws[imax]\n            cost += ws[imax] + ws[i]\n    return cost\n\n\ninput()\nws = list(map(int, input().split()))\nprint(mincost_sort(ws))"
  },
  {
    "language": "Python",
    "code": "#最小コストソート\nn = int(input())\nA = list(map(int, input().split()))\n#整列\nB = sorted(A)\n#サイクルに採用されたか否か\nC = [0 for _ in range(n)]\nCNT = 0\nminA = B[0]\n\nfor i in range(n):\n    #正しい位置にいるか\n    if A[i] == B[i]:\n        C[i] == 1\n    #サイクルに採用済みか\n    elif C[i] == 0:\n        cyc = []\n        ind = i\n        #サイクル作成\n        while C[ind] == 0:\n            a = A[ind]\n            cyc.append(a)\n            C[ind] = 1\n            ind = B.index(a)\n        #2種のコスト計算\n        mincyc = min(cyc)\n        cost1 = sum(cyc) + (len(cyc) - 2) * mincyc\n        cost2 = sum(cyc) + mincyc + (len(cyc) + 1) * minA\n        if cost1 > cost2:\n            CNT += cost2\n        else:\n            CNT += cost1\n    else:\n        pass\nprint(CNT)\n"
  },
  {
    "language": "Python",
    "code": "MAXV = 10**4\n\nif __name__ == '__main__':\n    n = int(raw_input())\n    # input, range[1, n], according to counting sort\n    A = [0] + map(int, raw_input().split())\n    # counter, range: [0, k]\n    # so why use counting sort?\n    # because it's easy to find where an element go after sorting\n    C = [0 for i in range(MAXV + 1)]\n    min_of_all = MAXV + 1\n\n    for i in range(1, n + 1):\n        C[A[i]] += 1\n        min_of_all = min(min_of_all, A[i])\n\n    for i in range(1, MAXV + 1):\n        C[i] += C[i - 1]\n\n    # find all cycles of moves\n    # if V[i] is 1, then A[i] is already covered in some cycle\n    V = [0 for i in range(n + 1)]\n    total_cost = 0\n    for i in range(1, n + 1):\n        if V[i] == 1:\n            continue\n        V[i] = 1  # mark as visited\n        size_of_cycle = 1  # the number of elements in the cycle\n        min_of_cycle = A[i]\n        sum_of_cycle = A[i]\n        j = i  # iterator\n        while True:\n            j = C[A[j]]\n            if i == j:\n                break\n            V[j] = 1\n            size_of_cycle += 1\n            sum_of_cycle += A[j]\n            min_of_cycle = min(min_of_cycle, A[j])\n        if size_of_cycle == 1:\n            # only one element, no move, cost is zero\n            continue\n\n        cost = sum_of_cycle + (size_of_cycle - 2) * min_of_cycle\n        if min_of_all < min_of_cycle:\n            # swap back and forth, positive\n            diff = 2 * (min_of_all + min_of_cycle)\n            # diff in the sum of the cycle, negative\n            diff += min_of_all - min_of_cycle\n            # diff in (n-2)*min(w), negative\n            diff += (size_of_cycle - 2) * (min_of_all - min_of_cycle)\n            if diff < 0:\n                cost += diff\n        total_cost += cost\n\n    print total_cost\n"
  },
  {
    "language": "Python",
    "code": "def solve(A):\n    correct_a = sorted(A)\n    correct_index = {n: i for i, n in enumerate(correct_a)}\n    ans, min_n = 0, correct_a[0]\n    cycles = []\n    used = [0]*len(A)\n    for i in filter(lambda i: not used[i], range(len(A))):\n        used[i] = 1\n        cycle, next_i = [i], correct_index[A[i]]\n        while next_i != i:\n            cycle.append(next_i)\n            used[next_i] = 1\n            next_i = correct_index[A[next_i]]\n        cycles.append(cycle)\n\n    for cycle in cycles:\n        if len(cycle) == 2:\n            ans += correct_a[cycle[0]] + correct_a[cycle[1]]\n        elif len(cycle) > 2:\n            ans += (min(correct_a[cycle[0]]*(len(cycle)-1), correct_a[cycle[0]]*2 + min_n*(len(cycle)+1))\n                    + sum(correct_a[i] for i in cycle[1:]))\n\n    return ans\n\n\nif __name__ == \"__main__\":\n    input()\n    a = list(map(int, input().split()))\n    print(solve(a))\n"
  },
  {
    "language": "Python",
    "code": "# Minimum Cost Sort\n# 交換に重みwぶんコストがかかる\n\n# N <= 1000\n# a <= 10000\n\nN = int(input())\nA = list(map(int, input().split()))\norigin = list(range(N))\n\nB = sorted(zip(A, origin), key=lambda x: x[0])\n\n\nclass UnionFind():\n    def __init__(self, n):\n        self.g = [[i] for i in range(n)]\n\n    def root(self, x):\n        if self.is_root(x):\n            return x\n\n        self.g[x] = self.root(self.g[x])\n        return self.g[x]\n\n    def unite(self, x, y):\n        x = self.root(x)\n        y = self.root(y)\n\n        if x == y:\n            return False\n\n        # yにxをくっつける\n        if x < y:\n            x, y = y, x\n        self.g[y] += self.g[x]\n        self.g[x] = y\n\n        return True\n\n    def size(self, x):\n        return -self.root(x)\n\n    def is_root(self, x):\n        if type(self.g[x]) is list:\n            return True\n        return False\n\n\nG = UnionFind(N)\nfor i, b in enumerate(B):\n    G.unite(i, b[1])\n\n\nmin_g = min(A)\ncost = 0\nfor i in range(N):\n    if G.is_root(i):\n        W = [A[j] for j in G.g[i]]\n        n_w = len(W)\n        sum_w = sum(W)\n        min_w = min(W)\n\n        cost1 = sum_w + min_w*(n_w-2)\n        cost2 = cost1 + 2*(min_w + min_g) - (min_w-min_g)*(n_w-1)\n        cost += min(cost1, cost2)\n\nprint(cost)\n\n"
  },
  {
    "language": "Python",
    "code": "import itertools\n\n\nWAIT, PRESORT, SORTED = 0, 1, 2\ncost = 0\n\ndef swap(w1, w2):\n    global cost\n    cost += w1[WAIT] + w2[WAIT]\n    w1[PRESORT], w2[PRESORT] = w2[PRESORT], w1[PRESORT]\n\nn = input()\nw = [[wi, i, None] for i, wi in enumerate(map(int, input().split()))]\ns = sorted(w)\n\nfor i, wi in enumerate (s):\n    wi[SORTED] = i\n\nfor si in s:\n    tmp = si\n    t = []\n    while tmp[SORTED] != si[PRESORT]:\n        tmp = w[tmp[SORTED]]\n        t += [tmp]\n    \n    for ti in t[::-1]:\n        swap(si, ti)\n\nprint(cost)"
  },
  {
    "language": "Python",
    "code": "# line = \"10 7 8 9\"\n# L = [int(x) for x in line.split()]\n# n = len(L)\n\nn = int(input())\nline = input()\nL = [int(x) for x in line.split()]\n\nflags = [False] * n\nloops = []\n\nS = sorted(L)\nfor i, x in enumerate(L):\n    k = S.index(x)\n    if flags[k]:\n        continue\n    if i == k:\n        flags[i] = True\n        continue\n\n    loop = []\n    while x not in loop:\n        flags[k] = True\n        loop.append(x)\n        x = L[k]\n        k = S.index(x)\n    loops.append(loop)\n\ncost = 0\nfor loop in loops:\n    m = min(loop)\n    cost += m * (len(loop)-1) + sum(loop) - m\n\nprint(cost)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\ndef Solve():\n    ans = 0\n    for i in range(n):\n        if V[i]:\n            continue\n        cur = i\n        S, an = 0, 0\n        m = VMAX\n        while True:\n            V[cur] = True\n            an += 1\n            v = A[cur]\n            m = min(m, v)\n            S += v\n            cur = T[v]\n            if V[cur]:\n                break\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s)\n    return ans\n\nMAX = 1000\nVMAX = 10000\n\nn = int(input())\nA = [int(x) for x in input().split()]\ns = min(A)\nB = sorted(A)\nT = [0] * (VMAX + 1)\nfor i, b in enumerate(B):\n    T[b] = i\nV =[False] * MAX\nans = Solve()\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import itertools\n \n \nWAIT, PRESORT, SORTED = 0, 1, 2\ncost = 0\n \ndef swap(w1, w2):\n    global cost\n    cost += w1[WAIT] + w2[WAIT]\n    w1[PRESORT], w2[PRESORT] = w2[PRESORT], w1[PRESORT]\n     \n \nn = input()\nw = [[wi, i, None] for i, wi in enumerate(map(int, input().split()))]\ns = sorted(w)\nminw = s[0]\nfor i, wi in enumerate (s):\n    wi[SORTED] = i\n     \nfor si in s:\n    tmp = si\n    t = []\n    while tmp[SORTED] != si[PRESORT]:\n        tmp = w[tmp[SORTED]]\n        t += [tmp]\n \n    if len(t ) and minw != si and si[WAIT] * (len(t) - 2) > minw[WAIT] * (len(t) + 2):\n        swap(minw, si)\n        for ti in t[::-1]:\n            swap(minw, ti)\n        swap(minw, si)\n    else:\n        for ti in t[::-1]:\n            swap(si, ti)\n     \nprint(cost)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\narr = list(map(int, input().split()))\nidx = {}\nfor i, a in enumerate(sorted(arr)):\n    idx[a] = i\nvisit = [False]*n\nMin = min(arr)\nans = 0\nfor i in range(n):\n    if visit[i]:\n        continue\n    visit[i] = True\n    now = idx[arr[i]]\n    tmp_min = arr[i]\n    tot = tmp_min\n    cnt = 1\n    while now != i:\n        visit[now] = True\n        tot += arr[now]\n        cnt += 1\n        if tmp_min > arr[now]:\n            tmp_min = arr[now]\n        now = idx[arr[now]]\n    ans += min(tot + (cnt - 2)*tmp_min, tot + tmp_min + (cnt + 1)*Min)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "def solve(A, n, s):\n    ans = 0\n\n    V = [False for i in range(n)] # 値が交換済みかどうか\n    B = sorted(A)\n    T = [None for i in range(10001)]\n    for i in range(n):\n        T[B[i]] = i\n    for i in range(n):\n        if V[i]: continue\n        cur = i # カーソル(サークル内で動かす)\n        S = 0 # サークル内の数字の総和\n        m = 10000\n        an = 0 # サークルに含まれる数字の数\n        while True:\n            V[cur] = True\n            an += 1\n            v = A[cur]\n            m = min(m, v) # mがサークル内の数字の最小値\n            S += v\n            cur = T[v]\n            if V[cur]: break\n        ans += min(S + (an-2)*m, m+S+(an+1)*s)\n    return ans\n\nn = int(input())\nA = list(map(int, input().split(' ')))\ns = min(A)\nans = solve(A, n, s)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nimport copy\n\nclass BagsWithWeight(list):\n    def __init__(self, l):\n        super(BagsWithWeight, self).__init__(l)\n        self.sorted_weights = list(sorted(self))\n\n    def get_lists_of_loop(self):\n        \"\"\"???????????????????????????????????????????±??????????\n        ????????\\??????????????????????????????????????¬??\\???????????? index ???????????????????????????\n        ??????????????????????????¬??\\???????????? index ????????£???????????¨?????????????????????????????????\n        ?????????????????§?????????????????????????????¨ 1 ????????????????????????\n        ????????????????????????????????? 1 ????????\\???????????§??????????????????????????????????????????\n        out: ListOfLoops     ??¨?????? loop ????????????\n        \"\"\"\n        c_weights = copy.copy(self)\n        loops = Loops()\n        for i in range(len(self)):\n            loop = []\n            index = i\n            while c_weights[index] != 0:\n                loop.append(c_weights[index])\n                c_weights[index] = 0\n                index = self.get_index_of_sorted_bag(index)\n            if loop:\n                loops.append(loop)\n        return loops\n\n    def get_index_of_sorted_bag(self, index):\n        \"\"\"???????????????????????????????????????????????? index ????????????\n        in:  index    int    ??????????????? index ????±?????????????????????? index\n        out: int    ?????????????????????????????? index\n        \"\"\"\n        return self.sorted_weights.index(self[index])\n\n\nclass Loops(list):\n    def append(self, elm):\n        elm.sort()\n        elm = Loop(elm, self)\n        super(Loops, self).append(elm)\n\n    def get_minimum_element(self):\n        return min(min(self))\n\n    def get_cost(self):\n        return sum(map((lambda loop: loop.get_cost_of_sorting()), self))\n\n\nclass Loop(list):\n    def __init__(self, loop, loops):\n        super(Loop, self).__init__(loop)\n        self.loops = loops\n    \n    def get_minimum_weight_of_outer(self):\n        return self.loops.get_minimum_element()\n\n    def get_cost_of_sorting(self):\n        \"\"\"Loop ?????¨???????°??????????????±??????????\n        \"\"\"\n        cost = sum(self) + min(self) * (len(self) - 2)\n        cost_reduced = self.get_how_much_outer_minimum_weight_bag_reduces_cost()\n        if cost_reduced > 0:\n            return cost - cost_reduced\n        else:\n            return cost\n\n\n    def get_how_much_outer_minimum_weight_bag_reduces_cost(self):\n        \"\"\"Loops ???????°????????????????????????£???????????§???????????????????±??????????\n        List of Loops ??????????°?????????????????´????\n        Loop ??????????°?????????????????´???¨??\\????????????\n        ?????????????????£?????????????????§???????????????????????????\n        ??????????????? len(loop) - 1 ??????????????????????????????????°???????????????????????????????\n        out: int    ????????§???????????????\n        \"\"\"\n        return ((min(self) - self.get_minimum_weight_of_outer()) *\n                    (len(self) - 1) -\n                    (min(self) + self.get_minimum_weight_of_outer()) * 2)\n\n\ndef get_weights():\n    raw_input()\n    return map(int, raw_input().split())\n\nbww = BagsWithWeight(get_weights())\nloops = bww.get_lists_of_loop()\nprint loops.get_cost()"
  },
  {
    "language": "Python",
    "code": "n=int(input())\na=list(map(int,input().split()))\nb=sorted(a)\nc=0\nfor i in range(n):\n t=k=0\n x=a.index(b[i])\n while x>i:\n  y=a.index(b[x])\n  a[x],a[y]=b[x],b[i]\n  k+=1\n  t+=b[x]+b[i]\n  x=y\n if k:c+=min(t,(b[i]+b[0])*2+t-(b[i]-b[0])*k)\nprint(c)\n"
  },
  {
    "language": "Python",
    "code": "#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_6_D\n#????°???????????????????\n\ndef processA(target_list, correct_list, i):\n\n    cost = 0\n    while not correct_list[i] == target_list[i]:\n        min_i = target_list.index(correct_list[i])\n        change_i = target_list.index(correct_list[min_i])\n        cost += (target_list[min_i] + target_list[change_i])\n        target_list[min_i], target_list[change_i] = target_list[change_i], target_list[min_i]\n        #print(\"A\", target_list)\n    return cost\n    \ndef processB(target_list, correct_list, i):\n    minv = correct_list[0]\n    target = correct_list[i]\n\n    if minv == target:\n        return 10 ** 9\n    cost = (minv + target)\n    #print(minv, target)\n    mmi = target_list.index(minv)\n    smi = target_list.index(target)\n    target_list[mmi], target_list[smi] = target_list[smi], target_list[mmi]\n    \n    while not correct_list[i] == target_list[i]:\n        min_i = target_list.index(minv)\n        change_i = target_list.index(correct_list[min_i])\n        cost += (target_list[min_i] + target_list[change_i])\n        target_list[min_i], target_list[change_i] = target_list[change_i], target_list[min_i]\n        #print(\"B\",target_list)\n    return cost\n    \ndef minimum_cost_sort(target_list):\n    correct_list = sorted([a for a in target_list])\n    cost = 0\n    i = 0\n    while not correct_list == target_list:\n        cost_b = processB([a for a in target_list], correct_list, i)\n        cost_a = processA(target_list, correct_list, i)\n        cost += min(cost_a, cost_b)\n        #print(cost_a, cost_b)\n        #print(target_list)\n        i += 1\n    return cost\ndef main():\n    n_list = input()\n    target_list = [int(s) for s in input().split()]\n    print(minimum_cost_sort(target_list))\n    \nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nA = list(map(int, input().split()))\nB = sorted(A)\n\nvisited = [0] * n  \nidxs = {}  \nfor i, b in enumerate(B):\n    idxs[b] = i\n\nsaisyo = min(A)  \n\nans = 0\nfor i in range(n):\n    if visited[i]:\n        continue  \n    cur = i  \n    S = 0  \n    n2 = 0\n    m = float(\"inf\")\n    while True:\n        visited[cur] = True\n        S += A[cur]\n        m = min(m, A[cur])\n        n2 += 1\n        cur = idxs[A[cur]]\n        if visited[cur]:\n            break \n    ans += min(m*(n2-2)+S, m+S+(1+n2)*saisyo)\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "def minimum_cost_sort(A):\n  cost = 0\n  B = sorted(A)\n  for i in range(len(B)):\n    x = A.index(B[i])\n    cnt = 0\n    tmp = 0\n    while x != i:\n      y = A.index(B[x])\n      A[x], A[y] = A[y], A[x]\n      tmp += A[x] + A[y]\n      cnt += 1\n      x = y\n    if cnt > 0:\n      # compare with procedure as follows:\n      #   convert B[i] and B[0] (minimum item) : cost = B[i] + B[0]\n      #   sort with B[0] in the same way       : cost diff = (B[i] - B[0]) * cnt\n      #   reconvert B[0] and B[i]              : cost = B[i] + B[0]\n      cost += min(tmp, (B[i] + B[0]) * 2 + tmp - (B[i] - B[0]) * cnt)\n  return cost\n\nN = int(input())\nA = list(map(int, input().split()))\nprint(minimum_cost_sort(A))"
  },
  {
    "language": "Python",
    "code": "def min_cost(nums, n):\n    sorted_list = sorted(nums)\n    global_min = sorted_list[0]\n    check_list = [False] * n\n    cost = 0\n    for start_idx in range(n):\n        if check_list[start_idx]:\n            pass\n        else:\n            start_num = nums[start_idx]\n            cycle_idx = start_idx\n            cycle_count = 0\n            min_num = start_num\n            w_sum = 0\n            while True:\n                check_list[cycle_idx] = True\n                cycle_num = nums[cycle_idx]\n                w_sum += cycle_num\n                next_idx = sorted_list.index(cycle_num)\n                min_num = min(min_num, cycle_num)\n                if next_idx == start_idx:\n                    break\n                cycle_idx = next_idx\n                cycle_count += 1\n            if cycle_count >= 1:\n                cost1 = w_sum + (cycle_count - 1) * min_num\n                cost2 = w_sum + min_num + (cycle_count + 2) * global_min\n                cost += min(cost1, cost2)\n    return cost\n\n\ndef main():\n    n = int(input())\n    nums = list(map(int, input().split(\" \")))\n    cost = min_cost(nums, n)\n    print(cost)\n\n\nif __name__ == \"__main__\":\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "def partition(li, p, r):\n    \"\"\"Separate li with a value of li[r].\n    Returns index of the partition value.\n\n    >>> ax = [13, 19, 9, 5, 12, 8, 7, 4, 21, 2, 6, 11]\n    >>> partition(ax, 0, 11)\n    7\n    >>> ax\n    [9, 5, 8, 7, 4, 2, 6, 11, 21, 13, 19, 12]\n    \"\"\"\n    x = li[r]\n    i = p - 1\n    for j in range(p, r):\n        if li[j] <= x:\n            i += 1\n            li[i], li[j] = li[j], li[i]\n\n    i += 1\n    li[i], li[r] = li[r], li[i]\n\n    return i\n\n\ndef quicksort(li, p, r):\n    \"\"\"sort li by quick sort algorithm.\n\n    >>> li = [3, 2, 1, 3, 2, 1]\n    >>> quicksort(li, 0, 5)\n    >>> li\n    [1, 1, 2, 2, 3, 3]\n    \"\"\"\n    if p < r:\n        q = partition(li, p, r)\n        quicksort(li, p, q-1)\n        quicksort(li, q+1, r)\n\n\ndef min_cost(li1, li2):\n    \"\"\"calculate minimum cost to transform li1 into li2.\n\n    >>> min_cost([1, 5, 3, 4, 2], [1, 2, 3, 4, 5])\n    7\n    >>> min_cost([4, 3, 2, 1], [1, 2, 3, 4])\n    10\n    \"\"\"\n    def find_moves(i, j):\n        start = i\n        elems = [i]\n        mincost = li1[i]\n        minidx = 0\n\n        while j != start:\n            if mincost > li1[j]:\n                mincost = li1[j]\n                minidx = len(elems)\n            elems.append(j)\n            j = li2.index(li1[j])\n\n        elems = elems[minidx+1:] + elems[:minidx+1]\n        if 2 * (mincost + li1[mini]) < (len(elems) - 1) * (mincost - li1[mini]):\n            elems.append(mini)\n            elems.insert(0, mini)\n\n        q = elems.pop()\n        p = elems.pop()\n        yield (p, q)\n        while len(elems) > 0:\n            q = p\n            p = elems.pop()\n            yield (p, q)\n\n\n    def move(i, j):\n        cost = 0\n        for p, q in find_moves(i, j):\n            li1[p], li1[q] = li1[q], li1[p]\n            cost += li1[p] + li1[q]\n\n        return cost\n\n    assert len(li1) == len(li2)\n    size = len(li1)\n    totalcost = 0\n\n    for i in reversed(range(size)):\n        if li1[i] != li2[i]:\n            mini = li1.index(li2[0])\n            totalcost += move(li1.index(li2[i]), i)\n\n    return totalcost\n\n\ndef run():\n    _ = int(input())  # flake8: noqa\n    li = [int(i) for i in input().split()]\n    sli = li[:]\n    quicksort(sli, 0, len(li)-1)\n\n    print(min_cost(li, sli))\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "\"\"\"Minimum cost Sort.\"\"\"\n\ndef make_cycle(A):\n    \"\"\"Return a list which has the minimum element of A and\n    switch elements cycles as list.\n\n    A is a list whose elements' type is 'int'.\n    \"\"\"\n    B = list(A)\n    B.sort()\n    cycle_list = [B[0]]\n    for i, b in enumerate(B):\n        if b:\n            new_cycle = []\n            new_cycle.append(b)\n            B[i] = None\n            si = A.index(b)\n            while si != i:\n                st = B[si]\n                new_cycle.append(st)\n                B[si] = None\n                si = A.index(st)\n            cycle_list.append(new_cycle)\n    return cycle_list\n\ndef min_sorting_cost(A):\n    \"\"\"Return the minimum cost of sorting A.\n\n    A is a list whose elements' type is 'int'.\n    \"\"\"\n    cycles = make_cycle(A)\n    min_w = cycles[0]\n    cost = 0\n    for c in cycles[1:]:\n        n = len(c)\n        min_cw = c[0]\n        dec = (n - 1) * (min_cw - min_w)\n        inc = 2 * (min_w + min_cw)\n        if dec < inc:\n            cost += sum(c) + min_cw * (n - 2)\n        else:\n            cost += sum(c) + min_cw * (n - 2) - dec + inc\n    return cost\n\n\nn = int(input())\n\nA = list(map(int, input().split()))\n\nans = min_sorting_cost(A)\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "def partition(target_list, l, r):\n    x = target_list[r]\n    i = l - 1\n\n    for j in range(l, r):\n        if target_list[j] <= x:\n            i = i + 1\n            tmp = target_list[i]\n            target_list[i] = target_list[j]\n            target_list[j] = tmp\n    tmp = target_list[r]\n    target_list[r] = target_list[i + 1]\n    target_list[i + 1] = tmp\n    \n    return  i + 1\n\ndef quick_sort(target_list, l, r):\n    if l < r:\n        c = partition(target_list, l, r)\n        quick_sort(target_list, l, c - 1)\n        quick_sort(target_list, c + 1, r)\n        \ndef minimum_cost_sort(target_list):\n    correct_list = [a for a in target_list]\n    quick_sort(correct_list, 0, len(correct_list) - 1)\n    cost = 0\n    i = 0\n    while not correct_list == target_list:\n        if target_list.index(correct_list[i]) == i:\n            i += 1\n        else:\n            min_i = target_list.index(correct_list[i])\n            change_i = correct_list.index(target_list[min_i])\n            cost += (target_list[min_i] + target_list[change_i])\n            tmp = target_list[min_i]\n            target_list[min_i] = target_list[change_i]\n            target_list[change_i] = tmp\n            \n    return cost\ndef main():\n    n_list = input()\n    target_list = [int(s) for s in input().split()]\n    print(minimum_cost_sort(target_list))\n    \nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport sys\n\nMAX_VALUE = int(1e4 + 1)\n\n\ndef min_cost_sort():\n    ans = 0\n    for i in range(array_length):\n        if check_order[i]:\n            continue\n        current_index = i\n        _sum, min_value, circle_size = 0, MAX_VALUE, 0\n        while True:\n            check_order[current_index] = True\n            circle_size += 1\n            current_value = array[current_index]\n            min_value = min(min_value, current_value)\n            _sum += current_value\n            current_index = kv_reverse[current_value]\n            if check_order[current_index]:\n                break\n        ans += min(_sum + (circle_size - 2) * min_value, _sum + min_value + (circle_size + 1) * _sum)\n    return ans\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    array_length = int(_input[0])\n    array = list(map(int, _input[1].split()))\n    # assert len(array) == array_length\n\n    check_order = [False] * array_length\n    kv_reverse = [-1] * MAX_VALUE\n    compare_ans = sorted(array)\n    for j in range(array_length):\n        kv_reverse[compare_ans[j]] = j\n    print(min_cost_sort())"
  },
  {
    "language": "Python",
    "code": "def partition(A, l, r):\n  p = A[r]\n  j = l - 1\n  for i in range(l, r):\n    if A[i] <= p:\n      j += 1\n      A[j], A[i] = A[i], A[j]\n  j += 1\n  A[j], A[r] = A[r], A[j]\n  return j\n\ndef quick_sort(A, l, r):\n  if l < r:\n    p = partition(A, l, r)\n    quick_sort(A, l, p - 1)\n    quick_sort(A, p + 1, r)\n\ndef minimum_cost_sort(A):\n  cost = 0\n  B = A[:]\n  quick_sort(A, 0, len(A) - 1)\n  for i in range(len(A) // 2):\n    if A[i] != B[i]:\n      cost += A[i] + B[i]\n  return cost\n\nN = int(input())\nA = list(map(int, input().split()))\nprint(minimum_cost_sort(A))"
  },
  {
    "language": "Python",
    "code": "def swap(a, b):\n    return (b, a)\n\n\ndef selectionSortWithCosts(array):\n    n = len(array)\n    cost = 0\n    for i in range(n):\n        minimumElement = min(array[i:])\n        if minimumElement == array[i]:\n            continue\n        else:\n            indexOfTheMinimumElement = array.index(minimumElement)\n            swappedElements = swap(array[i], array[indexOfTheMinimumElement])\n            array[i] = swappedElements[0]\n            array[indexOfTheMinimumElement] = swappedElements[1]\n            cost += sum(swappedElements)\n\n    return {\"cost\": cost, \"sortedArray\": array}\n\n\nn = int(input())\narray = list(map(int, input().split()))\n\nprint(selectionSortWithCosts(array)[\"cost\"])\n\n"
  },
  {
    "language": "Python",
    "code": "w=0\nn=input()\nA=map(int,raw_input().split())\nj=-1\nB=list(A)\nB.sort()\nfor i in B:\n    j+=1\n    if i==max(A):\n        break\n    while 1:\n        if i==A[j]:\n            break\n        else :\n            k=A.index(i)\n            w+=i+A[A.index(B[k])]\n            A[k]=A[A.index(B[k])]\n            A[A.index(B[k])]=i\nprint(w)"
  },
  {
    "language": "Python",
    "code": "\n\nSENTINEL = 10**9 + 1\n\n\ndef merge_sort(alist):\n    \"\"\"Sort alist using mergesort.\n    Returns a tuple of the number of comparisons and sorted list.\n\n    >>> merge_sort([8, 5, 9, 2, 6, 3, 7, 1, 10, 4])\n    (34, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    \"\"\"\n    def _sort(left, right):\n        count = 0\n        if left + 1 < right:\n            mid = (left + right) // 2\n            count += _sort(left, mid)\n            count += _sort(mid, right)\n            count += merge(left, mid, right)\n\n        return count\n\n    def merge(left, mid, right):\n        count = 0\n        ll = alist[left:mid] + [SENTINEL]\n        rl = alist[mid:right] + [SENTINEL]\n\n        i = j = 0\n        for k in range(left, right):\n            count += 1\n            if ll[i] <= rl[j]:\n                alist[k] = ll[i]\n                i += 1\n            else:\n                alist[k] = rl[j]\n                j += 1\n\n        return count\n\n    comp = _sort(0, len(alist))\n    return (comp, alist)\n\n\ndef min_cost(li1, li2):\n    \"\"\"calculate minimum cost to transform li1 into li2.\n\n    >>> min_cost([1, 5, 3, 4, 2], [1, 2, 3, 4, 5])\n    7\n    >>> min_cost([4, 3, 2, 1], [1, 2, 3, 4])\n    10\n    \"\"\"\n    def find_moves(i, j):\n        start = i\n        elems = [i]\n        mincost = li1[i]\n        minidx = 0\n\n        while j != start:\n            if mincost > li1[j]:\n                mincost = li1[j]\n                minidx = len(elems)\n            elems.append(j)\n            j = li2.index(li1[j])\n\n        elems = elems[minidx+1:] + elems[:minidx+1]\n        if 2 * (mincost + li1[mini]) < (len(elems) - 1) * (mincost - li1[mini]):\n            elems.append(mini)\n            elems.insert(0, mini)\n\n        q = elems.pop()\n        p = elems.pop()\n        yield (p, q)\n        while len(elems) > 0:\n            q = p\n            p = elems.pop()\n            yield (p, q)\n\n\n    def move(i, j):\n        cost = 0\n        for p, q in find_moves(i, j):\n            li1[p], li1[q] = li1[q], li1[p]\n            cost += li1[p] + li1[q]\n\n        return cost\n\n    assert len(li1) == len(li2)\n    size = len(li1)\n    totalcost = 0\n\n    for i in reversed(range(size)):\n        if li1[i] != li2[i]:\n            mini = li1.index(li2[0])\n            totalcost += move(li1.index(li2[i]), i)\n\n    return totalcost\n\n\ndef run():\n    _ = int(input())  # flake8: noqa\n    li = [int(i) for i in input().split()]\n    sli = li[:]\n    (_, sli) = merge_sort(sli)\n\n    print(min_cost(li, sli))\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\n*W, = map(int, input().split())\nC = {w: i for i, w in enumerate(W)}\nW.sort()\n\nans = 0\nS = []\nused = [0]*N\nfor i in range(N):\n    if used[i]:\n        continue\n    sq = []\n    w = W[i]\n    p = i; j = None\n    while j != i:\n        j = C[w]; w = W[j]\n        used[j] = 1\n        sq.append(w)\n        p = j\n    mi = min(sq); ln = len(sq)\n    if ln >= 2:\n        ans += sum(sq)\n    S.append((mi, ln))\nS.sort()\nm, ln = S[0]\nif ln >= 2:\n    ans += (ln-2)*m\nfor mi, ln in S[1:]:\n    if ln <= 2:\n        continue\n    ans += min(m+mi+ln*m, (ln-2)*mi)\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import copy\nn = int(input())\na = list(map(int, input().split()))\nb = copy.deepcopy(a)\nb.sort()\nloop = []\nminp = min(a)\nt = [0 for i in range(n)]\nwhile True:\n    i = t.index(0)\n    j = len(loop)\n    loop.append([a[i]])\n    t[i] = 1\n    while True:\n        i = b.index(a[i])\n        if t[i] == 1:\n            break\n        t[i] = 1\n        loop[j].append(a[i])\n    if sum(t) == n:\n        break\n    j += 1\nprint(loop)\ncost = 0\nfor i in loop:\n    if len(i) == 1:\n        continue\n    ps = sum(i)\n    pl = len(i)\n    pm = min(i)\n    p1 = ps + (pl - 2) * pm\n    p2 = ps + pm + (pl + 1) * minp\n    cost += min(p1, p2)\nprint(cost)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\na = list(map(int, input().split()))\nb = sorted(a)\ncost = 0\nfor i in range(n):\n    t = cnt = 0\n    x = a.index(b[i])\n    while x != i:\n        y = a.index(b[x])\n        a[x], a[y] = b[x], b[i]\n        cnt += 1\n        t += b[x] + b[i]\n        x = y\n    if cnt:\n        cost += min(t, (b[i] + b[0]) * 2 + t - (b[i] - b[0]) * cnt)\nprint(cost)\n"
  },
  {
    "language": "Python",
    "code": "def solve(A,n,s):\n    ans = 0\n\n    V = [False for i in range(n)] # 値が交換済みかどうか\n    B = sorted(A)\n    T = [None for i in range(10001)]\n    for i in range(n):\n        T[B[i]] = i\n    for i in range(n):\n        if V[i]: continue\n        cur = i #カーソル\n        S = 0 #サークル内の数字の総和\n        m = 10000 # VMAX\n        an = 0 # サークルに含まれる数字の個数\n        while True: #サークル内の処理\n            V[cur] = True\n            an += 1\n            v = A[cur]\n            m = min(m,v) #mがサークル内の最小の数字\n            S += v\n            cur = T[v]\n            if V[cur]: break\n        ans += min(S+(an-2)*m, m+S+(an+1)*s)\n    return ans\n\nn = int(input())\nA = [int(x) for x in input().split()]\ns = min(A)\n\nans = solve(A,n,s)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\na=list(map(int,input().split()))\nb=sorted(a)\nc=0\nfor i in range(n):\n t=k=0\n x=a.index(b[i])\n while x>i:\n  y=a.index(b[x])\n  a[x],a[y]=b[x],b[i]\n  k+=1\n  t+=b[x]+b[i]\n  x=y\n if k:c+=min(t,(b[i]+b[0])*2+t-(b[i]-b[0])*k)\nprint(c)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nA = [int(i) for i in input().split()]\nB = A.copy()\nB.sort()\nans = 0\nfor i in B:\n    ixB = B.index(i)\n    counter = 0\n    while(True):\n        ixA = A.index(i)\n        if ixA == ixB:\n            break\n        else:\n            counter += 1\n            num = B[ixA]\n            ixN = A.index(num)\n            A[ixA],A[ixN] = A[ixN],A[ixA]\n            ans += A[ixA] + A[ixN]\n    tmp = (B[0] - i)*counter + (B[0]+i)*2\n    if tmp < 0:\n        ans += tmp\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "MAX = 1000\nVMAX = 10000\n\n\ndef main():\n    n = int(input())\n    \n    a_s = list(map(int, input().split(' ')))\n    minimum = min(a_s)\n\n    ans = 0\n\n    t_s = [0] * (VMAX+1)\n    b_s = [a for a in a_s]\n    v_s = [False for _ in range(n)]\n    b_s = sorted(b_s)\n\n    for i in range(n):\n        t_s[b_s[i]] = i\n\n    for i in range(n):\n        if v_s[i]:\n            continue\n        cur = i\n        S = 0\n        m = VMAX\n        a_n = 0\n\n        while True:\n            v_s[cur] = True\n            a_n += 1\n            v = a_s[cur]\n            m = min(m, v)\n            S += v\n            cur = t_s[v]\n            if v_s[cur]:\n                break\n        ans += min(S + (a_n-2)*m, m+S+(a_n+1)*minimum)\n    \n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\ndata=list(map(int,input().split()))\n\nsorted_data=sorted(data)\nmindata=sorted_data[0]\n\ndata_dict={}\nfor i in range(n):\n    data_dict[data[i]]=i#key：データに含まれる要素　value:そのデータのインデックス\n\nsorted_data_dict={}\nfor i in range(n):\n    sorted_data_dict[sorted_data[i]]=i\n\n\nswap_cost=0\n\n\nfor x in sorted_data:\n    if(sorted_data_dict[x]!=data_dict[x]):\n        tmp_cost=0\n        swap_num=0\n\n        while(sorted_data_dict[x]!=data_dict[x]):\n            ind1=data_dict[x]\n            ind2=data_dict[sorted_data[ind1]]\n            data_dict[x]=ind2\n            data_dict[sorted_data[ind1]]=ind1\n            tmp_cost+=x+sorted_data[ind1]\n            swap_num+=1\n        if( (x+mindata)*2 < swap_num*(x-mindata) ):\n            tmp_cost+=(x+mindata)*2 - swap_num*(x-mindata)\n        swap_cost+=tmp_cost\n\nprint(swap_cost)\n"
  },
  {
    "language": "Python",
    "code": "#最小コストソート\n\nn = int(input())\na = list(map(int, input().split()))\nb = sorted(a)\nc = 0\nfor i in range(n-1):\n    t = cnt = 0\n    #本来i番目にいるべき値はaではどこにいるのか（ループの最小値）\n    x = a.index(b[i])\n    #もしあるべき場所にあったり、あるべき場所に帰ってきたら終了\n    while x != i:\n        #ループで最も小さい値を使いまわしながら整えていく\n        #ループの最小値が入っている場所にいるべき値がaでは何処にいるか\n        y = a.index(b[x])\n        #a[x]とa[y]を入れ替えればよい\n        a[x],a[y] = a[y],a[x];cnt += 1\n        t += a[x] + a[y]\n        x = y\n    if cnt: c += min(t, (b[i]+b[0])*2 + t -(b[i]-b[0])*cnt)\nprint(c)\n# print(a)\n"
  },
  {
    "language": "Python",
    "code": "def silly_sort(target):\n    ranked = sorted(target)\n    length = len(target)\n    rings = [n for n in range(length)]\n    all_cost = 0\n    minimum = ranked[0]\n    base_index = {}\n    rank_index = {}\n    for i, (t, r) in enumerate(zip(target, ranked)):\n        base_index[t] = i\n        rank_index[r] = i\n    for i in range(length):\n        if rings[i] != -1 and target[i] != ranked[i]:\n            ring_sum = target[i]\n            min_m = target[i]\n            num_ring = 1\n            next_index = rank_index[target[i]]\n            next_num = target[next_index]\n            while next_index != i:\n                # print(i, next_index, target[i], min_m, ring_sum)\n                num_ring += 1\n                ring_sum += next_num\n                min_m = min(min_m, next_num)\n                rings[next_index] = -1\n                next_index = rank_index[target[next_index]]\n                next_num = target[next_index]\n            # print(min((ring_sum + min_m * (num_ring - 2) ), (ring_sum + min_m + minimum * (num_ring + 1) ) ))\n            all_cost += min((ring_sum + min_m * (num_ring - 2) ), (ring_sum + min_m + minimum * (num_ring + 1) ) )\n        rings[i] = -1\n    return all_cost\n\nl = int(input())\nt = [int(n) for n in input().split(\" \")]\nprint(silly_sort(t))\n"
  },
  {
    "language": "Python",
    "code": "# L = [int(x) for x in \"1 5 3 4 2\".split()]\n# n = len(L)\n\nn = int(input())\nline = input()\nL = [int(x) for x in line.split()]\n\nflags = [False] * n\nloops = []\n\nfor i, x in enumerate(L):\n    k = x-1\n    if flags[k]:\n        continue\n    if i == k:\n        flags[i] = True\n        continue\n\n    loop = []\n    while k not in loop:\n        flags[k] = True\n        loop.append(k)\n        k = L[k]-1\n    loops.append(loop)\n\n\ncost = 0\nfor loop in loops:\n    cost += min(loop) * len(loop) + sum(loop)\n\nprint(cost)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nw = list(map(int, input().split()))\nws = sorted(w)\nd = {v:i for i, v in enumerate(ws)}\nchecked = [False] * n\ncost = 0\nwmin = min(w)\n\nfor i in range(n):\n    if checked[i] or d[w[i]] == i:\n        continue\n    # 循環群をさがす\n    gcnt = 0\n    gmin = gtot = w[i]\n    nexti = d[w[i]]\n    while nexti != i:\n        checked[nexti] = True\n        gcnt += 1\n        gmin = min(gmin, w[nexti])\n        gtot += w[nexti]\n        nexti = d[w[nexti]]\n    cost += gtot + min(gmin * (gcnt - 1), wmin * (gcnt + 2) + gmin)\nprint(cost)\n\n"
  },
  {
    "language": "Python",
    "code": "let quick_sort a n cmp =\n  let swap i j = let tmp = a.(i) in a.(i) <- a.(j); a.(j) <- tmp in\n  let partition p r =\n    let i = ref p in\n    for j = p to r - 1 do\n      if cmp a.(j) a.(r) <= 0 then (swap !i j; incr i)\n    done;\n    swap !i r;\n    !i in\n  let rec doit p r =\n    if p >= r then () else\n    let q = partition p r in\n    doit p (q - 1);\n    doit (q + 1) r in\n  doit 0 (n - 1)\n\nlet calc_cost a n =\n  let b = Array.copy a in\n  quick_sort b n compare;\n  let t = Array.make (b.(n-1) + 1) 0 in\n  Array.iteri (fun i e -> t.(e) <- i) b;\n  let p = Array.make n false in\n  let rec cycle i acc =\n    p.(i) <- true;\n    let j = t.(a.(i)) in\n    if p.(j) then a.(i) :: acc\n    else cycle j (a.(i) :: acc) in\n  let cycle i = cycle i [] in\n  let rec doit i acc =\n    if i = n then acc\n    else if p.(i) then doit (i + 1) acc\n    else\n      let ws = cycle i in\n      let m = List.length ws in\n      let s = List.fold_left (+) 0 ws in\n      let z = List.fold_left min max_int ws in\n      doit (i + 1) (acc + (min (s + (m - 2)*z) (s + z + (m + 1)*b.(0)))) in\n  doit 0 0\n\nlet () =\n  let n = read_int () in\n  let a = Array.init n (fun _ -> Scanf.scanf \"%d \" (fun e -> e)) in\n  calc_cost a n |> Printf.printf \"%d\\n\"\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nline = input()\nL = [int(x) for x in line.split()]\n\nflags = [False] * n\nloops = []\n\nfor i, x in enumerate(L):\n    k = x - 1\n    if flags[k]:\n        continue\n    if i == k:\n        flags[i] = True\n        continue\n\n    loop = []\n    while x not in loop:\n        flags[k] = True\n        loop.append(x)\n        x = L[k]\n        k = x - 1\n    loops.append(loop)\n\ncost = 0\nfor loop in loops:\n    m = min(loop)\n    cost += m * (len(loop)-1) + sum(loop) - m\n\nprint(cost)"
  },
  {
    "language": "Python",
    "code": "#最小コストソート\n\nn = int(input())\na = list(map(int, input().split()))\nb = sorted(a)\nc = 0\nfor i in range(n-1):\n    t = cnt = 0\n    x = a.index(b[i])\n    while x != i:\n        y = a.index(b[x])\n        a[x],a[y] = a[y],a[x];cnt += 1\n        t += a[x] + a[y]\n        x = y\n    if cnt: c += min(t, (b[i]+b[0])*2 + t -(b[i]-b[0])*cnt)\nprint(c)\n\n"
  },
  {
    "language": "Python",
    "code": "#! /usr/local/bin/python3\n# coding: utf-8\n\nfrom itertools import product\nfrom math import inf\nfrom sys import setrecursionlimit\n\nsetrecursionlimit(10000)\n\nws = []\nmin_weight = inf\n\n\ndef swap(w, i, j):\n    tmp = w[i]\n    w[i] = w[j]\n    w[j] = tmp\n\n\ndef try_next(w, total, hand):\n    global min_weight\n\n    if total > min_weight:\n        return\n\n    if w == ws:\n        min_weight = min(total, min_weight)\n        return\n\n    for i, j in product(range(len(w)), range(len(w))):\n        if i >= j:\n            continue\n        wnew = w[:]\n        swap(wnew, i, j)\n        hnew = hand[:]\n        hnew.append((i, j))\n        try_next(wnew, total + w[i] + w[j], hnew)\n\n    return\n\n\ndef first_try(w):\n    global ws\n\n    weight = 0\n    for i in reversed(range(len(w))):\n        j = w.index(ws[i])\n        if i != j:\n            weight += w[i] + w[j]\n            swap(w, i, j)\n    return weight\n\n\ndef main():\n    global ws, min_weight\n\n    n = int(input())\n    w = [int(x) for x in input().split()]\n    ws = sorted(w)\n\n    min_weight = first_try(w[:])\n    try_next(w, 0, [])\n    print(min_weight)\n\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "#! /usr/local/bin/python3\n# coding: utf-8\n\nfrom bisect import bisect_left\n\n\ndef swap(w, i, j):\n    tmp = w[i]\n    w[i] = w[j]\n    w[j] = tmp\n\n\ndef min_weight(w):\n    ws = sorted(w)\n    weight = 0\n    for i in reversed(range(len(w))):\n        j = bisect_left(ws, w[i])\n        if i != j:\n            weight += w[i] + w[j]\n            swap(w, i, j)\n    return weight\n\n\ndef main():\n    n = int(input())\n    w = [int(x) for x in input().split()]\n    print(min_weight(w))\n\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import *\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\n\ndef main():\n    def update(j, min_w, sum_w, wn):\n        j = ia[j][0]\n        fin[j] = True\n        w = ia[j][1]\n        if w < min_w: min_w = w\n        return j, min_w, sum_w + w, wn + 1\n\n    inf = 10 ** 16\n    n = int(input())\n    aa = list(map(int, input().split()))\n    ia = [[i, a] for i, a in enumerate(aa)]\n    ia.sort(key=lambda x: x[1])\n    #print(ia)\n    fin = [False] * n\n    min_a = ia[0][1]\n    ans = 0\n    for i in range(n):\n        if fin[i]: continue\n        min_w = inf\n        sum_w = 0\n        wn = 0\n\n        j, min_w, sum_w, wn = update(i, min_w, sum_w, wn)\n        if i == j: continue\n\n        while j != i:\n            j, min_w, sum_w, wn = update(j, min_w, sum_w, wn)\n\n        ans += min(sum_w + min_w * (wn - 2), sum_w + min_a * (wn + 1) + min_w)\n    print(ans)\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "import functools\n\ndef find_all_rings(items):\n    \"items: (??°???, ?????????????????????????????????)\"\n    l = len(items)\n    check_list = [False] * l\n    rings = []\n    i = 0\n    while i < l:\n        if check_list[i] == False:\n            ring = []\n            first = items[i]\n            ring.append(first)\n            check_list[i] = True\n            item_index = first[1]\n            item = items[item_index]\n            while item[0] != first[0]:\n                ring.append(item)\n                check_list[item_index] = True\n                item_index = item[1]\n                item = items[item_index]\n            rings.append(ring)\n        i += 1\n    return rings\n\ndef compute_ring_cost(min_all, ring):\n    l = len(ring)\n    if l <= 1:\n        return 0\n    w = [item[0] for item in ring]\n    min_ring = min(w)\n    sum_ring = sum(w)\n    if (l + 1) * min_all < (l - 3) * min_ring:\n        return sum_ring + min_ring + (l + 1) * min_all\n    else:\n        return sum_ring + (l - 2) * min_ring\n\nn = int(input())\nns = list(map(int, input().split()))\nitems = []\nsorted_items = []\nfor i in range(n):\n    item = (ns[i], i)\n    items.append(item)\n    sorted_items.append(item)\n\nsorted_items.sort(key = lambda x : x[0])\n\nfor i in range(n):\n    item = sorted_items[i]\n    items_index = item[1]\n    items[items_index] = (item[0], i)\n\nrings = find_all_rings(items)\ncompute_ring_cost1 = functools.partial(compute_ring_cost, min(ns))\nprint(sum(map(compute_ring_cost1, rings)))"
  },
  {
    "language": "Python",
    "code": "#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_6_D\n#????°???????????????????\ndef partition(target_list, l, r):\n    x = target_list[r]\n    i = l - 1\n\n    for j in range(l, r):\n        if target_list[j] <= x:\n            i = i + 1\n            tmp = target_list[i]\n            target_list[i] = target_list[j]\n            target_list[j] = tmp\n    tmp = target_list[r]\n    target_list[r] = target_list[i + 1]\n    target_list[i + 1] = tmp\n    \n    return  i + 1\n\ndef quick_sort(target_list, l, r):\n    if l < r:\n        c = partition(target_list, l, r)\n        quick_sort(target_list, l, c - 1)\n        quick_sort(target_list, c + 1, r)\n        \ndef minimum_cost_sort(target_list):\n    correct_list = [a for a in target_list]\n    quick_sort(correct_list, 0, len(correct_list) - 1)\n    cost = 0\n    i = 0\n    while not correct_list == target_list:\n        if target_list.index(correct_list[i]) == i:\n            i += 1\n        else:\n            min_i = target_list.index(correct_list[i])\n            change_i = target_list.index(correct_list[min_i])\n            cost += (target_list[min_i] + target_list[change_i])\n            tmp = target_list[min_i]\n            target_list[min_i] = target_list[change_i]\n            target_list[change_i] = tmp\n    return cost\ndef main():\n    n_list = input()\n    target_list = [int(s) for s in input().split()]\n    print(minimum_cost_sort(target_list))\n    \nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n\nn = int(input().rstrip())\nwi = [int(i) for i in input().rstrip().split()]\nvisited = [False for i in range(n)]\nminw = min(wi)\ndict = {}\nfor i, v in enumerate(sorted(wi)):\n    dict[v] = i\n\nans = 0\nfor i in range(n):\n    if visited[i]:\n        continue\n    cnt = 0\n    now = i\n    mi = 100000\n    s = 0\n    while True:\n        if visited[now]:\n            break\n        cnt += 1\n        visited[now] = True\n        mi = min(mi, wi[now])\n        s += wi[now]\n        now = dict[wi[now]]\n    \n    tmp = s + (cnt-2)*mi\n    tmp = min(tmp, s+mi+minw*(cnt+1))\n    ans += tmp\n\nprint(ans)\n    \n"
  },
  {
    "language": "Python",
    "code": "WMAX = 10 ** 4 + 1\nn = int(input())\nA = list(map(int, input().split()))  #1 5 3 4 2\nB = sorted(A)  #1 2 3 4 5\n\nis_visited = [False] * n\nnext_idxs = {}\n\nfor i, b in enumerate(B):\n  next_idxs[b] = i\n\nm_A = min(A)\n\nans = 0\nfor i in range(n):\n  if is_visited[i]:\n    continue\n  cur = i\n  S = 0\n  n2 = 0\n  m = WMAX\n  while True:\n    is_visited[cur] = True\n    S += A[cur]\n    m = min(m, A[cur])\n    n2 += 1\n    cur = next_idxs[A[cur]]\n    if is_visited[cur]:\n      break\n  ans += min(m*(n2-2) + S, m+S+(1+n2)*m_A)\n\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_6_D\n#????°???????????????????\ndef partition(target_list, l, r):\n    x = target_list[r]\n    i = l - 1\n\n    for j in range(l, r):\n        if target_list[j] <= x:\n            i = i + 1\n            tmp = target_list[i]\n            target_list[i] = target_list[j]\n            target_list[j] = tmp\n    tmp = target_list[r]\n    target_list[r] = target_list[i + 1]\n    target_list[i + 1] = tmp\n    \n    return  i + 1\n\ndef quick_sort(target_list, l, r):\n    if l < r:\n        c = partition(target_list, l, r)\n        quick_sort(target_list, l, c - 1)\n        quick_sort(target_list, c + 1, r)\n\ndef processA(target_list, correct_list, i):\n\n    cost = 0\n    while not correct_list[i] == target_list[i]:\n        min_i = target_list.index(correct_list[i])\n        change_i = target_list.index(correct_list[min_i])\n        cost += (target_list[min_i] + target_list[change_i])\n        target_list[min_i], target_list[change_i] = target_list[change_i], target_list[min_i]\n\n    return cost\n    \ndef processB(target_list, correct_list, i):\n    most_min = correct_list[0]\n    second_min = correct_list[i]\n    cost = (most_min + second_min)\n    \n    mmi = target_list.index(most_min)\n    smi = target_list.index(second_min)\n    target_list[mmi], target_list[smi] = target_list[smi], target_list[mmi]\n    \n    while not correct_list[i] == target_list[i]:\n        #print(target_list)\n        min_i = target_list.index(correct_list[i])\n        change_i = target_list.index(correct_list[min_i])\n        cost += (target_list[min_i] + target_list[change_i])\n        target_list[min_i], target_list[change_i] = target_list[change_i], target_list[min_i]\n\n    return cost\n    \ndef minimum_cost_sort(target_list):\n    correct_list = [a for a in target_list]\n    quick_sort(correct_list, 0, len(correct_list) - 1)\n    cost = 0\n    i = 0\n    while not correct_list == target_list:\n        cost_a = processA(target_list, correct_list, i)\n        cost_b = processB([a for a in target_list], correct_list, i)\n        cost += min(cost_a, cost_b)\n        print(cost_a, cost_b)\n        #print(target_list)\n        i += 1\n    return cost\ndef main():\n    n_list = input()\n    target_list = [int(s) for s in input().split()]\n    print(minimum_cost_sort(target_list))\n    \nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "def calc_loop_cost(loop, min_w):\n    if len(loop) == 1:\n        return 0\n    elif len(loop) == 2:\n        return loop[0] + loop[1]\n    else:\n        cost1 = sum(loop) + (len(loop) - 2) * min(loop)\n        cost2 = sum(loop) + min(loop) + (len(loop) + 1) * min_w\n        return min(cost1, cost2)\n\nn = int(input())\norg_list = [int(s) for s in input().split()]\nsorted_list = sorted(org_list)\ncheck_list = [False] * n\nloop_list = []\nfor i in range(n):\n    if check_list[i]:\n        continue\n\n    loop = []\n    check_list[i] = True\n    loop.append(org_list[i])\n    next_idx = sorted_list.index(org_list[i])\n    while next_idx != i:\n        check_list[next_idx] = True\n        loop.append(org_list[next_idx])\n        next_idx = sorted_list.index(org_list[next_idx])\n\n    loop_list.append(loop)\n\nmin_w = sorted_list[0]\ncost_sum = 0\nfor lp in loop_list:\n    cost_sum += calc_loop_cost(lp, min_w)\n\nprint(cost_sum)\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\na=list(map(int, input().split()))\nb=sorted(a)\nc=0\nfor i in range(n):\n x=a.index(b[i])\n j=0\n while x > i:\n  j+=1\n  y=a.index(b[x])\n  c+=a[b]\n  a[x],a[y]=a[y],a[x]\n  x=y\n c+=min(b[i]*j,b[i]*2+b[0]*(j+2))\nprint(c)\n"
  },
  {
    "language": "Python",
    "code": "def swap(A,i,j):\n    A[i],A[j] = A[j],A[i]\n    return A\n\ndef mincost(A):\n    B = sorted(A)\n    cost = 0\n    \n    for i, bi in enumerate(B):\n        t = 0\n        j = A.index(bi)\n        tmp_cost = 0\n        \n        # swap in a cyclic group\n        while j != i:\n            t += 1\n            bj = B[j]\n            k = A.index(bj)\n            tmp_cost += bi + bj\n            swap(A,j,k)\n            j = k\n        \n        # diff. to swap with min(B)\n        dec = t * (bi - B[0])\n        inc = 2 * (bi + B[0])\n        \n        if dec < inc:\n            cost += tmp_cost\n        else:\n            cost += tmp_cost - dec + inc\n    return cost\n\nif __name__ == \"__main__\":\n    input()\n    A = list(map(int, input().strip().split()))\n    cost = mincost(A)\n    print(cost)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport sys\n\nMAX_VALUE = 1e4\n\n\ndef min_cost_sort():\n    ans = 0\n    for i in range(array_length):\n        if check_order[i]:\n            continue\n        current_index = i\n        _sum, min_value, circle_size = 0, MAX_VALUE, 0\n        while True:\n            check_order[current_index] = True\n            circle_size += 1\n            current_value = array[current_index]\n            min_value = min(min_value, current_value)\n            _sum += current_value\n            current_index = kv_reverse[current_value]\n            if check_order[current_index]:\n                break\n        ans += min(_sum + (circle_size - 2) * min_value, _sum + min_value + (circle_size + 1) * _sum)\n    return ans\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    array_length = int(_input[0])\n    array = list(map(int, _input[1].split()))\n    # assert len(array) == array_length\n\n    check_order = [False] * array_length\n    kv_reverse = [-1] * (array_length + 1)\n    compare_ans = sorted(array)\n    for j in range(array_length):\n        kv_reverse[compare_ans[j]] = j\n    print(min_cost_sort())"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\n\nW_MAX = 10000\n\nn = int(stdin.readline().rstrip())\nw = [int(x) for x in stdin.readline().rstrip().split()]\nmin_w = min(w)\nidx = {}\nfor i, wi in enumerate(sorted(w)):\n    idx[wi] = i\n\nisVisited = [False]*n\ncost = 0\nfor i in range(n):\n    if isVisited[i]:\n        continue\n\n    cur = i\n    cyc = []\n    min_cyc = W_MAX\n    while not isVisited[cur]:\n        isVisited[cur] = True\n        cyc.append(w[cur])\n        min_cyc = min(min_cyc, w[cur])\n        cur = idx[w[cur]]\n\n    cost += min(sum(cyc) + (len(cyc)-2)*min_cyc, sum(cyc) + (len(cyc)+1)*min_w + min_cyc)\n\nprint(cost)\n\n"
  },
  {
    "language": "Python",
    "code": "\"\"\"Minimum cost Sort.\"\"\"\n\ndef min_cost_sort(A):\n    \"\"\"Sort list A in ascending order.\n \n    And return the switching cost in sorting.\n    \"\"\"\n    B = list(A)\n    B.sort()\n    cost = 0\n    min_w = B[0]\n    for i, b in enumerate(B):\n        tmp_cost = 0\n        bi = A.index(b)\n        n = 1\n        while bi != i:\n            n += 1\n            st = B[bi]\n            si = A.index(st)\n            tmp_cost += b + st\n            A[bi], A[si] = st, b\n            bi = si\n        dec = (n - 1) * (b - min_w)\n        inc = 2 * (min_w + b)\n        if dec < inc:\n            cost += tmp_cost\n        else:\n            cost += tmp_cost - dec + inc\n    return cost\n\n\nn = input()\n\nA = list(map(int, input().split()))\n\nans = min_cost_sort(A)\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nn_lst = list(map(int, input().split()))\nsorted_lst = sorted(n_lst)\ncost = 0\n\nfor i in range(n):\n    a = n_lst.index(sorted_lst[i])\n    j = 0\n    while a > i:\n        j += 1\n        b = n_lst.index(sorted_lst[a])\n        cost += n_lst[b]\n        n_lst[a],n_lst[b] = n_lst[b],n_lst[a]\n        a = b\n    cost += min(sorted_lst[i]*j,sorted_lst[i]*2+sorted_lst[0]*(j+2))\nprint(cost)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef minimumCostSort(A):\n    B = sorted(A)\n    V = [False] * len(A)\n    T = [0] * 10000\n    ans = 0\n    s = min(A)\n\n    for i in range(len(A)):\n        T[B[i]] = i\n\n    for i in range(len(A)):\n        if V[i]:\n            continue\n        S = an = 0\n        j = i\n        m = 10000\n        while True:\n            V[j] = True\n            an += 1\n            v = A[j]\n            m = min(m, v)\n            S += v\n            j = T[v]\n            if V[j]:\n                break\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s)\n    return ans\n\nif __name__ == \"__main__\":\n    lines = sys.stdin.readlines()\n    A = map(int, lines[1].split())\n    print minimumCostSort(A)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nl = list(map(int, input().split()))\ns = sorted(l)\ncost = 0\nfor i in range(n):\n    a = l.index(s[i])\n    j = 0\n    while a > i:\n        j += 1\n        b = l.index(s[a])\n        cost += l[b]\n        l[a], l[b] = l[b], l[a]\n        a = b\n    cost += min(s[i] * j, s[i] * 2 + s[0] * (j + 2))\nprint(cost)"
  },
  {
    "language": "Python",
    "code": "def get_weights():\n    raw_input()\n    return map(int, raw_input().split())\n\n#weights: list\ndef minimam_cost_sort(weights):\n    mw = min(weights)\n    s_w = sorted(weights)\n    lol = []\n    for i in range(len(weights)):\n        if weights[i] != 0:\n            j = weights[i]\n            idx = s_w.index(j)\n            weights[i] = 0\n            l = [j]\n            while weights[idx] != 0:\n                l.append(weights[idx])\n                j = weights[idx]\n                weights[idx] = 0\n                idx = s_w.index(j)\n            l.sort()\n            lol.append(l)\n\n    lol.sort()\n    print lol\n    s = 0\n    for l in lol:\n        s += get_wol(l, mw)\n\n    print s\n\ndef get_wol(l, mw):\n    sub = (l[0] - mw) * (len(l) - 1) - (l[0] + mw) * 2\n    s = sum(l) + (l[0] * (len(l) - 2))\n    if sub > 0:\n        return s - sub\n    return s\n\nminimam_cost_sort(get_weights())"
  },
  {
    "language": "Python",
    "code": "def minimum_cost_sort(A):\n  cost = 0\n  B = sorted(A)\n  for i in range(len(B)):\n    x = A.index(B[i])\n    cnt = 0\n    tmp = 0\n    while x != i:\n      y = A.index(B[x])\n      A[x], A[y] = A[y], A[x]\n      tmp += A[x] + A[y]\n      cnt += 1\n      x = y\n    if cnt > 0:\n      cost += tmp\n      #cost += min(tmp, (B[i] + B[0]) * 2 + tmp - (B[i] - B[0]) * cnt)\n  return cost\n\nN = int(input())\nA = list(map(int, input().split()))\nprint(minimum_cost_sort(A))"
  },
  {
    "language": "Python",
    "code": "n, cost = int(input()), 0\nnum = list(map(int, input().split()))\nnum_s = sorted(num)\nn0 = num_s[0]\n\nfor i in range(n - 1):\n    ni, tmp, cnt = num_s[i], 0, 0\n    si = num.index(ni)\n    while si != i:\n        nsi = num_s[si]\n        sj = num.index(nsi)\n        num[si], num[sj] = nsi, ni\n        tmp += ni + nsi\n        cnt += 1\n        si = sj\n    if cnt:\n        cost += min(tmp, (ni + n0) * 2 + tmp - (ni - n0) * cnt)\nprint(cost)"
  },
  {
    "language": "Python",
    "code": "N = int(raw_input())\nW = map(int, raw_input().split())\nT = sorted(W)\nmove = {}\nfor x in W:\n    index = T.index(x)\n    if x != W[index]:\n        move[x] = W[index]\n\ncycle = []\nwhile len(move) > 0:\n    l = []\n    k, v = move.popitem()\n    l.append(k)\n    nk = v\n    while nk != k:\n        nv = move[nk]\n        del move[nk]\n        l.append(nk)\n        nk = nv\n    cycle.append(l)\ncost = 0\nfor l in cycle:\n    n = len(l)\n    minCost = sum(l) + (n-2) * min(l)\n    otherCost = sum(l) + min(l) + (n+1) * min(W)\n    cost += minCost if minCost < otherCost else otherCost\nprint cost"
  },
  {
    "language": "Python",
    "code": "n=int(input())\na=list(map(int, input().split()))\nb=sorted(a)\nc=0\nfor i in range(n):\n x=a.index(b[i])\n j=0\n while x>i:\n  j+=1\n  y=a.index(b[x])\n  c+=a[y]\n  a[x],a[y]=a[y],a[x]\n  x=y\n c+=min(b[i]*j,b[i]*2+b[0]*(j+2))\nprint(c)\n"
  },
  {
    "language": "Python",
    "code": "def solve(a,n,mn,mx):\n\tans=0\n\tV=[False]*n\n\tb=sorted(a)\n\tT=[0]*(mx+1)\n\tfor i in range(n): T[b[i]]=i\n\tfor i in range(n):\n\t\tif V[i]: continue\n\t\tcur=i\n\t\tsum=0\n\t\tcnt=0\n\t\tm=1<<30\n\t\twhile True:\n\t\t\tV[cur]=True\n\t\t\tv=a[cur]\n\t\t\tcnt+=1\n\t\t\tsum+=v\n\t\t\tm=min(m,v)\n\t\t\tcur=T[v]\n\t\t\tif V[cur]: break\n\t\tans+=min(sum+(cnt-2)*m,sum+m+(cnt+1)*mn)\n\treturn ans\n\nn=int(input())\na=list(map(int,input().split()))\nmn=1<<30\nmx=mn*-1\nfor i in range(n):\n\tmn=min(mn,a[i])\n\tmx=max(mx,a[i])\nprint(solve(a,n,mn,mx))\n\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nA = list(map(int, input().split()))\nB = sorted(A)\nm_A = B[0]\n\nnext_idxs = {}\nfor i in range(n):\n    next_idxs[B[i]] = i\n\nans = 0\nis_visited = [False] * n\n\nfor i in range(n):\n    if is_visited[i]:\n        continue\n    cur = i\n    S = 0\n    n2 = 0\n    m = A[i]\n    while True:\n        is_visited[cur] = True\n        S = S + A[cur]\n        m = min(m, A[cur])\n        n2 = n2 + 1\n        cur = next_idxs[A[cur]]\n        if is_visited[cur]:\n            break\n    ans = ans + min(m*(n2-2)+S, m + S + (n2+1)*m_A)\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "\"\"\"Minimum cost Sort.\"\"\"\n\ndef min_c_sort(A, n):\n    cost = 0\n    for i in range(n - 1):\n        min_i = i\n        for j in range(i + 1, n):\n            if A[min_i] > A[j]:\n                min_i = j\n        if min_i != i:\n            cost += A[min_i]\n            cost += A[i]\n            A[min_i], A[i] = A[i], A[min_i]\n    return cost\n\n\nn = int(input())\n\nA = list(map(int, input().split()))\n\ncost = min_c_sort(A, n)\n\nprint(cost)"
  },
  {
    "language": "Python",
    "code": "\ndef partition(li, p, r):\n    \"\"\"Separate li with a value of li[r].\n    Returns index of the partition value.\n\n    >>> ax = [13, 19, 9, 5, 12, 8, 7, 4, 21, 2, 6, 11]\n    >>> partition(ax, 0, 11)\n    7\n    >>> ax\n    [9, 5, 8, 7, 4, 2, 6, 11, 21, 13, 19, 12]\n    \"\"\"\n    x = li[r]\n    i = p - 1\n    for j in range(p, r):\n        if li[j] <= x:\n            i += 1\n            li[i], li[j] = li[j], li[i]\n\n    i += 1\n    li[i], li[r] = li[r], li[i]\n\n    return i\n\n\ndef quicksort(li, p, r):\n    \"\"\"sort li by quick sort algorithm.\n\n    >>> li = [3, 2, 1, 3, 2, 1]\n    >>> quicksort(li, 0, 5)\n    >>> li\n    [1, 1, 2, 2, 3, 3]\n    \"\"\"\n    if p < r:\n        q = partition(li, p, r)\n        quicksort(li, p, q-1)\n        quicksort(li, q+1, r)\n\n\n\ndef min_cost(li1, li2):\n    \"\"\"calculate minimum cost to transform li1 into li2.\n\n    >>> min_cost([1, 5, 3, 4, 2], [1, 2, 3, 4, 5])\n    7\n    >>> min_cost([4, 3, 2, 1], [1, 2, 3, 4])\n    10\n    \"\"\"\n    def move(i, j):\n        cost = 0\n        k = li2.index(li1[j])\n        if li1[j] > li1[k]:\n            cost += move(j, k)\n\n        li1[i], li1[j] = li1[j], li1[i]\n        return cost + li1[i] + li1[j]\n\n    assert len(li1) == len(li2)\n    size = len(li1)\n    totalcost = 0\n\n    for i in reversed(range(size)):\n        if li1[i] != li2[i]:\n            totalcost += move(li1.index(li2[i]), i)\n\n    return totalcost\n\n\ndef run():\n    _ = int(input())  # flake8: noqa\n    li = [int(i) for i in input().split()]\n    sli = li[:]\n    quicksort(sli, 0, len(li)-1)\n\n    print(min_cost(li, sli))\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\n*W, = map(int, input().split())\nC = {w: i for i, w in enumerate(W)}\nW.sort()\n\nans = 0\nS = []\nused = [0]*N\nfor i in range(N):\n    if used[i]:\n        continue\n    sq = []\n    w = W[i]\n    p = i; j = None\n    while j != i:\n        j = C[w]; w = W[j]\n        used[j] = 1\n        sq.append(w)\n        p = j\n    mi = min(sq); ln = len(sq)\n    if ln >= 2:\n        ans += sum(sq)\n    S.append((mi, ln))\nS.sort()\nm, ln = S[0]\nif ln >= 2:\n    ans += (ln-2)*m\nfor mi, ln in S[1:]:\n    if ln <= 2:\n        continue\n    ans += min(m+mi+ln*m, (ln-2)*mi)\nprint(ans)\n\n\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\na=[int(i) for i in input().split()]\nb=sorted(a)\nc=0\nfor i in range(n-1):\n    t,cnt=0,0\n    x=a.index(b[i])\n    while x!=i:\n        y=a.index(b[x])\n        a[x],a[y]=b[x],b[i]\n        t+=b[x]+b[i]\n        cnt+=1\n        x=y\n    if cnt:\n        c+=min(t,(b[i]+b[0])*2+t-(b[i]-b[0])*cnt)\nprint(c)\n"
  },
  {
    "language": "Python",
    "code": "n = int(raw_input())\nW = map(int, raw_input().split())\ns = min(W)\nT = [0] * (max(W)+1)\n\ndef solve():\n    ans = 0\n    B = W[:]\n    V = [False] * n\n\n    B = sorted(B)\n    for i in xrange(n):\n        T[B[i]] = i\n    for i in xrange(n):\n        if V[i]:\n            continue\n        cur = i\n        S = 0\n        m = max(W)+1\n        an = 0\n        while True:\n            V[cur] = True\n            an += 1\n            v = W[cur]\n            m = min(m, v)\n            S += v\n            cur = T[v]\n            if V[cur]: break\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s)\n\n    return ans\n\ndef main():\n    ans = solve()\n    print ans\n    return 0\n\nmain()"
  },
  {
    "language": "Python",
    "code": "def swap(A,i,j):\n    A[i],A[j] = A[j],A[i]\n    return A\n\ndef mincost(A):\n    B = sorted(A)\n    cost = 0\n    b0 = B[0]\n    \n    for i, bi in enumerate(B):\n        t = 0\n        j = A.index(bi)\n        tmp_cost = 0\n        \n        # swap in a cyclic group\n        while j != i:\n            t += 1\n            bj = B[j]\n            k = A.index(bj)\n            tmp_cost += bi + bj\n            swap(A,j,k)\n            j = k\n        \n        # diff. to swap with min(B)\n        dec = t * (bi - b0)\n        inc = 2 * (bi + b0)\n        \n        if dec < inc:\n            cost += tmp_cost\n        else:\n            cost += tmp_cost - dec + inc\n    return cost\n\nif __name__ == \"__main__\":\n    input()\n    A = list(map(int, input().strip().split()))\n    cost = mincost(A)\n    print(cost)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nW = list(map(int,input().split()))\nW_2 = W[:]\nsorted_W = sorted(W)\ncost = 0\nfor i in range(n):\n    if i==0:\n        while W[i]!=sorted_W[i]:\n            a=W.index(sorted_W[i])\n            b=W.index(sorted_W[a])\n            W[a],W[b]=W[b],W[a]\n            W_2[a],W_2[b]=W_2[b],W_2[a]\n            cost+=W[a]+W[b]\n    else:\n        cost1=0\n        cost2=0\n        while W[i]!=sorted_W[i]:\n            a=W.index(sorted_W[i])\n            b=W.index(sorted_W[a])\n            W[a],W[b]=W[b],W[a]\n            cost1+=W[a]+W[b]\n        c = W_2.index(sorted_W[i])\n        W_2[0],W_2[c]=W_2[c],W_2[0]\n        cost2+=W_2[0]+W_2[c]\n        while W_2[0]!=sorted_W[0]:\n            a=W_2.index(sorted_W[0])\n            b=W_2.index(sorted_W[a])\n            W_2[a],W_2[b]=W_2[b],W_2[a]\n            cost2+=W_2[a]+W_2[b]\n        if cost1<=cost2:\n            W_2=W[:]\n            cost+=cost1\n        else:\n            W=W_2[:]\n            cost+=cost2\nprint(cost)\n"
  },
  {
    "language": "Python",
    "code": "def perfect_swap():\n    global n, a, b, cost\n    for i in range(1, n - 1):\n        for j in range(i + 1, n):\n            ai, aj = a[i], a[j]\n            if ai == b[j] and aj == b[i]:\n                a[i], a[j] = aj, ai\n                cost += ai + aj\n\n\ndef lowest_swap():\n    global n, a, b, cost\n    for i in range(n - 1):\n        bi, tmp_cost, count = b[i], 0, 0\n        while a[i] != bi:\n            si = a.index(bi)\n            bsi = b[si]\n            sj = a.index(bsi)\n            a[si], a[sj] = bsi, bi\n            tmp_cost += bi + bsi\n            count += 1\n        if count > 0:\n            if i > 0:\n                bip = b[i - 1]\n                cost += min(tmp_cost, (bi + bip) * 2 + tmp_cost - (bi - bip) * count)\n            else:\n                cost += tmp_cost\n\n\nn, a, cost = int(input()), list(map(int, input().split())), 0\nb = sorted(a)\nperfect_swap()\nlowest_swap()\nprint(cost)"
  },
  {
    "language": "Python",
    "code": "#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_6_D\n#????°???????????????????\ndef partition(target_list, l, r):\n    x = target_list[r]\n    i = l - 1\n\n    for j in range(l, r):\n        if target_list[j] <= x:\n            i = i + 1\n            tmp = target_list[i]\n            target_list[i] = target_list[j]\n            target_list[j] = tmp\n    tmp = target_list[r]\n    target_list[r] = target_list[i + 1]\n    target_list[i + 1] = tmp\n    \n    return  i + 1\n\ndef quick_sort(target_list, l, r):\n    if l < r:\n        c = partition(target_list, l, r)\n        quick_sort(target_list, l, c - 1)\n        quick_sort(target_list, c + 1, r)\n\ndef processA(target_list, correct_list, i):\n\n    cost = 0\n    while not correct_list[i] == target_list[i]:\n        min_i = target_list.index(correct_list[i])\n        change_i = target_list.index(correct_list[min_i])\n        cost += (target_list[min_i] + target_list[change_i])\n        target_list[min_i], target_list[change_i] = target_list[change_i], target_list[min_i]\n        #print(\"A\", target_list)\n    return cost\n    \ndef processB(target_list, correct_list, i):\n    minv = correct_list[0]\n    target = correct_list[i]\n\n    if minv == target:\n        return 10 ** 9\n    cost = (minv + target)\n    \n    mmi = target_list.index(minv)\n    smi = target_list.index(target)\n    target_list[mmi], target_list[smi] = target_list[smi], target_list[mmi]\n    \n    while not correct_list[i] == target_list[i]:\n        min_i = target_list.index(correct_list[i])\n        change_i = target_list.index(correct_list[min_i])\n        cost += (target_list[min_i] + target_list[change_i])\n        target_list[min_i], target_list[change_i] = target_list[change_i], target_list[min_i]\n        #print(\"B\",target_list)\n    return cost\n    \ndef minimum_cost_sort(target_list):\n    correct_list = [a for a in target_list]\n    quick_sort(correct_list, 0, len(correct_list) - 1)\n    cost = 0\n    i = 0\n    while not correct_list == target_list:\n        cost_b = processB([a for a in target_list], correct_list, i)\n        cost_a = processA(target_list, correct_list, i)\n        cost += min(cost_a, cost_b)\n        #print(cost_a, cost_b)\n        #print(target_list)\n        i += 1\n    return cost\ndef main():\n    n_list = input()\n    target_list = [int(s) for s in input().split()]\n    print(minimum_cost_sort(target_list))\n    \nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "def solve():\n    ans = 0\n\n    B = A[:]\n    V = [False] * n\n\n    B.sort()\n    for i in range(n):\n        T[B[i]] = i\n    for i in range(n):\n        if V[i]:\n            continue\n        cur = i\n        S = 0\n        m = 10000  # 10**4\n        an = 0\n        while True:\n            V[cur] = True\n            an += 1\n            v = A[cur]\n            m = min(m, v)\n            S += v\n            cur = T[v]\n            if V[cur]:\n                break\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s)\n    return ans\n\n\nif __name__ == '__main__':\n    n = int(input())\n    A = [int(i) for i in input().split()]\n    s = min(A)\n    s = min(s, 10000)\n    T = [0] * (max(A)+1)\n    ans = solve()\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "let quick_sort a n cmp =\n  let swap i j = let tmp = a.(i) in a.(i) <- a.(j); a.(j) <- tmp in\n  let partition p r =\n    let i = ref p in\n    for j = p to r - 1 do\n      if cmp a.(j) a.(r) <= 0 then (swap !i j; incr i)\n    done;\n    swap !i r;\n    !i in\n  let rec doit p r =\n    if p >= r then () else\n    let q = partition p r in\n    doit p (q - 1);\n    doit (q + 1) r in\n  doit 0 (n - 1)\n\nlet calc_cost a n =\n  let b = Array.copy a in\n  quick_sort b n compare;\n  let t = Array.make (b.(n-1) + 1) 0 in\n  Array.iteri (fun i e -> t.(e) <- i) b;\n  let p = Array.make n false in\n  let rec cycle i acc =\n    p.(i) <- true;\n    let j = t.(a.(i)) in\n    if p.(j) then a.(i) :: acc\n    else cycle j (a.(i) :: acc) in\n  let cycle i = cycle i [] in\n  let rec doit i acc =\n    if i = n then acc\n    else if p.(i) then doit (i + 1) acc\n    else\n      let ws = cycle i in\n      let m = List.length ws in\n      let s = List.fold_left (+) 0 ws in\n      let z = List.fold_left min max_int ws in\n      doit (i + 1) (acc + (min (s + (m - 2)*z) (s + z + (m + 1)*b.(0)))) in\n  doit 0 0\n\nlet () =\n  let n = read_int () in\n  let a = Array.init n (fun _ -> Scanf.scanf \"%d \" (fun e -> e)) in\n  calc_cost a n |> Printf.printf \"%d\\n\"\n"
  },
  {
    "language": "Python",
    "code": "# line = \"10 7 8 9\"\n# L = [int(x) for x in line.split()]\n# n = len(L)\n\nn = int(input())\nline = input()\nL = [int(x) for x in line.split()]\n\nflags = [False] * n\nloops = []\n\nS = sorted(L)\nfor i, x in enumerate(L):\n    k = S.index(x)\n    if flags[k]:\n        continue\n    if i == k:\n        flags[i] = True\n        continue\n\n    loop = []\n    while x not in loop:\n        flags[k] = True\n        loop.append(x)\n        x = L[k]\n        k = S.index(x)\n    loops.append(loop)\n\ncost = 0\nfor loop in loops:\n    m = min(loop)\n    cost += m * (len(loop)-1) + sum(loop) - m\n\nprint(cost)"
  },
  {
    "language": "Python",
    "code": "n=int(input())\na=list(map(int,input().split()))\nb=sorted(a)\nc=0\nfor i in range(n):\n x=a.index(b[i])\n j=0\n while x>i:\n  j+=1\n  y=a.index(b[x])\n  c+=a[y]\n  a[x],a[y]=a[y],a[x]\n  x=y\n c+=min(b[i]*j,b[i]*2+b[0]*(j+2))\nprint(c)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\na =list(map(int,input().split()))\nb = sorted(a)\nc = 0\nfor i in range(n-1):\n    t = cnt = 0\n    x = a.index(b[i])\n    while x != i:\n        y = a.index(b[x])\n        a[x],a[y] = b[x],b[i]\n        cnt += 1\n        t += b[x]+b[i]\n        x =y\n    if cnt:\n        c+= min(t,(b[i]+b[0])*2+t-(b[i]-b[0])*cnt)\n\nprint(c)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nimport sys\nimport math\nimport itertools as it\nfrom collections import deque\n\nsys.setrecursionlimit(10000000)\n\nN = input()\nA_ = map(int, raw_input().split())\nminA = min(A_)\nlst = []\nfor i in range(N):\n    lst.append((A_[i], i))\nlst.sort()\n\nA = [0] * N\nfor i in range(N):\n    A[lst[i][1]] = (lst[i][0], i)\n\nflag = [False] * N\n\ndef func(pos, lst):\n    if flag[pos]:\n        return\n    lst.append(A[pos][0])\n    flag[pos] = True\n    func(A[pos][1], lst)\n\nans = 0\nfor i in range(N):\n    if not flag[i]:\n        ret = []\n        func(i, ret)\n        ans += min(min(ret) * (len(ret) - 2) + sum(ret), sum(ret) + min(ret) + minA * (len(ret) + 1))\n\nprint ans\n"
  },
  {
    "language": "Python",
    "code": "def get_weights():\n    raw_input()\n    return map(int, raw_input().split())\n\n#weights: list\ndef minimam_cost_sort(weights):\n    mw = min(weights)\n    s_w = sorted(weights)\n    lol = []\n    for i in range(len(weights)):\n        if weights[i] != 0:\n            j = weights[i]\n            idx = s_w.index(j)\n            weights[i] = 0\n            l = [j]\n            while weights[idx] != 0:\n                l.append(weights[idx])\n                j = weights[idx]\n                weights[idx] = 0\n                idx = s_w.index(j)\n            l.sort()\n            lol.append(l)\n\n    lol.sort()\n    s = 0\n    for l in lol:\n        s += get_wol(l, mw)\n\n    print s\n\ndef get_wol(l, mw):\n    sub = (l[0] - mw) * (len(l) - 1) - (l[0] + mw) * 2\n    s = sum(l) + (l[0] * (len(l) - 2))\n    if sub > 0:\n        return s - sub\n    return s\n\nminimam_cost_sort(get_weights())"
  },
  {
    "language": "Python",
    "code": "n = int(raw_input())\nW = map(int, raw_input().split())\ns = min(W)\nT = [0] * (max(W)+1)\n\ndef solve():\n    ans = 0\n    B = W[:]\n    V = [False] * n\n\n    B.sort()\n    for i in xrange(n):\n        T[B[i]] = i\n    for i in xrange(n):\n        if V[i]:\n            continue\n        cur = i\n        S = 0\n        m = max(W)+1\n        an = 0\n        while True:\n            V[cur] = True\n            an += 1\n            v = W[cur]\n            m = min(m, v)\n            S += v\n            cur = T[v]\n            if V[cur]: break\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s)\n\n    return ans\n\ndef main():\n    ans = solve()\n    print ans\n    return 0\n\nmain()"
  },
  {
    "language": "Python",
    "code": "mp = {}\nMAXN = 1010\nmini =  100000\nw = [0] * MAXN\ndone = [False] * MAXN\n\nn = int(input())\nw1 = [int(i) for i in input().split()]\n\nfor index, value in enumerate(w1):\n    w[index] = value\n\nfor i in range(n):\n    mp[w[i]] = 0\n    mini = min(mini, w[i])\n\nk = 0\nfor i in sorted(w1):\n    mp[i] = k\n    k += 1\n\nans = 0\nfor i in range(n):\n    if done[i]: continue\n    cnt = 0\n    now = i\n    mi = 100000\n    total = 0\n    while (True):\n        if done[now]: break\n        cnt += 1\n        done[now] = True\n        mi = min(mi, w[now])\n        total += w[now]\n        now = mp[w[now]]\n    tmp = total + (cnt - 2) * mi\n    tmp = min(tmp, total + mi + mini * (cnt + 1))\n    ans += tmp\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import copy\nMAX_LENGTH = 1000\nMAX_WEIGHT = 10001\n\n\ndef minimum_sort_cost(A):\n    cost = 0\n    n = len(A)\n    s = min(A)\n    B = sorted(A)\n    V = [False] * n\n    T = [None] * MAX_WEIGHT\n\n    for i in range(n):\n        T[B[i]] = i\n    \n    for i in range(n):\n        if V[i]:\n            continue\n\n        cur = i\n        circle_len = 0\n        min_weight = MAX_WEIGHT\n        circle_weight = 0\n\n        while(True):\n            V[cur] = True\n            circle_len += 1\n            weight = A[cur]\n            min_weight = min(min_weight, weight)\n            circle_weight += weight\n            cur = T[weight]\n\n            if V[cur]:\n                break\n        \n        cost += min(circle_weight + (circle_len - 2) * min_weight,\\\n             min_weight + circle_weight + (circle_len + 1) * s)\n    \n    return cost\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    *A, = map(int, input().split())\n    print(minimum_sort_cost(A))\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\n*W, = map(int, input().split())\nC = {w: i for i, w in enumerate(W)}\nW.sort()\n\nans = 0\nS = []\nused = [0]*N\nfor i in range(N):\n    if used[i]:\n        continue\n    sq = []\n    w = W[i]\n    p = i; j = None\n    while j != i:\n        j = C[w]; w = W[j]\n        used[j] = 1\n        sq.append(w)\n        p = j\n    mi = min(sq); ln = len(sq)\n    if ln >= 2:\n        ans += sum(sq)\n    S.append((mi, ln))\nS.sort()\nm, ln = S[0]\nif ln >= 2:\n    ans += (ln-2)*m\nfor mi, ln in S[1:]:\n    if ln <= 2:\n        continue\n    ans += min(m+mi+ln*m, (ln-2)*mi)\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\na = list(map(int,input().split()))\nb = sorted(a)\nc = 0\nfor i in range(n):\n    x = a.index(b[i])\n    j = 0\n    while x > i:\n        j += 1\n        y = a.index(b[x])\n        c += a[y]\n        a[x],a[y] = a[y],a[x]\n        #print(\" \".join(map(str,a)))\n        #print(f\"x:{x} y:{y}\")\n        x = y\n    c += min(b[i]*j,b[i]*2+b[0]*(j+2))\nprint(c)\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nn = int(sys.stdin.readline())\nw = list(map(int, sys.stdin.readline().split()))\nc = [False]*n\nu = sorted(w)\ncost = 0\nwhile False in c:\n    i = c.index(False)\n    c[i] = True\n    i0=i\n    llen=1\n    lmin=w[i]\n    while True:\n        i = u.index(w[i])\n        if c[i]: break\n        c[i] = True\n        llen+=1\n        if lmin > w[i]: lmin = w[i]\n        cost += w[i]\n\n    if llen>1:\n        cost += w[i0]+min(lmin+(llen+1)*min(w), lmin*(llen-2))\n\nprint(cost)\n"
  },
  {
    "language": "Python",
    "code": "def solve(n, A):\n    def cycles():\n        V = [False] * n\n        B = sorted(A)\n        T = {B[i]: i for i in range(n)}\n        C = []\n\n        for i in range(n):\n            if V[i]:\n                continue\n            cur = i\n            cycle = []\n            while not V[cur]:\n                V[cur] = True\n                cycle.append(cur)\n                cur = T[A[cur]]\n            C.append(cycle)\n\n        return C\n\n    ans = 0\n    s = min(A)\n\n    for cycle in cycles():\n        S = sum([A[i] for i in cycle])\n        m = min([A[i] for i in cycle])\n        an = len(cycle)\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s)\n\n    return ans\n\n\ndef main():\n    n = int(input())\n    A = [int(x) for x in input().split()]\n\n    print(solve(n, A))\n\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "def get_weights():\n    raw_input()\n    return map(int, raw_input().split())\n\n#weights: list\ndef minimam_cost_sort(weights):\n    lol = []\n    for i in range(len(weights)):\n        if weights[i] !=0:\n            j = weights[i]\n            weights[i] = 0\n            l = [j]\n            while weights[j - 1] != 0:\n                l.append(weights[j - 1])\n                k = j\n                j = weights[k - 1]\n                weights[k - 1] = 0\n            l.sort()\n            lol.append(l)\n\n    lol.sort()\n    s = 0\n    for l in lol:\n        s += get_wol(l)\n\n    print s\n\ndef get_wol(l):\n    sub = (l[0] - 1) * (len(l) - 1) - (l[0] + 1) * 2\n    s = sum(l) + (l[0] * (len(l) - 2))\n    if sub > 0:\n        return s - sub\n    return s\n\nminimam_cost_sort(get_weights())"
  },
  {
    "language": "Python",
    "code": "if __name__ == \"__main__\":\n    n = int(input())\n    elements = list(map(lambda x: int(x), input().split()))\n    sorted_elements = sorted(elements)\n    total_cost = 0\n\n    for i in range(n - 1):\n        cost = 0\n        cnt = 0\n        x_idx = elements.index(sorted_elements[i])\n        while i != x_idx:\n            y_idx = elements.index(sorted_elements[x_idx])\n            elements[x_idx], elements[y_idx] = (sorted_elements[x_idx],\n                                                sorted_elements[i])\n            cnt += 1\n            cost += sorted_elements[x_idx] + sorted_elements[i]\n            x_idx = y_idx\n        if cnt:\n            total_cost += min(cost,\n                              (sorted_elements[i] + sorted_elements[0]) * 2 + cost\n                              - (sorted_elements[i] - sorted_elements[0]) * cnt)\n\n    print(total_cost)\n"
  },
  {
    "language": "Python",
    "code": "def perfect_swap():\n    global n, a, b, cost\n    for i in range(1, n - 1):\n        for j in range(i + 1, n):\n            ai, aj = a[i], a[j]\n            if ai == b[j] and aj == b[i]:\n                a[i], a[j] = aj, ai\n                cost += ai + aj\n\n\ndef lowest_swap():\n    global n, a, b, cost\n    for i in range(n - 1):\n        bi, tmp_cost, count = b[i], 0, 0\n        while a[i] != bi:\n            si = a.index(bi)\n            bsi = b[si]\n            sj = a.index(bsi)\n            a[si], a[sj] = bsi, bi\n            tmp_cost += bi + bsi\n            count += 1\n        if count:\n            if i:\n                b0 = b[0]\n                cost += min(tmp_cost, (bi + b0) * 2 + tmp_cost - (bi - b0) * count)\n            else:\n                cost += tmp_cost\n\n\nn, a, cost = int(input()), list(map(int, input().split())), 0\nb = sorted(a)\nperfect_swap()\nlowest_swap()\nprint(cost)"
  },
  {
    "language": "Python",
    "code": "def calc_cost(hoge):\n    cost = 0\n    hoge_refer = sorted(hoge[:])\n    #checker true means that this index have already looked.\n    checker = [False] * len(hoge)\n    #abs_min is minimum num in input array.\n    abs_min = hoge_refer[0]\n    #indexer -> key: sorted val, val: zero 2 n-1\n    indexer = {hoge_refer[i]:i for i in range(len(hoge_refer))}\n    \n    for now_index in range(len(hoge)):\n        if checker[now_index]:\n            continue\n        current = now_index\n        size = 0\n        sum_num = 0\n        circle_min = 10 ** 4\n        while True:\n            checker[current] = True\n            size += 1\n            val = hoge[current]\n            circle_min = min(circle_min, val)\n            sum_num += val\n            current = indexer[val]\n            if checker[current]:\n                break\n        cost += min(sum_num+(size-2)*circle_min, circle_min+sum_num+(size+1)*abs_min)\n    return cost\n        \n    \nif __name__ == '__main__':\n    _ = int(input())\n    hoge = [int(x) for x in input().split()]\n    print(calc_cost(hoge))\n"
  },
  {
    "language": "Python",
    "code": "import copy\nINFTY=1000000000\nMAX = 1000\nVMAX = 100000\n\ndef solve(W,N,VMAX):\n    T = [-1 for _ in range(VMAX)]\n    for i in range(N):\n        ans = 0\n        V = [False for _ in range(N)]\n        WW=copy.deepcopy(W)\n        WW.sort()\n        for i in range(N):\n            T[WW[i]] = i\n        for i in range(N):\n            if V[i]:\n                continue\n            cur = i\n            S = 0\n            m = VMAX\n            an = 0\n            while True:\n                V[cur] = True\n                an += 1\n                v = W[cur]\n                m = min(m,v)\n                S += v\n                cur = T[v]\n                if V[cur]:\n                   break\n            ans += min(S + (an - 2) * m, m + S + (an + 1) * s)\n    return ans\n\nN = int(input())\nW = list(map(int,input().split()))\ns = min(W)\nans = solve(W,N,VMAX)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "WMAX = 10**4 + 1\nn = int(input())\nA = list(map(int, input().split()))\nB = sorted(A)\nis_visited = [False] * n  # 巡回管理用\nnext_idxs = {}  # Aの要素について、これのkeyを見れば、その数字がsort後にどの位置にあるのかわかるように対応させる\nfor i, b in enumerate(B):\n    next_idxs[b] = i\n\nm_A = min(A)  # globalで一番小さい要素\n\n# ソート後の並び順から巡回可能なグループから答えを計算する\n# グループ内の最小の要素をm, グループの和をS, グループ内の要素数をn2とする。\n# 具体的には,m*(n2-2) + S もしくは m + S + (1+n2)*m_Aのうち小さい方\nans = 0\nfor i in range(n):\n    if is_visited[i]:\n        continue  # 巡回済みならば次へ\n    cur = i  # 巡回制御用のidx #探索済みでないiが入るはず\n    S = 0  # 合計管理用\n    n2 = 0\n    m = WMAX  # グループ内の最小値探索用\n    while True:\n        # まずはもろもろの値を更新\n        is_visited[cur] = True\n        S += A[cur]\n        m = min(m, A[cur])\n        n2 += 1\n        # ここで次のidxを取得する\n        cur = next_idxs[A[cur]]\n        if is_visited[cur]:\n            break  # もし一周したらおわり\n    # ループ内で完結したほうがいいのか外から要素を変えいてきたほうがいいのか\n    # 小さい方を採用して答えに足し込む\n    ans += min(m*(n2-2)+S, m+S+(1+n2)*m_A)\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "# https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/6/ALDS1_6_D\n# 本の解説がわかりやすい\n# ここでは本には書いてないことの補足を意識しながらコメントを付けていく\nWMAX = 10**4 + 1\nn = int(input())\nA = list(map(int, input().split()))\nB = sorted(A)\nis_visited = [False] * n  # 巡回管理用\nnext_idxs = {}  # Aの要素について、これのkeyを見れば、その数字がsort後にどの位置にあるのかわかるように対応させる\nfor i, b in enumerate(B):\n    next_idxs[b] = i\n\nm_A = min(A)  # globalで一番小さい要素\n\n# ソート後の並び順から巡回可能なグループから答えを計算する\n# グループ内の最小の要素をm, グループの和をS, グループ内の要素数をn2とする。\n# 具体的には,m*(n2-2) + S もしくは m + S + (1+n2)*m_Aのうち小さい方\nans = 0\nfor i in range(n):\n    if is_visited[i]:\n        continue  # 巡回済みならば次へ\n    cur = i  # 巡回制御用のidx #探索済みでないiが入るはず\n    S = 0  # 合計管理用\n    n2 = 0\n    m = WMAX  # グループ内の最小値探索用\n    while True:\n        # まずはもろもろの値を更新\n        is_visited[cur] = True\n        S += A[cur]\n        m = min(m, A[cur])\n        n2 += 1\n        # ここで次のidxを取得する\n        cur = next_idxs[A[cur]]\n        if is_visited[cur]:\n            break  # もし一周したらおわり\n    # ループ内で完結したほうがいいのか外から要素を変えいてきたほうがいいのか\n    # 小さい方を採用して答えに足し込む\n    ans += min(m*(n2-2)+S, m+S+(1+n2)*m_A)\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\na = list(map(int, input().split()))\nb = sorted(a)\nc = 0\nfor i in range(n - 1):\n    t = cnt = 0\n    # 動かす数字の位置\n    x = a.index(b[i])\n    while x != i:\n        # 動かす数字の所にあるべき数字\n        y = a.index(b[x])\n        # a[x], a[y] = b[x], b[i]\n        a[x], a[y] = a[y], a[x]\n        cnt += 1\n        # t += b[x] + b[i]\n        t += a[x] + a[y]\n        x = y\n    if cnt:\n        c += min(t, (b[i] + b[0]) * 2 + t - (b[i] - b[0]) * cnt)\nprint(c)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\na = [int(_) for _ in input().split()]\n\ndone = {}\nfor i in range(n):\n    done[a[i]] = 0\n# print(done)\n\ndirect = {}\na_sorted = sorted(a)\nfor i in range(n):\n    direct[a_sorted[i]] = i\n# print(direct)\n\ngroup_list = []\nfor i in range(n):\n    if done[a[i]] == 1:\n        continue\n    else:\n        f = a[i]\n        done[f] = 1\n        group = [f]\n        n = f\n        while a[direct[n]] != f:\n            n = a[direct[n]]\n            done[n] = 1\n            group.append(n)\n        group_list.append(group)\n# print(group_list)\n\nm = a_sorted[0]\ncost = 0\nwhile len(group_list) > 0:\n    group = group_list.pop()\n    if len(group) == 1:\n        continue\n    else:\n        cost += min(sum(group) + (len(group) - 2) * min(group), sum(group) + min(group) + (len(group) + 1) * m)\nprint(cost)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport sys\n\nMAX_VALUE = int(1e4 + 1)\n\n\ndef min_cost_sort():\n    ans = 0\n    for i in range(array_length):\n        if check_order[i]:\n            continue\n        current_index = i\n        circle_sum, circle_min, circle_size = 0, MAX_VALUE, 0\n        while True:\n            check_order[current_index] = True\n            circle_size += 1\n            current_value = array[current_index]\n            circle_min = min(circle_min, current_value)\n            circle_sum += current_value\n            current_index = kv_reverse[current_value]\n            if check_order[current_index]:\n                break\n        ans += min(circle_sum + (circle_size - 2) * circle_min,\n                   circle_sum + circle_min + (circle_size + 1) * min_value)\n    return ans\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    array_length = int(_input[0])\n    array = list(map(int, _input[1].split()))\n    # assert len(array) == array_length\n\n    check_order = [False] * array_length\n    kv_reverse = [-1] * MAX_VALUE\n    compare_ans = sorted(array)\n    min_value = compare_ans[0]\n    for j in range(array_length):\n        kv_reverse[compare_ans[j]] = j\n    print(min_cost_sort())"
  },
  {
    "language": "Python",
    "code": "VMAX = 10000\n\ndef minCostSort(A, n):\n\tglobal VMAX\n\tVMIN = min(A)\n\tans = 0\n\tB = A.copy()\n\tB.sort()\n\tT = [0] * (VMAX + 1)\n\tfor i in range(n):\n\t\tT[B[i]] = i\n\tV = [False] * n\n\tfor i in range(n):\n\t\tif V[i]:\n\t\t\tpass\n\t\telse:\n\t\t\tindex = i\n\t\t\tminv = VMAX\n\t\t\tcount = 0\n\t\t\tcycleweight = 0\n\t\t\twhile 1:\n\t\t\t\tV[index] = True\n\t\t\t\tcount += 1\n\t\t\t\tvalue = A[index]\n\t\t\t\tminv = min(minv, value)\n\t\t\t\tcycleweight += value\n\t\t\t\tindex = T[value]\n\t\t\t\tif V[index]:\n\t\t\t\t\tbreak\n\t\t\tans += min(cycleweight + (count - 2) * minv, cycleweight + minv + (count + 1) * VMIN)\n\treturn ans\n\n\nif __name__ == \"__main__\":\n\tn = int(input())\n\tA = list(map(int, input().split()))\n\tprint(minCostSort(A, n))\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\na=list(map(int,input().split()))\nb=sorted(a);c=0\nfor i in range(n-1):\n    t=cnt=0;x=a.index(b[i])\n    while x!=i:\n        y=a.index(b[x])\n        a[x],a[y]=b[x],b[i];cnt+=1\n        t+=b[x]+b[i]\n        x=y\n    c+=min(t,(b[i]+b[0])*2+t-(b[i]-b[0])*cnt)\nprint(c)"
  },
  {
    "language": "Python",
    "code": "#coding:utf-8\nn = int(input())\nA = list(map(int, input().split()))\nB = A[:]\nB.sort()\nC = [True for i in range(n)]\nminA = min(A)\n\nj = 0\na = []\ntotal = 0\nfor i in range(n):\n    circle = []\n    j = i\n    while C[j]:\n        C[j] = False\n        j = B.index(A[j])\n        circle.append(A[j])\n    n_c = len(circle)\n    if n_c == 2:\n        total += (circle[0]+circle[1])\n    if n_c > 2:\n        minc = min(circle)\n        cirSum = sum(circle)\n        total += min( cirSum + (n-2) * minc , cirSum + minc + (n+1)*minA)\n    a.append(circle)\n    \n\nprint(total)\n"
  },
  {
    "language": "Python",
    "code": "#最小コストソート\n\nn = int(input())\na = list(map(int, input().split()))\nb = sorted(a)\nc = 0\nfor i in range(n-1):\n    t = cnt = 0\n    #本来i番目にいるべき値はaではどこにいるのか（ループの最小値）\n    x = a.index(b[i])\n    #もしあるべき場所にあったり、あるべき場所に帰ってきたら終了\n    while x != i:\n        #ループで最も小さい値を使いまわしながら整えていく\n        #ループの最小値が入っている場所にいるべき値がaでは何処にいるか\n        y = a.index(b[x])\n        #a[x]とa[y]を入れ替えればよい\n        a[x],a[y] = a[y],a[x];cnt += 1\n        t += a[x] + a[i]\n        x = y\n    if cnt: c += min(t, (b[i]+b[0])*2 + t -(b[i]-b[0])*cnt)\nprint(c)\n# print(a)\n"
  },
  {
    "language": "Python",
    "code": "def swap(A,i,j):\n    A[i],A[j] = A[j],A[i]\n    return A\n\ndef mincost(A):\n    B = sorted(A)\n    cost = 0\n    \n    for j, bj in enumerate(B):\n        t = 0\n        i = A.index(bj)\n        tmp_cost = 0\n        \n        # swap in a cyclic group\n        while j != i:\n            t += 1\n            bi = B[i]\n            k = A.index(bi)\n            tmp_cost += bi + bj #= ak + ai\n            swap(A,j,k)\n            j = k\n        \n        # diff. to swap with min(B)\n        dec = t * (bj - B[0])\n        inc = 2 * (bj + B[0])\n        \n        if dec < inc:\n            cost += tmp_cost\n        else:\n            cost += tmp_cost - dec + inc\n    return cost\n\nif __name__ == \"__main__\":\n    input()\n    A = list(map(int, input().strip().split()))\n    cost = mincost(A)\n    print(cost)"
  },
  {
    "language": "Python",
    "code": "# Minimum cost sort\n\nn = int(input())\n*w, = map(int, input().split())\ns = list(sorted(w))\n\nsi = [0] * 10001\nfor i, v in enumerate(s):\n    si[v] = i\n\nans = 0\nb = [False] * n\nfor i in range(n):\n    if b[i]:\n        continue\n    j = i\n    mw = w[i]\n    z = 0\n    nn = 0\n    while b[j] == False:\n        b[j] = True\n        nn += 1\n        mw = min(w[j], mw)\n        z += w[j]\n        j = si[w[j]]\n    c = min((nn - 2) * mw + z, mw + z + (nn + 1) * s[0])\n    ans += c\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "\nMAX_NUM = int(1E4 + 1)\n\nif __name__ == '__main__':\n    N = int(input())\n    A = [int(i) for i in input().strip().split()]\n    sorted_A = sorted(A)\n    smallest = sorted_A[0]\n    correct_pos = [0] * MAX_NUM\n    flag_A = [False] * MAX_NUM\n    for i, val in enumerate(sorted_A):\n        correct_pos[val] = i\n\n    ans = 0\n    for i in range(len(A)):\n        if flag_A[i]:\n            continue\n        next_pos = i\n        sum = 0\n        m = 1E4\n        an = 0\n        while True:\n            an += 1\n            val = A[next_pos]\n            sum += val\n            m = min([m, val])\n            flag_A[A[next_pos]] = True\n            next_pos = correct_pos[val]\n            if flag_A[A[next_pos]]:\n                break\n        ans += min([sum + (an - 2) * m, m + sum + (an + 1) * smallest])\n\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nA = list(map(int, input().split()))\ns = min(A)\ndef solve():\n    ans = 0\n    V = [False] * n\n    # B = sorted(A)\n    # T = {B[i]: i for i in range(n)}\n\tT = {B: i for i, B in enumerate(sorted(A))}\n    for i in range(n):\n        if V[i]:\n            continue\n        cur = i\n        S = an = 0\n        m = 10000\n        while not V[cur]:\n            V[cur] = True\n            an += 1\n            v = A[cur]\n            m = min(m, v)\n            S += v\n            cur = T[v]\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s)\n    return ans\nprint(solve())\n\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\na=list(map(int,input().split()))\nb=sorted(a)\nm=b[0]\nc=0\nfor i in range(n):\n t=k=0\n x=a.index(b[i])\n while x>i:\n  y=a.index(b[x])\n  a[x],a[y]=b[x],b[i]\n  k+=1\n  t+=b[x]+b[i]\n  x=y\n if k:c+=min(t,(b[i]+m)*2+t-(b[i]-m)*k)\nprint(c)\n"
  },
  {
    "language": "Python",
    "code": "def make_cyclic(w, v):\n    flags = [True] * len(w)\n\n    cyclics = []\n    for i in range(len(w)):\n        if flags[i]:\n            flags[i] = False\n            cycle = [w[i]]\n            now = w[i]\n            while True:\n                j = v.index(now)\n                if j == i:\n                    break\n                cycle.append(w[j])\n                now = w[j]\n                flags[j] = False\n            cyclics.append(cycle)\n\n    return cyclics\n\n\ndef min_cost_sort(w):\n    v = w.copy()\n    v.sort()\n\n    cyclics = make_cyclic(w, v)\n\n    ans = 0\n    for cycle in cyclics:\n        inner_cycle = min(cycle) * (len(cycle) - 2) + sum(cycle)\n        if len(set(w) - set(cycle)) >= 1:\n            outer_cycle = min(cycle) + min(set(w) - set(cycle)) * (len(cycle) + 1) + sum(cycle)\n        else:\n            outer_cycle = inner_cycle + 1\n        ans += min(inner_cycle, outer_cycle)\n\n    return ans\n\n\nn = int(input())\nw = [int(x) for x in input().split()]\n\nprint(min_cost_sort(w))\n"
  },
  {
    "language": "Python",
    "code": "def swap(A,i,j):\n    A[i],A[j] = A[j],A[i]\n    return A\n\ndef mincost(A):\n    B = sorted(A)\n    cost = 0\n    \n    for i, bi in enumerate(B):\n        t = 0\n        j = A.index(bi)\n        tmp_cost = 0\n        \n        # swap in a cyclic group\n        while j != i:\n            t += 1\n            bj = B[j]\n            k = A.index(bj)\n            tmp_cost += bi + bj\n            swap(A,j,k)\n            j = k\n        \n        # diff. to swap with min(B)\n        dec = t * (bj - B[0])\n        inc = 2 * (bj + B[0])\n        \n        if dec < inc:\n            cost += tmp_cost\n        else:\n            cost += tmp_cost - dec + inc\n    return cost\n\nif __name__ == \"__main__\":\n    input()\n    A = list(map(int, input().strip().split()))\n    cost = mincost(A)\n    print(cost)"
  },
  {
    "language": "Python",
    "code": "WMAX = 10 ** 4 + 1\nN = int(input())\nW1 = [int(w) for w in input().split()]\nW2 = sorted(W1)\nW3 = {}\nmn1 = min(W1)\nV = [False] * N\n\nfor i, w in enumerate(W2):  W3[w] = i\n\ncost = 0\nfor i in range(N):\n    if V[i]: continue\n    cur = i\n    S = 0\n    N2 = 0\n    mn2 = WMAX\n    while True:\n        V[cur] = True\n        S += W1[cur]\n        mn2 = min(mn2, W1[cur])\n        N2 += 1\n        cur = W3[W1[cur]]\n        if V[cur]: break\n    cost += min(mn2 * (N2 - 2) + S, mn2 + S + (1 + N2) * mn1)\n\nprint(cost)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nw = list(map(int, input().split()))\ns = sorted(w)\n\ncost = 0\nfor i in range(n):\n    # 最小の要素と最小の要素の位置に適した要素と交換していく\n    now_v = s[i]\n    now_idx = w.index(s[i])\n    j = 0 # 交換回数\n    while now_idx > i:\n        j += 1\n        target_v = s[now_idx]\n        target_idx = w.index(target_v)\n        cost += w[target_idx] # ターゲットの方だけ足していく\n        w[now_idx], w[target_idx] = w[target_idx], w[now_idx]\n        now_idx = target_idx\n    # now_v * j: 普通の交換。\n    # now_v * 2 + s[0] * (j + 2): \n    #       s[0]は最小値。\n    #       最小値と現在値を交換して(コスト: now_v + s[0])、\n    #       ソート完了後に(コスト: s[0] * j)\n    #       最小値と現在値を元に戻すコスト(コスト: now_v + s[0])。\n    #       2回以上ならこっちが少ない。\n    cost += min(now_v * j, now_v * 2 + s[0] * (j + 2))\nprint(cost)\n\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\narray=[int(i) for i in input().split()]\ntemp=array.copy()\narray.sort()\nw=0\nfor i in range(n):\n    for j in range(n):\n        if i!=j and temp[i]==array[j]:\n            array[i],array[j]=array[j],array[i]\n            w+=array[i]\n            w+=array[j]\nprint(w)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nA = list(map(int, input().split()))\ns = min(A)\ndef solve():\n    ans = 0\n    V = [False] * n\n    B = sorted(A)\n    T = {B[i]: i for i in range(n)}\n    for i in range(n):\n        if V[i]:\n            continue\n        cur = i\n        S = an = 0\n        m = 10000\n        while not V[cur]:\n            V[cur] = True\n            an += 1\n            v = A[cur]\n            m = min(m, v)\n            S += v\n            cur = T[v]\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s)\n    return ans\nprint(solve())\n\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\narray=[int(i) for i in input().split()]\ntemp=array.copy()\narray.sort()\nw=0\nfor i in range(1,1+n):\n    for j in range(1,1+n):\n        if i!=j and array[n-i]==temp[n-j]:\n            temp[n-i],temp[n-j]=temp[n-j],temp[n-i]\n            w+=temp[n-i]\n            w+=temp[n-j]\nprint(w)"
  },
  {
    "language": "Python",
    "code": "n, cost = int(input()), 0\nnum = list(map(int, input().split()))\nnum_s = sorted(num)\nn0 = num[0]\n\nfor i in range(n - 1):\n    ni, tmp, cnt = num_s[i], 0, 0\n    si = num.index(ni)\n    while si != i:\n        nsi = num_s[si]\n        sj = num.index(nsi)\n        num[si], num[sj] = nsi, ni\n        tmp += ni + nsi\n        cnt += 1\n        si = sj\n    if cnt:\n        cost += min((ni + n0) * 2 + tmp - (ni - n0) * cnt, tmp)\nprint(cost)"
  },
  {
    "language": "Python",
    "code": "#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_6_D\n#????°???????????????????\ndef partition(target_list, l, r):\n    x = target_list[r]\n    i = l - 1\n\n    for j in range(l, r):\n        if target_list[j] <= x:\n            i = i + 1\n            tmp = target_list[i]\n            target_list[i] = target_list[j]\n            target_list[j] = tmp\n    tmp = target_list[r]\n    target_list[r] = target_list[i + 1]\n    target_list[i + 1] = tmp\n    \n    return  i + 1\n\ndef quick_sort(target_list, l, r):\n    if l < r:\n        c = partition(target_list, l, r)\n        quick_sort(target_list, l, c - 1)\n        quick_sort(target_list, c + 1, r)\n        \ndef minimum_cost_sort(target_list):\n    correct_list = [a for a in target_list]\n    quick_sort(correct_list, 0, len(correct_list) - 1)\n    cost = 0\n    i = 0\n    while not correct_list == target_list:\n        if target_list.index(correct_list[i]) == i:\n            i += 1\n        else:\n            min_i = target_list.index(correct_list[i])\n            change_i = target_list.index(correct_list[min_i])\n            cost += (target_list[min_i] + target_list[change_i])\n            tmp = target_list[min_i]\n            target_list[min_i] = target_list[change_i]\n            target_list[change_i] = tmp\n        print(target_list)\n    return cost\ndef main():\n    n_list = input()\n    target_list = [int(s) for s in input().split()]\n    print(minimum_cost_sort(target_list))\n    \nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "# https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/6/ALDS1_6_D\n# 本の解説がわかりやすい\n# ここでは本には書いてないことの補足を意識しながらコメントを付けていく\nWMAX = 10**4 + 1\nn = int(input())\nA = list(map(int, input().split()))\nB = sorted(A)\nis_visited = [False] * n  # 巡回管理用\nnext_idxs = {}  # Aの要素について、これのkeyを見れば、その数字がsort後にどの位置にあるのかわかるように対応させる\nfor i, b in enumerate(B):\n    next_idxs[b] = i\n\nm_A = min(A)  # globalで一番小さい要素\n\n# ソート後の並び順から巡回可能なグループから答えを計算する\n# グループ内の最小の要素をm, グループの和をS, グループ内の要素数をn2とする。\n# 具体的には,m*(n2-2) + S もしくは m + S + (1+n2)*m_Aのうち小さい方\nans = 0\nfor i in range(n):\n    if is_visited[i]:\n        continue  # 巡回済みならば次へ\n    cur = i  # 巡回制御用のidx #探索済みでないiが入るはず\n    S = 0  # 合計管理用\n    n2 = 0\n    m = WMAX  # グループ内の最小値探索用\n    while True:\n        # まずはもろもろの値を更新\n        is_visited[cur] = True\n        S += A[cur]\n        m = min(m, A[cur])\n        n2 += 1\n        # ここで次のidxを取得する\n        cur = next_idxs[A[cur]]\n        if is_visited[cur]:\n            break  # もし一周したらおわり\n    # ループ内で完結したほうがいいのか外から要素を変えいてきたほうがいいのか\n    # 小さい方を採用して答えに足し込む\n    ans += min(m*(n2-2)+S, m+S+(1+n2)*m_A)\n\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "input()\nw=list(map(int,input().split()))\nx=min(w)\nm={k:v for k,v in zip(sorted(w),w)if k!=v}\nl=list(m.keys())\nn=0\nwhile l:\n a=l.pop();b=m[a];l.remove(b)\n if a==m[b]:n+=a+b\n else:\n  t=[b]\n  while 1:\n   c=m[b];t+=[c]\n   if c==a:p,q=len(t),min(t);n+=sum(t)+min((p-2)*q,q+(p+1)*x);break\n   else:b=c;l.remove(c)\nprint(n)\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef minimumCostSort(A):\n    B = sorted(A)\n    V = [False] * len(A)\n    T = [0] * 10001\n    ans = 0\n    s = min(A)\n\n    for i in range(len(A)):\n        T[B[i]] = i\n\n    for i in range(len(A)):\n        if V[i]:\n            continue\n        S = an = 0\n        j = i\n        m = 10000\n        while True:\n            V[j] = True\n            an += 1\n            v = A[j]\n            m = min(m, v)\n            S += v\n            j = T[v]\n            if V[j]:\n                break\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s)\n    return ans\n\nif __name__ == \"__main__\":\n    lines = sys.stdin.readlines()\n    A = map(int, lines[1].split())\n    print minimumCostSort(A)"
  },
  {
    "language": "Python",
    "code": "import math\n\nn = int(input())\nA = list(map(int,input().split()))\n\nMAX = max(A)\nm = min(A)\nB = A.copy()\nresult = 0\n\ndef merge(A, left, mid, right):\n\n  global  count\n\n  L = A[left:mid]\n  L.append(math.inf)\n  R = A[mid:right]\n  R.append(math.inf)\n  i = 0\n  j = 0\n\n  for k in range(left,right):\n    if L[i] <= R[j]:\n      A[k] = L[i]\n      i = i + 1\n    else:\n      A[k] = R[j]\n      j = j + 1\n\n\ndef mergeSort(A,left,right):\n    if left +1 < right:\n        mid = (left+right) // 2\n        mergeSort(A,left,mid)\n        mergeSort(A,mid,right)\n        merge(A,left,mid,right)\n\nmergeSort(B,0,n)\n\nT = [None] * (MAX+1)\nV = [False] * n\nfor i in range(n):\n    T[B[i]] = i\n\nfor i in range(n):\n    if V[i]: continue\n    cur = i\n    ant = 0\n    S = 0\n    s = MAX\n    while(1):\n        V[cur] = True\n        v = A[cur]\n        if v < s:\n            s = v\n        S += v\n        ant += 1\n\n        cur = T[v]\n        if V[cur]: break\n\n    result += min(S+(ant-2)*s,S+s+(ant+1)*m)\n\n\nprint(result)\n\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nw = list(map(int,input().split()))\nA = dict(zip(sorted(w), w))\nmin_value = min(A)\nA = {k:v for k,v in A.items() if k != v or k == min_value}\ntotalcost = 0\n\nwhile len(A) > 1:\n    i_move_count = 0\n    i = min_value\n    if min_value == A[min_value]:\n        i = min([v for v in A if v != min_value])\n\n    while A[i] != i:\n        j = A[i]\n        A[i] = A[j]\n        A.pop(j)\n        i_move_count += 1\n        totalcost += j\n\n    if i != min_value:\n        A.pop(i)\n\n    totalcost += min((i * i_move_count), ((min_value * i_move_count) + (min_value + i) * 2))\n\nprint(totalcost)\n"
  },
  {
    "language": "Python",
    "code": "\"\"\"Minimum cost Sort.\"\"\"\n\ndef min_cost_sort(A):\n    \"\"\"Sort list A in ascending order.\n \n    And return the switching cost in sorting.\n    \"\"\"\n    B = list(A)\n    B.sort()\n    cost = 0\n    min_w = B[0]\n    for i, b in enumerate(B):\n        tmp_cost = 0\n        bi = A.index(b)\n        n = 1\n        while bi != i:\n            n += 1\n            st = B[bi]\n            si = A.index(st)\n            tmp_cost += b + st\n            A[bi], A[si] = st, b\n            bi = si\n        dec = (n - 1) * (b - min_w)\n        inc = 2 * (min_w + b)\n        if dec < inc:\n            cost += tmp_cost\n        else:\n            cost += tmp_cost - dec + inc\n    return cost\n\n\nn = input()\n\nA = list(map(int, input().split()))\n\nans = min_cost_sort(A)\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "def solve(A, n):\n    s = min(A)\n    ans = 0\n\n    B = A[:]\n    V = [False for i in A]\n    B = sorted(B)\n    T = [0 for i in range(VMAX+1)]\n    for i in range(n):\n        T[B[i]] = i\n\n    for i in range(n):\n        if V[i]:\n            continue\n        cur = i\n        S = 0\n        m = VMAX\n        an = 0\n\n        while True:\n            V[cur] = True\n            an += 1\n            v = A[cur]\n            m = min(m, v)\n            S += v\n            cur = T[v]\n            if V[cur]:\n                break\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s)\n    return ans\n\nMAX = 1000\nVMAX = 10000\n\n\nn = int(input())\nA = list(map(int, input().split()))\n\nans = solve(A, n)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_6_D\n#????°???????????????????\ndef partition(target_list, l, r):\n    x = target_list[r]\n    i = l - 1\n\n    for j in range(l, r):\n        if target_list[j] <= x:\n            i = i + 1\n            tmp = target_list[i]\n            target_list[i] = target_list[j]\n            target_list[j] = tmp\n    tmp = target_list[r]\n    target_list[r] = target_list[i + 1]\n    target_list[i + 1] = tmp\n    \n    return  i + 1\n\ndef quick_sort(target_list, l, r):\n    if l < r:\n        c = partition(target_list, l, r)\n        quick_sort(target_list, l, c - 1)\n        quick_sort(target_list, c + 1, r)\n        \ndef minimum_cost_sort(target_list):\n    correct_list = [a for a in target_list]\n    quick_sort(correct_list, 0, len(correct_list) - 1)\n    cost = 0\n    i = 0\n    while not correct_list == target_list:\n        if target_list.index(correct_list[i]) == i:\n            i += 1\n        else:\n            min_i = target_list.index(correct_list[i])\n            change_i = target_list.index(correct_list[min_i])\n            cost += (target_list[min_i] + target_list[change_i])\n            tmp = target_list[min_i]\n            target_list[min_i] = target_list[change_i]\n            target_list[change_i] = tmp\n        #print(target_list)\n    return cost\ndef main():\n    n_list = input()\n    target_list = [int(s) for s in input().split()]\n    print(minimum_cost_sort(target_list))\n    \nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nl = list(map(int, input().split()))\ns = sorted(l)\ncost = 0\nfor i in range(n):\n    a = l.index(s[i])\n    j = 0\n    while a > i:\n        j += 1\n        b = l.index(s[a])\n        cost += l[b]\n        l[a], l[b] = l[b], l[a]\n        a = b\n    cost += min(s[i] * j, s[i] * 2 + s[0] * (j + 2))\nprint(cost)\n"
  },
  {
    "language": "Python",
    "code": "def partition(li, p, r):\n    \"\"\"Separate li with a value of li[r].\n    Returns index of the partition value.\n\n    >>> ax = [13, 19, 9, 5, 12, 8, 7, 4, 21, 2, 6, 11]\n    >>> partition(ax, 0, 11)\n    7\n    >>> ax\n    [9, 5, 8, 7, 4, 2, 6, 11, 21, 13, 19, 12]\n    \"\"\"\n    x = li[r]\n    i = p - 1\n    for j in range(p, r):\n        if li[j] <= x:\n            i += 1\n            li[i], li[j] = li[j], li[i]\n\n    i += 1\n    li[i], li[r] = li[r], li[i]\n\n    return i\n\n\ndef quicksort(li, p, r):\n    \"\"\"sort li by quick sort algorithm.\n\n    >>> li = [3, 2, 1, 3, 2, 1]\n    >>> quicksort(li, 0, 5)\n    >>> li\n    [1, 1, 2, 2, 3, 3]\n    \"\"\"\n    if p < r:\n        q = partition(li, p, r)\n        quicksort(li, p, q-1)\n        quicksort(li, q+1, r)\n\n\ndef min_cost(li1, li2):\n    \"\"\"calculate minimum cost to transform li1 into li2.\n\n    >>> min_cost([1, 5, 3, 4, 2], [1, 2, 3, 4, 5])\n    7\n    >>> min_cost([4, 3, 2, 1], [1, 2, 3, 4])\n    10\n    \"\"\"\n    assert len(li1) == len(li2)\n    size = len(li1)\n    cost = 0\n    for i in reversed(range(size)):\n        e1 = li1[i]\n        e2 = li2[i]\n        if e1 == e2:\n            continue\n\n        j = li1.index(e2)\n        li1[i], li1[j] = li1[j], li1[i]\n        cost += e1 + e2\n\n    return cost\n\n\ndef run():\n    _ = int(input())  # flake8: noqa\n    li = [int(i) for i in input().split()]\n    sli = li[:]\n    quicksort(sli, 0, len(li)-1)\n\n    print(min_cost(li, sli))\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "n, a, cost = int(input()), list(map(int, input().split())), 0\nb = sorted(a)\nb0 = b[0]\nfor i in range(n - 1):\n    bi, tmp_cost, count = b[i], 0, 0\n    si = a.index(bi)\n    while si != i:\n        bsi = b[si]\n        sj = a.index(bsi)\n        a[si], a[sj] = bsi, bi\n        tmp_cost += bi + bsi\n        count += 1\n        si = sj\n    if count:\n        cost += min(tmp_cost, (bi + b0) * 2 + tmp_cost - (bi - b0) * count)\nprint(cost)"
  },
  {
    "language": "Python",
    "code": "#http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_6_D\n#????°???????????????????\ndef partition(target_list, l, r):\n    x = target_list[r]\n    i = l - 1\n\n    for j in range(l, r):\n        if target_list[j] <= x:\n            i = i + 1\n            tmp = target_list[i]\n            target_list[i] = target_list[j]\n            target_list[j] = tmp\n    tmp = target_list[r]\n    target_list[r] = target_list[i + 1]\n    target_list[i + 1] = tmp\n    \n    return  i + 1\n\ndef quick_sort(target_list, l, r):\n    if l < r:\n        c = partition(target_list, l, r)\n        quick_sort(target_list, l, c - 1)\n        quick_sort(target_list, c + 1, r)\n\ndef processA(target_list, correct_list, i):\n\n    cost = 0\n    while not correct_list[i] == target_list[i]:\n        min_i = target_list.index(correct_list[i])\n        change_i = target_list.index(correct_list[min_i])\n        cost += (target_list[min_i] + target_list[change_i])\n        target_list[min_i], target_list[change_i] = target_list[change_i], target_list[min_i]\n        print(\"A\", target_list)\n    return cost\n    \ndef processB(target_list, correct_list, i):\n    minv = correct_list[0]\n    target = correct_list[i]\n\n    if minv == target:\n        return 10 ** 9\n    cost = (minv + target)\n    \n    mmi = target_list.index(minv)\n    smi = target_list.index(target)\n    target_list[mmi], target_list[smi] = target_list[smi], target_list[mmi]\n    \n    while not correct_list[i] == target_list[i]:\n        min_i = target_list.index(correct_list[i])\n        change_i = target_list.index(correct_list[min_i])\n        cost += (target_list[min_i] + target_list[change_i])\n        target_list[min_i], target_list[change_i] = target_list[change_i], target_list[min_i]\n        print(\"B\",target_list)\n    return cost\n    \ndef minimum_cost_sort(target_list):\n    correct_list = [a for a in target_list]\n    quick_sort(correct_list, 0, len(correct_list) - 1)\n    cost = 0\n    i = 0\n    while not correct_list == target_list:\n        cost_b = processB([a for a in target_list], correct_list, i)\n        cost_a = processA(target_list, correct_list, i)\n        cost += min(cost_a, cost_b)\n        print(cost_a, cost_b)\n        #print(target_list)\n        i += 1\n    return cost\ndef main():\n    n_list = input()\n    target_list = [int(s) for s in input().split()]\n    print(minimum_cost_sort(target_list))\n    \nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "#coding:UTF-8\ndef MCS(A,n):\n    B=sorted(A)\n    B0=B[0]\n    cost=0\n    for i in range(n-1):\n        Bi,t_cost,count=B[i],0,0\n        si=A.index(Bi)\n        while si!=i:\n            bsi=B[si]\n            sj=A.index(bsi)\n            A[si],A[sj]=bsi,Bi\n            t_cost+=Bi+bsi\n            count+=1\n            si=sj\n        if count:\n            cost+=min(t_cost,(Bi + B0) * 2 + t_cost - (Bi - B0) * count) \n    print(cost)\nif __name__==\"__main__\":\n    n=int(input())\n    A=input().split(\" \")\n    for i in range(n):\n        A[i]=int(A[i])\n    MCS(A,n)"
  },
  {
    "language": "Python",
    "code": "import copy\n\ndef solve():\n    ans = 0\n    V = [False] * n\n    B = sorted(A)\n    maxWeight = B[-1]\n    minWeight = B[0]\n    T = [None] * (maxWeight + 1)\n    for i in range(n):\n        T[B[i]] = i\n        \n    for i in range(n):\n        if V[i]:\n            continue\n        \n        cur = i\n        S = 0\n        m = maxWeight\n        an = 0\n        while True:\n            V[cur] = True\n            an += 1\n            v = A[cur]\n            m = min(m, v)\n            S += v\n            cur = T[v]\n            if V[cur]:\n                break\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * minWeight)\n    \n    return ans\n\nn = int(input())\nA = list(map(int, input().split()))\n\nans = solve()\nprint(ans)\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "\ndef partition(li, p, r):\n    \"\"\"Separate li with a value of li[r].\n    Returns index of the partition value.\n\n    >>> ax = [13, 19, 9, 5, 12, 8, 7, 4, 21, 2, 6, 11]\n    >>> partition(ax, 0, 11)\n    7\n    >>> ax\n    [9, 5, 8, 7, 4, 2, 6, 11, 21, 13, 19, 12]\n    \"\"\"\n    x = li[r]\n    i = p - 1\n    for j in range(p, r):\n        if li[j] <= x:\n            i += 1\n            li[i], li[j] = li[j], li[i]\n\n    i += 1\n    li[i], li[r] = li[r], li[i]\n\n    return i\n\n\ndef quicksort(li, p, r):\n    \"\"\"sort li by quick sort algorithm.\n\n    >>> li = [3, 2, 1, 3, 2, 1]\n    >>> quicksort(li, 0, 5)\n    >>> li\n    [1, 1, 2, 2, 3, 3]\n    \"\"\"\n    if p < r:\n        q = partition(li, p, r)\n        quicksort(li, p, q-1)\n        quicksort(li, q+1, r)\n\n\ndef min_cost(li1, li2):\n    \"\"\"calculate minimum cost to transform li1 into li2.\n\n    >>> min_cost([1, 5, 3, 4, 2], [1, 2, 3, 4, 5])\n    7\n    >>> min_cost([4, 3, 2, 1], [1, 2, 3, 4])\n    10\n    \"\"\"\n    def find_min_pos(i, j):\n        start = i\n        elems = []\n        mincost = 10001\n\n        while j != start:\n            elems.append((i, j))\n            mincost = min(mincost, li1[j])\n            i = j\n            j = li2.index(li1[j])\n\n        while True:\n            (i, j) = elems.pop()\n            if li1[j] == mincost:\n                elems.append((i, j))\n                break\n\n        return reversed(elems)\n\n    def move(i, j):\n        cost = 0\n        for p, q in find_min_pos(i, j):\n            li1[p], li1[q] = li1[q], li1[p]\n            cost += li1[p] + li1[q]\n\n        return cost\n\n    assert len(li1) == len(li2)\n    size = len(li1)\n    totalcost = 0\n\n    for i in reversed(range(size)):\n        if li1[i] != li2[i]:\n            totalcost += move(li1.index(li2[i]), i)\n\n    return totalcost\n\n\ndef run():\n    _ = int(input())  # flake8: noqa\n    li = [int(i) for i in input().split()]\n    sli = li[:]\n    quicksort(sli, 0, len(li)-1)\n\n    print(min_cost(li, sli))\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "import copy\nn = int(input())\na = list(map(int, input().split()))\nb = copy.deepcopy(a)\nb.sort()\nloop = []\nminp = min(a)\nt = [0 for i in range(n)]\nwhile True:\n    i = t.index(0)\n    j = len(loop)\n    loop.append([a[i]])\n    t[i] = 1\n    while True:\n        i = b.index(a[i])\n        if t[i] == 1:\n            break\n        t[i] = 1\n        loop[j].append(a[i])\n    if sum(t) == n:\n        break\n    j += 1\ncost = 0\nfor i in loop:\n    if len(i) == 1:\n        continue\n    ps = sum(i)\n    pl = len(i)\n    pm = min(i)\n    p1 = ps + (pl - 2) * pm\n    p2 = ps + pm + (pl + 1) * minp\n    cost += min(p1, p2)\nprint(cost)\n"
  },
  {
    "language": "Python",
    "code": "n, cost = int(input()), 0\nnum = list(map(int, input().split()))\nnum_s = sorted(num)\nn0 = num[0]\n\nfor i in range(n - 1):\n    ni, tmp, cnt = num_s[i], 0, 0\n    si = num.index(ni)\n    while si != i:\n        nsi = num_s[si]\n        sj = num.index(nsi)\n        num[si], num[sj] = nsi, ni\n        tmp += ni + nsi\n        cnt += 1\n        si = sj\n    if cnt:\n        cost += min(tmp, (ni + n0) * 2 + tmp - (ni - n0) * cnt)\nprint(cost)"
  },
  {
    "language": "Python",
    "code": "\"\"\"Minimum cost Sort.\"\"\"\n\ndef make_cycle(A):\n    \"\"\"Return a list which has the minimum element of A and\n    switch elements cycles as list.\n\n    A is a list whose elements' type is 'int'.\n\n    Each cycle list has its minimum elements in the first index.\n    \"\"\"\n    B = list(A)\n    B.sort()\n    cycle_list = [B[0]]\n    for i, b in enumerate(B):\n        if b != None:\n            new_cycle = []\n            new_cycle.append(b)\n            B[i] = None\n            si = A.index(b)\n            while si != i:\n                st = B[si]\n                new_cycle.append(st)\n                B[si] = None\n                si = A.index(st)\n            cycle_list.append(new_cycle)\n    return cycle_list\n\ndef min_sorting_cost(A):\n    \"\"\"Return the minimum cost of sorting A.\n\n    A is a list whose elements' type is 'int'.\n    \"\"\"\n    cycles = make_cycle(A)\n    min_w = cycles[0]\n    cost = 0\n    for c in cycles[1:]:\n        n = len(c)\n        min_cw = c[0]\n        dec = (n - 1) * (min_cw - min_w)\n        inc = 2 * (min_w + min_cw)\n        if dec < inc:\n            cost += sum(c) + min_cw * (n - 2)\n        else:\n            cost += sum(c) + min_cw * (n - 2) - dec + inc\n    return cost\n\n\nn = int(input())\n\nA = list(map(int, input().split()))\n\nans = min_sorting_cost(A)\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "\"\"\"Minimum cost Sort.\"\"\"\n\ndef min_cost_sort(A):\n    \"\"\"Sort list A in ascending order.\n \n    And return the switching cost in sorting.\n    \"\"\"\n    B = list(A)\n    B.sort()\n    cost = 0\n    min_w = B[0]\n    for i, b in enumerate(B):\n        tmp_cost = 0\n        bi = A.index(b)\n        cnt = 0\n        while bi != i:\n            cnt += 1\n            st = B[bi]\n            si = A.index(st)\n            tmp_cost += b + st\n            A[bi], A[si] = st, b\n            bi = si\n        if cnt:\n            dec = cnt * (b - min_w)\n            inc = 2 * (min_w + b)\n            if dec < inc:\n                cost += tmp_cost\n            else:\n                cost += tmp_cost - dec + inc\n    return cost\n\n\nn = input()\n\nA = list(map(int, input().split()))\n\nans = min_cost_sort(A)\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "def decode():\n    n = int(input())\n    w = [int(x) for x in input().split()]\n\n    return n, w\n\n\ndef search(w, sw, swi):\n    wi = w.index(sw[swi])\n    cost = 0\n    count = 0\n    while wi != swi:\n        tw = sw[wi]\n        ti = w.index(tw)\n        w[ti], w[wi] = w[wi], w[ti]\n        cost += w[ti] + w[wi]\n        count += 1\n        wi = ti\n    return cost, count\n\n\ndef search_min_cost(w):\n    sorted_w = list(w)\n    sorted_w.sort()\n\n    min_w = sorted_w[0]\n    cost = 0\n\n    for i, sww in enumerate(sorted_w):\n        tmp_cost, count = search(w, sorted_w, i)\n        cost += min(tmp_cost, tmp_cost + (min_w + sww) * 2 - (sww - min_w) * count)\n\n    return cost\n\n\nif __name__ == '__main__':\n\n    n, w = decode()\n    print(search_min_cost(w))\n"
  },
  {
    "language": "Python",
    "code": "import itertools\n\n\nWAIT, PRESORT, SORTED = 0, 1, 2\ncost = 0\n\ndef swap(w1, w2):\n    global cost\n    cost += w1[WAIT] + w2[WAIT]\n    w1[PRESORT], w2[PRESORT] = w2[PRESORT], w1[PRESORT]\n    \n\nn = input()\nw = [[wi, i, None] for i, wi in enumerate(map(int, input().split()))]\ns = sorted(w)\nminw = s[0]\nfor i, wi in enumerate (s):\n    wi[SORTED] = i\n    \nfor si in s:\n    tmp = si\n    t = []\n    while tmp[SORTED] != si[PRESORT]:\n        tmp = w[tmp[SORTED]]\n        t += [tmp]\n\n    if len(t ) and minw != si and si[WAIT] * (len(t) - 2) > minw[WAIT] * (len(t) + 2):\n        swap(minw, si)\n        for ti in t[::-1]:\n            swap(minw, ti)\n        swap(minw, si)\n    else:\n        for ti in t[::-1]:\n            swap(si, ti)\n    \nprint(cost)"
  },
  {
    "language": "Python",
    "code": "input()\na=list(map(int,input().split()))\nb=sorted(a)\nc=0\nfor i in range(len(a)):\n x=a.index(b[i])\n j=0\n while x>i:\n  j+=1\n  y=a.index(b[x])\n  c+=a[y]\n  a[x],a[y]=a[y],a[x]\n  x=y\n c+=min(b[i]*j,b[i]*2+b[0]*(j+2))\nprint(c)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nwlist = list(map(int,input().split()))\nwdic = {j:i for i,j in enumerate(wlist)}\nwlist.sort()\ncost = 0\nused = [0]*n\nres = []\nfor i in range(n):\n    storage = []\n    if used[i]:\n        continue # next loop\n    w = wlist[i]\n    minimum = w\n    used[i] = 1\n    a = wdic[w]\n    b = wlist[a]\n    storage.append(w)\n    while b not in storage:\n        w = b\n        used[a] = 1\n        a = wdic[w]\n        b = wlist[a]\n        storage.append(w)\n        #print(w,a,b,storage)\n    ls = len(storage)\n    cost += (sum(storage) - minimum)\n    res.append((minimum,ls))\nm,l = res[0]\nif l>=2:\n    cost += m*(l-1)\nfor minimum,ls in res[1:]:\n    if ls>=2:\n        cost += min(2*(m+minimum)+m*(ls-1), minimum*(ls-1))\n    \nprint(cost)\n"
  },
  {
    "language": "Python",
    "code": "# INPUT\nn = int(input())\nW = list(map(int, input().split()))\n\n\n# PROCESS\ncost = 0\nW_sorted = sorted(W)\nW_min = W_sorted[0]\n\nfor i in range(n - 1):\n    cycle_min = W_sorted[i]\n    cost_cycle_in = 0\n    cnt_change = 0\n\n    index_cycle_min = W.index(cycle_min)\n\n    while index_cycle_min != i:\n        cycle_change = W_sorted[index_cycle_min]\n        index_cycle_change = W.index(cycle_change)\n\n        W[index_cycle_min], W[index_cycle_change] = cycle_change, cycle_min\n        cost_cycle_in += cycle_min + cycle_change\n\n        cnt_change += 1\n        index_cycle_min = index_cycle_change\n\n    if cnt_change:\n        cost_cycle_out = (\n            cost_cycle_in\n          + (cycle_min + W_min) * 2\n          - (cycle_min - W_min) * cnt_change\n        )\n\n        cost += min(cost_cycle_in, cost_cycle_out)\n\n\n# OUTPUT\nprint(cost)\n\n"
  },
  {
    "language": "Python",
    "code": "def minimum_cost(A, m, k):\n    \"\"\"整数列 A を最小コストソートでソートした場合の総コストを返す。\n\n    A 内の整数は 0 <= <= k のすべて異なる整数であり、\n    m がその中で最小の数。\n    \"\"\"\n    # A 内の整数 i の出現数を C[i] に記録していく。\n    C = [0 for _ in range(0, k + 1)]\n    for x in A:\n        C[x] += 1\n    \n    # A 内の i 番目の整数のソート後の位置（0 起点）を C[i] に記録する。\n    C[0] -= 1\n    for i in range(1, k + 1):\n        C[i] += C[i - 1]\n\n    total_cost = 0\n    n = len(A)\n    for i in range(n):\n        j = i\n        length = 0\n        sum_weight = 0\n        cur_min = k + 1\n        while C[A[j]] >= 0:\n            length += 1\n            sum_weight += A[j]\n            if A[j] < cur_min:\n                cur_min = A[j]\n            z = C[A[j]]\n            C[A[j]] = -1\n            j = z\n        if length >= 3:\n            if cur_min > m:\n                total_cost += min(sum_weight + cur_min * (length - 2),\n                                  (sum_weight - cur_min) + m * (length - 1) + 2 * (m + cur_min))\n            else:\n                total_cost += sum_weight + cur_min * (length - 2)\n        elif length == 2:\n            total_cost += sum_weight\n\n    return total_cost\n\nif __name__ == '__main__':\n    import sys\n\n    n = int(input())\n    A = list(map(int, sys.stdin.readline().split()))\n    print(minimum_cost(A, min(A), max(A)))\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nW = list(map(int, input().split()))\n\n_W = W[:]\n_W.sort()\nm = _W[0]\n\nC = [None for _ in range(_W[n - 1] + 1)]\nV = [False for _ in range(_W[n - 1] + 1)]\n\nfor i in range(n):\n    C[_W[i]] = W[i]\n\nr = 0\n\nfor i in _W:\n    if V[i]:\n        continue\n    nxt = C[i]\n    V[i] = True\n    if nxt == i or V[nxt]:\n        continue\n    sum_w = i\n    min_w = i\n    c = 1\n    while V[nxt] is False:\n        V[nxt] = True\n        sum_w += nxt\n        nxt = C[nxt]\n        c += 1\n    r += min(sum_w + (c - 2) * min_w, sum_w + min_w + (c + 1) * m)\n\nprint(r)\n\n"
  },
  {
    "language": "Python",
    "code": "\"\"\"Minimum cost Sort.\"\"\"\n\ndef min_cost_sort(A):\n    \"\"\"Sort list A in ascending order,\n\n    And return the switching cost in sorting.\n    \"\"\"\n    B = list(A)\n    B.sort()\n    cost = 0\n    for i, b in enumerate(B):\n        while A.index(b) != i:\n            st1 = b\n            si1 = A.index(b)\n            st2 = B[si1]\n            si2 = A.index(st2)\n            cost += st1 + st2\n            A[si1], A[si2] = st2, st1\n    return cost\n\n\nn = int(input())\n\nA = list(map(int, input().split()))\n\nans = min_cost_sort(A)\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "n=input()\nl=map(int,raw_input().split())\ns=sorted(l)\nc=0\nfor i in range(n):\n    a=l.index(s[i])\n    j=0\n    while a>i:\n        j+=1\n        b=l.index(s[a])\n        c+=l[b]\n        l[a],l[b]=l[b],l[a]\n        a=b\n    c+=min(s[i]*j,s[i]*2+s[0]*(j+2))\nprint c"
  },
  {
    "language": "Python",
    "code": "input()\nw=list(map(int,input().split()))\nx=min(w)\nm={k:v for k,v in zip(sorted(w),w)if k!=v}\nl=list(m.keys())\np=[]\nwhile l:\n a=l.pop();b=m[a];l.remove(b)\n if a==m[b]:p+=[[a,b]]\n else:\n  t=[b]\n  while 1:\n   c=m[b];t+=[c]\n   if c==a:p+=[t];break\n   else:b=c;l.remove(c)\nn=0\nfor s in p:\n n+=sum(s);t=len(s);y=min(s)\n if t>2:n+=min((t-2)*y,y+(t+1)*x)\nprint(n)\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::Read;\nuse std::cmp::min;\n\nfn main() {\n    let mut buf = String::new();\n    std::io::stdin().read_to_string(&mut buf).unwrap();\n\n    let answer = solve(&buf);\n\n    println!(\"{}\", answer);\n}\n\nfn solve(input: &str) -> String {\n    let mut iterator = input.split_whitespace();\n\n    let n: usize = iterator.next().unwrap().parse().unwrap();\n    let mut a: Vec<usize> = Vec::with_capacity(n);\n    let mut s: usize = 10_000;\n    for _ in 0..n {\n        a.push(iterator.next().unwrap().parse().unwrap());\n        s = min(s, *a.last().unwrap());\n    }\n\n    let mut b = a.clone();\n    let mut v: Vec<bool> = vec![false; n];\n\n    b.sort();\n\n    let mut t: Vec<usize> = vec![0; 10_001];\n    for i in 0..n {\n        t[b[i]] = i;\n    }\n\n    let mut ans = 0;\n    for i in 0..n {\n        if v[i] {\n            continue;\n        }\n\n        let mut cur = i;\n        let mut S: isize = 0;\n        let mut m: isize = 10_000;\n        let mut an = 0;\n        loop {\n            v[cur] = true;\n            an += 1;\n            let val = a[cur];\n            m = min(m, val as isize);\n            S += val as isize;\n            cur = t[val];\n            if v[cur] {\n                break;\n            }\n        }\n        ans += min(S + (an - 2) * m, m + S + (an + 1) * s as isize);\n    }\n\n    // let mut ans = 0;\n    // for i in 0..n {\n    //     let mut j = i;\n    //     let mut min = a[i];\n    //     for k in (i + 1)..n {\n    //         if min > a[k] {\n    //             j = k;\n    //             min = a[k];\n    //         }\n    //     }\n    //     if j != i {\n    //         ans += a[i] + a[j];\n    //         a.swap(i, j);\n    //     }\n    // }\n\n    return ans.to_string();\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "// ALDS1_6_D: Minimum Cost Sort\n\nuse std::cmp::min;\n\nfn scan<T: std::str::FromStr>() -> T {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).unwrap();\n    s.trim().parse().ok().unwrap()\n}\n\nfn scan_vec<T: std::str::FromStr>() -> Vec<T> {\n    let s: String = scan();\n    s.split_whitespace().map(|a| T::from_str(a).ok().unwrap()).collect()\n}\n\nfn solve(a: &Vec<usize>, n: usize, ss: usize) -> usize {\n    let mut ans: usize = 0;\n    let mut b = a.clone();\n    let mut v = vec![false; a.len()];\n    let mut t = vec![0; 10001];\n    b.sort();\n    for i in 0..n {\n        t[b[i]] = i;\n    }\n    for i in 0..n {\n        if v[i] {\n            continue;\n        }\n        let mut cur: usize = i;\n        let mut s: usize = 0;\n        let mut m: usize = 10001;\n        let mut an: usize = 0;\n        loop {\n            v[cur] = true;\n            an += 1;\n            let vv = a[cur];\n            m = min(m, vv);\n            s += vv;\n            cur = t[vv];\n            if v[cur] {\n                break;\n            }\n        }\n        ans += min(s + (an - 2) * m, m + s + (an + 1) * ss)\n    }\n    ans\n}\n\nfn main() {\n    let n: usize = scan();\n    let a: Vec<usize> = scan_vec();\n    let mut s: usize = 10001;\n    for i in 0..n {\n        s = min(s, a[i]);\n    }\n    let ans = solve(&a, n, s);\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\n#[allow(unused_imports)]\nuse std::collections::*;\n#[allow(unused_imports)]\nuse std::cmp::{min, max};\n\nstruct Scanner<R: Read> {\n    reader: R,\n    buffer: String,\n}\n\n#[allow(dead_code)]\nimpl<R: Read> Scanner<R> {\n    fn new(reader: R) -> Scanner<R> {\n        Scanner { reader: reader, buffer: String::new() }\n    }\n\n    // fn line(&mut self) -> String {\n    //     self.buffer = self.reader.by_ref().bytes().map(|c| c.unwrap() as char)\n    //         .skip_while(|&c| c == '\\n' || c == '\\r')\n    //         .take_while(|&c| !(c == '\\n' || c == '\\r'))\n    //         .collect::<String>();\n    //     self.buffer.clone()\n    // }\n\n    fn read_buffer(&mut self) {\n        self.buffer = self.reader.by_ref().bytes().map(|c| c.unwrap() as char)\n            .skip_while(|c| c.is_whitespace())\n            .take_while(|c| !c.is_whitespace())\n            .collect::<String>();\n    }\n\n    fn safe_read<T: FromStr>(&mut self) -> Option<T> {\n        self.read_buffer();\n        if self.buffer.is_empty() {\n            None\n        } else {\n            self.buffer.parse::<T>().ok()\n        }\n    }\n\n    fn read<T: FromStr>(&mut self) -> T {\n        if let Some(s) = self.safe_read() {\n            s\n        } else {\n            // writeln!(std::io::stderr(), \"Terminated with EOF\").unwrap();\n            std::process::exit(0);\n        }\n    }\n\n    fn vec<T: FromStr>(&mut self, len: usize) -> Vec<T> {\n        (0..len).map(|_| self.read()).collect()\n    }\n\n    fn mat<T: FromStr>(&mut self, row: usize, col: usize) -> Vec<Vec<T>> {\n        (0..row).map(|_| self.vec(col)).collect()\n    }\n}\n\ntrait Joinable {\n    fn join(self, sep: &str) -> String;\n}\n\nimpl<U: ToString, T: Iterator<Item=U>> Joinable for T {\n    fn join(self, sep: &str) -> String {\n        self.map(|x| x.to_string()).collect::<Vec<_>>().join(sep)\n    }\n}\n\nfn main() {\n    std::thread::Builder::new()\n        .stack_size(104_857_600)\n        .spawn(solve)\n        .unwrap()\n        .join()\n        .unwrap();\n}\n\nfn solve() {\n    let cin = stdin();\n    let cin = cin.lock();\n    let mut sc = Scanner::new(cin);\n\n    loop {\n        let n = sc.read();\n        let ws: Vec<u32> = sc.vec(n); // id -> w\n        let mut ids: Vec<_> = (0..n).collect(); // pos -> id\n        let mut pos: Vec<_> = (0..n).collect(); // id -> pos\n\n        let sorted_ws = {\n            let mut x: Vec<(u32, usize)> = ws.iter().cloned().zip(0..n).collect();\n            x.sort();\n            x\n        };\n\n        let mut ans = 0;\n        for (des_pos, &(_, id)) in sorted_ws.iter().enumerate() {\n            let cur_pos = pos[id];\n            if cur_pos != des_pos {\n                pos.swap(ids[cur_pos], ids[des_pos]);\n                ids.swap(cur_pos, des_pos);\n                ans += ws[ids[cur_pos]] + ws[ids[des_pos]];\n            }\n        }\n\n        println!(\"{}\", ans);\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::collections::VecDeque;\nuse std::env;\n//use std::fmt::Debug;\nuse std::io;\nuse std::cmp;\nuse std::io::prelude::*;\n//use std::time::{Duration, Instant};\n\n//===================================================\n// MACROs need to be defined above the use place ... ?\nmacro_rules! dprintln {\n    ($($x:expr),*) => {{\n        if $crate::is_debug_mode() {\n            let f = || {println!( $($x),*)};\n            f() } }} }\n\n/// Backward For-Loop Helper\n///  from -> to (exclude `to`)\n/// # Examples\n/// see tests::macro_backward()\n#[macro_export]\nmacro_rules! backward_ho {\n    ($from:expr, $to:expr) => {{\n        (($to + 1)..($from + 1)).rev() }}; }\n//===================================================\n\n#[derive(Debug)]\nstruct Quiz {\n    n: usize,    // 1 <= N <= 1,000\n    v: Vec<u32>, // 1 <= v[i] <= 10,000, length=N\n}\n\n#[derive(Debug)]\nstruct Answer {\n    min_cost: u64\n}\n\ntrait IntoQuiz {\n    fn into_quiz(self) -> Quiz;\n}\n\nimpl<I: Input> IntoQuiz for I {\n    fn into_quiz(mut self) -> Quiz {\n        let n: usize = self.parse_next().unwrap();\n        let v: Vec<u32> = self.parse_next_vec(n).unwrap();\n        Quiz { n, v }\n    }\n}\n\n#[derive(Debug,Clone)]\nstruct SortGroup {\n    min: u32,\n    elems: Vec<u32>,\n    connect_cost: u64,\n}\n\nimpl SortGroup {\n    pub fn new() -> Self {\n        SortGroup {\n            min: std::u32::MAX,\n            elems: Vec::new(),\n            connect_cost: 0u64,\n        }\n    }\n\n    pub fn add(&mut self, c: u32) {\n        dprintln!(\" SG.add {}\", c);\n        self.min = cmp::min(self.min, c);\n        self.elems.push(c);\n    }\n\n    pub fn cost(&self) -> u64 {\n        let c = self.elems.len() as u64;\n\n        if c <= 1 {\n            return 0;\n        }\n\n        let mut sum = self.elems.iter().fold(0u64, |s, e| s+(*e as u64));\n        sum += (c-2)*self.min as u64;\n\n        dprintln!(\" [cost{:?}] {}\", self, sum);\n\n        sum + self.connect_cost\n    }\n\n    pub fn connect(self, other: Self) -> Self {\n        let other_elems = other.elems.into_iter();\n        let mut elems: Vec<u32> = self.elems.into_iter().chain(other_elems).collect();\n        let mut min = cmp::min(self.min, other.min);\n\n        SortGroup {\n            min: min,\n            elems: elems,\n            connect_cost: self.connect_cost + (self.min + other.min) as u64,\n        }\n    }\n}\n\nimpl Quiz {\n    fn solve(self) -> Answer {\n        let mut v = {\n            let mut t = self.v.to_vec()\n                .into_iter()\n                .enumerate()\n                .map(|(n,x)| (x,n));\n            let mut vt = t.collect::<Vec<_>>();\n            vt.sort();\n            let mut vtt: Vec<Option<(usize, (u32, usize))>> = vt.into_iter().enumerate().map(|x| Some(x)).collect();\n            vtt\n        };\n\n        let mut gs = Vec::new();\n        let mut g_min : Option<SortGroup> = None;\n        for i in 0usize..v.len() {\n            dprintln!(\" {:?}\", v[i]);\n            let mut g = SortGroup::new();\n\n            if let Some((_dst, (c, src))) = v[i].take() {\n                let mut next_i = src;\n                g.add(c);\n                dprintln!(\" -> {:?}\", v[next_i]);\n\n                while let Some((_dst2, (c2, src2))) = v[next_i].take() {\n                    next_i = src2;\n                    g.add(c2);\n                    dprintln!(\" -> {:?}\", v[next_i]);\n                }\n                dprintln!(\"  g: {:?}\", g);\n\n                if let Some(gt) = g_min.take() {\n                    if gt.min > g.min {\n                        gs.push(gt);\n                        g_min = Some(g);\n                    } else {\n                        gs.push(g);\n                        g_min = Some(gt);\n                    }\n                } else {\n                    g_min = Some(g);\n                }\n                dprintln!(\" g_min {:?}\", g_min);\n            }\n        }\n\n        dprintln!(\"=== Making Groups Result ===\");\n        dprintln!(\"group: \");\n        dprintln!(\" {:?}\", gs);\n        dprintln!(\"min: {:?}\", g_min);\n\n        let mut rest_sum = 0u64;\n        if let Some(gtt) = g_min.take() {\n            let mut gt = gtt;\n            for g in gs {\n                let y = gt.min as i32;\n                let x = g.min as i32;\n                let c = g.elems.len() as i32;\n\n                if y * (c+1) < x * (c-3) {\n                    dprintln!(\" connect {:?} + {:?}\", gt, g);\n                    gt = gt.connect(g);\n                } else {\n                    dprintln!(\" not connect {:?}, {:?}\", gt, g);\n                    gt = gt;\n                    rest_sum += g.cost();\n                }\n            }\n\n            g_min = Some(gt);\n        }\n\n        if let Some(gt) = g_min.take() {\n            Answer {\n                min_cost: gt.cost() + rest_sum,\n            }\n        } else {\n            panic!(\"No elems\");\n        }\n    }\n}\n\nimpl Answer {\n    fn print(self) {\n        println!(\"{}\", self.min_cost);\n    }\n}\n\n// =====================================================\n// = Lib\n// =====================================================\n\n//==================================================\n// Main\nfn main() {\n    // Initialize\n    set_debug_mode(false);\n    for arg in env::args() {\n        if arg == \"--debug\" {\n            set_debug_mode(true);\n        }\n    }\n    dprintln!(\"[DebugMode] {}\", \"On\");\n\n    // Execute\n    dprintln!(\"=================\");\n    dprintln!(\"= READ INPUT     \");\n    let stdin = io::stdin();\n    let input = BufReadInput::new(stdin.lock());\n    dprintln!(\"[Input] \\n{:?}\", input);\n    dprintln!(\"=================\");\n    dprintln!(\"= INTERPRET INPUT\");\n    let q = input.into_quiz();\n    dprintln!(\"[Quiz] \\n{:?}\", q);\n    dprintln!(\"=================\");\n    dprintln!(\"= SOLVE QUIZE    \");\n    let a = q.solve();\n    dprintln!(\"[Answer] \\n{:?}\", a);\n    dprintln!(\"=================\");\n    dprintln!(\"= PRINT ANSWER   \");\n    a.print();\n    dprintln!(\"=================\");\n}\n\n//==================================================\n// Stdin Reader\n#[derive(Debug)]\npub enum Token {\n    Word(String),\n    LineBreak,\n}\n\nimpl Token {\n    pub fn is_word(&self) -> bool {\n        match *self {\n            Token::Word(ref _x) => true,\n            _ => false,\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct BufReadInput<R: BufRead> {\n    input: R,\n    tokens: VecDeque<Token>,\n}\n\npub trait Input {\n    fn read_next_word(&mut self) -> Option<Token>;\n\n    fn parse_next<T>(&mut self) -> Option<T>\n    where\n        T: std::str::FromStr,\n    {\n        if let Some(Token::Word(str)) = self.read_next_word() {\n            match str.parse() {\n                Ok(x) => Some(x),\n                _ => None,\n            }\n        } else {\n            None\n        }\n    }\n\n    fn parse_next_vec<T>(&mut self, size: usize) -> Option<Vec<T>>\n    where\n        T: std::str::FromStr,\n    {\n        let mut v = Vec::new();\n\n        for _i in 0..size {\n            if let Some(t) = self.parse_next() {\n                v.push(t);\n            } else {\n                return None;\n            }\n        }\n\n        Some(v)\n    }\n\n    fn parse_next_vec2<T>(&mut self, size2: usize, size1: usize) -> Option<Vec<Vec<T>>>\n    where\n        T: std::str::FromStr,\n    {\n        let mut v = Vec::new();\n\n        for _i in 0..size2 {\n            if let Some(t) = self.parse_next_vec(size1) {\n                v.push(t);\n            } else {\n                return None;\n            }\n        }\n\n        Some(v)\n    }\n\n    fn parse_all_remaining_into_vec<T>(&mut self) -> Vec<T>\n    where\n        T: std::str::FromStr,\n    {\n        let mut v = Vec::new();\n\n        loop {\n            match self.parse_next() {\n                Some(x) => v.push(x),\n                None => return v,\n            }\n        }\n    }\n}\nimpl<R: BufRead> BufReadInput<R> {\n    pub fn new(input: R) -> Self {\n        let tokens = VecDeque::new();\n\n        BufReadInput { input, tokens }\n    }\n}\n\nimpl<R: BufRead> Input for BufReadInput<R> {\n    fn read_next_word(&mut self) -> Option<Token> {\n        loop {\n            match self.tokens.pop_front() {\n                None => {\n                    // Read Input\n                    let mut line = String::new();\n                    let n = self.input.read_line(&mut line).expect(\"Read Error.\");\n                    if n == 0 {\n                        return None;\n                    }\n                    let mut line_tokens = tokenaize(line);\n                    self.tokens.append(&mut line_tokens);\n                }\n                Some(Token::LineBreak) => (),\n                x => return x,\n            }\n        }\n    }\n\n}\n\n//TODO: Make CaseIterator\n// ex) \n//  let mut input: Input ...\n//  let mut iter: CaseIterator<Case=Command> = input.rest_into_cases(|i|   \n//    let cmd:String = i.parse_next().expect(\"Parse error cmd\");\n//    let num:u32    = i.parse_next().expect(\"Parse error num\");\n//\n//    Command::new(cmd, num)\n//  );\n//  let case1 = iter.next();\n//  let case2 = iter.next();\n//  ...\n\n\nfn tokenaize(str: String) -> VecDeque<Token> {\n    let mut v = VecDeque::new();\n\n    for w in str.split_whitespace() {\n        v.push_back(Token::Word(w.to_string()));\n    }\n    v.push_back(Token::LineBreak);\n    v\n}\n\n//==================================================\n// Utility\npub fn concat_vec_to_string<T>(v: &Vec<T>) -> String\nwhere\n    T: std::fmt::Display,\n{\n    let mut string = String::with_capacity(v.len() * 2);\n\n    if let Some((h, t)) = v.split_first() {\n        string = h.to_string();\n\n        for obj in t {\n            string.push(' ');\n            string.push_str(&obj.to_string());\n        }\n    }\n\n    return string;\n}\n\nstruct Step {\n    current: i64,\n    start: usize,\n    end: usize,\n    step: i32,\n}\n\nimpl Step {\n    fn new(start: usize, end: usize, step: i32) -> Self {\n        if step == 0 {\n            panic!(\"step can't be 0\");\n        } else if step > 0 && start > end {\n            panic!(\"Can't reach end.\");\n        } else if step < 0 && start < end {\n            panic!(\"Can't reach end.\");\n        } \n\n        Step {\n            current: start as i64,\n            start: start,\n            end: end,\n            step: step,\n        }\n    }\n}\n\nimpl Iterator for Step {\n    type Item = usize;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let current_is_enable = if self.step > 0 {\n            self.current <= self.end as i64\n        } else {\n            self.current >= self.end as i64\n        };\n\n        if !current_is_enable {\n            None\n        } else {\n            let ret = self.current as usize;\n            self.current += self.step as i64;\n            Some(ret)\n        }\n    }\n}\n\n//==================================================\n// Debug Switch\nstatic mut S_DEBUG_MODE: bool = false;\nfn is_debug_mode() -> bool {\n    unsafe { S_DEBUG_MODE }\n}\n\nfn set_debug_mode(mode: bool) {\n    unsafe {\n        S_DEBUG_MODE = mode;\n    }\n}\n\n//==================================================\n// Usage\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn macro_backward() {\n        let mut v = Vec::new();\n        for i in backward_ho!(5, 1) {\n            v.push(i);\n        }\n        assert_eq!(vec![5, 4, 3, 2], v);\n    }\n\n    #[test]\n    fn step_basis() {\n        let step = Step::new(0, 6, 2);\n        let v: Vec<usize> = step.collect(); \n        assert_eq!(vec![0, 2, 4, 6], v);\n\n        let step = Step::new(0, 5, 3);\n        let v: Vec<usize> = step.collect(); \n        assert_eq!(vec![0, 3], v);\n\n        let step = Step::new(5, 0, -1);\n        let v: Vec<usize> = step.collect(); \n        assert_eq!(vec![5,4,3,2,1,0], v);\n\n        let step = Step::new(5, 4, -2);\n        let v: Vec<usize> = step.collect(); \n        assert_eq!(vec![5], v);\n        \n        let step = Step::new(100, 100, 1);\n        let v: Vec<usize> = step.collect(); \n        assert!(v.is_empty());\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::{max, min};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, Read, Write};\nuse std::str::FromStr;\n\n#[derive(Default)]\nstruct Scanner<R: Read> {\n    reader: R,\n}\n\nimpl<R: Read> Scanner<R> {\n    fn new(reader: R) -> Scanner<R> {\n        Scanner { reader }\n    }\n\n    fn scan<T: FromStr>(&mut self) -> Option<T> {\n        let s = self\n            .reader\n            .by_ref()\n            .bytes()\n            .map(|c| c.unwrap() as char)\n            .skip_while(|c| c.is_whitespace())\n            .take_while(|c| !c.is_whitespace())\n            .collect::<String>();\n        s.parse::<T>().ok()\n    }\n\n    fn next<T: FromStr>(&mut self) -> T {\n        if let Some(s) = self.scan() {\n            s\n        } else {\n            std::process::exit(1);\n        }\n    }\n}\n\nfn main() {\n    let cin = stdin();\n    let cin = cin.lock();\n    let mut sc = Scanner::new(cin);\n    let out = stdout();\n    let mut out = out.lock();\n\n    let n = sc.next();\n    let mut a = vec![0; n];\n    for i in 0..n {\n        a[i] = sc.next();\n    }\n\n    let a_min = a.iter().min().unwrap();\n    let mut b = vec![0; n];\n    for i in 0..n {\n        b[i] = a.iter().filter(|&&x| x < a[i]).count();\n    }\n\n    let mut seen = vec![false; n];\n    let mut ans = 0;\n    for i in 0..n {\n        if seen[i] || b[i] == i {\n            continue;\n        }\n        let mut v = Vec::<usize>::new();\n        let mut i = i;\n        while !seen[i] {\n            seen[i] = true;\n            v.push(a[i]);\n            i = b[i];\n        }\n        v.sort();\n        let sum = v[1..].iter().fold(0, |sum, x| sum + x);\n        ans += min(\n            v[0] * (v.len() - 1) + sum,\n            a_min * (v.len() - 1) + sum + (v[0] + a_min) * 2,\n        )\n    }\n\n    writeln!(out, \"{}\", ans).ok();\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp::min;\nuse std::io::*;\nuse std::str::FromStr;\n\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\nfn main() {\n    let n: usize = read();\n    let mut s: usize = 10_000;\n    let a: Vec<usize> = (0..n)\n        .map(|_| {\n            let number: usize = read();\n            s = min(s, number);\n            number\n        })\n        .collect();\n    let mut answer: isize = 0;\n    let mut b = a.clone();\n    let mut v: Vec<bool> = vec![false; n];\n    let mut t: Vec<usize> = vec![0; 10_001];\n\n    b.sort();\n    for index in 0..n {\n        t[b[index]] = index;\n    }\n\n    for index in 0..n {\n        if v[index] {\n            continue;\n        }\n\n        let mut cur: usize = index;\n        let mut S: isize = 0;\n        let mut m: isize = 10_000;\n        let mut an: isize = 0;\n        loop {\n            v[cur] = true;\n            an += 1;\n            let val = a[cur];\n            m = min(m, val as isize);\n            S += val as isize;\n            cur = t[val];\n            if v[cur] {\n                break;\n            }\n        }\n        answer += min(S + (an - 2) * m, m + S + (an + 1) * s as isize);\n    }\n\n    println!(\"{}\", answer);\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\n#[allow(unused_imports)]\nuse std::collections::*;\n#[allow(unused_imports)]\nuse std::cmp::{min, max};\n\nstruct Scanner<R: Read> {\n    reader: R,\n    buffer: String,\n}\n\n#[allow(dead_code)]\nimpl<R: Read> Scanner<R> {\n    fn new(reader: R) -> Scanner<R> {\n        Scanner { reader: reader, buffer: String::new() }\n    }\n\n    // fn line(&mut self) -> String {\n    //     self.buffer = self.reader.by_ref().bytes().map(|c| c.unwrap() as char)\n    //         .skip_while(|&c| c == '\\n' || c == '\\r')\n    //         .take_while(|&c| !(c == '\\n' || c == '\\r'))\n    //         .collect::<String>();\n    //     self.buffer.clone()\n    // }\n\n    fn read_buffer(&mut self) {\n        self.buffer = self.reader.by_ref().bytes().map(|c| c.unwrap() as char)\n            .skip_while(|c| c.is_whitespace())\n            .take_while(|c| !c.is_whitespace())\n            .collect::<String>();\n    }\n\n    fn safe_read<T: FromStr>(&mut self) -> Option<T> {\n        self.read_buffer();\n        if self.buffer.is_empty() {\n            None\n        } else {\n            self.buffer.parse::<T>().ok()\n        }\n    }\n\n    fn read<T: FromStr>(&mut self) -> T {\n        if let Some(s) = self.safe_read() {\n            s\n        } else {\n            // writeln!(std::io::stderr(), \"Terminated with EOF\").unwrap();\n            std::process::exit(0);\n        }\n    }\n\n    fn vec<T: FromStr>(&mut self, len: usize) -> Vec<T> {\n        (0..len).map(|_| self.read()).collect()\n    }\n\n    fn mat<T: FromStr>(&mut self, row: usize, col: usize) -> Vec<Vec<T>> {\n        (0..row).map(|_| self.vec(col)).collect()\n    }\n}\n\ntrait Joinable {\n    fn join(self, sep: &str) -> String;\n}\n\nimpl<U: ToString, T: Iterator<Item=U>> Joinable for T {\n    fn join(self, sep: &str) -> String {\n        self.map(|x| x.to_string()).collect::<Vec<_>>().join(sep)\n    }\n}\n\nfn main() {\n    std::thread::Builder::new()\n        .stack_size(104_857_600)\n        .spawn(solve)\n        .unwrap()\n        .join()\n        .unwrap();\n}\n\nfn solve() {\n    let cin = stdin();\n    let cin = cin.lock();\n    let mut sc = Scanner::new(cin);\n\n    loop {\n        let n = sc.read();\n        let ws: Vec<u32> = sc.vec(n); // id -> w\n        let mut ids: Vec<_> = (0..n).collect(); // pos -> id\n        let mut pos: Vec<_> = (0..n).collect(); // id -> pos\n\n        let sorted_ws = {\n            let mut x: Vec<(u32, usize)> = ws.iter().cloned().zip(0..n).collect();\n            x.sort();\n            x\n        };\n\n        let mut ans = 0;\n        for (des_pos, &(_, id)) in sorted_ws.iter().enumerate().rev() {\n            let cur_pos = pos[id];\n            if cur_pos != des_pos {\n                // println!(\"{} {}\", cur_pos, des_pos);\n                pos.swap(ids[cur_pos], ids[des_pos]);\n                ids.swap(cur_pos, des_pos);\n                ans += ws[ids[cur_pos]] + ws[ids[des_pos]];\n            }\n        }\n\n        println!(\"{}\", ans);\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\n#[allow(unused_imports)]\nuse std::collections::*;\n#[allow(unused_imports)]\nuse std::cmp::{min, max};\n\nstruct Scanner<R: Read> {\n    reader: R,\n    buffer: String,\n}\n\n#[allow(dead_code)]\nimpl<R: Read> Scanner<R> {\n    fn new(reader: R) -> Scanner<R> {\n        Scanner { reader: reader, buffer: String::new() }\n    }\n\n    // fn line(&mut self) -> String {\n    //     self.buffer = self.reader.by_ref().bytes().map(|c| c.unwrap() as char)\n    //         .skip_while(|&c| c == '\\n' || c == '\\r')\n    //         .take_while(|&c| !(c == '\\n' || c == '\\r'))\n    //         .collect::<String>();\n    //     self.buffer.clone()\n    // }\n\n    fn read_buffer(&mut self) {\n        self.buffer = self.reader.by_ref().bytes().map(|c| c.unwrap() as char)\n            .skip_while(|c| c.is_whitespace())\n            .take_while(|c| !c.is_whitespace())\n            .collect::<String>();\n    }\n\n    fn safe_read<T: FromStr>(&mut self) -> Option<T> {\n        self.read_buffer();\n        if self.buffer.is_empty() {\n            None\n        } else {\n            self.buffer.parse::<T>().ok()\n        }\n    }\n\n    fn read<T: FromStr>(&mut self) -> T {\n        if let Some(s) = self.safe_read() {\n            s\n        } else {\n            // writeln!(std::io::stderr(), \"Terminated with EOF\").unwrap();\n            std::process::exit(0);\n        }\n    }\n\n    fn vec<T: FromStr>(&mut self, len: usize) -> Vec<T> {\n        (0..len).map(|_| self.read()).collect()\n    }\n\n    fn mat<T: FromStr>(&mut self, row: usize, col: usize) -> Vec<Vec<T>> {\n        (0..row).map(|_| self.vec(col)).collect()\n    }\n}\n\ntrait Joinable {\n    fn join(self, sep: &str) -> String;\n}\n\nimpl<U: ToString, T: Iterator<Item=U>> Joinable for T {\n    fn join(self, sep: &str) -> String {\n        self.map(|x| x.to_string()).collect::<Vec<_>>().join(sep)\n    }\n}\n\nfn main() {\n    std::thread::Builder::new()\n        .stack_size(104_857_600)\n        .spawn(solve)\n        .unwrap()\n        .join()\n        .unwrap();\n}\n\nfn solve() {\n    let cin = stdin();\n    let cin = cin.lock();\n    let mut sc = Scanner::new(cin);\n\n    loop {\n        let n = sc.read();\n        let ws: Vec<u32> = sc.vec(n); // id -> w\n        let mut ids: Vec<_> = (0..n).collect(); // pos -> id\n        let mut pos: Vec<_> = (0..n).collect(); // id -> pos\n\n        let sorted_ws = {\n            let mut x: Vec<(u32, usize)> = ws.iter().cloned().zip(0..n).collect();\n            x.sort();\n            x\n        };\n\n        let mut ans = 0;\n        for (des_pos, &(_, id)) in sorted_ws.iter().enumerate().rev() {\n            let cur_pos = pos[id];\n            if cur_pos != des_pos {\n                println!(\"{} {}\", cur_pos, des_pos);\n                pos.swap(ids[cur_pos], ids[des_pos]);\n                ids.swap(cur_pos, des_pos);\n                ans += ws[ids[cur_pos]] + ws[ids[des_pos]];\n            }\n        }\n\n        println!(\"{}\", ans);\n    }\n}\n\n"
  }
]