[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 3005\nusing namespace std;\nint F[N][N],ymax,xmax,ans;\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\nvoid dfs(int y,int x,int cnt,int dir){\n  if(F[y][x]>=0){\n    int tmp=F[y][x];\n    int ny=y+dy[tmp];\n    int nx=x+dx[tmp];\n    ans=max(ans,cnt+1);\n    if(ny<0||nx<0||ymax<=ny||xmax<=nx)return;\n    F[y][x]=-1;\n    dfs(ny,nx,cnt+1,tmp);\n    F[y][x]=tmp;\n    return;\n  }\n  int ny=y+dy[dir];\n  int nx=x+dx[dir];\n  if(ny<0||nx<0||ymax<=ny||xmax<=nx)return;\n  dfs(ny,nx,cnt,dir);\n}\n\nint main(){\n  int n,x[N],y[N];\n  char d[N];\n  map<int,int> X,Y;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i]>>d[i];\n    X[x[i]]=0;\n    Y[y[i]]=0;\n  }\n  int num=0;\n  map<int,int>::iterator ite=X.begin();\n  while(ite!=X.end()){\n    (*ite).second=num;\n    num++;\n    ite++;\n  }\n  xmax=num;\n  ite=Y.begin();\n  num=0;\n  while(ite!=Y.end()){\n    (*ite).second=num;\n    num++;\n    ite++;\n  }\n  ymax=num;\n  memset(F,-1,sizeof(F));\n  for(int i=0;i<n;i++){\n    if(d[i]=='^')F[Y[y[i]]][X[x[i]]]=0;\n    if(d[i]=='>')F[Y[y[i]]][X[x[i]]]=1;\n    if(d[i]=='v')F[Y[y[i]]][X[x[i]]]=2;\n    if(d[i]=='<')F[Y[y[i]]][X[x[i]]]=3;\n  }\n  for(int i=0;i<n;i++)\n    dfs(Y[y[i]],X[x[i]],0,0);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nmap<int,set<int> > xx,yy;\nmap<pint,char> d;\nint x[3001],y[3001];\nconst int INF=1000100010;\nint main(){\n    int n;\n    cin>>n;\n    char c;\n    rep(i,n){\n        cin>>x[i]>>y[i]>>c;\n        xx[x[i]].insert(y[i]);\n        yy[y[i]].insert(x[i]);\n        d[pint(x[i],y[i])]=c;\n    }\n    for(auto it:xx){\n        it.second.insert(INF);\n        it.second.insert(-INF);\n        yy[it.first].insert(INF);\n        yy[it.first].insert(-INF);\n    }\n    for(auto it:yy){\n        it.second.insert(INF);\n        it.second.insert(-INF);\n        xx[it.first].insert(INF);\n        xx[it.first].insert(-INF);\n    }\n    int mx=0;\n    rep(i,n){\n        int cnt=0;\n        int tx=x[i],ty=y[i];\n        map<int,set<int> > sx=xx,sy=yy;\n        while(1){\n            if(sx[tx].empty()||sy[ty].empty()) break;\n            ++cnt;\n            sx[tx].erase(ty),sy[ty].erase(tx);\n            char tc=d[pint(tx,ty)];\n            if(tc=='v'){\n                ty=*sx[tx].lower_bound(ty);\n            }\n            else if(tc=='^'){\n                auto p=sx[tx].lower_bound(ty);\n                if(p==sx[tx].begin()) break;\n                --p;\n                ty=*p;\n            }\n            else if(tc=='<'){\n                auto p=sy[ty].lower_bound(tx);\n                if(p==sy[ty].begin()) break;\n                --p;\n                tx=*p;\n\n            }\n            else if(tc=='>'){\n                tx=*sy[ty].lower_bound(tx);\n            }\n            else break;\n            if(abs(tx)==INF||abs(ty)==INF) break;\n        }\n        mx=max(mx,cnt);\n    }\n    cout<<mx<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nint N, X[3009], Y[3009]; char c[3009], p[3009][3009]; vector<int>x, y;\nset<int>DX[3009], DY[3009];\n\nvoid dels(int px, int py) {\n\tDX[px].erase(py);\n\tDY[py].erase(px);\n}\n\nint solve(int pos) {\n\tfor (int i = 0; i < N; i++) { DX[i].clear(); DY[i].clear(); }\n\tfor (int i = 1; i <= N; i++) { DX[X[i]].insert(Y[i]); DY[Y[i]].insert(X[i]); }\n\n\tint cnt = 0, vx = X[pos], vy = Y[pos]; char dir = c[pos];\n\n\twhile (true) {\n\t\tdels(vx, vy); dir = p[vx][vy]; cnt++;\n\t\tif (dir == '<' || dir == '>') {\n\t\t\tauto itr = DX[vx].lower_bound(vy);\n\t\t\tif (dir == '<') {\n\t\t\t\tif (itr == DX[vx].begin()) break;\n\t\t\t\titr--;\n\t\t\t}\n\t\t\tif (itr == DX[vx].end()) break;\n\t\t\tvy = *itr;\n\t\t}\n\t\telse {\n\t\t\tauto itr = DY[vy].lower_bound(vx);\n\t\t\tif (dir == '^') {\n\t\t\t\tif (itr == DY[vy].begin()) break;\n\t\t\t\titr--;\n\t\t\t}\n\t\t\tif (itr == DY[vy].end()) break;\n\t\t\tvx = *itr;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tcin >> N;\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> X[i] >> Y[i] >> c[i]; swap(X[i], Y[i]);\n\t\tx.push_back(X[i]);\n\t\ty.push_back(Y[i]);\n\t}\n\tsort(x.begin(), x.end()); x.erase(unique(x.begin(), x.end()), x.end());\n\tsort(y.begin(), y.end()); y.erase(unique(y.begin(), y.end()), y.end());\n\t\n\tfor (int i = 1; i <= N; i++) {\n\t\tX[i] = lower_bound(x.begin(), x.end(), X[i]) - x.begin();\n\t\tY[i] = lower_bound(y.begin(), y.end(), Y[i]) - y.begin();\n\t\tp[X[i]][Y[i]] = c[i];\n\t}\n\tint maxn = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tmaxn = max(maxn, solve(i));\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst string D = \"^>v<\";\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 0};\nconst int inf = 1 << 25;\nint fld[3000][3000], w, h;\nint ans;\n\n\nvoid compress(vector<int>& vec)\n{\n  vector<int> temp = vec;\n  sort(temp.begin(), temp.end());\n  temp.erase(unique(temp.begin(), temp.end()), temp.end());\n  for(int i = 0; i < vec.size(); i++){\n    vec[i] = find(temp.begin(), temp.end(), vec[i]) - temp.begin();\n  }\n}\n\nint solve(int x, int y, int d)\n{\n  if(x < 0 || w < x || y < 0 || h < y) return 0;\n  int nx = x + dx[d], ny = y + dy[d], nd = (fld[y][x] == -1 ? d : fld[y][x]);\n  fld[y][x] = -1;\n  return solve(nx, ny, nd) + 1;\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n  vector<int> ix, iy, id;\n  for(int i = 0; i < n; i++){\n    int x, y; char d;\n    cin >> x >> y >> d;\n    ix.push_back(x);\n    iy.push_back(y);\n    id.push_back(D.find(d));\n  }\n  compress(ix);\n  compress(iy);\n  w = *max_element(ix.begin(), ix.end()), h = *max_element(iy.begin(), iy.end());\n  ans = 0;\n  for(int i = 0; i < n; i++){\n    for(int j = 0; j < n; j++) fld[iy[j]][ix[j]] = id[j];\n    ans = max(ans, solve(ix[i], iy[i], id[i]));\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<P ,ll> P3;\ntypedef pair<P ,P> PP;\nconst ll MOD = ll(1e9)+7;\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(1e5 + 5);\nconst double EPS = 1e-6;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define SORTR(v) sort((v).rbegin(), (v).rend())\n#define ALL(v) (v).begin(), (v).end()\n\nint n, ans = 1;\nmap<int, set<P> > vx, vy;\nP3 pos[3005];\n\nint main() {\n    cin >> n;\n    REP(i,n){\n        int x, y, dir;\n        char d;\n        cin >> x >> y >> d;\n        if(d == '>') dir = 0;\n        if(d == 'v') dir = 1;\n        if(d == '<') dir = 2;\n        if(d == '^') dir = 3;\n        vx[x].insert({y,dir});\n        vy[y].insert({x,dir});\n        pos[i] = {{x,y},dir};\n    }\n    REP(i,n){\n        auto xs = vx, ys = vy;\n        int px = pos[i].first.first, py = pos[i].first.second, dir = pos[i].second, cnt = 1;\n        while(1){\n            xs[px].erase({py,dir});\n            ys[py].erase({px,dir});\n            if(dir == 0){\n                auto p = ys[py].upper_bound({px,-1});\n                if(p==ys[py].end())break;\n                px = (*p).first;\n                dir = (*p).second;\n                cnt++;\n            }\n            else if(dir == 1){\n                auto p = xs[px].upper_bound({py,-1});\n                if(p==xs[px].end())break;\n                py = (*p).first;\n                dir = (*p).second;\n                cnt++;\n            }\n            else if(dir == 2){\n                if(ys[py].size()==0) break;\n                auto p = ys[py].upper_bound({px,-1});\n                if(p==ys[py].begin())break;\n                p--;\n                px = (*p).first;\n                dir = (*p).second;\n                cnt++;\n            }\n            else if(dir == 3){\n                if(xs[px].size()==0) break;\n                auto p = xs[px].upper_bound({py,-1});\n                if(p==xs[px].begin())break;\n                p--;\n                py = (*p).first;\n                dir = (*p).second;\n                cnt++;\n            }\n        }\n        ans = max(ans, cnt);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 3000\n\nenum DIR{\n\tNorth,\n\tEast,\n\tSouth,\n\tWest,\n};\n\nstruct Info{\n\tint x,y;\n\tDIR dir;\n};\n\ntypedef pair<int,int> Data;\nint N;\nmap<int,int> X_MAP,Y_MAP;\nvector<int> Y,X;\nInfo info[NUM];\nset<Data> SET_X[NUM],SET_Y[NUM];\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tchar buf[2];\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %s\",&info[i].x,&info[i].y,buf);\n\t\tX.push_back(info[i].x);\n\t\tY.push_back(info[i].y);\n\t\tswitch(buf[0]){\n\t\tcase '^':\n\t\t\tinfo[i].dir = North;\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tinfo[i].dir = East;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tinfo[i].dir = South;\n\t\t\tbreak;\n\t\tcase '<':\n\t\t\tinfo[i].dir = West;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsort(X.begin(),X.end());\n\tsort(Y.begin(),Y.end());\n\n\tX.erase(unique(X.begin(),X.end()),X.end());\n\tY.erase(unique(Y.begin(),Y.end()),Y.end());\n\n\tfor(int i = 0; i < X.size(); i++){\n\t\tX_MAP[X[i]] = i;\n\t}\n\tfor(int i = 0; i < Y.size(); i++){\n\t\tY_MAP[Y[i]] = i;\n\t}\n\n\tint size_X = (int)X.size(),size_Y = (int)Y.size();\n\n\tfor(int i = 0; i < N; i++){\n\t\tinfo[i].y = Y_MAP[info[i].y];\n\t\tinfo[i].x = X_MAP[info[i].x];\n\t}\n\n\tint ans = 0;\n\tint x,y,next_index;\n\tDIR dir;\n\tData tmp;\n\tbool FLG;\n\n\tfor(int start = 0; start < N; start++){\n\n\t\tfor(int i = 0; i < NUM; i++){\n\t\t\tSET_X[i].clear();\n\t\t\tSET_Y[i].clear();\n\t\t}\n\n\t\tint tmp_count = 1;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(i == start)continue;\n\t\t\tSET_X[info[i].x].insert(Data(info[i].y,i));\n\t\t\tSET_Y[info[i].y].insert(Data(info[i].x,i));\n\t\t}\n\n\t\tdir = info[start].dir;\n\t\tx = info[start].x;\n\t\ty = info[start].y;\n\n\t\tFLG = true;\n\n\t\tset<Data>::iterator it;\n\n\t\twhile(true){\n\n\t\t\tswitch(dir){\n\t\t\tcase North:\n\t\t\t\tit = SET_X[x].lower_bound(Data(y,0));\n\t\t\t\tif(it == SET_X[x].begin()){\n\t\t\t\t\tFLG = false;\n\t\t\t\t}else{\n\t\t\t\t\tit--;\n\t\t\t\t\ttmp = *it;\n\t\t\t\t\tnext_index = tmp.second;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase East:\n\t\t\t\tit = SET_Y[y].lower_bound(Data(x,0));\n\t\t\t\tif(it == SET_Y[y].end()){\n\t\t\t\t\tFLG = false;\n\t\t\t\t}else{\n\t\t\t\t\ttmp = *it;\n\t\t\t\t\tnext_index = tmp.second;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase South:\n\t\t\t\tit = SET_X[x].lower_bound(Data(y,0));\n\t\t\t\tif(it == SET_X[x].end()){\n\t\t\t\t\tFLG = false;\n\t\t\t\t}else{\n\t\t\t\t\ttmp = *it;\n\t\t\t\t\tnext_index = tmp.second;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase West:\n\t\t\t\tit = SET_Y[y].lower_bound(Data(x,0));\n\t\t\t\tif(it == SET_Y[y].begin()){\n\t\t\t\t\tFLG = false;\n\t\t\t\t}else{\n\t\t\t\t\tit--;\n\t\t\t\t\ttmp = *it;\n\t\t\t\t\tnext_index = tmp.second;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(!FLG)break;\n\n\t\t\ttmp_count++;\n\t\t\tx = info[next_index].x;\n\t\t\ty = info[next_index].y;\n\t\t\tdir = info[next_index].dir;\n\t\t\tSET_X[x].erase(Data(y,next_index));\n\t\t\tSET_Y[y].erase(Data(x,next_index));\n\t\t}\n\t\tans = max(ans,tmp_count);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst string vs = \"^v<>\";\n\nint main()\n{\n\n  int N, X[3000], Y[3000], Z[3000];\n  cin >> N;\n  map< pair< int, int >, int > xx, yy;\n  for(int i = 0; i < N; i++) {\n    char zz;\n    cin >> X[i] >> Y[i] >> zz;\n    Z[i] = vs.find(zz);\n    xx[{X[i], Y[i]}] = i;\n    yy[{Y[i], X[i]}] = i;\n  }\n\n  xx[{-1145141919, -1145141919}] = -1;\n  xx[{1145141919, 1145141919}] = -1;\n  yy[{-1145141919, -1145141919}] = -1;\n  yy[{1145141919, 1145141919}] = -1;\n\n\n  int ret = 0;\n\n  for(int i = 0; i < N; i++) {\n    auto aa = xx, bb = yy;\n    aa.erase({X[i], Y[i]});\n    bb.erase({Y[i], X[i]});\n\n    int now = i, sum = 1;\n    bool latte = true;\n    for(;; sum++) {\n      latte = false;\n      if(Z[now] >= 2) {\n        auto pp = bb.lower_bound({Y[now], X[now]});\n        if(Z[now] % 2 == 0) --pp;\n        if(pp->first.first != Y[now]) break;\n        now = pp->second;\n      } else {\n        auto pp = aa.lower_bound({X[now], Y[now]});\n        if(Z[now] % 2 == 0) --pp;\n        if(pp->first.first != X[now]) break;\n        now = pp->second;\n      }\n      aa.erase({X[now], Y[now]});\n      bb.erase({Y[now], X[now]});\n    }\n\n    ret = max(ret, sum);\n  }\n\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\nusing llong = long long;\n\nstruct node {\n        int l, r, u, d;\n        char dir;\n};\n\nusing pi = pair<int, int>;\nmap<int, set<pi>> x_axis;\nmap<int, set<pi>> y_axis;\nvector<node> nodes;\nint n;\nint X[3005], Y[3005];\nchar d;\n\nvoid build() {\n        for (int i = 1; i <= n; i++) {\n                int x = X[i];\n                int y = Y[i];\n                nodes[i].r = (x_axis[y].upper_bound(pi(x, 100000)))->second;\n                nodes[i].d = (y_axis[x].upper_bound(pi(y, 100000)))->second;\n\n                {\n                        auto itr = x_axis[y].lower_bound(pi(x, -1));\n                        itr--;\n                        nodes[i].l = itr->second;\n                }\n                {\n                        auto itr = y_axis[x].lower_bound(pi(y, -1));\n                        itr--;\n                        nodes[i].u = itr->second;\n                }\n        }\n}\n\nint dfs(int u) {\n        if (u == 0) return 0;\n\n        nodes[nodes[u].u].d = nodes[u].d;\n        nodes[nodes[u].d].u = nodes[u].u;\n        nodes[nodes[u].l].r = nodes[u].r;\n        nodes[nodes[u].r].l = nodes[u].l;\n\n        switch(nodes[u].dir) {\n                case '^' :\n                        return dfs(nodes[u].u) + 1;\n                        break;\n                case 'v' :\n                        return dfs(nodes[u].d) + 1;\n                        break;\n                        break;\n                case '<' :\n                        return dfs(nodes[u].l) + 1;\n                        break;\n                case '>' :\n                        return dfs(nodes[u].r) + 1;\n                        break;\n        }\n        return 0;\n}\n\nint main() {\n        cin >> n;\n        nodes.resize(n + 1);\n        for (int i = 1; i <= n; i++) {\n                cin >> X[i] >> Y[i] >> d;\n                int x = X[i];\n                int y = Y[i];\n                nodes[i].dir = d;\n\n                if (x_axis.count(y) == 0) {\n                        x_axis[y].insert(pi(-1000000001, 0));\n                        x_axis[y].insert(pi(1000000001, 0));\n                }\n                if (y_axis.count(x) == 0) {\n                        y_axis[x].insert(pi(-1000000001, 0));\n                        y_axis[x].insert(pi(1000000001, 0));\n                }\n\n                x_axis[y].insert(pi(x, i));\n                y_axis[x].insert(pi(y, i));\n        }\n\n/*\n        build();\n        for (int i = 1; i <= n; i++) {\n                printf(\"%d %d %d %d\", nodes[i].l, nodes[i].r, nodes[i].u, nodes[i].d);\n                cout << endl;\n        }\n        */\n\n        int ans = 0;\n        for (int i = 1; i <= n; i++) {\n                build();\n                ans = max(ans, dfs(i));\n        }\n        cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3001\nusing namespace std;\nint w,h;\nint dx[]={0,1,0,-1};//^>v<\nint dy[]={-1,0,1,0};\nvector<int> X,Y,d;\nmap<int,int> x,y;\n\n\nint compless(vector<int> A,map<int,int> &M){\n  sort(A.begin(),A.end());\n  int c=0;\n  for(int i=0;i<A.size();i++)if(!M.count(A[i]))M[A[i]]=c++;\n  return c;\n}\n\nint calc(int y,int x,vector<vector<int> >mp){\n  int res=0;\n  while(1){\n    res++;\n    int i=mp[y][x];\n    mp[y][x]=-1;\n    while(1){\n      y+=dy[i];\n      x+=dx[i];\n      if(y<0||x<0||x>=w||y>=h)return res;    \n      if(mp[y][x]!=-1)break;;\n    }\n  }\n  assert(0);\n}\n\nint main(){\n  int n;\n  cin>>n;\n  X.resize(n),Y.resize(n),d.resize(n);\n  for(int i=0;i<n;i++){\n    char ch;\n    cin>>X[i]>>Y[i]>>ch;\n    if(ch=='^')d[i]=0;\n    if(ch=='>')d[i]=1;\n    if(ch=='v')d[i]=2;\n    if(ch=='<')d[i]=3;\n  }\n  h=compless(Y,y);\n  w=compless(X,x);\n  vector<vector<int> >mp(h,vector<int>(w,-1));\n  for(int i=0;i<X.size();i++)mp[y[Y[i]]][x[X[i]]]=d[i];\n  int ans=1;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j]!=-1)ans=max(ans,calc(i,j,mp));\n  cout <<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> p;\nint main(){\n  int n,gr[2][3000];\n  cin>>n;\n  vector<p> t[2];\n  char d[3000];\n  for(int x,y,i=0;i<n;i++){\n    cin>>x>>y>>d[i];\n    t[0].push_back(p(P(x,y),i));\n    t[1].push_back(p(P(y,x),i));\n  }\n  sort(t[0].begin(),t[0].end());\n  sort(t[1].begin(),t[1].end());  \n  for(int i=0;i<n;i++)\n    gr[0][t[0][i].s]=i,gr[1][t[1][i].s]=i;\n  int ans=0;\n \n  for(int i=0;i<n;i++){\n    bool used[3000]={};\n    int ss=i,k=0;\n     while(1){\n       k++;\n       bool f=0;\n       used[ss]=1;\n \n       if(d[ss]=='v'){\n     int g=gr[0][ss];\n     int a=t[0][g].f.f;\n     while(used[ss]){\n       if(++g==n){f=1;break;}\n       ss=t[0][g].s;\n     }\n     if(f||t[0][gr[0][ss]].f.f!=a)break;\n       }\n \n       if(d[ss]=='^'){\n     int g=gr[0][ss];\n     int a=t[0][g].f.f;\n     while(used[ss]){\n       if(!g){f=1;break;}\n       ss=t[0][--g].s;\n     }\n     if(f||t[0][gr[0][ss]].f.f!=a)break;\n       }\n \n \n       if(d[ss]=='>'){\n     int g=gr[1][ss];\n     int a=t[1][g].f.f;\n     while(used[ss]){\n       if(++g==n){f=1;break;}     \n       ss=t[1][g].s;\n     }\n     if(f||t[1][gr[1][ss]].f.f!=a)break;\n       }\n \n \n      if(d[ss]=='<'){\n    int g=gr[1][ss];\n    int a=t[1][g].f.f;\n     while(used[ss]){\n       if(!g){f=1;break;}     \n       ss=t[1][--g].s;\n     }\n     if(f||t[1][gr[1][ss]].f.f!=a)break;\n      }\n     }\n     ans=max(ans,k);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3001\nusing namespace std;\nint w,h;\nint dx[]={0,1,0,-1};//^>v<\nint dy[]={-1,0,1,0};\nvector<int> X,Y,d;\nmap<int,int> x,y;\n\nint compless(vector<int> A,map<int,int> &M){\n  sort(A.begin(),A.end());\n  int c=0;\n  for(int i=0;i<A.size();i++)if(!M.count(A[i]))M[A[i]]=c++;\n  return c;\n}\n\nint calc(int y,int x,vector<vector<int> >&mp){\n  vector<vector<bool> > used(h,vector<bool>(w,0));\n  int res=0;\n  while(1){\n    res++;\n    int i=mp[y][x];\n    used[y][x]=1;\n    while(1){\n      y+=dy[i],x+=dx[i];\n      if(y<0||x<0||x>=w||y>=h)return res;\n      if(mp[y][x]!=-1&&!used[y][x])break;\n    }\n  }\n  assert(0);\n}\n\nint main(){\n  int n;\n  cin>>n;\n  X.resize(n),Y.resize(n),d.resize(n);\n  for(int i=0;i<n;i++){\n    char ch;\n    cin>>X[i]>>Y[i]>>ch;\n    if(ch=='^')d[i]=0;\n    if(ch=='>')d[i]=1;\n    if(ch=='v')d[i]=2;\n    if(ch=='<')d[i]=3;\n  }\n  h=compless(Y,y);\n  w=compless(X,x);\n  vector<vector<int> >mp(h,vector<int>(w,-1));\n  for(int i=0;i<X.size();i++)mp[y[Y[i]]][x[X[i]]]=d[i];\n\n  int ans=1;\n  for(int i=0;i<n;i++)ans=max(ans,calc(y[Y[i]],x[X[i]],mp));\n  cout <<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing Vec = vector<int>;\nusing Mat = vector<Vec>;\n\nint simulate(int v, int dir, Vec& d, Mat adj)\n{\n    int cnt = 1;\n    while (true) {\n        int next = adj[v][dir];\n        if (next == -1) break;\n        \n        for (int i = 0; i < 4; i++) {\n            if (adj[v][i] != -1) {\n                adj[adj[v][i]][(i + 2) % 4] = adj[v][(i + 2) % 4];\n            }\n        }\n        \n        v = next;\n        dir = d[v];\n        cnt += 1;\n    }    \n    return cnt;\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n    Vec x(N), y(N), d(N);\n    const string dv = \"<^>v\";\n    for (int i = 0; i < N; i++) {\n        char ch;\n        cin >> x[i] >> y[i] >> ch;\n        d[i] = dv.find(ch);\n    }\n\n    Mat adj(N, vector<int>(4, -1));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i == j) continue;\n            if (x[i] == x[j]) {\n                if (y[i] > y[j] && (adj[i][1] == -1 || y[adj[i][1]] < y[j])) {\n                    adj[i][1] = j;\n                }\n                if (y[i] < y[j] && (adj[i][3] == -1 || y[adj[i][3]] > y[j])) {\n                    adj[i][3] = j;\n                }\n            }\n            if (y[i] == y[j]) {\n                if (x[i] > x[j] && (adj[i][0] == -1 || x[adj[i][0]] < x[j])) {\n                    adj[i][0] = j;\n                }\n                if (x[i] < x[j] && (adj[i][2] == -1 || x[adj[i][2]] > x[j])) {\n                    adj[i][2] = j;\n                }\n            }\n        }\n    }\n\n    int res = 0;\n    for (int i = 0; i < N; i++) {\n        res = max(res, simulate(i, d[i], d, adj));\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, int>;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tchar c;\n\tvector<int> x(N), y(N), d(N);\n\tmap<int, set<P>> mp1, mp2;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> x[i] >> y[i] >> c;\n\t\tmp1[x[i]].insert(P(y[i], i));\n\t\tmp2[y[i]].insert(P(x[i], i));\n\n\t\td[i] = c == '>' ? 0 : c == '^' ? 1 : c == '<' ? 2 : 3;\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tauto t1 = mp1;\n\t\tauto t2 = mp2;\n\t\tint p = i;\n\t\tint cnt = 0;\n\t\twhile (1) {\n\t\t\tt1[x[p]].erase(P(y[p], p));\n\t\t\tt2[y[p]].erase(P(x[p], p));\n\t\t\tcnt++;\n\t\t\tif (d[p] == 3) {\n\t\t\t\tauto ite = t1[x[p]].lower_bound(P(y[p], 0));\n\t\t\t\tif (t1[x[p]].empty() || ite == t1[x[p]].end()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp = ite->second;\n\t\t\t}\n\t\t\telse if (d[p] == 0) {\n\t\t\t\tauto ite = t2[y[p]].lower_bound(P(x[p], 0));\n\t\t\t\tif (t2[y[p]].empty() || ite == t2[y[p]].end()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp = ite->second;\n\t\t\t}\n\t\t\telse if (d[p] == 1) {\n\t\t\t\tauto ite = t1[x[p]].upper_bound(P(y[p], 1e9));\n\t\t\t\tif (t1[x[p]].empty() || ite-- == t1[x[p]].begin()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp = ite->second;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tauto ite = t2[y[p]].upper_bound(P(x[p], 1e9));\n\t\t\t\tif (t2[y[p]].empty() || ite-- == t2[y[p]].begin()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tp = ite->second;\n\t\t\t}\n\t\t}\n\t\tres = max(res, cnt);\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3001\nusing namespace std;\nint w,h;\nint dx[]={0,1,0,-1};//^>v<\nint dy[]={-1,0,1,0};\nvector<int> X,Y,d;\nmap<int,int> x,y;\nint mp[N][N];\n\nint compless(vector<int> A,map<int,int> &M){\n  sort(A.begin(),A.end());\n  int c=0;\n  for(int i=0;i<A.size();i++)if(!M.count(A[i]))M[A[i]]=c++;\n  return c;\n}\n\nint calc(int y,int x){\n  bool used[N][N]={};\n  int res=0;\n  while(1){\n    res++;\n    int i=mp[y][x];\n    used[y][x]=1;\n    while(1){\n      y+=dy[i],x+=dx[i];\n      if(y<0||x<0||x>=w||y>=h)return res;\n      if(mp[y][x]!=-1&&!used[y][x])break;\n    }\n  }\n  assert(0);\n}\n\nint main(){\n  int n;\n  cin>>n;\n  X.resize(n),Y.resize(n),d.resize(n);\n  for(int i=0;i<n;i++){\n    char ch;\n    cin>>X[i]>>Y[i]>>ch;\n    if(ch=='^')d[i]=0;\n    if(ch=='>')d[i]=1;\n    if(ch=='v')d[i]=2;\n    if(ch=='<')d[i]=3;\n  }\n  h=compless(Y,y);\n  w=compless(X,x);\n  \n  memset(mp,-1,sizeof(mp));\n  for(int i=0;i<X.size();i++)mp[y[Y[i]]][x[X[i]]]=d[i];\n  int ans=1;\n  for(int i=0;i<n;i++)ans=max(ans,calc(y[Y[i]],x[X[i]]));\n  cout <<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pic = pair<int,char>;\n\nint main(){\n    int n;\n    cin >>n;\n\n    vector<int> x(n),y(n);\n    vector<char> d(n);\n\n    vector<int> ux,uy;\n    rep(i,n){\n        cin >>x[i] >>y[i] >>d[i];\n        ux.pb(x[i]);\n        uy.pb(y[i]);\n    }\n\n    sort(all(ux));\n    ux.erase(unique(all(ux)), ux.end());\n    sort(all(uy));\n    uy.erase(unique(all(uy)), uy.end());\n\n    int X = ux.size(), Y = uy.size();\n\n    rep(i,n){\n        x[i] = lower_bound(all(ux), x[i]) - ux.begin();\n        y[i] = lower_bound(all(uy), y[i]) - uy.begin();\n    }\n\n    int ans = 0;\n    rep(i,n){\n        // initialize\n        vector<set<pic>> sx(X), sy(Y);\n        rep(j,n){\n            sx[x[j]].insert({y[j],d[j]});\n            sy[y[j]].insert({x[j],d[j]});\n        }\n\n        int tmp = 0;\n        int cx = x[i], cy = y[i];\n        char cd = d[i];\n        while(1){\n            // remove current position\n            sx[cx].erase({cy,cd});\n            sy[cy].erase({cx,cd});\n            ++tmp;\n\n            if(cd == '>'){\n                auto itr = sy[cy].lower_bound({cx,cd});\n                if(itr == sy[cy].end()) break;\n\n                cx = itr->fi;\n                cd = itr->se;\n            }\n            else if(cd == '<'){\n                auto itr = sy[cy].lower_bound({cx,cd});\n                if(itr == sy[cy].begin()) break;\n                --itr;\n                cx = itr->fi;\n                cd = itr->se;\n\n            }\n            else if(cd == 'v'){\n                auto itr = sx[cx].lower_bound({cy,cd});\n                if(itr == sx[cx].end()) break;\n\n                cy = itr->fi;\n                cd = itr->se;\n            }\n            else if(cd == '^'){\n                auto itr = sx[cx].lower_bound({cy,cd});\n                if(itr == sx[cx].begin()) break;\n                --itr;\n                cy = itr->fi;\n                cd = itr->se;\n            }\n            else assert(false);\n        }\n\n        ans = max(ans, tmp);\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 3003\n#define inf 1<<29\n#define linf 1e16\n#define eps (1e-8)\n#define mod 1000000007\n#define pi acos(-1)\n#define phi (1.0+sqrt(5))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nint n;\nvector<pii> e[MAX]; \nint a[MAX],b[MAX];\nstring c[MAX];\nbool used[MAX];\n\nint dfs(int v){\n  used[v]=true;\n  pair<int,int> m(inf,inf);\n  FOR(i,0,e[v].size()){\n    if(!used[e[v][i].s])m=min(m,e[v][i]);\n  }\n  if(m.f==inf)return 1;\n  return 1+dfs(m.s);\n}\n\nint solve(){\n  int res=0;\n  FOR(i,0,n){\n    FOR(j,0,n){\n      if(i==j)continue;\n      if(c[i]==\">\" && b[i]==b[j] && a[i]<a[j])e[i].pb(mp(a[j]-a[i],j));\n      if(c[i]==\"<\" && b[i]==b[j] && a[j]<a[i])e[i].pb(mp(a[i]-a[j],j));\n      if(c[i]==\"v\" && a[i]==a[j] && b[i]<b[j])e[i].pb(mp(b[j]-b[i],j));\n      if(c[i]==\"^\" && a[i]==a[j] && b[j]<b[i])e[i].pb(mp(b[i]-b[j],j));\n    }\n  }\n  FOR(i,0,n){\n    fill(used,used+MAX,false);\n    res=max(res,dfs(i));\n  }\n  return res;\n}\n\nint main()\n{\n  cin>>n;\n  FOR(i,0,n)cin>>a[i]>>b[i]>>c[i];\n  cout<<solve()<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nmap<int,set<int> > xx,yy;\nmap<pint,char> d;\nint x[3001],y[3001];\nconst int INF=1000100010;\nint main(){\n    int n;\n    cin>>n;\n    char c;\n    rep(i,n){\n        cin>>x[i]>>y[i]>>c;\n        xx[x[i]].insert(y[i]);\n        yy[y[i]].insert(x[i]);\n        d[pint(x[i],y[i])]=c;\n    }\n    for(auto it:xx){\n        it.second.insert(INF);\n        it.second.insert(-INF);\n        yy[it.first].insert(INF);\n        yy[it.first].insert(-INF);\n    }\n    for(auto it:yy){\n        it.second.insert(INF);\n        it.second.insert(-INF);\n        xx[it.first].insert(INF);\n        xx[it.first].insert(-INF);\n    }\n    int mx=0;\n    rep(i,n){\n        int cnt=0;\n        int tx=x[i],ty=y[i];\n        map<int,set<int> > sx=xx,sy=yy;\n        while(1){\n            ++cnt;\n            sx[tx].erase(ty),sy[ty].erase(tx);\n            char tc=d[pint(tx,ty)];\n            if(tc=='v'){\n                ty=*sx[tx].lower_bound(ty);\n            }\n            else if(tc=='^'){\n                auto p=sx[tx].lower_bound(ty);\n                --p;\n                ty=*p;\n            }\n            else if(tc=='<'){\n                auto p=sy[ty].lower_bound(tx);\n                --p;\n                tx=*p;\n\n            }\n            else{\n                tx=*sy[ty].lower_bound(tx);\n            }\n            //cout<<tx<<ty<<endl;\n            if(abs(tx)==INF||abs(ty)==INF) break;\n        }\n        mx=max(mx,cnt);\n    }\n    cout<<mx<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nconstexpr int INF = (1<<30) - 1;\nconstexpr ll LLINF = (1ll<<60);\n\nusing vint = vector<int>;\nint simulation(int sx, int sy, map<int, set<Pi>> row, map<int, set<Pi>> col) {\n        int ret = 1;    \n        \n        auto getd = [&](int y, int x) {\n                return (row[y].lower_bound(Pi(x, -INF))->second);\n        };\n\n        int dir = getd(sy, sx);\n        //cout << sx << \" \" << sy << \" \" << (char)dir << endl;\n\n        //cout << \"A:\" << row[sy].size() << \" \" << col[sx].size() << endl;\n        row[sy].erase(Pi(sx, dir));\n        col[sx].erase(Pi(sy, dir));\n        //cout << \"B:\" << row[sy].size() << \" \" << col[sx].size() << endl;\n        int x = sx, y = sy;\n        while (true) {\n                //cout << \"    \" << x << \" \" << y << endl;\n                //find\n                int nx, ny, nd;\n                if (dir == '^') {\n                        auto pos = col[x].lower_bound(Pi(y, -INF));\n                        if (pos == begin(col[x])) return (ret);\n                        --pos;\n                        nx = x, ny = pos->first;\n                        nd = pos->second;\n                        ret++;\n                } else if (dir == '>') {\n                        auto pos = row[y].lower_bound(Pi(x, -INF));\n                        if (pos == end(row[y])) return (ret);\n                        nx = pos->first, ny = y;\n                        nd = pos->second;\n                        ret++;\n                } else if (dir == '<') {\n                        auto pos = row[y].lower_bound(Pi(x, -INF));\n                        if (pos == begin(row[y])) return (ret);\n                        pos--;\n                        nx = pos->first, ny = y;\n                        nd = pos->second;\n                        ret++;\n                } else {\n                        auto pos = col[x].lower_bound(Pi(y, -INF));\n                        if (pos == end(col[x])) return (ret);\n                        nx = x, ny = pos->first;\n                        //cout << \"                \" << nx << \" \" << ny << endl;\n                        nd = pos->second;\n                        ret++;\n                }\n                row[ny].erase(Pi(nx, nd));\n                col[nx].erase(Pi(ny, nd));\n                y = ny, x = nx, dir = nd;\n        }\n        return (ret);\n}\n\nint main() {\n        int N; cin >> N;\n        vint X(N), Y(N), D(N);\n\n        map<int, set<Pi>> row, col;\n        for (int i = 0; i < N; i++) {\n                int x, y;\n                char d; cin >> x >> y >> d;\n                tie(X[i], Y[i], D[i]) = tie(x, y, d);\n                row[y].insert(Pi(x, d));\n                col[x].insert(Pi(y, d));\n        }\n        \n        int maxv = 0;\n        for (int i = 0; i < N; i++) {\n                //cout << X[i] << \" \" << Y[i] << endl;\n                int val = simulation(X[i], Y[i], row, col);\n                maxv = max(maxv, val);\n                //cout << val << endl;\n        }\n\n        cout << maxv << endl;   \n        return (0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 3003\n#define inf (int)(1e9+1)\n#define linf 1e16\n#define eps (1e-8)\n#define mod 1000000007\n#define pi acos(-1)\n#define phi (1.0+sqrt(5))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nint n;\nvector<pair<ll,int> > e[MAX]; \nint a[MAX],b[MAX];\nstring c[MAX];\nbool used[MAX];\n\nint dfs(int v){\n  used[v]=true;\n  pair<ll,int> m(linf,inf);\n  FOR(i,0,e[v].size()){\n    if(!used[e[v][i].s])m=min(m,e[v][i]);\n  }\n  if(m.s==inf)return 1;\n  return 1+dfs(m.s);\n}\n\nint solve(){\n  int res=0;\n  FOR(i,0,n){\n    FOR(j,0,n){\n      if(i==j)continue;\n      if(c[i]==\">\" && b[i]==b[j] && a[i]<a[j])e[i].pb(mp(a[j]-a[i],j));\n      if(c[i]==\"<\" && b[i]==b[j] && a[j]<a[i])e[i].pb(mp(a[i]-a[j],j));\n      if(c[i]==\"v\" && a[i]==a[j] && b[i]<b[j])e[i].pb(mp(b[j]-b[i],j));\n      if(c[i]==\"^\" && a[i]==a[j] && b[j]<b[i])e[i].pb(mp(b[i]-b[j],j));\n    }\n  }\n  FOR(i,0,n){\n    fill(used,used+MAX,false);\n    res=max(res,dfs(i));\n  }\n  return res;\n}\n\nint main()\n{\n  cin>>n;\n  FOR(i,0,n)cin>>a[i]>>b[i]>>c[i];\n  cout<<solve()<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3001\nusing namespace std;\nint w,h;\nint dx[]={0,1,0,-1};//^>v<\nint dy[]={-1,0,1,0};\nvector<int> X,Y,d;\nunordered_map<int,int> x,y;\nint mp[N][N];\n\nint compless(vector<int> A,unordered_map<int,int> &M){\n  sort(A.begin(),A.end());\n  int c=0;\n  for(int i=0;i<A.size();i++)if(!M.count(A[i]))M[A[i]]=c++;\n  return c;\n}\n\nint calc(int y,int x){\n  bool used[N][N]={};\n  int res=0;\n  while(1){\n    res++;\n    int i=mp[y][x];\n    used[y][x]=1;\n    while(1){\n      y+=dy[i],x+=dx[i];\n      if(y<0||x<0||x>=w||y>=h)return res;\n      if(mp[y][x]!=-1&&!used[y][x])break;\n    }\n  }\n  assert(0);\n}\n\nint main(){\n  int n;\n  cin>>n;\n  X.resize(n),Y.resize(n),d.resize(n);\n  for(int i=0;i<n;i++){\n    char ch;\n    cin>>X[i]>>Y[i]>>ch;\n    if(ch=='^')d[i]=0;\n    if(ch=='>')d[i]=1;\n    if(ch=='v')d[i]=2;\n    if(ch=='<')d[i]=3;\n  }\n  h=compless(Y,y);\n  w=compless(X,x);\n  \n  memset(mp,-1,sizeof(mp));\n  for(int i=0;i<X.size();i++)mp[y[Y[i]]][x[X[i]]]=d[i];\n  int ans=1;\n  for(int i=0;i<n;i++)ans=max(ans,calc(y[Y[i]],x[X[i]]));\n  cout <<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\nsigned main(){\n  int n;\n  cin>>n;\n  int x[n],y[n];\n  char d[n];\n  for(int i=0;i<n;i++) cin>>x[i]>>y[i]>>d[i];\n  int INF=1LL<<55LL;\n  map<P,int> m;\n  for(int i=0;i<n;i++) m[P(x[i],y[i])]=i;\n  vector<int> cx,cy;\n  cx.push_back(INF);\n  cx.push_back(-INF);\n  cy.push_back(INF);\n  cy.push_back(-INF);\n  for(int i=0;i<n;i++){\n    cx.push_back(x[i]);\n    cy.push_back(y[i]);\n  }\n  sort(cx.begin(),cx.end());\n  cx.erase(unique(cx.begin(),cx.end()),cx.end());\n  sort(cy.begin(),cy.end());\n  cy.erase(unique(cy.begin(),cy.end()),cy.end());\n  map<int,int> rx,ry;\n  for(int i=0;i<(int)cx.size();i++) rx[cx[i]]=i;\n  for(int i=0;i<(int)cy.size();i++) ry[cy[i]]=i;\n  vector<set<int> > tx(cx.size()),ty(cy.size());\n  for(auto& s:tx){\n    s.insert(ry[INF]);\n    s.insert(ry[-INF]);\n  }\n  for(auto& s:ty){\n    s.insert(rx[INF]);\n    s.insert(rx[-INF]);\n  }\n  for(int i=0;i<n;i++){\n    tx[rx[x[i]]].insert(ry[y[i]]);\n    ty[ry[y[i]]].insert(rx[x[i]]);\n  }\n  int ans=0;\n  for(int i=0;i<n;i++){\n    vector<set<int> > sx=tx,sy=ty;\n    int px=rx[x[i]],py=ry[y[i]];\n    char pd=d[i];\n    int tmp=0;\n    while(1){\n      tmp++;\n      int bx=px,by=py;\n      auto latte=sx[px].find(py);\n      auto malta=sy[py].find(px);\n      if(pd=='>') ++malta;\n      if(pd=='<') --malta;\n      if(pd=='v') ++latte;\n      if(pd=='^') --latte;\n      px=*malta;\n      py=*latte;\n      pd=d[m[P(cx[px],cy[py])]];\n      if(abs(cx[px])==INF||abs(cy[py])==INF) break;\n      sx[bx].erase(by);\n      sy[by].erase(bx);\n    }\n    ans=max(ans,tmp);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint solve(int x, int y, vector<set<int>>& vx, vector<set<int>>& vy, char d, vector<vector<char>> const& dd) {\n    if(d == '>') {\n        auto it = vy[y].upper_bound(x);\n        if(it == vy[y].end()) {\n            return 1;\n        }\n        int nx = (*it);\n        char nd = dd[*it][y];\n        vy[y].erase(it);\n        vx[nx].erase(y);\n        return solve(nx, y, vx, vy, nd, dd) + 1;\n    } else if(d == '<') {\n        auto it = vy[y].lower_bound(x);\n        if(it == vy[y].begin()) {\n            return 1;\n        }\n        int nx = *(--it);\n        char nd = dd[nx][y];\n        vy[y].erase(it);\n        vx[nx].erase(y);\n        return solve(nx, y, vx, vy, nd, dd) + 1;\n    } else if(d == 'v') {\n        auto it = vx[x].upper_bound(y);\n        if(it == vx[x].end()) {\n            return 1;\n        }\n        int ny = *it;\n        char nd = dd[x][ny];\n        vx[x].erase(ny);\n        vy[ny].erase(x);\n        return solve(x, ny, vx, vy, nd, dd) + 1;\n    } else {\n        auto it = vx[x].lower_bound(y);\n        if(it == vx[x].begin()) {\n            return 1;\n        }\n        int ny = *(--it);\n        char nd = dd[x][ny];\n        vx[x].erase(ny);\n        vy[ny].erase(x);\n        return solve(x, ny, vx, vy, nd, dd) + 1;\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    using data = tuple<int, int, char>;\n    vector<int> x(n), y(n);\n    vector<char> d(n);\n    vector<int> xs, ys;\n    for(int i=0; i<n; ++i) {\n        cin >> x[i] >> y[i] >> d[i];\n        xs.push_back(x[i]);\n        ys.push_back(y[i]);\n    }\n    sort(xs.begin(), xs.end());\n    xs.erase(unique(xs.begin(), xs.end()), xs.end());\n    sort(ys.begin(), ys.end());\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n    for(int i=0; i<n; ++i) {\n        x[i] = lower_bound(xs.begin(), xs.end(), x[i]) - xs.begin();\n        y[i] = lower_bound(ys.begin(), ys.end(), y[i]) - ys.begin();\n    }\n    vector<vector<char>> dd(xs.size(), vector<char>(ys.size()));\n    for(int i=0; i<n; ++i) {\n        dd[x[i]][y[i]] = d[i];\n    }\n    vector<set<int>> vx(xs.size());\n    vector<set<int>> vy(ys.size());\n    for(int i=0; i<n; ++i) {\n        vx[x[i]].insert(y[i]);\n        vy[y[i]].insert(x[i]);\n    }\n    int res = 0;\n    for(int i=0; i<n; ++i) {\n        auto vxx = vx;\n        auto vyy = vy;\n        vxx[x[i]].erase(y[i]);\n        vyy[y[i]].erase(x[i]);\n        res = max(res, solve(x[i], y[i], vxx, vyy, d[i], dd));\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3001\nusing namespace std;\nint w,h;\nint dx[]={0,1,0,-1};//^>v<\nint dy[]={-1,0,1,0};\nvector<int> X,Y,d;\nmap<int,int> x,y;\nint mp[N][N];\n\nint compless(vector<int> A,map<int,int> &M){\n  sort(A.begin(),A.end());\n  int c=0;\n  for(int i=0;i<A.size();i++)if(!M.count(A[i]))M[A[i]]=c++;\n  return c;\n}\n\nint calc(int y,int x){\n  vector<vector<bool> > used(h,vector<bool>(w,0));\n  int res=0;\n  while(1){\n    res++;\n    int i=mp[y][x];\n    used[y][x]=1;\n    while(1){\n      y+=dy[i],x+=dx[i];\n      if(y<0||x<0||x>=w||y>=h)return res;\n      if(mp[y][x]!=-1&&!used[y][x])break;\n    }\n  }\n  assert(0);\n}\n\nint main(){\n  int n;\n  cin>>n;\n  X.resize(n),Y.resize(n),d.resize(n);\n  for(int i=0;i<n;i++){\n    char ch;\n    cin>>X[i]>>Y[i]>>ch;\n    if(ch=='^')d[i]=0;\n    if(ch=='>')d[i]=1;\n    if(ch=='v')d[i]=2;\n    if(ch=='<')d[i]=3;\n  }\n  h=compless(Y,y);\n  w=compless(X,x);\n  \n  memset(mp,-1,sizeof(mp));\n  for(int i=0;i<X.size();i++)mp[y[Y[i]]][x[X[i]]]=d[i];\n  int ans=1;\n  for(int i=0;i<n;i++)ans=max(ans,calc(y[Y[i]],x[X[i]]));\n  cout <<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<tuple>\nusing namespace std;\nclass BIT {\nprivate:\n\tint size_; vector<int>x;\npublic:\n\tBIT() : size_(0), x(vector<int>()) {};\n\tBIT(int size__) : size_(size__) {\n\t\tx.resize(size__ + 1);\n\t\tfor (int i = 0; i < size__ + 1; i++)x[i] = 0;\n\t}\n\tint size() { return size_; }\n\tvoid add(int r, int p) {\n\t\twhile (r <= size_) { x[r] += p; r += r&-r; }\n\t}\n\tint sums(int r) {\n\t\tint cnt1 = 0; while (r >= 1) { cnt1 += x[r]; r -= r&-r; }\n\t\treturn cnt1;\n\t}\n\tint sum(int l, int r) {\n\t\treturn sums(r) - sums(l - 1);//Range [l, r]\n\t}\n};\nint n, x[5000], y[5000], dir[5000];\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\nvector<int>XX, YY, XXX, YYY, XR[3100], YR[3100];//XR=yoko, YR=tate\nvector<tuple<int, int, int>>posit;\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tchar c; cin >> x[i] >> y[i] >> c; XX.push_back(x[i]); YY.push_back(y[i]);\n\t\tif (c == 'v')dir[i] = 0; if (c == '>')dir[i] = 1; if (c == '^')dir[i] = 2; if (c == '<')dir[i] = 3;\n\t\tposit.push_back(make_tuple(x[i], y[i], dir[i]));\n\t}\n\tsort(XX.begin(), XX.end()); sort(YY.begin(), YY.end()); sort(posit.begin(), posit.end()); XXX.push_back(XX[0]); YYY.push_back(YY[0]);\n\tfor (int i = 1; i < XX.size(); i++) { if (XX[i - 1] != XX[i])XXX.push_back(XX[i]); }\n\tfor (int i = 1; i < YY.size(); i++) { if (YY[i - 1] != YY[i])YYY.push_back(YY[i]); }\n\tfor (int i = 0; i < n; i++) {\n\t\tint pos1 = lower_bound(XXX.begin(), XXX.end(), x[i]) - XXX.begin(); x[i] = pos1 + 1;\n\t\tint pos2 = lower_bound(YYY.begin(), YYY.end(), y[i]) - YYY.begin(); y[i] = pos2 + 1;\n\t\tXR[x[i]].push_back(y[i]); YR[y[i]].push_back(x[i]);\n\t}\n\tvector<BIT> X(n + 2, BIT(n + 2)), Y(n + 2, BIT(n + 2));\n\tint maxn = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tvector<tuple<int, int, int>>used;\n\t\tint cx = x[i], cy = y[i], cd = dir[i];\n\t\tfor (int j = 0; j < n; j++) { X[x[i]].add(y[i], 1); Y[y[i]].add(x[i], 1); used.push_back(make_tuple(x[i], y[i], 0)); }\n\t\tbool flag = true; sort(used.begin(), used.end());\n\t\tint cnt2 = 0;\n\t\twhile (true) {\n\t\t\t//--------------DOWN---------------\n\t\t\tif (cd == 0) {\n\t\t\t\tint L = cx, R = n + 2, M;\n\t\t\t\twhile(true){\n\t\t\t\t\tM = (L + R) / 2;\n\t\t\t\t\tint E1 = Y[cy].sum(cx, M - 1);\n\t\t\t\t\tint E2 = Y[cy].sum(cx, M);\n\t\t\t\t\tif (E1 <= 0 && E2 >= 1) {\n\t\t\t\t\t\tY[cy].add(cx, -1); X[cx].add(cy, -1);\n\t\t\t\t\t\tint pos3 = lower_bound(used.begin(), used.end(), make_tuple(cx, cy, 0)) - used.begin();\n\t\t\t\t\t\tget<2>(used[pos3]) = 1; cx = M;\n\t\t\t\t\t\tint pos4 = lower_bound(posit.begin(), posit.end(), make_tuple(cx, cy, 0)) - posit.begin(); cd = get<2>(posit[pos4]); break;\n\t\t\t\t\t}\n\t\t\t\t\tif (E1 >= 1)R = M;\n\t\t\t\t\tif (E2 <= 0)L = M;\n\t\t\t\t\tif (E2 <= 0 && M == n + 1) { flag = false; break; }\n\t\t\t\t}\n\t\t\t}\n\t\t\t//--------------UP---------------\n\t\t\telse if (cd == 2) {\n\t\t\t\tint L = 0, R = cx + 1, M;\n\t\t\t\twhile (true) {\n\t\t\t\t\tM = (L + R) / 2;\n\t\t\t\t\tint E1 = Y[cy].sum(M - 1, cx);\n\t\t\t\t\tint E2 = Y[cy].sum(M, cx);\n\t\t\t\t\tif (E1 >= 1 && E2 <= 0) {\n\t\t\t\t\t\tY[cy].add(cx, -1); X[cx].add(cy, -1);\n\t\t\t\t\t\tint pos3 = lower_bound(used.begin(), used.end(), make_tuple(cx, cy, 0)) - used.begin();\n\t\t\t\t\t\tget<2>(used[pos3]) = 1; cx = M;\n\t\t\t\t\t\tint pos4 = lower_bound(posit.begin(), posit.end(), make_tuple(cx, cy, 0)) - posit.begin(); cd = get<2>(posit[pos4]); break;\n\t\t\t\t\t}\n\t\t\t\t\tif (E1 <= 0)R = M;\n\t\t\t\t\tif (E2 >= 1)L = M;\n\t\t\t\t\tif (E1 <= 0 && M == 0) { flag = false; break; }\n\t\t\t\t}\n\t\t\t}\n\t\t\t//--------------RIGHT---------------\n\t\t\telse if (cd == 1) {\n\t\t\t\tint L = cy, R = n + 2, M;\n\t\t\t\twhile (true) {\n\t\t\t\t\tM = (L + R) / 2;\n\t\t\t\t\tint E1 = X[cx].sum(cy, M - 1);\n\t\t\t\t\tint E2 = X[cx].sum(cy, M);\n\t\t\t\t\tif (E1 <= 0 && E2 >= 1) {\n\t\t\t\t\t\tY[cx].add(cy, -1); X[cy].add(cx, -1);\n\t\t\t\t\t\tint pos3 = lower_bound(used.begin(), used.end(), make_tuple(cx, cy, 0)) - used.begin();\n\t\t\t\t\t\tget<2>(used[pos3]) = 1; cy = M;\n\t\t\t\t\t\tint pos4 = lower_bound(posit.begin(), posit.end(), make_tuple(cx, cy, 0)) - posit.begin(); cd = get<2>(posit[pos4]); break;\n\t\t\t\t\t}\n\t\t\t\t\tif (E1 >= 1)R = M;\n\t\t\t\t\tif (E2 <= 0)L = M;\n\t\t\t\t\tif (E2 <= 0 && M == n + 1) { flag = false; break; }\n\t\t\t\t}\n\t\t\t}\n\t\t\t//--------------LEFT---------------\n\t\t\telse if (cd == 3) {\n\t\t\t\tint L = 0, R = cy + 1, M;\n\t\t\t\twhile (true) {\n\t\t\t\t\tM = (L + R) / 2;\n\t\t\t\t\tint E1 = X[cx].sum(M - 1, cy);\n\t\t\t\t\tint E2 = X[cx].sum(M, cy);\n\t\t\t\t\tif (E1 >= 1 && E2 <= 0) {\n\t\t\t\t\t\tY[cy].add(cx, -1); X[cx].add(cy, -1);\n\t\t\t\t\t\tint pos3 = lower_bound(used.begin(), used.end(), make_tuple(cx, cy, 0)) - used.begin();\n\t\t\t\t\t\tget<2>(used[pos3]) = 1; cx = M;\n\t\t\t\t\t\tint pos4 = lower_bound(posit.begin(), posit.end(), make_tuple(cx, cy, 0)) - posit.begin(); cd = get<2>(posit[pos4]); break;\n\t\t\t\t\t}\n\t\t\t\t\tif (E1 <= 0)R = M;\n\t\t\t\t\tif (E2 >= 1)L = M;\n\t\t\t\t\tif (E1 <= 0 && M == 0) { flag = false; break; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt2++;\n\t\t\tif (flag == false) { break; }\n\t\t}\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint a1 = get<0>(used[j]), a2 = get<1>(used[j]), a3 = get<2>(used[j]);\n\t\t\tif (a3 == 0)continue;\n\t\t\tX[a1].add(a2, -1); Y[a2].add(a1, -1);\n\t\t}\n\t\tmaxn = max(maxn, cnt2);\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n; char c[3009][3009];\nint main() {\n\tcin >> n;\n\tvector<int> x(n), y(n);\n\tvector<string> s(n);\n\tfor (int i = 0; i < n; i++) cin >> x[i] >> y[i] >> s[i];\n\tvector<int> tx = x, ty = y;\n\tsort(tx.begin(), tx.end());\n\ttx.erase(unique(tx.begin(), tx.end()));\n\tsort(ty.begin(), ty.end());\n\tty.erase(unique(ty.begin(), ty.end()));\n\tfor (int i = 0; i < n; i++) {\n\t\tx[i] = lower_bound(tx.begin(), tx.end(), x[i]) - tx.begin();\n\t\ty[i] = lower_bound(ty.begin(), ty.end(), y[i]) - ty.begin();\n\t\tc[x[i]][y[i]] = s[i][0];\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tvector<set<int> > px(tx.size());\n\t\tvector<set<int> > py(ty.size());\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tpx[x[j]].insert(y[j]);\n\t\t\tpy[y[j]].insert(x[j]);\n\t\t}\n\t\tpx[x[i]].erase(y[i]);\n\t\tpy[y[i]].erase(x[i]);\n\t\tint cx = x[i], cy = y[i], cnt = 1;\n\t\twhile (true) {\n\t\t\tif (c[cx][cy] == '<' || c[cx][cy] == '>') {\n\t\t\t\tset<int>::iterator it = py[cy].lower_bound(cx);\n\t\t\t\tif (c[cx][cy] == '<') {\n\t\t\t\t\tif (it == py[cy].begin()) break;\n\t\t\t\t\telse it--;\n\t\t\t\t}\n\t\t\t\telse if (it == py[cy].end()) break;\n\t\t\t\tcx = *it;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tset<int>::iterator it = px[cx].lower_bound(cy);\n\t\t\t\tif (c[cx][cy] == '^') {\n\t\t\t\t\tif (it == px[cx].begin()) break;\n\t\t\t\t\telse it--;\n\t\t\t\t}\n\t\t\t\telse if (it == px[cx].end()) break;\n\t\t\t\tcy = *it;\n\t\t\t\tpx[cx].erase(it);\n\t\t\t}\n\t\t\tpx[cx].erase(cy);\n\t\t\tpy[cy].erase(cx);\n\t\t\tcnt++;\n\t\t}\n\t\tret = max(ret, cnt);\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst string D = \"^>v<\";\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 0};\nconst int inf = 1 << 25;\nint fld[3000][3000], w, h;\nint ans;\n\n\nvoid compress(vector<int>& vec)\n{\n  vector<int> temp = vec;\n  sort(temp.begin(), temp.end());\n  temp.erase(unique(temp.begin(), temp.end()), temp.end());\n  for(int i = 0; i < vec.size(); i++){\n    vec[i] = find(temp.begin(), temp.end(), vec[i]) - temp.begin();\n  }\n}\n\nint solve(int x, int y, int d)\n{\n  if(x < 0 || w < x || y < 0 || h < y) return 0;\n  int nx = x + dx[d], ny = y + dy[d], nd = d;\n  if(0 <= nx && nx <= w && 0 <= ny && ny <= h && fld[ny][nx] != -1) nd = fld[ny][nx];\n  int hoge = fld[y][x];\n  fld[y][x] = -1;\n  int ret = solve(nx, ny, nd) + (hoge != -1);\n  return ret;\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n  vector<int> ix, iy, id;\n  for(int i = 0; i < n; i++){\n    int x, y; char d;\n    cin >> x >> y >> d;\n    ix.push_back(x);\n    iy.push_back(y);\n    id.push_back(D.find(d));\n  }\n  compress(ix);\n  compress(iy);\n  w = *max_element(ix.begin(), ix.end()), h = *max_element(iy.begin(), iy.end());\n  ans = 0;\n  memset(fld, -1, sizeof(fld));\n  /*\n  for(int j = 0; j < n; j++) fld[iy[j]][ix[j]] = id[j];\n  for(int i = 0; i <= h; i++){\n    for(int j = 0; j <= w; j++) printf(\"%2d\", fld[i][j]); \n    cout << endl;\n  }\n  */\n  for(int i = 0; i < n; i++){\n    //memset(fld, -1, sizeof(fld));\n    for(int j = 0; j < n; j++) fld[iy[j]][ix[j]] = id[j];\n    ans = max(ans, solve(ix[i], iy[i], id[i]));\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    vi x(n), y(n);\n    map<int, map<int, char>> d;\n    rep(i, n){\n        char c;\n        cin >> x[i] >> y[i] >> c;\n        d[y[i]][x[i]] = c;\n    }\n\n    map<int, set<int>> x2y_, y2x_, x2ny_, y2nx_;\n    rep(i, n){\n        int xx = x[i], yy = y[i];\n        x2y_ [xx].insert( yy);\n        x2ny_[xx].insert(-yy);\n        y2x_ [yy].insert( xx);\n        y2nx_[yy].insert(-xx);\n    }\n\n    int res = 0;\n    rep(i, n){\n        auto x2y = x2y_, y2x = y2x_, x2ny = x2ny_, y2nx = y2nx_;\n\n        int cx = x[i], cy = y[i];\n        int cur = 0;\n        while(true){\n            cur++;\n            int nx = cx, ny = cy;\n            switch(d[cy][cx]){\n                case 'v': { auto ni = x2y [cx].upper_bound( cy); if(ni != end(x2y [cx])){ ny =   *ni ; } break; }\n                case '^': { auto ni = x2ny[cx].upper_bound(-cy); if(ni != end(x2ny[cx])){ ny = -(*ni); } break; }\n                case '>': { auto ni = y2x [cy].upper_bound( cx); if(ni != end(y2x [cy])){ nx =   *ni ; } break; }\n                case '<': { auto ni = y2nx[cy].upper_bound(-cx); if(ni != end(y2nx[cy])){ nx = -(*ni); } break; }\n            }\n            x2y[cx].erase(cy); x2ny[cx].erase(-cy);\n            y2x[cy].erase(cx); y2nx[cy].erase(-cx);\n\n            if(nx == cx and ny == cy) break;\n            cx = nx, cy = ny;\n        }\n        chmax(res, cur);\n    }\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\ntypedef vector<string> svec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\n\nvoid to_unique(vector<int> &v) {\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n}\n\nint n;\nvoid solve() {\n\tcin >> n;\n\tvector<P> v(n);\n\tvector<char> d(n);\n\trep(i, n) {\n\t\tcin >> v[i].first >> v[i].second >> d[i];\n\t}\n\tvector<int> vx, vy;\n\t{\n\t\trep(i, n) {\n\t\t\tvx.push_back(v[i].first);\n\t\t\tvy.push_back(v[i].second);\n\t\t}\n\t\tto_unique(vx), to_unique(vy);\n\t\tmap<int, int> mx, my;\n\t\trep(i, vx.size()) {\n\t\t\tmx[vx[i]] = i;\n\t\t}\n\t\trep(i, vy.size()) {\n\t\t\tmy[vy[i]] = i;\n\t\t}\n\t\trep(i, n) {\n\t\t\tv[i].first = mx[v[i].first];\n\t\t\tv[i].second = my[v[i].second];\n\t\t}\n\t}\n\tmap<P, int> mp;\n\trep(i, n) {\n\t\tmp[v[i]] = i;\n\t}\n\tvector<set<int>> stx(vx.size()),sty(vy.size());\n\trep(i, n) {\n\t\tstx[v[i].first].insert(v[i].second);\n\t\tsty[v[i].second].insert(v[i].first);\n\t}\n\tint ans = 0;\n\trep(i, n) {\n\t\tvector<set<int>> sx = stx, sy = sty;\n\t\tint cx = v[i].first, cy = v[i].second;\n\t\tint cnt = 0;\n\t\twhile (true) {\n\t\t\tcnt++;\n\t\t\tsx[cx].erase(cy);\n\t\t\tsy[cy].erase(cx);\n\t\t\tint id = mp[{cx, cy}];\n\t\t\tif (d[id] == '>') {\n\t\t\t\tsy[cy].insert(cx);\n\t\t\t\tauto itr = sy[cy].find(cx);\n\t\t\t\titr++;\n\t\t\t\tif (itr == sy[cy].end())break;\n\t\t\t\tint nx = *itr;\n\t\t\t\tsy[cy].erase(cx);\n\t\t\t\tcx = nx;\n\t\t\t}\n\t\t\telse if (d[id] == '<') {\n\t\t\t\tsy[cy].insert(cx);\n\t\t\t\tauto itr = sy[cy].find(cx);\n\t\t\t\tif (itr == sy[cy].begin())break;\n\t\t\t\titr--;\n\t\t\t\tint nx = *itr;\n\t\t\t\tsy[cy].erase(cx);\n\t\t\t\tcx = nx;\n\t\t\t}\n\t\t\telse if (d[id] == 'v') {\n\t\t\t\tsx[cx].insert(cy);\n\t\t\t\tauto itr = sx[cx].find(cy);\n\t\t\t\titr++;\n\t\t\t\tif (itr == sx[cx].end())break;\n\t\t\t\tint ny = *itr;\n\t\t\t\tsx[cx].erase(cy);\n\t\t\t\tcy = ny;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsx[cx].insert(cy);\n\t\t\t\tauto itr = sx[cx].find(cy);\n\t\t\t\tif (itr == sx[cx].begin())break;\n\t\t\t\titr--;\n\t\t\t\tint ny = *itr;\n\t\t\t\tsx[cx].erase(cy);\n\t\t\t\tcy = ny;\n\t\t\t}\n\t\t}\n\t\tans = max(ans, cnt);\n\t}\n\tcout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\t/*while (cin >> n>>m>>l, n) {\n\t\tsolve();\n\t}*/\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 3003\n#define inf 1<<29\n#define linf 1e16\n#define eps (1e-8)\n#define mod 1000000007\n#define pi acos(-1)\n#define phi (1.0+sqrt(5))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nint n;\nvector<pii> e[MAX]; \nint a[MAX],b[MAX];\nstring c[MAX];\nbool used[MAX];\n\nint dfs(int v){\n  int res=1;\n  used[v]=true;\n  FOR(i,0,e[v].size()){\n    int next=e[v][i].s;\n    if(!used[next]){\n      res+=dfs(next);\n      break;\n    }\n  }\n  return res;\n}\n\nint solve(){\n  int res=0;\n  FOR(i,0,n){\n    FOR(j,0,n){\n      if(i==j)continue;\n      if(c[i]==\">\" && b[i]==b[j] && a[i]<a[j])e[i].pb(mp(a[j]-a[i],j));\n      if(c[i]==\"<\" && b[i]==b[j] && a[j]<a[i])e[i].pb(mp(a[i]-a[j],j));\n      if(c[i]==\"v\" && a[i]==a[j] && b[i]<b[j])e[i].pb(mp(b[j]-b[i],j));\n      if(c[i]==\"^\" && a[i]==a[j] && b[j]<b[i])e[i].pb(mp(b[i]-b[j],j));\n    }\n    sort(all(e[i]));\n  }\n  FOR(i,0,n){\n    fill(used,used+MAX,false);\n    res=max(res,dfs(i));\n  }\n  return res;\n}\n\nint main()\n{\n  cin>>n;\n  FOR(i,0,n)cin>>a[i]>>b[i]>>c[i];\n  cout<<solve()<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nmap<int,set<int> > xx,yy;\nmap<pint,char> d;\nint x[3001],y[3001];\nconst int INF=1000100010;\nint main(){\n    int n;\n    cin>>n;\n    char c;\n    rep(i,n){\n        cin>>x[i]>>y[i]>>c;\n        xx[x[i]].insert(y[i]);\n        yy[y[i]].insert(x[i]);\n        d[pint(x[i],y[i])]=c;\n    }\n    for(auto it:xx){\n        it.second.insert(INF);\n        it.second.insert(-INF);\n        yy[it.first].insert(INF);\n        yy[it.first].insert(-INF);\n    }\n    for(auto it:yy){\n        it.second.insert(INF);\n        it.second.insert(-INF);\n        xx[it.first].insert(INF);\n        xx[it.first].insert(-INF);\n    }\n    int mx=0;\n    rep(i,n){\n        int cnt=0;\n        int tx=x[i],ty=y[i];\n        map<int,set<int> > sx=xx,sy=yy;\n        while(1){\n            ++cnt;\n            sx[tx].erase(ty),sy[ty].erase(tx);\n            char tc=d[pint(tx,ty)];\n            if(tc=='v'){\n                ty=*sx[tx].lower_bound(ty);\n            }\n            else if(tc=='^'){\n                auto p=sx[tx].lower_bound(ty);\n                if(p==sx[tx].begin()) break;\n                --p;\n                ty=*p;\n            }\n            else if(tc=='<'){\n                auto p=sy[ty].lower_bound(tx);\n                if(p==sy[ty].begin()) break;\n                --p;\n                tx=*p;\n\n            }\n            else if(tc=='>'){\n                tx=*sy[ty].lower_bound(tx);\n            }\n            else break;\n            if(abs(tx)==INF||abs(ty)==INF) break;\n        }\n        mx=max(mx,cnt);\n    }\n    cout<<mx<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\n//int N, M, K, T, H, W, L, R;\nlong long int N, M, K, T, H, W, L, R;\n\nint func(vector<set<pair<int, int>>>xs, vector<set<pair<int, int>>>ys, vector<int>&x, vector<int>&y, vector<char>&c, int st) {\n\tint cx = x[st], cy = y[st];\n\tint ret = 1;\n\txs[cx].erase(xs[cx].lower_bound({ cy,0 }));\n\tys[cy].erase(ys[cy].lower_bound({ cx,0 }));\n\tchar nx = c[st];\n\twhile (ret < N) {\n\t\tif (nx == '^') {\n\t\t\tauto it = xs[cx].lower_bound({ cy,0 });\n\t\t\tif (xs[cx].begin() == it)break;\n\t\t\tit = prev(it);\n\t\t\tret++;\n\t\t\tcy = it->first;\n\t\t\tnx = c[it->second];\n\t\t}\n\t\telse if (nx == '<') {\n\t\t\tauto it = ys[cy].lower_bound({ cx,0 });\n\t\t\tif (ys[cy].begin() == it)break;\n\t\t\tit = prev(it);\n\t\t\tret++;\n\t\t\tcx = it->first;\n\t\t\tnx = c[it->second];\n\t\t}\n\t\telse if (nx == 'v') {\n\t\t\tauto it = xs[cx].lower_bound({ cy,0 });\n\t\t\tif (xs[cx].end() == it)break;\n\t\t\tret++;\n\t\t\tcy = it->first;\n\t\t\tnx = c[it->second];\n\t\t}\n\t\telse {\n\t\t\tauto it = ys[cy].lower_bound({ cx,0 });\n\t\t\tif (ys[cy].end() == it)break;\n\t\t\tret++;\n\t\t\tcx = it->first;\n\t\t\tnx = c[it->second];\n\t\t}\n\t\txs[cx].erase(xs[cx].lower_bound({ cy,0 }));\n\t\tys[cy].erase(ys[cy].lower_bound({ cx,0 }));\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<int>x(N);\n\tvector<int>y(N);\n\tvector<char>c(N);\n\tmap<int, int>xp;\n\tmap<int, int>yp;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> x[i] >> y[i] >> c[i];\n\t\txp[x[i]] = 0;\n\t\typ[y[i]] = 0;\n\t}\n\tint cnt = 0;\n\tfor (auto &i : xp) {\n\t\ti.second = cnt++;\n\t}\n\tcnt = 0;\n\tfor (auto &i : yp) {\n\t\ti.second = cnt++;\n\t}\n\tvector<set<pair<int, int>>>xx(xp.size());\n\tvector<set<pair<int, int>>>yy(yp.size());\n\tfor (int i = 0; i < N; i++) {\n\t\tx[i] = xp[x[i]];\n\t\ty[i] = yp[y[i]];\n\t\txx[x[i]].insert({ y[i],i });\n\t\tyy[y[i]].insert({ x[i],i });\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tans = max(ans, func(xx, yy, x, y, c, i));\n\t//\tcout << i << \" \" << ans << endl;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3001\nusing namespace std;\ntypedef pair<int,int> P;\nint W,H,n;\nchar mp[N+100][N+100];\n\nint compress(int *x1,int w){\n  vector <int>xs;\n  for(int i=0;i<n;i++)xs.push_back(x1[i]);\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n\n  for(int i=0;i<n;i++)\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n  return xs.size();\n}\n\nint dfs(int x,int y,int dir){\n  if(x<0||y<0||x>=W||y>=H)return 0;\n  int dx[]={0,0,-1,1},dy[]={-1,1,0,0};\n  char ch=mp[y][x];\n  mp[y][x]=0;\n\n  if(ch=='^')dir=0;\n  if(ch=='v')dir=1;\n  if(ch=='<')dir=2;\n  if(ch=='>')dir=3;\n  int res= dfs(x+dx[dir],y+dy[dir],dir)+(ch!=0);\n  mp[y][x]=ch;\n  return res;\n}\n\nint main(){\n  cin>>n;\n  int x[N],y[N];\n  char ch[N];\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>ch[i];  \n  W=compress(x,1e9);\n  H=compress(y,1e9);\n  memset(mp,0,sizeof(mp));\n  for(int i=0;i<n;i++)mp[y[i]][x[i]]=ch[i];\n\n  int ans=0;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      if(mp[i][j]!=0)ans=max(ans,dfs(j,i,0));\n  cout <<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n  \n#define MAX_N 3005\nint n;\nint px[MAX_N],py[MAX_N];\nchar ch[MAX_N];\n  \nint solve(int si){\n  bool used[MAX_N]={};\n  set< P > sx[MAX_N],sy[MAX_N];\n  for(int i=0;i<n;i++){\n    if(i==si)continue;\n    sx[ px[i] ].insert( P(py[i],i) );\n    sy[ py[i] ].insert( P(px[i],i) );\n  }\n  int res=1;\n  int x=px[si],y=py[si];\n  char dir=ch[si];\n  \n  set< P > :: iterator it;\n  while(1){\n    P next;\n    if(dir=='v'){\n      it= sx[x].lower_bound( P(y,0) );\n      if(it==sx[x].end())break;\n      next=*it;\n    }else if(dir=='^'){\n      it= sx[x].lower_bound( P(y,0) );\n      if(it==sx[x].begin())break;\n      it--;\n      next=*it;\n    }else if(dir=='>'){\n      it= sy[y].lower_bound( P(x,0) );\n      if(it==sy[y].end())break;\n      next=*it;      \n    }else if(dir=='<'){\n      it= sy[y].lower_bound( P(x,0) );\n      if(it==sy[y].begin())break;\n      it--;\n      next=*it;\n    }\n    res++;\n    int id=next.second;\n    x=px[id];\n    y=py[id];\n    dir=ch[id];\n    sx[ x ].erase(P(y,id));\n    sy[ y ].erase(P(x,id));\n  }\n  return res;\n}\n  \nint main(){\n  vector<int> X,Y;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>px[i]>>py[i]>>ch[i];\n    X.push_back(px[i]);\n    Y.push_back(py[i]);\n  }\n  sort(X.begin(),X.end());\n  sort(Y.begin(),Y.end());\n  X.erase(unique(X.begin(),X.end()),X.end());\n  Y.erase(unique(Y.begin(),Y.end()),Y.end());\n  \n  for(int i=0;i<n;i++){\n    px[i]=lower_bound(X.begin(),X.end(),px[i])-X.begin();\n    py[i]=lower_bound(Y.begin(),Y.end(),py[i])-Y.begin();\n  }\n  \n  \n  \n  int ans=0;\n  for(int i=0;i<n;i++){\n    ans=max(ans,solve(i));\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 3000\n\nenum DIR{\n\tNorth,\n\tEast,\n\tSouth,\n\tWest,\n};\n\nstruct Info{\n\tint x,y;\n\tDIR dir;\n};\n\nstruct Data{\n\tint index;\n\tDIR dir;\n\tbool exist,visited;\n};\n\nstruct State{\n\tvoid set(int arg_y,int arg_x,DIR arg_dir){\n\t\ty = arg_y;\n\t\tx = arg_x;\n\t\tdir = arg_dir;\n\t}\n\tint x,y;\n\tDIR dir;\n};\n\nint N;\nmap<int,int> X_MAP,Y_MAP;\nvector<int> Y,X;\nint ADJ[NUM][4];\nbool visited[NUM];\nInfo info[NUM];\nData data[NUM][NUM]; //座標圧縮した2次元フィールド\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tchar buf[2];\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %s\",&info[i].x,&info[i].y,buf);\n\t\tX.push_back(info[i].x);\n\t\tY.push_back(info[i].y);\n\t\tswitch(buf[0]){\n\t\tcase '^':\n\t\t\tinfo[i].dir = North;\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tinfo[i].dir = East;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tinfo[i].dir = South;\n\t\t\tbreak;\n\t\tcase '<':\n\t\t\tinfo[i].dir = West;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsort(X.begin(),X.end());\n\tsort(Y.begin(),Y.end());\n\n\tX.erase(unique(X.begin(),X.end()),X.end());\n\tY.erase(unique(Y.begin(),Y.end()),Y.end());\n\n\t//座標圧縮\n\tfor(int i = 0; i < X.size(); i++){\n\t\tX_MAP[X[i]] = i;\n\t}\n\tfor(int i = 0; i < Y.size(); i++){\n\t\tY_MAP[Y[i]] = i;\n\t}\n\n\tint size_X = (int)X.size(),size_Y = (int)Y.size();\n\n\tfor(int i = 0; i < size_X; i++){\n\t\tfor(int k = 0; k < size_Y; k++)data[i][k].exist = false;\n\t}\n\n\t//圧縮済座標上に力点を配置\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < 4; k++){\n\t\t\tADJ[i][k] = -1; //隣接している力点のインデックス\n\t\t}\n\n\t\tdata[Y_MAP[info[i].y]][X_MAP[info[i].x]].exist = true;\n\t\tdata[Y_MAP[info[i].y]][X_MAP[info[i].x]].dir = info[i].dir;\n\t\tdata[Y_MAP[info[i].y]][X_MAP[info[i].x]].index = i;\n\t}\n\n\t//隣接リストを作成する\n\tfor(int row = 0; row < size_Y; row++){\n\t\tfor(int col = 0; col < size_X; col++){\n\t\t\tif(data[row][col].exist == false)continue;\n\n\t\t\t//北\n\t\t\tfor(int tmp_row = row-1; tmp_row >= 0; tmp_row--){\n\t\t\t\tif(data[tmp_row][col].exist){\n\t\t\t\t\tADJ[data[row][col].index][North] = data[tmp_row][col].index;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//東\n\t\t\tfor(int tmp_col = col+1; tmp_col <= size_X-1; tmp_col++){\n\t\t\t\tif(data[row][tmp_col].exist){\n\t\t\t\t\tADJ[data[row][col].index][East] = data[row][tmp_col].index;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//南\n\t\t\tfor(int tmp_row = row+1; tmp_row <= size_Y-1; tmp_row++){\n\t\t\t\tif(data[tmp_row][col].exist){\n\t\t\t\t\tADJ[data[row][col].index][South] = data[tmp_row][col].index;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//西\n\t\t\tfor(int tmp_col = col-1; tmp_col >= 0; tmp_col--){\n\t\t\t\tif(data[row][tmp_col].exist){\n\t\t\t\t\tADJ[data[row][col].index][West] = data[row][tmp_col].index;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tint tmp_count,next_index;\n\tDIR dir;\n\n\tfor(int start = 0; start < N; start++){\n\t\tfor(int i = 0; i < N; i++)visited[i] = false;\n\t\tvisited[start] = true;\n\n\t\tdir = info[start].dir;\n\n\t\ttmp_count = 1;\n\t\tnext_index = start;\n\n\t\twhile(true){\n\n\t\t\tswitch(dir){\n\t\t\tcase North:\n\t\t\t\twhile(next_index != -1 && visited[next_index] == true){\n\t\t\t\t\tnext_index = ADJ[next_index][North];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase East:\n\t\t\t\twhile(next_index != -1 && visited[next_index] == true){\n\t\t\t\t\tnext_index = ADJ[next_index][East];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase South:\n\t\t\t\twhile(next_index != -1 && visited[next_index] == true){\n\t\t\t\t\tnext_index = ADJ[next_index][South];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase West:\n\t\t\t\twhile(next_index != -1 && visited[next_index] == true){\n\t\t\t\t\tnext_index = ADJ[next_index][West];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(next_index == -1)break;\n\n\t\t\tdir = info[next_index].dir;\n\t\t\tvisited[next_index] = true;\n\n\t\t\ttmp_count++;\n\t\t}\n\n\t\tans = max(ans,tmp_count);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3001\nusing namespace std;\ntypedef pair<int,int> P;\nint W,H,n;\nchar mp[N+100][N+100];\n\nint compress(int *x1,int w){\n  vector <int>xs;\n  for(int i=0;i<n;i++)\n    for(int d=-1;d<=1;d++){\n      int tx1=x1[i]+d;\n      if(0<=tx1&&tx1<=w)xs.push_back(tx1);\n    }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  for(int i=0;i<n;i++)\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n  return xs.size();\n}\n\nint dfs(int x,int y,int dir){\n  if(x<0||y<0||x>=W||y>=H)return 0;\n  int dx[]={0,0,-1,1},dy[]={-1,1,0,0};\n  char ch=mp[y][x];\n  mp[y][x]=0;\n  if(ch=='^')dir=0;\n  else if(ch=='v')dir=1;\n  else if(ch=='<')dir=2;\n  else if(ch=='>')dir=3;\n  return dfs(x+dx[dir],y+dy[dir],dir)+1;\n}\n\nint main(){\n  cin>>n;\n  int x[N],y[N];\n  char ch[N];\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>ch[i];  \n  W=compress(x,1e9)-1;\n  H=compress(y,1e9)-1;\n  memset(mp,0,sizeof(mp));\n  for(int i=0;i<n;i++)mp[y[i]][x[i]]=ch[i];\n\n  int ans=0;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      if(mp[i][j]!=0)ans=max(ans,dfs(j,i,0));\n  cout <<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nmap<int,set<int> > xx,yy;\nmap<pint,char> d;\nint x[3001],y[3001];\nconst int INF=1000100010;\nint main(){\n    int n;\n    cin>>n;\n    char c;\n    rep(i,n){\n        cin>>x[i]>>y[i]>>c;\n        xx[x[i]].insert(y[i]);\n        yy[y[i]].insert(x[i]);\n        d[pint(x[i],y[i])]=c;\n    }\n    for(auto it:xx){\n        it.second.insert(INF);\n        it.second.insert(-INF);\n        yy[it.first].insert(INF);\n        yy[it.first].insert(-INF);\n    }\n    for(auto it:yy){\n        it.second.insert(INF);\n        it.second.insert(-INF);\n        xx[it.first].insert(INF);\n        xx[it.first].insert(-INF);\n    }\n    int mx=0;\n    rep(i,n){\n        int cnt=0;\n        int tx=x[i],ty=y[i];\n        map<int,set<int> > sx=xx,sy=yy;\n        while(1){\n            ++cnt;\n            sx[tx].erase(ty),sy[ty].erase(tx);\n            char tc=d[pint(tx,ty)];\n            if(tc==0) break;\n            if(tc=='v'){\n                ty=*sx[tx].lower_bound(ty);\n            }\n            else if(tc=='^'){\n                auto p=sx[tx].lower_bound(ty);\n                --p;\n                ty=*p;\n            }\n            else if(tc=='<'){\n                auto p=sy[ty].lower_bound(tx);\n                --p;\n                tx=*p;\n\n            }\n            else{\n                tx=*sy[ty].lower_bound(tx);\n            }\n            if(abs(tx)==INF||abs(ty)==INF) break;\n        }\n        mx=max(mx,cnt);\n    }\n    cout<<mx<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int> x(n),y(n);\n    vector<char> d(n);\n    map<int,int> xconv, yconv;\n    for(int i=0; i<n; i++){\n        cin >> x[i] >> y[i] >> d[i];\n        xconv[x[i]] = 0;\n        yconv[y[i]] = 0;\n    }\n    \n    int idx=0;\n    for(auto &p: xconv) p.second = idx++;\n    idx = 0;\n    for(auto &p: yconv) p.second = idx++;\n    \n    vector<map<int,char>> xmap(n), ymap(n);\n    for(int i=0; i<n; i++){\n        xmap[xconv[x[i]]][yconv[y[i]]] = d[i];\n        ymap[yconv[y[i]]][xconv[x[i]]] = d[i];\n    }\n\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        auto xx=xmap, yy=ymap;\n        int cx=xconv[x[i]], cy=yconv[y[i]];\n        int sub=0;\n        while(1){\n            sub++;\n            char dir = xx[cx][cy];\n            xx[cx].erase(cy);\n            yy[cy].erase(cx);\n            if(dir == '>'){\n                auto itr = yy[cy].lower_bound(cx);\n                if(itr == yy[cy].end()) break;\n                cx = itr->first;\n            }\n            if(dir == '<'){\n                auto itr = yy[cy].lower_bound(cx);\n                if(itr == yy[cy].begin()) break;\n                itr--;\n                cx = itr->first;\n            }\n            if(dir == 'v'){\n                auto itr = xx[cx].lower_bound(cy);\n                if(itr == xx[cx].end()) break;\n                cy = itr->first;\n            }\n            if(dir == '^'){\n                auto itr = xx[cx].lower_bound(cy);\n                if(itr == xx[cx].begin()) break;\n                itr--;\n                cy = itr->first;\n            }\n        }\n        ans = max(ans, sub);\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3001\nusing namespace std;\nint w,h;\nint dx[]={0,1,0,-1};//^>v<\nint dy[]={-1,0,1,0};\nvector<int> X,Y,d;\nmap<int,int> x,y;\n\n\nint compless(vector<int> A,map<int,int> &M){\n  sort(A.begin(),A.end());\n  int c=0;\n  for(int i=0;i<A.size();i++)if(!M.count(A[i]))M[A[i]]=c++;\n  return c;\n}\n\n\nint calc(int y,int x,vector<vector<int> >&mp){\n  vector<vector<int> > used(h,vector<int>(w,0));\n  int res=0;\n  while(1){\n    res++;\n    int i=mp[y][x];\n    //mp[y][x]=-1;\n    while(1){\n      y+=dy[i];\n      x+=dx[i];\n      if(y<0||x<0||x>=w||y>=h)return res;\n      if(!used[y][x]++&&mp[y][x]!=-1)break;;\n    }\n  }\n  assert(0);\n}\n\nint main(){\n  int n;\n  cin>>n;\n  X.resize(n),Y.resize(n),d.resize(n);\n  for(int i=0;i<n;i++){\n    char ch;\n    cin>>X[i]>>Y[i]>>ch;\n    if(ch=='^')d[i]=0;\n    if(ch=='>')d[i]=1;\n    if(ch=='v')d[i]=2;\n    if(ch=='<')d[i]=3;\n  }\n  h=compless(Y,y);\n  w=compless(X,x);\n  vector<vector<int> >mp(h,vector<int>(w,-1));\n  for(int i=0;i<X.size();i++)mp[y[Y[i]]][x[X[i]]]=d[i];\n\n  int ans=1;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j]!=-1)ans=max(ans,calc(i,j,mp));\n\n  cout <<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 3003\n#define inf 1<<30\n#define linf 1e16\n#define eps (1e-8)\n#define mod 1000000007\n#define pi acos(-1)\n#define phi (1.0+sqrt(5))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nint n;\nvector<pii> e[MAX]; \nint a[MAX],b[MAX];\nstring c[MAX];\nbool used[MAX];\n\nint dfs(int v){\n  used[v]=true;\n  pair<int,int> m(inf,inf);\n  FOR(i,0,e[v].size()){\n    if(!used[e[v][i].s])m=min(m,e[v][i]);\n  }\n  if(m.f==inf)return 1;\n  return 1+dfs(m.s);\n}\n\nint solve(){\n  int res=0;\n  FOR(i,0,n){\n    FOR(j,0,n){\n      if(i==j)continue;\n      if(c[i]==\">\" && b[i]==b[j] && a[i]<a[j])e[i].pb(mp(a[j]-a[i],j));\n      if(c[i]==\"<\" && b[i]==b[j] && a[j]<a[i])e[i].pb(mp(a[i]-a[j],j));\n      if(c[i]==\"v\" && a[i]==a[j] && b[i]<b[j])e[i].pb(mp(b[j]-b[i],j));\n      if(c[i]==\"^\" && a[i]==a[j] && b[j]<b[i])e[i].pb(mp(b[i]-b[j],j));\n    }\n  }\n  FOR(i,0,n){\n    fill(used,used+MAX,false);\n    res=max(res,dfs(i));\n  }\n  return res;\n}\n\nint main()\n{\n  cin>>n;\n  FOR(i,0,n)cin>>a[i]>>b[i]>>c[i];\n  cout<<solve()<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n \n#define MAX_N 3005\nint n;\nint px[MAX_N],py[MAX_N];\nchar ch[MAX_N];\n \nint solve(int si){\n  bool used[MAX_N]={};\n  set< P > sx[MAX_N],sy[MAX_N];\n  for(int i=0;i<n;i++){\n    if(i==si)continue;\n    sx[ px[i] ].insert( P(py[i],i) );\n    sy[ py[i] ].insert( P(px[i],i) );\n  }\n  int res=1;\n  int x=px[si],y=py[si];\n  char dir=ch[si];\n \n  set< P > :: iterator it;\n  while(1){\n    P next;\n    if(dir=='v'){\n      it= sx[x].lower_bound( P(y,0) );\n      if(it==sx[x].end())break;\n      next=*it;\n    }else if(dir=='^'){\n      it= sx[x].lower_bound( P(y,0) );\n      if(it==sx[x].begin())break;\n      it--;\n      next=*it;\n    }else if(dir=='>'){\n      it= sy[y].lower_bound( P(x,0) );\n      if(it==sy[y].end())break;\n      next=*it;      \n    }else if(dir=='<'){\n      it= sy[y].lower_bound( P(x,0) );\n      if(it==sy[y].begin())break;\n      it--;\n      next=*it;\n    }\n    res++;\n    int id=next.second;\n    x=px[id];\n    y=py[id];\n    dir=ch[id];\n    sx[ x ].erase(P(y,id));\n    sy[ y ].erase(P(x,id));\n  }\n  return res;\n}\n \nint main(){\n  vector<int> X,Y;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>px[i]>>py[i]>>ch[i];\n    X.push_back(px[i]);\n    Y.push_back(py[i]);\n  }\n  sort(X.begin(),X.end());\n  sort(Y.begin(),Y.end());\n  X.erase(unique(X.begin(),X.end()),X.end());\n  Y.erase(unique(Y.begin(),Y.end()),Y.end());\n \n  for(int i=0;i<n;i++){\n    px[i]=lower_bound(X.begin(),X.end(),px[i])-X.begin();\n    py[i]=lower_bound(Y.begin(),Y.end(),py[i])-Y.begin();\n  }\n \n \n \n  int ans=0;\n  for(int i=0;i<n;i++){\n    ans=max(ans,solve(i));\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3001\nusing namespace std;\nint w,h;\nint dx[]={0,1,0,-1};//^>v<\nint dy[]={-1,0,1,0};\nvector<int> X,Y,d;\nmap<int,int> x,y;\nint mp[N][N];\n\nint compless(vector<int> A,map<int,int> &M){\n  sort(A.begin(),A.end());\n  int c=0;\n  for(int i=0;i<A.size();i++)if(!M.count(A[i]))M[A[i]]=c++;\n  return c;\n}\n\nint calc(int y,int x){\n  vector<vector<bool> > used(h,vector<bool>(w,0));\n  int res=0;\n  while(1){\n    res++;\n    int i=mp[y][x];\n    used[y][x]=1;\n    while(1){\n      y+=dy[i],x+=dx[i];\n      if(y<0||x<0||x>=w||y>=h)return res;\n      if(mp[y][x]!=-1&&!used[y][x])break;\n    }\n  }\n  assert(0);\n}\n\nint main(){\n  int n;\n  cin>>n;\n  X.resize(n),Y.resize(n),d.resize(n);\n  for(int i=0;i<n;i++){\n    char ch;\n    cin>>X[i]>>Y[i]>>ch;\n    if(ch=='^')d[i]=0;\n    if(ch=='>')d[i]=1;\n    if(ch=='v')d[i]=2;\n    if(ch=='<')d[i]=3;\n  }\n  h=compless(Y,y);\n  w=compless(X,x);\n  \n  memset(mp,-1,sizeof(mp));\n  for(int i=0;i<X.size();i++)mp[y[Y[i]]][x[X[i]]]=d[i];\n  int ans=1;\n  for(int i=0;i<n;i++)ans=max(ans,calc(y[Y[i]],x[X[i]]));\n  cout <<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nvector<int>v;\nint x[3333],y[3333],n,ans,c;\nchar s[3333];\nmap<P,char>A;\nmap<int,int>M;\nmap<char,int>Dir;\nbool used[3001][3001];\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\n\nint get(int idx){\n    memset(used,0,sizeof(used));\n    int res=1,d;\n    int X=x[idx];\n    int Y=y[idx];\n    d=Dir[A[P(X,Y)]];\n    used[X][Y]=1;\n    while(1){\n        X+=dx[d];\n        Y+=dy[d];\n        if(X<0||Y<0||X>3000||Y>3000)break;\n        if(used[X][Y])continue;\n        if(A.count(P(X,Y))){\n            used[X][Y]=1;\n            d=Dir[A[P(X,Y)]];\n            res++;\n        }\n    }\n    return res;\n}\n\nint main(){\n    Dir['^']=0;\n    Dir['>']=1;\n    Dir['v']=2;\n    Dir['<']=3;\n    cin>>n;\n    r(i,n){\n        cin>>x[i]>>y[i]>>s[i];\n        v.push_back(x[i]);\n        v.push_back(y[i]);\n    }\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n    r(i,v.size())M[v[i]]=c++;\n    r(i,n){\n        x[i]=M[x[i]];\n        y[i]=M[y[i]];\n        A[P(x[i],y[i])]=s[i];\n    }\n    r(i,n)ans=max(ans,get(i));\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst string D = \"^>v<\";\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 0};\nconst int inf = 1 << 25;\nint fld[3000][3000], w, h;\nint ans;\n\n\nvoid compress(vector<int>& vec)\n{\n  vector<int> temp = vec;\n  sort(temp.begin(), temp.end());\n  temp.erase(unique(temp.begin(), temp.end()), temp.end());\n  for(int i = 0; i < vec.size(); i++){\n    vec[i] = find(temp.begin(), temp.end(), vec[i]) - temp.begin();\n  }\n}\n\nint solve(int x, int y, int d)\n{\n  if(x < 0 || w < x || y < 0 || h < y) return 0;\n  int nx = x + dx[d], ny = y + dy[d], nd = d;\n  if(0 <= nx && nx <= w && 0 <= ny && ny <= h && fld[ny][nx] != -1) nd = fld[ny][nx];\n  int hoge = fld[y][x];\n  fld[y][x] = -1;\n  int ret = solve(nx, ny, nd) + (hoge != -1);\n  return ret;\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n  vector<int> ix, iy, id;\n  for(int i = 0; i < n; i++){\n    int x, y; char d;\n    cin >> x >> y >> d;\n    ix.push_back(x);\n    iy.push_back(y);\n    id.push_back(D.find(d));\n  }\n  compress(ix);\n  compress(iy);\n  w = *max_element(ix.begin(), ix.end()), h = *max_element(iy.begin(), iy.end());\n  ans = 0;\n  for(int i = 0; i < n; i++){\n    for(int j = 0; j < n; j++) fld[iy[j]][ix[j]] = id[j];\n    ans = max(ans, solve(ix[i], iy[i], id[i]));\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 3003\n#define inf (int)(1e9+1)\n#define linf 1e16\n#define eps (1e-8)\n#define mod 1000000007\n#define pi acos(-1)\n#define phi (1.0+sqrt(5))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nint n;\nvector<pair<ll,int>> e[MAX]; \nint a[MAX],b[MAX];\nstring c[MAX];\nbool used[MAX];\n\nint dfs(int v){\n  used[v]=true;\n  pair<ll,int> m(linf,inf);\n  FOR(i,0,e[v].size()){\n    if(!used[e[v][i].s])m=min(m,e[v][i]);\n  }\n  if(m.s==inf)return 1;\n  return 1+dfs(m.s);\n}\n\nint solve(){\n  int res=0;\n  FOR(i,0,n){\n    FOR(j,0,n){\n      if(i==j)continue;\n      if(c[i]==\">\" && b[i]==b[j] && a[i]<a[j])e[i].pb(mp(a[j]-a[i],j));\n      if(c[i]==\"<\" && b[i]==b[j] && a[j]<a[i])e[i].pb(mp(a[i]-a[j],j));\n      if(c[i]==\"v\" && a[i]==a[j] && b[i]<b[j])e[i].pb(mp(b[j]-b[i],j));\n      if(c[i]==\"^\" && a[i]==a[j] && b[j]<b[i])e[i].pb(mp(b[i]-b[j],j));\n    }\n  }\n  FOR(i,0,n){\n    fill(used,used+MAX,false);\n    res=max(res,dfs(i));\n  }\n  return res;\n}\n\nint main()\n{\n  cin>>n;\n  FOR(i,0,n)cin>>a[i]>>b[i]>>c[i];\n  cout<<solve()<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 3000\n\nenum DIR{\n\tNorth,\n\tEast,\n\tSouth,\n\tWest,\n};\n\nstruct Info{\n\tint x,y;\n\tDIR dir;\n};\n\nstruct Data{\n\tint index;\n\tDIR dir;\n\tbool exist,visited;\n};\n\nstruct State{\n\tvoid set(int arg_y,int arg_x,DIR arg_dir){\n\t\ty = arg_y;\n\t\tx = arg_x;\n\t\tdir = arg_dir;\n\t}\n\tint x,y;\n\tDIR dir;\n};\n\nint N;\nmap<int,int> X_MAP,Y_MAP;\nvector<int> Y,X;\nint ADJ[NUM][4];\nbool visited[NUM];\nInfo info[NUM];\nData data[NUM][NUM]; //座標圧縮した2次元フィールド\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tchar buf[2];\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %s\",&info[i].x,&info[i].y,buf);\n\t\tX.push_back(info[i].x);\n\t\tY.push_back(info[i].y);\n\t\tswitch(buf[0]){\n\t\tcase '^':\n\t\t\tinfo[i].dir = North;\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tinfo[i].dir = East;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tinfo[i].dir = South;\n\t\t\tbreak;\n\t\tcase '<':\n\t\t\tinfo[i].dir = West;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsort(X.begin(),X.end());\n\tsort(Y.begin(),Y.end());\n\n\tX.erase(unique(X.begin(),X.end()),X.end());\n\tY.erase(unique(Y.begin(),Y.end()),Y.end());\n\n\t//座標圧縮\n\tfor(int i = 0; i < X.size(); i++){\n\t\tX_MAP[X[i]] = i;\n\t}\n\tfor(int i = 0; i < Y.size(); i++){\n\t\tY_MAP[Y[i]] = i;\n\t}\n\n\tint size_X = (int)X.size(),size_Y = (int)Y.size();\n\n\tfor(int i = 0; i < size_X; i++){\n\t\tfor(int k = 0; k < size_Y; k++)data[i][k].exist = false;\n\t}\n\n\t//圧縮済座標上に力点を配置\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < 4; k++){\n\t\t\tADJ[i][k] = -1; //隣接している力点のインデックス\n\t\t}\n\n\t\tdata[Y_MAP[info[i].y]][X_MAP[info[i].x]].exist = true;\n\t\tdata[Y_MAP[info[i].y]][X_MAP[info[i].x]].dir = info[i].dir;\n\t\tdata[Y_MAP[info[i].y]][X_MAP[info[i].x]].index = i;\n\t}\n\n\t//隣接リストを作成する\n\tfor(int row = 0; row < size_Y; row++){\n\t\tfor(int col = 0; col < size_X; col++){\n\t\t\tif(data[row][col].exist == false)continue;\n\n\t\t\t//北\n\t\t\tfor(int tmp_row = row-1; tmp_row >= 0; tmp_row--){\n\t\t\t\tif(data[tmp_row][col].exist){\n\t\t\t\t\tADJ[data[row][col].index][North] = data[tmp_row][col].index;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//東\n\t\t\tfor(int tmp_col = col+1; tmp_col <= size_X-1; tmp_col++){\n\t\t\t\tif(data[row][tmp_col].exist){\n\t\t\t\t\tADJ[data[row][col].index][East] = data[row][tmp_col].index;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//南\n\t\t\tfor(int tmp_row = row+1; tmp_row <= size_Y-1; tmp_row++){\n\t\t\t\tif(data[tmp_row][col].exist){\n\t\t\t\t\tADJ[data[row][col].index][South] = data[tmp_row][col].index;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//西\n\t\t\tfor(int tmp_col = col-1; tmp_col >= 0; tmp_col--){\n\t\t\t\tif(data[row][tmp_col].exist){\n\t\t\t\t\tADJ[data[row][col].index][West] = data[row][tmp_col].index;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tint tmp_count,next_index;\n\tDIR dir;\n\n\tfor(int start = 0; start < N; start++){\n\t\tfor(int i = 0; i < N; i++)visited[i] = false;\n\t\tvisited[start] = true;\n\n\t\tdir = info[start].dir;\n\n\t\ttmp_count = 1;\n\t\tnext_index = start;\n\n\t\twhile(true){\n\n\t\t\tswitch(dir){\n\t\t\tcase North:\n\t\t\t\twhile(next_index != -1 && visited[next_index] == true){\n\t\t\t\t\tnext_index = ADJ[next_index][North];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase East:\n\t\t\t\twhile(next_index != -1 && visited[next_index] == true){\n\t\t\t\t\tnext_index = ADJ[next_index][East];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase South:\n\t\t\t\twhile(next_index != -1 && visited[next_index] == true){\n\t\t\t\t\tnext_index = ADJ[next_index][South];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase West:\n\t\t\t\twhile(next_index != -1 && visited[next_index] == true){\n\t\t\t\t\tnext_index = ADJ[next_index][West];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(next_index == -1)break;\n\n\t\t\tdir = info[next_index].dir;\n\t\t\tvisited[next_index] = true;\n\n\t\t\ttmp_count++;\n\t\t}\n\n\t\tans = max(ans,tmp_count);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3001\nusing namespace std;\nint w,h;\nint dx[]={0,1,0,-1};//^>v<\nint dy[]={-1,0,1,0};\nvector<int> X,Y,d;\nmap<int,int> x,y;\n\n\nint compless(vector<int> A,map<int,int> &M){\n  sort(A.begin(),A.end());\n  int c=0;\n  for(int i=0;i<A.size();i++)if(!M.count(A[i]))M[A[i]]=c++;\n  return c;\n}\n\n\nint calc(int y,int x,vector<vector<int> >&mp){\n  vector<vector<int> > used(h,vector<int>(w,0));\n  int res=0;\n  while(1){\n    res++;\n    int i=mp[y][x];\n    mp[y][x]=-1;\n    while(1){\n      y+=dy[i];\n      x+=dx[i];\n      if(y<0||x<0||x>=w||y>=h)return res;\n      if(!used[y][x]++&&mp[y][x]!=-1)break;;\n    }\n  }\n  assert(0);\n}\n\nint main(){\n  int n;\n  cin>>n;\n  X.resize(n),Y.resize(n),d.resize(n);\n  for(int i=0;i<n;i++){\n    char ch;\n    cin>>X[i]>>Y[i]>>ch;\n    if(ch=='^')d[i]=0;\n    if(ch=='>')d[i]=1;\n    if(ch=='v')d[i]=2;\n    if(ch=='<')d[i]=3;\n  }\n  h=compless(Y,y);\n  w=compless(X,x);\n  vector<vector<int> >mp(h,vector<int>(w,-1));\n  for(int i=0;i<X.size();i++)mp[y[Y[i]]][x[X[i]]]=d[i];\n\n  int ans=1;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j]!=-1)ans=max(ans,calc(i,j,mp));\n\n  cout <<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst string D = \"^>v<\";\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 0};\nconst int inf = 1 << 25;\nint fld[3000][3000], w, h;\nint ans;\n\n\nvoid compress(vector<int>& vec)\n{\n  vector<int> temp = vec;\n  sort(temp.begin(), temp.end());\n  temp.erase(unique(temp.begin(), temp.end()), temp.end());\n  for(int i = 0; i < vec.size(); i++){\n    vec[i] = find(temp.begin(), temp.end(), vec[i]) - temp.begin();\n  }\n}\n\nint solve(int x, int y, int d)\n{\n  if(x < 0 || w < x || y < 0 || h < y) return 0;\n  int nx = x + dx[d], ny = y + dy[d], nd = d;\n  if(0 <= nx && nx <= w && 0 <= ny && ny <= h && fld[ny][nx] != -1) nd = fld[ny][nx];\n  int hoge = fld[y][x];\n  fld[y][x] = -1;\n  int ret = solve(nx, ny, nd) + (hoge != -1);\n  return ret;\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n  vector<int> ix, iy, id;\n  for(int i = 0; i < n; i++){\n    int x, y; char d;\n    cin >> x >> y >> d;\n    ix.push_back(x);\n    iy.push_back(y);\n    id.push_back(D.find(d));\n  }\n  compress(ix);\n  compress(iy);\n  w = *max_element(ix.begin(), ix.end()), h = *max_element(iy.begin(), iy.end());\n  ans = 0;\n  memset(fld, -1, sizeof(fld));\n  /*\n  for(int j = 0; j < n; j++) fld[iy[j]][ix[j]] = id[j];\n  for(int i = 0; i <= h; i++){\n    for(int j = 0; j <= w; j++) printf(\"%2d\", fld[i][j]); \n    cout << endl;\n  }\n  */\n  for(int i = 0; i < n; i++){\n    memset(fld, -1, sizeof(fld));\n    for(int j = 0; j < n; j++) fld[iy[j]][ix[j]] = id[j];\n    ans = max(ans, solve(ix[i], iy[i], id[i]));\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; ++ i)\nusing namespace std;\n\nint x[3010],y[3010],d[3010];\nint init[4][3010];\nint mov[4][3010];\n\n\nint main(void){\n\tint n;\n\tcin >> n;\n\n\t{\n\t\tmap<char,int> dir={{'>',0},{'v',1},{'<',2},{'^',3}};\n\t\trep(i,n){\n\t\t\tchar tmp;\n\t\t\tcin >> x[i] >> y[i] >> tmp;\n\t\t\td[i] = dir[tmp];\n\t\t}\n\t}\n\t\n\n\trep(i,n){\n\t\tint u = -1, l = -1, r = -1 ,b = -1; \n\n\t\trep(j,n){\n\t\t\tif(j==i) continue;\n\n\t\t\tif(x[i] == x[j] and y[j] < y[i]){\n\t\t\t\tif(u == -1 or y[u] < y[j]) {\n\t\t\t\t\tu = j;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(x[i] == x[j] and y[i] < y[j]){\n\t\t\t\tif(b == -1 or y[j] < y[b]) {\n\t\t\t\t\tb = j;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(y[i] == y[j] and x[j] < x[i]){\n\t\t\t\tif(l == -1 or x[l] < x[j]) {\n\t\t\t\t\tl = j;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(y[i] == y[j] and x[i] < x[j]){\n\t\t\t\tif(r == -1 or x[j] < x[r]) {\n\t\t\t\t\tr = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinit[0][i] = r;\n\t\tinit[1][i] = b;\n\t\tinit[2][i] = l;\n\t\tinit[3][i] = u;\n\n\t}\n\n\t/*\n\trep(i,n){\n\t\tcerr << i << \" \";\n\t\trep(j,4) cerr << init[j][i] << \" \";\n\t\tcerr << endl;\n\t}\n\t*/\n\n\tint ans = 0;\n\t\n\trep(s,n){\n\t\trep(i,4)rep(j,n) mov[i][j] = init[i][j];\n\n\t\tint cur = s,num = 0;\n\n\t\twhile(1){\n\t\t\t//cerr << cur << endl;\n\t\t\tif(cur == -1) break;\n\t\t\tnum++;\n\t\t\trep(i,4){\n\t\t\t\tif(mov[(i+2)%4][cur]!=-1){\n\t\t\t\t\t//cerr << i << \" \" << mov[(i+2)%4][cur] << \" \" << mov[i][cur] << endl;\n\t\t\t\t\tmov[i][mov[(i+2)%4][cur]] = mov[i][cur];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint nxt = mov[d[cur]][cur];\n\t\t\trep(i,4) mov[i][cur] = -1;\n\t\t\tcur = nxt;\n\t\t}\n\n\t\tans = max(ans,num);\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<tuple>\nusing namespace std;\nclass BIT {\nprivate:\n\tint size_; vector<int>x;\npublic:\n\tBIT() : size_(0), x(vector<int>()) {};\n\tBIT(int size__) : size_(size__) {\n\t\tx.resize(size__ + 1);\n\t\tfor (int i = 0; i < size__ + 1; i++)x[i] = 0;\n\t}\n\tint size() { return size_; }\n\tvoid add(int r, int pp) {\n\t\twhile (r <= size_) { x[r] += pp; r += r&-r; }\n\t}\n\tint sums(int r) {\n\t\tint cnt1 = 0; while (r >= 1) { cnt1 += x[r]; r -= r&-r; }\n\t\treturn cnt1;\n\t}\n\tint sum(int l, int r) {\n\t\treturn sums(r) - sums(l - 1);//Range [l, r]\n\t}\n};\nint n, x[5000], y[5000], dir[5000];\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\nvector<int>XX, YY, XXX, YYY, XR[3100], YR[3100];//XR=yoko, YR=tate\nvector<tuple<int, int, int>>posit;\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tchar c; cin >> x[i] >> y[i] >> c; swap(x[i], y[i]); XX.push_back(x[i]); YY.push_back(y[i]);\n\t\tif (c == 'v')dir[i] = 0; if (c == '>')dir[i] = 1; if (c == '^')dir[i] = 2; if (c == '<')dir[i] = 3;\n\t}\n\tsort(XX.begin(), XX.end()); sort(YY.begin(), YY.end()); XXX.push_back(XX[0]); YYY.push_back(YY[0]);\n\tfor (int i = 1; i < XX.size(); i++) { if (XX[i - 1] != XX[i])XXX.push_back(XX[i]); }\n\tfor (int i = 1; i < YY.size(); i++) { if (YY[i - 1] != YY[i])YYY.push_back(YY[i]); }\n\tfor (int i = 0; i < n; i++) {\n\t\tint pos1 = lower_bound(XXX.begin(), XXX.end(), x[i]) - XXX.begin(); x[i] = pos1 + 1;\n\t\tint pos2 = lower_bound(YYY.begin(), YYY.end(), y[i]) - YYY.begin(); y[i] = pos2 + 1;\n\t\tXR[x[i]].push_back(y[i]); YR[y[i]].push_back(x[i]);\n\t\tposit.push_back(make_tuple(x[i], y[i], dir[i]));\n\t}\n\tvector<BIT> X(n + 2, BIT(n + 2)), Y(n + 2, BIT(n + 2)); sort(posit.begin(), posit.end());\n\tint maxn = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tvector<tuple<int, int, int>>used;\n\t\tint cx = x[i], cy = y[i], cd = dir[i];\n\t\tfor (int j = 0; j < n; j++) { X[x[j]].add(y[j], 1); Y[y[j]].add(x[j], 1); used.push_back(make_tuple(x[j], y[j], 0)); }\n\t\tbool flag = true; sort(used.begin(), used.end());\n\t\tint cnt2 = 0;\n\t\twhile (true) {\n\t\t\tX[cx].add(cy, -1); Y[cy].add(cx, -1);\n\t\t\tint pos3 = lower_bound(used.begin(), used.end(), make_tuple(cx, cy, 0)) - used.begin();\n\t\t\tget<2>(used[pos3]) = 1;\n\t\t\t//--------------DOWN---------------\n\t\t\tif (cd == 0) {\n\t\t\t\tint L = cx, R = n + 2, M;\n\t\t\t\twhile(true){\n\t\t\t\t\tM = (L + R) / 2;\n\t\t\t\t\tint E1 = Y[cy].sum(cx, M - 1);\n\t\t\t\t\tint E2 = Y[cy].sum(cx, M);\n\t\t\t\t\tif (E1 <= 0 && E2 >= 1) {\n\t\t\t\t\t\tcx = M;\n\t\t\t\t\t\tint pos4 = lower_bound(posit.begin(), posit.end(), make_tuple(cx, cy, 0)) - posit.begin(); cd = get<2>(posit[pos4]); break;\n\t\t\t\t\t}\n\t\t\t\t\tif (E1 >= 1)R = M;\n\t\t\t\t\tif (E2 <= 0)L = M;\n\t\t\t\t\tif (E2 <= 0 && M == n + 1) { flag = false; break; }\n\t\t\t\t}\n\t\t\t}\n\t\t\t//--------------UP---------------\n\t\t\telse if (cd == 2) {\n\t\t\t\tint L = 0, R = cx + 2, M;\n\t\t\t\twhile (true) {\n\t\t\t\t\tM = (L + R) / 2;\n\t\t\t\t\tint E1 = Y[cy].sum(M - 1, cx);\n\t\t\t\t\tint E2 = Y[cy].sum(M, cx);\n\t\t\t\t\tif (E1 >= 1 && E2 <= 0) {\n\t\t\t\t\t\tcx = M - 1;\n\t\t\t\t\t\tint pos4 = lower_bound(posit.begin(), posit.end(), make_tuple(cx, cy, 0)) - posit.begin(); cd = get<2>(posit[pos4]); break;\n\t\t\t\t\t}\n\t\t\t\t\tif (E1 <= 0)R = M;\n\t\t\t\t\tif (E2 >= 1)L = M;\n\t\t\t\t\tif (E1 <= 0 && M == 0) { flag = false; break; }\n\t\t\t\t}\n\t\t\t}\n\t\t\t//--------------RIGHT---------------\n\t\t\telse if (cd == 1) {\n\t\t\t\tint L = cy, R = n + 2, M;\n\t\t\t\twhile (true) {\n\t\t\t\t\tM = (L + R) / 2;\n\t\t\t\t\tint E1 = X[cx].sum(cy, M - 1);\n\t\t\t\t\tint E2 = X[cx].sum(cy, M);\n\t\t\t\t\tif (E1 <= 0 && E2 >= 1) {\n\t\t\t\t\t\tcy = M;\n\t\t\t\t\t\tint pos4 = lower_bound(posit.begin(), posit.end(), make_tuple(cx, cy, 0)) - posit.begin(); cd = get<2>(posit[pos4]); break;\n\t\t\t\t\t}\n\t\t\t\t\tif (E1 >= 1)R = M;\n\t\t\t\t\tif (E2 <= 0)L = M;\n\t\t\t\t\tif (E2 <= 0 && M == n + 1) { flag = false; break; }\n\t\t\t\t}\n\t\t\t}\n\t\t\t//--------------LEFT---------------\n\t\t\telse if (cd == 3) {\n\t\t\t\tint L = 0, R = cy + 2, M;\n\t\t\t\twhile (true) {\n\t\t\t\t\tM = (L + R) / 2;\n\t\t\t\t\tint E1 = X[cx].sum(M - 1, cy);\n\t\t\t\t\tint E2 = X[cx].sum(M, cy);\n\t\t\t\t\tif (E1 >= 1 && E2 <= 0) {\n\t\t\t\t\t\tcy = M - 1;\n\t\t\t\t\t\tint pos4 = lower_bound(posit.begin(), posit.end(), make_tuple(cx, cy, 0)) - posit.begin(); cd = get<2>(posit[pos4]); break;\n\t\t\t\t\t}\n\t\t\t\t\tif (E1 <= 0)R = M;\n\t\t\t\t\tif (E2 >= 1)L = M;\n\t\t\t\t\tif (E1 <= 0 && M == 0) { flag = false; break; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt2++;\n\t\t\tif (flag == false) { break; }\n\t\t}\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint a1 = get<0>(used[j]), a2 = get<1>(used[j]), a3 = get<2>(used[j]);\n\t\t\tif (a3 == 1)continue;\n\t\t\tX[a1].add(a2, -1); Y[a2].add(a1, -1);\n\t\t}\n\t\tmaxn = max(maxn, cnt2);\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 3000\n\nenum DIR{\n\tNorth,\n\tEast,\n\tSouth,\n\tWest,\n};\n\nstruct Info{\n\tint x,y;\n\tDIR dir;\n};\n\nstruct Data{\n\tint x_index,y_index;\n\tDIR dir;\n\tbool exist,visited;\n};\n\nstruct State{\n\tvoid set(int arg_y,int arg_x,DIR arg_dir){\n\t\ty = arg_y;\n\t\tx = arg_x;\n\t\tdir = arg_dir;\n\t}\n\tint x,y;\n\tDIR dir;\n};\n\nint N;\nmap<int,int> X_MAP,Y_MAP;\nvector<int> Y,X,comp_X[NUM],comp_Y[NUM];\nInfo info[NUM];\nData data[NUM][NUM]; //座標圧縮した2次元フィールド\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tchar buf[2];\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %s\",&info[i].x,&info[i].y,buf);\n\t\tX.push_back(info[i].x);\n\t\tY.push_back(info[i].y);\n\t\tswitch(buf[0]){\n\t\tcase '^':\n\t\t\tinfo[i].dir = North;\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tinfo[i].dir = East;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tinfo[i].dir = South;\n\t\t\tbreak;\n\t\tcase '<':\n\t\t\tinfo[i].dir = West;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsort(X.begin(),X.end());\n\tsort(Y.begin(),Y.end());\n\n\tX.erase(unique(X.begin(),X.end()),X.end());\n\tY.erase(unique(Y.begin(),Y.end()),Y.end());\n\n\t//座標圧縮\n\tfor(int i = 0; i < X.size(); i++){\n\t\tX_MAP[X[i]] = i;\n\t}\n\tfor(int i = 0; i < Y.size(); i++){\n\t\tY_MAP[Y[i]] = i;\n\t}\n\n\tint size_X = (int)X.size(),size_Y = (int)Y.size();\n\n\tfor(int i = 0; i < size_X; i++){\n\t\tfor(int k = 0; k < size_Y; k++)data[i][k].exist = false;\n\t}\n\n\t//圧縮済座標上に力点を配置\n\tfor(int i = 0; i < N; i++){\n\t\tdata[Y_MAP[info[i].y]][X_MAP[info[i].x]].exist = true;\n\t\tdata[Y_MAP[info[i].y]][X_MAP[info[i].x]].dir = info[i].dir;\n\n\t\tcomp_Y[Y_MAP[info[i].y]].push_back(X_MAP[info[i].x]); //圧縮後のY座標における、X座標の隣接リスト\n\t\tcomp_X[X_MAP[info[i].x]].push_back(Y_MAP[info[i].y]); //圧縮後のX座標における、Y座標の隣接リスト\n\t}\n\n\tfor(int i = 0; i < size_Y; i++)sort(comp_Y[i].begin(),comp_Y[i].end());\n\tfor(int i = 0; i < size_X; i++)sort(comp_X[i].begin(),comp_X[i].end());\n\n\t//圧縮後の座標系における、隣接リストでのインデックスを計算する\n\tint left,right,m;\n\tfor(int row = 0; row < size_Y; row++){\n\t\tfor(int col = 0; col < size_X; col++){\n\t\t\tif(data[row][col].exist == false)continue;\n\n\t\t\t//y == rowにおける、x座標のインデックス\n\t\t\tleft = 0,right = comp_Y[row].size()-1,m = (left+right)/2;\n\t\t\twhile(left <= right){\n\t\t\t\tif(comp_Y[row][m] == col){\n\t\t\t\t\tdata[row][col].y_index = m;\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(comp_Y[row][m] > col){\n\t\t\t\t\tright = m-1;\n\t\t\t\t}else{\n\t\t\t\t\tleft = m+1;\n\t\t\t\t}\n\t\t\t\tm = (left+right)/2;\n\t\t\t}\n\n\t\t\t//x == colにおける、y座標のインデックス\n\t\t\tleft = 0,right = comp_X[col].size()-1,m = (left+right)/2;\n\t\t\twhile(left <= right){\n\t\t\t\tif(comp_X[col][m] == row){\n\t\t\t\t\tdata[row][col].x_index = m;\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(comp_X[col][m] > row){\n\t\t\t\t\tright = m-1;\n\t\t\t\t}else{\n\t\t\t\t\tleft = m+1;\n\t\t\t\t}\n\t\t\t\tm = (left+right)/2;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint ans = 0;\n\tint next_y,next_x;\n\tState state;\n\n\t//初期位置を全探索\n\tfor(int start = 0; start < N; start++){\n\n\t\tfor(int i = 0; i < size_X; i++){\n\t\t\tfor(int k = 0; k < size_Y; k++)data[i][k].visited = false;\n\t\t}\n\n\t\tint tmp_count = 1;\n\t\tdata[Y_MAP[info[start].y]][X_MAP[info[start].x]].visited = true;\n\t\tstate.set(Y_MAP[info[start].y],X_MAP[info[start].x],info[start].dir);\n\n\t\twhile(true){\n\n\t\t\tnext_y = BIG_NUM;\n\t\t\tnext_x = BIG_NUM;\n\n\t\t\t//次の力点を探す\n\t\t\tswitch(state.dir){\n\t\t\tcase North:\n\t\t\t\tfor(int tmp_y = data[state.y][state.x].x_index-1; tmp_y >= 0; tmp_y--){\n\t\t\t\t\tif(data[comp_X[state.x][tmp_y]][state.x].exist == true && data[comp_X[state.x][tmp_y]][state.x].visited == false){\n\t\t\t\t\t\tnext_y = comp_X[state.x][tmp_y];\n\t\t\t\t\t\tnext_x = state.x;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase East:\n\t\t\t\tfor(int tmp_x = data[state.y][state.x].y_index+1; tmp_x <= comp_Y[state.y].size()-1; tmp_x++){\n\t\t\t\t\tif(data[state.y][comp_Y[state.y][tmp_x]].exist == true && data[state.y][comp_Y[state.y][tmp_x]].visited == false){\n\t\t\t\t\t\tnext_y = state.y;\n\t\t\t\t\t\tnext_x = comp_Y[state.y][tmp_x];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase South:\n\t\t\t\tfor(int tmp_y = data[state.y][state.x].x_index+1; tmp_y <= comp_X[state.x].size()-1; tmp_y++){\n\t\t\t\t\tif(data[comp_X[state.x][tmp_y]][state.x].exist == true && data[comp_X[state.x][tmp_y]][state.x].visited == false){\n\t\t\t\t\t\tnext_y = comp_X[state.x][tmp_y];\n\t\t\t\t\t\tnext_x = state.x;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase West:\n\t\t\t\tfor(int tmp_x = data[state.y][state.x].y_index-1; tmp_x >= 0; tmp_x--){\n\t\t\t\t\tif(data[state.y][comp_Y[state.y][tmp_x]].exist == true && data[state.y][comp_Y[state.y][tmp_x]].visited == false){\n\t\t\t\t\t\tnext_y = state.y;\n\t\t\t\t\t\tnext_x = comp_Y[state.y][tmp_x];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\n\t\t\tif(next_y == BIG_NUM || next_x == BIG_NUM)break;\n\n\t\t\tdata[next_y][next_x].visited = true;\n\t\t\tstate.set(next_y,next_x,data[next_y][next_x].dir);\n\t\t\ttmp_count++;\n\t\t}\n\n\t\tans = max(ans,tmp_count);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pic = pair<int,char>;\n\nint main(){\n    int n;\n    cin >>n;\n\n    vector<int> x(n),y(n);\n    vector<char> d(n);\n\n    vector<int> ux,uy;\n    rep(i,n){\n        cin >>x[i] >>y[i] >>d[i];\n        ux.pb(x[i]);\n        uy.pb(y[i]);\n    }\n\n    sort(all(ux));\n    ux.erase(unique(all(ux)), ux.end());\n    sort(all(uy));\n    uy.erase(unique(all(uy)), uy.end());\n\n    int X = ux.size(), Y = uy.size();\n\n    rep(i,n){\n        x[i] = lower_bound(all(ux), x[i]) - ux.begin();\n        y[i] = lower_bound(all(uy), y[i]) - uy.begin();\n    }\n\n    // initialize\n    vector<set<pic>> SX(X), SY(Y);\n    rep(i,n){\n        SX[x[i]].insert({y[i],d[i]});\n        SY[y[i]].insert({x[i],d[i]});\n    }\n\n    int ans = 0;\n    rep(i,n){\n        vector<set<pic>> sx(SX), sy(SY);\n\n        int tmp = 0;\n        int cx = x[i], cy = y[i];\n        char cd = d[i];\n        while(1){\n            // remove current position\n            sx[cx].erase({cy,cd});\n            sy[cy].erase({cx,cd});\n            ++tmp;\n\n            if(cd == '>'){\n                auto itr = sy[cy].lower_bound({cx,cd});\n                if(itr == sy[cy].end()) break;\n\n                cx = itr->fi;\n                cd = itr->se;\n            }\n            else if(cd == '<'){\n                auto itr = sy[cy].lower_bound({cx,cd});\n                if(itr == sy[cy].begin()) break;\n                --itr;\n                cx = itr->fi;\n                cd = itr->se;\n\n            }\n            else if(cd == 'v'){\n                auto itr = sx[cx].lower_bound({cy,cd});\n                if(itr == sx[cx].end()) break;\n\n                cy = itr->fi;\n                cd = itr->se;\n            }\n            else if(cd == '^'){\n                auto itr = sx[cx].lower_bound({cy,cd});\n                if(itr == sx[cx].begin()) break;\n                --itr;\n                cy = itr->fi;\n                cd = itr->se;\n            }\n            else assert(false);\n        }\n\n        ans = max(ans, tmp);\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<P ,ll> P3;\ntypedef pair<P ,P> PP;\nconst ll MOD = ll(1e9)+7;\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(1e5 + 5);\nconst double EPS = 1e-6;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define SORTR(v) sort((v).rbegin(), (v).rend())\n#define ALL(v) (v).begin(), (v).end()\n\nint n, ans = 1;\nmap<int, set<P> > vx, vy;\nP3 pos[3005];\n\nint main() {\n    cin >> n;\n    REP(i,n){\n        int x, y, dir;\n        char d;\n        cin >> x >> y >> d;\n        if(d == '>') dir = 0;\n        if(d == 'v') dir = 1;\n        if(d == '<') dir = 2;\n        if(d == '^') dir = 3;\n        vx[x].insert({y,dir});\n        vy[y].insert({x,dir});\n        pos[i] = {{x,y},dir};\n    }\n    REP(i,n){\n        auto xs = vx, ys = vy;\n        int px = pos[i].first.first, py = pos[i].first.second, dir = pos[i].second, cnt = 1;\n        while(1){\n            xs[px].erase({py,dir});\n            ys[py].erase({px,dir});\n            if(dir == 0){\n                auto p = ys[py].upper_bound({px,-1});\n                if(p==ys[py].end())break;\n                px = (*p).first;\n                dir = (*p).second;\n                cnt++;\n            }\n            else if(dir == 1){\n                auto p = xs[px].upper_bound({py,-1});\n                if(p==xs[px].end())break;\n                py = (*p).first;\n                dir = (*p).second;\n                cnt++;\n            }\n            else if(dir == 2){\n                if(ys[py].size()==0) break;\n                auto p = ys[py].upper_bound({px,-1});\n                if(p==ys[py].begin())break;\n                p--;\n                px = (*p).first;\n                dir = (*p).second;\n                cnt++;\n            }\n            else if(dir == 3){\n                if(xs[px].size()==0) break;\n                auto p = xs[px].upper_bound({py,-1});\n                if(p==xs[px].begin())break;\n                p--;\n                py = (*p).first;\n                dir = (*p).second;\n                cnt++;\n            }\n        }\n        ans = max(ans, cnt);\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3001\nusing namespace std;\ntypedef pair<int,int> P;\nint W,H,n;\nchar mp[N+100][N+100];\n\nint compress(int *x1,int w){\n  vector <int>xs;\n  for(int i=0;i<n;i++)\n    for(int d=-1;d<=1;d++){\n      int tx1=x1[i]+d;\n      if(0<=tx1&&tx1<=w)xs.push_back(tx1);\n    }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  for(int i=0;i<n;i++)\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n  return xs.size();\n}\n\nint dfs(int x,int y,int dir){\n  if(x<0||y<0||x>=W||y>=H)return 0;\n  int dx[]={0,0,-1,1},dy[]={-1,1,0,0};\n  char ch=mp[y][x];\n  mp[y][x]=0;\n  if(ch=='^')dir=0;\n  else if(ch=='v')dir=1;\n  else if(ch=='<')dir=2;\n  else if(ch=='>')dir=3;\n  int res= dfs(x+dx[dir],y+dy[dir],dir)+(ch!=0);\n  mp[y][x]=ch;\n  return res;\n}\n\nint main(){\n  cin>>n;\n  int x[N],y[N];\n  char ch[N];\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>ch[i];  \n  W=compress(x,1e9)-1;\n  H=compress(y,1e9)-1;\n  memset(mp,0,sizeof(mp));\n  for(int i=0;i<n;i++)mp[y[i]][x[i]]=ch[i];\n\n  int ans=0;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      if(mp[i][j]!=0)ans=max(ans,dfs(j,i,0));\n  cout <<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring tbl = \">v<^\";\n\nstruct P{\n\tint id;\n\tint p[4];\n\tP(){\n\t\tid = -1;\n\t\tmemset(p,-1,sizeof(p));\n\t}\n};\nP ps[3010];\n\n\n\nint dfs(int id){\n\tif( id == -1 ) return 0;\n\tint tmp[4];\n\tmemcpy(tmp,ps[id].p,sizeof(tmp));\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tif(ps[id].p[i] != -1 ){\n\t\n\t\t\tassert( ps[ps[id].p[i]].p[(i+2)%4] == id );\n\t\t\tps[ps[id].p[i]].p[(i+2)%4] = tmp[(i+2)%4];\n\t\t}\n\t}\n\t\n\tint ans = dfs(ps[id].p[ps[id].id]);\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tif( tmp[i] != -1 ){\n\t\t\tassert( ps[tmp[i]].p[(i+2)%4] != id );\n\t\t\tps[tmp[i]].p[(i+2)%4] = id;\n\t\t}\n\t}\n\treturn ans + 1;\n\t\n}\nint main(){\n\tint n;\n\tcin >> n;\n\tmap<int, vector< pair<int,int> > > col,row;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tint x,y;\n\t\tchar c;\n\t\tcin >> x >> y >> c;\n\t\ty*= -1;\n\t\tint id = tbl.find(c);\n\t\tps[i].id = id;\n\t\tcol[x].push_back({y,i});\n\t\trow[y].push_back({x,i});\n\t}\t\t\n\tfor( auto &i : col ) sort(i.second.begin(),i.second.end());\n\tfor( auto &i : row ) sort(i.second.begin(),i.second.end());\n\t\n\tfor( auto &i : col ){\n\t\t\n\t\tauto& seq = i.second;\n\t\t{\n\t\t\tint prv = -1;\n\t\t\tfor(int j = 0 ; j < seq.size() ; j++){\n\t\t\t\tps[seq[j].second].p[1] = prv;\n\t\t\t\tprv = seq[j].second;\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint prv = -1;\n\t\t\tfor(int j = seq.size() - 1 ; j >= 0 ; j--){\n\t\t\t\tps[seq[j].second].p[3] = prv;\n\t\t\t\tprv = seq[j].second;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor( auto &i : row ){\n\t\tauto& seq = i.second;\n\t\t{\n\t\t\tint prv = -1;\n\t\t\tfor(int j = 0 ; j < seq.size() ; j++){\n\t\t\t\tps[seq[j].second].p[2] = prv;\n\t\t\t\tprv = seq[j].second;\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint prv = -1;\n\t\t\tfor(int j = seq.size() - 1 ; j >= 0 ; j--){\n\t\t\t\tps[seq[j].second].p[0] = prv;\n\t\t\t\tprv = seq[j].second;\n\t\t\t}\n\t\t}\n\t}\n\tint answer = 0;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tanswer = max(answer,dfs(i));\n\t\t//cout << i << \" \" << dfs(i) << endl;\n\t}\n\tcout << answer << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> p;\nint main(){\n  int n,gr[2][3000];\n  cin>>n;\n  vector<p> t[2];\n  char d[3000];\n  for(int x,y,i=0;i<n;i++){\n    cin>>x>>y>>d[i];\n    t[0].push_back(p(P(x,y),i));\n    t[1].push_back(p(P(y,x),i));\n  }\n  sort(t[0].begin(),t[0].end());\n  sort(t[1].begin(),t[1].end());  \n  for(int i=0;i<n;i++)\n    gr[0][t[0][i].s]=i,gr[1][t[1][i].s]=i;\n  int ans=0;\n\n  for(int i=0;i<n;i++){\n    bool used[3000]={};\n    int ss=i,k=0;\n     while(1){\n       k++;\n       bool f=0;\n       used[ss]=1;\n\n       if(d[ss]=='v'){\n\t int g=gr[0][ss];\n\t int a=t[0][g].f.f;\n\t while(used[ss]){\n\t   if(++g==n){f=1;break;}\n\t   ss=t[0][g].s;\n\t }\n\t if(f||t[0][gr[0][ss]].f.f!=a)break;\n       }\n\n       if(d[ss]=='^'){\n\t int g=gr[0][ss];\n\t int a=t[0][g].f.f;\n\t while(used[ss]){\n\t   if(!g){f=1;break;}\n\t   ss=t[0][--g].s;\n\t }\n\t if(f||t[0][gr[0][ss]].f.f!=a)break;\n       }\n\n\n       if(d[ss]=='>'){\n\t int g=gr[1][ss];\n\t int a=t[1][g].f.f;\n\t while(used[ss]){\n\t   if(++g==n){f=1;break;}\t  \n\t   ss=t[1][g].s;\n\t }\n\t if(f||t[1][gr[1][ss]].f.f!=a)break;\n       }\n\n\n      if(d[ss]=='<'){\n\tint g=gr[1][ss];\n\tint a=t[1][g].f.f;\n\t while(used[ss]){\n\t   if(!g){f=1;break;}\t  \n\t   ss=t[1][--g].s;\n\t }\n\t if(f||t[1][gr[1][ss]].f.f!=a)break;\n      }\n     }\n     ans=max(ans,k);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 2048\n#define inf 1<<29\n#define linf 1e16\n#define eps (1e-8)\n#define mod 1000000007\n#define pi acos(-1)\n#define phi (1.0+sqrt(5))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nint n;\nvector<pii> e[MAX]; \nint a[MAX],b[MAX];\nstring c[MAX];\nbool used[MAX];\n\nint dfs(int v){\n  int res=1;\n  used[v]=true;\n  FOR(i,0,e[v].size()){\n    int next=e[v][i].s;\n    if(!used[next]){\n      res+=dfs(next);\n      break;\n    }\n  }\n  return res;\n}\n\nint solve(){\n  int res=0;\n  FOR(i,0,n){\n    FOR(j,0,n){\n      if(i==j)continue;\n      if(c[i]==\">\" && b[i]==b[j] && a[i]<a[j])e[i].pb(mp(a[j]-a[i],j));\n      if(c[i]==\"<\" && b[i]==b[j] && a[j]<a[i])e[i].pb(mp(a[i]-a[j],j));\n      if(c[i]==\"v\" && a[i]==a[j] && b[i]<b[j])e[i].pb(mp(b[j]-b[i],j));\n      if(c[i]==\"^\" && a[i]==a[j] && b[j]<b[i])e[i].pb(mp(b[i]-b[j],j));\n    }\n    sort(all(e[i]));\n  }\n  FOR(i,0,n){\n    fill(used,used+MAX,false);\n    res=max(res,dfs(i));\n  }\n  return res;\n}\n\nint main()\n{\n  cin>>n;\n  FOR(i,0,n)cin>>a[i]>>b[i]>>c[i];\n  cout<<solve()<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\nstruct point{\n\tint id;\n\tint a, b;\n\tpoint(){}\n\tpoint(int i, int x, int y){\n\t\tthis->id = i, this->a = x, this->b = y;\n\t}\n\tbool operator<(const point& ope)const{\n\t\treturn a < ope.a || (a == ope.a && b < ope.b);\n\t}\n};\n\nint n;\nint x[3005], y[3005], d[3005];\nint next[3005][4];\npoint XY[3005], YX[3005];\n\nvoid make_link(point p[], int dir)\n{\n\tint prev = 1000000005;\n\tfor(int i = 0; i < n; i++){\n\t\tif(prev == p[i].a){\n\t\t\tnext[p[i-1].id][dir] = p[i].id;\n\t\t}\n\t\telse if(i != 0){\n\t\t\tnext[p[i-1].id][dir] = -1;\n\t\t}\n\t\tprev = p[i].a;\n\t}\n\tnext[p[n-1].id][dir] = -1;\n}\n\nint search(int s)\n{\n\tint next2[3005][4];\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tnext2[i][j] = next[i][j];\n\t\t}\n\t}\n\t\n\tint ret = 0, pos = s;\n\twhile(1){\n\t\tfor(int dir = 0; dir < 4; dir++){\n\t\t\tif(next2[pos][dir] == -1) continue;\n\t\t\tnext2[next2[pos][dir]][(dir+2)%4] = next2[pos][(dir+2)%4];\n\t\t}\n\t\tpos = next2[pos][d[pos]];\n\t\tret++;\n\t\tif(pos == -1) return ret;\n\t}\n}\n\nint main(void)\n{\n\tcin >> n;\n\t\n\tchar c;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> x[i] >> y[i] >> c;\n\t\tif(c == '>') d[i] = 0;\n\t\tif(c == '^') d[i] = 1;\n\t\tif(c == '<') d[i] = 2;\n\t\tif(c == 'v') d[i] = 3;\n\t}\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tXY[i] = point(i, x[i], y[i]);\n\t\tYX[i] = point(i, y[i], x[i]);\n\t}\n\t\n\tsort(XY, XY+n); make_link(XY, 3);\n\treverse(XY, XY+n); make_link(XY, 1);\n\tsort(YX, YX+n); make_link(YX, 0);\n\treverse(YX, YX+n); make_link(YX,  2);\n\t\n\tint ans = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tans = max(ans, search(i));\n\t}\n\t\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n\n    std::vector<int> ds(n);\n    std::map<int, std::vector<std::pair<int, int>>> xby, yby;\n\n    for (int i = 0; i < n; ++i) {\n        int x, y;\n        char c;\n        std::cin >> x >> y >> c;\n\n        int d;\n        for (d = 0; d < 4; ++d) {\n            if (c == \"><v^\"[d]) break;\n        }\n\n        ds[i] = d;\n        xby[x].emplace_back(y, i);\n        yby[y].emplace_back(x, i);\n    }\n\n    std::vector<std::vector<int>> oto(n, std::vector<int>(4, -1));\n    for (auto& p : xby) {\n        auto& ys = p.second;\n        std::sort(ys.begin(), ys.end());\n\n        for (int i = 0; i + 1 < (int)ys.size(); ++i) {\n            int u = ys[i].second, v = ys[i + 1].second;\n            oto[u][2] = v;\n            oto[v][3] = u;\n        }\n    }\n\n    for (auto& p : yby) {\n        auto& xs = p.second;\n        std::sort(xs.begin(), xs.end());\n\n        for (int i = 0; i + 1 < (int)xs.size(); ++i) {\n            int u = xs[i].second, v = xs[i + 1].second;\n            oto[u][0] = v;\n            oto[v][1] = u;\n        }\n    }\n\n    int ans = 0;\n    for (int s = 0; s < n; ++s) {\n        auto to = oto;\n        int cnt = 0;\n\n        int v = s;\n        while (v != -1) {\n            int p = to[v][0], q = to[v][1];\n            if (p != -1) to[p][1] = q;\n            if (q != -1) to[q][0] = p;\n\n            p = to[v][2], q = to[v][3];\n            if (p != -1) to[p][3] = q;\n            if (q != -1) to[q][2] = p;\n\n            v = to[v][ds[v]];\n            ++cnt;\n        }\n\n        ans = std::max(ans, cnt);\n    }\n\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\n#define MAX_N 3005\nint n;\nint px[MAX_N],py[MAX_N];\nchar ch[MAX_N];\n\nint solve(int si){\n  bool used[MAX_N]={};\n  set< P > sx[MAX_N],sy[MAX_N];\n  for(int i=0;i<n;i++){\n    if(i==si)continue;\n    sx[ px[i] ].insert( P(py[i],i) );\n    sy[ py[i] ].insert( P(px[i],i) );\n  }\n  int res=1;\n  int x=px[si],y=py[si];\n  char dir=ch[si];\n\n  set< P > :: iterator it;\n  while(1){\n    P next;\n    if(dir=='v'){\n      it= sx[x].lower_bound( P(y,0) );\n      if(it==sx[x].end())break;\n      next=*it;\n    }else if(dir=='^'){\n      it= sx[x].lower_bound( P(y,0) );\n      if(it==sx[x].begin())break;\n      it--;\n      next=*it;\n    }else if(dir=='>'){\n      it= sy[y].lower_bound( P(x,0) );\n      if(it==sy[y].end())break;\n      next=*it;      \n    }else if(dir=='<'){\n      it= sy[y].lower_bound( P(x,0) );\n      if(it==sy[y].begin())break;\n      it--;\n      next=*it;\n    }\n    res++;\n    int id=next.second;\n    x=px[id];\n    y=py[id];\n    dir=ch[id];\n    sx[ x ].erase(P(y,id));\n    sy[ y ].erase(P(x,id));\n  }\n  return res;\n}\n\nint main(){\n  vector<int> X,Y;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>px[i]>>py[i]>>ch[i];\n    X.push_back(px[i]);\n    Y.push_back(py[i]);\n  }\n  sort(X.begin(),X.end());\n  sort(Y.begin(),Y.end());\n  X.erase(unique(X.begin(),X.end()),X.end());\n  Y.erase(unique(Y.begin(),Y.end()),Y.end());\n\n  for(int i=0;i<n;i++){\n    px[i]=lower_bound(X.begin(),X.end(),px[i])-X.begin();\n    py[i]=lower_bound(Y.begin(),Y.end(),py[i])-Y.begin();\n  }\n\n\n\n  int ans=0;\n  for(int i=0;i<n;i++){\n    ans=max(ans,solve(i));\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 3000\n\nenum DIR{\n\tNorth,\n\tEast,\n\tSouth,\n\tWest,\n};\n\nstruct Info{\n\tint x,y;\n\tDIR dir;\n};\n\nstruct Data{\n\tDIR dir;\n\tbool exist,visited;\n};\n\nstruct State{\n\tvoid set(int arg_y,int arg_x,DIR arg_dir){\n\t\ty = arg_y;\n\t\tx = arg_x;\n\t\tdir = arg_dir;\n\t}\n\tint x,y;\n\tDIR dir;\n};\n\nint N;\nmap<int,int> X_MAP,Y_MAP;\nvector<int> Y,X;\nInfo info[NUM];\nData data[NUM][NUM]; //座標圧縮した2次元フィールド\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tchar buf[2];\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %s\",&info[i].x,&info[i].y,buf);\n\t\tX.push_back(info[i].x);\n\t\tY.push_back(info[i].y);\n\t\tswitch(buf[0]){\n\t\tcase '^':\n\t\t\tinfo[i].dir = North;\n\t\t\tbreak;\n\t\tcase '>':\n\t\t\tinfo[i].dir = East;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tinfo[i].dir = South;\n\t\t\tbreak;\n\t\tcase '<':\n\t\t\tinfo[i].dir = West;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsort(X.begin(),X.end());\n\tsort(Y.begin(),Y.end());\n\n\tX.erase(unique(X.begin(),X.end()),X.end());\n\tY.erase(unique(Y.begin(),Y.end()),Y.end());\n\n\t//座標圧縮\n\tfor(int i = 0; i < X.size(); i++){\n\t\tX_MAP[X[i]] = i;\n\t}\n\tfor(int i = 0; i < Y.size(); i++){\n\t\tY_MAP[Y[i]] = i;\n\t}\n\n\tint size_X = (int)X.size(),size_Y = (int)Y.size();\n\n\tfor(int i = 0; i < size_X; i++){\n\t\tfor(int k = 0; k < size_Y; k++)data[i][k].exist = false;\n\t}\n\n\t//圧縮済座標上に力点を配置\n\tfor(int i = 0; i < N; i++){\n\t\tdata[Y_MAP[info[i].y]][X_MAP[info[i].x]].exist = true;\n\t\tdata[Y_MAP[info[i].y]][X_MAP[info[i].x]].dir = info[i].dir;\n\t}\n\n\tint ans = 0;\n\tint next_y,next_x;\n\tState state;\n\n\t//初期位置を全探索\n\tfor(int start = 0; start < N; start++){\n\n\t\tfor(int i = 0; i < size_X; i++){\n\t\t\tfor(int k = 0; k < size_Y; k++)data[i][k].visited = false;\n\t\t}\n\n\t\tint tmp_count = 1;\n\t\tdata[Y_MAP[info[start].y]][X_MAP[info[start].x]].visited = true;\n\t\tstate.set(Y_MAP[info[start].y],X_MAP[info[start].x],info[start].dir);\n\n\t\twhile(true){\n\n\t\t\tnext_y = BIG_NUM;\n\t\t\tnext_x = BIG_NUM;\n\n\t\t\t//次の力点を探す\n\t\t\tswitch(state.dir){\n\t\t\tcase North:\n\t\t\t\tfor(int tmp_y = state.y-1; tmp_y >= 0; tmp_y--){\n\t\t\t\t\tif(data[tmp_y][state.x].exist == true && data[tmp_y][state.x].visited == false){\n\t\t\t\t\t\tnext_y = tmp_y;\n\t\t\t\t\t\tnext_x = state.x;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase East:\n\t\t\t\tfor(int tmp_x = state.x+1; tmp_x <= size_X-1; tmp_x++){\n\t\t\t\t\tif(data[state.y][tmp_x].exist == true && data[state.y][tmp_x].visited == false){\n\t\t\t\t\t\tnext_y = state.y;\n\t\t\t\t\t\tnext_x = tmp_x;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase South:\n\t\t\t\tfor(int tmp_y = state.y+1; tmp_y <= size_Y-1; tmp_y++){\n\t\t\t\t\tif(data[tmp_y][state.x].exist == true && data[tmp_y][state.x].visited == false){\n\t\t\t\t\t\tnext_y = tmp_y;\n\t\t\t\t\t\tnext_x = state.x;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase West:\n\t\t\t\tfor(int tmp_x = state.x-1; tmp_x >= 0; tmp_x--){\n\t\t\t\t\tif(data[state.y][tmp_x].exist == true && data[state.y][tmp_x].visited == false){\n\t\t\t\t\t\tnext_y = state.y;\n\t\t\t\t\t\tnext_x = tmp_x;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(next_y == BIG_NUM || next_x == BIG_NUM)break;\n\n\t\t\tdata[next_y][next_x].visited = true;\n\t\t\tstate.set(next_y,next_x,data[next_y][next_x].dir);\n\t\t\ttmp_count++;\n\t\t}\n\n\t\tans = max(ans,tmp_count);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3001\nusing namespace std;\nint w,h;\nint dx[]={0,1,0,-1};//^>v<\nint dy[]={-1,0,1,0};\nvector<int> X,Y,d;\nmap<int,int> x,y;\n\nint compless(vector<int> A,map<int,int> &M){\n  sort(A.begin(),A.end());\n  int c=0;\n  for(int i=0;i<A.size();i++)if(!M.count(A[i]))M[A[i]]=c++;\n  return c;\n}\n\nint calc(int y,int x,vector<vector<int> >&mp){\n  vector<vector<bool> > used(h,vector<bool>(w,0));\n  int res=0;\n  while(1){\n    res++;\n    int i=mp[y][x];\n    used[y][x]=1;\n    while(1){\n      y+=dy[i],x+=dx[i];\n      if(y<0||x<0||x>=w||y>=h)return res;\n      if(mp[y][x]!=-1&&!used[y][x])break;\n    }\n  }\n  assert(0);\n}\n\nint main(){\n  int n;\n  cin>>n;\n  X.resize(n),Y.resize(n),d.resize(n);\n  for(int i=0;i<n;i++){\n    char ch;\n    cin>>X[i]>>Y[i]>>ch;\n    if(ch=='^')d[i]=0;\n    if(ch=='>')d[i]=1;\n    if(ch=='v')d[i]=2;\n    if(ch=='<')d[i]=3;\n  }\n  h=compless(Y,y);\n  w=compless(X,x);\n  vector<vector<int> >mp(h,vector<int>(w,-1));\n  for(int i=0;i<X.size();i++)mp[y[Y[i]]][x[X[i]]]=d[i];\n\n  int ans=1;\n  for(int i=0;i<n;i++)ans=max(ans,calc(y[Y[i]],x[X[i]],mp));\n  cout <<ans<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*  -*- coding: utf-8 -*-\n *\n * 2718.cc: Vector Field\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 3000;\n\n/* typedef */\n\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpii;\ntypedef map<int,int> mii;\n\n/* global variables */\n\nint xs[MAX_N], ys[MAX_N], cxs[MAX_N], cys[MAX_N], xis[MAX_N], yis[MAX_N];\nchar cs[MAX_N];\nmii xmap, ymap;\nbool used[MAX_N];\nvpii xvs[MAX_N], yvs[MAX_N];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d %d %c\", &xs[i], &ys[i], &cs[i]);\n    cxs[i] = xs[i], cys[i] = ys[i];\n    //printf(\"(%d,%d)[%c]\\n\", xs[i], ys[i], cs[i]);\n  }\n\n  sort(cxs, cxs + n);\n  int xn = unique(cxs, cxs + n) - cxs;\n  for (int i = 0; i < xn; i++) xmap[cxs[i]] = i;\n  sort(cys, cys + n);\n  int yn = unique(cys, cys + n) - cys;\n  for (int i = 0; i < yn; i++) ymap[cys[i]] = i;\n\n  for (int i = 0; i < n; i++) {\n    xis[i] = xmap[xs[i]], yis[i] = ymap[ys[i]];\n    xvs[yis[i]].push_back(pii(xis[i], i));\n    yvs[xis[i]].push_back(pii(yis[i], i));\n  }\n\n  for (int i = 0; i < yn; i++) sort(xvs[i].begin(), xvs[i].end());\n  for (int i = 0; i < xn; i++) sort(yvs[i].begin(), yvs[i].end());\n\n  int maxd = 0;\n  for (int st = 0; st < n; st++) {\n    memset(used, false, sizeof(used));\n    int d = 0;\n\n    for (int i = st; i >= 0;) {\n      used[i] = true, d++;\n      int xi = xis[i], yi = yis[i];\n      char c = cs[i];\n\n      if (c == '>') {\n\tvpii &xv = xvs[yi];\n\tint k =\n\t  lower_bound(xv.begin(), xv.end(), pii(xi, i)) - xv.begin() + 1;\n\twhile (k < xv.size() && used[xv[k].second]) k++;\n\ti = (k < xv.size()) ? xv[k].second : -1;\n      }\n      else if (c == '<') {\n\tvpii &xv = xvs[yi];\n\tint k =\n\t  lower_bound(xv.begin(), xv.end(), pii(xi, i)) - xv.begin() - 1;\n\twhile (k >= 0 && used[xv[k].second]) k--;\n\ti = (k >= 0) ? xv[k].second : -1;\n      }\n      else if (c == 'v') {\n\tvpii &yv = yvs[xi];\n\tint k =\n\t  lower_bound(yv.begin(), yv.end(), pii(yi, i)) - yv.begin() + 1;\n\twhile (k < yv.size() && used[yv[k].second]) k++;\n\ti = (k < yv.size()) ? yv[k].second : -1;\n      }\n      else {\n\tvpii &yv = yvs[xi];\n\tint k =\n\t  lower_bound(yv.begin(), yv.end(), pii(yi, i)) - yv.begin() - 1;\n\twhile (k >= 0 && used[yv[k].second]) k--;\n\ti = (k >= 0) ? yv[k].second : -1;\n      }\n    }\n\n    if (maxd < d) maxd = d;\n    //printf(\"st=%d, d=%d\\n\", st, d);\n  }\n\n  printf(\"%d\\n\", maxd);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int,int>;\n\nsigned main(){\n\tint n,x[3010],y[3010],ans = 0;\n\tchar d[3010];\n\tmap<int,set<P>> xy,yx;\n\tcin >> n;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> x[i] >> y[i] >> d[i];\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\txy.clear();\n\t\tyx.clear();\n\t\tfor(int j = 0;j < n;j++){\n\t\t\txy[x[j]].emplace(y[j],j);\n\t\t\tyx[y[j]].emplace(x[j],j);\n\t\t}\n\t\tint v = i,cnt = 0;\n\t\twhile(1){\n\t\t\tint nv;\n\t\t\tcnt++;\n\t\t\tif(d[v] == '^'){\n\t\t\t\tauto it = xy[x[v]].find(P(y[v],v));\n\t\t\t\tif(it == xy[x[v]].begin()) break;\n\t\t\t\tnv = (*(--it)).second;\n\t\t\t}else if(d[v] == 'v'){\n\t\t\t\tauto it = xy[x[v]].find(P(y[v],v));\n\t\t\t\tif(++it == xy[x[v]].end()) break;\n\t\t\t\tnv = (*it).second;\n\t\t\t}else if(d[v] == '<'){\n\t\t\t\tauto it = yx[y[v]].find(P(x[v],v));\n\t\t\t\tif(it == yx[y[v]].begin()) break;\n\t\t\t\tnv = (*(--it)).second;\n\t\t\t}else{\n\t\t\t\tauto it = yx[y[v]].find(P(x[v],v));\n\t\t\t\tif(++it == yx[y[v]].end()) break;\n\t\t\t\tnv = (*it).second;\n\t\t\t}\n\t\t\txy[x[v]].erase(P(y[v],v));\n\t\t\tyx[y[v]].erase(P(x[v],v));\n\t\t\tv = nv;\n\t\t}\n\t\tans = max(ans,cnt);\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\nclass Main {\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tlong[] x = new long[n];\n\t\tlong[] y = new long[n];\n\t\tchar[] d = new char[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tx[i] = sc.nextLong();\n\t\t\ty[i] = sc.nextLong();\n\t\t\td[i] = sc.next().charAt(0);\n\t\t}\n\t\tshrink(x);\n\t\tshrink(y);\n\t\tArrayList<Long>[] list1 = new ArrayList[3000];\n\t\tArrayList<Long>[] list2 = new ArrayList[3000];\n\t\tfor (int i = 0; i < list1.length; ++i) {\n\t\t\tlist1[i] = new ArrayList();\n\t\t}\n\t\tfor (int i = 0; i < list2.length; ++i) {\n\t\t\tlist2[i] = new ArrayList();\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tlist1[(int) x[i]].add(y[i] << 32 | i);\n\t\t\tlist2[(int) y[i]].add(x[i] << 32 | i);\n\t\t}\n\t\tint[] up = new int[n];\n\t\tint[] down = new int[n];\n\t\tint[] left = new int[n];\n\t\tint[] right = new int[n];\n\t\tArrays.fill(up, -1);\n\t\tArrays.fill(down, -1);\n\t\tArrays.fill(left, -1);\n\t\tArrays.fill(right, -1);\n\t\tfor (int i = 0; i < 3000; ++i) {\n\t\t\tCollections.sort(list1[i]);\n\t\t\tCollections.sort(list2[i]);\n\t\t\tfor (int j = 0; j + 1 < list1[i].size(); ++j) {\n\t\t\t\tint u = (int) (list1[i].get(j) & ((1L << 32) - 1));\n\t\t\t\tint v = (int) (list1[i].get(j + 1) & ((1L << 32) - 1));\n\t\t\t\tup[u] = v;\n\t\t\t\tdown[v] = u;\n\t\t\t}\n\t\t\tfor (int j = 0; j + 1 < list2[i].size(); ++j) {\n\t\t\t\tint u = (int) (list2[i].get(j) & ((1L << 32) - 1));\n\t\t\t\tint v = (int) (list2[i].get(j + 1) & ((1L << 32) - 1));\n\t\t\t\tright[u] = v;\n\t\t\t\tleft[v] = u;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint[] UP = Arrays.copyOf(up, up.length);\n\t\t\tint[] DOWN = Arrays.copyOf(down, down.length);\n\t\t\tint[] RIGHT = Arrays.copyOf(right, right.length);\n\t\t\tint[] LEFT = Arrays.copyOf(left, left.length);\n\t\t\tint cur = i;\n\t\t\tint pre = -1;\n\t\t\tint tmp = 0;\n\t\t\twhile (true) {\n\t\t\t\tpre = cur;\n\t\t\t\tif (d[cur] == 'v') {\n\t\t\t\t\tcur = UP[cur];\n\t\t\t\t} else if (d[cur] == '^') {\n\t\t\t\t\tcur = DOWN[cur];\n\t\t\t\t} else if (d[cur] == '>') {\n\t\t\t\t\tcur = RIGHT[cur];\n\t\t\t\t} else if (d[cur] == '<') {\n\t\t\t\t\tcur = LEFT[cur];\n\t\t\t\t} else {\n\t\t\t\t\tthrow new AssertionError();\n\t\t\t\t}\n\t\t\t\t++tmp;\n\t\t\t\tif (cur == -1)\n\t\t\t\t\tbreak;\n\t\t\t\telse {\n\t\t\t\t\terase(pre, UP, DOWN, RIGHT, LEFT);\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = Math.max(ans, tmp);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tvoid erase(int id, int[] up, int[] down, int[] right, int[] left) {\n\t\tif (id == -1)\n\t\t\treturn;\n\t\tif (down[id] != -1)\n\t\t\tup[down[id]] = up[id];\n\t\tif (up[id] != -1)\n\t\t\tdown[up[id]] = down[id];\n\t\tif (left[id] != -1)\n\t\t\tright[left[id]] = right[id];\n\t\tif (right[id] != -1)\n\t\t\tleft[right[id]] = left[id];\n\t\tup[id] = -1;\n\t\tdown[id] = -1;\n\t\tright[id] = -1;\n\t\tleft[id] = -1;\n\t}\n\n\tvoid shrink(long[] a) {\n\t\tlong[][] b = new long[a.length][2];\n\t\tfor (int i = 0; i < a.length; ++i) {\n\t\t\tb[i][0] = a[i];\n\t\t\tb[i][1] = i;\n\t\t}\n\t\tArrays.sort(b, new Comparator<long[]>() {\n\t\t\t@Override\n\t\t\tpublic int compare(long[] arg0, long[] arg1) {\n\t\t\t\treturn Long.compare(arg0[0], arg1[0]);\n\t\t\t}\n\t\t});\n\t\tint p = 0;\n\t\tfor (int i = 0; i < b.length; ++i) {\n\t\t\tif (i - 1 >= 0 && b[i][0] != b[i - 1][0]) {\n\t\t\t\t++p;\n\t\t\t}\n\t\t\ta[(int) b[i][1]] = p;\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\nclass Main {\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tlong[] x = new long[n];\n\t\tlong[] y = new long[n];\n\t\tchar[] d = new char[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tx[i] = sc.nextLong();\n\t\t\ty[i] = sc.nextLong();\n\t\t\td[i] = sc.next().charAt(0);\n\t\t}\n\t\tshrink(x);\n\t\tshrink(y);\n\t\tArrayList<Long>[] list1 = new ArrayList[3000];\n\t\tArrayList<Long>[] list2 = new ArrayList[3000];\n\t\tfor (int i = 0; i < list1.length; ++i) {\n\t\t\tlist1[i] = new ArrayList();\n\t\t}\n\t\tfor (int i = 0; i < list2.length; ++i) {\n\t\t\tlist2[i] = new ArrayList();\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tlist1[(int) x[i]].add(y[i] << 32 | i);\n\t\t\tlist2[(int) y[i]].add(x[i] << 32 | i);\n\t\t}\n\t\tint[] up = new int[n];\n\t\tint[] down = new int[n];\n\t\tint[] left = new int[n];\n\t\tint[] right = new int[n];\n\t\tArrays.fill(up, -1);\n\t\tArrays.fill(down, -1);\n\t\tArrays.fill(left, -1);\n\t\tArrays.fill(right, -1);\n\t\tfor (int i = 0; i < 3000; ++i) {\n\t\t\tCollections.sort(list1[i]);\n\t\t\tCollections.sort(list2[i]);\n\t\t\tfor (int j = 0; j + 1 < list1[i].size(); ++j) {\n\t\t\t\tint u = (int) (list1[i].get(j) & ((1L << 32) - 1));\n\t\t\t\tint v = (int) (list1[i].get(j + 1) & ((1L << 32) - 1));\n\t\t\t\tup[u] = v;\n\t\t\t\tdown[v] = u;\n\t\t\t}\n\t\t\tfor (int j = 0; j + 1 < list2[i].size(); ++j) {\n\t\t\t\tint u = (int) (list2[i].get(j) & ((1L << 32) - 1));\n\t\t\t\tint v = (int) (list2[i].get(j + 1) & ((1L << 32) - 1));\n\t\t\t\tright[u] = v;\n\t\t\t\tleft[v] = u;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint[] UP = Arrays.copyOf(up, up.length);\n\t\t\tint[] DOWN = Arrays.copyOf(down, down.length);\n\t\t\tint[] RIGHT = Arrays.copyOf(right, right.length);\n\t\t\tint[] LEFT = Arrays.copyOf(left, left.length);\n\t\t\tint cur = i;\n\t\t\tint pre = -1;\n\t\t\tint tmp = 0;\n\t\t\twhile (true) {\n\t\t\t\tpre = cur;\n\t\t\t\tif (d[cur] == 'v') {\n\t\t\t\t\tcur = UP[cur];\n\t\t\t\t} else if (d[cur] == '^') {\n\t\t\t\t\tcur = DOWN[cur];\n\t\t\t\t} else if (d[cur] == '>') {\n\t\t\t\t\tcur = RIGHT[cur];\n\t\t\t\t} else if (d[cur] == '<') {\n\t\t\t\t\tcur = LEFT[cur];\n\t\t\t\t} else {\n\t\t\t\t\tthrow new AssertionError();\n\t\t\t\t}\n\t\t\t\t++tmp;\n\t\t\t\tif (cur == -1)\n\t\t\t\t\tbreak;\n\t\t\t\telse {\n\t\t\t\t\terase(pre, UP, DOWN, RIGHT, LEFT);\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = Math.max(ans, tmp);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tvoid erase(int id, int[] up, int[] down, int[] right, int[] left) {\n\t\tif (id == -1)\n\t\t\treturn;\n\t\tif (down[id] != -1)\n\t\t\tup[down[id]] = up[id];\n\t\tif (up[id] != -1)\n\t\t\tdown[up[id]] = down[id];\n\t\tif (left[id] != -1)\n\t\t\tright[left[id]] = right[id];\n\t\tif (right[id] != -1)\n\t\t\tleft[right[id]] = left[id];\n\t\tup[id] = -1;\n\t\tdown[id] = -1;\n\t\tright[id] = -1;\n\t\tleft[id] = -1;\n\t}\n\n\tvoid shrink(long[] a) {\n\t\tlong[][] b = new long[a.length][2];\n\t\tfor (int i = 0; i < a.length; ++i) {\n\t\t\tb[i][0] = a[i];\n\t\t\tb[i][1] = i;\n\t\t}\n\t\tArrays.sort(b, new Comparator<long[]>() {\n\t\t\t@Override\n\t\t\tpublic int compare(long[] arg0, long[] arg1) {\n\t\t\t\treturn Long.compare(arg0[0], arg1[0]);\n\t\t\t}\n\t\t});\n\t\tint p = 0;\n\t\tfor (int i = 0; i < b.length; ++i) {\n\t\t\tif (i - 1 >= 0 && b[i][0] != b[i - 1][0]) {\n\t\t\t\t++p;\n\t\t\t}\n\t\t\ta[(int) b[i][1]] = p;\n\t\t}\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing static System.Math;\n\npublic static class P\n{\n    static int N;\n    static Cell[] Cells;\n    public static void Main()\n    {\n        int n = int.Parse(Console.ReadLine());\n        N = n;\n        Dictionary<int, List<Tuple<int, int>>> yDict = new Dictionary<int, List<Tuple<int, int>>>();\n        Dictionary<int, List<Tuple<int, int>>> xDict = new Dictionary<int, List<Tuple<int, int>>>();\n        Cell[] cells = Enumerable.Repeat(new Cell() { DownInd = -1, LeftInd = -1, RightInd = -1, UpInd = -1 }, n).ToArray();\n        for (int i = 0; i < n; i++)\n        {\n            var xyd = Console.ReadLine().Split();\n            var x = int.Parse(xyd[1]);\n            var y = int.Parse(xyd[0]);\n            var dir = xyd[2] == \"^\" ? 0 : xyd[2] == \">\" ? 1 : xyd[2] == \"v\" ? 2 : 3;\n            cells[i].Dir = dir;\n            if (!yDict.ContainsKey(y)) yDict.Add(y, new List<Tuple<int, int>>());\n            if (!xDict.ContainsKey(x)) xDict.Add(x, new List<Tuple<int, int>>());\n            yDict[y].Add(new Tuple<int, int>(x, i));\n            xDict[x].Add(new Tuple<int, int>(y, i));\n        }\n        foreach (var key in xDict.Keys)\n        {\n            var val = xDict[key];\n            val.Sort();\n            for (int i = 0; i < val.Count - 1; i++)\n            {\n                cells[val[i].Item2].RightInd = val[i + 1].Item2;\n                cells[val[i + 1].Item2].LeftInd = val[i].Item2;\n            }\n        }\n        foreach (var key in yDict.Keys)\n        {\n            var val = yDict[key];\n            val.Sort();\n            for (int i = 0; i < val.Count - 1; i++)\n            {\n                cells[val[i].Item2].DownInd = val[i + 1].Item2;\n                cells[val[i + 1].Item2].UpInd = val[i].Item2;\n            }\n        }\n        int res = 0;\n        for (int i = 0; i < n; i++)\n        {\n            Cells = cells.ToArray();\n            res = Max(res, Simulate(i));\n        }\n        Console.WriteLine(res);\n    }\n    static void Remove(int ind)\n    {\n        var u = Cells[ind].UpInd;\n        var d = Cells[ind].DownInd;\n        var l = Cells[ind].LeftInd;\n        var r = Cells[ind].RightInd;\n        if (u != -1) Cells[u].DownInd = d;\n        if (d != -1) Cells[d].UpInd = u;\n        if (l != -1) Cells[l].RightInd = r;\n        if (r != -1) Cells[r].LeftInd = l;\n        Cells[ind] = new Cell() { Dir = -1 };\n    }\n    static int Simulate(int startInd)\n    {\n        int res = 0;\n        var curCellInd = startInd;\n        //List<int> path = new List<int>();\n        while (true)\n        {\n            if (curCellInd == -1) break;\n            //path.Add(curCellInd);\n            int next;\n            switch (Cells[curCellInd].Dir)\n            {\n                case 0:\n                    next = Cells[curCellInd].UpInd;\n                    break;\n                case 1:\n                    next = Cells[curCellInd].RightInd;\n                    break;\n                case 2:\n                    next = Cells[curCellInd].DownInd;\n                    break;\n                case 3:\n                    next = Cells[curCellInd].LeftInd;\n                    break;\n                default:\n                    throw new Exception();\n            }\n            Remove(curCellInd);\n            curCellInd = next;\n            res++;\n        }\n        //Console.WriteLine($\"begin at {startInd}:\\n{string.Join(\"->\", path)}\");\n        return res;\n    }\n}\n\nstruct Cell\n{\n    public int UpInd;\n    public int DownInd;\n    public int LeftInd;\n    public int RightInd;\n    public int Dir;\n}\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\ndef solve():\n    readline = sys.stdin.readline\n    write = sys.stdout.write\n    f = \"<v>^\".index\n    N = int(readline())\n    Y = defaultdict(list)\n    for i in range(N):\n        x, y, d = readline().split()\n        x = int(x); y = int(y)\n        Y[y].append((x, f(d)))\n    *S, = Y.items()\n    S.sort()\n    L = [0]*N\n    V = [[-1]*4 for i in range(N)]\n    cur = 0\n    X = {}\n    for y, es in S:\n        es.sort()\n        prv = -1\n        for x, d in es:\n            v = V[cur]\n            L[cur] = d\n            if x in X:\n                k = X[x]\n                v[3] = k\n                V[k][1] = cur\n            X[x] = cur\n            if prv != -1:\n                v[0] = prv\n                V[prv][2] = cur\n            prv = cur\n            cur += 1\n    ans = 0\n    for i in range(N):\n        res = 0\n        R = [e[:] for e in V]\n        v = i\n        while v != -1:\n            d = L[v]\n            w0, w1, w2, w3 = r = R[v]\n            if w0 != -1:\n                R[w0][2] = w2\n            if w1 != -1:\n                R[w1][3] = w3\n            if w2 != -1:\n                R[w2][0] = w0\n            if w3 != -1:\n                R[w3][1] = w1\n            res += 1\n            v = r[d]\n        ans = max(ans, res)\n    write(\"%d\\n\" % ans)\nsolve()\n"
  }
]