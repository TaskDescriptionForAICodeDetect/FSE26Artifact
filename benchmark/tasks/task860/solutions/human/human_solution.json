[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstring s, t;\n\nconst int N = 301;\n\nint dp[N][N][N];\nint n;\n\nint f(int n1, int n2, int k) {\n    if (dp[n1][n2][k] != -1) {\n        return dp[n1][n2][k];\n    }\n    if (!n1 || !n2) {\n        return dp[n1][n2][k] = 0;\n    }\n    if (s[n1 - 1] == t[n2 - 1]) {\n        return dp[n1][n2][k] = f(n1 - 1, n2 - 1, k) + 1;\n    }\n    dp[n1][n2][k] = 0;\n    if (k && min(n1, n2) > (n + 1) / 2) {\n        dp[n1][n2][k] = f(n1 - 1, n2 - 1, k - 1) + 2 - (s[n1 - 1] == s[n - n1]);\n    }\n    dp[n1][n2][k] = max(dp[n1][n2][k], f(n1 - 1, n2, k));\n    dp[n1][n2][k] = max(dp[n1][n2][k], f(n1, n2 - 1, k));\n    return dp[n1][n2][k];\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int k;\n    cin >> s >> k;\n    t = s;\n    reverse(t.begin(), t.end());\n    n = s.length();\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            for (int l = 0; l < N; ++l) {\n                dp[i][j][l] = -1;\n            }\n        }\n    }\n    cout << f(n, n, k);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=305;\nint f[N][N][N],n,K;char s[N];\nint main(){\n  scanf(\"%s%d\",s+1,&K);n=strlen(s+1);\n  for(int i=1;i<=n;i++)f[i][i][0]=1;\n  for(int len=2;len<=n;len++){\n\t  for(int i=1;i+len-1<=n;i++){\n\t\t  int j=i+len-1;\n\t\t  for(int k=0;k<=K;k++){\n\t\t\t  f[i][j][k]=max(f[i+1][j][k],f[i][j-1][k]);\n\t\t\t  if(s[i]==s[j])f[i][j][k]=max(f[i][j][k],f[i+1][j-1][k]+2);\n\t\t\t  if(k)f[i][j][k]=max(f[i][j][k],f[i+1][j-1][k-1]+2);\n\t\t  }\n\t  }\n  }\n  cout<<f[1][n][K]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)   FOR(i,0,n)\n#define LL long long\n\nstring s;\nint k,n;\n\nint dp[300][300][300];\n\nint main(){\n  cin>>s>>k;\n  n=s.size();\n  FOR(d,1,n+1){\n    FOR(init,0,n-d+1){\n      REP(l,k+1){\n\tif(d==1)dp[init][init+d-1][l]=1;\n\telse if(l==0){\n\t  if(s[init]==s[init+d-1])\n\t    dp[init][init+d-1][0]=(d==2)?2:2+dp[init+1][init+d-2][0];\n\t  else\n\t    dp[init][init+d-1][0]=max(dp[init][init+d-2][0],dp[init+1][init+d-1][0]);\n\t}else{\n\t  if(s[init]==s[init+d-1]){\n\t    dp[init][init+d-1][l]=(d==2)?2:2+dp[init+1][init+d-2][l];\n\t  }else{\n\t    dp[init][init+d-1][l]=max(max(dp[init][init+d-2][l],dp[init+1][init+d-1][l]),2+dp[init+1][init+d-2][l-1]);\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<dp[0][n-1][k]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long int64;\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define sz(a) ((int) (a).size())\n\nconst int inf = (int) 1e9;\nconst int N = 301;\nchar s[N];\nint n, k, ans[N][N][N];\n\nint main() {\n\tscanf(\"%s%d\", s, &k), n = strlen(s);\n\tfor (int l = n - 1; l >= 0; --l) {\n\t\tfor (int r = l; r < n; ++r) {\n\t\t\tfor (int t = 0; t <= k; ++t) {\n\t\t\t\tans[l][r][t] = -inf;\n\t\t\t\tif (l == r) {\n\t\t\t\t\tans[l][r][t] = 1;\n\t\t\t\t} else if (s[l] == s[r]) {\n\t\t\t\t\tans[l][r][t] = 2 + ans[l + 1][r - 1][t];\n\t\t\t\t} else {\n\t\t\t\t\tans[l][r][t] = max(ans[l + 1][r][t], ans[l][r - 1][t]);\n\t\t\t\t\tif (t > 0) {\n\t\t\t\t\t\tans[l][r][t] = max(ans[l][r][t], ans[l + 1][r - 1][t - 1] + 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans[0][n - 1][k]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <list>\n#include <stack>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\n\nlong long int INF = 1e18;\nlong long int MOD = 1e9 + 7;\n\nint DP[310][310][310] = {};\n\nint main(){\n\t\n\tstring S;\n\tint K;\n\t\n\tcin >> S;\n\tcin >> K;\n\t\n\tfor(int i = 0; i < S.size(); i++){\n\t\tfor(int j = S.size() - 1; j > i; j--){\n\t\t\tint id1 = i + 1;\n\t\t\tint id2 = S.size() - j;\n\t\t\tfor(int k = 0; k <= K; k++){\n\t\t\t\tDP[id1][id2][k] = max(DP[id1 - 1][id2][k], DP[id1][id2 - 1][k]);\n\t\t\t\tif(k != 0){\n\t\t\t\t\tDP[id1][id2][k] = max(DP[id1][id2][k], DP[id1][id2][k - 1]);\n\t\t\t\t}\n\t\t\t\tif(S[i] == S[j]){\n\t\t\t\t\tDP[id1][id2][k] = max(DP[id1][id2][k], DP[id1 - 1][id2 - 1][k] + 1);\n\t\t\t\t}else if(k != 0){\n\t\t\t\t\tDP[id1][id2][k] = max(DP[id1][id2][k], DP[id1 - 1][id2 - 1][k - 1] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\t\n\tfor(int i = 0; i <= S.size(); i++){\n\t\tans = max(ans, DP[i][S.size() - i][K] * 2);\n\t}\n\t\n\tfor(int i = 0; i < S.size(); i++){\n\t\tans = max(ans, DP[i][S.size() - i - 1][K] * 2 + 1);\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define mod 1000000007LL\n#define eps 1e-13\n// #define PI 3.141592653589793238L\n#define INF 1000000011\n#define INFLL 1000000000000000011LL\n#define vi vector<int>\n#define vll vector<long long>\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define pil pair<int, long long>\n#define pli pair<long long, int>\n#define mp make_pair\n#define F first\n#define S second\n#define pb push_back\n#define fo(i,a,n) for(i = (a); i < (n); i++)\n#define gtl(x) getline(cin, (x))\n#define flsh fflush(stdout)\n#define sws ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)\n#define gcd __gcd\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)((a).size())\n#define io_file freopen(\"D:/Coding Problems/Contest/input_file.in\", \"r\", stdin); freopen(\"D:/Coding Problems/Contest/output_file.out\", \"w\", stdout)\n\nll modx(ll Base, ll exponent)\n{\n\tll ans = 1;\n\tif(Base == 1)\n\t\treturn Base;\n\twhile(exponent)\n\t{\n\t\tif(exponent & 1)\n\t\t\tans = (ans * Base)%mod;\n\t\tBase = (Base * Base)%mod;\n\t\texponent = exponent >> 1;\n\t}\n\treturn ans;\n}\n\nll inmodx(ll num)\n{\n\treturn (modx(num, mod-2LL));\n}\n\nbool cmp(pair < pii, int > a, pair < pii, int > b)//true for a before b\n{\n\tif(a.F.F/300 < b.F.F/300)\n\t\treturn 1;\n\tif(a.F.F/300 > b.F.F/300)\n\t\treturn 0;\n\tif(a.F.S < b.F.S)\n\t\treturn 1;\n\tif(a.F.S > b.F.S)\n\t\treturn 0;\n\tif(a.F <= b.F)\n\t\treturn 1;\n\treturn 0;\n}\n\nconst int N = (3e2) + 9;\nconst int M = (N<<2) + 9;\nconst int LOGN = ((int)log2(N)) + 3;\nconst int LOGM = ((int)log2(M)) + 3;\nconst int BUCK = 2*550;\nconst int SQRT = BUCK+9;\n\nint dp[N][N][N];\nstring s;\nint n, K;\n\nvoid solve()\n{\n\tint i, j, k, ans = 0;\n\tcin >> s;\n\tcin >> K;\n\tn = s.length();\n\tfo(i,1,n+1)\n\t\tfo(j,1,n-i+1+1)\n\t\t\tfo(k,0,K+1)\n\t\t\t{\n\t\t\t\tif(s[i-1] == s[n-j])\n\t\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k] + ((i+j < n) ? 2 : 1));\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k]);\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k]);\n\t\t\t\tif(k > 0)\n\t\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k-1] + ((i+j < n) ? 2 : 1));\n\t\t\t\tans = max(ans, dp[i][j][k]);\n\t\t\t}\n\tcout << ans << '\\n';\n\treturn;\n}\n\nint main()\n{\n\tsws;\n\tclock_t clk;\n\tclk = clock();\n\t// io_file; holy moly\n\t// srand (time(NULL));\n\n\t//Code here\n\tint t = 1, cs;\n\tcout << fixed << setprecision(9);\n\t// cin >> t;\n\tfo(cs,1,t+1)\n\t{\n\t\t// cout << \"Case #\" << cs << \": \";\n\t\tsolve();\n\t}\n\t// Code ends here\n\n\tclk = clock() - clk;\n\tcerr << fixed << setprecision(6) << \"Time: \" << ((double)clk)/CLOCKS_PER_SEC << \"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define mod 1000000007\nusing ll=long long;\nconst int INF=1000000000;\nconst ll LINF=1001002003004005006ll;\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n// ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return true;}return false;}\n \nstruct IOSetup{\n    IOSetup(){\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n        cout<<fixed<<setprecision(12);\n    }\n} iosetup;\n \ntemplate<typename T1,typename T2>\nostream &operator<<(ostream &os,const pair<T1,T2>&p){\n    os<<p.first<<\" \"<<p.second;\n    return os;\n}\n \ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T>&v){\n    for(int i=0;i<(int)v.size();i++) os<<v[i]<<(i+1==(int)v.size()?\"\":\" \");\n    return os;\n}\n\ntemplate<typename T1,typename T2>\nistream &operator>>(istream &is,pair<T1,T2>&p){\n    is>>p.first>>p.second;\n    return is;\n}\n\ntemplate<typename T>\nistream &operator>>(istream &is,vector<T>&v){\n    for(T &x:v)is>>x;\n    return is;\n}\n\n\nint dp[310][310][610];\nsigned main(){\n    string s;cin>>s;\n    int m;cin>>m;m*=2;\n    int n=(int)s.size();\n    string t=s;\n    reverse(ALL(t));\n\n    rep(i,n)rep(j,n)rep(k,m+1){\n        chmax(dp[i+1][j+1][k],dp[i][j][k]+(s[i]==t[j]));\n        chmax(dp[i+1][j+1][k],dp[i][j+1][k]);\n        chmax(dp[i+1][j+1][k],dp[i+1][j][k]);\n        if(k<m)chmax(dp[i+1][j+1][k+1],dp[i][j][k]+1);\n    }\n    \n    cout<<dp[n][n][m]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\ntemplate <class T>\nvector<T> Vec(size_t l, T v) { return vector<T>(l, v); }\n\ntemplate <class T, class... Ts>\nauto Vec(size_t l, Ts... ts) {\n    return vector<decltype(Vec<T>(ts...))>(l, Vec<T>(ts...));\n}\n\nauto A = Vec<int>(0, 0);\nauto pre = Vec<int>(0, 0, 0);\nauto dp = Vec<int>(0, 0, 0, 0);\n\nint rec(int L, int R, int K) {\n    if (L > R) return 0;\n    if (dp[L][R][K] >= 0) return dp[L][R][K];\n\n    // 1. A[L]を使わない場合\n    dp[L][R][K] = rec(L + 1, R, K);\n\n    // 2. A[L]を使う場合\n    //    Rの直前にあるA[L]を使う\n    int gain = (pre[R][A[L]] == L ? 1 : 2);\n    dp[L][R][K] = max(dp[L][R][K], rec(L + 1, pre[R][A[L]] - 1, K) + gain);\n\n    // 3. A[L]を変更する場合\n    //    A[L]をA[R]に変えるのが最善\n    if (K > 0) {\n        int gain = (L == R ? 1 : 2);\n        dp[L][R][K] = max(dp[L][R][K], rec(L + 1, R - 1, K - 1) + gain);\n    }\n\n    return dp[L][R][K];\n}\n\nint main() {\n    string S;\n    int K;\n    cin >> S >> K;\n    int N = S.length();\n\n    A = Vec<int>(N + 1, 0);\n    for (int i = 1; i <= N; ++i) {\n        A[i] = S[i - 1] - 'a';\n    }\n\n    pre = Vec<int>(N + 1, 26, -1);\n    // pre[i][c] = j <= iかつA[j] = cなる最大のj\n\n    for (int i = 1; i <= N; ++i) {\n        for (int c = 0; c < 26; ++c) {\n            if (A[i] == c) {\n                pre[i][c] = i;\n            } else {\n                pre[i][c] = pre[i - 1][c];\n            }\n        }\n    }\n    dp = Vec<int>(N + 1, N + 1, K + 1, -1);\n\n    cout << rec(1, N, K) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N = 305;\nint dp[N][N][N] = {}, k;\nchar s[N];\n\nint main()\n{\n    scanf(\"%s%d\", s+1, &k);\n    int n = strlen(s+1);\n    for(int i = 1;i<=n;i++) for(int j = 0;j<=k;j++) dp[i][i][j] = 1, dp[i][i-1][j] = 0;\n    for(int j = 1;j<n;j++){\n        for(int i = 1;i+j<=n;i++){\n            for(int r = 0;r<=k;r++){\n                dp[i][i+j][r] = max(dp[i+1][i+j][r], dp[i][i+j-1][r]);\n                if(s[i] == s[i+j]) dp[i][i+j][r] = max(dp[i][i+j][r], dp[i+1][i+j-1][r]+2);\n                if(r) dp[i][i+j][r] = max(dp[i][i+j][r], dp[i+1][i+j-1][r-1]+2);\n            }\n        }\n    }\n    int ans = dp[1][n][k];\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define mod 1000000007\nusing ll=long long;\nconst int INF=1000000000;\nconst ll LINF=1001002003004005006ll;\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n// ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return true;}return false;}\n \nstruct IOSetup{\n    IOSetup(){\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n        cout<<fixed<<setprecision(12);\n    }\n} iosetup;\n \ntemplate<typename T1,typename T2>\nostream &operator<<(ostream &os,const pair<T1,T2>&p){\n    os<<p.first<<\" \"<<p.second;\n    return os;\n}\n \ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T>&v){\n    for(int i=0;i<(int)v.size();i++) os<<v[i]<<(i+1==(int)v.size()?\"\":\" \");\n    return os;\n}\n\ntemplate<typename T1,typename T2>\nistream &operator>>(istream &is,pair<T1,T2>&p){\n    is>>p.first>>p.second;\n    return is;\n}\n\ntemplate<typename T>\nistream &operator>>(istream &is,vector<T>&v){\n    for(T &x:v)is>>x;\n    return is;\n}\n\n\nint dp[310][310][610];\nsigned main(){\n    string s;cin>>s;\n    int m;cin>>m;m*=2;\n    int n=(int)s.size();\n    if(m>=n){\n        cout<<n<<endl;\n        return 0;\n    }\n    string t=s;\n    reverse(ALL(t));\n\n    rep(i,n)rep(j,n)rep(k,m+1){\n        chmax(dp[i+1][j+1][k],dp[i][j][k]+(s[i]==t[j]));\n        chmax(dp[i+1][j+1][k],dp[i][j+1][k]);\n        chmax(dp[i+1][j+1][k],dp[i+1][j][k]);\n        if(k<m)chmax(dp[i+1][j+1][k+1],dp[i][j][k]+1);\n    }\n    \n    cout<<dp[n][n][m]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i, a, b) for (int i = (a); i < (b); ++i)\n#define F2(i, a, b) for (int i = (a); i <= (b); ++i)\n#define dF(i, a, b) for (int i = (a); i > (b); --i)\n#define dF2(i, a, b) for (int i = (a); i >= (b); --i)\n#define maxn 310\nusing namespace std;\ntypedef long long LL;\nchar ss[maxn];\nint dp[maxn][maxn][maxn];\nint main() {\n    int k;\n    scanf(\"%s%d\", ss, &k);\n    int n = strlen(ss), ans=0;\n    dF2(l, n-1, 0) {\n        F(r, l, n) {\n            F2(x, 0, k) {\n                dp[l][r][x] = max(dp[l+1][r][x], dp[l][r-1][x]);\n                if (ss[l]==ss[r]) dp[l][r][x] = max(dp[l][r][x], dp[l+1][r-1][x]+(l==r?1:2));\n                if (x) dp[l][r][x] = max(dp[l][r][x], dp[l+1][r-1][x-1]+(l==r?1:2));\n                ans = max(ans, dp[l][r][x]);\n            }\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring S;\nint K;\nvector<int> P[26];\n\nint cc[302][302][302];\nint dp(int l, int r, int k) {\n    if(l > r) return 0;\n    int &ret = cc[l][r][k];\n    if(ret != -1) return ret;\n\n    ret = 0;\n    ret = max(ret, dp(l + 1, r, k));\n\n    int s = 0, e = (int)P[ S[l] - 'a' ].size() - 1, p = -1;\n    while(s <= e) {\n        int m = (s + e)>>1;\n\n        if(P[ S[l] - 'a' ][m] <= r) {\n            p = P[ S[l] - 'a' ][m];\n            s = m + 1;\n        }\n        else e = m - 1;\n    }\n\n    if(l <= p && p <= r) {\n        ret = max(ret, (p == l? 1 : 2) + dp(l + 1, p - 1, k));\n    }\n\n    if(S[l] != S[r] && k) {\n        ret = max(ret, (l == r? 1 : 2) + dp(l + 1, r - 1, k - 1));\n    }\n    return ret;\n}\n\nint main() {\n    cin >> S >> K;\n\n    for(int i = 0; i < S.size(); i++) {\n        P[ S[i] - 'a' ].push_back(i);\n    }\n\n    memset(cc, -1, sizeof(cc));\n    printf(\"%d\", dp(0, (int)S.size() - 1, K));\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cout<<#v<<\":\";for(int i=0;i<v.size();i++) cout<<\" \"<<v[i]; cout<<endl\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\nconst int inf = 1000000001;\nconst ll INF = 2e18;\n#define MOD 1000000007\n#define mod 1000000009\n#define pi 3.14159265358979323846\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\n\nint main() {\n\tstring s;\n\tcin >> s;\n\tint k;\n\tcin >> k;\n\tint n = s.size();\n\tstring s2;\n\ts2 = s;\n\treverse(s2.begin(), s2.end());\n\tvii dp(n + 1, vi(n + 1));\n\tif (k >= 2) {\n\t\trep(i, n) {\n\t\t\trep(j, n) {\n\t\t\t\tif (s[i] == s2[j]) {\n\t\t\t\t\tdp[i + 1][j + 1] = dp[i][j] + 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << min(n, dp[n][n] + 2 * k) << endl;\n\t}\n\telse {\n\t\trep(i0, n) {\n\t\t\tstring t = s;\n\t\t\tt[i0] = '?';\n\t\t\tstring s2 = t;\n\t\t\treverse(s2.begin(), s2.end());\n\t\t\trep(i, n) {\n\t\t\t\trep(j, n) {\n\t\t\t\t\tif (t[i] == s2[j] || t[i] == '?' || s2[j] == '?') {\n\t\t\t\t\t\tdp[i + 1][j + 1] = dp[i][j] + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[n][n]  << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N = 305;\n\nint dp[2][MAX_N][MAX_N];\nchar S[MAX_N];\n\nint main() {\n  scanf(\"%s\", S + 1);\n  int N = strlen(S + 1), K;\n  scanf(\"%d\", &K);\n\n  memset(dp, -0x3f, sizeof dp);\n\n  int o = 0, p, result = 1;\n  dp[0][N + 1][0] = 0;\n  \n  for (int i = 1; i <= N; ++i) {\n    p = o, o ^= 1;\n    memset(dp[o], -0x3f, sizeof dp[o]);\n    dp[o][N + 1][0] = 0;\n    for (int j = N; j > i; --j)\n      for (int k = 0; k <= K; ++k) {\n\tdp[o][j][k] = max(dp[o][j + 1][k], dp[p][j][k]);\n\tif (S[i] == S[j]) dp[o][j][k] = max(dp[o][j][k], dp[p][j + 1][k] + 1);\n\telse if (k > 0) dp[o][j][k] = max(dp[o][j][k], dp[p][j + 1][k - 1] + 1);\n      }\n    for (int k = 0; k <= K; ++k) {\n      result = max(result, dp[o][i + 1][k] * 2);\n      result = max(result, dp[o][i + 2][k] * 2 + 1);\n    }\n  }\n\n  printf(\"%d\\n\", result);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 3e2 + 10;\nint dp[N][N][N];\n\nint main()\n{\n\tstring s;\n\tcin >> s;\n\tint k;\n\tcin >> k;\n\tint n = s.size();\n\tfor (int tool = 1; tool <= n; tool++)\n\t{\n\t\tfor (int l = 0; l + tool <= n; l++)\n\t\t{\n\t\t\tint r = l + tool - 1;\n\t\t\tif (tool == 1)\n\t\t\t{\n\t\t\t\tfor (int kk = 0; kk <= k; kk++)\n\t\t\t\t{\n\t\t\t\t\tdp[l][r][kk] = 1;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int kk = 0; kk <= k; kk++)\n\t\t\t{\n\t\t\t\tif (kk > tool)\n\t\t\t\t{\n\t\t\t\t\tdp[l][r][kk] = dp[l][r][tool];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (s[l] == s[r])\n\t\t\t\t{\n\t\t\t\t\tdp[l][r][kk] = 2 + dp[l + 1][r - 1][kk];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (kk == 0)\n\t\t\t\t{\n\t\t\t\t\tdp[l][r][kk] = max(dp[l + 1][r][kk], dp[l][r - 1][kk]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdp[l][r][kk] = max({2 + dp[l + 1][r - 1][kk - 1], dp[l + 1][r][kk], dp[l][r - 1][kk]});\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][n - 1][k];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 305;\nint dp[2][N][N];\nchar s[N];\nint dfs(int l, int r, int dp[N][N]) {\n\tint &res = dp[l][r];\n\tif (dp[l][r] != -1) return dp[l][r];\n\tif (l > r) return res = 0;\n\tres = 0;\n\tif (s[l] == s[r]) res = dfs(l + 1, r - 1, dp) + (l == r ? 1 : 2);\n\tres = max(res, dfs(l + 1, r, dp));\n\tres = max(res, dfs(l, r - 1, dp));\n\treturn res;\n}\nint dfs2(int l, int r, int dp[N][N], int fr[N][N]) {\n\tint &res = dp[l][r];\n\tif (dp[l][r] != -1) return dp[l][r];\n\tif (l > r) return res = 0;\n\tres = 0;\n\tif (s[l] == s[r]) res = dfs2(l + 1, r - 1, dp, fr) + (l == r ? 1 : 2);\n\tres = max(res, fr[l + 1][r - 1] + (l == r ? 1 : 2));\n\tres = max(res, dfs2(l + 1, r, dp, fr));\n\tres = max(res, dfs2(l, r - 1, dp, fr));\n\treturn res;\n}\nint main() {\n\tscanf(\"%s\", s + 1);\n\tint n = strlen(s + 1), k;\n\tscanf(\"%d\", &k);\n\tmemset(dp, -1, sizeof(dp));\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tfor (int j = i; j <= n; ++ j) {\n\t\t\tdfs(i, j, dp[0]);\n\t\t}\n\t}\n\tint cur = 0;\n\tint ans = dp[cur][1][n];\n\tfor (int i = 1; i <= k; ++ i) {\n\t\tcur ^= 1;\n\t\tmemset(dp[cur], -1, sizeof(dp[cur]));\n\t\tfor (int i = 1; i <= n; ++ i) {\n\t\t\tfor (int j = i + 1; j <= n; ++ j) {\n\t\t\t\tdfs2(i, j, dp[cur], dp[cur ^ 1]);\n\t\t\t}\n\t\t}\n\t\tans = max(ans, dp[cur][1][n]);\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\ntypedef long long ll;\ninline void Fail(){printf(\"0\");exit(0);}\n\nconst int maxn=305;\nint n,lim,ans;\nchar c[maxn];\nstring s;\nint dp[maxn][maxn][maxn];\n\nint main(){\n\tscanf(\"%s%d\",c,&lim);\n\ts=c;n=s.size();\n\tif(n==1)ans=1;\n\trep(i,n/2)rep(j,n/2)rep(k,lim+1){\n\t\tif(s[i]==s[n-j-1])dp[i][j][k]=(i>=1&&j>=1?dp[i-1][j-1][k]:0)+1;\n\t\tif(i>=1)dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k]);\n\t\tif(j>=1)dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k]);\n\t\tif(s[i]!=s[n-j-1]){\n\t\t\tif(k>=1)dp[i][j][k]=max((i>=1&&j>=1?dp[i-1][j-1][k-1]:0)+1,dp[i][j][k]);\n\t\t}\n\t\tans=max(ans,dp[i][j][k]*2+(n&1));\n\t}\n\trep(i,n/2)for(int j=(n+1)/2;j<n;j++)rep(k,lim+1){\n\t\tif(s[i]==s[n-j-1])dp[i][j][k]=(i>=1&&j>(n+1)/2?dp[i-1][j-1][k]:0)+1;\n\t\tif(i>=1)dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k]);\n\t\tif(j>=1)dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k]);\n\t\tif(s[i]!=s[n-j-1]){\n\t\t\tif(k>=1)dp[i][j][k]=max((i>=1&&j>(n+1)/2?dp[i-1][j-1][k-1]:0)+1,dp[i][j][k]);\n\t\t}\n//\t\tcout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<dp[i][j][k]<<endl;\n\t\tans=max(ans,dp[i][j][k]+(n-j-2>=0?dp[n-j-2][n/2-1][lim-k]:0)*2);\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n\n/*\nInput:\nabcabcabc\ncbacbacba\n1\natcodergrandcontest\ntsetnocdnargredocta\n3\n-----------------\nOutput:\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for(int i = x; i < (int)(n); ++i)\n\nchar in[302];\nint dp[301][301][301], k;\n\ninline int go(string a, string b){\n\treverse(b.begin(), b.end());\n\tint n = a.size(), m = b.size();\n\tf(i, 1, n + 1)f(j, 1, m + 1)f(w, 0, k + 1){\n\t\tif (a[i - 1] == b[j - 1])dp[i][j][w] = 1 + dp[i - 1][j - 1][w];\n\t\telse {\n\t\t\tdp[i][j][w] = max(dp[i - 1][j][w], dp[i][j - 1][w]);\n\t\t\tif (w)dp[i][j][w] = max(dp[i][j][w], 1 + dp[i - 1][j - 1][w - 1]);\n\t\t}\n\t}\n\treturn dp[n][m][k];\n}\n\nint main(){\n\tscanf(\"%s%d\", in, &k);\n\tstring s = in;\n\tint n = s.size();\n\tint an = 1;\n\tf(i, 1, n){\n\t\tint t = go(s.substr(0, i), s.substr(i, n - i));\n\t\tan = max(an, t << 1);\n\t}\n\tf(i, 1, n - 1){\n\t\tint t = go(s.substr(0, i), s.substr(i + 1, n - i - 1));\n\t\tan = max(an, t << 1 | 1);\n\t}\n\tprintf(\"%d\\n\", an);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rg register\nusing namespace std;\n\nconst int N = 300+10;\nchar str[N];\nint k,n;\nint f[N][N][N];\n\n\nint ck(int x,int y){\n\tif(x!=y && str[x]==str[y]) return 2;\n\tif(x==y) return 1;\n\treturn 0;\n}\n\nint main(){\n\t//freopen(\"d.in\",\"r\",stdin);\n\t//freopen(\"d.out\",\"w\",stdout);\n\tscanf(\"%s\",str+1);\t\t\n\tn=strlen(str+1);\n\tscanf(\"%d\",&k);\n\n\tint ans=0;\n\tfor(int i=1; i<=n; ++i)\n\t\tfor(int j=n; j>=i; --j)\n\t\t\tfor(int t=0; t<=k; ++t){\n\t\t\t\tint x=i+1,y=j-1,c=(bool)(str[i]!=str[j]);\n\t\t\t\t\tif(x<=y&&t+c<=k) f[t+c][x][y]=max(f[t+c][x][y],f[t][i][j]+2);\n\t\t\t\t\tif(x-1==y){\n\t\t\t\t\t\tif(t+c<=k) ans=max(ans,f[t][i][j]+2);\n\t\t\t\t\t}\n\t\t\t\t\tif(x-2==y){\n\t\t\t\t\t\tif(t+c<=k) ans=max(ans,f[t][i][j]+1);\n\t\t\t\t\t}\n\n\t\t\t\t\tf[t][x][y]=max(f[t][x][y],f[t][i][j]);\n\t\t\t\t\tf[t][i][y]=max(f[t][i][y],f[t][i][j]);\n\t\t\t\t\tf[t][x][j]=max(f[t][x][j],f[t][i][j]);\n\t\t\t\t\tans=max(ans,f[t][i][j]);\n\t\t\t}\n\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define rep(i, s, t) for(i = s; i <= t; ++i)\n#define dep(i, s, t) for(i = s; i >= t; --i)\n\nusing namespace std;\n\nconst int N = 310;\nint n, m, K, ans;\nchar s[N], t[N];\nint f[N][N][N];\n\nint main() {\n\tint i, j, k;\n\tscanf(\"%s\", s+1); n = strlen(s+1);\n\tm = n >> 1;\n\trep(i, 1, n) t[i] = s[n-i+1];\n\t\n\tscanf(\"%d\", &K);\n\trep(i, 1, n-1) {\n\t\trep(j, 1, n-i) \n\t\t\trep(k, 0, K) {\n\t\t\t\tf[i][j][k] = max(f[i-1][j][k], f[i][j-1][k]);\n\t\t\t\tif(k) f[i][j][k] = max(f[i][j][k], f[i][j][k-1]);\n\t\t\t\tif(s[i] == t[j]) {\n\t\t\t\t\tf[i][j][k] = max(f[i-1][j-1][k]+1, f[i][j][k]);\n\t\t\t\t} else {\n\t\t\t\t\tif(k) f[i][j][k] = max(f[i-1][j-1][k-1]+1, f[i][j][k]);\n\t\t\t\t}\n\t\t\t\t//printf(\"%d %d %d %d\\n\", i, j, k, f[i][j][k]);\n\t\t\t}\n\t\tif(n&1) ans = max(ans, f[i][n-i-1][K]*2+1);\n\t\tans = max(ans, f[i][n-i][K]*2);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#define int ll\n//#define char ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(4) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int N = 333;\nshort dp[N][N][N];\n\n\nvoid smain() {\n\n\n    string s;\n    cin >> s;\n    int k;\n    cin >> k;\n    int n = s.size();\n    string t = s;\n    reverse(ALL(t));\n\n\n    fori (i, N) {\n        fori (j, N) {\n            fori (k, N) {\n                dp[i][j][k] = n * 3;\n            }\n        }\n    }\n\n    dp[0][0][0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            for (int len = 0; len < n; ++len) if (dp[i][j][len] < n * 3) {\n                inmin(dp[i + 1][j][len], dp[i][j][len]);\n                inmin(dp[i][j + 1][len], dp[i][j][len]);\n                if (s[i] == t[j])\n                    inmin(dp[i + 1][j + 1][len + 1], dp[i][j][len]);\n                else {\n                    inmin(dp[i + 1][j + 1][len + 1], (short)(dp[i][j][len] + 1));\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    fori (i, n + 1) {\n        fori (j, n + 1) {\n            fori (len, n + 1) {\n                if (dp[i][j][len] <= k * 2) {\n                    inmax(ans, len);\n                }\n            }\n        }\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing ull = unsigned long long; \nusing pii =  pair<int, int>;\nusing pll =  pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\nconstexpr long long MOD = 1000000007LL;\n//constexpr long long MOD = 998244353LL;\ntemplate<class T, class U> inline bool chmax(T &a, U b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T, class U> inline bool chmin(T &a, U b) { if (a > b) { a = b; return true;} return false; }\n////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint dp[330][330][330];\nint pre[330][26];\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    string S; cin >> S;\n    int K; cin >> K;\n    int N = S.size();\n\n    rep(i,N) {\n        rep(j,26) {\n            if (i) pre[i][j] = pre[i-1][j];\n            else pre[i][j] = -1;\n        }\n        pre[i][S[i]-'a'] = i;\n    }\n\n    rep(i,N+1) rep(j,N+1) rep(k,K+1) dp[i][j][k] = -1;\n    dp[0][0][0] = N;\n    rep(i,N) {\n        rep(j,N+1) {\n            rep(k,K+1) {\n                if (dp[i][j][k]==-1) continue;\n                if (dp[i][j][k] > i) chmax(dp[i+1][j][k],dp[i][j][k]);\n                int num = dp[i][j][k];\n                if (num and pre[num-1][S[i]-'a'] > i) chmax(dp[i+1][j+1][k],pre[num-1][S[i]-'a']);\n                if (k < K and num-1 > i) chmax(dp[i+1][j+1][k+1],num-1);\n            }\n        }\n    }\n    int ans = 0;\n    rep(i,N+1) {\n        rep(j,N+1) {\n            rep(k,K+1) {\n                if (dp[i][j][k]==-1) continue;\n                if (dp[i][j][k] > i) chmax(ans,j*2+1);\n                else chmax(ans,j*2);\n            }\n        }\n    }\n\n    cout << ans << ln;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(int x) { return 8*sizeof(int)-__builtin_clz(x); }\n\nnamespace std {\n    template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};\n}\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\ntemplate <typename T> struct bounded_priority_queue {\n\tinline bounded_priority_queue(ui X) : A(X), B(0), s(0) {}\n\tinline void push(ui L, T V) { B = max(B, L); A[L].push(V); ++s; }\n\tinline const T &top() const { return A[B].front(); }\n\tinline void pop() { --s; A[B].pop(); while (B > 0 && A[B].empty()) --B; }\n\tinline bool empty() const { return A[B].empty(); }\n\tinline void clear() { s = B = 0; for (auto &a: A) a = queue<T>(); }\n\tinline ui size() const { return s; }\nprivate:\n\tvector<queue<T>> A; ui B; int s;\n};\n\n\n#endif\n// #include \"../l/mod.h\"\n\nclass D {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        string S; cin >> S;\n        int K; cin >> K;\n        string T = S;\n        reverse(T.begin(),T.end());\n        int N = S.size();\n        vector3<int> L(N+1,N+1,N+2,-1);\n        for (int i = 1; i <= N; ++i) {\n            L[0][i][0] = L[i][0][0] = 0;\n        }\n        L[0][0][0] = 0;\n\n        for (int i = 1; i <= N; ++i) {\n            for (int j = 1; j <= N; ++j) {\n                for (int k = 0; k <= N; ++k) {\n                    L[i][j][k] = max(L[i][j][k], L[i-1][j][k]);\n                    L[i][j][k] = max(L[i][j][k], L[i][j-1][k]);\n                    if (S[i-1] == T[j-1]) {\n                        L[i][j][k] = max(L[i][j][k], 1 + L[i-1][j-1][k]);\n                    } else if (L[i-1][j-1][k] >= 0 && (i+j < N)) {\n                        L[i][j][k+1] = max(L[i][j][k+1], L[i-1][j-1][k]);\n                    }\n                }\n            }\n        }\n//        cerr << L;\n        int ans = 0;\n        for (int i = 0; i <= N; ++i) {\n            int j = N-i;\n            for (int k = 0; k <= N; ++k) {\n                int pairs = min(k,K);\n//                cerr << i << ' ' << j << ' ' << k << ' ' << L[i][j][k] << ' ' << pairs << endl;\n                ans = max(ans, 2*L[i][j][k] + pairs + K);\n            }\n\n            j = N-i+1;\n            if (j <= N) {\n                for (int k = 0; k <= N; ++k) {\n                    int pairs = min(k, K);\n//                cerr << i << ' ' << j << ' ' << k << ' ' << L[i][j][k] << ' ' << pairs << endl;\n                    ans = max(ans, 2 * L[i][j][k] + pairs + K - 1);\n                }\n            }\n\n        }\n        cout << min(N, ans) << endl;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tD solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=305;\nchar s[N];\nint dp[N][N][N],K;\nint main(){\n\tscanf(\"%s%d\",s,&K);\n\tint n=strlen(s);\n\tfor (int i=0;i<n;i++)\n\t\tfor (int k=0;k<=K;k++)dp[i][i][k]=1;\n\tfor (int l=1;l<n;l++)\n\t\tfor (int i=0;i+l<n;i++){\n\t\t\tint j=i+l;\n\t\t\tfor (int k=0;k<=K;k++){\n\t\t\t\tdp[i][j][k]=max(dp[i+1][j][k],dp[i][j-1][k]);\n\t\t\t\tif (k>0)dp[i][j][k]=max(dp[i+1][j-1][k-1]+2,dp[i][j][k]);\n\t\t\t\tif (s[i]==s[j])dp[i][j][k]=max(dp[i+1][j-1][k]+2,dp[i][j][k]);\n\t        }\n\t    }\n\tprintf(\"%d\\n\",dp[0][n-1][K]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-8\n#define pi 3.14159265358979\n#define LL long long\n#define MP make_pair\n#define PH push\n#define PB push_back\n#define PII pair<int,int>\n#define VI vector<int>\n#define X first\n#define Y second\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\n#define sqr(x) ((x)*(x))\n#define CL(a) memset(a,0,sizeof a)\n#define fr(i,n) for(int i=1;i<=n;i++)\n#define FR(i,S,n) for(int i=S;i<=n;i++)\n#define dr(i,n) for(int i=n;i;i--)\n#define DR(i,n,S) for(int i=n;i>=S;i--)\n#define SZ(x) ((int)(x).size())\n#define rd(x) scanf(\"%d\",&x)\n#define pr(x) printf(\"%d\",x)\nconst int N=305;\nLL Pw(LL a,LL b,LL p){LL v=1;for(;b;b>>=1,a=a*a%p)if(b&1)v=v*a%p;return v;}\nusing namespace std;\nint n,m,f[N][N][N];char s[N];bool v[N][N][N];\nint dp(int l,int r,int k){\n\tif(k<0)return -1e9;\n\tif(l>r)return 0;\n\tif(l==r)return 1;\n\tif(v[l][r][k])return f[l][r][k];v[l][r][k]=1;\n\tint an=max(dp(l+1,r,k),dp(l,r-1,k));\n\tan=max(an,dp(l+1,r-1,k-(s[l]!=s[r]))+2);\n\treturn f[l][r][k]=an;\n}\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);rd(m);\n\tprintf(\"%d\\n\",dp(1,n,m));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\nconst ll MOD = 1e9+7;\nconst ll MOD2 = 998244353;\nconst ll INF = LLONG_MAX;\nconst string alpha = \"abcdefghijklmnopqrstuvwxyz\";\n\nint main(){\n    string S;\n    int K;\n    cin >> S >> K;\n    int N = S.size();\n    int dp[N][N][K+1];\n    rep(i, K+1){\n        rep(j, 2*i+1){\n            rep(k, N-j){\n                dp[k][k+j][i] = j+1;\n            }\n        }\n        rep2(j, 2*i+1, N-1){\n            rep(k, N-j){\n                if(S[k] == S[k+j]){\n                    if(j == 1 && i == 0) dp[k][k+j][i] = 2;\n                    else dp[k][k+j][i] = dp[k+1][k+j-1][i]+2;\n                }\n                else{\n                    dp[k][k+j][i] = max(dp[k+1][k+j][i], dp[k][k+j-1][i]);\n                    if(i > 0){\n                        dp[k][k+j][i] = max(dp[k][k+j][i], dp[k+1][k+j-1][i-1]+2);\n                    }\n                }\n            }\n        }\n    }\n    cout << dp[0][N-1][K] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define ll long long\n#define max(a,b) (a>b?a:b)\n#define min(a,b) (a<b?a:b)\n#define inf 0x3f3f3f3f\n#define mod 1000000007\n#define eps 1e-18\ninline ll read()\n{\n    ll tmp=0; char c=getchar(),f=1;\n    for(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n    for(;'0'<=c&&c<='9';c=getchar())tmp=(tmp<<3)+(tmp<<1)+c-'0';\n    return tmp*f;\n}\nusing namespace std;\nchar s[310];\nint f[2][310][310];\nint n,m;\nint main()\n{\n\tint i,j,k;\n\tscanf(\"%s\",s); n=strlen(s); m=read();\n\tint ans=0;\n\tfor(k=0;k<=m;k++){\n\t\tfor(i=0;i<n;i++)\n\t\t\tf[k&1][i][i]=1,f[k&1][i+1][i]=0;\n\t\tfor(i=1;i<n;i++)\n\t\t\tfor(j=0;j+i<n;j++){\n\t\t\t\tint l=j,r=j+i;\n\t\t\t\tf[k&1][l][r]=max(f[k&1][l+1][r],f[k&1][l][r-1]);\n\t\t\t\tif(s[l]==s[r])f[k&1][l][r]=max(f[k&1][l][r],f[k&1][l+1][r-1]+2);\n\t\t\t\telse if(k>0)f[k&1][l][r]=max(f[k&1][l][r],f[(k&1)^1][l+1][r-1]+2);\n\t\t\t}\n\t\t\n\t\tans=max(ans,f[k&1][0][n-1]);\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define rep(i, j) for (register int i = 0, i##_end_ = (j); i < i##_end_; ++ i)\n#define For(i, j, k) for (register int i = (j), i##_end_ = (k); i <= i##_end_; ++ i)\n#define Fordown(i, j, k) for (register int i = (j), i##_end_ = (k); i >= i##_end_; -- i)\n#define Set(a, b) memset(a, b, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define fir first\n#define sec second\n#define pb(a) push_back(a)\n#define mp(a, b) make_pair(a, b)\n#define ALL(a) (a).begin(), (a).end()\n#define SZ(a) ((int)(a).size())\n#define INF (0x3f3f3f3f)\n#define INF1 (2139062143)\n#define Mod (1000000007)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define y1 wozenmezhemecaia\n\ntemplate <typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\n\ninline int read()\n{\n    register int _, __; register char c_;\n    for (_ = 0, __ = 1, c_ = getchar(); c_ < '0' || c_ > '9'; c_ = getchar()) if (c_ == '-') __ = -1;\n    for ( ; c_ >= '0' && c_ <= '9'; c_ = getchar()) _ = (_ << 1) + (_ << 3) + (c_ ^ 48);\n    return _ * __;\n}\n\ninline void File()\n{\n#ifdef hany01\n    freopen(\"agc021d.in\", \"r\", stdin);\n    freopen(\"agc021d.out\", \"w\", stdout);\n#endif\n}\n\nconst int maxn = 310;\n\nchar s[maxn];\nint n, k, f[maxn][maxn][maxn];\n\nint main()\n{\n    File();\n    scanf(\"%s\", s + 1), n = strlen(s + 1), k = read();\n    For(len, 1, n)\n        For(st, 1, n - len + 1) {\n            register int ed = st + len - 1;\n            For(i, 0, k) {\n                if (st == ed) f[st][ed][i] = 1;\n                else if (st + 1 == ed) f[st][ed][i] = i || s[st] == s[ed] ? 2 : 1;\n                else {\n                    f[st][ed][i] = max(f[st + 1][ed][i], f[st][ed - 1][i]);\n                    if (s[st] == s[ed]) chkmax(f[st][ed][i], f[st + 1][ed - 1][i] + 2);\n                    if (i) chkmax(f[st][ed][i], f[st + 1][ed - 1][i - 1] + 2);\n                }\n            }\n        }\n    printf(\"%d\\n\", f[1][n][k]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\n#define rint register int\n#define gc() getchar()\ninline int read(rint ans = 0, rint sgn = ' ', rint ch = gc())\n{\n\tfor(; ch < '0' || ch > '9'; sgn = ch, ch = gc());\n\tfor(; ch >='0' && ch <='9';(ans*=10)+=ch-'0', ch = gc());\n\treturn sgn-'-'?ans:-ans;\n}\nint f[305][305], n, K, Ans; char T[305], R[305];\nvoid DP1(int a, int b)\n{\n\tfor(rint i = a; i <= n; f[i][b] = 0, i++); for(rint j = b; j <= n; f[a][j] = 0, j++);\n\tfor(rint i = a+1, j; i <= n; i++) for(j = b+1; j <= n; f[i][j] = T[i]^R[j]?max(f[i-1][j],f[i][j-1]):f[i-1][j-1]+1, j++);\n}\nvoid DP2(int a, int b)\n{\n\tfor(rint i = 1; i <= a; f[i][b] = 0, i++); for(rint j = 1; j <= b; f[a][j] = 0, j++);\n\tfor(rint i = a-1, j; i; i--) for(j = b-1; j; f[i][j] = T[i]^R[j]?max(f[i+1][j],f[i][j+1]):f[i+1][j+1]+1, j--);\n}\nint main()\n{\n\tscanf(\"%s\",T+1), n = strlen(T+1), reverse_copy(T+1,T+n+1,R+1), K = read();\n\tfor(rint i = 1; i <= n; i++)\n\t\tDP1(i,n-i+1), DP2(i,n-i+1), Ans = max(Ans,f[1][1]+f[n][n]+1+2*min(K,max(min(i-1-f[1][1],n-i-f[n][n]),0)));\n\tfor(rint i = 1; i <  n; i++)\n\t\tDP1(i,n-i+1), DP2(i+1,n-i), Ans = max(Ans,f[1][1]+f[n][n]+2*min(K,max(min(i-f[1][1],n-i+1-f[n][n]),0)));\n\tprintf(\"%d\\n\",Ans); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nstring S;\n\nint dp[303][303][303];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>S>>K;\n\tN=S.size();\n\t\n\tFOR(i,N) {\n\t\tdp[i][i][K]=1;\n\t\tif(i<N-1) {\n\t\t\tdp[i][i+1][K]=2*S[i]==S[i+1];\n\t\t\tif(K) dp[i][i+1][K-1]=2;\n\t\t}\n\t}\n\t\n\t\n\t\n\tfor(i=1;i<=N;i++) {\n\t\tfor(int L=0;L+i<=N;L++) {\n\t\t\tint R=L+i-1;\n\t\t\tfor(k=0;k<=K;k++) {\n\t\t\t\tif(L) dp[L-1][R][k]=max(dp[L-1][R][k],dp[L][R][k]);\n\t\t\t\tif(R<N-1) dp[L][R+1][k]=max(dp[L][R+1][k],dp[L][R+1][k]);\n\t\t\t\tif(L&&R<N-1) {\n\t\t\t\t\tdp[L-1][R+1][k]=max(dp[L-1][R+1][k],dp[L][R][k]+2*(S[L-1]==S[R+1]));\n\t\t\t\t\tif(k) dp[L-1][R+1][k-1]=max(dp[L-1][R+1][k-1],dp[L][R][k]+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ma=0;\n\tFOR(i,K+1) ma=max(ma,dp[0][N-1][i]);\n\tcout<<ma<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstring s;\nint lim,n;\nint mn[305][305][26],mx[305][305][26],dp[305][305][155];\nint rec(int a,int b,int c){\n\tif(dp[a][b][c] >= 0) return dp[a][b][c];\n\tif(a>b) return 0;\n\tint &ret = dp[a][b][c];\n\tint len = (a==b?1:2);\n\tif(c) ret=max(ret,rec(a+1,b-1,c-1)+len);\n\tfor(int k=0;k<26;k++){\n\t\tif(mx[a][b][k] == -INF) continue;\n\t\tint d = mn[a][b][k]-a;\n\t\tint e = b-mx[a][b][k];\n\t\td = min(d,e);\n\t\tint len = (mn[a][b][k]==mx[a][b][k]?1:2);\n\t\tret = max(ret,len+rec(mn[a][b][k]+1,mx[a][b][k]-1,c-min(c,d))+min(c,d)*2);\n\t}\n\treturn ret;\n}\nint main(){\n\tcin>>s>>lim;\n\tn = s.size();\n\trep(a,305)rep(b,305)rep(c,26){\n\t\tmn[a][b][c] = INF;\n\t\tmx[a][b][c] = -INF;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i;j<n;j++){\n\t\t\tfor(int k=i;k<=j;k++){\n\t\t\t\tmx[i][j][s[k]-'a'] = max(mx[i][j][s[k]-'a'],k);\n\t\t\t\tmn[i][j][s[k]-'a'] = min(mn[i][j][s[k]-'a'],k);\n\t\t\t}\n\t\t}\n\t}\n\tlim = min(n/2+1,lim);\n\trep(a,305)rep(b,305)rep(c,155)dp[a][b][c] = -INF;\n\tcout << rec(0,n-1,lim) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 330;\n\ninline void smax(int &x, int y) { if (x < y) x = y; }\n\nint dp[N][N][N];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  string s;\n  cin >> s;\n  int k;\n  cin >> k;\n  int n = (int) s.size();\n  for (int i = n; i > 0; i--) {\n    for (int j = 1; j <= n; j++) {\n      for (int r = 0; r <= k; r++) {\n        smax(dp[i][j][r], dp[i + 1][j][r]);\n        smax(dp[i][j][r], dp[i][j - 1][r]);\n        if (s[i - 1] == s[j - 1]) {\n          smax(dp[i][j][r], dp[i + 1][j - 1][r] + 1);\n        } else if (r > 0) {\n          smax(dp[i][j][r], dp[i + 1][j - 1][r - 1] + 1 + (i < j));\n        }\n      }\n    }\n  }\n  cout << dp[1][n][k] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define enum(i,x,y) for(int i=(x);i<=(y);++i)\n#define try(i,x,y) for(int i=(x);i>=(y);--i)\ntemplate <typename TYPE> inline void chkmax(TYPE &x,TYPE y){x<y?x=y:0;}\ntemplate <typename TYPE> inline void chkmin(TYPE &x,TYPE y){y<x?x=y:0;}\ntemplate <typename TYPE> void readint(TYPE &x)\n{\n    x=0;int f=1;char c;\n    for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;\n    for(;isdigit(c);c=getchar())x=x*10+c-'0';\n    x*=f;\n}\nconst int MAXN=305;\n\nint n,m;\nchar s[MAXN];\nint f[MAXN][MAXN][MAXN];\n\nint main()\n{\n\t#ifndef ONLINE_JUDGE\n    //freopen(\"code.in\",\"r\",stdin);\n    //freopen(\"code.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%s\",s+1);readint(m);n=strlen(s+1);\n\tenum(i,1,n)\n\t\tenum(k,0,m)\n\t\t\tf[i][i][k]=1;\n\tenum(len,2,n)\n\t\tenum(i,1,n-len+1)\n\t\t{\n\t\t\tint j=i+len-1;\n\t\t\tenum(k,0,m)\n\t\t\t{\n\t\t\t\tf[i][j][k]=max(f[i+1][j][k],f[i][j-1][k]);\n\t\t\t\tif(s[i]==s[j])chkmax(f[i][j][k],f[i+1][j-1][k]+2);\n\t\t\t\tif(k)chkmax(f[i][j][k],f[i+1][j-1][k-1]+2);\n\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\",f[1][n][m]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 303;\nint dp[maxn][maxn][maxn];\nchar s[maxn];\nint main()\n{\n    int a;\n    scanf(\"%s%d\",s+1,&a);\n    int len = strlen(s+1);\n    for(int j=1; j<=len; ++j)\n    {\n        for(int i=j; i>=1; --i)\n        {\n            for(int k=0; k<=a; ++k)\n            {\n                if(i==j)\n                {\n                    dp[i][j][k] = 1;\n                    continue;\n                }\n                dp[i][j][k] = max(dp[i+1][j-1][k]+((s[i]==s[j])?2:0),max(dp[i+1][j][k], dp[i][j-1][k]));\n                if(k>0)\n                {\n                    dp[i][j][k] = max(dp[i][j][k], dp[i][j][k-1]);\n                    dp[i][j][k] = max(dp[i][j][k], dp[i+1][j-1][k-1]+2);\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\",dp[1][len][a]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=305;\nint f[N][N][N],n,K;char s[N];\nint main(){\n  //freopen(\"pp.in\",\"r\",stdin);\n  //freopen(\"pp.out\",\"w\",stdout);\n  scanf(\"%s%d\",s+1,&K);n=strlen(s+1);\n  for(int i=1;i<=n;i++)\n      for(int k=0;k<=K;k++)f[i][i][k]=1;\n  for(int len=2;len<=n;len++){\n      for(int i=1;i+len-1<=n;i++){\n          int j=i+len-1;\n          for(int k=0;k<=K;k++){\n              f[i][j][k]=max(f[i+1][j][k],f[i][j-1][k]);\n              if(s[i]==s[j])f[i][j][k]=max(f[i][j][k],f[i+1][j-1][k]+2);\n              if(k)f[i][j][k]=max(f[i][j][k],f[i+1][j-1][k-1]+2);\n          }\n      }\n  }\n  cout<<f[1][n][K]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint dp[302][302][302];\n\nint main()\n{\n    string s;\n    cin >> s;\n    int n = s.size();\n    int m;\n    cin >> m;\n    if(n == 1){\n        cout << 1 << endl;\n        return 0;\n    }\n    for(int k = 0; k <= m; k++){\n        for(int i = 0; i <= n; i++){\n            for(int j = 0; j <= n; j++){\n                if(i > 0) dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k]);\n                if(j > 0) dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k]);\n                if(k > 0) dp[i][j][k] = max(dp[i][j][k], dp[i][j][k - 1]);\n                if(i > 0 && j > 0){\n                    if(s[i - 1] == s[n - j]) dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + 1);\n                    else if(k > 0) dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k - 1] + 1);\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for(int i = 0; i < n; i++){\n        ans = max(ans, dp[i][n - i - 1][m] * 2 + 1);\n    }\n    for(int i = 0; i <= n; i++){\n        ans = max(ans, dp[i][n - i][m] * 2);\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint DP[310][310];\n\nint main()\n{\n\tstring s;\n\tcin>>s;\n\tint k;\n\tcin>>k;\n\tstring s1=s;\n\treverse(s1.begin(),s1.end());\n//\tcout<<s1<<\"\\n\";\n\tint n=s.length();\n\tfor (int i=0;i<n;i++)\n\t for (int j=0;j<n;j++)\n\t {\n\t \tif (s[i]==s1[j])\n\t \t DP[i][j]=DP[i-1][j-1]+1;\n\t \telse\n\t \t DP[i][j]=max(DP[i-1][j],DP[i][j-1]);\n\t }\n//\tcout<<DP[n-1][n-1]<<\"\\n\";\n\tint ans=min(DP[n-1][n-1]+2*k,n);\n\tcout<<ans<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <memory>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#define rep(i, n) for(int i=0;i<(int)(n);i++)\n#define REP(i, n) for(int i=1;i<=(int)(n);i++)\n#define all(V) V.begin(),V.end()\ntypedef long long lint;\ntypedef std::pair<lint, lint> P;\nconstexpr int INF = INT_MAX / 10;\nconstexpr lint LINF = LLONG_MAX / 2;\nconstexpr double eps = 1e-9;\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\n\ntemplate<class T, class Alloc = std::allocator<T>>\nclass Vector {\n\n\tusing traits = std::allocator_traits<Alloc>;\n\npublic:\n\n\tusing value_type = T;\n\tusing allocator_type = Alloc;\n\tusing size_type = unsigned int;\n\tusing difference_type = int;\n\tusing reference = T&;\n\tusing const_reference = const T&;\n\tusing pointer = typename traits::pointer;\n\tusing const_pointer = typename traits::const_pointer;\n\n\tclass iterator {\n\n\tpublic:\n\n\t\tusing difference_type = int;\n\t\tusing value_type = Vector::value_type;\n\t\tusing pointer = Vector::pointer;\n\t\tusing reference = Vector::reference;\n\t\tusing iterator_category = std::random_access_iterator_tag;\n\n\tprivate:\n\n\t\tpointer p;\n\n\tpublic:\n\n\t\titerator()noexcept :p() {}\n\t\titerator(const Vector& base, difference_type index) noexcept :p(base.e + index) {}\n\t\titerator(const iterator& i) :p(i.p) {}\n\n\t\titerator& operator=(const iterator& i) = default;\n\t\titerator& operator=(iterator&& i)noexcept = default;\n\n\t\titerator& operator++() {\n\t\t\tp++;\n\t\t\treturn *this;\n\t\t}\n\n\t\titerator operator++(int) {\n\t\t\titerator res = *this;\n\t\t\tp++;\n\t\t\treturn res;\n\t\t}\n\n\t\titerator operator+(const difference_type& x)const {\n\t\t\titerator res = *this;\n\t\t\treturn res += x;\n\t\t}\n\n\t\titerator& operator+=(const difference_type& x) {\n\t\t\tp += x;\n\t\t\treturn *this;\n\t\t}\n\n\t\titerator& operator--() {\n\t\t\tp--;\n\t\t\treturn *this;\n\t\t}\n\n\t\titerator operator--(int) {\n\t\t\titerator res = *this;\n\t\t\tp--;\n\t\t\treturn res;\n\t\t}\n\n\t\titerator operator-(const difference_type x)const {\n\t\t\titerator res = *this;\n\t\t\treturn res -= x;\n\t\t}\n\n\t\tdifference_type operator-(const iterator& i)const {\n\t\t\treturn p - i.p;\n\t\t}\n\n\t\titerator& operator-=(const difference_type x) {\n\t\t\tp -= x;\n\t\t\treturn *this;\n\t\t}\n\n\t\treference operator*()const {\n\t\t\treturn *p;\n\t\t}\n\n\t\treference operator[](const difference_type x)const {\n\t\t\treturn *(p + x);\n\t\t}\n\n\t\tbool operator<(const iterator& i)const {\n\t\t\treturn p < i.p;\n\t\t}\n\n\t\tbool operator<=(const iterator& i)const {\n\t\t\treturn p <= i.p;\n\t\t}\n\n\t\tbool operator==(const iterator& i)const {\n\t\t\treturn p == i.p;\n\t\t}\n\n\t\tbool operator>(const iterator& i)const {\n\t\t\treturn p > i.p;\n\t\t}\n\n\t\tbool operator>=(const iterator& i)const {\n\t\t\treturn p >= i.p;\n\t\t}\n\n\t\tbool operator!=(const iterator& i)const {\n\t\t\treturn p != i.p;\n\t\t}\n\n\t};\n\n\tclass const_iterator {\n\n\tpublic:\n\n\t\tusing difference_type = int;\n\t\tusing value_type = Vector::value_type;\n\t\tusing pointer = const Vector::pointer;\n\t\tusing reference = const Vector::reference;\n\t\tusing iterator_category = std::random_access_iterator_tag;\n\n\tprivate:\n\n\t\tpointer p;\n\n\tpublic:\n\n\t\tconst_iterator()noexcept :p() {}\n\t\tconst_iterator(const Vector& base, difference_type index) noexcept :p(base.e + index) {}\n\t\tconst_iterator(const const_iterator& i) :p(i.p) {}\n\n\t\tconst_iterator& operator=(const const_iterator& i)noexcept = default;\n\t\tconst_iterator& operator=(const_iterator&& i)noexcept = default;\n\n\t\tconst_iterator& operator++() {\n\t\t\tp++;\n\t\t\treturn *this;\n\t\t}\n\n\t\tconst_iterator operator++(int) {\n\t\t\tconst_iterator res = *this;\n\t\t\tp++;\n\t\t\treturn res;\n\t\t}\n\n\t\tconst_iterator operator+(const difference_type x)const {\n\t\t\tconst_iterator res = *this;\n\t\t\treturn res += x;\n\t\t}\n\n\t\tconst_iterator& operator+=(const difference_type x) {\n\t\t\tp += x;\n\t\t\treturn *this;\n\t\t}\n\n\t\tconst_iterator& operator--() {\n\t\t\tp--;\n\t\t\treturn *this;\n\t\t}\n\n\t\tconst_iterator operator--(int) {\n\t\t\tconst_iterator res = *this;\n\t\t\tp--;\n\t\t\treturn res;\n\t\t}\n\n\t\tconst_iterator operator-(const difference_type x)const {\n\t\t\tconst_iterator res = *this;\n\t\t\treturn res -= x;\n\t\t}\n\n\t\tdifference_type operator-(const const_iterator& i)const {\n\t\t\treturn p - i.p;\n\t\t}\n\n\t\tconst_iterator& operator-=(const difference_type x) {\n\t\t\tp -= x;\n\t\t\treturn *this;\n\t\t}\n\n\t\treference operator*()const {\n\t\t\treturn *p;\n\t\t}\n\n\t\treference operator[](const difference_type x)const {\n\t\t\treturn *(p + x);\n\t\t}\n\n\t\tbool operator<(const const_iterator& i)const {\n\t\t\treturn p < i.p;\n\t\t}\n\n\t\tbool operator<=(const const_iterator& i)const {\n\t\t\treturn p <= i.p;\n\t\t}\n\n\t\tbool operator==(const const_iterator& i)const {\n\t\t\treturn p == i.p;\n\t\t}\n\n\t\tbool operator>(const const_iterator& i)const {\n\t\t\treturn p > i.p;\n\t\t}\n\n\t\tbool operator>=(const const_iterator& i)const {\n\t\t\treturn p >= i.p;\n\t\t}\n\n\t\tbool operator!=(const const_iterator& i)const {\n\t\t\treturn p != i.p;\n\t\t}\n\n\t};\n\n\tusing reverse_iterator = std::reverse_iterator<iterator>;\n\tusing const_reverse_iterator = std::reverse_iterator<const_iterator>;\n\nprivate:\n\n\tpointer e;\n\tsize_type length = 0, cap = 1;\n\tAlloc alloc;\n\n\tstatic_assert(std::is_same<T, typename Alloc::value_type>::value, \"The allocator value type is not matched the Vector value type.\");\n\tstatic_assert(!std::is_const<T>::value, \"This library forbids containers of const elements\");\n\npublic:\n\n\tVector() :Vector(Alloc()) {}\n\n\texplicit Vector(const Alloc& a)noexcept :alloc(a) {\n\t\te = alloc.allocate(cap);\n\t}\n\n\texplicit Vector(size_type n, const Alloc& a = Alloc()) :alloc(a) {\n\t\twhile (cap < n)cap *= 2;\n\t\te = alloc.allocate(cap);\n\t\trep(i, n)emplace_back();\n\t}\n\n\texplicit Vector(size_type n, const_reference value, const Alloc& a = Alloc()) :alloc(a) {\n\t\twhile (cap < n)cap *= 2;\n\t\te = alloc.allocate(cap);\n\t\trep(i, n)emplace_back(value);\n\t}\n\n\ttemplate<class InputIter>\n\tVector(InputIter first, InputIter last, const Alloc& a = Alloc()) :alloc(a) {\n\t\te = alloc.allocate(cap);\n\t\tfor (InputIter i = first; i != last; i++) {\n\t\t\templace_back(*i);\n\t\t}\n\t}\n\n\tVector(const Vector& x, const Alloc& a = Alloc()) :alloc(a) {\n\t\twhile (cap < x.length)cap *= 2;\n\t\tlength = x.length;\n\t\te = alloc.allocate(cap);\n\t\trep(i, x.length)traits::construct(alloc, e + i, *(x.e + i));\n\t}\n\n\tVector(Vector&& x, const Alloc& a = Alloc()) :alloc(a) {\n\t\tcap = x.cap;\n\t\tlength = x.length;\n\t\te = x.e;\n\t\tx.e = nullptr;\n\t}\n\n\t~Vector() {\n\t\tif (e != nullptr) {\n\t\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\t\talloc.deallocate(e, cap);\n\t\t}\n\t}\n\n\tVector& operator=(const Vector& x) {\n\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\talloc.deallocate(e, cap);\n\t\tlength = x.length;\n\t\tcap = 1;\n\t\twhile (cap < length)cap *= 2;\n\t\te = alloc.allocate(cap);\n\t\trep(i, length)traits::construct(alloc, e + i, *(x.e + i));\n\t\treturn *this;\n\t}\n\n\tVector& operator=(Vector&& x) {\n\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\talloc.deallocate(e, cap);\n\t\tcap = x.cap;\n\t\tlength = x.length;\n\t\te = x.e;\n\t\tx.e = nullptr;\n\t\treturn *this;\n\t}\n\nprivate:\n\n\tvoid extension() {\n\t\tpointer e_ = alloc.allocate(cap * 2);\n\t\trep(i, length)traits::construct(alloc, e_ + i, *(e + i));\n\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\talloc.deallocate(e, cap);\n\t\te = e_;\n\t\tcap *= 2;\n\t}\n\n\tvoid extension(size_type n) {\n\t\tunsigned int r = 1;\n\t\twhile (cap * r < n)r *= 2;\n\t\tif (r == 1)return;\n\t\tpointer e_ = alloc.allocate(cap * r);\n\t\trep(i, length)traits::construct(alloc, e_ + i, *(e + i));\n\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\talloc.deallocate(e, cap);\n\t\te = e_;\n\t\tcap *= r;\n\t}\n\npublic:\n\n\ttemplate<class InputIter>\n\tvoid assign(InputIter first, InputIter last) {\n\t\tsize_type cnt = 0;\n\t\tfor (InputIter i = first; i != last; i++) {\n\t\t\tif (cnt == cap) {\n\t\t\t\tlength = std::max(length, cnt);\n\t\t\t\textension();\n\t\t\t}\n\t\t\ttraits::construct(alloc, e + cnt, *i);\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tvoid assign(size_type n, const_reference value) {\n\t\textension(n);\n\t\tstd::fill(e, e + n, value);\n\t}\n\n\ttemplate<class... Args>\n\tvoid emplace_back(Args&&... args) {\n\t\tif (length == cap)extension();\n\t\ttraits::construct(alloc, e + length, std::forward<Args>(args)...);\n\t\tlength++;\n\t}\n\n\tvoid push_back(const_reference value) {\n\t\templace_back(value);\n\t}\n\n\tvoid push_back(T&& value) {\n\t\templace_back(std::move(value));\n\t}\n\n\tvoid pop_back() {\n\t\ttraits::destroy(alloc, e + length);\n\t\tlength--;\n\t}\n\n\tvoid reserve(size_type n) {\n\t\textension(n);\n\t}\n\n\titerator erase(iterator pos) {\n\t\tconst iterator res = pos;\n\t\titerator t = pos; t++;\n\t\tfor (iterator i = pos; t != end(); i++, t++) {\n\t\t\t*i = std::move(*t);\n\t\t}\n\t\tpop_back();\n\t\treturn res;\n\t}\n\n\titerator erase(iterator first, iterator last) {\n\t\tconst iterator res = first;\n\t\ttypename iterator::difference_type d = last - first;\n\t\tfor (iterator i = first; i + d != end(); i++) {\n\t\t\t*i = std::move(*(i + d));\n\t\t}\n\t\trep(i, d)pop_back();\n\t\treturn res;\n\t}\n\n\tvoid swap(Vector& x) {\n\t\tstd::swap(length, x.length);\n\t\tstd::swap(cap, x.cap);\n\t\tstd::swap(e, x.e);\n\t}\n\n\tvoid clear() {\n\t\twhile (length)pop_back();\n\t}\n\n\tsize_type size()const {\n\t\treturn length;\n\t}\n\n\tvoid resize(size_type  n, const_reference value = T()) {\n\t\textension(n);\n\t\twhile (n < length)pop_back();\n\t\tlength = n;\n\t\tstd::fill(e, e + n, value);\n\t}\n\n\tsize_type capacity()const {\n\t\treturn cap;\n\t}\n\n\tbool empty()const {\n\t\treturn !length;\n\t}\n\n\treference operator[](const size_type pos)const {\n\t\treturn e[pos];\n\t}\n\n\tpointer data() {\n\t\treturn e;\n\t}\n\n\treference front() {\n\t\treturn *e;\n\t}\n\n\treference back() {\n\t\treturn *(e + length - 1);\n\t}\n\n\titerator begin() noexcept {\n\t\treturn iterator(*this, 0);\n\t}\n\n\tconst_iterator begin()const noexcept {\n\t\treturn const_iterator(*this, 0);\n\t}\n\n\tconst_iterator cbegin()const noexcept {\n\t\treturn const_iterator(*this, 0);\n\t}\n\n\titerator rbegin()noexcept {\n\t\treturn reverse_iterator(*this, 0);\n\t}\n\n\tconst_iterator rbegin()const noexcept {\n\t\treturn const_reverse_iterator(*this, 0);\n\t}\n\n\tconst_iterator crbegin()const noexcept {\n\t\treturn const_reverse_iterator(*this, 0);\n\t}\n\n\titerator end() noexcept {\n\t\treturn iterator(*this, length);\n\t}\n\n\tconst_iterator end()const noexcept {\n\t\treturn const_iterator(*this, length);\n\t}\n\n\tconst_iterator cend()const noexcept {\n\t\treturn const_iterator(*this, length);\n\t}\n\n\titerator rend()noexcept {\n\t\treturn reverse_iterator(*this, length);\n\t}\n\n\tconst_iterator rend()const noexcept {\n\t\treturn const_reverse_iterator(*this, length);\n\t}\n\n\tconst_iterator crend()const noexcept {\n\t\treturn const_reverse_iterator(*this, length);\n\t}\n\n};\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ninline lint gcd(lint a, lint b) {\n\twhile (b) {\n\t\tlint c = a;\n\t\ta = b; b = c % b;\n\t}\n\treturn a;\n}\ninline lint lcm(lint a, lint b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(lint n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\nlint mypow(lint a, lint b) {\n\tif (!b)return 1;\n\tif (b & 1)return mypow(a, b - 1) * a;\n\tlint memo = mypow(a, b >> 1);\n\treturn memo * memo;\n}\nlint modpow(lint a, lint b, lint m) {\n\tif (!b)return 1;\n\tif (b & 1)return modpow(a, b - 1, m) * a % m;\n\tlint memo = modpow(a, b >> 1, m);\n\treturn memo * memo % m;\n}\ntemplate<typename T>\nvoid printArray(std::vector<T>& vec) {\n\trep(i, vec.size() - 1)std::cout << vec[i] << \" \";\n\tstd::cout << vec.back() << std::endl;\n}\ntemplate<typename T>\nvoid printArray(Vector<T>& vec) {\n\trep(i, vec.size() - 1)std::cout << vec[i] << \" \";\n\tstd::cout << vec.back() << std::endl;\n}\ntemplate<typename T>\nvoid printArray(T l, T r) {\n\tT rprev = r;\n\trprev--;\n\tfor (T i = l; i != rprev; i++) {\n\t\tstd::cout << *i << \" \";\n\t}\n\tstd::cout << *rprev << std::endl;\n}\nstd::string to_string(Vector<int>& vec) {\n\tstd::string res = \"[\";\n\trep(i, vec.size() - 1)res += std::to_string(vec[i]) + \", \";\n\tres += std::to_string(vec.back()) + \"]\";\n\treturn res;\n}\ntemplate<unsigned int modulo = 1000000007>\nclass ModInt {\n\tlint value;\npublic:\n\tModInt() : value(0) {}\n\ttemplate<typename T>\n\tModInt(T value = 0) : value(value) {\n\t\tif (value < 0)value = -(lint)(-value % modulo) + modulo;\n\t\tthis->value = value % modulo;\n\t}\n\tinline operator int()const { return value; }\n\tinline ModInt& operator+=(const ModInt& x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline ModInt operator-()const {\n\t\treturn ModInt(0) -= *this;\n\t}\n\tinline ModInt& operator-=(const ModInt& x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator*=(const ModInt& x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator/=(ModInt rhs) {\n\t\tint exp = modulo - 2;\n\t\twhile (exp) {\n\t\t\tif (exp & 1)*this *= rhs;\n\t\t\trhs *= rhs;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn *this;\n\t}\n\ttemplate<typename T> ModInt operator+(const T& rhs)const { return ModInt(*this) += rhs; }\n\ttemplate<typename T> ModInt& operator+=(const T& rhs) { return operator+=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator-(const T& rhs)const { return ModInt(*this) -= rhs; }\n\ttemplate<typename T> ModInt& operator-=(const T& rhs) { return operator-=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator*(const T& rhs)const { return ModInt(*this) *= rhs; }\n\ttemplate<typename T> ModInt& operator*=(const T& rhs) { return operator*=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator/(const T& rhs)const { return ModInt(*this) /= rhs; }\n\ttemplate<typename T> ModInt& operator/=(const T& rhs) { return operator/=(ModInt(rhs)); }\n};\ntemplate<unsigned int T>\nstd::istream& operator>>(std::istream& ist, ModInt<T>& x) {\n\tlint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\nstd::string s;\nint k;\nint dp[310][310][310];\nint main() {\n\tstd::cin >> s >> k;\n\trep(i, s.size())dp[i][i + 1][0] = 1;\n\trep(i, s.size() - 1) {\n\t\tif (s[i] == s[i + 1])dp[i][i + 2][0] = 2;\n\t}\n\trep(l, k + 1) {\n\t\tREP(i, s.size()) {\n\t\t\trep(j, s.size() - i + 1) {\n\t\t\t\tif (j)chmax(dp[j - 1][j + i][l], dp[j][j + i][l]);\n\t\t\t\tif (j + i != s.size())chmax(dp[j][j + i + 1][l], dp[j][j + i][l]);\n\t\t\t\tif (j && j + i != s.size()) {\n\t\t\t\t\tif (s[j - 1] == s[j + i]) {\n\t\t\t\t\t\tchmax(dp[j - 1][j + i + 1][l], dp[j][j + i][l] + 2);\n\t\t\t\t\t}\n\t\t\t\t\telse chmax(dp[j - 1][j + i + 1][l + 1], dp[j][j + i][l] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i, k + 1)chmax(ans, dp[0][s.size()][i]);\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb           push_back\n#define pii          pair<int,int>\n#define vi           vector<int>\n#define vii         vector<pair<int,int>>\n#define mp           make_pair\n#define FOR(i, n) for (int i = 0; i <  (int)(n); i++)\n#define FOR1(i, n) for (int i = 1; i <= (int)(n); i++)\n#define FORD0(i, n) for (int i = (int)n; i >= 0; i--)\n#define FORD1(i, n) for (int i = (int)n; i >= 1; i--)\n#define debug(X) { cout << #X << \" = \" << (X) << endl; }\n#define endl '\\n'\n#define int long long int\nusing namespace std;\n\n\nsigned main(){\n    ios_base::sync_with_stdio(false);cin.tie(NULL);\n\n    string s;cin >> s;\n    int n = s.length();\n    int k;cin >> k;\n    vector<vi> dp(n+1, vi(n+1));\n    vector<vi> prev(n+1, vi(n+1));\n    for(int change = 0; change <= k; change++){\n        for(int len = 1; len <= n; len++){\n            for(int start =0; start <= n - len; start++){\n                dp[start][len] = max(dp[start+1][len-1], dp[start][len-1]); \n                if(s[start] == s[start + len -1]){\n                    dp[start][len] = 1 + (len != 1) + dp[start + 1][len - 1];\n                }else if(change > 0)\n                    dp[start][len] = max(1 + (len != 1) + prev[start+1][len-1], dp[start][len]); \n            }\n        }\n        swap(dp, prev);\n    }\n    cout << prev[0][n];\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstring S;\nint K;\n\nint dp[305][305][305];\n\nsigned main(){\n    cin>>S;\n    int N=S.size();\n    cin>>K;\n\n    rep(i,K+1){\n        for(int len=0;len<=N;len++){\n            for(int l=0;l+len<=N;l++){\n                int r=l+len;\n                if(len==1)dp[i][l][r]=1;\n                chmax(dp[i+1][l][r],dp[i][l][r]);\n                if(l)chmax(dp[i][l-1][r],dp[i][l][r]);\n                if(r!=N)chmax(dp[i][l][r+1],dp[i][l][r]);\n                if(l&&r!=N){\n                    chmax(dp[i+(S[l-1]!=S[r])][l-1][r+1],dp[i][l][r]+2);\n                }\n            }\n        }\n    }\n\n    cout<<dp[K][0][N]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define overload_rep(va_0, va_1, va_2, name, ...) name\n#define rep_0(i, n) for(int i = 0; i < (n); ++i)\n#define rep_1(i, x, y) for(int i = (x); i <= (y); ++i)\n#define rep(...) overload_rep(__VA_ARGS__, rep_1, rep_0)(__VA_ARGS__)\n#define all(a) a.begin(), a.end()\n#ifndef STOP_DEBUG\n#define debug(...)\\\n    do { cerr << boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n    debug_cerr(__VA_ARGS__); cerr << noboolalpha; } while (0)\n#else\n#define debug(...)\n#endif\n\n// functions\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nvoid debug_cerr(){ cerr << '\\n'; }\ntemplate<class Head, class... Tail>\nvoid debug_cerr(Head head, Tail... tail){\n    cerr << ' ' << head;\n    debug_cerr(tail...);\n}\n\n// cin/cout setup\nstruct IoSetup{\n    IoSetup(){\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(20);\n    }\n} iosetup;\n\n// libraries\n\n// declarations\nint N, K;\nstring S;\n\nint dp[310][310][310];\n\n// solve\nint main(){\n\n    cin >> S >> K;\n    N = S.size();\n\n    rep(i, N)rep(j, 0, K)dp[i][i + 1][j] = 1;\n    rep(len, 1, N){\n        rep(i, 0, N - len){\n            if(i > 0){\n                rep(j, 0, K)chmax(dp[i - 1][i + len][j], dp[i][len][j]);\n                int pos = -1;\n                for(int j = i + len - 1; j >= i; j--){\n                    if(S[i - 1] == S[j]){\n                        pos = j;\n                        break;\n                    }\n                }\n                if(pos != -1)rep(j, 0, K)chmax(dp[i - 1][i + len][j], dp[i][pos][j] + 2);\n                rep(j, K){\n                    chmax(dp[i - 1][i + len][j + 1], dp[i][i + len - 1][j] + 2);\n                }\n            }\n            if(i < N - len){\n                rep(j, 0, K)chmax(dp[i][i + len + 1][j], dp[i][i + len][j]);\n                int pos = -1;\n                for(int j = i; j < i + len; j++){\n                    if(S[i + len] == S[j]){\n                        pos = j;\n                        break;\n                    }\n                }\n                if(pos != -1)rep(j, 0, K)chmax(dp[i][i + len + 1][j], dp[pos + 1][i + len][j] + 2);\n                rep(j, K){\n                    chmax(dp[i][i + len + 1][j + 1], dp[i + 1][i + len][j] + 2);\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    rep(i, 0, K)chmax(ans, dp[0][N][i]);\n    cout << ans << '\\n';\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 305, inf = 1e9;\n\nint n, k;\nchar a[N];\n\nint dt[N][N][N];\nbool vis[N][N][N];\n\nint solve (int S, int E, int X) {\n\tif(X < 0) return -inf;\n\tif(S > E) return 0;\n\tif(vis[S][E][X]) return dt[S][E][X];\n\tvis[S][E][X] = true;\n\tdt[S][E][X] = max(solve(S+1, E, X), solve(S, E-1, X), solve(S+1, E-1, X - (a[S] != a[E])) + 1 + (S != E)});\n\treturn dt[S][E][X];\n}\n\nint main()\n{\n\tscanf(\"%s%d\",a+1,&k);\n\tn = strlen(a+1);\n\tprintf(\"%d\\n\",solve(1, n, k));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for((i)=1;(i)<=(n);(i)++)\nusing namespace std;\nstring st;\nint dp[305][305][305],n,m,i,j,k;\nint main(){\n\tcin>>st>>m;n=st.length();st=\" \"+st;\n\trep(i,n) dp[i][i][0]=1;\n\trep(i,n-1) if(st[i]==st[i+1]) dp[i][i+1][0]=1; else dp[i][i+1][1]=1;\n\tfor(i=n;i>=1;i--){\n\t\tfor(j=i+1;j<=n;j++){\n\t\t\tfor(k=0;k<=m;k++){\n\t\t\t\tdp[i][j][k]=max(dp[i+1][j][k],dp[i][j-1][k]);\n\t\t\t\tif(i+1<=j-1&&st[i]==st[j]) dp[i][j][k]=max(dp[i][j][k],dp[i+1][j-1][k]+2);\n\t\t\t\tif(i+1<=j-1&&k) dp[i][j][k]=max(dp[i][j][k],dp[i+1][j-1][k-1]+2);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(k=0;k<=m;k++) ans=max(ans,dp[1][n][k]);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)a;i<=(sign)b;++i)\n#define Fordown(i,a,b) for(register sign i=(sign)a;i>=(sign)b;--i)\nconst int N=300+5;\nbool cmax(sign &a,sign b){return (a<b)?a=b,1:0;}\nbool cmin(sign &a,sign b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n  T ans=0,f=1;\n  char ch=getchar();\n  while(!isdigit(ch)&&ch!='-')ch=getchar();\n  if(ch=='-')f=-1,ch=getchar();\n  while(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n  return ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n  if(x==0)\n  {\n      putchar('0');putchar(y);\n      return;\n  }\n  if(x<0)\n  {\n      putchar('-');\n      x=-x;\n  }\n  static char wr[20];\n  int top=0;\n  for(;x;x/=10)wr[++top]=x%10+'0';\n  while(top)putchar(wr[top--]);\n  putchar(y);\n}\nvoid file()\n{\n  #ifndef ONLINE_JUDGE\n      freopen(\"d.in\",\"r\",stdin);\n      freopen(\"d.out\",\"w\",stdout);\n  #endif\n}\nchar s[N];\nint len,k;\nvoid input()\n{\n\tscanf(\"%s\",s+1);\n\tk=read<int>();\n\tlen=strlen(s+1);\n}\nint dp[N][N][N];\nvoid work()\n{\n\tif(k>=len/2){write(len,'\\n');return;}\n\tFor(i,1,len)For(j,0,k)dp[i][i][j]=1;\n\tFor(i,1,len-1)\n\t{\n\t\tdp[i][i+1][0]=(s[i]==s[i+1]?2:1);\n\t\tFor(j,1,k)dp[i][i+1][j]=2;\n\t}\n\tint j;\n\tFor(l,2,len)For(i,1,len-l)\n\t{\n\t\tj=i+l;\n\t\t//cout<<i<<' '<<j<<endl;\n\t\tFor(v,0,k)\n\t\t{\n\t\t\tdp[i][j][v]=max(dp[i+1][j][v],dp[i][j-1][v]);\n\t\t\tif(s[i]==s[j])cmax(dp[i][j][v],dp[i+1][j-1][v]+2);\n\t\t\tif(v)\n\t\t\t{\n\t\t\t\tcmax(dp[i][j][v],dp[i+1][j-1][v-1]+2);\n\t\t\t\tcmax(dp[i][j][v],dp[i][j][v-1]);\n\t\t\t}\n\t\t\t//cout<<i<<' '<<j<<' '<<v<<' '<<dp[i][j][v]<<endl;;\n\t\t}\n\t}\n\twrite(dp[1][len][k],'\\n');\n}\nint main()\n{\n\t//file();\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\nstring s;\nint limit;\nint dp[310][310][310];\n\nint main(void) {\n\tcin >> s >> limit;\n\tconst int n = s.size();\n\n\trep(i, n + 1)rep(j, n + 1)rep(k, limit + 1) {\n\t\tconst int sidx = i;\n\t\tconst int ridx = n - 1 - j;\n\n\t\tif (sidx < n and 0 <= ridx and s[sidx] == s[ridx]) {\n\t\t\tchmax(dp[i + 1][j + 1][k], dp[i][j][k] + 1);\n\t\t}\n\n\t\tif (sidx < n) {\n\t\t\tchmax(dp[i + 1][j][k], dp[i][j][k]);\n\t\t}\n\n\t\tif (0 <= ridx) {\n\t\t\tchmax(dp[i][j + 1][k], dp[i][j][k]);\n\t\t}\n\n\t\tif (k + 1 <= limit and sidx < n and 0 <= ridx) {\n\t\t\tchmax(dp[i + 1][j + 1][k + 1], dp[i][j][k] + 1);\n\t\t}\n\t}\n\n\tint ans = 0;\n\trep(i, n + 1) {\n\t\tconst int j = n - i;\n\t\trep(k, limit + 1) chmax(ans, 2 * dp[i][j][k]);\n\t}\n\n\trep(i, 1, n + 1) {\n\t\tconst int j = n + 1 - i;\n\t\trep(k, limit + 1) chmax(ans, 2 * dp[i][j][k] - 1);\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#include <tuple>\n#define mkp make_pair\n#define mkt make_tuple\n#define rep(i,n) for(int i = 0; i < (n); ++i)\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1e9+7;\ntemplate<class T> void chmin(T &a,const T &b){if(a>b) a=b;}\ntemplate<class T> void chmax(T &a,const T &b){if(a<b) a=b;}\n\nstring S;\nint N,K;\n\nstring T;\nint dp[303][303][303];\n\nint rec(int uplef,int dwlef,int num){\n    if(N-1-uplef<dwlef) return 0;\n    if(N-1-dwlef<uplef) return 0;\n    if(dp[uplef][dwlef][num]) return dp[uplef][dwlef][num];\n    if(2*uplef>=N&&2*dwlef>=N) return 0;\n\n    int res=0;\n    chmax(res,rec(uplef+1,dwlef,num));\n    chmax(res,rec(uplef,dwlef+1,num));\n\n    int cost=2;\n    if(N-1-uplef<=dwlef) cost=1;\n    if(N-1-dwlef<=uplef) cost=1;\n    if(S[uplef]==T[dwlef]) chmax(res,rec(uplef+1,dwlef+1,num)+cost);\n    else if(num>0) chmax(res,rec(uplef+1,dwlef+1,num-1)+cost);\n\n    return dp[uplef][dwlef][num]=res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin>>S;\n  cin>>K;\n  N=S.size();\n\n  T=S;\n  reverse(T.begin(),T.end());\n\n  cout<<rec(0,0,K)<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=305;\nint f[MAXN][MAXN][MAXN],n,K;char ch[MAXN];\nint main()\n{\n\tscanf(\"%s\",ch+1);n=strlen(ch+1);K=read();\n\tf[0][n+1][0]=0;int ans=0;\n\tfor(int i=0;i<=n;i++)for(int j=n+1;j>=i;j--)for(int k=0;k<=K;k++)\n\t{\n\t\tint ad=(ch[i]==ch[j]?0:1);\n\t\tif(i-1>=0)chkmax(f[i][j][k],f[i-1][j][k]);\n\t\tif(j+1<=n+1)chkmax(f[i][j][k],f[i][j+1][k]);\n\t\tif(i-1>=0&&j+1<=n+1&&k-ad>=0)chkmax(f[i][j][k],f[i-1][j+1][k-ad]+1);\n\t\tif(i<j)chkmax(ans,2*f[i][j][k]);\n\t\telse chkmax(ans,2*f[i][j][k]-1);\n\t}pr2(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int N = 1e5 + 5;\n\nstring s;\nint n, K;\nint dp[305][305][305];\nint solve(int i = 0, int j = n - 1, int k = K) {\n    if (i > j) return 0;\n    if (dp[i][j][k] == -1) {\n        if (i == j) dp[i][j][k] = 1;\n        else if (i + 1 == j) {\n            if (s[i] == s[j])\n                dp[i][j][k] = 2;\n            else if (k) \n                dp[i][j][k] = 2;\n            else\n                dp[i][j][k] = 1;\n        }\n        else if (s[i] == s[j]) {\n            dp[i][j][k] = 2 + solve(i + 1, j - 1, k);\n        }\n        else {\n            dp[i][j][k] = max(solve(i, j - 1, k), solve(i + 1, j, k));\n            if (k) {\n                dp[i][j][k] = max(dp[i][j][k], 2 + solve(i + 1, j - 1, k - 1));\n            }\n        }\n    }\n    return dp[i][j][k];\n}\nint32_t main() {\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    memset(dp, -1, sizeof(dp));\n    cin >> s;\n    n = s.size();\n    cin >> K;\n    cout << solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "//MIPT Cryptozoology 17.2\n#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\ntypedef long long li;\ntypedef long double ld;\nvoid solve(__attribute__((unused)) bool);\nvoid precalc();\nclock_t start;\n#define FILENAME \"\"\n\nint main() {\n#ifdef AIM\n    string s = FILENAME;\n    //assert(!s.empty());\n    freopen(\"/home/alexandero/ClionProjects/cryptozoology/input.txt\", \"r\", stdin);\n#else\n    //freopen(FILENAME \".in\", \"r\", stdin);\n    //freopen(FILENAME \".out\", \"w\", stdout);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#endif\n    start = clock();\n    int t = 1;\n#ifndef AIM\n    cout.sync_with_stdio(0);\n    cin.tie(0);\n#endif\n    precalc();\n    cout.precision(10);\n    cout << fixed;\n    //cin >> t;\n    int testNum = 1;\n    while (t--) {\n        //cout << \"Case #\" << testNum++ << \": \";\n        //cerr << testNum << endl;\n        solve(true);\n        //cerr << testNum - 1 << endl;\n    }\n    cout.flush();\n#ifdef AIM1\n    while (true) {\n      solve(false);\n  }\n#endif\n\n#ifdef AIM\n    cout.flush();\n    auto end = clock();\n\n    usleep(10000);\n    print_stats(end - start);\n    usleep(10000);\n#endif\n\n    return 0;\n}\n\nvoid precalc() {\n}\n\ntemplate<typename T>\ninline T nxt() {\n    T cur;\n    cin >> cur;\n    return cur;\n}\n\n//#define int li\n//const int mod = 1000000007;\n\ntemplate<typename T>\nvoid relax_max(T& cur, T val) {\n    cur = max(cur, val);\n}\n\nconst int C = 302;\nint dp[C][C][C];\n\nvoid solve(__attribute__((unused)) bool read) {\n    string s;\n    int k;\n    cin >> s >> k;\n    int n = s.length();\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 0; j <= n; ++j) {\n            for (int r = 0; r <= n; ++r) {\n                dp[i][j][r] = -(int)1e9;\n            }\n        }\n    }\n    dp[0][n - 1][0] = 0;\n    int res = 0;\n    for (int l = 0; l < n; ++l) {\n        for (int r = n - 1; r >= 0 && r >= l - 1; --r) {\n            for (int used = 0; used <= k; ++used) {\n                if (r < l) {\n                    relax_max(res, dp[l][r][used]);\n                    continue;\n                }\n                //cout << l << \" \" << r << \" \" << used << \" \" << dp[l][r][used] << endl;\n                relax_max(res, dp[l][r][used] + 1);\n                relax_max(dp[l + 1][r][used], dp[l][r][used]);\n                relax_max(dp[l][r - 1][used], dp[l][r][used]);\n                if (l < r) {\n                    if (s[l] == s[r]) {\n                        relax_max(dp[l + 1][r - 1][used], dp[l][r][used] + 2);\n                    }\n                    relax_max(dp[l + 1][r - 1][used + 1], dp[l][r][used] + 2);\n                }\n            }\n        }\n    }\n\n    cout << res << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "%:pragma GCC optimize(\"Ofast\", \"inline\")\n#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n    x = 0; char c = getchar(); int f = 0;\n    for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n    for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n    if (f) x = -x;\n}\n\nnamespace {\n    const int mo = 1e9 + 7;\n    inline int add(int x, int y) { x += y; return x >= mo ? x - mo : x; }\n    inline int sub(int x, int y) { x -= y; return x < 0 ? x + mo : x; }\n    inline int mul(int x, int y) { return (lo) x * y % mo; }\n    inline int power(int a, int k = mo - 2) {\n\t\tint ans = 1;\n\t\tfor (; k; k >>= 1, a = mul(a, a))\n\t\t\tif (k & 1) ans = mul(ans, a);\n\t\treturn ans;\n    }\n\tinline void U(int &x, int y) { x = add(x, y); } \n}\n\nconst int N = 333;\nint n, K;\nint dp[N][N][N];\nchar str[N];\n\ninline int dfs(int l, int r, int k) {\n\tif (k < 0) return -1e9;\n\tif (l > r) return 0;\n\tif (l == r) return 1;\n\tif (~dp[l][r][k]) return dp[l][r][k];\n\tint &ans = dp[l][r][k] = 0;\n\tans = max(ans, max(dfs(l + 1, r, k), dfs(l, r - 1, k)));\n\tans = max(ans, 2 + dfs(l + 1, r - 1, k - 1));\n\tans = max(ans, (str[l] == str[r]) * 2 + dfs(l + 1, r - 1, k));\n\t// cout << l << \" \" << r << \" \" << k << \" \"<< ans << \"\\n\";\n\treturn ans;\n}\n\nint main(void) {\n\tmemset(dp, -1, sizeof dp);\n\tscanf(\"%s\", str + 1);\n\tn = strlen(str + 1);\n\tread(K);\n\t// cout << dfs(1, n, K) << \"\\n\";\n\t// return 0;\n\tint ans = 0;\n\trep (r, n) rep (l, r) ans = max(ans, dfs(l, r, K));\n\tcout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <assert.h>\n#include <memory.h>\n#include <queue>\nusing namespace std;\n\n#define N 303\n\nint dp[N][N][N];\n\nchar s[N];\nvoid solve() {\n  scanf(\" %s\",s+1);\n  int n = strlen(s+1);\n  int k;scanf(\"%d\",&k);\n  for(int cc = k;cc>=0;--cc) {\n    for(int i=1;i<=n;++i) {\n      for(int j=n;j>=i+1;--j) {\n        dp[cc][i+1][j] = max(dp[cc][i+1][j], dp[cc][i][j]);\n        dp[cc][i][j-1] = max(dp[cc][i][j-1],dp[cc][i][j]);\n        if(s[i]==s[j]) {\n          dp[cc][i+1][j-1] = max(dp[cc][i+1][j-1], dp[cc][i][j]+1);\n        } else if(cc>0){\n          dp[cc-1][i+1][j-1] = max(dp[cc-1][i+1][j-1], dp[cc][i][j]+1);\n        }\n      }\n    }\n  }\n  int ret = 0;\n  for(int i=1;i<=n;++i) {\n    for(int cc=0;cc<=k;++cc) {\n      ret = max(ret, dp[cc][i][i-1]*2);\n      ret = max(ret, dp[cc][i+1][i]*2);\n      ret = max(ret,1 + dp[cc][i][i]*2);\n    }\n  }\n  printf(\"%d\\n\", ret);\n}\n\nint main() {\n  //freopen(\"input.txt\",\"r\",stdin);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma comment(linker, \"/STACK:108777216\")\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <functional>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <deque>\n#include <utility>\n#include <algorithm>\n#include <ctime>\nusing namespace std;\n\nint const MAX_N = 128 * 3;\n\nint exist[MAX_N], lst[26];\nint n;\nint dp[2][MAX_N];\n\nint calc(const string & st) {\n\tint from = 0;\n\tfill(dp[from], dp[from] + n+1, 0);\n\tfor (int i=1; i<=n; i++) {\n\t\tint to = 1-from;\n\t\tmemcpy(dp[to], dp[from], (n+1)*sizeof(int));\n\t\tfor (int j=1; j<=n; j++) {\n\t\t\tdp[to][j] = max(dp[to][j], dp[to][j-1]);\n\t\t\tif (st[i-1] == st[n-j])\n\t\t\t\tdp[to][j] = max(dp[to][j], dp[from][j-1] + 1);\n\t\t}\n\t\tswap(from, to);\n\t}\n\n\treturn dp[from][n];\n}\n\nint main() {\n\t//freopen(\"input.txt\",\"r\",stdin);\n\t//freopen(\"output.txt\",\"w\",stdout);\n\n\tstring st;\n\tcin>>st;\n\tint k;\n\tcin>>k;\n\n\tn = (int) st.length();\n\n\tfor (int i=0; i<(int) st.length(); i++)\n\t\texist[st[i]-'a']++;\n\n\tint lst_len = 0;\n\tfor (int i=0; i<26; i++)\n\t\tif (exist[i]) lst[lst_len++] = 'a' + i;\n\n\twhile (k-->0) {\n\t\tint ans_i = -1, mx = -1;\n\t\tchar ans_ch = 0;\n\t\tfor (int i=0; i<n; i++)\n\t\t\tfor (int ch_ind = 0; ch_ind < lst_len; ch_ind++) {\n\t\t\t\tstring q = st;\n\t\t\t\tq[i] = lst[ch_ind];\n\t\t\t\tint loc_ans = calc(q);\n\t\t\t\tif (loc_ans > mx) {\n\t\t\t\t\tmx = loc_ans;\n\t\t\t\t\tans_i = i;\n\t\t\t\t\tans_ch = lst[ch_ind];\n\t\t\t\t}\n\t\t\t}\n\t\tst[ans_i] = ans_ch;\n\t}\n\tcout<<calc(st);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint N,K;\nstring S;\nint dp[301][301][301];\n\nint main(){\n  cin>>S>>K;\n  N=S.size();\n\n  rep(i,301)rep(j,301)rep(k,301)dp[i][j][k]=-100000;\n  rep(i,N+1){\n    rep(k,K+1)dp[i][i][k]=0;\n    if(i<N)rep(k,K+1)dp[i][i+1][k]=1;\n  }\n\n  repl(len,2,N+1){\n    rep(l,N){\n      ll r=l+len;\n      if(r>N)continue;\n      rep(k,K+1){\n        maxch(dp[l][r][k],dp[l][r-1][k]);\n        maxch(dp[l][r][k],dp[l+1][r][k]);\n        if(S[l]==S[r-1])maxch(dp[l][r][k],dp[l+1][r-1][k]+2);\n        if(k>0){\n          maxch(dp[l][r][k],dp[l+1][r-1][k-1]+2);\n          maxch(dp[l][r][k],dp[l][r][k-1]);\n        }\n      }\n    }\n  }\n\n\n\n  cout<<dp[0][N][K]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N = 305;\n\nint dp[2][MAX_N][MAX_N];\nchar S[MAX_N];\n\nint main() {\n  scanf(\"%s\", S + 1);\n  int N = strlen(S + 1), K;\n  scanf(\"%d\", &K);\n\n  memset(dp, -0x3f, sizeof dp);\n\n  int o = 0, p, result = 1;\n  for (int i = 1; i <= N; ++i) dp[0][i][0] = 0;\n  \n  for (int i = 1; i <= N; ++i) {\n    p = o, o ^= 1;\n    memset(dp[o], -0x3f, sizeof dp[o]);\n    dp[o][N + 1][0] = 0;\n    for (int j = N; j > i; --j)\n      for (int k = 0; k <= K; ++k) {\n\tdp[o][j][k] = max(dp[o][j + 1][k], dp[p][j][k]);\n\tif (S[i] == S[j]) dp[o][j][k] = max(dp[o][j][k], dp[p][j + 1][k] + 1);\n\telse if (k > 0) dp[o][j][k] = max(dp[o][j][k], dp[p][j + 1][k - 1] + 1);\n      }\n    for (int k = 0; k <= K; ++k) {\n      result = max(result, dp[o][i + 1][k] * 2);\n      result = max(result, dp[o][i + 2][k] * 2 + 1);\n    }\n  }\n\n  printf(\"%d\\n\", result);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define PB push_back\n#define MP make_pair\nusing namespace std;\ntypedef long long LL;\nconst int MAXN=150 + 10;\n\nchar inis[MAXN*2], s[MAXN], t[MAXN];\nint n,m , f[MAXN][MAXN][MAXN],mdf, g[MAXN*2][MAXN*2][MAXN];\n\nint main(){\n\t\n\tscanf(\"%s\", s+1);scanf(\"%d\", &mdf);\n\tmdf=min(mdf, 150);\n\tfor (int i=1,j=n; i<=n; i++,j--) t[j]=s[i];\n\tint n= strlen(s+1);\n\tmemset(g, 0 ,sizeof(g));\n\tfor (int i=1; i<=n; i++) g[i][i][0] = 1;\n\tfor (int L=2; L<=n; L++)\n\t\tfor (int i=1; i<=n; i++){\n\t\t\tint j=i+L-1;\n\t\t\tfor (int k=0; k<=mdf; k++){\n\t\t\t\tint &cur= g[i][j][k];\n\t\t\t\tcur= max(g[i+1][j][k], g[i][j-1][k]);\n\t\t\t\tif ( s[i]==s[j]) cur= max(cur, g[i+1][j-1][k]+2);\n\t\t\t\t\telse\n\t\t\t\tif ( k) cur= max(cur, g[i+1][j-1][k-1]+2);\n\t\t\t}\n\t\t}\n\tint ans=0;\n\tfor (int i=0; i<=mdf; i++) ans= max(ans , g[1][n][i]);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\ntypedef pair<LL, LL> P;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQ(c)     (c).erase(unique(ALL((c))),(c).end())\n# define mp          make_pair\n# define eb          emplace_back\n# define FOR(i,a,b)  for(int i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(int i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nstring s, rs;\nint dp[303][303];\n\nint k;\n\nint lcs(string a, string b) {\n\tREP(i, 303)REP(j, 303)dp[i][j] = 0;\n\ta = \" \" + a;\n\tb = \"#\" + b;\n\tint sa = a.size(), sb = b.size();\n\tfor (int i = 0; i <= sa; i++) {\n\t\tfor (int j = 0; j <= sb; j++) {\n\t\t\tif (i == 0 || j == 0)dp[i][j] = 0;\n\t\t\telse if (a[i - 1] == b[j - 1])dp[i][j] = dp[i - 1][j - 1] + 1;\n\t\t\telse dp[i][j] = max({ dp[i - 1][j],dp[i][j - 1] });\n\t\t}\n\t}\n\treturn dp[sa][sb];\n\n}\n\nint main() {\n\tcin >> s >> k;\n\trs = s;\n\treverse(ALL(s));\n\tint ans = 0;\n\tfor (int i = 0; i <= k; i++) {\n\t\tans = max(lcs(s.substr(i, s.size() - i * 2), rs.substr(i, s.size() - i * 2)) + i * 2, ans);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)   FOR(i,0,n)\n#define LL long long\n\nstring s;\nint k,n;\n\nint dp[300][300][300];\n\nint main(){\n  cin>>s>>k;\n  n=s.size();\n  FOR(d,1,n+1){\n    FOR(init,0,n-d+1){\n      REP(l,k+1){\n\tif(d==1)dp[init][init+d-1][l]=1;\n\telse if(l==0){\n\t  if(s[init]==s[init+d-1])\n\t    dp[init][init+d-1][0]=(d==2)?2:2+dp[init+1][init+d-2][0];\n\t  else\n\t    dp[init][init+d-1][0]=max(dp[init][init+d-2][0],dp[init+1][init+d-1][0]);\n\t}else{\n\t  if(s[init]==s[init+d-1]){\n\t    dp[init][init+d-1][l]=(d==2)?2:2+dp[init+1][init+d-2][l];\n\t  }else{\n\t    dp[init][init+d-1][l]=(d==2)?2:max(max(dp[init][init+d-2][l],dp[init+1][init+d-1][l]),2+dp[init+1][init+d-2][l-1]);\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<dp[0][n-1][k]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n\nint n,m,i,j,k,l,r;\nint f[305][305][305];\nchar s[100005];\n\nint main()\n{\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tscanf(\"%d\",&m);\n\tfor(i=1;i<=n;++i)\n\tfor(j=0;j<=m;++j)\n\tf[i][i][j]=1;\n\tfor(i=1;i<n;++i)\n\tfor(l=1;l+i<=n;++l)\n\t{\n\t\tr=l+i;\n\t\tfor(j=0;j<=m;++j)\n\t\t{\n\t\t\tf[l][r][j]=max(f[l+1][r][j],f[l][r-1][j]);\n\t\t\tif(s[l]==s[r])f[l][r][j]=max(f[l][r][j],f[l+1][r-1][j]+2);\n\t\t\telse if(j)f[l][r][j]=max(f[l][r][j],f[l+1][r-1][j-1]+2);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[1][n][m]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\nusing namespace std;\nint n,m,f[310][310][310];\nchar s[310];\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k,l;\n\tscanf(\"%s%d\",s+1,&m);\n\tn=strlen(s+1);\n\tfor(i=1;i<=n;i++)\n\t  for(j=0;j<=m;j++)\n\t    f[i][i][j]=1;\n\tfor(l=1;l<n;l++)\n\t  for(i=1;i+l<=n;i++)\n\t    for(k=0;k<=m;k++)\n\t      {\n           j=i+l;\n           f[i][j][k]=max(max(f[i+1][j][k],f[i][j-1][k]),(s[i]==s[j]?f[i+1][j-1][k]:(k?f[i+1][j-1][k-1]:-1000000000))+2);\n          }\n    printf(\"%d\\n\",f[1][n][m]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 300;\n\nchar ch[N+5]; int f[N+5][N+5][N+5], k, n;\n\nvoid work() {\n    scanf(\"%s%d\", ch+1, &k); n = strlen(ch+1);\n    for (int i = 1; i <= n; i++) f[i][i][0] = 1;\n    for (int l = 1; l <= n; l++)\n\tfor (int i = 1; i+l <= n; i++)\n\t    for (int p = 0, j = i+l; p <= k; p++) {\n\t\tf[i][j][p] = max(f[i+1][j][p], f[i][j-1][p]);\n\t\tif (ch[i] == ch[j]) f[i][j][p] = max(f[i][j][p], f[i+1][j-1][p]+2);\n\t\tif (p) f[i][j][p] = max(f[i][j][p], max(f[i-1][j][p-1], f[i][j-1][p-1])+2);\n\t    }\n    int ans = 0;\n    for (int i = 0; i <= k; i++) ans = max(ans, f[1][n][i]);\n    printf(\"%d\\n\", ans);\n}\nint main() {work(); return 0; }\n"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\nusing namespace std;\n#define endl '\\n'\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\nusing ll = int64_t;\nusing ull = uint64_t;\nusing PLL = pair<ll, ll>;\n\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return max(low, min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { t = clamp(t, low, high); }\n\nnamespace init__ {\n\nstruct InitIO {\n    InitIO() {\n        cin.tie(nullptr);\n        ios_base::sync_with_stdio(false);\n        cout << fixed << setprecision(30);\n    }\n} init_io;\n\n}\n\n#ifdef DEBUGGING\n// #include \"../debug/debug.cpp\"\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\ntemplate <typename T>\nT make_v(T init) { return init; }\n\ntemplate <typename T, typename... Tail>\nauto make_v(T init, size_t s, Tail... tail) {\n#define rec make_v(init, tail...)\n    return V<decltype(rec)>(s, rec);\n#undef rec\n}\n\nVV<V<ll>> dp;\nstring S;\n\nll calc(ll l, ll r, ll rest) {\n    if(r < l) return 0;\n    if(l == r) {\n        if(rest) return 1;\n        else return S[l] == S[r];\n    }\n    \n    auto &d = dp[l][r][rest];\n    if(d != -1) return d;\n\n    if(S[l] == S[r]) chmax(d, calc(l + 1, r - 1, rest) + 2);\n    else if(rest) chmax(d, calc(l + 1, r - 1, rest - 1) + 2);\n    chmax(d, calc(l + 1, r, rest));\n    chmax(d, calc(l, r - 1, rest));\n\n    return d;\n}\n\nint main() {\n    dp = make_v<ll>(-1, 302, 302, 302);\n    ll K;\n    cin >> S >> K;\n    cout << calc(0, S.size() - 1, K) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nint n, k;\nstring str;\nint dp[302][302][151];\n\nint recur(int st, int en, int left){\n\tif(st == en) return 1;\n\tif(st > en) return 0;\n\tif(dp[st][en][left] != -1) return dp[st][en][left];\n\tint ret = 0;\n\tif(str[st] == str[en]) ret = max(ret, 2 + recur(st + 1, en - 1, left));\n\tret = max(ret, recur(st + 1, en, left));\n\tret = max(ret, recur(st, en - 1, left));\n\tif(left) ret = max(ret, 2 + recur(st + 1, en - 1, left - 1));\n\treturn dp[st][en][left] = ret;\n}\n\nint main(){\n\tcin >> str;\n\tcin >> k;\n\tn = str.size();\n\tmemset(dp, -1, sizeof(dp));\n\tcout << recur(0, n - 1, min(k, 150)) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define double long double\n#define ll long long\n#define P pair<int,int>\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define pb push_back\n#define eb emplace_back\ntemplate<class T>void chmax(T &a,T b){if(a<b)a=b;}\ntemplate<class T>void chmin(T &a,T b){if(a>b)a=b;}\nconstexpr int INF=1000000000000000000;\nconstexpr int mod=1000000007;\nconstexpr double eps=1e-8;\nconst double pi=acos(-1);\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nint Random(int mi,int ma){\n    random_device rnd;\n    mt19937 mt(rnd());//32bit\n    //[mi,ma]\n    uniform_int_distribution<int>engine(mi,ma);\n    return engine(mt);\n}\nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n}\nint lcm(int a,int b){\n    return a/gcd(a,b)*b;\n}\nbool prime(int a){\n    if(a==1)return false;\n    for(int i=2;i*i<=a;i++){\n        if(a%i==0)return false;\n    }\n    return true;\n}\nint modpow(int a,int b){\n    if(b==0)return 1;\n    if(b%2)return modpow(a,b-1)*a%mod;\n    int memo=modpow(a,b/2);\n    return memo*memo%mod;\n}\nvector<int>kaijo,invkaijo;\nvoid init_fact(int n){\n    kaijo.resize(n+1);\n    invkaijo.resize(n+1);\n    kaijo[0]=1;\n    for(int i=1;i<=n;i++){\n        kaijo[i]=kaijo[i-1]*i;\n        kaijo[i]%=mod;\n    }\n    rep(i,n+1)invkaijo[i]=modpow(kaijo[i],mod-2);\n}\nint comb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return kaijo[a]*modpow(kaijo[a-b],mod-2)%mod*modpow(kaijo[b],mod-2)%mod;\n}\nint inv(int x){\n    x=modpow(x,mod-2);\n    return x;\n}\nstring s;\nint n,k,dp[310][310][310];\nsigned main(){\n  //Save Submission\n    cin.tie(0);ios::sync_with_stdio(false);\n    cin>>s>>k;\n    n=s.size();\n    rep(i,n){\n        rep(x,k+1){\n            dp[i][i+1][x]=1;\n        }\n    }\n    for(int wid=2;wid<=n;wid++){\n        rep(l,n){\n            int r=l+wid;\n            if(r>n)break;\n            rep(x,k+1){\n                if(x)dp[l][r][x]=dp[l][r][x-1];\n                if(s[l]==s[r-1]){\n                    chmax(dp[l][r][x],dp[l+1][r-1][x]+2);\n                }\n                else{\n                    chmax(dp[l][r][x],dp[l+1][r][x]);\n                    chmax(dp[l][r][x],dp[l][r-1][x]);\n                    if(x)chmax(dp[l][r][x],dp[l+1][r-1][x-1]+2);\n                }\n            }\n        }\n    }\n    cout<<dp[0][n][k]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\nstring s;\nint k;\n\nint dp[324][324][324];\n\nint main(){\n\tcin >> s >> k;\n\tint n = s.size();\n\ts = \"*\" + s;\n\tfor(int i = 0;i < 324;i++)\n\t\tfor(int j = 0;j < 324;j++)\n\t\t\tfor(int k = 0;k < 324;k++)\n\t\t\t\tdp[i][j][k] = -100000;\n\t\n\tdp[0][n+1][0] = 0;\n\tfor(int i = 0;i <= n;i++){\n\t\tfor(int j = n+1;j > i;j--){\n\t\t\tfor(int k = 0;k <= n;k++){\n\t\t\t\tif(i > 0)dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k]);\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i][j+1][k]);\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i][j+1][k]);\n\t\t\t\tint cost = s[i] != s[j];\n\t\t\t\tif(k-cost >= 0 && i > 0)\n\t\t\t\t\t dp[i][j][k] = max(dp[i][j][k], dp[i-1][j+1][k-cost] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tfor(int i = 1;i <= n+1;i++){\n\t\tfor(int j = 0;j <= k;j++){\n\t\t\tres = max(res, dp[i-1][i+1][j] * 2 + 1);\n\t\t\tres = max(res, dp[i-1][i][j]*2);\n\t\t}\n\t}\n\n\tcout << res << endl;\n\treturn 0;\n}\n\t\t\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define mod 1000000007\nusing ll=long long;\nconst int INF=1000000000;\nconst ll LINF=1001002003004005006ll;\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n// ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return true;}return false;}\n \nstruct IOSetup{\n    IOSetup(){\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n        cout<<fixed<<setprecision(12);\n    }\n} iosetup;\n \ntemplate<typename T1,typename T2>\nostream &operator<<(ostream &os,const pair<T1,T2>&p){\n    os<<p.first<<\" \"<<p.second;\n    return os;\n}\n \ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T>&v){\n    for(int i=0;i<(int)v.size();i++) os<<v[i]<<(i+1==(int)v.size()?\"\":\" \");\n    return os;\n}\n\ntemplate<typename T1,typename T2>\nistream &operator>>(istream &is,pair<T1,T2>&p){\n    is>>p.first>>p.second;\n    return is;\n}\n\ntemplate<typename T>\nistream &operator>>(istream &is,vector<T>&v){\n    for(T &x:v)is>>x;\n    return is;\n}\n\n\nint dp[310][310][610];\nsigned main(){\n    string s;cin>>s;\n    int m;cin>>m;\n    int n=(int)s.size();\n    if(m>=n){\n        cout<<n<<endl;\n        return 0;\n    }\n    string t=s;\n    reverse(ALL(t));\n\n    rep(i,n)rep(j,n)rep(k,m+1){\n        chmax(dp[i+1][j+1][k],dp[i][j][k]+(s[i]==t[j]));\n        chmax(dp[i+1][j+1][k],dp[i][j+1][k]);\n        chmax(dp[i+1][j+1][k],dp[i+1][j][k]);\n        if(k<m)chmax(dp[i+1][j+1][k+1],dp[i][j][k]+2);\n    }\n    \n    cout<<dp[n][n][m]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> Pi;\ntypedef pair<ll,ll> Pll;\n\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define sz(x) (int)x.size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define repp(i, n) for(int i=1;i<=n;i++)\n#define all(x) x.begin(), x.end()\n\n#define geti1(X) scanf(\"%d\",&X)\n#define geti2(X,Y) scanf(\"%d%d\",&X,&Y)\n#define geti3(X,Y,Z) scanf(\"%d%d%d\",&X,&Y,&Z)\n#define geti4(X,Y,Z,W) scanf(\"%d%d%d%d\",&X,&Y,&Z,&W)\n\n#define GET_MACRO(_1,_2,_3,_4,NAME,...) NAME\n#define geti(...) GET_MACRO(__VA_ARGS__, geti4, geti3, geti2, geti1) (__VA_ARGS__)\n\n#define INF 7654321\n#define IINF 87654321987654321LL\n#define MAXV 200500\n\nll mod = 1e9 + 7;\n\n\nint dp[301][301][301];\nstring s;\nint N,K;\n\nint solve(int l, int r, int k){\n\n\tif( l == r ) return 1;\n\tif( l > r ) return 0;\n\n\tint& res = dp[l][r][k];\n\tif( res != -1 ) return res;\n\tres = 0;\n\tif( s[l] == s[r] ){\n\t\tres = max(res, 2 + solve(l+1,r-1,k) );\n\t}\n\telse{\n\t\tif( k > 0 ){\n\t\t\tres = max(res, 2 + solve(l+1,r-1,k-1) );\n\t\t}\n\t\tres = max(res, solve(l+1,r,k) );\n\t\tres = max(res, solve(l,r-1,k) );\n\t}\n\n\n\treturn res;\n}\t\n\nint main(){\n\tmemset(dp,-1,sizeof dp);\n\tcin >> s >> K;\n\tN = sz(s);\n\n\tcout << solve(0,N-1,K);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*\n変更箇所は順読み逆読みの少なくとも片方で役立たないといけない\nつまり1点分として加算される必要がある\n逆に1点分以上の役割は持てない<-嘘だった\n例えば右端の文字が他に存在しない文字ならそれを変更するのはOK\n*/\n/*\n問題概要は最長の回文を作れ？\nだとすると中心決めてしまえばそこからは書き換えるかどうかは片側だけに注目すればよくて\nsBtに対してsを右側から見ていくことを考える\n変えるならt[now]しかありえなくて、書き換えた方がいいかどうかチェックするのに150^2かかる？\nなんか違いそう\n端から見て言ってdp[i][j][k]で考えるべき？\ndp[i][j][k]:左からi文字右からj文字、k文字変更した時の最長回文\ndp[i][j][k]=max(dp[i][j-1][k],dp[i-1][j][k],dp[i-1][j-1][k]+(s[i]==s[N-j-1]),dp[i-1][j-1][k-1]+1)\n*/\nint dp[400][400][400];\nsigned main(){\n  string s;int K;cin>>s>>K;\n  int N=s.size();\n  int ans=1;\n  for(int k=0;k<=K;k++){\n    for(int i=1;i<N;i++){\n      for(int j=1;i+j<=N;j++){\n        dp[i][j][k]=max({dp[i][j-1][k],dp[i-1][j][k],dp[i-1][j-1][k]+2*(s[i-1]==s[N-j])});\n        if(k)dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k-1]+2);\n        ans=max(ans,dp[i][j][k]+(i+j<N));\n      }\n    }\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nint m;\nusing namespace std;\nconst int N = 302;\nstring s;\nint f[N][N][N];\nint a[N];\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> s;\n    cin >> m;\n    for (int i = 0; i < s.size(); i++) a[i] = s[i - 1] - 'a';\n    int n = s.size(); a[0] = -1; a[n + 1] = -1;\n    f[1][n][0] = 0;\n    for (int i = 1; i <= n; i++) {\n        for (int j = n; j >= i; j--) {\n            for (int k = 0; k <= m; k++) {\n                f[i + 1][j][k] = max(f[i + 1][j][k], f[i][j][k]);\n                f[i][j - 1][k] = max(f[i][j - 1][k], f[i][j][k]);\n                if (a[i] != a[j]) {\n                    f[i + 1][j - 1][k + 1] = max(f[i + 1][j - 1][k + 1], f[i][j][k] + 1);\n                }\n                else {\n                    f[i + 1][j - 1][k] = max(f[i + 1][j - 1][k], f[i][j][k] + 1);\n                }\n            }\n        }\n    }\n    int mx = 0;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            for (int k = 0; k <= m; k++) {\n                if (i <= j) mx = max(mx, f[i][j][k] * 2);\n                else mx = max(mx, (f[i][j][k] - 1) * 2 + 1);\n            }\n        }\n    }\n    cout << mx << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for(int i = x; i < (int)(n); ++i)\n\nchar s[302];\nint dp[302][302];\n\nint main(){\n\tint k;\n\tscanf(\"%s%d\", s + 1, &k);\n\tint n = strlen(s + 1);\n\tf(i, 1, n + 1)for (int j = n; j > 0; --j){\n\t\tif (s[i] == s[j])dp[i][j] = 1 + dp[i - 1][j + 1];\n\t\telse dp[i][j] = max(dp[i - 1][j], dp[i][j + 1]);\n\t}\n\tint an = 0;\n\tf(i, 1, n){\n\t\tint sz1 = i, sz2 = n - i;\n\t\tint nv = dp[i][i + 1];\n\t\tnv = min(min(sz1, sz2), nv + k);\n\t\tan = max(an, nv << 1);\n\t}\n\tf(i, 1, n - 1){\n\t\tint sz1 = i, sz2 = n - i - 1;\n\t\tint nv = dp[i][i + 2];\n\t\tnv = min(min(sz1, sz2), nv + k);\n\t\tan = max(an, nv << 1 | 1);\n\t}\n\tprintf(\"%d\\n\", an);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define cal(x,y) (x=x>y?x:y)\nusing namespace std;\nconst int N=350;\nint gi(){\n    char ch=getchar(); int x=0,q=0;\n    while(ch<'0'||ch>'9') q=ch=='-'?1:q,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return q?-x:x;\n}\nint f[N][N][N],n,k;\nchar s[N];\nint main(){\n    scanf(\"%s%d\",s+1,&k);\n    n=strlen(s+1);\n    int ans=0;\n    for (int i=1; i<=n; ++i)\n\tfor (int j=n; j>=i; --j)\n\t    for (int l=k; ~l; --l){\n\t\tcal(f[i+1][j][l],f[i][j][l]);\n\t\tcal(f[i][j-1][l],f[i][j][l]);\n\t\tcal(f[i+1][j-1][l],f[i][j][l]+(s[i]==s[j]));\n\t\tif (l) cal(f[i+1][j-1][l-1],f[i][j][l]+1);\n\t    }\n    for (int i=1; i<=n; ++i)\n\tfor (int j=0; j<=k; ++j){\n\tcal(ans,f[i+1][i-1][j]*2-1);\n\tcal(ans,f[i+1][i][j]*2);\n    }\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar s[310];\nint K, f[310][310][610];\n\nint main() {\n    scanf(\"%s %d\", s + 1, &K);\n    int n = strlen(s + 1);\n    memset(f, -1, sizeof(f));\n    function<int(int, int, int)> dfs = [&](int l, int r, int k) {\n        if (l > r) return 0;\n        if (~f[l][r][k]) return f[l][r][k];\n        f[l][r][k] = max(dfs(l + 1, r, k), dfs(l, r - 1, k));\n        int t = s[l] != s[r];\n        if (k >= t) f[l][r][k] = max(f[l][r][k], dfs(l + 1, r - 1, k - t) + 1);\n        return f[l][r][k];\n    };\n    printf(\"%d\\n\", dfs(1, n, K) * 2 - 1);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\ntypedef long long ll;\nll dp[305][305][305]={0};\nbool used[305][305][305]={0};\nstring s;\nll get_dp(ll i,ll j,ll k){\n  if(i==j) return dp[i][j][k]=1;\n  else if(i+1==j){\n    if(k==0) return dp[i][j][k]=(s[i]==s[j]?2:1);\n    else return dp[i][j][k]=2;\n  }\n  else if(used[i][j][k]>0) return dp[i][j][k];\n  used[i][j][k]=true;\n  dp[i][j][k]=max(get_dp(i+1,j,k),get_dp(i,j-1,k));\n  if(s[i]==s[j]) dp[i][j][k]=max(dp[i][j][k],get_dp(i+1,j-1,k)+2);\n  else if(k>0) dp[i][j][k]=max(dp[i][j][k],get_dp(i+1,j-1,k-1)+2);\n  return dp[i][j][k];\n}\nint main(){\n  cin>>s;\n  ll k;\n  cin>>k;\n  for(int i=0;i<305;i++){\n    for(int j=0;j<305;j++){\n      for(int l=0;l<305;l++) used[i][j][l]=false;\n    }\n  }\n  cout<<get_dp(0,s.length()-1,k)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\nstring s;\nint k;\n\nint dp[324][324][324];\n\nint main(){\n\tcin >> s >> k;\n\tint n = s.size();\n\ts = \"*\" + s;\n\tfor(int i = 0;i < 324;i++)\n\t\tfor(int j = 0;j < 324;j++)\n\t\t\tfor(int k = 0;k < 324;k++)\n\t\t\t\tdp[i][j][k] = -100000;\n\t\n\tdp[0][n+1][0] = 0;\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = n;j > i;j--){\n\t\t\tfor(int k = 0;k <= n;k++){\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k]);\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i][j+1][k]);\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i][j+1][k]);\n\t\t\t\tif(k){\n\t\t\t\t\tint cost = s[i] != s[j];\n\t\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i-1][j+1][k-cost] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tfor(int i = 1;i <= n+1;i++){\n\t\tfor(int j = 0;j <= k;j++){\n\t\t\tres = max(res, dp[i-1][i+1][j] * 2 + 1);\n\t\t\tres = max(res, dp[i-1][i][j]*2);\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\t\t\t\t\t"
  },
  {
    "language": "C++",
    "code": "//In the name of Allah\n//In the name of the compassionate of the merciful\n//Ya Ali!\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntemplate<typename Type>\nusing ordered_multiset = tree<Type, null_type, less_equal<Type>, rb_tree_tag, tree_order_statistics_node_update> ;\n\ntypedef long long ll ;\ntypedef long double ld ;\n\n#define f first\n#define s second\n#define pb push_back\n#define pf push_front\n#define popb pop_back\n#define popf pop_front\n#define all(x) x.begin() , x.end()\n#define mp make_pair\n#define pll pair<ll,ll>\n#define pii pair<int,int>\n\n//ifstream fin(\"input.txt\");\n//ofstream fout(\"output.txt\");\n// fflush(stdout);\n\nconst ll maxn = 310 ;\nconst ll INF = 1e18 ;\n\nll mod = 1e9 + 7 , p1 = 999999929 , p2 = 999999937 ;\n\nll n , k , dp[maxn][maxn][maxn] ;\nstring s1 ;\n\nint main()\n{\nstd::ios::sync_with_stdio(0) ;\ncin.tie(0) ;\ncout.tie(0) ;\n\ncin >> s1 >> k ;\nn = s1.size() ;\n\nfor(int i = 0 ; i < n ; i ++)\n  for(int j = 0 ; j <= k ; j ++)\n    dp[i][i][j] = 1 ;\n\nfor(int r = 1 ; r < n ; r ++){\n for(int l = r-1 ; l >= 0 ; l --){\n  for(int co = 0 ; co <= k ; co ++){\n    dp[l][r][co] = max(dp[l][r][co] , dp[l+1][r][co]) ;\n    dp[l][r][co] = max(dp[l][r][co] , dp[l][r-1][co]) ;\n   if(r-l>1){\n    if(s1[l] == s1[r])dp[l][r][co] = max(dp[l][r][co] , dp[l+1][r-1][co]+2) ;\n    if(co > 0)dp[l][r][co] = max(dp[l][r][co] , dp[l+1][r-1][co-1]+2) ;\n   }\n  }\n }\n}\ncout << dp[0][n-1][k] ;\n return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-13;\nconst double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\ndouble ABS(double a){return max(a,-a);}\nchar in[310];\nint dp[310][310][310];\n\nint solve(int a,int b,int c){\n\tif(~dp[a][b][c])return dp[a][b][c];\n\tif(a>b)return 0;\n\tif(a==b)return 1;\n\n\tint ret=0;\n\tif(in[a]==in[b]){\n\t\tret=max(ret,solve(a+1,b-1,c)+2);\n\t}\n\tret=max(ret,solve(a+1,b,c));\n\tret=max(ret,solve(a,b-1,c));\n\tif(c){\n\t\tret=max(ret,solve(a+1,b-1,c-1)+2);\n\t}\n\treturn dp[a][b][c]=ret;\n}\nint main(){\n\tscanf(\"%s\",in);\n\tint a;scanf(\"%d\",&a);\n\tint n=strlen(in);\n\tfor(int i=0;i<310;i++)for(int j=0;j<310;j++)for(int k=0;k<310;k++)dp[i][j][k]=-1;\n\tprintf(\"%d\\n\",solve(0,n-1,a));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n#define INF 1000000000\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint dp[333][333][333];\nstring s;\nint k;\n\nint dfs(int K,int L,int R)\n{\n//\tcout << K << ' ' << L << ' ' << R << endl;\n\tif(K < 0)return -100000000;\n\tif(L > R)return 0;\n\tif(dp[K][L][R] != 0)return dp[K][L][R];\n\tint ret = 0;\n\tif(s[L] == s[R])ret = max(ret,dfs(K,L+1,R-1)+2);\n\telse ret = max(ret,dfs(K-1,L+1,R-1)+2);\n\tret = max(ret,dfs(K,L+1,R));\n\tret = max(ret,dfs(K,L,R-1));\n\t\n\treturn dp[K][L][R] = ret;\n}\n\n\nint main()\n{\n\tcin >> s >> k;\n\t\n\tREP(K,333)REP(i,333)dp[K][i][i] = 1;\n\tREP(K,333)REP(i,s.size()-2)\n\t{\n\t\tif(s[i] == s[i+1])dp[K][i][i+1] = 2;\n\t\telse dp[K][i][i+1] = 1;\n\t}\n\t\n\tcout << dfs(k,0,s.size()-1) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar s[311],s1[311],s2[311];\nint k,f[311][311][311],n,ans,ma;\n\nint main()\n{\n\tscanf(\"%s%d\",s,&k),n=strlen(s);\n\tfor (int i=0; i<n; i++) s1[i+1]=s[i],s2[i+1]=s[n-i-1];\n\tfor (int i=0; i<=n; i++) \n\t\tfor (int j=0; j<=n; j++)\n\t\t\tfor (int l=0; l<=k; l++) f[i][j][l]=-114514;\n\tfor (int i=0; i<=n; i++) \n\t\tfor (int j=0; j<=k; j++) f[0][i][j]=f[i][0][j]=0;\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tfor (int l=0; l<=k; l++)\n\t\t\t{\n\t\t\t\tf[i][j][l]=max(f[i-1][j-1][l]+(s1[i]==s2[j]),max(f[i-1][j][l],f[i][j-1][l]));\n\t\t\t\tif (l) f[i][j][l]=max(f[i][j][l],f[i-1][j-1][l-1]+1);\n\t\t\t}\n\tans=1;\n\tfor (int i=0; i<n; i++) ans=max(ans,max(2*f[i][n-i][k],2*f[i][n-i-1][k]+1));\n\treturn printf(\"%d\\n\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n//\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//\nconstexpr ll MOD=1e9+7;\n//constexpr ll MOD=998244353;\n//constexpr ll MOD=10000000;\n//constexpr ll MOD=1e5;\nconstexpr ll MAX=3e6;\nconstexpr ll INF=(1ll<<60);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate<typename T>\nstruct Segment_tree{\n    ll N;\n    T mem;\n    vector<T> node;\n    Segment_tree(vector<T> &X,T m):mem(m){\n        ll sz=X.size();\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mem);\n        rep(i,0,sz) node[N-1+i]=X[i];\n        per(i,N-2,0){\n            node[i]=Compare(node[i*2+1],node[i*2+2]);\n        }\n    }\n    T Compare(T &A,T &B){\n        return std::max(A,B);\n    }\n    void update(ll X,T val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=Compare(node[X*2+1],node[X*2+2]);\n        }\n    }\n    T Query(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mem;\n        if(a<=l&&r<=b) return node[now];\n        auto vl=Query(a,b,now*2+1,l,(l+r)/2),vr=Query(a,b,now*2+2,(l+r)/2,r);\n        return Compare(vl,vr);\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,int a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nvoid comp(vi &A){\n    std::map<ll,ll> mem;\n    rep(i,0,A.size()) mem[A[i]]=0;\n    ll cnt=0;\n    for(auto &p:mem) p.second=cnt++;\n    rep(i,0,A.size()) A[i]=mem[A[i]];\n}\nll RLCS(string S){\n    string T=S;\n    reverse(ALL(T));\n    ll N=S.size();\n    vii dp(N+1,vi(N+1));\n    REP(i,0,N){\n        REP(j,0,N){\n            if(!i){\n                if(j) dp[i][j]=dp[i][j-1];\n            }\n            else if(!j){\n                dp[i][j]=dp[i-1][j];\n            }\n            else{\n                dp[i][j]=std::max(dp[i][j-1],dp[i-1][j]);\n                if(S[i-1]==T[j-1]) dp[i][j]=std::max(dp[i][j],dp[i-1][j-1]+1);\n            }\n        }\n    }\n    return dp[N][N];\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    string S; cin>>S;\n    ll K,N=S.size(); cin>>K;\n    string T=S; reverse(ALL(T));\n    K=std::min(K,N/2);\n    vector<vii> dp(N/2+1,vii(N/2+1,vi(K+1,INF)));\n    dp[0][0][0]=0;\n    vii mem(26);\n    rep(i,0,N/2) mem[T[i]-'a'].pb(i+1);\n    rep(i,0,N/2){\n        REP(j,0,N/2){\n            REP(k,0,K) dp[i+1][j][k]=dp[i][j][k];\n        }\n        rep(j,0,N/2){\n            REP(k,0,K){\n                if(dp[i][j][k]==INF) continue;\n                ll X=disup(mem[S[i]-'a'],dp[i][j][k]);\n                if(X<mem[S[i]-'a'].size()){\n                    ll Y=mem[S[i]-'a'][X];\n                    dp[i+1][j+1][k]=std::min(dp[i+1][j+1][k],Y);\n                }\n                if(dp[i][j][k]<N/2&&k<K){\n                    dp[i+1][j+1][k+1]=std::min(dp[i+1][j+1][k+1],dp[i][j][k]+1);\n                }\n            }\n        }\n    }\n    ll ans=0;\n    REP(i,0,N/2){\n        REP(j,0,N/2){\n            REP(k,0,K){\n                if(dp[i][j][k]!=INF){\n                  ans=std::max(ans,j);\n                }\n            }\n        }\n    }\n    ll memo=ans;\n    per(i,N/2,0){\n        ll left=i,right=N-dp[i][memo][K]-1;\n        if(left>right){\n            if(dp[i][memo][K]!=INF) ans=std::max(ans,memo*2);\n            continue;\n        }\n        string P=S.substr(left,right-left+1);\n        ans=std::max(ans,memo*2+RLCS(P));\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nint K, dp[309][309][309]; string S;\n\nint solve(int l, int r, int c) {\n\tif (c > K) return -(1 << 30);\n\tif (l > r) return 0;\n\tif (l == r) return 1;\n\tif (dp[l][r][c] >= 0) return dp[l][r][c];\n\tint ret = 0;\n\tret = max(ret, solve(l + 1, r, c));\n\tret = max(ret, solve(l, r - 1, c));\n\tif (S[l] == S[r]) ret = max(ret, solve(l + 1, r - 1, c) + 2);\n\telse ret = max(ret, solve(l + 1, r - 1, c + 1) + 2);\n\tdp[l][r][c] = ret;\n\treturn ret;\n}\n\nint main() {\n\tcin >> S >> K;\n\tfor (int i = 0; i < 309; i++) { for (int j = 0; j < 309; j++) { for (int k = 0; k < 309; k++) dp[i][j][k] = -1; } }\n\tcout << solve(0, S.size() - 1, 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int maxN = 305;\nint dp[maxN][maxN][maxN];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    string s;\n    int k;\n    cin >> s >> k;\n    int n = s.size();\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= n - i; j++) {\n            for (int cnt = k; cnt >= 0; cnt--) {\n                if (!i || !j) continue;\n                dp[i][j][cnt] = max(dp[i][j][cnt], dp[i - 1][j][cnt]);\n                dp[i][j][cnt] = max(dp[i][j][cnt], dp[i][j - 1][cnt]);\n                if (cnt) {\n                    dp[i][j][cnt] = max(dp[i][j][cnt], dp[i - 1][j - 1][cnt - 1] + 2);\n                }\n                if (s[i - 1] == s[n - j]) {\n                    dp[i][j][cnt] = max(dp[i][j][cnt], dp[i - 1][j - 1][cnt] + 2);\n                }\n            }\n        }\n    }\n    int best = 0;\n    for (int cut = 0; cut < n; cut++) {\n        best = max(best, dp[cut][n - cut - 1][k] + 1);\n    }\n    for (int cut = 0; cut < n; cut++) {\n        best = max(best, dp[cut][n - cut][k]);\n    }\n    cout << best;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#ifdef leowang\n#define debug(...) do{\\\n\tfprintf(stderr,\"%s - %d : (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);\\\n\t_DO(__VA_ARGS__);\\\n}while(0)\ntemplate<typename I> void _DO(I&&x){cerr<<x<<endl;}\ntemplate<typename I,typename...T> void _DO(I&&x,T&&...tail){cerr<<x<<\", \";_DO(tail...);}\n#else\n#define debug(...)\n#endif\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n}\n//}}}\nconst ll maxn=305;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=8000000000000000000LL;\nconst int INF=2000000000;\nconst ll MOD=ll(1e9+7);\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n/*\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) a=a*a%MOD;\n\t\telse res=res*a%MOD;\n\t\tb>>=1;\n\t}\n\tres=res*a%mod;\n\treturn res;\n}\n*/\nstring s,t;\nint dp[maxn][maxn][maxn*2];\n\nint f(int i,int j,int k){\n\tif(k<0) return -INF;\n\tif(i==0||j==0) return 0;\n\tif(dp[i][j][k]!=-1) return dp[i][j][k];\n\tif(s[i-1]==t[j-1]) return f(i-1,j-1,k)+1;\n\treturn dp[i][j][k]=max({f(i-1,j,k),f(i,j-1,k),f(i-1,j-1,k-1)+(SZ(s)%2==0||i!=SZ(s)/2||j!=SZ(s)/2)});\n}\n\nint main()\n{\n\tIOS;\n\tmemset(dp,-1,sizeof dp);\n\tint k;\n\tcin>>s>>k;\n\tt=s;\n\treverse(ALL(t));\n\tint ans=0;\n\tREP(i,SZ(s)){\n\t\tans=max(ans,f(i,SZ(s)-1-i,k));\n\t}\n\tcout<<ans*2+1;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 3e2 + 5;\nint n,m;\nchar s[maxn];\nint dp[maxn][maxn][maxn];\nint main () {\n    int ans = 0;\n    scanf(\" %s%d\",s,&m);\n    n = strlen(s);\n    for(int i=n;i>=1;i--) s[i] = s[i-1];\n    for(int l=1;l<=n;l++) {\n        for(int r=n;r>=l;r--) {\n            for(int k=0;k<=m;k++) {\n                int t = max(dp[l-1][r][k], dp[l][r+1][k]);\n                if(s[l]==s[r]) t = max(t, dp[l-1][r+1][k] + 1);\n                if(k>0) t = max(t, dp[l-1][r+1][k-1] + 1);\n                dp[l][r][k] = t;\n                ans = max(ans, dp[l][r][k]*2 - (l==r ? 1 : 0));\n//                printf(\"dp %d %d %d = %d (%c and %c)\\n\",l,r,k,dp[l][r][k],s[l],s[r]);\n            }\n        }\n    }\n    printf(\"%d\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include <boost/multiprecision/cpp_int.hpp>\n// using i128 = boost::multiprecision::int128_t;\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = vector<int>;\nusing Vll = vector<ll>;\nusing Vld = vector<ld>;\nusing Vbo = vector<bool>;\nusing VV = vector<V>;\nusing VVll = vector<Vll>;\nusing VVld = vector<Vld>;\nusing VVbo = vector<Vbo>;\nusing VVV = vector<VV>;\nusing VVVll = vector<VVll>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\n#define rep2(i, m, n) for(int i=int(m); i<int(n); ++i)\n#define drep2(i, m, n) for(int i=int(m)-1; i>=int(n); --i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) a.begin(), a.end()\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << \" \"; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int Log2(ll x) { int k; for (k = 0; x > 0; ++k) x >>= 1; return k; } // number of binary digits\nconst int INF  = 1<<30;\nconst ll INFll = 1ll<<62;\nconst ld EPS   = 1e-10;\nconst ld PI    = acos(-1.0);\nconst int MOD  = int(1e9)+7;\n// const int MOD  = 998244353;\n\n\nint main() {\n  string s; cin >> s;\n  int K; cin >> K;\n  int n = s.size();\n\n  VVV dp(K+2, VV(n+1, V(n+1)));\n\n  rep(k, K+1) rep(i, n) rep(j, n) {\n    chmax(dp[k][i+1][j+1], dp[k][i+1][j]);\n    chmax(dp[k][i+1][j+1], dp[k][i][j+1]);\n    chmax(dp[k][i+1][j+1], dp[k][i][j] + (s[i] == s[n-1-j]));\n    chmax(dp[k+1][i+1][j+1], dp[k][i+1][j]);\n    chmax(dp[k+1][i+1][j+1], dp[k][i][j+1]);\n    chmax(dp[k+1][i+1][j+1], dp[k][i][j] + 1);\n  }\n  \n  int ans = 0;\n  rep(i, n) chmax(ans, dp[K][i+1][n-i]);\n  ans = ans*2 - 1;\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i, a, b) for (int i = (a); i < (b); ++i)\n#define F2(i, a, b) for (int i = (a); i <= (b); ++i)\n#define dF(i, a, b) for (int i = (a); i > (b); --i)\n#define dF2(i, a, b) for (int i = (a); i >= (b); --i)\n#define maxn 310\nusing namespace std;\ntypedef long long LL;\nchar ss[maxn];\nint dp[maxn][maxn][maxn];\nint main() {\n    int n;\n    scanf(\"%s%d\", ss, &n);\n    int len = strlen(ss);\n    F(i, 0, len) F2(j, 0, n) dp[i][i][j] = dp[i][i+1][j] = 1;\n    F2(l, 2, len) {\n        F2(s, 0, len-l) {\n            int t = s+l;\n            F2(k, 0, n) {\n                dp[s][t][k] = max(max(dp[s+1][t][k], dp[s][t-1][k]), dp[s+1][t-1][k]+(ss[s]==ss[t]?2:0));\n                if (k) dp[s][t][k] = max(dp[s][t][k], max(dp[s][t][k-1], dp[s+1][t-1][k-1]+2));\n            }\n        }\n    }\n    printf(\"%d\\n\", dp[0][len][n]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\n\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntemplate<typename T>inline void upmin(T &x,T y) { y<x?x=y:0; }\ntemplate<typename T>inline void upmax(T &x,T y) { x<y?x=y:0; }\n\ntypedef unsigned int u32;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst LL OO=1e18;\n\nconst int N=310;\n\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\n\nint f[N][N][N];\nchar s[N];\nint main()\n{\n\t//cout<<sizeof(f)/1024/1024<<endl;return 0;\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1),l,r,k,lim=gi(),ans=0;\n\tfor (l=1;l<=n;l++)\n\t\tfor (r=n;r>=l;r--)\n\t\t\tfor (k=0;k<=lim;k++) {\n\t\t\t\tif (k||s[l]==s[r])\n\t\t\t\t\tupmax(f[l][r][k],f[l-1][r+1][k-(s[l]!=s[r])]+1+(l!=r));\n\t\t\t\tupmax(f[l][r][k],f[l-1][r][k]);\n\t\t\t\tupmax(f[l][r][k],f[l][r+1][k]);\n\t\t\t\tupmax(ans,f[l][r][k]);\n\t\t\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long int\n#define ull unsigned long long int\n#define mod 998244353 \n#define pb push_back\n//#define mp make_pair\n#define INF 2000000011LL\n#define INFLL 1000000000000000011LL\n#define eps 1e-9\n#define pp pair < pair<ll,ll> , ll> \n#define fo(i,j,k) for(int i=j;i<=k;i++)\n#define foll(i,j,k) for(ll i=j;i<=k;i++)\n#define clr(a) memset(a,0,sizeof(a))\n#define vi vector<int>\n#define vll vector<ll>\n#define sz(a) a.size()\n#define len(a) a.length()\n#define all(a) a.begin(),a.end()\n#define io_file freopen(\"Contest/input_file.in\", \"r\", stdin); freopen(\"Contest/output_file.in\", \"w\", stdout)\n\nconst int MAXN = 2e5+5;\nusing namespace std;\nll power(ll x, ll y)\n{\n  ll res = 1;\n  while(y>0)\n  {\n    if(y&1)\n       {\n         res = (res*x)%mod;\n        }\n     x = (x*x)%mod;\n     y = y>>1;\n  }\n    return res;\n}\n// std::vector<ll> divi[100004];\n// void divisor(int n)\n// {\n//    for(ll i=1;i<=n;i++)\n//    {\n//      for(ll j=i;j<=n;j+=i)\n//      {\n//        divi[j].pb(i);\n//      }\n//    }\n// }\n\nstring s;\nint K;\nint dp[305][305][305];\n\nll solve(int i, int j, int k)\n{\n\tif(i > j) return 0;\n\tif(i==j) return dp[i][j][k]=1;\n\tif(dp[i][j][k]!=-1) return dp[i][j][k];\n\tif(i+1==j){\n\t\tif(s[i]==s[j])\n\t\t{\n\t\t\treturn dp[i][j][k] = 2;\n\t\t}\n\t\telse {\n\t\t\tif(k==0)\n\t\t\t\treturn dp[i][j][k] = 1;\n\t\t\telse  if(k > 0) return dp[i][j][k] = 2;\n\t\t} \n\t}\n\tll ans=max(solve(i+1,j,k),solve(i,j-1,k));\n\tif(s[i]==s[j])\n\t{\n\t\tans  = max(ans, 2 + solve(i+1,j-1,k));\n\t\n\t}\n\telse if(k>0){\n\t\tans = max(ans,2 + solve(i+1,j-1,k-1));\n\t}\n\treturn dp[i][j][k] =  ans;\n}\n\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    memset(dp,-1,sizeof(dp));\n    cin>>s;\n    cin>>K;\n    \n    cout<<solve(0,s.length()-1,K)<<endl;\n    return 0;\n\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[305][305][305];\n\nint main(){\n  \n  string s;\n  int K;\n  \n  cin>>s>>K;\n  \n  memset(dp,-1,sizeof(dp));\n\n  s='x'+s;\n  \n  int len=s.size();\n  \n  dp[1][len-1][0]=0;\n  \n  for(int l=1;l<len;l++)\n    \n    for(int r=len-1;r>=l;r--){\n      \n      for(int k=0;k<=K;k++){\n\t\n\tif(dp[l][r][k]==-1) continue;\n\t\n\tif(s[l]==s[r]){\n\t  if(l==r) dp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]+1);\n\t  else dp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]+2);\n\t}\n\t\n\tif(l==r) continue;\n\t\n\tdp[l+1][r-1][k+1]=max(dp[l+1][r-1][k+1], dp[l][r][k]+2);\n\tdp[l+1][r][k]=max(dp[l+1][r][k], dp[l][r][k]);\n\tdp[l][r-1][k]=max(dp[l][r-1][k], dp[l][r][k]);\n\tdp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]);\n      }\n    }\n  \n  int ans=0;\n  \n  for(int i=0;i<=len;i++)\n    for(int j=0;j<=len;j++)\n      for(int k=0;k<=K;k++) ans=max(ans, dp[i][j][k]);\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\n//const int mod = ;\n\nint d[305][305][305];\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  string s;\n  int k;\n  cin >> s >> k;\n  int n = s.size();\n  if (k == n) {\n    cout << n << endl; return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    d[i][i][0] = 1;\n  }\n  int res = 0;\n  for (int l = 2; l <= n; ++l) {\n    for (int i = 0; i + l <= n; ++i) {\n      int j = i + l - 1;\n      for (int t = 0; t <= k; ++t) {\n        d[i][j][t] = max(d[i+1][j][t], d[i][j-1][t]);\n        if (s[i] == s[j]) d[i][j][t] = max(d[i][j][t], d[i+1][j-1][t] + 2);\n        if (t) {\n          d[i][j][t] = max(max(d[i][j][t], d[i+1][j-1][t-1] + 2), d[i][j][t-1]);\n        }\n        res = max(res, d[i][j][t]);\n      }\n    }\n  }\n  cout << max(1, res) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define forab(i, a, b) for (int i = int(a); i < int(b); ++i)\n#define ford(i, n) for (int i = int(n) - 1; i >= 0; --i)\n#define sz(c) int((c).size())\n#define all(c) (c).begin(), (c).end()\n#define mp(x, y) make_pair(x, y)\n#define pb push_back\n#define fst first\n#define snd second\n \nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing pii = pair<int, int>;\nusing vvi = vector<vi>;\n \n#define FILE_NAME \"a\"\n \nstring s;\nint k;\n \nbool read() {\n    if (!(cin >> s >> k)) {\n        return 0;\n    }\n    return 1;\n}\n\nvoid remax (int &x, int y)\n{\n    x = max(x, y);\n}\n\nconst int N = 310;\nconst int inf = (int)1e9;\nint dp[N][N][N];\n \nvoid solve() {\n    fill_n(&dp[0][0][0], N * N * N, -inf);\n    \n    const int n = sz(s);\n\n    forn (r, n + 1) ford (l, r + 1) forn (ch, k + 1)\n    {\n        int &cur = dp[l][r][ch];\n\n        const int len = r - l;\n        \n        if (len <= 1)\n        {\n            cur = len;\n            continue;\n        }\n            \n        remax(cur, dp[l][r - 1][ch]);\n        remax(cur, dp[l + 1][r][ch]);\n        if (s[l] == s[r - 1])\n            remax(cur, dp[l + 1][r - 1][ch] + 2);\n        else if (ch)\n            remax(cur, dp[l + 1][r - 1][ch - 1] + 2);\n    }\n\n    int ans = 0;\n    forn (ch, k + 1)\n       remax(ans, dp[0][n][k]);\n    cout << ans << endl; \n}\n \nint main() {\n#ifdef LOCAL\n    freopen(FILE_NAME \".in\", \"r\", stdin);\n//    freopen(FILE_NAME \".out\", \"w\", stdout);\n#endif\n \n    while (read()) {\n        solve();\n    }\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=310;\nint n,k,f[N][N][N];\nchar s[N];\nint main(){\n\tscanf(\"%s\",s+1);\n\tscanf(\"%d\",&k);\n\tn=strlen(s+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=k;j++) f[i][i][j]=1;\n\tint l,r;\n\tfor(int i=2;i<=n;i++)\n\t\tfor(int j=1;j<=n-i+1;j++)\n\t\t\tfor(int x=0;x<=k;x++){\n\t\t\t\tl=j,r=j+i-1;\n\t\t\t\tf[l][r][x]=max(f[l+1][r][x],f[l][r-1][x]);\n\t\t\t\tif(x) f[l][r][x]=max(f[l][r][x],f[l+1][r-1][x-1]+2);\n\t\t\t\tif(s[l]==s[r]) f[l][r][x]=max(f[l][r][x],f[l+1][r-1][x]+2);\n\t\t\t}\n\tprintf(\"%d\",f[1][n][k]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define rep(i, s, t) for(i = s; i <= t; ++i)\n#define dep(i, s, t) for(i = s; i >= t; --i)\n\nusing namespace std;\n\nconst int N = 310;\nint n, m, K, ans;\nchar s[N], t[N];\nint f[N][N][N];\n\nint main() {\n\tint i, j, k;\n\tscanf(\"%s\", s+1); n = strlen(s+1);\n\tm = n >> 1;\n\trep(i, 1, n) t[i] = s[n-i+1];\n\t\n\tscanf(\"%d\", &K);\n\trep(i, 1, m) {\n\t\trep(j, 1, n-i) \n\t\t\trep(k, 0, K) {\n\t\t\t\tf[i][j][k] = max(f[i-1][j][k], f[i][j-1][k]);\n\t\t\t\tif(k) f[i][j][k] = max(f[i][j][k], f[i][j][k-1]);\n\t\t\t\tif(s[i] == t[j]) {\n\t\t\t\t\tf[i][j][k] = max(f[i-1][j-1][k]+1, f[i][j][k]);\n\t\t\t\t} else {\n\t\t\t\t\tif(k) f[i][j][k] = max(f[i-1][j-1][k-1]+1, f[i][j][k]);\n\t\t\t\t}\n\t\t\t\t//printf(\"%d %d %d %d\\n\", i, j, k, f[i][j][k]);\n\t\t\t}\n\t\tif(n&1) ans = max(ans, f[i][n-i-1][K]*2+1);\n\t\tans = max(ans, f[i][n-i][K]*2);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/************************************************\n * Au: Hany01\n * Date: Feb 25th, 2018\n * Prob: AGC021 D Reversed LCS\n * Email: hany01@foxmail.com\n************************************************/\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define rep(i, j) for (register int i = 0, i##_end_ = (j); i < i##_end_; ++ i)\n#define For(i, j, k) for (register int i = (j), i##_end_ = (k); i <= i##_end_; ++ i)\n#define Fordown(i, j, k) for (register int i = (j), i##_end_ = (k); i >= i##_end_; -- i)\n#define Set(a, b) memset(a, b, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define fir first\n#define sec second\n#define pb(a) push_back(a)\n#define mp(a, b) make_pair(a, b)\n#define ALL(a) (a).begin(), (a).end()\n#define SZ(a) ((int)(a).size())\n#define INF (0x3f3f3f3f)\n#define INF1 (2139062143)\n#define Mod (1000000007)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define y1 wozenmezhemecaia\n\ntemplate <typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\n\ninline int read()\n{\n\tregister int _, __; register char c_;\n    for (_ = 0, __ = 1, c_ = getchar(); c_ < '0' || c_ > '9'; c_ = getchar()) if (c_ == '-') __ = -1;\n    for ( ; c_ >= '0' && c_ <= '9'; c_ = getchar()) _ = (_ << 1) + (_ << 3) + (c_ ^ 48);\n    return _ * __;\n}\n\ninline void File()\n{\n#ifdef hany01\n    freopen(\"agc021d.in\", \"r\", stdin);\n    freopen(\"agc021d.out\", \"w\", stdout);\n#endif\n}\n\nconst int maxn = 310;\n\nchar s[maxn];\nint n, k, f[maxn][maxn][maxn];\n\nint main()\n{\n    File();\n\tscanf(\"%s\", s + 1), n = strlen(s + 1), k = read();\n\tFor(len, 1, n)\n\t\tFor(st, 1, n - len + 1) {\n\t\t\tregister int ed = st + len - 1;\n\t\t\tFor(i, 0, k) {\n\t\t\t\tif (st == ed) f[st][ed][i] = 1;\n\t\t\t\telse if (st + 1 == ed) f[st][ed][i] = i || s[st] == s[ed] ? 2 : 1;\n\t\t\t\telse {\n\t\t\t\t\tf[st][ed][i] = max(f[st + 1][ed][i], f[st][ed - 1][i]);\n\t\t\t\t\tif (s[st] == s[ed]) chkmax(f[st][ed][i], f[st + 1][ed - 1][i] + 2);\n\t\t\t\t\tif (i) chkmax(f[st][ed][i], f[st + 1][ed - 1][i - 1] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\", f[1][n][k]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nint main(void) {\n  string S;\n  ll N, K;\n  cin >> S >> K;\n  N = S.length();\n\n  ll dp[N][N][K + 1];\n  REP(l, 0, N) REP(r, l, N) REP(k, 0, K + 1) dp[l][r][k] = 0;\n  REP(l, 0, N) REP(k, 0, K + 1) dp[l][l][k] = 1;\n  REP(l, 0, N - 1) if(S[l] == S[l + 1]) dp[l][l + 1][0] = 2;\n  REP(l, 0, N - 1) REP(k, 1, K + 1) dp[l][l + 1][k] = 2;\n  REP(s, 0, N) REP(l, 0, N - s) {\n    ll r = l + s;\n    REP(k, 0, K + 1) {\n      if(l + 1 <= r - 1 && S[l + 1] == S[r - 1]) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k] + 2);\n      if(l + 1 <= r) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r][k]);\n      if(l <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l][r - 1][k]);\n      if(k > 0 && l + 1 <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k - 1] + 2);\n      if(k > 0 && l + 1 <= r) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r][k - 1]);\n      if(k > 0 && l <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l][r - 1][k - 1]);\n      if(k > 0) dp[l][r][k] = max(dp[l][r][k], dp[l][r][k - 1]);\n    }\n  }\n  cout << dp[0][N - 1][K] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstring s;\nint K;\nint dp[301][301][301];\nmain()\n{\n\tcin>>s>>K;\n\tint N=s.size();\n\tfor(int i=0;i<=N;i++)for(int k=0;k<=N;k++)for(int j=0;j<=K;j++)dp[i][k][j]=-1e9;\n\tdp[0][N-1][K]=0;\n\tint ans=0;\n\tfor(int i=0;i<N;i++)for(int j=N-1;j>=0&&j>=i-1;j--)for(int k=0;k<=K;k++)\n\t{\n\t\tif(dp[i][j][k]<0)continue;\n\t\tans=max(ans,dp[i][j][k]+(i<=j));\n\t\tdp[i+1][j][k]=max(dp[i+1][j][k],dp[i][j][k]);\n\t\tif(j>0)dp[i][j-1][k]=max(dp[i][j-1][k],dp[i][j][k]);\n\t\tif(i<j)dp[i+1][j-1][k-(s[i]!=s[j])]=max(dp[i+1][j-1][k-(s[i]!=s[j])],dp[i][j][k]+2);\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n#define MOD 1000000007\n\nint dp[301][301];\n\nint main(){\n  string s;\n  cin>>s;\n  reverse(s.begin(),s.end());\n  string t=s;\n  reverse(s.begin(),s.end());\n  int k,n=s.length()-1;\n  cin>>k;\n  for(int i=0;i<s.length();i++){\n    if(s[i]==t[i]) continue;\n    if(s[i]==t[n-i]&&s[n-i]==t[i]){\n      k--;\n      s[i]=t[n-i]=s[n-i];\n    }\n    if(k==0) break;\n  }\n  for(int i=0;i<s.length();i++){\n    for(int j=0;j<s.length();j++){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n      }else{\n        dp[i+1][j+1]=max(dp[i][j+1],dp[i+1][j]);\n      }\n    }\n  }\n  cout<<dp[s.length()][s.length()]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define lint long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\ntemplate <typename T> inline T LB(vector<T>& v, T a) { return *lower_bound(ALL(v),a); }\ntemplate <typename T> inline int LBP(vector<T>& v, T a) { return lower_bound(ALL(v),a) - v.begin(); }\ntemplate <typename T> inline T UB(vector<T>& v, T a) { return *upper_bound(ALL(v),a); }\ntemplate <typename T> inline int UBP(vector<T>& v, T a) { return upper_bound(ALL(v),a) - v.begin(); }\ntemplate <typename T1, typename T2> ostream& operator<< (ostream& os, const pair<T1,T2>& p) { os << p.first << \" \" << p.second; return os; }\ntemplate <typename T1, typename T2> istream& operator>> (istream& is, pair<T1,T2>& p) { is >> p.first >> p.second; return is; }\ntemplate <typename T> ostream& operator<< (ostream& os, const vector<T>& v) { REP(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\ntemplate <typename T> istream& operator>> (istream& is, vector<T>& v) { for(T& in : v) is >> in; return is; }\ntemplate <typename T = int> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate <typename T, typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...)); }\ntemplate <typename T, typename V> typename enable_if<is_class<T>::value == 0>::type fill_v(T &t, const V &v) { t = v; }\ntemplate <typename T, typename V> typename enable_if<is_class<T>::value != 0>::type fill_v(T &t, const V &v) { for(auto &e : t) fill_v(e,v); }\nconst lint MOD = 1000000007;\nconst lint INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n\nstring S;\nint K;\nint dp[310][310][310];\n\nint dfs(int l, int r, int k) {\n    if (l == r)\n        return dp[l][r][k] = 1;\n    if (l > r)\n        return dp[l][r][k] = 0;\n    if (dp[l][r][k]) return dp[l][r][k];\n    int res = -1;\n    if (S[l] == S[r]) {\n        CHMAX(res, dfs(l + 1, r - 1, k) + 2);\n    } else {\n        if (k > 0)\n            CHMAX(res, dfs(l + 1, r - 1, k - 1) + 2);\n        CHMAX(res, dfs(l + 1, r, k));\n        CHMAX(res, dfs(l, r - 1, k));\n    }\n    return dp[l][r][k] = res;\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    cin >> S >> K;\n    cout << dfs(0, S.size() - 1, K) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <cassert>\n\nusing namespace std;\n\nconst int MOD = int(1e9) + 7;\n\nchar S[305];\nint tb[305][305][305];\n\nint main()\n{\n    int K; scanf(\"%s%d\", S+1, &K);\n    int N = strlen(S+1);\n    for(int i = 1; i <= N; i++) {\n      for(int k = 0; k <= K; k++) {\n        tb[i][i][k] = 1;\n      }\n    }\n    for(int l = 2; l <= N; l++) {\n      for(int i = 1, j = l; j <= N; i++, j++) {\n        tb[i][j][0] = max(\n          max(tb[i+1][j][0], tb[i][j-1][0]),\n          tb[i+1][j-1][0] + (S[i] == S[j] ? 2 : 0)\n        );\n        for(int k = 1; k <= K; k++) {\n          tb[i][j][k] = max(\n            max(tb[i+1][j][k], tb[i][j-1][k]),\n            tb[i+1][j-1][S[i] == S[j] ? k : k-1] + 2\n          );\n        }\n      }\n    }\n\n    int ans = 0;\n    for(int i = 1; i <= N; i++) {\n      for(int j = i; j <= N; j++) {\n        for(int k = 0; k <= K; k++) {\n          ans = max(ans, tb[i][j][k]);\n        }\n      }\n    }\n\n    printf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define INF (1LL << 55)\n#define MOD (1000 * 1000 * 1000 + 7)\n#define maxn 311\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\n\nint dp[maxn][maxn][maxn]; // dp[from][to][x changes left] - longest subsequence palindrome in range [from, to] with x changes left\nchar str[maxn];\n\nint main(){\n\tint n, k;\n\tscanf(\"%s\", str + 1);\n\tscanf(\"%d\", &k);\n\tn = strlen(str + 1);\n\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 0; j <= k; j++)\n\t\t\tdp[i][i][j] = 1;\n\t}\n\n\tfor(int len = 2; len <= n; len++){\n\t\tfor(int l = 1; l + len - 1 <= n; l++){\n\t\t\tint d = l + len - 1;\n\n\t\t\tfor(int j = 0; j <= k; j++){\n\t\t\t\tif(j > 0)\n\t\t\t\t\tdp[l][d][j] = max(dp[l][d][j], dp[l][d][j - 1]);\n\n\t\t\t\tdp[l][d][j] = max(dp[l][d][j], dp[l + 1][d][j]);\n\t\t\t\tdp[l][d][j] = max(dp[l][d][j], dp[l][d - 1][j]);\n\n\t\t\t\tif(j > 0)\n\t\t\t\t\tdp[l][d][j] = max(dp[l][d][j], dp[l + 1][d - 1][j - 1] + 2);\n\n\t\t\t\tif(str[l] == str[d])\n\t\t\t\t\tdp[l][d][j] = max(dp[l][d][j], dp[l + 1][d - 1][j] + 2);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", dp[1][n][k]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<double, double> P;\ntypedef pair<P, int> PI;\nconst LL MOD = 1000000007LL;\nconst double EPS = 1e-10;\nint dp[300][301][301];\nint main() {\n\tstring S;\n\tcin >> S;\n\tint K;\n\tcin >> K;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tfor (int j = 0; j <= K; j++) dp[i][i + 1][j] = 1;\n\t}\n\tfor (int len = 2; len <= S.size(); len++) {\n\t\tfor (int i = 0; i + len <= S.size(); i++) {\n\t\t\tfor (int j = 0; j <= K; j++) {\n\t\t\t\tif (S[i] == S[i + len - 1]) {\n\t\t\t\t\tdp[i][i + len][j] = max(dp[i][i + len][j], dp[i + 1][i + len - 1][j] + 2);\n\t\t\t\t}\n\t\t\t\tdp[i][i + len][j] = max(dp[i][i + len][j], dp[i + 1][i + len][j]);\n\t\t\t\tdp[i][i + len][j] = max(dp[i][i + len][j], dp[i][i + len - 1][j]);\n\t\t\t\tif (j > 0) {\n\t\t\t\t\tdp[i][i + len][j] = max(dp[i][i + len][j], dp[i + 1][i + len][j - 1] + 2);\n\t\t\t\t\tdp[i][i + len][j] = max(dp[i][i + len][j], dp[i][i + len - 1][j - 1] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= K; i++) ans = max(ans, dp[0][S.size()][i]);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\n\nint mat[301][301] = {0};\n\nint main() {\n\tint n;\n\tint res = 0;\n\n\tstring a, b;\n\tint k;\n\tcin >> a;\n\tcin >> k;\n\tfor(int i=0; i<a.size(); ++i)\n\t\tb += a[a.size()-i-1];\n\n\tdprint(a, b);\n\tn = max(a.size(), b.size());\n\n\tfor(int i=0; i<2*n; ++i)\n\t\tfor(int j=0; j<=i; ++j)\n\t\t{\n\t\t\tint y = i-j;\n\t\t\tint x = j;\n\t\t\tif(a.size() <= y || b.size() <= x)\n\t\t\t\tcontinue;\n\n\t\t\tif(a[y] == b[x])\n\t\t\t\tmat[y+1][x+1] = mat[y][x] + 1;\n\t\t\telse\n\t\t\t\tmat[y+1][x+1] = max(mat[y][x+1], mat[y+1][x]);\n\t\t}\n\n\tint ans = mat[a.size()][b.size()];\n\tans += 2*k;\n\tans = min(ans, n);\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n//\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//\nconstexpr ll MOD=1e9+7;\n//constexpr ll MOD=998244353;\n//constexpr ll MOD=10000000;\n//constexpr ll MOD=1e5;\nconstexpr ll MAX=3e6;\nconstexpr ll INF=(1ll<<60);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate<typename T>\nstruct Segment_tree{\n    ll N;\n    T mem;\n    vector<T> node;\n    Segment_tree(vector<T> &X,T m):mem(m){\n        ll sz=X.size();\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mem);\n        rep(i,0,sz) node[N-1+i]=X[i];\n        per(i,N-2,0){\n            node[i]=Compare(node[i*2+1],node[i*2+2]);\n        }\n    }\n    T Compare(T &A,T &B){\n        return std::max(A,B);\n    }\n    void update(ll X,T val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=Compare(node[X*2+1],node[X*2+2]);\n        }\n    }\n    T Query(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mem;\n        if(a<=l&&r<=b) return node[now];\n        auto vl=Query(a,b,now*2+1,l,(l+r)/2),vr=Query(a,b,now*2+2,(l+r)/2,r);\n        return Compare(vl,vr);\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,int a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nvoid comp(vi &A){\n    std::map<ll,ll> mem;\n    rep(i,0,A.size()) mem[A[i]]=0;\n    ll cnt=0;\n    for(auto &p:mem) p.second=cnt++;\n    rep(i,0,A.size()) A[i]=mem[A[i]];\n}\nll RLCS(string S){\n    string T=S;\n    reverse(ALL(T));\n    ll N=S.size();\n    vii dp(N+1,vi(N+1));\n    REP(i,0,N){\n        REP(j,0,N){\n            if(!i){\n                if(j) dp[i][j]=dp[i][j-1];\n            }\n            else if(!j){\n                dp[i][j]=dp[i-1][j];\n            }\n            else{\n                dp[i][j]=std::max(dp[i][j-1],dp[i-1][j]);\n                if(S[i-1]==T[j-1]) dp[i][j]=std::max(dp[i][j],dp[i-1][j-1]+1);\n            }\n        }\n    }\n    return dp[N][N];\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    string S; cin>>S;\n    ll K,N=S.size(); cin>>K;\n    string T=S; reverse(ALL(T));\n    vector<vii> dp(N/2+1,vii(N/2+1,vi(K+1,INF)));\n    dp[0][0][0]=0;\n    vii mem(26);\n    rep(i,0,N/2) mem[T[i]-'a'].pb(i+1);\n    rep(i,0,N/2){\n        REP(j,0,N/2){\n            REP(k,0,K) dp[i+1][j][k]=dp[i][j][k];\n        }\n        rep(j,0,N/2){\n            REP(k,0,K){\n                if(dp[i][j][k]==INF) continue;\n                ll X=disup(mem[S[i]-'a'],dp[i][j][k]);\n                if(X<mem[S[i]-'a'].size()){\n                    ll Y=mem[S[i]-'a'][X];\n                    dp[i+1][j+1][k]=std::min(dp[i+1][j+1][k],Y);\n                }\n                if(dp[i][j][k]<N/2&&k<K){\n                    dp[i+1][j+1][k+1]=std::min(dp[i+1][j+1][k+1],dp[i][j][k]+1);\n                }\n            }\n        }\n        REP(j,0,N/2){\n            REP(k,1,K) dp[i+1][j][k]=std::min(dp[i+1][j][k],dp[i+1][j][k-1]);\n        }\n    }\n    ll ans=0;\n    per(i,N/2,0){\n        per(j,N/2,0){\n            if(dp[i][j][K]!=INF){\n                ll left=i,right=N-1-dp[i][j][K];\n                if(left<=right){\n                    string P=S.substr(left,right-left+1);\n                    ans=std::max(ans,j*2+RLCS(P));\n                }\n                else{\n                    ans=std::max(ans,j*2);\n                }\n                break;\n            }\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 310;\n\nint n, k;\nint dp[maxn][maxn][maxn];\nstring s;\n\nint main(){\n\tcin >> s;\n\tn = s.length();\n\tcin >> k;\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j <= k; j++){\n\t\t\tdp[i][i+1][j] = 1;\n\t\t}\n\t}\n\n\tfor (int i = 2; i <= n; i++){\n\t\tfor (int j = 0; j <= n-i; j++){\n\t\t\tfor (int z = 0; z <= k; z++){\n\t\t\t\tdp[j][j+i][z] = max(dp[j][j+i-1][z], dp[j+1][j+i][z]);\n\t\t\t\tif (s[j] == s[j+i-1])\n\t\t\t\t\tdp[j][j+i][z] = max(dp[j][j+i][z], dp[j+1][j+i-1][z] + 2);\n\t\t\t\tif (z > 0)\n\t\t\t\t\tdp[j][j+i][z] = max(dp[j][j+i][z], dp[j+1][j+i-1][z-1] + 2);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[0][n][k] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n)  for(int i = (k);i < (n);++i)\n#define REP(i,n)    FOR(i,0,n)\n#define ALL(x)      begin(x),end(x)\n\nusing namespace std;\nusing vecint = vector<int>;\nusing ll = int64_t;\n\nint main()\n{\n  string s;\n  cin>>s;\n  string r = s;\n  reverse(ALL(r));\n  int n = s.size();\n  int K;\n  cin>>K;\n  vector<vector<vecint>> dp(n+1, vector<vecint>(n+1, vecint(K+1, 0)));\n  REP(i,n)REP(j,n)REP(k,K+1) {\n    //cerr << i << ' ' << j << ' ' << k << ' ' << dp[i][j][k] << endl;\n    if (s[i] == r[j]) {\n      dp[i+1][j+1][k] = max(dp[i+1][j+1][k], 1 + dp[i][j][k]);\n    }\n    if (k<K) {\n      dp[i+1][j+1][k+1] = max(dp[i+1][j+1][k+1], 1 + dp[i][j][k]);\n    }\n    dp[i+1][j][k] = max(dp[i+1][j][k], dp[i][j][k]);\n    dp[i][j+1][k] = max(dp[i][j+1][k], dp[i][j][k]);\n    dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k]);\n  }\n  int mx = 0;\n  REP(i,n)REP(j,n) {\n    if (i+j >= n) break;\n    mx = max(mx, dp[i][j][K]*2+(n-(i+j))%2);\n  }\n  cout << mx << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<math.h>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<cstring>\n#include<cstdio>\n#include<functional>\n#include<bitset>\n#include<limits.h>\n#include<cassert>\n#include<iterator>\n#include<complex>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<time.h>\n#include<random>\n#include<array>\nusing namespace std;\nusing ll = long long;\n#define rep(i, a, b) for(int i = a; i < b; i++)\n#define rrep(i, a, b) for(int i = b - 1; i >= a; i--)\n#define ALL(a) a.begin(), a.end()\nusing pii = pair<int,int>;\nusing piii = pair<pii,int>;\nusing pll = pair<long long, long long>;\nusing plll = pair<pll, long long>;\n// #pragma GCC optimize(\"Ofast\")\n#define pcnt __builtin_popcount\n#define buli(x) __builtin_popcountll(x)\n#define pb push_back\n#define mp make_pair\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define isSquare(x) (sqrt(x)*sqrt(x) == x)\ntemplate<class T>inline bool chmax(T &a, const T &b) {if(a<b){a = b; return 1;} return 0; };\ntemplate<class T>inline bool chmin(T &a, const T &b) {if(a>b){a = b; return 1;} return 0; };\ninline void in(void){return;}\ntemplate <typename First, typename... Rest> void in(First& first, Rest&... rest){cin >> first;in(rest...);return;}\ninline void out(void){cout << \"\\n\";return;}\ntemplate <typename First, typename... Rest> void out(First first, Rest... rest){cout << first << \" \";out(rest...);return;}\nconst double EPS = 1e-9;\nconst int mod = 1e9 + 7;\nconst int INF = 1e9;\nconst long long INFLL = 1e18;\nvoid iosetup() {\n    cin.tie(nullptr);ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n}\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 >& p) {\n    os << p.first << \" \" << p.second;\n    return os;\n}\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n    is >> p.first >> p.second;\n    return is;\n}\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n    for(int i = 0; i < (int) v.size(); i++) {\n        os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n    }\n    return os;\n}\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n    for(T &in : v) is >> in;\n    return is;\n}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S, T>& t){return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S, T>& t){return pair<S,T>(s.first-t.first, s.second-t.second);}\ntemplate<class S, class T> pair<S,T> operator*(const pair<S,T> &s, const S& t){return pair<S,T>(s.first*t, s.second*t);}\ntemplate <typename T> void Exit(T first){cout << first << endl;exit(0); };\ntemplate< int mod > struct ModInt {\n    unsigned x; ModInt() : x(0) {}\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n    ModInt &operator+=(const ModInt &p) {if((x += p.x) >= mod) x -= mod;return *this;}\n    ModInt &operator-=(const ModInt &p) {if((x += mod - p.x) >= mod) x -= mod;return *this;}\n    ModInt &operator*=(const ModInt &p) {x = (int) (1LL * x * p.x % mod);return *this;}\n    ModInt &operator/=(const ModInt &p) {*this *= p.inverse();return *this;}\n    ModInt operator-() const { return ModInt(-x); }\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n    bool operator==(const ModInt &p) const { return x == p.x; }\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n    ModInt inverse() const {int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) { t = a / b; swap(a -= t * b, b); swap(u -= t * v, v); }return ModInt(u);}\n    ModInt pow(int64_t n) const {ModInt ret(1), mul(x); while(n > 0) {if(n & 1) ret *= mul;mul *= mul;n >>= 1;}return ret;}\n    friend ostream &operator<<(ostream &os, const ModInt &p) { return os << p.x;}\n    friend istream &operator>>(istream &is, ModInt &a) { int64_t t; is >> t; a = ModInt< mod >(t); return (is); }\n    static int get_mod() { return mod; }\n}; using modint = ModInt< mod >;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst pii dxy[4] = {pii(1,0), pii(0, 1), pii(-1, 0), pii(0, -1)};\nconst int calender[13] = {0, 31,28,31,30,31,30,31,31,30,31,30,31};\nconst int ucalender[13] = {0, 31,29,31,30,31,30,31,31,30,31,30,31};\nbool range(int a, int b, int x){if(a <= x and x < b)return true;else return false;}\nbool range(int a, int b, int c, int d, pii p){if(a <= p.first and p.first < b and c <= p.second and p.second < d) return true;else return false;}\n\nint dp[310][310][310];\nint main(){\n    iosetup();\n    string S; cin >> S;\n    int n = S.size();\n    int K; cin >> K;\n    memset(dp, 0, sizeof dp);\n    rep(i, 0, n) dp[i][i][0] = 1;\n    rep(i, 1, n){\n        rep(j, 0, n){\n            if(j + i >= n) break;\n            rrep(k, 0, K + 1){\n                chmax(dp[j][j+i][k],dp[j][j+i-1][k]); \n                chmax(dp[j][j+i][k],dp[j+1][j+i][k]); \n                if(S[j] == S[j+i]) chmax(dp[j][j+i][k], dp[j+1][j+i-1][k] + 2);\n                else{\n                    if(k >= 1)chmax(dp[j][j+i][k], dp[j+1][j+i][k-1] + 2);\n                    if(k >= 1)chmax(dp[j][j+i][k], dp[j][j+i-1][k-1] + 2);\n                }\n            }\n        }\n    }\n    // rep(l, 0, n) rep(r, l + 1, n){\n    //     cerr << l << \",\" << r << endl;\n    //     rep(k, 0, K + 1){\n    //     cerr << dp[l][r][k] << \" \";\n    //     }\n    //     cerr << endl;\n    // }\n    cout << dp[0][n-1][K] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 262144\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nlong long dp[400][400][400];\nint visited[400][400];\nint k = 0;\nstring s;\nvoid solve(int left, int right) {\n\tif (left > right) return;\n\tif (visited[left][right] == 1) return;\n\tvisited[left][right] = 1;\n\tsolve(left + 1, right);\n\tfor (int q = 0; q <= k; ++q) {\n\t\tdp[left][right][q] = max(dp[left][right][q], dp[left + 1][right][q]);\n\t\tdp[left][right][q + 1] = max(dp[left][right][q], dp[left][right][q + 1]);\n\t}\n\tsolve(left, right - 1);\n\tfor (int q = 0; q <= k; ++q) {\n\t\tdp[left][right][q] = max(dp[left][right][q], dp[left][right - 1][q]);\n\t\tdp[left][right][q + 1] = max(dp[left][right][q], dp[left][right][q + 1]);\n\t}\n\tsolve(left + 1, right - 1);\n\tfor (int q = 0; q <= k; ++q) {\n\t\tif (s[left] == s[right]) {\n\t\t\tdp[left][right][q] = max(dp[left][right][q], dp[left + 1][right - 1][q]+2);\n\t\t}\n\t\telse {\n\t\t\tdp[left][right][q + 1] = max(dp[left][right][q + 1], dp[left + 1][right - 1][q] + 2);\n\t\t}\n\t\tdp[left][right][q + 1] = max(dp[left][right][q], dp[left][right][q+1]);\n\t}\n}\nint main() {\n\tcin >> s;\n\tcin >> k;\n\tfor (int i = 0; i < s.length(); ++i) {\n\t\tREP(j, k + 1) {\n\t\t\tdp[i][i][j] = 1;\n\t\t}\n\t\tvisited[i][i] = 1;\n\t}\n\tfor (int i = 0; i < s.length() - 1; ++i) {\n\t\tREP(j, k + 1) {\n\t\t\tif (s[i] == s[i + 1]) {\n\t\t\t\tdp[i][i + 1][j] = 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][i + 1][j + 1] = 2;\n\t\t\t}\n\t\t}\n\t}\n\tsolve(0, s.length() - 1);\n\tlong long ans = 0;\n\tREP(j, k + 1) {\n\t\tans = max(ans, dp[0][s.length() - 1][j]);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<bitset>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int N=100000+100;\nconst db pi=acos(-1.0);\n#define lowbit(x) ((x)&(-x))\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u],v=sq[i].to;i;i=sq[i].nxt,v=sq[i].to)\n#define fir first\n#define sec second\n#define mkp make_pair\n#define pb push_back\n#define maxd 998244353\n#define eps 1e-8\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\ninline ll readll()\n{\n    ll x=0;int f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nint n,m,f[310][310][310];\nchar s[310];\n\nint dfs(int l,int r,int k)\n{\n    if (l==r) return 1;\n    if (l>r) return 0;\n    if (f[l][r][k]!=-1) return f[l][r][k];\n    f[l][r][k]=max(dfs(l,r-1,k),dfs(l+1,r,k));\n    if (s[l]==s[r]) f[l][r][k]=max(f[l][r][k],dfs(l+1,r-1,k)+2);\n    else if (k) f[l][r][k]=max(f[l][r][k],dfs(l+1,r-1,k-1)+2);\n    return f[l][r][k];\n}\n\nint main()\n{\n    memset(f,-1,sizeof(f));\n    scanf(\"%s\",s+1);m=read();\n    n=strlen(s+1);\n    printf(\"%d\",dfs(1,n,m));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#if defined(__GNUC__)\n#pragma GCC optimize (\"Ofast\")\n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst ld eps=1e-7;\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod = 1000000007;\nconst int MAXN = 310, LOG=20;\n\nint n, m, k, u, v, x, y, t, a, b, ans;\nint dp[MAXN][MAXN][MAXN];\nstring S;\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin>>S>>k;\n\tn=S.size();\n\tS=\".\"+S;\n\tfor (int i=n; i; i--){\n\t\tfor (int x=0; x<=k; x++) dp[i][i][x]=1;\n\t\tfor (int j=i+1; j<=n; j++){\n\t\t\tdp[i][j][0]=max(dp[i+1][j][0], dp[i][j-1][0]);\n\t\t\tif (S[i]==S[j]) dp[i][j][0]=max(dp[i][j][0], dp[i+1][j-1][0]+2);\n\t\t\tfor (int x=1; x<=k; x++){\n\t\t\t\tdp[i][j][x]=max(dp[i+1][j][x], dp[i][j-1][x]);\n\t\t\t\tdp[i][j][x]=max(dp[i][j][x], 2+dp[i+1][j-1][x-(S[i]!=S[j])]);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[1][n][k]<<'\\n';\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <array>\nusing namespace std;\nusing ULL = unsigned long long;\nusing UL = unsigned;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nstruct Problem {\n\n\tUL dp[301][301][301] = {};\n\n\tvoid Solve() {\n\t\tstring S; cin >> S;\n\t\tstring rS = S; reverse(rS.begin(), rS.end());\n\t\tUL K; cin >> K;\n\t\tUL ans = 1;\n\t\tfor (UL i = 0; i < S.size(); i++) {\n\t\t\tfor (UL j = 0; j < rS.size(); j++) {\n\t\t\t\tif ((i + 1) + (j + 1) > S.size()) continue;\n\t\t\t\tfor (UL k = 0; k <= K; k++) {\n\t\t\t\t\tauto &p = dp[i + 1][j + 1][k];\n\t\t\t\t\tp = max(p, dp[i][j + 1][k]);\n\t\t\t\t\tp = max(p, dp[i + 1][j][k]);\n\t\t\t\t\tif (S[i] == rS[j]) p = max(p, dp[i][j][k] + 1);\n\t\t\t\t\tif (k != 0) p = max(p, dp[i][j][k - 1] + 1);\n\t\t\t\t\tif ((i + 1) + (j + 1) == S.size()) ans = max(ans, p * 2);\n\t\t\t\t\tif ((i + 1) + (j + 1) == S.size() - 1) ans = max(ans, p * 2 + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor (UL k = 0; k <= K; k++) {\n\t\t\tfor (UL i = 0; i <= S.size(); i++) {\n\t\t\t\tfor (UL j = 0; j <= rS.size(); j++) {\n\t\t\t\t\tcout << dp[i][j][k] << \" \";\n\t\t\t\t} cout << endl;\n\t\t\t} cout << endl;\n\t\t}*/\n\t\tcout << ans << endl;\n\t}\n\n\n\tProblem();\n};\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\nProblem::Problem() {\n\tcout << fixed << setprecision(10);\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL111\n\t#define _GLIBCXX_DEBUG\n#else\n\t#define NDEBUG\n#endif\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nconst int INF = 1e9;\nusing namespace std;\ntemplate<typename T, typename U> ostream& operator<< (ostream& os, const pair<T,U>& p) { os << '(' << p.first << ' ' << p.second << ')'; return os; }\n\n#define endl '\\n'\n#define ALL(a)  (a).begin(),(a).end()\n#define SZ(a) int((a).size())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#ifdef LOCAL111\n\t#define DEBUG(x) cout<<#x<<\": \"<<(x)<<endl\n\ttemplate<typename T> void dpite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\n#else\n\t#define DEBUG(x) true\n\ttemplate<typename T> void dpite(T a, T b){ return; }\n#endif\n#define F first\n#define S second\n#define SNP string::npos\n#define WRC(hoge) cout << \"Case #\" << (hoge)+1 << \": \"\ntemplate<typename T> void pite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\ntemplate<typename T> bool chmax(T& a, T b){if(a < b){a = b; return true;} return false;}\ntemplate<typename T> bool chmin(T& a, T b){if(a > b){a = b; return true;} return false;}\n\ntypedef long long int LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> P;\n\nvoid ios_init(){\n\t//cout.setf(ios::fixed);\n\t//cout.precision(12);\n#ifdef LOCAL111\n\treturn;\n#endif\n\tios::sync_with_stdio(false); cin.tie(0);\n}\n\n//;ibrary\nstring lcs(string s, string t){\n\tint n = s.size();\n\tint m = t.size();\n\tarray<int,3> dx({-1,0,-1});\n\tarray<int,3> dy({-1,-1,0});\n\tvector<vector<int>> dp(n+1,vector<int>(m+1));\n\tvector<vector<int>> pre(n+1,vector<int>(m+1,-1));\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < m; ++j) {\n\t\t\tint val = 0;\n\t\t\tif(s[i] == t[j] and val <= dp[i][j]+1){\n\t\t\t\tval = dp[i][j]+1;\n\t\t\t\tpre[i+1][j+1] = 0;\n\t\t\t}\n\t\t\tif(val <= dp[i+1][j]){\n\t\t\t\tval = dp[i+1][j];\n\t\t\t\tpre[i+1][j+1] = 1;\n\t\t\t}\n\t\t\tif(val <= dp[i][j+1]){\n\t\t\t\tval = dp[i][j+1];\n\t\t\t\tpre[i+1][j+1] = 2;\n\t\t\t}\n\t\t\tdp[i+1][j+1] = val;\n\t\t}\n\t}\n\tstring res;\n\tint x = n, y = m;\n\twhile(x != 0 and y != 0){\n\t\tint tmp = pre[x][y];\n\t\tif(tmp == 0){\n\t\t\tassert(s[x-1] == t[y-1]);\n\t\t\tres += s[x-1];\n\t\t}\n\t\tx += dx[tmp];\n\t\ty += dy[tmp];\n\t}\n\tassert((int)res.size() == dp[n][m]);\n\treverse(res.begin(), res.end());\n\treturn res;\n}\n//liblary\n\nint main()\n{\n\tios_init();\n\tstring s;\n\twhile(cin >> s) {\n\n\t\tint k;\n\t\tcin >> k;\n\t\tstring t = s;\n\t\treverse(ALL(t));\n\t\tDEBUG(lcs(s, t));\n\t\tint n = s.size();\n\t\tint m = t.size();\n\t\tarray<int,3> dx({-1,0,-1});\n\t\tarray<int,3> dy({-1,-1,0});\n\t\tvector<vector<int>> dp(n+1,vector<int>(m+1));\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = 0; j < m; ++j) {\n\t\t\t\tint val = 0;\n\t\t\t\tif(s[i] == t[j] and val <= dp[i][j]+1){\n\t\t\t\t\tval = dp[i][j]+1;\n\t\t\t\t}\n\t\t\t\tif(val <= dp[i+1][j]){\n\t\t\t\t\tval = dp[i+1][j];\n\t\t\t\t}\n\t\t\t\tif(val <= dp[i][j+1]){\n\t\t\t\t\tval = dp[i][j+1];\n\t\t\t\t}\n\t\t\t\tdp[i+1][j+1] = val;\n\t\t\t}\n\t\t}\n\t\tif(k == 0) {\n\t\t\tcout << dp[n][m] << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint ans = 1;\n\t\tREP(i, SZ(s)) {\n\t\t\tint tmp = dp[i+1][n-i];\n\t\t\tDEBUG(i+1); DEBUG(n-i);\n\t\t\tint rem = min(i+1, n-i)-tmp;\n\t\t\tint val = tmp + min(rem, k);\n\t\t\tchmax(ans, val*2-1);\n\t\t}\n\t\tREP(i, SZ(s)+1) {\n\t\t\tint tmp = dp[i][n-i];\n\t\t\tint rem = min(i, n-i)-tmp;\n\t\t\tint val = tmp + min(rem, k);\n\t\t\tchmax(ans, val*2);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring S;\nint K, dp[300][300][300];\nint dfs(int l,int r,int k){\n  if(dp[l][r][k]!=-1)return dp[l][r][k];\n  if(l>r)return dp[l][r][k]=0;\n  if(l==r)return dp[l][r][k]=1;\n  dp[l][r][k]=0;\n  if(S[l]==S[r])dp[l][r][k]=dfs(l+1,r-1,k)+2;\n  dp[l][r][k]=max(dp[l][r][k],dfs(l+1,r,k));\n  dp[l][r][k]=max(dp[l][r][k],dfs(l,r-1,k));\n  if(k>0)dp[l][r][k]=max(dp[l][r][k],dfs(l+1,r-1,k-1)+2);\n  return dp[l][r][k];\n}\nint main(){\n  for(int i=0;i<300;i++)for(int j=0;j<300;j++)for(int k=0;k<300;k++)dp[i][j][k]=-1;\n  cin>>S>>K;\n  cout<<dfs(0,S.length()-1,K)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nchar s[310];\nint n,k,F[310][310][310];\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tk=read();\n\tfor(int i=1;i<=n;i++) F[i][i][0]=1;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tF[i][i+1][0]=(s[i]==s[i+1])*2;\n\t\tF[i][i+1][1]=2;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int l=1;l+i-1<=n;l++)\n\t\t{\n\t\t\tint r=l+i-1;\n\t\t\tfor(int ks=0;ks<=k;ks++)\n\t\t\t{\n\t\t\t\tif(l>1) F[l-1][r][ks]=max(F[l-1][r][ks],F[l][r][ks]);\n\t\t\t\tif(l>1&&r<n) F[l-1][r+1][ks]=max(F[l-1][r+1][ks],F[l][r][ks]+(s[l-1]==s[r+1])*2);\n\t\t\t\tif(r<n) F[l][r+1][ks]=max(F[l][r+1][ks],F[l][r][ks]);\n\t\t\t\tif(l>1&&r<n) F[l-1][r+1][ks+1]=max(F[l-1][r+1][ks+1],F[l][r][ks]+2);\n\t\t\t}\n\t\t}\n\t}\n\tint Ans=0; for(int i=0;i<=k;i++) Ans=max(Ans,F[1][n][i]);\n\tcout << Ans << endl; return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\nstring S; int K;\n//---------------------------------------------------------------------------------------------------\nint memo[303][303][303];\nint f(int l, int r, int k) {\n    if (memo[l][r][k]) return memo[l][r][k];\n\n    int res = 0;\n    if (l == r) res = 1;\n    else if (l + 1 == r) {\n        if (S[l] == S[r] or 0 < k) res = 2;\n        else res = 1;\n    } else {\n        chmax(res, f(l + 1, r, k));\n        chmax(res, f(l, r - 1, k));\n        \n        if (S[l] == S[r]) chmax(res, f(l + 1, r - 1, k) + 2);\n        else if (0 < k) chmax(res, f(l + 1, r - 1, k - 1) + 2);\n    }\n\n    return memo[l][r][k] = res;\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> S >> K;\n    int N = S.length();\n\n    cout << f(0, N - 1, K) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\ndp[i][j][k] 第i个字符到第j个字符最多修改k个字符的最大长度\n\ndp[i][j][k] = max(\n                  dp[i+1][j][k],dp[i][j-1][k],\n                  if s[i]==s[j] : dp[i+1][j-1][k]+2\n                else :\n\nabcabcabc\ncbacbacba\n\n\n*/\n\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\nint n,m;\nchar s[305];\nint dp[305][305][305];\n\nint main(){\n    int i,j,k;\n    while(~scanf(\"%s%d\",s,&m)){\n        n = strlen(s);\n        for(i = 0;i < n;i++){\n            for(j = 0;j <= m;j++)\n                dp[i][i][j] = 1;\n        }\n        for(i = n-1;i >= 0;i--){\n            for(j = i+1;j < n;j++){\n                for(k = 0;k <= m;k++){\n                    dp[i][j][k] = max(dp[i+1][j][k],dp[i][j-1][k]);\n                    if(i+1 <= j-1){\n                        if(s[i] == s[j]){\n                            dp[i][j][k] = max(dp[i][j][k],dp[i+1][j-1][k]+2);\n                        }else if(k > 0){\n                            dp[i][j][k] = max(dp[i][j][k],dp[i+1][j-1][k-1]+2);\n                        }\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\",dp[0][n-1][m]);\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAXSIZE=10000020;\nint bufpos;\nchar buf[MAXSIZE];\n#define NEG 0\nvoid init(){\n    #ifdef LOCAL\n        freopen(\"D.txt\",\"r\",stdin);\n    #endif\n    buf[fread(buf,1,MAXSIZE,stdin)]='\\0';\n    bufpos=0;\n}\n#if NEG\nint readint(){\n    bool isneg;\n    int val=0;\n    for(;!isdigit(buf[bufpos]) && buf[bufpos]!='-';bufpos++);\n    bufpos+=(isneg=buf[bufpos]=='-');\n    for(;isdigit(buf[bufpos]);bufpos++)\n        val=val*10+buf[bufpos]-'0';\n    return isneg?-val:val;\n}\n#else\nint readint(){\n    int val=0;\n    for(;!isdigit(buf[bufpos]);bufpos++);\n    for(;isdigit(buf[bufpos]);bufpos++)\n        val=val*10+buf[bufpos]-'0';\n    return val;\n}\n#endif\nchar readchar(){\n    for(;isspace(buf[bufpos]);bufpos++);\n    return buf[bufpos++];\n}\nint readstr(char* s){\n    int cur=0;\n    for(;isspace(buf[bufpos]);bufpos++);\n    for(;!isspace(buf[bufpos]);bufpos++)\n        s[cur++]=buf[bufpos];\n    s[cur]='\\0';\n    return cur;\n}\nint dp[302][302][302];\nchar s[302];\ninline void relax(int &x,int y){\n    if (x>y)\n        x=y;\n}\nint main(){\n    init();\n    int n=readstr(s+1),m=readint();\n    memset(dp,0x3f,sizeof(dp));\n    for(int i=1;i<=n;i++)\n        memset(dp[i][i],0,sizeof(dp[i][i]));\n    for(int len=2;len<=n;len++)\n        for(int i=1;i<=n;i++){\n            int j=i+len-1;\n            if (j>n)\n                break;\n            for(int k=0;k<=m;k++){\n                if (k)\n                    dp[i][j][k]=dp[i+1][j-1][k-1];\n                if (s[i]==s[j])\n                    relax(dp[i][j][k],dp[i+1][j-1][k]);\n                relax(dp[i][j][k],dp[i+1][j][k]+1);\n                relax(dp[i][j][k],dp[i][j-1][k]+1);\n            }\n        }\n    printf(\"%d\",n-dp[1][n][m]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,K;\nchar S[310],T[310];\nint dp[310][310][310] = {0};\nint ans = 0;\n\nint main()\n{\n    scanf(\"%s %d\",S + 1,&K);\n\n    N = strlen(S + 1);\n    if(N == 1)\n    {\n        printf(\"1\\n\");\n        return 0;\n    }\n    for(int i = 1; i <= N; i++)T[i] = S[i];\n    reverse(T + 1,T + 1 + N);\n\n    for(int i = 0; i <= K; i++)\n    {\n        for(int j = 1; j <= N; j++)\n        {\n            for(int k = 1; k <= N; k++)\n            {\n                dp[j][k][i] = max(dp[j - 1][k][i],dp[j][k - 1][i]);\n                if(S[j] == T[k])dp[j][k][i] = max(dp[j][k][i],dp[j - 1][k - 1][i] + 1);\n                if(i != 0)dp[j][k][i] = max(dp[j][k][i],dp[j - 1][k - 1][i - 1] + 1);\n                if(j + k == N)ans = max(ans,dp[j][k][i] * 2);\n                if(j + k == N - 1)ans = max(ans,dp[j][k][i] * 2 + 1);\n            }\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(int x) { return 8*sizeof(int)-__builtin_clz(x); }\n\nnamespace std {\n    template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};\n}\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\ntemplate <typename T> struct bounded_priority_queue {\n\tinline bounded_priority_queue(ui X) : A(X), B(0), s(0) {}\n\tinline void push(ui L, T V) { B = max(B, L); A[L].push(V); ++s; }\n\tinline const T &top() const { return A[B].front(); }\n\tinline void pop() { --s; A[B].pop(); while (B > 0 && A[B].empty()) --B; }\n\tinline bool empty() const { return A[B].empty(); }\n\tinline void clear() { s = B = 0; for (auto &a: A) a = queue<T>(); }\n\tinline ui size() const { return s; }\nprivate:\n\tvector<queue<T>> A; ui B; int s;\n};\n\n\n#endif\n// #include \"../l/mod.h\"\n\nclass D {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        string S; cin >> S;\n        int K; cin >> K;\n        string T = S;\n        reverse(T.begin(),T.end());\n        int N = S.size();\n        vector3<int> L(N+1,N+1,N+2,-1);\n        for (int i = 1; i <= N; ++i) {\n            L[0][i][0] = L[i][0][0] = 0;\n        }\n        L[0][0][0] = 0;\n\n        for (int i = 1; i <= N; ++i) {\n            for (int j = 1; j <= N; ++j) {\n                for (int k = 0; k <= N; ++k) {\n                    L[i][j][k] = max(L[i][j][k], L[i-1][j][k]);\n                    L[i][j][k] = max(L[i][j][k], L[i][j-1][k]);\n                    if (S[i-1] == T[j-1]) {\n                        L[i][j][k] = max(L[i][j][k], 1 + L[i-1][j-1][k]);\n                    } else if (L[i-1][j-1][k] >= 0 && (i+j < N)) {\n                        L[i][j][k+1] = max(L[i][j][k+1], L[i-1][j-1][k]);\n                    }\n                }\n            }\n        }\n//        cerr << L;\n        int ans = 0;\n        for (int i = 0; i <= N-N%2; ++i) {\n            int j = N-i-N%2;\n            for (int k = 0; k <= N; ++k) {\n                int pairs = min(k,K);\n//                cerr << i << ' ' << j << ' ' << k << ' ' << L[i][j][k] << ' ' << pairs << endl;\n                ans = max(ans, 2*L[i][j][k] + pairs + K + N%2);\n            }\n        }\n        cout << min(N, ans) << endl;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tD solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int N=305;\nchar s[N];int f[N][N][N],n,k;\ninline int max(R int x,R int y){return x>y?x:y;}\nint dfs(int l,int r,int k){\n\tif(r<=l)return r-l+1;\n\tif(~f[l][r][k])return f[l][r][k];\n\tR int res=max(dfs(l+1,r,k),dfs(l,r-1,k));\n\tif(s[l]==s[r])cmax(res,dfs(l+1,r-1,k)+2);\n\tif(s[l]!=s[r]&&k)cmax(res,dfs(l+1,r-1,k-1)+2);\n\treturn f[l][r][k]=res;\n}\nint main(){\n\tscanf(\"%s%d\",s+1,&k),n=strlen(s+1);\n\tmemset(f,-1,sizeof(f));\n\tprintf(\"%d\\n\",dfs(1,n,k));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long I64;\n\nconst double EPS = 1e-6;\nconst double PI  = acos(-1);\nconst int NMAX = 303;\n\nint d[NMAX+2][NMAX+2][NMAX+2];\n\nint max(int a, int b, int c)\n{\n    return max(max(a,b), c);\n}\n\nint max2(int a, int b, int c)\n{\n    return max(max(a,b), c);\n}\n\nint main()\n{\n    int N, K;\n    string str;\n    cin >> str;\n    N = str.size();\n    if( N == 1 ) {\n        cout << \"1\\n\";\n        return 0;\n    }\n    str = \"#\" + str + \"$\";\n    cin >> K;\n    int Ans=  0;\n    for( int i = 1;  i <= N;  ++i ) {\n        for( int j = N;  i < j;  --j ) {\n            d[i][j][0] = max2( d[i - 1][j][0], d[i][j + 1][0], d[i - 1][j + 1][0] + (str[i] == str[j]) );\n            Ans = max( Ans, d[i][j][0] * 2 + (i + 2 == j) );\n            Ans = max( Ans, d[i][i + 1][0] * 2 );\n            for( int k = 1;  k <= K;  ++k ) {\n                if( str[i] == str[j] )\n                    d[i][j][k] = max2( d[i - 1][j][k], d[i][j + 1][k], d[i - 1][j + 1][k]+1 );\n                else\n                    d[i][j][k] = max2( d[i - 1][j][k],\n                                      d[i][j + 1][k],\n                                      d[i - 1][j + 1][k - 1] + 1 );\n                Ans = max(Ans, d[i][j][k] * 2 + (i + 2 == j));\n            }\n        }\n    }\n    cout << Ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <iomanip>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n#define rep(i, n) for(ll i = 0; i < (n); i++)\n#define revrep(i, n) for(ll i = (n)-1; i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\nll max(ll a, ll b){return (a > b) ? a : b;}\nll min(ll a, ll b){return (a < b) ? a : b;}\nll max3(ll a, ll b, ll c){return max(a, max(b, c));};\nll min3(ll a, ll b, ll c){return min(a, min(b, c));};\nll max4(ll a, ll b, ll c, ll d){return max(max(a, b), min(c, d));};\nll min4(ll a, ll b, ll c, ll d){return min(min(a, b), min(c, d));};\nll max5(ll a, ll b, ll c, ll d, ll e){return max(max(a, b), max3(c, d, e));};\nll min5(ll a, ll b, ll c, ll d, ll e){return min(min(a, b), min3(c, d, e));};\n\nconst ll INFL = 1LL << 60;//10^18 = 2^60\nconst int INF = 1 << 30;//10^9\nll MOD = 1000000007;\n//ll MOD = 998244353;\n\nvector<ll> dy = {0, 0, 1, -1, 1, 1, -1, -1, 0};\nvector<ll> dx = {1, -1, 0, 0, 1, -1, 1, -1, 0};\n\n\nll pow_long(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2) res *= x;\n    x *= x;\n    k /= 2;\n  }\n  return res;\n}\nll pow_mod(ll x, ll k){\n  x %= MOD; x += MOD; x %= MOD;\n  ll res = 1;\n  while(k > 0){\n    if(k % 2){\n      res *= x; res %= MOD;\n    }\n    x *= x; x %= MOD;\n    k /= 2;\n  }\n  return res;\n}\n\nll inverse(ll x){return pow_mod(x, MOD - 2);};\n\nll gcd(ll a, ll b){\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\nll lcm(ll x, ll y){return x / gcd(x, y) * y;};\n\nll kai_mod(ll x){\n  if(x == 0) return 1;\n  return x * kai_mod(x-1) % MOD;\n}\n\n/*\n//コンビネーション\nconst int MAXcomb = 200010;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\n//facはn!,finvは1/n!\n//invは逆元\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAXcomb; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nll comb(int n, int k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    return fac[n] * finv[k] % MOD * finv[n-k] % MOD;\n}\n*/\n\nstring S;\nll K;\nll memo[310][310][310];//[)\nll solve(ll l, ll r, ll rest){\n  if(l >= r) return 0;\n  if(memo[l][r][rest] != -1) return memo[l][r][rest];\n  ll res = max(solve(l, r-1, rest), solve(l+1, r, rest));\n  if(S[l] == S[r-1]){\n    res = max(res, solve(l+1, r-1, rest) + 2);\n  }else{\n    if(rest >= 1) res = max(res, solve(l+1, r-1, rest - 1) + 2);\n  }\n  return memo[l][r][rest] = res;\n}\n\nint main(){\n  cin >> S >> K;\n  rep(i, 310)rep(j, 310)rep(k, 310) memo[i][j][k] = -1;\n  rep(i, S.size()){\n    memo[i][i][0] = 0;\n    memo[i][i+1][0] = 1;\n  }\n  cout << solve(0, S.size(), K) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n#define INF 1000000000\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint dp[303][303][303];\nstring s;\nint k;\n\nint dfs(int K,int L,int R)\n{\n//\tcout << K << ' ' << L << ' ' << R << endl;\n\tif(K < 0)return -100000000;\n\tif(L > R)return 0;\n\tif(dp[K][L][R] != 0)return dp[K][L][R];\n\tint ret = 0;\n\tif(s[L] == s[R])ret = max(ret,dfs(K,L+1,R-1)+2);\n\telse ret = max(ret,dfs(K-1,L+1,R-1)+2);\n\tret = max(ret,dfs(K,L+1,R));\n\tret = max(ret,dfs(K,L,R-1));\n\t\n\treturn dp[K][L][R] = ret;\n}\n\n\nint main()\n{\n\tcin >> s >> k;\n\t\n\tREP(K,303)REP(i,303)dp[K][i][i] = 1;\n\tcout << dfs(k,0,s.size()-1) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << (x) << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int N = 307, inf = 1e9;\nint n, k, f[N][N][N];\nchar s[N];\nbool v[N][N][N];\n\nint F(int l, int r, int k) {\n\tif (k < 0) return -inf;\n\tif (r - l < 1) return r - l + 1;\n\tif (v[l][r][k]) return f[l][r][k];\n\tv[l][r][k] = 1;\n\treturn f[l][r][k] = max(max(F(l + 1, r, k), F(l, r - 1, k)), F(l + 1, r - 1, k - (s[l] != s[r])) + 2);\n}\n\nint main() {\n\trds(s, n), rd(k), print(F(1, n, k));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstring s;\nint K;\nint dp[301][301][301];\nmain()\n{\n\tcin>>s>>K;\n\tint N=s.size();\n\tfor(int i=0;i<=N;i++)for(int k=0;k<=N;k++)for(int j=0;j<=K;j++)dp[i][k][j]=-1e9;\n\tdp[0][N-1][K]=0;\n\tint ans=0;\n\tfor(int i=0;i<N;i++)for(int j=N-1;j>=i;j--)for(int k=0;k<=K;k++)\n\t{\n\t\tif(dp[i][j][k]<0)continue;\n\t\tans=max(ans,dp[i][j][k]+1);\n\t\tdp[i+1][j][k]=max(dp[i+1][j][k],dp[i][j][k]);\n\t\tif(j>0)dp[i][j-1][k]=max(dp[i][j-1][k],dp[i][j][k]);\n\t\tif(i<j)dp[i+1][j-1][k-(s[i]!=s[j])]=max(dp[i+1][j-1][k-(s[i]!=s[j])],dp[i][j][k]+2);\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define cal(x,y) (x=x>y?x:y)\nusing namespace std;\nconst int N=350;\nint gi(){\n    char ch=getchar(); int x=0,q=0;\n    while(ch<'0'||ch>'9') q=ch=='-'?1:q,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return q?-x:x;\n}\nint f[N][N][N],n,k;\nchar s[N];\nint main(){\n    scanf(\"%s%d\",s+1,&k);\n    n=strlen(s+1);\n    int ans=0;\n    for (int i=1; i<=n; ++i)\n\tfor (int j=n; j>=i; --j)\n\t    for (int l=k; ~l; --l){\n\t\tcal(f[i+1][j][l],f[i][j][l]);\n\t\tcal(f[i][j-1][l],f[i][j][l]);\n\t\tcal(f[i+1][j-1][l],f[i][j][l]+(s[i]==s[j]));\n\t\tif (l) cal(f[i+1][j-1][l-1],f[i][j][l]+1);\n\t\tif (i==j) ans=max(ans,2*f[i][j][l]+1);\n\t\telse ans=max(ans,2*f[i][j][l]);\n\t    }\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <memory>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#define rep(i, n) for(int i=0;i<(int)(n);i++)\n#define REP(i, n) for(int i=1;i<=(int)(n);i++)\n#define all(V) V.begin(),V.end()\ntypedef long long lint;\ntypedef std::pair<lint, lint> P;\nconstexpr int INF = INT_MAX / 10;\nconstexpr lint LINF = LLONG_MAX / 2;\nconstexpr double eps = 1e-9;\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\n\ntemplate<class T, class Alloc = std::allocator<T>>\nclass Vector {\n\n\tusing traits = std::allocator_traits<Alloc>;\n\npublic:\n\n\tusing value_type = T;\n\tusing allocator_type = Alloc;\n\tusing size_type = unsigned int;\n\tusing difference_type = int;\n\tusing reference = T&;\n\tusing const_reference = const T&;\n\tusing pointer = typename traits::pointer;\n\tusing const_pointer = typename traits::const_pointer;\n\n\tclass iterator {\n\n\tpublic:\n\n\t\tusing difference_type = int;\n\t\tusing value_type = Vector::value_type;\n\t\tusing pointer = Vector::pointer;\n\t\tusing reference = Vector::reference;\n\t\tusing iterator_category = std::random_access_iterator_tag;\n\n\tprivate:\n\n\t\tpointer p;\n\n\tpublic:\n\n\t\titerator()noexcept :p() {}\n\t\titerator(const Vector& base, difference_type index) noexcept :p(base.e + index) {}\n\t\titerator(const iterator& i) :p(i.p) {}\n\n\t\titerator& operator=(const iterator& i) = default;\n\t\titerator& operator=(iterator&& i)noexcept = default;\n\n\t\titerator& operator++() {\n\t\t\tp++;\n\t\t\treturn *this;\n\t\t}\n\n\t\titerator operator++(int) {\n\t\t\titerator res = *this;\n\t\t\tp++;\n\t\t\treturn res;\n\t\t}\n\n\t\titerator operator+(const difference_type& x)const {\n\t\t\titerator res = *this;\n\t\t\treturn res += x;\n\t\t}\n\n\t\titerator& operator+=(const difference_type& x) {\n\t\t\tp += x;\n\t\t\treturn *this;\n\t\t}\n\n\t\titerator& operator--() {\n\t\t\tp--;\n\t\t\treturn *this;\n\t\t}\n\n\t\titerator operator--(int) {\n\t\t\titerator res = *this;\n\t\t\tp--;\n\t\t\treturn res;\n\t\t}\n\n\t\titerator operator-(const difference_type x)const {\n\t\t\titerator res = *this;\n\t\t\treturn res -= x;\n\t\t}\n\n\t\tdifference_type operator-(const iterator& i)const {\n\t\t\treturn p - i.p;\n\t\t}\n\n\t\titerator& operator-=(const difference_type x) {\n\t\t\tp -= x;\n\t\t\treturn *this;\n\t\t}\n\n\t\treference operator*()const {\n\t\t\treturn *p;\n\t\t}\n\n\t\treference operator[](const difference_type x)const {\n\t\t\treturn *(p + x);\n\t\t}\n\n\t\tbool operator<(const iterator& i)const {\n\t\t\treturn p < i.p;\n\t\t}\n\n\t\tbool operator<=(const iterator& i)const {\n\t\t\treturn p <= i.p;\n\t\t}\n\n\t\tbool operator==(const iterator& i)const {\n\t\t\treturn p == i.p;\n\t\t}\n\n\t\tbool operator>(const iterator& i)const {\n\t\t\treturn p > i.p;\n\t\t}\n\n\t\tbool operator>=(const iterator& i)const {\n\t\t\treturn p >= i.p;\n\t\t}\n\n\t\tbool operator!=(const iterator& i)const {\n\t\t\treturn p != i.p;\n\t\t}\n\n\t};\n\n\tclass const_iterator {\n\n\tpublic:\n\n\t\tusing difference_type = int;\n\t\tusing value_type = Vector::value_type;\n\t\tusing pointer = const Vector::pointer;\n\t\tusing reference = const Vector::reference;\n\t\tusing iterator_category = std::random_access_iterator_tag;\n\n\tprivate:\n\n\t\tpointer p;\n\n\tpublic:\n\n\t\tconst_iterator()noexcept :p() {}\n\t\tconst_iterator(const Vector& base, difference_type index) noexcept :p(base.e + index) {}\n\t\tconst_iterator(const const_iterator& i) :p(i.p) {}\n\n\t\tconst_iterator& operator=(const const_iterator& i)noexcept = default;\n\t\tconst_iterator& operator=(const_iterator&& i)noexcept = default;\n\n\t\tconst_iterator& operator++() {\n\t\t\tp++;\n\t\t\treturn *this;\n\t\t}\n\n\t\tconst_iterator operator++(int) {\n\t\t\tconst_iterator res = *this;\n\t\t\tp++;\n\t\t\treturn res;\n\t\t}\n\n\t\tconst_iterator operator+(const difference_type x)const {\n\t\t\tconst_iterator res = *this;\n\t\t\treturn res += x;\n\t\t}\n\n\t\tconst_iterator& operator+=(const difference_type x) {\n\t\t\tp += x;\n\t\t\treturn *this;\n\t\t}\n\n\t\tconst_iterator& operator--() {\n\t\t\tp--;\n\t\t\treturn *this;\n\t\t}\n\n\t\tconst_iterator operator--(int) {\n\t\t\tconst_iterator res = *this;\n\t\t\tp--;\n\t\t\treturn res;\n\t\t}\n\n\t\tconst_iterator operator-(const difference_type x)const {\n\t\t\tconst_iterator res = *this;\n\t\t\treturn res -= x;\n\t\t}\n\n\t\tdifference_type operator-(const const_iterator& i)const {\n\t\t\treturn p - i.p;\n\t\t}\n\n\t\tconst_iterator& operator-=(const difference_type x) {\n\t\t\tp -= x;\n\t\t\treturn *this;\n\t\t}\n\n\t\treference operator*()const {\n\t\t\treturn *p;\n\t\t}\n\n\t\treference operator[](const difference_type x)const {\n\t\t\treturn *(p + x);\n\t\t}\n\n\t\tbool operator<(const const_iterator& i)const {\n\t\t\treturn p < i.p;\n\t\t}\n\n\t\tbool operator<=(const const_iterator& i)const {\n\t\t\treturn p <= i.p;\n\t\t}\n\n\t\tbool operator==(const const_iterator& i)const {\n\t\t\treturn p == i.p;\n\t\t}\n\n\t\tbool operator>(const const_iterator& i)const {\n\t\t\treturn p > i.p;\n\t\t}\n\n\t\tbool operator>=(const const_iterator& i)const {\n\t\t\treturn p >= i.p;\n\t\t}\n\n\t\tbool operator!=(const const_iterator& i)const {\n\t\t\treturn p != i.p;\n\t\t}\n\n\t};\n\n\tusing reverse_iterator = std::reverse_iterator<iterator>;\n\tusing const_reverse_iterator = std::reverse_iterator<const_iterator>;\n\nprivate:\n\n\tpointer e;\n\tsize_type length = 0, cap = 1;\n\tAlloc alloc;\n\n\tstatic_assert(std::is_same<T, typename Alloc::value_type>::value, \"The allocator value type is not matched the Vector value type.\");\n\tstatic_assert(!std::is_const<T>::value, \"This library forbids containers of const elements\");\n\npublic:\n\n\tVector() :Vector(Alloc()) {}\n\n\texplicit Vector(const Alloc& a)noexcept :alloc(a) {\n\t\te = alloc.allocate(cap);\n\t}\n\n\texplicit Vector(size_type n, const Alloc& a = Alloc()) :alloc(a) {\n\t\twhile (cap < n)cap *= 2;\n\t\te = alloc.allocate(cap);\n\t\trep(i, n)emplace_back();\n\t}\n\n\texplicit Vector(size_type n, const_reference value, const Alloc& a = Alloc()) :alloc(a) {\n\t\twhile (cap < n)cap *= 2;\n\t\te = alloc.allocate(cap);\n\t\trep(i, n)emplace_back(value);\n\t}\n\n\ttemplate<class InputIter>\n\tVector(InputIter first, InputIter last, const Alloc& a = Alloc()) :alloc(a) {\n\t\te = alloc.allocate(cap);\n\t\tfor (InputIter i = first; i != last; i++) {\n\t\t\templace_back(*i);\n\t\t}\n\t}\n\n\tVector(const Vector& x, const Alloc& a = Alloc()) :alloc(a) {\n\t\twhile (cap < x.length)cap *= 2;\n\t\tlength = x.length;\n\t\te = alloc.allocate(cap);\n\t\trep(i, x.length)traits::construct(alloc, e + i, *(x.e + i));\n\t}\n\n\tVector(Vector&& x, const Alloc& a = Alloc()) :alloc(a) {\n\t\tcap = x.cap;\n\t\tlength = x.length;\n\t\te = x.e;\n\t\tx.e = nullptr;\n\t}\n\n\t~Vector() {\n\t\tif (e != nullptr) {\n\t\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\t\talloc.deallocate(e, cap);\n\t\t}\n\t}\n\n\tVector& operator=(const Vector& x) {\n\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\talloc.deallocate(e, cap);\n\t\tlength = x.length;\n\t\tcap = 1;\n\t\twhile (cap < length)cap *= 2;\n\t\te = alloc.allocate(cap);\n\t\trep(i, length)traits::construct(alloc, e + i, *(x.e + i));\n\t\treturn *this;\n\t}\n\n\tVector& operator=(Vector&& x) {\n\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\talloc.deallocate(e, cap);\n\t\tcap = x.cap;\n\t\tlength = x.length;\n\t\te = x.e;\n\t\tx.e = nullptr;\n\t\treturn *this;\n\t}\n\nprivate:\n\n\tvoid extension() {\n\t\tpointer e_ = alloc.allocate(cap * 2);\n\t\trep(i, length)traits::construct(alloc, e_ + i, *(e + i));\n\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\talloc.deallocate(e, cap);\n\t\te = e_;\n\t\tcap *= 2;\n\t}\n\n\tvoid extension(size_type n) {\n\t\tunsigned int r = 1;\n\t\twhile (cap * r < n)r *= 2;\n\t\tif (r == 1)return;\n\t\tpointer e_ = alloc.allocate(cap * r);\n\t\trep(i, length)traits::construct(alloc, e_ + i, *(e + i));\n\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\talloc.deallocate(e, cap);\n\t\te = e_;\n\t\tcap *= r;\n\t}\n\npublic:\n\n\ttemplate<class InputIter>\n\tvoid assign(InputIter first, InputIter last) {\n\t\tsize_type cnt = 0;\n\t\tfor (InputIter i = first; i != last; i++) {\n\t\t\tif (cnt == cap) {\n\t\t\t\tlength = std::max(length, cnt);\n\t\t\t\textension();\n\t\t\t}\n\t\t\ttraits::construct(alloc, e + cnt, *i);\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tvoid assign(size_type n, const_reference value) {\n\t\textension(n);\n\t\tstd::fill(e, e + n, value);\n\t}\n\n\ttemplate<class... Args>\n\tvoid emplace_back(Args&&... args) {\n\t\tif (length == cap)extension();\n\t\ttraits::construct(alloc, e + length, std::forward<Args>(args)...);\n\t\tlength++;\n\t}\n\n\tvoid push_back(const_reference value) {\n\t\templace_back(value);\n\t}\n\n\tvoid push_back(T&& value) {\n\t\templace_back(std::move(value));\n\t}\n\n\tvoid pop_back() {\n\t\ttraits::destroy(alloc, e + length);\n\t\tlength--;\n\t}\n\n\tvoid reserve(size_type n) {\n\t\textension(n);\n\t}\n\n\titerator erase(iterator pos) {\n\t\tconst iterator res = pos;\n\t\titerator t = pos; t++;\n\t\tfor (iterator i = pos; t != end(); i++, t++) {\n\t\t\t*i = std::move(*t);\n\t\t}\n\t\tpop_back();\n\t\treturn res;\n\t}\n\n\titerator erase(iterator first, iterator last) {\n\t\tconst iterator res = first;\n\t\ttypename iterator::difference_type d = last - first;\n\t\tfor (iterator i = first; i + d != end(); i++) {\n\t\t\t*i = std::move(*(i + d));\n\t\t}\n\t\trep(i, d)pop_back();\n\t\treturn res;\n\t}\n\n\tvoid swap(Vector& x) {\n\t\tstd::swap(length, x.length);\n\t\tstd::swap(cap, x.cap);\n\t\tstd::swap(e, x.e);\n\t}\n\n\tvoid clear() {\n\t\twhile (length)pop_back();\n\t}\n\n\tsize_type size()const {\n\t\treturn length;\n\t}\n\n\tvoid resize(size_type  n, const_reference value = T()) {\n\t\textension(n);\n\t\twhile (n < length)pop_back();\n\t\tlength = n;\n\t\tstd::fill(e, e + n, value);\n\t}\n\n\tsize_type capacity()const {\n\t\treturn cap;\n\t}\n\n\tbool empty()const {\n\t\treturn !length;\n\t}\n\n\treference operator[](const size_type pos)const {\n\t\treturn e[pos];\n\t}\n\n\tpointer data() {\n\t\treturn e;\n\t}\n\n\treference front() {\n\t\treturn *e;\n\t}\n\n\treference back() {\n\t\treturn *(e + length - 1);\n\t}\n\n\titerator begin() noexcept {\n\t\treturn iterator(*this, 0);\n\t}\n\n\tconst_iterator begin()const noexcept {\n\t\treturn const_iterator(*this, 0);\n\t}\n\n\tconst_iterator cbegin()const noexcept {\n\t\treturn const_iterator(*this, 0);\n\t}\n\n\titerator rbegin()noexcept {\n\t\treturn reverse_iterator(*this, 0);\n\t}\n\n\tconst_iterator rbegin()const noexcept {\n\t\treturn const_reverse_iterator(*this, 0);\n\t}\n\n\tconst_iterator crbegin()const noexcept {\n\t\treturn const_reverse_iterator(*this, 0);\n\t}\n\n\titerator end() noexcept {\n\t\treturn iterator(*this, length);\n\t}\n\n\tconst_iterator end()const noexcept {\n\t\treturn const_iterator(*this, length);\n\t}\n\n\tconst_iterator cend()const noexcept {\n\t\treturn const_iterator(*this, length);\n\t}\n\n\titerator rend()noexcept {\n\t\treturn reverse_iterator(*this, length);\n\t}\n\n\tconst_iterator rend()const noexcept {\n\t\treturn const_reverse_iterator(*this, length);\n\t}\n\n\tconst_iterator crend()const noexcept {\n\t\treturn const_reverse_iterator(*this, length);\n\t}\n\n};\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ninline lint gcd(lint a, lint b) {\n\twhile (b) {\n\t\tlint c = a;\n\t\ta = b; b = c % b;\n\t}\n\treturn a;\n}\ninline lint lcm(lint a, lint b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(lint n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\nlint mypow(lint a, lint b) {\n\tif (!b)return 1;\n\tif (b & 1)return mypow(a, b - 1) * a;\n\tlint memo = mypow(a, b >> 1);\n\treturn memo * memo;\n}\nlint modpow(lint a, lint b, lint m) {\n\tif (!b)return 1;\n\tif (b & 1)return modpow(a, b - 1, m) * a % m;\n\tlint memo = modpow(a, b >> 1, m);\n\treturn memo * memo % m;\n}\ntemplate<typename T>\nvoid printArray(std::vector<T>& vec) {\n\trep(i, vec.size() - 1)std::cout << vec[i] << \" \";\n\tstd::cout << vec.back() << std::endl;\n}\ntemplate<typename T>\nvoid printArray(Vector<T>& vec) {\n\trep(i, vec.size() - 1)std::cout << vec[i] << \" \";\n\tstd::cout << vec.back() << std::endl;\n}\ntemplate<typename T>\nvoid printArray(T l, T r) {\n\tT rprev = r;\n\trprev--;\n\tfor (T i = l; i != rprev; i++) {\n\t\tstd::cout << *i << \" \";\n\t}\n\tstd::cout << *rprev << std::endl;\n}\nstd::string to_string(Vector<int>& vec) {\n\tstd::string res = \"[\";\n\trep(i, vec.size() - 1)res += std::to_string(vec[i]) + \", \";\n\tres += std::to_string(vec.back()) + \"]\";\n\treturn res;\n}\ntemplate<unsigned int modulo = 1000000007>\nclass ModInt {\n\tlint value;\npublic:\n\tModInt() : value(0) {}\n\ttemplate<typename T>\n\tModInt(T value = 0) : value(value) {\n\t\tif (value < 0)value = -(lint)(-value % modulo) + modulo;\n\t\tthis->value = value % modulo;\n\t}\n\tinline operator int()const { return value; }\n\tinline ModInt& operator+=(const ModInt& x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline ModInt operator-()const {\n\t\treturn ModInt(0) -= *this;\n\t}\n\tinline ModInt& operator-=(const ModInt& x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator*=(const ModInt& x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator/=(ModInt rhs) {\n\t\tint exp = modulo - 2;\n\t\twhile (exp) {\n\t\t\tif (exp & 1)*this *= rhs;\n\t\t\trhs *= rhs;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn *this;\n\t}\n\ttemplate<typename T> ModInt operator+(const T& rhs)const { return ModInt(*this) += rhs; }\n\ttemplate<typename T> ModInt& operator+=(const T& rhs) { return operator+=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator-(const T& rhs)const { return ModInt(*this) -= rhs; }\n\ttemplate<typename T> ModInt& operator-=(const T& rhs) { return operator-=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator*(const T& rhs)const { return ModInt(*this) *= rhs; }\n\ttemplate<typename T> ModInt& operator*=(const T& rhs) { return operator*=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator/(const T& rhs)const { return ModInt(*this) /= rhs; }\n\ttemplate<typename T> ModInt& operator/=(const T& rhs) { return operator/=(ModInt(rhs)); }\n};\ntemplate<unsigned int T>\nstd::istream& operator>>(std::istream& ist, ModInt<T>& x) {\n\tlint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\nstd::string s;\nint k;\nint dp[310][310][310];\nint main() {\n\tstd::cin >> s >> k;\n\trep(i, s.size())dp[i][i + 1][0] = 1;\n\tREP(i, s.size()) {\n\t\trep(j, s.size() - i + 1) {\n\t\t\trep(l, k + 1) {\n\t\t\t\tif (j)chmax(dp[j - 1][j + i][l], dp[j][j + i][l]);\n\t\t\t\tif (j + i != s.size())chmax(dp[j][j + i + 1][l], dp[j][j + i][l]);\n\t\t\t\tif (j) {\n\t\t\t\t\tif (j && j + i != s.size() && s[j - 1] == s[j + i]) {\n\t\t\t\t\t\tchmax(dp[j - 1][j + i + 1][l], dp[j][j + i][l] + 2);\n\t\t\t\t\t}\n\t\t\t\t\telse chmax(dp[j - 1][j + i + 1][l + 1], dp[j][j + i][l] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i, k + 1)chmax(ans, dp[0][s.size()][i]);\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nint DP[301*301*301];\nvoid Calc(){\n\tstring S = res();\n\tint K = rei();\n\tint N = S.length();\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=N-1;j>i;j--){\n\t\t\tfor(int k=0;k<=K;k++){\n\t\t\t\tDP[(i+1)*301*301+j*301+k] = max(DP[i*301*301+j*301+k],DP[(i+1)*301*301+(j+1)*301+k]);\n\t\t\t\tif(S[i] == S[j]){\n\t\t\t\t\tDP[(i+1)*301*301+j*301+k] = max(DP[(i+1)*301*301+j*301+k],DP[i*301*301+(j+1)*301+k]+1);\n\t\t\t\t}\n\t\t\t\telse if(k != 0){\n\t\t\t\t\tDP[(i+1)*301*301+j*301+k] = max(DP[(i+1)*301*301+j*301+k],DP[i*301*301+(j+1)*301+k-1]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int k=0;k<=K;k++){\n\t\tfor(int i=0;i<N-1;i++){\n\t\t\tans = max(DP[(i+1)*301*301+(i+1)*301+k]*2,ans);\n\t\t}\n\t\tfor(int i=0;i<N-2;i++){\n\t\t\tans = max(DP[(i+1)*301*301+(i+2)*301+k]*2+1,ans);\n\t\t}\n\t}\n\tcout << ans << endl;\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<math.h>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<cstring>\n#include<cstdio>\n#include<functional>\n#include<bitset>\n#include<limits.h>\n#include<cassert>\n#include<iterator>\n#include<complex>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<time.h>\n#include<random>\n#include<array>\nusing namespace std;\nusing ll = long long;\n#define rep(i, a, b) for(int i = a; i < b; i++)\n#define rrep(i, a, b) for(int i = b - 1; i >= a; i--)\n#define ALL(a) a.begin(), a.end()\nusing pii = pair<int,int>;\nusing piii = pair<pii,int>;\nusing pll = pair<long long, long long>;\nusing plll = pair<pll, long long>;\n// #pragma GCC optimize(\"Ofast\")\n#define pcnt __builtin_popcount\n#define buli(x) __builtin_popcountll(x)\n#define pb push_back\n#define mp make_pair\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define isSquare(x) (sqrt(x)*sqrt(x) == x)\ntemplate<class T>inline bool chmax(T &a, const T &b) {if(a<b){a = b; return 1;} return 0; };\ntemplate<class T>inline bool chmin(T &a, const T &b) {if(a>b){a = b; return 1;} return 0; };\ninline void in(void){return;}\ntemplate <typename First, typename... Rest> void in(First& first, Rest&... rest){cin >> first;in(rest...);return;}\ninline void out(void){cout << \"\\n\";return;}\ntemplate <typename First, typename... Rest> void out(First first, Rest... rest){cout << first << \" \";out(rest...);return;}\nconst double EPS = 1e-9;\nconst int mod = 1e9 + 7;\nconst int INF = 1e9;\nconst long long INFLL = 1e18;\nvoid iosetup() {\n    cin.tie(nullptr);ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n}\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 >& p) {\n    os << p.first << \" \" << p.second;\n    return os;\n}\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n    is >> p.first >> p.second;\n    return is;\n}\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n    for(int i = 0; i < (int) v.size(); i++) {\n        os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n    }\n    return os;\n}\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n    for(T &in : v) is >> in;\n    return is;\n}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S, T>& t){return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S, T>& t){return pair<S,T>(s.first-t.first, s.second-t.second);}\ntemplate<class S, class T> pair<S,T> operator*(const pair<S,T> &s, const S& t){return pair<S,T>(s.first*t, s.second*t);}\ntemplate <typename T> void Exit(T first){cout << first << endl;exit(0); };\ntemplate< int mod > struct ModInt {\n    unsigned x; ModInt() : x(0) {}\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n    ModInt &operator+=(const ModInt &p) {if((x += p.x) >= mod) x -= mod;return *this;}\n    ModInt &operator-=(const ModInt &p) {if((x += mod - p.x) >= mod) x -= mod;return *this;}\n    ModInt &operator*=(const ModInt &p) {x = (int) (1LL * x * p.x % mod);return *this;}\n    ModInt &operator/=(const ModInt &p) {*this *= p.inverse();return *this;}\n    ModInt operator-() const { return ModInt(-x); }\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n    bool operator==(const ModInt &p) const { return x == p.x; }\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n    ModInt inverse() const {int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) { t = a / b; swap(a -= t * b, b); swap(u -= t * v, v); }return ModInt(u);}\n    ModInt pow(int64_t n) const {ModInt ret(1), mul(x); while(n > 0) {if(n & 1) ret *= mul;mul *= mul;n >>= 1;}return ret;}\n    friend ostream &operator<<(ostream &os, const ModInt &p) { return os << p.x;}\n    friend istream &operator>>(istream &is, ModInt &a) { int64_t t; is >> t; a = ModInt< mod >(t); return (is); }\n    static int get_mod() { return mod; }\n}; using modint = ModInt< mod >;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst pii dxy[4] = {pii(1,0), pii(0, 1), pii(-1, 0), pii(0, -1)};\nconst int calender[13] = {0, 31,28,31,30,31,30,31,31,30,31,30,31};\nconst int ucalender[13] = {0, 31,29,31,30,31,30,31,31,30,31,30,31};\nbool range(int a, int b, int x){if(a <= x and x < b)return true;else return false;}\nbool range(int a, int b, int c, int d, pii p){if(a <= p.first and p.first < b and c <= p.second and p.second < d) return true;else return false;}\n\nint dp[310][310][310];\nint main(){\n    iosetup();\n    string S; cin >> S;\n    int n = S.size();\n    int K; cin >> K;\n    memset(dp, 0, sizeof dp);\n    rep(i, 0, n)rep(j, 0, K + 1) dp[i][i][j] = 1;\n    rep(i, 1, n){\n        rep(j, 0, n - i){\n            // if(j + i >= n) break;\n            rrep(k, 0, K + 1){\n                chmax(dp[j][j+i][k], dp[j][j+i-1][k]); \n                chmax(dp[j][j+i][k], dp[j+1][j+i][k]); \n                if(S[j] == S[j+i]) chmax(dp[j][j+i][k], dp[j+1][j+i-1][k] + 2);\n                else{\n                    if(k >= 1)chmax(dp[j][j+i][k], dp[j+1][j+i][k-1] + 2);\n                    if(k >= 1)chmax(dp[j][j+i][k], dp[j][j+i-1][k-1] + 2);\n                }\n            }\n        }\n    }\n    // rep(l, 0, n) rep(r, l + 1, n){\n    //     cerr << l << \",\" << r << endl;\n    //     rep(k, 0, K + 1){\n    //     cerr << dp[l][r][k] << \" \";\n    //     }\n    //     cerr << endl;\n    // }\n    cout << dp[0][n-1][K] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "///not today\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef pair<long long, long long> pll;\n\n#define SZ(x) (int)(x).size()\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define xmax(x, y) (x) = max((x), (y))\n#define xmin(x, y) (x) = min((x), (y))\n#define F first\n#define S second\n#define int long long\n#define accept_sho ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#pragma GCC optimize (\"Ofast\")\n#pragma GCC optimize (\"unroll-loops\")\n#define lc (v << 1)\n#define rc ((v << 1)| 1)\n#define mid ((R + L) >> 1)\n\nconst int maxn = 3e2 + 2;\nint dp[maxn][maxn][maxn];\n\nint32_t main(){\n      string s;\n      int K, n;\n      cin >>s >>K;\n      n = SZ(s);\n      for(int k = 0; k <= K; k ++){\n      for(int j = 0; j < n; j ++){\n      for(int i = 0; i + j < n; i ++){\n                        dp[k][j][i] = 1;\n                        if(j == 0)\n                              continue;\n                        if(s[i] == s[i + j]){\n                              if(j > 1){\n                                    dp[k][j][i] = dp[k][j - 2][i + 1] + 2;\n                              }\n                              else{\n                                    dp[k][j][i] = 2;\n                              }\n                        }\n                        else{\n                              xmax(dp[k][j][i], dp[k][j - 1][i]);\n                              xmax(dp[k][j][i], dp[k][j - 1][i + 1]);\n                              if(k){\n                                    if(j > 1){\n                                          xmax(dp[k][j][i], dp[k - 1][j - 2][i + 1] + 2);\n                                    }\n                                    else{\n                                          dp[k][j][i] = 2;\n                                    }\n                              }\n                        }\n      }\n      }\n      }\n      cout <<dp[K][n - 1][0] <<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst ld EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\nint main(){\n    string S;\n    cin >> S;\n    int N = sz(S), K;\n    cin >> K;\n    //dp[i][j][k]:=S[i:j]をk文字まで変更したときの価値の最大値\n    int dp[N][N][K+1];\n    //操作回数\n    rep(i, K+1){\n        //幅j\n        rep(j, N){\n            //スタート地点\n            rep(k, N-j){\n                if(j <= 2*i) dp[k][k+j][i] = j+1;\n                else{\n                    if(S[k] == S[k+j]){\n                        if(j == 0) dp[k][k+j][i] = 2;\n                        else dp[k][k+j][i] = dp[k+1][k+j-1][i]+2;\n                    }\n                    else{\n                        dp[k][k+j][i] = max(dp[k+1][k+j][i], dp[k][k+j-1][i]);\n                        if(i > 0){\n                            chmax(dp[k][k+j][i], dp[k+1][k+j-1][i-1]+2);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    cout << dp[0][N-1][K] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename Container>\nint SZ(const Container& S) { return S.size(); }\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg_var(x) clog << #x  << \": \" << x << endl;\n    #define dbg_array(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg_var(x)\n    #define dbg_array(x, len)\n#endif\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\nconst int MAXN = 310;\nint din[MAXN][MAXN][MAXN];\nint last[26][MAXN]; \n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in problems with online queries!\n    string s;\n    cin >> s;\n    int K;\n    cin >> K;\n    int N = s.size();\n    for (int i = 0; i < N; i++) {\n        for (int c = 0; c < 26; c++) last[c][i+1] = last[c][i];\n        last[s[i]-'a'][i+1] = i;\n    }\n    // for (int l = 0; l <= N; l++) din[l][l] = 0;\n    for (int l = 0; l < N; l++) for (int k = 0; k <= K; k++) din[l][l+1][k] = 1;\n    for (int dd = 2; dd <= N; dd++) {\n        for (int l = 0; l+dd <= N; l++) {\n            int r = l+dd;\n            for (int k = 0; k <= K; k++) {\n                din[l][r][k] = din[l+1][r][k];\n                if (k > 0) din[l][r][k] = max(din[l][r][k], 2 + din[l+1][r-1][k-1]);\n                int index = last[s[l]-'a'][r];\n                if (index > l) din[l][r][k] = max(din[l][r][k], 2 + din[l+1][index][k]);\n            }\n        }\n    }\n    cout << din[0][N][K] << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nchar sir[310];\nint d[310][310][160];\n\nint main()\n{\n    //freopen(\"file.in\",\"r\",stdin);\n    //freopen(\"file.out\",\"w\",stdout);\n    int k1;\n    scanf(\"%s\\n\",sir+1);\n    int n=strlen(sir+1);\n    scanf(\"%d\",&k1);\n    if(k1>=n/2) {printf(\"%d\",n);return 0;}\n    for(int l=0;l<n;l++)\n        for(int i=1;i<=n-l;i++)\n            for(int k=0;k<=k1;k++)\n            {\n                int j=i+l;\n                if(i==j) d[i][j][k]=1;\n                else if(i==j-1)\n                {\n                    if(k>0 or sir[i]==sir[j]) d[i][j][k]=2;\n                    else d[i][j][k]=1;\n                }\n                else\n                {\n                    d[i][j][k]=max(d[i+1][j][k],d[i][j-1][k]);\n                    if(sir[i]==sir[j]) d[i][j][k]=max(d[i][j][k],d[i+1][j-1][k]+2);\n                    if(k>0) d[i][j][k]=max(d[i][j][k],d[i+1][j-1][k-1]+2);\n                }\n            }\n    printf(\"%d\",d[1][n][k1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 305\nusing namespace std;\nchar s[N];\nint n,k,dp[N][N][N],Ans;\nvoid upd(int &x,int y)\n{\n\tx=max(x,y);\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tscanf(\"%d\",&k);\n\tdp[1][n][0]=0;\n\tfor (int i=0;i<=k;i++)\n\t{\n\t\tfor (int l=1;l<=n;l++)\n\t\tfor (int r=n;r>=l;r--)\n\t\t{\n\t\t\tint tmp=dp[l][r][i];\n\t\t\t\n\t\t\tif (l==r) upd(Ans,tmp+1);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (l+1==r)\n\t\t\t\t{\n\t\t\t\t\tif (s[l]==s[r]||i<k) upd(Ans,tmp+2);\n\t\t\t\t\telse upd(Ans,tmp+1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupd(dp[l+1][r][i],tmp);\n\t\t\t\t\tupd(dp[l][r-1][i],tmp);\n\t\t\t\t\tif (s[l]==s[r]) upd(dp[l+1][r-1][i],tmp+2);\n\t\t\t\t\telse if (i<k) upd(dp[l+1][r-1][i+1],tmp+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",Ans);\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(int x) { return 8*sizeof(int)-__builtin_clz(x); }\n\nnamespace std {\n    template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};\n}\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\ntemplate <typename T> struct bounded_priority_queue {\n\tinline bounded_priority_queue(ui X) : A(X), B(0), s(0) {}\n\tinline void push(ui L, T V) { B = max(B, L); A[L].push(V); ++s; }\n\tinline const T &top() const { return A[B].front(); }\n\tinline void pop() { --s; A[B].pop(); while (B > 0 && A[B].empty()) --B; }\n\tinline bool empty() const { return A[B].empty(); }\n\tinline void clear() { s = B = 0; for (auto &a: A) a = queue<T>(); }\n\tinline ui size() const { return s; }\nprivate:\n\tvector<queue<T>> A; ui B; int s;\n};\n\n\n#endif\n// #include \"../l/mod.h\"\n\nclass D {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        string S; cin >> S;\n        int K; cin >> K;\n        string T = S;\n        reverse(T.begin(),T.end());\n        int N = S.size();\n        vector3<int> L(N+1,N+1,N+3,-100000);\n        for (int i = 1; i <= N; ++i) {\n            L[0][i][0] = L[i][0][0] = 0;\n        }\n        L[0][0][0] = 0;\n\n        for (int i = 1; i <= N; ++i) {\n            for (int j = 1; j <= N; ++j) {\n                if (i+j>N+1) continue;\n                int c = 2 - (i+j==N+1);\n                for (int k = 0; k <= N; ++k) {\n                    L[i][j][k] = max(L[i][j][k], L[i-1][j][k]);\n                    L[i][j][k] = max(L[i][j][k], L[i][j-1][k]);\n                    if (S[i-1] == T[j-1]) {\n                        L[i][j][k] = max(L[i][j][k], c + L[i-1][j-1][k]);\n                    } else  {\n                        L[i][j][k+c] = max(L[i][j][k+c], L[i-1][j-1][k]);\n                    }\n                }\n            }\n        }\n\n\n        int ans = 0;\n        for (int i = 1; i <= N; ++i) {\n            int j = N-i+1;\n            for (int k = 0; k <= N; ++k) {\n//                cerr << L[i][j][k] << ' ' << K << ' ' << k << endl;\n                int pairs = min(k,2*K);\n                ans = max(ans, L[i][j][k] + pairs);\n            }\n        }\n        cout << min(N, ans) << endl;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tD solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,inline,unroll-loops,fast-math\")\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#define N 320\nusing namespace std;\n\nchar a[N];\nint f[N][N][N];\n\nint main(void)\n{\n    int n, k;\n    int i, j, t, o;\n\n    scanf(\"%s %d\", a + 1, &k);\n    n = strlen(a + 1);\n\n    for(i = 1, o = 0; i <= n; i ++)\n        for(j = n; j > i; j --)\n            for(t = 0; t <= k; t ++)\n            {\n                f[i][j][t] = max(f[i - 1][j][t], f[i][j + 1][t]);\n                if(a[i] == a[j])\n                    f[i][j][t] = max(f[i][j][t], f[i - 1][j + 1][t] + 1);\n                else if(t)\n                    f[i][j][t] = max(f[i][j][t], f[i - 1][j + 1][t - 1] + 1);\n\n                // printf(\"left %d, right %d, change %d : %d\\n\", i, j, t, f[i][j][t]);\n                o = max(o, f[i][j][t] * 2 + (i < j - 1));\n            }\n    printf(\"%d\\n\", o);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x < 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tstring S;\n\tint K;\n\tcin >> S >> K;\n\tint N =S.length();\n\tvector< vector< vector<int> > > ans(K+1, vector< vector<int> >(N+1, vector<int>(N+1, -OVER9000)));\n\tans[0][0][N] =0;\n\tfor(int l =N; l > 0; l--) for(int i =0; i <= N-l; i++) {\n\t\tif(l == 1) {\n\t\t\tfor(int k =0; k <= K; k++) ans[k][i][i] =max(ans[k][i][i], ans[k][i][i+1]+1);\n\t\t\tfor(int k =0; k <= K; k++) ans[k][i][i+l-1] =max(ans[k][i][i+l-1], ans[k][i][i+l]);\n\t\t\tfor(int k =0; k <= K; k++) ans[k][i+1][i+l] =max(ans[k][i+1][i+l], ans[k][i][i+l]);\n\t\t\tcontinue;\n\t\t}\n\t\tif(S[i] == S[i+l-1]) {\n\t\t\tfor(int k =0; k <= K; k++) ans[k][i+1][i+l-1] =max(ans[k][i+1][i+l-1], ans[k][i][i+l]+2);\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int k =0; k <= K; k++) ans[k][i][i+l-1] =max(ans[k][i][i+l-1], ans[k][i][i+l]);\n\t\tfor(int k =0; k <= K; k++) ans[k][i+1][i+l] =max(ans[k][i+1][i+l], ans[k][i][i+l]);\n\t\tfor(int k =0; k < K; k++) ans[k+1][i+1][i+l-1] =max(ans[k+1][i+1][i+l-1], ans[k][i][i+l]+2);\n\t}\n\tint ansF =0;\n\tfor(int i =0; i <= K; i++) for(int j =0; j <= N; j++) ansF =max(ansF, ans[i][j][j]);\n\tcout << ansF << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nll MOD = 1e9+7;\nint main()\n{\n    string s;\n    int k;\n    cin >> s >> k;\n    int n = s.size();\n    int dp[n+1][n+1][k+1];\n    for(int i = 0; i <= n; i++)\n    {\n      for(int j = 0; j <= n; j++)\n      {\n        for(int x = 0; x <= k; x++) dp[i][j][x] = 0;\n      }\n    }\n  \n    for(int i = 0; i < n; i++)\n    {\n        dp[i][i][k] = 1;\n        if(i+1 < n && s[i] == s[i+1]) dp[i][i+1][k] = 2;\n        else dp[i][i+1][k] = 1;\n        if(k) dp[i][i+1][k-1] = 2;\n    }\n\n    for(int i = 0; i < n; i++)\n    {\n        for(int l = 0; l+i < n; l++)\n        {\n            int r = l+i;\n            for(int x = 0; x <= k; x++)\n            {\n                if(l > 0) dp[l-1][r][x] = max(dp[l-1][r][x], dp[l][r][x]);\n                if(r+1 < n) dp[l][r+1][x] = max(dp[l][r+1][x], dp[l][r][x]);\n                if(l > 0 && r+1 < n)\n                {\n                    if(s[l-1] == s[r+1]) dp[l-1][r+1][x] = max(dp[l-1][r+1][x], dp[l][r][x] + 2);\n                    if(x) dp[l-1][r+1][x-1] = max(dp[l-1][r+1][x-1], dp[l][r][x] + 2);\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for(int i = 0; i <= k; i++)\n    {\n        ans = max(ans, dp[0][n-1][i]);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nshort dp[305][305][305];\nchar in[310];\nvoid upd(short &x, short y) {\n\tif (x < y) x = y;\n}\nint main() {\n\tint n, k;\n\tscanf(\"%s%d\", in+1, &k);\n\tn = strlen(in+1);\n\tfor (int i = 1; i <= n; i++) for (int j = 0; j <= k; j++) dp[i][i][j] = 1;\n\tfor (int d = 1; d <= n; d++) {\n\t\tfor (int i = 1; i + d <= n; i++) {\n\t\t\tint j = i + d;\n\t\t\tfor (int t = 0; t <= k; t++) {\n\t\t\t\tupd(dp[i][j][t], dp[i + 1][j][t]);\n\t\t\t\tupd(dp[i][j][t], dp[i][j - 1][t]);\n\t\t\t}\n\t\t\tif (in[i] == in[j]) {\n\t\t\t\tfor (int t = 0; t <= k; t++) upd(dp[i][j][t], dp[i + 1][j - 1][t] + 2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int t = 1; t <= k; t++) upd(dp[i][j][t], dp[i + 1][j - 1][t-1] + 2);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[1][n][k]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define rep(i, s, t) for(i = s; i <= t; ++i)\n#define dep(i, s, t) for(i = s; i >= t; --i)\n\nusing namespace std;\n\nconst int N = 310;\nint n, m, K, ans;\nchar s[N], t[N];\nint f[N][N][N];\n\nint main() {\n\tint i, j, k;\n\tscanf(\"%s\", s+1); n = strlen(s+1);\n\tm = n >> 1;\n\trep(i, 1, n) t[i] = s[n-i+1];\n\t\n\tscanf(\"%d\", &K);\n\tans = 1;\n\trep(i, 1, n-1) {\n\t\trep(j, 1, n-i) \n\t\t\trep(k, 0, K) {\n\t\t\t\tf[i][j][k] = max(f[i-1][j][k], f[i][j-1][k]);\n\t\t\t\tif(k) f[i][j][k] = max(f[i][j][k], f[i][j][k-1]);\n\t\t\t\tif(s[i] == t[j]) {\n\t\t\t\t\tf[i][j][k] = max(f[i-1][j-1][k]+1, f[i][j][k]);\n\t\t\t\t} else {\n\t\t\t\t\tif(k) f[i][j][k] = max(f[i-1][j-1][k-1]+1, f[i][j][k]);\n\t\t\t\t}\n\t\t\t\t//printf(\"%d %d %d %d\\n\", i, j, k, f[i][j][k]);\n\t\t\t}\n\t\tans = max(ans, f[i][n-i-1][K]*2+1);\n\t\tans = max(ans, f[i][n-i][K]*2);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nint m;\nusing namespace std;\nconst int N = 302;\nstring s;\nint f[N][N][N];\nint a[N];\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> s;\n    cin >> m;\n    for (int i = 0; i < s.size(); i++) a[i + 1] = s[i] - 'a';\n    int n = s.size(); a[0] = -1; a[n + 1] = -1;\n    f[1][n][0] = 0;\n    for (int i = 1; i <= n; i++) {\n        for (int j = n; j >= i; j--) {\n            for (int k = 0; k <= m; k++) {\n                f[i + 1][j][k] = max(f[i + 1][j][k], f[i][j][k]);\n                f[i][j - 1][k] = max(f[i][j - 1][k], f[i][j][k]);\n                if (a[i] != a[j]) {\n                    f[i + 1][j - 1][k + 1] = max(f[i + 1][j - 1][k + 1], f[i][j][k] + 2 - (i == j));\n                }\n                else {\n                    f[i + 1][j - 1][k] = max(f[i + 1][j - 1][k], f[i][j][k] + 2 - (i == j));\n                }\n            }\n        }\n    }\n    int mx = 0;\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            for (int k = 0; k <= m; k++) {\n                mx = max(mx, f[i][j][k]);\n            }\n        }\n    }\n    cout << mx << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn=305;\nconst int INF=1e9;\nint dp[maxn][maxn][maxn];\nchar str[maxn];\nint main()\n{\n    int s;\n    scanf(\"%s%d\",str,&s);\n    int l=strlen(str);\n    for(int i=0;i<=l+1;i++)\n        for(int j=0;j<=l+1;j++)\n            for(int k=0;k<=s;k++)\n                dp[i][j][k]=-INF;\n    for(int k=0;k<=s;k++)\n        dp[1][l][k]=0;\n    int ans=0;\n    for(int i=1;i<=l;i++)\n    {\n        for(int j=l;j>=i;j--)\n        {\n            for(int k=s;k>=0;k--)\n            {\n                dp[i+1][j][k]=max(dp[i][j][k],dp[i+1][j][k]);\n                dp[i][j-1][k]=max(dp[i][j][k],dp[i][j-1][k]);\n\n                if(str[i-1]==str[j-1]){\n                    dp[i+1][j-1][k]=max(dp[i][j][k]+1+(i!=j),dp[i+1][j-1][k]);\n                }\n                else{\n                    if(k){\n                        dp[i+1][j-1][k-1]=max(dp[i][j][k]+2,dp[i+1][j-1][k-1]);\n                    }\n                }\n\n            }\n        }\n    }\n    for(int i=0;i<=l+1;i++)\n        for(int j=0;j<=l+1;j++)\n            for(int k=0;k<=s;k++)\n                ans=max(ans,dp[i][j][k]);\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Nurbakyt Madibek\n// Look at my code! IT'S AWESOME\n\n#include <iostream>\n#include <iomanip>\n#include <cstdlib>\n#include <algorithm>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <cassert>\n#include <unordered_map>\n#include <bitset>\n#include <unordered_set>\n\nusing namespace std;\n\n#define pb push_back\n#define pp pop_back\n#define f first\n#define s second\n#define mp make_pair\n#define sz(a) (int)((a).size())\n#ifdef _WIN32\n#  define I64 \"%I64d\"\n#else\n#  define I64 \"%lld\"\n#endif\n#define fname \".\"\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair < int, int > pi;\ntypedef pair < int, ull > pu;\ntypedef pair < ll, ll > pl;\n\nconst int inf = (int)1e9;\nconst ll infl = (ll)1e18 + 123;\nconst double eps = 1e-9;\n\nconst int MAX_N = (int)1e5 + 123;\nconst int mod = (int)1e9 + 7;\nconst int P = 123457;\n\nstring s;\nint k;\n\nint dp[305][305][305];\n\nint calc(int l, int r, int x) {\n    int &res = dp[l][r][x];\n    if (res != -1)\n        return res;\n    if (l == sz(s) || r == -1 || l > r)\n        return res = 0;\n    if (l == r)\n        return res = 1;\n    res = max(calc(l + 1, r, x), calc(l, r - 1, x));\n    if (s[l] == s[r])\n        res = max(res, 2 + calc(l + 1, r - 1, x));\n    else if (x > 0)\n        res = max(res, 2 + calc(l + 1, r - 1, x - 1));\n    return res;\n}\n\nint main() {\n#ifdef DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    ios_base :: sync_with_stdio(0);\n    cin.tie(0);\n    cin >> s >> k;\n    memset(dp, -1, sizeof dp);\n    cout << calc(0, sz(s) - 1, k) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n\t#include <boost/multiprecision/cpp_int.hpp>\n\t#include <boost/multiprecision/cpp_dec_float.hpp>\n\tusing bll = boost::multiprecision::cpp_int;\n\tusing bdouble = boost::multiprecision::cpp_dec_float_100;\n#endif\n#ifdef LOCAL_DEV\n\tvoid debug_impl() { std::cerr << '\\n'; }\n\ttemplate<typename Head, typename... Tail> void debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head << (sizeof...(tail) ? \",\" : \"\"); debug_impl(tail...); }\n\t#define debug(...) do { std::cerr << \"(\" << #__VA_ARGS__ << \") =\"; debug_impl(__VA_ARGS__); } while (false)\n#else\n\t#define debug(...) do {} while (false)\n#endif\n#ifdef LOCAL_TEST\n\t#define BOOST_STACKTRACE_USE_ADDR2LINE\n\t#define BOOST_STACKTRACE_ADDR2LINE_LOCATION /usr/local/opt/binutils/bin/addr2line\n\t#define _GNU_SOURCE\n\t#include <boost/stacktrace.hpp>\n\tnamespace std {\n\t\ttemplate<typename T> class dvector : public std::vector<T> {\n\t\tpublic:\n\t\t\tdvector() : std::vector<T>() {}\n\t\t\texplicit dvector(size_t n, const T& value = T()) : std::vector<T>(n, value) {}\n\t\t\tdvector(const std::vector<T>& v) : std::vector<T>(v) {}\n\t\t\tdvector(const std::initializer_list<T> il) : std::vector<T>(il) {}\n\t\t\tdvector(const typename std::vector<T>::iterator first, const typename std::vector<T>::iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const std::string::iterator first, const std::string::iterator last) : std::vector<T>(first, last) {}\n\t\t\tT& operator[](size_t n) {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst T& operator[](size_t n) const {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\tclass dbool {\n\tprivate:\n\t\tbool boolvalue;\n\tpublic:\n\t\tdbool() : boolvalue(false) {}\n\t\tdbool(bool b) : boolvalue(b) {}\n\t\tdbool(const dbool& b) : boolvalue(b.boolvalue) {}\n\t\toperator bool&() { return boolvalue; }\n\t\toperator const bool&() const { return boolvalue; }\n\t};\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::dvector<T>& v) {\n\t\tfor (size_t i = 0; i < v.size(); ++i){ s << v[i]; if (i < v.size() - 1) s << \"\\t\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::dvector<std::dvector<T>>& vv) {\n\t\ts << \"\\n\"; for (size_t i = 0; i < vv.size(); ++i){ s << vv[i] << \"\\n\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::set<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::multiset<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate <typename T, size_t N> std::ostream& operator<<(std::ostream& s, const std::array<T, N>& a) {\n\t\ts << \"{ \"; for (size_t i = 0; i < N; ++i){ s << a[i] << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::map<T1, T2>& m) {\n\t\ts << \"{\\n\"; for (auto itr = m.begin(); itr != m.end(); ++itr){ s << \"\\t\" << (*itr).first << \" : \" << (*itr).second << \"\\n\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::pair<T1, T2>& p) {\n\t\treturn s << \"(\" << p.first << \", \" << p.second << \")\"; }\n\t#define vector dvector\n\t#define bool dbool\n\tclass SIGFPE_exception : std::exception {};\n\tclass SIGSEGV_exception : std::exception {};\n\tvoid catch_SIGFPE(int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGFPE_exception();\t}\n\tvoid catch_SIGSEGV(int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGSEGV_exception(); }\n\tsigned convertedmain();\n\tsigned main() { signal(SIGFPE, catch_SIGFPE); signal(SIGSEGV, catch_SIGSEGV); return convertedmain(); }\n\t#define main() convertedmain()\n#endif\n//#define int long long\nusing ll = long long;\n//constexpr int INF = 1e9;//INT_MAX=(1<<31)-1=2147483647\nconstexpr ll INF = (ll)1e18;//(1LL<<63)-1=9223372036854775807\nconstexpr ll MOD = 998244353;//(ll)1e9 + 7;\nconstexpr double EPS = 1e-9;\nconstexpr ll dx[4] = {1LL, 0LL, -1LL, 0LL};\nconstexpr ll dy[4] = {0LL, 1LL, 0LL, -1LL};\nconstexpr ll dx8[8] = {1LL, 0LL, -1LL, 0LL, 1LL, 1LL, -1LL, -1LL};\nconstexpr ll dy8[8] = {0LL, 1LL, 0LL, -1LL, 1LL, -1LL, 1LL, -1LL};\n#define rep(i, n)   for(ll i=0, i##_length=(n); i< i##_length; ++i)\n#define repeq(i, n) for(ll i=1, i##_length=(n); i<=i##_length; ++i)\n#define rrep(i, n)   for(ll i=(n)-1; i>=0; --i)\n#define rrepeq(i, n) for(ll i=(n)  ; i>=1; --i)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\nvoid p() { std::cout << '\\n'; }\ntemplate<typename Head, typename... Tail> void p(Head head, Tail... tail) { std::cout << head << (sizeof...(tail) ? \" \" : \"\"); p(tail...); }\ntemplate<typename T> inline void pv(std::vector<T>& v) { for(ll i=0, N=v.size(); i<N; i++) std::cout << v[i] << \" \\n\"[i==N-1]; }\ntemplate<typename T> inline T gcd(T a, T b) { return b ? gcd(b,a%b) : a; }\ntemplate<typename T> inline T lcm(T a, T b) { return a / gcd(a,  b) * b; }\ntemplate<typename T> inline bool chmax(T& a, T b) { return a < b && (a = b, true); }\ntemplate<typename T> inline bool chmin(T& a, T b) { return a > b && (a = b, true); }\ntemplate<typename T> inline void uniq(std::vector<T>& v) { v.erase(std::unique(v.begin(), v.end()), v.end()); }\n\n/*-----8<-----template-----8<-----*/\nnamespace makevectordetail {\n\ttemplate <typename Tp, size_t N>\n\tstd::vector<Tp> make_vector(\n\t\t\tstd::vector<size_t>& sizes,\n\t\t\ttypename std::enable_if<(N == 1), Tp const&>::type x\n\t) {\n\t\treturn std::vector<Tp>(sizes[0], x);\n\t}\n\ttemplate <typename Tp, size_t N>\n\tauto make_vector(\n\t\t\tstd::vector<size_t>& sizes,\n\t\t\ttypename std::enable_if<(N > 1), Tp const&>::type x\n\t) {\n\t\tsize_t size = sizes[N-1];\n\t\tsizes.pop_back();\n\t\treturn std::vector<decltype(make_vector<Tp, N-1>(sizes, x))>(\n\t\t\t\tsize, make_vector<Tp, N-1>(sizes, x)\n\t\t);\n\t}\n}\ntemplate <typename Tp, typename sizetype, size_t N>\nauto make_vector(sizetype const(&sizes)[N], Tp const& x = Tp()) {\n\tstd::vector<size_t> s(N);\n\tfor (size_t i = 0; i < N; ++i) s[i] = sizes[N-i-1];\n\treturn makevectordetail::make_vector<Tp, N>(s, x);\n}\n//vector<vector<vector<ll>>> v = make_vector<ll>({1, 2, 3}, 0LL);\n/*-----8<-----library-----8<-----*/\n\nstring S;ll K;\n//dp[l][r][k] 文字変更をk回行った状態で[l,r]間の回文の最大長\nvector<vector<vector<ll>>> dp;\nll f(ll l,ll r,ll k){\n\tif(dp[l][r][k])return dp[l][r][k];\n\t//0文字\n\tif(l==r)return dp[l][r][k]=1;\n\t//1文字\n\tif(r-l==1){\n\t\tif(S[l]==S[r])return dp[l][r][k]=2;\n\t\treturn dp[l][r][k]=1;\n\t}\n\n\tll ans=0;\n\t//左右に関係ない文字を追加しても回文長は同じ\n\tchmax(ans, f(l+1,r,k));\n\tchmax(ans, f(l,r-1,k));\n\n\tif(S[l]==S[r]){\n\t\t//文字が同じ → 回文長に2加算\n\t\tchmax(ans, f(l+1,r-1,k)+2);\n\t}else if(k<K){\n\t\t//文字変更して無理矢理一緒にする\n\t\tchmax(ans, f(l+1,r-1,k+1)+2);\n\t}\n\n\treturn dp[l][r][k]=ans;\n}\n\nvoid solve() {\n\t\n\tcin>>S>>K;\n\tdp = make_vector<ll>({S.size()+1, S.size()+1, (size_t)K+1}, 0);\n\n\tll ans=f(0,S.size()-1,0);\n\tp(ans);\n}\n\nsigned main() {\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=305;\nchar s[N];\nint n,f,dp[N][N][N];\nint main()\n{\n    scanf(\"%s\",s+1);\n    n=strlen(s+1);\n    scanf(\"%d\",&f);\n    int ans=1;\n    for(int i=1;i<=n;i++)\n        for(int j=n;j>i;j--)\n        for(int k=0;k<=f;k++)\n    {\n        dp[i][j][k]=max(dp[i-1][j][k],dp[i][j+1][k]);\n        if(s[i]==s[j])\n            dp[i][j][k]=max(dp[i][j][k],dp[i-1][j+1][k]+1);\n        if(k>0)\n            dp[i][j][k]=max(dp[i][j][k],dp[i-1][j+1][k-1]+1);\n        ans=max(ans,dp[i][j][k]*2);\n        if(i+1==j-1)\n            ans=max(ans,dp[i][j][k]*2+1);\n    }\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m;\nchar s[305];\ninline void init(){\n\tgets(s+1);\n\tn=strlen(s+1);\n\tscanf(\"%d\",&m);\n}\n\nint dp[305][305][305],ans;\ninline void solve(){\n\tfor(int k=0;k<=m;++k)\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tfor(int j=n;j>=i;--j){\n\t\t\t\tint &f=dp[i][j][k];\n\t\t\t\tf=max(dp[i-1][j][k],dp[i][j+1][k]);\n\t\t\t\tif(s[i]==s[j])f=max(f,dp[i-1][j+1][k]+1);\n\t\t\t\telse if(k)f=max(f,dp[i-1][j+1][k-1]+1);\n\t\t\t\tans=max(ans,i==j?f*2-1:f*2);\n\t\t\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\tinit();\n\tsolve();\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate <class T> void chmax(T& x, T y) { if (x < y) x = y; }\nstring S;\nint dp[300][300][151];\nint recur(int i, int j, int k) {\n    if (dp[i][j][k] != -1) {\n        return dp[i][j][k];\n    } else if (i > j) {\n        return dp[i][j][k] = 0;\n    } else if (i == j) {\n        return dp[i][j][k] = 1;\n    } else if (S[i] == S[j]) {\n        return dp[i][j][k] = recur(i + 1, j - 1, k) + 2;\n    } else {\n        int ret = 0;\n        chmax(ret, recur(i + 1, j, k));\n        chmax(ret, recur(i, j - 1, k));\n        if (k > 0) chmax(ret, recur(i + 1, j - 1, k - 1) + 2);\n        return dp[i][j][k] = ret;\n    }\n}\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    cin >> S;\n    int K; cin >> K;\n    K = min(K, (int)S.size() / 2);\n    for (int i = 0; i < S.size(); i++) {\n        for (int j = 0; j < S.size(); j++) {\n            for (int k = 0; k <= K; k++) {\n                dp[i][j][k] = -1;\n            }\n        }\n    }\n    cout << recur(0, S.size() - 1, K) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstring s, t;\n\nconst int N = 301;\n\nint dp[N][N][N];\nint n;\n\nint f(int n1, int n2, int k) {\n    if (dp[n1][n2][k] != -1) {\n        return dp[n1][n2][k];\n    }\n    if (!n1 || !n2) {\n        return dp[n1][n2][k] = 0;\n    }\n    if (s[n1 - 1] == t[n2 - 1]) {\n        return dp[n1][n2][k] = f(n1 - 1, n2 - 1, k) + 1;\n    }\n    dp[n1][n2][k] = 0;\n    if (k && (s[n1 - 1] != s[n - n1] || s[n2 - 1] != s[n - n2]) && max(n1, n2) > (n + 1) / 2) {\n        dp[n1][n2][k] = f(n1 - 1, n2 - 1, k - 1) + 2;\n    }\n    dp[n1][n2][k] = max(dp[n1][n2][k], f(n1 - 1, n2, k));\n    dp[n1][n2][k] = max(dp[n1][n2][k], f(n1, n2 - 1, k));\n    return dp[n1][n2][k];\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int k;\n    cin >> s >> k;\n    t = s;\n    reverse(t.begin(), t.end());\n    n = s.length();\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            for (int l = 0; l < N; ++l) {\n                dp[i][j][l] = -1;\n            }\n        }\n    }\n    cout << f(n, n, k);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nint m;\nusing namespace std;\nconst int N = 302;\nstring s;\nint f[N][N][N];\nint a[N];\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> s;\n    cin >> m;\n    for (int i = 0; i < s.size(); i++) a[i] = s[i - 1] - 'a';\n    int n = s.size(); a[0] = -1; a[n + 1] = -1;\n    f[1][n][0] = 0;\n    for (int i = 1; i <= n; i++) {\n        for (int j = n; j >= i; j--) {\n            for (int k = 0; k <= m; k++) {\n                f[i + 1][j][k] = max(f[i + 1][j][k], f[i][j][k]);\n                f[i][j - 1][k] = max(f[i][j - 1][k], f[i][j][k]);\n                if (a[i] != a[j]) {\n                    f[i + 1][j - 1][k + 1] = max(f[i + 1][j - 1][k + 1], f[i][j][k] + 1);\n                }\n                else {\n                    f[i + 1][j - 1][k] = max(f[i + 1][j - 1][k], f[i][j][k] + 1);\n                }\n            }\n        }\n    }\n    int mx = 0;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            for (int k = 0; k <= m; k++) {\n                if (i <= j) mx = max(mx, f[i][j][k] * 2);\n                else\n                if (abs(i - j) == -2) mx = max(mx, (f[i][j][k] - 1) * 2 + 1);\n                else\n                if (abs(i - j) == -1) mx = max(mx, f[i][j][k] * 2);\n            }\n        }\n    }\n    cout << mx << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\nsolution:\n lps == lcs( s, s')\n\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n#define ull unsigned long long\n#define re register\n#define il inline\n#define inf 0x3f3f3f\n\nconst int maxn = 333;\n\nchar s[maxn];\nint f[maxn][maxn][maxn], k, n;\n\nint main() {\n  scanf(\"%s%d\", s + 1, &k);\n  n = strlen(s + 1);\n\n  for (int i = 1; i <= n; ++i)\n    f[i][i][0] = 1;\n\n  for (int l = 1; l <= n; ++l)\n    for (int i = 1; i + l <= n; ++i)\n      for (int p = 0, j = i + l; p <= k; ++p) {\n        f[i][j][p] = max(f[i + 1][j][p], f[i][j - 1][p]);\n\n        if (s[i] == s[j])\n          f[i][j][p] = max(f[i][j][p], f[i + 1][j - 1][p] + 2);\n\n        if (p)\n          f[i][j][p] = max(f[i][j][p], f[i + 1][j - 1][p - 1] + 2);\n      }\n\n  int ans = 0;\n  for (int i = 0; i <= k; i++)\n    ans = max(ans, f[1][n][i]);\n\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// IOI 2021\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define ends ' '\n#define die(x) return cout << x << endl, 0\n#define all(v) v.begin(), v.end()\n#define sz(x) (int)(x.size())\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) { cerr << ends << H; debug_out(T...); }\n#define debug(...) cerr << \"{\" << #__VA_ARGS__ << \"}:\", debug_out(__VA_ARGS__)\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst ll INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\n////////////////////////////////////////////////////////////////////\n\nconst int N = 3e2 + 2;\n\nint DP[N][N][N];\n\nint main() {\n\n\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\t\n\n\tstring s; cin >> s;\n\tint n = sz(s), k; cin >> k;\n\tfor (int l = n; l >= 1; l--) for (int r = l; r <= n; r++) for (int i = 0; i <= k; i++) {\n\t\tif (l == r) DP[l][r][i] = 1;\n\t\telse DP[l][r][i] = max(max(DP[l + 1][r][i], DP[l][r - 1][i]), max((i > 0) * (DP[l + 1][r - 1][i - 1] + 2), (s[l - 1] == s[r - 1]) * (DP[l + 1][r - 1][i] + 2)));\n\t}\n\tcout << DP[1][n][k] << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nconst int nax=307;\n\nint n, k;\nchar wcz[nax];\n\nint dp[nax][nax][nax];\n\nint wyn;\n\nvoid maxi(int &a, int b)\n{\n\ta=max(a, b);\n}\n\nint main()\n{\n\tscanf(\"%s%d\", wcz+1, &k);\n\tn=strlen(wcz+1);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j=n; j>i; j--)\n\t\t{\n\t\t\tfor (int l=0; l<=k; l++)\n\t\t\t{\n\t\t\t\tmaxi(dp[i][j][l], dp[i-1][j][l]);\n\t\t\t\tmaxi(dp[i][j][l], dp[i][j+1][l]);\n\t\t\t\tif (wcz[i]==wcz[j])\n\t\t\t\t\tmaxi(dp[i][j][l], dp[i-1][j+1][l]+1);\n\t\t\t\tif (l)\n\t\t\t\t\tmaxi(dp[i][j][l], dp[i-1][j+1][l-1]+1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=0; i<=n; i++)\n\t\tmaxi(wyn, dp[i][i+1][k]*2);\n\tfor (int i=0; i<n; i++)\n\t\tmaxi(wyn, dp[i][i+2][k]*2+1);\n\tprintf(\"%d\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, ans;\nchar s[305];\nint dp[305][305][305];\nint dfs(int l, int r, int x) {\n    if(l >= r) {\n        return r - l + 1;\n    }\n    if(dp[l][r][x] != -1) {\n        return dp[l][r][x];\n    }\n    int ret = max(dfs(l + 1, r, x), dfs(l, r - 1, x));\n    if(s[l] == s[r]) {\n        ret = max(ret, dfs(l + 1, r - 1, x) + 2);\n    } else if(x) {\n        ret = max(ret, dfs(l + 1, r - 1, x - 1) + 2);\n    }\n    return dp[l][r][x] = ret;\n}\nint main() {\n    memset(dp, -1, sizeof(dp)); \n    scanf(\"%s%d\", s + 1, &k);\n    n = strlen(s + 1);\n    for(int i = 1; i <= n; ++i) {\n        for(int j = i; j <= n; ++j) {\n            ans = max(ans, dfs(i, j, k));\n        }\n    } \n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(int x) { return 8*sizeof(int)-__builtin_clz(x); }\n\nnamespace std {\n    template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}};\n}\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\ntemplate <typename T> struct bounded_priority_queue {\n\tinline bounded_priority_queue(ui X) : A(X), B(0), s(0) {}\n\tinline void push(ui L, T V) { B = max(B, L); A[L].push(V); ++s; }\n\tinline const T &top() const { return A[B].front(); }\n\tinline void pop() { --s; A[B].pop(); while (B > 0 && A[B].empty()) --B; }\n\tinline bool empty() const { return A[B].empty(); }\n\tinline void clear() { s = B = 0; for (auto &a: A) a = queue<T>(); }\n\tinline ui size() const { return s; }\nprivate:\n\tvector<queue<T>> A; ui B; int s;\n};\n\n\n#endif\n// #include \"../l/mod.h\"\n\nclass D {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        string S; cin >> S;\n        int K; cin >> K;\n        string T = S;\n        reverse(T.begin(),T.end());\n        int N = S.size();\n        vector3<int> L(N+1,N+1,N+2,-1);\n        for (int i = 1; i <= N; ++i) {\n            L[0][i][0] = L[i][0][0] = 0;\n        }\n        L[0][0][0] = 0;\n\n        for (int i = 1; i <= N; ++i) {\n            for (int j = 1; j <= N; ++j) {\n                for (int k = 0; k <= N; ++k) {\n                    L[i][j][k] = max(L[i][j][k], L[i-1][j][k]);\n                    L[i][j][k] = max(L[i][j][k], L[i][j-1][k]);\n                    if (S[i-1] == T[j-1]) {\n                        L[i][j][k] = max(L[i][j][k], 1 + L[i-1][j-1][k]);\n                    } else if (L[i-1][j-1][k] >= 0) {\n                        L[i][j][k+1] = max(L[i][j][k+1], L[i-1][j-1][k]);\n                    }\n                }\n            }\n        }\n//        cerr << L;\n        int ans = 0;\n        for (int i = 0; i <= N; ++i) {\n            int pairs = min(K, i/2);\n//            cerr << L[N][N][i]  << ' ' <<  pairs << ' ' << K << endl;\n            ans = max(ans, L[N][N][i] + pairs + K);\n        }\n        cout << min(N, ans) << endl;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tD solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <ext/numeric>\nusing namespace std;\n#define sc(a) scanf(\"%d\", &a)\n#define sc2(a, b) scanf(\"%d%d\", &a, &b)\n#define sc3(a, b, c) scanf(\"%d%d%d\", &a, &b, &c)\n#define scs(a) scanf(\"%s\", a)\n#define pri(x) printf(\"%d\\n\", x)\n#define prie(x) printf(\"%d \", x)\n#define pris() printf(\"\\n\")\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define BUFF ios::sync_with_stdio(false)\n#define db(x) cerr << #x << \" == \" << x << endl\n#define power(a,x) __gnu_cxx::power(a, x)\n#define eps 1e-5\ntypedef long long int ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ii> vii;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst ld pi = acos(-1);\nconst int MOD = 1e9 + 7;\nstring s;\nint t;\nint dp[310][310][310];\nint main()\n{\n    cin>>s>>t;\n    int n=s.size();\n    for(int i=n-1;i>=0;i--)\n    {\n        for(int j=i;j<n;j++)\n        {\n            if(i+1==j)\n                dp[i][j][0]=1+(s[i]==s[j]);\n            for(int k=0;k<=t;k++)\n            {\n                if(i==j)\n                {\n                    dp[i][j][k]=1;\n                    continue;\n                }\n                if(i+1==j)\n                {\n                    if(k>0)\n                        dp[i][j][k]=2;\n                    continue;\n                }\n                int mx=0;\n                mx=max(mx,dp[i+1][j][k]);\n                mx=max(mx,dp[i][j-1][k]);\n                if(k>0)\n                    mx=max(mx,dp[i][j][k-1]);\n                if(s[i]==s[j])\n                    mx=max(mx,2+dp[i+1][j-1][k]);\n                if(k>0)\n                    mx=max(mx,2+dp[i+1][j-1][k-1]);\n                dp[i][j][k]=mx;\n            }\n        }\n    }\n    cout<<dp[0][n-1][t]<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <boost/multiprecision/cpp_int.hpp>\n//namespace mp = boost::multiprecision;\n\nusing namespace std;\n\nconst double PI = 3.14159265358979323846;\ntypedef long long ll;\nconst double EPS = 1e-9;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\ntypedef pair<ll, ll> P;\nconst ll INF = 10e17;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n#define ret() return 0;\n\ndouble equal(double a, double b) {\n    return fabs(a - b) < DBL_EPSILON;\n}\n\nstd::istream &operator>>(std::istream &in, set<int> &o) {\n    int a;\n    in >> a;\n    o.insert(a);\n    return in;\n}\n\nstd::istream &operator>>(std::istream &in, queue<int> &o) {\n    ll a;\n    in >> a;\n    o.push(a);\n    return in;\n}\n\nbool contain(set<int> &s, int a) { return s.find(a) != s.end(); }\n\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\n//const ll mod = 1e10;\n\ntypedef priority_queue<ll, vector<ll>, greater<ll> > PQ_ASK;\n\nint f(string &s, int l, int r, int k, vector<vector<vector<int>>> &memo) {\n    if (memo[l][r][k] != -1) return memo[l][r][k];\n\n    int ans = [&] {\n\n        if (l == r) return 1;\n        else if (l + 1 == r) {\n            if (s[l] == s[r] || 0 < k) return 2;\n            else return 1;\n        } else {\n            int ans = 0;\n            cmax(ans, f(s, l + 1, r, k, memo));\n            cmax(ans, f(s, l, r - 1, k, memo));\n\n            if (s[l] == s[r]) cmax(ans, f(s, l + 1, r - 1, k, memo) + 2);\n            else if (0 < k) cmax(ans, f(s, l + 1, r - 1, k - 1, memo) + 2);\n            return ans;\n        }\n\n    }();\n\n    return memo[l][r][k] = ans;\n}\n\nint main() {\n    string s;\n    int k;\n    cin >> s >> k;\n    int n = s.size();\n    vector<vector<vector<int>>> memo(n + 1, vector<vector<int>>(n + 1, vector<int>(n + 1, -1)));\n    cout << f(s, 0, n - 1, k, memo) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\nstring s,t;\nint dp[310][310][310] = {};\nint main(){\n\tint i,j,l,n,k;\n\tcin >> s >> k; n = s.size();\n\tfor(i=0;i<n;i++){\n\t\tt.push_back(s[n - 1 - i]);\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++){\n\t\t\tfor(l=0;l<=k;l++){\n\t\t\t\tif(s[i - 1]==t[j - 1]){\n\t\t\t\t\tdp[i][j][l] = dp[i - 1][j - 1][l] + 1;\n\t\t\t\t}else{\n\t\t\t\t\tint x = max(dp[i - 1][j][l],dp[i][j - 1][l]);\n\t\t\t\t\tif(l>0) x = max(x,dp[i - 1][j - 1][l - 1] + 1);\n\t\t\t\t\tdp[i][j][l] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(i=0;i<n;i++){\n\t\tif(n&1){\n\t\t\tans = max(ans,2*dp[i][n - 1 - i][k] + 1);\n\t\t}else{\n\t\t\tans = max(ans,2*dp[i][n - i][k]);\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...)\n#endif\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    string s;\n    int k;\n    cin >> s >> k;\n    int n = s.size();\n    int dp[n][n][k + 1] = {};\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i; j <= n - 1; j++) {\n            for (int l = 0; l <= k; l++) {\n                if (i == j) {\n                    dp[i][j][l] = 1;\n                } else if (i + 1 == j) {\n                    dp[i][j][l] = 2;\n                    if (l == 0 && s[i] != s[j]) {\n                        dp[i][j][l] = 1;\n                    }\n                } else {\n                    dp[i][j][l] = max(dp[i + 1][j][l], dp[i][j - 1][l]);\n                    // dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l] + 1);\n                    if (s[i] == s[j]) {\n                        dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l] + 2);\n                    }\n                    if (l != 0) {\n                        dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l - 1] + 2);\n                    }\n                }\n            }\n        }\n    }\n    cout << dp[0][n - 1][k] << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint mat[307][307][307];\n\nint main() {\n\tint kmx, n, ans;\n\tstring theo;\n\n    cin >> theo >> kmx;\n    n = theo.size();\n    theo = \"$\" + theo;\n\tans = 0;\n\n    for (int i(1); i <= n; i++) {\n    for (int j(1); i + j <= n; j++) {\n    for (int k(0); k <= kmx; k++) {\n    \tif (theo[i] == theo[n - j + 1])\n        \tmat[i][j][k] = mat[i - 1][j - 1][k] + 1;\n        if (k > 0)\n        \tmat[i][j][k] = max(mat[i][j][k], mat[i - 1][j - 1][k - 1] + 1);\n        mat[i][j][k] = max(mat[i][j][k], mat[i - 1][j][k]);\n        mat[i][j][k] = max(mat[i][j][k], mat[i][j - 1][k]); } } }\n\n    for (int i(1); i <= n; i++)\n    for (int j(0); j <= kmx; j++)\n    \tans = max(ans, 2 * mat[i][n - i][j]);\n    for (int i(1); i <= n; i++)\n    for (int j(0); j <= kmx; j++)\n        ans = max(ans, 2 * mat[i - 1][n - i][j] + 1);\n\n    cout << ans << endl;\n\n    return 0; }\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Azat Ismagilov\n */\n\n/**********.*****.**************************:-******-:*******************\n**********......:*****************+@%@*+#@@@+.****.***********************\n...------........-*+*********+%#####@@@##########*************************\n********:........----------%@#####################@@-...............------\n**********......:********@%#####@###################@#@=+***************::\n*********.:****--******%##@#####@#######################@*+***************\n********.*******:-**+@@####@#@@@#################@#########=**************\n*******-*********:*@@@######@###############################=*************\n*****--**********%%@##@########@#############################=:***********\n****.************+##################@#@@#####################@************\n***.*************%######################@@###################=***********-\n*-:**************=##########@@%%%%=%@=%=%=%@################@@**********.*\n.****************########%++***+++****+++=+===+++***+=%@######%*******:-**\n****************+#######%+*::::::::::::***********:::::**@@###%******.:***\n****************#######@%*:::::::::::::::*:*****:::::::::*@@##@*****.*****\n****************######@%+*:::::::-::::::::::::::::::::::::=@##%****-******\n.......-------:*######=::::::----------:::::::::::::::::::+###:**--*******\n............:==:%####=:::::----:-:::::::::::::::::::::::::=@##:-.:********\n************=@++*%##@::::*=%%%@@###@=***::::::::::::::::::=@#@*..*********\n************=**+@+@#*:::**+++%@#@###%@%%+*::*+=======*::::*##-:**.********\n*************:=%%:%*::::*+=%##%###=@@@%=*::*=%@@@%%@@#@%::+#@:****.*******\n:**************==:=:::--::::*++++=%@@@%*:--*%#@####@#=+***@@%@*****.******\n--**************:-*::--------::**+***:::---*+%%%%%%@@%+*::#*@%******.*****\n*:-************---*::::-----------::--:---::::+++++**:::::%*%********-:***\n**:.************++*:::::--------::**+------::::::::::::::*++**********--**\n****.**************::::::-----::**==:-------+*:::::---:::**************:-*\n*****.***********.*::::::::-:::***:*+@**::**=+*::::::::::****************-\n******.*:*%@######+::::::::::::::::::++++=******::::::::******************\n******:############*::::::::****::::::*+*:*:*:***::::::*******************\n******#############***::*:*:*+==@@##=======:*+***:::*:********************\n******#############:*+**********:*++**+**++=%=***:*::*********************\n.....##############::*++**************+***:*********###+******************\n***:##############@*:**+=***:::**++===++***********#####%.................\n*:*###############******++=+*:::::::*:::::*::***#########=****************\n**:################%*****++==++********::::*+++=##########+***************\n*:%##################******++++==+=++++++++++++@############**************\n######################@******+++++++++++++++++=%#############*************\n########################+++++++++++++++++++++==@#############@***********.\n#########################%+++++++++++++++++===%###############%********:-*\n########################@=#=++++++++++++====%@##################******-**/\n\n#include <bits/stdc++.h>\n\n#define int long long\n#define fs first\n#define sc second\n#define pb push_back\n#define ppb pop_back\n#define pf push_front\n#define ppf pop_front\n#define mp make_pair\n#define len(v) ((int)v.size())\n#define vc vector\n#define pr pair\n#define endd \"\\n\"; return 0;\n#define all(v) v.begin(), v.end()\n\nusing namespace std;\n\nconst int MAXN = 1e5;\nconst int INF = 1e18;\nconst int MOD = 1e9 + 7;\n\n\nint dp[601][301][301];\n\nclass TaskD {\npublic:\n    void solve(std::istream &in, std::ostream &out) {\n        string s;\n        in >> s;\n        string s1 = s;\n        reverse(all(s1));\n        int k;\n        in >> k;\n        int n = len(s);\n        for (int i = 0; i < n; i++) {\n            dp[0][i][0] = (s[i] == s1[0]);\n        }\n        for (int i = 0; i < n; i++) {\n            dp[0][0][i] = (s1[i] == s[0]);\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[0][i][j] = max(dp[0][i - 1][j], dp[0][i][j - 1]);\n                if (s[i] == s1[j]) {\n                    dp[0][i][j] = max(dp[0][i][j], dp[0][i - 1][j - 1] + 1);\n                }\n            }\n        }\n        for (int d = 1; d <= 2 * k; d++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    dp[d][i][j] = dp[d - 1][i][j];\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                dp[d][i][0] = 1;\n            }\n            for (int i = 0; i < n; i++) {\n                dp[d][0][i] = 1;\n            }\n            for (int i = 1; i < n; i++) {\n                for (int j = 1; j < n; j++) {\n                    dp[d][i][j] = max(dp[d][i - 1][j], dp[d][i][j - 1]);\n                    if (s[i] == s1[j]) {\n                        dp[d][i][j] = max(dp[d][i][j], dp[d][i - 1][j - 1] + 1);\n                    } else {\n                        dp[d][i][j] = max(dp[d][i][j], dp[d - 1][i - 1][j - 1] + 1);\n                    }\n                }\n            }\n        }\n        out << min(n, dp[2 * k][n - 1][n - 1]);\n    }\n};\n\n\nmain() {\n    TaskD solver;\n    std::istream &in(std::cin);\n    std::ostream &out(std::cout);\n    ios_base::sync_with_stdio(0);\n    in.tie(0);\n    solver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#define max(a,b) (a>b?a:b)\nint dp[305][305][305],mk,len;\nchar a[305];\nint main(){\n\tscanf(\"%s%d\",a+1,&mk);\n\tlen=strlen(a+1);\n\tfor(int i=1;i<=len;i++)\n\t\tfor(int j=i;j>=1;j--){\n\t\t\tif(i==j){for(int k=0;k<=mk;k++) dp[j][i][k]=1;continue;}\n\t\t\tfor(int k=0;k<=mk;k++)\n\t\t\t\tif(k) dp[j][i][k]=max(dp[j+1][i-1][k-1]+2,max(dp[j+1][i-1][k]+(a[i]==a[j])*2,max(dp[j+1][i][k],dp[j][i-1][k])));\n\t\t\t\telse dp[j][i][k]=max(dp[j+1][i-1][k]+(a[i]==a[j])*2,max(dp[j+1][i][k],dp[j][i-1][k]));\n\t\t}\n\tprintf(\"%d\\n\",dp[1][len][mk]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define dro first\n#define adg second.first\n#define mog second.second\n#define ll long long\nusing namespace std;\n\nconst int N = 500001;\n\nint n,r,pos,l,x,U,D,S;\n \nlong long ans;\nint K;\n\nstring s;\n\nint fix[100],fix1[100],A[100],B[100];\n\nint dp[301][301][301];\n\nint main(){\n    \n    cin>>s;\n    \n    n=s.size();\n    \n    cin>>K;\n    \n    for(int j=0;j<2;j++)\n    for(int l=0;l+j<n;l++){\n        int r = l+j;\n        if(l==r){\n            dp[l][r][0] = 1;\n            dp[l][r][1] = 1;\n            continue;\n        }\n\n        if(l+1==r){\n            dp[l][r][0] = 1;\n            if(s[l] == s[r]) dp[l][r][0] = 2;\n            dp[l][r][1] = 2;\n            dp[l][r][2] = 2;\n            continue;\n        }\n    }\n\n    for(int j=2;j<n;j++)\n    for(int l=0;l+j<n;l++)\n    for(int k=0;k<=min(l+j-l+1,K);k++){\n\n        int r = l+j;\n        dp[l][r][k] = max( dp[l+1][r][k], dp[l][r-1][k]);\n        //cout<<dp[l+1][r][k]<<\" \"<<l<<\" \"<<r<<\" \"<<k<<endl;\n        //cout<<dp[l][r-1][k]<<\" \"<<l<<\" \"<<r<<\" \"<<k<<endl;\n        if(s[l]==s[r])\n            dp[l][r][k] = max( dp[l][r][k], dp[l+1][r-1][k] + 2);\n        else {\n            if(k-1>=0)\n            dp[l][r][k] = max( dp[l][r][k], dp[l+1][r-1][k-1] + 2);\n        }\n\n        //cout<<dp[l][r][k]<<\" \"<<l<<\" \"<<r<<\" \"<<k<<endl;\n    }\n    \n    cout<<dp[0][n-1][K]<<endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nchar s[353];\nint k;\n\nint dp[2][353][353];  // dp[k][l][r] := s[l,r) k modified max pal subseq\n\nint main(){\n  scanf(\"%s%d\",s,&k);\n  int n = strlen(s);\n  REP(i,k+1){\n    REP(j,353)REP(k,353)dp[1][j][k] = 0;\n    REP(l,n+1){\n      REP(lef,n-l+1){\n        int rig = lef+l;\n        if(l<=1){\n          dp[1][lef][rig] = l;\n        }else{\n          CHMAX(dp[1][lef][rig], dp[1][lef+1][rig-1] + (s[lef]==s[rig-1]?2:0));\n          CHMAX(dp[1][lef][rig], dp[1][lef+1][rig]);\n          CHMAX(dp[1][lef][rig], dp[1][lef][rig-1]);\n          if(i>0)CHMAX(dp[1][lef][rig], dp[0][lef+1][rig-1] + 2);\n        }\n      }\n    }\n    // REP(i,n)REP(j,n+1)printf(\"%d%c\",dp[1][i][j],j==n?'\\n':' ');puts(\"\");\n    REP(j,353)REP(k,353)dp[0][j][k] = dp[1][j][k];\n  }\n  printf(\"%d\\n\",dp[0][0][n]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 305;\n\nchar s[MAXN];\n\nint dp[MAXN][MAXN][MAXN];\n\nvoid solve(){\n\tint n, k;\n\tscanf(\"%s%d\", &s[0], &k);\n\tn = strlen(s);\n\tREP(i, 0, n) {\n\t\tdp[i][i][0] = 1;\n\t}\n\tREPN(l, 0, k) {\n\t\tfor(int i = n - 1; i >= 0; i--) {\n\t\t\tif (l > 0) {\n\t\t\t\tdp[i][i][l] = dp[i][i][l - 1];\n\t\t\t}\n\t\t\tREP(j, i + 1, n) {\n\t\t\t\tdp[i][j][l] = max(dp[i + 1][j][l], dp[i][j - 1][l]);\n\t\t\t\tif (l > 0) {\n\t\t\t\t\tdp[i][j][l] = max(dp[i][j][l], dp[i][j][l - 1]);\n\t\t\t\t}\n\t\t\t\tif (s[i] == s[j]) {\n\t\t\t\t\tdp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l] + 2);\n\t\t\t\t} else if (l > 0) {\n\t\t\t\t\tdp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l - 1] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[0][n - 1][k]);\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n\nconst int N = 3e2 + 10;\n\nint len, k;\nint dp[N][N][N];\nchar s[N];\n\nint dfs(int L, int R, int p) {\n\tif (dp[L][R][p] != -1) return dp[L][R][p];\n\tif (L > R) return dp[L][R][p] = 0;\n\tif (L == R) return dp[L][R][p] = 1;\n\tdp[L][R][p] = std::max(dfs(L + 1, R, p), dfs(L, R - 1, p));\n\tif (s[L] == s[R]) dp[L][R][p] = std::max(dp[L][R][p], dfs(L + 1, R - 1, p) + 2);\n\tif (p) dp[L][R][p] = std::max(dp[L][R][p], dfs(L + 1, R - 1, p - 1) + 2);\n\treturn dp[L][R][p];\n}\n\nint main() {\n\tmemset(dp, -1, sizeof(dp));\n\tscanf(\" %s%d\", s + 1, &k), len = strlen(s + 1);\n\tprintf(\"%d\\n\", dfs(1, len, k));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nconst double EPS = 1e-10;\nconst ll INF = 100000000;\nconst ll MOD = 1000000007;\n\nstring str;\nint k;\nint dp[300][301][301];\n\nint main() {\n    cin >> str;\n    cin >> k;\n    int n = str.size();\n    int ans = 1;\n    rep(i,n) dp[i][1][0] = 1;\n    for (int j = 2; j <= n; j++) {\n        rep(i,n) {\n            for (int u = 0; u <= k; u++) {\n                if (str[i] == str[i+j-1]) {\n                    dp[i][j][u] = dp[i+1][j-2][u]+2;\n                } else {\n                    dp[i][j][u] = max(dp[i][j-1][u], dp[i+1][j-1][u]);\n                }\n                if (u >= 1) dp[i][j][u] = max(dp[i][j][u], dp[i+1][j-2][u-1]+2);\n                ans = max(ans, dp[i][j][u]);\n            }\n        }\n    }\n    cout << ans << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for((i)=1;(i)<=(n);(i)++)\nusing namespace std;\nstring st;\nint dp[305][305][305],n,m,i,j,k;\nint main(){\n\tcin>>st>>m;n=st.length();st=\" \"+st;\n\trep(i,n) dp[i][i][0]=1;\n\trep(i,n-1) if(st[i]==st[i+1]) dp[i][i+1][0]=2; else dp[i][i+1][1]=2;\n\tfor(i=n;i>=1;i--){\n\t\tfor(j=i+1;j<=n;j++){\n\t\t\tfor(k=0;k<=m;k++){\n\t\t\t\tdp[i][j][k]=max(dp[i+1][j][k],dp[i][j-1][k]);\n\t\t\t\tif(i+1<=j-1&&st[i]==st[j]) dp[i][j][k]=max(dp[i][j][k],dp[i+1][j-1][k]+2);\n\t\t\t\tif(i+1<=j-1&&k) dp[i][j][k]=max(dp[i][j][k],dp[i+1][j-1][k-1]+2);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(k=0;k<=m;k++) ans=max(ans,dp[1][n][k]);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 309\n#define MAXM 4000009\n#define MOD 1000000007\n#define INF 1000000009\n#define FOR(x,n) for(int x=0; x<n; x++)\n#define FOR1e(x,n) for(int x=1; x<=n; x++)\ntypedef pair<int, int> ii;\ntypedef long long ll;\n\nint dp[MAXN][MAXN][MAXN];\nchar w[MAXN];\n\nint compute(int l, int r, int k) {\n\tif (l == r) return 1;\n\tif (l > r) return 0;\n\n\tif (w[l] == w[r]) return compute(l+1, r-1, k) + 2;\n\tint &ans = dp[l][r][k];\n\tif (ans != -1) return ans;\n\n\tans = max(ans, compute(l+1, r, k));\n\tans = max(ans, compute(l, r-1, k));\n\tif (k > 0) ans = max(ans, compute(l+1, r-1, k-1) + 2);\n\treturn ans;\n}\nint main() {\n\tint k;\n\tscanf(\"%s %d\", w, &k);\n\tint n = strlen(w);\n\tmemset(dp, -1, sizeof(dp));\n\tcout << compute(0, n-1, k) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[305][305][305];\n\nint main(){\n  \n  string s;\n  int K;\n  \n  cin>>s>>K;\n  \n  memset(dp,-1,sizeof(dp));\n  \n  dp[0][s.size()-1][0]=0;\n  \n  int ans=0;\n  \n  for(int l=0;l<s.size();l++)\n    \n    for(int r=s.size()-1;r>=l;r--){\n\n      for(int k=0;k<=K;k++){\n\t\n\tif(dp[l][r][k]==-1) continue;\n\n\tif(l==r) ans=max(ans, dp[l][r][k]*2+1);\n\telse if(l+1==r){\n\t  ans=max(ans, dp[l][r][k]*2);\n\t  if(k<K) ans=max(ans, dp[l][r][k]*2+1);\n\t}\n\t\n\tif(s[l]==s[r]) dp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]+1);\n\t\n\tif(l==r) continue;\n\t\n\tdp[l+1][r-1][k+1]=max(dp[l+1][r-1][k+1], dp[l][r][k]+1);\n\tdp[l+1][r][k]=max(dp[l+1][r][k], dp[l][r][k]);\n\tdp[l][r-1][k]=max(dp[l][r-1][k], dp[l][r][k]);\n\tdp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]);\n      }\n    }  \n  \n  cout<<ans<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef double D;\nconst ll inf=(1ll<<61);\nconst ll mod=1e9+7;\nconst int MX=302;\nint n,k,dp[MX][MX][MX];\nstring s,t;\nint DP(int x,int y,int k){\n    if(k<0)return -MX*2;\n    if(x>y)return 0;\n    if(x==y)return 1;\n    int &ret=dp[x][y][k];if(ret!=-1)return ret;\n    ret=DP(x+1,y,k);\n    ret=max(ret,DP(x,y-1,k));\n    if(s[x]==s[y]){\n        ret=max(ret,DP(x+1,y-1,k)+2);\n    }\n    ret=max(ret,DP(x+1,y-1,k-1)+2);\n    return ret;\n}\nint main(){\n    cin>>s>>k;n=s.size();\n    memset(dp,-1,sizeof(dp));\n    cout<<DP(0,n-1,k)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Relive your past life.\n//Face your demons.\n//The past is never dead,it is not even past.\n//The memories are not only the key to the past but...also to the future.\n//coded in Rusty Lake\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\nstring s,t;\nint n,k,f[305][305][305],ans;\nint main(){\n\tcin>>s;\n\tn=s.size();\n\tcin>>k;\n\ts=\" \"+s;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=0;j<=k;++j)f[j][i][i]=1;\n\t}\n\tfor(int d=1;d<n;++d){\n\t\tfor(int r=d+1;r<=n;++r){\n\t\t\tint l=r-d;\n\t\t\tf[0][l][r]=max(f[0][l+1][r],f[0][l][r-1]);\n\t\t\tif(s[l]==s[r])f[0][l][r]=max(f[0][l][r],f[0][l+1][r-1]+2);\n\t\t}\n\t}\n\tans=f[0][1][n];\n\tfor(int _=1;_<=k;++_){\n\t\tfor(int d=1;d<n;++d){\n\t\t\tfor(int r=d+1;r<=n;++r){\n\t\t\t\tint l=r-d;\n\t\t\t\tf[_][l][r]=max(f[_][l+1][r],f[_][l][r-1]);\n\t\t\t\tif(s[l]==s[r])f[_][l][r]=max(f[_][l][r],f[_][l+1][r-1]+2);\n\t\t\t\telse f[_][l][r]=max(f[_][l][r],f[_-1][l+1][r-1]+2);\n\t\t\t}\n\t\t}\n\t\tans=max(ans,f[_][1][n]);\n\t}\n\tprintf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <iomanip>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n#define rep(i, n) for(ll i = 0; i < (n); i++)\n#define revrep(i, n) for(ll i = (n)-1; i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\nll max(ll a, ll b){return (a > b) ? a : b;}\nll min(ll a, ll b){return (a < b) ? a : b;}\nll max3(ll a, ll b, ll c){return max(a, max(b, c));};\nll min3(ll a, ll b, ll c){return min(a, min(b, c));};\nll max4(ll a, ll b, ll c, ll d){return max(max(a, b), min(c, d));};\nll min4(ll a, ll b, ll c, ll d){return min(min(a, b), min(c, d));};\nll max5(ll a, ll b, ll c, ll d, ll e){return max(max(a, b), max3(c, d, e));};\nll min5(ll a, ll b, ll c, ll d, ll e){return min(min(a, b), min3(c, d, e));};\n\nconst ll INFL = 1LL << 60;//10^18 = 2^60\nconst int INF = 1 << 30;//10^9\nll MOD = 1000000007;\n//ll MOD = 998244353;\n\nvector<ll> dy = {0, 0, 1, -1, 1, 1, -1, -1, 0};\nvector<ll> dx = {1, -1, 0, 0, 1, -1, 1, -1, 0};\n\n\nll pow_long(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2) res *= x;\n    x *= x;\n    k /= 2;\n  }\n  return res;\n}\nll pow_mod(ll x, ll k){\n  x %= MOD; x += MOD; x %= MOD;\n  ll res = 1;\n  while(k > 0){\n    if(k % 2){\n      res *= x; res %= MOD;\n    }\n    x *= x; x %= MOD;\n    k /= 2;\n  }\n  return res;\n}\n\nll inverse(ll x){return pow_mod(x, MOD - 2);};\n\nll gcd(ll a, ll b){\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\nll lcm(ll x, ll y){return x / gcd(x, y) * y;};\n\nll kai_mod(ll x){\n  if(x == 0) return 1;\n  return x * kai_mod(x-1) % MOD;\n}\n\n/*\n//コンビネーション\nconst int MAXcomb = 200010;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\n//facはn!,finvは1/n!\n//invは逆元\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAXcomb; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nll comb(int n, int k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    return fac[n] * finv[k] % MOD * finv[n-k] % MOD;\n}\n*/\n\nstring S;\nll K;\nll memo[310][310][310];//[)\nll solve(ll l, ll r, ll rest){\n  if(l > r) return -INFL;\n  if(l == r) return 0;\n  if(l + 1 == r) return 1;\n  if(memo[l][r][rest] != -1) return memo[l][r][rest];\n  ll res = max(solve(l, r-1, rest), solve(l+1, r, rest));\n  if(S[l] == S[r-1]){\n    res = max(res, solve(l+1, r-1, rest) + 2);\n  }else{\n    if(rest >= 1) res = max(res, solve(l+1, r-1, rest - 1) + 2);\n  }\n  return memo[l][r][rest] = res;\n}\n\nint main(){\n  cin >> S >> K;\n  rep(i, 310)rep(j, 310)rep(k, 310) memo[i][j][k] = -1;\n  cout << solve(0, S.size(), K) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nint m;\nusing namespace std;\nconst int N = 302;\nstring s;\nint f[N][N][N];\nint a[N];\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> s;\n    cin >> m;\n    for (int i = 0; i < s.size(); i++) a[i] = s[i - 1] - 'a';\n    int n = s.size(); a[0] = -1; a[n + 1] = -1;\n    f[1][n][0] = 0;\n    for (int i = 1; i <= n; i++) {\n        for (int j = n; j >= i; j--) {\n            for (int k = 0; k <= m; k++) {\n                f[i + 1][j][k] = max(f[i + 1][j][k], f[i][j][k]);\n                f[i][j - 1][k] = max(f[i][j - 1][k], f[i][j][k]);\n                if (a[i] != a[j]) {\n                    f[i + 1][j - 1][k + 1] = max(f[i + 1][j - 1][k + 1], f[i][j][k] + 1);\n                }\n                else {\n                    f[i + 1][j - 1][k] = max(f[i + 1][j - 1][k], f[i][j][k] + 1);\n                }\n            }\n        }\n    }\n    int mx = 0;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            for (int k = 0; k <= m; k++) {\n                if (i <= j) mx = max(mx, f[i][j][k] * 2);\n                else\n                if (abs(i - j) == 2) mx = max(mx, (f[i][j][k] - 1) * 2 + 1);\n                else\n                if (abs(i - j) == 1) mx = max(mx, f[i][j][k] * 2);\n            }\n        }\n    }\n    cout << mx << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 24.02.2018 15:11:31       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 303;\n\nint f[N][N][N];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  string s;\n  cin >> s;\n  int k;\n  cin >> k;\n  int n = (int) s.length();\n  for (int i = n - 1; i >= 0; i--) {\n    for (int j = i; j < n; j++) {\n      for (int p = 0; p <= k; p++) {\n        if (i == j) {\n          f[i][j][p] = 1;\n          continue;\n        }\n        if (i + 1 == j) {\n          f[i][j][p] = (s[i] == s[j] || p > 0) ? 2 : 1;\n          continue;\n        }\n        f[i][j][p] = max(f[i + 1][j][p], f[i][j - 1][p]);\n        if (s[i] == s[j]) {\n          f[i][j][p] = max(f[i][j][p], f[i + 1][j - 1][p] + 2);\n        }\n        if (p > 0) {\n          f[i][j][p] = max(f[i][j][p], f[i + 1][j - 1][p - 1] + 2);\n        }\n      }\n    }\n  }\n  cout << f[0][n - 1][k] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<int, int> par;\ntypedef pair<par, int> prr;\n#define x first\n#define y second\nint dp[305][305][305];\nint main(){\n    string S, T;\n    cin >> S;\n    T = S;\n    reverse(T.begin(), T.end());\n    int n = S.size();\n    S = \"a\" + S;\n    T = \"a\" + T;\n    int maxx;\n    scanf(\"%d\", &maxx);\n    for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= n; j++) {\n        for (int k = 0; k <= maxx; k++) {\n            dp[i][j][k] = max(dp[i][j - 1][k], dp[i - 1][j][k]);\n            if (S[i] == T[j]) dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + 1);\n            else {\n                if (k) dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k - 1] + 1);\n            }\n        }\n    }\n    int ans = 0;\n    for (int mid = 1; mid <= n; mid++) {\n        int a = mid;\n        int b = n - mid;\n        for (int i = 0; i <= maxx; i++) {\n            int tmp = dp[a][b][i] * 2;\n            ans = max(ans, tmp);\n        }\n    }\n    for (int mid = 1; mid <= n; mid++) {\n        int a = mid - 1;\n        int b = n - mid;\n        for (int i = 0; i <= maxx; i++) {\n            int tmp = dp[a][b][i] * 2 + 1;\n            ans = max(ans, tmp);\n        }\n    }\n\n    printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int INF = (int)1.01e9;\n\nconst int N = 310;\n\nint dp[N][N][N];\n\nvoid upd(int &x, int y) {\n    x = max(x, y);\n}\n\nint main() {\n#ifdef HOME\n    freopen(\"in\", \"r\", stdin);\n#endif\n\n    string s;\n    int k;\n    while (cin >> s >> k) {\n        int n = s.length();\n\n        memset(dp, -1, sizeof(dp));\n        dp[1][n][0] = 0;\n        for (int len = n - 1; len >= 0; len--) {\n            for (int i = 0; i + len <= n + 1; i++) {\n                int j = i + len;\n\n                for (int t = 0; t <= k; t++) {\n                    if (dp[i][j][t] == -1) continue;\n                    //if (s[i - 1] == s[j - 1] && t < k) {\n                    {\n                        int delta = 1 + (i != j);\n                        int cost = s[i - 1] != s[j - 1];\n                        if (t + cost <= k) {\n                            upd(dp[i + 1][j - 1][t + cost], dp[i][j][t] + delta);\n                        }\n                    }\n                    upd(dp[i + 1][j][t], dp[i][j][t]);\n                    upd(dp[i][j - 1][t], dp[i][j][t]);\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < N; i++) for (int j = 0; j < N; j++) for (int t = 0; t < N; t++) upd(ans, dp[i][j][t]);\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n#define rint register int\n#define gc() getchar()\ninline int read(rint ans = 0, rint sgn = ' ', rint ch = gc())\n{\n\tfor(; ch < '0' || ch > '9'; sgn = ch, ch = gc());\n\tfor(; ch >='0' && ch <='9';(ans*=10)+=ch-'0', ch = gc());\n\treturn sgn-'-'?ans:-ans;\n}\nchar T[305]; int n, K, f[305][305][305]; inline int Cmax(int &x, int v){x < v ? x = v : 0;}\nint main()\n{\n\tscanf(\"%s\",T+1), n = strlen(T+1), K = read();\n\tfor(rint i = 1, k; i <= n; i++) for(k = 0; k <= K; f[i][i][k] = 1, k++);\n\tfor(rint d = 2, l, r, k; d <= n; d++)\n\t\tfor(l = 1, r = d; r <= n; l++, r++)\n\t\t\tfor(k = 0; k <= K; k++)\n\t\t\t{\n\t\t\t\tCmax(f[l][r][k],f[l][r-1][k]);\n\t\t\t\tCmax(f[l][r][k],f[l+1][r][k]);\n\t\t\t\tT[l]==T[r] ? Cmax(f[l][r][k],f[l+1][r-1][k]+2) : 0;\n\t\t\t\tk ? Cmax(f[l][r][k],f[l+1][r-1][k-1]+2) : 0;\n\t\t\t\tk ? Cmax(f[l][r][k],f[l][r][k-1]) : 0;\n\t\t\t}\tprintf(\"%d\\n\",f[1][n][K]); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nstring s;\nlong long k;\n\nlong long dp[301][301][301];\nint n;\n\nint main()\n{\n    cin >> s;\n    cin >> k;\n    n = s.size();\n    long long as = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (i > 0) dp[i][i - 1][0] = 0;\n        dp[i][i][0] = 1;\n        as = max(as, 1LL);\n    }\n    for (int len = 2; len <= n; len++)\n    {\n        for (int i = 0; i + len - 1 < n; i++)\n        {\n            int j = i + len - 1;\n            for (int e = 0; e <= k; e++)\n            {\n                if (s[i] == s[j])\n                {\n                    dp[i][j][e] = max(dp[i][j][e], dp[i + 1][j - 1][e] + 2);\n                }\n                else\n                {\n                    if (e - 1 >= 0)\n                        dp[i][j][e] = max(dp[i][j][e], dp[i + 1][j - 1][e - 1] + 2);\n                }\n                dp[i][j][e] = max(dp[i][j][e], dp[i][j - 1][e]);\n                dp[i][j][e] = max(dp[i][j][e], dp[i + 1][j][e]);\n                as = max(as, dp[i][j][e]);\n            }\n        }\n    }\n    cout << as;\n}\n"
  },
  {
    "language": "C++",
    "code": "//In the name of Allah\n//In the name of the compassionate of the merciful\n//Ya Ali!\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntemplate<typename Type>\nusing ordered_multiset = tree<Type, null_type, less_equal<Type>, rb_tree_tag, tree_order_statistics_node_update> ;\n\ntypedef long long ll ;\ntypedef long double ld ;\n\n#define f first\n#define s second\n#define pb push_back\n#define pf push_front\n#define popb pop_back\n#define popf pop_front\n#define all(x) x.begin() , x.end()\n#define mp make_pair\n#define pll pair<ll,ll>\n#define pii pair<int,int>\n\n//ifstream fin(\"input.txt\");\n//ofstream fout(\"output.txt\");\n// fflush(stdout);\n\nconst ll maxn = 310 ;\nconst ll INF = 1e18 ;\n\nll mod = 1e9 + 7 , p1 = 999999929 , p2 = 999999937 ;\n\nll n , k , dp[maxn][maxn][maxn] ;\nstring s1 ;\n\nint main()\n{\nstd::ios::sync_with_stdio(0) ;\ncin.tie(0) ;\ncout.tie(0) ;\n\ncin >> s1 >> k ;\nn = s1.size() ;\n\nfor(int i = 0 ; i < n ; i ++)\n  for(int j = 0 ; j <= k ; j ++)\n    dp[i][i][j] = 1 ;\n\nfor(int r = 1 ; r < n ; r ++){\n for(int l = r-1 ; l >= 0 ; l --){\n  for(int co = 0 ; co <= k ; co ++){\n    dp[l][r][co] = max(dp[l][r][co] , dp[l+1][r][co]) ;\n    dp[l][r][co] = max(dp[l][r][co] , dp[l][r-1][co]) ;\n   if(r-l>1){\n    if(s1[l] == s1[r])dp[l][r][co] = max(dp[l][r][co] , dp[l+1][r-1][co]+2) ;\n    if(co > 0)dp[l][r][co] = max(dp[l][r][co] , dp[l+1][r-1][co-1]+2) ;\n   }\n   else{\n    if(s1[l] == s1[r])dp[l][r][co] = 2 ;\n    if(co>0)dp[l][r][co] = 2;\n   }\n  }\n }\n}\ncout << dp[0][n-1][k] ;\n return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nchar s[310];\nint n,k,F[310][310][310];\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tk=read();\n\tfor(int i=1;i<=n;i++) F[i][i][0]=1;\n\tfor(int i=1;i<n;i++)\n\t\tF[i][i+1][0]=(s[i]==s[i+1])*2;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int l=1;l+i-1<=n;l++)\n\t\t{\n\t\t\tint r=l+i-1;\n\t\t\tfor(int ks=0;ks<=k;ks++)\n\t\t\t{\n\t\t\t\tif(l>1) F[l-1][r][ks]=max(F[l-1][r][ks],F[l][r][ks]);\n\t\t\t\tif(l>1&&r<n) F[l-1][r+1][ks]=max(F[l-1][r+1][ks],F[l][r][ks]+(s[l-1]==s[r+1])*2);\n\t\t\t\tif(r<n) F[l][r+1][ks]=max(F[l][r+1][ks],F[l][r][ks]);\n\t\t\t\tif(l>1&&r<n) F[l-1][r+1][ks+1]=max(F[l-1][r+1][ks+1],F[l][r][ks]+2);\n\t\t\t}\n\t\t}\n\t}\n\tint Ans=0; for(int i=0;i<=k;i++) Ans=max(Ans,F[1][n][k]);\n\tcout << Ans << endl; return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[305][305][305];\n\nint main(){\n  \n  string s;\n  int K;\n  \n  cin>>s>>K;\n  \n  memset(dp,-1,sizeof(dp));\n  \n  dp[0][s.size()-1][0]=0;\n  \n  \n  \n  for(int l=0;l<s.size();l++)\n    \n    for(int r=s.size()-1;r>=l;r--){\n\n      for(int k=0;k<=K;k++){\n\t\n\tif(dp[l][r][k]==-1) continue;\n\n\tif(s[l]==s[r]){\n\t  if(l==r) dp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]+1);\n\t  else dp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]+2);\n\t}\n\t\n\tif(l==r) dp[l+1][r-1][k+1]=max(dp[l+1][r-1][k+1], dp[l][r][k]+1);\n\telse dp[l+1][r-1][k+1]=max(dp[l+1][r-1][k+1], dp[l][r][k]+2);\n\t\n\tdp[l+1][r][k]=max(dp[l+1][r][k], dp[l][r][k]);\n\tdp[l][r-1][k]=max(dp[l][r-1][k], dp[l][r][k]);\n\tdp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]);\n      }\n    }\n  \n  int ans=0;\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nstatic const int IINF = 1 << 30;\n\ntemplate <typename T> std::vector<T> vectors(std::size_t n, T val) {\n  return std::vector<T>(n, val);\n}\n\ntemplate <typename T, typename... Args>\nauto vectors(std::size_t n, Args... args) {\n  return std::vector<decltype(vectors<T>(args...))>(n, vectors<T>(args...));\n}\n\ntemplate <class T> inline bool chmax(T &a, const T &b) {\n  return (a < b) ? a = b, true : false;\n}\n\nint main() {\n  // Input\n  std::string S;\n  int K;\n  int N;\n  std::cin >> S;\n  std::cin >> K;\n  N = S.length();\n\n  // Initialization\n  // auto dp = vectors<int>(1 + N + 1, 1 + N + 1, 1 + K + 1, -IINF);\n  auto dp = vectors<int>(1 + N + 1, 1 + N + 1, 1 + K + 1, 0);\n\n  // Initial condition\n  // dp[0][0][0] = 0;\n\n  // DP main\n  for (int i = 0; i <= N; ++i) {\n    for (int j = 0; j <= N; ++j) {\n      for (int k = 0; k <= K; ++k) {\n        chmax(dp[i + 1][j][k], dp[i][j][k]);\n        chmax(dp[i][j + 1][k], dp[i][j][k]);\n        // chmax(dp[i + 1][j][k + 1], dp[i][j][k] + 1);\n        // chmax(dp[i][j + 1][k + 1], dp[i][j][k] + 1);\n        chmax(dp[i + 1][j + 1][k + 1], dp[i][j][k] + 1);\n        if (i < N and k < N and S[i] == S[N - j - 1])\n          chmax(dp[i + 1][j + 1][k], dp[i][j][k] + 1);\n      }\n    }\n  }\n\n  // Output\n  int res = -1;\n  // for (int k = 0; k <= K; ++k) {\n  for (int i = 0; i <= N; ++i)\n    chmax(res, 2 * dp[i][N - i][K]);\n  for (int i = 0; i < N; ++i)\n    chmax(res, 2 * dp[i][N - i - 1][K] + 1);\n  // }\n\n  std::cout << res << std::endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\ntypedef long long ll;\ninline void Fail(){printf(\"0\");exit(0);}\n\nconst int maxn=305;\nint n,lim,ans;\nchar c[maxn];\nstring s;\nint dp[maxn][maxn][maxn];\n\nint main(){\n\tscanf(\"%s%d\",c,&lim);\n\tlim*=2;\n\ts=c;n=s.size();\n\trep(i,n)rep(j,n)rep(k,lim+1){\n\t\tif(s[i]==s[n-j-1])dp[i][j][k]=(i>=1&&j>=1?dp[i-1][j-1][k]:0)+1;\n\t\tif(i>=1)dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k]);\n\t\tif(j>=1)dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k]);\n\t\tif(s[i]!=s[n-j-1]){\n\t\t\tif(k>=1)dp[i][j][k]=max((i>=1&&j>=1?dp[i-1][j-1][k-1]:0)+1,dp[i][j][k]);\n\t\t}\n//\t\tcout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<dp[i][j][k]<<endl;\n\t\tans=max(ans,dp[i][j][k]);\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n\n/*\nInput:\nabcabbabc\ncbabbacba\n\nttcodergraedcoctest\ntsetcocdeargredoctt\n3\natcodergr a ndcontest\ntsetnocdn a rgredocta\n3\n-----------------\nOutput:\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring S;\nint K, dp[330][330][660];\nint dfs(int l,int r,int k){\n  if(l>=S.length()||r<0)return 0;\n  if(dp[l][r][k]!=-1)return dp[l][r][k];\n  dp[l][r][k]=0;\n  if(S[l]==S[r])dp[l][r][k]=dfs(l+1,r-1,k)+1;\n  dp[l][r][k]=max(dp[l][r][k],dfs(l+1,r,k));\n  dp[l][r][k]=max(dp[l][r][k],dfs(l,r-1,k));\n  if(k>0)dp[l][r][k]=max(dp[l][r][k],dfs(l+1,r-1,k-1)+1);\n  return dp[l][r][k];\n}\nint main(){\n  for(int i=0;i<330;i++)for(int j=0;j<330;j++)for(int k=0;k<330;k++)dp[i][j][k]=-1;\n  cin>>S>>K;\n  cout<<dfs(0,S.length()-1,K*2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint n, K, dp[301][301][301];\nstring s;\n\nint rec(int i, int j, int k){\n\tint &res = dp[i][j][k];\n\tif(res >= 0) return res;\n\tres = 0;\n\t\n\tif(i > 0) res = max(res, rec(i - 1, j, k));\n\tif(j < n) res = max(res, rec(i, j + 1, k));\n\tif(i > 0 && j < n){\n\t\tint nk = k - (s[i - 1] != s[j]);\n\t\tif(nk >= 0) res = max(res, 1 + rec(i - 1, j + 1, nk));\n\t}\n\treturn res;\n}\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tcin >> s >> K;\n\tn = s.size();\n\tmemset(dp, -1, sizeof(dp));\n\tint ans = 0;\n\trep(i, n + 1) ans = max(ans, 2 * rec(i, i, K));\n\trep(i, n) ans = max(ans, 2 * rec(i, i + 1, K) + 1);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(),vec.end()\n#define mp make_pair\nusing namespace std;\nusing ll=long long;\nconst ll INF=1LL<<30;\nconst ll LINF=1LL<<60;\nconst double eps=1e-5;\nconst ll MOD=1000000007LL;\ntemplate<typename T>void chmin(T &a,T b){a=min(a,b);};\ntemplate<typename T>void chmax(T &a,T b){a=max(a,b);};\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint dp[310][310][310];\nint main(){\n    string s;cin>>s;\n    int n=s.length();\n    int K;cin>>K;\n    for(int i=0;i<=n;i++)for(int j=0;j<=n;j++)for(int k=0;k<=n;k++)dp[i][j][k]=-INF;\n    dp[0][0][0]=0;dp[0][1][0]=0;dp[1][0][0]=0;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            for(int k=0;k<=K;k++){\n                chmax(dp[i][j][k],dp[i-1][j][k]);\n                chmax(dp[i][j][k],dp[i][j-1][k]);\n                if(s[i-1]==s[n-j]){\n                    chmax(dp[i][j][k],dp[i-1][j-1][k]+1);\n                }\n                if(k)chmax(dp[i][j][k],dp[i-1][j-1][k-1]+1);\n            }\n        }\n    }\n    int ans=0;\n    for(int i=1;i<n;i++){\n        int j=n-i;\n        for(int k=0;k<=K;k++){\n            chmax(ans,dp[i][j][k]*2);\n        }\n    }\n    if(n%2){\n        for(int i=1;i<n-1;i++){\n            int j=n-i-1;\n            for(int k=0;k<=K;k++){\n                chmax(ans,dp[i][j][k]*2+1);\n            }\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define READ() \t    freopen(\"in.txt\",\"r\",stdin)\n#define WRITE()     freopen(\"out.txt\",\"w\",stdout)\n#define sf(n) \t    scanf(\"%d\",&n)\n#define sl(x)       scanf(\"%I64d\",&x)\n#define lsf(n) \t    scanf(\"%lld\", &n)\n#define pb(n) \t    push_back(n)\n#define mem(x,y)    memset(x,y,sizeof(x))\n#define D(x)      \tcout << #x << \" = \" << x << endl\n#define CHKRTE\t\tassert(false)\n#define YOLO        cout << \"YOLO\" << endl\n#define NL\t\t\tprintf(\"\\n\")\n#define EPS \t    1e-10\n#define INF         INT_MAX\n#define MAX         INT_MAX\n#define MOD         1000000007\n#define LL          long long\n#define endl        \"\\n\"\n#define pi          2.0*acos(0.0)\n#define cnd         tree[idx]\n#define lnd         tree[left]\n#define rnd         tree[right]\n#define callLeft    left,st,mid\n#define callRight   right,mid+1,ed\n\nstring s;\nint len;\nint k;\n\nint dp[301][301][301];\n\nint rec(int i,int j,int k)\n{\n    if(i == j)return 1;\n    if(i > j)return 0;\n\n    if(dp[i][j][k] != -1)return dp[i][j][k];\n\n    int ret = 0;\n\n    if(s[i] == s[j])\n    {\n        ret = max(ret,(rec(i+1,j-1,k)+2));\n    }\n    else\n    {\n        ret = max(ret,(rec(i,j-1,k)));\n        ret = max(ret,(rec(i+1,j,k)));\n\n        if(k-1 >= 0)\n        {\n            ret = max(ret,(rec(i+1,j-1,k-1)+2));\n        }\n    }\n\n    dp[i][j][k] = ret;\n    return ret;\n}\n\nint main()\n{\n//\tios_base::sync_with_stdio(false);\n//    cin.tie(0); /// use \"\\n\" instead of endl\n\n/**\n#ifndef ONLINE_JUDGE\n    READ();\n    WRITE();\n#endif\n**/\n\n#ifdef JAMILPC\n//\tREAD();\n//\tWRITE();\n\n//    int t;\n//    cin >> t;\n//    while(t--)\n//    {\n#endif\n\n    cin >> s >> k;\n\n    mem(dp,-1);\n    cout << rec(0,s.size()-1,k) << endl;\n\n#ifdef JAMILPC\n//\t}\n#endif\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define X first\n#define Y second\n#define ld long double \n#define int long long \nusing namespace std;\n\nconst int N = 333;\n\nint dp[N][N][N] ; \n\nint32_t main()\n{\n\tios::sync_with_stdio(0), cin.tie(0);\n\tstring s ; \n\tcin >> s ;\n\tint n = s.size() ; \n\tint _k ;\n\tcin >> _k ; \n\tfor(int i = 0 ; i < n ; i ++ ) for(int j = 0 ; j <= _k ; j ++ ) dp[i][i+1][j] = 1 ; \n\tfor(int l = 2 ; l <= n ; l ++ ) for(int i = 0 ; i + l <= n ; i ++ ) for(int k = 0 ; k <= _k ; k ++ ) \n\t{\n\t\tint j = i + l ;\n\t\tdp[i][j][k] = max(dp[i+1][j][k],dp[i][j-1][k]) ; \n\t\tif(s[i]==s[j-1]) dp[i][j][k] = max(2+dp[i+1][j-1][k],dp[i][j][k]) ; \n\t\telse if(k) dp[i][j][k] = max(dp[i][j][k],2+dp[i+1][j-1][k-1]) ; \n\t}\n\tcout << dp[0][n][_k] << endl ; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\tstring s; cin >> s;\n\tint n = s.size();\n\tint K; cin >> K;\n\tvector<vector<vector<int> > > dp(n, vector<vector<int> >(n, vector<int>(K+1, 0)));\n\tfor (int i = 0; i < n; ++i) {\n\t\tdp[i][i][0] = 1;\n\t\tif (i < n-1) {\n\t\t\tif (s[i] == s[i+1]) dp[i][i+1][0] = 2;\n\t\t\telse if (K > 0) dp[i][i+1][1] = 2;\n\t\t}\n\t}\n\tfor (int k = 0; k < K+1; ++k) {\n\t\tfor (int x = 1; x < n; ++x) {\n\t\t\tfor (int i = 0; i < n-x; ++i) {\n\t\t\t\tint j = i+x;\n\t\t\t\tif (k > 0) dp[i][j][k] = max(dp[i][j][k], dp[i][j][k-1]);\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i+1][j][k]);\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k]);\n\t\t\t\tif (s[i] == s[j] && x > 1) dp[i][j][k] = max(dp[i][j][k], dp[i+1][j-1][k] + 2);\n\t\t\t\telse if (k > 0 && x > 1) dp[i][j][k] = max(dp[i][j][k], dp[i+1][j-1][k-1] + 2);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][n-1][K] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nstring S;\nint K;\nint dp[310][310][310] = {{{0}}};\nint main(){\n\tcin >> S >> K;\n\tint N = S.size();\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<=K;j++){\n\t\t\tdp[i][1][j] = 1;\n\t\t}\n\t}\n\tfor(int j=2;j<=N;j++){\n\t\tfor(int i=0;i<=N-j;i++){\n\t\t\tfor(int x=0;x<=K;x++){\n\t\t\t\tif(S[i]==S[i+j-1]) dp[i][j][x] = max(dp[i][j][x],dp[i+1][j-2][x]+2);\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j][x+1] = max(dp[i][j][x+1],dp[i+1][j-2][x]+2);\n\t\t\t\t\tdp[i][j][x] = max(dp[i][j][x],max(dp[i][j-1][x],dp[i+1][j-1][x]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][N][K] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\nusing namespace std;\n\nconst int MAXN = 300;\nconst int INF = 1000 * 1000 * 1000;\n\nint dp[MAXN + 1][MAXN + 1][MAXN + 1];\n\nvoid upd(int &x, int y) {\n    x = max(x, y);\n}\n\nint main() {\n    //cin.tie(0), ios::sync_with_stdio(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n\n    string s;\n    cin >> s;\n    int n = (int)s.size();\n    int K;\n    cin >> K;\n\n    for (int i = 0; i <= K; i++) {\n        for (int j = 0; j <= n; j++) {\n            for (int k = 0; k <= n; k++) {\n                dp[i][j][k] = -INF;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        dp[0][i][i] = 1;\n        if (i + 1 < n) {\n            if (s[i] == s[i + 1]) {\n                dp[0][i][i + 1] = 2;\n            } else {\n                dp[0][i][i + 1] = 1;\n                dp[1][i][i + 1] = 2;\n            }\n        }\n    }\n    for (int len = 3; len <= n; len++) {\n        for (int k = 0; k <= K; k++) {\n            for (int l = 0; l + len - 1 < n; l++) {\n                int r = l + len - 1;\n                upd(dp[k][l][r], dp[k][l + 1][r]);\n                upd(dp[k][l][r], dp[k][l][r - 1]);\n                if (s[l] == s[r]) {\n                    upd(dp[k][l][r], dp[k][l + 1][r - 1] + 2);\n                }\n                if (k > 0) {\n                    upd(dp[k][l][r], max(dp[k - 1][l + 1][r - 1], dp[k - 1][l + 1][r - 1]) + 2);\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for (int k = 0; k <= K; k++) {\n        ans = max(ans, dp[k][0][n - 1]);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n#define int ll\n//#define int ll\n//#define char ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(4) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int N = 333;\nconst int oo = 1e9 + 10;\nint dp[N][N][N];\n\n\nvoid smain() {\n\n    fori (i, N) {\n        fori (j, N) {\n            fori (k, N) {\n                dp[i][j][k] = oo;\n            }\n        }\n    }\n\n    string s;\n    cin >> s;\n    int k;\n    cin >> k;\n    int n = s.size();\n    string t = s;\n    reverse(ALL(t));\n\n    dp[0][0][0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            for (int len = 0; len < n; ++len) {\n                inmin(dp[i + 1][j][len], dp[i][j][len]);\n                inmin(dp[i][j + 1][len], dp[i][j][len]);\n                if (s[i] == t[j])\n                    inmin(dp[i + 1][j + 1][len + 1], dp[i][j][len]);\n                else {\n                    inmin(dp[i + 1][j + 1][len + 1], dp[i][j][len] + 1);\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    fori (i, n + 1) {\n        fori (j, n + 1) {\n            fori (len, n + 1) {\n                if (dp[i][j][len] <= k * 2) {\n                    inmax(ans, len);\n                }\n            }\n        }\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\n#define max(a,b) ((a)>(b)?(a):(b))\nconst int maxn=305;\nchar S[maxn];\nint dp[2][maxn][maxn],n,m,o,ans;\nint main() {\n\tscanf(\"%s\",S+1);n=strlen(S+1);scanf(\"%d\",&m);\n\tfor(re int p=0;p<=m;++p,o^=1) {\n\t\tfor(re int i=1;i<=n;i++) dp[o^1][i][i]=1;\n\t\tfor(re int l=2;l<=n;++l) \n\t\t\tfor(re int i=1,j=i+l-1;j<=n;++i,++j) {\n\t\t\t\tdp[o^1][i][j]=max(dp[o^1][i][j-1],dp[o^1][i+1][j]);\n\t\t\t\tif(S[i]==S[j]) dp[o^1][i][j]=(dp[o^1][i][j],dp[o^1][i+1][j-1]+2);\n\t\t\t\tif(p) dp[o^1][i][j]=max(dp[o^1][i][j],dp[o][i+1][j-1]+2);\n\t\t\t}\n\t\tans=max(ans,dp[o^1][1][n]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing ull = unsigned long long;\nusing namespace std;\nconst int INF = 1e5;\nconst int MOD = 1e9 + 7;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\n#define pb push_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define P pair<int, int>\n#define V vector<int>\n//#define S set<int>\n#define itn int\nbool dbg = false;\nstring S;\nint K;\n\nitn memo[333][333][333];\nitn f(itn l, int r, int k) {\n    if (memo[l][r][k] != 0)\n        return memo[l][r][k];\n    if (k < 0)\n        return INF * -1;\n    if (l == r)\n        return 1;\n    if (l > r)\n        return INF * -1;\n    int ret = 0;\n    chmax(ret, f(l + 1, r, k));\n    chmax(ret, f(l, r - 1, k));\n    if (S[l] == S[r])\n        chmax(ret, f(l + 1, r - 1, k) + 2);\n    else\n        chmax(ret, f(l + 1, r - 1, k - 1) + 2);\n    //cerr << l + 1 << \" \" << r + 1 << \" \" << k << \" \" << ret << endl;\n    memo[l][r][k] = ret;\n    return ret;\n}\n\nvoid solve() {\n    itn N = S.size();\n    cout << f(0, N - 1, K) << endl;\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cin >> S >> K;\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nchar str[310];\nint dp[310][310][310];\n\nint main ()\n{\n//    freopen (\"file.in\", \"r\", stdin);\n\n    fgets (str + 1, 310, stdin);\n\n    int n = strlen (str + 1) - 1, k;\n    scanf (\"%d\", &k);\n\n    int ma = 1;\n\n    for (int lg = 1; lg <= n; ++lg)\n        for (int i = 1; i + lg - 1 <= n; ++i)\n            for (int h = 0; h <= k; ++h)\n            {\n                int j = i + lg - 1;\n\n                if (i == j) dp[i][j][h] = 1;\n                else\n                {\n                    dp[i][j][h] = max (max (dp[i + 1][j][h], dp[i][j - 1][h]), dp[i + 1][j - 1][h] + 2 * (str[i] == str[j]));\n\n                    if (h > 0)\n                        dp[i][j][h] = max (dp[i][j][h], dp[i + 1][j - 1][h - 1] + 2);\n\n                    ma = max (ma, dp[i][j][h]);\n                }\n            }\n\n    printf (\"%d\\n\", ma);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nshort dp[301][301][301];\nchar in[310];\nvoid upd(short &x, short y) {\n\tif (x < y) x = y;\n}\nint main() {\n\tint n, k;\n\tscanf(\"%s%d\", in+1, &k);\n\tn = strlen(in+1);\n\tfor (int i = 1; i <= n; i++) for (int j = 0; j <= k; j++) dp[i][i][0] = 1;\n\tfor (int d = 1; d <= n; d++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = i + d;\n\t\t\tfor (int t = 0; t <= k; t++) {\n\t\t\t\tupd(dp[i][j][t], dp[i + 1][j][t]);\n\t\t\t\tupd(dp[i][j][t], dp[i][j - 1][t]);\n\t\t\t}\n\t\t\tif (in[i] == in[j]) {\n\t\t\t\tfor (int t = 0; t <= k; t++) upd(dp[i][j][t], dp[i + 1][j - 1][t] + 2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int t = 1; t <= k; t++) upd(dp[i][j][t], dp[i + 1][j - 1][t-1] + 2);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[1][n][k]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define vi vector<int>\n#define vvi vector<vi>\n#define vs vector<string>\n#define pb push_back\n#define P pair<int,int>\n#define vp vector<P>\n#define PP pair<int,P>\n#define vpp vector<PP>\n#define fi first\n#define se second\n#define INF 1e9\n#define MOD 1000000007\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REPR(i,n) for(int i=n;i>=0;i--)\n#define FOR(i,m,n) for(int i=m;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nint dp[310][310][310];\nstring st;\nint dfs(int l,int r,int x){\n    if(r<l){\n        return 0;\n    }\n    if(l==r){\n        return 1;\n    }\n    if(dp[l][r][x]!=-1){\n        return dp[l][r][x];\n    }\n    int res=max(dfs(l+1,r,x),dfs(l,r-1,x));\n    if(st[l]==st[r]){\n        res=max(res,dfs(l+1,r-1,x)+2);\n    }\n    if(x)res=max(res,dfs(l+1,r-1,x-1)+2);\n    return dp[l][r][x]=res;\n}\nint main(){\n    cin>>st;\n    int k;\n    cin>>k;\n    REP(i,300){\n        REP(j,300){\n            REP(k,300){\n                dp[i][j][k]=-1;\n            }\n        }\n    }\n    cout<<dfs(0,st.size()-1,k)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<string>\n\nusing namespace std;\ntypedef long long LL;\n\nconst int maxn=310;\n\nint DP[maxn][maxn][maxn],v;\nchar str[maxn];\n\nint Cal()\n{\n    int len=strlen(str);\n    memset(DP,0,sizeof(DP));\n    for(int i=0;i<len;i++) DP[i][i][0]=1;\n    for(int i=len-2;i>=0;i--)\n        for(int j=i+1;j<len;j++)\n             for(int k=0;k<=v;k++)\n             {\n        if(str[j]==str[i]) DP[i][j][k]=DP[i+1][j-1][k]+2;\n        else\n        {\n            DP[i][j][k]=max(DP[i+1][j][k],DP[i][j-1][k]);\n            if(k)  DP[i][j][k]=max(DP[i+1][j-1][k-1]+2,DP[i][j][k]);\n        }\n             }\n    int ans=0;\n    for(int i=0;i<=v;i++) ans=max(ans,DP[0][len-1][i]);\n    return ans;\n}\n\nint main()\n{\n    scanf(\"%s\",&str);\n    scanf(\"%d\",&v);\n    printf(\"%d\",Cal());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 305;\nchar s[N];\nint n, K;\nint f[N][N][N];\nint Dp(int l, int r, int x) {\n\tif (l > r) return 0;\n\tif (l == r) return 1;\n\tint &ans = f[l][r][x];\n\tif (~ ans) return ans;\n\tif (s[l] == s[r]) return ans = 2 + Dp(l+1, r-1, x);\n\tans = Dp(l+1, r, x);\n\tans = max(ans, Dp(l, r-1, x));\n\tif (x) ans = max(ans, 2 + Dp(l+1, r-1, x-1));\n\treturn ans;\n}\nint main() {\n\tscanf(\"%s\", s+1);\n\tn = strlen(s+1);\n\tcin >> K;\n\tmemset(f, -1, sizeof f);\n\tcout << Dp(1, n, K) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define pb push_back\nusing namespace std;\nint n, X, dp[301][301][301];\nstring s;\n\nint main(){ios_base::sync_with_stdio(false);\n    cin>>s>>X;n=s.size();    \n    for (int i=0; i<n; i++)dp[0][i][i]=1;\n\tfor (int x=0; x<=X; x++)\n\t\tfor (int k=1; k<n; k++)\n\t\t\tfor (int l=0, r=k; l+k<n; l++, r=l+k)\n\t\t\t\tdp[x][l][r]=max(max(dp[x][l][r-1], dp[x][l+1][r]),\n\t\t\t\t\t\t\tdp[max(x-min(1,abs(s[l]-s[r])), 0)][l+1][r-1]+\n\t\t\t\t\t\t\t2*min(1, (min(1, x)+(1-min(1,abs(s[l]-s[r]))))));\n    cout<<dp[x][0][n-1]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/// Containers Start\n#include <iostream>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <utility>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <cstdlib>\n#include <iterator>\n#include <algorithm>\n/// C Header Files\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <math.h>\n#include <ctime>\n#include <cstring>\n#include<random>\n/// Containers End\n\n\nusing namespace std;\n\n\n/// Math Start\n#define PI                    acos(-1.0)\n#define Pi                    3.141592653589793\n#define EPS (1e-7)\n#define INF (0x3f3f3f3f)\n/// Math End\n\n\n/// Extra Start\n#define nn                    '\\n'\n#define pb                    push_back\n#define SS                    stringstream\n#define ull                   unsigned long long\n#define mod                   1000000007\n#define SIZE                  2000001\n#define _cin                  ios_base::sync_with_stdio(0);  cin.tie(0);\n#define sz(a)                 int((a).size())\n#define space                 \" \"\n#define all(x)                (x).begin(), (x).end()\n#define rall(x)               (x).rbegin(), (x).rend()\n#define Ignore                cin.ignore()\n#define StringToInt           if ( ! (istringstream(s) >> n) ) n = 0;\n#define SORT(c) sort(all((c)))\n#define RSORT(c) sort(rall((c)))\n/// Extra End\n\n\n/// Functions Start\ntemplate<class T>\nT Multiply(T a, T b) { return a * b; }\n\ntemplate<class T>\nT larger(T a, T b) { return (a > b ? a : b); }\n\ntemplate<class T>\nT smaller(T a, T b) { return (a < b ? a : b); }\n\ntemplate<class T>\nT gcd(T a, T b) {\n    if (b == 0)return a;\n    return gcd(b, a % b);\n}\n\ntemplate<class T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n\ntemplate<class T>\nstring converter(T n) {\n    SS x;\n    x << n;\n    return x.str();\n}\n\n#define rep(i, n) for(int i = 0;i < n;i++)\n#define FOR(i, a, b) for(int i=(a);i<=(b);i++)\n#define FORD(i, a, b) for(int i=(a);i>=(b);i--)\n#define FORA(arr) for(auto &i:arr)\n#define Cin(a)     cin >>a;\n#define Cin2(a, b)        cin>>a>>b;\n#define Cin3(a, b, c)        cin>>a>>b>>c;\n#define Cin4(a, b, c, d)   cin>>a>>b>>c>>d;\n#define Cini(a)        int a; cin>>a;\n#define Cinii(a, b)        int a,b; cin>>a>>b;\n#define Cins(s)         string s; cin >> s;\n#define Cinc(c)         char c; cin >> c;\n/// Functions End\n\n\n/// Array Start\n#define SET(a)                memset( a, -1,    sizeof a )\n#define CLR(a)                memset( a,  0,    sizeof a )\n#define MEM(a, val)            memset( a,  val,  sizeof(a) )\n/// Array End\n\n\n/// Debug Start\n#define deb(x) cout << #x << \": \" << x << endl\n#define deb2(x, y) cout << #x << \": \" << x << '\\t' << #y << \": \" << y << endl\n#define deb3(x, y, z) cout << #x << \": \" << x << '\\t' << #y << \": \" << y << '\\t' << #z << \": \" << z << end\n/// Debug End\n\n\n/// TypeDef Start\ntypedef long long int ll;\ntypedef map<string, int> msi;\ntypedef map<int, int> mii;\ntypedef map<ll, ll> mll;\ntypedef map<char, int> mci;\ntypedef map<int, string> mis;\ntypedef pair<int, int> pii;\ntypedef pair<string, int> psi;\ntypedef pair<string, string> pss;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<char> vc;\ntypedef vector<bool> vb;\ntypedef vector<pii> vii;\n/// TypeDef End\n\n\n/****************** Geometry *****************/\n\ntemplate<typename T>\ninline T PointDistanceHorVer(T x1, T y1, T x2, T y2) { return abs(x1 - x2) + abs(y1 - y2); }\n\ntemplate<typename T>\ninline T PointDistanceDiagonally(T x1, T y1, T x2, T y2) { return sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)); }\n\ntemplate<typename T>\ninline T PointDistanceMinimum(T x1, T y1, T x2, T y2) {\n    T tmp1 = abs(x1 - x2);\n    T tmp2 = abs(y1 - y2);\n    T tmp3 = abs(tmp1 - tmp2);\n    T tmp4 = min(tmp1, tmp2);\n    return tmp3 + tmp4;\n}\n\ntemplate<typename T>\ninline T PointDistance3D(T x1, T y1, T z1, T x2, T y2, T z2) {\n    return sqrt(pow((x2 - x1), 2.0) + pow((y2 - y1), 2.0) + pow((z2 - z1), 2.0));\n}\n\ntemplate<typename T>\ninline T Cube(T a) { return a * a * a; }\n\ntemplate<typename T>\ninline T RectengularPrism(T a, T b, T c) { return a * b * c; }\n\ntemplate<typename T>\ninline T Pyramid(T base, T height) { return (1 / 3) * base * height; }\n\ntemplate<typename T>\ninline T Ellipsoid(T r1, T r2, T r3) { return (4 / 3) * PI * r1 * r2 * r3; }\n\ntemplate<typename T>\ninline T IrregualarPrism(T base, T height) { return base * height; }\n\ntemplate<typename T>\ninline T Sphere(T radius) { return (4 / 3) * PI * radius * radius * radius; }\n\ntemplate<typename T>\ninline T CylinderB(T base, T height) { return base * height; } // base and height\ntemplate<typename T>\ninline T CylinderR(T radius, T height) { return PI * radius * radius * height; } // radius and height\ntemplate<typename T>\ninline T Cone(T radius, T base, T height) { return (1 / 3) * PI * radius * radius * height; }\n\n/**>>>>>>>>>>>>>>>>>>> END <<<<<<<<<<<<<<<<<<**/\n\n\n///topcoder template\n\n//\n//class classname {\n//public:\n//\n//    int methodname(){\n//      return 0;\n//    }\n//\n//\n//};\n\n\n\nint c[300];\n\n\nint LCSLength(string s1, int i, int size_s1, string s2, int j, int size_s2) {\n\n    // 終了条件\n    if (i >= size_s1 || j >= size_s2) return 0;\n\n        // 一致する場合は両配列のインデックスを +1 だけ進める\n    else if (s1[i] == s2[j]) {\n        c[i] = 1;\n        return 1 + LCSLength(s1, i + 1, size_s1, s2, j + 1, size_s2);\n    }\n\n        // 一致しない場合は部分問題として扱う\n    else return max(LCSLength(s1, i + 1, size_s1, s2, j, size_s2), LCSLength(s1, i, size_s1, s2, j + 1, size_s2));\n}\n\n\nint main(void) {\n    Cins(s);\n    Cini(k);\n    deb(s);\n\n\n    string s2 = s;\n    reverse(s2.begin(), s2.end());\n    deb(s2);\n    int myl =LCSLength(s, 0, s.length(), s2, 0, s2.length());\n\n    cout << (( myl + k>s.length() )? s.length() :myl + k ) << endl;\n\n\n\n\n\n    return 0;\n\n\n}\n\n\n\n//\n//int getsum(ll n, int digi) {\n//    int sum = 0;\n//\n//    for (int j = 0; j < digi; j++) {\n//        sum += n % 10;\n//        n /= 10;\n//\n//    }\n//\n//    return sum;\n//}\n//\n//\n//int main(void) {\n//    long long N;\n//    cin >> N;\n//    int digi = 0;\n//    rep(i, 30) {\n//        if (N < pow((double) 10, i)) {\n//            digi = i;\n//            break;//iが桁数\n//        }\n//    }\n//\n//\n//\n//    int mymax = 0;\n//    ll tenp = 1;\n//    rep(i, digi) {\n//        if(i!=0) mymax = max(getsum((N / tenp - 1) * tenp + (tenp - 1), digi), mymax);\n//        else mymax = getsum(N,digi);\n////        deb((N / tenp - 1) * tenp + (tenp - 1));\n////        deb(i);\n////        deb(tenp);\n//        tenp *= 10;\n//\n//    }\n//\n//    cout << mymax << endl;\n//\n//    return 0;\n//}\n\n\n\n\n//\n//int A, B;\n//int d[2000000000 + 5];\n//\n//int dfs(int x, int k) {\n//\n//\n//    if (x > 1 && d[x - 1] == 0) {\n//        d[x - 1] = dfs(x - 1, k);\n//    }\n//    if (x > 1 && x % k == 0 && d[x / k] == 0) {\n//        d[x / k] = dfs(x / k, k);\n//    }\n//\n//    return x > 1 ? (x % k == 0 ? min(A + d[x - 1], B + d[x / k]) : A + d[x - 1]) : 0;\n//}\n//\n//int main(void) {\n//    Cinii(n, k);\n//    Cin(A);\n//    Cin(B);\n//    cout << dfs(n, k) << endl;\n//    return 0;\n//}\n\n\n\n\n// codeforces A\n//\n//int main(void) {\n//    Cinii(n, d);\n//    vector<int> a;\n//    rep(i, n) {\n//        Cini(p);\n//        a.pb(p);\n//    }\n//    SORT(a);\n//    int count = 0;\n//    int mymin = INF;\n//    for (auto i = a.begin(), end = a.end(); i < end; i++) {\n//        vector<int> b = a;\n//        for (auto j:b) {\n//            if (abs(*i - j) > d) { count++; a.erase(i); end--;}\n//        }\n//        mymin = min(mymin, count);\n//    }\n//    cout << mymin << endl;\n//    return 0;\n//}\n//\n//\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\n#define PB push_back\n#define MP make_pair\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\n\nconst int MOD = 1e9+7;\nconst int INF = 1e9;\nconst int MAX_N = 300;\n\nint dp[MAX_N+1][MAX_N+1];\n\nint main() {\n  string s, t, res = \"\";\n  int N, K;\n  cin >> s >> K;\n  N = s.length();\n  t = s;\n  reverse(t.begin(), t.end());\n  // cout << s << endl;\n  // cout << t << endl;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      if (s[i]==t[j]) {\n        dp[i+1][j+1] = dp[i][j]+1;\n      } else {\n        dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j]);\n      }\n    }\n  }\n\n  int x = N, y = N;\n  vi x_nums, y_nums;\n  string tmp = \"\";\n  while (x!=0 && y!=0) {\n    if (dp[x-1][y] == dp[x][y]) {\n      x--;\n      x_nums.PB(x);\n    } else if (dp[x][y-1] == dp[x][y]) {\n      y--;\n      // y_nums.PB(x);\n    } else {\n      // cout << x << endl;\n      x--; y--;\n      tmp.PB(s[x]);\n    }\n  }\n  for (int i = 0; i < x_nums.size(); i++) {\n    for (int j = 0; j < x_nums.size(); j++) {\n      if (x_nums[i] == N-x_nums[j]-1 && K > 0) {\n        K--;\n        dp[N][N] += 2;\n      }\n    }\n  }\n\n  reverse(tmp.begin(), tmp.end());\n  // cout << tmp << endl;\n\n  cout << dp[N][N] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define REP(i,n) for(int i=0,_n=(int)(n);i<_n;++i)\n#define ALL(v) (v).begin(),(v).end()\n#define CLR(t,v) memset(t,(v),sizeof(t))\ntemplate<class T1,class T2>ostream& operator<<(ostream& os,const pair<T1,T2>&a){return os<<\"(\"<<a.first<<\",\"<<a.second<< \")\";}\ntemplate<class T>void pv(T a,T b){for(T i=a;i!=b;++i)cout<<(*i)<<\" \";cout<<endl;}\ntemplate<class T>void chmin(T&a,const T&b){if(a>b)a=b;}\ntemplate<class T>void chmax(T&a,const T&b){if(a<b)a=b;}\n\n\nconst int INF = 1001001001;\nint dp[303][303][303];\n\nint main2() {\n  string s;\n  cin >> s;\n  int N = (int)s.size();\n  int K; cin >> K;\n  REP(i, N+1) REP(j, N+1) REP(k, N+1) dp[i][j][k] = -INF;\n  REP(i, N) dp[i][i][0] = 0;\n  REP(i, N) dp[i][i+1][0] = 1;\n  for (int d = 2; d <= N; d++) {\n    for (int i = 0; i + d <= N; i++) {\n      for (int k = 0; k <= N; k++) {\n        int j = i + d;\n        chmax(dp[i][j][k], dp[i+1][j][k]);\n        chmax(dp[i][j][k], dp[i][j-1][k]);\n        if (s[i] == s[j-1]) {\n          chmax(dp[i][j][k], dp[i+1][j-1][k] + 2);\n        } else {\n          chmax(dp[i][j][k+1], dp[i+1][j-1][k] + 2);\n        }\n      }\n    }\n  }\n  int ans = 0;\n  REP(i, N) for (int j = i + 1; j <= N; j++) REP(k, K+1) chmax(ans, dp[i][j][k]);\n  cout << ans << endl;\n  return 0;\n}\n\nint main() {\n  for (;!cin.eof();cin>>ws)\n    main2();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nconst int maxn = 305;\nint d[maxn][maxn][maxn];\n\nvoid uax(int& a, int b) {\n  a = max(a, b);\n}\n\nsigned main() {\n#ifdef LOCAL\n  assert(freopen(\"d.in\", \"r\", stdin));\n#endif\n  string s;\n  int k;\n  cin >> s >> k;\n  int n = (int) s.size();\n  string a = s;\n  string b = s;\n  reverse(b.begin(), b.end());\n  for (int i = 0; i <= (int) a.size(); ++i) {\n    for (int j = 0; j <= (int) b.size(); ++j) {\n      for (int q = 0; q <= k; ++q) {\n        uax(d[i + 1][j][q], d[i][j][q]);\n        uax(d[i][j + 1][q], d[i][j][q]);\n        if (i < (int) a.size() && j < (int) b.size()) {\n          uax(d[i + 1][j + 1][q + (a[i] != b[j])], d[i][j][q] + 1);\n        }\n      }\n    }\n  }\n  int res = 0;\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j <= k; ++j) {\n      uax(res, 2 * d[i][n - i - 1][j] + 1);\n      uax(res, 2 * d[i][n - i][j]);\n    }\n  }\n  cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint n,m,i,j,k,hh,ans,f[302][302][302];\nchar s[1010];\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tscanf(\"%d\",&m);\n\tmemset(f,210,sizeof(f));\n\tf[0][n+1][0]=0;\n\tfor(i=1;i<=n;i++){\n\t\tf[i][n+1][0]=0;\n\t for(j=n;j>=i;j--)\n\t  for(k=0;k<=m;k++){\n\t \tf[i][j][k]=max(f[i-1][j][k],f[i][j+1][k]);\n\t \tif(s[i]==s[j]){\n\t\t   f[i][j][k]=f[i-1][j+1][k]+1;\n\t\t   if(i==j)ans=max(ans,f[i][j][k]*2-1);\n\t\t    else ans=max(ans,f[i][j][k]*2);\n\t}\n\t \t else if(k){\n\t\t   f[i][j][k]=max(f[i][j][k],f[i-1][j+1][k-1]+1);\n\t\t   hh=f[i-1][j+1][k-1]+1;\n\t\t   hh*=2;\n\t\t   if(i==j)hh--;\n\t\t   ans=max(ans,hh);\n\t}\n\t \t//ans=max(ans,f[i][j][k]);\n\t }\n  }\n    printf(\"%d\",ans);\n}\n/*\n最后的lcs中l<r的部分确定下来，l>r的部分肯定是跟前者对称的（如果有更优的话那前面一部分肯定也会选更优的） \n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cstdio>\n#include <cstring>\n#include <math.h>\n#include <bitset>\n#include <time.h>\n#include <set>\n#include <algorithm>\n#define MODD 1000000007\n#define ll long long\nusing namespace std;\n\n\nstring S;\n\n\n\n\nint Solve(int p1,int p2,int K) {\n    \n    if (p1 == p2) {\n        return 1;\n    }\n    \n    if (p1 > p2) {\n        \n        return 0;\n        \n    }\n    \n    //printf(\"%d %d\\n\",p1,p2);\n    \n    int ans = max(Solve(p1+1,p2,K),\n                  Solve(p1,p2-1,K));\n    \n    \n    if (S[p1]==S[p2] || K > 0)\n        ans = max(ans,2+Solve(p1+1,p2-1,K-(S[p1]!=S[p2])));\n    \n    return ans;\n    \n}\n\nint dp[333][333][333];\n\nint Solve(int Kmax) {\n    \n    \n    for(int L=0;L<=S.size();L++) {\n        \n        for(int p1=0;p1+L-1<=S.size()-1;p1++) {\n            int p2 = p1+L-1;\n            \n            \n            \n            for(int K=0;K<=Kmax;K++) {\n                \n                if (p1 == p2) {\n                    dp[p1][p2][K]=1;\n                    continue;\n                }\n                \n                if (p1 > p2) {\n                    dp[p1][p2][K]=0;\n                    continue;\n                }\n                \n                int ans = max(dp[p1+1][p2][K],dp[p1][p2-1][K]);\n                \n                if (S[p1]==S[p2] || K > 0)\n                    ans = max(ans,2+dp[p1+1][p2-1][K-(S[p1]!=S[p2])]);\n                \n                \n                dp[p1][p2][K]=ans;\n\n            }\n            \n            \n        }\n        \n    }\n    \n    return dp[0][S.size()-1][Kmax];\n    \n}\n\n\nint main() {\n    int K;\n    cin>>S>>K;\n    \n    cout << Solve(K) << endl;\n    \n    //cout << Solve(0, S.size()-1,K) << endl;\n    \n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n//\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//\nconstexpr ll MOD=1e9+7;\n//constexpr ll MOD=998244353;\n//constexpr ll MOD=10000000;\n//constexpr ll MOD=1e5;\nconstexpr ll MAX=3e6;\nconstexpr ll INF=(1ll<<60);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate<typename T>\nstruct Segment_tree{\n    ll N;\n    T mem;\n    vector<T> node;\n    Segment_tree(vector<T> &X,T m):mem(m){\n        ll sz=X.size();\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mem);\n        rep(i,0,sz) node[N-1+i]=X[i];\n        per(i,N-2,0){\n            node[i]=Compare(node[i*2+1],node[i*2+2]);\n        }\n    }\n    T Compare(T &A,T &B){\n        return std::max(A,B);\n    }\n    void update(ll X,T val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=Compare(node[X*2+1],node[X*2+2]);\n        }\n    }\n    T Query(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mem;\n        if(a<=l&&r<=b) return node[now];\n        auto vl=Query(a,b,now*2+1,l,(l+r)/2),vr=Query(a,b,now*2+2,(l+r)/2,r);\n        return Compare(vl,vr);\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,int a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nvoid comp(vi &A){\n    std::map<ll,ll> mem;\n    rep(i,0,A.size()) mem[A[i]]=0;\n    ll cnt=0;\n    for(auto &p:mem) p.second=cnt++;\n    rep(i,0,A.size()) A[i]=mem[A[i]];\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    string S; cin>>S;\n    ll K,N=S.size(); cin>>K;\n    string T=S; reverse(ALL(T));\n    vector<vii> dp(N+1,vii(N+1,vi(K+1,INF)));\n    ll ans=0;\n    REP(i,0,K) dp[0][0][i]=0;\n    vii mem(26);\n    rep(i,0,N) mem[T[i]-'a'].pb(i+1);\n    rep(i,0,N){\n        REP(j,0,N){\n            REP(k,0,K) dp[i+1][j][k]=dp[i][j][k];\n        }\n        rep(j,0,N){\n            REP(k,0,K){\n                if(dp[i][j][k]==INF) continue;\n                ll X=disup(mem[S[i]-'a'],dp[i][j][k]);\n                if(X<mem[S[i]-'a'].size()){\n                    ll Y=mem[S[i]-'a'][X];\n                    if(Y<=N/2&&i+1<=N/2){\n                        dp[i+1][j+2][k]=std::min(dp[i+1][j+2][k],Y);\n                    }\n                    else if(i+1<N+1-Y||i+1==N/2){\n                        dp[i+1][j+1][k]=std::min(dp[i+1][j+1][k],dp[i][j][k]);\n                    }\n                }\n                ll Y=dp[i][j][k]-1;\n                if(K==k) continue;\n                if(Y<=N/2&&i+1<=N/2){\n                    dp[i+1][j+2][k+1]=std::min(dp[i+1][j+2][k+1],Y);\n                }\n                else if(i+1<N+1-Y){\n                    dp[i+1][j+1][k+1]=std::min(dp[i+1][j+1][k+1],dp[i][j][k]);\n                }\n            }\n        }\n        REP(j,0,N){\n            REP(k,1,K){\n                dp[i+1][j][k]=std::min(dp[i+1][j][k],dp[i+1][j][k-1]);\n                if(dp[i+1][j][k]!=INF) ans=std::max(ans,j);\n            }\n            if(dp[i+1][j][0]!=INF) ans=std::max(ans,j);\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define snd second\n#define pb(a) push_back(a)\n#define mp(a, b) std::make_pair(a, b)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\nconst int oo = 0x3f3f3f3f;\n\nstring procStatus() {\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\n\ntemplate <typename T> T read(T& x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    for(;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    return x *= f;\n}\n\nconst int N = 300;\n\nint n, k;\nchar S[N + 5];\nint dp[N + 5][N + 5][N + 5];\n\nint main() {\n#ifdef Wearry\n    freopen(\"in\", \"r\", stdin);\n    freopen(\"out\", \"w\", stdout);\n#endif\n\n    scanf(\"%s\", S + 1);\n    read(k), n = strlen(S + 1);\n\n    if(n == 1) return !puts(\"1\");\n\n    for (int i = 1; i <= n; ++ i) dp[i][i][0] = 1, dp[i][i+1][S[i] != S[i+1]] = 2;\n    for (int l = 2; l <= n; ++ l) {\n        for (int i = 1; i + l - 1 <= n; ++ i) {\n            int j = i + l - 1;\n\n            for (int t = 0; t <= k; ++ t) {\n                chkmax(dp[i][j][t], dp[i+1][j][t]);\n                chkmax(dp[i][j][t], dp[i][j-1][t]);\n\n                if(i<j-1) \n                    chkmax(dp[i][j][t], dp[i+1][j-1][t] + (S[i] == S[j]) *2);\n                if(t) \n                    chkmax(dp[i][j][t], dp[i+1][j-1][t-1] + 2);\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i <= k; ++ i) {\n        chkmax(ans, dp[1][n][i]);\n    }\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ull  unsigned long long\n#define pb push_back\n#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int N = 350;\nint dp[N][N][N];\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    string s;\n    cin >> s;\n    int k;\n    cin >> k;\n    int ans = 0;\n    int n = s.length();\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= n; j++){\n            for (int l = 0; l <= k; l++){\n                int p1 = i - 1;\n                int p2 = n - j;\n                if (s[p1] == s[p2]){\n                    dp[i][j][l] = dp[i - 1][j - 1][l] + 1;\n                }\n                dp[i][j][l] = max({dp[i][j][l], dp[i - 1][j][l], dp[i][j - 1][l]});\n                dp[i][j][l] = max(dp[i][j][l], dp[i - 1][j - 1][l]);\n                if (l != 0) dp[i][j][l] = max(dp[i][j][l], dp[i - 1][j - 1][l - 1] + 1);\n                if (i + j < n) ans = max(ans, 1 + 2 * dp[i][j][l]);\n                if (i + j <= n) ans = max(ans, 2 * dp[i][j][l]);\n                if (i + j <= n + 1) ans = max(ans, 2 * dp[i][j][l] - 1);\n            }\n        }\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#undef _DEBUG\n//#pragma GCC optimize(\"Ofast\")\n//不動小数点の計算高速化\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace std::chrono;\n#define int long long //todo 消したら動かない intの代わりにsignedを使う\n#define ll long long\nauto start_time = system_clock::now();\nauto past_time = system_clock::now();\n\n#define debugName(VariableName) # VariableName\n//最大引数がN\n#define over2(o1, o2, name, ...) name\n#define over3(o1, o2, o3, name, ...) name\n#define over4(o1, o2, o3, o4, name, ...) name\n#define over5(o1, o2, o3, o4, o5, name, ...) name\n#define over6(o1, o2, o3, o4, o5, o6, name, ...) name\n#define over7(o1, o2, o3, o4, o5, o6, o7, name, ...) name\n#define over8(o1, o2, o3, o4, o5, o6, o7, o8, name, ...) name\n#define over9(o1, o2, o3, o4, o5, o6, o7, o8, o9, name, ...) name\n#define over10(o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, name, ...) name\n\n\n/*@formatter:off*/\n//[-n, n)にアクセスできる\n//また、外部関数resizeに渡せる\n//sizeは[-n, n)でnを返す\ntemplate<class T> class mvec {    vector<T> v;    int n;public:    mvec() : n(0), v(0) {}    mvec(int n) : n(n), v(n * 2) {}    mvec(int n, T val) : n(n), v(n * 2, val) {}    auto &operator[](int i) { return v[i + n]; }    auto size() { return n; }    void resize(int sn) {        assert(n == 0);        n = sn;        v.resize(sn * 2);    }    auto begin() { return v.begin(); }    auto rbegin() { return v.rbegin(); }    auto end() { return v.end(); }    auto rend() { return v.rend(); }};\n//[]でboolは参照を返さないため特殊化が必要\ntemplate<> struct mvec<bool> {    vector<bool> v;    int n;    mvec() : n(0), v(0) {}    mvec(int n) : n(n), v(n * 2) {}    mvec(int n, bool val) : n(n), v(n * 2, val) {}    auto operator[](int i) { return v[i + n]; }    auto size() { return v.size(); }    void resize(int sn) {        assert(n == 0);        n = sn;        v.resize(sn * 2);    }    auto begin() { return v.begin(); }    auto rbegin() { return v.rbegin(); }    auto end() { return v.end(); }    auto rend() { return v.rend(); }};\ntemplate<class T>ostream &operator<<(ostream &os, mvec<T>& a) {    int spa = 3;    for(auto&&v : a){        spa = max(spa,(int)(to_string(v).size())+1);    }    int n = (int)a.size();    os<<endl;    for (int i = -n; i < n; i++){        int need = spa - ((int)to_string(i).size());        if(i==-n){            need -= min(need,spa - ((int)to_string(a[i]).size()));        }        while(need--){            os<<\" \";        }        os<<i;    }    os<<endl;    int i=-n;    for(auto&&v : a){        int need = spa - ((int)to_string(v).size());        if(i==-n){            need -= min(need,spa - ((int)to_string(i).size()));        }        while(need--){            os<<\" \";        }        os<<v;        i++;    }    return os;}\n#define mv mvec\n#define MV mvec\nusing mvi = mvec<ll>;\nusing mvb = mvec<bool>;\nusing mvs = mvec<string>;\nusing mvd = mvec<double>;\nusing mvc = mvec<char>;\n\n#define mvvt0(t) mvec<mvec<t>>\n#define mvvt1(t,a) mvec<mvec<t>>a\n#define mvvt2(t,a, b) mvec<mvec<t>>a(b)\n#define mvvt3(t,a, b, c) mvec<mvec<t>> a(b,mvec<t>(c))\n#define mvvt4(t,a, b, c, d) mvec<mvec<t>> a(b,mvec<t>(c,d))\n#define mvvi(...) over4(__VA_ARGS__,mvvt4,mvvt3,mvvt2 ,mvvt1,mvvt0)(ll,__VA_ARGS__)\n\ntemplate<typename T> mvec<T> make_mv(size_t a) { return mvec<T>(a); }\ntemplate<typename T, typename... Ts> auto make_mv(size_t a, Ts... ts) {return mvec<decltype(make_mv<T>(ts...))>(a, make_mv<T>(ts...));}\n#define mvni(name, ...) auto name = make_mv<ll>(__VA_ARGS__)\n\n\n#ifdef _DEBUG\nstring message;\n//https://marycore.jp/prog/cpp/class-extension-methods/ 違うかも\ntemplate<class T, class A = std::allocator<T>> struct debtor : std::vector<T, A> {\n    using std::vector<T, A>::vector;\n    template<class U> int deb_v(U a, int v) { return v; }\n    template<class U> int deb_v(debtor<U> &a, int v = 0) {cerr << a.size() << \" \";return deb_v(a.at(0), v + 1);}\n    template<class U> void deb_o(U a) { cerr << a << \" \"; }\n    template<class U> void deb_o(debtor<U> &a) {for (int i = 0; i < min((int) a.size(), 15ll); i++) { deb_o(a[i]); }if ((int) a.size() > 15) { cerr << \"...\"; }cerr << endl;}\n    typename std::vector<T>::reference operator[](typename std::vector<T>::size_type n) {        if (n < 0 || n >= (int) this->size()) {            int siz = (int) this->size();            cerr << \"vector size = \";            int dim = deb_v((*this));            cerr << endl;            cerr << \"out index at  \" << n << endl;            cerr << endl;            if (dim <= 2) { deb_o((*this)); }            exit(0);        }return this->at(n);}\n};\n//#define vector debtor\n//区間削除は出来ない\ntemplate<class T> struct my_pbds_tree {    set<T> s;    auto begin() { return s.begin(); }    auto end() { return s.end(); }    auto rbegin() { return s.rbegin(); }    auto rend() { return s.rend(); }    auto empty() { return s.empty(); }    auto size() { return s.size(); }    void clear() { s.clear(); }    template<class U> void insert(U v) { s.insert(v); }template<class U> void operator+=(U v) { insert(v); }    template<class F> auto erase(F v) { return s.erase(v); }    template<class U> auto find(U v) { return s.find(v); }    template<class U> auto lower_bound(U v) { return s.lower_bound(v); }    template<class U> auto upper_bound(U v) { return s.upper_bound(v); }    auto find_by_order(ll k) {        auto it = s.begin();        for (ll i = 0; i < k; i++)it++;        return it;    }    auto order_of_key(ll v) {        auto it = s.begin();        ll i=0;        for (;it != s.end() && *it <v ; i++)it++;        return i;    }};\n#define pbds(T) my_pbds_tree<T>\n//gp_hash_tableでcountを使えないようにするため\ntemplate<class T,class U> struct my_unordered_map{    unordered_map<T,U> m;    my_unordered_map(){};    auto begin(){        return m.begin();    }    auto end(){return m.end();}    auto cbegin(){return m.cbegin();}    auto cend(){return m.cend();}    template<class V>auto erase(V v){return m.erase(v);}    void clear(){m.clear();}    /*countは gp_hash_tableに存在しない*/    /*!= m.end()*/    template<class V>auto find(V v){return m.find(v);}    template<class V>auto & operator [](V n) { return m[n] ;}};\n#define unordered_map my_unordered_map\n#define umapi unordered_map<ll,ll>\n#define umapp unordered_map<P,ll>\n#define umapu unordered_map<uint64_t,ll>\n#define umapip unordered_map<ll,P>\n\n#else\n#define endl '\\n'\n//umapはunorderd_mapになる\n//umapiはgp_hash_table\n\n//find_by_order(k) k番目のイテレーター\n//order_of_key(k)  k以上が前から何番目か\n#define pbds(U) __gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>\n\n#define umapi __gnu_pbds::gp_hash_table<ll,ll,xorshift>\n#define umapp __gnu_pbds::gp_hash_table<P,ll,xorshift>\n#define umapu __gnu_pbds::gp_hash_table<uint64_t,ll,xorshift>\n#define umapip __gnu_pbds::gp_hash_table<ll,P,xorshift>\n\n#endif\n/*@formatter:on*/\nstruct xorshift {\n    static uint64_t splitmix64(uint64_t x) {\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n    size_t operator()(std::pair<ll, ll> x) const {\n        ll v = ((x.first) << 32) | x.second;\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(v + FIXED_RANDOM);\n    }\n};\n/*@formatter:off*/\ntemplate<class U, class L> void operator+=(__gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update> &s, L v) { s.insert(v); }\n//衝突対策\n#define ws ws_\n\ntemplate<class A, class B, class C>struct T2 {A f;B s;C t;T2() { f = 0, s = 0, t = 0; }T2(A f, B s, C t) : f(f), s(s), t(t) {}bool operator<(const T2 &r) const {        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;        /*return f != r.f ? f > r.f : s != r.s ?n s > r.s : t > r.t; 大きい順 */   }    bool operator>(const T2 &r) const {        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;        /*return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順 */   }    bool operator==(const T2 &r) const {        return f == r.f && s == r.s && t == r.t;    }    bool operator!=(const T2 &r) const {        return f != r.f || s != r.s || t != r.t;    }};\ntemplate<class A, class B, class C, class D> struct F2 {    A a;    B b;    C c;    D d;    F2() { a = 0, b = 0, c = 0, d = 0; }    F2(A a, B b, C c, D d) : a(a), b(b), c(c), d(d) {}    bool operator<(const F2 &r) const {        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;    /*    return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;*/    }    bool operator>(const F2 &r) const {        return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;/*        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;*/    }    bool operator==(const F2 &r) const {        return a == r.a && b == r.b && c == r.c && d == r.d;    }    bool operator!=(const F2 &r) const {        return a != r.a || b != r.b || c != r.c || d != r.d;    }    ll operator[](ll i) {        assert(i < 4);        return i == 0 ? a : i == 1 ? b : i == 2 ? c : d;    }};\ntypedef T2<ll, ll, ll> T;\ntypedef F2<ll, ll, ll, ll> F;\nT mt(ll a, ll b, ll c) {return T(a, b, c);}\nF mf(ll a, ll b, ll c, ll d) {return F(a, b, c, d);}\n\n\n\n//@マクロ省略系 型,構造\n#define double long double\nusing dou = double;\nconst double eps = 1e-9;\n//基本コメントアウト\n/*\nstruct epsdou {    double v;    epsdou(double v = 0) : v(v) {}    template<class T> epsdou &operator+=(T b) {        v += (double) b;        return (*this);    }    template<class T> epsdou &operator-=(T b) {        v -= (double) b;        return (*this);    }    template<class T> epsdou &operator*=(T b) {        v *= (double) b;        return (*this);    }    template<class T> epsdou &operator/=(T b) {        v /= (double) b;        return (*this);    }    epsdou operator+(epsdou b) { return v + (double) b; }    epsdou operator-(epsdou b) { return v - (double) b; }    epsdou operator*(epsdou b) { return v * (double) b; }    epsdou operator/(epsdou b) { return v / (double) b; }    epsdou operator-() const { return epsdou(-v); }    template<class T> bool operator<(T b) { return v < (double) b; }    template<class T> bool operator>(T b) { return v > (double) b; }    template<class T> bool operator==(T b) { return fabs(v - (double) b) <= eps; }    template<class T> bool operator<=(T b) { return v < (double) b || fabs(v - b) <= eps; }    template<class T> bool operator>=(T b) { return v > (double) b || fabs(v - b) <= eps; }    operator double() { return v; }};istream &operator>>(istream &iss, epsdou &a) {    iss >> a.v;    return iss;}ostream &operator<<(ostream &os, epsdou &a) {    os << a.v;    return os;}\n#define eps_conr_t(o) template<class T> epsdou operator o(T b, epsdou a){return a.v o (dou)b;}\n#define eps_conl_t(o) template<class T> epsdou operator o(epsdou a, T b){return a.v o (dou)b;}\neps_conl_t(+)eps_conl_t(-)eps_conl_t(*)eps_conl_t(/)eps_conr_t(+)eps_conr_t(-)eps_conr_t(*)eps_conr_t(/)\n#undef double\n#define double epsdou\n*/\n\n#define ull unsigned long long\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\nusing mvp = mvec<P>;\nusing mvt = mvec<T>;\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\n\n#define fi first\n#define se second\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n#define el else\n#define elf else if\n#define upd update\n#define sstream stringstream\n\n#define maxq 1\n#define minq -1\n\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MALLOC(type, len) (type*)malloc((len) * sizeof(type))\n#define lam1(ret) [&](auto& v){return ret;}\n#define lam2(v, ret) [&](auto& v){return ret;}\n#define lam(...) over2(__VA_ARGS__,lam2,lam1)(__VA_ARGS__)\n#define lamr(right) [&](auto& p){return p right;}\n\n//マクロ省略系 コンテナ\nusing vi = vector<ll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vp = vector<P>;\nusing vt = vector<T>;\n\n//#define V vector\n#define vvt0(t) vector<vector<t>>\n#define vvt1(t,a) vector<vector<t>>a\n#define vvt2(t,a, b) vector<vector<t>>a(b)\n#define vvt3(t,a, b, c) vector<vector<t>> a(b,vector<t>(c))\n#define vvt4(t,a, b, c, d) vector<vector<t>> a(b,vector<t>(c,d))\n\n#define vvi(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(ll,__VA_ARGS__)\n#define vvb(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(bool,__VA_ARGS__)\n#define vvs(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(string,__VA_ARGS__)\n#define vvd(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(double,__VA_ARGS__)\n#define vvc(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(char,__VA_ARGS__)\n#define vvp(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(P,__VA_ARGS__)\n#define vvt(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(T,__VA_ARGS__)\n#define vv(type,...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(type,__VA_ARGS__)\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts> auto make_v(size_t a, Ts... ts) {return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));}\n#define vni(name, ...) auto name = make_v<ll>(__VA_ARGS__)\n#define vnb(name, ...) auto name = make_v<bool>(__VA_ARGS__)\n#define vns(name, ...) auto name = make_v<string>(__VA_ARGS__)\n#define vnd(name, ...) auto name = make_v<double>(__VA_ARGS__)\n#define vnc(name, ...) auto name = make_v<char>(__VA_ARGS__)\n#define vnp(name, ...) auto name = make_v<P>(__VA_ARGS__)\n#define vn(type,name, ...) auto name = make_v<type>(__VA_ARGS__)\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<ll, ll>;\nusing mapp = map<P, ll>;\nusing mapd = map<dou, ll>;\nusing mapc = map<char, ll>;\nusing maps = map<str, ll>;\nusing seti = set<ll>;\nusing setp = set<P>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<ll>;\n#define uset unordered_set\n#define useti unordered_set<ll,xorshift>\n#define mset multiset\n#define mseti multiset<ll>\n#define umap unordered_map\n#define mmap multimap\n//任意のマクロサポート用 使う度に初期化する\nint index_,v1_,v2_,v3_;\n\ntemplate<class T> struct pq {\n    priority_queue<T, vector<T>, greater<T> > q;/*小さい順*/    T su = 0;\n    void clear() {        q = priority_queue<T, vector<T>, greater<T> >();        su = 0;    }\n    void operator+=(T v) {        su += v;        q.push(v);    }\n    T sum() { return su; }\n    T top() { return q.top(); }\n    void pop() {        su -= q.top();        q.pop();    }\n    T poll() {        T ret = q.top();        su -= ret;        q.pop();        return ret;    }\n    ll size() { return q.size(); }\n};\ntemplate<class T> struct pqg {\n    priority_queue<T> q;/*大きい順*/    T su = 0;\n    void clear() {        q = priority_queue<T>();        su = 0;    }\n    void operator+=(T v) {        su += v;        q.push(v);    }\n    T sum() { return su; }\n    T top() { return q.top(); }\n    void pop() {        su -= q.top();        q.pop();    }\n    T poll() {        T ret = q.top();        su -= ret;        q.pop();        return ret;    }\n    ll size() { return q.size(); }\n};\n#define pqi pq<ll>\n#define pqgi pqg<ll>\n//マクロ 繰り返し\n//↓@オーバーロード隔離\n\n#define rep1(n) for(ll rep1i = 0,rep1lim=n; rep1i < rep1lim ; ++rep1i)\n#define rep2(i, n) for(ll i = 0,rep2lim=n; i < rep2lim ; ++i)\n#define rep3(i, m, n) for(ll i = m,rep3lim=n; i < rep3lim ; ++i)\n#define rep4(i, m, n, ad) for(ll i = m,rep4lim=n; i < rep4lim ; i+= ad)\n//逆順 閉区間\n#define rer2(i, n) for(ll i = n; i >= 0 ; i--)\n#define rer3(i, m, n) for(ll i = m,rer3lim=n; i >= rer3lim ; i--)\n#define rer4(i, m, n, dec) for(ll i = m,rer4lim=n; i >= rer4lim ; i-=dec)\n//ループを一つにまとめないとフォーマットで汚くなるため\n#define nex_ind1(i) i++\n#define nex_ind2(i, j, J) i = (j + 1 == J) ? i + 1 : i, j = (j + 1 == J ? 0 : j + 1)\n#define nex_ind3(i, j, k, J, K)i = (j + 1 == J && k + 1 == K) ? i + 1 : i, j = (k + 1 == K) ? (j + 1 == J ? 0 : j + 1) : j, k = (k + 1 == K ? 0 : k + 1)\n#define nex_ind4(i, j, k, l, J, K, L) i = (j + 1 == J && k + 1 == K && l + 1 == L) ? i + 1 : i, j = (k + 1 == K && l + 1 == L) ? (j + 1 == J ? 0 : j + 1) : j, k = (l + 1 == L ?(k + 1 == K ? 0 : k + 1) : k), l = l + 1 == L ? 0 : l + 1\n#define nex_ind5(i, j, k, l, m, J, K, L, M) i = (j + 1 == J && k + 1 == K && l + 1 == L && m + 1 == M) ? i + 1 : i, j = (k + 1 == K && l + 1 == L && m + 1 == M) ? (j + 1 == J ? 0 : j + 1) : j, k = (l + 1 == L && m + 1 == M ?(k + 1 == K ? 0 : k + 1) : k), l =  m + 1 == M ? l+1 == L ? 0 : l+1 : l,  m = m + 1 == M ? 0 : m + 1\n\n#define repss2(i, I) for (int i = 0; i < I; i++)\n#define repss4(i, j, I, J) for (int i = (J ? 0 : I), j = 0; i < I; nex_ind2(i, j, J))\n#define repss6(i, j, k, I, J, K) for (int i = (J && K ? 0 : I), j = 0, k = 0; i < I; nex_ind3(i, j, k, J, K))\n#define repss8(i, j, k, l, I, J, K, L) for (int i = (J && K && L ? 0 : I), j = 0, k = 0, l = 0; i < I; nex_ind4(i, j, k, l, J, K, L))\n#define repss10(i, j, k, l, m, I, J, K, L, M)for (int i = (J && K && L && M ? 0 : I), j = 0, k = 0, l = 0, m = 0; i < I; nex_ind5(i, j, k, l, m, J, K, L, M))\n\n//i,j,k...をnまで見る\n#define reps2(i, n) repss2(i, n)\n#define reps3(i, j, n) repss4(i, j, n, n)\n#define reps4(i, j, k, n) repss6(i, j, k, n, n, n)\n#define reps5(i, j, k, l, n) repss8(i, j, k, l, n, n, n, n)\n\ntemplate<class T>void nex_repv2(int&i,int&j,int&I, int&J,vector<vector<T>>&s){    while(1){        j++;        if(j >= J){            j=0;            i++;            if(i < I){                J = (int)s[i].size();            }        }        if(i >= I || J) return;    }}\ntemplate<class T> void nex_repv3(int &i, int &j, int &k, int &I, int &J, int &K, vector<vector<vector<T>>> &s) {    while (1) {        k++;        if (k >= K) {            k = 0;            j++;            if (j >= J) {                j = 0;                i++;                if (i >= I)return;            }        }        J = (int) s[i].size();        K = (int) s[i][j].size();        if (J && K) return;    }}\n\n#define repv_2(i,a) repss2(i, sz(a))\n//正方形である必要はない\n//直前を持つのとどっちが早いか\n#define repv_3(i, j, a) for (int I = (int)a.size(), J = (int)a[0].size(), i = 0, j = 0; i < I; nex_repv2(i,j,I,J,a))\n//箱状になっている事が要求される つまり[i] 次元目の要素数は一定\n#define repv_4(i, j, k, a) for (int I = (int)a.size(), J = (int)a[0].size(), K =(int)a[0][0].size(), i = 0, j = 0, k=0; i < I; nex_repv3(i,j,k,I,J,K,a))\n#define repv_5(i, j, k, l, a) repss8(i, j, k, l, sz(a), sz(a[0]), sz(a[0][0]), sz(a[0][0][0]))\n#define repv_6(i, j, k, l, m, a) repss10(i, j, k, l, m, sz(a), sz(a[0]), sz(a[0][0]), sz(a[0][0][0]), sz(a[0][0][0][0]))\n\ntemplate<typename T>struct has_rbegin_rend {private:template<typename U>static auto check(U &&obj) -> decltype(std::rbegin(obj), std::rend(obj), std::true_type{});static std::false_type check(...);public:static constexpr bool value = decltype(check(std::declval<T>()))::value;};template<typename T>constexpr bool has_rbegin_rend_v = has_rbegin_rend<T>::value;template<typename Iterator>class Range {public:Range(Iterator &&begin, Iterator &&end) noexcept: m_begin(std::forward<Iterator>(begin)), m_end(std::forward<Iterator>(end)) {}Iterator begin() const noexcept {return m_begin;}Iterator end() const noexcept {return m_end;}private:const Iterator m_begin;const Iterator m_end;};template<typename Iterator>static inline Range<Iterator>makeRange(Iterator &&begin, Iterator &&end) noexcept {return Range<Iterator>{std::forward<Iterator>(begin), std::forward<Iterator>(end)};}template<typename T>static inline decltype(auto) makeReversedRange(const std::initializer_list<T> &iniList) noexcept {return makeRange(std::rbegin(iniList), std::rend(iniList));}template<typename T,typename std::enable_if_t<has_rbegin_rend_v<T>, std::nullptr_t> = nullptr>static inline decltype(auto)makeReversedRange(T &&c) noexcept {return makeRange(std::rbegin(c), std::rend(c));}/* rbegin(), rend()を持たないものはこっちに分岐させて，エラーメッセージを少なくする*/template<typename T,typename std::enable_if<!has_rbegin_rend<T>::value, std::nullptr_t>::type = nullptr>static inline void makeReversedRange(T &&) noexcept {static_assert(has_rbegin_rend<T>::value, \"Specified argument doesn't have reverse iterator.\");}\n\n#define form1(st) for (auto &&form_it = st.begin(); form_it != st.end(); ++form_it)\n#define form3(k, v, st) for (auto &&form_it = st.begin(); form_it != st.end(); ++form_it)\n#define form4(k, v, st, r) for (auto &&form_it = st.begin(); form_it != st.end() && (*form_it).fi < r; ++form_it)\n#define form5(k, v, st, l, r) for (auto &&form_it = st.lower_bound(l); form_it != st.end() && (*form_it).fi < r; ++form_it)\n\n#define fors1(st) for (auto &&fors_it = st.begin(); fors_it != st.end(); ++fors_it)\n#define fors2(v, st) for (auto &&fors_it = st.begin(); fors_it != st.end(); ++fors_it)\n#define fors3(v, st, r) for (auto &&fors_it = st.begin(); fors_it != st.end() && (*fors_it) < r; ++fors_it)\n#define fors4(v, st, l, r) for (auto &&fors_it = st.lower_bound(l); fors_it != st.end() && (*fors_it) < r; ++fors_it)\n\n#define forslr3(st, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end(); ++forslr_it)\n#define forslr4(v, st, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end(); ++forslr_it)\n#define forslr5(v, st, r, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end() && (*forslr_it) < r; ++forslr_it)\n#define forslr6(v, st, l, r, a, b) for (auto &&forslr_it = st.lower_bound(l); forslr_it != st.end() && (*forslr_it) < r; ++forslr_it)\n\ntemplate<class U> vector<U>to1d(vector<U>& a){return a;}\ntemplate<class U> vector<U>to1d(vector<vector<U>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)res.push_back(a2);return res;}\ntemplate<class U> vector<U>to1d(vector<vector<vector<U>>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)for(auto&& a3 : a2) res.push_back(a3);return res;}\ntemplate<class U> vector<U>to1d(vector<vector<vector<vector<U>>>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)for(auto&& a3 : a2) for(auto&& a4 : a3)res.push_back(a4);return res;}\ntemplate<class U> vector<U>to1d(vector<vector<vector<vector<vector<U>>>>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)for(auto&& a3 : a2) for(auto&& a4 : a3)for(auto&& a5 : a4)res.push_back(a5);return res;}\ntemplate<class U> vector<U>to1d(vector<vector<vector<vector<vector<vector<U>>>>>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)for(auto&& a3 : a2) for(auto&& a4 : a3)for(auto&& a5 : a4)for(auto&& a6 : a5)res.push_back(a6);return res;}\n\n#define fora_init_2(a, A) ;\n#define fora_init_3(fora_i, a, A) auto &&a = A[fora_i];\n#define fora_init_4(a, b, A, B) auto &&a = A[fora_i]; auto &&b = B[fora_i];\n#define fora_init_5(fora_i, a, b, A, B) auto &&a = A[fora_i]; auto &&b = B[fora_i];\n#define fora_init_6(a, b, c, A, B, C) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i];\n#define fora_init_7(fora_i, a, b, c, A, B, C) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i];\n#define fora_init_8(a, b, c, d, A, B, C, D) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i]; auto && d = D[fora_i];\n#define fora_init_9(fora_i, a, b, c, d, A, B, C, D) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i]; auto && d = D[fora_i];\n#define fora_init(...) over9(__VA_ARGS__,fora_init_9, fora_init_8, fora_init_7, fora_init_6, fora_init_5, fora_init_4, fora_init_3, fora_init_2)(__VA_ARGS__)\n\n#define forr_init_2(a, A) auto &&a = A[forr_i];\n#define forr_init_3(forr_i, a, A) auto &&a = A[forr_i];\n#define forr_init_4(a, b, A, B) auto &&a = A[forr_i]; auto &&b = B[forr_i];\n#define forr_init_5(forr_i, a, b, A, B) auto &&a = A[forr_i]; auto &&b = B[forr_i];\n#define forr_init_6(a, b, c, A, B, C) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i];\n#define forr_init_7(forr_i, a, b, c, A, B, C) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i];\n#define forr_init_8(a, b, c, d, A, B, C, D) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i]; auto && d = D[forr_i];\n#define forr_init_9(forr_i, a, b, c, d, A, B, C, D) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i]; auto && d = D[forr_i];\n#define forr_init(...) over9(__VA_ARGS__, forr_init_9, forr_init_8, forr_init_7, forr_init_6, forr_init_5, forr_init_4, forr_init_3, forr_init_2)(__VA_ARGS__)\n\n\n#define forp_init(k, v, ...) auto &&k = (*forp_it).fi;auto &&v = (*forp_it).se;\n#define form_init(k, v, ...) auto &&k = (*form_it).fi;auto &&v = (*form_it).se;\n#define fors_init(v, ...) auto &&v = (*fors_it);\n\n#define forlr_init(a,A,ngl,ngr) auto a = A[forlr_i]; auto prev = forlr_i ? A[forlr_i-1] : ngl;auto next = forlr_i+1< rep2lim? A[forlr_i+1] : ngr;\n#define forslr_init4(a, A, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init5(a, A, r, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init6(a, A, l, r, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init(...)  over6(__VA_ARGS__,forslr_init6,forslr_init5,forslr_init4)(__VA_ARGS__);\n\n#define fora_2(a, A) for(auto&& a : A)\n#define fora_3(fora_i, a, A) rep(fora_i, sz(A))\n#define fora_4(a, b, A, B) rep(fora_i, sz(A))\n#define fora_5(fora_i, a, b, A, B) rep(fora_i, sz(A))\n#define fora_6(a, b, c, A, B, C) rep(fora_i, sz(A))\n#define fora_7(fora_i, a, b, c, A, B, C) rep(fora_i, sz(A))\n#define fora_8(a, b, c, d, A, B, C, D) rep(fora_i, sz(A))\n#define fora_9(fora_i, a, b, c, d, A, B, C, D) rep(fora_i, sz(A))\n\n#define forr_2(a, A) rer(forr_i, sz(A)-1)\n#define forr_3(forr_i, a, A) rer(forr_i, sz(A)-1)\n#define forr_4(a, b, A, B) rer(forr_i, sz(A)-1)\n#define forr_5(forr_i, a, b, A, B) rer(forr_i, sz(A)-1)\n#define forr_6(a, b, c, A, B, C) rer(forr_i, sz(A)-1)\n#define forr_7(forr_i, a, b, c, A, B, C) rer(forr_i, sz(A)-1)\n#define forr_8(a, b, c, d, A, B, C, D) rer(forr_i, sz(A)-1)\n#define forr_9(forr_i, a, b, c, d, A, B, C, D) rer(forr_i, sz(A)-1)\n\n//↑@オーバーロード隔離\n\n//rep系はインデックス、for系は中身\n#define rep(...) over4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rer(...) over4(__VA_ARGS__,rer4,rer3,rer2,)(__VA_ARGS__)\n//char用のrep\n#define repc(i, m, n) for(char i = m,repc3lim=n; i < repc3lim ; ++i)\n//i,j,k...をnまで見る\n#define reps(...) over5(__VA_ARGS__,reps5,reps4,reps3,reps2,)(__VA_ARGS__)\n#define repss(...) over10(__VA_ARGS__, repss10, a, repss8, a, repss6, a, repss4, a, repss2) (__VA_ARGS__)\n//vectorのindexを走査する\n//repv(i,j,vvi)\n#define repv(...) over6(__VA_ARGS__,repv_6,repv_5,repv_4,repv_3,repv_2,)(__VA_ARGS__)\n#define rerv(i, A) for (int i = sz(A)-1; i >= 0 ; i--)\n//repvn(dp) nは次元\n#define repv1(a) repv(i, a)\n#define repv2(a) repv(i, j, a)\n#define repv3(a) repv(i, j, k, a)\n#define repv4(a) repv(i, j, k, l, a)\n\n#define fora(...) over9(__VA_ARGS__, forr_9, fora_8, fora_7, fora_6, fora_5, fora_4, fora_3, fora_2)(__VA_ARGS__)\n#define forr(...) over9(__VA_ARGS__, forr_9, forr_8, forr_7, forr_6, forr_5, forr_4, forr_3, forr_2)(__VA_ARGS__)\n\n//#define forr(v, a) for(auto&& v : makeReversedRange(a))\n//参照を取らない\n#define forv(a, b) for(auto a : to1d(b))\n\n//インデックスを前後含めて走査\n#define ring(i, s, len) for (int i = s, prev = (s == 0) ? len - 1 : s - 1, next = (s == len - 1) ? 0 : s + 1, cou = 0; cou < len; cou++, prev = i, i = next, next = (next == len - 1) ? 0 : next + 1)\n//値と前後を見る\n#define ringv(v, d) index_=0;for (auto prev = d[sz(d)-1],next= (int)d.size()>1?d[1]:d[0],v = d[0]; index_ < sz(d); index_++, prev = v, v = next, next = (index_>=sz(d)-1?d[0]:d[index_+1]))\n// 左右をnext prevで見る 0の左と nの右\n#define forlr(v, d, banpei_l, banpei_r) rep(forlr_i,sz(d))\n\n#define form(...) over5(__VA_ARGS__,form5,form4,form3,form2,form1)(__VA_ARGS__)\n#define fors(...) over4(__VA_ARGS__,fors4,fors3,fors2,fors1)(__VA_ARGS__)\n#define forslr(...) over6(__VA_ARGS__,forslr6,forslr5,forslr4,forslr3)(__VA_ARGS__)\n#define forp(k, v, st) for (auto &&forp_it = st.begin(); forp_it != st.end(); ++forp_it)\n\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst ll inf = (ll) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst dou dinf = (dou) linf * linf;\nconst char infc = '{';\nconst string infs = \"{\";\nconst double PI = 3.1415926535897932384626433832795029L;\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((ll)(a).size())\n#define mp make_pair\n#define pb pop_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconstexpr bool ev(ll a) { return !(a & 1); }\nconstexpr bool od(ll a) { return (a & 1); }\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> { public:size_t operator()(const std::pair<signed, signed> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n    template<> class hash<std::pair<ll, ll>> { public:/*大きいllが渡されると、<<32でオーバーフローするがとりあえず問題ないと判断*/size_t operator()(const std::pair<ll, ll> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n}\n//stream まとめ\n/*@formatter:on*/\nistream &operator>>(istream &iss, P &a) {\n    iss >> a.first >> a.second;\n    return iss;\n}\ntemplate<typename T> istream &operator>>(istream &iss, vector<T> &vec) {\n    for (T &x: vec) iss >> x;\n    return iss;\n}\ntemplate<class T, class U> ostream &operator<<(ostream &os, pair<T, U> p) {\n    os << p.fi << \" \" << p.se;\n    return os;\n}\nostream &operator<<(ostream &os, T p) {\n    os << p.f << \" \" << p.s << \" \" << p.t;\n    return os;\n}\nostream &operator<<(ostream &os, F p) {\n    os << p.a << \" \" << p.b << \" \" << p.c << \" \" << p.d;\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &vec) {\n    for (ll i = 0; i < vec.size(); ++i)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n    return os;\n}\n\ntemplate<typename T> ostream &operator<<(ostream &os, vector<vector<T>> &vec) {\n    for (ll i = 0; i < vec.size(); ++i) {\n        for (ll j = 0; j < vec[i].size(); ++j) { os << vec[i][j] << \" \"; }\n        os << endl;\n    }\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, map<T, U> &m) {\n    for (auto &&v:m) os << v;\n    return os;\n}\ntemplate<class T> ostream &operator<<(ostream &os, set<T> s) {\n    fora(v, s) { os << v << \" \"; }\n    return os;\n}\ntemplate<class T> ostream &operator<<(ostream &os, mset<T> s) {\n    fora(v, s) { os << v << \" \"; }\n    return os;\n}\ntemplate<class T> ostream &operator<<(ostream &os, deque<T> a) {\n    fora(v, a)os << v << \" \";\n    return os;\n}\nostream &operator<<(ostream &os, vector<vector<char>> &vec) {\n    rep(h, sz(vec)) {\n        rep(w, sz(vec[0])) { os << vec[h][w]; }\n        os << endl;\n    }\n    return os;\n}\n//template<class T,class U>ostream &operator<<(ostream &os, vector<pair<T,U>>& a) {fora(v,a)os<<v<<endl;return os;}\n/*@formatter:off*/\ntemplate<typename W, typename H> void resize(W &vec, const H head) { vec.resize(head); }\ntemplate<typename W, typename H, typename ... T> void resize(W &vec, const H &head, const T ... tail) {vec.resize(head);for (auto &v: vec)resize(v, tail...);}\n//template<typename W, typename H> void resize(vector<W> &vec, const H head) { vec.resize(head); }\n//template<typename W, typename H, typename ... T> void resize(vector<W> &vec, const H &head, const T ... tail) {vec.resize(head);for (auto &v: vec)resize(v, tail...);}\ntemplate<typename T, typename F> bool all_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool all_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (!all_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool any_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool any_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (any_of2(v[i], f))return true; }    return false;}\ntemplate<typename T, typename F> bool none_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool none_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (none_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool find_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll find_if2(vector<T> &v, F f) {    rep(i, sz(v)) { if (find_if2(v[i], f))return i; }    return sz(v);}\ntemplate<typename T, typename F> bool rfind_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll rfind_if2(vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (rfind_if2(v[i], f))return i; }    return -1;}\ntemplate<class T> bool contains(string &s, const T &v) { return s.find(v) != string::npos; }\ntemplate<typename T> bool contains(vector<T> &v, const T &val) { return std::find(v.begin(), v.end(), val) != v.end(); }\ntemplate<typename T, typename F> bool contains_if2(vector<T> &v, F f) { return find_if(v.begin(), v.end(), f) != v.end(); }\ntemplate<typename T, typename F> ll count_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll count_if2(vector<T> &vec, F f) {    ll ret = 0;    fora(v, vec)ret += count_if2(v, f);    return ret;}\ntemplate<typename T, typename F> void for_each2(T &v, F f) { f(v); }\ntemplate<typename T, typename F> void for_each2(vector<T> &vec, F f) { fora(v, vec)for_each2(v, f); }\ntemplate<typename W> ll count_od(vector<W> &a) {return count_if2(a,[](ll v){return v&1 ;});}\ntemplate<typename W> ll count_ev(vector<W> &a) {return count_if2(a,[](ll v){return !(v&1) ;});}\n//削除した後のvectorを返す\ntemplate<typename T, typename F> vector<T> erase_if2(vector<T> &v, F f) {vector<T> nv;rep(i, sz(v)) { if (!f(v[i])) { nv.push_back(v[i]); }}return nv;}\ntemplate<typename T, typename F> vector<vector<T>> erase_if2(vector<vector<T>> &v, F f) {vector<vector<T>> res;rep(i, sz(v)) { res[i] = erase_if2(v[i], f); }return res;}\ntemplate<typename T, typename F> vector<T> l_erase_if2(vector<T> &v, F f) {vector<T> nv;rep(i, sz(v)) { if (!f(v[i])) { nv.push_back(v[i]); }}return nv;}\n\ntemplate<typename T, typename F> ll l_rfind_if(vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (f(v[i]))return i; }    return -1;}\ntemplate<typename T, typename F> bool l_contains_if(vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (f(v[i]))return true; }    return false;}\ntemplate<class A,class B, class C> auto t_all_of(A a,B b, C c){return std::all_of(a,b,c);}\ntemplate<class A,class B, class C> auto t_any_of(A a,B b, C c){return std::any_of(a,b,c);}\ntemplate<class A,class B, class C> auto t_none_of(A a,B b, C c){return std::none_of(a,b,c);}\ntemplate<class A,class B, class C> auto t_find_if(A a,B b, C c){return std::find_if(a,b,c);}\ntemplate<class A,class B, class C> auto t_count_if(A a,B b, C c){return std::count_if(a,b,c);}\n\n#define all_of_s__2(a,right) (t_all_of(all(a),lamr(right)))\n#define all_of_s__3(a,v,siki) (t_all_of(all(a),[&](auto v){return siki;}))\n#define all_of_s(...) over3(__VA_ARGS__,all_of_s__3,all_of_s__2)(__VA_ARGS__)\n\n//all_of(A, %2);\n//all_of(A, a, a%2);\n#define all_of__2(a,right) all_of2(a,lamr(right))\n#define all_of__3(a,v,siki) all_of2(a,[&](auto v){return siki;})\n#define all_of(...) over3(__VA_ARGS__,all_of__3,all_of__2)(__VA_ARGS__)\n#define all_of_f(a,f) all_of2(a,f)\n\n#define any_of_s__2(a,right) (t_any_of(all(a),lamr(right)))\n#define any_of_s__3(a,v,siki) (t_any_of(all(a),[&](auto v){return siki;}))\n#define any_of_s(...) over3(__VA_ARGS__,any_of_s__3,any_of_s__2)(__VA_ARGS__)\n\n#define any_of__2(a,right) any_of2(a,lamr(right))\n#define any_of__3(a,v, siki) any_of2(a,[&](auto v){return siki;})\n#define any_of(...) over3(__VA_ARGS__,any_of__3,any_of__2)(__VA_ARGS__)\n#define any_of_f(a,f) any_of2(a,f)\n\n#define none_of_s__2(a,right) (t_none_of(all(a),lamr(right)))\n#define none_of_s__3(a,v,siki) (t_none_of(all(a),[&](auto v){return siki;}))\n#define none_of_s(...) over3(__VA_ARGS__,none_of_s__3,none_of_s__2)(__VA_ARGS__)\n\n#define none_of__2(a,right) none_of2(a,lamr(right))\n#define none_of__3(a,v, siki) none_of2(a,[&](auto v){return siki;})\n#define none_of(...) over3(__VA_ARGS__,none_of__3,none_of__2)(__VA_ARGS__)\n#define none_of_f(a,f) none_of2(a,f)\n\n#define find_if_s__2(a,right) (t_find_if(all(a),lamr(right))-a.begin())\n#define find_if_s__3(a,v,siki) (t_find_if(all(a),[&](auto v){return siki;})-a.begin())\n#define find_if_s(...) over3(__VA_ARGS__,find_if_s__3,find_if_s__2)(__VA_ARGS__)\n\n#define find_if__2(a,right) find_if2(a,lamr(right))\n#define find_if__3(a,v, siki) find_if2(a,[&](auto v){return siki;})\n#define find_if(...) over3(__VA_ARGS__,find_if__3,find_if__2)(__VA_ARGS__)\n#define find_if_f(a,f) find_if2(a,f)\n\n#define rfind_if_s__2(a,right) l_rfind_if(a, lamr(right))\n#define rfind_if_s__3(a,v,siki) l_rfind_if(a, [&](auto v){return siki;})\n#define rfind_if_s(...) over3(__VA_ARGS__,rfind_if_s__3,rfind_if_s__2)(__VA_ARGS__)\n\n#define rfind_if__2(a,right) rfind_if2(a,lamr(right))\n#define rfind_if__3(a,v, siki) rfind_if2(a,[&](auto v){return siki;})\n#define rfind_if(...) over3(__VA_ARGS__,rfind_if__3,rfind_if__2)(__VA_ARGS__)\n#define rfind_if_f(a,f) rfind_if2(a,f)\n\n#define contains_if_s__2(a,right) l_contains_if(a, lamr(right))\n#define contains_if_s__3(a,v,siki) l_contains_if(a, [&](auto v){return siki;})\n#define contains_if_s(...) over3(__VA_ARGS__,contains_if_s__3,contains_if_s__2)(__VA_ARGS__)\n\n#define contains_if__2(a,right) contains_if2(a,lamr(right))\n#define contains_if__3(a,v, siki) contains_if2(a,[&](auto v){return siki;})\n#define contains_if(...) over3(__VA_ARGS__,contains_if__3,contains_if__2)(__VA_ARGS__)\n#define contains_if_f(a,f) contains_if2(a,f)\n\n#define count_if_s__2(a,right) (t_count_if(all(a),lamr(right)))\n#define count_if_s__3(a,v,siki) (t_count_if(all(a),[&](auto v){return siki;}))\n#define count_if_s(...) over3(__VA_ARGS__,count_if_s__3,count_if_s__2)(__VA_ARGS__)\n\n#define count_if__2(a,right) count_if2(a,lamr(right))\n#define count_if__3(a,v, siki) count_if2(a,[&](auto v){return siki;})\n#define count_if(...) over3(__VA_ARGS__,count_if__3,count_if__2)(__VA_ARGS__)\n#define count_if_f(a,f) count_if2(a,f)\n\n\n#define for_each_s__2(a,right) do{fora(v,a){v right;}}while(0)\n#define for_each_s__3(a,v, siki) do{fora(v,a){siki;}}while(0)\n#define for_each_s(...) over3(__VA_ARGS__,for_each_s__3,for_each_s__2)(__VA_ARGS__)\n\n#define for_each__2(a,right) for_each2(a,lamr(right))\n#define for_each__3(a,v, siki) for_each2(a,[&](auto v){return siki;})\n#define for_each(...) over3(__VA_ARGS__,for_each__3,for_each__2)(__VA_ARGS__)\n#define for_each_f(a, f) for_each2(a, f);\n\n#define erase_if_s__2(a,right) l_erase_if2(a,lamr(right))\n#define erase_if_s__3(a,v, siki) l_erase_if2(a,[&](auto v){return siki;})\n#define erase_if_s(...) over3(__VA_ARGS__,erase_if_s__3,erase_if_s__2)(__VA_ARGS__)\n\n\n#define erase_if__2(a,right) erase_if2(a,lamr(right))\n#define erase_if__3(a,v, siki) erase_if2(a,[&](auto v){return siki;})\n#define erase_if(...) over3(__VA_ARGS__,erase_if__3,erase_if__2)(__VA_ARGS__)\n#define erase_if_f(a,f) erase_if2(a,f)\n\n#define entry_if_s__2(a,right) l_entry_if2(a,lamr(right))\n#define entry_if_s__3(a,v, siki) l_entry_if2(a,[&](auto v){return siki;})\n#define entry_if_s(...) over3(__VA_ARGS__,entry_if_s__3,entry_if_s__2)(__VA_ARGS__)\n\n\n#define entry_if__2(a,right) entry_if2(a,lamr(right))\n#define entry_if__3(a,v, siki) entry_if2(a,[&](auto v){return siki;})\n#define entry_if(...) over3(__VA_ARGS__,entry_if__3,entry_if__2)(__VA_ARGS__)\n#define entry_if_f(a,f) entry_if2(a,f)\n\n\n\ntemplate<class T, class U,class W> void replace(vector<W> &a, T key, U v) { rep(i,sz(a))if(a[i]==key)a[i]=v; }\ntemplate<class T, class U,class W> void replace(vector<vector<W>> &A, T key, U v) { rep(i,sz(A))replace(A[i], key, v); }\nvoid replace(str &a, char key, str v) { if (v == \"\")a.erase(remove(all(a), key), a.end()); }\nvoid replace(str &a, char key, char v) { replace(all(a), key, v); }\n//keyと同じかどうか01で置き換える\ntemplate<class T, class U> void replace(vector<T> &a, U k) { rep(i, sz(a)) a[i] = a[i] == k; }\ntemplate<class T, class U> void replace(vector<vector<T >> &a, U k) { rep(i, sz(a))rep(j, sz(a[0])) a[i][j] = a[i][j] == k; }\n//template<class T> void replace(T &a) { replace(a, '#'); }\nvoid replace(str &a) {    int dec = 0;    if('a'<=a[0]&&a[0]<='z')dec = 'a';    if('A'<=a[0]&&a[0]<='Z')dec = 'A';    fora(v,a)v-=dec;}\nvoid replace(str &a, str key, str v) {stringstream t;ll kn = sz(key);std::string::size_type Pos(a.find(key));ll l = 0;while (Pos != std::string::npos) {t << a.substr(l, Pos - l);t << v;l = Pos + kn;Pos = a.find(key, Pos + kn);}t << a.substr(l, sz(a) - l);a = t.str();}\ntemplate<class T> bool includes(vector<T> &a, vector<T> &b) {vi c = a;vi d = b;sort(all(c));sort(all(d));return includes(all(c), all(d));}\ntemplate<class T> bool is_permutation(vector<T> &a, vector<T> &b) { return is_permutation(all(a), all(b)); }\ntemplate<class T> bool next_permutation(vector<T> &a) { return next_permutation(all(a)); }\nvoid iota(vector<ll> &ve, ll s, ll n) {ve.resize(n);iota(all(ve), s);}\nvi iota(ll s, ll len) {vi ve(len);iota(all(ve), s);return ve;}\ntemplate<class A, class B> auto vtop(vector<A> &a, vector<B> &b) {    assert(sz(a) == sz(b));    /*stringを0で初期化できない  */  vector<pair<A, B>> res;    rep(i, sz(a))res.eb(a[i], b[i]);return res;}\ntemplate<class A, class B> void ptov(vector<pair<A, B>> &p, vector<A> &a, vector<B> &b) {    a.resize(sz(p)), b.resize(sz(p));    rep(i, sz(p))a[i] = p[i].fi, b[i] = p[i].se;}\ntemplate<class A, class B, class C> auto vtot(vector<A> &a, vector<B> &b, vector<C> &c) {    assert(sz(a) == sz(b) && sz(b) == sz(c));    vector<T2<A, B, C>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i]);    return res;}\ntemplate<class A, class B, class C, class D> auto vtof(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    assert(sz(a) == sz(b) && sz(b) == sz(c) && sz(c) == sz(d));    vector<F2<A, B, C, D>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i], d[i]);    return res;}\nenum pcomparator { fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd };\nenum tcomparator {    fisiti, fisitd, fisdti, fisdtd, fdsiti, fdsitd, fdsdti, fdsdtd,    fitisi, fitisd, fitdsi, fitdsd, fdtisi, fdtisd, fdtdsi, fdtdsd,    sifiti, sifitd, sifdti, sifdtd, sdfiti, sdfitd, sdfdti, sdfdtd,    sitifi, sitifd, sitdfi, sitdfd, sdtifi, sdtifd, sdtdfi, sdfdfd,    tifisi, tifisd, tifdsi, tifdsd, tdfisi, tdfisd, tdfdsi, tdfdsd,    tisifi, tisifd, tisdfi, tisdfd, tdsifi, tdsifd, tdsdfi, tdsdfd};\ntemplate<class A, class B> void sort(vector<pair<A, B>> &a, pcomparator type) {    typedef pair<A, B> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });};template<class U> void sort(vector<U> &a, pcomparator type) {    if (type == fisi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f > r.f; });};template<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D> > &a, pcomparator type) {    typedef F2<A, B, C, D> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a > r.a; });};template<class U> void sort(vector<U> &a, tcomparator type) {    if (type == 0) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == 41) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == 42) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == 43) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });    else if (type == 44) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == 45) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == 46) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == 47) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });}template<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D>> &a, tcomparator type) {    typedef F2<A, B, C, D> U;    if (type == 0) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == 41) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == 42) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == 43) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });    else if (type == 44) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == 45) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == 46) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == 47) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });}\n\nvoid sort(string &a) { sort(all(a)); }\nvoid sort(int& a,int& b){    if(a>b)swap(a,b);}\nvoid sort(int& a,int& b, int& c){    sort(a,b);    sort(a,c);    sort(b,c);}\nvoid rsort(int& a,int& b){    if(a<b)swap(a,b);}\nvoid rsort(int& a,int& b, int& c){    rsort(a,b);    rsort(a,c);    rsort(b,c);}\ntemplate<class T> void sort(vector<T> &a) { sort(all(a)); }\n//P l, P rで f(P) の形で渡す\ntemplate<class U, class F> void sort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) < f(r); }); };\ntemplate<class T> void rsort(vector<T> &a) { sort(all(a), greater<T>()); };\ntemplate<class U, class F> void rsort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) > f(r); }); };\n\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class A, class B> void sortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    sort(c);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}template<class A, class B, class F> void sortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    sort(c, f);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}template<class A, class B> void rsortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    rsort(c);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}template<class A, class B, class F> void rsortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    rsort(c, f);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}\ntemplate<class A, class B, class C> void sortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    sort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class F> void sortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    sort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    rsort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class F> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    rsort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class D> void sortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    sort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\ntemplate<class A, class B, class C, class D> void rsortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    rsort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\n//sortindex 元のvectorはソートしない\ntemplate<class T> vi sorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind);    return ind;}/*indexの分で型が変わるためpcomparatorが必要*/template<class T> vi sorti(vector<T> &a, pcomparator f) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind, f);    return ind;}template<class T, class F> vi sorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(a[x]) < f(a[y]); });    return ind;}template<class T> vi rsorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    rsortp(b, ind);    return ind;}template<class T, class F> vi rsorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(a[x]) > f(a[y]); });    return ind;}template<class A, class B, class F> vi sortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(c[x]) < f(c[y]); });    return ind;}template<class A, class B> vi sortpi(vector<A> &a, vector<B> &b, pcomparator f) {    vi ind = iota(0, sz(a));    auto c = a;    auto d = b;    sortt(c, d, ind, f);    return ind;}template<class A, class B> vi sortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fisi); };template<class A, class B, class F> vi rsortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(c[x]) > f(c[y]); });    return ind;}template<class A, class B> vi rsortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fdsd); };template<class A, class B, class C, class F> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(d[x]) < f(d[y]); });    return ind;}template<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, pcomparator f) {    vi ind = iota(0, sz(a));    auto d = vtof(a, b, c, ind);    sort(d, f);    rep(i, sz(a))ind[i] = d[i].d;    return ind;}template<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) {        if (a[x] == a[y]) {            if (b[x] == b[y])return c[x] < c[y];            else return b[x] < b[y];        } else {            return a[x] < a[y];        }    });    return ind;}template<class A, class B, class C, class F> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(d[x]) > f(d[y]); });    return ind;}template<class A, class B, class C> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) {        if (a[x] == a[y]) {            if (b[x] == b[y])return c[x] > c[y];            else return b[x] > b[y];        } else {            return a[x] > a[y];        }    });    return ind;}\ntemplate<class T> void sort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)sort(a[i]); }\ntemplate<class T> void rsort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)rsort(a[i]); }\n\ntemplate<class... T,class U> auto sorted(U head,T... a) { sort(head,a...); return head;}\n\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }template<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }template<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\ntemplate<typename W, typename T>void fill(W &xx, const T vall) {    xx = vall;}template<typename W, typename T>void fill(vector<W> &vecc, const T vall) {    for (auto &&vx     : vecc)fill(vx, vall);}\ntemplate<typename W,typename T>void fill(vector<W> &xx,ll len,const T v) {rep(i, len)xx[i]=v;}\ntemplate<typename W, typename T> void fill(vector<vector<W>> &xx, int sh, int th, int sw, int tw, T v) { rep(h, sh, th)rep(w, sw, tw)xx[h][w] = v; }\ntemplate<class T,class U>void fill(vector<T> &a,vi& ind,U val) {fora(v,ind)a[v]=val;}\ntemplate<class W,class T>void fill(mvec<W> &xx,const T v){\n    fora(x,xx)fill(x,v);\n}\n\n\ntemplate<typename A, size_t N> A sum(A (&a)[N]) {    A res = 0;    rep(i, N)res += a[i];    return res;}template<typename A, size_t N, size_t O> A sum(A (&a)[N][O]) {    A res = 0;    rep(i, N)rep(j, O)res += a[i][j];    return res;}template<typename A, size_t N, size_t O, size_t P> A sum(A (&a)[N][O][P]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)res += a[i][j][k];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A sum(A (&a)[N][O][P][Q]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)res += a[i][j][k][l];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A sum(A (&a)[N][O][P][Q][R]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)res += a[i][j][k][l][m];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A sum(A (&a)[N][O][P][Q][R][S]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)res += a[i][j][k][l][m][n];    return res;}\n//@汎用便利関数 入力\nll in() {ll ret;cin >> ret;return ret;}\nstring sin() {string ret;cin >> ret;return ret;}\ntemplate<class T>  void in(T &head) { cin >> head; }template<class T, class... U>  void in(T &head, U &... tail) {cin >> head;in(tail...);}\n\n#define din1(a) ll a;cin>>a\n#define din2(a, b) ll a,b;cin>>a>> b\n#define din3(a, b, c) ll a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) ll a,b,c,d;cin>>a>>b>>c>>d\n#define din5(a, b, c, d, e) ll a,b,c,d,e;cin>>a>>b>>c>>d>>e\n#define din6(a, b, c, d, e, f) ll a,b,c,d,e,f;cin>>a>>b>>c>>d>>e>>f\n#define din(...) over6(__VA_ARGS__,din6,din5,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define dins1(a) str a;cin>>a\n#define dins2(a, b) str a,b;cin>>a>> b\n#define dins3(a, b, c) str a,b,c;cin>>a>>b>>c\n#define dins4(a, b, c, d) str a,b,c,d;cin>>a>>b>>c>>d\n#define dins5(a, b, c, d, e) str a,b,c,d,e;cin>>a>>b>>c>>d>>e\n#define dins6(a, b, c, d, e, f) str a,b,c,d,e,f;cin>>a>>b>>c>>d>>e>>f\n#define dins(...) over6(__VA_ARGS__,dins6,dins5,dins4,dins3,dins2 ,dins1)(__VA_ARGS__)\n\n#define din1d(a) din1(a);a--\n#define din2d(a, b) din2(a,b);a--,b--\n#define din3d(a, b, c) din3(a,b,c);a--,b--,c--\n#define din4d(a, b, c, d) din4(a,b,c,d);a--,b--,c--,d--\n#define dind(...) over4(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\ntemplate<class T> void out2(T &&head) { cout << head; }\ntemplate<class T, class... U> void out2(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);}\ntemplate<class T, class... U> void out(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);    cout << \"\" << endl;}\ntemplate<class T> void out(T &&head) {    cout << head  << endl;}\nvoid out() {    cout << \"\"  << endl;}\n\n\n#ifdef _DEBUG\ntemplate<class T> void err2(T &&head) { cerr << head; }\ntemplate<class T, class... U> void err2(T &&head, U &&... tail) {    cerr << head << \" \";    err2(tail...);}\ntemplate<class T, class... U> void err(T &&head, U &&... tail) {    cerr << head << \" \";    err2(tail...);    cerr << \"\" << endl;}\ntemplate<class T> void err(T &&head) {    cerr << head  << endl;}\nvoid err() {    cerr << \"\"  << endl;}\ntemplate<class T> string out_m2(vector<T> &a, ll W = inf) {    stringstream ss;    if (W == inf)W = min(sz(a), 12ll);    if (sz(a) == 0)return ss.str();    rep(i, W) {        ss << a[i];        if (typeid(a[i]) == typeid(P)) {            ss << endl;        } else {            ss << \" \";        }    }    return ss.str();}\ntemplate<class T> string out_m2(vector<vector<T> > &a, ll H = inf, ll W = inf, int key = -1) {H = min({H, sz(a), 12ll});W = min({W, sz(a[0]), 12ll});stringstream ss;ss << endl;if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";rep(w, W)ss << std::right << std::setw(4) << w;ss << \"\" << endl;rep(w, W * 4 + 3)ss << \"_\";ss << \"\" << endl;rep(h, H) {ss << std::right << std::setw(2) << h << \"|\";rep(w, min(sz(a[h]),12ll)) { if (abs(a[h][w]) == linf) ss << \"   e\" << \"\"; else ss << std::right << std::setw(4) << a[h][w]; }ss << \"\" << endl;}return ss.str();}\ntemplate<class T> string out_m2(vector<vector<vector<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {stringstream ss;    if (H == inf)H = 12;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << out_m2(a[i], W, U, i);    }       return ss.str();}\ntemplate<class T, size_t N> string out_m2(T (&a)[N]) {    vector<T> b;    resize(b, N);    rep(i, N) {        b[i] = a[i];    }    return out_m2(b);}\ntemplate<class T, size_t N, size_t M> string out_m2(T (&a)[N][M]) {    vector<vector<T>> b;    resize(b, N, M);    rep(i, N) {        rep(j, M) {            b[i][j] = a[i][j];        }    }    return out_m2(b);}\ntemplate<class T, size_t N, size_t M, size_t O> string out_m2(T (&a)[N][M][O]) {    vector<vector<vector<T>>> b;    resize(b, N, M, O);    rep(i, N) {        rep(j, M) {            rep(k, O) {                b[i][j][k] = a[i][j][k];            }        }    }    return out_m2(b);}\nstring out_m2(int a) {stringstream ss;ss << a;return ss.str();}\n/*@formatter:on*/\ntemplate<class T> string out_m2(mvec<mvec<T> > &a, ll H = inf, ll W = inf, int key = inf) {\n    H = min({H, sz(a), 6ll});\n    W = min({W, sz(a[0]), 6ll});\n    stringstream ss;\n    ss << endl;\n//    if (key == inf)ss << \" *|\"; else ss << \" \" << key << \"|\";\n    if (key == inf)ss << \" *|\";\n    else {\n        ss << std::right << std::setw(2) << key;\n        ss << \"|\";\n    }\n    rep(w, -W, W)ss << std::right << std::setw(4) << w;\n    ss << \"\" << endl;\n    rep(w, W * 8 + 3)ss << \"_\";\n    ss << \"\" << endl;\n    rep(h, -H, H) {\n        ss << std::right << std::setw(2) << h << \"|\";\n        int NW = min(sz(a[h]), 6ll);\n        rep(w, -NW, NW) { if (abs(a[h][w]) == linf) ss << \"   e\" << \"\"; else ss << std::right << std::setw(4) << a[h][w]; }\n        ss << \"\" << endl;\n    }\n    return ss.str();\n}/*@formatter:on*/\ntemplate<class T> string out_m2(mvec<mvec<mvec<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {\n    stringstream ss;\n    if (H == inf)H = 6;\n    H = min(H, sz(a));\n    rep(i, -H, H) {\n        ss << endl;\n        ss << out_m2(a[i], W, U, i);\n    }\n    return ss.str();\n}\n\n/*@formatter:off*/\ntemplate<class T> string out_m2(T &a) {stringstream ss;ss << a;return ss.str();}\n/*@formatter:on*/\ntemplate<class T> string out_m(vector<T> &a, ll W = inf) {\n    stringstream ss;\n    if (W == inf)W = min(sz(a), 12ll);\n    if (sz(a) == 0)return ss.str();\n    rep(i, W) { ss << a[i] << \" \"; }\n    ss << \"\" << endl;\n    return ss.str();\n}\n/*@formatter:off*/\ntemplate<class T> string out_m(vector<vector<T> > &a, ll H = inf, ll W = inf, int key = -1) {H = min({H, sz(a), 12ll});W = min({W, sz(a[0]), 12ll});stringstream ss;ss << endl;if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";rep(w, W)ss << std::right << std::setw(4) << w;ss << \"\" << endl;rep(w, W * 4 + 3)ss << \"_\";ss << \"\" << endl;rep(h, H) {ss << std::right << std::setw(2) << h << \"|\";rep(w, min(sz(a[h]),12ll)) { if (abs(a[h][w]) == linf) ss << \"   e\" << \"\"; else ss << std::right << std::setw(4) << a[h][w]; }ss << \"\" << endl;}ss << endl;return ss.str();}\ntemplate<class T> string out_m(vector<vector<vector<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {stringstream ss;    if (H == inf)H = 5;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << out_m(a[i], W, U, i);    }    ss << endl;    return ss.str();}\nstring out_m(int a) {stringstream ss;ss << a << endl;return ss.str();}\ntemplate<class T> string out_m(T &a) {stringstream ss;ss << a << endl;return ss.str();}\ntemplate<class T> void outv(vector<T> &a, ll W=inf) {cout << out_m(a,W) << endl;}\ntemplate<class T> void outv(vector<vector<T> > &a, ll H = linf, ll W = linf,int key=-1) {    cout << out_m(a,H,W,key) << endl;}\ntemplate<class T> void outv(vector<vector<vector<T> > > &a, ll H = linf, ll W = linf,ll U = linf) {cout << out_m(a,H,W,U)<< endl;}\n#else\ntemplate<class T> void outv(vector<T> &a, ll W = inf) {\n    rep(i, min(W, sz(a))) { cout << a[i] << \" \"; }\n    cout << \"\" << endl;\n}\ntemplate<class T> void outv(vector<vector<T> > &a, ll H = linf, ll W = linf, int key = -1) { rep(i, min(H, sz(a))) { outv(a[i], W); }}\ntemplate<class T> void outv(vector<vector<vector<T> > > &a, ll H = linf, ll W = linf, ll U = linf) { ; }\n#define err(...);\n#endif\ntemplate<class T> void outl(vector<T> &a, int n = inf) { rep(i, min(n, sz(a)))cout << a[i] << endl; }\n//テーブルをスペースなしで出力\ntemplate<class T> void outt(vector<vector<T>> &a) {\n    rep(i, sz(a)) {\n        rep(j, sz(a[i])) { cout << a[i][j]; }\n        cout << endl;\n    }\n}\n//int型をbit表記で出力\nvoid outb(int a) { cout << bitset<20>(a) << endl; }\ntemplate<class T> void na(vector<T> &a, ll n) {\n    a.resize(n);\n    rep(i, n)cin >> a[i];\n}\ntemplate<class T> void na(set<T> &a, ll n) {\n    rep(i, n)a.insert(in());\n}\n#define dna(a, n) vi a(n); rep(dnai,n) cin >> a[dnai];\n#define dnad(a, n) vi a(n); rep(dnai,n) cin >> a[dnai],a[dnai]--;\ntemplate<class T> void nao(vector<T> &a, ll n) {\n    a.resize(n + 1);\n    a[0] = 0;\n    rep(i, n)cin >> a[i + 1];\n}\ntemplate<class T> void naod(vector<T> &a, ll n) {\n    a.resize(n + 1);\n    a[0] = 0;\n    rep(i, n)cin >> a[i + 1], a[i + 1]--;\n}\ntemplate<class T> void nad(vector<T> &a, ll n) {\n    a.resize(n);\n    rep(i, n)cin >> a[i], a[i]--;\n}\ntemplate<class T> void nad(set<T> &a, ll n) {\n    rep(i, n)a.insert(in()-1);\n}\ntemplate<class T, class U> void na2(vector<T> &a, vector<U> &b, ll n) {\n    a.resize(n);\n    b.resize(n);\n    rep(i, n)cin >> a[i] >> b[i];\n}\ntemplate<class T, class U> void na2(set<T> &a, set<U> &b, ll n) {\n    rep(i, n){\n        a.insert(in());\n        b.insert(in());\n    }\n}\n\n#define dna2(a, b, n) vi a(n),b(n);rep(dna2i, n)cin >> a[dna2i] >> b[dna2i];\ntemplate<class T, class U> void nao2(vector<T> &a, vector<U> &b, ll n) {\n    a.resize(n + 1);\n    b.resize(n + 1);\n    a[0] = b[0] = 0;\n    rep(i, n)cin >> a[i + 1] >> b[i + 1];\n}\n#define dna2d(a, b, n) vi a(n),b(n);rep(dna2di, n){cin >> a[dna2di] >> b[dna2di];a[dna2di]--,b[dna2di]--;}\ntemplate<class T, class U> void na2d(vector<T> &a, vector<U> &b, ll n) {\n    a.resize(n);\n    b.resize(n);\n    rep(i, n)cin >> a[i] >> b[i], a[i]--, b[i]--;\n}\ntemplate<class T, class U, class W> void na3(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {\n    a.resize(n);\n    b.resize(n);\n    c.resize(n);\n    rep(i, n)cin >> a[i] >> b[i] >> c[i];\n}\n#define dna3(a, b, c, n) vi a(n),b(n),c(n);   rep(dna3i, n)cin >> a[dna3i] >> b[dna3i] >> c[dna3i];\ntemplate<class T, class U, class W> void na3d(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {\n    a.resize(n);\n    b.resize(n);\n    c.resize(n);\n    rep(i, n)cin >> a[i] >> b[i] >> c[i], a[i]--, b[i]--, c[i]--;\n}\n#define dna3d(a, b, c, n) vi a(n),b(n),c(n);  rep(dna3di, n){cin >> a[dna3di] >> b[dna3di] >> c[dna3di];a[dna3di]--,b[dna3di]--,c[dna3di]--;}\ntemplate<class T, class U, class W, class X> void na4(vector<T> &a, vector<U> &b, vector<W> &c, vector<X> &d, ll n) {\n    a.resize(n);\n    b.resize(n);\n    c.resize(n);\n    d.resize(n);\n    rep(i, n)cin >> a[i] >> b[i] >> c[i] >> d[i];\n}\n#define dna4(a, b, c, d, n) vi a(n),b(n),c(n),d(n);   rep(dna4i, n)cin >> a[dna4i] >> b[dna4i] >> c[dna4i]>>d[dna4i];\n#define dna4d(a, b, c, d, n) vi a(n),b(n),c(n),d(n);   rep(dna4i, n)cin >> a[dna4i] >> b[dna4i] >> c[dna4i]>>d[dna4i],--a[dna4i] ,-- b[dna4i],-- c[dna4i],--d[dna4i];\n#define nt(a, h, w) resize(a,h,w);rep(nthi,h)rep(ntwi,w) cin >> a[nthi][ntwi];\n#define ntd(a, h, w) resize(a,h,w);rep(ntdhi,h)rep(ntdwi,w) cin >> a[ntdhi][ntdwi], a[ntdhi][ntdwi]--;\n#define ntp(a, h, w) resize(a,h+2,w+2);fill(a,'#');rep(ntphi,1,h+1)rep(ntpwi,1,w+1) cin >> a[ntphi][ntpwi];\n//デバッグ\n#define sp << \" \" <<\n\n#define deb1(x)  debugName(x)<<\" = \"<<out_m2(x)\n#define deb_2(x, ...) deb1(x) <<\", \"<< deb1(__VA_ARGS__)\n#define deb_3(x, ...) deb1(x) <<\", \"<< deb_2(__VA_ARGS__)\n#define deb_4(x, ...) deb1(x) <<\", \"<< deb_3(__VA_ARGS__)\n#define deb5(x, ...) deb1(x) <<\", \"<< deb_4(__VA_ARGS__)\n#define deb6(x, ...) deb1(x) <<\", \"<< deb5(__VA_ARGS__)\n#define deb7(x, ...) deb1(x) <<\", \"<< deb6(__VA_ARGS__)\n#define deb8(x, ...) deb1(x) <<\", \"<< deb7(__VA_ARGS__)\n#define deb9(x, ...) deb1(x) <<\", \"<< deb8(__VA_ARGS__)\n#define deb10(x, ...) deb1(x) <<\", \"<< deb9(__VA_ARGS__)\n\n\n#ifdef _DEBUG\n#define deb(...)  cerr<< over10(__VA_ARGS__,deb10,deb9,deb8,deb7,deb6,deb5,deb_4,deb_3,deb_2,deb1)(__VA_ARGS__) <<endl\n\n#define base_keta 8\nvoid print_n_base(int x,int base){    cerr<<bitset<base_keta>(x)<<endl;}\ntemplate<class T>void print_n_base(vector<T> X,int base){    cerr<<endl;    for(auto&& x:X){        print_n_base(x,base);    }    cerr<<endl;}\n\n//n進数\n#define deb2(x) cerr<<debugName(x)<<\" = \";print_n_base(x, 2);\n#define deb3(x) cerr<<debugName(x)<<\" = \";print_n_base(x, 3);\n#define deb4(x) cerr<<debugName(x)<<\" = \";print_n_base(x, 4);\n\n#else\n#define deb(...) ;\n#define deb2(...) ;\n#define deb3(...) ;\n#define deb4(...) ;\n#endif\n\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n\n//@formatter:off\n//よく使うクラス、構造体\n//graphでredefineしているため、書き換えたら向こうも書き換える\nstruct unionfind {\n    vector<ll> par;\n    vector<ll> siz;\n    vector<ll> es;\n    ll n, trees;//連結グループの数(親の種類)\n    unionfind(ll n) : n(n), trees(n) {        par.resize(n);        siz.resize(n);        es.resize(n);        for (ll i = 0; i < n; i++) {            par[i] = i;            siz[i] = 1;        }    }\n    ll root(ll x) { if (par[x] == x) { return x; } else { return par[x] = root(par[x]); }}\n    ll operator()(ll x){return root(x);}\n    bool unite(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        es[x]++;\n        if (x == y) return false;\n        if (siz[x] > siz[y]) swap(x, y);\n        trees--;\n        par[x] = y;\n        siz[y] += siz[x];\n        es[y] += es[x];\n        return true;\n    }\n    bool same(ll x, ll y) { return root(x) == root(y); }\n    ll size(ll x) { return siz[root(x)]; }\n    ll esize(ll x) { return es[root(x)]; }\n    vi sizes(){        vi cou(n);        vi ret;        ret.reserve(n);        rep(i, n){            cou[root (i)]++;        }        rep(i, n){            if(cou[i])ret.push_back(cou[i]);        }        return ret;    }\n    //つながりを無向グラフと見なし、xが閉路に含まれるか判定\n    bool close(ll x) { return esize(x) >= size(x); }\n    vector<vi> sets() {        vi ind(n, -1);        ll i = 0;        vvi(res, trees);        rep(j, n) {            ll r = root(j);            if (ind[r] == -1)ind[r] = i++;            res[ind[r]].push_back(j);        }        rep(i, trees) {            ll r = root(res[i][0]);            if (res[i][0] == r)continue;            rep(j, 1, sz(res[i])) {                if (res[i][j] == r) {                    swap(res[i][0], res[i][j]);                    break;                }            }        }        return res;    }\n};//@formatter:off\n\n\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing u128 = __uint128_t;\n\nusing bint =__int128;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {    std::ostream::sentry s(dest);    if (s) {        __uint128_t tmp = value < 0 ? -value : value;        char buffer[128];        char *d = std::end(buffer);        do {            --d;            *d = \"0123456789\"[tmp % 10];            tmp /= 10;        } while (tmp != 0);        if (value < 0) {            --d;            *d = '-';        }        ll len = std::end(buffer) - d;        if (dest.rdbuf()->sputn(d, len) != len) { dest.setstate(std::ios_base::badbit); }    }    return dest;}\n__int128 to_bint(string &s) {    __int128 ret = 0;    for (ll i = 0; i < s.length(); ++i)        if ('0' <= s[i] && s[i] <= '9')            ret = 10 * ret + s[i] - '0';    return ret;}\nvoid operator>>(istream &iss, bint &v) {\n    string S;\n    iss>>S;\n    v = 0;\n    rep(i,sz(S)){\n        v*=10;\n        v +=  S[i]-'0';\n    }\n}\n//エラー\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");    exit(0);\n#endif\n    string a = \"a\";    rep(i, 30)a += a;    rep(i, 1 << 17)cout << a << endl;    cout << \"OLE 出力長制限超過\" << endl;    exit(0);}\nvoid re() {    assert(0 == 1);    exit(0);}\nvoid tle() { while (inf)cout << inf << endl; }\n\n//便利関数\n\n//テスト用\n#define rand xor128_\nunsigned long xor128_(void){static unsigned long x=123456789,y=362436069,z=521288629,w=88675123;unsigned long t;t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );}\nchar ranc() { return (char) ('a' + rand() % 26); }\nll rand(ll min, ll max) {    assert(min <= max);    if (min >= 0 && max >= 0) { return rand() % (max + 1 - min) + min; } else if (max < 0) { return -rand(-max, -min); } else { if (rand() % 2) { return rand(0, max); } else { return -rand(0, -min); }}}\nll rand(ll max){return rand(0,max);}\ntemplate<class T> T rand(vector<T>& A){return A[rand(sz(A)-1)];}\n//重複することがある\ntemplate<class T> vector<T> ranv(vector<T>& A, int N){vector<T>ret(N);rep(i,N){ret[i]=rand(A);}return ret;}\ntemplate<class T> vector<T> ranv_unique(vector<T>& A, int N){    vector<T> ret(N);    umapi was;    rep(j,N){        int i;        while(1){            i = rand(sz(A)-1);            if(was.find(i) == was.end())break;        }        ret[j] = A[i];was[i]=1;    }    return ret;}\nvi ranv(ll n, ll min, ll max) {    vi v(n);    rep(i, n)v[i] = rand(min, max);    return v;}\nstr ransu(ll n) {    str s;    rep(i, n)s += (char) rand('A', 'Z');    return s;}\nstr ransl(ll n) {    str s;    rep(i, n)s += (char) rand('a', 'z');    return s;}\n//単調増加\nvi ranvinc(ll n, ll min, ll max) {    vi v(n);    bool bad = 1;    while (bad) {        bad = 0;        v.resize(n);        rep(i, n) {            if (i && min > max - v[i - 1]) {                bad = 1;                break;            }            if (i)v[i] = v[i - 1] + rand(min, max - v[i - 1]); else v[i] = rand(min, max);        }    }    return v;}\n//便利 汎用\n\nvoid ranvlr(ll n, ll min, ll max, vi &l, vi &r) {    l.resize(n);    r.resize(n);    rep(i, n) {        l[i] = rand(min, max);        r[i] = l[i] + rand(0, max - l[i]);    }}\ntemplate<class T>vector<pair<T,int>> run_length(vector<T> &a) {vector<pair<T,int>> ret;ret.eb(a[0], 1);rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}return ret;}\nvector<pair<char, ll>> run_length(string &a) {    vector<pair<char, ll>> ret;    ret.eb(a[0], 1);    rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}    return ret;}\ntemplate<class F> ll mgr(ll ok, ll ng, F f) {\n    bool han = true;\n    if (ok < ng)\n        while (ng - ok > 1) {\n            ll mid = (ok + ng) >> 1;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            deb(mid,han);\n        }\n    else\n        while (ok - ng > 1) {\n            ll mid = (ok + ng) >> 1;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            deb(mid,han);\n        }\n    return ok;\n}\ntemplate<class F> dou mgrd(dou ok, dou ng, F f,int kai=100) {\n    bool han = true;\n    if (ok < ng)\n        rep(i,kai) {\n            dou mid = (ok + ng) /2;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            deb(mid,han);\n        }\n    else\n        rep(i,kai) {\n            dou mid = (ok + ng) /2;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            deb(mid,han);\n        }\n    return ok;\n}\n//strを整数として比較\nstring smax(str &a, str b) {    if (sz(a) < sz(b)) { return b; }    else if (sz(a) > sz(b)) { return a; }    else if (a < b)return b;    else return a;}\n//strを整数として比較\nstring smin(str &a, str b) {    if (sz(a) > sz(b)) { return b; }    else if (sz(a) < sz(b)) { return a; }    else if (a > b)return b;    else return a;}\n//エラー-1\ntemplate<typename W, typename T> ll find(vector<W> &a, int l, const T key) {rep(i, l, sz(a))if (a[i] == key)return i;return -1;}\ntemplate<typename W, typename T> ll find(vector<W> &a, const T key) {    rep(i, sz(a))if (a[i] == key)return i;    return -1;}\ntemplate<typename W, typename T> P find(vector<vector<W >> &a, const T key) {    rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return mp(i, j);    return mp(-1, -1);}\n//getid(find())を返す 1次元にする\ntemplate<typename W, typename T> int findi(vector<vector<W >> &a, const T key) {    rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return i*sz(a[0])+j;    return -1;}\ntemplate<typename W, typename U> T find(vector<vector<vector<W >>> &a, const U key) {    rep(i, sz(a))rep(j, sz(a[0]))rep(k, sz(a[0][0]))if (a[i][j][k] == key)return mt(i, j, k);    return mt(-1, -1, -1);}\n//stringも書く\nint find(string& s, const string key){    int klen = sz(key);    rep(i,sz(s)-klen+1){        if(s[i]!=key[0])continue;        if(s.substr(i,klen) == key){            return i;        }    }    return -1;}\nint find(string& s, int l, const string key){    int klen = sz(key);    rep(i, l, sz(s)-klen+1){        if(s[i]!=key[0])continue;        if(s.substr(i,klen) == key){            return i;        }    }    return -1;}\nint find(string& s, const char key){    rep(i,sz(s)){        if(s[i]==key)return i;    }    return -1;}\nint find(string& s, int l, const char key){    rep(i, l, sz(s)){        if(s[i]==key)return i;    }    return -1;}\ntemplate<typename W, typename T> ll count2(W &a, const T k) { return a == k; }\ntemplate<typename W, typename T> ll count2(vector<W> &a, const T k) {    ll ret = 0;    fora(v, a)ret += count2(v, k);    return ret;}\ntemplate<typename W, typename T> ll count(vector<W> &a, const T k) {    ll ret = 0;    fora(v, a)ret += count2(v, k);    return ret;}\nvi count(vi &a) {    int ma = 0;    fora(v, a) {        if (ma < v)ma = v;    }    vi res(ma + 1);    fora(v, a) {        res[v]++;    }    return res;}\nll count(str &a, str k) {    ll ret = 0, len = k.length();    auto pos = a.find(k);    while (pos != string::npos)pos = a.find(k, pos + len), ++ret;    return ret;}\n//'a' = 'A' = 0 として集計 既に-'a'されていても動く\nvi count(str &a, int l, int r) {    vi cou(26);    char c = 'a';    if ('A' <= a[l] && a[l] <= 'Z')c = 'A';    if ('a' <= a[l] && a[l] <= 'z') c = 'a'; else c = 0;    rep(i, l, r)++cou[a[i] - c];    return cou;}\nvi count(str &a, int r = inf){return count(a, 0, min(r, sz(a)));}\n#define couif count_if\n//algorythm\n\nll rev(ll a) {    ll res = 0;    while (a) {        res *= 10;        res += a % 10;        a /= 10;    }    return res;}\ntemplate<class T> void rev(vector<T> &a) { reverse(all(a)); }\ntemplate<class U> void rev(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a[0]), vector<U>(sz(a)));    rep(h, sz(a)) rep(w, sz(a[0]))b[w][h] = a[h][w];    a = b;}\nvoid  rev(string &a) { reverse(all(a)); }\nconstexpr ll p10[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000ll, 100000000000ll, 1000000000000ll, 10000000000000ll, 100000000000000ll, 1000000000000000ll, 10000000000000000ll, 100000000000000000ll, 1000000000000000000ll};\n\n//0は0桁\nll keta(ll v) {    if (v < p10[9]) { if (v < p10[4]) { if (v < p10[2]) { if (v < p10[1]) { if (v < p10[0])return 0; else return 1; } else return 2; } else { if (v < p10[3]) return 3; else return 4; }} else { if (v < p10[7]) { if (v < p10[5]) return 5; else if (v < p10[6])return 6; else return 7; } else { if (v < p10[8])return 8; else return 9; }}}    else {        if (v < p10[13]) { if (v < p10[11]) { if (v < p10[10]) return 10; else return 11; } else { if (v < p10[12]) return 12; else return 13; }}        else {            if (v < p10[15]) {                if (v < p10[14]) return 14;                else return 15;            } else {                if (v < p10[17]) {                    if (v < p10[16]) return 16;                    else return 17;                } else {                    if (v < p10[18])return 18;                    else return 19;                }            }        }    }}\nll getr(ll a, ll keta) { return (a / (ll) pow(10, keta)) % 10; }\n//上から何桁目か\nll getl(ll a, ll ket) {int sketa = keta(a);return getr(a,sketa-1-ket);}\nll dsum(ll v,ll sin=10) {    ll ret = 0;    for (; v; v /= sin)ret += v % sin;    return ret;}\n\nll mask10(ll v) { return p10[v] - 1; }\n//変換系\n//[v] := iとなるようなvectorを返す\n//存在しない物は-1\ntemplate<class T> auto keys(T& a) {    vector<decltype((a.begin())->fi)> res;    for (auto &&k :a)res.push_back(k.fi);    return res;}\ntemplate<class T> auto values(T& a) {    vector<decltype((a.begin())->se)> res;    for (auto &&k :a)res.push_back(k.se);    return res;}\ntemplate<class T, class U>  bool chma(T &a, const U &b) {    if (a < b) {        a = b;        return true;    }    return false;}\ntemplate<class T, class U>  bool chmi(T &a, const U &b) {    if (b < a) {        a = b;        return true;    }    return false;}\ntemplate<class T> constexpr T min(T a, signed b) { return a < b ? a : b; }\ntemplate<class T> constexpr  T max(T a, signed b) { return a < b ? b : a; }\ntemplate<class T> constexpr  T min(T a, T b, T c) { return a >= b ? b >= c ? c : b : a >= c ? c : a; }\ntemplate<class T> constexpr  T max(T a, T b, T c) { return a <= b ? b <= c ? c : b : a <= c ? c : a; }\ntemplate<class T>  T min(vector<T>& a) { return *min_element(all(a)); }\ntemplate<class T>  T mini(vector<T>& a) { return min_element(all(a)) - a.begin(); }\ntemplate<class T>  T min(vector<T>& a, ll n) { return *min_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T>  T min(vector<T>& a, ll s, ll n) { return *min_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<class T>  T max(vector<T>& a) { return *max_element(all(a)); }\ntemplate<class T,class U>  T max(vector<T>& a,vector<U>& b) { return max(*max_element(all(a)),*max_element(all(b))); }\ntemplate<class T>  T maxi(vector<T>& a) { return max_element(all(a)) - a.begin(); }\ntemplate<class T>  T max(vector<T>& a, ll n) { return *max_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T>  T max(vector<T>& a, ll s, ll n) { return *max_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<typename A, size_t N> A max(A (&a)[N]) {    A res = a[0];    rep(i, N)res = max(res, a[i]);    return res;}template<typename A, size_t N, size_t O> A max(A (&a)[N][O]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P> A max(A (&a)[N][O][P]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A max(A (&a)[N][O][P][Q], const T &v) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A max(A (&a)[N][O][P][Q][R]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A max(A (&a)[N][O][P][Q][R][S]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}\ntemplate<typename A, size_t N> A min(A (&a)[N]) {    A res = a[0];    rep(i, N)res = min(res, a[i]);    return res;}template<typename A, size_t N, size_t O> A min(A (&a)[N][O]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P> A min(A (&a)[N][O][P]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A min(A (&a)[N][O][P][Q], const T &v) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A min(A (&a)[N][O][P][Q][R]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A min(A (&a)[N][O][P][Q][R][S]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}\ntemplate<class T> T sum(vector<T> &v, ll s, ll t) {    T ret = 0;    rep(i, s, min(sz(v), t))ret += v[i];    return ret;}\ntemplate<class T> T sum(vector<T> &v, ll t = inf) { return sum(v, 0, t); }\ntemplate<class T> T sum(vector<vector<T> > &v, int s, int t) {T ret = 0;rep(i, s, min(sz(v), t))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<T> > &v, int t = inf) { return sum(v, 0, t); }\ntemplate<class T> T sum(vector<vector<vector<T>> > &v, int s, int t) {T ret = 0;rep(i, s, min(sz(v), t))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<vector<T>> > &v, int t = inf) { return sum(v, 0, t); }\ntemplate<class T> T sum(vector<vector<vector<vector<T>>> > &v, int s, int t) {T ret = 0;rep(i, s, min(sz(v), t))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<vector<vector<T>>> > &v, int t = inf) { return sum(v, 0, t); }\ntemplate<class T> T sum(vector<vector<vector<vector<vector<T>>>> > &v, int s, int t) {T ret = 0;rep(i, s, min(sz(v), t))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<vector<vector<vector<T>>>> > &v, int t = inf) { return sum(v, 0, t); }\n\ntemplate<class T> auto sum(priority_queue<T, vector<T>, greater<T> > &r) {    auto q = r;    T ret = 0;    while (sz(q)) {        ret += q.top();        q.pop();    }    return ret;}\ntemplate<class T> auto sum(priority_queue<T> &r) {    auto q = r;    T ret = 0;    while (sz(q)) {        ret += q.top();        q.pop();    }    return ret;}\ntemplate<class T> T mul(vector<T> &v, ll t = inf) {    T ret = v[0];    rep(i, 1, min(t, sz(v)))ret *= v[i];    return ret;}\n\n//template<class T, class U, class... W>  auto sumn(vector<T> &v, U head, W... tail) {    auto ret = sum(v[0], tail...);    rep(i, 1, min(sz(v), head))ret += sum(v[i], tail...);    return ret;}\nvi v_i(vi &a) {    int n = max(a) + 1;    vi ret(n, -1);    rep(i, sz(a)) {        ret[a[i]] = i;    }    return ret;}\nvoid clear(PQ &q) { q = PQ(); }\nvoid clear(priority_queue<int>&q) { q = priority_queue<int>();}\ntemplate<class T> void clear(queue<T> &q) { while (q.size())q.pop(); }\ntemplate<class T> T *negarr(ll size) {    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));    return body + size;}\ntemplate<class T> T *negarr2(ll h, ll w) {    double **dummy1 = new double *[2 * h + 1];    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];    dummy1[0] = dummy2 + w;    for (ll i = 1; i <= 2 * h + 1; ++i) { dummy1[i] = dummy1[i - 1] + 2 * w + 1; }    double **a = dummy1 + h;    return a;}\n//imoは0-indexed\n//ruiは1-indexed\ntemplate<class T> vector<T> imo(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    return ret;}\n//kと同じものの数\ntemplate<class T, class U> vi imo(vector<T> &a, U k) {vector<T> ret = a;rep(i, sz(ret))ret[i] = a[i] == k;rep(i, sz(ret) - 1)ret[i + 1] += ret[i];return ret;}\ntemplate<class T> vector<T> imox(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] ^= ret[i];    return ret;}\n//漸化的に最小を持つ\ntemplate<class T> vector<T> imi(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chmi(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> ima(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chma(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> rimi(vector<T> &v) {    vector<T> ret = v;    rer(i, sz(ret) - 1, 1)chmi(ret[i - 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> rima(vector<T> &v) {    vector<T> ret = v;    rer(i, sz(ret) - 1, 1)chma(ret[i - 1], ret[i]);    return ret;}\ntemplate<class T> struct ruiC {\n    vector<T> rui;\n    ruiC(vector<T> &ru) : rui(ru) {}\n    /*先頭0*/\n    ruiC() : rui(1, 0) {}\n    T operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruic \";            deb(l, r);            assert(0);        }        return rui[r] - rui[l];    }\n    T operator()(int r) { return operator()(0, r); }\n    /*ruiv[]をruic[]に変えた際意味が変わるのがまずいため()と統一*/\n    /*単体iを返す 累積でないことに注意(seg木との統一でこうしている)*/\n//    T operator[](ll i) { return rui[i + 1] - rui[i]; }\n    T operator[](ll i) { return rui[i]; }\n    /*0から順に追加される必要がある*/\n    void operator+=(T v) { rui.push_back(rui.back() + v); }\n    void add(int i, T v) {if (sz(rui) - 1 != i)ole();operator+=(v);}\n    T back() { return rui.back(); }\n    ll size() { return rui.size(); }\n    auto begin(){return rui.begin();}\n    auto end(){return rui.end();}\n};\ntemplate<class T> struct ruimax {template<typename Monoid>struct SegmentTree {        /*pairで処理*/        int sz;        vector<Monoid> seg;        const Monoid M1 = mp(MIN(T), -1);        Monoid f(Monoid a, Monoid b) {            return max(a, b);        }        void build(vector<T> &a) {            int n = sz(a);            sz = 1;            while (sz < n) sz <<= 1;            seg.assign(2 * sz, M1);            rep(i, n) { seg[i + sz] = mp(a[i], i); }            for (int k = sz - 1; k > 0; k--) {                seg[k] = f(seg[k << 1], seg[(k << 1) | 1]);            }        }        Monoid query(int a, int b) {            Monoid L = M1, R = M1;            for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {                if (a & 1) L = f(L, seg[a++]);                if (b & 1) R = f(seg[--b], R);            }            return f(L, R);        }        Monoid operator[](const int &k) const {            return seg[k + sz];        }    };private:vector<T> ve;SegmentTree<pair<T, int>> seg;vector<T> rv;vector<T> ri;bool build = false;\npublic:\n    int n;\n    ruimax(vector<T> &a) : ve(a), n(sz(a)) {        int index = -1;        int ma = MIN(T);        rv.resize(n + 1);        ri.resize(n + 1);        rv[0] = -linf;        ri[0] = -1;        rep(i, n) {            if (chma(ma, a[i])) {                index = i;            }            rv[i + 1] = ma;            ri[i + 1] = index;        }    }\n    T operator()(int l, int r) {        if (!(l <= r && 0 <= l && r <= n)) {            deb(l, r, n);            assert(0);        }        if (l == 0) {            return rv[r];        } else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).first;        }    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) {        return operator()(0, r);    }\n    T getv(int l, int r) {        return operator()(l, r);    }\n    T geti(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) {            return ri[r];        } else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).second;        }    }\n    T geti(int r = inf) { return geti(0, min(r,n)); };\n    T getv(int r = inf) { return getv(0, min(r,n)); };\n    auto begin(){return rv.begin();}\n    auto end(){return rv.end();}\n};\ntemplate<class T> struct ruimin {template<typename Monoid>    struct SegmentTree {  /*pairで処理*/         int sz;        vector<Monoid> seg;        const Monoid M1 = mp(MAX(T), -1);        Monoid f(Monoid a, Monoid b) {            return min(a, b);        }        void build(vector<T> &a) {            int n = sz(a);            sz = 1;            while (sz < n) sz <<= 1;            seg.assign(2 * sz, M1);            rep(i, n) { seg[i + sz] = mp(a[i], i); }            for (int k = sz - 1; k > 0; k--) {                seg[k] = f(seg[k << 1], seg[(k << 1) | 1]);            }        }        Monoid query(int a, int b) {            Monoid L = M1, R = M1;            for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {                if (a & 1) L = f(L, seg[a++]);                if (b & 1) R = f(seg[--b], R);            }            return f(L, R);        }        Monoid operator[](const int &k) const {            return seg[k + sz];        }    };private:vector<T> ve;SegmentTree<pair<T, int>> seg;vector<T> rv;vector<T> ri;bool build = false;int n;\npublic:\n    ruimin(vector<T> &a) : ve(a), n(sz(a)) {        int index = -1;        int mi = MAX(T);        rv.resize(n + 1);        ri.resize(n + 1);        rv[0] = linf;        ri[0] = -1;        rep(i, n) {            if (chmi(mi, a[i])) {                index = i;            }            rv[i + 1] = mi;            ri[i + 1] = index;        }    }\n    T operator()(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) {            return rv[r];        } else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).first;        }    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) {return operator()(0, r);}\n    T getv(int l, int r) {        return operator()(l, r);    }\n    T geti(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) {            return ri[r];        } else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).second;        }    }\n    T geti(int r = inf) { return geti(0, min(r,n)); };\n    T getv(int r = inf) { return getv(0, min(r,n)); };\n    auto begin(){return rv.begin();}\n    auto end(){return rv.end();}\n};\n\ntemplate<class T>ostream &operator<<(ostream &os, ruiC<T> a) {fora(v,a.rui)os<<v<<\" \";return os;}\ntemplate<class T> vector<T> ruiv(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i];    return ret;}\ntemplate<class T> ruiC<T> ruic() {return ruiC<T>();}\ntemplate<class T> ruiC<T> ruic(vector<T> &a) {    vector<T> ret = ruiv(a);    return ruiC<T>(ret);}\nvvi() ruib(vi &a) {    vvi(res, 61, sz(a) + 1);    rep(k, 61) {        rep(i, sz(a)) {            res[k][i + 1] = res[k][i] + ((a[i] >> k) & 1);        }    }    return res;}\nvector<ruiC<int>> ruibc(vi &a) {    vector<ruiC<int>> ret(61);    vvi(res, 61, sz(a));    rep(k, 61) {        rep(i, sz(a)) {            res[k][i] = (a[i] >> k) & 1;        }        ret[k] = ruic(res[k]);    }    return ret;}\nvector<ll> ruiv(string &a) {    if (sz(a) == 0)return vi(1);    ll dec = ('0' <= a[0] && a[0] <= '9') ? '0' : 0;    vector<ll> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i] - dec;    return ret;}\nruiC<ll> ruic(string &a) {    vector<ll> ret = ruiv(a);    return ruiC<ll>(ret);}\n//kと同じものの数\ntemplate<class T, class U> vi ruiv(T &a, U k) {    vi ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + (a[i] == k);    return ret;}\ntemplate<class T, class U> ruiC<ll> ruic(T &a, U k) {    vi ret = ruiv(a, k);    return ruiC<ll>(ret);}\ntemplate<class T> struct ruiC2 {\n    int H;\n    vector<ruiC<T>> rui;\n    ruiC2(vector<vector<T>> &ru) : rui(sz(ru)),H(sz(ru)) {        for (int h = 0; h < H; h++){            rui[h] = ruic(ru[h]);        }    }\n    //WについてHを返す\n    vector<T> operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruic \";            deb(l, r);            assert(0);        }        vector<T> res(H);        for (int h = 0; h < H; h++)res[h]=rui[h](l, r);        return res;    }\n    //HについてWを返す\n    ruiC<T> operator[](ll h){ assert(h<H);return rui[h]; }\n    //    vector<T> operator()(int r) { return operator()(0, r); }\n    /*ruiv[]をruic[]に変えた際意味が変わるのがまずいため()と統一*/\n    /*単体iを返す 累積でないことに注意(seg木との統一でこうしている)*/\n//    T operator[](ll i) { return rui[i + 1] - rui[i]; }\n    /*0から順に追加される必要がある*/\n//    T back() { return rui.back(); }\n//    ll size() { return rui.size(); }\n//    auto begin(){return rui.begin();}\n//    auto end(){return rui.end();}\n};\n\n//a~zを0~25として\n// rui(l,r)でvector(26文字について, l~rのcの個数)\n// rui[h] ruic()を返す\nruiC2<ll> ruicou(str &a) {    str s = a;    replace(s);    vector<ruiC<ll>> res(26);    vvi(cou, 26, sz(s));    rep(i, sz(s)) { cou[s[i]][i] = 1; }    return ruiC2<ll>(cou);}\nruiC2<ll> ruicou(vi &a) {    int H = max(a) + 1;    vector<ruiC<ll>> res(H);    vvi(cou, H, sz(a));    rep(i, sz(a)) { cou[a[i]][i] = 1; }    return ruiC2<ll>(cou);}\n\n/*@formatter:off*/\n//h query\ntemplate<class T> vector<T> imoh(vector<vector<T>> &v, int w) {vector<T> ret(sz(v));rep(h,sz(ret)){ret[h] = v[h][w];}rep(i, sz(ret) - 1){ret[i + 1] += ret[i];}return ret;}\ntemplate<class T> vector<T> ruih(vector<vector<T>> &v, int w) {vector<T> ret(sz(v) + 1);rep(h, sz(v)) { ret[h + 1] = v[h][w]; }rep(i, sz(v)) { ret[i + 1] += ret[i]; }return ret;}\ntemplate<class T> ruiC<T> ruihc(vector<vector<T>> &a, int w) {vector<T> ret = ruih(a, w);return ruiC<T>(ret);}\n\n//xor\ntemplate<class T> struct ruixC {    vector<T> rui;    ruixC(vector<T> &ru) : rui(ru) {}    T operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruiXc \";            deb(l, r);            assert(0);        }        return rui[r] ^ rui[l];    }    T operator[](ll i) { return rui[i]; }    T back() { return rui.back(); }    ll size() { return rui.size(); }};\ntemplate<class T> vector<T> ruix(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] ^ a[i];    return ret;}\ntemplate<class T> ruixC<ll> ruixc(vector<T>  &a) {vi ret = ruix(a);return ruixC<ll>(ret);}\ntemplate<class T> vector<T> ruim(vector<T> &a) {    vector<T> res(a.size() + 1, 1);    rep(i, a.size())res[i + 1] = res[i] * a[i];    return res;}\n//漸化的に最小を1indexで持つ\ntemplate<class T> vector<T> ruimi(vector<T> &a) {    ll n = sz(a);    vector<T> ret(n + 1);    rep(i, 1, n) {        ret[i] = a[i - 1];        chmi(ret[i + 1], ret[i]);    }    return ret;}\n//template<class T> T *rrui(vector<T> &a) {\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> struct rruiC {\n    vector<T> rui;\n    int n;\n    rruiC(vector<T> &a) : n(sz(a)) {rui.resize(n + 1);rer(i, n - 1) {rui[i] = rui[i + 1] + a[i];}}\n    /*[r l)*/\n    T operator()(int r, int l) {r++;l++;assert(l <= r && l >= 0 && r <= n);return rui[l] - rui[r];}\n    T operator()(int l) {return operator()(n - 1, l);}\n    T operator[](int i) {return operator()(i);}\n};\ntemplate<class T> ostream &operator<<(ostream &os, rruiC<T> a) {fora(v, a.rui)os << v << \" \";return os;}\n\n#define rrui rruic\ntemplate<class T> rruiC<T> rruic(vector<T> &a) { return rruiC<T>(a); }\n\n//掛け算\ntemplate<class T> struct ruimulC {\n    vector<T> rv;\n    int n;\n    ruimulC(vector<T> &a) : rv(a), n(sz(a)) {rv.resize(n + 1);rv[0] = 1;rep(i, n) { rv[i + 1] = a[i] * rv[i]; }}\n    ruimulC() : n(0) {rv.resize(n + 1);rv[0] = 1;}\n    void operator+=(T v) {rv.push_back(rv.back()*v);n++;}\n    T operator()(int l, int r) {assert(l <= r && 0 <= l && r <= n);return rv[r] / rv[l];}\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) { return operator()(0, r); }\n    auto begin() { return rv.begin(); }\n    auto end() { return rv.end(); }\n};\ntemplate<class T> ruimulC<T> ruimul(vector<T> &a) { return ruimulC<T>(a); }\ntemplate<class T> ruimulC<T> ruimul() {vector<T> a; return ruimulC<T>(a); }\n/*@formatter:off*/\ntemplate<class T> T *rruim(vector<T> &a) {    ll len = a.size();    T *body = (T *) malloc((len + 1) * sizeof(T));    T *res = body + 1;    res[len - 1] = 1;    rer(i, len - 1)res[i - 1] = res[i] * a[i];    return res;}\ntemplate<class T, class U> void inc(pair<T,U> &a, U v = 1) { a.first += v,a.second+=v; }\ntemplate<class T, class U> void inc(T &a, U v = 1) { a += v; }\ntemplate<class T, class U> void inc(vector<T> &a, U v = 1) { for (auto &u:a)inc(u, v); }\ntemplate<class T, class U> void dec(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U> void dec(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class U> void dec(string &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T,class U, class W> void dec(vector<T> &a,vector<U> &b, W v = 1) { for (auto &u :a)dec(u, v);for (auto &u :b)dec(u, v); }\ntemplate<class T,class U,class W> void dec(vector<T> &a,vector<U> &b,vector<W>&c ) { for (auto &u :a)dec(u, 1);for (auto &u :b)dec(u, 1);for (auto &u :c)dec(u, 1); }\nbool ins(ll h, ll w, ll H, ll W) { return h >= 0 && w >= 0 && h < H && w < W; }\nbool ins(ll l, ll v, ll r) { return l <= v && v < r; }\ntemplate<class T> bool ins(vector<T> &a, ll i, ll j = 0) { return ins(0, i, sz(a)) && ins(0, j, sz(a)); }\n#define inside ins\nll u(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u(vector<T> &a) {    vector<T> ret = a;    fora(v, ret)v = u(v);    return ret;}\n\n//添え字を返す\ntemplate<class F> ll goldd_l(ll left, ll right, F calc) {    double GRATIO = 1.6180339887498948482045868343656;    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));    ll fl = calc(lm);    ll fr = calc(rm);    while (right - left > 10) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + (ll) ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    ll minScore = MAX(ll);    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (minScore > score) {            minScore = score;            resIndex = i;        }    }    return resIndex;}\ntemplate<class F> ll goldt_l(ll left, ll right, F calc) {        double GRATIO = 1.6180339887498948482045868343656;        ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));        ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));        ll fl = calc(lm);        ll fr = calc(rm);        while (right - left > 10) {            if (fl > fr) {                right = rm;                rm = lm;                fr = fl;                lm = left + (ll) ((right - left) / (GRATIO + 1.0));                fl = calc(lm);            } else {                left = lm;                lm = rm;                fl = fr;                rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));                fr = calc(rm);            }        }    if (left > right) {        ll l = left;        left = right;        right = l;    }    ll maxScore = MIN(ll);    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (maxScore < score) {            maxScore = score;            resIndex = i;        }    }    return resIndex;}\n/*loopは200にすればおそらく大丈夫 余裕なら300に*/\ntemplate<class F> dou goldd_d(dou left, dou right, F calc, ll loop = 200) {    dou GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    /*200にすればおそらく大丈夫*/    /*余裕なら300に*/    ll k = 141;    loop++;    while (--loop) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return left;}\ntemplate<class F> dou goldt_d(dou left, dou right, F calc, ll loop = 200) {    double GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    loop++;    while (--loop) {        if (fl > fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return left;}\n//l ~ rを複数の区間に分割し、極致を与えるiを返す time-20 msまで探索\ntemplate<class F> ll goldd_ls(ll l, ll r, F calc, ll time = 2000) {    auto lim = milliseconds(time - 20);    ll mini = 0, minv = MAX(ll);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldd_l(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return mini;}\ntemplate<class F> ll goldt_ls(ll l, ll r, F calc, ll time = 2000) {    auto lim = milliseconds(time - 20);    ll maxi = 0, maxv = MIN(ll);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldt_l(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return maxi;}\ntemplate<class F> dou goldd_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を持つ*/    auto lim = milliseconds(time - 20);    dou mini = 0, minv = MAX(dou);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldd_d(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return mini;}\ntemplate<class F> dou goldt_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を残している*/    auto lim = milliseconds(time - 20);    dou maxi = 0, maxv = MIN(dou);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldt_d(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return maxi;}\ntemplate<class T> T min(vector<vector<T >> &a) {    T res = MAX(T);    rep(i, a.size())chmi(res, *min_element(all(a[i])));    return res;}\ntemplate<class T> T max(vector<vector<T >> &a) {    T res = MIN(T);    rep(i, a.size())chma(res, *max_element(all(a[i])));    return res;}\ntemplate<class T> T min(vector<vector<vector<T>>> &a) {    T res = MAX(T);    rep(i, a.size())chmi(res, min(a[i]));    return res;}\ntemplate<class T> T max(vector<vector<vector<T>>> &a) {    T res = MIN(T);    rep(i, a.size())chma(res, max(a[i]));    return res;}\ntemplate<class T> T min(vector<vector<vector<vector<T>>>> &a) {    T res = MAX(T);    rep(i, a.size())chmi(res, min(a[i]));    return res;}\ntemplate<class T> T max(vector<vector<vector<vector<T>>>> &a) {    T res = MIN(T);    rep(i, a.size())chma(res, max(a[i]));    return res;}\ntemplate<class T> T min(vector<vector<vector<vector<vector<T>>>>> &a) {    T res = MAX(T);    rep(i, a.size())chmi(res, min(a[i]));    return res;}\ntemplate<class T> T max(vector<vector<vector<vector<vector<T>>>>> &a) {    T res = MIN(T);    rep(i, a.size())chma(res, max(a[i]));    return res;}\ntemplate<class T> T min(vector<vector<vector<vector<vector<vector<T>>>>>> &a) {    T res = MAX(T);    rep(i, a.size())chmi(res, min(a[i]));    return res;}\ntemplate<class T> T max(vector<vector<vector<vector<vector<vector<T>>>>>> &a) {    T res = MIN(T);    rep(i, a.size())chma(res, max(a[i]));    return res;}\n//pow周りの仕様\n//powiを使うと整数型\n//powbを使うとbint型\n//powを使うと powlに変換され long doubleが返る\n#ifdef _DEBUG\nauto pow(ll a,ll k){    static bool was = 1;    if(was){message +=\"if integer use *powi* it's very fast\\n\";}    was=0;    return powl(a,k);}\n//上のメッセージを出すための関数\nauto pow(signed a,ll k){    return pow((ll)a,k);}\nauto pow(signed a,signed k){    return pow((ll)a,(ll)k);}\n#else\n#define pow powl\n\n#endif\n//整数型のpow\nint powi(int a, int k) {    if (a == 2)return 1ll << k;    int res = 1;    int x = a;    while (k) {        if(k & 1)res *= x;        x *= x;        k >>= 1;    }    return res;}\n//define pow powlより上に動かすとバグる\nbint pow(bint a, ll k) {    bint res = 1;    bint x = a;    while (k) {        if(k & 1)res *= x;        x *= x;        k >>= 1;    }    return res;}\nbint pow(bint a, signed k) {return pow(a,(ll)k);}\nbint powb(int a, int b){return pow((bint)a,b);}\nconstexpr bool bget(ll m, ll keta) {\n    #ifdef _DEBUG\n        assert(keta<=62);//オーバーフロー 1^62までしか扱えない\n    #endif\n    return (m >> keta) & 1; }\n//bget(n)次元\n//                          NならN-1まで\nvector<vi> bget2(vi& a,int keta_size){    vvi(res,keta_size,sz(a));    rep(k,keta_size){        rep(i, sz(a)){            res[k][i]=bget(a[i],k);        }    }    return res;}\nvi bget1(vi& a,int keta){    vi res(sz(a));    rep(i, sz(a)){        res[i]=bget(a[i],keta);    }    return res;}\nll bget(ll m, ll keta, ll sinsuu) {    m /= (ll) pow(sinsuu, keta);    return m % sinsuu;}\nconstexpr ll bit(ll n) {\n    #ifdef _DEBUG\n        assert(n<=62);//オーバーフロー 1^62までしか扱えない\n    #endif\n    return (1LL << (n)); }\nll bit(ll n, ll sinsuu) { return (ll) pow(sinsuu, n); }\nll mask(ll n) { return (1ll << n) - 1; }\n//aをbitに置きなおす\n//{0, 2} -> 101\nll bit(vi&a){    int m=0;    for(auto&& v:a) m|=bit(v);    return m;}\n\n//{1, 1, 0} -> 011\n//bitsetに置き換える感覚 i が立っていたら i bit目を立てる\nll bitb(vi&a){    int m=0;    rep(i,sz(a)) if(a[i])m|=bit(i);    return m;}\n#define bcou __builtin_popcountll\n//最下位ビット\nll lbit(ll n) { return n & -n; }\nll lbiti(ll n) { return log2(n & -n); }\n//最上位ビット\nll hbit(ll n) {    n |= (n >> 1);    n |= (n >> 2);    n |= (n >> 4);    n |= (n >> 8);    n |= (n >> 16);    n |= (n >> 32);    return n - (n >> 1);}\nll hbiti(ll n){return log2(hbit(n));}\nll hbitk(ll n) {    ll k = 0;    rer(i, 5) {        ll a = k + (1ll << i);        ll b = 1ll << a;        if (b <= n)k += 1ll << i;    }    return k;}\n//初期化は0を渡す\nll nextComb(ll &mask, ll n, ll r) {    if (!mask)return mask = (1LL << r) - 1;    ll x = mask & -mask; /*最下位の1*/    ll y = mask + x; /*連続した下の1を繰り上がらせる*/    ll res = ((mask & ~y) / x >> 1) | y;    if (bget(res, n))return mask = 0; else return mask = res;}\n//n桁以下でビットがr個立っているもののvectorを返す\nvi bitCombList(ll n, ll r) {    vi res;    ll m = 0;    while (nextComb(m, n, r)) { res.push_back(m); }    return res;}\n//masの立ってるindexを見る\n#define forbit(i, mas) for (int forbitj = lbit(mas), forbitm = mas, i = log2(forbitj); forbitm; forbitm = forbitj ? forbitm ^ forbitj : 0, forbitj = lbit(forbitm), i = log2(forbitj))\n\nchar itoal(ll i) { return 'a' + i; }\nchar itoaL(ll i) { return 'A' + i; }\nll altoi(char c) {    if ('A' <= c && c <= 'Z')return c - 'A';    return c - 'a';}\nll ctoi(char c) { return c - '0'; }\nchar itoc(ll i) { return i + '0'; }\nll vtoi(vi &v) {    ll res = 0;    if (sz(v) > 18) {        debugline(\"vtoi\");        deb(sz(v));        ole();    }    rep(i, sz(v)) {        res *= 10;        res += v[i];    }    return res;}\nvi itov(ll i) {    vi res;    while (i) {        res.push_back(i % 10);        i /= 10;    }    rev(res);    return res;}\nvi stov(string &a) {    ll n = sz(a);    vi ret(n);    rep(i, n) { ret[i] = a[i] - '0'; }    return ret;}\n//基準を満たさないものは0になる\nvi stov(string &a, char one) {    ll n = sz(a);    vi ret(n);    rep(i, n)ret[i] = a[i] == one;    return ret;}\nvector<vector<ll>> ctoi(vector<vector<char>> s, char c) {    ll n = sz(s), m = sz(s[0]);    vector<vector<ll>> res(n, vector<ll>(m));    rep(i, n)rep(j, m)res[i][j] = s[i][j] == c;    return res;}\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\n//[i] := vを返す\n//aは0~n-1で置き換えられる\nvi compress(vi &a) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(all(b), a[i]) - b.begin(); }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, umap<ll, ll> &map) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) {        ll v = a[i];        a[i] = lower_bound(all(b), a[i]) - b.begin();        map[v] = a[i];    }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r) {    vi b;    ll len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r, vi &s) {    vi b;    ll len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    fora(v, s)b.push_back(v);    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    for (ll i = 0; i < sz(s); ++i) r[i] = lower_bound(all(b), s[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vi> &a) {    vi b;    fora(vv, a)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vv, a)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vector<vi >> &a) {    vi b;    fora(vvv, a)fora(vv, vvv)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vvv, a)fora(vv, vvv)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvoid compress(ll a[], ll len) {    vi b;    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(all(b), a[i]) - b.begin(); }}\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(all(a),v))\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n#define rlowerIndex(a, v) (upper_bound(all(a),v)-a.begin()-1)\n#define rupperIndex(a, v) (lower_bound(all(a),v)-a.begin()-1)\n\ntemplate<class T, class U, class W> T lowerBound(vector<T> &a, U v, W banpei) {auto it = lower_bound(a.begin(), a.end(), v);if (it == a.end())return banpei; else return *it;}template<class T, class U, class W> T lowerBound(ruiC<T> &a, U v, W banpei) {return lowerBound(a.rui, v, banpei);}\ntemplate<class T, class U, class W> T upperBound(vector<T>& a, U v, W banpei){    auto it = upper_bound(a.begin(),a.end(),v);    if(it==a.end())return banpei;    else return *it;}template<class T, class U, class W> T upperBound(ruiC<T> &a, U v, W banpei) {return upperBound(a.rui, v, banpei);}\ntemplate<class T, class U, class W> T rlowerBound(vector<T> &a, U v, W banpei) {    auto it = upper_bound(a.begin(), a.end(), v);    if (it == a.begin())return banpei;    else{        return *(--it);    }}template<class T, class U, class W> T rlowerBound(ruiC<T> &a, U v, W banpei) {return rlowerBound(a.rui, v, banpei);}\ntemplate<class T, class U, class W> T rupperBound(vector<T> &a, U v, W banpei) {    auto it = lower_bound(a.begin(), a.end(), v);    if (it == a.begin())return banpei;    else{        return *(--it);    }}template<class T, class U, class W> T rupperBound(ruiC<T> &a, U v, W banpei) {return rupperBound(a.rui, v, banpei);}\n#define next2(a) next(next(a))\n#define prev2(a) prev(prev(a))\n\n//狭義の単調増加列 長さを返す\ntemplate<class T> int lis(vector<T> &a) {    int n = sz(a);    vi tail(n + 1, MAX(T));    rep(i, n) {        int id = lowerIndex(tail, a[i]);/**/        tail[id] = a[i];    }    return lowerIndex(tail, MAX(T));}\ntemplate<class T> int lis_eq(vector<T> &a) {    int n = sz(a);    vi tail(n + 1, MAX(T));    rep(i, n) {        int id = upperIndex(tail, a[i]);/**/        tail[id] = a[i];    }    return lowerIndex(tail, MAX(T));}\n\n//iteratorを返す\n//valueが1以上の物を返す 0は見つけ次第削除\n//vを減らす場合 (*it).se--でいい\ntemplate<class T, class U, class V> auto lower_map(map<T, U> &m, V k) {    auto ret = m.lower_bound(k);    while (ret != m.end() && (*ret).second == 0) {        ret = m.erase(ret);    }    return ret;}\ntemplate<class T, class U, class V> auto upper_map(map<T, U> &m, V k) {    auto ret = m.upper_bound(k);    while (ret != m.end() && (*ret).second == 0) {        ret = m.erase(ret);    }    return ret;}\n//存在しなければエラー\ntemplate<class T, class U, class V> auto rlower_map(map<T, U> &m, V k) {    auto ret = upper_map(m, k);    assert(ret != m.begin());    ret--;    while (1) {        if ((*ret).second != 0)break;        assert(ret != m.begin());        auto next = ret;        --next;        m.erase(ret);        ret = next;    }    return ret;}\ntemplate<class T, class U, class V> auto rupper_map(map<T, U> &m, V k) {    auto ret = lower_map(m, k);    assert(ret != m.begin());    ret--;    while (1) {        if ((*ret).second != 0)break;        assert(ret != m.begin());        auto next = ret;        --next;        m.erase(ret);        ret = next;    }    return ret;}\n\ntemplate<class... T> void fin(T... s) {out(s...); exit(0); }\n\n//便利 数学 math\n//sub ⊂ top\nbool subset(int sub, int top) {return (sub & top) == sub;}\n//-180 ~ 180 degree\ndouble atand(double h, double w) {return atan2(h, w) / PI * 180;}\n//% -mの場合、最小の正の数を返す\nll mod(ll a, ll m) {if (m < 0) m *= -1;return (a % m + m) % m;}\nll pow(ll a) { return a * a; };\nll fact(ll v) { return v <= 1 ? 1 : v * fact(v - 1); }\ndou factd(int v){static vd fact(2,1);    if(sz(fact)<=v){        rep(i,sz(fact),v+1){            fact.push_back(fact.back()*i);        }    }    return fact[v];}\n\nll comi(ll n, ll r) {    assert(n < 100);    static vvi(pas, 100, 100);    if (pas[0][0])return pas[n][r];    pas[0][0] = 1;    rep(i, 1, 100) {        pas[i][0] = 1;        rep(j, 1, i + 1)pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];    }    return pas[n][r];}\ndouble comd2(ll n, ll r) {    static vvd(comb, 2020, 2020);    if (comb[0][0] == 0) {        comb[0][0] = 1;        rep(i, 2000) {            comb[i + 1][0] = 1;            rep(j, 1, i + 2) { comb[i + 1][j] = comb[i][j] + comb[i][j - 1]; }        }    }    return comb[n][r];}\ndouble comd(int n, int r) {    if (r < 0 || r > n) return 0;    if (n < 2020)return comd2(n, r);    static vd fact(2, 1);    if (sz(fact) <= n) { rep(i, sz(fact), n + 1) { fact.push_back(fact.back() * i); }}    return fact[n] / fact[n - r] / fact[r];}\n\nll gcd(ll a, ll b) {while (b) a %= b, swap(a, b);return abs(a);}\nll gcd(vi b) {ll res = b[0];rep(i, 1, sz(b))res = gcd(b[i], res);return res;}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll lcm(vi a) {ll res = a[0];rep(i, 1, sz(a))res = lcm(a[i], res);return res;}\nll ceil(ll a, ll b) {if (b == 0) {debugline(\"ceil\");deb(a, b);ole();return -1;} else if (a < 0) { return 0; } else { return (a + b - 1) / b; }}\n\nll sig0(ll t) { return t <= 0 ? 0 : ((1 + t) * t) >> 1; }\n//ll sig(ll s, ll t) { return ((s + t) * (t - s + 1)) >> 1; }\nll sig(ll s, ll t) {if (s > t)swap(s, t);return sig0(t - s) + s * (t - s + 1);}\n\n#define tousa_i tosa_i\n#define lower_tousa_i lower_tosa_i\n#define upper_tousa upper_tosa\n#define upper_tousa_i upper_tosa_i\nll tosa_i(ll st, ll ad, ll v) {    assert(((v - st) % ad) == 0);    return (v - st) / ad;}\nll tosa_s(ll st, ll ad, ll len) {    return st * len + sig0(len - 1) * ad;}\n\n// ax + r (x は非負整数) で表せる整数のうち、v 以上となる最小の整数\nll lower_tosa(ll st, ll ad, ll v) {    if (st >= v) return st;    return (v - st + ad - 1) / ad * ad + st;}\n//第何項か\nll lower_tosa_i(ll st, ll ad, ll v) {    if (st >= v) return 0;    return (v - st + ad - 1) / ad;}\nll upper_tosa(ll st, ll ad, ll v) { return lower_tosa(st, ad, v + 1); }\nll upper_tosa_i(ll st, ll ad, ll v) { return lower_tosa_i(st, ad, v + 1); }\n\n\n//v * v >= aとなる最小のvを返す\nll sqrt(ll a) {    if (a < 0) {        debugline(\"sqrt\");        deb(a);        ole();    }    ll res = (ll) std::sqrt(a);    while (res * res < a)++res;    return res;}\ndouble log(double e, double x) { return log(x) / log(e); }\n\n\n/*@formatter:off*/\n\n//機能拡張\n#define dtie(a, b) int a, b; tie(a, b)\ntemplate<class T, class U> string to_string(T a, U b) {    string res = \"\";    res += a;    res += b;    return res;}\ntemplate<class T, class U, class V> string to_string(T a, U b, V c) {    string res = \"\";    res += a;    res += b;    res += c;    return res;}\ntemplate<class T, class U, class V, class W> string to_string(T a, U b, V c, W d) {    string res = \"\";    res += a;    res += b;    res += c;    res += d;    return res;}\ntemplate<class T, class U, class V, class W, class X> string to_string(T a, U b, V c, W d, X e) {    string res = \"\";    res += a;    res += b;    res += c;    res += d;    res += e;    return res;}\n\n\nconstexpr int bsetlen = k5 * 2;\n//constexpr int bsetlen = 5050;\n#define bset bitset<bsetlen>\nbool operator<(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] < b[i])return true;if (a[i] > b[i])return false;}return false;}\nbool operator>(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] > b[i])return true;if (a[i] < b[i])return false;}return false;}\nbool operator<=(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] < b[i])return true;if (a[i] > b[i])return false;}return true;}\nbool operator>=(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] > b[i])return true;if (a[i] < b[i])return false;}return true;}\nstring operator~(string &a) {string res = a;for (auto &&c:res) {if (c == '0')c = '1';else if (c == '1')c = '0';else {cerr << \"cant ~\" << a << \"must bit\" << endl;exit(0);}}return res;}\nostream &operator<<(ostream &os, bset& a) {    bitset<10> b;    vi list;    rep(i,bsetlen){        if(a[i])list.push_back(i),b[i]=1;    }    os<<b<<\", \"<<list;    return os;}\nint hbiti(bset&a){rer(i,bsetlen){if(a[i])return i;}return -1;}\n#define hk(a, b, c) (a <= b && b < c)\n\n//O(N/64)\nbset nap(bset &a, int v) {bset r = a | a << v;return r;}\nbset nap(bset &a, bset &v) {bset r = a;rep(i, bsetlen) {if (v[i])r |= a << i;}return r;}\n\n\ntemplate<class T> void seth(vector<vector<T>> &S, int w, vector<T> &v) {assert(sz(S) == sz(v));assert(w < sz(S[0]));rep(h, sz(S)) { S[h][w] = v[h]; }}\n\ntemplate<class T, class U> void operator+=(pair<T,U> &a, pair<T,U> & b) {a.fi+=b.fi;a.se+=b.se;}\ntemplate<class T, class U> pair<T,U> operator+(pair<T,U> &a, pair<T,U> & b) {return pair<T,U>(a.fi+b.fi,a.se+b.se);}\n\ntemplate<typename CharT, typename Traits, typename Alloc>basic_string<CharT, Traits, Alloc>operator+(const basic_string<CharT, Traits, Alloc> &lhs, const int rv) {    basic_string<CharT, Traits, Alloc> str(lhs);    str.append(to_string(rv));    return str;}template<typename CharT, typename Traits, typename Alloc>void operator+=(basic_string<CharT, Traits, Alloc> &lhs, const int rv) {    lhs += to_string(rv);}template<typename CharT, typename Traits, typename Alloc>basic_string<CharT, Traits, Alloc>operator+(const basic_string<CharT, Traits, Alloc> &lhs, const signed rv) {    basic_string<CharT, Traits, Alloc> str(lhs);    str.append(to_string(rv));    return str;}template<typename CharT, typename Traits, typename Alloc>void operator+=(basic_string<CharT, Traits, Alloc> &lhs, const signed rv) {    lhs += to_string(rv);}\ntemplate<typename CharT, typename Traits, typename Alloc> void operator*=(basic_string<CharT, Traits, Alloc> &s, int num) {auto bek = s;s = \"\";for (; num; num >>= 1) {if (num & 1) {s += bek;}bek += bek;}}\ntemplate<class T, class U> void operator+=(queue<T> &a, U v) { a.push(v); }template<class T, class U> void operator+=(deque<T> &a, U v) { a.push_back(v); }template<class T> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, vector<T> &v) {    fora(d, v)a.push(d);    return a;}template<class T, class U> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, U v) {    a.push(v);    return a;}template<class T, class U> priority_queue<T> &operator+=(priority_queue<T> &a, U v) {    a.push(v);    return a;}template<class T> set<T> &operator+=(set<T> &a, vector<T> v) {    fora(d, v)a.insert(d);    return a;}template<class T, class U> auto operator+=(set<T> &a, U v) { return a.insert(v); }template<class T, class U> auto operator-=(set<T> &a, U v) { return a.erase(v); }template<class T, class U> auto operator+=(mset<T> &a, U v) { return a.insert(v); }template<class T, class U> set<T, greater<T>> &operator+=(set<T, greater<T>> &a, U v) {    a.insert(v);    return a;}template<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {    a.push_back(v);    return a;}template<class T, class U> vector<T> operator+(vector<T> &a, U v) {    vector<T> ret = a;    ret += v;    return ret;}template<class T, class U> vector<T> operator+(U v, vector<T> &a) {    vector<T> ret = a;    ret.insert(ret.begin(), v);    return ret;}template<class T> vector<T> operator+(vector<T> a, vector<T> b) {    vector<T> ret;    ret = a;    fora(v, b)ret += v;    return ret;}template<class T> vector<T> &operator+=(vector<T> &a, vector<T> &b) {    rep(i, sz(b)) {/*こうしないとa+=aで両辺が増え続けてバグる*/        a.push_back(b[i]); }    return a;}template<class T, class U> map<T, U> &operator+=(map<T, U> &a, map<T, U> &b) {    fora(bv, b) { a[bv.first] += bv.second; }    return a;}\ntemplate<class T> void operator+=(mset<T> &a, vector<T>& v) { for(auto&& u : v)a.insert(u); }\ntemplate<class T> void operator+=(set<T> &a, vector<T>& v) { for(auto&& u : v)a.insert(u); }\ntemplate<class T> void operator+=(vector<T> &a, set<T>& v) { for(auto&& u : v)a.emplace_back(u); }\ntemplate<class T> void operator+=(vector<T> &a, mset<T>& v) { for(auto&& u : v)a.emplace_back(u); }\ntemplate<class T> vector<T> &operator-=(vector<T> &a, vector <T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-=\");        deb(a);        deb(b);        exit(0);    }    rep(i, sz(a))a[i] -= b[i];    return a;}\ntemplate<class T> vector<T> operator-(vector<T> &a, vector<T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-\");        deb(a);        deb(b);        ole();    }    vector<T> res(sz(a));    rep(i, sz(a))res[i] = a[i] - b[i];    return res;}\ntemplate<class T, class U> void operator*=(vector<T> &a, U b) {    vector<T> ta = a;    rep(b-1){        a+=ta;    }}\ntemplate<typename T> void erase(vector<T> &v, unsigned ll i) { v.erase(v.begin() + i); }\ntemplate<typename T> void erase(vector<T> &v, unsigned ll s, unsigned ll e) { v.erase(v.begin() + s, v.begin() + e); }\ntemplate<class T, class U> void erase(map<T, U> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<class T> void erase(set<T> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<typename T> void erasen(vector<T> &v, unsigned ll s, unsigned ll n) { v.erase(v.begin() + s, v.begin() + s + n); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, U t) { v.insert(v.begin() + i, t); }\ntemplate<typename T, typename U> void push_front(vector<T> &v, U t) { v.insert(v.begin(), t); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, vector<T> list) { for (auto &&va:list)v.insert(v.begin() + i++, va); }\ntemplate<typename T> void insert(set<T> &v, vector<T> list) { for (auto &&va :list)v.insert(va); }\ntemplate<class T> T poll(set<T>& S){T ret = *S.begin();S.erase(S.begin());return ret;}\ntemplate<class T> T poll(mset<T>& S){T ret = *S.begin();S.erase(S.begin());return ret;}\ntemplate<class T> T poll_back(set<T>& S){T ret = *S.rbegin();S.erase(S.rbegin());return ret;}\ntemplate<class T> T poll_back(mset<T>& S){T ret = *S.rbegin();S.erase(S.rbegin());return ret;}\ntemplate<class T> T peek(set<T>& S){T ret = *S.begin();return ret;}\ntemplate<class T> T peek(mset<T>& S){T ret = *S.begin();return ret;}\ntemplate<class T> T peek_back(set<T>& S){T ret = *S.rbegin();return ret;}\ntemplate<class T> T peek_back(mset<T>& S){T ret = *S.rbegin();return ret;}\n\nvector<string> split(const string a, const char deli) {    string b = a + deli;    ll l = 0, r = 0, n = b.size();    vector<string> res;    rep(i, n) {        if (b[i] == deli) {            r = i;            if (l < r)res.push_back(b.substr(l, r - l));            l = i + 1;        }    }    return res;}\nvector<string> split(const string a, const string deli) {    vector<string> res;    ll kn = sz(deli);    std::string::size_type Pos(a.find(deli));    ll l = 0;    while (Pos != std::string::npos) {        if (Pos - l)res.push_back(a.substr(l, Pos - l));        l = Pos + kn;        Pos = a.find(deli, Pos + kn);    }    if (sz(a) - l)res.push_back(a.substr(l, sz(a) - l));    return res;}\nvoid yn(bool a) { if (a)cout << \"yes\" << endl; else cout << \"no\" << endl; }\nvoid Yn(bool a) { if (a)cout << \"Yes\" << endl; else cout << \"No\" << endl; }\nvoid YN(bool a) { if (a)cout << \"YES\" << endl; else cout << \"NO\" << endl; }\nvoid fyn(bool a) {    if (a)cout << \"yes\" << endl; else cout << \"no\" << endl;    exit(0);}\nvoid fYn(bool a) {    if (a)cout << \"Yes\" << endl; else cout << \"No\" << endl;    exit(0);}\nvoid fYN(bool a) {    if (a)cout << \"YES\" << endl; else cout << \"NO\" << endl;    exit(0);}\nvoid fAb(bool a) { if(a)cout<<\"Alice\"<<endl;else cout<<\"Bob\";}\nvoid Possible(bool a) {    if (a)cout << \"Possible\" << endl; else cout << \"Impossible\" << endl;    exit(0);}\nvoid POSSIBLE(bool a) {    if (a)cout << \"POSSIBLE\" << endl; else cout << \"IMPOSSIBLE\" << endl;    exit(0);}\ntemplate<typename T> class fixed_point        : T {public:    explicit constexpr fixed_point(T &&t) noexcept: T(std::forward<T>(t)) {}    template<typename... Args> constexpr decltype(auto) operator()(Args &&... args) const { return T::operator()(*this, std::forward<Args>(args)...); }};template<typename T> static inline constexpr decltype(auto) fix(T &&t) noexcept { return fixed_point<T>{std::forward<T>(t)}; }\n\n\n//未分類\n//0,2,1 1番目と2番目の次元を入れ替える\ntemplate<class T> auto irekae(vector<vector<vector<T> > > &A, int x, int y, int z) {\n#define irekae_resize_loop(a, b, c) resize(res,a,b,c);rep(i,a)rep(j,b)rep(k,c)\n    vector<vector<vector<T> > > res;    if (x == 0 && y == 1 && z == 2) {        res = A;    } else if (x == 0 && y == 2 && z == 1) {        irekae_resize_loop(sz(A), sz(A[0][0]), sz(A[0])) {                    res[i][j][k] = A[i][k][j];                }    } else if (x == 1 && y == 0 && z == 2) {        irekae_resize_loop(sz(A[0]), sz(A), sz(A[0][0])) {                    res[i][j][k] = A[j][i][k];                }    } else if (x == 1 && y == 2 && z == 0) {        irekae_resize_loop(sz(A[0]), sz(A[0][0]), sz(A)) {                    res[i][j][k] = A[k][i][j];                }    } else if (x == 2 && y == 0 && z == 1) {        irekae_resize_loop(sz(A[0][0]), sz(A), sz(A[0])) {                    res[i][j][k] = A[j][k][i];                }    } else if (x == 2 && y == 1 && z == 0) {        irekae_resize_loop(sz(A[0][0]), sz(A[0]), sz(A)) {                    res[i][j][k] = A[k][j][i];                }    }    return res;\n#undef irekae_resize_loop\n}\ntemplate<class T> auto irekae(vector<vector<T>>&A,int i=1,int j=0){    vvt(res,sz(A[0]),sz(A));    rep(i,sz(A)){        rep(j,sz(A[0])){            res[j][i]=A[i][j];        }    }    return res;}\n//tou分割する\ntemplate<typename T> vector<vector<T>> cut(vector<T> &a, int tou = 2) {    int N = sz(a);    vector<vector<T>> res(tou);    int hab = N / tou;    vi lens(tou, hab);    rep(i, N % tou) { lens[tou - 1 - i]++; }    int l = 0;    rep(i, tou) {        int len = lens[i];        int r = l + len;        res[i].resize(len);        std::copy(a.begin() + l, a.begin() + r, res[i].begin());        l = r;    }    return res;}\n//長さn毎に分割する\ntemplate<typename T> vector<vector<T>> cutn(vector<T> &a, int len) {    int N = sz(a);    vector<vector<T>> res(ceil(N, len));    vi lens(N / len, len);    if (N % len)lens.push_back(N % len);    int l = 0;    rep(i, sz(lens)) {        int len = lens[i];        int r = l + len;        res[i].resize(len);        std::copy(a.begin() + l, a.begin() + r, res[i].begin());        l = r;    }    return res;}\nvi inds_(vi &a) {    int n = sz(a);    vb was(n);    vi res(n);    rep(i, n) {        assert(!was[a[i]]);        res[a[i]] = i;        was[a[i]] = true;    }    return res;}\n\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} initonv;\n#define pre prev\n#define nex next\n\n//gra mll pr\n//上下左右\nconst string udlr = \"udlr\";\nstring UDLR = \"UDLR\";//x4と連動 UDLR.find('U') := x4[0]\n//右、上が正\nconstexpr ll h4[] = {1, -1, 0, 0};\nconstexpr ll w4[] = {0, 0, -1, 1};\nconstexpr ll h8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconstexpr ll w8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n    int mei_inc(int h, int w, int H, int W, int i) {while (++i < 4) { if (inside(h + h4[i], w + w4[i], H, W))return i; }return i;}\n#define mei(nh, nw, h, w) for (int i = mei_inc(h, w, H, W, -1), nh = i<4? h + h4[i] : 0, nw = i<4? w + w4[i] : 0; i < 4; i=mei_inc(h,w,H,W,i), nh = h+h4[i], nw = w+w4[i])\n\n//グラフ内で #undef getid\n//#define getidとしているため、ここを書き直したらgraphも書き直す\n#define getid_2(h, w) (h * W + w)\n#define getid_1(p) (p.first * W + p.second)\n#define getid(...) over2(__VA_ARGS__, getid_2, getid_1) (__VA_ARGS__)\n#define getp(id) mp(id / W, id % W)\n//#define set_shuffle() std::random_device seed_gen;std::mt19937 engine(seed_gen())\n//#define shuffle(a) std::shuffle((a).begin(), (a).end(), engine);\n//1980 開始からtime ms経っていたらtrue\nbool timeup(int time) {\n    auto end_time = system_clock::now();\n    auto part = duration_cast<milliseconds>(end_time - start_time);\n    auto lim = milliseconds(time);\n    return part >= lim;\n}\nvoid set_time() { past_time = system_clock::now(); }\n//MS型(millisecqnds)で返る\n//set_timeをしてからの時間\nauto calc_time_milli() {    auto now = system_clock::now();    auto part = duration_cast<milliseconds>(now - past_time);    return part;}\nauto calc_time_micro() {    auto now = system_clock::now();    auto part = duration_cast<microseconds>(now - past_time);    return part;}\nauto calc_time_nano() {    auto now = system_clock::now();    auto part = duration_cast<nanoseconds>(now - past_time);    return part;}\nbool calc_time(int zikan) { return calc_time_micro() >= microseconds(zikan); }\nusing MS=std::chrono::microseconds;\nint div(microseconds a, microseconds b) { return a / b; }\nint div(nanoseconds a, nanoseconds b) {    if (b < nanoseconds(1)) { return a / nanoseconds(1); }    int v = a / b;    return v;}\n//set_time();\n//rep(i,lim)shori\n\n//lim*=time_nanbai();\n//rep(i,lim)shoriと使う\n//全体でmilliかかっていいときにlimを何倍してもう一回できるかを返す\nint time_nanbai(int milli) {\n    auto dec = duration_cast<nanoseconds>(past_time - start_time);\n    auto part = calc_time_nano();\n    auto can_time = nanoseconds(milli * 1000 * 1000);\n    can_time -= part;\n    can_time -= dec;\n    return div(can_time, part);\n}\n/*@formatter:on*/\n//vectorで取れる要素数\n//bool=> 1e9 * 8.32\n//int => 1e8 * 2.6\n//ll  => 1e8 * 1.3\n//3次元以上取るとメモリがヤバい\n//static配列を使う\n\nvvc (ba);\nll N, M, H, W;\nvi A, B, C;\n\n//19:08\nvoid solve() {\n    dins(S);\n    N=sz(S);\n    din(K);\n    //[l, r], 使った回数 =  最大長\n    vni(dp, N, N, K + 10);\n    rep(i, N) {\n        dp[i][i][0] = 1;\n    }\n    rep(len, 2, N + 10) {\n        rep(l, N) {\n            int r = l + len - 1;\n            if (r >= N)break;\n            rep(pk, K + 1) {\n                chma(dp[l][r][pk], dp[l + 1][r][pk]);\n                chma(dp[l][r][pk], dp[l][r - 1][pk]);\n                if (len > 2) {\n                    chma(dp[l][r][pk + (S[l] != S[r])], dp[l + 1][r - 1][pk] + 2);\n                }\n            }\n        }\n    }\n    resize(dp, N, N, K + 1);\n    deb(dp);\n    out(max(dp));\n}\n\nauto my(ll n, vi &a) {\n    return 0;\n}\n\nauto sister(ll n, vi &a) {\n    ll ret = 0;\n    return ret;\n}\n\nsigned main() {\n    solve();\n\n#define arg n,a\n#ifdef _DEBUG\n    bool bad = 0;\n    for (ll i = 0, ok = 1; i < k5 && ok; ++i) {\n        ll n = rand(1, 8);\n        vi a = ranv(n, 1, 10);\n        auto myres = my(arg);\n        auto res = sister(arg);\n        ok = myres == res;\n        if (!ok) {\n            out(arg);\n            cerr << \"AC : \" << res << endl;\n            cerr << \"MY  : \" << myres << endl;\n            bad = 1;\n\n\n            break;\n        }\n    }\n    if (!bad) {\n//        cout << \"完璧 : solveを書き直そう\" << endl;\n//        cout << \"     : そして、solve()を呼び出すのだ\" << endl;\n//        cout << \"     : cin>>n; na(a,n);も忘れるな\" << endl;\n    }\n    if (sz(message)) {\n        cerr << \"****************************\" << endl;\n        cerr << message << endl;\n        cerr << \"****************************\" << endl;\n    }\n#endif\n    return 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n\t#include <boost/multiprecision/cpp_int.hpp>\n\t#include <boost/multiprecision/cpp_dec_float.hpp>\n\tusing bll = boost::multiprecision::cpp_int;\n\tusing bdouble = boost::multiprecision::cpp_dec_float_100;\n#endif\n#ifdef LOCAL_DEV\n\tvoid debug_impl() { std::cerr << '\\n'; }\n\ttemplate<typename Head, typename... Tail> void debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head << (sizeof...(tail) ? \",\" : \"\"); debug_impl(tail...); }\n\t#define debug(...) do { std::cerr << \"(\" << #__VA_ARGS__ << \") =\"; debug_impl(__VA_ARGS__); } while (false)\n#else\n\t#define debug(...) do {} while (false)\n#endif\n#ifdef LOCAL_TEST\n\t#define BOOST_STACKTRACE_USE_ADDR2LINE\n\t#define BOOST_STACKTRACE_ADDR2LINE_LOCATION /usr/local/opt/binutils/bin/addr2line\n\t#define _GNU_SOURCE\n\t#include <boost/stacktrace.hpp>\n\tnamespace std {\n\t\ttemplate<typename T> class dvector : public std::vector<T> {\n\t\tpublic:\n\t\t\tdvector() : std::vector<T>() {}\n\t\t\texplicit dvector(size_t n, const T& value = T()) : std::vector<T>(n, value) {}\n\t\t\tdvector(const std::vector<T>& v) : std::vector<T>(v) {}\n\t\t\tdvector(const std::initializer_list<T> il) : std::vector<T>(il) {}\n\t\t\tdvector(const typename std::vector<T>::iterator first, const typename std::vector<T>::iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const std::string::iterator first, const std::string::iterator last) : std::vector<T>(first, last) {}\n\t\t\tT& operator[](size_t n) {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst T& operator[](size_t n) const {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\tclass dbool {\n\tprivate:\n\t\tbool boolvalue;\n\tpublic:\n\t\tdbool() : boolvalue(false) {}\n\t\tdbool(bool b) : boolvalue(b) {}\n\t\tdbool(const dbool& b) : boolvalue(b.boolvalue) {}\n\t\toperator bool&() { return boolvalue; }\n\t\toperator const bool&() const { return boolvalue; }\n\t};\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::dvector<T>& v) {\n\t\tfor (size_t i = 0; i < v.size(); ++i){ s << v[i]; if (i < v.size() - 1) s << \"\\t\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::dvector<std::dvector<T>>& vv) {\n\t\ts << \"\\n\"; for (size_t i = 0; i < vv.size(); ++i){ s << vv[i] << \"\\n\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::set<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::multiset<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate <typename T, size_t N> std::ostream& operator<<(std::ostream& s, const std::array<T, N>& a) {\n\t\ts << \"{ \"; for (size_t i = 0; i < N; ++i){ s << a[i] << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::map<T1, T2>& m) {\n\t\ts << \"{\\n\"; for (auto itr = m.begin(); itr != m.end(); ++itr){ s << \"\\t\" << (*itr).first << \" : \" << (*itr).second << \"\\n\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::pair<T1, T2>& p) {\n\t\treturn s << \"(\" << p.first << \", \" << p.second << \")\"; }\n\t#define vector dvector\n\t#define bool dbool\n\tclass SIGFPE_exception : std::exception {};\n\tclass SIGSEGV_exception : std::exception {};\n\tvoid catch_SIGFPE(int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGFPE_exception();\t}\n\tvoid catch_SIGSEGV(int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGSEGV_exception(); }\n\tsigned convertedmain();\n\tsigned main() { signal(SIGFPE, catch_SIGFPE); signal(SIGSEGV, catch_SIGSEGV); return convertedmain(); }\n\t#define main() convertedmain()\n#endif\n//#define int long long\nusing ll = long long;\n//constexpr int INF = 1e9;//INT_MAX=(1<<31)-1=2147483647\nconstexpr ll INF = (ll)1e18;//(1LL<<63)-1=9223372036854775807\nconstexpr ll MOD = 998244353;//(ll)1e9 + 7;\nconstexpr double EPS = 1e-9;\nconstexpr ll dx[4] = {1LL, 0LL, -1LL, 0LL};\nconstexpr ll dy[4] = {0LL, 1LL, 0LL, -1LL};\nconstexpr ll dx8[8] = {1LL, 0LL, -1LL, 0LL, 1LL, 1LL, -1LL, -1LL};\nconstexpr ll dy8[8] = {0LL, 1LL, 0LL, -1LL, 1LL, -1LL, 1LL, -1LL};\n#define rep(i, n)   for(ll i=0, i##_length=(n); i< i##_length; ++i)\n#define repeq(i, n) for(ll i=1, i##_length=(n); i<=i##_length; ++i)\n#define rrep(i, n)   for(ll i=(n)-1; i>=0; --i)\n#define rrepeq(i, n) for(ll i=(n)  ; i>=1; --i)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\nvoid p() { std::cout << '\\n'; }\ntemplate<typename Head, typename... Tail> void p(Head head, Tail... tail) { std::cout << head << (sizeof...(tail) ? \" \" : \"\"); p(tail...); }\ntemplate<typename T> inline void pv(std::vector<T>& v) { for(ll i=0, N=v.size(); i<N; i++) std::cout << v[i] << \" \\n\"[i==N-1]; }\ntemplate<typename T> inline T gcd(T a, T b) { return b ? gcd(b,a%b) : a; }\ntemplate<typename T> inline T lcm(T a, T b) { return a / gcd(a,  b) * b; }\ntemplate<typename T> inline bool chmax(T& a, T b) { return a < b && (a = b, true); }\ntemplate<typename T> inline bool chmin(T& a, T b) { return a > b && (a = b, true); }\ntemplate<typename T> inline void uniq(std::vector<T>& v) { v.erase(std::unique(v.begin(), v.end()), v.end()); }\n\n/*-----8<-----template-----8<-----*/\nnamespace makevectordetail {\n\ttemplate <typename Tp, size_t N>\n\tstd::vector<Tp> make_vector(\n\t\t\tstd::vector<size_t>& sizes,\n\t\t\ttypename std::enable_if<(N == 1), Tp const&>::type x\n\t) {\n\t\treturn std::vector<Tp>(sizes[0], x);\n\t}\n\ttemplate <typename Tp, size_t N>\n\tauto make_vector(\n\t\t\tstd::vector<size_t>& sizes,\n\t\t\ttypename std::enable_if<(N > 1), Tp const&>::type x\n\t) {\n\t\tsize_t size = sizes[N-1];\n\t\tsizes.pop_back();\n\t\treturn std::vector<decltype(make_vector<Tp, N-1>(sizes, x))>(\n\t\t\t\tsize, make_vector<Tp, N-1>(sizes, x)\n\t\t);\n\t}\n}\ntemplate <typename Tp, typename sizetype, size_t N>\nauto make_vector(sizetype const(&sizes)[N], Tp const& x = Tp()) {\n\tstd::vector<size_t> s(N);\n\tfor (size_t i = 0; i < N; ++i) s[i] = sizes[N-i-1];\n\treturn makevectordetail::make_vector<Tp, N>(s, x);\n}\n//vector<vector<vector<ll>>> v = make_vector<ll>({1, 2, 3}, 0LL);\n/*-----8<-----library-----8<-----*/\n\nstring S;ll K;\n//dp[l][r][k] 文字変更をk回行った状態で[l,r]間の回文の最大長\nvector<vector<vector<ll>>> dp;\nll f(ll l,ll r,ll k){\n\tif(dp[l][r][k])return dp[l][r][k];\n\t//0文字\n\tif(l==r)return dp[l][r][k]=1;\n\t//1文字\n\tif(r-l==1){\n\t\tif(S[l]==S[r])return dp[l][r][k]=2;\n\t\treturn dp[l][r][k]=1;\n\t}\n\n\tll ans=0;\n\t//左右に関係ない文字を追加しても回文長は同じ\n\tchmax(ans, f(l+1,r,k));\n\tchmax(ans, f(l,r-1,k));\n\n\tif(S[l]==S[r]){\n\t\t//文字が同じ → 回文長に2加算\n\t\tchmax(ans, f(l+1,r-1,k)+2);\n\t}else if(k<K){\n\t\t//文字変更して無理矢理一緒にする\n\t\tchmax(ans, f(l+1,r-1,k+1)+2);\n\t}\n\n\treturn dp[l][r][k]=ans;\n}\n\nvoid solve() {\n\t\n\tcin>>S>>K;\n\tdp = make_vector<ll>({S.size()+1, S.size()+1, (size_t)K+1}, 0);\n\n\tf(0, S.size()-1, 0);\n\tll ans=0;\n\trep(i,K+1)chmax(ans, dp[0][S.size()-1][i]);\n\tp(ans);\n}\n\nsigned main() {\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nint dp[400][400][400];\nsigned main(){\n\tstring s;int K;cin>>s>>K;\n\trep(i,s.size()){\n\t\tfor(int j=s.size()-1;j>i;j--){\n\t\t\trep(k,K+1){\n\t\t\t\tif(s[i]==s[j]){\n\t\t\t\t\tdp[i+1][j-1][k]=max(dp[i+1][j-1][k],dp[i][j][k]+1);\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tdp[i+1][j-1][k]=max(dp[i+1][j-1][k],dp[i][j][k]);\n\t\t\t\t\tdp[i+1][j][k]=max(dp[i+1][j][k],dp[i][j][k]);\n\t\t\t\t\tdp[i][j-1][k]=max(dp[i][j-1][k],dp[i][j][k]);\n\t\t\t\t\tif(k<K){\n\t\t\t\t\t\tdp[i+1][j-1][k+1]=max(dp[i+1][j-1][k+1],dp[i][j][k]+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint Max=0;\n\trep(i,s.size())rep(j,K+1){\n\t\tMax=max(Max,dp[i][i][j]);\n\t}\n\tif(Max%2==1)cout<<Max*2+1<<endl;\n\telse cout<<Max*2+2<<endl;\n\t//cout<<Max*2+2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_DEPRECATE\n#pragma comment(linker, \"/STACK:128777216\")\n\n#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <sstream>\n\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <bitset>\n#include <queue>\n#include <deque>\n#include <stack>\n\n#include <math.h>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <string.h>\n\n#include <memory.h>\n#include <cassert>\n#include <time.h>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i,n) for (int i = 0; i < (int)(n); i++)\n#define fornd(i, n) for (int i = (int)(n) - 1; i >= 0; i--)\n#define forab(i,a,b) for (int i = (int)(a); i <= (int)(b); i++)\n#define forabd(i, b, a) for (int i = (int)(b); i >= (int)(a); i--)\n#define forit(i, a) for (__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n\n#define _(a, val) memset (a, val, sizeof (a))\n#define sz(a) (int)((a).size())\n#define pb push_back\n#define mp make_pair\n#define all(v) (v).begin(), (v).end()\n\ntypedef long long lint;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef vector<int> vii;\n\nconst lint LINF = 1000000000000000000LL;\nconst int INF = 1000000000;\nconst long double eps = 1e-9;\nconst long double PI = 3.1415926535897932384626433832795l;\n\n#ifdef MY_DEBUG\n#define dbgx( x ) { cerr << #x << \" = \" << x << endl; }\n#define dbg( ... ) { fprintf(stderr, __VA_ARGS__); fflush(stderr); }\n#else\n#define dbgx( x ) {  } \n#define dbg( ... ) {  } \n#endif\n\nvoid prepare(string s) {\n#ifdef MY_DEBUG\n  freopen(\"input.txt\", \"r\", stdin);\n  //freopen (\"output.txt\", \"w\", stdout);\n#else\n  //freopen(\"input.txt\", \"r\", stdin);\n  //freopen (\"output.txt\", \"w\", stdout);\n#endif\n}\n\nconst int CMAX = 305;\n\nchar c[CMAX];\nint K;\nint d[CMAX][CMAX];\nint n;\n\nvoid read() {\n  scanf(\"%s\", c);\n  scanf(\" %d\", &K);\n}\n\nvoid solve() {\n  n = strlen(c);\n  _(d, 0);\n  forn(i, n) {\n    d[i][i] = 1;\n  }\n  for (int L = 2; L <= n; ++L) {\n    for (int i = 0; i < n - L + 1; ++i) {\n      int j = i + L - 1;\n      d[i][j] = max(d[i + 1][j], d[i][j - 1]);\n      if (c[i] == c[j])\n        d[i][j] = max(d[i][j], 2 + d[i + 1][j - 1]);\n    }\n  }\n  printf(\"%d\\n\", min(n, d[0][n - 1] + 2*K));\n}\n\nint main() {\n  prepare(\"\");\n\n  read();\n  solve();\n  dbg(\"Clock = %.3f\\n\", clock() / (double)CLOCKS_PER_SEC);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.hpp\n//  HelloWorld\n//\n//  Created by Vipul Sharma on 2/17/18.\n//  Copyright © 2018 Vipul Sharma. All rights reserved.\n//  vipsharmavip@gmail.com [' . '] :)\n\n#include<bits/stdc++.h>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<cmath>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<stack>\n#include<queue>\n#include<cstring>\n#define up 1\n#define right 2\n#define down 3\n#define left 4\n#define mod 1000000007\n#define ll long long\n\nusing namespace std;\n\nstring x;\nint k;\nint dp[300][300][301];\n\nint go(int i, int j, int k){\n    if(i > j) return 0;\n    if(i == j) return 1;\n    if(dp[i][j][k] != -1) return dp[i][j][k];\n    int ans = 0;\n    if(x[i] == x[j])  ans = 2 + go(i + 1, j - 1, k); else\n    {\n        ans = max(go(i + 1, j, k), go(i, j - 1, k));\n        if(k)\n            ans = max(ans, 2 + go(i + 1, j - 1, k - 1));\n    }\n    return dp[i][j][k] = ans;\n}\n\nint main(){\n    \n    cin.sync_with_stdio(false);\n    cin >> x >> k;\n    memset(dp, -1, sizeof dp);\n    cout << go(0, x.size() - 1, k);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define Kafuu signed\n#define Chino main\n\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n\n#define maxn 305\n#define inf 0x3f3f3f3f\n#define px putchar\n#define pn px('\\n')\n#define ps px(' ')\n#define pd puts(\"======================\")\n#define pj puts(\"++++++++++++++++++++++\")\n\nusing namespace std;\n\ninline int read(){\n\tint x=0,y=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn y?-x:x;\n}\ntemplate<typename T>\ninline T read(){\n\tT x=0;\n\tint y=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn y?-x:x;\n}\nint f[2][maxn][maxn];\nchar s[maxn];\nKafuu Chino(){\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1),k=read();\n\tmemset(f,~0x3f,sizeof f);\n\tfor(register int i=1;i<=n;++i)f[0][i][i]=1;\n\tfor(register int i=0;i<=k;++i)\n\t\tfor(register int len=2;len<=n;++len)\n\t\t\tfor(register int st=1,en=st+len-1;en<=n;++st,++en)\n\t\t\t\tf[i&1][st][en]=max(max(f[i&1][st+1][en],f[i&1][st][en-1]),f[i&1^(s[st]!=s[en])][st+1][en-1]+2);\n\tprintf(\"%d\\n\",f[k&1][1][n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll     = long long;\nusing pii    = pair<int, int>;\nusing pll    = pair<ll, ll>;\nusing vi     = vector<int>;\nusing vl     = vector<ll>;\nusing vvi    = vector<vi>;\nusing vvl    = vector<vl>;\nconst ll INF = 1LL << 60;\nconst ll MOD = 1000000007;\ntemplate <class T>\nbool chmax(T &a, const T &b) {\n    return (a < b) ? (a = b, 1) : 0;\n}\ntemplate <class T>\nbool chmin(T &a, const T &b) {\n    return (b < a) ? (a = b, 1) : 0;\n}\ntemplate <class C>\nvoid print(const C &c, std::ostream &os = std::cout) {\n    std::copy(std::begin(c), std::end(c), std::ostream_iterator<typename C::value_type>(os, \" \"));\n    os << std::endl;\n}\n\nint main() {\n    string s;\n    cin >> s;\n    int k;\n    cin >> k;\n    int n    = s.size();\n    string t = s;\n    reverse(t.begin(), t.end());\n    vector<vvi> dp(n + 5, vvi(n + 5, vi(k + 5, 0)));\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 0; j <= n; ++j) {\n            for (int l = 0; l <= k; ++l) {\n                chmax(dp[i + 1][j][l], dp[i][j][l]);\n                chmax(dp[i][j + 1][l], dp[i][j][l]);\n                if (s[i] == t[j]) {\n                    chmax(dp[i + 1][j + 1][l], dp[i][j][l] + 1);\n                } else {\n                    chmax(dp[i + 1][j + 1][l + 1], dp[i][j][l] + 1);\n                }\n            }\n        }\n    }\n    int ret = 0;\n    for (int i = 0; i <= n; ++i) {\n        chmax(ret, dp[i][n - i][k] * 2);\n    }\n    for (int i = 0; i < n; ++i) {\n        chmax(ret, dp[i][n - 1 - i][k] * 2 + 1);\n    }\n    cout << ret << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 310;\n\nint dp[N][N][N];\nstring s;\n\nint f(int i, int j, int k) {\n    if (dp[i][j][k] != -1) {\n        return dp[i][j][k];\n    }\n    if (i > j) {\n        return dp[i][j][k] = 0;\n    }\n    if (i == j) {\n        return dp[i][j][k] = 1;\n    }\n    if (s[i] == s[j]) {\n        return dp[i][j][k] = f(i + 1, j - 1, k) + 2;\n    }\n    dp[i][j][k] = 0;\n    if (k) {\n        dp[i][j][k] = f(i + 1, j - 1, k - 1) + 2;\n    }\n    dp[i][j][k] = max(dp[i][j][k], f(i + 1, j, k));\n    dp[i][j][k] = max(dp[i][j][k], f(i, j - 1, k));\n    return dp[i][j][k];\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int k;\n    cin >> s >> k;\n    int n = s.length();\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            for (int k = 0; k < N; ++k) {\n                dp[i][j][k] = -1;\n            }\n        }\n    }\n    cout << f(0, n - 1, k);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nconst int MAXN = 300 + 10;\n\nchar s[MAXN];\nint k, n;\ninline void chmax(int &x, int y) {\n  x = std::max(x, y);\n}\nnamespace solver1 {\n  int f[MAXN][MAXN][MAXN];\n  void main() {\n    for (int i = 1; i <= n; i++) {\n      for (int j = n; j > i; j--) {\n        for (int t = k; t >= 0; t--) {\n          if (s[i] == s[j]) f[i][j][t] = f[i - 1][j + 1][t] + 1;\n          chmax(f[i][j][t], f[i - 1][j][t]);\n          chmax(f[i][j][t], f[i][j + 1][t]);\n          if (t == k) continue;\n          chmax(f[i][j][t], f[i][j][t + 1]);\n          chmax(f[i][j][t], f[i - 1][j][t + 1] + 1);\n          chmax(f[i][j][t], f[i][j + 1][t + 1] + 1);\n          if (t + 1 == k) continue;\n          chmax(f[i][j][t], f[i - 1][j + 1][t + 2] + 1);\n        }\n      }\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n      for (int j = 0; j <= k; j++) {\n        chmax(ans, f[i][i + 1][j] * 2);\n        chmax(ans, f[i][i + 2][j] * 2 + 1);\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n}\nint main() {\n  scanf(\"%s\", s + 1);\n  n = strlen(s + 1);\n  scanf(\"%d\", &k);\n  solver1::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(int x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(int x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 200010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\n\nint n,K;\n\nchar s[310];\n\nint f[305][305][305];\n\nint main(){\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tread(K);\n\tREP(k,0,K)\n\t\tRREP(i,n,1){\n\t\t\tf[i][i][k]=1;\n\t\t\tREP(j,i+1,n){\n\t\t\t\tf[i][j][k]=max(f[i+1][j][k],f[i][j-1][k]);\n\t\t\t\tif(s[i]==s[j])f[i][j][k]=max(f[i][j][k],f[i+1][j-1][k]+2);\n\t\t\t\tif(k)f[i][j][k]=max(f[i][j][k],f[i+1][j-1][k-1]+2);\n\t\t\t}\n\t\t}\n\tiout(f[1][n][K]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, X, dp[301][301][301];\nstring s;\nint main(){\n    cin>>s>>X;n=s.size();    \n    for (int i=0; i<n; i++)\n\t\tfor (int x=0; x<=X; x++)dp[x][i][i]=1;\n\tfor (int x=0; x<=X; x++)\n\t\tfor (int k=1; k<n; k++)\n\t\t\tfor (int l=0, r=k; l+k<n; l++, r=l+k)\n\t\t\t\tdp[x][l][r]=max(max(dp[x][l][r-1], dp[x][l+1][r]),\n\t\t\t\t\t\t\tdp[max(x-min(1,abs(s[l]-s[r])), 0)][l+1][r-1]+\n\t\t\t\t\t\t\t2*min(1, (min(1, x)+(1-min(1,abs(s[l]-s[r]))))));\n    cout<<dp[X][0][n-1]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <array>\n#include <list>\n#include <stack>\n#include <valarray>\n\nusing namespace std;\n\ntypedef unsigned uint;\ntypedef long long Int;\ntypedef unsigned long long UInt;\n\nconst int INF = 1001001001;\nconst Int INFLL = 1001001001001001001LL;\n\ntemplate<typename T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<typename T> void chmin(T& a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T& a, T b) { if (a < b) a = b; }\nint in() { int x; scanf(\"%d\", &x); return x; }\ndouble fin() { double x; scanf(\"%lf\", &x); return x; }\nInt lin() { Int x; scanf(\"%lld\", &x); return x; }\n\nchar S[333];\nint K;\nint memo[333][333][333];\n\nint solve(int a, int b, int u) {\n  if (memo[a][b][u] >= 0) {\n    return memo[a][b][u];\n  }\n  int& r = memo[a][b][u];\n  if (a > b) {\n    return r = 0;\n  }\n  if (a == b) {\n    return r = 1;\n  }\n\n  if (S[a] == S[b]) {\n    return r = solve(a + 1, b - 1, u) + 2;\n  }\n  r = 0;\n  chmax(r, solve(a + 1, b, u));\n  chmax(r, solve(a, b - 1, u));\n  if (u > 0) {\n    chmax(r, solve(a + 1, b - 1, u - 1) + 2);\n  }\n  return r;\n}\n\nint main() {\n  scanf(\"%s\", S);\n  K = in();\n  const int L = strlen(S);\n  for (int i = 0; i <= L; ++i) {\n    for (int j = 0; j <= L; ++j) {\n      fill(memo[i][j], memo[i][j] + L + 1, -1);\n    }\n  }\n\n  printf(\"%d\\n\", solve(0, strlen(S) - 1, K));\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define int long long\n\n#define all(X) (X).begin(), (X).end()\n#define reset(X) memset(X, 0, sizeof(X))\n#define mp(a, b) make_pair(a, b)\n#define pb push_back\n#define endl '\\n'\n#define fi first\n#define se second\n\nusing namespace __gnu_pbds;\nusing namespace std;\nconst int mod = 1e9 + 7;\n// const int mod=998244353;\n//const int mod=1e9+9;\n//const int INF=4e18+10;\nconst int INF = 4e18 + 10;\ntemplate <typename T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T>\nusing ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define read(n) \\\nint n;      \\\ncin >> n;\n#define readv(x, n)   \\\nvector<int> x(n); \\\nfor (auto &i : x) \\\n    cin >> i;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> pii;\n\ntemplate <typename T1, typename T2>\nvoid set_min(T1 &a, T2 b)\n{\n    a = min(a, (T1)b);\n}\n\nint multiply(int a, int b, int in_mod) { return (a * b) % in_mod; }\nint mult_identity(int a) { return 1; }\n\n\nauto power(auto a, int b, int in_mod)\n{\n    auto prod = mult_identity(a);\n    auto mult = a % in_mod;\n    while (b != 0)\n    {\n        if (b % 2)\n        {\n            prod = multiply(prod, mult, in_mod);\n        }\n        mult = multiply(mult, mult, in_mod);\n        b /= 2;\n    }\n    return prod;\n}\nint mod_inv(int q, int in_mod)\n{\n\n    return power(q, in_mod - 2, in_mod);\n}\n\n\nconst int MAXN = 1e5+100;\nint parent[MAXN];\nvoid build()\n{\n    for(int i=0;i<MAXN;i++)\n        parent[i] = i;\n}\n\nint find_set(int u)\n{\n    if( u== parent[u])\n        return u;\n    return parent[u] = find_set(parent[u]);\n}\nvoid merge(int u, int v)\n{\n    u= find_set(u);\n    v= find_set(v);\n    if(u!=v)\n    {\n        if(rand()%2)\n            swap(u,v);\n        parent[v] = u;\n    }\n\n}\n\nvoid solve()\n{\n    string s;\n    cin>>s;\n    int k;\n    cin>>k;\n    int n= s.size();\n    string c = s;\n    reverse(all(c));\n    k*=2;\n    vector<vector<int>> dp(n+1, vector<int>(n+1));\n\n    int mx= 0;\n    for(int _k= 0;_k<=k;_k++)\n    {\n        for(int i= 1;i<=n;i++)\n        {\n            for(int j=1;j<=n;j++)\n            {\n                if(c[i-1] == s[j-1])\n                    dp[i][j] = dp[i-1][j-1] + 1;\n                else\n                {\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n                    if(_k)\n                        dp[i][j] = max(dp[i][j], dp[i-1][j-1] + 1);\n                }\n            }\n        }\n        mx = max(mx, dp[n][n]);\n    }\n    cout<<mx<<endl;\n\n}\n\n\n\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cerr.tie(NULL);\n#ifndef ONLINE_JUDGE\n    if (fopen(\"INPUT.txt\", \"r\"))\n    {\n        freopen(\"INPUT.txt\", \"r\", stdin);\n        freopen(\"OUTPUT.txt\", \"w\", stdout);\n    }\n#endif\n    auto clk = clock();\n    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n    // -------------------------------------Code starts here---------------------------------------------------------------------\n\n    int t = 1;\n    // cin >> t;\n\n    for (int test = 1; test <= t; test++)\n    {\n        // cout<<\"Case #\"<<test<<\":\\n\";\n        //cout<<\"Trip #\"<<test<<\": \";\n        // cout<<endl;\n        solve();\n        // solveB();\n\n        // cout<<endl;\n    }\n\n    // -------------------------------------Code ends here------------------------------------------------------------------\n\n    clk = clock() - clk;\n    // cerr << fixed << setprecision(6) << \"Time: \" << ((long double)clk) / CLOCKS_PER_SEC << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// G++ MACRO.CPP -STD=C++14\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\nconst ll LINF = 1e18;\nusing namespace std;\n\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\"  ) << endl\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\"  ) << endl\n#define POSSIBLE(n) cout << ((n) ? \"POSSIBLE\" : \"IMPOSSIBLE\"  ) << endl\n#define Possible(n) cout << ((n) ? \"Possible\" : \"Impossible\"  ) << endl\n#define possible(n) cout << ((n) ? \"possible\" : \"impossible\"  ) << endl\n\n#define SANKOU(n,a,b) cout << ((n) ? (#a) : (#b) ) << endl\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define REPR(i,n) for(int i=n;i>=0;i--)\n\n#define FOREACH(x,a) for(auto& (x) : (a) )\n\n#define WFA(d,v) REP(k,v)REP(i,v)REP(j,v)d[i][j]=min(d[i][j],d[i][k]+d[k][j])\n\n#define SCOUT(x) cout<<(x)<<\" \"\n#define ENDL cout<<endl\n\n#define VECCIN(x) for(auto&youso_: (x) )cin>>youso_\n#define VECIN2(x,y) REP(i,x.size())cin>>x[i]>>y[i]\n#define VECCOUT(x) for(auto tt=x.begin();tt!=x.end();tt++){if(tt!=x.begin())cout<<\" \";cout<<(*tt);}cout<<endl\n\n#define ALL(obj) (obj).begin(),(obj).end()\n\n#define EXIST(n,x) (find(ALL(n),x)!=n.end())\n#define UNIQUE(obj) sort(ALL( obj )); obj.erase(unique(ALL(obj)),obj.end())\n#define COUT(x) cout<<(x)<<endl\nvoid CINT(){}\ntemplate <class Head,class... Tail>\nvoid CINT(Head&& head,Tail&&... tail){\n    cin>>head;\n    CINT(move(tail)...);\n}\n#define CIN(...) int __VA_ARGS__;CINT(__VA_ARGS__)\n#define LCIN(...) ll __VA_ARGS__;CINT(__VA_ARGS__)\n#define SCIN(...) string __VA_ARGS__;CINT(__VA_ARGS__)\n\ntemplate <class T = ll>\nT IN(){T x;cin>>x;return (x);}\n\ntemplate <class Head>\nvoid VT(Head head){}\ntemplate <class Head,class Seco,class... Tail>\nvoid VT(Head&& head,Seco&& seco,Tail&&... tail){\n    seco.resize(head);\n    VT(head,move(tail)...);\n}\nvoid VT2(){}\ntemplate <class Head,class... Tail>\nvoid VT2(Head&& head,Tail&&... tail){\n  VECCIN(head);\n  VT2(move(tail)...);\n}\n\ntemplate <class Head>\nvoid VT3(Head&& head){}\ntemplate <class Head,class Seco,class... Tail>\nvoid VT3(Head&& head,Seco&& seco,Tail&&... tail){\n  seco[head]=IN();\n  VT3(head,move(tail)...);\n}\n\n#define VC1(n,...) V __VA_ARGS__;VT(n,__VA_ARGS__);VT2(__VA_ARGS__); //aaabbbccc\n#define VC2(n,...) V __VA_ARGS__;VT(n,__VA_ARGS__);REP(i,n)VT3(i,__VA_ARGS__); //abcabcabc\n\n// #include <boost/multiprecision/cpp_int.hpp>\n// using namespace boost::multiprecision; // cpp_int\n\n#define P pair<int,int>\n#define V vector<int>\n#define M map<int,int>\n#define S set<int>\n#define PQ priority_queue<int>\n#define PQG priority_queue<int,V,greater<int>>\n\n#define str string\n\n#define pb(a) push_back(a)\n#define mp make_pair\n\nll calcDP(string s){ // O(n^2)\n  string t = s;reverse(ALL(t));\n  int n = s.size();\n  vector<V> dp(n+1,V(n+1,0));\n\n  REP(i,n)REP(j,n){\n    if(s[i]==t[j])dp[i+1][j+1] = dp[i][j]+1;\n    else dp[i+1][j+1] = max(dp[i][j+1],dp[i+1][j]);\n  }\n  // dump(dp[n][n]);\n  return dp[n][n];\n}\n\nint main(){\n  SCIN(s);CIN(k);\n  int n = s.size();\n\n  ll ans=0;\n\n  REP(i,4){\n    string s2 = s;\n    int count=0;\n    if(i==1)REP(j,k)s2[j]=s2[n-1-j];\n    if(i==2)FOR(j,(n+1)/2,min((n+1)/2+k,n))s2[j]=s2[n-1-j];\n    if(i==3)for(int j=n/2;j>=max(n/2-k+1,0);--j)s2[j]=s2[n-1-j];\n    else REP(j,k)s2[n-1-j]=s2[j];\n    // dump(s2);\n    ans=max(ans,calcDP(s2));\n  }\n\n  COUT(ans);\n\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// In the Name of Allah. Ya Ali!\n#include<bits/stdc++.h>\n#define bp __builtin_popcount\ntypedef long long ll;\nconst ll MAX_N = 300+5;\nconst ll MOD = 1e9+7;\nusing namespace std;\n\nint dp[MAX_N][MAX_N][MAX_N];\nint a[MAX_N];\nint n,k;\n\nint main()\n{\n    string s;\n    cin >> s >> k;\n    n = s.length();\n    for(int i = 1;i<=n;++i)\n        a[i] = (s[i-1]-'a');\n    for(int i = 1;i<=n;++i)\n        for(int j = 0;j<=n;++j)\n            dp[1][i][j] = 1;\n    for(int i = 2;i<=n;++i)\n    {\n        for(int j = 1;j<=n-i+1;++j)\n        {\n            for(int t = 0;t<=n;++t)\n            {\n                dp[i][j][t] = max(dp[i-1][j][t],dp[i-1][j+1][t]);\n                if (t-(a[j]!=a[j+i-1])>=0)\n                    dp[i][j][t] = max(dp[i][j][t],dp[i-2][j+1][t-(a[j]!=a[j+i-1])]+2);\n            }\n        }\n    }\n    cout << dp[n][1][k];\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<int, ll> i_ll;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, int> d_i;\nconst int MOD = 1e9 + 7;\nconst ll INF = LLONG_MAX / 10;\nstruct edge { int v, w; };\n\nint dp[310][310][310];\n\nint main() {\n\tstring s; cin >> s;\n\tint N = s.length();\n\tint K; cin >> K;\n\tfor (int d = N; d >= 1; d--)\n\t\tfor (int l = 0; l + d <= N; l++) {\n\t\t\tint r = l + d;\n\t\t\trep(k, K + 1) {\n\t\t\t\tint x = dp[l][r][k];\n\t\t\t\tdp[l + 1][r][k] = max(dp[l + 1][r][k], x);\n\t\t\t\tdp[l][r - 1][k] = max(dp[l][r - 1][k], x);\n\t\t\t\tif (d == 1) continue;\n\t\t\t\tif (s[l] == s[r - 1])\n\t\t\t\t\tdp[l + 1][r - 1][k] = max(dp[l + 1][r - 1][k], x + 1);\n\t\t\t\tif (k + 1 <= K)\n\t\t\t\t\tdp[l + 1][r - 1][k + 1] = max(dp[l + 1][r - 1][k + 1], x + 1);\n\t\t\t}\n\t\t}\n\tint ans = 0;\n\tfor (int l = 0; l <= N; l++) ans = max(ans, dp[l][l][K] * 2);\n\tfor (int l = 0; l + 1 <= N; l++)\n\t\tans = max(ans, dp[l][l + 1][K] * 2 + 1);\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define rep(i, s, t) for(i = s; i <= t; ++i)\n#define dep(i, s, t) for(i = s; i >= t; --i)\n\nusing namespace std;\n\nconst int N = 310;\nint n, m, K, ans;\nchar s[N], t[N];\nint f[N][N][N];\n\nint main() {\n\tint i, j, k;\n\tscanf(\"%s\", s+1); n = strlen(s+1);\n\tm = n >> 1;\n\trep(i, 1, n) t[i] = s[n-i+1];\n\t\n\tscanf(\"%d\", &K);\n\trep(i, 1, n-1) {\n\t\trep(j, 1, n-i) \n\t\t\trep(k, 0, K) {\n\t\t\t\tf[i][j][k] = max(f[i-1][j][k], f[i][j-1][k]);\n\t\t\t\tif(k) f[i][j][k] = max(f[i][j][k], f[i][j][k-1]);\n\t\t\t\tif(s[i] == t[j]) {\n\t\t\t\t\tf[i][j][k] = max(f[i-1][j-1][k]+1, f[i][j][k]);\n\t\t\t\t} else {\n\t\t\t\t\tif(k) f[i][j][k] = max(f[i-1][j-1][k-1]+1, f[i][j][k]);\n\t\t\t\t}\n\t\t\t\t//printf(\"%d %d %d %d\\n\", i, j, k, f[i][j][k]);\n\t\t\t}\n\t\tans = max(ans, f[i][n-i-1][K]*2+1);\n\t\tans = max(ans, f[i][n-i][K]*2);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<iomanip>\n#include<bitset>\nusing namespace std;\n\nconst int N = 310;\n\nint n, k, d[N][N][N];\nchar s[N];\n\nint main() {\n    int i, j, l;\n    //freopen(\"tttt\", \"r\", stdin);\n\n    cin >> (s + 1);\n    cin >> k;\n\n    n = strlen(s + 1);\n\n    for(i = 1; i <= n; ++i) {\n        for(j = n; j; --j) {\n\n            for(l = 0; l <= k; ++l) {\n                d[i][j][l] = max(d[i - 1][j][l], d[i][j + 1][l]);\n\n                if(s[i] == s[j]) {\n                    d[i][j][l] = max(d[i][j][l], d[i - 1][j + 1][l] + 1);\n                }\n                else if(l) {\n                    d[i][j][l] = max(d[i][j][l], d[i - 1][j + 1][l - 1] + 1);\n                }\n            }\n\n        }\n    }\n\n    int r = 0;\n\n    for(i = 1; i <= n; ++i) {\n        r = max(r, d[i - 1][i + 1][k] * 2 + 1);\n        r = max(r, d[i - 1][i][k] * 2);\n    }\n\n    cout << r;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nstring S;\nint dp[305][305][305];\nint K;\n\nint main() {\n    //cout.precision(10);\n    cin >> S;\n    cin >> K;\n    int n = S.size();\n    S = \"#\" + S;\n    int ans = 0;\n    for(int k = 0; k <= K; k++) {\n        for(int i = 0; i <= n; i++) {\n            for(int j = n + 1; j >= max(1, i); j--) {\n                ans = max(ans, dp[i][j][k]);\n                //cerr << i << \" \" << j << \" \" << k << \" \" << dp[i][j][k] << endl;\n                dp[i+1][j][k] = max(dp[i+1][j][k], dp[i][j][k]);\n                dp[i][j-1][k] = max(dp[i][j-1][k], dp[i][j][k]);\n                if(S[i+1] == S[j-1]) {\n                    if(i+1 == j-1) dp[i+1][j-1][k] = max(dp[i+1][j-1][k], dp[i][j][k]+1);\n                    else dp[i+1][j-1][k] = max(dp[i+1][j-1][k], dp[i][j][k] + 2);\n                }\n                if(i+1 == j-1) dp[i+1][j-1][k+1] = max(dp[i+1][j-1][k+1], dp[i][j][k] + 1);\n                else dp[i+1][j-1][k+1] = max(dp[i+1][j-1][k+1], dp[i][j][k] + 2);\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n#include <cstdio>\n#include <iostream>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n//#ifdef atom #else #endif\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\n#define X first\n#define Y second\n#define vi vector<int>\n#define vvi vector< vi >\n#define vii vector< ii >\n#define mp make_pair\n#define pb push_back\nstring s;\nint k;\nconst int maxn = 305;\nconst int maxk = 305;\nint dp[maxn][maxn][maxk];\nint n;\nint solve(int i, int j, int k)\n{\n    if(i> j) return 0;\n    if(dp[i][j][k] != -1) return dp[i][j][k];\n    int add = 2;\n    int res = 0;\n    if(i == j) add = 1;\n    res = max(res, solve(i+1, j, k));\n    res = max(res, solve(i, j-1, k));\n    if(s[i] == s[j]) res = max(res, add+solve(i+1, j-1, k));\n    if(k) res = max(res, add+solve(i+1, j-1, k-1));\n    return dp[i][j][k] = res;\n}\nint main()\n{\n    //#ifndef atom freopen(\".in\", \"r\", stdin); freopen(\".out\", \"w\", stdout); #endif\n    cin >> s >> k;\n    n = s.size();\n    memset(dp, -1, sizeof dp);\n    //cout << solve(1, 4, 0) << endl;\n    cout << solve(0, n-1, k) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#undef _DEBUG\n//#pragma GCC optimize(\"Ofast\")\n//不動小数点の計算高速化\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace std::chrono;\n#define int long long //todo 消したら動かない intの代わりにsignedを使う\n#define ll long long\nauto start_time = system_clock::now();\nauto past_time = system_clock::now();\n\n#define debugName(VariableName) # VariableName\n//最大引数がN\n#define over2(o1, o2, name, ...) name\n#define over3(o1, o2, o3, name, ...) name\n#define over4(o1, o2, o3, o4, name, ...) name\n#define over5(o1, o2, o3, o4, o5, name, ...) name\n#define over6(o1, o2, o3, o4, o5, o6, name, ...) name\n#define over7(o1, o2, o3, o4, o5, o6, o7, name, ...) name\n#define over8(o1, o2, o3, o4, o5, o6, o7, o8, name, ...) name\n#define over9(o1, o2, o3, o4, o5, o6, o7, o8, o9, name, ...) name\n#define over10(o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, name, ...) name\n\n\n/*@formatter:off*/\n//[-n, n)にアクセスできる\n//また、外部関数resizeに渡せる\n//sizeは[-n, n)でnを返す\ntemplate<class T> class mvec {    vector<T> v;    int n;public:    mvec() : n(0), v(0) {}    mvec(int n) : n(n), v(n * 2) {}    mvec(int n, T val) : n(n), v(n * 2, val) {}    auto &operator[](int i) { return v[i + n]; }    auto size() { return n; }    void resize(int sn) {        assert(n == 0);        n = sn;        v.resize(sn * 2);    }    auto begin() { return v.begin(); }    auto rbegin() { return v.rbegin(); }    auto end() { return v.end(); }    auto rend() { return v.rend(); }};\n//[]でboolは参照を返さないため特殊化が必要\ntemplate<> struct mvec<bool> {    vector<bool> v;    int n;    mvec() : n(0), v(0) {}    mvec(int n) : n(n), v(n * 2) {}    mvec(int n, bool val) : n(n), v(n * 2, val) {}    auto operator[](int i) { return v[i + n]; }    auto size() { return v.size(); }    void resize(int sn) {        assert(n == 0);        n = sn;        v.resize(sn * 2);    }    auto begin() { return v.begin(); }    auto rbegin() { return v.rbegin(); }    auto end() { return v.end(); }    auto rend() { return v.rend(); }};\ntemplate<class T>ostream &operator<<(ostream &os, mvec<T>& a) {    int spa = 3;    for(auto&&v : a){        spa = max(spa,(int)(to_string(v).size())+1);    }    int n = (int)a.size();    os<<endl;    for (int i = -n; i < n; i++){        int need = spa - ((int)to_string(i).size());        if(i==-n){            need -= min(need,spa - ((int)to_string(a[i]).size()));        }        while(need--){            os<<\" \";        }        os<<i;    }    os<<endl;    int i=-n;    for(auto&&v : a){        int need = spa - ((int)to_string(v).size());        if(i==-n){            need -= min(need,spa - ((int)to_string(i).size()));        }        while(need--){            os<<\" \";        }        os<<v;        i++;    }    return os;}\n#define mv mvec\n#define MV mvec\nusing mvi = mvec<ll>;\nusing mvb = mvec<bool>;\nusing mvs = mvec<string>;\nusing mvd = mvec<double>;\nusing mvc = mvec<char>;\n\n#define mvvt0(t) mvec<mvec<t>>\n#define mvvt1(t,a) mvec<mvec<t>>a\n#define mvvt2(t,a, b) mvec<mvec<t>>a(b)\n#define mvvt3(t,a, b, c) mvec<mvec<t>> a(b,mvec<t>(c))\n#define mvvt4(t,a, b, c, d) mvec<mvec<t>> a(b,mvec<t>(c,d))\n#define mvvi(...) over4(__VA_ARGS__,mvvt4,mvvt3,mvvt2 ,mvvt1,mvvt0)(ll,__VA_ARGS__)\n\ntemplate<typename T> mvec<T> make_mv(size_t a) { return mvec<T>(a); }\ntemplate<typename T, typename... Ts> auto make_mv(size_t a, Ts... ts) {return mvec<decltype(make_mv<T>(ts...))>(a, make_mv<T>(ts...));}\n#define mvni(name, ...) auto name = make_mv<ll>(__VA_ARGS__)\n\n\n#ifdef _DEBUG\nstring message;\n//https://marycore.jp/prog/cpp/class-extension-methods/ 違うかも\ntemplate<class T, class A = std::allocator<T>> struct debtor : std::vector<T, A> {\n    using std::vector<T, A>::vector;\n    template<class U> int deb_v(U a, int v) { return v; }\n    template<class U> int deb_v(debtor<U> &a, int v = 0) {cerr << a.size() << \" \";return deb_v(a.at(0), v + 1);}\n    template<class U> void deb_o(U a) { cerr << a << \" \"; }\n    template<class U> void deb_o(debtor<U> &a) {for (int i = 0; i < min((int) a.size(), 15ll); i++) { deb_o(a[i]); }if ((int) a.size() > 15) { cerr << \"...\"; }cerr << endl;}\n    typename std::vector<T>::reference operator[](typename std::vector<T>::size_type n) {        if (n < 0 || n >= (int) this->size()) {            int siz = (int) this->size();            cerr << \"vector size = \";            int dim = deb_v((*this));            cerr << endl;            cerr << \"out index at  \" << n << endl;            cerr << endl;            if (dim <= 2) { deb_o((*this)); }            exit(0);        }return this->at(n);}\n};\n//#define vector debtor\n//区間削除は出来ない\ntemplate<class T> struct my_pbds_tree {    set<T> s;    auto begin() { return s.begin(); }    auto end() { return s.end(); }    auto rbegin() { return s.rbegin(); }    auto rend() { return s.rend(); }    auto empty() { return s.empty(); }    auto size() { return s.size(); }    void clear() { s.clear(); }    template<class U> void insert(U v) { s.insert(v); }template<class U> void operator+=(U v) { insert(v); }    template<class F> auto erase(F v) { return s.erase(v); }    template<class U> auto find(U v) { return s.find(v); }    template<class U> auto lower_bound(U v) { return s.lower_bound(v); }    template<class U> auto upper_bound(U v) { return s.upper_bound(v); }    auto find_by_order(ll k) {        auto it = s.begin();        for (ll i = 0; i < k; i++)it++;        return it;    }    auto order_of_key(ll v) {        auto it = s.begin();        ll i=0;        for (;it != s.end() && *it <v ; i++)it++;        return i;    }};\n#define pbds(T) my_pbds_tree<T>\n//gp_hash_tableでcountを使えないようにするため\ntemplate<class T,class U> struct my_unordered_map{    unordered_map<T,U> m;    my_unordered_map(){};    auto begin(){        return m.begin();    }    auto end(){return m.end();}    auto cbegin(){return m.cbegin();}    auto cend(){return m.cend();}    template<class V>auto erase(V v){return m.erase(v);}    void clear(){m.clear();}    /*countは gp_hash_tableに存在しない*/    /*!= m.end()*/    template<class V>auto find(V v){return m.find(v);}    template<class V>auto & operator [](V n) { return m[n] ;}};\n#define unordered_map my_unordered_map\n#define umapi unordered_map<ll,ll>\n#define umapp unordered_map<P,ll>\n#define umapu unordered_map<uint64_t,ll>\n#define umapip unordered_map<ll,P>\n\n#else\n#define endl '\\n'\n//umapはunorderd_mapになる\n//umapiはgp_hash_table\n\n//find_by_order(k) k番目のイテレーター\n//order_of_key(k)  k以上が前から何番目か\n#define pbds(U) __gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>\n\n#define umapi __gnu_pbds::gp_hash_table<ll,ll,xorshift>\n#define umapp __gnu_pbds::gp_hash_table<P,ll,xorshift>\n#define umapu __gnu_pbds::gp_hash_table<uint64_t,ll,xorshift>\n#define umapip __gnu_pbds::gp_hash_table<ll,P,xorshift>\n\n#endif\n/*@formatter:on*/\nstruct xorshift {\n    static uint64_t splitmix64(uint64_t x) {\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n    size_t operator()(std::pair<ll, ll> x) const {\n        ll v = ((x.first) << 32) | x.second;\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(v + FIXED_RANDOM);\n    }\n};\n/*@formatter:off*/\ntemplate<class U, class L> void operator+=(__gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update> &s, L v) { s.insert(v); }\n//衝突対策\n#define ws ws_\n\ntemplate<class A, class B, class C>struct T2 {A f;B s;C t;T2() { f = 0, s = 0, t = 0; }T2(A f, B s, C t) : f(f), s(s), t(t) {}bool operator<(const T2 &r) const {        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;        /*return f != r.f ? f > r.f : s != r.s ?n s > r.s : t > r.t; 大きい順 */   }    bool operator>(const T2 &r) const {        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;        /*return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順 */   }    bool operator==(const T2 &r) const {        return f == r.f && s == r.s && t == r.t;    }    bool operator!=(const T2 &r) const {        return f != r.f || s != r.s || t != r.t;    }};\ntemplate<class A, class B, class C, class D> struct F2 {    A a;    B b;    C c;    D d;    F2() { a = 0, b = 0, c = 0, d = 0; }    F2(A a, B b, C c, D d) : a(a), b(b), c(c), d(d) {}    bool operator<(const F2 &r) const {        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;    /*    return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;*/    }    bool operator>(const F2 &r) const {        return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;/*        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;*/    }    bool operator==(const F2 &r) const {        return a == r.a && b == r.b && c == r.c && d == r.d;    }    bool operator!=(const F2 &r) const {        return a != r.a || b != r.b || c != r.c || d != r.d;    }    ll operator[](ll i) {        assert(i < 4);        return i == 0 ? a : i == 1 ? b : i == 2 ? c : d;    }};\ntypedef T2<ll, ll, ll> T;\ntypedef F2<ll, ll, ll, ll> F;\nT mt(ll a, ll b, ll c) {return T(a, b, c);}\nF mf(ll a, ll b, ll c, ll d) {return F(a, b, c, d);}\n\n\n\n//@マクロ省略系 型,構造\n#define double long double\nusing dou = double;\nconst double eps = 1e-9;\n//基本コメントアウト\n/*\nstruct epsdou {    double v;    epsdou(double v = 0) : v(v) {}    template<class T> epsdou &operator+=(T b) {        v += (double) b;        return (*this);    }    template<class T> epsdou &operator-=(T b) {        v -= (double) b;        return (*this);    }    template<class T> epsdou &operator*=(T b) {        v *= (double) b;        return (*this);    }    template<class T> epsdou &operator/=(T b) {        v /= (double) b;        return (*this);    }    epsdou operator+(epsdou b) { return v + (double) b; }    epsdou operator-(epsdou b) { return v - (double) b; }    epsdou operator*(epsdou b) { return v * (double) b; }    epsdou operator/(epsdou b) { return v / (double) b; }    epsdou operator-() const { return epsdou(-v); }    template<class T> bool operator<(T b) { return v < (double) b; }    template<class T> bool operator>(T b) { return v > (double) b; }    template<class T> bool operator==(T b) { return fabs(v - (double) b) <= eps; }    template<class T> bool operator<=(T b) { return v < (double) b || fabs(v - b) <= eps; }    template<class T> bool operator>=(T b) { return v > (double) b || fabs(v - b) <= eps; }    operator double() { return v; }};istream &operator>>(istream &iss, epsdou &a) {    iss >> a.v;    return iss;}ostream &operator<<(ostream &os, epsdou &a) {    os << a.v;    return os;}\n#define eps_conr_t(o) template<class T> epsdou operator o(T b, epsdou a){return a.v o (dou)b;}\n#define eps_conl_t(o) template<class T> epsdou operator o(epsdou a, T b){return a.v o (dou)b;}\neps_conl_t(+)eps_conl_t(-)eps_conl_t(*)eps_conl_t(/)eps_conr_t(+)eps_conr_t(-)eps_conr_t(*)eps_conr_t(/)\n#undef double\n#define double epsdou\n*/\n\n#define ull unsigned long long\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\nusing mvp = mvec<P>;\nusing mvt = mvec<T>;\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\n\n#define fi first\n#define se second\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n#define el else\n#define elf else if\n#define upd update\n#define sstream stringstream\n\n#define maxq 1\n#define minq -1\n\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MALLOC(type, len) (type*)malloc((len) * sizeof(type))\n#define lam1(ret) [&](auto& v){return ret;}\n#define lam2(v, ret) [&](auto& v){return ret;}\n#define lam(...) over2(__VA_ARGS__,lam2,lam1)(__VA_ARGS__)\n#define lamr(right) [&](auto& p){return p right;}\n\n//マクロ省略系 コンテナ\nusing vi = vector<ll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vp = vector<P>;\nusing vt = vector<T>;\n\n//#define V vector\n#define vvt0(t) vector<vector<t>>\n#define vvt1(t,a) vector<vector<t>>a\n#define vvt2(t,a, b) vector<vector<t>>a(b)\n#define vvt3(t,a, b, c) vector<vector<t>> a(b,vector<t>(c))\n#define vvt4(t,a, b, c, d) vector<vector<t>> a(b,vector<t>(c,d))\n\n#define vvi(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(ll,__VA_ARGS__)\n#define vvb(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(bool,__VA_ARGS__)\n#define vvs(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(string,__VA_ARGS__)\n#define vvd(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(double,__VA_ARGS__)\n#define vvc(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(char,__VA_ARGS__)\n#define vvp(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(P,__VA_ARGS__)\n#define vvt(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(T,__VA_ARGS__)\n#define vv(type,...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(type,__VA_ARGS__)\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts> auto make_v(size_t a, Ts... ts) {return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));}\n#define vni(name, ...) auto name = make_v<ll>(__VA_ARGS__)\n#define vnb(name, ...) auto name = make_v<bool>(__VA_ARGS__)\n#define vns(name, ...) auto name = make_v<string>(__VA_ARGS__)\n#define vnd(name, ...) auto name = make_v<double>(__VA_ARGS__)\n#define vnc(name, ...) auto name = make_v<char>(__VA_ARGS__)\n#define vnp(name, ...) auto name = make_v<P>(__VA_ARGS__)\n#define vn(type,name, ...) auto name = make_v<type>(__VA_ARGS__)\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<ll, ll>;\nusing mapp = map<P, ll>;\nusing mapd = map<dou, ll>;\nusing mapc = map<char, ll>;\nusing maps = map<str, ll>;\nusing seti = set<ll>;\nusing setp = set<P>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<ll>;\n#define uset unordered_set\n#define useti unordered_set<ll,xorshift>\n#define mset multiset\n#define mseti multiset<ll>\n#define umap unordered_map\n#define mmap multimap\n//任意のマクロサポート用 使う度に初期化する\nint index_,v1_,v2_,v3_;\n\ntemplate<class T> struct pq {\n    priority_queue<T, vector<T>, greater<T> > q;/*小さい順*/    T su = 0;\n    void clear() {        q = priority_queue<T, vector<T>, greater<T> >();        su = 0;    }\n    void operator+=(T v) {        su += v;        q.push(v);    }\n    T sum() { return su; }\n    T top() { return q.top(); }\n    void pop() {        su -= q.top();        q.pop();    }\n    T poll() {        T ret = q.top();        su -= ret;        q.pop();        return ret;    }\n    ll size() { return q.size(); }\n};\ntemplate<class T> struct pqg {\n    priority_queue<T> q;/*大きい順*/    T su = 0;\n    void clear() {        q = priority_queue<T>();        su = 0;    }\n    void operator+=(T v) {        su += v;        q.push(v);    }\n    T sum() { return su; }\n    T top() { return q.top(); }\n    void pop() {        su -= q.top();        q.pop();    }\n    T poll() {        T ret = q.top();        su -= ret;        q.pop();        return ret;    }\n    ll size() { return q.size(); }\n};\n#define pqi pq<ll>\n#define pqgi pqg<ll>\n//マクロ 繰り返し\n//↓@オーバーロード隔離\n\n#define rep1(n) for(ll rep1i = 0,rep1lim=n; rep1i < rep1lim ; ++rep1i)\n#define rep2(i, n) for(ll i = 0,rep2lim=n; i < rep2lim ; ++i)\n#define rep3(i, m, n) for(ll i = m,rep3lim=n; i < rep3lim ; ++i)\n#define rep4(i, m, n, ad) for(ll i = m,rep4lim=n; i < rep4lim ; i+= ad)\n//逆順 閉区間\n#define rer2(i, n) for(ll i = n; i >= 0 ; i--)\n#define rer3(i, m, n) for(ll i = m,rer3lim=n; i >= rer3lim ; i--)\n#define rer4(i, m, n, dec) for(ll i = m,rer4lim=n; i >= rer4lim ; i-=dec)\n//ループを一つにまとめないとフォーマットで汚くなるため\n#define nex_ind1(i) i++\n#define nex_ind2(i, j, J) i = (j + 1 == J) ? i + 1 : i, j = (j + 1 == J ? 0 : j + 1)\n#define nex_ind3(i, j, k, J, K)i = (j + 1 == J && k + 1 == K) ? i + 1 : i, j = (k + 1 == K) ? (j + 1 == J ? 0 : j + 1) : j, k = (k + 1 == K ? 0 : k + 1)\n#define nex_ind4(i, j, k, l, J, K, L) i = (j + 1 == J && k + 1 == K && l + 1 == L) ? i + 1 : i, j = (k + 1 == K && l + 1 == L) ? (j + 1 == J ? 0 : j + 1) : j, k = (l + 1 == L ?(k + 1 == K ? 0 : k + 1) : k), l = l + 1 == L ? 0 : l + 1\n#define nex_ind5(i, j, k, l, m, J, K, L, M) i = (j + 1 == J && k + 1 == K && l + 1 == L && m + 1 == M) ? i + 1 : i, j = (k + 1 == K && l + 1 == L && m + 1 == M) ? (j + 1 == J ? 0 : j + 1) : j, k = (l + 1 == L && m + 1 == M ?(k + 1 == K ? 0 : k + 1) : k), l =  m + 1 == M ? l+1 == L ? 0 : l+1 : l,  m = m + 1 == M ? 0 : m + 1\n\n#define repss2(i, I) for (int i = 0; i < I; i++)\n#define repss4(i, j, I, J) for (int i = (J ? 0 : I), j = 0; i < I; nex_ind2(i, j, J))\n#define repss6(i, j, k, I, J, K) for (int i = (J && K ? 0 : I), j = 0, k = 0; i < I; nex_ind3(i, j, k, J, K))\n#define repss8(i, j, k, l, I, J, K, L) for (int i = (J && K && L ? 0 : I), j = 0, k = 0, l = 0; i < I; nex_ind4(i, j, k, l, J, K, L))\n#define repss10(i, j, k, l, m, I, J, K, L, M)for (int i = (J && K && L && M ? 0 : I), j = 0, k = 0, l = 0, m = 0; i < I; nex_ind5(i, j, k, l, m, J, K, L, M))\n\n//i,j,k...をnまで見る\n#define reps2(i, n) repss2(i, n)\n#define reps3(i, j, n) repss4(i, j, n, n)\n#define reps4(i, j, k, n) repss6(i, j, k, n, n, n)\n#define reps5(i, j, k, l, n) repss8(i, j, k, l, n, n, n, n)\n\ntemplate<class T>void nex_repv2(int&i,int&j,int&I, int&J,vector<vector<T>>&s){    while(1){        j++;        if(j >= J){            j=0;            i++;            if(i < I){                J = (int)s[i].size();            }        }        if(i >= I || J) return;    }}\ntemplate<class T> void nex_repv3(int &i, int &j, int &k, int &I, int &J, int &K, vector<vector<vector<T>>> &s) {    while (1) {        k++;        if (k >= K) {            k = 0;            j++;            if (j >= J) {                j = 0;                i++;                if (i >= I)return;            }        }        J = (int) s[i].size();        K = (int) s[i][j].size();        if (J && K) return;    }}\n\n#define repv_2(i,a) repss2(i, sz(a))\n//正方形である必要はない\n//直前を持つのとどっちが早いか\n#define repv_3(i, j, a) for (int I = (int)a.size(), J = (int)a[0].size(), i = 0, j = 0; i < I; nex_repv2(i,j,I,J,a))\n//箱状になっている事が要求される つまり[i] 次元目の要素数は一定\n#define repv_4(i, j, k, a) for (int I = (int)a.size(), J = (int)a[0].size(), K =(int)a[0][0].size(), i = 0, j = 0, k=0; i < I; nex_repv3(i,j,k,I,J,K,a))\n#define repv_5(i, j, k, l, a) repss8(i, j, k, l, sz(a), sz(a[0]), sz(a[0][0]), sz(a[0][0][0]))\n#define repv_6(i, j, k, l, m, a) repss10(i, j, k, l, m, sz(a), sz(a[0]), sz(a[0][0]), sz(a[0][0][0]), sz(a[0][0][0][0]))\n\ntemplate<typename T>struct has_rbegin_rend {private:template<typename U>static auto check(U &&obj) -> decltype(std::rbegin(obj), std::rend(obj), std::true_type{});static std::false_type check(...);public:static constexpr bool value = decltype(check(std::declval<T>()))::value;};template<typename T>constexpr bool has_rbegin_rend_v = has_rbegin_rend<T>::value;template<typename Iterator>class Range {public:Range(Iterator &&begin, Iterator &&end) noexcept: m_begin(std::forward<Iterator>(begin)), m_end(std::forward<Iterator>(end)) {}Iterator begin() const noexcept {return m_begin;}Iterator end() const noexcept {return m_end;}private:const Iterator m_begin;const Iterator m_end;};template<typename Iterator>static inline Range<Iterator>makeRange(Iterator &&begin, Iterator &&end) noexcept {return Range<Iterator>{std::forward<Iterator>(begin), std::forward<Iterator>(end)};}template<typename T>static inline decltype(auto) makeReversedRange(const std::initializer_list<T> &iniList) noexcept {return makeRange(std::rbegin(iniList), std::rend(iniList));}template<typename T,typename std::enable_if_t<has_rbegin_rend_v<T>, std::nullptr_t> = nullptr>static inline decltype(auto)makeReversedRange(T &&c) noexcept {return makeRange(std::rbegin(c), std::rend(c));}/* rbegin(), rend()を持たないものはこっちに分岐させて，エラーメッセージを少なくする*/template<typename T,typename std::enable_if<!has_rbegin_rend<T>::value, std::nullptr_t>::type = nullptr>static inline void makeReversedRange(T &&) noexcept {static_assert(has_rbegin_rend<T>::value, \"Specified argument doesn't have reverse iterator.\");}\n\n#define form1(st) for (auto &&form_it = st.begin(); form_it != st.end(); ++form_it)\n#define form3(k, v, st) for (auto &&form_it = st.begin(); form_it != st.end(); ++form_it)\n#define form4(k, v, st, r) for (auto &&form_it = st.begin(); form_it != st.end() && (*form_it).fi < r; ++form_it)\n#define form5(k, v, st, l, r) for (auto &&form_it = st.lower_bound(l); form_it != st.end() && (*form_it).fi < r; ++form_it)\n\n#define fors1(st) for (auto &&fors_it = st.begin(); fors_it != st.end(); ++fors_it)\n#define fors2(v, st) for (auto &&fors_it = st.begin(); fors_it != st.end(); ++fors_it)\n#define fors3(v, st, r) for (auto &&fors_it = st.begin(); fors_it != st.end() && (*fors_it) < r; ++fors_it)\n#define fors4(v, st, l, r) for (auto &&fors_it = st.lower_bound(l); fors_it != st.end() && (*fors_it) < r; ++fors_it)\n\n#define forslr3(st, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end(); ++forslr_it)\n#define forslr4(v, st, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end(); ++forslr_it)\n#define forslr5(v, st, r, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end() && (*forslr_it) < r; ++forslr_it)\n#define forslr6(v, st, l, r, a, b) for (auto &&forslr_it = st.lower_bound(l); forslr_it != st.end() && (*forslr_it) < r; ++forslr_it)\n\ntemplate<class U> vector<U>to1d(vector<U>& a){return a;}\ntemplate<class U> vector<U>to1d(vector<vector<U>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)res.push_back(a2);return res;}\ntemplate<class U> vector<U>to1d(vector<vector<vector<U>>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)for(auto&& a3 : a2) res.push_back(a3);return res;}\ntemplate<class U> vector<U>to1d(vector<vector<vector<vector<U>>>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)for(auto&& a3 : a2) for(auto&& a4 : a3)res.push_back(a4);return res;}\ntemplate<class U> vector<U>to1d(vector<vector<vector<vector<vector<U>>>>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)for(auto&& a3 : a2) for(auto&& a4 : a3)for(auto&& a5 : a4)res.push_back(a5);return res;}\ntemplate<class U> vector<U>to1d(vector<vector<vector<vector<vector<vector<U>>>>>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)for(auto&& a3 : a2) for(auto&& a4 : a3)for(auto&& a5 : a4)for(auto&& a6 : a5)res.push_back(a6);return res;}\n\n#define fora_init_2(a, A) ;\n#define fora_init_3(fora_i, a, A) auto &&a = A[fora_i];\n#define fora_init_4(a, b, A, B) auto &&a = A[fora_i]; auto &&b = B[fora_i];\n#define fora_init_5(fora_i, a, b, A, B) auto &&a = A[fora_i]; auto &&b = B[fora_i];\n#define fora_init_6(a, b, c, A, B, C) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i];\n#define fora_init_7(fora_i, a, b, c, A, B, C) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i];\n#define fora_init_8(a, b, c, d, A, B, C, D) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i]; auto && d = D[fora_i];\n#define fora_init_9(fora_i, a, b, c, d, A, B, C, D) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i]; auto && d = D[fora_i];\n#define fora_init(...) over9(__VA_ARGS__,fora_init_9, fora_init_8, fora_init_7, fora_init_6, fora_init_5, fora_init_4, fora_init_3, fora_init_2)(__VA_ARGS__)\n\n#define forr_init_2(a, A) auto &&a = A[forr_i];\n#define forr_init_3(forr_i, a, A) auto &&a = A[forr_i];\n#define forr_init_4(a, b, A, B) auto &&a = A[forr_i]; auto &&b = B[forr_i];\n#define forr_init_5(forr_i, a, b, A, B) auto &&a = A[forr_i]; auto &&b = B[forr_i];\n#define forr_init_6(a, b, c, A, B, C) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i];\n#define forr_init_7(forr_i, a, b, c, A, B, C) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i];\n#define forr_init_8(a, b, c, d, A, B, C, D) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i]; auto && d = D[forr_i];\n#define forr_init_9(forr_i, a, b, c, d, A, B, C, D) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i]; auto && d = D[forr_i];\n#define forr_init(...) over9(__VA_ARGS__, forr_init_9, forr_init_8, forr_init_7, forr_init_6, forr_init_5, forr_init_4, forr_init_3, forr_init_2)(__VA_ARGS__)\n\n\n#define forp_init(k, v, ...) auto &&k = (*forp_it).fi;auto &&v = (*forp_it).se;\n#define form_init(k, v, ...) auto &&k = (*form_it).fi;auto &&v = (*form_it).se;\n#define fors_init(v, ...) auto &&v = (*fors_it);\n\n#define forlr_init(a,A,ngl,ngr) auto a = A[forlr_i]; auto prev = forlr_i ? A[forlr_i-1] : ngl;auto next = forlr_i+1< rep2lim? A[forlr_i+1] : ngr;\n#define forslr_init4(a, A, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init5(a, A, r, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init6(a, A, l, r, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init(...)  over6(__VA_ARGS__,forslr_init6,forslr_init5,forslr_init4)(__VA_ARGS__);\n\n#define fora_2(a, A) for(auto&& a : A)\n#define fora_3(fora_i, a, A) rep(fora_i, sz(A))\n#define fora_4(a, b, A, B) rep(fora_i, sz(A))\n#define fora_5(fora_i, a, b, A, B) rep(fora_i, sz(A))\n#define fora_6(a, b, c, A, B, C) rep(fora_i, sz(A))\n#define fora_7(fora_i, a, b, c, A, B, C) rep(fora_i, sz(A))\n#define fora_8(a, b, c, d, A, B, C, D) rep(fora_i, sz(A))\n#define fora_9(fora_i, a, b, c, d, A, B, C, D) rep(fora_i, sz(A))\n\n#define forr_2(a, A) rer(forr_i, sz(A)-1)\n#define forr_3(forr_i, a, A) rer(forr_i, sz(A)-1)\n#define forr_4(a, b, A, B) rer(forr_i, sz(A)-1)\n#define forr_5(forr_i, a, b, A, B) rer(forr_i, sz(A)-1)\n#define forr_6(a, b, c, A, B, C) rer(forr_i, sz(A)-1)\n#define forr_7(forr_i, a, b, c, A, B, C) rer(forr_i, sz(A)-1)\n#define forr_8(a, b, c, d, A, B, C, D) rer(forr_i, sz(A)-1)\n#define forr_9(forr_i, a, b, c, d, A, B, C, D) rer(forr_i, sz(A)-1)\n\n//↑@オーバーロード隔離\n\n//rep系はインデックス、for系は中身\n#define rep(...) over4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rer(...) over4(__VA_ARGS__,rer4,rer3,rer2,)(__VA_ARGS__)\n//char用のrep\n#define repc(i, m, n) for(char i = m,repc3lim=n; i < repc3lim ; ++i)\n//i,j,k...をnまで見る\n#define reps(...) over5(__VA_ARGS__,reps5,reps4,reps3,reps2,)(__VA_ARGS__)\n#define repss(...) over10(__VA_ARGS__, repss10, a, repss8, a, repss6, a, repss4, a, repss2) (__VA_ARGS__)\n//vectorのindexを走査する\n//repv(i,j,vvi)\n#define repv(...) over6(__VA_ARGS__,repv_6,repv_5,repv_4,repv_3,repv_2,)(__VA_ARGS__)\n#define rerv(i, A) for (int i = sz(A)-1; i >= 0 ; i--)\n//repvn(dp) nは次元\n#define repv1(a) repv(i, a)\n#define repv2(a) repv(i, j, a)\n#define repv3(a) repv(i, j, k, a)\n#define repv4(a) repv(i, j, k, l, a)\n\n#define fora(...) over9(__VA_ARGS__, forr_9, fora_8, fora_7, fora_6, fora_5, fora_4, fora_3, fora_2)(__VA_ARGS__)\n#define forr(...) over9(__VA_ARGS__, forr_9, forr_8, forr_7, forr_6, forr_5, forr_4, forr_3, forr_2)(__VA_ARGS__)\n\n//#define forr(v, a) for(auto&& v : makeReversedRange(a))\n//参照を取らない\n#define forv(a, b) for(auto a : to1d(b))\n\n//インデックスを前後含めて走査\n#define ring(i, s, len) for (int i = s, prev = (s == 0) ? len - 1 : s - 1, next = (s == len - 1) ? 0 : s + 1, cou = 0; cou < len; cou++, prev = i, i = next, next = (next == len - 1) ? 0 : next + 1)\n//値と前後を見る\n#define ringv(v, d) index_=0;for (auto prev = d[sz(d)-1],next= (int)d.size()>1?d[1]:d[0],v = d[0]; index_ < sz(d); index_++, prev = v, v = next, next = (index_>=sz(d)-1?d[0]:d[index_+1]))\n// 左右をnext prevで見る 0の左と nの右\n#define forlr(v, d, banpei_l, banpei_r) rep(forlr_i,sz(d))\n\n#define form(...) over5(__VA_ARGS__,form5,form4,form3,form2,form1)(__VA_ARGS__)\n#define fors(...) over4(__VA_ARGS__,fors4,fors3,fors2,fors1)(__VA_ARGS__)\n#define forslr(...) over6(__VA_ARGS__,forslr6,forslr5,forslr4,forslr3)(__VA_ARGS__)\n#define forp(k, v, st) for (auto &&forp_it = st.begin(); forp_it != st.end(); ++forp_it)\n\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst ll inf = (ll) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst dou dinf = (dou) linf * linf;\nconst char infc = '{';\nconst string infs = \"{\";\nconst double PI = 3.1415926535897932384626433832795029L;\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((ll)(a).size())\n#define mp make_pair\n#define pb pop_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconstexpr bool ev(ll a) { return !(a & 1); }\nconstexpr bool od(ll a) { return (a & 1); }\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> { public:size_t operator()(const std::pair<signed, signed> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n    template<> class hash<std::pair<ll, ll>> { public:/*大きいllが渡されると、<<32でオーバーフローするがとりあえず問題ないと判断*/size_t operator()(const std::pair<ll, ll> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n}\n//stream まとめ\n/*@formatter:on*/\nistream &operator>>(istream &iss, P &a) {\n    iss >> a.first >> a.second;\n    return iss;\n}\ntemplate<typename T> istream &operator>>(istream &iss, vector<T> &vec) {\n    for (T &x: vec) iss >> x;\n    return iss;\n}\ntemplate<class T, class U> ostream &operator<<(ostream &os, pair<T, U> p) {\n    os << p.fi << \" \" << p.se;\n    return os;\n}\nostream &operator<<(ostream &os, T p) {\n    os << p.f << \" \" << p.s << \" \" << p.t;\n    return os;\n}\nostream &operator<<(ostream &os, F p) {\n    os << p.a << \" \" << p.b << \" \" << p.c << \" \" << p.d;\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &vec) {\n    for (ll i = 0; i < vec.size(); ++i)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n    return os;\n}\n\ntemplate<typename T> ostream &operator<<(ostream &os, vector<vector<T>> &vec) {\n    for (ll i = 0; i < vec.size(); ++i) {\n        for (ll j = 0; j < vec[i].size(); ++j) { os << vec[i][j] << \" \"; }\n        os << endl;\n    }\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, map<T, U> &m) {\n    for (auto &&v:m) os << v;\n    return os;\n}\ntemplate<class T> ostream &operator<<(ostream &os, set<T> s) {\n    fora(v, s) { os << v << \" \"; }\n    return os;\n}\ntemplate<class T> ostream &operator<<(ostream &os, mset<T> s) {\n    fora(v, s) { os << v << \" \"; }\n    return os;\n}\ntemplate<class T> ostream &operator<<(ostream &os, deque<T> a) {\n    fora(v, a)os << v << \" \";\n    return os;\n}\nostream &operator<<(ostream &os, vector<vector<char>> &vec) {\n    rep(h, sz(vec)) {\n        rep(w, sz(vec[0])) { os << vec[h][w]; }\n        os << endl;\n    }\n    return os;\n}\n//template<class T,class U>ostream &operator<<(ostream &os, vector<pair<T,U>>& a) {fora(v,a)os<<v<<endl;return os;}\n/*@formatter:off*/\ntemplate<typename W, typename H> void resize(W &vec, const H head) { vec.resize(head); }\ntemplate<typename W, typename H, typename ... T> void resize(W &vec, const H &head, const T ... tail) {vec.resize(head);for (auto &v: vec)resize(v, tail...);}\n//template<typename W, typename H> void resize(vector<W> &vec, const H head) { vec.resize(head); }\n//template<typename W, typename H, typename ... T> void resize(vector<W> &vec, const H &head, const T ... tail) {vec.resize(head);for (auto &v: vec)resize(v, tail...);}\ntemplate<typename T, typename F> bool all_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool all_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (!all_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool any_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool any_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (any_of2(v[i], f))return true; }    return false;}\ntemplate<typename T, typename F> bool none_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool none_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (none_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool find_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll find_if2(vector<T> &v, F f) {    rep(i, sz(v)) { if (find_if2(v[i], f))return i; }    return sz(v);}\ntemplate<typename T, typename F> bool rfind_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll rfind_if2(vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (rfind_if2(v[i], f))return i; }    return -1;}\ntemplate<class T> bool contains(string &s, const T &v) { return s.find(v) != string::npos; }\ntemplate<typename T> bool contains(vector<T> &v, const T &val) { return std::find(v.begin(), v.end(), val) != v.end(); }\ntemplate<typename T, typename F> bool contains_if2(vector<T> &v, F f) { return find_if(v.begin(), v.end(), f) != v.end(); }\ntemplate<typename T, typename F> ll count_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll count_if2(vector<T> &vec, F f) {    ll ret = 0;    fora(v, vec)ret += count_if2(v, f);    return ret;}\ntemplate<typename T, typename F> void for_each2(T &v, F f) { f(v); }\ntemplate<typename T, typename F> void for_each2(vector<T> &vec, F f) { fora(v, vec)for_each2(v, f); }\ntemplate<typename W> ll count_od(vector<W> &a) {return count_if2(a,[](ll v){return v&1 ;});}\ntemplate<typename W> ll count_ev(vector<W> &a) {return count_if2(a,[](ll v){return !(v&1) ;});}\n//削除した後のvectorを返す\ntemplate<typename T, typename F> vector<T> erase_if2(vector<T> &v, F f) {vector<T> nv;rep(i, sz(v)) { if (!f(v[i])) { nv.push_back(v[i]); }}return nv;}\ntemplate<typename T, typename F> vector<vector<T>> erase_if2(vector<vector<T>> &v, F f) {vector<vector<T>> res;rep(i, sz(v)) { res[i] = erase_if2(v[i], f); }return res;}\ntemplate<typename T, typename F> vector<T> l_erase_if2(vector<T> &v, F f) {vector<T> nv;rep(i, sz(v)) { if (!f(v[i])) { nv.push_back(v[i]); }}return nv;}\n\ntemplate<typename T, typename F> ll l_rfind_if(vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (f(v[i]))return i; }    return -1;}\ntemplate<typename T, typename F> bool l_contains_if(vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (f(v[i]))return true; }    return false;}\ntemplate<class A,class B, class C> auto t_all_of(A a,B b, C c){return std::all_of(a,b,c);}\ntemplate<class A,class B, class C> auto t_any_of(A a,B b, C c){return std::any_of(a,b,c);}\ntemplate<class A,class B, class C> auto t_none_of(A a,B b, C c){return std::none_of(a,b,c);}\ntemplate<class A,class B, class C> auto t_find_if(A a,B b, C c){return std::find_if(a,b,c);}\ntemplate<class A,class B, class C> auto t_count_if(A a,B b, C c){return std::count_if(a,b,c);}\n\n#define all_of_s__2(a,right) (t_all_of(all(a),lamr(right)))\n#define all_of_s__3(a,v,siki) (t_all_of(all(a),[&](auto v){return siki;}))\n#define all_of_s(...) over3(__VA_ARGS__,all_of_s__3,all_of_s__2)(__VA_ARGS__)\n\n//all_of(A, %2);\n//all_of(A, a, a%2);\n#define all_of__2(a,right) all_of2(a,lamr(right))\n#define all_of__3(a,v,siki) all_of2(a,[&](auto v){return siki;})\n#define all_of(...) over3(__VA_ARGS__,all_of__3,all_of__2)(__VA_ARGS__)\n#define all_of_f(a,f) all_of2(a,f)\n\n#define any_of_s__2(a,right) (t_any_of(all(a),lamr(right)))\n#define any_of_s__3(a,v,siki) (t_any_of(all(a),[&](auto v){return siki;}))\n#define any_of_s(...) over3(__VA_ARGS__,any_of_s__3,any_of_s__2)(__VA_ARGS__)\n\n#define any_of__2(a,right) any_of2(a,lamr(right))\n#define any_of__3(a,v, siki) any_of2(a,[&](auto v){return siki;})\n#define any_of(...) over3(__VA_ARGS__,any_of__3,any_of__2)(__VA_ARGS__)\n#define any_of_f(a,f) any_of2(a,f)\n\n#define none_of_s__2(a,right) (t_none_of(all(a),lamr(right)))\n#define none_of_s__3(a,v,siki) (t_none_of(all(a),[&](auto v){return siki;}))\n#define none_of_s(...) over3(__VA_ARGS__,none_of_s__3,none_of_s__2)(__VA_ARGS__)\n\n#define none_of__2(a,right) none_of2(a,lamr(right))\n#define none_of__3(a,v, siki) none_of2(a,[&](auto v){return siki;})\n#define none_of(...) over3(__VA_ARGS__,none_of__3,none_of__2)(__VA_ARGS__)\n#define none_of_f(a,f) none_of2(a,f)\n\n#define find_if_s__2(a,right) (t_find_if(all(a),lamr(right))-a.begin())\n#define find_if_s__3(a,v,siki) (t_find_if(all(a),[&](auto v){return siki;})-a.begin())\n#define find_if_s(...) over3(__VA_ARGS__,find_if_s__3,find_if_s__2)(__VA_ARGS__)\n\n#define find_if__2(a,right) find_if2(a,lamr(right))\n#define find_if__3(a,v, siki) find_if2(a,[&](auto v){return siki;})\n#define find_if(...) over3(__VA_ARGS__,find_if__3,find_if__2)(__VA_ARGS__)\n#define find_if_f(a,f) find_if2(a,f)\n\n#define rfind_if_s__2(a,right) l_rfind_if(a, lamr(right))\n#define rfind_if_s__3(a,v,siki) l_rfind_if(a, [&](auto v){return siki;})\n#define rfind_if_s(...) over3(__VA_ARGS__,rfind_if_s__3,rfind_if_s__2)(__VA_ARGS__)\n\n#define rfind_if__2(a,right) rfind_if2(a,lamr(right))\n#define rfind_if__3(a,v, siki) rfind_if2(a,[&](auto v){return siki;})\n#define rfind_if(...) over3(__VA_ARGS__,rfind_if__3,rfind_if__2)(__VA_ARGS__)\n#define rfind_if_f(a,f) rfind_if2(a,f)\n\n#define contains_if_s__2(a,right) l_contains_if(a, lamr(right))\n#define contains_if_s__3(a,v,siki) l_contains_if(a, [&](auto v){return siki;})\n#define contains_if_s(...) over3(__VA_ARGS__,contains_if_s__3,contains_if_s__2)(__VA_ARGS__)\n\n#define contains_if__2(a,right) contains_if2(a,lamr(right))\n#define contains_if__3(a,v, siki) contains_if2(a,[&](auto v){return siki;})\n#define contains_if(...) over3(__VA_ARGS__,contains_if__3,contains_if__2)(__VA_ARGS__)\n#define contains_if_f(a,f) contains_if2(a,f)\n\n#define count_if_s__2(a,right) (t_count_if(all(a),lamr(right)))\n#define count_if_s__3(a,v,siki) (t_count_if(all(a),[&](auto v){return siki;}))\n#define count_if_s(...) over3(__VA_ARGS__,count_if_s__3,count_if_s__2)(__VA_ARGS__)\n\n#define count_if__2(a,right) count_if2(a,lamr(right))\n#define count_if__3(a,v, siki) count_if2(a,[&](auto v){return siki;})\n#define count_if(...) over3(__VA_ARGS__,count_if__3,count_if__2)(__VA_ARGS__)\n#define count_if_f(a,f) count_if2(a,f)\n\n\n#define for_each_s__2(a,right) do{fora(v,a){v right;}}while(0)\n#define for_each_s__3(a,v, siki) do{fora(v,a){siki;}}while(0)\n#define for_each_s(...) over3(__VA_ARGS__,for_each_s__3,for_each_s__2)(__VA_ARGS__)\n\n#define for_each__2(a,right) for_each2(a,lamr(right))\n#define for_each__3(a,v, siki) for_each2(a,[&](auto v){return siki;})\n#define for_each(...) over3(__VA_ARGS__,for_each__3,for_each__2)(__VA_ARGS__)\n#define for_each_f(a, f) for_each2(a, f);\n\n#define erase_if_s__2(a,right) l_erase_if2(a,lamr(right))\n#define erase_if_s__3(a,v, siki) l_erase_if2(a,[&](auto v){return siki;})\n#define erase_if_s(...) over3(__VA_ARGS__,erase_if_s__3,erase_if_s__2)(__VA_ARGS__)\n\n\n#define erase_if__2(a,right) erase_if2(a,lamr(right))\n#define erase_if__3(a,v, siki) erase_if2(a,[&](auto v){return siki;})\n#define erase_if(...) over3(__VA_ARGS__,erase_if__3,erase_if__2)(__VA_ARGS__)\n#define erase_if_f(a,f) erase_if2(a,f)\n\n#define entry_if_s__2(a,right) l_entry_if2(a,lamr(right))\n#define entry_if_s__3(a,v, siki) l_entry_if2(a,[&](auto v){return siki;})\n#define entry_if_s(...) over3(__VA_ARGS__,entry_if_s__3,entry_if_s__2)(__VA_ARGS__)\n\n\n#define entry_if__2(a,right) entry_if2(a,lamr(right))\n#define entry_if__3(a,v, siki) entry_if2(a,[&](auto v){return siki;})\n#define entry_if(...) over3(__VA_ARGS__,entry_if__3,entry_if__2)(__VA_ARGS__)\n#define entry_if_f(a,f) entry_if2(a,f)\n\n\n\ntemplate<class T, class U,class W> void replace(vector<W> &a, T key, U v) { rep(i,sz(a))if(a[i]==key)a[i]=v; }\ntemplate<class T, class U,class W> void replace(vector<vector<W>> &A, T key, U v) { rep(i,sz(A))replace(A[i], key, v); }\nvoid replace(str &a, char key, str v) { if (v == \"\")a.erase(remove(all(a), key), a.end()); }\nvoid replace(str &a, char key, char v) { replace(all(a), key, v); }\n//keyと同じかどうか01で置き換える\ntemplate<class T, class U> void replace(vector<T> &a, U k) { rep(i, sz(a)) a[i] = a[i] == k; }\ntemplate<class T, class U> void replace(vector<vector<T >> &a, U k) { rep(i, sz(a))rep(j, sz(a[0])) a[i][j] = a[i][j] == k; }\n//template<class T> void replace(T &a) { replace(a, '#'); }\nvoid replace(str &a) {    int dec = 0;    if('a'<=a[0]&&a[0]<='z')dec = 'a';    if('A'<=a[0]&&a[0]<='Z')dec = 'A';    fora(v,a)v-=dec;}\nvoid replace(str &a, str key, str v) {stringstream t;ll kn = sz(key);std::string::size_type Pos(a.find(key));ll l = 0;while (Pos != std::string::npos) {t << a.substr(l, Pos - l);t << v;l = Pos + kn;Pos = a.find(key, Pos + kn);}t << a.substr(l, sz(a) - l);a = t.str();}\ntemplate<class T> bool includes(vector<T> &a, vector<T> &b) {vi c = a;vi d = b;sort(all(c));sort(all(d));return includes(all(c), all(d));}\ntemplate<class T> bool is_permutation(vector<T> &a, vector<T> &b) { return is_permutation(all(a), all(b)); }\ntemplate<class T> bool next_permutation(vector<T> &a) { return next_permutation(all(a)); }\nvoid iota(vector<ll> &ve, ll s, ll n) {ve.resize(n);iota(all(ve), s);}\nvi iota(ll s, ll len) {vi ve(len);iota(all(ve), s);return ve;}\ntemplate<class A, class B> auto vtop(vector<A> &a, vector<B> &b) {    assert(sz(a) == sz(b));    /*stringを0で初期化できない  */  vector<pair<A, B>> res;    rep(i, sz(a))res.eb(a[i], b[i]);return res;}\ntemplate<class A, class B> void ptov(vector<pair<A, B>> &p, vector<A> &a, vector<B> &b) {    a.resize(sz(p)), b.resize(sz(p));    rep(i, sz(p))a[i] = p[i].fi, b[i] = p[i].se;}\ntemplate<class A, class B, class C> auto vtot(vector<A> &a, vector<B> &b, vector<C> &c) {    assert(sz(a) == sz(b) && sz(b) == sz(c));    vector<T2<A, B, C>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i]);    return res;}\ntemplate<class A, class B, class C, class D> auto vtof(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    assert(sz(a) == sz(b) && sz(b) == sz(c) && sz(c) == sz(d));    vector<F2<A, B, C, D>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i], d[i]);    return res;}\nenum pcomparator { fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd };\nenum tcomparator {    fisiti, fisitd, fisdti, fisdtd, fdsiti, fdsitd, fdsdti, fdsdtd,    fitisi, fitisd, fitdsi, fitdsd, fdtisi, fdtisd, fdtdsi, fdtdsd,    sifiti, sifitd, sifdti, sifdtd, sdfiti, sdfitd, sdfdti, sdfdtd,    sitifi, sitifd, sitdfi, sitdfd, sdtifi, sdtifd, sdtdfi, sdfdfd,    tifisi, tifisd, tifdsi, tifdsd, tdfisi, tdfisd, tdfdsi, tdfdsd,    tisifi, tisifd, tisdfi, tisdfd, tdsifi, tdsifd, tdsdfi, tdsdfd};\ntemplate<class A, class B> void sort(vector<pair<A, B>> &a, pcomparator type) {    typedef pair<A, B> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });};template<class U> void sort(vector<U> &a, pcomparator type) {    if (type == fisi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f > r.f; });};template<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D> > &a, pcomparator type) {    typedef F2<A, B, C, D> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a > r.a; });};template<class U> void sort(vector<U> &a, tcomparator type) {    if (type == 0) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == 41) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == 42) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == 43) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });    else if (type == 44) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == 45) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == 46) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == 47) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });}template<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D>> &a, tcomparator type) {    typedef F2<A, B, C, D> U;    if (type == 0) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == 41) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == 42) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == 43) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });    else if (type == 44) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == 45) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == 46) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == 47) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });}\n\nvoid sort(string &a) { sort(all(a)); }\nvoid sort(int& a,int& b){    if(a>b)swap(a,b);}\nvoid sort(int& a,int& b, int& c){    sort(a,b);    sort(a,c);    sort(b,c);}\nvoid rsort(int& a,int& b){    if(a<b)swap(a,b);}\nvoid rsort(int& a,int& b, int& c){    rsort(a,b);    rsort(a,c);    rsort(b,c);}\ntemplate<class T> void sort(vector<T> &a) { sort(all(a)); }\n//P l, P rで f(P) の形で渡す\ntemplate<class U, class F> void sort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) < f(r); }); };\ntemplate<class T> void rsort(vector<T> &a) { sort(all(a), greater<T>()); };\ntemplate<class U, class F> void rsort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) > f(r); }); };\n\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class A, class B> void sortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    sort(c);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}template<class A, class B, class F> void sortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    sort(c, f);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}template<class A, class B> void rsortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    rsort(c);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}template<class A, class B, class F> void rsortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    rsort(c, f);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}\ntemplate<class A, class B, class C> void sortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    sort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class F> void sortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    sort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    rsort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class F> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    rsort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class D> void sortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    sort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\ntemplate<class A, class B, class C, class D> void rsortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    rsort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\n//sortindex 元のvectorはソートしない\ntemplate<class T> vi sorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind);    return ind;}/*indexの分で型が変わるためpcomparatorが必要*/template<class T> vi sorti(vector<T> &a, pcomparator f) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind, f);    return ind;}template<class T, class F> vi sorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(a[x]) < f(a[y]); });    return ind;}template<class T> vi rsorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    rsortp(b, ind);    return ind;}template<class T, class F> vi rsorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(a[x]) > f(a[y]); });    return ind;}template<class A, class B, class F> vi sortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(c[x]) < f(c[y]); });    return ind;}template<class A, class B> vi sortpi(vector<A> &a, vector<B> &b, pcomparator f) {    vi ind = iota(0, sz(a));    auto c = a;    auto d = b;    sortt(c, d, ind, f);    return ind;}template<class A, class B> vi sortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fisi); };template<class A, class B, class F> vi rsortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(c[x]) > f(c[y]); });    return ind;}template<class A, class B> vi rsortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fdsd); };template<class A, class B, class C, class F> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(d[x]) < f(d[y]); });    return ind;}template<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, pcomparator f) {    vi ind = iota(0, sz(a));    auto d = vtof(a, b, c, ind);    sort(d, f);    rep(i, sz(a))ind[i] = d[i].d;    return ind;}template<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) {        if (a[x] == a[y]) {            if (b[x] == b[y])return c[x] < c[y];            else return b[x] < b[y];        } else {            return a[x] < a[y];        }    });    return ind;}template<class A, class B, class C, class F> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(d[x]) > f(d[y]); });    return ind;}template<class A, class B, class C> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) {        if (a[x] == a[y]) {            if (b[x] == b[y])return c[x] > c[y];            else return b[x] > b[y];        } else {            return a[x] > a[y];        }    });    return ind;}\ntemplate<class T> void sort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)sort(a[i]); }\ntemplate<class T> void rsort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)rsort(a[i]); }\n\ntemplate<class... T,class U> auto sorted(U head,T... a) { sort(head,a...); return head;}\n\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }template<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }template<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\ntemplate<typename W, typename T>void fill(W &xx, const T vall) {    xx = vall;}template<typename W, typename T>void fill(vector<W> &vecc, const T vall) {    for (auto &&vx     : vecc)fill(vx, vall);}\ntemplate<typename W,typename T>void fill(vector<W> &xx,ll len,const T v) {rep(i, len)xx[i]=v;}\ntemplate<typename W, typename T> void fill(vector<vector<W>> &xx, int sh, int th, int sw, int tw, T v) { rep(h, sh, th)rep(w, sw, tw)xx[h][w] = v; }\ntemplate<class T,class U>void fill(vector<T> &a,vi& ind,U val) {fora(v,ind)a[v]=val;}\ntemplate<class W,class T>void fill(mvec<W> &xx,const T v){\n    fora(x,xx)fill(x,v);\n}\n\n\ntemplate<typename A, size_t N> A sum(A (&a)[N]) {    A res = 0;    rep(i, N)res += a[i];    return res;}template<typename A, size_t N, size_t O> A sum(A (&a)[N][O]) {    A res = 0;    rep(i, N)rep(j, O)res += a[i][j];    return res;}template<typename A, size_t N, size_t O, size_t P> A sum(A (&a)[N][O][P]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)res += a[i][j][k];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A sum(A (&a)[N][O][P][Q]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)res += a[i][j][k][l];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A sum(A (&a)[N][O][P][Q][R]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)res += a[i][j][k][l][m];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A sum(A (&a)[N][O][P][Q][R][S]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)res += a[i][j][k][l][m][n];    return res;}\n//@汎用便利関数 入力\nll in() {ll ret;cin >> ret;return ret;}\nstring sin() {string ret;cin >> ret;return ret;}\ntemplate<class T>  void in(T &head) { cin >> head; }template<class T, class... U>  void in(T &head, U &... tail) {cin >> head;in(tail...);}\n\n#define din1(a) ll a;cin>>a\n#define din2(a, b) ll a,b;cin>>a>> b\n#define din3(a, b, c) ll a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) ll a,b,c,d;cin>>a>>b>>c>>d\n#define din5(a, b, c, d, e) ll a,b,c,d,e;cin>>a>>b>>c>>d>>e\n#define din6(a, b, c, d, e, f) ll a,b,c,d,e,f;cin>>a>>b>>c>>d>>e>>f\n#define din(...) over6(__VA_ARGS__,din6,din5,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define dins1(a) str a;cin>>a\n#define dins2(a, b) str a,b;cin>>a>> b\n#define dins3(a, b, c) str a,b,c;cin>>a>>b>>c\n#define dins4(a, b, c, d) str a,b,c,d;cin>>a>>b>>c>>d\n#define dins5(a, b, c, d, e) str a,b,c,d,e;cin>>a>>b>>c>>d>>e\n#define dins6(a, b, c, d, e, f) str a,b,c,d,e,f;cin>>a>>b>>c>>d>>e>>f\n#define dins(...) over6(__VA_ARGS__,dins6,dins5,dins4,dins3,dins2 ,dins1)(__VA_ARGS__)\n\n#define din1d(a) din1(a);a--\n#define din2d(a, b) din2(a,b);a--,b--\n#define din3d(a, b, c) din3(a,b,c);a--,b--,c--\n#define din4d(a, b, c, d) din4(a,b,c,d);a--,b--,c--,d--\n#define dind(...) over4(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\ntemplate<class T> void out2(T &&head) { cout << head; }\ntemplate<class T, class... U> void out2(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);}\ntemplate<class T, class... U> void out(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);    cout << \"\" << endl;}\ntemplate<class T> void out(T &&head) {    cout << head  << endl;}\nvoid out() {    cout << \"\"  << endl;}\n\n\n#ifdef _DEBUG\ntemplate<class T> void err2(T &&head) { cerr << head; }\ntemplate<class T, class... U> void err2(T &&head, U &&... tail) {    cerr << head << \" \";    err2(tail...);}\ntemplate<class T, class... U> void err(T &&head, U &&... tail) {    cerr << head << \" \";    err2(tail...);    cerr << \"\" << endl;}\ntemplate<class T> void err(T &&head) {    cerr << head  << endl;}\nvoid err() {    cerr << \"\"  << endl;}\ntemplate<class T> string out_m2(vector<T> &a, ll W = inf) {    stringstream ss;    if (W == inf)W = min(sz(a), 12ll);    if (sz(a) == 0)return ss.str();    rep(i, W) {        ss << a[i];        if (typeid(a[i]) == typeid(P)) {            ss << endl;        } else {            ss << \" \";        }    }    return ss.str();}\ntemplate<class T> string out_m2(vector<vector<T> > &a, ll H = inf, ll W = inf, int key = -1) {H = min({H, sz(a), 12ll});W = min({W, sz(a[0]), 12ll});stringstream ss;ss << endl;if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";rep(w, W)ss << std::right << std::setw(4) << w;ss << \"\" << endl;rep(w, W * 4 + 3)ss << \"_\";ss << \"\" << endl;rep(h, H) {ss << std::right << std::setw(2) << h << \"|\";rep(w, min(sz(a[h]),12ll)) { if (abs(a[h][w]) == linf) ss << \"   e\" << \"\"; else ss << std::right << std::setw(4) << a[h][w]; }ss << \"\" << endl;}return ss.str();}\ntemplate<class T> string out_m2(vector<vector<vector<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {stringstream ss;    if (H == inf)H = 12;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << out_m2(a[i], W, U, i);    }       return ss.str();}\ntemplate<class T, size_t N> string out_m2(T (&a)[N]) {    vector<T> b;    resize(b, N);    rep(i, N) {        b[i] = a[i];    }    return out_m2(b);}\ntemplate<class T, size_t N, size_t M> string out_m2(T (&a)[N][M]) {    vector<vector<T>> b;    resize(b, N, M);    rep(i, N) {        rep(j, M) {            b[i][j] = a[i][j];        }    }    return out_m2(b);}\ntemplate<class T, size_t N, size_t M, size_t O> string out_m2(T (&a)[N][M][O]) {    vector<vector<vector<T>>> b;    resize(b, N, M, O);    rep(i, N) {        rep(j, M) {            rep(k, O) {                b[i][j][k] = a[i][j][k];            }        }    }    return out_m2(b);}\nstring out_m2(int a) {stringstream ss;ss << a;return ss.str();}\n/*@formatter:on*/\ntemplate<class T> string out_m2(mvec<mvec<T> > &a, ll H = inf, ll W = inf, int key = inf) {\n    H = min({H, sz(a), 6ll});\n    W = min({W, sz(a[0]), 6ll});\n    stringstream ss;\n    ss << endl;\n//    if (key == inf)ss << \" *|\"; else ss << \" \" << key << \"|\";\n    if (key == inf)ss << \" *|\";\n    else {\n        ss << std::right << std::setw(2) << key;\n        ss << \"|\";\n    }\n    rep(w, -W, W)ss << std::right << std::setw(4) << w;\n    ss << \"\" << endl;\n    rep(w, W * 8 + 3)ss << \"_\";\n    ss << \"\" << endl;\n    rep(h, -H, H) {\n        ss << std::right << std::setw(2) << h << \"|\";\n        int NW = min(sz(a[h]), 6ll);\n        rep(w, -NW, NW) { if (abs(a[h][w]) == linf) ss << \"   e\" << \"\"; else ss << std::right << std::setw(4) << a[h][w]; }\n        ss << \"\" << endl;\n    }\n    return ss.str();\n}/*@formatter:on*/\ntemplate<class T> string out_m2(mvec<mvec<mvec<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {\n    stringstream ss;\n    if (H == inf)H = 6;\n    H = min(H, sz(a));\n    rep(i, -H, H) {\n        ss << endl;\n        ss << out_m2(a[i], W, U, i);\n    }\n    return ss.str();\n}\n\n/*@formatter:off*/\ntemplate<class T> string out_m2(T &a) {stringstream ss;ss << a;return ss.str();}\n/*@formatter:on*/\ntemplate<class T> string out_m(vector<T> &a, ll W = inf) {\n    stringstream ss;\n    if (W == inf)W = min(sz(a), 12ll);\n    if (sz(a) == 0)return ss.str();\n    rep(i, W) { ss << a[i] << \" \"; }\n    ss << \"\" << endl;\n    return ss.str();\n}\n/*@formatter:off*/\ntemplate<class T> string out_m(vector<vector<T> > &a, ll H = inf, ll W = inf, int key = -1) {H = min({H, sz(a), 12ll});W = min({W, sz(a[0]), 12ll});stringstream ss;ss << endl;if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";rep(w, W)ss << std::right << std::setw(4) << w;ss << \"\" << endl;rep(w, W * 4 + 3)ss << \"_\";ss << \"\" << endl;rep(h, H) {ss << std::right << std::setw(2) << h << \"|\";rep(w, min(sz(a[h]),12ll)) { if (abs(a[h][w]) == linf) ss << \"   e\" << \"\"; else ss << std::right << std::setw(4) << a[h][w]; }ss << \"\" << endl;}ss << endl;return ss.str();}\ntemplate<class T> string out_m(vector<vector<vector<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {stringstream ss;    if (H == inf)H = 5;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << out_m(a[i], W, U, i);    }    ss << endl;    return ss.str();}\nstring out_m(int a) {stringstream ss;ss << a << endl;return ss.str();}\ntemplate<class T> string out_m(T &a) {stringstream ss;ss << a << endl;return ss.str();}\ntemplate<class T> void outv(vector<T> &a, ll W=inf) {cout << out_m(a,W) << endl;}\ntemplate<class T> void outv(vector<vector<T> > &a, ll H = linf, ll W = linf,int key=-1) {    cout << out_m(a,H,W,key) << endl;}\ntemplate<class T> void outv(vector<vector<vector<T> > > &a, ll H = linf, ll W = linf,ll U = linf) {cout << out_m(a,H,W,U)<< endl;}\n#else\ntemplate<class T> void outv(vector<T> &a, ll W = inf) {\n    rep(i, min(W, sz(a))) { cout << a[i] << \" \"; }\n    cout << \"\" << endl;\n}\ntemplate<class T> void outv(vector<vector<T> > &a, ll H = linf, ll W = linf, int key = -1) { rep(i, min(H, sz(a))) { outv(a[i], W); }}\ntemplate<class T> void outv(vector<vector<vector<T> > > &a, ll H = linf, ll W = linf, ll U = linf) { ; }\n#define err(...);\n#endif\ntemplate<class T> void outl(vector<T> &a, int n = inf) { rep(i, min(n, sz(a)))cout << a[i] << endl; }\n//テーブルをスペースなしで出力\ntemplate<class T> void outt(vector<vector<T>> &a) {\n    rep(i, sz(a)) {\n        rep(j, sz(a[i])) { cout << a[i][j]; }\n        cout << endl;\n    }\n}\n//int型をbit表記で出力\nvoid outb(int a) { cout << bitset<20>(a) << endl; }\ntemplate<class T> void na(vector<T> &a, ll n) {\n    a.resize(n);\n    rep(i, n)cin >> a[i];\n}\ntemplate<class T> void na(set<T> &a, ll n) {\n    rep(i, n)a.insert(in());\n}\n#define dna(a, n) vi a(n); rep(dnai,n) cin >> a[dnai];\n#define dnad(a, n) vi a(n); rep(dnai,n) cin >> a[dnai],a[dnai]--;\ntemplate<class T> void nao(vector<T> &a, ll n) {\n    a.resize(n + 1);\n    a[0] = 0;\n    rep(i, n)cin >> a[i + 1];\n}\ntemplate<class T> void naod(vector<T> &a, ll n) {\n    a.resize(n + 1);\n    a[0] = 0;\n    rep(i, n)cin >> a[i + 1], a[i + 1]--;\n}\ntemplate<class T> void nad(vector<T> &a, ll n) {\n    a.resize(n);\n    rep(i, n)cin >> a[i], a[i]--;\n}\ntemplate<class T> void nad(set<T> &a, ll n) {\n    rep(i, n)a.insert(in()-1);\n}\ntemplate<class T, class U> void na2(vector<T> &a, vector<U> &b, ll n) {\n    a.resize(n);\n    b.resize(n);\n    rep(i, n)cin >> a[i] >> b[i];\n}\ntemplate<class T, class U> void na2(set<T> &a, set<U> &b, ll n) {\n    rep(i, n){\n        a.insert(in());\n        b.insert(in());\n    }\n}\n\n#define dna2(a, b, n) vi a(n),b(n);rep(dna2i, n)cin >> a[dna2i] >> b[dna2i];\ntemplate<class T, class U> void nao2(vector<T> &a, vector<U> &b, ll n) {\n    a.resize(n + 1);\n    b.resize(n + 1);\n    a[0] = b[0] = 0;\n    rep(i, n)cin >> a[i + 1] >> b[i + 1];\n}\n#define dna2d(a, b, n) vi a(n),b(n);rep(dna2di, n){cin >> a[dna2di] >> b[dna2di];a[dna2di]--,b[dna2di]--;}\ntemplate<class T, class U> void na2d(vector<T> &a, vector<U> &b, ll n) {\n    a.resize(n);\n    b.resize(n);\n    rep(i, n)cin >> a[i] >> b[i], a[i]--, b[i]--;\n}\ntemplate<class T, class U, class W> void na3(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {\n    a.resize(n);\n    b.resize(n);\n    c.resize(n);\n    rep(i, n)cin >> a[i] >> b[i] >> c[i];\n}\n#define dna3(a, b, c, n) vi a(n),b(n),c(n);   rep(dna3i, n)cin >> a[dna3i] >> b[dna3i] >> c[dna3i];\ntemplate<class T, class U, class W> void na3d(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {\n    a.resize(n);\n    b.resize(n);\n    c.resize(n);\n    rep(i, n)cin >> a[i] >> b[i] >> c[i], a[i]--, b[i]--, c[i]--;\n}\n#define dna3d(a, b, c, n) vi a(n),b(n),c(n);  rep(dna3di, n){cin >> a[dna3di] >> b[dna3di] >> c[dna3di];a[dna3di]--,b[dna3di]--,c[dna3di]--;}\ntemplate<class T, class U, class W, class X> void na4(vector<T> &a, vector<U> &b, vector<W> &c, vector<X> &d, ll n) {\n    a.resize(n);\n    b.resize(n);\n    c.resize(n);\n    d.resize(n);\n    rep(i, n)cin >> a[i] >> b[i] >> c[i] >> d[i];\n}\n#define dna4(a, b, c, d, n) vi a(n),b(n),c(n),d(n);   rep(dna4i, n)cin >> a[dna4i] >> b[dna4i] >> c[dna4i]>>d[dna4i];\n#define dna4d(a, b, c, d, n) vi a(n),b(n),c(n),d(n);   rep(dna4i, n)cin >> a[dna4i] >> b[dna4i] >> c[dna4i]>>d[dna4i],--a[dna4i] ,-- b[dna4i],-- c[dna4i],--d[dna4i];\n#define nt(a, h, w) resize(a,h,w);rep(nthi,h)rep(ntwi,w) cin >> a[nthi][ntwi];\n#define ntd(a, h, w) resize(a,h,w);rep(ntdhi,h)rep(ntdwi,w) cin >> a[ntdhi][ntdwi], a[ntdhi][ntdwi]--;\n#define ntp(a, h, w) resize(a,h+2,w+2);fill(a,'#');rep(ntphi,1,h+1)rep(ntpwi,1,w+1) cin >> a[ntphi][ntpwi];\n//デバッグ\n#define sp << \" \" <<\n\n#define deb1(x)  debugName(x)<<\" = \"<<out_m2(x)\n#define deb_2(x, ...) deb1(x) <<\", \"<< deb1(__VA_ARGS__)\n#define deb_3(x, ...) deb1(x) <<\", \"<< deb_2(__VA_ARGS__)\n#define deb_4(x, ...) deb1(x) <<\", \"<< deb_3(__VA_ARGS__)\n#define deb5(x, ...) deb1(x) <<\", \"<< deb_4(__VA_ARGS__)\n#define deb6(x, ...) deb1(x) <<\", \"<< deb5(__VA_ARGS__)\n#define deb7(x, ...) deb1(x) <<\", \"<< deb6(__VA_ARGS__)\n#define deb8(x, ...) deb1(x) <<\", \"<< deb7(__VA_ARGS__)\n#define deb9(x, ...) deb1(x) <<\", \"<< deb8(__VA_ARGS__)\n#define deb10(x, ...) deb1(x) <<\", \"<< deb9(__VA_ARGS__)\n\n\n#ifdef _DEBUG\n#define deb(...)  cerr<< over10(__VA_ARGS__,deb10,deb9,deb8,deb7,deb6,deb5,deb_4,deb_3,deb_2,deb1)(__VA_ARGS__) <<endl\n\n#define base_keta 8\nvoid print_n_base(int x,int base){    cerr<<bitset<base_keta>(x)<<endl;}\ntemplate<class T>void print_n_base(vector<T> X,int base){    cerr<<endl;    for(auto&& x:X){        print_n_base(x,base);    }    cerr<<endl;}\n\n//n進数\n#define deb2(x) cerr<<debugName(x)<<\" = \";print_n_base(x, 2);\n#define deb3(x) cerr<<debugName(x)<<\" = \";print_n_base(x, 3);\n#define deb4(x) cerr<<debugName(x)<<\" = \";print_n_base(x, 4);\n\n#else\n#define deb(...) ;\n#define deb2(...) ;\n#define deb3(...) ;\n#define deb4(...) ;\n#endif\n\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n\n//@formatter:off\n//よく使うクラス、構造体\n//graphでredefineしているため、書き換えたら向こうも書き換える\nstruct unionfind {\n    vector<ll> par;\n    vector<ll> siz;\n    vector<ll> es;\n    ll n, trees;//連結グループの数(親の種類)\n    unionfind(ll n) : n(n), trees(n) {        par.resize(n);        siz.resize(n);        es.resize(n);        for (ll i = 0; i < n; i++) {            par[i] = i;            siz[i] = 1;        }    }\n    ll root(ll x) { if (par[x] == x) { return x; } else { return par[x] = root(par[x]); }}\n    ll operator()(ll x){return root(x);}\n    bool unite(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        es[x]++;\n        if (x == y) return false;\n        if (siz[x] > siz[y]) swap(x, y);\n        trees--;\n        par[x] = y;\n        siz[y] += siz[x];\n        es[y] += es[x];\n        return true;\n    }\n    bool same(ll x, ll y) { return root(x) == root(y); }\n    ll size(ll x) { return siz[root(x)]; }\n    ll esize(ll x) { return es[root(x)]; }\n    vi sizes(){        vi cou(n);        vi ret;        ret.reserve(n);        rep(i, n){            cou[root (i)]++;        }        rep(i, n){            if(cou[i])ret.push_back(cou[i]);        }        return ret;    }\n    //つながりを無向グラフと見なし、xが閉路に含まれるか判定\n    bool close(ll x) { return esize(x) >= size(x); }\n    vector<vi> sets() {        vi ind(n, -1);        ll i = 0;        vvi(res, trees);        rep(j, n) {            ll r = root(j);            if (ind[r] == -1)ind[r] = i++;            res[ind[r]].push_back(j);        }        rep(i, trees) {            ll r = root(res[i][0]);            if (res[i][0] == r)continue;            rep(j, 1, sz(res[i])) {                if (res[i][j] == r) {                    swap(res[i][0], res[i][j]);                    break;                }            }        }        return res;    }\n};//@formatter:off\n\n\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing u128 = __uint128_t;\n\nusing bint =__int128;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {    std::ostream::sentry s(dest);    if (s) {        __uint128_t tmp = value < 0 ? -value : value;        char buffer[128];        char *d = std::end(buffer);        do {            --d;            *d = \"0123456789\"[tmp % 10];            tmp /= 10;        } while (tmp != 0);        if (value < 0) {            --d;            *d = '-';        }        ll len = std::end(buffer) - d;        if (dest.rdbuf()->sputn(d, len) != len) { dest.setstate(std::ios_base::badbit); }    }    return dest;}\n__int128 to_bint(string &s) {    __int128 ret = 0;    for (ll i = 0; i < s.length(); ++i)        if ('0' <= s[i] && s[i] <= '9')            ret = 10 * ret + s[i] - '0';    return ret;}\nvoid operator>>(istream &iss, bint &v) {\n    string S;\n    iss>>S;\n    v = 0;\n    rep(i,sz(S)){\n        v*=10;\n        v +=  S[i]-'0';\n    }\n}\n//エラー\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");    exit(0);\n#endif\n    string a = \"a\";    rep(i, 30)a += a;    rep(i, 1 << 17)cout << a << endl;    cout << \"OLE 出力長制限超過\" << endl;    exit(0);}\nvoid re() {    assert(0 == 1);    exit(0);}\nvoid tle() { while (inf)cout << inf << endl; }\n\n//便利関数\n\n//テスト用\n#define rand xor128_\nunsigned long xor128_(void){static unsigned long x=123456789,y=362436069,z=521288629,w=88675123;unsigned long t;t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );}\nchar ranc() { return (char) ('a' + rand() % 26); }\nll rand(ll min, ll max) {    assert(min <= max);    if (min >= 0 && max >= 0) { return rand() % (max + 1 - min) + min; } else if (max < 0) { return -rand(-max, -min); } else { if (rand() % 2) { return rand(0, max); } else { return -rand(0, -min); }}}\nll rand(ll max){return rand(0,max);}\ntemplate<class T> T rand(vector<T>& A){return A[rand(sz(A)-1)];}\n//重複することがある\ntemplate<class T> vector<T> ranv(vector<T>& A, int N){vector<T>ret(N);rep(i,N){ret[i]=rand(A);}return ret;}\ntemplate<class T> vector<T> ranv_unique(vector<T>& A, int N){    vector<T> ret(N);    umapi was;    rep(j,N){        int i;        while(1){            i = rand(sz(A)-1);            if(was.find(i) == was.end())break;        }        ret[j] = A[i];was[i]=1;    }    return ret;}\nvi ranv(ll n, ll min, ll max) {    vi v(n);    rep(i, n)v[i] = rand(min, max);    return v;}\nstr ransu(ll n) {    str s;    rep(i, n)s += (char) rand('A', 'Z');    return s;}\nstr ransl(ll n) {    str s;    rep(i, n)s += (char) rand('a', 'z');    return s;}\n//単調増加\nvi ranvinc(ll n, ll min, ll max) {    vi v(n);    bool bad = 1;    while (bad) {        bad = 0;        v.resize(n);        rep(i, n) {            if (i && min > max - v[i - 1]) {                bad = 1;                break;            }            if (i)v[i] = v[i - 1] + rand(min, max - v[i - 1]); else v[i] = rand(min, max);        }    }    return v;}\n//便利 汎用\n\nvoid ranvlr(ll n, ll min, ll max, vi &l, vi &r) {    l.resize(n);    r.resize(n);    rep(i, n) {        l[i] = rand(min, max);        r[i] = l[i] + rand(0, max - l[i]);    }}\ntemplate<class T>vector<pair<T,int>> run_length(vector<T> &a) {vector<pair<T,int>> ret;ret.eb(a[0], 1);rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}return ret;}\nvector<pair<char, ll>> run_length(string &a) {    vector<pair<char, ll>> ret;    ret.eb(a[0], 1);    rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}    return ret;}\ntemplate<class F> ll mgr(ll ok, ll ng, F f) {\n    bool han = true;\n    if (ok < ng)\n        while (ng - ok > 1) {\n            ll mid = (ok + ng) >> 1;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            deb(mid,han);\n        }\n    else\n        while (ok - ng > 1) {\n            ll mid = (ok + ng) >> 1;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            deb(mid,han);\n        }\n    return ok;\n}\ntemplate<class F> dou mgrd(dou ok, dou ng, F f,int kai=100) {\n    bool han = true;\n    if (ok < ng)\n        rep(i,kai) {\n            dou mid = (ok + ng) /2;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            deb(mid,han);\n        }\n    else\n        rep(i,kai) {\n            dou mid = (ok + ng) /2;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            deb(mid,han);\n        }\n    return ok;\n}\n//strを整数として比較\nstring smax(str &a, str b) {    if (sz(a) < sz(b)) { return b; }    else if (sz(a) > sz(b)) { return a; }    else if (a < b)return b;    else return a;}\n//strを整数として比較\nstring smin(str &a, str b) {    if (sz(a) > sz(b)) { return b; }    else if (sz(a) < sz(b)) { return a; }    else if (a > b)return b;    else return a;}\n//エラー-1\ntemplate<typename W, typename T> ll find(vector<W> &a, int l, const T key) {rep(i, l, sz(a))if (a[i] == key)return i;return -1;}\ntemplate<typename W, typename T> ll find(vector<W> &a, const T key) {    rep(i, sz(a))if (a[i] == key)return i;    return -1;}\ntemplate<typename W, typename T> P find(vector<vector<W >> &a, const T key) {    rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return mp(i, j);    return mp(-1, -1);}\n//getid(find())を返す 1次元にする\ntemplate<typename W, typename T> int findi(vector<vector<W >> &a, const T key) {    rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return i*sz(a[0])+j;    return -1;}\ntemplate<typename W, typename U> T find(vector<vector<vector<W >>> &a, const U key) {    rep(i, sz(a))rep(j, sz(a[0]))rep(k, sz(a[0][0]))if (a[i][j][k] == key)return mt(i, j, k);    return mt(-1, -1, -1);}\n//stringも書く\nint find(string& s, const string key){    int klen = sz(key);    rep(i,sz(s)-klen+1){        if(s[i]!=key[0])continue;        if(s.substr(i,klen) == key){            return i;        }    }    return -1;}\nint find(string& s, int l, const string key){    int klen = sz(key);    rep(i, l, sz(s)-klen+1){        if(s[i]!=key[0])continue;        if(s.substr(i,klen) == key){            return i;        }    }    return -1;}\nint find(string& s, const char key){    rep(i,sz(s)){        if(s[i]==key)return i;    }    return -1;}\nint find(string& s, int l, const char key){    rep(i, l, sz(s)){        if(s[i]==key)return i;    }    return -1;}\ntemplate<typename W, typename T> ll count2(W &a, const T k) { return a == k; }\ntemplate<typename W, typename T> ll count2(vector<W> &a, const T k) {    ll ret = 0;    fora(v, a)ret += count2(v, k);    return ret;}\ntemplate<typename W, typename T> ll count(vector<W> &a, const T k) {    ll ret = 0;    fora(v, a)ret += count2(v, k);    return ret;}\nvi count(vi &a) {    int ma = 0;    fora(v, a) {        if (ma < v)ma = v;    }    vi res(ma + 1);    fora(v, a) {        res[v]++;    }    return res;}\nll count(str &a, str k) {    ll ret = 0, len = k.length();    auto pos = a.find(k);    while (pos != string::npos)pos = a.find(k, pos + len), ++ret;    return ret;}\n//'a' = 'A' = 0 として集計 既に-'a'されていても動く\nvi count(str &a, int l, int r) {    vi cou(26);    char c = 'a';    if ('A' <= a[l] && a[l] <= 'Z')c = 'A';    if ('a' <= a[l] && a[l] <= 'z') c = 'a'; else c = 0;    rep(i, l, r)++cou[a[i] - c];    return cou;}\nvi count(str &a, int r = inf){return count(a, 0, min(r, sz(a)));}\n#define couif count_if\n//algorythm\n\nll rev(ll a) {    ll res = 0;    while (a) {        res *= 10;        res += a % 10;        a /= 10;    }    return res;}\ntemplate<class T> void rev(vector<T> &a) { reverse(all(a)); }\ntemplate<class U> void rev(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a[0]), vector<U>(sz(a)));    rep(h, sz(a)) rep(w, sz(a[0]))b[w][h] = a[h][w];    a = b;}\nvoid  rev(string &a) { reverse(all(a)); }\nconstexpr ll p10[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000ll, 100000000000ll, 1000000000000ll, 10000000000000ll, 100000000000000ll, 1000000000000000ll, 10000000000000000ll, 100000000000000000ll, 1000000000000000000ll};\n\n//0は0桁\nll keta(ll v) {    if (v < p10[9]) { if (v < p10[4]) { if (v < p10[2]) { if (v < p10[1]) { if (v < p10[0])return 0; else return 1; } else return 2; } else { if (v < p10[3]) return 3; else return 4; }} else { if (v < p10[7]) { if (v < p10[5]) return 5; else if (v < p10[6])return 6; else return 7; } else { if (v < p10[8])return 8; else return 9; }}}    else {        if (v < p10[13]) { if (v < p10[11]) { if (v < p10[10]) return 10; else return 11; } else { if (v < p10[12]) return 12; else return 13; }}        else {            if (v < p10[15]) {                if (v < p10[14]) return 14;                else return 15;            } else {                if (v < p10[17]) {                    if (v < p10[16]) return 16;                    else return 17;                } else {                    if (v < p10[18])return 18;                    else return 19;                }            }        }    }}\nll getr(ll a, ll keta) { return (a / (ll) pow(10, keta)) % 10; }\n//上から何桁目か\nll getl(ll a, ll ket) {int sketa = keta(a);return getr(a,sketa-1-ket);}\nll dsum(ll v,ll sin=10) {    ll ret = 0;    for (; v; v /= sin)ret += v % sin;    return ret;}\n\nll mask10(ll v) { return p10[v] - 1; }\n//変換系\n//[v] := iとなるようなvectorを返す\n//存在しない物は-1\ntemplate<class T> auto keys(T& a) {    vector<decltype((a.begin())->fi)> res;    for (auto &&k :a)res.push_back(k.fi);    return res;}\ntemplate<class T> auto values(T& a) {    vector<decltype((a.begin())->se)> res;    for (auto &&k :a)res.push_back(k.se);    return res;}\ntemplate<class T, class U>  bool chma(T &a, const U &b) {    if (a < b) {        a = b;        return true;    }    return false;}\ntemplate<class T, class U>  bool chmi(T &a, const U &b) {    if (b < a) {        a = b;        return true;    }    return false;}\ntemplate<class T> constexpr T min(T a, signed b) { return a < b ? a : b; }\ntemplate<class T> constexpr  T max(T a, signed b) { return a < b ? b : a; }\ntemplate<class T> constexpr  T min(T a, T b, T c) { return a >= b ? b >= c ? c : b : a >= c ? c : a; }\ntemplate<class T> constexpr  T max(T a, T b, T c) { return a <= b ? b <= c ? c : b : a <= c ? c : a; }\ntemplate<class T>  T min(vector<T>& a) { return *min_element(all(a)); }\ntemplate<class T>  T mini(vector<T>& a) { return min_element(all(a)) - a.begin(); }\ntemplate<class T>  T min(vector<T>& a, ll n) { return *min_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T>  T min(vector<T>& a, ll s, ll n) { return *min_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<class T>  T max(vector<T>& a) { return *max_element(all(a)); }\ntemplate<class T,class U>  T max(vector<T>& a,vector<U>& b) { return max(*max_element(all(a)),*max_element(all(b))); }\ntemplate<class T>  T maxi(vector<T>& a) { return max_element(all(a)) - a.begin(); }\ntemplate<class T>  T max(vector<T>& a, ll n) { return *max_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T>  T max(vector<T>& a, ll s, ll n) { return *max_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<typename A, size_t N> A max(A (&a)[N]) {    A res = a[0];    rep(i, N)res = max(res, a[i]);    return res;}template<typename A, size_t N, size_t O> A max(A (&a)[N][O]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P> A max(A (&a)[N][O][P]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A max(A (&a)[N][O][P][Q], const T &v) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A max(A (&a)[N][O][P][Q][R]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A max(A (&a)[N][O][P][Q][R][S]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}\ntemplate<typename A, size_t N> A min(A (&a)[N]) {    A res = a[0];    rep(i, N)res = min(res, a[i]);    return res;}template<typename A, size_t N, size_t O> A min(A (&a)[N][O]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P> A min(A (&a)[N][O][P]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A min(A (&a)[N][O][P][Q], const T &v) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A min(A (&a)[N][O][P][Q][R]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A min(A (&a)[N][O][P][Q][R][S]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}\ntemplate<class T> T sum(vector<T> &v, ll s, ll t) {    T ret = 0;    rep(i, s, min(sz(v), t))ret += v[i];    return ret;}\ntemplate<class T> T sum(vector<T> &v, ll t = inf) { return sum(v, 0, t); }\ntemplate<class T> T sum(vector<vector<T> > &v, int s, int t) {T ret = 0;rep(i, s, min(sz(v), t))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<T> > &v, int t = inf) { return sum(v, 0, t); }\ntemplate<class T> T sum(vector<vector<vector<T>> > &v, int s, int t) {T ret = 0;rep(i, s, min(sz(v), t))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<vector<T>> > &v, int t = inf) { return sum(v, 0, t); }\ntemplate<class T> T sum(vector<vector<vector<vector<T>>> > &v, int s, int t) {T ret = 0;rep(i, s, min(sz(v), t))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<vector<vector<T>>> > &v, int t = inf) { return sum(v, 0, t); }\ntemplate<class T> T sum(vector<vector<vector<vector<vector<T>>>> > &v, int s, int t) {T ret = 0;rep(i, s, min(sz(v), t))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<vector<vector<vector<T>>>> > &v, int t = inf) { return sum(v, 0, t); }\n\ntemplate<class T> auto sum(priority_queue<T, vector<T>, greater<T> > &r) {    auto q = r;    T ret = 0;    while (sz(q)) {        ret += q.top();        q.pop();    }    return ret;}\ntemplate<class T> auto sum(priority_queue<T> &r) {    auto q = r;    T ret = 0;    while (sz(q)) {        ret += q.top();        q.pop();    }    return ret;}\ntemplate<class T> T mul(vector<T> &v, ll t = inf) {    T ret = v[0];    rep(i, 1, min(t, sz(v)))ret *= v[i];    return ret;}\n\n//template<class T, class U, class... W>  auto sumn(vector<T> &v, U head, W... tail) {    auto ret = sum(v[0], tail...);    rep(i, 1, min(sz(v), head))ret += sum(v[i], tail...);    return ret;}\nvi v_i(vi &a) {    int n = max(a) + 1;    vi ret(n, -1);    rep(i, sz(a)) {        ret[a[i]] = i;    }    return ret;}\nvoid clear(PQ &q) { q = PQ(); }\nvoid clear(priority_queue<int>&q) { q = priority_queue<int>();}\ntemplate<class T> void clear(queue<T> &q) { while (q.size())q.pop(); }\ntemplate<class T> T *negarr(ll size) {    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));    return body + size;}\ntemplate<class T> T *negarr2(ll h, ll w) {    double **dummy1 = new double *[2 * h + 1];    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];    dummy1[0] = dummy2 + w;    for (ll i = 1; i <= 2 * h + 1; ++i) { dummy1[i] = dummy1[i - 1] + 2 * w + 1; }    double **a = dummy1 + h;    return a;}\n//imoは0-indexed\n//ruiは1-indexed\ntemplate<class T> vector<T> imo(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    return ret;}\n//kと同じものの数\ntemplate<class T, class U> vi imo(vector<T> &a, U k) {vector<T> ret = a;rep(i, sz(ret))ret[i] = a[i] == k;rep(i, sz(ret) - 1)ret[i + 1] += ret[i];return ret;}\ntemplate<class T> vector<T> imox(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] ^= ret[i];    return ret;}\n//漸化的に最小を持つ\ntemplate<class T> vector<T> imi(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chmi(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> ima(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chma(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> rimi(vector<T> &v) {    vector<T> ret = v;    rer(i, sz(ret) - 1, 1)chmi(ret[i - 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> rima(vector<T> &v) {    vector<T> ret = v;    rer(i, sz(ret) - 1, 1)chma(ret[i - 1], ret[i]);    return ret;}\ntemplate<class T> struct ruiC {\n    vector<T> rui;\n    ruiC(vector<T> &ru) : rui(ru) {}\n    /*先頭0*/\n    ruiC() : rui(1, 0) {}\n    T operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruic \";            deb(l, r);            assert(0);        }        return rui[r] - rui[l];    }\n    T operator()(int r) { return operator()(0, r); }\n    /*ruiv[]をruic[]に変えた際意味が変わるのがまずいため()と統一*/\n    /*単体iを返す 累積でないことに注意(seg木との統一でこうしている)*/\n//    T operator[](ll i) { return rui[i + 1] - rui[i]; }\n    T operator[](ll i) { return rui[i]; }\n    /*0から順に追加される必要がある*/\n    void operator+=(T v) { rui.push_back(rui.back() + v); }\n    void add(int i, T v) {if (sz(rui) - 1 != i)ole();operator+=(v);}\n    T back() { return rui.back(); }\n    ll size() { return rui.size(); }\n    auto begin(){return rui.begin();}\n    auto end(){return rui.end();}\n};\ntemplate<class T> struct ruimax {template<typename Monoid>struct SegmentTree {        /*pairで処理*/        int sz;        vector<Monoid> seg;        const Monoid M1 = mp(MIN(T), -1);        Monoid f(Monoid a, Monoid b) {            return max(a, b);        }        void build(vector<T> &a) {            int n = sz(a);            sz = 1;            while (sz < n) sz <<= 1;            seg.assign(2 * sz, M1);            rep(i, n) { seg[i + sz] = mp(a[i], i); }            for (int k = sz - 1; k > 0; k--) {                seg[k] = f(seg[k << 1], seg[(k << 1) | 1]);            }        }        Monoid query(int a, int b) {            Monoid L = M1, R = M1;            for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {                if (a & 1) L = f(L, seg[a++]);                if (b & 1) R = f(seg[--b], R);            }            return f(L, R);        }        Monoid operator[](const int &k) const {            return seg[k + sz];        }    };private:vector<T> ve;SegmentTree<pair<T, int>> seg;vector<T> rv;vector<T> ri;bool build = false;\npublic:\n    int n;\n    ruimax(vector<T> &a) : ve(a), n(sz(a)) {        int index = -1;        int ma = MIN(T);        rv.resize(n + 1);        ri.resize(n + 1);        rv[0] = -linf;        ri[0] = -1;        rep(i, n) {            if (chma(ma, a[i])) {                index = i;            }            rv[i + 1] = ma;            ri[i + 1] = index;        }    }\n    T operator()(int l, int r) {        if (!(l <= r && 0 <= l && r <= n)) {            deb(l, r, n);            assert(0);        }        if (l == 0) {            return rv[r];        } else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).first;        }    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) {        return operator()(0, r);    }\n    T getv(int l, int r) {        return operator()(l, r);    }\n    T geti(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) {            return ri[r];        } else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).second;        }    }\n    T geti(int r = inf) { return geti(0, min(r,n)); };\n    T getv(int r = inf) { return getv(0, min(r,n)); };\n    auto begin(){return rv.begin();}\n    auto end(){return rv.end();}\n};\ntemplate<class T> struct ruimin {template<typename Monoid>    struct SegmentTree {  /*pairで処理*/         int sz;        vector<Monoid> seg;        const Monoid M1 = mp(MAX(T), -1);        Monoid f(Monoid a, Monoid b) {            return min(a, b);        }        void build(vector<T> &a) {            int n = sz(a);            sz = 1;            while (sz < n) sz <<= 1;            seg.assign(2 * sz, M1);            rep(i, n) { seg[i + sz] = mp(a[i], i); }            for (int k = sz - 1; k > 0; k--) {                seg[k] = f(seg[k << 1], seg[(k << 1) | 1]);            }        }        Monoid query(int a, int b) {            Monoid L = M1, R = M1;            for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {                if (a & 1) L = f(L, seg[a++]);                if (b & 1) R = f(seg[--b], R);            }            return f(L, R);        }        Monoid operator[](const int &k) const {            return seg[k + sz];        }    };private:vector<T> ve;SegmentTree<pair<T, int>> seg;vector<T> rv;vector<T> ri;bool build = false;int n;\npublic:\n    ruimin(vector<T> &a) : ve(a), n(sz(a)) {        int index = -1;        int mi = MAX(T);        rv.resize(n + 1);        ri.resize(n + 1);        rv[0] = linf;        ri[0] = -1;        rep(i, n) {            if (chmi(mi, a[i])) {                index = i;            }            rv[i + 1] = mi;            ri[i + 1] = index;        }    }\n    T operator()(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) {            return rv[r];        } else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).first;        }    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) {return operator()(0, r);}\n    T getv(int l, int r) {        return operator()(l, r);    }\n    T geti(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) {            return ri[r];        } else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).second;        }    }\n    T geti(int r = inf) { return geti(0, min(r,n)); };\n    T getv(int r = inf) { return getv(0, min(r,n)); };\n    auto begin(){return rv.begin();}\n    auto end(){return rv.end();}\n};\n\ntemplate<class T>ostream &operator<<(ostream &os, ruiC<T> a) {fora(v,a.rui)os<<v<<\" \";return os;}\ntemplate<class T> vector<T> ruiv(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i];    return ret;}\ntemplate<class T> ruiC<T> ruic() {return ruiC<T>();}\ntemplate<class T> ruiC<T> ruic(vector<T> &a) {    vector<T> ret = ruiv(a);    return ruiC<T>(ret);}\nvvi() ruib(vi &a) {    vvi(res, 61, sz(a) + 1);    rep(k, 61) {        rep(i, sz(a)) {            res[k][i + 1] = res[k][i] + ((a[i] >> k) & 1);        }    }    return res;}\nvector<ruiC<int>> ruibc(vi &a) {    vector<ruiC<int>> ret(61);    vvi(res, 61, sz(a));    rep(k, 61) {        rep(i, sz(a)) {            res[k][i] = (a[i] >> k) & 1;        }        ret[k] = ruic(res[k]);    }    return ret;}\nvector<ll> ruiv(string &a) {    if (sz(a) == 0)return vi(1);    ll dec = ('0' <= a[0] && a[0] <= '9') ? '0' : 0;    vector<ll> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i] - dec;    return ret;}\nruiC<ll> ruic(string &a) {    vector<ll> ret = ruiv(a);    return ruiC<ll>(ret);}\n//kと同じものの数\ntemplate<class T, class U> vi ruiv(T &a, U k) {    vi ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + (a[i] == k);    return ret;}\ntemplate<class T, class U> ruiC<ll> ruic(T &a, U k) {    vi ret = ruiv(a, k);    return ruiC<ll>(ret);}\ntemplate<class T> struct ruiC2 {\n    int H;\n    vector<ruiC<T>> rui;\n    ruiC2(vector<vector<T>> &ru) : rui(sz(ru)),H(sz(ru)) {        for (int h = 0; h < H; h++){            rui[h] = ruic(ru[h]);        }    }\n    //WについてHを返す\n    vector<T> operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruic \";            deb(l, r);            assert(0);        }        vector<T> res(H);        for (int h = 0; h < H; h++)res[h]=rui[h](l, r);        return res;    }\n    //HについてWを返す\n    ruiC<T> operator[](ll h){ assert(h<H);return rui[h]; }\n    //    vector<T> operator()(int r) { return operator()(0, r); }\n    /*ruiv[]をruic[]に変えた際意味が変わるのがまずいため()と統一*/\n    /*単体iを返す 累積でないことに注意(seg木との統一でこうしている)*/\n//    T operator[](ll i) { return rui[i + 1] - rui[i]; }\n    /*0から順に追加される必要がある*/\n//    T back() { return rui.back(); }\n//    ll size() { return rui.size(); }\n//    auto begin(){return rui.begin();}\n//    auto end(){return rui.end();}\n};\n\n//a~zを0~25として\n// rui(l,r)でvector(26文字について, l~rのcの個数)\n// rui[h] ruic()を返す\nruiC2<ll> ruicou(str &a) {    str s = a;    replace(s);    vector<ruiC<ll>> res(26);    vvi(cou, 26, sz(s));    rep(i, sz(s)) { cou[s[i]][i] = 1; }    return ruiC2<ll>(cou);}\nruiC2<ll> ruicou(vi &a) {    int H = max(a) + 1;    vector<ruiC<ll>> res(H);    vvi(cou, H, sz(a));    rep(i, sz(a)) { cou[a[i]][i] = 1; }    return ruiC2<ll>(cou);}\n\n/*@formatter:off*/\n//h query\ntemplate<class T> vector<T> imoh(vector<vector<T>> &v, int w) {vector<T> ret(sz(v));rep(h,sz(ret)){ret[h] = v[h][w];}rep(i, sz(ret) - 1){ret[i + 1] += ret[i];}return ret;}\ntemplate<class T> vector<T> ruih(vector<vector<T>> &v, int w) {vector<T> ret(sz(v) + 1);rep(h, sz(v)) { ret[h + 1] = v[h][w]; }rep(i, sz(v)) { ret[i + 1] += ret[i]; }return ret;}\ntemplate<class T> ruiC<T> ruihc(vector<vector<T>> &a, int w) {vector<T> ret = ruih(a, w);return ruiC<T>(ret);}\n\n//xor\ntemplate<class T> struct ruixC {    vector<T> rui;    ruixC(vector<T> &ru) : rui(ru) {}    T operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruiXc \";            deb(l, r);            assert(0);        }        return rui[r] ^ rui[l];    }    T operator[](ll i) { return rui[i]; }    T back() { return rui.back(); }    ll size() { return rui.size(); }};\ntemplate<class T> vector<T> ruix(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] ^ a[i];    return ret;}\ntemplate<class T> ruixC<ll> ruixc(vector<T>  &a) {vi ret = ruix(a);return ruixC<ll>(ret);}\ntemplate<class T> vector<T> ruim(vector<T> &a) {    vector<T> res(a.size() + 1, 1);    rep(i, a.size())res[i + 1] = res[i] * a[i];    return res;}\n//漸化的に最小を1indexで持つ\ntemplate<class T> vector<T> ruimi(vector<T> &a) {    ll n = sz(a);    vector<T> ret(n + 1);    rep(i, 1, n) {        ret[i] = a[i - 1];        chmi(ret[i + 1], ret[i]);    }    return ret;}\n//template<class T> T *rrui(vector<T> &a) {\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> struct rruiC {\n    vector<T> rui;\n    int n;\n    rruiC(vector<T> &a) : n(sz(a)) {rui.resize(n + 1);rer(i, n - 1) {rui[i] = rui[i + 1] + a[i];}}\n    /*[r l)*/\n    T operator()(int r, int l) {r++;l++;assert(l <= r && l >= 0 && r <= n);return rui[l] - rui[r];}\n    T operator()(int l) {return operator()(n - 1, l);}\n    T operator[](int i) {return operator()(i);}\n};\ntemplate<class T> ostream &operator<<(ostream &os, rruiC<T> a) {fora(v, a.rui)os << v << \" \";return os;}\n\n#define rrui rruic\ntemplate<class T> rruiC<T> rruic(vector<T> &a) { return rruiC<T>(a); }\n\n//掛け算\ntemplate<class T> struct ruimulC {\n    vector<T> rv;\n    int n;\n    ruimulC(vector<T> &a) : rv(a), n(sz(a)) {rv.resize(n + 1);rv[0] = 1;rep(i, n) { rv[i + 1] = a[i] * rv[i]; }}\n    ruimulC() : n(0) {rv.resize(n + 1);rv[0] = 1;}\n    void operator+=(T v) {rv.push_back(rv.back()*v);n++;}\n    T operator()(int l, int r) {assert(l <= r && 0 <= l && r <= n);return rv[r] / rv[l];}\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) { return operator()(0, r); }\n    auto begin() { return rv.begin(); }\n    auto end() { return rv.end(); }\n};\ntemplate<class T> ruimulC<T> ruimul(vector<T> &a) { return ruimulC<T>(a); }\ntemplate<class T> ruimulC<T> ruimul() {vector<T> a; return ruimulC<T>(a); }\n/*@formatter:off*/\ntemplate<class T> T *rruim(vector<T> &a) {    ll len = a.size();    T *body = (T *) malloc((len + 1) * sizeof(T));    T *res = body + 1;    res[len - 1] = 1;    rer(i, len - 1)res[i - 1] = res[i] * a[i];    return res;}\ntemplate<class T, class U> void inc(pair<T,U> &a, U v = 1) { a.first += v,a.second+=v; }\ntemplate<class T, class U> void inc(T &a, U v = 1) { a += v; }\ntemplate<class T, class U> void inc(vector<T> &a, U v = 1) { for (auto &u:a)inc(u, v); }\ntemplate<class T, class U> void dec(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U> void dec(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class U> void dec(string &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T,class U, class W> void dec(vector<T> &a,vector<U> &b, W v = 1) { for (auto &u :a)dec(u, v);for (auto &u :b)dec(u, v); }\ntemplate<class T,class U,class W> void dec(vector<T> &a,vector<U> &b,vector<W>&c ) { for (auto &u :a)dec(u, 1);for (auto &u :b)dec(u, 1);for (auto &u :c)dec(u, 1); }\nbool ins(ll h, ll w, ll H, ll W) { return h >= 0 && w >= 0 && h < H && w < W; }\nbool ins(ll l, ll v, ll r) { return l <= v && v < r; }\ntemplate<class T> bool ins(vector<T> &a, ll i, ll j = 0) { return ins(0, i, sz(a)) && ins(0, j, sz(a)); }\n#define inside ins\nll u(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u(vector<T> &a) {    vector<T> ret = a;    fora(v, ret)v = u(v);    return ret;}\n\n//添え字を返す\ntemplate<class F> ll goldd_l(ll left, ll right, F calc) {    double GRATIO = 1.6180339887498948482045868343656;    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));    ll fl = calc(lm);    ll fr = calc(rm);    while (right - left > 10) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + (ll) ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    ll minScore = MAX(ll);    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (minScore > score) {            minScore = score;            resIndex = i;        }    }    return resIndex;}\ntemplate<class F> ll goldt_l(ll left, ll right, F calc) {        double GRATIO = 1.6180339887498948482045868343656;        ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));        ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));        ll fl = calc(lm);        ll fr = calc(rm);        while (right - left > 10) {            if (fl > fr) {                right = rm;                rm = lm;                fr = fl;                lm = left + (ll) ((right - left) / (GRATIO + 1.0));                fl = calc(lm);            } else {                left = lm;                lm = rm;                fl = fr;                rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));                fr = calc(rm);            }        }    if (left > right) {        ll l = left;        left = right;        right = l;    }    ll maxScore = MIN(ll);    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (maxScore < score) {            maxScore = score;            resIndex = i;        }    }    return resIndex;}\n/*loopは200にすればおそらく大丈夫 余裕なら300に*/\ntemplate<class F> dou goldd_d(dou left, dou right, F calc, ll loop = 200) {    dou GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    /*200にすればおそらく大丈夫*/    /*余裕なら300に*/    ll k = 141;    loop++;    while (--loop) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return left;}\ntemplate<class F> dou goldt_d(dou left, dou right, F calc, ll loop = 200) {    double GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    loop++;    while (--loop) {        if (fl > fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return left;}\n//l ~ rを複数の区間に分割し、極致を与えるiを返す time-20 msまで探索\ntemplate<class F> ll goldd_ls(ll l, ll r, F calc, ll time = 2000) {    auto lim = milliseconds(time - 20);    ll mini = 0, minv = MAX(ll);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldd_l(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return mini;}\ntemplate<class F> ll goldt_ls(ll l, ll r, F calc, ll time = 2000) {    auto lim = milliseconds(time - 20);    ll maxi = 0, maxv = MIN(ll);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldt_l(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return maxi;}\ntemplate<class F> dou goldd_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を持つ*/    auto lim = milliseconds(time - 20);    dou mini = 0, minv = MAX(dou);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldd_d(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return mini;}\ntemplate<class F> dou goldt_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を残している*/    auto lim = milliseconds(time - 20);    dou maxi = 0, maxv = MIN(dou);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldt_d(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return maxi;}\ntemplate<class T> T min(vector<vector<T >> &a) {    T res = MAX(T);    rep(i, a.size())chmi(res, *min_element(all(a[i])));    return res;}\ntemplate<class T> T max(vector<vector<T >> &a) {    T res = MIN(T);    rep(i, a.size())chma(res, *max_element(all(a[i])));    return res;}\ntemplate<class T> T min(vector<vector<vector<T>>> &a) {    T res = MAX(T);    rep(i, a.size())chmi(res, min(a[i]));    return res;}\ntemplate<class T> T max(vector<vector<vector<T>>> &a) {    T res = MIN(T);    rep(i, a.size())chma(res, max(a[i]));    return res;}\ntemplate<class T> T min(vector<vector<vector<vector<T>>>> &a) {    T res = MAX(T);    rep(i, a.size())chmi(res, min(a[i]));    return res;}\ntemplate<class T> T max(vector<vector<vector<vector<T>>>> &a) {    T res = MIN(T);    rep(i, a.size())chma(res, max(a[i]));    return res;}\ntemplate<class T> T min(vector<vector<vector<vector<vector<T>>>>> &a) {    T res = MAX(T);    rep(i, a.size())chmi(res, min(a[i]));    return res;}\ntemplate<class T> T max(vector<vector<vector<vector<vector<T>>>>> &a) {    T res = MIN(T);    rep(i, a.size())chma(res, max(a[i]));    return res;}\ntemplate<class T> T min(vector<vector<vector<vector<vector<vector<T>>>>>> &a) {    T res = MAX(T);    rep(i, a.size())chmi(res, min(a[i]));    return res;}\ntemplate<class T> T max(vector<vector<vector<vector<vector<vector<T>>>>>> &a) {    T res = MIN(T);    rep(i, a.size())chma(res, max(a[i]));    return res;}\n//pow周りの仕様\n//powiを使うと整数型\n//powbを使うとbint型\n//powを使うと powlに変換され long doubleが返る\n#ifdef _DEBUG\nauto pow(ll a,ll k){    static bool was = 1;    if(was){message +=\"if integer use *powi* it's very fast\\n\";}    was=0;    return powl(a,k);}\n//上のメッセージを出すための関数\nauto pow(signed a,ll k){    return pow((ll)a,k);}\nauto pow(signed a,signed k){    return pow((ll)a,(ll)k);}\n#else\n#define pow powl\n\n#endif\n//整数型のpow\nint powi(int a, int k) {    if (a == 2)return 1ll << k;    int res = 1;    int x = a;    while (k) {        if(k & 1)res *= x;        x *= x;        k >>= 1;    }    return res;}\n//define pow powlより上に動かすとバグる\nbint pow(bint a, ll k) {    bint res = 1;    bint x = a;    while (k) {        if(k & 1)res *= x;        x *= x;        k >>= 1;    }    return res;}\nbint pow(bint a, signed k) {return pow(a,(ll)k);}\nbint powb(int a, int b){return pow((bint)a,b);}\nconstexpr bool bget(ll m, ll keta) {\n    #ifdef _DEBUG\n        assert(keta<=62);//オーバーフロー 1^62までしか扱えない\n    #endif\n    return (m >> keta) & 1; }\n//bget(n)次元\n//                          NならN-1まで\nvector<vi> bget2(vi& a,int keta_size){    vvi(res,keta_size,sz(a));    rep(k,keta_size){        rep(i, sz(a)){            res[k][i]=bget(a[i],k);        }    }    return res;}\nvi bget1(vi& a,int keta){    vi res(sz(a));    rep(i, sz(a)){        res[i]=bget(a[i],keta);    }    return res;}\nll bget(ll m, ll keta, ll sinsuu) {    m /= (ll) pow(sinsuu, keta);    return m % sinsuu;}\nconstexpr ll bit(ll n) {\n    #ifdef _DEBUG\n        assert(n<=62);//オーバーフロー 1^62までしか扱えない\n    #endif\n    return (1LL << (n)); }\nll bit(ll n, ll sinsuu) { return (ll) pow(sinsuu, n); }\nll mask(ll n) { return (1ll << n) - 1; }\n//aをbitに置きなおす\n//{0, 2} -> 101\nll bit(vi&a){    int m=0;    for(auto&& v:a) m|=bit(v);    return m;}\n\n//{1, 1, 0} -> 011\n//bitsetに置き換える感覚 i が立っていたら i bit目を立てる\nll bitb(vi&a){    int m=0;    rep(i,sz(a)) if(a[i])m|=bit(i);    return m;}\n#define bcou __builtin_popcountll\n//最下位ビット\nll lbit(ll n) { return n & -n; }\nll lbiti(ll n) { return log2(n & -n); }\n//最上位ビット\nll hbit(ll n) {    n |= (n >> 1);    n |= (n >> 2);    n |= (n >> 4);    n |= (n >> 8);    n |= (n >> 16);    n |= (n >> 32);    return n - (n >> 1);}\nll hbiti(ll n){return log2(hbit(n));}\nll hbitk(ll n) {    ll k = 0;    rer(i, 5) {        ll a = k + (1ll << i);        ll b = 1ll << a;        if (b <= n)k += 1ll << i;    }    return k;}\n//初期化は0を渡す\nll nextComb(ll &mask, ll n, ll r) {    if (!mask)return mask = (1LL << r) - 1;    ll x = mask & -mask; /*最下位の1*/    ll y = mask + x; /*連続した下の1を繰り上がらせる*/    ll res = ((mask & ~y) / x >> 1) | y;    if (bget(res, n))return mask = 0; else return mask = res;}\n//n桁以下でビットがr個立っているもののvectorを返す\nvi bitCombList(ll n, ll r) {    vi res;    ll m = 0;    while (nextComb(m, n, r)) { res.push_back(m); }    return res;}\n//masの立ってるindexを見る\n#define forbit(i, mas) for (int forbitj = lbit(mas), forbitm = mas, i = log2(forbitj); forbitm; forbitm = forbitj ? forbitm ^ forbitj : 0, forbitj = lbit(forbitm), i = log2(forbitj))\n\nchar itoal(ll i) { return 'a' + i; }\nchar itoaL(ll i) { return 'A' + i; }\nll altoi(char c) {    if ('A' <= c && c <= 'Z')return c - 'A';    return c - 'a';}\nll ctoi(char c) { return c - '0'; }\nchar itoc(ll i) { return i + '0'; }\nll vtoi(vi &v) {    ll res = 0;    if (sz(v) > 18) {        debugline(\"vtoi\");        deb(sz(v));        ole();    }    rep(i, sz(v)) {        res *= 10;        res += v[i];    }    return res;}\nvi itov(ll i) {    vi res;    while (i) {        res.push_back(i % 10);        i /= 10;    }    rev(res);    return res;}\nvi stov(string &a) {    ll n = sz(a);    vi ret(n);    rep(i, n) { ret[i] = a[i] - '0'; }    return ret;}\n//基準を満たさないものは0になる\nvi stov(string &a, char one) {    ll n = sz(a);    vi ret(n);    rep(i, n)ret[i] = a[i] == one;    return ret;}\nvector<vector<ll>> ctoi(vector<vector<char>> s, char c) {    ll n = sz(s), m = sz(s[0]);    vector<vector<ll>> res(n, vector<ll>(m));    rep(i, n)rep(j, m)res[i][j] = s[i][j] == c;    return res;}\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\n//[i] := vを返す\n//aは0~n-1で置き換えられる\nvi compress(vi &a) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(all(b), a[i]) - b.begin(); }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, umap<ll, ll> &map) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) {        ll v = a[i];        a[i] = lower_bound(all(b), a[i]) - b.begin();        map[v] = a[i];    }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r) {    vi b;    ll len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r, vi &s) {    vi b;    ll len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    fora(v, s)b.push_back(v);    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    for (ll i = 0; i < sz(s); ++i) r[i] = lower_bound(all(b), s[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vi> &a) {    vi b;    fora(vv, a)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vv, a)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vector<vi >> &a) {    vi b;    fora(vvv, a)fora(vv, vvv)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vvv, a)fora(vv, vvv)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvoid compress(ll a[], ll len) {    vi b;    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(all(b), a[i]) - b.begin(); }}\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(all(a),v))\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n#define rlowerIndex(a, v) (upper_bound(all(a),v)-a.begin()-1)\n#define rupperIndex(a, v) (lower_bound(all(a),v)-a.begin()-1)\n\ntemplate<class T, class U, class W> T lowerBound(vector<T> &a, U v, W banpei) {auto it = lower_bound(a.begin(), a.end(), v);if (it == a.end())return banpei; else return *it;}template<class T, class U, class W> T lowerBound(ruiC<T> &a, U v, W banpei) {return lowerBound(a.rui, v, banpei);}\ntemplate<class T, class U, class W> T upperBound(vector<T>& a, U v, W banpei){    auto it = upper_bound(a.begin(),a.end(),v);    if(it==a.end())return banpei;    else return *it;}template<class T, class U, class W> T upperBound(ruiC<T> &a, U v, W banpei) {return upperBound(a.rui, v, banpei);}\ntemplate<class T, class U, class W> T rlowerBound(vector<T> &a, U v, W banpei) {    auto it = upper_bound(a.begin(), a.end(), v);    if (it == a.begin())return banpei;    else{        return *(--it);    }}template<class T, class U, class W> T rlowerBound(ruiC<T> &a, U v, W banpei) {return rlowerBound(a.rui, v, banpei);}\ntemplate<class T, class U, class W> T rupperBound(vector<T> &a, U v, W banpei) {    auto it = lower_bound(a.begin(), a.end(), v);    if (it == a.begin())return banpei;    else{        return *(--it);    }}template<class T, class U, class W> T rupperBound(ruiC<T> &a, U v, W banpei) {return rupperBound(a.rui, v, banpei);}\n#define next2(a) next(next(a))\n#define prev2(a) prev(prev(a))\n\n//狭義の単調増加列 長さを返す\ntemplate<class T> int lis(vector<T> &a) {    int n = sz(a);    vi tail(n + 1, MAX(T));    rep(i, n) {        int id = lowerIndex(tail, a[i]);/**/        tail[id] = a[i];    }    return lowerIndex(tail, MAX(T));}\ntemplate<class T> int lis_eq(vector<T> &a) {    int n = sz(a);    vi tail(n + 1, MAX(T));    rep(i, n) {        int id = upperIndex(tail, a[i]);/**/        tail[id] = a[i];    }    return lowerIndex(tail, MAX(T));}\n\n//iteratorを返す\n//valueが1以上の物を返す 0は見つけ次第削除\n//vを減らす場合 (*it).se--でいい\ntemplate<class T, class U, class V> auto lower_map(map<T, U> &m, V k) {    auto ret = m.lower_bound(k);    while (ret != m.end() && (*ret).second == 0) {        ret = m.erase(ret);    }    return ret;}\ntemplate<class T, class U, class V> auto upper_map(map<T, U> &m, V k) {    auto ret = m.upper_bound(k);    while (ret != m.end() && (*ret).second == 0) {        ret = m.erase(ret);    }    return ret;}\n//存在しなければエラー\ntemplate<class T, class U, class V> auto rlower_map(map<T, U> &m, V k) {    auto ret = upper_map(m, k);    assert(ret != m.begin());    ret--;    while (1) {        if ((*ret).second != 0)break;        assert(ret != m.begin());        auto next = ret;        --next;        m.erase(ret);        ret = next;    }    return ret;}\ntemplate<class T, class U, class V> auto rupper_map(map<T, U> &m, V k) {    auto ret = lower_map(m, k);    assert(ret != m.begin());    ret--;    while (1) {        if ((*ret).second != 0)break;        assert(ret != m.begin());        auto next = ret;        --next;        m.erase(ret);        ret = next;    }    return ret;}\n\ntemplate<class... T> void fin(T... s) {out(s...); exit(0); }\n\n//便利 数学 math\n//sub ⊂ top\nbool subset(int sub, int top) {return (sub & top) == sub;}\n//-180 ~ 180 degree\ndouble atand(double h, double w) {return atan2(h, w) / PI * 180;}\n//% -mの場合、最小の正の数を返す\nll mod(ll a, ll m) {if (m < 0) m *= -1;return (a % m + m) % m;}\nll pow(ll a) { return a * a; };\nll fact(ll v) { return v <= 1 ? 1 : v * fact(v - 1); }\ndou factd(int v){static vd fact(2,1);    if(sz(fact)<=v){        rep(i,sz(fact),v+1){            fact.push_back(fact.back()*i);        }    }    return fact[v];}\n\nll comi(ll n, ll r) {    assert(n < 100);    static vvi(pas, 100, 100);    if (pas[0][0])return pas[n][r];    pas[0][0] = 1;    rep(i, 1, 100) {        pas[i][0] = 1;        rep(j, 1, i + 1)pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];    }    return pas[n][r];}\ndouble comd2(ll n, ll r) {    static vvd(comb, 2020, 2020);    if (comb[0][0] == 0) {        comb[0][0] = 1;        rep(i, 2000) {            comb[i + 1][0] = 1;            rep(j, 1, i + 2) { comb[i + 1][j] = comb[i][j] + comb[i][j - 1]; }        }    }    return comb[n][r];}\ndouble comd(int n, int r) {    if (r < 0 || r > n) return 0;    if (n < 2020)return comd2(n, r);    static vd fact(2, 1);    if (sz(fact) <= n) { rep(i, sz(fact), n + 1) { fact.push_back(fact.back() * i); }}    return fact[n] / fact[n - r] / fact[r];}\n\nll gcd(ll a, ll b) {while (b) a %= b, swap(a, b);return abs(a);}\nll gcd(vi b) {ll res = b[0];rep(i, 1, sz(b))res = gcd(b[i], res);return res;}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll lcm(vi a) {ll res = a[0];rep(i, 1, sz(a))res = lcm(a[i], res);return res;}\nll ceil(ll a, ll b) {if (b == 0) {debugline(\"ceil\");deb(a, b);ole();return -1;} else if (a < 0) { return 0; } else { return (a + b - 1) / b; }}\n\nll sig0(ll t) { return t <= 0 ? 0 : ((1 + t) * t) >> 1; }\n//ll sig(ll s, ll t) { return ((s + t) * (t - s + 1)) >> 1; }\nll sig(ll s, ll t) {if (s > t)swap(s, t);return sig0(t - s) + s * (t - s + 1);}\n\n#define tousa_i tosa_i\n#define lower_tousa_i lower_tosa_i\n#define upper_tousa upper_tosa\n#define upper_tousa_i upper_tosa_i\nll tosa_i(ll st, ll ad, ll v) {    assert(((v - st) % ad) == 0);    return (v - st) / ad;}\nll tosa_s(ll st, ll ad, ll len) {    return st * len + sig0(len - 1) * ad;}\n\n// ax + r (x は非負整数) で表せる整数のうち、v 以上となる最小の整数\nll lower_tosa(ll st, ll ad, ll v) {    if (st >= v) return st;    return (v - st + ad - 1) / ad * ad + st;}\n//第何項か\nll lower_tosa_i(ll st, ll ad, ll v) {    if (st >= v) return 0;    return (v - st + ad - 1) / ad;}\nll upper_tosa(ll st, ll ad, ll v) { return lower_tosa(st, ad, v + 1); }\nll upper_tosa_i(ll st, ll ad, ll v) { return lower_tosa_i(st, ad, v + 1); }\n\n\n//v * v >= aとなる最小のvを返す\nll sqrt(ll a) {    if (a < 0) {        debugline(\"sqrt\");        deb(a);        ole();    }    ll res = (ll) std::sqrt(a);    while (res * res < a)++res;    return res;}\ndouble log(double e, double x) { return log(x) / log(e); }\n\n\n/*@formatter:off*/\n\n//機能拡張\n#define dtie(a, b) int a, b; tie(a, b)\ntemplate<class T, class U> string to_string(T a, U b) {    string res = \"\";    res += a;    res += b;    return res;}\ntemplate<class T, class U, class V> string to_string(T a, U b, V c) {    string res = \"\";    res += a;    res += b;    res += c;    return res;}\ntemplate<class T, class U, class V, class W> string to_string(T a, U b, V c, W d) {    string res = \"\";    res += a;    res += b;    res += c;    res += d;    return res;}\ntemplate<class T, class U, class V, class W, class X> string to_string(T a, U b, V c, W d, X e) {    string res = \"\";    res += a;    res += b;    res += c;    res += d;    res += e;    return res;}\n\n\nconstexpr int bsetlen = k5 * 2;\n//constexpr int bsetlen = 5050;\n#define bset bitset<bsetlen>\nbool operator<(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] < b[i])return true;if (a[i] > b[i])return false;}return false;}\nbool operator>(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] > b[i])return true;if (a[i] < b[i])return false;}return false;}\nbool operator<=(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] < b[i])return true;if (a[i] > b[i])return false;}return true;}\nbool operator>=(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] > b[i])return true;if (a[i] < b[i])return false;}return true;}\nstring operator~(string &a) {string res = a;for (auto &&c:res) {if (c == '0')c = '1';else if (c == '1')c = '0';else {cerr << \"cant ~\" << a << \"must bit\" << endl;exit(0);}}return res;}\nostream &operator<<(ostream &os, bset& a) {    bitset<10> b;    vi list;    rep(i,bsetlen){        if(a[i])list.push_back(i),b[i]=1;    }    os<<b<<\", \"<<list;    return os;}\nint hbiti(bset&a){rer(i,bsetlen){if(a[i])return i;}return -1;}\n#define hk(a, b, c) (a <= b && b < c)\n\n//O(N/64)\nbset nap(bset &a, int v) {bset r = a | a << v;return r;}\nbset nap(bset &a, bset &v) {bset r = a;rep(i, bsetlen) {if (v[i])r |= a << i;}return r;}\n\n\ntemplate<class T> void seth(vector<vector<T>> &S, int w, vector<T> &v) {assert(sz(S) == sz(v));assert(w < sz(S[0]));rep(h, sz(S)) { S[h][w] = v[h]; }}\n\ntemplate<class T, class U> void operator+=(pair<T,U> &a, pair<T,U> & b) {a.fi+=b.fi;a.se+=b.se;}\ntemplate<class T, class U> pair<T,U> operator+(pair<T,U> &a, pair<T,U> & b) {return pair<T,U>(a.fi+b.fi,a.se+b.se);}\n\ntemplate<typename CharT, typename Traits, typename Alloc>basic_string<CharT, Traits, Alloc>operator+(const basic_string<CharT, Traits, Alloc> &lhs, const int rv) {    basic_string<CharT, Traits, Alloc> str(lhs);    str.append(to_string(rv));    return str;}template<typename CharT, typename Traits, typename Alloc>void operator+=(basic_string<CharT, Traits, Alloc> &lhs, const int rv) {    lhs += to_string(rv);}template<typename CharT, typename Traits, typename Alloc>basic_string<CharT, Traits, Alloc>operator+(const basic_string<CharT, Traits, Alloc> &lhs, const signed rv) {    basic_string<CharT, Traits, Alloc> str(lhs);    str.append(to_string(rv));    return str;}template<typename CharT, typename Traits, typename Alloc>void operator+=(basic_string<CharT, Traits, Alloc> &lhs, const signed rv) {    lhs += to_string(rv);}\ntemplate<typename CharT, typename Traits, typename Alloc> void operator*=(basic_string<CharT, Traits, Alloc> &s, int num) {auto bek = s;s = \"\";for (; num; num >>= 1) {if (num & 1) {s += bek;}bek += bek;}}\ntemplate<class T, class U> void operator+=(queue<T> &a, U v) { a.push(v); }template<class T, class U> void operator+=(deque<T> &a, U v) { a.push_back(v); }template<class T> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, vector<T> &v) {    fora(d, v)a.push(d);    return a;}template<class T, class U> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, U v) {    a.push(v);    return a;}template<class T, class U> priority_queue<T> &operator+=(priority_queue<T> &a, U v) {    a.push(v);    return a;}template<class T> set<T> &operator+=(set<T> &a, vector<T> v) {    fora(d, v)a.insert(d);    return a;}template<class T, class U> auto operator+=(set<T> &a, U v) { return a.insert(v); }template<class T, class U> auto operator-=(set<T> &a, U v) { return a.erase(v); }template<class T, class U> auto operator+=(mset<T> &a, U v) { return a.insert(v); }template<class T, class U> set<T, greater<T>> &operator+=(set<T, greater<T>> &a, U v) {    a.insert(v);    return a;}template<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {    a.push_back(v);    return a;}template<class T, class U> vector<T> operator+(vector<T> &a, U v) {    vector<T> ret = a;    ret += v;    return ret;}template<class T, class U> vector<T> operator+(U v, vector<T> &a) {    vector<T> ret = a;    ret.insert(ret.begin(), v);    return ret;}template<class T> vector<T> operator+(vector<T> a, vector<T> b) {    vector<T> ret;    ret = a;    fora(v, b)ret += v;    return ret;}template<class T> vector<T> &operator+=(vector<T> &a, vector<T> &b) {    rep(i, sz(b)) {/*こうしないとa+=aで両辺が増え続けてバグる*/        a.push_back(b[i]); }    return a;}template<class T, class U> map<T, U> &operator+=(map<T, U> &a, map<T, U> &b) {    fora(bv, b) { a[bv.first] += bv.second; }    return a;}\ntemplate<class T> void operator+=(mset<T> &a, vector<T>& v) { for(auto&& u : v)a.insert(u); }\ntemplate<class T> void operator+=(set<T> &a, vector<T>& v) { for(auto&& u : v)a.insert(u); }\ntemplate<class T> void operator+=(vector<T> &a, set<T>& v) { for(auto&& u : v)a.emplace_back(u); }\ntemplate<class T> void operator+=(vector<T> &a, mset<T>& v) { for(auto&& u : v)a.emplace_back(u); }\ntemplate<class T> vector<T> &operator-=(vector<T> &a, vector <T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-=\");        deb(a);        deb(b);        exit(0);    }    rep(i, sz(a))a[i] -= b[i];    return a;}\ntemplate<class T> vector<T> operator-(vector<T> &a, vector<T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-\");        deb(a);        deb(b);        ole();    }    vector<T> res(sz(a));    rep(i, sz(a))res[i] = a[i] - b[i];    return res;}\ntemplate<class T, class U> void operator*=(vector<T> &a, U b) {    vector<T> ta = a;    rep(b-1){        a+=ta;    }}\ntemplate<typename T> void erase(vector<T> &v, unsigned ll i) { v.erase(v.begin() + i); }\ntemplate<typename T> void erase(vector<T> &v, unsigned ll s, unsigned ll e) { v.erase(v.begin() + s, v.begin() + e); }\ntemplate<class T, class U> void erase(map<T, U> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<class T> void erase(set<T> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<typename T> void erasen(vector<T> &v, unsigned ll s, unsigned ll n) { v.erase(v.begin() + s, v.begin() + s + n); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, U t) { v.insert(v.begin() + i, t); }\ntemplate<typename T, typename U> void push_front(vector<T> &v, U t) { v.insert(v.begin(), t); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, vector<T> list) { for (auto &&va:list)v.insert(v.begin() + i++, va); }\ntemplate<typename T> void insert(set<T> &v, vector<T> list) { for (auto &&va :list)v.insert(va); }\ntemplate<class T> T poll(set<T>& S){T ret = *S.begin();S.erase(S.begin());return ret;}\ntemplate<class T> T poll(mset<T>& S){T ret = *S.begin();S.erase(S.begin());return ret;}\ntemplate<class T> T poll_back(set<T>& S){T ret = *S.rbegin();S.erase(S.rbegin());return ret;}\ntemplate<class T> T poll_back(mset<T>& S){T ret = *S.rbegin();S.erase(S.rbegin());return ret;}\ntemplate<class T> T peek(set<T>& S){T ret = *S.begin();return ret;}\ntemplate<class T> T peek(mset<T>& S){T ret = *S.begin();return ret;}\ntemplate<class T> T peek_back(set<T>& S){T ret = *S.rbegin();return ret;}\ntemplate<class T> T peek_back(mset<T>& S){T ret = *S.rbegin();return ret;}\n\nvector<string> split(const string a, const char deli) {    string b = a + deli;    ll l = 0, r = 0, n = b.size();    vector<string> res;    rep(i, n) {        if (b[i] == deli) {            r = i;            if (l < r)res.push_back(b.substr(l, r - l));            l = i + 1;        }    }    return res;}\nvector<string> split(const string a, const string deli) {    vector<string> res;    ll kn = sz(deli);    std::string::size_type Pos(a.find(deli));    ll l = 0;    while (Pos != std::string::npos) {        if (Pos - l)res.push_back(a.substr(l, Pos - l));        l = Pos + kn;        Pos = a.find(deli, Pos + kn);    }    if (sz(a) - l)res.push_back(a.substr(l, sz(a) - l));    return res;}\nvoid yn(bool a) { if (a)cout << \"yes\" << endl; else cout << \"no\" << endl; }\nvoid Yn(bool a) { if (a)cout << \"Yes\" << endl; else cout << \"No\" << endl; }\nvoid YN(bool a) { if (a)cout << \"YES\" << endl; else cout << \"NO\" << endl; }\nvoid fyn(bool a) {    if (a)cout << \"yes\" << endl; else cout << \"no\" << endl;    exit(0);}\nvoid fYn(bool a) {    if (a)cout << \"Yes\" << endl; else cout << \"No\" << endl;    exit(0);}\nvoid fYN(bool a) {    if (a)cout << \"YES\" << endl; else cout << \"NO\" << endl;    exit(0);}\nvoid fAb(bool a) { if(a)cout<<\"Alice\"<<endl;else cout<<\"Bob\";}\nvoid Possible(bool a) {    if (a)cout << \"Possible\" << endl; else cout << \"Impossible\" << endl;    exit(0);}\nvoid POSSIBLE(bool a) {    if (a)cout << \"POSSIBLE\" << endl; else cout << \"IMPOSSIBLE\" << endl;    exit(0);}\ntemplate<typename T> class fixed_point        : T {public:    explicit constexpr fixed_point(T &&t) noexcept: T(std::forward<T>(t)) {}    template<typename... Args> constexpr decltype(auto) operator()(Args &&... args) const { return T::operator()(*this, std::forward<Args>(args)...); }};template<typename T> static inline constexpr decltype(auto) fix(T &&t) noexcept { return fixed_point<T>{std::forward<T>(t)}; }\n\n\n//未分類\n//0,2,1 1番目と2番目の次元を入れ替える\ntemplate<class T> auto irekae(vector<vector<vector<T> > > &A, int x, int y, int z) {\n#define irekae_resize_loop(a, b, c) resize(res,a,b,c);rep(i,a)rep(j,b)rep(k,c)\n    vector<vector<vector<T> > > res;    if (x == 0 && y == 1 && z == 2) {        res = A;    } else if (x == 0 && y == 2 && z == 1) {        irekae_resize_loop(sz(A), sz(A[0][0]), sz(A[0])) {                    res[i][j][k] = A[i][k][j];                }    } else if (x == 1 && y == 0 && z == 2) {        irekae_resize_loop(sz(A[0]), sz(A), sz(A[0][0])) {                    res[i][j][k] = A[j][i][k];                }    } else if (x == 1 && y == 2 && z == 0) {        irekae_resize_loop(sz(A[0]), sz(A[0][0]), sz(A)) {                    res[i][j][k] = A[k][i][j];                }    } else if (x == 2 && y == 0 && z == 1) {        irekae_resize_loop(sz(A[0][0]), sz(A), sz(A[0])) {                    res[i][j][k] = A[j][k][i];                }    } else if (x == 2 && y == 1 && z == 0) {        irekae_resize_loop(sz(A[0][0]), sz(A[0]), sz(A)) {                    res[i][j][k] = A[k][j][i];                }    }    return res;\n#undef irekae_resize_loop\n}\ntemplate<class T> auto irekae(vector<vector<T>>&A,int i=1,int j=0){    vvt(res,sz(A[0]),sz(A));    rep(i,sz(A)){        rep(j,sz(A[0])){            res[j][i]=A[i][j];        }    }    return res;}\n//tou分割する\ntemplate<typename T> vector<vector<T>> cut(vector<T> &a, int tou = 2) {    int N = sz(a);    vector<vector<T>> res(tou);    int hab = N / tou;    vi lens(tou, hab);    rep(i, N % tou) { lens[tou - 1 - i]++; }    int l = 0;    rep(i, tou) {        int len = lens[i];        int r = l + len;        res[i].resize(len);        std::copy(a.begin() + l, a.begin() + r, res[i].begin());        l = r;    }    return res;}\n//長さn毎に分割する\ntemplate<typename T> vector<vector<T>> cutn(vector<T> &a, int len) {    int N = sz(a);    vector<vector<T>> res(ceil(N, len));    vi lens(N / len, len);    if (N % len)lens.push_back(N % len);    int l = 0;    rep(i, sz(lens)) {        int len = lens[i];        int r = l + len;        res[i].resize(len);        std::copy(a.begin() + l, a.begin() + r, res[i].begin());        l = r;    }    return res;}\nvi inds_(vi &a) {    int n = sz(a);    vb was(n);    vi res(n);    rep(i, n) {        assert(!was[a[i]]);        res[a[i]] = i;        was[a[i]] = true;    }    return res;}\n\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} initonv;\n#define pre prev\n#define nex next\n\n//gra mll pr\n//上下左右\nconst string udlr = \"udlr\";\nstring UDLR = \"UDLR\";//x4と連動 UDLR.find('U') := x4[0]\n//右、上が正\nconstexpr ll h4[] = {1, -1, 0, 0};\nconstexpr ll w4[] = {0, 0, -1, 1};\nconstexpr ll h8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconstexpr ll w8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n    int mei_inc(int h, int w, int H, int W, int i) {while (++i < 4) { if (inside(h + h4[i], w + w4[i], H, W))return i; }return i;}\n#define mei(nh, nw, h, w) for (int i = mei_inc(h, w, H, W, -1), nh = i<4? h + h4[i] : 0, nw = i<4? w + w4[i] : 0; i < 4; i=mei_inc(h,w,H,W,i), nh = h+h4[i], nw = w+w4[i])\n\n//グラフ内で #undef getid\n//#define getidとしているため、ここを書き直したらgraphも書き直す\n#define getid_2(h, w) (h * W + w)\n#define getid_1(p) (p.first * W + p.second)\n#define getid(...) over2(__VA_ARGS__, getid_2, getid_1) (__VA_ARGS__)\n#define getp(id) mp(id / W, id % W)\n//#define set_shuffle() std::random_device seed_gen;std::mt19937 engine(seed_gen())\n//#define shuffle(a) std::shuffle((a).begin(), (a).end(), engine);\n//1980 開始からtime ms経っていたらtrue\nbool timeup(int time) {\n    auto end_time = system_clock::now();\n    auto part = duration_cast<milliseconds>(end_time - start_time);\n    auto lim = milliseconds(time);\n    return part >= lim;\n}\nvoid set_time() { past_time = system_clock::now(); }\n//MS型(millisecqnds)で返る\n//set_timeをしてからの時間\nauto calc_time_milli() {    auto now = system_clock::now();    auto part = duration_cast<milliseconds>(now - past_time);    return part;}\nauto calc_time_micro() {    auto now = system_clock::now();    auto part = duration_cast<microseconds>(now - past_time);    return part;}\nauto calc_time_nano() {    auto now = system_clock::now();    auto part = duration_cast<nanoseconds>(now - past_time);    return part;}\nbool calc_time(int zikan) { return calc_time_micro() >= microseconds(zikan); }\nusing MS=std::chrono::microseconds;\nint div(microseconds a, microseconds b) { return a / b; }\nint div(nanoseconds a, nanoseconds b) {    if (b < nanoseconds(1)) { return a / nanoseconds(1); }    int v = a / b;    return v;}\n//set_time();\n//rep(i,lim)shori\n\n//lim*=time_nanbai();\n//rep(i,lim)shoriと使う\n//全体でmilliかかっていいときにlimを何倍してもう一回できるかを返す\nint time_nanbai(int milli) {\n    auto dec = duration_cast<nanoseconds>(past_time - start_time);\n    auto part = calc_time_nano();\n    auto can_time = nanoseconds(milli * 1000 * 1000);\n    can_time -= part;\n    can_time -= dec;\n    return div(can_time, part);\n}\n/*@formatter:on*/\n//vectorで取れる要素数\n//bool=> 1e9 * 8.32\n//int => 1e8 * 2.6\n//ll  => 1e8 * 1.3\n//3次元以上取るとメモリがヤバい\n//static配列を使う\n\nvvc (ba);\nll N, M, H, W;\nvi A, B, C;\n\n//19:08\nvoid solve() {\n    dins(S);\n    N = sz(S);\n    din(K);\n    //[l, r], 使った回数 =  最大長\n    vni(dp, N, N + 1, K + 10);\n    rep(i, N) {\n        dp[i][i][0] = 0;\n        dp[i][i + 1][0] = 1;\n    }\n    rep(len, 2, N + 10) {\n        rep(l, N) {\n            int r = l + len;\n            if (r > N)break;\n            rep(pk, K + 1) {\n                chma(dp[l][r][pk], dp[l + 1][r][pk]);\n                chma(dp[l][r][pk], dp[l][r - 1][pk]);\n                chma(dp[l][r][pk + (S[l] != S[r - 1])], dp[l + 1][r - 1][pk] + 2);\n            }\n        }\n    }\n    resize(dp, N, N+1, K + 1);\n    deb(dp);\n    out(max(dp));\n}\n\nauto my(ll n, vi &a) {\n    return 0;\n}\n\nauto sister(ll n, vi &a) {\n    ll ret = 0;\n    return ret;\n}\n\nsigned main() {\n    solve();\n\n#define arg n,a\n#ifdef _DEBUG\n    bool bad = 0;\n    for (ll i = 0, ok = 1; i < k5 && ok; ++i) {\n        ll n = rand(1, 8);\n        vi a = ranv(n, 1, 10);\n        auto myres = my(arg);\n        auto res = sister(arg);\n        ok = myres == res;\n        if (!ok) {\n            out(arg);\n            cerr << \"AC : \" << res << endl;\n            cerr << \"MY  : \" << myres << endl;\n            bad = 1;\n\n\n            break;\n        }\n    }\n    if (!bad) {\n//        cout << \"完璧 : solveを書き直そう\" << endl;\n//        cout << \"     : そして、solve()を呼び出すのだ\" << endl;\n//        cout << \"     : cin>>n; na(a,n);も忘れるな\" << endl;\n    }\n    if (sz(message)) {\n        cerr << \"****************************\" << endl;\n        cerr << message << endl;\n        cerr << \"****************************\" << endl;\n    }\n#endif\n    return 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 305\nusing namespace std;\nchar c[N];\nint i,j,k,l,s,n,m,ans,f[N][N][N];\nint main() {\n\tscanf(\"%s\",c+1);\n\tn=strlen(c+1);\n\tscanf(\"%d\",&m);\n\tm*=2;\n\tm=min(m,n);\n\tfor (i=1;i<=n;i++)\n\tfor (j=n;j;j--)\n\tfor (k=0;k<=m;k++) {\n\t\tif (c[i]==c[j]) f[i+1][j-1][k]=max(f[i+1][j-1][k],f[i][j][k]+1);\n\t\telse if (k<m) f[i+1][j-1][k+1]=max(f[i+1][j-1][k+1],f[i][j][k]+1);\n\t\tf[i+1][j][k]=max(f[i+1][j][k],f[i][j][k]);\n\t\tf[i][j-1][k]=max(f[i][j-1][k],f[i][j][k]);\n\t}\n\tfor (i=0;i<=m;i++) ans=max(ans,f[n+1][0][i]);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define test cout<<\"test\"<<endl;\n#define fi first\n#define se second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T>\nvoid chmin(T &a,T b){if(a>b)a=b;}\ntemplate<typename T>\nvoid chmax(T &a,T b){if(a<b)a=b;}\nvoid pmod(ll &a,ll b){a=(a+b)%MOD;}\nvoid pmod(ll &a,ll b,ll c){a=(b+c)%MOD;}\nvoid qmod(ll &a,ll b){a=(a*b)%MOD;}\nvoid qmod(ll &a,ll b,ll c){a=(b*c)%MOD;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,0,-1,0,1,1,-1,-1};\nvector<ll>dy={0,1,0,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\nostream &operator<<(ostream &os, pair<ll, ll>&p){\n  return os << p.first << \" \" << p.second;\n}  \nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  //cout<<fixed<<setprecision(10);\n  ll res=0,buf=0;\n  bool judge = true;\n  string s,t;cin>>s;\n  t=s;\n  reverse(ALL(t));\n  ll k;cin>>k;\n  ll n=s.size();\n  auto dp=make_v(n+1,n+1,k+1,0LL);\n  //cout<<n spa s spa t<<endl;\n  rep(i,0,n+1){\n    rep(j,0,n+1){\n      rep(o,0,k+1){\n        if(i>0&&j>0&&s[i-1]==t[j-1]){\n          chmax(dp[i][j][o],dp[i-1][j-1][o]+1);\n        }\n        if(i>0)chmax(dp[i][j][o],dp[i-1][j][o]);\n        if(j>0)chmax(dp[i][j][o],dp[i][j-1][o]);\n        if(o>0&&i>0&&j>0)chmax(dp[i][j][o],dp[i-1][j-1][o-1]+1);\n        chmax(res,dp[i][j][o]+min(o,n-i));\n      }\n    }\n    //cout<<i<<endl;\n    //debug(dp[i],n+1,k+1);\n  }\n  cout<<res<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 300;\n\nchar s[MX + 2];\nint dp[MX + 2][MX + 2][MX + 1];\n\nint main() {\n\tint k;\n\tignore = scanf(\"%s %d\", s + 1, &k);\n\t\n\tint n = strlen(s + 1);\n\tfor (int l = n; l > 0; l--)\n\t\tfor (int r = l; r <= n; r++)\n\t\t\tfor (int p = 0; p <= k; p++) {\n\t\t\t\tif (s[l] == s[r]) {\n\t\t\t\t\tdp[l][r][p] = dp[l + 1][r - 1][p] + (l == r ? 1 : 2);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[l][r][p] = max(dp[l + 1][r][p], dp[l][r - 1][p]);\n\t\t\t\t\tif (p > 0) dp[l][r][p] = max(dp[l][r][p], dp[l + 1][r - 1][p - 1] + (l == r ? 1 : 2));\n\t\t\t\t}\n\t\t\t}\n\t\n\tprintf(\"%d\\n\", dp[1][n][k]);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[301][301][301];\nint main() {\n  string S;\n  int K;\n  cin >> S >> K;\n  for(auto i = 0; i < S.size(); ++i) dp[i][i+1][0] = 1;\n  for(auto k = 0; k <= K; ++k) for(auto w = 2; w <= S.size(); ++w) for(auto l = 0; l+w <= S.size(); ++l) {\n    auto r = l + w;\n    dp[l][r][k] = max({dp[l][r][k], dp[l+1][r][k], dp[l][r-1][k]});\n    if(0 < k)        dp[l][r][k] = max({dp[l][r][k], dp[l][r][k-1], 2 + dp[l+1][r-1][k-1]});\n    if(S[l]==S[r-1]) dp[l][r][k] = max(dp[l][r][k], 2 + dp[l+1][r-1][k]);\n  }\n  cout << dp[0][S.size()][K] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\n#include <random>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> P;\n\n\nint dp[301][301][301];\nvoid solve(std::string S, long long K){\n\tfor(int w=1;w<=S.size();w++){\n\t\tfor(int i=0;i+w<=S.size();i++){\n\t\t\tfor(int k=0;k<=K;k++){\n\t\t\t\tdp[i][i+w][k]=max(dp[i][i+w-1][k],dp[i+1][i+w][k]);\n\t\t\t\tif(k>0){\n\t\t\t\t\tdp[i][i+w][k]=max(dp[i][i+w][k],dp[i][i+w][k-1]);\n\t\t\t\t}\n\t\t\t\tif(S[i]==S[i+w-1]){\n\t\t\t\t\tint d=(w==1?1:2);\n\t\t\t\t\tdp[i][i+w][k]=max(dp[i][i+w][k],dp[i+1][i+w-1][k]+d);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(k>0){\n\t\t\t\t\t\tdp[i][i+w][k]=max(dp[i][i+w][k],dp[i+1][i+w-1][k-1]+2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][S.size()][K] << endl;\n\n}\n\nint main(){\n    std::string S;\n    std::cin >> S;\n    long long K;\n    scanf(\"%lld\",&K);\n    solve(S, K);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string>\n#include <memory.h>\n#include <set>\n#include <map>\n#include <vector>\n#include <queue>\n#include <time.h>\n#include <assert.h>\n#include <cmath>\n#include <stack>\n#include <string.h>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N = 300;\nstring s;\nint n, k, dp[N][N][N + 1];\nint calc(int i, int j, int k) {\n\tif (k < 0)\n\t\treturn -1e9;\n\tif (i >= j)\n\t\treturn i==j;\n\tint &ret = dp[i][j][k];\n\tif (ret != -1)\n\t\treturn ret;\n\tret = max(calc(i + 1, j, k), calc(i, j - 1, k));\n\tif (s[i] == s[j])\n\t\tret = max(ret, calc(i + 1, j - 1, k) + 2);\n\tret = max(ret, calc(i + 1, j - 1, k - 1) + 2);\n\treturn ret;\n}\nint main()\n{\n\tcin >> s;\n\tn = s.size();\n\tcin >> k;\n\tmemset(dp, -1, sizeof(dp));\n\tcout << calc(0, n - 1, k) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring s;\nint memo[310][310][310];\n\nint dp(int l, int r, int k){\n    if(l > r){\n        return 0;\n    }\n\n    if(l == r){\n        return 1;\n    }\n\n    if(memo[l][r][k] != -1) return memo[l][r][k];\n\n    int ans = 0;\n    ans = max(ans, dp(l+1, r, k));\n    ans = max(ans, dp(l, r-1, k));\n\n    if(s[l] == s[r]){\n        ans = max(ans, dp(l+1, r-1, k)+2);\n    }else if(k > 0){\n        ans = max(ans, dp(l+1, r-1, k-1)+2);\n    }\n\n    return memo[l][r][k] = ans;\n}\n\nint main(){\n    cin >> s;\n    int k;\n    cin >> k;\n    memset(memo, -1, sizeof(memo));\n    cout << dp(0, s.size()-1, k) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#ifdef leowang\n#define debug(...) do{\\\n\tfprintf(stderr,\"%s - %d : (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);\\\n\t_DO(__VA_ARGS__);\\\n}while(0)\ntemplate<typename I> void _DO(I&&x){cerr<<x<<endl;}\ntemplate<typename I,typename...T> void _DO(I&&x,T&&...tail){cerr<<x<<\", \";_DO(tail...);}\n#else\n#define debug(...)\n#endif\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n}\n//}}}\nconst ll maxn=305;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=8000000000000000000LL;\nconst int INF=2000000000;\nconst ll MOD=ll(1e9+7);\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n/*\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) a=a*a%MOD;\n\t\telse res=res*a%MOD;\n\t\tb>>=1;\n\t}\n\tres=res*a%mod;\n\treturn res;\n}\n*/\nstring s,t;\nint dp[maxn][maxn][maxn*2];\n\nint f(int i,int j,int k){\n\tif(k<0) return -INF;\n\tif(i<=0||j<=0) return 0;\n\tif(dp[i][j][k]!=-1) return dp[i][j][k];\n\tif(s[i-1]==t[j-1]) return f(i-1,j-1,k)+1;\n\treturn dp[i][j][k]=max({f(i-1,j,k),f(i,j-1,k),f(i-1,j-1,k-1)+(SZ(s)%2==0||i!=SZ(s)/2||j!=SZ(s)/2)});\n}\n\nint main()\n{\n\tIOS;\n\tmemset(dp,-1,sizeof dp);\n\tint k;\n\tcin>>s>>k;\n\tt=s;\n\treverse(ALL(t));\n\tint ans=0;\n\tREP(i,SZ(s)){\n\t\tans=max(ans,f(i,SZ(s)-1-i,k)*2+1);\n\t}\n\tREP(i,SZ(s)-1){\n\t\tif(s[i]==s[i+1]) ans=max(ans,2*f(i+1,SZ(s)-i-1,k));\n\t\telse ans=max(ans,2*f(i,SZ(s)-i-2,k-1)+2);\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*** author: yuji9511 ***/\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing lpair = pair<ll, ll>;\nconst ll MOD = 1e9+7;\nconst ll INF = 1e18;\n#define rep(i,m,n) for(ll i=(m);i<(n);i++)\n#define rrep(i,m,n) for(ll i=(m);i>=(n);i--)\n#define printa(x,n) for(ll i=0;i<n;i++){cout<<(x[i])<<\" \\n\"[i==n-1];};\nvoid print() {}\ntemplate <class H,class... T>\nvoid print(H&& h, T&&... t){cout<<h<<\" \\n\"[sizeof...(t)==0];print(forward<T>(t)...);}\nll dp[310][310][310] = {};\nstring S;\n\nll calc(ll i, ll j, ll k){\n    ll &res = dp[i][j][k];\n    if(~res) return res;\n    if(j - i == 0){\n        return res = 0;\n    }else if(j - i == 1){\n        return res = 1;\n    }\n    res = 0;\n    if(S[i] == S[j-1]){\n        res = 2 + calc(i+1, j-1, k);\n    }else{\n        if(k > 0){\n            res = 2 + calc(i+1, j-1, k-1);\n        }\n    }\n    rep(l,i+1,j){\n        res = max(res, calc(i, l, k));\n    }\n    rep(l,i+1,j){\n        res = max(res, calc(l, j, k));\n    }\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> S;\n    ll K;\n    cin >> K;\n    memset(dp, -1, sizeof(dp));\n    ll N = S.size();\n    ll ans = calc(0,N,K);\n    print(ans);\n\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nchar s[320];\nint f[320][320][320]; // [i, j] 修改k个\nint m;\nint main() {\n\tscanf(\"%s\", s);\n\tscanf(\"%d\", &m);\n\tint n = strlen(s);\n\tfor (int l = 0; l < n; l++) {\n\t\tfor (int i = 0; i + l < n; i++) {\n\t\t\tint j = i + l;\n\t\t\tfor (int k = 0; k <= m; k++) {\n\t\t\t\tif (i < j) {\n\t\t\t\t\tf[i][j][k] = max(f[i][j - 1][k], f[i + 1][j][k]);\n\t\t\t\t}\n\t\t\t\tif (s[i] == s[j]) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tf[i][j][k] = max(f[i][j][k], 0 + 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tf[i][j][k] = max(f[i][j][k], f[i + 1][j - 1][k] + 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (k > 0 && i < j) {\n\t\t\t\t\tf[i][j][k] = max(f[i][j][k], f[i + 1][j - 1][k - 1] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", f[0][n - 1][m]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//実装が重そうな問題はある程度考えてから書く\n//初期化を忘れずに（特に二分探索とか）\n//コーナーケースを考えて（特に場合分けとか）\n//不可解すぎるバグは配列外参照（配列の長さ）を検討\n#include \"bits/stdc++.h\"\n#define YES \"YES\"\n#define Yes \"Yes\"\n#define NO \"NO\"\n#define No \"No\"\n#define YESNO(x) OUT(three(x,YES,NO))\n#define YesNo(x) OUT(three(x,Yes,No))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define rep REP\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b-1,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB emplace_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define int long long\n#define zero 0LL\n#define all ALL\n#define pb PB\nusing namespace std;\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l < r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l > r ? l = r, 1 : 0; }\ntypedef long long LL;\ntypedef LL ll;\ntypedef double ld;\ntypedef LL ut;\nconst LL INF = 1LL << 60;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<ppr, Vppr ,greater<ppr> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nint dx[] = { 0,1,0,-1,1,1,-1,-1,0 }, dy[] = { 1,0,-1,0,1,-1,1,-1,0 };\nconst int SIZE1 =2e6 + 1000;\nconst int SIZE2 = 2010;\nconst int SIZE3 = 301;\nconst int SIZE = SIZE1;\nconst LL p = 7 + 1e9;const long double EPS = 1e-7;\nut N, M, K, X, L, Y,H,W,Q,D;\n// ut A,B,C,D,E,F,G,H,I,J,O,P,Q,R,T,U;\nVI edges[SIZE];\nLL vals[SIZE], nums[SIZE], maps[SIZE2][SIZE2], answer = zero;\n//LL A[SIZE], B[SIZE],I[SIZE];\nLL A, B;\nstring s;\nstring revs;\nLL DP[SIZE3][SIZE3][SIZE3];\nbool checked[SIZE3][SIZE3][SIZE3];\nLL solve2(int a,int b,int k) {\n\tif (a > b) return 0;\n\tif (a == b) return 1;\n\tif (checked[a][b][k]) return DP[a][b][k];\n\tchecked[a][b][k] = true;\n\n\tif (s[a] == s[b]) {\n\t\treturn DP[a][b][k] = solve2(a + 1, b - 1, k) + 2;\n\t}\n\tMX(DP[a][b][k], solve2(a + 1, b, k));\n\tMX(DP[a][b][k], solve2(a, b -1, k));\n\tif (k)\n\t\tMX(DP[a][b][k], solve2(a + 1, b -1, k - 1)+2);\n\treturn DP[a][b][k];\n\t/*/\n\tif (max(a, b) >= s.size()) return 0;\n\tif (checked[a][b][k]) return DP[a][b][k];\n\tchecked[a][b][k]=true;\n\tif (s[a] == revs[b]) {\n\t\treturn DP[a][b][k] = solve2(a + 1, b + 1, k)+1;\n\t}\n\tMX(DP[a][b][k], solve2(a + 1, b, k));\n\tMX(DP[a][b][k], solve2(a , b+1, k));\n\tif(k)\n\t\tMX(DP[a][b][k], solve2(a + 1, b+1, k-1));\n\treturn DP[a][b][k];\n/*/\n}\nLL solve() {\n\tcin >> s;\n\trevs = s;\n\treverse(ALL(revs));\n\tcin >> K;\n\tcout << solve2(0, (LL)s.size()-1, K) << endl;\n\treturn 0;\n}\nsigned main() {\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(10);\n\tsolve();\n\t//\tcin >> N;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <chrono>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <random>\n#include <memory>\n#include <utility>\n#include <limits>\n#include \"limits.h\"\n \n#define rep(i, a, b) for (long long (i) = (a); i < (b); i++)\n#define all(i) i.begin(), i.end()\n#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n\nvoid debug_out(){std::cerr<<std::endl;}\n\ntemplate<typename Head,typename... Tail>\nvoid debug_out(Head h,Tail... t){\n  std::cerr<<\" \"<<h;\n  debug_out(t...);\n}\n \ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, std::pair<T1, T2> pa) {\n  return os << pa.first << \" \" << pa.second;\n}\n \ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> vec) {\n  for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n  return os;\n}\n \ntemplate<typename T1,typename T2>\ninline bool chmax(T1& a,T2 b){return a<b && (a=b,true);}\n \ntemplate<typename T1,typename T2>\ninline bool chmin(T1& a,T2 b){return a>b && (a=b,true);}\n \nlong long pow_mod(long long a, long long b, long long mod=-1) {\n  if(b==0)return 1;\n  if ((a == 0)||(mod!=-1&&(a+mod)%mod==0)) {\n    return 0;\n  }\n  long long x = 1;\n  while (b > 0) {\n    if (b & 1) {\n      x = (mod!=-1)?(x * a) % mod:x*a;\n    }\n    a = (mod!=-1)?(a * a) % mod:a*a;\n    b >>= 1;\n  }\n  return x;\n}\n \n// const long long MOD = 998244353;\nconst long long MOD = 1e9 + 7;\n\nusing ll = long long;\nusing P=std::pair<long long,long long>;\n\nll dp[310][310][310]={0};\n\nint main() {\n  std::cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  std::string s;\n  std::cin>>s;\n\n  ll k;\n  std::cin>>k;\n\n  ll n=s.size();\n\n  rep(i,0,n)rep(j,0,k+1)dp[i][i][j]=0;\n  rep(i,0,n)rep(j,0,k+1)dp[i][i+1][j]=1;\n\n  rep(len,2,n+1){\n    rep(i,0,n-len+1){\n      if(s[i]==s[i+len-1]){\n        rep(j,0,k+1){\n          dp[i][i+len][j]=dp[i+1][i+len-1][j]+2;\n        }\n      }else{\n        rep(j,0,k+1){\n          chmax(dp[i][i+len][j],dp[i+1][i+len][j]);\n          chmax(dp[i][i+len][j],dp[i][i+len-1][j]);\n          if(j==0){\n            chmax(dp[i][i+len][j],dp[i+1][i+len-1][j]);      \n          }else{\n            chmax(dp[i][i+len][j],dp[i+1][i+len-1][j]);      \n            chmax(dp[i][i+len][j],dp[i+1][i+len-1][j-1]+2);\n          }\n        }\n      }\n    }\n  }\n\n  std::cout<<dp[0][n][k]<<\"\\n\";\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\nusing ll = long long;\n#define fst first\n#define snd second\n\n/* clang-format off */\ntemplate <class T, size_t D> struct _vec { using type = vector<typename _vec<T, D - 1>::type>; };\ntemplate <class T> struct _vec<T, 0> { using type = T; };\ntemplate <class T, size_t D> using vec = typename _vec<T, D>::type;\ntemplate <class T> vector<T> make_v(size_t size, const T& init) { return vector<T>(size, init); }\ntemplate <class... Ts> auto make_v(size_t size, Ts... rest) { return vector<decltype(make_v(rest...))>(size, make_v(rest...)); }\ntemplate <class T> inline void chmin(T &a, const T& b) { if (b < a) a = b; }\ntemplate <class T> inline void chmax(T &a, const T& b) { if (b > a) a = b; }\n/* clang-format on */\n\nstring S;\n\nint dp[310][310][310];\n\nint solve(int a, int b, int r) {\n  if (a > b) return 0;\n  int& res = dp[a][b][r];\n  if (res != -1) return res;\n  if (a == b) return (S[a] == S[b] || r > 0) ? 1 : 0;\n  res = 0;\n  chmax(res, solve(a + 1, b, r));\n  chmax(res, solve(a, b - 1, r));\n  if (S[a] == S[b]) {\n    chmax(res, solve(a + 1, b - 1, r) + 2);\n  } else if (r > 0) {\n    chmax(res, solve(a + 1, b - 1, r - 1) + 2);\n  }\n  return res;\n}\n\nint main() {\n#ifdef DEBUG\n  ifstream ifs(\"in.txt\");\n  cin.rdbuf(ifs.rdbuf());\n#endif\n  int K;\n  while (cin >> S >> K) {\n    memset(dp, -1, sizeof(dp));\n    cout << solve(0, S.size() - 1, K) << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nconst int maxn = 305;\nint d[maxn][maxn][maxn];\n\nvoid uax(int& a, int b) {\n  a = max(a, b);\n}\n\nsigned main() {\n#ifdef LOCAL\n  assert(freopen(\"d.in\", \"r\", stdin));\n#endif\n  string s;\n  int k;\n  cin >> s >> k;\n  int n = (int) s.size();\n  string a = s;\n  string b = s;\n  reverse(b.begin(), b.end());\n  for (int i = 0; i <= (int) a.size(); ++i) {\n    for (int j = 0; j <= (int) b.size(); ++j) {\n      for (int q = 0; q <= k; ++q) {\n        uax(d[i + 1][j][q], d[i][j][q]);\n        uax(d[i][j + 1][q], d[i][j][q]);\n        if (i < (int) a.size() && j < (int) b.size()) {\n          uax(d[i + 1][j + 1][q + (a[i] != b[j])], d[i][j][q] + 1);\n        }\n      }\n    }\n  }\n  int res = 0;\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j <= k; ++j) {\n      uax(res, 2 * d[i][n - i - 1][j] + 1);\n    }\n  }\n  cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for((i)=1;(i)<=(n);(i)++)\nusing namespace std;\nstring st;\nint dp[305][305][305],n,m,i,j,k;\nint main(){\n\tcin>>st>>m;n=st.length();st=\" \"+st;\n\trep(i,n) dp[i][i][0]=1;\n\trep(i,n-1) if(st[i]==st[i+1]) dp[i][i+1][0]=2; else dp[i][i+1][1]=2;\n\tfor(i=n;i>=1;i--){\n\t\tfor(j=i+1;j<=n;j++){\n\t\t\tfor(k=0;k<=m;k++){\n\t\t\t\tdp[i][j][k]=max(dp[i][j][k],max(dp[i+1][j][k],dp[i][j-1][k]));\n\t\t\t\tif(i+1<=j-1&&st[i]==st[j]) dp[i][j][k]=max(dp[i][j][k],dp[i+1][j-1][k]+2);\n\t\t\t\tif(i+1<=j-1&&k) dp[i][j][k]=max(dp[i][j][k],dp[i+1][j-1][k-1]+2);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(k=0;k<=m;k++) ans=max(ans,dp[1][n][k]);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <memory>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#define rep(i, n) for(int i=0;i<(int)(n);i++)\n#define REP(i, n) for(int i=1;i<=(int)(n);i++)\n#define all(V) V.begin(),V.end()\ntypedef long long lint;\ntypedef std::pair<lint, lint> P;\nconstexpr int INF = INT_MAX / 10;\nconstexpr lint LINF = LLONG_MAX / 2;\nconstexpr double eps = 1e-9;\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\n\ntemplate<class T, class Alloc = std::allocator<T>>\nclass Vector {\n\n\tusing traits = std::allocator_traits<Alloc>;\n\npublic:\n\n\tusing value_type = T;\n\tusing allocator_type = Alloc;\n\tusing size_type = unsigned int;\n\tusing difference_type = int;\n\tusing reference = T&;\n\tusing const_reference = const T&;\n\tusing pointer = typename traits::pointer;\n\tusing const_pointer = typename traits::const_pointer;\n\n\tclass iterator {\n\n\tpublic:\n\n\t\tusing difference_type = int;\n\t\tusing value_type = Vector::value_type;\n\t\tusing pointer = Vector::pointer;\n\t\tusing reference = Vector::reference;\n\t\tusing iterator_category = std::random_access_iterator_tag;\n\n\tprivate:\n\n\t\tpointer p;\n\n\tpublic:\n\n\t\titerator()noexcept :p() {}\n\t\titerator(const Vector& base, difference_type index) noexcept :p(base.e + index) {}\n\t\titerator(const iterator& i) :p(i.p) {}\n\n\t\titerator& operator=(const iterator& i) = default;\n\t\titerator& operator=(iterator&& i)noexcept = default;\n\n\t\titerator& operator++() {\n\t\t\tp++;\n\t\t\treturn *this;\n\t\t}\n\n\t\titerator operator++(int) {\n\t\t\titerator res = *this;\n\t\t\tp++;\n\t\t\treturn res;\n\t\t}\n\n\t\titerator operator+(const difference_type& x)const {\n\t\t\titerator res = *this;\n\t\t\treturn res += x;\n\t\t}\n\n\t\titerator& operator+=(const difference_type& x) {\n\t\t\tp += x;\n\t\t\treturn *this;\n\t\t}\n\n\t\titerator& operator--() {\n\t\t\tp--;\n\t\t\treturn *this;\n\t\t}\n\n\t\titerator operator--(int) {\n\t\t\titerator res = *this;\n\t\t\tp--;\n\t\t\treturn res;\n\t\t}\n\n\t\titerator operator-(const difference_type x)const {\n\t\t\titerator res = *this;\n\t\t\treturn res -= x;\n\t\t}\n\n\t\tdifference_type operator-(const iterator& i)const {\n\t\t\treturn p - i.p;\n\t\t}\n\n\t\titerator& operator-=(const difference_type x) {\n\t\t\tp -= x;\n\t\t\treturn *this;\n\t\t}\n\n\t\treference operator*()const {\n\t\t\treturn *p;\n\t\t}\n\n\t\treference operator[](const difference_type x)const {\n\t\t\treturn *(p + x);\n\t\t}\n\n\t\tbool operator<(const iterator& i)const {\n\t\t\treturn p < i.p;\n\t\t}\n\n\t\tbool operator<=(const iterator& i)const {\n\t\t\treturn p <= i.p;\n\t\t}\n\n\t\tbool operator==(const iterator& i)const {\n\t\t\treturn p == i.p;\n\t\t}\n\n\t\tbool operator>(const iterator& i)const {\n\t\t\treturn p > i.p;\n\t\t}\n\n\t\tbool operator>=(const iterator& i)const {\n\t\t\treturn p >= i.p;\n\t\t}\n\n\t\tbool operator!=(const iterator& i)const {\n\t\t\treturn p != i.p;\n\t\t}\n\n\t};\n\n\tclass const_iterator {\n\n\tpublic:\n\n\t\tusing difference_type = int;\n\t\tusing value_type = Vector::value_type;\n\t\tusing pointer = const Vector::pointer;\n\t\tusing reference = const Vector::reference;\n\t\tusing iterator_category = std::random_access_iterator_tag;\n\n\tprivate:\n\n\t\tpointer p;\n\n\tpublic:\n\n\t\tconst_iterator()noexcept :p() {}\n\t\tconst_iterator(const Vector& base, difference_type index) noexcept :p(base.e + index) {}\n\t\tconst_iterator(const const_iterator& i) :p(i.p) {}\n\n\t\tconst_iterator& operator=(const const_iterator& i)noexcept = default;\n\t\tconst_iterator& operator=(const_iterator&& i)noexcept = default;\n\n\t\tconst_iterator& operator++() {\n\t\t\tp++;\n\t\t\treturn *this;\n\t\t}\n\n\t\tconst_iterator operator++(int) {\n\t\t\tconst_iterator res = *this;\n\t\t\tp++;\n\t\t\treturn res;\n\t\t}\n\n\t\tconst_iterator operator+(const difference_type x)const {\n\t\t\tconst_iterator res = *this;\n\t\t\treturn res += x;\n\t\t}\n\n\t\tconst_iterator& operator+=(const difference_type x) {\n\t\t\tp += x;\n\t\t\treturn *this;\n\t\t}\n\n\t\tconst_iterator& operator--() {\n\t\t\tp--;\n\t\t\treturn *this;\n\t\t}\n\n\t\tconst_iterator operator--(int) {\n\t\t\tconst_iterator res = *this;\n\t\t\tp--;\n\t\t\treturn res;\n\t\t}\n\n\t\tconst_iterator operator-(const difference_type x)const {\n\t\t\tconst_iterator res = *this;\n\t\t\treturn res -= x;\n\t\t}\n\n\t\tdifference_type operator-(const const_iterator& i)const {\n\t\t\treturn p - i.p;\n\t\t}\n\n\t\tconst_iterator& operator-=(const difference_type x) {\n\t\t\tp -= x;\n\t\t\treturn *this;\n\t\t}\n\n\t\treference operator*()const {\n\t\t\treturn *p;\n\t\t}\n\n\t\treference operator[](const difference_type x)const {\n\t\t\treturn *(p + x);\n\t\t}\n\n\t\tbool operator<(const const_iterator& i)const {\n\t\t\treturn p < i.p;\n\t\t}\n\n\t\tbool operator<=(const const_iterator& i)const {\n\t\t\treturn p <= i.p;\n\t\t}\n\n\t\tbool operator==(const const_iterator& i)const {\n\t\t\treturn p == i.p;\n\t\t}\n\n\t\tbool operator>(const const_iterator& i)const {\n\t\t\treturn p > i.p;\n\t\t}\n\n\t\tbool operator>=(const const_iterator& i)const {\n\t\t\treturn p >= i.p;\n\t\t}\n\n\t\tbool operator!=(const const_iterator& i)const {\n\t\t\treturn p != i.p;\n\t\t}\n\n\t};\n\n\tusing reverse_iterator = std::reverse_iterator<iterator>;\n\tusing const_reverse_iterator = std::reverse_iterator<const_iterator>;\n\nprivate:\n\n\tpointer e;\n\tsize_type length = 0, cap = 1;\n\tAlloc alloc;\n\n\tstatic_assert(std::is_same<T, typename Alloc::value_type>::value, \"The allocator value type is not matched the Vector value type.\");\n\tstatic_assert(!std::is_const<T>::value, \"This library forbids containers of const elements\");\n\npublic:\n\n\tVector() :Vector(Alloc()) {}\n\n\texplicit Vector(const Alloc& a)noexcept :alloc(a) {\n\t\te = alloc.allocate(cap);\n\t}\n\n\texplicit Vector(size_type n, const Alloc& a = Alloc()) :alloc(a) {\n\t\twhile (cap < n)cap *= 2;\n\t\te = alloc.allocate(cap);\n\t\trep(i, n)emplace_back();\n\t}\n\n\texplicit Vector(size_type n, const_reference value, const Alloc& a = Alloc()) :alloc(a) {\n\t\twhile (cap < n)cap *= 2;\n\t\te = alloc.allocate(cap);\n\t\trep(i, n)emplace_back(value);\n\t}\n\n\ttemplate<class InputIter>\n\tVector(InputIter first, InputIter last, const Alloc& a = Alloc()) :alloc(a) {\n\t\te = alloc.allocate(cap);\n\t\tfor (InputIter i = first; i != last; i++) {\n\t\t\templace_back(*i);\n\t\t}\n\t}\n\n\tVector(const Vector& x, const Alloc& a = Alloc()) :alloc(a) {\n\t\twhile (cap < x.length)cap *= 2;\n\t\tlength = x.length;\n\t\te = alloc.allocate(cap);\n\t\trep(i, x.length)traits::construct(alloc, e + i, *(x.e + i));\n\t}\n\n\tVector(Vector&& x, const Alloc& a = Alloc()) :alloc(a) {\n\t\tcap = x.cap;\n\t\tlength = x.length;\n\t\te = x.e;\n\t\tx.e = nullptr;\n\t}\n\n\t~Vector() {\n\t\tif (e != nullptr) {\n\t\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\t\talloc.deallocate(e, cap);\n\t\t}\n\t}\n\n\tVector& operator=(const Vector& x) {\n\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\talloc.deallocate(e, cap);\n\t\tlength = x.length;\n\t\tcap = 1;\n\t\twhile (cap < length)cap *= 2;\n\t\te = alloc.allocate(cap);\n\t\trep(i, length)traits::construct(alloc, e + i, *(x.e + i));\n\t\treturn *this;\n\t}\n\n\tVector& operator=(Vector&& x) {\n\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\talloc.deallocate(e, cap);\n\t\tcap = x.cap;\n\t\tlength = x.length;\n\t\te = x.e;\n\t\tx.e = nullptr;\n\t\treturn *this;\n\t}\n\nprivate:\n\n\tvoid extension() {\n\t\tpointer e_ = alloc.allocate(cap * 2);\n\t\trep(i, length)traits::construct(alloc, e_ + i, *(e + i));\n\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\talloc.deallocate(e, cap);\n\t\te = e_;\n\t\tcap *= 2;\n\t}\n\n\tvoid extension(size_type n) {\n\t\tunsigned int r = 1;\n\t\twhile (cap * r < n)r *= 2;\n\t\tif (r == 1)return;\n\t\tpointer e_ = alloc.allocate(cap * r);\n\t\trep(i, length)traits::construct(alloc, e_ + i, *(e + i));\n\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\talloc.deallocate(e, cap);\n\t\te = e_;\n\t\tcap *= r;\n\t}\n\npublic:\n\n\ttemplate<class InputIter>\n\tvoid assign(InputIter first, InputIter last) {\n\t\tsize_type cnt = 0;\n\t\tfor (InputIter i = first; i != last; i++) {\n\t\t\tif (cnt == cap) {\n\t\t\t\tlength = std::max(length, cnt);\n\t\t\t\textension();\n\t\t\t}\n\t\t\ttraits::construct(alloc, e + cnt, *i);\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tvoid assign(size_type n, const_reference value) {\n\t\textension(n);\n\t\tstd::fill(e, e + n, value);\n\t}\n\n\ttemplate<class... Args>\n\tvoid emplace_back(Args&&... args) {\n\t\tif (length == cap)extension();\n\t\ttraits::construct(alloc, e + length, std::forward<Args>(args)...);\n\t\tlength++;\n\t}\n\n\tvoid push_back(const_reference value) {\n\t\templace_back(value);\n\t}\n\n\tvoid push_back(T&& value) {\n\t\templace_back(std::move(value));\n\t}\n\n\tvoid pop_back() {\n\t\ttraits::destroy(alloc, e + length);\n\t\tlength--;\n\t}\n\n\tvoid reserve(size_type n) {\n\t\textension(n);\n\t}\n\n\titerator erase(iterator pos) {\n\t\tconst iterator res = pos;\n\t\titerator t = pos; t++;\n\t\tfor (iterator i = pos; t != end(); i++, t++) {\n\t\t\t*i = std::move(*t);\n\t\t}\n\t\tpop_back();\n\t\treturn res;\n\t}\n\n\titerator erase(iterator first, iterator last) {\n\t\tconst iterator res = first;\n\t\ttypename iterator::difference_type d = last - first;\n\t\tfor (iterator i = first; i + d != end(); i++) {\n\t\t\t*i = std::move(*(i + d));\n\t\t}\n\t\trep(i, d)pop_back();\n\t\treturn res;\n\t}\n\n\tvoid swap(Vector& x) {\n\t\tstd::swap(length, x.length);\n\t\tstd::swap(cap, x.cap);\n\t\tstd::swap(e, x.e);\n\t}\n\n\tvoid clear() {\n\t\twhile (length)pop_back();\n\t}\n\n\tsize_type size()const {\n\t\treturn length;\n\t}\n\n\tvoid resize(size_type  n, const_reference value = T()) {\n\t\textension(n);\n\t\twhile (n < length)pop_back();\n\t\tlength = n;\n\t\tstd::fill(e, e + n, value);\n\t}\n\n\tsize_type capacity()const {\n\t\treturn cap;\n\t}\n\n\tbool empty()const {\n\t\treturn !length;\n\t}\n\n\treference operator[](const size_type pos)const {\n\t\treturn e[pos];\n\t}\n\n\tpointer data() {\n\t\treturn e;\n\t}\n\n\treference front() {\n\t\treturn *e;\n\t}\n\n\treference back() {\n\t\treturn *(e + length - 1);\n\t}\n\n\titerator begin() noexcept {\n\t\treturn iterator(*this, 0);\n\t}\n\n\tconst_iterator begin()const noexcept {\n\t\treturn const_iterator(*this, 0);\n\t}\n\n\tconst_iterator cbegin()const noexcept {\n\t\treturn const_iterator(*this, 0);\n\t}\n\n\titerator rbegin()noexcept {\n\t\treturn reverse_iterator(*this, 0);\n\t}\n\n\tconst_iterator rbegin()const noexcept {\n\t\treturn const_reverse_iterator(*this, 0);\n\t}\n\n\tconst_iterator crbegin()const noexcept {\n\t\treturn const_reverse_iterator(*this, 0);\n\t}\n\n\titerator end() noexcept {\n\t\treturn iterator(*this, length);\n\t}\n\n\tconst_iterator end()const noexcept {\n\t\treturn const_iterator(*this, length);\n\t}\n\n\tconst_iterator cend()const noexcept {\n\t\treturn const_iterator(*this, length);\n\t}\n\n\titerator rend()noexcept {\n\t\treturn reverse_iterator(*this, length);\n\t}\n\n\tconst_iterator rend()const noexcept {\n\t\treturn const_reverse_iterator(*this, length);\n\t}\n\n\tconst_iterator crend()const noexcept {\n\t\treturn const_reverse_iterator(*this, length);\n\t}\n\n};\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ninline lint gcd(lint a, lint b) {\n\twhile (b) {\n\t\tlint c = a;\n\t\ta = b; b = c % b;\n\t}\n\treturn a;\n}\ninline lint lcm(lint a, lint b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(lint n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\nlint mypow(lint a, lint b) {\n\tif (!b)return 1;\n\tif (b & 1)return mypow(a, b - 1) * a;\n\tlint memo = mypow(a, b >> 1);\n\treturn memo * memo;\n}\nlint modpow(lint a, lint b, lint m) {\n\tif (!b)return 1;\n\tif (b & 1)return modpow(a, b - 1, m) * a % m;\n\tlint memo = modpow(a, b >> 1, m);\n\treturn memo * memo % m;\n}\ntemplate<typename T>\nvoid printArray(std::vector<T>& vec) {\n\trep(i, vec.size() - 1)std::cout << vec[i] << \" \";\n\tstd::cout << vec.back() << std::endl;\n}\ntemplate<typename T>\nvoid printArray(Vector<T>& vec) {\n\trep(i, vec.size() - 1)std::cout << vec[i] << \" \";\n\tstd::cout << vec.back() << std::endl;\n}\ntemplate<typename T>\nvoid printArray(T l, T r) {\n\tT rprev = r;\n\trprev--;\n\tfor (T i = l; i != rprev; i++) {\n\t\tstd::cout << *i << \" \";\n\t}\n\tstd::cout << *rprev << std::endl;\n}\nstd::string to_string(Vector<int>& vec) {\n\tstd::string res = \"[\";\n\trep(i, vec.size() - 1)res += std::to_string(vec[i]) + \", \";\n\tres += std::to_string(vec.back()) + \"]\";\n\treturn res;\n}\ntemplate<unsigned int modulo = 1000000007>\nclass ModInt {\n\tlint value;\npublic:\n\tModInt() : value(0) {}\n\ttemplate<typename T>\n\tModInt(T value = 0) : value(value) {\n\t\tif (value < 0)value = -(lint)(-value % modulo) + modulo;\n\t\tthis->value = value % modulo;\n\t}\n\tinline operator int()const { return value; }\n\tinline ModInt& operator+=(const ModInt& x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline ModInt operator-()const {\n\t\treturn ModInt(0) -= *this;\n\t}\n\tinline ModInt& operator-=(const ModInt& x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator*=(const ModInt& x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator/=(ModInt rhs) {\n\t\tint exp = modulo - 2;\n\t\twhile (exp) {\n\t\t\tif (exp & 1)*this *= rhs;\n\t\t\trhs *= rhs;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn *this;\n\t}\n\ttemplate<typename T> ModInt operator+(const T& rhs)const { return ModInt(*this) += rhs; }\n\ttemplate<typename T> ModInt& operator+=(const T& rhs) { return operator+=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator-(const T& rhs)const { return ModInt(*this) -= rhs; }\n\ttemplate<typename T> ModInt& operator-=(const T& rhs) { return operator-=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator*(const T& rhs)const { return ModInt(*this) *= rhs; }\n\ttemplate<typename T> ModInt& operator*=(const T& rhs) { return operator*=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator/(const T& rhs)const { return ModInt(*this) /= rhs; }\n\ttemplate<typename T> ModInt& operator/=(const T& rhs) { return operator/=(ModInt(rhs)); }\n};\ntemplate<unsigned int T>\nstd::istream& operator>>(std::istream& ist, ModInt<T>& x) {\n\tlint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\nstd::string s;\nint k;\nint dp[310][310][310];\nint main() {\n\tstd::cin >> s >> k;\n\trep(i, s.size())dp[i][i + 1][0] = 1;\n\trep(l, k + 1) {\n\t\tREP(i, s.size()) {\n\t\t\trep(j, s.size() - i + 1) {\n\t\t\t\tif (j)chmax(dp[j - 1][j + i][l], dp[j][j + i][l]);\n\t\t\t\tif (j + i != s.size())chmax(dp[j][j + i + 1][l], dp[j][j + i][l]);\n\t\t\t\tif (j && j + i != s.size()) {\n\t\t\t\t\tif (s[j - 1] == s[j + i]) {\n\t\t\t\t\t\tchmax(dp[j - 1][j + i + 1][l], dp[j][j + i][l] + 2);\n\t\t\t\t\t}\n\t\t\t\t\telse chmax(dp[j - 1][j + i + 1][l + 1], dp[j][j + i][l] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i, k + 1)chmax(ans, dp[0][s.size()][i]);\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nint DP[301*301*301];\nvoid Calc(){\n\tstring S = res();\n\tint K = rei();\n\tint N = S.length();\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=N-1;j>i;j--){\n\t\t\tfor(int k=0;k<=K;k++){\n\t\t\t\tDP[(i+1)*301*301+j*301+k] = max(DP[i*301*301+j*301+k],DP[(i+1)*301*301+(j+1)*301+k]);\n\t\t\t\tif(S[i] == S[j]){\n\t\t\t\t\tDP[(i+1)*301*301+j*301+k] = max(DP[(i+1)*301*301+j*301+k],DP[i*301*301+(j+1)*301+k]+1);\n\t\t\t\t}\n\t\t\t\telse if(k != 0){\n\t\t\t\t\tDP[(i+1)*301*301+j*301+k] = max(DP[(i+1)*301*301+j*301+k],DP[i*301*301+(j+1)*301+k-1]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 1;\n\tfor(int k=0;k<=K;k++){\n\t\tfor(int i=0;i<N-1;i++){\n\t\t\tans = max(DP[(i+1)*301*301+(i+1)*301+k]*2,ans);\n\t\t}\n\t\tfor(int i=0;i<N-2;i++){\n\t\t\tans = max(DP[(i+1)*301*301+(i+2)*301+k]*2+1,ans);\n\t\t}\n\t}\n\tcout << ans << endl;\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <iostream>\n#include <functional>\n#include <algorithm>\n#include <sstream>\n#include <iterator>\n#include <cmath>\n#include <limits>\n#include <tuple>\n#include <queue>\n#include <stack>\n\nusing namespace std;\ntypedef long long ll;\n\nint main()\n{\n\tstring S;\n\tcin >> S;\n\tint K;\n\tcin >> K;\n\tint N = (int)S.size();\n\tvector<vector<vector<int>>> dp(N + 2, vector<vector<int>>(N + 2, vector<int>(K + 1)));\n\tfor (int l = N; l > 0; l--) {\n\t\tfor (int r = l; r <= N; r++) {\n\t\t\tfor (int k = 0; k <= K; k++) {\n\t\t\t\tif (S[l - 1] == S[r - 1]) {\n\t\t\t\t\tdp[l][r][k] = dp[l + 1][r - 1][k] + (l == r ? 1 : 2);\n\t\t\t\t} else {\n\t\t\t\t\tdp[l][r][k] = max(dp[l + 1][r][k], dp[l][r - 1][k]);\n\t\t\t\t\tif (k > 0) \n\t\t\t\t\t\tdp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k - 1] + (l == r ? 1 : 2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = dp[1][N][K];\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <set>\n\n#define lowbit(x) (x&(-x))\n#define MAX(a,b) (a<b?b:a)\n#define MIN(a,b) (a<b?a:b)\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int N = 1e7;\nconst int maxn = 3e2 + 5;\nll mod = 1e9 + 7;\n\nchar s[maxn];\nint k;\n\nint f[maxn][maxn][maxn];\n\nint main()\n{\n\tscanf(\"%s%d\", s, &k);\n\tint n = strlen(s);\n\tif (n == 1)\n\t{\n\t\tprintf(\"1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; i++) f[i][i][0] = 1;\n\n\tfor(int len = 2;len<=n;++len)\n\t{\n\t\tfor(int l = 0;l<n;l++)\n\t\t{\n\t\t\tint r = l + len - 1;\n\t\t\tif (r >= n) break;\n\t\t\tfor (int x = 0; x <= k; x++)\n\t\t\t{\n\t\t\t\tf[l][r][x] = MAX(f[l + 1][r][x], f[l][r - 1][x]);\n\t\t\t\tif (s[l] == s[r]) f[l][r][x] = MAX(f[l][r][x], f[l + 1][r - 1][x] + 2);\n\t\t\t\tif (x)\n\t\t\t\t{\n\t\t\t\t\tf[l][r][x] = MAX(f[l][r][x], f[l][r][x - 1]);\n\t\t\t\t\tf[l][r][x] = MAX(f[l][r][x], f[l + 1][r - 1][x - 1] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%d\", f[0][n - 1][k]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing i64 = long long;\n\nint dp[300][301][301];\n\nint main() {\n    std::string s;\n    int k;\n    std::cin >> s >> k;\n\n    for (int l = 0; l < s.size(); l++) for (int i = 0; i <= k; i++) {\n        dp[l][l + 1][i] = 1;\n    }\n    for (int w = 2; w <= s.size(); w++) {\n        for (int i = 0; i + w <= s.size(); i++) {\n            int j = i + w - 1;\n            for (int c = 0; c <= k; c++) dp[i][j + 1][c] = std::max(dp[i][j][c], dp[i + 1][j + 1][c]);\n            if (s[i] == s[j]) for (int c = 0; c <= k; c++) dp[i][j + 1][c] = std::max(dp[i][j + 1][c], dp[i + 1][j][c] + 2);\n            else for (int c = 0; c < k; c++) dp[i][j + 1][c + 1] = std::max(dp[i][j + 1][c + 1], dp[i + 1][j][c] + 2);\n        }\n    }\n\n    int ret = 0;\n    for (auto &v : dp) for (auto &w : v) for (auto e : w) ret = std::max(e, ret);\n    std::cout << ret << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sqr(x) ((x) * (x))\n#define pb push_back\n#define mp make_pair\n#define X first\n#define Y second\n#define fin(name) FILE* aasckmasl=freopen(name, \"r\", stdin)\n#define fout(name) freopen(name, \"w\", stdout)\n#define I(x, a) for(auto x : a)\n#define F(i, l, r) for(auto i = l; i < r; ++i)\n#define E(i, l, r) for(auto i = l; i <= r; ++i)\n#define DF(i, l, r) for(auto i = l; i >= r; --i)\n#define clean(a) memset((a),0,sizeof (a))\n#define sync ios_base::sync_with_stdio(0);cin.tie(0)\n#define all(x) (x).begin(),(x).end()\n#define ret return\n#define cont continue\n#define brk break\n#define ins insert\n#define sz(a) ((int)(a).size())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double dbl;\ntypedef pair <int, int> pii;\n\nconst int inf = (int)1e9;\nconst ll linf = (ll)1e18;\nconst int mod = (int)1e9 + 7;\nconst dbl eps = (dbl)1e-8;\nconst int maxn = (int)1e5 + 5;\nconst dbl pi = acos(-1);\n\nint n, k, ans;\nstring s;\nint d[303][303][303];\n\nint main() {\n//    fin(\"t.in\");\n    sync;\n    cin >> s;\n    n = sz(s);\n    cin >> k;\n    clean(d);\n    ans = 0;\n    F(i, 0, n) {\n    \tF(j, 0, n) {\n    \t\tif (i + j > n)\n    \t\t\tbreak;\n\t\t\tint x = i, y = n - 1 - j;\n\t\t\tif (x >= y)\n\t\t\t\tbreak;\n    \t\tE(q, 0, k) {\n   \t\t\t\tans = max(ans, 2 * d[i][j][q] + (i + j < n));\n   \t\t\t\tif (s[x] == s[y]) {\n   \t\t\t\t\td[i + 1][j + 1][q] = max(d[i + 1][j + 1][q], d[i][j][q] + 1);\n   \t\t\t\t}\n\t\t\t\td[i + 1][j + 1][q + 1] = max(d[i + 1][j + 1][q + 1], d[i][j][q] + 1);\n   \t\t\t\td[i + 1][j][q] = max(d[i + 1][j][q], d[i][j][q]);\n   \t\t\t\td[i][j + 1][q] = max(d[i][j + 1][q], d[i][j][q]);\n    \t\t}\n    \t}\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,l,r) for(int i=int(l);i<int(r);i++)\n#define put(x) cout<<#x<<\" = \"<<x<<endl;\n#define X first\n#define Y second\n#define pb push_back\n#define pp pop_back\nusing namespace std;\ntypedef long long num;\ntypedef pair<int,int> point;\nconst int maxn=305;\n\nint n,k,dp[maxn][maxn][maxn];\nchar s[maxn];\nint32_t main(){\n    scanf(\"%s%d\",s,&k);\n    n=strlen(s);\n    rep(i,0,n){\n\trep(l,0,k+1){\n\t    dp[i][i][l]=1;\n\t    if(i<n-1){\n\t\tdp[i][i+1][l]=(l>0 || s[i]==s[i+1])?2:1;\n\t    }\n\t}\n    }\n    rep(size,2,n){\n\trep(i,0,n-size){\n\t    int j=i+size;\n\t    rep(l,0,k+1){\n\t\tif(s[i]==s[j]){\n\t\t    dp[i][j][l]=dp[i+1][j-1][l]+2;\n\t\t}else{\n\t\t    if(l>0) dp[i][j][l]=dp[i+1][j-1][l-1]+2;\n\t\t    dp[i][j][l]=max({dp[i][j][l],dp[i+1][j][l],dp[i][j-1][l]});\n\t\t}\n\t    }\n\t}\n    }\n    printf(\"%d\\n\",dp[0][n-1][k]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nint main(void) {\n  string S;\n  ll N, K;\n  cin >> S >> K;\n  N = S.length();\n\n  const ll INF = 1LL << 50;\n  ll dp[N][N][K + 1];\n  REP(l, 0, N) REP(r, l, N) REP(k, 0, K + 1) dp[l][r][k] = 0;\n  REP(l, 0, N) REP(k, 0, K + 1) dp[l][l][0] = 1;\n  REP(l, 0, N - 1) REP(k, 0, K + 1) if(S[l] == S[l + 1]) dp[l][l + 1][0] = 2;\n  REP(s, 0, N) REP(l, 0, N - s) {\n    ll r = l + s;\n    REP(k, 0, K + 1) {\n      if(l + 1 <= r - 1 && S[l + 1] == S[r - 1]) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k] + 2);\n      if(l + 1 <= r) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r][k]);\n      if(l <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l][r - 1][k]);\n      if(k > 0) dp[l][r][k] = max(dp[l][r][k], dp[l][r][k - 1]);\n      if(k > 0 && l + 1 <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k - 1] + 2);\n    }\n  }\n  cout << dp[0][N - 1][K] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstring s; int K, dp[309][309][309];\nint main() {\n\tcin >> s >> K;\n\tstring d1 = s, d2 = s;\n\treverse(d2.begin(), d2.end());\n\tfor (int i = 0; i <= d1.size(); i++) {\n\t\tfor (int j = 0; j <= d2.size(); j++) {\n\t\t\tfor (int k = 0; k <= K; k++) {\n\t\t\t\tif (i >= 1) dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k]);\n\t\t\t\tif (j >= 1) dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k]);\n\t\t\t\tif (i >= 1 && j >= 1) {\n\t\t\t\t\tif (d1[i - 1] == d2[j - 1]) dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + 1);\n\t\t\t\t\telse if(k >= 1) dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k - 1] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i <= s.size(); i++) {\n\t\tfor (int j = 0; j <= K; j++) {\n\t\t\tret = max(ret, dp[i][s.size() - i][j]);\n\t\t}\n\t}\n\tcout << ret * 2 + s.size() % 2 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define int long long\n#define REP(i, n) for (int i = 0; i < (int)n; ++i)\n#define RREP(i, n) for (int i = (int)n - 1; i >= 0; --i)\n#define FOR(i, s, n) for (int i = s; i < (int)n; ++i)\n#define RFOR(i, s, n) for (int i = (int)n - 1; i >= s; --i)\n#define ALL(a) a.begin(), a.end()\n#define IN(a, x, b) (a <= x && x < b)\ntemplate<class T>istream&operator >>(istream&is,vector<T>&vec){for(T&x:vec)is>>x;return is;}\ntemplate<class T>inline void out(T t){cout << t << \"\\n\";}\ntemplate<class T,class... Ts>inline void out(T t,Ts... ts){cout << t << \" \";out(ts...);}\ntemplate<class T>inline bool CHMIN(T&a,T b){if(a > b){a = b;return true;}return false;}\ntemplate<class T>inline bool CHMAX(T&a,T b){if(a < b){a = b;return true;}return false;}\nconstexpr int INF = 1e18;\n\nint dp[303][303][303];\n\nsigned main(){\n\tstring s;\n\tint K;\n\tcin >> s >> K;\n\tint N = s.size();\n\tREP(i, N) {\n\t\tREP(j, N) {\n\t\t\tif(i > N - j - 1) continue;\n\t\t\tREP(k, N + 1) {\n\t\t\t\tCHMAX(dp[i + 1][j][k], dp[i][j][k]);\n\t\t\t\tCHMAX(dp[i][j + 1][k], dp[i][j][k]);\n\t\t\t\tCHMAX(dp[i + 1][j + 1][k + (s[i] != s[N - j - 1])], dp[i][j][k] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tREP(i, N) REP(j, N) REP(k, K + 1) CHMAX(ans, dp[i][j][k] * 2 - (i + j != N));\n\tout(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define overload_rep(va_0, va_1, va_2, name, ...) name\n#define rep_0(i, n) for(int i = 0; i < (n); ++i)\n#define rep_1(i, x, y) for(int i = (x); i <= (y); ++i)\n#define rep(...) overload_rep(__VA_ARGS__, rep_1, rep_0)(__VA_ARGS__)\n#define all(a) a.begin(), a.end()\n#ifndef STOP_DEBUG\n#define debug(...)\\\n    do { cerr << boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n    debug_cerr(__VA_ARGS__); cerr << noboolalpha; } while (0)\n#else\n#define debug(...)\n#endif\n\n// functions\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nvoid debug_cerr(){ cerr << '\\n'; }\ntemplate<class Head, class... Tail>\nvoid debug_cerr(Head head, Tail... tail){\n    cerr << ' ' << head;\n    debug_cerr(tail...);\n}\n\n// cin/cout setup\nstruct IoSetup{\n    IoSetup(){\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(20);\n    }\n} iosetup;\n\n// libraries\n\n// declarations\nint N, K;\nstring S;\n\nint dp[301][301][301];\n\n// solve\nint main(){\n\n    cin >> S >> K;\n    N = S.size();\n\n    rep(i, N)dp[i][i + 1][0] = 1;\n    rep(len, 1, N){\n        rep(i, 0, N - len){\n            // 右側に\n            if(i + len < N){\n                int pos;\n                rep(j, i, i + len)if(S[j] == S[i + len]){\n                    pos = j;\n                    break;\n                }\n                rep(j, 0, K){\n                    chmax(dp[i][i + len + 1][j], dp[i][i + len][j]);\n                    if(pos < i + len)chmax(dp[i][i + len + 1][j], dp[pos + 1][i + len][j] + 2);\n                }\n                rep(j, K){\n                    chmax(dp[i][i + len + 1][j + 1], dp[i + 1][i + len][j] + 2);\n                }\n            }   \n            // 左側に\n            if(i > 0){\n                int pos;\n                for(int j = i + len - 1; j >= i - 1; --j){\n                    if(S[j] == S[i - 1]){\n                        pos = j;\n                        break;\n                    }\n                }\n                rep(j, 0, K){\n                    chmax(dp[i - 1][i + len][j], dp[i][i + len][j]);\n                    if(pos > i - 1)chmax(dp[i - 1][i + len][j], dp[i - 1][pos - 1][j] + 2);\n                }\n                rep(j, K){\n                    chmax(dp[i - 1][i + len][j + 1], dp[i][i + len - 1][j] + 2);\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    rep(i, 0, K)chmax(ans, dp[0][N][K]);\n    cout << ans << '\\n';\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=305;\nint dp[N][N][N];\nint main()\n{\n    string s; int k;\n    cin>>s>>k;\n    s='a'+s;\n    int n=s.size();\n    for(int i=1;i<=n;i++)\n    {\n        dp[0][i][i]=1;\n        if(i==n)\n            continue;\n        if(s[i]==s[i+1])\n            dp[0][i][i+1]=2;\n        else\n            dp[0][i][i+1]=1;\n    }\n    for(int len=2;len<n;len++)\n    {\n        for(int i=1;i+len<=n;i++)\n        {\n            dp[0][i][i+len]=max(dp[0][i][i+len-1],dp[0][i+1][i+len]);\n            if(s[i]==s[i+len])\n                dp[0][i][i+len]=max(dp[0][i][i+len],dp[0][i+1][i+len-1]+2);\n        }\n    }\n    for(int x=1;x<=n;x++)\n    {\n        for(int i=1;i<=n;i++)\n        {\n            dp[x][i][i]=1;\n            if(i!=n) dp[x][i][i+1]=2;\n        }\n        for(int len=2;len<n;len++)\n        {\n            for(int i=1;i+len<=n;i++)\n            {\n                if(s[i]==s[i+len])\n                    dp[x][i][i+len]=dp[x][i+1][i+len-1]+2;\n                dp[x][i][i+len]=max(max(dp[x][i+1][i+len],dp[x][i][i+len-1]),max(dp[x][i][i+len],dp[x-1][i+1][i+len-1]+2));\n            }\n        }\n    }\n    cout<<dp[k][1][n]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int   ll;\ntypedef pair<ll, ll>    pll;\ntypedef pair<int, int>  pii;\n\n#define all(x)          x.begin(), x.end()\n#define kill(x)         return cout << x << endl, 0\n#define X               first\n#define Y               second\n#define sep             ' '\n#define endl            '\\n'\n\nll pw(ll a, ll b, ll mod) {\n    if (!b)    return 1;\n    if (b & 1) return a * pw(a * a % mod, b / 2, mod) % mod;\n    return pw(a * a % mod, b / 2, mod) % mod;\n}\n\nconst ll N    = 310;\nconst ll MOD  = 1e9 + 7;\nconst ll INF  = 1e18;\n\nint n, k, dp[N][N][N];\nstring s;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n    cin >> s >> k;\n    n = s.size();\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= k; j++) {\n            dp[i][i][j] = 1;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int l = 1; l + len - 1 <= n; l++) {\n            int r = l + len - 1, d = s[l - 1] != s[r - 1];\n            for (int j = 0; j <= k; j++) {\n                dp[l][r][j] = max(dp[l + 1][r][j], dp[l][r - 1][j]);\n                if (j - d >= 0)\n                    dp[l][r][j] = max(dp[l][r][j], dp[l + 1][r - 1][j - d] + 2);\n            }\n        }\n    }\n    cout << dp[1][n][k] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX=310;\nconst int INF=998877;\nchar s[MAX];\nint n,k,dp[MAX][MAX][MAX];\nint build(int l,int r,int c){\n    if(c>k) return -INF;\n    if(l>=r) return 0;\n    if(dp[l][r][c]==0){\n        int t=(s[l]==s[r-1]);\n        if(l==r-1) dp[l][r][c]=build(l+1,r-1,c+1-t)+1;\n        else dp[l][r][c]=build(l+1,r-1,c+1-t)+2;\n        dp[l][r][c]=max(dp[l][r][c],build(l+1,r,c));\n        dp[l][r][c]=max(dp[l][r][c],build(l,r-1,c));\n    }\n    return dp[l][r][c];\n}\nint main(){\n    scanf(\"%s%d\",s,&k);\n    n=strlen(s);\n    printf(\"%d\\n\",build(0,n,0));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define lsb(x) (x & (-x))\n#define ll long long\n#define ull unsigned long long\n// 217\n// 44\n\nusing namespace std;\n\nconst int MAXN = 300;\n\nchar str[MAXN + 1];\n\nint dp[MAXN + 1][MAXN + 1][MAXN + 1];\n\nint main() {\n    //ifstream cin(\"A.in\");\n    //ofstream cout(\"A.out\");\n    int i, j, k;\n    ios::sync_with_stdio(false);\n    cin >> str + 1;\n    int n = strlen(str + 1);\n    cin >> k;\n    for(i = 1; i <= n; i++) {\n        for(j = 0; j <= k; j++) {\n            dp[i][i][j] = 1;\n        }\n    }\n    for(int len = 1; len <= n; len++) {\n        for(i = 1; i + len <= n; i++) {\n            int l = i, r = i + len;\n            for(j = 0; j <= k; j++) {\n                dp[l][r][j] = max(dp[l + 1][r][j], dp[l][r - 1][j]);\n                if(j >= (str[l] != str[r])) {\n                    dp[l][r][j] = max(dp[l][r][j], dp[l + 1][r - 1][j - (str[l] != str[r])] + 2);\n                }\n            }\n            for(j = 1; j <= k; j++) {\n                dp[l][r][j] = max(dp[l][r][j], dp[l][r][j - 1]);\n            }\n        }\n    }\n    cout << dp[1][n][k];\n    //cin.close();\n    //cout.close();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <tuple>\n#include <cstdint>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <deque>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <cctype>\n#include <functional>\n#include <ctime>\n#include <cmath>\n#include <limits>\n#include <numeric>\n#include <type_traits>\n#include <iomanip>\n#include <float.h>\n#include <math.h>\nusing namespace std;\nusing ll = long long;\nunsigned euclidean_gcd(unsigned a, unsigned b) {\n    if (a < b) return euclidean_gcd(b, a);\n    unsigned r;\n    while ((r = a % b)) {\n        a = b;\n        b = r;\n    }\n    return b;\n}\n\nll ll_gcd(ll a, ll b) {\n    if (a < b) return ll_gcd(b, a);\n    ll r;\n    while ((r = a % b)) {\n        a = b;\n        b = r;\n    }\n    return b;\n}\n\nstruct UnionFind {\n    vector <ll> par;\n    vector <ll> siz;\n    UnionFind(ll sz_) : par(sz_), siz(sz_, 1LL) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(ll sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    ll root(ll x) {\n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n    bool merge(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n\n    bool issame(ll x, ll y) {\n        return root(x) == root(y);\n    }\n\n    ll size(ll x) {\n        return siz[root(x)];\n    }\n};\n\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nlong long modinv(long long a, long long mod) {\n    return modpow(a, mod - 2, mod);\n}\n\nvector<int> tpsort(vector<vector<int>>& G) {\n    int V = G.size();\n    vector<int> sorted_vertices;\n    queue<int> que;\n    vector<int> indegree(V);\n    for (int i = 0; i < V; i++) {\n        for (int j = 0; j < G[i].size(); j++) {\n            indegree[G[i][j]]++;\n        }\n    }\n    for (int i = 0; i < V; i++) {\n        if (indegree[i] == 0) {\n            que.push(i);\n        }\n    }\n    while (que.empty() == false) {\n        int v = que.front();\n        que.pop();\n        for (int i = 0; i < G[v].size(); i++) {\n            int u = G[v][i];\n            indegree[u] -= 1;\n            if (indegree[u] == 0) que.push(u);\n        }\n        sorted_vertices.push_back(v);\n    }\n    return sorted_vertices;\n}\n\nstruct Point\n{\n    double x;\n    double y;\n};\n\nstruct LineSegment\n{\n    Point start;\n    Point end;\n};\n\ndouble tenkyori(const LineSegment& line, const Point& point)\n{\n    double x0 = point.x, y0 = point.y;\n    double x1 = line.start.x, y1 = line.start.y;\n    double x2 = line.end.x, y2 = line.end.y;\n\n    double a = x2 - x1;\n    double b = y2 - y1;\n    double a2 = a * a;\n    double b2 = b * b;\n    double r2 = a2 + b2;\n    double tt = -(a * (x1 - x0) + b * (y1 - y0));\n\n    if (tt < 0)\n        return sqrt((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));\n    else if (tt > r2)\n        return sqrt((x2 - x0) * (x2 - x0) + (y2 - y0) * (y2 - y0));\n\n    double f1 = a * (y1 - y0) - b * (x1 - x0);\n    return sqrt((f1 * f1) / r2);\n}\n\ntemplate <typename X>\nstruct SegTree {\n    using FX = function<X(X, X)>; // X•X -> X となる関数の型\n    int n;\n    FX fx;\n    const X ex;\n    vector<X> dat;\n    SegTree(int n_, FX fx_, X ex_) : n(), fx(fx_), ex(ex_), dat(n_ * 4, ex_) {\n        int x = 1;\n        while (n_ > x) {\n            x *= 2;\n        }\n        n = x;\n    }\n\n    void set(int i, X x) { dat[i + n - 1] = x; }\n    void build() {\n        for (int k = n - 2; k >= 0; k--) dat[k] = fx(dat[2 * k + 1], dat[2 * k + 2]);\n    }\n\n    void update(int i, X x) {\n        i += n - 1;\n        dat[i] = x;\n        while (i > 0) {\n            i = (i - 1) / 2;  // parent\n            dat[i] = fx(dat[i * 2 + 1], dat[i * 2 + 2]);\n        }\n    }\n\n    X query(int a, int b) { return query_sub(a, b, 0, 0, n); }\n    X query_sub(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) {\n            return ex;\n        }\n        else if (a <= l && r <= b) {\n            return dat[k];\n        }\n        else {\n            X vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);\n            X vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);\n            return fx(vl, vr);\n        }\n    }\n};\n\ntemplate <typename X, typename M>\nstruct SegTreeLazy {\n    using FX = function<X(X, X)>;\n    using FA = function<X(X, M)>;\n    using FM = function<M(M, M)>;\n    int n;\n    FX fx;\n    FA fa;\n    FM fm;\n    const X ex;\n    const M em;\n    vector<X> dat;\n    vector<M> lazy;\n    SegTreeLazy(int n_, FX fx_, FA fa_, FM fm_, X ex_, M em_)\n        : n(), fx(fx_), fa(fa_), fm(fm_), ex(ex_), em(em_), dat(n_ * 4, ex), lazy(n_ * 4, em) {\n        int x = 1;\n        while (n_ > x) x *= 2;\n        n = x;\n    }\n\n    void set(int i, X x) { dat[i + n - 1] = x; }\n    void build() {\n        for (int k = n - 2; k >= 0; k--) dat[k] = fx(dat[2 * k + 1], dat[2 * k + 2]);\n    }\n\n    void eval(int k) {\n        if (lazy[k] == em) return; \n        if (k < n - 1) {            \n            lazy[k * 2 + 1] = fm(lazy[k * 2 + 1], lazy[k]);\n            lazy[k * 2 + 2] = fm(lazy[k * 2 + 2], lazy[k]);\n        }\n        \n        dat[k] = fa(dat[k], lazy[k]);\n        lazy[k] = em;\n    }\n\n    void update(int a, int b, M x, int k, int l, int r) {\n        eval(k);\n        if (a <= l && r <= b) {  \n            lazy[k] = fm(lazy[k], x);\n            eval(k);\n        }\n        else if (a < r && l < b) {                     \n            update(a, b, x, k * 2 + 1, l, (l + r) / 2);  \n            update(a, b, x, k * 2 + 2, (l + r) / 2, r);  \n            dat[k] = fx(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n    void update(int a, int b, M x) { update(a, b, x, 0, 0, n); }\n\n    X query_sub(int a, int b, int k, int l, int r) {\n        eval(k);\n        if (r <= a || b <= l) {\n            return ex;\n        }\n        else if (a <= l && r <= b) {\n            return dat[k];\n        }\n        else {\n            X vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);\n            X vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);\n            return fx(vl, vr);\n        }\n    }\n    X query(int a, int b) { return query_sub(a, b, 0, 0, n); }\n};\n\nint main() {\n    string s;\n    cin >> s;\n    ll m;\n    cin >> m;\n    ll n = s.size();\n    vector<vector<vector<ll>>> dp(n+1, vector<vector<ll>>(n+1, vector<ll>(m+1)));\n    for (int i = 0; i < m+1; i++) {\n        for (int k = 0; k < n+1; k++) {\n            for (int j = 0; j < n-k+1; j++) {\n                if (k != 0)dp[j][k][i] = max(dp[j][k-1][i], dp[j+1][k - 1][i]);\n                if (i != 0)dp[j][k][i] = max(dp[j][k][i], dp[j][k][i-1]);\n                if (k != 0)dp[j][k][i] = max(dp[j][k][i], (ll)1);\n                if (k >= 2 && i != 0) {\n                    dp[j][k][i] = max(dp[j][k][i], dp[j + 1][k - 2][i - 1]+2);\n                }\n                if (k >= 2) {\n                    if (s[j] == s[j + k-1]) {\n                        dp[j][k][i] = max(dp[j][k][i], dp[j + 1][k - 2][i] + 2);\n                    }\n                }\n            }\n        }\n    }\n    cout << dp[0][n][m] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\n#define MOD 1000000007\n#define MOD2 998244353\n#define int long long\n#define double long double\n#define EPS 1e-9\n//#define PI 3.14159265358979\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nusing namespace std;\n\ntemplate < typename T >\nostream &operator<<(ostream &os, const vector< T > &A) {\n\tfor (int i = 0; i < A.size(); i++)\n\t\tos << A[i] << \" \";\n\tos << endl;\n\treturn os;\n}\ntemplate <>\nostream &operator<<(ostream &os, const vector< vector< int > > &A) {\n\tint N = A.size();\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < A[i].size(); j++)\n\t\t\tos << A[i][j] << \" \";\n\t\tos << endl;\n\t}\n\treturn os;\n}\ntemplate < typename T, typename U >\nostream &operator<<(ostream &os, const pair< T, U > &p) {\n\tos << \"(\" << p.first << \",\" << p.second << \")\";\n\treturn os;\n}\ntemplate < typename T, typename U >\nistream &operator>>(istream &is, pair< T, U > &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate < typename T >\nistream &operator>>(istream &is, vector< T > &A) {\n\trep(i, A.size()) is >> A[i];\n\treturn is;\n}\n\ntypedef pair< int, int > pii;\ntypedef long long ll;\n\nstruct edge {\n\tint from, to, d, c, i;\n\tedge(int _from = 0, int _to = 0, int _d = 0, int _c = 0) {\n\t\tfrom = _from;\n\t\tto = _to;\n\t\td = _d;\n\t\tc = _c;\n\t}\n\tbool operator<(const edge &rhs) const {\n\t\treturn (d == rhs.d) ? (c < rhs.c) : (d < rhs.d);\n\t}\n};\nstruct aabb {\n\tint x1, y1, x2, y2;\n\taabb(int x1, int y1, int x2, int y2) : x1(x1), y1(y1), x2(x2), y2(y2) {}\n};\n\ntypedef vector< edge > edges;\ntypedef vector< edges > graph;\nstruct flow {\n\tint to, cap, rev, cost;\n\tflow(int to = 0, int cap = 0, int rev = 0, int cost = 0) : to(to), cap(cap), rev(rev), cost(cost) {}\n};\ntypedef vector< vector< flow > > flows;\n\nconst int di[4] = {0, -1, 0, 1};\nconst int dj[4] = {-1, 0, 1, 0};\nconst int ci[5] = {0, 0, -1, 0, 1};\nconst int cj[5] = {0, -1, 0, 1, 0};\nconst ll LINF = LLONG_MAX / 2;\nconst int INF = INT_MAX / 2;\nconst double PI = acos(-1);\n\nint pow2(int n) { return 1LL << n; }\ntemplate < typename T, typename U >\nbool chmin(T &x, const U &y) {\n\tif (x > y) {\n\t\tx = y;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate < typename T, typename U >\nbool chmax(T &x, const U &y) {\n\tif (x < y) {\n\t\tx = y;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\ntemplate < typename A, size_t N, typename T >\nvoid Fill(A (&array)[N], const T &val) {\n\tfill((T *)array, (T *)(array + N), val);\n}\nstruct initializer {\n\tinitializer() {\n\t\tcout << fixed << setprecision(20);\n\t}\n};\ninitializer _____;\n\nint N, M, K, T, Q, H, W;\nsigned main() {\n\tstatic int dp[301][301][301];\n\tFill(dp, -1);\n\tstring S;\n\tcin >> S >> K;\n\tN = S.size();\n\tauto f = [&](auto &&f, int l, int r, int k) -> int {\n\t\tif (dp[l][r][k] != -1)\n\t\t\treturn dp[l][r][k];\n\t\tif (l > r)\n\t\t\treturn 0;\n\t\tif (l == r)\n\t\t\treturn 1;\n\t\tint ret = 0;\n\t\tchmax(ret, f(f, l, r - 1, k));\n\t\tchmax(ret, f(f, l + 1, r, k));\n\t\tif (S[l] == S[r]) {\n\t\t\tchmax(ret, f(f, l + 1, r - 1, k) + 2);\n\t\t} else if (k > 0) {\n\t\t\tchmax(ret, f(f, l + 1, r - 1, k - 1) + 2);\n\t\t}\n\t\treturn dp[l][r][k] = ret;\n\t};\n\tint ans = 0;\n\trep(k, K + 1) {\n\t\tchmax(ans, f(f, 0, N - 1, k));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#define maxn 310\nusing namespace std;\n\nchar s[maxn];\nint n,k,f[maxn][maxn][maxn];\n\ntemplate <typename T>\nbool chkmax(T &a, T b){\n\treturn a < b ? a = b, 1 : 0;\n}\n\nint main(){\n    scanf(\"%s\",s+1);\n\tn=strlen(s + 1);\n\tcin>>k;\n    for(int len=1;len<=n;len++)\n        for(int st=1;st<=n-len+1;st++) {\n            int ed=st+len-1;\n            for(int i=0;i<=k;i++) {\n                if(st==ed) \n\t\t\t\t\tf[st][ed][i]=1;\n                else if(st+1==ed)\n\t\t\t\t\tf[st][ed][i]=i || s[st]==s[ed] ? 2 : 1;\n                else{\n                    f[st][ed][i]=max(f[st+1][ed][i],f[st][ed-1][i]);\n                    if(s[st]==s[ed])\n\t\t\t\t\t\tchkmax(f[st][ed][i],f[st+1][ed-1][i]+2);\n                    if(i) \n\t\t\t\t\t\tchkmax(f[st][ed][i],f[st+1][ed-1][i-1]+2);\n                }\n            }\n        }\n    printf(\"%d\\n\", f[1][n][k]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[305][305][305];\n\nint main(){\n  \n  string s;\n  int K;\n  \n  cin>>s>>K;\n  \n  memset(dp,-1,sizeof(dp));\n\n  s='x'+s;\n  \n  int len=s.size();\n  \n  dp[1][len-1][0]=0;\n  \n  for(int l=1;l<len;l++)\n    \n    for(int r=len-1;r>=l;r--){\n      \n      for(int k=0;k<=K;k++){\n\t\n\tif(dp[l][r][k]==-1) continue;\n\t\n\tif(s[l]==s[r]){\n\t  if(l==r) dp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]+1);\n\t  else dp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]+2);\n\t}\n\t\n\tif(l==r) continue;\n\t\n\tdp[l+1][r-1][k+1]=max(dp[l+1][r-1][k+1], dp[l][r][k]+2);\n\tdp[l+1][r][k]=max(dp[l+1][r][k], dp[l][r][k]);\n\tdp[l][r-1][k]=max(dp[l][r-1][k], dp[l][r][k]);\n\tdp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]);\n      }\n    }\n  \n  int ans=0;\n  \n  for(int i=0;i<len;i++)\n    for(int j=0;j<len;j++)\n      for(int k=0;k<=K;k++) ans=max(ans, dp[i][j][k]);\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<int, int> par;\ntypedef pair<par, int> prr;\n#define x first\n#define y second\nint dp[305][305];\nint main(){\n    string S, T;\n    cin >> S;\n    T = S;\n    reverse(T.begin(), T.end());\n    int n = S.size();\n    S = \"a\" + S;\n    T = \"a\" + T;\n    int maxx;\n    scanf(\"%d\", &maxx);\n    int ans = 0;\n    for (int mid = 1; mid <= n; mid++) {\n        memset(dp, 0, sizeof(dp));\n        int a = mid;\n        int b = n - mid;\n        for (int i = 1; i <= a; i++)\n        for (int j = 1; j <= b; j++) {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n            if (S[i] == T[j]) dp[i][j] = dp[i - 1][j - 1] + 1;\n        }\n        int res = min(a, b);\n        ans = max(ans, (dp[a][b] + min(res, maxx)) * 2);\n    }\n    for (int mid = 1; mid <= n; mid++) {\n        memset(dp, 0, sizeof(dp));\n        int a = mid - 1;\n        int b = n - mid;\n        for (int i = 1; i <= a; i++)\n        for (int j = 1; j <= b; j++) {\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n            if (S[i] == T[j]) dp[i][j] = dp[i - 1][j - 1] + 1;\n        }\n        int res = min(a, b);\n        ans = max(ans, (dp[a][b] + min(res, maxx)) * 2 + 1);\n    }\n\n    printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nstatic const int IINF = 1 << 30;\n\ntemplate <typename T> std::vector<T> vectors(std::size_t n, T val) {\n  return std::vector<T>(n, val);\n}\n\ntemplate <typename T, typename... Args>\nauto vectors(std::size_t n, Args... args) {\n  return std::vector<decltype(vectors<T>(args...))>(n, vectors<T>(args...));\n}\n\ntemplate <class T> inline bool chmax(T &a, const T &b) {\n  return (a < b) ? a = b, true : false;\n}\n\nint main() {\n  // Input\n  std::string S;\n  int K;\n  int N;\n  std::cin >> S;\n  std::cin >> K;\n  N = S.length();\n\n  // Initialization\n  auto dp = vectors<int>(1 + N + 1, 1 + N + 1, 1 + K + 1, -IINF);\n  // auto dp = vectors<int>(1 + N + 1, 1 + N + 1, 1 + K + 1, 0);\n\n  // Initial condition\n  // dp[0][0][0] = 0;\n  for (int k = 0; k <= K; ++k)\n    dp[0][0][k] = 0;\n\n  // DP main\n  for (int i = 0; i <= N; ++i) {\n    for (int j = 0; j <= N; ++j) {\n      for (int k = 0; k <= K; ++k) {\n        chmax(dp[i + 1][j][k], dp[i][j][k]);\n        chmax(dp[i][j + 1][k], dp[i][j][k]);\n        chmax(dp[i + 1][j + 1][k + 1], dp[i][j][k] + 1);\n        if (i < N and k < N and S[i] == S[N - j - 1])\n          chmax(dp[i + 1][j + 1][k], dp[i][j][k] + 1);\n      }\n    }\n  }\n\n  // Output\n  int res = -1;\n  for (int i = 0; i <= N; ++i)\n    chmax(res, 2 * dp[i][N - i][K]);\n  for (int i = 0; i < N; ++i)\n    chmax(res, 2 * dp[i][N - i - 1][K] + 1);\n\n  std::cout << res << std::endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nstatic const int IINF = 1 << 30;\n\ntemplate <typename T> std::vector<T> vectors(std::size_t n, T val) {\n  return std::vector<T>(n, val);\n}\n\ntemplate <typename T, typename... Args>\nauto vectors(std::size_t n, Args... args) {\n  return std::vector<decltype(vectors<T>(args...))>(n, vectors<T>(args...));\n}\n\ntemplate <class T> inline bool chmax(T &a, const T &b) {\n  return (a < b) ? a = b, true : false;\n}\n\nint main() {\n  // Input\n  std::string S;\n  int K;\n  int N;\n  std::cin >> S;\n  std::cin >> K;\n  N = S.length();\n\n  // Initialization\n  auto dp = vectors<int>(1 + N + 1, 1 + N + 1, 1 + K + 1, -IINF);\n\n  // Initial condition\n  dp[0][0][0] = 0;\n\n  // DP main\n  for (int i = 0; i <= N; ++i) {\n    for (int j = 0; j <= N; ++j) {\n      for (int k = 0; k <= K; ++k) {\n        chmax(dp[i + 1][j][k], dp[i][j][k]);\n        chmax(dp[i][j + 1][k], dp[i][j][k]);\n        // chmax(dp[i + 1][j][k + 1], dp[i][j][k] + 1);\n        // chmax(dp[i][j + 1][k + 1], dp[i][j][k] + 1);\n        chmax(dp[i + 1][j + 1][k + 1], dp[i][j][k] + 1);\n        if (i < N and k < N and S[i] == S[N - j - 1])\n          chmax(dp[i + 1][j + 1][k], dp[i][j][k] + 1);\n      }\n    }\n  }\n\n  // Output\n  int res = -1;\n  // for (int k = 0; k <= K; ++k) {\n    for (int i = 0; i <= N; ++i)\n      chmax(res, 2 * dp[i][N - i][K]);\n    for (int i = 0; i < N; ++i)\n      chmax(res, 2 * dp[i][N - i - 1][K] + 1);\n  // }\n\n  std::cout << res << std::endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nconst double EPS = 1e-10;\nconst ll INF = 100000000;\nconst ll MOD = 1000000007;\n\nstring str;\nint k;\nint dp[300][301][301];\n\nint main() {\n    cin >> str;\n    cin >> k;\n    int n = str.size();\n    int ans = 1;\n    rep(i,n) dp[i][1][0] = 1;\n    for (int j = 2; j <= n; j++) {\n        rep(i,n-j+1) {\n            for (int u = 0; u <= k; u++) {\n                if (str[i] == str[i+j-1]) {\n                    dp[i][j][u] = dp[i+1][j-2][u]+2;\n                } else {\n                    dp[i][j][u] = max(dp[i][j-1][u], dp[i+1][j-1][u]);\n                }\n                if (u >= 1) dp[i][j][u] = max(dp[i][j][u], dp[i+1][j-2][u-1]+2);\n                ans = max(ans, dp[i][j][u]);\n            }\n        }\n    }\n    cout << ans << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nconst int N=305;\nint dp[N][N][N]={},k;\nchar s[N];\nint main() {\n    scanf(\"%s%d\",s+1,&k);int n=strlen(s+1);\n    for(int i=1;i<=n;i++) for(int j=0;j<=k;j++) dp[i][i][j]=1,dp[i][i-1][j]=0;\n    for(int j=1;j<n;j++) for(int i=1;i+j<=n;i++) for(int r=0;r<=k;r++){\n        dp[i][i+j][r]=std::max(dp[i][i+j-1][r],dp[i+1][i+j][r]);\n        if(s[i]==s[i+j]) dp[i][i+j][r]=std::max(dp[i][i+j][r],dp[i+1][i+j-1][r]+2);\n        if(r) dp[i][i+j][r]=std::max(dp[i][i+j][r],dp[i+1][i+j-1][r-1]+2);\n    }\n    int ans=dp[1][n][k];\n    for(int i=0;i<k;i++) ans=std::max(ans,dp[1][n][k]);\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nint best[310][310][310];\n\nint main(){\n    string s;\n    cin >> s;\n    int k;\n    cin >> k;\n    int n = s.size();\n    for(int i = n-1; i >= 0; i--){\n        for(int a = 0; a <= k; a++){\n            if(i > 0) best[i][i-1][a] = 0;\n        }\n    }\n    for(int i = n-1; i >= 0; i--){\n        for(int j = i; j < n; j++){\n            for(int a = 0; a <= k; a++){\n                best[i][j][a] = 1;\n                if(i == j) continue;\n                best[i][j][a] = max(best[i][j][a], best[i+1][j][a]);\n                best[i][j][a] = max(best[i][j][a], best[i][j-1][a]);\n                if(s[i] == s[j]){\n                    best[i][j][a] = max(best[i][j][a], 2 + best[i+1][j-1][a]);\n                } else {\n                    if(a > 0){\n                        best[i][j][a] = max(best[i][j][a], best[i+1][j-1][a-1] + 2);\n                    }\n                }\n            }\n        }\n    }\n    \n    \n    cout << best[0][n-1][k] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <bitset>\t\t//UWAGA - w czasie kompilacji musi byc znany rozmiar wektora - nie mozna go zmienic\n#include <cassert>\n#include <iomanip>\t\t//do setprecision\n#include <ctime>\n#include <complex>\nusing namespace std;\n\n#define FOR(i,b,e) for(int i=(b);i<(e);++i)\n#define FORQ(i,b,e) for(int i=(b);i<=(e);++i)\n#define FORD(i,b,e) for(int i=(b)-1;i>=(e);--i)\n#define REP(x, n) for(int x = 0; x < (n); ++x)\n#define ALL(u) (u).begin(),(u).end()\n\n#define ST first\n#define ND second\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define ULL unsigned LL\n#define LD long double\n\ntypedef pair<int, int> PII;\n\nconst double pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342;\n\nconst int MR = 310;\n\nchar S[MR];\n\nint dp[MR][MR][MR];\n\n// key observation - max subsequence of S and rev(S) is the length of the longest palindromic subsequence of S\nint go(int b, int e, int k)\n{\n\tif (dp[b][e][k])\n\t\treturn dp[b][e][k];\n\tif (b >= e)\n\t\treturn 0;\n\tif (b == e - 1)\n\t\treturn dp[b][e][k] = 1;\n\n\tif (b == e - 2)\n\t{\n\t\tif (S[b] == S[b + 1] || k)\n\t\t\treturn dp[b][e][k] = 2;\n\t\telse\n\t\t\treturn dp[b][e][k] = 1;\n\t}\n\n\tif (S[b] == S[e - 1])\n\t\treturn 2 + go(b + 1, e - 1, k);\n\n\treturn dp[b][e][k] = max(max(go(b + 1, e, k), go(b, e - 1, k)), k ? 2 + go(b + 1, e - 1, k - 1) : 0);\n}\n\nint main()\n{\n\tint K;\n\tscanf(\"%s%d\", S, &K);\n\n\tprintf(\"%d\\n\", go(0, strlen(S), K));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\n\nint mat[301][301][301] = {0};\n\nint main() {\n\tint n;\n\tint res = 0;\n\n\tstring a, b;\n\tint k;\n\tcin >> a;\n\tcin >> k;\n\tfor(int i=0; i<a.size(); ++i)\n\t\tb += a[a.size()-i-1];\n\n\tn = max(a.size(), b.size());\n\n\tfor(int i=0; i<2*n; ++i)\n\t\tfor(int j=0; j<=i; ++j)\n\t\t{\n\t\t\tint y = i-j;\n\t\t\tint x = j;\n\t\t\tif(a.size() <= y || b.size() <= x)\n\t\t\t\tcontinue;\n\n\t\t\tif(a[y] == b[x])\n\t\t\t{\n\t\t\t\tfor(int l=0; l<=k; ++l)\n\t\t\t\t\tmat[y+1][x+1][l] = mat[y][x][l] + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int l=0; l<=k; ++l)\n\t\t\t\t{\n\t\t\t\t\tmat[y+1][x+1][l] = max(mat[y][x+1][l], mat[y+1][x][l]);\n\t\t\t\t\tif(0 < l)\n\t\t\t\t\t{\n\t\t\t\t\t\tint q = (x == y ? 2 : 2);\n\t\t\t\t\t\tmat[y+1][x+1][l] = max(mat[y+1][x+1][l], mat[y][x][l-1] + q);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tint ans = 0;\n\tfor(int l=0; l<=k; ++l)\n\t\tans = max(ans, mat[a.size()][b.size()][l]);\n\t//ans += 2*k;\n\tans = min(ans, n);\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 100000000\n#define YJ 1145141919\n#define INF_INT_MAX 2147483647\n#define INF_LL_MAX 9223372036854775807\n#define EPS 1e-10\n#define Pi acos(-1)\n#define LL long long\n#define ULL unsigned long long\n#define LD long double\n\nconst int MAX_S = 305;\nstring S;\nint K;\n\nint dp[MAX_S][MAX_S][MAX_S];\n\nint main()\n{\n  cin >> S;\n  cin >> K;\n  \n  memset(dp, 0, sizeof(dp));\n\n  for(int i = 0; i < S.length(); i++) {\n    dp[i][i][K] = 1;\n  }\n\n  for(int w = 0; w <= S.length(); w++) {\n    for(int l = 0; l+w <= S.length(); l++) {\n      int r = l+w;\n      for(int k = 0; k <= K; k++) {\n\t//何もしない\n\tif(l-1 >= 0) {\n\t  dp[l-1][r][k] = max(dp[l-1][r][k], dp[l][r][k]);\n\t}\n\tif(r+1 < S.length()) {\n\t  dp[l][r+1][k] = max(dp[l][r+1][k], dp[l][r][k]);\n\t}\n\n\t//回文を伸ばす\n\tif(l-1 >= 0 && r+1 < S.length()) {\n\t  if(S[l-1] == S[r+1]) {\n\t    dp[l-1][r+1][k] = max(dp[l-1][r+1][k], dp[l][r][k] + 2);\n\t  }\n\t  if(k > 0) {\n\t    dp[l-1][r+1][k-1] = max(dp[l-1][r+1][k-1], dp[l][r][k] + 2);\n\t  }\n\t}\n      }\n    }\n  }\n\n  int ans = 0;\n  for(int k = 0; k <= K; k++) {\n    ans = max(ans, dp[0][S.length()-1][k]);\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int INF=1e9;\nconst long double eps=1e-9;\nconst int maxn=3e2+10;\nint dp[maxn][maxn][maxn];\nchar str[maxn];\ninline int read(){\n\tint x=0,flag=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')flag=-1,ch=getchar();\n\twhile(isdigit(ch))x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn x*flag;\n}\ninline void chkmax(int &x,int y){\n\tx=x>y?x:y;\n}\nint main(){\n\tint i,j,k,m,n;\n\tscanf(\"%s\",str+1);\n\tn=strlen(str+1);m=read();\n\tdp[0][n+1][0]=0;\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=n;j>=i;j--)\n\t\t\tfor(k=0;k<=m;k++){\n\t\t\t\tif(str[i]==str[j])chkmax(dp[i][j][k],dp[i-1][j+1][k]+1);\n\t\t\t\telse if(k)chkmax(dp[i][j][k],dp[i-1][j+1][k-1]+1);\n\t\t\t\tchkmax(dp[i][j][k],dp[i][j+1][k]);chkmax(dp[i][j][k],dp[i-1][j][k]);\n\t\t\t}\n\tint ans=0;\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=0;j<=k;j++)\n\t\t\tans=max(ans,dp[i][i][j]);\n\tprintf(\"%d\\n\",ans*2-1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#pragma GCC optimize (\"O0\")\n#else\n#pragma GCC optimize (\"O3\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target (\"avx\")\n#endif\n\n#include <vector>\n#include <set>\n#include <map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <functional>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nusing ll = long long;\nusing VI = vector<int>;\nusing VVI = vector<vector<int>>;\nusing VLL = vector<ll>;\nusing VVLL = vector<vector<ll>>;\nusing VB = vector<bool>;\nusing VVB = vector<vector<bool>>;\nusing PII = pair<int, int>;\ntemplate <typename T>\nusing minheap = priority_queue<T, vector<T>, greater<T>>;\nconst int INF = 1e9 + 7;\nconst ll INF_LL = (ll)1e18 + 7;\n\n#define __overload3(_1, _2, _3, name,...) name\n#define rep(...) __overload3(__VA_ARGS__, repFromUntil, repUntil, repeat)(__VA_ARGS__)\n#define repeat(times) repFromUntil(__name, 0, times)\n#define repUntil(name, times) repFromUntil(name, 0, times)\n#define repFromUntil(name, from, until) for (int name = from, name##__until = (until); name < name##__until; name++)\n#define repr(...) __overload3(__VA_ARGS__, reprFromUntil, reprUntil, repeat)(__VA_ARGS__)\n#define reprUntil(name, times) reprFromUntil(name, 0, times)\n#define reprFromUntil(name, from, until) for (int name = until - 1, name##__from = (from); name >= name##__from; name--)\n\n#define EXIT(out) do { OUT(out); exit(0); } while (0)\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define _1 first\n#define _2 second\n\n#define debug(v) do {debugos << \"L\" << __LINE__ << \" \" << #v << \" > \";debugos<<(v)<<newl;} while (0)\n#define debugv(v) do {debugos << \"L\" << __LINE__ << \" \" << #v << \" > \";for(auto e:(v)){debugos<<e<<\" \";}debugos<<newl;} while (0)\n#define debuga(m,w) do {debugos << \"L\" << __LINE__ << \" \" << #m << \" > \";for(int x=0;x<(w);x++){debugos<<(m)[x]<<\" \";}debugos<<newl;} while (0)\n#define debugaa(m,h,w) do {debugos << \"L\" << __LINE__ << \" \" << #m << \" > \\n\";for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){debugos<<(m)[y][x]<<\" \";}debugos<<newl;}} while (0)\n\n#define newl \"\\n\"\nconstexpr int dr[] = {1,-1,0,0};\nconstexpr int dc[] = {0,0,1,-1};\n\nbool inside(int r, int c, int H, int W) {\n  return 0 <= r and r < H and 0 <= c and c < W;\n}\n\ntemplate <typename T> bool chmin(T& var, T x) {\n  if (var > x) {\n    var = x;\n    return true;\n  } else return false;\n}\n\ntemplate <typename T> bool chmax(T& var, T x) {\n  if (var < x) {\n    var = x;\n    return true;\n  } else return false;\n}\n\ntemplate <typename T>\nstruct minT {\n  T operator()(T a, T b) {\n    return min(a, b);\n  }\n};\n\ntemplate <typename T>\nstruct maxT {\n  T operator()(T a, T b) {\n    return max(a, b);\n  }\n};\n\ntemplate <typename T> int sgn(T val) {\n  return (T(0) < val) - (val < T(0));\n}\n\nll power(ll e, int t, ll mod = INF_LL) {\n  ll res = 1;\n  while (t) {\n    if (t&1) res = (res * e) % mod;\n    t >>= 1;\n    e = (e * e) % mod;\n  }\n  return res;\n}\n\ntemplate <typename T> T divceil(T, T);\n\ntemplate <typename T> T divfloor(T m, T d) {\n  if (sgn(m) * sgn(d) >= 0) return m / d;\n  else return -divceil(abs(m), abs(d));\n}\n\ntemplate <typename T> T divceil(T m, T d) {\n  if (m >= 0 and d > 0) return (m+d-1)/d;\n  else if (m < 0 and d < 0) return divceil(-m, -d);\n  else return -divfloor(abs(m), abs(d));\n}\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b){return vector<T>(a, b);}\n\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts){\n  return vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\nstring operator*(const string& s, int times) {\n  string res = \"\";\n  rep(times) res += s;\n  return res;\n}\n\nclass MyScanner {\npublic:\n  int offset = 0;\n  template <typename T> void input_integer(T& var) {\n    var = 0; T sign = 1;\n    int cc = getchar();\n    for (; cc<'0' || '9'<cc; cc = getchar())\n      if (cc == '-') sign = -1;\n    for (; '0' <= cc && cc <= '9'; cc = getchar())\n      var = (var << 3) + (var << 1) + cc - '0';\n    var = var * sign; var += offset;\n  }\n  int c() { char c; while (c = getchar(), c == ' ' or c == '\\n'); return c; }\n  MyScanner& operator>>(char& var) { var = c(); return *this; }\n  MyScanner& operator>>(int& var) { input_integer<int>(var); return *this; }\n  MyScanner& operator>>(ll& var) { input_integer<ll>(var); return *this; }\n  MyScanner& operator>>(string& var) {\n    int cc = getchar();\n    for (; !isvisiblechar(cc); cc = getchar());\n    for (; isvisiblechar(cc); cc = getchar())\n      var.push_back(cc);\n    return *this;\n  }\n  template <typename T>\n  operator T() {\n    T x;\n    *this >> x;\n    return x;\n  }\n  template <typename T>\n  void operator()(T &t) {\n    *this >> t;\n  }\n  template <typename T, typename... Ts>\n  void operator()(T &t, Ts &...ts) {\n    *this >> t;\n    this->operator()(ts...);\n  }\n  template <typename Iter>\n  void iter(Iter first, Iter last) {\n    while (first != last) *this >> *first, first++;\n  }\n  VI vi(int n) {\n    VI res(n);\n    iter(all(res));\n    return res;\n  }\n  VVI vvi(int n, int m) {\n    VVI res(n);\n    rep(i, n) res[i] = vi(m);\n    return res;\n  }\n  VLL vll(int n) {\n    VLL res(n);\n    iter(all(res));\n    return res;\n  }\n  VVLL vvll(int n, int m) {\n    VVLL res(n);\n    rep(i, n) res[i] = vll(m);\n    return res;\n  }\n  template <typename T>\n  vector<T> v(int n) {\n    vector<T> res(n);\n    iter(all(res));\n    return res;\n  }\nprivate:\n  int isvisiblechar(int c) {\n    return 0x21 <= c && c <= 0x7E;\n  }\n} IN, IN1{-1};\n\nclass MyPrinter {\npublic:\n  template <typename T>\n  void output_integer(T var) {\n    if (var == 0) { putchar('0'); return; }\n    if (var < 0)\n      putchar('-'),\n      var = -var;\n    char stack[32]; int stack_p = 0;\n    while (var)\n      stack[stack_p++] = '0' + (var % 10),\n      var /= 10;\n    while (stack_p)\n      putchar(stack[--stack_p]);\n  }\n  MyPrinter& operator<<(char c) { putchar(c); return *this; }\nMyPrinter& operator<<(double x) { printf(\"%.10f\\n\", x); return *this; }\n  template <typename T> MyPrinter& operator<<(T var) { output_integer<T>(var); return *this; }\n  MyPrinter& operator<<(char* str_p) { while (*str_p) putchar(*(str_p++)); return *this; }\n  MyPrinter& operator<<(const char* str_p) { while (*str_p) putchar(*(str_p++)); return *this; }\n  MyPrinter& operator<<(const string& str) {\n    const char* p = str.c_str();\n    const char* l = p + str.size();\n    while (p < l) putchar(*p++);\n    return *this;\n  }\n  template <typename T>\n  void operator()(T x) {\n    *this << x << newl;\n  }\n  template <typename T, typename... Ts>\n  void operator()(T x, Ts ...xs) {\n    *this << x << \" \";\n    this->operator()(xs...);\n  }\n  template <typename Iter>\n  void iter(Iter s, Iter t) {\n    if (s == t) *this << \"\\n\";\n    else {\n      for (; s != t; s++) {\n        *this << *s << \" \\n\"[next(s, 1) == t];\n      }\n    }\n  }\n  template <typename Range>\n  void range(const Range& r) {\n    iter(begin(r), end(r));\n  }\n} OUT;\n\nclass DebugPrint {\npublic:\n  template <typename T>\n  DebugPrint& operator <<(const T& v) {\n#ifdef LOCAL\n    cerr << v;\n#endif\n    return *this;\n  }\n} debugos;\n\n\nint main() {\n  string s = IN;\n  int k = IN;\n  int n = s.size();\n\n  auto dp = make_v(n+1, n+1, k+1, 0);\n\n  rep(l, n) dp[l][l+1][0] = 1;\n\n  rep(d, 2, n+1) rep(l, n+1-d) {\n    int r = l+d;\n    rep(x, k+1) {\n      dp[l][r][x] = max(dp[l+1][r][x], dp[l][r-1][x]);\n      if (s[l] == s[r-1]) chmax(dp[l][r][x], dp[l+1][r-1][x] + 2);\n      else if (x > 0) {\n        chmax(dp[l][r][x], dp[l+1][r-1][x-1] + 2);\n      }\n    }\n  }\n\n  OUT(*max_element(all(dp[0][n])));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring S;\nint K;\n\nint main()\n{\n    cin >> S >> K;\n    int L = S.size();\n    vector<vector<vector<int> > > dp(L, vector<vector<int> >(L, vector<int>(K+1, 1)));\n\n    // 1文字 dp[i][i][k]は全部1\n    \n    // 2文字 dp[i][i+1][k]埋め\n    for (int i=0; i<L-1; i++)\n    {\n        dp[i][i+1] = vector<int>(K+1, 2);\n        if (S[i] != S[i+1]) dp[i][i+1][0] = 1;\n    }\n    for (int l=3; l<=L; l++)\n    {\n        for (int i=0; i<=L-l; i++)\n        {\n            if (S[i] == S[i+l-1])\n            {\n                for (int k=0; k<=K; k++) dp[i][i+l-1][k] = dp[i+1][i+l-2][k] + 2;\n            }\n            else\n            {\n                for (int k=0; k<=K; k++)\n                {\n                    int tmpmax = max(dp[i][i+l-2][k], dp[i+1][i+l-1][k]);\n                    if (k>0) tmpmax = max(tmpmax, dp[i+1][i+l-2][k-1]+2);\n                    dp[i][i+l-1][k] = tmpmax;\n                }                \n            }\n        }\n    }\n    cout << dp[0].back().back() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct pt\n{\n\tint x, y, i;\n};\n\npt operator - (const pt &a, const pt &b)\n{\n\treturn {a.x - b.x, a.y - b.y, -1};\n}\n\nll operator ^ (const pt &a, const pt &b)\n{\n\treturn a.x * (ll) b.y - a.y * (ll) b.x;\n}\n\nll operator * (const pt &a, const pt &b)\n{\n\treturn a.x * (ll) b.x + a.y * (ll) b.y;\n}\n\npt s;\n\nbool operator < (const pt &a, const pt &b)\n{\n    if (((a - s) ^ (b - s)) != 0)\n    {\n\t    return ((a - s) ^ (b - s)) < 0;\n    }\n    else\n    {\n        return (a - s) * (a - s) < (b - s) * (b - s);\n    }\n}\n\nvector <pt> hull(vector <pt> e)\n{\n\tsort(e.begin(), e.end(), [] (pt a, pt b)\n\t{\n\t\tif (a.x != b.x)\n\t\t{\n\t\t\treturn a.x < b.x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn a.y < b.y;\n\t\t}\n\t});\n\ts = e[0];\n\tsort(e.begin() + 1, e.end());\n\tvector <pt> h;\n\tfor (auto c : e)\n\t{\n\t\twhile (h.size() > 1)\n\t\t{\n\t\t\tpt a = h[(int) h.size() - 2];\n\t\t\tpt b = h[(int) h.size() - 1];\n\t\t\tif (((b - a) ^ (c - b)) >= 0)\n\t\t\t{\n\t\t\t\th.pop_back();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\th.push_back(c);\n\t}\n\treturn h;\n}\n\ndouble dist(const pt &a, const pt &b)\n{\n    ll len = (a.x - b.x) * (ll) (a.x - b.x) + (a.y - b.y) * (ll) (a.y - b.y);\n    return sqrt(len);\n}\n\nint main()\n{\n#ifdef ONPC\n    freopen(\"a.in\", \"r\", stdin);\n#endif\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\tint n;\n    cin >> n;\n\tvector <pt> e;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint x, y;\n        cin >> x >> y;\n\t\te.push_back({x, y, i});\n\t}\n\tvector <pt> cur = hull(e);\n    e = cur;\n    int m = (int) cur.size();\n    double len = 0;\n    for (int i = 0; i < m; i++)\n    {\n        len += dist(e[i], e[(i + 1) % m]); \n    }\n    vector <double> ans(n);\n    double pi = acos(-1);\n    for (int i = 0; i < m; i++)\n    {\n        pt v1 = e[(i + m - 1) % m] - e[i];\n        pt v2 = e[(i + 1) % m] - e[i];\n        ans[e[i].i] = (atan2(v2 ^ v1, v2 * v1) + pi) / (2 * pi);\n    }\n    for (int i = 0; i < n; i++)\n    {\n        cout << fixed << setprecision(20) << ans[i] << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb           push_back\n#define pii          pair<int,int>\n#define vi           vector<int>\n#define vii         vector<pair<int,int>>\n#define mp           make_pair\n#define FOR(i, n) for (int i = 0; i <  (int)(n); i++)\n#define FOR1(i, n) for (int i = 1; i <= (int)(n); i++)\n#define FORD0(i, n) for (int i = (int)n; i >= 0; i--)\n#define FORD1(i, n) for (int i = (int)n; i >= 1; i--)\n#define debug(X) { cout << #X << \" = \" << (X) << endl; }\n#define endl '\\n'\n#define int long long int\nusing namespace std;\n\n\nsigned main(){\n    ios_base::sync_with_stdio(false);cin.tie(NULL);\n\n    string s;cin >> s;\n    int n = s.length();\n    int k;cin >> k;\n    vector<vi> dp(n+1, vi(n+1));\n    vector<vi> prev(n+1, vi(n+1));\n    for(int change = 0; change <= k; change++){\n        for(int len = 1; len <= n; len++){\n            for(int start =0; start <= n - len; start++){\n                dp[start][len] = max(dp[start+1][len-1], dp[start][len-1]); \n                if(s[start] == s[start + len -1]){\n                    int ad = 0;\n                    if(len >= 3)ad = dp[start+1][len -1];\n                    dp[start][len] = max(1 + (len != 1) + ad, dp[start][len]);\n                }else if(change > 0){\n                    int ad = 0;\n                    if(len >= 3)ad = prev[start+ 1][len - 1];\n                    dp[start][len] = max(1 + (len != 1) + ad, dp[start][len]); \n//                cout << dp[start][len] <<  \" \";\n                }\n            }\n//            cout << endl;\n        }\n        swap(dp, prev);\n    }\n    cout << prev[0][n];\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define FORR(i, n) for(ll i = (ll)n - 1LL; i >= 0LL; i--)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) (x).begin(), (x).end()\nusing namespace std;\nusing ll = long long;\ntemplate <typename T> using V = vector<T>;\n\nconstexpr int Mod = 998244353;\nconstexpr int mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\n\ntemplate <typename T> constexpr bool chmax(T &a, const T &b) {\n    if(a >= b) return false;\n    a = b;\n    return true;\n}\ntemplate <typename T> constexpr bool chmin(T &a, const T &b) {\n    if(a <= b) return false;\n    a = b;\n    return true;\n}\n\n/*-------------------------------------------*/\n\nstring s;\nint n, k;\nint dp[334][334][334];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    cin >> s >> k;\n    n = s.size();\n    rep(l, n) dp[l][l][0] = 1;\n    FOR(bit, 1, n + 1) rep(l, n - bit + 1) {\n        int r = l + bit - 1;\n        rep(i, k + 1) {\n            if(s[l] == s[r]) dp[l][r][i] = dp[l + 1][r - 1][i] + 2;\n            if(i) chmax(dp[l][r][i], dp[l + 1][r - 1][i - 1] + 2);\n            chmax(dp[l][r][i], dp[l + 1][r][i]);\n            chmax(dp[l][r][i], dp[l][r - 1][i]);\n            chmin<int>(dp[l][r][i], bit);\n        }\n    }\n    cout << dp[0][n - 1][k] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpii;\n\nint dp[310][310][310];\nchar a[310];\n\nint main()\n{\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(\"input.txt\",\"r\",stdin);\n\t\tfreopen(\"output.txt\",\"w\",stdout);\n\t#endif\n\tscanf(\"%s\",a+1);int n=strlen(a+1);\n\tfor (int i=1;i<=n;i++) {dp[i+1][i][0]=0;dp[i][i][0]=1;}\n\tint K;scanf(\"%d\",&K);\n\tfor (int t=1;t<n;t++)\n\t\tfor (int i=1;i<=n-t;i++)\n\t\t{\n\t\t\tint j=i+t;\n\t\t\tfor (int k=0;k<=K;k++)\n\t\t\t{\n\t\t\t\tdp[i][j][k]=max(dp[i][j-1][k],dp[i+1][j][k]);\n\t\t\t\tif (a[i]==a[j])\n\t\t\t\t\tdp[i][j][k]=max(dp[i][j][k],dp[i+1][j-1][k]+2);\n\t\t\t\telse\n\t\t\t\t\tif (k) dp[i][j][k]=max(dp[i][j][k],dp[i+1][j-1][k-1]+2);\n\t\t\t}\n\t\t}\n\tint ans=0;\n\tfor (int i=0;i<=K;i++) ans=max(ans,dp[1][n][i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N=305;\n\ntypedef long long LL;\n\nint n,f[N][N][N],m,ans,la[N][26];\n\nchar S[N];\n\nint main()\n{\n\tscanf(\"%s%d\",S+1,&m);\n\tn=strlen(S+1);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tS[i]-='a';\n\t\tfor (int j=0;j<26;j++) la[i][j]=(S[i]==j)?i:la[i-1][j];\n\t}\n\tf[0][0][0]=n+1;\n\tfor (int i=0;i<n;i++)\n\t{\n\t\tfor (int j=0;j<=min(i,m);j++)\n\t\t{\n\t\t\tfor (int k=0;k<=i;k++) if (f[i][j][k]>i)\n\t\t\t{\n\t\t\t\tans=max(ans,k*2);\n\t\t\t\tif (f[i][j][k]-1>i) ans=max(ans,k*2+1);\n\t\t\t\tf[i+1][j][k]=max(f[i+1][j][k],f[i][j][k]);\n\t\t\t\tf[i+1][j][k+1]=max(f[i+1][j][k+1],la[f[i][j][k]-1][S[i+1]]);\n\t\t\t\tif (j<m) f[i+1][j+1][k+1]=max(f[i+1][j+1][k+1],f[i][j][k]-1);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n#ifdef _DEBUG_\n  #define debug(...) printf(__VA_ARGS__)\n#else\n  #define debug(...) (void)0\n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n\nstring S;\nint K;\n\nconst int MAXL = 350;\nint dp[MAXL][MAXL][MAXL];\n\nint f(int l, int r, int k) {\n  if (dp[l][r][k] >= 0)\n    return dp[l][r][k];\n  if (l > r)\n    return dp[l][r][k] = 0;\n  if (l == r)\n    return dp[l][r][k] = 1;\n  int &res = dp[l][r][k];\n  res = max(f(l, r - 1, k), f(l + 1, r, k));\n  if (S[l] == S[r])\n    res = max(res, f(l + 1, r - 1, k) + 2);\n  if (k > 0)\n    res = max(res, f(l + 1, r - 1, k - 1) + 2);\n  debug(\"%d, %d, %d - %d\\n\", l, r, k, res);\n  return res;\n}\n\nint main() {\n  cin >> S >> K;\n  memset(dp, -1, sizeof(dp));\n  cout << f(0, SZ(S) - 1, K) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nstring s,t;\nint dp[310][310][310] = {};\nint main(){\n\tint i,j,l,n,k;\n\tcin >> s >> k; n = s.size();\n\tfor(i=0;i<n;i++){\n\t\tt.push_back(s[n - 1 - i]);\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++){\n\t\t\tfor(l=0;l<=k;l++){\n\t\t\t\tif(s[i - 1]==t[j - 1]){\n\t\t\t\t\tdp[i][j][l] = dp[i - 1][j - 1][l] + 1;\n\t\t\t\t}else{\n\t\t\t\t\tint x = max(dp[i - 1][j][l],dp[i][j - 1][l]);\n\t\t\t\t\tif(l>0) x = max(x,dp[i - 1][j - 1][l - 1] + 1);\n\t\t\t\t\tdp[i][j][l] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(i=0;i<n;i++){\n\t\tans = max(ans,2*dp[i][n - i][k]);\n\t\tans = max(ans,2*dp[i][n - 1 - i][k] + 1);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<map>\n#include<deque>\n#include<functional>\n#include<ctime>\n#include<cassert>\n#include<cstring>\n#include<unordered_map>\nusing namespace std;\n\n#define sz(x) (int)(x.size())\n#define fi(a,b) for(int i=a;i<=b;++i)\n#define fj(a,b) for(int j=a;j<=b;++j)\n#define fo(a,b) for(int o=a;o<=b;++o)\n#define fdi(a,b) for(int i=a;i>=b;--i)\n#define fdj(a,b) for(int j=a;j>=b;--j)\n#define fdo(a,b) for(int o=a;o>=b;--o)\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef double ld;\ntypedef vector<int> vi;\n\ntemplate<class T> bool uin(T &a, T b){ return (a > b ? a = b, true : false); }\ntemplate<class T> bool uax(T &a, T b){ return (a < b ? a = b, true : false); }\n\n/////////////////////////////////\n\nint const MAXN = 341;\n\nint d[MAXN][MAXN][MAXN];\nchar s[MAXN];\nint k;\nint n;\nint ans;\n\nint rec(int l, int r, int k) {\n\tif (l > r) {\n\t\treturn 0;\n\t}\n\tif (l == r) {\n\t\treturn 1;\n\t}\n\tif (d[l][r][k] != -1) {\n\t\treturn d[l][r][k];\n\t}\n\tint res = 0;\n\tif (k) {\n\t\tuax(res, 2 + rec(l + 1, r - 1, k - 1));\n\t}\n\tif (s[l] == s[r]) {\n\t\tuax(res, 2 + rec(l + 1, r - 1, k));\n\t}\n\tuax(res, rec(l + 1, r, k));\n\tuax(res, rec(l, r - 1, k));\n\td[l][r][k] = res;\n\treturn res;\n}\n\nvoid solve(){\n\tmemset(d, 255, sizeof(d));\n\tn = strlen(s);\n\tans = rec(0, n - 1, k);\t  \n}\n\nint main(){\n#ifdef LOCAL\n\tfreopen(\"input.txt\",\"r\",stdin);\n//\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tscanf(\"%s\", s);\n\tscanf(\"%d\", &k);\t\n\tsolve();\t\t\n\tprintf(\"%d\\n\", ans);\n\t\n#ifdef LOCAL\n\tfprintf(stderr, \"ELAPSED TIME: %.3lf\\n\", (ld) clock() / CLOCKS_PER_SEC);\n#endif\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=305;\nint f[N][N][N],n,K;char s[N];\nint main(){\n // freopen(\"input.txt\",\"r\",stdin);\n  scanf(\"%s%d\",s+1,&K);n=strlen(s+1);\n  for(int i=1;i<=n;i++)\n      for(int k=0;k<=K;k++)f[i][i][k]=1;\n  for(int len=2;len<=n;len++){\n      for(int i=1;i+len-1<=n;i++){\n          int j=i+len-1;\n          for(int k=0;k<=K;k++){\n              f[i][j][k]=max(f[i+1][j][k],f[i][j-1][k]);\n              if(s[i]==s[j])f[i][j][k]=max(f[i][j][k],f[i+1][j-1][k]+2);\n              if(k)f[i][j][k]=max(f[i][j][k],f[i+1][j-1][k-1]+2);\n          }\n      }\n  }\n  cout<<f[1][n][K]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define vec vector\n#define ALL(x) (x).begin(), (x).end()\n\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair< int, int > pii;\ntypedef pair< long long, long long > pll;\n\nconst int inf = 1e9;\nconst ll inf64 = 1e18;\n\nint main() {\n\n#ifdef debug\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n\n    string s;\n    int k;\n\n    cin >> s >> k;\n\n    int n = (int)s.size();\n\n    vec< vec< vec< int > > > dp(n, vec< vec< int > >(n, vec< int >(k + 1, -inf)));\n\n    for(int l = n - 1;l >= 0;l--) {\n        for(int r = l;r < n;r++) {\n            if(l == r) {\n                dp[l][r][0] = 1;\n                if(k > 0) dp[l][r][1] = 1;\n                continue;\n            }\n            for(int q = 0;q <= k;q++) {\n                dp[l][r][q] = max(dp[l + 1][r][q], dp[l][r - 1][q]);\n                if(q) dp[l][r][q] = max(dp[l][r][q], dp[l][r][q - 1]);\n                int add = !(s[l] == s[r]);\n                if(q >= add) {\n                    dp[l][r][q] = max(dp[l][r][q], dp[l + 1][r - 1][q - add] + 2);\n                }\n            }\n        }\n    }\n\n    cout << dp[0][n - 1][k] << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,K;\nchar S[310],T[310];\nint dp[310][310][310] = {0};\nint ans = 0;\n\nint main()\n{\n    scanf(\"%s %d\",S + 1,&K);\n\n    N = strlen(S + 1);\n    if(N == 1)\n    {\n        printf(\"1\\n\");\n        return 0;\n    }\n    if(N == 2)\n    {\n        if(K || S[1] == S[2])printf(\"2\\n\");\n        else printf(\"1\\n\");\n        return 0;\n    }\n    for(int i = 1; i <= N; i++)T[i] = S[i];\n    reverse(T + 1,T + 1 + N);\n\n    for(int i = 0; i <= K; i++)\n    {\n        for(int j = 1; j <= N; j++)\n        {\n            for(int k = 1; k <= N; k++)\n            {\n                dp[j][k][i] = max(dp[j - 1][k][i],dp[j][k - 1][i]);\n                if(S[j] == T[k])dp[j][k][i] = max(dp[j][k][i],dp[j - 1][k - 1][i] + 1);\n                if(i != 0)dp[j][k][i] = max(dp[j][k][i],dp[j - 1][k - 1][i - 1] + 1);\n                if(j + k == N)ans = max(ans,dp[j][k][i] * 2);\n                if(j + k == N - 1)ans = max(ans,dp[j][k][i] * 2 + 1);\n            }\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\nusing namespace std;\ntypedef long long LL;\nconst int N = 305;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\ntemplate <typename T> inline void cmax(T &x, T y) {\n    if (x < y) x = y;\n}\n\nchar s[N];\nint n, K;\nint dp[N][N][N];\n\nvoid init() {\n    scanf(\"%s\", s + 1);\n    n = strlen(s + 1);\n    read(K);\n}\n\nvoid solve() {\n    for (int i = 1; i <= n; ++i) {\n        for (int k = 0; k <= K; ++k) {\n            dp[i][i][k] = 1;\n        }\n    }\n    for (int i = 1; i < n; ++i) {\n        for (int l = 1, r; (r = l + i) <= n; ++l) {\n            for (int k = 0; k <= K; ++k) {\n                cmax(dp[l][r][k], dp[l + 1][r][k]);\n                cmax(dp[l][r][k], dp[l][r - 1][k]);\n                if (s[l] == s[r]) {\n                    cmax(dp[l][r][k], dp[l + 1][r - 1][k] + 2);\n                } else if (k > 0) {\n                    cmax(dp[l][r][k], dp[l + 1][r - 1][k - 1] + 2);\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for (int k = 0; k <= K; ++k) {\n        cmax(ans, dp[1][n][k]);\n    }\n    printf(\"%d\", ans);\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n#define pb push_back\n#define mp make_pair\nint dp[301][301][601];\nint main()\n{\n    int i,j;\n    string a;\n    int k;\n    cin>>a;\n    cin>>k;\n    int n=a.size();\n    if(k>=(n/2))\n            {cout<<n<<endl;\n             return 0;\n            }\n            int z=1;\n    for(z=0;z<=2*k;z++)\n  {\n\n    for(i=1;i<=n;i++)\n    {\n        for(j=n;j>=1;j--)\n        {\n          int o=n-j+1;\n\n              if(i!=j)\n              {    if(z!=0)\n                      dp[i][o][z]=max(dp[i][o][z],dp[i][o][z-1]);\n                  if(a[i-1]==a[j-1])\n                     dp[i][o][z]=max(dp[i][o][z],1+dp[i-1][o-1][z]);\n                  else\n                  {\n                      if(z!=0)\n                      dp[i][o][z]=max(dp[i][o][z],dp[i-1][o-1][z-1]+1);\n\n                      dp[i][o][z]=max(dp[i][o][z],max(dp[i-1][o][z],dp[i][o-1][z]));\n\n                  }\n\n\n              }\n              else{\n                 if(k!=0)\n                      dp[i][o][k]=dp[i][o][k-1];\n                 dp[i][o][z]=max(dp[i][o][z],1+dp[i-1][o-1][z]);\n\n\n                }\n\n\n        }\n\n\n\n\n    }\n\n\n\n\n\n  }\n  int ans=0;\n  for(z=0;z<=2*k;z++)\n    for(i=1;i<=n;i++)\n        for(j=1;j<=n;j++)\n    {\n        int o=(int)((dp[i][j][z]));\n        ans=max(ans,o);\n    }\n\n    cout<<ans<<endl;\nreturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef long double ld;\ntypedef vector<ld> vd;\ntypedef bool bl;\ntypedef vector<bl> vb;\ntypedef unordered_map<ll,unordered_map<ll,ll>> graph;\n\nconst ll e5 = 1 << 20;\nconst ll mod = 1000000007;\nconst ll e3 = 1 << 13;\nconst ll INF = 1ll << 60;\n\nstring s;\nstring r;\nll t;\nll dp[302][302][302];\nll ans;\n\nint main(){\n  cin >> s;\n  cin >> t;\n  r = s;\n  reverse(r.begin(),r.end());\n  // cerr << r << endl;\n  // cerr << s << endl;\n  for(ll i = 0;i < s.size();i++){\n    for(ll j = 0;j < s.size();j++){\n      for(ll k = 0;k <= t;k++){\n        if(s[i] == r[j]){\n          dp[i+1][j+1][k] = max(dp[i+1][j+1][k],dp[i][j][k]+1);\n        }else{\n          dp[i+1][j+1][k+1] = max(dp[i+1][j+1][k+1],dp[i][j][k]+1);\n        }\n        dp[i+1][j][k] = max(dp[i+1][j][k],dp[i][j][k]);\n        dp[i][j+1][k] = max(dp[i][j+1][k],dp[i][j][k]);\n      }\n    }\n  }\n  // cerr << s.size() << endl;\n  // for(ll k = 0;k <= t;k++){\n  //   for(ll i = 0;i <= s.size();i++){\n  //     for(ll j = 0;j <= s.size();j++){\n  //       cerr << dp[i][j][k] << \" \";\n  //     }\n  //     cerr << endl;\n  //   }\n  //   cerr << endl;\n  //   cerr << endl;\n  // }\n\n  for(ll i = 0;i < s.size();i++){\n    for(ll k = 0;k <= t;k++){\n      ans = max(ans,dp[i][s.size()-i-1][k]*2+1);\n    }\n  }\n  for(ll i = 1;i < s.size();i++){\n    for(ll k = 0;k <= t;k++){\n      ans = max(ans,dp[i][s.size()-i-1][k]*2);\n    }\n  }\n  cout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n//const ll mod = 1000000007;\n//const ll mod = 998244353;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18;\nconst ld EPS = 1e-10;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\nint dp[305][305][305];\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(25);\n\n  string s;\n  int k;\n  cin >> s >> k;\n\n  int n = s.length();\n  rep(i, n) {\n    dp[i][i][k] = 1;\n    if (i < n - 1) {\n      dp[i][i + 1][k] = 1 + (s[i] == s[i + 1]);\n      if (k) dp[i][i + 1][k - 1] = 2;\n    }\n  }\n  FOR(i, 1, n + 1) {\n    rep(l, n - i + 1) {\n      int r = l + i - 1;\n      rep(c, k + 1) {\n        if (l) chmax(dp[l - 1][r][c], dp[l][r][c]);\n        if (r < n - 1) chmax(dp[l][r + 1][c], dp[l][r][c]);\n        if (l && r < n - 1) {\n          if (dp[l][r][k]) {\n            chmax(dp[l - 1][r + 1][c], dp[l][r][c] + 2 * (s[l - 1] == s[r + 1]));\n          }\n          else {\n            chmax(dp[l - 1][r + 1][c], 1 + (s[l - 1] == s[r + 1]));\n          }\n          if (c) chmax(dp[l - 1][r + 1][c - 1], dp[l][r][c] + 2);\n        }\n      }\n    }\n  }\n  int ans = 0;\n  rep(i, k + 1) chmax(ans, dp[0][n - 1][i]);\n  cout << ans << '\\n';\n\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define all(a) a.begin(),a.end()\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){x=x>y?y:x;}\ntemplate<class T> inline void gmax(T &x,const T &y){x=x<y?y:x;}\ntemplate<class T> inline bool Gmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<class T> inline bool Gmax(T &x,const T &y){return x<y?x=y,1:0;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=305,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,K,ans,dp[N][N][N];\nchar s[N];\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"input.txt\",\"r\",stdin));\n#endif\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tscanf(\"%d\",&K);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tfor(int k=0;k<=K;k++){\n\t\t\t\tdp[i][j][k]=max(dp[i-1][j][k],dp[i][j-1][k]);\n\t\t\t\tif(k) gmax(dp[i][j][k],dp[i][j][k-1]);\n\t\t\t\tif(s[i]==s[n-j+1]) gmax(dp[i][j][k],dp[i-1][j-1][k]+1); else if(k) gmax(dp[i][j][k],dp[i-1][j-1][k-1]+1);\n\t\t\t}\n\tfor(int i=1;i<=n;i++){\n\t\tgmax(ans,dp[i][n-i][K]*2);\n\t\tgmax(ans,dp[i-1][n-i][K]*2+1);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint64_t dp[310][310][310];\nstring s;int64_t K;\nint main(){\ncin>>s>>K;\n  int64_t N=s.size();\n  for(int i=0;i<N;i++)\n    dp[i][i][0]=1;\n  for(int i=0;i<N-1;i++)\n    if(s.at(i)==s.at(i+1))\n      dp[i][i+1][0]=2;\n  else\n    dp[i][i+1][0]=1;\n  for(int j=2;j<=N-1;j++)\n    for(int i=0;i<N-j;i++){\n    if(s.at(i)==s.at(i+j))\n      dp[i][i+j][0]=2+dp[i+1][i+j-1][0];\n      else\n        dp[i][i+j][0]=max(dp[i+1][i+j][0],dp[i][i+j-1][0]);\n    }for(int i=0;i<N-1;i++)\n      dp[i][i+1][1]=2;\n  for(int k=1;k<=K;k++)\n      for(int j=2;j<=N-1;j++)\n        for(int i=0;i<N-j;i++){\n        if(s.at(i)==s.at(i+j))\n          dp[i][i+j][k]=2+dp[i+1][i+j-1][k];\n          else\ndp[i][i+j][k]=max(max(2+dp[i+1][i+j-1][k-1],dp[i][i+j-1][k]),dp[i+1][i+j][k]);\n          \n        }cout<<dp[0][N-1][K]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<stack>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<cstring>\n#include<complex>\n#include<bitset>\n#include<iostream>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> Q;\ntypedef complex<double> C;\n#define cx real()\n#define cy imag()\nconst ll INF = 1LL << 60;\nconst double DINF = 1e30;\nconst ll mod = 1000000007;\nconst ll dx[4] = {1, 0, -1, 0};\nconst ll dy[4] = {0, -1, 0, 1};\nconst C I = C(0, 1);\nconst double EPS = 1e-10;\nconst ll NCK_MAX = 510000;\n\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y) {\n  if (b == 0) {\n    x = 1, y = 0; return a;\n  }\n  ll q = a/b, g = extgcd(b, a - q*b, x, y);\n  ll z = x - q * y;\n  x = y;\n  y = z;\n  return g;\n}\n\nll invmod (ll a, ll m) { // a^-1 mod m\n  ll x, y;\n  extgcd(a, m, x, y);\n  x %= m;\n  if (x < 0) x += m;\n  return x;\n}\n\nll *fac, *finv, *inv;\n\nvoid nCk_init(ll mod) {\n  fac = new ll[NCK_MAX];\n  finv = new ll[NCK_MAX];\n  inv = new ll[NCK_MAX];\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (ll i = 2; i < NCK_MAX; i++) {\n    fac[i] = fac[i-1] * i % mod;\n    inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n    finv[i] = finv[i-1] * inv[i] % mod;\n  }\n}\n\nll nCk(ll n, ll k, ll mod) {\n  if (fac == NULL) nCk_init(mod);\n  if (n < k) return 0;\n  if (n < 0 || k < 0) return 0;\n  return fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\ntemplate <typename T>\nclass Zip {\n  vector<T> d;\n  bool flag;\n  void init() {\n    sort(d.begin(), d.end());\n    d.erase(unique(d.begin(), d.end()), d.end());\n    flag = false;\n  }\npublic:\n  Zip() {\n    flag = false;\n  }\n  void add(T x) {\n    d.push_back(x);\n    flag = true;\n  }\n  ll getNum(T x) {\n    if (flag) init();\n    return lower_bound(d.begin(), d.end(), x) - d.begin();\n  }\n  ll size() {\n    if (flag) init();\n    return (ll)d.size();\n  }\n};\n\nclass UnionFind {\n  vector<ll> par, rank; // par > 0: number, par < 0: -par\npublic:\n  UnionFind(ll n) : par(n, 1), rank(n, 0) {}\n  ll getSize(ll x) {\n    return par[find(x)];\n  }\n  ll find(ll x) {\n    if (par[x] > 0) return x;\n    return -(par[x] = -find(-par[x]));\n  }\n  void merge(ll x, ll y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (rank[x] < rank[y]) {\n      par[y] += par[x];\n      par[x] = -y;\n    } else {\n      par[x] += par[y];\n      par[y] = -x;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n  }\n  bool isSame(ll x, ll y) {\n    return find(x) == find(y);\n  }\n};\n\n\ntemplate <typename T>\nclass SegmentTree {\n  ll n;\n  vector<T> node;\n  function<T(T, T)> fun, fun2;\n  bool customChange;\n  T outValue, initValue;\npublic:\n  void init(ll num, function<T(T, T)> resultFunction, T init, T out, function<T(T, T)> changeFunction = NULL) {\n    // changeFunction: (input, beforevalue) => newvalue\n    fun = resultFunction;\n    fun2 = changeFunction;\n    customChange = changeFunction != NULL;\n    n = 1;\n    while (n < num) n *= 2;\n    node.resize(2 * n - 1);\n    fill(node.begin(), node.end(), init);\n    outValue = out;\n    initValue = init;\n  }\n  void valueChange(ll num, T value) {\n    num += n-1;\n    if (customChange) node[num] = fun2(value, node[num]);\n    else node[num] = value;\n    while (num > 0) num = (num - 1) / 2, node[num] = fun(node[num * 2 + 1], node[num * 2 + 2]);\n  }\n  T rangeQuery(ll a, ll b, ll l = 0, ll r = -1, ll k = 0) { // [a, b)\n    if (r == -1) r = n;\n    if (a <= l && r <= b) return node[k];\n    if (b <= l || r <= a) return outValue;\n    ll mid = (l + r) / 2;\n    return fun(rangeQuery(a, b, l, mid, 2*k+1), rangeQuery(a, b, mid, r, 2*k+2));\n  }\n};\n\ntemplate <typename T>\nclass Graph {\n  struct edge { ll to; T cost; };\n  struct edge_data { ll from, to; T cost; };\n\n  ll v;\n  vector<vector<edge>> e, re;\n  vector<edge_data> ed;\n  vector<bool> used;\n  vector<ll> vs, cmp;\n  bool isDirected, isMinasEdge;\npublic:\n  Graph(ll _v, bool _isDirected = true, ll range_add = 0) {\n    // range_add 0:no / 1:in / 2:out / 3:in+out\n    //_v++;\n    v = _v, isDirected = _isDirected; isMinasEdge = false;\n    e.resize(v), re.resize(v);\n  }\n  void add_edge(ll s, ll t, T cost = 1) {\n    e[s].push_back((edge){t, cost});\n    if (!isDirected) e[t].push_back((edge){s, cost});\n    else re[t].push_back((edge){s, cost});\n    ed.push_back((edge_data){s, t, cost});\n    if (cost < 0) isMinasEdge = true;\n  }\n  vector<T> dijkstra(ll s) {\n    vector<T> d(v, INF);\n    d[s] = 0;\n    auto edge_cmp = [](const edge& a, const edge& b) { return a.cost > b.cost; };\n    priority_queue<edge, vector<edge>, decltype(edge_cmp)> pq(edge_cmp);\n    pq.push((edge){s, 0});\n    while (!pq.empty()) {\n      edge temp = pq.top(); pq.pop();\n      if (d[temp.to] < temp.cost) continue;\n      for (const edge& next : e[temp.to]) {\n        T cost = temp.cost + next.cost;\n        if (d[next.to] > cost) {\n          d[next.to] = cost;\n          pq.push((edge){next.to, cost});\n        }\n      }\n    }\n    return d;\n  }\n  vector<T> bellmanford(ll s) {\n    vector<T> d(v, INF);\n    d[s] = 0;\n    for (ll i = 0; i < v; i++) {\n      for (const edge_data& temp : ed) {\n        if (d[temp.from] != INF && d[temp.to] > d[temp.from] + temp.cost) d[temp.to] = d[temp.from] + temp.cost;\n        if (!isDirected && d[temp.to] != INF && d[temp.from] > d[temp.to] + temp.cost) d[temp.from] = d[temp.to] + temp.cost;\n      }\n    }\n    for (ll i = 0; i < v; i++) {\n      for (const edge_data& temp : ed) {\n        if (d[temp.from] != INF && d[temp.to] > d[temp.from] + temp.cost) d[temp.to] = -INF;\n        if (!isDirected && d[temp.to] != INF && d[temp.from] > d[temp.to] + temp.cost) d[temp.from] = -INF;\n      }\n    }\n    return d;\n  }\n  vector<T> shortest_path(ll s) {\n    if (isMinasEdge) return bellmanford(s);\n    else return dijkstra(s);\n  }\n  T kruskal() {\n    // if (isDirected)\n    UnionFind uf(v);\n    auto edge_data_cmp = [](const edge_data& a, const edge_data& b) { return a.cost < b.cost; };\n    sort(ed.begin(), ed.end(), edge_data_cmp);\n    T ans = 0;\n    for (const edge_data& temp : ed) {\n      if (uf.isSame(temp.from, temp.to)) continue;\n      uf.merge(temp.from, temp.to);\n      ans += temp.cost;\n    }\n    return ans;\n  }\n  void scc_dfs(ll s) {\n    used[s] = true;\n    for (const edge& i : e[s]) if (!used[i.to]) scc_dfs(i.to);\n    vs.push_back(s);\n  }\n  void scc_rdfs(ll s, ll k) {\n    used[s] = true;\n    cmp[s] = k;\n    for (const edge& i : re[s]) if (!used[i.to]) scc_rdfs(i.to, k);\n  }\n  vector<ll> scc() {\n    used.resize(v);\n    fill(used.begin(), used.end(), false);\n    cmp.resize(v);\n    vs.clear();\n    for (ll i = 0; i < v; i++) if (!used[i]) scc_dfs(i);\n    used.resize(v);\n    fill(used.begin(), used.end(), false);\n    ll k = 0;\n    for (ll i = vs.size() - 1; i >= 0; i--) if (!used[vs[i]]) scc_rdfs(vs[i], k++);\n    return cmp;\n  }\n};\n\nclass RollingHash {\n  int base;\n  vector<__int128> hash;\n  vector<__int128> pw;\n  const __int128 hashmod = (1ull << 61) - 1;\npublic:\n  RollingHash(string s, int base = 10007) : base(base), hash(s.length()+1, 0), pw(s.length()+1, 1) {\n    for (int i = 0; i < (int)s.length(); i++) {\n      hash[i+1] = (hash[i] * base + s[i]) % hashmod;\n      pw[i+1] = pw[i] * base % hashmod;\n    }\n  }\n  ll get(ll a, ll b) { // [a, b)\n    __int128 tmp = hashmod + hash[b] - hash[a] * pw[b-a] % hashmod;\n    if (tmp >= hashmod) tmp -= hashmod;\n    return (ll)tmp;\n  }\n};\n\nll n, k, dp[302][302][302], ans;\nchar s[301];\n\nll solve(ll x, ll y, ll num) {\n  if (dp[x][y][num] != -1) return dp[x][y][num];\n  if (x == 0 || y == n+1) return 0;\n  ll ans = max(solve(x-1, y, num), solve(x, y+1, num));\n  if (s[x-1] == s[y-1]) ans = max(ans, solve(x-1, y+1, num)+(x==y?1:2));\n  if (num > 0) ans = max({ans, solve(x-1, y, num-1)+(x==y?1:2), solve(x, y+1, num-1)+(x==y?1:2)});\n  return dp[x][y][num] = ans;\n}\n\nint main() {\n  scanf(\"%s\", s);\n  scanf(\"%lld\", &k);\n  while (s[n] != 0) n++;\n  for (ll i = 0; i <= n+1; i++) {\n    for (ll j = 0; j <= n+1; j++) {\n      for (ll k = 0; k <= n+1; k++) {\n        dp[i][j][k] = -1;\n      }\n    }\n  }\n  for (ll i = 1; i < n; i++) ans = max(ans, solve(i, i, k));\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define MAXN 100005\n#define eps 1e-8\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nchar s[305];\nint K,dp[305][305][305],N;\nvoid update(int &x,int y) {\n    x = max(x,y);\n}\nvoid Solve() {\n    scanf(\"%s\",s + 1);\n    read(K);\n    N = strlen(s + 1);\n    for(int i = 1 ; i <= N ; ++i) \n\tfor(int j = 0 ; j <= K ; ++j)\n\t    dp[i][i][j] = 1;\n    for(int d = 2 ; d <= N ; ++d) {\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t    int j = i + d - 1;\n\t    if(j > N) break;\n\t    for(int k = 0 ; k <= K ; ++k) {\n\t\tif(k) update(dp[i][j][k],dp[i][j][k - 1]);\n\t\tupdate(dp[i][j][k],dp[i + 1][j][k]);\n\t\tupdate(dp[i][j][k],dp[i][j - 1][k]);\n\t\tif(s[i] == s[j]) update(dp[i][j][k],dp[i + 1][j - 1][k] + 2);\n\t\telse if(k) update(dp[i][j][k],dp[i + 1][j - 1][k - 1] + 2);\n\t    }\n\t}\n    }\n    out(dp[1][N][K]);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define lsb(x) (x & (-x))\n#define ll long long\n#define ull unsigned long long\n// 217\n// 44\n\nusing namespace std;\n\nconst int MAXN = 300;\n\nchar str[MAXN + 1];\n\nint dp[MAXN + 1][MAXN + 1][MAXN + 1];\n\nint main() {\n    //ifstream cin(\"A.in\");\n    //ofstream cout(\"A.out\");\n    int i, j, n, k;\n    ios::sync_with_stdio(false);\n    cin >> str + 1;\n    cin >> k;\n    n = strlen(str + 1);\n    for(i = 1; i <= n; i++) {\n        for(j = 0; j <= k; j++) {\n            dp[i][i][j] = 1;\n        }\n    }\n    for(i = 1; i < n; i++) {\n        if(str[i] == str[i + 1]) {\n            dp[i][i + 1][0] = 1;\n        }\n        else {\n            dp[i][i + 1][1] = 1;\n        }\n        for(j = 1; j <= k; j++) {\n            dp[i][i + 1][j] = max(dp[i][i + 1][j], dp[i][i + 1][j - 1]);\n        }\n    }\n    for(int len = 1; len < n; len++) {\n        for(int l = 1; l + len <= n; l++) {\n            int r = l + len;\n            for(i = 0; i <= k; i++) {\n                dp[l][r][i] = max(dp[l][r - 1][i], dp[l + 1][r][i]);\n                if(i >= (str[l] != str[r])) {\n                    dp[l][r][i] = max(dp[l][r][i], dp[l + 1][r - 1][i - (str[l] != str[r])] + 2);\n                }\n            }\n            for(i = 1; i <= k; i++) {\n                dp[l][r][i] = max(dp[l][r][i], dp[l][r][i - 1]);\n            }\n        }\n    }\n    cout << dp[1][n][k];\n    //cin.close();\n    //cout.close();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sz(a)((int)(a).size())\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);iostream::sync_with_stdio(0);cout<<fixed<<setprecision(10);cerr<<fixed<<setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());const int D=4,dx[]={+1,0,-1,0},dy[]={0,+1,0,-1};\nconst int N=303;\nshort dp[N][N][N+N];\nint32_t main(){\n    string s;int k;\n    cin>>s>>k;\n    int n=sz(s);\n    string t=s+\"#\";\n    reverse(t.begin(), t.end());\n    s=\"#\"+s;\n    int ans=0;\n    k+=k;\n    for(int i=1;i<=n;++i){\n        for(int j=1;j<=n;++j){\n            for(int c=0;c<=k;++c){\n                dp[i][j][c]=max(dp[i-1][j][c],dp[i][j-1][c]);\n                if(s[i]==t[j])upx(dp[i][j][c],dp[i-1][j-1][c]+1);\n                else if(c)upx(dp[i][j][c],dp[i-1][j-1][c-1]+1);\n            }\n        }\n    }\n    forn(i,k+1)upx(ans,dp[n][n][i]);\n    cout<<ans<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//by Judge\n#include<bits/stdc++.h>\n#define Rg register\n#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(Rg int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(Rg int i=head[u],v=e[i].to;i;v=e[i=e[i].nxt].to)\n#define open(S) freopen(S\".in\",\"r\",stdin),freopen(S\".out\",\"w\",stdout)\n#define ll long long\nusing namespace std;\nconst int M=305;\ntypedef int arr[M];\n#ifndef Judge\n#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\n#endif\nchar buf[1<<21],*p1=buf,*p2=buf;\ntemplate<class T>inline T Max(T x,T y){return x>y?x:y;}\ntemplate<class T>inline bool cmax(T& x,T y){return x<y?x=y,1:0;}\ninline ll read(){ ll x=0,f=1; char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;\n} inline void sread(string& s){ char c=getchar();\n\tfor(;!isalpha(c);c=getchar()); s=\" \";\n\tfor(;isalpha(c);c=getchar()) s+=c;\n} int n,k,f[M][M][M]; string s;\nint dfs(int l,int r,int k){ int &res=f[l][r][k];\n\tif(l==r) return res=1; if(l>r||res) return res;\n\tres=Max(dfs(l+1,r,k),dfs(l,r-1,k));\n\tif(s[l]==s[r]) cmax(res,dfs(l+1,r-1,k)+2);\n\telse if(k) cmax(res,dfs(l+1,r-1,k-1)+2); return res;\n}\nint main(){\n\tsread(s),n=s.length()-1,k=read();\n\treturn !printf(\"%d\\n\",dfs(1,n,k));\n}"
  },
  {
    "language": "C++",
    "code": "//Be Name Khoda\n/*\ntane ezafami sharifast be jane ezafamiat\nna hamin lebase zibast neshane ezafamiat\nagar ezafami be cheshmasto dahano goosho bini\nche miane naghshe divaro miane ezafamiat\nkhoro khabo khashmo shahvat shaghab asto jahlo zolmat\nhayavan khabar nezafarezaf ze jahane ezafamiat\nbe haghighat ezafami bash vagarna morgh bashezaf\nke hami sokhan begooyezaf be zabane ezafamiat\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\ntemplate <typename T> using ordered_set =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \ntypedef long long LL;\ntypedef LL ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vll;\ntypedef stringstream strs;\n \n \n#define X first\n#define Y second\n#define PB push_back\n#define For(i,a,b) for (int i=a;i<b;i++)\n#define Ford(i,a,b) for (int i=a;i>=b;i--)\n#define smax(a,b) a=max(a,b)\n#define smin(a,b) a=min(a,b)\n#define SZ(a) ((ll)a.size())\n#define ER(a) cout << #a << ' ' << a << endl\n#define LB(a,n,x) (lower_bound(a,(a)+(n),x)-(a))\n#define RET(x) { cout << x; exit(0); }\n#define MKP make_pair\n#define RETD(x) { cout << fixed << setprecision(15) << x; }\n#define GEI(x) scanf(\"%d\",&x)\n#define GEL(x) scanf(\"%lld\",&x)\n#define ALL(x) x.begin(),x.end()\nconst ll M=200+10,LG=26,SM=105,inf=1e9+5;\nll mod=1e9+7;\n\nstr s;\nll k;\nll dp[M][M],dp2[M][M];\n\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin >> s >> k;\n    ll n=SZ(s);\n    str t=s;\n    reverse(ALL(t));\n    {\n        For(i,1,n+1) For(j,1,n+1)\n        {\n            smax(dp[i][j],max(dp[i][j-1],dp[i-1][j]));\n            if (s[i-1]==t[j-1])\n                smax(dp[i][j],dp[i-1][j-1]+1);\n        }\n        //atcodergr\n        //tsetnocdn\n    }\n    RET(min(dp[n][n]+2*k,n));\n}\n"
  },
  {
    "language": "C++",
    "code": "// #includes {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define LET(x,a) __typeof(a) x(a)\n//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n\n#define EXIST(e,s) ((s).find(e)!=(s).end())\n\n#define RESET(a) memset((a),0,sizeof(a))\n#define SET(a) memset((a),-1,sizeof(a))\n#define PB push_back\n#define DEC(it,command) __typeof(command) it=command\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define debug_v(x) cerr << #x << \" = [\";REP(__ind,(x).size()){cerr << (x)[__ind] << \", \";}cerr << \"] (L\" << __LINE__ << \")\" << endl;\n\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\n\ntypedef long long Int;\ntypedef unsigned long long uInt;\ntypedef long double rn;\n\ntemplate<class T>\nT inf(){\n\treturn numeric_limits<T>::has_infinity?numeric_limits<T>::infinity():(numeric_limits<T>::max()/2);\n}\n\ntypedef pair<int,int> pii;\n\n/*\n#ifdef MYDEBUG\n#include\"debug.h\"\n#include\"print.h\"\n#endif\n*/\n// }}}\n\n//{{{ io\nFILE *file_in=stdin,*file_out=stdout;\n#define fin normal_in\n#define fout normal_out\n//const char fname[]=\"\";\n//FILE *fin=fopen(fname,\"r\"),*fout=fopen(fname,\"w\");\n#ifdef __MINGW32__\n#define LLD \"%I64d\"\n#define LLU \"%I64u\"\n#else\n#define LLD \"%lld\"\n#define LLU \"%llu\"\n#endif\nstruct NORMAL_IN{\n\tbool cnt;\n\tNORMAL_IN():cnt(true){}\n\toperator int() const {return cnt;}\n#define endl \"\\n\"\n\tNORMAL_IN& operator>>(int &n){cnt=fscanf(file_in,\"%d\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(unsigned int &n){cnt=fscanf(file_in,\"%u\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(long long &n){cnt=fscanf(file_in,LLD,&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(unsigned long long &n){cnt=fscanf(file_in,LLU,&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(double &n){cnt=fscanf(file_in,\"%lf\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(long double &n){cnt=fscanf(file_in,\"%Lf\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(char *c){cnt=fscanf(file_in,\"%s\",c)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(string &s){\n\t\ts.clear();\n\t\tfor(bool r=false;;){\n\t\t\tconst char c=getchar();\n\t\t\tif(c==EOF){ cnt=false; break;}\n\t\t\tconst int t=isspace(c);\n\t\t\tif(!r and !t)r=true;\n\t\t\tif(r){\n\t\t\t\tif(!t)s.push_back(c);\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\t\tNORMAL_IN& operator>>(vector<T> &v){\n\t\t\tint n;fscanf(file_in,\"%d\",&n);\n\t\t\tREP(i,n){\n\t\t\t\tT t;*this>>t;\n\t\t\t\tv.push_back(t);\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n} normal_in;\n\nstruct NORMAL_OUT{\n\tNORMAL_OUT& operator<<(const int &n){fprintf(file_out,\"%d\",n);return *this;}\n\tNORMAL_OUT& operator<<(const unsigned int &n){fprintf(file_out,\"%u\",n);return *this;}\n\tNORMAL_OUT& operator<<(const long long &n){fprintf(file_out,LLD,n);return *this;}\n\tNORMAL_OUT& operator<<(const unsigned long long &n){fprintf(file_out,LLU,n);return *this;}\n\tNORMAL_OUT& operator<<(const double &n){fprintf(file_out,\"%lf\",n);return *this;}\n\tNORMAL_OUT& operator<<(const long double &n){fprintf(file_out,\"%Lf\",n);return *this;}\n\tNORMAL_OUT& operator<<(const char c[]){fprintf(file_out,\"%s\",c);return *this;}\n\tNORMAL_OUT& operator<<(const string &s){fprintf(file_out,\"%s\",s.c_str());return *this;}\n} normal_out;\nstruct ERR_OUT{\n\ttemplate<class T>\n\t\tERR_OUT& operator<<(const T &a){\n\t\t\tcerr<<\"\\x1b[7m\"<<a<<\"\\x1b[m\";\n\t\t\treturn *this;\n\t\t}\n} ferr;\n//}}}\n\n//int dp[305][305][305];\n\nnamespace std {\n\ttemplate<>\n\t\tstruct hash<vector<int>> {\n\t\t\tsize_t operator()(const vector<int> &v) const {\n\t\t\t\tsize_t h = 0;\n\t\t\t\tfor(auto &&p:v){\n\t\t\t\t\th*=743;\n\t\t\t\t\th+=p;\n\t\t\t\t}\n\t\t\t\treturn h;\n\t\t\t}\n\t\t};\n}\n\nvoid solve(string S, Int K){\n//\tmemset(dp,-1,sizeof(dp));\n\tunordered_map<vector<int>,int> dp; \n\tfunction<int(int,int,int)> calc = [&](int l, int r, int k){\n\t\tauto it = dp.find({l,r,k});\n\t\tif(it==dp.end()){\n\t\t\tit = dp.insert({{l,r,k},-1}).first;\n\t\t}\n\t\tint &ret = it->second;\n\t\tif(ret!=-1)return ret;\n\t\tif(r<l)return ret = 0;\n\t\tif(l==r)return ret = 1;\n\t\tint ans;\n\t\tans = max(calc(l+1,r,k),calc(l,r-1,k));\n\t\tif(S[l]==S[r])ans = max(ans,calc(l+1,r-1,k)+2);\n\t\telse{\n\t\t\tif(k>0)ans = max(ans,calc(l+1,r-1,k-1)+2);\n\t\t}\n\t\treturn ret = ans;\n\t};\n\tfout<<calc(0,S.size()-1,K)<<endl;\n}\n\nint main(){\t\n\tstring S;\n\tInt K;\n\tfin >> S;\n\tfin >> K;\n\tsolve(S, K);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<ctime>\nusing namespace std;\ntypedef long long ll;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define PI pair<int,int>\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){\n    int x = 0; char ch = gc(); bool positive = 1;\n    for (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n    for (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n    return positive ? x : -x;\n}\ninline void write(int a){\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n    }\n    write(a); puts(\"\");\n}\nconst int N=305;\nint dp[N][N][N],n,m;\nchar s[N];\nint main(){\n    scanf(\"%s\",s+1); m=read(); n=strlen(s+1);\n    memset(dp,0x3f,sizeof(dp));\n    for(int i=0;i<=n+1;i++){\n        memset(dp[i][i],0,sizeof(dp[i][i]));\n        if(i)memset(dp[i][i-1],0,sizeof(dp[i][i-1]));\n    }\n    for(int o=2;o<=n;o++)\n        for(int i=1;i<=n;i++){\n            int j=i+o-1;\n            if (j>n)\n                break;\n            for(int k=0;k<=m;k++){\n                if (k)\n                    dp[i][j][k]=dp[i+1][j-1][k-1];\n                if (s[i]==s[j])\n                    dp[i][j][k]=min(dp[i][j][k],dp[i+1][j-1][k]);\n                dp[i][j][k]=min(dp[i][j][k],dp[i+1][j][k]+1);\n                dp[i][j][k]=min(dp[i][j][k],dp[i][j-1][k]+1);\n            }\n        }\n    cout<<n-dp[1][n][m]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MAX = 300 + 47;\nint dp[MAX][MAX][MAX];\nstring s;\n\nvoid Max(int& key, int val)\n{\n\tkey = max(key, val);\n}\n\nint solve(int n, int cnt)\n{\n\tFOR(i, 0, n)\n\t{\n\t\tdp[i][i][0] = 1;\n\t}\n\n\tFOR(len, 2, n + 1)\n\t{\n\t\tFOR(i, 0, n)\n\t\t{\n\t\t\tint j = i + len - 1;\n\t\t\tif (j >= n) break;\n\t\t\tFOR(k, 0, cnt + 1)\n\t\t\t{\n\t\t\t\tif (s[i] == s[j])\n\t\t\t\t{\n\t\t\t\t\tMax(dp[i][j][k], dp[i + 1][j - 1][k] + 2);\n\t\t\t\t}\n\n\t\t\t\tif (k) Max(dp[i][j][k], dp[i + 1][j - 1][k - 1] + 2);\n\t\t\t\tMax(dp[i][j][k], dp[i][j - 1][k]);\n\t\t\t\tMax(dp[i][j][k], dp[i + 1][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\n//\tFOR(i, 0, n)\n//\t{\n//\t\tFOR(j, i, n)\n//\t\t{\n//\t\t\tFOR(k, 0, cnt + 1)\n//\t\t\t{\n//\t\t\t\tcout << i << \" \" << j << \" \" << k << \": \" << dp[i][j][k] << endl;\n//\t\t\t}\n//\t\t}\n//\t}\n\tint ans = 0;\n\tFOR(k, 0, cnt + 1) Max(ans, dp[0][n - 1][k]);\n\treturn ans;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\tios::sync_with_stdio(false); cin.tie(0);\n\tint k, n;\n\tcin >> s >> k;\n\tn = SZ(s);\n\tint ans = solve(n, k);\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define vec vector\n#define ALL(x) (x).begin(), (x).end()\n\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair< int, int > pii;\ntypedef pair< long long, long long > pll;\n\nconst int inf = 1e9;\nconst ll inf64 = 1e18;\n\nint main() {\n\n#ifdef debug\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n\n    string s;\n    int k;\n\n    cin >> s >> k;\n\n    int n = (int)s.size();\n\n    vec< vec< vec< int > > > dp(n, vec< vec< int > >(n, vec< int >(k + 1, 0)));\n\n    for(int l = n - 1;l >= 0;l--) {\n        for(int r = l;r < n;r++) {\n            if(l == r) {\n                for(int q = 0;q <= k;q++) {\n                    dp[l][r][q] = 1;\n                }\n                continue;\n            }\n            for(int q = 0;q <= k;q++) {\n                dp[l][r][q] = max(dp[l + 1][r][q], dp[l][r - 1][q]);\n                if(q) dp[l][r][q] = max(dp[l][r][q], dp[l][r][q - 1]);\n                int add = !(s[l] == s[r]);\n                if(q >= add) {\n                    dp[l][r][q] = max(dp[l][r][q], dp[l + 1][r - 1][q - add] + 2);\n                }\n            }\n        }\n    }\n\n    cout << dp[0][n - 1][k] << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  string S;\n  int K;\n  cin >> S >> K;\n  vector<vector<int>> dp(S.size()+1, vector<int>(S.size()+1));\n  for(auto i = 0; i < S.size(); ++i) dp[i][i+1] = 1;\n  for(auto k = 0; k <= K; ++k) {\n    auto dup = dp;\n    for(auto w = 2; w <= S.size(); ++w) for(auto l = 0; l+w <= S.size(); ++l) {\n      auto r = l + w;\n      dp[l][r] = max({dp[l][r], dp[l+1][r], dp[l][r-1]});\n      if(k)            dp[l][r] = max(dp[l][r], 2 + dup[l+1][r-1]);\n      if(S[l]==S[r-1]) dp[l][r] = max(dp[l][r], 2 + dp[l+1][r-1]);\n    }\n  }\n  cout << dp[0][S.size()] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c<'0' || c>'9'));\n\tif(c=='-') c=getchar(),f=-1;\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tll f=1;\n\twhile((c=getchar())!='-' && (c<'0' || c>'9'));\n\tif(c=='-') c=getchar(),f=-1;\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=300+10;\ninline bool chkmax(int &x,int y){return (y>x)?(x=y,1):0;}\nchar s[maxn];\nint dp[maxn][maxn][maxn];\nint main(){\n\tscanf(\"%s\",s+1);\n\tint m=read(),n=strlen(s+1);\n\tREP(i,1,n)\n\t\tDREP(j,n,i)\n\t\t\tREP(k,0,m){\n\t\t\t\tdp[i][j][k]=max(dp[i-1][j][k],dp[i][j+1][k]);\n\t\t\t\tif(s[i]==s[j]) chkmax(dp[i][j][k],dp[i-1][j+1][k]+1);\n\t\t\t\telse if(k>0) chkmax(dp[i][j][k],dp[i-1][j+1][k-1]+1);\n\t\t\t}\n\tint ans=0;\n\tREP(i,1,n){\n\t\tchkmax(ans,dp[i][i][m]*2-1);\n\t\tREP(j,i+1,n) chkmax(ans,dp[i][j][m]*2);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include <boost/multiprecision/cpp_int.hpp>\n// using i128 = boost::multiprecision::int128_t;\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = vector<int>;\nusing Vll = vector<ll>;\nusing Vld = vector<ld>;\nusing Vbo = vector<bool>;\nusing VV = vector<V>;\nusing VVll = vector<Vll>;\nusing VVld = vector<Vld>;\nusing VVbo = vector<Vbo>;\nusing VVV = vector<VV>;\nusing VVVll = vector<VVll>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\n#define rep2(i, m, n) for(int i=int(m); i<int(n); ++i)\n#define drep2(i, m, n) for(int i=int(m)-1; i>=int(n); --i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) a.begin(), a.end()\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << \" \"; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int Log2(ll x) { int k; for (k = 0; x > 0; ++k) x >>= 1; return k; } // number of binary digits\nconst int INF  = 1<<30;\nconst ll INFll = 1ll<<62;\nconst ld EPS   = 1e-10;\nconst ld PI    = acos(-1.0);\nconst int MOD  = int(1e9)+7;\n// const int MOD  = 998244353;\n\n\nint main() {\n  string s; cin >> s;\n  int K; cin >> K;\n  int n = s.size();\n\n  VVV dp(K+2, VV(n+1, V(n+1)));\n\n  rep(k, K+1) rep(i, n) rep(j, n) {\n    chmax(dp[k][i+1][j+1], dp[k][i+1][j]);\n    chmax(dp[k][i+1][j+1], dp[k][i][j+1]);\n    chmax(dp[k][i+1][j+1], dp[k][i][j] + (s[i] == s[n-1-j]));\n    chmax(dp[k+1][i+1][j+1], dp[k][i+1][j]);\n    chmax(dp[k+1][i+1][j+1], dp[k][i][j+1]);\n    chmax(dp[k+1][i+1][j+1], dp[k][i][j] + 1);\n  }\n  int ans = 0;\n  rep(i, n+1) chmax(ans, dp[K][i][n-i]);\n  ans = ans*2 + 1;\n  \n  // rep(i, n+1) cout << dp[0][i] << \"\\n\";\n\n  // cout << \"\\n\";\n\n  // VV a(n+1, V(n+1));\n  // rep(i, n) rep(j, n) if (s[i] == s[n-1-j]) ++a[i][j];\n  // rep(i, n+1) cout << a[i] << \"\\n\";\n\n  \n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nstatic const int INF = 1000000000;\nstatic int dp[301][301];\n\nint solve(int k, string a, string b){\n\tif(a.size() > b.size()){ swap(a, b); }\n\tconst int n = a.size(), m = b.size();\n\tk = min(k, n);\n\tfor(int i = 0; i <= n; ++i){\n\t\tfor(int j = 0; j <= m; ++j){ dp[i][j] = -INF; }\n\t}\n\tdp[0][0] = 0;\n\tfor(int i = 0; i <= n; ++i){\n\t\tfor(int j = 0; j <= m; ++j){\n\t\t\tconst int cur = dp[i][j];\n\t\t\tif(i < n && j < m){\n\t\t\t\tif(a[i] == b[j]){ dp[i + 1][j + 1] = max(dp[i + 1][j + 1], cur + 1); }\n\t\t\t\tdp[i + 1][j + 1] = max(dp[i + 1][j + 1], cur);\n\t\t\t}\n\t\t\tif(i < n){ dp[i + 1][j] = max(dp[i + 1][j], cur); }\n\t\t\tif(j < m){ dp[i][j + 1] = max(dp[i][j + 1], cur); }\n\t\t}\n\t}\n\tconst int answer = min(dp[n][m] + k, n);\n\treturn answer;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint k;\n\tstring s;\n\tcin >> s >> k;\n\tconst int n = s.size();\n\tint answer = 0;\n\tfor(int i = 1; i + 1 < n; ++i){\n\t\tstring a = s.substr(0, i), b = s.substr(i);\n\t\treverse(b.begin(), b.end());\n\t\tanswer = max(answer, 2 * solve(k, a, b));\n\t}\n\tfor(int i = 0; i < n; ++i){\n\t\tstring a = s.substr(0, i), b = s.substr(i + 1);\n\t\treverse(b.begin(), b.end());\n\t\tanswer = max(answer, 1 + 2 * solve(k, a, b));\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvoid chkmax(int &x,int y){\n\tx=x>y?x:y;\n}\nint dp[310][310][310];\nint n,m;\nchar str[310];\nint main(){\n//\tfreopen(\"D.in\",\"r\",stdin);\n\tscanf(\"%s\",str+1);\n\tn=strlen(str+1);\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<n;i++){\n\t\tif(str[i]==str[i+1])\n\t\t\tdp[i][i+1][0]=2;\n\t\telse{\n\t\t\tdp[i][i+1][0]=0;\n\t\t\tdp[i][i+1][1]=2;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tdp[i][i][0]=1;\n\tfor(int k=0;k<=m;k++){\n\t\tfor(int l=0;l<n;l++){\n\t\t\tfor(int i=1;i+l<=n;i++){\n\t\t\t\tint j=i+l;\n\t\t\t\tchkmax(dp[i][j][k+1],dp[i][j][k]);\n\t\t\t\tif(i>1)\n\t\t\t\t\tchkmax(dp[i-1][j][k],dp[i][j][k]);\n\t\t\t\tif(j<n)\n\t\t\t\t\tchkmax(dp[i][j+1][k],dp[i][j][k]);\n\t\t\t\tif(i>1&&j<n){\n\t\t\t\t\tif(str[i-1]==str[j+1])\n\t\t\t\t\t\tchkmax(dp[i-1][j+1][k],dp[i][j][k]+2);\n\t\t\t\t\telse\n\t\t\t\t\t\tchkmax(dp[i-1][j+1][k+1],dp[i][j][k]+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[1][n][m]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nint main(void) {\n  string S;\n  ll N, K;\n  cin >> S >> K;\n  N = S.length();\n\n  ll dp[N][N][K + 1];\n  REP(l, 0, N) REP(r, l, N) REP(k, 0, K + 1) dp[l][r][k] = 0;\n  REP(l, 0, N) dp[l][l][k] = 1;\n  REP(l, 0, N - 1) if(S[l] == S[l + 1]) dp[l][l + 1][0] = 2;\n  REP(s, 0, N) REP(l, 0, N - s) {\n    ll r = l + s;\n    REP(k, 0, K + 1) {\n      if(l + 1 <= r - 1 && S[l] == S[r]) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k] + 2);\n      if(l + 1 <= r) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r][k]);\n      if(l <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l][r - 1][k]);\n      if(k > 0 && l + 1 <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k - 1] + 2);\n      if(k > 0) dp[l][r][k] = max(dp[l][r][k], dp[l][r][k - 1]);\n    }\n  }\n  cout << dp[0][N - 1][K] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  char s[310];\n  scanf(\"%s\",s);\n  int n=strlen(s);\n  int k;\n  scanf(\"%d\",&k);\n  static int dp[310][310][310];\n  int ans=0;\n  for(int i=0;i<=n;i++){\n    for(int j=0;j<=n;j++){\n      for(int l=0;l<=k;l++){\n\tif(i==0||j==0){\n\t  dp[i][j][l]=0;\n\t  continue;\n\t}\n\tdp[i][j][l]=max(dp[i-1][j][l],dp[i][j-1][l]);\n\tif(s[i-1]==s[n-j]){\n\t  dp[i][j][l]=max(dp[i][j][l],dp[i-1][j-1][l]+1);\n\t}\n\tif(l>0){\n\t  dp[i][j][l]=max(dp[i][j][l],dp[i-1][j-1][l-1]+2);\n\t}\n\tans=max(ans,dp[i][j][l]);\n      }\n    }\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int N = 3e2+5;\nint n, m, f[N][N][N], ans; char s[N];\nint main()\n{\n    scanf(\"%s\", s+1), n = strlen(s+1), m = read();\n    for(int i = 1; i <= n; ++i) f[0][i][i] = 1;\n    for(int k = 0; k <= m; ++k)\n        for(int l = 2; l <= n; ++l)\n            for(int i = 1, j = l; j <= n; ++i, ++j)\n            {\n                f[k][i][j] = max(f[k][i+1][j], f[k][i][j-1]);\n                if(s[i] == s[j]) f[k][i][j] = max(f[k][i][j], f[k][i+1][j-1]+2);\n                if(k) f[k][i][j] = max(f[k][i][j], f[k-1][i+1][j-1]+2);\n            }\n    for(int i = 0; i <= m; ++i) ans = max(ans, f[i][1][n]);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 305\nusing namespace std;\nchar c[N];\nint i,j,k,l,s,n,m,ans,f[N][N][N];\nint main() {\n\tscanf(\"%s\",c+1);\n\tn=strlen(c+1);\n\tscanf(\"%d\",&m);\n\tm*=2;\n\tm=min(m,n);\n\tfor (i=1;i<=n+1;i++)\n\tfor (j=n;j>=0;j--)\n\tfor (k=0;k<=m;k++) {\n\t\tif (i<=n&&j) {\n\t\t\tif (c[i]==c[j]) f[i+1][j-1][k]=max(f[i+1][j-1][k],f[i][j][k]+1);\n\t\t\telse if (k<m) f[i+1][j-1][k+1]=max(f[i+1][j-1][k+1],f[i][j][k]+1);\n\t\t}\n\t\tf[i+1][j][k]=max(f[i+1][j][k],f[i][j][k]);\n\t\tif (j) f[i][j-1][k]=max(f[i][j-1][k],f[i][j][k]);\n\t}\n\tfor (i=0;i<=m;i++) ans=max(ans,f[n+1][0][i]);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\n#define DUMP(x) cout<<#x<<\":\"<<(x)<<endl\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint dp[310][310][310];\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  string S;\n  cin >> S;\n  int K;\n  cin >> K;\n  int N = SZ(S);\n\n  REP(i,N) dp[i][i+1][0] = 1;\n  for(int len=2;len<=N;++len){\n\tfor(int l=0,r=len;r<=N;++l,++r){\n\t  REP(k,K+1){\n\t\tif(S[l] == S[r-1])\n\t\t  maxi(dp[l][r][k], dp[l+1][r-1][k] + 2);\n\t\tmaxi(dp[l][r][k], max(dp[l+1][r][k], dp[l][r-1][k]));\n\t\tmaxi(dp[l][r][k+1], dp[l+1][r-1][k] + 2);\n\t  }\n\t}\n  }\n\n  int ans = 0;\n  REP(i,K+1) maxi(ans, dp[0][N][i]);\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#define int ll\n//#define char ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(4) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int N = 333;\nshort dp[N][N][N];\n\n\nvoid smain() {\n\n\n    string s;\n    cin >> s;\n    int k;\n    cin >> k;\n    int n = s.size();\n    string t = s;\n    reverse(ALL(t));\n\n\n    fori (i, N) {\n        fori (j, N) {\n            fori (k, N) {\n                dp[i][j][k] = n + n;\n            }\n        }\n    }\n\n    dp[0][0][0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            for (int len = 0; len < n; ++len) if (dp[i][j][len] < n + n) {\n                inmin(dp[i + 1][j][len], dp[i][j][len]);\n                inmin(dp[i][j + 1][len], dp[i][j][len]);\n                if (s[i] == t[j])\n                    inmin(dp[i + 1][j + 1][len + 1], dp[i][j][len]);\n                else {\n                    inmin(dp[i + 1][j + 1][len + 1], (short)(dp[i][j][len] + 1));\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    fori (i, n + 1) {\n        fori (j, n + 1) {\n            fori (len, n + 1) {\n                if (dp[i][j][len] <= k * 2) {\n                    inmax(ans, len);\n                }\n            }\n        }\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x)  cerr << #x << \" = \" << x << endl\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ld PI = 3.14159265359;\n\nconst ll MOD = (ll) 998244353ll;\nconst ll MAXN = (ll) 3e2 + 10;\nconst ll INF = (ll) 2242545357980376863;\nconst ld EPS = (ld) 1e-8;\n\nll dp[2][MAXN][MAXN];\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tstr s;\n\tcin >> s;\n\tll n = s.size();\n\ts = '!' + s;\n\tll k;\n\tcin >> k;\n\tll ii, t, ans = 1;\n\tfor(int i = 1; i <= n; i++){\n\t\tii = i & 1;\n\t\t//debug(i);\n\t\tmemset(dp[ii], 0, sizeof dp[ii]);\n\t\tfor(int j = n; j > i; j--){\n\t\t\tif(s[i] == s[j]) t = 2;\n\t\t\telse t = 0;\n\t\t\t\n\t\t\tdp[ii][j][0] = max({dp[1 - ii][j][0], dp[1 - ii][j + 1][0] + t, dp[ii][j + 1][0]});\n\t\t\tfor(int l = 1; l <= k; l++){\n\t\t\t\tdp[ii][j][l] = max({dp[1 - ii][j][l], dp[1 - ii][j + 1][l] + t, dp[ii][j + 1][l]});\n\t\t\t\tdp[ii][j][l] = max(dp[ii][j][l], dp[1 - ii][j + 1][l - 1] + 2);\n\t\t\t\tans = max(ans, dp[ii][j][l] + (i + 1 < j ? 1 : 0));\n\t\t\t}\n\t\t\tans = max(ans, dp[ii][j][0] + (i + 1 < j ? 1 : 0));\n\t\t}\n\t}\n\tcout << ans;\n\treturn 0;\n}\n\n\n/*\n\n                                 ____              ,----..               ,----..\n   ,---,                       ,'  , `.           /   /   \\             /   /   \\\n  '  .' \\                   ,-+-,.' _ |          /   .     :           /   .     :\n /  ;    '.              ,-+-. ;   , ||         .   /   ;.  \\         .   /   ;.  \\\n:  :       \\            ,--.'|'   |  ;|        .   ;   /  ` ;        .   ;   /  ` ;\n:  |   /\\   \\          |   |  ,', |  ':        ;   |  ; \\ ; |        ;   |  ; \\ ; |\n|  :  ' ;.   :         |   | /  | |  ||        |   :  | ; | '        |   :  | ; | '\n|  |  ;/  \\   \\        '   | :  | :  |,        .   |  ' ' ' :        .   |  ' ' ' :\n'  :  | \\  \\ ,'        ;   . |  ; |--'         '   ;  \\; /  |        '   ;  \\; /  |\n|  |  '  '--'          |   : |  | ,             \\   \\  ',  /          \\   \\  ',  /\n|  :  :                |   : '  |/               ;   :    /            ;   :    /\n|  | ,'                ;   | |`-'                 \\   \\ .'              \\   \\ .'\n`--''                  |   ;/                      `---`                 `---`\n                       '---'\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 300;\n\nchar ch[N+5]; int f[N+5][N+5][N+5], k, n;\n\nvoid work() {\n    scanf(\"%s%d\", ch+1, &k); n = strlen(ch+1);\n    for (int i = 1; i <= n; i++) f[i][i][0] = 1;\n    for (int l = 1; l <= n; l++)\n    for (int i = 1; i+l <= n; i++)\n        for (int p = 0, j = i+l; p <= k; p++) {\n        f[i][j][p] = max(f[i+1][j][p], f[i][j-1][p]);\n        if (ch[i] == ch[j]) f[i][j][p] = max(f[i][j][p], f[i+1][j-1][p]+2);\n        if (p) f[i][j][p] = max(f[i][j][p], f[i+1][j-1][p-1]+2);\n        }\n    int ans = 0;\n    for (int i = 0; i <= k; i++) ans = max(ans, f[1][n][i]);\n    printf(\"%d\\n\", ans);\n}\nint main() {work(); return 0; }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\nstring s; int w;\nint mi[302][302][309];\nchar sa[333];\nint main()\n{\n\tcin>>s>>w; int ans=0,p=s.size();\n\tfor(int i=0;i<p;++i) sa[i+1]=s[i];\n\tmemset(mi,127/3,sizeof mi);\n\tfor(int i=1;i<=p;++i)\n\t\tmi[i][i-1][0]=0;\n\tfor(int i=p;i>=1;--i)\n\t{\n\t\tfor(int j=i;j<=p;++j)\n\t\t{\n\t\t\tfor(int k=0;k<=p;++k)\n\t\t\t{\n\t\t\t\tif(i==j&&k<=1)\n\t\t\t\t\tmi[i][j][k]=min(mi[i][j][k],0);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmi[i][j][k]=min(mi[i][j][k],mi[i][j-1][k]);\n\t\t\t\t\tmi[i][j][k]=min(mi[i][j][k],mi[i+1][j][k]);\n\t\t\t\t\tmi[i][j][k+2]=min(mi[i][j][k+2],mi[i+1][j-1][k]+(sa[i]!=sa[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int k=p;k>=0;--k)\n\t\tif(mi[1][p][k]<=w)\n\t\t{\n\t\t\tprintf(\"%d\\n\",k);\n\t\t\treturn 0;\n\t\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long I64;\n\nconst double EPS = 1e-6;\nconst double PI  = acos(-1);\nconst int NMAX = 300;\n\nshort int d[NMAX+2][NMAX+2][NMAX+2];\n\nint max(int a, int b, int c)\n{\n    return max(max(a,b), c);\n}\n\nint max2(int a, int b, int c)\n{\n    return max(max(a,b), c);\n}\n\nint max(short int a, short int b, short int c)\n{\n    return max(max(a,b), c);\n}\n\nint main()\n{\n    int N, K;\n    string str;\n    cin >> str;\n    N =  str.size();\n    if( N == 1 ) {\n        cout << \"1\\n\";\n        return 0;\n    }\n    str = \"#\" + str + \"$\";\n    cin >> K;\n    int Ans=  0;\n    for( int i = 1;  i <= N;  ++i ) {\n        for( int j = N;  i < j;  --j ) {\n            d[i][j][0] = max2( d[i - 1][j][0], d[i][j + 1][0], d[i - 1][j + 1][0] + (str[i] == str[j]) );\n            Ans = max( Ans, d[i][j][0] * 2 + (i + 2 == j) );\n            Ans = max( Ans, d[i][i + 1][0] * 2 );\n            for( int k = 1;  k <= K;  ++k ) {\n                if( str[i] == str[j] )\n                    d[i][j][k] = max2( d[i - 1][j][k], d[i][j + 1][k], d[i - 1][j + 1][k]+1 );\n                else\n                    d[i][j][k] = max2( d[i - 1][j][k],\n                                      d[i][j + 1][k],\n                                      d[i - 1][j + 1][k - 1] + 1 );\n                Ans = max(Ans, d[i][j][k] * 2 + (i + 2 == j));\n            }\n        }\n    }\n    cout << Ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define whole(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bit(n) (1LL<<(n))\n// functions\ntemplate <typename T> void unique(T& c){c.erase(std::unique(c.begin(), c.end()), c.end());}\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1000000007;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(nullptr); cout << fixed << setprecision(20);}\n} fast_io_;\n\nint dp[310][310][310];\n\nint main(int argc, char const* argv[])\n{\n  string s; cin >> s;\n  int k; cin >> k;\n  int n = sz(s);\n  if(n == 1){\n    cout << 1 << endl;\n    return 0;\n  }\n  rep(i, n){\n    for(int j = n - 1; j > i; j--){\n      rep(l, k + 1){\n        chmax(dp[i+1][j+1][l], dp[i][j+1][l]);\n        chmax(dp[i+1][j+1][l], dp[i+1][j+2][l]);\n        if(s[i] == s[j])chmax(dp[i+1][j+1][l], 1 + dp[i][j+2][l]);\n        else chmax(dp[i+1][j+1][l], dp[i][j+2][l]);\n        if(s[i] != s[j] && l > 0){\n          chmax(dp[i+1][j+1][l], 1 + dp[i][j+2][l-1]);\n        }\n      }\n    }\n  }\n  int res = 0;\n  for(int i = 0; i < n - 1; i++){\n    for(int l = 0; l <= k; l++){\n      chmax(res, dp[i+1][i+2][l] * 2);\n      chmax(res, 1 + dp[i][i+2][l] * 2);\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for((i)=1;(i)<=(n);(i)++)\nusing namespace std;\nstring st;\nint dp[305][305][305],n,m,i,j,k;\nint main(){\n\tcin>>st>>m;n=st.length();st=\" \"+st;\n\trep(i,n) dp[i][i][0]=1;\n\tfor(i=n;i>=1;i--){\n\t\tfor(j=i+1;j<=n;j++){\n\t\t\tfor(k=0;k<=m;k++){\n\t\t\t\tdp[i][j][k]=max(dp[i+1][j][k],dp[i][j-1][k]);\n\t\t\t\tif(st[i]==st[j]) dp[i][j][k]=max(dp[i][j][k],dp[i+1][j-1][k]+2);\n\t\t\t\tif(k) dp[i][j][k]=max(dp[i][j][k],dp[i+1][j-1][k-1]+2);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(k=0;k<=m;k++) ans=max(ans,dp[1][n][k]);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\nstring s; int w;\nint mi[333][333][333];\nchar sa[333],sb[333];\nint main()\n{\n\tcin>>s>>w; int ans=0,p=s.size();\n\tfor(int i=0;i<p;++i) sa[i+1]=s[i];\n\treverse(s.begin(),s.end());\n\tfor(int i=0;i<p;++i) sb[i+1]=s[i];\n\tmemset(mi,127/3,sizeof mi);\n\tfor(int i=0;i<=p;++i)\n\t\tmi[0][i][0]=mi[i][0][0]=0;\n\tfor(int i=1;i<=p;++i)\n\t\tfor(int j=1;j<=p;++j)\n\t\t\tfor(int k=0;k<=p;++k)\n\t\t\t\tmi[i][j][k]=min(mi[i][j][k],mi[i][j-1][k]),\n\t\t\t\tmi[i][j][k]=min(mi[i][j][k],mi[i-1][j][k]),\n\t\t\t\tmi[i][j][k+1]=min(mi[i][j][k+1]\n\t\t\t\t,mi[i-1][j-1][k]+(sa[i]!=sb[j]));\n\tfor(int k=p;k>=0;--k)\n\t\tif(mi[p][p][k]<=w*2)\n\t\t{\n\t\t\tprintf(\"%d\\n\",k);\n\t\t\treturn 0;\n\t\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<iostream>\n#define max(a,b) (a>b?a:b)\nint dp[305][305][305],mk,len;\nchar a[305];\nint main(){\n\tscanf(\"%s%d\",a+1,&mk);\n\tlen=strlen(a+1);\n\tfor(int i=1;i<=len;i++){\n\t\tfor(int j=i;j>=1;j--){\n\t\t\tif(i==j){\n\t\t\t\tfor(int k=0;k<=mk;k++) dp[j][i][k]=1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(i-j==1){\n\t\t\t\tdp[j][i][0]=(a[i]==a[j]?2:1);\n\t\t\t\tfor(int k=1;k<=mk;k++) dp[j][i][k]=2;\n\t\t\t}\n\t\t\tfor(int k=0;k<=mk;k++)\n\t\t\t\tif(k){\n\t\t\t\t\tdp[j][i][k]=max(dp[j+1][i-1][k-1]+2,max(dp[j+1][i-1][k]+(a[i]==a[j])*2,max(dp[j+1][i][k],dp[j][i-1][k])));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[j][i][k]=max(dp[j+1][i-1][k]+(a[i]==a[j])*2,max(dp[j+1][i][k],dp[j][i-1][k]));\n\t\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[1][len][mk]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define reps(i,x,n) for(int i=x; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n#define X first\n#define Y second\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\nconst ll INF = 1e9+7;\n\n\nint dp[305][305][305];\nint main(){\n\t//ios_base::sync_with_stdio(false);\n\tint N, K;\n\tstring S;\n\n\tcin >> S >> K;\n\tN = S.length();\n\n\trep(k,K+1) rep(l,N) rrep(r,N) if( l <= r ){\n\t\tif( S[l] == S[r] ){\n\t\t\tchmax(dp[l+1][r][k], dp[l][r+1][k] + 1);\n\t\t}else{\n\t\t\tchmax(dp[l+1][r][k+1], dp[l][r+1][k] + 1);\n\t\t}\n\t\tchmax(dp[l][r][k]    , dp[l][r+1][k]);\n\t\tchmax(dp[l+1][r+1][k], dp[l][r+1][k]);\n\t}\n\t// rep(k,K+1){\n\t// \tcout << \"k = \" << k << endl;\n\t// \trep(l,N){\n\t// \t\trep(r,N) cout << dp[l][r][k] << \" \";\n\t// \t\tcout << endl;\n\t// \t}\n\t// }\n\n\tint ans = 0;\n\trep(k,K+1) rep(i,N) rep(j,2) chmax(ans, dp[i+1][i+j][k] * 2 - (j==0));\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int LL;\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& vec) {\n    out << \"[\";\n    for (int x : vec) out << x << \", \";\n    out << \"]\";\n    return out;\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n    #define dbg_var(x) clog << #x << \": \" << x << endl;\n#endif\n\nint ans[333][333][333];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    string s;\n    cin >> s;\n    int n = s.size();\n    int K; cin >> K;\n    \n    for(int i=0; i<n; i++) for(int k=0; k<=K; k++) ans[i][0][k] = 0;\n    for(int i=0; i+1<=n; i++) for(int k=0; k<=K; k++) ans[i][1][k] = 1;\n        \n    for(int l=2; l<=n; l++){\n        for(int i=0; i+l<=n; i++){\n            for(int k=0; k<=K; k++){\n                int r = -2;\n                if(s[i] == s[i+l-1]) r = ans[i+1][l-2][k];\n                if(k > 0) r = max(r, ans[i+1][l-2][k-1]);\n                ans[i][l][k] = max( max(ans[i][l-1][k], ans[i+1][l-1][k]), 2 + r );\n                //~ cerr << i << ' ' << l << ' ' << k << ' ' << ans[i][l][k] << endl;\n            }\n        }\n    }\n    //~ cerr << 0 << ' ' << n << ' ' << K << ' ' << ans[0][n][K] << endl;\n    cout << ans[0][n][K] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n);i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(a);i>=(int)(b);--i)\n#define ALL(a) (a).begin(),(a).end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\n\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\n\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n  if(a < b) {a = b; return true;}\n  return false;\n}\n\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n  if(a > b) {a = b; return true;}\n  return false;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  REP(i, SZ(v)) {\n    if(i) os << \" \";\n    os << v[i];\n  }\n  return os;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  string s; cin >> s;\n  int k; cin >> k;\n  string revs = s;\n  reverse(ALL(revs));\n  int n = SZ(s);\n  vector<vvi> dp(n+1, vvi(n+1, vi(k+1, 0)));\n  REP(i, n) {\n    REP(j, n) {\n      REP(l, k+1) {\n        if(s[i] == revs[j]) {\n          chmax(dp[i+1][j+1][l], dp[i][j][l] + 1);\n        } else {\n          chmax(dp[i+1][j+1][l], max(dp[i+1][j][l], dp[i][j+1][l]));\n          if(l != k) chmax(dp[i+1][j+1][l+1], dp[i][j][l] + 1);\n        }\n\n        if(i<n && n-1-j >= 0 && s[i] == s[n-1-j]) {\n          chmax(dp[i+1][j+1][k], dp[i][j][k] + 1);\n        }\n      }\n    }\n  }\n/*\n  REP(l, k+1) {\n    REP(i, n) {\n      REP(j, n) {\n        cout << dp[i][j][l] << \" \";\n      }\n      cout << endl;\n    }\n    cout << endl;\n  }\n  */\n\n  int ans = 0;\n  REP(l, k+1) {\n    REP(i, n+1) chmax(ans, dp[i][n-i][l] * 2);\n    REP(i, n) chmax(ans, dp[i][n-i-1][l] * 2 + 1);\n  }\n  cout << ans << endl;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint D[310][310][310], n, K;\nstring p;\n\nint main()\n{\n    int i, L, j, k;\n    cin >> p;\n    cin >> K;\n    for (i = 1; p[i]; i++);\n    n = i - 1;\n    for (L = 1; L <= n; L++) {\n        for (i = 1; i <= n - L + 1; i++) {\n            j = i + L - 1;\n            for (k = 0; k <= n; k++) {\n                D[i][j][k] = max(D[i][j][k],1);\n                D[i][j][k] = max(D[i][j][k], D[i][j - 1][k]);\n                D[i][j][k] = max(D[i][j][k], D[i + 1][j][k]);\n                if (L != 1) {\n                    if (p[i] == p[j]) D[i][j][k] = max(D[i][j][k], D[i + 1][j - 1][k] + 2);\n                    if (k)D[i][j][k] = max(D[i][j][k], D[i + 1][j - 1][k - 1] + 2);\n                }\n            }\n        }\n    }\n    cout << D[1][n][K] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * じょえチャンネル\n * 高評価・チャンネル登録よろしくおねがいします！\n * https://www.youtube.com/channel/UCRXsI3FL_kvaVL9zoolBfbQ\n */\n\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <memory>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <string.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n//#pragma GCC target(\"avx2\")\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n\n\n\n//here!!!\n// define int long long !!!!!\n\n#define int long long\n\n// define int long long !!!!!\n\n\n//#define mod 1000000007ll\nconstexpr int mod = 998244353ll;\n\nconstexpr double PI=3.141592653589793238462643383279;\n//constexpr double eps = DBL_EPSILON;\n\ntypedef long long ll;\n\n#ifdef int\n#define inf (int)(3e18)\n#else\n#define inf (int)(5e8)\n#endif\n\n#define intt long long\n#define itn long long\n#define innt long long\n#define P pair<long long,long long>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<=n;i++)\n#define rev_rep(i,n) for(int i=n-1;i>=0;i--)\n#define REV_REP(i,n) for(int i=n;i>=1;i--)\n\n#define ALL(v) v.begin(),v.end()\n\n#define smallpriority_queue(T) priority_queue<T,vector<T>,greater<T>>\n\n\nusing namespace std;\n\n//Library\n//モッドパウ\ninline int modpow(int x, int y, int m = mod) {\n    int res = 1;\n    while (y) {\n        if (y & 1) {\n            res *= x;\n            res %= m;\n        }\n        x = x * x % m;\n        y /= 2;\n    }\n    return res;\n}\n\nint mypow(int x, int y) {\n    int res = 1;\n    while (y) {\n        if (y % 2) {\n            res *= x;\n        }\n        x = x * x;\n        y /= 2;\n    }\n    return res;\n}\n//is the number (x) a prime number?\n//bool prime(int x) {\n//    if (!x || x == 1) {\n//        return false;\n//    }\n//    for (int i = 2; i * i <= x; i++) {\n//        if (!(x % i)) {\n//            return false;\n//        }\n//    }\n//    return true;\n//}\nbool prime(int x) {\n    if (!x || x == 1) {\n        return false;\n    }\n    if(x == 2){\n        return true;\n    }\n    if(!(x & 1)){\n        return false;\n    }\n    for (int i = 3; i * i <= x; i+=2) {\n        if (!(x % i)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n//saidai-kouyakusuu\ninline int gcd(int x, int y) {\n    if (!y) {\n        return x;\n    }\n    return gcd(y, x % y);\n}\n\n\n//number of keta\nint keta(int x) {\n    int ans = 0;\n    while (x) {\n        x /= 10;\n        ans++;\n    }\n    return ans;\n}\n\n//number of 2shinsuu keta\nint bitketa(int x) {\n    int ans = 0;\n    while (x) {\n        x >>= 1;\n        ans++;\n    }\n    return ans;\n}\n\n//sum of keta\nint ketasum(int x) {\n    int ans = 0;\n    while (x) {\n        ans += x % 10;\n        x /= 10;\n    }\n    return ans;\n}\n\ninline int lcm(int x, int y) {\n    int ans = x / gcd(x, y) * y;\n    return ans;\n}\nint twobeki(int x) {\n    int ans = 0;\n    while (1) {\n        if (!(x & 1)) {\n            ans++;\n            x >>= 1;\n        }\n        else {\n            break;\n        }\n    }\n    return ans;\n}\n\n\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n    if (lhs < rhs) {\n        lhs = rhs;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n    if (lhs > rhs) {\n        lhs = rhs;\n        return 1;\n    }\n    return 0;\n}\nvoid Yes(){\n    cout<<\"Yes\"<<endl;\n}\nvoid No(){\n    cout<<\"No\"<<endl;\n}\nvoid YES(){\n    cout<<\"YES\"<<endl;\n}\nvoid NO(){\n    cout<<\"NO\"<<endl;\n}\n\n\n#define fin(i) scanf(\"%lld\",&i)\n#define fout(i) printf(\"%lld\",i)\n#define fendl printf(\"\\n\")\n\nint kai(int x, int y) {\n    int res = 1;\n    for (int i = x - y + 1; i <= x; i++) {\n        res *= i; res %= mod;\n    }\n    return res;\n}\n\nint comb(int x, int y) {\n    if (y > x)return 0;\n    //    cout<<kai(x, y)<<' '<<modpow(kai(y, y), mod - 2)<<endl;\n    return kai(x, y) * modpow(kai(y, y), mod - 2) % mod;\n}\n//Library-End\n\n//入出力高速化時にはoff！！！！\n//#define vecin(v) for(int i=0;i<v.size();i++)scanf(\"%lld\",&v[i]);\n//#define vecout(v) {if(v.size())printf(\"%lld\",v[0]);for(int i=1;i<(int)v.size();i++)printf(\" %lld\",v[i]);printf(\"\\n\");}\n\n\n\ntemplate <class T>\nclass SegTree {\n    int n;\n    vector<T> node;\n    T def;\n    function<T(T,T)> operation;\n    function<T(T,T)> update;\n    \npublic:\n    SegTree(unsigned int _n, T _def, function<T(T, T)> _operation,\n            function<T(T, T)> _update)\n    : def(_def), operation(_operation), update(_update) {\n        n=1;\n        while (n < _n) {\n            n *= 2;\n        }\n        node = vector<T>(n * 2, def);\n    }\n    SegTree(vector<int>& initvec, function<T(T, T)> _operation,\n            function<T(T, T)> _update)\n    :  operation(_operation), update(_update) {\n        n=1;\n        while (n < initvec.size()) {\n            n *= 2;\n        }\n        node = vector<T>(n * 2, def);\n        for(int i=n;i<n+initvec.size();i++){\n            node[i]=initvec[i-n];\n        }\n        for(int i=n-1;i>=1;i--){\n            node[i]=operation(node[i*2],node[i*2+1]);\n        }\n    }\n    void change(int i,T x){\n        i+=n;\n        node[i]=update(node[i],x);\n        while (i>=1) {\n            i>>=1;\n            node[i]=operation(node[i*2],node[i*2+1]);\n        }\n    }\n    T query(int l, int r){\n        l+=n;\n        r+=n;\n        T rx=def,lx=def;\n        while(l<r){\n            if (l&1) {\n                lx=operation(lx,node[l]);\n                l++;\n            }\n            if (r&1) {\n                r--;\n                rx=operation(node[r],rx);\n            }\n            l>>=1; r>>=1;\n        }\n        return operation(lx,rx);\n    }\n    T operator [] (const int& x){\n        return node[x+n];\n    }\n    void fill(T x) {\n        std::fill(ALL(node), x);\n    }\n    void print() {\n        rep(i, n)std::cout << operator[](i) << \" \";\n        std::cout << std::endl;\n    }\n    T queryForALL(){\n        return node[1];\n    }\n};\n\n#define R_MIN ([](long long a, long long b) { return min(a, b); })\n#define R_MAX ([](long long a, long long b) { return max(a, b); })\n#define R_SUM ([](long long a, long long b) { return a + b; })\n\n#define NORMAL_UPDATE ([](long long a, long long b) { return b; })\n#define ADD_UPDATE ([](long long a, long long b) { return a + b; })\n#define MINUS_UPDATE ([](long long a, long long b) { return a - b; }\n\nclass Union_Find {\n    vector<int> par;\n    vector<int> ookisa;\n    \npublic:\n    Union_Find(int size) {\n        par = vector<int>(size);\n        ookisa=vector<int>(size);\n        for (int i = 0; i < size; i++) {\n            par[i] = i;\n            ookisa[i]=1;\n        }\n    }\n    \n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        return par[x] = find(par[x]);\n    }\n    \n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) {\n            return;\n        }\n        if (ookisa[x] < ookisa[y]) {\n            par[x] = y;\n            ookisa[y]+=ookisa[x];\n            ookisa[x]=0;\n        }\n        else {\n            par[y] = x;\n            ookisa[x]+=ookisa[y];\n            ookisa[y]=0;\n        }\n    }\n    int size(int i){\n        i=find(i);\n        return ookisa[i];\n    }\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n    \n};\n\nclass BIT {\n    vector<int> data;\n    int size=0;\npublic:\n    BIT(int _size){\n        data=vector<int>(_size+1);\n        size=_size;\n    }\n    void add(int i,int x){\n        while (i<=size) {\n            data[i]+=x;\n            i += i & -i;\n        }\n    }\n    int sum(int i){\n        assert(i<=size);\n        int s=0;\n        while(i>0){\n            s+=data[i];\n            i -= i & -i;\n        }\n        return s;\n    }\n    int lower_bound(int x){\n        if(x<=0){\n            return 0;\n        }else{\n            int i=0;int r=1;\n            while(r<size) r=r<<1;\n            for(int len=r;len>0;len=len>>1) {\n                if(i+len<size && data[i+len]<x){\n                    x-=data[i+len];\n                    i+=len;\n                }\n            }\n            return i+1;\n        }\n    }\n};\n\n//Union-Find-End\n\nint perm[2000005];\nvoid init_perm() {\n    perm[0] = 1;\n    REP(i, 2000004) {\n        perm[i] = perm[i - 1] * i % mod;\n    }\n}\n\nint nCk(int x, int y) {\n    if (y>x) {\n        return 0;\n    }\n    if (x<0) {\n        return 0;\n    }\n    return perm[x] * modpow(perm[x - y], mod - 2) % mod * modpow(perm[y], mod - 2) % mod;\n}\n\nstruct Dot {\n    double x;\n    double y;\n    Dot(double _x=0.0, double _y=0.0){\n        x=_x;\n        y=_y;\n    }\n};\n\nstruct Dot_i {\n    int x;\n    int y;\n    Dot_i(int _x=0, int _y=0){\n        x=_x;\n        y=_y;\n    }\n};\n\ndouble kyori(pair<int, int> f, pair<int, int> s) {\n    double ans = 0;\n    double t = fabs(f.first - s.first);\n    double y = fabs(f.second - s.second);\n    ans = sqrt(t * t + y * y);\n    return ans;\n}\n\ndouble kyori(Dot f, Dot s) {\n    double ans = 0;\n    double t = fabs(f.x - s.x);\n    double y = fabs(f.y - s.y);\n    ans = sqrt(t * t + y * y);\n    return ans;\n}\n\ninline bool stringmax(string& x,string& y){\n    if (x.size()!=y.size()) {\n        return x.size()<y.size();\n    }\n    return x<y;\n}\n\n//vector<int>  RollingHash(string &s, string& t){\n//    vector<int> ans;\n//    if(s.size()<t.size())return ans;\n//    __int128 h=0,hamod=0,ki=0,kim=0,hikaku=0,one=0;\n//    one=1;\n//    ki=1000000007ll;\n//    hamod=(one<<61)-1;\n//    kim=1;\n//    rep(i,t.size()){\n//        hikaku*=ki;\n//        h*=ki;\n//        kim*=ki;\n//        hikaku+=t[i];\n//        h+=s[i];\n//        hikaku%=hamod;\n//        h%=hamod;\n//        kim%=hamod;\n//    }\n//    rep(i,(int)s.size()-(int)t.size()){\n//        if (h==hikaku) {\n//            ans.emplace_back(i);\n//        }\n//        h*=ki;\n//        h%=hamod;\n//        h+=s[i+(int)t.size()];\n//        h%=hamod;\n//        h+=hamod;\n//        h-=s[i]*kim%hamod;\n//        h%=hamod;\n//    }\n//    if(h==hikaku)ans.emplace_back((int)s.size()-(int)t.size());\n//    return ans;\n//}\nstruct edge {\n    int to;\n    int length;\n    edge(int _to, int _length){\n        to=_to;\n        length=_length;\n    }\n};\nvector<int> djkstra(vector<vector<edge>> &road,int start){\n    vector<int> kyo(road.size(),inf);\n    smallpriority_queue(P) q;\n    q.push({0,start});\n    kyo[start]=0;\n    while (q.size()) {\n        int x=q.top().second;\n        itn now=q.top().first;\n        q.pop();\n        if (kyo[x]<now) {\n            continue;\n        }\n        for(auto&i:road[x]){\n            if (kyo[i.to]>now+i.length) {\n                kyo[i.to]=now+i.length;\n                q.push({kyo[i.to],i.to});\n            }\n        }\n    }\n    return kyo;\n}\n\ntemplate <class T>\nvoid change_to_unique(vector<T> &v){\n    std::sort(ALL(v));\n    auto k=unique(ALL(v));\n    if(k!=v.end())v.erase(k,v.end());\n}\n\ndouble kodo_dosuu(double r){\n    return 180.0*r/(double)PI;\n}\n\ndouble dosuu_kodo(double r){\n    return r*(double)PI/180.0;\n}\n\ndouble kakudo(Dot a,Dot b1,Dot b2){\n    double size1=kyori(a,b1),size2=kyori(a,b2);\n    double nai=(b1.x-a.x)*(b2.x-a.x)+(b1.y-a.y)*(b2.y-a.y);\n    nai/=size1*size2;\n    return kodo_dosuu(acos(nai));\n}\n\nstruct fraction {\n    int shi;\n    int bo;\n    fraction(int bunshi,int bunbo):bo(bunbo),shi(bunshi){\n        if(bunbo&&bunshi){\n            int g=gcd(bo, shi);\n            bo/=g;\n            shi/=g;\n        }\n    };\n    explicit inline operator double()const { return (double)shi/(double)bo; }\n    explicit inline operator long double()const { return (long double)shi/(long double)bo; }\n};\nbool operator < (const fraction& b1, const fraction& b2){\n    return b1.shi*b2.bo < b2.shi*b1.bo;\n}\nbool operator > (const fraction& b1, const fraction& b2){\n    return b1.shi*b2.bo > b2.shi*b1.bo;\n}\n\ntemplate <class T>\nvoid vecout(vector<T> &v){\n    if (v.size()) {\n        cout<<v[0];\n    }\n    REP(i,(int)v.size()-1){\n        cout<<' '<<v[i];\n    }\n    cout<<endl;\n}\n\ninline int zeronCk(int x,int y){\n    return nCk(y+x-1,x-1);\n}\n\ninline int modinv(int x, int MOD=mod){\n    return modpow(x, MOD-2);\n}\n\n//#define endl \"\\n\" //interactive の時に注意！！！\n//#define Endl \"\\n\" //interactive の時に注意！！！\n#define cinn cin\n#define printd cout<<fixed<<setprecision(10)\n#define rrep(i,f,s) for(int i=f;i<s;i++)\n#define RREP(i,f,s) for(int i=f;i<=s;i++)\n#define REV_RREP(i,f,s) for(int i=s;i>=f;i--)\n#define hen_rep(i,l,step) for(int i=0;i<l;i+=step)\n#define HEN_REP(i,l,step) for(int i=1;i<=l;i+=step)\n\n\nstring s,ss;\nint k,memo[304][304][304];\nint solve(int l, int r, int k){\n    if(memo[l][r][k])return memo[l][r][k];\n    int ret=0;\n    if (l==r) {\n        ret=1;\n    }else if(l+1==r){\n        if (s[l]==s[r]||k) {\n            ret=2;\n        }else{\n            ret=1;\n        }\n    }else{\n        chmax(ret, solve(l,r-1,k));\n        chmax(ret, solve(l+1,r,k));\n        if(s[l]==s[r])chmax(ret, solve(l+1,r-1,k)+2);\n        else if(k)chmax(ret, solve(l+1,r-1,k-1)+2);\n    }\n    return memo[l][r][k]=ret;\n}\nsigned main() {\n    ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    cin>>s>>k;\n    cout<<solve(0,s.size()-1,k)<<endl;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nconst int MAXN = 300 + 10;\n\nchar s[MAXN];\nint k, n;\ninline void chmax(int &x, int y) {\n  x = std::max(x, y);\n}\nnamespace solver1 {\n  int f[MAXN][MAXN][MAXN];\n  void main() {\n    for (int i = 1; i <= n; i++) {\n      for (int j = n; j > i; j--) {\n        for (int t = k; t >= 0; t--) {\n          if (s[i] == s[j]) f[i][j][t] = f[i - 1][j + 1][t] + 1;\n          chmax(f[i][j][t], f[i - 1][j][t]);\n          chmax(f[i][j][t], f[i][j + 1][t]);\n          if (t == k) continue;\n          //chmax(f[i][j][t], f[i][j][t + 1]);\n          chmax(f[i][j][t], f[i - 1][j + 1][t + 1] + 1);\n          if (t + 1 == k) continue;\n          //chmax(f[i][j][t], f[i - 1][j + 1][t + 2] + 1);\n          \n        }\n      }\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n      for (int j = 0; j <= k; j++) {\n        chmax(ans, f[i][i + 1][j] * 2);\n        chmax(ans, f[i][i + 2][j] * 2 + 1);\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n}\nint main() {\n  scanf(\"%s\", s + 1);\n  n = strlen(s + 1);\n  scanf(\"%d\", &k);\n  solver1::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define rep(i, n) for(int i = 0 ; i < (int)(n) ; i++)\ntypedef long long ll;\ntypedef long double Double;\n\nshort dp[301][301][301];\nstring ss;\n\nint dfs(int l, int r, int k) {\n    if (dp[l][r][k] != -1) return dp[l][r][k];\n    if (l == r) return 1;\n    if (l > r) return 0;\n\n\n    int ans = 0;\n    if (k > 0) {\n        ans = max(ans, dfs(l + 1, r - 1, k - 1) + 2); // replace l or r\n    }\n    ans = max(ans, dfs(l + 1, r, k)); // abandon l\n    ans = max(ans, dfs(l, r - 1, k)); // abandon r\n\n    if (ss[l] == ss[r]) {\n        ans = max(ans, dfs(l + 1, r - 1, k) + 2);\n    }\n    return dp[l][r][k] = ans;\n}\n\nvoid solve(string S, ll K) {\n    ss = S;\n    memset(dp, -1, sizeof(dp));\n    \n    cout << dfs(0, S.size() - 1, K) << endl;\n}\n\nint main() {\n    ll K;\n    string S;\n    cin >> S;\n    scanf(\"%lld\", &K);\n    solve(S, K);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nchar s[1002]; int k;\nint vis[302][302][302], dp[302][302][302];\nint dfs(int l, int r, int k) {\n    if (k < 0) return - 100000;\n    if (l == r)return 1;\n    if (l > r) return 0;\n    if (vis[l][r][k]) return dp[l][r][k];\n    vis[l][r][k] = 1;\n    \n    int mx = max(dfs(l, r, k-1), 0);\n\n    if (s[l] == s[r]) {\n        mx = max(dfs(l+1,r-1,k) + 2, mx);\n    } else {\n        mx = max(dfs(l+1,r-1,k), mx);\n        mx = max(dfs(l+1,r-1,k-1) + 2, mx);\n    }\n    mx = max(dfs(l+1,r,k), mx);\n    mx = max(dfs(l,r-1,k), mx);\n    return dp[l][r][k] = mx;\n}\nint main() {\n    scanf(\"%s %d\", s+1, &k);\n    int n = strlen(s+1);\n    int ans = dfs(1,n,k);\n    printf(\"%d\\n\", ans);\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<stdexcept>\n#include<utility>\n#include<functional>\n#include<numeric>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<array>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<complex>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<bitset>\n#include<memory>\nusing namespace std;\nusing ll=long long;\n\nvoid cmax(int& lhs,int rhs){lhs=max(lhs,rhs);}\nint main(){\n    string s;\n    cin>>s;\n    int k;\n    cin>>k;\n    int half=s.size()/2;\n    \n    vector<vector<vector<int>>> dp(half+1,vector<vector<int>>(half+1,vector<int>(k+1)));\n    for(int i=0;i<=half;i++){\n        for(int j=0;j<=half;j++){\n            for(int l=0;l<=k;l++){\n                if(i<half){\n                    cmax(dp[i+1][j][l],dp[i][j][l]);\n                }\n                if(j<half){\n                    cmax(dp[i][j+1][l],dp[i][j][l]);\n                }\n                if(i<half &&j<half){\n                    if(s[i]!=s[s.size()-1-j] && l<k) cmax(dp[i+1][j+1][l+1],dp[i][j][l]+1);\n                    if(s[i]==s[s.size()-1-j]) cmax(dp[i+1][j+1][l],dp[i][j][l]+1);\n                }\n                if(l<k) cmax(dp[i][j][l+1],dp[i][j][l]);\n            }\n        }\n    }\n    \n\n    vector<vector<int>> posL(s.size()+1,vector<int>(26,-1));\n    for(int i=0;i<s.size();i++) posL[i+1]=posL[i],posL[i+1][s[i]-'a']=i;\n    vector<vector<int>> posR(s.size()+1,vector<int>(26,s.size()));\n    for(int i=s.size()-1;i<s.size();i--) posR[i]=posR[i+1],posR[i][s[i]-'a']=i;\n\n    vector<vector<vector<int>>> dp2(s.size()+1,vector<vector<int>>(s.size()+1,vector<int>(k+1)));\n    for(int i=0;i<s.size();i++) for(int j=0;j<=k;j++) dp2[i][i+1][j]=1;\n    for(int v=2;v<=s.size();v++){\n        for(int i=0;i<s.size();i++){\n        int j=i+v;\n        if(i+v>s.size()) continue;\n            for(int l=0;l<=k;l++){\n                if(l>0){\n                    cmax(dp2[i][j][l],dp2[i+1][j-1][l-1]+2);\n                    cmax(dp2[i][j][l],dp2[i][j][l-1]);\n                }\n                cmax(dp2[i][j][l],dp2[i+1][j][l]);\n                cmax(dp2[i][j][l],dp2[i][j-1][l]);\n                if(i+1<=posL[j][s[i]-'a']) cmax(dp2[i][j][l],dp2[i+1][posL[j][s[i]-'a']][l]+2);\n                if(posR[i][s[j-1]-'a']<=j-2) cmax(dp2[i][j][l],dp2[posR[i][s[j-1]-'a']+1][j-1][l]+2);\n            }\n        }\n    }\n\n    int res=0;\n    int tmp=s.size()%2;\n    for(int i=0;i<=half;i++){\n        for(int j=0;j<=half;j++){\n            for(int l=0;l<=k;l++){\n                cmax(res,dp[i][j][l]*2+dp2[i][half+tmp][k-l]);\n                cmax(res,dp[i][j][l]*2+dp2[half][s.size()-j][k-l]);\n            }\n        }\n    }\n    cout<<res<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n変更箇所は順読み逆読みの少なくとも片方で役立たないといけない\nつまり1点分として加算される必要がある\n逆に1点分以上の役割は持てない<-嘘だった\n例えば右端の文字が他に存在しない文字ならそれを変更するのはOK\n*/\n/*\n問題概要は最長の回文を作れ？\nだとすると中心決めてしまえばそこからは書き換えるかどうかは片側だけに注目すればよくて\nsBtに対してsを右側から見ていくことを考える\n変えるならt[now]しかありえなくて、書き換えた方がいいかどうかチェックするのに150^2かかる？\nなんか違いそう\n端から見て言ってdp[i][j][k]で考えるべき？\ndp[i][j][k]:左からi文字右からj文字、k文字変更した時の最長回文\ndp[i][j][k]=max(dp[i][j-1][k],dp[i-1][j][k],dp[i-1][j-1][k]+(s[i]==s[N-j-1]),dp[i-1][j-1][k-1]+1)\n*/\nint dp[400][400][400];\nsigned main(){\n  string s;int K;cin>>s>>K;\n  int N=s.size();\n  int ans=0;\n  for(int k=0;k<=K;k++){\n    for(int i=1;i<N;i++){\n      for(int j=1;i+j<=N;j++){\n        dp[i][j][k]=max({dp[i][j-1][k],dp[i-1][j][k],dp[i-1][j-1][k]+(s[i-1]==s[N-j])});\n        if(k)dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k-1]+1);\n        ans=max(ans,dp[i][j][k]);\n      }\n    }\n  }\n  cout<<ans*2+1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#ifdef leowang\n#define debug(...) do{\\\n\tfprintf(stderr,\"%s - %d : (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);\\\n\t_DO(__VA_ARGS__);\\\n}while(0)\ntemplate<typename I> void _DO(I&&x){cerr<<x<<endl;}\ntemplate<typename I,typename...T> void _DO(I&&x,T&&...tail){cerr<<x<<\", \";_DO(tail...);}\n#else\n#define debug(...)\n#endif\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n}\n//}}}\nconst ll maxn=305;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=8000000000000000000LL;\nconst int INF=2000000000;\nconst ll MOD=ll(1e9+7);\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n/*\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) a=a*a%MOD;\n\t\telse res=res*a%MOD;\n\t\tb>>=1;\n\t}\n\tres=res*a%mod;\n\treturn res;\n}\n*/\nstring s,t;\nint dp[maxn][maxn][maxn*2];\n\nint f(int i,int j,int k){\n\tif(k<0) return -INF;\n\tif(i==0||j==0) return 0;\n\tif(dp[i][j][k]!=-1) return dp[i][j][k];\n\tif(s[i-1]==t[j-1]) return f(i-1,j-1,k)+1;\n\treturn dp[i][j][k]=max({f(i-1,j,k),f(i,j-1,k),f(i-1,j-1,k-1)+1});\n}\n\nint main()\n{\n\tIOS;\n\tmemset(dp,-1,sizeof dp);\n\tint k;\n\tcin>>s>>k;\n\tt=s;\n\treverse(ALL(t));\n\tcout<<f(SZ(s),SZ(s),k*2);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// In The Name Of God\n#include <bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n\n#define sqr(A) ((A) * (A))\n#define X first\n#define Y second\n#define MP make_pair\n#define bsz  __builtin_popcount\n#define all(A) A.begin(), A.end()\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate < typename T >\nusing ordered_set = tree < T , null_type , less < T > , rb_tree_tag , tree_order_statistics_node_update >;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\nconst int MOD2 = 1e9 + 9;\nconst int PR = 727;\nconst int INF = INT_MAX;\nconst ll LINF = LLONG_MAX;\n\nconst int N = 3e2 + 20;\nint dp[N][N][N], n, k;\nstring s;\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> s >> k; n = s.size();\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j <= k; j++)\n\t\t\tdp[i][i][j] = 1;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tdp[i][i + 1][0] = (s[i] == s[i + 1] ? 2 : 1);\n\t\tfor (int j = 1; j <= k; j++)\n\t\t\tdp[i][i + 1][j] = 2;\n\t}\n\tfor (int gap = 3; gap <= n; gap++)\n\t\tfor (int i = 0; i < n - gap + 1; i++) {\n\t\t\tint j = i + gap - 1;\n\t\t\tif (s[i] == s[j])\n\t\t\t\tdp[i][j][0] = dp[i + 1][j - 1][0] + 2;\n\t\t\tdp[i][j][0] = max({dp[i][j][0], dp[i + 1][j][0], dp[i][j - 1][0]});\n\t\t\tfor (int x = 1; x <= k; x++) {\n\t\t\t\tif (s[i] == s[j])\n\t\t\t\t\tdp[i][j][x] = dp[i + 1][j - 1][x] + 2;\n\t\t\t\tdp[i][j][x] = max({dp[i][j][x], dp[i + 1][j - 1][x - 1] + 2, dp[i + 1][j][x], dp[i][j - 1][x]});\n\t\t\t}\n\t\t}\n\tcout << dp[0][n - 1][k] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[301][301][301];\nint main() {\n  string S;\n  int K;\n  cin >> S >> K;\n  for(auto i = 0; i < S.size(); ++i) dp[i][i+1][0] = 1;\n  for(auto k = 0; k <= K; ++k) for(auto w = 2; w <= S.size(); ++w) for(auto l = 0; l+w <= S.size(); ++l) {\n    auto r = l + w;\n    dp[l][r][k] = max({dp[l][r][k], dp[l+1][r][k], dp[l][r-1][k]});\n    if(0 < k)        dp[l][r][k] = max(dp[l][r][k], 2 + dp[l+1][r-1][k-1]);\n    if(S[l]==S[r-1]) dp[l][r][k] = max(dp[l][r][k], 2 + dp[l+1][r-1][k]);\n  }\n  cout << dp[0][S.size()][K] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',')cerr<<*sdbg++; cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n    \nstring s;\nconst int N = 3e2 + 5;\nint p[N][N][N];\nint Go(int l, int r, int k) {\n  if (p[l][r][k]) { return p[l][r][k]; }\n  if (l == r) {\n    return p[l][r][k] = 1;\n  }\n  if (l > r) {\n    return 0;\n  }\n  if (s[l] == s[r]) {\n    maxi(p[l][r][k], Go(l + 1, r - 1, k) + 2);\n  } else {\n    if (k > 0) {\n      maxi(p[l][r][k], Go(l + 1, r - 1, k - 1) + 2);\n    }\n  }\n  if (k > 0) {\n    maxi(p[l][r][k], Go(l, r, k - 1));\n  }\n  maxi(p[l][r][k], Go(l + 1, r, k));\n  maxi(p[l][r][k], Go(l, r - 1, k));\n  return p[l][r][k];\n}\n\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  cin>>s;\n  int k;\n  cin>>k;\n  int n = SZ(s);\n  s = '#' + s;\n  Go(1, n, k);\n  cout<<p[1][n][k]<<endl;\n  \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring s;\nint mat[311][311][311];\n\nint main()\n{\n    cin >> s;\n    int kmax;\n    cin >> kmax;\n    int n = s.size();\n    s = \"$\" + s;\n    int ans(0);\n    for (int i(1); i <= n; i++) {\n        for (int j(1); i + j <= n; j++) {\n            for (int k(0); k <= kmax; k++) {\n                if (s[i] == s[n - j + 1])\n                    mat[i][j][k] = mat[i - 1][j - 1][k] + 1;\n                if (k > 0)\n                    mat[i][j][k] = max(mat[i][j][k], mat[i - 1][j - 1][k - 1] + 1);\n                mat[i][j][k] = max(mat[i][j][k], mat[i - 1][j][k]);\n                mat[i][j][k] = max(mat[i][j][k], mat[i][j - 1][k]);\n\n            }\n        }\n    }\n\n    if (n % 2 == 0) {\n        for (int i(1); i <= n; i++)\n            for (int j(0); j <= kmax; j++)\n                ans = max(ans, 2 * mat[i][n - i][j]);\n    }\n    else {\n        for (int i(1); i <= n; i++)\n            for (int j(0); j <= kmax; j++)\n                ans = max(ans, 2 * mat[i - 1][n - i][j] + 1);\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nchar s[333];\nint dp[333][333][333];\nint calc(int S,int E,int left){\n\tif(S >= E)return 0;\n\tint&ret = dp[S][E][left];\n\tif(ret != -1)return ret;\n\tret = min(calc(S+1, E, left), calc(S, E-1, left)) + 1;\n\tif(s[S] == s[E])\n\t\tret = min(ret, calc(S+1, E-1, left));\n\telse\n\tif(left > 0)\n\t\tret = min(ret, calc(S+1, E-1, left-1));\n\treturn ret;\n}\nint main(){\n\tint k,n;\n\tscanf(\"%s%d\",s,&k);\n\tn = strlen(s);\n\tmemset(dp,-1,sizeof(dp));\n\tprintf(\"%d\\n\", n - calc(0, n-1, k));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nstatic const int IINF = 1 << 30;\n\ntemplate <typename T> std::vector<T> vectors(std::size_t n, T val) {\n  return std::vector<T>(n, val);\n}\n\ntemplate <typename T, typename... Args>\nauto vectors(std::size_t n, Args... args) {\n  return std::vector<decltype(vectors<T>(args...))>(n, vectors<T>(args...));\n}\n\ntemplate <class T> inline bool chmax(T &a, const T &b) {\n  return (a < b) ? a = b, true : false;\n}\n\nint main() {\n  // Input\n  std::string S;\n  int K;\n  int N;\n  std::cin >> S;\n  std::cin >> K;\n  N = S.length();\n\n  // Initialization\n  auto dp = vectors<int>(1 + N + 1, 1 + N + 1, 1 + K + 1, -IINF);\n\n  // Initial condition\n  for (int k = 0; k <= K; ++k)\n    dp[0][0][k] = 0;\n\n  // DP main\n  for (int i = 0; i <= N; ++i) {\n    for (int j = 0; j <= N; ++j) {\n      for (int k = 0; k <= K; ++k) {\n        chmax(dp[i + 1][j][k], dp[i][j][k]);\n        chmax(dp[i][j + 1][k], dp[i][j][k]);\n        chmax(dp[i + 1][j + 1][k + 1], dp[i][j][k] + 1);\n        if (i < N and j < N and S[i] == S[N - j - 1])\n          chmax(dp[i + 1][j + 1][k], dp[i][j][k] + 1);\n      }\n    }\n  }\n\n  // Output\n  int res = -1;\n  for (int i = 0; i <= N; ++i)\n    chmax(res, 2 * dp[i][N - i][K]);\n  for (int i = 0; i < N; ++i)\n    chmax(res, 2 * dp[i][N - i - 1][K] + 1);\n\n  std::cout << res << std::endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n\nstring s;\nint dp[303][303][303];\n\nint solve(int a, int b, int k) {\n\tif(dp[a][b][k] < 0) {\n\t\tdp[a][b][k] = 0;\n\t\tif(a > 0) {\n\t\t\tdp[a][b][k] = max(dp[a][b][k], solve(a - 1, b, k));\n\t\t}\n\t\tif(b > 0) {\n\t\t\tdp[a][b][k] = max(dp[a][b][k], solve(a, b - 1, k));\n\t\t}\n\t\tif(a > 0 && b > 0) {\n\t\t\tif(s[a - 1] == s[s.size() - b]) {\n\t\t\t\tdp[a][b][k] = max(dp[a][b][k], solve(a - 1, b - 1, k) + 1);\n\t\t\t}\n\t\t\tif(k > 0) {\n\t\t\t\tdp[a][b][k] = max(dp[a][b][k], solve(a - 1, b - 1, k - 1) + 1);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[a][b][k];\n}\n\nsigned main() {\n\tcin >> s;\n\tint k;\n\tcin >> k;\n\trep(i, s.size() + 2) {\n\t\trep(j, s.size() + 2) {\n\t\t\trep(k, s.size() + 2) {\n\t\t\t\tdp[i][j][k] = -1;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i, s.size()) {\n\t\tans = max(ans, solve(i, s.size() - i, k) * 2);\n\t}\n\trep(i, s.size() - 1) {\n\t\tans = max(ans, solve(i, s.size() - i - 1, k) * 2 + 1);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 305\n\nusing namespace std;\nint dp[maxn][maxn][maxn],n,k,l,r;\nchar s[maxn];\n\nint main()\n{\n    scanf(\"%s\",s); scanf(\"%d\",&k); n=strlen(s);\n    for (int i=0;i<n;i++) dp[i][i][0]=1;\n    for (int i=1;i<n;i++) dp[i][i-1][0]=0;\n    for (int i=1;i<n;i++)\n        for (int j=0;j+i<n;j++)\n        {\n            l=j; r=j+i;\n            for (int m=0;m<=k;m++)\n            {\n                dp[l][r][m]=max(dp[l+1][r][m],dp[l][r-1][m]);\n                if (m-(s[l]!=s[r])>=0) dp[l][r][m]=max(dp[l][r][m],dp[l+1][r-1][m-(s[l]!=s[r])]+2);\n            }\n        }\n    cout << dp[0][n-1][k] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef long double ld;\ntypedef vector<ld> vd;\ntypedef bool bl;\ntypedef vector<bl> vb;\ntypedef unordered_map<ll,unordered_map<ll,ll>> graph;\n\nconst ll e5 = 1 << 20;\nconst ll mod = 1000000007;\nconst ll e3 = 1 << 13;\nconst ll INF = 1ll << 60;\n\nstring s;\nstring r;\nll t;\nll dp[302][302][302];\nll ans;\n\nint main(){\n  cin >> s;\n  cin >> t;\n  r = s;\n  reverse(r.begin(),r.end());\n  // cerr << r << endl;\n  // cerr << s << endl;\n  for(ll i = 0;i < s.size();i++){\n    for(ll j = 0;j < s.size();j++){\n      for(ll k = 0;k <= t;k++){\n        if(s[i] == r[j]){\n          dp[i+1][j+1][k] = max(dp[i+1][j+1][k],dp[i][j][k]+1);\n        }else{\n          dp[i+1][j+1][k+1] = max(dp[i+1][j+1][k+1],dp[i][j][k]+1);\n        }\n        dp[i+1][j][k] = max(dp[i+1][j][k],dp[i][j][k]);\n        dp[i][j+1][k] = max(dp[i][j+1][k],dp[i][j][k]);\n      }\n    }\n  }\n  cerr << s.size() << endl;\n  for(ll k = 0;k <= t;k++){\n    for(ll i = 0;i <= s.size();i++){\n      for(ll j = 0;j <= s.size();j++){\n        cerr << dp[i][j][k] << \" \";\n      }\n      cerr << endl;\n    }\n    cerr << endl;\n    cerr << endl;\n  }\n\n  for(ll i = 0;i < s.size();i++){\n    for(ll k = 0;k <= t;k++){\n      ans = max(ans,dp[i][s.size()-i-1][k]*2+1);\n    }\n  }\n  for(ll i = 1;i < s.size();i++){\n    for(ll k = 0;k <= t;k++){\n      ans = max(ans,dp[i][s.size()-i][k]*2);\n    }\n  }\n  cout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) do{print_vars(cout<<\"# \"<<#__VA_ARGS__<<'=',__VA_ARGS__);cout<<endl;}while(0)\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\ntemplate<typename T,typename U>bool chmin(T& a,const U& b){return a>b?(a=b,1):0;}\ntemplate<typename T,typename U>bool chmax(T& a,const U& b){return a<b?(a=b,1):0;}\n\nvoid print_vars(ostream&){}\ntemplate<typename Car,typename... Cdr>\nvoid print_vars(ostream& os,const Car& car,const Cdr&... cdr){\n\tprint_vars(os<<car<<(sizeof...(cdr)?\",\":\"\"),cdr...);\n}\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<int I,typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<int I,typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tos<<get<I>(t)<<(sizeof...(Cdr)?\",\":\"\");\n\tprint_tuple<I+1,Cdr...>(os,t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<0,Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\nusing vvvi=vector<vvi>;\n\nint solve(const string& s,int l,int r,int x,vvvi& memo)\n{\n\tif(l>=r) return 0;\n\tint& res=memo[l][r][x];\n\tif(res==-1){\n\t\tassert(l<r);\n\t\tif(r-l==1)\n\t\t\tchmax(res,1);\n\t\telse{\n\t\t\tchmax(res,solve(s,l,r-1,x,memo));\n\t\t\tchmax(res,solve(s,l+1,r,x,memo));\n\t\t\tif(s[l]==s[r-1])\n\t\t\t\tchmax(res,solve(s,l+1,r-1,x,memo)+2);\n\t\t\tif(x)\n\t\t\t\tchmax(res,solve(s,l+1,r-1,x-1,memo)+2);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\t#ifndef _GLIBCXX_DEBUG\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tconstexpr char endl='\\n';\n\t#endif\n\n\tfor(string s;cin>>s;){\n\t\tint k; cin>>k;\n\t\tint n=s.size();\n\t\tvvvi memo(n,vvi(n+1,vi(k+1,-1)));\n\t\tcout<<solve(s,0,n,k,memo)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\nusing namespace std;\n\ntemplate<class T> vector<T> make_vec(size_t a) { return vector<T>(a); }\ntemplate<class T, class... Ts>\nauto make_vec(size_t a, Ts... ts){return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));}\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\n\nint main(int argc, char const *argv[]) {\n  string s;std::cin >> s;\n  ll K;std::cin >> K;\n  int n = s.size();\n  auto dp = make_vec<int>(n+2, n+2, K+2);\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 0; j <= n; ++j) {\n            for (int k = 0; k <= n; ++k) {\n                chmax(dp[i+1][j][k], dp[i][j][k]);\n                chmax(dp[i][j+1][k], dp[i][j][k]);\n                chmax(dp[i+1][j+1][k+1], dp[i][j][k] + 1);\n                if (i < n && n-1-j >= 0 && s[i] == s[n-1-j])\n                    chmax(dp[i+1][j+1][k], dp[i][j][k] + 1);\n            }\n        }\n    }\n    int res = 0;\n    for (int k = 0; k <= K; ++k) {\n      for (int i = 0; i <= n; ++i) chmax(res, dp[i][n-i][k]*2);\n      for (int i = 0; i < n; ++i) chmax(res, dp[i][n-1-i][k] * 2 + 1);\n    }\n    std::cout << res << '\\n';\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[301][300][300];\nint INF = 1e6;\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n//freopen(\"1.txt\", \"r\", stdin);\n    string s;\n    cin >> s;\n    int k;\n    cin >> k;\n    int n = s.size();\n\tfor (int i=0; i < n; i++){\n\t\tfor (int j=0; j < n; j++){\n\t\t\tfor (int p=0; p <= n; p++) dp[p][j][i] = INF;\n\t\t\tdp[1][j][i] = 0;\n\t\t}\n\t}\n\tfor (int it=2; it <= n; it++){\n\t\tfor (int i=0; i < n; i++){\n\t\t\tfor (int j=i+1; j < n; j++){\n\t\t\t\tint cost=0;\n\t\t\t\tif (s[i] != s[j]) cost=1;\n\t\t\t\tint I = i+1;\n\t\t\t\tint J = j - 1;\n\t\t\t\tif (I > J){\n\t\t\t\t\tif (it==2) dp[it][i][j] = cost;\n\t\t\t\t}\n\t\t\t\telse dp[it][i][j] = dp[it-2][I][J] + cost;\n\t\t\t}\n\t\t}\n\t\tfor (int i=0; i < n; i++){\n\t\t\tfor (int j=i+1; j < n; j++) dp[it][i][j] = min(dp[it][i][j], dp[it][i][j-1]);\n\t\t}\n\t\tfor (int i=0; i < n; i++){\n\t\t\tfor (int j=i-1; j >= 0; j--){\n\t\t\t\tdp[it][j][i] = min(dp[it][j][i], dp[it][j+1][i]);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i=1; i <= n; i++){\n\t\tfor (int j=0; j < n; j++){\n\t\t\tfor (int p=0; p < n; p++){\n\t\t\t\tif (dp[i][j][p] <= k){\n\t\t\t\t\tans = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 310;\n\nchar s[N];\nint f[N][N][N];\n\nint main() {\n  int m;\n  scanf(\"%s %d\", s + 1, &m);\n  int n = (int)strlen(s + 1);\n  memset(f, 0, sizeof f);\n  for (int i = 1; i <= n; ++i) {\n    for (int j = n; j >= i; --j) {\n      for (int k = 0; k <= m; ++k) {\n        f[i][j][k] = max(f[i][j][k], f[i - 1][j + 1][k] + 2 * (s[i] == s[j]) - (j == i));\n        f[i][j][k] = max(f[i][j][k], f[i - 1][j][k]);\n        f[i][j][k] = max(f[i][j][k], f[i][j + 1][k]);\n      }\n      for (int k = 1; k <= m; ++k) {\n        f[i][j][k] = max(f[i][j][k], f[i - 1][j + 1][k - 1] + 2 - (j == i));\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; ++i) {\n    for (int j = i; j <= n; ++j) {\n      for (int k = 0; k <= m; ++k) {\n        ans = max(ans, f[i][j][k]);\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n    for(T& x: vec) {is >> x;} return is;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll K;\n    string s;\n    cin >> s >> K;\n    ll n = s.size();\n    string t(s);\n    reverse(ALL(t));\n\n    auto dp = make_v<ll>(n+1, n+1, K+1);\n    FOR(i, 1, n+1) FOR(j, 1, n+1) REP(k, K+1) {\n        if(s[i-1] == t[j-1]) {\n            dp[i][j][k] = dp[i-1][j-1][k] + 1;\n        } else {\n            dp[i][j][k] = max(dp[i-1][j][k], dp[i][j-1][k]);\n            if(k) chmax(dp[i][j][k], dp[i-1][j-1][k-1]+2);\n        }\n        // cout << i << \" \" << j << \" \" << k << \" \" << dp[i][j][k] << endl;\n    }\n    cout << dp[n][n][K] << endl;\n\n    // REP(i, n+1) {\n    //     REP(j, n+1) {\n    //         cout << dp[i][j][0] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n    // cout << endl;\n    // REP(i, n+1) {\n    //     REP(j, n+1) {\n    //         cout << dp[i][j][1] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\ntemplate<typename T>\nvector<vector<T> > make_v(size_t a,size_t b){\n  return vector<vector<T> >(a,make_v<T>(b));\n}\ntemplate<typename T>\nvector<vector<vector<T> > > make_v(size_t a,size_t b,size_t c){\n  return vector<vector<vector<T> > > (a,make_v<T>(b,c));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  string s;\n  Int k;\n  cin>>s>>k;\n  Int n=s.size();\n\n  const Int INF = 1e5;\n  auto dp=make_v<Int>(k+2,n,n);\n  fill_v(dp,-INF);\n\n  for(Int i=0;i<n;i++){\n    dp[0][i][i]=1;\n    for(Int j=i+1;j<n;j++)\n      dp[s[i]!=s[j]][i][j]=2;\n  }\n\n  for(Int l=1;l<=n;l++){\n    for(Int i=0;i<=k;i++){\n      for(Int p=0;p+l<=n;p++){\n\tInt q=p+l-1;\n\t//cout<<i<<\" \"<<p<<\" \"<<q<<\":\"<<dp[i][p][q]<<endl;\n\tif(p  >0) chmax(dp[i][p-1][q],dp[i][p][q]);\n\tif(q+1<n) chmax(dp[i][p][q+1],dp[i][p][q]);\n\tif(p>0&&q+1<n) chmax(dp[i+(s[p-1]!=s[q+1])][p-1][q+1],dp[i][p][q]+2);\n      }\n    }\n  }\n  \n  Int ans=0;\n  for(Int i=0;i<=k;i++) chmax(ans,dp[i][0][n-1]);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[305][305][305];\n\nint main(){\n  \n  string s;\n  int K;\n  \n  cin>>s>>K;\n  \n  memset(dp,-1,sizeof(dp));\n  \n  dp[0][s.size()-1][0]=0;\n  \n  if(s.size()==1) cout<<1<<endl;\n  \n  int ans=0;\n  \n  for(int l=0;l<s.size();l++)\n    \n    for(int r=s.size()-1;r>=l;r--){\n\n      for(int k=0;k<=K;k++){\n\t\n\tif(dp[l][r][k]==-1) continue;\n\n\tif(l==r) ans=max(ans, dp[l][r][k]+1);\n\t\n\tif(s[l]==s[r]) dp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]+2);\n\t\n\tif(l==r) continue;\n\t\n\tdp[l+1][r-1][k+1]=max(dp[l+1][r-1][k+1], dp[l][r][k]+2);\n\tdp[l+1][r][k]=max(dp[l+1][r][k], dp[l][r][k]);\n\tdp[l][r-1][k]=max(dp[l][r-1][k], dp[l][r][k]);\n\tdp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]);\n      }\n    }  \n  \n  cout<<ans<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\nusing namespace std;\n\nconst int MAXN = 300;\nconst int INF = 1000 * 1000 * 1000;\n\nint dp[MAXN + 1][MAXN + 1][MAXN + 1];\n\nvoid upd(int &x, int y) {\n    x = max(x, y);\n}\n\nint main() {\n    //cin.tie(0), ios::sync_with_stdio(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n\n    string s;\n    cin >> s;\n    int n = (int)s.size();\n    int K;\n    cin >> K;\n\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            for (int k = 0; k <= K; k++) {\n                dp[i][j][k] = -INF;\n            }\n        }\n    }\n    dp[0][0][0] = 0;\n    for (int i = 0; i < n; i++) {\n        dp[0][i][i] = 1;\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int k = 0; k <= K; k++) {\n            for (int l = 0; l + len - 1 < n; l++) {\n                int r = l + len - 1;\n                upd(dp[k][l][r], dp[k][l + 1][r]);\n                upd(dp[k][l][r], dp[k][l][r - 1]);\n                if (s[l] == s[r]) {\n                    upd(dp[k][l][r], dp[k][l + 1][r - 1] + 2);\n                }\n                if (k > 0) {\n                    upd(dp[k][l][r], max(dp[k - 1][l + 1][r], dp[k - 1][l][r - 1]) + 2);\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for (int k = 0; k <= K; k++) {\n        ans = max(ans, dp[k][0][n - 1]);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define SF scanf\n#define PF printf\n#define MAXN 310\nusing namespace std;\nint dp[MAXN][MAXN][MAXN];\nchar s[MAXN];\nint t,n;\nint main(){\n    SF(\"%s\",s);\n    SF(\"%d\",&t);\n    n=strlen(s);\n    for(int i=0;i<n;i++)\n        dp[i][i][0]=1;\n    for(int i=1;i<=n;i++)\n        for(int j=0;j+i<n;j++)\n            for(int k=0;k<=t;k++){\n                int l=j,r=j+i;\n                if(s[l]==s[r])\n                    dp[l][r][k]=max(dp[l][r][k],dp[l+1][r-1][k]+2);\n                else{\n                    if(k!=0)\n                        dp[l][r][k]=max(dp[l+1][r-1][k-1]+2,dp[l][r][k]);\n                    dp[l][r][k]=max(dp[l+1][r][k],dp[l][r][k]);\n                    dp[l][r][k]=max(dp[l][r-1][k],dp[l][r][k]);\n                }\n            }\n    int ans=0;\n    for(int i=0;i<=t;i++)\n        ans=max(ans,dp[0][n-1][i]);\n    PF(\"%d\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <string>\nusing namespace std;\ntypedef long long LL;\n\nstring s,t;\nLL n,K,ans = 0;\nLL dp[305][305][305];\n\nint main(){\n\tcin >> s; n = s.length();\n\tt = s; reverse(t.begin(),t.end());\n\ts = ' ' + s; t = ' ' + t;\n\tcin >> K;\n\t\n\tfor(LL i = 1;i <= n;i ++){\n\t\tfor(LL j = 1;j <= n;j ++){\n\t\t\tfor(LL k = 0;k <= K;k ++){\n\t\t\t\tdp[i][j][k] = max(dp[i - 1][j][k],dp[i][j - 1][k]);\n\t\t\t\tif(k) dp[i][j][k] = max(dp[i][j][k],dp[i - 1][j - 1][k - 1] + 1);\n\t\t\t\tif(s[i] == t[j]) dp[i][j][k] = max(dp[i][j][k],dp[i - 1][j - 1][k] + 1);\n//\t\t\t\tcout << i << ' ' << j << ' ' << k << ' ' << dp[i][j][k] << '\\n';\n\t\t\t}\n\t\t}\n\t}\n\tfor(LL i = 1;i <= n;i ++){\n\t\tans = max(ans,dp[i][n - i][K] << 1);\n\t\tans = max(ans,(dp[i][n - i - 1][K] << 1) + 1);\n//\t\tcout << dp[i][n - i][K] << ' ' << dp[i][n - i - 1][K] << endl;\n\t}\n\tcout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 305;\nconst int INF = 1e9;\n\nstring s;\nint n, k;\nint dp[N][N][N];\nint res;\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcin >> s >> k;\n\tn = s.size();\n\ts = ' ' + s;\n\ts = s + '&';\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tfor (int c = 0; c <= k; ++c) dp[i][j][c] = -INF;\n\t\t}\n\t}\n\tfor (int i = 0; i <= n + 1; ++i) dp[0][i][0] = 0;\n\tfor (int i = 0; i <= n + 1; ++i) dp[i][n + 1][0] = 0;\n\tfor (int gap = n; gap >= 1; --gap) {\n\t\tfor (int i = 1; i <= n - gap + 1; ++i) {\n\t\t\tint j = i + gap - 1;\n\t\t\tfor (int c = 0; c <= k; ++c) {\n\t\t\t\tdp[i][j][c] = max(dp[i][j][c], dp[i - 1][j][c]);\n\t\t\t\tdp[i][j][c] = max(dp[i][j][c], dp[i][j + 1][c]);\n\t\t\t\t\n\t\t\t\tbool more = (s[i] == s[j] ? 0 : 1);\n\t\t\t\tif (c >= more) {\n\t\t\t\t\tdp[i][j][c] = max(dp[i][j][c], dp[i - 1][j + 1][c - more] + (i == j ? 1 : 2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tfor (int c = 0; c <= k; ++c) {\n\t\t\t\tres = max(res, dp[i][j][c]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing ull = unsigned long long;\nusing namespace std;\nconst int INF = 1e5;\nconst int MOD = 1e9 + 7;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\n#define pb push_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define P pair<int, int>\n#define V vector<int>\n//#define S set<int>\n#define itn int\nbool dbg = false;\nstring S;\nint K;\n\nitn memo[333][333][333];\nitn f(itn l, int r, int k) {\n    if (memo[l][r][k] != 0)\n        return memo[l][r][k];\n    if (k < 0)\n        return INF * -1;\n    if (l == r)\n        return 1;\n    if (l == r + 1)\n        return 0;\n    if (l > r)\n        return INF * -1;\n    int ret = 0;\n    chmax(ret, f(l + 1, r, k));\n    chmax(ret, f(l, r - 1, k));\n    if (S[l] == S[r])\n        chmax(ret, f(l + 1, r - 1, k) + 2);\n    else\n        chmax(ret, f(l + 1, r - 1, k - 1) + 2);\n    //cerr << l + 1 << \" \" << r + 1 << \" \" << k << \" \" << ret << endl;\n    memo[l][r][k] = ret;\n    return ret;\n}\n\nvoid solve() {\n    itn N = S.size();\n    cout << f(0, N - 1, K) << endl;\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cin >> S >> K;\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define mod 1000000007LL\n#define eps 1e-13\n// #define PI 3.141592653589793238L\n#define INF 1000000011\n#define INFLL 1000000000000000011LL\n#define vi vector<int>\n#define vll vector<long long>\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define pil pair<int, long long>\n#define pli pair<long long, int>\n#define mp make_pair\n#define F first\n#define S second\n#define pb push_back\n#define fo(i,a,n) for(i = (a); i < (n); i++)\n#define gtl(x) getline(cin, (x))\n#define flsh fflush(stdout)\n#define sws ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)\n#define gcd __gcd\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)((a).size())\n#define io_file freopen(\"D:/Coding Problems/Contest/input_file.in\", \"r\", stdin); freopen(\"D:/Coding Problems/Contest/output_file.out\", \"w\", stdout)\n\nll modx(ll Base, ll exponent)\n{\n\tll ans = 1;\n\tif(Base == 1)\n\t\treturn Base;\n\twhile(exponent)\n\t{\n\t\tif(exponent & 1)\n\t\t\tans = (ans * Base)%mod;\n\t\tBase = (Base * Base)%mod;\n\t\texponent = exponent >> 1;\n\t}\n\treturn ans;\n}\n\nll inmodx(ll num)\n{\n\treturn (modx(num, mod-2LL));\n}\n\nbool cmp(pair < pii, int > a, pair < pii, int > b)//true for a before b\n{\n\tif(a.F.F/300 < b.F.F/300)\n\t\treturn 1;\n\tif(a.F.F/300 > b.F.F/300)\n\t\treturn 0;\n\tif(a.F.S < b.F.S)\n\t\treturn 1;\n\tif(a.F.S > b.F.S)\n\t\treturn 0;\n\tif(a.F <= b.F)\n\t\treturn 1;\n\treturn 0;\n}\n\nconst int N = (3e2) + 9;\nconst int M = (N<<2) + 9;\nconst int LOGN = ((int)log2(N)) + 3;\nconst int LOGM = ((int)log2(M)) + 3;\nconst int BUCK = 2*550;\nconst int SQRT = BUCK+9;\n\nint dp[N][N][N];\nstring s;\nint n, K;\n\nvoid solve()\n{\n\tint i, j, k, ans = 0;\n\tcin >> s;\n\tcin >> K;\n\tn = s.length();\n\tfo(i,1,n+1)\n\t\tfo(j,1,n-i+1+1)\n\t\t\tfo(k,0,K+1)\n\t\t\t{\n\t\t\t\tif(s[i-1] == s[n-j])\n\t\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k] + ((i+j < n) ? 2 : 1));\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k]);\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k]);\n\t\t\t\tif(k > 0)\n\t\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k-1] + ((i+j < n) ? 2 : 1));\n\t\t\t\tans = max(ans, dp[i][j][k]);\n\t\t\t}\n\tcout << ans << '\\n';\n\treturn;\n}\n\nint main()\n{\n\tsws;\n\tclock_t clk;\n\tclk = clock();\n\t// io_file; yahoo\n\t// srand (time(NULL));\n\n\t//Code here\n\tint t = 1, cs;\n\tcout << fixed << setprecision(9);\n\t// cin >> t;\n\tfo(cs,1,t+1)\n\t{\n\t\t// cout << \"Case #\" << cs << \": \";\n\t\tsolve();\n\t}\n\t// Code ends here\n\n\tclk = clock() - clk;\n\tcerr << fixed << setprecision(6) << \"Time: \" << ((double)clk)/CLOCKS_PER_SEC << \"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 100000000\n#define YJ 1145141919\n#define INF_INT_MAX 2147483647\n#define INF_LL_MAX 9223372036854775807\n#define EPS 1e-10\n#define Pi acos(-1)\n#define LL long long\n#define ULL unsigned long long\n#define LD long double\n\nconst int MAX_S = 305;\nstring S;\nint K;\n\nint dp[MAX_S][MAX_S][MAX_S];\n\nint main()\n{\n  cin >> S;\n  cin >> K;\n  \n  memset(dp, 0, sizeof(dp));\n\n  for(int i = 0; i < S.length(); i++) {\n    dp[i][i][K] = 1;\n  }\n\n  for(int w = 0; w < S.length(); w++) {\n    for(int l = 0; l+w < S.length(); l++) {\n      int r = l+w;\n      for(int k = 0; k <= K; k++) {\n\t//何もしない\n\tif(l-1 >= 0) {\n\t  dp[l-1][r][k] = max(dp[l-1][r][k], dp[l][r][k]);\n\t}\n\tif(r+1 < S.length()) {\n\t  dp[l][r+1][k] = max(dp[l][r+1][k], dp[l][r][k]);\n\t}\n\n\t//回文を伸ばす\n\tif(l-1 >= 0 && r+1 < S.length()) {\n\t  if(S[l-1] == S[r+1]) {\n\t    dp[l-1][r+1][k] = max(dp[l-1][r+1][k], dp[l][r][k] + 2);\n\t  }\n\t  if(k > 0) {\n\t    dp[l-1][r+1][k-1] = max(dp[l-1][r+1][k-1], dp[l][r][k] + 2);\n\t  }\n\t}\n      }\n    }\n  }\n\n  cout << dp[0][S.length()-1][0] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_S = 300;\nconst int MAX_K = MAX_S;\nchar s[MAX_S+1];\nint dp[MAX_S+2][MAX_S+2][MAX_K+1];\n\nint main()\n{\n  int k;\n  cin >> (s+1) >> k;\n\n  int n = strlen(s + 1);\n\n  for (int l = n; l > 0; l--) {\n    for (int r = l; r <= n; r++) {\n      for (int c = 0; c <= k; c++) {\n        if (s[l] == s[r])\n          dp[l][r][c] = dp[l+1][r-1][c] + (l == r ? 1 : 2);\n        dp[l][r][c] = max(dp[l][r][c], max(dp[l+1][r][c], dp[l][r-1][c]));\n          if (c != 0)\n            dp[l][r][c] = max(dp[l][r][c], dp[l+1][r-1][c-1] + (l == r ? 1 : 2));\n      }\n    }\n  }\n  cout << dp[1][n][k] << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nchar S[305];\nint N, K;\nint DP[305][305][305];\nint Prev[305][305];\nint Next[305][305];\nvoid Read()\n{\n    cin.getline(S + 1, 305);\n    N = strlen(S + 1);\n    cin >> K;\n}\n\nvoid Solve()\n{\n    for(int i = 1; i <= N; i++)\n    {\n        for(int j = 0; j <= N; j++)\n            DP[i][i][j] = 1, Next[i][j] = 1, Prev[i][j] = 1;\n\n    }\n    for(int i = 1; i < N; i++)\n    {\n        if(S[i] == S[i + 1])\n            DP[i][i + 1][0] = 2;\n        else\n        {\n            DP[i][i + 1][0] = 1;\n            DP[i][i + 1][1] = 2;\n        }\n        for(int j = 1; j <= N; j++)\n            DP[i][i + 1][j] = 2, Next[i][j] = 2, Prev[i + 1][j] = 2;\n        Next[i][0] = max(Next[i][0], DP[i][i + 1][0]);\n        Prev[i + 1][0] = max(Prev[i + 1][0], DP[i][i + 1][0]);\n    }\n    for(int dist = 3; dist <= N; dist++)\n    {\n        for(int i = 1; i + dist - 1 <= N; i++)\n        {\n            int j = i + dist - 1;\n            for(int k = 0; k <= N; k++)\n            {\n                DP[i][j][k] = max(Next[i][k], Prev[j][k]);\n                if(S[i] == S[j])\n                    DP[i][j][k] = max(DP[i][j][k], DP[i + 1][j - 1][k] + 2);\n                else\n                    if(k > 0)\n                        DP[i][j][k] = max(DP[i][j][k], DP[i + 1][j - 1][k - 1] + 2);\n                Prev[j][k] = max(Prev[j][k], DP[i][j][k]);\n                Next[i][k] = max(Next[i][k], DP[i][j][k]);\n            }\n        }\n    }\n    int ans = 0;\n    for(int i = 0; i <= K; i++)\n        ans = max(ans, DP[1][N][i]);\n    cout << ans << \"\\n\";\n}\nint main()\n{\n    Read();\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 301;\nint n, m, f[maxn][maxn][maxn];\nchar buf[maxn];\nint F(int L, int R, int c) {\n\tif(L >= R)\n\t\treturn L == R;\n\tif(f[L][R][c] != -1)\n\t\treturn f[L][R][c];\n\tint ret = max(F(L + 1, R, c), F(L, R - 1, c));\n\tif(buf[L] == buf[R])\n\t\tret = max(ret, F(L + 1, R - 1, c) + 2);\n\tif(c)\n\t\tret = max(ret, F(L + 1, R - 1, c - 1) + 2);\n\treturn f[L][R][c] = ret;\n}\nint main() {\n\tscanf(\"%s%d\", buf, &m);\n\tn = strlen(buf);\n\tmemset(f, -1, sizeof f);\n\tprintf(\"%d\\n\", F(0, n - 1, m));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define f first\n#define s second\n#define ind(a) scanf(\"%d\", &a)\n#define inlld(a) scanf(\"%lld\", &a)\n#define ind2(a, b) scanf(\"%d%d\", &a, &b)\n#define inlld2(a, b) scanf(\"%lld%lld\", &a, &b)\n#define ind3(a, b, c) scanf(\"%d%d%d\", &a, &b, &c)\n#define inlld3(a, b, c) scanf(\"%lld%lld%lld\", &a, &b, &c)\n\nusing namespace std;\n\nconst int N=305;\nconst int MOD=1e9+7;\n\ntypedef long long ll;\ntypedef long double ld;\n\nstring s;\nint k, n, dp[N][N][N];\n\nint solve(int i, int j, int left)\n{\n    if(left<0)\n        return -1e9;\n    if(i==j)\n        return 1;\n    if(i>j)\n        return 0;\n    if(dp[i][j][left]!=-1)\n        return dp[i][j][left];\n    int ret=0;\n    if(s[i]==s[j])\n        ret=solve(i+1, j-1, left)+2;\n    else\n        ret=solve(i+1, j-1, left-1)+2;\n    ret=max(ret, solve(i+1, j, left));\n    ret=max(ret, solve(i, j-1, left));\n    // printf(\"%d %d %d %d\\n\", i, j, left, ret);\n    return dp[i][j][left]=ret;\n}\n\nint main() \n{\n    cin>>s>>k;\n    n=s.length();\n    memset(dp, -1, sizeof(dp));\n    printf(\"%d\\n\", solve(0,n-1,k));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#define MN 300\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nchar st[MN+5];\nint f[MN/2+5][MN/2+5][MN/2+5],g[MN/2+5][MN/2+5][MN/2+5],n,K,ans=0;\ninline void R(int&x,int y){y>x?x=y:0;}\nvoid Solve()\n{\n\tmemset(f,200,sizeof(f));f[0][0][0]=0;\n\tfor(int k=0;k<=K;++k)\n\t\tfor(int i=0;i<=n>>1;++i)\n\t\t\tfor(int j=0;j<=n>>1;++j) if(f[k][i][j]>=0)\n\t\t\t{\n\t\t\t\tR(f[k+1][i][j],f[k][i][j]);\n\t\t\t\tR(f[k][i+1][j],f[k][i][j]);\n\t\t\t\tR(f[k][i][j+1],f[k][i][j]);\n\t\t\t\tif(i<n>>1&&j<n>>1&&st[i+1]==st[n-j]) R(f[k][i+1][j+1],f[k][i][j]+1);\n\t\t\t\telse R(f[k+1][i+1][j+1],f[k][i][j]+1);\n\t\t\t}\n\tmemset(g,200,sizeof(g));\n\tfor(int i=1;i<=n+1>>1;++i) for(int j=0;j<=K;++j) g[j][i][i]=1,g[j][i+1][i]=0;\n\tfor(int k=0;k<=K;++k)\n\t\tfor(int i=n+1>>1;i;--i)\n\t\t\tfor(int j=i;j<=n+1>>1;++j)\n\t\t\t{\n\t\t\t\tR(g[k][i][j],g[k][i][j-1]);\n\t\t\t\tR(g[k][i][j],g[k][i+1][j]);\n\t\t\t\tif(k) R(g[k][i][j],g[k-1][i][j]),R(g[k][i][j],g[k-1][i+1][j-1]+2);\n\t\t\t\tif(st[i]==st[j]) R(g[k][i][j],g[k][i+1][j-1]+2);\n\t\t\t\t//cout<<k<<\" \"<<i<<\" \"<<j<<\" \"<<st[i]<<\" \"<<st[j]<<\" \"<<g[k][i][j]<<endl;\n\t\t\t}\n\tfor(int i=0;i<=n>>1;++i) for(int j=0;j<=K;++j)\n\t\tans=max(ans,f[j][i][n>>1]*2+(i<(n+1)>>1?g[K-j][i+1][n>>1]:0));\n\tif(n&1) ans=max(ans,2*f[K][n>>1][n>>1]+1);\n}\nint main()\n{\n\tscanf(\"%s\",st+1);n=strlen(st+1);K=read();\n\tif(K>n>>1) return 0*printf(\"%d\\n\",n);\n\tSolve();\n\tfor(int l=1,r=n;l<r;++l,--r) swap(st[l],st[r]);\n\tSolve();\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\ntypedef long long ll ;\nint x, dp[303][303]; \nstring a, b; \nint main()\n{\n\tcin >> a >> x ;\n\tb = a ;\n\treverse(a.begin(), a.end()) ;\n\tfor(int i = 1 ; i <= a.size() ; i ++){\n\t\tfor(int j = 1 ; j <= a.size() ; j ++){\n\t\t\tif(a[i-1] == b[j-1])\n\t\t\t\tdp[i][j] = dp[i-1][j-1] + 1 ;\n\t\t\telse \n\t\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]) ;\n\t\t}\n\t}\n\tint ans = a.size() ;\n\tans = min(ans, dp[a.size()][a.size()]+2*x) ;\n\tcout << ans ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n\tstring s;\n\tint k;\n\tcin>>s; cin>>k;\n\tint n=s.size();\n\tint dp[301][301][301]={};\n\tfor(int l=0; l<=k; l++){\n\t\tfor(int i=0; i+1<n; i++){\n\t\t\tdp[l][i][i+1]=1;\n\t\t}\n\t}\n\tfor(int d=2; d<=n; d++){\n\t\tfor(int l=0; l<=k; l++){\n\t\t\tfor(int i=0; i<=n-d; i++){\n\t\t\t\tif(s[i]==s[i+d-1]){\n\t\t\t\t\tdp[l][i][i+d]=max(dp[l][i][i+d], max(dp[l][i][i+d-1], max(dp[l][i+1][i+d], dp[l][i+1][i+d-1]+2)));\n\t\t\t\t}else{\n\t\t\t\t\tdp[l][i][i+d]=max(dp[l][i][i+d], max(dp[l][i][i+d-1], dp[l][i+1][i+d]));\n\t\t\t\t\tif(l+1<=k) dp[l+1][i][i+d]=max(dp[l+1][i][i+d], dp[l][i+1][i+d-1]+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int l=0; l<=k; l++){\n\t\tans=max(ans, dp[l][0][n]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    string s;\n    int change;\n    cin >> s >> change;\n    int n = s.size();\n\n    string t;\n    for (int i = n - 1; i >= 0; i--)t += s[i];\n\n    vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(n + 1, vector<int>(change + 1, -114514)));\n    for (int i = 0; i <= n; i++) {\n        for (int k = 0; k <= change; k++) {\n            dp[i][0][k] = 0;\n            dp[0][i][k] = 0;\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            for (int k = 0; k <= change; k++) {\n                if (s[i - 1] == t[j - 1])dp[i][j][k] = dp[i - 1][j - 1][k] + 1;\n                else dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k]);\n\n                if (k > 0) {\n                    dp[i][j][k] = max(dp[i][j][k], dp[i][j][k - 1]);\n                    if (s[i - 1] != t[j - 1]) {\n                        dp[i][j][k] = max(dp[i - 1][j][k - 1], dp[i][j - 1][k - 1]) + 1;\n                    }\n                }\n            }\n        }\n    }\n\n    cout << dp[n][n][change] + change << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n#define INF 1000000000\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint dp[333][333][333];\nstring s;\nint k;\n\nint dfs(int K,int L,int R)\n{\n//\tcout << K << ' ' << L << ' ' << R << endl;\n\tif(K < 0)return -100000000;\n\tif(L > R)return 0;\n\tif(dp[K][L][R] != 0)return dp[K][L][R];\n\tint ret = 0;\n\tif(s[L] == s[R])ret = max(ret,dfs(K,L+1,R-1)+2);\n\telse ret = max(ret,dfs(K-1,L+1,R-1)+2);\n\tret = max(ret,dfs(K,L+1,R));\n\tret = max(ret,dfs(K,L,R-1));\n\t\n\treturn dp[K][L][R] = ret;\n}\n\n\nint main()\n{\n\tcin >> s >> k;\n\t\n\tREP(K,333)REP(i,333)dp[K][i][i] = 1;\n\tREP(K,333)REP(i,s.size()-1)\n\t{\n\t\tif(s[i] == s[i+1])dp[K][i][i+1] = 2;\n\t\telse dp[K][i][i+1] = 1;\n\t}\n\t\n\tcout << dfs(k,0,s.size()-1) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fo(i, n) for(int i = 1; i <= n; ++i)\n#define mp make_pair\n#define F first\n#define S second\n#define pb push_back\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int N = 200200;\nconst int mod = 1e9 + 7;\nstring s;\n\nint dp[301][301][301];\n\t\n\ninline int calc(int l, int r, int k)\n{\n\tif(l > r) return 0;\n\tif(l == r)\n\t\treturn 1;\n\tif(dp[l][r][k] != -1)\n\t\treturn dp[l][r][k];\n\tint &res = dp[l][r][k];\n\tres = 0;\n\t\n\tif(s[l] == s[r])\n\t\tres = max(res, calc(l + 1, r - 1, k) + 2);\n\tres = max(res, calc(l + 1, r, k));\n\tres = max(res, calc(l, r - 1, k));\n\tif(s[l] != s[r] && k > 0)\n\t\tres = max(res, calc(l + 1, r - 1, k - 1) + 2);\n\treturn res;\n}\n\nint main()\n{\n\t//ios::sync_with_stdio(0); cin.tie(0);\n\tcin >> s;\n\tmemset(dp,-1,sizeof dp);\n\tint k;\n\tcin >> k;\n\tcout << calc(0,s.length()-1,k);\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring S;\nint n, k, ans;\nconst int N = 305;\nint F[N][N][N];\nint main()\n{\n    cin >> S; n = S.size(); cin >> k;\n    for (int l = 0; l < n; ++ l)\n        for (int r = n - 1; r >= l; -- r)\n            for (int c = 0; c <= k; ++ c)\n                if (S[l] == S[r])\n                {\n                    F[l + 1][r - 1][c] = max(F[l + 1][r - 1][c], F[l][r][c] + 1);\n                    ans = max(ans, F[l][r][c] * 2 + (l == r ? 1 : 2));\n                }\n                else\n                {\n                    if (c != k)\n                        F[l + 1][r - 1][c + 1] = max(F[l + 1][r - 1][c + 1], F[l][r][c] + 1),\n                        ans = max(ans, F[l][r][c] * 2 + 2);\n                    F[l][r - 1][c] = max(F[l][r - 1][c], F[l][r][c]);\n                    F[l + 1][r][c] = max(F[l + 1][r][c], F[l][r][c]);\n                }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define reps(i,x,n) for(int i=x; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n#define X first\n#define Y second\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\nconst ll INF = 1e9+7;\n\n\nint dp[305][305][305];\nint main(){\n\t//ios_base::sync_with_stdio(false);\n\tint N, K;\n\tstring S;\n\n\tcin >> S >> K;\n\tN = S.length();\n\n\trep(k,K+1) rep(d,N) rep(l,N) if( l+d < N ){\n\t\tint inner = dp[l+1][l+d][k];\n\t\tif( S[l] == S[l+d] ){\n\t\t\tchmax(dp[l][l+d+1][k], inner + 1 + (d>0));\n\t\t}else{\n\t\t\tchmax(dp[l][l+d+1][k+1], inner + 1 + (d>0));\n\t\t}\n\t\tchmax(dp[l+1][l+d+1][k], inner);\n\t\tchmax(dp[l][l+d][k], inner);\n\t\tchmax(dp[l][l+d+1][k], dp[l][l+d][k]);\n\t}\n\t// rep(k,K+1){\n\t// \tcout << \"k = \" << k << endl;\n\t// \trep(l,N){\n\t// \t\trep(r,N+1) cout << dp[l][r][k] << \" \";\n\t// \t\tcout << endl;\n\t// \t}\n\t// }\n\n\tint ans = 0;\n\trep(k,K+1) chmax(ans, dp[0][N][k]);\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long I64;\n\nconst double EPS = 1e-6;\nconst double PI  = acos(-1);\nconst int NMAX = 300;\n\nshort int d[NMAX+2][NMAX+2][NMAX+2];\n\nint max(int a, int b, int c)\n{\n    return max(max(a,b), c);\n}\n\nint max2(int a, int b, int c)\n{\n    return max(max(a,b), c);\n}\n\nint max(short int a, short int b, short int c)\n{\n    return max(max(a,b), c);\n}\n\nint main()\n{\n    int N, K;\n    string str;\n    cin >> str;\n    N =  str.size();\n    if( N == 1 ) {\n        cout << \"1\\n\";\n        return 0;\n    }\n    str = \"#\" + str + \"$\";\n    cin >> K;\n    int Ans=  0;\n    for( int i = 1;  i <= N;  ++i ) {\n        for( int j = N;  i < j;  --j ) {\n            d[i][j][0] = max2( d[i - 1][j][0], d[i][j + 1][0], d[i - 1][j + 1][0] + (str[i] == str[j]) );\n            Ans = max( Ans, d[i][j][0] * 2 + (i + 2 == j) );\n            Ans = max( Ans, d[i][i + 1][0] * 2 );\n            for( int k = 1;  k <= K;  ++k ) {\n                if( str[i] == str[j] )\n                    d[i][j][k] = max( d[i - 1][j][k], d[i][j + 1][k], d[i - 1][j + 1][k]+1 );\n                else\n                    d[i][j][k] = max2( d[i - 1][j][k],\n                                      d[i][j + 1][k],\n                                      d[i - 1][j + 1][k - 1] + 1 );\n                Ans = max(Ans, d[i][j][k] * 2 + (i + 2 == j));\n            }\n        }\n    }\n    cout << Ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define REP(i,n) for(int i=0;i<n;i++)\n\n\nstring st;\n\nint mem[310][310][310];\n\n\nint dfs(int l,int r,int x){\n    if(r<l){\n        return 0;\n    }\n    if(l==r){\n        return 1;\n    }\n    if(mem[l][r][x]!=-1){\n        return mem[l][r][x];\n    }\n    int res=max(dfs(l+1,r,x),dfs(l,r-1,x));\n    if(st[l]==st[r]){\n        res=max(res,dfs(l+1,r-1,x)+2);\n    }\n    if(x){\n        res=max(res,dfs(l+1,r-1,x-1)+2);\n    }\n    return mem[l][r][x]=res;\n}\n\n\nint main(){\n    cin>>st;\n    int K;\n    cin>>K;\n    REP(i,300){\n        REP(j,300){\n            REP(k,301){\n                mem[i][j][k]=-1;\n            }\n        }\n    }\n    cout<<dfs(0,st.size()-1,K)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <numeric>\n#include <cmath>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <complex>\n#include <string.h>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <iomanip>\n#include <sys/time.h>\n#include <tuple>\n#include <random>\nusing namespace std;\n\n#define endl '\\n'\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define UNIQ(v) (v).erase(unique((v).begin(), (v).end()), (v).end())\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, int> P;\ntypedef vector< vector<ld> > matrix;\nstruct pairhash {\npublic:\n    template<typename T, typename U>\n    size_t operator()(const pair<T, U> &x) const {\n\tsize_t seed = hash<T>()(x.first);\n\treturn hash<U>()(x.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n};\nconst int inf = 1e9 + 9;\nconst ll mod = 1e9 + 7;\nconst double eps = 1e-8;\nconst double pi = acos(-1);\n\nstring s;\nint k;\n\nint dp[310][310][310];\n\nint calc(int l, int r, int x) {\n    if (l == r) return 1;\n    if (l > r) return 0;\n    if (dp[l][r][x] < 0) {\n        int res = 0;\n        if (s[l] == s[r]) {\n            res = calc(l+1, r-1, x) + 2;\n        } else if (x > 0) {\n            res = calc(l+1, r-1, x-1) + 2;\n        }\n        res = max(res, calc(l+1, r, x));\n        res = max(res, calc(l, r-1, x));\n        \n        dp[l][r][x] = res;\n    }\n    return dp[l][r][x];\n}\n\nint solve() {\n    memset(dp, -1, sizeof(dp));\n    return calc(0, (int)s.size()-1, k);\n}\n\nvoid input() {\n    cin >> s >> k;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(15);\n\n    input();\n    cout << solve() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint n,m,i,j,k,hh,ans,f[302][302][302];\nchar s[1010];\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tscanf(\"%d\",&m);\n\tmemset(f,210,sizeof(f));\n\tf[0][n+1][0]=0;\n\tfor(i=1;i<=n;i++){\n\t\tf[i][n+1][0]=0;\n\t for(j=n;j>=i;j--)\n\t  for(k=0;k<=m;k++){\n\t \tf[i][j][k]=max(f[i-1][j][k],f[i][j+1][k]);\n\t \tif(s[i]==s[j]){\n\t\t   f[i][j][k]=max(f[i][j][k],f[i-1][j+1][k]+1);\n\t\t   if(i==j)ans=max(ans,(f[i-1][j+1][k]+1)*2-1);\n\t\t    else ans=max(ans,(f[i-1][j+1][k]+1)*2);\n\t}\n\t \t else if(k){\n\t\t   f[i][j][k]=max(f[i][j][k],f[i-1][j+1][k-1]+1);\n\t\t   hh=f[i-1][j+1][k-1]+1;\n\t\t   hh*=2;\n\t\t   if(i==j)hh--;\n\t\t   ans=max(ans,hh);\n\t}\n\t \t//ans=max(ans,f[i][j][k]);\n\t }\n  }\n    printf(\"%d\",ans);\n}\n/*\n最后的lcs中l<r的部分确定下来，l>r的部分肯定是跟前者对称的（如果有更优的话那前面一部分肯定也会选更优的） \n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long int int64;\n\n\nconst int N = 305;\nchar str[N];\n\nint dp[N][N][N];\nint ans;\n\nvoid upd(int &a, int b)\n{\n    a = max(a, b);\n    ans = max(ans, b);\n}\n\n\nint main(int,  char **)\n{\n#ifdef LOCAL\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n    int k;\n    scanf(\"%s\", str + 1);\n    scanf(\"%d\", &k);\n    int n = strlen(str + 1);\n\n    for (int i = 1; i <= n; i++)\n        for (int j = n; j >= i; j--)\n            for (int h = 0; h <= k; h++)\n            {\n                int cur = dp[i][j][h];\n                upd(dp[i + 1][j][h], cur);\n                upd(dp[i][j - 1][h], cur);\n                if (str[i] == str[j] )\n                {\n                    if (i == j) upd(dp[i + 1][j - 1][h], cur + 1);\n                    else upd(dp[i + 1][j - 1][h], cur + 2);\n                }\n                else if (h < k)\n                {\n                    if (i == j) upd(dp[i + 1][j - 1][h + 1], cur + 1);\n                    else upd(dp[i + 1][j - 1][h + 1], cur + 2);\n                }\n            }\n    printf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//wls niubi!\n#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\nconst LL mod = 1e9 + 7;\ninline int read()\n{\n\tint x = 0,f = 1;char ch = getchar();\n\tfor(;!isdigit(ch);ch = getchar())if(ch == '-')f = -f;\n\tfor(;isdigit(ch);ch = getchar())x = 10 * x + ch - '0';\n\treturn x * f;\n}\nint n,K;\nchar ch[500];\nint f[500][500][500];\nint main()\n{\n\tscanf(\"%s\",ch + 1);n = strlen(ch + 1);K = read();\n\tfor(int i=1;i<=n;i++)for(int j=0;j<=K;j++)f[i][i][j] = 1;\n\tfor(int l=2;l<=n;l++)\n\t{\n\t\tfor(int i=1;i+l-1<=n;i++)\n\t\t{\n\t\t\tint j = i + l - 1;\n\t\t\tfor(int k=0;k<=K;k++)\n\t\t\t{\n\t\t\t    f[i][j][k] = max(f[i - 1][j][k],f[i][j - 1][k]);\n\t\t\t    if(ch[i] == ch[j])f[i][j][k] = max(f[i][j][k],f[i + 1][j - 1][k] + 2);\n\t\t\t    if(k)f[i][j][k] = max(f[i][j][k],f[i + 1][j - 1][k - 1] + 2);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int k=0;k<=K;k++)ans = max(ans,f[1][n][k]);\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define int long long\n#define REP(i, n) for (int i = 0; i < (int)n; ++i)\n#define RREP(i, n) for (int i = (int)n - 1; i >= 0; --i)\n#define FOR(i, s, n) for (int i = s; i < (int)n; ++i)\n#define RFOR(i, s, n) for (int i = (int)n - 1; i >= s; --i)\n#define ALL(a) a.begin(), a.end()\n#define IN(a, x, b) (a <= x && x < b)\ntemplate<class T>istream&operator >>(istream&is,vector<T>&vec){for(T&x:vec)is>>x;return is;}\ntemplate<class T>inline void out(T t){cout << t << \"\\n\";}\ntemplate<class T,class... Ts>inline void out(T t,Ts... ts){cout << t << \" \";out(ts...);}\ntemplate<class T>inline bool CHMIN(T&a,T b){if(a > b){a = b;return true;}return false;}\ntemplate<class T>inline bool CHMAX(T&a,T b){if(a < b){a = b;return true;}return false;}\nconstexpr int INF = 1e18;\n\nint dp[303][303][303];\n\nsigned main(){\n\tstring s;\n\tint K;\n\tcin >> s >> K;\n\tint N = s.size();\n\tREP(i, N) {\n\t\tREP(j, N) {\n\t\t\tif(i > N - j - 1) continue;\n\t\t\tREP(k, N) {\n\t\t\t\tCHMAX(dp[i + 1][j][k], dp[i][j][k]);\n\t\t\t\tCHMAX(dp[i][j + 1][k], dp[i][j][k]);\n\t\t\t\tCHMAX(dp[i + 1][j + 1][k + (s[i] != s[N - j - 1])], dp[i][j][k] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tREP(i, N) REP(j, N) REP(k, K + 1) if(i + j <= N)CHMAX(ans, dp[i][j][k] * 2 - (i + j != N));\n\tout(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\n#include<list>\n#include <cstring>\n#include <functional>\n//#include<unordered_map>\n//#include<unordered_set>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define INF ((1<<30)-1)\n#define LINF ((Int)1<<60)\n#define EPS (1e-10)\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n#define RREP(i,n) for(int i=1; i<=(int)(n); ++i)\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef vector<double> vec;\ntypedef vector<vec> mat;\nconst int N = 100005;\n//////////////////////////////\n\nstring s;\nint k;\nint dp[330][330][330];\n\nvoid solve()\n{\n\tcin >> s;\n\tcin >> k;\n\tint n = s.size();\n\tREP(i, n) REP(l, n) REP(x, k + 1) {\n\t\tint r = l + i;\n\t\tif (l > r || n <= r) continue;\n\t\t\n\t\tif (l == r) { dp[l][r][x] = 1; continue; }\n\t\tif (r - l + 1 <= 2 * x) { dp[l][r][x] = r - l + 1; continue; }\n\t\tif (s[l] == s[r]) dp[l][r][x] = dp[l + 1][r - 1][x] + 2;\n\t\telse if(x > 0) dp[l][r][x] = max(dp[l + 1][r - 1][x - 1] + 2, max(dp[l + 1][r][x], dp[l][r - 1][x]));\n\t\telse dp[l][r][x] = max(dp[l + 1][r][x], dp[l][r - 1][x]);\n\t}\n\tcout << dp[0][n - 1][k] << endl;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout << fixed << setprecision(13);\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nstring s,t;\nint dp[310][310][310] = {};\nint main(){\n\tint i,j,l,n,k;\n\tcin >> s >> k; n = s.size();\n\tfor(i=0;i<n;i++){\n\t\tt.push_back(s[n - 1 - i]);\n\t}\n\tassert(k==0);\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++){\n\t\t\tfor(l=0;l<=k;l++){\n\t\t\t\tif(s[i - 1]==t[j - 1]){\n\t\t\t\t\tdp[i][j][l] = dp[i - 1][j - 1][l] + 1;\n\t\t\t\t}else{\n\t\t\t\t\tint x = max(dp[i - 1][j][l],dp[i][j - 1][l]);\n\t\t\t\t\tif(l>0) x = max(x,dp[i - 1][j - 1][l - 1] + 1);\n\t\t\t\t\tdp[i][j][l] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(i=0;i<n;i++){\n\t\tif(n&1){\n\t\t\tans = max(ans,2*dp[i][n - 1 - i][k] + 1);\n\t\t}else{\n\t\t\tans = max(ans,2*dp[i][n - i][k]);\n\t\t}\n\t}\n\tcout << max(dp[n][n][0],ans) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 305\n\nusing namespace std;\nint dp[maxn][maxn][maxn],n,k,l,r;\nchar s[maxn];\n\nint main()\n{\n    scanf(\"%s\",s); scanf(\"%d\",&k); n=strlen(s);\n    for (int i=0;i<n;i++) dp[i][i][0]=1;\n    for (int i=1;i<n;i++) dp[i][i-1][0]=0;\n    for (int i=1;i<n;i++)\n        for (int j=0;j+i<n;j++)\n        {\n            l=j; r=j+i;\n            for (int m=0;m<=k;m++)\n            {\n                dp[l][r][m]=max(dp[l+1][r][m],dp[l][r-1][m]);\n                if (m>0) dp[l][r][m]=max(dp[l][r][m-1],dp[l][r][m]);\n                if (m-(s[l]!=s[r])>=0) dp[l][r][m]=max(dp[l][r][m],dp[l+1][r-1][m-(s[l]!=s[r])]+2);\n            }\n        }\n    cout << dp[0][n-1][k] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define X first\n#define Y second\n#define smin(x , y) x = min(x , y)\n#define smax(x , y) x = max(x , y)\n#define all(v) v.begin() , v.end()\n//#define int long long\n\ntypedef long long ll;\n\nconst ll INF = 1e18 , MAXN= 310;\n\nstring s ; \nint K ; \n\nint dp[MAXN][MAXN][MAXN] ; \n\nint32_t main()\n{\n \tios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\tcin >> s >> K  ; \n\tstring t = s ;\n\treverse(t.begin() , t.end() ) ; \n  \tint n = s.size();\n  \tfor(int k=0 ; k<=K ; k++)\n  \t{\n\t\tfor(int i=0; i<=n ; i++)\n\t\t{\n\t\t\tfor(int j=0 ; j<=n ; j++)\n\t\t\t{\n\t\t\t\tif(i == 0 || j==0)\n\t\t\t\t\tdp[i][j][k] = 0 ; \n\t\t\t\telse if(s[i-1] == t[j-1])\n\t\t\t\t\tdp[i][j][k] = dp[i-1][j-1][k] + 1 ; \n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i][j][k] = max(dp[i-1][j][k] , dp[i][j-1][k]) ; \n\t\t\t\t\tif(k>0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][j][k] = max(dp[i][j][k] , dp[i-1][j-1][k-1] + 2) ; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n\tcout << dp[n][n][K] << endl ; \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\ntypedef double ld;\ntypedef pair<ld, ld> pdd;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define fastIO ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 305;\nint dp[N][N][N];\n\nint main(){\n  fastIO;\n  string s;\n  cin >> s;\n  int k;\n  cin >> k;\n  int n = s.size();\n  for(int i = 0 ; i < n; i ++ ){\n    dp[i][i][0] = 1;\n    if(i + 1 < n){\n      if(s[i] == s[i + 1]){\n        dp[i][i + 1][0] = 2;\n      }\n      else{\n        dp[i][i + 1][0] = 1;\n        dp[i][i + 1][1] = 2;\n      }\n    }\n  }\n  int r;\n  int cost;\n  for(int len = 3; len <= n; len ++ ){\n    for(int l = 0 ; l + len - 1 < n; l ++ ){\n      r = l + len - 1;\n      for(int t = 0 ; t <= k ; t ++ ){\n        dp[l][r][t] = max(dp[l][r-1][t], dp[l+1][r][t]);\n        cost = (s[l] != s[r]);\n        if(t - cost >= 0){\n          dp[l][r][t] = max(dp[l][r][t], dp[l+1][r-1][t - cost] + 2);\n        }\n      }\n    }\n  }\n  int ans = 0;\n  for(int t = 0 ;t <= k ; t ++ ) ans = max(ans, dp[0][n-1][t]);\n  cout << ans << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nchar s[1002]; int k;\nint vis[302][302][302], dp[302][302][302];\nint dfs(int l, int r, int k) {\n    if (k < 0) return - 100000;\n    if (l == r)return 1;\n    if (l > r) return 0;\n    if (vis[l][r][k]) return dp[l][r][k];\n    vis[l][r][k] = 1;\n    \n    int mx = max(dfs(l, r, k-1), 0);\n\n    if (s[l] == s[r]) {\n        mx = max(dfs(l+1,r-1,k) + 2, mx);\n    } else {\n        mx = max(dfs(l+1,r-1,k), mx);\n        mx = max(dfs(l+1,r-1,k-1) + 2, mx);\n    }\n    mx = max(dfs(l+1,r,k), mx);\n    mx = max(dfs(l,r-1,k), mx);\n    return dp[l][r][k] = mx;\n}\nint main() {\n    scanf(\"%s %d\", s+1, &k);\n    int n = strlen(s+1);\n    int ans = dfs(1,n,k);\n    printf(\"%d\\n\", ans);\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//MIPT Cryptozoology 17.2\n#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\ntypedef long long li;\ntypedef long double ld;\nvoid solve(__attribute__((unused)) bool);\nvoid precalc();\nclock_t start;\n#define FILENAME \"\"\n\nint main() {\n#ifdef AIM\n    string s = FILENAME;\n    //assert(!s.empty());\n    freopen(\"/home/alexandero/ClionProjects/cryptozoology/input.txt\", \"r\", stdin);\n#else\n    //freopen(FILENAME \".in\", \"r\", stdin);\n    //freopen(FILENAME \".out\", \"w\", stdout);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#endif\n    start = clock();\n    int t = 1;\n#ifndef AIM\n    cout.sync_with_stdio(0);\n    cin.tie(0);\n#endif\n    precalc();\n    cout.precision(10);\n    cout << fixed;\n    //cin >> t;\n    int testNum = 1;\n    while (t--) {\n        //cout << \"Case #\" << testNum++ << \": \";\n        //cerr << testNum << endl;\n        solve(true);\n        //cerr << testNum - 1 << endl;\n    }\n    cout.flush();\n#ifdef AIM1\n    while (true) {\n      solve(false);\n  }\n#endif\n\n#ifdef AIM\n    cout.flush();\n    auto end = clock();\n\n    usleep(10000);\n    print_stats(end - start);\n    usleep(10000);\n#endif\n\n    return 0;\n}\n\nvoid precalc() {\n}\n\ntemplate<typename T>\ninline T nxt() {\n    T cur;\n    cin >> cur;\n    return cur;\n}\n\n//#define int li\n//const int mod = 1000000007;\n\ntemplate<typename T>\nvoid relax_max(T& cur, T val) {\n    cur = max(cur, val);\n}\n\nconst int C = 303;\nint dp[C][C][C];\n\nvoid solve(__attribute__((unused)) bool read) {\n    string s;\n    int k;\n    cin >> s >> k;\n    int n = s.length();\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 0; j <= n; ++j) {\n            for (int r = 0; r <= n; ++r) {\n                dp[i][j][r] = -(int)1e9;\n            }\n        }\n    }\n    dp[0][n - 1][0] = 0;\n    int res = 0;\n    for (int l = 0; l < n; ++l) {\n        for (int r = n - 1; r >= 0 && r >= l - 1; --r) {\n            for (int used = 0; used <= k; ++used) {\n                if (r < l) {\n                    relax_max(res, dp[l][r][used]);\n                    continue;\n                }\n                //cout << l << \" \" << r << \" \" << used << \" \" << dp[l][r][used] << endl;\n                relax_max(res, dp[l][r][used] + 1);\n                relax_max(dp[l + 1][r][used], dp[l][r][used]);\n                if (r > 0) {\n                    relax_max(dp[l][r - 1][used], dp[l][r][used]);\n                }\n                if (l < r) {\n                    if (s[l] == s[r]) {\n                        relax_max(dp[l + 1][r - 1][used], dp[l][r][used] + 2);\n                    }\n                    relax_max(dp[l + 1][r - 1][used + 1], dp[l][r][used] + 2);\n                }\n            }\n        }\n    }\n\n    cout << res << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ll long long\n#define pii pair <int, int>\n#define x first\n#define y second\n\nusing namespace std;\n\nstring s;\nint dp[301][301][301];\n\ninline int solve(int l, int r, int k) {\n    if (k < 0)\n        return INT_MIN;\n    if (r - l < 1)\n        return r - l + 1;\n    if (dp[l][r][k] != -1)\n        return dp[l][r][k];\n    return dp[l][r][k] = max(solve(l + 1, r - 1, k - (s[l] != s[r])) + 2, max(solve(l + 1, r, k), solve(l, r - 1, k)));\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint k;\n    cin >> s >> k;\n    memset(dp, -1, sizeof(dp));\n    return cout << solve(0, s.length() - 1, k), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = (int) 1e9;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  string s;\n  int t;\n  cin >> s >> t;\n  int n = (int) s.size();\n  vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(n + 1, vector<int>(t + 2, 0)));\n  for (int k = 0; k <= t; k++) {\n    for (int len = 1; len <= n; len++) {\n      for (int i = 0; i + len <= n; i++) {\n        for (int k = 0; k <= t; k++) {\n          int j = i + len - 1;\n          dp[i][j][k] = max(dp[i][j][k], max(dp[i + 1][j][k], j - 1 < 0 ? 0 : dp[i][j - 1][k]));\n          if (s[i] == s[j]) {\n            dp[i][j][k] = max(dp[i][j][k], 1 + (i < j) + (j - 1 < 0 ? 0 : dp[i + 1][j - 1][k]));\n            dp[i][j][k + 1] = max(dp[i][j][k + 1], dp[i][j][k]);\n          } else {\n            dp[i][j][k + 1] = max(dp[i][j][k + 1], 2 + (j - 1 < 0 ? 0 : dp[i + 1][j - 1][k]));\n          }\n        }\n      }\n    }\n  }\n  cout << dp[0][n - 1][t] << '\\n'; \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint dp[305][305][305],k;\nchar a[305];\ninline int dfs(int l,int r,int x) {\n\tif(l>r) return 0;if(l==r) return 1;if(~dp[l][r][x]) return dp[l][r][x];\n\tint rt=max(dfs(l,r-1,x),dfs(l+1,r,x));\n\tif(a[l]==a[r]) rt=max(rt,2+dfs(l+1,r-1,x));\n\tif(x) rt=max(rt,2+dfs(l+1,r-1,x-1));\n\tdp[l][r][x]=rt;\n\treturn rt;\n}\nint main()\n{\n\tscanf(\"%s%d\",a+1,&k);memset(dp,-1,sizeof(dp));\n\tprintf(\"%d\",dfs(1,strlen(a+1),k));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pb emplace_back\n#define x first\n#define y second\n#define sz(a) ((int)(a).size())\n#define rep(i,a,b) for(auto i=(a); i<(b); i++)\n#define dec(i,n,a) for(auto i=(n); i>=(a); i--)\n#define clr(a,v) memset(a, v, sizeof(a))\n#define all(a) (a).begin(),(a).end()\n#define EPS 2e-9\n#define fcin ios_base::sync_with_stdio(false)\n#define db(x) cerr << #x << \" == \" << x << endl\n#define _ << \" \" <<\n#define MAXN 202020\n#define LOGN 20\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nchar s[303];\nint pd[303][303][303];\n\nint solve(int l, int r, int k){\n\tif(r<l) return 0;\n\tif(r==l) return 1;\n\tint & ret = pd[l][r][k];\n\tif(ret != -1) return ret;\n\tret = max(solve(l+1,r,k),solve(l,r-1,k));\n\tif(s[l]==s[r]) ret = max(ret, solve(l+1,r-1,k)+2);\n\telse if(k) ret = max(ret, solve(l+1,r-1,k-1)+2);\n\treturn ret;\n}\n\nint main(){\n\tclr(pd,-1);\n\tint n, k;\n\tscanf(\"%s%d\", s, &k);\n\tn = strlen(s);\n\tprintf(\"%d\\n\", solve(0,n-1,k));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#define ll long long\nusing namespace std;\n\nconst int MAXN = 310;\n\nint N, M, dp[MAXN][MAXN];\nchar str[MAXN];\n\nint main() {\n    int a, b, k;\n    scanf(\"%s%d\", str + 1, &M); N = strlen(str + 1);\n\n    for(a = 1; a <= N; a++) for(b = 1; b <= N; b++) {\n        dp[a][b] = max(dp[a][b - 1], dp[a - 1][b]);\n        if(str[a] == str[N - b + 1]) dp[a][b] = max(dp[a][b], dp[a - 1][b - 1] + 1);\n    }\n\n    int Ans = min(N, dp[N][N] + 2 * M);\n    printf(\"%d\", Ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define llu unsigned long long\n#define ld double\n#define llu unsigned long long\n#define rep(i,x,y)  for(ll i=x;i<y;++i)\n#define For(i,x,y)  for(ll i=x;i<=y;++i)\n#define FOr(i,x,y)  for(ll i=x;i>=y;--i)\n#define pi acos(-1)\n#define mk make_pair<ll,ll>\n#define pa pair<ll,ll>\n#define lf else if\n#define max(x,y)    ((x)<(y)?(y):(x))\n#define min(x,y)    ((x)<(y)?(x):(y))\n#define sqr(x)      ((x)*(x))\n#define abs(x)      ((x)>0?(x):-(x))\n#define Mul(x,y)    ((x)=1LL*(x)*(y)%mod)\n#define Add(x,y)    ((x)=((x)+(y))%mod)\n#define Max(x,y)    ((x)=((x)<(y)?(y):(x)))\n#define Min(x,y)    ((x)=((x)>(y)?(y):(x)))\n#define E(x)        return writeln(x),0\n#define p(x)        printf(\"~%lld~\\n\",x)\n#define pp(x,y)     printf(\"~~%lld %lld~~\\n\",x,y)\n#define ppp(x,y,z)  printf(\"~~~%lld %lld %lld~~~\\n\",x,y,z)\n#define pppp(a,b,c,d)\tprintf(\"~~~%lld %lld %lld %lld\\n\",a,b,c,d)\n#define f_in(x)     freopen(x,\"r\",stdin)\n#define f_out(x)    freopen(x,\"w\",stdout)\n#define open(x)     f_in(x\".in\"),f_out(x\".out\")\n#define fi first\n#define se second\ntypedef complex<double> E;\nnamespace SHENZHEBEI{\n#define NEG 1\n#ifdef LOCAL\n    struct _{_(){freopen(\"cf.in\",\"r\",stdin);}}_;\n#endif \n#if NEG\n    inline ll read(){    ll x=0,f=1; char ch=getchar();   for (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;  for (;isdigit(ch);ch=getchar())  x=x*10-48+ch;   return x*f; }\n    inline void write(ll x){    if (x<0) putchar('-'),x=-x;  if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#else\n    inline ll read(){    ll x=0; char ch=getchar();   for (;!isdigit(ch);ch=getchar());    for (;isdigit(ch);ch=getchar())  x=x*10-48+ch;   return x;   }\n    inline void write(ll x){    if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#endif\n    inline char readchar(){ char ch=getchar();   for(;isspace(ch);ch=getchar());  return ch;  }\n    inline ll readstr(char *s){ char ch=getchar();   int cur=0;  for(;isspace(ch);ch=getchar());      for(;!isspace(ch);ch=getchar())  s[cur++]=ch;    s[cur]='\\0';    return cur; }\n    inline void writeln(ll x){  write(x);   puts(\"\");   }\n    inline ld getreal(){    static ld lbc;  scanf(\"%lf\",&lbc);  return lbc; }\n}using namespace SHENZHEBEI;\nchar s[310];ll f[310][310][310],n,m;\nint main(){\n\tn=readstr(s+1),m=read();\n\tmemset(f,60,sizeof f);\n\tFor(i,0,n+1){\n\t\tmemset(f[i][i],0,sizeof f[i][i]);\n\t\tif (i)memset(f[i][i-1],0,sizeof f[i][i-1]);\n\t}\n\tFor(len,2,n){\n\t\tFor(i,1,n){\n            ll j=i+len-1;\n            if (j>n)break;\n            For(k,0,m){\n                if (k)\tf[i][j][k]=f[i+1][j-1][k-1];\n                if (s[i]==s[j])Min(f[i][j][k],f[i+1][j-1][k]);\n                Min(f[i][j][k],f[i+1][j][k]+1);\n                Min(f[i][j][k],f[i][j-1][k]+1);\n            }\n        }\n    }\n    writeln(n-f[1][n][m]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#define SIZE 305\n#define INF 1000000005\n\nusing namespace std;\n\nchar str[SIZE];\nint dp[SIZE][SIZE];\nint nxt[SIZE][SIZE];\n\nint main()\n{\n\tscanf(\"%s\",&str);\n\tint K;\n\tscanf(\"%d\",&K);\n\tint n=strlen(str);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=i;j<n;j++)\n\t\t{\n\t\t\tdp[i][j]=0;\n\t\t}\n\t}\n\tint mx=1;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tfor(int l=0;l<n;l++)\n\t\t{\n\t\t\tfor(int r=l;r<n;r++)\n\t\t\t{\n\t\t\t\tnxt[l][r]=INF;\n\t\t\t\tif(dp[l][r]>K) dp[l][r]=INF;\n\t\t\t}\n\t\t}\n\t\tfor(int l=0;l<n;l++)\n\t\t{\n\t\t\tfor(int r=n-1;r>=l;r--)\n\t\t\t{\n\t\t\t\tif(l<r) dp[l][r-1]=min(dp[l][r-1],dp[l][r]);\n\t\t\t\tif(l+1<=r) dp[l+1][r]=min(dp[l+1][r],dp[l][r]);\n\t\t\t}\n\t\t}\n\t\tfor(int l=0;l<n;l++)\n\t\t{\n\t\t\tfor(int r=l;r<n;r++)\n\t\t\t{\n\t\t\t\tif(dp[l][r]!=INF)\n\t\t\t\t{\n\t\t\t\t\tif(l==r) mx=max(mx,2*i+1);\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tmx=max(mx,2*i);\n\t\t\t\t\t\tif(str[l]==str[r])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmx=max(mx,2*i+2);\n\t\t\t\t\t\t\tnxt[l+1][r-1]=min(nxt[l+1][r-1],dp[l][r]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(dp[l][r]<K)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmx=max(mx,2*i+2);\n\t\t\t\t\t\t\tnxt[l+1][r-1]=min(nxt[l+1][r-1],dp[l][r]+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int l=0;l<n;l++)\n\t\t{\n\t\t\tfor(int r=l;r<n;r++)\n\t\t\t{\n\t\t\t\tdp[l][r]=nxt[l][r];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",mx);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint dp[301][301][301];\nint main()\n{\n\tstring str;\n\tint q;\n\tcin>>str>>q;\n\tint l=str.size();\n//\tcout<<l<<endl;\n\tfor(int i=l-1;i>=0;i--)\n\t{\n\t\tfor(int k=0;k<=q;k++)\n\t\t\tdp[i][i][k]=1;\n\t}\n\tfor(int i=l-1;i>=0;i--)\n\t{\n\t\t\n\t\tfor(int j=i+1;j<=l-1;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=q;k++)\n\t\t\t{\n\t\t\t\t//dp[i][i][k]=1; \n\t\t\t\tif(str[i]==str[j]) dp[i][j][k]=max(dp[i+1][j-1][k]+2,dp[i][j][k]);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i][j][k]=max(dp[i+1][j][k],dp[i][j][k]);\n\t\t\t\t\tdp[i][j][k]=max(dp[i][j-1][k],dp[i][j][k]);\n\t\t\t\t\tif(k!=0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][j][k]=max(dp[i+1][j-1][k-1]+2,dp[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int k=0;k<=q;k++)\n\t\t\tans=max(ans,dp[0][l-1][k]);\n\tcout<<ans<<endl;\n } "
  },
  {
    "language": "C++",
    "code": "// author: lkx\n// Problem:\n// ID:\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define PB push_back\n#define MP make_pair\n#define PH push\n\nconst int MOD=1e9+7;\n\nstring s;\nint k;\nint f[305][305][305];\nint ans=0;\n\nint main()\n{\n\tcin>>s>>k;\n\tfor(int i=s.size()-1;i>=0;i--)\n\t{\n\t\tfor(int j=i;j<s.size();j++)\n\t\t{\n\t\t\tfor(int ch=0;ch<=k;ch++)\n\t\t\t{\n\t\t\t\tif(i==j) f[i][j][ch]=1;\n\t\t\t\telse if(i+1==j) f[i][j][ch]=((ch>0)?2:1+(s[i]==s[j]));\n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tf[i][j][ch]=max(f[i+1][j][ch],f[i][j-1][ch]);\n\t\t\t\t\tif(s[i]==s[j]) f[i][j][ch]=max(f[i+1][j-1][ch]+2,f[i][j][ch]);\n\t\t\t\t\tif(ch>0) f[i][j][ch]=max(f[i+1][j-1][ch-1]+2,f[i][j][ch]);\n\t\t\t\t}\n\t\t\t//\tprintf(\"i=%d j=%d ch=%d res=%d\\n\",i,j,ch,f[i][j][ch]);\n\t\t\t\tans=max(ans,f[i][j][ch]);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nint dp[310][310][160];\nint d2[310][310][310];\nstring s;\nint cal(int x,int y,int z){\n\tif(d2[x][y][z]>=0) return d2[x][y][z];\n\tif(x==y) return d2[x][y][z]=1;\n\tif(x>y) return d2[x][y][z]=0;\n\tint ret=0;\n\tif(s[x]==s[y]) ret=max(ret,cal(x+1,y-1,z)+2);\n\tif(z>0) ret=max(ret,cal(x+1,y-1,z-1)+2);\n\tret=max(ret,cal(x+1,y,z));ret=max(ret,cal(x,y-1,z));\n\treturn d2[x][y][z]=ret;\n}\nint main()\n{\n\tint K,n,out;\n\tcin>>s;n=s.size();cin>>K;\n\tmemset(dp,0,sizeof(dp));\n\trep(i,n+1) rep(j,n+1) rep(k,min(K,155)+1){\n\t\t//cout<<i<<' '<<j<<' '<<k<<' '<<dp[i][j][k]<<endl;\n\t\tif(i<n) dp[i+1][j][k]=max(dp[i+1][j][k],dp[i][j][k]);\n\t\tif(j<n) dp[i][j+1][k]=max(dp[i][j+1][k],dp[i][j][k]);\n\t\tif(i+j+2<=n){\n\t\t\tif(s[i]==s[n-1-j]) dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+1);\n\t\t\telse dp[i+1][j+1][k+1]=max(dp[i+1][j+1][k+1],dp[i][j][k]+1);\n\t\t}\n\t}\n\t\n\tmemset(d2,-1,sizeof(d2));\n\t//cal(0,n-1);\n\t\n\t//cout<<dp[6][9][3]<<' '<<cal(6,9)<<endl;\n\trep(i,n+1) rep(j,n+1) rep(k,min(K,155)+1){\n\t\tif(i+j>n) continue;\n\t\tout=max(out,dp[i][j][k]*2+cal(i,n-j-1,K-k));\n\t}\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\ntypedef long long ll ;\nconst ll N = 303 ;\nint dp[303][303][303], n, k;\nstring s ;\nint main()\n{\n\tfor(int i = 0 ; i < N ; i ++)\n\t\tfor(int j = 1 ; j < N ; j ++)\n\t\t\tdp[i][j][j] = 1 ; \n\tcin >> s >> k ; \n\tn = s.size() ;\n\tfor(int jump = 1 ; jump <= n ; jump ++){\n\t\tfor(int i = 1 ; i + jump <= n ; i ++){\n\t\t\tfor(int u = 0 ; u <= n ; u ++){\n\t\t\t\tdp[u][i][i+jump] = max(dp[u][i+1][i+jump], dp[u][i][i+jump-1]) ;\n\t\t\t\tif(u-(s[i-1]!=s[i+jump-1])>=0)\n\t\t\t\t\tdp[u][i][i+jump] = max(dp[u][i][i+jump], dp[u-(s[i-1]!=s[i+jump-1])][i+1][i+jump-1]+2) ;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[k][1][n] ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SORT(x) sort((x).begin(), (x).end())\n#define ALL(x) (x).begin(), (x).end()\n#define rep(i, n) for (ll i = 0; i < n; i++)\n#define reps(i, m, n) for (ll i = m; i < n; i++)\n#define repr(i, m, n) for (ll i = m; i >= n; i--)\n#define de(x) cout << #x << \"=\" << x << endl;\ntemplate <class T> bool maxi(T &a, const T &b) {\n    if (a < b) { a = b; return 1;} return 0;}\ntemplate <class T> bool mini(T &a, const T &b) {\n    if (b < a) { a = b; return 1;} return 0;}\n#define dame {cout<< \"-1\" <<\"\\n\"; return;}\n#define SP << \" \" <<\n#define INF2 1000000000000000037\n#define INF  1000000007\n#define MOD  1000000007\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P  = pair<ll,ll>;\n//--GLOBAL---------------------------------\n\nll dp[310][310][310];\n//--MAIN-----------------------------------\nvoid Main() {\n    string S; cin>>S;\n    ll N=S.size(); \n    ll K; cin>>K;\n    rep(i,N+1){\n        rep(j,N+1){\n            rep(k,K+1){\n                maxi(dp[i+1][j][k],dp[i][j][k]);\n                maxi(dp[i][j+1][k],dp[i][j][k]);\n                maxi(dp[i+1][j+1][k+1],dp[i][j][k]+1);\n                if(i<N and N-1-j>=0 and S[i]==S[N-1-j]){\n                    maxi(dp[i+1][j+1][k],dp[i][j][k]+1);\n                }\n            }\n        }\n    }\n    ll ans=0;\n    rep(k,K+1){\n        rep(i,N+1) maxi(ans,dp[i][N-i][k]*2); \n        rep(i,N) maxi(ans,dp[i][N-1-i][k]*2+1); \n    }\n    cout<< ans <<\"\\n\";\n}\n\n//--START----------------------------------\nint main() {\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    Main();\n}\n//-----------------------------------------\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing u32 = uint32_t;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define MAXC(c, x) (c = max(c, x))\n#define MINC(c, x) (c = min(c, x))\n\n#define REP(i,n) for(auto i = 0 * (n), i##_len = (n); i < i##_len; ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,n) for(ll i=s, i##_len=(ll)(n); i<i##_len; ++i)\n#define TEN(x) ((ll)1e##x)\nconst ll mod = TEN(9) + 7;\n\nconst ll INF = 1e9;\n\nint main() {\n\t#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n\t#endif\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\n\tstring s; ll K;\n\tcin >> s >> K;\n\tll n = s.size();\n\n\tll ans = -1;\n\t// dp[現在の位置（左）（変更可）][現在の位置（右）][変更回数]\n\tvector<vvl> dp(n + 1, vvl(n + 1, vl(K + 1, -1)));\n\tdp[0][0][0] = 0;\n\tREP(i, n) REP(j, n) REP(k, K + 1) {\n\t\tif (dp[i][j][k] < 0) continue;\n\t\tif (i + j + 1 == n) { // 同じ場所になったとき\n\t\t\tans = max(ans, dp[i][j][k] * 2 + 1);\n\t\t} else if (i + j == n) { // すれ違ったとき\n\t\t\tans = max(ans, dp[i][j][k] * 2);\n\t\t} else {\n\t\t\tif (s[i] == s[n - j - 1]) MAXC(dp[i + 1][j + 1][k], dp[i][j][k] + 1);\n\t\t\tif (k < K) MAXC(dp[i + 1][j + 1][k + 1], dp[i][j][k] + 1);\n\t\t\tMAXC(dp[i + 1][j][k], dp[i][j][k]);\n\t\t\tMAXC(dp[i][j + 1][k], dp[i][j][k]);\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define Kafuu signed\n#define Chino main\n\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n\n#define maxn 305\n#define inf 0x3f3f3f3f\n#define px putchar\n#define pn px('\\n')\n#define ps px(' ')\n#define pd puts(\"======================\")\n#define pj puts(\"++++++++++++++++++++++\")\n\nusing namespace std;\n\ninline int read(){\n\tint x=0,y=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn y?-x:x;\n}\ntemplate<typename T>\ninline T read(){\n\tT x=0;\n\tint y=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn y?-x:x;\n}\nint f[2][maxn][maxn];\nchar s[maxn];\nKafuu Chino(){\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1),k=read();\n\tfor(register int i=1;i<=n;++i)f[0][i][i]=1;\n\tfor(register int i=0;i<=k;++i)\n\t\tfor(register int len=2;len<=n;++len)\n\t\t\tfor(register int st=1,en=st+len-1;en<=n;++st,++en){\n\t\t\t\tf[i&1][st][en]=max(f[i&1][st+1][en],f[i&1][st][en-1]);\n\t\t\t\tif(s[st]==s[en])f[i&1][st][en]=max(f[i&1][st][en],f[i&1][st+1][en-1]+2);\n\t\t\t\tif(i)f[i&1][st][en]=max(f[i&1][st][en],f[i&1^1][st+1][en-1]+2);\n\t\t\t}\n\tprintf(\"%d\\n\",f[k&1][1][n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, ans;\nchar s[305];\nint dp[305][305][305];\nint dfs(int l, int r, int x) {\n    if(l >= r) {\n        return r - l + 1;\n    }\n    if(dp[l][r][x] != -1) {\n        return dp[l][r][x];\n    }\n    int ret = max(dfs(l + 1, r, x), dfs(l, r - 1, x));\n    if(s[l] == s[r]) {\n        ret = max(ret, dfs(l + 1, r - 1, x) + 2);\n    } else if(x) {\n        ret = max(ret, dfs(l + 1, r - 1, x - 1) + 2);\n    }\n    return dp[l][r][x] = ret;\n}\nint main() {\n    memset(dp, -1, sizeof(dp));\n    scanf(\"%s%d\", s + 1, &k);\n    n = strlen(s + 1);\n    for(int i = 1; i <= n; ++i) {\n        for(int j = i; j <= n; ++j) {\n            ans = max(ans, dfs(i, j, k));\n        }\n    } \n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring s, rs;\nint n, k;\nvector<vector<vector<int>>> dp;\n\nint solve();\n\nint main() {\n  cin >> s >> k;\n  n = s.size();\n  rs = s;\n  reverse(rs.begin(), rs.end());\n  cout << solve() << endl;\n  return 0;\n}\n\nint solve() {\n  int res = 0;\n  dp.assign(n + 1, vector(n + 1, vector<int>(k + 1, 0)));\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < n; ++j)\n      for (int l = 0; l <= k; ++l) {\n        dp[i + 1][j + 1][l] = max(dp[i + 1][j][l], dp[i][j + 1][l]);\n        if (s[i] == rs[j])\n          dp[i + 1][j + 1][l] = max(dp[i + 1][j + 1][l], dp[i][j][l] + 1);\n        else if (l != 0)\n          dp[i + 1][j + 1][l] = max(dp[i + 1][j + 1][l], dp[i][j][l - 1] + 1);\n        else\n          dp[i + 1][j + 1][l] = max(dp[i + 1][j + 1][l], dp[i][j][l]);\n      }\n  for (int i = 0; i <= n; ++i)\n    for (int j = 0; j <= n; ++j)\n      for (int l = 1; l <= k; ++l)\n        dp[i][j][l] = max(dp[i][j][l], dp[i][j][l - 1]);\n  for (int i = 0; i <= n; ++i) {\n    // even\n    res = max(res, dp[i][n - i][k] * 2);\n    // odd\n    if (i > 0) res = max(res, dp[i - 1][n - i][k] * 2 + 1);\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nchar str[305];\nint dp[305][305][305],K;\nint max(int a,int b){return a>b?a:b;}\nint main(){\n\tscanf(\"%s%d\",str,&K); int lens=strlen(str);\n\tfor(int l=1;l<lens;++l)\n\t\tfor(int i=0;i+l<lens;++i){\n\t\t\tint j=i+l;\n\t\t\tfor(int k=0;k<=K;++k){\n\t\t\t\tdp[i][j][k]=max(dp[i+1][j][k],dp[i][j-1][k]);\n\t\t\t\tif(k>0) dp[i][j][k]=max(dp[i+1][j-1][k-1]+2,dp[i][j][k]);\n\t\t\t\tif(str[i]==str[j]) dp[i][j][k]=max(dp[i+1][j-1][k]+2,dp[i][j][k]);\n\t        }\n\t    }\n\tprintf(\"%d\\n\",dp[0][lens-1][K]+1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring s, t;\nint K;\nint dp[305][305][305];\nint dpmax[305][305];\n\nint main(void)\n{\n\tcin >> s >> K;\n\tint n = s.size();\n\tt = s;\n\treverse(t.begin(), t.end());\n\ts = \"#\" + s, t = \"#\" + t;\n\t\n\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\tfor(int k = 0; k <= K; k++){\n\t\t\t\tdp[i][j][k] = -1e9;\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0] = 0;\n\t\n\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\tfor(int k = 0; k <= K; k++){\n\t\t\t\tif(i > 0 && j > 0){\n\t\t\t\t\tif(s[i] == t[j]) dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+1);\n\t\t\t\t\tif(k > 0) dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k-1]+1);\n\t\t\t\t}\n\t\t\t\tif(i > 0) dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k]);\n\t\t\t\tif(j > 0) dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\tdpmax[i][j] = -1e9;\n\t\t\tfor(int k = 0; k <= K; k++) dpmax[i][j] = max(dpmax[i][j], dp[i][j][k]);\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor(int i = 0; i <= n; i++){\n\t\tans = max(ans, dpmax[i][n-i]*2);\n\t\tif(i > 0) ans = max(ans, dpmax[i-1][n-i]*2 + 1);\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <algorithm>\n#include <vector>\n#include <bitset>\n#include <set>\n#include <unordered_set>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <iterator>\n#include <numeric>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <limits>\n#include <iomanip>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nusing ll=long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\nusing vll = V<ll>;\nusing vvll = V<vll>;\n#define rep(i, k, n) for (ll i=k; i<(ll)n; ++i)\n#define REP(i, n) rep(i, 0, n)\n#define ALL(v) v.begin(),v.end()\ntemplate < class T > inline bool chmax(T& a, T b) {if (a < b) { a=b; return true; } return false; }\ntemplate < class T > inline bool chmin(T& a, T b) {if (a > b) { a=b; return true; } return false; }\n#define DEBUG_VLL(vec) REP(sz, vec.size()) std::cerr<<vec[sz]<<(sz==vec.size()-1?'\\n':' ');\n\nconst long long MOD = 1000000007;\nconst long long HIGHINF = (long long)1e18;\nconst int INF = (int)1e9;\n\nstring s;\nint k;\nV< V< V<int> > > dp;\n\nint rec(int l, int r, int cnt) {\n    if (dp[l][r][cnt] != 0) return dp[l][r][cnt];\n    if (l == r) return dp[l][r][cnt] = 1;\n    if (l + 1 == r) {\n        if (s[l] == s[r]) return dp[l][r][cnt] = 2;\n        else {\n            if (cnt > 0) return dp[l][r][cnt] = 2;\n            else return dp[l][r][cnt] = 1;\n        }\n    }\n\n    if (s[l] == s[r]) return dp[l][r][cnt] = rec(l + 1, r - 1, cnt) + 2;\n    else {\n        dp[l][r][cnt] = max(rec(l + 1, r, cnt), rec(l, r - 1, cnt));\n        if (cnt > 0) chmax(dp[l][r][cnt], rec(l + 1, r - 1, cnt - 1) + 2);\n        return dp[l][r][cnt];\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> s >> k;\n    int sz = s.size();\n    dp.resize(sz, V< V<int> >(sz, V<int>(k + 1, 0)));\n    rec(0, sz - 1, k);\n    cout << dp[0][sz - 1][k] << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\n//const ll inf=0x3f3f3f3f3f3f3f3fll;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\nchar s[333];\nint n;\nint k;\n\nint dp[305][305][165];\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tgs(s+1);\n\tn=strlen(s+1);\n\tgn(k);\n\tupmin(k,160);\n\trep(t,0,k+1){\n\t\trep(i,1,n+1)\n\t\t\trep(j,i,n+1)\n\t\t\t\tupmax(dp[i][j][t],1);\n\t\trep(d,-1,n+1){\n\t\t\trep(i,2,n){\n\t\t\t\tint j=i+d;\n\t\t\t\tif(i-1>=1 && j+1<=n){\n\t\t\t\t\tif(s[i-1]==s[j+1]){\n\t\t\t\t\t\tupmax(dp[i-1][j+1][t],dp[i][j][t]+2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tupmax(dp[i-1][j+1][t],dp[i][j][t]);\n\t\t\t\t\t\tupmax(dp[i-1][j+1][t+1],dp[i][j][t]+2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i-1>=1)\n\t\t\t\t\tupmax(dp[i-1][j][t],dp[i][j][t]);\n\t\t\t\tif(j+1<=n)\n\t\t\t\t\tupmax(dp[i][j+1][t],dp[i][j][t]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[1][n][k]);\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#define int ll\n//#define char ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(4) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int N = 333;\nshort dp[N][N][N];\n\n\nint solve(string s, int k) {\n\n    int n = s.size();\n    string t = s;\n    reverse(ALL(t));\n\n\n    fori (i, N) {\n        fori (j, N) {\n            fori (k, N) {\n                dp[i][j][k] = n * 3;\n            }\n        }\n    }\n\n    dp[0][0][0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            for (int len = 0; len < n; ++len) if (dp[i][j][len] < n * 3) {\n                    inmin(dp[i + 1][j][len], dp[i][j][len]);\n                    inmin(dp[i][j + 1][len], dp[i][j][len]);\n                    if (s[i] == t[j])\n                        inmin(dp[i + 1][j + 1][len + 1], dp[i][j][len]);\n                    else {\n                        inmin(dp[i + 1][j + 1][len + 1], (short)(dp[i][j][len] + 1));\n                    }\n                }\n        }\n    }\n\n    int ans = 0;\n    fori (i, n + 1) {\n        fori (j, n + 1) {\n            fori (len, n + 1) {\n                if (dp[i][j][len] <= k * 2) {\n                    inmax(ans, len);\n                }\n            }\n        }\n    }\n    return ans;\n}\n\nstring reversed(string s) {\n    reverse(ALL(s));\n    return s;\n}\n\nconst int L = 2;\n\nvoid rec(string s, int i, const vi & ids, vector<string> & curs) {\n    if (i == SZ(ids)) {\n        curs.push_back(s);\n        return;\n    }\n    int id = ids[i];\n    for (char c = 'a'; c <= char('a' + L); ++c) {\n        s[id] = c;\n        rec(s, i + 1, ids, curs);\n    }\n}\n\n\nint naive(string s, int k) {\n    int n = s.size();\n    vi kek(n, 0);\n    fori (i, k) {\n        kek[i] = 1;\n    }\n    sort(ALL(kek));\n    int ans = 0;\n    do {\n        vi ids;\n        fori (i, n) {\n            if (kek[i])\n                ids.push_back(i);\n        }\n\n        vector<string> curs;\n        rec(s, 0, ids, curs);\n\n        for (auto cur : curs) {\n            inmax(ans, solve(cur, 0));\n        }\n\n    } while (next_permutation(ALL(kek)));\n\n    return ans;\n}\n\nvoid stress() {\n    int cnt = -1;\n    while (true) {\n        if (++cnt % 1 == 0)\n            watch(cnt);\n        int n = 1 + rng() % 5;\n        string s(n, 'a');\n        fori (i, n) {\n            s[i] += rng() % (L + 1);\n        }\n        int k = rng() % (n + 1);\n        int sl = solve(s, k);\n        int nv = naive(s, k);\n        if (sl != nv) {\n            watch(sl);\n            watch(nv);\n            cerr << s << '\\n' << k << endl;\n            watch(cnt);\n            exit(0);\n        }\n    }\n}\n\n\nvoid smain() {\n\n//    stress();\n\n\n    string s;\n    cin >> s;\n    int k;\n    cin >> k;\n    int n = s.size();\n    string t = s;\n    reverse(ALL(t));\n\n\n    fori (i, N) {\n        fori (j, N) {\n            fori (k, N) {\n                dp[i][j][k] = n * 3;\n            }\n        }\n    }\n\n    dp[0][0][0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            for (int len = 0; len < n; ++len) if (dp[i][j][len] < n * 3) {\n                    inmin(dp[i + 1][j][len], dp[i][j][len]);\n                    inmin(dp[i][j + 1][len], dp[i][j][len]);\n                    if (s[i] == t[j])\n                        inmin(dp[i + 1][j + 1][len + 1], dp[i][j][len]);\n                    else {\n                        inmin(dp[i + 1][j + 1][len + 1], (short)(dp[i][j][len] + 1));\n                    }\n                }\n        }\n    }\n\n    int ans = 0;\n    fori (i, n + 1) {\n        fori (j, n + 1) {\n            fori (len, n + 1) {\n                if (dp[i][j][len] <= ((len & 1) ? 2 * k + 1 : 2 * k)) {\n                    inmax(ans, len);\n                }\n            }\n        }\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\nint n, k, a[305][305][305], ans;\nchar s[305];\nint main(){\n\tscanf(\"%s\\n%d\", s, &k);\n\tn = (int)strlen(s);\n\trep(i,n) rep(j,n-1-i) rep(l,k+1){\n\t\tif(s[i] == s[n-1-j]) a[i+1][j+1][l] = a[i][j][l] + 1;\n\t\telse a[i+1][j+1][l] = max({a[i][j+1][l], a[i+1][j][l], l ? a[i][j][l-1]+1 : 0});\n\t}\n\trep(i,n+1) ans = max({ans, (i!=n?a[i][n-1-i][k]*2:0)+1, a[i][n-i][k]*2});\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    string s;\n    cin>>s;\n    int k;\n    cin>>k;\n    int n = s.size();\n    int dp[n+1][n+1][k+1];\n    int ans = 0;\n    for(int i=0; i<n+1; i++){\n        for(int j=0; j<n+1; j++){\n            for(int c=0; c<k+1; c++){\n                dp[i][j][c] = 0;\n            }\n        }\n    }\n\n\n    for(int i=0; i<n+1; i++){\n        for(int j=0; j<n+1; j++){\n            for(int c=0; c<k+1; c++){\n                if(i<n)\n                    dp[i+1][j][c] = max(dp[i][j][c],dp[i+1][j][c]);\n                if(j<n)\n                    dp[i][j+1][c] = max(dp[i][j][c],dp[i][j+1][c]);\n                if(i<n &&j<n && i+j<n){\n                    if(s[i] == s[n-1-j]){\n                         dp[i+1][j+1][c] = max(dp[i+1][j+1][c], dp[i][j][c]+1);\n                         if(i+j==n-1)\n                            ans = max(ans, 2*dp[i+1][j+1][c]-1);\n                         else\n                            ans = max(ans,2*dp[i+1][j+1][c]);\n                    }\n                    else if(c<k){\n                        dp[i+1][j+1][c+1] = max(dp[i+1][j+1][c+1], dp[i][j][c]+1);\n                         if(i+j==n-1)\n                            ans = max(ans, 2*dp[i+1][j+1][c+1]-1);\n                         else\n                            ans = max(ans,2*dp[i+1][j+1][c+1]);\n                    }\n                }\n\n\n            }\n        }\n    }\n    cout<<ans<<endl;\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n ____ ____ ____ ____ ____\n||a |||t |||o |||d |||o ||\n||__|||__|||__|||__|||__||\n|/__\\|/__\\|/__\\|/__\\|/__\\|\n\n**/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N_MAX = 302;\n\nint n;\n\nstring s;\n\nint k;\n\nint dp[N_MAX][N_MAX][N_MAX];\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> s;\n    n = s.size();\n    s = \" \" + s;\n    cin >> k;\n    for(int l = 0; l <= n; l++)\n        for(int r = n + 1; r >= 1; r--)\n            if(l >= 1 || r <= n)\n            {\n                for(int c = 0; c <= k; c++)\n                {\n                    if(l >= 1)\n                        dp[l][r][c] = max(dp[l][r][c], dp[l - 1][r][c]);\n                    if(r <= n)\n                        dp[l][r][c] = max(dp[l][r][c], dp[l][r + 1][c]);\n                    if(c >= 1)\n                        dp[l][r][c] = max(dp[l][r][c], dp[l][r][c - 1]);\n                    if(l >= 1 && r <= n)\n                    {\n                        if(s[l] == s[r])\n                            dp[l][r][c] = max(dp[l][r][c], dp[l - 1][r + 1][c] + 1);\n                        else if(c >= 1)\n                            dp[l][r][c] = max(dp[l][r][c], dp[l - 1][r + 1][c - 1] + 2);\n                    }\n                }\n            }\n    cout << dp[n][1][k] << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include <boost/multiprecision/cpp_int.hpp>\n// using i128 = boost::multiprecision::int128_t;\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = vector<int>;\nusing Vll = vector<ll>;\nusing Vld = vector<ld>;\nusing Vbo = vector<bool>;\nusing VV = vector<V>;\nusing VVll = vector<Vll>;\nusing VVld = vector<Vld>;\nusing VVbo = vector<Vbo>;\nusing VVV = vector<VV>;\nusing VVVll = vector<VVll>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\n#define rep2(i, m, n) for(int i=int(m); i<int(n); ++i)\n#define drep2(i, m, n) for(int i=int(m)-1; i>=int(n); --i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) a.begin(), a.end()\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << \" \"; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int Log2(ll x) { int k; for (k = 0; x > 0; ++k) x >>= 1; return k; } // number of binary digits\nconst int INF  = 1<<30;\nconst ll INFll = 1ll<<62;\nconst ld EPS   = 1e-10;\nconst ld PI    = acos(-1.0);\nconst int MOD  = int(1e9)+7;\n// const int MOD  = 998244353;\n\n\nint main() {\n  string s; cin >> s;\n  int K; cin >> K;\n  int n = s.size();\n\n  VVV dp(K+2, VV(n+1, V(n+1)));\n\n  rep(k, K+1) rep(i, n) rep(j, n) {\n    chmax(dp[k][i+1][j+1], dp[k][i+1][j]);\n    chmax(dp[k][i+1][j+1], dp[k][i][j+1]);\n    chmax(dp[k][i+1][j+1], dp[k][i][j] + (s[i] == s[n-1-j]));\n    chmax(dp[k+1][i+1][j+1], dp[k][i+1][j]);\n    chmax(dp[k+1][i+1][j+1], dp[k][i][j+1]);\n    chmax(dp[k+1][i+1][j+1], dp[k][i][j] + 1);\n  }\n  int ans = 0;\n  rep(i, n+1) chmax(ans, dp[K][i][n-i]*2);\n  rep(i, n) chmax(ans, dp[K][i+1][n-i]*2-1);\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * File    : D2.cpp\n * Author  : Kazune Takahashi\n * Created : 2018-2-25 19:18:18\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>   // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set>\n#include <random> // random_device rd; mt19937 mt(rd());\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\n// const ll M = 1000000007;\n\nstring S;\nint N;\nint K;\n\nint DP[310][310][310];\nint DP2[310][26];\n\nint calc(int l, int r, int k) {\n  if (r - l <= 2 * k + 1)\n    return r - l;\n  if (DP[l][r][k] != -1)\n    return DP[l][r][k];\n  int ans = 0;\n  if (l+1 <= r-1 && k-1 >= 0)\n    ans = max(ans, calc(l + 1, r - 1, k - 1) + 2);\n  if (l <= r-1)\n    ans = max(ans, calc(l, r - 1, k));\n  int nl = DP2[l][S[r - 1] - 'a'] + 1;\n  if (nl <= r-1)\n    ans = max(ans, calc(nl, r - 1, k) + 2);\n  DP[l][r][k] = ans;\n#if DEBUG == 1\n  cerr << \"DP[\" << l << \"][\" << r\n       << \"][\" << k << \"] = \" << ans << endl;\n#endif\n  return ans;\n}\n\nint main()\n{\n  cin >> S >> K;\n  N = S.size();\n  fill(&DP[0][0][0], &DP[0][0][0] + 310 * 310 * 310, -1);\n  for (auto j = 0; j < 26; j++)\n  {\n    DP2[N][j] = N;\n  }\n  for (auto i = N-1; i >= 0; i--)\n  {\n    for (auto j = 0; j < 26; j++)\n    {\n      DP2[i][j] = DP2[i + 1][j];\n    }\n    DP2[i][S[i] - 'a'] = i;\n  }\n  cout << calc(0, N, K) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef long double ld;\ntypedef vector<ld> vd;\ntypedef bool bl;\ntypedef vector<bl> vb;\ntypedef unordered_map<ll,unordered_map<ll,ll>> graph;\n\nconst ll e5 = 1 << 20;\nconst ll mod = 1000000007;\nconst ll e3 = 1 << 13;\nconst ll INF = 1ll << 60;\n\nstring s;\nstring r;\nll t;\nll dp[302][302][302];\nll ans;\n\nint main(){\n  cin >> s;\n  cin >> t;\n  r = s;\n  reverse(r.begin(),r.end());\n  // cerr << r << endl;\n  // cerr << s << endl;\n  for(ll i = 0;i < s.size();i++){\n    for(ll j = 0;j < s.size();j++){\n      for(ll k = 0;k <= t;k++){\n        if(s[i] == r[j]){\n          dp[i+1][j+1][k] = max(dp[i+1][j+1][k],dp[i][j][k]+1);\n        }else{\n          dp[i+1][j+1][k+1] = max(dp[i+1][j+1][k+1],dp[i][j][k]+1);\n        }\n        dp[i+1][j][k] = max(dp[i+1][j][k],dp[i][j][k]);\n        dp[i][j+1][k] = max(dp[i][j+1][k],dp[i][j][k]);\n      }\n    }\n  }\n  // cerr << s.size() << endl;\n  // for(ll k = 0;k <= t;k++){\n  //   for(ll i = 0;i <= s.size();i++){\n  //     for(ll j = 0;j <= s.size();j++){\n  //       cerr << dp[i][j][k] << \" \";\n  //     }\n  //     cerr << endl;\n  //   }\n  //   cerr << endl;\n  //   cerr << endl;\n  // }\n\n  for(ll i = 0;i < s.size();i++){\n    for(ll k = 0;k <= t;k++){\n      ans = max(ans,dp[i][s.size()-i-1][k]*2+1);\n    }\n  }\n  for(ll i = 1;i < s.size();i++){\n    for(ll k = 0;k <= t;k++){\n      ans = max(ans,dp[i][s.size()-i][k]*2);\n    }\n  }\n  cout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing K = double;\n\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define SIZE(a) ((int)(a).size())\n\nconst int N = 105;\n\nstruct pt {\n\tK x, y;\n} a[N];\n\ntemplate <class T>\nT sqr(T x) {\n\treturn x*x;\n}\n\nK dist(const pt& a, const pt& b) {\n\treturn sqrt(sqr(a.x-b.x) + sqr(a.y-b.y));\n}\n\nint n;\nint cnt[N];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\t\n\t\n\tcin >> n;\n\tREP(i, n) cin >> a[i].x >> a[i].y;\n\t\n\tconst int I = 2000000;\n\t\n\tK now = 2*acos(-1.0)/I;\n\t\n\tREP(iter, I) {\n\t\tK ang = iter*now;\n\t\tpt now = {cos(ang)*1e9, sin(ang)*1e9};\n\t\tint id = 0;\n\t\tREP(i, n) {\n\t\t\tif (dist(now, a[i]) < dist(now, a[id])) {\n\t\t\t\tid = i;\n\t\t\t}\n\t\t}\n\t\t++cnt[id];\n\t}\n\t\n\tREP(i, n) {\n\t\tcout << setprecision(15) << fixed << (K)cnt[i]/(K)I << '\\n';\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <numeric>\n#include <bitset>\n#include <ctime>\n#define debug(x)  cerr << #x << \" = \" << x << endl\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <ll, ll> pll;\ntypedef pair <int, int> pii;\n\nconst int maxN = 3e2 + 5;\nconst ll INF = 1e18;\nconst ll MOD = 1e9 + 7;\n\nint dp[maxN][maxN][maxN];\n\nint main(){\n\ttime_t START = clock();\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tmemset(dp, 0, sizeof dp);\n\tstring s; cin >> s;\n\tint n = s.size();\n\tint X; cin >> X;\n\tfor (int len = 0; len < n; len++)\n\t\tfor (int l = 0; l + len < n; l++){\n\t\t\tfor (int i = 0; i <= X; i++){\n\t\t\t\tint r = l + len;\n\t\t\t\tif (l == r){\n\t\t\t\t\tdp[i][l][r] = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (l + 1 < n)\n\t\t\t\t\tdp[i][l][r] = max(dp[i][l][r], dp[i][l + 1][r]);\n\t\t\t\tif (r > 0)\n\t\t\t\t\tdp[i][l][r] = max(dp[i][l][r], dp[i][l][r - 1]);\n\t\t\t\tif (s[l] == s[r])\n\t\t\t\t\tdp[i][l][r] = max(dp[i][l][r], dp[i][l + 1][r - 1] + 2);\n\t\t\t\tif (i > 0)\n\t\t\t\t\tdp[i][l][r] = max(dp[i][l][r], dp[i - 1][l + 1][r - 1] + 2);\n\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\", dp[X][0][n - 1]);\n\ttime_t FINISH = clock();\n\tcerr << \"Execution time: \" << (ld)(FINISH - START) / CLOCKS_PER_SEC * 1000.0 << \" milliseconds.\\n\";\n\treturn 0;\n}\n \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef long double ld;\ntypedef vector<ld> vd;\ntypedef bool bl;\ntypedef vector<bl> vb;\ntypedef unordered_map<ll,unordered_map<ll,ll>> graph;\n\nconst ll e5 = 1 << 20;\nconst ll mod = 1000000007;\nconst ll e3 = 1 << 13;\nconst ll INF = 1ll << 60;\n\nstring s;\nstring r;\nll t;\nll dp[400][400][400];\nll ans;\n\nint main(){\n  cin >> s;\n  cin >> t;\n  r = s;\n  reverse(r.begin(),r.end());\n  // cerr << r << endl;\n  // cerr << s << endl;\n  for(ll i = 0;i < s.size();i++){\n    for(ll j = 0;j < s.size();j++){\n      for(ll k = 0;k <= t;k++){\n        if(s[i] == r[j]){\n          dp[i+1][j+1][k] = max(dp[i+1][j+1][k],dp[i][j][k]+1);\n        }else{\n          dp[i+1][j+1][k+1] = max(dp[i+1][j+1][k+1],dp[i][j][k]+1);\n        }\n        dp[i+1][j][k] = max(dp[i+1][j][k],dp[i][j][k]);\n        dp[i][j+1][k] = max(dp[i][j+1][k],dp[i][j][k]);\n      }\n    }\n  }\n  // cerr << s.size() << endl;\n  // for(ll k = 0;k <= t;k++){\n  //   for(ll i = 0;i <= s.size();i++){\n  //     for(ll j = 0;j <= s.size();j++){\n  //       cerr << dp[i][j][k] << \" \";\n  //     }\n  //     cerr << endl;\n  //   }\n  //   cerr << endl;\n  //   cerr << endl;\n  // }\n\n  for(ll i = 0;i < s.size();i++){\n    for(ll k = 0;k <= t;k++){\n      ans = max(ans,dp[i][s.size()-i-1][k]*2+1);\n    }\n  }\n  for(ll i = 1;i < s.size();i++){\n    for(ll k = 0;k <= t;k++){\n      ans = max(ans,dp[i][s.size()-i-1][k]*2);\n    }\n  }\n  cout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[301][301][301];\nint main() {\n  string S;\n  int K;\n  cin >> S >> K;\n  for(auto i = 0; i < S.size(); ++i) dp[i][i][0] = dp[i][i+1][0] = 1;\n  for(auto w = 2; w <= S.size(); ++w) for(auto l = 0; l+w <= S.size(); ++l) {\n    auto r = l + w;\n    for(auto k = 0; k <= K; ++k) {\n      dp[l][r][k] = max({dp[l][r][k], dp[l+1][r][k], dp[l][r-1][k]});\n      if(0 < k)        dp[l][r][k] = max(dp[l][r][k], 2 + dp[l+1][r-1][k-1]);\n      if(S[l]==S[r-1]) dp[l][r][k] = max(dp[l][r][k], 2 + dp[l+1][r-1][k]);\n    }\n  }\n  cout << dp[0][S.size()][K] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define gc getchar\n#define pc putchar\n#define fi first\n#define queue QQQ\n#define se second\n#define debug(x) cout << #x\" = \" << x << endl;\n#define pp(x,y) cout << \"pp: \" << x << \" \" << y << endl;\n#define rank __RAnK\ninline ll read(){\n\tregister ll x=0,f=1;register char c=gc();\n\tfor(;!isdigit(c);c=gc())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\n#define rd read\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid writeln(ll x){write(x);puts(\"\");}\nconst int maxn = 2e5+233;\nint f[305][305][305];\nchar s[305];\nint K,n;\nint main(){\n\tscanf(\"%s\",s+1);\n\tn = strlen(s+1);\n\tK = rd();\n\tmem(f,0);\n\tRep(i,1,n) f[i][i][0] = 1;\n\tRep(len,2,n){\n\t\tfor(int i=1;i+len-1<=n;++i){\n\t\t\tint j = i + len - 1;\n\t\t\tRep(k,0,K){\n\t\t\t\tf[i][j][k] = max(f[i][j][k],f[i+1][j][k]);\n\t\t\t\tf[i][j][k] = max(f[i][j][k],f[i][j-1][k]);\n\t\t\t\tif(s[i]==s[j]) f[i][j][k] = max(f[i][j][k],f[i+1][j-1][k]+2);\n\t\t\t\tif(k)f[i][j][k] = max(f[i][j][k],f[i+1][j-1][k-1]+2);\n\t\t\t}\n\t\t}\n\t}writeln(f[1][n][K]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m, A, B;\n\nchar Ans[1010][1010];\n\nint main() {\n    scanf(\"%d%d%d%d\", &n, &m, &A, &B);\n    /*if((A + B) * 2 > n * m || A > m / 2 * n || B > n / 2 * m) {\n        puts(\"NO\");\n        return 0;\n    }*/\n    memset(Ans, '.', sizeof Ans);\n    if(n & 1) {\n        for(int i = 1; i < m && A; i += 2)\n            if(1) {\n                Ans[n][i] = '<';\n                Ans[n][i + 1] = '>';\n                A--;\n            }\n    }\n    if(m & 1) {\n        for(int i = n - 1; i >= 1 && B; i -= 2)\n            if(1) {\n                Ans[i][m] = '^';\n                Ans[i + 1][m] = 'v';\n                B--;\n            }\n    }\n    int N = n / 2 * 2, M = m / 2 * 2;\n    if(N * M < (A + B) * 2) {\n        puts(\"NO\");\n        return 0;\n    }\n    for(int i = 1; i < n; i += 2)\n        for(int j = 1; j < m; j += 2) if(!((n & 1) && (m & 1) && (i == 1 && j == m - 2))) {\n            if(A > 1) {\n                Ans[i][j] = '<';\n                Ans[i][j + 1] = '>';\n                if(A != 1) {\n                    Ans[i + 1][j] = '<';\n                    Ans[i + 1][j + 1] = '>';\n                    A -= 2;\n                } else A--;\n            } else if(B > 1) {\n                Ans[i][j] = '^';\n                Ans[i + 1][j] = 'v';\n                if(B != 1) {\n                    Ans[i][j + 1] = '^';\n                    Ans[i + 1][j + 1] = 'v';\n                    B -= 2;\n                } else B--;\n            } else if(A == 1) {\n                \n                Ans[i][j] = '<';\n                Ans[i][j + 1] = '>';\n                A--;\n            } else if(B == 1) {\n                Ans[i][j] = '^';\n                Ans[i + 1][j] = 'v';\n                B--;\n            }\n        }\n    if(A || B) {\n        if(B == 0 && A <= 2) {\n            int i = 1, j = m - 2;\n            Ans[i][j] = '<';\n            Ans[i][j + 1] = '>';\n            if(A != 1) {\n                Ans[i + 1][j] = '<';\n                Ans[i + 1][j + 1] = '>';\n                A -= 2;\n            } else A--;\n        } else if(A == 0 && B <= 2) {\n            int i = 1, j = m - 2;\n            Ans[i][j] = '^';\n            Ans[i + 1][j] = 'v';\n            if(B != 1) {\n                Ans[i][j + 1] = '^';\n                Ans[i + 1][j + 1] = 'v';\n                B -= 2;\n            } else B--;\n        } else if((n & 1) && (m & 1) && A == 1 && B == 1 && n != 1 && m != 1) {\n            Ans[1][m - 2] = '^';\n            Ans[2][m - 2] = 'v';\n            Ans[1][m - 1] = '<';\n            Ans[1][m] = '>';\n        } else {\n            puts(\"NO\");\n            return 0;\n        }\n    }\n    puts(\"YES\");\n    for(int i = 1; i <= n; i++) {\n        for(int j = 1; j <= m; j++) putchar(Ans[i][j]);\n        putchar('\\n');\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define rep(i, s, t) for(i = s; i <= t; ++i)\n#define dep(i, s, t) for(i = s; i >= t; --i)\n\nusing namespace std;\n\nconst int N = 310;\nint n, m, K, ans;\nchar s[N], t[N];\nint f[N][N][N];\n\nint main() {\n\tint i, j, k;\n\tscanf(\"%s\", s+1); n = strlen(s+1);\n\tm = n >> 1;\n\trep(i, 1, n) t[i] = s[n-i+1];\n\t\n\tscanf(\"%d\", &K);\n\trep(i, 1, m) {\n\t\trep(j, 1, n-i) \n\t\t\trep(k, 0, K) {\n\t\t\t\tf[i][j][k] = max(f[i-1][j][k], f[i][j-1][k]);\n\t\t\t\tif(s[i] == t[j]) {\n\t\t\t\t\tf[i][j][k] = max(f[i-1][j-1][k]+1, f[i][j][k]);\n\t\t\t\t} else {\n\t\t\t\t\tif(k) f[i][j][k] = max(f[i-1][j-1][k-1]+1, f[i][j][k]);\n\t\t\t\t}\n\t\t\t\t//printf(\"%d %d %d %d\\n\", i, j, k, f[i][j][k]);\n\t\t\t}\n\t\tif(n&1) ans = max(ans, f[i][n-i-1][K]*2+1);\n\t\telse ans = max(ans, f[i][n-i][K]*2);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n\n# define pb push_back\n# define fr first\n# define sc second\n# define mk make_pair\n\nusing namespace std;\n\nconst long long linf = 1e18 + 7;\nconst int inf = 1e9 + 7;\nconst int N = 1e6 + 5;\n\ntypedef long long ll;\n\nstring s;\nint k, dp[301][301][301], u[301][301][301];\n\nint calc(int l, int r, int k){\n      if(u[l][r][k]) return dp[l][r][k];\n      if(k < 0) return -inf;\n      if(l > r) return 0;\n      if(l == r) return 1;\n      u[l][r][k] = 1;\n      int &res = dp[l][r][k];\n      res = max(calc(l + 1, r, k), calc(l, r - 1, k));\n      if(s[l] == s[r])\n            res = max(res, calc(l + 1, r - 1, k) + 2);\n      else\n            res = max(res, calc(l + 1, r - 1, k - 1) + 2);\n      return res;\n}\n\nint main(){\n      cin >> s >> k;\n      s = ' ' + s;\n      cout << calc(1, s.size(), k) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nint main(void) {\n  string S;\n  ll N, K;\n  cin >> S >> K;\n  N = S.length();\n\n  const ll INF = 1LL << 50;\n  ll dp[N][N][K + 1];\n  REP(l, 0, N) REP(r, l, N) REP(k, 0, K + 1) dp[l][r][k] = 0;\n  REP(l, 0, N) REP(k, 0, K + 1) dp[l][l][k] = 1;\n  REP(l, 0, N - 1) REP(k, 0, K + 1) if(S[l] == S[l + 1]) dp[l][l + 1][k] = 2;\n  REP(s, 0, N) REP(l, 0, N - s) {\n    ll r = l + s;\n    REP(k, 0, K + 1) {\n      if(l + 1 <= r - 1 && S[l + 1] == S[r - 1]) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k] + 2);\n      if(l + 1 <= r) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r][k]);\n      if(l <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l][r - 1][k]);\n      if(k > 0) dp[l][r][k] = max(dp[l][r][k], dp[l][r][k - 1]);\n      if(k > 0 && l + 1 <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k - 1] + 2);\n    }\n  }\n  cout << dp[0][N - 1][K] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define rep(n, i) Rep(0, n-1, i)\n#define MAX 301\nint c[MAX][MAX];\n\nint common_length(string s){\n    string r = s;\n    rep(s.length(), i) r[i] = s[s.length()-1-i];\n    int l = s.length();\n    rep(l, i) rep(l, j) {\n        if (s[i] == r[j]) c[i+1][j+1] = c[i][j]+1;\n        else c[i+1][j+1] = max(c[i+1][j], c[i][j+1]);\n    }\n    /*\n    rep(l+1, i) {\n        rep(l+1, j) {\n            cout << c[i][j] << ' ';\n        }\n        cout << '\\n';\n    }\n    */\n    return c[l][l];\n}\n\nvoid solve(void){\n    string s;\n    cin >> s;\n    int n;\n    cin >> n;\n    int l = s.length() - common_length(s);\n    cout << common_length(s) + min(n, l) * 2 << '\\n';\n}\n\nint main(void){\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring s, t;\nint K;\nint dp[305][305][305];\nint dpmax[305][305];\n\nint main(void)\n{\n\tcin >> s >> K;\n\tint n = s.size();\n\tt = s;\n\treverse(t.begin(), t.end());\n\ts = \"#\" + s, t = \"#\" + t;\n\t\n\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\tfor(int k = 0; k <= K; k++){\n\t\t\t\tdp[i][j][k] = -1e9;\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0] = 0;\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tfor(int k = 0; k <= K; k++){\n\t\t\t\tif(s[i] == t[j]) dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+1);\n\t\t\t\tif(k > 0) dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k-1]+1);\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], max(dp[i-1][j][k], dp[i][j-1][k]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\tdpmax[i][j] = -1e9;\n\t\t\tfor(int k = 0; k <= K; k++) dpmax[i][j] = max(dpmax[i][j], dp[i][j][k]);\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor(int i = 0; i <= n; i++){\n\t\tans = max(ans, dpmax[i][n-i]*2);\n\t\tif(i > 0) ans = max(ans, dpmax[i-1][n-i]*2 + 1);\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define taskname \"A\"\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\nconst int maxn = 3e2 + 5;\nconst int maxm = 1e7 + 5;\n\nconst int mod = 1e9 + 7;\nstring s;\n\nint n , k , dp[maxn][maxn][maxn];\nint cal(int l , int r , int k){\n    if(l > r)return 0;\n    if(l == r)return 1;\n    int & res = dp[l][r][k];\n    if(res != -1)return res;\n    res = 0;\n    res = max(cal(l+1,r,k),cal(l,r-1,k));\n    if(s[l]==s[r])res = max(res,cal(l+1,r-1,k)+2);\n    if(k > 0)res = max(res,cal(l+1,r-1,k-1)+2);\n    return res;\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\" , \"r\"))\n        freopen(taskname\".INP\",\"r\",stdin),\n        freopen(taskname\".OUT\",\"w\",stdout);\n    cin >> s >> k;memset(dp,-1,sizeof dp);\n    cout << cal(0,(int)s.size()-1,k);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint dp[302][302][302];\n\nint main()\n{\n    string s;\n    cin >> s;\n    int n = s.size();\n    int m;\n    cin >> m;\n    if(n == 1){\n        cout << 1 << endl;\n        return 0;\n    }\n    for(int k = 0; k <= m; k++){\n        for(int i = 0; i <= n; i++){\n            for(int j = 0; j <= n; j++){\n                if(i > 0) dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k]);\n                if(j > 0) dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k]);\n                if(k > 0) dp[i][j][k] = max(dp[i][j][k], dp[i][j][k - 1]);\n                if(i > 0 && j > 0){\n                    if(s[i - 1] == s[n - j]) dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + 1);\n                    else if(k > 0) dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k - 1] + 1);\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for(int i = 0; i < n; i++){\n        ans = max(ans, dp[i][n - i - 1][m] * 2 + 1);\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\nstring s;\nint kazu;\n\nint dp[310][310][310];\n\nint dfs(int hi,int mi,int k){\n\tif(dp[hi][mi][k]>=0) return dp[hi][mi][k];\n\t//cout<<hi<<\" \"<<mi<<\" \"<<k<<endl;\n\tdp[hi][mi][k]=dfs(hi+1,mi,k);\n\tdp[hi][mi][k]=max(dp[hi][mi][k],dfs(hi,mi-1,k));\n\tif(s[hi]==s[mi])dp[hi][mi][k]=max(dp[hi][mi][k],2+dfs(hi+1,mi-1,k));\n\telse if(k>0) dp[hi][mi][k]=max(dp[hi][mi][k],2+dfs(hi+1,mi-1,k-1));\n\t\n\treturn dp[hi][mi][k];\n}\n\n\n   signed main(){\n   \tcin>>s;\n   \tint l=s.length();\n   \tfor(int i=0;i<310;i++)for(int j=0;j<310;j++)for(int k=0;k<310;k++)dp[i][j][k]=-1;\n   \tcin>>kazu;\n   \t\n   \tfor(int i=0;i<l;i++){\n   \t\tdp[i][i][0]=1;\n   \t\tfor(int j=1;j<=kazu;j++)dp[i][i][j]=max(dp[i][i][j],dp[i][i][j-1]);\n   \t}\n   \t\n   \tfor(int i=0;i<l-1;i++){\n   \t\tdp[i][i+1][1]=2;\n   \t\tdp[i][i+1][0]=1;\n   \t\tif(s[i]==s[i+1]) dp[i][i+1][0]=2;\n   \t\tfor(int j=2;j<=kazu;j++)dp[i][i+1][j]=max(dp[i][i+1][j],dp[i][i+1][j-1]);\n   \t}\n   \t\n   \tcout<<dfs(0,l-1,kazu)<<endl;\n   \t\n   \treturn 0;\n        }"
  },
  {
    "language": "C++",
    "code": "//84104971101048411497 - Can you guess what does this mean?\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n#define mapii map<int, int>\n#define debug(a) cout << #a << \": \" << a << endl\n#define debuga1(a, l, r) fto(i, l, r) cout << a[i] << \" \"; cout << endl\n#define fdto(i, r, l) for(int i = (r); i >= (l); --i)\n#define fto(i, l, r) for(int i = (l); i <= (r); ++i)\n#define forit(it, var) for(__typeof(var.begin()) it = var.begin(); it != var.end(); it++)\n#define forrit(rit, var) for(__typeof(var.rbegin()) rit = var.rbegin(); rit != var.rend(); rit++)\n#define ii pair<int, int>\n#define iii pair<int, ii>\n#define ff first\n#define ss second\n#define mp make_pair\n#define pb push_back\n#define maxN 305\n#define oo 1000000007\n#define MOD 1000000007\n#define sz(a) (int)a.size()\n\nconst double PI = acos(-1.0);\n\ndouble fRand(double fMin, double fMax)\n{\n    double f = (double)rand() / RAND_MAX;\n    return fMin + f * (fMax - fMin);\n}\n\ntemplate <class T>\nT min(T a, T b, T c) {\n    return min(a, min(b, c));\n}\n\ntemplate <class T>\nT max(T a, T b, T c) {\n    return max(a, max(b, c));\n}\n\nstring s;\nint n, k, dp[maxN][maxN][maxN];\n\nint Solve(int i, int j, int k) {\n    if (k < 0) return -oo;\n    if (i > j) return 0;\n    if (i == j) return 1;\n    if (dp[i][j][k] != -1) return dp[i][j][k];\n\n    int res;\n    if (s[i] == s[j]) res = Solve(i+1, j-1, k)+2;\n    else res = max(Solve(i+1, j-1, k-1)+2, Solve(i+1, j, k), Solve(i, j-1, k));\n\n    return dp[i][j][k] = res;\n}\n\nint main () {\n    cin >> s;\n    n = s.length();\n    scanf(\"%d\", &k);\n\n    fto(i, 0, n-1) fto(j, 0, n-1) fto(k, 0, n) dp[i][j][k] = -1;\n\n    cout << Solve(0, n-1, k);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iomanip>\nusing namespace std;\n#define reps(i,s,n) for(int i = s; i < n; i++)\n#define rep(i,n) reps(i,0,n)\n#define Rreps(i,n,e) for(int i = n - 1; i >= e; --i)\n#define Rrep(i,n) Rreps(i,n,0)\n#define ALL(a) a.begin(), a.end()\n#define fi first\n#define se second\n#define mp make_pair\ntypedef long long ll;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nll N,M,H,W,K,Q,A,B;\nstring S, T;\n//const ll MOD = 998244353;\nconst ll MOD = (1e+9) + 7;\nconst ll INF = 1LL << 60;\ntypedef pair<ll,ll> P;\n\nvector<mat> dp(300, mat(300, vec(301, -1)));\nll dfs(int i, int j, int k){\n    if(i >= j) return i == j;\n    if(dp[i][j][k] != -1) return dp[i][j][k];\n    ll res = 0;\n    if(S[i] == S[j]){\n        res = dfs(i + 1, j - 1, k) + 2;\n    }else{\n        res = max(dfs(i, j - 1, k), dfs(i + 1, j, k));\n        if(k != 0) res = max(res, dfs(i + 1, j - 1, k - 1) + 2);\n    }\n    return dp[i][j][k] = res;\n}\n\nint main() {\n    cin>>S>>K;\n    N = S.size();\n    cout<<dfs(0, N - 1, K)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(register int i=a;i<=b;++i)\n#define rpd(i,a,b) for(register int i=a;i>=b;--i)\n#define rep1(i,x) for(register int i=head[x];i;i=nxt[i])\ntypedef long long ll;\nconst int N=300+5;\nusing namespace std;\ninline int read(){\n    int x=0,f=1;char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n    while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nstring s;int n,m;int f[N][N][N];\nvoid Max(int &x,int y){x=max(x,y);}\nint main(){\n    cin>>s;s=' '+s;\n    n=s.length()-1;m=read();\n    rep(i,1,n)rep(j,0,m)f[i][i][j]=1;\n    rep(d,2,n)rep(i,1,n){\n        int j=i+d-1;if(j>n)break;\n        rep(k,0,m){\n            if(k)Max(f[i][j][k],f[i][j][k-1]);\n            Max(f[i][j][k],f[i+1][j][k]);\n            Max(f[i][j][k],f[i][j-1][k]);\n            if(s[i]==s[j])Max(f[i][j][k],f[i+1][j-1][k]+2);\n            else if(k)Max(f[i][j][k],f[i+1][j-1][k-1]+2);\n        }\n    }\n    printf(\"%d\\n\",f[1][n][m]);\n    system(\"pause\");\n    return 0;\n}\n/*\n区间DP\nf[i][j][k]表示翻转[i,j]这个区间,修改k次的LCS\n转移时修改一次因为翻转前后都能匹配,所以LCS+2\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, k;\nchar s[310];\n\nint dp[310][310][310];\n\nint main()\n{\n\tcin >> (s+1) >> k;\n\tn = strlen(s+1);\n\tfor(int l=1; l<=n; ++l){\n\t\tfor(int r=n; l<=r; --r){\n\t\t\tfor(int u=0; u<=k; ++u){\n\t\t\t\tint d = max(dp[l-1][r][u], dp[l][r+1][u]);\n\t\t\t\tif(s[l] == s[r]){\n\t\t\t\t\td = max(d, dp[l-1][r+1][u] + 1);\n\t\t\t\t}\n\t\t\t\tif(u){\n\t\t\t\t\td = max(d, dp[l-1][r+1][u-1] + 1);\n\t\t\t\t}\n\t\t\t\tdp[l][r][u] = d;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i=1; i+1<=n; ++i){\n\t\tfor(int u=0; u<=k; ++u){\n\t\t\tans = max(ans, 2*dp[i][i+1][u]);\n\t\t}\n\t}\n\tfor(int i=1; i<=n; ++i){\n\t\tfor(int u=0; u<=k; ++u){\n\t\t\tans = max(ans, 2*dp[i][i][u] - 1);\n\t\t}\n\t}\n\tcout << ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n \n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n \ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQR = priority_queue<T,vector<T>,greater<T>>;\n \nconstexpr long long MOD = (long long)1e9 + 7;\nconstexpr long long MOD2 = 998244353;\nconstexpr long long HIGHINF = (long long)1e18;\nconstexpr long long LOWINF = (long long)1e15;\nconstexpr long double PI = 3.1415926535897932384626433;\n \ntemplate <class T> vector<T> multivector(size_t N,T init){return vector<T>(N,init);}\ntemplate <class... T> auto multivector(size_t N,T... t){return vector<decltype(multivector(t...))>(N,multivector(t...));}\ntemplate <class T> void corner(bool flg, T hoge) {if (flg) {cout << hoge << endl; exit(0);}}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const map<T, U>&obj) {o << \"{\"; for (auto &x : obj) o << \" {\" << x.first << \" : \" << x.second << \"}\" << \",\"; o << \" }\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const set<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const multiset<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&obj) {o << \"{\"; for (int i = 0; i < (int)obj.size(); ++i)o << (i > 0 ? \", \" : \"\") << obj[i]; o << \"}\"; return o;}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const pair<T, U>&obj) {o << \"{\" << obj.first << \", \" << obj.second << \"}\"; return o;}\nvoid print(void) {cout << endl;}\ntemplate <class Head> void print(Head&& head) {cout << head;print();}\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) {cout << head << \" \";print(forward<Tail>(tail)...);}\ntemplate <class T> void chmax(T& a, const T b){a=max(a,b);}\ntemplate <class T> void chmin(T& a, const T b){a=min(a,b);}\nvoid YN(bool flg) {cout << (flg ? \"YES\" : \"NO\") << endl;}\nvoid Yn(bool flg) {cout << (flg ? \"Yes\" : \"No\") << endl;}\nvoid yn(bool flg) {cout << (flg ? \"yes\" : \"no\") << endl;}\n\n\nint main() {\n\tSPEED\n\tstring S; cin >> S;\n\tint N = S.size();\n\tint K; cin >> K;\n\tauto R = multivector(N, 26,-1);\n\tauto L = multivector(N, 26,-1);\n\tvector<int> cnt(26,-1);\n\tfor(int i = 0; i < N; ++i) {\n\t\tL[i] = cnt;\n\t\tcnt[S[i]-'a'] = i;\n\t}\n\tfor(int a = 0; a < 26; ++a){\n\t\tcnt[a] = -1;\n\t}\n\tfor(int i = N-1; 0 <= i; --i) {\n\t\tR[i] = cnt;\n\t\tcnt[S[i]-'a'] = i;\n\t}\n\tauto dp = multivector((K+2)*N*N,0);\n\tfor(int i = 0; i < N; ++i) {\n\t\tfor(int k = 0; k <= K; ++k) {\n\t\t\tdp[k*N*N+i*N+i] = 1;\n\t\t}\n\t}\n\tfor(int i = 0; i+1 < N; ++i) {\n\t\tfor(int k = 0; k <= K; ++k) {\n\t\t\tif(S[i]==S[i+1]) dp[k*N*N+i*N+i+1] = 2;\n\t\t\telse dp[k*N*N+i*N+i+1] = (k?2:0);\n\t\t}\n\t}\n\tfor(int i = 0; i < N; ++i) {\n\t\tfor(int j = 0; j + i < N; ++j){\n\t\t\tint l = j, r = j + i;\n\t\t\tfor(int k = 0; k <= K; ++k) {\n\t\t\t\t//コストが発生しないとき\n\t\t\t\tfor(int a = 0; a < 26; ++a){\n\t\t\t\t\tint x = L[l][a],y = R[r][a];\n\t\t\t\t\tif(x==-1||y==-1) continue;\n\t\t\t\t\tchmax(dp[k*N*N+x*N+y],dp[k*N*N+l*N+r]+2);\n\t\t\t\t}\n\t\t\t\t//コストが発生するとき\n\t\t\t\tif(0<=l-1&&r+1<N) chmax(dp[(k+1)*N*N+(l-1)*N+r+1],dp[k*N*N+l*N+r]+2);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i < N; ++i) {\n\t\tfor(int j = 0; j < N; ++j){\n\t\t\tfor(int k = 0; k <= K; ++k) {\n\t\t\t\tchmax(ans,dp[k*N*N+i*N+j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n*/\n\n//#pragma GCC optimize(\"O3\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>т мом\n#include <list>\n#include <ctime>\n\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n#define ends asdgahhfdsfshdshfd\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bsize 512\n\n#define ldouble long double\nusing namespace std;\n\n#define bs 1000000007\n\nconst int N = 400031;\n\nstring st;\nint k;\n\nint dp[331][331][331];\n\nint get(int lev, int i,int j){\n\tif (i>j)\n\t\treturn 0;\n\treturn dp[lev][i][j];\n}\n\nint main(){\n//\tfreopen(\"apache.in\",\"r\",stdin);\n//\tfreopen(\"apache.out\",\"w\",stdout);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n//\tcin.tie(0);\n\n\tcin>>st>>k;\n\n\tfor (int i=0;i<=k;i++){\n\t\tfor (int j=0;j<=st.size();j++){\n\t\t\tfor (int q=0;q<=st.size();q++)\n\t\t\t{\n\t\t\t\t\tdp[i][j][q]=1e9;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i=0;i<st.size();i++){\n\t\tdp[0][i][i]=0;\n\n\t}\n\tfor (int lev=0;lev<=k;lev++){\n\t\tfor (int j=0;j<st.size();j++){\n\t\t\tfor (int i=j-1;i>=0;--i){\n\t\t\t\tif (st[i]==st[j]){ // match\n\t\t\t\t\tint here=get(lev,i+1,j-1);\n\t\t\t\t\tdp[lev][i][j]=min(dp[lev][i][j],here);\n\t\t\t\t}\n\t\t\t\t// remove left\n\t\t\t\tint here=get(lev,i+1,j);\n\t\t\t\tdp[lev][i][j]=min(dp[lev][i][j],here+1);\n\t\t\t\t// remove right\n\t\t\t\there=get(lev,i,j-1);\n\t\t\t\tdp[lev][i][j]=min(dp[lev][i][j],here+1);\n\t\t\t\t// change some\n\t\t\t\tif (lev>0)\n\t\t\t\t{\n\t\t\t\t\tint here=get(lev-1,i+1,j-1);\n\t\t\t\t\tdp[lev][i][j]=min(dp[lev][i][j],here);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint res=1e9;\n\tfor (int i=0;i<=k;i++){\n\t\tres=min(res,dp[i][0][st.size()-1]);\n\t}\n\tcout<<st.size()-res<<endl;\n\n//\tcin.get(); cin.get();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nint main(void) {\n  string S;\n  ll N, K;\n  cin >> S >> K;\n  N = S.length();\n\n  const ll INF = 1LL << 50;\n  ll dp[N][N][K + 1];\n  REP(l, 0, N) REP(r, l, N) REP(k, 0, K + 1) dp[l][r][k] = -INF;\n  REP(l, 0, N) dp[l][l][0] = 1;\n  REP(l, 0, N - 1) dp[l][l + 1][0] = S[l] == S[l + 1] ? 2 : 0;\n  REP(s, 0, N) REP(l, 0, N - s + 1) {\n    ll r = l + s;\n    REP(k, 0, K + 1) {\n      if(l + 1 <= r - 1 && S[l + 1] == S[r - 1]) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k] + 2);\n      if(l + 1 <= r) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r][k]);\n      if(l <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l][r - 1][k]);\n      if(k > 0) dp[l][r][k] = max(dp[l][r][k], dp[l][r][k - 1]);\n      if(k > 0 && l + 1 <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k - 1] + 2);\n    }\n  }\n  cout << dp[0][N - 1][K] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstring s, t;\n\nconst int N = 301;\n\nint dp[N][N][N];\nint n;\n\nint f(int n1, int n2, int k) {\n    if (dp[n1][n2][k] != -1) {\n        return dp[n1][n2][k];\n    }\n    if (!n1 || !n2) {\n        return dp[n1][n2][k] = 0;\n    }\n    if (s[n1 - 1] == t[n2 - 1]) {\n        return dp[n1][n2][k] = f(n1 - 1, n2 - 1, k) + 1;\n    }\n    dp[n1][n2][k] = 0;\n    if (k && (s[n1 - 1] != s[n - n1] || s[n2 - 1] != s[n - n2])) {\n        dp[n1][n2][k] = f(n1 - 1, n2 - 1, k - 1) + 2;\n    }\n    dp[n1][n2][k] = max(dp[n1][n2][k], f(n1 - 1, n2, k));\n    dp[n1][n2][k] = max(dp[n1][n2][k], f(n1, n2 - 1, k));\n    return dp[n1][n2][k];\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int k;\n    cin >> s >> k;\n    t = s;\n    reverse(t.begin(), t.end());\n    n = s.length();\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            for (int l = 0; l < N; ++l) {\n                dp[i][j][l] = -1;\n            }\n        }\n    }\n    cout << f(n, n, k);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<math.h>\n#include<time.h>\n#include<vector>\n#include<bitset>\n#include<memory>\n#include<utility>\n#include<fstream>\n#include<stdio.h>\n#include<sstream>\n#include<iostream>\n#include<stdlib.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\nchar a[305];\nint dp[305][305][305];\nint n;\nvoid dfs(int l,int r,int k)\n{\n    if (dp[l][r][k]!=-1)\n    {\n        return;\n    }\n    if (l>=r)\n    {\n        dp[l][r][k]=0;\n        return;\n    }\n    if (k>=r-l)\n    {\n        dp[l][r][k]=r-l;\n        return;\n    }\n    dfs(l+1,r,k);\n    dp[l][r][k]=dp[l+1][r][k];\n    int i;\n    for (i=l;i<r;i++)\n    {\n        if (a[l]==a[i])\n        {\n            dfs(l+1,i,k);\n            if (l+1<=i)\n            {\n                dp[l][r][k]=max(dp[l][r][k],dp[l+1][i][k]+2);\n            }\n            else\n            {\n                dp[l][r][k]=max(dp[l][r][k],dp[l+1][i][k]+1);\n            }\n        }\n        else if (k>0)\n        {\n            dfs(l+1,i,k-1);\n            if (l+1<=i)\n            {\n                dp[l][r][k]=max(dp[l][r][k],dp[l+1][i][k-1]+2);\n            }\n            else\n            {\n                dp[l][r][k]=max(dp[l][r][k],dp[l+1][i][k-1]+1);\n            }\n        }\n    }\n}\nint main()\n{\n    #ifdef absi2011\n    freopen(\"input.txt\",\"r\",stdin);\n    freopen(\"output.txt\",\"w\",stdout);\n    #endif\n    memset(dp,-1,sizeof(dp));\n    scanf(\"%s\",a);\n    n=strlen(a);\n    int k;\n    scanf(\"%d\",&k);\n    dfs(0,n,k);\n    printf(\"%d\\n\",dp[0][n][k]);\n    return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define modulo 998244353\n#define mod(mod_x) ((((long long)mod_x+modulo))%modulo)\n#define Inf 100000000\n\nstring S;\n\nint get(int l,int r,int k){\n\tif(k<0)return -100000;\n\tif(r==l)return 1;\n\tif(r<l)return 0;\n\tstatic vector<vector<vector<int>>> dp(S.size()+1,vector<vector<int>>(S.size()+1,vector<int>(S.size()+1,-1)));\n\tif(dp[l][r][k]!=-1)return dp[l][r][k];\n\tint ret = 0;\n\tret = max(ret,get(l+1,r,k));\n\tret = max(ret,get(l,r-1,k));\n\tret = max(ret,get(l+1,r-1,k-1)+2);\n\tif(S[l]==S[r])ret = max(ret,get(l+1,r-1,k)+2);\n\tdp[l][r][k]=ret;\n\treturn ret;\n}\n\nint main(){\n\t\n\tcin>>S;\n\t\n\tint K;\n\tcin>>K;\n\t\n\tcout<<get(0,S.size()-1,K)<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\nusing namespace std;\n\nstring s;\nshort dp[302][302][302];\nint go(int l, int r, int k){\n\tif(l == r)\n\t\treturn 1;\n\tif(l > r)\n\t\treturn 0;\n\tif(dp[l][r][k] != -1)\n\t\treturn dp[l][r][k];\n\tint ret = max(go(l + 1, r - 1, k), go(l, r - 1, k));\n\tif(s[l] == s[r])\n\t\tret = max(ret, go(l + 1, r - 1, k) + 2);\n\telse if(k)\n\t\tret = max(ret, go(l + 1, r - 1, k - 1) + 2);\n\treturn dp[l][r][k] = ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\t//\tsrand(time(NULL));\n\tint k; cin >> s >> k;\n\tmemset(dp, -1, sizeof dp);\n\tcout << go(0, s.size() - 1, k) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int N = 3e2+5;\nint n, m, f[N][N][N], ans; char s[N];\nint main()\n{\n    scanf(\"%s\", s+1), n = strlen(s+1), m = read();\n    for(int k = 0; k <= m; ++k)\n        for(int l = 3; l <= n; ++l)\n            for(int i = 1, j = l; j <= n; ++i, ++j)\n            {\n                f[k][i][j] = max(max(f[k][i+1][j], f[k][i][j-1]), f[k][i+1][j-1]+(s[i] == s[j]));\n                if(k) f[k][i][j] = max(f[k][i][j], max(f[k-1][i+1][j], f[k-1][i][j-1])+1);\n                ans = max(ans, f[k][i][j]*2+1);\n            }\n    for(int k = 0; k <= m; ++k)\n        for(int l = 2; l <= n; ++l)\n            for(int i = 1, j = l; j <= n; ++i, ++j)\n            {\n                f[k][i][j] = max(max(f[k][i+1][j], f[k][i][j-1]), f[k][i+1][j-1]+(s[i] == s[j]));\n                if(k) f[k][i][j] = max(f[k][i][j], max(f[k-1][i+1][j], f[k-1][i][j-1])+1);\n                ans = max(ans, f[k][i][j]*2);\n            }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #pragma GCC optimize (\"O3\")\n// #pragma GCC target (\"sse4\")\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\n\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define FOR(i,a,b) for (int i=(a); i<(b); ++i)\n#define FORD(i,a,b) for (int i=(a)-1; i>=(b); --i)\n\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\n\nconst int MOD = 1000000007;\n\nchar S[1000];\nint DP[400][400][400];\n\nint main() {\n  // ios_base::sync_with_stdio(0);\n\n  int K;\n  scanf(\"%s%d\", S, &K);\n  int N = strlen(S);\n  FORD(i,N,0)FOR(j,i+1,N+1)REP(k,K+1) {\n    if (j == i+1) {\n      DP[i][j][k] = 1;\n      continue;\n    }\n    DP[i][j][k] = max(DP[i][j-1][k], DP[i+1][j][k]);\n    if (S[i] == S[j-1]) DP[i][j][k] = max(DP[i][j][k], DP[i+1][j-1][k] + 2);\n    if (k > 0) DP[i][j][k] = max(DP[i][j][k], DP[i+1][j-1][k-1] + 2);\n  }\n\n  printf(\"%d\\n\", DP[0][N][K]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint maxlcs(string s1, string s2, int k)\n{\n\tif (s1.empty() || s2.empty())\n\t\treturn 0;\n\tvector<vector<vector<int>>> ans(s1.size() + 1, vector<vector<int>>(s2.size() + 1, vector<int>(k + 1)));\n\tfor (int i = 0; i <= s1.size(); ++i)\n\t\tfor (int j = 0; j <= s2.size(); ++j)\n\t\t\tfor (int l = 0; l <= k; ++l)\n\t\t\t{\n\t\t\t\tif (i < s1.size())\n\t\t\t\t\tans[i + 1][j][l] = max(ans[i + 1][j][l], ans[i][j][l]);\n\t\t\t\tif (j < s2.size())\n\t\t\t\t\tans[i][j + 1][l] = max(ans[i][j + 1][l], ans[i][j][l]);\n\t\t\t\tif (l < k)\n\t\t\t\t\tans[i][j][l + 1] = max(ans[i][j][l + 1], ans[i][j][l]);\n\t\t\t\tif (i < s1.size() && j < s2.size())\n\t\t\t\t{\n\t\t\t\t\tif (s1[i] == s2[j])\n\t\t\t\t\t\tans[i + 1][j + 1][l] = max(ans[i + 1][j + 1][l], ans[i][j][l] + 1);\n\t\t\t\t\telse if (l < k)\n\t\t\t\t\t\tans[i + 1][j + 1][l + 1] = max(ans[i + 1][j + 1][l + 1], ans[i][j][l] + 1);\n\t\t\t\t}\n\t\t\t}\n\treturn ans.back().back().back();\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tstring s;\n\tcin >> s;\n\tint k;\n\tcin >> k;\n\tvector<vector<vector<int>>> dp(s.size() + 1, vector<vector<int>>(s.size() + 1, vector<int>(k + 1)));\n\tint n = s.size();\n\tfor (int i = 0; i < n; ++i)\n\t\tdp[i][i + 1][0] = 1;\n\tfor (int len = 0; len <= n; ++len)\n\t\tfor (int i = 0; i + len <= n; ++i)\n\t\t{\n\t\t\tint j = i + len;\n\t\t\tfor (int l = 0; l <= k; ++l)\n\t\t\t{\n\t\t\t\tif (j < n)\n\t\t\t\t\tdp[i][j + 1][l] = max(dp[i][j + 1][l], dp[i][j][l]);\n\t\t\t\tif (i > 0)\n\t\t\t\t\tdp[i - 1][j][l] = max(dp[i - 1][j][l], dp[i][j][l]);\n\t\t\t\tif (l < k)\n\t\t\t\t\tdp[i][j][l + 1] = max(dp[i][j][l + 1], dp[i][j][l]);\n\t\t\t\tif (i > 0 && j < n)\n\t\t\t\t{\n\t\t\t\t\tif (s[i - 1] == s[j])\n\t\t\t\t\t\tdp[i - 1][j + 1][l] = max(dp[i - 1][j + 1][l], dp[i][j][l] + 2);\n\t\t\t\t\telse if (l < k)\n\t\t\t\t\t\tdp[i - 1][j + 1][l + 1] = max(dp[i - 1][j + 1][l + 1], dp[i][j][l] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcout << dp[0].back().back() << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "// khodaya khodet komak kon\n#include <bits/stdc++.h>\n#define pb push_back\n#define ers erase\n#define ins insert\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x)  cerr << #x << \" = \" << x << endl\n#define kill(x) return cout << x, 0;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#pragma GCC optimize (\"Ofast\")\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vl;\ntypedef vector<pll> vpl;\n\nconst ld Pi = 3.14159265359;\nconst ll MOD = 1000 * 1000 * 1000 + 7;\nconst ll N = 2e5 + 10;\nconst ll INF = 1e18;\nstr s;\nll K, n, dp[310][310][310];\n\nint main(){\n\tIOS;\n\tcin >> s;\n\tcin >> K;\n\tll n = s.size();\n\tif (n == 1) return cout << 1, 0;\n\ts = \".\" + s;\n\t//cout << n << '\\n';\n\tfor (int i = 1; i <= n; i++){\n\t\tdp[i][i + 1][0] = 1;\n\t}\n\tfor (int i = 2; i <= n; i++){\n\t\tfor (int j = 1; j <= n - i + 1; j++){\n\t\t\tfor (int k = 0; k <= K; k++){\n\t\t\t\tif (k == 0){\n\t\t\t\t\tif (s[j] == s[j + i - 1]){\n\t\t\t\t\t\tdp[j][i + j][0] = dp[j + 1][i + j - 1][0] + 2;\n\t\t\t\t\t}\n\t\t\t\t\tdp[j][i + j][k] = max(dp[j][i + j][k], max(dp[j + 1][i + j][k], dp[j][i + j - 1][k]));\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\telse if (k >= i - 1){\n\t\t\t\t\tdp[j][i + j][k] = i;\n\t\t\t\t}else{\n\t\t\t\t\tdp[j][i + j][k] = dp[j][i + j][k - 1];\n\t\t\t\t\tif (s[j] == s[i + j - 1]){\n\t\t\t\t\t\tdp[j][i + j][k] = dp[j + 1][i + j - 1][k] + 2;\n\t\t\t\t\t}\n\t\t\t\t\tdp[j][i + j][k] = max(dp[j][i + j][k], max(dp[j + 1][i + j][k], dp[j][i + j - 1][k]));\n\t\t\t\t\tdp[j][i + j][k] = max(dp[j][i + j][k], 2 + dp[j + 1][i + j - 1][k - 1]);\n\t\t\t\t}\n\t\t\t\t//cout << j << ' ' << j + i - 1 << ' ' << k << ' ' << dp[j][j + i][k] << '\\n';\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t}\n\tcout << dp[1][n + 1][K];\n\t\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "v"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\n//const int mod = ;\n\nint d[305][305][305];\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  string s;\n  int k;\n  cin >> s >> k;\n  int n = s.size();\n/*  if (k == n) {\n    cout << n << endl; return 0;\n  }*/\n  for (int i = 0; i < n; ++i) {\n    d[i][i][0] = 1;\n  }\n  int res = 0;\n  for (int l = 2; l <= n; ++l) {\n    for (int i = 0; i + l <= n; ++i) {\n      int j = i + l - 1;\n      for (int t = 0; t <= k; ++t) {\n        d[i][j][t] = max(d[i+1][j][t], d[i][j-1][t]);\n        if (s[i] == s[j]) d[i][j][t] = max(d[i][j][t], d[i+1][j-1][t] + 2);\n        if (t) {\n          d[i][j][t] = max(max(d[i][j][t], d[i+1][j-1][t-1] + 2), d[i][j][t-1]);\n        }\n        res = max(res, d[i][j][t]);\n      }\n    }\n  }\n  cout << max(1, res) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\n\nclass Solver {\n public:\n  string s;\n  int n, q;\n  Solver(string s) : s(s), n(s.length()){};\n\n  void solve() {\n    cin >> q;\n    vector<vector<vector<int>>> dp(q + 1, vector<vector<int>>(n, vector<int>(n)));\n    for (int i = 0; i < n; ++i) {\n      dp[0][i][i] = 1;\n    }\n    for (int i = 0; i < n - 1; ++i) {\n      if (s[i] == s[i + 1]) {\n        dp[0][i][i + 1] = 2;\n      } else {\n        dp[0][i][i + 1] = 1;\n      }\n    }\n    for (int d = 2; d < n; ++d) {\n      for (int i = 0; i < n - d; ++i) {\n        if (s[i] == s[i + d]) {\n          dp[0][i][i + d] = dp[0][i + 1][i + d - 1] + 2;\n        } else {\n          dp[0][i][i + d] = max(dp[0][i + 1][i + d], dp[0][i][i + d - 1]);\n        }\n      }\n    }\n    DBG(dp[0])\n    for (int i = 1; i <= q; ++i) {\n      for (int j = 0; j < n; ++j) {\n        dp[i][j][j] = 1;\n      }\n      for (int j = 0; j < n - 1; ++j) {\n        if (s[j] == s[j + 1]) {\n          dp[i][j][j + 1] = 2;\n        } else {\n          dp[i][j][j + 1] = 2;\n        }\n      }\n      for (int d = 2; d < n; ++d) {\n        for (int j = 0; j < n - d; ++j) {\n          dp[i][j][j + d] = dp[i - 1][j][j + d];\n          if (s[j] == s[j + d]) {\n            dp[i][j][j + d] = max(dp[i][j][j + d], dp[i][j + 1][j + d - 1] + 2);\n          } else {\n            dp[i][j][j + d] = max({dp[i][j][j + d], dp[i][j + 1][j + d], dp[i][j][j + d - 1], dp[i - 1][j + 1][j + d - 1] + 2 /*, dp[i - 1][j][j + d - 1] + 2*/});\n          }\n        }\n      }\n    }\n    DBG(dp)\n    cout << dp[q][0][n - 1] << endl;\n  }\n};\n\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  std::string s;\n  std::cin >> s;\n  Problem::Solver sol(s);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nchar buf[310];\nint n,k;\nint mx[310][310][310];\nint ans;\nint main()\n{\n\tscanf(\"%s%d\",buf,&k);\n\tn=strlen(buf);\n\tans=1;\n\tfor(int l=1;l<=n;l++)\n\t{\n\t\tfor(int i=0;i+l-1<n;i++)\n\t\t{\n\t\t\tint j=i+l-1;\n\t\t\tif(l==1)mx[i][j][0]=1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int t=0;t<=k;t++)\n\t\t\t\t{\n\t\t\t\t\tmx[i][j][t]=max(mx[i+1][j][t],mx[i][j-1][t]);\n\t\t\t\t\tif(buf[i]==buf[j])\n\t\t\t\t\t{\n\t\t\t\t\t\tmx[i][j][t]=max(mx[i][j][t],mx[i+1][j-1][t]+2);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(t)mx[i][j][t]=max(mx[i][j][t],mx[i+1][j-1][t-1]+2);\n\t\t\t\t\t}\n\t\t\t\t\tans=max(ans,mx[i][j][t]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\nstring s;\nint n, K, dp[310][310][310];\n\nint dfs(int l, int r, int t){\n    if(dp[l][r][t] >= 0) return dp[l][r][t];\n    if(l == r) return dp[l][r][t] = 0;\n    if(r-l == 1) return dp[l][r][t] = 1;\n    int ret = max(dfs(l+1, r, t), dfs(l, r-1, t));\n    if(s[l] == s[r-1]) chmax(ret, 2 + dfs(l+1, r-1, t));\n    else if(t > 0) chmax(ret, 2 + dfs(l+1, r-1, t-1));\n    return dp[l][r][t] = ret;\n}\n\nint main(){\n    cin >> s >> K;\n    int n = s.size();\n    rep(i, n+1)rep(j, n+1)rep(k, K+1) dp[i][j][k] = -1;\n    printf(\"%d\\n\", dfs(0, n, K));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FOR(i, a, b) for(ll i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(ll i = (a); i > (b); --i)\n#define REP(i, n) for(ll i = 0; i < (n); ++i)\n#define REPR(i, n) for(ll i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt __builtin_popcount\n#define SZ(x) ((ll)(x).size())\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\n#define CINT(...)                                                              \\\n    int __VA_ARGS__;                                                           \\\n    CIN(__VA_ARGS__)\n#define DCIN(...)                                                              \\\n    double __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    ll __VA_ARGS__;                                                            \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Yes(a) cout << (a ? \"Yes\" : \"No\") << \"\\n\"\n#define YES(a) cout << (a ? \"YES\" : \"NO\") << \"\\n\"\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        FOREACH(x, v) { cout << x << \" \"; }                                    \\\n        cout << \"\\n\";                                                          \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef vector<ll> VL;\ntypedef pair<ll, ll> PL;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\nconst double PI = atan(1.0) * 4.0;\n// const int MOD = 998244353;\nconst ll LINF = 9e18;\nconst ll dx[] = {1, 0, -1, 0};\nconst ll dy[] = {0, 1, 0, -1};\n\nstring S;\nll K;\nusing tp = tuple<ll, ll, ll>;\nmap<tp, ll> memo;\n\nll dp(ll s, ll t, ll k) {\n    if(memo.find(tp(s, t, k)) != memo.end()) return memo[tp(s, t, k)];\n    ll &res = memo[tp(s, t, k)];\n    if(s == t)\n        res = 1;\n    else if(s + 1 == t)\n        res = (S[s] == S[t] ? 2 : 1);\n    else {\n        res = max({res, dp(s + 1, t, k), dp(s, t - 1, k)});\n        if(S[s] == S[t])\n            res = max(res, dp(s + 1, t - 1, k) + 2);\n        else if(k > 0)\n            res = max(res, dp(s + 1, t - 1, k - 1) + 2);\n    }\n    return res;\n}\n\nsigned main() {\n    cin >> S >> K;\n    ll N = S.length();\n    cout << dp(0, N - 1, K) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\nusing namespace std;\n#define MOD 1000000007\n#define rep(i,m,n) for(int (i)=(int)(m);i<(int)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ll long long\n#define ull unsigned long long\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconst long long INF = 1LL << 60;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\n\n\n//priority_queue<ll> max;//大きい順\n//priority_queue<ll, Array, greater<ll>> min;//小さい順\n\n/*firstについては昇順 secondについては降順\nsort(all(wh), [&](P x, P y) {\n\tif (x.first == y.first)return x.second > y.second;\n\treturn x.first < y.first;\n});\n*/\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n//substr　文字列取り出し\n//upper_bound ある値より大きい一番左のイテレータを返す、lowerは以上(setに対して使うとO(N)なので、setのメンバ関数を使う\n//stoi\n\n\nstruct Edge {//グラフ\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, ll from, ll to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\nll max_flow_dfs(Graph & G, ll v, ll t, ll f, vector<bool> & used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph & G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d, Array &negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 2) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 2) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\td[i][G[i][j].to] = G[i][j].cap;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, vector<int>& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tlca() {}\n\n\tlca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unionSet(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tint numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\nclass SumSegTree {\nprivate:\n\n\tint _sum(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return 0;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tint s1 = _sum(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tint s2 = _sum(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn s1 + s2;\n\t\t}\n\t}\npublic:\n\tint n, height;\n\tvector<int> dat;\n\n\t// 初期化（_nは最大要素数）\n\tSumSegTree(int _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<int>(2 * n - 1, 0);\n\t}\n\n\t// 場所i(0-indexed)にxを足す\n\tvoid add(int i, int x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] += x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] += x;\n\t\t}\n\t}\n\n\t// 区間[a,b)の総和。ノードk=[l,r)に着目している。\n\tint sum(int a, int b) {\n\t\treturn _sum(a, b, 0, 0, n);\n\t}\n};\nclass RmqTree {\nprivate:\n\n\tP _find(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return make_pair(INF,INF);    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tP s1 = _find(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tP s2 = _find(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn min(s1, s2);\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<P> dat;\n\n\t// 初期化（_nは最大要素数）\n\tRmqTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<P>(2 * n - 1, make_pair(INF,INF));\n\t}\n\n\t// 場所i(0-indexed)をxにする\n\tvoid update(ll i, ll x) {\n\t\tll num = i;\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] = make_pair(x,num);\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\n\t// 区間[a,b)の最小値。ノードk=[l,r)に着目している。\n\tP find(ll a, ll b) {\n\t\treturn _find(a, b, 0, 0, n);\n\t}\n};\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\n}\n\nvector<ll> lis_fast(const vector<ll>& a) {//最長部分増加列\n\tconst ll n = a.size();\n\tvector<ll> A(n, INT_MAX);\n\tvector<ll> id(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tid[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n\t\tA[id[i]] = a[i];\n\t}\n\tll m = *max_element(id.begin(), id.end());\n\tvector<ll> b(m + 1);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tif (id[i] == m) b[m--] = a[i];\n\treturn b;\n}\n\n\nll ModPow(ll x, ll n) {\n\tll res = 1LL;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % MOD;\n\t\tx = x * x % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//nCrとか\nclass Combination {\npublic:\n\tArray fact;\n\tArray inv;\n\tll mod;\n\tll mod_inv(ll x) {\n\t\tll n = mod - 2LL;\n\t\tll res = 1LL;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res = res * x % mod;\n\t\t\tx = x * x % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tll nCr(ll n, ll r) {\n\t\treturn ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll n, ll _mod) {\n\t\tmod = _mod;\n\t\tfact.resize(n + 1);\n\t\tfact[0] = 1;\n\t\tREP(i, n) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tinv.resize(n + 1);\n\t\tREP(i, n + 1) {\n\t\t\tinv[i] = mod_inv(fact[i]);\n\t\t}\n\t}\n};\n\nll gcd(ll m, ll n) {\n\tif (n == 0)return m;\n\treturn gcd(n, m % n);\n}//gcd\n\nll lcm(ll m, ll n) {\n\treturn m / gcd(m, n) * n;\n}\n\n\nMatrix mIdentity(ll n) {\n\tMatrix A(n, Array(n));\n\tfor (int i = 0; i < n; ++i) A[i][i] = 1;\n\treturn A;\n}\n\nMatrix mMul(const Matrix& A, const Matrix& B) {\n\tMatrix C(A.size(), Array(B[0].size()));\n\tfor (int i = 0; i < C.size(); ++i)\n\t\tfor (int j = 0; j < C[i].size(); ++j)\n\t\t\tfor (int k = 0; k < A[i].size(); ++k)\n\t\t\t\t(C[i][j] += (A[i][k] % MOD) * (B[k][j] % MOD)) %= MOD;\n\treturn C;\n}\n// O( n^3 log e )\nMatrix mPow(const Matrix & A, ll e) {\n\treturn e == 0 ? mIdentity(A.size()) :\n\t\te % 2 == 0 ? mPow(mMul(A, A), e / 2) : mMul(A, mPow(A, e - 1));\n}\n\ntemplate <class T>class RectangleSum {\npublic:\n\tvector<vector<T>> sum;\n\tT GetSum(int left, int right, int top, int bottom) { //[left, right], [top, bottom]\n\t\tT res = sum[bottom][right];\n\t\tif (left > 0) res -= sum[bottom][left - 1];\n\t\tif (top > 0) res -= sum[top - 1][right];\n\t\tif (left > 0 && top > 0) res += sum[top - 1][left - 1];\n\t\treturn res;\n\t}\n\tRectangleSum(const vector<vector<T>> &s, int h, int w) {\n\t\tsum.resize(h);\n\t\tfor (int i = 0; i < h; i++) sum[i].resize(w, 0);\n\t\tfor (int y = 0; y < h; y++) {\n\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\tsum[y][x] = s[y][x];\n\t\t\t\tif (y > 0) sum[y][x] += sum[y - 1][x];\n\t\t\t\tif (x > 0) sum[y][x] += sum[y][x - 1];\n\t\t\t\tif (y > 0 && x > 0) sum[y][x] -= sum[y - 1][x - 1];\n\t\t\t}\n\t\t}\n\t}\n};\n\n\nll dp[310][310][310];\nstring s;\n\nll solve(ll l, ll r, ll k) {\n\tif (dp[l][r][k] != -1)return dp[l][r][k];\n\tif (r - l < 0)return 0;\n\tif (r - l == 0)return 1;\n\tif (r - l == 1) {\n\t\tif (k >= 1)return 2;\n\t\telse return 1;\n\t}\n\n\tll mx = 0;\n\tif (s[l] == s[r])chmax(mx, solve(l + 1, r - 1, k)+2);\n\telse if (k >= 1)chmax(mx, solve(l + 1, r - 1, k - 1) + 2);\n\tchmax(mx, solve(l + 1, r, k));\n\tchmax(mx, solve(l, r - 1, k));\n\n\treturn dp[l][r][k] = mx;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> s;\n\tll k;\n\tcin >> k;\n\tmemset(dp, -1, sizeof(dp));\n\tcout << solve(0, s.size() - 1, k);\n\t\n\t\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint maxlcs(string s1, string s2, int k)\n{\n\tif (s1.empty() || s2.empty())\n\t\treturn 0;\n\tvector<vector<vector<int>>> ans(s1.size() + 1, vector<vector<int>>(s2.size() + 1, vector<int>(k + 1)));\n\tfor (int i = 0; i <= s1.size(); ++i)\n\t\tfor (int j = 0; j <= s2.size(); ++j)\n\t\t\tfor (int l = 0; l <= k; ++l)\n\t\t\t{\n\t\t\t\tif (i < s1.size())\n\t\t\t\t\tans[i + 1][j][l] = max(ans[i + 1][j][l], ans[i][j][l]);\n\t\t\t\tif (j < s2.size())\n\t\t\t\t\tans[i][j + 1][l] = max(ans[i][j + 1][l], ans[i][j][l]);\n\t\t\t\tif (l < k)\n\t\t\t\t\tans[i][j][l + 1] = max(ans[i][j][l + 1], ans[i][j][l]);\n\t\t\t\tif (i < s1.size() && j < s2.size())\n\t\t\t\t{\n\t\t\t\t\tif (s1[i] == s2[j])\n\t\t\t\t\t\tans[i + 1][j + 1][l] = max(ans[i + 1][j + 1][l], ans[i][j][l] + 1);\n\t\t\t\t\telse if (l < k)\n\t\t\t\t\t\tans[i + 1][j + 1][l + 1] = max(ans[i + 1][j + 1][l + 1], ans[i][j][l] + 1);\n\t\t\t\t}\n\t\t\t}\n\treturn ans.back().back().back();\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tstring s;\n\tcin >> s;\n\tint k;\n\tcin >> k;\n\tvector<vector<vector<int>>> dp(s.size(), vector<vector<int>>(s.size() + 1, vector<int>(k + 1)));\n\tint n = s.size();\n\tfor (int i = 0; i < n; ++i)\n\t\tdp[i][i + 1][0] = 1;\n\tfor (int len = 1; len <= n; ++len)\n\t\tfor (int i = 0; i + len <= n; ++i)\n\t\t{\n\t\t\tint j = i + len;\n\t\t\tfor (int l = 0; l <= k; ++l)\n\t\t\t{\n\t\t\t\tif (j < n)\n\t\t\t\t\tdp[i][j + 1][l] = max(dp[i][j + 1][l], dp[i][j][l]);\n\t\t\t\tif (i > 0)\n\t\t\t\t\tdp[i - 1][j][l] = max(dp[i - 1][j][l], dp[i][j][l]);\n\t\t\t\tif (l < k)\n\t\t\t\t\tdp[i][j][l + 1] = max(dp[i][j][l + 1], dp[i][j][l]);\n\t\t\t\tif (i > 0 && j < n)\n\t\t\t\t{\n\t\t\t\t\tif (s[i - 1] == s[j])\n\t\t\t\t\t\tdp[i - 1][j + 1][l] = max(dp[i - 1][j + 1][l], dp[i][j][l] + 2);\n\t\t\t\t\telse if (l < k)\n\t\t\t\t\t\tdp[i - 1][j + 1][l + 1] = max(dp[i - 1][j + 1][l + 1], dp[i][j][l] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcout << dp[0].back().back() << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define a cout << \"Hackinginginginginginging.....\" << endl;\n#define b a a a a\n#define c b b b b\n#define d c c c c\n#define e d d d d\n#define f e e e e\n#define g f f f f\n#define h g g g g\n#define i h h h h\n#define j i i i i\n#define k j j j j\n#define l k k k k\n#define m l l l l\n#define n m m m m\n#define o n n n n\n#define p o o o o\n#define q p p p p\n#define r q q q q\n#define s r r r r\n\nint main(){\n\ts;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nint n,m,f[305][305][305],g[305][305][305];\nchar s[305];\nint main(){\n\tscanf(\"%s\",s+1);\n\tscanf(\"%d\",&m);\n\tn=strlen(s+1);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int p=n;p;p--){\n\t\t\tfor(int j=0;j<=m;j++){\n\t\t\t\tf[i][p][j]=max(f[i-1][p][j],f[i][p+1][j]);\n\t\t\t\tg[i][p][j]=f[i][p][j];\n\t\t\t\tif(s[i]==s[p]) f[i][p][j]=max(f[i-1][p+1][j]+1,f[i][p][j]);\n\t\t\t\tif(j) f[i][p][j]=max(f[i][p][j],max(f[i-1][p][j-1],f[i][p+1][j-1])+1);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++) ans=max(ans,max(g[i][i][m]*2,f[i][i][m]*2-1));\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//実装が重そうな問題はある程度考えてから書く\n//初期化を忘れずに（特に二分探索とか）\n//コーナーケースを考えて（特に場合分けとか）\n//不可解すぎるバグは配列外参照（配列の長さ）を検討\n#include \"bits/stdc++.h\"\n#define YES \"YES\"\n#define Yes \"Yes\"\n#define NO \"NO\"\n#define No \"No\"\n#define YESNO(x) OUT(three(x,YES,NO))\n#define YesNo(x) OUT(three(x,Yes,No))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define rep REP\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b-1,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB emplace_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n//#define int long long\n#define zero 0LL\n#define all ALL\n#define pb PB\nusing namespace std;\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l < r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l > r ? l = r, 1 : 0; }\ntypedef long long LL;\ntypedef LL ll;\ntypedef double ld;\ntypedef LL ut;\nconst LL INF = 1LL << 60;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<ppr, Vppr ,greater<ppr> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nint dx[] = { 0,1,0,-1,1,1,-1,-1,0 }, dy[] = { 1,0,-1,0,1,-1,1,-1,0 };\nconst int SIZE1 =2e6 + 1000;\nconst int SIZE2 = 2010;\nconst int SIZE3 = 301;\nconst int SIZE = SIZE1;\nconst LL p = 7 + 1e9;const long double EPS = 1e-7;\nut N, M, K, X, L, Y,H,W,Q,D;\n// ut A,B,C,D,E,F,G,H,I,J,O,P,Q,R,T,U;\nVI edges[SIZE];\nLL vals[SIZE], nums[SIZE], maps[SIZE2][SIZE2], answer = zero;\n//LL A[SIZE], B[SIZE],I[SIZE];\nLL A, B;\nstring s;\nstring revs;\nLL DP[SIZE3][SIZE3][SIZE3];\nbool checked[SIZE3][SIZE3][SIZE3];\nLL solve2(int a,int b,int k) {\n\tif (a > b) return 0;\n\tif (a == b) return 1;\n\tif (checked[a][b][k]) return DP[a][b][k];\n\tchecked[a][b][k] = true;\n\n\tif (s[a] == s[b]) {\n\t\treturn DP[a][b][k] = solve2(a + 1, b - 1, k) + 2;\n\t}\n\tMX(DP[a][b][k], solve2(a + 1, b, k));\n\tMX(DP[a][b][k], solve2(a, b -1, k));\n\tif (k)\n\t\tMX(DP[a][b][k], solve2(a + 1, b -1, k - 1)+2);\n\treturn DP[a][b][k];\n\t/*/\n\tif (max(a, b) >= s.size()) return 0;\n\tif (checked[a][b][k]) return DP[a][b][k];\n\tchecked[a][b][k]=true;\n\tif (s[a] == revs[b]) {\n\t\treturn DP[a][b][k] = solve2(a + 1, b + 1, k)+1;\n\t}\n\tMX(DP[a][b][k], solve2(a + 1, b, k));\n\tMX(DP[a][b][k], solve2(a , b+1, k));\n\tif(k)\n\t\tMX(DP[a][b][k], solve2(a + 1, b+1, k-1));\n\treturn DP[a][b][k];\n/*/\n}\nLL solve() {\n\tcin >> s;\n\trevs = s;\n\treverse(ALL(revs));\n\tcin >> K;\n\tcout << solve2(0, (LL)s.size()-1, K) << endl;\n\treturn 0;\n}\nsigned main() {\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(10);\n\tsolve();\n\t//\tcin >> N;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\ntemplate<class T,class U> inline bool chmin(T&x,U y){T Y=static_cast<T>(y);if(x>Y){x=Y;return true;}return false;}\ntemplate<class T,class U> inline bool chmax(T&x,U y){T Y=static_cast<T>(y);if(x<Y){x=Y;return true;}return false;}\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define Fr(i,n) for(int i=1;i<=(n);++i)\n#define ifr(i,n) for(int i=(n)-1;i>=0;--i)\n#define iFr(i,n) for(int i=(n);i>0;--i)\n\nint LCS(string s,string t){\n    int n=s.length(),m=t.length();\n    vector<vector<int>> dp(n+1,vector<int>(m+1));\n    fr(i,n) fr(j,m){\n        if(s[i]==t[j]) dp[i+1][j+1]=dp[i][j]+1;\n        else dp[i+1][j+1]=max(dp[i][j+1],dp[i+1][j]);\n    }\n    return dp[n][m];\n}\n\nunsigned char dp[301][301][301]={};\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    string s;\n    int k;\n    cin>>s>>k;\n    int n=s.length(),ans{1};\n    Fr(i,n) Fr(j,n-i) fr(l,k+1){\n        if(s[i-1]==s[n-j]) chmax(dp[i][j][l],dp[i-1][j-1][l]+1);\n        else{\n            chmax(dp[i][j][l],max(dp[i-1][j][l],dp[i][j-1][l]));\n            if(l) chmax(dp[i][j][l],dp[i-1][j-1][l-1]+1);\n        }\n        if(i+j<n) chmax(ans,dp[i][j][l]*2+1);\n        else chmax(ans,dp[i][j][l]*2);\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nint n, mx;\nchar s[305];\nint d[305][305][305];\n\ninline void upd(int &x, int y) {\n    x = max(x, y);\n}\n\nint main() {\n    scanf(\"%s%d\", s, &mx);\n    n = strlen(s);\n    int ans = 1;\n    for (int i = 0; i <= n; ++i) {\n        for (int j = n; j >= i; --j) {\n            for (int k = 0; k <= mx; ++k) {\n                if (i == j) {\n                    ans = max(ans, d[i][j][k]);\n                } else if (i + 1 == j) {\n                    ans = max(ans, d[i][j][k] + 1);\n                } else {\n                    upd(d[i + 1][j][k], d[i][j][k]);\n                    upd(d[i][j - 1][k], d[i][j][k]);\n                    if (s[i] == s[j - 1]) {\n                        upd(d[i + 1][j - 1][k], d[i][j][k] + 2);\n                    } else if (k < mx) {\n                        upd(d[i + 1][j - 1][k + 1], d[i][j][k] + 2);\n                    }\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define sz(x) (int)(x.size())\n#define FOR(x,y,z) for(int x = y; x <= z; x++)\n#define int long long\n\nconst int N = 1e5 + 2, inf = 1e18;\n\nstring s, t;\nint n, k;\nint dp[302][302][302];\n\nint go(int l, int r, int rem){\n    if(rem < 0)\n        return -inf;\n    if(l >= r)\n        return l == r;\n\n    int &ans = dp[l][r][rem];\n    if(~ans) return ans;\n\n    ans = 0;\n    if(s[l] == s[r])\n        ans = max(ans, 2 + go(l + 1, r - 1, rem));\n    ans = max(ans, 2 + go(l + 1, r - 1, rem - 1));\n    ans = max({ans, go(l + 1, r, rem), go(l, r - 1, rem)});\n    return ans;\n\n}\n\nint32_t main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL); cout.tie(NULL);  \n\n    memset(dp, -1, sizeof(dp));\n    cin >> s >> k;\n    n = sz(s);\n    cout << go(0,n-1,k);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <list>\n#include <vector>\n#include <string>\n#include <stack>\n#include <limits>\n#include <climits>\n#include <cassert>\n#include <fstream>\n#include <cstring>\n#include <cmath>\n#include <bitset>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <cstdio>\n#include <ciso646>\n#include <set>\n#include <array>\n#include <unordered_map>\n#include <complex>\n\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\n#define inf 0x3f3f3f3f\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define SET(a,c) memset(a,c,sizeof a)\n#define CLR(a) memset(a,0,sizeof a)\n#define VS vector<string>\n#define VI vector<ll>\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define MIN(a,b) (a>b?b:a)\n#define MAX(a,b) (a>b?a:b)\n#define pi 2*acos(0.0)\n#define INFILE() freopen(\"in0.txt\",\"r\",stdin)\n#define OUTFILE()freopen(\"out0.txt\",\"w\",stdout)\n#define ll long long\n#define ull unsigned long long\n#define pii pair<ll,ll>\n#define pcc pair<char,char>\n#define pic pair<ll,char>\n#define pci pair<char,ll>\n#define eps 1e-14\n#define FST first\n#define SEC second\n#define SETUP cin.tie(0), ios::sync_with_stdio(false), cout << setprecision(15)\n\nnamespace {\n\tstruct input_returnner {\n\t\tll N; input_returnner(ll N_ = 0) :N(N_) {}\n\t\ttemplate<typename T> operator vector<T>() const { vector<T> res(N); for (auto &a : res) cin >> a; return std::move(res); }\n\t\ttemplate<typename T> operator T() const { T res; cin >> res; return res; }\n\t\ttemplate<typename T> T operator - (T right) { return T(input_returnner()) - right; }\n\t\ttemplate<typename T> T operator + (T right) { return T(input_returnner()) + right; }\n\t\ttemplate<typename T> T operator * (T right) { return T(input_returnner()) * right; }\n\t\ttemplate<typename T> T operator / (T right) { return T(input_returnner()) / right; }\n\t\ttemplate<typename T> T operator << (T right) { return T(input_returnner()) << right; }\n\t\ttemplate<typename T> T operator >> (T right) { return T(input_returnner()) >> right; }\n\t};\n\ttemplate<typename T> input_returnner in() { return in<T>(); }\n\tinput_returnner in() { return input_returnner(); }\n\tinput_returnner in(ll N) { return std::move(input_returnner(N)); }\n}\n\nconst ll MOD = 1e9 + 7;\n\nvoid solve();\n\nsigned main() {\n\tSETUP;\n\tsolve();\n#ifdef _DEBUG\n\tsystem(\"pause\");\n#endif\n\treturn 0;\n}\n\nint dp[302][302][301] = {}; // dp[l][r][x] : x個文字列を変更する権利を使用した時に, [l,r)間で最長となる回文\n\nvoid solve() {\n\tstring S; cin >> S;\n\tint K; cin >> K;\n\tREP(i, S.size()) REP(x,K+1){\n\t\tdp[i][i + 1][x] = 1;\n\t}\n\tFOR(w, 2, S.size()+1) {\n\t\tFOR(l, 0, S.size() + 1 - w) {\n\t\t\tFOR(x, 0, K+1) {\n\t\t\t\tint r = l + w;\n\t\t\t\t// cout << S[l] << \" \" << S[r-1] << endl;\n\t\t\t\tif (S[l] == S[r-1]) {\n\t\t\t\t\tdp[l][r][x] = dp[l + 1][r - 1][x] + 2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[l][r][x] = max(dp[l + 1][r][x], dp[l][r - 1][x]);\n\t\t\t\t\tif(x-1 >= 0) dp[l][r][x] = max(dp[l][r][x], dp[l + 1][r - 1][x - 1] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tREP(i, K+1) {\n\t\tres = max(res, dp[0][S.size()][i]);\n\t}\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define dro first\n#define adg second.first\n#define mog second.second\n#define ll long long\nusing namespace std;\n\nconst int N = 500001;\n\nint n,r,pos,l,x,U,D,S;\n \nlong long ans;\nint K;\n\nstring s;\n\nint fix[100],fix1[100],A[100],B[100];\n\nint dp[305][305][305];\n\nint main(){\n    \n    cin>>s;\n    \n    n=s.size();\n    \n    cin>>K;\n    \n    for(int j=0;j<n;j++)\n    for(int l=0;l+j<n;l++)\n    for(int k=0;k<=K;k++){\n        \n        int r = l+j;\n        \n        if(l==r){\n            dp[l][r][k] = 1;\n            continue;\n            //dp[l][r][1] = 1\n        }\n\n        if(l+1==r){\n            if(k==0){\n                dp[l][r][k] = 1;\n                if(s[l] == s[r]) dp[l][r][k] = 2;\n            } else {\n                dp[l][r][k] = 2;\n            }\n            \n            continue;\n        }\n        \n        dp[l][r][k] = max( dp[l+1][r][k], dp[l][r-1][k]);\n        //cout<<dp[l+1][r][k]<<\" \"<<l<<\" \"<<r<<\" \"<<k<<endl;\n        //cout<<dp[l][r-1][k]<<\" \"<<l<<\" \"<<r<<\" \"<<k<<endl;\n        if(s[l]==s[r])\n            dp[l][r][k] = max( dp[l][r][k], dp[l+1][r-1][k] + 2);\n        else {\n            if(k-1>=0)\n            dp[l][r][k] = max( dp[l][r][k], dp[l+1][r-1][k-1] + 2);\n        }\n\n        //cout<<dp[l][r][k]<<\" \"<<l<<\" \"<<r<<\" \"<<k<<endl;\n    }\n    \n    cout<<dp[0][n-1][K]<<endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LD long double\n#define SC(t,x) static_cast<t>(x)\n#define AR(t) vector < t >\n#define PII pair < int, int >\n#define PLL pair < LL, LL >\n#define PIL pair < int, LL >\n#define PLI pair < LL, int >\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define PRF first\n#define PRS second\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\n#define qmax(a,b) (((a)>(b))?(a):(b))\n#define qmin(a,b) (((a)<(b))?(a):(b))\n#define qabs(a) (((a)>=0)?(a):(-(a)))\n\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 307;\n\nint n, K;\nchar s[MAXN];\nint dp[MAXN][MAXN][MAXN];\n\nvoid init ();\nvoid input ();\nvoid work ();\n\n\n\nint main ()\n{\n\tinit ();\n\tinput ();\n\twork ();\n}\n\n\n\nvoid init ()\n{\n\t// Init Everything Here\n\n\tios::sync_with_stdio ( false );\n}\n\nvoid input ()\n{\n\t// input method\n\n\tscanf ( \"%s%d\", s + 1, &K );\n}\n\nvoid work ()\n{\n\t// main work\n\n\tn = strlen ( s + 1 );\n\n\tlpi ( i, 0, K ) {\n\t\tlpi ( l, 1, n ) dp[l][l][i] = 1;\n\t\tlpi ( d, 2, n ) {\n\t\t\tlpi ( l, 1, n - d + 1 ) {\n\t\t\t\tint r = l + d - 1;\n\t\t\t\tdp[l][r][i] = qmax ( dp[l + 1][r][i], dp[l][r - 1][i] );\n\t\t\t\tif ( s[l] == s[r] ) dp[l][r][i] = qmax ( dp[l][r][i], dp[l + 1][r - 1][i] + 2 );\n\t\t\t\telse if ( i ) dp[l][r][i] = qmax ( dp[l][r][i], dp[l + 1][r - 1][i - 1] + 2 );\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[1][n][K] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll int\n#define f first\n#define s second\n#define pb push_back\nusing namespace std;\nll dp[301][301][301],k;\nstring s;\ninline ll solve(ll x,ll y,ll p){\n    if(dp[x][y][p])return dp[x][y][p];\n    if(x == y){\n        dp[x][y][p] = 1;\n        return dp[x][y][p];\n    }\n    if(x + 1 == y){\n        if(s[x] == s[y] || p)dp[x][y][p] = 2;\n        else dp[x][y][p] = 1;\n        return dp[x][y][p];\n    }\n    if(p == 0){\n        if(s[x] == s[y]){\n            dp[x][y][p] = solve(x + 1 ,y - 1, p) + 2;\n            return dp[x][y][p];\n        }\n        ll t = solve(x , y - 1 , p);\n        ll r = solve(x + 1 , y , p);\n        return max(t , r);\n    }\n    if(s[x] == s[y]){\n        dp[x][y][p] = solve(x + 1, y - 1 , p) + 2;\n        return dp[x][y][p];\n    }\n    dp[x][y][p] = solve(x + 1 , y - 1 , p);\n    ll t = solve(x , y - 1 , p);\n    ll r = solve(x + 1 , y , p);\n    ll q = solve(x + 1 , y - 1, p - 1) + 2;\n    q = max(q , max(t , r));\n    if(dp[x][y][p] < q)dp[x][y][p] = q;\n    return dp[x][y][p];\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin >> s >> k;\n    \n    cout << solve(0 , (int)s.size() - 1 , k);\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/************************************************\n * Au: Hany01\n * Date: Feb 25th, 2018\n * Prob: AGC021 D Reversed LCS\n * Email: hany01@foxmail.com\n************************************************/\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define rep(i, j) for (register int i = 0, i##_end_ = (j); i < i##_end_; ++ i)\n#define For(i, j, k) for (register int i = (j), i##_end_ = (k); i <= i##_end_; ++ i)\n#define Fordown(i, j, k) for (register int i = (j), i##_end_ = (k); i >= i##_end_; -- i)\n#define Set(a, b) memset(a, b, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define fir first\n#define sec second\n#define pb(a) push_back(a)\n#define mp(a, b) make_pair(a, b)\n#define ALL(a) (a).begin(), (a).end()\n#define SZ(a) ((int)(a).size())\n#define INF (0x3f3f3f3f)\n#define INF1 (2139062143)\n#define Mod (1000000007)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define y1 wozenmezhemecaia\n\ntemplate <typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\n\ninline int read()\n{\n\tregister int _, __; register char c_;\n    for (_ = 0, __ = 1, c_ = getchar(); c_ < '0' || c_ > '9'; c_ = getchar()) if (c_ == '-') __ = -1;\n    for ( ; c_ >= '0' && c_ <= '9'; c_ = getchar()) _ = (_ << 1) + (_ << 3) + (c_ ^ 48);\n    return _ * __;\n}\n\ninline void File()\n{\n#ifdef hany01\n    freopen(\"agc021d.in\", \"r\", stdin);\n    freopen(\"agc021d.out\", \"w\", stdout);\n#endif\n}\n\nconst int maxn = 310;\n\nchar s[maxn];\nint n, k, f[maxn][maxn][maxn];\n\nint main()\n{\n    File();\n\tscanf(\"%s\", s + 1), n = strlen(s + 1), k = read();\n\tFor(len, 2, n)\n\t\tFor(st, 1, n - len + 1) {\n\t\t\tregister int ed = st + len - 1;\n\t\t\tFor(i, 0, k) {\n\t\t\t\tif (st == ed) f[st][ed][i] = 1;\n\t\t\t\telse if (st + 1 == ed) f[st][ed][i] = i || s[st] == s[ed] ? 2 : 1;\n\t\t\t\telse {\n\t\t\t\t\tf[st][ed][i] = max(f[st + 1][ed][i], f[st][ed - 1][i]);\n\t\t\t\t\tif (s[st] == s[ed]) chkmax(f[st][ed][i], f[st + 1][ed - 1][i] + 2);\n\t\t\t\t\tif (i) chkmax(f[st][ed][i], f[st + 1][ed - 1][i - 1] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\", f[1][n][k]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma comment(linker, \"/STACK:108777216\")\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <functional>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <deque>\n#include <utility>\n#include <algorithm>\n#include <ctime>\nusing namespace std;\n\nint const MAX_N = 128 * 3;\n\nint n;\nint dp[MAX_N][MAX_N];\n\nint calc(const string & st) {\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tdp[i][j] = 0;\n\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++) {\n\t\t\tdp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n\t\t\tif (st[i-1] == st[n-j])\n\t\t\t\tdp[i][j] = max(dp[i][j], dp[i-1][j-1]+1);\n\t\t}\n\n\treturn dp[n][n];\n}\n\nint main() {\n\t//freopen(\"input.txt\",\"r\",stdin);\n\t//freopen(\"output.txt\",\"w\",stdout);\n\n\tstring st;\n\tcin>>st;\n\tint k;\n\tcin>>k;\n\n\tn = (int) st.length();\n\n\twhile (k-->0) {\n\t\tint ans_i = -1, mx = -1;\n\t\tchar ans_ch = 0;\n\t\tfor (int i=0; i<n; i++)\n\t\t\tfor (char ch='a'; ch<='z'; ch++) {\n\t\t\t\tstring q = st;\n\t\t\t\tq[i] = ch;\n\t\t\t\tint loc_ans = calc(q);\n\t\t\t\tif (loc_ans > mx) {\n\t\t\t\t\tmx = loc_ans;\n\t\t\t\t\tans_i = i;\n\t\t\t\t\tans_ch = ch;\n\t\t\t\t}\n\t\t\t}\n\t\tst[ans_i] = ans_ch;\n\t}\n\tcout<<calc(st);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 305\nusing namespace std;\nchar c[N];\nint i,j,k,l,s,n,m,ans,f[N][N][N];\nint main() {\n\tscanf(\"%s\",c+1);\n\tn=strlen(c+1);\n\tscanf(\"%d\",&m);\n\tm*=2;\n\tfor (i=1;i<=n;i++)\n\tfor (j=n;j;j--)\n\tfor (k=0;k<=m;k++) {\n\t\tif (c[i]==c[j]) f[i+1][j-1][k]=max(f[i+1][j-1][k],f[i][j][k]+1);\n\t\telse if (k<m) f[i+1][j-1][k+1]=max(f[i+1][j-1][k+1],f[i][j][k]+1);\n\t\tf[i+1][j][k]=max(f[i+1][j][k],f[i][j][k]);\n\t\tf[i][j-1][k]=max(f[i][j-1][k],f[i][j][k]);\n\t}\n\tfor (i=0;i<=m;i++) ans=max(ans,f[n+1][0][i]);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nint n,m,f[305][305][305],g[305][305][305];\nchar s[305];\nint main(){\n\tscanf(\"%s\",s+1);\n\tscanf(\"%d\",&m);\n\tn=strlen(s+1);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int p=n;p;p--){\n\t\t\tfor(int j=0;j<=m;j++){\n\t\t\t\tf[i][p][j]=max(f[i-1][p][j],f[i][p+1][j]);\n\t\t\t\tg[i][p][j]=f[i][p][j];\n\t\t\t\tif(s[i]==s[p]) f[i][p][j]=max(f[i-1][p+1][j]+1,f[i][p][j]);\n\t\t\t\tif(j) f[i][p][j]=max(f[i][p][j],f[i-1][p+1][j-1]+1);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++) ans=max(ans,max(g[i][i][m]*2,f[i][i][m]*2-1));\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst ll SIZE = 1e5 * 2 + 10, INF = 1e9 + 10, MOD = 1e9 + 7;\n\nconst ll SQR = 10000;\n\nll dp[303][303][303];\nbool used[303][303];\nstring s;\nll k, ans = 0;\n\nvoid lcs(ll l, ll r) {\n    if (used[l][r]) return;\n    used[l][r] = 1;\n    if (l == r) {\n        for (int t = 0; t <= k; t++) {\n            dp[l][r][t] = 1;\n            ans = max(ans, dp[l][r][t]);\n        }\n        return;\n    } else if (l == r - 1) {\n        lcs(l + 1, r);\n        lcs(l, r - 1);\n        for (int t = 0; t <= k; t++) {\n            dp[l][r][t] = 1;\n            dp[l][r][t] = max(ll((s[l] == s[r]) * 2), dp[l][r][t]);\n            if (t > 0) {\n                dp[l][r][t] = max(dp[l][r][t], 2ll);\n            }\n            ans = max(ans, dp[l][r][t]);\n        }\n        return;\n    } else {\n        lcs(l + 1, r);\n        lcs(l, r - 1);\n        for (int t = 0; t <= k; t++) {\n            dp[l][r][t] = max(dp[l + 1][r][t], dp[l][r - 1][t]);\n            if (s[l] == s[r]) dp[l][r][t] = max(dp[l + 1][r - 1][t] + 2, dp[l][r][t]);\n            if (t > 0) {\n                dp[l][r][t] = max(dp[l][r][t], dp[l][r][t - 1]);\n                dp[l][r][t] = max(dp[l + 1][r - 1][t - 1] + 2, dp[l][r][t]);\n            }\n            ans = max(ans, dp[l][r][t]);\n        }\n    }\n}\n\nint main()\n{\n    fastInp;\n\n    cin >> s;\n    cin >> k;\n\n    lcs(0, s.size() - 1);\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring str;\nint dp[302][302][302];\nint solve(int l, int r, int i){\n\tif(r-l == 1){\n\t\treturn dp[l][r][0] = 1;\n\t}else if(r-l == 2){\n\t\tdp[l][r][i] = 1;\n\t\tif(str[l] == str[r-1] || i > 0)dp[l][r][i] = 2;\n\t\treturn dp[l][r][i];\n\t}\n\tif(i == 0){\n\t\tif(str[l] == str[r-1])dp[l][r][0] = dp[l+1][r-1][0]+2;\n\t\telse dp[l][r][0] = max(dp[l+1][r][0], dp[l][r-1][0]);\n\t}else{\n\t\tif(str[l] == str[r-1])dp[l][r][i] = max(dp[l][r][i], dp[l+1][r-1][i]+2);\n\t\tint res1 = max(dp[l+1][r][i], dp[l][r-1][i]);\n\t\tint res2 = dp[l+1][r-1][i-1]+2;\n\t\tint res = max(res1, res2);\n\t\tdp[l][r][i] = max(dp[l][r][i], res);\n\t}\n\treturn dp[l][r][i];\n}\n\nint main(){\n\tint k, ans = 0;\n\tcin >> str >> k;\n\tint n = str.size();\n\tfor(int i = 0;i <= k;i++){\n\t\tfor(int l = n-1;l >= 0;l--){\n\t\t\tfor(int r = l+1;r <= n;r++){\n\t\t\t\tint res = solve(l, r, i);\n\t\t\t\tans = max(ans, res);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j <= n;j++)printf(\"%d \", dp[i][j][0]);\n\t\tprintf(\"\\n\");\n\t}*/\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define pb push_back\n\nconst int maxn = 3e2 + 20;\n\nint dp[maxn][maxn][maxn];\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tstring s;\n\tcin >> s;\n\n\tint k;\n\tcin >> k;\n\n\tint n = s.size();\n\n\tfor(int l = n - 1; l >= 0; l--)\n\t\tfor(int r = l; r < n; r++)\n\t\t\tfor(int i = 0; i <= k; i++)\n\t\t\t{\n\t\t\t\tif(l == r)\n\t\t\t\t{\n\t\t\t\t\tdp[l][r][i] = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif(r - l + 1 == 2)\n\t\t\t\t{\n\t\t\t\t\tdp[l][r][i] = 1;\n\t\t\t\t\tif(s[l] == s[r] || i)\n\t\t\t\t\t\tdp[l][r][i] = 2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif(i)\n\t\t\t\t\tdp[l][r][i] = max(dp[l][r][i] , dp[l + 1][r - 1][i - 1] + 2);\n\t\t\t\tif(s[l] == s[r])\n\t\t\t\t\tdp[l][r][i] = max(dp[l][r][i] , dp[l + 1][r - 1][i] + 2);\n\n\t\t\t\tdp[l][r][i] = max(dp[l][r][i] , max(dp[l + 1][r][i] , dp[l][r - 1][i]));\n\t\t\t}\n\n\tcout << dp[0][n - 1][k] << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nstatic const int INF = 1000000000;\nstatic int dp[301][301][301];\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint k;\n\tstring s;\n\tcin >> s >> k;\n\tstring t(s);\n\treverse(t.begin(), t.end());\n\tconst int n = s.size();\n\tfor(int i = 0; i <= k; ++i){\n\t\tfor(int x = 0; x <= n; ++x){\n\t\t\tfor(int y = 0; y <= n; ++y){ dp[i][x][y] = -INF; }\n\t\t}\n\t}\n\tdp[0][0][0] = 0;\n\tfor(int i = 0; i <= k; ++i){\n\t\tfor(int x = 0; x <= n; ++x){\n\t\t\tfor(int y = 0; y <= n; ++y){\n\t\t\t\tconst int cur = dp[i][x][y];\n\t\t\t\tif(x < n && y < n){\n\t\t\t\t\tif(s[x] == t[y]){ dp[i][x + 1][y + 1] = max(dp[i][x + 1][y + 1], cur + 1); }\n\t\t\t\t\tif(i < k){ dp[i + 1][x + 1][y + 1] = max(dp[i + 1][x + 1][y + 1], cur + 1); }\n\t\t\t\t\tdp[i][x + 1][y + 1] = max(dp[i][x + 1][y + 1], cur);\n\t\t\t\t}\n\t\t\t\tif(x < n){ dp[i][x + 1][y] = max(dp[i][x + 1][y], cur); }\n\t\t\t\tif(y < n){ dp[i][x][y + 1] = max(dp[i][x][y + 1], cur); }\n\t\t\t\tif(i < k){ dp[i + 1][x][y] = max(dp[i + 1][x][y], cur); }\n\t\t\t}\n\t\t}\n\t}\n\t/*\nfor(int i = 0; i <= k; ++i){\n\tfor(int x = 0; x <= n; ++x){\n\t\tfor(int y = 0; y <= n; ++y){ cout << dp[i][x][y] << \" \" ;}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n*/\n\tint answer = 0;\n\tfor(int i = 0; i <= n; ++i){\n\t\tanswer = max(answer, 2 * dp[k][i][n - i]);\n\t}\n\tfor(int i = 1; i <= n; ++i){\n\t\tanswer = max(answer, 1 + 2 * dp[k][i - 1][n - i]);\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n\tstring s;\n\tint k;\n\tcin>>s; cin>>k;\n\tint n=s.size();\n\tint dp[301][301][301]={};\n\tfor(int l=0; l<=k; l++){\n\t\tfor(int i=0; i<n; i++){\n\t\t\tdp[l][i][i+1]=1;\n\t\t}\n\t}\n\tfor(int d=2; d<=n; d++){\n\t\tfor(int l=0; l<=k; l++){\n\t\t\tfor(int i=0; i<=n-d; i++){\n\t\t\t\tif(s[i]==s[i+d-1]){\n\t\t\t\t\tdp[l][i][i+d]=max(dp[l][i][i+d], max(dp[l][i][i+d-1], max(dp[l][i+1][i+d], dp[l][i+1][i+d-1]+2)));\n\t\t\t\t}else{\n\t\t\t\t\tdp[l][i][i+d]=max(dp[l][i][i+d], max(dp[l][i][i+d-1], dp[l][i+1][i+d]));\n\t\t\t\t\tif(l>=1) dp[l][i][i+d]=max(dp[l][i][i+d], dp[l-1][i+1][i+d-1]+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int l=0; l<=k; l++){\n\t\tans=max(ans, dp[l][0][n]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long \n#define pb push_back\n#define ms(a,b) memset(a,b,sizeof a)\n#define F(i,a,b) for (int i=a;i<=b;i++)\n#define DF(i,a,b) for (int i=a;i>=b;i--)\n#define SZ(x) (int)x.size()-1\nusing namespace std;\ninline int read(){\n\tchar ch=getchar(); int w=1,c=0;\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') w=-1;\n\tfor (;isdigit(ch);ch=getchar()) c=(c<<1)+(c<<3)+(ch^48);\n\treturn w*c;\n}\nconst int M=333;\nint dp[M][M][M];\nchar s[M];\nint n,k;\nint solve(int x,int y,int l){\n\tif (dp[x][y][l]) return dp[x][y][l];\n\tif (l<0) return -1e9;\n\tif (x>y) return 0;\n\tif (x==y) return dp[x][y][l]=1;\n\tdp[x][y][l]=max(solve(x+1,y-1,l-(s[x]!=s[y]))+2,max(solve(x+1,y,l),solve(x,y-1,l)));\n\treturn dp[x][y][l];\n} \nint main(){\n\tscanf(\"%s%d\",s+1,&k);\n\tn=strlen(s+1);\n\tcout<<solve(1,n,k)<<\"\\n\";\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Azat Ismagilov\n */\n\n/**********.*****.**************************:-******-:*******************\n**********......:*****************+@%@*+#@@@+.****.***********************\n...------........-*+*********+%#####@@@##########*************************\n********:........----------%@#####################@@-...............------\n**********......:********@%#####@###################@#@=+***************::\n*********.:****--******%##@#####@#######################@*+***************\n********.*******:-**+@@####@#@@@#################@#########=**************\n*******-*********:*@@@######@###############################=*************\n*****--**********%%@##@########@#############################=:***********\n****.************+##################@#@@#####################@************\n***.*************%######################@@###################=***********-\n*-:**************=##########@@%%%%=%@=%=%=%@################@@**********.*\n.****************########%++***+++****+++=+===+++***+=%@######%*******:-**\n****************+#######%+*::::::::::::***********:::::**@@###%******.:***\n****************#######@%*:::::::::::::::*:*****:::::::::*@@##@*****.*****\n****************######@%+*:::::::-::::::::::::::::::::::::=@##%****-******\n.......-------:*######=::::::----------:::::::::::::::::::+###:**--*******\n............:==:%####=:::::----:-:::::::::::::::::::::::::=@##:-.:********\n************=@++*%##@::::*=%%%@@###@=***::::::::::::::::::=@#@*..*********\n************=**+@+@#*:::**+++%@#@###%@%%+*::*+=======*::::*##-:**.********\n*************:=%%:%*::::*+=%##%###=@@@%=*::*=%@@@%%@@#@%::+#@:****.*******\n:**************==:=:::--::::*++++=%@@@%*:--*%#@####@#=+***@@%@*****.******\n--**************:-*::--------::**+***:::---*+%%%%%%@@%+*::#*@%******.*****\n*:-************---*::::-----------::--:---::::+++++**:::::%*%********-:***\n**:.************++*:::::--------::**+------::::::::::::::*++**********--**\n****.**************::::::-----::**==:-------+*:::::---:::**************:-*\n*****.***********.*::::::::-:::***:*+@**::**=+*::::::::::****************-\n******.*:*%@######+::::::::::::::::::++++=******::::::::******************\n******:############*::::::::****::::::*+*:*:*:***::::::*******************\n******#############***::*:*:*+==@@##=======:*+***:::*:********************\n******#############:*+**********:*++**+**++=%=***:*::*********************\n.....##############::*++**************+***:*********###+******************\n***:##############@*:**+=***:::**++===++***********#####%.................\n*:*###############******++=+*:::::::*:::::*::***#########=****************\n**:################%*****++==++********::::*+++=##########+***************\n*:%##################******++++==+=++++++++++++@############**************\n######################@******+++++++++++++++++=%#############*************\n########################+++++++++++++++++++++==@#############@***********.\n#########################%+++++++++++++++++===%###############%********:-*\n########################@=#=++++++++++++====%@##################******-**/\n\n#include <bits/stdc++.h>\n\n#define int long long\n#define fs first\n#define sc second\n#define pb push_back\n#define ppb pop_back\n#define pf push_front\n#define ppf pop_front\n#define mp make_pair\n#define len(v) ((int)v.size())\n#define vc vector\n#define pr pair\n#define endd \"\\n\"; return 0;\n#define all(v) v.begin(), v.end()\n\nusing namespace std;\n\nconst int MAXN = 1e5;\nconst int INF = 1e18;\nconst int MOD = 1e9 + 7;\n\n\nint dp[1000][1000];\n\nclass TaskD {\npublic:\n    void solve(std::istream &in, std::ostream &out) {\n        string s;\n        in >> s;\n        string s1 = s;\n        reverse(all(s1));\n        int k;\n        in >> k;\n        int n = len(s);\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = (s[i] == s1[0]);\n        }\n        for (int i = 0; i < n; i++) {\n            dp[0][i] = (s1[i] == s[0]);\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n                if (s[i] == s1[j]) {\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1);\n                }\n            }\n        }\n        out << min(n, dp[n - 1][n - 1] + 2 * k);\n    }\n};\n\n\nmain() {\n    TaskD solver;\n    std::istream &in(std::cin);\n    std::ostream &out(std::cout);\n    ios_base::sync_with_stdio(0);\n    in.tie(0);\n    solver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll MOD = (1e+9)+7;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nint dp[301][301][302] = {};\nint main() {\n\tstring s; cin >> s; int n = s.length();\n\tint c; cin >> c;\n\trep(i, n) {\n\t\trep(k, c+1) {\n\t\t\trep(j, n+1) {\n\t\t\t\tif (j < n) {\n\t\t\t\t\tif (s[i] == s[n - 1 - j]) {\n\t\t\t\t\t\tdp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (k < c) {\n\t\t\t\t\t\tdp[i + 1][j + 1][k + 1] = max(dp[i + 1][j + 1][k + 1], dp[i][j][k] + 2);\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j + 1][k] = max(dp[i][j + 1][k], dp[i][j][k]);\n\t\t\t\t}\n\t\t\t\tdp[i + 1][j][k] = max(dp[i + 1][j][k], dp[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tint out = 0;\n\trep(i, n + 1) {\n\t\trep(j, n + 1) {\n\t\t\trep(k, c+1) {\n\t\t\t\tout = max(out, dp[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << out << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mk make_pair\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nint mem[301][301][301];\nstring a;\nint dp(int x, int y, int z){\n\n  if(x>y)\n    return 0;\n\n  if(mem[x][y][z]!=-1)\n    return mem[x][y][z];\n\n  int res=0;\n  if(a[x]==a[y]){\n    if(x==y)\n      res=max(max( 1+dp(x+1,y-1, z), dp(x+1, y, z)), dp(x, y-1, z));\n    else\n      res=max(max( 2+dp(x+1,y-1, z), dp(x+1, y, z)), dp(x, y-1, z));\n  }\n  else{\n    if(x==y){\n      if(z>0)\n        res=max(max( 1+dp(x+1,y-1, z-1), dp(x+1, y, z)), dp(x, y-1, z));\n      else\n        res=max(dp(x+1, y, z), dp(x, y-1, z));\n    }\n    else{\n      if(z>0)\n        res=max(max( 2+dp(x+1,y-1, z-1), dp(x+1, y, z)), dp(x, y-1, z));\n      else\n        res=max( dp(x+1, y, z), dp(x, y-1, z));\n    }\n  }\n//  cout<<x<<\" \"<<y<<\" \"<<z<<\"==\"<<res<<endl;\n  mem[x][y][z]=res;\n  return res;\n}\n\nint main(){\n  int k;\n  while(cin>>a>>k){\n    memset(mem, -1, sizeof mem);\n    int ans, n;\n    n=a.size();\n    --n;\n    ans=dp(0, n, k);\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntemplate<typename T> void chkmax(T &a, const T &b) { a = a > b ? a : b; }\ntemplate<typename T> void chkmin(T &a, const T &b) { a = a < b ? a : b; }\n\nconst int MAXN = 305;\nchar S[MAXN];\nint f[2][MAXN][MAXN], n, K;\n\nint main() {\n\tscanf(\"%s%d\", S + 1, &K);\n\tn = strlen(S + 1);\n\tmemset(f[1], 0xc0, sizeof(f[1]));\n\tfor (int i = 0; i <= K; i++) {\n\t\tint a = i & 1, b = !a;\n\t\tfor (int j = n; j > 0; j--) {\n\t\t\tf[a][j][j] = 1;\n\t\t\tfor (int k = j + 1; k <= n; k++) {\n\t\t\t\tchkmax(f[a][j][k], max(f[a][j + 1][k], f[a][j][k - 1]));\n\t\t\t\tchkmax(f[a][j][k], max(f[b][j][k], f[S[j] == S[k] ? a : b][j + 1][k - 1] + 2));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", f[K & 1][1][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n// #define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 313;\nstring z,z2;\nint n,k;\nint dp[MAX][MAX][MAX];\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> z >> k;\n  n = SZ(z);\n  z2 = z;\n  reverse(ALL(z));\n  R(i,n+1)R(j,n+1)R(kk,k+1){\n    if(i < n && j < n && z[i] == z2[j]){\n      maxi(dp[i+1][j+1][kk], dp[i][j][kk] + 1);\n    }\n    maxi(dp[i+1][j+1][kk+1], dp[i][j][kk] + 1);\n    maxi(dp[i+1][j][kk], dp[i][j][kk]);\n    maxi(dp[i][j+1][kk], dp[i][j][kk]);\n  }\n  int res = 0;\n  debug(dp[4][4][1]);\n  R(i,n){\n    maxi(res,1 + dp[i][n-i-1][k] * 2);\n  }\n  R(i,n+1){\n    maxi(res,dp[i][n - i][k] * 2);\n  }\n  cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp> // Common file\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\ntypedef tree<\nll,\nnull_type,\nless<ll>,\nrb_tree_tag,\ntree_order_statistics_node_update>\nordered_set;\n// ordered_set X;\n// *X.find_by_order(i) = ith largest element (counting from zero)\n// X.order_of_key(k) = number of items in X < k (strict lt)\nint main(){\n    string S;\n    int K;\n\n    cin >> S;\n    cin >> K;\n\n    int N = S.length();\n\n    vi dpr1(K+1, 0);\n    vvi dpr2(N+1, dpr1);\n    vector<vvi> dp(N+1, dpr2); // dp[i][j][k]\n\n    for (int len=1;len<=N;len++) {\n        for (int i=0;i+len<=N;i++) {\n            for(int k=0;k<=K;k++) {\n                int j = i+len;\n                if (k > 0) dp[i][j][k] = max(dp[i][j][k], dp[i][j][k-1]);\n\n                if (S[i] == S[i+len-1]) {\n                    if (len == 1) dp[i][j][k] = max(dp[i][j][k], 1 + dp[i+1][j-1][k]);\n                    else dp[i][j][k] = max(dp[i][j][k], 2 + dp[i+1][j-1][k]);\n                }\n\n                dp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k]);\n                dp[i][j][k] = max(dp[i][j][k], dp[i+1][j][k]);\n\n                if (k > 0) {\n                    if (len == 1) dp[i][j][k] = max(dp[i][j][k], 1 + dp[i+1][j-1][k-1]);\n                    else dp[i][j][k] = max(dp[i][j][k], 2 + dp[i+1][j-1][k-1]);\n                }\n            }\n        }\n    }\n\n    cout << dp[0][N][K] << endl;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nchar s[310];\nint n,k,F[310][310][310];\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tk=read();\n\tfor(int i=1;i<=n;i++) F[i][i][0]=1;\n\tfor(int i=1;i<n;i++)\n\t\tF[i][i+1][0]=(s[i]==s[i+1])*2;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int l=1;l+i-1<=n;l++)\n\t\t{\n\t\t\tint r=l+i-1;\n\t\t\tfor(int ks=0;ks<=k;ks++)\n\t\t\t{\n\t\t\t\tif(l>1) F[l-1][r][ks]=max(F[l-1][r][ks],F[l][r][ks]);\n\t\t\t\tif(l>1&&r<n) F[l-1][r+1][ks]=max(F[l-1][r+1][ks],F[l][r][ks]+(s[l-1]==s[r+1])*2);\n\t\t\t\tif(r<n) F[l][r+1][ks]=max(F[l][r+1][ks],F[l][r][ks]);\n\t\t\t\tif(l>1&&r<n) F[l-1][r+1][ks+1]=max(F[l-1][r+1][ks+1],F[l][r][ks]+2);\n\t\t\t}\n\t\t}\n\t}\n\tint Ans=0; for(int i=0;i<=k;i++) Ans=max(Ans,F[1][n][i]);\n\tcout << Ans << endl; return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define inf 0x7fffffff\n#define X first\n#define Y second\n#define N 120010\ntypedef long long ll;\nint dp[305][305][305];\nchar s[305];\n\nint dfs(int l,int r,int k){\n\tif(l>r)return 0;\n\tif(l==r)return 1;\n\n\tif(dp[l][r][k]!=-1)return dp[l][r][k];\n\tdp[l][r][k]=max(dfs(l+1,r,k),dfs(l,r-1,k));\n\tif(s[l]==s[r])dp[l][r][k]=max(dfs(l+1,r-1,k)+2,dp[l][r][k]);\n\telse if(k>=1) dp[l][r][k]=max(dfs(l+1,r-1,k-1)+2,dp[l][r][k]);\n\treturn dp[l][r][k];\n}\nint main()  {\n\tmemset(dp,-1,sizeof(dp));\n\tint k;\n\tscanf(\"%s\",&s);\n\tscanf(\"%d\",&k);\n\tprintf(\"%d\\n\",dfs(0,strlen(s)-1,k));\n     return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#define DEBUG 1\n\n//#define int long long\n#define for0(i,n) for (int i=0; i<n; i++)\n#define iter(c) for(auto it=c.begin(); it!=c.end(); it++)\n#define iter2(c) for(auto it2=c.begin(); it2!=c.end(); it2++)\n#define pb push_back\n#define ms(a,z) memset(a,z,sizeof(a));\n#define mp make_pair\n#define X first\n#define Y second\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define all(a) a.begin(),a.end()\n#define sz(x) (int)(x).size()\n#define pmod(x,m) (((x)%(m)+m)%m)\n#ifdef int\n#define read(x) scanf(\"%lld\",&x);\n#else\n#define read(x) scanf(\"%d\",&x);\n#endif\n\n#ifdef DEBUG\n#define nl cout<<\"\\n\";\n#define pr(x) cout<<(x)<<\" \";\n#define prl(x) cout<<#x \" = \"<<x<<endl;\n#define prp(x) cout<<\"(\"<<(x).first<<\" \"<<(x).second<<\") \";\n#define printv(v) {for(int _=0; _<sz(v); _++) cout<<v[_]<<\" \"; cout<<\"\\n\";}\n#define printa(a,s) {for (int _=0; _<s; _++) cout<<a[_]<<\" \"; cout<<\"\\n\";}\n#define print2D(a,m,n) {for (int _=0; _<m; _++) {for (int __=0; __<n; __++) cout<<a[_][__]<<\" \"; cout<<\"\\n\";} cout<<\"\\n\";}\n#define priter(v) iter(v) {pr(*it)} nl\n#define debug cout<<\"ok at line \"<<__LINE__<<endl;\n#else\n#define nl\n#define pr(x)\n#define prl(x)\n#define prp(x)\n#define printv(v)\n#define printa(a,s)\n#define print2D(a,m,n)\n#define priter(v)\n#define debug\n#endif\n#define MAXN 100000\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF = 2147483647;\nconst long long INFL = 9223372036854775807LL;\nconst double EPSILON = 0.00000001;\nconst long long MOD = 1000000007;\n\nint dp[305][305][305];\n\nint32_t main()\n{\n    #ifdef DEBUG\n    //freopen(\"C.txt\",\"r\",stdin);\n    //freopen(\"\",\"w\",stdout);\n    #endif\n\n    string s;\n    int K;\n    cin >> s;\n    cin >> K;\n    int n = s.length();\n    s = \"3\"+s;\n    \n    ms(dp,0);\n    for (int i=1; i<=n; i++) {\n        for (int k=0; k<=K; k++) {\n            dp[k][i][i] = 1;\n        }\n    }\n    \n    for (int k=0; k<=K; k++) {\n        for (int i=n; i>=1; i--) {\n            for (int j=i; j<=n; j++) {\n                //pr(i) pr(j) nl\n                int v = 0;\n                v = max(v, dp[k][i+1][j]);\n                v = max(v, dp[k][i][j-1]);\n                if (s[i] == s[j])\n                    v = max(v, dp[k][i+1][j-1]+2-(i==j));\n                else if (k > 0)\n                    v = max(v, dp[k-1][i+1][j-1]+2-(i==j));\n                dp[k][i][j] = v;\n            }\n        }\n    }\n    print2D(dp[0],n+1,n+1);\n    int ans = dp[K][1][n];\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define P push\n#define pb push_back\n#define MEM(dp,i) memset(dp,i,sizeof(dp))\n#define W while\n#define R return\n#define C continue\n#define SI size()\n#define ll long long\n#define ld long double\n#define pll pair<ll,ll>\n#define pii pair<int,int>\n#define SF(x) scanf(\"%Id\",&x)\n#define SF2(x,y) scanf(\"%Id%Id\",&x,&y)\n#define SF3(x,y,z) scanf(\"%I64d%I64d%I64d\",&x,&y,&z)\n#define SF4(x,y,z,o) scanf(\"%I64d%I64d%I64d%I64d\",&x,&y,&z,&o)\n#define all(v) v.begin(),v.end()\n\nusing namespace std;\nconst long long INF = 1e9+1;\nconst long long MOD = 1e9+7;\nconst int MX=100015;\nint dp[303][303][303];\nstring s;\nint n;\nint DP(int x,int y,int k){\n    if(k<0)R -INF;\n    if(x==n||y==0)R 0;\n    int &ret=dp[x][y][k];\n    if(ret!=-1)R ret;\n    ret=max(DP(x+1,y,k),DP(x,y-1,k));\n    if(s[x]==s[y])ret=max(ret,DP(x+1,y-1,k)+1);\n    ret=max(ret,DP(x+1,y-1,k-1)+2);\n    R ret;\n}\nint main(){\n    int k;\n    MEM(dp,-1);\n    cin>>s>>k;\n    n=s.size();\n    cout<<DP(0,n-1,k);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\n#include <map>\n#include <string.h>\n#include <math.h>\n#include <stdio.h>\n#include <deque>\n//#include \"D:\\C++\\test_lib_projects\\testlib.h\"\nusing namespace std;\n#define ll long long\n#define pii pair<int,int>\n\nbool debug=true;\n/*\n   Write In New Computer\n    By XiaoGeNintendo\n\t     gwq2017\n\tType:\n*/\n\n/*\nvoid fo(int id){\n\tfreopen((toString(id)+\".txt\").c_str(),\"w\",stdout);\n}\n*/\nstring s;\nint k;\n\n/*\nThe biggest answer in [l,r] with k left\n*/\n\nint d[305][305][305];\nbool f[305][305][305];\n\nint dp(int l,int r,int k){\n\t//cout<<l<<\" \"<<r<<\" \"<<k<<endl;\n\tint retv;\n\tif(k<0){\n\t\treturn 0;\n\t}else{\n\t\tif(f[l][r][k]) return d[l][r][k];\n\t\t\n\t\tif(l==r){\n\t\t\tretv=1;\n\t\t}else{\n\t\t\tif(l>r){\n\t\t\t\tretv=0;\n\t\t\t}else{\n\t\t\t\tretv=max(dp(l+1,r,k),dp(l,r-1,k));\n\t\t\t\tif(k>=1){\n\t\t\t\t\tretv=max(retv,dp(l+1,r-1,k-1)+2);\n\t\t\t\t}\n\t\t\t\tif(s[l]==s[r]){\n\t\t\t\t\tretv=max(retv,dp(l+1,r-1,k)+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tf[l][r][k]=true;\n\td[l][r][k]=retv;\n\treturn retv;\n}\n\nint main(int argc,char* argv[]){\n\tcin>>s>>k;\n\tcout<<dp(0,s.size()-1,k);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define Kafuu signed\n#define Chino main\n\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n\n#define maxn 305\n#define inf 0x3f3f3f3f\n#define px putchar\n#define pn px('\\n')\n#define ps px(' ')\n#define pd puts(\"======================\")\n#define pj puts(\"++++++++++++++++++++++\")\n\nusing namespace std;\n\ninline int read(){\n\tint x=0,y=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn y?-x:x;\n}\ntemplate<typename T>\ninline T read(){\n\tT x=0;\n\tint y=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn y?-x:x;\n}\nint f[2][maxn][maxn];\nchar s[maxn];\nKafuu Chino(){\n\tscanf(\"%s\",s+1);\n\tint n=strlen(s+1),k=read(),ans=0;\n\tfor(register int i=1;i<=n;++i)f[0][i][i]=1;\n\tfor(register int i=0;i<=k;++i){\n\t\tfor(register int len=2;len<=n;++len)\n\t\t\tfor(register int st=1,en=st+len-1;en<=n;++st,++en){\n\t\t\t\tf[i&1][st][en]=max(f[i&1][st+1][en],f[i&1][st][en-1]);\n\t\t\t\tif(s[st]==s[en])f[i&1][st][en]=max(f[i&1][st][en],f[i&1][st+1][en-1]+2);\n\t\t\t\tif(i)f[i&1][st][en]=max(f[i&1][st][en],f[i&1^1][st+1][en-1]+2);\n\t\t\t}\n\t\tans=max(ans,f[i&1][1][n]);\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nint dp[400][400][400];\nsigned main(){\n\tstring s;int K;cin>>s>>K;\n\trep(i,s.size()){\n\t\tfor(int j=s.size()-1;j>i;j--){\n\t\t\trep(k,K+1){\n\t\t\t\tif(s[i]==s[j]){\n\t\t\t\t\tdp[i+1][j-1][k]=max(dp[i+1][j-1][k],dp[i][j][k]+1);\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tdp[i+1][j-1][k]=max(dp[i+1][j-1][k],dp[i][j][k]);\n\t\t\t\t\tdp[i+1][j][k]=max(dp[i+1][j][k],dp[i][j][k]);\n\t\t\t\t\tdp[i][j-1][k]=max(dp[i][j-1][k],dp[i][j][k]);\n\t\t\t\t\tif(k<K){\n\t\t\t\t\t\tdp[i+1][j-1][k+1]=max(dp[i+1][j-1][k+1],dp[i][j][k]+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint Max=0;\n\trep(i,s.size())rep(j,K+1){\n\t\tMax=max(Max,dp[i][i][j]);\n\t}\n\tcout<<Max*2+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, int> P;\nconst int INF = (1<<30);\nconst ll INFLL = (1ll<<60);\nconst ll MOD = (ll)(1e9+7);\n\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\ta = (a<MOD)?a:(a-MOD);\n\tb = (b<MOD)?b:(b-MOD);\n\ta += b;\n\ta = (a<MOD)?a:(a-MOD);\n}\n\nstring s;\nbool done[334][334][334];\nint memo[334][334][334];\n\nint solve(int i, int j, int k){\n\tint l;\n\tif(done[i][j][k]){\n\t\treturn memo[i][j][k];\n\t}\n\tdone[i][j][k] = true;\n\tif(i==j){\n\t\treturn memo[i][j][k] = 1;\n\t}else if(i>j){\n\t\treturn memo[i][j][k] = 0;\n\t}\n\tmemo[i][j][k] = max(solve(i+1,j,k),solve(i,j-1,k));\n\tif(s[i]==s[j]){\n\t\tmemo[i][j][k] = max(memo[i][j][k],solve(i+1,j-1,k)+2);\n\t}else if(k){\n\t\tmemo[i][j][k] = max(memo[i][j][k],solve(i+1,j-1,k-1)+2);\n\t}\n\treturn memo[i][j][k];\n}\n\nint main(void){\n\tint k;\n\tcin >> s >> k;\n\tcout << solve(0,s.l_ength()-1,k) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar S[305];\nint K;\nint cache[305][305][305];\n\nint LPS(int i, int j, int k) {\n\tif (~cache[i][j][k]) return cache[i][j][k];\n\n\tif (i == j) return cache[i][j][k] = 1;\n\tif (j - i == 1 && S[i] != S[j]) return cache[i][j][k] = k ? 2 : 1;\n\tif (j - i == 1 && S[i] == S[j]) return cache[i][j][k] = 2;\n\tif (S[i] != S[j]) {\n\t\tcache[i][j][k] = max(LPS(i+1, j, k), LPS(i, j-1, k));\n\t\tif (k) cache[i][j][k] = max(cache[i][j][k], LPS(i+1, j-1, k-1) + 2);\n\t\treturn cache[i][j][k];\n\t}\n\tif (S[i] == S[j]) return cache[i][j][k] = LPS(i+1, j-1, k) + 2;\n}\n\nint main() {\n\tscanf(\"%s%d\", S, &K);\n\n\tint len = strlen(S);\n\n\tfor (int i = 0; i < 305; ++i) for (int j = 0; j < 305; ++j) for (int k = 0; k < 305; ++k) cache[i][j][k] = -1;\n\n\tprintf(\"%d\\n\", LPS(0, len-1, K));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nint dp[310][310][310];\n\nint main() {\n\tstring s, t;\n\tcin >> s;\n\tt = s;\n\treverse(ALL(t));\n\n\tint n = s.size();\n\tint K;\n\tcin >> K;\n\n\tif (n == 1) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tfor (int k = 0; k <= K; ++k) {\n\t\t\t\tif (s[i] == t[j]) {\n\t\t\t\t\tdp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + 1);\n\t\t\t\t} else {\n\t\t\t\t\tdp[i+1][j+1][k+1] = max(dp[i+1][j+1][k+1], dp[i][j][k] + 1);\n\t\t\t\t}\n\t\t\t\tdp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i+1][j][k]);\n\t\t\t\tdp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j+1][k]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = 0;\n\n\tfor (int m = 0; m < n; ++m) {\n\t\tfor (int k = 0; k <= K; ++k) {\n\t\t\tint t = dp[m][n-1-m][k] * 2 + 1;\n\t\t\tret = max(ret, t);\n\n\t\t\tt = dp[m+1][n-1-m][k] * 2;\n\t\t\tret = max(ret, t);\n\t\t}\n\t}\n\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include<iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nchar str[606];\nchar str2[606];\nint dp[606][606];\nint main(){\n    memset(dp,0,sizeof(dp));\n    int k;\n    scanf(\"%s\",str);\n    scanf(\"%d\",&k);\n    int n = strlen(str);\n    if (k==0) {\n     \tchar str1[606];\n     \tfor (int i=0;i<n;i++) {\n     \t\tstr1[i] = str[n-i-1];\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor (int i=0;i<n;i++) {\n\t\t\tfor (int j=0;j<n;j++) {\n\t\t\t\tif (str[i]==str1[j]) {\n\t\t\t\t\tif (i-1<0 || j-1<0) {\n\t\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse dp[i][j] = max(dp[i][j],dp[i-1][j-1]+1);\n\t\t\t\t}\n\t\t\t\telse dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dp[n-1][n-1]);\n\t\treturn 0;\n\t}\n    for(int i=0;i<n;i++){\n        str2[i*2+1] = str[i];\n        str2[i*2+2] = '*';\n    }\n    n = n*2+1;\n    int ans = 0;\n    for(int mid = 1; mid<=n/2+1;mid++){\n\n        for(int i=1;i<=n/2;i++){\n            for(int j=0;j<=min(i,k);j++){\n                if(str2[mid-dp[i-1][j]]==str2[mid+i]){\n                    dp[i][j] = dp[i-1][j]+1;\n                }\n                else{\n                    dp[i][j] = dp[i-1][j];\n                }\n                dp[i][j] = max(dp[i][j],dp[i-1][j-1]+1);\n            }\n        }\n        for(int i=1;i<=k;i++){\n            if(dp[n/2][i]==mid-1){\n                ans = max(ans,mid);\n            }\n        }\n\n    }\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sqr(x) ((x) * (x))\n#define pb push_back\n#define mp make_pair\n#define X first\n#define Y second\n#define fin(name) FILE* aasckmasl=freopen(name, \"r\", stdin)\n#define fout(name) freopen(name, \"w\", stdout)\n#define I(x, a) for(auto x : a)\n#define F(i, l, r) for(auto i = l; i < r; ++i)\n#define E(i, l, r) for(auto i = l; i <= r; ++i)\n#define DF(i, l, r) for(auto i = l; i >= r; --i)\n#define clean(a) memset((a),0,sizeof (a))\n#define sync ios_base::sync_with_stdio(0);cin.tie(0)\n#define all(x) (x).begin(),(x).end()\n#define ret return\n#define cont continue\n#define brk break\n#define ins insert\n#define sz(a) ((int)(a).size())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double dbl;\ntypedef pair <int, int> pii;\n\nconst int inf = (int)1e9;\nconst ll linf = (ll)1e18;\nconst int mod = (int)1e9 + 7;\nconst dbl eps = (dbl)1e-8;\nconst int maxn = (int)1e5 + 5;\nconst dbl pi = acos(-1);\n\nint n, k, ans;\nstring s;\nint d[303][303][303];\n\nint main() {\n//    fin(\"t.in\");\n    sync;\n    cin >> s;\n    n = sz(s);\n    cin >> k;\n    clean(d);\n    ans = 0;\n    E(i, 0, n) {\n    \tE(j, 0, n) {\n    \t\tif (i + j > n)\n    \t\t\tbreak;\n\t\t\tint x = i, y = n - 1 - j;\n    \t\tE(q, 0, k) {\n   \t\t\t\tans = max(ans, 2 * d[i][j][q] + (i + j < n));\n\t\t\t\tif (x >= y)\n\t\t\t\t\tcont;\n   \t\t\t\tif (s[x] == s[y]) {\n   \t\t\t\t\td[i + 1][j + 1][q] = max(d[i + 1][j + 1][q], d[i][j][q] + 1);\n   \t\t\t\t}\n\t\t\t\td[i + 1][j + 1][q + 1] = max(d[i + 1][j + 1][q + 1], d[i][j][q] + 1);\n   \t\t\t\td[i + 1][j][q] = max(d[i + 1][j][q], d[i][j][q]);\n   \t\t\t\td[i][j + 1][q] = max(d[i][j + 1][q], d[i][j][q]);\n    \t\t}\n    \t}\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <memory.h>\n\nchar S[310];\nint K;\nint len;\nint res;\nint memo[310][310][310];\n\nint srch(int ll, int rr, int kk)\n{\n\tif(memo[ll][rr][kk] != -1)\n\t\treturn memo[ll][rr][kk];\n\tif(ll==rr)\n\t\treturn 1;\n\tif(ll+1==rr){\n\t\tif(S[ll]==S[rr] || kk>0)\n\t\t\treturn 2;\n\t\telse\n\t\t\treturn 1;\n\t}\n\tint tmp;\n\tint mx=0;\n\ttmp = srch(ll+1, rr, kk);\n\tif(tmp > mx)\n\t\tmx = tmp;\n\ttmp = srch(ll, rr-1, kk);\n\tif(tmp > mx)\n\t\tmx = tmp;\n\tif(S[ll]==S[rr]){\n\t\ttmp = srch(ll+1, rr-1, kk) + 2;\n\t\tif(tmp > mx)\n\t\t\tmx = tmp;\n\t}\n\telse if(kk>0){\n\t\ttmp = srch(ll+1, rr-1, kk-1) + 2; \n\t\tif(tmp > mx)\n\t\t\tmx = tmp;\n\t}\n\tmemo[ll][rr][kk] = mx;\n\treturn mx;\n}\n\nvoid solve()\n{\n\tlen = strlen(S);\n\tmemset(memo, -1, sizeof(memo) );\n\tres = srch(0, len-1, K);\n\tprintf(\"%d\\n\", res);\n}\n\nint main()\n{\n\tscanf(\"%s\", S);\n\tscanf(\"%d\", &K);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nconst int N = 100000 + 100;\nconst int MOD = 1000000007;\nconst int oo = 1e9;\n\nstring s;\nint k,dp[301][301][301];\n\nint calc(int l , int r , int rem){\n\tif(rem<0)return -oo;\n\tif(l==r)return 1;\n\tif(l>r)return 0;\n\tint &ret = dp[l][r][rem];\n\tif(ret != -1)return ret;\n\tret = max(calc(l+1,r,rem),calc(l,r-1,rem));\n\tif(s[l]==s[r])\n\t\tret = max(ret,2+calc(l+1,r-1,rem));\n\tif(s[l]!=s[r])\n\t\tret = max(ret,2+calc(l+1,r-1,rem-1));\n\treturn ret;\n}\nint main() {\n\tmemset(dp,-1,sizeof dp);\n\tcin >> s>>k;\n\tcout << calc(0,s.size()-1,k) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//wls niubi!\n#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\nconst LL mod = 1e9 + 7;\ninline int read()\n{\n\tint x = 0,f = 1;char ch = getchar();\n\tfor(;!isdigit(ch);ch = getchar())if(ch == '-')f = -f;\n\tfor(;isdigit(ch);ch = getchar())x = 10 * x + ch - '0';\n\treturn x * f;\n}\nint n,K;\nchar ch[310];\nint f[310][310][310];\nint main()\n{\n\tscanf(\"%s\",ch + 1);n = strlen(ch + 1);K = read();\n\tfor(int i=1;i<=n;i++)for(int j=0;j<=K;j++)f[i][i][j] = 1;\n\tfor(int l=2;l<=n;l++)\n\t{\n\t\tfor(int i=1;i+l-1<=n;i++)\n\t\t{\n\t\t\tint j = i + l - 1;\n\t\t\tfor(int k=0;k<=K;k++)\n\t\t\t{\n\t\t\t    f[i][j][k] = max(f[i - 1][j][k],f[i][j - 1][k]);\n\t\t\t    if(ch[i] == ch[j])f[i][j][k] = max(f[i][j][k],f[i + 1][j - 1][k] + 2);\n\t\t\t    if(k)f[i][j][k] = max(f[i][j][k],f[i + 1][j - 1][k - 1] + 2);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tcout<<f[1][n][K];\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define f1 first\n#define f2 second\n#define int long long\n#define int1 int\n#define pb push_back\nusing namespace std;\nint dp[309][309][309];\nmain()\n{\n  string s;\n  cin>>s;\n  int k;\n  cin>>k;\n  int n=s.size();\n  for(int i=0 ; i<n ; i++)\n  {\n      for(int j=0 ; j<=k ; j++)\n      {\n          dp[i][i][j]=1;\n      }\n  }\n  for(int j=1 ; j<n ; j++)\n  {\n      for(int i=j-1 ; i>=0 ; i--)\n      {\n          for(int w=0 ; w<=k ; w++)\n          {\n              if(s[i]==s[j])\n              {\n                  dp[i][j][w]=dp[i+1][j-1][w]+2;\n              }\n              else if(w==0)\n              {\n                  dp[i][j][w]=max(dp[i+1][j][w],dp[i][j-1][w]);\n              }\n              else\n              {\n                dp[i][j][w]=max(max(dp[i+1][j][w],dp[i][j-1][w]),dp[i+1][j-1][w-1]+2);\n              }\n          }\n      }\n  }\n\ncout<<dp[0][n-1][k];\n}\n"
  },
  {
    "language": "C++",
    "code": "//#undef _DEBUG\n//#pragma GCC optimize(\"Ofast\")\n//不動小数点の計算高速化\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace std::chrono;\n#define int long long //todo 消したら動かない intの代わりにsignedを使う\n#define ll long long\nauto start_time = system_clock::now();\nauto past_time = system_clock::now();\n\n#define debugName(VariableName) # VariableName\n//最大引数がN\n#define over2(o1, o2, name, ...) name\n#define over3(o1, o2, o3, name, ...) name\n#define over4(o1, o2, o3, o4, name, ...) name\n#define over5(o1, o2, o3, o4, o5, name, ...) name\n#define over6(o1, o2, o3, o4, o5, o6, name, ...) name\n#define over7(o1, o2, o3, o4, o5, o6, o7, name, ...) name\n#define over8(o1, o2, o3, o4, o5, o6, o7, o8, name, ...) name\n#define over9(o1, o2, o3, o4, o5, o6, o7, o8, o9, name, ...) name\n#define over10(o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, name, ...) name\n\n\n/*@formatter:off*/\n//[-n, n)にアクセスできる\n//また、外部関数resizeに渡せる\n//sizeは[-n, n)でnを返す\ntemplate<class T> class mvec {    vector<T> v;    int n;public:    mvec() : n(0), v(0) {}    mvec(int n) : n(n), v(n * 2) {}    mvec(int n, T val) : n(n), v(n * 2, val) {}    auto &operator[](int i) { return v[i + n]; }    auto size() { return n; }    void resize(int sn) {        assert(n == 0);        n = sn;        v.resize(sn * 2);    }    auto begin() { return v.begin(); }    auto rbegin() { return v.rbegin(); }    auto end() { return v.end(); }    auto rend() { return v.rend(); }};\n//[]でboolは参照を返さないため特殊化が必要\ntemplate<> struct mvec<bool> {    vector<bool> v;    int n;    mvec() : n(0), v(0) {}    mvec(int n) : n(n), v(n * 2) {}    mvec(int n, bool val) : n(n), v(n * 2, val) {}    auto operator[](int i) { return v[i + n]; }    auto size() { return v.size(); }    void resize(int sn) {        assert(n == 0);        n = sn;        v.resize(sn * 2);    }    auto begin() { return v.begin(); }    auto rbegin() { return v.rbegin(); }    auto end() { return v.end(); }    auto rend() { return v.rend(); }};\ntemplate<class T>ostream &operator<<(ostream &os, mvec<T>& a) {    int spa = 3;    for(auto&&v : a){        spa = max(spa,(int)(to_string(v).size())+1);    }    int n = (int)a.size();    os<<endl;    for (int i = -n; i < n; i++){        int need = spa - ((int)to_string(i).size());        if(i==-n){            need -= min(need,spa - ((int)to_string(a[i]).size()));        }        while(need--){            os<<\" \";        }        os<<i;    }    os<<endl;    int i=-n;    for(auto&&v : a){        int need = spa - ((int)to_string(v).size());        if(i==-n){            need -= min(need,spa - ((int)to_string(i).size()));        }        while(need--){            os<<\" \";        }        os<<v;        i++;    }    return os;}\n#define mv mvec\n#define MV mvec\nusing mvi = mvec<ll>;\nusing mvb = mvec<bool>;\nusing mvs = mvec<string>;\nusing mvd = mvec<double>;\nusing mvc = mvec<char>;\n\n#define mvvt0(t) mvec<mvec<t>>\n#define mvvt1(t,a) mvec<mvec<t>>a\n#define mvvt2(t,a, b) mvec<mvec<t>>a(b)\n#define mvvt3(t,a, b, c) mvec<mvec<t>> a(b,mvec<t>(c))\n#define mvvt4(t,a, b, c, d) mvec<mvec<t>> a(b,mvec<t>(c,d))\n#define mvvi(...) over4(__VA_ARGS__,mvvt4,mvvt3,mvvt2 ,mvvt1,mvvt0)(ll,__VA_ARGS__)\n\ntemplate<typename T> mvec<T> make_mv(size_t a) { return mvec<T>(a); }\ntemplate<typename T, typename... Ts> auto make_mv(size_t a, Ts... ts) {return mvec<decltype(make_mv<T>(ts...))>(a, make_mv<T>(ts...));}\n#define mvni(name, ...) auto name = make_mv<ll>(__VA_ARGS__)\n\n\n#ifdef _DEBUG\nstring message;\nstring res_mes;\n//https://marycore.jp/prog/cpp/class-extension-methods/ 違うかも\ntemplate<class T, class A = std::allocator<T>> struct debtor : std::vector<T, A> {\n    using std::vector<T, A>::vector;\n    /*@formatter:on*/\n    template<class U> int deb_v(U a, int v) { return v; }\n    template<class U> int deb_v(debtor<U> &a, int v = 0) {\n        cerr << a.size() << \" \";\n        return deb_v(a.at(0), v + 1);\n    }\n    template<class U> void deb_o(U a) { cerr << a << \" \"; }\n    template<class U> void deb_o(debtor<U> &a) {\n        for (int i = 0; i < min((int) a.size(), 15ll); i++) { deb_o(a[i]); }\n        if ((int) a.size() > 15) { cerr << \"...\"; }\n        cerr << endl;\n    }\n    typename std::vector<T>::reference my_at(typename std::vector<T>::size_type n, vector<int> &ind) {\n        if (n < 0 || n >= (int) this->size()) {\n            int siz = (int) this->size();\n            cerr << \"vector size = \";\n            int dim = deb_v((*this));\n            cerr << endl;\n            ind.push_back(n);\n            cerr << \"out index at  \";\n            for (auto &&i: ind) {\n                cerr << i << \" \";\n            }\n            cerr << endl;\n            cerr << endl;\n            if (dim <= 2) { deb_o((*this)); }\n            exit(0);\n        }\n        return this->at(n);\n    }\n    typename std::vector<T>::reference operator[](typename std::vector<T>::size_type n) {\n        if (n < 0 || n >= (int) this->size()) {\n            int siz = (int) this->size();\n            cerr << \"vector size = \";\n            int dim = deb_v((*this));\n            cerr << endl;\n            cerr << \"out index at  \" << n << endl;\n            cerr << endl;\n            if (dim <= 2) { deb_o((*this)); }\n            exit(0);\n        }\n        return this->at(n);\n    }\n};\n/*@formatter:off*/\n#define vector debtor\n//区間削除は出来ない\ntemplate<class T> struct my_pbds_tree {    set<T> s;    auto begin() { return s.begin(); }    auto end() { return s.end(); }    auto rbegin() { return s.rbegin(); }    auto rend() { return s.rend(); }    auto empty() { return s.empty(); }    auto size() { return s.size(); }    void clear() { s.clear(); }    template<class U> void insert(U v) { s.insert(v); }template<class U> void operator+=(U v) { insert(v); }    template<class F> auto erase(F v) { return s.erase(v); }    template<class U> auto find(U v) { return s.find(v); }    template<class U> auto lower_bound(U v) { return s.lower_bound(v); }    template<class U> auto upper_bound(U v) { return s.upper_bound(v); }    auto find_by_order(ll k) {        auto it = s.begin();        for (ll i = 0; i < k; i++)it++;        return it;    }    auto order_of_key(ll v) {        auto it = s.begin();        ll i=0;        for (;it != s.end() && *it <v ; i++)it++;        return i;    }};\n#define pbds(T) my_pbds_tree<T>\n//gp_hash_tableでcountを使えないようにするため\ntemplate<class T,class U> struct my_unordered_map{    unordered_map<T,U> m;    my_unordered_map(){};    auto begin(){        return m.begin();    }    auto end(){return m.end();}    auto cbegin(){return m.cbegin();}    auto cend(){return m.cend();}    template<class V>auto erase(V v){return m.erase(v);}    void clear(){m.clear();}    /*countは gp_hash_tableに存在しない*/    /*!= m.end()*/    template<class V>auto find(V v){return m.find(v);}    template<class V>auto & operator [](V n) { return m[n] ;}};\n#define unordered_map my_unordered_map\n#define umapi unordered_map<ll,ll>\n#define umapp unordered_map<P,ll>\n#define umapu unordered_map<uint64_t,ll>\n#define umapip unordered_map<ll,P>\ntemplate<class T,class U, class X> auto count (unordered_map<T,U>& a, X k){return a.find(k) != a.end();}\n#else\n#define endl '\\n'\n//umapはunorderd_mapになる\n//umapiはgp_hash_table\n\n//find_by_order(k) k番目のイテレーター\n//order_of_key(k)  k以上が前から何番目か\n#define pbds(U) __gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>\n\n#define umapi __gnu_pbds::gp_hash_table<ll,ll,xorshift>\n#define umapp __gnu_pbds::gp_hash_table<P,ll,xorshift>\n#define umapu __gnu_pbds::gp_hash_table<uint64_t,ll,xorshift>\n#define umapip __gnu_pbds::gp_hash_table<ll,P,xorshift>\ntemplate<class T,class U,class W, class X>auto count (__gnu_pbds::gp_hash_table<T,U,W>& a, X k){return a.find(k) != a.end();}\n#endif\n\n\n/*@formatter:on*/\nstruct xorshift {\n    static uint64_t splitmix64(uint64_t x) {\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n    size_t operator()(std::pair<ll, ll> x) const {\n        ll v = ((x.first) << 32) | x.second;\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(v + FIXED_RANDOM);\n    }\n};\n/*@formatter:off*/\ntemplate<class U, class L> void operator+=(__gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update> &s, L v) { s.insert(v); }\n//衝突対策\n#define ws ws_\n\ntemplate<class A, class B, class C>struct T2 {A f;B s;C t;T2() { f = 0, s = 0, t = 0; }T2(A f, B s, C t) : f(f), s(s), t(t) {}bool operator<(const T2 &r) const {        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;        /*return f != r.f ? f > r.f : s != r.s ?n s > r.s : t > r.t; 大きい順 */   }    bool operator>(const T2 &r) const {        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;        /*return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順 */   }    bool operator==(const T2 &r) const {        return f == r.f && s == r.s && t == r.t;    }    bool operator!=(const T2 &r) const {        return f != r.f || s != r.s || t != r.t;    }};\ntemplate<class A, class B, class C, class D> struct F2 {    A a;    B b;    C c;    D d;    F2() { a = 0, b = 0, c = 0, d = 0; }    F2(A a, B b, C c, D d) : a(a), b(b), c(c), d(d) {}    bool operator<(const F2 &r) const {        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;    /*    return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;*/    }    bool operator>(const F2 &r) const {        return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;/*        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;*/    }    bool operator==(const F2 &r) const {        return a == r.a && b == r.b && c == r.c && d == r.d;    }    bool operator!=(const F2 &r) const {        return a != r.a || b != r.b || c != r.c || d != r.d;    }    ll operator[](ll i) {        assert(i < 4);        return i == 0 ? a : i == 1 ? b : i == 2 ? c : d;    }};\ntypedef T2<ll, ll, ll> T;\ntypedef F2<ll, ll, ll, ll> F;\nT mt(ll a, ll b, ll c) {return T(a, b, c);}\nF mf(ll a, ll b, ll c, ll d) {return F(a, b, c, d);}\n\n\n\n//@マクロ省略系 型,構造\n//using で元のdoubleを同時に使えるはず\n#define double_big\n\n#ifdef double_big\n    #define double long double\n    #define pow powl\n#endif\nusing dou = double;\nconst double eps = 1e-9;\n//基本コメントアウト\n//struct epsdou {    double v;    epsdou(double v = 0) : v(v) {}    template<class T> epsdou &operator+=(T b) {        v += (double) b;        return (*this);    }    template<class T> epsdou &operator-=(T b) {        v -= (double) b;        return (*this);    }    template<class T> epsdou &operator*=(T b) {        v *= (double) b;        return (*this);    }    template<class T> epsdou &operator/=(T b) {        v /= (double) b;        return (*this);    }    epsdou operator+(epsdou b) { return v + (double) b; }    epsdou operator-(epsdou b) { return v - (double) b; }    epsdou operator*(epsdou b) { return v * (double) b; }    epsdou operator/(epsdou b) { return v / (double) b; }    epsdou operator-() const { return epsdou(-v); }    template<class T> bool operator<(T b) { return v < (double) b; }    template<class T> bool operator>(T b) { return v > (double) b; }    template<class T> bool operator==(T b) { return fabs(v - (double) b) <= eps; }    template<class T> bool operator<=(T b) { return v < (double) b || fabs(v - b) <= eps; }    template<class T> bool operator>=(T b) { return v > (double) b || fabs(v - b) <= eps; }    operator double() { return v; }};istream &operator>>(istream &iss, epsdou &a) {    iss >> a.v;    return iss;}ostream &operator<<(ostream &os, epsdou &a) {    os << a.v;    return os;}\n//#define eps_conr_t(o) template<class T> epsdou operator o(T a, epsdou b) {return (dou) a o b.v;}\n//#define eps_conl_t(o) template<class T> epsdou operator o(epsdou a, T b) {return a.v o (dou) b;}\n//eps_conl_t(+)eps_conl_t(-)eps_conl_t(*)eps_conl_t(/)eps_conr_t(+)eps_conr_t(-)eps_conr_t(*)eps_conr_t(/)\n//#undef double\n//#define double epsdou\n\n/*@formatter:off*/\n#define ull unsigned long long\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\nusing mvp = mvec<P>;\nusing mvt = mvec<T>;\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\n\n#define fi first\n#define se second\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n#define el else\n#define elf else if\n#define upd update\n#define sstream stringstream\n\n#define maxq 1\n#define minq -1\n\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MALLOC(type, len) (type*)malloc((len) * sizeof(type))\n#define lam1(ret) [&](auto& v){return ret;}\n#define lam2(v, ret) [&](auto& v){return ret;}\n#define lam(...) over2(__VA_ARGS__,lam2,lam1)(__VA_ARGS__)\n#define lamr(right) [&](auto& p){return p right;}\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\n//マクロ省略系 コンテナ\nusing vi = vector<ll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vp = vector<P>;\nusing vt = vector<T>;\n\n//#define V vector\n#define vvt0(t) vector<vector<t>>\n#define vvt1(t,a) vector<vector<t>>a\n#define vvt2(t,a, b) vector<vector<t>>a(b)\n#define vvt3(t,a, b, c) vector<vector<t>> a(b,vector<t>(c))\n#define vvt4(t,a, b, c, d) vector<vector<t>> a(b,vector<t>(c,d))\n\n#define vvi(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(ll,__VA_ARGS__)\n#define vvb(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(bool,__VA_ARGS__)\n#define vvs(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(string,__VA_ARGS__)\n#define vvd(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(double,__VA_ARGS__)\n#define vvc(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(char,__VA_ARGS__)\n#define vvp(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(P,__VA_ARGS__)\n#define vvt(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(T,__VA_ARGS__)\n#define vv(type,...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(type,__VA_ARGS__)\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts> auto make_v(size_t a, Ts... ts) {return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));}\n#define vni(name, ...) auto name = make_v<ll>(__VA_ARGS__)\n#define vnb(name, ...) auto name = make_v<bool>(__VA_ARGS__)\n#define vns(name, ...) auto name = make_v<string>(__VA_ARGS__)\n#define vnd(name, ...) auto name = make_v<double>(__VA_ARGS__)\n#define vnc(name, ...) auto name = make_v<char>(__VA_ARGS__)\n#define vnp(name, ...) auto name = make_v<P>(__VA_ARGS__)\n#define vn(type,name, ...) auto name = make_v<type>(__VA_ARGS__)\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<ll, ll>;\nusing mapp = map<P, ll>;\nusing mapd = map<dou, ll>;\nusing mapc = map<char, ll>;\nusing maps = map<str, ll>;\nusing seti = set<ll>;\nusing setp = set<P>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<ll>;\n#define uset unordered_set\n#define useti unordered_set<ll,xorshift>\n#define mset multiset\n#define mseti multiset<ll>\n#define umap unordered_map\n#define mmap multimap\n//任意のマクロサポート用 使う度に初期化する\nint index_,v1_,v2_,v3_;\n\ntemplate<class T> struct pq {\n    priority_queue<T, vector<T>, greater<T> > q;/*小さい順*/    T su = 0;\n    void clear() {        q = priority_queue<T, vector<T>, greater<T> >();        su = 0;    }\n    void operator+=(T v) {        su += v;        q.push(v);    }\n    T sum() { return su; }\n    T top() { return q.top(); }\n    void pop() {        su -= q.top();        q.pop();    }\n    T poll() {        T ret = q.top();        su -= ret;        q.pop();        return ret;    }\n    ll size() { return q.size(); }\n};\ntemplate<class T> struct pqg {\n    priority_queue<T> q;/*大きい順*/    T su = 0;\n    void clear() {        q = priority_queue<T>();        su = 0;    }\n    void operator+=(T v) {        su += v;        q.push(v);    }\n    T sum() { return su; }\n    T top() { return q.top(); }\n    void pop() {        su -= q.top();        q.pop();    }\n    T poll() {        T ret = q.top();        su -= ret;        q.pop();        return ret;    }\n    ll size() { return q.size(); }\n};\n#define pqi pq<ll>\n#define pqgi pqg<ll>\n//マクロ 繰り返し\n//↓@オーバーロード隔離\n\n#define rep1(n) for(ll rep1i = 0,rep1lim=n; rep1i < rep1lim ; ++rep1i)\n#define rep2(i, n) for(ll i = 0,rep2lim=n; i < rep2lim ; ++i)\n#define rep3(i, m, n) for(ll i = m,rep3lim=n; i < rep3lim ; ++i)\n#define rep4(i, m, n, ad) for(ll i = m,rep4lim=n; i < rep4lim ; i+= ad)\n//逆順 閉区間\n#define rer2(i, n) for(ll i = n; i >= 0 ; i--)\n#define rer3(i, m, n) for(ll i = m,rer3lim=n; i >= rer3lim ; i--)\n#define rer4(i, m, n, dec) for(ll i = m,rer4lim=n; i >= rer4lim ; i-=dec)\n//ループを一つにまとめないとフォーマットで汚くなるため\n#define nex_ind1(i) i++\n#define nex_ind2(i, j, J) i = (j + 1 == J) ? i + 1 : i, j = (j + 1 == J ? 0 : j + 1)\n#define nex_ind3(i, j, k, J, K)i = (j + 1 == J && k + 1 == K) ? i + 1 : i, j = (k + 1 == K) ? (j + 1 == J ? 0 : j + 1) : j, k = (k + 1 == K ? 0 : k + 1)\n#define nex_ind4(i, j, k, l, J, K, L) i = (j + 1 == J && k + 1 == K && l + 1 == L) ? i + 1 : i, j = (k + 1 == K && l + 1 == L) ? (j + 1 == J ? 0 : j + 1) : j, k = (l + 1 == L ?(k + 1 == K ? 0 : k + 1) : k), l = l + 1 == L ? 0 : l + 1\n#define nex_ind5(i, j, k, l, m, J, K, L, M) i = (j + 1 == J && k + 1 == K && l + 1 == L && m + 1 == M) ? i + 1 : i, j = (k + 1 == K && l + 1 == L && m + 1 == M) ? (j + 1 == J ? 0 : j + 1) : j, k = (l + 1 == L && m + 1 == M ?(k + 1 == K ? 0 : k + 1) : k), l =  m + 1 == M ? l+1 == L ? 0 : l+1 : l,  m = m + 1 == M ? 0 : m + 1\n\n#define repss2(i, I) for (int i = 0; i < I; i++)\n#define repss4(i, j, I, J) for (int i = (J ? 0 : I), j = 0; i < I; nex_ind2(i, j, J))\n#define repss6(i, j, k, I, J, K) for (int i = (J && K ? 0 : I), j = 0, k = 0; i < I; nex_ind3(i, j, k, J, K))\n#define repss8(i, j, k, l, I, J, K, L) for (int i = (J && K && L ? 0 : I), j = 0, k = 0, l = 0; i < I; nex_ind4(i, j, k, l, J, K, L))\n#define repss10(i, j, k, l, m, I, J, K, L, M)for (int i = (J && K && L && M ? 0 : I), j = 0, k = 0, l = 0, m = 0; i < I; nex_ind5(i, j, k, l, m, J, K, L, M))\n\n//i,j,k...をnまで見る\n#define reps2(i, n) repss2(i, n)\n#define reps3(i, j, n) repss4(i, j, n, n)\n#define reps4(i, j, k, n) repss6(i, j, k, n, n, n)\n#define reps5(i, j, k, l, n) repss8(i, j, k, l, n, n, n, n)\n\ntemplate<class T>void nex_repv2(int&i,int&j,int&I, int&J,vector<vector<T>>&s){    while(1){        j++;        if(j >= J){            j=0;            i++;            if(i < I){                J = (int)s[i].size();            }        }        if(i >= I || J) return;    }}\ntemplate<class T> void nex_repv3(int &i, int &j, int &k, int &I, int &J, int &K, vector<vector<vector<T>>> &s) {    while (1) {        k++;        if (k >= K) {            k = 0;            j++;            if (j >= J) {                j = 0;                i++;                if (i >= I)return;            }        }        J = (int) s[i].size();        K = (int) s[i][j].size();        if (J && K) return;    }}\n\n#define repv_2(i,a) repss2(i, sz(a))\n//正方形である必要はない\n//直前を持つのとどっちが早いか\n#define repv_3(i, j, a) for (int I = (int)a.size(), J = (int)a[0].size(), i = 0, j = 0; i < I; nex_repv2(i,j,I,J,a))\n//箱状になっている事が要求される つまり[i] 次元目の要素数は一定\n#define repv_4(i, j, k, a) for (int I = (int)a.size(), J = (int)a[0].size(), K =(int)a[0][0].size(), i = 0, j = 0, k=0; i < I; nex_repv3(i,j,k,I,J,K,a))\n#define repv_5(i, j, k, l, a) repss8(i, j, k, l, sz(a), sz(a[0]), sz(a[0][0]), sz(a[0][0][0]))\n#define repv_6(i, j, k, l, m, a) repss10(i, j, k, l, m, sz(a), sz(a[0]), sz(a[0][0]), sz(a[0][0][0]), sz(a[0][0][0][0]))\n\ntemplate<typename T>struct has_rbegin_rend {private:template<typename U>static auto check(U &&obj) -> decltype(std::rbegin(obj), std::rend(obj), std::true_type{});static std::false_type check(...);public:static constexpr bool value = decltype(check(std::declval<T>()))::value;};template<typename T>constexpr bool has_rbegin_rend_v = has_rbegin_rend<T>::value;template<typename Iterator>class Range {public:Range(Iterator &&begin, Iterator &&end) noexcept: m_begin(std::forward<Iterator>(begin)), m_end(std::forward<Iterator>(end)) {}Iterator begin() const noexcept {return m_begin;}Iterator end() const noexcept {return m_end;}private:const Iterator m_begin;const Iterator m_end;};template<typename Iterator>static inline Range<Iterator>makeRange(Iterator &&begin, Iterator &&end) noexcept {return Range<Iterator>{std::forward<Iterator>(begin), std::forward<Iterator>(end)};}template<typename T>static inline decltype(auto) makeReversedRange(const std::initializer_list<T> &iniList) noexcept {return makeRange(std::rbegin(iniList), std::rend(iniList));}template<typename T,typename std::enable_if_t<has_rbegin_rend_v<T>, std::nullptr_t> = nullptr>static inline decltype(auto)makeReversedRange(T &&c) noexcept {return makeRange(std::rbegin(c), std::rend(c));}/* rbegin(), rend()を持たないものはこっちに分岐させて，エラーメッセージを少なくする*/template<typename T,typename std::enable_if<!has_rbegin_rend<T>::value, std::nullptr_t>::type = nullptr>static inline void makeReversedRange(T &&) noexcept {static_assert(has_rbegin_rend<T>::value, \"Specified argument doesn't have reverse iterator.\");}\n\n#define form1(st) for (auto &&form_it = st.begin(); form_it != st.end(); ++form_it)\n#define form3(k, v, st) for (auto &&form_it = st.begin(); form_it != st.end(); ++form_it)\n#define form4(k, v, st, r) for (auto &&form_it = st.begin(); form_it != st.end() && (*form_it).fi < r; ++form_it)\n#define form5(k, v, st, l, r) for (auto &&form_it = st.lower_bound(l); form_it != st.end() && (*form_it).fi < r; ++form_it)\n\n#define forrm1(st) for (auto &&forrm_it = st.rbegin(); forrm_it != st.rend(); ++forrm_it)\n#define forrm3(k, v, st) for (auto &&forrm_it = st.rbegin(); forrm_it != st.rend(); ++forrm_it)\n\n#define fors1(st) for (auto &&fors_it = st.begin(); fors_it != st.end(); ++fors_it)\n#define fors2(v, st) for (auto &&fors_it = st.begin(); fors_it != st.end(); ++fors_it)\n#define fors3(v, st, r) for (auto &&fors_it = st.begin(); fors_it != st.end() && (*fors_it) < r; ++fors_it)\n#define fors4(v, st, l, r) for (auto &&fors_it = st.lower_bound(l); fors_it != st.end() && (*fors_it) < r; ++fors_it)\n\n#define forslr3(st, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end(); ++forslr_it)\n#define forslr4(v, st, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end(); ++forslr_it)\n#define forslr5(v, st, r, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end() && (*forslr_it) < r; ++forslr_it)\n#define forslr6(v, st, l, r, a, b) for (auto &&forslr_it = st.lower_bound(l); forslr_it != st.end() && (*forslr_it) < r; ++forslr_it)\n\ntemplate<class U> vector<U>to1d(vector<U>& a){return a;}\ntemplate<class U> vector<U>to1d(vector<vector<U>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)res.push_back(a2);return res;}\ntemplate<class U> vector<U>to1d(vector<vector<vector<U>>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)for(auto&& a3 : a2) res.push_back(a3);return res;}\ntemplate<class U> vector<U>to1d(vector<vector<vector<vector<U>>>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)for(auto&& a3 : a2) for(auto&& a4 : a3)res.push_back(a4);return res;}\ntemplate<class U> vector<U>to1d(vector<vector<vector<vector<vector<U>>>>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)for(auto&& a3 : a2) for(auto&& a4 : a3)for(auto&& a5 : a4)res.push_back(a5);return res;}\ntemplate<class U> vector<U>to1d(vector<vector<vector<vector<vector<vector<U>>>>>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)for(auto&& a3 : a2) for(auto&& a4 : a3)for(auto&& a5 : a4)for(auto&& a6 : a5)res.push_back(a6);return res;}\n\n#define fora_init_2(a, A) ;\n#define fora_init_3(fora_i, a, A) auto &&a = A[fora_i];\n#define fora_init_4(a, b, A, B) auto &&a = A[fora_i]; auto &&b = B[fora_i];\n#define fora_init_5(fora_i, a, b, A, B) auto &&a = A[fora_i]; auto &&b = B[fora_i];\n#define fora_init_6(a, b, c, A, B, C) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i];\n#define fora_init_7(fora_i, a, b, c, A, B, C) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i];\n#define fora_init_8(a, b, c, d, A, B, C, D) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i]; auto && d = D[fora_i];\n#define fora_init_9(fora_i, a, b, c, d, A, B, C, D) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i]; auto && d = D[fora_i];\n#define fora_init(...) over9(__VA_ARGS__,fora_init_9, fora_init_8, fora_init_7, fora_init_6, fora_init_5, fora_init_4, fora_init_3, fora_init_2)(__VA_ARGS__)\n\n#define forr_init_2(a, A) auto &&a = A[forr_i];\n#define forr_init_3(forr_i, a, A) auto &&a = A[forr_i];\n#define forr_init_4(a, b, A, B) auto &&a = A[forr_i]; auto &&b = B[forr_i];\n#define forr_init_5(forr_i, a, b, A, B) auto &&a = A[forr_i]; auto &&b = B[forr_i];\n#define forr_init_6(a, b, c, A, B, C) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i];\n#define forr_init_7(forr_i, a, b, c, A, B, C) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i];\n#define forr_init_8(a, b, c, d, A, B, C, D) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i]; auto && d = D[forr_i];\n#define forr_init_9(forr_i, a, b, c, d, A, B, C, D) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i]; auto && d = D[forr_i];\n#define forr_init(...) over9(__VA_ARGS__, forr_init_9, forr_init_8, forr_init_7, forr_init_6, forr_init_5, forr_init_4, forr_init_3, forr_init_2)(__VA_ARGS__)\n\n\n#define forp_init(k, v, ...) auto &&k = (*forp_it).fi;auto &&v = (*forp_it).se;\n#define form_init(k, v, ...) auto &&k = (*form_it).fi;auto &&v = (*form_it).se;\n#define forrm_init(k, v, ...) auto &&k = (*forrm_it).fi;auto &&v = (*forrm_it).se;\n#define fors_init(v, ...) auto &&v = (*fors_it);\n\n#define forlr_init(a,A,ngl,ngr) auto a = A[forlr_i]; auto prev = forlr_i ? A[forlr_i-1] : ngl;auto next = forlr_i+1< rep2lim? A[forlr_i+1] : ngr;\n#define forslr_init4(a, A, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init5(a, A, r, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init6(a, A, l, r, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init(...)  over6(__VA_ARGS__,forslr_init6,forslr_init5,forslr_init4)(__VA_ARGS__);\n\n#define fora_2(a, A) for(auto&& a : A)\n#define fora_3(fora_i, a, A) rep(fora_i, sz(A))\n#define fora_4(a, b, A, B) rep(fora_i, sz(A))\n#define fora_5(fora_i, a, b, A, B) rep(fora_i, sz(A))\n#define fora_6(a, b, c, A, B, C) rep(fora_i, sz(A))\n#define fora_7(fora_i, a, b, c, A, B, C) rep(fora_i, sz(A))\n#define fora_8(a, b, c, d, A, B, C, D) rep(fora_i, sz(A))\n#define fora_9(fora_i, a, b, c, d, A, B, C, D) rep(fora_i, sz(A))\n\n#define forr_2(a, A) rer(forr_i, sz(A)-1)\n#define forr_3(forr_i, a, A) rer(forr_i, sz(A)-1)\n#define forr_4(a, b, A, B) rer(forr_i, sz(A)-1)\n#define forr_5(forr_i, a, b, A, B) rer(forr_i, sz(A)-1)\n#define forr_6(a, b, c, A, B, C) rer(forr_i, sz(A)-1)\n#define forr_7(forr_i, a, b, c, A, B, C) rer(forr_i, sz(A)-1)\n#define forr_8(a, b, c, d, A, B, C, D) rer(forr_i, sz(A)-1)\n#define forr_9(forr_i, a, b, c, d, A, B, C, D) rer(forr_i, sz(A)-1)\n\n//↑@オーバーロード隔離\n\n//rep系はインデックス、for系は中身\n#define rep(...) over4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rer(...) over4(__VA_ARGS__,rer4,rer3,rer2,)(__VA_ARGS__)\n//char用のrep\n#define repc(i, m, n) for(char i = m,repc3lim=n; i < repc3lim ; ++i)\n//i,j,k...をnまで見る\n#define reps(...) over5(__VA_ARGS__,reps5,reps4,reps3,reps2,)(__VA_ARGS__)\n#define repss(...) over10(__VA_ARGS__, repss10, a, repss8, a, repss6, a, repss4, a, repss2) (__VA_ARGS__)\n//vectorのindexを走査する\n//repv(i,j,vvi)\n#define repv(...) over6(__VA_ARGS__,repv_6,repv_5,repv_4,repv_3,repv_2,)(__VA_ARGS__)\n#define rerv(i, A) for (int i = sz(A)-1; i >= 0 ; i--)\n//repvn(dp) nは次元\n#define repv1(a) repv(i, a)\n#define repv2(a) repv(i, j, a)\n#define repv3(a) repv(i, j, k, a)\n#define repv4(a) repv(i, j, k, l, a)\n\n#define fora(...) over9(__VA_ARGS__, fora_9, fora_8, fora_7, fora_6, fora_5, fora_4, fora_3, fora_2)(__VA_ARGS__)\n#define forr(...) over9(__VA_ARGS__, forr_9, forr_8, forr_7, forr_6, forr_5, forr_4, forr_3, forr_2)(__VA_ARGS__)\n\n//#define forr(v, a) for(auto&& v : makeReversedRange(a))\n//参照を取らない\n#define forv(a, b) for(auto a : to1d(b))\n\n//インデックスを前後含めて走査\n#define ring(i, s, len) for (int i = s, prev = (s == 0) ? len - 1 : s - 1, next = (s == len - 1) ? 0 : s + 1, cou = 0; cou < len; cou++, prev = i, i = next, next = (next == len - 1) ? 0 : next + 1)\n//値と前後を見る\n#define ringv(v, d) index_=0;for (auto prev = d[sz(d)-1],next= (int)d.size()>1?d[1]:d[0],v = d[0]; index_ < sz(d); index_++, prev = v, v = next, next = (index_>=sz(d)-1?d[0]:d[index_+1]))\n// 左右をnext prevで見る 0の左と nの右\n#define forlr(v, d, banpei_l, banpei_r) rep(forlr_i,sz(d))\n\n#define form(...) over5(__VA_ARGS__,form5,form4,form3,form2,form1)(__VA_ARGS__)\n#define forrm(...) over5(__VA_ARGS__,forrm5,forrm4,forrm3,forrm2,forrm1)(__VA_ARGS__)\n#define fors(...) over4(__VA_ARGS__,fors4,fors3,fors2,fors1)(__VA_ARGS__)\n#define forslr(...) over6(__VA_ARGS__,forslr6,forslr5,forslr4,forslr3)(__VA_ARGS__)\n#define forp(k, v, st) for (auto &&forp_it = st.begin(); forp_it != st.end(); ++forp_it)\n\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst ll inf = (ll) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst dou dinf = (dou) linf * linf;\nconst char infc = '{';\nconst string infs = \"{\";\nconst double PI = 3.1415926535897932384626433832795029L;\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((ll)(a).size())\n#define mp make_pair\n#define pb pop_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconstexpr bool ev(ll a) { return !(a & 1); }\nconstexpr bool od(ll a) { return (a & 1); }\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> { public:size_t operator()(const std::pair<signed, signed> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n    template<> class hash<std::pair<ll, ll>> { public:/*大きいllが渡されると、<<32でオーバーフローするがとりあえず問題ないと判断*/size_t operator()(const std::pair<ll, ll> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n}\n//stream まとめ\n/*@formatter:on*/\nistream &operator>>(istream &iss, P &a) {\n    iss >> a.first >> a.second;\n    return iss;\n}\ntemplate<typename T> istream &operator>>(istream &iss, vector<T> &vec_) {\n    for (T &x: vec_) iss >> x;\n    return iss;\n}\ntemplate<class T, class U> ostream &operator<<(ostream &os, pair<T, U> p) {\n    os << p.fi << \" \" << p.se;\n    return os;\n}\nostream &operator<<(ostream &os, T p) {\n    os << p.f << \" \" << p.s << \" \" << p.t;\n    return os;\n}\nostream &operator<<(ostream &os, F p) {\n    os << p.a << \" \" << p.b << \" \" << p.c << \" \" << p.d;\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &vec_) {\n    for (ll i = 0; i < vec_.size(); ++i)os << vec_[i] << (i + 1 == vec_.size() ? \"\" : \" \");\n    return os;\n}\n\ntemplate<typename T> ostream &operator<<(ostream &os, vector<vector<T>> &vec_) {\n    for (ll i = 0; i < vec_.size(); ++i) {\n        for (ll j = 0; j < vec_[i].size(); ++j) { os << vec_[i][j] << \" \"; }\n        os << endl;\n    }\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, map<T, U> &m) {\n    os << endl;\n    for (auto &&v:m) os << v << endl;\n    return os;\n}\ntemplate<class T> ostream &operator<<(ostream &os, set<T> s) {\n    fora(v, s) { os << v << \" \"; }\n    return os;\n}\ntemplate<class T> ostream &operator<<(ostream &os, mset<T> s) {\n    fora(v, s) { os << v << \" \"; }\n    return os;\n}\ntemplate<class T> ostream &operator<<(ostream &os, deque<T> a) {\n    fora(v, a)os << v << \" \";\n    return os;\n}\nostream &operator<<(ostream &os, vector<vector<char>> &vec_) {\n    rep(h, sz(vec_)) {\n        rep(w, sz(vec_[0])) { os << vec_[h][w]; }\n        os << endl;\n    }\n    return os;\n}\n//template<class T,class U>ostream &operator<<(ostream &os, vector<pair<T,U>>& a) {fora(v,a)os<<v<<endl;return os;}\n/*@formatter:off*/\ntemplate<typename W, typename H> void resize(W &vec_, const H head) { vec_.resize(head); }\ntemplate<typename W, typename H, typename ... T> void resize(W &vec_, const H &head, const T ... tail) {vec_.resize(head);for (auto &v: vec_)resize(v, tail...);}\n//template<typename W, typename H> void resize(vector<W> &vec, const H head) { vec.resize(head); }\n//template<typename W, typename H, typename ... T> void resize(vector<W> &vec, const H &head, const T ... tail) {vec.resize(head);for (auto &v: vec)resize(v, tail...);}\ntemplate<typename T, typename F> bool all_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool all_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (!all_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool any_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool any_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (any_of2(v[i], f))return true; }    return false;}\ntemplate<typename T, typename F> bool none_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool none_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (none_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool find_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll find_if2(vector<T> &v, F f) {    rep(i, sz(v)) { if (find_if2(v[i], f))return i; }    return sz(v);}\ntemplate<typename T, typename F> bool rfind_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll rfind_if2(vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (rfind_if2(v[i], f))return i; }    return -1;}\ntemplate<class T> bool contains(string &s, const T &v) { return s.find(v) != string::npos; }\ntemplate<typename T> bool contains(vector<T> &v, const T &val) { return std::find(v.begin(), v.end(), val) != v.end(); }\ntemplate<typename T, typename F> bool contains_if2(vector<T> &v, F f) { return find_if(v.begin(), v.end(), f) != v.end(); }\ntemplate<typename T, typename F> ll count_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll count_if2(vector<T> &vec_, F f) {    ll ret = 0;    fora(v, vec_)ret += count_if2(v, f);    return ret;}\ntemplate<typename T, typename F> void for_each2(T &v, F f) { f(v); }\ntemplate<typename T, typename F> void for_each2(vector<T> &vec_, F f) { fora(v, vec_)for_each2(v, f); }\ntemplate<typename W> ll count_od(vector<W> &a) {return count_if2(a,[](ll v){return v&1 ;});}\ntemplate<typename W> ll count_ev(vector<W> &a) {return count_if2(a,[](ll v){return !(v&1) ;});}\n//削除した後のvectorを返す\ntemplate<typename T, typename F> vector<T> erase_if2(vector<T> &v, F f) {vector<T> nv;rep(i, sz(v)) { if (!f(v[i])) { nv.push_back(v[i]); }}return nv;}\ntemplate<typename T, typename F> vector<vector<T>> erase_if2(vector<vector<T>> &v, F f) {vector<vector<T>> res;rep(i, sz(v)) { res[i] = erase_if2(v[i], f); }return res;}\ntemplate<typename T, typename F> vector<T> l_erase_if2(vector<T> &v, F f) {vector<T> nv;rep(i, sz(v)) { if (!f(v[i])) { nv.push_back(v[i]); }}return nv;}\n\ntemplate<typename T, typename F> ll l_rfind_if(vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (f(v[i]))return i; }    return -1;}\ntemplate<typename T, typename F> bool l_contains_if(vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (f(v[i]))return true; }    return false;}\ntemplate<class A,class B, class C> auto t_all_of(A a,B b, C c){return std::all_of(a,b,c);}\ntemplate<class A,class B, class C> auto t_any_of(A a,B b, C c){return std::any_of(a,b,c);}\ntemplate<class A,class B, class C> auto t_none_of(A a,B b, C c){return std::none_of(a,b,c);}\ntemplate<class A,class B, class C> auto t_find_if(A a,B b, C c){return std::find_if(a,b,c);}\ntemplate<class A,class B, class C> auto t_count_if(A a,B b, C c){return std::count_if(a,b,c);}\n\n#define all_of_s__2(a,right) (t_all_of(all(a),lamr(right)))\n#define all_of_s__3(a,v,siki) (t_all_of(all(a),[&](auto v){return siki;}))\n#define all_of_s(...) over3(__VA_ARGS__,all_of_s__3,all_of_s__2)(__VA_ARGS__)\n\n//all_of(A, %2);\n//all_of(A, a, a%2);\n#define all_of__2(a,right) all_of2(a,lamr(right))\n#define all_of__3(a,v,siki) all_of2(a,[&](auto v){return siki;})\n#define all_of(...) over3(__VA_ARGS__,all_of__3,all_of__2)(__VA_ARGS__)\n#define all_of_f(a,f) all_of2(a,f)\n\n#define any_of_s__2(a,right) (t_any_of(all(a),lamr(right)))\n#define any_of_s__3(a,v,siki) (t_any_of(all(a),[&](auto v){return siki;}))\n#define any_of_s(...) over3(__VA_ARGS__,any_of_s__3,any_of_s__2)(__VA_ARGS__)\n\n#define any_of__2(a,right) any_of2(a,lamr(right))\n#define any_of__3(a,v, siki) any_of2(a,[&](auto v){return siki;})\n#define any_of(...) over3(__VA_ARGS__,any_of__3,any_of__2)(__VA_ARGS__)\n#define any_of_f(a,f) any_of2(a,f)\n\n#define none_of_s__2(a,right) (t_none_of(all(a),lamr(right)))\n#define none_of_s__3(a,v,siki) (t_none_of(all(a),[&](auto v){return siki;}))\n#define none_of_s(...) over3(__VA_ARGS__,none_of_s__3,none_of_s__2)(__VA_ARGS__)\n\n#define none_of__2(a,right) none_of2(a,lamr(right))\n#define none_of__3(a,v, siki) none_of2(a,[&](auto v){return siki;})\n#define none_of(...) over3(__VA_ARGS__,none_of__3,none_of__2)(__VA_ARGS__)\n#define none_of_f(a,f) none_of2(a,f)\n\n#define find_if_s__2(a,right) (t_find_if(all(a),lamr(right))-a.begin())\n#define find_if_s__3(a,v,siki) (t_find_if(all(a),[&](auto v){return siki;})-a.begin())\n#define find_if_s(...) over3(__VA_ARGS__,find_if_s__3,find_if_s__2)(__VA_ARGS__)\n\n#define find_if__2(a,right) find_if2(a,lamr(right))\n#define find_if__3(a,v, siki) find_if2(a,[&](auto v){return siki;})\n#define find_if(...) over3(__VA_ARGS__,find_if__3,find_if__2)(__VA_ARGS__)\n#define find_if_f(a,f) find_if2(a,f)\n\n#define rfind_if_s__2(a,right) l_rfind_if(a, lamr(right))\n#define rfind_if_s__3(a,v,siki) l_rfind_if(a, [&](auto v){return siki;})\n#define rfind_if_s(...) over3(__VA_ARGS__,rfind_if_s__3,rfind_if_s__2)(__VA_ARGS__)\n\n#define rfind_if__2(a,right) rfind_if2(a,lamr(right))\n#define rfind_if__3(a,v, siki) rfind_if2(a,[&](auto v){return siki;})\n#define rfind_if(...) over3(__VA_ARGS__,rfind_if__3,rfind_if__2)(__VA_ARGS__)\n#define rfind_if_f(a,f) rfind_if2(a,f)\n\n#define contains_if_s__2(a,right) l_contains_if(a, lamr(right))\n#define contains_if_s__3(a,v,siki) l_contains_if(a, [&](auto v){return siki;})\n#define contains_if_s(...) over3(__VA_ARGS__,contains_if_s__3,contains_if_s__2)(__VA_ARGS__)\n\n#define contains_if__2(a,right) contains_if2(a,lamr(right))\n#define contains_if__3(a,v, siki) contains_if2(a,[&](auto v){return siki;})\n#define contains_if(...) over3(__VA_ARGS__,contains_if__3,contains_if__2)(__VA_ARGS__)\n#define contains_if_f(a,f) contains_if2(a,f)\n\n#define count_if_s__2(a,right) (t_count_if(all(a),lamr(right)))\n#define count_if_s__3(a,v,siki) (t_count_if(all(a),[&](auto v){return siki;}))\n#define count_if_s(...) over3(__VA_ARGS__,count_if_s__3,count_if_s__2)(__VA_ARGS__)\n\n#define count_if__2(a,right) count_if2(a,lamr(right))\n#define count_if__3(a,v, siki) count_if2(a,[&](auto v){return siki;})\n#define count_if(...) over3(__VA_ARGS__,count_if__3,count_if__2)(__VA_ARGS__)\n#define count_if_f(a,f) count_if2(a,f)\n\n//vector<vi>で、viに対して操作\n#define for_each_s__2(a,right) do{fora(v,a){v right;}}while(0)\n#define for_each_s__3(a,v, shori) do{fora(v,a){shori;}}while(0)\n#define for_each_s(...) over3(__VA_ARGS__,for_each_s__3,for_each_s__2)(__VA_ARGS__)\n\n//vector<vi>で、intに対して操作\n#define for_each__2(a,right) for_each2(a,lamr(right))\n#define for_each__3(a,v, shori) for_each2(a,[&](auto& v){shori;})\n#define for_each(...) over3(__VA_ARGS__,for_each__3,for_each__2)(__VA_ARGS__)\n#define for_each_f(a, f) for_each2(a, f);\n\n#define for_eached__2(a,right) [&](auto a) {auto b = a;for_each(b, right);return b; }(a)\n#define for_eached__3(a,v, shori) [&](auto a) {auto b = a;for_each(b, v, shori);return b; }(a)\n#define for_eached(...) over3(__VA_ARGS__,for_eached__3,for_eached__2)(__VA_ARGS__)\n#define for_eached_f(a, f) for_eached2(a, f);\n\n\n\n#define erase_if_s__2(a,right) l_erase_if2(a,lamr(right))\n#define erase_if_s__3(a,v, siki) l_erase_if2(a,[&](auto v){return siki;})\n#define erase_if_s(...) over3(__VA_ARGS__,erase_if_s__3,erase_if_s__2)(__VA_ARGS__)\n\n\n#define erase_if__2(a,right) erase_if2(a,lamr(right))\n#define erase_if__3(a,v, siki) erase_if2(a,[&](auto v){return siki;})\n#define erase_if(...) over3(__VA_ARGS__,erase_if__3,erase_if__2)(__VA_ARGS__)\n#define erase_if_f(a,f) erase_if2(a,f)\n\n#define entry_if_s__2(a,right) l_entry_if2(a,lamr(right))\n#define entry_if_s__3(a,v, siki) l_entry_if2(a,[&](auto v){return siki;})\n#define entry_if_s(...) over3(__VA_ARGS__,entry_if_s__3,entry_if_s__2)(__VA_ARGS__)\n\n\n#define entry_if__2(a,right) entry_if2(a,lamr(right))\n#define entry_if__3(a,v, siki) entry_if2(a,[&](auto v){return siki;})\n#define entry_if(...) over3(__VA_ARGS__,entry_if__3,entry_if__2)(__VA_ARGS__)\n#define entry_if_f(a,f) entry_if2(a,f)\n\n\n\ntemplate<class T, class U,class W> void replace(vector<W> &a, T key, U v) { rep(i,sz(a))if(a[i]==key)a[i]=v; }\ntemplate<class T, class U,class W> void replace(vector<vector<W>> &A, T key, U v) { rep(i,sz(A))replace(A[i], key, v); }\nvoid replace(str &a, char key, str v) { if (v == \"\")a.erase(remove(all(a), key), a.end()); }\nvoid replace(str &a, char key, char v) { replace(all(a), key, v); }\n//keyと同じかどうか01で置き換える\ntemplate<class T, class U> void replace(vector<T> &a, U k) { rep(i, sz(a)) a[i] = a[i] == k; }\ntemplate<class T, class U> void replace(vector<vector<T >> &a, U k) { rep(i, sz(a))rep(j, sz(a[0])) a[i][j] = a[i][j] == k; }\n//template<class T> void replace(T &a) { replace(a, '#'); }\nvoid replace(str &a) {    int dec = 0;    if('a'<=a[0]&&a[0]<='z')dec = 'a';    if('A'<=a[0]&&a[0]<='Z')dec = 'A';    fora(v,a)v-=dec;}\nvoid replace(str &a, str key, str v) {stringstream t;ll kn = sz(key);std::string::size_type Pos(a.find(key));ll l = 0;while (Pos != std::string::npos) {t << a.substr(l, Pos - l);t << v;l = Pos + kn;Pos = a.find(key, Pos + kn);}t << a.substr(l, sz(a) - l);a = t.str();}\ntemplate<class T> bool includes(vector<T> &a, vector<T> &b) {vi c = a;vi d = b;sort(all(c));sort(all(d));return includes(all(c), all(d));}\ntemplate<class T> bool is_permutation(vector<T> &a, vector<T> &b) { return is_permutation(all(a), all(b)); }\ntemplate<class T> bool next_permutation(vector<T> &a) { return next_permutation(all(a)); }\nvoid iota(vector<ll> &ve, ll s, ll n) {ve.resize(n);iota(all(ve), s);}\nvi iota(ll s, ll len) {vi ve(len);iota(all(ve), s);return ve;}\ntemplate<class A, class B> auto vtop(vector<A> &a, vector<B> &b) {    assert(sz(a) == sz(b));    /*stringを0で初期化できない  */  vector<pair<A, B>> res;    rep(i, sz(a))res.eb(a[i], b[i]);return res;}\ntemplate<class A, class B> void ptov(vector<pair<A, B>> &p, vector<A> &a, vector<B> &b) {    a.resize(sz(p)), b.resize(sz(p));    rep(i, sz(p))a[i] = p[i].fi, b[i] = p[i].se;}\ntemplate<class A, class B, class C> auto vtot(vector<A> &a, vector<B> &b, vector<C> &c) {    assert(sz(a) == sz(b) && sz(b) == sz(c));    vector<T2<A, B, C>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i]);    return res;}\ntemplate<class A, class B, class C, class D> auto vtof(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    assert(sz(a) == sz(b) && sz(b) == sz(c) && sz(c) == sz(d));    vector<F2<A, B, C, D>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i], d[i]);    return res;}\nenum pcomparator { fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd };\nenum tcomparator {    fisiti, fisitd, fisdti, fisdtd, fdsiti, fdsitd, fdsdti, fdsdtd,    fitisi, fitisd, fitdsi, fitdsd, fdtisi, fdtisd, fdtdsi, fdtdsd,    sifiti, sifitd, sifdti, sifdtd, sdfiti, sdfitd, sdfdti, sdfdtd,    sitifi, sitifd, sitdfi, sitdfd, sdtifi, sdtifd, sdtdfi, sdfdfd,    tifisi, tifisd, tifdsi, tifdsd, tdfisi, tdfisd, tdfdsi, tdfdsd,    tisifi, tisifd, tisdfi, tisdfd, tdsifi, tdsifd, tdsdfi, tdsdfd};\ntemplate<class A, class B> void sort(vector<pair<A, B>> &a, pcomparator type) {    typedef pair<A, B> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });};template<class U> void sort(vector<U> &a, pcomparator type) {    if (type == fisi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f > r.f; });};template<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D> > &a, pcomparator type) {    typedef F2<A, B, C, D> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a > r.a; });};template<class U> void sort(vector<U> &a, tcomparator type) {    if (type == 0) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == 41) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == 42) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == 43) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });    else if (type == 44) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == 45) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == 46) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == 47) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });}template<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D>> &a, tcomparator type) {    typedef F2<A, B, C, D> U;    if (type == 0) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == 41) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == 42) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == 43) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });    else if (type == 44) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == 45) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == 46) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == 47) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });}\n\nvoid sort(string &a) { sort(all(a)); }\nvoid sort(int& a,int& b){    if(a>b)swap(a,b);}\nvoid sort(int& a,int& b, int& c){    sort(a,b);    sort(a,c);    sort(b,c);}\nvoid rsort(int& a,int& b){    if(a<b)swap(a,b);}\nvoid rsort(int& a,int& b, int& c){    rsort(a,b);    rsort(a,c);    rsort(b,c);}\ntemplate<class T> void sort(vector<T> &a) { sort(all(a)); }\n//P l, P rで f(P) の形で渡す\ntemplate<class U, class F> void sort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) < f(r); }); };\ntemplate<class T> void rsort(vector<T> &a) { sort(all(a), greater<T>()); };\ntemplate<class U, class F> void rsort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) > f(r); }); };\n\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class A, class B> void sortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    sort(c);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}template<class A, class B, class F> void sortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    sort(c, f);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}template<class A, class B> void rsortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    rsort(c);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}template<class A, class B, class F> void rsortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    rsort(c, f);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}\ntemplate<class A, class B, class C> void sortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    sort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class F> void sortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    sort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    rsort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class F> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    rsort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class D> void sortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    sort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\ntemplate<class A, class B, class C, class D> void rsortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    rsort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\n//sortindex 元のvectorはソートしない\ntemplate<class T> vi sorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind);    return ind;}/*indexの分で型が変わるためpcomparatorが必要*/template<class T> vi sorti(vector<T> &a, pcomparator f) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind, f);    return ind;}template<class T, class F> vi sorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(a[x]) < f(a[y]); });    return ind;}template<class T> vi rsorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    rsortp(b, ind);    return ind;}template<class T, class F> vi rsorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(a[x]) > f(a[y]); });    return ind;}template<class A, class B, class F> vi sortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(c[x]) < f(c[y]); });    return ind;}template<class A, class B> vi sortpi(vector<A> &a, vector<B> &b, pcomparator f) {    vi ind = iota(0, sz(a));    auto c = a;    auto d = b;    sortt(c, d, ind, f);    return ind;}template<class A, class B> vi sortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fisi); };template<class A, class B, class F> vi rsortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(c[x]) > f(c[y]); });    return ind;}template<class A, class B> vi rsortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fdsd); };template<class A, class B, class C, class F> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(d[x]) < f(d[y]); });    return ind;}template<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, pcomparator f) {    vi ind = iota(0, sz(a));    auto d = vtof(a, b, c, ind);    sort(d, f);    rep(i, sz(a))ind[i] = d[i].d;    return ind;}template<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) {        if (a[x] == a[y]) {            if (b[x] == b[y])return c[x] < c[y];            else return b[x] < b[y];        } else {            return a[x] < a[y];        }    });    return ind;}template<class A, class B, class C, class F> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(d[x]) > f(d[y]); });    return ind;}template<class A, class B, class C> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) {        if (a[x] == a[y]) {            if (b[x] == b[y])return c[x] > c[y];            else return b[x] > b[y];        } else {            return a[x] > a[y];        }    });    return ind;}\ntemplate<class T> void sort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)sort(a[i]); }\ntemplate<class T> void rsort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)rsort(a[i]); }\n\ntemplate<class... T,class U> auto sorted(U head,T... a) { sort(head,a...); return head;}\n\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }template<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }template<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\ntemplate<typename W, typename T>void fill(W &xx, const T vall) {    xx = vall;}template<typename W, typename T>void fill(vector<W> &vecc, const T vall) {    for (auto &&vx     : vecc)fill(vx, vall);}\ntemplate<typename W,typename T>void fill(vector<W> &xx,ll len,const T v) {rep(i, len)xx[i]=v;}\ntemplate<typename W, typename T> void fill(vector<vector<W>> &xx, int sh, int th, int sw, int tw, T v) { rep(h, sh, th)rep(w, sw, tw)xx[h][w] = v; }\ntemplate<class T,class U>void fill(vector<T> &a,vi& ind,U val) {fora(v,ind)a[v]=val;}\ntemplate<class W,class T>void fill(mvec<W> &xx,const T v){fora(x,xx)fill(x,v);}\n\n\ntemplate<typename A, size_t N> A sum(A (&a)[N]) {    A res = 0;    rep(i, N)res += a[i];    return res;}template<typename A, size_t N, size_t O> A sum(A (&a)[N][O]) {    A res = 0;    rep(i, N)rep(j, O)res += a[i][j];    return res;}template<typename A, size_t N, size_t O, size_t P> A sum(A (&a)[N][O][P]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)res += a[i][j][k];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A sum(A (&a)[N][O][P][Q]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)res += a[i][j][k][l];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A sum(A (&a)[N][O][P][Q][R]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)res += a[i][j][k][l][m];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A sum(A (&a)[N][O][P][Q][R][S]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)res += a[i][j][k][l][m][n];    return res;}\n//@汎用便利関数 入力\nll in() {ll ret;cin >> ret;return ret;}\ntemplate<class T> T in(){\n    T ret;\n    cin>>ret;\n    return ret;\n}\nstring sin() {string ret;cin >> ret;return ret;}\ntemplate<class T>  void in(T &head) { cin >> head; }template<class T, class... U>  void in(T &head, U &... tail) {cin >> head;in(tail...);}\n\n#define din_t2(type,a) type a;cin>>a\n#define din_t3(type,a, b) type a,b;cin>>a>> b\n#define din_t4(type,a, b, c) type a,b,c;cin>>a>>b>>c\n#define din_t5(type,a, b, c, d) type a,b,c,d;cin>>a>>b>>c>>d\n#define din_t6(type,a, b, c, d, e) type a,b,c,d,e;cin>>a>>b>>c>>d>>e\n#define din_t7(type,a, b, c, d, e, f) type a,b,c,d,e,f;cin>>a>>b>>c>>d>>e>>f\n#define din_t(...) over7(__VA_ARGS__,din_t7,din_t6,din_t5,din_t4,din_t3 ,din_t2)(__VA_ARGS__)\n\n#define din(...) din_t(int,__VA_ARGS__)\n#define d_in\n#define dsig(...) din_t(signed,__VA_ARGS__)\n\n#define dst(...) din_t(string,__VA_ARGS__)\n#define dstr dst\n#define d_str dst\n\n#define dcha(...) din_t(char,__VA_ARGS__)\n#define dchar dcha\n\n#define ddou(...) din_t(double,__VA_ARGS__)\n\n\n\n\n\n#define din1d(a) din_t2(int, a);a--\n#define din2d(a, b) din_t3(int, a,b);a--,b--\n#define din3d(a, b, c) din_t4(int, a,b,c);a--,b--,c--\n#define din4d(a, b, c, d) din_t5(int, a,b,c,d);a--,b--,c--,d--\n#define dind(...) over4(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\n\n#ifdef _DEBUG\ntemplate<class T> void err2(T &&head) { cerr << head; }\ntemplate<class T, class... U> void err2(T &&head, U &&... tail) {    cerr << head << \" \";    err2(tail...);}\ntemplate<class T, class... U> void err(T &&head, U &&... tail) {    cerr << head << \" \";    err2(tail...);    cerr << \"\" << endl;}\ntemplate<class T> void err(T &&head) {    cerr << head  << endl;}\nvoid err() {    cerr << \"\"  << endl;}\ntemplate<class T> string out_m2(vector<T> &a, ll W = inf) {    stringstream ss;    if (W == inf)W = min(sz(a), 12ll);    if (sz(a) == 0)return ss.str();    rep(i, W) {        ss << a[i];        if (typeid(a[i]) == typeid(P)) { ss << endl; } else { ss << \" \"; }    }    return ss.str();}\ntemplate<class T> string out_m2(vector<vector<T> > &a, ll H = inf, ll W = inf, int key = -1) {    H = (H != inf) ? H : min({H, sz(a), 12ll});    W = min({W, sz(a[0]), 12ll});    stringstream ss;    ss << endl;    if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";    rep(w, W)ss << std::right << std::setw(4) << w;    ss << \"\" << endl;    rep(w, W * 4 + 3)ss << \"_\";    ss << \"\" << endl;    rep(h, H) {        ss << std::right << std::setw(2) << h << \"|\";        rep(w, min(sz(a[h]), 12ll)) { if (abs(a[h][w]) == linf || abs(a[h][w])==inf) ss << \"   e\" << \"\"; else ss << std::right << std::setw(4) << a[h][w]; }        ss << \"\" << endl;    }    return ss.str();}\ntemplate<class T> string out_m2(vector<set<T> > &a, ll H = inf, ll W = inf, int key = -1) {    vector<vector<T> > b(sz(a));    rep(i, sz(a)) { fora(v, a[i]) { b[i].push_back(v); }}    return out_m2(b, H, W, key);}\ntemplate<class T> string out_m2(vector<vector<vector<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {    stringstream ss;    if (H == inf)H = 12;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << out_m2(a[i], W, U, i);    }    return ss.str();}\ntemplate<class T, size_t N> string out_m2(T (&a)[N]) {    vector<T> b;    resize(b, N);    rep(i, N) {        b[i] = a[i];    }    return out_m2(b);}\ntemplate<class T, size_t N, size_t M> string out_m2(T (&a)[N][M]) {    vector<vector<T>> b;    resize(b, N, M);    rep(i, N) {        rep(j, M) {            b[i][j] = a[i][j];        }    }    return out_m2(b);}\ntemplate<class T, size_t N, size_t M, size_t O> string out_m2(T (&a)[N][M][O]) {    vector<vector<vector<T>>> b;    resize(b, N, M, O);    rep(i, N) {        rep(j, M) {            rep(k, O) {                b[i][j][k] = a[i][j][k];            }        }    }    return out_m2(b);}\nstring out_m2(int a) {stringstream ss;ss << a;return ss.str();}\ntemplate<class T> string out_m2(mvec<mvec<T> > &a, ll H = inf, ll W = inf, int key = inf) {    H = min({H, sz(a), 6ll});    W = min({W, sz(a[0]), 6ll});    stringstream ss;    ss << endl;    if (key == inf)ss << \" *|\";    else {        ss << std::right << std::setw(2) << key;        ss << \"|\";    }    rep(w, -W, W)ss << std::right << std::setw(4) << w;    ss << \"\" << endl;    rep(w, W * 8 + 3)ss << \"_\";    ss << \"\" << endl;    rep(h, -H, H) {        ss << std::right << std::setw(2) << h << \"|\";        int NW = min(sz(a[h]), 6ll);        rep(w, -NW, NW) { if (abs(a[h][w]) == linf) ss << \"   e\" << \"\"; else ss << std::right << std::setw(4) << a[h][w]; }        ss << \"\" << endl;    }    return ss.str();}\ntemplate<class T> string out_m2(mvec<mvec<mvec<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {    stringstream ss;    if (H == inf)H = 6;    H = min(H, sz(a));    rep(i, -H, H) {        ss << endl;        ss << out_m2(a[i], W, U, i);    }    return ss.str();}\ntemplate<class T> string out_m2(T &a) {stringstream ss;ss << a;return ss.str();}\ntemplate<class T> string out_m(vector<T> &a, ll W = inf) {    stringstream ss;    if (W == inf)W = min(sz(a), 12ll);    if (sz(a) == 0)return ss.str();    rep(i, W) { ss << a[i] << \" \"; }    ss << \"\" << endl;    return ss.str();}\ntemplate<class T> string out_m(vector<vector<T> > &a, ll H = inf, ll W = inf, int key = -1) {H = min({H, sz(a), 12ll});W = min({W, sz(a[0]), 12ll});stringstream ss;ss << endl;if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";rep(w, W)ss << std::right << std::setw(4) << w;ss << \"\" << endl;rep(w, W * 4 + 3)ss << \"_\";ss << \"\" << endl;rep(h, H) {ss << std::right << std::setw(2) << h << \"|\";rep(w, min(sz(a[h]),12ll)) { if (abs(a[h][w]) == linf) ss << \"   e\" << \"\"; else ss << std::right << std::setw(4) << a[h][w]; }ss << \"\" << endl;}ss << endl;return ss.str();}\ntemplate<class T> string out_m(vector<vector<vector<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {stringstream ss;    if (H == inf)H = 5;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << out_m(a[i], W, U, i);    }    ss << endl;    return ss.str();}\nstring out_m(int a) {stringstream ss;ss << a << endl;return ss.str();}\ntemplate<class T> string out_m(T &a) {stringstream ss;ss << a << endl;return ss.str();}\ntemplate<class T> void outv(vector<T> &a, ll W=inf) {cout << out_m(a,W) << endl;}\ntemplate<class T> void outv(vector<vector<T> > &a, ll H = linf, ll W = linf,int key=-1) {    cout << out_m(a,H,W,key) << endl;}\ntemplate<class T> void outv(vector<vector<vector<T> > > &a, ll H = linf, ll W = linf,ll U = linf) {cout << out_m(a,H,W,U)<< endl;}\n\ntemplate<class T> void out2(T &&head) { cout << head;res_mes += out_m2(head); }\ntemplate<class T, class... U> void out2(T &&head, U &&... tail) {    cout << head << \" \";   res_mes += out_m2(head)+\" \"; out2(tail...);}\ntemplate<class T, class... U> void out(T &&head, U &&... tail) {    cout << head << \" \";    res_mes += out_m2(head)+\" \";out2(tail...);    cout << \"\" << endl;res_mes += \"\\n\";}\ntemplate<class T> void out(T &&head) {    cout << head  << endl; res_mes += out_m2(head)+\"\\n\";}\nvoid out() {    cout << \"\"  << endl;}\n\n#else\ntemplate<class T> void outv(vector<T> &a, ll W = inf) {\n    rep(i, min(W, sz(a))) { cout << a[i] << \" \"; }\n    cout << \"\" << endl;\n}\ntemplate<class T> void outv(vector<vector<T> > &a, ll H = linf, ll W = linf, int key = -1) { rep(i, min(H, sz(a))) { outv(a[i], W); }}\ntemplate<class T> void outv(vector<vector<vector<T> > > &a, ll H = linf, ll W = linf, ll U = linf) { ; }\n#define err(...);\n\ntemplate<class T> void out2(T &&head) { cout << head; }\ntemplate<class T, class... U> void out2(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);}\ntemplate<class T, class... U> void out(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);    cout << \"\" << endl;}\ntemplate<class T> void out(T &&head) {    cout << head  << endl;}\nvoid out() {    cout << \"\"  << endl;}\n\n#endif\ntemplate<class T> void outl(vector<T> &a, int n = inf) { rep(i, min(n, sz(a)))cout << a[i] << endl; }\n//テーブルをスペースなしで出力\ntemplate<class T> void outt(vector<vector<T>> &a) {rep(i, sz(a)) {rep(j, sz(a[i])) { cout << a[i][j]; }cout << endl;}}\n//int型をbit表記で出力\nvoid outb(int a) { cout << bitset<20>(a) << endl; }\ntemplate<class T> void na(vector<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i];}\ntemplate<class T> void na(set<T> &a, ll n) {rep(i, n)a.insert(in());}\n#define dna(a, n) vi a(n); rep(dnai,n) cin >> a[dnai];\n#define dnad(a, n) vi a(n); rep(dnai,n) cin >> a[dnai],a[dnai]--;\ntemplate<class T> void nao(vector<T> &a, ll n) {a.resize(n + 1);a[0] = 0;rep(i, n)cin >> a[i + 1];}\ntemplate<class T> void naod(vector<T> &a, ll n) {a.resize(n + 1);a[0] = 0;rep(i, n)cin >> a[i + 1], a[i + 1]--;}\ntemplate<class T> void nad(vector<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i], a[i]--;}\ntemplate<class T> void nad(set<T> &a, ll n) {    rep(i, n)a.insert(in()-1);}\ntemplate<class T, class U> void na2(vector<T> &a, vector<U> &b, ll n) {    a.resize(n);    b.resize(n);    rep(i, n)cin >> a[i] >> b[i];}\ntemplate<class T, class U> void na2(set<T> &a, set<U> &b, ll n) {    rep(i, n){        a.insert(in());        b.insert(in());    }}\n#define dna2(a, b, n) vi a(n),b(n);rep(dna2i, n)cin >> a[dna2i] >> b[dna2i];\ntemplate<class T, class U> void nao2(vector<T> &a, vector<U> &b, ll n) {    a.resize(n + 1);    b.resize(n + 1);    a[0] = b[0] = 0;    rep(i, n)cin >> a[i + 1] >> b[i + 1];}\n#define dna2d(a, b, n) vi a(n),b(n);rep(dna2di, n){cin >> a[dna2di] >> b[dna2di];a[dna2di]--,b[dna2di]--;}\ntemplate<class T, class U> void na2d(vector<T> &a, vector<U> &b, ll n) {    a.resize(n);    b.resize(n);    rep(i, n)cin >> a[i] >> b[i], a[i]--, b[i]--;}\ntemplate<class T, class U, class W> void na3(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {    a.resize(n);    b.resize(n);    c.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i];}\n#define dna3(a, b, c, n) vi a(n),b(n),c(n);   rep(dna3i, n)cin >> a[dna3i] >> b[dna3i] >> c[dna3i];\ntemplate<class T, class U, class W> void na3d(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {    a.resize(n);    b.resize(n);    c.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i], a[i]--, b[i]--, c[i]--;}\n#define dna3d(a, b, c, n) vi a(n),b(n),c(n);  rep(dna3di, n){cin >> a[dna3di] >> b[dna3di] >> c[dna3di];a[dna3di]--,b[dna3di]--,c[dna3di]--;}\ntemplate<class T, class U, class W, class X> void na4(vector<T> &a, vector<U> &b, vector<W> &c, vector<X> &d, ll n) {    a.resize(n);    b.resize(n);    c.resize(n);    d.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i] >> d[i];}\n#define dna4(a, b, c, d, n) vi a(n),b(n),c(n),d(n);   rep(dna4i, n)cin >> a[dna4i] >> b[dna4i] >> c[dna4i]>>d[dna4i];\n#define dna4d(a, b, c, d, n) vi a(n),b(n),c(n),d(n);   rep(dna4i, n)cin >> a[dna4i] >> b[dna4i] >> c[dna4i]>>d[dna4i],--a[dna4i] ,-- b[dna4i],-- c[dna4i],--d[dna4i];\n#define nt(a, h, w) resize(a,h,w);rep(nthi,h)rep(ntwi,w) cin >> a[nthi][ntwi];\n#define ntd(a, h, w) resize(a,h,w);rep(ntdhi,h)rep(ntdwi,w) cin >> a[ntdhi][ntdwi], a[ntdhi][ntdwi]--;\n#define ntp(a, h, w) resize(a,h+2,w+2);fill(a,'#');rep(ntphi,1,h+1)rep(ntpwi,1,w+1) cin >> a[ntphi][ntpwi];\n#define dnt(S, h, w) vvi(S,h,w);nt(S,h,w);\n#define dntc(S, h, w) vvc(S,h,w);nt(S,h,w);\n#define dnts(S, h, w) vvs(S,h,w);nt(S,h,w);\n\n//デバッグ\n#define sp << \" \" <<\n\n#define deb1(x)  debugName(x)<<\" = \"<<out_m2(x)\n#define deb_2(x, ...) deb1(x) <<\", \"<< deb1(__VA_ARGS__)\n#define deb_3(x, ...) deb1(x) <<\", \"<< deb_2(__VA_ARGS__)\n#define deb_4(x, ...) deb1(x) <<\", \"<< deb_3(__VA_ARGS__)\n#define deb5(x, ...) deb1(x) <<\", \"<< deb_4(__VA_ARGS__)\n#define deb6(x, ...) deb1(x) <<\", \"<< deb5(__VA_ARGS__)\n#define deb7(x, ...) deb1(x) <<\", \"<< deb6(__VA_ARGS__)\n#define deb8(x, ...) deb1(x) <<\", \"<< deb7(__VA_ARGS__)\n#define deb9(x, ...) deb1(x) <<\", \"<< deb8(__VA_ARGS__)\n#define deb10(x, ...) deb1(x) <<\", \"<< deb9(__VA_ARGS__)\n\n\n#ifdef _DEBUG\nbool was_deb=false;\n#define deb(...)  do{was_deb=true;cerr<< over10(__VA_ARGS__,deb10,deb9,deb8,deb7,deb6,deb5,deb_4,deb_3,deb_2,deb1)(__VA_ARGS__) <<endl;}while(0)\n\n#define base_keta 8\nvoid print_n_base(int x,int base){    cerr<<bitset<base_keta>(x)<<endl;}\ntemplate<class T>void print_n_base(vector<T> X,int base){    cerr<<endl;    for(auto&& x:X){        print_n_base(x,base);    }    cerr<<endl;}\n\n//n進数\n#define deb2(x) cerr<<debugName(x)<<\" = \";print_n_base(x, 2);\n#define deb3(x) cerr<<debugName(x)<<\" = \";print_n_base(x, 3);\n#define deb4(x) cerr<<debugName(x)<<\" = \";print_n_base(x, 4);\n\n#define deb_ex_deb(x, len)  debugName(x)<<\" = \"<<out_m2(x, len)\n#define call_deb_ex_deb(x, len) deb_ex_deb(x, len)\n//要素が存在する行だけ出力(vvt)\n#define deb_ex(v) do {int N = sz(v);int s = N;int t = 0;rep(i, N) {if (sz(v[i])) {chmi(s, i);chma(t, i);}}auto ex_v = sub(v, s, N);str S = out_m2(ex_v, sz(ex_v));debugName(v);cerr<<\" = \"<<endl;cerr << S << endl;} while (0);\ntemplate<class T, class F> string out_m2_f(vector<vector<T> > &a, F f, int key = -1) {    stringstream ss;    vi H, W;    rep(h, sz(a)) {        rep(w, sz(a[0])) {            if (f(a[h][w])) {                H.push_back(h);                W.push_back(w);            }        }    }    sort(H);    sort(W);    unique(H);    unique(W);    ss << endl;    if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";    fora(w, W)ss << std::right << std::setw(sz(tos(w)) + 1) << w;    ss << \"\" << endl;    rep(w, sz(W) * 4 + 3)ss << \"_\";    ss << \"\" << endl;    fora(h, H) {        ss << std::right << std::setw(2) << h << \"|\";        fora(w, W) { if (abs(a[h][w]) == linf) ss << \"   e\" << \"\"; else ss << std::right << std::setw(sz(tos(w)) + 1) << a[h][w]; }        ss << \"\" << endl;    }    return ss.str();}\ntemplate<class T, class F> string out_m2_f(vector<vector<vector<T>>> &a, F f) {    stringstream ss;    int H = sz(a);    if (sz(a) == 0)return ss.str();    rep(i, H) { ss << out_m2_f(a[i], f, i); }    ss << \"\" << endl;    return ss.str();}\n#define debf_normal(tab, f) do{cerr<<debugName(tab)<<\" = \"<<endl;cerr<< out_m2_f(tab, f)<<endl;}while(0);\n#define debf2(tab, siki_r) debf_normal(tab, lamr(siki_r))\n#define debf3(tab, v, siki)  debf_normal(tab, lam(siki))\n//S, sikir\n//S, v, siki\n#define debf(...) over3(__VA_ARGS__,debf3,debf2,debf1)(__VA_ARGS__)\n\n#else\n#define deb(...) ;\n#define deb2(...) ;\n#define deb3(...) ;\n#define deb4(...) ;\n#define deb_ex(...) ;\n#define debf(...) ;\n#endif\n\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n\n//@formatter:off\n//よく使うクラス、構造体\n//graphでredefineしているため、書き換えたら向こうも書き換える\nstruct unionfind {\n    vector<ll> par;\n    vector<ll> siz;\n    vector<ll> es;\n    ll n, trees;//連結グループの数(親の種類)\n    unionfind(ll n) : n(n), trees(n) {        par.resize(n);        siz.resize(n);        es.resize(n);        for (ll i = 0; i < n; i++) {            par[i] = i;            siz[i] = 1;        }    }\n    ll root(ll x) { if (par[x] == x) { return x; } else { return par[x] = root(par[x]); }}\n    ll operator()(ll x){return root(x);}\n    bool unite(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        es[x]++;\n        if (x == y) return false;\n        if (siz[x] > siz[y]) swap(x, y);\n        trees--;\n        par[x] = y;\n        siz[y] += siz[x];\n        es[y] += es[x];\n        return true;\n    }\n    bool same(ll x, ll y) { return root(x) == root(y); }\n    ll size(ll x) { return siz[root(x)]; }\n    ll esize(ll x) { return es[root(x)]; }\n    vi sizes(){        vi cou(n);        vi ret;        ret.reserve(n);        rep(i, n){            cou[root (i)]++;        }        rep(i, n){            if(cou[i])ret.push_back(cou[i]);        }        return ret;    }\n    //つながりを無向グラフと見なし、xが閉路に含まれるか判定\n    bool close(ll x) { return esize(x) >= size(x); }\n    vector<vi> sets() {        vi ind(n, -1);        ll i = 0;        vvi(res, trees);        rep(j, n) {            ll r = root(j);            if (ind[r] == -1)ind[r] = i++;            res[ind[r]].push_back(j);        }        rep(i, trees) {            ll r = root(res[i][0]);            if (res[i][0] == r)continue;            rep(j, 1, sz(res[i])) {                if (res[i][j] == r) {                    swap(res[i][0], res[i][j]);                    break;                }            }        }        return res;    }\n};//@formatter:off\n\n\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing u128 = __uint128_t;\n\nusing bint =__int128;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {    std::ostream::sentry s(dest);    if (s) {        __uint128_t tmp = value < 0 ? -value : value;        char buffer[128];        char *d = std::end(buffer);        do {            --d;            *d = \"0123456789\"[tmp % 10];            tmp /= 10;        } while (tmp != 0);        if (value < 0) {            --d;            *d = '-';        }        ll len = std::end(buffer) - d;        if (dest.rdbuf()->sputn(d, len) != len) { dest.setstate(std::ios_base::badbit); }    }    return dest;}\n__int128 to_bint(string &s) {    __int128 ret = 0;    for (ll i = 0; i < s.length(); ++i)        if ('0' <= s[i] && s[i] <= '9')            ret = 10 * ret + s[i] - '0';    return ret;}\nvoid operator>>(istream &iss, bint &v) {\n    string S;\n    iss>>S;\n    v = 0;\n    rep(i,sz(S)){\n        v*=10;\n        v +=  S[i]-'0';\n    }\n}\nbint max(bint a, signed b){return max(a,(bint)b);}\nbint max(signed a, bint b){return max((bint)a, b);}\nbint max(bint a, ll b){return max(a,(bint)b);}\nbint max(ll a, bint b){return max((bint)a, b);}\nbint min(bint a, signed b){return min(a,(bint)b);}\nbint min(signed a, bint b){return min((bint)a, b);}\nbint min(bint a, ll b){return min(a,(bint)b);}\nbint min(ll a, bint b){return min((bint)a, b);}\n//エラー\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");    exit(0);\n#endif\n    string a = \"a\";    rep(i, 30)a += a;    rep(i, 1 << 17)cout << a << endl;    cout << \"OLE 出力長制限超過\" << endl;    exit(0);}\nvoid re() {    assert(0 == 1);    exit(0);}\nvoid tle() { while (inf)cout << inf << endl; }\n\n//便利関数\n\n//テスト用\n#define rand xor128_\nunsigned long xor128_(void){static unsigned long x=123456789,y=362436069,z=521288629,w=88675123;unsigned long t;t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );}\nchar ranc() { return (char) ('a' + rand() % 26); }\nll rand(ll min, ll max) {    assert(min <= max);    if (min >= 0 && max >= 0) { return rand() % (max + 1 - min) + min; } else if (max < 0) { return -rand(-max, -min); } else { if (rand() % 2) { return rand(0, max); } else { return -rand(0, -min); }}}\nll rand(ll max){return rand(0,max);}\ntemplate<class T> T rand(vector<T>& A){return A[rand(sz(A)-1)];}\n//重複することがある\ntemplate<class T> vector<T> ranv(vector<T>& A, int N){vector<T>ret(N);rep(i,N){ret[i]=rand(A);}return ret;}\ntemplate<class T> vector<T> ranv_unique(vector<T>& A, int N){    vector<T> ret(N);    umapi was;    rep(j,N){        int i;        while(1){            i = rand(sz(A)-1);            if(was.find(i) == was.end())break;        }        ret[j] = A[i];was[i]=1;    }    return ret;}\nvi ranv(ll n, ll min, ll max) {    vi v(n);    rep(i, n)v[i] = rand(min, max);    return v;}\nstr ransu(ll n) {    str s;    rep(i, n)s += (char) rand('A', 'Z');    return s;}\nstr ransl(ll n) {    str s;    rep(i, n)s += (char) rand('a', 'z');    return s;}\n//単調増加\nvi ranvinc(ll n, ll min, ll max) {    vi v(n);    bool bad = 1;    while (bad) {        bad = 0;        v.resize(n);        rep(i, n) {            if (i && min > max - v[i - 1]) {                bad = 1;                break;            }            if (i)v[i] = v[i - 1] + rand(min, max - v[i - 1]); else v[i] = rand(min, max);        }    }    return v;}\n//便利 汎用\n\nvoid ranvlr(ll n, ll min, ll max, vi &l, vi &r) {    l.resize(n);    r.resize(n);    rep(i, n) {        l[i] = rand(min, max);        r[i] = l[i] + rand(0, max - l[i]);    }}\ntemplate<class T>vector<pair<T,int>> run_length(vector<T> &a) {vector<pair<T,int>> ret;ret.eb(a[0], 1);rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}return ret;}\nvector<pair<char, ll>> run_length(string &a) {    vector<pair<char, ll>> ret;    ret.eb(a[0], 1);    rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}    return ret;}\ntemplate<class T, class F> T mgr(T ok, T ng, F f, int deb_ = 0) {    bool han = true;    if (deb_) {        if (ok < ng)            while (ng - ok > 1) {                T mid = (ok + ng) >> 1;                if (f(mid))ok = mid, han = true; else ng = mid, han = false;                deb(mid, han);            }        else            while (ok - ng > 1) {                T mid = (ok + ng) >> 1;                if (f(mid))ok = mid, han = true; else ng = mid, han = false;                deb(mid, han);            }    }else{        if (ok < ng)            while (ng - ok > 1) {                T mid = (ok + ng) >> 1;                if (f(mid))ok = mid, han = true; else ng = mid, han = false;            }        else            while (ok - ng > 1) {                T mid = (ok + ng) >> 1;                if (f(mid))ok = mid, han = true; else ng = mid, han = false;            }    }    return ok;}\ntemplate<class T, class F> T mgr(signed ok, T ng, F f) {    return mgr((T)ok, ng, f);}\ntemplate<class T, class F> T mgr(T ok, signed ng, F f) {    return mgr(ok, (T)ng, f);}\ntemplate<class F> int mgr(signed ok, signed ng, F f) {    return mgr((ll)ok, (ll)ng, f);}\n//[l, r)の中で,f(i)がtrueとなる範囲を返す okはそこに含まれる\ntemplate<class F> P mgr(int l, int r, F f, int ok) {    if (f(ok) == 0) {        out(\"f(ok) must true\");        re();    }    return mp(mgr(ok, l - 1, f), mgr(ok, r, f) + 1);}\n\ntemplate<class F> dou mgrd(dou ok, dou ng, F f,int kai=100) {\n    bool han = true;\n    if (ok < ng)\n        rep(i,kai) {\n            dou mid = (ok + ng) /2;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            deb(mid,han);\n        }\n    else\n        rep(i,kai) {\n            dou mid = (ok + ng) /2;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            deb(mid,han);\n        }\n    return ok;\n}\n//strを整数として比較\nstring smax(str &a, str b) {    if (sz(a) < sz(b)) { return b; }    else if (sz(a) > sz(b)) { return a; }    else if (a < b)return b;    else return a;}\n//strを整数として比較\nstring smin(str &a, str b) {    if (sz(a) > sz(b)) { return b; }    else if (sz(a) < sz(b)) { return a; }    else if (a > b)return b;    else return a;}\n//エラー-1\ntemplate<typename W, typename T> ll find(vector<W> &a, int l, const T key) {rep(i, l, sz(a))if (a[i] == key)return i;return -1;}\ntemplate<typename W, typename T> ll find(vector<W> &a, const T key) {    rep(i, sz(a))if (a[i] == key)return i;    return -1;}\ntemplate<typename W, typename T> P find(vector<vector<W >> &a, const T key) {    rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return mp(i, j);    return mp(-1, -1);}\n//getid(find())を返す 1次元にする\ntemplate<typename W, typename T> int findi(vector<vector<W >> &a, const T key) {    rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return i*sz(a[0])+j;    return -1;}\ntemplate<typename W, typename U> T find(vector<vector<vector<W >>> &a, const U key) {    rep(i, sz(a))rep(j, sz(a[0]))rep(k, sz(a[0][0]))if (a[i][j][k] == key)return mt(i, j, k);    return mt(-1, -1, -1);}\n//stringも書く\nint find(string& s, const string key){    int klen = sz(key);    rep(i,sz(s)-klen+1){        if(s[i]!=key[0])continue;        if(s.substr(i,klen) == key){            return i;        }    }    return -1;}\nint find(string& s, int l, const string key){    int klen = sz(key);    rep(i, l, sz(s)-klen+1){        if(s[i]!=key[0])continue;        if(s.substr(i,klen) == key){            return i;        }    }    return -1;}\nint find(string& s, const char key){    rep(i,sz(s)){        if(s[i]==key)return i;    }    return -1;}\nint find(string& s, int l, const char key){    rep(i, l, sz(s)){        if(s[i]==key)return i;    }    return -1;}\ntemplate<typename W, typename T> ll count2(W &a, const T k) { return a == k; }\ntemplate<typename W, typename T> ll count2(vector<W> &a, const T k) {    ll ret = 0;    fora(v, a)ret += count2(v, k);    return ret;}\ntemplate<typename W, typename T> ll count(vector<W> &a, const T k) {    ll ret = 0;    fora(v, a)ret += count2(v, k);    return ret;}\nvi count(vi &a) {    int ma = 0;    fora(v, a) {        if (ma < v)ma = v;    }    vi res(ma + 1);    fora(v, a) {        res[v]++;    }    return res;}\nll count(str &a, str k) {    ll ret = 0, len = k.length();    auto pos = a.find(k);    while (pos != string::npos)pos = a.find(k, pos + len), ++ret;    return ret;}\n//'a' = 'A' = 0 として集計 既に-'a'されていても動く\nvi count(str &a, int l, int r) {    vi cou(26);    char c = 'a';    if ('A' <= a[l] && a[l] <= 'Z')c = 'A';    if ('a' <= a[l] && a[l] <= 'z') c = 'a'; else c = 0;    rep(i, l, r)++cou[a[i] - c];    return cou;}\nvi count(str &a, int r = inf){return count(a, 0, min(r, sz(a)));}\n#define couif count_if\n//algorythm\nll rev(ll a) {    ll res = 0;    while (a) {        res *= 10;        res += a % 10;        a /= 10;    }    return res;}\ntemplate<class T> auto rev(vector<T> &a) {auto b= a; reverse(all(b)); return b;}\n/* ＼反転  */                                                                                        template<class U>\nauto rev(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a[0]), vector<U>(sz(a)));    rep(h, sz(a)) rep(w, sz(a[0]))b[w][h] = a[h][w];    return b;}\n\n/* ｜反転  */                                                                                        template<class U>\nauto revw(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a), vector<U>(sz(a[0])));    int W = sz(a[0]);    rep(h, sz(a)) rep(w, sz(a[0])){            b[h][W-1-w] = a[h][w];        }    return b;}\n\n/* ー反転  */                                                                                        template<class U>\nauto revh(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a), vector<U>(sz(a[0])));    int H = sz(a);    rep(h, sz(a)) rep(w, sz(a[0])){        b[H-1-h][w] = a[h][w];    }    return b;}\n\n/* ／反転  */                                                                                        template<class U>\nauto revr(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a[0]), vector<U>(sz(a)));   int H = sz(a);int W = sz(a[0]); rep(h, sz(a)) rep(w, sz(a[0]))b[w][h] = a[H-1-h][W-1-w];    return b;}\n\nauto  rev(string &a) { string b = a; reverse(all(b));return b; }\nconstexpr ll p10[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000ll, 100000000000ll, 1000000000000ll, 10000000000000ll, 100000000000000ll, 1000000000000000ll, 10000000000000000ll, 100000000000000000ll, 1000000000000000000ll};\n\n//0は0桁\nll keta(ll v) {    if (v < p10[9]) { if (v < p10[4]) { if (v < p10[2]) { if (v < p10[1]) { if (v < p10[0])return 0; else return 1; } else return 2; } else { if (v < p10[3]) return 3; else return 4; }} else { if (v < p10[7]) { if (v < p10[5]) return 5; else if (v < p10[6])return 6; else return 7; } else { if (v < p10[8])return 8; else return 9; }}}    else {        if (v < p10[13]) { if (v < p10[11]) { if (v < p10[10]) return 10; else return 11; } else { if (v < p10[12]) return 12; else return 13; }}        else {            if (v < p10[15]) {                if (v < p10[14]) return 14;                else return 15;            } else {                if (v < p10[17]) {                    if (v < p10[16]) return 16;                    else return 17;                } else {                    if (v < p10[18])return 18;                    else return 19;                }            }        }    }}\nll getr(ll a, ll keta) { return (a / (ll) pow(10, keta)) % 10; }\n//上から何桁目か\nll getl(ll a, ll ket) {int sketa = keta(a);return getr(a,sketa-1-ket);}\nll dsum(ll v,ll sin=10) {    ll ret = 0;    for (; v; v /= sin)ret += v % sin;    return ret;}\n\nll mask10(ll v) { return p10[v] - 1; }\n//変換系\n//[v] := iとなるようなvectorを返す\n//存在しない物は-1\ntemplate<class T> auto keys(T a) {    vector<decltype((a.begin())->fi)> res;    for (auto &&k :a)res.push_back(k.fi);    return res;}\ntemplate<class T> auto values(T a) {    vector<decltype((a.begin())->se)> res;    for (auto &&k :a)res.push_back(k.se);    return res;}\ntemplate<class T, class U>  bool chma(T &a, const U &b) {    if (a < b) {        a = b;        return true;    }    return false;}\ntemplate<class T, class U>  bool chmi(T &a, const U &b) {    if (b < a) {        a = b;        return true;    }    return false;}\ntemplate<class T> constexpr T min(T a, signed b) { return a < b ? a : b; }\ntemplate<class T> constexpr  T max(T a, signed b) { return a < b ? b : a; }\ntemplate<class T> constexpr  T min(T a, T b, T c) { return a >= b ? b >= c ? c : b : a >= c ? c : a; }\ntemplate<class T> constexpr  T max(T a, T b, T c) { return a <= b ? b <= c ? c : b : a <= c ? c : a; }\ntemplate<class T>  T min(vector<T>& a) { return *min_element(all(a)); }\ntemplate<class T>  T mini(vector<T>& a) { return min_element(all(a)) - a.begin(); }\ntemplate<class T>  T min(vector<T>& a, ll n) { return *min_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T>  T min(vector<T>& a, ll s, ll n) { return *min_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<class T>  T max(vector<T>& a) { return *max_element(all(a)); }\ntemplate<class T,class U>  T max(vector<T>& a,vector<U>& b) { return max(*max_element(all(a)),*max_element(all(b))); }\ntemplate<class T>  T maxi(vector<T>& a) { return max_element(all(a)) - a.begin(); }\ntemplate<class T>  T max(vector<T>& a, ll n) { return *max_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T>  T max(vector<T>& a, ll s, ll n) { return *max_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<typename A, size_t N> A max(A (&a)[N]) {    A res = a[0];    rep(i, N)res = max(res, a[i]);    return res;}template<typename A, size_t N, size_t O> A max(A (&a)[N][O]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P> A max(A (&a)[N][O][P]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A max(A (&a)[N][O][P][Q], const T &v) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A max(A (&a)[N][O][P][Q][R]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A max(A (&a)[N][O][P][Q][R][S]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}\ntemplate<typename A, size_t N> A min(A (&a)[N]) {    A res = a[0];    rep(i, N)res = min(res, a[i]);    return res;}template<typename A, size_t N, size_t O> A min(A (&a)[N][O]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P> A min(A (&a)[N][O][P]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A min(A (&a)[N][O][P][Q], const T &v) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A min(A (&a)[N][O][P][Q][R]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A min(A (&a)[N][O][P][Q][R][S]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}\ntemplate<class T> T sum(vector<T> &v, ll s, ll t) {    T ret = 0;    rep(i, s, min(sz(v), t))ret += v[i];    return ret;}\ntemplate<class T> T sum(vector<T> &v, ll t = inf) { return sum(v, 0, t); }\ntemplate<class T> T sum(vector<vector<T> > &v, int s, int t) {T ret = 0;rep(i, s, min(sz(v), t))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<T> > &v, int t = inf) { return sum(v, 0, t); }\ntemplate<class T> T sum(vector<vector<vector<T>> > &v, int s, int t) {T ret = 0;rep(i, s, min(sz(v), t))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<vector<T>> > &v, int t = inf) { return sum(v, 0, t); }\ntemplate<class T> T sum(vector<vector<vector<vector<T>>> > &v, int s, int t) {T ret = 0;rep(i, s, min(sz(v), t))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<vector<vector<T>>> > &v, int t = inf) { return sum(v, 0, t); }\ntemplate<class T> T sum(vector<vector<vector<vector<vector<T>>>> > &v, int s, int t) {T ret = 0;rep(i, s, min(sz(v), t))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<vector<vector<vector<T>>>> > &v, int t = inf) { return sum(v, 0, t); }\n\ntemplate<class T> auto sum(priority_queue<T, vector<T>, greater<T> > &r) {    auto q = r;    T ret = 0;    while (sz(q)) {        ret += q.top();        q.pop();    }    return ret;}\ntemplate<class T> auto sum(priority_queue<T> &r) {    auto q = r;    T ret = 0;    while (sz(q)) {        ret += q.top();        q.pop();    }    return ret;}\ntemplate<class T> T mul(vector<T> &v, ll t = inf) {    T ret = v[0];    rep(i, 1, min(t, sz(v)))ret *= v[i];    return ret;}\n\n//template<class T, class U, class... W>  auto sumn(vector<T> &v, U head, W... tail) {    auto ret = sum(v[0], tail...);    rep(i, 1, min(sz(v), head))ret += sum(v[i], tail...);    return ret;}\nvi v_i(vi &a) {    int n = max(a) + 1;    vi ret(n, -1);    rep(i, sz(a)) {        ret[a[i]] = i;    }    return ret;}\nvoid clear(PQ &q) { q = PQ(); }\nvoid clear(priority_queue<int>&q) { q = priority_queue<int>();}\ntemplate<class T> void clear(queue<T> &q) { while (q.size())q.pop(); }\ntemplate<class T> T *negarr(ll size) {    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));    return body + size;}\ntemplate<class T> T *negarr2(ll h, ll w) {    double **dummy1 = new double *[2 * h + 1];    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];    dummy1[0] = dummy2 + w;    for (ll i = 1; i <= 2 * h + 1; ++i) { dummy1[i] = dummy1[i - 1] + 2 * w + 1; }    double **a = dummy1 + h;    return a;}\n//imoは0-indexed\n//ruiは1-indexed\ntemplate<class T> vector<T> imo(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    return ret;}\n//kと同じものの数\ntemplate<class T, class U> vi imo(vector<T> &a, U k) {vector<T> ret = a;rep(i, sz(ret))ret[i] = a[i] == k;rep(i, sz(ret) - 1)ret[i + 1] += ret[i];return ret;}\ntemplate<class T> vector<T> imox(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] ^= ret[i];    return ret;}\n//漸化的に最小を持つ\ntemplate<class T> vector<T> imi(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chmi(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> ima(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chma(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> rimi(vector<T> &v) {    vector<T> ret = v;    rer(i, sz(ret) - 1, 1)chmi(ret[i - 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> rima(vector<T> &v) {    vector<T> ret = v;    rer(i, sz(ret) - 1, 1)chma(ret[i - 1], ret[i]);    return ret;}\ntemplate<class T> struct ruiC {\n    vector<T> rui;\n    ruiC(vector<T> &ru) : rui(ru) {}\n    /*先頭0*/\n    ruiC() : rui(1, 0) {}\n    T operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruic \";            deb(l, r);            assert(0);        }        return rui[r] - rui[l];    }\n    T operator()(int r = inf) { return operator()(0, min(r, sz(rui)-1)); }\n    /*ruiv[]をruic[]に変えた際意味が変わるのがまずいため()と統一*/\n    /*単体iを返す 累積でないことに注意(seg木との統一でこうしている)*/\n//    T operator[](ll i) { return rui[i + 1] - rui[i]; }\n    T operator[](ll i) { return rui[i]; }\n    /*0から順に追加される必要がある*/\n    void operator+=(T v) { rui.push_back(rui.back() + v); }\n    void add(int i, T v) {if (sz(rui) - 1 != i)ole();operator+=(v);}\n    T back() { return rui.back(); }\n    ll size() { return rui.size(); }\n    auto begin(){return rui.begin();}\n    auto end(){return rui.end();}\n};\ntemplate<class T> struct ruimax {template<typename Monoid>struct SegmentTree {        /*pairで処理*/        int sz;        vector<Monoid> seg;        const Monoid M1 = mp(MIN(T), -1);        Monoid f(Monoid a, Monoid b) {            return max(a, b);        }        void build(vector<T> &a) {            int n = sz(a);            sz = 1;            while (sz < n) sz <<= 1;            seg.assign(2 * sz, M1);            rep(i, n) { seg[i + sz] = mp(a[i], i); }            for (int k = sz - 1; k > 0; k--) {                seg[k] = f(seg[k << 1], seg[(k << 1) | 1]);            }        }        Monoid query(int a, int b) {            Monoid L = M1, R = M1;            for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {                if (a & 1) L = f(L, seg[a++]);                if (b & 1) R = f(seg[--b], R);            }            return f(L, R);        }        Monoid operator[](const int &k) const {            return seg[k + sz];        }    };private:vector<T> ve;SegmentTree<pair<T, int>> seg;vector<T> rv;vector<T> ri;bool build = false;\npublic:\n    int n;\n    ruimax(vector<T> &a) : ve(a), n(sz(a)) {        int index = -1;        int ma = MIN(T);        rv.resize(n + 1);        ri.resize(n + 1);        rv[0] = -linf;        ri[0] = -1;        rep(i, n) {            if (chma(ma, a[i])) {                index = i;            }            rv[i + 1] = ma;            ri[i + 1] = index;        }    }\n    T operator()(int l, int r) {        if (!(l <= r && 0 <= l && r <= n)) {            deb(l, r, n);            assert(0);        }        if (l == 0) {            return rv[r];        } else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).first;        }    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) {        return operator()(0, r);    }\n    T getv(int l, int r) {        return operator()(l, r);    }\n    T geti(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) {            return ri[r];        } else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).second;        }    }\n    T geti(int r = inf) { return geti(0, min(r,n)); };\n    T getv(int r = inf) { return getv(0, min(r,n)); };\n    auto begin(){return rv.begin();}\n    auto end(){return rv.end();}\n};\ntemplate<class T> struct ruimin {template<typename Monoid>    struct SegmentTree {  /*pairで処理*/         int sz;        vector<Monoid> seg;        const Monoid M1 = mp(MAX(T), -1);        Monoid f(Monoid a, Monoid b) {            return min(a, b);        }        void build(vector<T> &a) {            int n = sz(a);            sz = 1;            while (sz < n) sz <<= 1;            seg.assign(2 * sz, M1);            rep(i, n) { seg[i + sz] = mp(a[i], i); }            for (int k = sz - 1; k > 0; k--) {                seg[k] = f(seg[k << 1], seg[(k << 1) | 1]);            }        }        Monoid query(int a, int b) {            Monoid L = M1, R = M1;            for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {                if (a & 1) L = f(L, seg[a++]);                if (b & 1) R = f(seg[--b], R);            }            return f(L, R);        }        Monoid operator[](const int &k) const {            return seg[k + sz];        }    };private:vector<T> ve;SegmentTree<pair<T, int>> seg;vector<T> rv;vector<T> ri;bool build = false;int n;\npublic:\n    ruimin(vector<T> &a) : ve(a), n(sz(a)) {        int index = -1;        int mi = MAX(T);        rv.resize(n + 1);        ri.resize(n + 1);        rv[0] = linf;        ri[0] = -1;        rep(i, n) {            if (chmi(mi, a[i])) {                index = i;            }            rv[i + 1] = mi;            ri[i + 1] = index;        }    }\n    T operator()(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) {            return rv[r];        } else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).first;        }    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) {return operator()(0, r);}\n    T getv(int l, int r) {        return operator()(l, r);    }\n    T geti(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) {            return ri[r];        } else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).second;        }    }\n    T geti(int r = inf) { return geti(0, min(r,n)); };\n    T getv(int r = inf) { return getv(0, min(r,n)); };\n    auto begin(){return rv.begin();}\n    auto end(){return rv.end();}\n};\n\ntemplate<class T>ostream &operator<<(ostream &os, ruiC<T> a) {fora(v,a.rui)os<<v<<\" \";return os;}\ntemplate<class T> vector<T> ruiv(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i];    return ret;}\ntemplate<class T> ruiC<T> ruic() {return ruiC<T>();}\ntemplate<class T> ruiC<T> ruic(vector<T> &a) {    vector<T> ret = ruiv(a);    return ruiC<T>(ret);}\nvvi() ruib(vi &a) {    vvi(res, 61, sz(a) + 1);    rep(k, 61) {        rep(i, sz(a)) {            res[k][i + 1] = res[k][i] + ((a[i] >> k) & 1);        }    }    return res;}\nvector<ruiC<int>> ruibc(vi &a) {    vector<ruiC<int>> ret(61);    vvi(res, 61, sz(a));    rep(k, 61) {        rep(i, sz(a)) {            res[k][i] = (a[i] >> k) & 1;        }        ret[k] = ruic(res[k]);    }    return ret;}\nvector<ll> ruiv(string &a) {    if (sz(a) == 0)return vi(1);    ll dec = ('0' <= a[0] && a[0] <= '9') ? '0' : 0;    vector<ll> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i] - dec;    return ret;}\nruiC<ll> ruic(string &a) {    vector<ll> ret = ruiv(a);    return ruiC<ll>(ret);}\n//kと同じものの数\ntemplate<class T, class U> vi ruiv(T &a, U k) {    vi ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + (a[i] == k);    return ret;}\ntemplate<class T, class U> ruiC<ll> ruic(T &a, U k) {    vi ret = ruiv(a, k);    return ruiC<ll>(ret);}\ntemplate<class T> struct ruiC2 {\n    int H;\n    vector<ruiC<T>> rui;\n    ruiC2(vector<vector<T>> &ru) : rui(sz(ru)),H(sz(ru)) {        for (int h = 0; h < H; h++){            rui[h] = ruic(ru[h]);        }    }\n    //WについてHを返す\n    vector<T> operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruic \";            deb(l, r);            assert(0);        }        vector<T> res(H);        for (int h = 0; h < H; h++)res[h]=rui[h](l, r);        return res;    }\n    //HについてWを返す\n    ruiC<T> operator[](ll h){ assert(h<H);return rui[h]; }\n    //    vector<T> operator()(int r) { return operator()(0, r); }\n    /*ruiv[]をruic[]に変えた際意味が変わるのがまずいため()と統一*/\n    /*単体iを返す 累積でないことに注意(seg木との統一でこうしている)*/\n//    T operator[](ll i) { return rui[i + 1] - rui[i]; }\n    /*0から順に追加される必要がある*/\n//    T back() { return rui.back(); }\n//    ll size() { return rui.size(); }\n//    auto begin(){return rui.begin();}\n//    auto end(){return rui.end();}\n};\n\n//a~zを0~25として\n// rui(l,r)でvector(26文字について, l~rのcの個数)\n// rui[h] ruic()を返す\nruiC2<ll> ruicou(str &a) {    str s = a;    replace(s);    vector<ruiC<ll>> res(26);    vvi(cou, 26, sz(s));    rep(i, sz(s)) { cou[s[i]][i] = 1; }    return ruiC2<ll>(cou);}\nruiC2<ll> ruicou(vi &a) {    int H = max(a) + 1;    vector<ruiC<ll>> res(H);    vvi(cou, H, sz(a));    rep(i, sz(a)) { cou[a[i]][i] = 1; }    return ruiC2<ll>(cou);}\ntemplate<class T, class U>ruiC<ll> ruicou(vector<T>& a, U b){    vi cou(sz(a));    rep(i,sz(a)){        cou[i] = a[i]==b;    }    return ruic(cou);}\n//h query\ntemplate<class T> vector<T> imoh(vector<vector<T>> &v, int w) {vector<T> ret(sz(v));rep(h,sz(ret)){ret[h] = v[h][w];}rep(i, sz(ret) - 1){ret[i + 1] += ret[i];}return ret;}\ntemplate<class T> vector<T> ruih(vector<vector<T>> &v, int w) {vector<T> ret(sz(v) + 1);rep(h, sz(v)) { ret[h + 1] = v[h][w]; }rep(i, sz(v)) { ret[i + 1] += ret[i]; }return ret;}\ntemplate<class T> ruiC<T> ruihc(vector<vector<T>> &a, int w) {vector<T> ret = ruih(a, w);return ruiC<T>(ret);}\n\n//xor\ntemplate<class T> struct ruixC {    vector<T> rui;    ruixC(vector<T> &ru) : rui(ru) {}    T operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruiXc \";            deb(l, r);            assert(0);        }        return rui[r] ^ rui[l];    }    T operator[](ll i) { return rui[i]; }    T back() { return rui.back(); }    ll size() { return rui.size(); }};\ntemplate<class T> vector<T> ruix(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] ^ a[i];    return ret;}\ntemplate<class T> ruixC<ll> ruixc(vector<T>  &a) {vi ret = ruix(a);return ruixC<ll>(ret);}\ntemplate<class T> vector<T> ruim(vector<T> &a) {    vector<T> res(a.size() + 1, 1);    rep(i, a.size())res[i + 1] = res[i] * a[i];    return res;}\n//漸化的に最小を1indexで持つ\ntemplate<class T> vector<T> ruimi(vector<T> &a) {    ll n = sz(a);    vector<T> ret(n + 1);    rep(i, 1, n) {        ret[i] = a[i - 1];        chmi(ret[i + 1], ret[i]);    }    return ret;}\n//template<class T> T *rrui(vector<T> &a) {\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> struct rruiC {\n    vector<T> rui;\n    int n;\n    rruiC(vector<T> &a) : n(sz(a)) {rui.resize(n + 1);rer(i, n - 1) {rui[i] = rui[i + 1] + a[i];}}\n    /*[r l)*/\n    T operator()(int r, int l) {r++;l++;assert(l <= r && l >= 0 && r <= n);return rui[l] - rui[r];}\n    T operator()(int l) {return operator()(n - 1, l);}\n    T operator[](int i) {return operator()(i);}\n};\ntemplate<class T> ostream &operator<<(ostream &os, rruiC<T> a) {fora(v, a.rui)os << v << \" \";return os;}\n\n#define rrui rruic\ntemplate<class T> rruiC<T> rruic(vector<T> &a) { return rruiC<T>(a); }\n\n//掛け算\ntemplate<class T> struct ruimulC {\n    vector<T> rv;\n    int n;\n    ruimulC(vector<T> &a) : rv(a), n(sz(a)) {rv.resize(n + 1);rv[0] = 1;rep(i, n) { rv[i + 1] = a[i] * rv[i]; }}\n    ruimulC() : n(0) {rv.resize(n + 1);rv[0] = 1;}\n    void operator+=(T v) {rv.push_back(rv.back()*v);n++;}\n    T operator()(int l, int r) {assert(l <= r && 0 <= l && r <= n);return rv[r] / rv[l];}\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) { return operator()(0, r); }\n    auto begin() { return rv.begin(); }\n    auto end() { return rv.end(); }\n};\ntemplate<class T> ruimulC<T> ruimul(vector<T> &a) { return ruimulC<T>(a); }\ntemplate<class T> ruimulC<T> ruimul() {vector<T> a; return ruimulC<T>(a); }\n/*@formatter:off*/\ntemplate<class T> T *rruim(vector<T> &a) {    ll len = a.size();    T *body = (T *) malloc((len + 1) * sizeof(T));    T *res = body + 1;    res[len - 1] = 1;    rer(i, len - 1)res[i - 1] = res[i] * a[i];    return res;}\ntemplate<class T, class U> void inc(pair<T,U> &a, U v = 1) { a.first += v,a.second+=v; }\ntemplate<class T, class U> void inc(T &a, U v = 1) { a += v; }\ntemplate<class T, class U = int> void inc(vector<T> &a, U v = 1) { for (auto &u:a)inc(u, v); }\ntemplate<class T, class U> void dec(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U = int> void dec(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class U> void dec(string &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T,class U, class W> void dec(vector<T> &a,vector<U> &b, W v = 1) { for (auto &u :a)dec(u, v);for (auto &u :b)dec(u, v); }\ntemplate<class T,class U,class W> void dec(vector<T> &a,vector<U> &b,vector<W>&c ) { for (auto &u :a)dec(u, 1);for (auto &u :b)dec(u, 1);for (auto &u :c)dec(u, 1); }\nbool ins(ll h, ll w, ll H, ll W) { return h >= 0 && w >= 0 && h < H && w < W; }\nbool san(ll l, ll v, ll r) { return l <= v && v < r; }\ntemplate<class T> bool ins(vector<T> &a, ll i, ll j = 0) { return san(0, i, sz(a)) && san(0, j, sz(a)); }\n#define inside ins\nll u(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u(vector<T> &a) {    vector<T> ret = a;    fora(v, ret)v = u(v);    return ret;}\n\n//添え字を返す\ntemplate<class F> ll goldd_l(ll left, ll right, F calc) {    double GRATIO = 1.6180339887498948482045868343656;    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));    ll fl = calc(lm);    ll fr = calc(rm);    while (right - left > 10) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + (ll) ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    ll minScore = MAX(ll);    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (minScore > score) {            minScore = score;            resIndex = i;        }    }    return resIndex;}\ntemplate<class F> ll goldt_l(ll left, ll right, F calc) {        double GRATIO = 1.6180339887498948482045868343656;        ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));        ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));        ll fl = calc(lm);        ll fr = calc(rm);        while (right - left > 10) {            if (fl > fr) {                right = rm;                rm = lm;                fr = fl;                lm = left + (ll) ((right - left) / (GRATIO + 1.0));                fl = calc(lm);            } else {                left = lm;                lm = rm;                fl = fr;                rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));                fr = calc(rm);            }        }    if (left > right) {        ll l = left;        left = right;        right = l;    }    ll maxScore = MIN(ll);    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (maxScore < score) {            maxScore = score;            resIndex = i;        }    }    return resIndex;}\n/*loopは200にすればおそらく大丈夫 余裕なら300に*/\ntemplate<class F> dou goldd_d(dou left, dou right, F calc, ll loop = 200) {    dou GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    /*200にすればおそらく大丈夫*/    /*余裕なら300に*/    ll k = 141;    loop++;    while (--loop) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return left;}\ntemplate<class F> dou goldt_d(dou left, dou right, F calc, ll loop = 200) {    double GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    loop++;    while (--loop) {        if (fl > fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return left;}\n//l ~ rを複数の区間に分割し、極致を与えるiを返す time-20 msまで探索\ntemplate<class F> ll goldd_ls(ll l, ll r, F calc, ll time = 2000) {    auto lim = milliseconds(time - 20);    ll mini = 0, minv = MAX(ll);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldd_l(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return mini;}\ntemplate<class F> ll goldt_ls(ll l, ll r, F calc, ll time = 2000) {    auto lim = milliseconds(time - 20);    ll maxi = 0, maxv = MIN(ll);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldt_l(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return maxi;}\ntemplate<class F> dou goldd_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を持つ*/    auto lim = milliseconds(time - 20);    dou mini = 0, minv = MAX(dou);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldd_d(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return mini;}\ntemplate<class F> dou goldt_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を残している*/    auto lim = milliseconds(time - 20);    dou maxi = 0, maxv = MIN(dou);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldt_d(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return maxi;}\ntemplate<class T> T min(vector<vector<T >> &a) {    T res = MAX(T);    rep(i, a.size())chmi(res, *min_element(all(a[i])));    return res;}\ntemplate<class T> T max(vector<vector<T >> &a) {    T res = MIN(T);    rep(i, a.size())chma(res, *max_element(all(a[i])));    return res;}\ntemplate<class T> T min(vector<vector<vector<T>>> &a) {    T res = MAX(T);    rep(i, a.size())chmi(res, min(a[i]));    return res;}\ntemplate<class T> T max(vector<vector<vector<T>>> &a) {    T res = MIN(T);    rep(i, a.size())chma(res, max(a[i]));    return res;}\ntemplate<class T> T min(vector<vector<vector<vector<T>>>> &a) {    T res = MAX(T);    rep(i, a.size())chmi(res, min(a[i]));    return res;}\ntemplate<class T> T max(vector<vector<vector<vector<T>>>> &a) {    T res = MIN(T);    rep(i, a.size())chma(res, max(a[i]));    return res;}\ntemplate<class T> T min(vector<vector<vector<vector<vector<T>>>>> &a) {    T res = MAX(T);    rep(i, a.size())chmi(res, min(a[i]));    return res;}\ntemplate<class T> T max(vector<vector<vector<vector<vector<T>>>>> &a) {    T res = MIN(T);    rep(i, a.size())chma(res, max(a[i]));    return res;}\ntemplate<class T> T min(vector<vector<vector<vector<vector<vector<T>>>>>> &a) {    T res = MAX(T);    rep(i, a.size())chmi(res, min(a[i]));    return res;}\ntemplate<class T> T max(vector<vector<vector<vector<vector<vector<T>>>>>> &a) {    T res = MIN(T);    rep(i, a.size())chma(res, max(a[i]));    return res;}\n//pow周りの仕様\n//powiを使うと整数型\n//powbを使うとbint型\n//powを使うと powlに変換され long doubleが返る\n#ifdef _DEBUG\n//整数値の場合はpowiを使った方がいいというメッセージを出すための物\nauto my_powl(ll a, ll k){return powl(a,k);}\nauto pow(ll a,ll k){    static bool was = 1;    if(was){message +=\"if integer use *powi* it's very fast\\n\";}    was=0;    return my_powl(a,k);}\n//上のメッセージを出すための関数\nauto pow(signed a,ll k){    return pow((ll)a,k);}\nauto pow(signed a,signed k){    return pow((ll)a,(ll)k);}\n#endif\n\n//整数型のpow\nint powi(int a, int k) {    if (a == 2)return 1ll << k;    int res = 1;    int x = a;    while (k) {        if(k & 1)res *= x;        x *= x;        k >>= 1;    }    return res;}\n//define pow powlより上に動かすとバグる\nbint pow(bint a, ll k) {    bint res = 1;    bint x = a;    while (k) {        if(k & 1)res *= x;        x *= x;        k >>= 1;    }    return res;}\nbint pow(bint a, signed k) {return pow(a,(ll)k);}\nbint powb(int a, int b){return pow((bint)a,b);}\nconstexpr bool bget(ll m, ll keta) {\n    #ifdef _DEBUG\n        assert(keta<=62);//オーバーフロー 1^62までしか扱えない\n    #endif\n    return (m >> keta) & 1; }\n//bget(n)次元\n//                          NならN-1まで\nvector<vi> bget2(vi& a,int keta_size){    vvi(res,keta_size,sz(a));    rep(k,keta_size){        rep(i, sz(a)){            res[k][i]=bget(a[i],k);        }    }    return res;}\nvi bget1(vi& a,int keta){    vi res(sz(a));    rep(i, sz(a)){        res[i]=bget(a[i],keta);    }    return res;}\nll bget(ll m, ll keta, ll sinsuu) {    m /= (ll) pow(sinsuu, keta);    return m % sinsuu;}\nconstexpr ll bit(ll n) {\n    #ifdef _DEBUG\n        assert(n<=62);//オーバーフロー 1^62までしか扱えない\n    #endif\n    return (1LL << (n)); }\nll bit(ll n, ll sinsuu) { return (ll) pow(sinsuu, n); }\nll mask(ll n) { return (1ll << n) - 1; }\n//aをbitに置きなおす\n//{0, 2} -> 101\nll bit(vi&a){    int m=0;    for(auto&& v:a) m|=bit(v);    return m;}\n\n//{1, 1, 0} -> 011\n//bitsetに置き換える感覚 i が立っていたら i bit目を立てる\nll bit_bool(vi&a){    int m=0;    rep(i,sz(a)) if(a[i])m|=bit(i);    return m;}\n#define bcou __builtin_popcountll\n//最下位ビット\nll lbit(ll n) { return n & -n; }\nll lbiti(ll n) { return log2(n & -n); }\n//最上位ビット\nll hbit(ll n) {    n |= (n >> 1);    n |= (n >> 2);    n |= (n >> 4);    n |= (n >> 8);    n |= (n >> 16);    n |= (n >> 32);    return n - (n >> 1);}\nll hbiti(ll n){return log2(hbit(n));}\nll hbitk(ll n) {    ll k = 0;    rer(i, 5) {        ll a = k + (1ll << i);        ll b = 1ll << a;        if (b <= n)k += 1ll << i;    }    return k;}\n//初期化は0を渡す\nll nextComb(ll &mask, ll n, ll r) {    if (!mask)return mask = (1LL << r) - 1;    ll x = mask & -mask; /*最下位の1*/    ll y = mask + x; /*連続した下の1を繰り上がらせる*/    ll res = ((mask & ~y) / x >> 1) | y;    if (bget(res, n))return mask = 0; else return mask = res;}\n//n桁以下でビットがr個立っているもののvectorを返す\nvi bitCombList(ll n, ll r) {    vi res;    ll m = 0;    while (nextComb(m, n, r)) { res.push_back(m); }    return res;}\n/*over*/#define forbit1_2(i, mas) for (int forbitj = lbit(mas), forbitm = mas, i = log2(forbitj); forbitm; forbitm = forbitj ? forbitm ^ forbitj : 0, forbitj = lbit(forbitm), i = log2(forbitj))\n/*over*/#define forbit1_3(i, N, mas) for (int forbitj = lbit(mas), forbitm = mas, i = log2(forbitj); forbitm && i < N; forbitm = forbitj ? forbitm ^ forbitj : 0, forbitj = lbit(forbitm), i = log2(forbitj))\n//masの立ってるindexを見る\n//              i, [N], mas\n#define forbit1(...) over3(__VA_ARGS__, forbit1_3, forbit1_2)(__VA_ARGS__)\n//masが立っていないindexを見る\n//              i, N, mas\n#define forbit0(i, N, mas) forbit1(i, mask(N) & (~(mas)))\n\n\n\n//aにある物をtrueとする\nvb bool_(vi&a,int n){    vb ret(max(max(a)+1,n));    rep(i,sz(a))ret[a[i]] = true;    return ret;}\n\nchar itoal(ll i) { return 'a' + i; }\nchar itoaL(ll i) { return 'A' + i; }\nll altoi(char c) {    if ('A' <= c && c <= 'Z')return c - 'A';    return c - 'a';}\nll ctoi(char c) { return c - '0'; }\nchar itoc(ll i) { return i + '0'; }\nll vtoi(vi &v) {    ll res = 0;    if (sz(v) > 18) {        debugline(\"vtoi\");        deb(sz(v));        ole();    }    rep(i, sz(v)) {        res *= 10;        res += v[i];    }    return res;}\nvi itov(ll i) {    vi res;    while (i) {        res.push_back(i % 10);        i /= 10;    }    res = rev(res);    return res;}\nvi stov(string &a) {    ll n = sz(a);    vi ret(n);    rep(i, n) { ret[i] = a[i] - '0'; }    return ret;}\n//基準を満たさないものは0になる\nvi stov(string &a, char one) {    ll n = sz(a);    vi ret(n);    rep(i, n)ret[i] = a[i] == one;    return ret;}\nvector<vector<ll>> ctoi(vector<vector<char>> s, char c) {    ll n = sz(s), m = sz(s[0]);    vector<vector<ll>> res(n, vector<ll>(m));    rep(i, n)rep(j, m)res[i][j] = s[i][j] == c;    return res;}\n//[i] := vを返す\n//aは0~n-1で置き換えられる\nvi compress(vi &a) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(all(b), a[i]) - b.begin(); }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, umap<ll, ll> &map) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) {        ll v = a[i];        a[i] = lower_bound(all(b), a[i]) - b.begin();        map[v] = a[i];    }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r) {    vi b;    ll len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r, vi &s) {    vi b;    ll len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    fora(v, s)b.push_back(v);    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    for (ll i = 0; i < sz(s); ++i) r[i] = lower_bound(all(b), s[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vi> &a) {    vi b;    fora(vv, a)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vv, a)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vector<vi >> &a) {    vi b;    fora(vvv, a)fora(vv, vvv)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vvv, a)fora(vv, vvv)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvoid compress(ll a[], ll len) {    vi b;    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(all(b), a[i]) - b.begin(); }}\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(all(a),v))\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n#define rlowerIndex(a, v) (upper_bound(all(a),v)-a.begin()-1)\n#define rupperIndex(a, v) (lower_bound(all(a),v)-a.begin()-1)\n\ntemplate<class T, class U, class W> T lowerBound(vector<T> &a, U v, W banpei) {auto it = lower_bound(a.begin(), a.end(), v);if (it == a.end())return banpei; else return *it;}template<class T, class U, class W> T lowerBound(ruiC<T> &a, U v, W banpei) {return lowerBound(a.rui, v, banpei);}\ntemplate<class T, class U, class W> T upperBound(vector<T>& a, U v, W banpei){    auto it = upper_bound(a.begin(),a.end(),v);    if(it==a.end())return banpei;    else return *it;}template<class T, class U, class W> T upperBound(ruiC<T> &a, U v, W banpei) {return upperBound(a.rui, v, banpei);}\ntemplate<class T, class U, class W> T rlowerBound(vector<T> &a, U v, W banpei) {    auto it = upper_bound(a.begin(), a.end(), v);    if (it == a.begin())return banpei;    else{        return *(--it);    }}template<class T, class U, class W> T rlowerBound(ruiC<T> &a, U v, W banpei) {return rlowerBound(a.rui, v, banpei);}\ntemplate<class T, class U, class W> T rupperBound(vector<T> &a, U v, W banpei) {    auto it = lower_bound(a.begin(), a.end(), v);    if (it == a.begin())return banpei;    else{        return *(--it);    }}template<class T, class U, class W> T rupperBound(ruiC<T> &a, U v, W banpei) {return rupperBound(a.rui, v, banpei);}\n#define next2(a) next(next(a))\n#define prev2(a) prev(prev(a))\n\n//狭義の単調増加列 長さを返す\ntemplate<class T> int lis(vector<T> &a) {    int n = sz(a);    vi tail(n + 1, MAX(T));    rep(i, n) {        int id = lowerIndex(tail, a[i]);/**/        tail[id] = a[i];    }    return lowerIndex(tail, MAX(T));}\ntemplate<class T> int lis_eq(vector<T> &a) {    int n = sz(a);    vi tail(n + 1, MAX(T));    rep(i, n) {        int id = upperIndex(tail, a[i]);/**/        tail[id] = a[i];    }    return lowerIndex(tail, MAX(T));}\n\n//iteratorを返す\n//valueが1以上の物を返す 0は見つけ次第削除\n//vを減らす場合 (*it).se--でいい\ntemplate<class T, class U, class V> auto lower_map(map<T, U> &m, V k) {    auto ret = m.lower_bound(k);    while (ret != m.end() && (*ret).second == 0) {        ret = m.erase(ret);    }    return ret;}\ntemplate<class T, class U, class V> auto upper_map(map<T, U> &m, V k) {    auto ret = m.upper_bound(k);    while (ret != m.end() && (*ret).second == 0) {        ret = m.erase(ret);    }    return ret;}\n//存在しなければエラー\ntemplate<class T, class U, class V> auto rlower_map(map<T, U> &m, V k) {    auto ret = upper_map(m, k);    assert(ret != m.begin());    ret--;    while (1) {        if ((*ret).second != 0)break;        assert(ret != m.begin());        auto next = ret;        --next;        m.erase(ret);        ret = next;    }    return ret;}\ntemplate<class T, class U, class V> auto rupper_map(map<T, U> &m, V k) {    auto ret = lower_map(m, k);    assert(ret != m.begin());    ret--;    while (1) {        if ((*ret).second != 0)break;        assert(ret != m.begin());        auto next = ret;        --next;        m.erase(ret);        ret = next;    }    return ret;}\n\ntemplate<class... T> void fin(T... s) {out(s...); exit(0); }\n\n//便利 数学 math\n//sub ⊂ top\nbool subset(int sub, int top) {return (sub & top) == sub;}\n//-180 ~ 180 degree\ndouble atand(double h, double w) {return atan2(h, w) / PI * 180;}\n//% -mの場合、最小の正の数を返す\nll mod(ll a, ll m) {if (m < 0) m *= -1;return (a % m + m) % m;}\nll pow(ll a) { return a * a; };\nll fact(ll v) { return v <= 1 ? 1 : v * fact(v - 1); }\ndou factd(int v){static vd fact(2,1);    if(sz(fact)<=v){        rep(i,sz(fact),v+1){            fact.push_back(fact.back()*i);        }    }    return fact[v];}\n\nll comi(ll n, ll r) {    assert(n < 100);    static vvi(pas, 100, 100);    if (pas[0][0])return pas[n][r];    pas[0][0] = 1;    rep(i, 1, 100) {        pas[i][0] = 1;        rep(j, 1, i + 1)pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];    }    return pas[n][r];}\ndouble comd2(ll n, ll r) {    static vvd(comb, 2020, 2020);    if (comb[0][0] == 0) {        comb[0][0] = 1;        rep(i, 2000) {            comb[i + 1][0] = 1;            rep(j, 1, i + 2) { comb[i + 1][j] = comb[i][j] + comb[i][j - 1]; }        }    }    return comb[n][r];}\ndouble comd(int n, int r) {    if (r < 0 || r > n) return 0;    if (n < 2020)return comd2(n, r);    static vd fact(2, 1);    if (sz(fact) <= n) { rep(i, sz(fact), n + 1) { fact.push_back(fact.back() * i); }}    return fact[n] / fact[n - r] / fact[r];}\n\nll gcd(ll a, ll b) {while (b) a %= b, swap(a, b);return abs(a);}\nll gcd(vi b) {ll res = b[0];rep(i, 1, sz(b))res = gcd(b[i], res);return res;}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll lcm(vi a) {ll res = a[0];rep(i, 1, sz(a))res = lcm(a[i], res);return res;}\nll ceil(ll a, ll b) {if (b == 0) {debugline(\"ceil\");deb(a, b);ole();return -1;} else if (a < 0) { return 0; } else { return (a + b - 1) / b; }}\n\nll sig0(int t) { return t <= 0 ? 0 : ((1 + t) * t) >> 1; }\nbint sig0(bint t) {return t <= 0 ? 0 : ((1 + t) * t) >> 1; }\n//ll sig(ll s, ll t) { return ((s + t) * (t - s + 1)) >> 1; }\nll sig(ll s, ll t) {if (s > t)swap(s, t);return sig0(t - s) + s * (t - s + 1);}\n\n#define tousa_i tosa_i\n#define lower_tousa_i lower_tosa_i\n#define upper_tousa upper_tosa\n#define upper_tousa_i upper_tosa_i\nll tosa_i(ll st, ll ad, ll v) {    assert(((v - st) % ad) == 0);    return (v - st) / ad;}\nll tosa_s(ll st, ll ad, ll len) {    return st * len + sig0(len - 1) * ad;}\n\n// ax + r (x は非負整数) で表せる整数のうち、v 以上となる最小の整数\nll lower_tosa(ll st, ll ad, ll v) {    if (st >= v) return st;    return (v - st + ad - 1) / ad * ad + st;}\n//第何項か\nll lower_tosa_i(ll st, ll ad, ll v) {    if (st >= v) return 0;    return (v - st + ad - 1) / ad;}\nll upper_tosa(ll st, ll ad, ll v) { return lower_tosa(st, ad, v + 1); }\nll upper_tosa_i(ll st, ll ad, ll v) { return lower_tosa_i(st, ad, v + 1); }\n\n\n//v * v >= aとなる最小のvを返す\nll sqrt(ll a) {    if (a < 0) {        debugline(\"sqrt\");        deb(a);        ole();    }    ll res = (ll) std::sqrt(a);    while (res * res < a)++res;    return res;}\ndouble log(double e, double x) { return log(x) / log(e); }\n\n//b * res <= aを満たす [l, r)を返す\nP drange_ika(int a, int b) {    assert(b);    if (a >= 0) {        if (b > 0)return mp(-linf, a / b + 1);        else return mp(-(a / -b), linf + 1);    } else {        if (b > 0)return mp(-linf, -ceil(-a, b) + 1);        else return mp(ceil(-a, -b), linf + 1);    }}\n\n/*@formatter:off*/\n\n//機能拡張\n#define dtie(a, b) int a, b; tie(a, b)\ntemplate<class T, class U> string to_string(T a, U b) {    string res = \"\";    res += a;    res += b;    return res;}\ntemplate<class T, class U, class V> string to_string(T a, U b, V c) {    string res = \"\";    res += a;    res += b;    res += c;    return res;}\ntemplate<class T, class U, class V, class W> string to_string(T a, U b, V c, W d) {    string res = \"\";    res += a;    res += b;    res += c;    res += d;    return res;}\ntemplate<class T, class U, class V, class W, class X> string to_string(T a, U b, V c, W d, X e) {    string res = \"\";    res += a;    res += b;    res += c;    res += d;    res += e;    return res;}\n\ntemplate<class T> vector<T> sub(vector<T> &A, int l, int r) {    assert(0 <= l && l <= r && r <= sz(A));    vector<T> ret(r - l);    std::copy(A.begin() + l, A.begin() + r, ret.begin());    return ret;}\ntemplate<class T> vector<T> sub(vector<T> &A, int r) { return sub(A, 0, r); }\ntemplate<class T> vector<T> subn(vector<T> &A, int l, int len) { return sub(A, l, l + len); }\nstring sub(string &A, int l, int r) {    assert(0 <= l && l <= r && r <= sz(A));    return A.substr(l, r - l);}\n\nconstexpr int bsetlen = k5 * 2;\n//constexpr int bsetlen = 5050;\n#define bset bitset<bsetlen>\nbool operator<(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] < b[i])return true;if (a[i] > b[i])return false;}return false;}\nbool operator>(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] > b[i])return true;if (a[i] < b[i])return false;}return false;}\nbool operator<=(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] < b[i])return true;if (a[i] > b[i])return false;}return true;}\nbool operator>=(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] > b[i])return true;if (a[i] < b[i])return false;}return true;}\nstring operator~(string &a) {string res = a;for (auto &&c:res) {if (c == '0')c = '1';else if (c == '1')c = '0';else {cerr << \"cant ~\" << a << \"must bit\" << endl;exit(0);}}return res;}\nostream &operator<<(ostream &os, bset& a) {    bitset<10> b;    vi list;    rep(i,bsetlen){        if(a[i])list.push_back(i),b[i]=1;    }    os<<b<<\", \"<<list;    return os;}\nint hbiti(bset&a){rer(i,bsetlen){if(a[i])return i;}return -1;}\n#define hk(a, b, c) (a <= b && b < c)\n\n//O(N/64)\nbset nap(bset &a, int v) {bset r = a | a << v;return r;}\nbset nap(bset &a, bset &v) {bset r = a;rep(i, bsetlen) {if (v[i])r |= a << i;}return r;}\n\ntemplate<class T> int count(set<T> &S, T l, T r) {    assert(l < r);    auto it = S.lower_bound(l);    return it != S.end() && (*it) < r;}\n\ntemplate<class T> void seth(vector<vector<T>> &S, int w, vector<T> &v) {assert(sz(S) == sz(v));assert(w < sz(S[0]));rep(h, sz(S)) { S[h][w] = v[h]; }}\n\ntemplate<class T, class U> void operator+=(pair<T,U> &a, pair<T,U> & b) {a.fi+=b.fi;a.se+=b.se;}\ntemplate<class T, class U> pair<T,U> operator+(pair<T,U> &a, pair<T,U> & b) {return pair<T,U>(a.fi+b.fi,a.se+b.se);}\n\ntemplate<typename CharT, typename Traits, typename Alloc>basic_string<CharT, Traits, Alloc>operator+(const basic_string<CharT, Traits, Alloc> &lhs, const int rv) {    basic_string<CharT, Traits, Alloc> str(lhs);    str.append(to_string(rv));    return str;}template<typename CharT, typename Traits, typename Alloc>void operator+=(basic_string<CharT, Traits, Alloc> &lhs, const int rv) {    lhs += to_string(rv);}template<typename CharT, typename Traits, typename Alloc>basic_string<CharT, Traits, Alloc>operator+(const basic_string<CharT, Traits, Alloc> &lhs, const signed rv) {    basic_string<CharT, Traits, Alloc> str(lhs);    str.append(to_string(rv));    return str;}template<typename CharT, typename Traits, typename Alloc>void operator+=(basic_string<CharT, Traits, Alloc> &lhs, const signed rv) {    lhs += to_string(rv);}\ntemplate<typename CharT, typename Traits, typename Alloc> void operator*=(basic_string<CharT, Traits, Alloc> &s, int num) {auto bek = s;s = \"\";for (; num; num >>= 1) {if (num & 1) {s += bek;}bek += bek;}}\ntemplate<class T, class U> void operator+=(queue<T> &a, U v) { a.push(v); }template<class T, class U> void operator+=(deque<T> &a, U v) { a.push_back(v); }template<class T> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, vector<T> &v) {    fora(d, v)a.push(d);    return a;}template<class T, class U> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, U v) {    a.push(v);    return a;}template<class T, class U> priority_queue<T> &operator+=(priority_queue<T> &a, U v) {    a.push(v);    return a;}template<class T> set<T> &operator+=(set<T> &a, vector<T> v) {    fora(d, v)a.insert(d);    return a;}template<class T, class U> auto operator+=(set<T> &a, U v) { return a.insert(v); }template<class T, class U> auto operator-=(set<T> &a, U v) { return a.erase(v); }template<class T, class U> auto operator+=(mset<T> &a, U v) { return a.insert(v); }template<class T, class U> set<T, greater<T>> &operator+=(set<T, greater<T>> &a, U v) {    a.insert(v);    return a;}template<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {    a.push_back(v);    return a;}template<class T, class U> vector<T> operator+(vector<T> &a, U v) {    vector<T> ret = a;    ret += v;    return ret;}template<class T, class U> vector<T> operator+(U v, vector<T> &a) {    vector<T> ret = a;    ret.insert(ret.begin(), v);    return ret;}template<class T> vector<T> operator+(vector<T> a, vector<T> b) {    vector<T> ret;    ret = a;    fora(v, b)ret += v;    return ret;}template<class T> vector<T> &operator+=(vector<T> &a, vector<T> &b) {    rep(i, sz(b)) {/*こうしないとa+=aで両辺が増え続けてバグる*/        a.push_back(b[i]); }    return a;}template<class T, class U> map<T, U> &operator+=(map<T, U> &a, map<T, U> &b) {    fora(bv, b) { a[bv.first] += bv.second; }    return a;}\ntemplate<class T> vector<T> operator%(vector<T>& a, int v){    vi ret(sz(a));    rep(i,sz(a)){        ret[i] = a[i] % v;    }    return ret;}\ntemplate<class T> vector<T> operator%=(vector<T>& a, int v){    rep(i,sz(a)){        a[i] %= v;    }    return a;}\nvi operator&(vi& a, vi& b){    assert(sz(a)==sz(b));    vi ret(sz(a));    rep(i,sz(a)){        ret[i] = min(a[i],b[i]);    }    return ret;}\ntemplate<class T> void operator+=(mset<T> &a, vector<T>& v) { for(auto&& u : v)a.insert(u); }\ntemplate<class T> void operator+=(set<T> &a, vector<T>& v) { for(auto&& u : v)a.insert(u); }\ntemplate<class T> void operator+=(vector<T> &a, set<T>& v) { for(auto&& u : v)a.emplace_back(u); }\ntemplate<class T> void operator+=(vector<T> &a, mset<T>& v) { for(auto&& u : v)a.emplace_back(u); }\ntemplate<class T> vector<T> &operator-=(vector<T> &a, vector <T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-=\");        deb(a);        deb(b);        exit(0);    }    rep(i, sz(a))a[i] -= b[i];    return a;}\ntemplate<class T> vector<T> operator-(vector<T> &a, vector<T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-\");        deb(a);        deb(b);        ole();    }    vector<T> res(sz(a));    rep(i, sz(a))res[i] = a[i] - b[i];    return res;}\ntemplate<class T, class U> void operator*=(vector<T> &a, U b) {    vector<T> ta = a;    rep(b-1){        a+=ta;    }}\ntemplate<typename T> void erase(vector<T> &v, unsigned ll i) { v.erase(v.begin() + i); }\ntemplate<typename T> void erase(vector<T> &v, unsigned ll s, unsigned ll e) { v.erase(v.begin() + s, v.begin() + e); }\ntemplate<typename T> void entry(vector<T> &v, unsigned ll s, unsigned ll e) { erase(v, e, sz(v));erase(v,0,s);}\n\ntemplate<class T, class U> void erase(map<T, U> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<class T> void erase(set<T> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<typename T> void erasen(vector<T> &v, unsigned ll s, unsigned ll n) { v.erase(v.begin() + s, v.begin() + s + n); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, U t) { v.insert(v.begin() + i, t); }\ntemplate<typename T, typename U> void push_front(vector<T> &v, U t) { v.insert(v.begin(), t); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, vector<T> list) { for (auto &&va:list)v.insert(v.begin() + i++, va); }\ntemplate<typename T> void insert(set<T> &v, vector<T> list) { for (auto &&va :list)v.insert(va); }\ntemplate<class T> T poll(set<T>& S){T ret = *S.begin();S.erase(S.begin());return ret;}\ntemplate<class T> T poll(mset<T>& S){T ret = *S.begin();S.erase(S.begin());return ret;}\ntemplate<class T> T poll_back(set<T>& S){T ret = *S.rbegin();S.erase(S.rbegin());return ret;}\ntemplate<class T> T poll_back(mset<T>& S){T ret = *S.rbegin();S.erase(S.rbegin());return ret;}\ntemplate<class T> T peek(set<T>& S){T ret = *S.begin();return ret;}\ntemplate<class T> T peek(mset<T>& S){T ret = *S.begin();return ret;}\ntemplate<class T> T peek_back(set<T>& S){T ret = *S.rbegin();return ret;}\ntemplate<class T> T peek_back(mset<T>& S){T ret = *S.rbegin();return ret;}\nvector<string> split(const string a, const char deli) {    string b = a + deli;    ll l = 0, r = 0, n = b.size();    vector<string> res;    rep(i, n) {        if (b[i] == deli) {            r = i;            if (l < r)res.push_back(b.substr(l, r - l));            l = i + 1;        }    }    return res;}\nvector<string> split(const string a, const string deli) {    vector<string> res;    ll kn = sz(deli);    std::string::size_type Pos(a.find(deli));    ll l = 0;    while (Pos != std::string::npos) {        if (Pos - l)res.push_back(a.substr(l, Pos - l));        l = Pos + kn;        Pos = a.find(deli, Pos + kn);    }    if (sz(a) - l)res.push_back(a.substr(l, sz(a) - l));    return res;}\nll stoi(string& s){return stol(s);}\n#define assert_yn(yn_v, v); assert(yn_v == 0 || yn_v == v);yn_v = v;\n//不完全な対策、現状はautohotkeyで対応\nint yn_v = 0;\nvoid yn(bool a) { assert_yn(yn_v, 1);if (a)cout << \"yes\" << endl; else cout << \"no\" << endl; }\nvoid fyn(bool a) {    assert_yn(yn_v, 1);yn(a);    exit(0);}\n\nvoid Yn(bool a) { assert_yn(yn_v, 2);if (a)cout << \"Yes\" << endl; else cout << \"No\" << endl; }\nvoid fYn(bool a) {    assert_yn(yn_v, 2);Yn(a);    exit(0);}\n\nvoid YN(bool a) { assert_yn(yn_v, 3);if (a)cout << \"YES\" << endl; else cout << \"NO\" << endl; }\nvoid fYN(bool a) {    assert_yn(yn_v, 3);YN(a);    exit(0);}\nint ab_v = 0;\nvoid fAb(bool a) { assert_yn(ab_v, 1);if(a)cout<<\"Alice\"<<endl;else cout<<\"Bob\";}\nvoid fAB(bool a) { assert_yn(yn_v, 2);if(a)cout<<\"ALICE\"<<endl;else cout<<\"BOB\";}\nint pos_v = 0;\nvoid Possible(bool a) {    assert_yn(pos_v, 1);if (a)cout << \"Possible\" << endl; else cout << \"Impossible\" << endl;    exit(0);}\nvoid POSSIBLE(bool a) {    assert_yn(pos_v, 2);if (a)cout << \"POSSIBLE\" << endl; else cout << \"IMPOSSIBLE\" << endl;    exit(0);}\nvoid fPossible(bool a) {    assert_yn(pos_v, 1)Possible(a);exit(0);}\nvoid fPOSSIBLE(bool a) {    assert_yn(pos_v, 2)POSSIBLE(a);exit(0);}\ntemplate<typename T> class fixed_point        : T {public:    explicit constexpr fixed_point(T &&t) noexcept: T(std::forward<T>(t)) {}    template<typename... Args> constexpr decltype(auto) operator()(Args &&... args) const { return T::operator()(*this, std::forward<Args>(args)...); }};template<typename T> static inline constexpr decltype(auto) fix(T &&t) noexcept { return fixed_point<T>{std::forward<T>(t)}; }\n\n\n//未分類\n//0,2,1 1番目と2番目の次元を入れ替える\ntemplate<class T> auto irekae(vector<vector<vector<T> > > &A, int x, int y, int z) {\n#define irekae_resize_loop(a, b, c) resize(res,a,b,c);rep(i,a)rep(j,b)rep(k,c)\n    vector<vector<vector<T> > > res;    if (x == 0 && y == 1 && z == 2) {        res = A;    } else if (x == 0 && y == 2 && z == 1) {        irekae_resize_loop(sz(A), sz(A[0][0]), sz(A[0])) {                    res[i][j][k] = A[i][k][j];                }    } else if (x == 1 && y == 0 && z == 2) {        irekae_resize_loop(sz(A[0]), sz(A), sz(A[0][0])) {                    res[i][j][k] = A[j][i][k];                }    } else if (x == 1 && y == 2 && z == 0) {        irekae_resize_loop(sz(A[0]), sz(A[0][0]), sz(A)) {                    res[i][j][k] = A[k][i][j];                }    } else if (x == 2 && y == 0 && z == 1) {        irekae_resize_loop(sz(A[0][0]), sz(A), sz(A[0])) {                    res[i][j][k] = A[j][k][i];                }    } else if (x == 2 && y == 1 && z == 0) {        irekae_resize_loop(sz(A[0][0]), sz(A[0]), sz(A)) {                    res[i][j][k] = A[k][j][i];                }    }    return res;\n#undef irekae_resize_loop\n}\ntemplate<class T> auto irekae(vector<vector<T>>&A,int i=1,int j=0){    vvt(res,sz(A[0]),sz(A));    rep(i,sz(A)){        rep(j,sz(A[0])){            res[j][i]=A[i][j];        }    }    return res;}\n//tou分割する\ntemplate<typename T> vector<vector<T>> cut(vector<T> &a, int tou = 2) {    int N = sz(a);    vector<vector<T>> res(tou);    int hab = N / tou;    vi lens(tou, hab);    rep(i, N % tou) { lens[tou - 1 - i]++; }    int l = 0;    rep(i, tou) {        int len = lens[i];        int r = l + len;        res[i].resize(len);        std::copy(a.begin() + l, a.begin() + r, res[i].begin());        l = r;    }    return res;}\n//長さn毎に分割する\ntemplate<typename T> vector<vector<T>> cutn(vector<T> &a, int len) {    int N = sz(a);    vector<vector<T>> res(ceil(N, len));    vi lens(N / len, len);    if (N % len)lens.push_back(N % len);    int l = 0;    rep(i, sz(lens)) {        int len = lens[i];        int r = l + len;        res[i].resize(len);        std::copy(a.begin() + l, a.begin() + r, res[i].begin());        l = r;    }    return res;}\nvi inds_(vi &a) {    int n = sz(a);    vb was(n);    vi res(n);    rep(i, n) {        assert(!was[a[i]]);        res[a[i]] = i;        was[a[i]] = true;    }    return res;}\n//縦を返す\nvi& geth(vvi()& a, int w){    static vi ret; ret.resize(sz(a));   rep(i,sz(a)){        ret[i] = a[i][w];    }    return ret;}\n\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} initonv;\n#define pre prev\n#define nex next\n\n//gra mll pr\n//上下左右\nconst string udlr = \"udlr\";\nstring UDLR = \"UDLR\";//x4と連動 UDLR.find('U') := x4[0]\nvc atoz = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x','y', 'z'};\nvc AtoZ = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X','Y', 'Z'};\n//右、上が正\nconstexpr ll h4[] = {1, -1, 0, 0};\nconstexpr ll w4[] = {0, 0, -1, 1};\nconstexpr ll h8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconstexpr ll w8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n    int mei_inc(int h, int w, int H, int W, int i) {while (++i < 4) { if (inside(h + h4[i], w + w4[i], H, W))return i; }return i;}\n#define mei(nh, nw, h, w) for (int i = mei_inc(h, w, H, W, -1), nh = i<4? h + h4[i] : 0, nw = i<4? w + w4[i] : 0; i < 4; i=mei_inc(h,w,H,W,i), nh = h+h4[i], nw = w+w4[i])\n\n//グラフ内で #undef getid\n//#define getidとしているため、ここを書き直したらgraphも書き直す\n#define getid_2(h, w) (h * W + w)\n#define getid_1(p) (p.first * W + p.second)\n#define getid(...) over2(__VA_ARGS__, getid_2, getid_1) (__VA_ARGS__)\n#define getp(id) mp(id / W, id % W)\n//#define set_shuffle() std::random_device seed_gen;std::mt19937 engine(seed_gen())\n//#define shuffle(a) std::shuffle((a).begin(), (a).end(), engine);\n//1980 開始からtime ms経っていたらtrue\n#ifdef _DEBUG\nbool timeup(int time){\n    static bool never = true;\n    if(never)message += \"may timeup, because slow\";\n    never = false;\n\n    auto end_time = system_clock::now();\n    auto part = duration_cast<milliseconds>(end_time - start_time);\n    auto lim = milliseconds(time);\n    return part >= lim;\n}\n#else\nbool timeup(int time) {\n    auto end_time = system_clock::now();\n    auto part = duration_cast<milliseconds>(end_time - start_time);\n    auto lim = milliseconds(time);\n    return part >= lim;\n}\n\n#endif\nvoid set_time() { past_time = system_clock::now(); }\n//MS型(millisecqnds)で返る\n//set_timeをしてからの時間\nauto calc_time_milli() {    auto now = system_clock::now();    auto part = duration_cast<milliseconds>(now - past_time);    return part;}\nauto calc_time_micro() {    auto now = system_clock::now();    auto part = duration_cast<microseconds>(now - past_time);    return part;}\nauto calc_time_nano() {    auto now = system_clock::now();    auto part = duration_cast<nanoseconds>(now - past_time);    return part;}\nbool calc_time(int zikan) { return calc_time_micro() >= microseconds(zikan); }\nusing MS=std::chrono::microseconds;\nint div(microseconds a, microseconds b) { return a / b; }\nint div(nanoseconds a, nanoseconds b) {    if (b < nanoseconds(1)) { return a / nanoseconds(1); }    int v = a / b;    return v;}\n//set_time();\n//rep(i,lim)shori\n\ntemplate<class F> dou mgrd_time(dou ok, dou ng, F f,int time = 1980) {\n    bool han = true;\n    if (ok < ng)\n        while(1) {\n            dou mid = (ok + ng) /2;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            deb(mid,han);\n            if(timeup(time)){\n                break;\n            }\n        }\n    else\n        while(1) {\n            dou mid = (ok + ng) /2;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            deb(mid,han);\n            if(timeup(time)){\n                break;\n            }\n        }\n    return ok;\n}\n//lim*=time_nanbai();\n//rep(i,lim)shoriと使う\n//全体でmilliかかっていいときにlimを何倍してもう一回できるかを返す\nint time_nanbai(int milli) {\n    auto dec = duration_cast<nanoseconds>(past_time - start_time);\n    auto part = calc_time_nano();\n    auto can_time = nanoseconds(milli * 1000 * 1000);\n    can_time -= part;\n    can_time -= dec;\n    return div(can_time, part);\n}\nvb bit_bool(int v, int len) {    assert(bit(len) > v);    vb ret(len);    rep(i, len) { ret[i] = bget(v, i); }    return ret;}\nvi &range(int l, int r) {static vi ret;ret.resize(r - l);rep(v, l, r) {ret[v - l] = v;}return ret;}\nvi &range(int r) {return range(0, r);}\n\n\n#define rge range\n//† ←template終了\n/*@formatter:on*/\n//vectorで取れる要素数\n//bool=> 1e9 * 8.32\n//int => 1e8 * 2.6\n//ll  => 1e8 * 1.3\n//3次元以上取るとメモリがヤバい\n//static配列を使う\n#define V vector\nvvc (ba);\nll N, M, H, W;\nvi A, B, C;\n\n//9:43\nvoid solve() {\n    str S;\n    in(S);\n    N = sz(S);\n    din(K);\n    //[)\n    vni(dp, N + 1, N + 1, N + 1);\n    fill(dp, inf);\n    rep(i, N) {\n        dp[i][i][0] = 0;\n        dp[i][i + 1][1] = 0;\n    }\n    int ma = 0;\n    deb(dp);\n    //長さと変更した数\n    rep(h, 2, N + 1) {\n        rep(l, N) {\n            rep(len, N + 1) {\n                int r = l + h;\n                if (r > N)break;\n                deb(l, r, len);\n                chmi(dp[l][r][len], dp[l][r - 1][len]);\n                chmi(dp[l][r][len], dp[l + 1][r][len]);\n                if (len >= 2){\n                    int v= dp[l + 1][r - 1][len - 2];\n                    deb(v);\n\n                    chmi(dp[l][r][len], v + (S[l] != S[r - 1]));\n                    deb(dp[l][r][len]);\n                }\n                if (dp[l][r][len] <= K) {\n                    chma(ma, len);\n                }\n            }\n        }\n    }\n    deb(dp);\n    out(ma);\n\n}\n\nauto my(ll n, vi &a) {\n    return 0;\n}\n\nauto sister(ll n, vi &a) {\n    ll ret = 0;\n    return ret;\n}\n\nsigned main() {\n    solve();\n\n#define arg n,a\n#ifdef _DEBUG\n    bool bad = 0;\n    for (ll i = 0, ok = 1; i < k5 && ok; ++i) {\n        ll n = rand(1, 8);\n        vi a = ranv(n, 1, 10);\n        auto myres = my(arg);\n        auto res = sister(arg);\n        ok = myres == res;\n        if (!ok) {\n            out(arg);\n            cerr << \"AC : \" << res << endl;\n            cerr << \"MY  : \" << myres << endl;\n            bad = 1;\n\n\n            break;\n        }\n    }\n    if (!bad) {\n//        cout << \"完璧 : solveを書き直そう\" << endl;\n//        cout << \"     : そして、solve()を呼び出すのだ\" << endl;\n//        cout << \"     : cin>>n; na(a,n);も忘れるな\" << endl;\n    }\n    if (was_deb && sz(res_mes)) {\n        cerr << \"result = \" << endl << res_mes << endl;\n    }\n    if (sz(message)) {\n        cerr << \"****************************\" << endl;\n        cerr << message << endl;\n        cerr << \"****************************\" << endl;\n    }\n#endif\n    return 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define mod 1000000007LL\n#define eps 1e-13\n// #define PI 3.141592653589793238L\n#define INF 1000000011\n#define INFLL 1000000000000000011LL\n#define vi vector<int>\n#define vll vector<long long>\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define pil pair<int, long long>\n#define pli pair<long long, int>\n#define mp make_pair\n#define F first\n#define S second\n#define pb push_back\n#define fo(i,a,n) for(i = (a); i < (n); i++)\n#define gtl(x) getline(cin, (x))\n#define flsh fflush(stdout)\n#define sws ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)\n#define gcd __gcd\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)((a).size())\n#define io_file freopen(\"D:/Coding Problems/Contest/input_file.in\", \"r\", stdin); freopen(\"D:/Coding Problems/Contest/output_file.out\", \"w\", stdout)\n\nll modx(ll Base, ll exponent)\n{\n\tll ans = 1;\n\tif(Base == 1)\n\t\treturn Base;\n\twhile(exponent)\n\t{\n\t\tif(exponent & 1)\n\t\t\tans = (ans * Base)%mod;\n\t\tBase = (Base * Base)%mod;\n\t\texponent = exponent >> 1;\n\t}\n\treturn ans;\n}\n\nll inmodx(ll num)\n{\n\treturn (modx(num, mod-2LL));\n}\n\nbool cmp(pair < pii, int > a, pair < pii, int > b)//true for a before b\n{\n\tif(a.F.F/300 < b.F.F/300)\n\t\treturn 1;\n\tif(a.F.F/300 > b.F.F/300)\n\t\treturn 0;\n\tif(a.F.S < b.F.S)\n\t\treturn 1;\n\tif(a.F.S > b.F.S)\n\t\treturn 0;\n\tif(a.F <= b.F)\n\t\treturn 1;\n\treturn 0;\n}\n\nconst int N = (3e2) + 9;\nconst int M = (N<<2) + 9;\nconst int LOGN = ((int)log2(N)) + 3;\nconst int LOGM = ((int)log2(M)) + 3;\nconst int BUCK = 2*550;\nconst int SQRT = BUCK+9;\n\nint dp[N][N][N];\nstring s;\nint n, K;\n\nvoid solve()\n{\n\tint i, j, k, ans = 0;\n\tcin >> s;\n\tcin >> K;\n\tn = s.length();\n\tfo(i,1,n+1)\n\t\tfo(j,1,n-i+1+1)\n\t\t\tfo(k,0,K+1)\n\t\t\t{\n\t\t\t\tif(s[i-1] == s[n-j])\n\t\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k] + ((i+j <= n) ? 2 : 1));\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k]);\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k]);\n\t\t\t\tif(k > 0)\n\t\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k-1] + ((i+j <= n) ? 2 : 1));\n\t\t\t\tans = max(ans, dp[i][j][k]);\n\t\t\t}\n\tcout << ans << '\\n';\n\treturn;\n}\n\nint main()\n{\n\tsws;\n\tclock_t clk;\n\tclk = clock();\n\t// io_file;\n\t// srand (time(NULL));\n\n\t//Code here\n\tint t = 1, cs;\n\tcout << fixed << setprecision(9);\n\t// cin >> t;\n\tfo(cs,1,t+1)\n\t{\n\t\t// cout << \"Case #\" << cs << \": \";\n\t\tsolve();\n\t}\n\t// Code ends here\n\n\tclk = clock() - clk;\n\tcerr << fixed << setprecision(6) << \"Time: \" << ((double)clk)/CLOCKS_PER_SEC << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n#define INF 1000000000\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint dp[333][333][333];\nstring s;\nint k;\n\nint dfs(int K,int L,int R)\n{\n//\tcout << K << ' ' << L << ' ' << R << endl;\n\tif(K < 0 || L > R)return 0;\n\tif(dp[K][L][R] != 0)return dp[K][L][R];\n\tint ret = 0;\n\tint p = 0;\n\tif(s[L] == s[R])ret = max(ret,dfs(K,L+1,R-1)+2);\n\telse ret = max(ret,dfs(K-1,L+1,R-1)+2);\n\tret = max(ret,dfs(K,L+1,R));\n\tret = max(ret,dfs(K,L,R-1));\n\t\n\treturn dp[K][L][R] = ret;\n}\n\n\nint main()\n{\n\tcin >> s >> k;\n\t\n\tREP(K,k+1)REP(i,333)dp[K][i][i] = 1;\n\tREP(K,k+1)REP(i,332)\n\t{\n\t\tif(s[i] == s[i+1])dp[K][i][i+1] = 2;\n\t\telse dp[K][i][i+1] = 1;\n\t}\n\t\n\tcout << dfs(k,0,s.size()-1) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, j, k) for (int i = j; i <= k; i++)\n\nusing namespace std;\n\nconst int N = 310;\n\nvoid chkmax(int &x, int y) { x = x < y ? y : x; }\n\nint dp[N][N][N];\nchar S[N];\nint n, k;\n\nint main() {\n\n\tscanf(\"%s%d\", S + 1, &k);\n\tn = strlen(S + 1);\n\tdp[0][0][0] = 0;\n\t\n\tFor(i, 0, n) For(j, 0, n) For(u, 0, k) {\n\t\tif (i) chkmax(dp[i][j][u], dp[i - 1][j][u]);\n\t\tif (j) chkmax(dp[i][j][u], dp[i][j - 1][u]);\n\t\tif (i && j) {\n\t\t\tint nu = u - (S[n + 1 - j] != S[i]);\n\t\t\tif (nu >= 0) chkmax(dp[i][j][u], dp[i - 1][j - 1][nu] + 1);\n\t\t}\n\t}\n\n\tint ans = 0;\n\tFor(i, 0, n) chkmax(ans, dp[i][n - i][k] * 2);\n\tFor(i, 0, n - 1) chkmax(ans, dp[i][n - i - 1][k] * 2 + 1);\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define overload_rep(va_0, va_1, va_2, name, ...) name\n#define rep_0(i, n) for(int i = 0; i < (n); ++i)\n#define rep_1(i, x, y) for(int i = (x); i <= (y); ++i)\n#define rep(...) overload_rep(__VA_ARGS__, rep_1, rep_0)(__VA_ARGS__)\n#define all(a) a.begin(), a.end()\n#ifndef STOP_DEBUG\n#define debug(...)\\\n    do { cerr << boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n    debug_cerr(__VA_ARGS__); cerr << noboolalpha; } while (0)\n#else\n#define debug(...)\n#endif\n\n// functions\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nvoid debug_cerr(){ cerr << '\\n'; }\ntemplate<class Head, class... Tail>\nvoid debug_cerr(Head head, Tail... tail){\n    cerr << ' ' << head;\n    debug_cerr(tail...);\n}\n\n// cin/cout setup\nstruct IoSetup{\n    IoSetup(){\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(20);\n    }\n} iosetup;\n\n// libraries\n\n// declarations\nint N, K;\nstring S;\n\nint dp[301][301][301];\n\n// solve\nint main(){\n\n    cin >> S >> K;\n    N = S.size();\n\n    rep(i, N)dp[i][i + 1][0] = 1;\n    rep(len, 1, N){\n        rep(i, 0, N - len){\n            // 右側に\n            if(i + len < N){\n                int pos;\n                rep(j, i, i + len)if(S[j] == S[i + len]){\n                    pos = j;\n                    break;\n                }\n                rep(j, 0, K){\n                    chmax(dp[i][i + len + 1][j], dp[i][i + len][j]);\n                    if(pos < i + len)chmax(dp[i][i + len + 1][j], dp[pos + 1][i + len][j] + 2);\n                }\n                rep(j, K){\n                    chmax(dp[i][i + len + 1][j + 1], dp[i + 1][i + len][j] + 2);\n                }\n            }   \n            // 左側に\n            if(i > 0){\n                int pos;\n                for(int j = i + len - 1; j >= i - 1; --j){\n                    if(S[j] == S[i - 1]){\n                        pos = j;\n                        break;\n                    }\n                }\n                rep(j, 0, K){\n                    chmax(dp[i - 1][i + len][j], dp[i][i + len][j]);\n                    if(pos > i - 1)chmax(dp[i - 1][i + len][j], dp[i - 1][pos - 1][j] + 2);\n                }\n                rep(j, K){\n                    chmax(dp[i - 1][i + len][j + 1], dp[i][i + len - 1][j] + 2);\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    rep(i, 0, K)chmax(ans, dp[0][N][i]);\n    cout << ans << '\\n';\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#define int ll\n//#define char ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(4) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int N = 311;\n\nshort dp[N][N][N];\nstring s;\n\nshort dfs(int l, int r, int k) {\n    if (l == r)\n        return 1;\n    if (l + 1 == r) {\n        if (k >= 1)\n            return 2;\n        return 1 + (s[l] == s[r]);\n    }\n    if (dp[l][r][k] != -1)\n        return dp[l][r][k];\n\n    inmax(dp[l][r][k], dfs(l + 1, r, k));\n    inmax(dp[l][r][k], dfs(l, r - 1, k));\n    inmax(dp[l][r][k], short(dfs(l + 1, r - 1, k) + 2 * (s[l] == s[r])));\n    if (k)\n        inmax(dp[l][r][k], short(dfs(l + 1, r - 1, k - 1) + 2));\n    return dp[l][r][k];\n}\n\nvoid smain() {\n\n    fori (i, N) {\n        fori (j, N) {\n            fori (k, N) {\n                dp[i][j][k] = -1;\n            }\n        }\n    }\n\n    cin >> s;\n    int K;\n    cin >> K;\n    int n = s.size();\n    fori (i, n) {\n\n    }\n    short ans = 0;\n    fori (i, n) {\n        for (int j = i; j < n; ++j) {\n            fori (k, K + 1) {\n                inmax(ans, dfs(i, j, k));\n            }\n        }\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\n\n// template {{{  0 \n// using {{{ 1\nusing ll = long long int;\nusing pii = pair<int,int>;\nusing pll = pair<ll,ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vii = vector<pii>;\nusing vll = vector<pll>;\n// }}} 1\n// definition {{{ 1\n// scaning {{{ 2\n#define Scd(x) scanf(\"%d\", &x)\n#define Scd2(x,y) scanf(\"%d%d\", &x, &y)\n#define Scd3(x,y,z) scanf(\"%d%d%d\", &x, &y, &z)\n#define Scll(x) scanf(\"%lld\", &x)\n#define Scll2(x,y) scanf(\"%lld%lld\", &x, &y)\n#define Scll3(x,y,z) scanf(\"%lld%lld%lld\", &x, &y, &z)\n#define Scc(c) scanf(\"%c\", &c);\n#define Scs(s) scanf(\"%s\", s);\n#define Scstr(s) scanf(\"%s\", &s);\n// }}} 2\n// constants {{{ 2\n#define EPS (1e-7)\n#define INF (2e9)\n#define PI (acos(-1))\n// }}} 2\n// systems {{{ 2\n#define Repe(x,y,z) for(ll x = z; x < y; x++)\n#define Rep(x,y) Repe(x,y,0)\n#define RRepe(x,y,z) for(ll x = y-z-1; x >= 0; x--)\n#define RRep(x,y) RRepe(x,y,0)\n// }}} 2\n// output {{{ 2\n#define YesNo(a) (a)?printf(\"Yes\\n\"):printf(\"No\\n\")\n#define YESNO(a) (a)?printf(\"YES\\n\"):printf(\"NO\\n\")\n// }}} 2\n// }}} 1\n// input {{{ 1\n// }}} 1\n// }}} 0\n\nint main() {\n\n    int N,K;\n    char S[322];\n    Scs(S);\n    N = strlen(S);\n    Scd(K);\n\n    if( K >= N/2 ) {\n        printf (\"%d\\n\", N);\n        return 0;\n    }\n\n    static int dp[301][301][302] = {};\n\n    Rep(ni,N) Rep(mi,N) {\n        int mir = N-1-mi;\n        bool same = S[ni] == S[mir];\n        RRep(ki,K+1){\n            // 無変換\n            dp[ni+1][mi+1][ki] = max( dp[ni][mi+1][ki], dp[ni+1][mi+1][ki] );\n            dp[ni+1][mi+1][ki] = max( dp[ni+1][mi][ki], dp[ni+1][mi+1][ki] );\n            dp[ni+1][mi+1][ki] = max( dp[ni][mi][ki]+same, dp[ni+1][mi+1][ki] );\n            // 変換\n            dp[ni+1][mi+1][ki+1] = max( dp[ni][mi][ki]+1, dp[ni+1][mi+1][ki+1] );\n        }\n    }\n\n    // Rep(ki,K+1){\n    //     Rep(ni,N+1) Rep(mi,N+1){\n    //         printf (\"%d%s\", dp[ni][mi][ki], mi!=N?\",\":\"\\n\" );\n    //     }\n    //     printf (\"---\\n\");\n    // }\n\n    int ans = 0;\n    Rep(ni,N+1) Rep(mi,N+1){\n        if( ni + mi > N ) break;\n        Rep(ki,K+1){\n            ans = max( dp[ni][mi][ki]*2+(ni+mi<N), ans );\n        }\n    }\n    printf (\"%d\\n\", ans );\n\n    return 0;\n}\n\n/**\natcodergrandcontest\natcoder\ng\natsetnocdn\n *\n */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x)  cerr << #x << \" = \" << x << endl\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ld PI = 3.14159265359;\n\nconst ll MOD = (ll) 998244353ll;\nconst ll MAXN = (ll) 3e2 + 10;\nconst ll INF = (ll) 2242545357980376863;\nconst ld EPS = (ld) 1e-8;\n\nll dp[2][MAXN][MAXN];\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tstr s;\n\tcin >> s;\n\tll n = s.size();\n\ts = '!' + s;\n\tll k;\n\tcin >> k;\n\tll ii, t, ans = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tii = i & 1;\n\t\tdebug(i);\n\t\tmemset(dp[ii], 0, sizeof dp[ii]);\n\t\tfor(int j = i + 1; j <= n; j++){\n\t\t\tif(s[i] == s[j]) t = 2;\n\t\t\telse t = 0;\n\t\t\t\n\t\t\tdp[ii][j][0] = max(dp[1 - ii][j][0], dp[1 - ii][j + 1][0] + t);\n\t\t\tfor(int l = 1; l <= k; l++){\n\t\t\t\tdp[ii][j][l] = max(dp[1 - ii][j][l], dp[1 - ii][j + 1][l] + t);\n\t\t\t\tdp[ii][j][l] = max(dp[ii][j][l], dp[1 - ii][j + 1][l - 1] + 2);\n\t\t\t\tans = max(ans, dp[ii][j][l] + (i + 1 < j ? 1 : 0));\n\t\t\t}\n\t\t\tans = max(ans, dp[ii][j][0] + (i + 1 < j ? 1 : 0));\n\t\t}\n\t}\n\tcout << ans;\n\treturn 0;\n}\n\n\n/*\n\n                                 ____              ,----..               ,----..\n   ,---,                       ,'  , `.           /   /   \\             /   /   \\\n  '  .' \\                   ,-+-,.' _ |          /   .     :           /   .     :\n /  ;    '.              ,-+-. ;   , ||         .   /   ;.  \\         .   /   ;.  \\\n:  :       \\            ,--.'|'   |  ;|        .   ;   /  ` ;        .   ;   /  ` ;\n:  |   /\\   \\          |   |  ,', |  ':        ;   |  ; \\ ; |        ;   |  ; \\ ; |\n|  :  ' ;.   :         |   | /  | |  ||        |   :  | ; | '        |   :  | ; | '\n|  |  ;/  \\   \\        '   | :  | :  |,        .   |  ' ' ' :        .   |  ' ' ' :\n'  :  | \\  \\ ,'        ;   . |  ; |--'         '   ;  \\; /  |        '   ;  \\; /  |\n|  |  '  '--'          |   : |  | ,             \\   \\  ',  /          \\   \\  ',  /\n|  :  :                |   : '  |/               ;   :    /            ;   :    /\n|  | ,'                ;   | |`-'                 \\   \\ .'              \\   \\ .'\n`--''                  |   ;/                      `---`                 `---`\n                       '---'\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define reg register\n#define max(a,b) (a>b?a:b)\ntypedef long long ll;\nint f[305][305][305];\nchar ch[305];\nint main(){\n\tscanf(\"%s\",ch+1);\n\treg int k,n=strlen(ch+1),ans=0;scanf(\"%d\",&k);\n\tfor(reg int i=1;i<=n;i++)\n\t\tfor(reg int j=0;j<=k;j++)\n\t\t\tf[i][i][j]=1;\n\tfor(reg int l=1;l<n;l++)\n\t\tfor(reg int i=1,j=i+l;j<=n;i++,j++)\n\t\t\tfor(reg int s=0;s<=k;s++){\n\t\t\t\tf[i][j][s]=max(f[i+1][j][s],f[i][j-1][s]);\n\t\t\t\tif(ch[i]==ch[j])f[i][j][s]=max(f[i][j][s],f[i+1][j-1][s]+2);\n\t\t\t\tif(s>0)f[i][j][s]=max(f[i][j][s],f[i+1][j-1][s-1]+2);\n\t\t\t}\n\tfor(reg int i=0;i<=k;i++)ans=max(ans,f[1][n][i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define finish(x) return cout << x << endl, 0\n#define ll long long\n\nconst int N = 301;\n\nint n, k, dp[N][N][N];\nstring s;\n\nint solve(int l, int r, int k){\n    if(r < l) return 0;\n    if(l == r) return 1;\n    int &ret = dp[l][r][k];\n    if(ret != -1) return ret;\n    ret = max(solve(l + 1, r, k), solve(l, r - 1, k));\n    if(s[l] == s[r]) ret = max(ret, solve(l + 1, r - 1, k) + 2);\n    else if(k > 0) ret = max(ret, solve(l + 1, r - 1, k - 1) + 2);\n    return ret;\n}\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    memset(dp, -1, sizeof dp);\n    cin >> s >> k;\n    n = s.size();\n    cout << solve(0, n - 1, k) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nint dp[400][400][400];\nsigned main(){\n\tstring s;int K;cin>>s>>K;\n\trep(i,s.size()){\n\t\tfor(int j=s.size()-1;j>i;j--){\n\t\t\trep(k,K+1){\n\t\t\t\tif(s[i]==s[j]){\n\t\t\t\t\tdp[i+1][j-1][k]=max(dp[i+1][j-1][k],dp[i][j][k]+1);\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tdp[i+1][j-1][k]=max(dp[i+1][j-1][k],dp[i][j][k]);\n\t\t\t\t\tdp[i+1][j][k]=max(dp[i+1][j][k],dp[i][j][k]);\n\t\t\t\t\tdp[i][j-1][k]=max(dp[i][j-1][k],dp[i][j][k]);\n\t\t\t\t\tif(k<K){\n\t\t\t\t\t\tdp[i+1][j-1][k+1]=max(dp[i+1][j-1][k+1],dp[i][j][k]+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint Max=0;\n\trep(i,s.size())rep(j,K+1){\n\t\tMax=max(Max,dp[i][i][j]);\n\t}\n\tcout<<Max*2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nint main(void) {\n  string S;\n  ll N, K;\n  cin >> S >> K;\n  N = S.length();\n\n  const ll INF = 1LL << 50;\n  ll dp[N][N][K + 1];\n  REP(l, 0, N) REP(r, l, N) REP(k, 0, K + 1) dp[l][r][k] = 0;\n  REP(l, 0, N) dp[l][l][0] = 1;\n  REP(l, 0, N - 1) dp[l][l + 1][0] = S[l] == S[l + 1] ? 2 : 0;\n  REP(s, 0, N) REP(l, 0, N - s) {\n    ll r = l + s;\n    REP(k, 0, K + 1) {\n      if(l + 1 <= r - 1 && S[l + 1] == S[r - 1]) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k] + 2);\n      if(l + 1 <= r) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r][k]);\n      if(l <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l][r - 1][k]);\n      if(k > 0) dp[l][r][k] = max(dp[l][r][k], dp[l][r][k - 1]);\n      if(k > 0 && l + 1 <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k - 1] + 2);\n    }\n  }\n  cout << dp[0][N - 1][K] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n//#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nint dp[333][333][333] = {};\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,x;\n  string s;\n  cin >> s >> x;\n\n  n = s.size();\n  REP(i,n) dp[i][i+1][0] = 1;\n\n  REP(len,n+1){\n    FOR(i,0,n+1){\n      int j = i+len;\n      if(j>n) break;\n      REP(k,x+1){\n        if(i) chmax(dp[i-1][j+1][k+(s[i-1]!=s[j])],dp[i][j][k]+2);\n        chmax(dp[i][j+1][k],dp[i][j][k]);\n        if(i) chmax(dp[i-1][j][k],dp[i][j][k]);\n      }\n    }\n  }\n\n  int ans = 0;\n  REP(i,x+1) chmax(ans,dp[0][n][i]);\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#define sqr(x) (x)*(x)\nusing namespace std;\nint n,m,i,j,dp[305][305][305],vis[305][305];\nstring st;\nvoid dfs(int l,int r)\n{\n\tif (l>r) return;\n\tif (vis[l][r]) return;\n\tvis[l][r]=1;\n\tif (l==r)\n\t{\n\t\tfill(dp[l][r],dp[l][r]+m+1,1);\n\t\treturn;\n\t}\n\tint i;\n\tdfs(l+1,r-1);\n\tdfs(l+1,r);\n\tdfs(l,r-1);\n\tfor (i=0;i<=m;i++)\n\t{\n\t\tdp[l][r][i]=0;\n\t\tif (st[l]==st[r]) dp[l][r][i]=max(dp[l][r][i],dp[l+1][r-1][i]+2);\n\t\telse\n\t\t{\n\t\t\tif (i) dp[l][r][i]=max(dp[l][r][i],dp[l+1][r-1][i-1]+2);\n\t\t\tdp[l][r][i]=max(dp[l][r][i],dp[l+1][r][i]);\n\t\t\tdp[l][r][i]=max(dp[l][r][i],dp[l][r-1][i]);\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>st>>m;\n\tst=\" \"+st;\n\tdfs(1,st.size()-1);\n\tcout<<dp[1][st.size()-1][m]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring S;\nint K;\n\nint main()\n{\n    cin >> S >> K;\n    int L = S.size();\n    vector<vector<vector<int> > > dp(L, vector<vector<int> >(L, vector<int>(K+1, 1)));\n\n    // 1文字 dp[i][i][k]は全部1\n    \n    // 2文字 dp[i][i+1][k]埋め\n    for (int i=0; i<L-1; i++)\n    {\n        dp[i][i+1] = vector<int>(K+1, 2);\n        if (S[i] != S[i+1]) dp[i][i+1][0] = 1;\n    }\n    for (int l=3; l<=L; l++)\n    {\n        for (int i=0; i<=L-l; i++)\n        {\n            if (S[i] == S[i+l-1])\n            {\n                for (int k=0; k<=K; k++) dp[i][i+l-1][k] = dp[i+1][i+l-2][k] + 2;\n            }\n            else\n            {\n                for (int k=0; k<=K; k++)\n                {\n                    int tmpmax = max(dp[i][i+l-2][k], dp[i+1][i+l-1][k]);\n                    if (k>0) tmpmax = max(tmpmax, dp[i][i+l-1][k-1]+2);\n                    dp[i][i+l-1][k] = tmpmax;\n                }                \n            }\n        }\n    }\n    cout << dp[0].back().back() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m, A, B;\n\nchar Ans[1010][1010];\n\nint main() {\n    scanf(\"%d%d%d%d\", &n, &m, &A, &B);\n    /*if((A + B) * 2 > n * m || A > m / 2 * n || B > n / 2 * m) {\n        puts(\"NO\");\n        return 0;\n    }*/\n    memset(Ans, '.', sizeof Ans);\n    if(n & 1) {\n        for(int i = 1; i < m && A; i += 2)\n            if(1) {\n                Ans[n][i] = '<';\n                Ans[n][i + 1] = '>';\n                A--;\n            }\n    }\n    if(m & 1) {\n        for(int i = n - 1; i >= 1 && B; i -= 2)\n            if(1) {\n                Ans[i][m] = '^';\n                Ans[i + 1][m] = 'v';\n                B--;\n            }\n    }\n    int N = n / 2 * 2, M = m / 2 * 2;\n    if(N * M < (A + B) * 2) {\n        puts(\"NO\");\n        return 0;\n    }\n    for(int i = 1; i < n; i += 2)\n        for(int j = 1; j < m; j += 2) if(!((n & 1) && (m & 1) && (i == 1 && j == m - 2))) {\n            if(A > 1) {\n                Ans[i][j] = '<';\n                Ans[i][j + 1] = '>';\n                if(A != 1) {\n                    Ans[i + 1][j] = '<';\n                    Ans[i + 1][j + 1] = '>';\n                    A -= 2;\n                } else A--;\n            } else if(B > 1) {\n                Ans[i][j] = '^';\n                Ans[i + 1][j] = 'v';\n                if(B != 1) {\n                    Ans[i][j + 1] = '^';\n                    Ans[i + 1][j + 1] = 'v';\n                    B -= 2;\n                } else B--;\n            } else if(A == 1) {\n                \n                Ans[i][j] = '<';\n                Ans[i][j + 1] = '>';\n                A--;\n            } else if(B == 1) {\n                Ans[i][j] = '^';\n                Ans[i + 1][j] = 'v';\n                B--;\n            }\n        }\n    if(A || B) {\n        if(B == 0 && A <= 2) {\n            int i = 1, j = m - 2;\n            Ans[i][j] = '<';\n            Ans[i][j + 1] = '>';\n            if(A != 1) {\n                Ans[i + 1][j] = '<';\n                Ans[i + 1][j + 1] = '>';\n                A -= 2;\n            } else A--;\n        } else if(A == 0 && B <= 2) {\n            int i = 1, j = m - 2;\n            Ans[i][j] = '^';\n            Ans[i + 1][j] = 'v';\n            if(B != 1) {\n                Ans[i][j + 1] = '^';\n                Ans[i + 1][j + 1] = 'v';\n                B -= 2;\n            } else B--;\n        } else if((n & 1) && (m & 1) && A == 1 && B == 1) {\n            Ans[1][m - 2] = '^';\n            Ans[2][m - 2] = 'v';\n            Ans[1][m - 1] = '<';\n            Ans[1][m] = '>';\n        } else {\n            puts(\"NO\");\n            return 0;\n        }\n    }\n    puts(\"YES\");\n    for(int i = 1; i <= n; i++) {\n        for(int j = 1; j <= m; j++) putchar(Ans[i][j]);\n        putchar('\\n');\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define int long long\n\n#define all(X) (X).begin(), (X).end()\n#define reset(X) memset(X, 0, sizeof(X))\n#define mp(a, b) make_pair(a, b)\n#define pb push_back\n#define endl '\\n'\n#define fi first\n#define se second\n\nusing namespace __gnu_pbds;\nusing namespace std;\nconst int mod = 1e9 + 7;\n// const int mod=998244353;\n//const int mod=1e9+9;\n//const int INF=4e18+10;\nconst int INF = 4e18 + 10;\ntemplate <typename T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T>\nusing ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define read(n) \\\nint n;      \\\ncin >> n;\n#define readv(x, n)   \\\nvector<int> x(n); \\\nfor (auto &i : x) \\\n    cin >> i;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> pii;\n\ntemplate <typename T1, typename T2>\nvoid set_min(T1 &a, T2 b)\n{\n    a = min(a, (T1)b);\n}\n\nint multiply(int a, int b, int in_mod) { return (a * b) % in_mod; }\nint mult_identity(int a) { return 1; }\n\n\nauto power(auto a, int b, int in_mod)\n{\n    auto prod = mult_identity(a);\n    auto mult = a % in_mod;\n    while (b != 0)\n    {\n        if (b % 2)\n        {\n            prod = multiply(prod, mult, in_mod);\n        }\n        mult = multiply(mult, mult, in_mod);\n        b /= 2;\n    }\n    return prod;\n}\nint mod_inv(int q, int in_mod)\n{\n\n    return power(q, in_mod - 2, in_mod);\n}\n\n\nconst int MAXN = 1e5+100;\nint parent[MAXN];\nvoid build()\n{\n    for(int i=0;i<MAXN;i++)\n        parent[i] = i;\n}\n\nint find_set(int u)\n{\n    if( u== parent[u])\n        return u;\n    return parent[u] = find_set(parent[u]);\n}\nvoid merge(int u, int v)\n{\n    u= find_set(u);\n    v= find_set(v);\n    if(u!=v)\n    {\n        if(rand()%2)\n            swap(u,v);\n        parent[v] = u;\n    }\n\n}\n\nvoid solve()\n{\n    string s;\n    cin>>s;\n    int k;\n    cin>>k;\n    int n= s.size();\n    string c = s;\n    reverse(all(c));\n    k*=2;\n    vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(n+1, vector<int>(k+1)));\n\n    for(int i= 1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)\n        {\n            for(int _k= 0;_k<=k;_k++)\n            {\n                if(c[i-1] == s[j-1])\n                    dp[i][j][_k] = dp[i-1][j-1][_k] + 1;\n                else\n                {\n                    dp[i][j][_k] = max(dp[i-1][j][_k], dp[i][j-1][_k]);\n                    if(_k)\n                        dp[i][j][_k] = max(dp[i][j][_k], dp[i-1][j-1][_k-1] + 1);\n                }\n            }\n        }\n    }\n    int mx= 0;\n    for(int i= 0;i<=k;i+=2)\n        mx = max(mx, dp[n][n][i]);\n    cout<<mx<<endl;\n\n}\n\n\n\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cerr.tie(NULL);\n#ifndef ONLINE_JUDGE\n    if (fopen(\"INPUT.txt\", \"r\"))\n    {\n        freopen(\"INPUT.txt\", \"r\", stdin);\n        freopen(\"OUTPUT.txt\", \"w\", stdout);\n    }\n#endif\n    auto clk = clock();\n    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n    // -------------------------------------Code starts here---------------------------------------------------------------------\n\n    int t = 1;\n    // cin >> t;\n\n    for (int test = 1; test <= t; test++)\n    {\n        // cout<<\"Case #\"<<test<<\":\\n\";\n        //cout<<\"Trip #\"<<test<<\": \";\n        // cout<<endl;\n        solve();\n        // solveB();\n\n        // cout<<endl;\n    }\n\n    // -------------------------------------Code ends here------------------------------------------------------------------\n\n    clk = clock() - clk;\n    // cerr << fixed << setprecision(6) << \"Time: \" << ((long double)clk) / CLOCKS_PER_SEC << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\nusing namespace std;\n#define MOD 1000000007\n#define rep(i,m,n) for(int (i)=(int)(m);i<(int)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ll long long\n#define ull unsigned long long\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconst long long INF = 1LL << 60;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\n\n\n//priority_queue<ll> max;//大きい順\n//priority_queue<ll, Array, greater<ll>> min;//小さい順\n\n/*firstについては昇順 secondについては降順\nsort(all(wh), [&](P x, P y) {\n\tif (x.first == y.first)return x.second > y.second;\n\treturn x.first < y.first;\n});\n*/\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n//substr　文字列取り出し\n//upper_bound ある値より大きい一番左のイテレータを返す、lowerは以上(setに対して使うとO(N)なので、setのメンバ関数を使う\n//stoi\n\n\nstruct Edge {//グラフ\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, ll from, ll to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\nll max_flow_dfs(Graph & G, ll v, ll t, ll f, vector<bool> & used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph & G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d, Array &negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 2) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 2) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\td[i][G[i][j].to] = G[i][j].cap;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, vector<int>& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tlca() {}\n\n\tlca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unionSet(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tint numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\nclass SumSegTree {\nprivate:\n\n\tint _sum(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return 0;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tint s1 = _sum(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tint s2 = _sum(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn s1 + s2;\n\t\t}\n\t}\npublic:\n\tint n, height;\n\tvector<int> dat;\n\n\t// 初期化（_nは最大要素数）\n\tSumSegTree(int _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<int>(2 * n - 1, 0);\n\t}\n\n\t// 場所i(0-indexed)にxを足す\n\tvoid add(int i, int x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] += x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] += x;\n\t\t}\n\t}\n\n\t// 区間[a,b)の総和。ノードk=[l,r)に着目している。\n\tint sum(int a, int b) {\n\t\treturn _sum(a, b, 0, 0, n);\n\t}\n};\nclass RmqTree {\nprivate:\n\n\tP _find(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return make_pair(INF,INF);    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tP s1 = _find(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tP s2 = _find(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn min(s1, s2);\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<P> dat;\n\n\t// 初期化（_nは最大要素数）\n\tRmqTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<P>(2 * n - 1, make_pair(INF,INF));\n\t}\n\n\t// 場所i(0-indexed)をxにする\n\tvoid update(ll i, ll x) {\n\t\tll num = i;\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] = make_pair(x,num);\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\n\t// 区間[a,b)の最小値。ノードk=[l,r)に着目している。\n\tP find(ll a, ll b) {\n\t\treturn _find(a, b, 0, 0, n);\n\t}\n};\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\n}\n\nvector<ll> lis_fast(const vector<ll>& a) {//最長部分増加列\n\tconst ll n = a.size();\n\tvector<ll> A(n, INT_MAX);\n\tvector<ll> id(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tid[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n\t\tA[id[i]] = a[i];\n\t}\n\tll m = *max_element(id.begin(), id.end());\n\tvector<ll> b(m + 1);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tif (id[i] == m) b[m--] = a[i];\n\treturn b;\n}\n\n\nll ModPow(ll x, ll n) {\n\tll res = 1LL;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % MOD;\n\t\tx = x * x % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//nCrとか\nclass Combination {\npublic:\n\tArray fact;\n\tArray inv;\n\tll mod;\n\tll mod_inv(ll x) {\n\t\tll n = mod - 2LL;\n\t\tll res = 1LL;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res = res * x % mod;\n\t\t\tx = x * x % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tll nCr(ll n, ll r) {\n\t\treturn ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll n, ll _mod) {\n\t\tmod = _mod;\n\t\tfact.resize(n + 1);\n\t\tfact[0] = 1;\n\t\tREP(i, n) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tinv.resize(n + 1);\n\t\tREP(i, n + 1) {\n\t\t\tinv[i] = mod_inv(fact[i]);\n\t\t}\n\t}\n};\n\nll gcd(ll m, ll n) {\n\tif (n == 0)return m;\n\treturn gcd(n, m % n);\n}//gcd\n\nll lcm(ll m, ll n) {\n\treturn m / gcd(m, n) * n;\n}\n\n\nMatrix mIdentity(ll n) {\n\tMatrix A(n, Array(n));\n\tfor (int i = 0; i < n; ++i) A[i][i] = 1;\n\treturn A;\n}\n\nMatrix mMul(const Matrix& A, const Matrix& B) {\n\tMatrix C(A.size(), Array(B[0].size()));\n\tfor (int i = 0; i < C.size(); ++i)\n\t\tfor (int j = 0; j < C[i].size(); ++j)\n\t\t\tfor (int k = 0; k < A[i].size(); ++k)\n\t\t\t\t(C[i][j] += (A[i][k] % MOD) * (B[k][j] % MOD)) %= MOD;\n\treturn C;\n}\n// O( n^3 log e )\nMatrix mPow(const Matrix & A, ll e) {\n\treturn e == 0 ? mIdentity(A.size()) :\n\t\te % 2 == 0 ? mPow(mMul(A, A), e / 2) : mMul(A, mPow(A, e - 1));\n}\n\ntemplate <class T>class RectangleSum {\npublic:\n\tvector<vector<T>> sum;\n\tT GetSum(int left, int right, int top, int bottom) { //[left, right], [top, bottom]\n\t\tT res = sum[bottom][right];\n\t\tif (left > 0) res -= sum[bottom][left - 1];\n\t\tif (top > 0) res -= sum[top - 1][right];\n\t\tif (left > 0 && top > 0) res += sum[top - 1][left - 1];\n\t\treturn res;\n\t}\n\tRectangleSum(const vector<vector<T>> &s, int h, int w) {\n\t\tsum.resize(h);\n\t\tfor (int i = 0; i < h; i++) sum[i].resize(w, 0);\n\t\tfor (int y = 0; y < h; y++) {\n\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\tsum[y][x] = s[y][x];\n\t\t\t\tif (y > 0) sum[y][x] += sum[y - 1][x];\n\t\t\t\tif (x > 0) sum[y][x] += sum[y][x - 1];\n\t\t\t\tif (y > 0 && x > 0) sum[y][x] -= sum[y - 1][x - 1];\n\t\t\t}\n\t\t}\n\t}\n};\n\n\nll dp[310][310][310];\nstring s;\n\nll solve(ll l, ll r, ll k) {\n\tif (dp[l][r][k] != -1)return dp[l][r][k];\n\tif (r - l < 0)return 0;\n\tif (r - l == 0)return 1;\n\tif (r - l == 1) {\n\t\tif (s[l] == s[r] || k >= 1)return 2;\n\t\telse return 1;\n\t}\n\n\tll mx = 0;\n\tif (s[l] == s[r])chmax(mx, solve(l + 1, r - 1, k)+2);\n\telse if (k >= 1)chmax(mx, solve(l + 1, r - 1, k - 1) + 2);\n\tchmax(mx, solve(l + 1, r, k));\n\tchmax(mx, solve(l, r - 1, k));\n\n\treturn dp[l][r][k] = mx;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> s;\n\tll k;\n\tcin >> k;\n\tmemset(dp, -1, sizeof(dp));\n\tcout << solve(0, s.size() - 1, k);\n\t\n\t\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring st;\nint dp[310][310][310],K;\nint dfs(int l,int r,int x){\n    if(r<l)return 0;\n    if(l==r)return 1;\n    if(dp[l][r][x]!=-1)return dp[l][r][x];\n    int res=max(dfs(l+1,r,x),dfs(l,r-1,x));\n    if(st[l]==st[r])res=max(res,dfs(l+1,r-1,x)+2);\n    if(x)res=max(res,dfs(l+1,r-1,x-1)+2);\n    return dp[l][r][x]=res;\n}\nint main(){\n    cin>>st>>K;\n    memset(dp,-1,sizeof(dp));\n    cout<<dfs(0,st.size()-1,K)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __clang__\n#pragma GCC optimize \"-O3\"\n#pragma GCC target \"tune=native\"\n#endif\n#ifdef ONLINE_JUDGE\n#define NDEBUG 1\n#endif\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n#define FOR(i, n)     for(lli i = 0; i < (lli)(n); ++i)\n#define FORU(i, j, k) for(lli i = (j); i <= (lli)(k); ++i)\n#define FORD(i, j, k) for(lli i = (j); i >= (lli)(k); --i)\n\n#define SQ(x) ((x)*(x))\n\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntemplate<typename... As>\nstruct tpl : public std::tuple<As...> {\n  using std::tuple<As...>::tuple;\n  tpl(){}\n  tpl(std::tuple<As...> const& b) { std::tuple<As...>::operator=(b); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type const&\n  x() const { return get<0>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<0, T>::type&\n  x() { return get<0>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type const&\n  y() const { return get<1>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<1, T>::type&\n  y() { return get<1>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type const&\n  z() const { return get<2>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<2, T>::type&\n  z() { return get<2>(*this); }\n\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type const&\n  w() const { return get<3>(*this); }\n  template<typename T = tuple<As...> >\n  typename tuple_element<3, T>::type&\n  w() { return get<3>(*this); }\n};\n\nusing lli   = long long int;\nusing llu   = long long unsigned;\n\nusing pii   = tpl<lli, lli>;\nusing piii  = tpl<lli, lli, lli>;\nusing piiii = tpl<lli, lli, lli, lli>;\nusing vi    = vector<lli>;\nusing vii   = vector<pii>;\nusing viii  = vector<piii>;\nusing vvi   = vector<vi>;\nusing vvii  = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\ntemplate<size_t... I>\nstruct my_index_sequence {\n  using type = my_index_sequence;\n  static constexpr array<size_t, sizeof...(I)> value = { {I...} };\n};\n\nnamespace my_index_sequence_detail {\n  template<typename I, typename J> struct concat;\n  template<size_t... I, size_t... J>\n  struct concat<my_index_sequence<I...>, my_index_sequence<J...> > :\n    my_index_sequence<I..., (sizeof...(I)+J)...> { };\n  template<size_t N> struct make_index_sequence :\n    concat<typename make_index_sequence<N/2>::type, typename make_index_sequence<N-N/2>::type>::type { };\n  template <> struct make_index_sequence<0> : my_index_sequence<>{};\n  template <> struct make_index_sequence<1> : my_index_sequence<0>{};\n}\n\ntemplate<class... A>\nusing my_index_sequence_for = typename my_index_sequence_detail::make_index_sequence<sizeof...(A)>::type;\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, my_index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a);\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a);\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tpl<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, my_index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\n//------------------------------------------------------------------------------\n\nconst int N = 300;\nint dp[N+1][N][N+1];\n\nvoid mw(int& a, int b) { a = max(a,b); }\n\nint main(){\n  ios::sync_with_stdio(0); cin.tie(0);\n  string s; cin>>s;\n  int k; cin>>k;\n  int n = s.size();\n  FOR(i,n+1) dp[0][i][0] = 0;\n  FOR(i,n) dp[1][i][0] = 1;\n  FORU(l,0,n-1) {\n    FOR(i,n-l+1) FOR(j,k+1) {\n      if(i) mw(dp[l+1][i-1][j], dp[l][i][j]);\n      if(i < n-l) mw(dp[l+1][i][j], dp[l][i][j]);\n      if(i && i<n-l) {\n        if(s[i-1] == s[i+l]) {\n          mw(dp[l+2][i-1][j], dp[l][i][j]+2);\n        }else{\n          mw(dp[l+2][i-1][j+1], dp[l][i][j]+2);\n        }\n      }\n    }\n  }\n  int ans = 0;\n  FOR(j,k+1) ans = max(ans,dp[n][0][j]);\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef LOCAL\n#define cerr dolor_sit_amet\n#endif\n\n#define mp make_pair\n#define sz(x) ((int)((x).size()))\n#define X first\n#define Y second\n#define ALL(x) (x).begin(), (x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair < int , int > ipair;\ntypedef pair < ll , ll > lpair;\nconst int IINF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = numeric_limits<double>::infinity();\nconst int MOD = 1000000007;\nconst double EPS = 1e-9;\nconst int DX[] = { 1,  0, -1,  0,  1, -1,  1, -1};\nconst int DY[] = { 0,  1,  0, -1,  1, -1, -1,  1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll sqr(ll x) { return x*x; } ll sqr(int x) { return (ll)x*x; }\ndouble sqr(double x) { return x*x; } ld sqr(ld x) { return x*x; }\nmt19937 mmtw(960172);\nll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(mmtw) % (y - x + 1) + x; }\n\n// ========================================================================= //\n\nconst int N = 303;\n\nstring s;\nint kk;\nint d[N][N][N];\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    cin >> s >> kk;\n    int n = sz(s);\n    for (int i = 0; i <= n; ++i)\n        for (int j = 0; i + j <= n; ++j)\n            for (int k = 0; k <= kk; ++k) {\n                if (i == 0 || j == 0) {\n                    d[i][j][k] = 0;\n                } else {\n                    int &cd = d[i][j][k];\n                    cd = (k == 0 ? 0 : d[i][j][k-1]);\n                    cd = max(cd, d[i-1][j][k]);\n                    cd = max(cd, d[i][j-1][k]);\n                    if (s[i - 1] == s[n - j])\n                        cd = max(cd, d[i-1][j-1][k] + 1);\n                    else if (k != 0)\n                        cd = max(cd, d[i-1][j-1][k - 1] + 1);\n                }\n            }\n\n    int ans = 0;\n    for (int i = 0; i < n; ++i)\n        ans = max(ans, 1 + d[i][n-i-1][kk] * 2);\n    for (int i = 1; i < n; ++i)\n        ans = max(ans, d[i][n-i][kk] * 2);\n    cout << ans << \"\\n\";\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\nusing namespace std;\nconst int N=308;\nint n,m,ans,a[N][N][N];\nchar b[N];\nint maxx(int x,int y){if(x>y)y=x;return y;}\nint main(void)\n{\n\tint i,j,k;\n\tscanf(\"%s%d\",b+1,&m);\n\tn=strlen(b+1);ans=1;\n\tfor(i=1;i<=n;i++)for(j=0;j<=m;j++)a[j][i][i]=1;\n\tfor(k=0;k<=m;k++)\n\tfor(i=n;i>=1;i--)\n\tfor(j=i+1;j<=n;j++)\n\t{\n\t\tif(k){a[k][i][j]=maxx(a[k][i][j],a[k-1][i][j]);}\n\t\tif(k){a[k][i][j]=maxx(a[k][i][j],2+a[k-1][i+1][j-1]);}\n\t\ta[k][i][j]=maxx(a[k][i][j],maxx(maxx(a[k][i+1][j],a[k][i][j-1]),(b[i]==b[j])*(2+a[k][i+1][j-1])));\n\t}\n\tcout<<a[m][1][n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n#define pb push_back\n#define mp make_pair\nint dp[301][301][601];\nint main()\n{\n    int i,j;\n    string a;\n    int k;\n    cin>>a;\n    cin>>k;\n    int n=a.size();\n    if(k>=(n/2))\n            {cout<<n<<endl;\n             return 0;\n            }\n            int z=1;\n    for(z=0;z<=2*k;z++)\n  {\n\n    for(i=1;i<=n;i++)\n    {\n        for(j=n;j>=1;j--)\n        {\n          int o=n-j+1;\n\n              if(i!=j)\n              {    if(z!=0)\n                      dp[i][o][z]=max(dp[i][o][z],dp[i][o][z-1]);\n                  if(a[i-1]==a[j-1])\n                     dp[i][o][z]=max(dp[i][o][z],1+dp[i-1][o-1][z]);\n                  else\n                  {\n                      if(z!=0)\n                      dp[i][o][z]=max(dp[i][o][z],dp[i-1][o-1][z-1]+1);\n\n                      dp[i][o][z]=max(dp[i][o][z],max(dp[i-1][o][z],dp[i][o-1][z]));\n\n                  }\n\n\n              }\n              else{\n                 if(k!=0)\n                      dp[i][o][k]=dp[i][o][k-1];\n                 dp[i][o][z]=max(dp[i][o][z],1+dp[i-1][o-1][z]);\n\n\n                }\n\n\n        }\n\n\n\n\n    }\n\n\n\n\n\n  }\n  int ans=0;\n\n        ans=dp[n][n][2*k];\n\n\n    cout<<ans<<endl;\nreturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define Debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned int uint;\ntypedef pair <int, int> pii;\ntypedef unsigned long long uLL;\n\ntemplate <typename T> inline void Read(T &x) {\n  char c = getchar();\n  bool f = false;\n  for (x = 0; !isdigit(c); c = getchar()) {\n    if (c == '-') {\n      f = true;\n    }\n  }\n  for (; isdigit(c); c = getchar()) {\n    x = x * 10 + c - '0';\n  }\n  if (f) {\n    x = -x;\n  }\n}\n\ntemplate <typename T> inline bool CheckMax(T &a, const T &b) {\n  return a < b ? a = b, true : false;\n}\n\ntemplate <typename T> inline bool CheckMin(T &a, const T &b) {\n  return a > b ? a = b, true : false;\n}\n\nconst int N = 305;\n\nint n, m, ans, f[N][N][N];\nchar s[N];\n\ninline int Solve(int l, int r, int k) {\n  if (l >= r) {\n    return r - l + 1;\n  }\n  if (f[l][r][k]) {\n    return f[l][r][k];\n  }\n  f[l][r][k] = max(Solve(l + 1, r, k), Solve(l, r - 1, k));\n  if (s[l] == s[r]) {\n    CheckMax(f[l][r][k], Solve(l + 1, r - 1, k) + 2);\n  } else if (k) {\n    CheckMax(f[l][r][k], Solve(l + 1, r - 1, k - 1) + 2);\n  }\n  return f[l][r][k];\n}\n\nint main() {\n#ifdef wxh010910\n  freopen(\"d.in\", \"r\", stdin);\n#endif\n  scanf(\"%s\", s + 1), n = strlen(s + 1), Read(m);\n  for (int i = 1; i <= n; ++i) {\n    for (int j = i; j <= n; ++j) {\n      CheckMax(ans, Solve(i, j, m));\n    }\n  }\n  printf(\"%d\\n\", ans);\n#ifdef wxh010910\n  Debug(\"My Time: %.3lfms\\n\", (double)clock() / CLOCKS_PER_SEC);\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n#define pb push_back\n#define mp make_pair\nint dp[301][301][301];\nint main()\n{\n    int i,j;\n    string a;\n    int k1;\n    cin>>a;\n    cin>>k1;\n    int n=a.size();\n\n            int k;\n    for(k=0;k<=k1;k++)\n  {\n\n    for(i=1;i<=n;i++)\n    {\n        for(j=1;j<=n-i+1;j++)\n        {\n            int o=j+i-1;\n            dp[j][o][k]=max(dp[j][o][k],dp[j][o][k-1]);\n\n            if(i==1)\n               dp[j][o][k]=1;\n               else\n               {\n\n                  if(a[j-1]==a[o-1])\n                  {\n\n                      dp[j][o][k]=max(dp[j][o][k],dp[j+1][o-1][k]+2);\n                  }\n                  else{\n\n                    if(k!=0)\n                         dp[j][o][k]=max(dp[j][o][k],dp[j+1][o-1][k-1]+2);\n\n                     dp[j][o][k]=max(dp[j][o][k],dp[j+1][o][k]);\n                      dp[j][o][k]=max(dp[j][o][k],dp[j][o-1][k]);\n\n\n\n                  }\n\n\n\n               }\n\n\n\n        }\n\n\n        }\n\n\n\n\n    }\n\n\n\n\n\n\n  int ans=0;\n  for(k=0;k<=k1;k++)\n    for(i=1;i<=n;i++)\n    for(j=i;j<=n;j++)\n\n        ans=max(ans,dp[i][j][k]);\n\n\n    cout<<ans<<endl;\nreturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)   FOR(i,0,n)\n#define LL long long\n\nstring s;\nint k,n;\n\nint dp[300][300][301];\n\nint main(){\n  cin>>s>>k;\n  n=s.size();\n  FOR(d,1,n+1){\n    FOR(init,0,n-d+1){\n      REP(l,k+1){\n\tif(d==1)dp[init][init+d-1][l]=1;\n\telse if(l==0){\n\t  if(s[init]==s[init+d-1])\n\t    dp[init][init+d-1][0]=(d==2)?2:2+dp[init+1][init+d-2][0];\n\t  else\n\t    dp[init][init+d-1][0]=max(dp[init][init+d-2][0],dp[init+1][init+d-1][0]);\n\t}else{\n\t  if(s[init]==s[init+d-1]){\n\t    dp[init][init+d-1][l]=(d==2)?2:2+dp[init+1][init+d-2][l];\n\t  }else{\n\t    dp[init][init+d-1][l]=(d==2)?2:max(max(dp[init][init+d-2][l],dp[init+1][init+d-1][l]),2+dp[init+1][init+d-2][l-1]);\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<dp[0][n-1][k]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define MAXN 100005\n#define eps 1e-8\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nchar s[305];\nint K,dp[305][305][305],N;\nvoid update(int &x,int y) {\n    x = max(x,y);\n}\nvoid Solve() {\n    scanf(\"%s\",s + 1);\n    read(K);\n    N = strlen(s + 1);\n    for(int i = 1 ; i <= N ; ++i) dp[i][i][0] = 1;\n    for(int d = 2 ; d <= N ; ++d) {\n\tfor(int i = 1 ; i <= N ; ++i) {\n\t    int j = i + d - 1;\n\t    if(j > N) break;\n\t    for(int k = 0 ; k <= K ; ++k) {\n\t\tif(k) update(dp[i][j][k],dp[i][j][k - 1]);\n\t\tupdate(dp[i][j][k],dp[i + 1][j][k]);\n\t\tupdate(dp[i][j][k],dp[i][j - 1][k]);\n\t\tif(s[i] == s[j]) update(dp[i][j][k],dp[i + 1][j - 1][k] + 2);\n\t\telse if(k) update(dp[i][j][k],dp[i + 1][j - 1][k - 1] + 2);\n\t    }\n\t}\n    }\n    out(dp[1][N][K]);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\ntemplate <typename H, typename ...Tail>\nH max(const H &head, const Tail&... tail) {\n\tauto tail_max = max(tail...);\n\treturn head > tail_max ? head : tail_max;\n}\ntemplate <typename H>\nH max(const H &head) {\n\treturn head;\n}\n\nint max_lcs(const std::string &str, int l, int r, int k, std::vector<std::vector<std::vector<int>>> &memo) {\n\tif (l > r) return -2;\n\tif (k < 0) return -2;\n\tif (l == r) return 1;\n\tif (memo[l][r][k] >= 0) return memo[l][r][k];\n\tauto &res = memo[l][r][k];\n\tif (str[l] == str[r]) {\n\t\tres = max_lcs(str, l + 1, r - 1, k, memo) + 2;\n\t}\n\telse {\n\t\tres = max_lcs(str, l + 1, r - 1, k, memo);\n\t}\n\tres = max(res, max_lcs(str, l + 1, r, k, memo), max_lcs(str, l, r - 1, k, memo), max_lcs(str, l + 1, r - 1, k - 1, memo) + 2);\n\t//std::cout << \"l = \" << l << \" ,r = \" << r << \" ,k = \" << k << \" ,res = \" << res << std::endl;\n\treturn res;\n}\nint max_lcs(const std::string &str, int k) {\n\tstd::vector<std::vector<std::vector<int>>> memo(str.size() + 1, std::vector<std::vector<int>>(str.size() + 1, std::vector<int>(k + 1, -1)));\n\treturn max_lcs(str, 0, str.size() - 1, k, memo);\n}\n\nint main() {\n\tstd::string str;\n\tint k;\n\tstd::cin >> str >> k;\n\tstd::cout << max_lcs(str, k) << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x)  cerr << #x << \" = \" << x << endl\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ld PI = 3.14159265359;\n\nconst ll MOD = (ll) 998244353ll;\nconst ll MAXN = (ll) 3e2 + 10;\nconst ll INF = (ll) 2242545357980376863;\nconst ld EPS = (ld) 1e-8;\n\nll dp[2][MAXN][MAXN];\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tstr s;\n\tcin >> s;\n\tll n = s.size();\n\ts = '!' + s;\n\tll k;\n\tcin >> k;\n\tll ii, t, ans = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tii = i & 1;\n\t\t//debug(i);\n\t\tmemset(dp[ii], 0, sizeof dp[ii]);\n\t\tfor(int j = n; j > i; j--){\n\t\t\tif(s[i] == s[j]) t = 2;\n\t\t\telse t = 0;\n\t\t\t\n\t\t\tdp[ii][j][0] = max({dp[1 - ii][j][0], dp[1 - ii][j + 1][0] + t, dp[ii][j + 1][0]});\n\t\t\tfor(int l = 1; l <= k; l++){\n\t\t\t\tdp[ii][j][l] = max({dp[1 - ii][j][l], dp[1 - ii][j + 1][l] + t, dp[ii][j + 1][l]});\n\t\t\t\tdp[ii][j][l] = max(dp[ii][j][l], dp[1 - ii][j + 1][l - 1] + 2);\n\t\t\t\tans = max(ans, dp[ii][j][l] + (i + 1 < j ? 1 : 0));\n\t\t\t}\n\t\t\tans = max(ans, dp[ii][j][0] + (i + 1 < j ? 1 : 0));\n\t\t}\n\t}\n\tcout << ans;\n\treturn 0;\n}\n\n\n/*\n\n                                 ____              ,----..               ,----..\n   ,---,                       ,'  , `.           /   /   \\             /   /   \\\n  '  .' \\                   ,-+-,.' _ |          /   .     :           /   .     :\n /  ;    '.              ,-+-. ;   , ||         .   /   ;.  \\         .   /   ;.  \\\n:  :       \\            ,--.'|'   |  ;|        .   ;   /  ` ;        .   ;   /  ` ;\n:  |   /\\   \\          |   |  ,', |  ':        ;   |  ; \\ ; |        ;   |  ; \\ ; |\n|  :  ' ;.   :         |   | /  | |  ||        |   :  | ; | '        |   :  | ; | '\n|  |  ;/  \\   \\        '   | :  | :  |,        .   |  ' ' ' :        .   |  ' ' ' :\n'  :  | \\  \\ ,'        ;   . |  ; |--'         '   ;  \\; /  |        '   ;  \\; /  |\n|  |  '  '--'          |   : |  | ,             \\   \\  ',  /          \\   \\  ',  /\n|  :  :                |   : '  |/               ;   :    /            ;   :    /\n|  | ,'                ;   | |`-'                 \\   \\ .'              \\   \\ .'\n`--''                  |   ;/                      `---`                 `---`\n                       '---'\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint dp[301][301][301];\nint main()\n{\n\tstring str;\n\tint q;\n\tcin>>str>>q;\n\tint l=str.size();\n//\tcout<<l<<endl;\n\tfor(int i=l-1;i>=0;i--)\n\t{\n\t\tfor(int k=0;k<=q;k++)\n\t\t\tdp[i][i][k]=1;\n\t}\n\tfor(int i=l-1;i>=0;i--)\n\t{\n\t\t\n\t\tfor(int j=i+1;j<=l-1;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=q;k++)\n\t\t\t{\n\t\t\t\t//dp[i][i][k]=1; \n\t\t\t\tif(str[i]==str[j]) dp[i][j][k]=max(dp[i+1][j-1][k]+2,dp[i][j][k]);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tif(k!=0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][j][k]=max(dp[i+1][j-1][k-1]+2,dp[i][j][k]);\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j][k]=max(dp[i+1][j][k],dp[i][j][k]);\n\t\t\t\t\tdp[i][j][k]=max(dp[i][j-1][k],dp[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int k=0;k<=q;k++)\n\t\t\tans=max(ans,dp[0][l-1][k]);\n\tcout<<ans<<endl;\n } "
  },
  {
    "language": "C++",
    "code": "//ProblemD\n\n#ifdef _MYPC\n#include \"mypc.h\"\n#endif // _MYPC\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <memory>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\n//ProblemD\n#define MAXL 300\n\nclass Solve {\nprivate:\n\tstring S;\n\tint K;\n\tint n;\n\n\tint dp[MAXL+1][MAXL+1][MAXL+1]{};\n\n\tvoid solve() {\n\t\tcin >> S >> K;\n\t\tn = S.length();\n\n\t\tfor (int k = 0; k <= K; k++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tdp[k][i][i + 0] = 1;\n\t\t\t}\n\n\t\t\tfor (int l = 1; l < n; l++) {\n\t\t\t\tfor (int i = 0; i < n - l; i++) {\n\t\t\t\t\tint j = i + l;\n\n\t\t\t\t\tif (S[i] == S[j]) {\n\t\t\t\t\t\tdp[k][i][j] = 2 + dp[k][i + 1][j - 1];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[k][i][j] = max(dp[k][i+1][j], dp[k][i][j-1]);\n\t\t\t\t\t\tif (k > 0) {\n\t\t\t\t\t\t\tdp[k][i][j] = max(dp[k][i][j], 2 + dp[k-1][i+1][j - 1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << dp[K][0][n - 1] << endl;\n\t}\n\npublic:\n\tSolve() { solve(); }\n};\n\nint main(int argc, char* argv[]) {\n\tunique_ptr<Solve> solve = make_unique<Solve>();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int maxn = 303;\nint f[maxn][maxn][maxn] , l , k;\nchar s[maxn];\nint main(){\n\tcin >> s + 1 >> k;\n\tl = strlen(s + 1);\n\tmemset(f , -1 , sizeof f);\n\tf[0][l + 1][0] = 0;\n\tint ans = 0;\n\tfor(int c = 0 ; c <= k ; ++ c){\n\t\tfor(int i = 1 ; i < l ; ++ i){\n\t\t\tfor(int j = l + 1 ; j > i ; -- j){\n\t\t\t\tif(s[i] == s[j])\n\t\t\t\t\tf[i][j][c] = max(f[i][j][c] , f[i - 1][j + 1][c] + 1);\n\t\t\t\telse if(c > 0)\n\t\t\t\t\tf[i][j][c] = max(f[i][j][c] , f[i - 1][j + 1][c - 1] + 1);\n\t\t\t\tf[i][j][c] = max(f[i][j][c] , f[i - 1][j][c]);\n\t\t\t\tf[i][j][c] = max(f[i][j][c] , f[i][j + 1][c]);\n\t\t\t}\n\t\t\tans = max(ans , f[i][i + 1][c] * 2);\n\t\t\tif(i < l - 1)\n\t\t\t\tans = max(ans , f[i][i + 2][c] * 2 + 1);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define MN 1000000\n#define mod 998244353\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint p[MN+5],inv[MN+5],n,m,ans;\ninline int C(int n,int m){return m<=n?1LL*p[n]*inv[m]%mod*inv[n-m]%mod:0;}\nint main()\n{\n\tinv[0]=inv[1]=p[0]=p[1]=1;\n\tfor(int i=2;i<=MN;++i) inv[i]=1LL*(mod-mod/i)*inv[mod%i]%mod,p[i]=1LL*p[i-1]*i%mod;\n\tfor(int i=2;i<=MN;++i) inv[i]=1LL*inv[i-1]*inv[i]%mod;\n\tn=read();m=read();\n\tfor(int i=0;i<=m;++i) if((i&1)==(m&1))\n\t{\n\t\tint u=(m+i)/2,d=(m-i)/2;\n\t\t//if(u<n) continue;\n\t\tans=(ans+C(m,u))%mod;\n\t//\tcout<<i<<\" \"<<C(m,u)<<endl; \n\t\tif(i<n)\n\t\t{\n\t\t\tint up=-d+(n-i)-1;\n\t\t\t//Way(0,2*up,m,i)\n\t\t\tif(up>=0) ans=(ans-C(m,u)+mod)%mod;\n\t\t\telse ans=(ans-C(m,(m+i-2*up)/2)+mod)%mod;\n\t\t\t//cout<<i<<\" gg \"<<up<<\" C\"<<m<<\" \"<<(m+i-2*up)<<\"/2 \"<<C(m,(m+i-2*up)/2)<<endl;\n\t\t}\t\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#undef _DEBUG\n//#pragma GCC optimize(\"Ofast\")\n//不動小数点の計算高速化\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace std::chrono;\n#define int long long //todo 消したら動かない intの代わりにsignedを使う\n#define ll long long\nauto start_time = system_clock::now();\nauto past_time = system_clock::now();\n\n#define debugName(VariableName) # VariableName\n//最大引数がN\n#define over2(o1, o2, name, ...) name\n#define over3(o1, o2, o3, name, ...) name\n#define over4(o1, o2, o3, o4, name, ...) name\n#define over5(o1, o2, o3, o4, o5, name, ...) name\n#define over6(o1, o2, o3, o4, o5, o6, name, ...) name\n#define over7(o1, o2, o3, o4, o5, o6, o7, name, ...) name\n#define over8(o1, o2, o3, o4, o5, o6, o7, o8, name, ...) name\n#define over9(o1, o2, o3, o4, o5, o6, o7, o8, o9, name, ...) name\n#define over10(o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, name, ...) name\n\n\n/*@formatter:off*/\n//[-n, n)にアクセスできる\n//また、外部関数resizeに渡せる\n//sizeは[-n, n)でnを返す\ntemplate<class T> class mvec {    vector<T> v;    int n;public:    mvec() : n(0), v(0) {}    mvec(int n) : n(n), v(n * 2) {}    mvec(int n, T val) : n(n), v(n * 2, val) {}    auto &operator[](int i) { return v[i + n]; }    auto size() { return n; }    void resize(int sn) {        assert(n == 0);        n = sn;        v.resize(sn * 2);    }    auto begin() { return v.begin(); }    auto rbegin() { return v.rbegin(); }    auto end() { return v.end(); }    auto rend() { return v.rend(); }};\n//[]でboolは参照を返さないため特殊化が必要\ntemplate<> struct mvec<bool> {    vector<bool> v;    int n;    mvec() : n(0), v(0) {}    mvec(int n) : n(n), v(n * 2) {}    mvec(int n, bool val) : n(n), v(n * 2, val) {}    auto operator[](int i) { return v[i + n]; }    auto size() { return v.size(); }    void resize(int sn) {        assert(n == 0);        n = sn;        v.resize(sn * 2);    }    auto begin() { return v.begin(); }    auto rbegin() { return v.rbegin(); }    auto end() { return v.end(); }    auto rend() { return v.rend(); }};\ntemplate<class T>ostream &operator<<(ostream &os, mvec<T>& a) {    int spa = 3;    for(auto&&v : a){        spa = max(spa,(int)(to_string(v).size())+1);    }    int n = (int)a.size();    os<<endl;    for (int i = -n; i < n; i++){        int need = spa - ((int)to_string(i).size());        if(i==-n){            need -= min(need,spa - ((int)to_string(a[i]).size()));        }        while(need--){            os<<\" \";        }        os<<i;    }    os<<endl;    int i=-n;    for(auto&&v : a){        int need = spa - ((int)to_string(v).size());        if(i==-n){            need -= min(need,spa - ((int)to_string(i).size()));        }        while(need--){            os<<\" \";        }        os<<v;        i++;    }    return os;}\n#define mv mvec\n#define MV mvec\nusing mvi = mvec<ll>;\nusing mvb = mvec<bool>;\nusing mvs = mvec<string>;\nusing mvd = mvec<double>;\nusing mvc = mvec<char>;\n\n#define mvvt0(t) mvec<mvec<t>>\n#define mvvt1(t,a) mvec<mvec<t>>a\n#define mvvt2(t,a, b) mvec<mvec<t>>a(b)\n#define mvvt3(t,a, b, c) mvec<mvec<t>> a(b,mvec<t>(c))\n#define mvvt4(t,a, b, c, d) mvec<mvec<t>> a(b,mvec<t>(c,d))\n#define mvvi(...) over4(__VA_ARGS__,mvvt4,mvvt3,mvvt2 ,mvvt1,mvvt0)(ll,__VA_ARGS__)\n\ntemplate<typename T> mvec<T> make_mv(size_t a) { return mvec<T>(a); }\ntemplate<typename T, typename... Ts> auto make_mv(size_t a, Ts... ts) {return mvec<decltype(make_mv<T>(ts...))>(a, make_mv<T>(ts...));}\n#define mvni(name, ...) auto name = make_mv<ll>(__VA_ARGS__)\n\n\n#ifdef _DEBUG\nstring message;\nstring res_mes;\n//https://marycore.jp/prog/cpp/class-extension-methods/ 違うかも\ntemplate<class T, class A = std::allocator<T>> struct debtor : std::vector<T, A> {\n    using std::vector<T, A>::vector;\n    /*@formatter:on*/\n    template<class U> int deb_v(U a, int v) { return v; }\n    template<class U> int deb_v(debtor<U> &a, int v = 0) {\n        cerr << a.size() << \" \";\n        return deb_v(a.at(0), v + 1);\n    }\n    template<class U> void deb_o(U a) { cerr << a << \" \"; }\n    template<class U> void deb_o(debtor<U> &a) {\n        for (int i = 0; i < min((int) a.size(), 15ll); i++) { deb_o(a[i]); }\n        if ((int) a.size() > 15) { cerr << \"...\"; }\n        cerr << endl;\n    }\n    typename std::vector<T>::reference my_at(typename std::vector<T>::size_type n, vector<int> &ind) {\n        if (n < 0 || n >= (int) this->size()) {\n            int siz = (int) this->size();\n            cerr << \"vector size = \";\n            int dim = deb_v((*this));\n            cerr << endl;\n            ind.push_back(n);\n            cerr << \"out index at  \";\n            for (auto &&i: ind) {\n                cerr << i << \" \";\n            }\n            cerr << endl;\n            cerr << endl;\n            if (dim <= 2) { deb_o((*this)); }\n            exit(0);\n        }\n        return this->at(n);\n    }\n    typename std::vector<T>::reference operator[](typename std::vector<T>::size_type n) {\n        if (n < 0 || n >= (int) this->size()) {\n            int siz = (int) this->size();\n            cerr << \"vector size = \";\n            int dim = deb_v((*this));\n            cerr << endl;\n            cerr << \"out index at  \" << n << endl;\n            cerr << endl;\n            if (dim <= 2) { deb_o((*this)); }\n            exit(0);\n        }\n        return this->at(n);\n    }\n};\n/*@formatter:off*/\n#define vector debtor\n//区間削除は出来ない\ntemplate<class T> struct my_pbds_tree {    set<T> s;    auto begin() { return s.begin(); }    auto end() { return s.end(); }    auto rbegin() { return s.rbegin(); }    auto rend() { return s.rend(); }    auto empty() { return s.empty(); }    auto size() { return s.size(); }    void clear() { s.clear(); }    template<class U> void insert(U v) { s.insert(v); }template<class U> void operator+=(U v) { insert(v); }    template<class F> auto erase(F v) { return s.erase(v); }    template<class U> auto find(U v) { return s.find(v); }    template<class U> auto lower_bound(U v) { return s.lower_bound(v); }    template<class U> auto upper_bound(U v) { return s.upper_bound(v); }    auto find_by_order(ll k) {        auto it = s.begin();        for (ll i = 0; i < k; i++)it++;        return it;    }    auto order_of_key(ll v) {        auto it = s.begin();        ll i=0;        for (;it != s.end() && *it <v ; i++)it++;        return i;    }};\n#define pbds(T) my_pbds_tree<T>\n//gp_hash_tableでcountを使えないようにするため\ntemplate<class T,class U> struct my_unordered_map{    unordered_map<T,U> m;    my_unordered_map(){};    auto begin(){        return m.begin();    }    auto end(){return m.end();}    auto cbegin(){return m.cbegin();}    auto cend(){return m.cend();}    template<class V>auto erase(V v){return m.erase(v);}    void clear(){m.clear();}    /*countは gp_hash_tableに存在しない*/    /*!= m.end()*/    template<class V>auto find(V v){return m.find(v);}    template<class V>auto & operator [](V n) { return m[n] ;}};\n#define unordered_map my_unordered_map\n#define umapi unordered_map<ll,ll>\n#define umapp unordered_map<P,ll>\n#define umapu unordered_map<uint64_t,ll>\n#define umapip unordered_map<ll,P>\ntemplate<class T,class U, class X> auto count (unordered_map<T,U>& a, X k){return a.find(k) != a.end();}\n#else\n#define endl '\\n'\n//umapはunorderd_mapになる\n//umapiはgp_hash_table\n\n//find_by_order(k) k番目のイテレーター\n//order_of_key(k)  k以上が前から何番目か\n#define pbds(U) __gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>\n\n#define umapi __gnu_pbds::gp_hash_table<ll,ll,xorshift>\n#define umapp __gnu_pbds::gp_hash_table<P,ll,xorshift>\n#define umapu __gnu_pbds::gp_hash_table<uint64_t,ll,xorshift>\n#define umapip __gnu_pbds::gp_hash_table<ll,P,xorshift>\ntemplate<class T,class U,class W, class X>auto count (__gnu_pbds::gp_hash_table<T,U,W>& a, X k){return a.find(k) != a.end();}\n#endif\n\n\n/*@formatter:on*/\nstruct xorshift {\n    static uint64_t splitmix64(uint64_t x) {\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n    size_t operator()(std::pair<ll, ll> x) const {\n        ll v = ((x.first) << 32) | x.second;\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(v + FIXED_RANDOM);\n    }\n};\n/*@formatter:off*/\ntemplate<class U, class L> void operator+=(__gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update> &s, L v) { s.insert(v); }\n//衝突対策\n#define ws ws_\n\ntemplate<class A, class B, class C>struct T2 {A f;B s;C t;T2() { f = 0, s = 0, t = 0; }T2(A f, B s, C t) : f(f), s(s), t(t) {}bool operator<(const T2 &r) const {        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;        /*return f != r.f ? f > r.f : s != r.s ?n s > r.s : t > r.t; 大きい順 */   }    bool operator>(const T2 &r) const {        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;        /*return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順 */   }    bool operator==(const T2 &r) const {        return f == r.f && s == r.s && t == r.t;    }    bool operator!=(const T2 &r) const {        return f != r.f || s != r.s || t != r.t;    }};\ntemplate<class A, class B, class C, class D> struct F2 {    A a;    B b;    C c;    D d;    F2() { a = 0, b = 0, c = 0, d = 0; }    F2(A a, B b, C c, D d) : a(a), b(b), c(c), d(d) {}    bool operator<(const F2 &r) const {        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;    /*    return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;*/    }    bool operator>(const F2 &r) const {        return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;/*        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;*/    }    bool operator==(const F2 &r) const {        return a == r.a && b == r.b && c == r.c && d == r.d;    }    bool operator!=(const F2 &r) const {        return a != r.a || b != r.b || c != r.c || d != r.d;    }    ll operator[](ll i) {        assert(i < 4);        return i == 0 ? a : i == 1 ? b : i == 2 ? c : d;    }};\ntypedef T2<ll, ll, ll> T;\ntypedef F2<ll, ll, ll, ll> F;\nT mt(ll a, ll b, ll c) {return T(a, b, c);}\nF mf(ll a, ll b, ll c, ll d) {return F(a, b, c, d);}\n\n\n\n//@マクロ省略系 型,構造\n//using で元のdoubleを同時に使えるはず\n#define double_big\n\n#ifdef double_big\n    #define double long double\n    #define pow powl\n#endif\nusing dou = double;\nconst double eps = 1e-9;\n//基本コメントアウト\n//struct epsdou {    double v;    epsdou(double v = 0) : v(v) {}    template<class T> epsdou &operator+=(T b) {        v += (double) b;        return (*this);    }    template<class T> epsdou &operator-=(T b) {        v -= (double) b;        return (*this);    }    template<class T> epsdou &operator*=(T b) {        v *= (double) b;        return (*this);    }    template<class T> epsdou &operator/=(T b) {        v /= (double) b;        return (*this);    }    epsdou operator+(epsdou b) { return v + (double) b; }    epsdou operator-(epsdou b) { return v - (double) b; }    epsdou operator*(epsdou b) { return v * (double) b; }    epsdou operator/(epsdou b) { return v / (double) b; }    epsdou operator-() const { return epsdou(-v); }    template<class T> bool operator<(T b) { return v < (double) b; }    template<class T> bool operator>(T b) { return v > (double) b; }    template<class T> bool operator==(T b) { return fabs(v - (double) b) <= eps; }    template<class T> bool operator<=(T b) { return v < (double) b || fabs(v - b) <= eps; }    template<class T> bool operator>=(T b) { return v > (double) b || fabs(v - b) <= eps; }    operator double() { return v; }};istream &operator>>(istream &iss, epsdou &a) {    iss >> a.v;    return iss;}ostream &operator<<(ostream &os, epsdou &a) {    os << a.v;    return os;}\n//#define eps_conr_t(o) template<class T> epsdou operator o(T a, epsdou b) {return (dou) a o b.v;}\n//#define eps_conl_t(o) template<class T> epsdou operator o(epsdou a, T b) {return a.v o (dou) b;}\n//eps_conl_t(+)eps_conl_t(-)eps_conl_t(*)eps_conl_t(/)eps_conr_t(+)eps_conr_t(-)eps_conr_t(*)eps_conr_t(/)\n//#undef double\n//#define double epsdou\n\n/*@formatter:off*/\n#define ull unsigned long long\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\nusing mvp = mvec<P>;\nusing mvt = mvec<T>;\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\n\n#define fi first\n#define se second\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n#define el else\n#define elf else if\n#define upd update\n#define sstream stringstream\n\n#define maxq 1\n#define minq -1\n\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MALLOC(type, len) (type*)malloc((len) * sizeof(type))\n#define lam1(ret) [&](auto& v){return ret;}\n#define lam2(v, ret) [&](auto& v){return ret;}\n#define lam(...) over2(__VA_ARGS__,lam2,lam1)(__VA_ARGS__)\n#define lamr(right) [&](auto& p){return p right;}\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\n//マクロ省略系 コンテナ\nusing vi = vector<ll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vp = vector<P>;\nusing vt = vector<T>;\n\n//#define V vector\n#define vvt0(t) vector<vector<t>>\n#define vvt1(t,a) vector<vector<t>>a\n#define vvt2(t,a, b) vector<vector<t>>a(b)\n#define vvt3(t,a, b, c) vector<vector<t>> a(b,vector<t>(c))\n#define vvt4(t,a, b, c, d) vector<vector<t>> a(b,vector<t>(c,d))\n\n#define vvi(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(ll,__VA_ARGS__)\n#define vvb(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(bool,__VA_ARGS__)\n#define vvs(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(string,__VA_ARGS__)\n#define vvd(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(double,__VA_ARGS__)\n#define vvc(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(char,__VA_ARGS__)\n#define vvp(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(P,__VA_ARGS__)\n#define vvt(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(T,__VA_ARGS__)\n#define vv(type,...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(type,__VA_ARGS__)\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts> auto make_v(size_t a, Ts... ts) {return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));}\n#define vni(name, ...) auto name = make_v<ll>(__VA_ARGS__)\n#define vnb(name, ...) auto name = make_v<bool>(__VA_ARGS__)\n#define vns(name, ...) auto name = make_v<string>(__VA_ARGS__)\n#define vnd(name, ...) auto name = make_v<double>(__VA_ARGS__)\n#define vnc(name, ...) auto name = make_v<char>(__VA_ARGS__)\n#define vnp(name, ...) auto name = make_v<P>(__VA_ARGS__)\n#define vn(type,name, ...) auto name = make_v<type>(__VA_ARGS__)\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<ll, ll>;\nusing mapp = map<P, ll>;\nusing mapd = map<dou, ll>;\nusing mapc = map<char, ll>;\nusing maps = map<str, ll>;\nusing seti = set<ll>;\nusing setp = set<P>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<ll>;\n#define uset unordered_set\n#define useti unordered_set<ll,xorshift>\n#define mset multiset\n#define mseti multiset<ll>\n#define umap unordered_map\n#define mmap multimap\n//任意のマクロサポート用 使う度に初期化する\nint index_,v1_,v2_,v3_;\n\ntemplate<class T> struct pq {\n    priority_queue<T, vector<T>, greater<T> > q;/*小さい順*/    T su = 0;\n    void clear() {        q = priority_queue<T, vector<T>, greater<T> >();        su = 0;    }\n    void operator+=(T v) {        su += v;        q.push(v);    }\n    T sum() { return su; }\n    T top() { return q.top(); }\n    void pop() {        su -= q.top();        q.pop();    }\n    T poll() {        T ret = q.top();        su -= ret;        q.pop();        return ret;    }\n    ll size() { return q.size(); }\n};\ntemplate<class T> struct pqg {\n    priority_queue<T> q;/*大きい順*/    T su = 0;\n    void clear() {        q = priority_queue<T>();        su = 0;    }\n    void operator+=(T v) {        su += v;        q.push(v);    }\n    T sum() { return su; }\n    T top() { return q.top(); }\n    void pop() {        su -= q.top();        q.pop();    }\n    T poll() {        T ret = q.top();        su -= ret;        q.pop();        return ret;    }\n    ll size() { return q.size(); }\n};\n#define pqi pq<ll>\n#define pqgi pqg<ll>\n//マクロ 繰り返し\n//↓@オーバーロード隔離\n\n#define rep1(n) for(ll rep1i = 0,rep1lim=n; rep1i < rep1lim ; ++rep1i)\n#define rep2(i, n) for(ll i = 0,rep2lim=n; i < rep2lim ; ++i)\n#define rep3(i, m, n) for(ll i = m,rep3lim=n; i < rep3lim ; ++i)\n#define rep4(i, m, n, ad) for(ll i = m,rep4lim=n; i < rep4lim ; i+= ad)\n//逆順 閉区間\n#define rer2(i, n) for(ll i = n; i >= 0 ; i--)\n#define rer3(i, m, n) for(ll i = m,rer3lim=n; i >= rer3lim ; i--)\n#define rer4(i, m, n, dec) for(ll i = m,rer4lim=n; i >= rer4lim ; i-=dec)\n//ループを一つにまとめないとフォーマットで汚くなるため\n#define nex_ind1(i) i++\n#define nex_ind2(i, j, J) i = (j + 1 == J) ? i + 1 : i, j = (j + 1 == J ? 0 : j + 1)\n#define nex_ind3(i, j, k, J, K)i = (j + 1 == J && k + 1 == K) ? i + 1 : i, j = (k + 1 == K) ? (j + 1 == J ? 0 : j + 1) : j, k = (k + 1 == K ? 0 : k + 1)\n#define nex_ind4(i, j, k, l, J, K, L) i = (j + 1 == J && k + 1 == K && l + 1 == L) ? i + 1 : i, j = (k + 1 == K && l + 1 == L) ? (j + 1 == J ? 0 : j + 1) : j, k = (l + 1 == L ?(k + 1 == K ? 0 : k + 1) : k), l = l + 1 == L ? 0 : l + 1\n#define nex_ind5(i, j, k, l, m, J, K, L, M) i = (j + 1 == J && k + 1 == K && l + 1 == L && m + 1 == M) ? i + 1 : i, j = (k + 1 == K && l + 1 == L && m + 1 == M) ? (j + 1 == J ? 0 : j + 1) : j, k = (l + 1 == L && m + 1 == M ?(k + 1 == K ? 0 : k + 1) : k), l =  m + 1 == M ? l+1 == L ? 0 : l+1 : l,  m = m + 1 == M ? 0 : m + 1\n\n#define repss2(i, I) for (int i = 0; i < I; i++)\n#define repss4(i, j, I, J) for (int i = (J ? 0 : I), j = 0; i < I; nex_ind2(i, j, J))\n#define repss6(i, j, k, I, J, K) for (int i = (J && K ? 0 : I), j = 0, k = 0; i < I; nex_ind3(i, j, k, J, K))\n#define repss8(i, j, k, l, I, J, K, L) for (int i = (J && K && L ? 0 : I), j = 0, k = 0, l = 0; i < I; nex_ind4(i, j, k, l, J, K, L))\n#define repss10(i, j, k, l, m, I, J, K, L, M)for (int i = (J && K && L && M ? 0 : I), j = 0, k = 0, l = 0, m = 0; i < I; nex_ind5(i, j, k, l, m, J, K, L, M))\n\n//i,j,k...をnまで見る\n#define reps2(i, n) repss2(i, n)\n#define reps3(i, j, n) repss4(i, j, n, n)\n#define reps4(i, j, k, n) repss6(i, j, k, n, n, n)\n#define reps5(i, j, k, l, n) repss8(i, j, k, l, n, n, n, n)\n\ntemplate<class T>void nex_repv2(int&i,int&j,int&I, int&J,vector<vector<T>>&s){    while(1){        j++;        if(j >= J){            j=0;            i++;            if(i < I){                J = (int)s[i].size();            }        }        if(i >= I || J) return;    }}\ntemplate<class T> void nex_repv3(int &i, int &j, int &k, int &I, int &J, int &K, vector<vector<vector<T>>> &s) {    while (1) {        k++;        if (k >= K) {            k = 0;            j++;            if (j >= J) {                j = 0;                i++;                if (i >= I)return;            }        }        J = (int) s[i].size();        K = (int) s[i][j].size();        if (J && K) return;    }}\n\n#define repv_2(i,a) repss2(i, sz(a))\n//正方形である必要はない\n//直前を持つのとどっちが早いか\n#define repv_3(i, j, a) for (int repvI = (int)a.size(), repvJ = (int)a[0].size(), i = 0, j = 0; i < repvI; nex_repv2(i,j,repvI,repvJ,a))\n//箱状になっている事が要求される つまり[i] 次元目の要素数は一定\n#define repv_4(i, j, k, a) for (int repvI = (int)a.size(), repvJ = (int)a[0].size(), repvK =(int)a[0][0].size(), i = 0, j = 0, k=0; i < repvI; nex_repv3(i,j,k,repvI,repvJ,repvK,a))\n#define repv_5(i, j, k, l, a) repss8(i, j, k, l, sz(a), sz(a[0]), sz(a[0][0]), sz(a[0][0][0]))\n#define repv_6(i, j, k, l, m, a) repss10(i, j, k, l, m, sz(a), sz(a[0]), sz(a[0][0]), sz(a[0][0][0]), sz(a[0][0][0][0]))\n\ntemplate<typename T>struct has_rbegin_rend {private:template<typename U>static auto check(U &&obj) -> decltype(std::rbegin(obj), std::rend(obj), std::true_type{});static std::false_type check(...);public:static constexpr bool value = decltype(check(std::declval<T>()))::value;};template<typename T>constexpr bool has_rbegin_rend_v = has_rbegin_rend<T>::value;template<typename Iterator>class Range {public:Range(Iterator &&begin, Iterator &&end) noexcept: m_begin(std::forward<Iterator>(begin)), m_end(std::forward<Iterator>(end)) {}Iterator begin() const noexcept {return m_begin;}Iterator end() const noexcept {return m_end;}private:const Iterator m_begin;const Iterator m_end;};template<typename Iterator>static inline Range<Iterator>makeRange(Iterator &&begin, Iterator &&end) noexcept {return Range<Iterator>{std::forward<Iterator>(begin), std::forward<Iterator>(end)};}template<typename T>static inline decltype(auto) makeReversedRange(const std::initializer_list<T> &iniList) noexcept {return makeRange(std::rbegin(iniList), std::rend(iniList));}template<typename T,typename std::enable_if_t<has_rbegin_rend_v<T>, std::nullptr_t> = nullptr>static inline decltype(auto)makeReversedRange(T &&c) noexcept {return makeRange(std::rbegin(c), std::rend(c));}/* rbegin(), rend()を持たないものはこっちに分岐させて，エラーメッセージを少なくする*/template<typename T,typename std::enable_if<!has_rbegin_rend<T>::value, std::nullptr_t>::type = nullptr>static inline void makeReversedRange(T &&) noexcept {static_assert(has_rbegin_rend<T>::value, \"Specified argument doesn't have reverse iterator.\");}\n\n#define form1(st) for (auto &&form_it = st.begin(); form_it != st.end(); ++form_it)\n#define form3(k, v, st) for (auto &&form_it = st.begin(); form_it != st.end(); ++form_it)\n#define form4(k, v, st, r) for (auto &&form_it = st.begin(); form_it != st.end() && (*form_it).fi < r; ++form_it)\n#define form5(k, v, st, l, r) for (auto &&form_it = st.lower_bound(l); form_it != st.end() && (*form_it).fi < r; ++form_it)\n\n#define forrm1(st) for (auto &&forrm_it = st.rbegin(); forrm_it != st.rend(); ++forrm_it)\n#define forrm3(k, v, st) for (auto &&forrm_it = st.rbegin(); forrm_it != st.rend(); ++forrm_it)\n\n#define fors1(st) for (auto &&fors_it = st.begin(); fors_it != st.end(); ++fors_it)\n#define fors2(v, st) for (auto &&fors_it = st.begin(); fors_it != st.end(); ++fors_it)\n#define fors3(v, st, r) for (auto &&fors_it = st.begin(); fors_it != st.end() && (*fors_it) < r; ++fors_it)\n#define fors4(v, st, l, r) for (auto &&fors_it = st.lower_bound(l); fors_it != st.end() && (*fors_it) < r; ++fors_it)\n\n#define forslr3(st, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end(); ++forslr_it)\n#define forslr4(v, st, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end(); ++forslr_it)\n#define forslr5(v, st, r, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end() && (*forslr_it) < r; ++forslr_it)\n#define forslr6(v, st, l, r, a, b) for (auto &&forslr_it = st.lower_bound(l); forslr_it != st.end() && (*forslr_it) < r; ++forslr_it)\n\ntemplate<class U> vector<U>to1d(vector<U>& a){return a;}\ntemplate<class U> vector<U>to1d(vector<vector<U>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)res.push_back(a2);return res;}\ntemplate<class U> vector<U>to1d(vector<vector<vector<U>>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)for(auto&& a3 : a2) res.push_back(a3);return res;}\ntemplate<class U> vector<U>to1d(vector<vector<vector<vector<U>>>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)for(auto&& a3 : a2) for(auto&& a4 : a3)res.push_back(a4);return res;}\ntemplate<class U> vector<U>to1d(vector<vector<vector<vector<vector<U>>>>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)for(auto&& a3 : a2) for(auto&& a4 : a3)for(auto&& a5 : a4)res.push_back(a5);return res;}\ntemplate<class U> vector<U>to1d(vector<vector<vector<vector<vector<vector<U>>>>>>&a){vector<U> res;for(auto&& a1 : a)for(auto&& a2 : a1)for(auto&& a3 : a2) for(auto&& a4 : a3)for(auto&& a5 : a4)for(auto&& a6 : a5)res.push_back(a6);return res;}\n\n#define fora_init_2(a, A) ;\n#define fora_init_3(fora_i, a, A) auto &&a = A[fora_i];\n#define fora_init_4(a, b, A, B) auto &&a = A[fora_i]; auto &&b = B[fora_i];\n#define fora_init_5(fora_i, a, b, A, B) auto &&a = A[fora_i]; auto &&b = B[fora_i];\n#define fora_init_6(a, b, c, A, B, C) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i];\n#define fora_init_7(fora_i, a, b, c, A, B, C) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i];\n#define fora_init_8(a, b, c, d, A, B, C, D) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i]; auto && d = D[fora_i];\n#define fora_init_9(fora_i, a, b, c, d, A, B, C, D) auto &&a = A[fora_i]; auto &&b = B[fora_i]; auto &&c = C[fora_i]; auto && d = D[fora_i];\n#define fora_init(...) over9(__VA_ARGS__,fora_init_9, fora_init_8, fora_init_7, fora_init_6, fora_init_5, fora_init_4, fora_init_3, fora_init_2)(__VA_ARGS__)\n\n#define forr_init_2(a, A) auto &&a = A[forr_i];\n#define forr_init_3(forr_i, a, A) auto &&a = A[forr_i];\n#define forr_init_4(a, b, A, B) auto &&a = A[forr_i]; auto &&b = B[forr_i];\n#define forr_init_5(forr_i, a, b, A, B) auto &&a = A[forr_i]; auto &&b = B[forr_i];\n#define forr_init_6(a, b, c, A, B, C) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i];\n#define forr_init_7(forr_i, a, b, c, A, B, C) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i];\n#define forr_init_8(a, b, c, d, A, B, C, D) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i]; auto && d = D[forr_i];\n#define forr_init_9(forr_i, a, b, c, d, A, B, C, D) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i]; auto && d = D[forr_i];\n#define forr_init(...) over9(__VA_ARGS__, forr_init_9, forr_init_8, forr_init_7, forr_init_6, forr_init_5, forr_init_4, forr_init_3, forr_init_2)(__VA_ARGS__)\n\n\n#define forp_init(k, v, ...) auto &&k = (*forp_it).fi;auto &&v = (*forp_it).se;\n#define form_init(k, v, ...) auto &&k = (*form_it).fi;auto &&v = (*form_it).se;\n#define forrm_init(k, v, ...) auto &&k = (*forrm_it).fi;auto &&v = (*forrm_it).se;\n#define fors_init(v, ...) auto &&v = (*fors_it);\n\n#define forlr_init(a,A,ngl,ngr) auto a = A[forlr_i]; auto prev = forlr_i ? A[forlr_i-1] : ngl;auto next = forlr_i+1< rep2lim? A[forlr_i+1] : ngr;\n#define forslr_init4(a, A, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init5(a, A, r, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init6(a, A, l, r, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init(...)  over6(__VA_ARGS__,forslr_init6,forslr_init5,forslr_init4)(__VA_ARGS__);\n\n#define fora_2(a, A) for(auto&& a : A)\n#define fora_3(fora_i, a, A) rep(fora_i, sz(A))\n#define fora_4(a, b, A, B) rep(fora_i, sz(A))\n#define fora_5(fora_i, a, b, A, B) rep(fora_i, sz(A))\n#define fora_6(a, b, c, A, B, C) rep(fora_i, sz(A))\n#define fora_7(fora_i, a, b, c, A, B, C) rep(fora_i, sz(A))\n#define fora_8(a, b, c, d, A, B, C, D) rep(fora_i, sz(A))\n#define fora_9(fora_i, a, b, c, d, A, B, C, D) rep(fora_i, sz(A))\n\n#define forr_2(a, A) rer(forr_i, sz(A)-1)\n#define forr_3(forr_i, a, A) rer(forr_i, sz(A)-1)\n#define forr_4(a, b, A, B) rer(forr_i, sz(A)-1)\n#define forr_5(forr_i, a, b, A, B) rer(forr_i, sz(A)-1)\n#define forr_6(a, b, c, A, B, C) rer(forr_i, sz(A)-1)\n#define forr_7(forr_i, a, b, c, A, B, C) rer(forr_i, sz(A)-1)\n#define forr_8(a, b, c, d, A, B, C, D) rer(forr_i, sz(A)-1)\n#define forr_9(forr_i, a, b, c, d, A, B, C, D) rer(forr_i, sz(A)-1)\n\n//↑@オーバーロード隔離\n\n//rep系はインデックス、for系は中身\n#define rep(...) over4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rer(...) over4(__VA_ARGS__,rer4,rer3,rer2,)(__VA_ARGS__)\n//char用のrep\n#define repc(i, m, n) for(char i = m,repc3lim=n; i < repc3lim ; ++i)\n//i,j,k...をnまで見る\n#define reps(...) over5(__VA_ARGS__,reps5,reps4,reps3,reps2,)(__VA_ARGS__)\n#define repss(...) over10(__VA_ARGS__, repss10, a, repss8, a, repss6, a, repss4, a, repss2) (__VA_ARGS__)\n//vectorのindexを走査する\n//repv(i,j,vvi)\n#define repv(...) over6(__VA_ARGS__,repv_6,repv_5,repv_4,repv_3,repv_2,)(__VA_ARGS__)\n#define rerv(i, A) for (int i = sz(A)-1; i >= 0 ; i--)\n//repvn(dp) nは次元\n#define repv1(a) repv(i, a)\n#define repv2(a) repv(i, j, a)\n#define repv3(a) repv(i, j, k, a)\n#define repv4(a) repv(i, j, k, l, a)\n\n#define fora(...) over9(__VA_ARGS__, fora_9, fora_8, fora_7, fora_6, fora_5, fora_4, fora_3, fora_2)(__VA_ARGS__)\n#define forr(...) over9(__VA_ARGS__, forr_9, forr_8, forr_7, forr_6, forr_5, forr_4, forr_3, forr_2)(__VA_ARGS__)\n\n//#define forr(v, a) for(auto&& v : makeReversedRange(a))\n//参照を取らない\n#define forv(a, b) for(auto a : to1d(b))\n\n//インデックスを前後含めて走査\n#define ring(i, s, len) for (int i = s, prev = (s == 0) ? len - 1 : s - 1, next = (s == len - 1) ? 0 : s + 1, cou = 0; cou < len; cou++, prev = i, i = next, next = (next == len - 1) ? 0 : next + 1)\n//値と前後を見る\n#define ringv(v, d) index_=0;for (auto prev = d[sz(d)-1],next= (int)d.size()>1?d[1]:d[0],v = d[0]; index_ < sz(d); index_++, prev = v, v = next, next = (index_>=sz(d)-1?d[0]:d[index_+1]))\n// 左右をnext prevで見る 0の左と nの右\n#define forlr(v, d, banpei_l, banpei_r) rep(forlr_i,sz(d))\n\n#define form(...) over5(__VA_ARGS__,form5,form4,form3,form2,form1)(__VA_ARGS__)\n#define forrm(...) over5(__VA_ARGS__,forrm5,forrm4,forrm3,forrm2,forrm1)(__VA_ARGS__)\n#define fors(...) over4(__VA_ARGS__,fors4,fors3,fors2,fors1)(__VA_ARGS__)\n#define forslr(...) over6(__VA_ARGS__,forslr6,forslr5,forslr4,forslr3)(__VA_ARGS__)\n#define forp(k, v, st) for (auto &&forp_it = st.begin(); forp_it != st.end(); ++forp_it)\n\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst ll inf = (ll) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst dou dinf = (dou) linf * linf;\nconst char infc = '{';\nconst string infs = \"{\";\nconst double PI = 3.1415926535897932384626433832795029L;\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((ll)(a).size())\n#define mp make_pair\n#define pb pop_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconstexpr bool ev(ll a) { return !(a & 1); }\nconstexpr bool od(ll a) { return (a & 1); }\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> { public:size_t operator()(const std::pair<signed, signed> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n    template<> class hash<std::pair<ll, ll>> { public:/*大きいllが渡されると、<<32でオーバーフローするがとりあえず問題ないと判断*/size_t operator()(const std::pair<ll, ll> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n}\n//stream まとめ\n/*@formatter:on*/\nistream &operator>>(istream &iss, P &a) {\n    iss >> a.first >> a.second;\n    return iss;\n}\ntemplate<typename T> istream &operator>>(istream &iss, vector<T> &vec_) {\n    for (T &x: vec_) iss >> x;\n    return iss;\n}\ntemplate<class T, class U> ostream &operator<<(ostream &os, pair<T, U> p) {\n    os << p.fi << \" \" << p.se;\n    return os;\n}\nostream &operator<<(ostream &os, T p) {\n    os << p.f << \" \" << p.s << \" \" << p.t;\n    return os;\n}\nostream &operator<<(ostream &os, F p) {\n    os << p.a << \" \" << p.b << \" \" << p.c << \" \" << p.d;\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &vec_) {\n    for (ll i = 0; i < vec_.size(); ++i)os << vec_[i] << (i + 1 == vec_.size() ? \"\" : \" \");\n    return os;\n}\n\ntemplate<typename T> ostream &operator<<(ostream &os, vector<vector<T>> &vec_) {\n    for (ll i = 0; i < vec_.size(); ++i) {\n        for (ll j = 0; j < vec_[i].size(); ++j) { os << vec_[i][j] << \" \"; }\n        os << endl;\n    }\n    return os;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, map<T, U> &m) {\n    os << endl;\n    for (auto &&v:m) os << v << endl;\n    return os;\n}\ntemplate<class T> ostream &operator<<(ostream &os, set<T> s) {\n    fora(v, s) { os << v << \" \"; }\n    return os;\n}\ntemplate<class T> ostream &operator<<(ostream &os, mset<T> s) {\n    fora(v, s) { os << v << \" \"; }\n    return os;\n}\ntemplate<class T> ostream &operator<<(ostream &os, deque<T> a) {\n    fora(v, a)os << v << \" \";\n    return os;\n}\nostream &operator<<(ostream &os, vector<vector<char>> &vec_) {\n    rep(h, sz(vec_)) {\n        rep(w, sz(vec_[0])) { os << vec_[h][w]; }\n        os << endl;\n    }\n    return os;\n}\n//template<class T,class U>ostream &operator<<(ostream &os, vector<pair<T,U>>& a) {fora(v,a)os<<v<<endl;return os;}\n/*@formatter:off*/\ntemplate<typename W, typename H> void resize(W &vec_, const H head) { vec_.resize(head); }\ntemplate<typename W, typename H, typename ... T> void resize(W &vec_, const H &head, const T ... tail) {vec_.resize(head);for (auto &v: vec_)resize(v, tail...);}\n//template<typename W, typename H> void resize(vector<W> &vec, const H head) { vec.resize(head); }\n//template<typename W, typename H, typename ... T> void resize(vector<W> &vec, const H &head, const T ... tail) {vec.resize(head);for (auto &v: vec)resize(v, tail...);}\ntemplate<typename T, typename F> bool all_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool all_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (!all_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool any_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool any_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (any_of2(v[i], f))return true; }    return false;}\ntemplate<typename T, typename F> bool none_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool none_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (none_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool find_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll find_if2(vector<T> &v, F f) {    rep(i, sz(v)) { if (find_if2(v[i], f))return i; }    return sz(v);}\ntemplate<typename T, typename F> bool rfind_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll rfind_if2(vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (rfind_if2(v[i], f))return i; }    return -1;}\ntemplate<class T> bool contains(string &s, const T &v) { return s.find(v) != string::npos; }\ntemplate<typename T> bool contains(vector<T> &v, const T &val) { return std::find(v.begin(), v.end(), val) != v.end(); }\ntemplate<typename T, typename F> bool contains_if2(vector<T> &v, F f) { return find_if(v.begin(), v.end(), f) != v.end(); }\ntemplate<typename T, typename F> ll count_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll count_if2(vector<T> &vec_, F f) {    ll ret = 0;    fora(v, vec_)ret += count_if2(v, f);    return ret;}\ntemplate<typename T, typename F> void for_each2(T &v, F f) { f(v); }\ntemplate<typename T, typename F> void for_each2(vector<T> &vec_, F f) { fora(v, vec_)for_each2(v, f); }\ntemplate<typename W> ll count_od(vector<W> &a) {return count_if2(a,[](ll v){return v&1 ;});}\ntemplate<typename W> ll count_ev(vector<W> &a) {return count_if2(a,[](ll v){return !(v&1) ;});}\n//削除した後のvectorを返す\ntemplate<typename T, typename F> vector<T> erase_if2(vector<T> &v, F f) {vector<T> nv;rep(i, sz(v)) { if (!f(v[i])) { nv.push_back(v[i]); }}return nv;}\ntemplate<typename T, typename F> vector<vector<T>> erase_if2(vector<vector<T>> &v, F f) {vector<vector<T>> res;rep(i, sz(v)) { res[i] = erase_if2(v[i], f); }return res;}\ntemplate<typename T, typename F> vector<T> l_erase_if2(vector<T> &v, F f) {vector<T> nv;rep(i, sz(v)) { if (!f(v[i])) { nv.push_back(v[i]); }}return nv;}\n\ntemplate<typename T, typename F> ll l_rfind_if(vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (f(v[i]))return i; }    return -1;}\ntemplate<typename T, typename F> bool l_contains_if(vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (f(v[i]))return true; }    return false;}\ntemplate<class A,class B, class C> auto t_all_of(A a,B b, C c){return std::all_of(a,b,c);}\ntemplate<class A,class B, class C> auto t_any_of(A a,B b, C c){return std::any_of(a,b,c);}\ntemplate<class A,class B, class C> auto t_none_of(A a,B b, C c){return std::none_of(a,b,c);}\ntemplate<class A,class B, class C> auto t_find_if(A a,B b, C c){return std::find_if(a,b,c);}\ntemplate<class A,class B, class C> auto t_count_if(A a,B b, C c){return std::count_if(a,b,c);}\n\n#define all_of_s__2(a,right) (t_all_of(all(a),lamr(right)))\n#define all_of_s__3(a,v,siki) (t_all_of(all(a),[&](auto v){return siki;}))\n#define all_of_s(...) over3(__VA_ARGS__,all_of_s__3,all_of_s__2)(__VA_ARGS__)\n\n//all_of(A, %2);\n//all_of(A, a, a%2);\n#define all_of__2(a,right) all_of2(a,lamr(right))\n#define all_of__3(a,v,siki) all_of2(a,[&](auto v){return siki;})\n#define all_of(...) over3(__VA_ARGS__,all_of__3,all_of__2)(__VA_ARGS__)\n#define all_of_f(a,f) all_of2(a,f)\n\n#define any_of_s__2(a,right) (t_any_of(all(a),lamr(right)))\n#define any_of_s__3(a,v,siki) (t_any_of(all(a),[&](auto v){return siki;}))\n#define any_of_s(...) over3(__VA_ARGS__,any_of_s__3,any_of_s__2)(__VA_ARGS__)\n\n#define any_of__2(a,right) any_of2(a,lamr(right))\n#define any_of__3(a,v, siki) any_of2(a,[&](auto v){return siki;})\n#define any_of(...) over3(__VA_ARGS__,any_of__3,any_of__2)(__VA_ARGS__)\n#define any_of_f(a,f) any_of2(a,f)\n\n#define none_of_s__2(a,right) (t_none_of(all(a),lamr(right)))\n#define none_of_s__3(a,v,siki) (t_none_of(all(a),[&](auto v){return siki;}))\n#define none_of_s(...) over3(__VA_ARGS__,none_of_s__3,none_of_s__2)(__VA_ARGS__)\n\n#define none_of__2(a,right) none_of2(a,lamr(right))\n#define none_of__3(a,v, siki) none_of2(a,[&](auto v){return siki;})\n#define none_of(...) over3(__VA_ARGS__,none_of__3,none_of__2)(__VA_ARGS__)\n#define none_of_f(a,f) none_of2(a,f)\n\n#define find_if_s__2(a,right) (t_find_if(all(a),lamr(right))-a.begin())\n#define find_if_s__3(a,v,siki) (t_find_if(all(a),[&](auto v){return siki;})-a.begin())\n#define find_if_s(...) over3(__VA_ARGS__,find_if_s__3,find_if_s__2)(__VA_ARGS__)\n\n#define find_if__2(a,right) find_if2(a,lamr(right))\n#define find_if__3(a,v, siki) find_if2(a,[&](auto v){return siki;})\n#define find_if(...) over3(__VA_ARGS__,find_if__3,find_if__2)(__VA_ARGS__)\n#define find_if_f(a,f) find_if2(a,f)\n\n#define rfind_if_s__2(a,right) l_rfind_if(a, lamr(right))\n#define rfind_if_s__3(a,v,siki) l_rfind_if(a, [&](auto v){return siki;})\n#define rfind_if_s(...) over3(__VA_ARGS__,rfind_if_s__3,rfind_if_s__2)(__VA_ARGS__)\n\n#define rfind_if__2(a,right) rfind_if2(a,lamr(right))\n#define rfind_if__3(a,v, siki) rfind_if2(a,[&](auto v){return siki;})\n#define rfind_if(...) over3(__VA_ARGS__,rfind_if__3,rfind_if__2)(__VA_ARGS__)\n#define rfind_if_f(a,f) rfind_if2(a,f)\n\n#define contains_if_s__2(a,right) l_contains_if(a, lamr(right))\n#define contains_if_s__3(a,v,siki) l_contains_if(a, [&](auto v){return siki;})\n#define contains_if_s(...) over3(__VA_ARGS__,contains_if_s__3,contains_if_s__2)(__VA_ARGS__)\n\n#define contains_if__2(a,right) contains_if2(a,lamr(right))\n#define contains_if__3(a,v, siki) contains_if2(a,[&](auto v){return siki;})\n#define contains_if(...) over3(__VA_ARGS__,contains_if__3,contains_if__2)(__VA_ARGS__)\n#define contains_if_f(a,f) contains_if2(a,f)\n\n#define count_if_s__2(a,right) (t_count_if(all(a),lamr(right)))\n#define count_if_s__3(a,v,siki) (t_count_if(all(a),[&](auto v){return siki;}))\n#define count_if_s(...) over3(__VA_ARGS__,count_if_s__3,count_if_s__2)(__VA_ARGS__)\n\n#define count_if__2(a,right) count_if2(a,lamr(right))\n#define count_if__3(a,v, siki) count_if2(a,[&](auto v){return siki;})\n#define count_if(...) over3(__VA_ARGS__,count_if__3,count_if__2)(__VA_ARGS__)\n#define count_if_f(a,f) count_if2(a,f)\n\n//vector<vi>で、viに対して操作\n#define for_each_s__2(a,right) do{fora(v,a){v right;}}while(0)\n#define for_each_s__3(a,v, shori) do{fora(v,a){shori;}}while(0)\n#define for_each_s(...) over3(__VA_ARGS__,for_each_s__3,for_each_s__2)(__VA_ARGS__)\n\n//vector<vi>で、intに対して操作\n#define for_each__2(a,right) for_each2(a,lamr(right))\n#define for_each__3(a,v, shori) for_each2(a,[&](auto& v){shori;})\n#define for_each(...) over3(__VA_ARGS__,for_each__3,for_each__2)(__VA_ARGS__)\n#define for_each_f(a, f) for_each2(a, f);\n\n#define for_eached__2(a,right) [&](auto a) {auto b = a;for_each(b, right);return b; }(a)\n#define for_eached__3(a,v, shori) [&](auto a) {auto b = a;for_each(b, v, shori);return b; }(a)\n#define for_eached(...) over3(__VA_ARGS__,for_eached__3,for_eached__2)(__VA_ARGS__)\n#define for_eached_f(a, f) for_eached2(a, f);\n\n\n\n#define erase_if_s__2(a,right) l_erase_if2(a,lamr(right))\n#define erase_if_s__3(a,v, siki) l_erase_if2(a,[&](auto v){return siki;})\n#define erase_if_s(...) over3(__VA_ARGS__,erase_if_s__3,erase_if_s__2)(__VA_ARGS__)\n\n\n#define erase_if__2(a,right) erase_if2(a,lamr(right))\n#define erase_if__3(a,v, siki) erase_if2(a,[&](auto v){return siki;})\n#define erase_if(...) over3(__VA_ARGS__,erase_if__3,erase_if__2)(__VA_ARGS__)\n#define erase_if_f(a,f) erase_if2(a,f)\n\n#define entry_if_s__2(a,right) l_entry_if2(a,lamr(right))\n#define entry_if_s__3(a,v, siki) l_entry_if2(a,[&](auto v){return siki;})\n#define entry_if_s(...) over3(__VA_ARGS__,entry_if_s__3,entry_if_s__2)(__VA_ARGS__)\n\n\n#define entry_if__2(a,right) entry_if2(a,lamr(right))\n#define entry_if__3(a,v, siki) entry_if2(a,[&](auto v){return siki;})\n#define entry_if(...) over3(__VA_ARGS__,entry_if__3,entry_if__2)(__VA_ARGS__)\n#define entry_if_f(a,f) entry_if2(a,f)\n\n\n\ntemplate<class T, class U,class W> void replace(vector<W> &a, T key, U v) { rep(i,sz(a))if(a[i]==key)a[i]=v; }\ntemplate<class T, class U,class W> void replace(vector<vector<W>> &A, T key, U v) { rep(i,sz(A))replace(A[i], key, v); }\nvoid replace(str &a, char key, str v) { if (v == \"\")a.erase(remove(all(a), key), a.end()); }\nvoid replace(str &a, char key, char v) { replace(all(a), key, v); }\n//keyと同じかどうか01で置き換える\ntemplate<class T, class U> void replace(vector<T> &a, U k) { rep(i, sz(a)) a[i] = a[i] == k; }\ntemplate<class T, class U> void replace(vector<vector<T >> &a, U k) { rep(i, sz(a))rep(j, sz(a[0])) a[i][j] = a[i][j] == k; }\n//template<class T> void replace(T &a) { replace(a, '#'); }\nvoid replace(str &a) {    int dec = 0;    if('a'<=a[0]&&a[0]<='z')dec = 'a';    if('A'<=a[0]&&a[0]<='Z')dec = 'A';    fora(v,a)v-=dec;}\nvoid replace(str &a, str key, str v) {stringstream t;ll kn = sz(key);std::string::size_type Pos(a.find(key));ll l = 0;while (Pos != std::string::npos) {t << a.substr(l, Pos - l);t << v;l = Pos + kn;Pos = a.find(key, Pos + kn);}t << a.substr(l, sz(a) - l);a = t.str();}\ntemplate<class T> bool includes(vector<T> &a, vector<T> &b) {vi c = a;vi d = b;sort(all(c));sort(all(d));return includes(all(c), all(d));}\ntemplate<class T> bool is_permutation(vector<T> &a, vector<T> &b) { return is_permutation(all(a), all(b)); }\ntemplate<class T> bool next_permutation(vector<T> &a) { return next_permutation(all(a)); }\nvoid iota(vector<ll> &ve, ll s, ll n) {ve.resize(n);iota(all(ve), s);}\nvi iota(ll s, ll len) {vi ve(len);iota(all(ve), s);return ve;}\ntemplate<class A, class B> auto vtop(vector<A> &a, vector<B> &b) {    assert(sz(a) == sz(b));    /*stringを0で初期化できない  */  vector<pair<A, B>> res;    rep(i, sz(a))res.eb(a[i], b[i]);return res;}\ntemplate<class A, class B> void ptov(vector<pair<A, B>> &p, vector<A> &a, vector<B> &b) {    a.resize(sz(p)), b.resize(sz(p));    rep(i, sz(p))a[i] = p[i].fi, b[i] = p[i].se;}\ntemplate<class A, class B, class C> auto vtot(vector<A> &a, vector<B> &b, vector<C> &c) {    assert(sz(a) == sz(b) && sz(b) == sz(c));    vector<T2<A, B, C>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i]);    return res;}\ntemplate<class A, class B, class C, class D> auto vtof(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    assert(sz(a) == sz(b) && sz(b) == sz(c) && sz(c) == sz(d));    vector<F2<A, B, C, D>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i], d[i]);    return res;}\nenum pcomparator { fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd };\nenum tcomparator {    fisiti, fisitd, fisdti, fisdtd, fdsiti, fdsitd, fdsdti, fdsdtd,    fitisi, fitisd, fitdsi, fitdsd, fdtisi, fdtisd, fdtdsi, fdtdsd,    sifiti, sifitd, sifdti, sifdtd, sdfiti, sdfitd, sdfdti, sdfdtd,    sitifi, sitifd, sitdfi, sitdfd, sdtifi, sdtifd, sdtdfi, sdfdfd,    tifisi, tifisd, tifdsi, tifdsd, tdfisi, tdfisd, tdfdsi, tdfdsd,    tisifi, tisifd, tisdfi, tisdfd, tdsifi, tdsifd, tdsdfi, tdsdfd};\ntemplate<class A, class B> void sort(vector<pair<A, B>> &a, pcomparator type) {    typedef pair<A, B> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });};template<class U> void sort(vector<U> &a, pcomparator type) {    if (type == fisi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f > r.f; });};template<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D> > &a, pcomparator type) {    typedef F2<A, B, C, D> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a > r.a; });};template<class U> void sort(vector<U> &a, tcomparator type) {    if (type == 0) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == 41) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == 42) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == 43) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });    else if (type == 44) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == 45) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == 46) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == 47) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });}template<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D>> &a, tcomparator type) {    typedef F2<A, B, C, D> U;    if (type == 0) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == 41) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == 42) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == 43) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });    else if (type == 44) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == 45) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == 46) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == 47) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });}\n\nvoid sort(string &a) { sort(all(a)); }\nvoid sort(int& a,int& b){    if(a>b)swap(a,b);}\nvoid sort(int& a,int& b, int& c){    sort(a,b);    sort(a,c);    sort(b,c);}\nvoid rsort(int& a,int& b){    if(a<b)swap(a,b);}\nvoid rsort(int& a,int& b, int& c){    rsort(a,b);    rsort(a,c);    rsort(b,c);}\ntemplate<class T> void sort(vector<T> &a) { sort(all(a)); }\n//P l, P rで f(P) の形で渡す\ntemplate<class U, class F> void sort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) < f(r); }); };\ntemplate<class T> void rsort(vector<T> &a) { sort(all(a), greater<T>()); };\ntemplate<class U, class F> void rsort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) > f(r); }); };\n\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class A, class B> void sortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    sort(c);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}template<class A, class B, class F> void sortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    sort(c, f);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}template<class A, class B> void rsortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    rsort(c);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}template<class A, class B, class F> void rsortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    rsort(c, f);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}\ntemplate<class A, class B, class C> void sortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    sort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class F> void sortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    sort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    rsort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class F> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    rsort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class D> void sortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    sort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\ntemplate<class A, class B, class C, class D> void rsortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    rsort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\n//sortindex 元のvectorはソートしない\ntemplate<class T> vi sorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind);    return ind;}/*indexの分で型が変わるためpcomparatorが必要*/template<class T> vi sorti(vector<T> &a, pcomparator f) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind, f);    return ind;}template<class T, class F> vi sorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(a[x]) < f(a[y]); });    return ind;}template<class T> vi rsorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    rsortp(b, ind);    return ind;}template<class T, class F> vi rsorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(a[x]) > f(a[y]); });    return ind;}template<class A, class B, class F> vi sortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(c[x]) < f(c[y]); });    return ind;}template<class A, class B> vi sortpi(vector<A> &a, vector<B> &b, pcomparator f) {    vi ind = iota(0, sz(a));    auto c = a;    auto d = b;    sortt(c, d, ind, f);    return ind;}template<class A, class B> vi sortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fisi); };template<class A, class B, class F> vi rsortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(c[x]) > f(c[y]); });    return ind;}template<class A, class B> vi rsortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fdsd); };template<class A, class B, class C, class F> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(d[x]) < f(d[y]); });    return ind;}template<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, pcomparator f) {    vi ind = iota(0, sz(a));    auto d = vtof(a, b, c, ind);    sort(d, f);    rep(i, sz(a))ind[i] = d[i].d;    return ind;}template<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) {        if (a[x] == a[y]) {            if (b[x] == b[y])return c[x] < c[y];            else return b[x] < b[y];        } else {            return a[x] < a[y];        }    });    return ind;}template<class A, class B, class C, class F> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(d[x]) > f(d[y]); });    return ind;}template<class A, class B, class C> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) {        if (a[x] == a[y]) {            if (b[x] == b[y])return c[x] > c[y];            else return b[x] > b[y];        } else {            return a[x] > a[y];        }    });    return ind;}\ntemplate<class T> void sort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)sort(a[i]); }\ntemplate<class T> void rsort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)rsort(a[i]); }\n\ntemplate<class... T,class U> auto sorted(U head,T... a) { sort(head,a...); return head;}\n\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }template<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }template<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\ntemplate<typename W, typename T>void fill(W &xx, const T vall) {    xx = vall;}template<typename W, typename T>void fill(vector<W> &vecc, const T vall) {    for (auto &&vx     : vecc)fill(vx, vall);}\ntemplate<typename W,typename T>void fill(vector<W> &xx,ll len,const T v) {rep(i, len)xx[i]=v;}\ntemplate<typename W, typename T> void fill(vector<vector<W>> &xx, int sh, int th, int sw, int tw, T v) { rep(h, sh, th)rep(w, sw, tw)xx[h][w] = v; }\ntemplate<class T,class U>void fill(vector<T> &a,vi& ind,U val) {fora(v,ind)a[v]=val;}\ntemplate<class W,class T>void fill(mvec<W> &xx,const T v){fora(x,xx)fill(x,v);}\n\n\ntemplate<typename A, size_t N> A sum(A (&a)[N]) {    A res = 0;    rep(i, N)res += a[i];    return res;}template<typename A, size_t N, size_t O> A sum(A (&a)[N][O]) {    A res = 0;    rep(i, N)rep(j, O)res += a[i][j];    return res;}template<typename A, size_t N, size_t O, size_t P> A sum(A (&a)[N][O][P]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)res += a[i][j][k];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A sum(A (&a)[N][O][P][Q]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)res += a[i][j][k][l];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A sum(A (&a)[N][O][P][Q][R]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)res += a[i][j][k][l][m];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A sum(A (&a)[N][O][P][Q][R][S]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)res += a[i][j][k][l][m][n];    return res;}\n//@汎用便利関数 入力\nll in() {ll ret;cin >> ret;return ret;}\ntemplate<class T> T in(){\n    T ret;\n    cin>>ret;\n    return ret;\n}\nstring sin() {string ret;cin >> ret;return ret;}\ntemplate<class T>  void in(T &head) { cin >> head; }template<class T, class... U>  void in(T &head, U &... tail) {cin >> head;in(tail...);}\n\n#define din_t2(type,a) type a;cin>>a\n#define din_t3(type,a, b) type a,b;cin>>a>> b\n#define din_t4(type,a, b, c) type a,b,c;cin>>a>>b>>c\n#define din_t5(type,a, b, c, d) type a,b,c,d;cin>>a>>b>>c>>d\n#define din_t6(type,a, b, c, d, e) type a,b,c,d,e;cin>>a>>b>>c>>d>>e\n#define din_t7(type,a, b, c, d, e, f) type a,b,c,d,e,f;cin>>a>>b>>c>>d>>e>>f\n#define din_t(...) over7(__VA_ARGS__,din_t7,din_t6,din_t5,din_t4,din_t3 ,din_t2)(__VA_ARGS__)\n\n#define din(...) din_t(int,__VA_ARGS__)\n#define d_in\n#define dsig(...) din_t(signed,__VA_ARGS__)\n\n#define dst(...) din_t(string,__VA_ARGS__)\n#define dstr dst\n#define d_str dst\n\n#define dcha(...) din_t(char,__VA_ARGS__)\n#define dchar dcha\n\n#define ddou(...) din_t(double,__VA_ARGS__)\n\n\n\n\n\n#define din1d(a) din_t2(int, a);a--\n#define din2d(a, b) din_t3(int, a,b);a--,b--\n#define din3d(a, b, c) din_t4(int, a,b,c);a--,b--,c--\n#define din4d(a, b, c, d) din_t5(int, a,b,c,d);a--,b--,c--,d--\n#define dind(...) over4(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\n\n#ifdef _DEBUG\ntemplate<class T> void err2(T &&head) { cerr << head; }\ntemplate<class T, class... U> void err2(T &&head, U &&... tail) {    cerr << head << \" \";    err2(tail...);}\ntemplate<class T, class... U> void err(T &&head, U &&... tail) {    cerr << head << \" \";    err2(tail...);    cerr << \"\" << endl;}\ntemplate<class T> void err(T &&head) {    cerr << head  << endl;}\nvoid err() {    cerr << \"\"  << endl;}\ntemplate<class T> string out_m2(vector<T> &a, ll W = inf) {    stringstream ss;    if (W == inf)W = min(sz(a), 12ll);    if (sz(a) == 0)return ss.str();    rep(i, W) {        ss << a[i];        if (typeid(a[i]) == typeid(P)) { ss << endl; } else { ss << \" \"; }    }    return ss.str();}\ntemplate<class T> string out_m2(vector<vector<T> > &a, ll H = inf, ll W = inf, int key = -1) {    H = (H != inf) ? H : min({H, sz(a), 12ll});    W = min({W, sz(a[0]), 12ll});    stringstream ss;    ss << endl;    if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";    rep(w, W)ss << std::right << std::setw(4) << w;    ss << \"\" << endl;    rep(w, W * 4 + 3)ss << \"_\";    ss << \"\" << endl;    rep(h, H) {        ss << std::right << std::setw(2) << h << \"|\";        rep(w, min(sz(a[h]), 12ll)) { if (abs(a[h][w]) == linf || abs(a[h][w])==inf) ss << \"   e\" << \"\"; else ss << std::right << std::setw(4) << a[h][w]; }        ss << \"\" << endl;    }    return ss.str();}\ntemplate<class T> string out_m2(vector<set<T> > &a, ll H = inf, ll W = inf, int key = -1) {    vector<vector<T> > b(sz(a));    rep(i, sz(a)) { fora(v, a[i]) { b[i].push_back(v); }}    return out_m2(b, H, W, key);}\ntemplate<class T> string out_m2(vector<vector<vector<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {    stringstream ss;    if (H == inf)H = 12;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << out_m2(a[i], W, U, i);    }    return ss.str();}\ntemplate<class T, size_t N> string out_m2(T (&a)[N]) {    vector<T> b;    resize(b, N);    rep(i, N) {        b[i] = a[i];    }    return out_m2(b);}\ntemplate<class T, size_t N, size_t M> string out_m2(T (&a)[N][M]) {    vector<vector<T>> b;    resize(b, N, M);    rep(i, N) {        rep(j, M) {            b[i][j] = a[i][j];        }    }    return out_m2(b);}\ntemplate<class T, size_t N, size_t M, size_t O> string out_m2(T (&a)[N][M][O]) {    vector<vector<vector<T>>> b;    resize(b, N, M, O);    rep(i, N) {        rep(j, M) {            rep(k, O) {                b[i][j][k] = a[i][j][k];            }        }    }    return out_m2(b);}\nstring out_m2(int a) {stringstream ss;ss << a;return ss.str();}\ntemplate<class T> string out_m2(mvec<mvec<T> > &a, ll H = inf, ll W = inf, int key = inf) {    H = min({H, sz(a), 6ll});    W = min({W, sz(a[0]), 6ll});    stringstream ss;    ss << endl;    if (key == inf)ss << \" *|\";    else {        ss << std::right << std::setw(2) << key;        ss << \"|\";    }    rep(w, -W, W)ss << std::right << std::setw(4) << w;    ss << \"\" << endl;    rep(w, W * 8 + 3)ss << \"_\";    ss << \"\" << endl;    rep(h, -H, H) {        ss << std::right << std::setw(2) << h << \"|\";        int NW = min(sz(a[h]), 6ll);        rep(w, -NW, NW) { if (abs(a[h][w]) == linf) ss << \"   e\" << \"\"; else ss << std::right << std::setw(4) << a[h][w]; }        ss << \"\" << endl;    }    return ss.str();}\ntemplate<class T> string out_m2(mvec<mvec<mvec<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {    stringstream ss;    if (H == inf)H = 6;    H = min(H, sz(a));    rep(i, -H, H) {        ss << endl;        ss << out_m2(a[i], W, U, i);    }    return ss.str();}\ntemplate<class T> string out_m2(T &a) {stringstream ss;ss << a;return ss.str();}\ntemplate<class T> string out_m(vector<T> &a, ll W = inf) {    stringstream ss;    if (W == inf)W = min(sz(a), 12ll);    if (sz(a) == 0)return ss.str();    rep(i, W) { ss << a[i] << \" \"; }    ss << \"\" << endl;    return ss.str();}\ntemplate<class T> string out_m(vector<vector<T> > &a, ll H = inf, ll W = inf, int key = -1) {H = min({H, sz(a), 12ll});W = min({W, sz(a[0]), 12ll});stringstream ss;ss << endl;if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";rep(w, W)ss << std::right << std::setw(4) << w;ss << \"\" << endl;rep(w, W * 4 + 3)ss << \"_\";ss << \"\" << endl;rep(h, H) {ss << std::right << std::setw(2) << h << \"|\";rep(w, min(sz(a[h]),12ll)) { if (abs(a[h][w]) == linf) ss << \"   e\" << \"\"; else ss << std::right << std::setw(4) << a[h][w]; }ss << \"\" << endl;}ss << endl;return ss.str();}\ntemplate<class T> string out_m(vector<vector<vector<T> > > &a, ll H = inf, ll W = inf, ll U = inf) {stringstream ss;    if (H == inf)H = 5;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << out_m(a[i], W, U, i);    }    ss << endl;    return ss.str();}\nstring out_m(int a) {stringstream ss;ss << a << endl;return ss.str();}\ntemplate<class T> string out_m(T &a) {stringstream ss;ss << a << endl;return ss.str();}\ntemplate<class T> void outv(vector<T> &a, ll W=inf) {cout << out_m(a,W) << endl;}\ntemplate<class T> void outv(vector<vector<T> > &a, ll H = linf, ll W = linf,int key=-1) {    cout << out_m(a,H,W,key) << endl;}\ntemplate<class T> void outv(vector<vector<vector<T> > > &a, ll H = linf, ll W = linf,ll U = linf) {cout << out_m(a,H,W,U)<< endl;}\n\ntemplate<class T> void out2(T &&head) { cout << head;res_mes += out_m2(head); }\ntemplate<class T, class... U> void out2(T &&head, U &&... tail) {    cout << head << \" \";   res_mes += out_m2(head)+\" \"; out2(tail...);}\ntemplate<class T, class... U> void out(T &&head, U &&... tail) {    cout << head << \" \";    res_mes += out_m2(head)+\" \";out2(tail...);    cout << \"\" << endl;res_mes += \"\\n\";}\ntemplate<class T> void out(T &&head) {    cout << head  << endl; res_mes += out_m2(head)+\"\\n\";}\nvoid out() {    cout << \"\"  << endl;}\n\n#else\ntemplate<class T> void outv(vector<T> &a, ll W = inf) {\n    rep(i, min(W, sz(a))) { cout << a[i] << \" \"; }\n    cout << \"\" << endl;\n}\ntemplate<class T> void outv(vector<vector<T> > &a, ll H = linf, ll W = linf, int key = -1) { rep(i, min(H, sz(a))) { outv(a[i], W); }}\ntemplate<class T> void outv(vector<vector<vector<T> > > &a, ll H = linf, ll W = linf, ll U = linf) { ; }\n#define err(...);\n\ntemplate<class T> void out2(T &&head) { cout << head; }\ntemplate<class T, class... U> void out2(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);}\ntemplate<class T, class... U> void out(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);    cout << \"\" << endl;}\ntemplate<class T> void out(T &&head) {    cout << head  << endl;}\nvoid out() {    cout << \"\"  << endl;}\n\n#endif\ntemplate<class T> void outl(vector<T> &a, int n = inf) { rep(i, min(n, sz(a)))cout << a[i] << endl; }\n//テーブルをスペースなしで出力\ntemplate<class T> void outt(vector<vector<T>> &a) {rep(i, sz(a)) {rep(j, sz(a[i])) { cout << a[i][j]; }cout << endl;}}\n//int型をbit表記で出力\nvoid outb(int a) { cout << bitset<20>(a) << endl; }\ntemplate<class T> void na(vector<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i];}\ntemplate<class T> void na(set<T> &a, ll n) {rep(i, n)a.insert(in());}\n#define dna(a, n) vi a(n); rep(dnai,n) cin >> a[dnai];\n#define dnad(a, n) vi a(n); rep(dnai,n) cin >> a[dnai],a[dnai]--;\ntemplate<class T> void nao(vector<T> &a, ll n) {a.resize(n + 1);a[0] = 0;rep(i, n)cin >> a[i + 1];}\ntemplate<class T> void naod(vector<T> &a, ll n) {a.resize(n + 1);a[0] = 0;rep(i, n)cin >> a[i + 1], a[i + 1]--;}\ntemplate<class T> void nad(vector<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i], a[i]--;}\ntemplate<class T> void nad(set<T> &a, ll n) {    rep(i, n)a.insert(in()-1);}\ntemplate<class T, class U> void na2(vector<T> &a, vector<U> &b, ll n) {    a.resize(n);    b.resize(n);    rep(i, n)cin >> a[i] >> b[i];}\ntemplate<class T, class U> void na2(set<T> &a, set<U> &b, ll n) {    rep(i, n){        a.insert(in());        b.insert(in());    }}\n#define dna2(a, b, n) vi a(n),b(n);rep(dna2i, n)cin >> a[dna2i] >> b[dna2i];\ntemplate<class T, class U> void nao2(vector<T> &a, vector<U> &b, ll n) {    a.resize(n + 1);    b.resize(n + 1);    a[0] = b[0] = 0;    rep(i, n)cin >> a[i + 1] >> b[i + 1];}\n#define dna2d(a, b, n) vi a(n),b(n);rep(dna2di, n){cin >> a[dna2di] >> b[dna2di];a[dna2di]--,b[dna2di]--;}\ntemplate<class T, class U> void na2d(vector<T> &a, vector<U> &b, ll n) {    a.resize(n);    b.resize(n);    rep(i, n)cin >> a[i] >> b[i], a[i]--, b[i]--;}\ntemplate<class T, class U, class W> void na3(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {    a.resize(n);    b.resize(n);    c.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i];}\n#define dna3(a, b, c, n) vi a(n),b(n),c(n);   rep(dna3i, n)cin >> a[dna3i] >> b[dna3i] >> c[dna3i];\ntemplate<class T, class U, class W> void na3d(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {    a.resize(n);    b.resize(n);    c.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i], a[i]--, b[i]--, c[i]--;}\n#define dna3d(a, b, c, n) vi a(n),b(n),c(n);  rep(dna3di, n){cin >> a[dna3di] >> b[dna3di] >> c[dna3di];a[dna3di]--,b[dna3di]--,c[dna3di]--;}\ntemplate<class T, class U, class W, class X> void na4(vector<T> &a, vector<U> &b, vector<W> &c, vector<X> &d, ll n) {    a.resize(n);    b.resize(n);    c.resize(n);    d.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i] >> d[i];}\n#define dna4(a, b, c, d, n) vi a(n),b(n),c(n),d(n);   rep(dna4i, n)cin >> a[dna4i] >> b[dna4i] >> c[dna4i]>>d[dna4i];\n#define dna4d(a, b, c, d, n) vi a(n),b(n),c(n),d(n);   rep(dna4i, n)cin >> a[dna4i] >> b[dna4i] >> c[dna4i]>>d[dna4i],--a[dna4i] ,-- b[dna4i],-- c[dna4i],--d[dna4i];\n#define nt(a, h, w) resize(a,h,w);rep(nthi,h)rep(ntwi,w) cin >> a[nthi][ntwi];\n#define ntd(a, h, w) resize(a,h,w);rep(ntdhi,h)rep(ntdwi,w) cin >> a[ntdhi][ntdwi], a[ntdhi][ntdwi]--;\n#define ntp(a, h, w) resize(a,h+2,w+2);fill(a,'#');rep(ntphi,1,h+1)rep(ntpwi,1,w+1) cin >> a[ntphi][ntpwi];\n#define dnt(S, h, w) vvi(S,h,w);nt(S,h,w);\n#define dntc(S, h, w) vvc(S,h,w);nt(S,h,w);\n#define dnts(S, h, w) vvs(S,h,w);nt(S,h,w);\n\n//デバッグ\n#define sp << \" \" <<\n\n#define deb1(x)  debugName(x)<<\" = \"<<out_m2(x)\n#define deb_2(x, ...) deb1(x) <<\", \"<< deb1(__VA_ARGS__)\n#define deb_3(x, ...) deb1(x) <<\", \"<< deb_2(__VA_ARGS__)\n#define deb_4(x, ...) deb1(x) <<\", \"<< deb_3(__VA_ARGS__)\n#define deb5(x, ...) deb1(x) <<\", \"<< deb_4(__VA_ARGS__)\n#define deb6(x, ...) deb1(x) <<\", \"<< deb5(__VA_ARGS__)\n#define deb7(x, ...) deb1(x) <<\", \"<< deb6(__VA_ARGS__)\n#define deb8(x, ...) deb1(x) <<\", \"<< deb7(__VA_ARGS__)\n#define deb9(x, ...) deb1(x) <<\", \"<< deb8(__VA_ARGS__)\n#define deb10(x, ...) deb1(x) <<\", \"<< deb9(__VA_ARGS__)\n\n\n#ifdef _DEBUG\nbool was_deb=false;\n#define deb(...)  do{was_deb=true;cerr<< over10(__VA_ARGS__,deb10,deb9,deb8,deb7,deb6,deb5,deb_4,deb_3,deb_2,deb1)(__VA_ARGS__) <<endl;}while(0)\n\n#define base_keta 8\nvoid print_n_base(int x,int base){    cerr<<bitset<base_keta>(x)<<endl;}\ntemplate<class T>void print_n_base(vector<T> X,int base){    cerr<<endl;    for(auto&& x:X){        print_n_base(x,base);    }    cerr<<endl;}\n\n//n進数\n#define deb2(x) cerr<<debugName(x)<<\" = \";print_n_base(x, 2);\n#define deb3(x) cerr<<debugName(x)<<\" = \";print_n_base(x, 3);\n#define deb4(x) cerr<<debugName(x)<<\" = \";print_n_base(x, 4);\n\n#define deb_ex_deb(x, len)  debugName(x)<<\" = \"<<out_m2(x, len)\n#define call_deb_ex_deb(x, len) deb_ex_deb(x, len)\n//要素が存在する行だけ出力(vvt)\n#define deb_ex(v) do {int N = sz(v);int s = N;int t = 0;rep(i, N) {if (sz(v[i])) {chmi(s, i);chma(t, i);}}auto ex_v = sub(v, s, N);str S = out_m2(ex_v, sz(ex_v));debugName(v);cerr<<\" = \"<<endl;cerr << S << endl;} while (0);\ntemplate<class T, class F> string out_m2_f(vector<vector<T> > &a, F f, int key = -1) {    stringstream ss;    vi H, W;    rep(h, sz(a)) {        rep(w, sz(a[0])) {            if (f(a[h][w])) {                H.push_back(h);                W.push_back(w);            }        }    }    sort(H);    sort(W);    unique(H);    unique(W);    ss << endl;    if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";    fora(w, W)ss << std::right << std::setw(sz(tos(w)) + 1) << w;    ss << \"\" << endl;    rep(w, sz(W) * 4 + 3)ss << \"_\";    ss << \"\" << endl;    fora(h, H) {        ss << std::right << std::setw(2) << h << \"|\";        fora(w, W) { if (abs(a[h][w]) == linf) ss << \"   e\" << \"\"; else ss << std::right << std::setw(sz(tos(w)) + 1) << a[h][w]; }        ss << \"\" << endl;    }    return ss.str();}\ntemplate<class T, class F> string out_m2_f(vector<vector<vector<T>>> &a, F f) {    stringstream ss;    int H = sz(a);    if (sz(a) == 0)return ss.str();    rep(i, H) { ss << out_m2_f(a[i], f, i); }    ss << \"\" << endl;    return ss.str();}\n#define debf_normal(tab, f) do{cerr<<debugName(tab)<<\" = \"<<endl;cerr<< out_m2_f(tab, f)<<endl;}while(0);\n#define debf2(tab, siki_r) debf_normal(tab, lamr(siki_r))\n#define debf3(tab, v, siki)  debf_normal(tab, lam(siki))\n//S, sikir\n//S, v, siki\n#define debf(...) over3(__VA_ARGS__,debf3,debf2,debf1)(__VA_ARGS__)\n\n#else\n#define deb(...) ;\n#define deb2(...) ;\n#define deb3(...) ;\n#define deb4(...) ;\n#define deb_ex(...) ;\n#define debf(...) ;\n#endif\n\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n\n//@formatter:off\n//よく使うクラス、構造体\n//graphでredefineしているため、書き換えたら向こうも書き換える\nstruct unionfind {\n    vector<ll> par;\n    vector<ll> siz;\n    vector<ll> es;\n    ll n, trees;//連結グループの数(親の種類)\n    unionfind(ll n) : n(n), trees(n) {        par.resize(n);        siz.resize(n);        es.resize(n);        for (ll i = 0; i < n; i++) {            par[i] = i;            siz[i] = 1;        }    }\n    ll root(ll x) { if (par[x] == x) { return x; } else { return par[x] = root(par[x]); }}\n    ll operator()(ll x){return root(x);}\n    bool unite(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        es[x]++;\n        if (x == y) return false;\n        if (siz[x] > siz[y]) swap(x, y);\n        trees--;\n        par[x] = y;\n        siz[y] += siz[x];\n        es[y] += es[x];\n        return true;\n    }\n    bool same(ll x, ll y) { return root(x) == root(y); }\n    ll size(ll x) { return siz[root(x)]; }\n    ll esize(ll x) { return es[root(x)]; }\n    vi sizes(){        vi cou(n);        vi ret;        ret.reserve(n);        rep(i, n){            cou[root (i)]++;        }        rep(i, n){            if(cou[i])ret.push_back(cou[i]);        }        return ret;    }\n    //つながりを無向グラフと見なし、xが閉路に含まれるか判定\n    bool close(ll x) { return esize(x) >= size(x); }\n    vector<vi> sets() {        vi ind(n, -1);        ll i = 0;        vvi(res, trees);        rep(j, n) {            ll r = root(j);            if (ind[r] == -1)ind[r] = i++;            res[ind[r]].push_back(j);        }        rep(i, trees) {            ll r = root(res[i][0]);            if (res[i][0] == r)continue;            rep(j, 1, sz(res[i])) {                if (res[i][j] == r) {                    swap(res[i][0], res[i][j]);                    break;                }            }        }        return res;    }\n};//@formatter:off\n\n\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing u128 = __uint128_t;\n\nusing bint =__int128;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {    std::ostream::sentry s(dest);    if (s) {        __uint128_t tmp = value < 0 ? -value : value;        char buffer[128];        char *d = std::end(buffer);        do {            --d;            *d = \"0123456789\"[tmp % 10];            tmp /= 10;        } while (tmp != 0);        if (value < 0) {            --d;            *d = '-';        }        ll len = std::end(buffer) - d;        if (dest.rdbuf()->sputn(d, len) != len) { dest.setstate(std::ios_base::badbit); }    }    return dest;}\n__int128 to_bint(string &s) {    __int128 ret = 0;    for (ll i = 0; i < s.length(); ++i)        if ('0' <= s[i] && s[i] <= '9')            ret = 10 * ret + s[i] - '0';    return ret;}\nvoid operator>>(istream &iss, bint &v) {\n    string S;\n    iss>>S;\n    v = 0;\n    rep(i,sz(S)){\n        v*=10;\n        v +=  S[i]-'0';\n    }\n}\nbint max(bint a, signed b){return max(a,(bint)b);}\nbint max(signed a, bint b){return max((bint)a, b);}\nbint max(bint a, ll b){return max(a,(bint)b);}\nbint max(ll a, bint b){return max((bint)a, b);}\nbint min(bint a, signed b){return min(a,(bint)b);}\nbint min(signed a, bint b){return min((bint)a, b);}\nbint min(bint a, ll b){return min(a,(bint)b);}\nbint min(ll a, bint b){return min((bint)a, b);}\n//エラー\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");    exit(0);\n#endif\n    string a = \"a\";    rep(i, 30)a += a;    rep(i, 1 << 17)cout << a << endl;    cout << \"OLE 出力長制限超過\" << endl;    exit(0);}\nvoid re() {    assert(0 == 1);    exit(0);}\nvoid tle() { while (inf)cout << inf << endl; }\n\n//便利関数\n\n//テスト用\n#define rand xor128_\nunsigned long xor128_(void){static unsigned long x=123456789,y=362436069,z=521288629,w=88675123;unsigned long t;t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) );}\nchar ranc() { return (char) ('a' + rand() % 26); }\nll rand(ll min, ll max) {    assert(min <= max);    if (min >= 0 && max >= 0) { return rand() % (max + 1 - min) + min; } else if (max < 0) { return -rand(-max, -min); } else { if (rand() % 2) { return rand(0, max); } else { return -rand(0, -min); }}}\nll rand(ll max){return rand(0,max);}\ntemplate<class T> T rand(vector<T>& A){return A[rand(sz(A)-1)];}\n//重複することがある\ntemplate<class T> vector<T> ranv(vector<T>& A, int N){vector<T>ret(N);rep(i,N){ret[i]=rand(A);}return ret;}\ntemplate<class T> vector<T> ranv_unique(vector<T>& A, int N){    vector<T> ret(N);    umapi was;    rep(j,N){        int i;        while(1){            i = rand(sz(A)-1);            if(was.find(i) == was.end())break;        }        ret[j] = A[i];was[i]=1;    }    return ret;}\nvi ranv(ll n, ll min, ll max) {    vi v(n);    rep(i, n)v[i] = rand(min, max);    return v;}\nstr ransu(ll n) {    str s;    rep(i, n)s += (char) rand('A', 'Z');    return s;}\nstr ransl(ll n) {    str s;    rep(i, n)s += (char) rand('a', 'z');    return s;}\n//単調増加\nvi ranvinc(ll n, ll min, ll max) {    vi v(n);    bool bad = 1;    while (bad) {        bad = 0;        v.resize(n);        rep(i, n) {            if (i && min > max - v[i - 1]) {                bad = 1;                break;            }            if (i)v[i] = v[i - 1] + rand(min, max - v[i - 1]); else v[i] = rand(min, max);        }    }    return v;}\n//便利 汎用\n\nvoid ranvlr(ll n, ll min, ll max, vi &l, vi &r) {    l.resize(n);    r.resize(n);    rep(i, n) {        l[i] = rand(min, max);        r[i] = l[i] + rand(0, max - l[i]);    }}\ntemplate<class T>vector<pair<T,int>> run_length(vector<T> &a) {vector<pair<T,int>> ret;ret.eb(a[0], 1);rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}return ret;}\nvector<pair<char, ll>> run_length(string &a) {    vector<pair<char, ll>> ret;    ret.eb(a[0], 1);    rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}    return ret;}\ntemplate<class T, class F> T mgr(T ok, T ng, F f, int deb_ = 0) {    bool han = true;    if (deb_) {        if (ok < ng)            while (ng - ok > 1) {                T mid = (ok + ng) >> 1;                if (f(mid))ok = mid, han = true; else ng = mid, han = false;                deb(mid, han);            }        else            while (ok - ng > 1) {                T mid = (ok + ng) >> 1;                if (f(mid))ok = mid, han = true; else ng = mid, han = false;                deb(mid, han);            }    }else{        if (ok < ng)            while (ng - ok > 1) {                T mid = (ok + ng) >> 1;                if (f(mid))ok = mid, han = true; else ng = mid, han = false;            }        else            while (ok - ng > 1) {                T mid = (ok + ng) >> 1;                if (f(mid))ok = mid, han = true; else ng = mid, han = false;            }    }    return ok;}\ntemplate<class T, class F> T mgr(signed ok, T ng, F f) {    return mgr((T)ok, ng, f);}\ntemplate<class T, class F> T mgr(T ok, signed ng, F f) {    return mgr(ok, (T)ng, f);}\ntemplate<class F> int mgr(signed ok, signed ng, F f) {    return mgr((ll)ok, (ll)ng, f);}\n//[l, r)の中で,f(i)がtrueとなる範囲を返す okはそこに含まれる\ntemplate<class F> P mgr(int l, int r, F f, int ok) {    if (f(ok) == 0) {        out(\"f(ok) must true\");        re();    }    return mp(mgr(ok, l - 1, f), mgr(ok, r, f) + 1);}\n\ntemplate<class F> dou mgrd(dou ok, dou ng, F f,int kai=100) {\n    bool han = true;\n    if (ok < ng)\n        rep(i,kai) {\n            dou mid = (ok + ng) /2;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            deb(mid,han);\n        }\n    else\n        rep(i,kai) {\n            dou mid = (ok + ng) /2;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            deb(mid,han);\n        }\n    return ok;\n}\n//strを整数として比較\nstring smax(str &a, str b) {    if (sz(a) < sz(b)) { return b; }    else if (sz(a) > sz(b)) { return a; }    else if (a < b)return b;    else return a;}\n//strを整数として比較\nstring smin(str &a, str b) {    if (sz(a) > sz(b)) { return b; }    else if (sz(a) < sz(b)) { return a; }    else if (a > b)return b;    else return a;}\n//エラー-1\ntemplate<typename W, typename T> ll find(vector<W> &a, int l, const T key) {rep(i, l, sz(a))if (a[i] == key)return i;return -1;}\ntemplate<typename W, typename T> ll find(vector<W> &a, const T key) {    rep(i, sz(a))if (a[i] == key)return i;    return -1;}\ntemplate<typename W, typename T> P find(vector<vector<W >> &a, const T key) {    rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return mp(i, j);    return mp(-1, -1);}\n//getid(find())を返す 1次元にする\ntemplate<typename W, typename T> int findi(vector<vector<W >> &a, const T key) {    rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return i*sz(a[0])+j;    return -1;}\ntemplate<typename W, typename U> T find(vector<vector<vector<W >>> &a, const U key) {    rep(i, sz(a))rep(j, sz(a[0]))rep(k, sz(a[0][0]))if (a[i][j][k] == key)return mt(i, j, k);    return mt(-1, -1, -1);}\n//stringも書く\nint find(string& s, const string key){    int klen = sz(key);    rep(i,sz(s)-klen+1){        if(s[i]!=key[0])continue;        if(s.substr(i,klen) == key){            return i;        }    }    return -1;}\nint find(string& s, int l, const string key){    int klen = sz(key);    rep(i, l, sz(s)-klen+1){        if(s[i]!=key[0])continue;        if(s.substr(i,klen) == key){            return i;        }    }    return -1;}\nint find(string& s, const char key){    rep(i,sz(s)){        if(s[i]==key)return i;    }    return -1;}\nint find(string& s, int l, const char key){    rep(i, l, sz(s)){        if(s[i]==key)return i;    }    return -1;}\ntemplate<typename W, typename T> ll count2(W &a, const T k) { return a == k; }\ntemplate<typename W, typename T> ll count2(vector<W> &a, const T k) {    ll ret = 0;    fora(v, a)ret += count2(v, k);    return ret;}\ntemplate<typename W, typename T> ll count(vector<W> &a, const T k) {    ll ret = 0;    fora(v, a)ret += count2(v, k);    return ret;}\nvi count(vi &a) {    int ma = 0;    fora(v, a) {        if (ma < v)ma = v;    }    vi res(ma + 1);    fora(v, a) {        res[v]++;    }    return res;}\nll count(str &a, str k) {    ll ret = 0, len = k.length();    auto pos = a.find(k);    while (pos != string::npos)pos = a.find(k, pos + len), ++ret;    return ret;}\n//'a' = 'A' = 0 として集計 既に-'a'されていても動く\nvi count(str &a, int l, int r) {    vi cou(26);    char c = 'a';    if ('A' <= a[l] && a[l] <= 'Z')c = 'A';    if ('a' <= a[l] && a[l] <= 'z') c = 'a'; else c = 0;    rep(i, l, r)++cou[a[i] - c];    return cou;}\nvi count(str &a, int r = inf){return count(a, 0, min(r, sz(a)));}\n#define couif count_if\n//algorythm\nll rev(ll a) {    ll res = 0;    while (a) {        res *= 10;        res += a % 10;        a /= 10;    }    return res;}\ntemplate<class T> auto rev(vector<T> &a) {auto b= a; reverse(all(b)); return b;}\n/* ＼反転  */                                                                                        template<class U>\nauto rev(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a[0]), vector<U>(sz(a)));    rep(h, sz(a)) rep(w, sz(a[0]))b[w][h] = a[h][w];    return b;}\n\n/* ｜反転  */                                                                                        template<class U>\nauto revw(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a), vector<U>(sz(a[0])));    int W = sz(a[0]);    rep(h, sz(a)) rep(w, sz(a[0])){            b[h][W-1-w] = a[h][w];        }    return b;}\n\n/* ー反転  */                                                                                        template<class U>\nauto revh(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a), vector<U>(sz(a[0])));    int H = sz(a);    rep(h, sz(a)) rep(w, sz(a[0])){        b[H-1-h][w] = a[h][w];    }    return b;}\n\n/* ／反転  */                                                                                        template<class U>\nauto revr(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a[0]), vector<U>(sz(a)));   int H = sz(a);int W = sz(a[0]); rep(h, sz(a)) rep(w, sz(a[0]))b[w][h] = a[H-1-h][W-1-w];    return b;}\n\nauto  rev(string &a) { string b = a; reverse(all(b));return b; }\nconstexpr ll p10[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000ll, 100000000000ll, 1000000000000ll, 10000000000000ll, 100000000000000ll, 1000000000000000ll, 10000000000000000ll, 100000000000000000ll, 1000000000000000000ll};\n\n//0は0桁\nll keta(ll v) {    if (v < p10[9]) { if (v < p10[4]) { if (v < p10[2]) { if (v < p10[1]) { if (v < p10[0])return 0; else return 1; } else return 2; } else { if (v < p10[3]) return 3; else return 4; }} else { if (v < p10[7]) { if (v < p10[5]) return 5; else if (v < p10[6])return 6; else return 7; } else { if (v < p10[8])return 8; else return 9; }}}    else {        if (v < p10[13]) { if (v < p10[11]) { if (v < p10[10]) return 10; else return 11; } else { if (v < p10[12]) return 12; else return 13; }}        else {            if (v < p10[15]) {                if (v < p10[14]) return 14;                else return 15;            } else {                if (v < p10[17]) {                    if (v < p10[16]) return 16;                    else return 17;                } else {                    if (v < p10[18])return 18;                    else return 19;                }            }        }    }}\nll getr(ll a, ll keta) { return (a / (ll) pow(10, keta)) % 10; }\n//上から何桁目か\nll getl(ll a, ll ket) {int sketa = keta(a);return getr(a,sketa-1-ket);}\nll dsum(ll v,ll sin=10) {    ll ret = 0;    for (; v; v /= sin)ret += v % sin;    return ret;}\n\nll mask10(ll v) { return p10[v] - 1; }\n//変換系\n//[v] := iとなるようなvectorを返す\n//存在しない物は-1\ntemplate<class T> auto keys(T a) {    vector<decltype((a.begin())->fi)> res;    for (auto &&k :a)res.push_back(k.fi);    return res;}\ntemplate<class T> auto values(T a) {    vector<decltype((a.begin())->se)> res;    for (auto &&k :a)res.push_back(k.se);    return res;}\ntemplate<class T, class U>  bool chma(T &a, const U &b) {    if (a < b) {        a = b;        return true;    }    return false;}\ntemplate<class T, class U>  bool chmi(T &a, const U &b) {    if (b < a) {        a = b;        return true;    }    return false;}\ntemplate<class T> constexpr T min(T a, signed b) { return a < b ? a : b; }\ntemplate<class T> constexpr  T max(T a, signed b) { return a < b ? b : a; }\ntemplate<class T> constexpr  T min(T a, T b, T c) { return a >= b ? b >= c ? c : b : a >= c ? c : a; }\ntemplate<class T> constexpr  T max(T a, T b, T c) { return a <= b ? b <= c ? c : b : a <= c ? c : a; }\ntemplate<class T>  T min(vector<T>& a) { return *min_element(all(a)); }\ntemplate<class T>  T mini(vector<T>& a) { return min_element(all(a)) - a.begin(); }\ntemplate<class T>  T min(vector<T>& a, ll n) { return *min_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T>  T min(vector<T>& a, ll s, ll n) { return *min_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<class T>  T max(vector<T>& a) { return *max_element(all(a)); }\ntemplate<class T,class U>  T max(vector<T>& a,vector<U>& b) { return max(*max_element(all(a)),*max_element(all(b))); }\ntemplate<class T>  T maxi(vector<T>& a) { return max_element(all(a)) - a.begin(); }\ntemplate<class T>  T max(vector<T>& a, ll n) { return *max_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T>  T max(vector<T>& a, ll s, ll n) { return *max_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<typename A, size_t N> A max(A (&a)[N]) {    A res = a[0];    rep(i, N)res = max(res, a[i]);    return res;}template<typename A, size_t N, size_t O> A max(A (&a)[N][O]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P> A max(A (&a)[N][O][P]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A max(A (&a)[N][O][P][Q], const T &v) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A max(A (&a)[N][O][P][Q][R]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A max(A (&a)[N][O][P][Q][R][S]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}\ntemplate<typename A, size_t N> A min(A (&a)[N]) {    A res = a[0];    rep(i, N)res = min(res, a[i]);    return res;}template<typename A, size_t N, size_t O> A min(A (&a)[N][O]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P> A min(A (&a)[N][O][P]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A min(A (&a)[N][O][P][Q], const T &v) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A min(A (&a)[N][O][P][Q][R]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A min(A (&a)[N][O][P][Q][R][S]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}\ntemplate<class T> T sum(vector<T> &v, ll s, ll t) {    T ret = 0;    rep(i, s, min(sz(v), t))ret += v[i];    return ret;}\ntemplate<class T> T sum(vector<T> &v, ll t = inf) { return sum(v, 0, t); }\ntemplate<class T> T sum(vector<vector<T> > &v, int s, int t) {T ret = 0;rep(i, s, min(sz(v), t))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<T> > &v, int t = inf) { return sum(v, 0, t); }\ntemplate<class T> T sum(vector<vector<vector<T>> > &v, int s, int t) {T ret = 0;rep(i, s, min(sz(v), t))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<vector<T>> > &v, int t = inf) { return sum(v, 0, t); }\ntemplate<class T> T sum(vector<vector<vector<vector<T>>> > &v, int s, int t) {T ret = 0;rep(i, s, min(sz(v), t))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<vector<vector<T>>> > &v, int t = inf) { return sum(v, 0, t); }\ntemplate<class T> T sum(vector<vector<vector<vector<vector<T>>>> > &v, int s, int t) {T ret = 0;rep(i, s, min(sz(v), t))ret += sum(v[i]);return ret;}\ntemplate<class T> T sum(vector<vector<vector<vector<vector<T>>>> > &v, int t = inf) { return sum(v, 0, t); }\n\ntemplate<class T> auto sum(priority_queue<T, vector<T>, greater<T> > &r) {    auto q = r;    T ret = 0;    while (sz(q)) {        ret += q.top();        q.pop();    }    return ret;}\ntemplate<class T> auto sum(priority_queue<T> &r) {    auto q = r;    T ret = 0;    while (sz(q)) {        ret += q.top();        q.pop();    }    return ret;}\ntemplate<class T> T mul(vector<T> &v, ll t = inf) {    T ret = v[0];    rep(i, 1, min(t, sz(v)))ret *= v[i];    return ret;}\n\n//template<class T, class U, class... W>  auto sumn(vector<T> &v, U head, W... tail) {    auto ret = sum(v[0], tail...);    rep(i, 1, min(sz(v), head))ret += sum(v[i], tail...);    return ret;}\nvi v_i(vi &a) {    int n = max(a) + 1;    vi ret(n, -1);    rep(i, sz(a)) {        ret[a[i]] = i;    }    return ret;}\nvoid clear(PQ &q) { q = PQ(); }\nvoid clear(priority_queue<int>&q) { q = priority_queue<int>();}\ntemplate<class T> void clear(queue<T> &q) { while (q.size())q.pop(); }\ntemplate<class T> T *negarr(ll size) {    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));    return body + size;}\ntemplate<class T> T *negarr2(ll h, ll w) {    double **dummy1 = new double *[2 * h + 1];    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];    dummy1[0] = dummy2 + w;    for (ll i = 1; i <= 2 * h + 1; ++i) { dummy1[i] = dummy1[i - 1] + 2 * w + 1; }    double **a = dummy1 + h;    return a;}\n//imoは0-indexed\n//ruiは1-indexed\ntemplate<class T> vector<T> imo(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    return ret;}\n//kと同じものの数\ntemplate<class T, class U> vi imo(vector<T> &a, U k) {vector<T> ret = a;rep(i, sz(ret))ret[i] = a[i] == k;rep(i, sz(ret) - 1)ret[i + 1] += ret[i];return ret;}\ntemplate<class T> vector<T> imox(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] ^= ret[i];    return ret;}\n//漸化的に最小を持つ\ntemplate<class T> vector<T> imi(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chmi(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> ima(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chma(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> rimi(vector<T> &v) {    vector<T> ret = v;    rer(i, sz(ret) - 1, 1)chmi(ret[i - 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> rima(vector<T> &v) {    vector<T> ret = v;    rer(i, sz(ret) - 1, 1)chma(ret[i - 1], ret[i]);    return ret;}\ntemplate<class T> struct ruiC {\n    vector<T> rui;\n    ruiC(vector<T> &ru) : rui(ru) {}\n    /*先頭0*/\n    ruiC() : rui(1, 0) {}\n    T operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruic \";            deb(l, r);            assert(0);        }        return rui[r] - rui[l];    }\n    T operator()(int r = inf) { return operator()(0, min(r, sz(rui)-1)); }\n    /*ruiv[]をruic[]に変えた際意味が変わるのがまずいため()と統一*/\n    /*単体iを返す 累積でないことに注意(seg木との統一でこうしている)*/\n//    T operator[](ll i) { return rui[i + 1] - rui[i]; }\n    T operator[](ll i) { return rui[i]; }\n    /*0から順に追加される必要がある*/\n    void operator+=(T v) { rui.push_back(rui.back() + v); }\n    void add(int i, T v) {if (sz(rui) - 1 != i)ole();operator+=(v);}\n    T back() { return rui.back(); }\n    ll size() { return rui.size(); }\n    auto begin(){return rui.begin();}\n    auto end(){return rui.end();}\n};\ntemplate<class T> struct ruimax {template<typename Monoid>struct SegmentTree {        /*pairで処理*/        int sz;        vector<Monoid> seg;        const Monoid M1 = mp(MIN(T), -1);        Monoid f(Monoid a, Monoid b) {            return max(a, b);        }        void build(vector<T> &a) {            int n = sz(a);            sz = 1;            while (sz < n) sz <<= 1;            seg.assign(2 * sz, M1);            rep(i, n) { seg[i + sz] = mp(a[i], i); }            for (int k = sz - 1; k > 0; k--) {                seg[k] = f(seg[k << 1], seg[(k << 1) | 1]);            }        }        Monoid query(int a, int b) {            Monoid L = M1, R = M1;            for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {                if (a & 1) L = f(L, seg[a++]);                if (b & 1) R = f(seg[--b], R);            }            return f(L, R);        }        Monoid operator[](const int &k) const {            return seg[k + sz];        }    };private:vector<T> ve;SegmentTree<pair<T, int>> seg;vector<T> rv;vector<T> ri;bool build = false;\npublic:\n    int n;\n    ruimax(vector<T> &a) : ve(a), n(sz(a)) {        int index = -1;        int ma = MIN(T);        rv.resize(n + 1);        ri.resize(n + 1);        rv[0] = -linf;        ri[0] = -1;        rep(i, n) {            if (chma(ma, a[i])) {                index = i;            }            rv[i + 1] = ma;            ri[i + 1] = index;        }    }\n    T operator()(int l, int r) {        if (!(l <= r && 0 <= l && r <= n)) {            deb(l, r, n);            assert(0);        }        if (l == 0) {            return rv[r];        } else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).first;        }    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) {        return operator()(0, r);    }\n    T getv(int l, int r) {        return operator()(l, r);    }\n    T geti(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) {            return ri[r];        } else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).second;        }    }\n    T geti(int r = inf) { return geti(0, min(r,n)); };\n    T getv(int r = inf) { return getv(0, min(r,n)); };\n    auto begin(){return rv.begin();}\n    auto end(){return rv.end();}\n};\ntemplate<class T> struct ruimin {template<typename Monoid>    struct SegmentTree {  /*pairで処理*/         int sz;        vector<Monoid> seg;        const Monoid M1 = mp(MAX(T), -1);        Monoid f(Monoid a, Monoid b) {            return min(a, b);        }        void build(vector<T> &a) {            int n = sz(a);            sz = 1;            while (sz < n) sz <<= 1;            seg.assign(2 * sz, M1);            rep(i, n) { seg[i + sz] = mp(a[i], i); }            for (int k = sz - 1; k > 0; k--) {                seg[k] = f(seg[k << 1], seg[(k << 1) | 1]);            }        }        Monoid query(int a, int b) {            Monoid L = M1, R = M1;            for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {                if (a & 1) L = f(L, seg[a++]);                if (b & 1) R = f(seg[--b], R);            }            return f(L, R);        }        Monoid operator[](const int &k) const {            return seg[k + sz];        }    };private:vector<T> ve;SegmentTree<pair<T, int>> seg;vector<T> rv;vector<T> ri;bool build = false;int n;\npublic:\n    ruimin(vector<T> &a) : ve(a), n(sz(a)) {        int index = -1;        int mi = MAX(T);        rv.resize(n + 1);        ri.resize(n + 1);        rv[0] = linf;        ri[0] = -1;        rep(i, n) {            if (chmi(mi, a[i])) {                index = i;            }            rv[i + 1] = mi;            ri[i + 1] = index;        }    }\n    T operator()(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) {            return rv[r];        } else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).first;        }    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) {return operator()(0, r);}\n    T getv(int l, int r) {        return operator()(l, r);    }\n    T geti(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) {            return ri[r];        } else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).second;        }    }\n    T geti(int r = inf) { return geti(0, min(r,n)); };\n    T getv(int r = inf) { return getv(0, min(r,n)); };\n    auto begin(){return rv.begin();}\n    auto end(){return rv.end();}\n};\n\ntemplate<class T>ostream &operator<<(ostream &os, ruiC<T> a) {fora(v,a.rui)os<<v<<\" \";return os;}\ntemplate<class T> vector<T> ruiv(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i];    return ret;}\ntemplate<class T> ruiC<T> ruic() {return ruiC<T>();}\ntemplate<class T> ruiC<T> ruic(vector<T> &a) {    vector<T> ret = ruiv(a);    return ruiC<T>(ret);}\nvvi() ruib(vi &a) {    vvi(res, 61, sz(a) + 1);    rep(k, 61) {        rep(i, sz(a)) {            res[k][i + 1] = res[k][i] + ((a[i] >> k) & 1);        }    }    return res;}\nvector<ruiC<int>> ruibc(vi &a) {    vector<ruiC<int>> ret(61);    vvi(res, 61, sz(a));    rep(k, 61) {        rep(i, sz(a)) {            res[k][i] = (a[i] >> k) & 1;        }        ret[k] = ruic(res[k]);    }    return ret;}\nvector<ll> ruiv(string &a) {    if (sz(a) == 0)return vi(1);    ll dec = ('0' <= a[0] && a[0] <= '9') ? '0' : 0;    vector<ll> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i] - dec;    return ret;}\nruiC<ll> ruic(string &a) {    vector<ll> ret = ruiv(a);    return ruiC<ll>(ret);}\n//kと同じものの数\ntemplate<class T, class U> vi ruiv(T &a, U k) {    vi ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + (a[i] == k);    return ret;}\ntemplate<class T, class U> ruiC<ll> ruic(T &a, U k) {    vi ret = ruiv(a, k);    return ruiC<ll>(ret);}\ntemplate<class T> struct ruiC2 {\n    int H;\n    vector<ruiC<T>> rui;\n    ruiC2(vector<vector<T>> &ru) : rui(sz(ru)),H(sz(ru)) {        for (int h = 0; h < H; h++){            rui[h] = ruic(ru[h]);        }    }\n    //WについてHを返す\n    vector<T> operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruic \";            deb(l, r);            assert(0);        }        vector<T> res(H);        for (int h = 0; h < H; h++)res[h]=rui[h](l, r);        return res;    }\n    //HについてWを返す\n    ruiC<T> operator[](ll h){ assert(h<H);return rui[h]; }\n    //    vector<T> operator()(int r) { return operator()(0, r); }\n    /*ruiv[]をruic[]に変えた際意味が変わるのがまずいため()と統一*/\n    /*単体iを返す 累積でないことに注意(seg木との統一でこうしている)*/\n//    T operator[](ll i) { return rui[i + 1] - rui[i]; }\n    /*0から順に追加される必要がある*/\n//    T back() { return rui.back(); }\n//    ll size() { return rui.size(); }\n//    auto begin(){return rui.begin();}\n//    auto end(){return rui.end();}\n};\n\n//a~zを0~25として\n// rui(l,r)でvector(26文字について, l~rのcの個数)\n// rui[h] ruic()を返す\nruiC2<ll> ruicou(str &a) {    str s = a;    replace(s);    vector<ruiC<ll>> res(26);    vvi(cou, 26, sz(s));    rep(i, sz(s)) { cou[s[i]][i] = 1; }    return ruiC2<ll>(cou);}\nruiC2<ll> ruicou(vi &a) {    int H = max(a) + 1;    vector<ruiC<ll>> res(H);    vvi(cou, H, sz(a));    rep(i, sz(a)) { cou[a[i]][i] = 1; }    return ruiC2<ll>(cou);}\ntemplate<class T, class U>ruiC<ll> ruicou(vector<T>& a, U b){    vi cou(sz(a));    rep(i,sz(a)){        cou[i] = a[i]==b;    }    return ruic(cou);}\n//h query\ntemplate<class T> vector<T> imoh(vector<vector<T>> &v, int w) {vector<T> ret(sz(v));rep(h,sz(ret)){ret[h] = v[h][w];}rep(i, sz(ret) - 1){ret[i + 1] += ret[i];}return ret;}\ntemplate<class T> vector<T> ruih(vector<vector<T>> &v, int w) {vector<T> ret(sz(v) + 1);rep(h, sz(v)) { ret[h + 1] = v[h][w]; }rep(i, sz(v)) { ret[i + 1] += ret[i]; }return ret;}\ntemplate<class T> ruiC<T> ruihc(vector<vector<T>> &a, int w) {vector<T> ret = ruih(a, w);return ruiC<T>(ret);}\n\n//xor\ntemplate<class T> struct ruixC {    vector<T> rui;    ruixC(vector<T> &ru) : rui(ru) {}    T operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruiXc \";            deb(l, r);            assert(0);        }        return rui[r] ^ rui[l];    }    T operator[](ll i) { return rui[i]; }    T back() { return rui.back(); }    ll size() { return rui.size(); }};\ntemplate<class T> vector<T> ruix(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] ^ a[i];    return ret;}\ntemplate<class T> ruixC<ll> ruixc(vector<T>  &a) {vi ret = ruix(a);return ruixC<ll>(ret);}\ntemplate<class T> vector<T> ruim(vector<T> &a) {    vector<T> res(a.size() + 1, 1);    rep(i, a.size())res[i + 1] = res[i] * a[i];    return res;}\n//漸化的に最小を1indexで持つ\ntemplate<class T> vector<T> ruimi(vector<T> &a) {    ll n = sz(a);    vector<T> ret(n + 1);    rep(i, 1, n) {        ret[i] = a[i - 1];        chmi(ret[i + 1], ret[i]);    }    return ret;}\n//template<class T> T *rrui(vector<T> &a) {\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> struct rruiC {\n    vector<T> rui;\n    int n;\n    rruiC(vector<T> &a) : n(sz(a)) {rui.resize(n + 1);rer(i, n - 1) {rui[i] = rui[i + 1] + a[i];}}\n    /*[r l)*/\n    T operator()(int r, int l) {r++;l++;assert(l <= r && l >= 0 && r <= n);return rui[l] - rui[r];}\n    T operator()(int l) {return operator()(n - 1, l);}\n    T operator[](int i) {return operator()(i);}\n};\ntemplate<class T> ostream &operator<<(ostream &os, rruiC<T> a) {fora(v, a.rui)os << v << \" \";return os;}\n\n#define rrui rruic\ntemplate<class T> rruiC<T> rruic(vector<T> &a) { return rruiC<T>(a); }\n\n//掛け算\ntemplate<class T> struct ruimulC {\n    vector<T> rv;\n    int n;\n    ruimulC(vector<T> &a) : rv(a), n(sz(a)) {rv.resize(n + 1);rv[0] = 1;rep(i, n) { rv[i + 1] = a[i] * rv[i]; }}\n    ruimulC() : n(0) {rv.resize(n + 1);rv[0] = 1;}\n    void operator+=(T v) {rv.push_back(rv.back()*v);n++;}\n    T operator()(int l, int r) {assert(l <= r && 0 <= l && r <= n);return rv[r] / rv[l];}\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) { return operator()(0, r); }\n    auto begin() { return rv.begin(); }\n    auto end() { return rv.end(); }\n};\ntemplate<class T> ruimulC<T> ruimul(vector<T> &a) { return ruimulC<T>(a); }\ntemplate<class T> ruimulC<T> ruimul() {vector<T> a; return ruimulC<T>(a); }\n/*@formatter:off*/\ntemplate<class T> T *rruim(vector<T> &a) {    ll len = a.size();    T *body = (T *) malloc((len + 1) * sizeof(T));    T *res = body + 1;    res[len - 1] = 1;    rer(i, len - 1)res[i - 1] = res[i] * a[i];    return res;}\ntemplate<class T, class U> void inc(pair<T,U> &a, U v = 1) { a.first += v,a.second+=v; }\ntemplate<class T, class U> void inc(T &a, U v = 1) { a += v; }\ntemplate<class T, class U = int> void inc(vector<T> &a, U v = 1) { for (auto &u:a)inc(u, v); }\ntemplate<class T, class U> void dec(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U = int> void dec(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class U> void dec(string &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T,class U, class W> void dec(vector<T> &a,vector<U> &b, W v = 1) { for (auto &u :a)dec(u, v);for (auto &u :b)dec(u, v); }\ntemplate<class T,class U,class W> void dec(vector<T> &a,vector<U> &b,vector<W>&c ) { for (auto &u :a)dec(u, 1);for (auto &u :b)dec(u, 1);for (auto &u :c)dec(u, 1); }\nbool ins(ll h, ll w, ll H, ll W) { return h >= 0 && w >= 0 && h < H && w < W; }\nbool san(ll l, ll v, ll r) { return l <= v && v < r; }\ntemplate<class T> bool ins(vector<T> &a, ll i, ll j = 0) { return san(0, i, sz(a)) && san(0, j, sz(a)); }\n#define inside ins\nll u(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u(vector<T> &a) {    vector<T> ret = a;    fora(v, ret)v = u(v);    return ret;}\n\n//添え字を返す\ntemplate<class F> ll goldd_l(ll left, ll right, F calc) {    double GRATIO = 1.6180339887498948482045868343656;    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));    ll fl = calc(lm);    ll fr = calc(rm);    while (right - left > 10) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + (ll) ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    ll minScore = MAX(ll);    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (minScore > score) {            minScore = score;            resIndex = i;        }    }    return resIndex;}\ntemplate<class F> ll goldt_l(ll left, ll right, F calc) {        double GRATIO = 1.6180339887498948482045868343656;        ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));        ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));        ll fl = calc(lm);        ll fr = calc(rm);        while (right - left > 10) {            if (fl > fr) {                right = rm;                rm = lm;                fr = fl;                lm = left + (ll) ((right - left) / (GRATIO + 1.0));                fl = calc(lm);            } else {                left = lm;                lm = rm;                fl = fr;                rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));                fr = calc(rm);            }        }    if (left > right) {        ll l = left;        left = right;        right = l;    }    ll maxScore = MIN(ll);    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (maxScore < score) {            maxScore = score;            resIndex = i;        }    }    return resIndex;}\n/*loopは200にすればおそらく大丈夫 余裕なら300に*/\ntemplate<class F> dou goldd_d(dou left, dou right, F calc, ll loop = 200) {    dou GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    /*200にすればおそらく大丈夫*/    /*余裕なら300に*/    ll k = 141;    loop++;    while (--loop) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return left;}\ntemplate<class F> dou goldt_d(dou left, dou right, F calc, ll loop = 200) {    double GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    loop++;    while (--loop) {        if (fl > fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return left;}\n//l ~ rを複数の区間に分割し、極致を与えるiを返す time-20 msまで探索\ntemplate<class F> ll goldd_ls(ll l, ll r, F calc, ll time = 2000) {    auto lim = milliseconds(time - 20);    ll mini = 0, minv = MAX(ll);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldd_l(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return mini;}\ntemplate<class F> ll goldt_ls(ll l, ll r, F calc, ll time = 2000) {    auto lim = milliseconds(time - 20);    ll maxi = 0, maxv = MIN(ll);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldt_l(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return maxi;}\ntemplate<class F> dou goldd_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を持つ*/    auto lim = milliseconds(time - 20);    dou mini = 0, minv = MAX(dou);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldd_d(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return mini;}\ntemplate<class F> dou goldt_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を残している*/    auto lim = milliseconds(time - 20);    dou maxi = 0, maxv = MIN(dou);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldt_d(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return maxi;}\ntemplate<class T> T min(vector<vector<T >> &a) {    T res = MAX(T);    rep(i, a.size())chmi(res, *min_element(all(a[i])));    return res;}\ntemplate<class T> T max(vector<vector<T >> &a) {    T res = MIN(T);    rep(i, a.size())chma(res, *max_element(all(a[i])));    return res;}\ntemplate<class T> T min(vector<vector<vector<T>>> &a) {    T res = MAX(T);    rep(i, a.size())chmi(res, min(a[i]));    return res;}\ntemplate<class T> T max(vector<vector<vector<T>>> &a) {    T res = MIN(T);    rep(i, a.size())chma(res, max(a[i]));    return res;}\ntemplate<class T> T min(vector<vector<vector<vector<T>>>> &a) {    T res = MAX(T);    rep(i, a.size())chmi(res, min(a[i]));    return res;}\ntemplate<class T> T max(vector<vector<vector<vector<T>>>> &a) {    T res = MIN(T);    rep(i, a.size())chma(res, max(a[i]));    return res;}\ntemplate<class T> T min(vector<vector<vector<vector<vector<T>>>>> &a) {    T res = MAX(T);    rep(i, a.size())chmi(res, min(a[i]));    return res;}\ntemplate<class T> T max(vector<vector<vector<vector<vector<T>>>>> &a) {    T res = MIN(T);    rep(i, a.size())chma(res, max(a[i]));    return res;}\ntemplate<class T> T min(vector<vector<vector<vector<vector<vector<T>>>>>> &a) {    T res = MAX(T);    rep(i, a.size())chmi(res, min(a[i]));    return res;}\ntemplate<class T> T max(vector<vector<vector<vector<vector<vector<T>>>>>> &a) {    T res = MIN(T);    rep(i, a.size())chma(res, max(a[i]));    return res;}\n//pow周りの仕様\n//powiを使うと整数型\n//powbを使うとbint型\n//powを使うと powlに変換され long doubleが返る\n#ifdef _DEBUG\n//整数値の場合はpowiを使った方がいいというメッセージを出すための物\nauto my_powl(ll a, ll k){return powl(a,k);}\nauto pow(ll a,ll k){    static bool was = 1;    if(was){message +=\"if integer use *powi* it's very fast\\n\";}    was=0;    return my_powl(a,k);}\n//上のメッセージを出すための関数\nauto pow(signed a,ll k){    return pow((ll)a,k);}\nauto pow(signed a,signed k){    return pow((ll)a,(ll)k);}\n#endif\n\n//整数型のpow\nint powi(int a, int k) {    if (a == 2)return 1ll << k;    int res = 1;    int x = a;    while (k) {        if(k & 1)res *= x;        x *= x;        k >>= 1;    }    return res;}\n//define pow powlより上に動かすとバグる\nbint pow(bint a, ll k) {    bint res = 1;    bint x = a;    while (k) {        if(k & 1)res *= x;        x *= x;        k >>= 1;    }    return res;}\nbint pow(bint a, signed k) {return pow(a,(ll)k);}\nbint powb(int a, int b){return pow((bint)a,b);}\nconstexpr bool bget(ll m, ll keta) {\n    #ifdef _DEBUG\n        assert(keta<=62);//オーバーフロー 1^62までしか扱えない\n    #endif\n    return (m >> keta) & 1; }\n//bget(n)次元\n//                          NならN-1まで\nvector<vi> bget2(vi& a,int keta_size){    vvi(res,keta_size,sz(a));    rep(k,keta_size){        rep(i, sz(a)){            res[k][i]=bget(a[i],k);        }    }    return res;}\nvi bget1(vi& a,int keta){    vi res(sz(a));    rep(i, sz(a)){        res[i]=bget(a[i],keta);    }    return res;}\nll bget(ll m, ll keta, ll sinsuu) {    m /= (ll) pow(sinsuu, keta);    return m % sinsuu;}\nconstexpr ll bit(ll n) {\n    #ifdef _DEBUG\n        assert(n<=62);//オーバーフロー 1^62までしか扱えない\n    #endif\n    return (1LL << (n)); }\nll bit(ll n, ll sinsuu) { return (ll) pow(sinsuu, n); }\nll mask(ll n) { return (1ll << n) - 1; }\n//aをbitに置きなおす\n//{0, 2} -> 101\nll bit(vi&a){    int m=0;    for(auto&& v:a) m|=bit(v);    return m;}\n\n//{1, 1, 0} -> 011\n//bitsetに置き換える感覚 i が立っていたら i bit目を立てる\nll bit_bool(vi&a){    int m=0;    rep(i,sz(a)) if(a[i])m|=bit(i);    return m;}\n#define bcou __builtin_popcountll\n//最下位ビット\nll lbit(ll n) { return n & -n; }\nll lbiti(ll n) { return log2(n & -n); }\n//最上位ビット\nll hbit(ll n) {    n |= (n >> 1);    n |= (n >> 2);    n |= (n >> 4);    n |= (n >> 8);    n |= (n >> 16);    n |= (n >> 32);    return n - (n >> 1);}\nll hbiti(ll n){return log2(hbit(n));}\nll hbitk(ll n) {    ll k = 0;    rer(i, 5) {        ll a = k + (1ll << i);        ll b = 1ll << a;        if (b <= n)k += 1ll << i;    }    return k;}\n//初期化は0を渡す\nll nextComb(ll &mask, ll n, ll r) {    if (!mask)return mask = (1LL << r) - 1;    ll x = mask & -mask; /*最下位の1*/    ll y = mask + x; /*連続した下の1を繰り上がらせる*/    ll res = ((mask & ~y) / x >> 1) | y;    if (bget(res, n))return mask = 0; else return mask = res;}\n//n桁以下でビットがr個立っているもののvectorを返す\nvi bitCombList(ll n, ll r) {    vi res;    ll m = 0;    while (nextComb(m, n, r)) { res.push_back(m); }    return res;}\n/*over*/#define forbit1_2(i, mas) for (int forbitj = lbit(mas), forbitm = mas, i = log2(forbitj); forbitm; forbitm = forbitj ? forbitm ^ forbitj : 0, forbitj = lbit(forbitm), i = log2(forbitj))\n/*over*/#define forbit1_3(i, N, mas) for (int forbitj = lbit(mas), forbitm = mas, i = log2(forbitj); forbitm && i < N; forbitm = forbitj ? forbitm ^ forbitj : 0, forbitj = lbit(forbitm), i = log2(forbitj))\n//masの立ってるindexを見る\n//              i, [N], mas\n#define forbit1(...) over3(__VA_ARGS__, forbit1_3, forbit1_2)(__VA_ARGS__)\n//masが立っていないindexを見る\n//              i, N, mas\n#define forbit0(i, N, mas) forbit1(i, mask(N) & (~(mas)))\n\n\n\n//aにある物をtrueとする\nvb bool_(vi&a,int n){    vb ret(max(max(a)+1,n));    rep(i,sz(a))ret[a[i]] = true;    return ret;}\n\nchar itoal(ll i) { return 'a' + i; }\nchar itoaL(ll i) { return 'A' + i; }\nll altoi(char c) {    if ('A' <= c && c <= 'Z')return c - 'A';    return c - 'a';}\nll ctoi(char c) { return c - '0'; }\nchar itoc(ll i) { return i + '0'; }\nll vtoi(vi &v) {    ll res = 0;    if (sz(v) > 18) {        debugline(\"vtoi\");        deb(sz(v));        ole();    }    rep(i, sz(v)) {        res *= 10;        res += v[i];    }    return res;}\nvi itov(ll i) {    vi res;    while (i) {        res.push_back(i % 10);        i /= 10;    }    res = rev(res);    return res;}\nvi stov(string &a) {    ll n = sz(a);    vi ret(n);    rep(i, n) { ret[i] = a[i] - '0'; }    return ret;}\n//基準を満たさないものは0になる\nvi stov(string &a, char one) {    ll n = sz(a);    vi ret(n);    rep(i, n)ret[i] = a[i] == one;    return ret;}\nvector<vector<ll>> ctoi(vector<vector<char>> s, char c) {    ll n = sz(s), m = sz(s[0]);    vector<vector<ll>> res(n, vector<ll>(m));    rep(i, n)rep(j, m)res[i][j] = s[i][j] == c;    return res;}\n//[i] := vを返す\n//aは0~n-1で置き換えられる\nvi compress(vi &a) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(all(b), a[i]) - b.begin(); }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, umap<ll, ll> &map) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) {        ll v = a[i];        a[i] = lower_bound(all(b), a[i]) - b.begin();        map[v] = a[i];    }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r) {    vi b;    ll len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r, vi &s) {    vi b;    ll len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    fora(v, s)b.push_back(v);    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    for (ll i = 0; i < sz(s); ++i) r[i] = lower_bound(all(b), s[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vi> &a) {    vi b;    fora(vv, a)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vv, a)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vector<vi >> &a) {    vi b;    fora(vvv, a)fora(vv, vvv)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vvv, a)fora(vv, vvv)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvoid compress(ll a[], ll len) {    vi b;    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(all(b), a[i]) - b.begin(); }}\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(all(a),v))\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n#define rlowerIndex(a, v) (upper_bound(all(a),v)-a.begin()-1)\n#define rupperIndex(a, v) (lower_bound(all(a),v)-a.begin()-1)\n\ntemplate<class T, class U, class W> T lowerBound(vector<T> &a, U v, W banpei) {auto it = lower_bound(a.begin(), a.end(), v);if (it == a.end())return banpei; else return *it;}template<class T, class U, class W> T lowerBound(ruiC<T> &a, U v, W banpei) {return lowerBound(a.rui, v, banpei);}\ntemplate<class T, class U, class W> T upperBound(vector<T>& a, U v, W banpei){    auto it = upper_bound(a.begin(),a.end(),v);    if(it==a.end())return banpei;    else return *it;}template<class T, class U, class W> T upperBound(ruiC<T> &a, U v, W banpei) {return upperBound(a.rui, v, banpei);}\ntemplate<class T, class U, class W> T rlowerBound(vector<T> &a, U v, W banpei) {    auto it = upper_bound(a.begin(), a.end(), v);    if (it == a.begin())return banpei;    else{        return *(--it);    }}template<class T, class U, class W> T rlowerBound(ruiC<T> &a, U v, W banpei) {return rlowerBound(a.rui, v, banpei);}\ntemplate<class T, class U, class W> T rupperBound(vector<T> &a, U v, W banpei) {    auto it = lower_bound(a.begin(), a.end(), v);    if (it == a.begin())return banpei;    else{        return *(--it);    }}template<class T, class U, class W> T rupperBound(ruiC<T> &a, U v, W banpei) {return rupperBound(a.rui, v, banpei);}\n#define next2(a) next(next(a))\n#define prev2(a) prev(prev(a))\n\n//狭義の単調増加列 長さを返す\ntemplate<class T> int lis(vector<T> &a) {    int n = sz(a);    vi tail(n + 1, MAX(T));    rep(i, n) {        int id = lowerIndex(tail, a[i]);/**/        tail[id] = a[i];    }    return lowerIndex(tail, MAX(T));}\ntemplate<class T> int lis_eq(vector<T> &a) {    int n = sz(a);    vi tail(n + 1, MAX(T));    rep(i, n) {        int id = upperIndex(tail, a[i]);/**/        tail[id] = a[i];    }    return lowerIndex(tail, MAX(T));}\n\n//iteratorを返す\n//valueが1以上の物を返す 0は見つけ次第削除\n//vを減らす場合 (*it).se--でいい\ntemplate<class T, class U, class V> auto lower_map(map<T, U> &m, V k) {    auto ret = m.lower_bound(k);    while (ret != m.end() && (*ret).second == 0) {        ret = m.erase(ret);    }    return ret;}\ntemplate<class T, class U, class V> auto upper_map(map<T, U> &m, V k) {    auto ret = m.upper_bound(k);    while (ret != m.end() && (*ret).second == 0) {        ret = m.erase(ret);    }    return ret;}\n//存在しなければエラー\ntemplate<class T, class U, class V> auto rlower_map(map<T, U> &m, V k) {    auto ret = upper_map(m, k);    assert(ret != m.begin());    ret--;    while (1) {        if ((*ret).second != 0)break;        assert(ret != m.begin());        auto next = ret;        --next;        m.erase(ret);        ret = next;    }    return ret;}\ntemplate<class T, class U, class V> auto rupper_map(map<T, U> &m, V k) {    auto ret = lower_map(m, k);    assert(ret != m.begin());    ret--;    while (1) {        if ((*ret).second != 0)break;        assert(ret != m.begin());        auto next = ret;        --next;        m.erase(ret);        ret = next;    }    return ret;}\n\ntemplate<class... T> void fin(T... s) {out(s...); exit(0); }\n\n//便利 数学 math\n//sub ⊂ top\nbool subset(int sub, int top) {return (sub & top) == sub;}\n//-180 ~ 180 degree\ndouble atand(double h, double w) {return atan2(h, w) / PI * 180;}\n//% -mの場合、最小の正の数を返す\nll mod(ll a, ll m) {if (m < 0) m *= -1;return (a % m + m) % m;}\nll pow(ll a) { return a * a; };\nll fact(ll v) { return v <= 1 ? 1 : v * fact(v - 1); }\ndou factd(int v){static vd fact(2,1);    if(sz(fact)<=v){        rep(i,sz(fact),v+1){            fact.push_back(fact.back()*i);        }    }    return fact[v];}\n\nll comi(ll n, ll r) {    assert(n < 100);    static vvi(pas, 100, 100);    if (pas[0][0])return pas[n][r];    pas[0][0] = 1;    rep(i, 1, 100) {        pas[i][0] = 1;        rep(j, 1, i + 1)pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];    }    return pas[n][r];}\ndouble comd2(ll n, ll r) {    static vvd(comb, 2020, 2020);    if (comb[0][0] == 0) {        comb[0][0] = 1;        rep(i, 2000) {            comb[i + 1][0] = 1;            rep(j, 1, i + 2) { comb[i + 1][j] = comb[i][j] + comb[i][j - 1]; }        }    }    return comb[n][r];}\ndouble comd(int n, int r) {    if (r < 0 || r > n) return 0;    if (n < 2020)return comd2(n, r);    static vd fact(2, 1);    if (sz(fact) <= n) { rep(i, sz(fact), n + 1) { fact.push_back(fact.back() * i); }}    return fact[n] / fact[n - r] / fact[r];}\n\nll gcd(ll a, ll b) {while (b) a %= b, swap(a, b);return abs(a);}\nll gcd(vi b) {ll res = b[0];rep(i, 1, sz(b))res = gcd(b[i], res);return res;}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll lcm(vi a) {ll res = a[0];rep(i, 1, sz(a))res = lcm(a[i], res);return res;}\nll ceil(ll a, ll b) {if (b == 0) {debugline(\"ceil\");deb(a, b);ole();return -1;} else if (a < 0) { return 0; } else { return (a + b - 1) / b; }}\n\nll sig0(int t) { return t <= 0 ? 0 : ((1 + t) * t) >> 1; }\nbint sig0(bint t) {return t <= 0 ? 0 : ((1 + t) * t) >> 1; }\n//ll sig(ll s, ll t) { return ((s + t) * (t - s + 1)) >> 1; }\nll sig(ll s, ll t) {if (s > t)swap(s, t);return sig0(t - s) + s * (t - s + 1);}\n\n#define tousa_i tosa_i\n#define lower_tousa_i lower_tosa_i\n#define upper_tousa upper_tosa\n#define upper_tousa_i upper_tosa_i\nll tosa_i(ll st, ll ad, ll v) {    assert(((v - st) % ad) == 0);    return (v - st) / ad;}\nll tosa_s(ll st, ll ad, ll len) {    return st * len + sig0(len - 1) * ad;}\n\n// ax + r (x は非負整数) で表せる整数のうち、v 以上となる最小の整数\nll lower_tosa(ll st, ll ad, ll v) {    if (st >= v) return st;    return (v - st + ad - 1) / ad * ad + st;}\n//第何項か\nll lower_tosa_i(ll st, ll ad, ll v) {    if (st >= v) return 0;    return (v - st + ad - 1) / ad;}\nll upper_tosa(ll st, ll ad, ll v) { return lower_tosa(st, ad, v + 1); }\nll upper_tosa_i(ll st, ll ad, ll v) { return lower_tosa_i(st, ad, v + 1); }\n\n\n//v * v >= aとなる最小のvを返す\nll sqrt(ll a) {    if (a < 0) {        debugline(\"sqrt\");        deb(a);        ole();    }    ll res = (ll) std::sqrt(a);    while (res * res < a)++res;    return res;}\ndouble log(double e, double x) { return log(x) / log(e); }\n\n//b * res <= aを満たす [l, r)を返す\nP drange_ika(int a, int b) {    assert(b);    if (a >= 0) {        if (b > 0)return mp(-linf, a / b + 1);        else return mp(-(a / -b), linf + 1);    } else {        if (b > 0)return mp(-linf, -ceil(-a, b) + 1);        else return mp(ceil(-a, -b), linf + 1);    }}\n\n/*@formatter:off*/\n\n//機能拡張\n#define dtie(a, b) int a, b; tie(a, b)\ntemplate<class T, class U> string to_string(T a, U b) {    string res = \"\";    res += a;    res += b;    return res;}\ntemplate<class T, class U, class V> string to_string(T a, U b, V c) {    string res = \"\";    res += a;    res += b;    res += c;    return res;}\ntemplate<class T, class U, class V, class W> string to_string(T a, U b, V c, W d) {    string res = \"\";    res += a;    res += b;    res += c;    res += d;    return res;}\ntemplate<class T, class U, class V, class W, class X> string to_string(T a, U b, V c, W d, X e) {    string res = \"\";    res += a;    res += b;    res += c;    res += d;    res += e;    return res;}\n\ntemplate<class T> vector<T> sub(vector<T> &A, int l, int r) {    assert(0 <= l && l <= r && r <= sz(A));    vector<T> ret(r - l);    std::copy(A.begin() + l, A.begin() + r, ret.begin());    return ret;}\ntemplate<class T> vector<T> sub(vector<T> &A, int r) { return sub(A, 0, r); }\ntemplate<class T> vector<T> subn(vector<T> &A, int l, int len) { return sub(A, l, l + len); }\nstring sub(string &A, int l, int r) {    assert(0 <= l && l <= r && r <= sz(A));    return A.substr(l, r - l);}\n\nconstexpr int bsetlen = k5 * 2;\n//constexpr int bsetlen = 5050;\n#define bset bitset<bsetlen>\nbool operator<(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] < b[i])return true;if (a[i] > b[i])return false;}return false;}\nbool operator>(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] > b[i])return true;if (a[i] < b[i])return false;}return false;}\nbool operator<=(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] < b[i])return true;if (a[i] > b[i])return false;}return true;}\nbool operator>=(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] > b[i])return true;if (a[i] < b[i])return false;}return true;}\nstring operator~(string &a) {string res = a;for (auto &&c:res) {if (c == '0')c = '1';else if (c == '1')c = '0';else {cerr << \"cant ~\" << a << \"must bit\" << endl;exit(0);}}return res;}\nostream &operator<<(ostream &os, bset& a) {    bitset<10> b;    vi list;    rep(i,bsetlen){        if(a[i])list.push_back(i),b[i]=1;    }    os<<b<<\", \"<<list;    return os;}\nint hbiti(bset&a){rer(i,bsetlen){if(a[i])return i;}return -1;}\n#define hk(a, b, c) (a <= b && b < c)\n\n//O(N/64)\nbset nap(bset &a, int v) {bset r = a | a << v;return r;}\nbset nap(bset &a, bset &v) {bset r = a;rep(i, bsetlen) {if (v[i])r |= a << i;}return r;}\n\ntemplate<class T> int count(set<T> &S, T l, T r) {    assert(l < r);    auto it = S.lower_bound(l);    return it != S.end() && (*it) < r;}\n\ntemplate<class T> void seth(vector<vector<T>> &S, int w, vector<T> &v) {assert(sz(S) == sz(v));assert(w < sz(S[0]));rep(h, sz(S)) { S[h][w] = v[h]; }}\n\ntemplate<class T, class U> void operator+=(pair<T,U> &a, pair<T,U> & b) {a.fi+=b.fi;a.se+=b.se;}\ntemplate<class T, class U> pair<T,U> operator+(pair<T,U> &a, pair<T,U> & b) {return pair<T,U>(a.fi+b.fi,a.se+b.se);}\n\ntemplate<typename CharT, typename Traits, typename Alloc>basic_string<CharT, Traits, Alloc>operator+(const basic_string<CharT, Traits, Alloc> &lhs, const int rv) {    basic_string<CharT, Traits, Alloc> str(lhs);    str.append(to_string(rv));    return str;}template<typename CharT, typename Traits, typename Alloc>void operator+=(basic_string<CharT, Traits, Alloc> &lhs, const int rv) {    lhs += to_string(rv);}template<typename CharT, typename Traits, typename Alloc>basic_string<CharT, Traits, Alloc>operator+(const basic_string<CharT, Traits, Alloc> &lhs, const signed rv) {    basic_string<CharT, Traits, Alloc> str(lhs);    str.append(to_string(rv));    return str;}template<typename CharT, typename Traits, typename Alloc>void operator+=(basic_string<CharT, Traits, Alloc> &lhs, const signed rv) {    lhs += to_string(rv);}\ntemplate<typename CharT, typename Traits, typename Alloc> void operator*=(basic_string<CharT, Traits, Alloc> &s, int num) {auto bek = s;s = \"\";for (; num; num >>= 1) {if (num & 1) {s += bek;}bek += bek;}}\ntemplate<class T, class U> void operator+=(queue<T> &a, U v) { a.push(v); }template<class T, class U> void operator+=(deque<T> &a, U v) { a.push_back(v); }template<class T> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, vector<T> &v) {    fora(d, v)a.push(d);    return a;}template<class T, class U> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, U v) {    a.push(v);    return a;}template<class T, class U> priority_queue<T> &operator+=(priority_queue<T> &a, U v) {    a.push(v);    return a;}template<class T> set<T> &operator+=(set<T> &a, vector<T> v) {    fora(d, v)a.insert(d);    return a;}template<class T, class U> auto operator+=(set<T> &a, U v) { return a.insert(v); }template<class T, class U> auto operator-=(set<T> &a, U v) { return a.erase(v); }template<class T, class U> auto operator+=(mset<T> &a, U v) { return a.insert(v); }template<class T, class U> set<T, greater<T>> &operator+=(set<T, greater<T>> &a, U v) {    a.insert(v);    return a;}template<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {    a.push_back(v);    return a;}template<class T, class U> vector<T> operator+(vector<T> &a, U v) {    vector<T> ret = a;    ret += v;    return ret;}template<class T, class U> vector<T> operator+(U v, vector<T> &a) {    vector<T> ret = a;    ret.insert(ret.begin(), v);    return ret;}template<class T> vector<T> operator+(vector<T> a, vector<T> b) {    vector<T> ret;    ret = a;    fora(v, b)ret += v;    return ret;}template<class T> vector<T> &operator+=(vector<T> &a, vector<T> &b) {    rep(i, sz(b)) {/*こうしないとa+=aで両辺が増え続けてバグる*/        a.push_back(b[i]); }    return a;}template<class T, class U> map<T, U> &operator+=(map<T, U> &a, map<T, U> &b) {    fora(bv, b) { a[bv.first] += bv.second; }    return a;}\ntemplate<class T> vector<T> operator%(vector<T>& a, int v){    vi ret(sz(a));    rep(i,sz(a)){        ret[i] = a[i] % v;    }    return ret;}\ntemplate<class T> vector<T> operator%=(vector<T>& a, int v){    rep(i,sz(a)){        a[i] %= v;    }    return a;}\nvi operator&(vi& a, vi& b){    assert(sz(a)==sz(b));    vi ret(sz(a));    rep(i,sz(a)){        ret[i] = min(a[i],b[i]);    }    return ret;}\ntemplate<class T> void operator+=(mset<T> &a, vector<T>& v) { for(auto&& u : v)a.insert(u); }\ntemplate<class T> void operator+=(set<T> &a, vector<T>& v) { for(auto&& u : v)a.insert(u); }\ntemplate<class T> void operator+=(vector<T> &a, set<T>& v) { for(auto&& u : v)a.emplace_back(u); }\ntemplate<class T> void operator+=(vector<T> &a, mset<T>& v) { for(auto&& u : v)a.emplace_back(u); }\ntemplate<class T> vector<T> &operator-=(vector<T> &a, vector <T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-=\");        deb(a);        deb(b);        exit(0);    }    rep(i, sz(a))a[i] -= b[i];    return a;}\ntemplate<class T> vector<T> operator-(vector<T> &a, vector<T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-\");        deb(a);        deb(b);        ole();    }    vector<T> res(sz(a));    rep(i, sz(a))res[i] = a[i] - b[i];    return res;}\ntemplate<class T, class U> void operator*=(vector<T> &a, U b) {    vector<T> ta = a;    rep(b-1){        a+=ta;    }}\ntemplate<typename T> void erase(vector<T> &v, unsigned ll i) { v.erase(v.begin() + i); }\ntemplate<typename T> void erase(vector<T> &v, unsigned ll s, unsigned ll e) { v.erase(v.begin() + s, v.begin() + e); }\ntemplate<typename T> void entry(vector<T> &v, unsigned ll s, unsigned ll e) { erase(v, e, sz(v));erase(v,0,s);}\n\ntemplate<class T, class U> void erase(map<T, U> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<class T> void erase(set<T> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<typename T> void erasen(vector<T> &v, unsigned ll s, unsigned ll n) { v.erase(v.begin() + s, v.begin() + s + n); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, U t) { v.insert(v.begin() + i, t); }\ntemplate<typename T, typename U> void push_front(vector<T> &v, U t) { v.insert(v.begin(), t); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, vector<T> list) { for (auto &&va:list)v.insert(v.begin() + i++, va); }\ntemplate<typename T> void insert(set<T> &v, vector<T> list) { for (auto &&va :list)v.insert(va); }\ntemplate<class T> T poll(set<T>& S){T ret = *S.begin();S.erase(S.begin());return ret;}\ntemplate<class T> T poll(mset<T>& S){T ret = *S.begin();S.erase(S.begin());return ret;}\ntemplate<class T> T poll_back(set<T>& S){T ret = *S.rbegin();S.erase(S.rbegin());return ret;}\ntemplate<class T> T poll_back(mset<T>& S){T ret = *S.rbegin();S.erase(S.rbegin());return ret;}\ntemplate<class T> T peek(set<T>& S){T ret = *S.begin();return ret;}\ntemplate<class T> T peek(mset<T>& S){T ret = *S.begin();return ret;}\ntemplate<class T> T peek_back(set<T>& S){T ret = *S.rbegin();return ret;}\ntemplate<class T> T peek_back(mset<T>& S){T ret = *S.rbegin();return ret;}\nvector<string> split(const string a, const char deli) {    string b = a + deli;    ll l = 0, r = 0, n = b.size();    vector<string> res;    rep(i, n) {        if (b[i] == deli) {            r = i;            if (l < r)res.push_back(b.substr(l, r - l));            l = i + 1;        }    }    return res;}\nvector<string> split(const string a, const string deli) {    vector<string> res;    ll kn = sz(deli);    std::string::size_type Pos(a.find(deli));    ll l = 0;    while (Pos != std::string::npos) {        if (Pos - l)res.push_back(a.substr(l, Pos - l));        l = Pos + kn;        Pos = a.find(deli, Pos + kn);    }    if (sz(a) - l)res.push_back(a.substr(l, sz(a) - l));    return res;}\nll stoi(string& s){return stol(s);}\n#define assert_yn(yn_v, v); assert(yn_v == 0 || yn_v == v);yn_v = v;\n//不完全な対策、現状はautohotkeyで対応\nint yn_v = 0;\nvoid yn(bool a) { assert_yn(yn_v, 1);if (a)cout << \"yes\" << endl; else cout << \"no\" << endl; }\nvoid fyn(bool a) {    assert_yn(yn_v, 1);yn(a);    exit(0);}\n\nvoid Yn(bool a) { assert_yn(yn_v, 2);if (a)cout << \"Yes\" << endl; else cout << \"No\" << endl; }\nvoid fYn(bool a) {    assert_yn(yn_v, 2);Yn(a);    exit(0);}\n\nvoid YN(bool a) { assert_yn(yn_v, 3);if (a)cout << \"YES\" << endl; else cout << \"NO\" << endl; }\nvoid fYN(bool a) {    assert_yn(yn_v, 3);YN(a);    exit(0);}\nint ab_v = 0;\nvoid fAb(bool a) { assert_yn(ab_v, 1);if(a)cout<<\"Alice\"<<endl;else cout<<\"Bob\";}\nvoid fAB(bool a) { assert_yn(yn_v, 2);if(a)cout<<\"ALICE\"<<endl;else cout<<\"BOB\";}\nint pos_v = 0;\nvoid Possible(bool a) {    assert_yn(pos_v, 1);if (a)cout << \"Possible\" << endl; else cout << \"Impossible\" << endl;    exit(0);}\nvoid POSSIBLE(bool a) {    assert_yn(pos_v, 2);if (a)cout << \"POSSIBLE\" << endl; else cout << \"IMPOSSIBLE\" << endl;    exit(0);}\nvoid fPossible(bool a) {    assert_yn(pos_v, 1)Possible(a);exit(0);}\nvoid fPOSSIBLE(bool a) {    assert_yn(pos_v, 2)POSSIBLE(a);exit(0);}\ntemplate<typename T> class fixed_point        : T {public:    explicit constexpr fixed_point(T &&t) noexcept: T(std::forward<T>(t)) {}    template<typename... Args> constexpr decltype(auto) operator()(Args &&... args) const { return T::operator()(*this, std::forward<Args>(args)...); }};template<typename T> static inline constexpr decltype(auto) fix(T &&t) noexcept { return fixed_point<T>{std::forward<T>(t)}; }\n\n\n//未分類\n//0,2,1 1番目と2番目の次元を入れ替える\ntemplate<class T> auto irekae(vector<vector<vector<T> > > &A, int x, int y, int z) {\n#define irekae_resize_loop(a, b, c) resize(res,a,b,c);rep(i,a)rep(j,b)rep(k,c)\n    vector<vector<vector<T> > > res;    if (x == 0 && y == 1 && z == 2) {        res = A;    } else if (x == 0 && y == 2 && z == 1) {        irekae_resize_loop(sz(A), sz(A[0][0]), sz(A[0])) {                    res[i][j][k] = A[i][k][j];                }    } else if (x == 1 && y == 0 && z == 2) {        irekae_resize_loop(sz(A[0]), sz(A), sz(A[0][0])) {                    res[i][j][k] = A[j][i][k];                }    } else if (x == 1 && y == 2 && z == 0) {        irekae_resize_loop(sz(A[0]), sz(A[0][0]), sz(A)) {                    res[i][j][k] = A[k][i][j];                }    } else if (x == 2 && y == 0 && z == 1) {        irekae_resize_loop(sz(A[0][0]), sz(A), sz(A[0])) {                    res[i][j][k] = A[j][k][i];                }    } else if (x == 2 && y == 1 && z == 0) {        irekae_resize_loop(sz(A[0][0]), sz(A[0]), sz(A)) {                    res[i][j][k] = A[k][j][i];                }    }    return res;\n#undef irekae_resize_loop\n}\ntemplate<class T> auto irekae(vector<vector<T>>&A,int i=1,int j=0){    vvt(res,sz(A[0]),sz(A));    rep(i,sz(A)){        rep(j,sz(A[0])){            res[j][i]=A[i][j];        }    }    return res;}\n//tou分割する\ntemplate<typename T> vector<vector<T>> cut(vector<T> &a, int tou = 2) {    int N = sz(a);    vector<vector<T>> res(tou);    int hab = N / tou;    vi lens(tou, hab);    rep(i, N % tou) { lens[tou - 1 - i]++; }    int l = 0;    rep(i, tou) {        int len = lens[i];        int r = l + len;        res[i].resize(len);        std::copy(a.begin() + l, a.begin() + r, res[i].begin());        l = r;    }    return res;}\n//長さn毎に分割する\ntemplate<typename T> vector<vector<T>> cutn(vector<T> &a, int len) {    int N = sz(a);    vector<vector<T>> res(ceil(N, len));    vi lens(N / len, len);    if (N % len)lens.push_back(N % len);    int l = 0;    rep(i, sz(lens)) {        int len = lens[i];        int r = l + len;        res[i].resize(len);        std::copy(a.begin() + l, a.begin() + r, res[i].begin());        l = r;    }    return res;}\nvi inds_(vi &a) {    int n = sz(a);    vb was(n);    vi res(n);    rep(i, n) {        assert(!was[a[i]]);        res[a[i]] = i;        was[a[i]] = true;    }    return res;}\n//縦を返す\nvi& geth(vvi()& a, int w){    static vi ret; ret.resize(sz(a));   rep(i,sz(a)){        ret[i] = a[i][w];    }    return ret;}\n\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} initonv;\n#define pre prev\n#define nex next\n\n//gra mll pr\n//上下左右\nconst string udlr = \"udlr\";\nstring UDLR = \"UDLR\";//x4と連動 UDLR.find('U') := x4[0]\nvc atoz = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x','y', 'z'};\nvc AtoZ = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X','Y', 'Z'};\n//右、上が正\nconstexpr ll h4[] = {1, -1, 0, 0};\nconstexpr ll w4[] = {0, 0, -1, 1};\nconstexpr ll h8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconstexpr ll w8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n    int mei_inc(int h, int w, int H, int W, int i) {while (++i < 4) { if (inside(h + h4[i], w + w4[i], H, W))return i; }return i;}\n#define mei(nh, nw, h, w) for (int i = mei_inc(h, w, H, W, -1), nh = i<4? h + h4[i] : 0, nw = i<4? w + w4[i] : 0; i < 4; i=mei_inc(h,w,H,W,i), nh = h+h4[i], nw = w+w4[i])\n\n//グラフ内で #undef getid\n//#define getidとしているため、ここを書き直したらgraphも書き直す\n#define getid_2(h, w) (h * W + w)\n#define getid_1(p) (p.first * W + p.second)\n#define getid(...) over2(__VA_ARGS__, getid_2, getid_1) (__VA_ARGS__)\n#define getp(id) mp(id / W, id % W)\n//#define set_shuffle() std::random_device seed_gen;std::mt19937 engine(seed_gen())\n//#define shuffle(a) std::shuffle((a).begin(), (a).end(), engine);\n//1980 開始からtime ms経っていたらtrue\n#ifdef _DEBUG\nbool timeup(int time){\n    static bool never = true;\n    if(never)message += \"may timeup, because slow\";\n    never = false;\n\n    auto end_time = system_clock::now();\n    auto part = duration_cast<milliseconds>(end_time - start_time);\n    auto lim = milliseconds(time);\n    return part >= lim;\n}\n#else\nbool timeup(int time) {\n    auto end_time = system_clock::now();\n    auto part = duration_cast<milliseconds>(end_time - start_time);\n    auto lim = milliseconds(time);\n    return part >= lim;\n}\n\n#endif\nvoid set_time() { past_time = system_clock::now(); }\n//MS型(millisecqnds)で返る\n//set_timeをしてからの時間\nauto calc_time_milli() {    auto now = system_clock::now();    auto part = duration_cast<milliseconds>(now - past_time);    return part;}\nauto calc_time_micro() {    auto now = system_clock::now();    auto part = duration_cast<microseconds>(now - past_time);    return part;}\nauto calc_time_nano() {    auto now = system_clock::now();    auto part = duration_cast<nanoseconds>(now - past_time);    return part;}\nbool calc_time(int zikan) { return calc_time_micro() >= microseconds(zikan); }\nusing MS=std::chrono::microseconds;\nint div(microseconds a, microseconds b) { return a / b; }\nint div(nanoseconds a, nanoseconds b) {    if (b < nanoseconds(1)) { return a / nanoseconds(1); }    int v = a / b;    return v;}\n//set_time();\n//rep(i,lim)shori\n\ntemplate<class F> dou mgrd_time(dou ok, dou ng, F f,int time = 1980) {\n    bool han = true;\n    if (ok < ng)\n        while(1) {\n            dou mid = (ok + ng) /2;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            deb(mid,han);\n            if(timeup(time)){\n                break;\n            }\n        }\n    else\n        while(1) {\n            dou mid = (ok + ng) /2;\n            if (f(mid))ok = mid, han = true; else ng = mid, han = false;\n            deb(mid,han);\n            if(timeup(time)){\n                break;\n            }\n        }\n    return ok;\n}\n//lim*=time_nanbai();\n//rep(i,lim)shoriと使う\n//全体でmilliかかっていいときにlimを何倍してもう一回できるかを返す\nint time_nanbai(int milli) {\n    auto dec = duration_cast<nanoseconds>(past_time - start_time);\n    auto part = calc_time_nano();\n    auto can_time = nanoseconds(milli * 1000 * 1000);\n    can_time -= part;\n    can_time -= dec;\n    return div(can_time, part);\n}\nvb bit_bool(int v, int len) {    assert(bit(len) > v);    vb ret(len);    rep(i, len) { ret[i] = bget(v, i); }    return ret;}\nvi &range(int l, int r) {static vi ret;ret.resize(r - l);rep(v, l, r) {ret[v - l] = v;}return ret;}\nvi &range(int r) {return range(0, r);}\n\n\n#define rge range\n//† ←template終了\n/*@formatter:on*/\n//vectorで取れる要素数\n//bool=> 1e9 * 8.32\n//int => 1e8 * 2.6\n//ll  => 1e8 * 1.3\n//3次元以上取るとメモリがヤバい\n//static配列を使う\n#define V vector\nvvc (ba);\nll N, M, H, W;\nvi A, B, C;\n\n//9:43\nvoid solve() {\n    str S;\n    in(S);\n    N = sz(S);\n    din(K);\n    //[)\n    //l, r, len := 変更回数\n    vni(dp, N + 1, N + 1, N + 1);\n    fill(dp, inf);\n    rep(i, N) {\n        dp[i][i][0] = 0;\n        dp[i][i + 1][1] = 0;\n    }\n    int ma = 1;\n    deb(dp);\n    //長さと変更した数\n    rep(h, 2, N + 1) {\n        rep(l, N) {\n            rep(len, N + 1) {\n                int r = l + h;\n                if (r > N)break;\n                deb(l, r, len);\n                chmi(dp[l][r][len], dp[l][r - 1][len]);\n                chmi(dp[l][r][len], dp[l + 1][r][len]);\n                if (len >= 2) {\n                    int v = dp[l + 1][r - 1][len - 2];\n                    deb(v);\n\n                    chmi(dp[l][r][len], v + (S[l] != S[r - 1]));\n                    deb(dp[l][r][len]);\n                }\n            }\n        }\n    }\n    repv(l, r, len, dp) {\n        if(dp[l][r][len] <= K){\n            chma(ma, len);\n        }\n    }\n    deb(dp);\n    out(ma);\n\n}\n\nauto my(ll n, vi &a) {\n    return 0;\n}\n\nauto sister(ll n, vi &a) {\n    ll ret = 0;\n    return ret;\n}\n\nsigned main() {\n    solve();\n\n#define arg n,a\n#ifdef _DEBUG\n    bool bad = 0;\n    for (ll i = 0, ok = 1; i < k5 && ok; ++i) {\n        ll n = rand(1, 8);\n        vi a = ranv(n, 1, 10);\n        auto myres = my(arg);\n        auto res = sister(arg);\n        ok = myres == res;\n        if (!ok) {\n            out(arg);\n            cerr << \"AC : \" << res << endl;\n            cerr << \"MY  : \" << myres << endl;\n            bad = 1;\n\n\n            break;\n        }\n    }\n    if (!bad) {\n//        cout << \"完璧 : solveを書き直そう\" << endl;\n//        cout << \"     : そして、solve()を呼び出すのだ\" << endl;\n//        cout << \"     : cin>>n; na(a,n);も忘れるな\" << endl;\n    }\n    if (was_deb && sz(res_mes)) {\n        cerr << \"result = \" << endl << res_mes << endl;\n    }\n    if (sz(message)) {\n        cerr << \"****************************\" << endl;\n        cerr << message << endl;\n        cerr << \"****************************\" << endl;\n    }\n#endif\n    return 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(),vec.end()\n#define mp make_pair\nusing namespace std;\nusing ll=long long;\nusing P=pair<ll,ll>;\nconst ll INF=1LL<<30;\nconst ll LINF=1LL<<60;\nconst double eps=1e-5;\nconst ll MOD=1000000007LL;\ntemplate<typename T>void chmin(T &a,T b){a=min(a,b);};\ntemplate<typename T>void chmax(T &a,T b){a=max(a,b);};\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint dp[310][310][310];\nint main(){\n\tstring s;cin>>s;\n\tint K;cin>>K;\n\tint n=s.length();\n\tfor(int i=0;i<n;i++){\n\t\tdp[i][i+1][0]=1;\n\t}\n\tfor(int l=2;l<=n;l++){\n\t\tfor(int i=0;i<=n-l;i++){\n\t\t\tint j=i+l;\n\t\t\tfor(int k=0;k<=K;k++){\n\t\t\t\tchmax(dp[i][j][k],dp[i+1][j][k]);\n\t\t\t\tchmax(dp[i][j][k],dp[i][j-1][k]);\n\t\t\t\tif(s[i]==s[j-1]){\n\t\t\t\t\tchmax(dp[i][j][k],dp[i+1][j-1][k]+2);\n\t\t\t\t}else{\n\t\t\t\t\tif(k)chmax(dp[i][j][k],dp[i+1][j-1][k-1]+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int k=0;k<=K;k++){\n\t\tchmax(ans,dp[0][n][k]);\n\t}\n\tcout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <random>\n#include <cassert>\n#include <cstring>\n#include <chrono>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstring s;\nint k;\n\nint ans[300][300][301];\n\nint Solve(int l, int r, int k) {\n  if (l > r) return 0;\n  if (l == r) return 1;\n  if (k < 0) return -1000;\n  int& result = ans[l][r][k];\n  if (result != -1) return result;\n\n  result = 0;\n\n  result = max(result, Solve(l + 1, r, k));\n  result = max(result, Solve(l, r - 1, k));\n  result = max(result, 2 + Solve(l + 1, r - 1, k - (s[l] == s[r] ? 0 : 1)));\n\n  return result;\n}\n\nint main()\n{\n  cin >> s >> k;\n\n  memset(ans, -1, sizeof(ans));\n  cout << Solve(0, s.size() - 1, k) << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=305;\nstring s;\nint k,dp[N][N][N],ANS;\nint main() {\n\tios::sync_with_stdio(false);\n\t\n\tcin>>s;\n\tcin>>k;\n\t\n\tfor (int len=0; len<s.size(); len++)\n\t\tfor (int l=0; l+len<s.size(); l++) \n\t\t\tfor (int x=0; x<=min(k,len); x++) {\n\t\t\t\tint r=l+len;\n\t\t\t\tif (l==r) dp[l][r][x]=1;\n\t\t\t\tif (l<r) dp[l][r][x]=max(dp[l][r][x],dp[l][r-1][x]);\n\t\t\t\tif (l<r) dp[l][r][x]=max(dp[l][r][x],dp[l+1][r][x]);\n\t\t\t\t\n\t\t\t\tif (l+1==r && s[l]!=s[r] && x) dp[l][r][x]=dp[l][r-1][x-1]+1;\n\t\t\t\t\t\telse \n\t\t\t\tif (l+1==r && s[l]==s[r] && !x) dp[l][r][x]=2;\n\t\t\t\t\n\t\t\t\tif (r && r-l>1 && s[l]!=s[r] && x) dp[l][r][x]=max(dp[l][r][x],dp[l+1][r-1][x-1]+2);\n\t\t\t\t\telse\n\t\t\t\tif (r && r-l>1 && s[l]==s[r]) dp[l][r][x]=max(dp[l][r][x],dp[l+1][r-1][x]+2);\n\t\t\t\t\n\t\t\t\tANS=max(ANS,dp[l][r][x]);\t\n\t\t\t}\n\t\n\tcout<<ANS<<endl;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint dp[300][300][301];\n\nconst int INF = 1e+5;\n\nint main(){\n    string S;\n    int K;\n    cin >> S;\n    cin >> K;\n    int N = S.size();\n    for(int i = 0; i < N-1; i++){\n        if(S[i] == S[i+1]) dp[i][i+1][2] = 0;\n        else dp[i][i+1][2] = 1;\n    }\n    for(int i = 0; i < N; i++){\n        for(int j = i+1; j < N; j++){\n            dp[i][j][0] = 0;\n            dp[i][j][1] = 0;\n        }\n    }\n    for(int k = 2; k <= N; k++){\n        for(int i = 2; i < N; i++){\n            for(int j = 0; i+j < N; j++){\n                if(i+1 < k) continue;\n                if(S[j] == S[j+i]) dp[j][j+i][k] = dp[j+1][j+i-1][k-2];\n                else dp[j][j+i][k] = dp[j+1][j+i-1][k-2]+1;\n                if(k <= i)dp[j][j+i][k] = min(min(dp[j+1][j+i][k], dp[j][j+i-1][k]), dp[j][j+i][k]);\n                //cout << j << ' ' << j+i << ' ' << k << ' ' << dp[j][j+i][k] << endl;\n            }\n        }\n    }\n    int ans = 0;\n    for(int k = 0; k <= N; k++){\n        //cout << dp[0][N-1][k] << endl;\n        if(dp[0][N-1][k] <= K) ans = k;\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nll MOD = 1e9+7;\nint main()\n{\n    string s;\n    int k;\n    cin >> s >> k;\n    int n = s.size();\n    int dp[n+1][n+1][k+1];\n    for(int i = 0; i <= n; i++)\n    {\n      for(int j = 0; j <= n; j++)\n      {\n        for(int x = 0; x <= k; x++) dp[i][j][x] = 0;\n      }\n    }\n  \n    for(int i = 0; i < n; i++)\n    {\n        dp[i][i][k] = 1;\n        if(i+1 < n && s[i] == s[i+1]) dp[i][i+1][k] = 2;\n        else dp[i][i+1][k] = 1;\n    }\n\n    for(int i = 0; i < n; i++)\n    {\n        for(int l = 0; l+i < n; l++)\n        {\n            int r = l+i;\n            for(int x = 0; x <= k; x++)\n            {\n                if(l > 0) dp[l-1][r][x] = max(dp[l-1][r][x], dp[l][r][x]);\n                if(r+1 < n) dp[l][r+1][x] = max(dp[l][r+1][x], dp[l][r][x]);\n                if(l > 0 && r+1 < n)\n                {\n                    if(s[l-1] == s[r+1]) dp[l-1][r+1][x] = max(dp[l-1][r+1][x], dp[l][r][x] + 2);\n                    if(x) dp[l-1][r+1][x-1] = max(dp[l-1][r+1][x-1], dp[l][r][x] + 2);\n                }\n            }\n        }\n    }\n    cout << dp[0][n-1][0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cassert>\ntypedef long long int ll;\nusing namespace std;\n\ntemplate <class... Args>\nstring dbgFormat(const char* fmt, Args... args) {\n  size_t len = snprintf(nullptr, 0, fmt, args...);\n  char buf[len + 1];\n  snprintf(buf, len + 1, fmt, args...);\n  return string(buf);\n}\n\ntemplate <class Head>\nvoid dbgLog(Head&& head) {\n  cerr << head << endl;\n}\n\ntemplate <class Head, class... Tail>\nvoid dbgLog(Head&& head, Tail&&... tail)\n{\n  cerr << head << \" \";\n  dbgLog(forward<Tail>(tail)...);\n}\n\n#if DEBUG\n  #define DLOG(...)        dbgLog(__VA_ARGS__)\n  #define DFMT(...)        cerr << dbgFormat(__VA_ARGS__) << endl\n  #define DCALL(func, ...) func(__VA_ARGS__)\n#else\n  #define DLOG(...)\n  #define DFMT(...)\n  #define DCALL(func, ...)\n#endif\n\n// operator<< definitions for some classes\n\ntemplate <typename T1, typename T2>\nostream& operator<< (ostream& os, const pair<T1,T2>& p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\n\ntemplate <typename T>\nostream& operator<< (ostream& os, const vector<T>& v) {\n  os << '[';\n  for (auto it = v.begin(); it != v.end(); it++) {\n    if (it != v.begin()) os << \", \";\n    os << *it;\n  }\n  os << ']';\n\n  return os;\n}\n\ntemplate <typename T, typename T2, typename T3>\nostream& operator<< (ostream& os, const priority_queue<T, T2, T3>& orig) {\n  priority_queue<T, T2, T3> pq(orig);\n  bool first = true;\n  os << '[';\n  while (!pq.empty()) {\n    T x = pq.top(); pq.pop();\n    if (!first) os << \", \";\n    os << x;\n    first = false;\n  }\n  return os << ']';\n}\n\ntemplate<typename F>\nclass FixPoint : private F {\npublic:\n  explicit constexpr FixPoint(F&& f) noexcept : F(forward<F>(f)) {}\n\n  template<typename... Args>\n  constexpr decltype(auto) operator()(Args&&... args) const {\n    return F::operator()(*this, forward<Args>(args)...);\n  }\n};\n\ntemplate<typename F>\nstatic inline constexpr decltype(auto) fix(F&& f) noexcept {\n  return FixPoint<F>{forward<F>(f)};\n}\n\nint main(int argc, char *argv[]) {\n  // C-style stdio functions should not be used.\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << setprecision(20);\n\n  string S; cin >> S;\n  int K; cin >> K;\n\n  int N = S.size();\n  vector<vector<vector<int>>>\n    dp(N+2, vector<vector<int>>(N+2, vector<int>(K+1, -1)));\n  for (int j = 0; j < N+1; j++) {\n    for (int k = 0; k < K+1; k++) {\n      dp.at(0).at(j).at(k) = dp.at(j).at(N+1).at(k) = 0;\n    }\n  }\n  auto f = fix([&](auto recF, int i, int j, int k) -> int {\n      int& ref = dp.at(i).at(j).at(k);\n      if (ref < 0) {\n\tif (S.at(i-1) == S.at(j-1)) {\n\t  ref = 1 + recF(i-1, j+1, k);\n\t}else {\n\t  int t = max(recF(i-1, j, k), recF(i, j+1, k));\n\t  if (k > 0) ref = max(t, 1 + recF(i-1, j+1, k-1));\n\t  else       ref = t;\n\t}\n\tDLOG(\"f: \", i, j, k, \" -> \", ref);\n      }\n      return ref;\n    });\n  int ans = 0;\n  for (int i = 1; i <= N; i++) ans = max(ans, 2 * f(i, i, K) - 1);\n  for (int i = 1; i <  N; i++) ans = max(ans, 2 * f(i, i+1, K));\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i, a, b) for (int i = (a); i < (b); ++i)\n#define F2(i, a, b) for (int i = (a); i <= (b); ++i)\n#define dF(i, a, b) for (int i = (a); i > (b); --i)\n#define dF2(i, a, b) for (int i = (a); i >= (b); --i)\n#define maxn 310\nusing namespace std;\ntypedef long long LL;\nchar ss[maxn];\nint dp[maxn][maxn][maxn];\nint main() {\n    int k;\n    scanf(\"%s%d\", ss, &k);\n    int n = strlen(ss), ans=0;\n    dF2(l, n-1, 0) {\n        F(r, l, n) {\n            F2(x, 0, k) {\n                if (ss[l]==ss[r]) dp[l][r][x] = dp[l+1][r-1][x]+(l==r?1:2);\n                else {\n                    dp[l][r][x] = max(dp[l+1][r][x], dp[l][r-1][x]);\n                    if (x) dp[l][r][x] = max(dp[l][r][x], dp[l+1][r-1][x-1]+2);\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\", dp[0][n-1][k]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n \nconst int MAXN = 310;\n \nint f[MAXN][MAXN][MAXN];\n \nint main() {\n#ifdef BZ\n    freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20); cout.tie(nullptr); cin.tie(nullptr);\n    string s;\n    int k;\n    cin >> s >> k;\n    string t(s.rbegin(), s.rend());\n    int n = s.length();\n    s += '#';\n    t += '#';\n \n    for (int i = 0; i <= n; ++i) {\n        for (int j = 0; j <= n; ++j) {\n            for (int l = 0; l <= k; ++l) {\n                int c = f[i][j][l];\n                f[i + 1][j][l] = max(f[i + 1][j][l], c);\n                f[i][j + 1][l] = max(f[i][j + 1][l], c);\n                int& nv = f[i + 1][j + 1][l + (s[i] != t[j])];\n                nv = max(nv, c + 1);\n            }\n        }\n    }\n \n    int ans = 0;\n \n    for (int i = 0; i < n; ++i) {\n        ans = max(ans, f[i][n - 1 - i][k] * 2 + 1);\n    }\n \n    for (int i = 0; i <= n; ++i) {\n        ans = max(ans, f[i][n - i][k] * 2);\n    }\n \n    cout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef HELTHAZAR\n#define dout if (true) cout\n#else\n#define dout if (false) cout\n#endif\n\n#define rep(i, from, to) for (ll i = from; i < ll(to); ++i)\n#define trav(a, x) for (auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (ll)(x).size()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef pair<ll, ll> pi;\ntypedef vector<ll> vi;\ntypedef vector<vector<ll> > vvi;\n\nconst int MAXN = 301;\n\nint used[MAXN][MAXN][MAXN];\nint dp[MAXN][MAXN][MAXN];\nstring s;\n\nint calcdp(int i, int j, int n, int k) {\n\tif (i > j)\n\t\treturn 0;\n\tif (i == j)\n\t\treturn 1;\n\tif (used[i][j][k])\n\t\treturn dp[i][j][k];\n\tint maxdp = max(calcdp(i + 1, j, n, k), calcdp(i, j - 1, n, k));\n\tif (s[i] == s[j])\n\t\tmaxdp = max(maxdp, calcdp(i + 1, j - 1, n, k) + 2);\n\telse if (k > 0)\n\t\tmaxdp = max(maxdp, calcdp(i + 1, j - 1, n, k - 1) + 2);\n\tused[i][j][k] = 1;\n\tdp[i][j][k] = maxdp;\n\treturn maxdp;\n}\n\nvoid solve() {\n\tcin >> s;\n\tint k;\n\tcin >> k;\n\tint n = sz(s);\n\tcout << calcdp(0, n - 1, n, k);\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nint m;\nusing namespace std;\nconst int N = 302;\nstring s;\nint f[N][N][N];\nint a[N];\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> s;\n    cin >> m;\n    for (int i = 0; i < s.size(); i++) a[i + 1] = s[i] - 'a';\n    int n = s.size(); a[0] = -1; a[n + 1] = -1;\n    f[1][n][0] = 0;\n    for (int i = 1; i <= n; i++) {\n        for (int j = n; j >= i; j--) {\n            for (int k = 0; k <= m; k++) {\n                f[i + 1][j][k] = max(f[i + 1][j][k], f[i][j][k]);\n                f[i][j - 1][k] = max(f[i][j - 1][k], f[i][j][k]);\n                if (a[i] != a[j]) {\n                    f[i + 1][j - 1][k + 1] = max(f[i + 1][j - 1][k + 1], f[i][j][k] + 2 - (i == j));\n                }\n                else {\n                    f[i + 1][j - 1][k] = max(f[i + 1][j - 1][k], f[i][j][k] + 2 - (i == j));\n                }\n            }\n        }\n    }\n    int mx = 0;\n    for (int i = 0; i <= n + 1; i++) {\n        for (int j = 0; j <= n; j++) {\n            for (int k = 0; k <= m; k++) {\n                mx = max(mx, f[i][j][k]);\n            }\n        }\n    }\n    cout << mx << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define double long double\n#define ll long long\n#define P pair<int,int>\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define pb push_back\n#define eb emplace_back\ntemplate<class T>void chmax(T &a,T b){if(a<b)a=b;}\ntemplate<class T>void chmin(T &a,T b){if(a>b)a=b;}\nconstexpr int INF=1000000000000000000;\nconstexpr int mod=1000000007;\nconstexpr double eps=1e-8;\nconst double pi=acos(-1);\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nint Random(int mi,int ma){\n    random_device rnd;\n    mt19937 mt(rnd());//32bit\n    //[mi,ma]\n    uniform_int_distribution<int>engine(mi,ma);\n    return engine(mt);\n}\nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n}\nint lcm(int a,int b){\n    return a/gcd(a,b)*b;\n}\nbool prime(int a){\n    if(a==1)return false;\n    for(int i=2;i*i<=a;i++){\n        if(a%i==0)return false;\n    }\n    return true;\n}\nint modpow(int a,int b){\n    if(b==0)return 1;\n    if(b%2)return modpow(a,b-1)*a%mod;\n    int memo=modpow(a,b/2);\n    return memo*memo%mod;\n}\nvector<int>kaijo,invkaijo;\nvoid init_fact(int n){\n    kaijo.resize(n+1);\n    invkaijo.resize(n+1);\n    kaijo[0]=1;\n    for(int i=1;i<=n;i++){\n        kaijo[i]=kaijo[i-1]*i;\n        kaijo[i]%=mod;\n    }\n    rep(i,n+1)invkaijo[i]=modpow(kaijo[i],mod-2);\n}\nint comb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return kaijo[a]*modpow(kaijo[a-b],mod-2)%mod*modpow(kaijo[b],mod-2)%mod;\n}\nint inv(int x){\n    x=modpow(x,mod-2);\n    return x;\n}\nstring s;\nint n,k,dp[310][310][310];\nsigned main(){\n  //Save Submission\n    cin.tie(0);ios::sync_with_stdio(false);\n    cin>>s>>k;\n    n=s.size();\n    rep(i,n){\n        rep(x,k+1){\n            dp[i][i+1][x]=1;\n        }\n    }\n    for(int wid=2;wid<=n;wid++){\n        rep(l,n){\n            int r=l+wid;\n            if(r>n)break;\n            rep(x,k+1){\n                if(x)dp[l][r][x]=dp[l][r][x-1];\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\n\n#include \"boost/multiprecision/cpp_int.hpp\"\n#include \"boost/multiprecision/cpp_dec_float.hpp\"\nnamespace mp = boost::multiprecision;\ntypedef mp::cpp_int LL;\ntypedef mp::number<mp::cpp_dec_float<1024>> DD;// 仮数部が1024ビットの浮動小数点数型(TLEしたら小さくする)\n\n \ntypedef long double dd;\n#define i_7 (ll)(1E9+7)\n//#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\ntypedef pair<ll,ll> l_l;\ntypedef pair<dd,dd> d_d;\nll inf=(ll)1E16;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define rrep(i,r,l) for(ll i=r;i>=l;i--)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\ndd EPS=1E-9;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define fi first\n#define se second\n#define endl \"\\n\"  //インタラクティブで消す！！！！！！！！！！！！！！！！！！！！！\n#define SORT(v) sort(v.begin(),v.end())\n#define ERASE(v) v.erase(unique(v.begin(),v.end()),v.end())\n#define POSL(v,x) (lower_bound(v.begin(),v.end(),x)-v.begin())\n#define POSU(v,x) (upper_bound(v.begin(),v.end(),x)-v.begin())\ntemplate<class T,class S>\ninline bool chmax(T &a, S b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T,class S>\ninline bool chmin(T &a, S b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nvoid mod_print(ll k){\n    ll P=1000;\n    rep(y,1,P){\n        ll x=mod(y*k);\n        if(x+P>=i_7){\n            x-=i_7;\n        }\n        if(abs(x)<=P){\n            //cout<<x<<\"/\"<<y;\n            cout<<setprecision(5)<<(dd)x/(dd)y;\n            return;\n        }\n    }\n    cout<<\"nun\"<<endl;\n}\n#define all(c) c.begin(),c.end()\n//////////////////////////\n\n\nint main(){fastio\n    string s;ll k;cin>>s>>k;\n    ll n=s.size();\n    ll dp[n][n][k+1];memset(dp,0,sizeof(dp));\n    rep(i,0,n-1)dp[i][i][0]=1;\n    rep(i,0,n-2){\n        if(s[i]==s[i+1])dp[i][i+1][0]=2;\n        else{\n            if(k!=0)dp[i][i+1][1]=2;\n            dp[i][i+1][0]=1;\n        }\n    }\n    rep(len,2,n){\n        rep(l,0,n-1){\n            ll r=l+len-1;\n            if(r>=n)continue;\n            rep(t,0,k){\n                chmax(dp[l][r][t],dp[l][r-1][t]);\n                chmax(dp[l][r][t],dp[l+1][r][t]);\n                if(s[l]==s[r]){\n                    chmax(dp[l][r][t],dp[l+1][r-1][t]+2);\n                }else{\n                    if(t-1>=0)chmax(dp[l][r][t],dp[l+1][r-1][t-1]+2);\n                }\n            }\n        }\n    }\n    /*\n    rep(t,0,k){\n        rep(i,0,n-1){\n            rep(j,0,n-1){\n                cout<<dp[i][j][t]<<\" \";\n            }cout<<endl;\n        }cout<<endl;\n    }\n    */\n    ll ans=0;\n    rep(i,0,n-1)rep(j,i,n-1)rep(t,0,k)chmax(ans,dp[i][j][t]);\n    cout<<ans<<endl;\n    \n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nstring S, rS;\nint dp[333][333];\n\nint dfs(int p1, int p2) {\n    if (p1 == 0 || p2 == 0) return 0;\n    if (~dp[p1][p2]) return dp[p1][p2];\n    if (S[p1 - 1] == rS[p2 - 1]) return dp[p1][p2] = dfs(p1 - 1, p2 - 1) + 1;\n    else {\n        return dp[p1][p2] = max(dfs(p1 - 1, p2), dfs(p1, p2 - 1));\n    }\n}\n\nint calc() {\n    memset(dp, -1, sizeof(dp));\n    return dfs(S.size(), S.size());\n}\n\nint main(void) {\n    int K;\n    cin >> S >> K;\n    rS = S;\n    REVERSE(rS);\n    int cnt = 0;\n    int ans = calc();\n    REP(i, (int)S.size()) {\n        char c = S[i];\n        bool change = false;\n        REP(j, 26) {\n            S[i] = rS[S.size() - 1 - i] = j + 'a';\n            if (chmax(ans, calc())) {\n                change = true;\n                break;\n            }\n        }\n        if (change) {\n            cnt++;\n            if (cnt == K) break;\n        } else {\n            S[i] = rS[S.size() - 1 - i] = c;\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/************************************************\n * Au: Hany01\n * Date: Feb 25th, 2018\n * Prob: AGC021 D Reversed LCS\n * Email: hany01@foxmail.com\n************************************************/\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define rep(i, j) for (register int i = 0, i##_end_ = (j); i < i##_end_; ++ i)\n#define For(i, j, k) for (register int i = (j), i##_end_ = (k); i <= i##_end_; ++ i)\n#define Fordown(i, j, k) for (register int i = (j), i##_end_ = (k); i >= i##_end_; -- i)\n#define Set(a, b) memset(a, b, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define fir first\n#define sec second\n#define pb(a) push_back(a)\n#define mp(a, b) make_pair(a, b)\n#define ALL(a) (a).begin(), (a).end()\n#define SZ(a) ((int)(a).size())\n#define INF (0x3f3f3f3f)\n#define INF1 (2139062143)\n#define Mod (1000000007)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define y1 wozenmezhemecaia\n\ntemplate <typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\n\ninline int read()\n{\n\tregister int _, __; register char c_;\n    for (_ = 0, __ = 1, c_ = getchar(); c_ < '0' || c_ > '9'; c_ = getchar()) if (c_ == '-') __ = -1;\n    for ( ; c_ >= '0' && c_ <= '9'; c_ = getchar()) _ = (_ << 1) + (_ << 3) + (c_ ^ 48);\n    return _ * __;\n}\n\ninline void File()\n{\n    freopen(\"agc021d.in\", \"r\", stdin);\n    freopen(\"agc021d.out\", \"w\", stdout);\n}\n\nconst int maxn = 310;\n\nchar s[maxn];\nint n, k, f[maxn][maxn][maxn];\n\nint main()\n{\n    File();\n\tscanf(\"%s\", s + 1), n = strlen(s + 1), k = read();\n\tFor(len, 2, n)\n\t\tFor(st, 1, n - len + 1) {\n\t\t\tregister int ed = st + len - 1;\n\t\t\tFor(i, 0, k) {\n\t\t\t\tif (st == ed) f[st][ed][i] = 1;\n\t\t\t\telse if (st + 1 == ed) f[st][ed][i] = i || s[st] == s[ed] ? 2 : 1;\n\t\t\t\telse {\n\t\t\t\t\tf[st][ed][i] = max(f[st + 1][ed][i], f[st][ed - 1][i]);\n\t\t\t\t\tif (s[st] == s[ed]) chkmax(f[st][ed][i], f[st + 1][ed - 1][i] + 2);\n\t\t\t\t\tif (i) chkmax(f[st][ed][i], f[st + 1][ed - 1][i - 1] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\", f[1][n][k]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\n#define PB push_back\n#define MP make_pair\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\n\nconst int MOD = 1e9+7;\nconst int INF = 1e9;\nconst int MAX_N = 300;\n\nint dp[MAX_N+1][MAX_N+1];\n\nint main() {\n  string s, t, res = \"\";\n  int N, K;\n  cin >> s >> K;\n  N = s.length();\n  t = s;\n  reverse(t.begin(), t.end());\n  // cout << s << endl;\n  // cout << t << endl;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      if (s[i]==t[j]) {\n        dp[i+1][j+1] = dp[i][j]+1;\n      } else {\n        dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j]);\n      }\n    }\n  }\n\n  int ans = 0;\n  for (int k = 0; k < 2; k++) {\n    int xy[2] = {N, N}, sm = 0, K_sub = K;\n    vi nums;\n    string tmp = \"\";\n    while (xy[k]!=0 && xy[1-k]!=0) {\n      if (dp[xy[k]-1][xy[1-k]] == dp[xy[k]][xy[1-k]]) {\n        xy[k]--;\n        nums.PB(xy[k]);\n      } else if (dp[xy[k]][xy[1-k]-1] == dp[xy[k]][xy[1-k]]) {\n        xy[1-k]--;\n      } else {\n        // cout << xy[k] << endl;\n        xy[k]--; xy[1-k]--;\n        tmp.PB(s[xy[k]]);\n      }\n    }\n    for (int i = 0; i < nums.size(); i++) {\n      for (int j = 0; j < nums.size(); j++) {\n        if (nums[i] == N-nums[j]-1 && K_sub > 0) {\n          K_sub--;\n          sm += 2;\n        }\n      }\n    }\n    ans = max(ans, sm);\n  }\n  ans += dp[N][N];\n  // reverse(tmp.begin(), tmp.end());\n  // cout << tmp << endl;\n\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nchar str[606];\nchar str2[606];\nint dp[606][606];\nint main(){\n    memset(dp,0,sizeof(dp));\n    int k;\n    scanf(\"%s\",str);\n    scanf(\"%d\",&k);\n    int n = strlen(str);\n    for(int i=0;i<n;i++){\n        str2[i*2+1] = str[i];\n        str2[i*2+2] = '*';\n    }\n    n = n*2-1;\n    int ans = 0;\n    for(int mid = 1; mid<=n/2+1;mid++){\n        for(int i=0;i<=500;i++)for(int j=0;j<=500;j++)dp[i][j]=0;\n        for(int i=1;i<=n-mid;i++){\n            for(int j=0;j<=min(i,k);j++){\n                if(str2[mid-dp[i-1][j]-1]==str2[mid+i]){\n                    dp[i][j] = dp[i-1][j]+1;\n                }\n                else{\n                    dp[i][j] = dp[i-1][j];\n                }\n                if(j>0)dp[i][j] = max(dp[i][j],dp[i-1][j-1]+1);\n            }\n        }\n        for(int i=0;i<=k;i++){\n            if(dp[n-mid][i]==mid-1){\n                ans = max(ans,mid);\n            }\n        }\n    }\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\ntypedef long long ll;\ninline void Fail(){printf(\"0\");exit(0);}\n\nconst int maxn=305;\nint n,lim,ans;\nchar c[maxn];\nstring s;\nint dp[maxn][maxn][maxn];\n\nint main(){\n\tscanf(\"%s%d\",c,&lim);\n\tlim*=2; \n\ts=c;n=s.size();\n\trep(i,n)rep(j,n)rep(k,lim+1){\n\t\tif(s[i]==s[n-j-1])dp[i][j][k]=(i>=1&&j>=1?dp[i-1][j-1][k]:0)+1;\n\t\tif(i>=1)dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k]);\n\t\tif(j>=1)dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k]);\n\t\tif(s[i]!=s[n-j-1]){\n\t\t\tint tp=((i==n/2&&(n&1))?2:1); \n\t\t\tif(k>=tp)dp[i][j][k]=max((i>=1&&j>=1?dp[i-1][j-1][k-tp]:0)+1,dp[i][j][k]);\n\t\t}\n\t\tans=max(ans,dp[i][j][k]);\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n\n/*\nInput:\nab\n0\n-----------------\nOutput:\n*/"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define f(i,a,b) for (int i = a; i < b; i++)\n#define fr(i,a,b) for (int i = b-1; i >= a; i--)\n#define Max(a,b) a=max(a,b)\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tclock_t start = clock();\n#endif\n\n\tstring s; cin >> s;\n\tint n = s.length();\n\tint K; cin >> K;\n\tint dp[n+1][n+1][K+1];\n\tf(i,0,n+1) f(j,0,n+1) f(k,0,K+1)\n\t\tdp[i][j][k] = 0;\n\tint ans = 0;\n\tf(i,0,n) fr(j,i,n) f(k,0,K+1) {\n\t\tif (s[i] == s[j]) {\n\t\t\tif (j) Max(dp[i+1][j-1][k],dp[i][j][k]+1+(i!=j));\t\n\t\t\telse Max(ans,dp[i][j][k]+1+(i!=j));\n\t\t} else if (k) {\n\t\t\tif (j) Max(dp[i+1][j-1][k-1],dp[i][j][k]+1+(i!=j));\n\t\t\telse Max(ans,dp[i][j][k]+1+(i!=j));\n\t\t}\n\t\tif (i<n) Max(dp[i+1][j][k], dp[i][j][k]);\n\t\tif (j) Max(dp[i][j-1][k], dp[i][j][k]);\n\t}\n\tf(i,0,n+1) f(j,0,n+1) f(k,0,K+1)\n\t\tMax(ans,dp[i][j][k]);\n\tcout << ans << endl;\n\n#ifdef LOCAL\n\tcout << setprecision(12) << (long double)(clock()-start) / CLOCKS_PER_SEC << endl;\n#endif\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=305;\nstring s;\nint dp[305][305][305],K;\nint dfs(int l,int r,int x)\n{\n    if(r<l)return 0;\n    if(l==r)return 1;\n    if(dp[l][r][x]!=-1)return dp[l][r][x];//记忆化思想，减少搜索次数\n    int t=max(dfs(l+1,r,x),dfs(l,r-1,x));//向左或右扩展一个\n    if(s[l]==s[r])t=max(t,dfs(l+1,r-1,x)+2);//相等，进行扩展\n    if(x)t=max(t,dfs(l+1,r-1,x-1)+2);//改变一个字符，向内扩展\n    return dp[l][r][x]=t;\n}\nint main()\n{\n    cin>>s>>K;\n    memset(dp,-1,sizeof(dp));\n    cout<<dfs(0,s.size()-1,K)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#define _GLIBCXX_DEBUG\n#endif\n#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,s,t) for(ll i = (ll)(s); i < (ll)(t); i++)\n#define rrep(i,s,t) for(ll i = (ll)(s-1);(ll)(t) <= i; i--)\n#define all(x) (x).begin(), (x).end()\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> Pll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\nconstexpr ll INF = numeric_limits<ll>::max()/4;\nconstexpr ll n_max = 2e5+10;\n#define int ll\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\nstring to_string(const string &s) {return '\"' + s + '\"';}\nstring to_string(const char *c) {return to_string((string) c);}\nstring to_string(bool b) {return (b ? \"true\" : \"false\");}\ntemplate <size_t N>\nstring to_string(bitset<N> v){\n    string res = \"\";\n    for(size_t i = 0; i < N; i++) res += static_cast<char>('0' + v[i]);\n    return res;\n}\ntemplate <typename A>\nstring to_string(A v) {\n    bool first = true;\n    string res = \"{\";\n    for(const auto &x : v) {\n        if(!first) res += \", \";\n        first = false;\n        res += to_string(x);\n    }\n    res += \"}\";\n    return res;\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p){return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}\n\nvoid debug_out() {cerr << endl;}\ntemplate<typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << to_string(H);\n    debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate<class T>\nbool chmax(T &a, T b){if(a < b){a = b; return true;} return false;}\ntemplate<class T>\nbool chmin(T &a, T b){if(a > b){a = b; return true;} return false;}\n\nsigned main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    string s;cin >> s;\n    ll k; cin >> k;\n    ll n = s.size();\n    vector dp(n, vector(n+1, vector(k+1, 0LL)));\n\n    auto dfs = [&](auto self, ll l, ll r, ll x){\n        if(dp[l][r][x])return dp[l][r][x];\n        if(r - l == 1){\n            return dp[l][r][x] = 1;\n        }\n        if(r - l == 2){\n            if(x){\n                return dp[l][r][x] = 2;\n            }\n            else{\n                return dp[l][r][x] = (s[l] == s[r-1] ? 2 : 1);\n            }\n        }\n        ll res = 0;\n        chmax(res, self(self, l, r-1, x));\n        chmax(res, self(self, l+1, r, x));\n        if(s[l] == s[r-1]) chmax(res, self(self, l+1, r-1, x) + 2);\n        else{\n            if(x)chmax(res, self(self, l+1, r-1, x-1) + 2);\n        }\n\n        return dp[l][r][x] = res;\n    };\n\n    cout << dfs(dfs, 0, n, k) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\n#define NDEBUG\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\nusing uint = unsigned int;\nusing usize = std::size_t;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return ((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\ntemplate<typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T>\nstd::vector<T> read_vec(const std::size_t size)\n{\n    std::vector<T> v(size);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\ntemplate<typename... Types>\nauto read_vals() { return std::tuple<std::decay_t<Types>...>{read<Types>()...}; }\n#define SHOW(...) static_cast<void>(0)\ntemplate<typename T>\nstd::vector<T> make_v(const std::size_t size, T v) { return std::vector<T>(size, v); }\ntemplate<class... Args>\nauto make_v(const std::size_t size, Args... args) { return std::vector<decltype(make_v(args...))>(size, make_v(args...)); }\nint main()\n{\n    const auto s = read<std::string>();\n    const auto k = read<usize>();\n    const auto n = s.size();\n    auto memo    = make_v(n, n, k + 1, inf_v<usize>);\n    auto dp      = [&](auto&& self, const int a, const int b, const usize c) -> usize {\n        if (a > b or b < 0 or a < 0 or a >= n or b >= n) { return 0; }\n        if (memo[a][b][c] != inf_v<usize>) { return memo[a][b][c]; }\n        if (s[a] == s[b]) { return memo[a][b][c] = self(self, a + 1, b - 1, c) + (a == b ? 1UL : 2UL); }\n        return memo[a][b][c] = std::max({self(self, a + 1, b, c), self(self, a, b - 1, c), (c == k ? 0 : self(self, a + 1, b - 1, c + 1) + 2)});\n    };\n    std::cout << dp(dp, 0, (int)n - 1, 0) << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * File    : D.cpp\n * Author  : Kazune Takahashi\n * Created : 2018-2-24 22:16:49\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>   // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set>\n#include <random> // random_device rd; mt19937 mt(rd());\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\n// const ll M = 1000000007;\n\nint dp[400][400];\n\nint lcs(string s, string t)\n{\n  fill(&dp[0][0], &dp[0][0] + 400 * 400, 0);\n  int N = s.size();\n  int M = t.size();\n  for (auto i = 0; i < N; i++)\n  {\n    for (auto j = 0; j < M; j++)\n    {\n      if (s[i] == t[j])\n      {\n        dp[i + 1][j + 1] = dp[i][j] + 1;\n      }\n      else\n      {\n        dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);\n      }\n    }\n  }\n  return dp[N][M];\n}\n\nstring S;\nint K;\n\nint main()\n{\n  cin >> S >> K;\n  string T = S;\n  reverse(T.begin(), T.end());\n  if (K == 0)\n  {\n    cout << lcs(S, T) << endl;\n  }\n  else\n  {\n    cout << min(lcs(S, T) + 2 * K, (int)S.size()) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define db double\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define pil pair<int,ll>\n#define pll pair<ll,ll>\n#define mat vector<vector<int>>\nconst int inf = 1 << 30;\nconst ll linf = 1e18;\nconst db EPS = 1e-7;\ntemplate<class T> void chmin(T& x, T y){if(x > y) x = y;}\ntemplate<class T> void chmax(T& x, T y){if(x < y) x = y;}\n\nstring S;\nint K, dp[310][310][310];\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin >> S >> K;\n    for(int i = 0; i < S.length(); i++) dp[i][i][0] = 1;\n    for(int i = 0; i + 1 < S.length(); i++) dp[i][i + 1][S[i] != S[i + 1]] = 2;\n    for(int k = 0; k <= K; k++){\n        for(int len = 0; len < S.length(); len++){\n            for(int l = 0; l + len < S.length(); l++){\n                if(l == 0 || l + len - 1 == S.length()) continue;\n                if(S[l - 1] == S[l + len + 1]) chmax(dp[l - 1][l + len + 1][k], dp[l][l + len][k] + 2);\n                else chmax(dp[l - 1][l + len + 1][k + 1], dp[l][l + len][k] + 2);\n                chmax(dp[l - 1][l + len][k], dp[l][l + len][k]);\n                chmax(dp[l][l + len + 1][k], dp[l][l + len][k]);\n            }\n        }\n    }\n    int ans = 0;\n    for(int l = 0; l < S.length(); l++){\n        for(int r = l; r < S.length(); r++){\n            for(int k = 0; k <= K; k++){\n                chmax(ans, dp[l][r][k]);\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define double long double\nusing namespace std;\nconst int N = 301;\n//const int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\nstring s;\nint used[N][N][N];\nint mem[N][N][N];\n\nint dfs(int l,int r,int k){\n  if(l > r) return 0;\n\n  if(used[l][r][k]++) return mem[l][r][k];\n  int res = 0;\n  int f = l < r;\n  if(k) Max(res,1 + f + dfs(l+1,r-1,k-1));\n  if(s[l] == s[r]) Max(res,1 +f +  dfs(l+1,r-1,k));\n\n  Max(res,dfs(l+1,r,k));\n  Max(res,dfs(l,r-1,k));\n  return mem[l][r][k] = res;\n}\n\nsigned main(){\n  int K;\n  cin>>s>>K;\n  int ans = dfs(0,s.size()-1,K);\n  cout<<ans<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "    #include <bits/stdc++.h>\n    using namespace std;\n     \n    using i64=int64_t;\n     \n    #define rep(i,x,y) for(i64 i=i64(x),i##_max_for_repmacro=i64(y); i<i##_max_for_repmacro; ++i)\n    #define debug(x) #x << \"=\" << (x)\n     \n    #ifdef DEBUG\n    #define _GLIBCXX_DEBUG\n    #define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n    #else\n    #define print(x)\n    #endif\n     \n    const int inf=1.01e9;\n    const i64 inf64=4.01e18;\n    const double eps=1e-9;\n     \n    template <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n        os << \"[\";\n        for (const auto &v : vec) {\n            os << v << \",\";\n        }\n        os << \"]\";\n        return os;\n    }\n     \n    template<int D,class point> struct kd_tree{\n        point p;\n        int axis,val;\n        kd_tree<D,point>* left,*right;\n        kd_tree(int axis_=0):left(NULL),right(NULL),axis(axis_){};\n        kd_tree(vector<pair<point,int>> points,int axis_=0):left(NULL),right(NULL),axis(axis_){ assert(points.size()); build(points,0,points.size()); }\n        ~kd_tree(){ delete left; delete right; }\n        kd_tree<D,point>* build(vector<pair<point,int>> &points,int l,int r){\n            int m=(l+r)/2;\n            nth_element(points.begin()+l,points.begin()+m,points.begin()+r,[&](const pair<point,int>& p,const pair<point,int>& q){ return p.first[axis]<q.first[axis]; });\n            p=points[m].first;\n            val=points[m].second;\n            if(l<m){\n                left=new kd_tree<D,point>((axis+1)%D);\n                left->build(points,l,m);\n            }\n            if(m+1<r){\n                right=new kd_tree<D,point>((axis+1)%D);\n                right->build(points,m+1,r);\n            }\n            return this;\n        }\n        //例えば,同じ点が大量にinsertされると右の子ばかり増えてしまう.そのようなときは適当なタイミングで全体をリビルドしたほうがよいかも.\n        kd_tree<D,point>* insert(const point& q){\n            if(q[axis]<p[axis]){\n                if(left==NULL){\n                    left=new kd_tree<D,point>({q},(axis+1)%D);\n                    return left;\n                }else return left->insert(q);\n            }else{\n                if(right==NULL){\n                    right=new kd_tree<D,point>({q},(axis+1)%D);\n                    return right;\n                }else return right->insert(q);\n            }\n        }\n        //未検証.多分遅い(O(n))のでerasedタグを付けて置いて,erasedが一定以上増えたら全体をbuildするようにした方が良いかも.\n        void erase(const point& q){\n            kd_tree<D,point>* tree=nearest_neighbor(q);\n            vector<point> points=tree->collect();\n            points.erase(points.rbegin());\n            delete tree->left;\n            delete tree->right;\n            tree->build(points,0,points.size());\n        }\n        //未検証\n        vector<point> collect()const{\n            vector<point> points;\n            if(left!=NULL){\n                vector<point> left_points=left->collect();\n                points.insert(points.end(),left_points.begin(),left_points.end());\n            }\n            if(right!=NULL){\n                vector<point> right_points=right->collect();\n                points.insert(points.end(),right_points.begin(),right_points.end());\n            }\n            points.push_back(p);\n            return points;\n        };\n        const kd_tree<D,point>* nearest_neighbor(const point& q)const{ //const外した方が良いかも\n            const kd_tree<D,point>* res=this;\n            long double mind=inf64;\n            auto dist=[&](const point& p,const point& q){\n                long double d=0;\n                for(int i=0; i<D; ++i) d+=(p[i]-q[i])*(p[i]-q[i]);\n                return d;\n            };\n            function<void(const kd_tree<D,point>*)> rec=[&](const kd_tree<D,point>* tree){\n                auto d=dist(tree->p,q);\n                if(d<mind){\n                    mind=d;\n                    res=tree;\n                }\n                if(q[tree->axis]<tree->p[tree->axis]){\n                    if(tree->left!=NULL) rec(tree->left);\n                    if(tree->right!=NULL and tree->p[tree->axis]-q[tree->axis]<=mind) rec(tree->right);\n                }else{\n                    if(tree->right!=NULL) rec(tree->right);\n                    if(tree->left!=NULL and q[tree->axis]-tree->p[tree->axis]<=mind) rec(tree->left);\n                }\n            };\n            rec(this);\n            return res;\n        }\n        vector<point> range_search(const point& lb,const point& ub)const{\n            vector<point> res;\n            function<void(const kd_tree<D,point>*)> rec=[&](const kd_tree<D,point>* tree){\n                bool in_range=true;\n                for(int i=0; i<D; ++i) if(tree->p[i]<lb[i] or ub[i]<tree->p[i]){\n                    in_range=false;\n                    break;\n                }\n                if(in_range) res.push_back(tree->p);\n                if(tree->left!=NULL and lb[tree->axis]<=tree->p[tree->axis]) rec(tree->left);\n                if(tree->right!=NULL and ub[tree->axis]>=tree->p[tree->axis]) rec(tree->right);\n            };\n            rec(this);\n            return res;\n        }\n    };\n     \n    const int loop=1600000;\n    const long double pi=acosl(-1),r=1e12;\n    void solve(){\n        fill_n((long double*)mc,loop2+1,2);\n        fill_n((long double*)ms,loop2+1,2);\n     \n        int N;\n        cin >> N;\n     \n        using point=vector<long double>;\n        vector<pair<point,int>> ps(N);\n        rep(i,0,N){\n            ps[i].first.resize(2);\n            ps[i].second=i;\n            cin >> ps[i].first[0] >> ps[i].first[1];\n        }\n     \n        kd_tree<2,point> kt(ps);\n        vector<int> cnt(N);\n        print(r);\n        rep(i,0,loop){\n            long double x=r*cosl(2*pi*i/loop),y=r*sinl(2*pi*i/loop);\n            print(x);\n            print(y);\n            ++cnt[kt.nearest_neighbor({x,y})->val];\n        }\n     \n        rep(i,0,N) cout << (long double)cnt[i]/loop << endl;\n    }\n     \n    int main(){\n        std::cin.tie(0);\n        std::ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        solve();\n        return 0;\n    }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring s, rs;\nint n, k;\nvector<vector<vector<int>>> dp;\n\nint solve();\n\nint main() {\n  cin >> s >> k;\n  n = s.size();\n  rs = s;\n  reverse(rs.begin(), rs.end());\n  cout << solve() << endl;\n  return 0;\n}\n\nint solve() {\n  int res = 0;\n  dp.assign(n + 1, vector(n + 1, vector<int>(k + 1, 0)));\n  for (int i = 1; i <= n; ++i)\n    for (int l = 0; l <= k; ++l) {\n      for (int j = 1; j + i <= n; ++j) {\n        if (s[i - 1] == rs[j - 1])\n          dp[i][j][l] = dp[i - 1][j - 1][l] + 2;\n        else if (l != 0)\n          dp[i][j][l] = dp[i - 1][j - 1][l - 1] + 2;\n        dp[i][j][l] = max(dp[i][j][l], dp[i - 1][j][l]);\n        dp[i][j][l] = max(dp[i][j][l], dp[i][j - 1][l]);\n        res = max(res, dp[i][j][l]);\n      }\n      // same\n      dp[i][n + 1 - i][l] = dp[i][n - i][l] + 1;\n      res = max(res, dp[i][n + 1 - i][l]);\n    }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#define MIN_INT -2147483648\n#define MAX_INT 2147483647\n#define MIN_LONG -9223372036854775808L\n#define MAX_LONG 9223372036854775807L\n#define PI 3.141592653589793238462643383279502884L\n\n#define long long long int\n\nusing std::vector;\nusing std::map;\nusing std::set;\nusing std::string;\nusing std::pair;\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\n// @author: pashka\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\n    string s;\n    cin >> s;\n    int k;\n    cin >> k;\n    int n = s.length();\n\n    int d[n + 1][n + 1][k + 1];\n\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            for (int kk = 0; kk <= k; kk++) {\n                if (i == 0 || j == 0) {\n                    d[i][j][kk] = 0;\n                } else {\n                    if (s[i - 1] == s[n - j]) {\n                        d[i][j][kk] = d[i - 1][j - 1][kk] + 1;\n                    } else {\n                        d[i][j][kk] = std::max(d[i - 1][j][kk], d[i][j - 1][kk]);\n                        if (kk > 0) {\n                            d[i][j][kk] = std::max(d[i][j][kk], d[i - 1][j - 1][kk - 1] + 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    int res = 0;\n    for (int i = 0; i < n; i++) {\n        res = std::max(res, d[i][n - i - 1][k] * 2 + 1);\n        res = std::max(res, d[i][n - i][k] * 2);\n    }\n    cout << res << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n//\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//\nconstexpr ll MOD=1e9+7;\n//constexpr ll MOD=998244353;\n//constexpr ll MOD=10000000;\n//constexpr ll MOD=1e5;\nconstexpr ll MAX=3e6;\nconstexpr ll INF=(1ll<<60);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate<typename T>\nstruct Segment_tree{\n    ll N;\n    T mem;\n    vector<T> node;\n    Segment_tree(vector<T> &X,T m):mem(m){\n        ll sz=X.size();\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mem);\n        rep(i,0,sz) node[N-1+i]=X[i];\n        per(i,N-2,0){\n            node[i]=Compare(node[i*2+1],node[i*2+2]);\n        }\n    }\n    T Compare(T &A,T &B){\n        return std::max(A,B);\n    }\n    void update(ll X,T val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=Compare(node[X*2+1],node[X*2+2]);\n        }\n    }\n    T Query(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mem;\n        if(a<=l&&r<=b) return node[now];\n        auto vl=Query(a,b,now*2+1,l,(l+r)/2),vr=Query(a,b,now*2+2,(l+r)/2,r);\n        return Compare(vl,vr);\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,int a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nvoid comp(vi &A){\n    std::map<ll,ll> mem;\n    rep(i,0,A.size()) mem[A[i]]=0;\n    ll cnt=0;\n    for(auto &p:mem) p.second=cnt++;\n    rep(i,0,A.size()) A[i]=mem[A[i]];\n}\nll RLCS(string S){\n    string T=S;\n    reverse(ALL(T));\n    ll N=S.size();\n    vii dp(N+1,vi(N+1));\n    REP(i,0,N){\n        REP(j,0,N){\n            if(!i){\n                if(j) dp[i][j]=dp[i][j-1];\n            }\n            else if(!j){\n                dp[i][j]=dp[i-1][j];\n            }\n            else{\n                dp[i][j]=std::max(dp[i][j-1],dp[i-1][j]);\n                if(S[i-1]==T[j-1]) dp[i][j]=std::max(dp[i][j],dp[i-1][j-1]+1);\n            }\n        }\n    }\n    return dp[N][N];\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    string S; cin>>S;\n    ll K,N=S.size(); cin>>K;\n    string T=S; reverse(ALL(T));\n    vector<vii> dp(N/2+1,vii(N/2+1,vi(K+1,INF)));\n    dp[0][0][0]=0;\n    vii mem(26);\n    rep(i,0,N/2) mem[T[i]-'a'].pb(i+1);\n    rep(i,0,N/2){\n        REP(j,0,N/2){\n            REP(k,0,K) dp[i+1][j][k]=dp[i][j][k];\n        }\n        rep(j,0,N/2){\n            REP(k,0,K){\n                if(dp[i][j][k]==INF) continue;\n                ll X=disup(mem[S[i]-'a'],dp[i][j][k]);\n                if(X<mem[S[i]-'a'].size()){\n                    ll Y=mem[S[i]-'a'][X];\n                    dp[i+1][j+1][k]=std::min(dp[i+1][j+1][k],Y);\n                }\n                if(dp[i][j][k]<N/2&&k<K){\n                    dp[i+1][j+1][k+1]=std::min(dp[i+1][j+1][k+1],dp[i][j][k]+1);\n                }\n            }\n        }\n        REP(j,0,N/2){\n            REP(k,1,K) dp[i+1][j][k]=std::min(dp[i+1][j][k],dp[i+1][j][k-1]);\n        }\n    }\n    ll ans=0;\n    per(i,N/2,0){\n        ll cnt=0p\n        per(j,N/2,0){\n            if(dp[i][j][K]!=INF){\n                ll left=i,right=N-1-dp[i][j][K];\n                if(left<=right){\n                    string P=S.substr(left,right-left+1);\n                    ans=std::max(ans,j*2+RLCS(P));\n                }\n                else{\n                    ans=std::max(ans,j*2);\n                }\n                cnt++;\n                if(cnt==10) break;\n            }\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include<bits/stdc++.h>\n# include<ext/pb_ds/assoc_container.hpp>\n# include<ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\ntemplate <typename T>\nusing ordered_set = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n# define int long long\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n# define S second\n# define F first\n# define kill(x) return(cout << x << '\\n', 0LL)\n# define debug(x) cerr<< #x << \" = \" << (x) << endl\n# define ddebug(x, y) cerr<< #x << \" = \" << (x)  << \", \" << #y << \" = \" << (y) << endl\n# define tdebug(x, y, z) cerr<< #x << \" = \" << (x)  << \", \" << #y << \" = \" << (y) << \", \" << #z << \" = \" << (z) << endl\n# define bin(x) cerr<< #x << \" : \" << bitset<4>(x) << endl\n# define sz(s) (int)s.size()\n# define sq(x) (x) * (x)\n# define PB(x) push_back(x)\n# define smax(x, y) (x) = max((x), (y))\n# define smin(x, y) (x) = min((x), (y))\n# define all(x) x.begin(), x.end()\n# define SP fixed << setprecision(10)\n# define uop(x, y) pii(min(x, y), max(x, y))\n# define MP(x, y) make_pair(x, y)\n\nconst int MAXN = 300 + 10;\nint dp[MAXN][MAXN][MAXN];\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n\tstring s;\n\tint k;\n\tcin >> s >> k;\n\n\tfor (int t = 1; t <= sz(s); t ++)\n\t{\n\t\tfor (int i = 0; i + t - 1 < sz(s); i ++)\n\t\t{\n\t\t\tint j = i + t - 1;\n\t\t\tfor (int l = 0; l <= k; l ++)\n\t\t\t{\n\t\t\t\tif (t == 1)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j][l] = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdp[i][j][l] = max(dp[i + 1][j][l], dp[i][j - 1][l]);\n\t\t\t\tif (l || s[i] == s[j])\n\t\t\t\t\tsmax(dp[i][j][l], dp[i + 1][j - 1][l - (s[i] != s[j])] + 2);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][sz(s) - 1][k] << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n変更箇所は順読み逆読みの少なくとも片方で役立たないといけない\nつまり1点分として加算される必要がある\n逆に1点分以上の役割は持てない<-嘘だった\n例えば右端の文字が他に存在しない文字ならそれを変更するのはOK\n*/\n/*\n問題概要は最長の回文を作れ？\nだとすると中心決めてしまえばそこからは書き換えるかどうかは片側だけに注目すればよくて\nsBtに対してsを右側から見ていくことを考える\n変えるならt[now]しかありえなくて、書き換えた方がいいかどうかチェックするのに150^2かかる？\nなんか違いそう\n端から見て言ってdp[i][j][k]で考えるべき？\ndp[i][j][k]:左からi文字右からj文字、k文字変更した時の最長回文\ndp[i][j][k]=max(dp[i][j-1][k],dp[i-1][j][k],dp[i-1][j-1][k]+(s[i]==s[N-j-1]),dp[i-1][j-1][k-1]+1)\n*/\ntemplate<typename T>\nvoid fin(T a){\n  cout<<a<<endl;\n  exit(0);\n}\nint dp[400][400][400];\nsigned main(){\n  string s;int K;cin>>s>>K;\n  int N=s.size();\n  if(K>=N/2)fin(N);\n  int ans=0;\n  for(int k=0;k<=K;k++){\n    for(int i=1;i<N;i++){\n      for(int j=1;i+j<=N;j++){\n        dp[i][j][k]=max({dp[i][j-1][k],dp[i-1][j][k],dp[i-1][j-1][k]+2*(s[i-1]==s[N-j])});\n        if(k)dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k-1]+2);\n        ans=max(ans,dp[i][j][k]+(i+j<N));\n      }\n    }\n  }\n  cout<<max(ans,1)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    \n    string s;\n    int k, n;\n    cin >> s >> k;\n    n = s.size();\n    static int dp[301][301][301];\n    for(int r=0;r<=k;++r){\n        for(int i=0;i<n;++i) dp[i][i][r] = 0;\n        for(int i=0;i<n;++i) dp[i][i+1][r] = 1;\n        for(int w=2;w<=n;++w){\n            for(int i=0;i+w<=n;++i){\n                dp[i][i+w][r] = max(dp[i][i+w-1][r], dp[i+1][i+w][r]);\n                if(s[i] == s[i+w-1]) dp[i][i+w][r] = max(dp[i][i+w][r], dp[i+1][i+w-1][r]+2);\n                if(r > 0) dp[i][i+w][r] = max(dp[i][i+w][r], dp[i+1][i+w-1][r-1]+2);\n            }\n        }\n    }\n    cout << dp[0][n][k] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nshort dp[305][305][305];\nchar in[310];\nvoid upd(short &x, short y) {\n\tif (x < y) x = y;\n}\nint main() {\n\tint n, k;\n\tscanf(\"%s%d\", in+1, &k);\n\tn = strlen(in+1);\n\tfor (int i = 1; i <= n; i++) for (int j = 0; j <= k; j++) dp[i][i][0] = 1;\n\tfor (int d = 1; d <= n; d++) {\n\t\tfor (int i = 1; i + d <= n; i++) {\n\t\t\tint j = i + d;\n\t\t\tfor (int t = 0; t <= k; t++) {\n\t\t\t\tupd(dp[i][j][t], dp[i + 1][j][t]);\n\t\t\t\tupd(dp[i][j][t], dp[i][j - 1][t]);\n\t\t\t}\n\t\t\tif (in[i] == in[j]) {\n\t\t\t\tfor (int t = 0; t <= k; t++) upd(dp[i][j][t], dp[i + 1][j - 1][t] + 2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int t = 1; t <= k; t++) upd(dp[i][j][t], dp[i + 1][j - 1][t-1] + 2);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[1][n][k]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=305;\nstring s;\nint dp[305][305][305],K;\nint dfs(int l,int r,int x)\n{\n    if(r<l)return 0;\n    if(l==r)return 1;\n    if(dp[l][r][x]!=-1)return dp[l][r][x];//记忆化思想，减少搜索次数\n    int t=max(dfs(l+1,r,x),dfs(l,r-1,x));//向左或右扩展一个\n    if(st[l]==st[r])t=max(t,dfs(l+1,r-1,x)+2);//相等，进行扩展\n    if(x)t=max(t,dfs(l+1,r-1,x-1)+2);//改变一个字符，向内扩展\n    return dp[l][r][x]=t;\n}\nint main()\n{\n    cin>>st>>K;\n    memset(dp,-1,sizeof(dp));\n    cout<<dfs(0,st.size()-1,K)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dp[400][400][400];\n\nint main() {\n  string s;\n  cin >> s;\n\n  int K;\n  cin >> K;\n\n  for (int i = 0; i < s.size(); ++i) {\n    dp[i][i][0] = 1;\n  }\n\n  int ans = 1;\n  for (int d = 1; d < s.size(); ++d) {\n    for (int l = 0; l + d < s.size(); ++l) {\n      int r = l + d;\n      for (int k = 0; k <= K; ++k) {\n        if (s[l] == s[r]) {\n          dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k] + 2);\n        } else {\n          if (k) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k - 1] + 2);\n        }\n\n        dp[l][r][k] = max({dp[l][r][k], dp[l + 1][r][k], dp[l + 1][r - 1][k], dp[l][r - 1][k]});\n        ans = max(ans, dp[l][r][k]);\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nint main(void) {\n  string S;\n  ll N, K;\n  cin >> S >> K;\n  N = S.length();\n\n  ll dp[N][N][K + 1];\n  REP(l, 0, N) REP(r, l, N) REP(k, 0, K + 1) dp[l][r][k] = 0;\n  REP(l, 0, N) REP(k, 0, K + 1) dp[l][l][k] = 1;\n  REP(l, 0, N - 1) if(S[l] == S[l + 1]) dp[l][l + 1][0] = 2;\n  REP(l, 0, N - 1) REP(k, 1, K + 1) dp[l][l + 1][k] = 2;\n  REP(s, 0, N) REP(l, 0, N - s) {\n    ll r = l + s;\n    REP(k, 0, K + 1) {\n      if(l + 1 <= r - 1 && S[l] == S[r]) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k] + 2);\n      if(l + 1 <= r) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r][k]);\n      if(l <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l][r - 1][k]);\n      if(k > 0 && l + 1 <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k - 1] + 2);\n      if(k > 0 && l + 1 <= r) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r][k - 1]);\n      if(k > 0 && l <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l][r - 1][k - 1]);\n      if(k > 0) dp[l][r][k] = max(dp[l][r][k], dp[l][r][k - 1]);\n    }\n  }\n  cout << dp[0][N - 1][K] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int N = 3e2+5;\nint n, m, f[N][N][N], ans; char s[N];\nint main()\n{\n    scanf(\"%s\", s+1), n = strlen(s+1), m = read();\n    for(int i = 1; i <= n; ++i) f[0][i][i] = 1;\n    for(int k = 0; k <= m; ++k)\n        for(int l = 2; l <= n; ++l)\n            for(int i = 1, j = l; j <= n; ++i, ++j)\n            {\n                f[k][i][j] = max(f[k][i+1][j], f[k][i][j-1]);\n                if(s[i] == s[j]) f[k][i][j] = max(f[k][i][j], f[k][i+1][j-1]+2);\n                if(k) f[k][i][j] = max(f[k][i][j], f[k-1][i+1][j-1]+2);\n                ans = max(ans, f[k][i][j]);\n            }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #includes {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define LET(x,a) __typeof(a) x(a)\n//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n\n#define EXIST(e,s) ((s).find(e)!=(s).end())\n\n#define RESET(a) memset((a),0,sizeof(a))\n#define SET(a) memset((a),-1,sizeof(a))\n#define PB push_back\n#define DEC(it,command) __typeof(command) it=command\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define debug_v(x) cerr << #x << \" = [\";REP(__ind,(x).size()){cerr << (x)[__ind] << \", \";}cerr << \"] (L\" << __LINE__ << \")\" << endl;\n\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\n\ntypedef long long Int;\ntypedef unsigned long long uInt;\ntypedef long double rn;\n\ntemplate<class T>\nT inf(){\n\treturn numeric_limits<T>::has_infinity?numeric_limits<T>::infinity():(numeric_limits<T>::max()/2);\n}\n\ntypedef pair<int,int> pii;\n\n/*\n#ifdef MYDEBUG\n#include\"debug.h\"\n#include\"print.h\"\n#endif\n*/\n// }}}\n\n//{{{ io\nFILE *file_in=stdin,*file_out=stdout;\n#define fin normal_in\n#define fout normal_out\n//const char fname[]=\"\";\n//FILE *fin=fopen(fname,\"r\"),*fout=fopen(fname,\"w\");\n#ifdef __MINGW32__\n#define LLD \"%I64d\"\n#define LLU \"%I64u\"\n#else\n#define LLD \"%lld\"\n#define LLU \"%llu\"\n#endif\nstruct NORMAL_IN{\n\tbool cnt;\n\tNORMAL_IN():cnt(true){}\n\toperator int() const {return cnt;}\n#define endl \"\\n\"\n\tNORMAL_IN& operator>>(int &n){cnt=fscanf(file_in,\"%d\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(unsigned int &n){cnt=fscanf(file_in,\"%u\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(long long &n){cnt=fscanf(file_in,LLD,&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(unsigned long long &n){cnt=fscanf(file_in,LLU,&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(double &n){cnt=fscanf(file_in,\"%lf\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(long double &n){cnt=fscanf(file_in,\"%Lf\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(char *c){cnt=fscanf(file_in,\"%s\",c)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(string &s){\n\t\ts.clear();\n\t\tfor(bool r=false;;){\n\t\t\tconst char c=getchar();\n\t\t\tif(c==EOF){ cnt=false; break;}\n\t\t\tconst int t=isspace(c);\n\t\t\tif(!r and !t)r=true;\n\t\t\tif(r){\n\t\t\t\tif(!t)s.push_back(c);\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\t\tNORMAL_IN& operator>>(vector<T> &v){\n\t\t\tint n;fscanf(file_in,\"%d\",&n);\n\t\t\tREP(i,n){\n\t\t\t\tT t;*this>>t;\n\t\t\t\tv.push_back(t);\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n} normal_in;\n\nstruct NORMAL_OUT{\n\tNORMAL_OUT& operator<<(const int &n){fprintf(file_out,\"%d\",n);return *this;}\n\tNORMAL_OUT& operator<<(const unsigned int &n){fprintf(file_out,\"%u\",n);return *this;}\n\tNORMAL_OUT& operator<<(const long long &n){fprintf(file_out,LLD,n);return *this;}\n\tNORMAL_OUT& operator<<(const unsigned long long &n){fprintf(file_out,LLU,n);return *this;}\n\tNORMAL_OUT& operator<<(const double &n){fprintf(file_out,\"%lf\",n);return *this;}\n\tNORMAL_OUT& operator<<(const long double &n){fprintf(file_out,\"%Lf\",n);return *this;}\n\tNORMAL_OUT& operator<<(const char c[]){fprintf(file_out,\"%s\",c);return *this;}\n\tNORMAL_OUT& operator<<(const string &s){fprintf(file_out,\"%s\",s.c_str());return *this;}\n} normal_out;\nstruct ERR_OUT{\n\ttemplate<class T>\n\t\tERR_OUT& operator<<(const T &a){\n\t\t\tcerr<<\"\\x1b[7m\"<<a<<\"\\x1b[m\";\n\t\t\treturn *this;\n\t\t}\n} ferr;\n//}}}\n\nint dp[305][305][305];\n\nvoid solve(string S, Int K){\n\tmemset(dp,-1,sizeof(dp));\n\tfunction<int(int,int,int)> calc = [&](int l, int r, int k){\n\t\tif(dp[l][r][k]!=-1)return dp[l][r][k];\n\t\tif(r<l)return dp[l][r][k] = 0;\n\t\tif(l==r)return dp[l][r][k] = 1;\n\t\tint ans;\n\t\tans = max(calc(l+1,r,k),calc(l,r-1,k));\n\t\tif(S[l]==S[r])ans = max(ans,calc(l+1,r-1,k)+2);\n\t\telse{\n\t\t\tif(k>0)ans = max(ans,calc(l+1,r-1,k-1)+2);\n\t\t}\n\t\treturn dp[l][r][k] = ans;\n\t};\n\tfout<<calc(0,S.size()-1,K)<<endl;\n}\n\nint main(){\t\n\tstring S;\n\tInt K;\n\tfin >> S;\n\tfin >> K;\n\tsolve(S, K);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//\n#include <cstdio>\n#include <iostream>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n//#ifdef atom #else #endif\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\n#define X first\n#define Y second\n#define vi vector<int>\n#define vvi vector< vi >\n#define vii vector< ii >\n#define mp make_pair\n#define pb push_back\nstring s;\nint k;\nconst int maxn = 305;\nconst int maxk = 305;\nint dp[maxn][maxn][maxk];\nint n;\nint solve(int i, int j, int k)\n{\n    if(i> j) return 0;\n    if(dp[i][j][k] != -1) return dp[i][j][k];\n    int res = 0;\n    res = max(res, solve(i+1, j, k));\n    res = max(res, solve(i, j-1, k));\n    if(s[i] == s[j]) res = max(res, 1+solve(i+1, j-1, k));\n    if(k) res = max(res, solve(i+1, j-1, k-1)+2);\n    return dp[i][j][k] = res;\n}\nint main()\n{\n    //#ifndef atom freopen(\".in\", \"r\", stdin); freopen(\".out\", \"w\", stdout); #endif\n    cin >> s >> k;\n    n = s.size();\n    memset(dp, -1, sizeof dp);\n    cout << solve(0, n-1, k) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int LL;\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& vec) {\n    out << \"[\";\n    for (int x : vec) out << x << \", \";\n    out << \"]\";\n    return out;\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n    #define dbg_var(x) clog << #x << \": \" << x << endl;\n#endif\n\nint ans[333][333][333];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    string s;\n    cin >> s;\n    int n = s.size();\n    int K; cin >> K;\n    \n    for(int i=0; i<n; i++) for(int k=0; k<=K; k++) ans[i][0][k] = 0;\n    for(int i=0; i+1<n; i++) for(int k=0; k<=K; k++) ans[i][1][k] = 1;\n    \n    for(int l=2; l<=n; l++){\n        for(int i=0; i+l<=n; i++){\n            for(int k=0; k<=K; k++){\n                int r = -2;\n                if(s[i] == s[i+l-1]) r = ans[i+1][l-2][k];\n                if(k > 0) r = max(r, ans[i+1][l-2][k-1]);\n                ans[i][l][k] = max( max(ans[i][l-1][k], ans[i+1][l-1][k]), 2 + r );\n                //~ cerr << i << ' ' << l << ' ' << k << ' ' << ans[i][l][k] << endl;\n            }\n        }\n    }\n    //~ cerr << 0 << ' ' << n << ' ' << K << ' ' << ans[0][n][K] << endl;\n    cout << ans[0][n][K] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\n#define NDEBUG\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\nusing uint = unsigned int;\nusing usize = std::size_t;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return ((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\ntemplate<typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T>\nstd::vector<T> read_vec(const std::size_t size)\n{\n    std::vector<T> v(size);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\ntemplate<typename... Types>\nauto read_vals() { return std::tuple<std::decay_t<Types>...>{read<Types>()...}; }\n#define SHOW(...) static_cast<void>(0)\ntemplate<typename T>\nstd::vector<T> make_v(const std::size_t size, T v) { return std::vector<T>(size, v); }\ntemplate<class... Args>\nauto make_v(const std::size_t size, Args... args) { return std::vector<decltype(make_v(args...))>(size, make_v(args...)); }\nint main()\n{\n    const auto s = read<std::string>();\n    const auto k = read<usize>();\n    const auto n = s.size();\n    auto memo    = make_v(n, n, k + 1, inf_v<usize>);\n    auto dp      = [&, k, n](auto&& self, const int a, const int b, const usize c) -> usize {\n        if (a > b or b < 0 or a < 0 or a >= n or b >= n) { return 0; }\n        if (memo[a][b][c] != inf_v<usize>) { return memo[a][b][c]; }\n        if (s[a] == s[b]) { return memo[a][b][c] = self(self, a + 1, b - 1, c) + (a == b ? 1UL : 2UL); }\n        return memo[a][b][c] = std::max({self(self, a + 1, b, c), self(self, a, b - 1, c), (c == k ? 0 : self(self, a + 1, b - 1, c + 1) + 2)});\n    };\n    std::cout << dp(dp, 0, (int)n - 1, 0) << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nint main(void) {\n  string S;\n  ll N, K;\n  cin >> S >> K;\n  N = S.length();\n\n  ll dp[N][N][K + 1];\n  REP(l, 0, N) REP(r, l, N) REP(k, 0, K + 1) dp[l][r][k] = 0;\n  REP(l, 0, N) REP(k, 0, K + 1) dp[l][l][k] = 1;\n  REP(l, 0, N - 1) REP(k, 0, K + 1) dp[l][l + 1][k] = S[l] == S[l + 1] && k > 0 ? 2 : 0;\n  REP(s, 0, N) REP(l, 0, N - s) {\n    ll r = l + s;\n    REP(k, 0, K + 1) {\n      if(l + 1 <= r - 1 && S[l] == S[r]) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k] + 2);\n      if(l + 1 <= r) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r][k]);\n      if(l <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l][r - 1][k]);\n      if(k > 0 && l + 1 <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k - 1] + 2);\n      if(k > 0) dp[l][r][k] = max(dp[l][r][k], dp[l][r][k - 1]);\n    }\n  }\n  cout << dp[0][N - 1][K] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dp[305][305][305];\nstring s;\n\nint my(int l,int r,int k)\n{\n\tif (dp[l][r][k]!=0)\n\t{\n\t\treturn dp[l][r][k];\n\t}\n\telse if (l==r)\n\t{\n\t\tdp[l][r][k]=1;\n\t\treturn 1;\n\t}\n\telse if (l+1==r)\n\t{\n\t\tif (s[l]==s[r]||k>0)\n\t\t{\n\t\t\tdp[l][r][k]=2;\n\t\t\treturn 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdp[l][r][k]=1;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tint ans=max(my(l+1,r,k),my(l,r-1,k));\n\tif (s[l]==s[r])\n\t{\n\t\tans=max(ans,my(l+1,r-1,k)+2);\n\t}\n\telse if (k>0)\n\t{\n\t\tans=max(ans,my(l+1,r-1,k-1)+2);\n\t}\n\tdp[l][r][k]=ans;\n\treturn ans;\n}\n\nint main(int argc, char const *argv[])\n{\n\tint k;\n\tcin>>s>>k;\n\tcout<<my(0,s.size()-1,k)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\nusing namespace std;\n\nconst int MAXN = 300;\nconst int INF = 1000 * 1000 * 1000;\n\nint dp[MAXN + 1][MAXN + 1][MAXN + 1];\n\nvoid upd(int &x, int y) {\n    x = max(x, y);\n}\n\nint main() {\n    //cin.tie(0), ios::sync_with_stdio(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n\n    string s;\n    cin >> s;\n    int n = (int)s.size();\n    int K;\n    cin >> K;\n\n    for (int i = 0; i <= K; i++) {\n        for (int j = 0; j <= n; j++) {\n            for (int k = 0; k <= n; k++) {\n                dp[i][j][k] = -INF;\n            }\n        }\n    }\n    dp[0][0][0] = 0;\n    for (int i = 0; i < n; i++) {\n        dp[0][i][i] = 1;\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int k = 0; k <= K; k++) {\n            for (int l = 0; l + len - 1 < n; l++) {\n                int r = l + len - 1;\n                upd(dp[k][l][r], dp[k][l + 1][r]);\n                upd(dp[k][l][r], dp[k][l][r - 1]);\n                if (s[l] == s[r]) {\n                    upd(dp[k][l][r], dp[k][l + 1][r - 1] + 2);\n                }\n                if (k > 0) {\n                    upd(dp[k][l][r], max(dp[k - 1][l + 1][r], dp[k - 1][l][r - 1]) + 2);\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for (int k = 0; k <= K; k++) {\n        ans = max(ans, dp[k][0][n - 1]);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(int i=(int)(st),i##end=(int)(ed);i<=i##end;++i)\n#define DREP(i,st,ed) for(int i=(int)(st),i##end=(int)(ed);i>=i##end;--i)\ntemplate<typename T>bool chkmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<typename T>bool chkmax(T &x,const T &y){return x<y?x=y,1:0;}\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\ntemplate<typename T>T read(){\n\tT x=0,f=1;\n\tchar c=getchar();\n\twhile((c<'0')||(c>'9')){if(c=='-')f=-1;c=getchar();}\n\twhile((c>='0')&&(c<='9'))x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\treturn x*f;\n}\n#define read() read<int>()\ntemplate<typename T>void write(T x,char c){\n\tstatic char t[25];\n\tstatic int tlen;\n\tt[tlen=1]=c;\n\tif(x<0)putchar('-'),x=-x;\n\tdo t[++tlen]=(x%10)^48;\n\twhile(x/=10);\n\twhile(tlen)putchar(t[tlen--]);\n}\n#define pb push_back\ntypedef long long ll;\ntypedef double lf;\nconst lf pi=acos(-1.0);\nconst int maxn=305;\nchar s[maxn];\nint n,m;\nint dp[maxn][maxn][maxn];\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1),m=read();\n\tREP(i,0,n)\n\t\tREP(j,0,n-i+1)\n\t\t\tREP(k,0,m){\n\t\t\t\tif(i>=1)chkmax(dp[i][j][k],dp[i-1][j][k]);\n\t\t\t\tif(j>=1)chkmax(dp[i][j][k],dp[i][j-1][k]);\n\t\t\t\tif((i>=1)&&(j>=1)){\n\t\t\t\t\tif(s[i]==s[n-j+1])\n\t\t\t\t\t\tchkmax(dp[i][j][k],dp[i-1][j-1][k]+2-((i+j==n+1)&&(i==n-j+1)));\n\t\t\t\t\telse if(k>=1)\n\t\t\t\t\t\tchkmax(dp[i][j][k],dp[i-1][j-1][k-1]+2-((i+j!=n+1)&&(i==n-j+1)));\n\t\t\t\t}\n\t\t\t}\n\tint ans=0;\n\tREP(i,1,n)\n\t\tchkmax(ans,dp[i][n-i+1][m]);\n\twrite(ans,'\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint DP[310][310];\n\nint main()\n{\n\tstring s;\n\tcin>>s;\n\tint k;\n\tcin>>k;\n\tstring s1=s;\n\treverse(s1.begin(),s1.end());\n//\tcout<<s1<<\"\\n\";\n\tint n=s.length();\n\tfor (int i=0;i<n;i++)\n\t for (int j=0;j<n;j++)\n\t {\n\t \tif (s[i]==s1[j])\n\t \t DP[i][j]=DP[i-1][j-1]+1;\n\t \telse\n\t \t DP[i][j]=max(DP[i-1][j],DP[i][j-1]);\n\t }\n//\tcout<<DP[n-1][n-1]<<\"\\n\";\n\tcout<<min(DP[n-1][n-1]+2*k,(int)s.length())<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N = 305;\n\nint dp[2][MAX_N][MAX_N];\nchar S[MAX_N];\n\nint main() {\n  scanf(\"%s\", S + 1);\n  int N = strlen(S + 1), K;\n  scanf(\"%d\", &K);\n\n  memset(dp, -0x3f, sizeof dp);\n\n  int o = 0, p, result = -0x3f3f3f3f;\n  dp[0][N + 1][0] = 0;\n  \n  for (int i = 1; i <= N; ++i) {\n    p = o, o ^= 1;\n    memset(dp[o], -0x3f, sizeof dp[o]);\n    dp[o][N + 1][0] = 0;\n    for (int j = N; j > i; --j)\n      for (int k = 0; k <= K; ++k) {\n\tdp[o][j][k] = max(dp[o][j + 1][k], dp[p][j][k]);\n\tif (S[i] == S[j]) dp[o][j][k] = max(dp[o][j][k], dp[p][j + 1][k] + 1);\n\telse if (k > 0) dp[o][j][k] = max(dp[o][j][k], dp[p][j + 1][k - 1] + 1);\n      }\n    for (int k = 0; k <= K; ++k) {\n      result = max(result, dp[o][i + 1][k] * 2);\n      result = max(result, dp[o][i + 2][k] * 2 + 1);\n    }\n  }\n\n  printf(\"%d\\n\", result);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//be name khoda\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n#define F first\n#define S second\n#define int long long\n\nconst int maxn = 310;\nconst int mod = 998244353;\nconst ll inf = 1e18;\n\nll pw(ll a, ll b)\n{\n    if(b == 0) return 1;\n    ll k = pw(a,b/2); k = (k * k) % mod;\n    if(b&1) k = (k * a) % mod;\n    return k;\n}\n\nint dp[maxn][maxn][maxn], n, K;\n\nsigned main()\n{\n   // ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    string ss; cin>> ss >> K; n = ss.size();\n    string s = \".\"; s += ss;\n\n    for(int t = 1; t <= n; t++)\n        for(int l = 1; l <= n-t+1; l++)\n            for(int k = 0; k <= K; k++)\n            {\n                int r = l+t-1;\n\n                if(t == 1)\n                {\n                    dp[l][r][k] = 1;\n                    continue;\n                }\n\n                if(s[l] == s[r])\n                    dp[l][r][k] = dp[l+1][r-1][k] + 2;\n                else\n                {\n                    dp[l][r][k] = max(dp[l+1][r][k], dp[l][r-1][k]);\n                    if(k)\n                        dp[l][r][k] = max(dp[l][r][k], dp[l+1][r-1][k-1] + 2);\n                }\n            }\n    cout<< dp[1][n][K];\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long \n#define pb push_back\n#define ms(a,b) memset(a,b,sizeof a)\n#define F(i,a,b) for (int i=a;i<=b;i++)\n#define DF(i,a,b) for (int i=a;i>=b;i--)\n#define SZ(x) (int)x.size()-1\nusing namespace std;\ninline int read(){\n\tchar ch=getchar(); int w=1,c=0;\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') w=-1;\n\tfor (;isdigit(ch);ch=getchar()) c=(c<<1)+(c<<3)+(ch^48);\n\treturn w*c;\n}\nconst int M=333;\nint dp[M][M][M];\nchar s[M];\nint n,k;\nint solve(int x,int y,int l){\n\tif (dp[x][y][l]) return dp[x][y][l];\n\tif (l<0) return -1e9;\n\tif (x>y) return 0;\n\tif (x==y) return dp[x][y][l]=1;\n\tdp[x][y][l]=max(solve(x+1,y-1,l-(s[x]!=s[y]))+2,max(solve(x+1,y,l),solve(x,y-1,l)));\n\treturn dp[x][y][l];\n} \nint main(){\n\tscanf(\"%s%d\",s+1,&k);\n\tn=strlen(s+1);\n\tcout<<solve(1,n,k)<<\"\\n\";\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nstring S;\n\nint dp[303][303][303];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>S>>K;\n\tN=S.size();\n\t\n\tFOR(i,N) {\n\t\tdp[i][i][K]=1;\n\t\tif(i<N-1) {\n\t\t\tdp[i][i+1][K]=2*S[i]==S[i+1];\n\t\t\tif(K) dp[i][i+1][K-1]=2;\n\t\t}\n\t}\n\t\n\t\n\t\n\tfor(i=1;i<=N;i++) {\n\t\tfor(int L=0;L+i<=N;L++) {\n\t\t\tint R=L+i-1;\n\t\t\tfor(k=0;k<=K;k++) {\n\t\t\t\tif(L) dp[L-1][R][k]=max(dp[L-1][R][k],dp[L][R][k]);\n\t\t\t\tif(R<N-1) dp[L][R+1][k]=max(dp[L][R+1][k],dp[L][R][k]);\n\t\t\t\tif(L&&R<N-1) {\n\t\t\t\t\tdp[L-1][R+1][k]=max(dp[L-1][R+1][k],dp[L][R][k]+2*(S[L-1]==S[R+1]));\n\t\t\t\t\tif(k) dp[L-1][R+1][k-1]=max(dp[L-1][R+1][k-1],dp[L][R][k]+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ma=0;\n\tFOR(i,K+1) ma=max(ma,dp[0][N-1][i]);\n\tcout<<ma<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\n\nint D[303][303][155];\nchar S[303]; int K;\n\nint main()\n{\n\tscanf(\"%s %d\", S+1,&K);\n\tint N = 0;\n\twhile (S[N + 1]) N++;\n\tif (2 * K > N) {\n\t\tprintf(\"%d\\n\" , N);\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = N; j > i; j--) {\n\t\t\tfor (int k = 0; k <= K; k++) {\n\t\t\t\tD[i][j][k] = max(D[i - 1][j][k], D[i][j + 1][k]);\n\t\t\t\tif (S[i] == S[j]) D[i][j][k] = max(D[i][j][k], D[i - 1][j + 1][k] + 2);\n\t\t\t\telse {\n\t\t\t\t\tif (k) D[i][j][k] = max(D[i][j][k], D[i - 1][j + 1][k-1] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = N; j > i; j--) {\n\t\t\tfor (int k = 0; k <= K; k++) {\n\t\t\t\tint d = D[i][j][k];\n\t\t\t\tif (i + 1 < j) d++;\n\t\t\t\tans = max(ans, d);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n//\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//\nconstexpr ll MOD=1e9+7;\n//constexpr ll MOD=998244353;\n//constexpr ll MOD=10000000;\n//constexpr ll MOD=1e5;\nconstexpr ll MAX=3e6;\nconstexpr ll INF=(1ll<<60);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate<typename T>\nstruct Segment_tree{\n    ll N;\n    T mem;\n    vector<T> node;\n    Segment_tree(vector<T> &X,T m):mem(m){\n        ll sz=X.size();\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mem);\n        rep(i,0,sz) node[N-1+i]=X[i];\n        per(i,N-2,0){\n            node[i]=Compare(node[i*2+1],node[i*2+2]);\n        }\n    }\n    T Compare(T &A,T &B){\n        return std::max(A,B);\n    }\n    void update(ll X,T val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=Compare(node[X*2+1],node[X*2+2]);\n        }\n    }\n    T Query(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mem;\n        if(a<=l&&r<=b) return node[now];\n        auto vl=Query(a,b,now*2+1,l,(l+r)/2),vr=Query(a,b,now*2+2,(l+r)/2,r);\n        return Compare(vl,vr);\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,int a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nvoid comp(vi &A){\n    std::map<ll,ll> mem;\n    rep(i,0,A.size()) mem[A[i]]=0;\n    ll cnt=0;\n    for(auto &p:mem) p.second=cnt++;\n    rep(i,0,A.size()) A[i]=mem[A[i]];\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    string S; cin>>S;\n    ll K,N=S.size(); cin>>K;\n    string T=S; reverse(ALL(T));\n    vector<vii> dp(N+1,vii(N+1,vi(K+1,INF)));\n    ll ans=0;\n    REP(i,0,K) dp[0][0][i]=0;\n    vii mem(26);\n    rep(i,0,N) mem[T[i]-'a'].pb(i+1);\n    rep(i,0,N){\n        REP(j,0,N){\n            REP(k,0,K) dp[i+1][j][k]=dp[i][j][k];\n        }\n        rep(j,0,N){\n            REP(k,0,K){\n                if(dp[i][j][k]==INF) continue;\n                ll X=disup(mem[S[i]-'a'],dp[i][j][k]);\n                if(X<mem[S[i]-'a'].size()){\n                    ll Y=mem[S[i]-'a'][X];\n                    if(i+Y<N){\n                        dp[i+1][j+2][k]=std::min(dp[i+1][j+2][k],Y);\n                        dp[i+1][j+1][k]=std::min(dp[i+1][j+1][k],Y);\n                    }\n                    else if(i+Y==N){\n                        dp[i+1][j+1][k]=std::min(dp[i+1][j+1][k],Y);\n                        \n                    }\n                }\n                ll Y=dp[i][j][k]+1;\n                if(K==k) continue;\n                if(i+Y<N){\n                    dp[i+1][j+2][k+1]=std::min(dp[i+1][j+2][k+1],Y);\n                    dp[i+1][j+1][k+1]=std::min(dp[i+1][j+1][k+1],Y);\n                }\n                else if(i+Y==N){\n                    dp[i+1][j+1][k+1]=std::min(dp[i+1][j+1][k+1],Y);\n                }\n            }\n        }\n        REP(j,0,N){\n            REP(k,1,K){\n                dp[i+1][j][k]=std::min(dp[i+1][j][k],dp[i+1][j][k-1]);\n                if(dp[i+1][j][k]!=INF){\n                    ans=std::max(ans,j);\n                }\n            }\n            if(dp[i+1][j][0]!=INF) ans=std::max(ans,j);\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#define SIZE 305\n#define INF 1000000005\n\nusing namespace std;\n\nchar str[SIZE];\nint dp[SIZE][SIZE];\nint nxt[SIZE][SIZE];\n\nint main()\n{\n\tscanf(\"%s\",&str);\n\tint K;\n\tscanf(\"%d\",&K);\n\tint n=strlen(str);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=i;j<n;j++)\n\t\t{\n\t\t\tdp[i][j]=(str[i]==str[j])?0:1;\n\t\t}\n\t}\n\tint mx=1;\n\tfor(int i=1;;i++)\n\t{\n\t\tbool up=false;/*\n\t\tfor(int l=0;l<n;l++)\n\t\t{\n\t\t\tfor(int r=l;r<n;r++)\n\t\t\t{\n\t\t\t\tprintf(\"%d \",dp[l][r]);\n\t\t\t}puts(\"\");\n\t\t}*/\n\t\tfor(int l=0;l<n;l++)\n\t\t{\n\t\t\tfor(int r=l;r<n;r++)\n\t\t\t{\n\t\t\t\tnxt[l][r]=INF;\n\t\t\t\tif(dp[l][r]>K) dp[l][r]=INF;\n\t\t\t\tif(dp[l][r]!=INF)\n\t\t\t\t{\n\t\t\t\t\tup=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!up) break;\n\t\tfor(int l=0;l<n;l++)\n\t\t{\n\t\t\tfor(int r=n-1;r>=l;r--)\n\t\t\t{\n\t\t\t\tif(l<r) dp[l][r-1]=min(dp[l][r-1],dp[l][r]);\n\t\t\t\tif(l+1<=r) dp[l+1][r]=min(dp[l+1][r],dp[l][r]);\n\t\t\t}\n\t\t}\n\t\tmx=2*i;\n\t\tfor(int l=0;l<n;l++)\n\t\t{\n\t\t\tfor(int r=l;r<n;r++)\n\t\t\t{\n\t\t\t\tif(dp[l][r]!=INF)\n\t\t\t\t{\n\t\t\t\t\tif(l==r) mx=2*i+1;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(str[l]==str[r])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnxt[l+1][r-1]=min(nxt[l+1][r-1],dp[l][r]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnxt[l+1][r-1]=min(nxt[l+1][r-1],dp[l][r]+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int l=0;l<n;l++)\n\t\t{\n\t\t\tfor(int r=l;r<n;r++)\n\t\t\t{\n\t\t\t\tdp[l][r]=nxt[l][r];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",mx);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for (int (i) = (a); (i) < (b); ++(i))\n#define per(i, a, b) for (int (i) = (a); (i) >= (b); --(i))\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define eb emplace_back\n#define ff first\n#define ss second\n#define sz(x) ((int) x.size())\n#define rd(type, ...) type __VA_ARGS__; sc(__VA_ARGS__)\n#define rda(a, n) rep(i, 0, n) cin >> a[i];\n#define rdaa(a, n, m) rep(i, 0, n) rep(j, 0, m) cin >> a[i][j];\n#define rdv(type, v, n) vector<type> v(n); rep(__ii, 0, n) cin >> v[__ii]\n#define rdm(type, v, h, w) vector<vector<type>>(h, vector<type>(w)) v; rep(__ii, 0, h) rep(__jj, 0, w) cin >> v[__ii][__jj]\n#define rdv2(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_rdv2_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_rdv2_Scan(w_, __VA_ARGS__);}\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"] : \", debug_out(__VA_ARGS__)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\nvoid solve();\nsigned main() {ios::sync_with_stdio(false); cin.tie(0);\n  cout << fixed; cout.precision(20); solve(); return 0;}\ntemplate<typename T> void chmin(T &a, T b) {if (a > b) a = b;}\ntemplate<typename T> void chmax(T &a, T b) {if (a < b) a = b;}\ntemplate<typename T> void MACRO_rdv2_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename... Rest> void MACRO_rdv2_Init(int n, First& first, Rest& ...rest) { first.resize(n); MACRO_rdv2_Init(n, rest...); }\ntemplate<typename T> void MACRO_rdv2_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename... Rest> void MACRO_rdv2_Scan(int p, First& first, Rest& ...rest) { std::cin >> first[p]; MACRO_rdv2_Scan(p, rest...); }\ntemplate<typename T> void wrv(const vector<T> &v) {rep(__ii, 0, sz(v)) {if (__ii) cout << ' '; cout << v[__ii];} cout << '\\n';} \ntemplate<typename T> void wrm(const vector<vector<T>> &v) {rep(__ii, 0, sz(v)) {rep(__jj, 0, v[__ii].size()) {if (__jj) cout << ' '; cout << v[__ii][__jj];} cout << '\\n';}}\ntemplate<typename T> void sc(T& x) {cin >> x;}\ntemplate<typename Head, typename... Tail> void sc(Head& head, Tail&... tail) {cin >> head; sc(tail...);}\ntemplate<typename T> void wr(const T& x) {cout << x << '\\n';}\ntemplate<typename Head, typename... Tail> void wr(const Head& head, const Tail&... tail) {cout << head << ' '; wr(tail...);}\ntemplate<typename T> void wrf(const T& x) {cout << x << endl;}\ntemplate<typename Head, typename... Tail> void wrf(const Head& head, const Tail&... tail) {cout << head << ' '; wrf(tail...);}\ntemplate<typename T> void debug_out(const T& x) {cerr << x << '\\n';}\ntemplate<typename Head, typename... Tail> void debug_out(const Head& head, const Tail&... tail) {cerr << head << ' '; debug_out(tail...);}\ntemplate<typename... T> void err(const T&... cod) {wr(cod...); exit(0);}\n\nconst int N = 305;\n\nstring s;\nint n, k;\nint dp[N][N][N];\n\nint f(int l, int r, int sisa) {\n  if (l > r) return 0;\n  if (l == r) return 1;\n  if (dp[l][r][sisa] != -1) return dp[l][r][sisa];\n\n  int ans = 2 * (s[l] == s[r]) + f(l + 1, r - 1, sisa);\n  if (sisa > 0) chmax(ans, 2 + f(l + 1, r - 1, sisa - 1));\n  chmax(ans, f(l + 1, r, sisa));\n  chmax(ans, f(l, r - 1, sisa));\n  \n  return dp[l][r][sisa] = ans;\n}\n\nvoid solve() {\n  cin >> s >> k;\n  n = sz(s);\n  memset(dp, -1, sizeof dp);\n  wr(f(0, n - 1, k));\n}"
  },
  {
    "language": "C++",
    "code": "// khodaya khodet komak kon\n#include <bits/stdc++.h>\n#define pb push_back\n#define ers erase\n#define ins insert\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x)  cerr << #x << \" = \" << x << endl\n#define kill(x) return cout << x, 0;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#pragma GCC optimize (\"Ofast\")\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vl;\ntypedef vector<pll> vpl;\n\nconst ld Pi = 3.14159265359;\nconst ll MOD = 1000 * 1000 * 1000 + 7;\nconst ll N = 2e5 + 10;\nconst ll INF = 1e18;\nstr s;\nll K, n, dp[310][310][310];\n\nint main(){\n\tIOS;\n\tcin >> s;\n\tcin >> K;\n\tll n = s.size();\n\tif (n == 1) return cout << 1, 0;\n\ts = \".\" + s;\n\t//cout << n << '\\n';\n\tfor (int i = 1; i <= n; i++){\n\t\tdp[i][i + 1][0] = 1;\n\t}\n\tfor (int i = 2; i <= n; i++){\n\t\tfor (int j = 1; j <= n - i + 1; j++){\n\t\t\tfor (int k = 0; k <= K; k++){\n\t\t\t\tif (k == 0){\n\t\t\t\t\tif (s[j] == s[j + i - 1]){\n\t\t\t\t\t\tdp[j][i + j][0] = dp[j + 1][i + j - 1][0] + 2;\n\t\t\t\t\t}\n\t\t\t\t\tdp[j][i + j][k] = max(dp[j][i + j][k], max(dp[j + 1][i + j][k], dp[j][i + j - 1][k]));\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\telse if (k >= i - 1){\n\t\t\t\t\tdp[j][i + j][k] = i;\n\t\t\t\t}else{\n\t\t\t\t\tdp[j][i + j][k] = dp[j][i + j][k - 1];\n\t\t\t\t\tif (s[j] == s[i + j - 1]){\n\t\t\t\t\t\tdp[j][i + j][k] = dp[j + 1][i + j - 1][k] + 2;\n\t\t\t\t\t}\n\t\t\t\t\tdp[j][i + j][k] = max(dp[j][i + j][k], max(dp[j + 1][i + j][k], dp[j][i + j - 1][k]));\n\t\t\t\t\tdp[j][i + j][k] = max(dp[j][i + j][k], 2 + dp[j + 1][i + j - 1][k - 1]);\n\t\t\t\t}\n\t\t\t\t//cout << j << ' ' << j + i - 1 << ' ' << k << ' ' << dp[j][j + i][k] << '\\n';\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t}\n\tcout << dp[1][n + 1][K];\n\t\n\t\n\t\n\treturn 0;\n}\n\n\n\n\n\n\n/*\n     ,---,           ___                 ,--,\n    '  .' \\        ,--.'|_             ,--.'|                             ,--,\n   /  ;    '.      |  | :,'            |  | :                           ,--.'|    ,---.        ,---,\n  :  :       \\     :  : ' :            :  : '                 .--.--.   |  |,    '   ,'\\   ,-+-. /  |\n  :  |   /\\   \\  .;__,'  /    ,--.--.  |  ' |     ,--.--.    /  /    '  `--'_   /   /   | ,--.'|'   |\n  |  :  ' ;.   : |  |   |    /       \\ '  | |    /       \\  |  :  /`./  ,' ,'| .   ; ,. :|   |  ,\"' |\n  |  |  ;/  \\   \\:__,'| :   .--.  .-. ||  | :   .--.  .-. | |  :  ;_    '  | | '   | |: :|   | /  | |\n  '  :  | \\  \\ ,'  '  : |__  \\__\\/: . .'  : |__  \\__\\/: . .  \\  \\    `. |  | : '   | .; :|   | |  | |\n  |  |  '  '--'    |  | '.'| ,\" .--.; ||  | '.'| ,\" .--.; |   `----.   \\'  : |_|   :    ||   | |  |/\n  |  :  :          ;  :    ;/  /  ,.  |;  :    ;/  /  ,.  |  /  /`--'  /|  | '.'\\   \\  / |   | |--'\n  |  | ,'          |  ,   /;  :   .'   \\  ,   /;  :   .'   \\'--'.     / ;  :    ;`----'  |   |/\n  `--''             ---`-' |  ,     .-./---`-' |  ,     .-./  `--'---'  |  ,   /         '---'\n                            `--`---'            `--`---'                 ---`-'\n*/\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define st first\n#define nd second\n#define pb push_back\n#define pf push_front\n#define ppb pop_back\n#define ppf pop_front\n#define umax(x,y) x=max(x,y)\n#define umin(x,y) x=min(x,y)\n#define ll long long \n#define ii pair<int,int>\n#define iii pair<int,ii>\n#define iiii pair<ii,ii>\n#define sz(x) ((int) x.size())\n#define orta ((bas+son)/2)\n#define all(x) x.begin(),x.end()\n#define pw(x) (1<<(x))\n#define inf 1000000005\n#define MOD 924844033 \n#define N 100005\n#define M 1000003\n#define LOG 20\n#define KOK 250\n#define EPS 0.0000001\nusing namespace std;\n\nint n,k;\nbool vis[305][305][305];\nint dp[305][305][305];\nchar s[305];\n\nint solve(int l,int r,int rem) {\n\n\tif(rem<0) return -inf;\n\n\tif(l>=r) return (l==r);\n\n\tbool& v=vis[l][r][rem];\n\tint& res=dp[l][r][rem];\n\n\tif(v) return res;\n\n\tif(s[l]==s[r]) umax(res,solve(l+1,r-1,rem)+2);\n\n\tumax(res,max(solve(l+1,r,rem),solve(l,r-1,rem)));\n\n\tumax(res,solve(l+1,r-1,rem-1)+2);\n\n\treturn res;\n\n}\n\nint main() {\n\n\tscanf(\"%s %d\",s+1,&k);\n\n\tn=strlen(s+1);\n\n\tprintf(\"%d\",solve(1,n,k));\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define FORR(i, n) for(ll i = (ll)n - 1LL; i >= 0LL; i--)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) begin(x), end(x)\nusing namespace std;\nusing ll = long long;\nconstexpr ll Mod = 998244353;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\nconst double PI = acos(-1);\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) {\n    return a < b && (a = b, true);\n}\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) {\n    return a > b && (a = b, true);\n}\n/*-------------------------------------------*/\n\nint dp[309][309][309];\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    string s;\n    cin >> s;\n    int n = s.size(), k;\n    cin >> k;\n\n    rep(i, n) dp[i][i + 1][0] = 1;\n\n    for(int sz = 2; sz <= n; sz++)\n        for(int l = 0; l + sz <= n; l++) {\n            int r = l + sz;\n            rep(i, k + 1) {\n                if(s[l] == s[r - 1])\n                    chmax(dp[l][r][i], dp[l + 1][r - 1][i] + 2);\n                if(i) chmax(dp[l][r][i], dp[l + 1][r - 1][i - 1] + 2);\n                chmax(dp[l][r][i], dp[l + 1][r][i]);\n                chmax(dp[l][r][i], dp[l][r - 1][i]);\n            }\n        }\n\n    cout << *max_element(ALL(dp[0][n])) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\nstring s; int w;\nint mi[333][333][666];\nchar sa[333];\nint main()\n{\n\tcin>>s>>w; int ans=0,p=s.size();\n\tfor(int i=0;i<p;++i) sa[i+1]=s[i];\n\tmemset(mi,127/3,sizeof mi);\n\tfor(int i=1;i<=p;++i)\n\t\tmi[i][i-1][0]=0;\n\tfor(int i=p;i>=1;--i)\n\t{\n\t\tfor(int j=i;j<=p;++j)\n\t\t{\n\t\t\tfor(int k=0;k<=p*2;++k)\n\t\t\t{\n\t\t\t\tif(i==j&&k<=1)\n\t\t\t\t\tmi[i][j][k]=min(mi[i][j][k],0);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmi[i][j][k]=min(mi[i][j][k],mi[i][j-1][k]);\n\t\t\t\t\tmi[i][j][k]=min(mi[i][j][k],mi[i+1][j][k]);\n\t\t\t\t\tmi[i][j][k+2]=min(mi[i][j][k+2],mi[i+1][j-1][k]+(sa[i]!=sa[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int k=p*2;k>=0;--k)\n\t\tif(mi[1][p][k]<=w)\n\t\t{\n\t\t\tprintf(\"%d\\n\",k);\n\t\t\treturn 0;\n\t\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define sz(x) (int)(x.size())\n#define FOR(x,y,z) for(int x = y; x <= z; x++)\n#define int long long\n\nconst int N = 1e5 + 2, inf = 1e18;\n\nstring s, t;\nint n, k;\nint dp[302][302][302];\n\nint go(int l, int r, int rem){\n    if(rem < 0)\n        return -inf;\n    if(l >= r)\n        return l == r;\n\n    int &ans = dp[l][r][rem];\n    if(~ans) return ans;\n\n    ans = 0;\n    if(s[l] == s[r])\n        ans = max(ans, 2 + go(l + 1, r - 1, rem));\n    ans = max(ans, 2 + go(l + 1, r - 1, rem - 1));\n    ans = max({ans, go(l + 1, r, rem), go(l, r - 1, rem)});\n    return ans;\n\n}\n\nint32_t main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL); cout.tie(NULL);  \n\n    memset(dp, -1, sizeof(dp));\n    cin >> s >> k;\n    n = sz(s);\n    cout << go(0,n-1,k);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n    for(T& x: vec) {is >> x;} return is;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll k;\n    string s;\n    cin >> s >> k;\n    const ll n = s.size();\n\n    auto dp = make_v<ll>(n, n, k+1);\n    REP(i, n) REP(j, k+1) dp[i][i][j] = 1;\n    REP(l, n-1) {\n        ll r = l+1;\n        if(s[l]==s[r]) {\n            REP(i, k+1) dp[l][r][i] = 2;\n        }\n        else {\n            dp[l][r][0] = 1;\n            FOR(i, 1, k+1) dp[l][r][i] = 2;\n        }\n    }\n    REP(i, k+1) {\n        FOR(w, 3, n+1) {\n            REP(l, n-w+1) {\n                ll r = l+w-1;\n                if(s[l]!=s[r]) {\n                    if(i) dp[l][r][i] = max(dp[l][r][i-1], dp[l+1][r-1][i-1]+2);\n                    dp[l][r][i] = max({dp[l][r][i], dp[l+1][r][i], dp[l][r-1][i]});\n                } else if(s[l]==s[r]) {\n                    dp[l][r][i] = dp[l+1][r-1][i] + 2;\n                    if(i) chmax(dp[l][r][i], dp[l][r][i-1]);\n                }\n            }\n        }\n    }\n\n    // REP(i, n) {\n    //     FOR(j, i, n) {\n    //         cout << dp[i][j][0] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n\n    cout << dp[0][n-1][k] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\nconst LL MOD = 1000000007LL;\nint dp[300][301][301];\nint main() {\n\tstring S;\n\tcin >> S;\n\tint K;\n\tcin >> K;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tfor (int j = 0; j <= K; j++) dp[i][i + 1][j] = 1;\n\t}\n\tfor (int len = 2; len <= S.size(); len++) {\n\t\tfor (int i = 0; i + len <= S.size(); i++) {\n\t\t\tfor (int j = 0; j <= K; j++) {\n\t\t\t\tif (S[i] == S[i + len - 1]) {\n\t\t\t\t\tdp[i][i + len][j] = max(dp[i][i + len][j], dp[i + 1][i + len - 1][j] + 2);\n\t\t\t\t}\n\t\t\t\tdp[i][i + len][j] = max(dp[i][i + len][j], dp[i + 1][i + len][j]);\n\t\t\t\tdp[i][i + len][j] = max(dp[i][i + len][j], dp[i][i + len - 1][j]);\n\t\t\t\tif (j > 0) {\n\t\t\t\t\tdp[i][i + len][j] = max(dp[i][i + len][j], dp[i + 1][i + len - 1][j - 1] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= K; i++) ans = max(ans, dp[0][S.size()][i]);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nsolution:\n lps == lcs( s, s')\n\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n#define ull unsigned long long\n#define re register\n#define il inline\n#define inf 0x3f3f3f\n\nconst int maxn = 333;\n\nchar s[maxn];\nint f[maxn][maxn][maxn], k, n;\n\nint main() {\n  scanf(\"%s%d\", s + 1, &k);\n  n = strlen(s + 1);\n\n  for (int i = 1; i <= n; ++i)\n    f[i][i][0] = 1;\n\n  for (int l = 1; l <= n; ++l)\n    for (int i = 1; i + l <= n; ++i)\n      for (int p = 0, j = i + l; p <= k; ++p) {\n        f[i][j][p] = max(f[i + 1][j][p], f[i][j - 1][p]);\n\n        if (s[i] == s[j])\n          f[i][j][p] = max(f[i][j][p], f[i][j][p] + 2);\n\n        if (p)\n          f[i][j][p] = max(f[i][j][p], f[i][j][p - 1] + 2);\n      }\n\n  int ans = 0;\n  for (int i = 0; i <= k; i++)\n    ans = max(ans, f[1][n][i]);\n\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define P pair<int,int>\n#define len(s) (int)s.size()\n#define pb push_back\n\ntemplate<class T> inline bool chmin(T &a, T b){\n\tif(a>b){a=b;return true;}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T &a, T b){\n\tif(a<b){a=b;return true;}\n\treturn false;\n}\nconstexpr int mod = 1e9+7;\nconstexpr int inf = 3e18;\n\nstring S;\nint K;\nint dp[305][305][305];\nbool b[305][305][305];\nint f(int l,int r,int k){\n\tif(b[l][r][k])return dp[l][r][k];\n\tb[l][r][k]=1;\n\tif(r-l==1)return dp[l][r][k]=1;\n\tif(r-l==2){\n\t\tif(S[l]==S[l+1])return dp[l][r][k]=2;\n\t\treturn dp[l][r][k]=k?2:1;\n\t}\n\tdp[l][r][k]=1;\n\tchmax(dp[l][r][k],f(l,r-1,k));\n\tchmax(dp[l][r][k],f(l+1,r,k));\n\tif(S[l]==S[r-1])chmax(dp[l][r][k],f(l+1,r-1,k)+2);\n\telse if(k)chmax(dp[l][r][k],f(l+1,r-1,k-1)+2);\n\treturn dp[l][r][k];\n}\nsigned main(){\n\tcin>>S>>K;\n\tcout<<f(0,len(S),K)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#define Pr(f,...) //printf(f,##__VA_ARGS__),fflush(stdout)\n\ntypedef long long ll;\n\nconst int N=305;\n\nint qk,f[N][N][N],n;\nchar s[N];\n\nint dp(int l,int r,int k){\n\tif(l>r)return 0;\n\tif(l==r)return 1;\n\tif(f[l][r][k]!=-1)return f[l][r][k];\n\tint &res=f[l][r][k];\n\tres=0;\n\tif(s[l]==s[r])res=max(res,dp(l+1,r-1,k)+2);\n\tres=max(res,dp(l+1,r,k));\n\tres=max(res,dp(l,r-1,k));\n\tif(k)res=max(res,dp(l+1,r-1,k-1)+2);\n\tPr(\"f(%d,%d,%d)=%d\\n\",l,r,k,f[l][r][k]);\n\treturn res;\n}\n\nint main(int argc,char *argv[]){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tscanf(\"%d\",&qk);\n\tmemset(f,-1,sizeof(f));\n\tcout<<dp(1,n,qk)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                             UM.\n                            J@B@1                                                                    iO@1\n                           Y@@@B@BB.                                                              7B@B@B@\n                          :@B@i,B@B@O                                                          ,Z@B@B@B@Br\n                          @B@q   i@B@BS                                                      7@B@@@O5vMB@q\n                         8@@B      LB@B@i                                                  FB@@@BNjYjLE@B@\n                        ,B@B:        0@@@Z                                               P@B@BM1JJ125JPB@B\n                        B@BB          :@B@B                                            XB@B@Z2LuU52F2u2@B@.\n                       :@B@             @@@B:                                        v@B@B8uJj51F1525uUB@B7\n                       @B@O              0@@B.               ..::ir7vvYUuU777r::.   B@B@OULU2F2F151F11Y@B@S\n                       B@B,               8B@B  :ruXMB@B@B@B@B@B@B@B@B@B@@@B@B@B@B@B@B@5Jj1211F1F1F2FUJO@BB\n                      U@B@                 @B@B@B@B@B@@@B@B@B@MMqPS5JuYL7rq@B@OBB@B@B8Yu211F1515251515YGB@@\n                      @B@u                 v@@@@MSur:.                    LB@MvvjJuU5YU252F1F1F25251F2uX@@@\n                      @@@.                                                N@BML2U2UUU12F15252525251515Jk@@B\n                     r@B@                                                 YB@Bju52121252515252F15251F2u5@B@\n                     PB@B                                                  @@@PYUF151F25151F152F2F1F15jF@@B\n                     @@BS                                                  N@@@UJ2F25252F251525151F1F1u5@B@\n                     @@@7                                                   B@B@5Yj12F152F1F1F25252515jFB@B\n                     B@Bi                                                    M@B@O2Luu52525212F151121UY1@B@7\n                    O@B@:                                                     v@B@BMSuYJJuuUu2u2uujjYJJXB@B@M\n                  7B@B@,                                                        1B@@@B@GPF1uujuu21PNMB@B@B@B@@\n                 qB@B2                                                            i8B@B@B@B@B@@@@@B@B@B@q: @@@B\n                MB@B:                                                                 7SBB@B@B@B@B@Zu:      @B@B\n               ZB@B.                                              ,v.                                        @B@L\n              LB@B,                         Y7                    @B@Bu                                      7@B@\n   :B@B@@B2:  @@B7                         @B@Z                   r@B@B@BP:                                   B@BE\n    BB@@@B@B@B@BE                        r@B@B                       7@B@B@B@Ou:                              iB@B\n         :uM@@B@@2.           :7::::ivk@B@B@0                           :5B@B@B@B@B@B@G.                       @B@i\n            BB@@@B@@         :@B@B@@@B@B@@1                                 .i5M@B@B@@@5                       M@@2\n            B@B ,@B1          L0EZZG0F7:                                            .:,                        uB@MrP@M7\n           2@B@                                                                                               ,O@B@B@B@B\n           @B@1                                                     :@B@@@r                                :@@@@B@BL:,,\n           B@Bi                         :2ZS;                      :@B@B@B@r                               L@B@B@BU\n           @B@.                        @@@B@B@                     vB@B@B@B5                                   @B@i\n           B@B                        7B@B@B@BM                     OB@B@B@                                   ,B@B\n           @B@                         @B@B@@@i                       rL7.                                    B@BM\n           B@B7.:                       NB@@M.                                                               .@B@.\n  .;JEB@@@B@B@B@B@.                                                                                       .  @B@u\n@@@B@B@B@B@@@B@18U                                                                                      :B@B@B@BU,\n7@BOui.    ,@@B                                                                                          SP@B@B@B@B@Or\n            @@@U                                                                                           B@BJ.YO@B@B@i\n            r@B@                                                                                         :B@Bk     .k@B@\n             B@B@                                                                                       LB@@k         2i\n              B@BM                                      .7jXEGqF7:                                     OB@@L\n              .B@BM                                   .B@B@B@B@B@B@.                                 :@B@B:\n               .B@B@                                   @@MYr::ivG@B                                .M@B@G\n                 B@@@S                                                                           ,MB@B@,\n                  v@@@BF                                                                      .1B@B@Br\n                    2@@B@BL                                                                ,FB@@@B8,\n                      r@B@B@BF,                                                        :YBB@B@B@B\n                         L@B@B@B@P7,                                           .ivXB@B@B@B@B@M@B@\n                            ,1B@B@B@B@@@BOP2L7i:,.              ..,:i7LSNB@@B@B@@@B@B@B@Z5v;.LB@@\n                              @B@OEB@B@@@B@B@B@B@B@B@B@B@@@B@B@B@B@B@@@B@B@B@B@BM0SJ7i::::i:,u@B@\n                              B@Bu ::i;7vu2XNGOMB@B@BMB@B@B@B@B@B@@@B1UFuj77ii:::::::iir;r;i.YB@B\n                              @B@L.:i:i:i::::::::::..Y@B@BMYi:i;SB@B@N:.::i:iirir;r;rii::::ivO@B@\n                              B@@X::,::::iirir;riri:E@B@1         ,@B@Br:;;r;rii:i::::i7JEB@@@@@B\n                              @@@B@BBq5v7ii:::::::.2@@@i  ..,..     @B@@,,:::::irv2XMB@B@B@B@2@B@:\n                             .B@BBB@@@B@B@B@BMNP5u7@B@1 .,,:,,  :.   @B@P50MB@B@B@B@B@@@BS:   @@B1\n                             E@B@   ijGB@B@B@B@B@B@B@Bi .,:,,..@@B@7 B@B@B@B@B@B@BM57.        kB@B\n                            .@B@:          .,ivu5Nq@B@u  ..,.. SB@B@@@B@PL7i,                 ,@B@\n                            @@@8                   i@B@:    .     :B@B@@                       B@@2\n                          i@@@@                     0@B@u          B@@B.                       vB@B\n                         ,@B@G                       L@B@BOv:.:iFB@B@M                          @B@Bi\n                          vNi                          S@@B@B@B@B@BM:                            MB@N\n                                                          758BMqJ,\n\n                 .  YO.               vq                            :G       Z:\n        SqOMBB@B@Br @@r rBE           @B     B@@@@@B@ONX8k    i::::.OB1.:::.u@O.::::i           @B@B@U:@@B@@BPEBu\n        B@@NB@k.    5@i  uB@E.        BM     1U2uUJvirB@@Z   r@@B@B@@@B@B@B@B@B@@@B@Bi   LB@B@1 BX :@k uLLLvr@BJ:\n            iB      iBi    7@     .@M8@BGMZZ         @@F            ,B       Pi          v@  Bq @i v@        B@\n       vuL7r8@S7vJL7N@Z7LLri;72.   F7@Bvvv@@       @BX         @@@B@B@@@@@B@@@B@B@B      7@  @F Bi @q  @B@Bu @B\n       N@B@G@@@8@BBOMB@G@BMNXG@,     B@   @@      .Bk          .:u;    i@:      Zv       7@  Bk @,;@  ,BY @B B@\n            r@       @G     5.      ,@v   BZ :::,.r@E .::i,      @B     B@    .@BL       7@  @F B:i@. .@  @M @B\n            7B: ,vO, @@   iB@:      @B   7@:MB@B@B@@@B@B@BM       @@.    B:  2@q         7@  BS @i 0@  B. @O B@\n       ,r2EBB@B@B@Bi G@  @BB        B@   @B        @S              :    r@   ..          7B  @F @7  B7 @  @B @B\n       E@B@UOBr       @B@Bi          L@0PB        .BZ        .@B@B@B@B@B@B@B@B@B@B@B@,   r@  BF @i  @G B@B@B B@\n            7@,      kB@U    ;r        @@@.       .@Z                GBuL@iBBi           vB@B@q BP:5@7 @u,.  @B\n            LBi   YB@BrB@    @@       @B:L@Br      BM             .M@B  rB  rB@J         v@. Pi @XZ8r  .     B@\n        .   G@i B@BM.  ,B@,  @B    iB@B    N, 7r..q@k         ,LB@B8    J@,   i@B@B1r           Br           @@\n        MB@B@B  ,i       B@B@B,    B@:        @B@B@F         .@BB:      P@i      :OBZ          .@U       B@B@B:\n                          .ll                                           rB.                     :\n                                                                                    “我好菜啊”商标(2018) by Charlieyan\n*/\n/*****************\n *   I<3   C++   *\n *  IWANT ANYAC  *\n * ILOVEPROGRAM! *\n *IT'SINTERESTING*\n * ILOVEPROGRAM! *\n *  INCONTESTS   *\n *   GETSCORE    *\n *    ACCODE     *\n *     LETS      *\n *      GO       *\n *Written by:    *\n *    charlieyan *\n *****************/\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <locale>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cerrno>\n#include <clocale>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <limits>\n#include <map>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <istream>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <utility>\n#include <vector>\n#include <cwchar>\n#include <cwctype>\n#include <complex.h>\n#include <fenv.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <tgmath.h>\n#include <numeric>\n#include <list>\n#define LL long long\n#define pb push_back\n#define pob pop_back\n#define mp make_pair\n#define FILL(a,v) memset((void*)a,v,sizeof(a))\n#define FILL0(a) FILL(a,0)\n#define FILL1(a) FILL(a,-1)\n#define FILLBIG(a) FILL(a,0x7f)\n#define ALL(a) (a).begin(),(a).end()\n#define Inf ((int)0x7f7f7f7f)\n#define INF ((long long)0x7f7f7f7f7f7f7f7f)\n#define Mod 1000000007\n#define foreach(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define RFOR(i,x) for(int i=x-1;i>=0;i--)\n#define FFOR(i,a,b) for(int i=a;i<b;i++)\n#define FRFOR(i,a,b) for(int i=a-1;i>=b;i--)\n#define SZ(a) ((int)(a).size())\n#define FI first\n#define SE second\n#define OVER(a) return puts(a),0\n#define fastio ios::sync_with_stdio(0)\n#define filei(f) freopen(f,\"r\",stdin)\n#define fileo(f) freopen(f,\"w\",stdout)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define MASK(a) (1<<(a))\n#define MASKX(x,a) ((x)<<(a))\n#define BIT(a,b) ((a>>b)&1)\n#define cddx(a) priority_queue<a >\n#define cxdd(a) priority_queue<a,vector<a >,greater<a > >\n#define deval(a) {cerr<<#a<<\" = \"<<a<<endl;}\n#define dearr(be,en) {cerr<<#be;cerr<<\" = {\";for(auto i=be;i!=en;i++)cerr<<' '<<*i;cerr<<\" }\\n\";}\n#define reg register\n#define prtime eprintf(\"\\n\\nTime used: %dms\\n\",clock());\n#define PI 3.1415926535897932384626\n//Xuzhen[The virus] is a BIG 13 !!!\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef unsigned long long UINT;\ntypedef unsigned int uint;\ntypedef long long INT;\ntypedef long double ldouble;\ntypedef pair<INT,INT> PII;\ntypedef stringstream sst;\ntypedef istringstream iss;\ntypedef vector<int> vint;\ntypedef vector<INT> VINT;\ntypedef vector<pii> vpii;\ntypedef vector<PII> VPII;\ntypedef priority_queue<int> pqi;\ntypedef priority_queue<INT> PQI;\ntypedef priority_queue<pii> pqp;\ntypedef priority_queue<PII> PQP;\ntypedef priority_queue<int,vint,greater<int> > xqi;\ntypedef priority_queue<INT,VINT,greater<INT> > XQI;\ntypedef priority_queue<pii,vpii,greater<pii> > xqp;\ntypedef priority_queue<PII,VPII,greater<PII> > XQP;\n\nint k;\nstring s,t;\nint dp[2][307][307];\n\nint main()\n{\n    cin >> s;\n    cin >> k;\n    t = s;\n    int n = SZ(s);\n    reverse(t.begin(), t.end());\n    s = ' ' + s;\n    t = ' ' + t;\n    //Calculate LCS between s and t\n    int now = 0, lst = 1;\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++)\n        {\n            if(s[i]==t[j])\n                dp[now][i][j] = dp[now][i - 1][j - 1] + 1;\n            else\n                dp[now][i][j] = max(dp[now][i - 1][j], dp[now][i][j - 1]);\n        }\n    //Start changing\n    for (int ii = 0; ii < k; ii++)\n    {\n        swap(now, lst);//Round dp\n        FILL0(dp[now]);\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n            {\n                if(s[i]==t[j])\n                    dp[now][i][j] = dp[now][i - 1][j - 1] + 1;\n                else\n                    dp[now][i][j] = max(max(dp[now][i - 1][j], dp[now][i][j - 1]), dp[lst][i - 1][j - 1] + 1 /*Have a change*/);\n            }\n    }\n    //Duicheng\n    int ans = 0;\n    for (int i = 1; i <= n; i++)\n        ans = max(ans, 2 * dp[now][i][n - i]);\n    for (int i = 1; i <= n; i++)\n        ans = max(ans, 2 * dp[now][i][n - i - 1] + 1);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <utility>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#define my_abs(x) ((x) < 0 ? -(x) : (x))\n#define mp std::make_pair\n#define pb push_back\n#define X first\n#define Y second\ntypedef long long ll; \nchar str[305]; \nint dp[305][305][305], n; \nint calc(int l, int r, int k)\n{\n\tif (k < 0)\n\t\treturn -1e9; \n\tif (l >= n || r < 0)\n\t\treturn 0; \n\tif (~dp[l][r][k])\n\t\treturn dp[l][r][k]; \n\tint res = std::max(calc(l + 1, r, k), calc(l, r - 1, k)); \n\tif (str[l] == str[r])\n\t\tres = std::max(res, calc(l + 1, r - 1, k) + 1); \n\treturn dp[l][r][k] = std::max(res, calc(l + 1, r - 1, k - 1) + 2); \n}\nint main()\n{\n\t// freopen(\"AGC021-D.in\", \"r\", stdin); \n\tint k; \n\tscanf(\"%s%d\", str, &k); \n\tn = strlen(str); \n\tmemset(dp, -1, sizeof(dp)); \n\tprintf(\"%d\\n\", calc(0, n - 1, k));\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "/*\ndp[i][j][k] 前i个字符和后j个字符最多修改k个字符的最大长度\n\ndp[i][j][k] = max(\n                  dp[i-1][j][k],\n                  dp[i][j-1][k],\n                  if s[i] == s[n-1-j] : dp[i-1][j-1][k]+1\n                  else : dp[i-1][j-1][k-1] + 1)\n\nabcabcabc\ncbacbacba\n\n\n*/\n\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\nint n,m;\nchar s[305];\nint dp[305][305][305];\n\nint main(){\n    int i,j,k;\n    while(~scanf(\"%s%d\",s,&m)){\n        n = strlen(s);\n        dp[0][0][0] = s[0]==s[n-1]? 1 : 0;\n        for(i = 1;i <= m;i++){\n            dp[0][0][i] = 1;\n        }\n        for(i = 0;i < n;i++){\n            for(j = 0;j < n;j++){\n                if(i+j==0) continue;\n                for(k = 0;k <= m;k++){\n                    dp[i][j][k] = max(i>0?dp[i-1][j][k]:-1,j>0?dp[i][j-1][k]:-1);\n                    if(i > 0 && j > 0)\n                    if(s[i] == s[n-1-j]){\n                        dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+1);\n                    }else{\n                        dp[i][j][k]= max(dp[i][j][k],dp[i-1][j-1][k-1]+1);\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\",dp[n-1][n-1][m]+m);\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<stdexcept>\n#include<utility>\n#include<functional>\n#include<numeric>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<array>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<complex>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<bitset>\n#include<memory>\nusing namespace std;\nusing ll=long long;\n\nvoid cmax(int& lhs,int rhs){lhs=max(lhs,rhs);}\nint main(){\n    string s;\n    cin>>s;\n    int k;\n    cin>>k;\n    int half=s.size()/2;\n    \n    vector<vector<vector<int>>> dp(half+1,vector<vector<int>>(half+1,vector<int>(k+1)));\n    for(int i=0;i<=half;i++){\n        for(int j=0;j<=half;j++){\n            for(int l=0;l<=k;l++){\n                if(i<half){\n                    cmax(dp[i+1][j][l],dp[i][j][l]);\n                }\n                if(j<half){\n                    cmax(dp[i][j+1][l],dp[i][j][l]);\n                }\n                if(i<half &&j<half){\n                    if(s[i]!=s[s.size()-1-j] && l<k) cmax(dp[i+1][j+1][l+1],dp[i][j][l]+1);\n                    if(s[i]==s[s.size()-1-j]) cmax(dp[i+1][j+1][l],dp[i][j][l]+1);\n                }\n                if(l<k) cmax(dp[i][j][l+1],dp[i][j][l]);\n            }\n        }\n    }\n    \n\n    vector<vector<int>> posL(s.size()+1,vector<int>(26,-1));\n    for(int i=0;i<s.size();i++) posL[i+1]=posL[i],posL[i+1][s[i]-'a']=i;\n    vector<vector<int>> posR(s.size()+1,vector<int>(26,s.size()));\n    for(int i=s.size()-1;i<s.size();i--) posR[i]=posR[i+1],posR[i][s[i]-'a']=i;\n\n    vector<vector<vector<int>>> dp2(s.size()+1,vector<vector<int>>(s.size()+1,vector<int>(k+1)));\n    for(int i=0;i<s.size();i++) for(int j=0;j<=k;j++) dp2[i][i+1][j]=1;\n    for(int v=2;v<=s.size();v++){\n        for(int i=0;i<s.size();i++){\n        int j=i+v;\n        if(i+v>s.size()) continue;\n            for(int l=0;l<=k;l++){\n                if(i==6 && j==9){\n                    v=v*0+v+1;\n                    v=v-1;\n                }\n                if(l>0){\n                    cmax(dp2[i][j][l],dp2[i+1][j-1][l-1]+1);\n                    cmax(dp2[i][j][l],dp2[i][j][l-1]);\n                }\n                cmax(dp2[i][j][l],dp2[i+1][j][l]);\n                cmax(dp2[i][j][l],dp2[i][j-1][l]);\n                if(i+1<=posL[j][s[i]-'a']) cmax(dp2[i][j][l],dp2[i+1][posL[j][s[i]-'a']][l]+2);\n                if(posR[i][s[j-1]-'a']<=j-2) cmax(dp2[i][j][l],dp2[posR[i][s[j-1]-'a']+1][j-1][l]+2);\n            }\n        }\n    }\n\n    int res=2*(*max_element(dp[half][half].begin(),dp[half][half].end()))+(s.size()%2);\n    int tmp=s.size()%2;\n    for(int i=0;i<=half;i++){\n        for(int j=0;j<=half;j++){\n            for(int l=0;l<=k;l++){\n                cmax(res,dp[i][j][l]*2+dp2[i][half+tmp][k-l]);\n                cmax(res,dp[i][j][l]*2+dp2[half][s.size()-j][k-l]);\n                if(res==8){\n                    cerr<<\"#\"<<endl;\n                }\n            }\n        }\n    }\n    cout<<res<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <utility>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#define my_abs(x) ((x) < 0 ? -(x) : (x))\n#define mp std::make_pair\n#define pb push_back\n#define X first\n#define Y second\ntypedef long long ll; \n#define upd(x, y) (x) = std::max(x, y)\nchar str[305]; \nint dp[305][305]; \nint main()\n{\n\t// freopen(\"AGC021-D.in\", \"r\", stdin); \n\tscanf(\"%s\", str); \n\tint n = strlen(str), k; \n\tscanf(\"%d\", &k); \n\tmemset(dp, -0x3f, sizeof(dp)); \n\tdp[0][n] = 0; \n\tfor (int i = 0; i <= n; i++)\n\t{\n\t\tfor (int j = n; j; j--)\n\t\t{\n\t\t\tif (str[i] == str[j - 1])\n\t\t\t\tupd(dp[i + 1][j - 1], dp[i][j] + 1); \n\t\t\tupd(dp[i + 1][j], dp[i][j]); \n\t\t\tupd(dp[i][j - 1], dp[i][j]); \n\t\t}\n\t}\n\tprintf(\"%d\\n\", std::min(dp[n][0] + k * 2, n));\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "//Be Name Khoda\n/*\ntane ezafami sharifast be jane ezafamiat\nna hamin lebase zibast neshane ezafamiat\nagar ezafami be cheshmasto dahano goosho bini\nche miane naghshe divaro miane ezafamiat\nkhoro khabo khashmo shahvat shaghab asto jahlo zolmat\nhayavan khabar nezafarezaf ze jahane ezafamiat\nbe haghighat ezafami bash vagarna morgh bashezaf\nke hami sokhan begooyezaf be zabane ezafamiat\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\ntemplate <typename T> using ordered_set =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \ntypedef long long LL;\ntypedef LL ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vll;\ntypedef stringstream strs;\n \n \n#define X first\n#define Y second\n#define PB push_back\n#define For(i,a,b) for (int i=a;i<b;i++)\n#define Ford(i,a,b) for (int i=a;i>=b;i--)\n#define smax(a,b) a=max(a,b)\n#define smin(a,b) a=min(a,b)\n#define SZ(a) ((ll)a.size())\n#define ER(a) cout << #a << ' ' << a << endl\n#define LB(a,n,x) (lower_bound(a,(a)+(n),x)-(a))\n#define RET(x) { cout << x; exit(0); }\n#define MKP make_pair\n#define RETD(x) { cout << fixed << setprecision(15) << x; }\n#define GEI(x) scanf(\"%d\",&x)\n#define GEL(x) scanf(\"%lld\",&x)\n#define ALL(x) x.begin(),x.end()\nconst ll M=300+10,LG=26,SM=105,inf=1e9+5;\nll mod=1e9+7;\n\nstr s;\nll k;\nll dp[M][M],dp2[M][M];\n\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin >> s >> k;\n    ll n=SZ(s);\n    str t=s;\n    reverse(ALL(t));\n    {\n        For(i,1,n+1) For(j,1,n+1)\n        {\n            smax(dp[i][j],max(dp[i][j-1],dp[i-1][j]));\n            if (s[i-1]==t[j-1])\n                smax(dp[i][j],dp[i-1][j-1]+1);\n        }\n        //atcodergr\n        //tsetnocdn\n    }\n    RET(min(dp[n][n]+2*k,n));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define dro first\n#define adg second.first\n#define mog second.second\n#define ll long long\nusing namespace std;\n\nconst int N = 500001;\n\nint n,r,pos,l,x,U,D,S;\n \nlong long ans;\nint K;\n\nstring s;\n\nint fix[100],fix1[100],A[100],B[100];\n\nint dp[501][501][501];\n\nint main(){\n    \n    cin>>s;\n    \n    n=s.size();\n    \n    cin>>K;\n    \n    for(int j=0;j<n;j++)\n    for(int l=0;l+j<n;l++)\n    for(int k=0;k<=min(l+j-l+1,K);k++){\n        \n        int r = l+j;\n        \n        if(l==r){\n            dp[l][r][0] = 1;\n            continue;\n            //dp[l][r][1] = 1\n        }\n\n        if(l+1==r){\n            if(k==0){\n                dp[l][r][k] = 1;\n                if(s[l] == s[r]) dp[l][r][k] = 2;\n            } else {\n                dp[l][r][k] = 2;\n            }\n            \n            continue;\n        }\n        \n        dp[l][r][k] = max( dp[l+1][r][k], dp[l][r-1][k]);\n        //cout<<dp[l+1][r][k]<<\" \"<<l<<\" \"<<r<<\" \"<<k<<endl;\n        //cout<<dp[l][r-1][k]<<\" \"<<l<<\" \"<<r<<\" \"<<k<<endl;\n        if(s[l]==s[r])\n            dp[l][r][k] = max( dp[l][r][k], dp[l+1][r-1][k] + 2);\n        else {\n            if(k-1>=0)\n            dp[l][r][k] = max( dp[l][r][k], dp[l+1][r-1][k-1] + 2);\n        }\n\n        //cout<<dp[l][r][k]<<\" \"<<l<<\" \"<<r<<\" \"<<k<<endl;\n    }\n    \n    cout<<dp[0][n-1][K]<<endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\nistream&operator>>(istream&s,_Bit_reference b){int a;s>>a;assert(a==0||a==1);b=a;return s;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}T get(int i){return S[i+B];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\nclass LCA{vvi par;vi dep;public:LCA(vvi&E,int root):par(MSB(E.size())+1,vi(E.size())),dep(E.size()){function<void(int,int)>dfs=[&](int i,int p){for(int j:E[i])if(j!=p){par[0][j]=i;dep[j]=dep[i]+1;dfs(j,i);}};par[0][root]=root;dfs(root,root);fr(i,par.size()-1){fr(j,par[0].size()){par[i+1][j]=par[i][par[i][j]];}}}int operator()(int a,int b){if(dep[a]>dep[b])swap(a,b);for(int t=dep[b]-dep[a],i=0;t;t>>=1,++i){if(t&1){b=par[i][b];}}if(a==b)return a;rf(i,par.size()){if(par[i][a]!=par[i][b]){a=par[i][a];b=par[i][b];}}return par[0][a];}};\nvpli factor(ll N){vpli r;for(ll i=2;i*i<=N;++i){if(N%i==0){r<<pli{i,0};while(N%i==0){N/=i;++r.back().second;}}}if(N>1){r<<pli{N,1};}return r;}\nvl divisors(ll n){vl r;ll m=sqrt(n);foor(i,1,m)if(n%i==0)r<<ll(i);rf(i,r.size()-(m*m==n))r<<n/r[i];return r;}\nvi SuffixArray(str S){int N=S.size();vi rank(N+1),tmp(N+1),sa(N+1);fr(i,N){sa[i]=i;rank[i]=S[i];}sa[N]=N;rank[N]=-1;int k;auto cmp=[&](int&a,int&b)->bool{if(rank[a]!=rank[b])return rank[a]<rank[b];return (a+k<=N?rank[a+k]:-1)<(b+k<=N?rank[b+k]:-1);};for(k=1;k<=N;k*=2){sort(all(sa),cmp);tmp[sa[0]]=0;foor(i,1,N){tmp[sa[i]]=tmp[sa[i-1]]+cmp(sa[i-1],sa[i]);}rank=tmp;}return sa;};\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tstr S;cin>>S;\n\tint N=S.size();\n\tint K;cin>>K;\n\tvector<vvi>d(K+1,vvi(N+1,vi(N)));\n\tint z=0;\n\tfoor(k,0,K){\n\t\tfr(i,N){\n\t\t\tfr(j,N){\n\t\t\t\tif(i+j==N-1){\n\t\t\t\t\tchmax(z,1+2*d[k][i][j]);\n\t\t\t\t}elsif(i+j==N){\n\t\t\t\t\tchmax(z,2*d[k][i][j]);\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tchmax(d[k][i+1][j],d[k][i][j]);\n\t\t\t\t\tchmax(d[k][i][j+1],d[k][i][j]);\n\t\t\t\t\tif(S[i]==S[N+~j]){\n\t\t\t\t\t\tchmax(d[k][i+1][j+1],d[k][i][j]+1);\n\t\t\t\t\t}elsif(k+1<=K){\n\t\t\t\t\t\tchmax(d[k+1][i+1][j+1],d[k][i][j]+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprint(z);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\n//const int mod = ;\n\nint d[305][305][305];\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  string s;\n  int k;\n  cin >> s >> k;\n  int n = s.size();\n  for (int i = 0; i < n; ++i) {\n    d[i][i][0] = 1;\n  }\n  for (int l = 2; l <= n; ++l) {\n    for (int i = 0; i + l <= n; ++i) {\n      int j = i + l - 1;\n      for (int t = 0; t <= k; ++t) {\n        d[i][j][t] = max(d[i+1][j][t], d[i][j-1][t]);\n        if (s[i] == s[j]) d[i][j][t] = max(d[i][j][t], d[i+1][j-1][t] + 2);\n        if (t) {\n          d[i][j][t] = max(max(d[i][j][t], d[i+1][j-1][t-1] + 2), d[i][j][t-1]);\n        }\n      }\n    }\n  }\n  cout << d[0][n-1][k] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid chmax(int &a, const int b) { if (a < b) a = b; }\n\nstring S;\nint N, K;\n\nint dp[303][303][303];\nbool visited[303][303][303];\n\nint rec(int l, int r, int k) {\n    if (l == N or r == -1) return 0;\n    if (visited[l][r][k]) return dp[l][r][k];\n    visited[l][r][k] = true;\n    int ret = 0;\n    chmax(ret, rec(l + 1, r, k));\n    chmax(ret, rec(l, r - 1, k));\n    if (S[l] == S[r]) chmax(ret, rec(l + 1, r - 1, k) + 1);\n    else if (k) chmax(ret, rec(l + 1, r - 1, k - 1) + 2);\n    return dp[l][r][k] = ret;\n}\n\nsigned main() {\n\n    cin >> S >> K;\n    N = S.size();\n    cout << rec(0, N - 1, K) << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Maxn 307\nusing namespace std;\nchar s[Maxn];\nint n,k;\nint f[Maxn][Maxn][Maxn];\nint calc(int x,int y)\n{\n\tif (s[x]==s[y]) return 0;\n\treturn 1;\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tscanf(\"%d\",&k);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=0;j<=k;j++)\n\t\t\tf[i][i][j]=1;\n\tfor (int del=1;del<n;del++)\n\t\tfor (int i=1;i+del<=n;i++)\n\t\t{\n\t\t\tint j=i+del;\n\t\t\tfor (int r=0;r<=k;r++)\n\t\t\t{\n\t\t\t\tf[i][j][r]=max(f[i+1][j][r],f[i][j-1][r]);\n\t\t\t\tint t=calc(i,j);\n\t\t\t\tif (r>=t) \n\t\t\t\t{\n\t\t\t\t\tif (i+1>j-1) f[i][j][r]=max(2,f[i][j][r]);\n\t\t\t\t\telse f[i][j][r]=max(f[i][j][r],f[i+1][j-1][r-t]+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\",f[1][n][k]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<cctype>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<cstdlib>\n#include<ctime>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<fstream>\n#define ld double\n#define ull unsigned long long\n#define ll long long\n#define pii pair<int,int >\n#define iiii pair<int,pii >\n#define mp make_pair\n#define INF 1000000000\n#define MOD 1000000007\n#define rep(i,x) for(int (i)=0;(i)<(x);(i)++)\ninline int getint(){\n    int x=0,p=1;char c=getchar();\n    while (c<=32)c=getchar();\n    if(c==45)p=-p,c=getchar();\n    while (c>32)x=x*10+c-48,c=getchar();\n    return x*p;\n}\nusing namespace std;\n//ruogu\nconst int N=310;\nint n,k,dp[N][N][N];\nchar s[N];\n//\nint go(int l,int r,int x){\n\tif(x<0)return 0;\n\tif(x>r-l+1)return -INF;\n\tif(l>r)return 0;\n\tif(l==r)return 1;\n\tif(dp[l][r][x]!=-1)return dp[l][r][x];\n\tint ans=max(go(l+1,r,x),go(l,r-1,x));\n\tif(s[l]==s[r])ans=max(ans,go(l+1,r-1,x)+2);\n\tif(x>0)ans=max(ans,go(l+1,r-1,x-1)+2);\n\treturn dp[l][r][x]=ans;\n}\nint main(){\n\tmemset(dp,-1,sizeof(dp));\n\tscanf(\"%s\",s);\n\tn=strlen(s);\n\tscanf(\"%d\",&k);\n\tprintf(\"%d\\n\",go(0,n-1,k));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    string s;\n    int change;\n    cin >> s >> change;\n    int n = s.size();\n\n    string t;\n    for (int i = n - 1; i >= 0; i--)t += s[i];\n\n    vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(n + 1, vector<int>(change + 1, -114514)));\n    for (int i = 0; i <= n; i++) {\n        for (int k = 0; k <= change; k++) {\n            dp[i][0][k] = 0;\n            dp[0][i][k] = 0;\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            for (int k = 0; k <= change; k++) {\n                if (s[i - 1] == t[j - 1])dp[i][j][k] = dp[i - 1][j - 1][k] + 1;\n                else dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k]);\n\n                if (k > 0) {\n                    dp[i][j][k] = max(dp[i][j][k], dp[i][j][k - 1]);\n                    if (s[i - 1] != t[j - 1]) {\n                        dp[i][j][k] = max({dp[i][j][k],\n                                           dp[i - 1][j][k - 1] + 1,\n                                           dp[i][j - 1][k - 1] + 1});\n                    }\n                }\n            }\n        }\n    }\n\n    cout << dp[n][n][change] + change << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...)\n#endif\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    string s;\n    int k;\n    cin >> s >> k;\n    int n = s.size();\n    vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(k + 1)));\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i; j <= n - 1; j++) {\n            for (int l = 0; l <= k; l++) {\n                if (i == j) {\n                    dp[i][j][l] = 1;\n                } else if (i + 1 == j) {\n                    dp[i][j][l] = 2;\n                    if (l == 0 && s[i] != s[j]) {\n                        dp[i][j][l] = 1;\n                    }\n                } else {\n                    dp[i][j][l] = max(dp[i + 1][j][l], dp[i][j - 1][l]);\n                    // dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l] + 1);\n                    if (s[i] == s[j]) {\n                        dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l] + 2);\n                    } else if (l != 0) {\n                        dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l - 1] + 2);\n                    }\n                }\n            }\n        }\n    }\n    cout << dp[0][n - 1][k] << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint dp[301][301][301];\nstring s;\nint K;\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> s >> K;\n    F0Rd(i,sz(s)) F0Rd(j,sz(s)) if (i+j < sz(s)) F0Rd(k,K+1) {\n        dp[i][j][k] = max(dp[i+1][j][k],dp[i][j+1][k]);\n        if (s[i] == s[sz(s)-1-j]) {\n            if (i == sz(s)-1-j) dp[i][j][k] = max(dp[i][j][k],dp[i+1][j+1][k]+1);\n            else dp[i][j][k] = max(dp[i][j][k],dp[i+1][j+1][k]+2);\n        }\n        else if (k < K) dp[i][j][k] = max(dp[i][j][k],dp[i+1][j+1][k+1]+2);\n    }\n    cout << dp[0][0][0];\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?) ARRAY OUT OF BOUNDSS"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int N = 310;\nint dp[N][N][N];\n\nint main() {\n    string s;\n    int k;\n    cin >> s >> k;\n    int n = s.length();\n\n    string t = s;\n    reverse(ALL(t));\n\n    REP(i,n+1) REP(j,n+1) REP(x,k+1){\n        dp[i+1][j][x] = max(dp[i+1][j][x], dp[i][j][x]);\n        dp[i][j+1][x] = max(dp[i][j+1][x], dp[i][j][x]);\n        if (i < n && j < n && s[i] == t[j]) dp[i+1][j+1][x] = max(dp[i+1][j+1][x], dp[i][j][x] + 1);\n        dp[i+1][j+1][x+1] = max(dp[i+1][j+1][x+1], dp[i][j][x] + 1);\n    }\n\n    int ans = 0;\n    REP(i,n+1){\n        ans = max(ans, 2 * dp[i][n-i][k]);\n    }\n    REP(i,n){\n        ans = max(ans, 2 * dp[i][n-1-i][k] + 1);\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\ntypedef long long ll;\ninline void Fail(){printf(\"0\");exit(0);}\n\nconst int maxn=305;\nint n,lim,ans;\nchar c[maxn];\nstring s;\nint dp[maxn][maxn][maxn];\n\nint main(){\n\tscanf(\"%s%d\",c,&lim);\n\ts=c;n=s.size();\n\tREP(len,n)rep(i,n)rep(k,lim+1){\n\t\tint j=i+len-1;\n\t\tif(j>=n)break;\n\t\tif(s[i]==s[j])dp[i][j][k]=(len>=3?dp[i+1][j-1][k]:0)+(i==j?1:2);\n\t\tif(i<n-1)dp[i][j][k]=max(dp[i][j][k],dp[i+1][j][k]);\n\t\tif(j-1>0)dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k]);\n\t\tif(s[i]!=s[j]&&k)\n\t\tdp[i][j][k]=max(dp[i][j][k],(len>=3?dp[i+1][j-1][k-1]:0)+2);\n\t\tans=max(ans,dp[i][j][k]);\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[305][305][305];\n\nint main(){\n  \n  string s;\n  int K;\n  \n  cin>>s>>K;\n  \n  memset(dp,-1,sizeof(dp));\n\n  s='x'+s;\n  \n  int len=s.size();\n  \n  dp[1][len][0]=0;\n  \n  for(int l=1;l<len;l++)\n    \n    for(int r=len-1;r>=l;r--){\n      \n      for(int k=0;k<=K;k++){\n\t\n\tif(dp[l][r][k]==-1) continue;\n\t\n\tif(s[l]==s[r]){\n\t  if(l==r) dp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]+1);\n\t  else dp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]+2);\n\t}\n\t\n\tif(l==r) continue;\n\t\n\tdp[l+1][r-1][k+1]=max(dp[l+1][r-1][k+1], dp[l][r][k]+2);\n\tdp[l+1][r][k]=max(dp[l+1][r][k], dp[l][r][k]);\n\tdp[l][r-1][k]=max(dp[l][r-1][k], dp[l][r][k]);\n\tdp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]);\n      }\n    }\n  \n  int ans=0;\n  \n  for(int i=0;i<len;i++)\n    for(int j=0;j<len;j++)\n      for(int k=0;k<=K;k++) ans=max(ans, dp[i][j][k]);\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//header\n#ifdef LOCAL\n    #include \"cxx-prettyprint-master/prettyprint.hpp\"\n    #define debug(x) cout << x << endl\n#else\n    #define debug(...) 42\n#endif\n    #pragma GCC optimize(\"Ofast\")\n    #include <bits/stdc++.h>\n    //types\n    using namespace std;\n    using ll = long long;\n    typedef pair < ll , ll >Pl;\n    typedef pair < int, int >Pi;\n    typedef vector<ll> vl;\n    typedef vector<int> vi;\n    template< typename T >\n    using mat = vector< vector< T > >;\n    template <std::uint_fast64_t Modulus> class modint {\n\n        using u64 = std::uint_fast64_t;\n\n        public:\n        u64 a;\n\n        constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n        constexpr u64 &value() noexcept { return a; }\n        constexpr const u64 &value() const noexcept { return a; }\n        constexpr modint operator+(const modint rhs) const noexcept {\n            return modint(*this) += rhs;\n        }\n        constexpr modint operator-(const modint rhs) const noexcept {\n            return modint(*this) -= rhs;\n        }\n        constexpr modint operator*(const modint rhs) const noexcept {\n            return modint(*this) *= rhs;\n        }\n        constexpr modint operator/(const modint rhs) const noexcept {\n            return modint(*this) /= rhs;\n        }\n        constexpr modint &operator+=(const modint rhs) noexcept {\n            a += rhs.a;\n            if (a >= Modulus) {\n            a -= Modulus;\n            }\n            return *this;\n        }\n        constexpr modint &operator-=(const modint rhs) noexcept {\n            if (a < rhs.a) {\n            a += Modulus;\n            }\n            a -= rhs.a;\n            return *this;\n        }\n        constexpr modint &operator*=(const modint rhs) noexcept {\n            a = a * rhs.a % Modulus;\n            return *this;\n        }\n        constexpr modint &operator/=(modint rhs) noexcept {\n            u64 exp = Modulus - 2;\n            while (exp) {\n            if (exp % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            exp /= 2;\n            }\n            return *this;\n        }\n        };\n    \n    \n    \n    \n    \n    //abreviations\n    #define all(x) (x).begin(), (x).end()\n    #define rall(x) (x).rbegin(), (x).rend()\n    #define rep2(i,a,b) for(int i=(a);i<(b);++i)\n    #define rep(i,n) for(int i=0;i<(n);++i)\n    #define rev(i,n) for(int i=n-1;i>=0;i--)\n    #define SZ(x) ((ll)(x).size())\n    #define pb(x) push_back(x)\n    #define eb(x) emplace_back(x)\n    #define ff first\n    #define ss second\n    #define mp make_pair\n    #define print(x) cout << x << endl\n    //functions\n    ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\n    template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\n    template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n    template< typename T >\n    T mypow(T x, ll n) {\n        T ret = 1;\n        while(n > 0) {\n            if(n & 1) (ret *= x);\n            (x *= x);\n            n >>= 1;\n        }\n        return ret;\n    }\n    uint64_t my_rand(void) {\n        static uint64_t x = 88172645463325252ULL;\n        x = x ^ (x << 13); x = x ^ (x >> 7);\n        return x = x ^ (x << 17);\n    }\n    //graph template\n    template< typename T >\n    struct edge {\n        int src, to;\n        T cost;\n\n        edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n        edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n        edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n\n    operator int() const { return to; }\n    };\n\n    template< typename T >\n    using Edges = vector< edge< T > >;\n    template< typename T >\n    using WeightedGraph = vector< Edges< T > >;\n    using UnWeightedGraph = vector< vector< int > >;\n\n//constant\n#define INF 10000000000LL\n#define mod 1000000007LL\n//typedef modint<mod> mint;\n#define eps 0.000001\n//library\nint memo[305][305][305];\nstring s;\nint k;\nint n;\nint rec(int i, int j, int l){\n    if(l<0)return -1;\n    if(i<0||j<0)return 0;\n    if(memo[i][j][l] >= 0)return memo[i][j][l];\n    int res = -1;\n    if(s[i] == s[n-1-j]){\n        chmax(res, rec(i-1, j-1, l)+1);\n    }\n    chmax(res, rec(i-1, j-1, l-1)+1);\n    chmax(res, rec(i-1, j, l));\n    chmax(res, rec(i, j-1, l));\n    memo[i][j][l] = res;\n    return res;\n}\n//main\nint main(){\n    rep(i, 305)rep(j, 305)rep(l, 305){\n        memo[i][j][l] = -1;\n    }\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin>>s;\n    cin>>k;\n    n = SZ(s);\n    int ans = 0;\n    rep(i, n){\n        chmax(ans, rec(i, n-2-i, k)*2);\n    }\n    rep(i, n){\n        chmax(ans, rec(i-1, n-2-i, k)*2+1);\n    }\n    print(ans);\n    return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nchar a[321];\nint n, K;\nint d[321][321][321];\nbool v[321][321][321];\nint dfs(int s, int len, int edits)\n{\n\tif (len == 0) return 0;\n\tif (len == 1) return 1;\n\tif (v[s][len][edits]) return d[s][len][edits];\n\tint e = s + len - 1;\n\tif (a[s] == a[e]) return dfs(s + 1, len - 2, edits) + 2;\n\tint ret = max(dfs(s, len - 1, edits), dfs(s + 1, len - 1, edits));\n\tif (edits < K)\n\t\tret = max(ret, dfs(s + 1, len - 2, edits + 1) + 2);\n\tv[s][len][edits] = true;\n\treturn d[s][len][edits] = ret;\n}\nint main()\n{\n\tscanf(\"%s%d\", &a[1], &K);\n\tn = strlen(&a[1]);\n\tprintf(\"%d\\n\", dfs(1, n, 0));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define R freopen(\"A.in\",\"r\",stdin);\n#define W freopen(\"A.out\",\"w\",stdout);\nconst int N=305;\nchar s[N];\nint k,d[N][N][N],n;\nint dp(int i,int j,int x)\n{\n    if(i==j)return 1;\n    if(i>j)return 0;\n    int& ans=d[i][j][x];\n    if(ans!=-1)return ans;\n    if(s[i]==s[j])ans=dp(i+1,j-1,x)+2;\n    else if(x)ans=max(max(dp(i,j-1,x),dp(i+1,j,x)),dp(i+1,j-1,x-1)+2);\n         else ans=max(dp(i,j-1,x),dp(i+1,j,x));\n    return ans;\n}\nint main()\n{\n    \n    memset(d,-1,sizeof d);\n    scanf(\"%s%d\",s,&k);\n    n=strlen(s);\n    cout<<dp(0,n-1,k);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define P(x) {if (debug) cout << x << endl;}\n#define H(x) P(#x << \": \" << (x))\n#define FR(i,a,b) for (int i=(a); i<(b); i++)\n#define F(i,n) FR(i,0,n)\n#define D(i,n) for (int i=(n); i-->0;)\n#define S(s) (int)(s).size()\n#define ALL(v) v.begin(), v.end()\n#define MI(a,v) a = min(a,v)\n#define MA(a,v) a = max(a,v)\n#define V vector\n#define pb push_back\n#define mt make_tuple\nusing namespace std;\ntemplate<class T> ostream& operator<<(ostream& os, V<T> v) {\n    F(i,S(v)) os<<(i?\" \":\"\")<<v[i]; return os;}\nconst bool debug = 1;\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    string s,t; cin>>s;\n    t = s; reverse(ALL(t));\n    int n = S(s);\n    int k; cin>>k;\n    V<V<V<int>>> lcs(n+1, V<V<int>>(n+1, V<int>(k+1, 0)));\n    F(i,n+1) F(j,n+1) F(kk,k+1) {\n        if (j < n) MA(lcs[i][j+1][kk], lcs[i][j][kk]);\n        if (i < n) MA(lcs[i+1][j][kk], lcs[i][j][kk]);\n        if (kk < k) MA(lcs[i][j][kk+1], lcs[i][j][kk]);\n        if (i < n && j < n) {\n            if (s[i] == t[j])\n                MA(lcs[i+1][j+1][kk], lcs[i][j][kk] + 1);\n            else if (kk < k)\n                MA(lcs[i+1][j+1][kk+1], lcs[i][j][kk] + 1);\n        }\n    }\n    int ma=0;\n    F(i,n+1) {\n        // without center\n        MA(ma, 2*lcs[i][n-i][k]);\n        if (i<n) {\n            MA(ma, 2*lcs[i][n-1-i][k] + 1);\n        }\n    }\n    cout << ma << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\tstring s; cin >> s;\n\tint n = s.size();\n\tint K; cin >> K;\n\tvector<vector<vector<int> > > dp(n, vector<vector<int> >(n, vector<int>(K+1, 0)));\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int k = 0; k < K+1; ++k) {\n\t\t\tdp[i][i][k] = 1;\n\t\t\tif (i < n-1 and s[i] == s[i+1]) dp[i][i+1][k] = 2;\n\t\t}\n\t}\n\tfor (int k = 0; k < K+1; ++k) {\n\t\tfor (int x = 1; x < n; ++x) {\n\t\t\tfor (int i = 0; i < n-x; ++i) {\n\t\t\t\tint j = i+x;\n\t\t\t\tif (k > 0) dp[i][j][k] = dp[i][j][k-1];\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i+1][j][k]);\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k]);\n\t\t\t\tif (s[i] == s[j] && x > 1) dp[i][j][k] = max(dp[i][j][k], dp[i+1][j-1][k] + 2);\n\t\t\t\telse if (k > 0 && x > 1) dp[i][j][k] = max(dp[i][j][k], dp[i+1][j-1][k-1] + 2);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][n-1][K] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n\nstring s;\nint dp[303][303][303];\n\nint solve(int a, int b, int k) {\n\tif(dp[a][b][k] < 0) {\n\t\tdp[a][b][k] = 0;\n\t\tif(a > 0) {\n\t\t\tdp[a][b][k] = max(dp[a][b][k], solve(a - 1, b, k));\n\t\t}\n\t\tif(b > 0) {\n\t\t\tdp[a][b][k] = max(dp[a][b][k], solve(a, b - 1, k));\n\t\t}\n\t\tif(a > 0 && b > 0) {\n\t\t\tif(s[a - 1] == s[s.size() - b]) {\n\t\t\t\tdp[a][b][k] = max(dp[a][b][k], solve(a - 1, b - 1, k) + 1);\n\t\t\t}\n\t\t\tif(k > 0) {\n\t\t\t\tdp[a][b][k] = max(dp[a][b][k], solve(a - 1, b - 1, k - 1) + 1);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[a][b][k];\n}\n\nsigned main() {\n\tcin >> s;\n\tint k;\n\tcin >> k;\n\trep(i, s.size() + 2) {\n\t\trep(j, s.size() + 2) {\n\t\t\trep(k, s.size() + 2) {\n\t\t\t\tdp[i][j][k] = -1;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 1;\n\trep(i, s.size()) {\n\t\tans = max(ans, solve(i, s.size() - i, k) * 2);\n\t}\n\trep(i, s.size() - 1) {\n\t\tans = max(ans, solve(i, s.size() - i - 1, k) * 2 + 1);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int N = 3e2+5;\nint n, m, f[N][N][N], ans; char s[N];\nint main()\n{\n    scanf(\"%s\", s+1), n = strlen(s+1), m = read();\n    for(int k = 0; k <= m; ++k)\n        for(int l = 3; l <= n; ++l)\n            for(int i = 1, j = l; j <= n; ++i, ++j)\n            {\n                f[k][i][j] = max(max(f[k][i+1][j], f[k][i][j-1]), f[k][i+1][j-1]+(s[i] == s[j]));\n                if(k) f[k][i][j] = max(f[k][i][j], f[k-1][i+1][j-1]+1);\n                ans = max(ans, f[k][i][j]*2+1);\n            }\n    for(int k = 0; k <= m; ++k)\n        for(int l = 2; l <= n; ++l)\n            for(int i = 1, j = l; j <= n; ++i, ++j)\n            {\n                f[k][i][j] = max(max(f[k][i+1][j], f[k][i][j-1]), f[k][i+1][j-1]+(s[i] == s[j]));\n                if(k) f[k][i][j] = max(f[k][i][j], f[k-1][i+1][j-1]+1);\n                ans = max(ans, f[k][i][j]*2);\n            }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int maxn = 300;\n\ninline void Max(int &a, int b) {\n  a = b > a ? b : a;\n}\n\nint n, m;\nchar s[maxn + 1];\nint dp[maxn + 1][maxn + 1][maxn + 1];\n\nint main(void) {\n  scanf(\"%s%d\", s, &m);\n  n = strlen(s);\n  for (int k = 0; k <= m; ++k) {\n    for (int l = 0; l <= n; ++l) {\n      for (int r = n; r >= l; --r) {\n        if (l > 0) {\n          Max(dp[l][r][k], dp[l - 1][r][k]);\n        }\n        if (r < n) {\n          Max(dp[l][r][k], dp[l][r + 1][k]);\n        }\n        if (l > 0 && r < n) {\n          int cost = !(s[l - 1] == s[r]);\n          if (k >= cost) {\n            Max(dp[l][r][k], dp[l - 1][r + 1][k - cost] + 1);\n          }\n        }\n      }\n    }\n  }\n  int ans = 0;\n  for (int mid = 0; mid < n; ++mid) {\n    Max(ans, dp[mid][mid + 1][m] * 2 + 1);\n    Max(ans, dp[mid][mid][m] * 2);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define vi vector<int>\n#define vvi vector<vi>\n#define vs vector<string>\n#define pb push_back\n#define P pair<int,int>\n#define vp vector<P>\n#define PP pair<int,P>\n#define vpp vector<PP>\n#define fi first\n#define se second\n#define INF 1e9\n#define MOD 1000000007\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REPR(i,n) for(int i=n;i>=0;i--)\n#define FOR(i,m,n) for(int i=m;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nint dp[300][300][301];\nstring st;\nint dfs(int l,int r,int x){\n    if(r<l){\n        return 0;\n    }\n    if(l==r){\n        return 1;\n    }\n    if(dp[l][r][x]!=-1){\n        return dp[l][r][x];\n    }\n    int res=max(dfs(l+1,r,x),dfs(l,r-1,x));\n    if(st[l]==st[r]){\n        res=max(res,dfs(l+1,r-1,x)+2);\n    }\n    if(x)res=max(res,dfs(l+1,r-1,x-1)+2);\n    return dp[l][r][x]=res;\n}\nint main(){\n    cin>>st;\n    int k;\n    cin>>k;\n    REP(i,300){\n        REP(j,300){\n            REP(k,300){\n                dp[i][j][k]=-1;\n            }\n        }\n    }\n    cout<<dfs(0,st.size()-1,k)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\nusing namespace std;\nint dp[320][320][320];\nint main()\n{\n\tstring x;\n\tcin >> x;\n\tint gen;\n\tscanf(\"%d\", &gen);\n\tfor (int i = 0; i < x.size(); i++)\n\t{\n\t\tfor (int j = 0; j < x.size() - i; j++)\n\t\t{\n\t\t\tint s = j, t = j + i;\n\t\t\tfor (int k = 0; k <= gen; k++)\n\t\t\t{\n\t\t\t\tif (s == t)dp[s][t][k] = 1;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[s][t][k] = max(dp[s][t][k], dp[s + 1][t][k]);\n\t\t\t\t\tdp[s][t][k] = max(dp[s][t][k], dp[s][t - 1][k]);\n\t\t\t\t\tdp[s][t][k + (x[s] != x[t])] = max(dp[s][t][k + (x[s] != x[t])], dp[s + 1][t - 1][k] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[0][x.size() - 1][gen]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n変更箇所は順読み逆読みの少なくとも片方で役立たないといけない\nつまり1点分として加算される必要がある\n逆に1点分以上の役割は持てない<-嘘だった\n例えば右端の文字が他に存在しない文字ならそれを変更するのはOK\n*/\nint dp[302][302];\ntemplate<typename T>\nvoid fin(T a){\n  cout<<a<<endl;\n  exit(0);\n}\n\nsigned main(){\n  string s;int K;cin>>s>>K;\n  int N=s.size();\n  if(N/2<=K)fin(N);\n  string t=s;\n  reverse(t.begin(),t.end());\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i][j]+(s[i]==t[j])});\n    }\n  }\n  int ans=dp[N][N];\n  if(K==0)fin(ans);\n  for(int k=0;k<N;k++){\n    for(int q=0;q<26;q++){\n      char tmp=s[k];\n      s[k]=t[N-k-1]='a'+q;\n      for(int i=k-1;i<N;i++){if(i<0)i++;\n        for(int j=k-1;j<N;j++){if(j<0)j++;\n          dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i][j]+(s[i]==t[j])});\n        }\n      }\n      if(dp[N][N]>ans+1){\n        ans=dp[N][N];\n        K--;\n      }\n      else s[k]=t[N-k-1]=tmp;\n      if(K==0)fin(ans);\n    }\n  }\n  for(int k=0;k<N;k++){\n    for(int q=0;q<26;q++){\n      char tmp=s[k];\n      s[k]=t[N-k-1]='a'+q;\n      for(int i=k-1;i<N;i++){if(i<0)i++;\n        for(int j=k-1;j<N;j++){if(j<0)j++;\n          dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i][j]+(s[i]==t[j])});\n        }\n      }\n      if(dp[N][N]>ans){\n        ans=dp[N][N];\n        K--;\n      }\n      else s[k]=t[N-k-1]=tmp;\n      if(K==0)fin(ans);\n    }\n  }\n  fin(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 301;\nint dp[MAXN][MAXN][MAXN];\n\nint main() {\n    string s;\n    cin >> s;\n    int k;\n    cin >> k;\n\n    int n = s.length();\n    int mx = 0;\n\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; i + j <= n; j++) {\n            for (int c = 0; c <= k; c++) {\n                mx = max(mx, dp[i][j][c]);\n\n                if (i + j + 1 <= n) {\n                    dp[i + 1][j][c] = max(dp[i + 1][j][c], dp[i][j][c]);\n                    dp[i][j + 1][c] = max(dp[i][j + 1][c], dp[i][j][c]);\n                }\n                if (i + j + 1 == n) {\n                    dp[i + 1][j][c] = max(dp[i + 1][j][c], dp[i][j][c] + 1);\n                    dp[i][j + 1][c] = max(dp[i][j + 1][c], dp[i][j][c] + 1);\n                }\n\n                // don't change\n                if (i + j + 1 <= n && s[i] == s[n - 1 - j]) {\n                    dp[i + 1][j + 1][c] = max(dp[i + 1][j + 1][c], dp[i][j][c] + 2);\n                }\n\n                // change\n                if (i + j + 1 <= n && c + 1 <= k) {\n                    dp[i + 1][j + 1][c + 1] = max(dp[i + 1][j + 1][c + 1], dp[i][j][c] + 2);\n                }\n            }\n        }\n    }\n\n    cout << mx << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#define int ll\n//#define char ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(4) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int N = 333;\nshort dp[N][N][N];\n\n\nint solve(string s, int k) {\n\n    int n = s.size();\n    string t = s;\n    reverse(ALL(t));\n\n\n    fori (i, N) {\n        fori (j, N) {\n            fori (k, N) {\n                dp[i][j][k] = n * 3;\n            }\n        }\n    }\n\n    dp[0][0][0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            for (int len = 0; len < n; ++len) if (dp[i][j][len] < n * 3) {\n                    inmin(dp[i + 1][j][len], dp[i][j][len]);\n                    inmin(dp[i][j + 1][len], dp[i][j][len]);\n                    if (s[i] == t[j])\n                        inmin(dp[i + 1][j + 1][len + 1], dp[i][j][len]);\n                    else {\n                        inmin(dp[i + 1][j + 1][len + 1], (short)(dp[i][j][len] + 1));\n                    }\n                }\n        }\n    }\n\n    int ans = 0;\n    fori (i, n + 1) {\n        fori (j, n + 1) {\n            fori (len, n + 1) {\n                if (dp[i][j][len] <= k * 2) {\n                    inmax(ans, len);\n                }\n            }\n        }\n    }\n    return ans;\n}\n\nstring reversed(string s) {\n    reverse(ALL(s));\n    return s;\n}\n\nconst int L = 2;\n\nvoid rec(string s, int i, const vi & ids, vector<string> & curs) {\n    if (i == SZ(ids)) {\n        curs.push_back(s);\n        return;\n    }\n    int id = ids[i];\n    for (char c = 'a'; c <= char('a' + L); ++c) {\n        s[id] = c;\n        rec(s, i + 1, ids, curs);\n    }\n}\n\n\nint naive(string s, int k) {\n    int n = s.size();\n    vi kek(n, 0);\n    fori (i, k) {\n        kek[i] = 1;\n    }\n    sort(ALL(kek));\n    int ans = 0;\n    do {\n        vi ids;\n        fori (i, n) {\n            if (kek[i])\n                ids.push_back(i);\n        }\n\n        vector<string> curs;\n        rec(s, 0, ids, curs);\n\n        for (auto cur : curs) {\n            inmax(ans, solve(cur, 0));\n        }\n\n    } while (next_permutation(ALL(kek)));\n\n    return ans;\n}\n\nvoid stress() {\n    int cnt = -1;\n    while (true) {\n        if (++cnt % 1 == 0)\n            watch(cnt);\n        int n = 1 + rng() % 5;\n        string s(n, 'a');\n        fori (i, n) {\n            s[i] += rng() % (L + 1);\n        }\n        int k = rng() % (n + 1);\n        int sl = solve(s, k);\n        int nv = naive(s, k);\n        if (sl != nv) {\n            watch(sl);\n            watch(nv);\n            cerr << s << '\\n' << k << endl;\n            watch(cnt);\n            exit(0);\n        }\n    }\n}\n\n\nvoid smain() {\n\n//    stress();\n\n\n    string s;\n    cin >> s;\n    int k;\n    cin >> k;\n    int n = s.size();\n    string t = s;\n    reverse(ALL(t));\n\n\n    fori (i, N) {\n        fori (j, N) {\n            fori (k, N) {\n                dp[i][j][k] = n * 3;\n            }\n        }\n    }\n\n    dp[0][0][0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            for (int len = 0; len < n; ++len) if (dp[i][j][len] < n * 3) {\n                    inmin(dp[i + 1][j][len], dp[i][j][len]);\n                    inmin(dp[i][j + 1][len], dp[i][j][len]);\n                    if (s[i] == t[j])\n                        inmin(dp[i + 1][j + 1][len + 1], dp[i][j][len]);\n                    else {\n                        inmin(dp[i + 1][j + 1][len + 1], (short)(dp[i][j][len] + 1));\n                    }\n                }\n        }\n    }\n\n    int ans = 0;\n    fori (i, n + 1) {\n        fori (j, n + 1) {\n            fori (len, n + 1) {\n                if (dp[i][j][len] == 0) {\n                    inmax(ans, len);\n                }\n            }\n        }\n    }\n    cout << min(n, ans + 2 * k);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-8\n#define pi 3.14159265358979\n#define LL long long\n#define MP make_pair\n#define PH push\n#define PB push_back\n#define PII pair<int,int>\n#define VI vector<int>\n#define X first\n#define Y second\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\n#define sqr(x) ((x)*(x))\n#define CL(a) memset(a,0,sizeof a)\n#define fr(i,n) for(int i=1;i<=n;i++)\n#define FR(i,S,n) for(int i=S;i<=n;i++)\n#define dr(i,n) for(int i=n;i;i--)\n#define DR(i,n,S) for(int i=n;i>=S;i--)\n#define SZ(x) ((int)(x).size())\n#define rd(x) scanf(\"%d\",&x)\n#define pr(x) printf(\"%d\",x)\nconst int N=305;\nLL Pw(LL a,LL b,LL p){LL v=1;for(;b;b>>=1,a=a*a%p)if(b&1)v=v*a%p;return v;}\nusing namespace std;\nint n,m,i,j,k;char s[N];short f[N][N][N*2];\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);rd(m);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\tfor(k=0;k<=m*2;k++){\n\t\t\t\tif(s[i]==s[n-j+1]){\n\t\t\t\t\tf[i][j][k]=f[i-1][j-1][k]+1;\n\t\t\t\t}else{\n\t\t\t\t\tf[i][j][k]=max(f[i-1][j][k],f[i][j-1][k]);\n\t\t\t\t\tif(k)f[i][j][k]=max((int)f[i][j][k],f[i-1][j-1][k-1]+1);\n\t\t\t\t}\n\t\t\t}\n\tprintf(\"%d\",(int)f[n][n][m*2]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\n\nint mat[301][301] = {0};\n\nint main() {\n\tint n;\n\tint res = 0;\n\n\tstring a, b;\n\tint k;\n\tcin >> a;\n\tcin >> k;\n\tfor(int i=0; i<a.size(); ++i)\n\t\tb += a[a.size()-i-1];\n\n\tn = max(a.size(), b.size());\n\n\tfor(int i=0; i<2*n; ++i)\n\t\tfor(int j=0; j<=i; ++j)\n\t\t{\n\t\t\tint y = i-j;\n\t\t\tint x = j;\n\t\t\tif(a.size() <= y || b.size() <= x)\n\t\t\t\tcontinue;\n\n\t\t\tif(a[y] == b[x])\n\t\t\t\tmat[y+1][x+1] = mat[y][x] + 1;\n\t\t\telse\n\t\t\t\tmat[y+1][x+1] = max(mat[y][x+1], mat[y+1][x]);\n\t\t}\n\n\tint ans = mat[a.size()][b.size()];\n\tans += 2*k;\n\tans = min(ans, n);\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n#define INF 1000000000\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint dp[333][333][333];\nstring s;\nint k;\n\nint dfs(int K,int L,int R)\n{\n//\tcout << K << ' ' << L << ' ' << R << endl;\n\tif(K < 0)return -100000000;\n\tif(L > R)return 0;\n\tif(dp[K][L][R] != 0)return dp[K][L][R];\n\tint ret = 0;\n\tif(s[L] == s[R])ret = max(ret,dfs(K,L+1,R-1)+2);\n\telse ret = max(ret,dfs(K-1,L+1,R-1)+2);\n\tret = max(ret,dfs(K,L+1,R));\n\tret = max(ret,dfs(K,L,R-1));\n\t\n\treturn dp[K][L][R] = ret;\n}\n\n\nint main()\n{\n\tcin >> s >> k;\n\t\n\tREP(K,333)REP(i,333)dp[K][i][i] = 1;\n\tREP(K,333)REP(i,s.size()-1)\n\t{\n\t\tif(s[i] == s[i+1])dp[K][i][i+1] = 2;\n\t\telse dp[K][i][i+1] = 1;\n\t\tif(K > 0)dp[K][i][i+1] = 2;\n\t}\n\t\n\tcout << dfs(k,0,s.size()-1) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n#define INF 1000000000\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint dp[333][333][333];\nstring s;\nint k;\n\nint dfs(int K,int L,int R)\n{\n//\tcout << K << ' ' << L << ' ' << R << endl;\n\tif(K < 0)return -100000000;\n\tif(L > R)return 0;\n\tif(dp[K][L][R] != 0)return dp[K][L][R];\n\tint ret = 0;\n\tif(s[L] == s[R])ret = max(ret,dfs(K,L+1,R-1)+2);\n\telse ret = max(ret,dfs(K-1,L+1,R-1)+2);\n\tret = max(ret,dfs(K,L+1,R));\n\tret = max(ret,dfs(K,L,R-1));\n\t\n\treturn dp[K][L][R] = ret;\n}\n\n\nint main()\n{\n\tcin >> s >> k;\n\t\n\tREP(K,333)REP(i,333)dp[K][i][i] = 1;\n\tREP(K,333)REP(i,332)\n\t{\n\t\tif(s[i] == s[i+1])dp[K][i][i+1] = 2;\n\t\telse dp[K][i][i+1] = 1;\n\t}\n\t\n\tcout << dfs(k,0,s.size()-1) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//cwystc <--> 陈威宇是天才  --by cwy\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pi;\nconst double PI=acos(-1);\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define rep(i,a,b) for (int i=(a);i<=(b);i++)\n#define per(i,a,b) for (int i=(a);i>=(b);i--)\n#define Rep(i,a,b) for (int i=(a);i<(b);i++)\n#define Per(i,a,b) for (int i=(a);i>(b);i--)\n#define travel_set(it,a) for (set<int>::iterator (it)=(a).begin();(it)!=(a).end();(it)++)\n#define travel_map(it,a) for (map<int>::iterator (it)=(a).begin();(it)!=(a).end();(it)++)\n#define travel_vec(it,a) for (vector<int>::iterator (it)=(a).begin();(it)!=(a).end();(it)++)\n#define p(x) cout << x << endl;\n#define def cout << \"find\" << endl;\n#define what_is(x) cout << #x << \" is \" << x << endl;\ntemplate <class T>T sqr(T x){return x*x;}\ntemplate <class T>T alex(T x){return (x>0)?x:-x;}\ntemplate <class T>void read(T&x){\n\tx=0;T f=1;char ch=getchar();\n\twhile ((ch<48||ch>57)&&ch!=45)ch=getchar();\n\tif (ch==45)f=-1,ch=getchar();\n\twhile (ch>=48&&ch<=57)x=x*10+ch-48,ch=getchar();\n\tx*=f;\n}\n\n//-------------------------------------------------head-------------------------------------------------\n\n#define maxn 305\nint f[maxn][maxn][maxn];\nchar s[maxn],_s[maxn];int k,len;\nint main(){\n\tscanf(\"%s\",s+1);len=strlen(s+1);read(k);\n\trep(i,1,len)_s[i]=s[len-i+1];\n\t// rep(i,0,len)f[i][0][0]=f[0][i][0]=0;\n\trep(i,1,len)rep(j,1,len)if (i!=0&&j!=0){\n\t\tf[i][j][0]=max(max(f[i-1][j][0],f[i][j-1][0]),f[i-1][j-1][0]+(s[i]==_s[j]));\n\t\trep(kk,1,k){\n\t\t\tf[i][j][kk]=max(max(f[i-1][j][kk],f[i][j-1][kk]),f[i-1][j-1][kk-(s[i]!=_s[j])]+1);\n\t\t}\n\t}\n\tint res=0;\n\trep(i,1,len)rep(kk,0,k)res=max(f[i][len-i][k]*2,res);\n\trep(i,1,len)rep(kk,0,k)res=max(f[i-1][len-i][kk]*2+1,res);printf(\"%d\\n\",res);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing PII = pair<ll, ll>;\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\ntemplate<typename T> void chmin(T &a, const T &b) { a = min(a, b); }\ntemplate<typename T> void chmax(T &a, const T &b) { a = max(a, b); }\nstruct FastIO {FastIO() { cin.tie(0); ios::sync_with_stdio(0); }}fastiofastio;\n#ifdef DEBUG_ \n#include \"../program_contest_library/memo/dump.hpp\"\n#else\n#define dump(...)\n#endif\nconst ll INF = 1LL<<60;\n\nll dp[305][305][305];\nint main(void) {\n    string s;\n    ll m;\n    cin >> s >> m;\n    ll n = s.size();\n\n    REP(i, n) REP(j, m+1) dp[i][i][j] = 1;\n    REP(i, n-1) {\n        dp[i][i+1][0] = (s[i]==s[i+1] ? 2 : 1);\n        dp[i][i+1][1] = 2;\n    }\n\n    FOR(w, 1, n+1) REP(l, n-w+1) {\n        ll r = l+w-1;\n        REP(i, m+1) {\n            if(l-1>=0) chmax(dp[l-1][r][i], dp[l][r][i]);\n            if(r+1<n) chmax(dp[l][r+1][i], dp[l][r][i]);\n            if(l-1>=0 && r+1<n && s[l-1]==s[r+1]) chmax(dp[l-1][r+1][i], dp[l][r][i]+2);\n            if(l-1>=0 && r+1<n && i+1<=m) chmax(dp[l-1][r+1][i+1], dp[l][r][i]+2);\n        }\n    }\n\n    cout << dp[0][n-1][m] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nint dp[160][160][160];\nint d2[310][310];\nstring s;\nint cal(int x,int y){\n\tif(x==y) return d2[x][y]=1;\n\tif(x>y) return d2[x][y]=0;\n\tif(d2[x][y]>=0) return d2[x][y];\n\tint ret=0;\n\tif(s[x]==s[y]) ret=max(ret,cal(x+1,y-1)+2);\n\tret=max(ret,cal(x+1,y));ret=max(ret,cal(x,y-1));\n\treturn d2[x][y]=ret;\n}\nint main()\n{\n\tint K,n,out;\n\tcin>>s;n=s.size();cin>>K;\n\tmemset(dp,0,sizeof(dp));\n\trep(i,n/2+1) rep(j,n/2+1) rep(k,K+1){\n\t\t//cout<<i<<' '<<j<<' '<<k<<' '<<dp[i][j][k]<<endl;\n\t\tif(i<n/2) dp[i+1][j][k]=max(dp[i+1][j][k],dp[i][j][k]);\n\t\tif(j<n/2) dp[i][j+1][k]=max(dp[i][j+1][k],dp[i][j][k]);\n\t\tif(i<n/2 && j<n/2){\n\t\t\tif(s[i]==s[n-1-j]) dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+1);\n\t\t\telse dp[i+1][j+1][k+1]=max(dp[i+1][j+1][k+1],dp[i][j][k]+1);\n\t\t}\n\t}\n\t\n\tmemset(d2,-1,sizeof(d2));\n\t//cal(0,n-1);\n\t\n\t//cout<<dp[6][9][3]<<' '<<cal(6,9)<<endl;\n\trep(i,n/2+1) rep(j,n/2+1) rep(k,K+1){\n\t\tout=max(out,dp[i][j][k]*2+cal(i,n-j-1));\n\t}\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\ninline void chmax(int &x, int v) { if (x < v) x = v; }\n\nstring S;\nint N, K;\nint dp[300][300][302];\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> S >> K;\n  N = S.length();\n  rep(i, N) rep(j, N) rep(k, K+1) dp[i][j][k] = -INF;\n  dp[0][N-1][0] = 0;\n  for (int len=N; len>=1; len--) {\n    rep(l, N) {\n      int r = l+len-1;\n      if (r >= N) break;\n      rep(k, K+1) {\n        if (dp[l][r][k] < 0) continue;\n        //cout<<\"dp[\"<<l<<\"][\"<<r<<\"][\"<<k<<\"]=\"<<dp[l][r][k]<<\"\\n\";\n        chmax(dp[l+1][r-1][k+(S[l]!=S[r])], dp[l][r][k] + (l==r?1:2));\n        chmax(dp[l+1][r][k], dp[l][r][k]);\n        chmax(dp[l][r-1][k], dp[l][r][k]);\n      }\n    }\n  }\n  int m = 0;\n  rep(i, N) rep(j, N) rep(k, K+1) chmax(m, dp[i][j][k]);\n  cout << m << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define gc getchar\n#define pc putchar\n#define fi first\n#define queue QQQ\n#define se second\n#define debug(x) cout << #x\" = \" << x << endl;\n#define pp(x,y) cout << \"pp: \" << x << \" \" << y << endl;\n#define rank __RAnK\ninline ll read(){\n\tregister ll x=0,f=1;register char c=gc();\n\tfor(;!isdigit(c);c=gc())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\n#define rd read\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid writeln(ll x){write(x);puts(\"\");}\nconst int maxn = 2e5+233;\nint f[305][305][305];\nchar s[305];\nint K,n;\nint main(){\n\tscanf(\"%s\",s+1);\n\tn = strlen(s+1);\n\tK = rd();\n\tmem(f,0);\n\tRep(i,1,n) f[i][i][0] = 1;\n\tRep(len,2,n){\n\t\tfor(int i=1;i+len-1<=n;++i){\n\t\t\tint j = i + len - 1;\n\t\t\tRep(k,0,K){\n\t\t\t\tif(k)f[i][j][k] = max(f[i][j][k],f[i][j][k-1]);\n\t\t\t\tf[i][j][k] = max(f[i][j][k],f[i+1][j][k]);\n\t\t\t\tf[i][j][k] = max(f[i][j][k],f[i][j-1][k]);\n\t\t\t\tif(s[i]==s[j]) f[i][j][k] = max(f[i][j][k],f[i+1][j-1][k]+2);\n\t\t\t\tif(k)f[i][j][k] = max(f[i][j][k],f[i+1][j-1][k-1]+2);\n\t\t\t}\n\t\t}\n\t}writeln(f[1][n][K]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nint dp[311][311][311];\nstring s;\n\nint solve(int l, int r, int k)\n{\n\tif(k<0) return -int(1e9);\n\tif(l>r) return 0;\n\tif(dp[l][r][k]>=0) return dp[l][r][k];\n\tif(l==r) return 1;\n\tint ans = max(solve(l,r-1,k),solve(l+1,r,k));\n\tans=max(ans,solve(l+1,r-1,k-(s[l]!=s[r]))+2);\n\treturn (dp[l][r][k]=ans);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin>>s; int k; cin>>k;\n\tmemset(dp,-1,sizeof(dp));\n\tcout<<solve(0,int(s.length())-1,k)<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "//wls niubi!\n#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\nconst LL mod = 1e9 + 7;\ninline int read()\n{\n\tint x = 0,f = 1;char ch = getchar();\n\tfor(;!isdigit(ch);ch = getchar())if(ch == '-')f = -f;\n\tfor(;isdigit(ch);ch = getchar())x = 10 * x + ch - '0';\n\treturn x * f;\n}\nint n,K;\nchar ch[310];\nint f[310][310][310];\nint main()\n{\n\tscanf(\"%s\",ch + 1);n = strlen(ch + 1);K = read();\n\tfor(int i=1;i<=n;i++)for(int j=0;j<=K;j++)f[i][i][j] = 1;\n\tfor(int l=2;l<=n;l++)\n\t{\n\t\tfor(int i=1;i+l-1<=n;i++)\n\t\t{\n\t\t\tint j = i + l - 1;\n\t\t\tfor(int k=0;k<=K;k++)\n\t\t\t{\n\t\t\t    f[i][j][k] = max(f[i - 1][j][k],f[i][j - 1][k]);\n\t\t\t    if(ch[i] == ch[j])f[i][j][k] = max(f[i][j][k],f[i + 1][j - 1][k] + 2);\n\t\t\t    if(k)f[i][j][k] = max(f[i][j][k],f[i + 1][j - 1][k - 1] + 2);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tcout<<f[1][n][K];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dp[303][303][303];\nstring s;\n\nint getdp(int i, int j, int k){\n    if (i<0) return -1;\n    if (j>k) return 0;\n    if (j == k) return 1;\n    if (dp[i][j][k] != -1) return dp[i][j][k];\n    int res = -1;\n    if (s[j] == s[k]) res = getdp(i, j+1, k-1)+2;\n    else res = max(getdp(i-1, j+1, k-1)+2, max(getdp(i, j+1, k), getdp(i, j, k-1)));\n    dp[i][j][k] = res;\n    return res;\n}\n\nint main(){\n    cin >> s;\n    int k; cin >> k;\n    for(int i=0; i<302; i++)for(int j=0; j<302; j++)for(int k=0; k<302; k++) dp[i][j][k] = -1;\n    cout << getdp(k, 0, s.size()-1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#ifdef leowang\n#define debug(...) do{\\\n\tfprintf(stderr,\"%s - %d : (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);\\\n\t_DO(__VA_ARGS__);\\\n}while(0)\ntemplate<typename I> void _DO(I&&x){cerr<<x<<endl;}\ntemplate<typename I,typename...T> void _DO(I&&x,T&&...tail){cerr<<x<<\", \";_DO(tail...);}\n#else\n#define debug(...)\n#endif\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n}\n//}}}\nconst ll maxn=305;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=8000000000000000000LL;\nconst int INF=2000000000;\nconst ll MOD=ll(1e9+7);\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n/*\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) a=a*a%MOD;\n\t\telse res=res*a%MOD;\n\t\tb>>=1;\n\t}\n\tres=res*a%mod;\n\treturn res;\n}\n*/\nstring s,t;\nint dp[maxn][maxn][maxn*2];\n\nint f(int i,int j,int k){\n\tif(k<0) return -INF;\n\tif(i==0||j==0) return 0;\n\tif(dp[i][j][k]!=-1) return dp[i][j][k];\n\tif(s[i-1]==t[j-1]) return f(i-1,j-1,k)+1;\n\treturn dp[i][j][k]=max({f(i-1,j,k),f(i,j-1,k),f(i-1,j-1,k-1)+(SZ(s)%2==0||i!=SZ(s)/2||j!=SZ(s)/2)});\n}\n\nint main()\n{\n\tIOS;\n\tmemset(dp,-1,sizeof dp);\n\tint k;\n\tcin>>s>>k;\n\tt=s;\n\treverse(ALL(t));\n\tint ans=0;\n\tREP(i,SZ(s)){\n\t\tans=max(ans,f(i,SZ(s)-1-i,k)*2+1);\n\t}\n\tREP(i,SZ(s)-1) if(s[i]==s[i+1]){\n\t\tans=max(ans,2*f(i+1,SZ(s)-i-1,k));\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=310;\nint gi() {\n    int x=0,o=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\nchar s[N];\nint n,k,f[N][N][N];\nint main() {\n    scanf(\"%s\",s+1),n=strlen(s+1);\n    k=gi();\n    for(int l=n;l;l--)\n        for(int r=l;r<=n;r++)\n            for(int i=0;i<=k;i++) {\n                if(l==r) f[l][r][i]=1;\n                else if(l+1==r) f[l][r][i]=(i||s[l]==s[r])?2:1;\n                else {\n                    f[l][r][i]=max(f[l+1][r][i],f[l][r-1][i]);\n                    if(s[l]==s[r]) f[l][r][i]=max(f[l][r][i],f[l+1][r-1][i]+2);\n                    if(i) f[l][r][i]=max(f[l][r][i],f[l+1][r-1][i-1]+2);\n                }\n            }\n    printf(\"%d\\n\",f[1][n][k]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 305;\nint dp[2][N][N];\nchar s[N];\nint dfs(int l, int r, int dp[N][N]) {\n\tint &res = dp[l][r];\n\tif (dp[l][r] != -1) return dp[l][r];\n\tif (l > r) return res = 0;\n\tres = 0;\n\tif (s[l] == s[r]) res = dfs(l + 1, r - 1, dp) + (l == r ? 1 : 2);\n\tres = max(res, dfs(l + 1, r, dp));\n\tres = max(res, dfs(l, r - 1, dp));\n\treturn res;\n}\nint dfs2(int l, int r, int dp[N][N], int fr[N][N]) {\n\tint &res = dp[l][r];\n\tif (dp[l][r] != -1) return dp[l][r];\n\tif (l > r) return res = 0;\n\tres = 0;\n\tif (s[l] == s[r]) res = dfs2(l + 1, r - 1, dp, fr) + (l == r ? 1 : 2);\n\tres = max(res, fr[l + 1][r - 1] + (l == r ? 1 : 2));\n\tres = max(res, dfs2(l + 1, r, dp, fr));\n\tres = max(res, dfs2(l, r - 1, dp, fr));\n\treturn res;\n}\nint main() {\n\tscanf(\"%s\", s + 1);\n\tint n = strlen(s + 1), k;\n\tscanf(\"%d\", &k);\n\tmemset(dp, -1, sizeof(dp));\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tfor (int j = i + 1; j <= n; ++ j) {\n\t\t\tdfs(i, j, dp[0]);\n\t\t}\n\t}\n\tint cur = 0;\n\tint ans = dp[cur][1][n];\n\tfor (int i = 1; i <= k; ++ i) {\n\t\tcur ^= 1;\n\t\tmemset(dp[cur], -1, sizeof(dp[cur]));\n\t\tfor (int i = 1; i <= n; ++ i) {\n\t\t\tfor (int j = i + 1; j <= n; ++ j) {\n\t\t\t\tdfs2(i, j, dp[cur], dp[cur ^ 1]);\n\t\t\t}\n\t\t}\n\t\tans = max(ans, dp[cur][1][n]);\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n//#define int long long\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long double ld;\ntypedef long long ll;\n#define X first\n#define Y second\n#define all(o) o.begin(), o.end()\n#define endl '\\n'\n#define IOS ios::sync_with_stdio(0), cin.tie(0)\nconst int maxn = 300 + 10;\nint dp[maxn][maxn][maxn];\nint32_t main(){\n\tIOS;\n\tstring s;\n\tcin >> s;\n\tint n = s.size(), k1;\n\tcin >> k1;\n\tfor(int k=0; k<=k1; k++){\n\t\tfor(int sz=1; sz<=n; sz++){\n\t\t\tfor(int i=0; i+sz<=n; i++){\n\t\t\t\tint j = i+sz;\n\t\t\t\tif(sz == 1){\n\t\t\t\t\tdp[k][i][j] = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(s[i] == s[j-1]){\n\t\t\t\t\tdp[k][i][j] = dp[k][i+1][j-1]+2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint x = dp[k][i+1][j];\n\t\t\t\tx = max(x, dp[k][i][j-1]);\n\t\t\t\tif(k) \n\t\t\t\t\tx = max(x, dp[k-1][i+1][j-1] + 2);\n\t\t\t\tdp[k][i][j] = x;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[k1][0][n] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n)  for(int i = (k);i < (n);++i)\n#define REP(i,n)    FOR(i,0,n)\n#define ALL(x)      begin(x),end(x)\n\nusing namespace std;\nusing vecint = vector<int>;\nusing ll = int64_t;\n\nint main()\n{\n  string s;\n  cin>>s;\n  string r = s;\n  reverse(ALL(r));\n  int n = s.size();\n  int K;\n  cin>>K;\n  vector<vector<vecint>> dp(n+1, vector<vecint>(n+1, vecint(K+1, 0)));\n  REP(i,n)REP(j,n)REP(k,K+1) {\n    //cerr << i << ' ' << j << ' ' << k << ' ' << dp[i][j][k] << endl;\n    if (s[i] == r[j]) {\n      dp[i+1][j+1][k] = max(dp[i+1][j+1][k], 1 + dp[i][j][k]);\n    }\n    if (k<K) {\n      dp[i+1][j+1][k+1] = max(dp[i+1][j+1][k+1], 1 + dp[i][j][k]);\n    }\n    dp[i+1][j][k] = max(dp[i+1][j][k], dp[i][j][k]);\n    dp[i][j+1][k] = max(dp[i][j+1][k], dp[i][j][k]);\n    dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k]);\n  }\n  int mx = 0;\n  REP(i,n)REP(j,n) {\n    if (i+j > n) break;\n    mx = max(mx, dp[i][j][K]*2+(n-(i+j))%2);\n  }\n  cout << mx << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nstring s;\t\nconst int inf = 100000000;\nint mem[333][333][333];\n\nint dp(int l, int r, int k) {\n\tif(k < 0) return -inf;\n\tif(l == r) return 1;\n\tif(l > r) {\n\t\treturn 0;\n\t}\n\tif(mem[l][r][k] != -1) return mem[l][r][k];\n\tint ans = -inf;\n\tif(s[l] == s[r]) ans = max(ans, 2 + dp(l + 1, r - 1, k));\n\tans = max(ans, dp(l + 1, r, k));\n\tans = max(ans, dp(l, r - 1, k));\n\tans = max(ans, 2 + dp(l + 1, r - 1, k - 1));\n\treturn mem[l][r][k] = ans;\n}\n\nint main(int argc, char const *argv[])\n{\n\tcin >> s;\n\tint k;\n\tcin >> k;\n\tmemset(mem, -1, sizeof mem);\n\tcout << dp(0, s.size() - 1, k) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 310;\n\ninline int read() {\n\tint x = 0, f = 1;\n\tchar ch = getchar();\n\tfor(; !isdigit(ch); ch = getchar()) if(ch=='-') f=-1;\n\tfor(; isdigit(ch); ch = getchar()) x = (x*10)+(ch^48);\n\treturn x * f;\n}\n\nchar s[310];\nint dp[MAXN][MAXN][MAXN], K, n, ans;\n\ninline void chkmax(int &cur, int val) {\n\tif(val > cur) cur = val;\n}\n\nint main() {\n\n\tscanf(\"%s\", s+1);\n\tK = read();\n\tn = strlen(s+1);\n\tif(n == 1) {\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tint i, j, k, d;\n\t//dp[1][n][0] = s[1] == s[n] ? 2 : 0;\n\t//dp[1][n][1] = 2;\n\tdp[0][n+1][0] = 0;\n\tfor(d = n+1; d > 1; d--) \n\t\tfor(i = 0; i+d <= n+1; i++) {\n\t\t\tj = i+d;\n\t\t\tfor(k = 0; k <= K; k++) {\n\t\t\t\tchkmax(dp[i][j-1][k], dp[i][j][k]);\n\t\t\t\tchkmax(dp[i+1][j][k], dp[i][j][k]);\n\t\t\t\tif(i + 1 != j-1) {\n\t\t\t\t\tchkmax(dp[i+1][j-1][k], dp[i][j][k]+(s[i+1] == s[j-1] ? 2 : 0));\n\t\t\t\t\tchkmax(dp[i+1][j-1][k+1], dp[i][j][k]+2);\n\t\t\t\t}\n\t\t\t\telse chkmax(dp[i+1][j-1][k], dp[i][j][k]+1);\n\t\t\t\tchkmax(ans, dp[i][j][k]);\n\t\t\t}\n\t\t}\n\tfor(i = 1; i < n; i++) \n\t\tfor(k = 0; k <= K; k++) \n\t\t\tchkmax(ans, dp[i][i+1][k]);\n\tfor(i = 1; i <= n; i++)\n\t\tfor(k = 0; k <= K; k++)\n\t\t\tchkmax(ans, dp[i][i][k]);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge {c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\nconst int nax = 305;\nint dp[nax][nax][nax];\n\nvoid maxi(int & a, int b) {\n\ta = max(a, b);\n}\n\nint main() {\n\tstring s;\n\tcin >> s;\n\tconst int n = s.length();\n\tint k;\n\tcin >> k;\n\tassert(k <= n);\n\tint answer = 0;\n\tfor(int low = 0; low < n; ++low)\n\t\tfor(int high = n - 1; high >= low; --high)\n\t\t\tfor(int used = 0; used <= k; ++used) {\n\t\t\t\tint me = dp[low][high][used];\n\t\t\t\tif(low == high) {\n\t\t\t\t\tmaxi(answer, 2 * me + 1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(low + 1 == high) {\n\t\t\t\t\tmaxi(answer, 2 * me + 1);\n\t\t\t\t\tif(s[low] == s[high] || used < k)\n\t\t\t\t\t\tmaxi(answer, 2 * me + 2);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmaxi(dp[low+1][high][used], me);\n\t\t\t\tmaxi(dp[low][high-1][used], me);\n\t\t\t\tif(s[low] == s[high])\n\t\t\t\t\tmaxi(dp[low+1][high-1][used], me + 1);\n\t\t\t\tmaxi(dp[low+1][high-1][used+1], me + 1);\n\t\t\t}\n\tprintf(\"%d\\n\", answer);\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n#include <cstdio>\n#include <iostream>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n//#ifdef atom #else #endif\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\n#define X first\n#define Y second\n#define vi vector<int>\n#define vvi vector< vi >\n#define vii vector< ii >\n#define mp make_pair\n#define pb push_back\nstring s;\nint k;\nconst int maxn = 305;\nconst int maxk = 305;\nint dp[maxn][maxn][maxk];\nint n;\nint solve(int i, int j, int k)\n{\n    if(i == n || j< 0) return 0;\n    if(dp[i][j][k] != -1) return dp[i][j][k];\n    int res = 0;\n    res = max(res, solve(i+1, j, k));\n    res = max(res, solve(i, j-1, k));\n    if(s[i] == s[j]) res = max(res, 1+solve(i+1, j-1, k));\n    else if(k && i != j) res = max(res, solve(i+1, j-1, k-1)+2);\n    return dp[i][j][k] = res;\n}\nint main()\n{\n    //#ifndef atom freopen(\".in\", \"r\", stdin); freopen(\".out\", \"w\", stdout); #endif\n    cin >> s >> k;\n    n = s.size();\n    memset(dp, -1, sizeof dp);\n    //cout << solve(1, 4, 0) << endl;\n    cout << solve(0, n-1, k) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring s;\nint mat[301][301][301];\n\nint main()\n{\n    cin >> s;\n    int kmax;\n    cin >> kmax;\n    int n = s.size();\n    s = \"$\" + s;\n    int ans(0);\n    for (int i(1); i <= n; i++) {\n        for (int j(1); i + j <= n; j++) {\n            for (int k(0); k <= kmax; k++) {\n                if (s[i] == s[n - j + 1])\n                    mat[i][j][k] = mat[i - 1][j - 1][k] + 1;\n                mat[i][j][k] = max(mat[i][j][k], mat[i - 1][j - 1][k - 1] + 1);\n                mat[i][j][k] = max(mat[i][j][k], mat[i - 1][j][k]);\n                mat[i][j][k] = max(mat[i][j][k], mat[i][j - 1][k]);\n\n            }\n        }\n    }\n\n    if (n % 2 == 0) {\n        for (int i(1); i <= n; i++)\n            for (int j(0); j <= kmax; j++)\n                ans = max(ans, 2 * mat[i][n - i][j]);\n    }\n    else {\n        for (int i(1); i <= n; i++)\n            for (int j(0); j <= kmax; j++)\n                ans = max(ans, 2 * mat[i - 1][n - i][j] + 1);\n    }\n\n    cout << ans << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*******************************************\n*    Template created by Danel Batyrbek    *\n*    All rights reserved 2018 (lol)        *\n********************************************/\n\n#include <bits/stdc++.h>\n\n#define fr first\n#define sc second\n#define mkp make_pair\n#define lrb lower_bound\n#define upb upper_bound\n#define pb emplace_back\n#define ins insert\n#define sz(x) x.size()\n#define all(x) x.begin(), x.end()\n#define speed_up ios_base :: sync_with_stdio(0);cin.tie(0)\n#define skip continue\n#define left(x) x << 1\n#define rght(x) x << 1 | 1\n#define forn(x, y, z) for(int x = y; x <= z; ++ x)\n#define for1(x, y, z) for(int x = y; x >= z; -- x)\n#define fname \"\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 2e5 + 10;\nconst int INF = 2e9 + 10;\nconst int mod = 1e9 + 7;\nconst ll LINF = 4e18 + 10;\n\nstring s;\nint ans, k, now, prv, dp[301][301][301];\nint main(){\n#ifdef DANEL\n\tfreopen(\"in\", \"r\", stdin);\n#else\n\tif(fname != \"\"){\n\tfreopen(fname\".in\", \"r\", stdin);\n\tfreopen(fname\".out\", \"w\", stdout);\n\t}\n#endif\n\tcin >> s;\n\tcin >> k;\n\tint n = s.size();\n\tfor(int len = 1; len <= n; ++ len){\n\t\tfor(int l = 0; l < n - len + 1; ++ l){\n\t\t\tint r = l + len - 1;\n\t\t\tif(len == 1){\n\t\t\t\tdp[l][r][0] = 1;\n\t\t\t\tskip;\n\t\t\t}\n\t\t\tfor(int change = 0; change <= k; ++ change){\n\t\t\t\tdp[l][r][change] = dp[l + 1][r - 1][change];\n\t\t\t\tif(s[l] == s[r]){\n\t\t\t\t\tdp[l][r][change] = max(dp[l][r][change], dp[l + 1][r - 1][change] + 2);\n\t\t\t\t} else {\n\t\t\t\t\tdp[l][r][change] = max(dp[l][r][change], max(dp[l + 1][r][change], dp[l][r - 1][change]));\n\t\t\t\t\tif(change > 0) dp[l][r][change] = max(dp[l][r][change], dp[l + 1][r - 1][change - 1] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tforn(change, 0, k){\n\t\tans = max(ans, dp[0][n - 1][change]);\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=310;\nchar s[N]; int k,dp[N][N][N];\ninline void cmax(int &x,int y){x=max(x,y);}\ninline int dfs(int a,int b,int c){\n\tif(a==b)return 1; if(a>b)return 0;\n\tif(dp[a][b][c])return dp[a][b][c];\n\tif(s[a]==s[b])cmax(dp[a][b][c],dfs(a+1,b-1,c)+2);\n\telse if(c)cmax(dp[a][b][c],dfs(a+1,b-1,c-1)+2);\n\tcmax(dp[a][b][c],dfs(a+1,b,c));\n\tcmax(dp[a][b][c],dfs(a,b-1,c));\n\treturn dp[a][b][c];\n}\nint main(){\n\tscanf(\"%s%d\",s+1,&k); int len=strlen(s+1);\n\tfor(int i=1; i<=len; ++i)dp[i][i][0]=1;\n\tint ans=0;\n\tfor(int i=1; i<=len; ++i)\n\t\tfor(int j=i; j<=len; ++j)\n\t\t\tcmax(ans,dfs(i,j,k));\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nint dp[160][160][160];\nint d2[310][310][310];\nstring s;\nint cal(int x,int y,int z){\n\tif(d2[x][y][z]>=0) return d2[x][y][z];\n\tif(x==y) return d2[x][y][z]=1;\n\tif(x>y) return d2[x][y][z]=0;\n\tint ret=0;\n\tif(s[x]==s[y]) ret=max(ret,cal(x+1,y-1,z)+2);\n\tif(z>0) ret=max(ret,cal(x+1,y-1,z-1)+2);\n\tret=max(ret,cal(x+1,y,z));ret=max(ret,cal(x,y-1,z));\n\treturn d2[x][y][z]=ret;\n}\nint main()\n{\n\tint K,n,out;\n\tcin>>s;n=s.size();cin>>K;\n\tmemset(dp,0,sizeof(dp));\n\trep(i,n/2+1) rep(j,n/2+1) rep(k,min(K,155)+1){\n\t\t//cout<<i<<' '<<j<<' '<<k<<' '<<dp[i][j][k]<<endl;\n\t\tif(i<n/2) dp[i+1][j][k]=max(dp[i+1][j][k],dp[i][j][k]);\n\t\tif(j<n/2) dp[i][j+1][k]=max(dp[i][j+1][k],dp[i][j][k]);\n\t\tif(i<n/2 && j<n/2){\n\t\t\tif(s[i]==s[n-1-j]) dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+1);\n\t\t\telse dp[i+1][j+1][k+1]=max(dp[i+1][j+1][k+1],dp[i][j][k]+1);\n\t\t}\n\t}\n\t\n\tmemset(d2,-1,sizeof(d2));\n\t//cal(0,n-1);\n\t\n\t//cout<<dp[6][9][3]<<' '<<cal(6,9)<<endl;\n\trep(i,n/2+1) rep(j,n/2+1) rep(k,min(K,155)+1){\n\t\tout=max(out,dp[i][j][k]*2+cal(i,n-j-1,K-k));\n\t}\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dp[310][310][310];\n\nint main() {\n    string s; cin >> s;\n    int k; cin >> k;\n    int n = s.size();\n    for (int i = 0; i < n; i++) {\n        dp[i][i+1][0] = 1;\n        if (i) {\n            if (s[i-1] == s[i]) dp[i-1][i+1][0] = 2;\n            else {\n                dp[i-1][i+1][1] = 2;\n                dp[i-1][i+1][0] = 1;\n            }\n        }\n    }\n    for (int len = 3; len <= n; len++) {\n        for (int i = 0; i < n-len+1; i++) {\n            for (int u = 0; u <= 300; u++) {\n                // dp[i][i+len][u]\n                if (u) dp[i][i+len][u] = max(dp[i][i+len][u], dp[i+1][i+len-1][u-1] + 2);\n                dp[i][i+len][u] = max(dp[i][i+len][u], dp[i+1][i+len-1][u] + 2 * (s[i] == s[i+len-1]));\n                dp[i][i+len][u] = max({dp[i][i+len][u], dp[i][i+len-1][u], dp[i+1][i+len][u]});\n            }\n        }\n    }\n    \n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j <= n; j++) {\n            for (int z = 0; z <= k; z++) {\n                ans = max(ans, dp[i][j][z]);\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cout<<#v<<\":\";for(int i=0;i<v.size();i++) cout<<\" \"<<v[i]; cout<<endl\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\nconst int inf = 1000000001;\nconst ll INF = 2e18;\n#define MOD 1000000007\n#define mod 1000000009\n#define pi 3.14159265358979323846\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\n\nint main() {\n\tstring s;\n\tcin >> s;\n\tint k;\n\tcin >> k;\n\tint n = s.size();\n\tstring s2;\n\ts2 = s;\n\treverse(s2.begin(), s2.end());\n\tvii dp(n + 1, vi(n + 1));\n\tif (k >= 2) {\n\t\trep(i, n) {\n\t\t\trep(j, n) {\n\t\t\t\tif (s[i] == s2[j]) {\n\t\t\t\t\tdp[i + 1][j + 1] = dp[i][j] + 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << min(n, dp[n][n] + 2 * k) << endl;\n\t}\n\telse {\n\t\tint res = -1;\n\t\trep(i0, n) {\n\t\t\tstring t = s;\n\t\t\tt[i0] = '?';\n\t\t\tstring s2 = t;\n\t\t\treverse(s2.begin(), s2.end());\n\t\t\trep(i, n) {\n\t\t\t\trep(j, n) {\n\t\t\t\t\tif (t[i] == s2[j] || t[i] == '?' || s2[j] == '?') {\n\t\t\t\t\t\tdp[i + 1][j + 1] = dp[i][j] + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = max(res, dp[n][n]);\n\t\t}\n\t\tcout << res  << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nstatic const int IINF = 1 << 30;\n\ntemplate <typename T> std::vector<T> vectors(std::size_t n, T val) {\n  return std::vector<T>(n, val);\n}\n\ntemplate <typename T, typename... Args>\nauto vectors(std::size_t n, Args... args) {\n  return std::vector<decltype(vectors<T>(args...))>(n, vectors<T>(args...));\n}\n\ntemplate <class T> inline bool chmax(T &a, const T &b) {\n  return (a < b) ? a = b, true : false;\n}\n\nint main() {\n  // Input\n  std::string S;\n  int K;\n  int N;\n  std::cin >> S;\n  std::cin >> K;\n  N = S.length();\n\n  // Initialization\n  auto dp = vectors<int>(1 + N + 1, 1 + N + 1, 1 + K + 1, -IINF);\n\n  // Initial condition\n  dp[0][0][0] = 0;\n\n  // DP main\n  for (int i = 0; i <= N; ++i) {\n    for (int j = 0; j <= N; ++j) {\n      for (int k = 0; k <= K; ++k) {\n        chmax(dp[i + 1][j][k], dp[i][j][k]);\n        chmax(dp[i][j + 1][k], dp[i][j][k]);\n        // chmax(dp[i + 1][j][k + 1], dp[i][j][k] + 1);\n        // chmax(dp[i][j + 1][k + 1], dp[i][j][k] + 1);\n        chmax(dp[i + 1][j + 1][k + 1], dp[i][j][k] + 1);\n        if (S[i] == S[N - j - 1])\n          chmax(dp[i + 1][j + 1][k], dp[i][j][k] + 1);\n      }\n    }\n  }\n\n  // Output\n  int res = -1;\n  for (int k = 0; k <= K; ++k) {\n    for (int i = 0; i <= N; ++i)\n      chmax(res, 2 * dp[i][N - i][K]);\n    for (int i = 0; i < N; ++i)\n      chmax(res, 2 * dp[i][N - i - 1][K] + 1);\n  }\n\n  std::cout << res << std::endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nint p = 1000000007;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\n#define rev(s) reverse(s.begin(),s.end())\n#define end_program(s) cout << s <<endl;return 0\nint kai_size = 1000001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4); \n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size-1) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tif (r < 0 || n < r) { return 0; }\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\n\nint per(int a, int b) {\n\tint ans = a % b;\n\tif (ans < 0) { ans += b; }\n\treturn ans;\n}\nvel uni(vel &v) {\n\tsor(v);\n\tvel ans(1, v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tif (v[i] != v[i-1]) { ans.push_back(v[i]); }\n\t}\n\tv = ans;\n\treturn v;\n}\nint s_gcd(int a, int b) {\n\tif (b == 0) { return a; }\n\treturn s_gcd(b, a%b);\n}\nint gcd(int a, int b) {\n\tif (a < b) { swap(a, b); }\n\treturn s_gcd(a, b);\n}\nbool is_prime(int i) {\n\tfor (int j = 2; j*j <= i; j++) {\n\t\tif (i%j == 0) { return false; }\n\t}\n\treturn true;\n}\nint get(int i, int j, vvel &ans) {\n\tint n = ans.size();\n\tif (i < 0 || n <= i || j < 0 || n <= j) { return 1; }\n\treturn ans[i][j];\n}\nint lcm(int a, int b) {\n\treturn a * b / gcd(a, b);\n}\nsigned main() {\n\tstring s; cin >> s;\n\tint n = s.size();\n\tif (n == 1) { cout << 1 << endl; return 0; }\n\tint k; cin >> k;\n\tV<veb> can_use(n, veb(n));\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tcan_use[i][j] = (s[i] == s[n-1-j]);\n\t\t}\n\t}\n\tV<vvel> ans(n,vvel(n, vel(k+1, 0)));\n\tbool fl = false;\n\trep(i, n) {\n\t\tfl =fl || can_use[0][i];\n\t\tif (fl) {\n\t\t\tif (i < n - 1) {\n\t\t\t\tans[0][i][0] = 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans[0][i][0] = 1;\n\t\t\t}\n\t\t}\n\t\trep(use, k) {\n\t\t\tans[0][i][use + 1] = 2;\n\t\t}\n\t}\n\tfl = false;\n\trep(i, n) {\n\t\tfl = fl || can_use[i][0];\n\t\tif (fl) {\n\t\t\tif (i < n - 1) {\n\t\t\t\tans[i][0][0] = 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans[i][0][0] = 1;\n\t\t\t}\n\t\t}\n\t\trep(use, k) {\n\t\t\tans[i][0][use + 1] = 2;\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = 1; j < n; j++) {\n\t\t\trep(use, k+1) {\n\t\t\t\tans[i][j][use] = max(ans[i - 1][j][use], ans[i][j - 1][use]);\n\t\t\t\tif (can_use[i][j] and i+j<n-1) {\n\t\t\t\t\tmmax(ans[i][j][use], ans[i - 1][j - 1][use] + 2);\n\t\t\t\t}\n\t\t\t\telse if(can_use[i][j] and i + j == n - 1){\n\t\t\t\t\tmmax(ans[i][j][use], ans[i - 1][j - 1][use] + 1);\n\t\t\t\t}\n\t\t\t\telse if (use != 0 and i+j<n-1) {\n\t\t\t\t\tmmax(ans[i][j][use], ans[i - 1][j - 1][use-1] + 2);\n\t\t\t\t}\n\t\t\t\telse if (use != 0 and i + j == n - 1) {\n\t\t\t\t\tmmax(ans[i][j][use], ans[i - 1][j - 1][use - 1] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\trep(use, k+1) {\n\t\t\tmmax(ret, ans[i][n-1 - i][use]);\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> vector<T> make_vec(size_t a) { return vector<T>(a); }\ntemplate<class T, class... Ts> auto make_vec(size_t a, Ts... ts) {\n  return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\n\nint main() {\n    string S;\n    int K;\n    cin >> S >> K;\n    int N = (int)S.size();\n    auto dp = make_vec<int>(N+2, N+2, K+2);\n    for (int i = 0; i <= N; ++i) {\n        for (int j = 0; j <= N; ++j) {\n            for (int k = 0; k <= K; ++k) {\n                chmax(dp[i+1][j][k], dp[i][j][k]);\n                chmax(dp[i][j+1][k], dp[i][j][k]);\n                chmax(dp[i+1][j+1][k+1], dp[i][j][k] + 1);\n                if (i < N && N-1-j >= 0 && S[i] == S[N-1-j])\n                    chmax(dp[i+1][j+1][k], dp[i][j][k] + 1);\n            }\n        }\n    }\n    int res = 0;\n    for (int k = 0; k <= K; ++k) {\n        for (int i = 0; i <= N; ++i) chmax(res, dp[i][N-i][k] * 2);\n        for (int i = 0; i < N; ++i) chmax(res, dp[i][N-1-i][k] * 2 + 1);\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long long llong;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nstring s, t;\nint k;\n\nint dp[310][310];\nint dp2[310][310];\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcin >> s;\n\tcin >> k;\n\tt = s;\n\treverse(t.begin(), t.end());\n\tint n = s.size();\n\tfor (int i = 0; i <= n; ++i)\n\t\tfor (int j = 0; j <= n; ++j)\n\t\t\tdp[i][j] = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif (s[i - 1] == t[j - 1]) {\n\t\t\t\tdp[i][j] = dp[i - 1][j - 1] + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n\t\t\t}\n\t\t}\n\tfor (int i = 1; i <= k; ++i) {\n\t\tfor (int i = 0; i <= n; ++i)\n\t\t\tfor (int j = 0; j <= n; ++j)\n\t\t\t\tdp2[i][j] = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\t\tif (s[i - 1] == t[j - 1]) {\n\t\t\t\t\tdp2[i][j] = dp2[i - 1][j - 1] + 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp2[i][j] = max({dp2[i - 1][j], dp2[i][j - 1], dp[i - 1][j - 1] + 1});\n\t\t\t\t}\n\t\t\t}\n\t\tfor (int i = 0; i <= n; ++i)\n\t\t\tfor (int j = 0; j <= n; ++j)\n\t\t\t\tdp[i][j] = dp2[i][j];\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tans = max(ans, 2 * dp[i][n - i]);\n\tfor (int i = 0; i < n; ++i) {\n\t\tans = max(ans, 2 * dp[i][n - 1 - i] + 1);\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n\tstring s;\n\tint k;\n\tcin>>s; cin>>k;\n\tint n=s.size();\n\tint dp[301][301][301]={};\n\tfor(int l=0; l<=k; l++){\n\t\tfor(int i=0; i+1<n; i++){\n\t\t\tdp[l][i][i+1]=1;\n\t\t}\n\t}\n\tfor(int d=2; d<=n; d++){\n\t\tfor(int l=0; l<=k; l++){\n\t\t\tfor(int i=0; i<=n-d; i++){\n\t\t\t\tif(s[i]==s[i+d-1]){\n\t\t\t\t\tdp[l][i][i+d]=max(dp[l][i][i+d], max(dp[l][i][i+d-1], max(dp[l][i+1][i+d], dp[l][i+1][i+d-1]+2)));\n\t\t\t\t}else{\n\t\t\t\t\tdp[l][i][i+d]=max(dp[l][i][i+d], max(dp[l][i][i+d-1], dp[l][i+1][i+d]));\n\t\t\t\t\tif(l>=1) dp[l][i][i+d]=max(dp[l][i][i+d], dp[l-1][i+1][i+d-1]+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int l=0; l<=k; l++){\n\t\tans=max(ans, dp[l][0][n]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include <atcoder/all>\nusing namespace std;\n// using namespace atcoder;\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  os << \"(\" << p.first << \",\" << p.second << \")\";\n  return os;\n}\n#ifdef __LOCAL\n#define debug(x) cerr << __LINE__ << \": \" << #x << \" = \" << (x) << '\\n'\n#define debugArray(x, n)                                      \\\n  cerr << __LINE__ << \": \" << #x << \" = {\";                   \\\n  for (long long hoge = 0; (hoge) < (long long)(n); ++(hoge)) \\\n    cerr << ((hoge) ? \",\" : \"\") << x[hoge];                   \\\n  cerr << \"}\" << '\\n'\n#define debugMatrix(x, h, w)                                         \\\n  cerr << __LINE__ << \": \" << #x << \" =\\n\";                          \\\n  for (long long hoge = 0; (hoge) < (long long)(h); ++(hoge)) {      \\\n    cerr << ((hoge ? \" {\" : \"{{\"));                                  \\\n    for (long long fuga = 0; (fuga) < (long long)(w); ++(fuga))      \\\n      cerr << ((fuga ? \", \" : \"\")) << x[hoge][fuga];                 \\\n    cerr << \"}\" << (hoge + 1 == (long long)(h) ? \"}\" : \",\") << '\\n'; \\\n  }\n#else\n#define debug(x) (void(0))\n#define debugArray(x, n) (void(0))\n#define debugMatrix(x, h, w) (void(0))\n#endif\n\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  string S;\n  cin >> S;\n  int K;\n  cin >> K;\n  int N = S.length();\n  long long dp[N][N][K + 1];\n  for (int i = 0; i < N; i++)\n    for (int k = 0; k <= K; k++) dp[i][i][k] = 1;\n  for (int i = 0; i + 1 < N; i++)\n    for (int k = 0; k <= K; k++)\n      dp[i][i + 1][k] = S[i] == S[i + 1] || k > 0 ? 2 : 1;\n  for (int d = 2; d < N; d++)\n    for (int l = 0; l + d < N; l++) {\n      int r = l + d;\n      for (int k = 0; k <= K; k++) {\n        dp[l][r][k] = max(dp[l + 1][r][k], dp[l][r - 1][k]);\n        if (S[l] == S[r]) {\n          dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k] + 2);\n        } else if (k > 0) {\n          dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k - 1] + 2);\n        }\n      }\n    }\n  cout << dp[0][N - 1][K] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef pair<ll, ll> l4;\n\nconst int N = 301;\nchar s[N];\nint k;\nint d[N][N][N];\ninline void Max(int &x, int y)\n{\n  if (x < y) x = y;\n}\nint dp(int l, int r, int k)\n{\n  if (l > r) return 0;\n  int &ret = d[l][r][k];\n  if (ret == -1)\n    {\n      if (l == r) return ret = 1;\n      if (s[l] == s[r]) return ret = 2 + dp(l+1, r-1, k);\n      ret = 0;\n      Max(ret, dp(l, r-1, k));\n      Max(ret, dp(l+1, r, k));\n      if (k != 0)\n        Max(ret, 2 + dp(l+1, r-1, k-1));\n    }\n  return ret;\n}\nint main()\n{\n  scanf(\"%s %d\", s, &k);\n  memset(d, -1, sizeof(d));\n  printf(\"%d\\n\", dp(0, strlen(s)-1, k));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(register int i=a;i<=b;++i)\n#define rpd(i,a,b) for(register int i=a;i>=b;--i)\n#define rep1(i,x) for(register int i=head[x];i;i=nxt[i])\ntypedef long long ll;\nconst int N=300+5;\nusing namespace std;\ninline int read(){\n    int x=0,f=1;char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n    while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nstring s;int n,m;int f[N][N][N];\nvoid Max(int &x,int y){x=max(x,y);}\nint main(){\n    cin>>s;s=' '+s;\n    n=s.length()-1;m=read();\n    rep(i,1,n)rep(j,0,m)f[i][i][j]=1;\n    rep(d,2,n)rep(i,1,n){\n        int j=i+d-1;if(j>n)break;\n        rep(k,0,m){\n            if(k)Max(f[i][j][k],f[i][j][k-1]);\n            Max(f[i][j][k],f[i+1][j][k]);\n            Max(f[i][j][k],f[i][j-1][k]);\n            if(s[i]==s[j])Max(f[i][j][k],f[i+1][j-1][k]+2);\n            else if(k)Max(f[i][j][k],f[i+1][j-1][k-1]+2);\n        }\n    }\n    printf(\"%d\\n\",f[1][n][m]);\n    //system(\"pause\");\n    return 0;\n}\n/*\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define llint long long \n#define inf 1000000000000000000\n\nusing namespace std;\n\nstring s;\nllint N, K;\nllint dp[305][305][305];\n\nint main(void)\n{\ncin >> s >> K;\nN = s.size();\ns = \" \" + s;\n\nfor(llint i = 0; i <= N; i++){\nfor(llint j = 0; j <= N; j++){\nfor(llint k = 0; k <= K; k++){\ndp[i][j][k] = -inf;\n}\n}\n}\nfor(llint i = 0; i <= N; i++) dp[i][0][0] = dp[0][i][0] = 0;\n\n\nfor(llint i = 1; i <= N; i++){\nfor(llint j = 1; j <= N; j++){\nfor(llint k = 0; k <= K; k++){\n\nif(i+j > N+1){\n\tcontinue;\n}\n\nif(s[i] == s[N-j+1]){\ndp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k] + 1);\n}\nelse{\ndp[i][j][k] = max(dp[i][j][k], max(dp[i-1][j][k], dp[i][j-1][k]));\nif(k > 0){\n\tdp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k-1] + 1);\n\tdp[i][j][k] = max(dp[i][j][k], max(dp[i-1][j][k-1], dp[i][j-1][k-1]));\n}\n}\n\n\n}\n}\n}\n\n/*for(llint k = 0; k <= K; k++){\nfor(llint i = 0; i <= N; i++){\nfor(llint j = 0; j <= N; j++){\ncout << dp[i][j][k] << \" \";\n}cout << endl;\n}cout << endl;\n}*/\n\nllint ans = 0;\nfor(llint k = 0; k <= K; k++){\nfor(llint i = 0; i <= N; i++){\nfor(llint j = 0; j <= N; j++){\nif(i+j != N+1) continue;\nllint tmp = dp[i][j][k] * 2;\nif(s[i] == s[N-j+1]) tmp--;\nans = max(ans, tmp);\n}\n}\n}\n\ncout << ans << endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n\t#include <boost/multiprecision/cpp_int.hpp>\n\t#include <boost/multiprecision/cpp_dec_float.hpp>\n\tusing bll = boost::multiprecision::cpp_int;\n\tusing bdouble = boost::multiprecision::cpp_dec_float_100;\n#endif\n#ifdef LOCAL_DEV\n\tvoid debug_impl() { std::cerr << '\\n'; }\n\ttemplate<typename Head, typename... Tail> void debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head << (sizeof...(tail) ? \",\" : \"\"); debug_impl(tail...); }\n\t#define debug(...) do { std::cerr << \"(\" << #__VA_ARGS__ << \") =\"; debug_impl(__VA_ARGS__); } while (false)\n#else\n\t#define debug(...) do {} while (false)\n#endif\n#ifdef LOCAL_TEST\n\t#define BOOST_STACKTRACE_USE_ADDR2LINE\n\t#define BOOST_STACKTRACE_ADDR2LINE_LOCATION /usr/local/opt/binutils/bin/addr2line\n\t#define _GNU_SOURCE\n\t#include <boost/stacktrace.hpp>\n\tnamespace std {\n\t\ttemplate<typename T> class dvector : public std::vector<T> {\n\t\tpublic:\n\t\t\tdvector() : std::vector<T>() {}\n\t\t\texplicit dvector(size_t n, const T& value = T()) : std::vector<T>(n, value) {}\n\t\t\tdvector(const std::vector<T>& v) : std::vector<T>(v) {}\n\t\t\tdvector(const std::initializer_list<T> il) : std::vector<T>(il) {}\n\t\t\tdvector(const typename std::vector<T>::iterator first, const typename std::vector<T>::iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const std::string::iterator first, const std::string::iterator last) : std::vector<T>(first, last) {}\n\t\t\tT& operator[](size_t n) {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst T& operator[](size_t n) const {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\tclass dbool {\n\tprivate:\n\t\tbool boolvalue;\n\tpublic:\n\t\tdbool() : boolvalue(false) {}\n\t\tdbool(bool b) : boolvalue(b) {}\n\t\tdbool(const dbool& b) : boolvalue(b.boolvalue) {}\n\t\toperator bool&() { return boolvalue; }\n\t\toperator const bool&() const { return boolvalue; }\n\t};\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::dvector<T>& v) {\n\t\tfor (size_t i = 0; i < v.size(); ++i){ s << v[i]; if (i < v.size() - 1) s << \"\\t\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::dvector<std::dvector<T>>& vv) {\n\t\ts << \"\\n\"; for (size_t i = 0; i < vv.size(); ++i){ s << vv[i] << \"\\n\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::set<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::multiset<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate <typename T, size_t N> std::ostream& operator<<(std::ostream& s, const std::array<T, N>& a) {\n\t\ts << \"{ \"; for (size_t i = 0; i < N; ++i){ s << a[i] << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::map<T1, T2>& m) {\n\t\ts << \"{\\n\"; for (auto itr = m.begin(); itr != m.end(); ++itr){ s << \"\\t\" << (*itr).first << \" : \" << (*itr).second << \"\\n\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::pair<T1, T2>& p) {\n\t\treturn s << \"(\" << p.first << \", \" << p.second << \")\"; }\n\t#define vector dvector\n\t#define bool dbool\n\tclass SIGFPE_exception : std::exception {};\n\tclass SIGSEGV_exception : std::exception {};\n\tvoid catch_SIGFPE(int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGFPE_exception();\t}\n\tvoid catch_SIGSEGV(int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGSEGV_exception(); }\n\tsigned convertedmain();\n\tsigned main() { signal(SIGFPE, catch_SIGFPE); signal(SIGSEGV, catch_SIGSEGV); return convertedmain(); }\n\t#define main() convertedmain()\n#endif\n//#define int long long\nusing ll = long long;\n//constexpr int INF = 1e9;//INT_MAX=(1<<31)-1=2147483647\nconstexpr ll INF = (ll)1e18;//(1LL<<63)-1=9223372036854775807\nconstexpr ll MOD = 998244353;//(ll)1e9 + 7;\nconstexpr double EPS = 1e-9;\nconstexpr ll dx[4] = {1LL, 0LL, -1LL, 0LL};\nconstexpr ll dy[4] = {0LL, 1LL, 0LL, -1LL};\nconstexpr ll dx8[8] = {1LL, 0LL, -1LL, 0LL, 1LL, 1LL, -1LL, -1LL};\nconstexpr ll dy8[8] = {0LL, 1LL, 0LL, -1LL, 1LL, -1LL, 1LL, -1LL};\n#define rep(i, n)   for(ll i=0, i##_length=(n); i< i##_length; ++i)\n#define repeq(i, n) for(ll i=1, i##_length=(n); i<=i##_length; ++i)\n#define rrep(i, n)   for(ll i=(n)-1; i>=0; --i)\n#define rrepeq(i, n) for(ll i=(n)  ; i>=1; --i)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\nvoid p() { std::cout << '\\n'; }\ntemplate<typename Head, typename... Tail> void p(Head head, Tail... tail) { std::cout << head << (sizeof...(tail) ? \" \" : \"\"); p(tail...); }\ntemplate<typename T> inline void pv(std::vector<T>& v) { for(ll i=0, N=v.size(); i<N; i++) std::cout << v[i] << \" \\n\"[i==N-1]; }\ntemplate<typename T> inline T gcd(T a, T b) { return b ? gcd(b,a%b) : a; }\ntemplate<typename T> inline T lcm(T a, T b) { return a / gcd(a,  b) * b; }\ntemplate<typename T> inline bool chmax(T& a, T b) { return a < b && (a = b, true); }\ntemplate<typename T> inline bool chmin(T& a, T b) { return a > b && (a = b, true); }\ntemplate<typename T> inline void uniq(std::vector<T>& v) { v.erase(std::unique(v.begin(), v.end()), v.end()); }\n\n/*-----8<-----template-----8<-----*/\nnamespace makevectordetail {\n\ttemplate <typename Tp, size_t N>\n\tstd::vector<Tp> make_vector(\n\t\t\tstd::vector<size_t>& sizes,\n\t\t\ttypename std::enable_if<(N == 1), Tp const&>::type x\n\t) {\n\t\treturn std::vector<Tp>(sizes[0], x);\n\t}\n\ttemplate <typename Tp, size_t N>\n\tauto make_vector(\n\t\t\tstd::vector<size_t>& sizes,\n\t\t\ttypename std::enable_if<(N > 1), Tp const&>::type x\n\t) {\n\t\tsize_t size = sizes[N-1];\n\t\tsizes.pop_back();\n\t\treturn std::vector<decltype(make_vector<Tp, N-1>(sizes, x))>(\n\t\t\t\tsize, make_vector<Tp, N-1>(sizes, x)\n\t\t);\n\t}\n}\ntemplate <typename Tp, typename sizetype, size_t N>\nauto make_vector(sizetype const(&sizes)[N], Tp const& x = Tp()) {\n\tstd::vector<size_t> s(N);\n\tfor (size_t i = 0; i < N; ++i) s[i] = sizes[N-i-1];\n\treturn makevectordetail::make_vector<Tp, N>(s, x);\n}\n//vector<vector<vector<ll>>> v = make_vector<ll>({1, 2, 3}, 0LL);\n/*-----8<-----library-----8<-----*/\n\nstring S;\nll K;\n//dp[l][r][k] 文字変更をk回行った状態で[l,r]間の回文の最大長\nvector<vector<vector<ll>>> dp;\nll f(ll l,ll r,ll k){\n\tif(dp[l][r][k])return dp[l][r][k];\n\t//1文字\n\tif(l==r)return dp[l][r][k]=1;\n\t//2文字\n\tif(r-l==1){\n\t\t//元から同じ || 変更して同じにした\n\t\tif(S[l]==S[r] || k<K)return dp[l][r][k]=2;\n\t\treturn dp[l][r][k]=1;\n\t}\n\n\tll ans=0;\n\t//左右に関係ない文字を追加しても回文長は同じ\n\tchmax(ans, f(l+1,r,k));\n\tchmax(ans, f(l,r-1,k));\n\n\tif(S[l]==S[r]){\n\t\t//文字が同じ → 回文長に2加算\n\t\tchmax(ans, f(l+1,r-1,k)+2);\n\t}else if(k<K){\n\t\t//文字変更して無理矢理一緒にする\n\t\tchmax(ans, f(l+1,r-1,k+1)+2);\n\t}\n\n\treturn dp[l][r][k]=ans;\n}\n\nvoid solve() {\n\t\n\tcin>>S>>K;\n\tdp = make_vector<ll>({S.size()+1, S.size()+1, (size_t)K+1}, 0);\n\n\tf(0, S.size()-1, 0);\n\tll ans=0;\n\trep(i,K+1)chmax(ans, dp[0][S.size()-1][i]);\n\tp(ans);\n}\n\nsigned main() {\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N = 305;\n\nint dp[2][MAX_N][MAX_N];\nchar S[MAX_N];\n\nint main() {\n  scanf(\"%s\", S + 1);\n  int N = strlen(S + 1), K;\n  scanf(\"%d\", &K);\n\n  memset(dp, -0x3f, sizeof dp);\n\n  int o = 0, p, result = 1;\n  for (int i = 1; i <= N + 1; ++i) dp[0][i][0] = 0;\n  \n  for (int i = 1; i <= N; ++i) {\n    p = o, o ^= 1;\n    memset(dp[o], -0x3f, sizeof dp[o]);\n    dp[o][N + 1][0] = 0;\n    for (int j = N; j > i; --j)\n      for (int k = 0; k <= K; ++k) {\n\tdp[o][j][k] = max(dp[o][j + 1][k], dp[p][j][k]);\n\tif (S[i] == S[j]) dp[o][j][k] = max(dp[o][j][k], dp[p][j + 1][k] + 1);\n\telse if (k > 0) dp[o][j][k] = max(dp[o][j][k], dp[p][j + 1][k - 1] + 1);\n      }\n    for (int k = 0; k <= K; ++k) {\n      result = max(result, dp[o][i + 1][k] * 2);\n      result = max(result, dp[o][i + 2][k] * 2 + 1);\n    }\n  }\n\n  printf(\"%d\\n\", result);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL111\n\t#define _GLIBCXX_DEBUG\n#else\n\t#define NDEBUG\n#endif\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nconst int INF = 1e9;\nusing namespace std;\ntemplate<typename T, typename U> ostream& operator<< (ostream& os, const pair<T,U>& p) { os << '(' << p.first << ' ' << p.second << ')'; return os; }\n\n#define endl '\\n'\n#define ALL(a)  (a).begin(),(a).end()\n#define SZ(a) int((a).size())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#ifdef LOCAL111\n\t#define DEBUG(x) cout<<#x<<\": \"<<(x)<<endl\n\ttemplate<typename T> void dpite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\n#else\n\t#define DEBUG(x) true\n\ttemplate<typename T> void dpite(T a, T b){ return; }\n#endif\n#define F first\n#define S second\n#define SNP string::npos\n#define WRC(hoge) cout << \"Case #\" << (hoge)+1 << \": \"\ntemplate<typename T> void pite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\ntemplate<typename T> bool chmax(T& a, T b){if(a < b){a = b; return true;} return false;}\ntemplate<typename T> bool chmin(T& a, T b){if(a > b){a = b; return true;} return false;}\n\ntypedef long long int LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> P;\n\nvoid ios_init(){\n\t//cout.setf(ios::fixed);\n\t//cout.precision(12);\n#ifdef LOCAL111\n\treturn;\n#endif\n\tios::sync_with_stdio(false); cin.tie(0);\n}\n\n//;ibrary\nstring lcs(string s, string t){\n\tint n = s.size();\n\tint m = t.size();\n\tarray<int,3> dx({-1,0,-1});\n\tarray<int,3> dy({-1,-1,0});\n\tvector<vector<int>> dp(n+1,vector<int>(m+1));\n\tvector<vector<int>> pre(n+1,vector<int>(m+1,-1));\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < m; ++j) {\n\t\t\tint val = 0;\n\t\t\tif(s[i] == t[j] and val <= dp[i][j]+1){\n\t\t\t\tval = dp[i][j]+1;\n\t\t\t\tpre[i+1][j+1] = 0;\n\t\t\t}\n\t\t\tif(val <= dp[i+1][j]){\n\t\t\t\tval = dp[i+1][j];\n\t\t\t\tpre[i+1][j+1] = 1;\n\t\t\t}\n\t\t\tif(val <= dp[i][j+1]){\n\t\t\t\tval = dp[i][j+1];\n\t\t\t\tpre[i+1][j+1] = 2;\n\t\t\t}\n\t\t\tdp[i+1][j+1] = val;\n\t\t}\n\t}\n\tstring res;\n\tint x = n, y = m;\n\twhile(x != 0 and y != 0){\n\t\tint tmp = pre[x][y];\n\t\tif(tmp == 0){\n\t\t\tassert(s[x-1] == t[y-1]);\n\t\t\tres += s[x-1];\n\t\t}\n\t\tx += dx[tmp];\n\t\ty += dy[tmp];\n\t}\n\tassert((int)res.size() == dp[n][m]);\n\treverse(res.begin(), res.end());\n\treturn res;\n}\n//liblary\n\nint main()\n{\n\tios_init();\n\tstring s;\n\twhile(cin >> s) {\n\n\t\tint k;\n\t\tcin >> k;\n\t\tstring t = s;\n\t\treverse(ALL(t));\n\t\tDEBUG(lcs(s, t));\n\t\tint n = s.size();\n\t\tint m = t.size();\n\t\tarray<int,3> dx({-1,0,-1});\n\t\tarray<int,3> dy({-1,-1,0});\n\t\tvector<vector<int>> dp(n+1,vector<int>(m+1));\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = 0; j < m; ++j) {\n\t\t\t\tint val = 0;\n\t\t\t\tif(s[i] == t[j] and val <= dp[i][j]+1){\n\t\t\t\t\tval = dp[i][j]+1;\n\t\t\t\t}\n\t\t\t\tif(val <= dp[i+1][j]){\n\t\t\t\t\tval = dp[i+1][j];\n\t\t\t\t}\n\t\t\t\tif(val <= dp[i][j+1]){\n\t\t\t\t\tval = dp[i][j+1];\n\t\t\t\t}\n\t\t\t\tdp[i+1][j+1] = val;\n\t\t\t}\n\t\t}\n\t\tint ans = 1;\n\t\tREP(i, SZ(s)) {\n\t\t\tint tmp = dp[i+1][n-i];\n\t\t\tDEBUG(i+1); DEBUG(n-i);\n\t\t\tint rem = min(i+1, n-i)-tmp;\n\t\t\tint val = tmp + min(rem, k);\n\t\t\tchmax(ans, val*2-1);\n\t\t}\n\t\t// REP(i, SZ(s)+1) {\n\t\t// \tint tmp = dp[i][n-i];\n\t\t// \tint rem = min(i, n-i)-tmp;\n\t\t// \tint val = tmp + min(rem, k);\n\t\t// \tchmax(ans, val*2);\n\t\t// }\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nint main() {\n    int N, K;\n    string S, T;\n    cin >> S;\n    N = (int)S.size();\n    cin >> K;\n    T = S;\n    reverse(T.begin(), T.end());\n    \n    vector<vector<vector<int>>> dp(N+1, vector<vector<int>>(N+1, vector<int>(K+1, 0)));\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            bool same;\n            if (S[i-1] == T[j-1]) same = true;\n            else same = false;\n            if (same) {\n                for (int k = 0; k <= K; k++) {\n                    dp[i][j][k] = max(max(dp[i-1][j][k], dp[i][j-1][k]), dp[i-1][j-1][k]+1);\n                }\n            }else {\n                for (int k = 0; k <= K; k++) {\n                    dp[i][j][k] = max(dp[i-1][j][k], dp[i][j-1][k]);\n                    if (k > 0) dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k-1]+1);\n                }\n            }\n        }\n    }\n    int ans = 0;\n    if (N%2 == 0) {\n        for (int i = 1; i <= N; i++) {\n            for (int j = 0; j <= K; j++) {\n                ans = max(ans, 2*dp[i][N-i][j]);\n                if (i < N) ans = max(ans, 2*dp[i][N-1-i][j]+1);\n            }\n        }\n    }else {\n        for (int i = 1; i < N; i++) {\n            for (int j = 0; j <= K; j++) {\n                ans = max(ans, 2*dp[i][N-1-i][j]+1);\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 305;\ntypedef long long ll;\n\nstring s;\nint n, m, f[N][N][N];\n\nint Dfs(int l, int r, int p) {\n\tif(f[l][r][p]) return f[l][r][p];\n\tif(l == r) return f[l][r][p] = 1;\n\tif(l + 1 == r) {\n\t\tif(p || s[l] == s[r]) return f[l][r][p] = 2;\n\t\telse return f[l][r][p] = 1;\n\t}\n\tif(s[l] == s[r]) f[l][r][p] = max(f[l][r][p], Dfs(l + 1, r - 1, p) + 2);\n\telse if(p) f[l][r][p] = max(f[l][r][p], Dfs(l + 1, r - 1, p - 1) + 2);\n\treturn f[l][r][p] = max(f[l][r][p], max(Dfs(l, r - 1, p), Dfs(l + 1, r, p)));\n}\n\nint main() {\n\tcin>>s>>m;\n\tn = s.size();\n\tcout<<Dfs(0, n - 1, m)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n\nint lcs(string s, string rs) {\n\tint c[1000][1000];\n\tint m = s.size();\n\tint n = rs.size();\n\tint maxl = 0;\n\ts = s.insert(0,\" \");\n\trs = rs.insert(0, \" \");\n\tfor (int i = 1; i <= m; i++)c[i][0] = 0;\n\tfor (int j = 1; j <= n; j++)c[0][j] = 0;\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (s[i] == rs[j]) {\n\t\t\t\tc[i][j] = c[i - 1][j - 1] + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[i][j] = max(c[i - 1][j], c[i][j - 1]);\n\t\t\t}\n\t\t\tmaxl = max(maxl, c[i][j]);\n\t\t}\n\t}\n\treturn maxl;\n}\n\n\nint main() {\n\tstring s,rs;\n\tint k, maxl;\n\tcin >> s >> k;\n\trs = s;\n\treverse(rs.begin(), rs.end());\n\n\tmaxl = lcs(s, rs);\n\n\tif (maxl <= s.size() - k) cout << maxl + k << endl;\n\telse cout << s.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint f[305][305][305],n,K;\nchar s[305];\ninline int max(int x,int y){\n\treturn x>y?x:y;\n}\nint main(){\n  \tscanf(\"%s%d\",s+1,&K);\n\tn=strlen(s+1);\n  \tfor(int i=1;i<=n;i++) for(int k=0;k<=K;k++) f[i][i][k]=1;\n  \tfor(int l=2;l<=n;l++){\n      \tfor(int i=1;i+l-1<=n;i++){\n          \tint j=i+l-1;\n          \tfor(int k=0;k<=K;k++){\n             \tf[i][j][k]=max(f[i+1][j][k],f[i][j-1][k]);\n                if(k) f[i][j][k]=max(f[i][j][k],f[i+1][j-1][k-1]+2);\n                if(s[i]==s[j]) f[i][j][k]=max(f[i][j][k],f[i+1][j-1][k]+2);\n          \t}\n    \t}\n  \t}\n  printf(\"%d\\n\",f[1][n][K]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nstring s;\nlong long k;\n\nlong long dp[301][301][301];\nint n;\n\nint main()\n{\n    cin >> s;\n    cin >> k;\n    n = s.size();\n    for (int i = 0; i < n; i++)\n    {\n        if (i > 0) dp[i][i - 1][0] = 0;\n        dp[i][i][0] = 1;\n    }\n    long long as = 0;\n    for (int len = 2; len <= n; len++)\n    {\n        for (int i = 0; i + len - 1 < n; i++)\n        {\n            int j = i + len - 1;\n            for (int e = 0; e <= k; e++)\n            {\n                if (s[i] == s[j])\n                {\n                    dp[i][j][e] = max(dp[i][j][e], dp[i + 1][j - 1][e] + 2);\n                }\n                else\n                {\n                    dp[i][j][e] = max(dp[i][j][e], dp[i + 1][j - 1][e - 1] + 2);\n                }\n                dp[i][j][e] = max(dp[i][j][e], dp[i][j - 1][e]);\n                dp[i][j][e] = max(dp[i][j][e], dp[i + 1][j][e]);\n                as = max(as, dp[i][j][e]);\n            }\n        }\n    }\n    cout << as;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\nstring s;\nint K;\nint n;\n\nint dp[310][310][310];\n\nint calc(int l, int r, int k) {\n    if(dp[l][r][k] != INF) return dp[l][r][k];\n    int& ret = dp[l][r][k];\n    ret = 0;\n    int len = r - l;\n    if(len == 1) return ret = 1;\n    else if(len == 2) {\n        if(s[l] != s[r-1]) ret = (k > 0 ? 2 : 1);\n        else ret = 2;\n        return ret;\n    }\n    else { // len >= 3\n        if(s[l] == s[r-1]) ret = calc(l+1, r-1, k) + 2;\n        else {\n            ret = max({ret, calc(l+1, r, k), calc(l, r-1, k)});\n            if(k > 0) {\n                ret = max(ret, calc(l+1, r-1, k-1) + 2);\n            }\n        }\n    }\n    return ret;\n}\n\nint main(){\n    cin >> s >> K;\n    n = s.size();\n    rep(i, 310) rep(j, 310) rep(k, 310) dp[i][j][k] = INF;\n    rep(i, n) {\n        dp[i][i+1][0] = 1;\n    }\n    rep(i, n-1) {\n        if(s[i] != s[i+1]) {\n            dp[i][i+2][0] = 1;\n            dp[i][i+2][1] = 2;\n        }\n        else {\n            dp[i][i+2][0] = 2;\n        }\n    }\n    cout << calc(0, n, K) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n//\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//\nconstexpr ll MOD=1e9+7;\n//constexpr ll MOD=998244353;\n//constexpr ll MOD=10000000;\n//constexpr ll MOD=1e5;\nconstexpr ll MAX=3e6;\nconstexpr ll INF=(1ll<<60);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate<typename T>\nstruct Segment_tree{\n    ll N;\n    T mem;\n    vector<T> node;\n    Segment_tree(vector<T> &X,T m):mem(m){\n        ll sz=X.size();\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mem);\n        rep(i,0,sz) node[N-1+i]=X[i];\n        per(i,N-2,0){\n            node[i]=Compare(node[i*2+1],node[i*2+2]);\n        }\n    }\n    T Compare(T &A,T &B){\n        return std::max(A,B);\n    }\n    void update(ll X,T val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=Compare(node[X*2+1],node[X*2+2]);\n        }\n    }\n    T Query(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mem;\n        if(a<=l&&r<=b) return node[now];\n        auto vl=Query(a,b,now*2+1,l,(l+r)/2),vr=Query(a,b,now*2+2,(l+r)/2,r);\n        return Compare(vl,vr);\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,int a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nvoid comp(vi &A){\n    std::map<ll,ll> mem;\n    rep(i,0,A.size()) mem[A[i]]=0;\n    ll cnt=0;\n    for(auto &p:mem) p.second=cnt++;\n    rep(i,0,A.size()) A[i]=mem[A[i]];\n}\nll RLCS(string S){\n    string T=S;\n    reverse(ALL(T));\n    ll N=S.size();\n    vii dp(N+1,vi(N+1));\n    REP(i,0,N){\n        REP(j,0,N){\n            if(!i){\n                if(j) dp[i][j]=dp[i][j-1];\n            }\n            else if(!j){\n                dp[i][j]=dp[i-1][j];\n            }\n            else{\n                dp[i][j]=std::max(dp[i][j-1],dp[i-1][j]);\n                if(S[i-1]==T[j-1]) dp[i][j]=std::max(dp[i][j],dp[i-1][j-1]+1);\n            }\n        }\n    }\n    return dp[N][N];\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    string S; cin>>S;\n    ll K,N=S.size(); cin>>K;\n    string T=S; reverse(ALL(T));\n    vector<vii> dp(N/2+1,vii(N/2+1,vi(K+1,INF)));\n    dp[0][0][0]=0;\n    vii mem(26);\n    rep(i,0,N/2) mem[T[i]-'a'].pb(i+1);\n    rep(i,0,N/2){\n        REP(j,0,N/2){\n            REP(k,0,K) dp[i+1][j][k]=dp[i][j][k];\n        }\n        rep(j,0,N/2){\n            REP(k,0,K){\n                if(dp[i][j][k]==INF) continue;\n                ll X=disup(mem[S[i]-'a'],dp[i][j][k]);\n                if(X<mem[S[i]-'a'].size()){\n                    ll Y=mem[S[i]-'a'][X];\n                    dp[i+1][j+1][k]=std::min(dp[i+1][j+1][k],Y);\n                }\n                if(dp[i][j][k]<N/2&&k<K){\n                    dp[i+1][j+1][k+1]=std::min(dp[i+1][j+1][k+1],dp[i][j][k]+1);\n                }\n            }\n        }\n        REP(j,0,N/2){\n            REP(k,1,K) dp[i+1][j][k]=std::min(dp[i+1][j][k],dp[i+1][j][k-1]);\n        }\n    }\n    ll ans=0;\n    per(i,N/2,0){\n        ll cnt=0;\n        per(j,N/2,0){\n            if(dp[i][j][K]!=INF){\n                ll left=i,right=N-1-dp[i][j][K];\n                if(left<=right){\n                    string P=S.substr(left,right-left+1);\n                    ans=std::max(ans,j*2+RLCS(P));\n                }\n                else{\n                    ans=std::max(ans,j*2);\n                }\n                cnt++;\n                if(cnt==30) break;\n            }\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tstring s;\n\tcin >> s;\n\tcin >> K;\n\tN = s.size();\n\tvector<vector<vector<int>>>dp(N, vector<vector<int>>(N, vector<int>(K + 1, MOD)));\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tfor (int k = 0; k <= K; k++) {\n\t\t\t\tdp[i][j][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j <= K; j++) {\n\t\t\tdp[i][i][j] = 1;\n\t\t}\n\t}\n\tint ans = 1;\n\tfor (int i = 1; i < N; i++) {\n\t\tfor (int j = 0; j + i < N; j++) {\n\t\t\tfor (int k = 0; k <= K; k++) {\n\t\t\t\tif (s[j] == s[j + i]) {\n\t\t\t\t\tdp[j][j + i][k] = dp[j + 1][j + i - 1][k] + 2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[j][j + i][k] = max(dp[j + 1][j + i][k], dp[j][j + i - 1][k]);\n\t\t\t\t\tif (k)dp[j][i + j][k] = max(dp[j][j + i][k], dp[j + 1][j + i - 1][k - 1] + 2);\n\t\t\t\t}\n\t\t\t\tans = max(ans, dp[j][i + j][k]);\n\t\t\t\t//cout << j << \" \" << j + i << \" \" << k << \" \" << dp[j][j + i][k] << endl;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int maxn = 310;\n\nusing namespace std;\n\nint n,K,f[maxn][maxn][maxn];\nstring t;\n\nint main() {\n   // freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin>>t;\n    cin>>K;\n    n= t.length();\n    for (int i=n-1;i>=0;i--)\n        for (int j=i;j<n;j++)\n            for (int k=0;k<=K;k++) {\n                    if (i==j) {\n                        f[i][j][k] = 1;\n                        continue;\n                    }\n                    if (i+1==j) {\n                        f[i][j][k] = ((t[i] == t[j] || k>0) ? 2 : 1);\n                        continue;\n                    }\n                    f[i][j][k] = max(f[i+1][j][k], f[i][j-1][k]);\n                    if (t[i]==t[j]) f[i][j][k] = max(f[i][j][k], f[i+1][j-1][k] + 2);\n                    else if (k>0) f[i][j][k] = max(f[i][j][k], f[i+1][j-1][k-1] +2);\n            }\n    cout<<f[0][n-1][K]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\nusing namespace std;\n#define MN 305\n#define inf 1e12\nstring a;\nint k,len;\nvoid rw(int &x,int y){if(y>x)x=y;}\nint f(int l,int r,int k){\n\tif(l<0||r<0||l>len||r>len||l>r||k<0) return -inf;\n\tif(l==r) return 1;\n\tint res=-inf;\n\trw(res,f(l+1,r-1,a[l]==a[r]?k:k-1)+2);\n\trw(res,f(l+1,r,k));\n\trw(res,f(l,r-1,k));\n\treturn res;\n}\nint main(){\n\tcin>>a>>k;\n\tprintf(\"%d\\n\",f(0,len=a.size()-1,k));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint D[333][333][333];\nchar str[333];\nint n, k;\n\nint f(int l, int r, int t)\n{\n\tif(l >= r) return l == r;\n\t\n\tif(D[l][r][t]) return D[l][r][t];\n\t\n\tint ret = max(f(l+1, r, t), f(l, r-1, t));\n\tif(str[l] == str[r]) ret = max(ret, f(l+1, r-1, t) + 2);\n\telse if(t < k) ret = max(ret, f(l+1, r-1, t+1) + 2);\n\t\n\treturn D[l][r][t] = ret;\n}\n\nint main()\n{\n\tscanf(\"%s%d\", str, &k);\n\t\n\tfor(;str[n];n++);\n\t\n\tprintf(\"%d\\n\", f(0, n-1, 0));\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <cassert>\n#include <sstream>\n#include <fstream>\n#include <functional>\n#include <set>\n#include <bitset>\n#include <string>\n#include <utility>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <map>\n#else\n#include <bits/stdc++.h>\n#endif\n\n#ifdef DEBUG\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\n#define rep(i, n) for (int i = 0, i##_end_ = (n); i < i##_end_; ++i)\n#define per(i, n) for (int i = (n) - 1; i >= 0; --i)\n#define forn(i, l, r) for (int i = (l), i##_end_ = (r); i <= i##_end_; ++i)\n#define nrof(i, r, l) for (int i = (r), i##_end_ = (l); i >= i##_end_; --i)\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define SZ(x) (int)((x).size())\n#define ALL(x) (x).begin(), (x).end()\n\nusing namespace std;\n\ntypedef vector<int> vi;\n\ntypedef pair<int, int> pii;\n\ntypedef long long LL;\n\ntemplate<typename T> inline bool chkmax(T &x, const T &y) {\n\treturn x < y ? x = y, 1 : 0;\n}\n\ntemplate<typename T> inline bool chkmin(T &x, const T &y) {\n\treturn x > y ? x = y, 1 : 0;\n}\n\nint n, k;\nstring s;\n\nvoid transfer(vector< vector<int> > &dp) {\n\tauto pd = dp;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = n - 1; ~j; --j) {\n\t\t\tdp[i + 1][j + 1] = max(dp[i + 1][j + 2], dp[i][j + 1]);\n\t\t\tif(s[i] == s[j]) {\n\t\t\t\tchkmax(dp[i + 1][j + 1], dp[i][j + 2] + 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchkmax(dp[i + 1][j + 1], pd[i][j + 2] + 1);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tcin >> s;\n\tn = s.size(), k;\n\tcin >> k;\n\tvector< vector<int> > dp(n + 2, vector<int>(n + 2, 0));\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = n - 1; ~j; --j) {\n\t\t\tdp[i + 1][j + 1] = max(dp[i + 1][j + 2], dp[i][j + 1]);\n\t\t\tif(s[i] == s[j]) {\n\t\t\t\tchkmax(dp[i + 1][j + 1], dp[i][j + 2] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int _k = 1; _k <= k; ++_k) {\n\t\ttransfer(dp);\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= n + 1; ++i) {\n\t\tfor (int j = i + 1; j <= n + 1; ++j) {\n\t\t\tchkmax(ans, dp[i][j] * 2);\n\t\t}\n\t\tif(i >= 1 && i <= n) {\n\t\t\tchkmax(ans, dp[i - 1][i + 1] * 2 + 1);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\ntypedef long long ll;\nconst int Imx=2147483647;\nconst ll Lbig=2e18;\nconst int mod=1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==' '||c=='\\n')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=_buff.get();\n\tif(c=='-')ng=1,c=_buff.get();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c<=32)c=_buff.get();return c;}\nll qpow(ll x,ll k){return k==0?1:1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nchar s[311];\nint n,k;\nint dp[305][305][305];\nvoid upd(int &x,int v){x=max(x,v);}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tcin>>k;\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=n;j>=i;j--)\n\t\t{\n\t\t\tfor(int t=0;t<=k;t++)\n\t\t\t{\n\t\t\t\tint cur=dp[i][j][t];\n\t\t\t\tupd(ans,cur+(s[i]==s[j])*2-(i==j));\n\t\t\t\tif(i<j)\n\t\t\t\t{\n\t\t\t\t\tupd(dp[i+1][j][t],cur);\n\t\t\t\t\tupd(dp[i][j-1][t],cur);\n\t\t\t\t\tupd(dp[i+1][j-1][t],cur+(s[i]==s[j])*2-(i==j));\n\t\t\t\t\tif(t<k)upd(dp[i+1][j-1][t+1],cur+2-(i==j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\n\nint main(){\n    string s;\n    cin>>s;\n    vector<ll> Mnext(26,0);\n    vector<vector<ll>> back(s.size()+1,Mnext);\n    for(int i=0;i<s.size();i++){\n        back[i+1]=Mnext;\n        Mnext[s[i]-'a']=i+1;\n    }\n    for(int i=0;i<26;i++){Mnext[i]=s.size();}\n    vector<vector<ll>> next(s.size()+1,Mnext);\n    for(ll i=s.size()-1;i>=0;i--){\n        next[i]=Mnext;\n        Mnext[s[i]-'a']=i;\n    }\n    ll k;\n    cin>>k;\n    ll ans=0;\n    vector<vector<vector<ll>>> dp(s.size()+1,vector<vector<ll>>(s.size()+1,vector<ll>(k+1,0)));\n    for(int i=1;i<=s.size();i++){\n        for(int t=1;t<=s.size();t++){\n            for(int h=0;h<=k;h++){\n                dp[i][t][h]=max(dp[i-1][t][h],dp[i][t-1][h]);\n                if(s[i-1]==s[s.size()-t]){\n                    dp[i][t][h]=max(dp[i][t][h],dp[i-1][t-1][h]+1);\n                    for(int w=0;w<26;w++){\n                        dp[i][t][h]=max(dp[i][t][h],dp[back[i][w]][s.size()-next[s.size()-t][w]][h]+1);\n                    }\n                }\n                if(h!=0){\n                    dp[i][t][h]=max(dp[i][t][h],dp[i-1][t-1][h-1]+1);\n                }\n            }\n        }\n    }\n    for(int i=0;i<=s.size();i++){\n        for(int t=0;t<=s.size();t++){\n            for(int h=0;h<=k;h++){\n                if(i+t<=s.size()){ans=max(ans,dp[i][t][h]*2);}\n                if(i+t==s.size()+1){ans=max(ans,dp[i][t][h]*2-1);}\n            }\n        }\n    }\n    cout<<ans<<endl;\n    \n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n#define INF 1000000000\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint dp[333][333][333];\nstring s;\nint k;\n\nint dfs(int K,int L,int R)\n{\n//\tcout << K << ' ' << L << ' ' << R << endl;\n\tif(K < 0 || L > R)return 0;\n\tif(dp[K][L][R] != 0)return dp[K][L][R];\n\tint ret = 0;\n\tint p = 0;\n\tif(s[L] == s[R])ret = max(ret,dfs(K,L+1,R-1)+2);\n\telse ret = max(ret,dfs(K-1,L+1,R-1)+2);\n\tret = max(ret,dfs(K,L+1,R));\n\tret = max(ret,dfs(K,L,R-1));\n\t\n\treturn dp[K][L][R] = ret;\n}\n\n\nint main()\n{\n\tcin >> s >> k;\n\t\n\tREP(K,k)REP(i,333)dp[K][i][i] = 1;\n\tREP(K,k)REP(i,332)\n\t{\n\t\tif(s[i] == s[i+1])dp[K][i][i+1] = 2;\n\t\telse dp[K][i][i+1] = 1;\n\t}\n\t\n\tcout << dfs(k,0,s.size()-1) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nint main(void) {\n  string S;\n  ll N, K;\n  cin >> S >> K;\n  N = S.length();\n\n  ll dp[N][N][K + 1];\n  REP(l, 0, N) REP(r, l, N) REP(k, 0, K + 1) dp[l][r][k] = 0;\n  REP(l, 0, N) REP(k, 0, K + 1) dp[l][l][k] = 1;\n  REP(l, 0, N - 1) REP(k, 0, K + 1) dp[l][l + 1][k] = S[l] == S[l + 1] || k > 0 ? 2 : 0;\n  REP(s, 0, N) REP(l, 0, N - s) {\n    ll r = l + s;\n    REP(k, 0, K + 1) {\n      if(l + 1 <= r - 1 && S[l] == S[r]) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k] + 2);\n      if(l + 1 <= r) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r][k]);\n      if(l <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l][r - 1][k]);\n      if(k > 0 && l + 1 <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k - 1] + 2);\n      if(k > 0) dp[l][r][k] = max(dp[l][r][k], dp[l][r][k - 1]);\n    }\n  }\n  cout << dp[0][N - 1][K] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nint main(void) {\n  string S;\n  ll N, K;\n  cin >> S >> K;\n  N = S.length();\n\n  ll dp[N][N][K + 1];\n  REP(l, 0, N) REP(r, l, N) REP(k, 0, K + 1) dp[l][r][k] = 0;\n  REP(l, 0, N) REP(k, 0, K + 1) dp[l][l][k] = 1;\n  REP(l, 0, N - 1) if(S[l] == S[l + 1]) dp[l][l + 1][0] = 2;\n  REP(l, 0, N - 1) REP(k, 1, K + 1) dp[l][l + 1][k] = 2;\n  REP(s, 0, N) REP(l, 0, N - s) {\n    ll r = l + s;\n    REP(k, 0, K + 1) {\n      if(l + 1 <= r - 1 && S[l + 1] == S[r - 1]) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k] + 2);\n      if(l + 1 <= r) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r][k]);\n      if(l <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l][r - 1][k]);\n      if(k > 0) dp[l][r][k] = max(dp[l][r][k], dp[l][r][k - 1]);\n      if(k > 0 && l + 1 <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k - 1] + 2);\n    }\n  }\n  cout << dp[0][N - 1][K] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[305][305][305];\n\nint main(){\n  \n  string s;\n  int K;\n  \n  cin>>s>>K;\n  \n  memset(dp,-1,sizeof(dp));\n  \n  dp[0][s.size()-1][0]=0;\n  \n  int ans=0;\n  \n  for(int l=0;l<s.size();l++)\n    \n    for(int r=s.size()-1;r>=l;r--){\n\n      for(int k=0;k<=K;k++){\n\t\n\tif(dp[l][r][k]==-1) continue;\n\t\n\tif(s[l]==s[r]){\n\t  if(l==r) ans=max(ans, dp[l][r][k]+1);\n\t  else{\n\t    dp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]+2);\n\t    ans=max(ans, dp[l+1][r-1][k]);\n\t  }\n\t}\n\t\n\tif(l==r) continue;\n\t\n\tdp[l+1][r-1][k+1]=max(dp[l+1][r-1][k+1], dp[l][r][k]+2);\n\tans=max(ans, dp[l+1][r-1][k+1]);\n\t\n\tdp[l+1][r][k]=max(dp[l+1][r][k], dp[l][r][k]);\n\tdp[l][r-1][k]=max(dp[l][r-1][k], dp[l][r][k]);\n\tdp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]);\n      }\n    }\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 330;\n\ninline void smax(int &x, int y) { if (x < y) x = y; }\n\nint dp[N][N][N];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  string s;\n  cin >> s;\n  int k;\n  cin >> k;\n  int n = (int) s.size();\n  for (int i = n; i > 0; i--) {\n    for (int j = 1; j <= n; j++) {\n      for (int r = 0; r <= k; r++) {\n        smax(dp[i][j][r], dp[i + 1][j][r]);\n        smax(dp[i][j][r], dp[i][j - 1][r]);\n        if (s[i - 1] == s[j - 1]) {\n          smax(dp[i][j][r], dp[i + 1][j - 1][r] + 1);\n        } else if (r > 0) {\n          smax(dp[i][j][r], dp[i + 1][j - 1][r - 1] + 2);\n        }\n      }\n    }\n  }\n  cout << dp[1][n][k] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring s;\nint k;\nint dp[303][303][303];\n\nint solve(int fron,int bck,int changes)\n{\n\tif(fron>=bck)\n\t{\n\t\tif(changes<=k)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn (int)(s.length()+2);\n\t\t}\n\t}\n\tif(dp[fron][bck][changes]!=-1)\n\t{\n\t\treturn dp[fron][bck][changes];\n\t}\n\tint ans=(int)(s.length()+2);\n\tif(s[fron]==s[bck])\n\t{\n\t\tans=solve(fron+1,bck-1,changes);\n\t}\n\telse\n\t{\n\t\tans=min(ans,solve(fron+1,bck,changes)+1);\n\t\tans=min(ans,solve(fron,bck-1,changes)+1);\n\t\tans=min(ans,solve(fron+1,bck-1,changes+1));\n\t}\n\tdp[fron][bck][changes]=ans;\n\treturn ans;\n}\n\nint main()\n{\n\tcin>>s;\n\tscanf(\"%d\",&k);\n\tmemset(dp,-1,sizeof dp);\n\tint x=solve(0,s.length()-1,0);\n\tprintf(\"%d\\n\",(int)s.length()-x);\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n  * @brief atcoder\n  * @author yao\n  */\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <climits>\n#define ft first\n#define sd second\n#ifdef DBG\n#   define dbg_pri(x...) fprintf(stderr,x)\n#else\n#   define dbg_pri(x...) 0\n#   define NDEBUG\n#endif //DBG\n#include <cassert>\n\ntypedef unsigned int uint;\ntypedef long long int lli;\ntypedef unsigned long long int ulli;\n\n#define N 512\n\nchar s[N];\nint dp[N][N][N];\n\nint get(int x, int y, int z)\n{\n    if(x<0||y<0||z<0) return 0;\n    return dp[x][y][z];\n}\n\nint main()\n{\n    int n, m;\n    scanf(\"%s%d\", s, &m), n = strlen(s);\n    for(int i=0;i<n;++i)for(int j=0;j<n;++j)for(int k=0;k<=m;++k)\n        dp[i][j][k] = s[i] == s[n-j-1] ?\n            get(i-1,j-1,k)+1 :\n            std::max(std::max(get(i-1,j,k),get(i,j-1,k)), get(i-1,j-1,k-1)+!!k);\n    int ans = 0;\n    for(int i=0;i<n;++i) ans = std::max(ans, get(i,n-i-1,m)*2-1);\n    for(int i=0;i<n;++i) ans = std::max(ans, get(i,n-i-2,m)*2);\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n#define int ll\n//#define int ll\n//#define char ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(4) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int N = 333;\nconst int oo = 1e9 + 10;\nint dp[N][N][N];\n\n\nvoid smain() {\n\n    fori (i, N) {\n        fori (j, N) {\n            fori (k, N) {\n                dp[i][j][k] = oo;\n            }\n        }\n    }\n\n    string s;\n    cin >> s;\n    int k;\n    cin >> k;\n    int n = s.size();\n    string t = s;\n    reverse(ALL(t));\n\n    dp[0][0][0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            for (int len = 0; len < n; ++len) {\n                inmin(dp[i + 1][j][len], dp[i][j][len]);\n                inmin(dp[i][j + 1][len], dp[i][j][len]);\n                if (s[i] == t[j])\n                    inmin(dp[i + 1][j + 1][len + 1], dp[i][j][len]);\n                else {\n                    inmin(dp[i + 1][j + 1][len + 1], dp[i][j][len] + 1);\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    fori (i, n + 1) {\n        fori (j, n + 1) {\n            fori (len, n + 1) {\n                if (dp[i][j][len] <= k * 2) {\n                    inmax(ans, len);\n                }\n            }\n        }\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nchar s[311];\nint dp[311][311][311],K;\nint main()\n{\n\tscanf(\"%s%d\",s,&K);int n=strlen(s);\n\tfor(int i=n;i>=1;i--)s[i]=s[i-1];\n\tfor(int i=1;i<=n;i++)dp[i][i][0]=1;\n\tfor(int len=2;len<=n;len++)\n\t{\n\t\tfor(int i=1;i+len-1<=n;i++)\n\t\t{\n\t\t\tint j=i+len-1;\n\t\t\tfor(int k=0;k<=min(len>>1,K);k++)\n\t\t\t{\n\t\t\t\tdp[i][j][k]=max(dp[i+1][j][k],dp[i][j-1][k]);\n\t\t\t\tif(s[i]==s[j])dp[i][j][k]=max(dp[i][j][k],dp[i+1][j-1][k]+2);\n\t\t\t\telse if(k>0)dp[i][j][k]=max(dp[i][j][k],dp[i+1][j-1][k-1]+2);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<=K;i++)ans=max(ans,dp[1][n][i]);\n\tprintf(\"%d\",ans);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint dp[301][301][301];\n\nclass DReversedLCS {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      string s; cin >> s;\n      int k; cin >> k;\n      int n = s.size();\n      rep(i, n) rep(j, n) rep(k, n) {\n        dp[i][j][k] = 0;\n      }\n      // d = 0;\n      rep(i, n) {\n        dp[i][i][0] = 1;\n      }\n\n      // d >= 2\n      for(int d=0; d<n-1; d++) {\n        for(int i=0; i<n; i++) {\n          int j=i+d;\n          for(int r=0; r<=k; r++) {\n            if (j+1<n) chmax(dp[i][j+1][r], dp[i][j][r]);\n            if (i-1>=0 && j<n) chmax(dp[i-1][j][r], dp[i][j][r]);\n            if (j+1<n) {\n              if (s[i]==s[j+1]) {\n                chmax(dp[i][j+1][r], dp[i+1][j][r]+2);\n              } else {\n                chmax(dp[i][j+1][r], dp[i+1][j][r]);\n              }\n              chmax(dp[i][j+1][r+1], dp[i+1][j][r]+2);\n            }\n            if (i-1>=0 && j<n) {\n              if (s[i-1]==s[j]) {\n                chmax(dp[i-1][j][r], dp[i][j-1][r]+2);\n              } else {\n                chmax(dp[i-1][j][r], dp[i][j-1][r]);\n              }\n              chmax(dp[i-1][j][r+1], dp[i][j-1][r]+2);\n            }\n          }\n        }\n      }\n      int ans = 0;\n      rep(i, n) rep(j, n) rep(r, k+1) {\n        chmax(ans, dp[i][j][r]);\n      }\n      cout << ans << endl;\n    }\n};\n\nsigned main() {\n  DReversedLCS solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\nusing namespace std;\n#define MN 305\n#define inf 1e12\nstring a;\nint k,len,res;\nvoid rw(int &x,int y){if(y>x)x=y;}\nint f(int l,int r,int k){\n\tif(l<0||r<0||l>len||r>len||l>r||k<0) return -inf;\n\tif(l==r) return 1;\n\tres=-inf;\n\trw(res,f(l+1,r-1,a[l]==a[r]?k:k-1)+2);\n\trw(res,f(l+1,r,k));\n\trw(res,f(l,r-1,k));\n\treturn res;\n}\nint main(){\n\tcin>>a>>k;\n\tprintf(\"%d\\n\",f(0,len=a.size()-1,k));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*  ***  In The Name of God ... ***  */\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n//#define int long long\n#define all(v) v.begin() , v.end()\n\ntemplate<typename T> inline bool smin(T &a, const T &b){ return b < a ? a = b,1:0;}\ntemplate<typename T> inline bool smax(T &a, const T &b){ return a < b ? a = b,1:0;}\n\nconst int N = 300 + 10 ; \n\nint n , k , dp [ N ] [ N ] [ N ] ;\nstring s ; \n\nint32_t main()\n{\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> s >> k ;\n\tn = ( int ) s . size ( ) ;\n\tfor ( int i = 0 ; i < n ; ++ i )\n\t\tdp [ i ] [ i ] [ 0 ] = 1 ;\n\tfor ( int i = 0 ; i < n - 1 ; ++ i ) {\n\t\tif ( s [ i ] == s [ i + 1 ] )\n\t\t\tdp [ i ] [ i + 1 ] [ 0 ] = 2 ;\n\t\telse\n\t\t\tdp [ i ] [ i + 1 ] [ 1 ] = 2 , dp [ i ] [ i + 1 ] [ 0 ] = 1  ; \n\t}\n\tfor ( int want = 1 ; want <= k ; ++ want ) {\n\t\tfor ( int i = 0 ; i < n ; ++ i ) { \n\t\t\tsmax ( dp [ i ] [ i ] [ want ] , dp [ i ] [ i ] [ want - 1 ] ) ;\n\t\t\tsmax ( dp [ i ] [ i + 1 ] [ want ] , dp [ i ] [ i + 1 ] [ want - 1 ] ) ;\n\t\t}\n\t}\n\tfor ( int sz = 3 ; sz <= n ; ++ sz ) {\n\t\tfor ( int i = 0 ; i + sz - 1 < n ; ++ i ) {\n\t\t\tint j = i + sz - 1 ;\n\t\t\tint eq = ( s [ i ] == s [ j ] ) * 2 ;\n\t\t\tfor ( int want = 0 ; want <= k ; ++ want ) {\n\t\t\t\tdp [ i ] [ j ] [ want ] = max (  { dp [ i + 1 ] [ j - 1 ] [ want ] + eq ,\n\t\t\t\t\t\t\t\tdp [ i + 1 ] [ j ] [ want ] ,\n\t\t\t\t\t\t\tdp [ i ] [ j - 1 ] [ want ] } ) ;\n\t\t\t\tif ( want )\n\t\t\t\t\tsmax ( dp [ i ] [ j ] [ want ] , dp [ i + 1 ] [ j - 1 ] [ want - 1 ] + 2 ) ;\n\t\t\t\tif ( want )\n\t\t\t\t\tsmax ( dp [ i ] [ j ] [ want ] , dp [ i ] [ j ] [ want - 1 ] ) ; \n\t\t\t}\n\t\t}\n\t}\n\tint res = 0 ;\n\tfor ( int want = 0 ; want <= k ; ++ want )\n\t\tsmax ( res , dp [ 0 ] [ n - 1 ] [ want ] ) ; \n\tcout << res << endl ; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 305;\nint f[maxn][maxn][maxn], g[maxn][maxn], n, K, ans;\nchar s[maxn];\n\nint main() {\n\tscanf(\"%s%d\", s + 1, &K);\n\tn = strlen(s + 1);\n\tfor (int l=n; l>=1; l--) {\n\t\tf[l][l][0] = 1;\n\t\tfor (int r=l+1; r<=n; r++) \n\t\t\tfor (int k=0; k<=K; k++) {\n\t\t\t\tf[l][r][k] = max(f[l+1][r][k], f[l][r-1][k]);\n\t\t\t\tif (s[l] == s[r]) f[l][r][k] = max(f[l][r][k], f[l+1][r-1][k] + 2);\n\t\t\t\telse if (k) f[l][r][k] = max(f[l][r][k], f[l+1][r-1][k-1] + 2);\n\t\t\t}\n\t}\n\tfor (int k=0; k<=K; k++) ans = max(ans, f[1][n][k]);\n\tprintf(\"%d\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define IO ios_base::sync_with_stdio(false); cin.tie(NULL);\n\n#define endl '\\n'\n#define D(x) cout << #x << \" = \" << (x) << endl;\n\nconst int maxn = 301;\nint dp[maxn][maxn][maxn];\n\nint f(string &s, int i, int j, int k) {\n  if (i > j or i >= s.size() or j < 0) return 0;\n\n  if (dp[i][j][k] == -1) {\n    int ret = 0;\n    if (s[i] == s[j]) {\n      int cnt = 1 + (i != j) + f(s, i + 1, j - 1, k);\n      ret = max(ret, cnt);\n    } else {\n      int cnt = f(s, i + 1, j, k);\n      ret = max(ret, cnt);\n\n      cnt = f(s, i, j - 1, k);\n      ret = max(ret, cnt);\n\n      if (k) {\n        cnt = 2 + f(s, i + 1, j - 1, k - 1);\n        ret = max(ret, cnt);\n      }\n    }\n\n    dp[i][j][k] = ret;\n  }\n\n  return dp[i][j][k];\n}\n\nint main() { IO;\n  string s;\n  cin >> s;\n\n  int k;\n  cin >> k;\n\n  memset(dp, -1, sizeof dp);\n  int ans = f(s, 0, s.size() - 1, k);\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <string.h>\n#include <queue>\n#include <math.h>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <list>\n#include <ctype.h>\n#include <cassert>\n#include <stack>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <ctime>\n#include <functional>\n#include <ctime>\n#include <limits>\n#include <tuple>\n#include <complex>\n#include <numeric>\n#include <future>\n\nusing namespace std;\n\n#define snd second\n#define fst first\n#define mp make_pair\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pb push_back\n#define left _left\n#define right _right\n\nconst ld pi = acos(-1.0);\n\ntemplate<typename T>\nT abs(T x) {\n    return x > 0 ? x : -x;\n}\n\ntemplate<typename T>\nT sqr(T x) {\n    return x * x;\n}\n\ntemplate<typename T>\nbool chmin(T &x, T y) {\n    if (x > y) {\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T>\nbool chmax(T &x, T y) {\n    if (x < y) {\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename U, typename V>\nostream &operator<<(ostream &s, const pair<U, V> &x) {\n    s << \"(\" << x.fst << \", \" << x.snd << \")\";\n    return s;\n}\n\ntemplate<typename U>\nostream &operator<<(ostream &s, const vector<U> &x) {\n    s << \"[\";\n    bool was = false;\n    for (auto it : x) {\n        if (was) {\n            s << \", \";\n        }\n        was = true;\n        s << it;\n    }\n    s << \"]\";\n    return s;\n}\n\ntemplate<typename U>\nostream &operator<<(ostream &s, const set<U> &x) {\n    s << \"{\";\n    bool was = false;\n    for (auto it : x) {\n        if (was) {\n            s << \", \";\n        }\n        was = true;\n        s << it;\n    }\n    s << \"}\";\n    return s;\n}\n\ntemplate<int sz>\nostream operator<<(ostream &s, const bitset<sz> &x) {\n    for (int i = 0; i < sz; i++) {\n        s << x[i];\n    }\n    return s;\n}\n\n\n//--------------------------------------------------------------------------\n\nstring s;\n\nconst int maxn = 305;\n\nint dp[maxn][maxn][maxn];\n\nint f(int l, int r, int k) {\n    if (l > r) {\n        return 0;\n    }\n    if (dp[l][r][k] != -1) {\n        return dp[l][r][k];\n    }\n\n    int& res = dp[l][r][k];\n    res = 0;\n\n    if (l == r) {\n        return res = 1;\n    } else if (s[l] == s[r]) {\n        chmax(res, 2 + f(l + 1, r - 1, k));\n    } else if (k) {\n        chmax(res, 2 + f(l + 1, r - 1, k - 1));\n    }\n    chmax(res, f(l + 1, r, k));\n    chmax(res, f(l, r - 1, k));\n    return res;\n}\n\n\n\nint main() {\n\n    srand(time(NULL));\n\n#ifdef LOCAL\n    //gen();\n    freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.in\", \"w\", stdout);\n#else\n    //freopen(\"brackets.in\", \"r\", stdin);\n    //freopen(\"brackets.out\", \"w\", stdout);\n#endif\n\n\n    cin >> s;\n    for (int i = 0; i < maxn; i++) {\n        for (int j = 0; j < maxn; j++) {\n            for (int h = 0; h < maxn; h++) {\n                dp[i][j][h] = -1;\n            }\n        }\n    }\n    int k;\n    cin >> k;\n    cout << f(0, s.size() - 1, k) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long I64;\n\nconst double EPS = 1e-6;\nconst double PI  = acos(-1);\nconst int NMAX = 303;\n\nint d[NMAX+2][NMAX+2][NMAX+2];\n\nint max(int a, int b, int c)\n{\n    return max(max(a,b), c);\n}\n\nint max2(int a, int b, int c)\n{\n    return max(max(a,b), c);\n}\n\nint main()\n{\n    int N, K;\n    string str;\n    cin >> str;\n    N = str.size();\n    if( N == 1 ) {\n        cout << \"1\\n\";\n        return 0;\n    }\n    str = \"#\" + str + \"*\";\n    cin >> K;\n    int Ans = 1;\n    for( int i = 1;  i <= N;  ++i ) {\n        for( int j = N;  i < j;  --j ) {\n            d[i][j][0] = max2( d[i - 1][j][0], d[i][j + 1][0], d[i - 1][j + 1][0] + (str[i] == str[j]) );\n            Ans = max( Ans, d[i][j][0] * 2 + (i + 2 == j) );\n            Ans = max( Ans, d[i][i + 1][0] * 2 );\n            for( int k = 1;  k <= K;  ++k ) {\n                if( str[i] == str[j] )\n                    d[i][j][k] = max2( d[i - 1][j][k], d[i][j + 1][k], d[i - 1][j + 1][k] + 1 );\n                else\n                    d[i][j][k] = max2( d[i - 1][j][k],\n                                      d[i][j + 1][k],\n                                      d[i - 1][j + 1][k - 1] + 1 );\n                Ans = max(Ans, d[i][j][k] * 2 + (i + 2 == j));\n            }\n        }\n    }\n    cout << Ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint n,m;\nstring s;\nvvi dp;\n\nint main(){\n\tcin>>s>>m;\n\tn=s.size();\n\tdp=vvi(n+2,vi(n+2));\n\tfor(int d=0;d<n;d++) for(int l=0;l<n;l++) if(l+d<n){\n\t\tint r=l+d;\n\t\tif(s[l]==s[r]) dp[l+1][r+1]=dp[l+2][r]+(l==r?1:2);\n\t\tdp[l+1][r+1]=max({dp[l+1][r+1],dp[l+2][r+1],dp[l+1][r]});\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tvvi DP(n+2,vi(n+2));\n\t\tfor(int d=0;d<n;d++) for(int l=0;l<n;l++) if(l+d<n){\n\t\t\tint r=l+d;\n\t\t\tbool B=s[l]==s[r];\n\t\t\tDP[l+1][r+1]=(B?DP[l+2][r]:dp[l+2][r])+(l==r?1:2);\n\t\t\tDP[l+1][r+1]=max({DP[l+1][r+1],DP[l+2][r+1],DP[l+1][r]});\n\t\t}\n\t\tdp=DP;\n\t}\n\tcout<<dp[1][n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i>= (a); i--)\n#define ITER(it,a) for(__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a,value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(),a.end()\n#define MP make_pair\n#define PB push_back\n\ntypedef vector<int> VI;\ntypedef long long LL;\ntypedef pair<int,int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL) INF;\n\nconst int MAX = 333;\n\nint DP[MAX][MAX][MAX];\nstring s;\n\nint get(int l, int r, int k)\n{\n//\tcout<<l<<' '<<r<<' '<<k<<endl;\n\tif (l > r) return 0;\n\n\tif (DP[l][r][k] != -1) return DP[l][r][k];\n\t\n\tint res = 0;\n\t\n\tif (s[l] == s[r])\n\t{\n\t\tint add = 1;\n\t\tif (l != r) add++;\n\t\tres = max(res, get(l+1, r-1, k) + add);\n\t}\n\t\n\tres = max(res, get(l+1, r, k));\n\tres = max(res, get(l, r-1, k));\n\t\n\tif (k)\n\t{\n\t\tint add = 1;\n\t\tif (l != r) add++;\n\t\tres = max(res, get(l+1, r-1, k-1) + add);\n\t}\n\t\n\treturn DP[l][r][k] = res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\t\n\tcin>>s;\n\tint k;\n\tcin>>k;\n\t\n\tFILL(DP, -1);\n\t\n\tint res = get(0, SZ(s)-1, k);\n\tcout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 305;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nchar s[MAXN];\nint n, m, ans, dp[MAXN][MAXN][MAXN];\nint main() {\n\tscanf(\"%s\", s + 1);\n\tn = strlen(s + 1), read(m);\n\tfor (int i = 1; i <= n; i++)\n\tfor (int j = i; j <= n; j++)\n\tfor (int k = 0; k <= n; k++)\n\t\tdp[i][j][k] = m + 1;\n\tdp[1][n][0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\tfor (int j = n; j >= i; j--)\n\tfor (int k = 0; k <= n; k++) {\n\t\tint tmp = dp[i][j][k];\n\t\tif (tmp == m + 1) continue;\n\t\tchkmin(dp[i + 1][j][k], tmp);\n\t\tchkmin(dp[i][j - 1][k], tmp);\n\t\tif (i == j) chkmax(ans, 2 * k + 1);\n\t\telse {\n\t\t\tint cost = s[i] != s[j];\n\t\t\tif (cost + tmp <= m) {\n\t\t\t\tchkmin(dp[i + 1][j - 1][k + 1], tmp + cost);\n\t\t\t\tchkmax(ans, 2 * k + 2);\n\t\t\t}\n\t\t}\n\t}\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint LCS(string s,string t){\n\tvvi dp(s.size()+1,vi(t.size()+1));\n\trep(i,s.size())rep(j,t.size()){\n\t\tif(s[i]==t[j])dp[i+1][j+1]=max(dp[i+1][j+1],dp[i][j]+1);\n\t\tdp[i+1][j+1]=max(dp[i+1][j+1],max(dp[i+1][j],dp[i][j+1]));//\n\t}\n\treturn dp[s.size()][t.size()];\n}\nint main(){\n\tstring s;\n\tcin>>s;\n\tint m;cin>>m;\n\tstring t=s;\n\treverse(all(t));\n\tcout<<min((int)s.size(),LCS(s,t)+2*m)<<endl;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 300 + 10;\nint dp[maxn][maxn][maxn];\nchar s[maxn];\nint n, k, ans;\nint f(int i, int j, int k)\n{\n\tif(i == 0 || j == n + 1) return 0;\n\tif(~dp[i][j][k]) return dp[i][j][k];\n\tint ret = max(f(i - 1, j, k), f(i, j + 1, k));\n\tif(s[i] == s[j]) ret = max(ret, f(i - 1, j + 1, k) + 1);\n\telse if(k > 0) ret = max(ret, f(i - 1, j + 1, k - 1) + 1);\n\treturn dp[i][j][k] = ret;\n}\nint main()\n{\n\tmemset(dp, -1, sizeof dp);\n\tscanf(\"%s\", s + 1);\n\tscanf(\"%d\", &k);\n\tn = strlen(s + 1);\n\tfor(int i = 1; i < n; ++i) ans = max(ans, f(i, i + 1, k) * 2);\n\tfor(int i = 1; i <= n; ++i) ans = max(ans, f(i - 1, i + 1, k) * 2 + 1);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n\nstd::string str;\n\nint memo[303][303][303];\n\nint dp(int l, int r, int k) {\n\tif(k < 0) {\n\t\treturn -1e9;\n\t} else if(l > r) {\n\t\treturn 0;\n\t}\n\tint &ans = memo[l][r][k];\n\tif(ans != -1) {\n\t\treturn ans;\n\t}\n\tans = 0;\n\tif(str[l] == str[r]) {\n\t\tans = 1 + (l != r) + dp(l + 1, r - 1, k);\n\t}\n\tans = std::max(std::max(ans, 1 + (l != r) + dp(l + 1, r - 1, k - 1)), std::max(dp(l + 1, r, k), dp(l, r - 1, k)));\n\treturn ans;\n}\n\nint main() {\n\tint k;\n\tstd::cin >> str >> k;\n\tmemset(memo, -1, sizeof memo);\n\tstd::cout << dp(0, str.size() - 1, k) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=310;\nchar s[N];\nint dp[N][N][N],k,n;\nint solve(int l,int r,int k) {\n\tif (dp[l][r][k]!=-1) {\n\t\treturn dp[l][r][k];\n\t}\n\tif (l>r) {\n\t\treturn dp[l][r][k]=0;\n\t}\n\tif (l==r) {\n\t\treturn dp[l][r][k]=1;\n\t}\n\tint &v=dp[l][r][k];\n\tv=0;\n\tv=max(v,solve(l,r-1,k));\n\tv=max(v,solve(l+1,r,k));\n\tif (s[l]==s[r]) v=max(v,solve(l+1,r-1,k)+2);\n\telse if (k>0) v=max(v,solve(l+1,r-1,k-1)+2);\n\treturn v;\n}\nint main() {\n\tscanf(\"%s\",s);\n\tscanf(\"%d\",&k);\n\tn=strlen(s);\n\tmemset(dp,-1,sizeof(dp));\n\tprintf(\"%d\\n\",solve(0,n-1,k));\n}"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\ntypedef long long ll;\ninline void Fail(){printf(\"0\");exit(0);}\n\nconst int maxn=305;\nint n,lim,ans;\nchar c[maxn];\nstring s;\nint dp[maxn][maxn][maxn];\n\nint main(){\n\tscanf(\"%s%d\",c,&lim);\n\ts=c;n=s.size();\n\trep(i,n){\n\t\trep(j,i+1)rep(k,n-i)rep(p,min(lim+1,(i+1,n-i+1))){\n\t\t\tdp[j][k][p]=0;\n\t\t\tif(s[i-j]==s[i+k])dp[j][k][p]=(j>=1&&k>=1?dp[j-1][k-1][p]:0)+(j==0&&k==0?1:2);\n\t\t\tif(j>=1)dp[j][k][p]=max(dp[j][k][p],dp[j-1][k][p]);\n\t\t\tif(k>=1)dp[j][k][p]=max(dp[j][k][p],dp[j][k-1][p]);\n\t\t\tif(s[i-j]!=s[i+k]&&p)\n\t\t\tdp[j][k][p]=max((j>=1&&k>=1?dp[j-1][k-1][p-1]:0)+2,dp[j][k][p]);\n\t\t\tans=max(ans,dp[j][k][p]);\n\t\t}\n\t} \n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define dro first\n#define adg second.first\n#define mog second.second\n#define ll long long\nusing namespace std;\n\nconst int N = 500001;\n\nint n,r,pos,l,x,U,D,S;\n \nlong long ans;\nint K;\n\nstring s;\n\nint fix[100],fix1[100],A[100],B[100];\n\nint dp[501][501][501];\n\nint main(){\n    \n    cin>>s;\n    \n    n=s.size();\n    \n    cin>>K;\n    \n    for(int j=0;j<n;j++)\n    for(int l=0;l+j<n;l++)\n    for(int k=0;k<=K;k++){\n        \n        int r = l+j;\n        \n        if(l==r){\n            dp[l][r][0] = 1;\n            continue;\n            //dp[l][r][1] = 1\n        }\n\n        if(l+1==r){\n            if(k==0){\n                dp[l][r][k] = 1;\n                if(s[l] == s[r]) dp[l][r][k] = 2;\n            } else {\n                dp[l][r][k] = 2;\n            }\n            \n            continue;\n        }\n        \n        dp[l][r][k] = max( dp[l+1][r][k], dp[l][r-1][k]);\n        //cout<<dp[l+1][r][k]<<\" \"<<l<<\" \"<<r<<\" \"<<k<<endl;\n        //cout<<dp[l][r-1][k]<<\" \"<<l<<\" \"<<r<<\" \"<<k<<endl;\n        if(s[l]==s[r])\n            dp[l][r][k] = max( dp[l][r][k], dp[l+1][r-1][k] + 2);\n        else {\n            if(k-1>=0)\n            dp[l][r][k] = max( dp[l][r][k], dp[l+1][r-1][k-1] + 2);\n        }\n\n        //cout<<dp[l][r][k]<<\" \"<<l<<\" \"<<r<<\" \"<<k<<endl;\n    }\n    \n    cout<<dp[0][n-1][K]<<endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//wls niubi!\n#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\nconst LL mod = 1e9 + 7;\ninline int read()\n{\n\tint x = 0,f = 1;char ch = getchar();\n\tfor(;!isdigit(ch);ch = getchar())if(ch == '-')f = -f;\n\tfor(;isdigit(ch);ch = getchar())x = 10 * x + ch - '0';\n\treturn x * f;\n}\nint n,K;\nchar ch[210];\nint f[210][210][210];\nint main()\n{\n\tscanf(\"%s\",ch + 1);n = strlen(ch + 1);K = read();\n\tfor(int i=1;i<=n;i++)for(int j=0;j<=K;j++)f[i][i][j] = 1;\n\tfor(int l=2;l<=n;l++)\n\t{\n\t\tfor(int i=1;i+l-1<=n;i++)\n\t\t{\n\t\t\tint j = i + l - 1;\n\t\t\tfor(int k=0;k<=K;k++)\n\t\t\t{\n\t\t\t    f[i][j][k] = max(f[i - 1][j][k],f[i][j - 1][k]);\n\t\t\t    if(ch[i] == ch[j])f[i][j][k] = max(f[i][j][k],f[i + 1][j - 1][k] + 2);\n\t\t\t    if(k)f[i][j][k] = max(f[i][j][k],f[i + 1][j - 1][k - 1] + 2);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int k=0;k<=K;k++)ans = max(ans,f[1][n][k]);\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<math.h>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<cstring>\n#include<cstdio>\n#include<functional>\n#include<bitset>\n#include<limits.h>\n#include<cassert>\n#include<iterator>\n#include<complex>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<time.h>\n#include<random>\n#include<array>\nusing namespace std;\nusing ll = long long;\n#define rep(i, a, b) for(int i = a; i < b; i++)\n#define rrep(i, a, b) for(int i = b - 1; i >= a; i--)\n#define ALL(a) a.begin(), a.end()\nusing pii = pair<int,int>;\nusing piii = pair<pii,int>;\nusing pll = pair<long long, long long>;\nusing plll = pair<pll, long long>;\n// #pragma GCC optimize(\"Ofast\")\n#define pcnt __builtin_popcount\n#define buli(x) __builtin_popcountll(x)\n#define pb push_back\n#define mp make_pair\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define isSquare(x) (sqrt(x)*sqrt(x) == x)\ntemplate<class T>inline bool chmax(T &a, const T &b) {if(a<b){a = b; return 1;} return 0; };\ntemplate<class T>inline bool chmin(T &a, const T &b) {if(a>b){a = b; return 1;} return 0; };\ninline void in(void){return;}\ntemplate <typename First, typename... Rest> void in(First& first, Rest&... rest){cin >> first;in(rest...);return;}\ninline void out(void){cout << \"\\n\";return;}\ntemplate <typename First, typename... Rest> void out(First first, Rest... rest){cout << first << \" \";out(rest...);return;}\nconst double EPS = 1e-9;\nconst int mod = 1e9 + 7;\nconst int INF = 1e9;\nconst long long INFLL = 1e18;\nvoid iosetup() {\n    cin.tie(nullptr);ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n}\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 >& p) {\n    os << p.first << \" \" << p.second;\n    return os;\n}\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n    is >> p.first >> p.second;\n    return is;\n}\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n    for(int i = 0; i < (int) v.size(); i++) {\n        os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n    }\n    return os;\n}\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n    for(T &in : v) is >> in;\n    return is;\n}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S, T>& t){return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S, T>& t){return pair<S,T>(s.first-t.first, s.second-t.second);}\ntemplate<class S, class T> pair<S,T> operator*(const pair<S,T> &s, const S& t){return pair<S,T>(s.first*t, s.second*t);}\ntemplate <typename T> void Exit(T first){cout << first << endl;exit(0); };\ntemplate< int mod > struct ModInt {\n    unsigned x; ModInt() : x(0) {}\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n    ModInt &operator+=(const ModInt &p) {if((x += p.x) >= mod) x -= mod;return *this;}\n    ModInt &operator-=(const ModInt &p) {if((x += mod - p.x) >= mod) x -= mod;return *this;}\n    ModInt &operator*=(const ModInt &p) {x = (int) (1LL * x * p.x % mod);return *this;}\n    ModInt &operator/=(const ModInt &p) {*this *= p.inverse();return *this;}\n    ModInt operator-() const { return ModInt(-x); }\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n    bool operator==(const ModInt &p) const { return x == p.x; }\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n    ModInt inverse() const {int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) { t = a / b; swap(a -= t * b, b); swap(u -= t * v, v); }return ModInt(u);}\n    ModInt pow(int64_t n) const {ModInt ret(1), mul(x); while(n > 0) {if(n & 1) ret *= mul;mul *= mul;n >>= 1;}return ret;}\n    friend ostream &operator<<(ostream &os, const ModInt &p) { return os << p.x;}\n    friend istream &operator>>(istream &is, ModInt &a) { int64_t t; is >> t; a = ModInt< mod >(t); return (is); }\n    static int get_mod() { return mod; }\n}; using modint = ModInt< mod >;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst pii dxy[4] = {pii(1,0), pii(0, 1), pii(-1, 0), pii(0, -1)};\nconst int calender[13] = {0, 31,28,31,30,31,30,31,31,30,31,30,31};\nconst int ucalender[13] = {0, 31,29,31,30,31,30,31,31,30,31,30,31};\nbool range(int a, int b, int x){if(a <= x and x < b)return true;else return false;}\nbool range(int a, int b, int c, int d, pii p){if(a <= p.first and p.first < b and c <= p.second and p.second < d) return true;else return false;}\n\nint dp[310][310][310];\n// dp[l][r][k] := 左からl,右からrでLCS(k文字まで変えてok)\nint main(){\n    iosetup();\n    string S; cin >> S;\n    int n = S.size();\n    int K; cin >> K;\n    memset(dp, 0, sizeof dp);\n    rep(l, 1, n + 1){\n        rep(r, 1, n + 1){\n            rep(k, 0, K + 1){\n                chmax(dp[l][r][k], dp[l][r-1][k]);\n                chmax(dp[l][r][k], dp[l-1][r][k]);\n                if(k-1>=0)chmax(dp[l][r][k], dp[l-1][r-1][k-1] + 1);\n                if(S[l-1] == S[n - r])\n                    chmax(dp[l][r][k], dp[l-1][r-1][k] + 1);\n            }\n        }\n    }\n    // rep(l, 0, n) rep(r, l + 1, n){\n    //     cerr << l << \", \" << r << endl;\n    //     rep(k, 0, K + 1){\n    //     cerr << dp[l][r][k] << \" \";\n    //     }\n    //     cerr << endl;\n    // }\n    int res = 0;\n    for (int k = 0; k <= K; ++k) {\n        for (int i = 0; i <= n; ++i) chmax(res, dp[i][n-i][k] * 2);\n        for (int i = 0; i < n; ++i) chmax(res, dp[i][n-1-i][k] * 2 + 1);\n    }\n    cout << res << endl;\n    // cout << dp[n][n][K] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nstring S;\nint N;\nint K;\nint memo[345][345][345];\nint dp(int i, int j, int k) {\n\tif (i == 0 || j == 0)return 0;\n\tif (memo[i][j][k] >= 0)return memo[i][j][k];\n\tint res = max(dp(i - 1, j, k), dp(i, j - 1, k));\n\tif (S[i - 1] == S[N - j])res = max(res, dp(i - 1, j - 1, k) + 1);\n\tif (k > 0)res = max(res, dp(i - 1, j - 1, k - 1) + 1);\n\treturn memo[i][j][k] = res;\n}\n\nint main(void)\n{\n\tcin >> S;\n\tcin >> K;\n\tN = S.size();\n\tmemset(memo, 0xff, sizeof(memo));\n\tint ans = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint can = dp(i, N - i - 1, K);\n\t\tans = max(ans, can * 2 + 1);\n\t}\n\tfor (int i = 0; i <= N; ++i) {\n\t\tint can = dp(i, N - i, K);\n\t\tans = max(ans, can * 2);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 300+10;\nint dp[2][MAXN][2][2][MAXN];\nchar str[MAXN];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin>>str;\n    int K,N=strlen(str);\n    cin>>K;\n    int ans=0;\n    for(int i=0;i<N;++i)\n    {\n        int ii=i%2;\n        for(int j=N-1;j>=i;--j)\n        {\n            for(int k=0;k<=K;++k)\n            {\n                dp[ii][j][0][0][k]=max(max(dp[!ii][j][0][0][k],dp[!ii][j][1][0][k]),max(dp[ii][j+1][0][0][k],dp[ii][j+1][0][1][k]));\n                dp[ii][j][0][1][k]=max(dp[!ii][j][0][1][k],dp[!ii][j][1][1][k]);\n                dp[ii][j][1][0][k]=max(dp[ii][j+1][1][0][k],dp[ii][j+1][1][1][k]);\n                if(str[i]==str[j])\n                    dp[ii][j][1][1][k]=max(max(dp[!ii][j][0][0][k],dp[!ii][j][1][0][k]),max(dp[ii][j+1][0][0][k],dp[ii][j+1][0][1][k]))+1;\n                else if(k!=0)\n                    dp[ii][j][1][1][k]=max(max(dp[!ii][j][0][0][k-1],dp[!ii][j][1][0][k-1]),max(dp[ii][j+1][0][0][k-1],dp[ii][j+1][0][1][k-1]))+1;\n                int tmp=0;\n                for(int ui=0;ui<2;++ui)\n                    for(int uj=0;uj<2;++uj)\n                        if(!(ui&&uj))\n                            tmp=max(tmp,dp[ii][j][ui][uj][k]);\n                ans=max(ans,tmp*2);\n                if(i==j)\n                    ans=max(ans,2*dp[ii][j][1][1][k]-1);\n                else ans=max(ans,2*dp[ii][j][1][1][k]);\n            }\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define fi first\n#define se second\n#define ll long long\n#define dbg(v) cerr<<#v<<\" = \"<<v<<'\\n'\n#define vi vector<int>\n#define vl vector <ll>\n#define pii pair<int,int>\n#define mp make_pair\n#define db long double\n#define pb push_back\n#define all(s) s.begin(),s.end()\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nconst int N = (int)(1e6) + 5;\nchar str[N];\nint k;\nint dp[333][333][333];\nint f(int l,int r,int t)\n{\n    if (dp[l][r][t] != -1)\n        return dp[l][r][t];\n    if (l > r)\n        return 0;\n    if (l == r)\n        return 1;\n    int &ans = dp[l][r][t];\n    ans = max(f(l + 1,r,t),f(l,r - 1,t));\n    if (str[l] == str[r])\n        smax(ans,f(l + 1,r - 1,t) + 2);\n    else\n    if (t + 1 <= k)\n        smax(ans,2 + f(l + 1,r - 1,t + 1));\n    return ans;\n}\nint main(void)\n{\n    cin>>(str + 1);\n    cin>>k;\n    memset(dp,-1,sizeof(dp));\n    int n = strlen(str + 1);\n    cout << f(1,n,0) << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nstring s;\nint rec(int pos, int sml){\n\tif(pos == s.size()) return 0;\n\tint d = s[pos] - '0';\n\tint res = (sml ? 9 : d) + rec(pos + 1, sml);\n\tif(!sml && d > 0) res = max(res, d - 1 + rec(pos + 1, 1));\n\t\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tcin >> s;\n\tcout << rec(0, 0) << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<pii, int> ppiii;\ntypedef pair<ll, ll> pll;\ntypedef pair<pii, pii> query;\n\nstring s;\nint dp[301][301][301];\nbool seen[301][301][301];\n\nint solve(int lhs, int rhs, int k) {\n  if(lhs > rhs) return 0;\n  if(lhs == rhs) return 1;\n  if(seen[lhs][rhs][k]) return dp[lhs][rhs][k];\n  seen[lhs][rhs][k] = true;\n  dp[lhs][rhs][k] = max(solve(lhs+1, rhs, k), solve(lhs, rhs-1, k));\n  if(s[lhs] == s[rhs]) dp[lhs][rhs][k] = max(dp[lhs][rhs][k], 2 + solve(lhs+1, rhs-1, k));\n  else if(k > 0) {\n    dp[lhs][rhs][k] = max(dp[lhs][rhs][k], 2 + solve(lhs+1, rhs-1, k-1));\n  }\n  return dp[lhs][rhs][k];\n}\n\nvoid solve() {\n  cin >> s;\n  int k;\n  cin >> k;\n  cout << solve(0, s.size()-1, k) << \"\\n\";\n}\n\nvoid casesolve() {\n  int t;\n  cin >> t;\n  for(int i = 1; i <= t; i++) {\n    cout << \"Case #\" << i << \" \";\n    solve();\n  }\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL); cout.tie(NULL);\n  solve();\n  // casesolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n//\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//\nconstexpr ll MOD=1e9+7;\n//constexpr ll MOD=998244353;\n//constexpr ll MOD=10000000;\n//constexpr ll MOD=1e5;\nconstexpr ll MAX=3e6;\nconstexpr ll INF=(1ll<<60);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate<typename T>\nstruct Segment_tree{\n    ll N;\n    T mem;\n    vector<T> node;\n    Segment_tree(vector<T> &X,T m):mem(m){\n        ll sz=X.size();\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mem);\n        rep(i,0,sz) node[N-1+i]=X[i];\n        per(i,N-2,0){\n            node[i]=Compare(node[i*2+1],node[i*2+2]);\n        }\n    }\n    T Compare(T &A,T &B){\n        return std::max(A,B);\n    }\n    void update(ll X,T val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=Compare(node[X*2+1],node[X*2+2]);\n        }\n    }\n    T Query(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mem;\n        if(a<=l&&r<=b) return node[now];\n        auto vl=Query(a,b,now*2+1,l,(l+r)/2),vr=Query(a,b,now*2+2,(l+r)/2,r);\n        return Compare(vl,vr);\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,int a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nvoid comp(vi &A){\n    std::map<ll,ll> mem;\n    rep(i,0,A.size()) mem[A[i]]=0;\n    ll cnt=0;\n    for(auto &p:mem) p.second=cnt++;\n    rep(i,0,A.size()) A[i]=mem[A[i]];\n}\nll RLCS(string S){\n    string T=S;\n    reverse(ALL(T));\n    ll N=S.size();\n    vii dp(N+1,vi(N+1));\n    REP(i,0,N){\n        REP(j,0,N){\n            if(!i){\n                if(j) dp[i][j]=dp[i][j-1];\n            }\n            else if(!j){\n                dp[i][j]=dp[i-1][j];\n            }\n            else{\n                dp[i][j]=std::max(dp[i][j-1],dp[i-1][j]);\n                if(S[i-1]==T[j-1]) dp[i][j]=std::max(dp[i][j],dp[i-1][j-1]+1);\n            }\n        }\n    }\n    return dp[N][N];\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    string S; cin>>S;\n    ll K,N=S.size(); cin>>K;\n    string T=S; reverse(ALL(T));\n    vector<vii> dp(N/2+1,vii(N/2+1,vi(K+1,INF)));\n    dp[0][0][0]=0;\n    vii mem(26);\n    rep(i,0,N/2) mem[T[i]-'a'].pb(i+1);\n    rep(i,0,N/2){\n        REP(j,0,N/2){\n            REP(k,0,K) dp[i+1][j][k]=dp[i][j][k];\n        }\n        rep(j,0,N/2){\n            REP(k,0,K){\n                if(dp[i][j][k]==INF) continue;\n                ll X=disup(mem[S[i]-'a'],dp[i][j][k]);\n                if(X<mem[S[i]-'a'].size()){\n                    ll Y=mem[S[i]-'a'][X];\n                    dp[i+1][j+1][k]=std::min(dp[i+1][j+1][k],Y);\n                }\n                if(dp[i][j][k]<N/2&&k<K){\n                    dp[i+1][j+1][k+1]=std::min(dp[i+1][j+1][k+1],dp[i][j][k]+1);\n                }\n            }\n        }\n        REP(j,0,N/2){\n            REP(k,1,K) dp[i+1][j][k]=std::min(dp[i+1][j][k],dp[i+1][j][k-1]);\n        }\n    }\n    ll ans=0;\n    per(i,N/2,0){\n        ll cnt=0;\n        per(j,N/2,0){\n            if(dp[i][j][K]!=INF){\n                ll left=i,right=N-1-dp[i][j][K];\n                if(left<=right){\n                    string P=S.substr(left,right-left+1);\n                    ans=std::max(ans,j*2+RLCS(P));\n                }\n                else{\n                    ans=std::max(ans,j*2);\n                }\n                cnt++;\n            }\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...)\n#endif\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    string s;\n    int k;\n    cin >> s >> k;\n    int n = s.size();\n    vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(k + 1)));\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i; j <= n - 1; j++) {\n            for (int l = 0; l <= k; l++) {\n                if (i == j) {\n                    dp[i][j][l] = 1;\n                } else if (i + 1 == j) {\n                    dp[i][j][l] = 2;\n                    if (l == 0 && s[i] != s[j]) {\n                        dp[i][j][l] = 1;\n                    }\n                } else {\n                    dp[i][j][l] = max(dp[i + 1][j][l], dp[i][j - 1][l]);\n                    dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l] + 1);\n                    if (s[i] == s[j]) {\n                        dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l] + 2);\n                    }\n                    if (l != 0) {\n                        dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l - 1] + 2);\n                    }\n                }\n            }\n        }\n    }\n    cout << dp[0][n - 1][k] << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[300][300][301];\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tstring s;\n\tint k;\n\tcin>>s>>k;\n\tint n = s.size();\n\tfor(int i=0;i<n;i++)\n\t\tdp[i][i][0]=1;\n\tfor(int l=2;l<=n;l++)\n\t\tfor(int i=0;i+l<=n;i++){\n\t\t\tint j=i+l-1;\n\t\t\tfor(int m=0;m<=k;m++){\n\t\t\t\tdp[i][j][m]=max(dp[i+1][j][m],dp[i][j-1][m]);\n\t\t\t\tif(s[i]==s[j])\n\t\t\t\t\tdp[i][j][m]=max(dp[i+1][j-1][m]+2,dp[i][j][m]);\n\t\t\t\tif(m){\n\t\t\t\t\tdp[i][j][m]=max(dp[i][j][m],dp[i][j][m-1]);\n\t\t\t\t\tdp[i][j][m]=max(dp[i][j][m],dp[i+1][j-1][m-1]+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcout<<dp[0][n-1][k]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//teja349\n#include <bits/stdc++.h>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <iomanip> \n//setbase - cout << setbase (16); cout << 100 << endl; Prints 64\n//setfill -   cout << setfill ('x') << setw (5); cout << 77 << endl; prints xxx77\n//setprecision - cout << setprecision (14) << f << endl; Prints x.xxxx\n//cout.precision(x)  cout<<fixed<<val;  // prints x digits after decimal in val\n\nusing namespace std;\n#define f(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) f(i,0,n)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define pb push_back\n#define mp make_pair\n#define vi vector< int >\n#define vl vector< ll >\n#define ss second\n#define ff first\n#define ll long long\n#define pii pair< int,int >\n#define pll pair< ll,ll >\n#define sz(a) a.size()\n#define inf (1000*1000*1000+5)\n#define all(a) a.begin(),a.end()\n#define tri pair<int,pii>\n#define vii vector<pii>\n#define vll vector<pll>\n#define viii vector<tri>\n#define mod (1000*1000*1000+7)\n#define pqueue priority_queue< int >\n#define pdqueue priority_queue< int,vi ,greater< int > >\n\n//std::ios::sync_with_stdio(false);   \nint dp[312][313][312];\n    \nstring s;\nint n;\nint compute(int i,int j,int left){\n\t\n\tif(j<i)\n\t\treturn 0;\n\tif(i==j)\n\t\treturn 1;\n\tif(dp[i][j][left])\n\t\treturn dp[i][j][left];\n\tdp[i][j][left]=max(compute(i+1,j,left),compute(i,j-1,left));\n\tif(s[i]==s[j]){\n\t\tdp[i][j][left]=max(dp[i][j][left],2+compute(i+1,j-1,left));\n\t}\n\telse if(left){\n\t\tdp[i][j][left]=max(dp[i][j][left],2+compute(i+1,j-1,left-1));\n\t}\n\treturn dp[i][j][left];\n\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    \n    cin>>s;\n    int k;\n    n=s.length();\n    cin>>k;\n    cout<<compute(0,n-1,k)<<endl;\n    return 0;  \n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\n#define MAXN 301\n#define mod 1000000007\n\nchar S[MAXN];\nint N;\nint dp[MAXN][MAXN][MAXN];\n\nvoid print(int k) {\n    string tmp(S);\n    for (int len = 1; len <= N; len++) {\n        for (int i = 0; i + len - 1 < N; i++) {\n            int j = i + len - 1;\n            printf(\"dp[%d][%d][%d] = %d, %s\\n\", k, i, j, dp[k][i][j], tmp.substr(i, len).c_str());\n        }\n    }\n    printf(\"\\n\");\n}\n\nvoid f(int k) {\n    for (int i = 0; i < N; i++) {\n        dp[k][i][i] = 1;\n    }\n\n    for (int len = 2; len <= N; len++) {\n        for (int i = 0; i + len - 1 < N; i++) {\n            int j = i + len - 1;\n            if (S[i] == S[j]) {\n                if (len == 2) {\n                    dp[k][i][j] = 2;\n                } else {\n                    dp[k][i][j] = dp[k][i + 1][j - 1] + 2;\n                }\n            } else {\n                if (k == 0) {\n                    if (len == 2) {\n                        dp[k][i][j] = 1;\n                    } else {\n                        dp[k][i][j] = max(dp[k][i + 1][j - 1], max(dp[k][i][j - 1], dp[k][i + 1][j]));\n                    }\n                } else {\n                    if (len == 2) {\n                        dp[k][i][j] = 2;\n                    } else {\n\n                        dp[k][i][j] = max(dp[k - 1][i + 1][j - 1] + 2, max(dp[k][i][j - 1], dp[k][i + 1][j]));\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main() {\n#ifdef ONLINE_JUDGE\n    freopen(\"input.txt\", \"rt\", stdin);\n    //    freopen(\"output.txt\", \"wt\", stdout);\n#endif\n\n    scanf(\"%s\", S);\n    N = strlen(S);\n\n    int K;\n    scanf(\"%d\", &K);\n\n    for (int i = 0; i <= K; i++) {\n        f(i);\n    }\n\n    //    print(0);\n    //    print(1);\n    int ans = dp[K][0][N - 1];\n    //    for (int i = 0; i <= K; i++)\n    //        ans = max(ans, dp[i][0][N - 1]);\n\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//実装が重そうな問題はある程度考えてから書く\n//初期化を忘れずに（特に二分探索とか）\n//コーナーケースを考えて（特に場合分けとか）\n//不可解すぎるバグは配列外参照（配列の長さ）を検討\n#include \"bits/stdc++.h\"\n#define YES \"YES\"\n#define Yes \"Yes\"\n#define NO \"NO\"\n#define No \"No\"\n#define YESNO(x) OUT(three(x,YES,NO))\n#define YesNo(x) OUT(three(x,Yes,No))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define rep REP\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b-1,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB emplace_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define int short\n#define zero 0LL\n#define all ALL\n#define pb PB\nusing namespace std;\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l < r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l > r ? l = r, 1 : 0; }\ntypedef long long LL;\ntypedef LL ll;\ntypedef double ld;\ntypedef LL ut;\nconst LL INF = 1LL << 60;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<ppr, Vppr ,greater<ppr> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nint dx[] = { 0,1,0,-1,1,1,-1,-1,0 }, dy[] = { 1,0,-1,0,1,-1,1,-1,0 };\nconst int SIZE1 =2e6 + 1000;\nconst int SIZE2 = 2010;\nconst int SIZE3 = 301;\nconst int SIZE = SIZE1;\nconst LL p = 7 + 1e9;const long double EPS = 1e-7;\nut N, M, K, X, L, Y,H,W,Q,D;\n// ut A,B,C,D,E,F,G,H,I,J,O,P,Q,R,T,U;\nVI edges[SIZE];\nLL vals[SIZE], nums[SIZE], maps[SIZE2][SIZE2], answer = zero;\n//LL A[SIZE], B[SIZE],I[SIZE];\nLL A, B;\nstring s;\nstring revs;\nLL DP[SIZE3][SIZE3][SIZE3];\nbool checked[SIZE3][SIZE3][SIZE3];\nLL solve2(int a,int b,int k) {\n\tif (a > b) return 0;\n\tif (a == b) return 1;\n\tif (checked[a][b][k]) return DP[a][b][k];\n\tchecked[a][b][k] = true;\n\n\tif (s[a] == s[b]) {\n\t\treturn DP[a][b][k] = solve2(a + 1, b - 1, k) + 2;\n\t}\n\tMX(DP[a][b][k], solve2(a + 1, b, k));\n\tMX(DP[a][b][k], solve2(a, b -1, k));\n\tif (k)\n\t\tMX(DP[a][b][k], solve2(a + 1, b -1, k - 1)+2);\n\treturn DP[a][b][k];\n\t/*/\n\tif (max(a, b) >= s.size()) return 0;\n\tif (checked[a][b][k]) return DP[a][b][k];\n\tchecked[a][b][k]=true;\n\tif (s[a] == revs[b]) {\n\t\treturn DP[a][b][k] = solve2(a + 1, b + 1, k)+1;\n\t}\n\tMX(DP[a][b][k], solve2(a + 1, b, k));\n\tMX(DP[a][b][k], solve2(a , b+1, k));\n\tif(k)\n\t\tMX(DP[a][b][k], solve2(a + 1, b+1, k-1));\n\treturn DP[a][b][k];\n/*/\n}\nLL solve() {\n\tcin >> s;\n\trevs = s;\n\treverse(ALL(revs));\n\tcin >> K;\n\tcout << solve2(0, (LL)s.size()-1, K) << endl;\n\treturn 0;\n}\nsigned main() {\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(10);\n\tsolve();\n\t//\tcin >> N;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int Nmax = 303;\n\nint ans, i, j, k, K, N, dp[Nmax][Nmax][Nmax];\nchar a[Nmax];\n\nint main()\n{\n  //  freopen(\"input\", \"r\", stdin);\n  //  freopen(\"output\", \"w\", stdout);\n    cin.sync_with_stdio(false);\n\n    cin >> (a+1) >> K;\n    N = strlen(a+1);\n\n    for(i=N; i; --i)\n        for(j=i; j<=N; ++j)\n            for(k=0; k<=K; ++k)\n            {\n                if(i == j) dp[i][j][k] = 1;\n                    else if(a[i] == a[j]) dp[i][j][k] = 2 + dp[i+1][j-1][k];\n                        else\n                        {\n                            dp[i][j][k] = max(dp[i+1][j][k], dp[i][j-1][k]);\n                            if(k) dp[i][j][k] = max(dp[i][j][k], dp[i+1][j-1][k-1] + 2);\n                        }\n            }\n\n    for(i=0; i<=K; ++i) ans = max(ans, dp[1][N][i]);\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=303;\nint n,f[N][N][N],p,ans;char s[N];\nint main(){\n    scanf(\"%s%d\",s+1,&p);n=strlen(s+1);\n    for(int i=n;i;i--)\n        for(int j=i;j<=n;j++)\n            for(int k=0;k<=(j-i)/2+1;k++)\n                f[i][j][k]=max(k||s[i]==s[j]?f[i+1][j-1][k-!!(s[i]^s[j])]+1+!!(i^j):0,max(f[i][j-1][k],f[i+1][j][k]));\n    for(int i=0;i<=p;i++)ans=max(ans,f[1][n][i]);\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n\nusing namespace std;\ntemplate<class T, class T2> inline void chkmax(T &x, const T2 &y) { if(x < y) x = y; }\ntemplate<class T, class T2> inline void chkmin(T &x, const T2 &y) { if(x > y) x = y; }\nconst int MAXN = (317);\n\nint n;\nstring s;\nint k;\n\nvoid read()\n{\n\tcin >> s >> k;\n\tn = s.size();\n}\n\nint dp[MAXN][MAXN][MAXN];\n\nint rec(int l, int r, int o)\n{\n\tif(r < l) return 0;\n\tif(l == r) return 1;\n\n\tint &memo = dp[l][r][o];\n\tif(memo != -1) return memo;\n\t\n\tmemo = 0;\n\tif(s[l] == s[r]) chkmax(memo, 2 + rec(l + 1, r - 1, o));\n\tchkmax(memo, rec(l + 1, r, o));\n\tchkmax(memo, rec(l, r - 1, o));\n\tif(o) chkmax(memo, 2 + rec(l + 1, r - 1, o - 1));\n\treturn memo;\n}\n\nvoid solve()\n{\n\tmemset(dp, -1, sizeof(dp));\n\tcout << rec(0, n - 1, k) << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_S = 300;\nconst int MAX_K = MAX_S;\nint64_t dp[MAX_S+2][MAX_S+2][MAX_K+1];\n\nint main()\n{\n  string s;\n  int k;\n  cin >> s >> k;\n\n  s = \"0\" + s;\n\n  int n = s.size() - 1;\n\n  for (int l = 0; l < n+2; l++)\n    for (int r = 0; r < n+2; r++)\n      for (int c = 0; c <= k; c++)\n        dp[l][r][c] = 0;\n\n  for (int l = n; l > 0; l--) {\n    for (int r = l; r <= n; r++) {\n      for (int c = 0; c <= k; c++) {\n        if (s[l] == s[r])\n          dp[l][r][c] = dp[l+1][r-1][c] + (l == r ? 1 : 2);\n        dp[l][r][c] = max(dp[l][r][c], max(dp[l+1][r][c], dp[l][r-1][c]));\n          if (c != 0)\n            dp[l][r][c] = max(dp[l][r][c], dp[l+1][r-1][c-1] + (l == r ? 1 : 2));\n      }\n    }\n  }\n  cout << dp[1][n][k] << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define lint long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\ntemplate <typename T> inline T LB(vector<T>& v, T a) { return *lower_bound(ALL(v),a); }\ntemplate <typename T> inline int LBP(vector<T>& v, T a) { return lower_bound(ALL(v),a) - v.begin(); }\ntemplate <typename T> inline T UB(vector<T>& v, T a) { return *upper_bound(ALL(v),a); }\ntemplate <typename T> inline int UBP(vector<T>& v, T a) { return upper_bound(ALL(v),a) - v.begin(); }\ntemplate <typename T1, typename T2> ostream& operator<< (ostream& os, const pair<T1,T2>& p) { os << p.first << \" \" << p.second; return os; }\ntemplate <typename T1, typename T2> istream& operator>> (istream& is, pair<T1,T2>& p) { is >> p.first >> p.second; return is; }\ntemplate <typename T> ostream& operator<< (ostream& os, const vector<T>& v) { REP(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\ntemplate <typename T> istream& operator>> (istream& is, vector<T>& v) { for(T& in : v) is >> in; return is; }\ntemplate <typename T = int> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate <typename T, typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...)); }\ntemplate <typename T, typename V> typename enable_if<is_class<T>::value == 0>::type fill_v(T &t, const V &v) { t = v; }\ntemplate <typename T, typename V> typename enable_if<is_class<T>::value != 0>::type fill_v(T &t, const V &v) { for(auto &e : t) fill_v(e,v); }\nconst lint MOD = 1000000007;\nconst lint INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n\nstring S;\nint K;\nint dp[310][310][310];\n\nint dfs(int i, int j, int k) {\n    if (dp[i][j][k])\n        return dp[i][j][k];\n    if (i > j)\n        return dp[i][j][k] = 0;\n    if (i == j)\n        return dp[i][j][k] = 1;\n    if (S[i] == S[j])\n        return dfs(i + 1, j - 1, k) + 2;\n    int res = -1;\n    if (k > 0)\n        CHMAX(res, dfs(i + 1, j - 1, k - 1) + 2);\n    CHMAX(res, dfs(i + 1, j, k));\n    CHMAX(res, dfs(i, j - 1, k));\n    return dp[i][j][k] = res;\n}\n\nvoid _main() {\n    cin >> S >> K;\n    cout << dfs(0, S.size() - 1, K) << endl;\n}\n\nsigned main(signed argc, char **argv) {\n    if (argc > 1) {\n        freopen(\"input.txt\", \"r\", stdin);\n        freopen(\"output.txt\", \"w\", stdout);\n    }\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    _main();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 305\n\nusing namespace std;\nint dp[maxn][maxn][maxn],n,k,l,r;\nchar s[maxn];\n\nint main()\n{\n    scanf(\"%s\",s); scanf(\"%d\",&k); n=strlen(s);\n    for (int i=0;i<n;i++) for (int j=0;j<=k;j++) dp[i][i][j]=1;\n    for (int i=1;i<n;i++) dp[i][i-1][0]=0;\n    for (int i=1;i<n;i++)\n        for (int j=0;j+i<n;j++)\n        {\n            l=j; r=j+i;\n            for (int m=0;m<=k;m++)\n            {\n                dp[l][r][m]=max(dp[l+1][r][m],dp[l][r-1][m]);\n                if (m>0) dp[l][r][m]=max(dp[l][r][m-1],dp[l][r][m]);\n                if (m-(s[l]!=s[r])>=0) dp[l][r][m]=max(dp[l][r][m],dp[l+1][r-1][m-(s[l]!=s[r])]+2);\n            }\n        }\n    cout << dp[0][n-1][k] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nint dp[310][310][160];\nint d2[310][310][310];\nstring s;\nint cal(int x,int y,int z){\n\tif(d2[x][y][z]>=0) return d2[x][y][z];\n\tif(x==y) return d2[x][y][z]=1;\n\tif(x>y) return d2[x][y][z]=0;\n\tint ret=0;\n\tif(s[x]==s[y]) ret=max(ret,cal(x+1,y-1,z)+2);\n\tif(z>0) ret=max(ret,cal(x+1,y-1,z-1)+2);\n\tret=max(ret,cal(x+1,y,z));ret=max(ret,cal(x,y-1,z));\n\treturn d2[x][y][z]=ret;\n}\nint main()\n{\n\tint K,n,out;\n\tcin>>s;n=s.size();cin>>K;\n\tmemset(dp,0,sizeof(dp));\n\trep(i,n+1) rep(j,n+1) rep(k,min(K,155)+1){\n\t\t//cout<<i<<' '<<j<<' '<<k<<' '<<dp[i][j][k]<<endl;\n\t\tdp[i+1][j][k]=max(dp[i+1][j][k],dp[i][j][k]);\n\t\tdp[i][j+1][k]=max(dp[i][j+1][k],dp[i][j][k]);\n\t\tif(i+j+2<=n){\n\t\t\tif(s[i]==s[n-1-j]) dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+1);\n\t\t\telse dp[i+1][j+1][k+1]=max(dp[i+1][j+1][k+1],dp[i][j][k]+1);\n\t\t}\n\t}\n\t\n\tmemset(d2,-1,sizeof(d2));\n\t//cal(0,n-1);\n\t\n\t//cout<<dp[6][9][3]<<' '<<cal(6,9)<<endl;\n\trep(i,n+1) rep(j,n+1) rep(k,K+1){\n\t\tif(i+j>n) continue;\n\t\tout=max(out,dp[i][j][k]*2+cal(i,n-j-1,K-k));\n\t}\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define db double\n#define pb push_back\n#define ppb pop_back\n#define F first\n#define S second\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 303;\nstring s;\nint n, k, dp[N][N][N];\n\nint rec(int l, int r, int x) {\n\tif (x < 0) {\n\t\treturn -N;\n\t}\n\tif (l > r) {\n\t\treturn 0;\n\t}\n\tif (l == r) {\n\t\treturn 1;\n\t}\n\tint & res = dp[l][r][x];\n\tif (res != -1) {\n\t\treturn res;\n\t}\n\tres = 0;\n\tif (s[l] == s[r]) {\n\t\tres = rec(l + 1, r - 1, x) + 2;\n\t}\n\tres = max(res, rec(l + 1, r - 1, x - 1) + 2);\n\tres = max(res, rec(l + 1, r, x));\n\tres = max(res, rec(l, r - 1, x));\n\treturn res;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(NULL);\n\t#ifdef LOCAL\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t#endif\n\n\tcin >> s >> k;\n\tn = s.size();\n\tmemset(& dp, -1, sizeof(dp));\n\tcout << rec(0, n - 1, k);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(x) cerr<<#x<<'='<<x<<endl\n#define set0(x) memset(x,0,sizeof(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\ntemplate<typename T> void read(T &x){\n\tx = 0;char ch = getchar();ll f = 1;\n\twhile(!isdigit(ch)){if(ch == '-')f*=-1;ch=getchar();}\n\twhile(isdigit(ch)){x = x*10+ch-48;ch=getchar();}x*=f;\n}\n\nchar str[305];\nint dp[305][305][305];\nvoid upd(int &a,int b){\n\ta =max(a,b);\n}\nint main() {\n\tcin>>(str+1);\n\tint n = strlen(str+1);\n\tint lim;\n\tcin>>lim;\n\tint ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=n;j>=1;j--){\n\t\t\tfor(int k=0;k<=lim;k++){\n\t\t\t\tupd(dp[i+1][j][k],dp[i][j][k]);\n\t\t\t\tupd(dp[i][j-1][k],dp[i][j][k]);\n\t\t\t\tif(str[i] == str[j]){\n\t\t\t\t\tupd(dp[i+1][j-1][k],dp[i][j][k]+1);\n\t\t\t\t}else{\n\t\t\t\t\tupd(dp[i+1][j-1][k+1],dp[i][j][k]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n+1;i++){\n\t\tfor(int j=n+1;j>=0;j--){\n\t\t\tfor(int k=0;k<=lim;k++){\n\t\t\t\tif(i == j+1)ans = max(ans,dp[i][j][k]*2);\n\t\t\t\tif(i-1 == j+1)ans = max(ans,dp[i][j][k]*2-1);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n#define STRINGIFY(n) #n\n#define TOSTRING(n) STRINGIFY(n)\n#define PREFIX \"#\" TOSTRING(__LINE__) \"| \"\n#define debug(x) \\\n{ \\\n  std::cout << PREFIX << #x << \" = \" << x << std::endl; \\\n}\n\nstd::ostream& output_indent(std::ostream& os, int ind) {\n  for(int i = 0; i < ind; i++) os << \" \";\n  return os;\n}\n\ntemplate<class S, class T> std::ostream& operator<<(std::ostream& os, const std::pair<S, T>& p);\ntemplate<class T> std::ostream& operator<<(std::ostream& os, const std::vector<T>& v);\n\ntemplate<class S, class T> std::ostream& operator<<(std::ostream& os, const std::pair<S, T>& p) {\n  return (os << \"(\" << p.first << \", \" << p.second << \")\");\n}\ntemplate<class T> std::ostream& operator<<(std::ostream& os, const std::vector<T>& v) {\n  os << \"[\";\n  for(int i = 0;i < v.size();i++) os << v[i] << \", \";\n  return (os << \"]\");\n}\n\ntemplate<class T>\nstatic inline std::vector<T> ndvec(size_t&& n, T val) { return std::vector<T>(n, std::forward<T>(val)); }\ntemplate<class... Tail>\nstatic inline auto ndvec(size_t&& n, Tail&&... tail) {\n  return std::vector<decltype(ndvec(std::forward<Tail>(tail)...))>(n, ndvec(std::forward<Tail>(tail)...));\n}\ntemplate<class Cond> struct chain {\n  Cond cond; chain(Cond cond) : cond(cond) {}\n  template<class T> bool operator()(T& a, const T& b) const { if(cond(a, b)) { a = b; return true; } return false; }\n};\ntemplate<class Cond> chain<Cond> make_chain(Cond cond) { return chain<Cond>(cond); }\n\nint main() {\n  string S;\n  cin >> S;\n  i64 K;\n  cin >> K;\n  i64 N = S.size();\n  auto dp = ndvec(N + 1, N + 1,K + 1, i64(0));\n  rep(i,0,N) {\n    dp[i][i + 1][0] = 1;\n  }\n  auto chmax = make_chain(std::less<i64>());\n  rep(len,2,N + 1) {\n    rep(l,0,N) {\n      i64 r = l + len;\n      if(r > N) break;\n      i64 cost;\n      if(S[l] == S[r - 1]) cost = 0;\n      else                 cost = 1;\n      rep(k,0,K + 1) {\n        if(k - cost >= 0) {\n          chmax(dp[l][r][k], dp[l + 1][r - 1][k - cost] + 2);\n        }\n        chmax(dp[l][r][k], dp[l + 1][r][k]);\n        chmax(dp[l][r][k], dp[l][r - 1][k]);\n      }\n    }\n  }\n  cout << *max_element(all(dp[0][N])) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nint main() {\n\tstring s;\n\tint K;\n\tcin >> s >> K;\n\tvector<vector<vector<int> > > dp(s.length(), vector<vector<int> >(s.length(), vector<int>(K + 1, 0)));\n\tfor (int i = s.length() - 1; i >= 0; i--) {\n\t\tfor (int k = 0; k <= K; k++) {\n\t\t\tdp[i][i][k] = 1;\n\t\t}\n\t\tfor (int j = i + 1; j < s.length(); j++) {\n\t\t\tdp[i][j][0] = max(dp[i + 1][j][0], dp[i][j - 1][0]);\n\t\t\tdp[i][j][0] = max(dp[i][j][0], dp[i + 1][j - 1][0] + (s[i] == s[j]) * 2);\n\t\t\tfor (int k = 1; k <= K; k++) {\n\t\t\t\tdp[i][j][k] = max(dp[i + 1][j][k], dp[i][j - 1][k]);\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i + 1][j - 1][k - 1] + 2);\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i + 1][j - 1][k] + (s[i] == s[j]) * 2);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][s.length() - 1][K] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define vi vector<int>\n#define vvi vector<vi>\n#define vs vector<string>\n#define pb push_back\n#define P pair<int,int>\n#define vp vector<P>\n#define PP pair<int,P>\n#define vpp vector<PP>\n#define fi first\n#define se second\n#define INF 1e9\n#define MOD 1000000007\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REPR(i,n) for(int i=n;i>=0;i--)\n#define FOR(i,m,n) for(int i=m;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nint mem[310][310][310];\nstring st;\nint dfs(int l,int r,int x){\n    if(r<l){\n        return 0;\n    }\n    if(l==r){\n        return 1;\n    }\n    if(mem[l][r][x]!=-1){\n        return mem[l][r][x];\n    }\n    int res=max(dfs(l+1,r,x),dfs(l,r-1,x));\n    if(st[l]==st[r]){\n        res=max(res,dfs(l+1,r-1,x)+2);\n    }\n    if(x){\n        res=max(res,dfs(l+1,r-1,x-1)+2);\n    }\n    return mem[l][r][x]=res;\n}\nint main(){\n    cin>>st;\n    int K;\n    cin>>K;\n    REP(i,300){\n        REP(j,300){\n            REP(k,300){\n                mem[i][j][k]=-1;\n            }\n        }\n    }\n    cout<<dfs(0,st.size()-1,K)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 20;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\npii operator-(pii l, pii r){ return pii(l.first - r.first, l.second - r.second); }\nll operator/(pii l, pii r){ return (ll)l.first * r.second - (ll)l.second * r.first; }\nll operator*(pii l, pii r){ return (ll)l.first * r.first + (ll)l.second * r.second; }\n\nconst int MX = 305;\nchar D[MX];\nint T[MX][MX][MX];\nint N, K;\n\nint main()\n{\n\tscanf(\"%s%d\", D+1, &K);\n\tN = strlen(D+1);\n\tfor(int i = 1; i <= N; i++) T[i][i][0] = 1;\n\tfor(int i = 1; i < N; i++){\n\t\tfor(int x = 1; x+i <= N; x++){\n\t\t\tint y = x+i;\n\t\t\tfor(int k = 0; k <= K; k++){\n\t\t\t\tT[x][y][k] = max(T[x+1][y][k], T[x][y-1][k]);\n\t\t\t\tif( k ) T[x][y][k] = max(T[x+1][y-1][k-1] + 2, T[x][y][k]);\n\t\t\t\tif( D[x] == D[y] ) T[x][y][k] = max(T[x+1][y-1][k] + 2, T[x][y][k]);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i <= K; i++) ans = max(ans, T[1][N][i]);\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tstring s, t;\n\tint N, K, i, j, k;\n\tcin >> s;\n\tscanf(\"%d\", &K);\n\tN = s.size();\n\tt = s;\n\treverse(t.begin(), t.end());\n\tchar *S = (char *)malloc(sizeof(char) * (N + 1));\n\tfor(i = 1; i <= N; i++){\n\t\tS[i] = s[i - 1];\n\t}\n\tchar *T = (char *)malloc(sizeof(char) * (N + 1));\n\tfor(i = 1; i <= N; i++){\n\t\tT[i] = t[i - 1];\n\t}\n\tvector<vector<vector<int> > > dp(N + 1, vector<vector<int> >(N + 1, vector<int>(K + 1, 0)));\n\tfor(i = 1; i <= N; i++){\n\t\tfor(j = 1; j <= N; j++){\n\t\t\tdp[i][j][0] = max(dp[i - 1][j][0], dp[i][j - 1][0]);\n\t\t\tif(S[i] == T[j]){\n\t\t\t\tdp[i][j][0] = max(dp[i][j][0], dp[i - 1][j - 1][0] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(k = 1; k <= K; k++){\n\t\tfor(i = 1; i <= N; i++){\n\t\t\tfor(j = 1; j <= N; j++){\n\t\t\t\tdp[i][j][k] = max(max(dp[i - 1][j][k], dp[i][j - 1][k]), dp[i - 1][j - 1][k - 1] + 1);\n\t\t\t\tif(S[i] == T[j]){\n\t\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(i = 0; i <= N; i++){\n\t\tans = max(ans, 2 * dp[i][N - i][K]);\n\t}\n\tfor(i = 1; i <= N; i++){\n\t\tans = max(ans, 2 * dp[i - 1][N - i][K] + 1);\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  char s[310];\n  scanf(\"%s\",s);\n  int n=strlen(s);\n  int k;\n  scanf(\"%d\",&k);\n  static int dp[310][310][310];\n  int ans=1;\n  for(int j=0;j<=n;j++){\n    for(int i=0;i+j<=n;i++){\n      for(int l=0;l<=k;l++){\n\tif(j==0||j==1){\n\t  dp[i][j][l]=j;\n\t  continue;\n\t}\n\tdp[i][j][l]=max(dp[i][j-1][l],dp[i+1][j-1][l]);\n\tif(s[i]==s[i+j-1]){\n\t  dp[i][j][l]=max(dp[i][j][l],dp[i+1][j-2][l]+2);\n\t}\n\tif(l>0){\n\t  dp[i][j][l]=max(dp[i][j][l],dp[i+1][j-2][l-1]+2);\n\t}\n\tans=max(ans,dp[i][j][l]);\n      }\n    }\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=305;\nstring s;\nint dp[305][305][305],K;\nint dfs(int l,int r,int x)\n{\n    if(r<l)return 0;\n    if(l==r)return 1;\n    if(dp[l][r][x]!=-1)return dp[l][r][x];\n    int t=max(dfs(l+1,r,x),dfs(l,r-1,x));\n    if(s[l]==s[r])t=max(t,dfs(l+1,r-1,x)+2);\n    else if(x)t=max(t,dfs(l+1,r-1,x-1)+2);\n    return dp[l][r][x]=t;\n}\nint main()\n{\n    cin>>s>>K;\n    memset(dp,-1,sizeof(dp));\n    cout<<dfs(0,s.size()-1,K)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef DEMETRIO\n#define deb(...) fprintf(stderr,__VA_ARGS__)\n#define deb1(x) cerr << #x << \" = \" << x << endl\n#else\n#define deb(...) 0\n#define deb1(x) 0\n#endif\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define fore(i,a,b) for(int i=a,ThxDem=b;i<ThxDem;++i)\n#define SZ(x) ((int)(x).size())\n#define mset(a,v) memset(a,v,sizeof(a))\n#define mcopy(a,b) memcpy(a,b,sizeof(a))\nusing namespace std;\ntypedef long long ll;\n\nint dp[302][302][302];\nchar s[302];int n,k;\n\nint f(int i, int j, int k){\n\tint& r=dp[i][j][k];\n\tif(r>=0)return r;\n\tif(i==0||j==n)r=0;\n\telse if(s[i-1]==s[j])r=1+f(i-1,j+1,k);\n\telse {\n\t\tr=max(f(i-1,j,k),f(i,j+1,k));\n\t\tif(k)r=max(r,1+f(i-1,j+1,k-1));\n\t}\n\treturn r;\n}\n\nint main(){\n\tmemset(dp,-1,sizeof(dp));\n\tscanf(\"%s%d\",s,&k);n=strlen(s);\n\tint r=0;\n\tfore(i,0,n)r=max(r,2*f(i,i,k)),r=max(r,2*f(i,i+1,k)+1);\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 262144\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nint dp[302][302][302];\nint visited[400][400];\nint k = 0;\nstring s;\nvoid solve(int left, int right) {\n\tif (left > right) return;\n\tif (visited[left][right] == 1) return;\n\tvisited[left][right] = 1;\n\tsolve(left + 1, right);\n\tfor (int q = 0; q <= k; ++q) {\n\t\tdp[left][right][q] = max(dp[left][right][q], dp[left + 1][right][q]);\n\t\tdp[left][right][q + 1] = max(dp[left][right][q], dp[left][right][q + 1]);\n\t}\n\tsolve(left, right - 1);\n\tfor (int q = 0; q <= k; ++q) {\n\t\tdp[left][right][q] = max(dp[left][right][q], dp[left][right - 1][q]);\n\t\tdp[left][right][q + 1] = max(dp[left][right][q], dp[left][right][q + 1]);\n\t}\n\tsolve(left + 1, right - 1);\n\tfor (int q = 0; q <= k; ++q) {\n\t\tif (s[left] == s[right]) {\n\t\t\tdp[left][right][q] = max(dp[left][right][q], dp[left + 1][right - 1][q]+2);\n\t\t}\n\t\telse {\n\t\t\tdp[left][right][q + 1] = max(dp[left][right][q + 1], dp[left + 1][right - 1][q] + 2);\n\t\t}\n\t\tdp[left][right][q + 1] = max(dp[left][right][q], dp[left][right][q+1]);\n\t}\n}\nint main() {\n\tcin >> s;\n\tcin >> k;\n\tfor (int i = 0; i < s.length(); ++i) {\n\t\tREP(j, k + 1) {\n\t\t\tdp[i][i][j] = 1;\n\t\t}\n\t\tvisited[i][i] = 1;\n\t}\n\tfor (int i = 0; i < s.length() - 1; ++i) {\n\t\tREP(j, k + 1) {\n\t\t\tif (s[i] == s[i + 1]) {\n\t\t\t\tdp[i][i + 1][j] = 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][i + 1][j + 1] = 2;\n\t\t\t}\n\t\t}\n\t}\n\tsolve(0, s.length() - 1);\n\tint ans = 0;\n\tREP(j, k + 1) {\n\t\tans = max(ans, dp[0][s.length() - 1][j]);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nint dp[400][400][400];\nsigned main(){\n\tstring s;int K;cin>>s>>K;\n\trep(i,s.size()){\n\t\tfor(int j=s.size()-1;j>i;j--){\n\t\t\trep(k,K+1){\n\t\t\t\tif(s[i]==s[j]){\n\t\t\t\t\tdp[i+1][j-1][k]=max(dp[i+1][j-1][k],dp[i][j][k]+1);\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tdp[i+1][j-1][k]=max(dp[i+1][j-1][k],dp[i][j][k]);\n\t\t\t\t\tdp[i+1][j][k]=max(dp[i+1][j][k],dp[i][j][k]);\n\t\t\t\t\tdp[i][j-1][k]=max(dp[i][j-1][k],dp[i][j][k]);\n\t\t\t\t\tif(k<K){\n\t\t\t\t\t\tdp[i+1][j-1][k+1]=max(dp[i+1][j-1][k+1],dp[i][j][k]+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint Max=0;\n\trep(i,s.size())rep(k,s.size())rep(j,K+1){\n\t\tMax=max(Max,dp[i][k][j]);\n\t}\n\tif(s.size()%2==1){\n\t\tcout<<Max*2+1<<endl;\n\t}\n\telse{\n\t\tif(Max*2!=s.size())cout<<Max*2+1<<endl;\n\t\telse cout<<Max*2<<endl;\n\t}\n\t//cout<<Max*2+2<<vendl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define forE(i,x) for(int i=head[x];i!=-1;i=ne[i])\nusing namespace std;\ntypedef long long i64;\ntypedef unsigned long long u64;\ntypedef unsigned u32;\ntypedef pair<int,int> pin;\n#define mk(a,b) make_pair(a,b)\n#define lowbit(x) ((x)&(-(x)))\n#define sqr(a) ((a)*(a))\n#define clr(a) (memset((a),0,sizeof(a)))\n#define ls ((x)<<1)\n#define rs (((x)<<1)|1)\n#define mid (((l)+(r))>>1)\n#define pb push_back\n#define w1 first\n#define w2 second\ninline void read(int &x){\n\tx=0;int f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\tx*=f;\n}\ninline void judge(){\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n}\n/*******************************head*******************************/\nconst int maxn=305;\nchar s[maxn];\nint f[maxn][maxn][maxn],k,n;\nint main(){\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tread(k);int ans=0;\n\trep(i,1,n)per(j,n,i)rep(p,0,k){\n\t\tf[i][j][p]=max(f[i-1][j][p],f[i][j+1][p]);\n\t\tif(s[i]==s[j])f[i][j][p]=max(f[i][j][p],f[i-1][j+1][p]+1+(i!=j));\n\t\tif(p){\n\t\t\tf[i][j][p]=max(f[i][j][p],f[i-1][j+1][p-1]+1+(i!=j));\n\t\t}\n\t\tans=max(ans,f[i][j][p]);\n\t}cout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\ntemplate<class T,class U> inline bool chmin(T&x,U y){T Y=static_cast<T>(y);if(x>Y){x=Y;return true;}return false;}\ntemplate<class T,class U> inline bool chmax(T&x,U y){T Y=static_cast<T>(y);if(x<Y){x=Y;return true;}return false;}\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define Fr(i,n) for(int i=1;i<=(n);++i)\n#define ifr(i,n) for(int i=(n)-1;i>=0;--i)\n#define iFr(i,n) for(int i=(n);i>0;--i)\n\nint LCS(string s,string t){\n    int n=s.length(),m=t.length();\n    vector<vector<int>> dp(n+1,vector<int>(m+1));\n    fr(i,n) fr(j,m){\n        if(s[i]==t[j]) dp[i+1][j+1]=dp[i][j]+1;\n        else dp[i+1][j+1]=max(dp[i][j+1],dp[i+1][j]);\n    }\n    return dp[n][m];\n}\n\nunsigned char dp[301][301][301]={};\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    string s;\n    int k;\n    cin>>s>>k;\n    int n=s.length(),ans{};\n    Fr(i,n) Fr(j,n-i) fr(l,k+1){\n        if(s[i-1]==s[n-j]) chmax(dp[i][j][l],dp[i-1][j-1][l]+1);\n        else{\n            chmax(dp[i][j][l],max(dp[i-1][j][l],dp[i][j-1][l]));\n            if(l) chmax(dp[i][j][l],dp[i-1][j-1][l-1]+1);\n        }\n        if(i+j<n) chmax(ans,dp[i][j][l]*2+1);\n        else chmax(ans,dp[i][j][l]*2);\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 330;\n\nint k, dp[N][N][N];\nstring s;\n\nvoid _max(int &a, int b) {\n\ta = max(a, b);\n}\n\nvoid solve() {\n\tfor (int i = 0; i < s.length(); i++)\n\t\tfor (int j = 0; j < N; j++)\n\t\t\tdp[i][i + 1][j] = 1;\n\t\n\tfor (int len = 2; len <= s.length(); len++)\n\t\tfor (int l = 0; l + len <= s.length(); l++) {\n\t\t\tint r = l + len;\n\t\t\tfor (int cnt = 0; cnt <= k; cnt++) {\n\t\t\t\tdp[l][r][cnt] = max(dp[l + 1][r][cnt], dp[l][r - 1][cnt]);\n\t\t\t\tif (s[l] == s[r - 1])\n\t\t\t\t\t_max(dp[l][r][cnt], 2 + dp[l + 1][r - 1][cnt]);\n\t\t\t\telse if (cnt)\n\t\t\t\t\t_max(dp[l][r][cnt], 2 + dp[l + 1][r - 1][cnt - 1]);\n\t\t\t}\n\t\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> s >> k;\n\tsolve();\n\tcout << dp[0][s.length()][k];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\tstring s; cin >> s;\n\tint n = s.size();\n\tint K; cin >> K;\n\tvector<vector<vector<int> > > dp(n, vector<vector<int> >(n, vector<int>(K+1)));\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int k = 0; k < K+1; ++k) {\n\t\t\tdp[i][i][k] = 1;\n\t\t\tif (i < n-1 and s[i] == s[i+1]) dp[i][i+1][k] = 2;\n\t\t}\n\t}\n\tfor (int k = 0; k < K+1; ++k) {\n\t\tfor (int x = 1; x < n; ++x) {\n\t\t\tfor (int i = 0; i < n-x; ++i) {\n\t\t\t\tint j = i+x;\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k-1], dp[i+1][j][k], dp[i][j-1][k]);\n\t\t\t\tif (s[i] == s[j] and x > 1) dp[i][j][k] = max(dp[i][j][k], dp[i+1][j-1][k] + 2);\n\t\t\t\telse if (k > 0 and x > 1) dp[i][j][k] = max(dp[i][j][k], dp[i+1][j-1][k-1] + 2);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][n-1][K] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define cal(x,y) (x=x>y?x:y)\nusing namespace std;\nconst int N=350;\nint gi(){\n    char ch=getchar(); int x=0,q=0;\n    while(ch<'0'||ch>'9') q=ch=='-'?1:q,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return q?-x:x;\n}\nint f[N][N][N],n,k;\nchar s[N];\nint main(){\n    scanf(\"%s%d\",s+1,&k);\n    n=strlen(s+1);\n    int ans=0;\n    for (int i=1; i<=n; ++i)\n\tfor (int j=n; j>=i; --j)\n\t    for (int l=k; ~l; --l){\n\t\tcal(f[i+1][j][l],f[i][j][l]);\n\t\tcal(f[i][j-1][l],f[i][j][l]);\n\t\tcal(f[i+1][j-1][l],f[i][j][l]+(s[i]==s[j]));\n\t\tif (l) cal(f[i+1][j-1][l-1],f[i][j][l]+1);\n\t\tif (i==j) ans=max(ans,2*f[i][j][l]+1);\n\t\telse ans=max(ans,2*(f[i][j][l]+(s[i]==s[j])));\n\t    }\n    cout<<ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int N = 3e2+5;\nint n, m, f[N][N][N], ans; char s[N];\nint main()\n{\n    scanf(\"%s\", s+1), n = strlen(s+1), m = read();\n    for(int i = 1; i <= n; ++i) f[0][i][i] = 1;\n    for(int k = 0; k <= m; ++k)\n        for(int l = 2; l <= n; ++l)\n            for(int i = 1, j = l; j <= n; ++i, ++j)\n            {\n                f[k][i][j] = max(max(f[k][i+1][j], f[k][i][j-1]), f[k][i+1][j-1]+2*(s[i] == s[j]));\n                if(k) f[k][i][j] = max(f[k][i][j], f[k-1][i+1][j-1]+2);\n                ans = max(ans, f[k][i][j]);\n            }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pa pair<int,int>\n#define db double\n#define mo 1000000007\nusing namespace std;\nchar s[305];\nint f[305][305][305];\nint K,ans;\nint main(){\n\tscanf(\"%s%d\",s+1,&K);\n\tint n=strlen(s+1);\n\tfor (int i=0;i<=K;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tfor (int k=n;k>j;k--){\n\t\t\t\tif (i!=0) f[i][j][k]=f[i-1][j-1][k+1]+1;\n\t\t\t\tf[i][j][k]=max(f[i][j][k],max(f[i][j-1][k],f[i][j][k+1]));\n\t\t\t\tif (s[j]==s[k]) f[i][j][k]=max(f[i][j][k],f[i][j-1][k+1]+1);\n\t\t\t}\n\tfor (int i=1;i<=n;i++)\n\t\tans=max(ans,2*f[K][i-1][i+1]+1);\n\tfor (int i=0;i<=n;i++)\n\t\tans=max(ans,2*f[K][i][i+1]);\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                             UM.\n                            J@B@1                                                                    iO@1\n                           Y@@@B@BB.                                                              7B@B@B@\n                          :@B@i,B@B@O                                                          ,Z@B@B@B@Br\n                          @B@q   i@B@BS                                                      7@B@@@O5vMB@q\n                         8@@B      LB@B@i                                                  FB@@@BNjYjLE@B@\n                        ,B@B:        0@@@Z                                               P@B@BM1JJ125JPB@B\n                        B@BB          :@B@B                                            XB@B@Z2LuU52F2u2@B@.\n                       :@B@             @@@B:                                        v@B@B8uJj51F1525uUB@B7\n                       @B@O              0@@B.               ..::ir7vvYUuU777r::.   B@B@OULU2F2F151F11Y@B@S\n                       B@B,               8B@B  :ruXMB@B@B@B@B@B@B@B@B@B@@@B@B@B@B@B@B@5Jj1211F1F1F2FUJO@BB\n                      U@B@                 @B@B@B@B@B@@@B@B@B@MMqPS5JuYL7rq@B@OBB@B@B8Yu211F1515251515YGB@@\n                      @B@u                 v@@@@MSur:.                    LB@MvvjJuU5YU252F1F1F25251F2uX@@@\n                      @@@.                                                N@BML2U2UUU12F15252525251515Jk@@B\n                     r@B@                                                 YB@Bju52121252515252F15251F2u5@B@\n                     PB@B                                                  @@@PYUF151F25151F152F2F1F15jF@@B\n                     @@BS                                                  N@@@UJ2F25252F251525151F1F1u5@B@\n                     @@@7                                                   B@B@5Yj12F152F1F1F25252515jFB@B\n                     B@Bi                                                    M@B@O2Luu52525212F151121UY1@B@7\n                    O@B@:                                                     v@B@BMSuYJJuuUu2u2uujjYJJXB@B@M\n                  7B@B@,                                                        1B@@@B@GPF1uujuu21PNMB@B@B@B@@\n                 qB@B2                                                            i8B@B@B@B@B@@@@@B@B@B@q: @@@B\n                MB@B:                                                                 7SBB@B@B@B@B@Zu:      @B@B\n               ZB@B.                                              ,v.                                        @B@L\n              LB@B,                         Y7                    @B@Bu                                      7@B@\n   :B@B@@B2:  @@B7                         @B@Z                   r@B@B@BP:                                   B@BE\n    BB@@@B@B@B@BE                        r@B@B                       7@B@B@B@Ou:                              iB@B\n         :uM@@B@@2.           :7::::ivk@B@B@0                           :5B@B@B@B@B@B@G.                       @B@i\n            BB@@@B@@         :@B@B@@@B@B@@1                                 .i5M@B@B@@@5                       M@@2\n            B@B ,@B1          L0EZZG0F7:                                            .:,                        uB@MrP@M7\n           2@B@                                                                                               ,O@B@B@B@B\n           @B@1                                                     :@B@@@r                                :@@@@B@BL:,,\n           B@Bi                         :2ZS;                      :@B@B@B@r                               L@B@B@BU\n           @B@.                        @@@B@B@                     vB@B@B@B5                                   @B@i\n           B@B                        7B@B@B@BM                     OB@B@B@                                   ,B@B\n           @B@                         @B@B@@@i                       rL7.                                    B@BM\n           B@B7.:                       NB@@M.                                                               .@B@.\n  .;JEB@@@B@B@B@B@.                                                                                       .  @B@u\n@@@B@B@B@B@@@B@18U                                                                                      :B@B@B@BU,\n7@BOui.    ,@@B                                                                                          SP@B@B@B@B@Or\n            @@@U                                                                                           B@BJ.YO@B@B@i\n            r@B@                                                                                         :B@Bk     .k@B@\n             B@B@                                                                                       LB@@k         2i\n              B@BM                                      .7jXEGqF7:                                     OB@@L\n              .B@BM                                   .B@B@B@B@B@B@.                                 :@B@B:\n               .B@B@                                   @@MYr::ivG@B                                .M@B@G\n                 B@@@S                                                                           ,MB@B@,\n                  v@@@BF                                                                      .1B@B@Br\n                    2@@B@BL                                                                ,FB@@@B8,\n                      r@B@B@BF,                                                        :YBB@B@B@B\n                         L@B@B@B@P7,                                           .ivXB@B@B@B@B@M@B@\n                            ,1B@B@B@B@@@BOP2L7i:,.              ..,:i7LSNB@@B@B@@@B@B@B@Z5v;.LB@@\n                              @B@OEB@B@@@B@B@B@B@B@B@B@B@@@B@B@B@B@B@@@B@B@B@B@BM0SJ7i::::i:,u@B@\n                              B@Bu ::i;7vu2XNGOMB@B@BMB@B@B@B@B@B@@@B1UFuj77ii:::::::iir;r;i.YB@B\n                              @B@L.:i:i:i::::::::::..Y@B@BMYi:i;SB@B@N:.::i:iirir;r;rii::::ivO@B@\n                              B@@X::,::::iirir;riri:E@B@1         ,@B@Br:;;r;rii:i::::i7JEB@@@@@B\n                              @@@B@BBq5v7ii:::::::.2@@@i  ..,..     @B@@,,:::::irv2XMB@B@B@B@2@B@:\n                             .B@BBB@@@B@B@B@BMNP5u7@B@1 .,,:,,  :.   @B@P50MB@B@B@B@B@@@BS:   @@B1\n                             E@B@   ijGB@B@B@B@B@B@B@Bi .,:,,..@@B@7 B@B@B@B@B@B@BM57.        kB@B\n                            .@B@:          .,ivu5Nq@B@u  ..,.. SB@B@@@B@PL7i,                 ,@B@\n                            @@@8                   i@B@:    .     :B@B@@                       B@@2\n                          i@@@@                     0@B@u          B@@B.                       vB@B\n                         ,@B@G                       L@B@BOv:.:iFB@B@M                          @B@Bi\n                          vNi                          S@@B@B@B@B@BM:                            MB@N\n                                                          758BMqJ,\n\t\t\t\t\t\t\t\t\t\tI       am        too        slow!!!!!!!!!!!!!\n                 .  YO.               vq                            :G       Z:\n        SqOMBB@B@Br @@r rBE           @B     B@@@@@B@ONX8k    i::::.OB1.:::.u@O.::::i           @B@B@U:@@B@@BPEBu\n        B@@NB@k.    5@i  uB@E.        BM     1U2uUJvirB@@Z   r@@B@B@@@B@B@B@B@B@@@B@Bi   LB@B@1 BX :@k uLLLvr@BJ:\n            iB      iBi    7@     .@M8@BGMZZ         @@F            ,B       Pi          v@  Bq @i v@        B@\n       vuL7r8@S7vJL7N@Z7LLri;72.   F7@Bvvv@@       @BX         @@@B@B@@@@@B@@@B@B@B      7@  @F Bi @q  @B@Bu @B\n       N@B@G@@@8@BBOMB@G@BMNXG@,     B@   @@      .Bk          .:u;    i@:      Zv       7@  Bk @,;@  ,BY @B B@\n            r@       @G     5.      ,@v   BZ :::,.r@E .::i,      @B     B@    .@BL       7@  @F B:i@. .@  @M @B\n            7B: ,vO, @@   iB@:      @B   7@:MB@B@B@@@B@B@BM       @@.    B:  2@q         7@  BS @i 0@  B. @O B@\n       ,r2EBB@B@B@Bi G@  @BB        B@   @B        @S              :    r@   ..          7B  @F @7  B7 @  @B @B\n       E@B@UOBr       @B@Bi          L@0PB        .BZ        .@B@B@B@B@B@B@B@B@B@B@B@,   r@  BF @i  @G B@B@B B@\n            7@,      kB@U    ;r        @@@.       .@Z                GBuL@iBBi           vB@B@q BP:5@7 @u,.  @B\n            LBi   YB@BrB@    @@       @B:L@Br      BM             .M@B  rB  rB@J         v@. Pi @XZ8r  .     B@\n        .   G@i B@BM.  ,B@,  @B    iB@B    N, 7r..q@k         ,LB@B8    J@,   i@B@B1r           Br           @@\n        MB@B@B  ,i       B@B@B,    B@:        @B@B@F         .@BB:      P@i      :OBZ          .@U       B@B@B:\n                          .ll                                           rB.                     :\n*/\n//--------------------------------Informations-----------------------------------------\n//Introduction: Written by vegetable_bird,e.g.,me.\n//Hate things: DP(very much,(especially Tree_DP))\n//Like things: brute force\n//Submission OJ: codeforces\n//Problem:\n//Date:\n//Status: Unknown\n//--------------------------------Informations-----------------------------------------\n#pragma comment(linker, \"/stack:20000000\")\n#pragma warning(disable:4146)\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define _CRT_SECURE_NO_WARNINGS\n//#define __NOT_WANT_TO_DEBUG__\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdalign>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <string>\n#include <typeinfo>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ull hash_type;\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define Rep(i,a,b) for (int i=(a);i<=(b);i++)\n#define repit(it,a) for (__typeof(a.begin()) it=a.begin();it!=a.end();++it)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define RET(p,x) return p<<x<<endl,0\n#define all(a) (a).begin(),(a).end()\n#define reunique(v) v.erase(unique(all(v)),v.end())\n#define sz(a) (int)a.size()\n#define pb push_back\n#define eb emplace_back\n#define X first\n#define Y second\n#define sqr(x) ((x)*(x))\n#define assert(...) if (!__VA_ARGS__) throw 0\n#if !defined(__NOT_WANT_TO_DEBUG__)\n#define Debug(...) __debug_assistant(#__VA_ARGS__,__VA_ARGS__)\ntemplate<typename T>void __debug_assistant(const char* name,T&& t){cerr<<name<<\" = \"<<t<<endl;}\ntemplate<typename T1,typename... T>void __debug_assistant(const char* names,T1&& t1,T&&... t){const char* comma=strchr(names+1,',');cerr.write(names,comma-names)<<\" = \"<<t1<<\", \";__debug_assistant(comma+1,t...);}\n#else\n#define Debug(...)\n#endif\nvoid print(){}\nvoid print(int x){__builtin_printf(\"%d\",x);}\nvoid print(long long x){__builtin_printf(\"%lld\",x);}\nvoid print(char x){putchar(x);}\nvoid print(const char *x){__builtin_printf(\"%s\",x);}\nvoid print(unsigned x){__builtin_printf(\"%u\",x);}\nvoid print(unsigned long long x){__builtin_printf(\"%llu\",x);}\nvoid print(float x){__builtin_printf(\"%.15f\",x);}\nvoid print(double x){__builtin_printf(\"%.15lf\",x);}\nvoid print(long double x){__builtin_printf(\"%.15lf\",x);}\nvoid print(const string &x){__builtin_printf(\"%s\",x.c_str());}\ntemplate<typename Y,typename ...T>void print(Y t1,T ...t){print(t1);print(' ');print(t...);}\ntemplate<typename T>void print_arr(T a,T b){for(print(*a++);a!=b;++a){print(' ');print(*a);}}\n#define println(...) print(__VA_ARGS__),__builtin_putchar('\\n')\nvoid input(){}\nvoid input(int &x){__builtin_scanf(\"%d\",&x);}\nvoid input(long long &x){__builtin_scanf(\"%lld\",&x);}\nvoid input(char &x){__builtin_scanf(\"%c \",&x);}\nvoid input(char *x){__builtin_scanf(\"%s\",x);}\nvoid input(unsigned &x){__builtin_scanf(\"%u\",&x);}\nvoid input(unsigned long long &x){__builtin_scanf(\"%llu\",&x);}\nvoid input(float &x){__builtin_scanf(\"%f\",&x);}\nvoid input(double &x){__builtin_scanf(\"%lf\",&x);}\nvoid input(long double &x){__builtin_scanf(\"%lf\",&x);}\nvoid input(string &x){char s[1000005];__builtin_scanf(\"%s\",s);x=s;}\ntemplate<typename Y,typename ...T>void input(Y &t1,T &...t){input(t1);input(t...);}\ntemplate<typename T>void input_arr(T a,T b){for(;a!=b;++a){input(*a);}}\nvoid inputline(string &x,char cc='\\n'){for(char c=getchar();c!=cc;c=getchar())x+=cc;}\nvoid inputline(char *x,char cc='\\n'){string xx=\"\";inputline(xx,cc);__builtin_memcpy(x,xx.c_str(),sizeof(x));}\nvector<string> splitstring(const string&s,const string&c){vector<string> v;string::size_type pos1,pos2;pos2=s.find(c);pos1=0;while(string::npos!=pos2){v.push_back(s.substr(pos1,pos2-pos1));pos1=pos2+c.size();pos2=s.find(c,pos1);}if(pos1!=s.length())v.push_back(s.substr(pos1));}\nll gcd(ll a,ll b){while(b)b^=a^=b^=a%=b,Debug(a);return a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\ninline ll fastpow(ll a,ll b,ll mod){ll c=1;while(b){if(b&1)c=c*a%mod;a=a*a%mod;b>>=1;}return c;}\ninline ll fastpow(ll a,ll b){ll c=1;while(b){if(b&1)c*=a;a*=a;b>>=1;}return c;}\ninline bool isprime(const ll &x){if(x<=4||x%2==0||x%3==0){return x==2||x==3;}for(int i=5;i*i<=x;i+=6){if(x%i==0||x%(i+2)==0){return false;}}return true;}\ninline int reverse_bits(int x){x=((x>>1)&0x55555555)|((x<<1)&0xaaaaaaaa);x=((x>>2)&0x33333333)|((x<<2)&0xcccccccc);x=((x>>4)&0x0f0f0f0f)|((x<<4)&0xf0f0f0f0);x=((x>>8)&0x00ff00ff)|((x<<8)&0xff00ff00);x=((x>>16)&0x0000ffff)|((x<<16)&0xffff0000);return x;}\ninline ll reverse_bits(ll x){x=((x>>1)&0x5555555555555555ll)|((x<<1)&0xaaaaaaaaaaaaaaaall);x=((x>>2)&0x3333333333333333ll)|((x<<2)&0xccccccccccccccccll);x=((x>>4)&0x0f0f0f0f0f0f0f0fll)|((x<<4)&0xf0f0f0f0f0f0f0f0ll);x=((x>>8)&0x00ff00ff00ff00ffll)|((x<<8)&0xff00ff00ff00ff00ll);x=((x>>16)&0x0000ffff0000ffffll)|((x<<16)&0xffff0000ffff0000ll);x=((x>>32)&0x00000000ffffffffll)|((x<<32)&0xffffffff00000000ll);return x;}\ntemplate<class T>inline bool odd(T x){return x&1;}template<class T>inline bool even(T x){return !odd(x);}\ntemplate<class T>inline T lowbit(T x){return x&-x;}template<class T>inline T highbit(T x){T p=lowbit(x);while(p!=x)x-=p,p=lowbit(x);return p;}\ntemplate<class T>inline T coverbit(T x){T p=1;while(p<x)p<<=1;return p;}\ntemplate<class T>inline int coveridx(T x){int p=0;while((1<<p)<x)++p;return p;}\ninline int clz(int x){return __builtin_clz(x);}\ninline int clz(ll x){return __builtin_clzll(x);}\ninline int ctz(int x){return __builtin_ctz(x);}\ninline int ctz(ll x){return __builtin_ctzll(x);}\ninline int lg2(int x){return !x?-1:31-clz(x);}\ninline int lg2(ll x){return !x?-1:63-clz(x);}\ninline int lowidx(int x){return !x?-1:ctz(x);}\ninline int lowidx(ll x){return !x?-1:ctz(x);}\ninline int highidx(int x){return lg2(x);}\ninline int highidx(ll x){return lg2(x);}\ninline int parity(int x){return __builtin_parity(x);}\ninline int parity(ll x){return __builtin_parityll(x);}\ninline int count_bits(int x){return __builtin_popcount(x);}\ninline int count_bits(ll x){return __builtin_popcountll(x);}\nconst short single_test=1;\nconst int inf=1e9;\nconst long long lnf=1e18;\nconst long long h1=239017,h2=731604233;\nconst long long mod=1000000007,mod2=1000000009;\nconst long double pi=3.141592653589793238462643383279;\nconst long double EPS=1e-9;\nconst int Maxn=3e2+3;\nstring s,t;\nint k,ans;\nint dp[Maxn][Maxn];\nint dp2[Maxn][Maxn];\nbool solve(const int &test)\n{\n\tinput(s,k);\n\tt=s;\n\treverse(t.begin(),t.end());\n\tint n=sz(s);\n\tRep(i,1,n)\n\t{\n\t\tRep(j,1,n)\n\t\t{\n\t\t\tif (s[i-1]==t[j-1]) dp[i][j]=dp[i-1][j-1]+1;\n\t\t\telse dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\n\t\t}\n\t}\n\tRep(i,1,k)\n\t{\n\t\tmemset(dp2,0,sizeof(dp2));\n\t\tRep(i,1,n)\n\t\t{\n\t\t\tRep(j,1,n)\n\t\t\t{\n\t\t\t\tif (s[i-1]==t[j-1]) dp2[i][j]=dp2[i-1][j-1]+1;\n\t\t\t\telse dp2[i][j]=max({dp2[i-1][j],dp2[i][j-1],dp[i-1][j-1]+1});\n\t\t\t}\n\t\t}\n\t\tmemcpy(dp,dp2,sizeof(dp));\n\t}\n\tRep(i,1,n-1) ans=max(ans,2*dp[i][n-i]);\n\trep(i,n) ans=max(ans,2*dp[i][n-1-i]+1);\n\tprintln(ans);\n}\nvoid main_init()\n{\n}\nsigned main()\n{\n\tmain_init();\n\tint tests=single_test;\n\tif (!tests) __builtin_scanf(\"%d\",&tests);\n\telse if (tests<0) tests=100000000;\n\tfor (int test=1;test<=tests;++test)\n\t\tif (solve(test))\n\t\t\tbreak;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[310][310][310],n;\nchar s[310];\nint dfs(int l,int r,int k){\n\tif(k<0)return -1000000007;\n\tif(l>r)return 0;\n\telse if(l==r)return 1;\n\tif(~dp[l][r][k])return dp[l][r][k];\n\tdp[l][r][k]=max(dfs(l+1,r,k),dfs(l,r-1,k));\n\tdp[l][r][k]=max(dp[l][r][k],dfs(l+1,r-1,k-(s[l]!=s[r]))+2);\n//\tprintf(\"{%d,%d,%d,%d}\",l,r,k,dp[l][r][k]);\n\treturn dp[l][r][k];\n}\nint main(){\n\tmemset(dp,-1,sizeof(dp));\n\tscanf(\"%s%d\",s+1,&n);\n\tprintf(\"%d\\n\",dfs(1,strlen(s+1),n));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nchar a[1000];\nint dp[305][305][305];\nint main()\n{\n    int n = 0, m, ans = 0;\n    cin >> a + 1;\n    cin >> m;\n    for(int i = 1; a[i] != 0; i ++)\n        n = i;\n    for(int i = 1; i <= n; i ++)\n        for(int j = n ; j >= i; j --)\n        {\n            for(int k = 0; k <= m; k ++)\n            {\n                if(i == j)\n                    dp[i][j][k] = dp[i - 1][j + 1][k] + 1;\n                else\n                {\n                    if(k > 0)\n                        dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j + 1][k - 1] + 2);\n                    if(a[i] == a[j])\n                        dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j + 1][k] + 2);\n                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k]);\n                    dp[i][j][k] = max(dp[i][j][k], dp[i][j + 1][k]);\n                }\n                //cout << i << \" \" << j << \" \" << k << \"  \" << dp[i][j][k] << endl;\n                ans = max(ans, dp[i][j][k]);\n            }\n        }\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 405\nusing namespace std;\nchar s[N];int K,dp[N][N][N];\nint main(){\n\tscanf(\"%s\",s+1);scanf(\"%d\",&K);\n\tint n=strlen(s+1);\n\tfor (int i=1;i<=n;i++) dp[i][i][0]=1;\n\tfor (int len=1;len<n;len++){\n\t\tfor (int l=1;l<=n-len+1;l++){\n\t\t\tint r=l+len-1;\n\t\t\tif (s[l]==s[r]){\n\t\t\t\tfor (int k=0;k<=K;k++)\n\t\t\t\t\tdp[l-1][r+1][k]=max(dp[l-1][r+1][k],dp[l][r][k]+2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int k=0;k<=K;k++) dp[l-1][r][k]=max(dp[l-1][r][k],dp[l][r][k]),dp[l][r+1][k]=max(dp[l][r+1][k],dp[l][r][k]);\n\t\t\t\tfor (int k=1;k<=K;k++) dp[l-1][r+1][k]=max(dp[l-1][r+1][k],dp[l][r][k-1]+2);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor (int i=0;i<=K;i++) ans=max(ans,dp[1][n][i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\n//const ll inf=0x3f3f3f3f3f3f3f3fll;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\nchar s[333];\nint n;\nint k;\n\nint dp[305][305][165];\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tgs(s+1);\n\tn=strlen(s+1);\n\tgn(k);\n\tupmin(k,160);\n\trep(t,0,k+1){\n\t\trep(i,1,n+1)\n\t\t\trep(j,i,n+1)\n\t\t\t\tupmax(dp[i][j][t],1);\n\t\trep(d,-1,n+1){\n\t\t\trep(i,1,n+1){\n\t\t\t\tint j=i+d;\n\t\t\t\tif(i-1>=1 && j+1<=n){\n\t\t\t\t\tif(s[i-1]==s[j+1]){\n\t\t\t\t\t\tupmax(dp[i-1][j+1][t],dp[i][j][t]+2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tupmax(dp[i-1][j+1][t],dp[i][j][t]);\n\t\t\t\t\t\tupmax(dp[i-1][j+1][t+1],dp[i][j][t]+2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i-1>=1)\n\t\t\t\t\tupmax(dp[i-1][j][t],dp[i][j][t]);\n\t\t\t\tif(j+1<=n)\n\t\t\t\t\tupmax(dp[i][j+1][t],dp[i][j][t]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[1][n][k]);\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<string>\n#include<iostream>\n\nusing namespace std;\ntypedef long long LL;\n\nconst int maxs=310;\nchar ch[maxs],cha[maxs];\nint k,dp[maxs][maxs];\n\nint Cal()\n{\n    int len=strlen(ch);\n    for(int i=0;i<len;i++)\n        cha[len-1-i]=ch[i];\n    for(int i=0;i<len;i++)\n        for(int j=0;j<len;j++)\n        if(ch[i]==cha[j]) dp[i+1][j+1]=dp[i][j]+1;\n        else dp[i+1][j+1]=max(dp[i][j+1],dp[i+1][j]);\n    int ans=dp[len][len]+2*k;\n    if(ans<=len) return ans;\n    else return len;\n}\n\nint main()\n{\n    scanf(\"%s\",&ch);\n    scanf(\"%d\",&k);\n    printf(\"%d\\n\",Cal());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define mp make_pair\n#define pb push_back\nconst int M=301;\nint n,m,x,y;\nint dp[M][M][M];\nstring s;\nint calc(int i,int j,int c){\n    if(c<0)return -1e9;\n    if(j<=i)return j==i;\n    int &k=dp[i][j][c];\n    if(k!=-1)return k;\n    k=max(calc(i+1,j,c),calc(i,j-1,c));\n    return k=max(k,2+calc(i+1,j-1,c-(s[i]!=s[j])));\n}\nint main()\n{\n    memset(dp,-1,sizeof dp);\n    cin>>s>>x;\n    n=s.size();\n    cout<<calc(0,n-1,x);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<cassert>\n#pragma warning(disable:4996)\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define MRE assert(0)\nconst int mod = 1000000007;\nconst long long inf = 1ll << 61;\ntypedef pair<int, int> P;\ntypedef pair<P, int>PP;\nint dp[305][305][305];\nsigned main() {\n\tstring s; cin >> s; int K; cin >> K; int n = s.size();\n\trep(i, n)dp[i][i][0] = 1;\n\n\trep(i, n) {//幅\n\t\tfor (int j = 0; j + i < n; j++) {//[j,j+i]\n\t\t\trep(k, K + 1) {\n\t\t\t\tif (j) {\n\t\t\t\t\tdp[j - 1][j + i][k] = max(dp[j - 1][j + i][k], dp[j][j + i][k]);\n\t\t\t\t}\n\t\t\t\tif (j + i < n - 1) {\n\t\t\t\t\tdp[j][j + i + 1][k] = max(dp[j][j + i + 1][k], dp[j][j + i][k]);\n\t\t\t\t}\n\t\t\t\tif (j&&j + i < n - 1) {\n\t\t\t\t\tif (s[j - 1] == s[j + i + 1]) {\n\t\t\t\t\t\tdp[j - 1][j + i + 1][k] = max(dp[j - 1][j + i + 1][k], dp[j][j + i][k] + 2);\n\t\t\t\t\t}\n\t\t\t\t\telse if (k != K) {\n\t\t\t\t\t\tdp[j - 1][j + i + 1][k + 1] = max(dp[j - 1][j + i + 1][k + 1], dp[j][j + i][k] + 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\trep(i, n)rep(j, n)rep(k, n + 1)res = max(res, dp[i][j][k]);\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int maxn=3e3+5;\nint dp[maxn][maxn],a1[maxn],a2[maxn],n,m;\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)scanf(\"%d\",&a1[i]);\n    for(int i=1;i<=n;i++)scanf(\"%d\",&a2[i]);\n    for(int i=1;i<=n;i++)\n     for(int j=1;j<=n;j++)\n      {\n        dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\n        if(a1[i]==a2[j])\n        dp[i][j]=max(dp[i][j],dp[i-1][j-1]+1);\n      }\n    printf(\"%d\",dp[n][n]);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                             UM.\n                            J@B@1                                                                    iO@1\n                           Y@@@B@BB.                                                              7B@B@B@\n                          :@B@i,B@B@O                                                          ,Z@B@B@B@Br\n                          @B@q   i@B@BS                                                      7@B@@@O5vMB@q\n                         8@@B      LB@B@i                                                  FB@@@BNjYjLE@B@\n                        ,B@B:        0@@@Z                                               P@B@BM1JJ125JPB@B\n                        B@BB          :@B@B                                            XB@B@Z2LuU52F2u2@B@.\n                       :@B@             @@@B:                                        v@B@B8uJj51F1525uUB@B7\n                       @B@O              0@@B.               ..::ir7vvYUuU777r::.   B@B@OULU2F2F151F11Y@B@S\n                       B@B,               8B@B  :ruXMB@B@B@B@B@B@B@B@B@B@@@B@B@B@B@B@B@5Jj1211F1F1F2FUJO@BB\n                      U@B@                 @B@B@B@B@B@@@B@B@B@MMqPS5JuYL7rq@B@OBB@B@B8Yu211F1515251515YGB@@\n                      @B@u                 v@@@@MSur:.                    LB@MvvjJuU5YU252F1F1F25251F2uX@@@\n                      @@@.                                                N@BML2U2UUU12F15252525251515Jk@@B\n                     r@B@                                                 YB@Bju52121252515252F15251F2u5@B@\n                     PB@B                                                  @@@PYUF151F25151F152F2F1F15jF@@B\n                     @@BS                                                  N@@@UJ2F25252F251525151F1F1u5@B@\n                     @@@7                                                   B@B@5Yj12F152F1F1F25252515jFB@B\n                     B@Bi                                                    M@B@O2Luu52525212F151121UY1@B@7\n                    O@B@:                                                     v@B@BMSuYJJuuUu2u2uujjYJJXB@B@M\n                  7B@B@,                                                        1B@@@B@GPF1uujuu21PNMB@B@B@B@@\n                 qB@B2                                                            i8B@B@B@B@B@@@@@B@B@B@q: @@@B\n                MB@B:                                                                 7SBB@B@B@B@B@Zu:      @B@B\n               ZB@B.                                              ,v.                                        @B@L\n              LB@B,                         Y7                    @B@Bu                                      7@B@\n   :B@B@@B2:  @@B7                         @B@Z                   r@B@B@BP:                                   B@BE\n    BB@@@B@B@B@BE                        r@B@B                       7@B@B@B@Ou:                              iB@B\n         :uM@@B@@2.           :7::::ivk@B@B@0                           :5B@B@B@B@B@B@G.                       @B@i\n            BB@@@B@@         :@B@B@@@B@B@@1                                 .i5M@B@B@@@5                       M@@2\n            B@B ,@B1          L0EZZG0F7:                                            .:,                        uB@MrP@M7\n           2@B@                                                                                               ,O@B@B@B@B\n           @B@1                                                     :@B@@@r                                :@@@@B@BL:,,\n           B@Bi                         :2ZS;                      :@B@B@B@r                               L@B@B@BU\n           @B@.                        @@@B@B@                     vB@B@B@B5                                   @B@i\n           B@B                        7B@B@B@BM                     OB@B@B@                                   ,B@B\n           @B@                         @B@B@@@i                       rL7.                                    B@BM\n           B@B7.:                       NB@@M.                                                               .@B@.\n  .;JEB@@@B@B@B@B@.                                                                                       .  @B@u\n@@@B@B@B@B@@@B@18U                                                                                      :B@B@B@BU,\n7@BOui.    ,@@B                                                                                          SP@B@B@B@B@Or\n            @@@U                                                                                           B@BJ.YO@B@B@i\n            r@B@                                                                                         :B@Bk     .k@B@\n             B@B@                                                                                       LB@@k         2i\n              B@BM                                      .7jXEGqF7:                                     OB@@L\n              .B@BM                                   .B@B@B@B@B@B@.                                 :@B@B:\n               .B@B@                                   @@MYr::ivG@B                                .M@B@G\n                 B@@@S                                                                           ,MB@B@,\n                  v@@@BF                                                                      .1B@B@Br\n                    2@@B@BL                                                                ,FB@@@B8,\n                      r@B@B@BF,                                                        :YBB@B@B@B\n                         L@B@B@B@P7,                                           .ivXB@B@B@B@B@M@B@\n                            ,1B@B@B@B@@@BOP2L7i:,.              ..,:i7LSNB@@B@B@@@B@B@B@Z5v;.LB@@\n                              @B@OEB@B@@@B@B@B@B@B@B@B@B@@@B@B@B@B@B@@@B@B@B@B@BM0SJ7i::::i:,u@B@\n                              B@Bu ::i;7vu2XNGOMB@B@BMB@B@B@B@B@B@@@B1UFuj77ii:::::::iir;r;i.YB@B\n                              @B@L.:i:i:i::::::::::..Y@B@BMYi:i;SB@B@N:.::i:iirir;r;rii::::ivO@B@\n                              B@@X::,::::iirir;riri:E@B@1         ,@B@Br:;;r;rii:i::::i7JEB@@@@@B\n                              @@@B@BBq5v7ii:::::::.2@@@i  ..,..     @B@@,,:::::irv2XMB@B@B@B@2@B@:\n                             .B@BBB@@@B@B@B@BMNP5u7@B@1 .,,:,,  :.   @B@P50MB@B@B@B@B@@@BS:   @@B1\n                             E@B@   ijGB@B@B@B@B@B@B@Bi .,:,,..@@B@7 B@B@B@B@B@B@BM57.        kB@B\n                            .@B@:          .,ivu5Nq@B@u  ..,.. SB@B@@@B@PL7i,                 ,@B@\n                            @@@8                   i@B@:    .     :B@B@@                       B@@2\n                          i@@@@                     0@B@u          B@@B.                       vB@B\n                         ,@B@G                       L@B@BOv:.:iFB@B@M                          @B@Bi\n                          vNi                          S@@B@B@B@B@BM:                            MB@N\n                                                          758BMqJ,\n\n                 .  YO.               vq                            :G       Z:\n        SqOMBB@B@Br @@r rBE           @B     B@@@@@B@ONX8k    i::::.OB1.:::.u@O.::::i           @B@B@U:@@B@@BPEBu\n        B@@NB@k.    5@i  uB@E.        BM     1U2uUJvirB@@Z   r@@B@B@@@B@B@B@B@B@@@B@Bi   LB@B@1 BX :@k uLLLvr@BJ:\n            iB      iBi    7@     .@M8@BGMZZ         @@F            ,B       Pi          v@  Bq @i v@        B@\n       vuL7r8@S7vJL7N@Z7LLri;72.   F7@Bvvv@@       @BX         @@@B@B@@@@@B@@@B@B@B      7@  @F Bi @q  @B@Bu @B\n       N@B@G@@@8@BBOMB@G@BMNXG@,     B@   @@      .Bk          .:u;    i@:      Zv       7@  Bk @,;@  ,BY @B B@\n            r@       @G     5.      ,@v   BZ :::,.r@E .::i,      @B     B@    .@BL       7@  @F B:i@. .@  @M @B\n            7B: ,vO, @@   iB@:      @B   7@:MB@B@B@@@B@B@BM       @@.    B:  2@q         7@  BS @i 0@  B. @O B@\n       ,r2EBB@B@B@Bi G@  @BB        B@   @B        @S              :    r@   ..          7B  @F @7  B7 @  @B @B\n       E@B@UOBr       @B@Bi          L@0PB        .BZ        .@B@B@B@B@B@B@B@B@B@B@B@,   r@  BF @i  @G B@B@B B@\n            7@,      kB@U    ;r        @@@.       .@Z                GBuL@iBBi           vB@B@q BP:5@7 @u,.  @B\n            LBi   YB@BrB@    @@       @B:L@Br      BM             .M@B  rB  rB@J         v@. Pi @XZ8r  .     B@\n        .   G@i B@BM.  ,B@,  @B    iB@B    N, 7r..q@k         ,LB@B8    J@,   i@B@B1r           Br           @@\n        MB@B@B  ,i       B@B@B,    B@:        @B@B@F         .@BB:      P@i      :OBZ          .@U       B@B@B:\n                          .ll                                           rB.                     :\n                                                                                    “我好菜啊”商标(2018) by Charlieyan\n*/\n/*****************\n *   I<3   C++   *\n *  IWANT ANYAC  *\n * ILOVEPROGRAM! *\n *IT'SINTERESTING*\n * ILOVEPROGRAM! *\n *  INCONTESTS   *\n *   GETSCORE    *\n *    ACCODE     *\n *     LETS      *\n *      GO       *\n *Written by:    *\n *    charlieyan *\n *****************/\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <locale>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cerrno>\n#include <clocale>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <limits>\n#include <map>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <istream>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <utility>\n#include <vector>\n#include <cwchar>\n#include <cwctype>\n#include <complex.h>\n#include <fenv.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <tgmath.h>\n#include <numeric>\n#include <list>\n#define LL long long\n#define pb push_back\n#define pob pop_back\n#define mp make_pair\n#define FILL(a,v) memset((void*)a,v,sizeof(a))\n#define FILL0(a) FILL(a,0)\n#define FILL1(a) FILL(a,-1)\n#define FILLBIG(a) FILL(a,0x7f)\n#define ALL(a) (a).begin(),(a).end()\n#define Inf ((int)0x7f7f7f7f)\n#define INF ((long long)0x7f7f7f7f7f7f7f7f)\n#define Mod 1000000007\n#define foreach(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define RFOR(i,x) for(int i=x-1;i>=0;i--)\n#define FFOR(i,a,b) for(int i=a;i<b;i++)\n#define FRFOR(i,a,b) for(int i=a-1;i>=b;i--)\n#define SZ(a) ((int)(a).size())\n#define FI first\n#define SE second\n#define OVER(a) return puts(a),0\n#define fastio ios::sync_with_stdio(0)\n#define filei(f) freopen(f,\"r\",stdin)\n#define fileo(f) freopen(f,\"w\",stdout)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define MASK(a) (1<<(a))\n#define MASKX(x,a) ((x)<<(a))\n#define BIT(a,b) ((a>>b)&1)\n#define cddx(a) priority_queue<a >\n#define cxdd(a) priority_queue<a,vector<a >,greater<a > >\n#define deval(a) {cerr<<#a<<\" = \"<<a<<endl;}\n#define dearr(be,en) {cerr<<#be;cerr<<\" = {\";for(auto i=be;i!=en;i++)cerr<<' '<<*i;cerr<<\" }\\n\";}\n#define reg register\n#define prtime eprintf(\"\\n\\nTime used: %dms\\n\",clock());\n#define PI 3.1415926535897932384626\n//Xuzhen[The virus] is a BIG 13 !!!\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef unsigned long long UINT;\ntypedef unsigned int uint;\ntypedef long long INT;\ntypedef long double ldouble;\ntypedef pair<INT,INT> PII;\ntypedef stringstream sst;\ntypedef istringstream iss;\ntypedef vector<int> vint;\ntypedef vector<INT> VINT;\ntypedef vector<pii> vpii;\ntypedef vector<PII> VPII;\ntypedef priority_queue<int> pqi;\ntypedef priority_queue<INT> PQI;\ntypedef priority_queue<pii> pqp;\ntypedef priority_queue<PII> PQP;\ntypedef priority_queue<int,vint,greater<int> > xqi;\ntypedef priority_queue<INT,VINT,greater<INT> > XQI;\ntypedef priority_queue<pii,vpii,greater<pii> > xqp;\ntypedef priority_queue<PII,VPII,greater<PII> > XQP;\n\nint k;\nstring s,t;\nint dp[2][307][307];\n\nint main()\n{\n    cin >> s;\n    cin >> k;\n    t = s;\n    int n = SZ(s);\n    reverse(t.begin(), t.end());\n    s = ' ' + s;\n    t = ' ' + t;\n    //Calculate LCS between s and t\n    int now = 0, lst = 1;\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++)\n        {\n            if(s[i]==t[j])\n                dp[now][i][j] = dp[now][i - 1][j - 1] + 1;\n            else\n                dp[now][i][j] = max(dp[now][i - 1][j], dp[now][i][j - 1]);\n        }\n    //Start changing\n    for (int ii = 0; ii < k; ii++)\n    {\n        swap(now, lst);//Round dp\n        FILL0(dp[now]);\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n            {\n                if(s[i]==t[j])\n                    dp[now][i][j] = dp[now][i - 1][j - 1] + 1;\n                else\n                    dp[now][i][j] = max(max(dp[now][i - 1][j], dp[now][i][j - 1]), dp[lst][i - 1][j - 1] + 1 /*Have a change*/);\n            }\n    }\n    //Duicheng\n    int ans = 0;\n    for (int i = 1; i <= n; i++)\n        ans = max(ans, 2 * dp[now][i][n - i]);\n    for (int i = 1; i <= n; i++)\n        ans = max(ans, 2 * dp[now][i][n - i - 1] + 1);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nint n,q,ans;\nchar s[305];\nint dp[305][305][305];\nint main(void){\n    cin>>s>>q;\n    n=strlen(s);\n    for(int i=0;i<n;i++)dp[q][i][i]=1;\n    for(int i=0;i<n-1;i++){\n        if(s[i]==s[i+1])dp[q][i][i+1]=2;\n        else dp[q][i][i+1]=1;\n    }\n    for(int i=0;i<n-1;i++)if(s[i]!=s[i+1]&&q>0)dp[q-1][i][i+1]=2;\n    for(int k=1;k<n;k++){\n        for(int i=0;i+k<n;i++){\n            int l=i,r=i+k;\n            for(int j=0;j<=q;j++){\n                if(s[l]==s[r]){\n                    dp[j][l][r]=max(dp[j][l][r],dp[j][l+1][r-1]+2);\n                }else if(j<q){\n                    dp[j][l][r]=max(dp[j][l][r],dp[j+1][l+1][r-1]+2);\n                }\n                dp[j][l][r]=max(dp[j][l][r],max(dp[j][l+1][r],dp[j][l][r-1]));\n            }\n        }\n    }\n    for(int i=0;i<=q;i++)ans=max(ans,dp[i][0][n-1]);\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n//#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nint dp[333][333][333] = {};\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,x;\n  string s;\n  cin >> s >> x;\n\n  n = s.size();\n  REP(i,n) dp[i][i+1][0] = 1;\n\n  REP(len,n+1){\n    FOR(i,0,n+1){\n      int j = i+len;\n      if(j>=n) break;\n      REP(k,x+1){\n        if(i) chmax(dp[i-1][j+1][k+(s[i-1]!=s[j])],dp[i][j][k]+2);\n        chmax(dp[i][j+1][k],dp[i][j][k]);\n        if(i) chmax(dp[i-1][j][k],dp[i][j][k]);\n      }\n    }\n  }\n\n  int ans = 0;\n  REP(i,x+1) chmax(ans,dp[0][n][i]);\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define mod 1000000007LL\n#define eps 1e-13\n// #define PI 3.141592653589793238L\n#define INF 1000000011\n#define INFLL 1000000000000000011LL\n#define vi vector<int>\n#define vll vector<long long>\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define pil pair<int, long long>\n#define pli pair<long long, int>\n#define mp make_pair\n#define F first\n#define S second\n#define pb push_back\n#define fo(i,a,n) for(i = (a); i < (n); i++)\n#define gtl(x) getline(cin, (x))\n#define flsh fflush(stdout)\n#define sws ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)\n#define gcd __gcd\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)((a).size())\n#define io_file freopen(\"D:/Coding Problems/Contest/input_file.in\", \"r\", stdin); freopen(\"D:/Coding Problems/Contest/output_file.out\", \"w\", stdout)\n\nll modx(ll Base, ll exponent)\n{\n\tll ans = 1;\n\tif(Base == 1)\n\t\treturn Base;\n\twhile(exponent)\n\t{\n\t\tif(exponent & 1)\n\t\t\tans = (ans * Base)%mod;\n\t\tBase = (Base * Base)%mod;\n\t\texponent = exponent >> 1;\n\t}\n\treturn ans;\n}\n\nll inmodx(ll num)\n{\n\treturn (modx(num, mod-2LL));\n}\n\nbool cmp(pair < pii, int > a, pair < pii, int > b)//true for a before b\n{\n\tif(a.F.F/300 < b.F.F/300)\n\t\treturn 1;\n\tif(a.F.F/300 > b.F.F/300)\n\t\treturn 0;\n\tif(a.F.S < b.F.S)\n\t\treturn 1;\n\tif(a.F.S > b.F.S)\n\t\treturn 0;\n\tif(a.F <= b.F)\n\t\treturn 1;\n\treturn 0;\n}\n\nconst int N = (3e2) + 9;\nconst int M = (N<<2) + 9;\nconst int LOGN = ((int)log2(N)) + 3;\nconst int LOGM = ((int)log2(M)) + 3;\nconst int BUCK = 2*550;\nconst int SQRT = BUCK+9;\n\nint dp[N][N][N];\nstring s;\nint n, K;\n\nvoid solve()\n{\n\tint i, j, k, ans = 0;\n\tcin >> s;\n\tcin >> K;\n\tn = s.length();\n\tfo(i,1,n+1)\n\t\tfo(j,1,n-i+1+1)\n\t\t\tfo(k,0,K+1)\n\t\t\t{\n\t\t\t\tif(s[i-1] == s[n-j])\n\t\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k] + ((i+j < n) ? 2 : 1));\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k]);\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k]);\n\t\t\t\tif(k > 0)\n\t\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k-1] + ((i+j < n) ? 2 : 1));\n\t\t\t\tans = max(ans, dp[i][j][k]);\n\t\t\t}\n\tcout << ans << '\\n';\n\treturn;\n}\n\nint main()\n{\n\tsws;\n\tclock_t clk;\n\tclk = clock();\n\t// io_file;\n\t// srand (time(NULL));\n\n\t//Code here\n\tint t = 1, cs;\n\tcout << fixed << setprecision(9);\n\t// cin >> t;\n\tfo(cs,1,t+1)\n\t{\n\t\t// cout << \"Case #\" << cs << \": \";\n\t\tsolve();\n\t}\n\t// Code ends here\n\n\tclk = clock() - clk;\n\tcerr << fixed << setprecision(6) << \"Time: \" << ((double)clk)/CLOCKS_PER_SEC << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...)\n#endif\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    string s;\n    int k;\n    cin >> s >> k;\n    int n = s.size();\n    int dp[n][n][k] = {};\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i; j <= n - 1; j++) {\n            for (int l = 0; l <= k; l++) {\n                if (i == j) {\n                    dp[i][j][l] = 1;\n                } else if (i + 1 == j) {\n                    dp[i][j][l] = 2;\n                    if (l == 0 && s[i] != s[j]) {\n                        dp[i][j][l] = 1;\n                    }\n                } else {\n                    dp[i][j][l] = max(dp[i + 1][j][l], dp[i][j - 1][l]);\n                    if (s[i] == s[j]) {\n                        dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l] + 2);\n                    } else if (l != 0) {\n                        dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l] + 1);\n                        dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l - 1] + 2);\n                    }\n                }\n            }\n        }\n    }\n    cout << dp[0][n - 1][k] << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=310;\nchar s[N]; int k,dp[N][N][N];\ninline void cmax(int &x,int y){x=max(x,y);}\ninline int dfs(int a,int b,int c){\n\tif(a==b)return 1; if(a>b)return 0;\n\tif(dp[a][b][c])return dp[a][b][c];\n\tif(s[a]==s[b])cmax(dp[a][b][c],dfs(a+1,b-1,c)+2);\n\telse if(c)cmax(dp[a][b][c],dfs(a+1,b-1,c-1)+2);\n\tcmax(dp[a][b][c],dfs(a+1,b,c));\n\tcmax(dp[a][b][c],dfs(a,b-1,c));\n\treturn dp[a][b][c];\n}\nint main(){\n\tscanf(\"%s%d\",s+1,&k); int len=strlen(s+1);\n\tfor(int i=1; i<=len; ++i)dp[i][i][0]=1;\n\tint ans=0;\n\tfor(int i=1; i<=len; ++i)\n\t\tfor(int j=i; j<=len; ++j)\n\t\t\tcmax(ans,dfs(i,j,k));\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <bitset>\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define szz(x) ((int)(x).size())\n#define rep(i, n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(), (x).end()\ntypedef tuple<int, int, int> t3;\ntypedef pair<ll, ll> pll;\ntypedef long double ldouble;\ntypedef pair<ldouble, ldouble> pdd;\n\nchar S[310];\nint K;\nint D[310][310][310];\n\nvoid solve() {\n\tscanf(\"%s%d\", S+1, &K);\n\tint L = (int)strlen(S+1);\n\tfor(int i=1;i<=L;i++) rep(j, K+1) D[i][i][j] = 1;\n\tfor(int i=1;i<L;i++) for(int j=1;j+i<=L;j++) {\n\t\tint l = j, r = j + i;\n\t\tfor(int k=0;k<=K+1;k++) {\n\t\t\tD[l][r][k] = max(D[l+1][r][k], D[l][r-1][k]);\n\t\t\tif(S[l] == S[r]) D[l][r][k] = max(D[l][r][k], D[l+1][r-1][k] + 2);\n\t\t\telse {\n\t\t\t\tif(k) D[l][r][k] = max(D[l][r][k], D[l+1][r-1][k-1] + 2);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", D[1][L][K]);\n}\n\nint main(){\n\tint Tc = 1; //scanf(\"%d\\n\", &Tc);\n\tfor(int tc=1;tc<=Tc;tc++){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#define mod 1000000007\n#define mod998 998244353\n#define sp ' '\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define mkp make_pair\ntypedef long long ll;\nusing namespace std;\n\nstring S, T;\nint K, res, DP[302][302][302];\nint main() {\n\tcin >> S >> K;\n\tT = S;\n\treverse(T.begin(), T.end());\n\tfor (int i = 0; i <= K; i++) {\n\t\tfor (int j = 0; j < S.size(); j++) {\n\t\t\tfor (int k = 0; k < T.size(); k++) {\n\t\t\t\tif (S[j] == T[k]) {\n\t\t\t\t\tDP[j + 1][k + 1][i] = max(DP[j + 1][k + 1][i], DP[j][k][i] + 1);\n\t\t\t\t}\n\t\t\t\tDP[j + 1][k][i] = max(DP[j + 1][k][i], DP[j][k][i]);\n\t\t\t\tDP[j][k + 1][i] = max(DP[j][k + 1][i], DP[j][k][i]);\n\t\t\t\tDP[j + 1][k + 1][i + 1] = max(DP[j + 1][k + 1][i + 1], DP[j][k][i] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tres = 1;\n\tfor (int i = 1; i < S.size(); i++) {\n\t\tres = max(res, DP[i][S.size() - i][K] * 2);\n\t\tres = max(res, DP[i][S.size() - i - 1][K] * 2 + 1);\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/* be name khoda */\n\n// #define stream_enable\n// #define long_enable\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <numeric>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#ifdef stream_enable\n#define cin sss\n#endif\n#ifdef long_enable\ntypedef long long int ll;\n#else\ntypedef int ll;\n#endif\n\ntypedef pair<ll, ll> pii;\ntypedef pair<pii, ll> ppi;\ntypedef pair<ll, pii> pip;\ntypedef vector<ll> vi;\ntypedef vector<pii> vpii;\n\nconst ll MOD = 1000000007;\nconst long long BIG = 1446803456761533460;\nconst int Big = 336860180;\n\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n\n#define debug(x) cout << #x << \" -> \" << (x) << endl\n#define debug2(x, y) cout << #x << ' ' << #y << \" -> \" << (x) << ' ' << (y) << endl\n#define debug3(x, y, z) cout << #x << ' ' << #y << ' ' << #z << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << endl\n#define debug4(x, y, z, t) cout << #x << ' ' << #y << ' ' << #z << ' ' << #t << \" -> \" << (x) << ' ' << (y) << ' ' << (z) << ' ' << (t) << endl\n#define debugp(x) cout << #x << \" -> \" << \"(\" << (x).F << \", \" << (x).S << \")\" << endl\n#define debuga(x, n) cout << #x << \" -> \"; fori (i1_da, n) { cout << (x)[i1_da] << ' '; } cout << endl\n#define debugap(x, n) cout << #x << \" ->\\n\"; fori (i1_dap, n) { cout << \"(\" << (x)[i1_dap].F << \", \" << (x)[i1_dap].S << \")\\n\"; } cout << endl\n#define debugaa(x, n, m) cout << #x << \" ->\\n\"; fori (i1_daa, n) { fori (i2_daa, m) { cout << (x)[i1_daa][i2_daa] << ' '; } cout << '\\n'; } cout << endl\n#define debugav(x, n) cout << #x << \" ->\\n\"; fori (i1_dav, n) { fori (i2_dav, (x)[i1_dav].size()) { cout << (x)[i1_dav][i2_dav] << ' '; } cout << '\\n'; } cout << endl\n#define debugia(x, n) cout << #x << \" ->\\n\"; fori (i1_dia, n) { cout << i1_dia << \" : \" << (x)[i1_dia] << '\\n'; } cout << endl\n\n#define forifrom(i, s, n) for(ll i = (s); i < (n); ++i)\n#define forirto(i, n, e) for(ll i = (n) - 1; i >= (e); --i)\n#define fori(i, n) forifrom (i, 0, n)\n#define forir(i, n) forirto (i, n, 0)\n\n#define smin(a, b) a = min(a, (b))\n#define smax(a, b) a = max(a, (b))\n\n#define Add(a, b) a = ((a) + (b)) % MOD\n#define Mul(a, b) a = (1LL * (a) * (b)) % MOD\n\nstringstream sss;\n\n// -----------------------------------------------------------------------\n\nconst ll maxn = 310;\n\nll N, K;\nstring S;\nll dp[maxn][maxn][maxn];\n\nvoid MAIN() {\n\n    cin >> S >> K;\n    N = S.size();\n    fori (i, N + 1) fill(dp[1][i], dp[1][i] + maxn, 1);\n    forifrom (k, 2, N + 1) {\n        fori (i, N - k + 1) {\n            fori (t, K + 1) {\n                if (S[i] == S[i + k - 1]) {\n                    dp[k][i][t] = dp[k - 2][i + 1][t] + 2;\n                } else {\n                    dp[k][i][t] = max(dp[k - 1][i][t], dp[k - 1][i + 1][t]);\n                    if (t > 0) smax(dp[k][i][t], dp[k - 2][i + 1][t - 1] + 2);\n                }\n            }\n        }\n    }\n    cout << dp[N][0][K] << '\\n';\n\n}\n\n// -----------------------------------------------------------------------\n\nint main() {\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cout << fixed << setprecision(10);\n    sss << R\"(\nabcabcabc\n1\n\n\natcodergrandcontest\n3\n    )\";\n    MAIN();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nstring S;\nint K;\nint dp[310][310][310] = {{{0}}};\nint main(){\n\tcin >> S >> K;\n\tint N = S.size();\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<=K;j++){\n\t\t\tdp[i][i+1][j] = 1;\n\t\t\tdp[i][i][j] = 0;\n\t\t}\n\t}\n\tfor(int i=1;i<N-1;i++){\n\t\tfor(int l=i;l>0;l--){\n\t\t\tfor(int r=i;r<N;r++){\n\t\t\t\tfor(int x=0;x<=K;x++){\n\t\t\t\t\tif(S[l-1]==S[r]) dp[l-1][r+1][x] = max(dp[l-1][r+1][x],dp[l][r][x]+2);\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[l-1][r+1][x+1] = max(dp[l-1][r+1][x+1],dp[l][r][x]+2);\n\t\t\t\t\t\tdp[l-1][r+1][x] = max(dp[l-1][r+1][x],max(dp[l-1][r][x],dp[l][r+1][x]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(int i=0;i<=N;i++){\n\t\tfor(int j=0;j<=N;j++){\n\t\t\tcout << dp[i][j][0] << (j!=N?\" \":\"\\n\");\n\t\t}\n\t}\n*/\tcout << dp[0][N][K] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC target(\"avx,sse4\")\n \n#define mms(a,n) memset(a,0,sizeof((a)[0])*(n))\n#define mmp(a,b,n) memcpy(a,b,sizeof((b)[0])*(n))\n#define lowbit(x) ((x)&-(x))\n#define pb push_back\n#define fi first\n#define se second\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define fo(i,l,r) for(register int i=l,_lim_=r;i<=_lim_;i++)\n#define fd(i,r,l) for(register int i=r,_lim_=l;i>=_lim_;i--)\n#define fos(i,l,r,d) for(register int i=l,_lim_=r;i<=r;i+=d)\n#define fol(i,l,r) for(register ll i=l,_lim_=r;i<=_lim_;i++)\n#define fdl(i,r,l) for(register ll i=r,_lim_=l;i>=_lim_;i--)\n#define fosl(i,l,r,d) for(register ll i=l,_lim_=r;i<=r;i+=d)\n#define Clear(a) memset(a,0,sizeof(a))\n#define Copy(a,b) memcpy(a,b,sizeof(b))\n#define ALL(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define sqr(x) ((x)*(x))\n#define GCD __gcd\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ldb;\ntypedef double db;\ntypedef pair<int,int> pi;\ntypedef vector<int> VI;\ntypedef vector<VI> VII;\n\nnamespace io{\n\tconst int L=(1<<21)+1;\n\tchar ibuf[L],*iS,*iT,obuf[L],*oS=obuf,*oT=obuf+L-1,c,st[55];int f,tp;\n\t#ifdef whzzt\n\t\t#define gc()getchar()\n\t#else\n\t\t#define gc()(iS==iT?(iT=(iS=ibuf)+fread(ibuf,1,L,stdin),(iS==iT?EOF:*iS++)):*iS++)\n\t#endif\n\tinline void flush(){fwrite(obuf,1,oS-obuf,stdout);oS=obuf;}\n\tinline void putc(char x){*oS++=x;if(oS==oT)flush();}\n\ttemplate<class I>\n\tinline void gi(I&x){\n\t\tfor(f=1,c=gc();c<'0'||c>'9';c=gc())if(c=='-')f=-1;\n\t\tfor(x=0;c<='9'&&c>='0';c=gc())x=x*10+(c&15);x*=f;\n\t}\n\ttemplate<class I>\n\tinline void print(I x){\n\t\tif(!x)putc('0');if(x<0)putc('-'),x=-x;\n\t\twhile(x)st[++tp]=x%10+'0',x/=10;\n\t\twhile(tp)putc(st[tp--]);\n\t}\n\tinline void gs(char*s,int&l){\n\t\tfor(c=gc();c<'a'||c>'z';c=gc());\n\t\tfor(l=0;c<='z'&&c>='a';c=gc())s[l++]=c;\n\t}\n\tinline void ps(const char*s){\n\t\tfo(i,0,strlen(s)-1)putc(s[i]);\n\t}\n};\nusing io::putc;\nusing io::gi;\nusing io::gs;\nusing io::ps;\nusing io::print;\n\nconst int N=305,M=26;\n\nchar s[N];\nint n,k,dp[N][N][N];\nbool vi[N][N][N];\n\ninline void upd(int&x,int y){x>y?:x=y;}\nint dfs(int a,int l,int r){\n\tif(a<0)return -N;\n\tif(l>=r)return l==r;\n\tif(vi[a][l][r])return dp[a][l][r];\n\tvi[a][l][r]=true;\n\tint&ret=dp[a][l][r];\n\tupd(ret,dfs(a-(s[l]!=s[r]),l+1,r-1)+(l<r)+1);\n\tupd(ret,dfs(a,l+1,r));upd(ret,dfs(a,l,r-1));\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tscanf(\"%d\",&k);\n\tprintf(\"%d\\n\",dfs(k,1,n));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\nusing std::abs;\nusing std::min;\nusing std::max;\nusing std::swap;\n\nusing std::map;\nusing std::pair;\nusing std::set;\nusing std::string;\nusing std::vector;\n\nusing std::sort;\nusing std::reverse;\n\nusing ll = long long;\n\n#define forn(i, n) for (ll i = 0; i < (ll) n; ++i)\n#define sz(a) static_cast<int>(a.size())\n#define endl '\\n'\n\nstruct __init {\n    __init() {\n        cin.tie(nullptr);\n        std::iostream::sync_with_stdio(false);\n        cout << std::fixed << std::setprecision(10);\n        cerr << std::fixed << std::setprecision(5);\n        std::mt19937 rand(300);\n    }\n\n    ~__init() {\n        #ifdef SEREZHKA\n            cerr << \"Time elapsed: \" << static_cast<double>(clock()) / CLOCKS_PER_SEC << endl;\n        #endif\n    }\n} init;\n\nconst ll inf = (ll) 1e9 + 7ll;\nconst int maxn = (int) 3e2 + 17;\n\nint n, k;\nstring s;\nint dp[maxn][maxn][maxn];\n\nbool read() {\n    if (!(cin >> s))\n        return false;\n\n    cin >> k;\n    return true;\n}\n\nvoid solve() {\n    n = sz(s);\n\n    forn (i, n)\n        forn (j, n)\n            forn (kk, n)\n                dp[i][j][k] = -inf;\n\n    forn (i, n) {\n        dp[i][i][0] = 1;\n        dp[i][i][1] = 1;\n        \n        if (i < n - 1) {\n            if (s[i] == s[i + 1]) {\n                dp[i][i + 1][0] = 2;\n                dp[i][i + 1][1] = 2;\n                dp[i][i + 1][2] = 2;\n            }\n            else {\n                dp[i][i + 1][0] = 1;\n                dp[i][i + 1][1] = 2;\n                dp[i][i + 1][2] = 2;\n            }\n        }\n    }\n\n    for (int len = 3; len <= n; ++len) {\n        for (int l = 0; l + len <= n; ++l) {\n            int r = l + len - 1;\n\n            for (int kk = 0; kk <= min(k, len); ++kk) {\n                dp[l][r][kk] = max(dp[l][r - 1][kk], dp[l + 1][r][kk]);\n\n                if (s[l] == s[r]) {\n                    dp[l][r][kk] = max(dp[l][r][kk], dp[l + 1][r - 1][kk] + 2);\n\n                    for (int p = 1; p <= 2 && kk - p >= 0; ++p)\n                        dp[l][r][kk] = max(dp[l][r][kk], dp[l + 1][r - 1][kk - p] + 2);\n                } else {\n                    if (kk >= 1)\n                        dp[l][r][kk] = max(dp[l][r][kk], dp[l + 1][r - 1][kk - 1] + 2);\n\n                    if (kk >= 2)\n                        dp[l][r][kk] = max(dp[l][r][kk], dp[l + 1][r - 1][kk - 2] + 2);\n\n                    dp[l][r][kk] = max(dp[l][r][kk], dp[l + 1][r - 1][kk]);\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n\n    for (int kk = 0; kk <= k; ++kk)\n        ans = max(ans, dp[0][n - 1][kk]);\n\n    cout << ans << endl;\n}\n\nint main() {\n#if SEREZHKA\n    freopen(\"file.in\", \"r\", stdin);\n#endif\n\n    while (read())\n        solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n)  for(int i = (k);i < (n);++i)\n#define REP(i,n)    FOR(i,0,n)\n#define ALL(x)      begin(x),end(x)\n\nusing namespace std;\nusing vecint = vector<int>;\nusing ll = int64_t;\n\nint main()\n{\n  string s;\n  cin>>s;\n  string r = s;\n  reverse(ALL(r));\n  int n = s.size();\n  int K;\n  cin>>K;\n  vector<vector<vecint>> dp(n+1, vector<vecint>(n+1, vecint(K+1, 0)));\n  REP(i,n)REP(j,n)REP(k,K+1) {\n    //cerr << i << ' ' << j << ' ' << k << ' ' << dp[i][j][k] << endl;\n    if (s[i] == r[j]) {\n      dp[i+1][j+1][k] = max(dp[i+1][j+1][k], 1 + dp[i][j][k]);\n    }\n    if (k<K) {\n      dp[i+1][j+1][k+1] = max(dp[i+1][j+1][k+1], 1 + dp[i][j][k]);\n    }\n    dp[i+1][j][k] = max(dp[i+1][j][k], dp[i][j][k]);\n    dp[i][j+1][k] = max(dp[i][j+1][k], dp[i][j][k]);\n    dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k]);\n  }\n  int mx = 0;\n  REP(i,n/2) {\n    mx = max(mx, dp[i][n-i][K]*2+(n%2));\n  }\n  cout << mx << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...)\n#endif\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    string s;\n    int k;\n    cin >> s >> k;\n    int n = s.size();\n    int dp[n][n][k] = {};\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i; j <= n - 1; j++) {\n            for (int l = 0; l <= k; l++) {\n                if (i == j) {\n                    dp[i][j][l] = 1;\n                } else if (i + 1 == j) {\n                    dp[i][j][l] = 2;\n                    if (l == 0 && s[i] != s[j]) {\n                        dp[i][j][l] = 1;\n                    }\n                } else {\n                    dp[i][j][l] = max(dp[i + 1][j][l], dp[i][j - 1][l]);\n                    if (s[i] == s[j]) {\n                        dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l] + 2);\n                    } else if (l != 0) {\n                        dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l - 1] + 2);\n                    }\n                }\n            }\n        }\n    }\n    cout << dp[0][n - 1][k] << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n//\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//\nconstexpr ll MOD=1e9+7;\n//constexpr ll MOD=998244353;\n//constexpr ll MOD=10000000;\n//constexpr ll MOD=1e5;\nconstexpr ll MAX=3e6;\nconstexpr ll INF=(1ll<<60);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate<typename T>\nstruct Segment_tree{\n    ll N;\n    T mem;\n    vector<T> node;\n    Segment_tree(vector<T> &X,T m):mem(m){\n        ll sz=X.size();\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mem);\n        rep(i,0,sz) node[N-1+i]=X[i];\n        per(i,N-2,0){\n            node[i]=Compare(node[i*2+1],node[i*2+2]);\n        }\n    }\n    T Compare(T &A,T &B){\n        return std::max(A,B);\n    }\n    void update(ll X,T val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=Compare(node[X*2+1],node[X*2+2]);\n        }\n    }\n    T Query(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mem;\n        if(a<=l&&r<=b) return node[now];\n        auto vl=Query(a,b,now*2+1,l,(l+r)/2),vr=Query(a,b,now*2+2,(l+r)/2,r);\n        return Compare(vl,vr);\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,int a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nvoid comp(vi &A){\n    std::map<ll,ll> mem;\n    rep(i,0,A.size()) mem[A[i]]=0;\n    ll cnt=0;\n    for(auto &p:mem) p.second=cnt++;\n    rep(i,0,A.size()) A[i]=mem[A[i]];\n}\nll RLCS(string S){\n    string T=S;\n    reverse(ALL(T));\n    ll N=S.size();\n    vii dp(N+1,vi(N+1));\n    REP(i,0,N){\n        REP(j,0,N){\n            if(!i){\n                if(j) dp[i][j]=dp[i][j-1];\n            }\n            else if(!j){\n                dp[i][j]=dp[i-1][j];\n            }\n            else{\n                dp[i][j]=std::max(dp[i][j-1],dp[i-1][j]);\n                if(S[i-1]==T[j-1]) dp[i][j]=std::max(dp[i][j],dp[i-1][j-1]+1);\n            }\n        }\n    }\n    return dp[N][N];\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    string S; cin>>S;\n    ll K,N=S.size(); cin>>K;\n    string T=S; reverse(ALL(T));\n    vector<vii> dp(N/2+1,vii(N/2+1,vi(K+1,INF)));\n    REP(i,0,K) dp[0][0][i]=0;\n    vii mem(26);\n    rep(i,0,N/2) mem[T[i]-'a'].pb(i+1);\n    rep(i,0,N/2){\n        REP(j,0,N/2){\n            REP(k,0,K) dp[i+1][j][k]=dp[i][j][k];\n        }\n        rep(j,0,N/2){\n            REP(k,0,K){\n                if(dp[i][j][k]==INF) continue;\n                ll X=disup(mem[S[i]-'a'],dp[i][j][k]);\n                if(X<mem[S[i]-'a'].size()){\n                    ll Y=mem[S[i]-'a'][X];\n                    dp[i+1][j+1][k]=std::min(dp[i+1][j+1][k],Y);\n                }\n                if(dp[i][j][k]<N/2&&k<K){\n                    dp[i+1][j+1][k+1]=std::min(dp[i+1][j+1][k+1],dp[i][j][k]+1);\n                }\n            }\n        }\n        REP(j,0,N/2){\n            REP(k,1,K) dp[i+1][j][k]=std::min(dp[i+1][j][k],dp[i+1][j][k-1]);\n        }\n    }\n    ll ans=0;\n    per(i,N/2,0){\n        per(j,N/2,0){\n            if(dp[i][j][K]!=INF){\n                ll left=i,right=N-1-dp[i][j][K];\n                if(left<=right){\n                    string P=S.substr(left,right-left+1);\n                    ans=std::max(ans,j*2+RLCS(P));\n                }\n                else{\n                    ans=std::max(ans,j*2);\n                }\n                break;\n            }\n        }\n    }\n    cout<<ans<<endl;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define vec vector\n#define ALL(x) (x).begin(), (x).end()\n\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair< int, int > pii;\ntypedef pair< long long, long long > pll;\n\nconst int inf = 1e9;\nconst ll inf64 = 1e18;\n\nint main() {\n\n#ifdef debug\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n\n    string s;\n    int k;\n\n    cin >> s >> k;\n\n    int n = (int)s.size();\n\n    vec< vec< vec< int > > > dp(n, vec< vec< int > >(n, vec< int >(k + 1, -inf)));\n\n    for(int l = n - 1;l >= 0;l--) {\n        for(int r = l;r < n;r++) {\n            if(l == r) {\n                for(int q = 0;q <= k;q++) {\n                    dp[l][r][q] = 1;\n                }\n                continue;\n            }\n            for(int q = 0;q <= k;q++) {\n                dp[l][r][q] = max(dp[l + 1][r][q], dp[l][r - 1][q]);\n                if(q) dp[l][r][q] = max(dp[l][r][q], dp[l][r][q - 1]);\n                int add = !(s[l] == s[r]);\n                if(q >= add) {\n                    dp[l][r][q] = max(dp[l][r][q], dp[l + 1][r - 1][q - add] + 2);\n                }\n            }\n        }\n    }\n\n    cout << dp[0][n - 1][k] << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define fr first\n#define sc second\n#define ll  long long\n#define mp make_pair\n#define mod 1000000007\n\nusing namespace std;\n\nstring s;\nint dp[330][330][330];\nint aft[330][30];\nint bef[330][30];\nint f(int st,int en,int k){\n    if(st == en){\n        return 1;\n    }\n    int &ret = dp[st][en][k];\n    if(ret != -1)return ret;\n    int r =0;\n    r = max(r,f(st+1,en,k));\n    r = max(r,f(st,en-1,k));\n    if(st +1 != en ){\n        if(k ||(s[st] == s[en]))\n            r = max(r,f(st+1,en-1,k-(s[st] != s[en]))+2);\n    }\n    return ret = r;\n}\n\nint v[100100];\nint main()  {\n    int k;\n    ios::sync_with_stdio(0);\n    cin>>s>>k;\n    int n = s.size();\n    memset(dp,-1,sizeof dp);\n    for(int j=0 ;j <26 ; j++){\n        v[j] = -1;\n    }\n\n    for(int i=0 ;i <n ;i ++){\n        for(int j=0 ;j <26  ; j++){\n            bef[i][j] = v[j];\n        }\n        v[s[i]-'a'] = i;\n    }\n\n    for(int j=0 ;j <26 ; j++){\n        v[j] = n+2;\n    }\n\n    for(int i=n-1 ;i >=0 ;i --){\n        for(int j=0 ;j <26  ; j++){\n            aft[i][j] = v[j];\n        }\n        v[s[i]-'a'] = i;\n    }\n    int mx =f(0,n-1,k);\n    cout<<mx<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nint const N = 300 + 5 ;\nint n , k , dp[N][N][N] ;\nstring s ;\n\nint main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tcin >> s ;\n\tcin >> k ;\n\n\tn = _sz(s) ;\n\n\tfor (int l = n - 1 ; l >= 0 ; l --) {\n\t\tfor (int r = l + 1 ; r <= n ; r ++) {\n\t\t\tfor (int t = 0 ; t <= k ; t ++) {\n\t\t\t\tif (r - l == 1) dp[l][r][t] = 1 ;\n\t\t\t\telse {\n\t\t\t\t\tif (s[l] == s[r - 1]) dp[l][r][t] = dp[l + 1][r - 1][t] + 2 ;\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[l][r][t] = max(dp[l][r][t] , dp[l + 1][r][t]) ;\n\t\t\t\t\t\tdp[l][r][t] = max(dp[l][r][t] , dp[l][r - 1][t]) ;\n\t\t\t\t\t\tif (t) dp[l][r][t] = max(dp[l][r][t] , dp[l + 1][r - 1][t - 1] + 2) ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[0][n][k] << '\\n' ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[301][301][301];\nint main() {\n  string S;\n  int K;\n  cin >> S >> K;\n  for(auto i = 0; i < S.size(); ++i) dp[i][i][0] = dp[i][i+1][0] = 1;\n  for(auto k = 0; k <= K; ++k) for(auto w = 2; w <= S.size(); ++w) for(auto l = 0; l+w <= S.size(); ++l) {\n    auto r = l + w;\n    dp[l][r][k] = max({dp[l][r][k], dp[l+1][r][k], dp[l][r-1][k]});\n    if(0 < k)        dp[l][r][k] = max(dp[l][r][k], 2 + dp[l+1][r-1][k-1]);\n    if(S[l]==S[r-1]) dp[l][r][k] = max(dp[l][r][k], 2 + dp[l+1][r-1][k]);\n  }\n  cout << dp[0][S.size()][K] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#define maxn 315\n#define ll long long int\n#define rep(i, l, r) for (register int i = l; i <= r; i++)\n#define per(i, r, l) for (register int i = r; i >= l; i--)\nusing namespace std;\n\nint n, _k;\nchar s[maxn];\n\nint dp[maxn][maxn][maxn];\nbool vis[maxn][maxn][maxn];\nint DP(int a, int b, int k){\n    if (a == n + 1 || !b) return 0;\n    if (a >= b) return (a == b);\n    if (vis[a][b][k]) return dp[a][b][k];\n    vis[a][b][k] = 1;\n    int& ans = dp[a][b][k];\n    if (s[a] == s[b]) ans = max(ans, DP(a + 1, b - 1, k) + 2);\n    if (k) ans = max(ans, DP(a + 1, b - 1, k - 1) + 2);\n    ans = max(ans, DP(a + 1, b, k));\n    ans = max(ans, DP(a, b - 1, k));\n    return ans;\n}\n\nint main(){\n    scanf(\"%s%d\", s + 1, &_k);\n    n = strlen(s + 1);\n    printf(\"%d\", DP(1, n, _k));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define X first\n#define Y second\n#define ld long double \n//#define int long long \nusing namespace std;\n\nconst int N = 333;\n\nint dp[N][N][N] ; \n\nint32_t main()\n{\n\tios::sync_with_stdio(0), cin.tie(0);\n\tstring s ; \n\tcin >> s ;\n\tint n = s.size() ; \n\tint _k ;\n\tcin >> _k ; \n\tfor(int i = 0 ; i < n ; i ++ ) for(int j = 0 ; j <= _k ; j ++ ) dp[i][i+1][j] = 1 ; \n\tfor(int l = 2 ; l <= n ; l ++ ) for(int i = 0 ; i + l <= n ; i ++ ) for(int k = 0 ; k <= _k ; k ++ ) \n\t{\n\t\tint j = i + l ;\n\t\tdp[i][j][k] = max(dp[i+1][j][k],dp[i][j-1][k]) ; \n\t\tif(s[i]==s[j-1]) dp[i][j][k] = max(2+dp[i+1][j-1][k],dp[i][j][k]) ; \n\t\telse if(k) dp[i][j][k] = max(dp[i][j][k],2+dp[i+1][j-1][k-1]) ; \n\t}\n\tcout << dp[0][n][_k] << endl ; \n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,inline,unroll-loops,fast-math\")\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#define N 320\nusing namespace std;\n\nchar a[N];\nint f[N][N][N];\n\nint main(void)\n{\n    int n, k;\n    int i, j, t, o;\n\n    scanf(\"%s %d\", a + 1, &k);\n    n = strlen(a + 1);\n    if(n == 1)\n    {\n        printf(\"1\\n\");\n\n        return 0;\n    }\n\n    for(i = 1, o = 0; i <= n; i ++)\n        for(j = n; j > i; j --)\n            for(t = 0; t <= k; t ++)\n            {\n                f[i][j][t] = max(f[i - 1][j][t], f[i][j + 1][t]);\n                if(a[i] == a[j])\n                    f[i][j][t] = max(f[i][j][t], f[i - 1][j + 1][t] + 1);\n                else if(t)\n                    f[i][j][t] = max(f[i][j][t], f[i - 1][j + 1][t - 1] + 1);\n\n                // printf(\"left %d, right %d, change %d : %d\\n\", i, j, t, f[i][j][t]);\n                o = max(o, f[i][j][t] * 2 + (i < j - 1));\n            }\n    printf(\"%d\\n\", o);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <assert.h>\n#include <memory.h>\n#include <queue>\nusing namespace std;\n\n#define N 301\n\nint dp[N][N][N];\n\nchar s[N];\nvoid solve() {\n  scanf(\" %s\",s+1);\n  int n = strlen(s+1);\n  int k;scanf(\"%d\",&k);\n  for(int cc = k;cc>=0;--cc) {\n    for(int i=1;i<=n;++i) {\n      for(int j=n;j>=i+1;--j) {\n        dp[cc][i+1][j] = max(dp[cc][i+1][j], dp[cc][i][j]);\n        dp[cc][i][j-1] = max(dp[cc][i][j-1],dp[cc][i][j]);\n        if(s[i]==s[j]) {\n          dp[cc][i+1][j-1] = max(dp[cc][i+1][j-1], dp[cc][i][j]+1);\n        } else if(cc>0){\n          dp[cc-1][i+1][j-1] = max(dp[cc-1][i+1][j-1], dp[cc][i][j]+1);\n        }\n      }\n    }\n  }\n  int ret = 0;\n  for(int i=1;i<=n;++i) {\n    for(int cc=0;cc<=k;++cc) {\n      ret = max(ret, dp[cc][i][i-1]*2);\n      ret = max(ret, dp[cc][i+1][i]*2);\n      ret = max(ret,1 + dp[cc][i][i]*2);\n    }\n  }\n  printf(\"%d\\n\", ret);\n}\n\nint main() {\n  //freopen(\"input.txt\",\"r\",stdin);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", clock()*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, clock()*1.0/CLOCKS_PER_SEC)\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int MAXN = 305;\n\nint dp[MAXN][MAXN][MAXN];\nchar s[MAXN];\nint k;\n\nint solve(int l, int r, int k) {\n  if (l == r) { return 0;}\n  if (l == r - 1) { return 1;};\n  int &ans = dp[l][r][k];\n  if (ans != -1) return ans;\n  ans = max(ans, solve(l + 1, r, k));\n  ans = max(ans, solve(l, r - 1, k));\n  if (k) {\n    ans = max(ans, solve(l + 1, r - 1, k - 1) + 2);\n  }\n  if (s[l] == s[r - 1]) {\n    ans = max(ans, solve(l + 1, r - 1, k) + 2);\n  }\n//  eprintf(\"dp[%d][%d][%d] = %d\\n\", l, r, k, ans);\n  return ans;\n}\n\nint main() {\n#ifdef LOCAL\n  freopen(\"d.in\", \"r\", stdin);\n  freopen(\"d.out\", \"w\", stdout);\n#endif\n\n  while (scanf(\"%s%d\", s, &k) == 2) {\n    memset(dp, -1, sizeof(dp));\n    printf(\"%d\\n\", solve(0, strlen(s), k));\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nconst int N = 333;\nint dp[N][N][N];\n\nvoid relax(int& x, int y) {\n\tif (x == -1) {\n\t\tx = y;\n\t} else {\n\t\tx = max(x, y);\n\t}\n}\n\nint main() {\n\tstring s;\n\tcin >> s;\n\tint k = nxt();\n\tint n = s.length();\n\n\tmemset(dp, -1, sizeof(dp));\n\tdp[0][0][0] = 0;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tfor (int j = 0; i + j <= n + 1; ++j) {\n\t\t\tfor (int ij = 0; ij <= k; ++ij) {\n\t\t\t\tif (i == 0 && j == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint& what = dp[i][j][ij];\n\t\t\t\tif (i) {\n\t\t\t\t\trelax(what, dp[i - 1][j][ij]);\n\t\t\t\t}\n\t\t\t\tif (j) {\n\t\t\t\t\trelax(what, dp[i][j - 1][ij]);\n\t\t\t\t}\n\t\t\t\tif (!i || !j) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbool diff = (s[i - 1] != s[n - j]);\n\t\t\t\tif (diff) {\n\t\t\t\t\tif (ij) {\n\t\t\t\t\t\trelax(what, dp[i - 1][j - 1][ij - 1] + 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trelax(what, dp[i - 1][j - 1][ij] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = -1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; i + j < n + 1; ++j) {\n\t\t\tfor (int ij = 0; ij <= k; ++ij) {\n\t\t\t\tif (i + j == n) {\n\t\t\t\t\trelax(ans, dp[i][j][ij] * 2);\n\t\t\t\t} else {\n\t\t\t\t\trelax(ans, dp[i][j][ij] * 2 + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef unsigned char uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\nconst ld pi = 3.1415926535897932384626433832795l;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 310;\nint d[N][N][N];\n\nint main () {\n\t//std::ios::sync_with_stdio(false);\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n#ifdef SG\n\tfreopen((problemname + \".in\").c_str(), \"r\", stdin);\n//\tfreopen((problemname + \".out\").c_str(), \"w\", stdout);\n#endif\n\tstring s;\n\tint K;\n\tgetline(cin, s);\n\tcin >> K;\n\tmemset(d, 0, sizeof(d));\n\tint n = sz(s);\n\tint ans = 0;\n\tforn(k, K + 1) {\n    \tforn(i, n + 1) {\n    \t\tforn(j, n + 1) {\n    \t\t\tif (i + j > n) {\n\t\t\t\t\tcontinue;    \t\t\t\t\n    \t\t\t}\n    \t\t\tif (i > 0) {\n    \t\t\t \tumx(d[i][j][k], d[i - 1][j][k]);\n    \t\t\t}\n    \t\t\tif (j > 0) {\n    \t\t\t \tumx(d[i][j][k], d[i][j - 1][k]);\n    \t\t\t}\n    \t\t\tif (s[i] == s[n - 1 - j] && i > 0 && j > 0) {\n    \t\t\t\tumx(d[i][j][k], d[i - 1][j - 1][k] + 1);\n    \t\t\t}\n    \t\t\tif (k > 0 && i > 0 && j > 0) {\n    \t\t\t\tumx(d[i][j][k], d[i - 1][j - 1][k - 1] + 1);\n    \t\t\t}\n    \t\t\tumx(ans, 2 * d[i][j][k] + (i + j < n));\n    \t\t}\n    \t}\n\t}\n\tif (sz(s) == 1) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tcout << ans << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = (int) 1e9;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  string s;\n  int t;\n  cin >> s >> t;\n  int n = (int) s.size();\n  vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(n + 1, vector<int>(t + 2, 0)));\n  for (int len = 1; len <= n; len++) {\n    for (int i = 0; i + len <= n; i++) {\n      for (int k = 0; k <= t; k++) {\n        int j = i + len - 1;\n        dp[i][j][k] = max(dp[i][j][k], max(dp[i + 1][j][k], j - 1 < 0 ? 0 : dp[i][j - 1][k]));\n        if (s[i] == s[j]) {\n          dp[i][j][k] = max(dp[i][j][k], 1 + (i < j) + (j - 1 < 0 ? 0 : dp[i + 1][j - 1][k]));\n          dp[i][j][k + 1] = max(dp[i][j][k + 1], dp[i][j][k]);\n        } else {\n          dp[i][j][k + 1] = max(dp[i][j][k + 1], 2 + (j - 1 < 0 ? 0 : dp[i + 1][j - 1][k]));\n        }\n      }\n    }\n  }\n  cout << dp[0][n - 1][t] << '\\n'; \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \n#define ll long long\n#define all(aaa) aaa.begin(), aaa.end()\n\nconst int N = 305;\nint dp[N][N][N];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    string s;\n    int k;\n    cin >> s >> k;\n\n    int n = s.size();\n\n    for (int i = 0; i + 1 < n; i++) {\n        if (s[i] == s[i + 1]) {\n            dp[i][i + 1][0] = 2;\n        }\n        else {\n            dp[i][i + 1][1] = 2;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        dp[i][i][0] = 1;\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int l = 0, r = i; r < n; l++, r++) {\n            for (int h = 0; h <= k; h++) {\n                if (l > 0)\n                    dp[l - 1][r][h] = max(dp[l - 1][r][h], dp[l][r][h]);\n                if (r + 1 < n)\n                    dp[l][r + 1][h] = max(dp[l][r + 1][h], dp[l][r][h]);\n                if (l > 0 && r + 1 < n) {\n                    if (s[l - 1] == s[r + 1]) {\n                        dp[l - 1][r + 1][h] = max(dp[l - 1][r + 1][h], dp[l][r][h] + 2);\n                    }\n                    if (h < k) {\n                        dp[l - 1][r + 1][h + 1] = max(dp[l - 1][r + 1][h + 1], dp[l][r][h] + 2);\n                    }\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            for (int h = 0; h <= k; h++) {\n                ans = max(ans, dp[i][j][h]);\n            }\n        }\n    }\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nstatic const int INF = 1000000000;\nstatic int dp[301][301][301];\n\nint solve(int k, string a, string b){\n\tif(a.size() > b.size()){ swap(a, b); }\n\tconst int n = a.size(), m = b.size();\n\tk = min(k, n);\n\tfor(int i = 0; i <= k; ++i){\n\t\tfor(int x = 0; x <= n; ++x){\n\t\t\tfor(int y = 0; y <= m; ++y){ dp[i][x][y] = -INF; }\n\t\t}\n\t}\n\tdp[0][0][0] = 0;\n\tfor(int i = 0; i <= k; ++i){\n\t\tfor(int x = 0; x <= n; ++x){\n\t\t\tfor(int y = 0; y <= m; ++y){\n\t\t\t\tconst int cur = dp[i][x][y];\n\t\t\t\tif(x < n && y < m){\n\t\t\t\t\tif(a[x] == b[y]){ dp[i][x + 1][y + 1] = max(dp[i][x + 1][y + 1], cur + 1); }\n\t\t\t\t\tif(i < k){ dp[i + 1][x + 1][y + 1] = max(dp[i + 1][x + 1][y + 1], cur + 1); }\n\t\t\t\t\tdp[i][x + 1][y + 1] = max(dp[i][x + 1][y + 1], cur);\n\t\t\t\t}\n\t\t\t\tif(x < n){ dp[i][x + 1][y] = max(dp[i][x + 1][y], cur); }\n\t\t\t\tif(y < m){ dp[i][x][y + 1] = max(dp[i][x][y + 1], cur); }\n\t\t\t}\n\t\t}\n\t}\n\tint answer = 0;\n\tfor(int i = 0; i <= k; ++i){\n\t\tanswer = max(answer, dp[i][n][m]);\n\t}\n\treturn answer;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint k;\n\tstring s;\n\tcin >> s >> k;\n\tconst int n = s.size();\n\tint answer = 0;\n\tfor(int i = 1; i + 1 < n; ++i){\n\t\tstring a = s.substr(0, i), b = s.substr(i);\n\t\treverse(b.begin(), b.end());\n\t\tanswer = max(answer, 2 * solve(k, a, b));\n\t}\n\tfor(int i = 0; i < n; ++i){\n\t\tstring a = s.substr(0, i), b = s.substr(i + 1);\n\t\treverse(b.begin(), b.end());\n\t\tanswer = max(answer, 1 + 2 * solve(k, a, b));\n\t}\n\tcout << answer << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <stack>\n#include <vector>\n#define maxn 310\n#define maxe 100010\ntypedef long long ll;\nusing namespace std;\nconst double eps=1e-5;\nconst int inf=0x3f3f3f3f3f;\nchar a[maxn];\nint mc;\nint dp[maxn][maxn][maxn];\nint main()\n{\n    while(scanf(\"%s%d\",a,&mc)==2)\n    {\n        int n=strlen(a);\n        for(int i=0;i<n;i++)dp[i][i][0]=1;\n        for(int l=1;l<n;l++)\n        {\n            for(int i=0;i+l<n;i++)\n            {\n                int j=i+l;\n                for(int k=0;k<=mc;k++)\n                {\n                    if(k)dp[i][j][k]=dp[i][j][k-1];\n                    int t=max(dp[i+1][j][k],dp[i][j-1][k]);\n                    dp[i][j][k]=max(t,dp[i][j][k]);\n                    if(k)dp[i][j][k]=max(dp[i+1][j-1][k-1]+2,dp[i][j][k]);\n                    if(a[i]==a[j])\n                        dp[i][j][k]=max(dp[i+1][j-1][k]+2,dp[i][j][k]);\n                }\n            }\n        }\n        printf(\"%d\\n\",dp[0][n-1][mc]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar str[303]; int dp[303][303][303] , N , K;\n\nint solve(int x , int y , int z){\n\tif(x > y) return 0;\n\tif(x == y) return 1;\n\tif(dp[x][y][z]) return dp[x][y][z];\n\tif(str[x] == str[y]) return dp[x][y][z] = solve(x + 1 , y - 1 , z) + 2;\n\treturn dp[x][y][z] = max(solve(x + 1 , y , z) , max(solve(x , y - 1 , z) , z == 0 ? 0 : 2 + solve(x + 1 , y - 1 , z - 1)));\n}\n\nint main(){\n\tscanf(\"%s %d\" , str + 1 , &K); N = strlen(str + 1);\n\tcout << solve(1 , N , K) << endl; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\nusing namespace std;\n\nstring s;\nshort dp[302][302][302];\nint go(int l, int r, int k){\n\tif(l == r)\n\t\treturn 1;\n\tif(l > r)\n\t\treturn 0;\n\tif(dp[l][r][k] != -1)\n\t\treturn dp[l][r][k];\n\tint ret = max(go(l + 1, r, k), go(l, r - 1, k));\n\tif(s[l] == s[r])\n\t\tret = max(ret, go(l + 1, r - 1, k) + 2);\n\telse if(k)\n\t\tret = max(ret, go(l + 1, r - 1, k - 1) + 2);\n\treturn dp[l][r][k] = ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\t//\tsrand(time(NULL));\n\tint k; cin >> s >> k;\n\tmemset(dp, -1, sizeof dp);\n\tcout << go(0, s.size() - 1, k) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nint dp[400][400][400];\nsigned main(){\n\tstring s;int K;cin>>s>>K;\n\trep(i,s.size()){\n\t\tfor(int j=s.size()-1;j>i;j--){\n\t\t\trep(k,K+1){\n\t\t\t\tif(s[i]==s[j]){\n\t\t\t\t\tdp[i+1][j-1][k]=max(dp[i+1][j-1][k],dp[i][j][k]+1);\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tdp[i+1][j-1][k]=max(dp[i+1][j-1][k],dp[i][j][k]);\n\t\t\t\t\tdp[i+1][j][k]=max(dp[i+1][j][k],dp[i][j][k]);\n\t\t\t\t\tdp[i][j-1][k]=max(dp[i][j-1][k],dp[i][j][k]);\n\t\t\t\t\tif(k<K){\n\t\t\t\t\t\tdp[i+1][j-1][k+1]=max(dp[i+1][j-1][k+1],dp[i][j][k]+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint Max=0;\n\trep(i,s.size())rep(k,s.size())rep(j,K+1){\n\t\tMax=max(Max,dp[i][k][j]);\n\t}\n\tif(s.size()%2==1)cout<<Max*2+1<<endl;\n\telse cout<<Max*2<<endl;\n\t//cout<<Max*2+2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\ndp[i][j][k] 第i个字符到第j个字符最多修改k个字符的最大长度\n\ndp[i][j][k] = max(\n                  dp[i+1][j][k],dp[i][j-1][k],\n                  if s[i]==s[j] : dp[i+1][j-1][k]+2\n                else :\n\nabcabcabc\ncbacbacba\n\n\n*/\n\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\nint n,m;\nchar s[305];\nint dp[305][305][305];\n\nint main(){\n    int i,j,k;\n    while(~scanf(\"%s%d\",s,&m)){\n        n = strlen(s);\n        memset(dp,0,sizeof(dp));\n        for(i = 0;i < n;i++){\n            for(j = 0;j <= m;j++)\n                dp[i][i][j] = 1;\n        }\n        for(i = n-1;i >= 0;i--){\n            for(j = i+1;j < n;j++){\n                for(k = 0;k <= m;k++){\n                    dp[i][j][k] = max(dp[i+1][j][k],dp[i][j-1][k]);\n                    //if(i+1 <= j-1){\n                        if(s[i] == s[j]){\n                            dp[i][j][k] = max(dp[i][j][k],dp[i+1][j-1][k]+2);\n                        }else if(k > 0){\n                            dp[i][j][k] = max(dp[i][j][k],dp[i+1][j-1][k-1]+2);\n                        }\n                    //}\n                }\n            }\n        }\n        printf(\"%d\\n\",dp[0][n-1][m]);\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <ctime>\n#include <complex>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int,int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL) INF;\n\nconst int MOD = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-7;\n\n\nconst int MAX = 303;\n\nint DP[MAX][MAX][MAX];\nchar S[MAX];\nint K;\n\nint get(int l, int r, int k)\n{\n    if (l == r)return 1;\n    if (r < l)return 0;\n    int& res = DP[l][r][k];\n    if (res != -1)return res;\n    res = max(res, get(l+1, r, k));\n    res = max(res, get(l, r - 1, k));\n    if (S[l] == S[r])res = max(res, get(l + 1, r - 1, k) + 2);\n    if (k < K)res = max(res, get(l+1, r-1, k+1) + 2);\n    return res;\n}\n\n\nint main()\n{\n\n    scanf(\"%s\", S);\n    scanf(\"%d\", &K);\n    int n = strlen(S);\n    FILL(DP, -1);\n    cout << get(0, n-1, 0) << endl;\n    \n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define p_ary(ary,a,b) do { cout << \"[\"; for (int count = (a);count < (b);++count) cout << ary[count] << ((b)-1 == count ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\nint main() {\n    string s;\n    int k;\n    cin >> s >> k;\n    int n = s.size();\n    vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(n+1,vector<int>(k+1,0)));\n    for (int i = 0;i < n;++i) for (int j = 0;j < k+1;++j) dp[i][i+1][j] = 1;\n    for (int i = 2;i <= n;++i) {\n        for (int j = 0;j < n+1-i;++j) {\n            if (s[j] == s[j+i-1]) for (int l = 0;l < k+1;++l) dp[j][j+i][l] = max({dp[j+1][j+i-1][l]+2,dp[j][j+i-1][l],dp[j+1][j+i][l]});\n            else for (int l = 0;l < k+1;++l) dp[j][j+i][l] = max(dp[j][j+i-1][l],dp[j+1][j+i][l]);\n        }\n        for (int j = 0;j < n+1-i;++j) {\n            for (int l = 0;l < k;++l) dp[j][j+i][l+1] = max({dp[j][j+i][l+1],dp[j+1][j+i-1][l]+2});\n        }\n    }\n    cout << dp[0][n][k] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int ms = 311;\n\nint memo[ms][ms][ms][2];\n\nstring s;\n\nint dp(int k, int l, int r, int b) {\n  if (l == s.size() or r < 0) return 0;\n  if (r - l + 1 == b) return 0;\n  if (r - l + 1 < b) return -10000;\n  int &ans = memo[k][l][r][b];\n  if (ans != -1) return ans;\n  ans = max(dp(k, l + 1, r, b), dp(k, l, r - 1, b));\n  ans = max(ans, 0);\n  if (s[l] == s[r]) ans = max(ans, 1 + dp(k, l + 1, r - 1, b));\n  if (k and l < r) ans = max(ans, 1 + dp(k - 1, l + 1, r - 1, b));\n  // cout << k << ' ' << l << ' ' << r << ' ' << b << ' ' << ans << endl;\n  return ans;\n}\n\nint main() {\n  cin >> s;\n  int k;\n  cin >> k;\n  int ans = 0;\n  if (k >= s.size() / 2) ans = s.size();\n  memset(memo, -1, sizeof memo);\n  ans = max(ans, 2 * dp(k, 0, s.size() - 1, 0));\n  ans = max(ans, 2 * dp(k, 0, s.size() - 1, 1) + 1);\n  cout << min(ans, (int)s.size()) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 303;\nint dp[maxn][maxn][maxn];\nchar s[maxn];\nint main()\n{\n    int a;\n    scanf(\"%s%d\",s+1,&a);\n    int len = strlen(s+1);\n    for(int i=1; i<=len; ++i)\n        for(int j=0; j<=a; ++j) dp[i][i][j] = 1;\n    for(int j=1; j<=len; ++j)\n    {\n        for(int i=j-1; i>=1; --i)\n        {\n            for(int k=0; k<=a; ++k)\n            {\n                dp[i][j][k] = max(dp[i+1][j][k], dp[i][j-1][k]);//not change borders\n                if(s[i]==s[j]) dp[i][j][k] = max(dp[i][j][k], dp[i+1][j-1][k]+2);//not change borders\n                if(k) dp[i][j][k] = max(dp[i][j][k], max(dp[i][j][k], dp[i+1][j-1][k-1]+2));//change one border\n            }\n        }\n    }\n    printf(\"%d\\n\",dp[1][len][a]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint dp[300][301][301];\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  string s; cin >> s;\n  int n = s.size();\n  int k; cin >> k;\n  for (int r = 1; r <= n; ++r) {\n    for (int l = 0; l < r; ++l) {\n      for (int x = 0; x <= k; ++x) {\n        if (r - l == 1) {\n          dp[l][r][x] = 1;\n        } else {\n          dp[l][r][x] = max(dp[l][r - 1][x], dp[l + 1][r][x]);\n          if (s[l] == s[r - 1]) {\n            dp[l][r][x] = max(dp[l][r][x], dp[l + 1][r - 1][x] + 2);\n          } else if (x) {\n            dp[l][r][x] = max(dp[l][r][x], dp[l + 1][r - 1][x - 1] + 2);\n          }\n        }\n      }\n    }\n  }\n  cout << dp[0][n][k] << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "//In the name of Allah\n//In the name of the compassionate of the merciful\n//Ya Ali!\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntemplate<typename Type>\nusing ordered_multiset = tree<Type, null_type, less_equal<Type>, rb_tree_tag, tree_order_statistics_node_update> ;\n\ntypedef long long ll ;\ntypedef long double ld ;\n\n#define f first\n#define s second\n#define pb push_back\n#define pf push_front\n#define popb pop_back\n#define popf pop_front\n#define all(x) x.begin() , x.end()\n#define mp make_pair\n#define pll pair<ll,ll>\n#define pii pair<int,int>\n\n//ifstream fin(\"input.txt\");\n//ofstream fout(\"output.txt\");\n// fflush(stdout);\n\nconst ll maxn = 310 ;\nconst ll INF = 1e18 ;\n\nll mod = 1e9 + 7 , p1 = 999999929 , p2 = 999999937 ;\n\nll n , k , dp[maxn][maxn][maxn] ;\nstring s1 ;\n\nint main()\n{\nstd::ios::sync_with_stdio(0) ;\ncin.tie(0) ;\ncout.tie(0) ;\n\ncin >> s1 >> k ;\nn = s1.size() ;\n\nfor(int i = 0 ; i < n ; i ++)\n  for(int j = 0 ; j <= k ; j ++)\n    dp[i][i][j] = 1 ;\n\nfor(int r = 1 ; r < n ; r ++){\n for(int l = r-1 ; l >= 0 ; l --){\n  for(int co = 0 ; co <= k ; co ++){\n    dp[l][r][co] = max(dp[l][r][co] , dp[l+1][r][co]) ;\n    dp[l][r][co] = max(dp[l][r][co] , dp[l][r-1][co]) ;\n   if(r-l>1){\n    if(s1[l] == s1[r])dp[l][r][co] = max(dp[l][r][co] , dp[l+1][r-1][co]+2) ;\n    if(co > 0)dp[l][r][co] = max(dp[l][r][co] , dp[l+1][r-1][co-1]+2) ;\n   }\n   else{\n    if(s1[l] == s1[r])dp[l][r][co] = 2 ;\n    if(co>0)dp[l][r][co] = 2;\n   }\n  }\n }\n}\ncout << dp[0][n-1][k] ;\n return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nint m;\nusing namespace std;\nconst int N = 302;\nstring s;\nint f[N][N][N];\nint a[N];\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> s;\n    cin >> m;\n    for (int i = 0; i < s.size(); i++) a[i + 1] = s[i] - 'a';\n    int n = s.size(); a[0] = -1; a[n + 1] = -1;\n    f[1][n][0] = 0;\n    for (int i = 1; i <= n; i++) {\n        for (int j = n; j >= i; j--) {\n            for (int k = 0; k <= m; k++) {\n                f[i + 1][j][k] = max(f[i + 1][j][k], f[i][j][k]);\n                f[i][j - 1][k] = max(f[i][j - 1][k], f[i][j][k]);\n                if (a[i] != a[j]) {\n                    f[i + 1][j - 1][k + 1] = max(f[i + 1][j - 1][k + 1], f[i][j][k] + 1);\n                }\n                else {\n                    f[i + 1][j - 1][k] = max(f[i + 1][j - 1][k], f[i][j][k] + 1);\n                }\n            }\n        }\n    }\n    int mx = 0;\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            for (int k = 0; k <= m; k++) {\n                if (i <= j) mx = max(mx, f[i][j][k] * 2);\n                else\n                if (abs(i - j) == 2) mx = max(mx, (f[i][j][k] - 1) * 2 + 1);\n                else\n                if (abs(i - j) == 1) mx = max(mx, f[i][j][k] * 2);\n            }\n        }\n    }\n    cout << mx << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n// #define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\nint dp[302][302][302];\n// dp[l][r][x] = s[l,r]であとx文字変更できる時のs[l,r]とrev(s[l,r])のLCSの最大値\n\nsigned main() {\n\tINIT;\n\n\tVAR(std::string, s);\n\tVAR(int, k);\n\n\tint n = s.size();\n\tFILL(dp, -1);\n\tREP(i, n) REP(j, k+1) dp[i][i][j] = 1;\n\tREP(i, n - 1) {\n\t\tif (s[i] == s[i + 1]) {\n\t\t\tdp[i][i + 1][0] = 2;\n\t\t}\n\t\telse {\n\t\t\tdp[i][i + 1][0] = 1;\n\t\t\tdp[i][i + 1][1] = 2;\n\t\t}\n\t}\n\n\tstd::function<int(int, int, int)> rec = [&](int l, int r, int x) {\n\t\tif (l > r) return 0;\n\t\tint& res = dp[l][r][x];\n\t\tif (res != -1) return res;\n\n\t\tres = std::max(rec(l + 1, r, x), rec(l, r - 1, x));\n\t\tif (x - 1 >= 0) CHMAX(res, rec(l, r, x - 1));\n\t\tif (s[l] == s[r]) CHMAX(res, rec(l + 1, r - 1, x) + 2);\n\t\telse {\n\t\t\tCHMAX(res, rec(l + 1, r - 1, x));\n\t\t\tif (x - 1 >= 0) CHMAX(res, rec(l + 1, r - 1, x - 1) + 2);\n\t\t}\n\t\treturn res;\n\t};\n\tOUT(rec(0, n - 1, k))BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1e9+7,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\n#define MAX 301\nint dp[MAX][MAX];\nint arr[MAX][MAX];\nvoid init(int N,int M){\n  for(int i = 0 ; i <= N ; i++){\n    for(int j = 0 ; j <= M ; j++){\n      dp[i][j] = 0;arr[i][j] = MAX;\n    }\n  }\n}\nint getStr(string &s,string &t,int l,int r){\n  init(l,r);\n  for(int i = 0 ; i < l ; i++){\n    for(int j = 0 ; j < r ; j++){\n      if(s[i] == t[j]){\n        dp[i+1][j+1] = dp[i][j]+1;\n        arr[i+1][j+1] = 0;\n      }else{\n        if(dp[i][j+1] < dp[i+1][j]){\n          dp[i+1][j+1] = dp[i+1][j];\n          arr[i+1][j+1] = -1;\n        }else{\n          dp[i+1][j+1] = dp[i][j+1];\n          arr[i+1][j+1] = 1;\n        }\n      }\n    }\n  }\n  string res=\"\";\n  int x=MAX,y=MAX,c=0;\n  for(int i = l, j = r ; i > 0 && j > 0 ; ){\n    if(!arr[i][j]){\n      //res += s[i-1];\n      c++;\n      i--; j--;\n      x=min(x,i);\n      y=min(y,j);\n    } else if(arr[i][j] == 1) i--;\n    else j--;\n  }\n  //reverse(res.begin(),res.end());\n  return c*2+(x||y);\n}\n\nvoid Main() {\n  string s;\n  int m;\n  cin >> s >> m;\n  ll ans=0;\n  rep(i,s.size()) {\n    string t=s.substr(0,i);\n    string r=s.substr(i);\n    reverse(all(t));\n    ans=max(ans,(ll)getStr(t,r,t.size(),r.size()));\n  }\n  pr(min((ll)s.size(),ans+m*2));\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "//\n#include <cstdio>\n#include <iostream>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n//#ifdef atom #else #endif\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\n#define X first\n#define Y second\n#define vi vector<int>\n#define vvi vector< vi >\n#define vii vector< ii >\n#define mp make_pair\n#define pb push_back\nstring s;\nint k;\nconst int maxn = 305;\nconst int maxk = 305;\nint dp[maxn][maxn][maxk];\nint n;\nint solve(int i, int j, int k)\n{\n    if(i == n || j< 0) return 0;\n    if(dp[i][j][k] != -1) return dp[i][j][k];\n    int res = 0;\n    res = max(res, solve(i+1, j, k));\n    res = max(res, solve(i, j-1, k));\n    if(s[i] == s[j]) res = max(res, 1+solve(i+1, j-1, k));\n    else if(k && i != j) res = max(res, solve(i+1, j-1, k-1)+2);\n    return dp[i][j][k] = res;\n}\nint main()\n{\n    //#ifndef atom freopen(\".in\", \"r\", stdin); freopen(\".out\", \"w\", stdout); #endif\n    cin >> s >> k;\n    n = s.size();\n    memset(dp, -1, sizeof dp);\n    cout << solve(0, n-1, k) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nint main() {\n        string s;\n        cin >> s;\n        int k;\n        scanf(\"%d\", &k);\n        int n = s.size();\n        vector<vector<vector<int>>> dp(n, vector<vector<int>> (n, vector<int> (n, -1)));\n        function<int (int, int, int)> calc = [&](int l, int r, int t) {\n                if (dp[l][r][t] != -1) return dp[l][r][t];\n                if (l > r) return 0;\n                if (l == r) return 1;\n                int ma = 0;\n                if (s[l] == s[r]) ma = max(ma, calc(l + 1, r - 1, t) + 2);\n                ma = max(ma, calc(l + 1, r, t));\n                ma = max(ma, calc(l, r - 1, t));\n                if (t > 0) ma = max(ma, calc(l + 1, r - 1, t - 1) + 2);\n                return dp[l][r][t] = ma;\n        };\n        printf(\"%d\\n\", calc(0, n - 1, k));\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n//\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//\nconstexpr ll MOD=1e9+7;\n//constexpr ll MOD=998244353;\n//constexpr ll MOD=10000000;\n//constexpr ll MOD=1e5;\nconstexpr ll MAX=3e6;\nconstexpr ll INF=(1ll<<60);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate<typename T>\nstruct Segment_tree{\n    ll N;\n    T mem;\n    vector<T> node;\n    Segment_tree(vector<T> &X,T m):mem(m){\n        ll sz=X.size();\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mem);\n        rep(i,0,sz) node[N-1+i]=X[i];\n        per(i,N-2,0){\n            node[i]=Compare(node[i*2+1],node[i*2+2]);\n        }\n    }\n    T Compare(T &A,T &B){\n        return std::max(A,B);\n    }\n    void update(ll X,T val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=Compare(node[X*2+1],node[X*2+2]);\n        }\n    }\n    T Query(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mem;\n        if(a<=l&&r<=b) return node[now];\n        auto vl=Query(a,b,now*2+1,l,(l+r)/2),vr=Query(a,b,now*2+2,(l+r)/2,r);\n        return Compare(vl,vr);\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,int a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nvoid comp(vi &A){\n    std::map<ll,ll> mem;\n    rep(i,0,A.size()) mem[A[i]]=0;\n    ll cnt=0;\n    for(auto &p:mem) p.second=cnt++;\n    rep(i,0,A.size()) A[i]=mem[A[i]];\n}\nll RLCS(string S){\n    string T=S;\n    reverse(ALL(T));\n    ll N=S.size();\n    vii dp(N+1,vi(N+1));\n    REP(i,0,N){\n        REP(j,0,N){\n            if(!i){\n                if(j) dp[i][j]=dp[i][j-1];\n            }\n            else if(!j){\n                dp[i][j]=dp[i-1][j];\n            }\n            else{\n                dp[i][j]=std::max(dp[i][j-1],dp[i-1][j]);\n                if(S[i-1]==T[j-1]) dp[i][j]=std::max(dp[i][j],dp[i-1][j-1]+1);\n            }\n        }\n    }\n    return dp[N][N];\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    string S; cin>>S;\n    ll K,N=S.size(); cin>>K;\n    string T=S; reverse(ALL(T));\n    vector<vii> dp(N/2+1,vii(N/2+1,vi(K+1,INF)));\n    dp[0][0][0]=0;\n    vii mem(26);\n    rep(i,0,N/2) mem[T[i]-'a'].pb(i+1);\n    rep(i,0,N/2){\n        REP(j,0,N/2){\n            REP(k,0,K) dp[i+1][j][k]=dp[i][j][k];\n        }\n        rep(j,0,N/2){\n            REP(k,0,K){\n                if(dp[i][j][k]==INF) continue;\n                ll X=disup(mem[S[i]-'a'],dp[i][j][k]);\n                if(X<mem[S[i]-'a'].size()){\n                    ll Y=mem[S[i]-'a'][X];\n                    dp[i+1][j+1][k]=std::min(dp[i+1][j+1][k],Y);\n                }\n                if(dp[i][j][k]<N/2&&k<K){\n                    dp[i+1][j+1][k+1]=std::min(dp[i+1][j+1][k+1],dp[i][j][k]+1);\n                }\n            }\n        }\n    }\n    vii m(N,vi(N));\n    rep(i,0,N){\n        rep(j,i,N){\n            string P=S.substr(i,j-i+1);\n            m[i][j]=RLCS(P);\n        }\n    }\n    ll ans=0;\n    REP(i,0,N/2){\n        REP(j,0,N/2){\n            REP(k,0,K){\n                if(dp[i][j][k]!=INF){\n                    ll left=i,right=N-dp[i][j][k]-1;\n                    if(left<=right){\n                        ans=std::max(ans,j*2+m[left][right]);\n                    }\n                }\n            }\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\nusing namespace std;\nconst int N=308;\nint n,m,ans,a[N][N][N];\nchar b[N];\nint maxx(int x,int y){if(x>y)y=x;return y;}\nint main(void)\n{\n\tint i,j,k;\n\tscanf(\"%s%d\",b+1,&m);\n\tn=strlen(b+1);ans=1;\n\tfor(i=1;i<=n;i++)a[0][i][i]=1;\n\tfor(k=0;k<=m;k++)\n\tfor(i=n;i>=1;i--)\n\tfor(j=i+1;j<=n;j++)\n\t{\n\t\ta[k][i][j]=maxx(maxx(a[k][i+1][j],a[k][i][j-1]),(b[i]==b[j])*(2+a[k][i+1][j-1]));\n\t\tif(k){a[k][i][j]=maxx(a[k][i][j],2+a[k-1][i+1][j-1]);}\n\t}\n\tcout<<a[m][1][n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define inf 1000000000000000000\n#define llint long long \n\nusing namespace std;\n\nstring s;\nllint N, K;\nllint dp[305][305][305];\n\nint main(void)\n{\ncin >> s >> K;\nN = s.size();\ns = \" \" + s;\n\nfor(llint i = 0; i <= N; i++){\nfor(llint j = 0; j <= N; j++){\nfor(llint k = 0; k <= K; k++){\ndp[i][j][k] = -inf;\n}\n}\n}\nfor(llint i = 0; i <= N; i++) dp[i][0][0] = dp[0][i][0] = 0;\n\n\nfor(llint i = 1; i <= N; i++){\nfor(llint j = 1; j <= N; j++){\nfor(llint k = 0; k <= K; k++){\n\nif(i+j > N+1){\n\tcontinue;\n}\n\nif(s[i] == s[N-j+1]){\ndp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k] + 1);\n}\nelse{\ndp[i][j][k] = max(dp[i][j][k], max(dp[i-1][j][k], dp[i][j-1][k]));\nif(k > 0) dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k-1] + 1);\n}\n\n\n}\n}\n}\n\n/*for(llint k = 0; k <= K; k++){\nfor(llint i = 0; i <= N; i++){\nfor(llint j = 0; j <= N; j++){\ncout << dp[i][j][k] << \" \";\n}cout << endl;\n}cout << endl;\n}*/\n\nllint ans = 0;\nfor(llint k = 0; k <= K; k++){\nfor(llint i = 0; i <= N; i++){\nfor(llint j = 0; j <= N; j++){\nif(i+j != N+1) continue;\nllint tmp = dp[i][j][k] * 2;\nif(s[i] == s[N-j+1]) tmp--;\nans = max(ans, tmp);\n}\n}\n}\n\ncout << ans << endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pa pair<int,int>\n#define db double\n#define mo 1000000007\nusing namespace std;\nchar s[305];\nint f[305][305][305];\nint K,ans;\nint main(){\n\tscanf(\"%s%d\",s+1,&K);\n\tint n=strlen(s+1);\n\tfor (int i=0;i<=K;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tfor (int k=n;k>j;k--){\n\t\t\t\tif (i!=0) f[i][j][k]=f[i-1][j-1][k+1]+1;\n\t\t\t\tf[i][j][k]=max(f[i][j][k],max(f[i][j-1][k],f[i][j][k+1]));\n\t\t\t\tif (s[j]==s[k]) f[i][j][k]=max(f[i][j][k],f[i][j-1][k+1]+1);\n\t\t\t}\n\tfor (int i=1;i<=n;i++)\n\t\tans=max(ans,2*f[K][i-1][i+1]+1);\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "// {{{ by shik\n#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wunused-result\"\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define REP(i, n) for (int i = 0; i < int(n); i++)\n#define REP1(i, a, b) for (int i = (a); i <= int(b); i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef int64_t LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nnamespace { namespace shik {\n\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%\" SCNd64, &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\n\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%\" PRId64, x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n\n#ifdef SHIK\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\ntemplate<class T, class F = less<T>> void sort_uniq(vector<T> &v, F f = F()) { sort(begin(v), end(v), f); v.resize(unique(begin(v), end(v)) - begin(v)); }\ntemplate<class T> inline T bit(T x, int i) { return (x >> i) & 1; }\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\ntemplate<class T> using MaxHeap = priority_queue<T>;\ntemplate<class T> using MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\n// }}}\n\nconst int N=314;\nchar s[N];\nint n,k,dp[N][N][N];\n\nint go( int l, int r, int t ) {\n    if ( l>r ) return 0;\n    if ( l==r ) return 1;\n    int &v=dp[l][r][t];\n    if ( v!=0 ) return v;\n    if ( s[l]==s[r] ) v=go(l+1,r-1,t)+2;\n    else {\n        chkmax(v,go(l+1,r,t));\n        chkmax(v,go(l,r-1,t));\n        if ( t>0 ) chkmax(v,go(l+1,r-1,t-1)+2);\n    }\n    return v;\n}\n\nvoid main() {\n    R(s,k);\n    n=strlen(s);\n    int ans=go(0,n-1,k);\n    W(ans);\n}\n\n// {{{ main\n}}\nint main() { shik::main(); return 0; }\n// }}}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define for0(i, n) for(int i = 0; i < n; i++)\n#define for1(i, n) for(int i = 1; i <= n; i++)\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(), v.end()\n#define V vector<int>\n#define VP vector<pair<int, int> >\n#define FASTIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#ifdef _WIN32\n#include <windows.h>\n#define print(x) PRINT(x, #x)\ntemplate<typename T> inline const void PRINT(T VARIABLE, string NAME)\n{\n#ifndef ONLINE_JUDGE /// ONLINE_JUDGE IS DEFINED ON CODEFORCES\n    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n    SetConsoleTextAttribute(hConsole, 10);\n    cerr << NAME << \" = \" << VARIABLE;\n    SetConsoleTextAttribute(hConsole, 7);\n    cerr << '\\n';\n#endif\n}\n#else\n#define print(x) 0\n#endif\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst ll INFLL = 2 * (ll)1e18 + 100;\nconst int INFINT = 2 * (int)1e9 + 100;\nconst double PI = atan(1) * 4;\nconst double EPS = 1e-12;\nconst int SEED = 1e3 + 7;\n\nconst int MOD = 1e9 + 7; /// careful here (7 or 9, 66.. etc)\nconst int NMAX = 300 + 5;\n\nstring s;\nint k;\nint dp[NMAX][NMAX][NMAX], trecut[NMAX][NMAX][NMAX];\n\nvoid solve(int l, int r, int x)\n{\n    if(trecut[l][r][x]) return;\n    if(l == r)\n    {\n        dp[l][r][x] = 1;\n        trecut[l][r][x] = 1;\n        return;\n    }\n    if(l > r)\n    {\n        dp[l][r][x] = 0;\n        trecut[l][r][x] = 1;\n        return;\n    }\n\n    if(s[l] == s[r])\n    {\n        if(!trecut[l + 1][r - 1][x]) solve(l + 1, r - 1, x);\n        dp[l][r][x] = 2 + dp[l + 1][r - 1][x];\n    }\n    else\n    {\n        if(x - 1 >= 0)\n        {\n            if(!trecut[l + 1][r - 1][x - 1])\n                solve(l + 1, r - 1, x - 1);\n            dp[l][r][x] = 2 + dp[l + 1][r - 1][x - 1];\n        }\n\n        if(!trecut[l + 1][r][x]) solve(l + 1, r, x);\n        if(!trecut[l][r - 1][x]) solve(l, r - 1, x);\n        dp[l][r][x] = max(dp[l][r][x], max(dp[l + 1][r][x], dp[l][r - 1][x]));\n\n    }\n    trecut[l][r][x] = 1;\n}\n\nint main()\n{\n    FASTIO;\n    cin >> s >> k;\n    int n = s.size();\n    solve(0, n - 1, k);\n    int sol = 1;\n    for0(i, n)\n    for0(j, n)\n    for0(K, k + 1)\n    {\n        if(!trecut[i][j][K]) solve(i, j, K);\n        sol = max(sol, dp[i][j][K]);\n    }\n\n    cout << sol;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid Max(int &a,int x){\n  a=max(a,x);\n}\n\nstring s;\nint mem[305][305][305];\nint rec(int l,int r,int k){\n\n  if( mem[l][r][k] != -1 )return mem[l][r][k];\n  \n  if(l==r)return 1;\n  if(l>r)return 0;\n  \n  int res=0;\n  \n  if(s[l]==s[r]){\n    Max(res,rec(l+1,r-1,k)+2);\n  }\n\n  Max(res,rec(l+1,r,k));\n  Max(res,rec(l,r-1,k));\n  if(k>0){\n    Max(res,rec(l+1,r-1,k-1)+2);\n  }\n\n  \n  return mem[l][r][k]=res;\n}\n\nint main(){\n  memset( mem, -1, sizeof(mem) );\n  cin>>s;\n  int k;\n  cin>>k;\n\n  cout<< rec(0, s.size()-1 , k) <<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sz(a)((int)(a).size())\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);iostream::sync_with_stdio(0);cout<<fixed<<setprecision(10);cerr<<fixed<<setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());const int D=4,dx[]={+1,0,-1,0},dy[]={0,+1,0,-1};\nconst int N=303;\nint dp[N][N][N+N];\nint32_t main(){\n    string s;int k;\n    cin>>s>>k;\n    int n=sz(s);\n    string t=s+\"#\";\n    reverse(t.begin(), t.end());\n    s=\"#\"+s;\n    int ans=0;\n    k+=k;\n    for(int i=1;i<=n;++i){\n        for(int j=1;j<=n;++j){\n            for(int c=0;c<=k;++c){\n                dp[i][j][c]=max(dp[i-1][j][c],dp[i][j-1][c]);\n                if(s[i]==t[j])upx(dp[i][j][c],dp[i-1][j-1][c]+1);\n                else if(c)upx(dp[i][j][c],dp[i-1][j-1][c-1]+1);\n            }\n        }\n    }\n    forn(i,k+1)upx(ans,dp[n][n][i]);\n    cout<<ans<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 300;\n\nchar ch[N+5]; int f[N+5][N+5][N+5], k, n;\n\nvoid work() {\n    scanf(\"%s%d\", ch+1, &k); n = strlen(ch+1);\n    for (int i = 1; i <= n; i++) f[i][i][0] = 1;\n    for (int l = 1; l <= n; l++)\n\tfor (int i = 1; i+l <= n; i++)\n\t    for (int p = 0, j = i+l; p <= k; p++) {\n\t\tf[i][j][p] = max(f[i+1][j][p], f[i][j-1][p]);\n\t\tif (ch[i] == ch[j]) f[i][j][p] = max(f[i][j][p], f[i+1][j-1][p]+2);\n\t\tif (p) f[i][j][p] = max(f[i][j][p], f[i+1][j-1][p-1]+2);\n\t    }\n    int ans = 0;\n    for (int i = 0; i <= k; i++) ans = max(ans, f[1][n][i]);\n    printf(\"%d\\n\", ans);\n}\nint main() {work(); return 0; }\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<stack>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<cstring>\n#include<complex>\n#include<bitset>\n#include<iostream>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> Q;\ntypedef complex<double> C;\n#define cx real()\n#define cy imag()\nconst ll INF = 1LL << 60;\nconst double DINF = 1e30;\nconst ll mod = 1000000007;\nconst ll dx[4] = {1, 0, -1, 0};\nconst ll dy[4] = {0, -1, 0, 1};\nconst C I = C(0, 1);\nconst double EPS = 1e-10;\nconst ll NCK_MAX = 510000;\n\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y) {\n  if (b == 0) {\n    x = 1, y = 0; return a;\n  }\n  ll q = a/b, g = extgcd(b, a - q*b, x, y);\n  ll z = x - q * y;\n  x = y;\n  y = z;\n  return g;\n}\n\nll invmod (ll a, ll m) { // a^-1 mod m\n  ll x, y;\n  extgcd(a, m, x, y);\n  x %= m;\n  if (x < 0) x += m;\n  return x;\n}\n\nll *fac, *finv, *inv;\n\nvoid nCk_init(ll mod) {\n  fac = new ll[NCK_MAX];\n  finv = new ll[NCK_MAX];\n  inv = new ll[NCK_MAX];\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (ll i = 2; i < NCK_MAX; i++) {\n    fac[i] = fac[i-1] * i % mod;\n    inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n    finv[i] = finv[i-1] * inv[i] % mod;\n  }\n}\n\nll nCk(ll n, ll k, ll mod) {\n  if (fac == NULL) nCk_init(mod);\n  if (n < k) return 0;\n  if (n < 0 || k < 0) return 0;\n  return fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\ntemplate <typename T>\nclass Zip {\n  vector<T> d;\n  bool flag;\n  void init() {\n    sort(d.begin(), d.end());\n    d.erase(unique(d.begin(), d.end()), d.end());\n    flag = false;\n  }\npublic:\n  Zip() {\n    flag = false;\n  }\n  void add(T x) {\n    d.push_back(x);\n    flag = true;\n  }\n  ll getNum(T x) {\n    if (flag) init();\n    return lower_bound(d.begin(), d.end(), x) - d.begin();\n  }\n  ll size() {\n    if (flag) init();\n    return (ll)d.size();\n  }\n};\n\nclass UnionFind {\n  vector<ll> par, rank; // par > 0: number, par < 0: -par\npublic:\n  UnionFind(ll n) : par(n, 1), rank(n, 0) {}\n  ll getSize(ll x) {\n    return par[find(x)];\n  }\n  ll find(ll x) {\n    if (par[x] > 0) return x;\n    return -(par[x] = -find(-par[x]));\n  }\n  void merge(ll x, ll y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (rank[x] < rank[y]) {\n      par[y] += par[x];\n      par[x] = -y;\n    } else {\n      par[x] += par[y];\n      par[y] = -x;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n  }\n  bool isSame(ll x, ll y) {\n    return find(x) == find(y);\n  }\n};\n\n\ntemplate <typename T>\nclass SegmentTree {\n  ll n;\n  vector<T> node;\n  function<T(T, T)> fun, fun2;\n  bool customChange;\n  T outValue, initValue;\npublic:\n  void init(ll num, function<T(T, T)> resultFunction, T init, T out, function<T(T, T)> changeFunction = NULL) {\n    // changeFunction: (input, beforevalue) => newvalue\n    fun = resultFunction;\n    fun2 = changeFunction;\n    customChange = changeFunction != NULL;\n    n = 1;\n    while (n < num) n *= 2;\n    node.resize(2 * n - 1);\n    fill(node.begin(), node.end(), init);\n    outValue = out;\n    initValue = init;\n  }\n  void valueChange(ll num, T value) {\n    num += n-1;\n    if (customChange) node[num] = fun2(value, node[num]);\n    else node[num] = value;\n    while (num > 0) num = (num - 1) / 2, node[num] = fun(node[num * 2 + 1], node[num * 2 + 2]);\n  }\n  T rangeQuery(ll a, ll b, ll l = 0, ll r = -1, ll k = 0) { // [a, b)\n    if (r == -1) r = n;\n    if (a <= l && r <= b) return node[k];\n    if (b <= l || r <= a) return outValue;\n    ll mid = (l + r) / 2;\n    return fun(rangeQuery(a, b, l, mid, 2*k+1), rangeQuery(a, b, mid, r, 2*k+2));\n  }\n};\n\ntemplate <typename T>\nclass Graph {\n  struct edge { ll to; T cost; };\n  struct edge_data { ll from, to; T cost; };\n\n  ll v;\n  vector<vector<edge>> e, re;\n  vector<edge_data> ed;\n  vector<bool> used;\n  vector<ll> vs, cmp;\n  bool isDirected, isMinasEdge;\npublic:\n  Graph(ll _v, bool _isDirected = true, ll range_add = 0) {\n    // range_add 0:no / 1:in / 2:out / 3:in+out\n    //_v++;\n    v = _v, isDirected = _isDirected; isMinasEdge = false;\n    e.resize(v), re.resize(v);\n  }\n  void add_edge(ll s, ll t, T cost = 1) {\n    e[s].push_back((edge){t, cost});\n    if (!isDirected) e[t].push_back((edge){s, cost});\n    else re[t].push_back((edge){s, cost});\n    ed.push_back((edge_data){s, t, cost});\n    if (cost < 0) isMinasEdge = true;\n  }\n  vector<T> dijkstra(ll s) {\n    vector<T> d(v, INF);\n    d[s] = 0;\n    auto edge_cmp = [](const edge& a, const edge& b) { return a.cost > b.cost; };\n    priority_queue<edge, vector<edge>, decltype(edge_cmp)> pq(edge_cmp);\n    pq.push((edge){s, 0});\n    while (!pq.empty()) {\n      edge temp = pq.top(); pq.pop();\n      if (d[temp.to] < temp.cost) continue;\n      for (const edge& next : e[temp.to]) {\n        T cost = temp.cost + next.cost;\n        if (d[next.to] > cost) {\n          d[next.to] = cost;\n          pq.push((edge){next.to, cost});\n        }\n      }\n    }\n    return d;\n  }\n  vector<T> bellmanford(ll s) {\n    vector<T> d(v, INF);\n    d[s] = 0;\n    for (ll i = 0; i < v; i++) {\n      for (const edge_data& temp : ed) {\n        if (d[temp.from] != INF && d[temp.to] > d[temp.from] + temp.cost) d[temp.to] = d[temp.from] + temp.cost;\n        if (!isDirected && d[temp.to] != INF && d[temp.from] > d[temp.to] + temp.cost) d[temp.from] = d[temp.to] + temp.cost;\n      }\n    }\n    for (ll i = 0; i < v; i++) {\n      for (const edge_data& temp : ed) {\n        if (d[temp.from] != INF && d[temp.to] > d[temp.from] + temp.cost) d[temp.to] = -INF;\n        if (!isDirected && d[temp.to] != INF && d[temp.from] > d[temp.to] + temp.cost) d[temp.from] = -INF;\n      }\n    }\n    return d;\n  }\n  vector<T> shortest_path(ll s) {\n    if (isMinasEdge) return bellmanford(s);\n    else return dijkstra(s);\n  }\n  T kruskal() {\n    // if (isDirected)\n    UnionFind uf(v);\n    auto edge_data_cmp = [](const edge_data& a, const edge_data& b) { return a.cost < b.cost; };\n    sort(ed.begin(), ed.end(), edge_data_cmp);\n    T ans = 0;\n    for (const edge_data& temp : ed) {\n      if (uf.isSame(temp.from, temp.to)) continue;\n      uf.merge(temp.from, temp.to);\n      ans += temp.cost;\n    }\n    return ans;\n  }\n  void scc_dfs(ll s) {\n    used[s] = true;\n    for (const edge& i : e[s]) if (!used[i.to]) scc_dfs(i.to);\n    vs.push_back(s);\n  }\n  void scc_rdfs(ll s, ll k) {\n    used[s] = true;\n    cmp[s] = k;\n    for (const edge& i : re[s]) if (!used[i.to]) scc_rdfs(i.to, k);\n  }\n  vector<ll> scc() {\n    used.resize(v);\n    fill(used.begin(), used.end(), false);\n    cmp.resize(v);\n    vs.clear();\n    for (ll i = 0; i < v; i++) if (!used[i]) scc_dfs(i);\n    used.resize(v);\n    fill(used.begin(), used.end(), false);\n    ll k = 0;\n    for (ll i = vs.size() - 1; i >= 0; i--) if (!used[vs[i]]) scc_rdfs(vs[i], k++);\n    return cmp;\n  }\n};\n\nclass RollingHash {\n  int base;\n  vector<__int128> hash;\n  vector<__int128> pw;\n  const __int128 hashmod = (1ull << 61) - 1;\npublic:\n  RollingHash(string s, int base = 10007) : base(base), hash(s.length()+1, 0), pw(s.length()+1, 1) {\n    for (int i = 0; i < (int)s.length(); i++) {\n      hash[i+1] = (hash[i] * base + s[i]) % hashmod;\n      pw[i+1] = pw[i] * base % hashmod;\n    }\n  }\n  ll get(ll a, ll b) { // [a, b)\n    __int128 tmp = hashmod + hash[b] - hash[a] * pw[b-a] % hashmod;\n    if (tmp >= hashmod) tmp -= hashmod;\n    return (ll)tmp;\n  }\n};\n\nll n, k, dp[302][302][302], ans;\nchar s[301];\n\nll solve(ll x, ll y, ll num) {\n  if (dp[x][y][num] != -1) return dp[x][y][num];\n  if (x == 0 || y == n+1) return 0;\n  ll ans = max(solve(x-1, y, num), solve(x, y+1, num));\n  if (s[x-1] == s[y-1]) ans = max(ans, solve(x-1, y+1, num)+(x==y?1:2));\n  if (x != y && num > 0) ans = max(ans, solve(x-1, y+1, num-1)+2);\n  return dp[x][y][num] = ans;\n}\n\nint main() {\n  scanf(\"%s\", s);\n  scanf(\"%lld\", &k);\n  while (s[n] != 0) n++;\n  for (ll i = 0; i <= n+1; i++) {\n    for (ll j = 0; j <= n+1; j++) {\n      for (ll k = 0; k <= n+1; k++) {\n        dp[i][j][k] = -1;\n      }\n    }\n  }\n  for (ll i = 1; i < n; i++) ans = max(ans, solve(i, i, k));\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n#define INF 1000000000\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint dp[333][333][333];\nstring s;\nint k;\n\nint dfs(int K,int L,int R)\n{\n//\tcout << K << ' ' << L << ' ' << R << endl;\n\tif(K < 0)return -100000000;\n\tif(L > R)return 0;\n\tif(dp[K][L][R] != 0)return dp[K][L][R];\n\tint ret = 0;\n\tif(s[L] == s[R])ret = max(ret,dfs(K,L+1,R-1)+2);\n\telse ret = max(ret,dfs(K-1,L+1,R-1)+2);\n\tret = max(ret,dfs(K,L+1,R));\n\tret = max(ret,dfs(K,L,R-1));\n\t\n\treturn dp[K][L][R] = ret;\n}\n\n\nint main()\n{\n\tcin >> s >> k;\n\t\n\tREP(K,333)REP(i,333)dp[K][i][i] = 1;\n\tcout << dfs(k,0,s.size()-1) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nЗАПУСКАЕМ \n░ГУСЯ░▄▀▀▀▄░РАБОТЯГУ░░\n▄███▀░◐░░░▌░░░░░░░\n░░░░▌░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▌░░░░░▐▄▄░░░░░\n░░░░▌░░░░▄▀▒▒▀▀▀▀▄\n░░░▐░░░░▐▒▒▒▒▒▒▒▒▀▀▄\n░░░▐░░░░▐▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░▀▄░░░░▀▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░░░▀▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▀▄\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░▄▄▌▌▄▌▌░░░░░ \n */\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; } \ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p) { _out << _p.first << ' ' << _p.second; return _out; }\ntemplate<typename T, typename U> inline istream &operator>> (istream &_in, pair<T, U> &_p) { _in >> _p.first >> _p.second; return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const vector<T> &_v) { if (_v.empty()) { return _out; } _out << _v.front(); for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline istream &operator>> (istream &_in, vector<T> &_v) { for (auto &_i : _v) { _in >> _i; } return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define y1 y1228                                                         \n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define files(FILENAME) read(FILENAME), write(FILENAME)\n#define pb push_back\n#define x first\n#define y second\nconst string FILENAME = \"input\";\nconst int MAXN = 333;\n\n\nint n, m;\nstring a;\nint dp[MAXN][MAXN][MAXN];\n\n\nint main(){\n\tios::sync_with_stdio(0);\n    cin.tie(0);\n   // read(FILENAME);\n    cin >> a;\n    cin >> m;\n    n = sz(a);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n - i; j++) {\n            int s = j, t = j + i;\n            for (int k = 0; k <= m; k++) {\n                if (s == t) {\n                    dp[s][t][k] = 1;\n                } else {\n                    chkmax(dp[s][t][k], dp[s + 1][t][k]);\n                    chkmax(dp[s][t][k], dp[s][t - 1][k]);\n                    chkmax(dp[s][t][k + (a[s] != a[t])], dp[s + 1][t - 1][k] + 2);\n                }\n            }\n        }\n    }\n    cout << dp[0][n - 1][m] << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <memory>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#define rep(i, n) for(int i=0;i<(int)(n);i++)\n#define REP(i, n) for(int i=1;i<=(int)(n);i++)\n#define all(V) V.begin(),V.end()\ntypedef long long lint;\ntypedef std::pair<lint, lint> P;\nconstexpr int INF = INT_MAX / 10;\nconstexpr lint LINF = LLONG_MAX / 2;\nconstexpr double eps = 1e-9;\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\n\ntemplate<class T, class Alloc = std::allocator<T>>\nclass Vector {\n\n\tusing traits = std::allocator_traits<Alloc>;\n\npublic:\n\n\tusing value_type = T;\n\tusing allocator_type = Alloc;\n\tusing size_type = unsigned int;\n\tusing difference_type = int;\n\tusing reference = T&;\n\tusing const_reference = const T&;\n\tusing pointer = typename traits::pointer;\n\tusing const_pointer = typename traits::const_pointer;\n\n\tclass iterator {\n\n\tpublic:\n\n\t\tusing difference_type = int;\n\t\tusing value_type = Vector::value_type;\n\t\tusing pointer = Vector::pointer;\n\t\tusing reference = Vector::reference;\n\t\tusing iterator_category = std::random_access_iterator_tag;\n\n\tprivate:\n\n\t\tpointer p;\n\n\tpublic:\n\n\t\titerator()noexcept :p() {}\n\t\titerator(const Vector& base, difference_type index) noexcept :p(base.e + index) {}\n\t\titerator(const iterator& i) :p(i.p) {}\n\n\t\titerator& operator=(const iterator& i) = default;\n\t\titerator& operator=(iterator&& i)noexcept = default;\n\n\t\titerator& operator++() {\n\t\t\tp++;\n\t\t\treturn *this;\n\t\t}\n\n\t\titerator operator++(int) {\n\t\t\titerator res = *this;\n\t\t\tp++;\n\t\t\treturn res;\n\t\t}\n\n\t\titerator operator+(const difference_type& x)const {\n\t\t\titerator res = *this;\n\t\t\treturn res += x;\n\t\t}\n\n\t\titerator& operator+=(const difference_type& x) {\n\t\t\tp += x;\n\t\t\treturn *this;\n\t\t}\n\n\t\titerator& operator--() {\n\t\t\tp--;\n\t\t\treturn *this;\n\t\t}\n\n\t\titerator operator--(int) {\n\t\t\titerator res = *this;\n\t\t\tp--;\n\t\t\treturn res;\n\t\t}\n\n\t\titerator operator-(const difference_type x)const {\n\t\t\titerator res = *this;\n\t\t\treturn res -= x;\n\t\t}\n\n\t\tdifference_type operator-(const iterator& i)const {\n\t\t\treturn p - i.p;\n\t\t}\n\n\t\titerator& operator-=(const difference_type x) {\n\t\t\tp -= x;\n\t\t\treturn *this;\n\t\t}\n\n\t\treference operator*()const {\n\t\t\treturn *p;\n\t\t}\n\n\t\treference operator[](const difference_type x)const {\n\t\t\treturn *(p + x);\n\t\t}\n\n\t\tbool operator<(const iterator& i)const {\n\t\t\treturn p < i.p;\n\t\t}\n\n\t\tbool operator<=(const iterator& i)const {\n\t\t\treturn p <= i.p;\n\t\t}\n\n\t\tbool operator==(const iterator& i)const {\n\t\t\treturn p == i.p;\n\t\t}\n\n\t\tbool operator>(const iterator& i)const {\n\t\t\treturn p > i.p;\n\t\t}\n\n\t\tbool operator>=(const iterator& i)const {\n\t\t\treturn p >= i.p;\n\t\t}\n\n\t\tbool operator!=(const iterator& i)const {\n\t\t\treturn p != i.p;\n\t\t}\n\n\t};\n\n\tclass const_iterator {\n\n\tpublic:\n\n\t\tusing difference_type = int;\n\t\tusing value_type = Vector::value_type;\n\t\tusing pointer = const Vector::pointer;\n\t\tusing reference = const Vector::reference;\n\t\tusing iterator_category = std::random_access_iterator_tag;\n\n\tprivate:\n\n\t\tpointer p;\n\n\tpublic:\n\n\t\tconst_iterator()noexcept :p() {}\n\t\tconst_iterator(const Vector& base, difference_type index) noexcept :p(base.e + index) {}\n\t\tconst_iterator(const const_iterator& i) :p(i.p) {}\n\n\t\tconst_iterator& operator=(const const_iterator& i)noexcept = default;\n\t\tconst_iterator& operator=(const_iterator&& i)noexcept = default;\n\n\t\tconst_iterator& operator++() {\n\t\t\tp++;\n\t\t\treturn *this;\n\t\t}\n\n\t\tconst_iterator operator++(int) {\n\t\t\tconst_iterator res = *this;\n\t\t\tp++;\n\t\t\treturn res;\n\t\t}\n\n\t\tconst_iterator operator+(const difference_type x)const {\n\t\t\tconst_iterator res = *this;\n\t\t\treturn res += x;\n\t\t}\n\n\t\tconst_iterator& operator+=(const difference_type x) {\n\t\t\tp += x;\n\t\t\treturn *this;\n\t\t}\n\n\t\tconst_iterator& operator--() {\n\t\t\tp--;\n\t\t\treturn *this;\n\t\t}\n\n\t\tconst_iterator operator--(int) {\n\t\t\tconst_iterator res = *this;\n\t\t\tp--;\n\t\t\treturn res;\n\t\t}\n\n\t\tconst_iterator operator-(const difference_type x)const {\n\t\t\tconst_iterator res = *this;\n\t\t\treturn res -= x;\n\t\t}\n\n\t\tdifference_type operator-(const const_iterator& i)const {\n\t\t\treturn p - i.p;\n\t\t}\n\n\t\tconst_iterator& operator-=(const difference_type x) {\n\t\t\tp -= x;\n\t\t\treturn *this;\n\t\t}\n\n\t\treference operator*()const {\n\t\t\treturn *p;\n\t\t}\n\n\t\treference operator[](const difference_type x)const {\n\t\t\treturn *(p + x);\n\t\t}\n\n\t\tbool operator<(const const_iterator& i)const {\n\t\t\treturn p < i.p;\n\t\t}\n\n\t\tbool operator<=(const const_iterator& i)const {\n\t\t\treturn p <= i.p;\n\t\t}\n\n\t\tbool operator==(const const_iterator& i)const {\n\t\t\treturn p == i.p;\n\t\t}\n\n\t\tbool operator>(const const_iterator& i)const {\n\t\t\treturn p > i.p;\n\t\t}\n\n\t\tbool operator>=(const const_iterator& i)const {\n\t\t\treturn p >= i.p;\n\t\t}\n\n\t\tbool operator!=(const const_iterator& i)const {\n\t\t\treturn p != i.p;\n\t\t}\n\n\t};\n\n\tusing reverse_iterator = std::reverse_iterator<iterator>;\n\tusing const_reverse_iterator = std::reverse_iterator<const_iterator>;\n\nprivate:\n\n\tpointer e;\n\tsize_type length = 0, cap = 1;\n\tAlloc alloc;\n\n\tstatic_assert(std::is_same<T, typename Alloc::value_type>::value, \"The allocator value type is not matched the Vector value type.\");\n\tstatic_assert(!std::is_const<T>::value, \"This library forbids containers of const elements\");\n\npublic:\n\n\tVector() :Vector(Alloc()) {}\n\n\texplicit Vector(const Alloc& a)noexcept :alloc(a) {\n\t\te = alloc.allocate(cap);\n\t}\n\n\texplicit Vector(size_type n, const Alloc& a = Alloc()) :alloc(a) {\n\t\twhile (cap < n)cap *= 2;\n\t\te = alloc.allocate(cap);\n\t\trep(i, n)emplace_back();\n\t}\n\n\texplicit Vector(size_type n, const_reference value, const Alloc& a = Alloc()) :alloc(a) {\n\t\twhile (cap < n)cap *= 2;\n\t\te = alloc.allocate(cap);\n\t\trep(i, n)emplace_back(value);\n\t}\n\n\ttemplate<class InputIter>\n\tVector(InputIter first, InputIter last, const Alloc& a = Alloc()) :alloc(a) {\n\t\te = alloc.allocate(cap);\n\t\tfor (InputIter i = first; i != last; i++) {\n\t\t\templace_back(*i);\n\t\t}\n\t}\n\n\tVector(const Vector& x, const Alloc& a = Alloc()) :alloc(a) {\n\t\twhile (cap < x.length)cap *= 2;\n\t\tlength = x.length;\n\t\te = alloc.allocate(cap);\n\t\trep(i, x.length)traits::construct(alloc, e + i, *(x.e + i));\n\t}\n\n\tVector(Vector&& x, const Alloc& a = Alloc()) :alloc(a) {\n\t\tcap = x.cap;\n\t\tlength = x.length;\n\t\te = x.e;\n\t\tx.e = nullptr;\n\t}\n\n\t~Vector() {\n\t\tif (e != nullptr) {\n\t\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\t\talloc.deallocate(e, cap);\n\t\t}\n\t}\n\n\tVector& operator=(const Vector& x) {\n\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\talloc.deallocate(e, cap);\n\t\tlength = x.length;\n\t\tcap = 1;\n\t\twhile (cap < length)cap *= 2;\n\t\te = alloc.allocate(cap);\n\t\trep(i, length)traits::construct(alloc, e + i, *(x.e + i));\n\t\treturn *this;\n\t}\n\n\tVector& operator=(Vector&& x) {\n\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\talloc.deallocate(e, cap);\n\t\tcap = x.cap;\n\t\tlength = x.length;\n\t\te = x.e;\n\t\tx.e = nullptr;\n\t\treturn *this;\n\t}\n\nprivate:\n\n\tvoid extension() {\n\t\tpointer e_ = alloc.allocate(cap * 2);\n\t\trep(i, length)traits::construct(alloc, e_ + i, *(e + i));\n\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\talloc.deallocate(e, cap);\n\t\te = e_;\n\t\tcap *= 2;\n\t}\n\n\tvoid extension(size_type n) {\n\t\tunsigned int r = 1;\n\t\twhile (cap * r < n)r *= 2;\n\t\tif (r == 1)return;\n\t\tpointer e_ = alloc.allocate(cap * r);\n\t\trep(i, length)traits::construct(alloc, e_ + i, *(e + i));\n\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\talloc.deallocate(e, cap);\n\t\te = e_;\n\t\tcap *= r;\n\t}\n\npublic:\n\n\ttemplate<class InputIter>\n\tvoid assign(InputIter first, InputIter last) {\n\t\tsize_type cnt = 0;\n\t\tfor (InputIter i = first; i != last; i++) {\n\t\t\tif (cnt == cap) {\n\t\t\t\tlength = std::max(length, cnt);\n\t\t\t\textension();\n\t\t\t}\n\t\t\ttraits::construct(alloc, e + cnt, *i);\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tvoid assign(size_type n, const_reference value) {\n\t\textension(n);\n\t\tstd::fill(e, e + n, value);\n\t}\n\n\ttemplate<class... Args>\n\tvoid emplace_back(Args&&... args) {\n\t\tif (length == cap)extension();\n\t\ttraits::construct(alloc, e + length, std::forward<Args>(args)...);\n\t\tlength++;\n\t}\n\n\tvoid push_back(const_reference value) {\n\t\templace_back(value);\n\t}\n\n\tvoid push_back(T&& value) {\n\t\templace_back(std::move(value));\n\t}\n\n\tvoid pop_back() {\n\t\ttraits::destroy(alloc, e + length);\n\t\tlength--;\n\t}\n\n\tvoid reserve(size_type n) {\n\t\textension(n);\n\t}\n\n\titerator erase(iterator pos) {\n\t\tconst iterator res = pos;\n\t\titerator t = pos; t++;\n\t\tfor (iterator i = pos; t != end(); i++, t++) {\n\t\t\t*i = std::move(*t);\n\t\t}\n\t\tpop_back();\n\t\treturn res;\n\t}\n\n\titerator erase(iterator first, iterator last) {\n\t\tconst iterator res = first;\n\t\ttypename iterator::difference_type d = last - first;\n\t\tfor (iterator i = first; i + d != end(); i++) {\n\t\t\t*i = std::move(*(i + d));\n\t\t}\n\t\trep(i, d)pop_back();\n\t\treturn res;\n\t}\n\n\tvoid swap(Vector& x) {\n\t\tstd::swap(length, x.length);\n\t\tstd::swap(cap, x.cap);\n\t\tstd::swap(e, x.e);\n\t}\n\n\tvoid clear() {\n\t\twhile (length)pop_back();\n\t}\n\n\tsize_type size()const {\n\t\treturn length;\n\t}\n\n\tvoid resize(size_type  n, const_reference value = T()) {\n\t\textension(n);\n\t\twhile (n < length)pop_back();\n\t\tlength = n;\n\t\tstd::fill(e, e + n, value);\n\t}\n\n\tsize_type capacity()const {\n\t\treturn cap;\n\t}\n\n\tbool empty()const {\n\t\treturn !length;\n\t}\n\n\treference operator[](const size_type pos)const {\n\t\treturn e[pos];\n\t}\n\n\tpointer data() {\n\t\treturn e;\n\t}\n\n\treference front() {\n\t\treturn *e;\n\t}\n\n\treference back() {\n\t\treturn *(e + length - 1);\n\t}\n\n\titerator begin() noexcept {\n\t\treturn iterator(*this, 0);\n\t}\n\n\tconst_iterator begin()const noexcept {\n\t\treturn const_iterator(*this, 0);\n\t}\n\n\tconst_iterator cbegin()const noexcept {\n\t\treturn const_iterator(*this, 0);\n\t}\n\n\titerator rbegin()noexcept {\n\t\treturn reverse_iterator(*this, 0);\n\t}\n\n\tconst_iterator rbegin()const noexcept {\n\t\treturn const_reverse_iterator(*this, 0);\n\t}\n\n\tconst_iterator crbegin()const noexcept {\n\t\treturn const_reverse_iterator(*this, 0);\n\t}\n\n\titerator end() noexcept {\n\t\treturn iterator(*this, length);\n\t}\n\n\tconst_iterator end()const noexcept {\n\t\treturn const_iterator(*this, length);\n\t}\n\n\tconst_iterator cend()const noexcept {\n\t\treturn const_iterator(*this, length);\n\t}\n\n\titerator rend()noexcept {\n\t\treturn reverse_iterator(*this, length);\n\t}\n\n\tconst_iterator rend()const noexcept {\n\t\treturn const_reverse_iterator(*this, length);\n\t}\n\n\tconst_iterator crend()const noexcept {\n\t\treturn const_reverse_iterator(*this, length);\n\t}\n\n};\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ninline lint gcd(lint a, lint b) {\n\twhile (b) {\n\t\tlint c = a;\n\t\ta = b; b = c % b;\n\t}\n\treturn a;\n}\ninline lint lcm(lint a, lint b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(lint n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\nlint mypow(lint a, lint b) {\n\tif (!b)return 1;\n\tif (b & 1)return mypow(a, b - 1) * a;\n\tlint memo = mypow(a, b >> 1);\n\treturn memo * memo;\n}\nlint modpow(lint a, lint b, lint m) {\n\tif (!b)return 1;\n\tif (b & 1)return modpow(a, b - 1, m) * a % m;\n\tlint memo = modpow(a, b >> 1, m);\n\treturn memo * memo % m;\n}\ntemplate<typename T>\nvoid printArray(std::vector<T>& vec) {\n\trep(i, vec.size() - 1)std::cout << vec[i] << \" \";\n\tstd::cout << vec.back() << std::endl;\n}\ntemplate<typename T>\nvoid printArray(Vector<T>& vec) {\n\trep(i, vec.size() - 1)std::cout << vec[i] << \" \";\n\tstd::cout << vec.back() << std::endl;\n}\ntemplate<typename T>\nvoid printArray(T l, T r) {\n\tT rprev = r;\n\trprev--;\n\tfor (T i = l; i != rprev; i++) {\n\t\tstd::cout << *i << \" \";\n\t}\n\tstd::cout << *rprev << std::endl;\n}\nstd::string to_string(Vector<int>& vec) {\n\tstd::string res = \"[\";\n\trep(i, vec.size() - 1)res += std::to_string(vec[i]) + \", \";\n\tres += std::to_string(vec.back()) + \"]\";\n\treturn res;\n}\ntemplate<unsigned int modulo = 1000000007>\nclass ModInt {\n\tlint value;\npublic:\n\tModInt() : value(0) {}\n\ttemplate<typename T>\n\tModInt(T value = 0) : value(value) {\n\t\tif (value < 0)value = -(lint)(-value % modulo) + modulo;\n\t\tthis->value = value % modulo;\n\t}\n\tinline operator int()const { return value; }\n\tinline ModInt& operator+=(const ModInt& x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline ModInt operator-()const {\n\t\treturn ModInt(0) -= *this;\n\t}\n\tinline ModInt& operator-=(const ModInt& x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator*=(const ModInt& x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator/=(ModInt rhs) {\n\t\tint exp = modulo - 2;\n\t\twhile (exp) {\n\t\t\tif (exp & 1)*this *= rhs;\n\t\t\trhs *= rhs;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn *this;\n\t}\n\ttemplate<typename T> ModInt operator+(const T& rhs)const { return ModInt(*this) += rhs; }\n\ttemplate<typename T> ModInt& operator+=(const T& rhs) { return operator+=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator-(const T& rhs)const { return ModInt(*this) -= rhs; }\n\ttemplate<typename T> ModInt& operator-=(const T& rhs) { return operator-=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator*(const T& rhs)const { return ModInt(*this) *= rhs; }\n\ttemplate<typename T> ModInt& operator*=(const T& rhs) { return operator*=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator/(const T& rhs)const { return ModInt(*this) /= rhs; }\n\ttemplate<typename T> ModInt& operator/=(const T& rhs) { return operator/=(ModInt(rhs)); }\n};\ntemplate<unsigned int T>\nstd::istream& operator>>(std::istream& ist, ModInt<T>& x) {\n\tlint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\nstd::string s;\nint k;\nint dp[310][310][310];\nint main() {\n\tstd::cin >> s >> k;\n\trep(i, s.size())dp[i][i + 1][0] = 1;\n\tREP(i, s.size()) {\n\t\trep(j, s.size() - i + 1) {\n\t\t\trep(l, k + 1) {\n\t\t\t\tif (j)chmax(dp[j - 1][j + i][l], dp[j][j + i][l]);\n\t\t\t\tif (j + i != s.size())chmax(dp[j][j + i + 1][l], dp[j][j + i][l]);\n\t\t\t\tif (j && j + i != s.size()) {\n\t\t\t\t\tif (s[j - 1] == s[j + i]) {\n\t\t\t\t\t\tchmax(dp[j - 1][j + i + 1][l], dp[j][j + i][l] + 2);\n\t\t\t\t\t}\n\t\t\t\t\telse chmax(dp[j - 1][j + i + 1][l + 1], dp[j][j + i][l] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i, k + 1)chmax(ans, dp[0][s.size()][i]);\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring S; int N, K;\nint dp[2][300][300];\n\nint main() {\n  cin >> S >> K; int N = S.size();\n  for(int k = 0; k <= K; ++k) {\n    int cur = k % 2, prev = (k + 1) % 2;\n    for(int i = 1; i <= N - 1; ++i) for(int j = 1; j <= N - i; ++j) {\n      if(S[i - 1] == S[N - j]) {\n        dp[cur][i][j] = dp[cur][i - 1][j - 1] + 1;\n      } else {\n        dp[cur][i][j] = max(dp[cur][i][j - 1], dp[cur][i - 1][j]);\n        if(k > 0) dp[cur][i][j] = max(dp[cur][i][j], dp[prev][i - 1][j - 1] + 1);\n      }\n    }\n  }\n  int res = 0;\n  for(int i = 0; i < N; ++i) res = max(res, 2 * dp[K % 2][i][N - 1 - i] + 1);\n  for(int i = 0; i < N; ++i) res = max(res, 2 * dp[K % 2][i][N - i]);\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <stack>\n#include <vector>\n#define maxn 310\n#define maxe 100010\ntypedef long long ll;\nusing namespace std;\nconst double eps=1e-5;\nconst int inf=0x3f3f3f3f3f;\nchar a[maxn];\nint mc;\nint dp[maxn][maxn][maxn];\nint main()\n{\n    while(scanf(\"%s%d\",a,&mc)==2)\n    {\n        int n=strlen(a);\n        for(int i=0;i<n;i++)dp[i][i][0]=1;\n        for(int l=1;l<n;l++)\n        {\n            for(int i=0;i+l<n;i++)\n            {\n                int j=i+l;\n                for(int k=0;k<=mc;k++)\n                {\n                    if(k)dp[i][j][k]=dp[i][j][k-1]+1;\n                    int t=max(dp[i+1][j][k],dp[i][j-1][k]);\n                    dp[i][j][k]=max(t,dp[i][j][k]);\n                    if(k)dp[i][j][k]=max(dp[i+1][j-1][k-1]+2,dp[i][j][k]);\n                    if(a[i]==a[j])\n                        dp[i][j][k]=max(dp[i+1][j-1][k]+2,dp[i][j][k]);\n                }\n            }\n        }\n        printf(\"%d\\n\",dp[0][n-1][mc]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n\nint lcs(string s, string rs) {\n\tint c[1000][1000];\n\tint m = s.size();\n\tint n = rs.size();\n\tint maxl = 0;\n\ts = s.insert(0,\" \");\n\trs = rs.insert(0, \" \");\n\tfor (int i = 1; i <= m; i++)c[i][0] = 0;\n\tfor (int j = 1; j <= n; j++)c[0][j] = 0;\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (s[i] == rs[j]) {\n\t\t\t\tc[i][j] = c[i - 1][j - 1] + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[i][j] = max(c[i - 1][j], c[i][j - 1]);\n\t\t\t}\n\t\t\tmaxl = max(maxl, c[i][j]);\n\t\t}\n\t}\n\treturn maxl;\n}\n\n\nint main() {\n\tstring s,rs;\n\tint k, maxl;\n\tcin >> s >> k;\n\trs = s;\n\treverse(rs.begin(), rs.end());\n\n\tmaxl = lcs(s, rs);\n\n\tif (maxl <= s.size() - k) cout << maxl + k+1 << endl;\n\telse cout << s.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n \n\nint dp[305][305][305];\n\n\nsigned main()\n{\n \nios_base::sync_with_stdio(false);\ncin.tie(NULL);  \ncout.tie(0);   \n \n \n#ifndef ONLINE_JUDGE\n    if(fopen(\"INPUT.txt\",\"r\"))\n    {\n    freopen (\"INPUT.txt\" , \"r\" , stdin);\n    freopen (\"OUTPUT.txt\" , \"w\" , stdout);\n    }\n#endif    \n\n    string a;\n    cin>>a;\n    int k;\n    cin>>k;\n    int n=a.length();\n    a=\"#\"+a;\n    for(int i=n;i>=1;i--)\n    {\n        for(int j=i+1;j<=n;j++)\n        {\n            dp[i][i][0]=1;\n            for(int l=0;l<=k;l++)\n            {\n                if(a[i]==a[j])\n                {\n                    dp[i][j][l]=max({dp[i+1][j-1][l]+2,dp[i+1][j][l],dp[i][j-1][l]});\n                }\n                else\n                {\n                    if(l>0)\n                        dp[i][j][l]=dp[i+1][j-1][l-1]+2;\n                    dp[i][j][l]=max({dp[i][j][l],dp[i+1][j][l],dp[i][j-1][l]});\n                }                \n            }\n        }\n    }\n\n    int mx=0;\n    for(int i=0;i<=k;i++)\n        mx=max(mx,dp[1][n][i]);\n    cout<<mx;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <stack>\n#include <vector>\n#define maxn 310\n#define maxe 100010\ntypedef long long ll;\nusing namespace std;\nconst double eps=1e-5;\nconst int inf=0x3f3f3f3f3f;\nchar a[maxn];\nint mc;\nint dp[maxn][maxn][maxn];\nint main()\n{\n    while(scanf(\"%s%d\",a,&mc)==2)\n    {\n        int n=strlen(a);\n        for(int i=0;i<n;i++)dp[i][i][0]=1;\n        for(int l=1;l<n;l++)\n        {\n            for(int i=0;i+l<n;i++)\n            {\n                int j=i+l;\n                for(int k=0;k<=mc;k++)\n                {\n                    if(k)dp[i][j][k]=dp[i][j][k-1]+1;\n                    int t=max(dp[i+1][j][k],dp[i][j-1][k]);\n                    dp[i][j][k]=max(t,dp[i][j][k]);\n                    if(a[i]==a[j])\n                        dp[i][j][k]=max(dp[i+1][j-1][k]+2,dp[i][j][k]);\n                }\n            }\n        }\n        printf(\"%d\\n\",dp[0][n-1][mc]+mc);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<math.h>\n#include<time.h>\n#include<vector>\n#include<bitset>\n#include<memory>\n#include<utility>\n#include<fstream>\n#include<stdio.h>\n#include<sstream>\n#include<iostream>\n#include<stdlib.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\nchar a[305];\nint dp[305][305][305];\nint n;\nvoid dfs(int l,int r,int k)\n{\n    if (dp[l][r][k]!=-1)\n    {\n        return;\n    }\n    if (l>r)\n    {\n        dp[l][r][k]=0;\n        return;\n    }\n    if (k>=r-l)\n    {\n        dp[l][r][k]=r-l;\n        return;\n    }\n    dfs(l+1,r,k);\n    dp[l][r][k]=dp[l+1][r][k];\n    int i;\n    for (i=l;i<=r;i++)\n    {\n        if (a[l]==a[i])\n        {\n            dfs(l+1,i,k);\n            if (l+1<=i)\n            {\n                dp[l][r][k]=max(dp[l][r][k],dp[l+1][i][k]+2);\n            }\n            else\n            {\n                dp[l][r][k]=max(dp[l][r][k],dp[l+1][i][k]+1);\n            }\n        }\n        else if (k>0)\n        {\n            dfs(l+1,i,k-1);\n            if (l+1<=i)\n            {\n                dp[l][r][k]=max(dp[l][r][k],dp[l+1][i][k-1]+2);\n            }\n            else\n            {\n                dp[l][r][k]=max(dp[l][r][k],dp[l+1][i][k-1]+1);\n            }\n        }\n    }\n}\nint main()\n{\n    #ifdef absi2011\n    freopen(\"input.txt\",\"r\",stdin);\n    freopen(\"output.txt\",\"w\",stdout);\n    #endif\n    memset(dp,-1,sizeof(dp));\n    scanf(\"%s\",a);\n    n=strlen(a);\n    int k;\n    scanf(\"%d\",&k);\n    dfs(0,n,k);\n    printf(\"%d\\n\",dp[0][n][k]);\n    return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define gc getchar\n#define pc putchar\n#define fi first\n#define queue QQQ\n#define se second\n#define debug(x) cout << #x\" = \" << x << endl;\n#define pp(x,y) cout << \"pp: \" << x << \" \" << y << endl;\n#define rank __RAnK\ninline ll read(){\n\tregister ll x=0,f=1;register char c=gc();\n\tfor(;!isdigit(c);c=gc())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\n#define rd read\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid writeln(ll x){write(x);puts(\"\");}\nconst int maxn = 2e5+233;\nint f[305][305][305];\nchar s[305];\nint K,n;\nint main(){\n\tscanf(\"%s\",s+1);\n\tn = strlen(s+1);\n\tK = rd();\n\tmem(f,0);\n\tRep(i,1,n){\n\t\tRep(k,0,K) f[i][i][k] = 1;\n\t}\n\tRep(len,2,n){\n\t\tfor(int i=1;i+len-1<=n;++i){\n\t\t\tint j=i+len-1;\n\t\t\tRep(k,0,K){\n\t\t\t\tif(k)f[i][j][k] = max(f[i][j][k],f[i][j][k-1]);\n\t\t\t\tf[i][j][k] = max(f[i][j][k],f[i+1][j][k]);\n\t\t\t\tf[i][j][k] = max(f[i][j][k],f[i][j-1][k]);\n\t\t\t\tif(s[i]==s[j]) f[i][j][k] = max(f[i][j][k],f[i+1][j-1][k]+2);\n\t\t\t\tif(k)f[i][j][k] = max(f[i][j][k],f[i+1][j-1][k-1]+2);\n\t\t\t}\n\t\t}\n\t}writeln(f[1][n][K]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=305;\nint dp[N][N][N];\nint main()\n{\n    string s; int k;\n    cin>>s>>k;\n    int n=s.size();\n    s='a'+s;\n    for(int i=1;i<=n;i++)\n    {\n        dp[0][i][i]=1;\n        if(i==n)\n            continue;\n        if(s[i]==s[i+1])\n            dp[0][i][i+1]=2;\n        else\n            dp[0][i][i+1]=1;\n    }\n    for(int len=2;len<n;len++)\n    {\n        for(int i=1;i+len<=n;i++)\n        {\n            dp[0][i][i+len]=max(dp[0][i][i+len-1],dp[0][i+1][i+len]);\n            if(s[i]==s[i+len])\n                dp[0][i][i+len]=max(dp[0][i][i+len],dp[0][i+1][i+len-1]+2);\n        }\n    }\n    for(int x=1;x<=n;x++)\n    {\n        for(int i=1;i<=n;i++)\n        {\n            dp[x][i][i]=1;\n            if(i!=n) dp[x][i][i+1]=2;\n        }\n        for(int len=2;len<n;len++)\n        {\n            for(int i=1;i+len<=n;i++)\n            {\n                if(s[i]==s[i+len])\n                    dp[x][i][i+len]=dp[x][i+1][i+len-1]+2;\n                dp[x][i][i+len]=max(max(dp[x][i+1][i+len],dp[x][i][i+len-1]),max(dp[x][i][i+len],dp[x-1][i+1][i+len-1]+2));\n            }\n        }\n    }\n    cout<<dp[k][1][n]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<stack>\n#include<set>\n#include<unordered_set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<complex>\n#include<cmath>\n#include<iomanip>\n#include<numeric>\n#include<algorithm>\n#include<list>\n#include<functional>\n#include<cassert>\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n#define y0 y12\n#define y1 y22\n#define INF 987654321\n#define PI 3.141592653589793238462643383279502884\n#define fup(i,a,b,c) for(int (i)=(a);(i)<=(b);(i)+=(c))\n#define fdn(i,a,b,c) for(int (i)=(a);(i)>=(b);(i)-=(c))\n#define MEM0(a) memset((a),0,sizeof(a));\n#define MEM_1(a) memset((a),-1,sizeof(a));\n#define ALL(a) a.begin(),a.end()\n#define SYNC ios_base::sync_with_stdio(false);cin.tie(0)\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef double db;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> Pi;\ntypedef pair<ll, ll> Pll;\ntypedef pair<ld, ld> Pd;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<double> Vd;\ntypedef vector<Pi> VPi;\ntypedef vector<Pll> VPll;\ntypedef vector<Pd> VPd;\ntypedef tuple<int, int, int> iii;\ntypedef tuple<int,int,int,int> iiii;\ntypedef tuple<ll, ll, ll> LLL;\ntypedef vector<iii> Viii;\ntypedef vector<LLL> VLLL;\ntypedef complex<double> base;\nconst int MOD = 998244353;\nll POW(ll a, ll b, ll MMM = MOD) {ll ret=1; for(;b;b>>=1,a=(a*a)%MMM)if(b&1)ret=(ret*a)% MMM; return ret; }\nll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\nll lcm(ll a, ll b) { if (a == 0 || b == 0)return a + b; return a*(b / gcd(a, b)); }\nint dx[] = { 0,1,0,-1,1,1,-1,-1 }, dy[] = { 1,0,-1,0,1,-1,1,-1 };\nint ddx[]={2,2,-2,-2,1,1,-1,-1},ddy[]={1,-1,1,-1,2,-2,2,-2};\n\nint k,d[305][305][305];\nchar s[305];\nint go(int l,int r,int K)\n{\n\tif(K<0)return -INF;\n\tif(l==r)return 1;\n\tif(l>r)return 0;\n\tint &ret=d[l][r][K];\n\tif(~ret)return ret;\n\tret=max({go(l+1,r-1,K-(s[l]!=s[r]))+2,go(l+1,r,K),go(l,r-1,K)});\n\treturn ret;\n}\nint main(){\n\tMEM_1(d);\n\tscanf(\"%s%d\",s,&k);\n\tprintf(\"%d\",go(0,strlen(s)-1,k));\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#define p(s) cout<<(s)<<endl\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define RREP(i,n,N) for(int i=N-1;i>=n;i--)\n#define CK(n,a,b) ((a)<=(n)&&(n)<(b))\n#define F first\n#define S second\ntypedef long long ll;\nusing namespace std;\nconst ll mod = 1e9+7;\n\nstring s,t;\nint K;\nint dp[310][310];\n\nint LCS(string a,string b){\n\n    REP(i, 0, a.size()){\n        REP(j, 0, b.size()){\n            if(a[i] == b[j]) {\n                dp[i + 1][j + 1] = dp[i][j] + 1;\n            }\n            else\n                dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1]);\n        }\n    }\n    return dp[a.size()][b.size()];\n}\n\nint main() {\n    cin>>s>>K;\n    t=s;\n    reverse(t.begin(),t.end());\n    p(min<int>(s.size(),LCS(s, t)+2*K));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n#define INF 1000000000\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint dp[333][333][333];\nstring s;\nint k;\n\nint dfs(int K,int L,int R)\n{\n//\tcout << K << ' ' << L << ' ' << R << endl;\n\tif(K < 0 || L > R)return -100000000;\n\tif(dp[K][L][R] != 0)return dp[K][L][R];\n\tint ret = 0;\n\tint p = 0;\n\tif(s[L] == s[R])ret = max(ret,dfs(K,L+1,R-1)+2);\n\telse ret = max(ret,dfs(K-1,L+1,R-1)+2);\n\tret = max(ret,dfs(K,L+1,R));\n\tret = max(ret,dfs(K,L,R-1));\n\t\n\treturn dp[K][L][R] = ret;\n}\n\n\nint main()\n{\n\tcin >> s >> k;\n\t\n\tREP(K,333)REP(i,333)dp[K][i][i] = 1;\n\tREP(K,333)REP(i,332)\n\t{\n\t\tif(s[i] == s[i+1])dp[K][i][i+1] = 2;\n\t\telse dp[K][i][i+1] = 1;\n\t}\n\t\n\tcout << dfs(k,0,s.size()-1) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\n\nint D[303][303][155];\nchar S[303]; int K;\n\nint main()\n{\n\tscanf(\"%s %d\", S+1,&K);\n\tint N = 0;\n\twhile (S[N + 1]) N++;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = N; j > i; j--) {\n\t\t\tfor (int k = 0; k <= K; k++) {\n\t\t\t\tD[i][j][k] = max({ D[i][j][k], D[i - 1][j][k], D[i][j + 1][k] });\n\t\t\t\tif (S[i] == S[j]) D[i][j][k] = max(D[i][j][k], D[i - 1][j + 1][k] + 2);\n\t\t\t\telse {\n\t\t\t\t\tD[i][j][k+1] = max(D[i][j][k+1], D[i - 1][j + 1][k] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = N; j > i; j--) {\n\t\t\tfor (int k = 0; k <= K; k++) {\n\t\t\t\tint d = D[i][j][k];\n\t\t\t\tif (i + 1 < j) d++;\n\t\t\t\tans = max(ans, d);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 305;\n\nint id[MAX_N][26];\nint dp[MAX_N][MAX_N][MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    int n = len(s);\n    rep(j,26){\n        id[n][j] = n;\n    }\n    rrep(i,n){\n        int c = (s[i]-'a');\n        rep(j,26){\n            if(j == c){\n                id[i][j] = i;\n            }else{\n                id[i][j] = id[i+1][j];\n            }\n        }\n    }\n    int K;\n    cin >> K;\n    rep(i,n){\n        rep(j,K+1){\n            dp[i][i+1][j] = 1;\n        }\n    }\n    srep(l,1,n){\n        rep(i,n-l){\n            int j = i+l;\n            rep(k,K+1){\n                if(k) cmx(dp[i][j+1][k],dp[i][j+1][k-1]);\n                cmx(dp[i][j+1][k],dp[i][j][k]);\n                if(id[i][s[j]-'a'] < j) cmx(dp[i][j+1][k],dp[id[i][s[j]-'a']+1][j][k]+2);\n                if(k < K) cmx(dp[i][j+1][k+1],dp[i+1][j][k]+2);\n            }\n        }\n    }\n    cout << dp[0][n][K] << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC target(\"avx,sse4\")\n \n#define mms(a,n) memset(a,0,sizeof((a)[0])*(n))\n#define mmp(a,b,n) memcpy(a,b,sizeof((b)[0])*(n))\n#define lowbit(x) ((x)&-(x))\n#define pb push_back\n#define fi first\n#define se second\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define fo(i,l,r) for(register int i=l,_lim_=r;i<=_lim_;i++)\n#define fd(i,r,l) for(register int i=r,_lim_=l;i>=_lim_;i--)\n#define fos(i,l,r,d) for(register int i=l,_lim_=r;i<=r;i+=d)\n#define fol(i,l,r) for(register ll i=l,_lim_=r;i<=_lim_;i++)\n#define fdl(i,r,l) for(register ll i=r,_lim_=l;i>=_lim_;i--)\n#define fosl(i,l,r,d) for(register ll i=l,_lim_=r;i<=r;i+=d)\n#define Clear(a) memset(a,0,sizeof(a))\n#define Copy(a,b) memcpy(a,b,sizeof(b))\n#define ALL(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define sqr(x) ((x)*(x))\n#define GCD __gcd\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ldb;\ntypedef double db;\ntypedef pair<int,int> pi;\ntypedef vector<int> VI;\ntypedef vector<VI> VII;\n\nnamespace io{\n\tconst int L=(1<<21)+1;\n\tchar ibuf[L],*iS,*iT,obuf[L],*oS=obuf,*oT=obuf+L-1,c,st[55];int f,tp;\n\t#ifdef whzzt\n\t\t#define gc()getchar()\n\t#else\n\t\t#define gc()(iS==iT?(iT=(iS=ibuf)+fread(ibuf,1,L,stdin),(iS==iT?EOF:*iS++)):*iS++)\n\t#endif\n\tinline void flush(){fwrite(obuf,1,oS-obuf,stdout);oS=obuf;}\n\tinline void putc(char x){*oS++=x;if(oS==oT)flush();}\n\ttemplate<class I>\n\tinline void gi(I&x){\n\t\tfor(f=1,c=gc();c<'0'||c>'9';c=gc())if(c=='-')f=-1;\n\t\tfor(x=0;c<='9'&&c>='0';c=gc())x=x*10+(c&15);x*=f;\n\t}\n\ttemplate<class I>\n\tinline void print(I x){\n\t\tif(!x)putc('0');if(x<0)putc('-'),x=-x;\n\t\twhile(x)st[++tp]=x%10+'0',x/=10;\n\t\twhile(tp)putc(st[tp--]);\n\t}\n\tinline void gs(char*s,int&l){\n\t\tfor(c=gc();c<'a'||c>'z';c=gc());\n\t\tfor(l=0;c<='z'&&c>='a';c=gc())s[l++]=c;\n\t}\n\tinline void ps(const char*s){\n\t\tfo(i,0,strlen(s)-1)putc(s[i]);\n\t}\n};\nusing io::putc;\nusing io::gi;\nusing io::gs;\nusing io::ps;\nusing io::print;\n\nconst int N=305,M=26;\n\nchar s[N];\nint n,k,dp[N][N][N];\nbool vi[N][N][N];\n\ninline void upd(int&x,int y){x>y?:x=y;}\nint dfs(int a,int l,int r){\n\tif(a<0)return -N;\n\tif(l>=r)return l==r;\n\tif(a*2>=r-l)return r-l+1;\n\tif(vi[a][l][r])return dp[a][l][r];\n\tvi[a][l][r]=true;\n\tint&ret=dp[a][l][r];\n\tupd(ret,dfs(a-(s[l]!=s[r]),l+1,r-1)+(l<r)+1);\n\tupd(ret,dfs(a,l+1,r));upd(ret,dfs(a,l,r-1));\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tscanf(\"%d\",&k);\n\tprintf(\"%d\\n\",dfs(k,1,n));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define pb push_back\n#define F first\n#define S second\nusing namespace std;\nconst int N = 3e2+10;\nint dp[N][N][N];\nmain(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    string s;cin>>s;\n    int k;cin>>k;\n    int n=s.length();\n    for(int i=0;i<n;i++)\n        for(int ch=0;ch<=k;ch++)\n            dp[i][i][ch]=1;\n    for(int i=0;i<n;i++)\n        for(int j=i+1;j<=n;j++)\n            for(int ch=0;ch<=k;ch++){\n                int curr=j-i;\n                if(curr!=j){\n                    if(s[curr-1]!=s[j-1]){\n                        dp[j][curr][ch]=max(dp[j-1][curr][ch],dp[j][curr+1][ch]);\n                        if(ch>0)\n                            dp[j][curr][ch]=max(2+dp[j-1][curr+1][ch-1],dp[j][curr][ch]);\n                        continue;\n                    }\n                    else\n                        dp[j][curr][ch]=2+dp[j-1][curr+1][ch];\n                }\n            }\n    cout<<dp[n][1][k];\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define mod 1000000007LL\n#define eps 1e-13\n// #define PI 3.141592653589793238L\n#define INF 1000000011\n#define INFLL 1000000000000000011LL\n#define vi vector<int>\n#define vll vector<long long>\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define pil pair<int, long long>\n#define pli pair<long long, int>\n#define mp make_pair\n#define F first\n#define S second\n#define pb push_back\n#define fo(i,a,n) for(i = (a); i < (n); i++)\n#define gtl(x) getline(cin, (x))\n#define flsh fflush(stdout)\n#define sws ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)\n#define gcd __gcd\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)((a).size())\n#define io_file freopen(\"D:/Coding Problems/Contest/input_file.in\", \"r\", stdin); freopen(\"D:/Coding Problems/Contest/output_file.out\", \"w\", stdout)\n\nll modx(ll Base, ll exponent)\n{\n\tll ans = 1;\n\tif(Base == 1)\n\t\treturn Base;\n\twhile(exponent)\n\t{\n\t\tif(exponent & 1)\n\t\t\tans = (ans * Base)%mod;\n\t\tBase = (Base * Base)%mod;\n\t\texponent = exponent >> 1;\n\t}\n\treturn ans;\n}\n\nll inmodx(ll num)\n{\n\treturn (modx(num, mod-2LL));\n}\n\nbool cmp(pair < pii, int > a, pair < pii, int > b)//true for a before b\n{\n\tif(a.F.F/300 < b.F.F/300)\n\t\treturn 1;\n\tif(a.F.F/300 > b.F.F/300)\n\t\treturn 0;\n\tif(a.F.S < b.F.S)\n\t\treturn 1;\n\tif(a.F.S > b.F.S)\n\t\treturn 0;\n\tif(a.F <= b.F)\n\t\treturn 1;\n\treturn 0;\n}\n\nconst int N = (3e2) + 9;\nconst int M = (N<<2) + 9;\nconst int LOGN = ((int)log2(N)) + 3;\nconst int LOGM = ((int)log2(M)) + 3;\nconst int BUCK = 2*550;\nconst int SQRT = BUCK+9;\n\nint dp[N][N][N];\nstring s;\nint n, K;\n\nvoid solve()\n{\n\tint i, j, k, ans = 0;\n\tcin >> s;\n\tcin >> K;\n\tn = s.length();\n\tfo(i,1,n+1)\n\t\tfo(j,1,n-i+1+1)\n\t\t\tfo(k,0,K+1)\n\t\t\t{\n\t\t\t\tif(s[i-1] == s[n-j])\n\t\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k] + ((i+j < n) ? 2 : 1));\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k]);\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k]);\n\t\t\t\tif(k > 0)\n\t\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k-1] + ((i+j < n) ? 2 : 1));\n\t\t\t\tans = max(ans, dp[i][j][k]);\n\t\t\t}\n\tcout << ans << '\\n';\n\treturn;\n}\n\nint main()\n{\n\tsws;\n\tclock_t clk;\n\tclk = clock();\n\t// io_file;\n\t// srand (time(NULL));\n\n\t//Code here\n\tint t = 1, cs;\n\tcout << fixed << setprecision(9);\n\t// cin >> t;\n\tfo(cs,1,t+1)\n\t{\n\t\t// cout << \"Case #\" << cs << \": \";\n\t\tsolve();\n\t}\n\t// Code ends here\n\n\tclk = clock() - clk;\n\tcerr << fixed << setprecision(6) << \"Time: \" << ((double)clk)/CLOCKS_PER_SEC << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define enum(i,x,y) for(int i=(x);i<=(y);++i)\n#define try(i,x,y) for(int i=(x);i>=(y);--i)\ntemplate <typename TYPE> inline void chkmax(TYPE &x,TYPE y){x<y?x=y:0;}\ntemplate <typename TYPE> inline void chkmin(TYPE &x,TYPE y){y<x?x=y:0;}\ntemplate <typename TYPE> void readint(TYPE &x)\n{\n    x=0;int f=1;char c;\n    for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;\n    for(;isdigit(c);c=getchar())x=x*10+c-'0';\n    x*=f;\n}\nconst int MAXN=305;\n\nint n,m;\nchar s[MAXN];\nint f[MAXN][MAXN][MAXN];\nint main()\n{\n\tscanf(\"%s\",s+1);readint(m);n=strlen(s+1);\n\tenum(i,1,n)\n\t\tenum(j,1,n)\n\t\t\tenum(k,0,m)\n\t\t\t{\n\t\t\t\tf[i][j][k]=max(f[i][j-1][k],f[i-1][j][k]);\n\t\t\t\tchkmax(f[i][j][k],f[i-1][j-1][k]+(s[i]==s[n-j+1]));\n\t\t\t\tif(k)chkmax(f[i][j][k],f[i-1][j-1][k-1]+1);\n\t\t\t}\n\tint ans=0;\n\tenum(i,1,n)\n\t\tchkmax(ans,f[i][n-i+1][m]);\n\tprintf(\"%d\\n\",ans*2-1);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\n#include <map>\n#include <string.h>\n#include <math.h>\n#include <stdio.h>\n#include <deque>\n//#include \"D:\\C++\\test_lib_projects\\testlib.h\"\nusing namespace std;\n#define ll long long\n#define pii pair<int,int>\n\nbool debug=true;\n/*\n   Write In New Computer\n    By XiaoGeNintendo\n\t     gwq2017\n\tType:\n*/\n\n/*\nvoid fo(int id){\n\tfreopen((toString(id)+\".txt\").c_str(),\"w\",stdout);\n}\n*/\nstring s;\nint k;\n\n/*\nThe biggest answer in [l,r] with k left\n*/\n\nint d[305][305][305];\nbool f[305][305][305];\n\nint dp(int l,int r,int k){\n\t//cout<<l<<\" \"<<r<<\" \"<<k<<endl;\n\tint retv;\n\tif(k<0){\n\t\treturn 0;\n\t}else{\n\t\tif(f[l][r][k]) return d[l][r][k];\n\t\t\n\t\tif(l==r){\n\t\t\tretv=1;\n\t\t}else{\n\t\t\tif(l>r){\n\t\t\t\tretv=0;\n\t\t\t}else{\n\t\t\t\tif(s[l]==s[r]){\n\t\t\t\t\t//Middle\n\t\t\t\t\tint ans1=dp(l+1,r-1,k)+2;\n\t\t\t\t\t//Left\n\t\t\t\t\tint ans2=dp(l,r-1,k)+1;\n\t\t\t\t\t//Right\n\t\t\t\t\tint ans3=dp(l+1,r,k)+1;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tretv=max(ans1,max(ans2,ans3));\n\t\t\t\t}else{\n//\t\t\t\t\t//Change left\n//\t\t\t\t\tint ans1=dp(l+1,r,k-1)+1;\n//\t\t\t\t\t//Change right\n//\t\t\t\t\tint ans2=dp(l,r-1,k-1)+1;\n//\t\t\t\t\t//Change middle\n//\t\t\t\t\tint ans5=dp(l+1,r-1,k-1)+2;\n//\t\t\t\t\t//Don't change,use left\n//\t\t\t\t\tint ans3=dp(l,r-1,k);\n//\t\t\t\t\t//Don't change,use right\n//\t\t\t\t\tint ans4=dp(l+1,r,k);\n//\t\t\t\t\t//Don't change,use middle\n//\t\t\t\t\tint ans6=dp(l+1,r-1,k);\n\t\t\t\t\tint ans1=dp(l+1,r-1,k-1)+2;\n\t\t\t\t\tint ans2=dp(l+1,r-1,k);\n\t\t\t\t\tint ans3,ans4,ans5,ans6;\n\t\t\t\t\tans3=ans4=ans5=ans6=-1;\n\t\t\t\t\tretv=max(ans1,max(ans2,max(ans3,max(ans4,max(ans5,ans6)))));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tf[l][r][k]=true;\n\td[l][r][k]=retv;\n\treturn retv;\n}\n\nint main(int argc,char* argv[]){\n\tcin>>s>>k;\n\tcout<<dp(0,s.size()-1,k);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n ____ ____ ____ ____ ____\n||a |||t |||o |||d |||o ||\n||__|||__|||__|||__|||__||\n|/__\\|/__\\|/__\\|/__\\|/__\\|\n\n**/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N_MAX = 302;\n\nint n;\n\nstring s;\n\nint k;\n\nint dp[N_MAX][N_MAX][N_MAX];\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> s;\n    n = s.size();\n    s = \" \" + s;\n    cin >> k;\n    for(int l = 0; l <= n; l++)\n        for(int r = n + 1; r >= l; r--)\n            if(l >= 1 || r <= n)\n            {\n                for(int c = 0; c <= k; c++)\n                {\n                    if(l >= 1)\n                        dp[l][r][c] = max(dp[l][r][c], dp[l - 1][r][c]);\n                    if(r <= n)\n                        dp[l][r][c] = max(dp[l][r][c], dp[l][r + 1][c]);\n                    if(c >= 1)\n                        dp[l][r][c] = max(dp[l][r][c], dp[l][r][c - 1]);\n                    if(l >= 1 && r <= n)\n                    {\n                        if(s[l] == s[r])\n                            dp[l][r][c] = max(dp[l][r][c], dp[l - 1][r + 1][c] + 1 + (l < r));\n                        else if(c >= 1)\n                            dp[l][r][c] = max(dp[l][r][c], dp[l - 1][r + 1][c - 1] + 1 + (l < r));\n                    }\n                }\n            }\n    int ans = 0;\n    for(int i = 1; i <= n; i++)\n        ans = max(ans, dp[i][i][k]);\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=305;\nint f[N][N][N],n,K;char s[N];\nint main(){\n  scanf(\"%s%d\",s+1,&K);n=strlen(s+1);\n  for(int i=1;i<=n;i++)f[i][i][0]=1;\n  for(int len=2;len<=n;len++){\n\t  for(int i=1;i+len-1<=n;i++){\n\t\t  int j=i+len-1;\n\t\t  for(int k=0;k<=K;k++){\n\t\t\t  f[i][j][k]=max(f[i+1][j][k],f[i][j-1][k]);\n\t\t\t  if(len>2){\n\t\t\t\t  if(s[i]==s[j])f[i][j][k]=max(f[i][j][k],f[i+1][j-1][k]+2);\n\t\t\t\t  if(k)f[i][j][k]=max(f[i][j][k],f[i+1][j-1][k-1]+2);\n\t\t\t  }\n\t\t  }\n\t  }\n  }\n  cout<<f[1][n][K]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=305;\nint f[N][N][N],n,K;char s[N];\nint main(){\n  scanf(\"%s%d\",s+1,&K);n=strlen(s+1);\n  for(int i=1;i<=n;i++)\n      for(int k=0;k<=K;k++)f[i][i][k]=1;\n  for(int len=2;len<=n;len++){\n      for(int i=1;i+len-1<=n;i++){\n          int j=i+len-1;\n          for(int k=0;k<=K;k++){\n              f[i][j][k]=max(f[i+1][j][k],f[i][j-1][k]);\n              if(s[i]==s[j])f[i][j][k]=max(f[i][j][k],f[i+1][j-1][k]+2);\n              if(k)f[i][j][k]=max(f[i][j][k],f[i+1][j-1][k-1]+2);\n          }\n      }\n  }\n  cout<<f[1][n][K]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define st first\n#define nd second\n#define mp make_pair\n#define pb push_back\n#define N 305\nusing namespace std;\n\nint n, k, dp[N][N][N];\nchar s[N];\n\nint f(int bas, int son, int k){\n\tif(bas == son)\n\t\treturn 1;\n\tif(bas > son)\n\t\treturn 0;\n\tint &r = dp[bas][son][k];\n\tif(r != -1)\n\t\treturn r;\n\tif(s[bas] == s[son])\n\t\tr = f(bas + 1, son - 1, k) + 2;\n\tif(k)\n\t\tr = max(r, f(bas + 1, son - 1, k - 1) + 2);\n\tr = max(r, f(bas + 1, son - 1, k));\n\tr = max(r, f(bas, son - 1, k));\n\tr = max(r, f(bas + 1, son, k));\n\treturn r;\n}\n\nint main() {\n\t// freopen(\"in.txt\", \"r\", stdin);\n\t// freopen(\"out.txt\", \"w\", stdout);\n\tmemset(dp, -1, sizeof dp);\n\tscanf(\"%s %d\",s + 1, &k);\n\tn = strlen(s + 1);\n\tprintf(\"%d\\n\", f(1, n, k));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nchar a[500];\nchar b[500];\nint f[305][305];\nint main()\n{\n    scanf(\"%s\",a);\n    int n=strlen(a);\n    int k;\n    scanf(\"%d\",&k);\n    for (int i=0;i<n;i++)\n        b[n-1-i]=a[i];\n    for (int i=0;i<n;i++)\n      for (int j=0;j<n;j++)\n            f[i][j]=0;\n    for (int i=0;i<n;i++)\n        for (int j=0;j<n;j++)\n    {\n        if (a[i]==b[j])\n            f[i][j]=f[i-1][j-1]+1;\n        else\n            f[i][j]=max(f[i-1][j],f[i][j-1]);\n    }\n    int anw=min(f[n-1][n-1]+2*k,n);\n    printf(\"%d\",anw);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define dro first\n#define adg second.first\n#define mog second.second\n#define ll long long\nusing namespace std;\n\nconst int N = 500001;\n\nint n,r,pos,l,x,U,D,S;\n \nlong long ans;\nint K;\n\nstring s;\n\nint fix[100],fix1[100],A[100],B[100];\n\nint dp[310][310][310];\n\nint main(){\n    \n    cin>>s;\n    \n    n=s.size();\n    \n    cin>>K;\n    \n    for(int j=0;j<n;j++)\n    for(int l=0;l+j<n;l++)\n    for(int k=0;k<=min(l+j-l+1,K);k++){\n        \n        int r = l+j;\n        \n        if(l==r){\n            dp[l][r][0] = 1;\n            continue;\n            //dp[l][r][1] = 1\n        }\n\n        if(l+1==r){\n            if(k==0){\n                dp[l][r][k] = 1;\n                if(s[l] == s[r]) dp[l][r][k] = 2;\n            } else {\n                dp[l][r][k] = 2;\n            }\n            \n            continue;\n        }\n        \n        dp[l][r][k] = max( dp[l+1][r][k], dp[l][r-1][k]);\n        //cout<<dp[l+1][r][k]<<\" \"<<l<<\" \"<<r<<\" \"<<k<<endl;\n        //cout<<dp[l][r-1][k]<<\" \"<<l<<\" \"<<r<<\" \"<<k<<endl;\n        if(s[l]==s[r])\n            dp[l][r][k] = max( dp[l][r][k], dp[l+1][r-1][k] + 2);\n        else {\n            if(k-1>=0)\n            dp[l][r][k] = max( dp[l][r][k], dp[l+1][r-1][k-1] + 2);\n        }\n\n        //cout<<dp[l][r][k]<<\" \"<<l<<\" \"<<r<<\" \"<<k<<endl;\n    }\n    \n    cout<<dp[0][n-1][K]<<endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n#define pb push_back\n#define mp make_pair\nint dp[301][301][601];\nint main()\n{\n    int i,j;\n    string a;\n    int k;\n    cin>>a;\n    cin>>k;\n    int n=a.size();\n    if(k>=(n/2))\n            {cout<<n<<endl;\n             return 0;\n            }\n            int z=1;\n    for(z=0;z<=2*k;z++)\n  {\n\n    for(i=1;i<=n;i++)\n    {\n        for(j=n;j>=1;j--)\n        {\n          int o=n-j+1;\n\n              if(i!=j)\n              {    if(z!=0)\n                      dp[i][o][z]=max(dp[i][o][z],dp[i][o][z-1]);\n                  if(a[i-1]==a[j-1])\n                     dp[i][o][z]=max(dp[i][o][z],1+dp[i-1][o-1][z]);\n                  else\n                  {\n                      if(z!=0)\n                      dp[i][o][z]=max(dp[i][o][z],dp[i-1][o-1][z-1]+1);\n\n                      dp[i][o][z]=max(dp[i][o][z],max(dp[i-1][o][z],dp[i][o-1][z]));\n\n                  }\n\n\n              }\n              else{\n                 if(z!=0)\n                      dp[i][o][z]=dp[i][o][z-1];\n                 dp[i][o][z]=max(dp[i][o][z],1+dp[i-1][o-1][z]);\n\n\n                }\n\n\n        }\n\n\n\n\n    }\n\n\n\n\n\n  }\n  int ans=0;\n\n        ans=dp[n][n][2*k];\n\n\n    cout<<ans<<endl;\nreturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ninline int read(){\n\tchar c=getchar();while (c!='-'&&(c<'0'||c>'9'))c=getchar();\n\tint k=1,kk=0;if (c=='-')c=getchar(),k=-1;\n\twhile (c>='0'&&c<='9')kk=kk*10+c-'0',c=getchar();return kk*k;\n}using namespace std;\nvoid write(int x){if (x<0)putchar('-'),x=-x;if (x/10)write(x/10);putchar(x%10+'0');}\nvoid writeln(int x){write(x);puts(\"\");}\nint f[301][301][301],kk,ans,l;\nchar s[1000];\nsigned main(){\n\tscanf(\"%s\",s);kk=read();l=strlen(s);//f[i][j][k]为i到i+j-1最多修改k个后变成回文最少插入的个数 \n\tmemset(f,10,sizeof(f));for (int i=1;i<=l;i++)f[i][0][0]=f[i][1][0]=0; \n\tfor (int j=2;j<=l;j++)\n\t\tfor (int i=1;i+j-1<=l;i++)\n\t\t\tfor (int k=0;k<=kk;k++){\n\t\t\t\tif (k)f[i][j][k]=f[i][j][k-1];\n\t\t\t\tif (s[i-1]!=s[i+j-2]){\n\t\t\t\t\tf[i][j][k]=min(f[i][j][k],min(f[i][j-1][k],f[i+1][j-1][k])+1);//插入一发\n\t\t\t\t\tif (k)f[i][j][k]=min(f[i][j][k],f[i+1][j-2][k-1]);//修改一发 \n\t\t\t\t}else f[i][j][k]=min(f[i][j][k],f[i+1][j-2][k]);\n\t\t\t}\n\twriteln(l-f[1][l][kk]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __MINMAX_H__\n#define __MINMAX_H__\n\n/* updated: 2020-08-02 */\n\n#include <algorithm>\n#include <functional>\n\n/* \n// 最小値と最大値をビット演算の演算子オーバーロードで表記できるようにするクラス\n// 演算子 | が max, 演算子 & が min を表す\n// (扱うときはオーバーロード解決に注意)\n*/\ntemplate <class T, class Pred = std::less<T>>\nclass MinMax {\n\tT value_m = T();\n\npublic:\n\tMinMax() = default;\n\tMinMax(const T& value);\n\tMinMax(const MinMax<T, Pred>& other) = default;\n\n\tMinMax<T, Pred>& operator=(const T& value);\n\tMinMax<T, Pred>& operator=(const MinMax<T, Pred>& other) = default;\n\n\tMinMax<T, Pred>& operator|=(const T& other);\n\tMinMax<T, Pred>& operator&=(const T& other);\n\n\toperator T() const;\n};\n\ntemplate <class T, class Pred>\nMinMax<T, Pred> operator|(const MinMax<T, Pred>& a, const MinMax<T, Pred>& b);\ntemplate <class T, class Pred>\nMinMax<T, Pred> operator&(const MinMax<T, Pred>& a, const MinMax<T, Pred>& b);\ntemplate <class T, class Pred, class U>\nMinMax<T, Pred> operator|(const MinMax<T, Pred>& a, const U& b);\ntemplate <class T, class Pred, class U>\nMinMax<T, Pred> operator&(const MinMax<T, Pred>& a, const U& b);\ntemplate <class T, class Pred, class U>\nMinMax<T, Pred> operator|(const U& a, const MinMax<T, Pred>& b);\ntemplate <class T, class Pred, class U>\nMinMax<T, Pred> operator&(const U& a, const MinMax<T, Pred>& b);\n\ntemplate<class T, class Pred>\nMinMax<T, Pred>::MinMax(const T& value)\n\t: value_m(value) {\n}\n\ntemplate<class T, class Pred>\nMinMax<T, Pred>& MinMax<T, Pred>::operator=(const T& value) {\n\tvalue_m = value;\n\treturn *this;\n}\n\ntemplate<class T, class Pred>\nMinMax<T, Pred>& MinMax<T, Pred>::operator|=(const T& other) {\n\tvalue_m = std::max(value_m, other, Pred());\n\treturn *this;\n}\n\ntemplate<class T, class Pred>\nMinMax<T, Pred>& MinMax<T, Pred>::operator&=(const T& other) {\n\tvalue_m = std::min(value_m, other, Pred());\n\treturn *this;\n}\n\ntemplate<class T, class Pred>\nMinMax<T, Pred>::operator T() const {\n\treturn value_m;\n}\n\ntemplate<class T, class Pred>\nMinMax<T, Pred> operator|(const MinMax<T, Pred>& a, const MinMax<T, Pred>& b) {\n\tMinMax<T, Pred> ret(a);\n\tret |= b;\n\treturn ret;\n}\n\ntemplate<class T, class Pred>\nMinMax<T, Pred> operator&(const MinMax<T, Pred>& a, const MinMax<T, Pred>& b) {\n\tMinMax<T, Pred> ret(a);\n\tret &= b;\n\treturn ret;\n}\n\ntemplate<class T, class Pred, class U>\nMinMax<T, Pred> operator|(const MinMax<T, Pred>& a, const U& b) {\n\treturn a | MinMax<T, Pred>(b);\n}\n\ntemplate<class T, class Pred, class U>\nMinMax<T, Pred> operator&(const MinMax<T, Pred>& a, const U& b) {\n\treturn a & MinMax<T, Pred>(b);\n}\n\ntemplate<class T, class Pred, class U>\nMinMax<T, Pred> operator|(const U& a, const MinMax<T, Pred>& b) {\n\treturn MinMax<T, Pred>(a) | b;\n}\n\ntemplate<class T, class Pred, class U>\nMinMax<T, Pred> operator&(const U& a, const MinMax<T, Pred>& b) {\n\treturn MinMax<T, Pred>(a) & b;\n}\n\nusing MMInt = MinMax<int>;\nusing MMLL = MinMax<long long int>;\nusing MMDouble = MinMax<double>;\n\n#endif\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = uint32_t;\nusing LL = int64_t;\nusing ULL = uint64_t;\nusing PP = pair<LL, LL>;\ntemplate <typename T> using PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n#define REP(i, a, n) for(LL i = (a), i##_max_ = (n); i < i##_max_; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##_min_ = (a); i >= i##_min_; --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP { cin.tie(NULL); ios::sync_with_stdio(false); }\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U> istream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U> ostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N> void Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N> void Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate <class T> T Next() { T buf; cin >> buf; return buf; }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h&& j >= 0 && j < w; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"Accumulator.h\"\n#include \"Algebraic.h\"\n#include \"BinaryMatrix.h\"\n#include \"BinaryTree.h\"\n#include \"Bipartite.h\"\n#include \"BIT.h\"\n#include \"Compressor.h\"\n#include \"Decompositions.h\"\n#include \"DiscreteLog.h\"\n#include \"DynamicMod.h\"\n#include \"Exponential.h\"\n#include \"Factorization.h\"\n#include \"FFT.h\"\n#include \"FlowSolver.h\"\n#include \"Geometric2D.h\"\n#include \"Geometric2DFloat.h\"\n#include \"Geometric3D.h\"\n#include \"Geometric3DFloat.h\"\n#include \"Graph.h\"\n#include \"GraphUtil.h\"\n#include \"Interpolation.h\"\n#include \"IntMod.h\"\n#include \"KDTree.h\"\n#include \"LazySegmentTree.h\"\n#include \"LIS.h\"\n#include \"List.h\"\n#include \"Math.h\"\n#include \"MathUtil.h\"\n#include \"Matrix.h\"\n#include \"MinCostFlowSolver.h\"\n#include \"MinMax.h\"\n#include \"Numbers.h\"\n#include \"Optimize.h\"\n#include \"Permutation.h\"\n#include \"Polynomial.h\"\n#include \"Position.h\"\n#include \"Random.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"RuntimeMod.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"Sets.h\"\n#include \"Shortest.h\"\n#include \"SlidingWindow.h\"\n#include \"SpanningTree.h\"\n#include \"StringSearching.h\"\n#include \"SuffixArray.h\"\n#include \"SwitchList.h\"\n#include \"Timer.h\"\n#include \"Tree.h\"\n#include \"TreeUtil.h\"\n#include \"UnionFind.h\"\n#include \"Util.h\"\n#include \"VectorUtil.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>>(istream& ist, __int128& val) { LL tmp; ist >> tmp; val = tmp; return ist; }\nostream& operator<<(ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\nstring s;\nint l;\nMMInt dp[302][302][302];\nint main() {\n\tcin >> s >> l;\n\tint n = s.size();\n\n\tREP(i, 0, n) {\n\t\tREP(j, 0, n) {\n\t\t\tif (i + j > n) continue;\n\t\t\tREP(k, 0, l + 1) {\n\t\t\t\tint nk = k + (s[i] != s[n - 1 - j]);\n\t\t\t\tif (i < n && j < n) dp[i + 1][j + 1][nk] |= dp[i][j][k] + 2;\n\t\t\t\tif (i < n) dp[i + 1][j][k] |= dp[i][j][k];\n\t\t\t\tif (j < n) dp[i][j + 1][k] |= dp[i][j][k];\n\t\t\t}\n\t\t}\n\t}\n\n\tMMInt mx = 0;\n\tREP(i, 0, n) {\n\t\tREP(j, 0, n) {\n\t\t\tif (i + j > n) continue;\n\t\t\tREP(k, 0, l + 1) {\n\t\t\t\tmx |= dp[i][j][k] + (i + j < n);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << mx << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <array>\nusing namespace std;\nusing ULL = unsigned long long;\nusing UL = unsigned;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nstruct Problem {\n\n\tUL dp[301][301][301] = {};\n\n\tvoid Solve() {\n\t\tstring S; cin >> S;\n\t\tstring rS = S; reverse(rS.begin(), rS.end());\n\t\tUL K; cin >> K;\n\t\tUL ans = 0;\n\t\tfor (UL i = 0; i < S.size(); i++) {\n\t\t\tfor (UL j = 0; j < rS.size(); j++) {\n\t\t\t\tif ((i + 1) + (j + 1) > S.size()) continue;\n\t\t\t\tfor (UL k = 0; k <= K; k++) {\n\t\t\t\t\tauto &p = dp[i + 1][j + 1][k];\n\t\t\t\t\tp = max(p, dp[i][j + 1][k]);\n\t\t\t\t\tp = max(p, dp[i + 1][j][k]);\n\t\t\t\t\tif (S[i] == rS[j]) p = max(p, dp[i][j][k] + 1);\n\t\t\t\t\tif (k != 0) p = max(p, dp[i][j][k - 1] + 1);\n\t\t\t\t\tif ((i + 1) + (j + 1) == S.size()) ans = max(ans, p * 2);\n\t\t\t\t\tif ((i + 1) + (j + 1) == S.size() - 1) ans = max(ans, p * 2 + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor (UL k = 0; k <= K; k++) {\n\t\t\tfor (UL i = 0; i <= S.size(); i++) {\n\t\t\t\tfor (UL j = 0; j <= rS.size(); j++) {\n\t\t\t\t\tcout << dp[i][j][k] << \" \";\n\t\t\t\t} cout << endl;\n\t\t\t} cout << endl;\n\t\t}*/\n\t\tcout << ans << endl;\n\t}\n\n\n\tProblem();\n};\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\nProblem::Problem() {\n\tcout << fixed << setprecision(10);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar s[310];\nint K, f[310][310][610];\n\nint main() {\n    scanf(\"%s %d\", s + 1, &K), K <<= 1;\n    int n = strlen(s + 1);\n    memset(f, -1, sizeof(f));\n    function<int(int, int, int)> dfs = [&](int l, int r, int k) {\n        if (l > n || r < 1) return 0;\n        if (~f[l][r][k]) return f[l][r][k];\n        f[l][r][k] = max(dfs(l + 1, r, k), dfs(l, r - 1, k));\n        int t = s[l] != s[r];\n        if (k >= t) f[l][r][k] = max(f[l][r][k], dfs(l + 1, r - 1, k - t) + 1);\n        return f[l][r][k];\n    };\n    printf(\"%d\\n\", dfs(1, n, K));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n\n# define pb push_back\n# define fr first\n# define sc second\n# define mk make_pair\n\nusing namespace std;\n\nconst long long linf = 1e18 + 7;\nconst int inf = 1e9 + 7;\nconst int N = 1e6 + 5;\n\ntypedef long long ll;\n\nstring s;\nint k, dp[301][301][301], u[301][301][301];\n\nint calc(int l, int r, int k){\n      if(k < 0) return -inf;\n      if(l > r) return 0;\n      if(l == r) return 1;\n      if(u[l][r][k]) return dp[l][r][k];\n      u[l][r][k] = 1;\n      int &res = dp[l][r][k];\n      res = max(calc(l + 1, r, k), calc(l, r - 1, k));\n      if(s[l] == s[r])\n            res = max(res, calc(l + 1, r - 1, k) + 2);\n      else\n            res = max(res, calc(l + 1, r - 1, k - 1) + 2);\n      return res;\n}\n\nint main(){\n      cin >> s >> k;\n      s = ' ' + s;\n      cout << calc(1, s.size() - 1, k) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#include <functional>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<ll, ll, ll, ll> tlglglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\ntemplate <class T> using VVV = V<VV<T>>;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-12;\nvoid yesno(bool ok, string yes = \"Yes\", string no = \"No\") {\n    if (ok) {\n        cout << yes << endl;\n    } else {\n        cout << no << endl;\n    }\n}\n\nll dp[310][310][310];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string S;\n    cin >> S;\n    ll len = S.size();\n    ll K;\n    cin >> K;\n    dp[0][0][0] = 0;\n    REP(i, 0, len) {\n        REP(k, 0, K + 1) {\n            dp[i][i + 1][k] = 1;\n        }\n    }\n    REP(j, 2, len + 1) {\n        REP(i, 0, len) {\n            if (i + j > len) {\n                continue;\n            }\n            REP(k, 0, K + 1) {\n                dp[i][i + j][k] = max(dp[i][i + j - 1][k], dp[i + 1][i + j][k]);\n                if (k > 0) {\n                    dp[i][i + j][k] = max(dp[i][i + j][k], dp[i + 1][i + j - 1][k - 1] + 2);\n                }\n                if (S[i] == S[i + j - 1]) {\n                    dp[i][i + j][k] = max(dp[i][i + j][k], dp[i + 1][i + j - 1][k] + 2);\n                }\n            }\n        }\n    }\n    // REP(i, 0, len + 1) {\n    //     REP(j, 0, len + 1) {\n    //         REP(k, 0, K + 1) {\n    //             cout << dp[i][j][k] << \" \";\n    //         }\n    //         cout << \"aaa \";\n    //     }\n    //     cout << endl;\n    // }\n    ll ans = 0;\n    REP(i, 0, K + 1) {\n        ans = max(ans, dp[0][len][i]);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <stack>\nusing namespace std;\nconst int maxn=300+5;\nint dp[maxn][maxn][maxn];\nchar s[maxn];\nint k;\nint main(){\n    scanf(\"%s%d\",s+1,&k);\n    int n=strlen(s+1);\n    for(int i=1;i<=n;i++) dp[i][i][0]=1;\n    for(int i=1;i<=n-1;i++){\n        if(s[i]!=s[i+1]) dp[i][i+1][1]=2, dp[i][i+1][0]=1;\n        else dp[i][i+1][0]=2;\n    }\n    for(int i=n-2;i>=1;i--){\n        for(int j=i+2;j<=n;j++){\n            for(int w=0;w<=k;w++){\n                if(w>=1)dp[i][j][w]=dp[i][j][w-1];\n                if(s[i]==s[j]) dp[i][j][w]=max(dp[i][j][w], dp[i+1][j-1][w]+2);\n                else if(w>=1) dp[i][j][w]=max(dp[i][j][w], dp[i+1][j-1][w-1]+2);\n                dp[i][j][w]=max(dp[i][j][w], max(dp[i+1][j][w], dp[i][j-1][w]));\n             }\n        }\n    }\n    printf(\"%d\\n\", dp[1][n][k]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define pll pair <ll , ll>\n\n#define pb push_back\n#define pf push_front\n#define pob pop_back\n#define pof pop_front\n#define mp make_pair\n\n#define X first\n#define Y second\n\n#define LB(x) ((x) & -(x))\n#define BIT(a , b) (((a)>>(b)) & 1)\n\n#define ll int\n\nconst ll MAXN=3e2+10;\n\nll dp[MAXN][MAXN][MAXN];\n\nint main()\n{\n\tios_base :: sync_with_stdio(false);\n\tcin.tie(0);\n\n\tstring s;\n\tcin>>s;\n\n\tll n=(ll)(s.size());\n\n\tll k;\n\tcin>>k;\n\n\tfor(ll i=0;i<n;i++)\n    {\n        for(ll j=0;j<=k;j++)\n        {\n            dp[i][i][j]=1;\n        }\n    }\n\n\tfor(ll i=1;i<n;i++)\n    {\n        for(ll j=0;j+i<n;j++)\n        {\n            ll w=j+i;\n\n            for(ll u=0;u<=k;u++)\n            {\n                if (s[j]==s[w])\n                {\n                    dp[j][w][u]=dp[j+1][w-1][u]+2;\n                }\n                else\n                {\n                    dp[j][w][u]=max(max(dp[j+1][w][u] , dp[j][w-1][u]) , (u>0 ? dp[j+1][w-1][u-1]+2 : 0));\n                }\n            }\n        }\n    }\n\n    cout<<dp[0][n-1][k];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1e18;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"YES\");}else{puts(\"NO\");}\nconst int MX = 305;\n\nint dp[MX][MX][MX];\n\nint main() {\n  string s;\n  cin>>s;\n  int n = sz(s);\n  int m;\n  scanf(\"%d\",&m);\n  string t = s; reverse(rng(t));\n  int mx = n-1;\n  int ans = 0;\n  rep(i,n+1)rep(j,n+1)rep(k,m+1) {\n    maxs(ans, dp[i][j][k]);\n    if (i+j > mx) continue;\n    maxs(dp[i+1][j][k], dp[i][j][k]);\n    maxs(dp[i][j+1][k], dp[i][j][k]);\n    int x = (i+j == mx)?1:2;\n    if (s[i] == t[j]) {\n      maxs(dp[i+1][j+1][k], dp[i][j][k]+x);\n    } else {\n      maxs(dp[i+1][j+1][k+1], dp[i][j][k]+x);\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint main() {\n    std::cout << \"0\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define reps(i,x,n) for(int i=x; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n#define X first\n#define Y second\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\nconst ll INF = 1e9+7;\n\n\nint dp[305][305][305];\nint main(){\n\t//ios_base::sync_with_stdio(false);\n\tint N, K;\n\tstring S;\n\n\tcin >> S >> K;\n\tN = S.length();\n\n\trep(k,K+1) rep(d,N) rep(l,N) if( l+d < N ){\n\t\tint inner = ( l+d >= 0 ? dp[l+1][l+d][k] : 0 );\n\t\tif( S[l] == S[l+d] ){\n\t\t\tchmax(dp[l][l+d+1][k], inner + 1 + (d>0));\n\t\t}else{\n\t\t\tchmax(dp[l][l+d+1][k+1], inner + 2);\n\t\t}\n\t\tchmax(dp[l+1][l+d+1][k], inner);\n\t\tchmax(dp[l][l+d][k], inner);\n\t}\n\t// rep(k,K+1){\n\t// \tcout << \"k = \" << k << endl;\n\t// \trep(l,N){\n\t// \t\trep(r,N+1) cout << dp[l][r][k] << \" \";\n\t// \t\tcout << endl;\n\t// \t}\n\t// }\n\n\tint ans = 0;\n\trep(k,K+1) chmax(ans, dp[0][N][k]);\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 333;\nstring z,z2;\nint n,k;\nint dp[MAX][MAX][MAX];\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> z >> k;\n  n = SZ(z);\n  z2 = z;\n  reverse(ALL(z));\n  R(i,n+1)R(j,n+1)R(kk,k+1){\n    if(i < n && j < n && z[i] == z2[j]){\n      maxi(dp[i+1][j+1][kk], dp[i][j][kk] + 1);\n    }\n    maxi(dp[i+1][j+1][kk+1], dp[i][j][kk] + 1);\n    maxi(dp[i+1][j][kk], dp[i][j][kk]);\n    maxi(dp[i][j+1][kk], dp[i][j][kk]);\n  }\n  int res = 0;\n  debug(dp[4][4][1]);\n  R(i,n){\n    maxi(res,1 + dp[i][n-i-1][k] * 2);\n  }\n  cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(x) cerr<<#x<<'='<<x<<endl\n#define set0(x) memset(x,0,sizeof(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\ntemplate<typename T> void read(T &x){\n\tx = 0;char ch = getchar();ll f = 1;\n\twhile(!isdigit(ch)){if(ch == '-')f*=-1;ch=getchar();}\n\twhile(isdigit(ch)){x = x*10+ch-48;ch=getchar();}x*=f;\n}\n\nchar str[305];\nint dp[305][305][305];\nvoid upd(int &a,int b){\n\ta =max(a,b);\n}\nint main() {\n\tcin>>(str+1);\n\tint n = strlen(str+1);\n\tint lim;\n\tcin>>lim;\n\tint ans = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=n;j>=1;j--){\n\t\t\tfor(int k=0;k<=lim;k++){\n\t\t\t\tif(i == j+1)ans = max(ans,dp[i][j][k]*2);\n\t\t\t\tif(i-1 == j+1)ans = max(ans,dp[i][j][k]*2-1);\n\t\t\t\tupd(dp[i+1][j][k],dp[i][j][k]);\n\t\t\t\tupd(dp[i][j-1][k],dp[i][j][k]);\n\t\t\t\tif(str[i] == str[j]){\n\t\t\t\t\tupd(dp[i+1][j-1][k],dp[i][j][k]+1);\n\t\t\t\t}else{\n\t\t\t\t\tupd(dp[i+1][j-1][k+1],dp[i][j][k]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\nusing namespace std;\n\nint lcs(string &s, int i, int j, int n, int k) {\n    int dp[i+1][n-j+1];\n    memset(dp, 0, sizeof dp);\n    for (int x = 1; x <= i; x++) {\n        for (int y = 1; y <= n-j; y++) {\n            char a = s[x-1], b = s[n-y];\n            if (a == b) dp[x][y] = dp[x-1][y-1] + 1;\n            else dp[x][y] = max(dp[x-1][y], dp[x][y-1]);\n        }\n    }\n    int len = dp[i][n-j];\n    return min({len + k, i, n-j});\n}\n\nint main() {\n    string s; cin >> s;\n    int k; cin >> k;\n    int n = s.size();\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        ans = max(ans, 1 + 2 * lcs(s, i, i+1, n, k));\n        ans = max(ans, 2 * lcs(s, i, i, n, k));\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=305;\nstring s;\nint dp[305][305][305],K;\nint dfs(int l,int r,int x)\n{\n    if(r<l)return 0;\n    if(l==r)return 1;\n    if(dp[l][r][x]!=-1)return dp[l][r][x];//记忆化思想，减少搜索次数\n    int t=max(dfs(l+1,r,x),dfs(l,r-1,x));//向左或右扩展一个\n    if(s[l]==s[r])t=max(t,dfs(l+1,r-1,x)+2);//相等，进行扩展\n    else if(x)t=max(t,dfs(l+1,r-1,x-1)+2);//改变一个字符，向内扩展\n    return dp[l][r][x]=t;\n}\nint main()\n{\n    cin>>s>>K;\n    memset(dp,-1,sizeof(dp));\n    cout<<dfs(0,s.size()-1,K)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma warning(disable : 4996)\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<math.h>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<cstring>\n#include<cstdio>\n#include<functional>\n#include<bitset>\n#include<limits.h>\n#include<cassert>\n#include<iterator>\n#include<complex>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<time.h>\n#include<random>\n#include<array>\n\n\nusing namespace std;\n\n#define REP(i, n) for(int i = 0;i < n;++i)\n#define REPR(i, n) for(int i = n-1;i >= 0;--i)\n#define FOR(i, m, n) for(int i = m;i < n;++i)\n#define FORR(i, m, n) for(int i = m-1;i >= n;--i)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define REVERSE(v,n) reverse(v,v+n);\n#define VREVERSE(v) reverse(v.begin(), v.end())\n#define ll long long\n#define print(x) cout<<(x)<<'\\n'\n#define pe(x) cout<<(x)<<\" \"\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define lb(v,n) lower_bound(v.begin(), v.end(), (n))\n#define ub(v,n) upper_bound(v.begin(), v.end(), (n))\n#define int long long\n//#define double long double\n#define all(x) (x).begin(), (x).end()\n#define print_space(v) REP(i,v.size())cout << v[i] << ((i == v.size() - 1) ? \"\\n\" : \" \")\ntemplate<typename T1, typename T2> inline void chmin(T1 & a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1& a, T2 b) { if (a < b) a = b; }\ntypedef pair<int, int>P;\nstd::random_device rd;\nstd::mt19937 mt(rd());\nconstexpr int MOD = 1e9+7; constexpr int MAX = 200020;\nconst double pi = acos(-1); constexpr double EPS = 1e-8;\nconstexpr ll INF = 1e18;\n\nstring S; int K;\n\nint dp[303][303][303];\nint rec(int l, int r, int k) {\n\tif(dp[l][r][k])return dp[l][r][k];\n\tint res = 0;\n\tif (l == r)res = 1;\n\telse if (l + 1 == r) {\n\t\tif (S[l] == S[r] || k>0)res = 2;\n\t\telse res = 1;\n\t}\n\telse {\n\t\tchmax(res, rec(l + 1, r, k));\n\t\tchmax(res, rec(l, r - 1, k));\n\t\tif (S[l] == S[r])chmax(res, rec(l + 1, r - 1, k) + 2);\n\t\telse if (k > 0)chmax(res, rec(l + 1, r - 1, k - 1) + 2);\n\t}\n\treturn dp[l][r][k] = res;\n}\n\nvoid solve() {\n\tcin >> S >> K;\n\tint N = S.size();\n\tprint(rec(0, N-1, K));\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t//int q; cin >> q;\n\t//while (q--)\n\tsolve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,K;\nchar S[310],T[310];\nint dp[310][310][310] = {0};\nint ans = 0;\n\nint main()\n{\n    scanf(\"%s %d\",S + 1,&K);\n\n    N = strlen(S + 1);\n    for(int i = 1; i <= N; i++)T[i] = S[i];\n    reverse(T + 1,T + 1 + N);\n\n    for(int i = 0; i <= K; i++)\n    {\n        for(int j = 1; j <= N; j++)\n        {\n            for(int k = 1; k <= N; k++)\n            {\n                dp[j][k][i] = max(dp[j - 1][k][i],dp[j][k - 1][i]);\n                if(S[j] == T[k])dp[j][k][i] = max(dp[j][k][i],dp[j - 1][k - 1][i] + 1);\n                if(i != 0)dp[j][k][i] = max(dp[j][k][i],dp[j - 1][k - 1][i - 1] + 1);\n                if(j + k == N)ans = max(ans,dp[j][k][i] * 2);\n                if(j + k == N - 1)ans = max(ans,dp[j][k][i] * 2 + 1);\n            }\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nint best[310][310][310];\nint main(){\n    string s;\n    cin >> s;\n    int k;\n    cin >> k;\n    int n = s.size();\n    for(int i = n-1; i >= 0; i--){\n        for(int a = 0; a <= k; a++){\n            if(i > 0) best[i][i-1][a] = 0;\n        }\n    }\n    for(int i = n-1; i >= 0; i--){\n        for(int j = i; j < n; j++){\n            for(int a = 0; a <= k; a++){\n                best[i][j][a] = 1;\n                if(i == j) continue;\n                best[i][j][a] = max(best[i][j][a], best[i+1][j][a]);\n                best[i][j][a] = max(best[i][j][a], best[i][j-1][a]);\n                if(s[i] == s[j]){\n                    best[i][j][a] = max(best[i][j][a], 2 + best[i+1][j-1][a]);\n                } else {\n                    if(a > 0){\n                        best[i][j][a] = max(best[i][j][a], best[i+1][j-1][a-1] + 2);\n                    }\n                }\n            }\n        }\n    }\n\n\n    cout << best[0][n-1][k] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb emplace_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\n#define dupli(a) a.erase(unique(all(a)),a.end())\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vvvvi=vector<vvvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst ll INF=1001001001;\nconst ll mod=1000000007;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\nll ma;\nstring s;\nll dp[305][305][305];\nll dfs(int i,int j,int k){\n    if(i==j)return 1;\n    if(i>j)return 0;\n    if(dp[i][j][k]!=-1)return dp[i][j][k];\n    if(s[i]==s[j])chmax(dp[i][j][k],dfs(i+1,j-1,k)+2);\n    chmax(dp[i][j][k],dfs(i+1,j,k));\n    chmax(dp[i][j][k],dfs(i,j-1,k));\n    if(k!=ma)chmax(dp[i][j][k],dfs(i+1,j-1,k+1)+2);\n    return dp[i][j][k];\n}\n\nint main(){\n    cin>>s;\n    ll n=s.size();cin>>ma;\n    rep(i,n)rep(j,n)rep(t,ma+1)dp[i][j][t]=-1;\n    out(dfs(0,n-1,0));\n    //rep(i,n)rep(j,n)rep(t,ma+1)if(dp[i][j][t]!=-1)cout<<i<<' '<<j<<' '<<t<<' '<<dp[i][j][t]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N = 305;\n\nint dp[2][MAX_N][MAX_N];\nchar S[MAX_N];\n\nint main() {\n  scanf(\"%s\", S + 1);\n  int N = strlen(S + 1), K;\n  scanf(\"%d\", &K);\n\n  memset(dp, -0x3f, sizeof dp);\n\n  int o = 0, p, result = -0x3f3f3f3f;\n  dp[0][N + 1][0] = 0;\n  \n  for (int i = 1; i <= N; ++i) {\n    p = o, o ^= 1;\n    memset(dp[o], -0x3f, sizeof dp[o]);\n    dp[o][N + 1][0] = 0;\n    for (int j = N; j > i; --j)\n      for (int k = 0; k <= K; ++k) {\n\tdp[o][j][k] = max(dp[o][j + 1][k], dp[p][j + 1][k]);\n\tif (S[i] == S[j]) dp[o][j][k] = max(dp[o][j][k], dp[p][j + 1][k] + 1);\n\telse if (k > 0) dp[o][j][k] = max(dp[o][j][k], dp[p][j + 1][k - 1] + 1);\n      }\n    for (int k = 0; k <= K; ++k) {\n      result = max(result, dp[o][i + 1][k] * 2);\n      result = max(result, dp[o][i + 2][k] * 2 + 1);\n    }\n  }\n\n  printf(\"%d\\n\", result);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\nusing namespace std;\nconst int inf=1<<28;\nchar s[310];\nint n,f[310][310],g[310][310],K;\nint main()\n{\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tscanf(\"%d\",&K);\n\tmemset(f,-63,sizeof(f));\n\tfor(int i=0;i<=K;i++) f[1][i]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<i;j++)\n\t\t\tfor(int k=0;k<=K;k++) g[j][k]=f[j][k];\n\t\tfor(int j=0;j<=K;j++) g[i][j]=1;\n\t\tfor(int j=0;j<=K;j++)\n\t\t{\n\t\t\tint t1=0,t2=0;\n\t\t\tfor(int k=i-1;k>=1;k--)\n\t\t\t{\n\t\t\t\tt1=max(t1,f[k+1][j]);\n\t\t\t\tif(j!=0) t2=max(t2,f[k+1][j-1]);\n\t\t\t\tif(s[k]==s[i]) g[k][j]=max(g[k][j],t1+2);\n\t\t\t\telse if(j!=0) g[k][j]=max(g[k][j],t2+2);\n\t\t\t}\n\t\t}\n\t\tfor(int j=1;j<=i;j++) for(int k=1;k<=K;k++) g[j][k]=max(g[j][k],g[j][k-1]);\n\t\tfor(int j=i-1;j>=1;j--) for(int k=0;k<=K;k++) g[j][k]=max(g[j][k],g[j+1][k]);\n\t\tfor(int j=1;j<=i;j++) for(int k=0;k<=K;k++) f[j][k]=max(f[j][k],g[j][k]);\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++) for(int j=0;j<=K;j++) ans=max(ans,f[i][j]);\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[301][301];\nint main() {\n  string S;\n  int K;\n  cin >> S >> K;\n  vector<vector<int>> dp(S.size(), vector<int>(S.size()));\n  for(auto i = 0; i < S.size(); ++i) dp[i][i+1] = 1;\n  for(auto k = 0; k <= K; ++k) {\n    auto dup = dp;\n    for(auto w = 2; w <= S.size(); ++w) for(auto l = 0; l+w <= S.size(); ++l) {\n      auto r = l + w;\n      dp[l][r] = max({dp[l][r], dp[l+1][r], dp[l][r-1]});\n      if(k)            dp[l][r] = max(dp[l][r], 2 + dup[l+1][r-1]);\n      if(S[l]==S[r-1]) dp[l][r] = max(dp[l][r], 2 + dp[l+1][r-1]);\n    }\n  }\n  cout << dp[0][S.size()] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n\t  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n\t  for(auto &e:u) fill_v<T>(e,v...);\n}\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  \n  string s;\n  int64 K;\n  cin >> s >> K;\n  auto dp = make_v<int64>(s.size()+1, s.size()+1, K+1); // [l, r]で作れるアの最大値\n  REP(k, K+1) {\n    REP(w, s.size()) {\n      REP(l, s.size() - w) {\n        int64 r = l + w;\n        if (l+1 <= s.size() && r-1 >= 0 && k+(s[l] != s[r]) <= K)\n          chmax(dp[l][r][k+(s[l] != s[r])], dp[l+1][r-1][k] + (l == r ? 1 : 2));\n        if (l+1 <= s.size())\n          chmax(dp[l][r][k], dp[l+1][r][k]);\n        if (r-1 >= 0)\n          chmax(dp[l][r][k], dp[l][r-1][k]);\n      }\n    }\n  }\n  int64 res = 0;\n  REP(i, s.size()) {\n    REP(j, s.size()) {\n      REP(k, K+1) {\n        chmax(res, dp[i][j][k]);\n      }\n    }\n  }\n  cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <fstream>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n//ifstream cin(\"x.in\"); ofstream cout(\"x.out\");\n\nconst int nmax = 300 + 5;\n\nstring s;\nint d[nmax + 1][nmax + 1][nmax + 1];\n\nint main() {\n    int q;\n    cin >> s >> q;\n\n    int n = (int)s.size();\n    s = '#' + s;\n\n    int ans = 0;\n\n    for (int i = 1; i <= n; ++ i) {\n        for (int j = n; j > i; -- j) {\n            for (int k = 0; k <= q; ++ k) {\n                d[ i ][ j ][ k ] = max(d[i - 1][ j ][ k ], d[ i ][j + 1][ k ]);\n\n                if (k - 1 >= 0)\n                    d[ i ][ j ][ k ] = max(d[ i ][ j ][ k ], d[ i ][ j ][k - 1]);\n\n                if (s[ i ] == s[ j ])\n                    d[ i ][ j ][ k ] = max(d[ i ][ j ][ k ], d[i - 1][j + 1][ k ] + 2);\n                else if (k > 0)\n                    d[ i ][ j ][ k ] = max(d[ i ][ j ][ k ], d[i - 1][j + 1][k - 1] + 2);\n            }\n\n            ans = max(ans, d[ i ][i + 1][ q ]);\n            ans = max(ans, d[ i ][i + 2][ q ] + 1);\n        }\n    }\n\n    if (n == 1)\n        ans = 1;\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-8\n#define pi 3.14159265358979\n#define LL long long\n#define MP make_pair\n#define PH push\n#define PB push_back\n#define PII pair<int,int>\n#define VI vector<int>\n#define X first\n#define Y second\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\n#define sqr(x) ((x)*(x))\n#define CL(a) memset(a,0,sizeof a)\n#define fr(i,n) for(int i=1;i<=n;i++)\n#define FR(i,S,n) for(int i=S;i<=n;i++)\n#define dr(i,n) for(int i=n;i;i--)\n#define DR(i,n,S) for(int i=n;i>=S;i--)\n#define SZ(x) ((int)(x).size())\n#define rd(x) scanf(\"%d\",&x)\n#define pr(x) printf(\"%d\",x)\nconst int N=1111;\nconst int M=100000007;\nLL Pw(LL a,LL b,LL p){LL v=1;for(;b;b>>=1,a=a*a%p)if(b&1)v=v*a%p;return v;}\nusing namespace std;\nint n,i,j,k,f[N][N];char s[N];\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);rd(k);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)if(s[i]==s[n-j+1])\n\t\t\tf[i][j]=f[i-1][j-1]+1;\n\t\t\telse f[i][j]=max(f[i-1][j],f[i][j-1]);\n\tprintf(\"%d\",min(f[n][n]+k*2,n));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n    for(T& x: vec) {is >> x;} return is;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll k;\n    string s;\n    cin >> s >> k;\n    const ll n = s.size();\n\n    auto dp = make_v<ll>(n, n, k+1);\n    REP(i, n) dp[i][i][0] = 1;\n    REP(l, n-1) {\n        ll r = l+1;\n        if(s[l]==s[r]) dp[l][r][0] = 2;\n        else dp[l][r][0] = 1, dp[l][r][1] = 2;\n    }\n    REP(i, k+1) {\n        FOR(w, 3, n+1) {\n            REP(l, n-w+1) {\n                ll r = l+w-1;\n                if(s[l]!=s[r]) {\n                    if(i) dp[l][r][i] = max(dp[l][r][i-1], dp[l+1][r-1][i-1]+2);\n                    dp[l][r][i] = max({dp[l][r][i], dp[l+1][r][i], dp[l][r-1][i]});\n                } else if(s[l]==s[r]) {\n                    dp[l][r][i] = dp[l+1][r-1][i] + 2;\n                    if(i) chmax(dp[l][r][i], dp[l][r][i-1]);\n                }\n            }\n        }\n    }\n\n    // REP(i, n) {\n    //     FOR(j, i, n) {\n    //         cout << dp[i][j][0] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n\n    cout << dp[0][n-1][k] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n//\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//\nconstexpr ll MOD=1e9+7;\n//constexpr ll MOD=998244353;\n//constexpr ll MOD=10000000;\n//constexpr ll MOD=1e5;\nconstexpr ll MAX=3e6;\nconstexpr ll INF=(1ll<<60);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate<typename T>\nstruct Segment_tree{\n    ll N;\n    T mem;\n    vector<T> node;\n    Segment_tree(vector<T> &X,T m):mem(m){\n        ll sz=X.size();\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mem);\n        rep(i,0,sz) node[N-1+i]=X[i];\n        per(i,N-2,0){\n            node[i]=Compare(node[i*2+1],node[i*2+2]);\n        }\n    }\n    T Compare(T &A,T &B){\n        return std::max(A,B);\n    }\n    void update(ll X,T val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=Compare(node[X*2+1],node[X*2+2]);\n        }\n    }\n    T Query(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mem;\n        if(a<=l&&r<=b) return node[now];\n        auto vl=Query(a,b,now*2+1,l,(l+r)/2),vr=Query(a,b,now*2+2,(l+r)/2,r);\n        return Compare(vl,vr);\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,int a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nvoid comp(vi &A){\n    std::map<ll,ll> mem;\n    rep(i,0,A.size()) mem[A[i]]=0;\n    ll cnt=0;\n    for(auto &p:mem) p.second=cnt++;\n    rep(i,0,A.size()) A[i]=mem[A[i]];\n}\nll RLCS(string S){\n    string T=S;\n    reverse(ALL(T));\n    ll N=S.size();\n    vii dp(N+1,vi(N+1));\n    REP(i,0,N){\n        REP(j,0,N){\n            if(!i){\n                if(j) dp[i][j]=dp[i][j-1];\n            }\n            else if(!j){\n                dp[i][j]=dp[i-1][j];\n            }\n            else{\n                dp[i][j]=std::max(dp[i][j-1],dp[i-1][j]);\n                if(S[i-1]==T[j-1]) dp[i][j]=std::max(dp[i][j],dp[i-1][j-1]+1);\n            }\n        }\n    }\n    return dp[N][N];\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    string S; cin>>S;\n    ll K,N=S.size(); cin>>K;\n    string T=S; reverse(ALL(T));\n    vector<vii> dp(N/2+1,vii(N/2+1,vi(K+1,INF)));\n    dp[0][0][0]=0;\n    vii mem(26);\n    rep(i,0,N/2) mem[T[i]-'a'].pb(i+1);\n    rep(i,0,N/2){\n        REP(j,0,N/2){\n            REP(k,0,K) dp[i+1][j][k]=dp[i][j][k];\n        }\n        rep(j,0,N/2){\n            REP(k,0,K){\n                if(dp[i][j][k]==INF) continue;\n                ll X=disup(mem[S[i]-'a'],dp[i][j][k]);\n                if(X<mem[S[i]-'a'].size()){\n                    ll Y=mem[S[i]-'a'][X];\n                    dp[i+1][j+1][k]=std::min(dp[i+1][j+1][k],Y);\n                }\n                if(dp[i][j][k]<N/2&&k<K){\n                    dp[i+1][j+1][k+1]=std::min(dp[i+1][j+1][k+1],dp[i][j][k]+1);\n                }\n            }\n        }\n        REP(j,0,N/2){\n            REP(k,1,K) dp[i+1][j][k]=std::min(dp[i+1][j][k],dp[i+1][j][k-1]);\n        }\n    }\n    ll ans=0;\n    per(i,N/2,0){\n        ll cnt=0;\n        per(j,N/2,0){\n            if(dp[i][j][K]!=INF){\n                ll left=i,right=N-1-dp[i][j][K];\n                if(left<=right){\n                    string P=S.substr(left,right-left+1);\n                    ans=std::max(ans,j*2+RLCS(P));\n                }\n                else{\n                    ans=std::max(ans,j*2);\n                }\n                cnt++;\n                if(cnt==100) break;\n            }\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\ntypedef long long ll;\ninline void Fail(){printf(\"0\");exit(0);}\n\nconst int maxn=305;\nint n,lim,ans;\nchar c[maxn];\nstring s;\nint dp[maxn][maxn][maxn];\n\nint main(){\n\tscanf(\"%s%d\",c,&lim);\n\tlim*=2; \n\ts=c;n=s.size();\n\trep(i,n)rep(j,n)rep(k,lim+1){\n\t\tif(s[i]==s[n-j-1]){\n\t\t\tdp[i][j][k]=(i>=1&&j>=1?dp[i-1][j-1][k]:0)+1;\n\t\t}\n\t\telse{\n\t\t\tif(i>=1)dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k]);\n\t\t\tif(j>=1)dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k]);\n\t\t}\n\t\tif(s[i]!=s[n-j-1]){\n\t\t\tint tp=(i==n-j-1?2:1); \n\t\t\tif(k>=tp)dp[i][j][k]=max((i>=1&&j>=1?dp[i-1][j-1][k-tp]:0)+1,dp[i][j][k]);\n\t\t}\n//\t\tcout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<dp[i][j][k]<<endl;\n\t\tans=max(ans,dp[i][j][k]);\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n\n/*\nInput:\ncbcabcabc\ncbacbacbc\n1\n-----------------\nOutput:\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define eb emplace_back\n#define ll long long\n#define pii pair < int, int >\n#define fr first\n#define sc second\n#define mk make_pair\n\nconst int N = (int)3e2 + 7;\nconst int inf = (int)1e9 + 7;\n\nint dp[N][N][N];\n\nmain() {\n  string s;\n  cin >> s;\n  int n = s.size();\n  int k;\n  scanf(\"%d\", &k);\n  for (int l = n - 1; l >= 0; l--) {\n    for (int r = l; r < n; r++) {\n      for (int i = 0; i <= k; i++) {\n        if (l == r) {\n          dp[l][r][i] = 1;\n          continue;\n        }\n        if (l + 1 == r) {\n          dp[l][r][i] = (s[l] == s[r] || i > 0) ? 2 : 1;\n          continue;\n        }\n        dp[l][r][i] = max(dp[l + 1][r][i], dp[l][r - 1][i]);\n        if (s[l] == s[r]) {\n          dp[l][r][i] = max(dp[l][r][i], dp[l + 1][r - 1][i] + 2);\n        }\n        if (i > 0) {\n          dp[l][r][i] = max(dp[l][r][i], dp[l + 1][r - 1][i - 1] + 2);\n        }\n      }\n    }\n  }\n  cout << dp[0][n - 1][k];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#define fi first\n#define se second\n#define L(i,u) for (int i=head[u]; i!=0; i=nxt[i])\n#define rep(i,a,b) for (register int i=a; i<=b; i++)\n#define per(i,a,b) for (register int i=a; i>=b; i--)\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\nconst int N = 303;\nchar s[N];\nint n,k,f[N][N][N];\ninline void umax(int &a, int b) {a=a>b?a:b;}\nint main() {\n\tscanf(\"%s\",s+1); read(k); n=strlen(s+1);\n\trep(i,1,n) f[i][i][0]=1; int ans=0;\n\trep(l,-1,n-1) rep(i,1,n) {\n\t\tint j=i+l; if (j>n) break;\n\t\trep(K,0,k) {\n\t\t\tint v=f[i][j][K]; umax(ans,v);\n\t\t\tumax(f[i][j+1][K],v); umax(f[i-1][j][K],v);\n\t\t\tumax(f[i-1][j+1][K+(s[i-1]!=s[j+1])],v+2);\n\t\t}\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * File    : D.cpp\n * Author  : Kazune Takahashi\n * Created : 2018-2-24 22:16:49\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>   // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set>\n#include <random> // random_device rd; mt19937 mt(rd());\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\n// const ll M = 1000000007;\n\nint dp[400][400];\nbool used[400];\n\nint lcs(string s, string t)\n{\n  fill(&dp[0][0], &dp[0][0] + 400 * 400, 0);\n  fill(used, used + 400, false);\n  int N = s.size();\n  int M = t.size();\n  for (auto i = 0; i < N; i++)\n  {\n    for (auto j = 0; j < M; j++)\n    {\n      if (s[i] == t[j])\n      {\n        dp[i + 1][j + 1] = dp[i][j] + 1;\n      }\n      else\n      {\n        dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);\n      }\n    }\n  }\n  int x = M, y = N;\n  while (x >= 1 && y >= 1)\n  {\n    if (dp[x][y] == dp[x-1][y-1] + 1)\n    {\n      used[x - 1] = true;\n      x--;\n      y--;\n    }\n    else if (dp[x][y] == dp[x-1][y])\n    {\n      x--;\n    }\n    else\n    {\n      y--;\n    }\n  }\n  return dp[N][M];\n}\n\nstring S;\nint K;\n\nint main()\n{\n  cin >> S >> K;\n  string T = S;\n  reverse(T.begin(), T.end());\n  if (K == 0)\n  {\n    cout << lcs(S, T) << endl;\n  }\n  else\n  {\n    int N = S.size();\n    lcs(S, T);\n    for (auto i = 0; i < N; i++)\n    {\n      if (K > 0 && !used[i])\n      {\n        used[i] = true;\n        for (auto j = N-1; j > i; j--)\n        {\n          if (!used[j])\n          {\n            used[j] = true;\n            break;\n          }\n        }\n        K--;\n      }\n    }\n    for (auto i = 0; i < N; i++)\n    {\n      if (K > 0 && !used[i])\n      {\n        used[i] = true;\n        K--;\n      }\n    }\n    int cnt = 0;\n    for (auto i = 0; i < N; i++)\n    {\n      if (used[i])\n        cnt++;\n    }\n    cout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F(i,a,b) for(int i=(a);i<=(b);++i)\n#define F2(i,a,b) for(int i=(a);i<(b);++i)\n#define dF(i,a,b) for(int i=(a);i>=(b);--i)\n#define dF2(i,a,b) for(int i=(a);i>(b);--i)\n#define dF3(i,a,b) for(int i=(a)-1;i>=(b);--i)\nusing namespace std;typedef long long ll;typedef double ld;int INF=0x3f3f3f3f;int INF2=0x7fffffff;ll LNF=0x3f3f3f3f3f3f3f3f;ll LNF2=0x7fffffffffffffff;\n\nchar str[305];\nint n,K,Ans;\nint f[305][305][305];\n\nint main(){\n\tscanf(\"%s%d\",str+1,&K); n=strlen(str+1);\n\tmemset(f,0x80,sizeof(f));\n\tF(i,1,n) f[i][i][0]=1;\n\tF(Q,2,n){\n\t\tF(i,1,n-Q+1){\n\t\t\tint j=i+Q-1;\n\t\t\tF(k,0,min(K,Q)){\n\t\t\t\tf[i][j][k]=max(f[i+1][j][k],max(f[i][j-1][k],f[i+1][j-1][k-(str[i]!=str[j])]+2));\n\t\t\t}\n\t\t}\n\t}\n\tF(k,0,K) Ans=max(Ans,f[1][n][k]);\n\tprintf(\"%d\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"-O3\"\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimization (\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n#define NumberOfOnes __builtin_popcount\n#define LSOne(S) (S & (-S))\n#define ll long long\n#define two pair<int,int>\n#define twoll pair<ll,ll>\n#define four pair<two,two>\n#define pb push_back\n#define eb emplace_back\n#define mk make_pair\n#define y1 y1922\n#define INF 1000000000000000000\n#define P 1000000007\n#define lmax 1000000000\n#define nn 1000003\n#define ff first.first\n#define fs first.second\n#define sf second.first\n#define ss second.second\n#define f first\n#define s second\n#define vi vector<int>\n#define vll vector<ll>\n#define vtwo vector<two>\n#define ALL(container) (container).begin(), (container).end()\n#define sz(container) (int)(container.size())\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define mid(a,b) (a+b>>1)\n#define minN 0\n#define maxN 10000000\n#define na(x) ((x)<P?(x):(x)-P)\n#define ab(a) (-(a)<(a)?(a):-(a))\n#define FAST std::ios::sync_with_stdio(false)\n#define xRand mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#define rnd rng\n#define IT iterator\ntypedef\ntree<\n  int,// aq pair<int,int> shegidzlia\n  null_type,\n  less/*_equal*/<int>,// aqac\n  rb_tree_tag,\n  tree_order_statistics_node_update>\nordered_set;\n// '_equal' mashin ginda roca multiset gchirdeba\ntemplate<class key, class value,class cmp = std::less<key>>\nusing ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;\nordered_map<int, int> my_map;\ninline int rin(){\n\tint x=0,w=1;char ch=getchar();\n\twhile ((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n\tif (ch=='-') w=0,ch=getchar();\n\twhile (ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn w?x:-x;\n}\ninline int bin(){\n\tint x=0;char ch=getchar();\n\twhile (ch<'0'||ch>'9') ch=getchar();\n\twhile (ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn x;\n}\nint k,n,f[308][308][308];\nstring s;\nint main(){FAST;xRand;\ncin>>s;\ncin>>k;\nn=sz(s);\nfor(int i=n-1;i>=0;i--){\n\tfor(int j=i;j<n;j++){\n\t\tfor(int p=0;p<=k;p++){\n\t\t\tif(i==j){\n\t\t\t\tf[i][j][p]=1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(i+1==j){\n\t\t\t\tf[i][j][p]=(s[i]==s[j]||p>0)?2:1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tf[i][j][p]=max(f[i+1][j][p],f[i][j-1][p]);\n\t\t\tif(s[i]==s[j]){\n\t\t\t\tf[i][j][p]=max(f[i][j][p],f[i+1][j-1][p]+2);\t\n\t\t\t}\n\t\t\tif(p>0){\n\t\t\t\tf[i][j][p]=max(f[i][j][p],f[i+1][j-1][p-1]+2);\n\t\t\t}\n\t\t}\n\t}\n}\ncout<<f[0][n-1][k]<<endl;\n}\n/*\n\n                   *         *\n                  * *       * *\n                 *   *     *   *\n                *     *   *     *\n                 *   *   * *   *\n                  *   *   *   *\n                   *   * *   *\n                     *  *   *\n\t\t\t\t\t   *  *\n\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  char s[310];\n  scanf(\"%s\",s);\n  int n=strlen(s);\n  int k;\n  scanf(\"%d\",&k);\n  static int dp[310][310][310];\n  int ans=0;\n  for(int i=0;i<=n;i++){\n    for(int j=0;j<=n;j++){\n      for(int l=0;l<=k;l++){\n\tif(i==0||j==0){\n\t  dp[i][j][l]=0;\n\t  continue;\n\t}\n\tdp[i][j][l]=max(dp[i-1][j][l],dp[i][j-1][l]);\n\tif(s[i-1]==s[n-j]){\n\t  dp[i][j][l]=max(dp[i][j][l],dp[i-1][j-1][l]+1);\n\t}\n\tif(l>0){\n\t  dp[i][j][l]=max(dp[i][j][l],dp[i-1][j-1][l-1]+1);\n\t}\n\tans=max(ans,dp[i][j][l]);\n      }\n    }\n  }\n  printf(\"%d\\n\",ans+k);\n  return 0;\n}\n\n\t\n"
  },
  {
    "language": "C++",
    "code": "// Wanna Hack? GL...\n\n#include<bits/stdc++.h>\n\n#define F first\n#define S second\n#define PB push_back\n#define sz(s) int((s).size())\n#define bit(n,k) (((n)>>(k))&1)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int maxn=310,mod=1e9+7;\nconst ll inf=1e18;\n\nint dp[2][maxn][maxn];\n\nint main(){\n    ios_base::sync_with_stdio(false);cin.tie(0);\n    string s;cin>>s;\n    int k,t=0,n=sz(s);cin>>k;\n    for(int r=0;r<n;r++){\n\tdp[0][r][r]=1;\n\tfor(int l=r-1;l>=0;l--)\n\t    dp[0][l][r]=max(dp[0][l+1][r],max(dp[0][l][r-1],(s[l]==s[r]?2:0) + dp[0][l+1][r-1]));\n    }\n    for(int i=1;i<=k;i++){\n\tmemset(dp[t^1],0,sizeof dp[t^1]);\n\tfor(int r=0;r<n;r++){\n\t    dp[t^1][r][r]=1;\n\t    for(int l=r-1;l>=0;l--)\n\t\tdp[t^1][l][r]=max(dp[t^1][l+1][r],max(dp[t^1][l][r-1],s[l]==s[r]?2+dp[t^1][l+1][r-1]:2+dp[t][l+1][r-1]));\n\t}\n\tt^=1;\n    }\n    return cout<<dp[t][0][n-1]<<endl,0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define pb push_back\nusing namespace std;\nint n, X, dp[301][301][301];\nstring s;\n\nint main(){ios_base::sync_with_stdio(false);\n    cin>>s>>X;n=s.size();    \n    for (int i=0; i<n; i++)dp[0][i][i]=1;\n\tfor (int x=0; x<=X; x++)\n\t\tfor (int k=1; k<n; k++)\n\t\t\tfor (int l=0, r=k; l+k<n; l++, r=l+k)\n\t\t\t\tdp[x][l][r]=max(max(dp[x][l][r-1], dp[x][l+1][r]),\n\t\t\t\t\t\t\tdp[max(x-min(1,abs(s[l]-s[r])), 0)][l+1][r-1]+\n\t\t\t\t\t\t\t2*min(1, (min(1, x)+(1-min(1,abs(s[l]-s[r]))))));\n    cout<<dp[X][0][n-1]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int LL;\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& vec) {\n    out << \"[\";\n    for (int x : vec) out << x << \", \";\n    out << \"]\";\n    return out;\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n    #define dbg_var(x) clog << #x << \": \" << x << endl;\n#endif\n\nint dp[400][400][400];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    string S;\n    int N, K;\n    cin >> S >> K;\n    N = S.size();\n    for(int l = 0; l < N; ++l) {\n        for(int k = 0; k <= K; ++k) {\n            dp[l][l + 1][k] = 1;\n        }\n    }\n    for(int len = 2; len <= N; ++len) {\n        for(int l = 0; l + len <= N; ++l) {\n            int r = l + len;\n            int i = -1;\n            for(int j = l + 1; j < r; ++j) {\n                if(S[j] == S[l]) {\n                    i = j;\n                }\n            }\n            for(int k = 0; k <= K; ++k) {\n                dp[l][r][k] = dp[l + 1][r][k];\n                if(l + 1 <= i) {\n                    dp[l][r][k] = max(dp[l][r][k], 2 + dp[l + 1][i][k]);\n                }\n                if(k > 0) {\n                    dp[l][r][k] = max(dp[l][r][k], 2 + dp[l + 1][r - 1][k - 1]);\n                }\n            }\n        }\n    }\n    cout << dp[0][N][K] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nchar s[310];\nint l, K;\nint dp[2][310][310];\nvoid upd(int &v, int x) {\n\tif (v < x) v = x;\n}\nint main() {\n\tscanf(\"%s%d\", s, &K);\n\tfor (l = 0; s[l]; l++) ;\n\tfor (int i = 0; i < l; i++) {\n\t\tdp[0][i][i+1] = 1;\n\t}\n\tfor (int i = 2; i <= l; i++) {\n\t\tfor (int j = 0; j < l - i + 1; j++) {\n\t\t\tif (s[j] == s[j+i-1]) {\n\t\t\t\tupd(dp[0][j][j+i], dp[0][j+1][j+i-1] + 2);\n\t\t\t}\n\t\t\tupd(dp[0][j][j+i], dp[0][j+1][j+i]);\n\t\t\tupd(dp[0][j][j+i], dp[0][j][j+i-1]);\n\t\t}\n\t}\n\tint y = 0, z = 1;\n\tfor (int i = 0; i < K; i++) {\n\t\tfor (int j = 0; j <= l; j++) {\n\t\t\tfor (int k = 0; k <= l; k++) {\n\t\t\t\tdp[z][j][k] = j + 1 == k;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 2; j <= l; j++) {\n\t\t\tfor (int k = 0; k < l - j + 1; k++) {\n\t\t\t\tif (s[k] == s[k+j-1]) {\n\t\t\t\t\tupd(dp[z][k][k+j], dp[z][k+1][k+j-1] + 2);\n\t\t\t\t} else {\n\t\t\t\t\tupd(dp[z][k][k+j], dp[y][k+1][k+j-1] + 2);\n\t\t\t\t}\n\t\t\t\tupd(dp[z][k][k+j], dp[y][k][k+j]);\n\t\t\t\tupd(dp[z][k][k+j], dp[z][k+1][k+j]);\n\t\t\t\tupd(dp[z][k][k+j], dp[z][k][k+j-1]);\n\t\t\t}\n\t\t}\n\t\ty ^= 1;\n\t\tz ^= 1;\n\t}\n\tprintf(\"%d\\n\", dp[y][0][l]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n//\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//\nconstexpr ll MOD=1e9+7;\n//constexpr ll MOD=998244353;\n//constexpr ll MOD=10000000;\n//constexpr ll MOD=1e5;\nconstexpr ll MAX=3e6;\nconstexpr ll INF=(1ll<<60);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate<typename T>\nstruct Segment_tree{\n    ll N;\n    T mem;\n    vector<T> node;\n    Segment_tree(vector<T> &X,T m):mem(m){\n        ll sz=X.size();\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mem);\n        rep(i,0,sz) node[N-1+i]=X[i];\n        per(i,N-2,0){\n            node[i]=Compare(node[i*2+1],node[i*2+2]);\n        }\n    }\n    T Compare(T &A,T &B){\n        return std::max(A,B);\n    }\n    void update(ll X,T val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=Compare(node[X*2+1],node[X*2+2]);\n        }\n    }\n    T Query(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mem;\n        if(a<=l&&r<=b) return node[now];\n        auto vl=Query(a,b,now*2+1,l,(l+r)/2),vr=Query(a,b,now*2+2,(l+r)/2,r);\n        return Compare(vl,vr);\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,int a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nvoid comp(vi &A){\n    std::map<ll,ll> mem;\n    rep(i,0,A.size()) mem[A[i]]=0;\n    ll cnt=0;\n    for(auto &p:mem) p.second=cnt++;\n    rep(i,0,A.size()) A[i]=mem[A[i]];\n}\nll RLCS(string S){\n    string T=S;\n    reverse(ALL(T));\n    ll N=S.size();\n    vii dp(N+1,vi(N+1));\n    REP(i,0,N){\n        REP(j,0,N){\n            if(!i){\n                if(j) dp[i][j]=dp[i][j-1];\n            }\n            else if(!j){\n                dp[i][j]=dp[i-1][j];\n            }\n            else{\n                dp[i][j]=std::max(dp[i][j-1],dp[i-1][j]);\n                if(S[i-1]==T[j-1]) dp[i][j]=std::max(dp[i][j],dp[i-1][j-1]+1);\n            }\n        }\n    }\n    return dp[N][N];\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    string S; cin>>S;\n    ll K,N=S.size(); cin>>K;\n    string T=S; reverse(ALL(T));\n    vector<vii> dp(N/2+1,vii(N/2+1,vi(K+1,INF)));\n    REP(i,0,K) dp[0][0][i]=0;\n    vii mem(26);\n    rep(i,0,N/2) mem[T[i]-'a'].pb(i+1);\n    rep(i,0,N/2){\n        REP(j,0,N/2){\n            REP(k,0,K) dp[i+1][j][k]=dp[i][j][k];\n        }\n        rep(j,0,N/2){\n            REP(k,0,K){\n                if(dp[i][j][k]==INF) continue;\n                ll X=disup(mem[S[i]-'a'],dp[i][j][k]);\n                if(X<mem[S[i]-'a'].size()){\n                    ll Y=mem[S[i]-'a'][X];\n                    dp[i+1][j+1][k]=std::min(dp[i+1][j+1][k],Y);\n                }\n                if(dp[i][j][k]<N/2&&k<K){\n                    dp[i+1][j+1][k+1]=std::min(dp[i+1][j+1][k+1],dp[i][j][k]+1);\n                }\n            }\n        }\n        REP(j,0,N/2){\n            REP(k,1,K) dp[i+1][j][k]=std::min(dp[i+1][j][k],dp[i+1][j][k-1]);\n        }\n    }\n    ll ans=0;\n    per(i,N/2,0){\n        per(j,N/2,0){\n            if(dp[i][j][K]!=INF){\n                ll left=i,right=N-1-dp[i][j][K];\n                if(left<=right){\n                    string P=S.substr(left,right-left+1);\n                    ans=std::max(ans,j*2+RLCS(P));\n                }\n                else{\n                    ans=std::max(ans,j*2);\n                }\n            }\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 307;\n\nint dp[MX][MX][MX];\n\nint main() {\n#ifdef BZ\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n    string s;\n    cin >> s;\n    int p;\n    cin >> p;\n    int n = s.size();\n    for (int l = n - 1; l >= 0; l--) {\n        for (int r = l; r < n; r++) {\n            for (int k = 0; k <= p; k++) {\n                dp[l][r][k] = 1;\n                if (k > 0) {\n                    dp[l][r][k] = max(dp[l][r][k], dp[l][r][k - 1]);\n                }\n                if (l != r && s[l] == s[r]) {\n                    dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k] + 2);\n                }\n                if (l != r) {\n                    dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r][k]);\n                    dp[l][r][k] = max(dp[l][r][k], dp[l][r - 1][k]);\n                    if (k > 0) {\n                        dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k - 1] + 2);\n                    }\n                }\n            }\n        }\n    }\n    cout << dp[0][s.size() - 1][p] << \"\\n\";\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpii;\n\nint dp[310][310][310];\nchar a[310];\n\nint main()\n{\n\tscanf(\"%s\",a+1);int n=strlen(a+1);\n\tfor (int i=1;i<=n;i++) {dp[i+1][i][0]=0;dp[i][i][0]=1;}\n\tint K;scanf(\"%d\",&K);\n\tfor (int t=1;t<n;t++)\n\t\tfor (int i=1;i<=n-t;i++)\n\t\t{\n\t\t\tint j=i+t;\n\t\t\tfor (int k=0;k<=K;k++)\n\t\t\t{\n\t\t\t\tdp[i][j][k]=max(dp[i][j-1][k],dp[i+1][j][k]);\n\t\t\t\tif (a[i]==a[j])\n\t\t\t\t\tdp[i][j][k]=max(dp[i][j][k],dp[i+1][j-1][k]+2);\n\t\t\t\telse\n\t\t\t\t\tif (k) dp[i][j][k]=max(dp[i][j][k],dp[i+1][j-1][k-1]+2);\n\t\t\t}\n\t\t}\n\tint ans=0;\n\tfor (int i=0;i<=K;i++) ans=max(ans,dp[1][n][i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint x,dp[305][305][305];\nint main()\n{\n\tstring s;cin>>s>>x;\n\tfor(int i=0;i<s.size();i++)for(int j=0;j<s.size()-i;j++)\n\t{\n\t\tint fr=j,to=j+i;\n\t\tfor(int k=0;k<=x;k++)\n\t\t{\n\t\t\tif(fr==to)dp[fr][to][k]=1;\n\t\t\telse dp[fr][to][k]=max(dp[fr][to][k],max(dp[fr][to-1][k],dp[fr+1][to][k])),dp[fr][to][k+(s[fr]!=s[to])]=max(dp[fr][to][k+(s[fr]!=s[to])],dp[fr+1][to-1][k]+2);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[0][s.size()-1][x]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\n#include <map>\n#include <string.h>\n#include <math.h>\n#include <stdio.h>\n#include <deque>\n//#include \"D:\\C++\\test_lib_projects\\testlib.h\"\nusing namespace std;\n#define ll long long\n#define pii pair<int,int>\n\nbool debug=true;\n/*\n   Write In New Computer\n    By XiaoGeNintendo\n\t     gwq2017\n\tType:\n*/\n\n/*\nvoid fo(int id){\n\tfreopen((toString(id)+\".txt\").c_str(),\"w\",stdout);\n}\n*/\nstring s;\nint k;\n\n/*\nThe biggest answer in [l,r] with k left\n*/\n\nint d[305][305][305];\nbool f[305][305][305];\n\nint dp(int l,int r,int k){\n\t//cout<<l<<\" \"<<r<<\" \"<<k<<endl;\n\tint retv;\n\tif(k<0){\n\t\treturn 0;\n\t}else{\n\t\tif(f[l][r][k]) return d[l][r][k];\n\t\t\n\t\tif(l==r){\n\t\t\tretv=1;\n\t\t}else{\n\t\t\tif(l>r){\n\t\t\t\tretv=0;\n\t\t\t}else{\n\t\t\t\tif(s[l]==s[r]){\n\t\t\t\t\t//Middle\n\t\t\t\t\tint ans1=dp(l+1,r-1,k)+2;\n\t\t\t\t\t//Left\n\t\t\t\t\tint ans2=dp(l,r-1,k)+1;\n\t\t\t\t\t//Right\n\t\t\t\t\tint ans3=dp(l+1,r,k)+1;\n\t\t\t\t\tretv=max(ans1,max(ans2,ans3));\n\t\t\t\t}else{\n\t\t\t\t\t//Change left\n\t\t\t\t\tint ans1=dp(l+1,r,k-1)+1;\n\t\t\t\t\t//Change right\n\t\t\t\t\tint ans2=dp(l,r-1,k-1)+1;\n\t\t\t\t\t//Change middle\n\t\t\t\t\tint ans5=dp(l+1,r-1,k-1)+2;\n\t\t\t\t\t//Don't change,use left\n\t\t\t\t\tint ans3=dp(l,r-1,k);\n\t\t\t\t\t//Don't change,use right\n\t\t\t\t\tint ans4=dp(l+1,r,k);\n\t\t\t\t\t//Don't change,use middle\n\t\t\t\t\tint ans6=dp(l+1,r-1,k);\n\t\t\t\t\tretv=max(ans1,max(ans2,max(ans3,max(ans4,max(ans5,ans6)))));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tf[l][r][k]=true;\n\td[l][r][k]=retv;\n\treturn retv;\n}\n\nint main(int argc,char* argv[]){\n\tcin>>s>>k;\n\tcout<<dp(0,s.size()-1,k);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[305][305][305];\n\nint main(){\n  \n  string s;\n  int K;\n  \n  cin>>s>>K;\n  \n  memset(dp,-1,sizeof(dp));\n  \n  dp[0][s.size()-1][0]=0;\n  \n  if(s.size()==1) cout<<1<<endl;\n  \n  int ans=0;\n  \n  for(int l=0;l<s.size();l++)\n    \n    for(int r=s.size()-1;r>=l;r--){\n\n      for(int k=0;k<=K;k++){\n\t\n\tif(dp[l][r][k]==-1) continue;\n\t\n\tif(l+2==r){\n\t  ans=max(ans, dp[l][r][k]*2+1);\n\t  if(k<K) ans=max(ans, (dp[l][r][k]+1)*2+1);\n\t}\n\t\n\tif(l+1==r){\n\t  ans=max(ans, dp[l][r][k]*2);\n\t  if(k<K) ans=max(ans, (dp[l][r][k]+1)*2);\n\t}\n\t\n\tif(s[l]==s[r]) dp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]+1);\n\t\n\tif(l==r) continue;\n\t\n\tdp[l+1][r-1][k+1]=max(dp[l+1][r-1][k+1], dp[l][r][k]+1);\n\tdp[l+1][r][k]=max(dp[l+1][r][k], dp[l][r][k]);\n\tdp[l][r-1][k]=max(dp[l][r-1][k], dp[l][r][k]);\n\tdp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]);\n      }\n    }  \n  \n  cout<<ans<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n#include <cstdio>\n#include <iostream>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n//#ifdef atom #else #endif\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\n#define X first\n#define Y second\n#define vi vector<int>\n#define vvi vector< vi >\n#define vii vector< ii >\n#define mp make_pair\n#define pb push_back\nstring s;\nint k;\nconst int maxn = 305;\nconst int maxk = 305;\nint dp[maxn][maxn][maxk];\nint n;\nint solve(int i, int j, int k)\n{\n    if(i == n || j< 0) return 0;\n    if(dp[i][j][k] != -1) return dp[i][j][k];\n    int res = 0;\n    res = max(res, solve(i+1, j, k));\n    res = max(res, solve(i, j-1, k));\n    if(s[i] == s[j]) res = max(res, 1+solve(i+1, j-1, k));\n    if(k) res = max(res, solve(i+1, j-1, k-1)+2);\n    return dp[i][j][k] = res;\n}\nint main()\n{\n    //#ifndef atom freopen(\".in\", \"r\", stdin); freopen(\".out\", \"w\", stdout); #endif\n    cin >> s >> k;\n    n = s.size();\n    memset(dp, -1, sizeof dp);\n    cout << solve(0, n-1, k) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nint main(void) {\n  string S;\n  ll N, K;\n  cin >> S >> K;\n  N = S.length();\n\n  const ll INF = 1LL << 50;\n  ll dp[N][N][K + 1];\n  REP(l, 0, N) REP(r, l, N) REP(k, 0, K + 1) dp[l][r][k] = -INF;\n  REP(l, 0, N) dp[l][l][0] = 1;\n  REP(l, 0, N - 1) dp[l][l + 1][0] = S[l] == S[l + 1] ? 2 : 0;\n  REP(s, 0, N) REP(l, 0, N - s) {\n    ll r = l + s;\n    REP(k, 0, K + 1) {\n      if(l + 1 <= r - 1 && S[l + 1] == S[r - 1]) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k] + 2);\n      if(l + 1 <= r) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r][k]);\n      if(l <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l][r - 1][k]);\n      if(k > 0) dp[l][r][k] = max(dp[l][r][k], dp[l][r][k - 1]);\n      if(k > 0 && l + 1 <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k - 1] + 2);\n    }\n  }\n  cout << dp[0][N - 1][K] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nthis is the most obvious problem I've seen and B was so hard...\n*/\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, K, dp[309][309][309];\nchar sir[309];\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%s\\n\", sir + 1), N = strlen (sir + 1);\nscanf (\"%d\", &K);\nfor (int i=N; i>=1; i--)\n    for (int j=i; j<=N; j++)\n    {\n        if (i == j)\n        {\n            dp[i][j][0] = 1;\n            continue;\n        }\n        if (j == i + 1)\n        {\n            dp[i][j][0] = (sir[i] == sir[j] ? 2 : 1);\n            dp[i][j][1] = 2;\n            continue;\n        }\n        for (int k=0; k<=K && k<=(j - i + 1) / 2; k++)\n        {\n            dp[i][j][k] = max (dp[i + 1][j][k], dp[i][j - 1][k]);\n            if (k >= (sir[i] != sir[j]))\n                dp[i][j][k] = max (dp[i][j][k], 2 + dp[i + 1][j - 1][k - (sir[i] != sir[j])]);\n        }\n    }\nint ans = 0;\nfor (int k=0; k<=K; k++)\n    if (dp[1][N][k] > ans)\n        ans = dp[1][N][k];\nprintf (\"%d\\n\", ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\nusing namespace std;\nint n,k;\nint f[310][310][310];\nchar s[110];\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tscanf(\"%d\",&k);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=0;j<=k;j++) f[i][i][j]=1;\n\tfor (int len=2;len<=n;len++)\n\t\tfor (int l=1;l+len-1<=n;l++)\n\t\t{\n\t\t\tint r=l+len-1;\n\t\t\tfor (int i=0;i<=k;i++)\n\t\t\t{\n\t\t\t\tif (i) f[l][r][i]=f[l][r][i-1];\n\t\t\t\tf[l][r][i]=max(f[l][r][i],f[l+1][r][i]);\n\t\t\t\tf[l][r][i]=max(f[l][r][i],f[l][r-1][i]);\n\t\t\t\tif (i) f[l][r][i]=max(f[l][r][i],f[l+1][r-1][i-1]+2);\n\t\t\t\tif (s[l]==s[r]) f[l][r][i]=max(f[l][r][i],f[l+1][r-1][i]+2);\n\t\t\t}\n\t\t}\n\tprintf(\"%d\",f[1][n][k]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <time.h>\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <iomanip>\n#include <vector>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nconst int MAXN = 305;\n\nint n,k,ans;\nint f[2][MAXN][MAXN];\n\nchar s[MAXN];\n\nint main()\n{\n\tscanf(\"%s\",s + 1);\n\tn = strlen(s + 1);\n\tscanf(\"%d\",&k);\n\tfor (int i = 0;i <= k;i++)\n\t{\n\t\tmemcpy(f[i & 1],f[~i & 1],sizeof(f[i & 1]));\n\t\tfor (int j = 1;j <= n;j++)\n\t\t\tfor (int k = n;k >= j + 1;k--)\n\t\t\t{\n\t\t\t\tif (s[j] == s[k])\n\t\t\t\t\tf[i & 1][j][k] = max(f[i & 1][j][k],f[i & 1][j - 1][k + 1] + 1);\n\t\t\t\telse if (i)\n\t\t\t\t\tf[i & 1][j][k] = max(f[i & 1][j][k],f[~i & 1][j - 1][k + 1] + 1);\n\t\t\t\tf[i & 1][j][k] = max(f[i & 1][j][k],f[i & 1][j - 1][k]);\n\t\t\t\tf[i & 1][j][k] = max(f[i & 1][j][k],f[i & 1][j][k + 1]);\n\t\t\t}\n\t}\n\tfor (int i = 0;i <= n;i++)\n\t\tans = max(ans,f[k & 1][i][i + 1] * 2);\n\tfor (int i = 1;i <= n;i++)\n\t\tans = max(ans,f[k & 1][i - 1][i + 1] * 2 + 1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nint dp[400][400][400];\nsigned main(){\n\tstring s;int K;cin>>s>>K;\n\trep(i,s.size()){\n\t\tfor(int j=s.size()-1;j>i;j--){\n\t\t\trep(k,K+1){\n\t\t\t\tif(s[i]==s[j]){\n\t\t\t\t\tdp[i+1][j-1][k]=max(dp[i+1][j-1][k],dp[i][j][k]+1);\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tdp[i+1][j-1][k]=max(dp[i+1][j-1][k],dp[i][j][k]);\n\t\t\t\t\tdp[i+1][j][k]=max(dp[i+1][j][k],dp[i][j][k]);\n\t\t\t\t\tdp[i][j-1][k]=max(dp[i][j-1][k],dp[i][j][k]);\n\t\t\t\t\tif(k<K){\n\t\t\t\t\t\tdp[i+1][j-1][k+1]=max(dp[i+1][j-1][k+1],dp[i][j][k]+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint Max=0;\n\trep(i,s.size())rep(j,K+1){\n\t\tMax=max(Max,dp[i][i][j]);\n\t}\n\tif(s.size()%2==1)cout<<Max*2+1<<endl;\n\telse cout<<Max*2+2<<endl;\n\t//cout<<Max*2+2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define endl \"\\n\"\n#define Max(x,y,z) max(x,max(y,z))\n#define Min(x,y,z) min(x,min(y,z))\n#define pb push_back\n#define mp make_pair\n#define ff first\n#define ss second\n#define trace1(x)                cerr<<#x<<\": \"<<x<<endl\n#define trace2(x, y)             cerr<<#x<<\": \"<<x<<\" | \"<<#y<<\": \"<<y<<endl\n#define trace3(x, y, z)          cerr<<#x<<\":\" <<x<<\" | \"<<#y<<\": \"<<y<<\" | \"<<#z<<\": \"<<z<<endl\n#define trace4(a, b, c, d)       cerr<<#a<<\": \"<<a<<\" | \"<<#b<<\": \"<<b<<\" | \"<<#c<<\": \"<<c<<\" | \"<<#d<<\": \"<<d<<endl\n#define trace5(a, b, c, d, e)    cerr<<#a<<\": \"<<a<<\" | \"<<#b<<\": \"<<b<<\" | \"<<#c<<\": \"<<c<<\" | \"<<#d<<\": \"<<d<<\" | \"<<#e<< \": \"<<e<<endl\n#define trace6(a, b, c, d, e, f) cerr<<#a<<\": \"<<a<<\" | \"<<#b<<\": \"<<b<<\" | \"<<#c<<\": \"<<c<<\" | \"<<#d<<\": \"<<d<<\" | \"<<#e<< \": \"<<e<<\" | \"<<#f<<\": \"<<f<<endl\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<long long, long long> pll;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef pair<ll,ll> ii;\ntypedef vector<pair<ll,ll> > vii;\ntypedef vector<long long> vll;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<pair<long long,long long> > vpll;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\n\n#define PI 3.141592653589793\n#define mod 1000000007\n#define N 1000000000\n//# define N 2003\ntemplate<typename T> T gcd(T a,T b) { if(a==0) return b; return gcd(b%a,a); }\ntemplate<typename T> T pow(T a,T b, ll m){T ans=1; while(b>0){ if(b%2==1) ans=(ans*a)%m; b/=2; a=(a*a)%m; } return ans%m; }\n# define INF 10000000\n# define A 1000000\n\n//bool vis[N+5],vis1[N+5];\nstring s;\nint dp[300][300][300];\nint  solve(int l,int r,int k)\n{\n\tif(l==r)\n\t{\n\t\treturn 1;\n\t}\n\tif(l>r)\n\t{\n\t\treturn 0;\n\t}\n\tif(dp[l][r][k]!=-1)\n\t\treturn dp[l][r][k];\n\tint ans;\n\tif(s[l]==s[r])\n\t\tans=(2+solve(l+1,r-1,k));\n\telse\n\t{\n\t\tans=max(solve(l+1,r,k),solve(l,r-1,k));\n\t\tif(k)\n\t\tans=max(ans,2+solve(l+1,r-1,k-1));\n\t}\n\treturn dp[l][r][k]=ans;\n}\nint main()\n{\n\tIOS;\n\tint k;\n\tcin >> s;\n\tcin >> k;\n    memset(dp,-1,sizeof dp);\n\tint l=s.length();\n\tcout << solve(0,l-1,k);\n}"
  },
  {
    "language": "C++",
    "code": "\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define int long long\n\n#define all(X) (X).begin(), (X).end()\n#define reset(X) memset(X, 0, sizeof(X))\n#define mp(a, b) make_pair(a, b)\n#define pb push_back\n// #define endl '\\n'\n#define fi first\n#define se second\n\nusing namespace __gnu_pbds;\nusing namespace std;\nconst int mod = 1e9 + 7;\n// const int mod=998244353;\n//const int mod=1e9+9;\n//const int INF=4e18+10;\nconst int INF = 4e18 + 10;\ntemplate <typename T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T>\nusing ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define read(n) \\\nint n;      \\\ncin >> n;\n#define readv(x, n)   \\\nvector<int> x(n); \\\nfor (auto &i : x) \\\n    cin >> i;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> pii;\n\ntemplate <typename T1, typename T2>\nvoid set_min(T1 &a, T2 b)\n{\n    a = min(a, (T1)b);\n}\n\nint multiply(int a, int b, int in_mod) { return (a * b) % in_mod; }\nint mult_identity(int a) { return 1; }\n\n\nauto power(auto a, int b, int in_mod)\n{\n    auto prod = mult_identity(a);\n    auto mult = a % in_mod;\n    while (b != 0)\n    {\n        if (b % 2)\n        {\n            prod = multiply(prod, mult, in_mod);\n        }\n        mult = multiply(mult, mult, in_mod);\n        b /= 2;\n    }\n    return prod;\n}\nint mod_inv(int q, int in_mod)\n{\n\n    return power(q, in_mod - 2, in_mod);\n}\n\nint n;\nvector<vector<int>> g, gt;\nvector<bool>used;\nvector<int> order,comp;\nvector<bool> assignment;\n\nvoid dfs1(int v)\n{\n    used[v] = true;\n    for(int u:g[v])\n        if(!used[u])\n            dfs1(u);\n    order.pb(v);\n}\n\nvoid dfs2(int v, int cl)\n{\n    comp[v] = cl;\n    for(auto u:gt[v])\n        if(comp[u] ==-1)\n            dfs2(u, cl);\n}\n\nbool solve_2SAT()\n{\n    used.assign(n, false);\n    for(int i= 0;i<n;i++)\n        if(!used[i])\n            dfs1(i);\n\n    comp.assign(n,-1);\n    for(int i= 0,j=0;i<n;++i)\n    {\n        int v= order[n-i-1];\n        if(comp[v] == -1)\n            dfs2(v, j++);\n    }\n    assignment.assign(n/2, false);\n    for(int i= 0;i<n;i+=2)\n    {\n        if(comp[i] == comp[i+1])\n\n            return false;\n        assignment[i/2] = comp[i]>comp[i+1];\n    }\n    return true;\n}\n\n\n// void  solve()\n// {\n//     int n;\n//     cin>>n;\n//     int a, b;\n//     cin>>a>>b;\n//     readv(p,n);\n//     map<int, bool> cnt;\n//     for(auto i:p)\n//         cnt[i] = true;\n\n//     map<int, int> marking;\n\n//     int ind = 0;\n//     for(auto i:p)\n//         if(!marking[i])\n//             marking[i] = ind++;\n\n\n//     ::n = 2*ind+2;\n//     g.resize(::n);\n//     gt.resize(::n);\n//     for(auto i:p)\n//     {\n//         int it = marking[i];\n//         int other = marking[a-i];\n//         int otherother = marking[b-i];\n//         if(cnt[a-i])\n//         {\n//             g[2*it].pb(2*other);\n//             g[2*it+1].pb(2*it);\n//             g[2*other].pb(2*it);\n//             g[2*other+1].pb(2*other);\n\n//             gt[2*other].pb(2*it);\n//             gt[2*it].pb(2*it+1);\n\n//             gt[2*it].pb(2*other);\n//             gt[2*other].pb(2*other+1);\n//         }\n//         else\n//         {\n\n//             if(cnt[b-i])\n//             {\n\n//                 g[2*it+1].pb(2*otherother+1);\n//                 g[2*it].pb(2*it+1);\n//                 g[2*otherother+1].pb(2*it+1);\n//                 g[2*otherother].pb(2*otherother+1);\n\n//                 gt[2*otherother+1].pb(2*it+1);\n//                 gt[2*it+1].pb(2*it);\n//                 gt[2*it+1].pb(2*otherother+1);\n//                 gt[2*otherother + 1].pb(2*otherother);\n\n//             }\n//             else\n//             {\n//                 cout<<\"NO\"<<endl;\n//                 return;\n//             }\n//         }\n//         if(cnt[a-i] && cnt[b-i])\n//         {\n//                 g[2*it].pb(2*otherother);\n//                 g[2*it].pb(2*other);\n//                 g[2*it+1].pb(2*otherother+1);\n//                 g[2*it+1].pb(2*other+1);\n\n//                 g[2*otherother].pb(2*it);\n//                 g[2*otherother].pb(2*other);\n//                 g[2*otherother+1].pb(2*it+1);\n//                 g[2*otherother+1].pb(2*other+1);\n\n//                 g[2*other].pb(2*it);\n//                 g[2*other].pb(2*otherother);\n//                 g[2*other+1].pb(2*otherother+1);\n//                 g[2*other + 1].pb(2*it + 1);\n\n//                 gt[2*it].pb(2*otherother);\n//                 gt[2*it].pb(2*other);\n//                 gt[2*it+1].pb(2*otherother+1);\n//                 gt[2*it+1].pb(2*other+1);\n\n//                 gt[2*otherother].pb(2*it);\n//                 gt[2*otherother].pb(2*other);\n//                 gt[2*otherother+1].pb(2*it+1);\n//                 gt[2*otherother+1].pb(2*other+1);\n\n//                 gt[2*other].pb(2*it);\n//                 gt[2*other].pb(2*otherother);\n//                 gt[2*other+1].pb(2*otherother+1);\n//                 gt[2*other + 1].pb(2*it + 1);\n//         }\n//     }\n\n//     bool flag = solve_2SAT();\n\n//     if(flag)\n//     {\n//         cout<<\"YES\"<<endl;\n//         for(auto i:p)\n//             cout<<1-assignment[marking[i]]<<\" \";\n//     }\n//     else\n//     {\n//         cerr<<\"method1\"<<endl;\n//         cout<<\"NO\"<<endl;\n//     }\n\n// }\nvoid solve()\n{\n    string s;\n    cin>>s;\n    int k;\n    cin>>k;\n    int n= s.size();\n    vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(k+1)));\n\n\n    for(int len = 1;len<=n;len++)\n    {\n        for(int l = 0;l+len-1<n;l++)\n        {\n            int r= l+len-1;\n            for(int _k=0;_k<=k;_k++)\n            {\n                if(len == 1)\n                    dp[l][r][_k] =1;\n                else\n                {\n                    if(s[l] == s[r])\n                        dp[l][r][_k] =2 +dp[l+1][r-1][_k];\n                    else\n                    {\n                        dp[l][r][_k] = max(dp[l+1][r][_k], dp[l][r-1][_k]);\n                        if(_k)\n                            dp[l][r][_k] = max(dp[l][r][_k], 2+dp[l+1][r-1][_k-1]); \n                    }\n                }\n            }\n        }\n    }\n    cout<<dp[0][n-1][k]<<endl;\n}\n\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cerr.tie(NULL);\n#ifndef ONLINE_JUDGE\n    if (fopen(\"INPUT.txt\", \"r\"))\n    {\n        freopen(\"INPUT.txt\", \"r\", stdin);\n        freopen(\"OUTPUT.txt\", \"w\", stdout);\n    }\n#endif\n    auto clk = clock();\n    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n    // -------------------------------------Code starts here---------------------------------------------------------------------\n\n    int t = 1;\n    // cin >> t;\n\n    for (int test = 1; test <= t; test++)\n    {\n        // cout<<\"Case #\"<<test<<\":\\n\";\n        //cout<<\"Trip #\"<<test<<\": \";\n        // cout<<endl;\n        solve();\n        // solveB();\n\n        // cout<<endl;\n    }\n\n    // -------------------------------------Code ends here------------------------------------------------------------------\n\n    clk = clock() - clk;\n    // cerr << fixed << setprecision(6) << \"Time: \" << ((long double)clk) / CLOCKS_PER_SEC << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,inline,unroll-loops,fast-math\")\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#define N 320\nusing namespace std;\n\nchar a[N];\nint f[N][N][N];\n\nint main(void)\n{\n    int n, k;\n    int i, j, t, o;\n\n    scanf(\"%s %d\", a + 1, &k);\n    n = strlen(a + 1);\n    if(n == 1)\n    {\n        printf(\"1\\n\");\n\n        return 0;\n    }\n    if(n == 2)\n    {\n        printf(\"%d\\n\", 1 + (a[1] == a[2] || k));\n\n        return 0;\n    }\n\n    for(i = 1, o = 0; i <= n; i ++)\n        for(j = n; j > i; j --)\n            for(t = 0; t <= k; t ++)\n            {\n                f[i][j][t] = max(f[i - 1][j][t], f[i][j + 1][t]);\n                if(a[i] == a[j])\n                    f[i][j][t] = max(f[i][j][t], f[i - 1][j + 1][t] + 1);\n                else if(t)\n                    f[i][j][t] = max(f[i][j][t], f[i - 1][j + 1][t - 1] + 1);\n\n                // printf(\"left %d, right %d, change %d : %d\\n\", i, j, t, f[i][j][t]);\n                o = max(o, f[i][j][t] * 2 + (i < j - 1));\n            }\n    printf(\"%d\\n\", o);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nint main(void) {\n  string S;\n  ll N, K;\n  cin >> S >> K;\n  N = S.length();\n\n  ll dp[N][N][K + 1];\n  REP(l, 0, N) REP(r, l, N) REP(k, 0, K + 1) dp[l][r][k] = 0;\n  REP(l, 0, N) dp[l][l][0] = 1;\n  REP(l, 0, N - 1) if(S[l] == S[l + 1]) dp[l][l + 1][0] = 2;\n  REP(s, 0, N) REP(l, 0, N - s) {\n    ll r = l + s;\n    REP(k, 0, K + 1) {\n      if(l + 1 <= r - 1 && S[l] == S[r]) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k] + 2);\n      if(l + 1 <= r) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r][k]);\n      if(l <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l][r - 1][k]);\n      if(k > 0 && l + 1 <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k - 1] + 2);\n      if(k > 0) dp[l][r][k] = max(dp[l][r][k], dp[l][r][k - 1]);\n    }\n  }\n  cout << dp[0][N - 1][K] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n\tstring s;\n\tint k;\n\tcin>>s; cin>>k;\n\tint n=s.size();\n\tint dp[301][301][301]={};\n\tfor(int l=0; l<=k; l++){\n\t\tfor(int i=0; i+1<n; i++){\n\t\t\tdp[l][i][i+1]=1;\n\t\t}\n\t}\n\tfor(int d=2; d<=n; d++){\n\t\tfor(int l=0; l<=k; l++){\n\t\t\tfor(int i=0; i<=n-d; i++){\n\t\t\t\tif(s[i]==s[i+d-1]){\n\t\t\t\t\tdp[l][i][i+d]=max(dp[l][i][i+d], max(dp[l][i][i+d-1], max(dp[l][i+1][i+d], dp[l][i+1][i+d-1]+2)));\n\t\t\t\t}else{\n\t\t\t\t\tdp[l][i][i+d]=max(dp[l][i][i+d], max(dp[l][i][i+d-1], dp[l][i+1][i+d]));\n\t\t\t\t\tdp[l+1][i][i+d]=max(dp[l+1][i][i+d], dp[l][i+1][i+d-1]+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int l=0; l<=k; l++){\n\t\tans=max(ans, dp[l][0][n]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <memory>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#define rep(i, n) for(int i=0;i<(int)(n);i++)\n#define REP(i, n) for(int i=1;i<=(int)(n);i++)\n#define all(V) V.begin(),V.end()\ntypedef long long lint;\ntypedef std::pair<lint, lint> P;\nconstexpr int INF = INT_MAX / 10;\nconstexpr lint LINF = LLONG_MAX / 2;\nconstexpr double eps = 1e-9;\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\n\ntemplate<class T, class Alloc = std::allocator<T>>\nclass Vector {\n\n\tusing traits = std::allocator_traits<Alloc>;\n\npublic:\n\n\tusing value_type = T;\n\tusing allocator_type = Alloc;\n\tusing size_type = unsigned int;\n\tusing difference_type = int;\n\tusing reference = T&;\n\tusing const_reference = const T&;\n\tusing pointer = typename traits::pointer;\n\tusing const_pointer = typename traits::const_pointer;\n\n\tclass iterator {\n\n\tpublic:\n\n\t\tusing difference_type = int;\n\t\tusing value_type = Vector::value_type;\n\t\tusing pointer = Vector::pointer;\n\t\tusing reference = Vector::reference;\n\t\tusing iterator_category = std::random_access_iterator_tag;\n\n\tprivate:\n\n\t\tpointer p;\n\n\tpublic:\n\n\t\titerator()noexcept :p() {}\n\t\titerator(const Vector& base, difference_type index) noexcept :p(base.e + index) {}\n\t\titerator(const iterator& i) :p(i.p) {}\n\n\t\titerator& operator=(const iterator& i) = default;\n\t\titerator& operator=(iterator&& i)noexcept = default;\n\n\t\titerator& operator++() {\n\t\t\tp++;\n\t\t\treturn *this;\n\t\t}\n\n\t\titerator operator++(int) {\n\t\t\titerator res = *this;\n\t\t\tp++;\n\t\t\treturn res;\n\t\t}\n\n\t\titerator operator+(const difference_type& x)const {\n\t\t\titerator res = *this;\n\t\t\treturn res += x;\n\t\t}\n\n\t\titerator& operator+=(const difference_type& x) {\n\t\t\tp += x;\n\t\t\treturn *this;\n\t\t}\n\n\t\titerator& operator--() {\n\t\t\tp--;\n\t\t\treturn *this;\n\t\t}\n\n\t\titerator operator--(int) {\n\t\t\titerator res = *this;\n\t\t\tp--;\n\t\t\treturn res;\n\t\t}\n\n\t\titerator operator-(const difference_type x)const {\n\t\t\titerator res = *this;\n\t\t\treturn res -= x;\n\t\t}\n\n\t\tdifference_type operator-(const iterator& i)const {\n\t\t\treturn p - i.p;\n\t\t}\n\n\t\titerator& operator-=(const difference_type x) {\n\t\t\tp -= x;\n\t\t\treturn *this;\n\t\t}\n\n\t\treference operator*()const {\n\t\t\treturn *p;\n\t\t}\n\n\t\treference operator[](const difference_type x)const {\n\t\t\treturn *(p + x);\n\t\t}\n\n\t\tbool operator<(const iterator& i)const {\n\t\t\treturn p < i.p;\n\t\t}\n\n\t\tbool operator<=(const iterator& i)const {\n\t\t\treturn p <= i.p;\n\t\t}\n\n\t\tbool operator==(const iterator& i)const {\n\t\t\treturn p == i.p;\n\t\t}\n\n\t\tbool operator>(const iterator& i)const {\n\t\t\treturn p > i.p;\n\t\t}\n\n\t\tbool operator>=(const iterator& i)const {\n\t\t\treturn p >= i.p;\n\t\t}\n\n\t\tbool operator!=(const iterator& i)const {\n\t\t\treturn p != i.p;\n\t\t}\n\n\t};\n\n\tclass const_iterator {\n\n\tpublic:\n\n\t\tusing difference_type = int;\n\t\tusing value_type = Vector::value_type;\n\t\tusing pointer = const Vector::pointer;\n\t\tusing reference = const Vector::reference;\n\t\tusing iterator_category = std::random_access_iterator_tag;\n\n\tprivate:\n\n\t\tpointer p;\n\n\tpublic:\n\n\t\tconst_iterator()noexcept :p() {}\n\t\tconst_iterator(const Vector& base, difference_type index) noexcept :p(base.e + index) {}\n\t\tconst_iterator(const const_iterator& i) :p(i.p) {}\n\n\t\tconst_iterator& operator=(const const_iterator& i)noexcept = default;\n\t\tconst_iterator& operator=(const_iterator&& i)noexcept = default;\n\n\t\tconst_iterator& operator++() {\n\t\t\tp++;\n\t\t\treturn *this;\n\t\t}\n\n\t\tconst_iterator operator++(int) {\n\t\t\tconst_iterator res = *this;\n\t\t\tp++;\n\t\t\treturn res;\n\t\t}\n\n\t\tconst_iterator operator+(const difference_type x)const {\n\t\t\tconst_iterator res = *this;\n\t\t\treturn res += x;\n\t\t}\n\n\t\tconst_iterator& operator+=(const difference_type x) {\n\t\t\tp += x;\n\t\t\treturn *this;\n\t\t}\n\n\t\tconst_iterator& operator--() {\n\t\t\tp--;\n\t\t\treturn *this;\n\t\t}\n\n\t\tconst_iterator operator--(int) {\n\t\t\tconst_iterator res = *this;\n\t\t\tp--;\n\t\t\treturn res;\n\t\t}\n\n\t\tconst_iterator operator-(const difference_type x)const {\n\t\t\tconst_iterator res = *this;\n\t\t\treturn res -= x;\n\t\t}\n\n\t\tdifference_type operator-(const const_iterator& i)const {\n\t\t\treturn p - i.p;\n\t\t}\n\n\t\tconst_iterator& operator-=(const difference_type x) {\n\t\t\tp -= x;\n\t\t\treturn *this;\n\t\t}\n\n\t\treference operator*()const {\n\t\t\treturn *p;\n\t\t}\n\n\t\treference operator[](const difference_type x)const {\n\t\t\treturn *(p + x);\n\t\t}\n\n\t\tbool operator<(const const_iterator& i)const {\n\t\t\treturn p < i.p;\n\t\t}\n\n\t\tbool operator<=(const const_iterator& i)const {\n\t\t\treturn p <= i.p;\n\t\t}\n\n\t\tbool operator==(const const_iterator& i)const {\n\t\t\treturn p == i.p;\n\t\t}\n\n\t\tbool operator>(const const_iterator& i)const {\n\t\t\treturn p > i.p;\n\t\t}\n\n\t\tbool operator>=(const const_iterator& i)const {\n\t\t\treturn p >= i.p;\n\t\t}\n\n\t\tbool operator!=(const const_iterator& i)const {\n\t\t\treturn p != i.p;\n\t\t}\n\n\t};\n\n\tusing reverse_iterator = std::reverse_iterator<iterator>;\n\tusing const_reverse_iterator = std::reverse_iterator<const_iterator>;\n\nprivate:\n\n\tpointer e;\n\tsize_type length = 0, cap = 1;\n\tAlloc alloc;\n\n\tstatic_assert(std::is_same<T, typename Alloc::value_type>::value, \"The allocator value type is not matched the Vector value type.\");\n\tstatic_assert(!std::is_const<T>::value, \"This library forbids containers of const elements\");\n\npublic:\n\n\tVector() :Vector(Alloc()) {}\n\n\texplicit Vector(const Alloc& a)noexcept :alloc(a) {\n\t\te = alloc.allocate(cap);\n\t}\n\n\texplicit Vector(size_type n, const Alloc& a = Alloc()) :alloc(a) {\n\t\twhile (cap < n)cap *= 2;\n\t\te = alloc.allocate(cap);\n\t\trep(i, n)emplace_back();\n\t}\n\n\texplicit Vector(size_type n, const_reference value, const Alloc& a = Alloc()) :alloc(a) {\n\t\twhile (cap < n)cap *= 2;\n\t\te = alloc.allocate(cap);\n\t\trep(i, n)emplace_back(value);\n\t}\n\n\ttemplate<class InputIter>\n\tVector(InputIter first, InputIter last, const Alloc& a = Alloc()) :alloc(a) {\n\t\te = alloc.allocate(cap);\n\t\tfor (InputIter i = first; i != last; i++) {\n\t\t\templace_back(*i);\n\t\t}\n\t}\n\n\tVector(const Vector& x, const Alloc& a = Alloc()) :alloc(a) {\n\t\twhile (cap < x.length)cap *= 2;\n\t\tlength = x.length;\n\t\te = alloc.allocate(cap);\n\t\trep(i, x.length)traits::construct(alloc, e + i, *(x.e + i));\n\t}\n\n\tVector(Vector&& x, const Alloc& a = Alloc()) :alloc(a) {\n\t\tcap = x.cap;\n\t\tlength = x.length;\n\t\te = x.e;\n\t\tx.e = nullptr;\n\t}\n\n\t~Vector() {\n\t\tif (e != nullptr) {\n\t\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\t\talloc.deallocate(e, cap);\n\t\t}\n\t}\n\n\tVector& operator=(const Vector& x) {\n\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\talloc.deallocate(e, cap);\n\t\tlength = x.length;\n\t\tcap = 1;\n\t\twhile (cap < length)cap *= 2;\n\t\te = alloc.allocate(cap);\n\t\trep(i, length)traits::construct(alloc, e + i, *(x.e + i));\n\t\treturn *this;\n\t}\n\n\tVector& operator=(Vector&& x) {\n\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\talloc.deallocate(e, cap);\n\t\tcap = x.cap;\n\t\tlength = x.length;\n\t\te = x.e;\n\t\tx.e = nullptr;\n\t\treturn *this;\n\t}\n\nprivate:\n\n\tvoid extension() {\n\t\tpointer e_ = alloc.allocate(cap * 2);\n\t\trep(i, length)traits::construct(alloc, e_ + i, *(e + i));\n\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\talloc.deallocate(e, cap);\n\t\te = e_;\n\t\tcap *= 2;\n\t}\n\n\tvoid extension(size_type n) {\n\t\tunsigned int r = 1;\n\t\twhile (cap * r < n)r *= 2;\n\t\tif (r == 1)return;\n\t\tpointer e_ = alloc.allocate(cap * r);\n\t\trep(i, length)traits::construct(alloc, e_ + i, *(e + i));\n\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\talloc.deallocate(e, cap);\n\t\te = e_;\n\t\tcap *= r;\n\t}\n\npublic:\n\n\ttemplate<class InputIter>\n\tvoid assign(InputIter first, InputIter last) {\n\t\tsize_type cnt = 0;\n\t\tfor (InputIter i = first; i != last; i++) {\n\t\t\tif (cnt == cap) {\n\t\t\t\tlength = std::max(length, cnt);\n\t\t\t\textension();\n\t\t\t}\n\t\t\ttraits::construct(alloc, e + cnt, *i);\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tvoid assign(size_type n, const_reference value) {\n\t\textension(n);\n\t\tstd::fill(e, e + n, value);\n\t}\n\n\ttemplate<class... Args>\n\tvoid emplace_back(Args&&... args) {\n\t\tif (length == cap)extension();\n\t\ttraits::construct(alloc, e + length, std::forward<Args>(args)...);\n\t\tlength++;\n\t}\n\n\tvoid push_back(const_reference value) {\n\t\templace_back(value);\n\t}\n\n\tvoid push_back(T&& value) {\n\t\templace_back(std::move(value));\n\t}\n\n\tvoid pop_back() {\n\t\ttraits::destroy(alloc, e + length);\n\t\tlength--;\n\t}\n\n\tvoid reserve(size_type n) {\n\t\textension(n);\n\t}\n\n\titerator erase(iterator pos) {\n\t\tconst iterator res = pos;\n\t\titerator t = pos; t++;\n\t\tfor (iterator i = pos; t != end(); i++, t++) {\n\t\t\t*i = std::move(*t);\n\t\t}\n\t\tpop_back();\n\t\treturn res;\n\t}\n\n\titerator erase(iterator first, iterator last) {\n\t\tconst iterator res = first;\n\t\ttypename iterator::difference_type d = last - first;\n\t\tfor (iterator i = first; i + d != end(); i++) {\n\t\t\t*i = std::move(*(i + d));\n\t\t}\n\t\trep(i, d)pop_back();\n\t\treturn res;\n\t}\n\n\tvoid swap(Vector& x) {\n\t\tstd::swap(length, x.length);\n\t\tstd::swap(cap, x.cap);\n\t\tstd::swap(e, x.e);\n\t}\n\n\tvoid clear() {\n\t\twhile (length)pop_back();\n\t}\n\n\tsize_type size()const {\n\t\treturn length;\n\t}\n\n\tvoid resize(size_type  n, const_reference value = T()) {\n\t\textension(n);\n\t\twhile (n < length)pop_back();\n\t\tlength = n;\n\t\tstd::fill(e, e + n, value);\n\t}\n\n\tsize_type capacity()const {\n\t\treturn cap;\n\t}\n\n\tbool empty()const {\n\t\treturn !length;\n\t}\n\n\treference operator[](const size_type pos)const {\n\t\treturn e[pos];\n\t}\n\n\tpointer data() {\n\t\treturn e;\n\t}\n\n\treference front() {\n\t\treturn *e;\n\t}\n\n\treference back() {\n\t\treturn *(e + length - 1);\n\t}\n\n\titerator begin() noexcept {\n\t\treturn iterator(*this, 0);\n\t}\n\n\tconst_iterator begin()const noexcept {\n\t\treturn const_iterator(*this, 0);\n\t}\n\n\tconst_iterator cbegin()const noexcept {\n\t\treturn const_iterator(*this, 0);\n\t}\n\n\titerator rbegin()noexcept {\n\t\treturn reverse_iterator(*this, 0);\n\t}\n\n\tconst_iterator rbegin()const noexcept {\n\t\treturn const_reverse_iterator(*this, 0);\n\t}\n\n\tconst_iterator crbegin()const noexcept {\n\t\treturn const_reverse_iterator(*this, 0);\n\t}\n\n\titerator end() noexcept {\n\t\treturn iterator(*this, length);\n\t}\n\n\tconst_iterator end()const noexcept {\n\t\treturn const_iterator(*this, length);\n\t}\n\n\tconst_iterator cend()const noexcept {\n\t\treturn const_iterator(*this, length);\n\t}\n\n\titerator rend()noexcept {\n\t\treturn reverse_iterator(*this, length);\n\t}\n\n\tconst_iterator rend()const noexcept {\n\t\treturn const_reverse_iterator(*this, length);\n\t}\n\n\tconst_iterator crend()const noexcept {\n\t\treturn const_reverse_iterator(*this, length);\n\t}\n\n};\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ninline lint gcd(lint a, lint b) {\n\twhile (b) {\n\t\tlint c = a;\n\t\ta = b; b = c % b;\n\t}\n\treturn a;\n}\ninline lint lcm(lint a, lint b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(lint n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\nlint mypow(lint a, lint b) {\n\tif (!b)return 1;\n\tif (b & 1)return mypow(a, b - 1) * a;\n\tlint memo = mypow(a, b >> 1);\n\treturn memo * memo;\n}\nlint modpow(lint a, lint b, lint m) {\n\tif (!b)return 1;\n\tif (b & 1)return modpow(a, b - 1, m) * a % m;\n\tlint memo = modpow(a, b >> 1, m);\n\treturn memo * memo % m;\n}\ntemplate<typename T>\nvoid printArray(std::vector<T>& vec) {\n\trep(i, vec.size() - 1)std::cout << vec[i] << \" \";\n\tstd::cout << vec.back() << std::endl;\n}\ntemplate<typename T>\nvoid printArray(Vector<T>& vec) {\n\trep(i, vec.size() - 1)std::cout << vec[i] << \" \";\n\tstd::cout << vec.back() << std::endl;\n}\ntemplate<typename T>\nvoid printArray(T l, T r) {\n\tT rprev = r;\n\trprev--;\n\tfor (T i = l; i != rprev; i++) {\n\t\tstd::cout << *i << \" \";\n\t}\n\tstd::cout << *rprev << std::endl;\n}\nstd::string to_string(Vector<int>& vec) {\n\tstd::string res = \"[\";\n\trep(i, vec.size() - 1)res += std::to_string(vec[i]) + \", \";\n\tres += std::to_string(vec.back()) + \"]\";\n\treturn res;\n}\ntemplate<unsigned int modulo = 1000000007>\nclass ModInt {\n\tlint value;\npublic:\n\tModInt() : value(0) {}\n\ttemplate<typename T>\n\tModInt(T value = 0) : value(value) {\n\t\tif (value < 0)value = -(lint)(-value % modulo) + modulo;\n\t\tthis->value = value % modulo;\n\t}\n\tinline operator int()const { return value; }\n\tinline ModInt& operator+=(const ModInt& x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline ModInt operator-()const {\n\t\treturn ModInt(0) -= *this;\n\t}\n\tinline ModInt& operator-=(const ModInt& x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator*=(const ModInt& x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator/=(ModInt rhs) {\n\t\tint exp = modulo - 2;\n\t\twhile (exp) {\n\t\t\tif (exp & 1)*this *= rhs;\n\t\t\trhs *= rhs;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn *this;\n\t}\n\ttemplate<typename T> ModInt operator+(const T& rhs)const { return ModInt(*this) += rhs; }\n\ttemplate<typename T> ModInt& operator+=(const T& rhs) { return operator+=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator-(const T& rhs)const { return ModInt(*this) -= rhs; }\n\ttemplate<typename T> ModInt& operator-=(const T& rhs) { return operator-=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator*(const T& rhs)const { return ModInt(*this) *= rhs; }\n\ttemplate<typename T> ModInt& operator*=(const T& rhs) { return operator*=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator/(const T& rhs)const { return ModInt(*this) /= rhs; }\n\ttemplate<typename T> ModInt& operator/=(const T& rhs) { return operator/=(ModInt(rhs)); }\n};\ntemplate<unsigned int T>\nstd::istream& operator>>(std::istream& ist, ModInt<T>& x) {\n\tlint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\nstd::string s;\nint k;\nint dp[310][310][310];\nint main() {\n\tstd::cin >> s >> k;\n\trep(i, s.size())dp[i][i + 1][0] = 1;\n\trep(i, s.size() + 1) {\n\t\trep(j, s.size() - i + 1) {\n\t\t\trep(l, k + 1) {\n\t\t\t\tif (j)chmax(dp[j - 1][j + i][l], dp[j][j + i][l]);\n\t\t\t\tif (j + i != s.size())chmax(dp[j][j + i + 1][l], dp[j][j + i][l]);\n\t\t\t\tif (j && j + i != s.size()) {\n\t\t\t\t\tif (s[j - 1] == s[j + i]) {\n\t\t\t\t\t\tchmax(dp[j - 1][j + i + 1][l], dp[j][j + i][l] + 2);\n\t\t\t\t\t}\n\t\t\t\t\telse chmax(dp[j - 1][j + i + 1][l + 1], dp[j][j + i][l] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i, k + 1)chmax(ans, dp[0][s.size()][i]);\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#define SIZE 305\n#define INF 1000000005\n\nusing namespace std;\n\nchar str[SIZE];\nint dp[SIZE][SIZE];\nint nxt[SIZE][SIZE];\n\nint main()\n{\n\tscanf(\"%s\",&str);\n\tint K;\n\tscanf(\"%d\",&K);\n\tint n=strlen(str);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=i;j<n;j++)\n\t\t{\n\t\t\tdp[i][j]=(str[i]==str[j])?0:1;\n\t\t}\n\t}\n\tint mx=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int l=0;l<n;l++)\n\t\t{\n\t\t\tfor(int r=l;r<n;r++)\n\t\t\t{\n\t\t\t\tnxt[l][r]=INF;\n\t\t\t\tif(dp[l][r]>K) dp[l][r]=INF;\n\t\t\t\tif(dp[l][r]!=INF)\n\t\t\t\t{\n\t\t\t\t\tif(l==r) mx=max(mx,2*i-1);\n\t\t\t\t\telse mx=max(mx,2*i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int l=0;l<n;l++)\n\t\t{\n\t\t\tfor(int r=n-1;r>=l;r--)\n\t\t\t{\n\t\t\t\tif(l<r) dp[l][r-1]=min(dp[l][r-1],dp[l][r]);\n\t\t\t\tif(l+1<=r) dp[l+1][r]=min(dp[l+1][r],dp[l][r]);\n\t\t\t}\n\t\t}\n\t\tfor(int l=0;l<n;l++)\n\t\t{\n\t\t\tfor(int r=l;r<n;r++)\n\t\t\t{\n\t\t\t\tif(dp[l][r]!=INF)\n\t\t\t\t{\n\t\t\t\t\tif(l<r)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(str[l]==str[r])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnxt[l+1][r-1]=min(nxt[l+1][r-1],dp[l][r]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnxt[l+1][r-1]=min(nxt[l+1][r-1],dp[l][r]+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int l=0;l<n;l++)\n\t\t{\n\t\t\tfor(int r=l;r<n;r++)\n\t\t\t{\n\t\t\t\tdp[l][r]=nxt[l][r];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",mx);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#define MIN_INT -2147483648\n#define MAX_INT 2147483647\n#define MIN_LONG -9223372036854775808L\n#define MAX_LONG 9223372036854775807L\n#define PI 3.141592653589793238462643383279502884L\n\n#define long long long int\n\nusing std::vector;\nusing std::map;\nusing std::set;\nusing std::string;\nusing std::pair;\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\n// @author: pashka\n\nint lcs(string s1, string s2, int k) {\n    int n = s1.length();\n    int m = s2.length();\n    int d[n + 1][m + 1];\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= m; j++) {\n            if (i == 0 || j == 0) {\n                d[i][j] = 0;\n            } else {\n                if (s1[i - 1] == s2[j - 1]) {\n                    d[i][j] = d[i - 1][j - 1] + 1;\n                } else {\n                    d[i][j] = std::max(d[i - 1][j], d[i][j - 1]);\n                }\n            }\n        }\n    }\n//    cout << s1 << \" \" << s2 << \" \" << d[n][m] << \"\\n\";\n    return std::min(d[n][m] + k, std::min(n, m));\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\n    string s;\n    cin >> s;\n    int k;\n    cin >> k;\n    int n = s.length();\n    int res = 0;\n    for (int i = 0; i < n; i++) {\n        string s1 = s.substr(0, i);\n        string s2 = s.substr(i + 1, n - i - 1);\n        std::reverse(s2.begin(), s2.end());\n        res = std::max(res, lcs(s1, s2, k) * 2 + 1);\n    }\n    for (int i = 0; i < n; i++) {\n        string s1 = s.substr(0, i);\n        string s2 = s.substr(i, n - i);\n        std::reverse(s2.begin(), s2.end());\n        res = std::max(res, lcs(s1, s2, k) * 2);\n    }\n    cout << res << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<set>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<limits>\n#include<sstream>      \n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef int itn;\n\nconst int inf = numeric_limits<int>::max() /4;\nconst ll linf = numeric_limits<ll>::max() /4;\nconst ull ulinf = numeric_limits<ull>::max()/4;\nconst double pi = acos(-1);\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\nconst int dx8[8]={-1,0,1,-1,1,-1,0,1};\nconst int dy8[8]={-1,-1,-1,0,0,1,1,1};\n\n#define p_queue(i) priority_queue<i> \n#define rp_queue(i) priority_queue<i, vector<i>, greater<i>> \n#define P(p) cout<<(p)<<endl\n#define rep(i,m,n) for(int i = (m); i < (int)(n); i++)\n#define mod(i) ((i)%(ll)(1e9 + 7))\n#define divm(a,b) (mod(a * modpow((ll)b,(ll)(1e9+5))))\n#define rsort(a,b,c) sort(a, b, greater<c>())\n#define vsort(v) sort(v.begin(), v.end());\n#define rvsort(v) sort(v.end(), v.begin());\n#define ft first\n#define sd second\n#define pb push_back\n#define it insert\n#define sz(x) ((int)(x).size())\n#define lb(a,n,k) (lower_bound(a,a+n,k) - a) \n#define vlb(a,k)  (lower_bound(a.begin(),a.end(),k) - a.begin())\n#define ub(a,n,k) (upper_bound(a,a+n,k) - a) \n#define vub(a,k)  (upper_bound(a.begin(),a.end(),k) - a.begin())\n#define YES cout<<\"YES\"<< endl\n#define NO cout<<\"NO\"<<endl\n#define Yes cout<<\"Yes\"<<endl\n#define No cout<<\"No\"<<endl  \n#define yes cout<<\"yes\"<<endl\n#define no cout<<\"no\"<<endl\n#define ret return\n\nll modpow(ll i,ll j){ ll tmp=1; while(j){ if(j%2)tmp=mod(tmp*i);i=mod(i*i);j/=2;}return tmp;}\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\nvector<string> split(const string &str, char sep){\n    vector<string> v;\n    stringstream ss(str);\n    string buffer;\n    while( getline(ss, buffer, sep) ) {\n        v.push_back(buffer);\n    }\n    return v;\n}\n\n//ll ncr[100][100];\n//ll nCr(int n, int r){if(n==r) ret ncr[n][r] = 1; if(r==0) ret ncr[n][r] = 1; if(r==1) ret ncr[n][r] = n;if(ncr[n][r]) ret ncr[n][r]; ret ncr[n][r] = nCr(n-1,r) + nCr(n-1,r-1);}\n\n//ll npr[100][100]={};\n//ll nPr(int n,int r){if(npr[n][r])ret npr[n][r];if(r==0)ret npr[n][r] = 1;if(r==1)ret npr[n][r] = n;ret npr[n][r] = n * nPr(n-1,r-1);}\n\n//ll nHr(int n,int r){ret nCr(n+r-1,r);}\n\n///////////////////////////////////////////////////////////////////////////\n\n\nint lcs(string s, string t){\n    int dp[305][305] = {};\n    rep(i,0,sz(s)){\n        rep(j,0,sz(t)){\n            if(s[i] == t[j]){\n                dp[i+1][j+1] = dp[i][j] + 1; \n            }else{\n                dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j]);\n            }\n        }\n    }\n    ret dp[sz(s)][sz(t)];\n}\n\n\nint main(){\n    string s,t;\n    int k;\n    cin >> s >> k;\n    set<char> ss;\n    rep(i,0,sz(s))ss.it(s[i]);\n    \n    t = s;\n    reverse(t.begin(),t.end());\n    \n    int ans = lcs(s,t);\n\n    rep(j,0,k){\n        string ms;\n        rep(i,0,sz(s)){\n            char tmp = s[i];\n            for(auto ite: ss){\n                s[i] = ite;\n                t = s;\n                reverse(t.begin(),t.end());\n\n                int r = lcs(s,t);\n                if(ans < r){\n                    ans = r;\n                    ms = s;\n                }\n\n               // cout << s << \" \" << r << endl;\n            }  \n            s[i] = tmp;   \n        }\n        s = ms;\n    }\n\n    P(ans);\n\t\n\treturn  0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#define MN 300\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nchar st[MN+5];\nint f[MN/2+5][MN/2+5][MN/2+5],g[MN/2+5][MN/2+5][MN/2+5],n,K,ans=0;\ninline void R(int&x,int y){y>x?x=y:0;}\nvoid Solve()\n{\n\tmemset(f,200,sizeof(f));f[0][0][0]=0;\n\tfor(int k=0;k<=K;++k)\n\t\tfor(int i=0;i<=n>>1;++i)\n\t\t\tfor(int j=0;j<=n>>1;++j) if(f[k][i][j]>=0)\n\t\t\t{\n\t\t\t\tR(f[k+1][i][j],f[k][i][j]);\n\t\t\t\tR(f[k][i+1][j],f[k][i][j]);\n\t\t\t\tR(f[k][i][j+1],f[k][i][j]);\n\t\t\t\tif(i<n>>1&&j<n>>1&&st[i+1]==st[n-j]) R(f[k][i+1][j+1],f[k][i][j]+1);\n\t\t\t\telse R(f[k+1][i+1][j+1],f[k][i][j]+1);\n\t\t\t}\n\tmemset(g,200,sizeof(g));\n\tfor(int i=1;i<=n+1>>1;++i) for(int j=0;j<=K;++j) g[j][i][i]=1,g[j][i+1][i]=0;\n\tfor(int k=0;k<=K;++k)\n\t\tfor(int i=n+1>>1;i;--i)\n\t\t\tfor(int j=i;j<=n+1>>1;++j)\n\t\t\t{\n\t\t\t\tR(g[k][i][j],g[k][i][j-1]);\n\t\t\t\tR(g[k][i][j],g[k][i+1][j]);\n\t\t\t\tif(k) R(g[k][i][j],g[k-1][i][j]),R(g[k][i][j],g[k-1][i+1][j-1]+2);\n\t\t\t\tif(st[i]==st[j]) R(g[k][i][j],g[k][i+1][j-1]+2);\n\t\t\t\t//cout<<k<<\" \"<<i<<\" \"<<j<<\" \"<<st[i]<<\" \"<<st[j]<<\" \"<<g[k][i][j]<<endl;\n\t\t\t}\n\tfor(int i=0;i<=n>>1;++i) for(int j=0;j<=K;++j)\n\t\tans=max(ans,f[j][i][n>>1]*2+(i<n+1>>1?g[K-j][i+1][n+1>>1]:0));\n\tif(n&1) ans=max(ans,2*f[K][n>>1][n>>1]+1);\n}\nint main()\n{\n\tscanf(\"%s\",st+1);n=strlen(st+1);K=read();\n\tif(K>n>>1) return 0*printf(\"%d\\n\",n);\n\tSolve();\n\tfor(int l=1,r=n;l<r;++l,--r) swap(st[l],st[r]);\n\tSolve();\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(),vec.end()\n#define mp make_pair\nusing namespace std;\nusing ll=long long;\nconst ll INF=1LL<<30;\nconst ll LINF=1LL<<60;\nconst double eps=1e-5;\nconst ll MOD=1000000007LL;\ntemplate<typename T>void chmin(T &a,T b){a=min(a,b);};\ntemplate<typename T>void chmax(T &a,T b){a=max(a,b);};\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint dp[310][310][310];\nint main(){\n    string s;cin>>s;\n    int n=s.length();\n    int K;cin>>K;\n    for(int i=0;i<=n;i++)for(int j=0;j<=n;j++)for(int k=0;k<=n;k++)dp[i][j][k]=-INF;\n    dp[0][0][0]=0;dp[0][1][0]=0;dp[1][0][0]=0;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            for(int k=0;k<=K;k++){\n                chmax(dp[i][j][k],dp[i-1][j][k]);\n                chmax(dp[i][j][k],dp[i][j-1][k]);\n                if(s[i-1]==s[n-j]){\n                    chmax(dp[i][j][k],dp[i-1][j-1][k]+1);\n                }\n                if(k)chmax(dp[i][j][k],dp[i-1][j-1][k-1]+1);\n            }\n        }\n    }\n    int ans=0;\n    if(n%2){\n        for(int i=1;i<n-1;i++){\n            int j=n-i-1;\n            for(int k=0;k<=K;k++){\n                chmax(ans,dp[i][j][k]*2+1);\n            }\n        }\n    }else{\n        for(int i=1;i<n;i++){\n            int j=n-i;\n            for(int k=0;k<=K;k++){\n                chmax(ans,dp[i][j][k]*2);\n            }\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 305\n\nusing namespace std;\nint dp[maxn][maxn][maxn],n,k,l,r;\nchar s[maxn];\n\nint main()\n{\n    scanf(\"%s\",s); scanf(\"%d\",&k); n=strlen(s);\n    for (int i=0;i<n;i++) dp[i][i][0]=1;\n    for (int i=1;i<n;i++) dp[i][i-1][0]=0;\n    for (int i=1;i<n;i++)\n        for (int j=0;j+i<n;j++)\n        {\n            l=j; r=j+i;\n            for (int m=0;m<=k;m++)\n            {\n                dp[l][r][m]=max(dp[l+1][r][m],dp[l][r-1][m]);\n                if (m-(s[l]!=s[r])>=0) dp[l][r][m]=max(dp[l][r][m],dp[l+1][r-1][m-(s[l]!=s[r])]+2);\n            }\n        }\n    cout << dp[0][n-1][k] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define X first\n#define Y second\n#define smin(x , y) x = min(x , y)\n#define smax(x , y) x = max(x , y)\n#define all(v) v.begin() , v.end()\n//#define int long long\n\ntypedef long long ll;\n\nconst ll INF = 1e18 , MAXN= 310;\n\nstring s ; \nint K ; \n\nint dp[MAXN][MAXN][MAXN] ; \n\nint32_t main()\n{\n \tios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\tcin >> s >> K  ; \n\tstring t = s ;\n\treverse(t.begin() , t.end() ) ; \n  \tint n = s.size();\n  \tfor(int k=0 ; k<=K ; k++)\n  \t{\n\t\tfor(int i=0; i<=n ; i++)\n\t\t{\n\t\t\tfor(int j=0 ; j<=n ; j++)\n\t\t\t{\n\t\t\t\tif(i == 0 || j==0)\n\t\t\t\t\tdp[i][j][k] = 0 ; \n\t\t\t\telse if(s[i-1] == t[j-1])\n\t\t\t\t\tdp[i][j][k] = dp[i-1][j-1][k] + 1 ; \n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i][j][k] = max(dp[i-1][j][k] , dp[i][j-1][k]) ; \n\t\t\t\t\tif(k>0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][j][k] = max(dp[i][j][k] , dp[i-1][j-1][k-1] + 2) ; \n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j][k] = min(dp[i][j][k] , min(i, j)) ; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n\tcout << dp[n][n][K] << endl ; \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\t\n#include <time.h>\n#include <vector>\n#include <stdio.h>\n#include <memory.h>\n#include <string>\n#include <string.h>\n#include <map>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <time.h>\n#include <assert.h>\n#include <sstream>\n//#include <unordered_map>\n#include <bitset>\n#include <utility>\n#include <iomanip>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <numeric>\n#include <math.h>\n#include <cmath>\n#include <complex>\n#ifdef MYDEF\n#include \"inc.h\"\n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef complex<double> point;\n \nint n, k;\nchar s[330];\nint dp[330][330][330];\nint calc(int i, int j, int rem) {\n\tif(i >= j)\n\t\treturn i == j;\n\tint &ret = dp[i][j][rem];\n\tif(~ret)\n\t\treturn ret;\n\tret = max(calc(i + 1, j, rem), calc(i, j - 1, rem));\n\tif(s[i] == s[j])\n\t\tret = max(ret, 2 + calc(i + 1, j - 1, rem));\n\telse if(rem)\n\t  ret = max(ret, 2 + calc(i + 1, j - 1, rem - 1));\n\treturn ret;\n}\n \nint main() {\n#ifdef MYDEF\n\t// sandstone\n\tHEAD\n\t\tfreopen(\"a.txt\", \"r\", stdin);\n\t//freopen(\"a.txt\", \"w\", stdout);\n\tdecTime;\n#endif\n \n\tscanf(\"%s%d\", s, &k);\n\tn = strlen(s);\n\tmemset(dp, -1, sizeof dp);\n\tprintf(\"%d\\n\", calc(0, n - 1, k));\n \n \n#ifdef MYDEF\n\tprintTime;\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string> \n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm> \n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nvoid solve() {\n\tstring s; \n    cin >> s;\n    int n = (int)s.size();\n    int k;\n    cin >> k;\n    static int dp[330][330][330];\n    rep(i, 330) {\n        rep(j, 330) {\n            rep(l, 330) {\n                dp[i][j][l] = 0;\n            }\n        }\n    }\n    rep(i, n) {\n        rep(j, n) {\n            rep(l, k + 1) {\n                chmax(dp[i + 1][j][l], dp[i][j][l]);\n                chmax(dp[i][j + 1][l], dp[i][j][l]);\n                chmax(dp[i + 1][j + 1][l + 1], dp[i][j][l] + 1);\n                if(i <= n - 1 - j && s[i] == s[n - 1 - j]) {\n                    chmax(dp[i + 1][j + 1][l], dp[i][j][l] + 1);\n                }\n            }\n        }\n    }\n    int ans = 0;\n    rep(i, n + 1) {\n        rep(l, k + 1) {\n            chmax(ans, dp[i][n + 1 - i][l] * 2 - 1);\n            chmax(ans, dp[i][n - i][l] * 2);\n        }\n    }\n    cout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[305][305][305];\n\nint main(){\n  \n  string s;\n  int K;\n  \n  cin>>s>>K;\n  \n  memset(dp,-1,sizeof(dp));\n  \n  dp[0][s.size()-1][0]=0;\n  \n  int ans=0;\n  \n  for(int l=0;l<s.size();l++)\n    \n    for(int r=s.size()-1;r>=l;r--){\n\n      for(int k=0;k<=K;k++){\n\t\n\tif(dp[l][r][k]==-1) continue;\n\n\tif(l==r) ans=max(ans, dp[l][r][k]*2+1);\n\telse ans=max(ans, dp[l][r][k]*2);\n\t\n\tif(s[l]==s[r]) dp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]+1);\n\t\n\tif(l==r) continue;\n\t\n\tdp[l+1][r-1][k+1]=max(dp[l+1][r-1][k+1], dp[l][r][k]+1);\n\tdp[l+1][r][k]=max(dp[l+1][r][k], dp[l][r][k]);\n\tdp[l][r-1][k]=max(dp[l][r-1][k], dp[l][r][k]);\n\tdp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]);\n      }\n    }  \n  \n  cout<<ans<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint maxlcs(string s1, string s2, int k)\n{\n\tif (s1.empty() || s2.empty())\n\t\treturn 0;\n\tvector<vector<vector<int>>> ans(s1.size() + 1, vector<vector<int>>(s2.size() + 1, vector<int>(k + 1)));\n\tfor (int i = 0; i <= s1.size(); ++i)\n\t\tfor (int j = 0; j <= s2.size(); ++j)\n\t\t\tfor (int l = 0; l <= k; ++l)\n\t\t\t{\n\t\t\t\tif (i < s1.size())\n\t\t\t\t\tans[i + 1][j][l] = max(ans[i + 1][j][l], ans[i][j][l]);\n\t\t\t\tif (j < s2.size())\n\t\t\t\t\tans[i][j + 1][l] = max(ans[i][j + 1][l], ans[i][j][l]);\n\t\t\t\tif (l < k)\n\t\t\t\t\tans[i][j][l + 1] = max(ans[i][j][l + 1], ans[i][j][l]);\n\t\t\t\tif (i < s1.size() && j < s2.size())\n\t\t\t\t{\n\t\t\t\t\tif (s1[i] == s2[j])\n\t\t\t\t\t\tans[i + 1][j + 1][l] = max(ans[i + 1][j + 1][l], ans[i][j][l] + 1);\n\t\t\t\t\telse if (l < k)\n\t\t\t\t\t\tans[i + 1][j + 1][l + 1] = max(ans[i + 1][j + 1][l + 1], ans[i][j][l] + 1);\n\t\t\t\t}\n\t\t\t}\n\treturn ans.back().back().back();\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tstring s;\n\tcin >> s;\n\tint k;\n\tcin >> k;\n\tvector<vector<vector<int>>> dp(s.size(), vector<vector<int>>(s.size() + 1, vector<int>(k + 1)));\n\tint n = s.size();\n\tfor (int i = 0; i < n; ++i)\n\t\tdp[i][i + 1][0] = 1;\n\tfor (int len = 0; len <= n; ++len)\n\t\tfor (int i = 0; i + len <= n; ++i)\n\t\t{\n\t\t\tint j = i + len;\n\t\t\tfor (int l = 0; l <= k; ++l)\n\t\t\t{\n\t\t\t\tif (j < n)\n\t\t\t\t\tdp[i][j + 1][l] = max(dp[i][j + 1][l], dp[i][j][l]);\n\t\t\t\tif (i > 0)\n\t\t\t\t\tdp[i - 1][j][l] = max(dp[i - 1][j][l], dp[i][j][l]);\n\t\t\t\tif (l < k)\n\t\t\t\t\tdp[i][j][l + 1] = max(dp[i][j][l + 1], dp[i][j][l]);\n\t\t\t\tif (i > 0 && j < n)\n\t\t\t\t{\n\t\t\t\t\tif (s[i - 1] == s[j])\n\t\t\t\t\t\tdp[i - 1][j + 1][l] = max(dp[i - 1][j + 1][l], dp[i][j][l] + 2);\n\t\t\t\t\telse if (l < k)\n\t\t\t\t\t\tdp[i - 1][j + 1][l + 1] = max(dp[i - 1][j + 1][l + 1], dp[i][j][l] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcout << dp[0].back().back() << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define mod 1000000007\nusing ll=long long;\nconst int INF=1000000000;\nconst ll LINF=1001002003004005006ll;\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n// ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return true;}return false;}\n \nstruct IOSetup{\n    IOSetup(){\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n        cout<<fixed<<setprecision(12);\n    }\n} iosetup;\n \ntemplate<typename T1,typename T2>\nostream &operator<<(ostream &os,const pair<T1,T2>&p){\n    os<<p.first<<\" \"<<p.second;\n    return os;\n}\n \ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T>&v){\n    for(int i=0;i<(int)v.size();i++) os<<v[i]<<(i+1==(int)v.size()?\"\":\" \");\n    return os;\n}\n\ntemplate<typename T1,typename T2>\nistream &operator>>(istream &is,pair<T1,T2>&p){\n    is>>p.first>>p.second;\n    return is;\n}\n\ntemplate<typename T>\nistream &operator>>(istream &is,vector<T>&v){\n    for(T &x:v)is>>x;\n    return is;\n}\n\n\nint dp[310][310][610];\nsigned main(){\n    string s;cin>>s;\n    int m;cin>>m;\n    int n=(int)s.size();\n    if(m>=n){\n        cout<<n<<endl;\n        return 0;\n    }\n    string t=s;\n    reverse(ALL(t));\n\n    rep(i,n)rep(j,n)rep(k,m+1){\n        chmax(dp[i+1][j+1][k],dp[i][j][k]+(s[i]==t[j]));\n        chmax(dp[i+1][j+1][k],dp[i][j+1][k]);\n        chmax(dp[i+1][j+1][k],dp[i+1][j][k]);\n        chmax(dp[i+1][j+1][k+1],dp[i][j][k]+1);\n    }\n    int res=0;\n    // t=rev(s)\n    // s = [a   ][b     ]\n    // t = [rb    ][ra  ]\n    // LCS(a,rb)=LCS(b,ra)\n    // 文字同士をマッチングさせることを考えるとそれはそう\n    rep(i,n+1)chmax(res,2*dp[i][n-i][m]);\n    rep(i,n)  chmax(res,2*dp[i][n-1-i][m]+1);\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main(){\n    string S; cin >> S;\n    const int N = S.size();\n    int K; cin >> K;\n    int res = 0;\n    vector<vector<vector<int>>> dp(K+1, vector<vector<int>>(N, vector<int>(N, 0)));\n    for(int d=N-1;d>=0;d--){\n        for(int i=0;i+d<N;i++){\n            int j = i+d;\n            for(int k=0;k<=K;k++){\n                if(k < K && S[i] != S[j]){\n                    res = max(res, dp[k][i][j] + 2);\n                    if(i+1 < N && j > 0){\n                        dp[k+1][i+1][j-1] = max(dp[k+1][i+1][j-1], dp[k][i][j] + 2);\n                    }\n                }\n                if(S[i] == S[j]){\n                    res = max(res, dp[k][i][j] + (i==j ? 1 : 2));\n                    if(i+1 < N && j > 0){\n                        dp[k][i+1][j-1] = max(dp[k][i+1][j-1], dp[k][i][j] + (i==j ? 1 : 2));\n                    }\n                }\n                if(i+1 < N) dp[k][i+1][j] = max(dp[k][i+1][j], dp[k][i][j]);\n                if(j > 0) dp[k][i][j-1] = max(dp[k][i][j-1], dp[k][i][j]);\n            }\n        }\n    }\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\ninline void chkmax(int& a,int b){\n\tif(a<b) a=b;\n}\n\nconst int N=305;\n\nchar s[N];\n\nint lim,n,f[N][N][N];\n\nint main(){\n\tscanf(\"%s%d\",s+1,&lim); n=strlen(s+1);\n\tfor(int i=1;i<=n;++i) for(int k=0;k<=lim;++k) f[i][i][k]=1;\n\tfor(int i=n;i>=1;--i){\n\t\tfor(int j=i+1;j<=n;++j){\n\t\t\tfor(int k=0;k<=lim;++k){\n\t\t\t\tif(k) chkmax(f[i][j][k],f[i][j][k-1]);\n\t\t\t\tchkmax(f[i][j][k],f[i][j-1][k]);\n\t\t\t\tchkmax(f[i][j][k],f[i+1][j][k]);\n\t\t\t\tif(s[i]==s[j]) chkmax(f[i][j][k],f[i+1][j-1][k]+2);\n\t\t\t\telse if(k) chkmax(f[i][j][k],f[i+1][j-1][k-1]+2);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[1][n][lim]); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 310\n\nint dp[MAX][MAX][MAX]; //l,r,change\nchar buf[MAX];\nstring s;\nint k;\n\n\nint main(){\n\tscanf(\"%s\", buf);\n\ts = buf;\n\tscanf(\"%d\", &k);\n\tint n = strlen(buf);\n\tint ans = 0;\n\tfor (int chang = 0; chang <= k; chang++){\n\t\tfor (int len = n; len >=0; len--){\n\t\t\tfor (int i = 0; i < n; i++){\n\t\t\t\tint j = i + len;\n\t\t\t\tif (j < 0 || j >= n)continue;\n\t\t\t\t//match\n\t\t\t\tdp[i + 1][j][chang] = max(dp[i + 1][j][chang], dp[i][j][chang]);\n\t\t\t\tif (j){\n\t\t\t\t\tdp[i][j - 1][chang] = max(dp[i][j - 1][chang], dp[i][j][chang]);\n\t\t\t\t}\n\t\t\t\tif (s[i] == s[j]){\n\t\t\t\t\tint ii = i + 1;\n\t\t\t\t\tint jj = j - 1;\n\t\t\t\t\tans = max(ans, (dp[i][j][chang] + 1)*2-(int)(i==j) );\n\t\t\t\t\tif (ii < n&&jj >= 0){\n\t\t\t\t\t\tdp[ii][jj][chang] = max(dp[ii][jj][chang], dp[i][j][chang] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (chang < k){\n\t\t\t\t\t\tint ii = i + 1;\n\t\t\t\t\t\tint jj = j - 1;\n\t\t\t\t\t\tans = max(ans, (dp[i][j][chang] + 1) * 2 - (int)(i == j));\n\t\t\t\t\t\tif (ii < n&&jj >= 0){\n\t\t\t\t\t\t\tdp[ii][jj][chang + 1] = max(dp[ii][jj][chang + 1], dp[i][j][chang] + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nchar str[305];\nint dp[305][305][305],K;\nint max(int a,int b){return a>b?a:b;}\nint main(){\n\tscanf(\"%s%d\",str,&K); int lens=strlen(str);\n\tfor(int i=0;i<lens;i++)\n\t\tfor(int k=0;k<=K;k++)\n\t\t\tdp[i][i][k]=1;\n\tfor(int l=1;l<lens;++l)\n\t\tfor(int i=0;i+l<lens;++i){\n\t\t\tint j=i+l;\n\t\t\tfor(int k=0;k<=K;++k){\n\t\t\t\tdp[i][j][k]=max(dp[i+1][j][k],dp[i][j-1][k]);\n\t\t\t\tif(k>0) dp[i][j][k]=max(dp[i+1][j-1][k-1]+2,dp[i][j][k]);\n\t\t\t\tif(str[i]==str[j]) dp[i][j][k]=max(dp[i+1][j-1][k]+2,dp[i][j][k]);\n\t        }\n\t    }\n\tprintf(\"%d\\n\",dp[0][lens-1][K]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nint main(void) {\n  string S;\n  ll N, K;\n  cin >> S >> K;\n  N = S.length();\n\n  ll dp[N][N][K + 1];\n  REP(l, 0, N) REP(r, l, N) REP(k, 0, K + 1) dp[l][r][k] = 0;\n  REP(l, 0, N) REP(k, 0, K + 1) dp[l][l][k] = 1;\n  REP(l, 0, N - 1) if(S[l] == S[l + 1]) dp[l][l + 1][0] = 2;\n  REP(l, 0, N - 1) REP(k, 1, K + 1) dp[l][l + 1][k] = 2;\n  REP(s, 0, N) REP(l, 0, N - s) {\n    ll r = l + s;\n    REP(k, 0, K + 1) {\n      if(l + 1 <= r - 1 && S[l] == S[r]) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k] + 2);\n      if(l + 1 <= r) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r][k]);\n      if(l <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l][r - 1][k]);\n      if(k > 0 && l + 1 <= r - 1) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k - 1] + 2);\n      if(k > 0) dp[l][r][k] = max(dp[l][r][k], dp[l][r][k - 1]);\n    }\n  }\n  cout << dp[0][N - 1][K] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[305][305][305];\n\nint main(){\n  \n  string s;\n  int K;\n  \n  cin>>s>>K;\n  \n  memset(dp,-1,sizeof(dp));\n  \n  dp[0][s.size()-1][0]=0;\n  \n  for(int l=0;l<s.size();l++)\n    \n    for(int r=s.size()-1;r>l;r--){\n\n      for(int k=0;k<=K;k++){\n\t\n\tif(dp[l][r][k]==-1) continue;\n\t\n\tif(s[l]==s[r]) dp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]+1);\n\t\n\tdp[l+1][r-1][k+1]=max(dp[l+1][r-1][k+1], dp[l][r][k]+1);\n\tdp[l+1][r][k]=max(dp[l+1][r][k], dp[l][r][k]);\n\tdp[l][r-1][k]=max(dp[l][r-1][k], dp[l][r][k]);\n\tdp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]);\n      }\n    }\n  \n  int ans=0;\n  \n  for(int i=0;i<s.size();i++)\n    for(int j=0;j<=K;j++) ans=max(ans, dp[i][i][j]*2+1);\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\n\nclass Solver {\n public:\n  string s;\n  int n, q;\n  Solver(string s) : s(s), n(s.length()){};\n\n  void solve() {\n    cin >> q;\n    vector<vector<vector<int>>> dp(q + 1, vector<vector<int>>(n, vector<int>(n)));\n    for (int i = 0; i < n; ++i) {\n      dp[0][i][i] = 1;\n    }\n    for (int i = 0; i < n - 1; ++i) {\n      if (s[i] == s[i + 1]) {\n        dp[0][i][i + 1] = 2;\n      } else {\n        dp[0][i][i + 1] = 1;\n      }\n    }\n    for (int d = 2; d < n; ++d) {\n      for (int i = 0; i < n - d; ++i) {\n        if (s[i] == s[i + d]) {\n          dp[0][i][i + d] = dp[0][i + 1][i + d - 1] + 2;\n        } else {\n          dp[0][i][i + d] = max(dp[0][i + 1][i + d], dp[0][i][i + d - 1]);\n        }\n      }\n    }\n    DBG(dp[0])\n    for (int i = 1; i <= q; ++i) {\n      for (int j = 0; j < n; ++j) {\n        dp[i][j][j] = 1;\n      }\n      for (int j = 0; j < n - 1; ++j) {\n        if (s[j] == s[j + 1]) {\n          dp[i][j][j + 1] = 2;\n        } else {\n          dp[i][j][j + 1] = 2;\n        }\n      }\n      for (int d = 2; d < n; ++d) {\n        for (int j = 0; j < n - d; ++j) {\n          dp[i][j][j + d] = dp[i - 1][j][j + d];\n          if (s[j] == s[j + d]) {\n            dp[i][j][j + d] = max(dp[i][j][j + d], dp[i][j + 1][j + d - 1] + 2);\n          } else {\n            dp[i][j][j + d] = max({dp[i][j][j + d], dp[i][j + 1][j + d], dp[i][j][j + d - 1], dp[i - 1][j + 1][j + d] + 2, dp[i - 1][j][j + d - 1] + 2});\n          }\n        }\n      }\n    }\n    DBG(dp)\n    cout << dp[q][0][n - 1] << endl;\n  }\n};\n\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  std::string s;\n  std::cin >> s;\n  Problem::Solver sol(s);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define fr first\n#define sc second\n#define ll  long long\n#define mp make_pair\n#define mod 1000000007\n\nusing namespace std;\n\nstring s;\nint dp[330][330][330];\nint aft[330][30];\nint bef[330][30];\nint f(int st,int en,int k){\n    if(st == en){\n        return 1;\n    }\n    int &ret = dp[st][en][k];\n    if(ret != -1)return ret;\n    int r =0;\n    if(st +1 != en &&k){\n        r = max(r,f(st+1,en-1,k-1)+2);\n    }\n    for(int i=0 ;i < 26 ; i++){\n        if(aft[st][i] <= bef[en][i]){\n            r = max(r,f(aft[st][i],bef[en][i],k)+2);\n        }\n\n    }\n    return ret = r;\n}\n\nint v[100100];\nint main()  {\n    int k;\n    ios::sync_with_stdio(0);\n    cin>>s>>k;\n    int n = s.size();\n    memset(dp,-1,sizeof dp);\n    for(int j=0 ;j <26 ; j++){\n        v[j] = -1;\n    }\n\n    for(int i=0 ;i <n ;i ++){\n        for(int j=0 ;j <26  ; j++){\n            bef[i][j] = v[j];\n        }\n        v[s[i]-'a'] = i;\n    }\n\n    for(int j=0 ;j <26 ; j++){\n        v[j] = n+2;\n    }\n\n    for(int i=n-1 ;i >=0 ;i --){\n        for(int j=0 ;j <26  ; j++){\n            aft[i][j] = v[j];\n        }\n        v[s[i]-'a'] = i;\n    }\n    cout<<f(0,n-1,k);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define eb emplace_back\n#define sz(V) ((int)(V).size())\n#define allv(V) ((V).begin()),((V).end())\n#define befv(V) ((V)[sz(V)-2])\n#define sorv(V) sort(allv(V))\n#define revv(V) reverse(allv(V))\n#define univ(V) (V).erase(unique(allv(V)),(V).end())\n#define upmax(a,b) (a)=max((a),(b))\n#define upmin(a,b) (a)=min((a),(b))\n#define rb(x) ((x)&(-(x)))\n#define INF (0x3f3f3f3f)\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll pw(ll n) { return n*n; }\npll operator - (pll a, pll b) { return pll(a.first-b.first, a.second-b.second); }\nll operator * (pll a, pll b) { return a.first*b.second - b.first*a.second; }\nll ccw(pll a, pll b, pll c) { return a*b + b*c + c*a; }\nll dst(pll a) { return pw(a.first) + pw(a.second); }\n\nconst int MAXN = 305;\n\nint dp[MAXN][MAXN][MAXN];\n\nvector<int> V[26];\n\nint A[MAXN];\n\nint N, K;\n\nint f(int s, int e, int k) {\n\tif(s > e || k < 0) return 0;\n\tif(s == e) return 1;\n\tint &ret = dp[s][e][k];\n\tif(0 <= ret) return ret;\n\n\tret = 1;\n\n\tif(A[s] == A[e])\n\t\tupmax(ret, f(s+1, e-1, k) + 2);\n\t{\n\t\tint ei = (int)(upper_bound(allv(V[A[s]]), e) - V[A[s]].begin()) - 1;\n\t\tif(0 <= ei && s < V[A[s]][ei])\n\t\t\tupmax(ret, f(s+1, V[A[s]][ei]-1, k) + 2);\n\t}\n\t{\n\t\tint si = (int)(lower_bound(allv(V[A[e]]), s) - V[A[e]].begin());\n\t\tif(0 <= si && V[A[e]][si] < e)\n\t\t\tupmax(ret, f(V[A[e]][si]+1, e-1, k) + 2);\n\t}\n\tif(k) upmax(ret, f(s+1, e-1, k-1) + 2);\n\tupmax(ret, f(s, e-1, k));\n\tupmax(ret, f(s+1, e, k));\n\n\treturn ret;\n}\nchar str[MAXN] = {0};\nint main() {\n\t{\n\n\t\tscanf(\" %s\", str+1);\n\t\tN = int(strlen(str+1));\n\t\tscanf(\"%d\", &K);\n\n\t\tfor(int i = 1; i <= N; i++)\n\t\t\tA[i] = str[i] - 'a';\n\t}\n\n\tfor(int i = 1; i <= N; i++)\n\t\tV[A[i]].pb(i);\n\n\tfor(int i = 0; i <= N; i++) for(int j = 0; j <= N; j++)\n\t\tfill(dp[i][j], dp[i][j]+N+1, -1);\n\n\tcout << f(1, N, K) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\n\nstring s; int n;\nint K;\nint dp[300][300][301];\t//dp[l][r][x] = 区間[l, r]内における最長回文の長さ（変更数≦x)\nint iter[2][300][26];\t//iter[left or right][pos][moji] = (leftの場合)s[pos],…,s[n-1]の間において文字mojiが出現する最初の場所\n\t\t\t\t\t\t//, (rightの場合)s[0],…,s[pos]の間において文字mojiが出現する最後の場所\n\nint dfs(int l, int r, int x) {\n\tint len = r - l + 1;\n\tif (len == 1) return 1;\n\tif (len <= 0) return 0;\n\tif (dp[l][r][x] != -1) return dp[l][r][x];\n\t\n\tint ret = 0;\n\tif (x > 0 && len >= 2) ret = 2 + dfs(l + 1, r - 1, x - (s[l] != s[r]));\n\t\n\tfor (int i = 0; i < 26; i++) {\n\t\tint nl = iter[0][l][i];\n\t\tint nr = iter[1][r][i];\n\t\tif (nl == -1 || nr == -1 || nl > nr) continue;\n\t\tint res = 2 - (nl == nr) + dfs(nl + 1, nr - 1, x);\n\t\tret = max(ret, res);\n\t}\n\treturn dp[l][r][x] = ret;\n}\n\nint main() {\n\tint i, j, k;\n\t\n\tcin >> s >> K;\n\tn = s.length();\n\trep(i, n) rep(j, n) rep(k, n + 1) dp[i][j][k] = -1;\n\trep(i, 2) rep(j, n) rep(k, 26) iter[i][j][k] = -1;\n\t\n\trep(i, n) {\n\t\tfor (j = i; j < n; j++) {\n\t\t\tif (iter[0][i][s[j] - 'a'] == -1) {\n\t\t\t\titer[0][i][s[j] - 'a'] = j;\n\t\t\t}\n\t\t}\n\t\tfor (j = i; j >= 0; j--) {\n\t\t\tif (iter[1][i][s[j] - 'a'] == -1) {\n\t\t\t\titer[1][i][s[j] - 'a'] = j;\n\t\t\t}\n\t\t}\n\t}\n\tint res = dfs(0, n - 1, K);\n\tcout << res << endl;\n\treturn 0;\n}\n\n//K=0の場合で実験すると、最長部分列のうち一つは回文になっていると予想できる。これが正しければ、最長回文の長さが解の上界になる。\n//まあ、AGCなので正しいだろう（は？）\n//また、Tの回文部分列なら何でも、TとT'の共通部分列になっている。よって、最長回文の長さが解の下界になる。\n//\n//よって、「文字列Sの文字をK文字まで変更できるとき、作れる回文部分列の長さは最大でいくらになるか？」という問題になる。\n//これは、\n//１．文字を変更する→（回文になるように）左から文字を選ぶ\n//２．左から文字を選ぶ→（回文になるように）文字を変更する→変更数≦Kかをチェックする。\n//３．両端から文字を選ぶ→（回文になるように）文字を変更する\n//のいずれでも解くことができるが、３の方針で考えると見通しがよい。このとき、以下の問題を解くのが本質になる。\n//\n//「両端からペアを作っていく。1文字だけのペアも作れるが、ペアは入れ子構造になっている必要がある。\n//ペアを作るとき、違う文字ならコストが1発生する。コストK以下でいくつペアを作れるか？」\n//\n//この問題は、dp[左端l][右端r][変更数x] = そこからいくつのペアを作れるか？というDPで解くことができる。\n//遷移は、「両端(l, r)を使う」「コストを消費せず、文字aでペアを作る」の2つだが、どちらもO(1)で行うことができる。\n//計算量はO(N^3) * 26 / 2くらいになる。これ間に合うのか？"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <memory>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#define rep(i, n) for(int i=0;i<(int)(n);i++)\n#define REP(i, n) for(int i=1;i<=(int)(n);i++)\n#define all(V) V.begin(),V.end()\ntypedef long long lint;\ntypedef std::pair<lint, lint> P;\nconstexpr int INF = INT_MAX / 10;\nconstexpr lint LINF = LLONG_MAX / 2;\nconstexpr double eps = 1e-9;\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\n\ntemplate<class T, class Alloc = std::allocator<T>>\nclass Vector {\n\n\tusing traits = std::allocator_traits<Alloc>;\n\npublic:\n\n\tusing value_type = T;\n\tusing allocator_type = Alloc;\n\tusing size_type = unsigned int;\n\tusing difference_type = int;\n\tusing reference = T&;\n\tusing const_reference = const T&;\n\tusing pointer = typename traits::pointer;\n\tusing const_pointer = typename traits::const_pointer;\n\n\tclass iterator {\n\n\tpublic:\n\n\t\tusing difference_type = int;\n\t\tusing value_type = Vector::value_type;\n\t\tusing pointer = Vector::pointer;\n\t\tusing reference = Vector::reference;\n\t\tusing iterator_category = std::random_access_iterator_tag;\n\n\tprivate:\n\n\t\tpointer p;\n\n\tpublic:\n\n\t\titerator()noexcept :p() {}\n\t\titerator(const Vector& base, difference_type index) noexcept :p(base.e + index) {}\n\t\titerator(const iterator& i) :p(i.p) {}\n\n\t\titerator& operator=(const iterator& i) = default;\n\t\titerator& operator=(iterator&& i)noexcept = default;\n\n\t\titerator& operator++() {\n\t\t\tp++;\n\t\t\treturn *this;\n\t\t}\n\n\t\titerator operator++(int) {\n\t\t\titerator res = *this;\n\t\t\tp++;\n\t\t\treturn res;\n\t\t}\n\n\t\titerator operator+(const difference_type& x)const {\n\t\t\titerator res = *this;\n\t\t\treturn res += x;\n\t\t}\n\n\t\titerator& operator+=(const difference_type& x) {\n\t\t\tp += x;\n\t\t\treturn *this;\n\t\t}\n\n\t\titerator& operator--() {\n\t\t\tp--;\n\t\t\treturn *this;\n\t\t}\n\n\t\titerator operator--(int) {\n\t\t\titerator res = *this;\n\t\t\tp--;\n\t\t\treturn res;\n\t\t}\n\n\t\titerator operator-(const difference_type x)const {\n\t\t\titerator res = *this;\n\t\t\treturn res -= x;\n\t\t}\n\n\t\tdifference_type operator-(const iterator& i)const {\n\t\t\treturn p - i.p;\n\t\t}\n\n\t\titerator& operator-=(const difference_type x) {\n\t\t\tp -= x;\n\t\t\treturn *this;\n\t\t}\n\n\t\treference operator*()const {\n\t\t\treturn *p;\n\t\t}\n\n\t\treference operator[](const difference_type x)const {\n\t\t\treturn *(p + x);\n\t\t}\n\n\t\tbool operator<(const iterator& i)const {\n\t\t\treturn p < i.p;\n\t\t}\n\n\t\tbool operator<=(const iterator& i)const {\n\t\t\treturn p <= i.p;\n\t\t}\n\n\t\tbool operator==(const iterator& i)const {\n\t\t\treturn p == i.p;\n\t\t}\n\n\t\tbool operator>(const iterator& i)const {\n\t\t\treturn p > i.p;\n\t\t}\n\n\t\tbool operator>=(const iterator& i)const {\n\t\t\treturn p >= i.p;\n\t\t}\n\n\t\tbool operator!=(const iterator& i)const {\n\t\t\treturn p != i.p;\n\t\t}\n\n\t};\n\n\tclass const_iterator {\n\n\tpublic:\n\n\t\tusing difference_type = int;\n\t\tusing value_type = Vector::value_type;\n\t\tusing pointer = const Vector::pointer;\n\t\tusing reference = const Vector::reference;\n\t\tusing iterator_category = std::random_access_iterator_tag;\n\n\tprivate:\n\n\t\tpointer p;\n\n\tpublic:\n\n\t\tconst_iterator()noexcept :p() {}\n\t\tconst_iterator(const Vector& base, difference_type index) noexcept :p(base.e + index) {}\n\t\tconst_iterator(const const_iterator& i) :p(i.p) {}\n\n\t\tconst_iterator& operator=(const const_iterator& i)noexcept = default;\n\t\tconst_iterator& operator=(const_iterator&& i)noexcept = default;\n\n\t\tconst_iterator& operator++() {\n\t\t\tp++;\n\t\t\treturn *this;\n\t\t}\n\n\t\tconst_iterator operator++(int) {\n\t\t\tconst_iterator res = *this;\n\t\t\tp++;\n\t\t\treturn res;\n\t\t}\n\n\t\tconst_iterator operator+(const difference_type x)const {\n\t\t\tconst_iterator res = *this;\n\t\t\treturn res += x;\n\t\t}\n\n\t\tconst_iterator& operator+=(const difference_type x) {\n\t\t\tp += x;\n\t\t\treturn *this;\n\t\t}\n\n\t\tconst_iterator& operator--() {\n\t\t\tp--;\n\t\t\treturn *this;\n\t\t}\n\n\t\tconst_iterator operator--(int) {\n\t\t\tconst_iterator res = *this;\n\t\t\tp--;\n\t\t\treturn res;\n\t\t}\n\n\t\tconst_iterator operator-(const difference_type x)const {\n\t\t\tconst_iterator res = *this;\n\t\t\treturn res -= x;\n\t\t}\n\n\t\tdifference_type operator-(const const_iterator& i)const {\n\t\t\treturn p - i.p;\n\t\t}\n\n\t\tconst_iterator& operator-=(const difference_type x) {\n\t\t\tp -= x;\n\t\t\treturn *this;\n\t\t}\n\n\t\treference operator*()const {\n\t\t\treturn *p;\n\t\t}\n\n\t\treference operator[](const difference_type x)const {\n\t\t\treturn *(p + x);\n\t\t}\n\n\t\tbool operator<(const const_iterator& i)const {\n\t\t\treturn p < i.p;\n\t\t}\n\n\t\tbool operator<=(const const_iterator& i)const {\n\t\t\treturn p <= i.p;\n\t\t}\n\n\t\tbool operator==(const const_iterator& i)const {\n\t\t\treturn p == i.p;\n\t\t}\n\n\t\tbool operator>(const const_iterator& i)const {\n\t\t\treturn p > i.p;\n\t\t}\n\n\t\tbool operator>=(const const_iterator& i)const {\n\t\t\treturn p >= i.p;\n\t\t}\n\n\t\tbool operator!=(const const_iterator& i)const {\n\t\t\treturn p != i.p;\n\t\t}\n\n\t};\n\n\tusing reverse_iterator = std::reverse_iterator<iterator>;\n\tusing const_reverse_iterator = std::reverse_iterator<const_iterator>;\n\nprivate:\n\n\tpointer e;\n\tsize_type length = 0, cap = 1;\n\tAlloc alloc;\n\n\tstatic_assert(std::is_same<T, typename Alloc::value_type>::value, \"The allocator value type is not matched the Vector value type.\");\n\tstatic_assert(!std::is_const<T>::value, \"This library forbids containers of const elements\");\n\npublic:\n\n\tVector() :Vector(Alloc()) {}\n\n\texplicit Vector(const Alloc& a)noexcept :alloc(a) {\n\t\te = alloc.allocate(cap);\n\t}\n\n\texplicit Vector(size_type n, const Alloc& a = Alloc()) :alloc(a) {\n\t\twhile (cap < n)cap *= 2;\n\t\te = alloc.allocate(cap);\n\t\trep(i, n)emplace_back();\n\t}\n\n\texplicit Vector(size_type n, const_reference value, const Alloc& a = Alloc()) :alloc(a) {\n\t\twhile (cap < n)cap *= 2;\n\t\te = alloc.allocate(cap);\n\t\trep(i, n)emplace_back(value);\n\t}\n\n\ttemplate<class InputIter>\n\tVector(InputIter first, InputIter last, const Alloc& a = Alloc()) :alloc(a) {\n\t\te = alloc.allocate(cap);\n\t\tfor (InputIter i = first; i != last; i++) {\n\t\t\templace_back(*i);\n\t\t}\n\t}\n\n\tVector(const Vector& x, const Alloc& a = Alloc()) :alloc(a) {\n\t\twhile (cap < x.length)cap *= 2;\n\t\tlength = x.length;\n\t\te = alloc.allocate(cap);\n\t\trep(i, x.length)traits::construct(alloc, e + i, *(x.e + i));\n\t}\n\n\tVector(Vector&& x, const Alloc& a = Alloc()) :alloc(a) {\n\t\tcap = x.cap;\n\t\tlength = x.length;\n\t\te = x.e;\n\t\tx.e = nullptr;\n\t}\n\n\t~Vector() {\n\t\tif (e != nullptr) {\n\t\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\t\talloc.deallocate(e, cap);\n\t\t}\n\t}\n\n\tVector& operator=(const Vector& x) {\n\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\talloc.deallocate(e, cap);\n\t\tlength = x.length;\n\t\tcap = 1;\n\t\twhile (cap < length)cap *= 2;\n\t\te = alloc.allocate(cap);\n\t\trep(i, length)traits::construct(alloc, e + i, *(x.e + i));\n\t\treturn *this;\n\t}\n\n\tVector& operator=(Vector&& x) {\n\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\talloc.deallocate(e, cap);\n\t\tcap = x.cap;\n\t\tlength = x.length;\n\t\te = x.e;\n\t\tx.e = nullptr;\n\t\treturn *this;\n\t}\n\nprivate:\n\n\tvoid extension() {\n\t\tpointer e_ = alloc.allocate(cap * 2);\n\t\trep(i, length)traits::construct(alloc, e_ + i, *(e + i));\n\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\talloc.deallocate(e, cap);\n\t\te = e_;\n\t\tcap *= 2;\n\t}\n\n\tvoid extension(size_type n) {\n\t\tunsigned int r = 1;\n\t\twhile (cap * r < n)r *= 2;\n\t\tif (r == 1)return;\n\t\tpointer e_ = alloc.allocate(cap * r);\n\t\trep(i, length)traits::construct(alloc, e_ + i, *(e + i));\n\t\trep(i, length)traits::destroy(alloc, e + i);\n\t\talloc.deallocate(e, cap);\n\t\te = e_;\n\t\tcap *= r;\n\t}\n\npublic:\n\n\ttemplate<class InputIter>\n\tvoid assign(InputIter first, InputIter last) {\n\t\tsize_type cnt = 0;\n\t\tfor (InputIter i = first; i != last; i++) {\n\t\t\tif (cnt == cap) {\n\t\t\t\tlength = std::max(length, cnt);\n\t\t\t\textension();\n\t\t\t}\n\t\t\ttraits::construct(alloc, e + cnt, *i);\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tvoid assign(size_type n, const_reference value) {\n\t\textension(n);\n\t\tstd::fill(e, e + n, value);\n\t}\n\n\ttemplate<class... Args>\n\tvoid emplace_back(Args&&... args) {\n\t\tif (length == cap)extension();\n\t\ttraits::construct(alloc, e + length, std::forward<Args>(args)...);\n\t\tlength++;\n\t}\n\n\tvoid push_back(const_reference value) {\n\t\templace_back(value);\n\t}\n\n\tvoid push_back(T&& value) {\n\t\templace_back(std::move(value));\n\t}\n\n\tvoid pop_back() {\n\t\ttraits::destroy(alloc, e + length);\n\t\tlength--;\n\t}\n\n\tvoid reserve(size_type n) {\n\t\textension(n);\n\t}\n\n\titerator erase(iterator pos) {\n\t\tconst iterator res = pos;\n\t\titerator t = pos; t++;\n\t\tfor (iterator i = pos; t != end(); i++, t++) {\n\t\t\t*i = std::move(*t);\n\t\t}\n\t\tpop_back();\n\t\treturn res;\n\t}\n\n\titerator erase(iterator first, iterator last) {\n\t\tconst iterator res = first;\n\t\ttypename iterator::difference_type d = last - first;\n\t\tfor (iterator i = first; i + d != end(); i++) {\n\t\t\t*i = std::move(*(i + d));\n\t\t}\n\t\trep(i, d)pop_back();\n\t\treturn res;\n\t}\n\n\tvoid swap(Vector& x) {\n\t\tstd::swap(length, x.length);\n\t\tstd::swap(cap, x.cap);\n\t\tstd::swap(e, x.e);\n\t}\n\n\tvoid clear() {\n\t\twhile (length)pop_back();\n\t}\n\n\tsize_type size()const {\n\t\treturn length;\n\t}\n\n\tvoid resize(size_type  n, const_reference value = T()) {\n\t\textension(n);\n\t\twhile (n < length)pop_back();\n\t\tlength = n;\n\t\tstd::fill(e, e + n, value);\n\t}\n\n\tsize_type capacity()const {\n\t\treturn cap;\n\t}\n\n\tbool empty()const {\n\t\treturn !length;\n\t}\n\n\treference operator[](const size_type pos)const {\n\t\treturn e[pos];\n\t}\n\n\tpointer data() {\n\t\treturn e;\n\t}\n\n\treference front() {\n\t\treturn *e;\n\t}\n\n\treference back() {\n\t\treturn *(e + length - 1);\n\t}\n\n\titerator begin() noexcept {\n\t\treturn iterator(*this, 0);\n\t}\n\n\tconst_iterator begin()const noexcept {\n\t\treturn const_iterator(*this, 0);\n\t}\n\n\tconst_iterator cbegin()const noexcept {\n\t\treturn const_iterator(*this, 0);\n\t}\n\n\titerator rbegin()noexcept {\n\t\treturn reverse_iterator(*this, 0);\n\t}\n\n\tconst_iterator rbegin()const noexcept {\n\t\treturn const_reverse_iterator(*this, 0);\n\t}\n\n\tconst_iterator crbegin()const noexcept {\n\t\treturn const_reverse_iterator(*this, 0);\n\t}\n\n\titerator end() noexcept {\n\t\treturn iterator(*this, length);\n\t}\n\n\tconst_iterator end()const noexcept {\n\t\treturn const_iterator(*this, length);\n\t}\n\n\tconst_iterator cend()const noexcept {\n\t\treturn const_iterator(*this, length);\n\t}\n\n\titerator rend()noexcept {\n\t\treturn reverse_iterator(*this, length);\n\t}\n\n\tconst_iterator rend()const noexcept {\n\t\treturn const_reverse_iterator(*this, length);\n\t}\n\n\tconst_iterator crend()const noexcept {\n\t\treturn const_reverse_iterator(*this, length);\n\t}\n\n};\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ninline lint gcd(lint a, lint b) {\n\twhile (b) {\n\t\tlint c = a;\n\t\ta = b; b = c % b;\n\t}\n\treturn a;\n}\ninline lint lcm(lint a, lint b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(lint n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\nlint mypow(lint a, lint b) {\n\tif (!b)return 1;\n\tif (b & 1)return mypow(a, b - 1) * a;\n\tlint memo = mypow(a, b >> 1);\n\treturn memo * memo;\n}\nlint modpow(lint a, lint b, lint m) {\n\tif (!b)return 1;\n\tif (b & 1)return modpow(a, b - 1, m) * a % m;\n\tlint memo = modpow(a, b >> 1, m);\n\treturn memo * memo % m;\n}\ntemplate<typename T>\nvoid printArray(std::vector<T>& vec) {\n\trep(i, vec.size() - 1)std::cout << vec[i] << \" \";\n\tstd::cout << vec.back() << std::endl;\n}\ntemplate<typename T>\nvoid printArray(Vector<T>& vec) {\n\trep(i, vec.size() - 1)std::cout << vec[i] << \" \";\n\tstd::cout << vec.back() << std::endl;\n}\ntemplate<typename T>\nvoid printArray(T l, T r) {\n\tT rprev = r;\n\trprev--;\n\tfor (T i = l; i != rprev; i++) {\n\t\tstd::cout << *i << \" \";\n\t}\n\tstd::cout << *rprev << std::endl;\n}\nstd::string to_string(Vector<int>& vec) {\n\tstd::string res = \"[\";\n\trep(i, vec.size() - 1)res += std::to_string(vec[i]) + \", \";\n\tres += std::to_string(vec.back()) + \"]\";\n\treturn res;\n}\ntemplate<unsigned int modulo = 1000000007>\nclass ModInt {\n\tlint value;\npublic:\n\tModInt() : value(0) {}\n\ttemplate<typename T>\n\tModInt(T value = 0) : value(value) {\n\t\tif (value < 0)value = -(lint)(-value % modulo) + modulo;\n\t\tthis->value = value % modulo;\n\t}\n\tinline operator int()const { return value; }\n\tinline ModInt& operator+=(const ModInt& x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline ModInt operator-()const {\n\t\treturn ModInt(0) -= *this;\n\t}\n\tinline ModInt& operator-=(const ModInt& x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator*=(const ModInt& x) {\n\t\tvalue = value * x.value % modulo;\n\t\treturn *this;\n\t}\n\tinline ModInt& operator/=(ModInt rhs) {\n\t\tint exp = modulo - 2;\n\t\twhile (exp) {\n\t\t\tif (exp & 1)*this *= rhs;\n\t\t\trhs *= rhs;\n\t\t\texp >>= 1;\n\t\t}\n\t\treturn *this;\n\t}\n\ttemplate<typename T> ModInt operator+(const T& rhs)const { return ModInt(*this) += rhs; }\n\ttemplate<typename T> ModInt& operator+=(const T& rhs) { return operator+=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator-(const T& rhs)const { return ModInt(*this) -= rhs; }\n\ttemplate<typename T> ModInt& operator-=(const T& rhs) { return operator-=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator*(const T& rhs)const { return ModInt(*this) *= rhs; }\n\ttemplate<typename T> ModInt& operator*=(const T& rhs) { return operator*=(ModInt(rhs)); }\n\ttemplate<typename T> ModInt operator/(const T& rhs)const { return ModInt(*this) /= rhs; }\n\ttemplate<typename T> ModInt& operator/=(const T& rhs) { return operator/=(ModInt(rhs)); }\n};\ntemplate<unsigned int T>\nstd::istream& operator>>(std::istream& ist, ModInt<T>& x) {\n\tlint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\nstd::string s;\nint k;\nint dp[310][310][310];\nint main() {\n\tstd::cin >> s >> k;\n\trep(i, s.size())dp[i][i + 1][0] = 1;\n\tREP(i, s.size()) {\n\t\trep(j, s.size() - i + 1) {\n\t\t\trep(l, k + 1) {\n\t\t\t\tif (j)chmax(dp[j - 1][j + i][l], dp[j][j + i][l]);\n\t\t\t\tif (j + i != s.size())chmax(dp[j][j + i + 1][l], dp[j][j + i][l]);\n\t\t\t\tif (j) {\n\t\t\t\t\tif (s[j - 1] == s[j + i]) {\n\t\t\t\t\t\tchmax(dp[j - 1][j + i + 1][l], dp[j][j + i][l] + 2);\n\t\t\t\t\t}\n\t\t\t\t\telse chmax(dp[j - 1][j + i + 1][l + 1], dp[j][j + i][l] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i, k + 1)chmax(ans, dp[0][s.size()][i]);\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 305;\n\nint dp[MAX_N][MAX_N][MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    int n = len(s);\n    int K;\n    cin >> K;\n    rep(i,n){\n        rep(j,K+1){\n            dp[i][i+1][j] = 1;\n        }\n    }\n    srep(l,1,n){\n        rep(i,n-l){\n            int j = i+l;\n            rep(k,K+1){\n                if(k) cmx(dp[i][j+1][k],dp[i][j+1][k-1]);\n                cmx(dp[i][j+1][k],dp[i][j][k]);\n                if(i) cmx(dp[i-1][j][k],dp[i][j][k]);\n                if(s[i] == s[j]) cmx(dp[i][j+1][k],dp[i+1][j][k]+2);\n                if(k < K) cmx(dp[i][j+1][k+1],dp[i+1][j][k]+2);\n            }\n        }\n    }\n    cout << dp[0][n][K] << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<cctype>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<cstdlib>\n#include<ctime>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<fstream>\n#define ld double\n#define ull unsigned long long\n#define ll long long\n#define pii pair<int,int >\n#define iiii pair<int,pii >\n#define mp make_pair\n#define INF 1000000000\n#define MOD 1000000007\n#define rep(i,x) for(int (i)=0;(i)<(x);(i)++)\ninline int getint(){\n    int x=0,p=1;char c=getchar();\n    while (c<=32)c=getchar();\n    if(c==45)p=-p,c=getchar();\n    while (c>32)x=x*10+c-48,c=getchar();\n    return x*p;\n}\nusing namespace std;\n//ruogu\nconst int N=310;\nint n,k,dp[N][N][N];\nchar s[N];\n//\nint go(int l,int r,int x){\n\tif(x<0)return 0;\n\tif(x>r-l+1)return -INF;\n\tif(l>r)return 0;\n\tif(l==r)return 1;\n\tif(dp[l][r][x]>=0)return dp[l][r][x];\n\tint ans=max(go(l+1,r,x),go(l,r-1,x));\n\tif(s[l]==s[r])ans=max(ans,go(l+1,r-1,x)+2);\n\tif(x>0)ans=max(ans,go(l+1,r-1,x-1)+2);\n\treturn dp[l][r][x]=ans;\n}\nint main(){\n\tmemset(dp,-1,sizeof(dp));\n\tscanf(\"%s\",s);\n\tn=strlen(s);\n\tscanf(\"%d\",&k);\n\tprintf(\"%d\\n\",go(0,n-1,k));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\ntypedef long double ld;\ntypedef long long ll;\n\nconst int M = 303;\n\nint n;\nstring s;\nint k;\nint d[M][M][M];\n\nvoid read() {\n  cin >> s >> k;\n  n = s.length();\n}\n\nvoid uax(int &x, int y) {\n  x = max(x, y);\n}\n\nvoid kill() {\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < n; ++j)\n      for (int t = 0; t <= k; ++t) {\n        int cur = d[i][j][t];\n        if (s[i] == s[n - 1 - j])\n          uax(d[i + 1][j + 1][t], cur + 1);\n        else\n          uax(d[i + 1][j + 1][t + 1], cur + 1);\n        uax(d[i + 1][j][t], cur);\n        uax(d[i][j + 1][t], cur);\n      }\n\n  int ans = 0;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; i + j < n; ++j)\n      for (int t = 0; t <= k; ++t)\n        uax(ans, 2 * d[i][j][t] + 1);\n\n  cout << ans << endl;\n}\n\nint main() {\n#ifdef LOCAL\n  assert(freopen(\"d.in\", \"r\", stdin));\n#endif\n\n  ios_base::sync_with_stdio(false);\n\n  read();\n  kill();\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=305,INF=1<<30;\nint dp[MAX][MAX][MAX];\n\nint main(){\n    \n    string S;cin>>S;\n    int N=S.size();\n    int K;cin>>K;\n    int maxi=0;\n    \n    for(int i=0;i<N;i++){\n        dp[i][i][0]=1;\n    }\n    \n    for(int w=1;w<N;w++){\n        for(int l=0;l<N;l++){\n            int r=l+w;\n            if(r>=N) continue;\n            for(int k=0;k<=K;k++){\n                if(k==0){\n                    if(S[l]==S[r]){\n                        dp[l][r][k]=max(dp[l][r][k],dp[l+1][r-1][k]+2);\n                    }else{\n                        dp[l][r][k]=max({dp[l][r][k],dp[l+1][r][k],dp[l][r-1][k],dp[l+1][r-1][k]});\n                    }\n                }else{\n                    if(S[l]==S[r]){\n                        dp[l][r][k]=max(dp[l][r][k],dp[l+1][r-1][k]+2);\n                    }else{\n                        dp[l][r][k]=max({dp[l][r][k],dp[l+1][r][k],dp[l][r-1][k],dp[l+1][r-1][k]});\n                        dp[l][r][k]=max({dp[l][r][k],dp[l+1][r-1][k-1]+2});\n                    }\n                }\n            }\n        }\n    }\n    \n    for(int k=0;k<=K;k++){\n        maxi=max(maxi,dp[0][N-1][k]);\n    }\n    \n    cout<<maxi<<endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for(int i = x; i < (int)(n); ++i)\n\nchar s[302];\nint dp[302][302];\n\nint main(){\n\tint k;\n\tscanf(\"%s%d\", s + 1, &k);\n\tint n = strlen(s + 1);\n\tf(i, 1, n + 1)for (int j = n; j > 0; --j){\n\t\tif (s[i] == s[j])dp[i][j] = 1 + dp[i - 1][j + 1];\n\t\telse dp[i][j] = max(dp[i - 1][j], dp[i][j + 1]);\n\t}\n\tint an = dp[n][1];\n\tf(i, 1, n){\n\t\tint sz1 = i, sz2 = n - i;\n\t\tint nv = dp[i][i + 1];\n\t\tnv = min(min(sz1, sz2), nv + k);\n\t\tan = max(an, nv << 1);\n\t}\n\tf(i, 1, n - 1){\n\t\tint sz1 = i, sz2 = n - i - 1;\n\t\tint nv = dp[i][i + 2];\n\t\tnv = min(min(sz1, sz2), nv + k);\n\t\tan = max(an, nv << 1 | 1);\n\t}\n\tprintf(\"%d\\n\", an);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nint main() {\n        string s;\n        cin >> s;\n        int k;\n        scanf(\"%d\", &k);\n        int n = s.size();\n        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>> (n + 1, vector<int> (n + 1, -1)));\n        function<int (int, int, int)> calc = [&](int l, int r, int t) {\n                if (dp[l][r][t] != -1) return dp[l][r][t];\n                if (l > r) return 0;\n                if (l == r) return 1;\n                int ma = 0;\n                if (s[l] == s[r]) ma = max(ma, calc(l + 1, r - 1, t) + 2);\n                ma = max(ma, calc(l + 1, r, t));\n                ma = max(ma, calc(l, r - 1, t));\n                if (t > 0) ma = max(ma, calc(l + 1, r - 1, t - 1) + 2);\n                return dp[l][r][t] = ma;\n        };\n        printf(\"%d\\n\", calc(0, n - 1, k));\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n変更箇所は順読み逆読みの少なくとも片方で役立たないといけない\nつまり1点分として加算される必要がある\n逆に1点分以上の役割は持てない<-嘘だった\n例えば右端の文字が他に存在しない文字ならそれを変更するのはOK\n*/\nint dp[400][400];\ntemplate<typename T>\nvoid fin(T a){\n  cout<<a<<endl;\n  exit(0);\n}\n\nsigned main(){\n  string s;int K;cin>>s>>K;\n  int N=s.size();\n  string t=s;\n  reverse(t.begin(),t.end());\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i][j]+(s[i]==t[j])});\n    }\n  }\n  int ans=dp[N][N];\n  if(K==0)fin(ans);\n  for(int k=0;k<N;k++){\n    for(int q=0;q<26;q++){\n      memset(dp,0,sizeof(dp));\n      char tmp=s[k];\n      s[k]=t[N-k-1]='a'+q;\n      for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n          dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i][j]+(s[i]==t[j])});\n        }\n      }\n      if(dp[N][N]>ans+1){\n        ans=dp[N][N];\n        K--;\n      }\n      else s[k]=t[N-k-1]=tmp;\n      if(K==0)fin(ans);\n    }\n  }\n  for(int k=0;k<N;k++){\n    for(int q=0;q<26;q++){\n      memset(dp,0,sizeof(dp));\n      char tmp=s[k];\n      s[k]=t[N-k-1]='a'+q;\n      for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n          dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i][j]+(s[i]==t[j])});\n        }\n      }\n      if(dp[N][N]>ans){\n        ans=dp[N][N];\n        K--;\n      }\n      else s[k]=t[N-k-1]=tmp;\n      if(K==0)fin(ans);\n    }\n  }\n  fin(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * File    : D.cpp\n * Author  : Kazune Takahashi\n * Created : 2018-2-24 22:16:49\n * Powered by Visual Studio Code\n */\n\n#include <iostream>\n#include <iomanip>   // << fixed << setprecision(xxx)\n#include <algorithm> // do { } while ( next_permutation(A, A+xxx) ) ;\n#include <vector>\n#include <string> // to_string(nnn) // substr(m, n) // stoi(nnn)\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map> // if (M.find(key) != M.end()) { }\n#include <set>\n#include <random> // random_device rd; mt19937 mt(rd());\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n#define DEBUG 0 // change 0 -> 1 if we need debug.\n\ntypedef long long ll;\n\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\n// const int C = 1e6+10;\n// const ll M = 1000000007;\n\nint dp[400][400];\nbool used[400];\n\nint lcs(string s, string t)\n{\n  fill(&dp[0][0], &dp[0][0] + 400 * 400, 0);\n  fill(used, used + 400, false);\n  int N = s.size();\n  int M = t.size();\n  for (auto i = 0; i < N; i++)\n  {\n    for (auto j = 0; j < M; j++)\n    {\n      if (s[i] == t[j])\n      {\n        dp[i + 1][j + 1] = dp[i][j] + 1;\n      }\n      else\n      {\n        dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);\n      }\n    }\n  }\n  int x = M, y = N;\n  while (x >= 1 && y >= 1)\n  {\n    if (dp[x][y] == dp[x-1][y-1] + 1)\n    {\n      used[x - 1] = true;\n      x--;\n      y--;\n    }\n    else if (dp[x][y] == dp[x-1][y])\n    {\n      x--;\n    }\n    else\n    {\n      y--;\n    }\n  }\n  return dp[N][M];\n}\n\nstring S;\nint K;\n\nint main()\n{\n  cin >> S >> K;\n  string T = S;\n  reverse(T.begin(), T.end());\n  if (K == 0)\n  {\n    cout << lcs(S, T) << endl;\n  }\n  else\n  {\n    int N = S.size();\n    lcs(S, T);\n    for (auto i = 0; i < N; i++)\n    {\n      if (K > 0 && !used[i])\n      {\n        used[i] = true;\n        for (auto j = N-1; j > i; j--)\n        {\n          if (!used[j])\n          {\n            used[j] = true;\n            break;\n          }\n        }\n        K--;\n      }\n    }\n    for (auto i = 0; i < N; i++)\n    {\n      if (K > 0 && !used[i])\n      {\n        used[i] = true;\n        K--;\n      }\n    }\n    int cnt = 0;\n    for (auto i = 0; i < N; i++)\n    {\n      if (used[i])\n        cnt++;\n    }\n    cout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n#define INF 1000000000\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint dp[333][333][333];\nstring s;\nint k;\n\nint dfs(int K,int L,int R)\n{\n//\tcout << K << ' ' << L << ' ' << R << endl;\n\tif(K < 0 || L > R)return 0;\n\tif(dp[K][L][R] != 0)return dp[K][L][R];\n\tint ret = 0;\n\tint p = 0;\n\tif(s[L] == s[R])p += 2;\n\tret = max(ret,dfs(K,L+1,R-1)+p);\n\tret = max(ret,dfs(K-1,L+1,R-1)+2);\n\tret = max(ret,dfs(K,L+1,R));\n\tret = max(ret,dfs(K,L,R-1));\n\t\n\treturn dp[K][L][R] = ret;\n}\n\n\nint main()\n{\n\tcin >> s >> k;\n\t\n\tREP(K,k)REP(i,333)dp[K][i][i] = 1;\n\tREP(K,k)REP(i,332)\n\t{\n\t\tif(s[i] == s[i+1])dp[K][i][i+1] = 2;\n\t\telse dp[K][i][i+1] = 1;\n\t}\n\t\n\tcout << dfs(k,0,s.size()-1) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nchar s[311];\nint dp[311][311][311],K;\nint main()\n{\n\tscanf(\"%s%d\",s,&K);int n=strlen(s);\n\tfor(int i=n;i>=1;i--)s[i]=s[i-1];\n\tfor(int i=1;i<=n;i++)dp[i][i][0]=1;\n\tfor(int len=2;len<=n;len++)\n\t{\n\t\tfor(int i=1;i+len-1<=n;i++)\n\t\t{\n\t\t\tint j=i+len-1;\n\t\t\tfor(int k=0;k<=min(len>>1,K);k++)\n\t\t\t{\n\t\t\t\tdp[i][j][k]=max(dp[i+1][j][k],dp[i][j-1][k]);\n\t\t\t\tif(s[i]==s[j])dp[i][j][k]=max(dp[i][j][k],dp[i+1][j-1][k]+2);\n\t\t\t\telse if(k>0)dp[i][j][k]=max(dp[i][j][k],dp[i+1][j-1][k-1]+2);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<=K;i++)ans=max(ans,dp[1][n][i]);\n\tprintf(\"%d\",ans);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar s[310];\nint K, f[310][310][610];\n\nint main() {\n    scanf(\"%s %d\", s + 1, &K), K <<= 1;\n    int n = strlen(s + 1);\n    memset(f, -1, sizeof(f));\n    function<int(int, int, int)> dfs = [&](int l, int r, int k) {\n        if (l > n || r < 1) return 0;\n        if (~f[l][r][k]) return f[l][r][k];\n        f[l][r][k] = max(dfs(l + 1, r, k), dfs(l, r - 1, k));\n        int t = s[l] != s[r];\n        if (l == r) t = 0;\n        if (k >= t) f[l][r][k] = max(f[l][r][k], dfs(l + 1, r - 1, k - t) + 1);\n        return f[l][r][k];\n    };\n    printf(\"%d\\n\", dfs(1, n, K));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nchar s[320];\nint f[320][320][320]; // [i, j] 修改k个\nint m;\nint main() {\n\tscanf(\"%s\", s);\n\tscanf(\"%d\", &m);\n\tint n = strlen(s);\n\tfor (int l = 0; l < n; l++) {\n\t\tfor (int i = 0; i + l < n; i++) {\n\t\t\tint j = i + l;\n\t\t\tfor (int k = 0; k <= m; k++) {\n\t\t\t\tf[i][j][k] = max(f[i][j - 1][k], f[i + 1][j][k]);\n\t\t\t\tif (s[i] == s[j]) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tf[i][j][k] = max(f[i][j][k], f[i + 1][j - 1][k] + 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tf[i][j][k] = max(f[i][j][k], f[i + 1][j - 1][k] + 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (k > 0 && i < j) {\n\t\t\t\t\tf[i][j][k] = max(f[i][j][k], f[i + 1][j - 1][k - 1] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", f[0][n - 1][m]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-8\n#define pi 3.14159265358979\n#define LL long long\n#define MP make_pair\n#define PH push\n#define PB push_back\n#define PII pair<int,int>\n#define VI vector<int>\n#define X first\n#define Y second\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\n#define sqr(x) ((x)*(x))\n#define CL(a) memset(a,0,sizeof a)\n#define fr(i,n) for(int i=1;i<=n;i++)\n#define FR(i,S,n) for(int i=S;i<=n;i++)\n#define dr(i,n) for(int i=n;i;i--)\n#define DR(i,n,S) for(int i=n;i>=S;i--)\n#define SZ(x) ((int)(x).size())\n#define rd(x) scanf(\"%d\",&x)\n#define pr(x) printf(\"%d\",x)\nconst int N=305;\nLL Pw(LL a,LL b,LL p){LL v=1;for(;b;b>>=1,a=a*a%p)if(b&1)v=v*a%p;return v;}\nusing namespace std;\nint n,m,i,j,k;char s[N];short f[N][N][N*2];\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);rd(m);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\tfor(k=0;k<=m*2;k++){\n\t\t\t\tif(s[i]==s[n-j+1]){\n\t\t\t\t\tf[i][j][k]=f[i-1][j-1][k]+1;\n\t\t\t\t}\n\t\t\t\tf[i][j][k]=max(f[i-1][j][k],f[i][j-1][k]);\n\t\t\t\tif(k)f[i][j][k]=max((int)f[i][j][k],f[i-1][j-1][k-1]+1);\n\t\t\t}\n\tprintf(\"%d\",(int)f[n][n][m*2]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n変更箇所は順読み逆読みの少なくとも片方で役立たないといけない\nつまり1点分として加算される必要がある\n逆に1点分以上の役割は持てない<-嘘だった\n例えば右端の文字が他に存在しない文字ならそれを変更するのはOK\n*/\n/*\n問題概要は最長の回文を作れ？\nだとすると中心決めてしまえばそこからは書き換えるかどうかは片側だけに注目すればよくて\nsBtに対してsを右側から見ていくことを考える\n変えるならt[now]しかありえなくて、書き換えた方がいいかどうかチェックするのに150^2かかる？\nなんか違いそう\n端から見て言ってdp[i][j][k]で考えるべき？\ndp[i][j][k]:左からi文字右からj文字、k文字変更した時の最長回文\ndp[i][j][k]=max(dp[i][j-1][k],dp[i-1][j][k],dp[i-1][j-1][k]+(s[i]==s[N-j-1]),dp[i-1][j-1][k-1]+1)\n*/\nint dp[400][400][400];\nsigned main(){\n  string s;int K;cin>>s>>K;\n  int N=s.size();\n  int ans=0;\n  for(int k=0;k<=K;k++){\n    for(int i=1;i<N;i++){\n      for(int j=1;i+j<=N;j++){\n        dp[i][j][k]=max({dp[i][j-1][k],dp[i-1][j][k],dp[i-1][j-1][k]+2*(s[i-1]==s[N-j])});\n        if(k)dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k-1]+2);\n        ans=max(ans,dp[i][j][k]+(i+j<N));\n      }\n    }\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#pragma GCC optimize(1)\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"inline\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-fipa-sra\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-ffast-math\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fdevirtualize\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"inline-functions\")\n#pragma GCC optimize(\"-ftree-tail-merge\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fpartial-inlining\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"inline-small-functions\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"inline-functions-called-once\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#include<bits/stdc++.h>\n#define R register\nusing namespace std;\nchar s[351];int len,k;\nint f[351][351][351],ans;\ninline void read(R int &x)\n{\n    x=0;R int f=1;\n\tR char c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n        if(c=='-') f=-1;\n        c=getchar();\n    }\n    while(c>=48&&c<=57)\n\t{\n        x=(x<<1)+(x<<3)+(c^48);\n        c=getchar();\n    }\n\tx=x*f;\n}\ninline void input_data()\n{\n\tchar ch=getchar();\n\twhile(ch>='a'&&ch<='z')\n\t\ts[++len]=ch,ch=getchar();\n\tread(k);return;\n}\nint dfs(R int k,R int l,R int r)\n{\n\tif(l>r) return false;\n\tif(l==r) return s[l]==s[r];\n\tif(f[k][l][r]) return f[k][l][r];\n\tf[k][l][r]=max(dfs(k,l+1,r),dfs(k,l,r-1));\n\tif(s[l]==s[r]) f[k][l][r]=max(f[k][l][r],dfs(k,l+1,r-1)+2);\n\tif(k>=1) f[k][l][r]=max(f[k][l][r],dfs(k-1,l+1,r-1)+2);\n\treturn f[k][l][r];\n}\nint main()\n{\n\tinput_data();\n\tfor(R int i=0;i<=k;++i)\n\t\tans=max(ans,dfs(i,1,len));\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <utility>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#define my_abs(x) ((x) < 0 ? -(x) : (x))\n#define mp std::make_pair\n#define pb push_back\n#define X first\n#define Y second\ntypedef long long ll; \nchar str[305]; \nint dp[305][305][305], n; \nint calc(int l, int r, int k)\n{\n\tif (k < 0)\n\t\treturn -1e9; \n\tif (l > r || l >= n || r < 0)\n\t\treturn 0; \n\tif (~dp[l][r][k])\n\t\treturn dp[l][r][k]; \n\tint res = std::max(calc(l + 1, r, k), calc(l, r - 1, k)); \n\tif (str[l] == str[r])\n\t\tres = std::max(res, calc(l + 1, r - 1, k) + (l != r) + 1); \n\treturn dp[l][r][k] = std::max(res, calc(l + 1, r - 1, k - 1) + (l != r) + 1); \n}\nint main()\n{\n\t// freopen(\"AGC021-D.in\", \"r\", stdin); \n\tint k; \n\tscanf(\"%s%d\", str, &k); \n\tn = strlen(str); \n\tmemset(dp, -1, sizeof(dp)); \n\tprintf(\"%d\\n\", calc(0, n - 1, k));\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int ms = 311;\n\nint memo[ms][ms][ms][2];\n\nstring s;\n\nint dp(int k, int l, int r, int b) {\n  if (l == s.size() or r < 0) return 0;\n  if (r - l + 1 == b) return 0;\n  if (r - l + 1 < b) return -10000;\n  int &ans = memo[k][l][r][b];\n  if (ans != -1) return ans;\n  ans = max(dp(k, l + 1, r, b), dp(k, l, r - 1, b));\n  ans = max(ans, 0);\n  if (s[l] == s[r] and l < r) ans = max(ans, 1 + dp(k, l + 1, r - 1, b));\n  if (k and l < r) ans = max(ans, 1 + dp(k - 1, l + 1, r - 1, b));\n  // cout << k << ' ' << l << ' ' << r << ' ' << b << ' ' << ans << endl;\n  return ans;\n}\n\nint main() {\n  cin >> s;\n  int k;\n  cin >> k;\n  int ans = 0;\n  if (k >= s.size() / 2) ans = s.size();\n  memset(memo, -1, sizeof memo);\n  ans = max(ans, 2 * dp(k, 0, s.size() - 1, 0));\n  ans = max(ans, 2 * dp(k, 0, s.size() - 1, 1) + 1);\n  cout << min(ans, (int)s.size()) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define MT make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\n#define RT return\n#define vv(a,b,c,d) vector<vector<a> >(b,vector<a>(c,d))\n#define vvv(a,b,c,d,e) vector<vector<vector<a> > >(b,vv(a,c,d,e))\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\nint N, K;\nstring S;\nint f[301][301][301], INF = 1 << 29;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(20);\n\n    cin >> S >> K;\n    N = sz(S);\n\n    rep(i, N + 1)rep(j, N + 1)rep(k, K + 1)f[i][j][k] = INF;\n    f[0][N][0] = 0;\n\n    rep(i, N) for (int j = N; j > i; --j) rep(k, K + 1) {\n        int a = f[i][j][k];\n        if (S[i] == S[j - 1])smin(f[i + 1][j - 1][k], a);\n        if (k < K) smin(f[i + 1][j - 1][k + 1], a);\n        smin(f[i + 1][j][k], a + 1);\n        smin(f[i][j - 1][k], a + 1);\n    }\n\n    int mi = INF;\n    rep(i, N + 1)rep(j, i + 1)rep(k, K + 1) {\n        smin(mi, f[i][j][k]);\n    }\n    int ans = sz(S) - mi;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\tstring s; cin >> s;\n\tint n = s.size();\n\tint K; cin >> K;\n\tvector<vector<vector<int> > > dp(n, vector<vector<int> >(n, vector<int>(K+1, 0)));\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int k = 0; k < K+1; ++k) dp[i][i][k] = 1;\n\t\tif (i < n-1) {\n\t\t\tif (s[i] == s[i+1]) dp[i][i+1][0] = 2;\n\t\t\telse if (K > 0) dp[i][i+1][1] = 2;\n\t\t}\n\t}\n\tfor (int k = 0; k < K+1; ++k) {\n\t\tfor (int x = 1; x < n; ++x) {\n\t\t\tfor (int i = 0; i < n-x; ++i) {\n\t\t\t\tint j = i+x;\n\t\t\t\tif (k > 0) dp[i][j][k] = max(dp[i][j][k], dp[i][j][k-1]);\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i+1][j][k]);\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k]);\n\t\t\t\tif (s[i] == s[j] && x > 1) dp[i][j][k] = max(dp[i][j][k], dp[i+1][j-1][k] + 2);\n\t\t\t\telse if (k > 0 && x > 1) dp[i][j][k] = max(dp[i][j][k], dp[i+1][j-1][k-1] + 2);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][n-1][K] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\nint n, k, a[305][305][305], ans;\nchar s[305];\nint main(){\n\tscanf(\"%s\\n%d\", s, &k);\n\tn = (int)strlen(s);\n\trep(i,n) rep(j,n-1-i) rep(l,k+1){\n\t\tif(s[i] == s[n-1-j]) a[i+1][j+1][k] = a[i][j][k] + 1;\n\t\telse a[i+1][j+1][l] = max({a[i][j+1][l], a[i+1][j][l], l ? a[i+1][j+1][l-1]+1 : 0});\n\t}\n\trep(i,n+1) ans = max({ans, (i!=n?a[i][n-1-i][k]*2:0)+1, a[i][n-i][k]*2});\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define dro first\n#define adg second.first\n#define mog second.second\n#define ll long long\nusing namespace std;\n\nconst int N = 500001;\n\nint n,r,pos,l,x,U,D,S;\n \nlong long ans;\nint K;\n\nstring s;\n\nint fix[100],fix1[100],A[100],B[100];\n\nint dp[301][301][301];\n\nint main(){\n    \n    cin>>s;\n    \n    n=s.size();\n    \n    cin>>K;\n    \n    for(int j=0;j<2;j++)\n    for(int l=0;l+j<n;l++){\n        int r = l+j;\n        if(l==r){\n            dp[l][r][0] = 1;\n            //dp[l][r][1] = 1;\n            continue;\n        }\n\n        if(l+1==r){\n            dp[l][r][0] = 1;\n            if(s[l] == s[r]) dp[l][r][0] = 2;\n            dp[l][r][1] = 2;\n            dp[l][r][2] = 2;\n            continue;\n        }\n    }\n\n    for(int j=2;j<n;j++)\n    for(int l=0;l+j<n;l++)\n    for(int k=0;k<=min(l+j-l+1,K);k++){\n\n        int r = l+j;\n        dp[l][r][k] = max( dp[l+1][r][k], dp[l][r-1][k]);\n        //cout<<dp[l+1][r][k]<<\" \"<<l<<\" \"<<r<<\" \"<<k<<endl;\n        //cout<<dp[l][r-1][k]<<\" \"<<l<<\" \"<<r<<\" \"<<k<<endl;\n        if(s[l]==s[r])\n            dp[l][r][k] = max( dp[l][r][k], dp[l+1][r-1][k] + 2);\n        else {\n            if(k-1>=0)\n            dp[l][r][k] = max( dp[l][r][k], dp[l+1][r-1][k-1] + 2);\n        }\n\n        //cout<<dp[l][r][k]<<\" \"<<l<<\" \"<<r<<\" \"<<k<<endl;\n    }\n    \n    cout<<dp[0][n-1][K]<<endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar s[310];\nint K, f[310][310][610];\n\nint main() {\n    scanf(\"%s %d\", s + 1, &K);\n    int n = strlen(s + 1);\n    memset(f, -1, sizeof(f));\n    function<int(int, int, int)> dfs = [&](int l, int r, int k) {\n        if (r - l < 1) return r - l + 1;\n        if (~f[l][r][k]) return f[l][r][k];\n        f[l][r][k] = max(dfs(l + 1, r, k), dfs(l, r - 1, k));\n        int t = s[l] != s[r];\n        if (k >= t) f[l][r][k] = max(f[l][r][k], dfs(l + 1, r - 1, k - t) + 2);\n        return f[l][r][k];\n    };\n    printf(\"%d\\n\", dfs(1, n, K));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <locale>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> int len(const T &x) { return x.size(); }\n\ntemplate<typename T>\nvector<T> table(int n, T v) { return vector<T>(n, v); }\n\ntemplate <class... Args>\nauto table(int n, Args... args) {\n  auto val = table(args...);\n  return vector<decltype(val)>(n, move(val));\n}\n\nstruct yes_no : numpunct<char> {\n  string_type do_truename()  const { return \"Yes\"; }\n  string_type do_falsename() const { return \"No\"; }\n};\n\nstring S;\nint dp[310][310][310];\nbool memo[310][310][310];\n\nint dfs(int l, int r, int k) {\n  if (k < 0) return -1e9;\n  if (l > r) return 0;\n  if (l == r) return 1;\n  int &m = dp[l][r][k];\n  if (memo[l][r][k]) return m;\n  int res = dfs(l, r - 1, k);\n  chmax(res, dfs(l + 1, r, k));\n  if (S[l] == S[r]) chmax(res, dfs(l + 1, r - 1, k) + 2);\n  else chmax(res, dfs(l + 1, r - 1, k - 1) + 2);\n  memo[l][r][k] = true;\n  return m = res;\n}\n\nint main() {\n  locale loc(locale(), new yes_no);\n  cout << boolalpha << setprecision(12) << fixed;\n  cout.imbue(loc);\n\tll K;\n\tcin >> S;\n\tcin >> K;\n  const int n = S.size();\n  cout << dfs(0, n - 1, K) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma comment(linker, \"/STACK:108777216\")\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <functional>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <deque>\n#include <utility>\n#include <algorithm>\n#include <ctime>\nusing namespace std;\n\nint const MAX_N = 128 * 3;\n\nint exist[MAX_N], lst[MAX_N], ms[MAX_N];\nint n;\nint dp[2][MAX_N];\n\nint calc(const string & st) {\n\tint from = 0;\n\tfill(dp[from], dp[from] + n+1, 0);\n\tfor (int i=1; i<=n; i++) {\n\t\tint to = 1-from;\n\t\tmemcpy(dp[to], dp[from], (n+1)*sizeof(int));\n\t\tfor (int j=1; j<=n; j++) {\n\t\t\tdp[to][j] = max(dp[to][j], dp[to][j-1]);\n\t\t\tif (st[i-1] == st[n-j])\n\t\t\t\tdp[to][j] = max(dp[to][j], dp[from][j-1] + 1);\n\t\t}\n\t\tswap(from, to);\n\t}\n\n\treturn dp[from][n];\n}\n\nint main() {\n\t//freopen(\"input.txt\",\"r\",stdin);\n\t//freopen(\"output.txt\",\"w\",stdout);\n\n\tstring st;\n\tcin>>st;\n\tint k;\n\tcin>>k;\n\n\tn = (int) st.length();\n\n\tfor (int i=0; i<(int) st.length(); i++)\n\t\texist[st[i]-'a']++;\n\n\tint lst_len = 0;\n\tfor (int i=0; i<26; i++)\n\t\tif (exist[i]) lst[lst_len++] = 'a' + i;\n\n\tint i = 0, j = n-1;\n\tint ms_len = 0;\n\twhile (i <= j) {\n\t\tms[ms_len++] = i;\n\t\tif (i!=j) ms[ms_len++] = j;\n\t\ti++; j--;\n\t}\n\n\tint last_fnd = -1;\n\n\twhile (k-->0) {\n\t\tint ans_i = -1, ans_iind = -1, mx = -1;\n\t\tchar ans_ch = 0;\n\t\tfor (int iind=last_fnd+1; iind<n; iind++) {\n\t\t\tint i = ms[iind];\n\t\t\tfor (int ch_ind = 0; ch_ind < lst_len; ch_ind++) {\n\t\t\t\tstring q = st;\n\t\t\t\tq[i] = lst[ch_ind];\n\t\t\t\tint loc_ans = calc(q);\n\t\t\t\tif (loc_ans > mx) {\n\t\t\t\t\tmx = loc_ans;\n\t\t\t\t\tans_i = i;\n\t\t\t\t\tans_iind = iind;\n\t\t\t\t\tans_ch = lst[ch_ind];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tst[ans_i] = ans_ch;\n\t\tlast_fnd = ans_iind;\n\t}\n\tcout<<calc(st);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define inf 1000000000\n\nusing namespace std;\n\nstring s;\nint N, K;\nint dp[305][305][305];\n\nint main(void)\n{\ncin >> s >> K;\nN = s.size();\ns = \" \" + s;\n\nfor(int i = 0; i <= N; i++){\nfor(int j = 0; j <= N; j++){\nfor(int k = 0; k <= K; k++){\ndp[i][j][k] = -inf;\n}\n}\n}\nfor(int i = 0; i <= N; i++) dp[i][0][0] = dp[0][i][0] = 0;\n\n\nfor(int i = 1; i <= N; i++){\nfor(int j = 1; j <= N; j++){\nfor(int k = 0; k <= K; k++){\n\nif(i+j > N+1){\n\tcontinue;\n}\n\nif(s[i] == s[N-j+1]){\ndp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k] + 1);\n}\nelse{\ndp[i][j][k] = max(dp[i][j][k], max(dp[i-1][j][k], dp[i][j-1][k]));\nif(k > 0) dp[i][j][k] = max(dp[i][j][k], dp[i][j][k-1] + 1);\n}\n\n\n}\n}\n}\n\n/*for(int k = 0; k <= K; k++){\nfor(int i = 0; i <= N; i++){\nfor(int j = 0; j <= N; j++){\ncout << dp[i][j][k] << \" \";\n}cout << endl;\n}cout << endl;\n}*/\n\nint ans = 0;\nfor(int k = 0; k <= K; k++){\nfor(int i = 0; i <= N; i++){\nfor(int j = 0; j <= N; j++){\nif(i+j != N+1) continue;\nint tmp = dp[i][j][k] * 2;\nif(s[i] == s[N-j+1]) tmp--;\nans = max(ans, tmp);\n}\n}\n}\n\ncout << ans << endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define whole(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bit(n) (1LL<<(n))\n// functions\ntemplate <typename T> void unique(T& c){c.erase(std::unique(c.begin(), c.end()), c.end());}\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1000000007;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(nullptr); cout << fixed << setprecision(20);}\n} fast_io_;\n\nint dp[310][310][310];\n\nint main(int argc, char const* argv[])\n{\n  string s; cin >> s;\n  int k; cin >> k;\n  int n = sz(s);\n  rep(i, n){\n    for(int j = n - 1; j > i; j--){\n      rep(l, k + 1){\n        chmax(dp[i+1][j+1][l], dp[i][j+1][l]);\n        chmax(dp[i+1][j+1][l], dp[i+1][j+2][l]);\n        if(s[i] == s[j])chmax(dp[i+1][j+1][l], 1 + dp[i][j+2][l]);\n        else chmax(dp[i+1][j+1][l], dp[i][j+2][l]);\n        if(s[i] != s[j] && l > 0){\n          chmax(dp[i+1][j+1][l], 1 + dp[i][j+2][l-1]);\n        }\n      }\n    }\n  }\n  int res = 0;\n  for(int i = 0; i < n - 1; i++){\n    for(int l = 0; l <= k; l++){\n      chmax(res, dp[i+1][i+2][l] * 2);\n      chmax(res, 1 + dp[i][i+2][l] * 2);\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll int\n#define f first\n#define s second\n#define pb push_back\nusing namespace std;\nll dp[301][301][301],k;\nstring s;\ninline ll solve(ll x,ll y,ll p){\n    if(dp[x][y][p])return dp[x][y][p];\n    if(x == y){\n        dp[x][y][p] = 1;\n        return dp[x][y][p];\n    }\n    if(x + 1 == y){\n        if(s[x] == s[y] || p)dp[x][y][p] = 2;\n        else dp[x][y][p] = 1;\n        return dp[x][y][p];\n    }\n    if(p == 0){\n        if(s[x] == s[y]){\n            dp[x][y][p] = solve(x + 1 ,y - 1, p) + 2;\n            return dp[x][y][p];\n        }\n        ll t = solve(x , y - 1 , p);\n        ll r = solve(x + 1 , y , p);\n        dp[x][y][p] = max(t,r);\n        return dp[x][y][p];\n    }\n    if(s[x] == s[y]){\n        dp[x][y][p] = solve(x + 1, y - 1 , p) + 2;\n        return dp[x][y][p];\n    }\n    dp[x][y][p] = solve(x + 1 , y - 1 , p);\n    ll t = solve(x , y - 1 , p);\n    ll r = solve(x + 1 , y , p);\n    ll q = solve(x + 1 , y - 1, p - 1) + 2;\n    q = max(q , max(t , r));\n    if(dp[x][y][p] < q)dp[x][y][p] = q;\n    return dp[x][y][p];\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin >> s >> k;\n    \n    cout << solve(0 , (int)s.size() - 1 , k);\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\nconstexpr ll MOD=1e9+7;\n//constexpr ll MOD=998244353;\n//constexpr ll MOD=10000000;\nconstexpr ll MAX=1e7;\nconstexpr ll INF=(1ll<<62);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\n/*struct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,int a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nll modpow(ll X,ll Y,ll mod){\n    ll sum=X,cnt=1;\n    vi A;\n    while(cnt<=Y){\n        A.pb(sum);\n        sum*=sum;\n        sum%=mod;\n        cnt*=2;\n    }\n    int M=A.size();\n    ll ret=1;\n    REP(i,1,M){\n        if(Y>=(1ll<<M-i)){\n            Y-=(1ll<<M-i);\n            ret*=A[M-i];\n            ret%=mod;\n        }\n    }\n    return ret;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}*/\nsigned main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    string S; cin>>S;\n    ll K; cin>>K;\n    ll N=S.size();\n    vii dp(N+1,vi(K+1,-1));\n    dp[0][0]=N;\n    rep(i,0,N/2){\n        vi memo(N+1,-1);\n        rep(j,0,N){\n            memo[j+1]=memo[j];\n            if(S[i]==S[j]) memo[j+1]=j;\n        }\n        rep(j,0,N){\n            rep(k,0,K) dp[j+1][k+1]=std::max(dp[j+1][k+1],dp[j][k]-1);\n            REP(k,0,K){\n                if(dp[j][k]*2<=N) continue;\n                dp[j+1][k]=std::max(dp[j+1][k],memo[dp[j][k]]);\n            }\n        }\n    }\n    ll ans=0;\n    REP(i,1,N){\n        REP(j,0,K){\n            if(dp[i][j]*2>N) ans=i;\n        }\n    }\n    ans*=2;\n    ans+=N%2;\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int ms = 311;\n\nint memo[ms][ms][ms];\n\nstring s;\n\nint dp(int k, int l, int r) {\n  if (l == s.size() or r < 0) return 0;\n  int &ans = memo[k][l][r];\n  if (ans != -1) return ans;\n  ans = max(dp(k, l + 1, r), dp(k, l, r - 1));\n  if (s[l] == s[r]) ans = max(ans, 1 + dp(k, l + 1, r - 1));\n  if (k) ans = max(ans, 1 + dp(k - 1, l + 1, r - 1));\n  return ans;\n}\n\nint main() {\n  cin >> s;\n  int k;\n  cin >> k;\n  memset(memo, -1, sizeof memo);\n  cout << dp(0, 0, s.size() - 1) + k * 2 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-8\n#define pi 3.14159265358979\n#define LL long long\n#define MP make_pair\n#define PH push\n#define PB push_back\n#define PII pair<int,int>\n#define VI vector<int>\n#define X first\n#define Y second\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\n#define sqr(x) ((x)*(x))\n#define CL(a) memset(a,0,sizeof a)\n#define fr(i,n) for(int i=1;i<=n;i++)\n#define FR(i,S,n) for(int i=S;i<=n;i++)\n#define dr(i,n) for(int i=n;i;i--)\n#define DR(i,n,S) for(int i=n;i>=S;i--)\n#define SZ(x) ((int)(x).size())\n#define rd(x) scanf(\"%d\",&x)\n#define pr(x) printf(\"%d\",x)\nconst int N=305;\nLL Pw(LL a,LL b,LL p){LL v=1;for(;b;b>>=1,a=a*a%p)if(b&1)v=v*a%p;return v;}\nusing namespace std;\nint n,m,i,j,k;char s[N];int f[2][N][N*2];\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);rd(m);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\tfor(k=0;k<=m*2;k++){\n\t\t\t\tif(s[i]==s[n-j+1])f[i%2][j][k]=f[(i-1)%2][j-1][k]+1;else f[i%2][j][k]=0;\n\t\t\t\tf[i%2][j][k]=max(f[i%2][j][k],max(f[(i-1)%2][j][k],f[i%2][j-1][k]));\n\t\t\t\tif(k)f[i%2][j][k]=max((int)f[i%2][j][k],f[(i-1)%2][j-1][k-1]+1);\n\t\t\t}\n\tprintf(\"%d\",f[n%2][n][m*2]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n#define pb push_back\n#define mp make_pair\nint dp[301][301][601];\nint main()\n{\n    int i,j;\n    string a;\n    int k;\n    cin>>a;\n    cin>>k;\n    int n=a.size();\n\n            int z=1;\n    for(z=0;z<=2*k;z++)\n  {\n\n    for(i=1;i<=n;i++)\n    {\n        for(j=n;j>=1;j--)\n        {\n          int o=n-j+1;\n\n              if(i!=j)\n              {    if(z!=0)\n                      dp[i][o][z]=max(dp[i][o][z],dp[i][o][z-1]);\n                  if(a[i-1]==a[j-1])\n                     dp[i][o][z]=max(dp[i][o][z],1+dp[i-1][o-1][z]);\n                  else\n                  {\n                      if(z!=0)\n                      dp[i][o][z]=max(dp[i][o][z],dp[i-1][o-1][z-1]+1);\n\n                      dp[i][o][z]=max(dp[i][o][z],max(dp[i-1][o][z],dp[i][o-1][z]));\n\n                  }\n\n\n              }\n              else{\n                 if(z!=0)\n                      dp[i][o][z]=dp[i][o][z-1];\n                 dp[i][o][z]=max(dp[i][o][z],1+dp[i-1][o-1][z]);\n\n\n                }\n\n\n        }\n\n\n\n\n    }\n\n\n\n\n\n  }\n  int ans=0;\n\n        ans=dp[n][n][2*k];\n\n\n    cout<<ans<<endl;\nreturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAXSIZE=10000020;\nint bufpos;\nchar buf[MAXSIZE];\n#define NEG 0\nvoid init(){\n    #ifdef LOCAL\n        freopen(\"D.txt\",\"r\",stdin);\n    #endif\n    buf[fread(buf,1,MAXSIZE,stdin)]='\\0';\n    bufpos=0;\n}\n#if NEG\nint readint(){\n    bool isneg;\n    int val=0;\n    for(;!isdigit(buf[bufpos]) && buf[bufpos]!='-';bufpos++);\n    bufpos+=(isneg=buf[bufpos]=='-');\n    for(;isdigit(buf[bufpos]);bufpos++)\n        val=val*10+buf[bufpos]-'0';\n    return isneg?-val:val;\n}\n#else\nint readint(){\n    int val=0;\n    for(;!isdigit(buf[bufpos]);bufpos++);\n    for(;isdigit(buf[bufpos]);bufpos++)\n        val=val*10+buf[bufpos]-'0';\n    return val;\n}\n#endif\nchar readchar(){\n    for(;isspace(buf[bufpos]);bufpos++);\n    return buf[bufpos++];\n}\nint readstr(char* s){\n    int cur=0;\n    for(;isspace(buf[bufpos]);bufpos++);\n    for(;!isspace(buf[bufpos]);bufpos++)\n        s[cur++]=buf[bufpos];\n    s[cur]='\\0';\n    return cur;\n}\nint dp[302][302][302];\nchar s[302];\ninline void relax(int &x,int y){\n    if (x>y)\n        x=y;\n}\nint main(){\n    init();\n    int n=readstr(s+1),m=readint();\n    memset(dp,0x3f,sizeof(dp));\n    for(int i=0;i<=n+1;i++){\n        memset(dp[i][i],0,sizeof(dp[i][i]));\n        if (i)\n            memset(dp[i][i-1],0,sizeof(dp[i][i-1]));\n    }\n    for(int len=2;len<=n;len++)\n        for(int i=1;i<=n;i++){\n            int j=i+len-1;\n            if (j>n)\n                break;\n            for(int k=0;k<=m;k++){\n                if (k)\n                    dp[i][j][k]=dp[i+1][j-1][k-1];\n                if (s[i]==s[j])\n                    relax(dp[i][j][k],dp[i+1][j-1][k]);\n                relax(dp[i][j][k],dp[i+1][j][k]+1);\n                relax(dp[i][j][k],dp[i][j-1][k]+1);\n            }\n        }\n    printf(\"%d\",n-dp[1][n][m]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nchar s[400];\nint memo[310][310][310], n;\nbool done[310][310][310];\nint dp(int i, int j, int k)\n{\n\tif (i > j) return 0;\n\tif (i == n) return 0;\n\tif (j == -1) return 0;\n\tif (done[i][j][k]) return memo[i][j][k];\n\tdone[i][j][k] = true;\n\tint ans = dp(i+1, j, k);\n\tans = max(ans, dp(i, j-1, k));\n\tif (s[i] == s[j]) ans = max(ans, dp(i+1, j-1, k)+1+(i != j));\n\tif (k)\n\t{\n\t\tans = max(ans, dp(i+1, j-1, k-1)+1 + (i != j));\n\t}\n\t//printf(\"%d %d %d - %d\\n\", i, j, k, ans);\n\treturn memo[i][j][k] = ans;\n}\nint main()\n{\n\tscanf(\" %s\", s);\n\tn = strlen(s);\n\tint k;\n\tscanf(\"%d\", &k);\n\tint ans = dp(0, n-1, k);\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\ntemplate <typename H>\nH max(const H &head) {\n\treturn head;\n}\ntemplate <typename H, typename ...Tail>\nH max(const H &head, const Tail&... tail) {\n\tauto tail_max = max(tail...);\n\treturn head > tail_max ? head : tail_max;\n}\n\nint max_lcs(const std::string &str, int l, int r, int k, std::vector<std::vector<std::vector<int>>> &memo) {\n\tif (l > r) return -2;\n\tif (k < 0) return -2;\n\tif (l == r) return 1;\n\tif (memo[l][r][k] >= 0) return memo[l][r][k];\n\tint res;\n\tif (str[l] == str[r]) {\n\t\tres = max_lcs(str, l + 1, r - 1, k, memo) + 2;\n\t}\n\telse {\n\t\tres = max_lcs(str, l + 1, r - 1, k, memo);\n\t}\n\tres = max(res, max_lcs(str, l + 1, r, k, memo), max_lcs(str, l, r - 1, k, memo), max_lcs(str, l + 1, r - 1, k - 1, memo) + 2);\n\treturn memo[l][r][k] = res;\n}\nint max_lcs(const std::string &str, int k) {\n\tstd::vector<std::vector<std::vector<int>>> memo(str.size() + 1, std::vector<std::vector<int>>(str.size() + 1, std::vector<int>(k + 1, -1)));\n\treturn max_lcs(str, 0, str.size() - 1, k, memo);\n}\n\nint main() {\n\tstd::string str;\n\tint k;\n\tstd::cin >> str >> k;\n\tstd::cout << max_lcs(str, k) << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nchar buf[310];\nint n,k;\nint mx[310][310][310];\nint ans;\nint main()\n{\n\tscanf(\"%s%d\",buf,&k);\n\tn=strlen(buf);\n\tans=1;\n\tfor(int l=1;l<=n;l++)\n\t{\n\t\tfor(int i=0;i+l-1<n;i++)\n\t\t{\n\t\t\tint j=i+l-1;\n\t\t\tif(l==1)mx[i][j][0]=1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int t=0;t<=k;t++)\n\t\t\t\t{\n\t\t\t\t\tmx[i][j][t]=max(mx[i+1][j][t],mx[i][j-1][t]);\n\t\t\t\t\tif(buf[i]==buf[j])\n\t\t\t\t\t{\n\t\t\t\t\t\tmx[i][j][t]=max(mx[i][j][t],mx[i+1][j-1][t]+2);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(t)mx[i][j][t]=max(mx[i][j][t],mx[i+1][j-1][t-1]+2);\n\t\t\t\t\t}\n\t\t\t\t\tans=max(ans,mx[i][j][t]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 305;\n\nint dp[MAX_N][MAX_N][MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    int n = len(s);\n    int K;\n    cin >> K;\n    rep(i,n){\n        rep(j,K+1){\n            dp[i][i+1][j] = 1;\n        }\n    }\n    srep(l,1,n){\n        rep(i,n-l){\n            int j = i+l;\n            rep(k,K+1){\n                if(k) cmx(dp[i][j+1][k],dp[i][j+1][k-1]);\n                cmx(dp[i][j+1][k],dp[i][j][k]);\n                if(s[i] == s[j]) cmx(dp[i][j+1][k],dp[i+1][j][k]+2);\n                if(k < K) cmx(dp[i][j+1][k+1],dp[i+1][j][k]+2);\n            }\n        }\n    }\n    cout << dp[0][n][K] << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\n\nconst int oo = 0x3f3f3f3f;\n\nconst int maxn = 310, maxk = 310;\n\nint n, K;\nchar a[maxn + 5], b[maxn + 5];\nint f[maxn + 5][maxn + 5][maxk + 5];\n\nint main()\n{\n#ifdef matthew99\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tscanf(\"%s%d\", a, &K);\n\tn = strlen(a);\n\tstrcpy(b, a);\n\treverse(b, b + n);\n\tREP(i, 0, n) REP(j, 0, n) if (i + j <= n - 1)\n\t\tREP(k, 0, K + 1)\n\t\t{\n\t\t\tif (a[i] == b[j] || k > 0) f[i][j][k] = 1 + (i + j < n - 1);\n\t\t\tif (i > 0 && j > 0) \n\t\t\t{\n\t\t\t\tif (a[i] == b[j]) f[i][j][k] += f[i - 1][j - 1][k];\n\t\t\t\telse if (k > 0) f[i][j][k] += f[i - 1][j - 1][k - 1];\n\t\t\t}\n\t\t\tif (i > 0) chkmax(f[i][j][k], f[i - 1][j][k]);\n\t\t\tif (j > 0) chkmax(f[i][j][k], f[i][j - 1][k]);\n\t\t\tif (k > 0) chkmax(f[i][j][k], f[i][j][k - 1]);\n\t\t}\n\tint ans = 0;\n\tREP(i, 0, n) chkmax(ans, f[i][n - 1 - i][K]);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint dp[301][301][301];\nint main()\n{\n\tstring str;\n\tint q;\n\tcin>>str>>q;\n\tint l=str.size();\n//\tcout<<l<<endl;\n\tfor(int i=l-1;i>=0;i--)\n\t{\n\t\tfor(int k=0;k<=q;k++)\n\t\t\tdp[i][i][k]=1;\n\t}\n\tfor(int i=l-1;i>=0;i--)\n\t{\n\t\t\n\t\tfor(int j=i+1;j<=l-1;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=q;k++)\n\t\t\t{\n\t\t\t\t//dp[i][i][k]=1; \n\t\t\t\tif(str[i]==str[j]) dp[i][j][k]=dp[i+1][j-1][k]+2;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(k!=0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][j][k]=max(dp[i+1][j][k-1]+2,dp[i][j-1][k-1]+2);\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j][k]=max(dp[i+1][j][k],dp[i][j][k]);\n\t\t\t\t\tdp[i][j][k]=max(dp[i][j-1][k],dp[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[0][l-1][q]<<endl;\n } "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint64_t dp[310][310][310];\nstring s;int64_t K;\nint main(){\ncin>>s>>K;\n  int64_t N=s.size();\n  for(int i=0;i<N;i++)\n    dp[i][i][0]=1;\n  for(int i=0;i<N-1;i++)\n    if(s.at(i)==s.at(i+1))\n      dp[i][i+1][0]=2;\n  else\n    dp[i][i+1][0]=1;\n  for(int j=2;j<=N-1;j++)\n    for(int i=0;i<N-j;i++){\n    if(s.at(i)==s.at(i+j))\n      dp[i][i+j][0]=2+dp[i+1][i+j-1][0];\n      else\n        dp[i][i+j][0]=max(dp[i+1][i+j][0],dp[i][i+j-1][0]);\n    }for(int i=0;i<N-1;i++)\n      for(int j=1;j<=K;j++)\n      dp[i][i+1][j]=2;\n  for(int k=1;k<=K;k++)\n      for(int j=2;j<=N-1;j++)\n        for(int i=0;i<N-j;i++){\n        if(s.at(i)==s.at(i+j))\n          dp[i][i+j][k]=2+dp[i+1][i+j-1][k];\n          else\ndp[i][i+j][k]=max(max(2+dp[i+1][i+j-1][k-1],dp[i][i+j-1][k]),dp[i+1][i+j][k]);\n          \n        }cout<<dp[0][N-1][K]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define dro first\n#define adg second.first\n#define mog second.second\n#define ll long long\nusing namespace std;\n\nconst int N = 500001;\n\nint n,r,pos,l,x,U,D,S;\n \nlong long ans;\nint K;\n\nstring s;\n\nint fix[100],fix1[100],A[100],B[100];\n\nint dp[305][305][305];\n\nint main(){\n    \n    cin>>s;\n    \n    n=s.size();\n    \n    cin>>K;\n    \n    for(int j=0;j<n;j++)\n    for(int l=0;l+j<n;l++)\n    for(int k=0;k<=K;k++){\n        \n        int r = l+j;\n        \n        if(l==r){\n            dp[l][r][0] = 1;\n            continue;\n            //dp[l][r][1] = 1\n        }\n\n        if(l+1==r){\n            if(k==0){\n                dp[l][r][k] = 1;\n                if(s[l] == s[r]) dp[l][r][k] = 2;\n            } else {\n                dp[l][r][k] = 2;\n            }\n            \n            continue;\n        }\n        \n        dp[l][r][k] = max( dp[l+1][r][k], dp[l][r-1][k]);\n        //cout<<dp[l+1][r][k]<<\" \"<<l<<\" \"<<r<<\" \"<<k<<endl;\n        //cout<<dp[l][r-1][k]<<\" \"<<l<<\" \"<<r<<\" \"<<k<<endl;\n        if(s[l]==s[r])\n            dp[l][r][k] = max( dp[l][r][k], dp[l+1][r-1][k] + 2);\n        else {\n            if(k-1>=0)\n            dp[l][r][k] = max( dp[l][r][k], dp[l+1][r-1][k-1] + 2);\n        }\n\n        //cout<<dp[l][r][k]<<\" \"<<l<<\" \"<<r<<\" \"<<k<<endl;\n    }\n    \n    cout<<dp[0][n-1][K]<<endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ninline int read(){\n\tchar c=getchar();while (c!='-'&&(c<'0'||c>'9'))c=getchar();\n\tint k=1,kk=0;if (c=='-')c=getchar(),k=-1;\n\twhile (c>='0'&&c<='9')kk=kk*10+c-'0',c=getchar();return kk*k;\n}using namespace std;\nvoid write(int x){if (x<0)putchar('-'),x=-x;if (x/10)write(x/10);putchar(x%10+'0');}\nvoid writeln(int x){write(x);puts(\"\");}\nint f[301][301][301],kk,ans,l;\nchar s[1000];\nsigned main(){\n\tscanf(\"%s\",s);kk=read();l=strlen(s);//f[i][j][k]为i到i+j-1最多修改k个后变成回文最少插入的个数 \n\tmemset(f,10,sizeof(f));for (int i=1;i<=l;i++)f[i][0][0]=f[i][1][0]=0; \n\tfor (int j=2;j<=l;j++)\n\t\tfor (int i=1;i+j-1<=l;i++)\n\t\t\tfor (int k=0;k<=kk;k++){\n\t\t\t\tif (k)f[i][j][k]=f[i][j][k-1];\n\t\t\t\tif (s[i-1]!=s[i+j-2]){\n\t\t\t\t\tf[i][j][k]=min(f[i][j][-],min(f[i][j-1][k],f[i+1][j-1][k])+1);//插入一发\n\t\t\t\t\tif (k)f[i][j][k]=min(f[i][j][k],f[i+1][j-2][k-1]);//修改一发 \n\t\t\t\t}else f[i][j][k]=min(f[i][j][k],f[i+1][j-2][k]);\n\t\t\t}\n\twriteln(l-f[1][l][kk]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define REP(e,v) for(auto e:v)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\n#define MAX_V 400010\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\n\n#define INF 1e9+7\n#define LLINF 1e18+7\nll MOD=924844033;\n#define N 1055050\n\nll n,m,k;\nstring s;\nvector<vec> mm(300,vec(1,-1));\nvector<vector<vec>> mem(300,vector<vec>(300,vec(300,-1)));\nint dfs(int l,int r,int c){\n    if(c>k)return -2;\n    if(l>r)return 0;\n    if(l==r)return 1;\n    if(mem[l][r][c]!=-1) return mem[l][r][c];\n    if(s[l]==s[r]){\n        return mem[l][r][c]=2+dfs(l+1,r-1,c);\n    }\n    int count=0;\n    count=max(dfs(l+1,r,c),count);\n    count=max(count,dfs(l,r-1,c));\n    count=max(count,dfs(l+1,r-1,c+1)+2);\n    return mem[l][r][c]=count;\n}\n\nmain(){\n    cin>>s;\n    n=s.size();\n    k=in();\n    cout<<dfs(0,n-1,0);\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring s;\nint n, dp[305][305][305];\nint go(int l, int r, int k) {\n\tif (dp[l][r][k] != -1) return dp[l][r][k];\n\tif (l == r) {\n\t\treturn dp[l][r][k] = 1;\n\t}\n\tif (l + 1 == r) {\n\t\tif (s[l] == s[r] || k) {\n\t\t\treturn dp[l][r][k] = 2;\n\t\t} else {\n\t\t\treturn dp[l][r][k] = 1;\n\t\t}\n\t}\n\tdp[l][r][k] = max(go(l + 1, r, k), go(l, r - 1, k));\n\tif (s[l] == s[r]) {\n\t\tdp[l][r][k] = max(dp[l][r][k], go(l + 1, r - 1, k) + 2);\n\t} else if (k) {\n\t\tdp[l][r][k] = max(dp[l][r][k], go(l + 1, r - 1, k - 1) + 2);\n\t}\n\treturn dp[l][r][k];\n}\nint main() {\n\tint k;\n\tcin >> s >> k;\n\tn = s.size();\n\tmemset(dp, -1, sizeof(dp));\n\tcout << go(0, n - 1, k) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define int long long\n\n#define all(X) (X).begin(), (X).end()\n#define reset(X) memset(X, 0, sizeof(X))\n#define mp(a, b) make_pair(a, b)\n#define pb push_back\n// #define endl '\\n'\n#define fi first\n#define se second\n\nusing namespace __gnu_pbds;\nusing namespace std;\nconst int mod = 1e9 + 7;\n// const int mod=998244353;\n//const int mod=1e9+9;\n//const int INF=4e18+10;\nconst int INF = 4e18 + 10;\ntemplate <typename T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T>\nusing ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define read(n) \\\nint n;      \\\ncin >> n;\n#define readv(x, n)   \\\nvector<int> x(n); \\\nfor (auto &i : x) \\\n    cin >> i;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> pii;\n\ntemplate <typename T1, typename T2>\nvoid set_min(T1 &a, T2 b)\n{\n    a = min(a, (T1)b);\n}\n\nint multiply(int a, int b, int in_mod) { return (a * b) % in_mod; }\nint mult_identity(int a) { return 1; }\n\n\nauto power(auto a, int b, int in_mod)\n{\n    auto prod = mult_identity(a);\n    auto mult = a % in_mod;\n    while (b != 0)\n    {\n        if (b % 2)\n        {\n            prod = multiply(prod, mult, in_mod);\n        }\n        mult = multiply(mult, mult, in_mod);\n        b /= 2;\n    }\n    return prod;\n}\nint mod_inv(int q, int in_mod)\n{\n\n    return power(q, in_mod - 2, in_mod);\n}\n\nint n;\nvector<vector<int>> g, gt;\nvector<bool>used;\nvector<int> order,comp;\nvector<bool> assignment;\n\nvoid dfs1(int v)\n{\n    used[v] = true;\n    for(int u:g[v])\n        if(!used[u])\n            dfs1(u);\n    order.pb(v);\n}\n\nvoid dfs2(int v, int cl)\n{\n    comp[v] = cl;\n    for(auto u:gt[v])\n        if(comp[u] ==-1)\n            dfs2(u, cl);\n}\n\nbool solve_2SAT()\n{\n    used.assign(n, false);\n    for(int i= 0;i<n;i++)\n        if(!used[i])\n            dfs1(i);\n\n    comp.assign(n,-1);\n    for(int i= 0,j=0;i<n;++i)\n    {\n        int v= order[n-i-1];\n        if(comp[v] == -1)\n            dfs2(v, j++);\n    }\n    assignment.assign(n/2, false);\n    for(int i= 0;i<n;i+=2)\n    {\n        if(comp[i] == comp[i+1])\n\n            return false;\n        assignment[i/2] = comp[i]>comp[i+1];\n    }\n    return true;\n}\n\n\n// void  solve()\n// {\n//     int n;\n//     cin>>n;\n//     int a, b;\n//     cin>>a>>b;\n//     readv(p,n);\n//     map<int, bool> cnt;\n//     for(auto i:p)\n//         cnt[i] = true;\n\n//     map<int, int> marking;\n\n//     int ind = 0;\n//     for(auto i:p)\n//         if(!marking[i])\n//             marking[i] = ind++;\n\n\n//     ::n = 2*ind+2;\n//     g.resize(::n);\n//     gt.resize(::n);\n//     for(auto i:p)\n//     {\n//         int it = marking[i];\n//         int other = marking[a-i];\n//         int otherother = marking[b-i];\n//         if(cnt[a-i])\n//         {\n//             g[2*it].pb(2*other);\n//             g[2*it+1].pb(2*it);\n//             g[2*other].pb(2*it);\n//             g[2*other+1].pb(2*other);\n\n//             gt[2*other].pb(2*it);\n//             gt[2*it].pb(2*it+1);\n\n//             gt[2*it].pb(2*other);\n//             gt[2*other].pb(2*other+1);\n//         }\n//         else\n//         {\n\n//             if(cnt[b-i])\n//             {\n\n//                 g[2*it+1].pb(2*otherother+1);\n//                 g[2*it].pb(2*it+1);\n//                 g[2*otherother+1].pb(2*it+1);\n//                 g[2*otherother].pb(2*otherother+1);\n\n//                 gt[2*otherother+1].pb(2*it+1);\n//                 gt[2*it+1].pb(2*it);\n//                 gt[2*it+1].pb(2*otherother+1);\n//                 gt[2*otherother + 1].pb(2*otherother);\n\n//             }\n//             else\n//             {\n//                 cout<<\"NO\"<<endl;\n//                 return;\n//             }\n//         }\n//         if(cnt[a-i] && cnt[b-i])\n//         {\n//                 g[2*it].pb(2*otherother);\n//                 g[2*it].pb(2*other);\n//                 g[2*it+1].pb(2*otherother+1);\n//                 g[2*it+1].pb(2*other+1);\n\n//                 g[2*otherother].pb(2*it);\n//                 g[2*otherother].pb(2*other);\n//                 g[2*otherother+1].pb(2*it+1);\n//                 g[2*otherother+1].pb(2*other+1);\n\n//                 g[2*other].pb(2*it);\n//                 g[2*other].pb(2*otherother);\n//                 g[2*other+1].pb(2*otherother+1);\n//                 g[2*other + 1].pb(2*it + 1);\n\n//                 gt[2*it].pb(2*otherother);\n//                 gt[2*it].pb(2*other);\n//                 gt[2*it+1].pb(2*otherother+1);\n//                 gt[2*it+1].pb(2*other+1);\n\n//                 gt[2*otherother].pb(2*it);\n//                 gt[2*otherother].pb(2*other);\n//                 gt[2*otherother+1].pb(2*it+1);\n//                 gt[2*otherother+1].pb(2*other+1);\n\n//                 gt[2*other].pb(2*it);\n//                 gt[2*other].pb(2*otherother);\n//                 gt[2*other+1].pb(2*otherother+1);\n//                 gt[2*other + 1].pb(2*it + 1);\n//         }\n//     }\n\n//     bool flag = solve_2SAT();\n\n//     if(flag)\n//     {\n//         cout<<\"YES\"<<endl;\n//         for(auto i:p)\n//             cout<<1-assignment[marking[i]]<<\" \";\n//     }\n//     else\n//     {\n//         cerr<<\"method1\"<<endl;\n//         cout<<\"NO\"<<endl;\n//     }\n\n// }\nvoid solve()\n{\n    string s;\n    cin>>s;\n    int k;\n    cin>>k;\n    int n= s.size();\n    vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(k+1)));\n\n\n    for(int len = 1;len<=n;len++)\n    {\n        for(int l = 0;l+len-1<n;l++)\n        {\n            int r= l+len-1;\n            for(int _k=0;_k<=k;_k++)\n            {\n                if(len == 1)\n                    dp[l][r][_k] =1;\n                else\n                {\n                    if(s[l] == s[r])\n                        dp[l][r][_k] =2 +dp[l+1][r-1][_k];\n                    else\n                    {\n                        dp[l][r][_k] = max(dp[l+1][r][_k], dp[l][r-1][_k]);\n                        if(_k)\n                            dp[l][r][_k] = max(dp[l][r][_k], 2+dp[l+1][r-1][_k-1]); \n                    }\n                }\n            }\n        }\n    }\n    cout<<dp[0][n-1][k]<<endl;\n}\n\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cerr.tie(NULL);\n#ifndef ONLINE_JUDGE\n    if (fopen(\"INPUT.txt\", \"r\"))\n    {\n        freopen(\"INPUT.txt\", \"r\", stdin);\n        freopen(\"OUTPUT.txt\", \"w\", stdout);\n    }\n#endif\n    auto clk = clock();\n    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n    // -------------------------------------Code starts here---------------------------------------------------------------------\n\n    int t = 1;\n    // cin >> t;\n\n    for (int test = 1; test <= t; test++)\n    {\n        // cout<<\"Case #\"<<test<<\":\\n\";\n        //cout<<\"Trip #\"<<test<<\": \";\n        // cout<<endl;\n        solve();\n        // solveB();\n\n        // cout<<endl;\n    }\n\n    // -------------------------------------Code ends here------------------------------------------------------------------\n\n    clk = clock() - clk;\n    // cerr << fixed << setprecision(6) << \"Time: \" << ((long double)clk) / CLOCKS_PER_SEC << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N, K;\nint dp[310][310][310];\nbool used[26];\nstring str;\n\nint loop(int a, int b, int k) {\n\tif(k < 0) return -inf;\n\telse if(a > b + 1) return 1;\n\telse if(a == b + 1) return 0;\n\telse if(a == b) return 1;\n\telse if(dp[a][b][k] != -1) return dp[a][b][k];\n\telse {\n\t\tint res = 1;\n\t\tif(str[a] == str[b]) {\n\t\t\tMAX(res, loop(a + 1, b - 1, k) + 2);\n\t\t}\n\t\telse {\n\t\t\tMAX(res, loop(a + 1, b, k));\n\t\t\tMAX(res, loop(a, b - 1, k));\n\t\t\tMAX(res, loop(a + 1, b - 1, k - 1) + 2);\n\t\t\tfor(int i = a; i < b; i++) {\n\t\t\t\tif(str[i] == str[b]) {\n\t\t\t\t\tMAX(res, loop(i + 1, b - 2, k - 1) + 2);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = b; i > a; i--) {\n\t\t\t\tif(str[i] == str[a]) {\n\t\t\t\t\tMAX(res, loop(a + 2, i - 1, k - 1) + 2);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[a][b][k] = res;\n\t}\n}\n\nvoid solve() {\n\tmemset(dp, -1, sizeof(dp));\n\tcin >> str >> K;\n\tN = sz(str);\n\tcout << loop(0, N - 1, K) << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define inf 1000000000000000000\n#define llint long long \n\nusing namespace std;\n\nstring s;\nllint N, K;\nllint dp[305][305][305];\n\nint main(void)\n{\ncin >> s >> K;\nN = s.size();\ns = \" \" + s;\n\nfor(llint i = 0; i <= N; i++){\nfor(llint j = 0; j <= N; j++){\nfor(llint k = 0; k <= K; k++){\ndp[i][j][k] = -inf;\n}\n}\n}\nfor(llint i = 0; i <= N; i++) dp[i][0][0] = dp[0][i][0] = 0;\n\n\nfor(llint i = 1; i <= N; i++){\nfor(llint j = 1; j <= N; j++){\nfor(llint k = 0; k <= K; k++){\n\nif(i+j > N+1){\n\tcontinue;\n}\n\nif(s[i] == s[N-j+1]){\ndp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k] + 1);\n}\nelse{\ndp[i][j][k] = max(dp[i][j][k], max(dp[i-1][j][k], dp[i][j-1][k]));\nif(k > 0) dp[i][j][k] = max(dp[i][j][k], dp[i][j][k-1] + 1);\n}\n\n\n}\n}\n}\n\n/*for(llint k = 0; k <= K; k++){\nfor(llint i = 0; i <= N; i++){\nfor(llint j = 0; j <= N; j++){\ncout << dp[i][j][k] << \" \";\n}cout << endl;\n}cout << endl;\n}*/\n\nllint ans = 0;\nfor(llint k = 0; k <= K; k++){\nfor(llint i = 0; i <= N; i++){\nfor(llint j = 0; j <= N; j++){\nif(i+j != N+1) continue;\nllint tmp = dp[i][j][k] * 2;\nif(s[i] == s[N-j+1]) tmp--;\nans = max(ans, tmp);\n}\n}\n}\n\ncout << ans << endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nstring S;\nint dp[305][305][305];\nint K;\n\nint main() {\n    //cout.precision(10);\n    cin >> S;\n    cin >> K;\n    int n = S.size();\n    S = \"#\" + S;\n    int ans = 0;\n    for(int k = 0; k <= K; k++) {\n        for(int i = 0; i < n; i++) {\n            for(int j = n + 1; j >= max(1, i); j--) {\n                ans = max(ans, dp[i][j][k]);\n                //cerr << i << \" \" << j << \" \" << k << \" \" << dp[i][j][k] << endl;\n                dp[i+1][j][k] = max(dp[i+1][j][k], dp[i][j][k]);\n                dp[i][j-1][k] = max(dp[i][j-1][k], dp[i][j][k]);\n                if(S[i+1] == S[j-1]) {\n                    if(i+1 == j-1) dp[i+1][j-1][k] = max(dp[i+1][j-1][k], dp[i][j][k]+1);\n                    else dp[i+1][j-1][k] = max(dp[i+1][j-1][k], dp[i][j][k] + 2);\n                }\n                if(i+1 == j-1) dp[i+1][j-1][k+1] = max(dp[i+1][j-1][k+1], dp[i][j][k] + 1);\n                else dp[i+1][j-1][k+1] = max(dp[i+1][j-1][k+1], dp[i][j][k] + 2);\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 405\nusing namespace std;\nchar s[N];int K,dp[N][N][N];\nint main(){\n\tscanf(\"%s\",s+1);scanf(\"%d\",&K);\n\tint n=strlen(s+1);\n\tfor (int i=1;i<=n;i++) dp[i][i][0]=1;\n\tfor (int len=2;len<=n;len++){\n\t\tfor (int l=1;l<=n-len+1;l++){\n\t\t\tint r=l+len-1;\n\t\t\tif (s[l]==s[r]){\n\t\t\t\tfor (int k=0;k<=K;k++)\n\t\t\t\t\tdp[l][r][k]=max(dp[l][r][k],dp[l+1][r-1][k]+2);\n\t\t\t\tfor (int k=0;k<=K;k++) dp[l][r][k]=max(dp[l+1][r][k],dp[l][r][k]),dp[l][r][k]=max(dp[l][r][k],dp[l][r-1][k]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int k=0;k<=K;k++) dp[l][r][k]=max(dp[l+1][r][k],dp[l][r][k]),dp[l][r][k]=max(dp[l][r][k],dp[l][r-1][k]);\n\t\t\t\tfor (int k=1;k<=K;k++) dp[l][r][k]=max(dp[l+1][r-1][k-1]+2,dp[l][r][k]);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor (int i=0;i<=K;i++) ans=max(ans,dp[1][n][i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=310;\nint n,m,dp[N][N][N];\nchar s[N];\nint main()\n{\n\tscanf(\"%s%d\",s+1,&m);\n\tn=strlen(s+1);\n\tfor (int i=1;i<=n;i++) dp[i][i][0]=1;\n\tfor (int len=2;len<=n;len++)\n\t{\n\t\tfor (int i=1;i<=n-len+1;i++)\n\t\t{\n\t\t\tint j=i+len-1;\n\t\t\tfor (int k=0;k<=m;k++)\n\t\t\t{\n\t\t\t\tdp[i][j][k]=max(dp[i][j][k],dp[i+1][j][k]);\n\t\t\t\tdp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k]);\n\t\t\t\tdp[i][j][k]=max(dp[i][j][k],dp[i+1][j-1][k]);\n\t\t\t\tif (s[i]==s[j]) dp[i][j][k]=max(dp[i][j][k],dp[i+1][j-1][k]+2);\n\t\t\t\telse if (k>0) dp[i][j][k]=max(dp[i][j][k],dp[i+1][j-1][k-1]+2);\n\t\t\t}\n\t\t}\n\t}\n\t// for (int len=1;len<=n;len++)\n\t// {\n\t// \tfor (int i=1;i<=n-len+1;i++)\n\t// \t{\n\t// \t\tint j=i+len-1;\n\t// \t\tfor (int k=0;k<=m;k++)\n\t// \t\t{\n\t// \t\t\tprintf(\"%d %d %d: %d\\n\",i,j,k,dp[i][j][k]);\n\t// \t\t}\n\t// \t}\n\t// }\n\tint ans=0;\n\tfor (int k=0;k<=m;k++) ans=max(ans,dp[1][n][k]);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FOR(i, a, b) for(ll i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(ll i = (a); i > (b); --i)\n#define REP(i, n) for(ll i = 0; i < (n); ++i)\n#define REPR(i, n) for(ll i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt __builtin_popcount\n#define SZ(x) ((ll)(x).size())\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\n#define CINT(...)                                                              \\\n    int __VA_ARGS__;                                                           \\\n    CIN(__VA_ARGS__)\n#define DCIN(...)                                                              \\\n    double __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    ll __VA_ARGS__;                                                            \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Yes(a) cout << (a ? \"Yes\" : \"No\") << \"\\n\"\n#define YES(a) cout << (a ? \"YES\" : \"NO\") << \"\\n\"\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        FOREACH(x, v) { cout << x << \" \"; }                                    \\\n        cout << \"\\n\";                                                          \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef vector<ll> VL;\ntypedef pair<ll, ll> PL;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\nconst double PI = atan(1.0) * 4.0;\n// const int MOD = 998244353;\nconst ll LINF = 9e18;\nconst ll dx[] = {1, 0, -1, 0};\nconst ll dy[] = {0, 1, 0, -1};\n\nstring S;\nll K;\nusing tp = tuple<ll, ll, ll>;\nmap<tp, ll> memo;\n\nll dp(ll s, ll t, ll k) {\n    ll &res = memo[tp(s, t, k)];\n    if(res) return res;\n    if(s == t)\n        res = 1;\n    else if(s + 1 == t)\n        res = (S[s] == S[t] ? 2 : 1);\n    else {\n        res = max({res, dp(s + 1, t, k), dp(s, t - 1, k)});\n        if(S[s] == S[t])\n            res = max(res, dp(s + 1, t - 1, k) + 2);\n        else if(k > 0)\n            res = max(res, dp(s + 1, t - 1, k - 1) + 2);\n    }\n    return res;\n}\n\nsigned main() {\n    cin >> S >> K;\n    ll N = S.length();\n    cout << dp(0, N - 1, K) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 305\nusing namespace std;\nchar c[N];\nint i,j,k,l,s,n,m,ans,f[N][N][N];\nint main() {\n\tscanf(\"%s\",c+1);\n\tn=strlen(c+1);\n\tscanf(\"%d\",&m);\n\tfor (i=1;i<=n;i++) f[i][i][0]=1;\n\tfor (i=1;i<n;i++) {\n\t\tif (c[i]==c[i+1]) f[i][i+1][0]=2;\n\t\telse f[i][i+1][1]=2;\n\t}\n\tfor (i=1;i<=n;i++) for (j=1;j+i-1<=n;j++) for (k=0;k<=m;k++) {\n\t\tint L=j-1,R=j+i;\n\t\tif (!f[L+1][R-1][k]) continue;\n\t\tif (L&&R<=n) {\n\t\t\tif (c[L]==c[R]) f[L][R][k]=max(f[L][R][k],f[L+1][R-1][k]+2);\n\t\t\telse if (k<m) f[L][R][k+1]=max(f[L][R][k+1],f[L+1][R-1][k]+2);\n\t\t}\n\t\tf[L+1][R][k]=max(f[L+1][R][k],f[L+1][R-1][k]);\n\t\tf[L][R-1][k]=max(f[L][R-1][k],f[L+1][R-1][k]);\n\t}\n\tfor (i=0;i<=n;i++) for (j=1;j<=n+1;j++) for (k=0;k<=m;k++) ans=max(ans,f[i][j][k]);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n変更箇所は順読み逆読みの少なくとも片方で役立たないといけない\nつまり1点分として加算される必要がある\n逆に1点分以上の役割は持てない<-嘘だった\n例えば右端の文字が他に存在しない文字ならそれを変更するのはOK\n*/\nint dp[400][400];\n\nsigned main(){\n  string s;int K;cin>>s>>K;\n  int N=s.size();\n  string t=s;\n  reverse(t.begin(),t.end());\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i][j]+(s[i]==t[j])});\n    }\n  }\n  cout<<min(N,dp[N][N]+K*2)<<endl;\n  //そんなわけない\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstring s, t;\n\nconst int N = 301;\n\nint dp[N][N][N];\nint n;\n\nint f(int n1, int n2, int k) {\n    if (dp[n1][n2][k] != -1) {\n        return dp[n1][n2][k];\n    }\n    if (!n1 || !n2) {\n        return dp[n1][n2][k] = 0;\n    }\n    if (s[n1 - 1] == t[n2 - 1]) {\n        return dp[n1][n2][k] = f(n1 - 1, n2 - 1, k) + 1;\n    }\n    dp[n1][n2][k] = 0;\n    if (k && (s[n1 - 1] != s[n - n1] || s[n2 - 1] != s[n - n2]) && min(n1, n2) > (n + 1) / 2) {\n        dp[n1][n2][k] = f(n1 - 1, n2 - 1, k - 1) + 2;\n    }\n    dp[n1][n2][k] = max(dp[n1][n2][k], f(n1 - 1, n2, k));\n    dp[n1][n2][k] = max(dp[n1][n2][k], f(n1, n2 - 1, k));\n    return dp[n1][n2][k];\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int k;\n    cin >> s >> k;\n    t = s;\n    reverse(t.begin(), t.end());\n    n = s.length();\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            for (int l = 0; l < N; ++l) {\n                dp[i][j][l] = -1;\n            }\n        }\n    }\n    cout << f(n, n, k);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,inline,unroll-loops,fast-math\")\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#define N 320\nusing namespace std;\n\nchar a[N];\nint f[N][N][N];\n\nint main(void)\n{\n    int n, k;\n    int i, j, t, o;\n\n    scanf(\"%s %d\", a + 1, &k);\n    n = strlen(a + 1);\n\n    for(i = 1, o = 0; i <= n; i ++)\n        for(j = n; j > i; j --)\n            for(t = 0; t <= k; t ++)\n            {\n                f[i][j][t] = max(f[i - 1][j][t], f[i][j + 1][t]);\n                if(a[i] == a[j])\n                    f[i][j][t] = max(f[i][j][t], f[i - 1][j + 1][t] + 1);\n                else if(t)\n                    f[i][j][t] = max(f[i][j][t], f[i - 1][j + 1][t - 1] + 1);\n\n                // printf(\"left %d, right %d, change %d : %d\\n\", i, j, t, f[i][j][t]);\n                o = max(o, f[i][j][t] * 2);\n            }\n    printf(\"%d\\n\", o);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, x, y) for(int i = x; i <= y; i ++)\n#define rrep(i, x, y) for(int i = x; i >= y; i --)\n#define ll long long\n#define X first\n#define Y second\n#define pb push_back\n#define mp make_pair\n#define pii pair<ll, ll>\n#define ls rt << 1\n#define rs rt << 1 | 1\n#define sz(x) (int)(x).size()\n#define ALL(x) (x).insgin(), (x).end()\n#define vi vector<int>\n#define EPS 1e-8\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }\n\treturn x * f;\n}\ninline ll read1()\n{\n\tll x = 0, f = 1; char ch = getchar();\n\twhile (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }\n\twhile (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }\n\treturn x * f;\n}\n\nint n, K;\nchar s[310];\nint f[305][305][305];\n\nint main()\n{\n\tscanf(\"%s\", s + 1);\n\tn = strlen(s + 1);\n\tK = read();\n\trep(k, 0, K)\n\t\trrep(i, n, 1)\n\t\t{\n\t\t\tf[i][i][k] = 1;\n\t\t\trep(j, i + 1, n)\n\t\t\t{\n\t\t\t\tf[i][j][k] = max(f[i + 1][j][k], f[i][j - 1][k]);\n\t\t\t\tif(s[i] == s[j]) f[i][j][k] = max(f[i][j][k], f[i + 1][j - 1][k] + 2);\n\t\t\t\tif(k) f[i][j][k] = max(f[i][j][k], f[i + 1][j - 1][k - 1] + 2);\n\t\t\t}\n\t\t}\n\tcout << f[1][n][K];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PP;\n\n/*\n    freopen(\"input\",\"r\",stdin);\n    freopen(\"output\",\"w\",stdout);\n*/\n\nint A[301][301];\nint B[301][301];\nint N;\n\nint get_a(int a, int b) {\n\tif (a < 0 || b >= N) return 0;\n\treturn A[a][b];\n}\n\nint get_b(int a, int b) {\n\tif (a < 0 || b >= N) return 0;\n\treturn B[a][b];\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    string s;\n    cin >> s;\n    N = s.size();\n    int K;\n    cin >> K;\n    if (K * 2 + 1 >= N) {\n    \tcout << N << endl;\n    \treturn 0;\n    }\n    memset(A, 0, sizeof(A));\n    int res = 0;\n    for (int i = 0;i < N;i++) {\n    \tfor (int j = N - 1;j >= i;j--) {\n    \t\tif (i != j) {\n    \t\t\tif (s[i] == s[j]) {\n    \t\t\t\tA[i][j] = max(A[i][j], get_a(i - 1, j + 1) + 2);\n    \t\t\t\tA[i][j] = max(A[i][j], get_a(i - 1, j));\n    \t\t\t\tA[i][j] = max(A[i][j], get_a(i, j + 1));\n    \t\t\t}\n    \t\t\telse {\n    \t\t\t\tA[i][j] = max(A[i][j], get_a(i - 1, j + 1));\n    \t\t\t\tA[i][j] = max(A[i][j], get_a(i - 1, j));\n    \t\t\t\tA[i][j] = max(A[i][j], get_a(i, j + 1));\n    \t\t\t}\n    \t\t}\n    \t\telse {\n    \t\t\tA[i][j] = max(A[i][j], get_a(i - 1, j + 1) + 1);\n    \t\t}\n    \t}\n    }\n    for (int i = 0;i < N;i++) res = max(res, A[i][i]);\n    for (int k = 1;k <= K;k++) {\n    \tmemset(B, 0, sizeof(B));\n    \tfor (int i = 0;i < N;i++) {\n    \t\tfor (int j = N - 1;j >= i;j--) {\n    \t\t\tif (i != j) {\n    \t\t\t\tif (s[i] == s[j]) {\n    \t\t\t\tB[i][j] = max(B[i][j], get_b(i - 1, j + 1) + 2);\n    \t\t\t\tB[i][j] = max(B[i][j], get_b(i - 1, j));\n    \t\t\t\tB[i][j] = max(B[i][j], get_b(i, j + 1));\n    \t\t\t}\n    \t\t\telse {\n    \t\t\t\tB[i][j] = max(B[i][j], get_a(i - 1, j + 1) + 2);\n    \t\t\t\tB[i][j] = max(B[i][j], get_b(i - 1, j + 1));\n    \t\t\t\tB[i][j] = max(B[i][j], get_b(i - 1, j));\n    \t\t\t\tB[i][j] = max(B[i][j], get_b(i, j + 1));\n    \t\t\t}\n    \t\t\t}\n    \t\t\telse {\n    \t\t\t\tB[i][j] = max(B[i][j], get_b(i - 1, j + 1) + 1);\n    \t\t\t}\n    \t\t}\n    \t}\n    \tswap(A, B);\n    \tfor (int i = 0;i < N;i++) res = max(res, A[i][i]);\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <fstream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <climits>\n#include <bitset>\n#include <cassert>\n\nusing namespace std;\n\nconst int SIZE = 1 << 17;\n\nint pointer = SIZE;\nchar buffer[SIZE];\n\nchar Advance() {\n    if (pointer == SIZE) {\n        fread(buffer, 1, SIZE, stdin);\n        pointer = 0;\n    }\n    return buffer[pointer++];\n}\n\nint Read() {\n    int answer = 0,sign = 1;\n    char ch = Advance();\n    while (!isdigit(ch) && ch != '-')\n        ch = Advance();\n    if (ch == '-') {\n        ch = Advance();\n        sign = -1;\n    }\n    while (isdigit(ch)) {\n        answer = answer * 10 + ch - '0';\n        ch = Advance();\n    }\n    return answer * sign;\n}\n\nchar ReadCh() {\n    char ch = Advance();\n    while (!isalpha(ch))\n        ch = Advance();\n    return ch;\n}\n\nconst int MAXN = 300;\n\nint dp[1 + MAXN + 1][1 + MAXN + 1][1 + MAXN + 1];\nchar s[1 + MAXN + 1];\n\nint main() {\n    //freopen(\"tema.in\", \"r\", stdin);\n    //freopen(\"tema.out\", \"w\", stdout);\n    scanf(\"%s\", s + 1);\n    int p, n = strlen(s + 1);\n    scanf(\"%d\", &p);\n    for (int i = 1; i <= n; i++)\n        for (int j = n; j > i; j--)\n            for (int k = 0; k <= p; k++) {\n                dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j + 1][k]);\n                if (s[i] == s[j])\n                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j + 1][k] + 1);\n                else\n                    if (k > 0)\n                        dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j + 1][k - 1] + 1);\n            }\n    int answer = 0;\n    for (int i = 1; i < n; i++)\n        answer = max(answer, 2 * dp[i][i + 1][p]);\n    for (int i = 1; i <= n; i++)\n        answer = max(answer, 2 * dp[i - 1][i + 1][p] + 1);\n    printf(\"%d\\n\", answer);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\nchar s[400];\nint kk;\nint f[152][152][302];\n\nint main()\n{\n\tscanf(\"%s\",s);\n\tint n = strlen(s);\n\tscanf(\"%d\",&kk);\n\tmemset(f,0,sizeof(f));\n\tfor (int i = 0;i<n/2;i++)\n\t{\n\t\tfor (int j = 0;j<n/2;j++)\n\t\t{\n\t\t\tfor (int k = 0;k<=kk;k++)\n\t\t\t{\n\t\t\t\tif (s[i] == s[n-1-j])\n\t\t\t\t{\n\t\t\t\t\tif (i-1>=0 && j-1>=0)\n\t\t\t\t\tf[i][j][k]=f[i-1][j-1][k]+1;\n\t\t\t\t\telse f[i][j][k] = 1;\n\t\t\t\t} \n\t\t\t\t\tif (i-1>=0) f[i][j][k] = max(f[i][j][k],f[i-1][j][k]);\n\t\t\t\t\tif (j-1>=0) f[i][j][k] = max(f[i][j][k],f[i][j-1][k]);\n\t\t\n\t\t\t\tif (k>0)\n\t\t\t\tif (i>0 && j>0)\n\t\t\t\tf[i][j][k]=max(f[i-1][j-1][k-1]+1,f[i][j][k]);\n\t\t\t\telse f[i][j][k] = max(f[i][j][k],1);\n\t\t\t\tif (k>0)\n\t\t\t\tf[i][j][k]=max(f[i][j][k],f[i][j][k-1]);\n\t\t\t}\n\t\t}\n\t}\n\tif (n==1) {\n\t\tprintf(\"1\");\n\t\treturn 0;\n\t}\n\tif (n%2==1) printf(\"%d\",(f[n/2-1][n/2-1][kk])*2+1);\n\telse printf(\"%d\",f[n/2-1][n/2-1][kk]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int maxn = 303;\nint f[maxn][maxn][maxn] , l , k;\nchar s[maxn];\nint main(){\n\tcin >> s + 1 >> k;\n\tl = strlen(s + 1);\n\tint ans = 1;\n\tfor(int c = 0 ; c <= k ; ++ c){\n\t\tfor(int i = 1 ; i < l ; ++ i){\n\t\t\tfor(int j = l ; j > i ; -- j){\n\t\t\t\tif(s[i] == s[j])\n\t\t\t\t\tf[i][j][c] = max(f[i][j][c] , f[i - 1][j + 1][c] + 1);\n\t\t\t\telse if(c > 0)\n\t\t\t\t\tf[i][j][c] = max(f[i][j][c] , f[i - 1][j + 1][c - 1] + 1);\n\t\t\t\tf[i][j][c] = max(f[i][j][c] , f[i - 1][j][c]);\n\t\t\t\tf[i][j][c] = max(f[i][j][c] , f[i][j + 1][c]);\n\t\t\t\tf[i][j][c] = max(f[i][j][c - 1] , f[i][j][c]);\n\t\t\t}\n\t\t\tans = max(ans , f[i][i + 1][c] * 2);\n\t\t\tif(i < l - 1)\n\t\t\t\tans = max(ans , f[i][i + 2][c] * 2 + 1);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nconst int maxn = 301;\nint dp[maxn][maxn][maxn] = {};\n\nint main()\n{\n\tstring s;\n\tcin >> s;\n\tint n = s.length();\n\tint k;\n\tcin >> k;\n\tfor (int t = 0; t <= k; t++)\n\t\tfor (int l = 1; l <= n; l++)\n\t\t\tfor (int r = n - 1; r >= l - 1; --r)\n\t\t\t{\n\t\t\t\tdp[l][r][t] = max(dp[l][r + 1][t], dp[l - 1][r][t]);\n\t\t\t\tif (s[l - 1] == s[r])\n\t\t\t\t\tdp[l][r][t] = max(dp[l][r][t], dp[l - 1][r + 1][t] + 2 - (int)(r == l - 1));\n\t\t\t\tif (t)\n\t\t\t\t{\n\t\t\t\t\tdp[l][r][t] = max(dp[l][r][t], dp[l][r][t - 1]);\n\t\t\t\t\tdp[l][r][t] = max(dp[l][r][t], dp[l - 1][r + 1][t - 1] + 2 - (int)(r == l - 1));\n\t\t\t\t}\n\t\t\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tans = max(ans, dp[i][i - 1][k]);\n\t}\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define fr first\n#define sc second\n#define ll  long long\n#define mp make_pair\n#define mod 1000000007\n\nusing namespace std;\n\nstring s;\nint dp[330][330][330];\n\nint f(int st,int en,int k){\n    if(st >en)return 0;\n    if(st == en){\n        return 1;\n    }\n    int &ret = dp[st][en][k];\n    if(ret != -1)return ret;\n    int r =0;\n    r = max(r,f(st+1,en,k));\n    r = max(r,f(st,en-1,k));\n\n    if(k ||(s[st] == s[en]))\n        r = max(r,f(st+1,en-1,k-(s[st] != s[en]))+2);\n\n    return ret = r;\n}\n\nint v[100100];\nint main()  {\n    int k;\n    ios::sync_with_stdio(0);\n    cin>>s>>k;\n    int n = s.size();\n    memset(dp,-1,sizeof dp);\n\n    int mx =f(0,n-1,k);\n    cout<<mx<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ninline int read(){\n\tchar c=getchar();while (c!='-'&&(c<'0'||c>'9'))c=getchar();\n\tint k=1,kk=0;if (c=='-')c=getchar(),k=-1;\n\twhile (c>='0'&&c<='9')kk=kk*10+c-'0',c=getchar();return kk*k;\n}using namespace std;\nvoid write(int x){if (x<0)putchar('-'),x=-x;if (x/10)write(x/10);putchar(x%10+'0');}\nvoid writeln(int x){write(x);puts(\"\");}\nint f[310][310][310],kk,ans,l;\nchar s[1000];\nsigned main(){\n\tscanf(\"%s\",s);kk=read();l=strlen(s);//f[i][j][k]为i到i+j-1最多修改k个后变成回文最少插入的个数 \n\tmemset(f,10,sizeof(f));for (int i=0;i<=l+5;i++){\n\t\tmemset(f[i][0],0,sizeof(f[i][0]));memset(f[i][1],0,sizeof(f[i][1]));\n\t}for (int j=2;j<=l;j++)\n\t\tfor (int i=1;i+j-1<=l;i++)\n\t\t\tfor (int k=0;k<=kk;k++){\n\t\t\t\tif (k)f[i][j][k]=f[i+1][j-2][k-1];\n\t\t\t\tif (s[i-1]!=s[i+j-2]){\n\t\t\t\t\tif (k)f[i][j][k]=min(f[i][j][k],f[i+1][j-2][k-1]);//修改一发 \n\t\t\t\t}else f[i][j][k]=min(f[i][j][k],f[i+1][j-2][k]);\n\t\t\t\tf[i][j][k]=min(f[i][j][k],min(f[i][j-1][k],f[i+1][j-1][k])+1);//插入一发\n\t\t\t}\n\twriteln(l-f[1][l][kk]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<stdexcept>\n#include<utility>\n#include<functional>\n#include<numeric>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<array>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<complex>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<bitset>\n#include<memory>\nusing namespace std;\nusing ll=long long;\n\nvoid cmax(int& lhs,int rhs){lhs=max(lhs,rhs);}\nint main(){\n    string s;\n    cin>>s;\n    int k;\n    cin>>k;\n    int half=s.size()/2;\n    \n    vector<vector<vector<int>>> dp(half+1,vector<vector<int>>(half+1,vector<int>(k+1)));\n    for(int i=0;i<=half;i++){\n        for(int j=0;j<=half;j++){\n            for(int l=0;l<=k;l++){\n                if(i<half){\n                    cmax(dp[i+1][j][l],dp[i][j][l]);\n                }\n                if(j<half){\n                    cmax(dp[i][j+1][l],dp[i][j][l]);\n                }\n                if(i<half &&j<half){\n                    if(s[i]!=s[s.size()-1-j] && l<k) cmax(dp[i+1][j+1][l+1],dp[i][j][l]+1);\n                    if(s[i]==s[s.size()-1-j]) cmax(dp[i+1][j+1][l],dp[i][j][l]+1);\n                }\n                if(l<k) cmax(dp[i][j][l+1],dp[i][j][l]);\n            }\n        }\n    }\n    \n\n    vector<vector<int>> posL(s.size()+1,vector<int>(26,-1));\n    for(int i=0;i<s.size();i++) posL[i+1]=posL[i],posL[i+1][s[i]-'a']=i;\n    vector<vector<int>> posR(s.size()+1,vector<int>(26,s.size()));\n    for(int i=s.size()-1;i<s.size();i--) posR[i]=posR[i+1],posR[i][s[i]-'a']=i;\n\n    vector<vector<vector<int>>> dp2(s.size()+1,vector<vector<int>>(s.size()+1,vector<int>(k+1)));\n    for(int i=0;i<s.size();i++) for(int j=0;j<=k;j++) dp2[i][i+1][j]=1;\n    for(int v=2;v<=s.size();v++){\n        for(int i=0;i<s.size();i++){\n        int j=i+v;\n        if(i+v>s.size()) continue;\n            for(int l=0;l<=k;l++){\n                if(l>0){\n                    cmax(dp2[i][j][l],dp2[i+1][j-1][l-1]+2);\n                    cmax(dp2[i][j][l],dp2[i][j][l-1]);\n                }\n                cmax(dp2[i][j][l],dp2[i+1][j][l]);\n                cmax(dp2[i][j][l],dp2[i][j-1][l]);\n                if(i+1<=posL[j][s[i]-'a']) cmax(dp2[i][j][l],dp2[i+1][posL[j][s[i]-'a']][l]+2);\n                if(posR[i][s[j-1]-'a']<=j-2) cmax(dp2[i][j][l],dp2[posR[i][s[j-1]-'a']+1][j-1][l]+2);\n            }\n        }\n    }\n\n    int res=0;\n    int tmp=s.size()%2;\n    for(int i=0;i<=half;i++){\n        for(int j=0;j<=half;j++){\n            for(int l=0;l<=k;l++){\n                cmax(res,dp[i][j][l]*2+dp2[i][half+tmp][k-l]);\n                cmax(res,dp[i][j][l]*2+dp2[half][s.size()-j][k-l]);\n            }\n        }\n    }\n    cout<<dp2[0][s.size()][k]<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 305;\nint dp[MAXN][MAXN][MAXN];\n\nint main()\n{\n    string s;\n    cin >> s;\n    int k;\n    cin >> k;\n    for(int sz = 1; sz <= s.size(); sz++){\n        for(int l = 0; l < s.size() - sz + 1; l++){\n            int r = l + sz - 1;\n            for(int j = 0; j <= k; j++){\n                if(r == l){\n                    dp[l][r][j] = 1;\n                    continue;\n                }\n                if(r - l == 1){\n                    if(j == 0){\n                        if(s[l] == s[r]){\n                            dp[l][r][j] = 2;\n                        }\n                        else{\n                            dp[l][r][j] = 1;\n                        }\n                    }\n                    else{\n                        dp[l][r][j] = 2;\n                    }\n                    continue;\n                }\n                dp[l][r][j] = max(dp[l + 1][r][j], dp[l][r - 1][j]);\n                if(s[l] == s[r]){\n                    dp[l][r][j] = max(dp[l][r][j], dp[l + 1][r - 1][j] + 2);\n                }\n                else if(j != 0){\n                    dp[l][r][j] = max(dp[l][r][j], dp[l + 1][r - 1][j - 1] + 2);\n                }\n            }\n        }\n    }\n    cout << dp[0][s.size() - 1][k];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <boost/multiprecision/cpp_int.hpp>\n//namespace mp = boost::multiprecision;\n\nusing namespace std;\n\nconst double PI = 3.14159265358979323846;\ntypedef long long ll;\nconst double EPS = 1e-9;\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\ntypedef pair<ll, ll> P;\nconst ll INF = 10e17;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n#define ret() return 0;\n\ndouble equal(double a, double b) {\n    return fabs(a - b) < DBL_EPSILON;\n}\n\nstd::istream &operator>>(std::istream &in, set<int> &o) {\n    int a;\n    in >> a;\n    o.insert(a);\n    return in;\n}\n\nstd::istream &operator>>(std::istream &in, queue<int> &o) {\n    ll a;\n    in >> a;\n    o.push(a);\n    return in;\n}\n\nbool contain(set<int> &s, int a) { return s.find(a) != s.end(); }\n\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\n//const ll mod = 1e10;\n\ntypedef priority_queue<ll, vector<ll>, greater<ll> > PQ_ASK;\n\nint f(string &s, int l, int r, int k, vector<vector<vector<int>>> &memo) {\n    if (memo[l][r][k] != -1) return memo[l][r][k];\n\n    int ans = [&] {\n\n        if (l == r) return 1;\n        else if (l + 1 == r) {\n            if (s[l] == s[r] || 0 < k) return 2;\n            else return 1;\n        } else {\n            int ans = 0;\n            cmax(ans, f(s, l + 1, r, k, memo));\n            cmax(ans, f(s, l, r - 1, k, memo));\n\n            if (s[l] == s[r]) cmax(ans, f(s, l + 1, r - 1, k, memo) + 2);\n            else if (0 < k) cmax(ans, f(s, l + 1, r - 1, k - 1, memo) + 2);\n            return ans;\n        }\n\n    }();\n\n    return memo[l][r][k] = ans;\n}\n\nint main() {\n    string s;\n    int k;\n    cin >> s >> k;\n    int n = s.size();\n    vector<vector<vector<int>>> memo(n, vector<vector<int>>(n, vector<int>(n, -1)));\n    cout << f(s, 0, n - 1, k, memo) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn=300+10;\nint n,x,f[maxn][maxn][maxn],ans;\nchar s[maxn];\n\nvoid chkmax(int&a,int b){if(a<b)a=b;}\n\nint main(){\n\tcin>>(s+1)>>x;\n\tn=strlen(s+1);\n\tfor(int i=0;i<=n;++i)\n\t\tfor(int j=n+1;i<j;--j)\n\t\t\tfor(int k=0;k<=x;++k){\n\t\t\t\tif(i+1<j)\n\t\t\t\t\tchkmax(ans,f[i][j][k]+1);\n\t\t\t\telse\n\t\t\t\t\tchkmax(ans,f[i][j][k]);\n\t\t\t\tif(i+1<j){\n\t\t\t\t\tchkmax(f[i+1][j][k],f[i][j][k]);\n\t\t\t\t\tchkmax(f[i][j-1][k],f[i][j][k]);\n\t\t\t\t}\n\t\t\t\tif(i+1<j-1)\n\t\t\t\t\tif(s[i+1]==s[j-1])\n\t\t\t\t\t\tchkmax(f[i+1][j-1][k],f[i][j][k]+2);\n\t\t\t\t\telse if(k<x)\n\t\t\t\t\t\tchkmax(f[i+1][j-1][k+1],f[i][j][k]+2);\n\t\t\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 100000 + 10;\nconst int M = 1000000007;\nconst double eps = 1e-9;\nconst double PI = acos(-1);\nconst int oo = 1000000000;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> ii;\n#define pb push_back \n#define all(c) (c).begin(),(c).end()\nstring s;\nint k,dp[301][301][301];\nint calc(int l, int r, int k){\n\tif(k<0)\n\t\treturn -oo;\n\tif(l>r)\n\t\treturn 0;\n\tif(l==r)\n\t\treturn 1;\n\tint &ret=dp[l][r][k];\n\tif(ret!=-1)return ret;\n\tret=max(calc(l+1,r,k),calc(l,r-1,k));\n\tif(s[l]==s[r])\n\t\tret=max(ret, 2+calc(l+1,r-1,k));\n\telse\n\t\tret=max(ret, 2+calc(l+1,r-1,k-1));\n\treturn ret;\n}\nint main(){\n\tcin>>s>>k;\n\tmemset(dp,-1,sizeof(dp));\n\tcout<<calc(0,s.size()-1,k)<<endl;\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n#define INF 1000000000\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint dp[303][303][303];\nstring s;\nint k;\n\nint dfs(int K,int L,int R)\n{\n//\tcout << K << ' ' << L << ' ' << R << endl;\n\tif(K < 0)return -100000000;\n\tif(L > R)return 0;\n\tif(dp[K][L][R] != 0)return dp[K][L][R];\n\tint ret = 0;\n\tif(s[L] == s[R])ret = max(ret,dfs(K,L+1,R-1)+2);\n\telse ret = max(ret,dfs(K-1,L+1,R-1)+2);\n\tret = max(ret,dfs(K,L+1,R));\n\tret = max(ret,dfs(K,L,R-1));\n\t\n\treturn dp[K][L][R] = ret;\n}\n\n\nint main()\n{\n\tcin >> s >> k;\n\t\n\tREP(K,333)REP(i,333)dp[K][i][i] = 1;\n\tcout << dfs(k,0,s.size()-1) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int maxn = 303;\nint f[maxn][maxn][maxn] , l , k;\nchar s[maxn];\nint main(){\n\tcin >> s + 1 >> k;\n\tl = strlen(s + 1);\n\tmemset(f , -1 , sizeof f);\n\tf[0][l + 1][0] = 0;\n\tint ans = 0;\n\tfor(int c = 1 ; c <= k ; ++ c){\n\t\tfor(int i = 1 ; i < l ; ++ i){\n\t\t\tfor(int j = l + 1 ; j > i ; -- j){\n\t\t\t\tif(s[i] == s[j])\n\t\t\t\t\tf[i][j][c] = max(f[i][j][c] , f[i - 1][j + 1][c] + 1);\n\t\t\t\telse\n\t\t\t\t\tf[i][j][c] = max(f[i][j][c] , f[i - 1][j + 1][c - 1] + 1);\n\t\t\t\tf[i][j][c] = max(f[i][j][c] , f[i - 1][j][c]);\n\t\t\t\tf[i][j][c] = max(f[i][j][c] , f[i][j + 1][c]);\n\t\t\t}\n\t\t\tans = max(ans , f[i][i + 1][c] * 2);\n\t\t\tif(i < l - 1)\n\t\t\t\tans = max(ans , f[i][i + 2][c] * 2 + 1);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int ms = 311;\n\nint memo[ms][ms][ms];\n\nstring s;\n\nint dp(int k, int l, int r) {\n  if (l == s.size() or r < 0) return 0;\n  int &ans = memo[k][l][r];\n  if (ans != -1) return ans;\n  ans = max(dp(k, l + 1, r), dp(k, l, r - 1));\n  if (s[l] == s[r]) ans = max(ans, 1 + dp(k, l + 1, r - 1));\n  if (k) ans = max(ans, 1 + dp(k - 1, l + 1, r - 1));\n  return ans;\n}\n\nint main() {\n  cin >> s;\n  int k;\n  cin >> k;\n  memset(memo, -1, sizeof memo);\n  cout << min(dp(0, 0, s.size() - 1) + k * 2, (int)s.size()) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\nusing namespace std;\n#define MN 305\n#define inf 1e12\nstring a;\nint k,len;\nvoid rw(int &x,int y){if(y>x)x=y;}\nint f(int l,int r,int k){\n\tif(l<0||r<0||l>=len||r>=len||l>r||k<0) return -inf;\n\tif(l==r) return 1;\n\tint res=-inf;\n\trw(res,f(l+1,r-1,a[l]==a[r]?k:k-1)+2);\n\trw(res,f(l+1,r,k));\n\trw(res,f(l,r-1,k));\n\treturn res;\n}\nint main(){\n\tcin>>a>>k;\n\tprintf(\"%d\\n\",f(0,len=a.size()-1,k));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i, a, b) for (int i = (a); i < (b); ++i)\n#define F2(i, a, b) for (int i = (a); i <= (b); ++i)\n#define dF(i, a, b) for (int i = (a); i > (b); --i)\n#define dF2(i, a, b) for (int i = (a); i >= (b); --i)\n#define maxn 310\nusing namespace std;\ntypedef long long LL;\nchar ss[maxn];\nint dp[maxn][maxn][maxn];\nint main() {\n    int n;\n    scanf(\"%s%d\", ss, &n);\n    int len = strlen(ss);\n    F(i, 0, len) F2(j, 0, n) dp[i][i][j] = dp[i][i+1][j] = 1;\n    F2(l, 2, len) {\n        F2(s, 0, len-l) {\n            int t = s+l;\n            F2(k, 0, n) {\n                dp[s][t][k] = max(max(dp[s+1][t][k], dp[s][t-1][k]), dp[s+1][t-1][k]+(ss[s]==ss[t]?2:0));\n                if (k) dp[s][t][k] = max(dp[s][t][k], dp[s+1][t-1][k-1]+2);\n            }\n        }\n    }\n    printf(\"%d\\n\", dp[0][len][n]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n// #include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\n// #include <bitset>\nconst int oo=2139063143;\nconst int N=310;\nconst int P=1000000007;\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\n#define pritnf printf\n//char buf[1<<22],*p1=buf,*p2=buf,obuf[1<<22],*O=obuf;\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ntemplate <typename T>\ninline void sc (T &x)\n{\n    x=0; static int p; p=1; static char c; c=getchar();\n    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }\n    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }\n    x*=p;\n}\ntemplate <typename T>\ninline void print (T x)\n{\n\tif (x< 0) putchar('-'),x=-x;\n\tif (x>=10) print(x/10);\n\tputchar(x%10+'0');\n}\ntemplate <typename T>\ninline void pr (T x) { print(x),putchar('\\n'); }\nvoid chkmax (int &A,int B) { A=A>=B?A:B; }\nchar s[N];\nint f[N][N][N];\nint main ()\n{\n\t// freopen (\".in\",\"r\",stdin);\n\t// freopen (\".out\",\"w\",stdout);\n\tscanf (\"%s\",s+1);\n\tint n=strlen (s+1),k; sc(k);\n\tfor (int i=1; i<=n; i++)\n\t\tf[i][i][0]=1;\n\tfor (int len=2; len<=n; len++)\n\t{\n\t\tfor (int l=1,r=len; r<=n; l++,r++)\n\t\t{\n\t\t\tfor (int i=0; i<=k; i++)\n\t\t\t{\n\t\t\t\tf[l][r][i]=max (f[l+1][r][i],f[l][r-1][i]);\n\t\t\t\tif (s[l]==s[r]) chkmax (f[l][r][i],f[l+1][r-1][i]+2);\n\t\t\t\tif (i) chkmax (f[l][r][i],f[l+1][r-1][i-1]+2);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor (int i=0; i<=k; i++)\n\t\tchkmax (ans,f[1][n][i]);\n\tpr(ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//wls niubi!\n#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\nconst LL mod = 1e9 + 7;\ninline int read()\n{\n\tint x = 0,f = 1;char ch = getchar();\n\tfor(;!isdigit(ch);ch = getchar())if(ch == '-')f = -f;\n\tfor(;isdigit(ch);ch = getchar())x = 10 * x + ch - '0';\n\treturn x * f;\n}\nint n,K;\nchar ch[310];\nint f[310][310][310];\nint main()\n{\n\tscanf(\"%s\",ch + 1);n = strlen(ch + 1);K = read();\n\tfor(int i=1;i<=n;i++)for(int j=0;j<=K;j++)f[i][i][j] = 1;\n\tfor(int l=2;l<=n;l++)\n\t{\n\t\tfor(int i=1;i+l-1<=n;i++)\n\t\t{\n\t\t\tint j = i + l - 1;\n\t\t\tfor(int k=0;k<=K;k++)\n\t\t\t{\n\t\t\t    f[i][j][k] = max(f[i + 1][j][k],f[i][j - 1][k]);\n\t\t\t    if(ch[i] == ch[j])f[i][j][k] = max(f[i][j][k],f[i + 1][j - 1][k] + 2);\n\t\t\t    if(k)f[i][j][k] = max(f[i][j][k],f[i + 1][j - 1][k - 1] + 2);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tcout<<f[1][n][K];\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n#define rint register int\n#define gc() getchar()\ninline int read(rint ans = 0, rint sgn = ' ', rint ch = gc())\n{\n\tfor(; ch < '0' || ch > '9'; sgn = ch, ch = gc());\n\tfor(; ch >='0' && ch <='9';(ans*=10)+=ch-'0', ch = gc());\n\treturn sgn-'-'?ans:-ans;\n}\nchar T[305]; int n, K, f[305][305][305]; inline int Cmax(int &x, int v){x < v ? x = v : 0;}\nint main()\n{\n\tscanf(\"%s\",T+1), n = strlen(T+1), K = read();\n\tfor(rint i = 1, k; i <= n; i++) for(k = 0; k <= K; f[i][i][k] = 1, k++);\n\tfor(rint d = 2, l, r, k; d <= n; d++)\n\t\tfor(l = 1, r = d; r <= n; l++, r++)\n\t\t\tfor(k = 0; k <= K; k++)\n\t\t\t{\n\t\t\t\tCmax(f[l][r][k],f[l][r-1][k]);\n\t\t\t\tCmax(f[l][r][k],f[l+1][r][k]);\n\t\t\t\tT[l]==T[r] ? Cmax(f[l][r][k],f[l+1][r-1][k]+2) : 0;\n\t\t\t\tk ? Cmax(f[l][r][k],f[l+1][r-1][k-1]+2) : 0;\n\t\t\t\tk ? Cmax(f[l][r][k],f[l][r][k-1]) : 0;\n\t\t\t}\tprintf(\"%d\\n\",f[1][n][K]); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#include <tuple>\n#define mkp make_pair\n#define mkt make_tuple\n#define rep(i,n) for(int i = 0; i < (n); ++i)\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1e9+7;\ntemplate<class T> void chmin(T &a,const T &b){if(a>b) a=b;}\ntemplate<class T> void chmax(T &a,const T &b){if(a<b) a=b;}\n\nstring S;\nint N,K;\n\nstring T;\nint nxt[303][26];\nint dp[303][303][303];\n\nint rec(int uplef,int dwlef,int num){\n    if(N-1-uplef<dwlef) return 0;\n    if(N-1-dwlef<uplef) return 0;\n    if(dp[uplef][dwlef][num]) return dp[uplef][dwlef][num];\n    if(2*uplef>=N&&2*dwlef>=N) return 0;\n    if(N%2&&uplef==N/2&&dwlef==N/2) return 1;\n\n    int res=0;\n    chmax(res,rec(uplef+1,dwlef,num));\n    chmax(res,rec(uplef,dwlef+1,num));\n\n    int cost=2;\n    if(N-1-uplef<=dwlef) cost=1;\n    if(N-1-dwlef<=uplef) cost=1;\n    if(S[uplef]==T[dwlef]) chmax(res,rec(uplef+1,dwlef+1,num)+cost);\n    else if(num>0) chmax(res,rec(uplef+1,dwlef+1,num-1)+cost);\n\n    return dp[uplef][dwlef][num]=res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin>>S;\n  cin>>K;\n  N=S.size();\n\n  T=S;\n  reverse(T.begin(),T.end());\n  rep(i,N+1) rep(j,26) nxt[i][j]=N;\n  for(int i=N-1;i>=0;i--){\n      for(int j=0;j<26;j++){\n          nxt[i][j]=nxt[i+1][j];\n      }\n      nxt[i][T[i]-'a']=i;\n  }\n\n  cout<<rec(0,0,K)<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nchar str[606];\nchar str2[606];\nint dp[606][606];\nint main(){\n    memset(dp,0,sizeof(dp));\n    int k;\n    scanf(\"%s\",str);\n    scanf(\"%d\",&k);\n    int n = strlen(str);\n    for(int i=0;i<n;i++){\n        str2[i*2+1] = str[i];\n        str2[i*2+2] = '*';\n    }\n    n = n*2+1;\n    int ans = 0;\n    for(int mid = 1; mid<=n/2+1;mid++){\n\n        for(int i=1;i<=n/2;i++){\n            for(int j=0;j<=min(i,k);j++){\n                if(str2[mid-dp[i-1][j]]==str2[mid+i]){\n                    dp[i][j] = dp[i-1][j]+1;\n                }\n                else{\n                    dp[i][j] = dp[i-1][j];\n                }\n                dp[i][j] = max(dp[i][j],dp[i-1][j-1]+1);\n            }\n        }\n        for(int i=1;i<=k;i++){\n            if(dp[n/2][i]==mid-1){\n                ans = max(ans,mid);\n            }\n        }\n\n    }\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 305;\n\nint dp[MAX_N][MAX_N][MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    int n = len(s);\n    int K;\n    cin >> K;\n    rep(i,n){\n        rep(j,K+1){\n            dp[i][i+1][j] = 1;\n        }\n    }\n    srep(l,1,n){\n        rep(i,n-l+1){\n            int j = i+l;\n            rep(k,K+1){\n                if(i) cmx(dp[i-1][j][k],dp[i][j][k]);\n                if(j < n){\n                    if(k) cmx(dp[i][j+1][k],dp[i][j+1][k-1]);\n                    cmx(dp[i][j+1][k],dp[i][j][k]);\n                    if(s[i] == s[j]) cmx(dp[i][j+1][k],dp[i+1][j][k]+2);\n                    if(k < K) cmx(dp[i][j+1][k+1],dp[i+1][j][k]+2);\n                }\n            }\n        }\n    }\n    cout << dp[0][n][K] << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n#define INF 1000000000\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint dp[333][333][333];\nstring s;\nint k;\n\nint dfs(int K,int L,int R)\n{\n//\tcout << K << ' ' << L << ' ' << R << endl;\n\tif(K < 0)return -100000000;\n\tif(L > R)return 0;\n\tif(dp[K][L][R] != 0)return dp[K][L][R];\n\tint ret = 0;\n\tif(s[L] == s[R])ret = max(ret,dfs(K,L+1,R-1)+2);\n\telse ret = max(ret,dfs(K-1,L+1,R-1)+2);\n\tret = max(ret,dfs(K,L+1,R));\n\tret = max(ret,dfs(K,L,R-1));\n\t\n\treturn dp[K][L][R] = ret;\n}\n\n\nint main()\n{\n\tcin >> s >> k;\n\t\n\tREP(K,333)REP(i,333)dp[K][i][i] = 1;\n\tREP(K,333)REP(i,s.size()-1)\n\t{\n\t\tif(K < k || s[i] == s[i+1])dp[K][i][i+1] = 2;\n\t\telse dp[K][i][i+1] = 1;\n\t}\n\t\n\tcout << dfs(k,0,s.size()-1) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nID: 5ak0\nPROG:\nLANG: C++11\n*/\n\n#include <bits/stdc++.h>\n#define fr first\n#define sc second\n#define pb push_back\n#define mpr make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 1e9 + 7;\n\nstring s;\nint k;\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    #ifndef SAKO\n    //freopen(\".in\", \"r\", stdin);\n    //freopen(\".out\", \"w\", stdout);\n    #endif // SAKO\n    cin >> s;\n    cin >> k;\n    cout << s.size() - k - 1;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define SORT(a) sort(a.begin(), a.end())\n#define REVERSE(a) reverse(a.begin(), a.end())\n#define int long long\n#define INF 1000000000000000\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\ntypedef pair<int, int> Pii;\n\ntemplate<typename T>\nvoid readvec(vector<T> &a);\nvoid readindex(vector<int> &a);\n\n\n\nsigned main(){\n\n    string S; cin >> S;\n    int N = S.size();\n    int K; cin >> K;\n\n    if(N == 1){\n        cout << 1;\n        return 0;\n    }\n\n    vector<mat> dp(N + 1, mat(N + 1, vec(K + 1, 0)));\n\n    REP(i, N){\n        REP(j, N){\n            if(S[i] == S[N - 1 - j]){\n                REP(k, K + 1) dp[i + 1][j + 1][k] = dp[i][j][k] + 1;\n            }else{\n                REP(k, K) dp[i + 1][j + 1][k + 1] = dp[i][j][k] + 1;\n                REP(k, K + 1) dp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], max(dp[i + 1][j][k], dp[i][j + 1][k]));\n            }\n        }\n    }\n\n    /*\n    REP(i, N + 1){\n        REP(j, N + 1){\n            cout << i << \", \" << j << endl;\n            REP(k, K + 1){\n                cout << dp[i][j][k] << \",\";\n            }\n            cout << endl;\n        }\n    }*/\n\n    \n    int ans = 0;\n    FOR(i, 1, N){\n        REP(k, K + 1){\n            ans = max(dp[i][N - i][k] * 2, ans);\n            ans = max(dp[i][N - i - 1][k] * 2 + 1, ans);\n        }\n    }\n\n    cout << ans;\n    \n    return 0;\n}\n\n\ntemplate<typename T>\nvoid readvec(vector<T> &a){\n    REP(i, a.size()){\n        cin >> a[i];\n    }\n}\nvoid readindex(vector<int> &a){\n    REP(i, a.size()){\n        cin >> a[i];\n        a[i]--;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define MN 300\nchar s[MN+5];\nint ls[MN+5][26],f[MN+5][MN+5][MN+5];\ninline void rw(int&a,int b){if(b>a)a=b;}\nint main()\n{\n\tint n,m,i,j,k,ans=0;\n\tscanf(\"%s%d\",s+1,&m);n=strlen(s+1);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tfor(j=0;j<26;++j)ls[i][j]=ls[i-1][j];\n\t\tls[i][s[i]-'a']=i;\n\t}\n\tfor(i=1;i<=n;++i)for(j=n;j>=i;--j)for(k=0;k<=m;++k)\n\t{\n\t\trw(f[i+1][j][k],f[i][j][k]);\n\t\tif(ls[j][s[i]-'a']>i)rw(f[i+1][ls[j][s[i]-'a']-1][k],f[i][j][k]+2),rw(ans,f[i][j][k]+2);\n\t\trw(ans,f[i][j][k]+1);\n\t\tif(i<j&&k<m)rw(f[i+1][j-1][k+1],f[i][j][k]+2),rw(ans,f[i][j][k]+2);\n\t}\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define all(x) x.begin(),x.end()\n#define SZ(x) (int)(x.size())\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,a,b) for(int i=b-1;i>=a;i--)\n#define inf 1000000007\n#define mod 1000000007\n#define x first\n#define y second\n#define pi acos(-1.0)\n#define DBG(x) cerr<<(#x)<<\"=\"<<x<<\"\\n\";\n//#define dprintf(...) \n#define hash _hash\n//#define dprintf(...) fprintf(outFile,__VA_ARGS__)\n \n#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define ull unsigned long long\n#define ll long long\n#define N 100010\n \ntemplate <class T,class U>inline void Max(T &a,U b){if(a<b)a=b;}\ntemplate <class T,class U>inline void Min(T &a,U b){if(a>b)a=b;}\n \n//FILE* outFile;\n \ninline void add(int &a,int b){a+=b;while(a>=mod)a-=mod;}\n \n \nint pow(int a,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=ans*(ll)a%mod;\n        a=(ll)a*a%mod;b>>=1;\n    }\n    return ans;\n}\n\nchar s[303];\nint dp[2][303][303],now;\nint main(){\n    //freopen(\"atlarge.in\",\"r\",stdin);\n    //freopen(\"atlarge.out\",\"w\",stdout);\n    //cout<<setprecision(9)<<fixed;\n    int T,j,i,k,ca=0,K,m=0,n;\n    scanf(\"%s%d\",s,&K);n=strlen(s);\n    int ans=0;\n    rep(i,0,n){\n        per(j,i,n){\n            rep(k,0,K+1){\n                int &w=dp[now][j][k];\n                if(i==j){\n                    Max(ans,w+1);\n                }\n                else if(s[i]==s[j]){\n                    if(i+1==j)Max(ans,w+2);\n                    else Max(dp[1-now][j-1][k],w+2);\n                }\n                else{\n                    if(k+1<=K){\n                        if(i+1==j)Max(ans,w+2);\n                        else Max(dp[1-now][j-1][k+1],w+2);\n                    }\n                    Max(dp[now][j-1][k],w);\n                    Max(dp[1-now][j][k],w);\n                }\n            }\n        }\n        now=1-now;\n    }\n    printf(\"%d\\n\",ans);\n    //cerr<<1.*clock()/CLOCKS_PER_SEC<<\"ms\"<<\"\\n\";\n    return 0;\n}   "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint dp[300][301][301];\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  string s; cin >> s;\n  int n = s.size();\n  int k; cin >> k;\n  for (int r = 1; r <= n; ++r) {\n    for (int l = r - 1; l >= 0; --l) {\n      for (int x = 0; x <= k; ++x) {\n        if (r - l == 1) {\n          dp[l][r][x] = 1;\n        } else {\n          dp[l][r][x] = max(dp[l][r - 1][x], dp[l + 1][r][x]);\n          if (s[l] == s[r - 1]) {\n            dp[l][r][x] = max(dp[l][r][x], dp[l + 1][r - 1][x] + 2);\n          } else if (x) {\n            dp[l][r][x] = max(dp[l][r][x], dp[l + 1][r - 1][x - 1] + 2);\n          }\n        }\n      }\n    }\n  }\n  cout << dp[0][n][k] << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=305;\nchar s[N];\nint n,f,dp[N][N][N];\nint main()\n{\n    scanf(\"%s\",s+1);\n    n=strlen(s+1);\n    scanf(\"%d\",&f);\n    int ans=0;\n    for(int i=1;i<=n;i++)\n        for(int j=n;j>i;j--)\n        for(int k=0;k<=f;k++)\n    {\n        dp[i][j][k]=max(dp[i-1][j][k],dp[i][j+1][k]);\n        if(s[i]==s[j])\n            dp[i][j][k]=max(dp[i][j][k],dp[i-1][j+1][k]+1);\n        if(k>0)\n            dp[i][j][k]=max(dp[i][j][k],dp[i-1][j+1][k-1]+1);\n        ans=max(ans,dp[i][j][k]*2);\n        if(i+1==j-1)\n            ans=max(ans,dp[i][j][k]*2+1);\n    }\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring s;\nint k, n, dp[302][302][302];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> s >> k;\n\tn = s.size();\n\ts = 'N' + s;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tdp[0][i][i] = 1;\n\t\tif(i < n) dp[0][i][i + 1] = 1 + (int)(s[i] == s[i + 1]);\n\t}\n\tfor(int i = 2; i < n; ++i) {\n\t\tfor(int j = 1; j + i <= n; ++j) {\n\t\t\tdp[0][j][j + i] = max(dp[0][j + 1][j + i], dp[0][j][j + i - 1]);\n\t\t\tif(s[j] == s[j + i]) dp[0][j][j + i] = dp[0][j + 1][j + i - 1] + 2;\n\t\t}\n\t}\n\tfor(int r = 1; r <= k; ++r) {\n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\tdp[r][i][i] = 1;\n\t\t\tif(i < n) dp[r][i][i + 1] = 2;\n\t\t}\n\t\tfor(int i = 2; i < n; ++i) {\n\t\t\tfor(int j = 1; j + i <= n; ++j) {\n\t\t\t\tif(s[j] == s[j + i]) dp[r][j][j + i] = dp[r][j + 1][j + i - 1] + 2;\n\t\t\t\tdp[r][j][j + i] = max(max(dp[r][j + 1][j + i], dp[r][j][j + i]), max(dp[r][j][j + i - 1], dp[r - 1][j + 1][j + i - 1] + 2));\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[k][1][n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\n\nconst int N = 310;\nint dp[N][N][N];\n\nvoid chmax(int &a, int b) { a = max(a, b); }\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  string s;\n  int k;\n  cin >> s >> k;\n  int n = s.length();\n  REP(i, 0, n) {\n    dp[i][i + 1][0] = 1;\n  }\n  REP(u, 2, n + 1) {\n    REP(i, 0, n - u + 1) {\n      REP(l, 0, k + 1) {\n        int j = i + u;\n        int tmp = 0;\n        chmax(tmp, dp[i][j - 1][l]);\n        chmax(tmp, dp[i + 1][j][l]);\n        if (s[i] == s[j - 1]) {\n          chmax(tmp, dp[i + 1][j - 1][l] + 2);\n        }\n        if (l >= 1) {\n          chmax(tmp, dp[i + 1][j - 1][l - 1] + 2);\n        }\n        dp[i][j][l] = tmp;\n      }\n    }\n  }\n  int ma = 0;\n  REP(i, 0, k + 1) chmax(ma, dp[0][n][i]);\n  cout << ma << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int N = 3e2+5;\nint n, m, f[N][N][N], ans; char s[N];\nint main()\n{\n    scanf(\"%s\", s+1), n = strlen(s+1), m = read();\n    for(int i = 1; i <= n; ++i) f[0][i][i] = 1;\n    for(int l = 2; l <= n; ++l)\n        for(int i = 1, j = l; j <= n; ++i, ++j)    \n            for(int k = 0; k <= m; ++k)\n            {\n                f[k][i][j] = max(max(f[k][i+1][j], f[k][i][j-1]), f[k][i+1][j-1]+2*(s[i] == s[j]));\n                if(k) f[k][i][j] = max(f[k][i][j], f[k-1][i+1][j-1]+2);\n                ans = max(ans, f[k][i][j]);\n            }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//wls niubi!\n#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\nconst LL mod = 1e9 + 7;\ninline int read()\n{\n\tint x = 0,f = 1;char ch = getchar();\n\tfor(;!isdigit(ch);ch = getchar())if(ch == '-')f = -f;\n\tfor(;isdigit(ch);ch = getchar())x = 10 * x + ch - '0';\n\treturn x * f;\n}\nint n,K;\nchar ch[310];\nint f[310][310][310];\nint main()\n{\n\tscanf(\"%s\",ch + 1);n = strlen(ch + 1);K = read();\n\tfor(int i=1;i<=n;i++)for(int j=0;j<=K;j++)f[i][i][j] = 1;\n\tfor(int l=2;l<=n;l++)\n\t{\n\t\tfor(int i=1;i+l-1<=n;i++)\n\t\t{\n\t\t\tint j = i + l - 1;\n\t\t\tfor(int k=0;k<=K;k++)\n\t\t\t{\n\t\t\t    f[i][j][k] = max(f[i - 1][j][k],f[i][j - 1][k]);\n\t\t\t    if(ch[i] == ch[j])f[i][j][k] = max(f[i][j][k],f[i + 1][j - 1][k] + 2);\n\t\t\t    if(k)f[i][j][k] = max(f[i][j][k],f[i + 1][j - 1][k - 1] + 2);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int k=0;k<=K;k++)ans = max(ans,f[1][n][k]);\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n#define rint register int\n#define gc() getchar()\ninline int read(rint ans = 0, rint sgn = ' ', rint ch = gc())\n{\n\tfor(; ch < '0' || ch > '9'; sgn = ch, ch = gc());\n\tfor(; ch >='0' && ch <='9';(ans*=10)+=ch-'0', ch = gc());\n\treturn sgn-'-'?ans:-ans;\n}\nchar T[305]; int n, K, f[305][305][305]; inline int Cmax(int &x, int v){x < v ? x = v : 0;}\nint main()\n{\n\tscanf(\"%s\",T+1), n = strlen(T+1), K = read();\n\tfor(rint i = 1, k; i <= n; i++) for(k = 0; k <= K; f[i][i][k] = 1, k++);\n\tfor(rint d = 2, l, r, k; d <= n; d++)\n\t\tfor(l = 1, r = d; r <= n; l++, r++)\n\t\t\tfor(k = 0; k <= K; k++)\n\t\t\t{\n\t\t\t\tCmax(f[l][r][k],f[l][r-1][k]);\n\t\t\t\tCmax(f[l][r][k],f[l+1][r][k]);\n\t\t\t\tT[l]==T[r] ? Cmax(f[l][r][k],f[l+1][r-1][k]+2) : 0;\n\t\t\t\tk ? Cmax(f[l][r][k],f[l+1][r-1][k-1]+2) : 0;\n\t\t\t\tk ? Cmax(f[l][r][k],f[l][r][k-1]) : 0;\n\t\t\t}\tprintf(\"%d\\n\",f[1][n][K]); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\n\nint mat[301][301][301] = {0};\n\nint main() {\n\tint n;\n\tint res = 0;\n\n\tstring a, b;\n\tint k;\n\tcin >> a;\n\tcin >> k;\n\tfor(int i=0; i<a.size(); ++i)\n\t\tb += a[a.size()-i-1];\n\n\tn = max(a.size(), b.size());\n\n\tfor(int i=0; i<2*n; ++i)\n\t\tfor(int j=0; j<=i; ++j)\n\t\t{\n\t\t\tint y = i-j;\n\t\t\tint x = j;\n\t\t\tif(a.size() <= y || b.size() <= x)\n\t\t\t\tcontinue;\n\n\t\t\tif(a[y] == b[x])\n\t\t\t{\n\t\t\t\tfor(int l=0; l<=k; ++l)\n\t\t\t\t\tmat[y+1][x+1][l] = mat[y][x][l] + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int l=0; l<=k; ++l)\n\t\t\t\t{\n\t\t\t\t\tmat[y+1][x+1][l] = max(mat[y][x+1][l], mat[y+1][x][l]);\n\t\t\t\t\tif(0 < l)\n\t\t\t\t\t{\n\t\t\t\t\t\tint q = (x < n/2 ? 2 : 1);\n\t\t\t\t\t\tmat[y+1][x+1][l] = max(mat[y+1][x+1][l], mat[y][x][l-1] + q);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tint ans = 0;\n\tfor(int l=0; l<=k; ++l)\n\t\tans = max(ans, mat[a.size()][b.size()][l]);\n\t//ans += 2*k;\n\tans = min(ans, n);\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define ll long long\n#define ull  unsigned long long\n#define pb push_back\n#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int N = 305;\nint dp[N][N][N];\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    string s;\n    cin >> s;\n    int k;\n    cin >> k;\n    int ans = 0;\n    int n = s.length();\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= n; j++){\n            for (int l = 0; l <= k; l++){\n                int p1 = i - 1;\n                int p2 = n - j;\n                if (s[p1] == s[p2]){\n                    dp[i][j][l] = dp[i - 1][j - 1][l] + 1;\n                }\n                dp[i][j][l] = max({dp[i][j][l], dp[i - 1][j][l], dp[i][j - 1][l]});\n                dp[i][j][l] = max(dp[i][j][l], dp[i - 1][j - 1][l]);\n                if (l != 0) dp[i][j][l] = max(dp[i][j][l], dp[i - 1][j - 1][l - 1] + 1);\n                if (i + j < n) ans = max(ans, 1 + 2 * dp[i][j][l]);\n                if (i + j <= n) ans = max(ans, 2 * dp[i][j][l]);\n                if (i + j <= n + 1) ans = max(ans, 2 * dp[i][j][l] - 1);\n            }\n        }\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\n\nint dp[303][303][303] = {0};\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  string s;\n  int k;\n  cin >> s >> k;\n  string t = s;\n  reverse(t.begin(), t.end());\n\n  int n = s.size();\n\n  for (int i = 0; i < n; i++) dp[i][i + 1][0] = 1;\n\n  for (int d = 2; d <= n; d++) {\n    for (int i = 0; i < n; i++) {\n      int j = d + i;\n      if (j > n) continue;\n      for (int l = 0; l <= k; l++) {\n        dp[i][j][l] = max(dp[i + 1][j][l], dp[i][j - 1][l]);\n        if (s[i] == s[j - 1]) {\n          dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l] + 2);\n        } else {\n          if (l > 0)\n            dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l - 1] + 2);\n        }\n      }\n    }\n  }\n\n  int ans = 0;\n  for (int i = 0; i <= k; i++) ans = max(ans, dp[0][n][i]);\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define MN 305\nusing namespace std;\nint k,f[MN][MN][MN];char ch[MN];\nint main(){\n\tscanf(\"%s\",ch+1);int n=strlen(ch+1);scanf(\"%d\",&k);\n\tfor(int i=1;i<=n;i++)for(int j=0;j<=k;j++)f[i][i][j]=1;\n\tfor(int len=2;len<=n;len++)\n\t\tfor(int i=1,j=i+len-1;j<=n;i++,j++)\n          \tfor(int kk=0;kk<=k;kk++){\n            \tf[i][j][kk]=max(f[i+1][j][kk],f[i][j-1][kk]);\n            \tif(kk>0)f[i][j][kk]=max(f[i][j][kk],f[i+1][j-1][kk-1]+2);\n            \tif(ch[i]==ch[j])f[i][j][kk]=max(f[i][j][kk],f[i+1][j-1][kk]+2);\n          \t}\n\tprintf(\"%d\\n\",f[1][n][k]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define fr first\n#define sc second\n#define ll  long long\n#define mp make_pair\n#define mod 1000000007\n\nusing namespace std;\n\nstring s;\nint dp[330][330][330];\nint aft[330][30];\nint bef[330][30];\nint f(int st,int en,int k){\n    if(st == en){\n        return 1;\n    }\n    int &ret = dp[st][en][k];\n    if(ret != -1)return ret;\n    int r =0;\n    r = max(r,f(st+1,en,k));\n    r = max(r,f(st,en-1,k));\n    if(st +1 != en &&k){\n        r = max(r,f(st+1,en-1,k-1)+2);\n    }\n    for(int i=0 ;i < 26 ; i++){\n        if(aft[st][i] <= bef[en][i]){\n            r = max(r,f(aft[st][i],bef[en][i],k)+2);\n        }\n\n    }\n    return ret = r;\n}\n\nint v[100100];\nint main()  {\n    int k;\n    ios::sync_with_stdio(0);\n    cin>>s>>k;\n    int n = s.size();\n    memset(dp,-1,sizeof dp);\n    for(int j=0 ;j <26 ; j++){\n        v[j] = -1;\n    }\n\n    for(int i=0 ;i <n ;i ++){\n        for(int j=0 ;j <26  ; j++){\n            bef[i][j] = v[j];\n        }\n        v[s[i]-'a'] = i;\n    }\n\n    for(int j=0 ;j <26 ; j++){\n        v[j] = n+2;\n    }\n\n    for(int i=n-1 ;i >=0 ;i --){\n        for(int j=0 ;j <26  ; j++){\n            aft[i][j] = v[j];\n        }\n        v[s[i]-'a'] = i;\n    }\n    int mx =0 ;\n    for(int i=0 ; i<n ;i ++){\n        for(int j=i ;j <n ;j ++){\n            if(k == 0 && s[i] != s[j])continue;\n            mx = max(mx,f(i,j,k-(s[i] != s[j])));\n        }\n    }\n    cout<<mx<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N, K;\nchar buf[333];\nint dp[333][333][333];\n\nvoid MAIN() {\n    scanf(\"%s\", buf);\n    scanf(\"%d\", &K);\n\n    string S = buf;\n    string T = buf;\n    reverse(T.begin(), T.end());\n    N = S.size();\n\n    REP (i, N) REP (j, N) {\n\tif (S[i] == T[j]) {\n\t    REP (k, K+1) dp[i+1][j+1][k] = dp[i][j][k] + 1;\n\t} else {\n\t    REP (k, K+1) dp[i+1][j+1][k] = max(dp[i][j+1][k], dp[i+1][j][k]);\n\t    REP (k, K) amax(dp[i+1][j+1][k+1], dp[i][j][k] + 1);\n\t}\n    }\n\n    int ans = 0;\n    REP (i, N+1) {\n\tREP (k, K+1) {\n\t    int j = N-i;\n\n\t    {\n\t\tint guess = dp[i][j][k] * 2;\n\t\tamax(ans, guess);\n\t    }\n\n\t    if (j) {\n\t\tj--;\n\t\tint guess = dp[i][j][k] * 2 + 1;\n\t\tamax(ans, guess);\n\t    }\n\t}\n    }\n    printf(\"%d\\n\", ans);\n}\n\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 305;\nconst int INF = 1e9;\n\nstring s;\nint n, k;\nint dp[N][N][N];\nint res;\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcin >> s >> k;\n\tn = s.size();\n\ts = ' ' + s;\n\ts = s + '&';\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tfor (int c = 0; c <= k; ++c) dp[i][j][c] = -INF;\n\t\t}\n\t}\n\tdp[0][n + 1][0] = 0;\n\tfor (int gap = n; gap >= 1; --gap) {\n\t\tfor (int i = 1; i <= n - gap + 1; ++i) {\n\t\t\tint j = i + gap - 1;\n\t\t\tfor (int c = 0; c <= k; ++c) {\n\t\t\t\tdp[i][j][c] = max(dp[i][j][c], dp[i - 1][j][c]);\n\t\t\t\tdp[i][j][c] = max(dp[i][j][c], dp[i][j + 1][c]);\n\t\t\t\t\n\t\t\t\tbool more = (s[i] == s[j] ? 0 : 1);\n\t\t\t\tif (c >= more) {\n\t\t\t\t\tdp[i][j][c] = max(dp[i][j][c], dp[i - 1][j + 1][c - more] + (i == j ? 1 : 2));\n\t\t\t\t}\n\n\t\t\t\t// if (dp[i][j][c] >= 0) {\n\t\t\t\t// \tprintf(\"lef %d rig = %d c = %d -> dp = %d\\n\", i, j, c, dp[i][j][c]);\n\t\t\t\t// }\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tfor (int c = 0; c <= k; ++c) {\n\t\t\t\tres = max(res, dp[i][j][c]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nint main() {\n    int N, K;\n    string S, T;\n    cin >> S;\n    N = (int)S.size();\n    cin >> K;\n    T = S;\n    reverse(T.begin(), T.end());\n    \n    vector<vector<vector<int>>> dp(N+1, vector<vector<int>>(N+1, vector<int>(K+1, 0)));\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            bool same;\n            if (S[i-1] == T[j-1]) same = true;\n            else same = false;\n            if (same) {\n                for (int k = 0; k <= K; k++) {\n                    dp[i][j][k] = max(max(dp[i-1][j][k], dp[i][j-1][k]), dp[i-1][j-1][k]+1);\n                }\n            }else {\n                for (int k = 0; k <= K; k++) {\n                    dp[i][j][k] = max(dp[i-1][j][k], dp[i][j-1][k]);\n                    if (k > 0) dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k-1]+1);\n                }\n            }\n        }\n    }\n    int ans = 0;\n    if (N%2 == 0) {\n        for (int i = 0; i <= N; i++) {\n            for (int j = 0; j <= K; j++) {\n                ans = max(ans, 2*dp[i][N-i][j]);\n                if (i < N) ans = max(ans, 2*dp[i][N-1-i][j]+1);\n            }\n        }\n    }else {\n        for (int i = 0; i <= N; i++) {\n            for (int j = 0; j <= K; j++) {\n                ans = max(ans, 2*dp[i][N-i][j]);\n                if (i < N) ans = max(ans, 2*dp[i][N-1-i][j]+1);\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> Pi;\ntypedef pair<ll,ll> Pll;\n\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define sz(x) (int)x.size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define repp(i, n) for(int i=1;i<=n;i++)\n#define all(x) x.begin(), x.end()\n\n#define geti1(X) scanf(\"%d\",&X)\n#define geti2(X,Y) scanf(\"%d%d\",&X,&Y)\n#define geti3(X,Y,Z) scanf(\"%d%d%d\",&X,&Y,&Z)\n#define geti4(X,Y,Z,W) scanf(\"%d%d%d%d\",&X,&Y,&Z,&W)\n\n#define GET_MACRO(_1,_2,_3,_4,NAME,...) NAME\n#define geti(...) GET_MACRO(__VA_ARGS__, geti4, geti3, geti2, geti1) (__VA_ARGS__)\n\n#define INF 7654321\n#define IINF 87654321987654321LL\n#define MAXV 200500\n\nll mod = 1e9 + 7;\n\n\nint dp[500][500][500];\nstring s;\nint N,K;\n\nint solve(int l, int r, int k){\n\n\tif( l == r ) return 1;\n\tif( l > r ) return 0;\n\n\tint& res = dp[l][r][k];\n\tif( res != -1 ) return res;\n\tres = 0;\n\tif( s[l] == s[r] ){\n\t\tres = max(res, 2 + solve(l+1,r-1,k) );\n\t}\n\telse{\n\t\tif( k > 0 ){\n\t\t\tres = max(res, 2 + solve(l+1,r-1,k-1) );\n\t\t}\n\t\tres = max(res, solve(l+1,r,k) );\n\t\tres = max(res, solve(l,r-1,k) );\n\t}\n\n\n\treturn res;\n}\t\n\nint main(){\n\tmemset(dp,-1,sizeof dp);\n\tcin >> s >> K;\n\tN = sz(s);\n\n\tcout << solve(0,N-1,K);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint dp[302][302][302];\n\nint main()\n{\n    string s;\n    cin >> s;\n    int n = s.size();\n    int m;\n    cin >> m;\n    if(n == 1){\n        cout << 1 << endl;\n        return 0;\n    }\n    for(int k = 0; k <= m; k++){\n        for(int i = 0; i <= n; i++){\n            for(int j = 0; j <= n; j++){\n                if(i > 0) dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k]);\n                if(j > 0) dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k]);\n                if(k > 0) dp[i][j][k] = max(dp[i][j][k], dp[i][j][k - 1]);\n                if(i > 0 && j > 0){\n                    if(s[i - 1] == s[n - j]) dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + 1);\n                    else if(k > 0) dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k - 1] + 1);\n                }\n            }\n        }\n    }\n    int ans = 0;\n    if(n % 2){\n        for(int i = 0; i < n; i++){\n            ans = max(ans, dp[i][n - i - 1][m] * 2 + 1);\n        }\n    }\n    else{\n        for(int i = 0; i <= n; i++){\n            ans = max(ans, dp[i][n - i][m] * 2);\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[301][301][301];\nint main() {\n  string S;\n  int K;\n  cin >> S >> K;\n  for(auto i = 0; i < S.size(); ++i) dp[i][i][0] = dp[i][i+1][0] = 1;\n  for(auto w = 0; w <= S.size(); ++w) for(auto l = 0; l+w <= S.size(); ++l) {\n    auto r = l + w;\n    for(auto k = 0; k <= K; ++k) {\n      if(0 <= l-1)        dp[l-1][r][k] = max(dp[l-1][r][k], dp[l][r][k]);\n      if(r+1 <= S.size()) dp[l][r+1][k] = max(dp[l][r+1][k], dp[l][r][k]);\n      if(k < K)           dp[l][r][k+1] = max(dp[l][r][k+1], dp[l][r][k]);\n      if(0<=l-1 && r+1<=S.size()) {\n        dp[l-1][r+1][k] = max(dp[l-1][r+1][k], dp[l][r][k]);\n        if(k < K)        dp[l-1][r+1][k+1] = max(dp[l-1][r+1][k+1], 2 + dp[l][r][k]);\n        if(S[l-1]==S[r]) dp[l-1][r+1][k]   = max(dp[l-1][r+1][k],   2 + dp[l][r][k]);\n      }\n    }\n  }\n  cout << dp[0][S.size()][K] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\ntypedef pair<LL, LL> P;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQ(c)     (c).erase(unique(ALL((c))),(c).end())\n# define mp          make_pair\n# define eb          emplace_back\n# define FOR(i,a,b)  for(int i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(int i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nstring s;\nint n;\n\nint main() {\n\tcin >> s >> n;\n\tcout << s.size() - n - 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)a;i<=(sign)b;++i)\n#define Fordown(i,a,b) for(register sign i=(sign)a;i>=(sign)b;--i)\nconst int N=300+5;\nbool cmax(sign &a,sign b){return (a<b)?a=b,1:0;}\nbool cmin(sign &a,sign b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n  T ans=0,f=1;\n  char ch=getchar();\n  while(!isdigit(ch)&&ch!='-')ch=getchar();\n  if(ch=='-')f=-1,ch=getchar();\n  while(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n  return ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n  if(x==0)\n  {\n      putchar('0');putchar(y);\n      return;\n  }\n  if(x<0)\n  {\n      putchar('-');\n      x=-x;\n  }\n  static char wr[20];\n  int top=0;\n  for(;x;x/=10)wr[++top]=x%10+'0';\n  while(top)putchar(wr[top--]);\n  putchar(y);\n}\nvoid file()\n{\n  #ifndef ONLINE_JUDGE\n      freopen(\"d.in\",\"r\",stdin);\n      freopen(\"d.out\",\"w\",stdout);\n  #endif\n}\nchar s[N];\nint len,k;\nvoid input()\n{\n\tscanf(\"%s\",s+1);\n\tk=read<int>();\n\tlen=strlen(s+1);\n}\nint dp[N][N][N];\nvoid work()\n{\n\tif(k>=len/2){write(len,'\\n');return;}\n\tFor(i,1,len)dp[i][i][0]=1;\n\tFor(i,1,len-1)dp[i][i+1][0]=(s[i]==s[i+1]?2:1);\n\tint j;\n\tFor(l,2,len)For(i,1,len-l)\n\t{\n\t\tj=i+l;\n\t\tFor(v,0,k)\n\t\t{\n\t\t\tdp[i][j][v]=max(dp[i+1][j][v],dp[i][j-1][v]);\n\t\t\tif(s[i]==s[j])cmax(dp[i][j][v],dp[i-1][j+1][v]+2);\n\t\t\tif(!v)continue;\n\t\t\tcmax(dp[i][j][v],dp[i+1][j-1][v-1]+2);\n\t\t\tcmax(dp[i][j][v],dp[i][j][v-1]);\n\t\t}\n\t}\n\twrite(dp[1][len][k]*2-1,'\\n');\n}\nint main()\n{\n\t//file();\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 100000000\n#define YJ 1145141919\n#define INF_INT_MAX 2147483647\n#define INF_LL_MAX 9223372036854775807\n#define EPS 1e-10\n#define Pi acos(-1)\n#define LL long long\n#define ULL unsigned long long\n#define LD long double\n\nconst int MAX_S = 305;\nstring S;\nint K;\n\nint dp[MAX_S][MAX_S][MAX_S];\n\nint main()\n{\n  cin >> S;\n  cin >> K;\n  \n  memset(dp, 0, sizeof(dp));\n\n  for(int i = 0; i < S.length(); i++) {\n    dp[i][i][K] = 1;\n  }\n\n  for(int w = 0; w < S.length(); w++) {\n    for(int l = 0; l+w < S.length(); l++) {\n      int r = l+w;\n      for(int k = 0; k <= K; k++) {\n\t//何もしない\n\tif(l-1 >= 0) {\n\t  dp[l-1][r][k] = max(dp[l-1][r][k], dp[l][r][k]);\n\t}\n\tif(r+1 < S.length()) {\n\t  dp[l][r+1][k] = max(dp[l][r+1][k], dp[l][r][k]);\n\t}\n\n\t//回文を伸ばす\n\tif(l-1 >= 0 && r+1 < S.length()) {\n\t  if(S[l-1] == S[r+1]) {\n\t    dp[l-1][r+1][k] = max(dp[l-1][r+1][k], dp[l][r][k] + 2);\n\t  }\n\t  if(k > 0) {\n\t    dp[l-1][r+1][k-1] = max(dp[l-1][r+1][k-1], dp[l][r][k] + 2);\n\t  }\n\t}\n      }\n    }\n  }\n\n  int ans = 0;\n  for(int k = 0; k <= K; k++) {\n    ans = max(ans, dp[0][S.length()-1][k]);\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n//#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nint dp[333][333][333] = {};\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,x;\n  string s;\n  cin >> s >> x;\n\n  n = s.size();\n  REP(i,n) dp[i][i+1][0] = 1;\n\n  REP(len,n){\n    FOR(i,0,n+1){\n      int j = i+len;\n      if(j>=n) break;\n      REP(k,x+1){\n        if(i) chmax(dp[i-1][j+1][k+(s[i-1]!=s[j])],dp[i][j][k]+2);\n        chmax(dp[i][j+1][k],dp[i][j][k]);\n        if(i) chmax(dp[i-1][j][k],dp[i][j][k]);\n      }\n    }\n  }\n\n  int ans = 0;\n  REP(i,x+1) chmax(ans,dp[0][n][i]);\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[305][305][305];\n\nint main(){\n  \n  string s;\n  int K;\n  \n  cin>>s>>K;\n  \n  memset(dp,-1,sizeof(dp));\n\n  s='x'+s;\n  \n  int len=s.size();\n  \n  dp[1][len][0]=0;\n  \n  for(int l=1;l<len;l++)\n    \n    for(int r=len-1;r>=l;r--){\n      \n      for(int k=0;k<K;k++){\n\t\n\tif(dp[l][r][k]==-1) continue;\n\t\n\tif(s[l]==s[r]){\n\t  if(l==r) dp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]+1);\n\t  else dp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]+2);\n\t}\n\t\n\tif(l==r) continue;\n\t\n\tdp[l+1][r-1][k+1]=max(dp[l+1][r-1][k+1], dp[l][r][k]+2);\n\tdp[l+1][r][k]=max(dp[l+1][r][k], dp[l][r][k]);\n\tdp[l][r-1][k]=max(dp[l][r-1][k], dp[l][r][k]);\n\tdp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]);\n      }\n    }\n  \n  int ans=0;\n  \n  for(int i=0;i<len;i++)\n    for(int j=0;j<len;j++)\n      for(int k=0;k<=K;k++) ans=max(ans, dp[i][j][k]);\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint DP[310][310];\n\nint main()\n{\n\tstring s;\n\tcin>>s;\n\tint k;\n\tcin>>k;\n\tstring s1=s;\n\treverse(s1.begin(),s1.end());\n//\tcout<<s1<<\"\\n\";\n\tint n=s.length();\n\tfor (int i=0;i<n;i++)\n\t for (int j=0;j<n;j++)\n\t {\n\t \tif (s[i]==s1[j])\n\t \t DP[i][j]=DP[i-1][j-1]+1;\n\t \telse\n\t \t DP[i][j]=max(DP[i-1][j],DP[i][j-1]);\n\t }\n//\tcout<<DP[n-1][n-1]<<\"\\n\";\n\tcout<<min(DP[n-1][n-1]+2*k,n)<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F(i,a,b) for(int i=(a);i<=(b);++i)\n#define F2(i,a,b) for(int i=(a);i<(b);++i)\n#define dF(i,a,b) for(int i=(a);i>=(b);--i)\n#define dF2(i,a,b) for(int i=(a);i>(b);--i)\n#define dF3(i,a,b) for(int i=(a)-1;i>=(b);--i)\nusing namespace std;typedef long long ll;typedef double ld;int INF=0x3f3f3f3f;int INF2=0x7fffffff;ll LNF=0x3f3f3f3f3f3f3f3f;ll LNF2=0x7fffffffffffffff;\n\nchar str[308];\nint n,K,Ans;\nint f[305][305][305];\n\nint main(){\n\tscanf(\"%s%d\",str+1,&K); n=strlen(str+1);\n\tmemset(f,0x80,sizeof(f));\n\tF(i,1,n) F(k,0,K) f[i][i][k]=1;\n\tF(i,2,n){\n\t\tif(str[i]==str[i-1]){\n\t\t\tF(k,0,K) f[i-1][i][k]=2;\n\t\t}\n\t\telse{\n\t\t\tf[i-1][i][0]=1;\n\t\t\tF(k,1,K) f[i-1][i][k]=2;\n\t\t}\n\t}\n\tF(Q,3,n){\n\t\tF(i,1,n-Q+1){\n\t\t\tint j=i+Q-1;\n\t\t\tf[i][j][0]=max(f[i+1][j][0],max(f[i][j-1][0],f[i+1][j-1][0]+2*(str[i]==str[j])));\n\t\t\tF(k,1,min(K,Q)){\n\t\t\t\tf[i][j][k]=max(f[i+1][j][k],max(f[i][j-1][k],f[i+1][j-1][k-(str[i]!=str[j])]+2)); \n\t\t\t}\n\t\t\tF(k,min(K,Q)+1,K) f[i][j][k]=f[i][j][k-1];\n\t\t}\n\t}\n\tF(k,0,K) Ans=max(Ans,f[1][n][k]);\n\tprintf(\"%d\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<cctype>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<cstdlib>\n#include<ctime>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<fstream>\n#define ld double\n#define ull unsigned long long\n#define ll long long\n#define pii pair<int,int >\n#define iiii pair<int,pii >\n#define mp make_pair\n#define INF 1000000000\n#define MOD 1000000007\n#define rep(i,x) for(int (i)=0;(i)<(x);(i)++)\ninline int getint(){\n    int x=0,p=1;char c=getchar();\n    while (c<=32)c=getchar();\n    if(c==45)p=-p,c=getchar();\n    while (c>32)x=x*10+c-48,c=getchar();\n    return x*p;\n}\nusing namespace std;\n//ruogu\nconst int N=310;\nint n,k,dp[N][N][N];\nchar s[N];\n//\nint go(int l,int r,int x){\n\tif(l>r)return 0;\n\tif(l==r)return 1;\n\tif(dp[l][r][x]!=-1)return dp[l][r][x];\n\tint ans=max(go(l+1,r,x),go(l,r-1,x));\n\tif(s[l]==s[r])ans=max(ans,go(l+1,r-1,x)+2);\n\tif(x>0)ans=max(ans,go(l+1,r-1,x-1)+2);\n\treturn dp[l][r][x]=ans;\n}\nint main(){\n\tmemset(dp,-1,sizeof(dp));\n\tscanf(\"%s\",s);\n\tn=strlen(s);\n\tscanf(\"%d\",&k);\n\tprintf(\"%d\\n\",go(0,n-1,k));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#pragma GCC optimize(1)\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"inline\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-fipa-sra\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-ffast-math\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fdevirtualize\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"inline-functions\")\n#pragma GCC optimize(\"-ftree-tail-merge\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fpartial-inlining\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"inline-small-functions\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"inline-functions-called-once\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#include<bits/stdc++.h>\n#define R register\nusing namespace std;\nchar s[351];int len,k;\nint f[351][351][351],ans;\ninline void read(R int &x)\n{\n    x=0;R int f=1;\n\tR char c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n        if(c=='-') f=-1;\n        c=getchar();\n    }\n    while(c>=48&&c<=57)\n\t{\n        x=(x<<1)+(x<<3)+(c^48);\n        c=getchar();\n    }\n\tx=x*f;\n}\ninline void input_data()\n{\n\tchar ch=getchar();\n\twhile(ch>='a'&&ch<='z')\n\t\ts[++len]=ch,ch=getchar();\n\tread(k);return;\n}\nint dfs(R int k,R int l,R int r)\n{\n\tif(l>r) return false;\n\tif(l==r) return s[l]==s[r];\n\tif(f[k][l][r]) return f[k][l][r];\n\tf[k][l][r]=max(dfs(k,l+1,r),dfs(k,l,r-1));\n\tif(s[l]==s[r]) f[k][l][r]=max(f[k][l][r],dfs(k,l+1,r-1)+2);\n\tif(k>=1) f[k][l][r]=max(f[k][l][r],dfs(k-1,l+1,r-1)+2);\n\treturn f[k][l][r];\n}\nint main()\n{\n\tinput_data();\n\tfor(R int i=0;i<=k;++i)\n\t\tans=max(ans,dfs(i,1,len));\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define pb push_back\n#define F first\n#define S second\nusing namespace std;\nconst int N = 3e2+10;\nint dp[N][N][N];\nmain(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    string s;cin>>s;\n    int k;cin>>k;\n    int n=s.length();\n    for(int i=0;i<n;i++)\n        for(int j=i+1;j<=n;j++)\n            for(int ch=0;ch<=k;ch++){\n                int curr=j-i;\n                //cout<<curr;\n                if(curr!=j){\n                    if(s[curr-1]!=s[j-1]){\n                        dp[j][curr][ch]=max(dp[j-1][curr][ch],dp[j][curr+1][ch]);\n                        if(ch>0)\n                            dp[j][curr][ch]=max(2+dp[j-1][curr+1][ch-1],dp[j][curr][ch]);\n                        continue;\n                    }\n                    else\n                        dp[j][curr][ch]=2+dp[j-1][curr+1][ch];\n                }\n                else\n                    dp[j][curr][ch]=1;\n            }\n    cout<<dp[n][1][k];\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n#define INF 1000000000\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint dp[333][333][333];\nstring s;\nint k;\n\nint dfs(int K,int L,int R)\n{\n//\tcout << K << ' ' << L << ' ' << R << endl;\n\tif(K < 0)return -100000000;\n\tif(L > R)return 0;\n\tif(dp[K][L][R] != 0)return dp[K][L][R];\n\tint ret = 0;\n\tif(s[L] == s[R])ret = max(ret,dfs(K,L+1,R-1)+2);\n\telse ret = max(ret,dfs(K-1,L+1,R-1)+2);\n\tret = max(ret,dfs(K,L+1,R));\n\tret = max(ret,dfs(K,L,R-1));\n\t\n\treturn dp[K][L][R] = ret;\n}\n\n\nint main()\n{\n\tcin >> s >> k;\n\t\n\tREP(K,333)REP(i,333)dp[K][i][i] = 1;\n\tREP(K,333)REP(i,s.size()-1)\n\t{\n\t\tif(s[i] == s[i+1])dp[K][i][i+1] = 2;\n\t\telse dp[K][i][i+1] = 1;\n\t\tif(K > 0)dp[K-1][i][i+1] = 2;\n\t}\n\t\n\tcout << dfs(k,0,s.size()-1) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int, int >\n#define F first\n#define S second\n#define int long long int\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize (\"Ofast\")\nusing namespace std;\n/// khodaya komak kon\n/// ya navid navid\n/// ye tec khaphan ke yadam bemone : age jayi didi soale masir hamiltoni mikhad rasasho bokon yal oilery;https://mobomovie1.top/series/%D8%AF%D8%A7%D9%86%D9%84%D9%88%D8%AF-%D8%B3%D8%B1%DB%8C%D8%A7%D9%84-%D9%81%D8%B1%DB%8C%D9%86%D8%AC-fringe-2008-2013-%D8%A8%D8%A7-%D8%B2%D9%8A%D8%B1%D9%86%D9%88%D9%8A%D8%B3-%D9%81%D8%A7%D8%B1/\n/// age ye ja mikhasti to dp az ozv i k ta entekhab koni bejash ye log bezan (nominal) hamoon 2**k va o 1 ent kon\nconst int N=302;\nll dp[N][N][N];\nll par[N][N][2];\nint32_t main(){\n    string s;\n    cin >> s;\n    ll k;\n    cin >> k;\n    ll n=s.size();\n    for (int i=0;i<n;i++){\n        for (int j=0;j<N;j++){\n            dp[i][i+1][j]=1;\n        }\n    }\n    for (int i=0;i<n;i++){\n        for (int j=i+2;j<=n;j++){\n            for (int l=i;l<j;l++){\n                if (s[l]==s[j-1]){\n                    par[i][j][1]=l;\n                    break;\n                }\n\n            }\n            for (int l=j-1;l>=i;l--){\n                if (s[l]==s[i]){\n                    par[i][j][0]=l;\n                    break;\n                }\n            }\n        }\n    }\n    for (int i=n-1;i>-1;i--){\n        for (int j=i+2;j<=n;j++){\n            for (int l=0;l<=k;l++){\n                dp[i][j][l]=max(dp[i+1][j][l],dp[i][j-1][l]);\n                if (l>0){\n                    dp[i][j][l]=max(dp[i][j][l],2+dp[i+1][j-1][l-1]);\n                }\n                ll p=par[i][j][0];\n                if (p!=i){\n                    dp[i][j][l]=max(dp[i][j][l],2+dp[i+1][p][l]);\n                }\n                p=par[i][j][1];\n                if (p!=j-1){\n                    dp[i][j][l]=max(dp[i][j][l],2+dp[p+1][j-1][l]);\n                }\n                //cout << i << \" \" << j << \" \" << l << \" \" << dp[i][j][l]  << endl;\n\n\n            }\n\n        }\n    }\n    //cout << 3 << endl;\n    cout << dp[0][n][k] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma warning(disable : 4996)\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<math.h>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<cstring>\n#include<cstdio>\n#include<functional>\n#include<bitset>\n#include<limits.h>\n#include<cassert>\n#include<iterator>\n#include<complex>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<time.h>\n#include<random>\n#include<array>\n\n\nusing namespace std;\n\n#define REP(i, n) for(int i = 0;i < n;++i)\n#define REPR(i, n) for(int i = n-1;i >= 0;--i)\n#define FOR(i, m, n) for(int i = m;i < n;++i)\n#define FORR(i, m, n) for(int i = m-1;i >= n;--i)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define REVERSE(v,n) reverse(v,v+n);\n#define VREVERSE(v) reverse(v.begin(), v.end())\n#define ll long long\n#define print(x) cout<<(x)<<'\\n'\n#define pe(x) cout<<(x)<<\" \"\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define lb(v,n) lower_bound(v.begin(), v.end(), (n))\n#define ub(v,n) upper_bound(v.begin(), v.end(), (n))\n#define int long long\n//#define double long double\n#define all(x) (x).begin(), (x).end()\n#define print_space(v) REP(i,v.size())cout << v[i] << ((i == v.size() - 1) ? \"\\n\" : \" \")\ntemplate<typename T1, typename T2> inline void chmin(T1 & a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1& a, T2 b) { if (a < b) a = b; }\ntypedef pair<int, int>P;\nstd::random_device rd;\nstd::mt19937 mt(rd());\nconstexpr int MOD = 1e9+7; constexpr int MAX = 200020;\nconst double pi = acos(-1); constexpr double EPS = 1e-8;\nconstexpr ll INF = 1e18;\n\nstring S; int K;\n\nint dp[303][303][303];\nint rec(int l, int r, int k) {\n\tif(dp[l][r][k])return dp[l][r][k];\n\tint res = 0;\n\tif (l == r)res = 1;\n\telse if (l + 1 == r) {\n\t\tif (S[l] == S[r] || k)res = 2;\n\t\telse res = 1;\n\t}\n\telse {\n\t\tchmax(res, rec(l + 1, r, k));\n\t\tchmax(res, rec(l, r - 1, k));\n\t\tif (S[l] == S[r])chmax(res, rec(l + 1, r - 1, k) + 2);\n\t\telse if (k > 0)chmax(res, rec(l + 1, r - 1, k - 1) + 2);\n\t}\n\treturn dp[l][r][k] = res;\n}\n\nvoid solve() {\n\tcin >> S >> K;\n\tint N = S.size();\n\tprint(rec(0, N, K));\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t//int q; cin >> q;\n\t//while (q--)\n\tsolve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=305;\nstring s;\nint k,dp[N][N][N];\nint main() {\n\tios::sync_with_stdio(false);\n\t\n\tcin>>s;\n\tcin>>k;\n\t\n\tfor (int len=0; len<s.size(); len++)\n\t\tfor (int l=0; l+len<s.size(); l++) \n\t\t\tfor (int x=0; x<=min(k,len); x++) {\n\t\t\t\tint r=l+len;\n\t\t\t\tif (l==r) dp[l][r][x]=1;\n\t\t\t\tif (l<r) dp[l][r][x]=max(dp[l][r][x],dp[l][r-1][x]);\n\t\t\t\tif (l<r) dp[l][r][x]=max(dp[l][r][x],dp[l+1][r][x]);\n\t\t\t\tif (l+1==r && s[l]!=s[r] && x) dp[l][r][x]=dp[l][r-1][x-1]+1;\n\t\t\t\t\t\telse \n\t\t\t\tif (l+1==r && s[l]==s[r] && !x) dp[l][r][x]=2;\n\t\t\t\tif (r && r-l>1 && s[l]!=s[r] && x) dp[l][r][x]=max(dp[l][r][x],dp[l+1][r-1][x-1]+2);\n\t\t\t\t\telse\n\t\t\t\tif (r && r-l>1 && s[l]==s[r]) dp[l][r][x]=max(dp[l][r][x],dp[l+1][r-1][x]+2);\t\n\t\t\t}\n\t\n\tcout<<dp[0][s.size()-1][k]<<endl;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 310;\n\ninline int read() {\n\tint x = 0, f = 1;\n\tchar ch = getchar();\n\tfor(; !isdigit(ch); ch = getchar()) if(ch=='-') f=-1;\n\tfor(; isdigit(ch); ch = getchar()) x = (x*10)+(ch^48);\n\treturn x * f;\n}\n\nchar s[310];\nint dp[MAXN][MAXN][MAXN], K, n, ans;\n\ninline void chkmax(int &cur, int val) {\n\tif(val > cur) cur = val;\n}\n\nint main() {\n\tscanf(\"%s\", s+1);\n\tK = read();\n\tn = strlen(s+1);\n\tif(n == 1) {\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\tint i, j, k, d;\n\tdp[1][n][0] = s[1] == s[n] ? 2 : 0;\n\tdp[1][n][1] = 2;\n\tfor(d = n-1; d > 1; d--) \n\t\tfor(i = 1; i+d <= n; i++) {\n\t\t\tj = i+d;\n\t\t\tfor(k = 0; k <= K; k++) {\n\t\t\t\tchkmax(dp[i][j-1][k], dp[i][j][k]);\n\t\t\t\tchkmax(dp[i+1][j][k], dp[i][j][k]);\n\t\t\t\tif(i + 1 != j-1) {\n\t\t\t\t\tchkmax(dp[i+1][j-1][k], dp[i][j][k]+(s[i+1] == s[j-1] ? 2 : 0));\n\t\t\t\t\tchkmax(dp[i+1][j-1][k+1], dp[i][j][k]+2);\n\t\t\t\t}\n\t\t\t\telse chkmax(dp[i+1][j-1][k], dp[i][j][k]+1);\n\t\t\t\tchkmax(ans, dp[i][j][k]);\n\t\t\t}\n\t\t}\n\tfor(i = 1; i < n; i++) \n\t\tfor(k = 0; k <= K; k++) \n\t\t\tchkmax(ans, dp[i][i+1][k]);\n\tfor(i = 1; i <= n; i++)\n\t\tfor(k = 0; k <= K; k++)\n\t\t\tchkmax(ans, dp[i][i][k]);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define PB push_back\n#define MP make_pair\nusing namespace std;\ntypedef long long LL;\nconst int MAXN=150 + 10;\n\nchar inis[MAXN*2], s[MAXN], t[MAXN];\nint n,m , f[MAXN][MAXN][MAXN],mdf, g[MAXN*2][MAXN*2][MAXN];\n\nint main(){\n\t\n\tscanf(\"%s\", s+1);scanf(\"%d\", &mdf);\n\tmdf=min(mdf, 150);\n\tfor (int i=1,j=n; i<=n; i++,j--) t[j]=s[i];\n\tint n= strlen(s+1);\n\tmemset(g, 0 ,sizeof(g));\n\tfor (int i=1; i<=n; i++) g[i][i][0] = 1;\n\tfor (int L=2; L<=n; L++)\n\t\tfor (int i=1; i<=n; i++){\n\t\t\tint j=i+L-1;\n\t\t\tfor (int k=0; k<=mdf; k++){\n\t\t\t\tint &cur= g[i][j][k];\n\t\t\t\tcur= max(g[i+1][j][k], g[i][j-1][k]);\n\t\t\t\tif ( s[i]==s[j]) cur= max(cur, g[i+1][j-1][k]+2);\n\t\t\t\t\telse\n\t\t\t\tif ( k) cur= max(cur, g[i+1][j-1][k-1]+2);\n\t\t\t}\n\t\t}\n\tint nn=n/2;\n\tfor (int i=1; i<=nn; i++)\n\t\tfor (int j=1;j<=n; j++)\n\t\t\tfor (int k=0; k<=mdf; k++){\n\t\t\t\tint &cur= f[i][j][k];cur= max(f[i-1][j][k], f[i][j-1][k]);\n\t\t\t\tif ( s[i]==t[j]) cur= max( cur,  f[i-1][j-1][k]+1);\n\t\t\t\t\telse\n\t\t\t\tif ( k) cur= max( cur, max(f[i-1][j][k-1], f[i][j-1][k-1])+1);\n\t\t\t}\n\tint ans=0;\n\tfor (int i=1; i<=nn; i++)\n\t\tfor (int k=0; k<=mdf ; k++) ans= max(ans, (f[i][i][k]<<1)+ g[i+1][n-i][mdf-k]);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define REP(e,v) for(auto e:v)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\n#define MAX_V 400010\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\n\n#define INF 1e9+7\n#define LLINF 1e18+7\nll MOD=924844033;\n#define N 1055050\n\nll n,m,k;\nstring s;\nvector<vec> mm(300,vec(1,-1));\nvector<vector<vec>> mem(300,vector<vec>(300,vec(300,-1)));\nint dfs(int l,int r,int c){\n    if(c>k)return -2;\n    if(l>r)return -2;\n    if(l==r)return 1;\n    if(mem[l][r][c]!=-1) return mem[l][r][c];\n    if(s[l]==s[r]){\n        return mem[l][r][c]=2+dfs(l+1,r-1,c);\n    }\n    int count=0;\n    count=max(dfs(l+1,r,c),count);\n    count=max(count,dfs(l,r-1,c));\n    count=max(count,dfs(l+1,r-1,c+1)+2);\n    return mem[l][r][c]=count;\n}\n\nmain(){\n    cin>>s;\n    n=s.size();\n    k=in();\n    cout<<dfs(0,n-1,0);\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\n#define MOD 1000000007\n#define MOD2 998244353\n#define int long long\n#define double long double\n#define EPS 1e-9\n//#define PI 3.14159265358979\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nusing namespace std;\n\ntemplate < typename T >\nostream &operator<<(ostream &os, const vector< T > &A) {\n\tfor (int i = 0; i < A.size(); i++)\n\t\tos << A[i] << \" \";\n\tos << endl;\n\treturn os;\n}\ntemplate <>\nostream &operator<<(ostream &os, const vector< vector< int > > &A) {\n\tint N = A.size();\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < A[i].size(); j++)\n\t\t\tos << A[i][j] << \" \";\n\t\tos << endl;\n\t}\n\treturn os;\n}\ntemplate < typename T, typename U >\nostream &operator<<(ostream &os, const pair< T, U > &p) {\n\tos << \"(\" << p.first << \",\" << p.second << \")\";\n\treturn os;\n}\ntemplate < typename T, typename U >\nistream &operator>>(istream &is, pair< T, U > &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate < typename T >\nistream &operator>>(istream &is, vector< T > &A) {\n\trep(i, A.size()) is >> A[i];\n\treturn is;\n}\n\ntypedef pair< int, int > pii;\ntypedef long long ll;\n\nstruct edge {\n\tint from, to, d, c, i;\n\tedge(int _from = 0, int _to = 0, int _d = 0, int _c = 0) {\n\t\tfrom = _from;\n\t\tto = _to;\n\t\td = _d;\n\t\tc = _c;\n\t}\n\tbool operator<(const edge &rhs) const {\n\t\treturn (d == rhs.d) ? (c < rhs.c) : (d < rhs.d);\n\t}\n};\nstruct aabb {\n\tint x1, y1, x2, y2;\n\taabb(int x1, int y1, int x2, int y2) : x1(x1), y1(y1), x2(x2), y2(y2) {}\n};\n\ntypedef vector< edge > edges;\ntypedef vector< edges > graph;\nstruct flow {\n\tint to, cap, rev, cost;\n\tflow(int to = 0, int cap = 0, int rev = 0, int cost = 0) : to(to), cap(cap), rev(rev), cost(cost) {}\n};\ntypedef vector< vector< flow > > flows;\n\nconst int di[4] = {0, -1, 0, 1};\nconst int dj[4] = {-1, 0, 1, 0};\nconst int ci[5] = {0, 0, -1, 0, 1};\nconst int cj[5] = {0, -1, 0, 1, 0};\nconst ll LINF = LLONG_MAX / 2;\nconst int INF = INT_MAX / 2;\nconst double PI = acos(-1);\n\nint pow2(int n) { return 1LL << n; }\ntemplate < typename T, typename U >\nbool chmin(T &x, const U &y) {\n\tif (x > y) {\n\t\tx = y;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate < typename T, typename U >\nbool chmax(T &x, const U &y) {\n\tif (x < y) {\n\t\tx = y;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\ntemplate < typename A, size_t N, typename T >\nvoid Fill(A (&array)[N], const T &val) {\n\tfill((T *)array, (T *)(array + N), val);\n}\nstruct initializer {\n\tinitializer() {\n\t\tcout << fixed << setprecision(20);\n\t}\n};\ninitializer _____;\n\nint N, M, K, T, Q, H, W;\nsigned main() {\n\tstatic int dp[301][301][301];\n\tFill(dp, -1);\n\tstring S;\n\tcin >> S >> K;\n\tN = S.size();\n\tauto f = [&](auto &&f, int l, int r, int k) -> int {\n\t\tif (dp[l][r][k] != -1)\n\t\t\treturn dp[l][r][k];\n\t\tif (l > r)\n\t\t\treturn 0;\n\t\tif (l == r)\n\t\t\treturn 1;\n\t\tint ret = 0;\n\t\tchmax(ret, f(f, l, r - 1, k));\n\t\tchmax(ret, f(f, l + 1, r - 1, k));\n\t\tif (S[l] == S[r]) {\n\t\t\tchmax(ret, f(f, l + 1, r - 1, k) + 2);\n\t\t} else if (k > 0) {\n\t\t\tchmax(ret, f(f, l + 1, r - 1, k - 1) + 2);\n\t\t}\n\t\treturn dp[l][r][k] = ret;\n\t};\n\tint ans = 0;\n\trep(k, K + 1) {\n\t\tchmax(ans, f(f, 0, N - 1, k));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <iomanip>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\n\nmt19937 rnd(228);\n\nconst int N = 300 + 1;\n\nint dp[N][N][N];\n\nint main()\n{\n#ifdef ONPC\n    freopen(\"a.in\", \"r\", stdin);\n#endif\n    string s;\n    cin >> s;\n    int k;\n    cin >> k;\n    int n = (int) s.size();\n    for (int len = 1; len <= n; len++)\n    {\n        for (int i = 0; i + len - 1 < n; i++)\n        {\n            int j = i + len - 1;\n            for (int cur = 0; cur <= k; cur++)\n            {\n                if (len == 1)\n                {\n                    dp[i][j][cur] = 1;\n                    continue;\n                }\n                if (cur - 1 >= 0)\n                {\n                    dp[i][j][cur] = max(dp[i][j][cur], dp[i][j][cur - 1]);\n                }\n                if (i + 1 < n)\n                {\n                    dp[i][j][cur] = max(dp[i][j][cur], dp[i + 1][j][cur]);\n                }\n                if (j - 1 >= 0)\n                {\n                    dp[i][j][cur] = max(dp[i][j][cur], dp[i][j - 1][cur]);\n                }\n                if (s[i] == s[j])\n                {\n                    dp[i][j][cur] = max(dp[i][j][cur], dp[i + 1][j - 1][cur] + 2);\n                }\n                else if (cur - 1 >= 0 && i + 1 < n && j - 1 >= 0)\n                {\n                    dp[i][j][cur] = max(dp[i][j][cur], dp[i + 1][j - 1][cur - 1] + 2);\n                }\n            }\n        }\n    }\n    cout << dp[0][n - 1][k] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m;\nchar str[310];\nint D[310][310][310];\n\nint main() {\n    int i, j, k, l;\n\n    scanf(\"%s\",str); n = strlen(str);\n    scanf(\"%d\",&m);\n    for (l=0;l<n;l++) {\n        for (i=0;i<n-l;i++) {\n            j = i+l;\n            for (k=0;k<=l+1;k++) {\n                if (!l) {\n                    D[i][j][k] = 1;\n                    continue;\n                }\n                D[i][j][k]=max({D[i+1][j][k],D[i][j-1][k],D[i+1][j-1][k]+2*(str[i]==str[j])});\n                if (k) D[i][j][k]=max({D[i][j][k],D[i+1][j-1][k-1]+2,D[i][j][k-1]});\n            }\n        }\n    }\n    printf(\"%d\\n\",D[0][n-1][m]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <utility>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#define my_abs(x) ((x) < 0 ? -(x) : (x))\n#define mp std::make_pair\n#define pb push_back\n#define X first\n#define Y second\ntypedef long long ll; \nchar str[305]; \nint dp[305][305][305], n; \nint calc(int l, int r, int k)\n{\n\tif (k < 0)\n\t\treturn -1e9; \n\tif (l > r)\n\t\treturn 0; \n\tif (~dp[l][r][k])\n\t\treturn dp[l][r][k]; \n\tint res = std::max(calc(l + 1, r, k), calc(l, r - 1, k)); \n\tif (str[l] == str[r])\n\t\tres = std::max(res, calc(l + 1, r - 1, k) + (l != r) + 1); \n\treturn dp[l][r][k] = std::max(res, calc(l + 1, r - 1, k - 1) + 2); \n}\nint main()\n{\n\t// freopen(\"AGC021-D.in\", \"r\", stdin); \n\tint k; \n\tscanf(\"%s%d\", str, &k); \n\tn = strlen(str); \n\tmemset(dp, -1, sizeof(dp)); \n\tprintf(\"%d\\n\", calc(0, n - 1, k));\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring s;\n\nint dp[305][305][305];\n\nint dfs(int l, int r, int k)\n{\n    if(r < l)\n        return 0;\n    if(l == r)\n        return 1;\n    int &res = dp[l][r][k];\n    if(res != -1)\n        return res;\n    res = max(dfs(l, r - 1, k), dfs(l + 1, r, k));\n    if(s[l] == s[r])\n        res = max(res, dfs(l + 1, r - 1, k) + 2);\n    if(k)\n        res = max(res, dfs(l + 1, r - 1, k - 1) + 2);\n    return res;\n\n}\n\nint main()\n{\n    int k;\n    cin >> s >> k;\n    memset(dp, -1, sizeof dp);\n\n    cout << dfs(0, s.size() - 1, k);\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define in(x,y,h,w) x >= 0 && x < h && y >= 0 && y < w\n\n#define int long long\n#define double long double\n//typedef    long long          ll;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\n//typedef    pair<int,int>      P;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n \nconst int INF=1e+18;\nconst double EPS=1e-15;\nconst int MOD=1000000007;\n \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint n,k,ind[26][301],dp[301][301][301];\nstring s;\n\nint dfs(int l,int r,int x){\n\tif(dp[l][r][x] != -1) return dp[l][r][x];\n\tif(r == l) return 0;\n\tif(r - l == 1) return 1;\n\tif(s[l] == s[r - 1]) dp[l][r][x] = dfs(l + 1,r - 1,x) + 2;\n\tchmax(dp[l][r][x],max(dfs(l + 1,r,x),max(dfs(l,r - 1,x),(x ? dfs(l + 1,r - 1,x - 1) + 2 : 0))));\n\treturn dp[l][r][x];\n}\n\nsigned main(){\n\tcin >> s >> k;\n\tn = s.length();\n\tfor(int i = 0;i <= n;i++){\n\t\tfor(int j = 0;j <= n;j++){\n\t\t\tfor(int l = 0;l <= k;l++) dp[i][j][l] = -1;\n\t\t}\n\t}\n\tfor(int i = 0;i < 26;i++) ind[i][0] = -1;\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < 26;j++){\n\t\t\tif(s[i] - 'a' == j) ind[j][i + 1] = i;\n\t\t\telse ind[j][i + 1] = ind[j][i];\n\t\t}\n\t}\n\tcout << dfs(0,n,k) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    string s;\n    int change;\n    cin >> s >> change;\n    int n = s.size();\n\n    string t;\n    for (int i = n - 1; i >= 0; i--)t += s[i];\n\n    vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(n + 1, vector<int>(change + 1, -114514)));\n    for (int i = 0; i <= n; i++) {\n        for (int k = 0; k <= change; k++) {\n            dp[i][0][k] = 0;\n            dp[0][i][k] = 0;\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            for (int k = 0; k <= change; k++) {\n                if (s[i - 1] == t[j - 1])dp[i][j][k] = dp[i - 1][j - 1][k] + 1;\n                else dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k]);\n\n                if (k > 0) {\n                    dp[i][j][k] = max({dp[i][j][k - 1],\n                                       dp[i - 1][j][k - 1] + 1,\n                                       dp[i][j - 1][k - 1] + 1});\n                }\n            }\n        }\n    }\n\n    cout << dp[n][n][change] + change << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\n#define maz(a,b) a=max(a,b);\ntypedef long long ll;\n\nusing namespace std;\n#define N 310\nll d[N][N][N],n,x;\nstring s;\nint main(){\n    cin>>s>>x; n=s.size();\n    lol(k,x+1)lol(i,n)d[0][i][k]=0,d[1][i][k]=1;\n    for(ll t=2;t<=n;t++){\n\tfor(ll i=0;i+t-1<n;i++)lol(k,x+1){\n\t    ll l=i,r=i+t-1;\n\t    ll res=max(d[t-1][i][k],d[t-1][i+1][k]);\n\t    if(s[l]==s[r]){\n\t\tmaz(res,d[t-2][i+1][k]+2);\n\t    }\n\t    else if(k){\n\t\tmaz(res,d[t-2][i+1][k-1]+2);\n\t    }\n\t    d[t][i][k]=res;\n\t}\n    }\n    cout<<d[n][0][x]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nconstexpr lint mod = 998244353;\n#define all(x) (x).begin(), (x).end()\n#define bitcount(n) __builtin_popcountl((lint)(n))\n#define fcout cout << fixed << setprecision(15)\n#define highest(x) (63 - __builtin_clzl(x))\n#define rep(i, n) for(int i = 0; i < int(n); i++)\n#define rep2(i, l, r) for(int i = int(l); i < int(r); i++)\n#define repr(i, n) for(int i = int(n) - 1; i >= 0; i--)\n#define repr2(i, l, r) for(int i = int(r) - 1; i >= int(l); i--)\n#define SZ(x) int(x.size())\nconstexpr int inf9 = 1e9; constexpr lint inf18 = 1e18;\ninline void YES(bool condition){ if(condition) cout << \"YES\" << endl; else cout << \"NO\" << endl; }\ninline void Yes(bool condition){ if(condition) cout << \"Yes\" << endl; else cout << \"No\" << endl; }\ninline void assert_NO(bool condition){ if(!condition){ cout << \"NO\" << endl; exit(0); } }\ninline void assert_No(bool condition){ if(!condition){ cout << \"No\" << endl; exit(0); } }\ninline void assert_m1(bool condition){ if(!condition){ cout << -1 << endl; exit(0); } }\nlint power(lint base, lint exponent, lint module){ if(exponent % 2){ return power(base, exponent - 1, module) * base % module; }else if(exponent){ lint root_ans = power(base, exponent / 2, module); return root_ans * root_ans % module; }else{ return 1; }}\nstruct position{ int y, x; }; position mv[4] = {{0, -1}, {1, 0}, {0, 1}, {-1, 0}}; double euclidean(position first, position second){ return sqrt((second.x - first.x) * (second.x - first.x) + (second.y - first.y) * (second.y - first.y)); }\ntemplate<class T, class U> string to_string(pair<T, U> x){ return to_string(x.first) + \",\" + to_string(x.second); } string to_string(string x){ return x; }\ntemplate<class itr> void array_output(itr start, itr goal){ string ans; for(auto i = start; i != goal; i++) ans += to_string(*i) + \" \"; if(!ans.empty()) ans.pop_back(); cout << ans << endl; }\ntemplate<class itr> void cins(itr first, itr last){ for(auto i = first; i != last; i++){ cin >> (*i); } }\ntemplate<class T> T gcd(T a, T b){ if(b) return gcd(b, a % b); else return a; }\ntemplate<class T> T lcm(T a, T b){ return a / gcd(a, b) * b; }\nstruct combination{ vector<lint> fact, inv; combination(int sz) : fact(sz + 1), inv(sz + 1){ fact[0] = 1; for(int i = 1; i <= sz; i++){ fact[i] = fact[i - 1] * i % mod; } inv[sz] = power(fact[sz], mod - 2, mod); for(int i = sz - 1; i >= 0; i--){ inv[i] = inv[i + 1] * (i + 1) % mod; } } lint P(int n, int r){ if(r < 0 || n < r) return 0; return (fact[n] * inv[n - r] % mod); } lint C(int p, int q){ if(q < 0 || p < q) return 0; return (fact[p] * inv[q] % mod * inv[p - q] % mod); } };\ntemplate<class itr> bool next_sequence(itr first, itr last, int max_bound){ itr now = last; while(now != first){ now--; (*now)++; if((*now) == max_bound){ (*now) = 0; }else{ return true; } } return false; }\ntemplate<class itr, class itr2> bool next_sequence2(itr first, itr last, itr2 first2, itr2 last2){ itr now = last; itr2 now2 = last2; while(now != first){ now--, now2--; (*now)++; if((*now) == (*now2)){ (*now) = 0; }else{ return true; } } return false; }\ntemplate<class T> bool chmax(T &a, const T &b){ if(a < b){ a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b){ if(b < a){ a = b; return 1; } return 0; }\ninline int at(lint i, int j){ return (i >> j) & 1; }\nrandom_device rnd;\nbool is_in_board(lint y, lint x, lint H, lint W){ return (0 <= y && y < H && 0 <= x && x < W); }\n\nint dp[310][310][310];\n\nstring S;\nint K;\n\nint LCS(int now, int rev_now, int used){\n    if(now >= S.size() || rev_now < 0){\n        return 0;\n    }\n    if(dp[now][rev_now][used] != -1){\n        return dp[now][rev_now][used];\n    }\n    int ans = max(LCS(now + 1, rev_now, used), LCS(now, rev_now - 1, used));\n    if(S[now] == S[rev_now]){\n        ans = max(ans, LCS(now + 1, rev_now - 1, used) + 1);\n    }\n    if(used){\n        ans = max({ans, LCS(now + 1, rev_now - 1, used - 1) + 1});\n    }\n    return dp[now][rev_now][used] = ans;\n}\n\nint main(){\n    cin >> S >> K;\n    memset(dp, -1, sizeof(dp));\n    int ans = 0;\n    rep(i, S.size()){\n        ans = max(ans, LCS(i + 1, i - 1, K) * 2 + 1);\n    }\n    rep(i, S.size() + 1){\n        ans = max(ans, LCS(i, i - 1, K) * 2);\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define vi vector<int>\n#define vvi vector<vi>\n#define vs vector<string>\n#define pb push_back\n#define P pair<int,int>\n#define vp vector<P>\n#define PP pair<int,P>\n#define vpp vector<PP>\n#define fi first\n#define se second\n#define INF 1e9\n#define MOD 1000000007\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REPR(i,n) for(int i=n;i>=0;i--)\n#define FOR(i,m,n) for(int i=m;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nint dp[300][300][301];\nstring st;\nint dfs(int l,int r,int x){\n    if(r<l){\n        return 0;\n    }\n    if(l==r){\n        return 1;\n    }\n    if(dp[l][r][x]!=-1){\n        return dp[l][r][x];\n    }\n    int res=max(dfs(l+1,r,x),dfs(l,r-1,x));\n    if(st[l]==st[r]){\n        res=max(res,dfs(l+1,r-1,x)+2);\n    }else{\n        if(x)res=max(res,dfs(l+1,r-1,x-1)+2);\n    }\n    return dp[l][r][x]=res;\n}\nint main(){\n    cin>>st;\n    int k;\n    cin>>k;\n    REP(i,300){\n        REP(j,300){\n            REP(k,300){\n                dp[i][j][k]=-1;\n            }\n        }\n    }\n    cout<<dfs(0,st.size()-1,k)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 300+5;\nchar s[N];\nint f[N][N][N];\nbool v[N][N][N];\ninline int q(int l,int r,int k){\n\tif(r-l+1<=1)return r-l+1>=1;\n\tif(v[l][r][k])return f[l][r][k];\n\tv[l][r][k]=1;\n\tint diff = s[l]!=s[r];\n\tf[l][r][k]=max(q(l+1,r,k), q(l,r-1,k));\n\tif(k - diff>=0)f[l][r][k]=max(f[l][r][k],q(l+1,r-1,k-diff)+2);\n\treturn f[l][r][k];\n}\n\nint main(){\n\tscanf(\"%s\",s+1);\n\tint k;cin >> k;\n\tcout << q(1,strlen(s+1),k) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst ll p = 998244353;\n\nstring s;\nint kk, n;\n\nint dp[305][305][305];\n\nint comp(int i, int j, int k) {\n\tif (k < 0)\n\t\treturn -1000;\n\tif (i > j)\n\t\treturn 0;\n\n\tif (dp[i][j][k] != -1)\n\t\treturn dp[i][j][k];\n\n\tif (i == j) {\n\t\tdp[i][j][k] = 1;\n\t\treturn dp[i][j][k];\n\t}\n\n\tif (s[i] == s[j]) {\n\t\tdp[i][j][k] = 2 + comp(i+1, j-1, k);\n\t\treturn dp[i][j][k];\n\t}\n\n\tdp[i][j][k] = comp(i+1, j, k);\n\tdp[i][j][k] = max(dp[i][j][k], comp(i, j-1, k));\n\tdp[i][j][k] = max(dp[i][j][k], 2 + comp(i+1, j-1, k-1));\n\n\t// cout << i << ' ' << j << ' ' << k << ' ' << dp[i][j][k] << endl;\n\treturn dp[i][j][k];\n}\n\nint main() {\n\tcin >> s >> kk;\n\tn = s.length();\n\n\tfor (int i = 0; i < 305; ++i)\n\t\tfor (int j = i; j < 305; ++j)\n\t\t\tfor (int a = 0; a <= kk; ++a)\n\t\t\t\tdp[i][j][a] = -1;\n\n\tcout << comp(0, n-1, kk) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define int long long\n\n#define all(X) (X).begin(), (X).end()\n#define reset(X) memset(X, 0, sizeof(X))\n#define mp(a, b) make_pair(a, b)\n#define pb push_back\n#define endl '\\n'\n#define fi first\n#define se second\n\nusing namespace __gnu_pbds;\nusing namespace std;\nconst int mod = 1e9 + 7;\n// const int mod=998244353;\n//const int mod=1e9+9;\n//const int INF=4e18+10;\nconst int INF = 4e18 + 10;\ntemplate <typename T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T>\nusing ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define read(n) \\\nint n;      \\\ncin >> n;\n#define readv(x, n)   \\\nvector<int> x(n); \\\nfor (auto &i : x) \\\n    cin >> i;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> pii;\n\ntemplate <typename T1, typename T2>\nvoid set_min(T1 &a, T2 b)\n{\n    a = min(a, (T1)b);\n}\n\nint multiply(int a, int b, int in_mod) { return (a * b) % in_mod; }\nint mult_identity(int a) { return 1; }\n\n\nauto power(auto a, int b, int in_mod)\n{\n    auto prod = mult_identity(a);\n    auto mult = a % in_mod;\n    while (b != 0)\n    {\n        if (b % 2)\n        {\n            prod = multiply(prod, mult, in_mod);\n        }\n        mult = multiply(mult, mult, in_mod);\n        b /= 2;\n    }\n    return prod;\n}\nint mod_inv(int q, int in_mod)\n{\n\n    return power(q, in_mod - 2, in_mod);\n}\n\n\nconst int MAXN = 1e5+100;\nint parent[MAXN];\nvoid build()\n{\n    for(int i=0;i<MAXN;i++)\n        parent[i] = i;\n}\n\nint find_set(int u)\n{\n    if( u== parent[u])\n        return u;\n    return parent[u] = find_set(parent[u]);\n}\nvoid merge(int u, int v)\n{\n    u= find_set(u);\n    v= find_set(v);\n    if(u!=v)\n    {\n        if(rand()%2)\n            swap(u,v);\n        parent[v] = u;\n    }\n\n}\n\nvoid solve()\n{\n    string s;\n    cin>>s;\n    int k;\n    cin>>k;\n    int n= s.size();\n    string c = s;\n    reverse(all(c));\n    k*=2;\n    vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(n+1, vector<int>(k+1)));\n\n    for(int i= 1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)\n        {\n            for(int _k= 0;_k<=k;_k++)\n            {\n                if(c[i-1] == s[j-1])\n                    dp[i][j][_k] = dp[i-1][j-1][_k] + 1;\n                else\n                {\n                    dp[i][j][_k] = max(dp[i-1][j][_k], dp[i][j-1][_k]);\n                    if(_k)\n                        dp[i][j][_k] = max(dp[i][j][_k], dp[i-1][j-1][_k-1] + 1);\n                }\n            }\n        }\n    }\n    int mx= 0;\n    for(int i= 0;i<=k;i++)\n        mx = max(mx, dp[n][n][i]);\n    cout<<mx<<endl;\n\n}\n\n\n\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cerr.tie(NULL);\n#ifndef ONLINE_JUDGE\n    if (fopen(\"INPUT.txt\", \"r\"))\n    {\n        freopen(\"INPUT.txt\", \"r\", stdin);\n        freopen(\"OUTPUT.txt\", \"w\", stdout);\n    }\n#endif\n    auto clk = clock();\n    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n    // -------------------------------------Code starts here---------------------------------------------------------------------\n\n    int t = 1;\n    // cin >> t;\n\n    for (int test = 1; test <= t; test++)\n    {\n        // cout<<\"Case #\"<<test<<\":\\n\";\n        //cout<<\"Trip #\"<<test<<\": \";\n        // cout<<endl;\n        solve();\n        // solveB();\n\n        // cout<<endl;\n    }\n\n    // -------------------------------------Code ends here------------------------------------------------------------------\n\n    clk = clock() - clk;\n    // cerr << fixed << setprecision(6) << \"Time: \" << ((long double)clk) / CLOCKS_PER_SEC << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n//#include<math.h>\n//#include<time.h>\n//#include<complex>\n#include<algorithm>\nusing namespace std;\n\nint n,K;\n#define maxn 311\nchar s[maxn];\nint f[maxn][maxn][maxn];\nint main()\n{\n\tscanf(\"%s\",s+1); n=strlen(s+1); scanf(\"%d\",&K);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=0;j<=K;j++)\n\t\t\tf[i][i][j]=1;\n\tfor (int len=1;len<n;len++)\n\t\tfor (int i=1;i<=n-len;i++)\n\t\t{\n\t\t\tint j=i+len;\n\t\t\tfor (int k=0;k<=K;k++)\n\t\t\t{\n\t\t\t\tf[i][j][k]=max(f[i][j][k-1],max(f[i][j-1][k],f[i+1][j][k]));\n\t\t\t\tif (s[i]==s[j]) f[i][j][k]=max(f[i][j][k],f[i+1][j-1][k]+2);\n\t\t\t\tif (s[i]!=s[j] && k) f[i][j][k]=max(f[i][j][k],f[i+1][j-1][k-1]+2);\n\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\",f[1][n][K]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <fstream>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n//ifstream cin(\"x.in\"); ofstream cout(\"x.out\");\n\nconst int nmax = 300 + 5;\n\nstring s;\nint d[nmax + 1][nmax + 1][nmax + 1];\n\nint main() {\n    int q;\n    cin >> s >> q;\n\n    int n = (int)s.size();\n    s = '#' + s;\n\n    int ans = 0;\n\n    for (int i = 1; i <= n; ++ i) {\n        for (int j = n; j > i; -- j) {\n            for (int k = 0; k <= q; ++ k) {\n                d[ i ][ j ][ k ] = max(d[i - 1][ j ][ k ], d[ i ][j + 1][ k ]);\n\n                if (k - 1 >= 0)\n                    d[ i ][ j ][ k ] = max(d[ i ][ j ][ k ], d[ i ][ j ][k - 1]);\n\n                if (s[ i ] == s[ j ])\n                    d[ i ][ j ][ k ] = max(d[ i ][ j ][ k ], d[i - 1][j + 1][ k ] + 2);\n                else if (k > 0)\n                    d[ i ][ j ][ k ] = max(d[ i ][ j ][ k ], d[i - 1][j + 1][k - 1] + 2);\n            }\n\n            ans = max(ans, d[ i ][i + 1][ q ]);\n            ans = max(ans, d[ i ][i + 2][ q ] + 1);\n        }\n    }\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\nusing namespace std;\n\n\ntypedef long long i64;\nconst int inf = (int)1.05e9;\n\nint solve(char* s, int l, int r, int k, int n, vector<int>& memo)\n{\n\tif(r - l <= 0) return 0;\n\tif(r - l == 1) return 1;\n\n\tint n1 = n + 1;\n\tint idx = k * n1 * n1 + l * n1 + r;\n\tint& val = memo[idx];\n\n\tif(val != -1)\n\t\treturn val;\n\tval = 0;\n\n\tif(s[l] == s[r - 1]) {\n\n\t\tval = solve(s, l + 1, r - 1, k, n, memo) + 2;\n\n\t} else {\n\n\t\tif(k > 0) {\n\t\t\tval = solve(s, l + 1, r - 1, k - 1, n, memo) + 2;\n\t\t}\n\n\t\tint t1 = solve(s, l, r - 1, k, n, memo);\n\t\tint t2 = solve(s, l + 1, r, k, n, memo);\n\t\tval = max(val, max(t1, t2));\n\t}\n\n\treturn val;\n}\n\nint main()\n{\n\tchar s[512];\n\tint k;\n\n\tscanf(\"%s%d\", s, &k);\n\n\tint n = strlen(s);\n\tvector<int> memo;\n\tmemo.resize((n + 1) * (n + 1) * (n + 1), -1);\n\n\tint ans = solve(s, 0, n, k, n, memo);\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n\n/* waffle */\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstring s;\n\nconst int N = 301;\n\nint dp[N][N][N];\nint n;\n\nint f(int n1, int n2, int k) {\n    if (dp[n1][n2][k] != -1) {\n        return dp[n1][n2][k];\n    }\n    if (!n1 || !n2) {\n        return dp[n1][n2][k] = 0;\n    }\n    if (s[n1 - 1] == s[n - n2]) {\n        return dp[n1][n2][k] = f(n1 - 1, n2 - 1, k) + 1;\n    }\n    dp[n1][n2][k] = 0;\n    if (k && min(n1, n2) > n / 2 + 1) {\n        dp[n1][n2][k] = f(n1 - 1, n2 - 1, k - 1) + 2 - (s[n1 - 1] == s[n - n1]);\n    }\n    dp[n1][n2][k] = max(dp[n1][n2][k], f(n1 - 1, n2, k));\n    dp[n1][n2][k] = max(dp[n1][n2][k], f(n1, n2 - 1, k));\n    return dp[n1][n2][k];\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int k;\n    cin >> s >> k;\n    n = s.length();\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            for (int l = 0; l < N; ++l) {\n                dp[i][j][l] = -1;\n            }\n        }\n    }\n    cout << f(n, n, k);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#include<bitset>\n#include<random>\n#include<time.h>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<m; i++)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nll dp[300][300][301];\nstring s;\n\nll memo(ll l, ll r, ll k) {\n\tif(dp[l][r][k]!=INF*INF) return dp[l][r][k];\n\tif(l==r) return dp[l][r][k]=1;\n\tif(l==r-1) {\n\t\tif(k>=1) return dp[l][r][k]=2;\n\t\telse if(s[l]==s[r]) return dp[l][r][k]=2;\n\t\telse return dp[l][r][k]=1;\n\t}\n\tll ret=0;\n\tif(k>0) ret=memo(l+1,r-1,k-1)+2;\n\tif(s[l]==s[r]) ret=max(ret,memo(l+1,r-1,k)+2);\n\tret=max(ret,max(memo(l+1,r,k),memo(l,r-1,k)));\n\treturn dp[l][r][k]=ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll k;\n\tcin>>s>>k;\n\tll n=(ll)s.size();\n\tREP(i,300) REP(j,300) REP(k,301) dp[i][j][k]=INF*INF;\n\tcout<<memo(0,n-1,k)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nstatic const int IINF = 1 << 30;\n\ntemplate <typename T> std::vector<T> vectors(std::size_t n, T val) {\n  return std::vector<T>(n, val);\n}\n\ntemplate <typename T, typename... Args>\nauto vectors(std::size_t n, Args... args) {\n  return std::vector<decltype(vectors<T>(args...))>(n, vectors<T>(args...));\n}\n\ntemplate <class T> inline bool chmax(T &a, const T &b) {\n  return (a < b) ? a = b, true : false;\n}\n\nint main() {\n  // Input\n  std::string S;\n  int K;\n  int N;\n  std::cin >> S;\n  std::cin >> K;\n  N = S.length();\n\n  // Initialization\n  auto dp = vectors<int>(1 + N + 1, 1 + N + 1, 1 + K + 1, -IINF);\n\n  // Initial condition\n  dp[0][0][0] = 0;\n\n  // DP main\n  for (int i = 0; i <= N; ++i) {\n    for (int j = 0; j <= N; ++j) {\n      for (int k = 0; k <= K; ++k) {\n        chmax(dp[i + 1][j][k], dp[i][j][k]);\n        chmax(dp[i][j + 1][k], dp[i][j][k]);\n        chmax(dp[i + 1][j][k + 1], dp[i][j][k] + 1);\n        chmax(dp[i][j + 1][k + 1], dp[i][j][k] + 1);\n        chmax(dp[i + 1][j + 1][k + 1], dp[i][j][k] + 1);\n        if (S[i] == S[N - j - 1])\n          chmax(dp[i + 1][j + 1][k], dp[i][j][k] + 1);\n      }\n    }\n  }\n\n  // Output\n  int res = -1;\n  for (int i = 0; i <= N; ++i)\n    chmax(res, 2 * dp[i][N - i][K]);\n  for (int i = 0; i < N; ++i)\n    chmax(res, 2 * dp[i][N - i - 1][K] + 1);\n\n  std::cout << res << std::endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...)\n#endif\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    string s;\n    int k;\n    cin >> s >> k;\n    int n = s.size();\n    int dp[n][n][k] = {};\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i; j <= n - 1; j++) {\n            for (int l = 0; l <= k; l++) {\n                if (i == j) {\n                    dp[i][j][l] = 1;\n                } else if (i + 1 == j) {\n                    dp[i][j][l] = 2;\n                    if (l == 0 && s[i] != s[j]) {\n                        dp[i][j][l] = 1;\n                    }\n                } else {\n                    dp[i][j][l] = max(dp[i + 1][j][l], dp[i][j - 1][l]);\n                    // dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l] + 1);\n                    if (s[i] == s[j]) {\n                        dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l] + 2);\n                    }\n                    if (l != 0) {\n                        dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l - 1] + 2);\n                    }\n                }\n            }\n        }\n    }\n    cout << dp[0][n - 1][k] << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[305][305][305];\n\nint main(){\n  \n  string s;\n  int K;\n  \n  cin>>s>>K;\n  \n  memset(dp,-1,sizeof(dp));\n  \n  dp[0][s.size()-1][0]=0;\n  \n  if(s.size()==1) cout<<1<<endl;\n  \n  int ans=0;\n  \n  for(int l=0;l<s.size();l++)\n    \n    for(int r=s.size()-1;r>=l;r--){\n\n      for(int k=0;k<=K;k++){\n\t\n\tif(dp[l][r][k]==-1) continue;\n\n\tif(s[l]==s[r]) dp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]+2);\n\t\n\tif(l==r) continue;\n\t\n\tdp[l+1][r-1][k+1]=max(dp[l+1][r-1][k+1], dp[l][r][k]+2);\n\t\n\tdp[l+1][r][k]=max(dp[l+1][r][k], dp[l][r][k]);\n\tdp[l][r-1][k]=max(dp[l][r-1][k], dp[l][r][k]);\n\tdp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]);\n      }\n    }\n  \n  for(int i=0;i<s.size();i++)\n    \n    for(int j=0;j<=K;j++) ans=max(ans, dp[i][i][j]+1);\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstring s;int n;\nint dp[301][301][301];\nint f(int a,int b,int c){\n\tif(dp[a][b][c]!=-inf)return dp[a][b][c];\n\tif(b<=a)return 0;\n\tif(a+1==b)return 1;\n\tint out=0;\n\tif(s[a]==s[b-1]){\n\t\tout=max(out,2+f(a+1,b-1,c));\n\t}else if(c+1<=n){\n\t\tout=max(out,2+f(a+1,b-1,c+1));\n\t}\n\tout=max(out,f(a+1,b,c));\n\tout=max(out,f(a,b-1,c));\n//\tcout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<out<<endl;\n\treturn dp[a][b][c]=out;\n}\nint main(){\n\tcin>>s;\n\tcin>>n;\n\trep(i,301)rep(j,301)rep(k,301)dp[i][j][k]=-inf;\n\tcout<<f(0,s.size(),0)<<endl;\n//\tcout<<min((int)s.size(),LCS(s,t)+2*m)<<endl;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint dp[301][300][300];\nint INF = 1e6;\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    //freopen(\"1.txt\", \"r\", stdin);\n    string s;\n    cin >> s;\n    int k;\n    cin >> k;\n    int n = s.size();\n\tfor (int i=0; i < n; i++){\n\t\tfor (int j=0; j < n; j++){\n\t\t\tfor (int p=0; p <= n; p++) dp[p][j][i] = INF;\n\t\t\tdp[1][j][i] = 0;\n\t\t}\n\t}\n\tfor (int it=2; it <= n; it++){\n\t\tfor (int i=0; i < n; i++){\n\t\t\tfor (int j=i+1; j < n; j++){\n\t\t\t\tint cost=0;\n\t\t\t\tif (s[i] != s[j]) cost=1;\n\t\t\t\tint I = i+1;\n\t\t\t\tint J = j - 1;\n\t\t\t\tif (I > J){\n\t\t\t\t\tif (it==2) dp[it][i][j] = cost;\n\t\t\t\t}\n\t\t\t\telse dp[it][i][j] = dp[it-2][I][J] + cost;\n\t\t\t}\n\t\t}\n\t\tfor (int i=0; i < n; i++){\n\t\t\tfor (int j=i+1; j < n; j++) dp[it][i][j] = min(dp[it][i][j], dp[it][i][j-1]);\n\t\t}\n\t\tfor (int i=0; i < n; i++){\n\t\t\tfor (int j=i-1; j >= 0; j--){\n\t\t\t\tdp[it][i][j] = min(dp[it][i][j], dp[it][i][j+1]);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i=1; i <= n; i++){\n\t\tfor (int j=0; j < n; j++){\n\t\t\tfor (int p=0; p < n; p++){\n\t\t\t\tif (dp[i][j][p] <= k){\n\t\t\t\t\tans = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define il inline\n#define outy printf(\"Yes\\n\")\n#define outn printf(\"No\\n\")\n#define outf printf(\"First\\n\")\n#define outs printf(\"Second\\n\")\n#define FOR(a,b,c) for(int a=b;a<=c;a++)\n#define FORD(a,b,c) for(int a=b;a>=c;a--)\n#define FORL(a,b) for(int a=head[b];a;a=nxt[a])\n#define in(a)  a=read()\n#define in2(a,b)  a=read(),b=read()\n#define in3(a,b,c)  a=read(),b=read(),c=read()\n#define in4(a,b,c,d)  a=read(),b=read(),c=read(),d=read()\n#define inl(a)  a=readl()\n#define inl2(a,b)  a=readl(),b=readl()\n#define inl3(a,b,c)  a=readl(),b=readl(),c=readl()\n#define inl4(a,b,c,d)  a=readl(),b=readl(),c=readl(),d=readl()\n#define out(a) printf(\"%d\\n\",a)\n#define out2(a,b) printf(\"%d %d\\n\",a,b)\n#define out3(a,b,c) printf(\"%d %d %d\\n\",a,b,c)\n#define out4(a,b,c,d) printf(\"%d %d %d %d\\n\",a,b,c,d)\n#define outl(a) printf(\"%lld\\n\",a)\n#define outl2(a,b) printf(\"%lld %lld\\n\",a,b)\n#define outl3(a,b,c) printf(\"%lld %lld %lld\\n\",a,b,c)\n#define outl4(a,b,c,d) printf(\"%lld %lld %lld %lld\\n\",a,b,c,d)\n#define clr(x,y) memset(x,y,sizeof(x))\ninline int read(){\n    char c;int s=0,t=1;\n    while(!isdigit(c=getchar()))if(c=='-')t=-1;\n    do{s=s*10+c-'0';}while(isdigit(c=getchar()));\n    return s*t;\n}\ninline ll readl(){\n    char c;ll s=0;int t=1;\n    while(!isdigit(c=getchar()))if(c=='-')t=-1;\n    do{s=s*10+c-'0';}while(isdigit(c=getchar()));\n    return s*t;\n}\n/*------------------------------------------------------------*/\n#define mod 1000000007\n#define maxn 100010\n#define inf 0x7fffffff\n/*------------------------------------------------------------*/\nint n,m;\nint f[310][310][310];\nint main(){\n\tstring s;\n\tcin>>s;\n\tin(n);\n\tint l=s.length();\n\tFOR(i,0,l-1)f[i][i][0]=1;\n\tFOR(k,1,l)\n\t\tFOR(i,0,l-1){\n\t\t\tint j=i+k;\n\t\t\tif(j>=l)break;\n\t\t\tFOR(p,0,n){\n\t\t\t\tf[i][j][p]=max(f[i+1][j][p],f[i][j-1][p]);\n\t\t\t\tif(s[i]==s[j])f[i][j][p]=max(f[i][j][p],f[i+1][j-1][p]+2);\n\t\t\t\t else if(p)f[i][j][p]=max(f[i][j][p],f[i+1][j-1][p-1]+2);\n\t\t\t}\n\t\t}\n\tint ans=0;\n\tFOR(i,0,n)ans=max(ans,f[0][l-1][i]);\n\tout(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define llint long long \n#define inf 1000000000000000000\n\nusing namespace std;\n\nstring s;\nllint N, K;\nllint dp[305][305][305];\n\nint main(void)\n{\ncin >> s >> K;\nN = s.size();\ns = \" \" + s;\n\nfor(llint i = 0; i <= N; i++){\nfor(llint j = 0; j <= N; j++){\nfor(llint k = 0; k <= K; k++){\ndp[i][j][k] = -inf;\n}\n}\n}\nfor(llint i = 0; i <= N; i++) dp[i][0][0] = dp[0][i][0] = 0;\n\n\nfor(llint i = 1; i <= N; i++){\nfor(llint j = 1; j <= N; j++){\nfor(llint k = 0; k <= K; k++){\n\nif(i+j > N+1){\n\tcontinue;\n}\n\nif(s[i] == s[N-j+1]){\ndp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k] + 1);\n}\nelse{\ndp[i][j][k] = max(dp[i][j][k], max(dp[i-1][j][k], dp[i][j-1][k]));\nif(k > 0){\n\tdp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k-1] + 1);\n}\n\n\n}\n}\n}\n\n/*for(llint k = 0; k <= K; k++){\nfor(llint i = 0; i <= N; i++){\nfor(llint j = 0; j <= N; j++){\ncout << dp[i][j][k] << \" \";\n}cout << endl;\n}cout << endl;\n}*/\n\nllint ans = 0;\nfor(llint k = 0; k <= K; k++){\nfor(llint i = 0; i <= N; i++){\nfor(llint j = 0; j <= N; j++){\nif(i+j != N+1) continue;\nllint tmp = dp[i][j][k] * 2;\nif(s[i] == s[N-j+1]) tmp--;\nans = max(ans, tmp);\n}\n}\n}\n\ncout << ans << endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long li;\n\nli dp[301][301][301];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    string s;\n    cin >> s;\n    \n    li k;\n    cin >> k;\n    \n    const li n = s.size();\n    for (int len = 0; len <= n; ++len) {\n        for (int l = 0; l <= n; ++l) {\n            const int r = l + len;\n            if (r > n) {\n                continue;\n            }\n            for (int kk = 0; kk <= k; ++kk) {\n                if (kk > 0) {\n                    dp[l][r][kk] = max(dp[l][r][kk], dp[l][r][kk - 1]);\n                }\n                if (len > 0) {\n                    dp[l][r][kk] = max(dp[l][r][kk], dp[l + 1][r][kk]);\n                    dp[l][r][kk] = max(dp[l][r][kk], dp[l][r - 1][kk]);\n                }\n                if (len == 1) {\n                    dp[l][r][kk] = max(dp[l][r][kk], 1LL);\n                }\n                if (len >= 2) {\n                    if (kk > 0) {\n                        dp[l][r][kk] = max(dp[l][r][kk], dp[l + 1][r - 1][kk - 1] + 2);\n                    }\n                    if (s[l] == s[r - 1]) {\n                        dp[l][r][kk] = max(dp[l][r][kk], dp[l + 1][r - 1][kk] + 2);\n                    }\n                }\n            }\n        }\n    }    \n    \n    cout << dp[0][n][k] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <set>\n\n#define lowbit(x) (x&(-x))\n#define MAX(a,b) (a<b?b:a)\n#define MIN(a,b) (a<b?a:b)\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int N = 1e7;\nconst int maxn = 3e2 + 5;\nll mod = 1e9 + 7;\n\nchar s[maxn];\nint k;\n\nint f[maxn][maxn][maxn];\n\nint main()\n{\n\tscanf(\"%s%d\", s, &k);\n\tint n = strlen(s);\n\tfor (int i = 0; i < n; i++) f[i][i][0] = 1;\n\n\tfor(int len = 2;len<=n;++len)\n\t{\n\t\tfor(int l = 0;l<n;l++)\n\t\t{\n\t\t\tint r = l + len - 1;\n\t\t\tif (r >= n) break;\n\t\t\tfor (int x = 0; x <= k; x++)\n\t\t\t{\n\t\t\t\tf[l][r][x] = MAX(f[l + 1][r][x], f[l][r - 1][x]);\n\t\t\t\tif (s[l] == s[r]) f[l][r][x] = MAX(f[l][r][x], f[l + 1][r - 1][x] + 2);\n\t\t\t\tif (x)\n\t\t\t\t{\n\t\t\t\t\tf[l][r][x] = MAX(f[l][r][x], f[l][r][x - 1]);\n\t\t\t\t\tf[l][r][x] = MAX(f[l][r][x], f[l + 1][r - 1][x - 1] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%d\", f[0][n - 1][k]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint f[320][320][320];\nchar c[320];\nint i,j,k,m,n;\n\nint main()\n{\n\tscanf(\"%s\",c+1);\n\tn=strlen(c+1);\n\tscanf(\"%d\",&m);\n\tfor (i=n;i>0;i--)\n\t\tfor (j=i;j<=n;j++)\n\t\t\tfor (k=0;k<=m;k++)\n\t\t\t{\n\t\t\t\tf[i][j][k]=max(f[i][j][k],f[i+1][j][k]);\n\t\t\t\tf[i][j][k]=max(f[i][j][k],f[i][j-1][k]);\n\t\t\t\tif (c[i]==c[j])\n\t\t\t\t\tf[i][j][k]=max(f[i][j][k],f[i+1][j-1][k]+1+(i!=j));\n\t\t\t\tif (k>0)\n\t\t\t\t\tf[i][j][k]=max(f[i][j][k],f[i+1][j-1][k-1]+1+(i!=j));\n\t\t\t}\n\tprintf(\"%d\",f[1][n][m]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\ntypedef long double ld;\ntypedef long long ll;\n\nconst int M = 303;\n\nint n;\nstring s;\nint k;\nint d[M][M][M];\n\nvoid read() {\n  cin >> s >> k;\n  n = s.length();\n}\n\nvoid uax(int &x, int y) {\n  x = max(x, y);\n}\n\nvoid kill() {\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < n; ++j)\n      for (int t = 0; t <= k; ++t) {\n        int cur = d[i][j][t];\n        if (s[i] == s[n - 1 - j])\n          uax(d[i + 1][j + 1][t], cur + 1);\n        else\n          uax(d[i + 1][j + 1][t + 1], cur + 1);\n        uax(d[i + 1][j][t], cur);\n        uax(d[i][j + 1][t], cur);\n      }\n\n  int ans = 0;\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; i + j < n; ++j)\n      for (int t = 0; t <= k; ++t)\n        uax(ans, 2 * d[i][j][t] + 1);\n\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; i + j <= n; ++j)\n      for (int t = 0; t <= k; ++t)\n        uax(ans, 2 * d[i][j][t]);\n\n  cout << ans << endl;\n}\n\nint main() {\n#ifdef LOCAL\n  assert(freopen(\"d.in\", \"r\", stdin));\n#endif\n\n  ios_base::sync_with_stdio(false);\n\n  read();\n  kill();\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    string s; cin >> s;\n    int k; cin >> k;\n    int n = s.size();\n    vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(k + 1, -1)));\n\n    constexpr int kInf = 1'000'000'000;\n\n    function<int(int, int, int)> Dfs = [&](int l, int r, int c) {\n        if (dp[l][r][c] >= 0) return dp[l][r][c];\n        if (l == r) return 1;\n        if (l == r - 1) {\n            if (s[l] == s[r]) return 2;\n            if (s[l] != s[r] && c > 0) return 2;\n            return 1;\n        }\n        if (s[l] == s[r]) return dp[l][r][c] = Dfs(l + 1, r - 1, c) + 2;\n        dp[l][r][c] = max(Dfs(l + 1, r, c), Dfs(l, r - 1, c));\n        if (c > 0) dp[l][r][c] = max(dp[l][r][c], Dfs(l + 1, r - 1, c - 1) + 2);\n        return dp[l][r][c];\n    };\n\n    int ans = 0;\n    for (int i = 0; i <= k; ++i) ans = max(ans, Dfs(0, n - 1, i));\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst int MC = 305;\nstring S;\nint K;\nint dp[MC][MC][MC];\n\nint main(){\n\tcin >> S;\n\tint n = S.size();\n\tint m = n/2;\n\tcin >> K;\n\trepp(i,0,n) repm(j,n-1,i) repp(k,0,K+1){\n\t\tif(S[i] == S[j]){\n\t\t\tdp[i+1][j-1][k] = max(dp[i+1][j-1][k] , dp[i][j][k]+1);\n\t\t} else {\n\t\t\tdp[i+1][j][k] = max(dp[i+1][j][k] , dp[i][j][k]);\n\t\t\tdp[i][j-1][k] = max(dp[i][j-1][k] , dp[i][j][k]);\n\t\t\tif(k < K){\n\t\t\t\tdp[i+1][j-1][k+1] = max(dp[i+1][j-1][k+1] , dp[i][j][k]+1);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trepp(i,0,n) repp(k,0,K+1){\n\t\tans = max(ans , dp[i][i][k]*2 + 1);\n\t\tans = max(ans , dp[i+1][i][k]*2);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma comment(linker, \"/STACK:108777216\")\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <functional>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <deque>\n#include <utility>\n#include <algorithm>\n#include <ctime>\nusing namespace std;\n\nint const MAX_N = 128 * 3;\n\nint exist[MAX_N], lst[MAX_N], ms[MAX_N];\nint n;\nint dp[2][MAX_N];\n\nint calc(const string & st) {\n\tint from = 0;\n\tfill(dp[from], dp[from] + n+1, 0);\n\tfor (int i=1; i<=n; i++) {\n\t\tint to = 1-from;\n\t\tmemcpy(dp[to], dp[from], (n+1)*sizeof(int));\n\t\tfor (int j=1; j<=n; j++) {\n\t\t\tdp[to][j] = max(dp[to][j], dp[to][j-1]);\n\t\t\tif (st[i-1] == st[n-j])\n\t\t\t\tdp[to][j] = max(dp[to][j], dp[from][j-1] + 1);\n\t\t}\n\t\tswap(from, to);\n\t}\n\n\treturn dp[from][n];\n}\n\nint main() {\n\t//freopen(\"input.txt\",\"r\",stdin);\n\t//freopen(\"output.txt\",\"w\",stdout);\n\n\tstring st;\n\tcin>>st;\n\tint k;\n\tcin>>k;\n\n\tn = (int) st.length();\n\n\tfor (int i=0; i<(int) st.length(); i++)\n\t\texist[st[i]-'a']++;\n\n\tint lst_len = 0;\n\tfor (int i=0; i<26; i++)\n\t\tif (exist[i]) lst[lst_len++] = 'a' + i;\n\n\tint i = 0, j = n-1;\n\tint ms_len = 0;\n\twhile (i <= j) {\n\t\tms[ms_len++] = i;\n\t\tif (i!=j) ms[ms_len++] = j;\n\t\ti++; j--;\n\t}\n\n\tint last_fnd = -1;\n\tint iter = 0;\n\twhile (k-->0) {\n\t\titer++;\n\t\tif (iter > n/2+1)\n\t\t\tbreak;\n\t\tint ans_i = -1, ans_iind = -1, mx = -1;\n\t\tchar ans_ch = 0;\n\t\tfor (int iind=last_fnd+1; iind<n; iind++) {\n\t\t\tint i = ms[iind];\n\t\t\tfor (int ch_ind = 0; ch_ind < lst_len; ch_ind++) {\n\t\t\t\tstring q = st;\n\t\t\t\tq[i] = lst[ch_ind];\n\t\t\t\tint loc_ans = calc(q);\n\t\t\t\tif (loc_ans > mx) {\n\t\t\t\t\tmx = loc_ans;\n\t\t\t\t\tans_i = i;\n\t\t\t\t\tans_iind = iind;\n\t\t\t\t\tans_ch = lst[ch_ind];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tst[ans_i] = ans_ch;\n\t\tlast_fnd = ans_iind;\n\t\tif (mx >= n)\n\t\t\tbreak;\n\t}\n\tcout<<calc(st);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nint dp[310][310][310];\nint d2[310][310][310];\nstring s;\nint cal(int x,int y,int z){\n\tif(d2[x][y][z]>=0) return d2[x][y][z];\n\tif(x==y) return d2[x][y][z]=1;\n\tif(x>y) return d2[x][y][z]=0;\n\tint ret=0;\n\tif(s[x]==s[y]) ret=max(ret,cal(x+1,y-1,z)+2);\n\tif(z>0) ret=max(ret,cal(x+1,y-1,z-1)+2);\n\tret=max(ret,cal(x+1,y,z));ret=max(ret,cal(x,y-1,z));\n\treturn d2[x][y][z]=ret;\n}\nint main()\n{\n\tint K,n,out;\n\tcin>>s;n=s.size();cin>>K;\n\tmemset(dp,0,sizeof(dp));\n\trep(i,n+1) rep(j,n+1) rep(k,K+1){\n\t\t//cout<<i<<' '<<j<<' '<<k<<' '<<dp[i][j][k]<<endl;\n\t\tif(i<n/2) dp[i+1][j][k]=max(dp[i+1][j][k],dp[i][j][k]);\n\t\tif(j<n/2) dp[i][j+1][k]=max(dp[i][j+1][k],dp[i][j][k]);\n\t\tif(i<n/2 && j<n/2){\n\t\t\tif(s[i]==s[n-1-j]) dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+1);\n\t\t\telse dp[i+1][j+1][k+1]=max(dp[i+1][j+1][k+1],dp[i][j][k]+1);\n\t\t}\n\t}\n\t\n\tmemset(d2,-1,sizeof(d2));\n\t//cal(0,n-1);\n\t\n\t//cout<<dp[6][9][3]<<' '<<cal(6,9)<<endl;\n\trep(i,n+1) rep(j,n+1) rep(k,K+1){\n\t\tif(i+j>n) continue;\n\t\tout=max(out,dp[i][j][k]*2+cal(i,n-j-1,K-k));\n\t}\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// khodaya khodet komak kon\n#include <bits/stdc++.h>\n#define pb push_back\n#define ers erase\n#define ins insert\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x)  cerr << #x << \" = \" << x << endl\n#define kill(x) return cout << x, 0;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#pragma GCC optimize (\"Ofast\")\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vl;\ntypedef vector<pll> vpl;\n\nconst ld Pi = 3.14159265359;\nconst ll MOD = 1000 * 1000 * 1000 + 7;\nconst ll N = 2e5 + 10;\nconst ll INF = 1e18;\nstr s;\nll K, n, dp[310][310][310];\n\nint main(){\n\tIOS;\n\tcin >> s;\n\tcin >> K;\n\tll n = s.size();\n\ts = \".\" + s;\n\t//cout << n << '\\n';\n\tfor (int i = 1; i <= n; i++){\n\t\tdp[i][i + 1][0] = 1;\n\t}\n\tfor (int i = 2; i <= n; i++){\n\t\tfor (int j = 1; j <= n - i + 1; j++){\n\t\t\tfor (int k = 0; k <= K; k++){\n\t\t\t\tif (k == 0){\n\t\t\t\t\tif (s[j] == s[j + i - 1]){\n\t\t\t\t\t\tdp[j][i + j][0] = dp[j + 1][i + j - 1][0] + 2;\n\t\t\t\t\t}\n\t\t\t\t\tdp[j][i + j][k] = max(dp[j][i + j][k], max(dp[j + 1][i + j][k], dp[j][i + j - 1][k]));\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\telse if (k >= i - 1){\n\t\t\t\t\tdp[j][i + j][k] = i;\n\t\t\t\t}else{\n\t\t\t\t\tdp[j][i + j][k] = dp[j][i + j][k - 1];\n\t\t\t\t\tif (s[j] == s[i + j - 1]){\n\t\t\t\t\t\tdp[j][i + j][k] = dp[j + 1][i + j - 1][k] + 2;\n\t\t\t\t\t}\n\t\t\t\t\tdp[j][i + j][k] = max(dp[j][i + j][k], max(dp[j + 1][i + j][k], dp[j][i + j - 1][k]));\n\t\t\t\t\tdp[j][i + j][k] = max(dp[j][i + j][k], 2 + dp[j + 1][i + j - 1][k - 1]);\n\t\t\t\t}\n\t\t\t\t//cout << j << ' ' << j + i - 1 << ' ' << k << ' ' << dp[j][j + i][k] << '\\n';\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t}\n\tcout << dp[1][n + 1][K];\n\t\n\t\n\t\n\treturn 0;\n}\n\n\n\n\n\n\n/*\n     ,---,           ___                 ,--,\n    '  .' \\        ,--.'|_             ,--.'|                             ,--,\n   /  ;    '.      |  | :,'            |  | :                           ,--.'|    ,---.        ,---,\n  :  :       \\     :  : ' :            :  : '                 .--.--.   |  |,    '   ,'\\   ,-+-. /  |\n  :  |   /\\   \\  .;__,'  /    ,--.--.  |  ' |     ,--.--.    /  /    '  `--'_   /   /   | ,--.'|'   |\n  |  :  ' ;.   : |  |   |    /       \\ '  | |    /       \\  |  :  /`./  ,' ,'| .   ; ,. :|   |  ,\"' |\n  |  |  ;/  \\   \\:__,'| :   .--.  .-. ||  | :   .--.  .-. | |  :  ;_    '  | | '   | |: :|   | /  | |\n  '  :  | \\  \\ ,'  '  : |__  \\__\\/: . .'  : |__  \\__\\/: . .  \\  \\    `. |  | : '   | .; :|   | |  | |\n  |  |  '  '--'    |  | '.'| ,\" .--.; ||  | '.'| ,\" .--.; |   `----.   \\'  : |_|   :    ||   | |  |/\n  |  :  :          ;  :    ;/  /  ,.  |;  :    ;/  /  ,.  |  /  /`--'  /|  | '.'\\   \\  / |   | |--'\n  |  | ,'          |  ,   /;  :   .'   \\  ,   /;  :   .'   \\'--'.     / ;  :    ;`----'  |   |/\n  `--''             ---`-' |  ,     .-./---`-' |  ,     .-./  `--'---'  |  ,   /         '---'\n                            `--`---'            `--`---'                 ---`-'\n*/\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for(int i = x; i < (int)(n); ++i)\n \nchar s[302];\nint dp[302][302][301];\n \nint main(){\n\tint k;\n\tscanf(\"%s%d\", s + 1, &k);\n\tint n = strlen(s + 1);\n\tf(i, 1, n + 1)for (int j = n; j > 0; --j)f(w, 0, k + 1){\n\t\tif (s[i] == s[j])dp[i][j][w] = 1 + dp[i - 1][j + 1][w];\n\t\telse {\n\t\t\tdp[i][j][w] = max(dp[i - 1][j][w], dp[i][j + 1][w]);\n\t\t\tif (w)dp[i][j][w] = max(dp[i][j][w], 1 + dp[i - 1][j + 1][w - 1]);\n\t\t}\n\t}\n\tint an = 1;\n\tf(i, 1, n){\n\t\tint nv = dp[i][i + 1][k];\n\t\tan = max(an, nv << 1);\n\t}\n\tf(i, 1, n - 1){\n\t\tint nv = dp[i][i + 2][k];\n\t\tan = max(an, nv << 1 | 1);\n\t}\n\tprintf(\"%d\\n\", an);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 305;\n\nchar str[MAXN];\nint n, k;\nint dp[MAXN][MAXN][MAXN];\n\nint dfs(int L, int R, int k)\n{\n\tif (k < 0) return -1e8;\n\tif (L > R) return 0;\n\tif (L == R) return 1;\n\tif (dp[L][R][k] != -1) return dp[L][R][k];\n\tdp[L][R][k] = max(dfs(L+1, R, k), dfs(L, R-1, k));\n\tdp[L][R][k] = max(dp[L][R][k], dfs(L+1, R-1, k-(str[L] != str[R]))+2);\n\treturn dp[L][R][k];\n}\n\nint main()\n{\n\tmemset(dp, -1, sizeof dp);\n\tscanf(\"%s\", str+1), n = strlen(str+1);\n\tscanf(\"%d\", &k);\n\tcout << dfs(1, n, k) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include <atcoder/all>\nusing namespace std;\n// using namespace atcoder;\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  os << \"(\" << p.first << \",\" << p.second << \")\";\n  return os;\n}\n#ifdef __LOCAL\n#define debug(x) cerr << __LINE__ << \": \" << #x << \" = \" << (x) << '\\n'\n#define debugArray(x, n)                                      \\\n  cerr << __LINE__ << \": \" << #x << \" = {\";                   \\\n  for (long long hoge = 0; (hoge) < (long long)(n); ++(hoge)) \\\n    cerr << ((hoge) ? \",\" : \"\") << x[hoge];                   \\\n  cerr << \"}\" << '\\n'\n#define debugMatrix(x, h, w)                                         \\\n  cerr << __LINE__ << \": \" << #x << \" =\\n\";                          \\\n  for (long long hoge = 0; (hoge) < (long long)(h); ++(hoge)) {      \\\n    cerr << ((hoge ? \" {\" : \"{{\"));                                  \\\n    for (long long fuga = 0; (fuga) < (long long)(w); ++(fuga))      \\\n      cerr << ((fuga ? \", \" : \"\")) << x[hoge][fuga];                 \\\n    cerr << \"}\" << (hoge + 1 == (long long)(h) ? \"}\" : \",\") << '\\n'; \\\n  }\n#else\n#define debug(x) (void(0))\n#define debugArray(x, n) (void(0))\n#define debugMatrix(x, h, w) (void(0))\n#endif\n\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  string S;\n  cin >> S;\n  int K;\n  cin >> K;\n  int N = S.length();\n  debug(N);\n  int M = N / 2;\n  debug(M);\n  int dp[M + 1][M + 1][K + 1];\n  for (int i = 0; i <= M; i++)\n    for (int k = 0; k <= K; k++) dp[i][0][k] = dp[0][i][k] = 0;\n  for (int i = 1; i <= M; i++)\n    for (int j = 1; j <= M; j++)\n      for (int k = 0; k <= K; k++) {\n        if (S[i - 1] == S[N - j])\n          dp[i][j][k] = dp[i - 1][j - 1][k] + 1;\n        else {\n          dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k]);\n          if (k > 0)\n            dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k - 1] + 1);\n        }\n      }\n  int ans = 0;\n  debugArray(dp[M][M], K + 1);\n  for (int i = 0; i <= M; i++) {\n    int tmp = 0;\n    for (int k = 0; k <= K; k++) tmp = max(tmp, dp[i][i][k]);\n    ans = max(ans, tmp * 2 + N - 2 * i);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int maxn = 333;\nstring u, v;\nint dp[maxn][maxn][maxn];\nint solve(int l, int r, int k){\n    if(l > r) return 0;\n    if(l == r) return 1;\n    if(dp[l][r][k] != -1) return dp[l][r][k];\n    int ans = 0;\n    if(u[l] == u[r]) ans = max(ans, 2 + solve(l + 1, r - 1, k));\n    ans = max(ans, solve(l+1, r, k));\n    ans = max(ans, solve(l, r-1, k));\n    if(k) ans = max(ans, 2 + solve(l + 1, r - 1, k - 1));\n    return dp[l][r][k] = ans;\n}\nint main(){\n    string c;\n    cin >> c;\n    int k;\n    cin >> k;\n    u = c;\n    memset(dp, -1, sizeof(dp));\n    cout << solve(0, c.size() - 1, k) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nchar a[1000];\nchar b[1000];\nint dp[301][301];\nint main()\n{\n    int n = 0, m, ans = 0;\n    cin >> a + 1;\n    cin >> m;\n    for(int i = 1; a[i] != 0; i ++)\n        n = i;\n    for(int i = 1; i <= n; i ++)\n        b[i] = a[n - i + 1];\n    for(int i = 1; i <= n; i ++)\n        for(int j = 1; j <= n; j ++)\n        {\n            if(a[i] == b[j])\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            else\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n            ans = max(ans, dp[i][j]);\n        }\n    if(ans + m * 2 > n)\n        cout << n;\n    else\n        cout << ans + m * 2;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//header\n#ifdef LOCAL\n    #include \"cxx-prettyprint-master/prettyprint.hpp\"\n    #define debug(x) cout << x << endl\n#else\n    #define debug(...) 42\n#endif\n    #pragma GCC optimize(\"Ofast\")\n    #include <bits/stdc++.h>\n    //types\n    using namespace std;\n    using ll = long long;\n    typedef pair < ll , ll >Pl;\n    typedef pair < int, int >Pi;\n    typedef vector<ll> vl;\n    typedef vector<int> vi;\n    template< typename T >\n    using mat = vector< vector< T > >;\n    template <std::uint_fast64_t Modulus> class modint {\n\n        using u64 = std::uint_fast64_t;\n\n        public:\n        u64 a;\n\n        constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n        constexpr u64 &value() noexcept { return a; }\n        constexpr const u64 &value() const noexcept { return a; }\n        constexpr modint operator+(const modint rhs) const noexcept {\n            return modint(*this) += rhs;\n        }\n        constexpr modint operator-(const modint rhs) const noexcept {\n            return modint(*this) -= rhs;\n        }\n        constexpr modint operator*(const modint rhs) const noexcept {\n            return modint(*this) *= rhs;\n        }\n        constexpr modint operator/(const modint rhs) const noexcept {\n            return modint(*this) /= rhs;\n        }\n        constexpr modint &operator+=(const modint rhs) noexcept {\n            a += rhs.a;\n            if (a >= Modulus) {\n            a -= Modulus;\n            }\n            return *this;\n        }\n        constexpr modint &operator-=(const modint rhs) noexcept {\n            if (a < rhs.a) {\n            a += Modulus;\n            }\n            a -= rhs.a;\n            return *this;\n        }\n        constexpr modint &operator*=(const modint rhs) noexcept {\n            a = a * rhs.a % Modulus;\n            return *this;\n        }\n        constexpr modint &operator/=(modint rhs) noexcept {\n            u64 exp = Modulus - 2;\n            while (exp) {\n            if (exp % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            exp /= 2;\n            }\n            return *this;\n        }\n        };\n    \n    \n    \n    \n    \n    //abreviations\n    #define all(x) (x).begin(), (x).end()\n    #define rall(x) (x).rbegin(), (x).rend()\n    #define rep2(i,a,b) for(int i=(a);i<(b);++i)\n    #define rep(i,n) for(int i=0;i<(n);++i)\n    #define rev(i,n) for(int i=n-1;i>=0;i--)\n    #define SZ(x) ((ll)(x).size())\n    #define pb(x) push_back(x)\n    #define eb(x) emplace_back(x)\n    #define ff first\n    #define ss second\n    #define mp make_pair\n    #define print(x) cout << x << endl\n    //functions\n    ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\n    template<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\n    template<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n    template< typename T >\n    T mypow(T x, ll n) {\n        T ret = 1;\n        while(n > 0) {\n            if(n & 1) (ret *= x);\n            (x *= x);\n            n >>= 1;\n        }\n        return ret;\n    }\n    uint64_t my_rand(void) {\n        static uint64_t x = 88172645463325252ULL;\n        x = x ^ (x << 13); x = x ^ (x >> 7);\n        return x = x ^ (x << 17);\n    }\n    //graph template\n    template< typename T >\n    struct edge {\n        int src, to;\n        T cost;\n\n        edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n        edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n        edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n\n    operator int() const { return to; }\n    };\n\n    template< typename T >\n    using Edges = vector< edge< T > >;\n    template< typename T >\n    using WeightedGraph = vector< Edges< T > >;\n    using UnWeightedGraph = vector< vector< int > >;\n\n//constant\n#define INF 10000000000LL\n#define mod 1000000007LL\n//typedef modint<mod> mint;\n#define eps 0.000001\n//library\nint memo[305][305][305];\nstring s;\nint k;\nint n;\nint rec(int i, int j, int l){\n    if(l<0)return -1;\n    if(i<0||j<0)return 0;\n    if(memo[i][j][l])return memo[i][j][l];\n    int res = -1;\n    if(s[i] == s[n-1-j]){\n        chmax(res, rec(i-1, j-1, l)+1);\n    }\n    chmax(res, rec(i-1, j-1, l-1)+1);\n    chmax(res, rec(i-1, j, l));\n    chmax(res, rec(i, j-1, l));\n    memo[i][j][l] = res;\n    return res;\n}\n//main\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin>>s;\n    cin>>k;\n    n = SZ(s);\n    int ans = 0;\n    rep(i, n){\n        chmax(ans, rec(i, n-2-i, k)*2);\n    }\n    rep(i, n){\n        chmax(ans, rec(i-1, n-2-i, k)*2+1);\n    }\n    print(ans);\n    return 0;\n}    "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <stack>\n#include <vector>\n#define maxn 310\n#define maxe 100010\ntypedef long long ll;\nusing namespace std;\nconst double eps=1e-5;\nconst int inf=0x3f3f3f3f3f;\nchar a[maxn];\nint mc;\nint dp[maxn][maxn][maxn];\nint main()\n{\n    while(scanf(\"%s%d\",a,&mc)==2)\n    {\n        int n=strlen(a);\n        for(int i=0;i<n;i++)dp[i][i][0]=1;\n        for(int l=1;l<n;l++)\n        {\n            for(int i=0;i+l<n;i++)\n            {\n                int j=i+l;\n                for(int k=0;k<=mc;k++)\n                {\n                    if(k)dp[i][j][k]=dp[i][j][k-1]+1;\n                    int t=max(dp[i+1][j][k],dp[i][j-1][k]);\n                    dp[i][j][k]=max(t,dp[i][j][k]);\n                    if(a[i]==a[j])\n                        dp[i][j][k]=max(dp[i+1][j-1][k]+2,dp[i][j][k]);\n                }\n            }\n        }\n        printf(\"%d\\n\",dp[0][n-1][mc]+mc);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=305;\nint f[N][N][N],n,K;char s[N];\nint main(){\n  scanf(\"%s%d\",s+1,&K);n=strlen(s+1);\n  for(int i=1;i<=n;i++)\n\t  for(int k=0;k<=K;k++)f[i][i][k]=1;\n  for(int len=2;len<=n;len++){\n\t  for(int i=1;i+len-1<=n;i++){\n\t\t  int j=i+len-1;\n\t\t  for(int k=0;k<=K;k++){\n\t\t\t  f[i][j][k]=max(f[i+1][j][k],f[i][j-1][k]);\n\t\t\t  if(s[i]==s[j])f[i][j][k]=max(f[i][j][k],f[i+1][j-1][k]+2);\n\t\t\t  if(k)f[i][j][k]=max(f[i][j][k],f[i+1][j-1][k-1]+2);\n\t\t  }\n\t  }\n  }\n  cout<<f[1][n][K]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\ntypedef long long ll;\ninline void Fail(){printf(\"0\");exit(0);}\n\nconst int maxn=305;\nint n,lim,ans;\nchar c[maxn];\nstring s;\nint dp[maxn][maxn][maxn];\n\nint main(){\n\tscanf(\"%s%d\",c,&lim);\n\ts=c;n=s.size();\n\tif(n==1)ans=1;\n\trep(i,n/2)rep(j,n/2)rep(k,lim+1){\n\t\tif(s[i]==s[n-j-1])dp[i][j][k]=(i>=1&&j>=1?dp[i-1][j-1][k]:0)+1;\n\t\tif(i>=1)dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k]);\n\t\tif(j>=1)dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k]);\n\t\tif(s[i]!=s[n-j-1]){\n\t\t\tif(k>=1)dp[i][j][k]=max((i>=1&&j>=1?dp[i-1][j-1][k-1]:0)+1,dp[i][j][k]);\n\t\t}\n\t\tans=max(ans,dp[i][j][k]*2+(n&1));\n\t}\n\trep(i,n/2)for(int j=(n+1)/2;j<n;j++)rep(k,lim+1){\n\t\tif(s[i]==s[n-j-1])dp[i][j][k]=(i>=1&&j>(n+1)/2?dp[i-1][j-1][k]:0)+1;\n\t\tif(i>=1)dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k]);\n\t\tif(j>(n+1)/2)dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k]);\n\t\tif(s[i]!=s[n-j-1]){\n\t\t\tif(k>=1)dp[i][j][k]=max((i>=1&&j>(n+1)/2?dp[i-1][j-1][k-1]:0)+1,dp[i][j][k]);\n\t\t}\n//\t\tcout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<dp[i][j][k]<<endl;\n\t\tans=max(ans,dp[i][j][k]+(n-j-2>=0?dp[n-j-2][n/2-1][lim-k]:0)*2);\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n\n/*\nInput:\nabcabcabc\ncbacbacba\n1\natcodergrandcontest\ntsetnocdnargredocta\n3\n-----------------\nOutput:\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nchar s[301];\nint left[301][26];\nint right[301][26];\nint dp[301][301][301];\n\nint calc(int x, int y, int z) {\n    int ans = 0, i;\n    \n    if (dp[x][y][z] >= 0) return dp[x][y][z];\n    \n    if (x > y) return dp[x][y][z] = 0;\n    if (x == y) return dp[x][y][z] = 1;\n    \n    if (s[x] == s[y]) return dp[x][y][z] = calc(x + 1, y - 1, z) + 2;\n    \n    ans = calc(x + 1, y - 1, z);\n    if (z > 0) ans = max(ans, calc(x + 1, y - 1, z - 1) + 2);\n    \n    if (left[y][s[x] - 'a'] > x) ans = max(ans, calc(x + 1, left[y][s[x] - 'a'] - 1, z) + 2);\n    if (left[y][s[x] - 'a'] == x) ans = max(ans, 1);\n    if (right[x][s[y] - 'a'] < y) ans = max(ans, calc(right[x][s[y] - 'a'] + 1, y - 1, z) + 2);\n    if (right[x][s[y] - 'a'] == y) ans = max(ans, 1);\n    \n    return dp[x][y][z] = ans;\n}\n\nint main() {\n    int n, k, i, j, l;\n    \n    scanf(\"%s\", s);\n    scanf(\"%d\", &k);\n    \n    n = strlen(s);\n    \n    for (i = 0; i < 26; i++) left[0][i] = -1;\n    for (i = 0; i < n; i++) {\n        if (i > 0) {\n            for (j = 0; j < 26; j++) left[i][j] = left[i - 1][j];\n        }\n        \n        left[i][s[i] - 'a'] = i;\n    }\n    \n    for (i = 0; i < 26; i++) right[n][i] = 1e9;\n    for (i = n - 1; i >= 0; i--) {\n        for (j = 0; j < 26; j++) right[i][j] = right[i + 1][j];\n        \n        right[i][s[i] - 'a'] = i;\n    }\n    \n    for (i = 0; i <= n; i++) {\n        for (j = 0; j <= n; j++) {\n            for (l = 0; l <= k; l++) {\n                dp[i][j][l] = -1;\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", calc(0, n - 1, k));\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n\n# define pb push_back\n# define fr first\n# define sc second\n# define mk make_pair\n\nusing namespace std;\n\nconst long long linf = 1e18 + 7;\nconst int inf = 1e9 + 7;\nconst int N = 1e6 + 5;\n\ntypedef long long ll;\n\nstring s;\nint k, dp[301][301][301], u[301][301][301];\n\nint calc(int l, int r, int k){\n      if(k < 0) return -inf;\n      if(l > r) return 0;\n      if(l == r) return 1;\n      if(u[l][r][k]) return dp[l][r][k];\n      u[l][r][k] = 1;\n      int &res = dp[l][r][k];\n      res = max(calc(l + 1, r, k), calc(l, r - 1, k));\n      if(s[l] == s[r])\n            res = max(res, calc(l + 1, r - 1, k) + 2);\n      else\n            res = max(res, calc(l + 1, r - 1, k - 1) + 2);\n      return res;\n}\n\nint main(){\n      cin >> s >> k;\n      s = ' ' + s;\n      cout << calc(1, s.size(), k) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LL long long\n#define Accel ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define Re(a,b) memset(a,b,sizeof a)\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define ALL(X) (X).begin(), (X).end()\n#define FOR(I, A, B) for (int I = (A); I <= (B); I++)\n#define REP(I, N) for (int I = 0; I < (N); I++)\n#define PII pair<int,int>\n#define PLL pair<LL,LL>\n#define SZ(a) ((int)a.size())\n#define endl \"\\n\"\n//#pragma GCC optimize(2)\nusing namespace std;\nconst int N=1e3+1;\nconst int M=1e9+7;\nconst double eps=1e-6;\ntypedef complex<double>C;\nconst double PI(acos(-1.0));\n//__gcd, atan2(y,x)=y/x , __int128\n//c(n,k)=c(n-1,k-1)+c(n-1,k)\n//c(i,r),i for r to n =c(n+1,r+1)\n//void add(int x){while(x<N)BIT[x]++,x+=x&-x;}\n//int sum(int x){return x?BIT[x]+sum(x-(x&-x)):0;}\n//int find(int x){return x==p[x]?x:p[x]=find(p[x]);}\n//LL pw(LL a, LL b,LL M) { return b ? b & 1 ? a*pw(a, b - 1,M) % M : pw(a*a%M, b>>1,M) : 1; }\n//log() = ln() , log(x)/log(y)=log(y)-base-x\n//INT_MAX 127,INT_MIN 128\n//int dw[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\n//int dw[8][2]={{0,1},{1,0},{0,-1},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};\nstring s;\nint f[301][301][301];\nint main(){\n\tcin>>s;\n\tint x;\n\tcin>>x;\n\tint n=SZ(s);\n\tREP(i,n)\n\t\tREP(j,n-i){\n\t\t\tint from=j,to=j+i;\n\t\t\t//cout<<from<<\" \"<<to<<endl;\n\t\t\tfor(int k=0;k<=x;k++){\n\t\t\t\tif(from==to)f[from][to][k]=1;\n\t\t\t\telse{\n\t\t\t\t\tf[from][to][k]=max(max(f[from+1][to][k],f[from][to-1][k]),f[from][to][k]);\n\t\t\t\t\tif(s[from]!=s[to])\n\t\t\t\t\t\tf[from][to][k+1]=max(f[from][to][k+1],f[from+1][to-1][k]+2);\n\t\t\t\t\telse f[from][to][k]=max(f[from][to][k],f[from+1][to-1][k]+2);\n\t\t\t\t}\n\t\t\t\t//cout<<f[from][to][k]<<endl;\n\t\t\t}\n\t\t}\n\tcout<<f[0][n-1][x]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Inf = 1000000000;\nconst int Maxn = 305;\n\nstring S;\nint k;\nint dp[Maxn][Maxn][Maxn];\nint res;\n\nint main()\n{\n\tcin >> S;\n\tcin >> k;\n\tfill((int*)dp, (int*)dp + Maxn * Maxn * Maxn, -Inf);\n\tdp[0][int(S.length()) - 1][0] = 0;\n\tfor (int i = 0; i < S.length(); i++)\n\t\tfor (int j = int(S.length()) - 1; j >= 0; j--)\n\t\t\tfor (int l = 0; l <= k; l++) if (dp[i][j][l] >= 0) {\n\t\t\t\tif (i == j) { res = max(res, dp[i][j][l] + 1); continue; }\n\t\t\t\telse if (i > j) { res = max(res, dp[i][j][l]); continue; }\n\t\t\t\tif (S[i] == S[j]) dp[i + 1][j - 1][l] = max(dp[i + 1][j - 1][l], dp[i][j][l] + 2);\n\t\t\t\tdp[i + 1][j][l] = max(dp[i + 1][j][l], dp[i][j][l]);\n\t\t\t\tdp[i][j - 1][l] = max(dp[i][j - 1][l], dp[i][j][l]);\n\t\t\t\tif (l + 1 <= k) dp[i + 1][j - 1][l + 1] = max(dp[i + 1][j - 1][l + 1], dp[i][j][l] + 2);\n\t\t\t}\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Template\n#include <bits/stdc++.h>\n#define rep_override(x, y, z, name, ...) name\n#define rep2(i, n) for (int i = 0; i < (int)(n); ++i)\n#define rep3(i, l, r) for (int i = (int)(l); i < (int)(r); ++i)\n#define rep(...) rep_override(__VA_ARGS__, rep3, rep2)(__VA_ARGS__)\n#define per(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define all(x) (x).begin(), (x).end()\nusing namespace std;\nusing ll = long long;\nconstexpr int inf = 1001001001;\nconstexpr ll INF = 3003003003003003003;\ntemplate <typename T> inline bool chmin(T& x, const T& y) {if (x > y) {x = y; return 1;} return 0;}\ntemplate <typename T> inline bool chmax(T& x, const T& y) {if (x < y) {x = y; return 1;} return 0;}\nstruct IOSET {IOSET() {cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(10);}} ioset;\n\n// Main\nint main() {\n    string s;\n    int k;\n    cin >> s >> k;\n    \n    vector<vector<vector<int>>> dp(s.size() + 1, vector<vector<int>>(s.size() + 1, vector<int>(k + 1, -1)));\n    auto rec = [&](auto f, int l, int r, int m) -> int {\n        if (dp[l][r][m] != -1) return dp[l][r][m];\n        if (l == r) return dp[l][r][m] = 0;\n        if (l + 1 == r) return dp[l][r][m] = 1;\n        chmax(dp[l][r][m], f(f, l, r - 1, m));\n        chmax(dp[l][r][m], f(f, l + 1, r, m));\n        if (s[l] == s[r - 1]) chmax(dp[l][r][m], f(f, l + 1, r - 1, m) + 2);\n        else if (m) chmax(dp[l][r][m], f(f, l + 1, r - 1, m - 1) + 2);\n        return dp[l][r][m];\n    };\n    \n    cout << rec(rec, 0, (int)s.size(), k) << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//実装が重そうな問題はある程度考えてから書く\n//初期化を忘れずに（特に二分探索とか）\n//コーナーケースを考えて（特に場合分けとか）\n//不可解すぎるバグは配列外参照（配列の長さ）を検討\n#include \"bits/stdc++.h\"\n#define YES \"YES\"\n#define Yes \"Yes\"\n#define NO \"NO\"\n#define No \"No\"\n#define YESNO(x) OUT(three(x,YES,NO))\n#define YesNo(x) OUT(three(x,Yes,No))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define rep REP\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b-1,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB emplace_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define int short\n#define zero 0LL\n#define all ALL\n#define pb PB\nusing namespace std;\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l < r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l > r ? l = r, 1 : 0; }\ntypedef long long LL;\ntypedef LL ll;\ntypedef double ld;\ntypedef LL ut;\nconst LL INF = 1LL << 60;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<ppr, Vppr ,greater<ppr> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nint dx[] = { 0,1,0,-1,1,1,-1,-1,0 }, dy[] = { 1,0,-1,0,1,-1,1,-1,0 };\nconst int SIZE1 =2e3 + 1000;\nconst int SIZE2 = 2010;\nconst int SIZE3 = 301;\nconst int SIZE = SIZE1;\nconst LL p = 7 + 1e9;const long double EPS = 1e-7;\nut N, M, K, X, L, Y,H,W,Q,D;\n// ut A,B,C,D,E,F,G,H,I,J,O,P,Q,R,T,U;\nVI edges[SIZE];\nLL vals[SIZE], nums[SIZE], maps[SIZE2][SIZE2], answer = zero;\n//LL A[SIZE], B[SIZE],I[SIZE];\nLL A, B;\nstring s;\nstring revs;\nLL DP[SIZE3][SIZE3][SIZE3];\nbool checked[SIZE3][SIZE3][SIZE3];\nLL solve2(int a,int b,int k) {\n\tif (a > b) return 0;\n\tif (a == b) return 1;\n\tif (checked[a][b][k]) return DP[a][b][k];\n\tchecked[a][b][k] = true;\n\n\tif (s[a] == s[b]) {\n\t\treturn DP[a][b][k] = solve2(a + 1, b - 1, k) + 2;\n\t}\n\tMX(DP[a][b][k], solve2(a + 1, b, k));\n\tMX(DP[a][b][k], solve2(a, b -1, k));\n\tif (k)\n\t\tMX(DP[a][b][k], solve2(a + 1, b -1, k - 1)+2);\n\treturn DP[a][b][k];\n\t/*/\n\tif (max(a, b) >= s.size()) return 0;\n\tif (checked[a][b][k]) return DP[a][b][k];\n\tchecked[a][b][k]=true;\n\tif (s[a] == revs[b]) {\n\t\treturn DP[a][b][k] = solve2(a + 1, b + 1, k)+1;\n\t}\n\tMX(DP[a][b][k], solve2(a + 1, b, k));\n\tMX(DP[a][b][k], solve2(a , b+1, k));\n\tif(k)\n\t\tMX(DP[a][b][k], solve2(a + 1, b+1, k-1));\n\treturn DP[a][b][k];\n/*/\n}\nLL solve() {\n\tcin >> s;\n\trevs = s;\n\treverse(ALL(revs));\n\tcin >> K;\n\tcout << solve2(0, (LL)s.size()-1, K) << endl;\n\treturn 0;\n}\nsigned main() {\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(10);\n\tsolve();\n\t//\tcin >> N;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nint dp[310][310][310];\n\nstring s;\nint K;\n\nint saiki(int i,int j,int k){\n\tif(k>K)return 0;\n\tif(i==j)return 1;\n\tif(i>j)return 0;\n\tif(dp[i][j][k]!=0)return dp[i][j][k];\n\tif(s[i]==s[j]){\n\t\treturn dp[i][j][k] = saiki(i+1,j-1,k)+2;\n\t}else{\n\t\tdp[i][j][k] = max(dp[i][j][k],saiki(i+1,j,k));\n\t\tdp[i][j][k] = max(dp[i][j][k],saiki(i,j-1,k));\n\t\tif(k!=K)dp[i][j][k] = max(dp[i][j][k],saiki(i+1,j-1,k+1)+2);\n\t\treturn dp[i][j][k];\n\t}\n}\n\n\n\nint main(){\n\tcin >> s >> K;\n\tcout << saiki(0,s.size()-1,0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint result[301][301][301] = {};\n\nint main()\n{\n\tstring s;\n\tint k;\n\tcin >> s >> k;\n\tint l = s.length();\n\tfor(int i = 0; i <= k; i++){\n\t\tfor(int p = 1; p <= l; p++){\n\t\t\tfor(int q = 1; q <= l; q++){\n\t\t\t\tif(s[p - 1] == s[l - q]) result[i][p][q] = max(result[i][p][q], result[i][p - 1][q - 1] + 1);\n\t\t\t\telse {\n\t\t\t\t\tif(i < k) result[i + 1][p][q] = max(result[i + 1][p][q], result[i][p - 1][q - 1] + 2);\n\t\t\t\t\tresult[i][p][q] = max(result[i][p][q], max(result[i][p - 1][q], result[i][p][q - 1]));\n\t\t\t\t}\n\t\t\t\t// cout << i << \" \" << p << \" \" << q << \" \" << result[i][p][q] << endl;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i <= k; i++){\n\t\tans = max(ans, result[i][l][l]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <iostream>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdlib>\n\nusing namespace std;\n\n#define INF 1e+9\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define fs first\n#define se second\n#define i64 long long\n#define li long long\n#define lint long long\n#define pii pair<int, int>\n#define vi vector<int>\n\n#define forn(i, n) for (int i = 0; i < (int)n; i++)\n#define fore(i, b, e) for (int i = (int)b; i <= (int)e; i++)\n\nint ans;\n\nvoid upd(int& x, int y) {\n    x = max(x, y);\n    ans = max(ans, y);\n}\n\nconst int maxn = 305;\n\nint dp[maxn][maxn][maxn];\n\nint main() {\n#ifdef LOCAL\n    freopen(\"inp\", \"r\", stdin);\n    //freopen(\"outp\", \"w\", stdout);\n#else\n    // freopen(TASKNAME \".in\", \"r\", stdin);\n    // freopen(TASKNAME \".out\", \"w\", stdout);\n#endif\n    int k;\n    string s;\n    cin >> s >> k;\n    int n = s.length();\n    fore(l1, 0, n)\n        fore(l2, 0, n - l1 - 1)\n            fore(changes, 0, k) {\n                //printf(\"dp = %d l1 = %d l2 = %d changes = %d\\n\", dp[l1][l2][changes], l1, l2, changes);\n                upd(dp[l1 + 1][l2][changes], dp[l1][l2][changes]);\n                upd(dp[l1][l2 + 1][changes], dp[l1][l2][changes]);\n                int addit = l1 == n - l2 - 1 ? 1 : 2;\n                if (s[l1] == s[n - l2 - 1]) {\n                    upd(dp[l1 + 1][l2 + 1][changes], dp[l1][l2][changes] + addit);\n                } else if (changes < k) {\n                    upd(dp[l1 + 1][l2 + 1][changes + 1], dp[l1][l2][changes] + addit);\n                }\n            }\n    printf(\"%d\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n変更箇所は順読み逆読みの少なくとも片方で役立たないといけない\nつまり1点分として加算される必要がある\n逆に1点分以上の役割は持てない<-嘘だった\n例えば右端の文字が他に存在しない文字ならそれを変更するのはOK\n*/\n/*\n問題概要は最長の回文を作れ？\nだとすると中心決めてしまえばそこからは書き換えるかどうかは片側だけに注目すればよくて\nsBtに対してsを右側から見ていくことを考える\n変えるならt[now]しかありえなくて、書き換えた方がいいかどうかチェックするのに150^2かかる？\nなんか違いそう\n端から見て言ってdp[i][j][k]で考えるべき？\ndp[i][j][k]:左からi文字右からj文字、k文字変更した時の最長回文\ndp[i][j][k]=max(dp[i][j-1][k],dp[i-1][j][k],dp[i-1][j-1][k]+(s[i]==s[N-j-1]),dp[i-1][j-1][k-1]+1)\n*/\ntemplate<typename T>\nvoid fin(T a){\n  cout<<a<<endl;\n  exit(0);\n}\nint dp[400][400][400];\nsigned main(){\n  string s;int K;cin>>s>>K;\n  int N=s.size();\n  if(K>=N/2)fin(N);\n  int ans=0;\n  for(int k=0;k<=K;k++){\n    for(int i=1;i<N;i++){\n      for(int j=1;i+j<=N;j++){\n        dp[i][j][k]=max({dp[i][j-1][k],dp[i-1][j][k],dp[i-1][j-1][k]+2*(s[i-1]==s[N-j])});\n        if(k)dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k-1]+2);\n        ans=max(ans,dp[i][j][k]+(i+j<N));\n      }\n    }\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint i,j,k,n,m,x,y,t,f[310][310][310],ans;\nchar s[310];\nint main(){\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tscanf(\"%d\",&m);\n\tfor (j=1;j<=n;j++)\n\t\tfor (i=1;i<=n-j+1;i++)\n\t\t\tfor (k=0;k<=m;k++)\n\t\t\t\tif (j==1)f[i][i][k]=1;\n\t\t\t\telse if (j==2)f[i][i+1][k]=(k||s[i]==s[i+1])?2:1;\n\t\t\t\telse{\n\t\t\t\t\tf[i][i+j-1][k]=max(f[i+1][i+j-1][k],f[i][i+j-2][k]);\n\t\t\t\t\tif (s[i]==s[i+j-1])f[i][i+j-1][k]=max(f[i][i+j-1][k],f[i+1][i+j-2][k]+2);\n\t\t\t\t\telse if (k)f[i][i+j-1][k]=max(f[i][i+j-1][k],f[i+1][i+j-2][k-1]+2);\n\t\t\t\t}\n\tfor (i=0;i<=m;i++)ans=max(ans,f[1][n][i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma comment(linker, \"/STACK:108777216\")\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <deque>\n#include <utility>\n#include <algorithm>\n#include <ctime>\nusing namespace std;\n\nint const MAX_N = 305;\n\nstring st;\nint K_mx;\n\nshort int dp[MAX_N][MAX_N][MAX_N];\n\nint main() {\n\t//freopen(\"input.txt\",\"r\",stdin);\n\t//freopen(\"output.txt\",\"w\",stdout);\n    \n    cin>>st>>K_mx;\n\n    int n = (int) st.length();\n    for (int i=0; i<n; i++)\n        dp[i][i][0] = 1;\n\n    for (int len=2; len<=n; len++)\n        for (int i=0; i+len-1 < n; i++) {\n            int j = i+len-1;\n            for (int old_k = 0; old_k <= K_mx; old_k++) {\n                dp[i][j][old_k] = max(dp[i][j][old_k], max(dp[i+1][j][old_k], dp[i][j-1][old_k]));\n                if (st[i] == st[j])\n                    dp[i][j][old_k] = max(dp[i][j][old_k], (short int) (dp[i+1][j-1][old_k] + 2));\n                else if (old_k + 1 <= K_mx)\n                    dp[i][j][old_k+1] = max(dp[i][j][old_k+1], (short int) (dp[i+1][j-1][old_k] + 2));\n            }\n        }\n\n    short int ans = 0;\n    for (int old_k=0; old_k<=K_mx; old_k++)\n        ans = max(ans, dp[0][n-1][old_k]);\n    cout<<ans;\n   \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n#include <cstdio>\n#include <iostream>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n//#ifdef atom #else #endif\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\n#define X first\n#define Y second\n#define vi vector<int>\n#define vvi vector< vi >\n#define vii vector< ii >\n#define mp make_pair\n#define pb push_back\nstring s;\nint k;\nconst int maxn = 305;\nconst int maxk = 305;\nint dp[maxn][maxn][maxk];\nint n;\nint solve(int i, int j, int k)\n{\n    if(i == n || j< 0) return 0;\n    if(dp[i][j][k] != -1) return dp[i][j][k];\n    int res = 0;\n    res = max(res, solve(i+1, j, k));\n    res = max(res, solve(i, j-1, k));\n    if(s[i] == s[j]) res = max(res, 1+solve(i+1, j-1, k));\n    else if(k) res = max(res, solve(i+1, j-1, k-1)+2);\n    return dp[i][j][k] = res;\n}\nint main()\n{\n    //#ifndef atom freopen(\".in\", \"r\", stdin); freopen(\".out\", \"w\", stdout); #endif\n    cin >> s >> k;\n    n = s.size();\n    memset(dp, -1, sizeof dp);\n    cout << solve(0, n-1, k) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\nchar s[310];\nint K,n,f[310][310][310];\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') f=-1;\n\tfor(;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\nint main()\n{\n\tscanf(\"%s%d\",s+1,&K);\n\tn=strlen(s+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int k=0;k<=K;k++)\n\t\t\tf[i][i][k]=1;\n\tfor(int len=1;len<n;len++)\n\t\tfor(int l=1,r=len+1;r<=n;r++,l++)\n\t\t\tfor(int k=0;k<=K;k++)\n\t\t\t{\n\t\t\t\tf[l][r][k]=max(f[l+1][r][k],f[l][r-1][k]);\n\t\t\t\tif(s[l]==s[r]) f[l][r][k]=max(f[l+1][r-1][k]+2,f[l][r][k]);\n\t\t\t\telse if(k) f[l][r][k]=max(f[l+1][r-1][k-1]+2,f[l][r][k]);\n\t\t\t}\n\tprintf(\"%d\",f[1][n][K]);\t\t\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\n\nstring s; int n;\nint K;\nint dp[300][300][301];\nint iter[2][300][26];\n\nint dfs(int l, int r, int x) {\n\tint len = r - l + 1;\n\tif (len == 1) return 1;\n\tif (len <= 0) return 0;\n\tif (dp[l][r][x] != -1) return dp[l][r][x];\n\t\n\tint ret = 0;\n\tif (x > 0 && len >= 2) ret = 2 + dfs(l + 1, r - 1, x - (s[l] != s[r]));\n\t\n\tfor (int i = 0; i < 26; i++) {\n\t\tint nl = iter[0][l][i];\n\t\tint nr = iter[1][r][i];\n\t\tif (nl == -1 || nr == -1 || nl > nr) continue;\n\t\tint res = 2 - (nl == nr) + dfs(nl + 1, nr - 1, x);\n\t\tret = max(ret, res);\n\t}\n\treturn dp[l][r][x] = ret;\n}\n\nint main() {\n\tint i, j, k;\n\t\n\tcin >> s >> K;\n\tn = s.length();\n\trep(i, n) rep(j, n) rep(k, n + 1) dp[i][j][k] = -1;\n\trep(i, 2) rep(j, n) rep(k, 26) iter[i][j][k] = -1;\n\t\n\trep(i, n) {\n\t\tfor (j = i; j < n; j++) {\n\t\t\tif (iter[0][i][s[j] - 'a'] == -1) {\n\t\t\t\titer[0][i][s[j] - 'a'] = j;\n\t\t\t}\n\t\t}\n\t\tfor (j = i; j >= 0; j--) {\n\t\t\tif (iter[1][i][s[j] - 'a'] == -1) {\n\t\t\t\titer[1][i][s[j] - 'a'] = j;\n\t\t\t}\n\t\t}\n\t}\n\tint res = dfs(0, n - 1, K);\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n\ninline void check_max(int a,int &b){if(a>b)b=a;}\n\nconst int N=310,INF=1000000007;\n\nint f[N][N][N];\n\nchar s[N];\nint n,k;\n\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tscanf(\"%d\",&k);\n\tn=strlen(s+1);\n\n\tfor(int i=0;i<N;i++)\n\t\tfor(int j=0;j<N;j++)\n\t\t\tfor(int l=0;l<N;l++)\n\t\t\t\tf[i][j][l]=-INF;\n\n\tf[0][n+1][0]=0;\n\t\n\tfor(int len=n+1;len>0;len--)\n\t\tfor(int i=0;i+len<=n+1;i++)\n\t\t{\n\t\t\tint j=i+len;\n\t\t\tfor(int l=0;l<=k;l++)\n\t\t\t{\n\t\t\t\tint v=f[i][j][l];\n\t\t\t\tif(v<0)continue;\n\t\t\t\t\n\t\t\t\tif(s[i+1]==s[j-1])\n\t\t\t\t\tcheck_max(v+1,f[i+1][j-1][l]);\n\t\t\t\t\n\t\t\t\tcheck_max(v,f[i+1][j][l]);\n\t\t\t\tcheck_max(v,f[i][j-1][l]);\n\n\t\t\t\tcheck_max(v+1,f[i+1][j-1][l+1]);\n\t\t\t}\n\t\t}\n\n\tint ans=0;\n\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int l=0;l<=k;l++)\n\t\t\tcheck_max(f[i][i][l]*2-1,ans);\n\tfor(int i=1;i<n;i++)\n\t\tfor(int l=0;l<=k;l++)\n\t\t\tcheck_max(f[i][i+1][l]*2,ans);\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\ntemplate <typename H>\nH max(const H &head) {\n\treturn head;\n}\ntemplate <typename H, typename ...Tail>\nH max(const H &head, const Tail&... tail) {\n\tauto tail_max = max(tail...);\n\treturn head > tail_max ? head : tail_max;\n}\n\nint max_lcs(const std::string &str, int l, int r, int k, std::vector<std::vector<std::vector<int>>> &memo) {\n\tif (l > r) return 0;\n\tif (l == r) return 1;\n\tif (memo[l][r][k] > 0) return memo[l][r][k];\n\tint res{ 0 };\n\tif (str[l] == str[r]) {\n\t\tres = max_lcs(str, l + 1, r - 1, k, memo) + 2;\n\t}\n\telse if (k != 0) {\n\t\tres = max_lcs(str, l + 1, r - 1, k - 1, memo) + 2;\n\t}\n\tres = max(res, max_lcs(str, l + 1, r, k, memo), max_lcs(str, l, r - 1, k, memo));\n\treturn memo[l][r][k] = res;\n}\nint max_lcs(const std::string &str, int k) {\n\tstd::vector<std::vector<std::vector<int>>> memo(str.size() + 1, std::vector<std::vector<int>>(str.size() + 1, std::vector<int>(k + 1, -1)));\n\treturn max_lcs(str, 0, str.size() - 1, k, memo);\n}\n\nint main() {\n\tstd::string str;\n\tint k;\n\tstd::cin >> str >> k;\n\tstd::cout << max_lcs(str, k) << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define f first\n#define s second\n#define pb push_back\nusing namespace std;\nll dp[301][301][301],k;\nstring s;\nll solve(ll x,ll y,ll p){\n    if(dp[x][y][p])return dp[x][y][p];\n    if(x == y){\n        dp[x][y][p] = 1;\n        return dp[x][y][p];\n    }\n    if(x + 1 == y){\n        if(s[x] == s[y] || p)dp[x][y][p] = 2;\n        else dp[x][y][p] = 1;\n        return dp[x][y][p];\n    }\n    if(p == 0){\n        if(s[x] == s[y]){\n            dp[x][y][p] = solve(x + 1 ,y - 1, p) + 2;\n            return dp[x][y][p];\n        }\n        ll t = solve(x , y - 1 , p);\n        ll r = solve(x + 1 , y , p);\n        return max(t , r);\n    }\n    if(s[x] == s[y]){\n        dp[x][y][p] = solve(x + 1, y - 1 , p) + 2;\n        return dp[x][y][p];\n    }\n    dp[x][y][p] = solve(x + 1 , y - 1 , p);\n    ll t = solve(x , y - 1 , p);\n    ll r = solve(x + 1 , y , p);\n    ll q = solve(x + 1 , y - 1, p - 1) + 2;\n    q = max(q , max(t , r));\n    if(dp[x][y][p] < q)dp[x][y][p] = q;\n    return dp[x][y][p];\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin >> s >> k;\n    \n    cout << solve(0 , (int)s.size() - 1 , k);\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<iostream>\nusing namespace std;\nconst int maxn=307;\n\nchar S[maxn];\nint L,K;\n\nint dp[maxn][maxn][maxn],V[maxn][maxn];\n\nint main(){\n        scanf(\"%s%d\",S+1,&K);\n        L=strlen(S+1);\n        for(int i=1;i<=L;++i) for(int j=L;j;--j) for(int k=0;k<=K;++k){\n                if(S[i]==S[j]){\n                        dp[i][j][k]=dp[i-1][j+1][k]+1;\n                }else{\n                        dp[i][j][k]=max(dp[i-1][j][k],dp[i][j+1][k]);\n                        if(k) dp[i][j][k]=max(dp[i][j][k],dp[i-1][j+1][k-1]+1);\n                }   \n        }   \n        for(int i=1;i<=L;++i) for(int j=L;j;--j){\n                V[i][j]=max(max(V[i-1][j],V[i][j+1]),dp[i][j][K]);\n        }   \n\n        int ans=1;\n        for(int i=2;i<L;++i) ans=max(ans,V[i-1][i+1]*2+1);\n        for(int i=1;i<L;++i) ans=max(ans,V[i][i+1]*2);\n        printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\nint Max(int x,int y){\n        return x<y?y:x;\n}\nint main(){\n        string str;\n        int k;\n        cin >> str >> k;\n        string rts=\"\";\n        for(int i=str.size()-1 ; i>=0 ; i-- ){\n                rts+=str[i];\n        }\n        int dp[310][310];\n        cout << rts << endl;\n        for(int i=0 ; i<str.size() ; i++ ){\n                dp[i][0]=0;dp[0][i]=0;\n        }\n        for(int i=1 ; i<=str.size() ; i++ ){\n                for(int j=1 ; j<=str.size() ; j++ ){\n                        if(str[i-1]==rts[j-1]){\n                                dp[i][j]=dp[i-1][j-1]+1;\n                        }else\n                                dp[i][j]=Max(dp[i-1][j],dp[i][j-1]);\n                }\n        }\n        k*=2;\n        if(dp[str.size()][str.size()]+k<=str.size())\n                cout<<dp[str.size()][str.size()]+k<<endl;\n        else\n                cout<<str.size() << endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\ninline void chmax(int &x, int v) { if (x < v) x = v; }\n\nstring S;\nint N, K;\nint dp[301][301][302];\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> S >> K;\n  N = S.length();\n  rep(i, N) rep(j, N) rep(k, K+1) dp[i][j][k] = -INF;\n  dp[0][N-1][0] = 0;\n  int m = 0;\n  for (int len=N; len>=2; len--) {\n    rep(l, N) {\n      int r = l+len-1;\n      if (r >= N) break;\n      rep(k, K+1) {\n        if (dp[l][r][k] < 0) continue;\n        chmax(dp[l+1][r-1][k+(S[l]!=S[r])], dp[l][r][k] + 2);\n        chmax(dp[l+1][r][k], dp[l][r][k]);\n        chmax(dp[l][r-1][k], dp[l][r][k]);\n      }\n    }\n  }\n  rep(i, N) rep(j, N) rep(k, K+1) chmax(m, dp[i][j][k] + (i<=j));\n  cout << m << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//cwystc <--> 陈威宇是天才  --by cwy\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pi;\nconst double PI=acos(-1);\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define rep(i,a,b) for (int i=(a);i<=(b);i++)\n#define per(i,a,b) for (int i=(a);i>=(b);i--)\n#define Rep(i,a,b) for (int i=(a);i<(b);i++)\n#define Per(i,a,b) for (int i=(a);i>(b);i--)\n#define travel_set(it,a) for (set<int>::iterator (it)=(a).begin();(it)!=(a).end();(it)++)\n#define travel_map(it,a) for (map<int>::iterator (it)=(a).begin();(it)!=(a).end();(it)++)\n#define travel_vec(it,a) for (vector<int>::iterator (it)=(a).begin();(it)!=(a).end();(it)++)\n#define p(x) cout << x << endl;\n#define def cout << \"find\" << endl;\n#define what_is(x) cout << #x << \" is \" << x << endl;\ntemplate <class T>T sqr(T x){return x*x;}\ntemplate <class T>T alex(T x){return (x>0)?x:-x;}\ntemplate <class T>void read(T&x){\n\tx=0;T f=1;char ch=getchar();\n\twhile ((ch<48||ch>57)&&ch!=45)ch=getchar();\n\tif (ch==45)f=-1,ch=getchar();\n\twhile (ch>=48&&ch<=57)x=x*10+ch-48,ch=getchar();\n\tx*=f;\n}\n\n//-------------------------------------------------head-------------------------------------------------\n\n#define maxn 305\nint f[maxn][maxn][maxn];\nchar s[maxn],_s[maxn];int k,len;\nint main(){\n\tscanf(\"%s\",s+1);len=strlen(s+1);read(k);\n\trep(i,1,len)_s[i]=s[len-i+1];\n\t// rep(i,0,len)f[i][0][0]=f[0][i][0]=0;\n\trep(i,1,len)rep(j,1,len)if (i!=0&&j!=0){\n\t\tf[i][j][0]=max(max(f[i-1][j][0],f[i][j-1][0]),f[i-1][j-1][0]+(s[i]==_s[j]));\n\t\trep(kk,1,k){\n\t\t\tf[i][j][kk]=max(max(f[i-1][j][kk],f[i][j-1][kk]),f[i-1][j-1][kk-(s[i]!=_s[j])]+1);\n\t\t}\n\t}\n\tint res=0;\n\trep(i,1,len)rep(kk,0,k)res=max(f[i-1][len-i][kk]*2+1,res);printf(\"%d\\n\",res);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring s;\nint dp[305][305][305];\nint solve(int l,int r,int k)\n{\n\tif (k<0)\n\treturn -1e9;\n\tif (r-l<1)\n\treturn r-l+1;\n\tif (dp[l][r][k]!=-1)\n\treturn dp[l][r][k];\n\treturn dp[l][r][k]=max(max(solve(l+1,r,k),solve(l,r-1,k)),2+solve(l+1,r-1,k-(s[l]!=s[r])));\n}\nint main()\n{\n\tint k;\n\tcin >> s >> k;\n\tmemset(dp,-1,sizeof(dp));\n\tcout << solve(0,s.size()-1,k);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<string>\n\nusing namespace std;\ntypedef long long LL;\n\nconst int maxn=310;\n\nint DP[maxn][maxn][maxn],v;\nchar str[maxn];\n\nint Cal()\n{\n    int len=strlen(str);\n    memset(DP,0,sizeof(DP));\n    for(int i=0;i<len;i++) DP[i][i][0]=1;\n    for(int i=len-2;i>=0;i--)\n        for(int j=i+1;j<len;j++)\n             for(int k=0;k<=v;k++)\n             {\n        if(str[j]==str[i]) DP[i][j][k]=DP[i+1][j-1][k]+2;\n        else\n        {\n            DP[i][j][k]=max(DP[i+1][j][k],DP[i][j-1][k]);\n            if(k)  DP[i][j][k]=max(DP[i+1][j-1][k-1]+2,DP[i][j][k]);\n        }\n             }\n    return DP[0][len-1][v];\n}\n\nint main()\n{\n    scanf(\"%s\",&str);\n    scanf(\"%d\",&v);\n    printf(\"%d\",Cal());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=310;\nint n,k,f[N][N][N];\nchar s[N];\nint main(){\n\tscanf(\"%s\",s+1);\n\tscanf(\"%d\",&k);\n\tn=strlen(s+1);\n\tfor(int i=1;i<=n;i++) f[i][i][0]=1;\n\tint l,r;\n\tfor(int i=2;i<=n;i++)\n\t\tfor(int j=1;j<=n-i+1;j++)\n\t\t\tfor(int x=0;x<=k;x++){\n\t\t\t\tl=j,r=j+i-1;\n\t\t\t\tf[l][r][x]=max(f[l+1][r][x],f[l][r-1][x]);\n\t\t\t\tif(x) f[l][r][x]=max(f[l][r][x],max(f[l+1][r][x-1]+2,f[l][r-1][x-1]+2));\n\t\t\t\tif(s[l]==s[r]) f[l][r][x]=max(f[l][r][x],f[l+1][r-1][x]+2);\n\t\t\t}\n\tprintf(\"%d\",f[1][n][k]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\nstring s;\nint limit;\nint dp[310][310][310];\n\nint main(void) {\n\tcin >> s >> limit;\n\tconst int n = s.size();\n\n\trep(i, n + 1)rep(j, n + 1)rep(k, limit + 1) {\n\t\tconst int sidx = i;\n\t\tconst int ridx = n - 1 - j;\n\n\t\tif (sidx < n and 0 <= ridx and s[sidx] == s[ridx]) {\n\t\t\tchmax(dp[i + 1][j + 1][k], dp[i][j][k] + 1);\n\t\t}\n\n\t\tif (sidx < n) {\n\t\t\tchmax(dp[i + 1][j][k], dp[i][j][k]);\n\t\t}\n\n\t\tif (0 <= ridx) {\n\t\t\tchmax(dp[i][j + 1][k], dp[i][j][k]);\n\t\t}\n\n\t\tif (k + 1 <= limit and sidx < n and 0 <= ridx) {\n\t\t\tchmax(dp[i + 1][j + 1][k + 1], dp[i][j][k] + 1);\n\t\t}\n\t}\n\n\tint ans = 0;\n\trep(i, n + 1) {\n\t\tconst int j = n - i;\n\t\trep(k, limit + 1) chmax(ans, dp[i][j][k]);\n\t}\n\n\tif(n % 2 == 1)\n\t\tcout << 2 * ans + 1 << endl;\n\telse\n\t\tcout << 2 * ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define maxn 1000005\n#define inf 1e9\n#define pb push_back\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,w=1; char c=getchar();\n\twhile(c<'0'||c>'9') {if(c=='-') w=-1; c=getchar();}\n\twhile(c<='9'&&c>='0') {x=(x<<1)+(x<<3)+c-'0'; c=getchar();}\n\treturn w==1?x:-x;\n}\n\nint dp[305][305][305];\nchar s[maxn];\n\nint main()\n{\n\tscanf(\"%s\",s+1); int K=read(),len=strlen(s+1);\n\trep(i,1,len) dp[i][i][0]=1;\n\trep(i,2,len) for(int l=1;l+i-1<=len;l++) for(int k=0;k<=K;k++)\n\t{\n\t\tint r=l+i-1;\n\t\tdp[l][r][k]=max(dp[l+1][r][k],dp[l][r-1][k]);\n\t\tif(s[l]==s[r]) dp[l][r][k]=max(dp[l][r][k],dp[l+1][r-1][k]+2);\n\t\tif(k) dp[l][r][k]=max(dp[l][r][k],dp[l+1][r-1][k-1]+2);\n\t}\n\tint ans=0;\n\trep(i,0,K) ans=max(ans,dp[1][len][i]);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n#define MOD 1000000007\n \nint dp[301][301];\n \nint main(){\n  string s;\n  cin>>s;\n  reverse(s.begin(),s.end());\n  string t=s;\n  reverse(s.begin(),s.end());\n  int k,n=s.length();\n  cin>>k;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n      }else{\n        dp[i+1][j+1]=max(dp[i][j+1],dp[i+1][j]);\n      }\n    }\n  }\n  int ans=dp[n][n];\n  ans=min(n,ans+2*k);\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dp[400][400][400];\n\nint main() {\n  string s;\n  cin >> s;\n\n  int K;\n  cin >> K;\n\n  for (int i = 0; i < s.size(); ++i) {\n    dp[i][i][0] = 1;\n  }\n  for (int i = 0; i + 1 < s.size(); ++i) {\n    if (s[i] == s[i + 1])\n      dp[i][i + 1][0] = 2;\n    else\n      dp[i][i + 1][0] = 1;\n  }\n\n  int ans = 0;\n  for (int d = 2; d < s.size(); ++d) {\n    for (int l = 0; l + d < s.size(); ++l) {\n      int r = l + d;\n      for (int k = 0; k <= K; ++k) {\n        if (s[l] == s[r]) {\n          dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k] + 2);\n        } else {\n          if (k) dp[l][r][k] = max(dp[l][r][k], dp[l + 1][r - 1][k - 1] + 2);\n        }\n\n        dp[l][r][k] = max({dp[l][r][k], dp[l + 1][r][k], dp[l + 1][r - 1][k], dp[l][r - 1][k]});\n        ans = max(ans, dp[l][r][k]);\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define be(v) (v).begin(),(v).end()\n#define pb(q) push_back(q)\ntypedef long long ll;\nusing namespace std;\nconst ll mod=1000000007, INF=mod*mod*3LL;\n#define doublecout(a) cout<<fixed<<setprecision(10)<<a<<endl;\n\nvoid chmax(int &a, int b){a = max(a, b);}\nint main() {\n    cin.tie(0);\n    cout.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    int m;\n    cin >> s >> m;\n    int n = s.length();\n    s = \"#\" + s;\n    vector<vector<vector<int> > > dp(n+1, vector<vector<int> > (n+2, vector<int> (m+1, 0)));\n    int ans = 0;\n    for(int i=1;i<=n;i++){\n    \tfor(int j=n;j>=i;j--){\n    \t\tfor(int k=0;k<=m;k++){\n    \t\t\tchmax(dp[i][j][k], dp[i][j+1][k]);\n    \t\t\tchmax(dp[i][j][k], dp[i-1][j][k]);\n    \t\t}\n    \t\tif(s[i] == s[j]){\n    \t\t\tfor(int k=0;k<=m;k++){\n    \t\t\t\tif(i == j) chmax(dp[i][j][k], dp[i-1][j+1][k] + 1);\n    \t\t\t\telse chmax(dp[i][j][k], dp[i-1][j+1][k] + 2);\n    \t\t\t\tchmax(ans, dp[i][j][k]);\n    \t\t\t}\n    \t\t}else{\n    \t\t\tfor(int k=0;k<m;k++){\n    \t\t\t\tif(i == j) chmax(dp[i][j][k+1], dp[i-1][j+1][k] + 1);\n    \t\t\t\telse chmax(dp[i][j][k+1], dp[i-1][j+1][k] + 2);\n    \t\t\t\tchmax(ans, dp[i][j][k+1]);\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"---------------\"#x\"---------------\"<<endl\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n\t\t\t\t\t\tFor(_x,L,R)cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector <int> vi;\ntypedef long double LD;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf|=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\nconst int N=305;\nint n,k;\nchar s[N];\nint dp[N][N][N];\nvoid ckmax(int &x,int y){\n\tx=max(x,y);\n}\nint DP(int L,int R,int k){\n\tif (L>R)\n\t\treturn 0;\n\tif (L==R)\n\t\treturn 1;\n\tif (~dp[L][R][k])\n\t\treturn dp[L][R][k];\n\tint ans=0;\n\tckmax(ans,DP(L,R-1,k));\n\tckmax(ans,DP(L+1,R,k));\n\tif (s[L]==s[R])\n\t\tckmax(ans,DP(L+1,R-1,k)+2);\n\telse if (k>0)\n\t\tckmax(ans,DP(L+1,R-1,k-1)+2);\n\treturn dp[L][R][k]=ans;\n}\nint main(){\n\tcin>>s+1>>k;\n\tn=strlen(s+1);\n\tmemset(dp,-1,sizeof dp);\n\tcout<<DP(1,n,k)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    string S;\n    cin >> S;\n    size_t K;\n    cin >> K;\n    size_t N{S.size()};\n    vector<vector<vector<int>>> dp(N, vector<vector<int>>(N, vector<int>(K + 1)));\n    for(size_t i = 0; i < N; ++i)dp[i][i][0] = 1;\n    for(size_t j = 0; j <= K; ++j)for(size_t k = 1; k < N; ++k)for(size_t i = 0; i + k < N; ++i)\n        dp[i][i + k][j] = max({dp[i][i + k - 1][j], dp[i + 1][i + k][j], (S[i] == S[i + k]) * (dp[i + 1][i + k - 1][j] + 2), (j != 0) * (dp[i + 1][i + k - 1][j - 1] + 2)});\n    cout << dp[0][N - 1][K] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cout<<#v<<\":\";for(int i=0;i<v.size();i++) cout<<\" \"<<v[i]; cout<<endl\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\nconst int inf = 1000000001;\nconst ll INF = 2e18;\n#define MOD 1000000007\n#define mod 1000000009\n#define pi 3.14159265358979323846\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\n\nint main() {\n\tstring s;\n\tcin >> s;\n\tint k;\n\tcin >> k;\n\tint n = s.size();\n\tstring s2;\n\ts2 = s;\n\treverse(s2.begin(), s2.end());\n\tvii dp(n + 1, vi(n + 1));\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tif (s[i] == s2[j]) {\n\t\t\t\tdp[i + 1][j + 1] = dp[i][j] + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << min(n, dp[n][n] + 2 * k) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\n#define mem(a,v) memset((a), (v), sizeof (a))\n#define enl printf(\"\\n\")\n#define case(t) printf(\"Case #%d: \", (t))\n#define ni(n) scanf(\"%d\", &(n))\n#define nl(n) scanf(\"%lld\", &(n))\n#define nai(a, n) for (int i = 0; i < (n); i++) ni(a[i])\n#define nal(a, n) for (int i = 0; i < (n); i++) nl(a[i])\n#define pri(n) printf(\"%d\\n\", (n))\n#define prl(n) printf(\"%lld\\n\", (n))\n#define pii pair<int, int>\n#define pil pair<int, long long>\n#define pll pair<long long, long long>\n#define vii vector<pii>\n#define vil vector<pil>\n#define vll vector<pll>\n#define vi vector<int>\n#define vl vector<long long>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef cc_hash_table<int,int,hash<int>> ht;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> oset;\nconst double pi = acos(-1);\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 7;\nconst int MAXN = 3e2 + 5;\nconst double eps = 1e-9;\nint dp[MAXN][MAXN][MAXN];\nchar str[MAXN];\n\nint main() {\n\tscanf(\"%s\", str);\n\tint n = strlen(str), k; ni(k);\n\tfor (int i = 0; i <= k; i++) {\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tdp[i][j][j] = 1;\n\t\tfor (int len = 1; len < n; len++) {\n\t\t\tfor (int l = 0; l + len < n; l++) {\n\t\t\t\tint r = l + len;\n\t\t\t\tdp[i][l][r] = max(dp[i][l+1][r], dp[i][l][r-1]);\n\t\t\t\tif (str[l] == str[r])\n\t\t\t\t\tdp[i][l][r] = dp[i][l+1][r-1] + 2;\n\t\t\t\telse if (i)\n\t\t\t\t\tdp[i][l][r] = max(dp[i][l][r], dp[i-1][l+1][r-1] + 2);\n\t\t\t}\n\t\t}\n\t}\n\tpri(dp[k][0][n-1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 2e3+1;\n\nchar c[N][N];\nint n,m,a,b;\n\n\nint main(){\n\tcin>>n>>m>>a>>b;\n\tif(n==3&&m==3&&a==2&&b==2){\n\t\tprintf(\"<>^\\n^ v\\nv<>\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;++i)\n\tfor(int j=1;j<=m;++j)\n\tc[i][j]='.';\n\tif(n&1){\n\t\tint tn=min(a,m/2);\n\t\ta-=tn;\n\t\tfor(int i=1;i<=tn;++i)c[n][i*2-1]='<',c[n][i*2]='>';\n\t}\n\tif(m&1){\n\t\tint tm=min(b,n/2);\n\t\tb-=tm;\n\t\tfor(int i=1;i<=tm;++i)c[i*2-1][m]='^',c[i*2][m]='v';\n\t}\n\tint n1=n,m1=m;\n\tn=n-(n&1),m=m-(m&1);\n\tif(n*m<2*(a+(a&1))+2*(b+(b&1)))return 0*printf(\"NO\\n\");\n\tbool flag=1;\n\tfor(int i=1;i<=n;i+=2)\n\tfor(int j=1;j<=m;j+=2){\n\t\tif(a)c[i][j]='<',c[i][j+1]='>',a--;\n\t\tif(a)c[i+1][j]='<',c[i+1][j+1]='>',a--;\n\t\tif(!flag){\n\t\t\tif(b)c[i][j]='^',c[i+1][j]='v',b--;\n\t\t\tif(b)c[i][j+1]='^',c[i+1][j+1]='v',b--;\n\t\t}\n\t\tif(!a)flag=0;\n\t}\n\tprintf(\"YES\\n\");\n\tfor(int i=1;i<=n1;++i){\n\t\tfor(int j=1;j<=m1;++j)putchar(c[i][j]);\n\t\tcout<<endl;\n\t}\n}\n/*\n1000 1000 500000 500000\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nint f[305][305][305],n,k;\nchar s[305];\ninline int dfs(int l,int r,int k){\n  if (l==r) return 1; if (l>r) return 0;\n  if (f[l][r][k]) return f[l][r][k];\n  f[l][r][k]=std::max(dfs(l+1,r,k),dfs(l,r-1,k));\n  if (s[l]==s[r]) f[l][r][k]=std::max(f[l][r][k],dfs(l+1,r-1,k)+2);\n  else if (k) f[l][r][k]=std::max(f[l][r][k],dfs(l+1,r-1,k-1)+2);\n  return f[l][r][k];\n}\nint main(){\n  std::cin>>s>>k,n=strlen(s);\n  std::cout<<dfs(0,n-1,k); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 330;\n\ninline void smax(int &x, int y) { if (x < y) x = y; }\n\nint dp[N][N][N];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  string s;\n  cin >> s;\n  int k;\n  cin >> k;\n  int n = (int) s.size();\n  for (int i = 1; i <= n; i++) {\n    dp[i][i][0] = 1;\n    if (i < n && s[i - 1] == s[i]) {\n      dp[i][i + 1][0] = 2;\n    } else if (i < n) {\n      dp[i][i + 1][1] = 2;\n    }\n  }\n  for (int i = n; i >= 1; i--) {\n    for (int j = i + 1; j <= n; j++) {\n      for (int r = 0; r <= k; r++) {\n        smax(dp[i][j][r], dp[i + 1][j][r]);\n        smax(dp[i][j][r], dp[i][j - 1][r]);\n        smax(dp[i][j][r], dp[i][j][r - 1]);\n        if (s[i - 1] == s[j - 1]) {\n          smax(dp[i][j][r], dp[i + 1][j - 1][r] + 2);\n        } else if (r > 0) {\n          smax(dp[i][j][r], dp[i + 1][j - 1][r - 1] + 2);\n        }\n      }\n    }\n  }\n  cout << dp[1][n][k] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define int long long\n#define mp make_pair\n#define inf 998244353\n#define LINF 1000000000000000007LL\n#define ll long long\nusing namespace std;\nint dp[310][310][310]; \nstring s;\nint calc( int lef, int rig, int k){\n\tif( dp[lef][rig][k] != 0){\n\t\treturn dp[lef][rig][k];\n\t}\n\tif( lef == rig ){\n\t\treturn 1;\n\t}\n\tif( lef > rig ){\n\t\treturn 0;\n\t}\n\telse{\n\t\tif( s[lef] == s[rig] ){\n\t\t\tdp[lef][rig][k] = calc( lef+1, rig -1, k ) + 2;\n\t\t\treturn dp[lef][rig][k];\n\t\t}\n\t\telse{\n\t\t\tint c1 = -1;\n\t\t\tif( k > 0 ) c1 = calc( lef+1, rig-1, k-1) + 2;\n\t\t\tint c2 = calc( lef+1, rig, k);\n\t\t\tint c3 = calc( lef, rig-1, k);\n\t\t\tdp[lef][rig][k] = max( c1, max(c2,c3) );\n\t\t\treturn dp[lef][rig][k];\n\t\t}\n\t}\n}\nsigned main(){\n\tint k;\n\tcin >> s;\n\tcin >> k;\n\tint n = s.size();\n\tint ans = calc( 0, n-1, k );\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long int int64;\n\n\nconst int N = 305;\nchar str[N];\n\nint dp[N][N][N];\nint ans;\n\nvoid upd(int &a, int b)\n{\n    a = max(a, b);\n    ans = max(ans, b);\n}\n\n\nint main(int,  char **)\n{\n#ifdef LOCAL\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n    int k;\n    scanf(\"%s\", str + 1);\n    scanf(\"%d\", &k);\n    int n = strlen(str + 1);\n\n    for (int i = 1; i <= n; i++)\n        for (int j = n; j >= i; j--)\n            for (int h = 0; h <= k; h++)\n            {\n                int cur = dp[i][j][h];\n                upd(dp[i + 1][j][h], cur);\n                upd(dp[i][j - 1][h], cur);\n                if (str[i] == str[j] )\n                {\n                    if (i == j) upd(dp[i + 1][j - 1][h], cur + 1);\n                    else upd(dp[i + 1][j - 1][h], cur + 2);\n                }\n                else if (h < k)\n                {\n                    if (i == j) upd(dp[i + 1][j - 1][h + 1], cur + 1);\n                    else upd(dp[i + 1][j + 1][h + 1], cur + 2);\n                }\n            }\n    printf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nint dp[400][400][400];\nsigned main(){\n\tstring s;int K;cin>>s>>K;\n\trep(i,s.size()){\n\t\tfor(int j=s.size()-1;j>i;j--){\n\t\t\trep(k,K+1){\n\t\t\t\tif(s[i]==s[j]){\n\t\t\t\t\tdp[i+1][j-1][k]=max(dp[i+1][j-1][k],dp[i][j][k]+1);\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tdp[i+1][j-1][k]=max(dp[i+1][j-1][k],dp[i][j][k]);\n\t\t\t\t\tdp[i+1][j][k]=max(dp[i+1][j][k],dp[i][j][k]);\n\t\t\t\t\tdp[i][j-1][k]=max(dp[i][j-1][k],dp[i][j][k]);\n\t\t\t\t\tif(k<K){\n\t\t\t\t\t\tdp[i+1][j-1][k+1]=max(dp[i+1][j-1][k+1],dp[i][j][k]+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint Max=0,id=0;\n\trep(i,s.size())rep(k,s.size())rep(j,K+1){\n\t\tif(Max<dp[i][k][j]){\n\t\t\tMax=dp[i][k][j];\n\t\t\tid=0;\n\t\t}\n\t\tif(Max==dp[i][k][j]){\n\t\t\tid=max(id,k-i+1);\n\t\t}\n\t}/*\n\tif(s.size()%2==1){\n\t\tcout<<Max*2+1<<endl;\n\t}\n\telse{\n\t\tif(Max*2!=s.size())cout<<Max*2+1<<endl;\n\t\telse cout<<Max*2<<endl;\n\t}\n\t//cout<<Max*2+2<<vendl;*/\n\tif(id)cout<<Max*2+1<<endl;\n\telse cout<<Max*2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n//\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//\nconstexpr ll MOD=1e9+7;\n//constexpr ll MOD=998244353;\n//constexpr ll MOD=10000000;\n//constexpr ll MOD=1e5;\nconstexpr ll MAX=3e6;\nconstexpr ll INF=(1ll<<60);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate<typename T>\nstruct Segment_tree{\n    ll N;\n    T mem;\n    vector<T> node;\n    Segment_tree(vector<T> &X,T m):mem(m){\n        ll sz=X.size();\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mem);\n        rep(i,0,sz) node[N-1+i]=X[i];\n        per(i,N-2,0){\n            node[i]=Compare(node[i*2+1],node[i*2+2]);\n        }\n    }\n    T Compare(T &A,T &B){\n        return std::max(A,B);\n    }\n    void update(ll X,T val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=Compare(node[X*2+1],node[X*2+2]);\n        }\n    }\n    T Query(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mem;\n        if(a<=l&&r<=b) return node[now];\n        auto vl=Query(a,b,now*2+1,l,(l+r)/2),vr=Query(a,b,now*2+2,(l+r)/2,r);\n        return Compare(vl,vr);\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,int a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nvoid comp(vi &A){\n    std::map<ll,ll> mem;\n    rep(i,0,A.size()) mem[A[i]]=0;\n    ll cnt=0;\n    for(auto &p:mem) p.second=cnt++;\n    rep(i,0,A.size()) A[i]=mem[A[i]];\n}\nll RLCS(string S){\n    string T=S;\n    reverse(ALL(T));\n    ll N=S.size();\n    vii dp(N+1,vi(N+1));\n    REP(i,0,N){\n        REP(j,0,N){\n            if(!i){\n                if(j) dp[i][j]=dp[i][j-1];\n            }\n            else if(!j){\n                dp[i][j]=dp[i-1][j];\n            }\n            else{\n                dp[i][j]=std::max(dp[i][j-1],dp[i-1][j]);\n                if(S[i-1]==T[j-1]) dp[i][j]=std::max(dp[i][j],dp[i-1][j-1]+1);\n            }\n        }\n    }\n    return dp[N][N];\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    string S; cin>>S;\n    ll K,N=S.size(); cin>>K;\n    assert(N<=150);\n    string T=S; reverse(ALL(T));\n    vector<vii> dp(N/2+1,vii(N/2+1,vi(K+1,INF)));\n    dp[0][0][0]=0;\n    vii mem(26);\n    rep(i,0,N/2) mem[T[i]-'a'].pb(i+1);\n    rep(i,0,N/2){\n        REP(j,0,N/2){\n            REP(k,0,K) dp[i+1][j][k]=dp[i][j][k];\n        }\n        rep(j,0,N/2){\n            REP(k,0,K){\n                if(dp[i][j][k]==INF) continue;\n                ll X=disup(mem[S[i]-'a'],dp[i][j][k]);\n                if(X<mem[S[i]-'a'].size()){\n                    ll Y=mem[S[i]-'a'][X];\n                    dp[i+1][j+1][k]=std::min(dp[i+1][j+1][k],Y);\n                }\n                if(dp[i][j][k]<N/2&&k<K){\n                    dp[i+1][j+1][k+1]=std::min(dp[i+1][j+1][k+1],dp[i][j][k]+1);\n                }\n            }\n        }\n    }\n    vii m(N,vi(N));\n    rep(i,0,N){\n        rep(j,i,N){\n            string P=S.substr(i,j-i+1);\n            m[i][j]=RLCS(P);\n        }\n    }\n    ll ans=0;\n    REP(i,0,N/2){\n        REP(j,0,N/2){\n            REP(k,0,K){\n                if(dp[i][j][k]!=INF){\n                    ll left=i,right=N-dp[i][j][k]-1;\n                    if(left<=right){\n                        ans=std::max(ans,j*2+m[left][right]);\n                    }\n                    else ans=std::max(ans,dp[i][j][k]*2);\n                }\n            }\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dp[300][300][300];\n\nstring reverse ( string s ) {\n  string res = \"\";\n  for ( int i = s.length() - 1 ; i >= 0 ; i-- )\n    res += s[i];\n  return res;\n}\n\nint main() {\n  \n  string s;\n  int k;\n  cin >> s;\n  cin >> k;\n  int n = s.length();\n  \n  string t = reverse ( s );\n  \n  int ans = 0;\n  \n  memset ( dp , 0 , sizeof dp );\n  \n  for ( int i = 1 ; i <= n ; i++ ) {\n    for ( int j = 1 ; j <= n ; j++ ) {\n      for ( int v = 0 ; v < k ; v++ ) {\n        if ( i < ( n + 1 ) - j ) {\n          \n          // if same \n          if ( s[i-1] == t[j-1] ) {\n            dp[i][j][v] = dp[i-1][j-1][v] + 2;\n          }\n          else {\n            dp[i][j][v] = max ( dp[i][j][v] , dp[i-1][j][v] );\n            dp[i][j][v] = max ( dp[i][j][v] , dp[i][j-1][v] );\n            dp[i][j][v] = max ( dp[i][j][v] , dp[i-1][j-1][v-1] + 2 );\n          }\n          \n          \n          \n        }\n        else if ( i == ( n + 1 ) - j ) {\n          dp[i][j][v] = dp[i-1][j-1][v] + 1;\n        }\n        \n        ans = max ( ans , dp[i][j][v] );\n      }\n    }\n  }\n  \n  cout << ans << endl;\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n \n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n \ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQR = priority_queue<T,vector<T>,greater<T>>;\n \nconstexpr long long MOD = (long long)1e9 + 7;\nconstexpr long long MOD2 = 998244353;\nconstexpr long long HIGHINF = (long long)1e18;\nconstexpr long long LOWINF = (long long)1e15;\nconstexpr long double PI = 3.1415926535897932384626433;\n \ntemplate <class T> vector<T> multivector(size_t N,T init){return vector<T>(N,init);}\ntemplate <class... T> auto multivector(size_t N,T... t){return vector<decltype(multivector(t...))>(N,multivector(t...));}\ntemplate <class T> void corner(bool flg, T hoge) {if (flg) {cout << hoge << endl; exit(0);}}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const map<T, U>&obj) {o << \"{\"; for (auto &x : obj) o << \" {\" << x.first << \" : \" << x.second << \"}\" << \",\"; o << \" }\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const set<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const multiset<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&obj) {o << \"{\"; for (int i = 0; i < (int)obj.size(); ++i)o << (i > 0 ? \", \" : \"\") << obj[i]; o << \"}\"; return o;}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const pair<T, U>&obj) {o << \"{\" << obj.first << \", \" << obj.second << \"}\"; return o;}\nvoid print(void) {cout << endl;}\ntemplate <class Head> void print(Head&& head) {cout << head;print();}\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) {cout << head << \" \";print(forward<Tail>(tail)...);}\ntemplate <class T> void chmax(T& a, const T b){a=max(a,b);}\ntemplate <class T> void chmin(T& a, const T b){a=min(a,b);}\nvoid YN(bool flg) {cout << (flg ? \"YES\" : \"NO\") << endl;}\nvoid Yn(bool flg) {cout << (flg ? \"Yes\" : \"No\") << endl;}\nvoid yn(bool flg) {cout << (flg ? \"yes\" : \"no\") << endl;}\n\n\nint main() {\n\tstring S; cin >> S;\n\tint N = S.size();\n\tint K; cin >> K;\n\tauto R = multivector(N, 26,-1);\n\tauto L = multivector(N, 26,-1);\n\tvector<int> cnt(26,-1);\n\tfor(int i = 0; i < N; ++i) {\n\t\tL[i] = cnt;\n\t\tcnt[S[i]-'a'] = i;\n\t}\n\tfor(int a = 0; a < 26; ++a){\n\t\tcnt[a] = -1;\n\t}\n\tfor(int i = N-1; 0 <= i; --i) {\n\t\tR[i] = cnt;\n\t\tcnt[S[i]-'a'] = i;\n\t}\n\tauto dp = multivector(K+2,N,N,0);\n\tfor(int i = 0; i < N; ++i) {\n\t\tfor(int k = 0; k <= K; ++k) {\n\t\t\tdp[k][i][i] = 1;\n\t\t}\n\t}\n\tfor(int i = 0; i+1 < N; ++i) {\n\t\tfor(int k = 0; k <= K; ++k) {\n\t\t\tif(S[i]==S[i+1]) dp[k][i][i+1] = 2;\n\t\t\telse dp[k][i][i+1] = (k?2:0);\n\t\t}\n\t}\n\tfor(int i = 0; i < N; ++i) {\n\t\tfor(int j = 0; j + i < N; ++j){\n\t\t\tint l = j, r = j + i;\n\t\t\tfor(int k = 0; k <= K; ++k) {\n\t\t\t\t//コストが発生しないとき\n\t\t\t\tfor(int a = 0; a < 26; ++a){\n\t\t\t\t\tint x = L[l][a],y = R[r][a];\n\t\t\t\t\tif(x==-1||y==-1) continue;\n\t\t\t\t\tchmax(dp[k][x][y],dp[k][l][r]+2);\n\t\t\t\t}\n\t\t\t\t//コストが発生するとき\n\t\t\t\tif(0<=l-1&&r+1<N) chmax(dp[k+1][l-1][r+1],dp[k][l][r]+2);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i < N; ++i) {\n\t\tfor(int j = 0; j < N; ++j){\n\t\t\tfor(int k = 0; k <= K; ++k) {\n\t\t\t\tchmax(ans,dp[k][i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nstatic const int IINF = 1 << 30;\n\ntemplate <typename T> std::vector<T> vectors(std::size_t n, T val) {\n  return std::vector<T>(n, val);\n}\n\ntemplate <typename T, typename... Args>\nauto vectors(std::size_t n, Args... args) {\n  return std::vector<decltype(vectors<T>(args...))>(n, vectors<T>(args...));\n}\n\ntemplate <class T> inline bool chmax(T &a, const T &b) {\n  return (a < b) ? a = b, true : false;\n}\n\nint main() {\n  // Input\n  std::string S;\n  int K;\n  int N;\n  std::cin >> S;\n  std::cin >> K;\n  N = S.length();\n\n  // Initialization\n  auto dp = vectors<int>(1 + N + 1, 1 + N + 1, 1 + K + 1, -IINF);\n\n  // Initial condition\n  dp[0][0][0] = 0;\n\n  // DP main\n  for (int i = 0; i <= N; ++i) {\n    for (int j = 0; j <= N; ++j) {\n      for (int k = 0; k <= K; ++k) {\n        chmax(dp[i + 1][j][k], dp[i][j][k]);\n        chmax(dp[i][j + 1][k], dp[i][j][k]);\n        // chmax(dp[i + 1][j][k + 1], dp[i][j][k] + 1);\n        // chmax(dp[i][j + 1][k + 1], dp[i][j][k] + 1);\n        chmax(dp[i + 1][j + 1][k + 1], dp[i][j][k] + 1);\n        if (i < N and k < N and S[i] == S[N - j - 1])\n          chmax(dp[i + 1][j + 1][k], dp[i][j][k] + 1);\n      }\n    }\n  }\n\n  // Output\n  int res = -1;\n  for (int k = 0; k <= K; ++k) {\n    for (int i = 0; i <= N; ++i)\n      chmax(res, 2 * dp[i][N - i][K]);\n    for (int i = 0; i < N; ++i)\n      chmax(res, 2 * dp[i][N - i - 1][K] + 1);\n  }\n\n  std::cout << res << std::endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\n#define MOD 1000000007\n#define MOD2 998244353\n#define int long long\n#define double long double\n#define EPS 1e-9\n//#define PI 3.14159265358979\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nusing namespace std;\n\ntemplate < typename T >\nostream &operator<<(ostream &os, const vector< T > &A) {\n\tfor (int i = 0; i < A.size(); i++)\n\t\tos << A[i] << \" \";\n\tos << endl;\n\treturn os;\n}\ntemplate <>\nostream &operator<<(ostream &os, const vector< vector< int > > &A) {\n\tint N = A.size();\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < A[i].size(); j++)\n\t\t\tos << A[i][j] << \" \";\n\t\tos << endl;\n\t}\n\treturn os;\n}\ntemplate < typename T, typename U >\nostream &operator<<(ostream &os, const pair< T, U > &p) {\n\tos << \"(\" << p.first << \",\" << p.second << \")\";\n\treturn os;\n}\ntemplate < typename T, typename U >\nistream &operator>>(istream &is, pair< T, U > &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate < typename T >\nistream &operator>>(istream &is, vector< T > &A) {\n\trep(i, A.size()) is >> A[i];\n\treturn is;\n}\n\ntypedef pair< int, int > pii;\ntypedef long long ll;\n\nstruct edge {\n\tint from, to, d, c, i;\n\tedge(int _from = 0, int _to = 0, int _d = 0, int _c = 0) {\n\t\tfrom = _from;\n\t\tto = _to;\n\t\td = _d;\n\t\tc = _c;\n\t}\n\tbool operator<(const edge &rhs) const {\n\t\treturn (d == rhs.d) ? (c < rhs.c) : (d < rhs.d);\n\t}\n};\nstruct aabb {\n\tint x1, y1, x2, y2;\n\taabb(int x1, int y1, int x2, int y2) : x1(x1), y1(y1), x2(x2), y2(y2) {}\n};\n\ntypedef vector< edge > edges;\ntypedef vector< edges > graph;\nstruct flow {\n\tint to, cap, rev, cost;\n\tflow(int to = 0, int cap = 0, int rev = 0, int cost = 0) : to(to), cap(cap), rev(rev), cost(cost) {}\n};\ntypedef vector< vector< flow > > flows;\n\nconst int di[4] = {0, -1, 0, 1};\nconst int dj[4] = {-1, 0, 1, 0};\nconst int ci[5] = {0, 0, -1, 0, 1};\nconst int cj[5] = {0, -1, 0, 1, 0};\nconst ll LINF = LLONG_MAX / 2;\nconst int INF = INT_MAX / 2;\nconst double PI = acos(-1);\n\nint pow2(int n) { return 1LL << n; }\ntemplate < typename T, typename U >\nbool chmin(T &x, const U &y) {\n\tif (x > y) {\n\t\tx = y;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate < typename T, typename U >\nbool chmax(T &x, const U &y) {\n\tif (x < y) {\n\t\tx = y;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\ntemplate < typename A, size_t N, typename T >\nvoid Fill(A (&array)[N], const T &val) {\n\tfill((T *)array, (T *)(array + N), val);\n}\nstruct initializer {\n\tinitializer() {\n\t\tcout << fixed << setprecision(20);\n\t}\n};\ninitializer _____;\n\nint N, M, K, T, Q, H, W;\nsigned main() {\n\tstatic int dp[301][301][301][2][2];\n\tstring S;\n\tcin >> S >> K;\n\tcout << dp[1][1][1][1][1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n//typedef vector<vector<ll>> Graph;\n\nconst ll mod = 1e9 + 7;\n//const ll mod = 998244353;\n\n#define REP(i,n) for(ll i=0;i<(ll)n;i++)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define spa << \" \" <<\n#define fi first\n#define se second\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){\nos << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<T> v){\nfor(int i = 0; i < (int)v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<vector<T>> v){\nfor(int i = 0; i < (int)v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\n\ntemplate<typename T> void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cerr<<v[i][0];for(ll j=1;j<w;j++)cerr spa v[i][j];cerr<<endl;}};\ntemplate<typename T> void debug(vector<T>&v,ll n){if(n!=0)cerr<<v[0];\nfor(ll i=1;i<n;i++)cerr spa v[i];\ncerr<<endl;};\n\nstring num2bit(ll num, ll len){\n    string bit = \"\";\n    REP(i, len){\n    bit += char('0'+(num>>i & 1));\n    }\n    return bit;\n}\n\nll dp[303][303][303];\nstring S;\nll K;\n\nll rec(ll l, ll r, ll k){\n    if(dp[l][r][k]>=0) return dp[l][r][k];\n    if(l+1 == r) return 1;\n    if(l >= r) return 0;\n    ll res = 0;\n    if(S[l] != S[r-1]){\n        chmax(res, rec(l, r-1, k));\n        chmax(res, rec(l+1, r, k));\n        if(k>0) chmax(res, rec(l+1, r-1, k-1)+2);\n    }else{\n        chmax(res, rec(l+1, r-1, k)+2);\n    }\n    dp[l][r][k] = res;\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> S >> K;\n    ll N = S.size();\n    \n    REP(i, 303)REP(j, 303)REP(k, 303) dp[i][j][k] = -1;\n\n    ll res = 0;\n    REP(i, K+1){\n        chmax(res, rec(0, N, i));\n    }\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=int64_t;\n//#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DMP(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\t#ifdef int\n\tscanf(\"%\" SCNd64,&i);\n\t#else\n\tscanf(\"%d\",&i);\n\t#endif\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(int x,int suc=1){\n\t#ifdef int\n\tprintf(\"%\" PRId64,x);\n\t#else\n\tprintf(\"%d\",x);\n\t#endif\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\n#ifdef int\nconst int inf=LLONG_MAX/3;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nconst int Nmax=310;\nint dp[Nmax][Nmax][Nmax];\n\nsigned main(){\n\tstring s=readString();\n\tint n=s.size(),k=read();\n\tREP(i,n)dp[i][i+1][0]=1;\n\tFOR(len,2,n+1)REP(b,n-len+1){\n\t\tint e=b+len;\n\t\tREP(x,k+1)dp[b][e][x]=max(dp[b+1][e][x],dp[b][e-1][x]);\n\t\tif(s[b]==s[e-1]){\n\t\t\tREP(x,k+1)chmax(dp[b][e][x],dp[b+1][e-1][x]+2);\n\t\t}else{\n\t\t\tFOR(x,1,k+1)chmax(dp[b][e][x],dp[b+1][e-1][x-1]+2);\n\t\t}\n\t}\n\tint ans=0;\n\tREP(x,k+1)chmax(ans,dp[0][n][x]);\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\t\n#include <time.h>\n#include <vector>\n#include <stdio.h>\n#include <memory.h>\n#include <string>\n#include <string.h>\n#include <map>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <time.h>\n#include <assert.h>\n#include <sstream>\n//#include <unordered_map>\n#include <bitset>\n#include <utility>\n#include <iomanip>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <numeric>\n#include <math.h>\n#include <cmath>\n#include <complex>\n#ifdef MYDEF\n#include \"inc.h\"\n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef complex<double> point;\n\nint n, k;\nchar s[330], r[330];\nint dp[330][330];\nint calc(int i, int j) {\n\tif(i == n)\n\t\treturn 0;\n\tif(j == n)\n\t\treturn 0;\n\tint &ret = dp[i][j];\n\tif(~ret)\n\t\treturn ret;\n\tret = calc(i + 1, j);\n\tret = max(ret, calc(i, j + 1));\n\tif(s[i] == r[j])\n\t\tret = max(ret, 1 + calc(i + 1, j + 1));\n\treturn ret;\n}\nstring ans;\nint last = -1;\nvoid path(int i, int j) {\n\tif(i == n || j == n)\n\t\treturn;\n\tint op = calc(i, j);\n\tif(op == calc(i + 1, j)) {\n\t\tif(k)\n\t\t\tans += s[i], ans += s[i], --k;\n\t\tpath(i + 1, j);\n\t}\n\telse if(op == calc(i, j + 1)) {\n\t\tif(k)\n\t\t\tans += s[i], ans += s[i], --k;\n\t\tpath(i, j + 1);\n\t}\n\telse {\n\t\tans += s[i];\n\t\tpath(i + 1, j + 1);\n\t}\n}\n\nint main() {\n#ifdef MYDEF\n\t// sandstone\n\tHEAD\n\t\tfreopen(\"a.txt\", \"r\", stdin);\n\t//freopen(\"a.txt\", \"w\", stdout);\n\tdecTime;\n#endif\n\n\tscanf(\"%s%d\", s, &k);\n\tn = strlen(s);\n\tfor(int i = n - 1; i >= 0; --i)\n\t\tr[n - i - 1] = s[i];\n\tmemset(dp, -1, sizeof dp);\n\tcalc(0, 0);\n\tpath(0, 0);\n\tprintf(\"%d\\n\", ans.size());\n\n\n#ifdef MYDEF\n\tprintTime;\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nchar str[305];\nint dp[305][305][305],K;\nint max(int a,int b){return a>b?a:b;}\nint main(){\n\tscanf(\"%s%d\",str,&K); int lens=strlen(str);\n\tfor(int i=0;i<lens;++i)\n\t\tfor(int k=0;k<=K;++k)\n\t\t\tdp[i][i][k]=1;\n\tfor(int l=1;l<lens;++l)\n\t\tfor(int i=0;i+l<lens;++i){\n\t\t\tint j=i+l;\n\t\t\tfor(int k=0;k<=K;++k){\n\t\t\t\tdp[i][j][k]=max(dp[i+1][j][k],dp[i][j-1][k]);\n\t\t\t\tif(k>0) dp[i][j][k]=max(dp[i+1][j-1][k-1]+2,dp[i][j][k]);\n\t\t\t\tif(str[i]==str[j]) dp[i][j][k]=max(dp[i+1][j-1][k]+2,dp[i][j][k]);\n\t        }\n\t    }\n\tprintf(\"%d\\n\",dp[0][lens-1][K]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nint dp[400][400][400];\nsigned main(){\n\tstring s;int K;cin>>s>>K;\n\trep(i,s.size()){\n\t\tfor(int j=s.size()-1;j>i;j--){\n\t\t\trep(k,K+1){\n\t\t\t\tif(s[i]==s[j]){\n\t\t\t\t\tdp[i+1][j-1][k]=max(dp[i+1][j-1][k],dp[i][j][k]+1);\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tdp[i+1][j-1][k]=max(dp[i+1][j-1][k],dp[i][j][k]);\n\t\t\t\t\tdp[i+1][j][k]=max(dp[i+1][j][k],dp[i][j][k]);\n\t\t\t\t\tdp[i][j-1][k]=max(dp[i][j-1][k],dp[i][j][k]);\n\t\t\t\t\tif(k<K){\n\t\t\t\t\t\tdp[i+1][j-1][k+1]=max(dp[i+1][j-1][k+1],dp[i][j][k]+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint Max=0;\n\trep(i,s.size())rep(j,K+1){\n\t\tMax=max(Max,dp[i][i][j]);\n\t}\n\tcout<<Max*2+2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n\t#include <boost/multiprecision/cpp_int.hpp>\n\t#include <boost/multiprecision/cpp_dec_float.hpp>\n\tusing bll = boost::multiprecision::cpp_int;\n\tusing bdouble = boost::multiprecision::cpp_dec_float_100;\n#endif\n#ifdef LOCAL_DEV\n\tvoid debug_impl() { std::cerr << '\\n'; }\n\ttemplate<typename Head, typename... Tail> void debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head << (sizeof...(tail) ? \",\" : \"\"); debug_impl(tail...); }\n\t#define debug(...) do { std::cerr << \"(\" << #__VA_ARGS__ << \") =\"; debug_impl(__VA_ARGS__); } while (false)\n#else\n\t#define debug(...) do {} while (false)\n#endif\n#ifdef LOCAL_TEST\n\t#define BOOST_STACKTRACE_USE_ADDR2LINE\n\t#define BOOST_STACKTRACE_ADDR2LINE_LOCATION /usr/local/opt/binutils/bin/addr2line\n\t#define _GNU_SOURCE\n\t#include <boost/stacktrace.hpp>\n\tnamespace std {\n\t\ttemplate<typename T> class dvector : public std::vector<T> {\n\t\tpublic:\n\t\t\tdvector() : std::vector<T>() {}\n\t\t\texplicit dvector(size_t n, const T& value = T()) : std::vector<T>(n, value) {}\n\t\t\tdvector(const std::vector<T>& v) : std::vector<T>(v) {}\n\t\t\tdvector(const std::initializer_list<T> il) : std::vector<T>(il) {}\n\t\t\tdvector(const typename std::vector<T>::iterator first, const typename std::vector<T>::iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const std::string::iterator first, const std::string::iterator last) : std::vector<T>(first, last) {}\n\t\t\tT& operator[](size_t n) {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst T& operator[](size_t n) const {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\tclass dbool {\n\tprivate:\n\t\tbool boolvalue;\n\tpublic:\n\t\tdbool() : boolvalue(false) {}\n\t\tdbool(bool b) : boolvalue(b) {}\n\t\tdbool(const dbool& b) : boolvalue(b.boolvalue) {}\n\t\toperator bool&() { return boolvalue; }\n\t\toperator const bool&() const { return boolvalue; }\n\t};\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::dvector<T>& v) {\n\t\tfor (size_t i = 0; i < v.size(); ++i){ s << v[i]; if (i < v.size() - 1) s << \"\\t\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::dvector<std::dvector<T>>& vv) {\n\t\ts << \"\\n\"; for (size_t i = 0; i < vv.size(); ++i){ s << vv[i] << \"\\n\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::set<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::multiset<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate <typename T, size_t N> std::ostream& operator<<(std::ostream& s, const std::array<T, N>& a) {\n\t\ts << \"{ \"; for (size_t i = 0; i < N; ++i){ s << a[i] << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::map<T1, T2>& m) {\n\t\ts << \"{\\n\"; for (auto itr = m.begin(); itr != m.end(); ++itr){ s << \"\\t\" << (*itr).first << \" : \" << (*itr).second << \"\\n\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::pair<T1, T2>& p) {\n\t\treturn s << \"(\" << p.first << \", \" << p.second << \")\"; }\n\t#define vector dvector\n\t#define bool dbool\n\tclass SIGFPE_exception : std::exception {};\n\tclass SIGSEGV_exception : std::exception {};\n\tvoid catch_SIGFPE(int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGFPE_exception();\t}\n\tvoid catch_SIGSEGV(int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGSEGV_exception(); }\n\tsigned convertedmain();\n\tsigned main() { signal(SIGFPE, catch_SIGFPE); signal(SIGSEGV, catch_SIGSEGV); return convertedmain(); }\n\t#define main() convertedmain()\n#endif\n//#define int long long\nusing ll = long long;\n//constexpr int INF = 1e9;//INT_MAX=(1<<31)-1=2147483647\nconstexpr ll INF = (ll)1e18;//(1LL<<63)-1=9223372036854775807\nconstexpr ll MOD = 998244353;//(ll)1e9 + 7;\nconstexpr double EPS = 1e-9;\nconstexpr ll dx[4] = {1LL, 0LL, -1LL, 0LL};\nconstexpr ll dy[4] = {0LL, 1LL, 0LL, -1LL};\nconstexpr ll dx8[8] = {1LL, 0LL, -1LL, 0LL, 1LL, 1LL, -1LL, -1LL};\nconstexpr ll dy8[8] = {0LL, 1LL, 0LL, -1LL, 1LL, -1LL, 1LL, -1LL};\n#define rep(i, n)   for(ll i=0, i##_length=(n); i< i##_length; ++i)\n#define repeq(i, n) for(ll i=1, i##_length=(n); i<=i##_length; ++i)\n#define rrep(i, n)   for(ll i=(n)-1; i>=0; --i)\n#define rrepeq(i, n) for(ll i=(n)  ; i>=1; --i)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\nvoid p() { std::cout << '\\n'; }\ntemplate<typename Head, typename... Tail> void p(Head head, Tail... tail) { std::cout << head << (sizeof...(tail) ? \" \" : \"\"); p(tail...); }\ntemplate<typename T> inline void pv(std::vector<T>& v) { for(ll i=0, N=v.size(); i<N; i++) std::cout << v[i] << \" \\n\"[i==N-1]; }\ntemplate<typename T> inline T gcd(T a, T b) { return b ? gcd(b,a%b) : a; }\ntemplate<typename T> inline T lcm(T a, T b) { return a / gcd(a,  b) * b; }\ntemplate<typename T> inline bool chmax(T& a, T b) { return a < b && (a = b, true); }\ntemplate<typename T> inline bool chmin(T& a, T b) { return a > b && (a = b, true); }\ntemplate<typename T> inline void uniq(std::vector<T>& v) { v.erase(std::unique(v.begin(), v.end()), v.end()); }\n\n/*-----8<-----template-----8<-----*/\nnamespace makevectordetail {\n\ttemplate <typename Tp, size_t N>\n\tstd::vector<Tp> make_vector(\n\t\t\tstd::vector<size_t>& sizes,\n\t\t\ttypename std::enable_if<(N == 1), Tp const&>::type x\n\t) {\n\t\treturn std::vector<Tp>(sizes[0], x);\n\t}\n\ttemplate <typename Tp, size_t N>\n\tauto make_vector(\n\t\t\tstd::vector<size_t>& sizes,\n\t\t\ttypename std::enable_if<(N > 1), Tp const&>::type x\n\t) {\n\t\tsize_t size = sizes[N-1];\n\t\tsizes.pop_back();\n\t\treturn std::vector<decltype(make_vector<Tp, N-1>(sizes, x))>(\n\t\t\t\tsize, make_vector<Tp, N-1>(sizes, x)\n\t\t);\n\t}\n}\ntemplate <typename Tp, typename sizetype, size_t N>\nauto make_vector(sizetype const(&sizes)[N], Tp const& x = Tp()) {\n\tstd::vector<size_t> s(N);\n\tfor (size_t i = 0; i < N; ++i) s[i] = sizes[N-i-1];\n\treturn makevectordetail::make_vector<Tp, N>(s, x);\n}\n//vector<vector<vector<ll>>> v = make_vector<ll>({1, 2, 3}, 0LL);\n/*-----8<-----library-----8<-----*/\n\nstring S;ll K;\nvector<vector<vector<ll>>> dp;\nll f(ll l,ll r,ll k){\n\tif(dp[l][r][k])return dp[l][r][k];\n\t//0文字\n\tif(l==r)return 1;\n\t//1文字\n\tif(r-l==1){\n\t\tif(S[l]==S[r])return 2;\n\t\treturn 1;\n\t}\n\n\tll ans=0;\n\tchmax(ans, f(l+1,r,k));\n\tchmax(ans, f(l,r-1,k));\n\tif(S[l]==S[r])chmax(ans,f(l+1,r-1,k)+2);\n\telse if(k<K)chmax(ans,f(l+1,r-1,k+1)+2);\n\n\treturn ans;\n}\n\nvoid solve() {\n\t\n\tcin>>S>>K;\n\tdp = make_vector<ll>({S.size()+1, S.size()+1, (size_t)K+1}, 0);\n\n\tll ans=f(0,S.size()-1,0);\n\tp(ans);\n}\n\nsigned main() {\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nint dp[310][310][310];\nint d2[310][310][310];\nstring s;\nint cal(int x,int y,int z){\n\tif(d2[x][y][z]>=0) return d2[x][y][z];\n\tif(x==y) return d2[x][y][z]=1;\n\tif(x>y) return d2[x][y][z]=0;\n\tint ret=0;\n\tif(s[x]==s[y]) ret=max(ret,cal(x+1,y-1,z)+2);\n\tif(z>0) ret=max(ret,cal(x+1,y-1,z-1)+2);\n\tret=max(ret,cal(x+1,y,z));ret=max(ret,cal(x,y-1,z));\n\treturn d2[x][y][z]=ret;\n}\nint main()\n{\n\tint K,n,out;\n\tcin>>s;n=s.size();cin>>K;\n\tmemset(dp,0,sizeof(dp));\n\trep(i,n+1) rep(j,n+1) rep(k,K+1){\n\t\t//cout<<i<<' '<<j<<' '<<k<<' '<<dp[i][j][k]<<endl;\n\t\tif(i<n/2) dp[i+1][j][k]=max(dp[i+1][j][k],dp[i][j][k]);\n\t\tif(j<n/2) dp[i][j+1][k]=max(dp[i][j+1][k],dp[i][j][k]);\n\t\tif(i<n/2 && j<n/2){\n\t\t\tif(s[i]==s[n-1-j]) dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+1);\n\t\t\telse dp[i+1][j+1][k+1]=max(dp[i+1][j+1][k+1],dp[i][j][k]+1);\n\t\t}\n\t}\n\t\n\tmemset(d2,-1,sizeof(d2));\n\t//cal(0,n-1);\n\t\n\t//cout<<dp[6][9][3]<<' '<<cal(6,9)<<endl;\n\trep(i,n+1) rep(j,n+1) rep(k,K+1){\n\t\tif(i+j>n) continue;\n\t\tout=max(out,dp[i][j][k]*2+cal(i,n-j-1,K-k));\n\t}\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\nint dp[300][300][301];\nint n, k;\nstring s;\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> s >> k;\n  n = s.size();\n  const int inf = 300;\n  for(int i = 0; i < n; i++) for(int p = 0; p <= k; p++) dp[i][i][p] = 1;\n  for(int w = 2; w <= n; w++) {\n    for(int l = 0; l + w - 1 < n; l++) {\n      int r = l + w - 1;\n      for(int p = 0; p <= k; p++) {\n        dp[l][r][p] = max({\n            dp[l+1][r][p],\n            dp[l][r-1][p],\n            s[l] == s[r] ? dp[l+1][r-1][p] + 2 : -inf,\n            p < k ? dp[l+1][r-1][p+1] + 2 : -inf,\n            });\n      }\n    }\n  }\n  cout << dp[0][n-1][0] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcount\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define Time (double)clock()/CLOCKS_PER_SEC\nconst int N = 307;\nint n, k, dp[N][N][N];\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n    string s; cin >> s; n = s.size(); cin >> k;\n    for (int i = 1; i <= n; ++i) dp[i][i][0] = 1;\n    for (int len = 2; len <= n; ++len) \n        for (int l = 1; l + len - 1 <= n; ++l) {\n            int r = l + len - 1;\n            for (int u = 0; u <= k; ++u) dp[l][r][u] = max(dp[l + 1][r][u], dp[l][r - 1][u]);\n            if (s[l - 1] == s[r - 1]) for (int u = 0; u <= k; ++u) dp[l][r][u] = max(dp[l][r][u], dp[l + 1][r - 1][u] + 2);\n            else for (int u = 1; u <= k; ++u) dp[l][r][u] = max(dp[l][r][u], dp[l + 1][r - 1][u - 1] + 2);\n            //for (int u = 0; u <= k; ++u) cout << l << ' ' << r << ' ' << u << \" : \" << dp[l][r][u] << '\\n';\n        }   \n    int ans = 0;\n    for (int i = 0; i < N; ++i) ans = max(ans, dp[1][n][i]);\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "//84104971101048411497 - Can you guess what does this mean?\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n#define mapii map<int, int>\n#define debug(a) cout << #a << \": \" << a << endl\n#define debuga1(a, l, r) fto(i, l, r) cout << a[i] << \" \"; cout << endl\n#define fdto(i, r, l) for(int i = (r); i >= (l); --i)\n#define fto(i, l, r) for(int i = (l); i <= (r); ++i)\n#define forit(it, var) for(__typeof(var.begin()) it = var.begin(); it != var.end(); it++)\n#define forrit(rit, var) for(__typeof(var.rbegin()) rit = var.rbegin(); rit != var.rend(); rit++)\n#define ii pair<int, int>\n#define iii pair<int, ii>\n#define ff first\n#define ss second\n#define mp make_pair\n#define pb push_back\n#define maxN 305\n#define oo 1000000007\n#define MOD 1000000007\n#define sz(a) (int)a.size()\n\nconst double PI = acos(-1.0);\n\ndouble fRand(double fMin, double fMax)\n{\n    double f = (double)rand() / RAND_MAX;\n    return fMin + f * (fMax - fMin);\n}\n\ntemplate <class T>\nT min(T a, T b, T c) {\n    return min(a, min(b, c));\n}\n\ntemplate <class T>\nT max(T a, T b, T c) {\n    return max(a, max(b, c));\n}\n\nstring s;\nint n, k, dp[maxN][maxN][maxN];\n\nint Solve(int i, int j, int k) {\n    if (k < 0) return -oo;\n    if (i > j) return 0;\n    if (i == j) return 1;\n    if (dp[i][j][k] != -1) return dp[i][j][k];\n\n    int res;\n    if (s[i] == s[j]) res = Solve(i+1, j-1, k)+2;\n    else res = max(Solve(i+1, j-1, k-1)+2, Solve(i+1, j, k), Solve(i, j-1, k));\n\n    return dp[i][j][k] = res;\n}\n\nint main () {\n    cin >> s;\n    n = s.length();\n    scanf(\"%d\", &k);\n\n    fto(i, 0, n-1) fto(j, 0, n-1) fto(k, 0, n-1) dp[i][j][k] = -1;\n\n    cout << Solve(0, n-1, k);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define int long long\n#define REP(i, n) for (int i = 0; i < (int)n; ++i)\n#define RREP(i, n) for (int i = (int)n - 1; i >= 0; --i)\n#define FOR(i, s, n) for (int i = s; i < (int)n; ++i)\n#define RFOR(i, s, n) for (int i = (int)n - 1; i >= s; --i)\n#define ALL(a) a.begin(), a.end()\n#define IN(a, x, b) (a <= x && x < b)\ntemplate<class T>istream&operator >>(istream&is,vector<T>&vec){for(T&x:vec)is>>x;return is;}\ntemplate<class T>inline void out(T t){cout << t << \"\\n\";}\ntemplate<class T,class... Ts>inline void out(T t,Ts... ts){cout << t << \" \";out(ts...);}\ntemplate<class T>inline bool CHMIN(T&a,T b){if(a > b){a = b;return true;}return false;}\ntemplate<class T>inline bool CHMAX(T&a,T b){if(a < b){a = b;return true;}return false;}\nconstexpr int INF = 1e18;\n\nint dp[303][303][303];\n\nsigned main(){\n\tstring s;\n\tint K;\n\tcin >> s >> K;\n\tint N = s.size();\n\tREP(i, N) {\n\t\tREP(j, N) {\n\t\t\tif(i > N - j - 1) continue;\n\t\t\tREP(k, N) {\n\t\t\t\tCHMAX(dp[i + 1][j][k], dp[i][j][k]);\n\t\t\t\tCHMAX(dp[i][j + 1][k], dp[i][j][k]);\n\t\t\t\tCHMAX(dp[i + 1][j + 1][k + (s[i] != s[N - j - 1])], dp[i][j][k] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tREP(i, N) REP(j, N) REP(k, K + 1) CHMAX(ans, dp[i][j][k] * 2 - (i + j != N));\n\tout(ans);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n* C++11 code template for contests.\n* @author: Andrei Kalendarov\n* @e-mail: andreykalendarov@gmail.com\n*/\n\n//#define ANDREIKKAA_ALLOCATOR\nconst int _ML = 250;\n\nconst char _inpf[] =\n#if defined(ANDREIKKAA)\n        \"input.txt\"\n#else\n\"\"\n#endif\n;\nconst char _outf[] =\n#if defined(ANDREIKKAA)\n        \"\"\n#else\n\"\"\n#endif\n;\n\n#if defined(ANDREIKKAA)\n#undef NDEBUG\n#else\n#pragma GCC optimize(\"O3,no-stack-protector\")\n#endif\n#include <bits/stdc++.h>\n#if !defined(ANDREIKKAA)\n#define endl '\\n'\n#endif\n#define x first\n#define y second\nusing namespace std;\n#define rand abcdefghijklmnopqrstuvwxyz\n#define random_shuffle abcdefghijklmnopqrstuvwxyz\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef long double ld;\nconst ld PI = 3.14159265358979323846;\nmt19937 rd(228);\n#if defined(ANDREIKKAA_ALLOCATOR)\nchar _mem[_ML * 1024 * 1024];\nsize_t _ptr = 0;\ninline void* operator new (size_t _x) { _ptr += _x; assert(_ptr < _ML * 1024 * 1024); return _mem + _ptr - _x; }\ninline void operator delete (void*) { }\n#endif\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p) { _out << _p.first << ' ' << _p.second; return _out; }\ntemplate<typename T, typename U> inline istream &operator>> (istream &_in, pair<T, U> &_p) { _in >> _p.first >> _p.second; return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const vector<T> &_v) { if (_v.empty()) { return _out; } _out << _v.front(); for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline istream &operator>> (istream &_in, vector<T> &_v) { for (auto &_i : _v) { _in >> _i; } return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\n\n/* ________ CODE ________ */\n\nconst int N = 302;\nint dp[N][N][N];\n\ninline void _main_function()\n{\n    string s;\n    cin >> s;\n    int n = sz(s);\n\n    for(int i = 0; i < n; ++i)\n    {\n        dp[i][i][0] = 1;\n    }\n\n    int k;\n    cin >> k;\n\n    for(int len = 2; len <= n; ++len)\n    {\n        for(int l = 0; l + len <= n; ++l)\n        {\n            int r = l + len - 1;\n            int to = min(k, (len + 1) / 2);\n            for(int i = 0; i <= to; ++i)\n            {\n                dp[l][r][i] = max(dp[l + 1][r][i], dp[l][r - 1][i]);\n                if(s[l] == s[r])\n                {\n                    dp[l][r][i] = max(dp[l][r][i], dp[l + 1][r - 1][i] + 2);\n                }\n                else if(i > 0)\n                {\n                    dp[l][r][i] = max(dp[l][r][i], dp[l + 1][r - 1][i - 1] + 2);\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    for(int i = 0; i <= k; ++i)\n    {\n        ans = max(ans, dp[0][n - 1][i]);\n    }\n    cout << ans << endl;\n}\n\n/* ________ CODE ________ */\n\nint main()\n{\n#if defined(ANDREIKKAA)\n    time_t _start = clock();\n#endif\n    if (_inpf[0] != '\\0') assert(freopen(_inpf, \"r\", stdin) != nullptr);\n    if (_outf[0] != '\\0') assert(freopen(_outf, \"w\", stdout) != nullptr);\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n\n    cout << setprecision(20);\n    cout << fixed;\n\n    _main_function();\n#if defined(ANDREIKKAA)\n    cout << \"Time: \" << (clock() - _start) / (ld)CLOCKS_PER_SEC << endl;\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int MOD=1e9+7;\nconst double PI=3.14159265359;\n\nint lcs( string X, string Y, int m, int n )\n{\n   int L[m+1][n+1];\n   int i, j;\n  \n   /* Following steps build L[m+1][n+1] in bottom up fashion. Note \n      that L[i][j] contains length of LCS of X[0..i-1] and Y[0..j-1] */\n   for (i=0; i<=m; i++)\n   {\n     for (j=0; j<=n; j++)\n     {\n       if (i == 0 || j == 0)\n         L[i][j] = 0;\n  \n       else if (X[i-1] == Y[j-1])\n         L[i][j] = L[i-1][j-1] + 1;\n  \n       else\n         L[i][j] = max(L[i-1][j], L[i][j-1]);\n     }\n   }\n    \n   /* L[m][n] contains length of LCS for X[0..n-1] and Y[0..m-1] */\n   return L[m][n];\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    \n    string s;\n    int k;\n    cin>>s>>k;\n    \n    auto s2=s;\n    reverse(s2.begin(),s2.end());\n    int n=s.size();\n    /*for(int i=0; i<n && k; i++){\n        if(s[i]!=s2[i]){\n            s2[i]=s[i];\n            s[n-1-i]=s[i];\n            k--;\n        }\n    }*/\n    \n    cout<<min(n,lcs(s,s2,n,n)+2*k);\n    \n   \n   \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 100000 + 10;\nconst int M = 1000000007;\nconst double eps = 1e-9;\nconst double PI = acos(-1);\nconst int oo = 1000000000;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> ii;\n#define pb push_back \n#define all(c) (c).begin(),(c).end()\nstring s;\nint k,dp[301][301][301];\nint calc(int a, int b, int t){\n\tif(t<0)return -oo;\n\tif(a==b)return 1;\n\tif(a>b)return 0;\n\tint &ret=dp[a][b][t];\n\tif(ret+1)return ret;\n\tret=max(calc(a+1,b,t), calc(a, b-1, t));\n\tret=max(ret, 2+calc(a+1,b-1,t-1));\n\tif(s[a]==s[b])\n\t\tret=max(ret, 2+calc(a+1,b-1,t));\n\treturn ret;\n}\nint main(){\n\tcin>>s>>k;\n\tmemset(dp,-1,sizeof(dp));\n\tcout<<calc(0,s.size()-1, k)<<endl;\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\ntypedef pair<LL, LL> P;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQ(c)     (c).erase(unique(ALL((c))),(c).end())\n# define mp          make_pair\n# define eb          emplace_back\n# define FOR(i,a,b)  for(int i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(int i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nstring s, int n;\n\nint main() {\n\tcin >> s >> n;\n\tcout << s.size() - n - 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 301;\nint dp[MAXN][MAXN][MAXN];\n\nint main() {\n    string s;\n    cin >> s;\n    int k;\n    cin >> k;\n\n    int n = s.length();\n\n    // l1 - 1, l1\n    // dp[0][0][0] = 0\n    int mx = 0;\n\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; i + j <= n; j++) {\n            for (int c = 0; c <= k; c++) {\n                mx = max(mx, dp[i][j][c]);\n                if (i + j + 1 <= n) {\n                    dp[i + 1][j][c] = max(dp[i + 1][j][c], max(dp[i][j][c], 1));\n                }\n                if (i + j + 1 <= n) {\n                    dp[i][j + 1][c] = max(dp[i][j + 1][c], max(dp[i][j][c], 1));\n                }\n\n                // don't change\n                if (i + j + 1 <= n && s[i] == s[n - 1 - j]) {\n                    dp[i + 1][j + 1][c] = max(dp[i + 1][j + 1][c], dp[i][j][c] + 2);\n                }\n\n                // change\n                if (i + j + 1 <= n && c + 1 <= k) {\n                    dp[i + 1][j + 1][c + 1] = max(dp[i + 1][j + 1][c + 1], dp[i][j][c] + 2);\n                }\n            }\n        }\n    }\n\n    cout << mx << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <list>\n#include <stack>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\n\nlong long int INF = 1e18;\nlong long int MOD = 1e9 + 7;\n\nint DP[310][310][310] = {};\n\nint main(){\n\t\n\tstring S;\n\tint K;\n\t\n\tcin >> S;\n\tcin >> K;\n\t\n\tfor(int i = 0; i < S.size(); i++){\n\t\tfor(int j = S.size() - 1; j > i; j--){\n\t\t\tint id1 = i + 1;\n\t\t\tint id2 = S.size() - j;\n\t\t\t//cout << id1 << \" \" << id2 << endl;\n\t\t\tfor(int k = 0; k <= K; k++){\n\t\t\t\tDP[id1][id2][k] = max(DP[id1 - 1][id2][k], DP[id1][id2 - 1][k]);\n\t\t\t\tif(k != 0){\n\t\t\t\t\tDP[id1][id2][k] = max(DP[id1][id2][k], DP[id1][id2][k - 1]);\n\t\t\t\t}\n\t\t\t\tif(S[i] == S[j]){\n\t\t\t\t\tDP[id1][id2][k] = max(DP[id1][id2][k], DP[id1 - 1][id2 - 1][k] + 1);\n\t\t\t\t}else if(k != 0){\n\t\t\t\t\tDP[id1][id2][k] = max(DP[id1][id2][k], DP[id1 - 1][id2 - 1][k - 1] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << DP[id1][id2][K] << endl;\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\t\n\tfor(int i = 1; i < S.size(); i++){\n\t\tans = max(ans, DP[i][S.size() - i][K] * 2);\n\t\t//cout << i << \" \" << S.size() - i << endl;\n\t\t//cout << DP[i][S.size() - i][K] << endl;\n\t}\n\t\n\tfor(int i = 1; i < S.size() - 1; i++){\n\t\tans = max(ans, DP[i][S.size() - i - 1][K] * 2 + 1);\n\t\t//cout << i << \" \" << S.size() - i - 1 << endl;\n\t\t//cout << DP[i][S.size() - i - 1][K] << endl;\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nint dp[160][160][160];\nint d2[310][310][310];\nstring s;\nint cal(int x,int y,int z){\n\tif(d2[x][y][z]>=0) return d2[x][y][z];\n\tif(x==y) return d2[x][y][z]=1;\n\tif(x>y) return d2[x][y][z]=0;\n\tint ret=0;\n\tif(s[x]==s[y]) ret=max(ret,cal(x+1,y-1,z)+2);\n\tif(z>0) ret=max(ret,cal(x+1,y-1,z-1)+2);\n\tret=max(ret,cal(x+1,y,z));ret=max(ret,cal(x,y-1,z));\n\treturn d2[x][y][z]=ret;\n}\nint main()\n{\n\tint K,n,out;\n\tcin>>s;n=s.size();cin>>K;\n\tmemset(dp,0,sizeof(dp));\n\trep(i,n/2+1) rep(j,n/2+1) rep(k,K+1){\n\t\t//cout<<i<<' '<<j<<' '<<k<<' '<<dp[i][j][k]<<endl;\n\t\tif(i<n/2) dp[i+1][j][k]=max(dp[i+1][j][k],dp[i][j][k]);\n\t\tif(j<n/2) dp[i][j+1][k]=max(dp[i][j+1][k],dp[i][j][k]);\n\t\tif(i<n/2 && j<n/2){\n\t\t\tif(s[i]==s[n-1-j]) dp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+1);\n\t\t\telse dp[i+1][j+1][k+1]=max(dp[i+1][j+1][k+1],dp[i][j][k]+1);\n\t\t}\n\t}\n\t\n\tmemset(d2,-1,sizeof(d2));\n\t//cal(0,n-1);\n\t\n\t//cout<<dp[6][9][3]<<' '<<cal(6,9)<<endl;\n\trep(i,n/2+1) rep(j,n/2+1) rep(k,K+1){\n\t\tout=max(out,dp[i][j][k]*2+cal(i,n-j-1,K-k));\n\t}\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nconst int N=310;\nchar s[N];\nint f[N][N][N];\ninline int solve(int l,int r,int k) {\n    if(l>r) return 0;\n    if(l==r) return 1;\n    if(f[l][r][k]!=-1) return f[l][r][k];\n    int &ans=f[l][r][k];\n    ans=max(solve(l+1,r,k),solve(l,r-1,k));\n    if(s[l]==s[r]) ans=max(ans,solve(l+1,r-1,k)+2);\n    else if(k) ans=max(ans,solve(l+1,r-1,k-1)+2);\n    return ans;\n}\nint main() {\n    int k;\n    memset(f,-1,sizeof(f));\n    scanf(\"%s%d\",s+1,&k);\n    cout<<solve(1,strlen(s+1),k);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \n#define ll long long\n#define all(aaa) aaa.begin(), aaa.end()\n\nconst int N = 305;\nint dp[N][N][N];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    string s;\n    int k;\n    cin >> s >> k;\n\n    int n = s.size();\n\n    for (int i = 0; i + 1 < n; i++) {\n        if (s[i] == s[i + 1]) {\n            dp[i][i + 1][0] = 2;\n        }\n        else {\n            dp[i][i + 1][1] = 2;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        dp[i][i][0] = 1;\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int l = 0, r = i; r < n; l++, r++) {\n            for (int h = 0; h <= k; h++) {\n                if (l > 0)\n                    dp[l - 1][r][h] = max(dp[l - 1][r][h], dp[l][r][h]);\n                if (r + 1 < n)\n                    dp[l][r + 1][h] = max(dp[l][r + 1][h], dp[l][r][h]);\n                if (l > 0 && r + 1 < n) {\n                    if (s[l - 1] == s[r + 1]) {\n                        dp[l - 1][r + 1][h] = max(dp[l - 1][r + 1][h], dp[l][r][h] + 2);\n                    }\n                    if (h < k) {\n                        dp[l - 1][r + 1][h + 1] = max(dp[l - 1][r + 1][h + 1], dp[l][r][h] + 2);\n                    }\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            for (int h = 0; h <= k; h++) {\n                ans = max(ans, dp[i][j][h]);\n            }\n        }\n    }\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*** author: yuji9511 ***/\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing lpair = pair<ll, ll>;\nconst ll MOD = 1e9+7;\nconst ll INF = 1e18;\n#define rep(i,m,n) for(ll i=(m);i<(n);i++)\n#define rrep(i,m,n) for(ll i=(m);i>=(n);i--)\n#define printa(x,n) for(ll i=0;i<n;i++){cout<<(x[i])<<\" \\n\"[i==n-1];};\nvoid print() {}\ntemplate <class H,class... T>\nvoid print(H&& h, T&&... t){cout<<h<<\" \\n\"[sizeof...(t)==0];print(forward<T>(t)...);}\nint dp[301][301][301] = {};\nstring S;\n\nint calc(ll i, ll j, ll k){\n    int &res = dp[i][j][k];\n    if(~res) return res;\n    if(j - i == 0){\n        return res = 0;\n    }else if(j - i == 1){\n        return res = 1;\n    }\n    res = 0;\n    if(S[i] == S[j-1]){\n        res = 2 + calc(i+1, j-1, k);\n    }else{\n        if(k > 0){\n            res = 2 + calc(i+1, j-1, k-1);\n        }\n    }\n    res = max(res, calc(i, j-1, k));\n    res = max(res, calc(i+1, j, k));\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> S;\n    ll K;\n    cin >> K;\n    memset(dp, -1, sizeof(dp));\n    ll N = S.size();\n    ll ans = calc(0,N,K);\n    print(ans);\n\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nstring S;\n\nint dp[303][303][303];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>S>>K;\n\tN=S.size();\n\t\n\tFOR(i,N) {\n\t\tdp[i][i][K]=1;\n\t\tif(i<N-1) {\n\t\t\tdp[i][i+1][K]=1+(S[i]==S[i+1]);\n\t\t\tif(K) dp[i][i+1][K-1]=2;\n\t\t}\n\t}\n\t\n\t\n\t\n\tfor(i=1;i<=N;i++) {\n\t\tfor(int L=0;L+i<=N;L++) {\n\t\t\tint R=L+i-1;\n\t\t\tfor(k=0;k<=K;k++) {\n\t\t\t\tif(L) dp[L-1][R][k]=max(dp[L-1][R][k],dp[L][R][k]);\n\t\t\t\tif(R<N-1) dp[L][R+1][k]=max(dp[L][R+1][k],dp[L][R][k]);\n\t\t\t\tif(L&&R<N-1) {\n\t\t\t\t\tif(dp[L][R][k]==0) {\n\t\t\t\t\t\tdp[L-1][R+1][k]=max(dp[L-1][R+1][k],1+(S[L-1]==S[R+1]));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[L-1][R+1][k]=max(dp[L-1][R+1][k],dp[L][R][k]+2*(S[L-1]==S[R+1]));\n\t\t\t\t\t}\n\t\t\t\t\tif(k) dp[L-1][R+1][k-1]=max(dp[L-1][R+1][k-1],dp[L][R][k]+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ma=0;\n\tFOR(i,K+1) ma=max(ma,dp[0][N-1][i]);\n\tcout<<ma<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb          emplace_back\n#define ll          long long\n#define fi          first\n#define se          second\n#define mp          make_pair\n#define sz(x)       int(x.size())\n//#define int         int64_t\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\nconst int N = 302;\nconst int mod = 998244353;\n\nstring s;\nint k, n, f[N][N][N];\n\nint DP(int l, int r, int k) {\n    if(f[l][r][k] != -1) return f[l][r][k];\n    if(r < l) return f[l][r][k] = 0;\n    if(l == r) return f[l][r][k] = 1;\n    if(l + 1 == r) {\n       if(k >= 1 || s[l] == s[r]) return f[l][r][k] = 2;\n       return f[l][r][k] = 1;\n    }\n    int&res = f[l][r][k];\n    res = max(DP(l + 1, r, k), DP(l, r - 1, k));\n    if(s[l] == s[r]) {\n        res = max(res, DP(l + 1, r - 1, k) + 2);\n    } else if(k >= 1) {\n        res = max(res, DP(l + 1, r - 1, k - 1) + 2);\n    }\n    return res;\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0), cout.tie(0);\n    #define Task        \"test\"\n    if(fopen(Task\".inp\", \"r\")) {\n        freopen(Task\".inp\", \"r\", stdin);\n        freopen(Task\".out\", \"w\", stdout);\n    }\n    cin >> s >> k; n = sz(s);\n    s = ' ' + s;\n    memset(&f, -1, sizeof f);\n    cout << DP(1, n, k);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dp[300][300][302];\nvoid chmax(int& a, int b){\n    a = max(a, b);\n}\n\nint main(){\n    string S;\n    int K;\n    cin >> S >> K;\n    int N = S.size();\n\n    for(int i=0; i<N; i++) dp[i][i][0] = 1;\n    for(int i=0; i<N-1; i++){\n        if(S[i] == S[i+1]){\n            dp[i][i+1][0] = 2;\n        }else{\n            dp[i][i+1][0] = 1;\n            dp[i][i+1][1] = 2; \n        }\n    }\n    for(int d=2; d<N; d++){\n        for(int i=0; i+d<N; i++){\n            for(int k=0; k<=K; k++){\n                chmax(dp[i][i+d][k], max(dp[i][i+d-1][k], dp[i+1][i+d][k]));\n                chmax(dp[i][i+d][k + (S[i] != S[i+d])], dp[i+1][i+d-1][k] + 2);\n            }\n        }\n    }\n    int ans = 0;\n    for(int k=0; k<=K; k++) chmax(ans, dp[0][N-1][k]);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nint p = 1000000007;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\n#define rev(s) reverse(s.begin(),s.end())\n#define end_program(s) cout << s <<endl;return 0\nint kai_size = 1000001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4); \n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size-1) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tif (r < 0 || n < r) { return 0; }\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\n\nint per(int a, int b) {\n\tint ans = a % b;\n\tif (ans < 0) { ans += b; }\n\treturn ans;\n}\nvel uni(vel &v) {\n\tsor(v);\n\tvel ans(1, v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tif (v[i] != v[i-1]) { ans.push_back(v[i]); }\n\t}\n\tv = ans;\n\treturn v;\n}\nint s_gcd(int a, int b) {\n\tif (b == 0) { return a; }\n\treturn s_gcd(b, a%b);\n}\nint gcd(int a, int b) {\n\tif (a < b) { swap(a, b); }\n\treturn s_gcd(a, b);\n}\nbool is_prime(int i) {\n\tfor (int j = 2; j*j <= i; j++) {\n\t\tif (i%j == 0) { return false; }\n\t}\n\treturn true;\n}\nint get(int i, int j, vvel &ans) {\n\tint n = ans.size();\n\tif (i < 0 || n <= i || j < 0 || n <= j) { return 1; }\n\treturn ans[i][j];\n}\nint lcm(int a, int b) {\n\treturn a * b / gcd(a, b);\n}\nsigned main() {\n\tstring s; cin >> s;\n\tint n = s.size();\n\tif (n == 1) { cout << 1 << endl; return 0; }\n\tint k; cin >> k;\n\tV<veb> can_use(n, veb(n));\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tcan_use[i][j] = (s[i] == s[n-1-j]);\n\t\t}\n\t}\n\tV<vvel> ans(n,vvel(n, vel(k+1, 0)));\n\tbool fl = false;\n\trep(i, n) {\n\t\tfl =fl || can_use[0][i];\n\t\tif (fl) { ans[0][i][0] = 2; }\n\t\trep(use, k) {\n\t\t\tans[0][i][use + 1] = 2;\n\t\t}\n\t}\n\tfl = false;\n\trep(i, n) {\n\t\tfl = fl || can_use[i][0];\n\t\tif (fl) { ans[i][0][0] = 2; }\n\t\trep(use, k) {\n\t\t\tans[i][0][use + 1] = 2;\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = 1; j < n; j++) {\n\t\t\trep(use, k+1) {\n\t\t\t\tans[i][j][use] = max(ans[i - 1][j][use], ans[i][j - 1][use]);\n\t\t\t\tif (can_use[i][j] and i+j<n-1) {\n\t\t\t\t\tmmax(ans[i][j][use], ans[i - 1][j - 1][use] + 2);\n\t\t\t\t}\n\t\t\t\telse if(can_use[i][j] and i + j == n - 1){\n\t\t\t\t\tmmax(ans[i][j][use], ans[i - 1][j - 1][use] + 1);\n\t\t\t\t}\n\t\t\t\telse if (use != 0 and i+j<n-1) {\n\t\t\t\t\tmmax(ans[i][j][use], ans[i - 1][j - 1][use-1] + 2);\n\t\t\t\t}\n\t\t\t\telse if (use != 0 and i + j == n - 1) {\n\t\t\t\t\tmmax(ans[i][j][use], ans[i - 1][j - 1][use - 1] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\trep(use, k+1) {\n\t\t\tmmax(ret, ans[i][n-1 - i][use]);\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n\nint lcs(string s, string rs) {\n\tint c[1000][1000];\n\tint m = s.size();\n\tint n = rs.size();\n\tint maxl = 0;\n\ts = s.insert(0,\" \");\n\trs = rs.insert(0, \" \");\n\tfor (int i = 1; i <= m; i++)c[i][0] = 0;\n\tfor (int j = 1; j <= n; j++)c[0][j] = 0;\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (s[i] == rs[j]) {\n\t\t\t\tc[i][j] = c[i - 1][j - 1] + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[i][j] = max(c[i - 1][j], c[i][j - 1]);\n\t\t\t}\n\t\t\tmaxl = max(maxl, c[i][j]);\n\t\t}\n\t}\n\treturn maxl;\n}\n\n\nint main() {\n\tstring s,rs;\n\tint k, maxl;\n\tcin >> s >> k;\n\t\n\tfor (int i = 0;i<s.size();i++) {\n\t\trs[i] = s[s.size() - 1 - i];\n\t}\n\n\tmaxl = lcs(s, rs);\n\n\tif (maxl <= s.size() - k) cout << maxl + k << endl;\n\telse cout << s.size() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nconst int M_S = 305;\n\nint dp[M_S][M_S][M_S];\n\nstring reverse ( string s ) {\n  string res = \"\";\n  for ( int i = s.length() - 1 ; i >= 0 ; i-- )\n    res += s[i];\n  return res;\n}\n\nint main() {\n  \n  string s;\n  int k;\n  cin >> s;\n  cin >> k;\n  int n = s.length();\n  \n  string t = reverse ( s );\n  \n  \n  int ans = 0;\n  \n  memset ( dp , 0 , sizeof dp );\n  \n  for ( int i = 1 ; i <= n ; i++ ) {\n    for ( int j = 1 ; j <= n ; j++ ) {\n      for ( int v = 0 ; v <= k ; v++ ) {\n        if ( i < ( n + 1 ) - j ) {\n          \n          // if same \n          if ( s[i-1] == t[j-1] ) {\n            dp[i][j][v] = dp[i-1][j-1][v] + 2;\n          }\n          else {\n            dp[i][j][v] = max ( dp[i][j][v] , dp[i-1][j][v] );\n            dp[i][j][v] = max ( dp[i][j][v] , dp[i][j-1][v] );\n            if ( v > 0 )\n              dp[i][j][v] = max ( dp[i][j][v] , dp[i-1][j-1][v-1] + 2 );\n          }\n          \n        }\n        else if ( i == ( n + 1 ) - j ) {\n          dp[i][j][v] = dp[i-1][j-1][v] + 1;\n        }\n        \n        /*if ( dp[i][j][v] > 0 )\n          cout << \"dp[\" << i << \"][\" << j << \"][\" << v << \"] = \" << dp[i][j][v] << endl;\n        */\n        ans = max ( ans , dp[i][j][v] );\n      }\n    }\n  }\n  \n  cout << ans << endl;\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Zory-2020\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define Debug printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define debug(x) cerr<<#x<<'='<<x<<endl\n#define mem(x,val) memset(x,val,sizeof x)\nnamespace mine\n{\n    ll qread()\n    {\n        ll ans=0,f=1;char c=getchar();\n        while(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n        while('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n        return ans*f;\n    }\n    void write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n    void write1(ll num){write(num);putchar(' ');}\n    void write2(ll num){write(num);putchar('\\n');}\n    template<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n    template<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n    ll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n    bool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\n    const int INF=0x3f3f3f3f;\n    const int MOD=993244853;\n    int mm(const int x){return x>=MOD?x-MOD:x;}\n    template<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n    ll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n    ll invm(ll x){return qpower(x,MOD-2);}\n    const int N=3e2+10;\n\n    char str[N];int dp[N][N][N];\n    void main()\n\t{\n        scanf(\"%s\",str+1);int K=qread(),n=strlen(str+1);\n        fo(i,0,n) fd(j,n+1,i+1) fo(cnt,0,K)\n        {\n            chmax(dp[i+1][j][cnt],dp[i][j][cnt]);chmax(dp[i][j-1][cnt],dp[i][j][cnt]);\n            chmax(dp[i+1][j-1][cnt+(str[i+1]!=str[j-1])],dp[i][j][cnt]+1);\n        }\n        int ans=0;fo(i,0,n) fo(cnt,0,K) chmax(ans,dp[i][i+1][cnt]*2),chmax(ans,dp[i][i+2][cnt]*2+1);write(ans);\n\t}\n};//(ans+MOD)%MOD\nsigned main()\n{\n    srand(time(0));\n    mine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n//\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//\nconstexpr ll MOD=1e9+7;\n//constexpr ll MOD=998244353;\n//constexpr ll MOD=10000000;\n//constexpr ll MOD=1e5;\nconstexpr ll MAX=3e6;\nconstexpr ll INF=(1ll<<60);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate<typename T>\nstruct Segment_tree{\n    ll N;\n    T mem;\n    vector<T> node;\n    Segment_tree(vector<T> &X,T m):mem(m){\n        ll sz=X.size();\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mem);\n        rep(i,0,sz) node[N-1+i]=X[i];\n        per(i,N-2,0){\n            node[i]=Compare(node[i*2+1],node[i*2+2]);\n        }\n    }\n    T Compare(T &A,T &B){\n        return std::max(A,B);\n    }\n    void update(ll X,T val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=Compare(node[X*2+1],node[X*2+2]);\n        }\n    }\n    T Query(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mem;\n        if(a<=l&&r<=b) return node[now];\n        auto vl=Query(a,b,now*2+1,l,(l+r)/2),vr=Query(a,b,now*2+2,(l+r)/2,r);\n        return Compare(vl,vr);\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,int a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nvoid comp(vi &A){\n    std::map<ll,ll> mem;\n    rep(i,0,A.size()) mem[A[i]]=0;\n    ll cnt=0;\n    for(auto &p:mem) p.second=cnt++;\n    rep(i,0,A.size()) A[i]=mem[A[i]];\n}\nll RLCS(string S){\n    string T=S;\n    reverse(ALL(T));\n    ll N=S.size();\n    vii dp(N+1,vi(N+1));\n    REP(i,0,N){\n        REP(j,0,N){\n            if(!i){\n                if(j) dp[i][j]=dp[i][j-1];\n            }\n            else if(!j){\n                dp[i][j]=dp[i-1][j];\n            }\n            else{\n                dp[i][j]=std::max(dp[i][j-1],dp[i-1][j]);\n                if(S[i-1]==T[j-1]) dp[i][j]=std::max(dp[i][j],dp[i-1][j-1]+1);\n            }\n        }\n    }\n    return dp[N][N];\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    string S; cin>>S;\n    ll K,N=S.size(); cin>>K;\n    string T=S; reverse(ALL(T));\n    vector<vii> dp(N/2+1,vii(N/2+1,vi(K+1,INF)));\n    dp[0][0][0]=0;\n    vii mem(26);\n    rep(i,0,N/2) mem[T[i]-'a'].pb(i+1);\n    rep(i,0,N/2){\n        REP(j,0,N/2){\n            REP(k,0,K) dp[i+1][j][k]=dp[i][j][k];\n        }\n        rep(j,0,N/2){\n            REP(k,0,K){\n                if(dp[i][j][k]==INF) continue;\n                ll X=disup(mem[S[i]-'a'],dp[i][j][k]);\n                if(X<mem[S[i]-'a'].size()){\n                    ll Y=mem[S[i]-'a'][X];\n                    dp[i+1][j+1][k]=std::min(dp[i+1][j+1][k],Y);\n                }\n                if(dp[i][j][k]<N/2&&k<K){\n                    dp[i+1][j+1][k+1]=std::min(dp[i+1][j+1][k+1],dp[i][j][k]+1);\n                }\n            }\n        }\n        REP(j,0,N/2){\n            REP(k,1,K) dp[i+1][j][k]=std::min(dp[i+1][j][k],dp[i+1][j][k-1]);\n        }\n    }\n    ll ans=0;\n    per(i,N/2,0){\n        ll cnt=0;\n        per(j,N/2,0){\n            if(dp[i][j][K]!=INF){\n                ll left=i,right=N-1-dp[i][j][K];\n                if(left<=right){\n                    string P=S.substr(left,right-left+1);\n                    ans=std::max(ans,j*2+RLCS(P));\n                }\n                else{\n                    ans=std::max(ans,j*2);\n                }\n                cnt++;\n                if(cnt==10) break;\n            }\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-8\n#define pi 3.14159265358979\n#define LL long long\n#define MP make_pair\n#define PH push\n#define PB push_back\n#define PII pair<int,int>\n#define VI vector<int>\n#define X first\n#define Y second\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\n#define sqr(x) ((x)*(x))\n#define CL(a) memset(a,0,sizeof a)\n#define fr(i,n) for(int i=1;i<=n;i++)\n#define FR(i,S,n) for(int i=S;i<=n;i++)\n#define dr(i,n) for(int i=n;i;i--)\n#define DR(i,n,S) for(int i=n;i>=S;i--)\n#define SZ(x) ((int)(x).size())\n#define rd(x) scanf(\"%d\",&x)\n#define pr(x) printf(\"%d\",x)\nconst int N=305;\nLL Pw(LL a,LL b,LL p){LL v=1;for(;b;b>>=1,a=a*a%p)if(b&1)v=v*a%p;return v;}\nusing namespace std;\nint n,m,i,j,k;char s[N];short f[N][N][N*2];\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);rd(m);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\tfor(k=0;k<=m*2;k++){\n\t\t\t\tif(s[i]==s[n-j+1]){\n\t\t\t\t\tf[i][j][k]=f[i-1][j-1][k]+1;\n\t\t\t\t}\n\t\t\t\tf[i][j][k]=max(f[i][j][k],max(f[i-1][j][k],f[i][j-1][k]));\n\t\t\t\tif(k)f[i][j][k]=max((int)f[i][j][k],f[i-1][j-1][k-1]+1);\n\t\t\t}\n\tprintf(\"%d\",(int)f[n][n][m*2]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <stdio.h>\n#include <ctype.h>\n#include <random>\n#include <string.h>\n#include <unordered_map>\n#include <cstdio>\n#include <climits>\nusing namespace std;\n#define all(vec) vec.begin(),vec.end()\ntypedef long long ll;\n\nll gcd(ll x, ll y) {\n\tif (y == 0)return x;\n\treturn gcd(y, x%y);\n}\nll lcm(ll x, ll y) {\n\treturn x / gcd(x, y)*y;\n}\nll kai(ll x, ll y, ll m) {\n\tll res = 1;\n\tfor (ll i = x - y + 1; i <= x; i++) {\n\t\tres *= i; res %= m;\n\t}\n\treturn res;\n}\nll mod_pow(ll x, ll y, ll m) {\n\tll res = 1;\n\twhile (y > 0) {\n\t\tif (y & 1) {\n\t\t\tres = res * x % m;\n\t\t}\n\t\tx = x * x % m;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nll comb(ll x, ll y, ll m) {\n\tif (y > x)return 0;\n\treturn kai(x, y, m) * mod_pow(kai(y, y, m), m - 2, m) % m;\n}\n\nstring s, t;\nint k;\nint d[310][310][310];\n\nsigned main() {\n\tstd::random_device rnd;\n\tstd::mt19937_64 mt(rnd());\n\tcin >> s >> k;\n\tt = s;\n\treverse(all(t));\n\tint n = (int)s.size();\n\tfor (int i = 0; i < n; i++)for (int j = 0; j < n; j++) {\n\t\tif (n <= i + j)continue;\n\t\tfor (int l = 0; l <= k; l++)d[i + 1][j + 1][l] = max(d[i][j + 1][l], d[i + 1][j][l]);\n\t\tif (s[i] == t[j])for (int l = 0; l <= k; l++)d[i + 1][j + 1][l] = max(d[i + 1][j + 1][l], d[i][j][l] + 1);\n\t\telse for (int l = 0; l < k; l++)d[i + 1][j + 1][l + 1] = max(d[i + 1][j + 1][l + 1], d[i][j][l] + 1);\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= n; i++)for (int j = 0; j <= n; j++) {\n\t\tif (n <= i + j - 2)continue;\n\t\tint ma = 0;\n\t\tfor (int l = 0; l <= k; l++)ma = max(ma, d[i][j][l]);\n\t\tif (i + j == n + 1)ans = max(ans, 2 * ma - 1);\n\t\telse ans = max(ans, 2 * ma);\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[305][305][305];\n\nint main(){\n  \n  string s;\n  int K;\n  \n  cin>>s>>K;\n  \n  memset(dp,-1,sizeof(dp));\n  \n  dp[0][s.size()-1][0]=0;\n  \n  int ans=0;\n  \n  for(int l=0;l<s.size();l++)\n    \n    for(int r=s.size()-1;r>=l;r--){\n\n      for(int k=0;k<=K;k++){\n\t\n\tif(dp[l][r][k]==-1) continue;\n\n\tif(l==r) ans=max(ans, dp[l][r][k]*2+1);\n\telse if(l+1==r){\n\t  ans=max(ans, dp[l][r][k]*2);\n\t  if(k<K) ans=max(ans, (dp[l][r][k]+1)*2);\n\t}\n\t\n\tif(s[l]==s[r]) dp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]+1);\n\t\n\tif(l==r) continue;\n\t\n\tdp[l+1][r-1][k+1]=max(dp[l+1][r-1][k+1], dp[l][r][k]+1);\n\tdp[l+1][r][k]=max(dp[l+1][r][k], dp[l][r][k]);\n\tdp[l][r-1][k]=max(dp[l][r-1][k], dp[l][r][k]);\n\tdp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]);\n      }\n    }  \n  \n  cout<<ans<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\ntemplate<class T, class... U> void DEBUG(const T &head, const U &... tail) { \n#ifdef HOME\n    _W('#'); _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...);\n#endif\n}\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 310;\nchar s[SIZE];\nint K;\nint dp[SIZE][SIZE][SIZE/2];\nauto maa = [](auto& x,auto y){if(x<y)x=y;};\nint main(){\n    RS(s);\n    R(K);\n    int n=LEN(s);\n    if(K*2>=n+1)W(n);\n    else{\n        REP(i,n)dp[i][i][0]=1;\n        REPP(dif,1,n){\n            for(int l=0;l+dif<n;l++){\n                int r=l+dif;\n                FOR(j,0,K)maa(dp[l][r][j],max(dp[l+1][r][j],dp[l][r-1][j]));\n                if(s[l]==s[r]){\n                    FOR(j,0,K){\n                        maa(dp[l][r][j],dp[l+1][r-1][j]+2);\n                    }\n                }\n                else{\n                    FOR(j,0,K){\n                        maa(dp[l][r][j+1],dp[l+1][r-1][j]+2);\n                    }\n                }\n            }\n        }\n        int an=0;\n        FOR(i,0,K)maa(an,dp[0][n-1][i]);\n        W(an);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\nusing namespace std;\n\nconst int MAXN = 300;\nconst int INF = 1000 * 1000 * 1000;\n\nint dp[MAXN + 1][MAXN + 1][MAXN + 1];\n\nvoid upd(int &x, int y) {\n    x = max(x, y);\n}\n\nint main() {\n    //cin.tie(0), ios::sync_with_stdio(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n\n    string s;\n    cin >> s;\n    int n = (int)s.size();\n    int K;\n    cin >> K;\n\n    for (int i = 0; i <= K; i++) {\n        for (int j = 0; j <= n; j++) {\n            for (int k = 0; k <= n; k++) {\n                dp[i][j][k] = -INF;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        dp[0][i][i] = 1;\n        if (i + 1 < n) {\n            if (s[i] == s[i + 1]) {\n                dp[0][i][i + 1] = 2;\n            } else {\n                dp[0][i][i + 1] = 1;\n                dp[1][i][i + 1] = 2;\n            }\n        }\n    }\n    for (int len = 3; len <= n; len++) {\n        for (int k = 0; k <= K; k++) {\n            for (int l = 0; l + len - 1 < n; l++) {\n                int r = l + len - 1;\n                upd(dp[k][l][r], dp[k][l + 1][r]);\n                upd(dp[k][l][r], dp[k][l][r - 1]);\n                if (s[l] == s[r]) {\n                    upd(dp[k][l][r], dp[k][l + 1][r - 1] + 2);\n                }\n                if (k > 0) {\n                    upd(dp[k][l][r], max(dp[k - 1][l + 1][r], dp[k - 1][l][r - 1]) + 2);\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for (int k = 0; k <= K; k++) {\n        ans = max(ans, dp[k][0][n - 1]);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i, a, b) for (int i = (a); i < (b); ++i)\n#define F2(i, a, b) for (int i = (a); i <= (b); ++i)\n#define dF(i, a, b) for (int i = (a); i > (b); --i)\n#define dF2(i, a, b) for (int i = (a); i >= (b); --i)\n#define maxn 310\nusing namespace std;\ntypedef long long LL;\nchar ss[maxn];\nint dp[maxn][maxn][maxn];\nint main() {\n    int k;\n    scanf(\"%s%d\", ss, &k);\n    int n = strlen(ss);\n    dF2(l, n-1, 0) {\n        F(r, l, n) {\n            F2(x, 0, k) {\n                dp[l][r][x] = max(dp[l+1][r][x], dp[l][r-1][x]);\n                if (ss[l]==ss[r]) dp[l][r][x] = max(dp[l][r][x], dp[l+1][r-1][x]+(l==r?1:2));\n                if (x) dp[l][r][x] = max(dp[l][r][x], dp[l+1][r-1][x-1]+(l==r?1:2));\n            }\n        }\n    }\n    printf(\"%d\\n\", dp[0][n-1][k]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Do you knOW what it feels like?\n\n\t\t// To be TorTured by your own MinD?\n\n\t// I don't wanna feel the PAIN.\n\n// I BeG you to KILL me, pleASE...\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O2\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC optimize(\"Os\")\n\n#define F first\n#define S second\n#define pb push_back\n#define SZ(x) (ll)(x.size())\n#define all(x) x.begin(),x.end()\n\ntypedef int ll;\ntypedef pair<ll,ll> pll;\n\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll maxn=3e2+10, lg=20, mod=1e9+7, inf=1e18;\n\nstring s;\nll k,dp[maxn][maxn][maxn],ans=1;\n\nint main(){\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\t\n\tcin>>s>>k;\n\tfor(int i=0;i<SZ(s);i++)for(int j=0;j<=k;j++) dp[i][i][j]=1;\n\tfor(int t=2;t<=SZ(s);t++)for(int l=0,r;l<=SZ(s)-t;l++){\tr=l+t-1;\n\t\tfor(int tg=0;tg<=k;tg++){\n\t\t\tdp[l][r][tg]=max(dp[l+1][r][tg],dp[l][r-1][tg]);\n\t\t\tif(tg!=0 || s[l]==s[r]) dp[l][r][tg]=max(dp[l][r][tg],dp[l+1][r-1][tg-(s[l]!=s[r])]+2);\n\t\t\tans=max(ans,dp[l][r][tg]);\n\t\t}\n\t\t//cout<<l<<' '<<r<<' '<<dp[l][r][1]<<endl;\n\t}\n\tcout<<ans;\n\t\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    string s; cin >> s;\n    int K; cin >> K;\n    int n = s.size();\n    int dp[K+1][n+1][n+1];\n    memset(dp, 0, sizeof dp);\n    for (int k = 0; k <= K; k++)\n        for (int i = 1; i <= n; i++)\n            for (int j = n-1; j >= i; j--) {\n                if (s[i-1] == s[j])\n                    dp[k][i][j] = dp[k][i-1][j+1] + 1;\n                else if (k > 0)\n                    dp[k][i][j] = max({dp[k][i-1][j], dp[k][i][j+1], dp[k-1][i-1][j+1] + 1});\n                else\n                    dp[0][i][j] = max(dp[0][i-1][j], dp[0][i][j+1]);\n            }\n\n    int ans = 0;\n    for (int i = 0; i < n; i++)\n        ans = max({ans, 1 + 2 * dp[K][i][i+1], 2 * dp[K][i][i]});\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < int(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = int(n) - 1; (i) >= int(m); -- (i))\n#define ALL(x) begin(x), end(x)\n#define dump(x) cerr << #x \" = \" << x << endl\n#define unittest_name_helper(counter) unittest_ ## counter\n#define unittest_name(counter) unittest_name_helper(counter)\n#define unittest __attribute__((constructor)) void unittest_name(__COUNTER__) ()\nusing ll = long long;\nusing namespace std;\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T> inline void chmax(T & a, T const & b) { a = max(a, b); }\ntemplate <class T> inline void chmin(T & a, T const & b) { a = min(a, b); }\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\ntemplate <typename T> ostream & operator << (ostream & out, vector<T> const & xs) { REP (i, int(xs.size()) - 1) out << xs[i] << ' '; if (not xs.empty()) out << xs.back(); return out; }\n\nint solve_k0(string const & s) {\n    int n = s.length();\n    auto dp = vectors(n + 1, n + 1, int());\n    REP (i, n + 1) REP (j, n + 1) {\n        if (i >= 1) chmax(dp[i][j], dp[i - 1][j]);\n        if (j >= 1) chmax(dp[i][j], dp[i][j - 1]);\n        if (i >= 1 and j >= 1 and s[i - 1] == s[n - j]) chmax(dp[i][j], dp[i - 1][j - 1] + 1);\n    }\n    return dp[n][n];\n}\n\nint solve(string s, int k) {\n    return min<int>(s.length(), solve_k0(s) + 2 * k);\n    int result = 0;\n    while (s.length() >= 2 and (s.front() == s.back() or k)) {\ncerr << result << ' ' << s << ' ' << k << \" (\" << result + solve_k0(s) << \")\" << endl;\n        if (s.front() != s.back()) -- k;\n        s = s.substr(1, s.length() - 2);\n        result += 2;\n    }\ncerr << result << ' ' << s << ' ' << k << \" (\" << result + solve_k0(s) << \")\" << endl;\n    return result + solve_k0(s);\n}\n\nint main() {\n    string s; cin >> s;\n    int k; cin >> k;\n    cout << solve(s, k) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define ll long long\nusing ull = unsigned long long;\nusing namespace std;\nconst int INF = 1e10;\nconst int MOD = 1e9 + 7;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\n#define pb push_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define P pair<int, int>\n#define V vector<int>\n//#define S set<int>\n#define itn int\nbool dbg = false;\nstring S;\nint K;\n\nitn memo[333][333][333];\nitn f(itn l, int r, int k) {\n    if (memo[l][r][k] != 0)\n        return memo[l][r][k];\n    if (k < 0)\n        return INF * -1;\n    if (l == r)\n        return 1;\n    if (l > r)\n        return INF * -1;\n    int ret = 0;\n    chmax(ret, f(l + 1, r, k));\n    chmax(ret, f(l, r - 1, k));\n    if (S[l] == S[r])\n        chmax(ret, f(l + 1, r - 1, k) + 2);\n    else\n        chmax(ret, f(l + 1, r - 1, k - 1) + 2);\n    //cerr << l + 1 << \" \" << r + 1 << \" \" << k << \" \" << ret << endl;\n    memo[l][r][k] = ret;\n    return ret;\n}\n\nvoid solve() {\n    itn N = S.size();\n    cout << f(0, N - 1, K) << endl;\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cin >> S >> K;\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,a,b) for(int i=(a);i<(b);i++)\n#define RREP(i,a,b) for(int i=(a);i>=(b);i--)\n#define pq priority_queue\n#define P pair<int,int>\n#define P2 pair<int,P>\n#define P3 pair<int,P2>\ntypedef long long ll; typedef long double ld;\nusing namespace std;\nconst int INF=1e9, MOD=1e9+7, around[]={0,1,1,-1,-1,0,-1,1,0,0};\nconst int vx[]={1,0,-1,0}, vy[]={0,1,0,-1};\nconst ll LINF=1e18;\nconst ld PI=abs(acos(-1));\n\nint dp[310][310][310] = {};\n\nint main(){\n\tstring s; int c; cin >> s >> c;\n\t\n\tstring w = s; reverse(w.begin(), w.end());\n\tREP(i,0,s.size()){\n\t\tREP(j,0,w.size()){\n\t\t\tREP(k,0,c + 1){\n\t\t\t\tif(s[i] == w[j]){\n\t\t\t\t\tdp[i + 1][j + 1][k] = max({dp[i + 1][j + 1][k], dp[i + 1][j][k] + 1, dp[i][j + 1][k] + 1});\n\t\t\t\t}else{\n\t\t\t\t\tdp[i + 1][j + 1][k] = max({dp[i + 1][j + 1][k], dp[i + 1][j][k], dp[i][j + 1][k]});\n\t\t\t\t\tdp[i + 1][j + 1][k + 1] = max({dp[i + 1][j + 1][k + 1], dp[i + 1][j][k] + 1, dp[i][j + 1][k] + 1});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ma = 0;\n\tREP(i,0,s.size() + 1) REP(j,0,w.size() + 1) REP(k,0,c + 1) ma = max(ma, dp[i][j][k]);\n\tcout << ma + 1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<string.h>\nusing namespace std;\nchar s[400];\nint dp[400][400][400];\nint main(){\n\tint k;\n\tscanf(\"%s\",s+1);\n\tscanf(\"%d\",&k);\n\tint l=strlen(s+1);\n\tfor(int i=1;i<=l;i++){\n\t\tfor(int j=0;j<=k;j++){\n\t\t\tdp[i][i][j]=1;\n\t\t}\n\t}\n\tfor(int i=2;i<=l;i++){\n\t\tfor(int j=1;j+i-1<=l;j++){\n\t\t\tfor(int t=0;t<=k;t++){\n\t\t\t\tdp[j][j+i-1][t]=std::max(dp[j+1][j+i-1][t],dp[j][i+j-2][t]);\n\t\t\t\tif(s[j]==s[j+i-1]){\n\t\t\t\t\tdp[j][j+i-1][t]=std::max(dp[j][j+i-1][t],dp[j+1][j+i-2][t]+2);\n\t\t\t\t}\n\t\t\t\tif(t)\n\t\t\t\t\tdp[j][j+i-1][t]=std::max(dp[j][j+i-1][t],dp[j+1][j+i-2][t-1]+2);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\",dp[1][l][k]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<list>\n#include <numeric>\nusing namespace std;\ntypedef unsigned long long int ulint;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define RE return 0\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\nconst int mod=(int)1e9+7;\nconst llint big=(llint)(2.19e15)+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\ntemplate <class T> void soun(T& ar)\n{sort(ar.begin(),ar.end());ar.erase(unique(ar.begin(),ar.end()),ar.end());}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else{return gcd(b,a%b);}}\nllint lcm(llint a,llint b){return a/gcd(a,b) *b;}\ntemplate<class T,class U> auto LB(T& ve,U in){return lower_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto UB(T& ve,U in){return upper_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto LBI(T& ve,U in){return LB(ve,in)-ve.begin();}\ntemplate<class T,class U> auto UBI(T& ve,U in){return UB(ve,in)-ve.begin();}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\nusing pli=pair<llint,int>;\nusing daic=priority_queue<pli,vector<pli>,greater<pli>>;\nint main(void){\n\t//どうせこういうのは最長共通部分列は回文になる(証明はしていない)\n\t//両側から適当なDPでもすれば答えにたどり着く?\n\tstring s;cin>>s;\n\tint n,h,i,j,K,ans=0;cin>>K;n=s.size();\n\tstatic int dp[301][301][302]={0};\n\tfor(i=0;i<n;i++){\n\t\tfor(j=n-1;j>i;j--){\n\t\t\tfor(h=0;h<=K;h++){\n\t\t\t\tif(s[i]==s[j]){maxeq(dp[i+1][j-1][h],dp[i][j][h]+2);}\n\t\t\t\telse{maxeq(dp[i+1][j-1][h+1],dp[i][j][h]+2);}\n\t\t\t\tmaxeq(dp[i+1][j][h],dp[i][j][h]);\n\t\t\t\tmaxeq(dp[i][j-1][h],dp[i][j][h]);\n\t\t\t}\n\t\t}\n\t\tmaxeq(ans,dp[i][i][K]+1);\n\t\tif(i>0){maxeq(ans,dp[i][i-1][K]);}\n\t}\n\tcout<<ans<<endl;\n\tRE;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 330;\n\ninline void smax(int &x, int y) { if (x < y) x = y; }\n\nint dp[N][N][N];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  string s;\n  cin >> s;\n  int k;\n  cin >> k;\n  int n = (int) s.size();\n  if (n == 1) {\n    cout << 1 << '\\n';\n    return 0;\n  }\n  for (int i = 1; i <= n; i++) {\n    dp[i][i][0] = 1;\n    if (i < n && s[i - 1] == s[i]) {\n      dp[i][i + 1][0] = 2;\n    } else if (i < n) {\n      dp[i][i + 1][1] = 2;\n    }\n  }\n  for (int i = n; i >= 1; i--) {\n    for (int j = i + 1; j <= n; j++) {\n      for (int r = 0; r <= k; r++) {\n        smax(dp[i][j][r], dp[i + 1][j][r]);\n        smax(dp[i][j][r], dp[i][j - 1][r]);\n        smax(dp[i][j][r], dp[i][j][r - 1]);\n        if (s[i - 1] == s[j - 1]) {\n          smax(dp[i][j][r], dp[i + 1][j - 1][r] + 2);\n        } else if (r > 0) {\n          smax(dp[i][j][r], dp[i + 1][j - 1][r - 1] + 2);\n        }\n      }\n    }\n  }\n  cout << dp[1][n][k] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e9;\n\nstring s;\nint memo[310][310][310];\n\nint calc(int l, int r, int k){\n    if(k < 0) return -INF;\n    if(l > r) return 0;\n    if(memo[l][r][k]) return memo[l][r][k];\n    if(l == r) return memo[l][r][k] = 1;\n    int res = 0;\n    if(s[l] == s[r]) res = max(res, calc(l + 1, r - 1, k) + 2);\n    else res = max({res, calc(l + 1, r, k), calc(l, r - 1, k), calc(l + 1, r - 1, k - 1) + 2});\n    return memo[l][r][k] = res;\n}\n\nint main(){\n    int k;\n    cin >> s >> k;\n    cout << calc(0, s.size() - 1, k) << endl;    \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\ntemplate<class T>\nvector<T> make_vec(size_t a){\n    return vector<T>(a);\n}\ntemplate<class T, class... Ts>\nauto make_vec(size_t a, Ts... ts){\n  return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\ntemplate<class T, class V>\ntypename enable_if<is_class<T>::value == 0>::type fill(T &t, const V &v) {\n    t = v;\n}\ntemplate<class T, class V>\ntypename enable_if<is_class<T>::value != 0>::type fill(T &t, const V &v){\n    for (auto &e : t) fill(e, v);\n}\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\n\n\n\nint main() {\n    string S;\n    int K;\n    cin >> S >> K;\n    int N = (int)S.size();\n    auto dp = make_vec<int>(N+1, N+1, K+1);\n    for (int i = 0; i <= N; ++i) {\n        for (int j = N; j >= i; --j) {\n            for (int k = 0; k <= K; ++k) {\n                if (i+1 <= N) chmax(dp[i+1][j][k], dp[i][j][k]);\n                if (j-1 >= 0) chmax(dp[i][j-1][k], dp[i][j][k]);\n                if (i+1 <= N && j-1 >= 0) {\n                    if (k+1 <= K) chmax(dp[i+1][j-1][k+1], dp[i][j][k] + 1);\n                    if (S[i] == S[j-1]) chmax(dp[i+1][j-1][k], dp[i][j][k] + 1);\n                }\n            }\n        }\n    }\n    int res = 0;\n    for (int k = 0; k <= K; ++k) {\n        for (int i = 0; i <= N; ++i) chmax(res, dp[i][i][k] * 2);\n        for (int i = 0; i < N; ++i) chmax(res, dp[i][i+1][k] * 2 + 1);\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0;i<(n);++i)\n\ntemplate<class T> inline bool chmax(T &a,T b){\n    if (a<b){a=b; return true;} return false;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string S; int K; cin >> S >> K;\n    int n=S.size();\n    int dp[n+1][n+1][K+1];\n    rep(i,n+1) rep(j,n+1) rep(k,K+1) dp[i][j][k]=0;\n    rep(i,n) dp[i][i+1][0]=1;\n    for (int j=2;j<=n;++j)\n        for (int i=0;i+j<=n;++i)\n            for (int k=0;k<=K;++k){\n                chmax(dp[i][i+j][k],max(dp[i+1][i+j][k],dp[i][i+j-1][k]));\n                if (S[i]==S[i+j-1]) chmax(dp[i][i+j][k],dp[i+1][i+j-1][k]+2);\n                else if (k<K) chmax(dp[i][i+j][k+1],dp[i+1][i+j-1][k]+2);\n    }\n    int ans=0;\n    rep(k,K+1) chmax(ans,dp[0][n][k]);\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define reg register\n#define max(a,b) (a>b?a:b)\ntypedef long long ll;\nint f[305][305][305];\nchar ch[305];\nint main(){\n\tscanf(\"%s\",ch+1);\n\treg int k,n=strlen(ch+1),ans=0;scanf(\"%d\",&k);\n\tfor(reg int i=1;i<=n;i++)\n\t\tfor(reg int j=0;j<=k;j++)\n\t\t\tf[i][i][j]=1;\n\tfor(reg int l=1;l<n;l++)\n\t\tfor(reg int i=1,j=i+l;j<=n;i++,j++)\n\t\t\tfor(reg int s=0;s<=k;s++){\n\t\t\t\tf[i][j][s]=max(f[i+1][j][s],f[i][j-1][s]);\n\t\t\t\tif(ch[i]==ch[j])f[i][j][s]=max(f[i][j][s],f[i+1][j-1][s]+2);\n\t\t\t\tif(s>0)f[i][j][s]=max(f[i][j][s],f[i+1][j-1][s-1]+2);\n\t\t\t}\n\tfor(reg int i=0;i<=k;i++)ans=max(ans,f[1][n][i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\nusing ll = long long;\nusing ii = pair<int, int>;\nconstexpr int MN = 303;\n\nint DP[MN][MN][MN];\n\nint main() {\n    if (fopen(\"in\", \"r\")) freopen(\"in\", \"r\", stdin), freopen(\"out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0), cin.tie(0);\n\n    string S; cin >> S;\n    int N = S.size();\n    int K; cin >> K;\n\n    memset(DP, 191, sizeof DP);\n    for (int i = 0; i < N; ++i) DP[i][i][0] = 1, DP[i+1][i][0] = 0;\n\n    for (int len = 0; len < N; ++len) {\n        for (int i = 0; i+len <= N; ++i) {\n            int j = i+len-1;\n            if (j < 0) continue;\n            for (int k = 0; k <= K; ++k) {\n                if (i) DP[i-1][j][k] = max(DP[i][j][k], DP[i-1][j][k]);\n                if (j < N-1) DP[i][j+1][k] = max(DP[i][j][k], DP[i][j+1][k]);\n                if (i && j < N-1) DP[i-1][j+1][k+(S[i-1]!=S[j+1])] = max(DP[i][j][k]+2, DP[i-1][j+1][k+(S[i-1]!=S[j+1])]);\n            }\n        }\n    }\n    cout << *max_element(DP[0][N-1], DP[0][N-1]+K+1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    string S;\n    cin >> S;\n    size_t K;\n    cin >> K;\n    size_t N{S.size()};\n    vector<vector<vector<int>>> dp(N, vector<vector<int>>(N, vector<int>(K + 1)));\n    for(size_t i = 0; i < N; ++i)for(size_t j = 0; j <= K; ++j)dp[i][i][j] = 1;\n    for(size_t j = 0; j <= K; ++j)for(size_t k = 1; k < N; ++k)for(size_t i = 0; i + k < N; ++i)\n        dp[i][i + k][j] = max({dp[i][i + k - 1][j], dp[i + 1][i + k][j], (S[i] == S[i + k]) * (dp[i + 1][i + k - 1][j] + 2), (j != 0) * (dp[i + 1][i + k - 1][j - 1] + 2)});\n    cout << dp[0][N - 1][K] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\nconst int MAXN = 1005;\n\nint n, m, a, b;\nbool f1, f2;\nchar ans[MAXN][MAXN];\n\nint main(){\n\tscanf( \"%d%d%d%d\", &n, &m, &a, &b );\n\tif( n&1 ){\n\t\tf1 = 1;\n\t\tint j;\n\t\tfor( j = 1; j < m && a; j += 2, --a ){\n\t\t\tans[n][j] = '<';\n\t\t\tans[n][j+1] = '>';\n\t\t}\n\t\tfor( ; j <= m; ++j )\n\t\t\tans[n][j] = '.';\n\t}\n\tif( m&1 ){\n\t\tf2 = 1;\n\t\tint i;\n\t\tfor( i = 1; i < n && b; i += 2, --b ){\n\t\t\tans[i][m] = '^';\n\t\t\tans[i+1][m] = 'v';\n\t\t}\n\t\tfor( ; i <= n; ++i )\n\t\t\tans[i][m] = '.';\n\t}\n\tint tot = ( n / 2 ) * ( m / 2 );\n\tint num = ( a + 1 ) / 2 + ( b + 1 ) / 2;\n\tif( num > tot ){\n\t\tputs( \"NO\" );\n\t\treturn 0;\n\t}\n\tfor( int i = 1; i < n; i += 2 )\n\t\tfor( int j = 1; j < m; j += 2 ){\n\t\t\tif( a >= 2 ){\n\t\t\t\ta -= 2;\n\t\t\t\tans[i][j] = ans[i+1][j] = '<';\n\t\t\t\tans[i][j+1] = ans[i+1][j+1] = '>';\n\t\t\t} else if( a == 1 ){\n\t\t\t\t--a;\n\t\t\t\tans[i][j] = '<';\n\t\t\t\tans[i][j+1] = '>';\n\t\t\t\tans[i+1][j] = ans[i+1][j+1] = '.';\n\t\t\t} else if( b >= 2 ){\n\t\t\t\tb -= 2;\n\t\t\t\tans[i][j] = ans[i][j+1] = '^';\n\t\t\t\tans[i+1][j] = ans[i+1][j+1] = 'v';\n\t\t\t} else if( b == 1 ){\n\t\t\t\t--b;\n\t\t\t\tans[i][j] = '^';\n\t\t\t\tans[i+1][j] = 'v';\n\t\t\t\tans[i][j+1] = ans[i+1][j+1] = '.';\n\t\t\t} else{\n\t\t\t\tans[i][j] = ans[i+1][j] = ans[i][j+1] = ans[i+1][j+1] = '.';\n\t\t\t}\n\t\t}\n\tputs( \"YES\" );\n\tfor( int i = 1; i <= n; ++i ){\n\t\tfor( int j = 1; j <= m; ++j )\n\t\t\tprintf( \"%c\", ans[i][j] );\n\t\tputs( \"\" );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nchar a[1000];\nint dp[305][305][305];\nint main()\n{\n    int n = 0, m, ans = 0;\n    cin >> a + 1;\n    cin >> m;\n    for(int i = 1; a[i] != 0; i ++)\n        n = i;\n    for(int i = 1; i <= n; i ++)\n        for(int j = n ; j >= i; j --)\n        {\n            for(int k = 1; k <= min(i, m); k ++)\n            {\n                if(i == j)\n                    dp[i][j][k] = dp[i - 1][j + 1][k] + 1;\n                else\n                {\n                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j + 1][k - 1] + 2);\n                    if(a[i] == a[j])\n                        dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j + 1][k] + 2);\n                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k]);\n                    dp[i][j][k] = max(dp[i][j][k], dp[i][j + 1][k]);\n                }\n                ans = max(ans, dp[i][j][k]);\n            }\n        }\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\n//const int mod = ;\n\nint d[305][305][305];\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  string s;\n  int k;\n  cin >> s >> k;\n  int n = s.size();\n  for (int i = 0; i < n; ++i) {\n    d[i][i][0] = 1;\n  }\n//  int res = 0;\n  for (int l = 2; l <= n; ++l) {\n    for (int i = 0; i + l <= n; ++i) {\n      int j = i + l - 1;\n      for (int t = 0; t <= k; ++t) {\n        d[i][j][t] = max(d[i+1][j][t], d[i][j-1][t]);\n        if (s[i] == s[j]) d[i][j][t] = max(d[i][j][t], d[i+1][j-1][t] + 2);\n        if (t) {\n          d[i][j][t] = max(max(d[i][j][t], d[i+1][j-1][t-1] + 2), d[i][j][t-1]);\n        }\n//        res = max(res, d[i][j][t]);\n      }\n    }\n  }\n  cout << max(1, d[0][n-1][k]) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...)\n#endif\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    string s;\n    int k;\n    cin >> s >> k;\n    int n = s.size();\n    vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(k + 1)));\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i; j <= n - 1; j++) {\n            for (int l = 0; l <= k; l++) {\n                if (i == j) {\n                    dp[i][j][l] = 1;\n                } else if (i + 1 == j) {\n                    dp[i][j][l] = 2;\n                    if (l == 0 && s[i] != s[j]) {\n                        dp[i][j][l] = 1;\n                    }\n                } else {\n                    dp[i][j][l] = max(dp[i + 1][j][l], dp[i][j - 1][l]);\n                    dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l] + 1);\n                    if (s[i] == s[j]) {\n                        dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l] + 2);\n                    } else if (l != 0) {\n                        dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l - 1] + 2);\n                    }\n                }\n            }\n        }\n    }\n    cout << dp[0][n - 1][k] << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define int long long\n\n#define all(X) (X).begin(), (X).end()\n#define reset(X) memset(X, 0, sizeof(X))\n#define mp(a, b) make_pair(a, b)\n#define pb push_back\n#define endl '\\n'\n#define fi first\n#define se second\n\nusing namespace __gnu_pbds;\nusing namespace std;\nconst int mod = 1e9 + 7;\n// const int mod=998244353;\n//const int mod=1e9+9;\n//const int INF=4e18+10;\nconst int INF = 4e18 + 10;\ntemplate <typename T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T>\nusing ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define read(n) \\\nint n;      \\\ncin >> n;\n#define readv(x, n)   \\\nvector<int> x(n); \\\nfor (auto &i : x) \\\n    cin >> i;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> pii;\n\ntemplate <typename T1, typename T2>\nvoid set_min(T1 &a, T2 b)\n{\n    a = min(a, (T1)b);\n}\n\nint multiply(int a, int b, int in_mod) { return (a * b) % in_mod; }\nint mult_identity(int a) { return 1; }\n\n\nauto power(auto a, int b, int in_mod)\n{\n    auto prod = mult_identity(a);\n    auto mult = a % in_mod;\n    while (b != 0)\n    {\n        if (b % 2)\n        {\n            prod = multiply(prod, mult, in_mod);\n        }\n        mult = multiply(mult, mult, in_mod);\n        b /= 2;\n    }\n    return prod;\n}\nint mod_inv(int q, int in_mod)\n{\n\n    return power(q, in_mod - 2, in_mod);\n}\n\n\nconst int MAXN = 1e5+100;\nint parent[MAXN];\nvoid build()\n{\n    for(int i=0;i<MAXN;i++)\n        parent[i] = i;\n}\n\nint find_set(int u)\n{\n    if( u== parent[u])\n        return u;\n    return parent[u] = find_set(parent[u]);\n}\nvoid merge(int u, int v)\n{\n    u= find_set(u);\n    v= find_set(v);\n    if(u!=v)\n    {\n        if(rand()%2)\n            swap(u,v);\n        parent[v] = u;\n    }\n\n}\n\nvoid solve()\n{\n    string s;\n    cin>>s;\n    int k;\n    cin>>k;\n    int n= s.size();\n    string c = s;\n    reverse(all(c));\n    k*=2;\n    vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(n+1, vector<int>(k+1)));\n\n    for(int i= 1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)\n        {\n            for(int _k= 0;_k<=k;_k++)\n            {\n                if(c[i-1] == s[j-1])\n                    dp[i][j][_k] = dp[i-1][j-1][_k] + 1;\n                else\n                {\n                    dp[i][j][_k] = max(dp[i-1][j][_k], dp[i][j-1][_k]);\n                    if(_k)\n                        dp[i][j][_k] = max(dp[i][j][_k], dp[i-1][j-1][_k-1] + 1);\n                }\n            }\n        }\n    }\n    int mx= 0;\n    for(int i= 0;i<=k;i+=2)\n        mx = max(mx, dp[n][n][i]);\n    cout<<mx<<endl;\n\n}\n\n\n\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cerr.tie(NULL);\n#ifndef ONLINE_JUDGE\n    if (fopen(\"INPUT.txt\", \"r\"))\n    {\n        freopen(\"INPUT.txt\", \"r\", stdin);\n        freopen(\"OUTPUT.txt\", \"w\", stdout);\n    }\n#endif\n    auto clk = clock();\n    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n    // -------------------------------------Code starts here---------------------------------------------------------------------\n\n    int t = 1;\n    // cin >> t;\n\n    for (int test = 1; test <= t; test++)\n    {\n        // cout<<\"Case #\"<<test<<\":\\n\";\n        //cout<<\"Trip #\"<<test<<\": \";\n        // cout<<endl;\n        solve();\n        // solveB();\n\n        // cout<<endl;\n    }\n\n    // -------------------------------------Code ends here------------------------------------------------------------------\n\n    clk = clock() - clk;\n    // cerr << fixed << setprecision(6) << \"Time: \" << ((long double)clk) / CLOCKS_PER_SEC << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 300;\n\nchar ch[N+5]; int f[N+5][N+5][N+5], k, n;\n\nvoid work() {\n    scanf(\"%s%d\", ch+1, &k); n = strlen(ch+1);\n    for (int i = 1; i <= n; i++) f[i][i][0] = 1;\n    for (int l = 1; l <= n; l++)\n    for (int i = 1; i+l <= n; i++)\n        for (int p = 0, j = i+l; p <= k; p++) {\n        f[i][j][p] = max(f[i+1][j][p], f[i][j-1][p]);\n        if (ch[i] == ch[j]) f[i][j][p] = max(f[i][j][p], f[i+1][j-1][p]+2);\n        if (p) f[i][j][p] = max(f[i][j][p], f[i+1][j-1][p-1]+2);\n        }\n    int ans = 0;\n    for (int i = 0; i <= k; i++) ans = max(ans, f[1][n][i]);\n    printf(\"%d\\n\", ans);\n}\nint main() {work(); return 0; }\n/*\n最后的lcs中l<r的部分确定下来，l>r的部分肯定是跟前者对称的（如果有更优的话那前面一部分肯定也会选更优的） \n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nvoid chmax(int &a, int b) {\n    a = max(a, b);\n}\n\nchar buf[310];\nint dp[310][310][310];\nint main() {\n    scanf(\"%s\", buf);\n    int K; scanf(\"%d\", &K);\n\n    int N = strlen(buf);\n    for(int i=0; i<N; i++) {\n        dp[i][i+1][0] = 1;\n    }\n\n    for(int k=0; k<=K; k++) {\n        for(int len=0; len<=N; len++) {\n            for(int l=0; l<N-len+1; l++) {\n                int r = l + len;\n                if(k > 0) chmax(dp[l][r][k], dp[l][r][k-1]);\n                if(l-1 >= 0 && r+1 <= N) {\n                    int cost = (buf[l-1] != buf[r]);\n\n                    // 変更する\n                    if(k + cost <= K) chmax(dp[l-1][r+1][k+cost], dp[l][r][k] + 2);\n                    \n                    // 変更しない\n                    chmax(dp[l-1][r+1][k], dp[l][r][k]);\n                }\n                if(l-1 >= 0) chmax(dp[l-1][r][k], dp[l][r][k]);\n                if(r+1 <= N) chmax(dp[l][r+1][k], dp[l][r][k]);\n            }\n        }\n    }\n\n    /*\n    for(int i=0; i<N; i++) {\n        for(int j=i+1; j<=N; j++) {\n            printf(\"%s -> %d\\n\", buf, dp[i][j][K]);\n            for(int x=0; x<N; x++) {\n                if(i <= x && x < j) printf(\"=\");\n                else printf(\" \");\n            }\n            printf(\"\\n\");\n        }\n    }\n    */\n\n    int ans = 0;\n    for(int i=0; i<=K; i++) {\n        chmax(ans, dp[0][N][i]);\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint f[310][310][310],kk,ans,l;\nchar s[1000];\nint main(){\n\tscanf(\"%s\",s);scanf(\"%d\",&kk);;l=strlen(s);\n\tmemset(f,10,sizeof(f));for (int i=0;i<=l+5;i++){\n\t\tmemset(f[i][0],0,sizeof(f[i][0]));memset(f[i][1],0,sizeof(f[i][1]));\n\t}for (int j=2;j<=l;j++)\n\t\tfor (int i=1;i+j-1<=l;i++)\n\t\t\tfor (int k=0;k<=kk;k++){\n\t\t\t\tif (k)f[i][j][k]=f[i+1][j-2][k-1];\n\t\t\t\tif (s[i-1]!=s[i+j-2]){\n\t\t\t\t\tif (k)f[i][j][k]=min(f[i][j][k],f[i+1][j-2][k-1]);\n\t\t\t\t}else f[i][j][k]=min(f[i][j][k],f[i+1][j-2][k]);\n\t\t\t\tf[i][j][k]=min(f[i][j][k],min(f[i][j-1][k],f[i+1][j-1][k])+1);\n\t\t\t}\n\tprintf(\"%d\\n\",l-f[1][l][kk]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint D[310][310][310], n, K;\nchar p[310];\nint main() {\n\tint i, L, j, k;\n\tscanf(\"%s\", p + 1);\n\tscanf(\"%d\", &K);\n\tfor (i = 1; p[i]; i++);\n\tn = i - 1;\n\tfor (L = 1; L <= n; L++) {\n\t\tfor (i = 1; i <= n - L + 1; i++) {\n\t\t\tj = i + L - 1;\n\t\t\tfor (k = 0; k <= n; k++) {\n\t\t\t\tD[i][j][k] = max(D[i][j][k],1);\n\t\t\t\tD[i][j][k] = max(D[i][j][k], D[i][j - 1][k]);\n\t\t\t\tD[i][j][k] = max(D[i][j][k], D[i + 1][j][k]);\n\t\t\t\tif (L != 1) {\n\t\t\t\t\tif (p[i] == p[j]) D[i][j][k] = max(D[i][j][k], D[i + 1][j - 1][k] + 2);\n\t\t\t\t\tif (k)D[i][j][k] = max(D[i][j][k], D[i + 1][j - 1][k - 1] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", D[1][n][K]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nstring s,t;\nint dp[310][310][310] = {};\nint main(){\n\tint i,j,l,n,k;\n\tcin >> s >> k; n = s.size();\n\tfor(i=0;i<n;i++){\n\t\tt.push_back(s[n - 1 - i]);\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++){\n\t\t\tfor(l=0;l<=k;l++){\n\t\t\t\tif(s[i - 1]==t[j - 1]){\n\t\t\t\t\tdp[i][j][l] = dp[i - 1][j - 1][l] + 1;\n\t\t\t\t}else{\n\t\t\t\t\tint x = max(dp[i - 1][j][l],dp[i][j - 1][l]);\n\t\t\t\t\tif(l>0) x = max(x,dp[i - 1][j - 1][l - 1] + 1);\n\t\t\t\t\tdp[i][j][l] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(i=0;i<n;i++){\n\t\tif(n&1){\n\t\t\tans = max(ans,2*dp[i][n - 1 - i][k] + 1);\n\t\t}else{\n\t\t\tans = max(ans,2*dp[i][n - i][k]);\n\t\t\tans = max(ans,2*dp[i][n - 1 - i][k] + 1);\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb           push_back\n#define pii          pair<int,int>\n#define vi           vector<int>\n#define vii         vector<pair<int,int>>\n#define mp           make_pair\n#define FOR(i, n) for (int i = 0; i <  (int)(n); i++)\n#define FOR1(i, n) for (int i = 1; i <= (int)(n); i++)\n#define FORD0(i, n) for (int i = (int)n; i >= 0; i--)\n#define FORD1(i, n) for (int i = (int)n; i >= 1; i--)\n#define debug(X) { cout << #X << \" = \" << (X) << endl; }\n#define endl '\\n'\n#define int long long int\nusing namespace std;\n\n\nsigned main(){\n    ios_base::sync_with_stdio(false);cin.tie(NULL);\n\n    string s;cin >> s;\n    int n = s.length();\n    int k;cin >> k;\n    vector<vi> dp(n+1, vi(n+1));\n    vector<vi> prev(n+1, vi(n+1));\n    for(int change = 0; change <= k; change++){\n        for(int len = 1; len <= n; len++){\n            for(int start =0; start <= n - len; start++){\n                dp[start][len] = max(dp[start+1][len-1], dp[start][len-1]); \n                if(s[start] == s[start + len -1]){\n                    dp[start][len] = max(1 + (len != 1) + dp[start+1][max(len-2,0LL)], dp[start][len]);\n                }else if(change > 0){\n                    dp[start][len] = max(1 + (len != 1) + prev[start+ 1][max(len-2,0LL)], dp[start][len]); \n//                cout << dp[start][len] <<  \" \";\n                }\n            }\n//            cout << endl;\n        }\n        swap(dp, prev);\n    }\n    cout << prev[0][n];\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PP;\n\n/*\n    freopen(\"input\",\"r\",stdin);\n    freopen(\"output\",\"w\",stdout);\n*/\n\nint A[301][301];\nint B[301][301];\nint N;\n\nint get_a(int a, int b) {\n\tif (a < 0 || b >= N) return 0;\n\treturn A[a][b];\n}\n\nint get_b(int a, int b) {\n\tif (a < 0 || b >= N) return 0;\n\treturn B[a][b];\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    string s;\n    cin >> s;\n    N = s.size();\n    int K;\n    cin >> K;\n    if (K * 2 + 1 >= N) {\n    \tcout << N << endl;\n    \treturn 0;\n    }\n    memset(A, 0, sizeof(A));\n    int res = 0;\n    for (int i = 0;i < N;i++) {\n    \tfor (int j = N - 1;j >= i;j--) {\n    \t\tif (i != j) {\n    \t\t\tif (s[i] == s[j]) {\n    \t\t\t\tA[i][j] = max(A[i][j], get_a(i - 1, j + 1) + 2);\n    \t\t\t\tA[i][j] = max(A[i][j], get_a(i - 1, j));\n    \t\t\t\tA[i][j] = max(A[i][j], get_a(i, j + 1));\n    \t\t\t}\n    \t\t\telse {\n    \t\t\t\tA[i][j] = max(A[i][j], get_a(i - 1, j + 1));\n    \t\t\t\tA[i][j] = max(A[i][j], get_a(i - 1, j));\n    \t\t\t\tA[i][j] = max(A[i][j], get_a(i, j + 1));\n    \t\t\t}\n    \t\t}\n    \t\telse {\n    \t\t\tA[i][j] = max(A[i][j], get_a(i - 1, j + 1) + 1);\n    \t\t}\n    \t}\n    }\n    for (int i = 0;i < N;i++) {\n    \tfor (int j = i;j < N;j++) res = max(res, A[i][j]);\n    }\n    for (int k = 1;k <= K;k++) {\n    \tmemset(B, 0, sizeof(B));\n    \tfor (int i = 0;i < N;i++) {\n    \t\tfor (int j = N - 1;j >= i;j--) {\n    \t\t\tif (i != j) {\n    \t\t\t\tif (s[i] == s[j]) {\n    \t\t\t\tB[i][j] = max(B[i][j], get_b(i - 1, j + 1) + 2);\n    \t\t\t\tB[i][j] = max(B[i][j], get_b(i - 1, j));\n    \t\t\t\tB[i][j] = max(B[i][j], get_b(i, j + 1));\n    \t\t\t}\n    \t\t\telse {\n    \t\t\t\tB[i][j] = max(B[i][j], get_a(i - 1, j + 1) + 2);\n    \t\t\t\tB[i][j] = max(B[i][j], get_b(i - 1, j + 1));\n    \t\t\t\tB[i][j] = max(B[i][j], get_b(i - 1, j));\n    \t\t\t\tB[i][j] = max(B[i][j], get_b(i, j + 1));\n    \t\t\t}\n    \t\t\t}\n    \t\t\telse {\n    \t\t\t\tB[i][j] = max(B[i][j], get_b(i - 1, j + 1) + 1);\n    \t\t\t}\n    \t\t}\n    \t}\n    \tswap(A, B);\n    \tfor (int i = 0;i < N;i++) {\n\t    \tfor (int j = i;j < N;j++) res = max(res, A[i][j]);\n\t    }\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst long long infll = (long long) 1.01e18;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nconst int maxn = 305;\nint n, k;\nstring s;\nchar tmp[maxn];\n\nint read() {\n  if (scanf(\"%s\", tmp) < 1) {\n    return false;\n  }\n  s = tmp;\n  n = sz(s);\n  scanf(\"%d\", &k);\n  return true;\n}\n\nint dp[maxn][maxn], ndp[maxn][maxn];\n\nvoid solve() {\n  for (int it = 0; it <= k; it++) {\n    for (int i = 0; i < n; i++) {\n      ndp[i][i + 1] = 1;\n    }\n    for (int len = 2; len <= n; len++) {\n      for (int i = 0; i + len <= n; i++) {\n        auto &cur = ndp[i][i + len];\n        cur = max(ndp[i][i + len - 1], ndp[i + 1][i + len]);\n        if (s[i] == s[i + len - 1]) {\n          cur = max(cur, ndp[i + 1][i + len - 1] + 2);\n        }\n        if (it) {\n          cur = max(cur, dp[i + 1][i + len - 1] + 2);\n        }\n      }\n    }\n    swap(dp, ndp);\n  }\n  printf(\"%d\\n\", dp[0][n]);\n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (read()) {\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __MINMAX_H__\n#define __MINMAX_H__\n\n/* updated: 2019-10-05 */\n\n#include <functional>\n\ntemplate <class T, class Pred = std::less<T>>\nclass MinMax {\n\tT value_m = T();\n\npublic:\n\tMinMax() = default;\n\tMinMax(const T& value);\n\tMinMax(const MinMax<T, Pred>& other) = default;\n\n\tMinMax<T, Pred>& operator=(const T& value);\n\tMinMax<T, Pred>& operator=(const MinMax<T, Pred>& other) = default;\n\n\tMinMax<T, Pred>& operator|=(const T& other);\n\tMinMax<T, Pred>& operator&=(const T& other);\n\n\toperator T() const;\n\toperator T&();\n};\n\ntemplate<class T, class Pred>\nMinMax<T, Pred>::MinMax(const T& value)\n\t: value_m(value) {\n}\n\ntemplate<class T, class Pred>\nMinMax<T, Pred>& MinMax<T, Pred>::operator=(const T& value) {\n\tvalue_m = value;\n\treturn *this;\n}\n\ntemplate<class T, class Pred>\nMinMax<T, Pred>& MinMax<T, Pred>::operator|=(const T& other) {\n\tvalue_m = std::max(value_m, other, Pred());\n\treturn *this;\n}\n\ntemplate<class T, class Pred>\nMinMax<T, Pred>& MinMax<T, Pred>::operator&=(const T& other) {\n\tvalue_m = std::min(value_m, other, Pred());\n\treturn *this;\n}\n\ntemplate<class T, class Pred>\nMinMax<T, Pred>::operator T() const {\n\treturn value_m;\n}\n\ntemplate<class T, class Pred>\nMinMax<T, Pred>::operator T&() {\n\treturn value_m;\n}\n\nusing MMInt = MinMax<int>;\nusing MMLL = MinMax<long long int>;\nusing MMDouble = MinMax<double>;\n\n#endif\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = uint32_t;\nusing LL = int64_t;\nusing ULL = uint64_t;\nusing PP = pair<LL, LL>;\ntemplate <typename T> using PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n#define REP(i, a, n) for(LL i = (a), i##_max_ = (n); i < i##_max_; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##_min_ = (a); i >= i##_min_; --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP { cin.tie(NULL); ios::sync_with_stdio(false); }\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U> istream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U> ostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N> void Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N> void Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate <class T> T Next() { T buf; cin >> buf; return buf; }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h&& j >= 0 && j < w; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"Accumulator.h\"\n#include \"Algebraic.h\"\n#include \"BinaryMatrix.h\"\n#include \"BinaryTree.h\"\n#include \"Bipartite.h\"\n#include \"BIT.h\"\n#include \"Compressor.h\"\n#include \"Decompositions.h\"\n#include \"DiscreteLog.h\"\n#include \"DynamicMod.h\"\n#include \"Exponential.h\"\n#include \"Factorization.h\"\n#include \"FFT.h\"\n#include \"FlowSolver.h\"\n#include \"Geometric2D.h\"\n#include \"Geometric2DFloat.h\"\n#include \"Geometric3D.h\"\n#include \"Geometric3DFloat.h\"\n#include \"Graph.h\"\n#include \"GraphUtil.h\"\n#include \"Interpolation.h\"\n#include \"IntMod.h\"\n#include \"KDTree.h\"\n#include \"LazySegmentTree.h\"\n#include \"LIS.h\"\n#include \"List.h\"\n#include \"Math.h\"\n#include \"MathUtil.h\"\n#include \"Matrix.h\"\n#include \"MinCostFlowSolver.h\"\n#include \"MinMax.h\"\n#include \"Numbers.h\"\n#include \"Optimize.h\"\n#include \"Permutation.h\"\n#include \"Polynomial.h\"\n#include \"Position.h\"\n#include \"Random.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"RuntimeMod.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"Sets.h\"\n#include \"Shortest.h\"\n#include \"SlidingWindow.h\"\n#include \"SpanningTree.h\"\n#include \"StringSearching.h\"\n#include \"SuffixArray.h\"\n#include \"SwitchList.h\"\n#include \"Timer.h\"\n#include \"Tree.h\"\n#include \"TreeUtil.h\"\n#include \"UnionFind.h\"\n#include \"Util.h\"\n#include \"VectorUtil.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>>(istream& ist, __int128& val) { LL tmp; ist >> tmp; val = tmp; return ist; }\nostream& operator<<(ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n\nstring s;\nint l;\nMMInt dp[302][302][302];\nint main() {\n\tcin >> s >> l;\n\tint n = s.size();\n\n\tREP(i, 0, n) {\n\t\tREP(j, 0, n) {\n\t\t\tif (i + j > n) continue;\n\t\t\tREP(k, 0, l + 1) {\n\t\t\t\tint nk = k + (s[i] != s[n - 1 - j]);\n\t\t\t\tif (i < n && j < n) dp[i + 1][j + 1][nk] |= (int)dp[i][j][k] + 2;\n\t\t\t\tif (i < n) dp[i + 1][j][k] |= dp[i][j][k];\n\t\t\t\tif (j < n) dp[i][j + 1][k] |= dp[i][j][k];\n\t\t\t}\n\t\t}\n\t}\n\n\tMMInt mx = 0;\n\tREP(i, 0, n) {\n\t\tREP(j, 0, n) {\n\t\t\tif (i + j > n) continue;\n\t\t\tREP(k, 0, l + 1) {\n\t\t\t\tmx |= (int)dp[i][j][k] + (i + j < n);\n\t\t\t}\n\t\t}\n\t}\n\tcout << mx << endl;\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <array>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <sstream>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <random>\n#include <bitset>\n#include <cassert>\n#include <tuple>\n#include <list>\n#include <iterator>\n#include <unordered_set>\n#include <unordered_map>\n#include <numeric>\n#include <complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntemplate<class htpe, class cmp>\nusing heap = priority_queue<htpe, vector<htpe>, cmp>;\n\ntemplate<class htpe>\nusing min_heap = heap<htpe, greater<htpe> >;\n\ntemplate<class htpe>\nusing max_heap = heap<htpe, less<htpe> >;\n\n#define mp make_pair\n#define pb push_back\n#define mt make_tuple\n#define ff first\n#define ss second\n\n#define forn(i, n) for (int i = 0; i < ((int)(n)); ++i)\n#define forrn(i, s, n) for (int i = (int)(s); i < ((int)(n)); ++i)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n\n#define PYMOD(a, m) ((((a) % (m)) + (m)) % (m))\n\nconst int INF = 1791791791;\nconst ll INFLL = 1791791791791791791ll;\n\nconst int maxn = 379;\nint dp[maxn][maxn][maxn];\n\nint main() {\n    // Code here:\n\n    string s;\n    cin >> s;\n    int n = s.size();\n    int k;\n    cin >> k;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = n; j > i; j--) {\n            for (int t = 0; t <= k; t++) {\n                dp[i + 1][j][t] = max(dp[i + 1][j][t], dp[i][j][t]);\n                dp[i][j - 1][t] = max(dp[i][j - 1][t], dp[i][j][t]);\n                if (s[i - 1] == s[j - 1]) {\n                    dp[i + 1][j - 1][t] = max(dp[i + 1][j - 1][t], dp[i][j][t] + 1);\n                } else if (t > 0) {\n                    dp[i + 1][j - 1][t - 1] = max(dp[i + 1][j - 1][t - 1], dp[i][j][t] + 1);\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= k; j++) {\n            ans = max(ans, 2 * dp[i][i][j] + 1);\n            ans = max(ans, 2 * dp[i][i - 1][j]);\n        }\n    }\n\n    cout << ans;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FOR(i, a, b) for(ll i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(ll i = (a); i > (b); --i)\n#define REP(i, n) for(ll i = 0; i < (n); ++i)\n#define REPR(i, n) for(ll i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt __builtin_popcount\n#define SZ(x) ((ll)(x).size())\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\n#define CINT(...)                                                              \\\n    int __VA_ARGS__;                                                           \\\n    CIN(__VA_ARGS__)\n#define DCIN(...)                                                              \\\n    double __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    ll __VA_ARGS__;                                                            \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Yes(a) cout << (a ? \"Yes\" : \"No\") << \"\\n\"\n#define YES(a) cout << (a ? \"YES\" : \"NO\") << \"\\n\"\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        FOREACH(x, v) { cout << x << \" \"; }                                    \\\n        cout << \"\\n\";                                                          \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef vector<ll> VL;\ntypedef pair<ll, ll> PL;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\nconst double PI = atan(1.0) * 4.0;\n// const int MOD = 998244353;\nconst ll LINF = 9e18;\nconst ll dx[] = {1, 0, -1, 0};\nconst ll dy[] = {0, 1, 0, -1};\n\nstring S;\nll K;\nll memo[300][300][301];\n\nll dp(ll s, ll t, ll k) {\n    ll &res = memo[s][t][k];\n    if(res) return res;\n    res = 0;\n    if(s == t)\n        res = 1;\n    else if(s + 1 == t)\n        res = (S[s] == S[t] or 0 < k ? 2 : 1);\n    else {\n        res = max({res, dp(s + 1, t, k), dp(s, t - 1, k)});\n        if(S[s] == S[t])\n            res = max(res, dp(s + 1, t - 1, k) + 2);\n        else if(k > 0)\n            res = max(res, dp(s + 1, t - 1, k - 1) + 2);\n    }\n    return res;\n}\n\nsigned main() {\n    cin >> S >> K;\n    ll N = S.length();\n    cout << dp(0, N - 1, K) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 998244353;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint operator^(const ll& t)const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\n///////////////////////////\ntemplate<typename T>\nstruct Segment_Tree {\n\ttypedef function<T(T, T)> F;\n\n\tll n;\n\tF f;//モノイドとしての演算(最小値、和　など)\n\tT unit;//単位元\n\n\tll size;\n\tvector<T> seg;\n\n\tSegment_Tree(ll n0, F f0, T unit0) {\n\t\tn = n0;\n\t\tf = f0;\n\t\tunit = unit0;\n\n\t\tsize = 1;\n\t\twhile (size < n) {\n\t\t\tsize *= 2;\n\t\t}\n\t\tseg.assign(2 * size, unit);\n\t}\n\n\n\tvoid update(ll k, T x) {//k番目の要素をxに更新\n\t\tk += size - 1;\n\t\tseg[k] = x;\n\t\twhile (k > 1) {\n\t\t\tk /= 2;\n\t\t\tseg[k] = f(seg[2 * k], seg[2 * k + 1]);\n\t\t}\n\t}\n\n\n\n\tT query_prep(ll a, ll b, ll k, ll l, ll r) {//[a,b)とkに対応する区間[l,r)の共通部分でクエリ\n\t\tif (b <= l || a >= r) { return unit; }\n\t\tif (a <= l && r <= b) { return seg[k]; }\n\n\t\tT v1 = query_prep(a, b, 2 * k, l, (l + r) / 2);\n\t\tT v2 = query_prep(a, b, 2 * k + 1, (l + r) / 2, r);\n\t\treturn f(v1, v2);\n\n\t}\n\n\tT query(ll a, ll b) {\n\t\treturn query_prep(a, b, 1, 1, size + 1);\n\t}\n\n};\n\n\n\n\nint main() {\n\tstring S;\n\tcin >> S;\n\tll N = S.size();\n\tll K;\n\tcin >> K;\n\n\tvector<vector<vector<ll>>> dp(N + 1, vector<vector<ll>>(N + 1, vector<ll>(K + 1, 0)));\n\n\trepn(i, N)repn(j, N)rep(k, K + 1) {\n\t\tif (i + j > N) { continue; }\n\n\t\tif (S[i-1] == S[N-j]) {\n\t\t\tdp[i][j][k] = max(dp[i - 1][j][k], max(dp[i][j - 1][k], dp[i - 1][j - 1][k] + 1));\n\t\t}\n\t\telse {\n\t\t\tdp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k]);\n\t\t\tif (k > 0) { dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k - 1] + 1); }\n\t\t}\n\t}\n\n\tll ans = 0;\n\trep(i, N + 1) {\n\t\tans = max(ans, dp[i][N - i][K]*2);\n\t}\n\trep(i, N) {\n\t\tans = max(ans, dp[i][N - 1 - i][K] * 2 + 1);\n\t}\n\tcout << ans << endl;\n\t\n\t\n\tsystem(\"PAUSE\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F firts\n#define S second\n#define pii pair<int, int>\n#define pb push_back\n\nusing namespace std;\n\nconst int N = 310;\n\nint dp[N][N][N];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tstring s; cin >> s;\n\tint n = s.size(), k;\n\tcin >> k;\n\n\tfor(int i=0; i<n; i++)\n\t\tfor(int j=0; j<=k; j++)\n\t\t\tdp[i][i + 1][j] = 1;\n\n\tfor(int c=0; c<=k; c++)\n\t\tfor(int len=2; len<=n; len++)\n\t\t\tfor(int l=0; l+len<=n; l++)\n\t\t\t{\n\t\t\t\tint r = l + len;\n\t\t\t\tdp[l][r][c] = max(dp[l][r - 1][c], dp[l + 1][r][c]);\n\t\t\t\tif(s[l] == s[r - 1])dp[l][r][c] = max(dp[l][r][c], 2 + dp[l + 1][r - 1][c]);\n\t\t\t\telse if(c >= 1)dp[l][r][c] = max(dp[l][r][c], 2 + dp[l + 1][r - 1][c - 1]);\n\t\t\t}\n\n\tcout << dp[0][n][k] << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nstatic const int IINF = 1 << 30;\n\ntemplate <typename T> std::vector<T> vectors(std::size_t n, T val) {\n  return std::vector<T>(n, val);\n}\n\ntemplate <typename T, typename... Args>\nauto vectors(std::size_t n, Args... args) {\n  return std::vector<decltype(vectors<T>(args...))>(n, vectors<T>(args...));\n}\n\ntemplate <class T> inline bool chmax(T &a, const T &b) {\n  return (a < b) ? a = b, true : false;\n}\n\nint main() {\n  // Input\n  std::string S;\n  int K;\n  int N;\n  std::cin >> S;\n  std::cin >> K;\n  N = S.length();\n\n  // Initialization\n  auto dp = vectors<int>(1 + N + 1, 1 + N + 1, 1 + K + 1, -IINF);\n\n  // Initial condition\n  dp[0][0][0] = 0;\n\n  // DP main\n  for (int i = 0; i <= N; ++i) {\n    for (int j = 0; j <= N; ++j) {\n      for (int k = 0; k <= K; ++k) {\n        chmax(dp[i + 1][j][k], dp[i][j][k]);\n        chmax(dp[i][j + 1][k], dp[i][j][k]);\n        chmax(dp[i + 1][j + 1][k + 1], dp[i][j][k] + 1);\n        if (S[i] == S[N - j - 1])\n          chmax(dp[i + 1][j + 1][k], dp[i][j][k] + 1);\n      }\n    }\n  }\n\n  // Output\n  int res = -1;\n  for (int i = 0; i <= N; ++i)\n    chmax(res, 2 * dp[i][N - i][K]);\n  for (int i = 0; i < N; ++i)\n    chmax(res, 2 * dp[i][N - i - 1][K] + 1);\n\n  std::cout << res << std::endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 305;\nchar s[N];\nint n, K;\nint f[N][N][N];\nint Dp(int l, int r, int x) {\n\tif (l > r) return 0;\n\tif (l == r) return 1;\n\tint &ans = f[l][r][x];\n\tif (~ ans) return ans;\n\tif (s[l] == s[r]) return ans = 2 + Dp(l+1, r-1, x);\n\tans = Dp(l+1, r, x);\n\tans = max(ans, Dp(l, r-1, x));\n\tif (x) {\n\t\tans = max(ans, 2 + Dp(l+1, r, x-1));\n\t\tans = max(ans, 2 + Dp(l, r-1, x-1));\n\t}\n\treturn ans;\n}\nint main() {\n\tscanf(\"%s\", s+1);\n\tn = strlen(s+1);\n\tcin >> K;\n\tmemset(f, -1, sizeof f);\n\tcout << Dp(1, n, K) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll inf=1LL<<60;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-10;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(int i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define Max(a,b) a=max(a,b)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\n\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    string s;cin>>s;\n    int n=s.size();\n    int k;cin>>k;\n    string t=s;\n    reverse(t.begin(),t.end());\n    int dp[n+1][n+1][k+1];\n    memset(dp,0,sizeof dp);\n    rep(i,0,n){\n        rep(j,0,n){\n            rep(l,0,k+1){\n                if(s[i]==t[j]){\n                    Max(dp[i+1][j+1][l],dp[i][j][l]+1);\n                }\n                else{\n                    Max(dp[i+1][j+1][l],max(dp[i][j+1][l],dp[i+1][j][l]));\n                    if(l<k)Max(dp[i+1][j+1][l+1],dp[i][j][l]+1);\n                }\n            }\n        }\n    }\n    int ans=0;\n    rep(i,0,n+1){\n        rep(j,0,n+1){\n            if(i+j>n)break;\n            rep(l,0,k+1){\n                if(i+j==n)Max(ans,dp[i][j][l]*2);\n                else Max(ans,dp[i][j][l]*2+1);\n            }\n        }\n    }\n    cout<<ans<<endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> vector<T> make_vec(size_t a) { return vector<T>(a); }\ntemplate<class T, class... Ts> auto make_vec(size_t a, Ts... ts) {\n  return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\n\nint main() {\n    string S;\n    int K;\n    cin >> S >> K;\n    int N = (int)S.size();\n    auto dp = make_vec<int>(N+2, N+2, K+2);\n    for (int i = 0; i <= N; ++i) {\n        for (int j = 0; j <= N; ++j) {\n            for (int k = 0; k <= K; ++k) {\n                chmax(dp[i+1][j][k], dp[i][j][k]);\n                chmax(dp[i][j+1][k], dp[i][j][k]);\n                chmax(dp[i+1][j+1][k+1], dp[i][j][k] + 1);\n                if (i < N && N-1-j >= 0 && S[i] == S[N-1-j])\n                    chmax(dp[i+1][j+1][k], dp[i][j][k] + 1);\n            }\n        }\n    }\n    int res = 0;\n    for (int k = 0; k <= K; ++k) {\n        for (int i = 0; i <= N; ++i) chmax(res, dp[i][N-i][k] * 2);\n        for (int i = 0; i < N; ++i) chmax(res, dp[i][N-1-i][k] * 2 + 1);\n    }\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint N,K;\nstring S;\nint dp[301][301][301];\n\nint main(){\n  cin>>S>>K;\n  N=S.size();\n\n  rep(i,301)rep(j,301)rep(k,301)dp[i][j][k]=-100000;\n  rep(i,N+1){\n    dp[i][i][0]=0;\n    if(i<N)dp[i][i+1][0]=1;\n  }\n\n  repl(len,2,N+1){\n    rep(l,N){\n      ll r=l+len;\n      if(r>N)continue;\n      rep(k,K+1){\n        maxch(dp[l][r][k],dp[l][r-1][k]);\n        maxch(dp[l][r][k],dp[l+1][r][k]);\n        if(S[l]==S[r-1])maxch(dp[l][r][k],dp[l+1][r-1][k]+2);\n        if(k>0)maxch(dp[l][r][k],dp[l+1][r-1][k-1]+2);\n      }\n    }\n  }\n\n\n\n  cout<<dp[0][N][K]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ljc 998244353\nusing namespace std;\ninline ll read(){\n\tll x=0,f=1;char ch=getchar();\n\twhile (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}\n\twhile (isdigit(ch)){x=x*10ll+ch-'0';ch=getchar();}\n\treturn x*f;\n}\ninline ll fast_pow(ll a,ll b,ll p){\n    ll t=1;a%=p;\n    while (b){\n        if (b&1) t=t*a%p;\n        b>>=1;a=a*a%p;\n    }\n    return t;\n}\nchar s[10101];\nint dp[303][303][303],n,K;\nsigned main(){\n\tscanf(\"%s\",s+1);\n\tK=read();n=strlen(s+1);\n\tfor (int i=1;i<=n;i++){\n\t\tfor (int j=0;j<=K;j++){\n\t\t\tdp[i][i][j]=1;\n\t\t}\n\t}\n\tfor (int len=2;len<=n;len++){\n\t\tfor (int i=1;i+len-1<=n;i++){\n\t\t\tint j=i+len-1;\n\t\t\tfor (int k=0;k<=K;k++){\n\t\t\t\tdp[i][j][k]=max(dp[i][j-1][k],dp[i+1][j][k]);\n\t\t\t\tif (s[i]==s[j]) dp[i][j][k]=max(dp[i][j][k],dp[i+1][j-1][k]+2);\n\t\t\t\telse if (k) dp[i][j][k]=max(dp[i][j][k],dp[i+1][j-1][k-1]+2);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[1][n][K];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb           push_back\n#define pii          pair<int,int>\n#define vi           vector<int>\n#define vii         vector<pair<int,int>>\n#define mp           make_pair\n#define FOR(i, n) for (int i = 0; i <  (int)(n); i++)\n#define FOR1(i, n) for (int i = 1; i <= (int)(n); i++)\n#define FORD0(i, n) for (int i = (int)n; i >= 0; i--)\n#define FORD1(i, n) for (int i = (int)n; i >= 1; i--)\n#define debug(X) { cout << #X << \" = \" << (X) << endl; }\n#define endl '\\n'\n#define int long long int\nusing namespace std;\n\n\nsigned main(){\n    ios_base::sync_with_stdio(false);cin.tie(NULL);\n\n    string s;cin >> s;\n    int n = s.length();\n    int k;cin >> k;\n    vector<vi> dp(n+1, vi(n+1));\n    vector<vi> prev(n+1, vi(n+1));\n    for(int change = 0; change <= k; change++){\n        for(int len = 1; len <= n; len++){\n            for(int start =0; start <= n - len; start++){\n                dp[start][len] = max(dp[start+1][len-1], dp[start][len-1]); \n                if(s[start] == s[start + len -1]){\n                    dp[start][len] = max(1 + (len != 1) + dp[start + 1][len - 1], dp[start][len]);\n                }else if(change > 0)\n                    dp[start][len] = max(1 + (len != 1) + prev[start+1][len-1], dp[start][len]); \n            }\n        }\n        swap(dp, prev);\n    }\n    cout << prev[0][n];\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n#define INF 1000000000\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint dp[333][333][333];\nstring s;\nint k;\n\nint dfs(int K,int L,int R)\n{\n//\tcout << K << ' ' << L << ' ' << R << endl;\n\tif(K < 0 || L > R)return -100000000;\n\tif(dp[K][L][R] != -1)return dp[K][L][R];\n\tint ret = 0;\n\tint p = 0;\n\tif(s[L] == s[R])ret = max(ret,dfs(K,L+1,R-1)+2);\n\telse ret = max(ret,dfs(K-1,L+1,R-1)+2);\n\tret = max(ret,dfs(K,L+1,R));\n\tret = max(ret,dfs(K,L,R-1));\n\t\n\treturn dp[K][L][R] = ret;\n}\n\n\nint main()\n{\n\tcin >> s >> k;\n\t\n\tREP(K,333)REP(i,333)REP(j,333)dp[K][i][j] = -1;\n\tREP(K,333)REP(i,333)dp[K][i][i] = 1;\n\tREP(K,333)REP(i,332)\n\t{\n\t\tif(s[i] == s[i+1])dp[K][i][i+1] = 2;\n\t\telse dp[K][i][i+1] = 1;\n\t}\n\t\n\tcout << dfs(k,0,s.size()-1) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ninline int read(){\n\tchar c=getchar();while (c!='-'&&(c<'0'||c>'9'))c=getchar();\n\tint k=1,kk=0;if (c=='-')c=getchar(),k=-1;\n\twhile (c>='0'&&c<='9')kk=kk*10+c-'0',c=getchar();return kk*k;\n}using namespace std;\nvoid write(int x){if (x<0)putchar('-'),x=-x;if (x/10)write(x/10);putchar(x%10+'0');}\nvoid writeln(int x){write(x);puts(\"\");}\nint f[310][310][310],kk,ans,l;\nchar s[1000];\nsigned main(){\n\tscanf(\"%s\",s);kk=read();l=strlen(s);//f[i][j][k]为i到i+j-1最多修改k个后变成回文最少插入的个数 \n\tmemset(f,10,sizeof(f));for (int i=1;i<=l;i++)f[i][0][0]=f[i][1][0]=0; \n\tfor (int j=2;j<=l;j++)\n\t\tfor (int i=1;i+j-1<=l;i++)\n\t\t\tfor (int k=0;k<=kk;k++){\n\t\t\t\tif (k)f[i][j][k]=f[i][j][k-1];\n\t\t\t\tif (s[i-1]!=s[i+j-2]){\n\t\t\t\t\tif (k)f[i][j][k]=min(f[i][j][k],f[i+1][j-2][k-1]);//修改一发 \n\t\t\t\t}else f[i][j][k]=min(f[i][j][k],f[i+1][j-2][k]);\n\t\t\t\tf[i][j][k]=min(f[i][j][k],min(f[i][j-1][k],f[i+1][j-1][k])+1);//插入一发\n\t\t\t}\n\twriteln(l-f[1][l][kk]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint F[305][305][305], K, n;\n\nchar ch[333];\n\nvoid cmax(int &x, int y) {\n    if(x < y) x = y;\n}\n\nint main() {\n    scanf(\"%s\", ch + 1);\n    scanf(\"%d\", &K);\n    memset(F, 200, sizeof F);\n    n = strlen(ch + 1);\n    F[0][n + 1][0] = 0;\n    for(int i = 0; i <= n + 1; i++)\n        for(int j = n + 1; j >= 1; j--)\n            for(int k = 0; k <= K; k++) {\n                cmax(F[i + 1][j][k], F[i][j][k]);\n                cmax(F[i][j - 1][k], F[i][j][k]);\n                int tmp = ch[i + 1] != ch[j - 1];\n                if(k + tmp <= K) cmax(F[i + 1][j - 1][k + tmp], F[i][j][k] + 2);\n            }\n    int ans = 0;\n    for(int i = 2; i <= n + 1; i++)\n        for(int j = 0; j <= K; j++)\n            cmax(ans, F[i - 2][i][j] + 1);\n    for(int i = 1; i <= n + 1; i++)\n        for(int j = 0; j <= K; j++)\n            cmax(ans, F[i - 1][i][j]);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nID: 5ak0\nPROG:\nLANG: C++11\n*/\n\n#include <bits/stdc++.h>\n#define fr first\n#define sc second\n#define pb push_back\n#define mpr make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 1e9 + 7;\n\nstring s;\nint k;\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    #ifndef SAKO\n    //freopen(\".in\", \"r\", stdin);\n    //freopen(\".out\", \"w\", stdout);\n    #endif // SAKO\n    cin >> s;\n    cin >>> k;\n    cout << s.size() - k - 1;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-8\n#define pi 3.14159265358979\n#define LL long long\n#define MP make_pair\n#define PH push\n#define PB push_back\n#define PII pair<int,int>\n#define VI vector<int>\n#define X first\n#define Y second\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\n#define sqr(x) ((x)*(x))\n#define CL(a) memset(a,0,sizeof a)\n#define fr(i,n) for(int i=1;i<=n;i++)\n#define FR(i,S,n) for(int i=S;i<=n;i++)\n#define dr(i,n) for(int i=n;i;i--)\n#define DR(i,n,S) for(int i=n;i>=S;i--)\n#define SZ(x) ((int)(x).size())\n#define rd(x) scanf(\"%d\",&x)\n#define pr(x) printf(\"%d\",x)\nconst int N=333;\nLL Pw(LL a,LL b,LL p){LL v=1;for(;b;b>>=1,a=a*a%p)if(b&1)v=v*a%p;return v;}\nusing namespace std;\nint n,m,i,j,k,f[N][N][N*2];char s[N];\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);rd(m);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\tfor(k=0;k<=m*2;k++){\n\t\t\t\tif(s[i]==s[n-j+1]){\n\t\t\t\t\tf[i][j][k]=f[i-1][j-1][k]+1;\n\t\t\t\t}else{\n\t\t\t\t\tf[i][j][k]=max(f[i-1][j][k],f[i][j-1][k]);\n\t\t\t\t\tif(k)f[i][j][k]=max(f[i][j][k],f[i-1][j-1][k-1]+1);\n\t\t\t\t}\n\t\t\t}\n\tprintf(\"%d\",f[n][n][m*2]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nint p = 1000000007;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\n#define rev(s) reverse(s.begin(),s.end())\n#define end_program(s) cout << s <<endl;return 0\nint kai_size = 1000001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4); \n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size-1) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tif (r < 0 || n < r) { return 0; }\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\n\nint per(int a, int b) {\n\tint ans = a % b;\n\tif (ans < 0) { ans += b; }\n\treturn ans;\n}\nvel uni(vel &v) {\n\tsor(v);\n\tvel ans(1, v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tif (v[i] != v[i-1]) { ans.push_back(v[i]); }\n\t}\n\tv = ans;\n\treturn v;\n}\nint s_gcd(int a, int b) {\n\tif (b == 0) { return a; }\n\treturn s_gcd(b, a%b);\n}\nint gcd(int a, int b) {\n\tif (a < b) { swap(a, b); }\n\treturn s_gcd(a, b);\n}\nbool is_prime(int i) {\n\tfor (int j = 2; j*j <= i; j++) {\n\t\tif (i%j == 0) { return false; }\n\t}\n\treturn true;\n}\nint get(int i, int j, vvel &ans) {\n\tint n = ans.size();\n\tif (i < 0 || n <= i || j < 0 || n <= j) { return 1; }\n\treturn ans[i][j];\n}\nint lcm(int a, int b) {\n\treturn a * b / gcd(a, b);\n}\nsigned main() {\n\tstring s; cin >> s;\n\tint n = s.size();\n\tif (n == 1) { cout << 1 << endl; return 0; }\n\tint k; cin >> k;\n\tV<veb> can_use(n, veb(n));\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tcan_use[i][j] = (s[i] == s[n-1-j]);\n\t\t}\n\t}\n\tV<vvel> ans(n,vvel(n, vel(k+1, 0)));\n\tbool fl = false;\n\trep(i, n) {\n\t\tfl =fl || can_use[0][i];\n\t\tif (fl) {\n\t\t\tif (i < n - 1) {\n\t\t\t\tans[0][i][0] = 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans[0][i][0] = 1;\n\t\t\t\tmmax(ans[0][i][0], ans[0][i - 1][0]);\n\t\t\t}\n\t\t}\n\t\trep(use, k) {\n\t\t\tans[0][i][use + 1] = 2;\n\t\t}\n\t}\n\tfl = false;\n\trep(i, n) {\n\t\tfl = fl || can_use[i][0];\n\t\tif (fl) {\n\t\t\tif (i < n - 1) {\n\t\t\t\tans[i][0][0] = 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans[i][0][0] = 1;\n\t\t\t\tmmax(ans[0][i][0], ans[0][i - 1][0]);\n\t\t\t}\n\t\t}\n\t\trep(use, k) {\n\t\t\tans[i][0][use + 1] = 2;\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = 1; j < n; j++) {\n\t\t\trep(use, k+1) {\n\t\t\t\tans[i][j][use] = max(ans[i - 1][j][use], ans[i][j - 1][use]);\n\t\t\t\tif (can_use[i][j] and i+j<n-1) {\n\t\t\t\t\tmmax(ans[i][j][use], ans[i - 1][j - 1][use] + 2);\n\t\t\t\t}\n\t\t\t\telse if(can_use[i][j] and i + j == n - 1){\n\t\t\t\t\tmmax(ans[i][j][use], ans[i - 1][j - 1][use] + 1);\n\t\t\t\t}\n\t\t\t\telse if (use != 0 and i+j<n-1) {\n\t\t\t\t\tmmax(ans[i][j][use], ans[i - 1][j - 1][use-1] + 2);\n\t\t\t\t}\n\t\t\t\telse if (use != 0 and i + j == n - 1) {\n\t\t\t\t\tmmax(ans[i][j][use], ans[i - 1][j - 1][use - 1] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\trep(use, k+1) {\n\t\t\tmmax(ret, ans[i][n-1 - i][use]);\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[305][305][305];\n\nint main(){\n  \n  string s;\n  int K;\n  \n  cin>>s>>K;\n  \n  memset(dp,-1,sizeof(dp));\n  \n  dp[0][s.size()-1][0]=0;\n  \n  int ans=0;\n  \n  for(int l=0;l<s.size();l++)\n    \n    for(int r=s.size()-1;r>=l;r--){\n\n      for(int k=0;k<=K;k++){\n\t\n\tif(dp[l][r][k]==-1) continue;\n\t\n\tif(s[l]==s[r]){\n\t  if(l==r) ans=max(ans, dp[l][r][k]+1);\n\t  else{\n\t    dp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]+2);\n\t    ans=max(ans, dp[l+1][r-1][k]);\n\t  }\n\t}\n\t\n\tif(l==r) continue;\n\t\n\tif(k<K){\n\t  dp[l+1][r-1][k+1]=max(dp[l+1][r-1][k+1], dp[l][r][k]+2);\n\t  ans=max(ans, dp[l+1][r-1][k+1]);\n\t}\n\t\n\tdp[l+1][r][k]=max(dp[l+1][r][k], dp[l][r][k]);\n\tdp[l][r-1][k]=max(dp[l][r-1][k], dp[l][r][k]);\n\tdp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]);\n      }\n    }\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define st first\n#define nd second\n#define pb push_back\n#define pf push_front\n#define ppb pop_back\n#define ppf pop_front\n#define umax(x,y) x=max(x,y)\n#define umin(x,y) x=min(x,y)\n#define ll long long \n#define ii pair<int,int>\n#define iii pair<int,ii>\n#define iiii pair<ii,ii>\n#define sz(x) ((int) x.size())\n#define orta ((bas+son)/2)\n#define all(x) x.begin(),x.end()\n#define pw(x) (1<<(x))\n#define inf 1000000005\n#define MOD 924844033 \n#define N 100005\n#define M 1000003\n#define LOG 20\n#define KOK 250\n#define EPS 0.0000001\nusing namespace std;\n\nint n,k;\nbool vis[305][305][305];\nint dp[305][305][305];\nchar s[305];\n\nint solve(int l,int r,int rem) {\n\n\tif(rem<0) return -inf;\n\n\tif(l>=r) return (l==r);\n\n\tbool& v=vis[l][r][rem];\n\tint& res=dp[l][r][rem];\n\n\tif(v) return res;\n\n\tv=1;\n\n\tif(s[l]==s[r]) umax(res,solve(l+1,r-1,rem)+2);\n\n\tumax(res,max(solve(l+1,r,rem),solve(l,r-1,rem)));\n\n\tumax(res,solve(l+1,r-1,rem-1)+2);\n\n\treturn res;\n\n}\n\nint main() {\n\n\tscanf(\"%s %d\",s+1,&k);\n\n\tn=strlen(s+1);\n\n\tprintf(\"%d\",solve(1,n,k));\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin (),(x).end()\n#define sqrt(x) sqrt(abs(x))\n#define re return\n#define sz(x) ((int)(x).size ())\n#define prev PREV\n#define next NEXT\n\nusing ll = long long;\nusing ii = pair<int, int>;\nusing ld = long double;\nusing D = double;\nusing vi = vector<int>;\nusing vii = vector<ii>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\n\ntemplate<typename T> T abs (T x) { re x < 0 ? -x : x; }\ntemplate<typename T> T sgn (T x) { re x < 0 ? -1 : (x > 0 ? 1 : 0); }\ntemplate<typename T> T sqr (T x) { re x * x; }\ntemplate<typename T> T gcd (T a, T b) { re a ? gcd (b % a, a) : b; }\n\nint n;\nint m;\nstring s;\nbool was[300][300][301];\nshort res[300][300][301];\n        \nint go (int i, int j, int k) {\n\tif (i > j) re 0;\n\tif (i == j) re 1;\n\tif (i >= n || j < 0) re 0;\n\tif (was[i][j][k]) re res[i][j][k];\n\twas[i][j][k] = 1;\n\tint cur = max (go (i + 1, j, k), go (i, j - 1, k));\n\tif (s[i] == s[j]) cur = max (cur, go (i + 1, j - 1, k) + 2); else\n\tif (k > 0) cur = max (cur, go (i + 1, j - 1, k - 1) + 2);\n\tre res[i][j][k] = cur;\n}\n\nint main () {\n\tcin >> s >> m;\n\tn = sz (s);\n\tprintf (\"%d\\n\", go (0, n - 1, m));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vpii;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef vector<ll> vll;\n#define INF 0x3f3f3f3f\n#define MOD 998244353LL\n#define EPSILON 0.00001\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n\n#define FOR(i, a, b) for (ll i=(a); i<=(signed)(b); i++)\n#define F0R(i, a) for (ll i=0; i<(signed)(a); i++)\n#define RFOR(i, a, b) for (int i=(a); i >= b; i--)\n\n#define MN 305\nstring s; int n; int k;\nint dp[MN][MN][MN];\nint calc(int l, int r, int x){\n    if(dp[l][r][x] != -1) return dp[l][r][x];\n    if(r < l){\n        dp[l][r][x] = 0;\n        return 0;\n    }\n    if(l == r){\n        dp[l][r][x] = 1;\n        return 1;\n    }\n    int mx = 0;\n    mx = max(mx, calc(l, r-1, x));\n    mx = max(mx, calc(l+1, r, x));\n    if(s[l] == s[r]){\n        mx = max(mx, calc(l+1, r-1, x)+2);\n    } else if(x != 0){\n        mx = max(mx, calc(l+1, r-1, x-1)+2);\n    }\n    dp[l][r][x] = mx;\n    return mx;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> s >> k; n=s.length();\n    memset(dp, -1, sizeof dp);\n    cout << calc(0, n-1, k) << \"\\n\";\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define IN freopen(\"perimetric_chapter_1_input.txt\",\"r\",stdin)\n#define OUT freopen(\"output.txt\",\"w\",stdout)\n\n#define pb push_back\n#define mp make_pair\n#define FOR(i,a,b) for(i=a ; i<=b ; i++)\n#define DBG printf(\"Hi\\n\")\n#define i64 long long int\n#define ui64 unsigned long long int\n#define xx first\n#define yy second\n#define ln 17\n#define off 2002\n\n#define sq(x) ((x)*(x))\n\n#define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL)\n\nusing namespace __gnu_pbds;\nusing namespace std ;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntypedef tree< i64, null_type, less<i64>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef pair<int,int> pii;\n\n#define log 20\n#define mod 1000000007LL\n#define INF 1000000000000000000LL\n#define maxn 300005\n\nconst long double eps = 1e-9 ;\n\nchar s[305] ;\n\nint dp[305][305][305] ;\n\nint f(int l, int r, int k)\n{\n    if( l>r ) return 0 ;\n    if(l==r) return dp[l][r][k] = 1 ;\n    if( dp[l][r][k] != -1 ) return dp[l][r][k] ;\n\n    if(s[l]==s[r]) return dp[l][r][k] = f(l+1,r-1,k) + 2 ;\n    int ret = max(f(l+1,r,k) , f(l,r-1,k)) ;\n    if(k>0) ret = max( ret , f(l+1,r-1,k-1) + 2 ) ;\n    return dp[l][r][k] = ret ;\n}\n\nint main()\n{\n    scanf(\"%s\",s) ;\n    int k ;\n\n    scanf(\"%d\",&k) ;\n\n    memset(dp,-1,sizeof(dp)) ;\n\n    int n = strlen(s) ;\n    printf(\"%d\\n\", f(0,n-1,k)) ;\n\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-8\n#define pi 3.14159265358979\n#define LL long long\n#define MP make_pair\n#define PH push\n#define PB push_back\n#define PII pair<int,int>\n#define VI vector<int>\n#define X first\n#define Y second\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\n#define sqr(x) ((x)*(x))\n#define CL(a) memset(a,0,sizeof a)\n#define fr(i,n) for(int i=1;i<=n;i++)\n#define FR(i,S,n) for(int i=S;i<=n;i++)\n#define dr(i,n) for(int i=n;i;i--)\n#define DR(i,n,S) for(int i=n;i>=S;i--)\n#define SZ(x) ((int)(x).size())\n#define rd(x) scanf(\"%d\",&x)\n#define pr(x) printf(\"%d\",x)\nconst int N=305;\nLL Pw(LL a,LL b,LL p){LL v=1;for(;b;b>>=1,a=a*a%p)if(b&1)v=v*a%p;return v;}\nusing namespace std;\nint n,m,i,j,k;char s[N];int f[2][N][N*2];\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);rd(m);\n\tif(m>=n/2)return printf(\"%d\",n),0;\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\tfor(k=0;k<=m*2;k++){\n\t\t\t\tif(s[i]==s[n-j+1])f[i%2][j][k]=f[(i-1)%2][j-1][k]+1;else f[i%2][j][k]=0;\n\t\t\t\tf[i%2][j][k]=max(f[i%2][j][k],max(f[(i-1)%2][j][k],f[i%2][j-1][k]));\n\t\t\t\tif(k)f[i%2][j][k]=max((int)f[i%2][j][k],f[(i-1)%2][j-1][k-1]+1);\n\t\t\t}\n\tprintf(\"%d\",f[n%2][n][m*2]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 100000000\n#define YJ 1145141919\n#define INF_INT_MAX 2147483647\n#define INF_LL_MAX 9223372036854775807\n#define EPS 1e-10\n#define Pi acos(-1)\n#define LL long long\n#define ULL unsigned long long\n#define LD long double\n\nconst int MAX_S = 305;\nstring S;\nint K;\n\nint dp[MAX_S][MAX_S][MAX_S];\n\nint main()\n{\n  cin >> S;\n  cin >> K;\n  \n  memset(dp, 0, sizeof(dp));\n\n  //配るdpだと偶数の時がバグるので貰うdpにする\n  for(int w = 0; w < S.length(); w++) {\n    for(int l = 0; l+w < S.length(); l++) {\n      int r = l+w;\n      for(int k = 0; k <= K; k++) {\n\tif(l == r) {\n\t  dp[l][r][k] = 1;\n\t} else { \n\t  //何もしない\n\t  if(l+1 < S.length()) {\n\t    dp[l][r][k] = max(dp[l][r][k], dp[l+1][r][k]);\n\t  }\n\t  if(r-1 >= 0) {\n\t    dp[l][r][k] = max(dp[l][r][k], dp[l][r-1][k]);\n\t  }\n\n\t  //回文を伸ばす\n\t  if(l+1 < S.length() && r-1 >= 0) {\n\t    if(S[l] == S[r]) {\n\t      dp[l][r][k] = max(dp[l][r][k], dp[l+1][r-1][k] + 2);\n\t    }\n\t    if(k < K) {\n\t      dp[l][r][k] = max(dp[l][r][k], dp[l+1][r-1][k+1] + 2);\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n\n  int ans = 0;\n  for(int k = 0; k <= K; k++) {\n    ans = max(ans, dp[0][S.length()-1][k]);\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring s;\nint mat[311][311][311];\n\nint main()\n{\n    cin >> s;\n    int kmax;\n    cin >> kmax;\n    int n = s.size();\n    s = \"$\" + s;\n    int ans(0);\n    for (int i(1); i <= n; i++) {\n        for (int j(1); i + j <= n; j++) {\n            for (int k(0); k <= kmax; k++) {\n                if (s[i] == s[n - j + 1])\n                    mat[i][j][k] = mat[i - 1][j - 1][k] + 1;\n                if (k > 0)\n                    mat[i][j][k] = max(mat[i][j][k], mat[i - 1][j - 1][k - 1] + 1);\n                mat[i][j][k] = max(mat[i][j][k], mat[i - 1][j][k]);\n                mat[i][j][k] = max(mat[i][j][k], mat[i][j - 1][k]);\n            }\n        }\n    }\n\n    for (int i(1); i <= n; i++)\n        for (int j(0); j <= kmax; j++)\n            ans = max(ans, 2 * mat[i][n - i][j]);\n    for (int i(1); i <= n; i++)\n        for (int j(0); j <= kmax; j++)\n            ans = max(ans, 2 * mat[i - 1][n - i][j] + 1);\n\n    cout << ans << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstring s;\nll dp[305][305][305];\nll solve(ll l,ll r,ll k){\n    if(k<0)return (-1e9);\n    if(r<l+1)return r-l+1;\n    if(dp[l][r][k]!=-1)return dp[l][r][k];\n    ll &ans = dp[l][r][k];\n    ans = max(solve(l+1,r,k),solve(l,r-1,k));\n    ll nk = k - (s[l]!=s[r]);\n    ans = max(ans , 2 + solve(l+1,r-1,nk));\n    return ans;\n}\nint main(){\n    ios_base:: sync_with_stdio(false);\n    cin.tie(NULL); cout.tie(NULL);\n    ll k;cin>>s>>k;\n    memset(dp,-1,sizeof(dp));\n    cout<<solve(0,s.size()-1,k);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int INF=1e9;\nconst long double eps=1e-9;\nconst int maxn=3e2+10;\nint dp[maxn][maxn][maxn];\nchar str[maxn];\ninline int read(){\n\tint x=0,flag=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')flag=-1,ch=getchar();\n\twhile(isdigit(ch))x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn x*flag;\n}\ninline void chkmax(int &x,int y){\n\tx=x>y?x:y;\n}\nint main(){\n\tint i,j,k,m,n;\n\tscanf(\"%s\",str+1);\n\tn=strlen(str+1);m=read();\n\tdp[0][n+1][0]=0;\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=n;j>=i;j--)\n\t\t\tfor(k=0;k<=m;k++){\n\t\t\t\tif(str[i]==str[j])chkmax(dp[i][j][k],dp[i-1][j+1][k]+1);\n\t\t\t\telse if(k)chkmax(dp[i][j][k],dp[i-1][j+1][k-1]+1);\n\t\t\t\tchkmax(dp[i][j][k],dp[i][j+1][k]);chkmax(dp[i][j][k],dp[i-1][j][k]);\n\t\t\t}\n\tint ans=0;\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=0;j<=m;j++)\n\t\t\tans=max(ans,dp[i][i][j]*2-1);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=i+1;j<=n;j++)\n\t\t\tans=max(ans,dp[i][j][m]*2);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...)\n#endif\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    string s;\n    int k;\n    cin >> s >> k;\n    int n = s.size();\n    int dp[n][n][k] = {};\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i; j <= n - 1; j++) {\n            for (int l = 0; l <= k; l++) {\n                if (i == j) {\n                    dp[i][j][l] = 1;\n                } else if (i + 1 == j) {\n                    dp[i][j][l] = 2;\n                    if (l == 0 && s[i] != s[j]) {\n                        dp[i][j][l] = 1;\n                    }\n                } else {\n                    dp[i][j][l] = max(dp[i + 1][j][l], dp[i][j - 1][l]);\n                    dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l] + 1);\n                    if (s[i] == s[j]) {\n                        dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l] + 2);\n                    }\n                    if (l != 0) {\n                        dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l - 1] + 2);\n                    }\n                }\n            }\n        }\n    }\n    cout << dp[0][n - 1][k] << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//writer：Sakura\n//problem：Reversed LCS\n//id：021_d\n//from：Actor\n\n#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <set>\n#include <map>\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nstring s;\nll n;\nint dp[305][305][305];\n\nint dfs(int l,int r,int sum){\n\tif(dp[l][r][sum]!=-1)return dp[l][r][sum];\n\tif(l>r)return 0;\n\tif(l==r)return 1;\n\tint ans=0;\n\tif(sum>0){\n\t\tans=max(ans,dfs(l+1,r-1,sum-1)+2);\n\t}\n\tans=max(ans,dfs(l+1,r,sum));\n\tans=max(ans,dfs(l,r-1,sum));\n\tif(s[l]==s[r])ans=max(ans,dfs(l+1,r-1,sum)+2);\n\treturn dp[l][r][sum]=ans;\n}\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tcin>>s;\n\tscanf(\"%lld\",&n);\n\tmemset(dp,-1,sizeof(dp));\n\tint _=dfs(0,s.size()-1,n);\n\tprintf(\"%lld\\n\",_);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n変更箇所は順読み逆読みの少なくとも片方で役立たないといけない\nつまり1点分として加算される必要がある\n逆に1点分以上の役割は持てない<-嘘だった\n例えば右端の文字が他に存在しない文字ならそれを変更するのはOK\n*/\nint dp[302][302];\ntemplate<typename T>\nvoid fin(T a){\n  cout<<a<<endl;\n  exit(0);\n}\n\nsigned main(){\n  string s;int K;cin>>s>>K;\n  int N=s.size();\n  assert(N<=100);\n  string t=s;\n  reverse(t.begin(),t.end());\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i][j]+(s[i]==t[j])});\n    }\n  }\n  int ans=dp[N][N];\n  if(K==0)fin(ans);\n  for(int k=0;k<N;k++){\n    for(int q=0;q<26;q++){\n      char tmp=s[k];\n      s[k]=t[N-k-1]='a'+q;\n      for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n          dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i][j]+(s[i]==t[j])});\n        }\n      }\n      if(dp[N][N]>ans+1){\n        ans=dp[N][N];\n        K--;\n      }\n      else s[k]=t[N-k-1]=tmp;\n      if(K==0)fin(ans);\n    }\n  }\n  for(int k=0;k<N;k++){\n    for(int q=0;q<26;q++){\n      char tmp=s[k];\n      s[k]=t[N-k-1]='a'+q;\n      for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n          dp[i+1][j+1]=max({dp[i+1][j],dp[i][j+1],dp[i][j]+(s[i]==t[j])});\n        }\n      }\n      if(dp[N][N]>ans){\n        ans=dp[N][N];\n        K--;\n      }\n      else s[k]=t[N-k-1]=tmp;\n      if(K==0)fin(ans);\n    }\n  }\n  fin(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx2,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"trapv\")\n#include <bits/stdc++.h>\n//#include <ext/pb_ds/assoc_container.hpp>\n//using namespace __gnu_pbds;\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing vi = vector<ll>;\nusing vvi = vector<vi>;\nusing pi = pair<ll, ll>;\nconst int mod = 7*17*(1<<23) + 1;\nconst ll inf = 1e18;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nshort dp[330][330][330];\nint n, k;\nstring s, t;\nshort f(int i, int j, int k) {\n\tif(k<0) return -3;\n\tif(i>j) return 0;\n\tif(i==j) return 1;\n\tif(dp[i][j][k] != -1) return dp[i][j][k];\n\tdp[i][j][k] = max(f(i+1,j,k), f(i,j-1,k));\n\tdp[i][j][k] = max(dp[i][j][k], (short)(f(i+1,j-1,k - (s[i]!=s[j])) + 2));\n//\tcout << i << \" \" << j << \" \" << k << \" \" << dp[i][j][k] << \"\\n\";\n\treturn dp[i][j][k];\n//\t\t\tdp[i][j][k] = max(dp[]);\n}\nint main() { //DINIC ORZ, FFT ORZ\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> s >> k;\n\tmemset(dp, -1, sizeof dp);\n\tcout << f(0, s.size()-1, k);\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nint dp[333][333][333] = {};\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,x;\n  string s;\n  cin >> s >> x;\n\n  n = s.size();\n  REP(i,n) dp[i][i+1][0] = 1;\n\n  REP(len,n){\n    FOR(i,0,n+1){\n      int j = i+len;\n      if(j>=n) break;\n      REP(k,x+1){\n        if(i) chmax(dp[i-1][j+1][k+(s[i-1]!=s[j])],dp[i][j][k]+2);\n        chmax(dp[i][j+1][k],dp[i][j][k]);\n        if(i) chmax(dp[i-1][j][k],dp[i][j][k]);\n      }\n    }\n  }\n\n  int ans = 0;\n  REP(i,x+1) chmax(ans,dp[0][n][i]);\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nint n, k, f[305][305][305];\nchar s[305];\n\nint main()\n{\n\tscanf(\"%s%d\", s + 1, &k);\n\tn = strlen(s + 1);\n\tfor (int l = n; l; l--)\n\t{\n\t\tf[l][l][0] = f[l][l][1] = 1;\n\t\tfor (int r = l + 1; r <= n; r++)\n\t\t\tfor (int x = 0; x <= r - l + 1; x++)\n\t\t\t\tf[l][r][x] = std::max({f[l + 1][r][x], f[l][r - 1][x], (x >= (s[l] != s[r])) ? f[l + 1][r - 1][x - (s[l] != s[r])] + 2 : 0});\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= k; i++)\n\t\tans = std::max(ans, f[1][n][i]);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring st;\nint mem[310][310][310],K;\nint dfs(int l,int r,int x){\n    if(r<l)return 0;\n    if(l==r)return 1;\n    if(mem[l][r][x]!=-1)return mem[l][r][x];\n    int res=max(dfs(l+1,r,x),dfs(l,r-1,x));\n    if(st[l]==st[r])res=max(res,dfs(l+1,r-1,x)+2);\n    if(x)res=max(res,dfs(l+1,r-1,x-1)+2);\n    return mem[l][r][x]=res;\n}\nint main(){\n    cin>>st>>K;\n    memset(dp,-1,sizeof(dp));\n    cout<<dfs(0,st.size()-1,K)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, ans;\nchar s[305];\nint dp[305][305][305];\nint dfs(int l, int r, int x) {\n\tif(l >= r) {\n\t\treturn r - l + 1;\n\t}\n\tif(dp[l][r][x] != -1) {\n\t\treturn dp[l][r][x];\n\t}\n\tint ret = max(dfs(l + 1, r, x), dfs(l, r - 1, x));\n\tif(s[l] == s[r]) {\n\t\tret = max(ret, dfs(l + 1, r - 1, x) + 2);\n\t} else if(x) {\n\t\tret = max(ret, dfs(l + 1, r - 1, x - 1) + 2);\n\t}\n\treturn dp[l][r][x] = ret;\n}\nint main() {\n\tmemset(dp, -1, sizeof(dp));\n\tscanf(\"%s%d\", s + 1, &k);\n\tn = strlen(s + 1);\n\tfor(int i = 1; i <= n; ++i) {\n\t\tfor(int j = i; j <= n; ++j) {\n\t\t\tans = max(ans, dfs(i, j, k));\n\t\t}\n\t} \n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,k,f[305][305][305],ans;\nchar s[305];\n\nvoid work()\n{\n\tscanf(\"%s\\n%d\",s+1,&k),n=strlen(s+1);\n\tfor (int i=1; i<=n; i++)  f[i][i][0]=1;\n\tfor (int len=2; len<=n; len++)\n\t\tfor (int i=1,j=len; j<=n; i++,j++)\n\t\t\tfor (int l=0; l<=k; l++)\n\t\t\t\t{\n\t\t\t\t\tf[i][j][l]=max(f[i+1][j][l],f[i][j-1][l]);\n\t\t\t\t\tif (l)  f[i][j][l]=max(f[i][j][l],f[i+1][j-1][l-1]+2);\n\t\t\t\t\tif (s[i]==s[j])  f[i][j][l]=max(f[i][j][l],f[i+1][j-1][l]+2);\n\t\t\t\t}\n\tfor (int l=0; l<=k; l++)  ans=max(ans,f[1][n][l]);\n\tprintf(\"%d\",ans);\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,sse3,sse4,popcnt,abm,mmx\")\n\n//#include<bits/stdc++.h>\n#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <cassert>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\n#include <unordered_set>\n#include <unordered_map>\n\n#define _USE_MATH_DEFINES\n#define ll long long\n#define ins Not Needed Thing\n#define ull unsigned long long\n#define ld long double\n#define Accepted 0\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define mp make_pair\n#define sz(x) (int)(x.size())\n#define all(x) x.begin(),x.end()\n#define F first\n#define S second\n#define SORRY FUL Accepted \n#define SpeedForce ios_base::sync_with_stdio(0), cin.tie(0)\n#define Toktama Kazakhstan \n\nusing namespace std;\n\nconst double eps = 0.000001;\nconst ld pi = acos(-1);\nconst int maxn = 1e7 + 9;\nconst int mod = 1e9 + 7;\nconst ll MOD = 1e18 + 9;\nconst ll INF = 1e18 + 123;\nconst int inf = 2e9 + 11;\nconst int mxn = 1e6 + 9;\nconst int N = 3e5 + 123;                                          \nconst int PRI = 555557;\nconst int pri = 997;\n\nint tests = 1;\n\nstring s;\nint k;\n\nint dp[333][333][333];\nbool u[333][333][333];\n\nint calc (int l, int r, int k) {\n\tif (l > r) return 0;\n\tif (l == r)\n\t\treturn 1;\n\tif (u[l][r][k])\n\t\treturn dp[l][r][k];\n\n\tu[l][r][k] = 1;\n\tint res = 0;\n\n\tif (s[l] != s[r] && k > 0)\n\t\tres = max(res, calc(l + 1, r - 1, k - 1) + 2);\n   \t\n\tif(s[l] == s[r])\n\t\tres = max(res, calc(l + 1, r - 1, k) + 2);\n\n\tres = max(res, calc(l + 1, r, k));\n\tres = max(res, calc(l, r - 1, k));\n\t\n\treturn dp[l][r][k] = res;\n}\n\ninline void Solve () {\n\t//easy\n\tcin >> s >> k;\n\tcout << calc(0, s.size() - 1, k);\n}\n\nint main () {\n\tSpeedForce;\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\t\n\t// cin >> tests;\n\twhile(tests --) {\n\t\tSolve ();\n\t\t// Ee Zadrot\n\t}\n\n\treturn Accepted; \n}"
  },
  {
    "language": "C++",
    "code": "//In the name of Allah\n//In the name of the compassionate of the merciful\n//Ya Ali!\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntemplate<typename Type>\nusing ordered_multiset = tree<Type, null_type, less_equal<Type>, rb_tree_tag, tree_order_statistics_node_update> ;\n\ntypedef long long ll ;\ntypedef long double ld ;\n\n#define f first\n#define s second\n#define pb push_back\n#define pf push_front\n#define popb pop_back\n#define popf pop_front\n#define all(x) x.begin() , x.end()\n#define mp make_pair\n#define pll pair<ll,ll>\n#define pii pair<int,int>\n\n//ifstream fin(\"input.txt\");\n//ofstream fout(\"output.txt\");\n// fflush(stdout);\n\nconst ll maxn = 310 ;\nconst ll INF = 1e18 ;\n\nll mod = 1e9 + 7 , p1 = 999999929 , p2 = 999999937 ;\n\nll n , k , dp[maxn][maxn][maxn] ;\nstring s1 ;\n\nint main()\n{\nstd::ios::sync_with_stdio(0) ;\ncin.tie(0) ;\ncout.tie(0) ;\n\ncin >> s1 >> k ;\nn = s1.size() ;\n\nfor(int i = 0 ; i < n ; i ++)\n  for(int j = 0 ; j <= k ; j ++)\n    dp[i][i][j] = 1 ;\n\nfor(int r = 1 ; r < n ; r ++){\n for(int l = r-1 ; l >= 0 ; l --){\n  for(int co = 0 ; co <= k ; co ++){\n    dp[l][r][co] = max(dp[l][r][co] , dp[l+1][r][co]) ;\n    dp[l][r][co] = max(dp[l][r][co] , dp[l][r-1][co]) ;\n   if(r-l>1){\n    if(s1[l] == s1[r])dp[l][r][co] = max(dp[l][r][co] , dp[l+1][r-1][co]+2) ;\n    if(co > 0)dp[l][r][co] = max(dp[l][r][co] , dp[l+1][r-1][co-1]+2) ;\n   }\n   else{\n    if(s1[l] == s1[r])dp[l][r][co] = 2 ;\n   }\n  }\n }\n}\ncout << dp[0][n-1][k] ;\n return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nchar s[305];\nint k;\nint dp[305][305][305];\nint main()\n{\n\tmemset(s,0,sizeof(s));\n\tmemset(dp,0,sizeof(dp));\n\tscanf(\"%s\",s+1);\n\tscanf(\"%d\",&k);\n\tint n = strlen(s+1);\n\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tfor(int j=0; j+i<=n; j++)\n\t\t{\n\t\t\tint l=j,r=j+i;\n\t\t\tfor(int kk=0; kk<=k; kk++)\n\t\t\t{\n\t\t\t\tdp[l][r][kk] = max(dp[r+1][l][kk],dp[l][r-1][kk]);\n\t\t\t\tif(s[l]==s[r])\tdp[l][r][kk] = max(dp[l][r][kk], dp[l+1][r-1][kk]+2);\n\t\t\t\telse if(kk>0)\tdp[l][r][kk] = max(dp[l][r][kk], dp[l+1][r-1][kk-1]+2);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0; i<=k; i++)\n\t\tans = max(dp[1][n][i],ans);\n\tprintf(\"%d\",ans+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...)\n#endif\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    string s;\n    int k;\n    cin >> s >> k;\n    int n = s.size();\n    int dp[n][n][k + 1] = {};\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i; j <= n - 1; j++) {\n            for (int l = 0; l <= k; l++) {\n                if (i == j) {\n                    dp[i][j][l] = 1;\n                } else if (i + 1 == j) {\n                    dp[i][j][l] = 2;\n                    if (l == 0 && s[i] != s[j]) {\n                        dp[i][j][l] = 1;\n                    }\n                } else {\n                    dp[i][j][l] = max(dp[i + 1][j][l], dp[i][j - 1][l]);\n                    dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l] + 1);\n                    if (s[i] == s[j]) {\n                        dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l] + 2);\n                    } else if (l != 0) {\n                        dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l - 1] + 2);\n                    }\n                }\n            }\n        }\n    }\n    cout << dp[0][n - 1][k] << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\ntemplate <typename H>\nH max(const H &head) {\n\treturn head;\n}\ntemplate <typename H, typename ...Tail>\nH max(const H &head, const Tail&... tail) {\n\tauto tail_max = max(tail...);\n\treturn head > tail_max ? head : tail_max;\n}\n\nint max_lcs(const std::string &str, int l, int r, int k, std::vector<std::vector<std::vector<int>>> &memo) {\n\tif (l > r) return -2;\n\tif (k < 0) return -2;\n\tif (l == r) return 1;\n\tif (memo[l][r][k] >= 0) return memo[l][r][k];\n\tauto &res = memo[l][r][k];\n\tif (str[l] == str[r]) {\n\t\tres = max_lcs(str, l + 1, r - 1, k, memo) + 2;\n\t}\n\telse {\n\t\tres = max_lcs(str, l + 1, r - 1, k, memo);\n\t}\n\tres = max(res, max_lcs(str, l + 1, r, k, memo), max_lcs(str, l, r - 1, k, memo), max_lcs(str, l + 1, r - 1, k - 1, memo) + 2);\n\t//std::cout << \"l = \" << l << \" ,r = \" << r << \" ,k = \" << k << \" ,res = \" << res << std::endl;\n\treturn res;\n}\nint max_lcs(const std::string &str, int k) {\n\tstd::vector<std::vector<std::vector<int>>> memo(str.size() + 1, std::vector<std::vector<int>>(str.size() + 1, std::vector<int>(k + 1, -1)));\n\treturn max_lcs(str, 0, str.size() - 1, k, memo);\n}\n\nint main() {\n\tstd::string str;\n\tint k;\n\tstd::cin >> str >> k;\n\tstd::cout << max_lcs(str, k) << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define all(v) v.begin(), v.end()\n#define sz(v) int(v.size())\n#define pii pair<int, int>\n#define mp make_pair\n#define f first\n#define ll long long\n#define ld long double\n#define s second\n#define vec vector<int>\n\nusing namespace std;\n\nconst int N = (int) 300 + 10;\nconst int M = (int) 2018 * 2018;\nconst int K = (int) 15;\nconst int INF = (int) 1e9 + 7;\nconst int mod = (int) 998244353;\nconst ld EPS = (ld) 1e-9;\nconst ll LINF = (ll) 1e18;\n\nint n, k;\nstring s;\nint dp[N][N][N];\n\nvoid upd_max(int &x, int y) {\n\tx = max(x, y);\n}\n\nint main() {\n\t#ifdef sony\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t\tfreopen(\"output.txt\", \"w\", stdout);\n\t#endif\n\tsrand(time(0));\n\tcin >> s >> k;\n\tn = sz(s);\n\tfor (int i = 0; i < n; i++) {\n\t\tdp[i][i][0] = 1;\n\t}\n\tfor (int len = 2; len <= n; len++) {\n\t\tfor (int i = 0; i + len - 1 < n; i++) {\n\t\t\tint j = i + len - 1;\n\t\t\tfor (int sum = 0; sum <= k; sum++) {\n\t\t\t\tif (s[i] == s[j]) {\n\t\t\t\t\tupd_max(dp[i][j][sum], dp[i + 1][j - 1][sum] + 2);\n\t\t\t\t} else {\n\t\t\t\t\tif (sum)\n\t\t\t\t\t\tupd_max(dp[i][j][sum], dp[i + 1][j - 1][sum - 1] + 2);\n\t\t\t\t\tupd_max(dp[i][j][sum], dp[i + 1][j][sum]);\n\t\t\t\t\tupd_max(dp[i][j][sum], dp[i][j - 1][sum]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int sum = 0; sum <= k; sum++) {\n\t\tans = max(ans, dp[0][n - 1][sum]);\n\t}\n\tcout << ans;\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <math.h>\n#include <random>\n#include <set>\n#include <stdio.h>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  string s, rs;\n  int K;\n  cin >> s >> K;\n  rs = s;\n  reverse(rs.begin(), rs.end());\n  int n = s.size();\n  K *= 2;\n  int dp[K + 1][n + 1][n + 1];\n  for (int i = 0; i < K + 1; i++)\n    for (int j = 0; j < n + 1; j++)\n      for (int k = 0; k < n + 1; k++)\n        dp[i][j][k] = 0;\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < n; j++) {\n      dp[0][i + 1][j + 1] = max(dp[0][i][j + 1], dp[0][i + 1][j]);\n      if (s[i] == rs[j])\n        dp[0][i + 1][j + 1] = max(dp[0][i + 1][j + 1], dp[0][i][j] + 1);\n    }\n  for (int i = 0; i < K; i++) {\n    for (int j = 0; j < n; j++)\n      for (int k = 0; k < n; k++) {\n        dp[i + 1][j + 1][k + 1] = dp[i][j + 1][k + 1];\n        dp[i + 1][j + 1][k + 1] =\n            max(dp[i + 1][j + 1][k + 1], dp[i + 1][j][k + 1]);\n        dp[i + 1][j + 1][k + 1] =\n            max(dp[i + 1][j + 1][k + 1], dp[i + 1][j + 1][k]);\n        if (s[j] != rs[k])\n          dp[i + 1][j + 1][k + 1] =\n              max(dp[i + 1][j + 1][k + 1], dp[i][j][k] + 1);\n        else\n          dp[i + 1][j + 1][k + 1] =\n              max(dp[i + 1][j + 1][k + 1], dp[i + 1][j][k] + 1);\n      }\n  }\n  /*/\n  for (int i = 0; i < K + 1; i++) {\n    cout << i << endl;\n    for (int j = 0; j < n + 1; j++) {\n      for (int k = 0; k < n + 1; k++)\n        cout << dp[i][j][k] << \" \";\n      cout << endl;\n    }\n  }\n  /*/\n\n  cout << dp[K][n][n] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x < 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tstring S;\n\tint K;\n\tcin >> S >> K;\n\tint N =S.length();\n\tvector< vector< vector<int> > > ans(N+1, vector< vector<int> >(N+1, vector<int>(K+1, -OVER9000)));\n\tans[0][N][0] =0;\n\tfor(int l =N; l > 0; l--) for(int i =0; i <= N-l; i++) {\n\t\tif(l == 1) {\n\t\t\tfor(int k =0; k <= K; k++) ans[i][i][k] =max(ans[i][i][k], ans[i][i+1][k]+1);\n\t\t\tfor(int k =0; k <= K; k++) ans[i][i+l-1][k] =max(ans[i][i+l-1][k], ans[i][i+l][k]);\n\t\t\tfor(int k =0; k <= K; k++) ans[i+1][i+l][k] =max(ans[i+1][i+l][k], ans[i][i+l][k]);\n\t\t\tcontinue;\n\t\t}\n\t\tif(S[i] == S[i+l-1]) {\n\t\t\tfor(int k =0; k <= K; k++) ans[i+1][i+l-1][k] =max(ans[i+1][i+l-1][k], ans[i][i+l][k]+2);\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int k =0; k <= K; k++) ans[i][i+l-1][k] =max(ans[i][i+l-1][k], ans[i][i+l][k]);\n\t\tfor(int k =0; k <= K; k++) ans[i+1][i+l][k] =max(ans[i+1][i+l][k], ans[i][i+l][k]);\n\t\tfor(int k =0; k < K; k++) ans[i+1][i+l-1][k+1] =max(ans[i+1][i+l-1][k+1], ans[i][i+l][k]+2);\n\t}\n\tint ansF =0;\n\tfor(int i =0; i <= K; i++) for(int j =0; j <= N; j++) ansF =max(ansF, ans[j][j][i]);\n\tcout << ansF << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nconst int MAX_N = 305;\n\nint dp [MAX_N][MAX_N][MAX_N];\n\nint main () {\n  string s;\n  cin >> s;\n\n  int n, K;\n  n = s.size();\n  cin >> K;\n\n  for (int i = 0; i < n; i++) {\n    dp[i][i][0] = 1;\n  }\n  for (int i = 0; i < n - 1; i++) {\n    if (s[i] == s[i + 1]) {\n      dp[i][i + 1][0] = 2;\n    } else {\n      dp[i][i + 1][1] = 2;\n    }\n  }\n\n  for (int i = 0; i < n; i++) {\n    for (int l = 0; l + i < n; l++) {\n      int r = l + i;\n      for (int k = 0; k <= K; k++) {\n        if (l != 0) dp[l - 1][r][k] = max(dp[l - 1][r][k], dp[l][r][k]);\n        if (r != n) dp[l][r + 1][k] = max(dp[l][r + 1][k], dp[l][r][k]);\n        if (l != 0 && r != n && s[l - 1] == s[r + 1]) {\n          dp[l - 1][r + 1][k] = max(dp[l - 1][r + 1][k], dp[l][r][k] + 2);\n        }\n        if (l != 0 && r != n) {\n          dp[l - 1][r + 1][k + 1] = max(dp[l - 1][r + 1][k + 1], dp[l][r][k] + 2);\n        }\n      }\n    }\n  }\n\n  int ans = 0;\n  for (int i = 0; i <= K; i++) {\n    ans = max(ans, dp[0][n - 1][i]);\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 20;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nchar in[305];\nint dp[305][305][305];\nint main() {\n\tint N, K, i, j, k;\n\tscanf(\"%s %d\", in+1, &K);\n\tN = strlen(in + 1);\n\n\tfor (i = N; i >= 1; i--) {\n\t\tfor (k = 0; k <= K; k++) dp[i][i][k] = 1;\n\t\tfor (j = i + 1; j <= N; j++) {\n\t\t\tfor (k = 0; k <= K; k++) {\n\t\t\t\tdp[i][j][k] = max(dp[i + 1][j][k], dp[i][j - 1][k]);\n\t\t\t\tif (in[i] == in[j]) dp[i][j][k] = max(dp[i][j][k], dp[i + 1][j - 1][k] + 2);\n\t\t\t\tif (k) dp[i][j][k] = max(dp[i][j][k], dp[i + 1][j - 1][k - 1] + 2);\n\t\t\t}\n\t\t}\n\t}\n\treturn !printf(\"%d\\n\", dp[1][N][K]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[300][300][301];\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tstring s;\n\tint k;\n\tcin>>s>>k;\n\tint n = s.size();\n\tfor(int i=0;i<n;i++)\n\t\tfor(int m=0;m<=k;m++)\n\t\t\tdp[i][i][m]=1;\n\tfor(int l=2;l<=n;l++)\n\t\tfor(int i=0;i+l<=n;i++){\n\t\t\tint j=i+l-1;\n\t\t\tfor(int m=0;m<=k;m++){\n\t\t\t\tdp[i][j][m]=max(dp[i+1][j][m],dp[i][j-1][m]);\n\t\t\t\tif(s[i]==s[j])\n\t\t\t\t\tdp[i][j][m]=max(dp[i+1][j-1][m]+2,dp[i][j][m]);\n\t\t\t\tif(m){\n\t\t\t\t\tdp[i][j][m]=max(dp[i][j][m],dp[i][j][m-1]);\n\t\t\t\t\tdp[i][j][m]=max(dp[i][j][m],dp[i+1][j-1][m-1]+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcout<<dp[0][n-1][k]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#define maxn 315\n#define ll long long int\n#define rep(i, l, r) for (register int i = l; i <= r; i++)\n#define per(i, r, l) for (register int i = r; i >= l; i--)\n#define gc() ((p1 == p2 && (p2 = (p1 = buffer) + fread(buffer, 1, maxn, stdin), p1 == p2)) ? EOF : *p1++)\nusing namespace std;\n\n\nchar *p1, *p2;\nchar buffer[maxn];\ntemplate <class T> void read(T& x){\n    char ch = gc(); x = 0; bool f = 1;\n    while (!('0' <= ch && ch <= '9') && ch != '-') ch = gc();\n    if (ch == '-') f  =0, ch = gc();\n    while ('0' <= ch && ch <= '9') x = (x << 1) + (x << 3) + ch - '0', ch = gc();\n    if (!f) x = -x;\n}\n\nint n, _k;\nchar s[maxn];\n\nint dp[maxn][maxn][maxn];\nbool vis[maxn][maxn][maxn];\nint DP(int a, int b, int k){\n    if (a == n + 1 || !b) return 0;\n    if (a >= b) return a == b;\n    if (vis[a][b][k]) return dp[a][b][k];\n    vis[a][b][k] = 1;\n    int& ans = dp[a][b][k];\n    if (s[a] == s[b]) ans = max(ans, DP(a + 1, b - 1, k) + 2);\n    if (k) ans = max(ans, DP(a + 1, b - 1, k - 1) + 2);\n    ans = max(ans, DP(a + 1, b, k));\n    ans = max(ans, DP(a, b - 1, k));\n    return ans;\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(\"D.in\", \"r\", stdin);\n    #endif\n    scanf(\"%s%d\", s + 1, &_k);\n    n = strlen(s + 1);\n    printf(\"%d\", DP(1, n, _k));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=1e3+5;\nint n,nn,mm,m,i,j,A,B;\nchar c[N][N];\nint main(){\n\tscanf(\"%d%d%d%d\",&n,&m,&A,&B);\n\tfor(i=1;i<=n;++i)for(j=1;j<=m;++j)c[i][j]='.';\n\tnn=n-n%2;mm=m-m%2;\n\tif(nn<n)for(i=1;i<m && A;i+=2)c[n][i]='<',c[n][i+1]='>',--A;\n\tif(mm<m)for(i=1;i<n && B;i+=2)c[i][m]='^',c[i+1][m]='v',--B;\n\tfor(i=1;i*2<=nn;++i)for(j=1;j*2<=mm;++j){\n\t\tif(A>1 || (i*2==nn && j*2==mm)){\n\t\t\tc[i*2-1][j*2-1]='<';c[i*2-1][j*2]='>';--A;\n\t\t\tif(A)c[i*2][j*2-1]='<',c[i*2][j*2]='>',--A;\n\t\t}else if(B){\n\t\t\tc[i*2-1][j*2-1]='^';c[i*2][j*2-1]='v';--B;\n\t\t\tif(B)c[i*2-1][j*2]='^',c[i*2][j*2]='v',--B;\n\t\t}\n\t}\n\tif(!A && B && nn<n && mm<m && c[nn][mm]=='.'){\n\t\tc[n][m]='>';c[n][m-1]='<';c[n][m-2]='v';c[n-1][m-2]='^';--B;\n\t}\n\tif(A || B)return puts(\"NO\"),0;\n\tputs(\"YES\");\n\tfor(i=1;i<=n;++i)puts(c[i]+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 305, inf = 1e9;\n\nint n, k;\nchar a[N];\n\nint dt[N][N][N];\nbool vis[N][N][N];\n\nint solve (int S, int E, int X) {\n\tif(X < 0) return -inf;\n\tif(S > E) return 0;\n\tif(vis[S][E][X]) return dt[S][E][X];\n\tvis[S][E][X] = true;\n\tdt[S][E][X] = max({solve(S+1, E, X), solve(S, E-1, X), solve(S+1, E-1, X - (a[S] != a[E])) + 1 + (S != E)});\n\treturn dt[S][E][X];\n}\n\nint main()\n{\n\tscanf(\"%s%d\",a+1,&k);\n\tn = strlen(a+1);\n\tprintf(\"%d\\n\",solve(1, n, k));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 305;\n\nchar s[MAXN];\n\nint dp[MAXN][MAXN][MAXN];\n\nvoid solve(){\n\tint n, k;\n\tscanf(\"%s%d\", &s[0], &k);\n\tn = strlen(s);\n\tREP(i, 0, n) {\n\t\tdp[i][i][0] = 1;\n\t}\n\tREPN(l, 0, k) {\n\t\tfor(int i = n - 1; i >= 0; i--) {\n\t\t\tREP(j, i + 1, n) {\n\t\t\t\tdp[i][j][l] = max(dp[i + 1][j][l], dp[i][j - 1][l]);\n\t\t\t\tif (l > 0) {\n\t\t\t\t\tdp[i][j][l] = max(dp[i][j][l], dp[i][j][l - 1]);\n\t\t\t\t}\n\t\t\t\tif (s[i] == s[j]) {\n\t\t\t\t\tdp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l] + 2);\n\t\t\t\t} else if (l > 0) {\n\t\t\t\t\tdp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l - 1] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[0][n - 1][k]);\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < int(n); ++ (i))\nusing namespace std;\ntemplate <class T> inline void chmax(T & a, T const & b) { a = max(a, b); }\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\nint solve(string const & s, int k) {\n    int n = s.length();\n    auto dp = vectors(n + 1, n + 1, k + 1, int());\n    REP (l, n) {\n        REP (i, k + 1) {\n            dp[l][l + 1][i] = 1;\n        }\n    }\n    REP3 (len, 2, n + 1) {\n        REP (l, n - len + 1) {\n            int r = l + len;\n            REP (i, k + 1) {\n                int & it = dp[l][r][i];\n                if (s[l] == s[r - 1]) {\n                    chmax(it, dp[l + 1][r - 1][i] + 2);\n                }\n                if (i - 1 >= 0) {\n                    chmax(it, dp[l + 1][r - 1][i - 1] + 2);\n                }\n                chmax(it, dp[l + 1][r][i]);\n                chmax(it, dp[l][r - 1][i]);\n                if (i - 1 >= 0) {\n                    chmax(it, dp[l][r][i - 1]);\n                }\n            }\n        }\n    }\n    return dp[0][n][k];\n}\n\nint main() {\n    string s; cin >> s;\n    int k; cin >> k;\n    cout << solve(s, k) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n\t  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n\t  for(auto &e:u) fill_v<T>(e,v...);\n}\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  string s;\n  int64 K;\n  cin >> s >> K;\n  auto dp = make_v<int64>(s.size()+1, s.size()+1, K+1); // [l, r]で作れるアの最大値\n  REP(k, K+1) {\n    REP(w, s.size()) {\n      REP(l, s.size() - w) {\n        int64 r = l + w;\n        if (k+(s[l] != s[r]) <= K) {\n          if (l == r)\n            chmax(dp[l][r][k + (s[l] != s[r])], 1);\n          else\n            chmax(dp[l][r][k + (s[l] != s[r])], dp[l+1][r-1][k] + 2);\n        }\n        if (l+1 <= s.size())\n          chmax(dp[l][r][k], dp[l+1][r][k]);\n        if (r-1 >= 0)\n          chmax(dp[l][r][k], dp[l][r-1][k]);\n      }\n    }\n  }\n  int64 res = 0;\n  REP(i, s.size()) {\n    REP(j, s.size()) {\n      REP(k, K+1) {\n        chmax(res, dp[i][j][k]);\n      }\n    }\n  }\n  cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n//\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//\nconstexpr ll MOD=1e9+7;\n//constexpr ll MOD=998244353;\n//constexpr ll MOD=10000000;\n//constexpr ll MOD=1e5;\nconstexpr ll MAX=3e6;\nconstexpr ll INF=(1ll<<60);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate<typename T>\nstruct Segment_tree{\n    ll N;\n    T mem;\n    vector<T> node;\n    Segment_tree(vector<T> &X,T m):mem(m){\n        ll sz=X.size();\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mem);\n        rep(i,0,sz) node[N-1+i]=X[i];\n        per(i,N-2,0){\n            node[i]=Compare(node[i*2+1],node[i*2+2]);\n        }\n    }\n    T Compare(T &A,T &B){\n        return std::max(A,B);\n    }\n    void update(ll X,T val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=Compare(node[X*2+1],node[X*2+2]);\n        }\n    }\n    T Query(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mem;\n        if(a<=l&&r<=b) return node[now];\n        auto vl=Query(a,b,now*2+1,l,(l+r)/2),vr=Query(a,b,now*2+2,(l+r)/2,r);\n        return Compare(vl,vr);\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,int a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nvoid comp(vi &A){\n    std::map<ll,ll> mem;\n    rep(i,0,A.size()) mem[A[i]]=0;\n    ll cnt=0;\n    for(auto &p:mem) p.second=cnt++;\n    rep(i,0,A.size()) A[i]=mem[A[i]];\n}\nll RLCS(string S){\n    string T=S;\n    reverse(ALL(T));\n    ll N=S.size();\n    vii dp(N+1,vi(N+1));\n    REP(i,0,N){\n        REP(j,0,N){\n            if(!i){\n                if(j) dp[i][j]=dp[i][j-1];\n            }\n            else if(!j){\n                dp[i][j]=dp[i-1][j];\n            }\n            else{\n                dp[i][j]=std::max(dp[i][j-1],dp[i-1][j]);\n                if(S[i-1]==T[j-1]) dp[i][j]=std::max(dp[i][j],dp[i-1][j-1]+1);\n            }\n        }\n    }\n    return dp[N][N];\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    string S; cin>>S;\n    ll K,N=S.size(); cin>>K;\n    string T=S; reverse(ALL(T));\n    K=std::min(K,N/2);\n    vector<vii> dp(N/2+1,vii(N/2+1,vi(K+1,INF)));\n    dp[0][0][0]=0;\n    vii mem(26);\n    rep(i,0,N/2) mem[T[i]-'a'].pb(i+1);\n    rep(i,0,N/2){\n        REP(j,0,N/2){\n            REP(k,0,K) dp[i+1][j][k]=dp[i][j][k];\n        }\n        rep(j,0,N/2){\n            REP(k,0,K){\n                if(dp[i][j][k]==INF) continue;\n                ll X=disup(mem[S[i]-'a'],dp[i][j][k]);\n                if(X<mem[S[i]-'a'].size()){\n                    ll Y=mem[S[i]-'a'][X];\n                    dp[i+1][j+1][k]=std::min(dp[i+1][j+1][k],Y);\n                }\n                if(dp[i][j][k]<N/2&&k<K){\n                    dp[i+1][j+1][k+1]=std::min(dp[i+1][j+1][k+1],dp[i][j][k]+1);\n                }\n            }\n        }\n    }\n    ll ans=0;\n    REP(i,0,N/2){\n        REP(j,0,N/2){\n            REP(k,0,K){\n                if(dp[i][j][k]!=INF){\n                  ans=std::max(ans,j);\n                }\n            }\n        }\n    }\n    ll memo=ans;\n    per(i,N/2,0){\n        ll left=i,right=N-dp[i][memo][K]-1;\n        if(left>right) continue;\n        string P=S.substr(left,right-left+1);\n        ans=std::max(ans,memo*2+RLCS(P));\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\ntypedef long long ll;\nconst int Imx=2147483647;\nconst ll Lbig=2e18;\nconst int mod=1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==' '||c=='\\n')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=_buff.get();\n\tif(c=='-')ng=1,c=_buff.get();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c<=32)c=_buff.get();return c;}\nll qpow(ll x,ll k){return k==0?1:1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nchar s[311];\nint n,k;\nint dp[305][305][305];\nvoid upd(int &x,int v){x=max(x,v);}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tcin>>k;\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=n;j>=i;j--)\n\t\t{\n\t\t\tfor(int t=0;t<=k;t++)\n\t\t\t{\n\t\t\t\tint cur=dp[i][j][t];\n\t\t\t\tupd(ans,cur+(s[i]==s[j])*2-(i==j));\n\t\t\t\tif(t<k)upd(ans,cur+2-(i==j));\n\t\t\t\tif(i<j)\n\t\t\t\t{\n\t\t\t\t\tupd(dp[i+1][j][t],cur);\n\t\t\t\t\tupd(dp[i][j-1][t],cur);\n\t\t\t\t\tupd(dp[i+1][j-1][t],cur+(s[i]==s[j])*2-(i==j));\n\t\t\t\t\tif(t<k)upd(dp[i+1][j-1][t+1],cur+2-(i==j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define N 305\n#define int long long\n\nint dp[N][N][N];\nstring s;\n\nint find(int l, int r, int x)\n{\n    if(l>r || x<0)\n        return 0;\n\n    if(dp[l][r][x]!=-1)\n        return dp[l][r][x];\n\n    if(l==r)\n    {\n        return dp[l][r][x]=1;\n    }\n\n    int x1 = find(l+1,r,x);\n    x1 = max(x1, find(l,r-1,x));\n    \n    if(s[l]==s[r])\n    {\n        x1 = max(x1, 2+find(l+1,r-1,x));\n    }\n    else if(x>0){\n        x1 = max(x1, 2+find(l+1,r-1,x-1));\n    }\n\n    //cout<<l<<\" \"<<r<<\" \"<<x<<\" \"<<x1<<endl;\n    return dp[l][r][x]=x1;\n\n}\n\nint32_t main()\n{\n    for(int i=0;i<N;i++)\n    {\n        for(int j=0;j<N;j++)\n        {\n            for(int k=0;k<N;k++)\n            {\n                dp[i][j][k] = -1;\n            }\n        }\n    }\n\n    cin>>s;\n    int x;\n    cin>>x;\n    int n = s.length();\n    cout<<find(0,n-1,x)<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#define SIZE 305\n#define INF 1000000005\n\nusing namespace std;\n\nchar str[SIZE];\nint dp[SIZE][SIZE];\nint nxt[SIZE][SIZE];\n\nint main()\n{\n\tscanf(\"%s\",&str);\n\tint K;\n\tscanf(\"%d\",&K);\n\tint n=strlen(str);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=i;j<n;j++)\n\t\t{\n\t\t\tdp[i][j]=(str[i]==str[j])?0:1;\n\t\t}\n\t}\n\tint mx=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int l=0;l<n;l++)\n\t\t{\n\t\t\tfor(int r=l;r<n;r++)\n\t\t\t{\n\t\t\t\tnxt[l][r]=INF;\n\t\t\t\tif(dp[l][r]>K) dp[l][r]=INF;\n\t\t\t\tif(dp[l][r]!=INF)\n\t\t\t\t{\n\t\t\t\t\tif(l==r) mx=max(mx,2*i+1);\n\t\t\t\t\telse mx=max(mx,2*i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int l=0;l<n;l++)\n\t\t{\n\t\t\tfor(int r=n-1;r>=l;r--)\n\t\t\t{\n\t\t\t\tif(l<r) dp[l][r-1]=min(dp[l][r-1],dp[l][r]);\n\t\t\t\tif(l+1<=r) dp[l+1][r]=min(dp[l+1][r],dp[l][r]);\n\t\t\t}\n\t\t}\n\t\tfor(int l=0;l<n;l++)\n\t\t{\n\t\t\tfor(int r=l;r<n;r++)\n\t\t\t{\n\t\t\t\tif(dp[l][r]!=INF)\n\t\t\t\t{\n\t\t\t\t\tif(l<r)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(str[l]==str[r])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnxt[l+1][r-1]=min(nxt[l+1][r-1],dp[l][r]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnxt[l+1][r-1]=min(nxt[l+1][r-1],dp[l][r]+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int l=0;l<n;l++)\n\t\t{\n\t\t\tfor(int r=l;r<n;r++)\n\t\t\t{\n\t\t\t\tdp[l][r]=nxt[l][r];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",mx);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<stack>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<cstring>\n#include<complex>\n#include<bitset>\n#include<iostream>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> Q;\ntypedef complex<double> C;\n#define cx real()\n#define cy imag()\nconst ll INF = 1LL << 60;\nconst double DINF = 1e30;\nconst ll mod = 1000000007;\nconst ll dx[4] = {1, 0, -1, 0};\nconst ll dy[4] = {0, -1, 0, 1};\nconst C I = C(0, 1);\nconst double EPS = 1e-10;\nconst ll NCK_MAX = 510000;\n\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y) {\n  if (b == 0) {\n    x = 1, y = 0; return a;\n  }\n  ll q = a/b, g = extgcd(b, a - q*b, x, y);\n  ll z = x - q * y;\n  x = y;\n  y = z;\n  return g;\n}\n\nll invmod (ll a, ll m) { // a^-1 mod m\n  ll x, y;\n  extgcd(a, m, x, y);\n  x %= m;\n  if (x < 0) x += m;\n  return x;\n}\n\nll *fac, *finv, *inv;\n\nvoid nCk_init(ll mod) {\n  fac = new ll[NCK_MAX];\n  finv = new ll[NCK_MAX];\n  inv = new ll[NCK_MAX];\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (ll i = 2; i < NCK_MAX; i++) {\n    fac[i] = fac[i-1] * i % mod;\n    inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n    finv[i] = finv[i-1] * inv[i] % mod;\n  }\n}\n\nll nCk(ll n, ll k, ll mod) {\n  if (fac == NULL) nCk_init(mod);\n  if (n < k) return 0;\n  if (n < 0 || k < 0) return 0;\n  return fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\ntemplate <typename T>\nclass Zip {\n  vector<T> d;\n  bool flag;\n  void init() {\n    sort(d.begin(), d.end());\n    d.erase(unique(d.begin(), d.end()), d.end());\n    flag = false;\n  }\npublic:\n  Zip() {\n    flag = false;\n  }\n  void add(T x) {\n    d.push_back(x);\n    flag = true;\n  }\n  ll getNum(T x) {\n    if (flag) init();\n    return lower_bound(d.begin(), d.end(), x) - d.begin();\n  }\n  ll size() {\n    if (flag) init();\n    return (ll)d.size();\n  }\n};\n\nclass UnionFind {\n  vector<ll> par, rank; // par > 0: number, par < 0: -par\npublic:\n  UnionFind(ll n) : par(n, 1), rank(n, 0) {}\n  ll getSize(ll x) {\n    return par[find(x)];\n  }\n  ll find(ll x) {\n    if (par[x] > 0) return x;\n    return -(par[x] = -find(-par[x]));\n  }\n  void merge(ll x, ll y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (rank[x] < rank[y]) {\n      par[y] += par[x];\n      par[x] = -y;\n    } else {\n      par[x] += par[y];\n      par[y] = -x;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n  }\n  bool isSame(ll x, ll y) {\n    return find(x) == find(y);\n  }\n};\n\n\ntemplate <typename T>\nclass SegmentTree {\n  ll n;\n  vector<T> node;\n  function<T(T, T)> fun, fun2;\n  bool customChange;\n  T outValue, initValue;\npublic:\n  void init(ll num, function<T(T, T)> resultFunction, T init, T out, function<T(T, T)> changeFunction = NULL) {\n    // changeFunction: (input, beforevalue) => newvalue\n    fun = resultFunction;\n    fun2 = changeFunction;\n    customChange = changeFunction != NULL;\n    n = 1;\n    while (n < num) n *= 2;\n    node.resize(2 * n - 1);\n    fill(node.begin(), node.end(), init);\n    outValue = out;\n    initValue = init;\n  }\n  void valueChange(ll num, T value) {\n    num += n-1;\n    if (customChange) node[num] = fun2(value, node[num]);\n    else node[num] = value;\n    while (num > 0) num = (num - 1) / 2, node[num] = fun(node[num * 2 + 1], node[num * 2 + 2]);\n  }\n  T rangeQuery(ll a, ll b, ll l = 0, ll r = -1, ll k = 0) { // [a, b)\n    if (r == -1) r = n;\n    if (a <= l && r <= b) return node[k];\n    if (b <= l || r <= a) return outValue;\n    ll mid = (l + r) / 2;\n    return fun(rangeQuery(a, b, l, mid, 2*k+1), rangeQuery(a, b, mid, r, 2*k+2));\n  }\n};\n\ntemplate <typename T>\nclass Graph {\n  struct edge { ll to; T cost; };\n  struct edge_data { ll from, to; T cost; };\n\n  ll v;\n  vector<vector<edge>> e, re;\n  vector<edge_data> ed;\n  vector<bool> used;\n  vector<ll> vs, cmp;\n  bool isDirected, isMinasEdge;\npublic:\n  Graph(ll _v, bool _isDirected = true, ll range_add = 0) {\n    // range_add 0:no / 1:in / 2:out / 3:in+out\n    //_v++;\n    v = _v, isDirected = _isDirected; isMinasEdge = false;\n    e.resize(v), re.resize(v);\n  }\n  void add_edge(ll s, ll t, T cost = 1) {\n    e[s].push_back((edge){t, cost});\n    if (!isDirected) e[t].push_back((edge){s, cost});\n    else re[t].push_back((edge){s, cost});\n    ed.push_back((edge_data){s, t, cost});\n    if (cost < 0) isMinasEdge = true;\n  }\n  vector<T> dijkstra(ll s) {\n    vector<T> d(v, INF);\n    d[s] = 0;\n    auto edge_cmp = [](const edge& a, const edge& b) { return a.cost > b.cost; };\n    priority_queue<edge, vector<edge>, decltype(edge_cmp)> pq(edge_cmp);\n    pq.push((edge){s, 0});\n    while (!pq.empty()) {\n      edge temp = pq.top(); pq.pop();\n      if (d[temp.to] < temp.cost) continue;\n      for (const edge& next : e[temp.to]) {\n        T cost = temp.cost + next.cost;\n        if (d[next.to] > cost) {\n          d[next.to] = cost;\n          pq.push((edge){next.to, cost});\n        }\n      }\n    }\n    return d;\n  }\n  vector<T> bellmanford(ll s) {\n    vector<T> d(v, INF);\n    d[s] = 0;\n    for (ll i = 0; i < v; i++) {\n      for (const edge_data& temp : ed) {\n        if (d[temp.from] != INF && d[temp.to] > d[temp.from] + temp.cost) d[temp.to] = d[temp.from] + temp.cost;\n        if (!isDirected && d[temp.to] != INF && d[temp.from] > d[temp.to] + temp.cost) d[temp.from] = d[temp.to] + temp.cost;\n      }\n    }\n    for (ll i = 0; i < v; i++) {\n      for (const edge_data& temp : ed) {\n        if (d[temp.from] != INF && d[temp.to] > d[temp.from] + temp.cost) d[temp.to] = -INF;\n        if (!isDirected && d[temp.to] != INF && d[temp.from] > d[temp.to] + temp.cost) d[temp.from] = -INF;\n      }\n    }\n    return d;\n  }\n  vector<T> shortest_path(ll s) {\n    if (isMinasEdge) return bellmanford(s);\n    else return dijkstra(s);\n  }\n  T kruskal() {\n    // if (isDirected)\n    UnionFind uf(v);\n    auto edge_data_cmp = [](const edge_data& a, const edge_data& b) { return a.cost < b.cost; };\n    sort(ed.begin(), ed.end(), edge_data_cmp);\n    T ans = 0;\n    for (const edge_data& temp : ed) {\n      if (uf.isSame(temp.from, temp.to)) continue;\n      uf.merge(temp.from, temp.to);\n      ans += temp.cost;\n    }\n    return ans;\n  }\n  void scc_dfs(ll s) {\n    used[s] = true;\n    for (const edge& i : e[s]) if (!used[i.to]) scc_dfs(i.to);\n    vs.push_back(s);\n  }\n  void scc_rdfs(ll s, ll k) {\n    used[s] = true;\n    cmp[s] = k;\n    for (const edge& i : re[s]) if (!used[i.to]) scc_rdfs(i.to, k);\n  }\n  vector<ll> scc() {\n    used.resize(v);\n    fill(used.begin(), used.end(), false);\n    cmp.resize(v);\n    vs.clear();\n    for (ll i = 0; i < v; i++) if (!used[i]) scc_dfs(i);\n    used.resize(v);\n    fill(used.begin(), used.end(), false);\n    ll k = 0;\n    for (ll i = vs.size() - 1; i >= 0; i--) if (!used[vs[i]]) scc_rdfs(vs[i], k++);\n    return cmp;\n  }\n};\n\nclass RollingHash {\n  int base;\n  vector<__int128> hash;\n  vector<__int128> pw;\n  const __int128 hashmod = (1ull << 61) - 1;\npublic:\n  RollingHash(string s, int base = 10007) : base(base), hash(s.length()+1, 0), pw(s.length()+1, 1) {\n    for (int i = 0; i < (int)s.length(); i++) {\n      hash[i+1] = (hash[i] * base + s[i]) % hashmod;\n      pw[i+1] = pw[i] * base % hashmod;\n    }\n  }\n  ll get(ll a, ll b) { // [a, b)\n    __int128 tmp = hashmod + hash[b] - hash[a] * pw[b-a] % hashmod;\n    if (tmp >= hashmod) tmp -= hashmod;\n    return (ll)tmp;\n  }\n};\n\nll n, k, dp[302][302][302], ans;\nchar s[301];\n\nll solve(ll x, ll y, ll num) {\n  if (dp[x][y][num] != -1) return dp[x][y][num];\n  if (x == 0 || y == n+1) return 0;\n  ll ans = max(solve(x-1, y, num), solve(x, y+1, num));\n  if (s[x-1] == s[y-1]) ans = max(ans, solve(x-1, y+1, num)+(x==y?1:2));\n  if (x != y && num > 0) ans = max(ans, solve(x-1, y+1, num-1)+2);\n  return dp[x][y][num] = ans;\n}\n\nint main() {\n  scanf(\"%s\", s);\n  scanf(\"%lld\", &k);\n  while (s[n] != 0) n++;\n  for (ll i = 0; i <= n+1; i++) {\n    for (ll j = 0; j <= n+1; j++) {\n      for (ll k = 0; k <= n+1; k++) {\n        dp[i][j][k] = -1;\n      }\n    }\n  }\n  for (ll i = 0; i <= n; i++) ans = max(ans, solve(i, i, k));\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x);i<=(y);i++)\nusing namespace std;\n#define N 305\nint n,k,f[N][N][N];char s[N];\nint dp(int l,int r,int k){\n\tif (k<0) return -1000;\n\tif (l>r) return 0;\n\tint &res=f[l][r][k];\n\tif (~res) return res;\n\tif (l==r) return res=1;\n\tres=0;\n\tif (s[l]==s[r]) res=max(res,dp(l+1,r-1,k)+2);\n\telse res=max(res,max(max(dp(l+1,r,k),dp(l,r-1,k)),dp(l+1,r-1,k-1)+2));\n\treturn res;\n}\nint main(){\n\tscanf(\"%s%d\",s+1,&k);n=strlen(s+1);\n\tmemset(f,-1,sizeof(f));\n\tprintf(\"%d\\n\",dp(1,n,k));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\n\nint main() {\n  string s;\n  cin >> s;\n  int k;\n  cin >> k;\n  int n = s.size();\n  vector<vii> dp(n + 1, vii(n + 1, vi(k + 1, -inf)));\n  rep (i, n + 1) {\n    dp[i][i][0] = 0;\n    if (i != n) {\n      dp[i][i + 1][0] = 1;\n    }\n  }\n  rep (len, n) {\n    rep (l, n) {\n      int r = l + len;\n      if (r > n) break;\n      rep (i, k + 1) {\n        if (r != n) {\n          chmax(dp[l][r + 1][i], dp[l][r][i]);\n        }\n        if (l != 0) {\n          chmax(dp[l - 1][r][i], dp[l][r][i]);\n        }\n        if (l != 0 && r != n) {\n          if (s[l - 1] == s[r]) {\n            chmax(dp[l - 1][r + 1][i], dp[l][r][i] + 2);\n          }\n          else {\n            if (i != k) {\n              chmax(dp[l - 1][r + 1][i + 1], dp[l][r][i] + 2);\n            }\n          }\n        }\n      }\n    }\n  }\n  int ans = -inf;\n  rep (i, n + 1) {\n    rep (j, n + 1) {\n      rep (l, k + 1) {\n        chmax(ans, dp[i][j][l]);\n      }\n    }\n  }\n  cout << ans << endl;\n}\n    \n"
  },
  {
    "language": "C++",
    "code": "///A drunk man will find his way home, but a drunk bird may get lost forever...\n#include <bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds;\nusing namespace std;\n//template <typename T>\n//using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntypedef tree<double, null_type, less_equal<double>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n#define int long long\ntypedef long long ll;\ntypedef double dd;\ntypedef long double ldd;\ntypedef pair <int, int> pii;\ntypedef pair <pii , int> ppii;\n#define pb push_back\n#define pf push_front\n#define ppb pop_back()\n#define ppf pop_front()\n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define smin(x , y) x = min(x , y)\n#define smax(x , y) x = max(x , y)\n#define mp make_pair\n#define all(x) x.begin() , x.end()\n#define debug(x) cerr<< #x << \" = \" << x << endl\n#define ddebug(x, y) cerr<< #x << \" = \" << x  << \", \" << #y << \" = \" << y << endl\n#define uop(x, y) pii(min(x, y), max(x, y))\n#define mem(a, b) memset(a, b, sizeof a)\n#define sq(x) (x) * (x)\n#define out return cout << \"NO\" << endl, 0\n//const int mx = 1e5 + 10;\nint dp[305][305][305];\nint32_t main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tstring s;\n\tint k, n;\n\tcin >> s >> k;\n\tn = sz(s);\n\tfor(int l = n - 1; ~l; l--)\n\t\tfor(int r = l + 1; r <= n; r++)\n\t\t\tfor(int t = 0; t <= k; t++){\n\t\t\t\tif(r - l == 1){\n\t\t\t\t\tdp[l][r][t] = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(s[l] == s[r - 1])\n\t\t\t\t\tdp[l][r][t] = dp[l + 1][r - 1][t] + 2;\n\t\t\t\telse{\n\t\t\t\t\tdp[l][r][t] = max(dp[l + 1][r][t] , dp[l][r - 1][t]);\n\t\t\t\t\tif(t)\n\t\t\t\t\t\tsmax(dp[l][r][t] , dp[l + 1][r - 1][t - 1] + 2);\n\t\t\t\t}\n\t\t\t}\n\tcout << dp[0][n][k] << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define mod 1000000007LL\n#define eps 1e-13\n// #define PI 3.141592653589793238L\n#define INF 1000000011\n#define INFLL 1000000000000000011LL\n#define vi vector<int>\n#define vll vector<long long>\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define pil pair<int, long long>\n#define pli pair<long long, int>\n#define mp make_pair\n#define F first\n#define S second\n#define pb push_back\n#define fo(i,a,n) for(i = (a); i < (n); i++)\n#define gtl(x) getline(cin, (x))\n#define flsh fflush(stdout)\n#define sws ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)\n#define gcd __gcd\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)((a).size())\n#define io_file freopen(\"D:/Coding Problems/Contest/input_file.in\", \"r\", stdin); freopen(\"D:/Coding Problems/Contest/output_file.out\", \"w\", stdout)\n\nll modx(ll Base, ll exponent)\n{\n\tll ans = 1;\n\tif(Base == 1)\n\t\treturn Base;\n\twhile(exponent)\n\t{\n\t\tif(exponent & 1)\n\t\t\tans = (ans * Base)%mod;\n\t\tBase = (Base * Base)%mod;\n\t\texponent = exponent >> 1;\n\t}\n\treturn ans;\n}\n\nll inmodx(ll num)\n{\n\treturn (modx(num, mod-2LL));\n}\n\nbool cmp(pair < pii, int > a, pair < pii, int > b)//true for a before b\n{\n\tif(a.F.F/300 < b.F.F/300)\n\t\treturn 1;\n\tif(a.F.F/300 > b.F.F/300)\n\t\treturn 0;\n\tif(a.F.S < b.F.S)\n\t\treturn 1;\n\tif(a.F.S > b.F.S)\n\t\treturn 0;\n\tif(a.F <= b.F)\n\t\treturn 1;\n\treturn 0;\n}\n\nconst int N = (3e2) + 9;\nconst int M = (N<<2) + 9;\nconst int LOGN = ((int)log2(N)) + 3;\nconst int LOGM = ((int)log2(M)) + 3;\nconst int BUCK = 2*550;\nconst int SQRT = BUCK+9;\n\nint dp[N][N][N];\nstring s;\nint n, K;\n\nvoid solve()\n{\n\tint i, j, k, ans = 0;\n\tcin >> s;\n\tcin >> K;\n\tn = s.length();\n\tfo(i,1,n+1)\n\t\tfo(j,1,n-i+1+1)\n\t\t\tfo(k,0,K+1)\n\t\t\t{\n\t\t\t\tif(s[i-1] == s[n-j])\n\t\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k] + ((i+j <= n) ? 2 : 1));\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k]);\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i][j-1][k]);\n\t\t\t\tif(k > 0)\n\t\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k-1] + ((i+j <= n) ? 2 : 1));\n\t\t\t\tans = max(ans, dp[i][j][k]);\n\t\t\t}\n\tcout << ans << '\\n';\n\treturn;\n}\n\nint main()\n{\n\tsws;\n\tclock_t clk;\n\tclk = clock();\n\t// io_file;\n\t// srand (time(NULL));\n\n\t//Code here\n\tint t = 1, cs;\n\tcout << fixed << setprecision(9);\n\t// cin >> t;\n\tfo(cs,1,t+1)\n\t{\n\t\t// cout << \"Case #\" << cs << \": \";\n\t\tsolve();\n\t}\n\t// Code ends here\n\n\tclk = clock() - clk;\n\tcerr << fixed << setprecision(6) << \"Time: \" << ((double)clk)/CLOCKS_PER_SEC << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define pb push_back\n#define F first\n#define S second\nusing namespace std;\nconst int N = 3e2+10;\nint dp[N][N][N];\nmain(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    string s;cin>>s;\n    int k;cin>>k;\n    int n=s.length();\n    for(int i=0;i<n-1;i++)\n        for(int ch=0;ch<=k;ch++)\n            dp[i][i][ch]=1;\n    for(int i=0;i<n;i++)\n        for(int j=i+1;j<=n;j++)\n            for(int ch=0;ch<=k;ch++){\n                int curr=j-i;\n                //cout<<curr;\n                if(curr!=j){\n                    if(s[curr-1]!=s[j-1]){\n                        dp[j][curr][ch]=max(dp[j-1][curr][ch],dp[j][curr+1][ch]);\n                        if(ch>0)\n                            dp[j][curr][ch]=max(2+dp[j-1][curr+1][ch-1],dp[j][curr][ch]);\n                        continue;\n                    }\n                    else\n                        dp[j][curr][ch]=2+dp[j-1][curr+1][ch];\n                }\n            }\n    cout<<dp[n][1][k];\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nint m;\nusing namespace std;\nconst int N = 302;\nstring s;\nint f[N][N][N];\nint a[N];\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> s;\n    cin >> m;\n    for (int i = 0; i < s.size(); i++) a[i] = s[i - 1] - 'a';\n    int n = s.size(); a[0] = -1; a[n + 1] = -1;\n    f[1][n][0] = 0;\n    for (int i = 1; i <= n; i++) {\n        for (int j = n; j >= i; j--) {\n            for (int k = 0; k <= m; k++) {\n                f[i + 1][j][k] = max(f[i + 1][j][k], f[i][j][k]);\n                f[i][j - 1][k] = max(f[i][j - 1][k], f[i][j][k]);\n                if (a[i] != a[j]) {\n                    f[i + 1][j - 1][k + 1] = max(f[i + 1][j - 1][k + 1], f[i][j][k] + 1);\n                }\n                else {\n                    f[i + 1][j - 1][k] = max(f[i + 1][j - 1][k], f[i][j][k] + 1);\n                }\n            }\n        }\n    }\n    int mx = 0;\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            for (int k = 0; k <= m; k++) {\n                if (i <= j) mx = max(mx, f[i][j][k] * 2);\n                else\n                if (abs(i - j) == 2) mx = max(mx, (f[i][j][k] - 1) * 2 + 1);\n                else\n                if (abs(i - j) == 1) mx = max(mx, f[i][j][k] * 2);\n            }\n        }\n    }\n    cout << mx << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstring s; int K, dp[309][309][309];\nint main() {\n\tcin >> s >> K;\n\tstring d1 = s, d2 = s;\n\treverse(d2.begin(), d2.end());\n\tfor (int i = 0; i <= d1.size(); i++) {\n\t\tfor (int j = 0; j <= d2.size(); j++) {\n\t\t\tfor (int k = 0; k <= K; k++) {\n\t\t\t\tif (i >= 1) dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k]);\n\t\t\t\tif (j >= 1) dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k]);\n\t\t\t\tif (i >= 1 && j >= 1) {\n\t\t\t\t\tif (d1[i - 1] == d2[j - 1]) dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k] + 1);\n\t\t\t\t\telse if(k >= 1) dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k - 1] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tfor (int j = 0; j <= K; j++) {\n\t\t\tret = max(ret, dp[i][s.size() - i - 1][j] * 2 + 1);\n\t\t}\n\t}\n\tfor (int i = 0; i <= s.size(); i++) {\n\t\tfor (int j = 0; j <= K; j++) {\n\t\t\tret = max(ret, dp[i][s.size() - i][j] * 2);\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <iomanip>\n#include <functional>\n#include <cassert>\n#include <bitset>\n \nusing namespace std;\n \ntypedef long long ll;\n\nconst int N = 307;\n\nint dp[N][N][N];\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  string s;\n  cin >> s;\n  assert(s.size() % 2 == 0);\n  int k;\n  cin >> k;\n  string t = s;\n  reverse(t.begin(), t.end());\n  int n = (int)s.size() / 2;\n  string a = s.substr(0, n);\n  string b = t.substr(0, n);\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= n; ++j) {\n      for (int t = 0; t <= k; ++t) {\n        dp[i][j][t] = max(dp[i - 1][j][t], dp[i][j - 1][t]);\n        if (a[i - 1] == b[j - 1]) {\n          dp[i][j][t] = max(dp[i][j][t], dp[i - 1][j - 1][t] + 1);\n        } else if (t > 0) {\n          dp[i][j][t] = max(dp[i][j][t], dp[i - 1][j - 1][t - 1] + 1);\n        }\n      }\n    }\n  }\n  int ans = 0;\n  for (int t = 0; t <= k; ++t) ans = max(ans, dp[n][n][t]);\n  cout << 2 * ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 310;\n\nint n, k;\nint dp[maxn][maxn][maxn];\nstring s;\n\nint main(){\n\tcin >> s;\n\tn = s.length();\n\tcin >> k;\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j <= k; j++){\n\t\t\tdp[i][i+1][j] = 1;\n\t\t}\n\t}\n\n\tfor (int i = 2; i <= n; i++){\n\t\tfor (int j = 0; j <= n-i; j++){\n\t\t\tfor (int z = 0; z <= k; z++){\n\t\t\t\tdp[j][j+i][z] = max(dp[j][j+i-1][z], dp[j+1][j+i][z]);\n\t\t\t\tif (s[j] == s[j+i-1])\n\t\t\t\t\tdp[j][j+i][z] = max(dp[j][j+i][z], dp[j+1][j+i-1][z] + 2);\n\t\t\t\tif (z > 0)\n\t\t\t\t\tdp[j][j+i][z] = max(dp[j][j+i][z], dp[j+1][j+i-1][z-1] + 2);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << dp[0][n][k] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\nint Max(int x,int y){\n        return x<y?y:x;\n}\nint main(){\n        string str;\n        int k;\n        cin >> str >> k;\n        string rts=\"\";\n        for(int i=str.size()-1 ; i>=0 ; i-- ){\n                rts+=str[i];\n        }\n        int dp[310][310];\n        for(int i=0 ; i<str.size() ; i++ ){\n                dp[i][0]=0;dp[0][i]=0;\n        }\n        for(int i=1 ; i<=str.size() ; i++ ){\n                for(int j=1 ; j<=str.size() ; j++ ){\n                        if(str[i-1]==rts[j-1]){\n                                dp[i][j]=dp[i-1][j-1]+1;\n                        }else\n                                dp[i][j]=Max(dp[i-1][j],dp[i][j-1]);\n                }\n        }\n        k*=2;\n        if(dp[str.size()][str.size()]+k<=str.size())\n                cout<<dp[str.size()][str.size()]+k<<endl;\n        else\n                cout<<str.size() << endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<iostream>\nusing namespace std;\nconst int maxn=307;\n\nchar S[maxn];\nint L,K;\n\nint dp[maxn][maxn][maxn],V[maxn][maxn];\n\nint main(){\n        scanf(\"%s%d\",S+1,&K);\n        L=strlen(S+1);\n        for(int i=1;i<=L;++i) for(int j=L;j;--j) for(int k=0;k<=K;++k){\n                if(S[i]==S[j]){\n                        dp[i][j][k]=dp[i-1][j+1][k]+1;\n                }else{\n                        dp[i][j][k]=max(dp[i-1][j][k],dp[i][j+1][k]);\n                        if(k) dp[i][j][k]=max(dp[i][j][k],dp[i-1][j+1][k-1]+1);\n                }   \n        }   \n        for(int i=1;i<=L;++i) for(int j=L;j;--j){\n                V[i][j]=max(max(V[i-1][j],V[i][j+1]),dp[i][j][K]);\n        }   \n\n        int ans=0;\n        for(int i=2;i<L;++i) ans=max(ans,V[i-1][i+1]*2+1);\n        for(int i=1;i<L;++i) ans=max(ans,V[i][i+1]*2);\n        printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define reps(i,x,n) for(int i=x; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n#define X first\n#define Y second\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\nconst ll INF = 1e9+7;\n\n\nint dp[305][305][305];\nint main(){\n\t//ios_base::sync_with_stdio(false);\n\tint N, K;\n\tstring S;\n\n\tcin >> S >> K;\n\tN = S.length();\n\n\trep(k,K+1) rep(d,N) rep(l,N) if( l+d < N ){\n\t\tint inner = dp[l+1][l+d][k];\n\t\tif( S[l] == S[l+d] ){\n\t\t\tchmax(dp[l][l+d+1][k], inner + 1 + (d>0));\n\t\t}else{\n\t\t\tchmax(dp[l][l+d+1][k+1], inner + 1 + (d>0));\n\t\t}\n\t\tchmax(dp[l+1][l+d+1][k], inner);\n\t\tchmax(dp[l][l+d][k], inner);\n\t}\n\t// rep(k,K+1){\n\t// \tcout << \"k = \" << k << endl;\n\t// \trep(l,N){\n\t// \t\trep(r,N+1) cout << dp[l][r][k] << \" \";\n\t// \t\tcout << endl;\n\t// \t}\n\t// }\n\n\tint ans = 0;\n\trep(k,K+1) chmax(ans, dp[0][N][k]);\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std;\n\nint main()\n{\n\tint i,n,k,f[305][305];\n\tchar c[305],s[305];\n\tcin>>c;\n\tn=strlen(c);\n\tcin>>k;\n\t\n\tfor (i=0;i<n;i++)\n\ts[i]=c[n-i-1];\n\t\n\tmemset(f,0,sizeof(f));\n\tfor (int i=0;i<n;i++)\n\t\tfor (int j=0;j<n;j++)\n\t\t{\n\t\t\tif (i==0||j==0)\n\t\t\t{\n\t\t\t\tf[i][j]=0;\n\t\t\t\tif (i==0&&j==0&&c[i]==s[j]) f[i][j]=1;\n\t\t\t\telse if (i>0)\n\t\t\t\t{\n\t\t\t\t\tf[i][j]=f[i-1][j];\n\t\t\t\t\tif (c[i]==s[j]) f[i][j]=1;\n\t\t\t\t}\n\t\t\t\telse if (j>0)\n\t\t\t\t{\n\t\t\t\t\tf[i][j]=f[i][j-1];\n\t\t\t\t\tif (c[i]==s[j]) f[i][j-1]=1;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\t\n\t\t\tf[i][j]=f[i-1][j];\n\t\t\tif (c[i]==s[j]&&f[i-1][j-1]+1>f[i][j]) f[i][j]=f[i-1][j-1]+1;\n\t\t\tif (f[i][j]<f[i][j-1]) f[i][j]=f[i][j-1];\n\t\t}\n\t\n\tif (f[n-1][n-1]+2*k<=n) cout<<f[n-1][n-1]+2*k; else cout<<n;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\ntypedef long long ll;\ninline void Fail(){printf(\"0\");exit(0);}\n\nconst int maxn=305;\nint n,lim,ans;\nchar c[maxn];\nstring s;\nint dp[maxn][maxn][maxn];\n\nint main(){\n\tscanf(\"%s%d\",c,&lim);\n\tlim*=2;\n\ts=c;n=s.size();\n\trep(i,n)rep(j,n)rep(k,lim+1){\n\t\tif(s[i]==s[n-j-1])dp[i][j][k]=(i>=1&&j>=1?dp[i-1][j-1][k]:0)+1;\n\t\tif(i>=1)dp[i][j][k]=max(dp[i][j][k],dp[i-1][j][k]);\n\t\tif(j>=1)dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k]);\n\t\tif(s[i]!=s[n-j-1]){\n\t\t\tint tp=((i==n/2&&(n&1)||(j==n/2&&(n&1)))?2:1);\n\t\t\tif(k>=tp)dp[i][j][k]=max((i>=1&&j>=1?dp[i-1][j-1][k-tp]:0)+1,dp[i][j][k]);\n\t\t}\n//\t\tcout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<dp[i][j][k]<<endl;\n\t\tans=max(ans,dp[i][j][k]);\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n\n/*\nInput:\nttcodergraedcoctest\ntsetcocdeargredoctt\n3\natcodergr a ndcontest\ntsetnocdn a rgredocta\n3\n-----------------\nOutput:\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef pair<ll, ll> l4;\n\nconst int N = 301;\nchar s[N];\nint k;\nint d[N][N][N];\ninline void Max(int &x, int y)\n{\n  if (x < y) x = y;\n}\nint dp(int l, int r, int k)\n{\n  if (l > r) return 0;\n  int &ret = d[l][r][k];\n  if (ret == -1)\n    {\n      if (l == r) return ret = 1;\n      if (s[l] == s[r]) return ret = 2 + dp(l+1, r-1, k);\n      ret = 0;\n      Max(ret, dp(l, r-1, k));\n      Max(ret, dp(l+1, r, k));\n      if (k != 0)\n        Max(ret, 2 + dp(l+1, r-1, k-1));\n    }\n  return ret;\n}\nint main()\n{\n  scanf(\"%s %d\", s, k);\n  memset(d, -1, sizeof(d));\n  printf(\"%d\\n\", dp(0, strlen(s)-1, k));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\n\nint D[303][303][155];\nchar S[303]; int K;\n\nint main()\n{\n\tscanf(\"%s %d\", S+1,&K);\n\tint N = 0;\n\twhile (S[N + 1]) N++;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = N; j > i; j--) {\n\t\t\tfor (int k = 0; k <= K; k++) {\n\t\t\t\tD[i][j][k] = max(D[i - 1][j][k], D[i][j + 1][k]);\n\t\t\t\tif (S[i] == S[j]) D[i][j][k] = max(D[i][j][k], D[i - 1][j + 1][k] + 2);\n\t\t\t\telse {\n\t\t\t\t\tif (k) D[i][j][k] = max(D[i][j][k], D[i - 1][j + 1][k-1] + 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 1;\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = N; j > i; j--) {\n\t\t\tfor (int k = 0; k <= K; k++) {\n\t\t\t\tint d = D[i][j][k];\n\t\t\t\tif (i + 1 < j) d++;\n\t\t\t\tans = max(ans, d);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring str;\nint dp[500][500][500];\nint solve(int l, int r, int i){\n\tif(r-l == 1){\n\t\treturn dp[l][r][0] = 1;\n\t}else if(r-l == 2){\n\t\tdp[l][r][i] = 1;\n\t\tif(str[l] == str[r-1] || i > 0)dp[l][r][i] = 2;\n\t\treturn dp[l][r][i];\n\t}\n\tif(i == 0){\n\t\tif(str[l] == str[r-1])dp[l][r][0] = dp[l+1][r-1][0]+2;\n\t\telse dp[l][r][0] = max(dp[l+1][r][0], dp[l][r-1][0]);\n\t}else{\n\t\tif(str[l] == str[r-1])dp[l][r][i] = max(dp[l][r][i], dp[l+1][r-1][i]+2);\n\t\tint res1 = max(dp[l+1][r][i], dp[l][r-1][i]);\n\t\tint res2 = dp[l+1][r-1][i-1]+2;\n\t\tint res = max(res1, res2);\n\t\tdp[l][r][i] = max(dp[l][r][i], res);\n\t}\n\treturn dp[l][r][i];\n}\n\nint main(){\n\tint k, ans = 0;\n\tcin >> str >> k;\n\tint n = str.size();\n\tfor(int i = 0;i <= k;i++){\n\t\tfor(int l = n-1;l >= 0;l--){\n\t\t\tfor(int r = l+1;r <= n;r++){\n\t\t\t\tint res = solve(l, r, i);\n\t\t\t\tans = max(ans, res);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j <= n;j++)printf(\"%d \", dp[i][j][0]);\n\t\tprintf(\"\\n\");\n\t}*/\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef unsigned char uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\nconst ld pi = 3.1415926535897932384626433832795l;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 310;\nint d[N][N][N];\n\nint main () {\n\t//std::ios::sync_with_stdio(false);\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n#ifdef SG\n\tfreopen((problemname + \".in\").c_str(), \"r\", stdin);\n//\tfreopen((problemname + \".out\").c_str(), \"w\", stdout);\n#endif\n\tstring s;\n\tint K;\n\tgetline(cin, s);\n\tcin >> K;\n\tmemset(d, 0, sizeof(d));\n\tint n = sz(s);\n\tint ans = 0;\n\tforn(k, K + 1) {\n    \tforn(i, n + 1) {\n    \t\tforn(j, n + 1) {\n    \t\t\tif (i + j > n) {\n\t\t\t\t\tcontinue;    \t\t\t\t\n    \t\t\t}\n    \t\t\tif (i > 0) {\n    \t\t\t \tumx(d[i][j][k], d[i - 1][j][k]);\n    \t\t\t}\n    \t\t\tif (j > 0) {\n    \t\t\t \tumx(d[i][j][k], d[i][j - 1][k]);\n    \t\t\t}\n    \t\t\tif (i > 0 && j > 0 && s[i - 1] == s[n - j]) {\n    \t\t\t\tumx(d[i][j][k], d[i - 1][j - 1][k] + 1);\n    \t\t\t}\n    \t\t\tif (k > 0 && i > 0 && j > 0) {\n    \t\t\t\tumx(d[i][j][k], d[i - 1][j - 1][k - 1] + 1);\n    \t\t\t}\n    \t\t\tumx(ans, 2 * d[i][j][k] + (i + j < n));\n    \t\t}\n    \t}\n\t}\n\tif (sz(s) == 1) {\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tcout << ans << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iostream>\nusing namespace std;\nint kq,k,result[330][330][330];\nstring s;\nint main()\n{\n\t\tcin >> s;\n\t\tint cd = s.size();\n\t\tcin >> k;\n\t\ts = '0' + s;\n\t\tfor (int e = 1 ; e <= cd ; e++)\n\t\t{\n\t\t\t\tfor (int i = 1 ; i <= cd ; i++)\n\t\t\t\t{\n\t\t\t\t\t\tif (i + e - 1 > cd) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int f = 0 ; f <= min(k,e) ; f++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint cur = i;\n\t\t\t\t\t\t\t\tint nxt = i + e - 1;\n\t\t\t\t\t\t\t\tif (f == e)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tresult[i][e][f] = e;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (e == 2)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif (s[i] == s[i+1])\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresult[i][e][0] = 2;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresult[i][e][0] = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tresult[i][e][1] = 2;\n\t\t\t\t\t\t\t\t\t\t\t\tresult[i][e][2] = 2;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif (e - 1 > 0)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresult[i][e][f] = max(result[i][e][f] , result[i][e-1][f]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif (i + 1 <= cd)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresult[i][e][f] = max(result[i][e][f] , result[i+1][e-1][f]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif (f != 0 && e - 2 > 0 && i + 1 <= cd)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresult[i][e][f] = max(result[i][e][f] , result[i+1][e-2][f-1] + 2);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif (e - 2 >= 1)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresult[i][e][f] = max(result[i][e][f] , result[i+1][e-2][f]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif (s[cur] == s[nxt] && e - 2 > 0 && i + 1 <= cd)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresult[i][e][f] = max(result[i][e][f] , result[i+1][e-2][f] + 2);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (e == 1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tresult[i][e][f] = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tkq = max(kq , result[i][e][f]);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tcout << kq;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <iomanip>\n#include <functional>\n#include <cassert>\n#include <bitset>\n \nusing namespace std;\n \ntypedef long long ll;\n\nconst int N = 307;\n\nint dp[N][N][N];\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  string s;\n  cin >> s;\n  //assert(s.size() % 2 == 0);\n  int k;\n  cin >> k;\n  string tt = s;\n  reverse(tt.begin(), tt.end());\n  int n = s.size();\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= n; ++j) {\n      for (int t = 0; t <= k; ++t) {\n        dp[i][j][t] = max(dp[i - 1][j][t], dp[i][j - 1][t]);\n        if (s[i - 1] == tt[j - 1]) {\n          dp[i][j][t] = max(dp[i][j][t], dp[i - 1][j - 1][t] + 1);\n        } else if (t > 0) {\n          dp[i][j][t] = max(dp[i][j][t], dp[i - 1][j - 1][t - 1] + 1);\n        }\n      }\n    }\n  }\n  for (int i = 0; i <= n; ++i) {\n    for (int j = 0; j <= n; ++j) {\n      for (int t = 0; t <= k; ++t) {\n        dp[i][j][k] = max(dp[i][j][k], dp[i][j][t]);\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i <= n; ++i) {\n    ans = max(ans, 2 * dp[i][n - i][k]);\n  }\n  ans = max(ans, dp[n][n][k]);\n  if (n % 2 == 1) {\n    ans = max(ans, 2 * dp[n / 2][n / 2][k] + 1);\n  }\n  cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nshort dp[305][305][305];\nchar in[310];\nvoid upd(short &x, short y) {\n\tif (x < y) x = y;\n}\nint main() {\n\tint n, k;\n\tscanf(\"%s%d\", in+1, &k);\n\tn = strlen(in+1);\n\tfor (int i = 1; i <= n; i++) for (int j = 0; j <= k; j++) dp[i][i][0] = 1;\n\tfor (int d = 1; d <= n; d++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = i + d;\n\t\t\tfor (int t = 0; t <= k; t++) {\n\t\t\t\tupd(dp[i][j][t], dp[i + 1][j][t]);\n\t\t\t\tupd(dp[i][j][t], dp[i][j - 1][t]);\n\t\t\t}\n\t\t\tif (in[i] == in[j]) {\n\t\t\t\tfor (int t = 0; t <= k; t++) upd(dp[i][j][t], dp[i + 1][j - 1][t] + 2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int t = 1; t <= k; t++) upd(dp[i][j][t], dp[i + 1][j - 1][t-1] + 2);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[1][n][k]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long \n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define F first\n#define S second\nint const M=300+10;\nint dp[M][M][M];\nstring x;\nvoid fdp(int i,int j,int k)\n{\n\tif(i==j)\n\t{\n\t\tdp[i][j][k]=1;\n\t\treturn;\n\t}\n\tif(x[i]==x[j])\n\t{\n\t\tdp[i][j][k]=dp[i+1][j-1][k]+2;\n\t}\n\telse \n\t{\n\t\tdp[i][j][k]=max(dp[i+1][j][k],dp[i][j-1][k]);\n\t\tif(k!=0)\n\t\t\tdp[i][j][k]=max(dp[i][j][k],dp[i+1][j-1][k-1]+2);\n\t}\n}\nmain()\n{\n\tcin>>x;\t\n\tint k;\n\tcin>>k;\n\tint n=x.size();\n\treverse(x.begin(),x.end());\n\tx+='0';\n\treverse(x.begin(),x.end());\n\tfor(int t=0;t<=n-1;t++)\n\t{\n\t\tfor(int j=1+t;j<=n;j++)\n\t\t{\n\t\t\tfor(int l=0;l<=k;l++)\n\t\t\t{\n\t\t\t\tfdp(j-t,j,l);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[1][n][k];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MaxN = 300;\nconst int MaxM = 300;\n\nint n, m;\nchar s[MaxN + 2];\n\nint f[MaxN + 1][MaxN + 1][MaxM + 1];\n\nint main()\n{\n\tcin >> s + 1 >> m;\n\n\tn = strlen(s + 1);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 0; j <= m; ++j)\n\t\t\tf[i][i][j] = 1;\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tf[i][i + 1][0] = 1 + (s[i] == s[i + 1]);\n\t\tfor (int j = 1; j <= m; ++j)\n\t\t\tf[i][i + 1][j] = 2;\n\t}\n\n\tfor (int k = 3; k <= n; ++k)\n\t\tfor (int l = 1; l <= n - k + 1; ++l)\n\t\t{\n\t\t\tint r = l + k - 1;\n\t\t\tfor (int i = 0; i <= m; ++i)\n\t\t\t{\n\t\t\t\tint j = i - (s[l] != s[r]);\n\t\t\t\tint w = j >= 0 ? f[l + 1][r - 1][j] + 2 : -1;\n\t\t\t\tf[l][r][i] = max(f[l + 1][r][i], f[l][r - 1][i]);\n\t\t\t\tf[l][r][i] = max(f[l][r][i], w);\n\t\t\t}\n\t\t}\n\n\tcout << f[1][n][m] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dp[303][303][303];\nstring s;\n\nint getdp(int i, int j, int k){\n    if (i<0) return -1;\n    if (j>k) return 0;\n    if (j == k) return 1;\n    if (dp[i][j][k] != -1) return dp[i][j][k];\n    int res = -1;\n    if (s[j] == s[k]) res = max(getdp(i, j+1, k-1)+2, max(getdp(i, j+1, k), getdp(i, j, k-1)));\n    else res = max(getdp(i-2, j+1, k-1)+2, max(getdp(i, j+1, k), getdp(i, j, k-1)));\n    dp[i][j][k] = res;\n    return res;\n}\n\nint main(){\n    cin >> s;\n    int k; cin >> k;\n    for(int i=0; i<302; i++)for(int j=0; j<302; j++)for(int k=0; k<302; k++) dp[i][j][k] = -1;\n    cout << getdp(k, 0, s.size()-1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <iomanip>\n#include <functional>\n#include <cassert>\n#include <bitset>\n \nusing namespace std;\n \ntypedef long long ll;\n\nconst int N = 307;\n\nint dp[N][N][N];\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  string s;\n  cin >> s;\n  //assert(s.size() % 2 == 0);\n  int k;\n  cin >> k;\n  string tt = s;\n  reverse(tt.begin(), tt.end());\n  int n = s.size();\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= n; ++j) {\n      for (int t = 0; t <= k; ++t) {\n        dp[i][j][t] = max(dp[i - 1][j][t], dp[i][j - 1][t]);\n        if (s[i - 1] == tt[j - 1]) {\n          dp[i][j][t] = max(dp[i][j][t], dp[i - 1][j - 1][t] + 1);\n        } else if (t > 0) {\n          dp[i][j][t] = max(dp[i][j][t], dp[i - 1][j - 1][t - 1] + 1);\n        }\n      }\n    }\n  }\n  for (int i = 0; i <= n; ++i) {\n    for (int j = 0; j <= n; ++j) {\n      for (int t = 0; t <= k; ++t) {\n        dp[i][j][k] = max(dp[i][j][k], dp[i][j][t]);\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i <= n; ++i) {\n    ans = max(ans, 2 * dp[i][n - i][k]);\n  }\n  cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n\nconst int MAXN = 301;\n\nint f[MAXN][MAXN][MAXN];\n\nint main() {\n#ifdef BZ\n    freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\n#endif\n    ios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20); cout.tie(nullptr); cin.tie(nullptr);\n    string s;\n    int k;\n    cin >> s >> k;\n    string t(s.rbegin(), s.rend());\n    int n = s.length();\n    s += '#';\n    t += '#';\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 0; j <= n; ++j) {\n            for (int l = 0; l <= k; ++l) {\n                int c = f[i][j][l];\n                f[i + 1][j][l] = max(f[i + 1][j][l], c);\n                f[i][j + 1][l] = max(f[i][j + 1][l], c);\n                int& nv = f[i + 1][j + 1][l + (s[i] != t[j])];\n                nv = max(nv, c + 1);\n            }\n        }\n    }\n\n    int ans = 0;\n\n    for (int i = 0; i < n; ++i) {\n        ans = max(ans, f[i][n - 1 - i][k] * 2 + 1);\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        ans = max(ans, f[i][n - i][k] * 2);\n    }\n\n    cout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef long long int ll;\n\nint dp[305][305][305];\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tstring s; cin >> s;\n\tint m; cin >> m;\n\tint n=s.size();\n\tstring t=s;\n\treverse(t.begin(),t.end());\n\tint ans=0;\n\tfor(int i=0;i<n+1;i++){\n\t\tfor(int j=0;j<n+1;j++){\n\t\t\tfor(int k=0;k<m+1;k++){\n\t\t\t\tans=max(ans,dp[i][j][k]);\n\t\t\t\tif(i+j>n-1)continue;\n\t\t\t\tdp[i+1][j][k]=max(dp[i+1][j][k],dp[i][j][k]);\n\t\t\t\tdp[i][j+1][k]=max(dp[i][j+1][k],dp[i][j][k]);\n\t\t\t\tint x=(i+j==n-1)?1:2;\n\t\t\t\tif(s[i]==t[j]){\n\t\t\t\t\tdp[i+1][j+1][k]=max(dp[i+1][j+1][k],dp[i][j][k]+x);\n\t\t\t\t}else{\n\t\t\t\t\tdp[i+1][j+1][k+1]=max(dp[i+1][j+1][k+1],dp[i][j][k]+x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\n\nconst int N=305;\n\nint n,m;\nint dp[N][N][N];\nchar s[N];\n\nint main(){\n\tint l,r,k,d,i;\n\tscanf(\"%s\",s+1); n=strlen(s+1);\n\tscanf(\"%d\",&m);\n\tfor (i=1;i<=n;i++)\n\t\tfor (k=0;k<=m;k++) dp[i][i][k]=1;\n\tfor (d=2;d<=n;d++){\n\t\tfor (l=1;l+d-1<=n;l++){\n\t\t\tr=l+d-1;\n\t\t\tfor (k=0;k<=m;k++){\n\t\t\t\tif (k) dp[l][r][k]=max(dp[l][r][k],dp[l][r][k-1]);\n\t\t\t\tdp[l][r][k]=max(dp[l][r][k],dp[l+1][r][k]);\n\t\t\t\tdp[l][r][k]=max(dp[l][r][k],dp[l][r-1][k]);\n\t\t\t\tif (s[l]==s[r]) dp[l][r][k]=max(dp[l][r][k],dp[l+1][r-1][k]+2);\n\t\t\t\tif (k) dp[l][r][k]=max(dp[l][r][k],dp[l+1][r-1][k-1]+2);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[1][n][m]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n\nstring str[2];\nint n,k;\nint dp[305][305][305];\nint dp2[305][305][305];\n\nint solve(int f,int t,int r){\n\t//printf(\"%d %d %d\\n\",f,t,r);\n\tif(r<=-1)return -514514;\n\tif(f>=t)return 0;\n\tif(dp2[f][t][r]!=-1)return dp2[f][t][r];\n\tint maxi=0;\n\tif(str[0][f]==str[0][t-1]){\n\t\tif(f+1==t){\n\t\t\tmaxi=max(maxi,1);\n\t\t}else{\n\t\t\tmaxi=max(maxi,solve(f+1,t-1,r)+2);\n\t\t}\n\t}else{\n\t\tmaxi=max(maxi,solve(f+1,t-1,r-1)+2);\n\t}\n\tmaxi=max(maxi,solve(f+1,t,r));\n\tmaxi=max(maxi,solve(f,t-1,r));\n\t//printf(\"%d %d %d %d\\n\",f,t,r,maxi);\n\treturn (dp2[f][t][r]=maxi);\n}\n\nint main(void){\n\tmemset(dp2,-1,sizeof(dp2));\n\tcin >> str[0];\n\tscanf(\"%d\",&k);\n\tn=str[0].size();\n\tfor(int i=0;i<n;i++){\n\t\tstr[1]+=str[0][i];\n\t}\n\treverse(str[1].begin(),str[1].end());\n\tmemset(dp,-1,sizeof(dp));\n\tdp[0][0][0]=0;\n\tint ans=0;\n\tfor(int i=0;i<=n/2;i++){\n\t\tfor(int j=0;j<=n/2;j++){\n\t\t\tfor(int a=0;a<=k;a++){\n\t\t\t\tif(dp[i][j][a]>=0){\n\t\t\t\t\tans=max(ans,solve(i,n-j,k-a)+dp[i][j][a]*2);\n\t\t\t\t\tdp[i+1][j][a]=max(dp[i+1][j][a],dp[i][j][a]);\n\t\t\t\t\tdp[i][j+1][a]=max(dp[i][j+1][a],dp[i][j][a]);\n\t\t\t\t\tif(i<n && j<n){\n\t\t\t\t\t\tif(str[0][i]==str[1][j]){\n\t\t\t\t\t\t\tdp[i+1][j+1][a]=max(dp[i+1][j+1][a],dp[i][j][a]+1);\n\t\t\t\t\t\t}else if(a<k){\n\t\t\t\t\t\t\tdp[i+1][j+1][a+1]=max(dp[i+1][j+1][a+1],dp[i][j][a]+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Maxn 307\nusing namespace std;\nchar s[Maxn];\nint n,k;\nint f[Maxn][Maxn][Maxn];\nint calc(int x,int y)\n{\n\tif (s[x]==s[y]) return 0;\n\treturn 1;\n}\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tscanf(\"%d\",&k);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=0;j<=k;j++)\n\t\t\tf[i][i][j]=1;\n\tfor (int del=1;del<n;del++)\n\t\tfor (int i=1;i+del<=n;i++)\n\t\t{\n\t\t\tint j=i+del;\n\t\t\tfor (int r=0;r<=k;r++)\n\t\t\t{\n\t\t\t\tf[i][j][r]=max(f[i+1][j][r],f[i][j-1][r]);\n\t\t\t\tint t=calc(i,j);\n\t\t\t\tif (r>=t) \n\t\t\t\t{\n\t\t\t\t\tif (i+1>j-1) f[i][j][r]=max(1,f[i][j][r]);\n\t\t\t\t\telse f[i][j][r]=max(f[i][j][r],f[i+1][j-1][r-t]+2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\",f[1][n][k]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[305][305][305];\n\nint main(){\n  \n  string s;\n  int K;\n  \n  cin>>s>>K;\n  \n  memset(dp,-1,sizeof(dp));\n\n  s='x'+s;\n  \n  int len=s.size();\n  \n  dp[1][len][0]=0;\n  \n  for(int l=1;l<=len;l++)\n    \n    for(int r=len;r>=l;r--){\n      \n      for(int k=0;k<K;k++){\n\t\n\tif(dp[l][r][k]==-1) continue;\n\t\n\tif(s[l]==s[r]){\n\t  if(l==r) dp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]+1);\n\t  else dp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]+2);\n\t}\n\t\n\tif(l==r) continue;\n\t\n\tdp[l+1][r-1][k+1]=max(dp[l+1][r-1][k+1], dp[l][r][k]+2);\n\tdp[l+1][r][k]=max(dp[l+1][r][k], dp[l][r][k]);\n\tdp[l][r-1][k]=max(dp[l][r-1][k], dp[l][r][k]);\n\tdp[l+1][r-1][k]=max(dp[l+1][r-1][k], dp[l][r][k]);\n      }\n    }\n  \n  int ans=0;\n  \n  for(int i=0;i<=len;i++)\n    for(int j=0;j<=len;j++)\n      for(int k=0;k<=K;k++) ans=max(ans, dp[i][j][k]);\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\ntypedef long double ld;\nconst int INF=1e9,MOD=1e9+7,ohara=1e6+10;\nconst ll LINF=1e18;\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define rrep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrrep(i,a,b) for(int i=(a);i>=(b);i--)\n#define all(v) (v).begin(), (v).end()\n#define Size(n) (n).size()\n#define Cout(x) cout<<(x)<<endl\n#define Cerr(x) cerr<<(x)<<endl\n#define fi first\n#define se second\n\nll n,cnt,ans,a,b,c,d,tmp,tmpp,m,h,w,x,y,sum,pos,K;\nld doua;\nint dy[]={1,0,-1,0};\nint dx[]={0,1,0,-1};\n//int dy[]={-1,0,1,-1,1,-1,0,1};\n//int dx[]={-1,-1,-1,0,0,1,1,1};\nstring alph(\"abcdefghijklmnopqrstuvwxyz\"),s;\nbool fl;\nstruct edge{int to,cost;};\nll dp[305][305][305];//l～rでK回変更の最長\n\n//-------------------------↓↓↓↓↓↓------------------------\n\nint main(void){\n       cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin>>s>>K;\n    rrrep(i,Size(s)-1,0){\n        rrep(j,i,Size(s)){\n            rep(k,K+1){\n                if(i==j){\n                    dp[i][j][k]=1;\n                }\n                else if(i+1==j){\n                    if(s[i]==s[j]){\n                        dp[i][j][k]=2;\n                    }\n                    else if(k>0){\n                        dp[i][j][k]=2;\n                    }\n                    else{\n                        dp[i][j][k]=1;\n                    }\n                }\n                else{\n                    dp[i][j][k]=max(dp[i+1][j][k],dp[i][j-1][k]);\n                    if(s[i]==s[j]){\n                        dp[i][j][k]=max(dp[i+1][j-1][k]+2,dp[i][j][k]);\n                    }\n                    if(k>0){\n                        dp[i][j][k]=max(dp[i+1][j-1][k-1]+2,dp[i][j][k]);\n                    }\n                }\n            }\n        }\n    }\n    Cout(dp[0][Size(s)-1][K]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n\nstring s;\nint dp[334][334][334];\n\nint solve(int a, int b, int k) {\n\tif(dp[a][b][k] < 0) {\n\t\tdp[a][b][k] = 0;\n\t\tif(a > 0) {\n\t\t\tdp[a][b][k] = max(dp[a][b][k], solve(a - 1, b, k));\n\t\t}\n\t\tif(b > 0) {\n\t\t\tdp[a][b][k] = max(dp[a][b][k], solve(a, b - 1, k));\n\t\t}\n\t\tif(a > 0 && b > 0) {\n\t\t\tif(s[a - 1] == s[s.size() - b]) {\n\t\t\t\tdp[a][b][k] = max(dp[a][b][k], solve(a - 1, b - 1, k) + 1);\n\t\t\t}\n\t\t\tif(k > 0) {\n\t\t\t\tdp[a][b][k] = max(dp[a][b][k], solve(a - 1, b - 1, k - 1) + 1);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[a][b][k];\n}\n\nsigned main() {\n\tcin >> s;\n\tint k;\n\tcin >> k;\n\trep(i, s.size() + 2) {\n\t\trep(j, s.size() + 2) {\n\t\t\trep(k, s.size() + 2) {\n\t\t\t\tdp[i][j][k] = -1;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\trep(i, s.size()) {\n\t\tans = max(ans, solve(i, s.size() - i, k) * 2);\n\t}\n\trep(i, s.size() - 1) {\n\t\tans = max(ans, solve(i, s.size() - i - 1, k) * 2 + 1);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[301][301][301];\nint main() {\n  string S;\n  int K;\n  cin >> S >> K;\n  for(auto i = 0; i < S.size(); ++i) dp[i][i][0] = dp[i][i+1][0] = 1;\n  for(auto w = 0; w <= S.size(); ++w) for(auto l = 0; l+w <= S.size(); ++l) {\n    auto r = l + w;\n    for(auto k = 0; k < K; ++k) {\n      if(0 <= l-1)        dp[l-1][r][k] = max(dp[l-1][r][k], dp[l][r][k]);\n      if(r+1 <= S.size()) dp[l][r+1][k] = max(dp[l][r+1][k], dp[l][r][k]);\n      if(0<=l-1 && r+1<=S.size()) {\n        dp[l-1][r+1][k] = max(dp[l-1][r+1][k], dp[l][r][k]);\n        dp[l-1][r+1][k+1] = max(dp[l-1][r+1][k+1], 2 + dp[l][r][k]);\n        if(S[l-1]==S[r]) dp[l-1][r+1][k] = max(dp[l-1][r+1][k], 2 + dp[l][r][k]);\n      }\n    }\n  }\n  cout << dp[0][S.size()][K] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <iomanip>\n#include <functional>\n#include <cassert>\n#include <bitset>\n \nusing namespace std;\n \ntypedef long long ll;\n\nconst int N = 307;\n\nint dp[N][N][N];\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  string s;\n  cin >> s;\n  //assert(s.size() % 2 == 0);\n  int k;\n  cin >> k;\n  string tt = s;\n  reverse(tt.begin(), tt.end());\n  int n = s.size();\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= n; ++j) {\n      for (int t = 0; t <= k; ++t) {\n        dp[i][j][t] = max(dp[i - 1][j][t], dp[i][j - 1][t]);\n        if (s[i - 1] == tt[j - 1]) {\n          dp[i][j][t] = max(dp[i][j][t], dp[i - 1][j - 1][t] + 1);\n        } else if (t > 0) {\n          dp[i][j][t] = max(dp[i][j][t], dp[i - 1][j - 1][t - 1] + 1);\n        }\n      }\n      for (int t = 1; t <= k; ++t) dp[i][j][t] = max(dp[i][j][t], dp[i][j][t - 1]);\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i <= n; ++i) {\n    ans = max(ans, 2 * dp[i][n - i][k]);\n  }\n  ans = max(ans, dp[n][n][k]);\n  if (n % 2 == 1) {\n    ans = max(ans, 2 * dp[n / 2][n / 2][k] + 1);\n  }\n  cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<vector>\n#include<functional>\n\nusing namespace std;\n\nint memo[301][301][301];\nint visited[301][301][301];\nchar S[301];\nint K, len;\n\nint max(int i, int j) { if (i > j) { return i; } else { return j; } }\nint dp(int i, int j, int k) {\n\tint M;\n\tif (visited[i][j][k] == 1) { return memo[i][j][k]; }\n\n\tif (i == j) {\n\t\tmemo[i][j][k] = 0;\n\t\tvisited[i][j][k] = 1;\n\t}\n\telse if (i + 1 == j) {\n\t\tmemo[i][j][k] = 1;\n\t\tvisited[i][j][k] = 1;\n\t}\n\telse {\n\t\tM = max(dp(i+1,j,k), dp(i,j-1,k));\n\t\tif (S[i] == S[j - 1]) { M = max(M, dp(i + 1,j - 1,k) + 2); }\n\t\telse if (k >= 1) { M = max(M, dp(i + 1,j - 1,k - 1) + 2); }\n\t\tmemo[i][j][k] = M;\n\t\tvisited[i][j][k] = 1;\n\t}\n\treturn memo[i][j][k];\n}\n\nint main() {\n\tscanf(\"%s\", S);\n\tscanf(\"%d\", &K);\n\tlen = strlen(S);\n\n\tfor (int i = 0; i < 301; i++) {\n\t\tfor (int j = 0; j < 301; j++) {\n\t\t\tfor (int k = 0; k < 301; k++) {\n\t\t\t\tvisited[i][j][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", dp(0, len, K));\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n#define N (305)\nint f[N][N][N];\nchar s[N];\nint kk;\nint main(){\n    scanf(\"%s%d\", s+1, &kk);\n    int n = strlen(s+1);\n    for (int i = 1; i <= n; ++i){\n        for (int j = n; j >= i; --j){\n            f[i][j][0] = max(f[i-1][j][0], f[i][j+1][0]);\n            if (s[i] == s[j]){\n                f[i][j][0] = max(f[i][j][0], f[i-1][j+1][0]+1);\n            }\n        }\n    }\n    for (int k = 1; k <= kk; ++k){\n        for (int i=1; i <= n; ++i){\n            for (int j = n; j>=i; --j){\n                f[i][j][k] = max(max(f[i-1][j][k], f[i][j+1][k]), f[i-1][j+1][k-(s[i]!=s[j])]+1);\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; ++i){\n        ans = max(2*f[i][i+1][kk], ans);\n        ans = max(2*f[i-1][i+1][kk]+1, ans);\n    }\n    printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <random>\n#include <cassert>\n#include <cstring>\n#include <chrono>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstring s;\nint k;\n\nint ans[300][300][301];\n\nint Solve(int l, int r, int k) {\n  if (k < 0) return -1000;\n  if (l > r) return 0;\n  if (l == r) return 1;\n  int& result = ans[l][r][k];\n  if (result != -1) return result;\n\n  result = 0;\n\n  result = max(result, Solve(l + 1, r, k));\n  result = max(result, Solve(l, r - 1, k));\n  result = max(result, 2 + Solve(l + 1, r - 1, k - (s[l] == s[r] ? 0 : 1)));\n\n  return result;\n}\n\nint main()\n{\n  cin >> s >> k;\n\n  memset(ans, -1, sizeof(ans));\n  cout << Solve(0, s.size() - 1, k) << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar s[305],c[305];\nint k;\nint f[305][305][305];\ninline int mymax(int a,int b,int c)\n{\n\treturn max(max(a,b),c);\n}\nint main() {\n\tscanf(\"%s\",s);\n\tscanf(\"%d\",&k);\n\tint n = strlen(s);\n\tfor (int i=0;i<n/2;i++)\n\t\tc[i]=s[n-i-1];\n\tf[0][0][0]=0;\n\t\n\t\tfor(int i=1; i<=n/2; i++) {\n\t\t\tfor(int j=1; j<=n/2; j++) {for(int m=0; m<=k; m++) {\n\t\t\t\tif(s[i-1]==c[j-1])\n\t\t\t\t\tf[i][j][m] = max(f[i-1][j-1][m]+1,f[i][j][m]);\n\t\t\t\telse\n\t\t\t\t{\t\n\t\t\t\t\tf[i][j][m] = mymax(f[i][j][m], f[i-1][j][m], f[i][j-1][m]);\n\t\t\t\t\tif(m)\n\t\t\t\t\t\tf[i][j][m] = max(f[i][j][m], f[i-1][j-1][m-1]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<f[n/2][n/2][k]*2 + n%2;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing PII = pair<ll, ll>;\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\ntemplate<typename T> void chmin(T &a, const T &b) { a = min(a, b); }\ntemplate<typename T> void chmax(T &a, const T &b) { a = max(a, b); }\nstruct FastIO {FastIO() { cin.tie(0); ios::sync_with_stdio(0); }}fastiofastio;\n#ifdef DEBUG_ \n#include \"../program_contest_library/memo/dump.hpp\"\n#else\n#define dump(...)\n#endif\nconst ll INF = 1LL<<60;\n\nll dp[305][305][305];\nint main(void) {\n    string s;\n    ll m;\n    cin >> s >> m;\n    ll n = s.size();\n\n    REP(i, n) REP(j, m+1) dp[i][i][j] = 1;\n    REP(i, n-1) {\n        dp[i][i+1][0] = (s[i]==s[i+1] ? 2 : 1);\n        FOR(j, 1, m+1) dp[i][i+1][j] = 2; \n    }\n\n    FOR(w, 1, n+1) REP(l, n-w+1) {\n        ll r = l+w-1;\n        REP(i, m+1) {\n            if(l-1>=0) chmax(dp[l-1][r][i], dp[l][r][i]);\n            if(r+1<n) chmax(dp[l][r+1][i], dp[l][r][i]);\n            if(l-1>=0 && r+1<n && s[l-1]==s[r+1]) chmax(dp[l-1][r+1][i], dp[l][r][i]+2);\n            if(l-1>=0 && r+1<n && i+1<=m) chmax(dp[l-1][r+1][i+1], dp[l][r][i]+2);\n        }\n    }\n\n    cout << dp[0][n-1][m] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define int long long\n#define REP(i, n) for (int i = 0; i < (int)n; ++i)\n#define RREP(i, n) for (int i = (int)n - 1; i >= 0; --i)\n#define FOR(i, s, n) for (int i = s; i < (int)n; ++i)\n#define RFOR(i, s, n) for (int i = (int)n - 1; i >= s; --i)\n#define ALL(a) a.begin(), a.end()\n#define IN(a, x, b) (a <= x && x < b)\ntemplate<class T>istream&operator >>(istream&is,vector<T>&vec){for(T&x:vec)is>>x;return is;}\ntemplate<class T>inline void out(T t){cout << t << \"\\n\";}\ntemplate<class T,class... Ts>inline void out(T t,Ts... ts){cout << t << \" \";out(ts...);}\ntemplate<class T>inline bool CHMIN(T&a,T b){if(a > b){a = b;return true;}return false;}\ntemplate<class T>inline bool CHMAX(T&a,T b){if(a < b){a = b;return true;}return false;}\nconstexpr int INF = 1e18;\n\nint dp[303][303][303];\n\nsigned main(){\n\tstring s;\n\tint K;\n\tcin >> s >> K;\n\tint N = s.size();\n\tREP(i, N) {\n\t\tREP(j, N) {\n\t\t\tif(i > N - j - 1) continue;\n\t\t\tREP(k, N + 1) {\n\t\t\t\tCHMAX(dp[i + 1][j][k], dp[i][j][k]);\n\t\t\t\tCHMAX(dp[i][j + 1][k], dp[i][j][k]);\n\t\t\t\tCHMAX(dp[i + 1][j + 1][k + (s[i] != s[N - j - 1])], dp[i][j][k] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tREP(i, N + 1) REP(j, N + 1) REP(k, K + 1) CHMAX(ans, dp[i][j][k] * 2 - (i + j != N));\n\tout(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint dp[301][301][301];\nint main()\n{\n\tstring str;\n\tint q;\n\tcin>>str>>q;\n\tint l=str.size();\n//\tcout<<l<<endl;\n\tfor(int i=l-1;i>=0;i--)\n\t{\n\t\tfor(int k=0;k<=q;k++)\n\t\t\tdp[i][i][k]=1;\n\t}\n\tfor(int i=l-1;i>=0;i--)\n\t{\n\t\t\n\t\tfor(int j=i+1;j<=l-1;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=q;k++)\n\t\t\t{\n\t\t\t\t//dp[i][i][k]=1; \n\t\t\t\tif(str[i]==str[j]) dp[i][j][k]=dp[i+1][j-1][k]+2;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(k!=0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][j][k]=max(dp[i+1][j][k-1]+2,dp[i][j-1][k-1]+2);\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j][k]=max(dp[i+1][j][k],dp[i][j][k]);\n\t\t\t\t\tdp[i][j][k]=max(dp[i][j-1][k],dp[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int k=0;k<=q;k++)\n\t\t\tans=max(ans,dp[0][l-1][k]);\n\tcout<<ans<<endl;\n } "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T, class S, class U, class V> void writerLn(T x, S y, U z, V v) { writer(x, ' '); writer(y, ' '); writer(z, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\nll mod_inv(ll a, ll m) { ll x, y; extgcd<ll>(a, m, x, y); return (m + x % m) % m; }\n\nstring s;\nint dp[301][301][301];\n\nint dfs(int l, int r, int k) {\n\tint& ret = dp[l][r][k];\n\tif (ret >= 0) return ret;\n\tconst int len = r - l;\n\tif (len == 1) {\n\t\treturn ret = 1;\n\t} else if (len == 2) {\n\t\tret = 1;\n\t\tif (s[l] == s[l + 1] || k > 0) {\n\t\t\tret = 2;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tif (s[l] == s[r - 1]) {\n\t\tret = dfs(l + 1, r - 1, k) + 2;\n\t} else {\n\t\tret = dfs(l + 1, r - 1, k);\n\t\tif (k > 0) {\n\t\t\tchmax(ret, dfs(l + 1, r - 1, k - 1) + 2);\n\t\t}\n\t}\n\n\tchmax(ret, dfs(l + 1, r, k));\n\tchmax(ret, dfs(l, r - 1, k));\n\n\treturn ret;\n}\n\n\nint main() {\n\treader(s);\n\tint K; reader(K);\n\tmemset(dp, -1, sizeof(dp));\n\tint ans = dfs(0, sz(s), K);\n\twriterLn(ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define enum(i,x,y) for(int i=(x);i<=(y);++i)\n#define try(i,x,y) for(int i=(x);i>=(y);--i)\ntemplate <typename TYPE> inline void chkmax(TYPE &x,TYPE y){x<y?x=y:0;}\ntemplate <typename TYPE> inline void chkmin(TYPE &x,TYPE y){y<x?x=y:0;}\ntemplate <typename TYPE> void readint(TYPE &x)\n{\n    x=0;int f=1;char c;\n    for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;\n    for(;isdigit(c);c=getchar())x=x*10+c-'0';\n    x*=f;\n}\nconst int MAXN=305;\n\nint n,m;\nchar s[MAXN];\nint f[MAXN][MAXN][MAXN];\n\nint main()\n{\n\t#ifndef ONLINE_JUDGE\n    //freopen(\"code.in\",\"r\",stdin);\n    //freopen(\"code.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%s\",s+1);readint(m);n=strlen(s+1);\n\tenum(i,1,n)\n\t\tenum(k,0,m)\n\t\t\tf[i][i][k]=1;\n\tenum(len,2,n)\n\t\tenum(i,1,n-len+1)\n\t\t{\n\t\t\tint j=i+len-1;\n\t\t\tenum(k,0,m)\n\t\t\t{\n\t\t\t\tf[i][j][k]=max(f[i+1][j][k],f[i][j-1][k]);\n\t\t\t\tif(len>=3 && s[i]==s[j])chkmax(f[i][j][k],f[i+1][j-1][k]+2);\n\t\t\t\tif(len>=3 && k)chkmax(f[i][j][k],f[i+1][j-1][k-1]+2);\n\t\t\t}\n\t\t}\n\tprintf(\"%d\\n\",f[1][n][m]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring S;\nint K;\nint dp[300][300][300];\n\nint rec(int left, int right, int rest) {\n  if(left >= right) return left == right;\n  if(~dp[left][right][rest]) return dp[left][right][rest];\n  int ret = max(rec(left + 1, right, rest), rec(left, right - 1, rest));\n  if(rest > 0) ret = max(ret, rec(left + 1, right - 1, rest - 1) + 2);\n  if(S[left] == S[right]) ret = max(ret, rec(left + 1, right - 1, rest) + 2);\n  return dp[left][right][rest] = ret;\n}\n\nint main() {\n  cin >> S >> K;\n  memset(dp, -1, sizeof(dp));\n  cout << rec(0, S.size() - 1, K) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N, K;\nchar buf[333];\nint dp[333][333];\n\nvoid MAIN() {\n    scanf(\"%s\", buf);\n    scanf(\"%d\", &K);\n\n    string S = buf;\n    string T = buf;\n    reverse(T.begin(), T.end());\n    N = S.size();\n\n    REP (i, N) REP (j, N) {\n\tif (S[i] == T[j]) dp[i+1][j+1] = dp[i][j] + 1;\n\telse dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j]);\n    }\n\n    int ans = 0;\n    REP (i, N+1) {\n\tint j = N-i;\n\t{\n\t    int s = dp[i][j];\n\t    int w = min(i, j) - s;\n\t    int guess = (s + min(w, K)) * 2;\n\t    amax(ans, guess);\n\t}\n\n\tif (j) {\n\t    j--;\n\t    int s = dp[i][j];\n\t    int w = min(i, j) - s;\n\t    int guess = (s + min(w, K)) * 2 + 1;\n\t    amax(ans, guess);\n\t}\n    }\n    printf(\"%d\\n\", ans);\n}\n\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nint main() {\n    int N, K;\n    string S, T;\n    cin >> S;\n    N = (int)S.size();\n    cin >> K;\n    T = S;\n    reverse(T.begin(), T.end());\n    \n    vector<vector<vector<int>>> dp(N+1, vector<vector<int>>(N+1, vector<int>(K+1, 0)));\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            bool same;\n            if (S[i-1] == T[j-1]) same = true;\n            else same = false;\n            if (same) {\n                for (int k = 0; k <= K; k++) {\n                    dp[i][j][k] = max(max(dp[i-1][j][k], dp[i][j-1][k]), dp[i-1][j-1][k]+1);\n                }\n            }else {\n                for (int k = 0; k <= K; k++) {\n                    dp[i][j][k] = max(dp[i-1][j][k], dp[i][j-1][k]);\n                    if (k > 0) dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k-1]+1);\n                }\n            }\n        }\n    }\n    int ans = 0;\n    if (N%2 == 0) {\n        for (int i = 1; i < N; i++) {\n            for (int j = 0; j <= K; j++) {\n                ans = max(ans, 2*dp[i][N-i][j]);\n            }\n        }\n    }else {\n        for (int i = 1; i < N; i++) {\n            for (int j = 0; j <= K; j++) {\n                ans = max(ans, 2*dp[i][N-1-i][j]+1);\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\nusing namespace std;\nconst int N=308;\nint n,m,ans,a[N][N][N];\nchar b[N];\nint maxx(int x,int y){if(x>y)y=x;return y;}\nint main(void)\n{\n\tint i,j,k;\n\tscanf(\"%s%d\",b+1,&m);\n\tn=strlen(b+1);ans=1;\n\tfor(i=1;i<=n;i++)a[0][i][i]=1;\n\tfor(k=0;k<=m;k++)\n\tfor(i=n;i>=1;i--)\n\tfor(j=i+1;j<=n;j++)\n\t{\n\t\tif(k){a[k][i][j]=maxx(a[k][i][j],a[k-1][i][j]);}\n\t\tif(k){a[k][i][j]=maxx(a[k][i][j],2+a[k-1][i+1][j-1]);}\n\t\ta[k][i][j]=maxx(a[k][i][j],maxx(maxx(a[k][i+1][j],a[k][i][j-1]),(b[i]==b[j])*(2+a[k][i+1][j-1])));\n\t}\n\tcout<<a[m][1][n];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/////////////////////////   _LeMur_\n#include <iostream>\n#include <algorithm>\n#include <time.h>\n#include <stack>\n#include <string>\n#include <cstring>\n#include <cassert>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nconst int N = 305;\nconst int inf = 1000 * 1000 * 1000;\nconst int mod = 1000 * 1000 * 1000 + 7;\n\nint k;\nstring t;\nchar s[N] , rs[N];\nint dp[N][N][N];\n\nint solve(int l,int r,int k){\n    if(dp[l][r][k] != -1)return dp[l][r][k];\n    if(l > r)return 0;\n    if(l == r)return dp[l][r][k] = 1;\n    int answ = max(solve(l + 1 , r , k) , solve(l , r - 1 , k));\n    if(s[l] == s[r]) answ = max(answ , 2 + solve(l + 1 , r - 1 , k));\n    if(k) answ = max(answ , 2 + solve(l + 1 , r - 1 , k - 1));\n    return dp[l][r][k] = answ;\n}\n\nint main(){\n    cin>>t>>k;\n    int n = (int)t.size();\n    for(int i=1;i<=n;i++){\n        s[i] = t[i - 1];\n    }\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            for(int h=0;h<=k;h++){\n                dp[i][j][h] = -1;\n            }\n        }\n    }\n    cout<<solve(1 , n , k)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/pb_ds/priority_queue.hpp>\n#define MAXN 305\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\ntypedef __gnu_pbds::priority_queue<int,greater<int>,pairing_heap_tag> pq;\nint n,k;\nchar str[MAXN];\nint dp[MAXN][MAXN][MAXN];\nint solve(int l,int r,int k)\n{\n    if(l>r) return 0;\n    if(l==r) return 1;\n    if(dp[l][r][k]!=-1) return dp[l][r][k];\n    int &ans=dp[l][r][k];\n    ans=0;\n    ans=max(ans,solve(l+1,r,k));\n    ans=max(ans,solve(l,r-1,k));\n    if(str[l]==str[r]) ans=max(ans,2+solve(l+1,r-1,k));\n    else if(k) ans=max(ans,2+solve(l+1,r-1,k-1));\n    return ans;\n}\nint main()\n{\n    scanf(\"%s\",str+1);\n    n=strlen(str+1);\n    scanf(\"%d\",&k);\n    memset(dp,-1,sizeof(dp));\n    printf(\"%d\\n\",solve(1,n,k));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nint main() {\n    int N, K;\n    string S, T;\n    cin >> S;\n    N = (int)S.size();\n    cin >> K;\n    T = S;\n    reverse(T.begin(), T.end());\n    \n    vector<vector<vector<int>>> dp(N+1, vector<vector<int>>(N+1, vector<int>(K+1, 0)));\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            bool same;\n            if (S[i-1] == T[j-1]) same = true;\n            else same = false;\n            if (same) {\n                for (int k = 0; k <= K; k++) {\n                    dp[i][j][k] = max(max(dp[i-1][j][k], dp[i][j-1][k]), dp[i-1][j-1][k]+1);\n                }\n            }else {\n                for (int k = 0; k <= K; k++) {\n                    dp[i][j][k] = max(dp[i-1][j][k], dp[i][j-1][k]);\n                    if (k > 0) dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k-1]+1);\n                }\n            }\n        }\n    }\n    int ans = 0;\n    if (N%2 == 0) {\n        for (int i = 0; i <= N; i++) {\n            for (int j = 0; j <= K; j++) {\n                ans = max(ans, 2*dp[i][N-i][j]);\n                if (i < N) ans = max(ans, 2*dp[i][N-1-i][j]+1);\n            }\n        }\n    }else {\n        for (int i = 1; i <= N; i++) {\n            for (int j = 0; j <= K; j++) {\n                ans = max(ans, 2*dp[i][N-i][j]);\n                if (i < N) ans = max(ans, 2*dp[i][N-1-i][j]+1);\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> bool get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;return true;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) (get1(a)&&get1(b))\n#define get3(a,b,c) (get1(a)&&get2(b,c))\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nint n,k,dp[311][311][311];\nchar s[311];\n\nint dfs(int l,int r,int k)\n{\n\tif(dp[l][r][k]!=-1)return dp[l][r][k];\n\tif(l>r)return 0;if(l==r)return 1;\n\tint&ret=dp[l][r][k];\n\tret=max(dfs(l,r-1,k),dfs(l+1,r,k));\n\tif(k||s[l]==s[r])ret=max(ret,dfs(l+1,r-1,k-(s[l]!=s[r]))+2);\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%s\",s+1);get1(k);n=strlen(s+1);\n\t\n\tmemset(dp,-1,sizeof(dp));\n\tprintf(\"%d\\n\",dfs(1,n,k));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sz(a)((int)(a).size())\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);iostream::sync_with_stdio(0);cout<<fixed<<setprecision(10);cerr<<fixed<<setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());const int D=4,dx[]={+1,0,-1,0},dy[]={0,+1,0,-1};\nconst int N=303;\nshort dp[N][N][N];\nint32_t main(){\n    string s;int k;\n    cin>>s>>k;\n    int n=sz(s);\n    string t=s+\"#\";\n    reverse(t.begin(), t.end());\n    s=\"#\"+s;\n    for(int i=1;i<=n;++i){\n        for(int j=1;j<=n;++j){\n            for(int c=0;c<=k;++c){\n                dp[i][j][c]=max(dp[i-1][j][c],dp[i][j-1][c]);\n                if(s[i]==t[j])upx(dp[i][j][c],dp[i-1][j-1][c]+1);\n                else if(c)upx(dp[i][j][c],dp[i-1][j-1][c-1]+1);\n            }\n        }\n    }\n    int ans=0;\n    for(int i=1;i<=n;++i){\n        int j=n-i+1;\n        upx(ans,1+2*dp[i-1][j-1][k]);\n        upx(ans,2*dp[i][j-1][k]);\n    }\n    cout<<ans<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cassert>\nusing namespace std;\nstring s,t;\nint dp[310][310][310] = {};\nint main(){\n\tint i,j,l,n,k;\n\tcin >> s >> k; n = s.size();\n\tassert(k==0);\n\tfor(i=0;i<n;i++){\n\t\tt.push_back(s[n - 1 - i]);\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++){\n\t\t\tfor(l=0;l<=k;l++){\n\t\t\t\tif(s[i - 1]==t[j - 1]){\n\t\t\t\t\tdp[i][j][l] = dp[i - 1][j - 1][l] + 1;\n\t\t\t\t}else{\n\t\t\t\t\tint x = max(dp[i - 1][j][l],dp[i][j - 1][l]);\n\t\t\t\t\tif(l>0) x = max(x,dp[i - 1][j - 1][l - 1] + 1);\n\t\t\t\t\tdp[i][j][l] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(i=0;i<n;i++){\n\t\tif(n&1){\n\t\t\tans = max(ans,2*dp[i][n - 1 - i][k] + 1);\n\t\t}else{\n\t\t\tans = max(ans,2*dp[i][n - i][k]);\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\n\nstring s;\nint N,K;\n\nint memo[310][310][310];\nint calc(int l,int r,int k){\n\tif(memo[l][r][k]!=-1) return memo[l][r][k];\n\n\tint& v = memo[l][r][k];\n\tv = 0;\n\n\tif(l>0) chmax(v,calc(l-1,r,k));\n\tif(r>0) chmax(v,calc(l,r-1,k));\n\tif(k>0) chmax(v,calc(l,r,k-1));\n\tif(l>0 && r>0){\n\t\tif(s[l-1] == s[N-r]){\n\t\t\tchmax(v,calc(l-1,r-1,k)+1);\n\t\t}\n\t\tif(k>0){\n\t\t\tchmax(v,calc(l-1,r-1,k-1)+1);\n\t\t}\n\t}\n\treturn v;\n}\n\nint main(){\n\tcin>>s>>K;\n\tN = s.size();\n\trep(i,310) rep(j,310) rep(k,310) memo[i][j][k] = -1;\n\tint ans = 0;\n\trep(l,N+1){\n\t\tint r = N-l;\n\t\tint tmp = calc(l,r,K);\n\t\tchmax(ans,tmp*2);\n\t}\n\trep(l,N){\n\t\tint r = N-l-1;\n\t\tint tmp = calc(l,r,K);\n\t\tchmax(ans,tmp*2+1);\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nvoid fastStream(){cin.tie(0);std::ios_base::sync_with_stdio(0);}\n\nint dp[310][310][310];\n\n\nint rec(int l, int r, int k, string &S){\n    if(dp[l][r][k] >= 0) \n        return dp[l][r][k];\n    int res = 0;\n    if(l == r){\n        res = 1;\n    }\n    else if(l > r){\n        res = 0;\n    }\n    else{\n        if(S[l] == S[r]){\n            res = max(res, rec(l + 1, r - 1, k, S) + 2);\n        }\n        else{\n            if(k - 1 >= 0){\n                res = max(res, rec(l + 1, r - 1, k - 1, S) + 2);\n                res = max(res, rec(l + 1, r - 1, k - 1, S) + 2);\n            }\n        }\n        res = max(res, rec(l + 1, r, k, S));\n        res = max(res, rec(l, r - 1, k, S));\n    }\n    return dp[l][r][k] = res;\n}\n\n\nint main(){\n\n    string S;\n    int K;\n    cin >> S;\n    cin >> K;\n    memset(dp, -1, sizeof(dp));\n    cout << rec(0, (int)S.size() - 1, K, S) << endl;\n    \n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n#define INF 1000000000\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint dp[333][333][333];\nstring s;\nint k;\n\nint dfs(int K,int L,int R)\n{\n//\tcout << K << ' ' << L << ' ' << R << endl;\n\tif(K < 0 || L > R)return -100000000;\n\tif(dp[K][L][R] != -1)return dp[K][L][R];\n\tint ret = 0;\n\tint p = 0;\n\tif(s[L] == s[R])ret = max(ret,dfs(K,L+1,R-1)+2);\n\telse ret = max(ret,dfs(K-1,L+1,R-1)+2);\n\tret = max(ret,dfs(K,L+1,R));\n\tret = max(ret,dfs(K,L,R-1));\n\t\n\treturn dp[K][L][R] = ret;\n}\n\n\nint main()\n{\n\tcin >> s >> k;\n\t\n\tREP(K,333)REP(i,333)REP(j,333)dp[K][i][i] = -1;\n\tREP(K,333)REP(i,333)dp[K][i][i] = 1;\n\tREP(K,333)REP(i,332)\n\t{\n\t\tif(s[i] == s[i+1])dp[K][i][i+1] = 2;\n\t\telse dp[K][i][i+1] = 1;\n\t}\n\t\n\tcout << dfs(k,0,s.size()-1) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n#define INF 1000000000\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint dp[333][333][333];\nstring s;\nint k;\n\nint dfs(int K,int L,int R)\n{\n//\tcout << K << ' ' << L << ' ' << R << endl;\n\tif(K < 0)return -100000000;\n\tif(L > R)return 0;\n\tif(dp[K][L][R] != 0)return dp[K][L][R];\n\tint ret = 0;\n\tif(s[L] == s[R])ret = max(ret,dfs(K,L+1,R-1)+2);\n\telse ret = max(ret,dfs(K-1,L+1,R-1)+2);\n\tret = max(ret,dfs(K,L+1,R));\n\tret = max(ret,dfs(K,L,R-1));\n\t\n\treturn dp[K][L][R] = ret;\n}\n\n\nint main()\n{\n\tcin >> s >> k;\n\t\n\tREP(K,333)REP(i,333)dp[K][i][i] = 1;\n\t\n\tcout << dfs(k,0,s.size()-1) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar str[303]; int dp[303][303][303] , N , K;\n\nint solve(int x , int y , int z){\n\tif(x > y) return 0;\n\tif(x == y) return 1;\n\tif(dp[x][y][z]) return dp[x][y][z];\n\tif(str[x] == str[y]) return dp[x][y][z] = solve(x + 1 , y - 1 , z) + 2;\n\treturn max(solve(x + 1 , y , z) , max(solve(x , y - 1 , z) , z == 0 ? 0 : 2 + solve(x + 1 , y - 1 , z - 1)));\n}\n\nint main(){\n\tscanf(\"%s %d\" , str + 1 , &K); N = strlen(str + 1);\n\tcout << solve(1 , N , K) << endl; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring st;\nint dp[310][310][310],K;\nint dfs(int l,int r,int x){\n    if(r<l)return 0;\n    if(l==r)return 1;\n    if(dp[l][r][x]!=-1)return dp[l][r][x];\n    int res=max(dfs(l+1,r,x),dfs(l,r-1,x));\n    if(st[l]==st[r])res=max(res,dfs(l+1,r-1,x)+2);\n    if(x)res=max(res,dfs(l+1,r-1,x-1)+2);\n    return dp[l][r][x]=res;\n}\nint main(){\n    cin>>st>>K;\n    dpset(dp,-1,sizeof(dp));\n    cout<<dfs(0,st.size()-1,K)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<string>\n\nusing namespace std;\ntypedef long long LL;\n\nconst int maxn=310;\n\nint DP[maxn][maxn][maxn],v;\nchar str[maxn];\n\nint Cal()\n{\n    int len=strlen(str);\n    memset(DP,0,sizeof(DP));\n    for(int i=0;i<len;i++) DP[i][i][0]=1;\n    for(int i=len-2;i>=0;i--)\n        for(int j=i+1;j<len;j++)\n             for(int k=0;k<=v;k++)\n             {\n        if(str[j]==str[i]) DP[i][j][k]=DP[i+1][j-1][k]+2;\n        else\n        {\n            DP[i][j][k]=max(DP[i+1][j][k],DP[i][j-1][k]);\n            if(k)  DP[i][j][k]=max(DP[i+1][j-1][k-1]+2,DP[i][j][k]);\n        }\n             }\n    return DP[0][len-1][v];\n}\n\nint main()\n{\n    scanf(\"%s\",&str);\n    scanf(\"%d\",&v);\n    printf(\"%d\",Cal());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, x, y) for(int i = x; i <= y; i ++)\n#define rrep(i, x, y) for(int i = x; i >= y; i --)\n#define ll long long\n#define X first\n#define Y second\n#define pb push_back\n#define mp make_pair\n#define pii pair<ll, ll>\n#define ls rt << 1\n#define rs rt << 1 | 1\n#define sz(x) (int)(x).size()\n#define ALL(x) (x).insgin(), (x).end()\n#define vi vector<int>\nusing namespace std;\nint n, K;\nchar s[310];\nint f[305][305][305];\n\nint main()\n{\n\tscanf(\"%s\", s + 1);\n\tn = strlen(s + 1);\n\tscanf(\"%d\", &K);\n\trep(k, 0, K)\n\t\trrep(i, n, 1) {\n\t\t\tf[i][i][k] = 1;\n\t\t\trep(j, i + 1, n) {\n\t\t\tf[i][j][k] = max(f[i + 1][j][k], f[i][j - 1][k]);\n\t\t\tif(s[i] == s[j]) f[i][j][k] = max(f[i][j][k], f[i + 1][j - 1][k] + 2);\n\t\t\tif(k) f[i][j][k] = max(f[i][j][k], f[i + 1][j - 1][k - 1] + 2);\n\t\t\t}\n\t\t}\n\tcout << f[1][n][K];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(int i=(int)(st),i##end=(int)(ed);i<=i##end;++i)\n#define DREP(i,st,ed) for(int i=(int)(st),i##end=(int)(ed);i>=i##end;--i)\ntemplate<typename T>bool chkmin(T &x,const T &y){return x>y?x=y,1:0;}\ntemplate<typename T>bool chkmax(T &x,const T &y){return x<y?x=y,1:0;}\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\ntemplate<typename T>T read(){\n\tT x=0,f=1;\n\tchar c=getchar();\n\twhile((c<'0')||(c>'9')){if(c=='-')f=-1;c=getchar();}\n\twhile((c>='0')&&(c<='9'))x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\treturn x*f;\n}\n#define read() read<int>()\ntemplate<typename T>void write(T x,char c){\n\tstatic char t[25];\n\tstatic int tlen;\n\tt[tlen=1]=c;\n\tif(x<0)putchar('-'),x=-x;\n\tdo t[++tlen]=(x%10)^48;\n\twhile(x/=10);\n\twhile(tlen)putchar(t[tlen--]);\n}\n#define pb push_back\ntypedef long long ll;\ntypedef double lf;\nconst lf pi=acos(-1.0);\nconst int maxn=305;\nchar s[maxn];\nint n,m;\nint dp[maxn][maxn][maxn];\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1),m=read();\n\tREP(i,0,n)\n\t\tREP(j,0,n-i+1)\n\t\t\tREP(k,0,m){\n\t\t\t\tif(i>=1)chkmax(dp[i][j][k],dp[i-1][j][k]);\n\t\t\t\tif(j>=1)chkmax(dp[i][j][k],dp[i][j-1][k]);\n\t\t\t\tif((i>=1)&&(j>=1)){\n\t\t\t\t\tif(s[i]==s[n-j+1])\n\t\t\t\t\t\tchkmax(dp[i][j][k],dp[i-1][j-1][k]+2-((i+j==n+1)&&(i==n-j+1)));\n\t\t\t\t\telse if(k>=1)\n\t\t\t\t\t\tchkmax(dp[i][j][k],dp[i-1][j-1][k-1]+2-((i+j!=n+1)&&(i==n-j+1)));\n\t\t\t\t}\n\t\t\t}\n\tint ans=0;\n\tREP(i,1,n)\n\t\tREP(j,0,m)\n\t\t\tchkmax(ans,dp[i][n-i+1][j]);\n\twrite(ans,'\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<cassert>\n#pragma warning(disable:4996)\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define MRE assert(0)\nconst int mod = 1000000007;\nconst long long inf = 1ll << 61;\ntypedef pair<int, int> P;\ntypedef pair<P, int>PP;\nint dp[305][305][305];\nstring s; int K, n;\nvoid DP() {\n\trep(k, K + 1) {\n\t\trep(i, n) {//幅\n\t\t\tfor (int j = 0; j + i < n; j++) {//[j,j+i]\n\t\t\t\tif (j) {\n\t\t\t\t\tdp[j - 1][j + i][k] = max(dp[j - 1][j + i][k], dp[j][j + i][k]);\n\t\t\t\t}\n\t\t\t\tif (j + i < n - 1) {\n\t\t\t\t\tdp[j][j + i + 1][k] = max(dp[j][j + i + 1][k], dp[j][j + i][k]);\n\t\t\t\t}\n\t\t\t\tif (j&&j + i < n - 1) {\n\t\t\t\t\tif (s[j - 1] == s[j + i + 1]) {\n\t\t\t\t\t\tdp[j - 1][j + i + 1][k] = max(dp[j - 1][j + i + 1][k], dp[j][j + i][k] + 2);\n\t\t\t\t\t}\n\t\t\t\t\telse if (k != K) {\n\t\t\t\t\t\tdp[j - 1][j + i + 1][k + 1] = max(dp[j - 1][j + i + 1][k + 1], dp[j][j + i][k] + 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main() {\n\tcin >> s; cin >> K; n = s.size();\n\trep(i, n)dp[i][i][0] = 1;\n\tDP();\n\tint res = 0,res2=0;\n\trep(i, n)rep(j, n)rep(k, K + 1)res = max(res, dp[i][j][k]);\n\trep(i, n)rep(j, n)rep(k, K + 1)dp[i][j][k] = 0;\n\trep(i, n-1) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (s[i] == s[j])dp[i][j][0] = 2;\n\t\t\telse dp[i][j][1] = 2;\n\t\t}\n\t}\n\tDP();\n\trep(i, n)rep(j, n)rep(k, K + 1)res2 = max(res2, dp[i][j][k]);\n\tcout <<max(res,res2)<< endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll MOD = (1e+9)+7;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nint dp[301][301][302] = {};\nint main() {\n\tstring s; cin >> s; int n = s.length();\n\tint c; cin >> c;\n\trep(i, n) {\n\t\trep(k, c+1) {\n\t\t\trep(j, n+1) {\n\t\t\t\tif (j < n) {\n\t\t\t\t\tif (s[i] == s[n - 1 - j]) {\n\t\t\t\t\t\tdp[i + 1][j + 1][k] = max(dp[i + 1][j + 1][k], dp[i][j][k] + 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (k < c) {\n\t\t\t\t\t\tdp[i + 1][j + 1][k + 1] = max(dp[i + 1][j + 1][k + 1], dp[i][j][k] + 1);\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j + 1][k] = max(dp[i][j + 1][k], dp[i][j][k]);\n\t\t\t\t}\n\t\t\t\tdp[i + 1][j][k] = max(dp[i + 1][j][k], dp[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tint out = 0;\n\trep(i, n + 1) {\n\t\trep(j, n + 1) {\n\t\t\trep(k, c+1) {\n\t\t\t\tif (i + j == n) {\n\t\t\t\t\tout = max(out, 2*dp[i][j][k]);\n\t\t\t\t}\n\t\t\t\telse if (i + j == n - 1) {\n\t\t\t\t\tout = max(out, 1 + 2 * dp[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << out << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define F(i,a,b) for(int i=(a);i<=(b);++i)\n#define F2(i,a,b) for(int i=(a);i<(b);++i)\n#define dF(i,a,b) for(int i=(a);i>=(b);--i)\n#define dF2(i,a,b) for(int i=(a);i>(b);--i)\n#define dF3(i,a,b) for(int i=(a)-1;i>=(b);--i)\nusing namespace std;typedef long long ll;typedef double ld;int INF=0x3f3f3f3f;int INF2=0x7fffffff;ll LNF=0x3f3f3f3f3f3f3f3f;ll LNF2=0x7fffffffffffffff;\n\nchar str[305];\nint n,K,Ans;\nint f[305][305][305];\n\nint main(){\n\tscanf(\"%s%d\",str+1,&K); n=strlen(str+1);\n\tmemset(f,0x80,sizeof(f));\n\tF(i,1,n) f[i][i][0]=1;\n\tF(Q,2,n){\n\t\tF(i,1,n-Q+1){\n\t\t\tint j=i+Q-1;\n\t\t\tf[i][j][0]=max(f[i+1][j][0],max(f[i][j-1][0],f[i+1][j-1][0]+2*(str[i]==str[j])));\n\t\t\tF(k,1,min(K,Q)){\n\t\t\t\tf[i][j][k]=max(f[i+1][j][k],max(f[i][j-1][k],f[i+1][j-1][k-(str[i]!=str[j])]+2)); \n\t\t\t}\n\t\t}\n\t}\n\tF(k,0,K) Ans=max(Ans,f[1][n][k]);\n\tprintf(\"%d\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL111\n\t#define _GLIBCXX_DEBUG\n#else\n\t#define NDEBUG\n#endif\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nconst int INF = 1e9;\nusing namespace std;\ntemplate<typename T, typename U> ostream& operator<< (ostream& os, const pair<T,U>& p) { os << '(' << p.first << ' ' << p.second << ')'; return os; }\n\n#define endl '\\n'\n#define ALL(a)  (a).begin(),(a).end()\n#define SZ(a) int((a).size())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#ifdef LOCAL111\n\t#define DEBUG(x) cout<<#x<<\": \"<<(x)<<endl\n\ttemplate<typename T> void dpite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\n#else\n\t#define DEBUG(x) true\n\ttemplate<typename T> void dpite(T a, T b){ return; }\n#endif\n#define F first\n#define S second\n#define SNP string::npos\n#define WRC(hoge) cout << \"Case #\" << (hoge)+1 << \": \"\ntemplate<typename T> void pite(T a, T b){ for(T ite = a; ite != b; ite++) cout << (ite == a ? \"\" : \" \") << *ite; cout << endl;}\ntemplate<typename T> bool chmax(T& a, T b){if(a < b){a = b; return true;} return false;}\ntemplate<typename T> bool chmin(T& a, T b){if(a > b){a = b; return true;} return false;}\n\ntypedef long long int LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> P;\n\nvoid ios_init(){\n\t//cout.setf(ios::fixed);\n\t//cout.precision(12);\n#ifdef LOCAL111\n\treturn;\n#endif\n\tios::sync_with_stdio(false); cin.tie(0);\n}\n\n//;ibrary\nstring lcs(string s, string t){\n\tint n = s.size();\n\tint m = t.size();\n\tarray<int,3> dx({-1,0,-1});\n\tarray<int,3> dy({-1,-1,0});\n\tvector<vector<int>> dp(n+1,vector<int>(m+1));\n\tvector<vector<int>> pre(n+1,vector<int>(m+1,-1));\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < m; ++j) {\n\t\t\tint val = 0;\n\t\t\tif(s[i] == t[j] and val <= dp[i][j]+1){\n\t\t\t\tval = dp[i][j]+1;\n\t\t\t\tpre[i+1][j+1] = 0;\n\t\t\t}\n\t\t\tif(val <= dp[i+1][j]){\n\t\t\t\tval = dp[i+1][j];\n\t\t\t\tpre[i+1][j+1] = 1;\n\t\t\t}\n\t\t\tif(val <= dp[i][j+1]){\n\t\t\t\tval = dp[i][j+1];\n\t\t\t\tpre[i+1][j+1] = 2;\n\t\t\t}\n\t\t\tdp[i+1][j+1] = val;\n\t\t}\n\t}\n\tstring res;\n\tint x = n, y = m;\n\twhile(x != 0 and y != 0){\n\t\tint tmp = pre[x][y];\n\t\tif(tmp == 0){\n\t\t\tassert(s[x-1] == t[y-1]);\n\t\t\tres += s[x-1];\n\t\t}\n\t\tx += dx[tmp];\n\t\ty += dy[tmp];\n\t}\n\tassert((int)res.size() == dp[n][m]);\n\treverse(res.begin(), res.end());\n\treturn res;\n}\n//liblary\n\nint main()\n{\n\tios_init();\n\tstring s;\n\twhile(cin >> s) {\n\n\t\tint k;\n\t\tcin >> k;\n\t\tstring t = s;\n\t\treverse(ALL(t));\n\t\tint n = s.size();\n\t\tint m = t.size();\n\t\tarray<int,3> dx({-1,0,-1});\n\t\tarray<int,3> dy({-1,-1,0});\n\t\tvector<vector<int>> dp(n+1,vector<int>(m+1));\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = 0; j < m; ++j) {\n\t\t\t\tint val = 0;\n\t\t\t\tif(s[i] == t[j] and val <= dp[i][j]+1){\n\t\t\t\t\tval = dp[i][j]+1;\n\t\t\t\t}\n\t\t\t\tif(val <= dp[i+1][j]){\n\t\t\t\t\tval = dp[i+1][j];\n\t\t\t\t}\n\t\t\t\tif(val <= dp[i][j+1]){\n\t\t\t\t\tval = dp[i][j+1];\n\t\t\t\t}\n\t\t\t\tdp[i+1][j+1] = val;\n\t\t\t}\n\t\t}\n\t\tint ans = 1;\n\t\tREP(i, SZ(s)) {\n\t\t\tint tmp = dp[i+1][n-i];\n\t\t\tDEBUG(i+1); DEBUG(n-i);\n\t\t\tint rem = min(i+1, n-i)-tmp;\n\t\t\tint val = tmp + min(rem, k);\n\t\t\tchmax(ans, val*2-1);\n\t\t}\n\t\tREP(i, SZ(s)+1) {\n\t\t\tint tmp = dp[i][n-i];\n\t\t\tint rem = min(i, n-i)-tmp;\n\t\t\tint val = tmp + min(rem, k);\n\t\t\tchmax(ans, val*2);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <iomanip>\n#include <functional>\n#include <cassert>\n#include <bitset>\n \nusing namespace std;\n \ntypedef long long ll;\n\nconst int N = 307;\n\nint dp[N][N][N];\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  string s;\n  cin >> s;\n  //assert(s.size() % 2 == 0);\n  int k;\n  cin >> k;\n  string tt = s;\n  reverse(tt.begin(), tt.end());\n  int n = s.size();\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j <= n; ++j) {\n      for (int t = 0; t <= k; ++t) {\n        dp[i][j][t] = max(dp[i - 1][j][t], dp[i][j - 1][t]);\n        if (s[i - 1] == tt[j - 1]) {\n          dp[i][j][t] = max(dp[i][j][t], dp[i - 1][j - 1][t] + 1);\n        } else if (t > 0) {\n          dp[i][j][t] = max(dp[i][j][t], dp[i - 1][j - 1][t - 1] + 1);\n        }\n      }\n      for (int t = 1; t <= k; ++t) dp[i][j][t] = max(dp[i][j][t], dp[i][j][t - 1]);\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i <= n; ++i) {\n    ans = max(ans, 2 * dp[i][n - i][k]);\n  }\n  for (int i = 0; i <= n; ++i) {\n    for (int j = 0; j <= n; ++j) {\n      for (int t = 0; t <= k; ++t) {\n        ans = max(ans, dp[i][j][t] + dp[n - j][n - i][k - t]);\n      }\n    }\n  }\n  ans = max(ans, dp[n][n][k]);\n  if (n % 2 == 1) {\n    ans = max(ans, 2 * dp[n / 2][n / 2][k] + 1);\n  }\n  cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <array>\nusing namespace std;\nusing ULL = unsigned long long;\nusing UL = unsigned;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nstruct Problem {\n\n\tUL dp[301][301][300] = {};\n\n\tvoid Solve() {\n\t\tstring S; cin >> S;\n\t\tstring rS = S; reverse(rS.begin(), rS.end());\n\t\tUL K; cin >> K;\n\t\tUL ans = 0;\n\t\tfor (UL i = 0; i < S.size(); i++) {\n\t\t\tfor (UL j = 0; j < rS.size(); j++) {\n\t\t\t\tif ((i + 1) + (j + 1) > S.size()) continue;\n\t\t\t\tfor (UL k = 0; k <= K; k++) {\n\t\t\t\t\tauto &p = dp[i + 1][j + 1][k];\n\t\t\t\t\tp = max(p, dp[i][j + 1][k]);\n\t\t\t\t\tp = max(p, dp[i + 1][j][k]);\n\t\t\t\t\tif (S[i] == rS[j]) p = max(p, dp[i][j][k] + 1);\n\t\t\t\t\tif (k != 0) p = max(p, dp[i][j][k - 1] + 1);\n\t\t\t\t\tif ((i + 1) + (j + 1) == S.size()) ans = max(ans, p * 2);\n\t\t\t\t\tif ((i + 1) + (j + 1) == S.size() - 1) ans = max(ans, p * 2 + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor (UL k = 0; k <= K; k++) {\n\t\t\tfor (UL i = 0; i <= S.size(); i++) {\n\t\t\t\tfor (UL j = 0; j <= rS.size(); j++) {\n\t\t\t\t\tcout << dp[i][j][k] << \" \";\n\t\t\t\t} cout << endl;\n\t\t\t} cout << endl;\n\t\t}*/\n\t\tcout << ans << endl;\n\t}\n\n\n\tProblem();\n};\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\nProblem::Problem() {\n\tcout << fixed << setprecision(10);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define for0(i, n) for(int i = 0; i < n; i++)\n#define for1(i, n) for(int i = 1; i <= n; i++)\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(), v.end()\n#define V vector<int>\n#define VP vector<pair<int, int> >\n#define FASTIO ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#ifdef _WIN32\n#include <windows.h>\n#define print(x) PRINT(x, #x)\ntemplate<typename T> inline const void PRINT(T VARIABLE, string NAME)\n{\n#ifndef ONLINE_JUDGE /// ONLINE_JUDGE IS DEFINED ON CODEFORCES\n    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n    SetConsoleTextAttribute(hConsole, 10);\n    cerr << NAME << \" = \" << VARIABLE;\n    SetConsoleTextAttribute(hConsole, 7);\n    cerr << '\\n';\n#endif\n}\n#else\n#define print(x) 0\n#endif\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst ll INFLL = 2 * (ll)1e18 + 100;\nconst int INFINT = 2 * (int)1e9 + 100;\nconst double PI = atan(1) * 4;\nconst double EPS = 1e-12;\nconst int SEED = 1e3 + 7;\n\nconst int MOD = 1e9 + 7; /// careful here (7 or 9, 66.. etc)\nconst int NMAX = 300 + 5;\n\nstring s;\nint k;\nint dp[NMAX][NMAX][NMAX], trecut[NMAX][NMAX][NMAX];\n\nvoid solve(int l, int r, int x)\n{\n    if(trecut[l][r][x]) return;\n    if(l == r)\n    {\n        dp[l][r][x] = 1;\n        trecut[l][r][x] = 1;\n        return;\n    }\n    if(l > r)\n    {\n        dp[l][r][x] = 0;\n        trecut[l][r][x] = 1;\n        return;\n    }\n\n    if(s[l] == s[r])\n    {\n        if(!trecut[l + 1][r - 1][x]) solve(l + 1, r - 1, x);\n        dp[l][r][x] = 2 + dp[l + 1][r - 1][x];\n    }\n    else\n    {\n        if(x - 1 >= 0 && !trecut[l][r][x - 1])\n        {\n            solve(l, r, x - 1);\n            dp[l][r][x] = 2 + dp[l][r][x - 1];\n\n        }\n        else\n        {\n            if(!trecut[l + 1][r][x]) solve(l + 1, r, x);\n            if(!trecut[l][r - 1][x]) solve(l, r - 1, x);\n            dp[l][r][x] = max(dp[l + 1][r][x], dp[l][r - 1][x]);\n        }\n    }\n    trecut[l][r][x] = 1;\n}\n\nint main()\n{\n    FASTIO;\n    cin >> s >> k;\n    int n = s.size();\n    solve(0, n - 1, k);\n    int sol = 1;\n    for0(i, n)\n        for0(j, n)\n            for0(K, k + 1)\n            {\n                if(!trecut[i][j][K]) solve(i, j, K);\n                sol = max(sol, dp[i][j][K]);\n            }\n\n    cout << sol;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 305;\nint dp[N][N][N];\n\nint main()\n{\n    string s; cin >> s;\n    int n = s.size(), k; cin >> k;\n    for (int i = 0; i < n; i++) for (int j = 0; j <= k; j++) dp[i][i][j] = 1;\n    for (int len = 2; len <= n; len++) {\n        for (int l = 0, r = len - 1; r < n; l++,r++) {\n            for (int j = 0; j <= k; j++) {\n                dp[l][r][j] = max(dp[l+1][r][j], dp[l][r-1][j]);\n                if (j - (s[l] != s[r]) >= 0) dp[l][r][j] = max(dp[l][r][j], dp[l+1][r-1][j - (s[l] != s[r])] + 2);\n            }\n        }\n    }\n    cout << dp[0][n-1][k] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define int long long\n\n#define all(X) (X).begin(), (X).end()\n#define reset(X) memset(X, 0, sizeof(X))\n#define mp(a, b) make_pair(a, b)\n#define pb push_back\n#define endl '\\n'\n#define fi first\n#define se second\n\nusing namespace __gnu_pbds;\nusing namespace std;\nconst int mod = 1e9 + 7;\n// const int mod=998244353;\n//const int mod=1e9+9;\n//const int INF=4e18+10;\nconst int INF = 4e18 + 10;\ntemplate <typename T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T>\nusing ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define read(n) \\\nint n;      \\\ncin >> n;\n#define readv(x, n)   \\\nvector<int> x(n); \\\nfor (auto &i : x) \\\n    cin >> i;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> pii;\n\ntemplate <typename T1, typename T2>\nvoid set_min(T1 &a, T2 b)\n{\n    a = min(a, (T1)b);\n}\n\nint multiply(int a, int b, int in_mod) { return (a * b) % in_mod; }\nint mult_identity(int a) { return 1; }\n\n\nauto power(auto a, int b, int in_mod)\n{\n    auto prod = mult_identity(a);\n    auto mult = a % in_mod;\n    while (b != 0)\n    {\n        if (b % 2)\n        {\n            prod = multiply(prod, mult, in_mod);\n        }\n        mult = multiply(mult, mult, in_mod);\n        b /= 2;\n    }\n    return prod;\n}\nint mod_inv(int q, int in_mod)\n{\n\n    return power(q, in_mod - 2, in_mod);\n}\n\n\nconst int MAXN = 1e5+100;\nint parent[MAXN];\nvoid build()\n{\n    for(int i=0;i<MAXN;i++)\n        parent[i] = i;\n}\n\nint find_set(int u)\n{\n    if( u== parent[u])\n        return u;\n    return parent[u] = find_set(parent[u]);\n}\nvoid merge(int u, int v)\n{\n    u= find_set(u);\n    v= find_set(v);\n    if(u!=v)\n    {\n        if(rand()%2)\n            swap(u,v);\n        parent[v] = u;\n    }\n\n}\n\nvoid solve()\n{\n    string s;\n    cin>>s;\n    int k;\n    cin>>k;\n    int n= s.size();\n    string c = s;\n    reverse(all(c));\n    k*=2;\n    vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(n+1, vector<int>(2)));\n\n    int mx= 0;\n    int prev = 0;\n    int now = 1;\n    for(int _k= 0;_k<=k;_k++)\n    {\n        for(int i= 1;i<=n;i++)\n        {\n            for(int j=1;j<=n;j++)\n            {\n                if(c[i-1] == s[j-1])\n                    dp[i][j][now] = dp[i-1][j-1][now] + 1;\n                else\n                {\n                    dp[i][j][now] = max(dp[i-1][j][now], dp[i][j-1][now]);\n                    if(_k)\n                        dp[i][j][now] = max(dp[i][j][now], dp[i-1][j-1][prev] + 1);\n                }\n            }\n        }\n        mx = max(mx, dp[n][n][now]);\n        swap(prev, now);\n    }\n    cout<<mx<<endl;\n\n}\n\n\n\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cerr.tie(NULL);\n#ifndef ONLINE_JUDGE\n    if (fopen(\"INPUT.txt\", \"r\"))\n    {\n        freopen(\"INPUT.txt\", \"r\", stdin);\n        freopen(\"OUTPUT.txt\", \"w\", stdout);\n    }\n#endif\n    auto clk = clock();\n    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n    // -------------------------------------Code starts here---------------------------------------------------------------------\n\n    int t = 1;\n    // cin >> t;\n\n    for (int test = 1; test <= t; test++)\n    {\n        // cout<<\"Case #\"<<test<<\":\\n\";\n        //cout<<\"Trip #\"<<test<<\": \";\n        // cout<<endl;\n        solve();\n        // solveB();\n\n        // cout<<endl;\n    }\n\n    // -------------------------------------Code ends here------------------------------------------------------------------\n\n    clk = clock() - clk;\n    // cerr << fixed << setprecision(6) << \"Time: \" << ((long double)clk) / CLOCKS_PER_SEC << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int maxn = 303;\nint f[maxn][maxn][maxn] , l , k;\nchar s[maxn];\nint main(){\n\tcin >> s + 1 >> k;\n\tl = strlen(s + 1);\n\tmemset(f , -1 , sizeof f);\n\tf[0][l + 1][0] = 0;\n\tint ans = 1;\n\tfor(int c = 0 ; c <= k ; ++ c){\n\t\tfor(int i = 1 ; i < l ; ++ i){\n\t\t\tfor(int j = l ; j > i ; -- j){\n\t\t\t\tif(s[i] == s[j])\n\t\t\t\t\tf[i][j][c] = max(f[i][j][c] , f[i - 1][j + 1][c] + 1);\n\t\t\t\telse if(c > 0)\n\t\t\t\t\tf[i][j][c] = max(f[i][j][c] , f[i - 1][j + 1][c - 1] + 1);\n\t\t\t\tf[i][j][c] = max(f[i][j][c] , f[i - 1][j][c]);\n\t\t\t\tf[i][j][c] = max(f[i][j][c] , f[i][j + 1][c]);\n\t\t\t}\n\t\t\tans = max(ans , f[i][i + 1][c] * 2);\n\t\t\tif(i < l - 1)\n\t\t\t\tans = max(ans , f[i][i + 2][c] * 2 + 1);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint64_t dp[310][310][310];\nstring s;int64_t K;\nint main(){\ncin>>s>>K;\n  int64_t N=s.size();\n  for(int i=0;i<N;i++)\n    for(int j=0;j<=K;j++)\n    dp[i][i][j]=1;\n  for(int i=0;i<N-1;i++)\n    if(s.at(i)==s.at(i+1))\n      dp[i][i+1][0]=2;\n  else\n    dp[i][i+1][0]=1;\n  for(int j=2;j<=N-1;j++)\n    for(int i=0;i<N-j;i++){\n    if(s.at(i)==s.at(i+j))\n      dp[i][i+j][0]=2+dp[i+1][i+j-1][0];\n      else\n        dp[i][i+j][0]=max(dp[i+1][i+j][0],dp[i][i+j-1][0]);\n    }for(int i=0;i<N-1;i++)\n      for(int j=1;j<=K;j++)\n      dp[i][i+1][j]=2;\n  for(int k=1;k<=K;k++)\n      for(int j=2;j<=N-1;j++)\n        for(int i=0;i<N-j;i++){\n        if(s.at(i)==s.at(i+j))\n          dp[i][i+j][k]=2+dp[i+1][i+j-1][k];\n          else\ndp[i][i+j][k]=max(max(2+dp[i+1][i+j-1][k-1],dp[i][i+j-1][k]),dp[i+1][i+j][k]);\n          \n        }cout<<dp[0][N-1][K]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=310;\nint n,k,f[N][N][N];\nchar s[N];\nint main(){\n\tscanf(\"%s\",s+1);\n\tscanf(\"%d\",&k);\n\tn=strlen(s+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=k;j++) f[i][i][j]=1;\n\tint l,r;\n\tfor(int i=2;i<=n;i++)\n\t\tfor(int j=1;j<=n-i+1;j++)\n\t\t\tfor(int x=0;x<=k&&x<=i;x++){\n\t\t\t\tl=j,r=j+i-1;\n\t\t\t\tf[l][r][x]=max(f[l+1][r][x],f[l][r-1][x]);\n\t\t\t\tif(x) f[l][r][x]=max(f[l][r][x],max(f[l+1][r-1][x-1]+2,f[l+1][r-1][x-1]+2));\n\t\t\t\tif(s[l]==s[r]) f[l][r][x]=max(f[l][r][x],f[l+1][r-1][x]+2);\n\t\t\t}\n\tprintf(\"%d\",f[1][n][k]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...)\n#endif\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    string s;\n    int k;\n    cin >> s >> k;\n    int n = s.size();\n    int dp[n][n][k] = {};\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i; j <= n - 1; j++) {\n            for (int l = 0; l <= k; l++) {\n                if (i == j) {\n                    dp[i][j][l] = 1;\n                } else if (i + 1 == j) {\n                    dp[i][j][l] = 2;\n                    if (l == 0 && s[i] != s[j]) {\n                        dp[i][j][l] = 1;\n                    }\n                } else {\n                    dp[i][j][l] = max(dp[i + 1][j][l], dp[i][j - 1][l]);\n                    if (s[i] == s[j]) {\n                        dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l] + 2);\n                    }\n                    if (l != 0) {\n                        dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l] + 1);\n                        dp[i][j][l] = max(dp[i][j][l], dp[i + 1][j - 1][l - 1] + 2);\n                    }\n                }\n            }\n        }\n    }\n    cout << dp[0][n - 1][k] << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\n#define MOD 1000000007\n#define MOD2 998244353\n#define int long long\n#define double long double\n#define EPS 1e-9\n//#define PI 3.14159265358979\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nusing namespace std;\n\ntemplate < typename T >\nostream &operator<<(ostream &os, const vector< T > &A) {\n\tfor (int i = 0; i < A.size(); i++)\n\t\tos << A[i] << \" \";\n\tos << endl;\n\treturn os;\n}\ntemplate <>\nostream &operator<<(ostream &os, const vector< vector< int > > &A) {\n\tint N = A.size();\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < A[i].size(); j++)\n\t\t\tos << A[i][j] << \" \";\n\t\tos << endl;\n\t}\n\treturn os;\n}\ntemplate < typename T, typename U >\nostream &operator<<(ostream &os, const pair< T, U > &p) {\n\tos << \"(\" << p.first << \",\" << p.second << \")\";\n\treturn os;\n}\ntemplate < typename T, typename U >\nistream &operator>>(istream &is, pair< T, U > &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate < typename T >\nistream &operator>>(istream &is, vector< T > &A) {\n\trep(i, A.size()) is >> A[i];\n\treturn is;\n}\n\ntypedef pair< int, int > pii;\ntypedef long long ll;\n\nstruct edge {\n\tint from, to, d, c, i;\n\tedge(int _from = 0, int _to = 0, int _d = 0, int _c = 0) {\n\t\tfrom = _from;\n\t\tto = _to;\n\t\td = _d;\n\t\tc = _c;\n\t}\n\tbool operator<(const edge &rhs) const {\n\t\treturn (d == rhs.d) ? (c < rhs.c) : (d < rhs.d);\n\t}\n};\nstruct aabb {\n\tint x1, y1, x2, y2;\n\taabb(int x1, int y1, int x2, int y2) : x1(x1), y1(y1), x2(x2), y2(y2) {}\n};\n\ntypedef vector< edge > edges;\ntypedef vector< edges > graph;\nstruct flow {\n\tint to, cap, rev, cost;\n\tflow(int to = 0, int cap = 0, int rev = 0, int cost = 0) : to(to), cap(cap), rev(rev), cost(cost) {}\n};\ntypedef vector< vector< flow > > flows;\n\nconst int di[4] = {0, -1, 0, 1};\nconst int dj[4] = {-1, 0, 1, 0};\nconst int ci[5] = {0, 0, -1, 0, 1};\nconst int cj[5] = {0, -1, 0, 1, 0};\nconst ll LINF = LLONG_MAX / 2;\nconst int INF = INT_MAX / 2;\nconst double PI = acos(-1);\n\nint pow2(int n) { return 1LL << n; }\ntemplate < typename T, typename U >\nbool chmin(T &x, const U &y) {\n\tif (x > y) {\n\t\tx = y;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate < typename T, typename U >\nbool chmax(T &x, const U &y) {\n\tif (x < y) {\n\t\tx = y;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\ntemplate < typename A, size_t N, typename T >\nvoid Fill(A (&array)[N], const T &val) {\n\tfill((T *)array, (T *)(array + N), val);\n}\nstruct initializer {\n\tinitializer() {\n\t\tcout << fixed << setprecision(20);\n\t}\n};\ninitializer _____;\n\nint N, M, K, T, Q, H, W;\nsigned main() {\n\tstatic int dp[301][301][301][2][2];\n\tstring S;\n\tcin >> S >> K;\n\tcout << 0 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include <boost/multiprecision/cpp_int.hpp>\n// using i128 = boost::multiprecision::int128_t;\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = vector<int>;\nusing Vll = vector<ll>;\nusing Vld = vector<ld>;\nusing Vbo = vector<bool>;\nusing VV = vector<V>;\nusing VVll = vector<Vll>;\nusing VVld = vector<Vld>;\nusing VVbo = vector<Vbo>;\nusing VVV = vector<VV>;\nusing VVVll = vector<VVll>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\n#define rep2(i, m, n) for(int i=int(m); i<int(n); ++i)\n#define drep2(i, m, n) for(int i=int(m)-1; i>=int(n); --i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) a.begin(), a.end()\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << \" \"; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int Log2(ll x) { int k; for (k = 0; x > 0; ++k) x >>= 1; return k; } // number of binary digits\nconst int INF  = 1<<30;\nconst ll INFll = 1ll<<62;\nconst ld EPS   = 1e-10;\nconst ld PI    = acos(-1.0);\nconst int MOD  = int(1e9)+7;\n// const int MOD  = 998244353;\n\n\nint main() {\n  string s; cin >> s;\n  int K; cin >> K;\n  int n = s.size();\n\n  VVV dp(K+2, VV(n+1, V(n+1)));\n\n  rep(k, K+1) rep(i, n) rep(j, n) {\n    chmax(dp[k][i+1][j+1], dp[k][i+1][j]);\n    chmax(dp[k][i+1][j+1], dp[k][i][j+1]);\n    chmax(dp[k][i+1][j+1], dp[k][i][j] + (s[i] == s[n-1-j]));\n    chmax(dp[k+1][i+1][j+1], dp[k][i+1][j]);\n    chmax(dp[k+1][i+1][j+1], dp[k][i][j+1]);\n    chmax(dp[k+1][i+1][j+1], dp[k][i][j] + 1);\n  }\n  int ans = 0;\n  rep(i, n+1) chmax(ans, dp[K][i][n-i]*2);\n  rep(i, n) chmax(ans, dp[K][i+1][n-i]*2-1);\n  \n  // rep(i, n+1) cout << dp[0][i] << \"\\n\";\n\n  // cout << \"\\n\";\n\n  // VV a(n+1, V(n+1));\n  // rep(i, n) rep(j, n) if (s[i] == s[n-1-j]) ++a[i][j];\n  // rep(i, n+1) cout << a[i] << \"\\n\";\n\n  \n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nint dp[310][310][310];\n\nint main() {\n\tstring s, t;\n\tcin >> s;\n\tt = s;\n\treverse(ALL(t));\n\n\tint n = s.size();\n\tint K;\n\tcin >> K;\n\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tfor (int k = 0; k <= K; ++k) {\n\t\t\t\tif (s[i] == t[j]) {\n\t\t\t\t\tdp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + 1);\n\t\t\t\t} else {\n\t\t\t\t\tdp[i+1][j+1][k+1] = max(dp[i+1][j+1][k+1], dp[i][j][k] + 1);\n\t\t\t\t}\n\t\t\t\tdp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i+1][j][k]);\n\t\t\t\tdp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j+1][k]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = 0;\n\n\tfor (int m = 0; m < n; ++m) {\n\t\tfor (int k = 0; k <= K; ++k) {\n\t\t\tint t = dp[m][n-1-m][k] * 2 + 1;\n\t\t\tret = max(ret, t);\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n#define MOD 1000000007\n\nint dp[301][301];\n\nint main(){\n  string s;\n  cin>>s;\n  reverse(s.begin(),s.end());\n  string t=s;\n  reverse(s.begin(),s.end());\n  int k,n=s.length()-1;\n  cin>>k;\n  for(int i=0;i<s.length();i++){\n    if(s[i]==t[i]) continue;\n    if(s[i]==t[n-i]&&s[n-i]==t[i]){\n      k--;\n      s[i]=t[n-i]=s[n-i];\n    }\n    if(k==0) break;\n  }\n  cout<<s<<endl;\n  cout<<t<<endl;\n  for(int i=0;i<s.length();i++){\n    for(int j=0;j<s.length();j++){\n      if(s[i]==t[j]){\n        dp[i+1][j+1]=dp[i][j]+1;\n      }else{\n        dp[i+1][j+1]=max(dp[i][j+1],dp[i+1][j]);\n      }\n    }\n  }\n  cout<<dp[s.length()][s.length()]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int ms = 311;\n\nint memo[ms][ms][ms];\n\nstring s;\n\nint dp(int k, int l, int r) {\n  if (l == s.size() or r < 0) return 0;\n  int &ans = memo[k][l][r];\n  if (ans != -1) return ans;\n  ans = max(dp(k, l + 1, r), dp(k, l, r - 1));\n  if (s[l] == s[r]) ans = max(ans, 1 + dp(k, l + 1, r - 1));\n  if (k and l < r) ans = max(ans, 2 + dp(k - 1, l + 1, r - 1));\n  return ans;\n}\n\nint main() {\n  cin >> s;\n  int k;\n  cin >> k;\n  memset(memo, -1, sizeof memo);\n  cout << min(dp(k, 0, s.size() - 1), (int)s.size()) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n#define maxN 333\n\nint n, k, i, j;\nchar s[maxN];\nint dp[maxN][maxN][maxN];\n\nint compute(int l, int r, int k) {\n    if (dp[l][r][k] != 0) return dp[l][r][k];\n\n    int &ans = dp[l][r][k];\n    if (r - l + 1 <= 2) {\n        if (r == l) ans = 1;\n        if (l + 1 == r) {\n            if (s[l] == s[r])\n                ans = 2;\n            else\n                ans = (k > 0 ? 2 : 1);\n        }\n    } else {\n        ans = max(ans, compute(l + 1, r, k));\n        ans = max(ans, compute(l, r - 1, k));\n        if (s[l] == s[r]) ans = max(ans, 2 + compute(l + 1, r - 1, k));\n        if (k > 0 && s[l] != s[r]) ans = max(ans, 2 + compute(l + 1, r - 1, k - 1));\n    }\n\n    return dp[l][r][k];\n}\n\nint main()\n{\n //   freopen(\"test.in\",\"r\",stdin);\n\n    scanf(\"%s%d\", s + 1, &k);\n    n = strlen(s + 1);\n    printf(\"%d\", compute(1, n, k));\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main() {\n\tstring S;\n\tlong long K;\n\tcin >> S >> K;\n\tvector<vector<vector<long long> > > DP(K + 1, vector<vector<long long> >(S.size() + 1, vector<long long>(S.size() + 1, 0)));\n\tfor (int k = 0; k <= K; k++) {\n\t\tfor (int L = 0; L < S.size(); L++) {\n\t\t\tfor (int R = S.size(); R > L; R--) {\n\t\t\t\tif (S[L] == S[R - 1]) DP[k][L + 1][R - 1] = max(DP[k][L + 1][R - 1], DP[k][L][R] + 2);\n\t\t\t\telse if (k != K) DP[k + 1][L + 1][R - 1] = max(DP[k + 1][L + 1][R - 1], DP[k][L][R] + 2);\n\t\t\t\tDP[k][L][R - 1] = max(DP[k][L][R - 1], DP[k][L][R]);\n\t\t\t\tDP[k][L + 1][R] = max(DP[k][L + 1][R], DP[k][L][R]);\n\t\t\t\tif (k != K) DP[k + 1][L][R] = max(DP[k + 1][L][R], DP[k][L][R]);\n\t\t\t}\n\t\t}\n\t}\n\tlong long ANS = 0;\n\tfor (int L = 0; L < S.size(); L++) {\n\t\tfor (int R = S.size(); R >= L; R--) {\n\t\t\tANS = max(ANS, DP[K][L][R]);\n\t\t\tif (R == L + 1) ANS = max(ANS, DP[K][L][R] + 1);\n\t\t}\n\t}\n\tcout << ANS << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long int\n#define pb push_back\n#define mp make_pair\nint dp[301][301][601];\nint main()\n{\n    int i,j;\n    string a;\n    int k;\n    cin>>a;\n    cin>>k;\n    int n=a.size();\n\n            int z=1;\n    for(z=0;z<=k;z++)\n  {\n\n    for(i=1;i<=n;i++)\n    {\n        for(j=n;j>=1;j--)\n        {\n          int o=n-j+1;\n\n              if(i!=j)\n              {    if(z!=0)\n                      dp[i][o][z]=max(dp[i][o][z],dp[i][o][z-1]);\n                  if(a[i-1]==a[j-1])\n                     dp[i][o][z]=max(dp[i][o][z],1+dp[i-1][o-1][z]);\n                  else\n                  {\n                      if(z!=0)\n                     {\n                         \n                      dp[i][o][z]=max(dp[i][o][z],dp[i-1][o-1][z-1]+1);\n                      if(j<i)\n                        dp[i][o][z]=max(dp[i][o][z],dp[i-1][o-1][z]+1);\n                      \n                      }\n\n                      dp[i][o][z]=max(dp[i][o][z],max(dp[i-1][o][z],dp[i][o-1][z]));\n\n                  }\n\n\n              }\n              else{                    \n                 if(z!=0)\n                      dp[i][o][z]=dp[i][o][z-1];\n                 dp[i][o][z]=max(dp[i][o][z],1+dp[i-1][o-1][z]);\n\n\n                }\n\n\n        }\n\n\n\n\n    }\n\n\n\n\n\n  }\n  int ans=0;\n\n        ans=dp[n][n][k];\n\n\n    cout<<ans<<endl;\nreturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <cctype>\n#include <ctime>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <complex>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cwchar>\n#include <cwctype>\n#include <exception>\n#include <locale>\n#include <numeric>\n#include <new>\n#include <stdexcept>\n#include <limits>\n#include <valarray>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <list>\n#include <utility>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int INF = 1e9 + 7;\nint dp[305][305][305];\nchar S[305];\nint main()\n{\n\tint n, m, ans = 0;\n\tscanf(\"%s\", S + 1);\n\tn = strlen(S + 1);\n\tscanf(\"%d\", &m);\n\tdp[0][n + 1][0] = 0;\n\tfor(int i = 0; i < n; i ++) for(int j = n + 1; j > i; j --) \n\tfor(int k = 0; k <= m; k ++){\n\t\tif(i > 0) dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k]);\n\t\tif(j < n + 1) dp[i][j][k] = max(dp[i][j][k], dp[i][j + 1][k]);\n\t\tif(i > 0 && j < n + 1) {\n\t\t\tif(S[i] == S[j]) dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j + 1][k] + 1);\n\t\t\tif(k > 0) dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j + 1][k - 1] + 1);\n\t\t}\n\t\tans = max(ans, dp[i][j][k] * 2 + (j - i > 1));\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//ここから編集する\nclass Solve {\npublic:\n    string S;\n    int K;\n    vector<vector<vector<int>>> dp;\n\n    void input() {\n        cin >> S >> K;\n        dp.resize(S.size(), vector<vector<int>>(S.size(), vector<int>(K + 1, -1)));\n    }\n\n    int rec(int l, int r, int k) {\n        if (dp[l][r][k] != -1) return dp[l][r][k];\n        if (l == r) return 1;\n        if (l + 1 == r) {\n            if (k > 0 || S[l] == S[r]) {\n                return 2;\n            } else {\n                return 1;\n            }\n        }\n\n        int ret = 0;\n        if (S[l] == S[r]) {\n            chmax(ret, 2 + rec(l + 1, r - 1, k));\n        } else {\n            ll tmp;\n            if (k > 0) {\n                tmp = 2 + rec(l + 1, r - 1, k - 1);\n                chmax(ret, tmp);\n            }\n            tmp = rec(l, r - 1, k);\n            chmax(ret, tmp);\n            tmp = rec(l + 1, r, k);\n            chmax(ret, tmp);\n        }\n        return dp[l][r][k] = ret;\n    }\n\n    void solve() {\n        input();\n        int ans = rec(0, S.size() - 1, K);\n        cout << ans << endl;\n\n\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    Solve().solve();\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n \n\nint dp[305][305][305];\n\n\nsigned main()\n{\n \nios_base::sync_with_stdio(false);\ncin.tie(NULL);  \ncout.tie(0);   \n \n \n#ifndef ONLINE_JUDGE\n    if(fopen(\"INPUT.txt\",\"r\"))\n    {\n    freopen (\"INPUT.txt\" , \"r\" , stdin);\n    freopen (\"OUTPUT.txt\" , \"w\" , stdout);\n    }\n#endif    \n\n    string a;\n    cin>>a;\n    int k;\n    cin>>k;\n    int n=a.length();\n    a=\"#\"+a;\n    for(int i=n;i>=1;i--)\n    {\n        dp[i][i][0]=1;\n        for(int j=i+1;j<=n;j++)\n        {\n            for(int l=0;l<=k;l++)\n            {\n                if(a[i]==a[j])\n                {\n                    dp[i][j][l]=dp[i+1][j-1][l]+2;\n                }\n                else\n                {\n                    if(l>0)\n                        dp[i][j][l]=dp[i+1][j-1][l-1]+2;\n                } \n                dp[i][j][l]=max({dp[i][j][l],dp[i+1][j][l],dp[i][j-1][l]});\n            }\n        }\n    }\n\n    int mx=0;\n    for(int i=0;i<=k;i++)\n        mx=max(mx,dp[1][n][i]);\n    cout<<mx;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint64_t dp[310][310][310];\nstring s;int64_t K;\nint main(){\ncin>>s>>K;\n  int64_t N=s.size();\n  for(int i=0;i<N;i++)\n    dp[i][i][0]=1;\n  for(int i=0;i<N-1;i++)\n    if(s.at(i)==s.at(i+1))\n      dp[i][i+1][0]=2;\n  else\n    dp[i][i+1][0]=1;\n  for(int j=2;j<=N-1;j++)\n    for(int i=0;i<N-j;i++){\n    if(s.at(i)==s.at(i+j))\n      dp[i][i+j][0]=2+dp[i+1][i+j-1][0];\n      else\n        dp[i][i+j][0]=max(dp[i+1][i+j][0],dp[i][i+j-1][0]);\n    }for(int i=0;i<N-1;i++)\n      dp[i][i+1][1]=2;\n  for(int k=1;k<=K;k++)\n      for(int j=2;j<=N-1;j++)\n        for(int i=0;i<N-j;i++){\n        if(s.at(i)==s.at(i+j))\n          dp[i][i+j][k]=2+dp[i+1][i+j-1][k];\n          else\ndp[i][i+j][k]=max(2+dp[i+1][i+j-1][k-1],dp[i][i+j-1][k]);\n          \n        }cout<<dp[0][N-1][K]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 262144\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nint dp[400][400][400];\nint visited[400][400];\nint k = 0;\nstring s;\nvoid solve(int left, int right) {\n\tif (left > right) return;\n\tif (visited[left][right] == 1) return;\n\tvisited[left][right] = 1;\n\tsolve(left + 1, right);\n\tfor (int q = 0; q <= k; ++q) {\n\t\tdp[left][right][q] = max(dp[left][right][q], dp[left + 1][right][q]);\n\t\tdp[left][right][q + 1] = max(dp[left][right][q], dp[left][right][q + 1]);\n\t}\n\tsolve(left, right - 1);\n\tfor (int q = 0; q <= k; ++q) {\n\t\tdp[left][right][q] = max(dp[left][right][q], dp[left][right - 1][q]);\n\t\tdp[left][right][q + 1] = max(dp[left][right][q], dp[left][right][q + 1]);\n\t}\n\tsolve(left + 1, right - 1);\n\tfor (int q = 0; q <= k; ++q) {\n\t\tif (s[left] == s[right]) {\n\t\t\tdp[left][right][q] = max(dp[left][right][q], dp[left + 1][right - 1][q]+2);\n\t\t}\n\t\telse {\n\t\t\tdp[left][right][q + 1] = max(dp[left][right][q + 1], dp[left + 1][right - 1][q] + 2);\n\t\t}\n\t\tdp[left][right][q + 1] = max(dp[left][right][q], dp[left][right][q+1]);\n\t}\n}\nint main() {\n\tcin >> s;\n\tcin >> k;\n\tfor (int i = 0; i < s.length(); ++i) {\n\t\tREP(j, k + 1) {\n\t\t\tdp[i][i][j] = 1;\n\t\t}\n\t\tvisited[i][i] = 1;\n\t}\n\tfor (int i = 0; i < s.length() - 1; ++i) {\n\t\tREP(j, k + 1) {\n\t\t\tif (s[i] == s[i + 1]) {\n\t\t\t\tdp[i][i + 1][j] = 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][i + 1][j + 1] = 2;\n\t\t\t}\n\t\t}\n\t}\n\tsolve(0, s.length() - 1);\n\tlong long ans = 0;\n\tREP(j, k + 1) {\n\t\tans = max(ans, dp[0][s.length() - 1][j]);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "Haskell",
    "code": "import qualified Data.Vector as V\n\nsolve :: String -> Int -> Int\nsolve valS valK = dp 0 lenS valK\n  where\n    lenS = length valS\n    vecS = V.fromList valS\n\n    dp :: Int -> Int -> Int -> Int\n    dp st 0 n = 0\n    dp st 1 n = 1\n    dp st len n\n      | vecS V.! st == vecS V.! (st+len-1) =\n                    max shorter (2 + ds V.! (idx (st+1, len-2, n  )))\n      | n > 0     = max shorter (2 + ds V.! (idx (st+1, len-2, n-1)))\n      | otherwise =     shorter\n      where shorter = max (ds V.! (idx (st, len-1, n)))\n                          (ds V.! (idx (st+1, len-1, n)))\n\n    ds = V.fromList \n           [dp st len n | st <- [0..lenS-1],\n                          len <- [0..lenS],\n                          n <- [0..valK]]\n\n    idx (st, len, n) = (st * (lenS+1) + len) * (valK + 1) + n\n\nmain :: IO ()\nmain = do\n  cont <- getContents\n  let [valS, kk] = words cont\n      valK = read kk\n      answer = solve valS valK\n  putStrLn (show answer)\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n\n#define POS(cnt,L,R) (((cnt)*(n+1)+(L))*(n+1)+(R))\n\nvoid run(void){\n  char *s=(char *)calloc(301,sizeof(char));\n  scanf(\"%s\",s);\n  const int n=strlen(s);\n  int k;\n  scanf(\"%d\",&k);\n  int *dp=(int *)calloc((n+1)*(n+1)*(k+1),sizeof(int));\n  for(int cnt=0;cnt<=k;cnt++){\n    for(int l=0;l<n;l++){\n      dp[POS(cnt,l,l+1)]=1;\n    }\n    for(int len=2;len<=n;len++){\n      for(int l=0;l+len<=n;l++){\n\tif(s[l]==s[l+len-1]){\n\t  dp[POS(cnt,l,l+len)]=dp[POS(cnt,l+1,l+len-1)]+2;\n\t} else {\n\t  int a=cnt>0?dp[POS(cnt-1,l+1,l+len-1)]+2:0;\n\t  int b=dp[POS(cnt,l+1,l+len)];\n\t  int c=dp[POS(cnt,l,l+len-1)];\n\t  dp[POS(cnt,l,l+len)]=MAX(a,MAX(b,c));\n\t}\n      }\n    }\n  }\n  printf(\"%d\\n\",dp[POS(k,0,n)]);\n}\n\nint main(void){\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*\ncat <<EOF >mistaken-paste\n*/\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 200000000000007LL\n\n#define MOD 1000000007\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 200000\n#define M_MAX 200000\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\n\ntypedef struct {\n\tull s;\n\tull t;\n\tint32_t c;\n} struct_a;\n\ntypedef struct {\n\tint32_t from;\n\tint32_t to;\n\tsll cost;\n} struct_b;\n\null n, m;\null h, w;\null k;\null q;\null vua, vub, vuc, vud, vue, vuf;\nsll vsa, vsb, vsc, vsd, vse, vsf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nsize_t slen;\nsize_t tlen;\nchar ch, dh;\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nchar s[401];\n\null dp[305][305][305];\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tn = strlen(s);\n\tfor (j = 0; j <= n; j++) {\n\t\tfor (i = 0; i + j <= n; i++) {\n\t\t\tfor (ki = 0; ki <= k; ki++) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tdp[i][j][ki] = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (j == 1) {\n\t\t\t\t\tdp[i][j][ki] = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tbool isaddable = (s[i] == s[i + j - 1]);\n\t\t\t\tmaybe = umax(umax(dp[i][j - 1][ki], dp[i + 1][j - 1][ki]), dp[i + 1][j - 2][ki] + (isaddable ? 2 : 0));\n\t\t\t\tif (!isaddable && ki) {\n\t\t\t\t\tmaybe = umax(maybe, dp[i + 1][j - 2][ki - 1] + 2);\n\t\t\t\t}\n\n\t\t\t\tdp[i][j][ki] = maybe;\n\t\t\t\t// printf(\"%lld/%lld/%lld: %lld\\n\", i, j, ki, maybe);\n\t\t\t}\n\t\t}\n\t}\n\n\tresult = 0;\n\tfor (ki = 0; ki <= k; ki++) {\n\t\tresult = umax(result, dp[0][n][ki]);\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\n\treturn 0;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\tscanf(\"%s\", s);\n\tscanf(\"%llu\", &k);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main()\n{\n\tint K;\n\tchar S[301];\n\tscanf(\"%s\", S);\n\tscanf(\"%d\", &K);\n\t\n\tint i, l;\n\tchar T[301];\n\tfor (l = 0; S[l] != 0; l++);\n\tfor (i = 0, T[l] = 0; i < l; i++) T[i] = S[l-i-1];\n\tif (K >= l / 2) {\n\t\tprintf(\"%d\\n\", l);\n\t\tfflush(stdout);\n\t\treturn 0;\n\t}\n\t\n\tint j, k, dp[151][301][301] = {};\n\tfor (i = 1; i <= l; i++) {\n\t\tfor (j = 1; j <= l; j++) {\n\t\t\tfor (k = 0; k <= K; k++) {\n\t\t\t\tif (dp[k][i-1][j] > dp[k][i][j]) dp[k][i][j] = dp[k][i-1][j];\n\t\t\t\tif (dp[k][i][j-1] > dp[k][i][j]) dp[k][i][j] = dp[k][i][j-1];\n\t\t\t\tif (S[i-1] == T[j-1] && dp[k][i-1][j-1] >= dp[k][i][j]) dp[k][i][j] = dp[k][i-1][j-1] + 1;\n\t\t\t\tif (dp[k][i-1][j-1] >= dp[k+1][i][j]) dp[k+1][i][j] = dp[k][i-1][j-1] + 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (i = 1; i <= l; i++) {\n\t\tfor (k = 0; k <= K; k++) {\n\t\t\tif (dp[k][i][l-i] * 2 > ans) ans = dp[k][i][l-i] * 2;\n\t\t\tif (dp[k][i][l-i-1] * 2 + 1 > ans) ans = dp[k][i][l-i-1] * 2 + 1;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#define F(a,b,c) for(a=b;a<=c;++a)\n#define upd(a,b) (a<b?a=b:0)\nchar s[301];c,i,j,k,n,f[301][301][301],a;main(){\nscanf(\"%s%d\",s,&c);for(n=0;s[n];++n);F(i,0,n)f[0][i][i]=1;\nF(k,0,c)F(i,1,n)F(j,i,n-1)\nif(s[j-i]-s[j]){if(k)upd(f[k][j-i][j],f[k-1][j-i+1][j-1]+2);\nupd(f[k][j-i][j],f[k][j-i+1][j]);upd(f[k][j-i][j],f[k][j-i][j-1]);\n}else upd(f[k][j-i][j],f[k][j-i+1][j-1]+2);\nF(i,0,c)upd(a,f[i][0][n-1]);printf(\"%d\\n\",a);exit(0);}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n\ntypedef int32_t i32;\n\n#define POS(l, r, x) ((((x) & 1)* (n + 1) + (l)) * (n + 1) + (r))\n\ni32 max (i32 a, i32 b) {\n  return a > b ? a : b;\n}\n\nvoid run (void) {\n  char s[301];\n  scanf (\"%s\", s);\n  i32 n = strlen (s);\n  i32 k;\n  scanf (\"%\" SCNi32, &k);\n  i32 *dp = (i32 *) calloc ((n + 1) * (n + 1) * 2, sizeof (i32));\n  for (i32 x = 0; x <= k; ++x) {\n    for (i32 l = 0; l < n; ++l) {\n      dp[POS(l, l + 1, x)] = 1;\n    }\n    for (i32 len = 2; len <= n; ++len) {\n      for (i32 l = 0; l < n + 1 - len; ++l) {\n        i32 r = l + len;\n        i32 local = max(dp[POS(l, r - 1, x)], dp[POS(l + 1, r, x)]);\n        if (s[l] == s[r - 1]) {\n          local = dp[POS(l + 1, r - 1, x)] + 2;\n        } else if (x > 0) {\n          local = max (local, dp[POS(l + 1, r - 1, x - 1)] + 2);\n        }\n        dp[POS(l, r, x)] = local;\n      }\n    }\n  }\n  printf (\"%\" PRIi32 \"\\n\", dp[POS(0, n, k)]);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*\ncat <<EOF >mistaken-paste\n*/\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 200000000000007LL\n\n#define MOD 1000000007\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 200000\n#define M_MAX 200000\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\n\ntypedef struct {\n\tull s;\n\tull t;\n\tint32_t c;\n} struct_a;\n\ntypedef struct {\n\tint32_t from;\n\tint32_t to;\n\tsll cost;\n} struct_b;\n\null n, m;\null h, w;\null k;\null q;\null vua, vub, vuc, vud, vue, vuf;\nsll vsa, vsb, vsc, vsd, vse, vsf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nsize_t slen;\nsize_t tlen;\nchar ch, dh;\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll a[N_MAX];\nsll b[N_MAX];\nsll c[N_MAX];\n\nchar s[N_MAX + 1];\n\null dp[400][400][400];\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tn = strlen(s);\n\tfor (j = 0; j <= n; j++) {\n\t\tfor (i = 0; i + j <= n; i++) {\n\t\t\tfor (ki = 0; ki <= k; ki++) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tdp[i][j][ki] = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (j == 1) {\n\t\t\t\t\tdp[i][j][ki] = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tbool isaddable = (s[i] == s[i + j - 1]);\n\t\t\t\tmaybe = umax(umax(dp[i][j - 1][ki], dp[i + 1][j - 1][ki]), dp[i + 1][j - 2][ki] + (isaddable ? 2 : 0));\n\t\t\t\tif (!isaddable && ki) {\n\t\t\t\t\tmaybe = umax(maybe, dp[i + 1][j - 2][ki - 1] + 2);\n\t\t\t\t}\n\n\t\t\t\tdp[i][j][ki] = maybe;\n\t\t\t\t// printf(\"%lld/%lld/%lld: %lld\\n\", i, j, ki, maybe);\n\t\t\t}\n\t\t}\n\t}\n\n\tresult = 0;\n\tfor (ki = 0; ki <= k; ki++) {\n\t\tresult = umax(result, dp[0][n][ki]);\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\n\treturn 0;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\tscanf(\"%s\", s);\n\tscanf(\"%llu\", &k);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20180717\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\n\nvoid shuffledget(int x[],int n){\n    srand(time(0));\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\ntypedef struct{\nint val;\nint node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\nint dp[305][305][160];\nchar s[512];\n\nint rep(int st,int fi,int cnt){\n    if(st==fi){return 1;}\n    if(st>fi){return 0;}\n    if(dp[st][fi][cnt]!=-1){\n        return dp[st][fi][cnt];\n    }\n    if(s[st]==s[fi]){\n        dp[st][fi][cnt]=2+rep(st+1,fi-1,cnt);\n    }\n    else{\n        if(cnt>0){\n            dp[st][fi][cnt]=2+rep(st+1,fi-1,cnt-1);\n        }\n    }\n    dp[st][fi][cnt]=max(rep(st+1,fi,cnt),dp[st][fi][cnt]);\n    dp[st][fi][cnt]=max(rep(st,fi-1,cnt),dp[st][fi][cnt]);\n    return dp[st][fi][cnt];\n}\n\n\nint main(void){\n    int i,j,n,m,k,a,b,c,h,w,r=0,l,t;\n    scanf(\"%s%d\",s,&k);\n    for(i=0;i<305;i++){\n        for(j=0;j<305;j++){\n            for(l=0;l<160;l++){\n                dp[i][j][l]=-1;\n            }\n        }\n    }\n    l=strlen(s);\n    if(k>155){k=155;}\n    printf(\"%d\\n\",rep(0,l-1,k));\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n\n#define POS(cnt,LEN,L) ((((cnt)&1)*(n+1)+(LEN))*(n+1)+(L))\n\nvoid run(void){\n  char *s=(char *)calloc(301,sizeof(char));\n  scanf(\"%s\",s);\n  const int n=strlen(s);\n  int k;\n  scanf(\"%d\",&k);\n  int *dp=(int *)calloc((n+1)*(n+1)*2,sizeof(int));\n  for(int cnt=0;cnt<=k;cnt++){\n    memset(dp+POS(cnt,0,0),0,sizeof(int)*(n+1)*(n+1));\n    for(int l=0;l<n;l++){\n      dp[POS(cnt,1,l)]=1;\n    }\n    for(int len=2;len<=n;len++){\n      for(int l=0;l+len<=n;l++){\n\tif(s[l]==s[l+len-1]){\n\t  dp[POS(cnt,len,l)]=dp[POS(cnt,len-2,l+1)]+2;\n\t} else {\n\t  int a=cnt>0?dp[POS(cnt-1,len-2,l+1)]+2:0;\n\t  int b=dp[POS(cnt,len-1,l)];\n\t  int c=dp[POS(cnt,len-1,l+1)];\n\t  dp[POS(cnt,len,l)]=MAX(a,MAX(b,c));\n\t}\n      }\n    }\n  }\n  printf(\"%d\\n\",dp[POS(k,n,0)]);\n}\n\nint main(void){\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <string.h>\n#include<stdio.h>\n#define MAXN 305\n\nint max(int a,int b)\n{\n\tif(a>b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\nvoid rev(char *a,char *b)\n{\n\tint i,N=strlen(b);\n\tfor(i=0;b[i];i++)\n\t\ta[N-i-1]=b[i];\n\ta[i]=0;\n\n}\nint main(void)\n{\n\tint LCS[MAXN][MAXN];\n\tint i,j,N,k;\n\tchar a[MAXN],b[MAXN];\n\tscanf(\"%s\",b);\n\tN=strlen(b);\n\tfor(i=0;i<N+1;i++)\n\t{\n\t\tLCS[0][i]=0;\n\t\tLCS[i][0]=0;\n\t}\n\trev(a,b);\n\tfor(i=1;i<=N;i++)\n\t\tfor(j=1;j<=N;j++)\n\t\t{\n\t\t\tif(a[i-1]==b[j-1])\n\t\t\t\tLCS[i][j]=LCS[i-1][j-1]+1;\n\t\t\telse\n\t\t\t\tLCS[i][j]=max(LCS[i-1][j],LCS[i][j-1]);\n\t\t}\n\n\tscanf(\"%d\",&k);\n\tprintf(\"%d\\n\",LCS[N][N]+2*k);\n\treturn 0;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main()\n{\n\tint K;\n\tchar S[301];\n\tscanf(\"%s\", S);\n\tscanf(\"%d\", &K);\n\t\n\tint i, l;\n\tchar T[301];\n\tfor (l = 0; S[l] != 0; l++);\n\tfor (i = 0, T[l] = 0; i < l; i++) T[i] = S[l-i-1];\n\tif (K >= l / 2) {\n\t\tprintf(\"%d\\n\", l);\n\t\tfflush(stdout);\n\t\treturn 0;\n\t}\n\t\n\tint j, k, dp[151][301][301] = {};\n\tfor (i = 1; i <= l; i++) {\n\t\tfor (j = 1; j <= l; j++) {\n\t\t\tfor (k = 0; k <= K; k++) {\n\t\t\t\tif (dp[k][i-1][j] > dp[k][i][j]) dp[k][i][j] = dp[k][i-1][j];\n\t\t\t\tif (dp[k][i][j-1] > dp[k][i][j]) dp[k][i][j] = dp[k][i][j-1];\n\t\t\t\tif (S[i-1] == T[j-1] && dp[k][i-1][j-1] >= dp[k][i][j]) dp[k][i][j] = dp[k][i-1][j-1] + 1;\n\t\t\t\tif (dp[k][i-1][j-1] >= dp[k+1][i][j]) dp[k+1][i][j] = dp[k][i-1][j-1] + 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (i = 0; i <= l - 1; i++) {\n\t\tfor (k = 0; k <= K; k++) {\n\t\t\tif (dp[k][i][l-i] * 2 > ans) ans = dp[k][i][l-i] * 2;\n\t\t\tif (dp[k][i][l-i-1] * 2 + 1 > ans) ans = dp[k][i][l-i-1] * 2 + 1;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint dp[301][301][301];\nint main()\n{\n\tstring str;\n\tint q;\n\tcin>>str>>q;\n\tint l=str.size();\n//\tcout<<l<<endl;\n\tfor(int i=l-1;i>=0;i--)\n\t{\n\t\tfor(int k=0;k<=q;k++)\n\t\t\tdp[i][i][k]=1;\n\t}\n\tfor(int i=l-1;i>=0;i--)\n\t{\n\t\t\n\t\tfor(int j=i+1;j<=l-1;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=q;k++)\n\t\t\t{\n\t\t\t\t//dp[i][i][k]=1; \n\t\t\t\tif(str[i]==str[j]) dp[i][j][k]=dp[i+1][j-1][k]+2;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(k!=0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][j][k]=max(dp[i+1][j][k-1]+2,dp[i][j-1][k-1]+2);\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j][k]=max(dp[i+1][j][k],dp[i][j][k]);\n\t\t\t\t\tdp[i][j][k]=max(dp[i][j-1][k],dp[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[0][l-1][q]<<endl;\n } "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main()\n{\n\tint K;\n\tchar S[301];\n\tscanf(\"%s\", S);\n\tscanf(\"%d\", &K);\n\t\n\tint i, l;\n\tchar T[301];\n\tfor (l = 0; S[l] != 0; l++);\n\tfor (i = 0, T[l] = 0; i < l; i++) T[i] = S[l-i-1];\n\tif (K >= l / 2) {\n\t\tprintf(\"%d\\n\", l);\n\t\tfflush(stdout);\n\t\treturn -1;\n\t}\n\t\n\tint j, k, dp[151][301][301] = {};\n\tfor (i = 1; i <= l; i++) {\n\t\tfor (j = 1; j <= l; j++) {\n\t\t\tfor (k = 0; k <= K; k++) {\n\t\t\t\tif (dp[k][i-1][j] > dp[k][i][j]) dp[k][i][j] = dp[k][i-1][j];\n\t\t\t\tif (dp[k][i][j-1] > dp[k][i][j]) dp[k][i][j] = dp[k][i][j-1];\n\t\t\t\tif (S[i-1] == T[j-1] && dp[k][i-1][j-1] >= dp[k][i][j]) dp[k][i][j] = dp[k][i-1][j-1] + 1;\n\t\t\t\tif (dp[k][i-1][j-1] >= dp[k+1][i][j]) dp[k+1][i][j] = dp[k][i-1][j-1] + 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (i = 1; i <= l; i++) {\n\t\tfor (k = 0; k <= K; k++) {\n\t\t\tif (dp[k][i][l-i] * 2 > ans) ans = dp[k][i][l-i] * 2;\n\t\t\tif (dp[k][i][l-i-1] * 2 + 1 > ans) ans = dp[k][i][l-i-1] * 2 + 1;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\ncat <<EOF >mistaken-paste\n*/\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 200000000000007LL\n\n#define MOD 1000000007\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 200000\n#define M_MAX 200000\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\n\ntypedef struct {\n\tull s;\n\tull t;\n\tint32_t c;\n} struct_a;\n\ntypedef struct {\n\tint32_t from;\n\tint32_t to;\n\tsll cost;\n} struct_b;\n\null n, m;\null h, w;\null k;\null q;\null vua, vub, vuc, vud, vue, vuf;\nsll vsa, vsb, vsc, vsd, vse, vsf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nsize_t slen;\nsize_t tlen;\nchar ch, dh;\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nchar s[401];\n\null dp[400][400][400];\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tn = strlen(s);\n\tfor (j = 0; j <= n; j++) {\n\t\tfor (i = 0; i + j <= n; i++) {\n\t\t\tfor (ki = 0; ki <= k; ki++) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tdp[i][j][ki] = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (j == 1) {\n\t\t\t\t\tdp[i][j][ki] = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tbool isaddable = (s[i] == s[i + j - 1]);\n\t\t\t\tmaybe = umax(umax(dp[i][j - 1][ki], dp[i + 1][j - 1][ki]), dp[i + 1][j - 2][ki] + (isaddable ? 2 : 0));\n\t\t\t\tif (!isaddable && ki) {\n\t\t\t\t\tmaybe = umax(maybe, dp[i + 1][j - 2][ki - 1] + 2);\n\t\t\t\t}\n\n\t\t\t\tdp[i][j][ki] = maybe;\n\t\t\t\t// printf(\"%lld/%lld/%lld: %lld\\n\", i, j, ki, maybe);\n\t\t\t}\n\t\t}\n\t}\n\n\tresult = 0;\n\tfor (ki = 0; ki <= k; ki++) {\n\t\tresult = umax(result, dp[0][n][ki]);\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\n\treturn 0;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\tscanf(\"%s\", s);\n\tscanf(\"%llu\", &k);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args: Array<String>) {\n  val s = readLine()!!\n  val k = readLine()!!.toInt()\n  val n = s.length\n  val dp = Array(n, { Array(n, { IntArray(k + 1, { -1 } ) })})\n\n  // Max length of Palindrome sub-sequence\n  // [l, r]: Range (closed)\n  // c: Change\n  fun doDP(l: Int, r: Int, c: Int): Int {\n    if (dp[l][r][c] >= 0) return dp[l][r][c]\n\n    fun doDPInternal(l: Int, r: Int, c: Int): Int {\n      if (l == r) return 1\n      if (r - l == 1) {\n        return if (s[l] == s[r] || c > 0) 2 else 1\n      }\n      // r - l >= 2\n      if (s[l] == s[r]) {\n        return doDP(l + 1, r - 1, c) + 2\n      } else {\n        val v1 = Math.max(doDP(l + 1, r, c), doDP(l, r - 1, c))\n        if (c == 0) return v1\n        val v2 = doDP(l + 1, r - 1, c - 1) + 2\n        return Math.max(v1, v2)\n      }\n    }\n\n    val value = doDPInternal(l, r, c)\n    dp[l][r][c] = value\n    return value\n  }\n\n  println(doDP(0, n - 1, k))\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            String s = in.next();\n            int k = in.nextInt();\n\n            int[][][] dp = new int[s.length()][s.length()][k + 1];\n\n            for (int i = s.length() - 1; i >= 0; i--) {\n                for (int j = i; j < s.length(); j++) {\n                    if (i == j) {\n                        dp[i][j][0] = 1;\n                    } else {\n                        for (int t = 0; t <= k; t++) {\n                            dp[i][j][t] = Math.max(dp[i + 1][j][t], dp[i][j - 1][t]);\n                            int cost = s.charAt(i) == s.charAt(j) ? 0 : 1;\n                            if (t - cost >= 0) {\n                                dp[i][j][t] = Math.max(dp[i][j][t], dp[i + 1][j - 1][t - cost] + 2);\n                            }\n                        }\n                    }\n                }\n            }\n\n            int max = 0;\n            for (int t = 0; t <= k; t++) {\n                max = Math.max(max, dp[0][s.length() - 1][t]);\n            }\n            out.println(max);\n        }\n\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreElements()) {\n                String line = null;\n                try {\n                    line = br.readLine();\n                } catch (IOException e) {\n                }\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Arrays;\n\nclass Main{\n\n    static int dp[][][] = new int[301][301][301];\n\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        String S = scan.next();\n        int K = scan.nextInt();\n        int N = S.length();\n\n        //dp[i][j][x]:[i,j)でx以下使ったときの最大\n        for(int i=0;i<N;++i)for(int k=0;k<=K;++k){\n            dp[i][i+1][k]=1;\n            dp[i][i][k]=0;\n        }\n        for(int k=0;k<=K;++k){\n            for(int L=2;L<=N;++L){\n                int i=0,j=L;\n                while(j<=N){\n                    if(k==0)dp[i][j][k]=Math.max(dp[i+1][j][k],\n                                        Math.max(dp[i][j-1][k],\n                                        ((S.charAt(i)==S.charAt(j-1) ? dp[i+1][j-1][k]+2 : dp[i+1][j-1][k]))));\n                    else dp[i][j][k] = Math.max(dp[i+1][j][k],\n                                       Math.max(dp[i][j-1][k],\n                                       Math.max(dp[i][j][k-1],\n                                       ((S.charAt(i)==S.charAt(j-1) ? dp[i+1][j-1][k]+2 : dp[i+1][j-1][k-1]+2)))));\n                    ++i;++j;\n                }\n            }\n        }\n        System.out.println(dp[0][N][K]);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            char[] T1 = in.next().toCharArray();\n            char[] T2 = reverse(T1);\n            int K = in.nextInt();\n            int lcs = solve(T1, T2);\n\n            int N = T1.length;\n//        for (int i = 0; i < N; i++) {\n//            if (T1[i] != T2[i] && K > 0) {\n//                char tmp1 = T1[i];\n//                char tmp2 = T2[N - i - 1];\n//                T1[i] = T2[i];\n//                T2[N - i - 1] = T1[i];\n//                K--;\n//\n//                int newLcs = solve(T1, T2);\n//\n//                if (newLcs >= lcs) {\n//                    lcs = newLcs;\n//                } else {\n//                    T1[i] = tmp1;\n//                    T2[N - i - 1] = tmp2;\n//                    K++;\n//                }\n//\n//            }\n//        }\n\n            out.println(Math.min(T1.length, lcs + 2 * K));\n        }\n\n        private char[] reverse(char[] str) {\n            char[] ans = new char[str.length];\n            for (int i = 0; i <= str.length / 2; i++) {\n                char tmp = str[str.length - i - 1];\n                ans[str.length - i - 1] = str[i];\n                ans[i] = tmp;\n            }\n            return ans;\n        }\n\n        private int solve(char[] S, char[] T) {\n            int N = S.length;\n            int M = T.length;\n\n            int[][] dp = new int[N + 1][M + 1];\n\n            for (int i = N - 1; i >= 0; i--) {\n                dp[i][M] = dp[i + 1][M];\n            }\n\n            for (int i = M - 1; i >= 0; i--) {\n                dp[N][i] = dp[N][i + 1];\n            }\n\n            for (int i = N - 1; i >= 0; i--) {\n                for (int j = M - 1; j >= 0; j--) {\n                    if (S[i] == T[j]) {\n                        dp[i][j] = 1 + dp[i + 1][j + 1];\n                    } else {\n                        dp[i][j] = Math.max(dp[i + 1][j], dp[i][j + 1]);\n                    }\n                }\n            }\n\n            return dp[0][0];\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            DReversedLCS solver = new DReversedLCS();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class DReversedLCS {\n        char[] s;\n        int[][][] dp;\n\n        public int dp(int l, int r, int k) {\n            if (l > r) {\n                return 0;\n            }\n            if (l == r) {\n                return 1;\n            }\n            if (dp[l][r][k] == -1) {\n                dp[l][r][k] = 0;\n                //change nothing\n                dp[l][r][k] = Math.max(dp(l + 1, r, k), dp(l, r - 1, k));\n                if (s[l] == s[r]) {\n                    dp[l][r][k] = dp(l + 1, r - 1, k) + 2;\n                }\n                if (k > 0) {\n                    dp[l][r][k] = Math.max(dp[l][r][k], dp(l + 1, r - 1, k - 1) + 2);\n                }\n            }\n            return dp[l][r][k];\n        }\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            s = in.readString().toCharArray();\n            int k = in.readInt();\n            dp = new int[s.length][s.length][k + 1];\n            SequenceUtils.deepFill(dp, -1);\n            int ans = dp(0, s.length - 1, k);\n            out.println(ans);\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static void deepFill(Object array, int val) {\n            if (!array.getClass().isArray()) {\n                throw new IllegalArgumentException();\n            }\n            if (array instanceof int[]) {\n                int[] intArray = (int[]) array;\n                Arrays.fill(intArray, val);\n            } else {\n                Object[] objArray = (Object[]) array;\n                for (Object obj : objArray) {\n                    deepFill(obj, val);\n                }\n            }\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 13);\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.function.IntBinaryOperator;\nimport java.util.function.IntFunction;\nimport java.util.function.IntUnaryOperator;\nimport java.util.function.LongUnaryOperator;\n\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Field f = System.out.getClass().getDeclaredField(\"autoFlush\");\n        f.setAccessible(true);\n        f.set(System.out, false);\n        execute(System.in, System.out);\n    }\n\n    public static void execute(InputStream in, OutputStream out) {\n        ExtendedScanner s = new ExtendedScanner(in);\n        Out o = new Out(out);\n        solve(s, o);\n        o.flush();\n        o.close();\n    }\n\n    public static void solve(ExtendedScanner sc, Out out) {\n        char[] s = sc.nextChars();\n        char[] t = s.clone();\n        CharArrays.reverse(t);\n        int m = sc.nextInt();\n        int n = s.length;\n        int[][][] dp = new int[n + 1][n + 1][m + 1];\n        int max = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n - i; j++) {\n                for (int k = 0; k <= m; k++) {\n                    if (s[i] == t[j]) {\n                        dp[i + 1][j + 1][k] = dp[i][j][k] + 1;\n                        if (j + 1 == n - i) {\n                            max = Ints.max(max, dp[i + 1][j + 1][k] * 2 - 1, dp[i + 1][j][k] * 2);\n                        }\n                    } else {\n                        dp[i + 1][j + 1][k] = Ints.max(dp[i + 1][j][k], dp[i][j + 1][k], k > 0 ? dp[i][j][k - 1] + 1 : 0);\n                    }\n                }\n            }\n        }\n        out.writeln(max);\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass BasicScanner {\n    private final InputStream in;\n    private final byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public BasicScanner(InputStream in) {this.in = in;}\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try {buflen = in.read(buf);}\n        catch (final IOException e) {e.printStackTrace();}\n        return buflen > 0;\n    }\n    private int readByte() {return hasNextByte() ? buf[ptr++] : -1;}\n    public boolean hasNext() {\n        while (hasNextByte() && !(33 <= buf[ptr] && buf[ptr] <= 126)) ptr++;\n        return hasNextByte();\n    }\n    private StringBuilder nextSequence() {\n        if (!hasNext()) throw new NoSuchElementException();\n        final StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}\n        return sb;\n    }\n    public char nextChar() {\n        return (char) readByte();\n    }\n    public String next() {\n        return nextSequence().toString();\n    }\n    public String next(int len) {\n        return new String(nextChars(len));\n    }\n    public char[] nextChars() {\n        final StringBuilder sb = nextSequence();\n        int l = sb.length();\n        char[] dst = new char[l];\n        sb.getChars(0, l, dst, 0);\n        return dst;\n    }\n    public char[] nextChars(int len) {\n        if (!hasNext()) throw new NoSuchElementException();\n        char[] s = new char[len];\n        int i = 0;\n        int b = readByte();\n        while (33 <= b && b <= 126 && i < len) {s[i++] = (char) b; b = readByte();}\n        if (i != len) throw new NoSuchElementException(String.format(\"length %d is longer than the sequence.\", len));\n        return s;\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {minus = true; b = readByte();}\n        if (b < '0' || '9' < b) throw new NumberFormatException();\n        while (true) {\n            if ('0' <= b && b <= '9') n = n * 10 + b - '0';\n            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;\n            else throw new NumberFormatException();\n            b = readByte();\n        }\n    }\n    public int nextInt() {return Math.toIntExact(nextLong());}\n    public double nextDouble() {return Double.parseDouble(next());}\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass Out {\n    private final OutputStream out;\n    private byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private static final int AUTO_FLUSH_THRETHOLD = 1 << 17;\n\n    public Out(OutputStream out) {\n        this.out = out;\n    }\n\n    public void flush() {\n        try {\n            out.write(buf, 0, ptr);\n            out.flush();\n            ptr = 0;\n        } catch (IOException e) {e.printStackTrace();}\n    }\n\n    public void close() {\n        try {out.close();} catch (IOException e) {e.printStackTrace();}\n    }\n\n    public Out writeln() {return write('\\n');}\n    public Out writeln(Object o) {return write(o).write('\\n');}\n    public Out writeln(String s) {return write(s).write('\\n');}\n    public Out writeln(char[] c) {return write(c).write('\\n');}\n    public Out writeln(char   c) {return write(c).write('\\n');}\n    public Out writeln(byte   b) {return write(b).write('\\n');}\n    public Out writeln(int    x) {return write(x).write('\\n');}\n    public Out writeln(long   x) {return write(x).write('\\n');}\n    public Out writeln(double d) {return write(d).write('\\n');}\n\n    public Out writeSpace() {return write(' ');}\n    \n    public Out write(Object o) {\n        return write(o.toString());\n    }\n\n    public Out write(String s) {\n        try {\n            Field strValueField = s.getClass().getDeclaredField(\"value\");\n            strValueField.setAccessible(true);\n            byte[] b = (byte[]) strValueField.get(s);\n            int l = s.length();\n            if (l > AUTO_FLUSH_THRETHOLD) {\n                flush();\n                int i = 0;\n                while (i + AUTO_FLUSH_THRETHOLD < l) {\n                    out.write(b, i, AUTO_FLUSH_THRETHOLD);\n                    out.flush();\n                    i += AUTO_FLUSH_THRETHOLD;\n                }\n                ensureCapacity(l - i);\n                System.arraycopy(b, i, buf, 0, l - i);\n                ptr = l - i;\n            } else {\n                ensureCapacity(ptr + l);\n                System.arraycopy(b, 0, buf, ptr, l);\n                ptr += l;\n            }\n        } catch (Exception e) {e.printStackTrace();}\n        return this;\n    }\n\n    public Out write(char[] c) {\n        int l = c.length;\n        if (l > AUTO_FLUSH_THRETHOLD) {\n            flush();\n            ensureCapacity(AUTO_FLUSH_THRETHOLD);\n            int i = 0;\n            while (i + AUTO_FLUSH_THRETHOLD < l) {\n                for (int j = 0; j < AUTO_FLUSH_THRETHOLD; j++) {\n                    buf[ptr++] = (byte) c[i + j];\n                }\n                flush();\n                i += AUTO_FLUSH_THRETHOLD;\n            }\n            for (; i < l; i++) {\n                buf[ptr++] = (byte) c[i];\n            }\n        } else {\n            ensureCapacity(ptr + l);\n            for (char ch : c) buf[ptr++] = (byte) ch;\n        }\n        return this;\n    }\n\n    public Out write(char c) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = (byte) c;\n        return this;\n    }\n\n    public Out write(byte b) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = b;\n        return this;\n    }\n\n    public Out write(int x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(long x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(double d) {\n        return write(Double.toString(d));\n    }\n\n    private void ensureCapacity(int cap) {\n        if (cap > AUTO_FLUSH_THRETHOLD) {\n            flush();\n        }\n        if (cap >= buf.length) {\n            int newLength = buf.length;\n            while (newLength < cap) newLength <<= 1;\n            byte[] newBuf = new byte[newLength];\n            System.arraycopy(buf, 0, newBuf, 0, buf.length);\n            buf = newBuf;\n        }\n    }\n    private static int stringSize(long x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        long p = -10;\n        for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;\n        return 19 + d;\n    }\n    private static int stringSize(int x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        int p = -10;\n        for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;\n        return 10 + d;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class Ints {\n    private Ints(){}\n    public static int max(int a, int b) {\n        return Math.max(a, b);\n    }\n    public static int max(int a, int b, int c) {\n        return Math.max(Math.max(a, b), c);\n    }\n    public static int max(int a, int b, int c, int d) {\n        return Math.max(Math.max(Math.max(a, b), c), d);\n    }\n    public static int max(int a, int b, int c, int d, int e) {\n        return Math.max(Math.max(Math.max(Math.max(a, b), c), d), e);\n    }\n    public static int max(int a, int b, int c, int d, int e, int f) {\n        return Math.max(Math.max(Math.max(Math.max(Math.max(a, b), c), d), e), f);\n    }\n    public static int max(int a, int b, int c, int d, int e, int f, int g) {\n        return Math.max(Math.max(Math.max(Math.max(Math.max(Math.max(a, b), c), d), e), f), g);\n    }\n    public static int max(int a, int b, int c, int d, int e, int f, int g, int h) {\n        return Math.max(Math.max(Math.max(Math.max(Math.max(Math.max(Math.max(a, b), c), d), e), f), g), h);\n    }\n    public static int max(int a, int... vals) {\n        int ret = a; for (int e : vals) ret = Math.max(ret, e);\n        return ret;\n    }\n    public static int min(int a, int b) {\n        return Math.min(a, b);\n    }\n    public static int min(int a, int b, int c) {\n        return Math.min(Math.min(a, b), c);\n    }\n    public static int min(int a, int b, int c, int d) {\n        return Math.min(Math.min(Math.min(a, b), c), d);\n    }\n    public static int min(int a, int b, int c, int d, int e) {\n        return Math.min(Math.min(Math.min(Math.min(a, b), c), d), e);\n    }\n    public static int min(int a, int b, int c, int d, int e, int f) {\n        return Math.min(Math.min(Math.min(Math.min(Math.min(a, b), c), d), e), f);\n    }\n    public static int min(int a, int b, int c, int d, int e, int f, int g) {\n        return Math.min(Math.min(Math.min(Math.min(Math.min(Math.min(a, b), c), d), e), f), g);\n    }\n    public static int min(int a, int b, int c, int d, int e, int f, int g, int h) {\n        return Math.min(Math.min(Math.min(Math.min(Math.min(Math.min(Math.min(a, b), c), d), e), f), g), h);\n    }\n    public static int min(int a, int... vals) {\n        int ret = a; for (int e : vals) ret = Math.min(ret, e);\n        return ret;\n    }\n    public static int fold(final IntBinaryOperator func, final int... a) {\n        int ret = a[0]; for (int i = 1; i < a.length; i++) ret = func.applyAsInt(ret, a[i]);\n        return ret;\n    }\n    public static boolean isPowerOfTwo(final int n) {return n != 0 && (-n & n) == n;}\n    public static int ceilExponent(final int n) {return 31 - Integer.numberOfLeadingZeros(n) + (isPowerOfTwo(n) ? 0 : 1);}\n    public static int floorExponent(final int n) {return 31 - Integer.numberOfLeadingZeros(n) + (n == 0 ? 1 : 0);}\n    /**\n     * Caluculate the ceil of a/b. Returns the smallest integer greater than or\n     * equal to a/b while 'a/b' rounds fractional parts to ZERO.\n     * @param a\n     * @param b\n     * @return the smallest integer greater than or equal to a/b\n     */\n    public static int cld(final int a, final int b) {\n        if (a > 0 && b > 0) return (a + b - 1) / b;\n        if (a < 0 && b < 0) return (a + b + 1) / b;\n        return a / b;\n    }\n    /**\n     * Caluculate the floor of a/b. Returns the largest integer less than or equal\n     * to a/b while 'a/b' rounds fractional parts to ZERO.\n     * @param a\n     * @param b\n     * @return the largest integer less than or equal to a/b\n     */\n    public static int fld(final int a, final int b) {\n        if (a <= 0 && b > 0) return (a - b + 1) / b;\n        if (a > 0 && b <= 0) return (a - b - 1) / b;\n        return a / b;\n    }\n    public static String join(final String sep, final int... a) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < a.length; i++) {\n            sb.append(a[i]);\n            if (i < a.length - 1)  sb.append(sep);\n        }\n        return sb.toString();\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class ExtendedScanner extends BasicScanner {\n    public ExtendedScanner(InputStream in) {super(in);}\n    public int[] ints(final int n) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> nextInt());\n        return a;\n    }\n    public int[] ints(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> f.applyAsInt(nextInt()));\n        return a;\n    }\n    public int[][] ints(final int n, final int m) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m));\n        return a;\n    }\n    public int[][] ints(final int n, final int m, final IntUnaryOperator f) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m, f));\n        return a;\n    }\n    public long[] longs(final int n) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> nextLong());\n        return a;\n    }\n    public long[] longs(final int n, final LongUnaryOperator f) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> f.applyAsLong(nextLong()));\n        return a;\n    }\n    public long[][] longs(final int n, final int m) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m));\n        return a;\n    }\n    public long[][] longs(final int n, final int m, final LongUnaryOperator f) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m, f));\n        return a;\n    }\n    public char[][] charArrays(final int n) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars());\n        return c;\n    }\n    public char[][] charArrays(final int n, final int m) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars(m));\n        return c;\n    }\n    public double[] doubles(final int n) {\n        final double[] a = new double[n];\n        Arrays.setAll(a, $ -> nextDouble());\n        return a;\n    }\n    public double[][] doubles(final int n, final int m) {\n        final double[][] a = new double[n][];\n        Arrays.setAll(a, $ -> doubles(m));\n        return a;\n    }\n    public String[] strings(final int n) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next());\n        return s;\n    }\n    public String[] strings(final int n, final int m) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next(m));\n        return s;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n * \n * 1. DESTRUCTIVE methods for char arrays.\n * 2. methods that receives arrays and return some results (except for char arrays).\n */\nfinal class CharArrays {\n    private CharArrays(){}\n    public static void swap(final char[] a, final int u, final int v) {\n        final char tmp = a[u]; a[u] = a[v]; a[v] = tmp;\n    }\n    public static void reverse(final char[] a, int begin, int end) {\n        while (end - begin > 1) swap(a, begin++, --end);\n    }\n    public static void reverse(final char[] a) {reverse(a, 0, a.length);}\n    public static void sortDescending(final char[] a) {Arrays.sort(a); reverse(a);}\n    public static void transpose(char[][] a) {\n        final int n = a.length, m = a[0].length;\n        final char[][] ret = new char[m][n];\n        for (int j = 0; j < m; j++) for (int i = 0; i < n; i++) ret[j][i] = a[i][j];\n        a = ret;\n    }\n    public static String join(final char[] a, final String sep) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < a.length; i++) {\n            sb.append(a[i]);\n            if (i < a.length - 1) sb.append(sep);\n        }\n        return sb.toString();\n    }\n    public static String join(final char[][] a, final String sep) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < a.length; i++) {\n            sb.append(a[i]);\n            if (i < a.length - 1) sb.append(sep);\n        }\n        return sb.toString();\n    }\n    public static String joinWithPrefixAndSuffix(final char[] a, final IntFunction<String> idxToPre, final IntFunction<String> idxToSuf, final String sep) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < a.length; i++) {\n            sb.append(idxToPre.apply(i)).append(a[i]).append(idxToSuf.apply(i));\n            if (i < a.length - 1) sb.append(sep);\n        }\n        return sb.toString();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            String s = in.next();\n            int k = in.nextInt();\n            int[][][] best = new int[s.length() + 1][s.length() + 1][k + 1];\n            for (int pos = s.length() - 1; pos >= 0; --pos) {\n                Arrays.fill(best[pos][1], 1);\n                for (int len = 2; pos + len <= s.length(); ++len) {\n                    if (s.charAt(pos) == s.charAt(pos + len - 1)) {\n                        for (int i = 0; i <= k; ++i) {\n                            best[pos][len][i] = 2 + best[pos + 1][len - 2][i];\n                        }\n                    } else {\n                        for (int i = 0; i <= k; ++i) {\n                            best[pos][len][i] = Math.max(best[pos + 1][len - 1][i], best[pos][len - 1][i]);\n                            if (i > 0) {\n                                best[pos][len][i] = Math.max(best[pos][len][i], 2 + best[pos + 1][len - 2][i - 1]);\n                            }\n                        }\n                    }\n                }\n            }\n            out.println(best[0][s.length()][k]);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            String T1 = in.next();\n            String T2 = reverse(T1);\n            int K = in.nextInt();\n\n            int lcs = solve(T1, T2);\n            out.println(Math.min(T1.length(), lcs + 2 * K));\n        }\n\n        private String reverse(String str) {\n            char[] ans = str.toCharArray();\n            for (int i = 0; i < str.length() / 2; i++) {\n                char tmp = ans[str.length() - i - 1];\n                ans[str.length() - i - 1] = ans[i];\n                ans[i] = tmp;\n            }\n            return new String(ans);\n        }\n\n        private int solve(String S, String T) {\n            int N = S.length();\n            int M = T.length();\n\n            int[][] dp = new int[N + 1][M + 1];\n\n            for (int i = N - 1; i >= 0; i--) {\n                dp[i][M] = dp[i + 1][M];\n            }\n\n            for (int i = M - 1; i >= 0; i--) {\n                dp[N][i] = dp[N][i + 1];\n            }\n\n            for (int i = N - 1; i >= 0; i--) {\n                for (int j = M - 1; j >= 0; j--) {\n                    if (S.charAt(i) == T.charAt(j)) {\n                        dp[i][j] = 1 + dp[i + 1][j + 1];\n                    } else {\n                        dp[i][j] = Math.max(dp[i + 1][j + 1], Math.max(dp[i + 1][j], dp[i][j + 1]));\n                    }\n                }\n            }\n\n            return dp[0][0];\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "// package agc.agc021;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    public static void updMax(int[][][] dp, int i, int j, int k, int a) {\n        dp[i][j][k] = Math.max(dp[i][j][k], a);\n    }\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        char[] s = in.nextToken().toCharArray();\n        int k = in.nextInt();\n\n        int n = s.length;\n\n        // dp[i][j][k]: i < j\n        int[][][] dp = new int[n][n+1][k+1];\n        for (int i = 0; i < dp.length; i++) {\n            for (int j = 0; j < dp[0].length; j++) {\n                Arrays.fill(dp[i][j], -1);\n            }\n        }\n        dp[0][n-1][0] = 0;\n\n        for (int i = 0; i < n ; i++) {\n            for (int j = n-1 ; j > i ; j--) {\n                for (int l = 0; l <= k ; l++) {\n                    if (dp[i][j][l] == -1) {\n                        continue;\n                    }\n                    int base = dp[i][j][l];\n                    if (i+1 <= j) {\n                        updMax(dp, i+1, j, l, base);\n                    }\n                    if (i <= j-1) {\n                        updMax(dp, i, j-1, l, base);\n                    }\n                    if (s[i] != s[j]) {\n                        if (l+1 <= k) {\n                            updMax(dp, i+1, j-1, l+1, base+2);\n                        }\n                    } else {\n                        updMax(dp, i+1, j-1, l, base+2);\n                    }\n                }\n            }\n        }\n\n        int best = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n ; j++) {\n                for (int l = 0; l <= k; l++) {\n                    best = Math.max(best, dp[i][j][l] + ((i == j) ? 1 : 0));\n                }\n            }\n        }\n        out.println(best);\n        out.flush();\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author prakharjain\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        agc021_d solver = new agc021_d();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class agc021_d {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n            String s = in.next();\n\n            int n = s.length();\n\n            int k = in.nextInt();\n\n            int[][][] dp = new int[n][n][k + 1];\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    for (int l = 0; l <= k; l++) {\n                        dp[i][j][l] = -1;\n                    }\n                }\n            }\n\n            out.println(rec(dp, 0, n - 1, k, s));\n        }\n\n        int rec(int[][][] dp, int i, int j, int k, String s) {\n            if (i > j)\n                return 0;\n\n            if (dp[i][j][k] != -1)\n                return dp[i][j][k];\n\n            if (i == j) {\n                return dp[i][j][k] = 1;\n            }\n\n            int ans = 0;\n            if (s.charAt(i) == s.charAt(j)) {\n                ans = 2 + rec(dp, i + 1, j - 1, k, s);\n            } else {\n                ans = Math.max(rec(dp, i, j - 1, k, s), rec(dp, i + 1, j, k, s));\n                if (k > 0) {\n                    ans = Math.max(ans, 2 + rec(dp, i + 1, j - 1, k - 1, s));\n                }\n\n            }\n\n            return dp[i][j][k] = ans;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String nextString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                if (Character.isValidCodePoint(c)) {\n                    res.appendCodePoint(c);\n                }\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public String next() {\n            return nextString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tvoid submit() {\n\t\tchar[] s = nextToken().toCharArray();\n\t\tint k = nextInt();\n\t\t\n\t\tint n = s.length;\n\t\t\n\t\tint[][][] dp = new int[k + 1][n][n];\n\t\tfor (int z = 0; z <= k; z++) {\n\t\t\t\n\t\t\tint[][] now = dp[z];\n\t\t\tint[][] prev = z == 0 ? null : dp[z - 1];\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tnow[i][i] = 1;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i + 1 < n; i++) {\n\t\t\t\tif (s[i] == s[i + 1]) {\n\t\t\t\t\tnow[i][i + 1] = 2;\n\t\t\t\t} else {\n\t\t\t\t\tnow[i][i + 1] = z > 0 ? 2 : 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int len = 3; len <= n; len++) {\n\t\t\t\tfor (int i = 0; i + len - 1 < n; i++) {\n\t\t\t\t\tint j = i + len - 1;\n\t\t\t\t\t\n\t\t\t\t\tnow[i][j] = Math.max(now[i + 1][j], now[i][j - 1]);\n\t\t\t\t\tif (s[i] == s[j]) {\n\t\t\t\t\t\tnow[i][j] = Math.max(now[i][j], now[i + 1][j - 1] + 2);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (z > 0) {\n\t\t\t\t\t\tnow[i][j] = Math.max(now[i][j], prev[i + 1][j - 1] + 2);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tout.println(dp[k][0][n - 1]);\n\t}\n\n\tvoid preCalc() {\n\n\t}\n\n\tvoid stress() {\n\n\t}\n\n//\tint lsp(char[] s) {\n//\t\tint n = s.length;\n//\t\tint[][] dp = new int[n][n];\n//\t\tfor (int i = 0; i < n; i++) {\n//\t\t\tdp[i][i] = 1;\n//\t\t}\n//\t\t\n//\t\tfor (int i = 0; i + 1 < n; i++) {\n//\t\t\tif (s[i] == s[i + 1]) {\n//\t\t\t\tdp[i][i + 1] = 2;\n//\t\t\t} else {\n//\t\t\t\tdp[i][i + 1] = 1;\n//\t\t\t}\n//\t\t}\n//\t\t\n//\t\tfor (int len = 3; len <= n; len++) {\n//\t\t\tfor (int i = 0; i + len - 1 < n; i++) {\n//\t\t\t\tint j = i + len - 1;\n//\t\t\t\t\n//\t\t\t\tdp[i][j] = Math.max(dp[i + 1][j], now[i + 1][j]);\n//\t\t\t\tif (s[i] == s[j]) {\n//\t\t\t\t\tnow[i][j] = Math.max(now[i][j], now[i + 1][j - 1] + 2);\n//\t\t\t\t}\n//\t\t\t\t\n//\t\t\t\tif (z > 0) {\n//\t\t\t\t\tnow[i][j] = Math.max(now[i][j], prev[i + 1][j - 1] + 2);\n//\t\t\t\t}\n//\t\t\t\t\n//\t\t\t}\n//\t\t}\n//\t}\n\t\n\tvoid test() {\n//\t\tchar[] s = \"atcodergrandcontest\".toCharArray();\n//\t\tfor (int i = 0; i < s.length; i++) {\n//\t\t\tfor (int j = i + 1; j < s.length; j++) {\n//\t\t\t\tfor (int k = j + 1; k < s.length; k++) {\n//\t\t\t\t\tchar[] s1 = s.clone();\n//\t\t\t\t\ts1[i] = s1[j] = s1[k] = '?';\n//\t\t\t\t\tans = Math.max(ans, lsp(s1));\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n//\t\tSystem.err.println(ans);\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tpreCalc();\n\t\tsubmit();\n\t\t//stress();\n\t\t//test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Array;\nimport java.util.*;\n\npublic class Main implements Runnable {\n    static ContestScanner in;\n    static Writer out;\n    public static void main(String[] args) {\n        new Thread(null, new Main(), \"\", 16 * 1024 * 1024).start();\n    }\n\n    public void run() {\n        Main main = new Main();\n        try {\n            in = new ContestScanner();\n            out = new Writer();\n            main.solve();\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    void solve() throws IOException {\n        s = in.nextToken().toCharArray();\n        int k = in.nextInt();\n        len = s.length;\n        dp = new int[len][len][k + 1];\n        for (int i = 0; i < len; i++) {\n            for (int j = 0; j < len; j++) {\n                for (int l = 0; l <= k; l++) {\n                    dp[i][j][l] = -1;\n                }\n            }\n        }\n        System.out.println(dfs(0, len - 1, k));\n    }\n\n    int len;\n    char[] s;\n    int[][][] dp;\n    int dfs(int l, int r, int k) {\n        if(r < l || k < 0) return -10;\n        else if(r == l) return 1;\n        if(dp[l][r][k] >= 0) return dp[l][r][k];\n        int ans = 0;\n        if(s[l] == s[r]) ans = dfs(l + 1, r - 1, k) + 2;\n        ans = Math.max(ans, dfs(l + 1, r, k));\n        ans = Math.max(ans, dfs(l, r - 1, k));\n        ans = Math.max(ans, dfs(l + 1, r - 1, k - 1) + 2);\n        return dp[l][r][k] = ans;\n    }\n}\n\n@SuppressWarnings(\"serial\")\nclass MultiSet<T> extends HashMap<T, Integer>{\n    @Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n    public void add(T key,int v){put(key,get(key)+v);}\n    public void add(T key){put(key,get(key)+1);}\n    public void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n    public MultiSet<T> merge(MultiSet<T> set)\n    {MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n        for(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\n\nclass Writer extends PrintWriter{\n    public Writer(String filename)throws IOException\n    {super(new BufferedWriter(new FileWriter(filename)));}\n    public Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n    private BufferedReader in;private int c=-2;\n    public ContestScanner()throws IOException\n    {in=new BufferedReader(new InputStreamReader(System.in));}\n    public ContestScanner(String filename)throws IOException\n    {in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n    public String nextToken()throws IOException {\n        StringBuilder sb=new StringBuilder();\n        while((c=in.read())!=-1&&Character.isWhitespace(c));\n        while(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n        return sb.toString();\n    }\n    public String readLine()throws IOException{\n        StringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n        while(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n        return sb.toString();\n    }\n    public long nextLong()throws IOException,NumberFormatException\n    {return Long.parseLong(nextToken());}\n    public int nextInt()throws NumberFormatException,IOException\n    {return(int)nextLong();}\n    public double nextDouble()throws NumberFormatException,IOException\n    {return Double.parseDouble(nextToken());}\n    public void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    FastScanner in;\n    PrintWriter out;\n\n\n    void solve() {\n        char[] s = in.next().toCharArray();\n        int n = s.length;\n        int maxChange = in.nextInt();\n        int[][][] dp = new int[maxChange + 2][n][n];\n        for (int i = 0; i < n; i++) {\n            dp[0][i][i] = 1;\n            if (i + 1 < n) {\n                if (s[i] == s[i + 1]) {\n                    dp[0][i][i + 1] = 2;\n                } else {\n                    dp[1][i][i + 1] = 2;\n                }\n            }\n        }\n        for (int len = 1; len <= n; len++) {\n            for (int fr = 0; fr + len <= n; fr++) {\n                int to = fr + len - 1;\n                for (int ch = 0; ch <= maxChange; ch++) {\n                    int cur = dp[ch][fr][to];\n                    if (fr > 0) {\n                        dp[ch][fr - 1][to] = Math.max(dp[ch][fr - 1][to], cur);\n                    }\n                    if (to + 1 < n) {\n                        dp[ch][fr][to + 1] = Math.max(dp[ch][fr][to + 1], cur);\n                    }\n                    if (fr > 0 && to + 1 < n) {\n                        if (s[fr - 1] == s[to + 1]) {\n                            dp[ch][fr - 1][to + 1] = Math.max(dp[ch][fr - 1][to + 1], cur + 2);\n                        } else {\n                            dp[ch + 1][fr - 1][to + 1] = Math.max(dp[ch + 1][fr - 1][to + 1], cur + 2);\n                        }\n                    }\n                }\n            }\n        }\n        int res = 0;\n        for (int ch = 0; ch <= maxChange; ch++) {\n            res = Math.max(res, dp[ch][0][n - 1]);\n        }\n        out.println(res);\n    }\n\n\n    void run() {\n        try {\n            in = new FastScanner(new File(\"Main.in\"));\n            out = new PrintWriter(new File(\"Main.out\"));\n\n            solve();\n\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    void runIO() {\n\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        solve();\n\n        out.close();\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().runIO();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tchar[] s = ns().toCharArray();\n\t\tint n = s.length;\n\t\tint K = Math.min(n/2, ni());\n\t\tint[][][] dp = new int[K+1][n][n];\n\t\tint I = -9999999;\n\t\tfor(int i = 0;i <= K;i++){\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tArrays.fill(dp[i][j], I);\n\t\t\t}\n\t\t}\n\t\tfor(int len = 1;len <= n;len++){\n\t\t\tfor(int i = 0;i+len-1 < n;i++){\n\t\t\t\tint j = i+len-1;\n\t\t\t\tif(len == 1){\n\t\t\t\t\tdp[0][i][j] = 1;\n\t\t\t\t}else if(len == 2){\n\t\t\t\t\tif(s[i] == s[j]){\n\t\t\t\t\t\tdp[0][i][j] = 2;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[0][i][j] = 1;\n\t\t\t\t\t\tif(K >= 1){\n\t\t\t\t\t\t\tdp[1][i][j] = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tfor(int k = 0;k <= K;k++){\n\t\t\t\t\t\tdp[k][i][j] = Math.max(dp[k][i][j-1], dp[k][i+1][j]);\n\t\t\t\t\t}\n\t\t\t\t\tif(s[i] == s[j]){\n\t\t\t\t\t\tfor(int k = 0;k <= K;k++){\n\t\t\t\t\t\t\tdp[k][i][j] = Math.max(dp[k][i+1][j-1] + 2, dp[k][i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(int k = 1;k <= K;k++){\n\t\t\t\t\t\t\tdp[k][i][j] = Math.max(dp[k-1][i+1][j-1] + 2, dp[k][i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0;i <= K;i++){\n\t\t\tans = Math.max(ans, dp[i][0][n-1]);\n\t\t}\n\t\tout.println(ans);\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        int[][][] answer;\n        String s;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            s = in.readString();\n            int n = s.length();\n            int k = in.readInt();\n            answer = new int[n][n][k + 1];\n            ArrayUtils.fill(answer, -1);\n            out.printLine(go(0, n - 1, k));\n        }\n\n        private int go(int from, int to, int k) {\n            if (from > to) {\n                return 0;\n            }\n            if (from == to) {\n                return 1;\n            }\n            if (answer[from][to][k] != -1) {\n                return answer[from][to][k];\n            }\n            if (s.charAt(from) == s.charAt(to)) {\n                answer[from][to][k] = go(from + 1, to - 1, k) + 2;\n            } else {\n                answer[from][to][k] = Math.max(go(from, to - 1, k), go(from + 1, to, k));\n                if (k != 0) {\n                    answer[from][to][k] = Math.max(answer[from][to][k], go(from + 1, to - 1, k - 1) + 2);\n                }\n            }\n            return answer[from][to][k];\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static void fill(int[][] array, int value) {\n            for (int[] row : array) {\n                Arrays.fill(row, value);\n            }\n        }\n\n        public static void fill(int[][][] array, int value) {\n            for (int[][] subArray : array) {\n                fill(subArray, value);\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                if (Character.isValidCodePoint(c)) {\n                    res.appendCodePoint(c);\n                }\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            DReversedLCS solver = new DReversedLCS();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class DReversedLCS {\n        char[] s;\n        int[][][] dp;\n\n        public int dp(int l, int r, int k) {\n            if (l > r) {\n                return 0;\n            }\n            if (l == r) {\n                return 1;\n            }\n            if (dp[l][r][k] == -1) {\n                dp[l][r][k] = 0;\n                //change nothing\n                dp[l][r][k] = Math.max(dp(l + 1, r, k), dp(l, r - 1, k));\n                if (s[l] == s[r]) {\n                    dp[l][r][k] = dp(l + 1, r - 1, k) + 2;\n                }\n                if (k > 0) {\n                    dp[l][r][k] = Math.max(dp[l][r][k], dp(l + 1, r - 1, k - 1) + 2);\n                }\n            }\n            return dp[l][r][k];\n        }\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            s = in.readString().toCharArray();\n            int k = in.readInt();\n            dp = new int[s.length][s.length][k + 1];\n            SequenceUtils.deepFill(dp, -1);\n            int ans = dp(0, s.length - 1, k);\n            out.println(ans);\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static void deepFill(Object array, int val) {\n            if (!array.getClass().isArray()) {\n                throw new IllegalArgumentException();\n            }\n            if (array instanceof int[]) {\n                int[] intArray = (int[]) array;\n                Arrays.fill(intArray, val);\n            } else {\n                Object[] objArray = (Object[]) array;\n                for (Object obj : objArray) {\n                    deepFill(obj, val);\n                }\n            }\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 13);\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tchar[] s = sc.nextLine().toCharArray();\n\t\tint k = sc.nextInt();\n\t\t\n\t\t\n\t\tint[][] map = new int[s.length+1][s.length+1];\n\t\tfor(int i = 0; i < s.length; i++){\n\t\t\tfor(int j = 0 ; j < s.length; j++){\n\t\t\t\tint  jj = s.length - j - 1;\n\t\t\t\t\n\t\t\t\tmap[i+1][j+1] = Math.max(map[i+1][j],map[i][j+1]);\n\t\t\t\tif(s[i] == s[jj]){\n\t\t\t\t\tmap[i+1][j+1] = Math.max(map[i+1][j+1] , map[i][j]+1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(Math.min(s.length, (map[s.length][s.length] + k*2)));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.function.IntBinaryOperator;\nimport java.util.function.IntFunction;\nimport java.util.function.IntUnaryOperator;\nimport java.util.function.LongUnaryOperator;\n\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Field f = System.out.getClass().getDeclaredField(\"autoFlush\");\n        f.setAccessible(true);\n        f.set(System.out, false);\n        execute(System.in, System.out);\n    }\n\n    public static void execute(InputStream in, OutputStream out) {\n        ExtendedScanner s = new ExtendedScanner(in);\n        Out o = new Out(out);\n        solve(s, o);\n        o.flush();\n        o.close();\n    }\n\n    public static void solve(ExtendedScanner sc, Out out) {\n        char[] s = sc.nextChars();\n        char[] t = s.clone();\n        CharArrays.reverse(t);\n        int m = sc.nextInt();\n        int n = s.length;\n        int[][][] dp = new int[n + 1][n + 1][m + 1];\n        int max = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n - i; j++) {\n                for (int k = 0; k <= m; k++) {\n                    if (s[i] == t[j]) {\n                        dp[i + 1][j + 1][k] = dp[i][j][k] + 1;\n                        if (j + 1 == n - i) {\n                            max = Math.max(max, dp[i + 1][j + 1][k] * 2 - 1);\n                        }\n                    } else {\n                        dp[i + 1][j + 1][k] = Ints.max(dp[i + 1][j][k], dp[i][j + 1][k], k > 0 ? dp[i][j][k - 1] + 1 : 0);\n                    }\n                }\n            }\n        }\n        out.writeln(max);\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass BasicScanner {\n    private final InputStream in;\n    private final byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public BasicScanner(InputStream in) {this.in = in;}\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try {buflen = in.read(buf);}\n        catch (final IOException e) {e.printStackTrace();}\n        return buflen > 0;\n    }\n    private int readByte() {return hasNextByte() ? buf[ptr++] : -1;}\n    public boolean hasNext() {\n        while (hasNextByte() && !(33 <= buf[ptr] && buf[ptr] <= 126)) ptr++;\n        return hasNextByte();\n    }\n    private StringBuilder nextSequence() {\n        if (!hasNext()) throw new NoSuchElementException();\n        final StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}\n        return sb;\n    }\n    public char nextChar() {\n        return (char) readByte();\n    }\n    public String next() {\n        return nextSequence().toString();\n    }\n    public String next(int len) {\n        return new String(nextChars(len));\n    }\n    public char[] nextChars() {\n        final StringBuilder sb = nextSequence();\n        int l = sb.length();\n        char[] dst = new char[l];\n        sb.getChars(0, l, dst, 0);\n        return dst;\n    }\n    public char[] nextChars(int len) {\n        if (!hasNext()) throw new NoSuchElementException();\n        char[] s = new char[len];\n        int i = 0;\n        int b = readByte();\n        while (33 <= b && b <= 126 && i < len) {s[i++] = (char) b; b = readByte();}\n        if (i != len) throw new NoSuchElementException(String.format(\"length %d is longer than the sequence.\", len));\n        return s;\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {minus = true; b = readByte();}\n        if (b < '0' || '9' < b) throw new NumberFormatException();\n        while (true) {\n            if ('0' <= b && b <= '9') n = n * 10 + b - '0';\n            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;\n            else throw new NumberFormatException();\n            b = readByte();\n        }\n    }\n    public int nextInt() {return Math.toIntExact(nextLong());}\n    public double nextDouble() {return Double.parseDouble(next());}\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass Out {\n    private final OutputStream out;\n    private byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private static final int AUTO_FLUSH_THRETHOLD = 1 << 17;\n\n    public Out(OutputStream out) {\n        this.out = out;\n    }\n\n    public void flush() {\n        try {\n            out.write(buf, 0, ptr);\n            out.flush();\n            ptr = 0;\n        } catch (IOException e) {e.printStackTrace();}\n    }\n\n    public void close() {\n        try {out.close();} catch (IOException e) {e.printStackTrace();}\n    }\n\n    public Out writeln() {return write('\\n');}\n    public Out writeln(Object o) {return write(o).write('\\n');}\n    public Out writeln(String s) {return write(s).write('\\n');}\n    public Out writeln(char[] c) {return write(c).write('\\n');}\n    public Out writeln(char   c) {return write(c).write('\\n');}\n    public Out writeln(byte   b) {return write(b).write('\\n');}\n    public Out writeln(int    x) {return write(x).write('\\n');}\n    public Out writeln(long   x) {return write(x).write('\\n');}\n    public Out writeln(double d) {return write(d).write('\\n');}\n\n    public Out writeSpace() {return write(' ');}\n    \n    public Out write(Object o) {\n        return write(o.toString());\n    }\n\n    public Out write(String s) {\n        try {\n            Field strValueField = s.getClass().getDeclaredField(\"value\");\n            strValueField.setAccessible(true);\n            byte[] b = (byte[]) strValueField.get(s);\n            int l = s.length();\n            if (l > AUTO_FLUSH_THRETHOLD) {\n                flush();\n                int i = 0;\n                while (i + AUTO_FLUSH_THRETHOLD < l) {\n                    out.write(b, i, AUTO_FLUSH_THRETHOLD);\n                    out.flush();\n                    i += AUTO_FLUSH_THRETHOLD;\n                }\n                ensureCapacity(l - i);\n                System.arraycopy(b, i, buf, 0, l - i);\n                ptr = l - i;\n            } else {\n                ensureCapacity(ptr + l);\n                System.arraycopy(b, 0, buf, ptr, l);\n                ptr += l;\n            }\n        } catch (Exception e) {e.printStackTrace();}\n        return this;\n    }\n\n    public Out write(char[] c) {\n        int l = c.length;\n        if (l > AUTO_FLUSH_THRETHOLD) {\n            flush();\n            ensureCapacity(AUTO_FLUSH_THRETHOLD);\n            int i = 0;\n            while (i + AUTO_FLUSH_THRETHOLD < l) {\n                for (int j = 0; j < AUTO_FLUSH_THRETHOLD; j++) {\n                    buf[ptr++] = (byte) c[i + j];\n                }\n                flush();\n                i += AUTO_FLUSH_THRETHOLD;\n            }\n            for (; i < l; i++) {\n                buf[ptr++] = (byte) c[i];\n            }\n        } else {\n            ensureCapacity(ptr + l);\n            for (char ch : c) buf[ptr++] = (byte) ch;\n        }\n        return this;\n    }\n\n    public Out write(char c) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = (byte) c;\n        return this;\n    }\n\n    public Out write(byte b) {\n        ensureCapacity(ptr + 1);\n        buf[ptr++] = b;\n        return this;\n    }\n\n    public Out write(int x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(long x) {\n        if (x == 0) {\n            ensureCapacity(ptr + 1);\n            buf[ptr++] = '0';\n            return this;\n        }\n        int d = stringSize(x);\n        ensureCapacity(ptr + d);\n        if (x < 0) {\n            buf[ptr++] = '-';\n            x = -x;\n            d--;\n        }\n        int j = ptr + d; \n        while (x > 0) {\n            buf[--j] = (byte) ('0' + (x % 10));\n            x /= 10;\n        }\n        ptr += d;\n        return this;\n    }\n\n    public Out write(double d) {\n        return write(Double.toString(d));\n    }\n\n    private void ensureCapacity(int cap) {\n        if (cap > AUTO_FLUSH_THRETHOLD) {\n            flush();\n        }\n        if (cap >= buf.length) {\n            int newLength = buf.length;\n            while (newLength < cap) newLength <<= 1;\n            byte[] newBuf = new byte[newLength];\n            System.arraycopy(buf, 0, newBuf, 0, buf.length);\n            buf = newBuf;\n        }\n    }\n    private static int stringSize(long x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        long p = -10;\n        for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;\n        return 19 + d;\n    }\n    private static int stringSize(int x) {\n        int d = 1;\n        if (x >= 0) {d = 0; x = -x;}\n        int p = -10;\n        for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;\n        return 10 + d;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class Ints {\n    private Ints(){}\n    public static int max(int a, int b) {\n        return Math.max(a, b);\n    }\n    public static int max(int a, int b, int c) {\n        return Math.max(Math.max(a, b), c);\n    }\n    public static int max(int a, int b, int c, int d) {\n        return Math.max(Math.max(Math.max(a, b), c), d);\n    }\n    public static int max(int a, int b, int c, int d, int e) {\n        return Math.max(Math.max(Math.max(Math.max(a, b), c), d), e);\n    }\n    public static int max(int a, int b, int c, int d, int e, int f) {\n        return Math.max(Math.max(Math.max(Math.max(Math.max(a, b), c), d), e), f);\n    }\n    public static int max(int a, int b, int c, int d, int e, int f, int g) {\n        return Math.max(Math.max(Math.max(Math.max(Math.max(Math.max(a, b), c), d), e), f), g);\n    }\n    public static int max(int a, int b, int c, int d, int e, int f, int g, int h) {\n        return Math.max(Math.max(Math.max(Math.max(Math.max(Math.max(Math.max(a, b), c), d), e), f), g), h);\n    }\n    public static int max(int a, int... vals) {\n        int ret = a; for (int e : vals) ret = Math.max(ret, e);\n        return ret;\n    }\n    public static int min(int a, int b) {\n        return Math.min(a, b);\n    }\n    public static int min(int a, int b, int c) {\n        return Math.min(Math.min(a, b), c);\n    }\n    public static int min(int a, int b, int c, int d) {\n        return Math.min(Math.min(Math.min(a, b), c), d);\n    }\n    public static int min(int a, int b, int c, int d, int e) {\n        return Math.min(Math.min(Math.min(Math.min(a, b), c), d), e);\n    }\n    public static int min(int a, int b, int c, int d, int e, int f) {\n        return Math.min(Math.min(Math.min(Math.min(Math.min(a, b), c), d), e), f);\n    }\n    public static int min(int a, int b, int c, int d, int e, int f, int g) {\n        return Math.min(Math.min(Math.min(Math.min(Math.min(Math.min(a, b), c), d), e), f), g);\n    }\n    public static int min(int a, int b, int c, int d, int e, int f, int g, int h) {\n        return Math.min(Math.min(Math.min(Math.min(Math.min(Math.min(Math.min(a, b), c), d), e), f), g), h);\n    }\n    public static int min(int a, int... vals) {\n        int ret = a; for (int e : vals) ret = Math.min(ret, e);\n        return ret;\n    }\n    public static int fold(final IntBinaryOperator func, final int... a) {\n        int ret = a[0]; for (int i = 1; i < a.length; i++) ret = func.applyAsInt(ret, a[i]);\n        return ret;\n    }\n    public static boolean isPowerOfTwo(final int n) {return n != 0 && (-n & n) == n;}\n    public static int ceilExponent(final int n) {return 31 - Integer.numberOfLeadingZeros(n) + (isPowerOfTwo(n) ? 0 : 1);}\n    public static int floorExponent(final int n) {return 31 - Integer.numberOfLeadingZeros(n) + (n == 0 ? 1 : 0);}\n    /**\n     * Caluculate the ceil of a/b. Returns the smallest integer greater than or\n     * equal to a/b while 'a/b' rounds fractional parts to ZERO.\n     * @param a\n     * @param b\n     * @return the smallest integer greater than or equal to a/b\n     */\n    public static int cld(final int a, final int b) {\n        if (a > 0 && b > 0) return (a + b - 1) / b;\n        if (a < 0 && b < 0) return (a + b + 1) / b;\n        return a / b;\n    }\n    /**\n     * Caluculate the floor of a/b. Returns the largest integer less than or equal\n     * to a/b while 'a/b' rounds fractional parts to ZERO.\n     * @param a\n     * @param b\n     * @return the largest integer less than or equal to a/b\n     */\n    public static int fld(final int a, final int b) {\n        if (a <= 0 && b > 0) return (a - b + 1) / b;\n        if (a > 0 && b <= 0) return (a - b - 1) / b;\n        return a / b;\n    }\n    public static String join(final String sep, final int... a) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < a.length; i++) {\n            sb.append(a[i]);\n            if (i < a.length - 1)  sb.append(sep);\n        }\n        return sb.toString();\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class ExtendedScanner extends BasicScanner {\n    public ExtendedScanner(InputStream in) {super(in);}\n    public int[] ints(final int n) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> nextInt());\n        return a;\n    }\n    public int[] ints(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, $ -> f.applyAsInt(nextInt()));\n        return a;\n    }\n    public int[][] ints(final int n, final int m) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m));\n        return a;\n    }\n    public int[][] ints(final int n, final int m, final IntUnaryOperator f) {\n        final int[][] a = new int[n][];\n        Arrays.setAll(a, $ -> ints(m, f));\n        return a;\n    }\n    public long[] longs(final int n) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> nextLong());\n        return a;\n    }\n    public long[] longs(final int n, final LongUnaryOperator f) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, $ -> f.applyAsLong(nextLong()));\n        return a;\n    }\n    public long[][] longs(final int n, final int m) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m));\n        return a;\n    }\n    public long[][] longs(final int n, final int m, final LongUnaryOperator f) {\n        final long[][] a = new long[n][];\n        Arrays.setAll(a, $ -> longs(m, f));\n        return a;\n    }\n    public char[][] charArrays(final int n) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars());\n        return c;\n    }\n    public char[][] charArrays(final int n, final int m) {\n        final char[][] c = new char[n][];\n        Arrays.setAll(c, $ -> nextChars(m));\n        return c;\n    }\n    public double[] doubles(final int n) {\n        final double[] a = new double[n];\n        Arrays.setAll(a, $ -> nextDouble());\n        return a;\n    }\n    public double[][] doubles(final int n, final int m) {\n        final double[][] a = new double[n][];\n        Arrays.setAll(a, $ -> doubles(m));\n        return a;\n    }\n    public String[] strings(final int n) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next());\n        return s;\n    }\n    public String[] strings(final int n, final int m) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, $ -> next(m));\n        return s;\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n * \n * 1. DESTRUCTIVE methods for char arrays.\n * 2. methods that receives arrays and return some results (except for char arrays).\n */\nfinal class CharArrays {\n    private CharArrays(){}\n    public static void swap(final char[] a, final int u, final int v) {\n        final char tmp = a[u]; a[u] = a[v]; a[v] = tmp;\n    }\n    public static void reverse(final char[] a, int begin, int end) {\n        while (end - begin > 1) swap(a, begin++, --end);\n    }\n    public static void reverse(final char[] a) {reverse(a, 0, a.length);}\n    public static void sortDescending(final char[] a) {Arrays.sort(a); reverse(a);}\n    public static void transpose(char[][] a) {\n        final int n = a.length, m = a[0].length;\n        final char[][] ret = new char[m][n];\n        for (int j = 0; j < m; j++) for (int i = 0; i < n; i++) ret[j][i] = a[i][j];\n        a = ret;\n    }\n    public static String join(final char[] a, final String sep) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < a.length; i++) {\n            sb.append(a[i]);\n            if (i < a.length - 1) sb.append(sep);\n        }\n        return sb.toString();\n    }\n    public static String join(final char[][] a, final String sep) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < a.length; i++) {\n            sb.append(a[i]);\n            if (i < a.length - 1) sb.append(sep);\n        }\n        return sb.toString();\n    }\n    public static String joinWithPrefixAndSuffix(final char[] a, final IntFunction<String> idxToPre, final IntFunction<String> idxToSuf, final String sep) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < a.length; i++) {\n            sb.append(idxToPre.apply(i)).append(a[i]).append(idxToSuf.apply(i));\n            if (i < a.length - 1) sb.append(sep);\n        }\n        return sb.toString();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport fastio.InputReader;\nimport fastio.OutputWriter;\n\npublic class agc021_d {\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n\n        String s = in.next();\n\n        int n = s.length();\n\n        int k = in.nextInt();\n\n        int[][][] dp = new int[n][n][k + 1];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int l = 0; l <= k; l++) {\n                    dp[i][j][l] = -1;\n                }\n            }\n        }\n\n        out.println(rec(dp, 0, n - 1, k, s));\n    }\n\n    int rec(int[][][] dp, int i, int j, int k, String s) {\n        if (i > j)\n            return 0;\n\n        if (dp[i][j][k] != -1)\n            return dp[i][j][k];\n\n        if (i == j) {\n            return dp[i][j][k] = 1;\n        }\n\n        int ans = 0;\n        if (s.charAt(i) == s.charAt(j)) {\n            ans = 2 + rec(dp, i + 1, j - 1, k, s);\n        } else {\n            ans = Math.max(rec(dp, i, j - 1, k, s), rec(dp, i + 1, j, k, s));\n            if (k > 0) {\n                ans = Math.max(ans, 2 + rec(dp, i + 1, j - 1, k - 1, s));\n            }\n\n        }\n\n        return dp[i][j][k] = ans;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String args[]) throws IOException{\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t//BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t//StringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\n\t\t//StringBuilder sb = new StringBuilder();\n\t\t\n\t\tchar s[] = sc.next().toCharArray();\n\t\t\n\t\tint k = sc.nextInt();\n\t\t\n\t\tint dp[][][] = new int[s.length][s.length][k+1];\n\t\t\n\t\tfor(int i=0;i<=k;i++){\n\t\t\tfor(int r=0;r<s.length;r++){\n\t\t\t\tfor(int l=r;l>=0;l--){\n\t\t\t\t\tif(l==r){\n\t\t\t\t\t\tdp[l][r][i] = 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(r==l+1){\n\t\t\t\t\t\tdp[l][r][i] = s[l] == s[r] || i>0 ? 2 : 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(s[l] == s[r]){\n\t\t\t\t\t\tdp[l][r][i] = dp[l+1][r-1][i]+2;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[l][r][i] = Math.max(dp[l+1][r][i], dp[l][r-1][i]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(i>0){\n\t\t\t\t\t\tdp[l][r][i] = Math.max(dp[l][r][i], dp[l+1][r-1][i-1]+2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(dp[0][s.length-1][k]);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic class Solver {\n\t\tstatic int solve(String s, int k) {\n\t\t\tint[][][] dp = new int[s.length()][s.length()][k + 1];\n\n\t\t\tfor (int i = s.length() - 1; i >= 0; i--) {\n\t\t\t\tfor (int j = i; j < s.length(); j++) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tdp[i][j][0] = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (int t = 0; t <= k; t++) {\n\t\t\t\t\t\t\tdp[i][j][t] = Math.max(dp[i + 1][j][t], dp[i][j - 1][t]);\n\t\t\t\t\t\t\tint cost = s.charAt(i) == s.charAt(j) ? 0 : 1;\n\t\t\t\t\t\t\tif (t - cost >= 0) {\n\t\t\t\t\t\t\t\tdp[i][j][t] = Math.max(dp[i][j][t], dp[i + 1][j - 1][t - cost] + 2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dp[0][s.length() - 1][k];\n\t\t}\n\t}\n\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\n\tvoid solve() {\n\n\t\tint t = 1;// ni();\n\t\twhile (t-- > 0) {\n\t\t\ttry {\n\t\t\t\tint ans = Solver.solve(ns(), ni());\n\t\t\t\tout.println(ans);\n\t\t\t} catch (Exception e) {\n\t\t\t\tout.println(e.getMessage());\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tvoid run() throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\tif (!INPUT.isEmpty())\n\t\t\ttr(System.currentTimeMillis() - s + \"ms\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != '\n\t\t\t\t\t\t\t\t\t// ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n) {\n\t\t\tif (!(isSpaceChar(b)))\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = ni();\n\t\t}\n\t\treturn a;\n\t}\n\n\tprivate int[][] na(int n, int m) {\n\t\tint[][] a = new int[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = na(m);\n\t\treturn a;\n\t}\n\n\tprivate int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic class Solver {\n\t\tstatic int solve(String s, int k) {\n\t\t\tint[][][] dp = new int[s.length()][s.length()][k + 1];\n\n\t\t\tfor (int i = s.length() - 1; i >= 0; i--) {\n\t\t\t\tfor (int j = i; j < s.length(); j++) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tdp[i][j][0] = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (int t = 0; t <= k; t++) {\n\t\t\t\t\t\t\tdp[i][j][t] = Math.max(dp[i + 1][j][t], dp[i][j - 1][t]);\n\t\t\t\t\t\t\tint cost = s.charAt(i) == s.charAt(j) ? 0 : 1;\n\t\t\t\t\t\t\tif (t - cost >= 0) {\n\t\t\t\t\t\t\t\tdp[i][j][t] = Math.max(dp[i][j][t], dp[i + 1][j - 1][t - cost] + 2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor(int i = 0;i <= k;i++)\n\t\t\t\tans = Math.max(ans,  dp[0][s.length() - 1][i]);\n\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\n\tvoid solve() {\n\n\t\tint t = 1;// ni();\n\t\twhile (t-- > 0) {\n\t\t\ttry {\n\t\t\t\tint ans = Solver.solve(ns(), ni());\n\t\t\t\tout.println(ans);\n\t\t\t} catch (Exception e) {\n\t\t\t\tout.println(e.getMessage());\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tvoid run() throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\tif (!INPUT.isEmpty())\n\t\t\ttr(System.currentTimeMillis() - s + \"ms\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != '\n\t\t\t\t\t\t\t\t\t// ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n) {\n\t\t\tif (!(isSpaceChar(b)))\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = ni();\n\t\t}\n\t\treturn a;\n\t}\n\n\tprivate int[][] na(int n, int m) {\n\t\tint[][] a = new int[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = na(m);\n\t\treturn a;\n\t}\n\n\tprivate int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            String T = in.next();\n            int N = T.length();\n            int K = in.nextInt();\n\n            int[][][] dp = new int[N][N][K + 1];\n\n            for (int right = 0; right < N; right++) {\n                for (int left = right; left >= 0; left--) {\n                    if (left == right) {\n                        dp[left][right][0] = 1;\n                    } else {\n                        for (int k = 0; k <= K; k++) {\n                            dp[left][right][k] = Math.max(dp[left + 1][right][k], dp[left][right - 1][k]);\n                            if (T.charAt(left) == T.charAt(right)) {\n                                dp[left][right][k] = Math.max(dp[left][right][k], 2 + dp[left + 1][right - 1][k]);\n                            } else if (k > 0) {\n                                dp[left][right][k] = Math.max(dp[left][right][k], 2 + dp[left + 1][right - 1][k - 1]);\n                            }\n                        }\n                    }\n                }\n            }\n            int best = 0;\n            for (int k = 0; k <= K; k++) {\n                best = Math.max(best, dp[0][N - 1][k]);\n            }\n            out.println(best);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n *\n * @author ilyakor\n */\npublic class Main {\n\n  public static void main(String[] args) {\n    InputStream inputStream = System.in;\n    OutputStream outputStream = System.out;\n    InputReader in = new InputReader(inputStream);\n    OutputWriter out = new OutputWriter(outputStream);\n    TaskD solver = new TaskD();\n    solver.solve(1, in, out);\n    out.close();\n  }\n\n  static class TaskD {\n\n    char[] s;\n    int n;\n    int k;\n    int[][][] d;\n\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n      s = in.nextToken().toCharArray();\n      n = s.length;\n      k = in.nextInt();\n      int res = 0;\n      d = new int[k + 1][n + 1][n + 1];\n      for (int t = 0; t <= k; ++t) {\n        for (int i = 1; i <= n; ++i) {\n          for (int j = n - 1; j >= i - 1; --j) {\n            int cur = Math.max(d[t][i][j + 1], d[t][i - 1][j]);\n            int inc = (j == i - 1 ? 1 : 2);\n            if (s[i - 1] == s[j]) {\n              if (cur < d[t][i - 1][j + 1] + inc) {\n                cur = d[t][i - 1][j + 1] + inc;\n              }\n            }\n            if (t > 0) {\n              if (cur < d[t - 1][i - 1][j + 1] + inc) {\n                cur = d[t - 1][i - 1][j + 1] + inc;\n              }\n            }\n            d[t][i][j] = cur;\n            if (cur > res) {\n              res = cur;\n            }\n          }\n        }\n      }\n      out.printLine(res);\n    }\n\n  }\n\n  static class InputReader {\n\n    private InputStream stream;\n    private byte[] buffer = new byte[10000];\n    private int cur;\n    private int count;\n\n    public InputReader(InputStream stream) {\n      this.stream = stream;\n    }\n\n    public static boolean isSpace(int c) {\n      return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public int read() {\n      if (count == -1) {\n        throw new InputMismatchException();\n      }\n      try {\n        if (cur >= count) {\n          cur = 0;\n          count = stream.read(buffer);\n          if (count <= 0) {\n            return -1;\n          }\n        }\n      } catch (IOException e) {\n        throw new InputMismatchException();\n      }\n      return buffer[cur++];\n    }\n\n    public int readSkipSpace() {\n      int c;\n      do {\n        c = read();\n      } while (isSpace(c));\n      return c;\n    }\n\n    public String nextToken() {\n      int c = readSkipSpace();\n      StringBuilder sb = new StringBuilder();\n      while (!isSpace(c)) {\n        sb.append((char) c);\n        c = read();\n      }\n      return sb.toString();\n    }\n\n    public int nextInt() {\n      int sgn = 1;\n      int c = readSkipSpace();\n      if (c == '-') {\n        sgn = -1;\n        c = read();\n      }\n      int res = 0;\n      do {\n        if (c < '0' || c > '9') {\n          throw new InputMismatchException();\n        }\n        res = res * 10 + c - '0';\n        c = read();\n      } while (!isSpace(c));\n      res *= sgn;\n      return res;\n    }\n\n  }\n\n  static class OutputWriter {\n\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n      this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n      for (int i = 0; i < objects.length; i++) {\n        if (i != 0) {\n          writer.print(' ');\n        }\n        writer.print(objects[i]);\n      }\n    }\n\n    public void printLine(Object... objects) {\n      print(objects);\n      writer.println();\n    }\n\n    public void close() {\n      writer.close();\n    }\n\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        int k;\n        char[] s;\n        int[][][] dp;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            s = in.next().toCharArray();\n            int n = s.length;\n            k = in.nextInt();\n            dp = new int[n][n][k + 1];\n            AUtils.deepFill(dp, -1);\n            out.println(solve(0, n - 1, k));\n        }\n\n        int solve(int front, int back, int rem) {\n            if (front > back) return 0;\n            if (front == back) return 1;\n            if (dp[front][back][rem] != -1) return dp[front][back][rem];\n            int ans = AUtils.max(\n                    solve(front + 1, back, rem),\n                    solve(front, back - 1, rem)\n            );\n            if (s[front] == s[back]) {\n                ans = AUtils.max(ans, 2 + solve(front + 1, back - 1, rem));\n            } else if (rem > 0) {\n                ans = AUtils.max(ans, 2 + solve(front + 1, back - 1, rem - 1));\n            }\n            return dp[front][back][rem] = ans;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class AUtils {\n        public static <E extends Comparable<E>> E max(E... arr) {\n            E res = arr[0];\n            for (E x : arr) if (x.compareTo(res) > 0) res = x;\n            return res;\n        }\n\n        public static void deepFill(int[][][] x, int val) {\n            for (int[][] y : x) deepFill(y, val);\n        }\n\n        public static void deepFill(int[][] x, int val) {\n            for (int[] y : x) deepFill(y, val);\n        }\n\n        public static void deepFill(int[] x, int val) {\n            Arrays.fill(x, val);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1 << 16];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (this.numChars == -1) {\n                throw new InputMismatchException();\n            } else {\n                if (this.curChar >= this.numChars) {\n                    this.curChar = 0;\n\n                    try {\n                        this.numChars = this.stream.read(this.buf);\n                    } catch (IOException var2) {\n                        throw new InputMismatchException();\n                    }\n\n                    if (this.numChars <= 0) {\n                        return -1;\n                    }\n                }\n\n                return this.buf[this.curChar++];\n            }\n        }\n\n        public int nextInt() {\n            int c;\n            for (c = this.read(); isSpaceChar(c); c = this.read()) {\n                ;\n            }\n\n            byte sgn = 1;\n            if (c == 45) {\n                sgn = -1;\n                c = this.read();\n            }\n\n            int res = 0;\n\n            while (c >= 48 && c <= 57) {\n                res *= 10;\n                res += c - 48;\n                c = this.read();\n                if (isSpaceChar(c)) {\n                    return res * sgn;\n                }\n            }\n\n            throw new InputMismatchException();\n        }\n\n        public String next() {\n            int c;\n            while (isSpaceChar(c = this.read())) {\n                ;\n            }\n\n            StringBuilder result = new StringBuilder();\n            result.appendCodePoint(c);\n\n            while (!isSpaceChar(c = this.read())) {\n                result.appendCodePoint(c);\n            }\n\n            return result.toString();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c == 32 || c == 10 || c == 13 || c == 9 || c == -1;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Array;\nimport java.util.*;\n\npublic class Main implements Runnable {\n    static ContestScanner in;\n    static Writer out;\n    public static void main(String[] args) {\n        new Thread(null, new Main(), \"\", 16 * 1024 * 1024).start();\n    }\n\n    public void run() {\n        Main main = new Main();\n        try {\n            in = new ContestScanner();\n            out = new Writer();\n            main.solve();\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    void solve() throws IOException {\n        s = in.nextToken().toCharArray();\n        int k = in.nextInt();\n        len = s.length;\n        dp = new int[len][len][k + 1];\n        for (int i = 0; i < len; i++) {\n            for (int j = 0; j < len; j++) {\n                for (int l = 0; l <= k; l++) {\n                    dp[i][j][l] = -1;\n                }\n            }\n        }\n        System.out.println(dfs(0, len - 1, k));\n    }\n\n    int len;\n    char[] s;\n    int[][][] dp;\n    int dfs(int l, int r, int k) {\n        if(r < l) return 0;\n        else if(r == l) return 1;\n        if(dp[l][r][k] >= 0) return dp[l][r][k];\n        int ans = 0;\n        if(s[l] == s[r]) ans = dfs(l + 1, r - 1, k) + 2;\n        else if(k > 0) ans = Math.max(ans, dfs(l + 1, r - 1, k - 1) + 2);\n        ans = Math.max(ans, dfs(l + 1, r, k));\n        ans = Math.max(ans, dfs(l, r - 1, k));\n        return dp[l][r][k] = ans;\n    }\n}\n\n@SuppressWarnings(\"serial\")\nclass MultiSet<T> extends HashMap<T, Integer>{\n    @Override public Integer get(Object key){return containsKey(key)?super.get(key):0;}\n    public void add(T key,int v){put(key,get(key)+v);}\n    public void add(T key){put(key,get(key)+1);}\n    public void sub(T key){final int v=get(key);if(v==1)remove(key);else put(key,v-1);}\n    public MultiSet<T> merge(MultiSet<T> set)\n    {MultiSet<T>s,l;if(this.size()<set.size()){s=this;l=set;}else{s=set;l=this;}\n        for(Entry<T,Integer>e:s.entrySet())l.add(e.getKey(),e.getValue());return l;}\n}\n\nclass Writer extends PrintWriter{\n    public Writer(String filename)throws IOException\n    {super(new BufferedWriter(new FileWriter(filename)));}\n    public Writer()throws IOException{super(System.out);}\n}\nclass ContestScanner implements Closeable{\n    private BufferedReader in;private int c=-2;\n    public ContestScanner()throws IOException\n    {in=new BufferedReader(new InputStreamReader(System.in));}\n    public ContestScanner(String filename)throws IOException\n    {in=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n    public String nextToken()throws IOException {\n        StringBuilder sb=new StringBuilder();\n        while((c=in.read())!=-1&&Character.isWhitespace(c));\n        while(c!=-1&&!Character.isWhitespace(c)){sb.append((char)c);c=in.read();}\n        return sb.toString();\n    }\n    public String readLine()throws IOException{\n        StringBuilder sb=new StringBuilder();if(c==-2)c=in.read();\n        while(c!=-1&&c!='\\n'&&c!='\\r'){sb.append((char)c);c=in.read();}\n        return sb.toString();\n    }\n    public long nextLong()throws IOException,NumberFormatException\n    {return Long.parseLong(nextToken());}\n    public int nextInt()throws NumberFormatException,IOException\n    {return(int)nextLong();}\n    public double nextDouble()throws NumberFormatException,IOException\n    {return Double.parseDouble(nextToken());}\n    public void close() throws IOException {in.close();}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\n\npublic class Main {\n\n  private static void solve() {\n    char[] s = ns();\n    int k = ni();\n    System.out.println(solve(s, k));\n\n  }\n\n  public static int solve(char[] a, int K) {\n    int n = a.length;\n    int[][][] dp = new int[n + 1][n + 1][K + 1];\n    for (int pos = n - 1; pos >= 0; pos --) {\n      Arrays.fill(dp[pos][1], 1);\n      for (int len = 2; pos + len <= n; len ++) {\n        if (a[pos] == a[pos + len - 1]) {\n          for (int k = 0; k <= K; k ++) {\n            dp[pos][len][k] = 2 + dp[pos + 1][len - 2][k];\n          }\n        } else {\n          for (int k = 0; k <= K; k ++) {\n            dp[pos][len][k] = Math.max(dp[pos + 1][len - 1][k], dp[pos][len - 1][k]);\n            if (k > 0) {\n              dp[pos][len][k] = Math.max(dp[pos][len][k], dp[pos + 1][len - 2][k - 1] + 2);\n            }\n          }\n        }\n      }\n    }\n    int ret = 0;\n    for (int k = 0; k <= K; k ++) {\n      ret = Math.max(ret, dp[0][n][k]);\n    }\n    return ret;\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = System.getProperty(\"debug\");\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyScan in = new MyScan(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, MyScan in, PrintWriter out) {\n            String s = in.next();\n            int k = in.nextInt();\n            int[][][] pos = new int[k + 1][s.length() + 1][s.length()];\n\n            for (int i = 0; i < s.length(); i++) {\n                pos[0][1][i] = 1;\n            }\n            for (int r = 2; r <= s.length(); r++) {\n                for (int l = 0; l <= s.length() - r; l++) {\n                    int e = l + r - 1;\n                    boolean match = s.charAt(l) == s.charAt(e);\n                    if (match) {\n                        for (int i = 0; i <= k; i++) {\n                            pos[i][r][l] = Math.max(2 + pos[i][r - 2][l + 1], pos[i][r][l]);\n                        }\n                    } else {\n                        for (int i = 0; i <= k; i++) {\n                            pos[i][r][l] = Math.max(pos[i][r][l], pos[i][r - 1][l]);\n                            pos[i][r][l] = Math.max(pos[i][r - 1][l + 1], pos[i][r][l]);\n                        }\n                        for (int i = 0; i < k; i++) {\n                            pos[i + 1][r][l] = Math.max(pos[i + 1][r][l], 2 + pos[i][r - 2][l + 1]);\n                        }\n                    }\n                }\n            }\n            int max = 0;\n            for (int l = 0; l <= k; l++) {\n                max = Math.max(max, pos[l][s.length()][0]);\n            }\n            out.println(max);\n\n\n        }\n\n    }\n\n    static class MyScan {\n        BufferedReader br;\n        StringTokenizer st;\n\n        MyScan(BufferedReader br) {\n            this.br = br;\n        }\n\n        public MyScan(InputStream in) {\n            this(new BufferedReader(new InputStreamReader(in)));\n        }\n\n        public void findToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n\n        public String next() {\n            findToken();\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "public class Main{\n\tstatic int dp[][][];\n\tstatic String s;\n\tpublic static int solve(int i,int j,int k) {\n\t\tif(dp[i][j][k]>=0)\n\t\t\treturn dp[i][j][k];\n\t\telse {\n\t\t\tint ans;\n\t\t\tif(i>j)\n\t\t\t\tans=0;\n\t\t\telse if(i==j)\n\t\t\t\tans=1;\n\t\t\telse if(s.charAt(i)==s.charAt(j))\n\t\t\t\tans=solve(i+1,j-1,k)+2;\n\t\t\telse {\n\t\t\t\tans=solve(i+1,j,k);\n\t\t\t\tans=Math.max(ans, solve(i,j-1,k));\n\t\t\t\tif(k>0)\n\t\t\t\tans=Math.max(ans, solve(i+1,j-1,k-1)+2);\n\t\t\t}\n\t\t\tdp[i][j][k]=ans;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tjava.util.Scanner scan=new java.util.Scanner(System.in);\n\t\ts=scan.next();\n\t\tint t=scan.nextInt();\n\t\tdp=new int[s.length()][s.length()][t+1];\n\t\tfor(int i=0;i<s.length();i++) {\n\t\t\tfor(int j=0;j<s.length();j++) {\n\t\t\t\tfor(int k=0;k<=t;k++)\n\t\t\t\t\tdp[i][j][k]=-1;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(solve(0,s.length()-1,t));\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\n//using System.Text;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\n//using System.Numerics;\n//using static System.Math;\n//using pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n\n    int[,,] dp;\n    string S;\n    void solve()\n    {\n        S = ReadLine();\n        int K = cin.nextint;\n        dp = new int[S.Length, S.Length, K + 1];//少なくとも1以上になる\n        WriteLine(calc(0, S.Length - 1, K));\n\n    }\n    int calc(int l, int r, int k)\n    {\n        if (dp[l, r, k] > 0) return dp[l, r, k];\n\n        int res = 0;\n        if (l == r) return 1;\n        else if (l + 1 == r)\n        {\n            if (S[l] == S[r] || k > 0) res = 2;\n            else res = 1;\n        }\n        else\n        {\n            res = Math.Max(res, calc(l + 1, r, k));\n            res = Math.Max(res, calc(l, r - 1, k));\n\n            if (S[l] == S[r]) res = Math.Max(res, calc(l + 1, r - 1, k) + 2);\n            if (k > 0) res = Math.Max(res, calc(l + 1, r - 1, k - 1) + 2);\n        }\n\n        return dp[l, r, k] = res;\n    }\n\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan { get { return ReadLine().Split(); } }\n    public int[] scanint { get { return Array.ConvertAll(scan, int.Parse); } }\n    public long[] scanlong { get { return Array.ConvertAll(scan, long.Parse); } }\n    public double[] scandouble { get { return Array.ConvertAll(scan, double.Parse); } }\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint { get { return int.Parse(next); } }\n    public long nextlong { get { return long.Parse(next); } }\n    public double nextdouble { get { return double.Parse(next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression, System.Linq.Expressions.UnaryExpression>;\n\nclass Program\n{\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    // const int M = 998244353;\n    const long LM = (long)1e18;\n    const double eps = 1e-11;\n    static readonly int[] dd = { 0, 1, 0, -1, 0 };\n    static void Main(string[] args)\n    {\n        var s = sc.Str;\n        int k = sc.Int;\n        int n = s.Length;\n        var dp = new int[n + 1][][];\n        for (int i = 0; i < n + 1; i++)\n        {\n            dp[i] = new int[n + 1][];\n            for (int j = 0; j < n + 1; j++)\n            {\n                dp[i][j] = new int[k + 1];\n            }\n        }\n        for (int i = 0; i <= n; i++)\n        {\n            for (int j = 0; j <= n; j++)\n            {\n                for (int l = 0; l <= k; l++)\n                {\n                    if (i > 0 && j > 0 && s[i - 1] == s[n - j]) {\n                        dp[i][j][l] = Math.Max(dp[i][j][l], dp[i - 1][j - 1][l] + 1);\n                    }\n                    if (i > 0 && j > 0 && l > 0) {\n                        dp[i][j][l] = Math.Max(dp[i][j][l], dp[i - 1][j - 1][l - 1] + 1);\n                    }\n                    if (i > 0) {\n                        dp[i][j][l] = Math.Max(dp[i][j][l], dp[i - 1][j][l]);\n                    }\n                    if (j > 0) {\n                        dp[i][j][l] = Math.Max(dp[i][j][l], dp[i][j - 1][l]);\n                    }\n                    if (l > 0) {\n                        dp[i][j][l] = Math.Max(dp[i][j][l], dp[i][j][l - 1]);\n                    }\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i <= n; i++)\n        {\n            ans = Math.Max(ans, dp[i][n - i][k] * 2);\n            if (i < n)\n                ans = Math.Max(ans, dp[i][n - i - 1][k] * 2 + 1);\n        }\n        Prt(ans);\n        sw.Flush();\n    }\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n}\nclass pair<T, U> : IComparable<pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T v1;\n    public U v2;\n    public pair(T v1, U v2) {\n        this.v1 = v1;\n        this.v2 = v2;\n    }\n    public int CompareTo(pair<T, U> a) => v1.CompareTo(a.v1) != 0 ? v1.CompareTo(a.v1) : v2.CompareTo(a.v2);\n    public override string ToString() => v1 + \" \" + v2;\n}\nstatic class util\n{\n    public static pair<T, T> make_pair<T>(this IList<T> l) where T : IComparable<T> => make_pair(l[0], l[1]);\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) where T : IComparable<T> where U : IComparable<U> => new pair<T, U>(v1, v2);\n    public static T sqr<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    public static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T>\n{\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan\n{\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => Console.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() where T : IComparable<T> where U : IComparable<U>\n    { T a; U b; Multi(out a, out b); return make_pair(a, b); }\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new []{' '}, System.StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n    public void Multi<T, U, V, W, X, Y>(out T a, out U b, out V c, out W d, out X e, out Y f)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); f = cv<Y>(ar[5]); }\n}\nstatic class mymath\n{\n    public static long Mod = 1000000007;\n    public static bool isprime(long a) {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n) {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static List<int> getprimes(int n) {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long[][] E(int n) {\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static double[][] dE(int n) {\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new double[n]; ret[i][i] = 1; }\n        return ret;\n    }\n    public static long[][] pow(long[][] A, long n) {\n        if (n == 0) return E(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double[][] pow(double[][] A, long n) {\n        if (n == 0) return dE(A.Length);\n        var t = pow(A, n / 2);\n        if ((n & 1) == 0) return mul(t, t);\n        return mul(mul(t, t), A);\n    }\n    public static double dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0;\n        for (int i = 0; i < n; i++) ret += x[i] * y[i];\n        return ret;\n    }\n    public static double _dot(double[] x, double[] y) {\n        int n = x.Length;\n        double ret = 0, r = 0;\n        for (int i = 0; i < n; i++) {\n            double s = ret + (x[i] * y[i] + r);\n            r = (x[i] * y[i] + r) - (s - ret);\n            ret = s;\n        }\n        return ret;\n    }\n    public static long dot(long[] x, long[] y) {\n        int n = x.Length;\n        long ret = 0;\n        for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n        return ret;\n    }\n    public static T[][] trans<T>(T[][] A) {\n        int n = A[0].Length, m = A.Length;\n        var ret = new T[n][];\n        for (int i = 0; i < n; i++) { ret[i] = new T[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n        return ret;\n    }\n    public static double[] mul(double a, double[] x) {\n        int n = x.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = a * x[i];\n        return ret;\n    }\n    public static long[] mul(long a, long[] x) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = a * x[i] % Mod;\n        return ret;\n    }\n    public static double[] mul(double[][] A, double[] x) {\n        int n = A.Length;\n        var ret = new double[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static long[] mul(long[][] A, long[] x) {\n        int n = A.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double a, double[][] A) {\n        int n = A.Length;\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(a, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long a, long[][] A) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(a, A[i]);\n        return ret;\n    }\n    public static double[][] mul(double[][] A, double[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new double[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[][] mul(long[][] A, long[][] B) {\n        int n = A.Length;\n        var Bt = trans(B);\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n        return ret;\n    }\n    public static long[] add(long[] x, long[] y) {\n        int n = x.Length;\n        var ret = new long[n];\n        for (int i = 0; i < n; i++) ret[i] = (x[i] + y[i]) % Mod;\n        return ret;\n    }\n    public static long[][] add(long[][] A, long[][] B) {\n        int n = A.Length;\n        var ret = new long[n][];\n        for (int i = 0; i < n; i++) ret[i] = add(A[i], B[i]);\n        return ret;\n    }\n    public static long pow(long a, long b) {\n        if (a >= Mod) return pow(a % Mod, b);\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = pow(a, b / 2);\n        if ((b & 1) == 0) return t * t % Mod;\n        return t * t % Mod * a % Mod;\n    }\n    public static long inv(long a) => pow(a, Mod - 2);\n    public static long gcd(long a, long b) {\n        while (b > 0) { var t = a % b; a = b; b = t; } return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y) {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n    public static long lcm(long a, long b) => a / gcd(a, b) * b;\n\n    static long[] facts;\n    public static long[] setfacts(int n) {\n        facts = new long[n + 1];\n        facts[0] = 1;\n        for (int i = 0; i < n; i++) facts[i + 1] = facts[i] * (i + 1) % Mod;\n        return facts;\n    }\n    public static long comb(int n, int r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        if (facts != null && facts.Length > n) return facts[n] * inv(facts[r]) % Mod * inv(facts[n - r]) % Mod;\n        int[] numer = new int[r], denom = new int[r];\n        for (int k = 0; k < r; k++) { numer[k] = n - r + k + 1; denom[k] = k + 1; }\n        for (int p = 2; p <= r; p++) {\n            int piv = denom[p - 1];\n            if (piv > 1) {\n                int ofst = (n - r) % p;\n                for (int k = p - 1; k < r; k += p) { numer[k - ofst] /= piv; denom[k] /= piv; }\n            }\n        }\n        long ret = 1;\n        for (int k = 0; k < r; k++) if (numer[k] > 1) ret = ret * numer[k] % Mod;\n        return ret;\n    }\n    public static long[][] getcombs(int n) {\n        var ret = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            ret[i] = new long[i + 1];\n            ret[i][0] = ret[i][i] = 1;\n            for (int j = 1; j < i; j++) ret[i][j] = (ret[i - 1][j - 1] + ret[i - 1][j]) % Mod;\n        }\n        return ret;\n    }\n    // nC0, nC2, ..., nCn\n    public static long[] getcomb(int n) {\n        var ret = new long[n + 1];\n        ret[0] = 1;\n        for (int i = 0; i < n; i++) ret[i + 1] = ret[i] * (n - i) % Mod * inv(i + 1) % Mod;\n        return ret;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Runtime.CompilerServices;\nusing System.Text;\nusing System.Diagnostics;\nusing System.Numerics;\nusing static System.Console;\nusing static System.Convert;\nusing static System.Math;\nusing static Template;\nusing Pi = Pair<int, int>;\n\nclass Solver\n{\n    public void Solve(Scanner sc)\n    {\n        var S = sc.Str;\n        var K = sc.Int;\n        var dp = Create(S.Length, () => Create(S.Length+1, () => new int[K + 1]));\n        for (int i = 0; i < S.Length; i++)\n        {\n            dp[i][i][0] = 1;\n        }\n        for(int l=2;l<=S.Length;l++)\n            for(int i = 0; i + l <= S.Length; i++)\n            {\n                var r = i + l - 1;\n                for (int k = 0; k <=K; k++)\n                {\n                    chmax(ref dp[i][r][k], dp[i][r - 1][k]);\n                    chmax(ref dp[i][r][k], dp[i + 1][r][k]);\n                    if (k != 0)\n                        chmax(ref dp[i][r][k], dp[i + 1][r - 1][k-1]+2);\n                    if (S[i] == S[r]) chmax(ref dp[i][r][k], dp[i + 1][r - 1][k] + 2);\n                }\n            }\n        Console.WriteLine(dp[0][S.Length-1].Max());\n    }\n}\n\n#region Template\npublic static class Template\n{\n    static void Main(string[] args)\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Solver().Solve(new Scanner());\n        Console.Out.Flush();\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) > 0) { a = b; return true; } return false; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void swap<T>(ref T a, ref T b) { var t = b; b = a; a = t; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void swap<T>(this IList<T> A, int i, int j) { var t = A[i]; A[i] = A[j]; A[j] = t; }\n    public static T[] Create<T>(int n, Func<T> f) { var rt = new T[n]; for (var i = 0; i < rt.Length; ++i) rt[i] = f(); return rt; }\n    public static T[] Create<T>(int n, Func<int, T> f) { var rt = new T[n]; for (var i = 0; i < rt.Length; ++i) rt[i] = f(i); return rt; }\n    public static IEnumerable<T> Shuffle<T>(this IEnumerable<T> A) => A.OrderBy(v => Guid.NewGuid());\n    public static int CompareTo<T>(this T[] A, T[] B, Comparison<T> cmp = null) { cmp = cmp ?? Comparer<T>.Default.Compare; for (var i = 0; i < Min(A.Length, B.Length); i++) { int c = cmp(A[i], B[i]); if (c > 0) return 1; else if (c < 0) return -1; } if (A.Length == B.Length) return 0; if (A.Length > B.Length) return 1; else return -1; }\n    public static int MaxElement<T>(this IList<T> A, Comparison<T> cmp = null) { cmp = cmp ?? Comparer<T>.Default.Compare; T max = A[0]; int rt = 0; for (int i = 1; i < A.Count; i++) if (cmp(max, A[i]) < 0) { max = A[i]; rt = i; } return rt; }\n    public static T PopBack<T>(this List<T> A) { var v = A[A.Count - 1]; A.RemoveAt(A.Count - 1); return v; }\n    public static void Fail<T>(T s) { Console.WriteLine(s); Console.Out.Close(); Environment.Exit(0); }\n}\npublic class Scanner\n{\n    public string Str => Console.ReadLine().Trim();\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public int[] ArrInt => Str.Split(' ').Select(int.Parse).ToArray();\n    public long[] ArrLong => Str.Split(' ').Select(long.Parse).ToArray();\n    public char[][] Grid(int n) => Create(n, () => Str.ToCharArray());\n    public int[] ArrInt1D(int n) => Create(n, () => Int);\n    public long[] ArrLong1D(int n) => Create(n, () => Long);\n    public int[][] ArrInt2D(int n) => Create(n, () => ArrInt);\n    public long[][] ArrLong2D(int n) => Create(n, () => ArrLong);\n    private Queue<string> q = new Queue<string>();\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public T Next<T>() { if (q.Count == 0) foreach (var item in Str.Split(' ')) q.Enqueue(item); return (T)Convert.ChangeType(q.Dequeue(), typeof(T)); }\n    public void Make<T1>(out T1 v1) => v1 = Next<T1>();\n    public void Make<T1, T2>(out T1 v1, out T2 v2) { v1 = Next<T1>(); v2 = Next<T2>(); }\n    public void Make<T1, T2, T3>(out T1 v1, out T2 v2, out T3 v3) { Make(out v1, out v2); v3 = Next<T3>(); }\n    public void Make<T1, T2, T3, T4>(out T1 v1, out T2 v2, out T3 v3, out T4 v4) { Make(out v1, out v2, out v3); v4 = Next<T4>(); }\n    public void Make<T1, T2, T3, T4, T5>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5) { Make(out v1, out v2, out v3, out v4); v5 = Next<T5>(); }\n    public void Make<T1, T2, T3, T4, T5, T6>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5, out T6 v6) { Make(out v1, out v2, out v3, out v4, out v5); v6 = Next<T6>(); }\n    public void Make<T1, T2, T3, T4, T5, T6, T7>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5, out T6 v6, out T7 v7) { Make(out v1, out v2, out v3, out v4, out v5, out v6); v7 = Next<T7>(); }\n    //public (T1, T2) Make<T1, T2>() { Make(out T1 v1, out T2 v2); return (v1, v2); }\n    //public (T1, T2, T3) Make<T1, T2, T3>() { Make(out T1 v1, out T2 v2, out T3 v3); return (v1, v2, v3); }\n    //public (T1, T2, T3, T4) Make<T1, T2, T3, T4>() { Make(out T1 v1, out T2 v2, out T3 v3, out T4 v4); return (v1, v2, v3, v4); }\n}\npublic class Pair<T1, T2> : IComparable<Pair<T1, T2>>\n{\n    public T1 v1;\n    public T2 v2;\n    public Pair() { }\n    public Pair(T1 v1, T2 v2)\n    { this.v1 = v1; this.v2 = v2; }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public int CompareTo(Pair<T1, T2> p)\n    {\n        var c = Comparer<T1>.Default.Compare(v1, p.v1);\n        if (c == 0)\n            c = Comparer<T2>.Default.Compare(v2, p.v2);\n        return c;\n    }\n    public override string ToString() => $\"{v1.ToString()} {v2.ToString()}\";\n    public void Deconstruct(out T1 a, out T2 b) { a = v1; b = v2; }\n}\n\npublic class Pair<T1, T2, T3> : Pair<T1, T2>, IComparable<Pair<T1, T2, T3>>\n{\n    public T3 v3;\n    public Pair() : base() { }\n    public Pair(T1 v1, T2 v2, T3 v3) : base(v1, v2)\n    { this.v3 = v3; }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public int CompareTo(Pair<T1, T2, T3> p)\n    {\n        var c = base.CompareTo(p);\n        if (c == 0)\n            c = Comparer<T3>.Default.Compare(v3, p.v3);\n        return c;\n    }\n    public override string ToString() => $\"{base.ToString()} {v3.ToString()}\";\n    public void Deconstruct(out T1 a, out T2 b, out T3 c) { Deconstruct(out a, out b); c = v3; }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Globalization;\nusing System.Diagnostics;\n\n\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().calc();\n        return 0;\n    }\n\n\n    Scanner cin;\n    \n\n    void calc()\n    {\n        cin = new Scanner();\n        string S = cin.next();\n        int K = cin.nextInt();\n        int N = S.Length;\n        int ans = 0;\n\n        \n        int[,,] dp = new int[N, N, K + 1];\n        for (int i = 0; i < N; i++)\n        {\n            for (int j = 0; j < N; j++)\n            {\n                for (int k = 0; k < K + 1; k++)\n                {\n                    dp[i, j, k] = -1;\n                }\n            }\n        }\n        for (int i = 0; i < N; i++)\n        {\n            dp[i, i, 0] = 1;\n            ans = 1;\n        }\n\n        for (int i = 0; i < N - 1; i++)\n        {\n            if(S[i] == S[i + 1])\n            {\n                dp[i, i + 1, 0] = 2;\n                ans = 2;\n            }\n            else\n            {\n                dp[i, i + 1, 0] = 0;\n                if(K >= 1)\n                {\n                    dp[i, i + 1, 1] = 2;\n                    ans = 2;\n                }\n            }\n        }\n        \n        for (int l = 0; l < N; l++)\n        {\n            for (int i = 0; i < N - l; i++)\n            {\n                int j = i + l;\n                for (int k = 0; k < K + 1; k++)\n                {\n                    if (dp[i, j, k] == -1) continue;\n                    int c = dp[i, j, k];\n                    ans = Math.Max(ans, c);\n                    if (i > 0) dp[i - 1, j, k] = Math.Max(dp[i - 1, j, k], c);\n                    if (j < N - 1) dp[i, j + 1, k] = Math.Max(dp[i, j + 1, k], c);\n                    if (i > 0 && j < N - 1)\n                    {\n                        if(S[i] == S[j])\n                        {\n                            dp[i - 1, j + 1, k] = Math.Max(dp[i - 1, j + 1, k], c + 2);\n                        }\n                        else\n                        {\n                            dp[i - 1, j + 1, k] = Math.Max(dp[i - 1, j + 1, k], c);\n                            if(k != K)\n                            {\n                                dp[i - 1, j + 1, k + 1] = Math.Max(dp[i - 1, j + 1, k + 1], c + 2);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        Console.WriteLine(ans);\n    }\n\n\n}\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Program\n{\n    private string S;\n    private int K;\n\n    private int[,,] Memo;\n\n    public void Solve()\n    {\n        var sc = new Scanner();\n        S = sc.Next();\n        K = sc.NextInt();\n        Memo = new int[S.Length+1,S.Length+1,K+1];\n        for (int i = 0; i <=S.Length ; i++)\n        {\n            for (int j = 0; j <=S.Length ; j++)\n            {\n                for (int k = 0; k <=K ; k++)\n                {\n                    Memo[i, j, k] = -1;\n                }\n            }\n        }\n        Console.WriteLine(Count(0, S.Length, K));\n    }\n\n    private int Count(int l, int r, int k)\n    {\n        if (r - l == 0) return 0;\n        if (r - l == 1) return 1;\n        if (Memo[l, r, k] != -1)\n        {\n            return Memo[l, r, k];\n        }\n        int result;\n        if (S[l] == S[r - 1])\n        {\n            result = Count(l + 1, r - 1, k) + 2;\n        }\n        else\n        {\n            result = Math.Max(Count(l + 1, r, k), Count(l, r - 1, k));\n            if (k > 0)\n            {\n                result = Math.Max(result, Count(l + 1, r - 1, k - 1) + 2);\n            }\n        }\n\n        Memo[l, r, k] = result;\n        return result;\n    }\n\n    public static void Main(string[] args)\n    {\n        new Program().Solve();\n    }\n}\n\nclass Scanner\n{\n    public Scanner()\n    {\n        _pos = 0;\n        _line = new string[0];\n    }\n\n    const char Separator = ' ';\n    private int _pos;\n    private string[] _line;\n\n    #region スペース区切りで取得\n\n    public string Next()\n    {\n        if (_pos >= _line.Length)\n        {\n            _line = Console.ReadLine().Split(Separator);\n            _pos = 0;\n        }\n\n        return _line[_pos++];\n    }\n\n    public int NextInt()\n    {\n        return int.Parse(Next());\n    }\n\n    public long NextLong()\n    {\n        return long.Parse(Next());\n    }\n\n    public double NextDouble()\n    {\n        return double.Parse(Next());\n    }\n\n    #endregion\n\n    #region 型変換\n\n    private int[] ToIntArray(string[] array)\n    {\n        var result = new int[array.Length];\n        for (int i = 0; i < array.Length; i++)\n        {\n            result[i] = int.Parse(array[i]);\n        }\n\n        return result;\n    }\n\n    private long[] ToLongArray(string[] array)\n    {\n        var result = new long[array.Length];\n        for (int i = 0; i < array.Length; i++)\n        {\n            result[i] = long.Parse(array[i]);\n        }\n\n        return result;\n    }\n\n    private double[] ToDoubleArray(string[] array)\n    {\n        var result = new double[array.Length];\n        for (int i = 0; i < array.Length; i++)\n        {\n            result[i] = double.Parse(array[i]);\n        }\n\n        return result;\n    }\n\n    #endregion\n\n    #region 配列取得\n\n    public string[] Array()\n    {\n        if (_pos >= _line.Length)\n            _line = Console.ReadLine().Split(Separator);\n\n        _pos = _line.Length;\n        return _line;\n    }\n\n    public int[] IntArray()\n    {\n        return ToIntArray(Array());\n    }\n\n    public long[] LongArray()\n    {\n        return ToLongArray(Array());\n    }\n\n    public double[] DoubleArray()\n    {\n        return ToDoubleArray(Array());\n    }\n\n    #endregion\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Globalization;\nusing System.Diagnostics;\n\n\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().calc();\n        return 0;\n    }\n\n\n    Scanner cin;\n    \n\n    void calc()\n    {\n        cin = new Scanner();\n        string S = cin.next();\n        int K = cin.nextInt();\n        int N = S.Length;\n        int ans = 0;\n\n        \n        int[,,] dp = new int[N, N, K + 1];\n        for (int i = 0; i < N; i++)\n        {\n            for (int j = 0; j < N; j++)\n            {\n                for (int k = 0; k < K + 1; k++)\n                {\n                    dp[i, j, k] = -1;\n                }\n            }\n        }\n        for (int i = 0; i < N; i++)\n        {\n            dp[i, i, 0] = 1;\n            ans = 1;\n        }\n\n        for (int i = 0; i < N - 1; i++)\n        {\n            if(S[i] == S[i + 1])\n            {\n                dp[i, i + 1, 0] = 2;\n                ans = 2;\n            }\n            else\n            {\n                dp[i, i + 1, 0] = 1;\n                if(K >= 1)\n                {\n                    dp[i, i + 1, 1] = 2;\n                    ans = 2;\n                }\n            }\n        }\n        \n        for (int l = 0; l < N; l++)\n        {\n            for (int i = 0; i < N - l; i++)\n            {\n                int j = i + l;\n                for (int k = 0; k < K + 1; k++)\n                {\n                    if (dp[i, j, k] == -1) continue;\n                    int c = dp[i, j, k];\n                    ans = Math.Max(ans, c);\n                    if (i > 0) dp[i - 1, j, k] = Math.Max(dp[i - 1, j, k], c);\n                    if (j < N - 1) dp[i, j + 1, k] = Math.Max(dp[i, j + 1, k], c);\n                    if (i > 0 && j < N - 1)\n                    {\n                        if(S[i - 1] == S[j + 1])\n                        {\n                            dp[i - 1, j + 1, k] = Math.Max(dp[i - 1, j + 1, k], c + 2);\n                        }\n                        else\n                        {\n                            //dp[i - 1, j + 1, k] = Math.Max(dp[i - 1, j + 1, k], c);\n                            if(k != K)\n                            {\n                                dp[i - 1, j + 1, k + 1] = Math.Max(dp[i - 1, j + 1, k + 1], c + 2);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        for (int i = 0; i < N; i++)\n        {\n            for (int j = 0; j < N; j++)\n            {\n                for (int k = 0; k < K + 1; k++)\n                {\n                    ans = Math.Max(ans, dp[i, j, k]);\n                }\n            }\n        }\n        Console.WriteLine(ans);\n    }\n\n\n}\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tvar s=sc.S;\n\t\tvar n=s.Length;\n\t\tvar m=sc.I;\n\t\tvar dp=new int[m+1][][];\n\t\tfor(int i = 0;i<=m;i++) {\n\t\t\tdp[i]=new int[n+1][];\n\t\t\tfor(int j = 0;j<n;j++) {\n\t\t\t\tdp[i][j]=new int[n+1];\n\t\t\t\tfor(int k = 0;k+j<n;k++) {\n\t\t\t\t\tif(j==0){dp[i][j][k]=1;}\n\t\t\t\t\telse if(j==1){\n\t\t\t\t\t\tif(s[k]==s[k+j]||i>0){dp[i][j][k]=2;}\n\t\t\t\t\t\telse{dp[i][j][k]=1;}\n\t\t\t\t\t}\n\t\t\t\t\telse if(s[k]==s[k+j]){dp[i][j][k]=dp[i][j-2][k+1]+2;}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[i][j][k]=Max(dp[i][j-1][k],dp[i][j-1][k+1]);\n\t\t\t\t\t\tif(i>0){dp[i][j][k]=Max(dp[i][j][k],dp[i-1][j-2][k+1]+2);}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine(\"{0}\",dp[m][n-1][0]);\n\t}\n}\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\n//using System.Numerics;\nusing static System.Math;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var s = rs;\n            var m = ri;\n            var n = s.Length;\n            var dp = new int[n, n, m + 1];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    for (int k = 0; k <= m; k++)\n                        dp[i, j, k] = -10000;\n            Func<int, int, int, int> dfs = null;\n            dfs = (l, r, k) =>\n            {\n                if (k < 0) return -1000;\n                if (r < l) return 0;\n                else if (l == r) return 1;\n                if (dp[l, r, k] != -10000) return dp[l, r, k];\n                var ret = Max(dfs(l + 1, r, k), dfs(l, r - 1, k));\n                ret = Max(ret, dfs(l + 1, r - 1, s[l] == s[r] ? k : k - 1) + 2);\n                return dp[l, r, k] = ret;\n            };\n            Console.WriteLine(dfs(0, n - 1, m));\n        }\n        const long INF = 5L << 60;\n        static int[] dx = { -1, 0, 1, 0 };\n        static int[] dy = { 0, 1, 0, -1 };\n        const string URDL = \"URDL\";\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        try\n        {\n            solver.Solve();\n            Console.Out.Flush();\n        }\n        catch { }\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tvar s=sc.S;\n\t\tvar n=s.Length;\n\t\tvar m=sc.I;\n\t\tvar dp=new int[m+1][][];\n\t\tfor(int i = 0;i<=m;i++) {\n\t\t\tdp[i]=new int[n][];\n\t\t\tfor(int j = 0;j<n;j++) {\n\t\t\t\tdp[i][j]=new int[n-j];\n\t\t\t\tfor(int k = 0;k+j<n;k++) {\n\t\t\t\t\tif(j==0){dp[i][j][k]=1;}\n\t\t\t\t\telse if(j==1){\n\t\t\t\t\t\tif(s[k]==s[k+j]||i>0){dp[i][j][k]=2;}\n\t\t\t\t\t\telse{dp[i][j][k]=1;}\n\t\t\t\t\t}\n\t\t\t\t\telse if(s[k]==s[k+j]){dp[i][j][k]=dp[i][j-2][k+1]+2;}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[i][j][k]=Max(dp[i][j-1][k],dp[i][j-1][k+1]);\n\t\t\t\t\t\tif(i>0){dp[i][j][k]=Max(dp[i][j][k],dp[i-1][j-2][k+1]+2);}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine(\"{0}\",dp[m][n-1][0]);\n\t}\n}\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\n//using System.Text;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\n//using System.Numerics;\nusing static System.Math;\n//using pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n\n\n    void solve()\n    {\n        var S = ReadLine().ToCharArray();\n        var T = S.Reverse().ToArray();\n\n        //WriteLine(new string(S));\n        //WriteLine(new string(T));\n        //WriteLine(S.Length);\n        int K = cin.nextint;\n        int N = S.Length;\n\n        //int cnt = 0;\n        //for (int i = 0; i < N; i++)\n        //{\n        //    if (cnt == K) break;\n        //    if (S[i] != T[i])\n        //    {\n        //        S[i] = T[i];\n        //        T[N - i - 1] = S[N - i - 1];\n        //        cnt++;\n        //    }\n        //}\n\n        var dp = new int[N + 1, N + 1];\n        for (int i = 0; i < N; i++)\n        {\n            for (int j = 0; j < N; j++)\n            {\n                if (S[i] == T[j])\n                {\n                    dp[i + 1, j + 1] = dp[i, j] + 1;\n                }\n                else\n                {\n                    dp[i + 1, j + 1] = Max(dp[i, j + 1], dp[i + 1, j]);\n                }\n            }\n        }\n        WriteLine(Min(N, dp[N, N] + K * 2));\n\n        //if (N % 2 == 1)\n        //{\n        //    long ans = 0;\n        //    var dp = new int[N + 1, N + 1, K + 1];\n        //    for (int i = 0; i <= N / 2; i++)\n        //    {\n        //        for (int j = 0; j <= N / 2; j++)\n        //        {\n        //            for (int k = 0; k <= K; k++)\n        //            {\n        //                if (S[i] == T[j])\n        //                {\n        //                    dp[i + 1, j + 1, k] = Max(Max(dp[i, j + 1, k], dp[i + 1, j, k]), dp[i + 1, j + 1, k]);\n        //                    dp[i + 1, j + 1, k] = Max(dp[i, j, k] + 1, dp[i + 1, j + 1, k]);\n        //                }\n        //                else\n        //                {\n        //                    dp[i + 1, j + 1, k] = Max(Max(dp[i, j + 1, k], dp[i + 1, j, k]), dp[i + 1, j + 1, k]);\n        //                    //S[i] == T[j]、T[N - i - 1] == S[N - i - 1]とできる\n        //                    if (k < K)\n        //                    {\n        //                        dp[i + 1, j + 1, k + 1] = Max(Max(dp[i, j + 1, k + 1], dp[i + 1, j, k + 1]), dp[i + 1, j + 1, k + 1]);\n        //                        dp[i + 1, j + 1, k + 1] = Max(dp[i, j, k] + 1, dp[i + 1, j + 1, k + 1]);\n        //                    }\n        //                }\n        //                ans = Max(ans, dp[i + 1, j + 1, k]);\n        //            }\n        //        }\n        //    }\n        //    WriteLine(ans * 2 + 1);\n        //}\n        //else\n        //{\n        //    long ans = 0;\n        //    var dp = new int[N + 1, N + 1, K + 1];\n        //    for (int i = 0; i < N / 2; i++)\n        //    {\n        //        for (int j = 0; j < N / 2; j++)\n        //        {\n        //            for (int k = 0; k <= K; k++)\n        //            {\n        //                if (S[i] == T[j])\n        //                {\n        //                    dp[i + 1, j + 1, k] = Max(Max(dp[i, j + 1, k], dp[i + 1, j, k]), dp[i + 1, j + 1, k]);\n        //                    dp[i + 1, j + 1, k] = Max(dp[i, j, k] + 1, dp[i + 1, j + 1, k]);\n        //                }\n        //                else\n        //                {\n        //                    dp[i + 1, j + 1, k] = Max(Max(dp[i, j + 1, k], dp[i + 1, j, k]), dp[i + 1, j + 1, k]);\n        //                    //S[i] == T[j]、T[N - i - 1] == S[N - i - 1]とできる\n        //                    if (k < K)\n        //                    {\n        //                        dp[i + 1, j + 1, k + 1] = Max(Max(dp[i, j + 1, k + 1], dp[i + 1, j, k + 1]), dp[i + 1, j + 1, k + 1]);\n        //                        dp[i + 1, j + 1, k + 1] = Max(dp[i, j, k] + 1, dp[i + 1, j + 1, k + 1]);\n        //                    }\n        //                }\n        //                ans = Max(ans, dp[i + 1, j + 1, k]);\n        //            }\n        //        }\n        //    }\n        //    WriteLine(ans * 2);\n        //}\n        //for (int i = 0; i <= N / 2; i++)\n        //{\n        //    for (int j = 0; j <= N / 2; j++)\n        //    {\n        //        Write(dp[i, j, K] + \" \");\n        //    }\n        //    WriteLine();\n        //}\n        //if (N % 2 == 0)\n        //{\n        //    WriteLine(dp[N / 2, N / 2, K] * 2);\n        //}\n        //else\n        //{\n        //    WriteLine(dp[N / 2, N / 2, K] * 2 + 1);\n        //}\n        //WriteLine(ans);\n    }\n\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan { get { return ReadLine().Split(); } }\n    public int[] scanint { get { return Array.ConvertAll(scan, int.Parse); } }\n    public long[] scanlong { get { return Array.ConvertAll(scan, long.Parse); } }\n    public double[] scandouble { get { return Array.ConvertAll(scan, double.Parse); } }\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint { get { return int.Parse(next); } }\n    public long nextlong { get { return long.Parse(next); } }\n    public double nextdouble { get { return double.Parse(next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tvar s=\"$\"+sc.S+\"$\";\n\t\tint n=sc.I;\n\t\tint ans=0;\n\t\tfor(int i = 1;i<s.Length-1;i++) {\n\t\t\tans=Max(ans,lcs2(s,i,i,n)-1);\n\t\t\tif(i<s.Length-2&&s[i]==s[i+1]){\n\t\t\t\tans=Max(ans,lcs2(s,i,i+1,n));\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine(\"{0}\",ans);\n\t}\n\tstatic int lcs2(string s,int a,int b,int n){\n\t\tint[][] dp=new int[a+1][];\n\t\tint[][] dp2=new int[a+1][];\n\t\tint[][] dp3=new int[a+1][];\n\t\tint[][] dp4=new int[a+1][];\n\t\tdp[a]=new int[s.Length-b];\n\t\tdp2[a]=new int[s.Length-b];\n\t\tdp3[a]=new int[s.Length-b];\n\t\tdp4[a]=new int[s.Length-b];\n\t\tfor(int i=a-1;i>=0;i--){\n\t\t\tdp[i]=new int[s.Length-b];\n\t\t\tdp2[i]=new int[s.Length-b];\n\t\t\tdp3[i]=new int[s.Length-b];\n\t\t\tdp4[i]=new int[s.Length-b];\n\t\t\tfor(int j=1;j<dp[i].Length;j++){\n\t\t\t\tdp[i][j]=Max(dp[i+1][j],dp[i][j-1]);\n\t\t\t\tdp4[i][j]=Max(dp4[i+1][j],dp4[i][j-1]);\n\t\t\t\tif(s[i]==s[j+b]){\n\t\t\t\t\tdp[i][j]=Max(dp[i+1][j-1]+1,dp[i][j]);\n\t\t\t\t\tdp2[i][j]=0;\n\t\t\t\t\tdp3[i][j]=0;\n\t\t\t\t\tdp4[i][j]+=Min(dp2[i][j-1],dp3[i+1][j]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(dp[i][j]!=dp[i][j-1]){dp2[i][j]=0;}\n\t\t\t\t\telse{dp2[i][j]=dp2[i][j-1]+1;}\n\t\t\t\t\tif(dp[i][j]!=dp[i+1][j]){dp3[i][j]=0;}\n\t\t\t\t\telse{dp3[i][j]=dp3[i+1][j]+1;}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[0][s.Length-b-1]*2+Min(dp4[0][s.Length-b-1],n)*2;\n\t}\n}\n\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n#-swank (disable-debugger) ; for CS Academy\n\n;; BEGIN_INSERTED_CONTENTS\n(macrolet ((def (name fname)\n             `(define-modify-macro ,name (new-value) ,fname)))\n  (def minf min)\n  (def maxf max)\n  (def mulf *)\n  (def divf /)\n  (def iorf logior)\n  (def xorf logxor)\n  (def andf logand))\n\n(in-package :cl-user)\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;;;\n;;; Body\n;;;\n\n(defun main ()\n  (let* ((s (read-line))\n         (n (length s))\n         (k (read))\n         (dp (make-array (list (+ n 1) (+ n 1) (+ k 1))\n                         :element-type 'uint31\n                         :initial-element 0)))\n    (dotimes (x (+ n 1))\n      (dotimes (y (+ n 1))\n        (dotimes (z (+ k 1))\n          (let ((value 0))\n            (when (> x 0)\n              (maxf value (aref dp (- x 1) y z)))\n            (when (> y 0)\n              (maxf value (aref dp x (- y 1) z)))\n            (when (> z 0)\n              (maxf value (aref dp x y (- z 1))))\n            (when (and (> x 0) (> y 0))\n              (cond ((char= (aref s (- x 1)) (aref s (- n y)))\n                     (maxf value (+ 1 (aref dp (- x 1) (- y 1) z))))\n                    ((> z 0)\n                     (maxf value (+ 1 (aref dp (- x 1) (- y 1) (- z 1)))))))\n            (setf (aref dp x y z) value)))))\n    (let ((res 0))\n      (loop for x from 1 to n\n            do (let ((y (- n x)))\n                 (maxf res (* 2 (aref dp x y k))))\n               (let ((y (- (+ n 1) x)))\n                 (assert (char= (aref s (- x 1)) (aref s (- n y))))\n                 (maxf res (- (* 2 (aref dp x y k)) 1))))\n      (println res))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"abcabcabc\n1\n\"\n    \"7\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"atcodergrandcontest\n3\n\"\n    \"15\n\")))\n"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n#-swank (disable-debugger) ; for CS Academy\n\n;; BEGIN_INSERTED_CONTENTS\n(macrolet ((def (name fname)\n             `(define-modify-macro ,name (new-value) ,fname)))\n  (def minf min)\n  (def maxf max)\n  (def mulf *)\n  (def divf /)\n  (def iorf logior)\n  (def xorf logxor)\n  (def andf logand))\n\n(in-package :cl-user)\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;;;\n;;; Body\n;;;\n\n(defun main ()\n  (declare #.OPT)\n  (let* ((s (coerce (read-line) 'simple-base-string))\n         (n (length s))\n         (k (read))\n         (dp (make-array '(301 301 301)\n                         :element-type 'uint31\n                         :initial-element 0)))\n    (declare (uint16 n k))\n    (dotimes (x (+ n 1))\n      (dotimes (y (+ n 1))\n        (when (<= (+ x y) (+ n 1))\n          (dotimes (z (+ k 1))\n            (let ((value 0))\n              (declare (uint31 value))\n              (when (> x 0)\n                (maxf value (aref dp (- x 1) y z)))\n              (when (> y 0)\n                (maxf value (aref dp x (- y 1) z)))\n              (when (> z 0)\n                (maxf value (aref dp x y (- z 1))))\n              (when (and (> x 0) (> y 0))\n                (cond ((char= (aref s (- x 1)) (aref s (- n y)))\n                       (maxf value (+ 1 (aref dp (- x 1) (- y 1) z))))\n                      ((> z 0)\n                       (maxf value (+ 1 (aref dp (- x 1) (- y 1) (- z 1)))))))\n              (setf (aref dp x y z) value))))))\n    (let ((res 0))\n      (declare (uint31 res))\n      (loop for x from 1 to n\n            do (let ((y (- n x)))\n                 (maxf res (* 2 (aref dp x y k))))\n               (let ((y (- (+ n 1) x)))\n                 (assert (char= (aref s (- x 1)) (aref s (- n y))))\n                 (maxf res (- (* 2 (aref dp x y k)) 1))))\n      (println res))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"abcabcabc\n1\n\"\n    \"7\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"atcodergrandcontest\n3\n\"\n    \"15\n\")))\n"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n#-swank (disable-debugger) ; for CS Academy\n\n;; BEGIN_INSERTED_CONTENTS\n(macrolet ((def (name fname)\n             `(define-modify-macro ,name (new-value) ,fname)))\n  (def minf min)\n  (def maxf max)\n  (def mulf *)\n  (def divf /)\n  (def iorf logior)\n  (def xorf logxor)\n  (def andf logand))\n\n(in-package :cl-user)\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;;;\n;;; Body\n;;;\n\n(defun main ()\n  (declare #.OPT)\n  (let* ((s (coerce (read-line) 'simple-base-string))\n         (n (length s))\n         (k (read))\n         (dp (make-array '(301 301 301)\n                         :element-type 'uint15\n                         :initial-element 0)))\n    (declare (uint16 n k))\n    (dotimes (x (+ n 1))\n      (dotimes (y (+ n 1))\n        (when (<= (+ x y) (+ n 1))\n          (dotimes (z (+ k 1))\n            (let ((value 0))\n              (declare (uint31 value))\n              (when (> x 0)\n                (maxf value (aref dp (- x 1) y z)))\n              (when (> y 0)\n                (maxf value (aref dp x (- y 1) z)))\n              (when (> z 0)\n                (maxf value (aref dp x y (- z 1))))\n              (when (and (> x 0) (> y 0))\n                (cond ((char= (aref s (- x 1)) (aref s (- n y)))\n                       (maxf value (+ 1 (aref dp (- x 1) (- y 1) z))))\n                      ((> z 0)\n                       (maxf value (+ 1 (aref dp (- x 1) (- y 1) (- z 1)))))))\n              (setf (aref dp x y z) value))))))\n    (let ((res 0))\n      (declare (uint31 res))\n      (loop for x from 1 to n\n            do (let ((y (- n x)))\n                 (maxf res (* 2 (aref dp x y k))))\n               (let ((y (- (+ n 1) x)))\n                 (assert (char= (aref s (- x 1)) (aref s (- n y))))\n                 (maxf res (- (* 2 (aref dp x y k)) 1))))\n      (println res))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"abcabcabc\n1\n\"\n    \"7\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"atcodergrandcontest\n3\n\"\n    \"15\n\")))\n"
  },
  {
    "language": "Ruby",
    "code": "def dfs s,t,w\n  max = w\n  aa = ('a'..'z').to_a\n  aa.each{|c|\n    sd = s.index(c)\n    td = t.index(c)\n    if sd&&td\n      res = dfs(s[sd+1..-1],t[td+1..-1],w+1)\n      max = res if max < res\n    end\n  }\n  return max\nend\n\ns = gets.chomp\nt = s.reverse\nk = gets.to_i\nn = s.size\n\naa = ('a'..'z').to_a\ninf = 10**9\n\nres = dfs(s,t,0)\n\np [n, res+k*2].min"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n  \"bufio\"\n  \"os\"\n  \"strconv\"\n  \"strings\"\n  \"fmt\"\n)\n\nvar reader = bufio.NewReaderSize(os.Stdin, 1000000)\nvar writer = bufio.NewWriter(os.Stdout)\nfunc NextLine() string {\n  buffer := make([]byte, 0)\n  for true {\n    line, isPrefix, err := reader.ReadLine()\n    if err != nil { panic(err) }\n    buffer = append(buffer, line...)\n    if !isPrefix { break }\n  }\n  return string(buffer)\n}\nfunc NextInt() int {\n  n, _ := strconv.Atoi(NextLine())\n  return n\n}\nfunc NextIntVec() []int {\n  L := strings.Split(NextLine(), \" \")\n  N := make([]int, len(L))\n  for i := range N {\n    N[i], _ = strconv.Atoi(L[i])\n  }\n  return N\n}\nfunc NextFloat() float64 {\n  n, _ := strconv.ParseFloat(NextLine(), 64)\n  return n\n}\nfunc NextFloatVec() []float64 {\n  L := strings.Split(NextLine(), \" \")\n  N := make([]float64, len(L))\n  for i := range N {\n    N[i], _ = strconv.ParseFloat(L[i], 64)\n  }\n  return N\n}\nfunc Write(s interface{}) {\n  fmt.Fprintln(writer, s)\n}\nfunc WriteIntVec(A []int) {\n  S := make([]string, len(A))\n  for i, a := range A {\n    S[i] = strconv.Itoa(a)\n  }\n  Write(strings.Join(S, \" \"))\n}\nfunc Output() {\n  _ = writer.Flush()\n}\n\nfunc MaxInt(A ...int32) int32 {\n  max := A[0]\n  for _, a := range A {\n    if max < a { max = a }\n  }\n  return max\n}\n\nfunc Solve() {\n  S := NextLine()\n  N := len(S)\n  K := NextInt()\n  M := make([][]int, 26)\n  for i := range M {\n    M[i] = make([]int, N)\n  }\n  for i, s := range S {\n    m := int(s) - int('a')\n    M[m][i] = i + 1\n  }\n  for i := range M {\n    for j := N - 1; 0 < j; j-- {\n      if 0 < M[i][j - 1] { continue }\n      M[i][j - 1] = M[i][j]\n    }\n  }\n  DP := make([][][]int32, K + 1)\n  for i := range DP {\n    DP[i] = make([][]int32, N)\n    for j := range DP[i] {\n      DP[i][j] = make([]int32, N)\n      for k := 0; k < i + 1; k++ {\n        if N <= j + k { continue }\n        DP[i][j][j + k] = int32(k + 1)\n      }\n    }\n  }\n  for i := range DP {\n    for j := N - 1; 0 <= j; j-- {\n      for k := j + 1; k < N; k++ {\n        DP[i][j][k] = MaxInt(DP[i][j][k - 1], DP[i][j][k])\n        l := M[int(S[k]) - int('a')][j]\n        if l <= k {\n          DP[i][j][k] = MaxInt(DP[i][l][k - 1] + 2, DP[i][j][k])\n        }\n        if j < N - 1 {\n          DP[i][j][k] = MaxInt(DP[i][j + 1][k], DP[i][j][k])\n        }\n        if 0 < i {\n          DP[i][j][k] = MaxInt(DP[i - 1][j][k], DP[i][j][k])\n          DP[i][j][k] = MaxInt(DP[i - 1][j + 1][k - 1] + 2, DP[i][j][k])\n        }\n      }\n    }\n  }\n  Write(DP[K][0][N - 1])\n  return\n}\n\nfunc main() {\n  Solve()\n  Output()\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n  \"bufio\"\n  \"os\"\n  \"strconv\"\n  \"fmt\"\n)\n\nvar reader = bufio.NewReaderSize(os.Stdin, 1000000)\nvar writer = bufio.NewWriter(os.Stdout)\nfunc NextLine() string {\n  buffer := make([]byte, 0)\n  for true {\n    line, isPrefix, err := reader.ReadLine()\n    if err != nil { panic(err) }\n    buffer = append(buffer, line...)\n    if !isPrefix { break }\n  }\n  return string(buffer)\n}\nfunc NextInt() int {\n  n, _ := strconv.Atoi(NextLine())\n  return n\n}\nfunc Write(s interface{}) {\n  fmt.Fprintln(writer, s)\n}\nfunc Output() {\n  _ = writer.Flush()\n}\n\nfunc MaxInt(A ...int) int {\n  max := A[0]\n  for _, a := range A {\n    if max < a { max = a }\n  }\n  return max\n}\n\nfunc SearchAfter(M []int, s int) int {\n  N := len(M)\n  if s <= M[0] { return M[0] }\n  lts, ges := 0, N - 1\n  for 1 < ges - lts {\n    med := (ges - lts) / 2\n    if M[med] < s {\n      lts = med\n    } else {\n      ges = med\n    }\n  }\n  return M[ges]\n}\n\nfunc Solve() {\n  S := NextLine()\n  N := len(S)\n  K := NextInt()\n  M := make([][]int, 26)\n  for i := range M {\n    M[i] = make([]int, 0)\n  }\n  for i, s := range S {\n    m := int(s) - int('a')\n    M[m] = append(M[m], i)\n  }\n  DP := make([][][]int, K + 1)\n  for i := range DP {\n    DP[i] = make([][]int, N)\n    for j := range DP[i] {\n      DP[i][j] = make([]int, N)\n      if N <= j + i { continue }\n      DP[i][j][j + i] = i + 1\n    }\n  }\n  for i := range DP {\n    for j := N - 1; 0 <= j; j-- {\n      for k := j + 1; k < N; k++ {\n        DP[i][j][k] = MaxInt(DP[i][j][k - 1], DP[i][j][k])\n        l := SearchAfter(M[int(S[k]) - int('a')], j)\n        if l < k {\n          DP[i][j][k] = MaxInt(DP[i][l + 1][k - 1] + 2, DP[i][j][k])\n        }\n        if j < N - 1 {\n          DP[i][j][k] = MaxInt(DP[i][j + 1][k], DP[i][j][k])\n        }\n        if 0 < i {\n          DP[i][j][k] = MaxInt(DP[i - 1][j][k], DP[i][j][k])\n          DP[i][j][k] = MaxInt(DP[i - 1][j + 1][k - 1] + 2, DP[i][j][k])\n        }\n      }\n    }\n  }\n  Write(DP[K][0][N - 1])\n  return\n}\n\nfunc main() {\n  Solve()\n  Output()\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n  \"bufio\"\n  \"os\"\n  \"strconv\"\n  \"strings\"\n  \"fmt\"\n)\n\nvar reader = bufio.NewReaderSize(os.Stdin, 1000000)\nvar writer = bufio.NewWriter(os.Stdout)\nfunc NextLine() string {\n  buffer := make([]byte, 0)\n  for true {\n    line, isPrefix, err := reader.ReadLine()\n    if err != nil { panic(err) }\n    buffer = append(buffer, line...)\n    if !isPrefix { break }\n  }\n  return string(buffer)\n}\nfunc NextInt() int {\n  n, _ := strconv.Atoi(NextLine())\n  return n\n}\nfunc NextIntVec() []int {\n  L := strings.Split(NextLine(), \" \")\n  N := make([]int, len(L))\n  for i := range N {\n    N[i], _ = strconv.Atoi(L[i])\n  }\n  return N\n}\nfunc NextFloat() float64 {\n  n, _ := strconv.ParseFloat(NextLine(), 64)\n  return n\n}\nfunc NextFloatVec() []float64 {\n  L := strings.Split(NextLine(), \" \")\n  N := make([]float64, len(L))\n  for i := range N {\n    N[i], _ = strconv.ParseFloat(L[i], 64)\n  }\n  return N\n}\nfunc Write(s interface{}) {\n  fmt.Fprintln(writer, s)\n}\nfunc WriteIntVec(A []int) {\n  S := make([]string, len(A))\n  for i, a := range A {\n    S[i] = strconv.Itoa(a)\n  }\n  Write(strings.Join(S, \" \"))\n}\nfunc Output() {\n  _ = writer.Flush()\n}\n\nfunc MaxInt(A ...int) int {\n  max := A[0]\n  for _, a := range A {\n    if max < a { max = a }\n  }\n  return max\n}\n\nfunc Solve() {\n  S := NextLine()\n  N := len(S)\n  K := NextInt()\n  M := make([][]int, 26)\n  for i := range M {\n    M[i] = make([]int, N)\n  }\n  for i, s := range S {\n    m := int(s) - int('a')\n    M[m][i] = i + 1\n  }\n  for i := range M {\n    for j := N - 1; 0 < j; j-- {\n      if 0 < M[i][j - 1] { continue }\n      M[i][j - 1] = M[i][j]\n    }\n  }\n  DP := make([][][]int, K + 1)\n  for i := range DP {\n    DP[i] = make([][]int, N)\n    for j := range DP[i] {\n      DP[i][j] = make([]int, N)\n      for k := 0; k < i + 1; k++ {\n        if N <= j + k { continue }\n        DP[i][j][j + k] = k + 1\n      }\n    }\n  }\n  for i := range DP {\n    for j := N - 1; 0 <= j; j-- {\n      for k := j + 1; k < N; k++ {\n        DP[i][j][k] = MaxInt(DP[i][j][k - 1], DP[i][j][k])\n        l := M[int(S[k]) - int('a')][j]\n        if l <= k {\n          DP[i][j][k] = MaxInt(DP[i][l][k - 1] + 2, DP[i][j][k])\n        }\n        if j < N - 1 {\n          DP[i][j][k] = MaxInt(DP[i][j + 1][k], DP[i][j][k])\n        }\n        if 0 < i {\n          DP[i][j][k] = MaxInt(DP[i - 1][j][k], DP[i][j][k])\n          DP[i][j][k] = MaxInt(DP[i - 1][j + 1][k - 1] + 2, DP[i][j][k])\n        }\n      }\n    }\n  }\n  Write(DP[K][0][N - 1])\n  return\n}\n\nfunc main() {\n  Solve()\n  Output()\n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n  \"bufio\"\n  \"os\"\n  \"strconv\"\n  \"strings\"\n  \"fmt\"\n)\n\nvar reader = bufio.NewReaderSize(os.Stdin, 1000000)\nvar writer = bufio.NewWriter(os.Stdout)\nfunc NextLine() string {\n  buffer := make([]byte, 0)\n  for true {\n    line, isPrefix, err := reader.ReadLine()\n    if err != nil { panic(err) }\n    buffer = append(buffer, line...)\n    if !isPrefix { break }\n  }\n  return string(buffer)\n}\nfunc NextInt() int {\n  n, _ := strconv.Atoi(NextLine())\n  return n\n}\nfunc NextIntVec() []int {\n  L := strings.Split(NextLine(), \" \")\n  N := make([]int, len(L))\n  for i := range N {\n    N[i], _ = strconv.Atoi(L[i])\n  }\n  return N\n}\nfunc NextFloat() float64 {\n  n, _ := strconv.ParseFloat(NextLine(), 64)\n  return n\n}\nfunc NextFloatVec() []float64 {\n  L := strings.Split(NextLine(), \" \")\n  N := make([]float64, len(L))\n  for i := range N {\n    N[i], _ = strconv.ParseFloat(L[i], 64)\n  }\n  return N\n}\nfunc Write(s interface{}) {\n  fmt.Fprintln(writer, s)\n}\nfunc WriteIntVec(A []int) {\n  S := make([]string, len(A))\n  for i, a := range A {\n    S[i] = strconv.Itoa(a)\n  }\n  Write(strings.Join(S, \" \"))\n}\nfunc Output() {\n  _ = writer.Flush()\n}\n\nfunc MaxInt(A ...int) int {\n  max := A[0]\n  for _, a := range A {\n    if max < a { max = a }\n  }\n  return max\n}\n\nfunc Solve() {\n  S := NextLine()\n  N := len(S)\n  K := NextInt()\n  M := make([][]int, 26)\n  for i := range M {\n    M[i] = make([]int, N)\n  }\n  for i, s := range S {\n    m := int(s) - int('a')\n    M[m][i] = i + 1\n  }\n  for i := range M {\n    for j := N - 1; 0 < j; j-- {\n      if 0 < M[i][j - 1] { continue }\n      M[i][j - 1] = M[i][j]\n    }\n  }\n  DP := make([][][]int, K + 1)\n  for i := range DP {\n    DP[i] = make([][]int, N)\n    for j := range DP[i] {\n      DP[i][j] = make([]int, N)\n      if N <= j + i { continue }\n      DP[i][j][j + i] = i + 1\n    }\n  }\n  for i := range DP {\n    for j := N - 1; 0 <= j; j-- {\n      for k := j + 1; k < N; k++ {\n        DP[i][j][k] = MaxInt(DP[i][j][k - 1], DP[i][j][k])\n        l := M[int(S[k]) - int('a')][j]\n        if l <= k {\n          DP[i][j][k] = MaxInt(DP[i][l][k - 1] + 2, DP[i][j][k])\n        }\n        if j < N - 1 {\n          DP[i][j][k] = MaxInt(DP[i][j + 1][k], DP[i][j][k])\n        }\n        if 0 < i {\n          DP[i][j][k] = MaxInt(DP[i - 1][j][k], DP[i][j][k])\n          DP[i][j][k] = MaxInt(DP[i - 1][j + 1][k - 1] + 2, DP[i][j][k])\n        }\n      }\n    }\n  }\n  Write(DP[K][0][N - 1])\n  return\n}\n\nfunc main() {\n  Solve()\n  Output()\n}"
  },
  {
    "language": "Go",
    "code": "package main\nimport \"fmt\"\nfunc main() {\n  var s string\n  var k int\n  fmt.Scan(&s,&k)\n  n := len(s)\n  dp := make([][][]int,n+1)\n  for l:=0;l<n+1;l++ {\n    dp[l] = make([][]int,n)\n    for r:=0;r<n;r++ {\n      dp[l][r] = make([]int,k+1)\n      for i:=0;i<k+1;i++ { dp[l][r][i] = -(1<<30) }\n    }\n  }\n  dp[0][n-1][k] = 0\n  ans := 0\n  for l:=0;l<n;l++ {\n    for r:=n-1;r>=max(0,l-1);r-- {\n      for i:=0;i<k+1;i++ {\n        if dp[l][r][i] < 0 { continue }\n        f := 0\n        if l <= r { f = 1 }\n        ans = max(ans,dp[l][r][i]+f)\n        dp[l+1][r][i] = max(dp[l+1][r][i],dp[l][r][i])\n        if r > 0 { dp[l][r-1][i] = max(dp[l][r-1][i],dp[l][r][i]) }\n        if l < r {\n          f = 0\n          if s[l:l+1] != s[r:r+1] { f = 1 }\n          if i-f >= 0 { dp[l+1][r-1][i-f] = max(dp[l+1][r-1][i-f],dp[l][r][i]+2) }\n        }\n      }\n    }\n  }\n  fmt.Println(ans)\n}\nfunc max(x,y int) int {\n  if x > y { return x }\n  return y \n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n  \"bufio\"\n  \"os\"\n  \"strconv\"\n  \"fmt\"\n)\n\nvar reader = bufio.NewReaderSize(os.Stdin, 1000000)\nvar writer = bufio.NewWriter(os.Stdout)\nfunc NextLine() string {\n  buffer := make([]byte, 0)\n  for true {\n    line, isPrefix, err := reader.ReadLine()\n    if err != nil { panic(err) }\n    buffer = append(buffer, line...)\n    if !isPrefix { break }\n  }\n  return string(buffer)\n}\nfunc NextInt() int {\n  n, _ := strconv.Atoi(NextLine())\n  return n\n}\nfunc Write(s interface{}) {\n  fmt.Fprintln(writer, s)\n}\nfunc Output() {\n  _ = writer.Flush()\n}\n\nfunc MaxInt(A ...int) int {\n  max := A[0]\n  for _, a := range A {\n    if max < a { max = a }\n  }\n  return max\n}\n\nfunc Solve() {\n  S := NextLine()\n  N := len(S)\n  K := NextInt()\n  M := make([][]int, 26)\n  for i := range M {\n    M[i] = make([]int, N)\n  }\n  for i, s := range S {\n    m := int(s) - int('a')\n    M[m][i] = i\n  }\n  for i := range M {\n    for j := N - 1; 0 < j; j-- {\n      if 0 < M[i][j - 1] { continue }\n      M[i][j - 1] = M[i][j]\n    }\n  }\n  DP := make([][][]int, K + 1)\n  for i := range DP {\n    DP[i] = make([][]int, N)\n    for j := range DP[i] {\n      DP[i][j] = make([]int, N)\n      if N <= j + i { continue }\n      DP[i][j][j + i] = i + 1\n    }\n  }\n  for i := range DP {\n    for j := N - 1; 0 <= j; j-- {\n      for k := j + 1; k < N; k++ {\n        DP[i][j][k] = MaxInt(DP[i][j][k - 1], DP[i][j][k])\n        l := M[int(S[k]) - int('a')][j]\n        if l < k {\n          DP[i][j][k] = MaxInt(DP[i][l + 1][k - 1] + 2, DP[i][j][k])\n        }\n        if j < N - 1 {\n          DP[i][j][k] = MaxInt(DP[i][j + 1][k], DP[i][j][k])\n        }\n        if 0 < i {\n          DP[i][j][k] = MaxInt(DP[i - 1][j][k], DP[i][j][k])\n          DP[i][j][k] = MaxInt(DP[i - 1][j + 1][k - 1] + 2, DP[i][j][k])\n        }\n      }\n    }\n  }\n  Write(DP[K][0][N - 1])\n  return\n}\n\nfunc main() {\n  Solve()\n  Output()\n}"
  },
  {
    "language": "Go",
    "code": "package main\nimport \"fmt\"\nfunc main() {\n  var s string\n  var k int\n  fmt.Scan(&s,&k)\n  n := len(s)\n  dp := make([][][]int,n)\n  for l:=0;l<n;l++ {\n    dp[l] = make([][]int,n)\n    for r:=0;r<n;r++ {\n      dp[l][r] = make([]int,k+1)\n      for i:=0;i<k+1;i++ { dp[l][r][i] = -(1<<30) }\n    }\n  }\n  dp[0][n-1][k] = 0\n  ans := 0\n  for l:=0;l<n;l++ {\n    for r:=n-1;r>=max(0,l-1);r-- {\n      for i:=0;i<k+1;i++ {\n        if dp[l][r][i] < 0 { continue }\n        f := 0\n        if l <= r { f = 1 }\n        ans = max(ans,dp[l][r][i]+f)\n        if l < n-1 { dp[l+1][r][i] = max(dp[l+1][r][i],dp[l][r][i]) }\n        if r > 0 { dp[l][r-1][i] = max(dp[l][r-1][i],dp[l][r][i]) }\n        if l < r {\n          f = 0\n          if s[l:l+1] != s[r:r+1] { f = 1 }\n          if i-f >= 0 { dp[l+1][r-1][i-f] = max(dp[l+1][r-1][i-f],dp[l][r][i]+2) }\n        }\n      }\n    }\n  }\n  fmt.Println(ans)\n}\nfunc max(x,y int) int {\n  if x > y { return x }\n  return y \n}"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n  \"bufio\"\n  \"os\"\n  \"strconv\"\n  \"strings\"\n  \"fmt\"\n)\n\nvar reader = bufio.NewReaderSize(os.Stdin, 1000000)\nvar writer = bufio.NewWriter(os.Stdout)\nfunc NextLine() string {\n  buffer := make([]byte, 0)\n  for true {\n    line, isPrefix, err := reader.ReadLine()\n    if err != nil { panic(err) }\n    buffer = append(buffer, line...)\n    if !isPrefix { break }\n  }\n  return string(buffer)\n}\nfunc NextInt() int {\n  n, _ := strconv.Atoi(NextLine())\n  return n\n}\nfunc NextIntVec() []int {\n  L := strings.Split(NextLine(), \" \")\n  N := make([]int, len(L))\n  for i := range N {\n    N[i], _ = strconv.Atoi(L[i])\n  }\n  return N\n}\nfunc NextFloat() float64 {\n  n, _ := strconv.ParseFloat(NextLine(), 64)\n  return n\n}\nfunc NextFloatVec() []float64 {\n  L := strings.Split(NextLine(), \" \")\n  N := make([]float64, len(L))\n  for i := range N {\n    N[i], _ = strconv.ParseFloat(L[i], 64)\n  }\n  return N\n}\nfunc Write(s interface{}) {\n  fmt.Fprintln(writer, s)\n}\nfunc WriteIntVec(A []int) {\n  S := make([]string, len(A))\n  for i, a := range A {\n    S[i] = strconv.Itoa(a)\n  }\n  Write(strings.Join(S, \" \"))\n}\nfunc Output() {\n  _ = writer.Flush()\n}\n\nfunc MaxInt(A ...int) int {\n  max := A[0]\n  for _, a := range A {\n    if max < a { max = a }\n  }\n  return max\n}\n\nfunc Solve() {\n  S := NextLine()\n  N := len(S)\n  K := NextInt()\n  M := make([][]int, 26)\n  for i := range M {\n    M[i] = make([]int, N)\n  }\n  for i, s := range S {\n    m := int(s) - int('a')\n    M[m][i] = i + 1\n  }\n  for i := range M {\n    for j := N - 1; 0 < j; j-- {\n      if 0 < M[i][j - 1] { continue }\n      M[i][j - 1] = M[i][j]\n    }\n  }\n  DP := make([][][]int, K + 1)\n  for i := range DP {\n    DP[i] = make([][]int, N)\n    for j := range DP[i] {\n      DP[i][j] = make([]int, N)\n      for k := 0; k < i + 1; k++ {\n        if N <= j + k { continue }\n        DP[i][j][j + k] = k + 1\n      }\n    }\n  }\n  for i := range DP {\n    for j := N - 1; 0 <= j; j-- {\n      for k := j + 1; k < N; k++ {\n        DP[i][j][k] = MaxInt(DP[i][j][k - 1], DP[i][j][k])\n        //l := M[int(S[k]) - int('a')][j]\n        if M[int(S[k]) - int('a')][j] <= k {\n          DP[i][j][k] = MaxInt(DP[i][M[int(S[k]) - int('a')][j]][k - 1] + 2, DP[i][j][k])\n        }\n        if j < N - 1 {\n          DP[i][j][k] = MaxInt(DP[i][j + 1][k], DP[i][j][k])\n        }\n        if 0 < i {\n          DP[i][j][k] = MaxInt(DP[i - 1][j][k], DP[i][j][k])\n          DP[i][j][k] = MaxInt(DP[i - 1][j + 1][k - 1] + 2, DP[i][j][k])\n        }\n      }\n    }\n  }\n  Write(DP[K][0][N - 1])\n  return\n}\n\nfunc main() {\n  Solve()\n  Output()\n}"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"D\"\n    dependency \"dunkelheit\" version=\">=0.9.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dkh.foundation, dkh.scanner;\n\n// import dkh.functional;\n\nstring s;\n\nmemoCont!calcBase calc;\nint calcBase(int l, int r, int k) {\n    if (l == r) return 1;\n    if (l > r) return 0;\n    int ans = max(calc(l+1, r, k), calc(l, r-1, k));\n    if (s[l] == s[r]) ans = max(ans, 2+calc(l+1, r-1, k));\n    if (k) ans = max(ans, 2 + calc(l+1, r-1, k-1));\n    return ans;\n}\n\nint main() {\n    Scanner sc = new Scanner(stdin);\n    scope(exit) assert(!sc.hasNext);\n    sc.read(s);\n    int k;\n    sc.read(k);\n    int n = s.length.to!int;\n    calc.init([[-1, n], [-1, n], [0, k]]);\n    writeln(calc(0, n-1, k));\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dunkelheit/source/dkh/scanner.d */\n// module dkh.scanner;\n\n// import dkh.container.stackpayload;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                StackPayload!E buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n\n    int unsafeRead(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n    void read(Args...)(auto ref Args args) {\n        import std.exception;\n        static if (args.length != 0) {\n            enforce(readSingle(args[0]));\n            read(args[1..$]);\n        }\n    }\n    bool hasNext() {\n        return succ();\n    }\n}\n\n\n \n \n\n \n/* IMPORT /Users/yosupo/Program/dunkelheit/source/dkh/container/stackpayload.d */\n// module dkh.container.stackpayload;\n\n \nstruct StackPayload(T, size_t MINCAP = 4) if (MINCAP >= 1) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n     \n    inout(T)[] data() inout { return (_data) ? _data[0..len] : null; }\n    \n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        return _data[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import core.stdc.string : memcpy;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        void* newData = GC.malloc(newCap * T.sizeof);\n        cap = newCap.to!uint;\n        if (len) memcpy(newData, _data, len * T.sizeof);\n        _data = cast(T*)(newData);\n    }  \n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }  \n     \n    void clear() {\n        len = 0;\n    }\n\n    void insertBack(T item) {\n        import std.algorithm : max;\n        if (len == cap) reserve(max(cap * 2, MINCAP));\n        _data[len++] = item;\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    void removeBack() {\n        assert(!empty, \"StackPayload.removeBack: Stack is empty\");\n        len--;\n    }  \n}\n\n \n/* IMPORT /Users/yosupo/Program/dunkelheit/source/dkh/functional.d */\n// module dkh.functional;\n\n \nstruct memoCont(alias pred) {\n    import std.traits : ReturnType, ParameterTypeTuple, isIntegral;\n    import std.meta : allSatisfy;\n    alias R = ReturnType!pred;\n    alias Args = ParameterTypeTuple!pred;\n    static assert (allSatisfy!(isIntegral, Args));\n    static immutable N = Args.length;\n    \n    private int[2][N] rng;\n    int[N] len;\n    R[] dp;\n    bool[] used;\n    void init(in int[2][N] rng) {\n        import std.algorithm : reduce, map;\n        import std.range : array;\n        this.rng = rng;\n        len = rng[].map!(a => a[1]-a[0]+1).array;\n        auto sz = reduce!\"a*b\"(1, len);\n        dp = new R[sz];\n        used = new bool[sz];\n    }\n    R opCall(Args args) {\n        import core.exception : RangeError;\n        size_t idx, base = 1;\n        foreach (i, v; args) {\n            version(assert) {\n                if (v < rng[i][0] || rng[i][1] < v) {\n                    throw new RangeError;\n                }\n            }\n            assert(rng[i][0] <= v && v <= rng[i][1]);\n            idx += base*(v - rng[i][0]);\n            base *= len[i];\n        }\n        if (used[idx]) return dp[idx];\n        used[idx] = true;\n        auto r = pred(args);\n        dp[idx] = r;\n        return r;\n    }\n}\n\n \n \n/* IMPORT /Users/yosupo/Program/dunkelheit/source/dkh/foundation.d */\n \n// module dkh.foundation;\n\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n\n/*\nThis source code generated by dunkelheit and include dunkelheit's source code.\ndunkelheit's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dunkelheit)\ndunkelheit's License: MIT License(https://github.com/yosupo06/dunkelheit/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.stdio;\n\nvoid main() {\n    auto S = readln.chomp;\n    auto N = S.length.to!int;\n    auto K = readln.chomp.to!int;\n\n    auto dp = new int[][][](N, N, K+1);\n    foreach (i; 0..N) dp[i][i][0] = 1;\n    if (K > 0) foreach (i; 0..N-1) dp[i][i+1][S[i]!=S[i+1]] = 2;\n    else foreach (i; 0..N-1) if (S[i] == S[i+1]) dp[i][i+1][0] = 2;\n\n    foreach (len; 1..N+1) {\n        foreach (il; 0..N-len+1) {\n            foreach (k; 0..K+1) {\n                int ir = il + len - 1;\n                if (il > 0) dp[il-1][ir][k] = max(dp[il-1][ir][k], dp[il][ir][k]);\n                if (ir < N - 1) dp[il][ir+1][k] = max(dp[il][ir+1][k], dp[il][ir][k]);\n                if (il > 0 && ir < N - 1) {\n                    int cost = S[il-1] != S[ir+1];\n                    if (k + cost <= K) {\n                        dp[il-1][ir+1][k+cost] = max(dp[il-1][ir+1][k+cost], dp[il][ir][k] + 2);\n                    }\n                }\n            }\n        }\n    }\n\n    dp[0][N-1].reduce!max.writeln;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.format;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\nimport std.ascii;\nimport std.concurrency;\nimport std.traits;\nimport core.bitop : popcnt;\nalias Generator = std.concurrency.Generator;\n\nconst long INF = long.max/3;\nconst long MOD = 10L^^9+7;\n\nvoid main() {\n    string as = readln.chomp;\n    int N = as.length.to!int;\n    int K;\n    scanln(K);\n\n    int[][][] dp = new int[][][](N, N, K+1);\n    foreach_reverse(l; 0..N) foreach(r; l..N) foreach(k; 0..K+1) {\n        if (l==r) {\n            dp[l][r][k] = 1;\n        } else {\n            dp[l][r][k] = max(dp[l][r][k], dp[l+1][r][k]);\n            dp[l][r][k] = max(dp[l][r][k], dp[l][r-1][k]);\n            if (as[l] == as[r]) dp[l][r][k] = max(dp[l][r][k], 2 + dp[l+1][r-1][k]);\n            if (k > 0) dp[l][r][k] = max(dp[l][r][k], 2 + dp[l+1][r-1][k-1]);\n        }\n    }\n    dp[0][N-1][K].writeln;\n}\n\n// ----------------------------------------------\n\nvoid scanln(Args...)(auto ref Args args) {\n    import std.meta;\n    template getFormat(T) {\n        static if (isIntegral!T) {\n            enum getFormat = \"%d\";\n        } else static if (isFloatingPoint!T) {\n            enum getFormat = \"%g\";\n        } else static if (isSomeString!T || isSomeChar!T) {\n            enum getFormat = \"%s\";\n        } else {\n            static assert(false);\n        }\n    }\n    enum string str = [staticMap!(getFormat, Args)].join(\" \") ~ \"\\n\";\n    // readf!str(args);\n    mixin(\"str.readf(\" ~ Args.length.iota.map!(i => \"&args[%d]\".format(i)).join(\", \") ~ \");\");\n}\n\nvoid times(alias fun)(int n) {\n    // n.iota.each!(i => fun());\n    foreach(i; 0..n) fun();\n}\nauto rep(alias fun, T = typeof(fun()))(int n) {\n    // return n.iota.map!(i => fun()).array;\n    T[] res = new T[n];\n    foreach(ref e; res) e = fun();\n    return res;\n}\n\nT ceil(T)(T x, T y) if (__traits(isIntegral, T)) {\n    // `(x+y-1)/y` will only work for positive numbers ...\n    T t = x / y;\n    if (t * y < x) t++;\n    return t;\n}\n\nT floor(T)(T x, T y) if (__traits(isIntegral, T)) {\n    T t = x / y;\n    if (t * y > x) t--;\n    return t;\n}\n\n// fold was added in D 2.071.0\nstatic if (__VERSION__ < 2071) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n}\n\n// cumulativeFold was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    template cumulativeFold(fun...)\n    if (fun.length >= 1)\n    {\n        import std.meta : staticMap;\n        private alias binfuns = staticMap!(binaryFun, fun);\n\n        auto cumulativeFold(R)(R range)\n        if (isInputRange!(Unqual!R))\n        {\n            return cumulativeFoldImpl(range);\n        }\n\n        auto cumulativeFold(R, S)(R range, S seed)\n        if (isInputRange!(Unqual!R))\n        {\n            static if (fun.length == 1)\n                return cumulativeFoldImpl(range, seed);\n            else\n                return cumulativeFoldImpl(range, seed.expand);\n        }\n\n        private auto cumulativeFoldImpl(R, Args...)(R range, ref Args args)\n        {\n            import std.algorithm.internal : algoFormat;\n\n            static assert(Args.length == 0 || Args.length == fun.length,\n                algoFormat(\"Seed %s does not have the correct amount of fields (should be %s)\",\n                    Args.stringof, fun.length));\n\n            static if (args.length)\n                alias State = staticMap!(Unqual, Args);\n            else\n                alias State = staticMap!(ReduceSeedType!(ElementType!R), binfuns);\n\n            foreach (i, f; binfuns)\n            {\n                static assert(!__traits(compiles, f(args[i], e)) || __traits(compiles,\n                        { args[i] = f(args[i], e); }()),\n                    algoFormat(\"Incompatible function/seed/element: %s/%s/%s\",\n                        fullyQualifiedName!f, Args[i].stringof, E.stringof));\n            }\n\n            static struct Result\n            {\n            private:\n                R source;\n                State state;\n\n                this(R range, ref Args args)\n                {\n                    source = range;\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                    {\n                        static if (args.length)\n                            state[i] = f(args[i], source.front);\n                        else\n                            state[i] = source.front;\n                    }\n                }\n\n            public:\n                @property bool empty()\n                {\n                    return source.empty;\n                }\n\n                @property auto front()\n                {\n                    assert(!empty, \"Attempting to fetch the front of an empty cumulativeFold.\");\n                    static if (fun.length > 1)\n                    {\n                        import std.typecons : tuple;\n                        return tuple(state);\n                    }\n                    else\n                    {\n                        return state[0];\n                    }\n                }\n\n                void popFront()\n                {\n                    assert(!empty, \"Attempting to popFront an empty cumulativeFold.\");\n                    source.popFront;\n\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                        state[i] = f(state[i], source.front);\n                }\n\n                static if (isForwardRange!R)\n                {\n                    @property auto save()\n                    {\n                        auto result = this;\n                        result.source = source.save;\n                        return result;\n                    }\n                }\n\n                static if (hasLength!R)\n                {\n                    @property size_t length()\n                    {\n                        return source.length;\n                    }\n                }\n            }\n\n            return Result(range, args);\n        }\n    }\n}\n\n// minElement/maxElement was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    auto minElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        alias mapFun = unaryFun!map;\n        auto element = r.front;\n        auto minimum = mapFun(element);\n        r.popFront;\n        foreach(a; r) {\n            auto b = mapFun(a);\n            if (b < minimum) {\n                element = a;\n                minimum = b;\n            }\n        }\n        return element;\n    }\n    auto maxElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        alias mapFun = unaryFun!map;\n        auto element = r.front;\n        auto maximum = mapFun(element);\n        r.popFront;\n        foreach(a; r) {\n            auto b = mapFun(a);\n            if (b > maximum) {\n                element = a;\n                maximum = b;\n            }\n        }\n        return element;\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.stdio;\n\nvoid main() {\n    auto S = readln.chomp;\n    auto N = S.length.to!int;\n    auto K = readln.chomp.to!int;\n\n    auto dp = new int[][][](N, N, K+1);\n    foreach (i; 0..N) dp[i][i][0] = 1;\n    if (K > 0) foreach (i; 0..N-1) dp[i][i+1][S[i]!=S[i+1]] = 2;\n\n    foreach (len; 1..N+1) {\n        foreach (il; 0..N-len+1) {\n            foreach (k; 0..K+1) {\n                int ir = il + len - 1;\n                if (il > 0) dp[il-1][ir][k] = max(dp[il-1][ir][k], dp[il][ir][k]);\n                if (ir < N - 1) dp[il][ir+1][k] = max(dp[il][ir+1][k], dp[il][ir][k]);\n                if (il > 0 && ir < N - 1) {\n                    int cost = S[il-1] != S[ir+1];\n                    if (k + cost <= K) {\n                        dp[il-1][ir+1][k+cost] = max(dp[il-1][ir+1][k+cost], dp[il][ir][k] + 2);\n                    }\n                }\n            }\n        }\n    }\n\n    dp[0][N-1].reduce!max.writeln;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.format;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\nimport std.ascii;\nimport std.concurrency;\nimport std.traits;\nimport core.bitop : popcnt;\nalias Generator = std.concurrency.Generator;\n\nconst long INF = long.max/3;\nconst long MOD = 10L^^9+7;\n\nvoid main() {\n    string as = readln.chomp;\n    int N = as.length.to!int;\n    int K;\n    scanln(K);\n\n    int[][][] dp = new int[][][](N, N, K+1);\n    foreach_reverse(l; 0..N) foreach(r; l..N) foreach(k; 0..K+1) {\n        if (l==r) {\n            dp[l][r][k] = 1;\n        } else if (as[l] == as[r]) {\n            dp[l][r][k] = 2 + dp[l+1][r-1][k];\n        } else {\n            dp[l][r][k] = max(dp[l][r][k], dp[l+1][r][k]);\n            dp[l][r][k] = max(dp[l][r][k], dp[l][r-1][k]);\n            if (k > 0) {\n                dp[l][r][k] = max(dp[l][r][k], 2 + dp[l+1][r-1][k-1]);\n            }\n        }\n    }\n    dp[0][N-1][K].writeln;\n}\n\n// ----------------------------------------------\n\nvoid scanln(Args...)(auto ref Args args) {\n    import std.meta;\n    template getFormat(T) {\n        static if (isIntegral!T) {\n            enum getFormat = \"%d\";\n        } else static if (isFloatingPoint!T) {\n            enum getFormat = \"%g\";\n        } else static if (isSomeString!T || isSomeChar!T) {\n            enum getFormat = \"%s\";\n        } else {\n            static assert(false);\n        }\n    }\n    enum string str = [staticMap!(getFormat, Args)].join(\" \") ~ \"\\n\";\n    // readf!str(args);\n    mixin(\"str.readf(\" ~ Args.length.iota.map!(i => \"&args[%d]\".format(i)).join(\", \") ~ \");\");\n}\n\nvoid times(alias fun)(int n) {\n    // n.iota.each!(i => fun());\n    foreach(i; 0..n) fun();\n}\nauto rep(alias fun, T = typeof(fun()))(int n) {\n    // return n.iota.map!(i => fun()).array;\n    T[] res = new T[n];\n    foreach(ref e; res) e = fun();\n    return res;\n}\n\nT ceil(T)(T x, T y) if (__traits(isIntegral, T)) {\n    // `(x+y-1)/y` will only work for positive numbers ...\n    T t = x / y;\n    if (t * y < x) t++;\n    return t;\n}\n\nT floor(T)(T x, T y) if (__traits(isIntegral, T)) {\n    T t = x / y;\n    if (t * y > x) t--;\n    return t;\n}\n\n// fold was added in D 2.071.0\nstatic if (__VERSION__ < 2071) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n}\n\n// cumulativeFold was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    template cumulativeFold(fun...)\n    if (fun.length >= 1)\n    {\n        import std.meta : staticMap;\n        private alias binfuns = staticMap!(binaryFun, fun);\n\n        auto cumulativeFold(R)(R range)\n        if (isInputRange!(Unqual!R))\n        {\n            return cumulativeFoldImpl(range);\n        }\n\n        auto cumulativeFold(R, S)(R range, S seed)\n        if (isInputRange!(Unqual!R))\n        {\n            static if (fun.length == 1)\n                return cumulativeFoldImpl(range, seed);\n            else\n                return cumulativeFoldImpl(range, seed.expand);\n        }\n\n        private auto cumulativeFoldImpl(R, Args...)(R range, ref Args args)\n        {\n            import std.algorithm.internal : algoFormat;\n\n            static assert(Args.length == 0 || Args.length == fun.length,\n                algoFormat(\"Seed %s does not have the correct amount of fields (should be %s)\",\n                    Args.stringof, fun.length));\n\n            static if (args.length)\n                alias State = staticMap!(Unqual, Args);\n            else\n                alias State = staticMap!(ReduceSeedType!(ElementType!R), binfuns);\n\n            foreach (i, f; binfuns)\n            {\n                static assert(!__traits(compiles, f(args[i], e)) || __traits(compiles,\n                        { args[i] = f(args[i], e); }()),\n                    algoFormat(\"Incompatible function/seed/element: %s/%s/%s\",\n                        fullyQualifiedName!f, Args[i].stringof, E.stringof));\n            }\n\n            static struct Result\n            {\n            private:\n                R source;\n                State state;\n\n                this(R range, ref Args args)\n                {\n                    source = range;\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                    {\n                        static if (args.length)\n                            state[i] = f(args[i], source.front);\n                        else\n                            state[i] = source.front;\n                    }\n                }\n\n            public:\n                @property bool empty()\n                {\n                    return source.empty;\n                }\n\n                @property auto front()\n                {\n                    assert(!empty, \"Attempting to fetch the front of an empty cumulativeFold.\");\n                    static if (fun.length > 1)\n                    {\n                        import std.typecons : tuple;\n                        return tuple(state);\n                    }\n                    else\n                    {\n                        return state[0];\n                    }\n                }\n\n                void popFront()\n                {\n                    assert(!empty, \"Attempting to popFront an empty cumulativeFold.\");\n                    source.popFront;\n\n                    if (source.empty)\n                        return;\n\n                    foreach (i, f; binfuns)\n                        state[i] = f(state[i], source.front);\n                }\n\n                static if (isForwardRange!R)\n                {\n                    @property auto save()\n                    {\n                        auto result = this;\n                        result.source = source.save;\n                        return result;\n                    }\n                }\n\n                static if (hasLength!R)\n                {\n                    @property size_t length()\n                    {\n                        return source.length;\n                    }\n                }\n            }\n\n            return Result(range, args);\n        }\n    }\n}\n\n// minElement/maxElement was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n    auto minElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        alias mapFun = unaryFun!map;\n        auto element = r.front;\n        auto minimum = mapFun(element);\n        r.popFront;\n        foreach(a; r) {\n            auto b = mapFun(a);\n            if (b < minimum) {\n                element = a;\n                minimum = b;\n            }\n        }\n        return element;\n    }\n    auto maxElement(alias map, Range)(Range r)\n    if (isInputRange!Range && !isInfinite!Range)\n    {\n        alias mapFun = unaryFun!map;\n        auto element = r.front;\n        auto maximum = mapFun(element);\n        r.popFront;\n        foreach(a; r) {\n            auto b = mapFun(a);\n            if (b > maximum) {\n                element = a;\n                maximum = b;\n            }\n        }\n        return element;\n    }\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nchar str[606];\nchar str2[606];\nint dp[606][606];\nint main(){\n    memset(dp,0,sizeof(dp));\n    int k;\n    scanf(\"%s\",str);\n    scanf(\"%d\",&k);\n    int n = strlen(str);\n    for(int i=0;i<n;i++){\n        str2[i*2+1] = str[i];\n        str2[i*2+2] = '*';\n    }\n    n = n*2-1;\n    int ans = 0;\n    for(int mid = 1; mid<=n/2+1;mid++){\n        for(int i=0;i<=500;i++)for(int j=0;j<=500;j++)dp[i][j]=0;\n        for(int i=1;i<=n-mid;i++){\n            for(int j=0;j<=min(i,k);j++){\n                if(str2[mid-dp[i-1][j]-1]==str2[mid+i]){\n                    dp[i][j] = dp[i-1][j]+1;\n                }\n                else{\n                    dp[i][j] = dp[i-1][j];\n                }\n                if(j>0)dp[i][j] = max(dp[i][j],dp[i-1][j-1]+1);\n            }\n        }\n        for(int i=0;i<=k;i++){\n            if(dp[n-mid][i]==mid-1){\n                ans = max(ans,mid);\n            }\n        }\n    }\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N = 305;\nint dp[N][N][N] = {}, k;\nchar s[N];\n\nint main()\n{\n    scanf(\"%s%d\", s+1, &k);\n    int n = strlen(s+1);\n    for(int i = 1;i<=n;i++) for(int j = 0;j<=k;j++) dp[i][i][j] = 1, dp[i][i-1][j] = 0;\n    for(int j = 1;j<n;j++){\n        for(int i = 1;i+j<=n;i++){\n            for(int r = 0;r<=k;r++){\n                dp[i][i+j][r] = max(dp[i+1][i+j][r], dp[i][i+j-1][r]);\n                if(s[i] == s[i+j]) dp[i][i+j][r] = max(dp[i][i+j][r], dp[i+1][i+j-1][r]+2);\n                if(r) dp[i][i+j][r] = max(dp[i][i+j][r], dp[i+1][i+j-1][r-1]+2);\n            }\n        }\n    }\n    int ans = dp[1][n][k];\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, k, ans;\nchar s[305];\nint dp[305][305][305];\nint dfs(int l, int r, int x) {\n    if(l >= r) {\n        return r - l + 1;\n    }\n    if(dp[l][r][x] != -1) {\n        return dp[l][r][x];\n    }\n    int ret = max(dfs(l + 1, r, x), dfs(l, r - 1, x));\n    if(s[l] == s[r]) {\n        ret = max(ret, dfs(l + 1, r - 1, x) + 2);\n    } else if(x) {\n        ret = max(ret, dfs(l + 1, r - 1, x - 1) + 2);\n    }\n    return dp[l][r][x] = ret;\n}\nint main() {\n    memset(dp, -1, sizeof(dp));\n    scanf(\"%s%d\", s + 1, &k);\n    n = strlen(s + 1);\n    for(int i = 1; i <= n; ++i) {\n        for(int j = i; j <= n; ++j) {\n            ans = max(ans, dfs(i, j, k));\n        }\n    } \n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "Bash",
    "code": "/*\ndp[i][j][k] 前i个字符和后j个字符最多修改k个字符的最大长度\n\ndp[i][j][k] = max(\n                  dp[i-1][j][k],\n                  dp[i][j-1][k],\n                  if s[i] == s[n-1-j] : dp[i-1][j-1][k]+1\n                  else : dp[i-1][j-1][k-1] + 1)\n\nabcabcabc\ncbacbacba\n\n\n*/\n\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\nint n,m;\nchar s[305];\nint dp[305][305][305];\n\nint main(){\n    int i,j,k;\n    while(~scanf(\"%s%d\",s,&m)){\n        n = strlen(s);\n        dp[0][0][0] = s[0]==s[n-1]? 1 : 0;\n        for(i = 1;i <= m;i++){\n            dp[0][0][i] = 1;\n        }\n        for(i = 0;i < n;i++){\n            for(j = 0;j < n;j++){\n                if(i+j==0) continue;\n                for(k = 0;k <= m;k++){\n                    dp[i][j][k] = max(i>0?dp[i-1][j][k]:-1,j>0?dp[i][j-1][k]:-1);\n                    if(i > 0 && j > 0)\n                    if(s[i] == s[n-1-j]){\n                        dp[i][j][k] = max(dp[i][j][k],dp[i-1][j-1][k]+1);\n                    }else{\n                        dp[i][j][k]= max(dp[i][j][k],dp[i-1][j-1][k-1]+1);\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\",dp[n-1][n-1][m]+m);\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint dp[301][301][301];\nint main()\n{\n\tstring str;\n\tint q;\n\tcin>>str>>q;\n\tint l=str.size();\n//\tcout<<l<<endl;\n\tfor(int i=l-1;i>=0;i--)\n\t{\n\t\tfor(int k=0;k<=q;k++)\n\t\t\tdp[i][i][k]=1;\n\t}\n\tfor(int i=l-1;i>=0;i--)\n\t{\n\t\t\n\t\tfor(int j=i+1;j<=l-1;j++)\n\t\t{\n\t\t\tfor(int k=0;k<=q;k++)\n\t\t\t{\n\t\t\t\t//dp[i][i][k]=1; \n\t\t\t\tif(str[i]==str[j]) dp[i][j][k]=dp[i+1][j-1][k]+2;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(k!=0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i][j][k]=max(dp[i+1][j][k-1]+2,dp[i][j-1][k-1]+2);\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j][k]=max(dp[i+1][j][k],dp[i][j][k]);\n\t\t\t\t\tdp[i][j][k]=max(dp[i][j-1][k],dp[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[0][l-1][q]<<endl;\n } "
  },
  {
    "language": "Bash",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar s[305],c[305];\nint k;\nint f[305][305][305];\nint mymax(int a,int b,int c)\n{\n\treturn max(max(a,b),c);\n}\nint main() {\n\tscanf(\"%s\",s);\n\tscanf(\"%d\",&k);\n\tint n = strlen(s);\n\tfor (int i=0;i<n/2;i++)\n\t\tc[i]=s[n-i-1];\n\tf[0][0][0]=0;\n\tfor(int i=1; i<=n/2; i++) {\n\t\tfor(int j=1; j<=n/2; j++) {\n\t\t\tif(s[i-1]==c[j-1])\n\t\t\t\tf[i][j][0] = f[i-1][j-1][0] + 1;\n\t\t\telse\n\t\t\t\tf[i][j][0] = max(f[i-1][j][0], f[i][j-1][0]);\n\t\t}\n\t}\n\tfor(int m=1; m<=k; m++) {\n\t\tfor(int i=1; i<=n/2; i++) {\n\t\t\tfor(int j=1; j<=n/2; j++) {\n\t\t\t\tif(s[i-1]==c[j-1])\n\t\t\t\t\tf[i][j][m] = max(f[i-1][j-1][m],f[i-1][j-1][m-1])+1;\n\t\t\t\telse\n\t\t\t\t\tf[i][j][m] = mymax(f[i-1][j-1][m-1]+1, f[i][j-1][m], f[i-1][j][m]);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = f[n/2][n/2][k]*2;\n\tif(n%2)\tans+=1;\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "Python",
    "code": "import sys\n\nreadline = sys.stdin.buffer.readline\n\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\n\ns = ns()\nls = len(s)\nlk = ni()\ndp = [[[0]*(lk+1) for _ in range(ls)] for i in range(ls)]\nfor i in range(ls):\n  dp[i][i][0] = 1\nfor k in range(lk+1):\n  for dis in range(1, ls):\n    for i in range(ls - dis):\n      j = i + dis\n      if s[i] == s[j]:\n        dp[i][j][k] = dp[i+1][j-1][k] + 2\n      elif k:\n        dp[i][j][k] = dp[i+1][j-1][k-1] + 2\n      dp[i][j][k] = max(dp[i][j][k], dp[i+1][j][k], dp[i][j-1][k])\n      \nprint(max(dp[0][ls-1]))\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nreadline = sys.stdin.buffer.readline\n\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\n\ndef solve():\n  s = list(ns())\n  ls = len(s)\n  lk = ni()\n  if lk * 2 >= ls:\n    print(ls)\n    return\n  dp = [[[0]*ls for _ in range(ls)] for i in range(2)]\n  ans = 0\n  for i in range(ls):\n    dp[0][i][i] = 1\n  for k in range(lk+1):\n    v = k & 1\n    for dis in range(1, ls):\n      for i in range(ls - dis):\n        j = i + dis\n        dp[v][i][j] = 0\n        if s[i] == s[j]:\n          dp[v][i][j] = dp[v][i+1][j-1] + 2\n        elif k:\n          dp[v][i][j] = dp[v^1][i+1][j-1] + 2\n        dp[v][i][j] = max(dp[v][i][j], dp[v][i+1][j], dp[v][i][j-1])\n    ans = max(ans, dp[v][0][-1])\n\n  print(ans)\n  return\n\nsolve()"
  },
  {
    "language": "Python",
    "code": "def main():\n    s = input()\n    n = len(s)\n    k = int(input())\n    # dp[左端][左端からの右端の距離][使った回数]\n    dp = [[[1]*(k+1) for _ in [0]*(n-i)] for i in range(n)]\n\n    for i in range(n-1):\n        if s[i] == s[i+1]:\n            dp[i][1][0] = 2\n    if k > 0:\n        for cnt in range(1, k+1):\n            for i in range(n-1):\n                dp[i][1][cnt] = 2\n\n    for cnt in range(k):\n        for d in range(2, n):\n            for left in range(n-d):\n                right = left+d\n                plus = (s[left] == s[right])*2\n                dp[left][d][cnt] = max(\n                    dp[left][d][cnt], dp[left][d-1][cnt],\n                    dp[left+1][d-1][cnt], dp[left+1][d-2][cnt]+plus)\n                dp[left][d][cnt+1] = max(\n                    max(dp[left][d][cnt:cnt+2]), dp[left+1][d-2][cnt]+2)\n    for d in range(2, n):\n        for left in range(n-d):\n            right = left+d\n            plus = (s[left] == s[right])*2\n            dp[left][d][k] = max(\n                dp[left][d][k], dp[left][d-1][k], dp[left+1][d-1][k], dp[left+1][d-2][k]+plus)\n    print(dp[0][-1][-1])\n\n\nmain()"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\n\nhttps://atcoder.jp/contests/agc021/tasks/agc021_d\n\nある部分でcutしたとする。\n前半と後半のLCSを求めたとすると、交差した後のLCSの長さも同じ\n→左からindex iまでと右からindex jまでのLCSを求めればいい (i < j)\nあとは、普通のLCSと同様のdpでいける\n\ndp[i][j][k] = 左からi番目の文字までと、右からindex jの文字までのk回替えた際のLCS長さ\nあとは2倍すれば大体行ける？\ni+1 == jでは、2倍すればおk\ni+1 < j では、真ん中の文字を使えるので、2倍して1足す\n\n\"\"\"\n\nS = input()\nS = \" \"+S\nK = int(input())\nN = len(S)-1\n\ndp = [[[0] * (K+1) for i in range(N+2)] for j in range(N+2)]\nans = 0\n\nfor i in range(1,N+1):\n\n    for j in range(N,i,-1):\n\n        for k in range(K+1):\n\n            #同じ場合、どっちも進める\n            if S[i] == S[j]:\n                dp[i][j][k] = max( dp[i][j][k] , dp[i-1][j+1][k] + 1)\n            else:\n                dp[i][j][k] = max( dp[i][j][k] , dp[i-1][j][k] , dp[i][j+1][k] )\n                if k != 0:\n                    dp[i][j][k] = max(dp[i][j][k] , dp[i-1][j+1][k-1] + 1)\n\n            if i+1 == j:\n                ans = max(ans , dp[i][j][k] * 2)\n            else:\n                ans = max(ans , dp[i][j][k] * 2 + 1)\n\nprint (ans)\n                \n"
  },
  {
    "language": "Python",
    "code": "def examA():\n    N = I()\n    ans = 0\n    print(ans)\n    return\n\n# 参考 https://atcoder.jp/contests/agc021/submissions/8392122\ndef examB():\n    def norm2(vec):\n        return math.sqrt(vec[0] ** 2 + vec[1] ** 2)\n    # any 2 points must have different position.\n    def ConvexHull(point_list):\n        pos2idx = {point_list[i]: i for i in range(len(point_list))}\n        y_val = defaultdict(list)\n        x_list = sorted(list(set([p[0] for p in point_list])))\n        for x, y in point_list:\n            y_val[x].append(y)\n\n        upper = [(x_list[0], max(y_val[x_list[0]]))]\n        lower = [(x_list[0], min(y_val[x_list[0]]))]\n        prev = float('inf')\n        for xi in x_list[1:]:\n            x0, y0 = upper[-1]\n            x1, y1 = xi, max(y_val[xi])\n            if (y1 - y0) / (x1 - x0) < prev:\n                upper.append((x1, y1))\n                prev = (y1 - y0) / (x1 - x0)\n            else:\n                while True:\n                    x0, y0 = upper[-1]\n                    if len(upper) == 1:\n                        upper.append((x1, y1))\n                        break\n                    x00, y00 = upper[-2]\n                    if (y1 - y0) / (x1 - x0) > (y1 - y00) / (x1 - x00):\n                        upper.pop()\n                    else:\n                        prev = (y1 - y0) / (x1 - x0)\n                        upper.append((x1, y1))\n                        break\n\n        prev = -float('inf')\n        for xi in x_list[1:]:\n            x0, y0 = lower[-1]\n            x1, y1 = xi, min(y_val[xi])\n            if (y1 - y0) / (x1 - x0) > prev:\n                lower.append((x1, y1))\n                prev = (y1 - y0) / (x1 - x0)\n            else:\n                while True:\n                    x0, y0 = lower[-1]\n                    if len(lower) == 1:\n                        lower.append((x1, y1))\n                        break\n                    x00, y00 = lower[-2]\n                    if (y1 - y0) / (x1 - x0) < (y1 - y00) / (x1 - x00):\n                        lower.pop()\n                    else:\n                        prev = (y1 - y0) / (x1 - x0)\n                        lower.append((x1, y1))\n                        break\n\n        # return upper, lower\n        # return [pos2idx[xy] for xy in upper], [pos2idx[xy] for xy in lower]\n\n        upper_idx, lower_idx = [pos2idx[xy] for xy in upper], [pos2idx[xy] for xy in lower]\n        if upper_idx[-1] == lower_idx[-1]:\n            upper_idx.pop()\n        CH_idx = upper_idx\n        CH_idx.extend(reversed(lower_idx))\n        if CH_idx[0] == CH_idx[-1] and len(CH_idx) > 1:\n            CH_idx.pop()\n        return CH_idx\n\n    N = I()\n    P = [[]for _ in range(N)]\n    D = defaultdict(int)\n    for i in range(N):\n        x,y = LI()\n        P[i] = (x,y)\n        D[(x,y)] = i\n    C = ConvexHull(P)\n    ans = [0]*N\n    if len(C)==2:\n        for c in C:\n            ans[c] = 0.5\n        for v in ans:\n            print(v)\n        return\n    #print(C)\n    for i,c in enumerate(C):\n        s, t, u = C[i - 1], C[i], C[(i + 1) % len(C)]\n        x0, y0 = P[s]\n        x1, y1 = P[t]\n        x2, y2 = P[u]\n        vec0 = (y0 - y1, x1 - x0)\n        vec1 = (y1 - y2, x2 - x1)\n        ans[t] =  math.acos((vec0[0] * vec1[0] + vec0[1] * vec1[1]) / (norm2(vec0) * norm2(vec1))) / (2 * math.pi)\n    for v in ans:\n        print(v)\n    return\n\ndef examC():\n    ans = 0\n    print(ans)\n    return\n\ndef examD():\n    S = SI()\n    N = len(S)\n    K = I()\n    dp = [[[0 for _ in range(K+1)]for _ in range(N)]for _ in range(N)]\n    for i in range(N):\n        for j in range(K+1):\n            dp[i][i][j] = 1\n    for i in range(2,N+1):\n        for k in range(K+1):\n            for l,r in enumerate(range(i-1,N)):\n                if S[l]==S[r]:\n                    dp[l][r][k] = dp[l+1][r-1][k] + 2\n                else:\n                    if k>0:\n                        dp[l][r][k] = max(dp[l+1][r][k],dp[l][r-1][k],dp[l+1][r-1][k-1]+2)\n                    else:\n                        dp[l][r][k] = max(dp[l + 1][r][k], dp[l][r - 1][k])\n    ans = max(dp[0][-1])\n    print(ans)\n    return\n\ndef examE():\n    ans = 0\n    print(ans)\n    return\n\ndef examF():\n    ans = 0\n    print(ans)\n    return\n\nfrom decimal import Decimal as dec\nimport sys\nfrom collections import Counter,defaultdict,deque\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\ndef I(): return int(input())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\ndef DI(): return dec(input())\ndef LDI(): return list(map(dec,sys.stdin.readline().split()))\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef SI(): return sys.stdin.readline().strip()\nglobal mod,mod2,inf,alphabet,_ep\nmod = 10**9 + 7\nmod2 = 998244353\ninf = 10**18\n_ep = 10**(-12)\nalphabet = [chr(ord('a') + i) for i in range(26)]\n\nsys.setrecursionlimit(10**7)\n\nif __name__ == '__main__':\n    examD()\n\n\"\"\"\n142\n12 9 1445 0 1\nasd dfg hj o o\naidn\n\"\"\""
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\n\nhttps://atcoder.jp/contests/agc021/tasks/agc021_d\n\nある部分でcutしたとする。\n前半と後半のLCSを求めたとすると、交差した後のLCSの長さも同じ\n→左からindex iまでと右からindex jまでのLCSを求めればいい (i < j)\nあとは、普通のLCSと同様のdpでいける\n\ndp[i][j][k] = 左からi番目の文字までと、右からindex jの文字までのk回替えた際のLCS長さ\nあとは2倍すれば大体行ける？\ni+1 == jでは、2倍すればおk\ni+1 < j では、真ん中の文字を使えるので、2倍して1足す\n\n\"\"\"\n\nS = input()\nS = \" \"+S\nK = int(input())\nN = len(S)-1\n\ndp = [[[0] * (K+1) for i in range(N+2)] for j in range(N+2)]\nans = 0\n\nfor i in range(1,N+1):\n\n    for j in range(N,i,-1):\n\n        for k in range(K+1):\n\n            #同じ場合、どっちも進める\n            if S[i] == S[j]:\n                dp[i][j][k] = max( dp[i][j][k] , dp[i-1][j+1][k] + 1)\n            else:\n                dp[i][j][k] = max( dp[i][j][k] , dp[i-1][j][k] , dp[i][j+1][k] )\n                if k != 0:\n                    dp[i][j][k] = max(dp[i][j][k] , dp[i-1][j+1][k-1] + 1)\n\n            if i+1 == j:\n                ans = max(ans , dp[i][j][k] * 2)\n            else:\n                ans = max(ans , dp[i][j][k] * 2 + 1)\n\nprint (ans)\n                \n"
  },
  {
    "language": "Python",
    "code": "def solve(s, k):\n    n = len(s)\n    pdp = [[0] * (k + 1) for _ in range(n + 1)]\n    for l in range(n - 1, -1, -1):\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for r in range(l, n):\n            dpr, dpr1 = dp[r], pdp[r - 1]\n            inc = 1 if l == r else 2\n            is_same = s[l] == s[r]\n            for p in range(k + 1):\n                if is_same:\n                    dpr[p] = dpr1[p] + inc\n                else:\n                    if p:\n                        dpr[p] = max(pdp[r][p], dp[r - 1][p], dpr1[p - 1] + inc)\n                    else:\n                        dpr[p] = max(pdp[r][p], dp[r - 1][p])\n        pdp = dp\n\n    return pdp[-2][k]\n\n\nprint(solve(input(), int(input())))\n"
  },
  {
    "language": "Python",
    "code": "s = list(map(ord, list(input())))\nls = len(s)\nlk = int(input())\nif lk*2 >= ls: print(ls); exit(0)\nlk *= 2\ndp = [[[0]*(lk+1) for _ in range(ls+1)] for i in range(ls+1)]\nfor k in range(lk+1):\n  for i in range(ls):\n    for j in range(ls):\n      if s[i] == s[-j-1]:\n        dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + 1)\n      else:\n        dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i+1][j][k], dp[i][j+1][k], (k > 0)*(dp[i][j][k-1] + 1))\nprint(max(dp[ls][ls]))"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\n\"\"\"\n・reversed LCS = 最大長の回文\n・(長さ、始点、変更コスト) -> opt value\n\"\"\"\n\nS = np.frombuffer(readline().rstrip(),'S1')\nN = len(S)\nK = int(readline())\n\ndp = [None] * (N+1) # 長さ -> array\ndp[0] = None # 自身ないので使わない\ndp[1] = np.zeros((N,K+10),np.int32); dp[1][:,0] = 1\nif N >= 2:\n    dp[2] = np.zeros((N-1,K+10),np.int32)\n    dp[2][:,0] = 1+(S[:-1]==S[1:])\n    dp[2][:,1] = 2\n\nfor n in range(3,N+1):\n    arr = np.zeros((N-n+1,K+10),np.int32)\n    # 両端をマッチしない場合\n    np.maximum(arr,dp[n-1][:-1],out=arr)\n    np.maximum(arr,dp[n-1][1:],out=arr)\n    # 両端をコストなしでマッチさせる場合\n    match = (S[:-n+1]==S[n-1:])\n    np.maximum(arr,match[:,None]*(dp[n-2][1:-1]+2),out=arr)\n    # 両端をコストありでマッチさせる場合\n    np.maximum(arr[:,1:],dp[n-2][1:-1,:-1]+2,out=arr[:,1:])\n    \n    dp[n] = arr\n\nanswer = dp[-1][0][:K+1].max()\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "#coding:utf-8\ndef check(s, t):\n    count = 0\n    v = 0\n    for i in range(len(s)):\n        if s[i] in t[i]:\n            count += 1\n        else:\n            if count > v:\n                v = count\n            count = 0\n    return v\n    \ns = list(input())\nk = int(input())\nt = []\ntg = []\npat = [0]*len(s)\nfor i in s[::-1]:\n    t.append(i)\n    tg.append(i)\n\nfor i in range(k):\n    v = check(s, t)\n    c = 0\n    for j in range(len(s)):\n        t[j] = s[j]\n        if v < check(s, t):\n            ind = j\n        t[j] = tg[j]\n    tg[ind] = s[ind]\n\nprint(check(s, tg))\n"
  },
  {
    "language": "Python",
    "code": "# coding=utf-8\n\ndef lcs(s1,s2):\n    table = []\n    for _ in range(100):\n        table.append([0 for _ in range(100)])\n\n    for y in range(1,len(s1)+1):\n        for x in range(1,len(s2)+1):\n            match = 0\n            if s1[y-1]==s2[x-1]:\n                match = 1\n\n            v1 = table[y-1][x-1]+match\n            v2 = table[y-1][x]\n            v3 = table[y][x-1]\n            table[y][x] = max(v1,v2,v3)\n    return table[len(s1)][len(s2)]\n\ndef log(s,s2):\n    return\n    print(\"---\")\n    print(\"s :\"+\"\".join(s))\n    print(\"s2:\"+\"\".join(s2))\n\ns = list(input())\nk = int(input())\ns2 = s[::-1]\nlog(s,s2)\n\nab = set(s)\n\nfor i in range(k):\n    idx = -1\n    char = \"\"\n    r = -1\n    for j in range(len(s)):\n        for x in ab:\n            t = s[:]\n            t[j] = x\n            t2 = t[::-1]\n            if lcs(t,t2)>r:\n                r = lcs(t,t2)\n                idx = j\n                char = x\n\n    s[idx] = char\n    s2 = s[::-1]\n    log(s,s2)\n\n\nprint(lcs(s,s2))\n"
  },
  {
    "language": "Python",
    "code": "s = input()\nK = int(input())\nn = len(s)\nt = s[::-1]\ndp = [[[0 for i in range(K+1)] for j in range(n+1)] for k in range(n+1)]\nansls = min(2*K+1,n)\nfor center in range(1,n-1):\n  flg = 0\n  sf = s[:center]\n  sl = t[:n-center-1]\n  if s[center] == s[center+1]:\n    flg = 1\n  sfl = len(sf)\n  sll = len(sl)\n  for j in range(1,sll+1):\n    dp[sfl][j][0] = max(dp[sfl-1][j][0],dp[sfl][j-1][0])\n    if sf[-1] != sl[j-1]:\n      for k in range(1,min(K,sll)+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n    if sf[-1] == sl[j-1]:\n      dp[sfl][j][0] = max(dp[sfl][j][0],dp[sfl-1][j-1][0]+1)\n      for k in range(1,min(K,sll)+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j-1][k]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n  ans= max(dp[sfl][sll][min(K,sll)]*2+1,dp[sfl][sll-1][min(K,sll)]*2+1+flg,ans)\nprint(max(ansls))"
  },
  {
    "language": "Python",
    "code": "def lcs(s1, s2):\n    dp = []\n    for s2_k in s2:\n        bgn_idx = 0\n        for i, cur_idx in enumerate(dp):\n            chr_idx = s1.find(s2_k, bgn_idx) + 1\n            if not chr_idx:\n                break\n            dp[i] = min(cur_idx, chr_idx)\n            bgn_idx = cur_idx\n        else:\n            chr_idx = s1.find(s2_k, bgn_idx) + 1\n            if chr_idx:\n                dp.append(chr_idx)\n    return len(dp)\n\nS = raw_input()\nK = int(raw_input())\n\nrevstr = S[::-1]\n\ncharset = set(S)\n\ndef replace_calclcs(i, candstrlist):\n    newcand = candstrlist[:]\n    for candstr, maxlcs in candstrlist:\n        for char in charset:\n            newrevstr = candstr[:i] + char + candstr[i+1:]\n            newlcs = lcs(S, newrevstr)\n            if(newlcs > maxlcs):\n                newcand.append([newrevstr, newlcs])\n    return newcand\n\ncands = [[revstr, lcs(S, revstr)]]\nfor i in range(len(revstr)):\n    cands = replace_calclcs(i, cands)\n\nprint(max(map(lambda x: x[1], cands)))\n"
  },
  {
    "language": "Python",
    "code": "# coding=utf-8\n\ndef lcs(s1,s2):\n    table = []\n    for _ in range(110):\n        table.append([0 for _ in range(110)])\n\n    for y in range(1,len(s1)+1):\n        for x in range(1,len(s2)+1):\n            match = 0\n            if s1[y-1]==s2[x-1]:\n                match = 1\n\n            v1 = table[y-1][x-1]+match\n            v2 = table[y-1][x]\n            v3 = table[y][x-1]\n            table[y][x] = max(v1,v2,v3)\n    return table[len(s1)][len(s2)]\n\ndef log(s,s2):\n    return\n    print(\"---\")\n    print(\"s :\"+\"\".join(s))\n    print(\"s2:\"+\"\".join(s2))\n\ns = list(input())\nk = int(input())\ns2 = s[::-1]\nlog(s,s2)\n\nab = set(s)\n\nfor i in range(k):\n    idx = -1\n    char = \"\"\n    r = -1\n    for j in range(len(s)):\n        for x in ab:\n            t = s[:]\n            t[j] = x\n            t2 = t[::-1]\n            if lcs(t,t2)>r:\n                r = lcs(t,t2)\n                idx = j\n                char = x\n\n    s[idx] = char\n    s2 = s[::-1]\n    log(s,s2)\n\n\nprint(lcs(s,s2))\n"
  },
  {
    "language": "Python",
    "code": "s = input()\nK = int(input())\nn = len(s)\nt = s[::-1]\nif 2*K+1 >= n:\n  print(n)\n  exit()\ndp = [[[0 for i in range(K+1)] for j in range(n+1)] for k in range(n+1)]\n\nans = min(2*K+1,n)\nfor center in range(1,n-1):\n  flg = 0\n  sf = s[:center]\n  sl = t[:n-center-1]\n  if s[center] == s[center+1]:\n    flg = 1\n  sfl = len(sf)\n  sll = len(sl)\n  for j in range(1,sll+1):\n    dp[sfl][j][0] = max(dp[sfl-1][j][0],dp[sfl][j-1][0])\n    if sf[-1] != sl[j-1]:\n      for k in range(1,min(K,sll)+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n    if sf[-1] == sl[j-1]:\n      dp[sfl][j][0] = max(dp[sfl][j][0],dp[sfl-1][j-1][0]+1)\n      for k in range(1,min(K,sll)+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j-1][k]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n  ans= max(dp[sfl][sll][min(K,sll)]*2+1,dp[sfl][sll-1][min(K,sll)]*2+1+flg,ans)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\ns = input()\nK = int(input())\nn = len(s)\ndp = [[[0]*(K+1) for _ in range(n+1)] for _ in range(n+1)]\nfor i in range(n):\n    for j in range(K+1):\n        dp[i][i+1][j] = 1\nfor l in range(2, n+1):\n    for i in range(n-l+1):\n        for k in range(K+1):\n#             print(l, i, i+l, j)\n            if s[i]==s[i+l-1]:\n                dp[i][i+l][k] = dp[i+1][i+l-1][k] + 2\n            else:\n                dp[i][i+l][k] = max(dp[i+1][i+l][k], dp[i][i+l-1][k])\n                if k>=1:\n                    dp[i][i+l][k] = max(dp[i][i+l][k], dp[i+1][i+l-1][k-1]+2)\nans = max(dp[0][n][j] for j in range(K+1))\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\ns = input()\nn = len(s)\nK = int(input())\n\ndp = [[[0 for _ in range(K+1)] for _ in range(n)] for _ in range(n)]\nfor i in range(n):\n\tdp[i][i][0] = 1\n\tif i < n-1:\n\t\tdp[i][i+1][0] = 2\n\nfor k in range(K+1):\n\tfor x in range(1, n):\n\t\tfor i in range(n-x):\n\t\t\tj = i+x\n\t\t\tdp[i][j][k] = max(dp[i][j][k-1], dp[i+1][j][k], dp[i][j-1][k])\n\t\t\tif s[i] == s[j] and x > 1:\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i+1][j-1][k] + 2)\n\t\t\telif k > 0:\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i+1][j-1][k-1] + 2)\n\nprint(dp[0][n-1][K])"
  },
  {
    "language": "Python",
    "code": "def main():\n    s = input()\n    n = len(s)\n    k = int(input())\n    # dp[使った回数][左端からの距離][左端]\n    dp = [[[1]*(n-i) for i in range(n)] for _ in range(k+1)]\n\n    for i in range(n-1):\n        if s[i] == s[i+1]:\n            dp[0][1][i] = 2\n    if k > 0:\n        for cnt in range(1, k+1):\n            for i in range(n-1):\n                dp[cnt][1][i] = 2\n\n    for cnt in range(k):\n        for d in range(2, n):\n            for left in range(n-d):\n                right = left+d\n                plus = (s[left] == s[right])*2\n                dp[cnt][d][left] = max(\n                    dp[cnt][d][left], dp[cnt][d-1][left],\n                    dp[cnt][d-1][left+1], dp[cnt][d-2][left+1]+plus)\n                dp[cnt+1][d][left] = max(\n                    dp[cnt+1][d][left], dp[cnt][d][left], dp[cnt][d-2][left+1]+2)\n    for d in range(2, n):\n        for left in range(n-d):\n            right = left+d\n            plus = (s[left] == s[right])*2\n            dp[k][d][left] = max(\n                dp[k][d][left], dp[k][d-1][left], dp[k][d-1][left+1], dp[k][d-2][left+1]+plus)\n    print(dp[-1][-1][0])\n\n\nmain()"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nS=raw_input()\nL=len(S)\nK=input()\n\ndp = defaultdict(lambda: 0)\n\nfor i in range(L):\n\tfor j in range(K+1):\n\t\tdp[(i,i,j)]=1\n\nfor i in range(1,L):\t\t\t#i:width\n\tfor j in range(1,L-i+1):\t#j:start point\n\t\tl=j\n\t\tr=j+i\n\t\tfor k in range(K+1):\n\t\t\tdp[(l,r,k)] = max(dp[(l+1,r,k)], dp[(l,r-1,k)]);\n\t\t\tif(S[l-1] == S[r-1]):\n\t\t\t\tdp[(l,r,k)] = max(dp[(l,r,k)], dp[(l+1,r-1,k)] + 2);\n\t\t\telse:\n\t\t\t\tif(k):\n\t\t\t\t\tdp[(l,r,k)] = max(dp[(l,r,k)], dp[(l+1,r-1,k-1)] + 2);\n\nprint dp[(1,L,K)]"
  },
  {
    "language": "Python",
    "code": "s = input()\nK = int(input())\nn = len(s)\nt = s[::-1]\ndp = [[[0 for i in range(K+1)] for j in range(n+1)] for k in range(n+1)]\nans = min(2*K+1,n)\nfor center in range(1,n-1):\n  flg = 0\n  sf = s[:center]\n  sl = t[:n-center-1]\n  if s[center] == s[center+1]:\n    flg = 1\n  sfl = len(sf)\n  sll = len(sl)\n  for j in range(1,sll+1):\n    dp[sfl][j][0] = max(dp[sfl-1][j][0],dp[sfl][j-1][0])\n    if sf[-1] != sl[j-1]:\n      for k in range(1,min(K,sll)+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n    if sf[-1] == sl[j-1]:\n      dp[sfl][j][0] = max(dp[sfl][j][0],dp[sfl-1][j-1][0]+1)\n      for k in range(1,min(K,sll)+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j-1][k]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n  ans= max(dp[sfl][sll][min(K,sll)]*2+1,dp[sfl][sll-1][min(K,sll)]*2+1+flg,ans)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.buffer.readline\n\nS = list(input().rstrip())\nK = int(input())\n\nL = len(S)\n\ndef main():\n    dp = [[[0]*(K+1) for _ in range(L+1)] for _ in range(L+1)]\n\n    ans = 0\n    for ind in reversed(range(L)):\n        # [0, ind), [ind, L-1]\n        s = S[ind]\n        for i in range(ind):\n            for k in reversed(range(K+1)):\n                if S[i] == s:\n                    dp[i+1][L-ind][k] = dp[i][L-ind-1][k] + 1\n                else:\n                    dp[i+1][L-ind][k] = max(dp[i][L-ind][k], dp[i+1][L-ind-1][k])\n                    dp[i+1][L-ind][k] = min(dp[i+1][L-ind][k], min(i+1, L-ind))\n                    if k < K:\n                        dp[i+1][L-ind][k+1] = max(dp[i+1][L-ind][k+1], dp[i+1][L-ind][k]+1)\n                        dp[i+1][L-ind][k+1] = min(dp[i+1][L-ind][k+1], min(i+1, L-ind))\n        for k in range(K+1):\n            ans = max(ans, 2*dp[ind][L-ind][k])\n            ans = max(ans, 2*dp[ind][L-ind-1][k] + 1)\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\ns = input()\nK = int(input())\nn = len(s)\ndp = [[[0]*(K+1) for _ in range(n+2-i)] for i in range(n+1)]\nfor i in range(n):\n    for j in range(K+1):\n        dp[i][1][j] = 1\nfor l in range(2, n+1):\n    for i in range(n-l+1):\n        for k in range(K+1):\n#             print(l, i, i+l, j)\n            if s[i]==s[i+l-1]:\n                dp[i][l][k] = dp[i+1][l-1][k] + 2\n            else:\n#                 print(i,l,k)\n                dp[i][l][k] = max(dp[i+1][l][k], dp[i][l-1][k])\n                if k>=1:\n                    dp[i][l][k] = max(dp[i][l][k], dp[i+1][l-1][k-1]+2)\nans = max(dp[0][n][j] for j in range(K+1))\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "S = input()\nK = int(input())\nN = len(S)\n\n# MLE対策\nif K * 2 >= N-1:\n    print(N)\n    exit()\n\ndp = [[[0 for _ in range(K+1)] for _ in range(N)] for _ in range(N)]\nfor i in range(N):\n    for k in range(K+1):\n        dp[i][i][k] = 1\n\nfor _j in range(1, N):\n    for i in range(N):\n        j = i + _j\n        if j < N:\n            for k in range(K+1):\n                dp[i][j][k] = max(dp[i][j][k], dp[i+1][j][k], dp[i][j-1][k])\n                if _j == 1:\n                    if S[i] == S[j]:\n                        dp[i][j][k] = 2\n                    else:\n                        if k+1 <= K:\n                            dp[i][j][k+1] = 2\n                else:\n                    if S[i] == S[j]:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i+1][j-1][k] + 2)\n                    else:\n                        if k+1 <= K:\n                            dp[i][j][k+1] = max(dp[i][j][k], dp[i+1][j-1][k] + 2)\n\nprint(max(dp[0][N-1]))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nreadline = sys.stdin.buffer.readline\n\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\n\ns = list(ns())\nls = len(s)\nlk = ni()\ndp = [[[0]*(lk+1) for _ in range(ls)] for i in range(ls)]\nfor i in range(ls):\n  dp[i][i][0] = 1\nfor k in range(lk+1):\n  for dis in range(1, ls):\n    for i in range(ls - dis):\n      j = i + dis\n      if s[i] == s[j]:\n        dp[i][j][k] = dp[i+1][j-1][k] + 2\n      elif k:\n        dp[i][j][k] = dp[i+1][j-1][k-1] + 2\n      dp[i][j][k] = max(dp[i][j][k], dp[i+1][j][k], dp[i][j-1][k])\n      \nprint(max(dp[0][ls-1]))\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\n\ndef LCS_words(X,Y):\n    X,Y=\" \"+X,\" \"+Y\n    m,n=len(X),len(Y)\n    MAP=[[0 for i in range(m)] for j in range(n)]\n    for i in range(1,n):\n        for j in range(1,m):\n            if Y[i]==X[j]:\n                MAP[i][j]=MAP[i-1][j-1]+1\n            else:\n                MAP[i][j]=max(MAP[i][j-1],MAP[i-1][j])\n    #print(np.array(MAP))\n    return MAP[n-1][m-1]\n\n\ns=input()\nk=int(input())\nbase=LCS_words(s,s[::-1])\nreverse=s[::-1]\n\nfor i in range(len(s)//2):\n    if k==0:break\n    if [s[i],reverse[-i]]==[reverse[i],reverse[-i]]:\n        base +=2\n        k -=1\n\nprint(base+k)"
  },
  {
    "language": "Python",
    "code": "s = list(map(ord, list(input())))\nls = len(s)\nlk = int(input())\nif lk*2 >= ls: print(ls); exit(0)\nlk = 2*lk - ls%2\ndp = [[[0]*(lk+1) for _ in range(ls+1)] for i in range(ls+1)]\nfor k in range(lk+1):\n  for i in range(ls):\n    for j in range(ls):\n      if s[i] == s[-j-1]:\n        dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + 1)\n      else:\n        dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i+1][j][k], dp[i][j+1][k], (k > 0)*(dp[i][j][k-1] + 1))\nprint(max(dp[ls][ls]))"
  },
  {
    "language": "Python",
    "code": "s = list(map(ord, list(input())))\nls = len(s)\nlk = int(input())\nif lk*2 >= ls: print(ls); exit(0)\nlk *= 2\ndp = [[[0]*(lk+1) for _ in range(ls+1)] for i in range(ls+1)]\nfor k in range(lk+1):\n  for i in range(ls):\n    for j in range(ls):\n      if s[i] == s[-j-1]:\n        dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + 1)\n      else:\n        dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i+1][j][k], dp[i][j+1][k], (k > 0)*(dp[i][j][k-1] + 1))\nprint(max(dp[ls][ls]))"
  },
  {
    "language": "Python",
    "code": "s = input()\nn = len(s)\nK = int(input())\n\ndp = [[[0 for _ in range(K+1)] for _ in range(n)] for _ in range(n)]\nfor i in range(n):\n\tfor k in range(K+1):\n\t\tdp[i][i][k] = 1\n\t\tif i < n-1 and s[i] == s[i+1]:\n\t\t\tdp[i][i+1][k] = 2\n\nfor k in range(K+1):\n\tfor x in range(1, n):\n\t\tfor i in range(n-x):\n\t\t\tj = i+x\n\t\t\tdp[i][j][k] = max(dp[i][j][k-1], dp[i+1][j][k], dp[i][j-1][k])\n\t\t\tif s[i] == s[j] and x > 1:\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i+1][j-1][k] + 2)\n\t\t\telif k > 0 and x > 1:\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i+1][j-1][k-1] + 2)\n\nprint(dp[0][n-1][K])"
  },
  {
    "language": "Python",
    "code": "import sys\ns = input()\nn = len(s)\nK = int(input())\n\ndp = [[[0 for _ in range(K+1)] for _ in range(n)] for _ in range(n)]\nfor i in range(n):\n\tdp[i][i][0] = 1\n\tif i < n-1 and s[i] == s[i+1]:\n\t\tdp[i][i+1][0] = 2\n\nfor k in range(K+1):\n\tfor x in range(1, n):\n\t\tfor i in range(n-x):\n\t\t\tj = i+x\n\t\t\tdp[i][j][k] = max(dp[i][j][k-1], dp[i+1][j][k], dp[i][j-1][k])\n\t\t\tif s[i] == s[j] and x > 1:\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i+1][j-1][k] + 2)\n\t\t\telif k > 0:\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i+1][j-1][k-1] + 2)\n\nprint(dp[0][n-1][K])"
  },
  {
    "language": "Python",
    "code": "def main():\n    s = input()\n    n = len(s)\n    k = int(input())\n    # dp[左端][左端からの右端の距離][使った回数]\n    dp = [[[2]*(k+1) for _ in [0]*(n-i)] for i in range(n)]\n\n    for i in range(n):\n        for cnt in range(k+1):\n            dp[i][0][cnt] = 1\n\n    for i in range(n-1):\n        if s[i] != s[i+1]:\n            dp[i][1][0] = 1\n\n    for cnt in range(k):\n        for d in range(2, n):\n            for left in range(n-d):\n                right = left+d\n                plus = (s[left] == s[right])*2\n                dp[left][d][cnt] = max(\n                    dp[left][d][cnt], dp[left][d-1][cnt],\n                    dp[left+1][d-1][cnt], dp[left+1][d-2][cnt]+plus)\n                dp[left][d][cnt+1] = max(\n                    max(dp[left][d][cnt:cnt+2]), dp[left+1][d-2][cnt]+2)\n    for d in range(2, n):\n        for left in range(n-d):\n            right = left+d\n            plus = (s[left] == s[right])*2\n            dp[left][d][k] = max(\n                dp[left][d][k], dp[left][d-1][k], dp[left+1][d-2][k]+plus)\n    print(dp[0][-1][-1])\n\n\nmain()"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\n\ns = input()\nK = int(input())\nn = len(s)\ndp = [[[0]*(K+1) for _ in range(n+1-i+1)] for i in range(n+1)]\nfor i in range(n):\n    for j in range(K+1):\n        dp[i][1][j] = 1\nfor l in range(2, n+1):\n    for i in range(n-l+1):\n        for k in range(K+1):\n#             print(l, i, i+l, j)\n            if s[i]==s[i+l-1]:\n                dp[i][l][k] = dp[i+1][l-1][k] + 2\n            else:\n                dp[i][l][k] = max(dp[i+1][l][k], dp[i][l-1][k])\n                if k>=1:\n                    dp[i][l][k] = max(dp[i][l][k], dp[i+1][l-1][k-1]+2)\nans = max(dp[0][i][j] for i in range(n+2) for j in range(K+1))\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\ns = input()\nK = int(input())\nn = len(s)\ndp = [[[0]*(K+1) for _ in range(n+1)] for _ in range(n+1)]\nfor i in range(n):\n    for j in range(K+1):\n        dp[i][i+1][j] = 1\nfor l in range(2, n+1):\n    for i in range(n-l+1):\n        for k in range(K+1):\n#             print(l, i, i+l, j)\n            if s[i]==s[i+l-1]:\n                dp[i][i+l][k] = dp[i+1][i+l-1][k] + 2\n            else:\n                dp[i][i+l][k] = max(dp[i+1][i+l][k], dp[i][i+l-1][k])\n                if k>=1:\n                    dp[i][i+l][k] = max(dp[i][i+l][k], dp[i+1][i+l-1][k-1]+2)\nans = max(dp[0][n][j] for j in range(K+1))\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nimport math\nimport bisect\nimport random\nfrom itertools import permutations, accumulate, combinations, product\nimport sys\nimport string\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial, ceil, floor\nfrom functools import reduce\n\n\nsys.setrecursionlimit(2147483647)\nINF = 10 ** 13\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\ndef I(): return int(sys.stdin.buffer.readline())\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\nmod = 1000000007\n\n\ns = S()\nn = len(s)\nk = I()\ndp = defaultdict(lambda:1)\nfor diff in range(1, n):\n    for l in range(n):\n        for m in range(k + 1):\n            r = l + diff\n            if r >= n:\n                continue\n            if r - l == 1:\n                dp[(l, r, m)] = 2 if s[l] == s[r] or m else 1\n            elif s[l] == s[r]:\n                dp[(l, r, m)] = dp[(l + 1, r - 1, m)] + 2\n            else:\n                dp[(l, r, m)] = max(dp[(l, r, m)], dp[(l + 1, r, m)], dp[(l, r - 1, m)])\n                if m:\n                    dp[(l, r, m)] = max(dp[(l, r, m)], dp[(l + 1, r - 1, m - 1)] + 2)\n\nprint(dp[(0, n - 1, k)])\n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\n\nhttps://atcoder.jp/contests/agc021/tasks/agc021_d\n\nある部分でcutしたとする。\n前半と後半のLCSを求めたとすると、交差した後のLCSの長さも同じ\n→左からindex iまでと右からindex jまでのLCSを求めればいい (i < j)\nあとは、普通のLCSと同様のdpでいける\n\ndp[i][j][k] = 左からi番目の文字までと、右からindex jの文字までのk回替えた際のLCS長さ\nあとは2倍すれば大体行ける？\ni+1 == jでは、2倍すればおk\ni+1 < j では、真ん中の文字を使えるので、2倍して1足す\n\n\"\"\"\n\nimport sys\nS = input()\nS = \" \"+S\nK = int(input())\nN = len(S)-1\nif N == 1:\n    print (1)\n    sys.exit()\nelif N == 2:\n    if S[1] == S[2] or K > 0:\n        print (2)\n    else:\n        print (1)\n    sys.exit()\n\ndp = [[[0] * (K+1) for i in range(N+2)]]\nans = 0\n\nfor i in range(1,N+1):\n\n    dp.append( [[0] * (K+1) for i in range(N+2)] )\n\n    for j in range(N,i,-1):\n\n        for k in range(K+1):\n\n            #同じ場合、どっちも進める\n            if S[i] == S[j]:\n                dp[i][j][k] = max( dp[i][j][k] , dp[i-1][j+1][k] + 1)\n            else:\n                dp[i][j][k] = max( dp[i][j][k] , dp[i-1][j][k] , dp[i][j+1][k] )\n                if k != 0:\n                    dp[i][j][k] = max(dp[i][j][k] , dp[i-1][j+1][k-1] + 1)\n\n            if i+1 == j:\n                ans = max(ans , dp[i][j][k] * 2)\n            else:\n                ans = max(ans , dp[i][j][k] * 2 + 1)\n\n    dp[i-1] = []\n\nprint (ans)\n                \n"
  },
  {
    "language": "Python",
    "code": "def main():\n    s = input()\n    n = len(s)\n    k = int(input())\n    # dp[使った回数][左端からの距離][左端]\n    dp = [[[1]*(n-i) for i in range(n)] for _ in range(k+1)]\n\n    dp2 = dp[0][1]\n    for i in range(n-1):\n        if s[i] == s[i+1]:\n            dp2[i] = 2\n    if k > 0:\n        for cnt in range(1, k+1):\n            dp2 = dp[cnt][1]\n            for i in range(n-1):\n                dp2[i] = 2\n\n    for cnt in range(k):\n        dp2 = dp[cnt]\n        for d in range(2, n):\n            dp3 = dp2[d]\n            for left in range(n-d):\n                right = left+d\n                plus = (s[left] == s[right])*2\n                dp3[left] = max(\n                    dp3[left], dp2[d-1][left],\n                    dp2[d-1][left+1], dp2[d-2][left+1]+plus)\n                dp[cnt+1][d][left] = max(\n                    dp[cnt+1][d][left], dp3[left], dp2[d-2][left+1]+2)\n    dp2 = dp[k]\n    for d in range(2, n):\n        dp3 = dp[d]\n        for left in range(n-d):\n            right = left+d\n            plus = (s[left] == s[right])*2\n            dp3[left] = max(\n                dp3[left], dp2[d-1][left], dp2[d-1][left+1], dp2[d-2][left+1]+plus)\n    print(dp[-1][-1][0])\n\n\nmain()"
  },
  {
    "language": "Python",
    "code": "s = input()\nk = int(input())\nn = len(s)\ndp = [[[0]*(n+1) for i in range(n+1)] for j in range(n+1)]\nfor j in range(k+1):\n    for i in range(n):\n        dp[i][i+1][j] = 1\nfor j in range(2,n+1):\n  for i in range(n+1-j):\n    for l in range(k+1):\n      jj = i+j\n      if s[i] == s[jj-1]:\n        dp[i][jj][l] = dp[i+1][jj-1][l]+2\n      else:\n        dp[i][jj][l] = max(dp[i+1][jj][l],dp[i][jj-1][l])\n        if l-1>=0:\n          dp[i][jj][l] = max(dp[i][jj][l],dp[i+1][jj-1][l-1]+2)\nans = 0\nfor i in range(k+1):\n  ans = max(ans,dp[0][n][i])\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "def LCS_words(X,Y):\n    X,Y=\" \"+X,\" \"+Y\n    m,n=len(X),len(Y)\n    MAP=[[0 for i in range(m)] for j in range(n)]\n    for i in range(1,n):\n        for j in range(1,m):\n            if Y[i]==X[j]:\n                MAP[i][j]=MAP[i-1][j-1]+1\n            else:\n                MAP[i][j]=max(MAP[i][j-1],MAP[i-1][j])\n    return MAP[n-1][m-1]\n\n\ns=input()\nk=int(input())\nprint(LCS_words(s,s[::-1])+k*2)"
  },
  {
    "language": "Python",
    "code": "s = input()\nK = int(input())\nn = len(s)\nt = s[::-1]\nif 2*K+1 >= n:\n  print(n)\n  exit()\ndp = [[[0 for i in range(K+1)] for j in range(n+1)] for k in range(n+1)]\n\nans = min(2*K+1,n)\nfor center in range(1,n-1):\n  flg = 0\n  sf = s[:center]\n  sl = t[:n-center-1]\n  if s[center] == s[center+1]:\n    flg = 1\n  sfl = len(sf)\n  sll = len(sl)\n  for j in range(1,sll+1):\n    dp[sfl][j][0] = max(dp[sfl-1][j][0],dp[sfl][j-1][0])\n    if sf[-1] != sl[j-1]:\n      for k in range(1,K+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n    if sf[-1] == sl[j-1]:\n      dp[sfl][j][0] = max(dp[sfl][j][0],dp[sfl-1][j-1][0]+1)\n      for k in range(1,K+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j-1][k]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n  if flg:\n    ans= max(dp[sfl][sll][K]*2+1,dp[sfl][sll-1][min(sll-1,K)]*2+2,ans)\n  else:\n    ans= max(dp[sfl][sll][K]*2+1,dp[sfl][sll-1][min(sll-1,K-1)]*2+2,ans)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "def get_ind(l, r):\n    mod = 3\n    return OFFSET * (l % mod) + r\n\ns = input()\nn = len(s)\nk = int(input())\n\ndp = [[0] * ((n + 1) * 3) for i in range(k + 1)]\nOFFSET = n + 1\n\n# 長さ1のときの初期化\nfor i in range(n):\n    dp[0][get_ind(i, i + 1)] = 1\n\n# 長さ2~nのときのDP\nfor length in range(2, n + 1):\n    for l in range(n + 1):\n        for ki in range(k + 1):\n            r = l + length\n            if r > n:\n                break\n            if s[l] == s[r - 1]:\n                dp[ki][get_ind(l, r)] = max(2 + dp[ki][get_ind(l + 1, r - 1)], dp[ki][get_ind(l, r)])\n            else:\n                dp[ki][get_ind(l, r)] = max(dp[ki][get_ind(l + 1, r)], dp[ki][get_ind(l, r - 1)], dp[ki][get_ind(l, r)])\n                if ki - 1 >= 0:\n                    dp[ki][get_ind(l, r)] = max(dp[ki - 1][get_ind(l + 1, r - 1)] + 2, dp[ki][get_ind(l, r)])\n\nans = 0\nfor i in range(k + 1):\n    for j in range(3 * (n + 1)):\n        ans = max(ans, dp[i][j])\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "s = input()\nls = len(s)\nlk = int(input())\nif lk*2 >= ls: print(ls); exit(0)\nlk *= 2\ndp = [[[0]*(lk+1) for _ in range(ls+1)] for i in range(ls+1)]\nfor k in range(lk+1):\n  for i in range(ls):\n    for j in range(ls):\n      if s[i] == s[-j-1]:\n        dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + 1)\n      else:\n        dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i+1][j][k], dp[i][j+1][k], (k > 0)*(dp[i][j][k-1] + 1))\nprint(max(dp[ls][ls]))"
  },
  {
    "language": "Python",
    "code": "def examA():\n    N = I()\n    ans = 0\n    print(ans)\n    return\n\n# 参考 https://atcoder.jp/contests/agc021/submissions/8392122\ndef examB():\n    def norm2(vec):\n        return math.sqrt(vec[0] ** 2 + vec[1] ** 2)\n    # any 2 points must have different position.\n    def ConvexHull(point_list):\n        pos2idx = {point_list[i]: i for i in range(len(point_list))}\n        y_val = defaultdict(list)\n        x_list = sorted(list(set([p[0] for p in point_list])))\n        for x, y in point_list:\n            y_val[x].append(y)\n\n        upper = [(x_list[0], max(y_val[x_list[0]]))]\n        lower = [(x_list[0], min(y_val[x_list[0]]))]\n        prev = float('inf')\n        for xi in x_list[1:]:\n            x0, y0 = upper[-1]\n            x1, y1 = xi, max(y_val[xi])\n            if (y1 - y0) / (x1 - x0) < prev:\n                upper.append((x1, y1))\n                prev = (y1 - y0) / (x1 - x0)\n            else:\n                while True:\n                    x0, y0 = upper[-1]\n                    if len(upper) == 1:\n                        upper.append((x1, y1))\n                        break\n                    x00, y00 = upper[-2]\n                    if (y1 - y0) / (x1 - x0) > (y1 - y00) / (x1 - x00):\n                        upper.pop()\n                    else:\n                        prev = (y1 - y0) / (x1 - x0)\n                        upper.append((x1, y1))\n                        break\n\n        prev = -float('inf')\n        for xi in x_list[1:]:\n            x0, y0 = lower[-1]\n            x1, y1 = xi, min(y_val[xi])\n            if (y1 - y0) / (x1 - x0) > prev:\n                lower.append((x1, y1))\n                prev = (y1 - y0) / (x1 - x0)\n            else:\n                while True:\n                    x0, y0 = lower[-1]\n                    if len(lower) == 1:\n                        lower.append((x1, y1))\n                        break\n                    x00, y00 = lower[-2]\n                    if (y1 - y0) / (x1 - x0) < (y1 - y00) / (x1 - x00):\n                        lower.pop()\n                    else:\n                        prev = (y1 - y0) / (x1 - x0)\n                        lower.append((x1, y1))\n                        break\n\n        # return upper, lower\n        # return [pos2idx[xy] for xy in upper], [pos2idx[xy] for xy in lower]\n\n        upper_idx, lower_idx = [pos2idx[xy] for xy in upper], [pos2idx[xy] for xy in lower]\n        if upper_idx[-1] == lower_idx[-1]:\n            upper_idx.pop()\n        CH_idx = upper_idx\n        CH_idx.extend(reversed(lower_idx))\n        if CH_idx[0] == CH_idx[-1] and len(CH_idx) > 1:\n            CH_idx.pop()\n        return CH_idx\n\n    N = I()\n    P = [[]for _ in range(N)]\n    D = defaultdict(int)\n    for i in range(N):\n        x,y = LI()\n        P[i] = (x,y)\n        D[(x,y)] = i\n    C = ConvexHull(P)\n    ans = [0]*N\n    if len(C)==2:\n        for c in C:\n            ans[c] = 0.5\n        for v in ans:\n            print(v)\n        return\n    #print(C)\n    for i,c in enumerate(C):\n        s, t, u = C[i - 1], C[i], C[(i + 1) % len(C)]\n        x0, y0 = P[s]\n        x1, y1 = P[t]\n        x2, y2 = P[u]\n        vec0 = (y0 - y1, x1 - x0)\n        vec1 = (y1 - y2, x2 - x1)\n        ans[t] =  math.acos((vec0[0] * vec1[0] + vec0[1] * vec1[1]) / (norm2(vec0) * norm2(vec1))) / (2 * math.pi)\n    for v in ans:\n        print(v)\n    return\n\ndef examC():\n    ans = 0\n    print(ans)\n    return\n\ndef examD():\n    S = SI()\n    N = len(S)\n    K = I()\n    if K>100:\n        K = 100\n    dp = [[[0]*(K+1) for _ in range(N)] for i in range(N)]\n    for i in range(N):\n        for j in range(K+1):\n            dp[i][i][j] = 1\n    for i in range(2,N+1):\n        for k in range(K+1):\n            for l,r in enumerate(range(i-1,N)):\n                if S[l]==S[r]:\n                    dp[l][r][k] = dp[l+1][r-1][k] + 2\n                else:\n                    if k>0:\n                        dp[l][r][k] = max(dp[l+1][r][k],dp[l][r-1][k],dp[l+1][r-1][k-1]+2)\n                    else:\n                        dp[l][r][k] = max(dp[l + 1][r][k], dp[l][r - 1][k])\n    ans = max(dp[0][-1])\n    #print(dp)\n    print(ans)\n    return\n\ndef examE():\n    ans = 0\n    print(ans)\n    return\n\ndef examF():\n    ans = 0\n    print(ans)\n    return\n\nfrom decimal import Decimal as dec\nimport sys,bisect,itertools,heapq,math,random\nfrom copy import deepcopy\nfrom heapq import heappop,heappush,heapify\nfrom collections import Counter,defaultdict,deque\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\ndef I(): return int(input())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\ndef DI(): return dec(input())\ndef LDI(): return list(map(dec,sys.stdin.readline().split()))\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef SI(): return sys.stdin.readline().strip()\nglobal mod,mod2,inf,alphabet,_ep\nmod = 10**9 + 7\nmod2 = 998244353\ninf = 10**18\n_ep = 10**(-12)\nalphabet = [chr(ord('a') + i) for i in range(26)]\n\nsys.setrecursionlimit(10**7)\n\nif __name__ == '__main__':\n    examD()\n\n\"\"\"\n142\n12 9 1445 0 1\nasd dfg hj o o\naidn\n\"\"\""
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\nS = list(map(ord, readline().strip()))\nN = len(S)\nS = [None] + S + [None]\nK = int(readline())\n\nif N == 1:\n    ans = 1\nelif N == 2:\n    ans = 1\n    if S[1] == S[2]:\n        ans = 2\n    if K:\n        ans = 2\nelse:\n    dp1 = [[0]*(K+1) for _ in range(N+2)]\n    dp2 = [[0]*(K+1) for _ in range(N+2)]\n    for i in range(1, N+1):\n        dp1[i][0] = 1\n    for i in range(1, N):\n        dp2[i][0] = 1\n        if S[i] == S[i+1]:\n            dp2[i][0] = 2    \n        elif K:    \n            dp2[i][1] = 2\n    for s in range(3, N+1):\n        dp3 = [[0]*(K+1) for _ in range(N+2)]\n        for i in range(1, N-s+2):\n            j = i+s-1    \n            if S[i] == S[j]:\n                for k in range(K+1):\n                    dp3[i][k] = max(dp2[i+1][k], dp2[i][k], 2+dp1[i+1][k])\n            else:\n                dp3[i][0] = max(dp2[i+1][0], dp2[i][0], dp2[i+1][0])\n                for k in range(1, K+1):\n                    dp3[i][k] = max(dp2[i+1][k], dp2[i][k], dp1[i+1][k], 2+dp1[i+1][k-1])\n        '''\n        dp1 = [k[:] for k in dp2]\n        dp2 = [k[:] for k in dp3]\n        '''\n        dp1 = dp2[:]\n        dp2 = dp3[:]\n    ans = max(dp3[1][k] for k in range(K+1))\nprint(ans)\n'''\nMLEした\ndp = [[[0]*(K+1) for _ in range(N+2)] for _ in range(N+2)]\nfor i in range(1, N+1):\n    dp[i][i][0] = 1\nfor i in range(1, N):\n    dp[i][i+1][0] = 1\n    if S[i] == S[i+1]:\n        dp[i][i+1][0] = 2    \n    elif K:    \n        dp[i][i+1][1] = 2\nfor s in range(3, N+1):\n    for i in range(1, N-s+2):\n        j = i+s-1\n        if S[i] == S[j]:\n            for k in range(K+1):\n                dp[i][j][k] = max(dp[i+1][j][k], dp[i][j-1][k], 2+dp[i+1][j-1][k])\n        else:\n            dp[i][j][0] = max(dp[i+1][j][0], dp[i][j-1][0], dp[i+1][j-1][0])\n            for k in range(1, K+1):\n                dp[i][j][k] = max(dp[i+1][j][k], dp[i][j-1][k], dp[i+1][j-1][k], 2+dp[i+1][j-1][k-1], dp[i+1][j-1][k])\nprint(max(dp[1][N][k] for k in range(K+1)))\n'''   "
  },
  {
    "language": "Python",
    "code": "S=input()\nK=int(input())\nS2=S[::-1]\nl=len(S)\n\ndp=[[0 for x in range(l+1)] for y in range(l+1)]\ntrace=[[0 for x in range(l+1)] for y in range(l+1)]\nfor i in range(l+1):\n  trace[i][0]=-1\n  trace[0][i]=-1\n\nfor i in range(l):\n  for j in range(l):\n    if S[i]==S2[j]:\n      dp[i+1][j+1]=dp[i][j]+1\n      trace[i+1][j+1]=1\n    elif dp[i+1][j] > dp[i][j+1]:\n      dp[i+1][j+1]=dp[i+1][j]\n      trace[i+1][j+1]=2\n    else:\n      dp[i+1][j+1]=dp[i][j+1]\n      trace[i+1][j+1]=3\ncnt=[0 for t in range(l+1)]\ndef tracedo(trace,a,b):\n  if trace[a][b]==-1:\n    return\n  elif trace[a][b]==2:\n    tracedo(trace,a,b-1)\n  elif trace[a][b]==3:\n    tracedo(trace,a-1,b)\n  else:\n    tracedo(trace,a-1,b-1)\n    cnt[a-1]=1\n  return\n\ntracedo(trace,l,l)\nans=0\nfor i in range(l):\n  if cnt[i]==0 and cnt[l-i-1]==0:\n    ans+=1\nprint(dp[l][l]+min(ans*2,K*2))"
  },
  {
    "language": "Python",
    "code": "def examA():\n    N = I()\n    ans = 0\n    print(ans)\n    return\n\n# 参考 https://atcoder.jp/contests/agc021/submissions/8392122\ndef examB():\n    def norm2(vec):\n        return math.sqrt(vec[0] ** 2 + vec[1] ** 2)\n    # any 2 points must have different position.\n    def ConvexHull(point_list):\n        pos2idx = {point_list[i]: i for i in range(len(point_list))}\n        y_val = defaultdict(list)\n        x_list = sorted(list(set([p[0] for p in point_list])))\n        for x, y in point_list:\n            y_val[x].append(y)\n\n        upper = [(x_list[0], max(y_val[x_list[0]]))]\n        lower = [(x_list[0], min(y_val[x_list[0]]))]\n        prev = float('inf')\n        for xi in x_list[1:]:\n            x0, y0 = upper[-1]\n            x1, y1 = xi, max(y_val[xi])\n            if (y1 - y0) / (x1 - x0) < prev:\n                upper.append((x1, y1))\n                prev = (y1 - y0) / (x1 - x0)\n            else:\n                while True:\n                    x0, y0 = upper[-1]\n                    if len(upper) == 1:\n                        upper.append((x1, y1))\n                        break\n                    x00, y00 = upper[-2]\n                    if (y1 - y0) / (x1 - x0) > (y1 - y00) / (x1 - x00):\n                        upper.pop()\n                    else:\n                        prev = (y1 - y0) / (x1 - x0)\n                        upper.append((x1, y1))\n                        break\n\n        prev = -float('inf')\n        for xi in x_list[1:]:\n            x0, y0 = lower[-1]\n            x1, y1 = xi, min(y_val[xi])\n            if (y1 - y0) / (x1 - x0) > prev:\n                lower.append((x1, y1))\n                prev = (y1 - y0) / (x1 - x0)\n            else:\n                while True:\n                    x0, y0 = lower[-1]\n                    if len(lower) == 1:\n                        lower.append((x1, y1))\n                        break\n                    x00, y00 = lower[-2]\n                    if (y1 - y0) / (x1 - x0) < (y1 - y00) / (x1 - x00):\n                        lower.pop()\n                    else:\n                        prev = (y1 - y0) / (x1 - x0)\n                        lower.append((x1, y1))\n                        break\n\n        # return upper, lower\n        # return [pos2idx[xy] for xy in upper], [pos2idx[xy] for xy in lower]\n\n        upper_idx, lower_idx = [pos2idx[xy] for xy in upper], [pos2idx[xy] for xy in lower]\n        if upper_idx[-1] == lower_idx[-1]:\n            upper_idx.pop()\n        CH_idx = upper_idx\n        CH_idx.extend(reversed(lower_idx))\n        if CH_idx[0] == CH_idx[-1] and len(CH_idx) > 1:\n            CH_idx.pop()\n        return CH_idx\n\n    N = I()\n    P = [[]for _ in range(N)]\n    D = defaultdict(int)\n    for i in range(N):\n        x,y = LI()\n        P[i] = (x,y)\n        D[(x,y)] = i\n    C = ConvexHull(P)\n    ans = [0]*N\n    if len(C)==2:\n        for c in C:\n            ans[c] = 0.5\n        for v in ans:\n            print(v)\n        return\n    #print(C)\n    for i,c in enumerate(C):\n        s, t, u = C[i - 1], C[i], C[(i + 1) % len(C)]\n        x0, y0 = P[s]\n        x1, y1 = P[t]\n        x2, y2 = P[u]\n        vec0 = (y0 - y1, x1 - x0)\n        vec1 = (y1 - y2, x2 - x1)\n        ans[t] =  math.acos((vec0[0] * vec1[0] + vec0[1] * vec1[1]) / (norm2(vec0) * norm2(vec1))) / (2 * math.pi)\n    for v in ans:\n        print(v)\n    return\n\ndef examC():\n    ans = 0\n    print(ans)\n    return\n\ndef examD():\n    S = SI()\n    N = len(S)\n    K = I()\n    dp = defaultdict(lambda:[0 for _ in range(K+1)])\n    for i in range(N):\n        for j in range(K+1):\n            dp[(i,i)][j] = 1\n    for i in range(2,N+1):\n        for k in range(K+1):\n            for l,r in enumerate(range(i-1,N)):\n                if S[l]==S[r]:\n                    dp[(l,r)][k] = dp[(l+1,r-1)][k] + 2\n                else:\n                    if k>0:\n                        dp[(l,r)][k] = max(dp[(l+1,r)][k],dp[(l,r-1)][k],dp[(l+1,r-1)][k-1]+2)\n                    else:\n                        dp[(l,r)][k] = max(dp[(l + 1,r)][k], dp[(l,r - 1)][k])\n    ans = max(dp[(0,N-1)])\n    #print(dp)\n    print(ans)\n    return\n\ndef examE():\n    ans = 0\n    print(ans)\n    return\n\ndef examF():\n    ans = 0\n    print(ans)\n    return\n\nfrom decimal import Decimal as dec\nimport sys,bisect,itertools,heapq,math,random\nfrom copy import deepcopy\nfrom heapq import heappop,heappush,heapify\nfrom collections import Counter,defaultdict,deque\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\ndef I(): return int(input())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\ndef DI(): return dec(input())\ndef LDI(): return list(map(dec,sys.stdin.readline().split()))\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef SI(): return sys.stdin.readline().strip()\nglobal mod,mod2,inf,alphabet,_ep\nmod = 10**9 + 7\nmod2 = 998244353\ninf = 10**18\n_ep = 10**(-12)\nalphabet = [chr(ord('a') + i) for i in range(26)]\n\nsys.setrecursionlimit(10**7)\n\nif __name__ == '__main__':\n    examD()\n\n\"\"\"\n142\n12 9 1445 0 1\nasd dfg hj o o\naidn\n\"\"\""
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.buffer.readline\n\nS = list(input().rstrip())\nK = int(input())\n\nL = len(S)\n\ndef main():\n    dp = [[[0]*(K+1) for _ in range(L+1)] for _ in range(L+1)]\n\n    ans = 0\n    for ind in reversed(range(L)):\n        # [0, ind), [ind, L-1]\n        s = S[ind]\n        for i in range(ind):\n            for k in reversed(range(K+1)):\n                if S[i] == s:\n                    dp[i+1][L-ind][k] = dp[i][L-ind-1][k] + 1\n                else:\n                    dp[i+1][L-ind][k] = max(dp[i][L-ind][k], dp[i+1][L-ind-1][k])\n                    dp[i+1][L-ind][k] = min(dp[i+1][L-ind][k], min(i+1, L-ind))\n                    if k < K and dp[i+1][L-ind][k] == dp[i][L-ind-1][k]:\n                        dp[i+1][L-ind][k+1] = max(dp[i+1][L-ind][k+1], dp[i+1][L-ind][k]+1)\n                        dp[i+1][L-ind][k+1] = min(dp[i+1][L-ind][k+1], min(i+1, L-ind))\n        for k in range(K+1):\n            ans = max(ans, 2*dp[ind][L-ind][k])\n            ans = max(ans, 2*dp[ind][L-ind-1][k] + 1)\n        dp.pop()\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "s = input()\nK = int(input())\nn = len(s)\nt = s[::-1]\nif 2*K+1 >= n:\n  print(n)\n  exit()\ndp = [[[0 for i in range(K+1)] for j in range(n+1)] for k in range(n+1)]\n\nans = min(2*K+1,n)\nfor center in range(1,n-1):\n  flg = 0\n  sf = s[:center]\n  sl = t[:n-center-1]\n  if s[center] == s[center+1]:\n    flg = 1\n  sfl = len(sf)\n  sll = len(sl)\n  for j in range(1,sll+1):\n    dp[sfl][j][0] = max(dp[sfl-1][j][0],dp[sfl][j-1][0])\n    if sf[-1] != sl[j-1]:\n      for k in range(1,K+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n    if sf[-1] == sl[j-1]:\n      dp[sfl][j][0] = max(dp[sfl][j][0],dp[sfl-1][j-1][0]+1)\n      for k in range(1,K+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j-1][k]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n  if flg:\n    ans= max(dp[sfl][sll][K]*2+1,dp[sfl][sll-1][K]*2+2,ans)\n  elif K > 0:\n    ans= max(dp[sfl][sll][K]*2+1,dp[sfl][sll-1][K-1]*2+2,ans)\n  else:\n    ans= max(dp[sfl][sll][K]*2+1,ans)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.buffer.readline\n\nS = list(input().rstrip())\nK = int(input())\n\nL = len(S)\n\ndef main():\n    if K >= L//2:\n        ans = L\n    else:\n        dp = [[[0]*(K+1) for _ in range(L+1)] for _ in range(L+1)]\n\n        ans = 0\n        for ind in reversed(range(L)):\n            # [0, ind), [ind, L-1]\n            s = S[ind]\n            for i in range(ind):\n                for k in reversed(range(K+1)):\n                    if S[i] == s:\n                        dp[i+1][L-ind][k] = dp[i][L-ind-1][k] + 1\n                    else:\n                        dp[i+1][L-ind][k] = max(dp[i][L-ind][k], dp[i+1][L-ind-1][k])\n                        dp[i+1][L-ind][k] = min(dp[i+1][L-ind][k], min(i+1, L-ind))\n                        if k < K and dp[i+1][L-ind][k] == dp[i][L-ind-1][k]:\n                            dp[i+1][L-ind][k+1] = max(dp[i+1][L-ind][k+1], dp[i+1][L-ind][k]+1)\n                            dp[i+1][L-ind][k+1] = min(dp[i+1][L-ind][k+1], min(i+1, L-ind))\n            for k in range(K+1):\n                ans = max(ans, 2*dp[ind][L-ind][k])\n                ans = max(ans, 2*dp[ind][L-ind-1][k] + 1)\n            dp.pop()\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "def main():\n    s = input()\n    n = len(s)\n    k = int(input())\n    # dp[使った回数][左端からの距離][左端]\n    dp = [[[1]*(n-i) for i in range(n)] for _ in range(k+1)]\n\n    if n == 1:\n        print(1)\n        return\n    dp2 = dp[0][1]\n    for i in range(n-1):\n        if s[i] == s[i+1]:\n            dp2[i] = 2\n    if k > 0:\n        for cnt in range(1, k+1):\n            dp2 = dp[cnt][1]\n            for i in range(n-1):\n                dp2[i] = 2\n\n    for cnt in range(k):\n        dp2 = dp[cnt]\n        dp4 = dp[cnt+1]\n        for d in range(2, n):\n            dp3 = dp2[d]\n            dp5 = dp2[d-1]\n            dp6 = dp2[d-2]\n            dp7 = dp4[d]\n            for left in range(n-d):\n                right = left+d\n                plus = (s[left] == s[right])*2\n                dp3[left] = max(\n                    dp3[left], dp5[left],\n                    dp5[left+1], dp6[left+1]+plus)\n                dp7[left] = max(\n                    dp7[left], dp3[left], dp6[left+1]+2)\n    dp2 = dp[k]\n    for d in range(2, n):\n        dp3 = dp2[d]\n        dp4 = dp2[d-1]\n        dp5 = dp2[d-2]\n        for left in range(n-d):\n            right = left+d\n            plus = (s[left] == s[right])*2\n            dp3[left] = max(\n                dp3[left], dp4[left], dp4[left+1], dp5[left+1]+plus)\n    print(dp[-1][-1][0])\n\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    s = input()\n    n = len(s)\n    k = int(input())\n    # dp[使った回数][左端からの距離][左端]\n    dp = [[[1]*(n-i) for i in range(n)] for _ in range(k+1)]\n\n    if n == 1:\n        print(1)\n        return\n    dp2 = dp[0][1]\n    for i in range(n-1):\n        if s[i] == s[i+1]:\n            dp2[i] = 2\n    if k > 0:\n        for cnt in range(1, k+1):\n            dp2 = dp[cnt][1]\n            for i in range(n-1):\n                dp2[i] = 2\n\n    for cnt in range(k):\n        dp2 = dp[cnt]\n        for d in range(2, n):\n            dp3 = dp2[d]\n            for left in range(n-d):\n                right = left+d\n                plus = (s[left] == s[right])*2\n                dp3[left] = max(\n                    dp3[left], dp2[d-1][left],\n                    dp2[d-1][left+1], dp2[d-2][left+1]+plus)\n                dp[cnt+1][d][left] = max(\n                    dp[cnt+1][d][left], dp3[left], dp2[d-2][left+1]+2)\n    dp2 = dp[k]\n    for d in range(2, n):\n        dp3 = dp2[d]\n        for left in range(n-d):\n            right = left+d\n            plus = (s[left] == s[right])*2\n            dp3[left] = max(\n                dp3[left], dp2[d-1][left], dp2[d-1][left+1], dp2[d-2][left+1]+plus)\n    print(dp[-1][-1][0])\n\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "def solve(s, k):\n    n = len(s)\n    pdp = [[0] * (k + 1) for _ in range(n + 1)]\n    for l in range(n - 1, -1, -1):\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for r in range(l, n):\n            dpr, dpr1 = dp[r], pdp[r - 1]\n            inc = 1 if l == r else 2\n            is_same = s[l] == s[r]\n            for p in range(k + 1):\n                if is_same:\n                    dpr[p] = dpr1[p] + inc\n                else:\n                    if p:\n                        dpr[p] = max(pdp[r][p], dp[r - 1][p], dpr1[p - 1] + inc)\n                    else:\n                        dpr[p] = max(pdp[r][p], dp[r - 1][p])\n        pdp = dp\n\n    return pdp[-2][k]\n\n\nprint(solve(input(), int(input())))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\nS = list(map(ord, readline().strip()))\nN = len(S)\nS = [None] + S + [None]\nK = int(readline())\n\nif N == 1:\n    ans = 1\nelif N == 2:\n    ans = 1\n    if S[1] == S[2]:\n        ans = 2\n    if K:\n        ans = 2\nelse:\n    dp1 = [[0]*(K+1) for _ in range(N+2)]\n    dp2 = [[0]*(K+1) for _ in range(N+2)]\n    for i in range(1, N+1):\n        dp1[i][0] = 1\n    for i in range(1, N):\n        dp2[i][0] = 1\n        if S[i] == S[i+1]:\n            dp2[i][0] = 2    \n        elif K:    \n            dp2[i][1] = 2\n    for s in range(3, N+1):\n        dp3 = [[0]*(K+1) for _ in range(N+2)]\n        for i in range(1, N-s+2):\n            j = i+s-1    \n            if S[i] == S[j]:\n                for k in range(K+1):\n                    dp3[i][k] = max(dp2[i+1][k], dp2[i][k], 2+dp1[i+1][k])\n            else:\n                dp3[i][0] = max(dp2[i+1][0], dp2[i][0], dp2[i+1][0])\n                for k in range(1, K+1):\n                    dp3[i][k] = max(dp2[i+1][k], dp2[i][k], dp1[i+1][k], 2+dp1[i+1][k-1])\n        dp1 = [k[:] for k in dp2]\n        dp2 = [k[:] for k in dp3]\n    ans = max(dp3[1][k] for k in range(K+1))\nprint(ans)\n'''\nMLEした\ndp = [[[0]*(K+1) for _ in range(N+2)] for _ in range(N+2)]\nfor i in range(1, N+1):\n    dp[i][i][0] = 1\nfor i in range(1, N):\n    dp[i][i+1][0] = 1\n    if S[i] == S[i+1]:\n        dp[i][i+1][0] = 2    \n    elif K:    \n        dp[i][i+1][1] = 2\nfor s in range(3, N+1):\n    for i in range(1, N-s+2):\n        j = i+s-1\n        if S[i] == S[j]:\n            for k in range(K+1):\n                dp[i][j][k] = max(dp[i+1][j][k], dp[i][j-1][k], 2+dp[i+1][j-1][k])\n        else:\n            dp[i][j][0] = max(dp[i+1][j][0], dp[i][j-1][0], dp[i+1][j-1][0])\n            for k in range(1, K+1):\n                dp[i][j][k] = max(dp[i+1][j][k], dp[i][j-1][k], dp[i+1][j-1][k], 2+dp[i+1][j-1][k-1], dp[i+1][j-1][k])\nprint(max(dp[1][N][k] for k in range(K+1)))\n'''   "
  },
  {
    "language": "Python",
    "code": "s = input()\nK = int(input())\nn = len(s)\nt = s[::-1]\nif 2*K+1 >= n:\n  print(n)\n  exit()\ndp = [[[0 for i in range(K+1)] for j in range(n+1)] for k in range(n+1)]\n\nans = min(2*K+1,n)\nfor center in range(1,n-1):\n  flg = 0\n  sf = s[:center]\n  sl = t[:n-center-1]\n  if s[center] == s[center+1]:\n    flg = 1\n  sfl = len(sf)\n  sll = len(sl)\n  for j in range(1,sll+1):\n    dp[sfl][j][0] = max(dp[sfl-1][j][0],dp[sfl][j-1][0])\n    if sf[-1] != sl[j-1]:\n      for k in range(1,K+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n    if sf[-1] == sl[j-1]:\n      dp[sfl][j][0] = max(dp[sfl][j][0],dp[sfl-1][j-1][0]+1)\n      for k in range(1,K+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j-1][k]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n  ans= max(dp[sfl][sll][K]*2+1,dp[sfl][sll-1][K]*2+1+flg,ans)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "s = input()\nn = len(s)\nK = int(input())\n\ndp = [[[0 for _ in range(K+1)] for _ in range(n)] for _ in range(n)]\nfor i in range(n):\n\tfor k in range(K+1):\n\t\tdp[i][i][k] = 1\n\t\tif i < n-1 and s[i] == s[i+1]:\n\t\t\tdp[i][i+1][k] = 2\n\nfor k in range(K+1):\n\tfor x in range(1, n):\n\t\tfor i in range(n-x):\n\t\t\tj = i+x\n\t\t\tdp[i][j][k] = max(dp[i][j][k-1], dp[i+1][j][k], dp[i][j-1][k])\n\t\t\tif s[i] == s[j] and x > 1:\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i+1][j-1][k] + 2)\n\t\t\telif k > 0 and x > 1:\n\t\t\t\tdp[i][j][k] = max(dp[i][j][k], dp[i+1][j-1][k-1] + 2)\n\nprint(dp[0][n-1][K])"
  },
  {
    "language": "Python",
    "code": "# coding=utf-8\n\ndef lcs(s1,s2):\n    table = []\n    for _ in range(310):\n        table.append([0 for _ in range(310)])\n\n    for y in range(1,len(s1)+1):\n        for x in range(1,len(s2)+1):\n            match = 0\n            if s1[y-1]==s2[x-1]:\n                match = 1\n\n            v1 = table[y-1][x-1]+match\n            v2 = table[y-1][x]\n            v3 = table[y][x-1]\n            table[y][x] = max(v1,v2,v3)\n    return table[len(s1)][len(s2)]\n\ndef log(s,s2):\n    return\n    print(\"---\")\n    print(\"s :\"+\"\".join(s))\n    print(\"s2:\"+\"\".join(s2))\n\ns = list(input())\nk = int(input())\ns2 = s[::-1]\nlog(s,s2)\n\nab = set(s)\n\nfor i in range(k):\n    idx = -1\n    char = \"\"\n    r = -1\n    for j in range(len(s)):\n        for x in ab:\n            t = s[:]\n            t[j] = x\n            t2 = t[::-1]\n            if lcs(t,t2)>r:\n                r = lcs(t,t2)\n                idx = j\n                char = x\n\n    s[idx] = char\n    s2 = s[::-1]\n    log(s,s2)\n\n\nprint(lcs(s,s2))\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.buffer.readline\n\nS = list(input().rstrip())\nK = int(input())\n\nL = len(S)\n\ndef main():\n    dp = [[[0]*(K+1) for _ in range(L+1)] for _ in range(L+1)]\n\n    ans = 0\n    for ind in reversed(range(L)):\n        # [0, ind), [ind, L-1]\n        s = S[ind]\n        for i in range(ind):\n            for k in reversed(range(K+1)):\n                if S[i] == s:\n                    dp[i+1][L-ind][k] = dp[i][L-ind-1][k] + 1\n                else:\n                    dp[i+1][L-ind][k] = max(dp[i][L-ind][k], dp[i+1][L-ind-1][k])\n                    dp[i+1][L-ind][k] = min(dp[i+1][L-ind][k], max(i+1, L-ind))\n                    if k < K:\n                        dp[i+1][L-ind][k+1] = max(dp[i+1][L-ind][k+1], dp[i+1][L-ind][k]+1)\n                        dp[i+1][L-ind][k+1] = min(dp[i+1][L-ind][k+1], min(i+1, L-ind))\n        for k in range(K+1):\n            ans = max(ans, 2*dp[ind][L-ind][k])\n            ans = max(ans, 2*dp[ind][L-ind-1][k] + 1)\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "s = input()\nK = int(input())\nn = len(s)\nt = s[::-1]\nif 2*K+1 >= n:\n  print(n)\n  exit()\ndp = [[[0 for i in range(K+1)] for j in range(n+1)] for k in range(n+1)]\n\nans = min(2*K+1,n)\nfor center in range(1,n-1):\n  flg = 0\n  sf = s[:center]\n  sl = t[:n-center-1]\n  if s[center] == s[center+1]:\n    flg = 1\n  sfl = len(sf)\n  sll = len(sl)\n  for j in range(1,sll+1):\n    dp[sfl][j][0] = max(dp[sfl-1][j][0],dp[sfl][j-1][0])\n    if sf[-1] != sl[j-1]:\n      for k in range(1,K+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n    if sf[-1] == sl[j-1]:\n      dp[sfl][j][0] = max(dp[sfl][j][0],dp[sfl-1][j-1][0]+1)\n      for k in range(1,K+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j-1][k]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n  if flg:\n    ans= max(dp[sfl][sll][K]*2+1,dp[sfl][sll-1][K]*2+2,ans)\n  else:\n    ans= max(dp[sfl][sll][K]*2+1,dp[sfl][sll-1][K-1]*2+2,ans)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "s = input()\nk = int(input())\nn = len(s)\ndp = [[[0]*(n+1) for i in range(n+1)] for j in range(n+1)]\nfor j in range(k+1):\n    for i in range(n):\n        dp[i][i+1][j] = 1\nfor j in range(2,n+1):\n  for i in range(n+1-j):\n    for l in range(k+1):\n      jj = i+j\n      if s[i] == s[jj-1]:\n        dp[i][jj][l] = dp[i+1][jj-1][l]+2\n      else:\n        dp[i][jj][l] = max(dp[i+1][jj][l],dp[i][jj-1][l])\n        if l-1>=0:\n          dp[i][jj][l] = max(dp[i][jj][l],dp[i+1][jj-1][l-1]+2)\nans = 0\nfor i in range(k+1):\n  ans = max(ans,dp[0][n][i])\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "def solve(s, k):\n    n = len(s)\n    dp = [[[0] * (k + 1) for _ in range(n)] for _ in range(n + 1)]\n    for l in range(n - 1, -1, -1):\n        dpl, dpl1 = dp[l], dp[l + 1]\n        for r in range(l, n):\n            dpr, dpr1 = dpl[r], dpl1[r - 1]\n            inc = 1 if l == r else 2\n            for p in range(k + 1):\n                if s[l] == s[r]:\n                    dpr[p] = dpr1[p] + inc\n                else:\n                    dpr[p] = max(dpl1[r][p], dp[l][r - 1][p])\n                    if p:\n                        dpr[p] = max(dpr[p], dpr1[p - 1] + inc)\n    return dp[0][-1][k]\n\n\nprint(solve(input(), int(input())))\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    s = input()\n    n = len(s)\n    k = int(input())\n    # dp[左端][左端からの右端の距離][使った回数]\n    dp = [[[1]*(k+1) for _ in [0]*(n-i)] for i in range(n)]\n\n    for i in range(n-1):\n        if s[i] == s[i+1]:\n            dp[i][1][0] = 2\n    if k > 0:\n        for i in range(n-1):\n            dp[i][1][1] = 2\n\n    for cnt in range(k):\n        for d in range(2, n):\n            for left in range(n-d):\n                right = left+d\n                plus = (s[left] == s[right])*2\n                dp[left][d][cnt] = max(\n                    dp[left][d][cnt], dp[left][d-1][cnt],\n                    dp[left+1][d-1][cnt], dp[left+1][d-2][cnt]+plus)\n                dp[left][d][cnt+1] = max(\n                    max(dp[left][d][cnt:cnt+2]), dp[left+1][d-2][cnt]+2)\n    for d in range(2, n):\n        for left in range(n-d):\n            right = left+d\n            plus = (s[left] == s[right])*2\n            dp[left][d][k] = max(\n                dp[left][d][k], dp[left][d-1][k], dp[left+1][d-1][k], dp[left+1][d-2][k]+plus)\n    print(dp[0][-1][-1])\n\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "s = input()\nK = int(input())\nn = len(s)\nt = s[::-1]\nif 2*K+1 >= n:\n  print(n)\n  exit()\ndp = [[[0 for i in range(K+1)] for j in range(n+1)] for k in range(n+1)]\n\nans = min(2*K+1,n)\nfor center in range(1,n-1):\n  flg = 0\n  sf = s[:center]\n  sl = t[:n-center-1]\n  if s[center] == s[center+1]:\n    flg = 1\n  sfl = len(sf)\n  sll = len(sl)\n  for j in range(1,sll+1):\n    dp[sfl][j][0] = max(dp[sfl-1][j][0],dp[sfl][j-1][0])\n    if sf[-1] != sl[j-1]:\n      for k in range(1,K+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n    if sf[-1] == sl[j-1]:\n      dp[sfl][j][0] = max(dp[sfl][j][0],dp[sfl-1][j-1][0]+1)\n      for k in range(1,K+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j-1][k]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n  if flg:\n    ans= max(dp[sfl][sll][K]*2+1,dp[sfl][sll-1][K]*2+2,ans)\n  else:\n    ans= max(dp[sfl][sll][K]*2+1,dp[sfl][sll-1][max(0,K-1)]*2+2,ans)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "s = input()\nn = len(s)\nk = int(input())\n\n\ndp = [[[0] * (n + 1) for i in range(n + 1)] for i in range(k + 1)]\nfor i in range(n):\n    dp[0][i][i + 1] = 1\n\nfor length in range(2, n + 1):\n    for l in range(n):\n        for ki in range(k + 1):\n            r = l + length\n            if r > n:\n                break\n            if s[l] == s[r - 1]:\n                dp[ki][l][r] = max(2 + dp[ki][l + 1][r - 1], dp[ki][l][r])\n            else:\n                dp[ki][l][r] = max(dp[ki][l + 1][r], dp[ki][l][r - 1], dp[ki][l][r])\n                if ki - 1 >= 0:\n                    dp[ki][l][r] = max(dp[ki - 1][l + 1][r] + 2, dp[ki - 1][l][r - 1] + 2, dp[ki][l][r])\n\nprint(dp[-1][0][-1])"
  },
  {
    "language": "Python",
    "code": "s = input()\nn = len(s)\nk = int(input())\n\ndp = [[0] * ((n + 1) * (n + 1)) for i in range(k + 1)]\nOFFSET = n + 1\n\n# 長さ1のときの初期化\nfor i in range(n):\n    dp[0][i * OFFSET + i + 1] = 1\n\n# 長さ2~nのときのDP\nfor length in range(2, n + 1):\n    for l in range(n + 1):\n        for ki in range(k + 1):\n            r = l + length\n            if r > n:\n                break\n            if s[l] == s[r - 1]:\n                dp[ki][l * OFFSET + r] = max(2 + dp[ki][(l + 1) * OFFSET + r - 1], dp[ki][l * OFFSET + r])\n            else:\n                dp[ki][l * OFFSET + r] = max(dp[ki][(l + 1) * OFFSET + r], dp[ki][l * OFFSET + r - 1], dp[ki][l * OFFSET + r])\n                if ki - 1 >= 0:\n                    dp[ki][l * OFFSET + r] = max(dp[ki - 1][(l + 1) * OFFSET + r - 1] + 2, dp[ki][l * OFFSET + r])\n\nans = 0\nfor i in range(k + 1):\n    ans = max(ans, dp[i][n])\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "def solve(s, k):\n    n = len(s)\n    if k >= n // 2:\n        return n\n    dpp = [[1] * (k + 1), [0] * (k + 1)]\n    for r in range(1, n):\n        dpc = [[0] * (k + 1) for _ in range(r + 2)]\n        dpc[r] = [1] * (k + 1)\n        for l in range(r - 1, -1, -1):\n            dpl, dpl1 = dpc[l], dpp[l + 1]\n            if s[l] == s[r]:\n                dpc[l] = [c + 2 for c in dpl1]\n            else:\n                dppl, dpcl1 = dpp[l], dpc[l + 1]\n                dpl[0] = max(dppl[0], dpcl1[0])\n                for p in range(1, k + 1):\n                    dpl[p] = max(dppl[p], dpcl1[p], dpl1[p - 1] + 2)\n        dpp = dpc\n\n    return dpp[0][k]\n\n\nprint(solve(input(), int(input())))\n"
  },
  {
    "language": "Python",
    "code": "s = input()\nK = int(input())\nn = len(s)\nt = s[::-1]\nif 2*K+1 >= n:\n  print(n)\n  exit()\ndp = [[[0 for i in range(K+1)] for j in range(n+1)] for k in range(n+1)]\n\nans = min(2*K+1,n)\nfor center in range(1,n-1):\n  flg = 0\n  sf = s[:center]\n  sl = t[:n-center-1]\n  if s[center] == s[center+1]:\n    flg = 1\n  sfl = len(sf)\n  sll = len(sl)\n  for j in range(1,sll+1):\n    dp[sfl][j][0] = max(dp[sfl-1][j][0],dp[sfl][j-1][0])\n    if sf[-1] != sl[j-1]:\n      for k in range(1,K+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n    if sf[-1] == sl[j-1]:\n      dp[sfl][j][0] = max(dp[sfl][j][0],dp[sfl-1][j-1][0]+1)\n      for k in range(1,K+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j-1][k]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n  ans= max(dp[sfl][sll][min(K,sll)]*2+1,dp[sfl][sll-1][min(K,sll)]*2+1+flg,ans)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "def main():\n    s = input()\n    n = len(s)\n    k = int(input())\n    # dp[左端][左端からの右端の距離][使った回数]\n    dp = [[[2]*(k+1) for _ in [0]*(n-i)] for i in range(n)]\n\n    for i in range(n):\n        for cnt in range(k+1):\n            dp[i][0][cnt] = 1\n\n    for i in range(n-1):\n        if s[i] != s[i+1]:\n            dp[i][1][0] = 1\n\n    for cnt in range(k):\n        for d in range(2, n):\n            for left in range(n-d):\n                right = left+d\n                plus = (s[left] == s[right])*2\n                dp[left][d][cnt] = max(\n                    dp[left][d][cnt], dp[left][d-1][cnt], dp[left+1][d-2][cnt]+plus)\n                dp[left][d][cnt+1] = max(\n                    max(dp[left][d][cnt:cnt+2]), dp[left+1][d-2][cnt]+2)\n    for d in range(2, n):\n        for left in range(n-d):\n            right = left+d\n            plus = (s[left] == s[right])*2\n            dp[left][d][k] = max(\n                dp[left][d][k], dp[left][d-1][k], dp[left+1][d-2][k]+plus)\n    print(dp[0][-1][-1])\n\n\nmain()"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.buffer.readline\n\nS = list(input().rstrip())\nK = int(input())\n\nL = len(S)\n\ndef main():\n    dp = [[[0]*(K+1) for _ in range(L+1)] for _ in range(L+1)]\n\n    ans = 0\n    for ind in reversed(range(L)):\n        # [0, ind), [ind, L-1]\n        s = S[ind]\n        for i in range(ind):\n            for k in reversed(range(K+1)):\n                if S[i] == s:\n                    dp[i+1][L-ind][k] = dp[i][L-ind-1][k] + 1\n                else:\n                    dp[i+1][L-ind][k] = max(dp[i][L-ind][k], dp[i+1][L-ind-1][k])\n                    dp[i+1][L-ind][k] = min(dp[i+1][L-ind][k], max(i+1, L-ind))\n                    if k < K:\n                        dp[i+1][L-ind][k+1] = max(dp[i+1][L-ind][k+1], dp[i+1][L-ind][k]+1)\n                        #dp[i+1][L-ind][k+1] = min(dp[i+1][L-ind][k+1], max(i+1, L-ind))\n        for k in range(K+1):\n            ans = max(ans, 2*dp[ind][L-ind][k])\n            ans = max(ans, 2*dp[ind][L-ind-1][k] + 1)\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "S = input()\nK = int(input())\nN = len(S)\n\ndp = [[[0 for _ in range(K+1)] for _ in range(N)] for _ in range(N)]\nfor i in range(N):\n    for k in range(K+1):\n        dp[i][i][k] = 1\n\nfor _j in range(1, N):\n    for i in range(N):\n        j = i + _j\n        if j < N:\n            for k in range(K+1):\n                dp[i][j][k] = max(dp[i][j][k], dp[i+1][j][k], dp[i][j-1][k])\n                if _j == 1:\n                    if S[i] == S[j]:\n                        dp[i][j][k] = 2\n                    else:\n                        if k+1 <= K:\n                            dp[i][j][k+1] = 2\n                else:\n                    if S[i] == S[j]:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i+1][j-1][k] + 2)\n                    else:\n                        if k+1 <= K:\n                            dp[i][j][k+1] = max(dp[i][j][k], dp[i+1][j-1][k] + 2)\n\nprint(max(dp[0][N-1]))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\n\ns = input()\nK = int(input())\nn = len(s)\ndp = [[[0]*(K+1) for _ in range(n+2-i)] for i in range(n+1)]\nfor i in range(n):\n    for j in range(K+1):\n        dp[i][1][j] = 1\nfor l in range(2, n+1):\n    for i in range(n-l+1):\n        for k in range(K+1):\n#             print(l, i, i+l, j)\n            if s[i]==s[i+l-1]:\n                dp[i][l][k] = dp[i+1][l-2][k] + 2\n            else:\n                dp[i][l][k] = max(dp[i+1][l-1][k], dp[i][l-1][k])\n                if k>=1:\n                    dp[i][l][k] = max(dp[i][l][k], dp[i+1][l-2][k-1]+2)\nans = max(dp[0][i][j] for i in range(n+2) for j in range(K+1))\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\n\nreadline = sys.stdin.buffer.readline\n\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\n\ndef solve():\n  s = list(ns())\n  ls = len(s)\n  lk = ni()\n  dp = [[[0]*(lk+1) for _ in range(ls)] for i in range(ls)]\n  for i in range(ls):\n    dp[i][i][0] = 1\n  for k in range(lk+1):\n    for dis in range(1, ls):\n      for i in range(ls - dis):\n        j = i + dis\n        if s[i] == s[j]:\n          dp[i][j][k] = dp[i+1][j-1][k] + 2\n        elif k:\n          dp[i][j][k] = dp[i+1][j-1][k-1] + 2\n        dp[i][j][k] = max(dp[i][j][k], dp[i+1][j][k], dp[i][j-1][k])\n\n  print(max(dp[0][ls-1]))\n  return\n\nsolve()"
  },
  {
    "language": "Python",
    "code": "s = list(map(ord, list(input())))\nls = len(s)\nlk = int(input())\nif lk*2 >= ls: print(ls); exit(0)\nlk *= 2\ndp = [[[0]*(lk+1) for _ in range(ls+1)] for i in range(ls+1)]\nfor k in range(lk+1):\n  for i in range(ls):\n    for j in range(ls):\n      if s[i] == s[-j-1]:\n        if dp[i+1][j+1][k] < dp[i][j][k] + 1:\n          dp[i+1][j+1][k] = dp[i][j][k] + 1\n      else:\n        dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i+1][j][k], dp[i][j+1][k], (k > 0)*(dp[i][j][k-1] + 1))\nprint(max(dp[ls][ls]))"
  },
  {
    "language": "Python",
    "code": "s = input()\nK = int(input())\nn = len(s)\nt = s[::-1]\nif 2*K+1 >= n:\n  print(n)\n  exit()\ndp = [[[0 for i in range(K+1)] for j in range(n+1)] for k in range(n+1)]\nif n == 2 and K == 0:\n  if s == t:\n    print(2)\n    exit()\n  else:\n    print(1)\n    exit()\nans = min(2*K+1,n)\nfor center in range(1,n-1):\n  flg = 0\n  sf = s[:center]\n  sl = t[:n-center-1]\n  if s[center] == s[center+1]:\n    flg = 1\n  sfl = len(sf)\n  sll = len(sl)\n  for j in range(1,sll+1):\n    dp[sfl][j][0] = max(dp[sfl-1][j][0],dp[sfl][j-1][0])\n    if sf[-1] != sl[j-1]:\n      for k in range(1,K+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n    if sf[-1] == sl[j-1]:\n      dp[sfl][j][0] = max(dp[sfl][j][0],dp[sfl-1][j-1][0]+1)\n      for k in range(1,K+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j-1][k]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n  if flg:\n    ans= max(dp[sfl][sll][K]*2+1,dp[sfl][sll-1][K]*2+2,ans)\n  elif K > 0:\n    ans= max(dp[sfl][sll][K]*2+1,dp[sfl][sll-1][K-1]*2+2,ans)\n  else:\n    ans= max(dp[sfl][sll][K]*2+1,ans)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "def main():\n    s = input()\n    n = len(s)\n    k = int(input())\n    # dp[左端][左端からの右端の距離][使った回数]\n    dp = [[[1]*(k+1) for _ in [0]*(n-i)] for i in range(n)]\n\n    for i in range(n-1):\n        if s[i] == s[i+1]:\n            dp[i][1][0] = 2\n\n    for cnt in range(k):\n        for d in range(2, n):\n            for left in range(n-d):\n                right = left+d\n                plus = (s[left] == s[right])*2\n                dp[left][d][cnt] = max(\n                    dp[left][d][cnt], dp[left][d-1][cnt],\n                    dp[left+1][d-1][cnt], dp[left+1][d-2][cnt]+plus)\n                dp[left][d][cnt+1] = max(\n                    max(dp[left][d][cnt:cnt+2]), dp[left+1][d-2][cnt]+2)\n    for d in range(2, n):\n        for left in range(n-d):\n            right = left+d\n            plus = (s[left] == s[right])*2\n            dp[left][d][k] = max(\n                dp[left][d][k], dp[left][d-1][k], dp[left+1][d-1][k], dp[left+1][d-2][k]+plus)\n    print(dp[0][-1][-1])\n\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "S = input()\nK = int(input())\nN = len(S)\n\n# MLE対策\nif K * 2 >= N-1:\n    print(N)\n    exit()\n\ndp = [[[0 for _ in range(K+1)] for _ in range(N)] for _ in range(N)]\nfor i in range(N):\n    for k in range(K+1):\n        dp[i][i][k] = 1\n\nfor _j in range(1, N):\n    for i in range(N):\n        j = i + _j\n        if j < N:\n            for k in range(K+1):\n                dp[i][j][k] = max(dp[i][j][k], dp[i+1][j][k], dp[i][j-1][k])\n                if _j == 1:\n                    if S[i] == S[j]:\n                        dp[i][j][k] = 2\n                    else:\n                        if k+1 <= K:\n                            dp[i][j][k+1] = 2\n                else:\n                    if S[i] == S[j]:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i+1][j-1][k] + 2)\n                    else:\n                        if k+1 <= K:\n                            dp[i][j][k+1] = max(dp[i][j][k], dp[i+1][j-1][k] + 2)\n\nprint(max(dp[0][N-1]))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nreadline = sys.stdin.buffer.readline\n\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\n\ndef solve():\n  s = list(ns())\n  ls = len(s)\n  lk = ni()\n  dp = [[[0]*ls for _ in range(ls)] for i in range(2)]\n  ans = 0\n  for i in range(ls):\n    dp[0][i][i] = 1\n  for k in range(lk+1):\n    v = k & 1\n    for dis in range(1, ls):\n      for i in range(ls - dis):\n        j = i + dis\n        dp[v][i][j] = 0\n        if s[i] == s[j]:\n          dp[v][i][j] = dp[v][i+1][j-1] + 2\n        elif k:\n          dp[v][i][j] = dp[v^1][i+1][j-1] + 2\n        dp[v][i][j] = max(dp[v][i][j], dp[v][i+1][j], dp[v][i][j-1])\n    ans = max(ans, dp[v][0][-1])\n\n  print(ans)\n  return\n\nsolve()"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.buffer.readline\n\nS = list(input().rstrip())\nK = int(input())\n\nL = len(S)\n\ndef main():\n    dp = [[[0]*(K+1) for _ in range(L+1)] for _ in range(L+1)]\n\n    ans = 0\n    for ind in reversed(range(L)):\n        # [0, ind), [ind, L-1]\n        s = S[ind]\n        for i in range(ind):\n            for k in reversed(range(K+1)):\n                if S[i] == s:\n                    dp[i+1][L-ind][k] = dp[i][L-ind-1][k] + 1\n                else:\n                    dp[i+1][L-ind][k] = max(dp[i][L-ind][k], dp[i+1][L-ind-1][k])\n                    dp[i+1][L-ind][k] = min(dp[i+1][L-ind][k], min(i+1, L-ind))\n                    if k < K and dp[i+1][L-ind][k] == dp[i+1][L-ind-1][k] and dp[i+1][L-ind][k] == dp[i][L-ind][k]:\n                        dp[i+1][L-ind][k+1] = max(dp[i+1][L-ind][k+1], dp[i+1][L-ind][k]+1)\n                        dp[i+1][L-ind][k+1] = min(dp[i+1][L-ind][k+1], min(i+1, L-ind))\n        for k in range(K+1):\n            ans = max(ans, 2*dp[ind][L-ind][k])\n            ans = max(ans, 2*dp[ind][L-ind-1][k] + 1)\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "s = input()\nK = int(input())\nn = len(s)\nt = s[::-1]\nif 2*K+1 >= n:\n  print(n)\n  exit()\ndp = [[[0 for i in range(K+1)] for j in range(n+1)] for k in range(n+1)]\nif n == 2 and k == 0:\n  if s == t:\n    print(2)\n  else:\n    print(1)\n    exit()\nans = min(2*K+1,n)\nfor center in range(1,n-1):\n  flg = 0\n  sf = s[:center]\n  sl = t[:n-center-1]\n  if s[center] == s[center+1]:\n    flg = 1\n  sfl = len(sf)\n  sll = len(sl)\n  for j in range(1,sll+1):\n    dp[sfl][j][0] = max(dp[sfl-1][j][0],dp[sfl][j-1][0])\n    if sf[-1] != sl[j-1]:\n      for k in range(1,K+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n    if sf[-1] == sl[j-1]:\n      dp[sfl][j][0] = max(dp[sfl][j][0],dp[sfl-1][j-1][0]+1)\n      for k in range(1,K+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j-1][k]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n  if flg:\n    ans= max(dp[sfl][sll][K]*2+1,dp[sfl][sll-1][K]*2+2,ans)\n  elif K > 0:\n    ans= max(dp[sfl][sll][K]*2+1,dp[sfl][sll-1][K-1]*2+2,ans)\n  else:\n    ans= max(dp[sfl][sll][K]*2+1,ans)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "s = input()\nK = int(input())\nn = len(s)\nt = s[::-1]\nif 2*K+1 >= n:\n  print(n)\n  exit()\ndp = [[[0 for i in range(K+1)] for j in range(n+1)] for k in range(n+1)]\n\nans = min(2*K+1,n)\nflg2 = 0\nfor center in range(1,n-1):\n  flg = 0\n  sf = s[:center]\n  sl = t[:n-center-1]\n  if s[center] == s[center+1]:\n    flg = 1\n  sfl = len(sf)\n  sll = len(sl)\n  for j in range(1,sll+1):\n    dp[sfl][j][0] = max(dp[sfl-1][j][0],dp[sfl][j-1][0])\n    if sf[-1] != sl[j-1]:\n      for k in range(1,K+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n    if sf[-1] == sl[j-1]:\n      dp[sfl][j][0] = max(dp[sfl][j][0],dp[sfl-1][j-1][0]+1)\n      for k in range(1,K+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j-1][k]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n  if ans < max(dp[sfl][sll][K]*2+1,dp[sfl][sll-1][K]*2+1+flg):\n    flg2 = flg\n  ans= max(dp[sfl][sll][K]*2+1,dp[sfl][sll-1][K]*2+1+flg,ans)\nif flg2 == 1:\n  print(2/0)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "s = input()\nK = int(input())\nn = len(s)\nt = s[::-1]\nif 2*K+1 >= n:\n  print(n)\n  exit()\ndp = [[[0 for i in range(K+1)] for j in range(n+1)] for k in range(n+1)]\n\nans = min(2*K+1,n)\nfor center in range(1,n-1):\n  flg = 0\n  sf = s[:center]\n  sl = t[:n-center-1]\n  sfl = len(sf)\n  sll = len(sl)\n  for j in range(1,sll+1):\n    dp[sfl][j][0] = max(dp[sfl-1][j][0],dp[sfl][j-1][0])\n    if sf[-1] != sl[j-1]:\n      for k in range(1,K+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n    if sf[-1] == sl[j-1]:\n      dp[sfl][j][0] = max(dp[sfl][j][0],dp[sfl-1][j-1][0]+1)\n      for k in range(1,K+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j-1][k]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n  ans= max(dp[sfl][sll][K]*2+1,dp[sfl][sll-1][K]*2+2,ans)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "s = input()\nK = int(input())\nn = len(s)\nt = s[::-1]\ndp = [[[0 for i in range(K+1)] for j in range(n+1)] for k in range(n+1)]\nansls = [min(2*K+1,n)]\nfor center in range(1,n-1):\n  flg = 0\n  sf = s[:center]\n  sl = t[:n-center-1]\n  if s[center] == s[center+1]:\n    flg = 1\n  sfl = len(sf)\n  sll = len(sl)\n  for j in range(1,sll+1):\n    dp[sfl][j][0] = max(dp[sfl-1][j][0],dp[sfl][j-1][0])\n    if sf[-1] != sl[j-1]:\n      for k in range(1,min(K,sll)+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n    if sf[-1] == sl[j-1]:\n      dp[sfl][j][0] = max(dp[sfl][j][0],dp[sfl-1][j-1][0]+1)\n      for k in range(1,min(K,sll)+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j-1][k]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n  ansls.append(max(dp[sfl][sll][min(K,sll)]*2+1,dp[sfl][sll-1][min(K,sll)]*2+1+flg))\nprint(max(ansls))"
  },
  {
    "language": "Python",
    "code": "s = input()\nn = len(s)\nk = int(input())\n\ndp = [[[0] * (n + 1) for i in range(n + 1)] for i in range(k + 1)]\n\n# 長さ1のときの初期化\nfor i in range(n):\n    dp[0][i][i + 1] = 1\n\n# 長さ2~nのときのDP\nfor length in range(2, n + 1):\n    for l in range(n + 1):\n        for ki in range(k + 1):\n            r = l + length\n            if r > n:\n                break\n            if s[l] == s[r - 1]:\n                dp[ki][l][r] = max(2 + dp[ki][l + 1][r - 1], dp[ki][l][r])\n            else:\n                dp[ki][l][r] = max(dp[ki][l + 1][r], dp[ki][l][r - 1], dp[ki][l][r])\n                if ki - 1 >= 0:\n                    dp[ki][l][r] = max(dp[ki - 1][l + 1][r - 1] + 2, dp[ki - 1][l + 1][r - 1] + 2, dp[ki][l][r])\n\nprint(dp[-1][0][-1])"
  },
  {
    "language": "Python",
    "code": "def examA():\n    N = I()\n    ans = 0\n    print(ans)\n    return\n\n# 参考 https://atcoder.jp/contests/agc021/submissions/8392122\ndef examB():\n    def norm2(vec):\n        return math.sqrt(vec[0] ** 2 + vec[1] ** 2)\n    # any 2 points must have different position.\n    def ConvexHull(point_list):\n        pos2idx = {point_list[i]: i for i in range(len(point_list))}\n        y_val = defaultdict(list)\n        x_list = sorted(list(set([p[0] for p in point_list])))\n        for x, y in point_list:\n            y_val[x].append(y)\n\n        upper = [(x_list[0], max(y_val[x_list[0]]))]\n        lower = [(x_list[0], min(y_val[x_list[0]]))]\n        prev = float('inf')\n        for xi in x_list[1:]:\n            x0, y0 = upper[-1]\n            x1, y1 = xi, max(y_val[xi])\n            if (y1 - y0) / (x1 - x0) < prev:\n                upper.append((x1, y1))\n                prev = (y1 - y0) / (x1 - x0)\n            else:\n                while True:\n                    x0, y0 = upper[-1]\n                    if len(upper) == 1:\n                        upper.append((x1, y1))\n                        break\n                    x00, y00 = upper[-2]\n                    if (y1 - y0) / (x1 - x0) > (y1 - y00) / (x1 - x00):\n                        upper.pop()\n                    else:\n                        prev = (y1 - y0) / (x1 - x0)\n                        upper.append((x1, y1))\n                        break\n\n        prev = -float('inf')\n        for xi in x_list[1:]:\n            x0, y0 = lower[-1]\n            x1, y1 = xi, min(y_val[xi])\n            if (y1 - y0) / (x1 - x0) > prev:\n                lower.append((x1, y1))\n                prev = (y1 - y0) / (x1 - x0)\n            else:\n                while True:\n                    x0, y0 = lower[-1]\n                    if len(lower) == 1:\n                        lower.append((x1, y1))\n                        break\n                    x00, y00 = lower[-2]\n                    if (y1 - y0) / (x1 - x0) < (y1 - y00) / (x1 - x00):\n                        lower.pop()\n                    else:\n                        prev = (y1 - y0) / (x1 - x0)\n                        lower.append((x1, y1))\n                        break\n\n        # return upper, lower\n        # return [pos2idx[xy] for xy in upper], [pos2idx[xy] for xy in lower]\n\n        upper_idx, lower_idx = [pos2idx[xy] for xy in upper], [pos2idx[xy] for xy in lower]\n        if upper_idx[-1] == lower_idx[-1]:\n            upper_idx.pop()\n        CH_idx = upper_idx\n        CH_idx.extend(reversed(lower_idx))\n        if CH_idx[0] == CH_idx[-1] and len(CH_idx) > 1:\n            CH_idx.pop()\n        return CH_idx\n\n    N = I()\n    P = [[]for _ in range(N)]\n    D = defaultdict(int)\n    for i in range(N):\n        x,y = LI()\n        P[i] = (x,y)\n        D[(x,y)] = i\n    C = ConvexHull(P)\n    ans = [0]*N\n    if len(C)==2:\n        for c in C:\n            ans[c] = 0.5\n        for v in ans:\n            print(v)\n        return\n    #print(C)\n    for i,c in enumerate(C):\n        s, t, u = C[i - 1], C[i], C[(i + 1) % len(C)]\n        x0, y0 = P[s]\n        x1, y1 = P[t]\n        x2, y2 = P[u]\n        vec0 = (y0 - y1, x1 - x0)\n        vec1 = (y1 - y2, x2 - x1)\n        ans[t] =  math.acos((vec0[0] * vec1[0] + vec0[1] * vec1[1]) / (norm2(vec0) * norm2(vec1))) / (2 * math.pi)\n    for v in ans:\n        print(v)\n    return\n\ndef examC():\n    ans = 0\n    print(ans)\n    return\n\ndef examD():\n    S = SI()\n    N = len(S)\n    K = I()\n    dp = [[[0 for _ in range(K+1)]for _ in range(N)]for _ in range(N)]\n    for i in range(N):\n        for j in range(K+1):\n            dp[i][i][j] = 1\n    for i in range(2,N+1):\n        for k in range(K+1):\n            for l,r in enumerate(range(i-1,N)):\n                if S[l]==S[r]:\n                    dp[l][r][k] = dp[l+1][r-1][k] + 2\n                else:\n                    if k>0:\n                        dp[l][r][k] = max(dp[l+1][r][k],dp[l][r-1][k],dp[l+1][r-1][k-1]+2)\n                    else:\n                        dp[l][r][k] = max(dp[l + 1][r][k], dp[l][r - 1][k])\n    ans = max(dp[0][-1])\n    print(ans)\n    return\n\ndef examE():\n    ans = 0\n    print(ans)\n    return\n\ndef examF():\n    ans = 0\n    print(ans)\n    return\n\ndef test():\n    i = I()\n    li = LI()\n    lsi = LSI()\n    si = LS()\n    print(i)\n    print(li)\n    print(lsi)\n    print(si)\n    return\n\nfrom decimal import Decimal as dec\nimport sys,bisect,itertools,heapq,math,random\nfrom copy import deepcopy\nfrom heapq import heappop,heappush,heapify\nfrom collections import Counter,defaultdict,deque\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\ndef I(): return int(input())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\ndef DI(): return dec(input())\ndef LDI(): return list(map(dec,sys.stdin.readline().split()))\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef SI(): return sys.stdin.readline().strip()\nglobal mod,mod2,inf,alphabet,_ep\nmod = 10**9 + 7\nmod2 = 998244353\ninf = 10**18\n_ep = 10**(-12)\nalphabet = [chr(ord('a') + i) for i in range(26)]\n\nsys.setrecursionlimit(10**7)\n\nif __name__ == '__main__':\n    examD()\n\n\"\"\"\n142\n12 9 1445 0 1\nasd dfg hj o o\naidn\n\"\"\""
  },
  {
    "language": "Python",
    "code": "def getdp(i, j, k):\n    if i < 0: return -1\n    if j > k: return 0\n    if j == k: return 1\n    if dp[i][j][k] != -1: return dp[i][j][k]\n    res = -1\n    if s[j] == s[k]: res = max(res, getdp(i, j+1, k-1)+2)\n    else: res = max(res, getdp(i-1, j+1, k-1)+2, getdp(i, j+1, k), getdp(i, j, k-1))\n    dp[i][j][k] = res\n    return res\n\ninput = raw_input\nrange = xrange\ns = input()\nn = len(s)\nk = int(input())\ndp = [[[-1]*n for j in range(n)] for i in range(k+1)] # score [j..k], i more free slots\nprint(getdp(k, 0, n-1))"
  },
  {
    "language": "Python",
    "code": "def solve(s, k):\n    n = len(s)\n    dp = [[[0] * (k + 1) for _ in range(n)] for _ in range(n + 1)]\n    for l in range(n - 1, -1, -1):\n        dpl, dpl1 = dp[l], dp[l + 1]\n        for r in range(l, n):\n            dpr, dpr1 = dpl[r], dpl1[r - 1]\n            inc = 1 if l == r else 2\n            for p in range(k + 1):\n                if s[l] == s[r]:\n                    dpr[p] = dpr1[p] + inc\n                else:\n                    dpr[p] = max(dpl1[r][p], dp[l][r - 1][p])\n                    if p:\n                        dpr[p] = max(dpr[p], dpr1[p - 1] + inc)\n    return dp[0][-1][k]\n\n\nprint(solve(input(), int(input())))\n"
  },
  {
    "language": "Python",
    "code": "def lcs(str1, str2):\n    '''文字列str1, str2の最長共通部分列(Lowest Common Subsequence, LCS)を求める\n    計算量O(len(str1)*len(str2))  \n    '''\n    dp = [[0]*(len(str2) + 1) for _ in range(len(str1) + 1)]\n    for i in range(len(str1)):\n        for j in range(len(str2)):\n            if str1[i] == str2[j]:\n                dp[i+1][j+1] = dp[i][j] + 1\n            else:\n                dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j])\n\n    return dp[len(str1)][len(str2)]\n\n\ns = input()\nn = len(s)\nk = int(input())\n\nans = 0\nfor i in range(n):\n    t = s[0:i]\n    rev_t = s[i+1:][::-1]\n    min_len = min(len(t), len(rev_t))\n    ans = max(min(lcs(t, rev_t) + k, min_len) * 2 + 1, ans)\n\nfor i in range(n + 1):\n    t = s[0:i]\n    rev_t = s[i:][::-1]\n    min_len = min(len(t), len(rev_t))\n    ans = max(min(lcs(t, rev_t) + k, min_len) * 2, ans)\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\n\ns = input()\nK = int(input())\nn = len(s)\ndp = [[[0]*(K+1) for _ in range(n+1-i+1)] for i in range(n+1)]\nfor i in range(n):\n    for j in range(K+1):\n        dp[i][1][j] = 1\nfor l in range(2, n+1):\n    for i in range(n-l+1):\n        for k in range(K+1):\n#             print(l, i, i+l, j)\n            if s[i]==s[i+l-1]:\n                dp[i][l][k] = dp[i+1][l-1][k] + 2\n            else:\n                dp[i][l][k] = max(dp[i+1][l][k], dp[i][l-1][k])\n                if k>=1:\n                    dp[i][l][k] = max(dp[i][l][k], dp[i+1][l-1][k-1]+2)\nans = max(dp[0][n][j] for j in range(K+1))\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nreadline = sys.stdin.buffer.readline\n\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\n\ns = list(ns())\nls = len(s)\nlk = ni()\ndp = [[[0]*(lk+1) for _ in range(ls)] for i in range(ls)]\nfor i in range(ls):\n  dp[i][i][0] = 1\nfor k in range(lk+1):\n  for dis in range(1, ls):\n    for i in range(ls - dis):\n      j = i + dis\n      if s[i] == s[j]:\n        dp[i][j][k] = dp[i+1][j-1][k] + 2\n      elif k:\n        dp[i][j][k] = dp[i+1][j-1][k-1] + 2\n      dp[i][j][k] = max(dp[i][j][k], dp[i+1][j][k], dp[i][j-1][k])\n      \nprint(max(dp[0][ls-1]))\n"
  },
  {
    "language": "Python",
    "code": "S = input()\nK = int(input())\nN = len(S)\n\ndp = [[[0 for _ in range(K+1)] for _ in range(N)] for _ in range(N)]\nfor i in range(N):\n    for k in range(K+1):\n        dp[i][i][k] = 1\n\nfor _j in range(1, N):\n    for i in range(N):\n        j = i + _j\n        if j < N:\n            for k in range(K+1):\n                dp[i][j][k] = max(dp[i][j][k], dp[i+1][j][k], dp[i][j-1][k])\n                if _j == 1:\n                    if S[i] == S[j]:\n                        dp[i][j][k] = 2\n                    else:\n                        if k+1 <= K:\n                            dp[i][j][k+1] = 2\n                else:\n                    if S[i] == S[j]:\n                        dp[i][j][k] = max(dp[i][j][k], dp[i+1][j-1][k] + 2)\n                    else:\n                        if k+1 <= K:\n                            dp[i][j][k+1] = max(dp[i][j][k], dp[i+1][j-1][k] + 2)\n\nprint(max(dp[0][N-1]))\n\n"
  },
  {
    "language": "Python",
    "code": "s = input()\nK = int(input())\nn = len(s)\nt = s[::-1]\ndp = [[[0 for i in range(K+1)] for j in range(n+1)] for k in range(n+1)]\nansls = [min(2*K+1,n)]\nfor center in range(1,n-1):\n  flg = 0\n  sf = s[:center]\n  sl = t[:n-center-1]\n  if s[center] == s[center+1]:\n    flg = 1\n  sfl = len(sf)\n  sll = len(sl)\n  for j in range(1,sll+1):\n    dp[sfl][j][0] = max(dp[sfl-1][j][0],dp[sfl][j-1][0])\n    if sf[-1] != sl[j-1]:\n      for k in range(1,min(K,sll)+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n    if sf[-1] == sl[j-1]:\n      dp[sfl][j][0] = max(dp[sfl][j][0],dp[sfl-1][j-1][0]+1)\n      for k in range(1,min(K,sll)+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j-1][k]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n  ansls.append(max(dp[sfl][sll][min(K,sll)]*2+1,dp[sfl][sll-1][min(K,sll)]*2+1+flg))\nprint(max(ansls))"
  },
  {
    "language": "Python",
    "code": "input = raw_input\nrange = xrange\nn, m, h, v = map(int,input().split())\nremain = [n] * m\nind = 0\nfor i in range(h):\n    for odd in range(1, m, 2):\n        if remain[odd] % 2 == 1: break\n    else:\n        for odd in range(1, m, 2):\n            if remain[odd]: break\n        else: print(\"NO\"); exit()\n    if m == 1: print(\"NO\"); exit()\n    remain[odd]-= 1; remain[odd-1]-= 1\n\nif sum(x//2 for x in remain) < v: print(\"NO\"); exit()\nprint(\"YES\")\ngrid = [[\".\"]*m for i in range(n)]\nfor j in range(0, m, 2):\n    placed = n - remain[j]\n    for i in range(placed):\n        grid[i][j] = \"<\"\n        grid[i][j+1] = \">\"\n    for i in range(placed, n, 2):\n        if i == n-1: break\n        grid[i][j] = \"^\"\n        grid[i+1][j] = \"v\"\n        v-= 1\n        if v == 0:\n            for row in grid: print(''.join(row))\n            exit()\n        if j == m-1: continue\n        grid[i][j+1] = \"^\"\n        grid[i+1][j+1] = \"v\"\n        v-= 1\n        if v == 0:\n            for row in grid: print(''.join(row))\n            exit()"
  },
  {
    "language": "Python",
    "code": "s = input()\nls = len(s)\nlk = int(input())\nif lk*2 >= ls: print(ls); exit(0)\nlk *= 2\ndp = [[[0]*(lk+1) for _ in range(ls+1)] for i in range(ls+1)]\nfor k in range(lk+1):\n  for i in range(ls):\n    for j in range(ls):\n      if s[i] == s[-j-1]:\n        dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i][j][k] + 1)\n      else:\n        dp[i+1][j+1][k] = max(dp[i+1][j+1][k], dp[i+1][j][k], dp[i][j+1][k], (k > 0)*(dp[i][j][k-1] + 1))\nprint(max(dp[ls][ls]))"
  },
  {
    "language": "Python",
    "code": "def main():\n    s = input()\n    n = len(s)\n    k = int(input())\n    # dp[使った回数][左端からの距離][左端]\n    dp = [[[1]*(n-i) for i in range(n)] for _ in range(k+1)]\n\n    if n == 1:\n        print(1)\n        return\n    dp2 = dp[0][1]\n    for i in range(n-1):\n        if s[i] == s[i+1]:\n            dp2[i] = 2\n    if k > 0:\n        for cnt in range(1, k+1):\n            dp2 = dp[cnt][1]\n            for i in range(n-1):\n                dp2[i] = 2\n\n    for cnt in range(k):\n        dp2 = dp[cnt]\n        dp4 = dp[cnt+1]\n        for d in range(2, n):\n            dp3 = dp2[d]\n            dp5 = dp2[d-1]\n            dp6 = dp2[d-2]\n            dp7 = dp4[d]\n            for left in range(n-d):\n                right = left+d\n                plus = (s[left] == s[right])*2\n                dp3[left] = max(\n                    dp3[left], dp5[left],\n                    dp5[left+1], dp6[left+1]+plus)\n                dp7[left] = max(\n                    dp7[left], dp3[left], dp6[left+1]+2)\n    dp2 = dp[k]\n    for d in range(2, n):\n        dp3 = dp2[d]\n        dp4 = dp2[d-1]\n        dp5 = dp2[d-2]\n        for left in range(n-d):\n            right = left+d\n            plus = (s[left] == s[right])*2\n            dp3[left] = max(\n                dp3[left], dp4[left], dp4[left+1], dp5[left+1]+plus)\n    print(dp[-1][-1][0])\n\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "s = input()\nK = int(input())\nn = len(s)\nt = s[::-1]\nif 2*K+1 >= n:\n  print(n)\n  exit()\ndp = [[[0 for i in range(K+1)] for j in range(n+1)] for k in range(n+1)]\nif n == 2 and K == 0:\n  if s == t:\n    print(2)\n  else:\n    print(1)\n    exit()\nans = min(2*K+1,n)\nfor center in range(1,n-1):\n  flg = 0\n  sf = s[:center]\n  sl = t[:n-center-1]\n  if s[center] == s[center+1]:\n    flg = 1\n  sfl = len(sf)\n  sll = len(sl)\n  for j in range(1,sll+1):\n    dp[sfl][j][0] = max(dp[sfl-1][j][0],dp[sfl][j-1][0])\n    if sf[-1] != sl[j-1]:\n      for k in range(1,K+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n    if sf[-1] == sl[j-1]:\n      dp[sfl][j][0] = max(dp[sfl][j][0],dp[sfl-1][j-1][0]+1)\n      for k in range(1,K+1):\n        dp[sfl][j][k] = max(dp[sfl-1][j-1][k-1]+1,dp[sfl-1][j-1][k]+1,dp[sfl-1][j][k],dp[sfl][j-1][k])\n  if flg:\n    ans= max(dp[sfl][sll][K]*2+1,dp[sfl][sll-1][K]*2+2,ans)\n  elif K > 0:\n    ans= max(dp[sfl][sll][K]*2+1,dp[sfl][sll-1][K-1]*2+2,ans)\n  else:\n    ans= max(dp[sfl][sll][K]*2+1,ans)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "s = input()\nn = len(s)\nk = int(input())\n\ndp = [[[0] * (n + 1) for i in range(n + 1)] for i in range(k + 1)]\n\n# 長さ1のときの初期化\nfor i in range(n):\n    dp[0][i][i + 1] = 1\n\n# 長さ2~nのときのDP\nfor length in range(2, n + 1):\n    for l in range(n + 1):\n        for ki in range(k + 1):\n            r = l + length\n            if r > n:\n                break\n            if s[l] == s[r - 1]:\n                dp[ki][l][r] = max(2 + dp[ki][l + 1][r - 1], dp[ki][l][r])\n            else:\n                dp[ki][l][r] = max(dp[ki][l + 1][r], dp[ki][l][r - 1], dp[ki][l][r])\n                if ki - 1 >= 0:\n                    dp[ki][l][r] = max(dp[ki - 1][l + 1][r - 1] + 2, dp[ki - 1][l + 1][r - 1] + 2, dp[ki][l][r])\n\nans = 0\nfor i in range(k + 1):\n    ans = max(ans, dp[i][0][-1])\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.buffer.readline\n\nS = list(input().rstrip())\nK = int(input())\n\nL = len(S)\n\ndef main():\n    dp = [[[0]*(K+1) for _ in range(L+1)] for _ in range(L+1)]\n\n    ans = 0\n    for ind in reversed(range(L)):\n        # [0, ind), [ind, L-1]\n        s = S[ind]\n        for i in range(ind):\n            for k in reversed(range(K+1)):\n                if S[i] == s:\n                    dp[i+1][L-ind][k] = dp[i][L-ind-1][k] + 1\n                else:\n                    dp[i+1][L-ind][k] = max(dp[i][L-ind][k], dp[i+1][L-ind-1][k])\n                    dp[i+1][L-ind][k] = min(dp[i+1][L-ind][k], max(i+1, L-ind))\n                    if k < K:\n                        dp[i+1][L-ind][k+1] = max(dp[i+1][L-ind][k+1], dp[i+1][L-ind][k]+1)\n                        dp[i+1][L-ind][k+1] = min(dp[i+1][L-ind][k+1], max(i+1, L-ind))\n        for k in range(K+1):\n            ans = max(ans, 2*dp[ind][L-ind][k])\n            ans = max(ans, 2*dp[ind][L-ind-1][k] + 1)\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "S=input()\nK=int(input())\nS2=S[::-1]\nl=len(S)\n\ndp=[[0 for x in range(l+1)] for y in range(l+1)]\ntrace=[[0 for x in range(l+1)] for y in range(l+1)]\nfor i in range(l+1):\n  trace[i][0]=-1\n  trace[0][i]=-1\n\nfor i in range(l):\n  for j in range(l):\n    if S[i]==S2[j]:\n      dp[i+1][j+1]=dp[i][j]+1\n      trace[i+1][j+1]=1\n    elif dp[i+1][j] > dp[i][j+1]:\n      dp[i+1][j+1]=dp[i+1][j]\n      trace[i+1][j+1]=2\n    else:\n      dp[i+1][j+1]=dp[i][j+1]\n      trace[i+1][j+1]=3\ncnt=[0 for t in range(l+1)]\ndef tracedo(trace,a,b):\n  if trace[a][b]==-1:\n    return\n  elif trace[a][b]==2:\n    tracedo(trace,a,b-1)\n  elif trace[a][b]==3:\n    tracedo(trace,a-1,b)\n  else:\n    tracedo(trace,a-1,b-1)\n    cnt[a-1]=1\n  return\n\ntracedo(trace,l,l)\nans=0\nfor i in range(l):\n  if cnt[i]==0 and cnt[l-i-1]==0 and i!=(l-i-1):\n    ans+=2\n  elif cnt[i]==0 and cnt[l-i-1]==0 and i==(l-i-1):\n    ans+=1\nprint(dp[l][l]+min(ans,K*2))"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.buffer.readline\n\nS = list(input().rstrip())\nK = int(input())\n\nL = len(S)\n\ndef main():\n    dp = [[[0]*(K+1) for _ in range(L+1)] for _ in range(L+1)]\n\n    ans = 0\n    for ind in reversed(range(L)):\n        # [0, ind), [ind, L-1]\n        s = S[ind]\n        for i in range(ind):\n            for k in reversed(range(K+1)):\n                if S[i] == s:\n                    dp[i+1][L-ind][k] = dp[i][L-ind-1][k] + 1\n                else:\n                    dp[i+1][L-ind][k] = max(dp[i][L-ind][k], dp[i+1][L-ind-1][k])\n                    if k < K:\n                        dp[i+1][L-ind][k+1] = max(dp[i+1][L-ind][k+1], dp[i+1][L-ind][k]+1)\n        for k in range(K+1):\n            ans = max(ans, 2*dp[ind][L-ind][k])\n            ans = max(ans, 2*dp[ind][L-ind-1][k] + 1)\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "import sys\n\nreadline = sys.stdin.buffer.readline\n\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\n\ndef solve():\n  s = list(ns())\n  ls = len(s)\n  lk = ni()\n  dp = [[[0]*ls for _ in range(ls)] for i in range(2)]\n  ans = 0\n  for i in range(ls):\n    dp[0][i][i] = 1\n  for k in range(lk+1):\n    v = k & 1\n    for dis in range(1, ls):\n      for i in range(ls - dis):\n        j = i + dis\n        dp[v][i][j] = 0\n        if s[i] == s[j]:\n          dp[v][i][j] = dp[v][i+1][j-1] + 2\n        elif k:\n          dp[v][i][j] = dp[v^1][i+1][j-1] + 2\n        dp[v][i][j] = max(dp[v][i][j], dp[v][i+1][j], dp[v][i][j-1])\n    ans = max(ans, dp[v][0][-1])\n\n  print(ans)\n  return\n\nsolve()"
  },
  {
    "language": "Python",
    "code": "def solve(s, k):\n    n = len(s)\n    if k >= n // 2:\n        return n\n    pdp = [[0] * (k + 1)]\n    for l in range(1, n + 1):\n        i = n - l\n        dp = [[0] * (k + 1) for _ in range(l + 1)]\n        dpr1, pdpr1 = dp[-1], [0] * (k + 1)\n        for r in range(l):\n            dpr, pdpr = dp[r], pdp[r - 1]\n            inc = 2 if r else 1\n            if s[i] == s[i + r]:\n                for p in range(k + 1):\n                    dp[r] = [c + inc for c in pdpr1]\n            else:\n                dpr[0] = max(pdpr[0], dpr1[0])\n                for p in range(1, k + 1):\n                    dpr[p] = max(pdpr[p], dpr1[p], pdpr1[p - 1] + inc)\n            dpr1, pdpr1 = dpr, pdpr\n        pdp = dp\n\n    return pdp[-2][k]\n\n\nprint(solve(input(), int(input())))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\nS = list(map(ord, readline().strip()))\nN = len(S)\nS = [None] + S + [None]\nK = int(readline())\ndp = [[[0]*(K+1) for _ in range(N+2)] for _ in range(N+2)]\nfor i in range(1, N+1):\n    dp[i][i][0] = 1\nfor i in range(1, N):\n    if S[i] == S[i+1]:\n        dp[i][i+1][0] = 2\n    elif K:\n        dp[i][i+1][0] = 1\n        dp[i][i+1][1] = 2\nfor s in range(3, N+1):\n    for i in range(1, N-s+2):\n        j = i+s-1\n        if S[i] == S[j]:\n            for k in range(K+1):\n                dp[i][j][k] = max(dp[i+1][j][k], dp[i][j-1][k], 2+dp[i+1][j-1][k])\n        else:\n            dp[i][j][0] = max(dp[i+1][j][0], dp[i][j-1][0], dp[i+1][j-1][0])\n            for k in range(1, K+1):\n                dp[i][j][k] = max(dp[i+1][j][k], dp[i][j-1][k], dp[i+1][j-1][k], 2+dp[i+1][j-1][k-1], dp[i+1][j-1][k])\nprint(max(dp[1][N][k] for k in range(K+1)))"
  },
  {
    "language": "Python",
    "code": "def main():\n    s = input()\n    n = len(s)\n    k = int(input())\n    # dp[左端][左端からの右端の距離][使った回数]\n    dp = [[[2]*(k+1) for _ in [0]*(n-i)] for i in range(n)]\n\n    for i in range(n):\n        for cnt in range(k+1):\n            dp[i][0][cnt] = 1\n\n    for i in range(n-1):\n        if s[i] != s[i+1]:\n            dp[i][1][0] = 1\n\n    for cnt in range(k):\n        for d in range(2, n):\n            for left in range(n-d):\n                right = left+d\n                plus = (s[left] == s[right])*2\n                dp[left][d][cnt] = max(\n                    dp[left][d][cnt], dp[left][d-1][cnt],\n                    dp[left+1][d-1][cnt], dp[left+1][d-2][cnt]+plus)\n                dp[left][d][cnt+1] = max(\n                    max(dp[left][d][cnt:cnt+2]), dp[left+1][d-2][cnt]+2)\n    for d in range(2, n):\n        for left in range(n-d):\n            right = left+d\n            plus = (s[left] == s[right])*2\n            dp[left][d][k] = max(\n                dp[left][d][k], dp[left][d-1][k], dp[left+1][d-1][k], dp[left+1][d-2][k]+plus)\n    print(dp[0][-1][-1])\n\n\nmain()"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nimport math\nimport bisect\nimport random\nfrom itertools import permutations, accumulate, combinations, product\nimport sys\nimport string\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial, ceil, floor\nfrom functools import reduce\n\n\nsys.setrecursionlimit(2147483647)\nINF = 10 ** 13\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\ndef I(): return int(sys.stdin.buffer.readline())\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\nmod = 1000000007\n\n\ns = S()\nn = len(s)\nk = I()\ndp = [[[1] * (k + 1) for _ in range(n)] for _ in range(n)]\nfor diff in range(1, n):\n    for l in range(n):\n        for m in range(k + 1):\n            r = l + diff\n            if r >= n:\n                continue\n            if r - l == 1:\n                dp[l][r][m] = 2 if s[l] == s[r] or m else 1\n            elif s[l] == s[r]:\n                dp[l][r][m] = dp[l + 1][r - 1][m] + 2\n            else:\n                dp[l][r][m] = max(dp[l][r][m], dp[l + 1][r][m], dp[l][r - 1][m])\n                if m:\n                    dp[l][r][m] = max(dp[l][r][m], dp[l + 1][r - 1][m - 1] + 2)\n\nprint(dp[0][n - 1][k])\n"
  },
  {
    "language": "Python",
    "code": "def examA():\n    N = I()\n    ans = 0\n    print(ans)\n    return\n\n# 参考 https://atcoder.jp/contests/agc021/submissions/8392122\ndef examB():\n    def norm2(vec):\n        return math.sqrt(vec[0] ** 2 + vec[1] ** 2)\n    # any 2 points must have different position.\n    def ConvexHull(point_list):\n        pos2idx = {point_list[i]: i for i in range(len(point_list))}\n        y_val = defaultdict(list)\n        x_list = sorted(list(set([p[0] for p in point_list])))\n        for x, y in point_list:\n            y_val[x].append(y)\n\n        upper = [(x_list[0], max(y_val[x_list[0]]))]\n        lower = [(x_list[0], min(y_val[x_list[0]]))]\n        prev = float('inf')\n        for xi in x_list[1:]:\n            x0, y0 = upper[-1]\n            x1, y1 = xi, max(y_val[xi])\n            if (y1 - y0) / (x1 - x0) < prev:\n                upper.append((x1, y1))\n                prev = (y1 - y0) / (x1 - x0)\n            else:\n                while True:\n                    x0, y0 = upper[-1]\n                    if len(upper) == 1:\n                        upper.append((x1, y1))\n                        break\n                    x00, y00 = upper[-2]\n                    if (y1 - y0) / (x1 - x0) > (y1 - y00) / (x1 - x00):\n                        upper.pop()\n                    else:\n                        prev = (y1 - y0) / (x1 - x0)\n                        upper.append((x1, y1))\n                        break\n\n        prev = -float('inf')\n        for xi in x_list[1:]:\n            x0, y0 = lower[-1]\n            x1, y1 = xi, min(y_val[xi])\n            if (y1 - y0) / (x1 - x0) > prev:\n                lower.append((x1, y1))\n                prev = (y1 - y0) / (x1 - x0)\n            else:\n                while True:\n                    x0, y0 = lower[-1]\n                    if len(lower) == 1:\n                        lower.append((x1, y1))\n                        break\n                    x00, y00 = lower[-2]\n                    if (y1 - y0) / (x1 - x0) < (y1 - y00) / (x1 - x00):\n                        lower.pop()\n                    else:\n                        prev = (y1 - y0) / (x1 - x0)\n                        lower.append((x1, y1))\n                        break\n\n        # return upper, lower\n        # return [pos2idx[xy] for xy in upper], [pos2idx[xy] for xy in lower]\n\n        upper_idx, lower_idx = [pos2idx[xy] for xy in upper], [pos2idx[xy] for xy in lower]\n        if upper_idx[-1] == lower_idx[-1]:\n            upper_idx.pop()\n        CH_idx = upper_idx\n        CH_idx.extend(reversed(lower_idx))\n        if CH_idx[0] == CH_idx[-1] and len(CH_idx) > 1:\n            CH_idx.pop()\n        return CH_idx\n\n    N = I()\n    P = [[]for _ in range(N)]\n    D = defaultdict(int)\n    for i in range(N):\n        x,y = LI()\n        P[i] = (x,y)\n        D[(x,y)] = i\n    C = ConvexHull(P)\n    ans = [0]*N\n    if len(C)==2:\n        for c in C:\n            ans[c] = 0.5\n        for v in ans:\n            print(v)\n        return\n    #print(C)\n    for i,c in enumerate(C):\n        s, t, u = C[i - 1], C[i], C[(i + 1) % len(C)]\n        x0, y0 = P[s]\n        x1, y1 = P[t]\n        x2, y2 = P[u]\n        vec0 = (y0 - y1, x1 - x0)\n        vec1 = (y1 - y2, x2 - x1)\n        ans[t] =  math.acos((vec0[0] * vec1[0] + vec0[1] * vec1[1]) / (norm2(vec0) * norm2(vec1))) / (2 * math.pi)\n    for v in ans:\n        print(v)\n    return\n\ndef examC():\n    ans = 0\n    print(ans)\n    return\n\ndef examD():\n    S = SI()\n    N = len(S)\n    K = I()\n    if K>150:\n        K = 150\n    dp = [[[0]*(K+1) for _ in range(N)] for i in range(N)]\n    for i in range(N):\n        for j in range(K+1):\n            dp[i][i][j] = 1\n    for i in range(2,N+1):\n        for k in range(K+1):\n            for l,r in enumerate(range(i-1,N)):\n                if S[l]==S[r]:\n                    dp[l][r][k] = dp[l+1][r-1][k] + 2\n                else:\n                    if k>0:\n                        dp[l][r][k] = max(dp[l+1][r][k],dp[l][r-1][k],dp[l+1][r-1][k-1]+2)\n                    else:\n                        dp[l][r][k] = max(dp[l + 1][r][k], dp[l][r - 1][k])\n    ans = max(dp[0][-1])\n    #print(dp)\n    print(ans)\n    return\n\ndef examE():\n    ans = 0\n    print(ans)\n    return\n\ndef examF():\n    ans = 0\n    print(ans)\n    return\n\nfrom decimal import Decimal as dec\nimport sys,bisect,itertools,heapq,math,random\nfrom copy import deepcopy\nfrom heapq import heappop,heappush,heapify\nfrom collections import Counter,defaultdict,deque\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\ndef I(): return int(input())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\ndef DI(): return dec(input())\ndef LDI(): return list(map(dec,sys.stdin.readline().split()))\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef SI(): return sys.stdin.readline().strip()\nglobal mod,mod2,inf,alphabet,_ep\nmod = 10**9 + 7\nmod2 = 998244353\ninf = 10**18\n_ep = 10**(-12)\nalphabet = [chr(ord('a') + i) for i in range(26)]\n\nsys.setrecursionlimit(10**7)\n\nif __name__ == '__main__':\n    examD()\n\n\"\"\"\n142\n12 9 1445 0 1\nasd dfg hj o o\naidn\n\"\"\""
  },
  {
    "language": "Python",
    "code": "import sys\n\nreadline = sys.stdin.buffer.readline\n\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\n\ns = ns()\nls = len(s)\nlk = ni()\ndp = [[[0]*(lk+1) for _ in range(ls)] for i in range(ls)]\nfor i in range(ls):\n  dp[i][i][0] = 1\nfor k in range(lk+1):\n  for dis in range(1, ls):\n    for i in range(ls - dis):\n      j = i + dis\n      if s[i] == s[j]:\n        dp[i][j][k] = dp[i+1][j-1][k] + 2\n      elif k:\n        dp[i][j][k] = dp[i+1][j-1][k-1] + 2\n      dp[i][j][k] = max(dp[i][j][k], dp[i+1][j][k], dp[i][j-1][k])\n      \nprint(max(dp[0][ls-1]))\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/agc021/tasks/agc021_d\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nfn main() {\n    input! {\n        s: chars,\n        c: usize\n    };\n\n    let n = s.len();\n\n    let mut dp = vec![vec![vec![-1; c+1]; n+1]; n];\n    dp[0][n-1][0] = 0;\n    for i in 0..n {\n        for j in (0..n).rev() {\n            if i > j {\n                continue;\n            }\n            for k in 0..c+1 {\n                let base = dp[i][j][k];\n                if base == -1 {\n                    continue;\n                }\n\n                if i == j {\n                    dp[0][n][k] = max(dp[0][n][k], base+1);\n                    continue;\n                }\n\n                if s[i] == s[j] {\n                    dp[i+1][j-1][k] = max(dp[i+1][j-1][k], base+2);\n                } else if k+1 <= c {\n                    dp[i+1][j-1][k+1] = max(dp[i+1][j-1][k+1], base+2);\n                }\n                if i+1 < n {\n                    dp[i+1][j][k] = max(dp[i+1][j][k], base);\n                }\n                if j-1 >= 0 {\n                    dp[i][j-1][k] = max(dp[i][j-1][k], base);\n                }\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in 0..n {\n        for j in 0..n+1 {\n            for k in 0..c+1 {\n                ans = max(ans, dp[i][j][k]);\n            }\n        }\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "const MAX: usize = 310;\nfn main() {\n    let s: Vec<char> = readln();\n    let max_k: usize = readln();\n    let inf: isize = 10000000;\n    let mut dp = vec![vec![vec![-inf; MAX]; MAX]; MAX];\n    dp[1][s.len()][0] = 0;\n    let n = s.len();\n    for l in (1..n + 1).rev() {\n        for i in 0..n - l + 1 {\n            let j = i + l - 1;\n            for k in 0..max_k + 1 {\n                let i = i + 1;\n                let j = j + 1;\n\n                let cur = dp[i][j][k];\n                if cur > -inf {\n                    // TODO: update max function\n                    if i == j {\n                        dp[i + 1][j - 1][k] = max(dp[i + 1][j - 1][k], cur + 1);\n                    } else if s[i - 1] == s[j - 1] {\n                        dp[i + 1][j - 1][k] = max(dp[i + 1][j - 1][k], cur + 2);\n                    } else {\n                        dp[i + 1][j - 1][k + 1] = max(dp[i + 1][j - 1][k + 1], cur + 2);\n                    }\n                    dp[i + 1][j][k] = max(dp[i + 1][j][k], cur);\n                    if j >= 0 {\n                        dp[i][j - 1][k] = max(dp[i][j - 1][k], cur);\n                    }\n                }\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in 0..n + 1 {\n        for j in 0..n + 1 {\n            for k in 0..max_k + 1 {\n                ans = max(ans, dp[i][j][k]);\n            }\n        }\n    }\n\n    if s.len() == 1 {\n        ans = 1;\n    }\n\n    println!(\"{}\", ans);\n}\n\n#[allow(unused_imports)]\nuse std::cmp::{max, min};\n#[allow(unused_imports)]\nuse std::collections::{HashMap, HashSet, VecDeque};\n\npub trait FromLn {\n    fn fromln(s: &str) -> Self;\n}\npub fn readln<T: FromLn>() -> T {\n    let mut buf = String::new();\n    let _ = ::std::io::stdin().read_line(&mut buf).unwrap();\n    T::fromln(buf.trim())\n}\npub fn readlns<T: FromLn>(n: usize) -> Vec<T> {\n    let mut vs = vec![];\n    for _ in 0..n {\n        vs.push(readln());\n    }\n    vs\n}\nmacro_rules! fromln_primitives {\n    ($($t:ty),*) => { $(\n        impl FromLn for $t {\n            fn fromln(s: &str) -> $t {\n                s.parse().unwrap()\n            }\n        }\n    )* }\n}\nfromln_primitives!(\n    String,\n    bool,\n    f32,\n    f64,\n    isize,\n    i8,\n    i16,\n    i32,\n    i64,\n    usize,\n    u8,\n    u16,\n    u32,\n    u64\n);\nimpl<T> FromLn for Vec<T>\nwhere\n    T: FromLn,\n{\n    fn fromln(s: &str) -> Vec<T> {\n        s.split_whitespace().map(T::fromln).collect()\n    }\n}\nimpl FromLn for Vec<char> {\n    fn fromln(s: &str) -> Vec<char> {\n        s.chars().collect()\n    }\n}\nmacro_rules! fromln_tuple {\n    ($($t:ident),*) => {\n        impl<$($t),*> FromLn for ($($t),*) where $($t: FromLn),* {\n            fn fromln(s: &str) -> ($($t),*) {\n                let mut it = s.split_whitespace();\n                let t = ($($t::fromln(it.next().unwrap())),*);\n                assert_eq!(it.next(), None);\n                t\n            }\n        }\n    }\n}\nfromln_tuple!(A, B);\nfromln_tuple!(A, B, C);\nfromln_tuple!(A, B, C, D);\nfromln_tuple!(A, B, C, D, E);\nfromln_tuple!(A, B, C, D, E, F);\nmod comp {\n    pub mod math {\n        pub mod comb {\n            use super::mint::{Mint, MOD};\n            pub struct Comb {\n                fact: Vec<Mint>,\n                factinv: Vec<Mint>,\n            }\n            impl Comb {}\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let c = Comb::new(100);\n                    assert_eq!(Mint::from(336), c.perm(8, 3));\n                    assert_eq!(Mint::from(56), c.comb(8, 3));\n                    assert_eq!(Mint::from(10), c.multi_comb(3, 3));\n                }\n                #[test]\n                fn test_fact() {\n                    let c = Comb::new(100);\n                    let p = 8721234;\n                    let mut f = Mint::from(1);\n                    for i in 1..(p + 1) {\n                        f *= i;\n                    }\n                    assert_eq!(f, c.fact(p));\n                }\n            }\n        }\n        pub mod mint {\n            use std;\n            pub const MOD: u32 = 1000000007;\n            #[derive(Debug, Copy, Clone, Eq)]\n            pub struct Mint {\n                val: u32,\n            }\n            impl<T: Into<Mint>> std::ops::Add<T> for Mint {\n                type Output = Mint;\n                fn add(self, other: T) -> Mint {\n                    let nval = self.val + other.into().val;\n                    Mint {\n                        val: if nval >= MOD { nval - MOD } else { nval },\n                    }\n                }\n            }\n            impl<T: Into<Mint>> std::ops::Sub<T> for Mint {\n                type Output = Mint;\n                fn sub(self, other: T) -> Mint {\n                    let nval = self.val + MOD - other.into().val;\n                    Mint {\n                        val: if nval >= MOD { nval - MOD } else { nval },\n                    }\n                }\n            }\n            impl<T: Into<Mint>> std::ops::Mul<T> for Mint {\n                type Output = Mint;\n                fn mul(self, other: T) -> Mint {\n                    let nval = self.val as u64 * other.into().val as u64;\n                    Mint {\n                        val: (nval % (MOD as u64)) as u32,\n                    }\n                }\n            }\n            impl<T: Into<Mint>> std::ops::Div<T> for Mint {\n                type Output = Mint;\n                fn div(self, other: T) -> Mint {\n                    self * other.into().inv()\n                }\n            }\n            impl Mint {\n                pub fn inv(self) -> Mint {\n                    let mut a = self.val as i32;\n                    let mut b = MOD as i32;\n                    let mut u = 1 as i32;\n                    let mut v = 0 as i32;\n                    while b != 0 {\n                        let t = a / b;\n                        a -= t * b;\n                        std::mem::swap(&mut a, &mut b);\n                        u -= t * v;\n                        std::mem::swap(&mut u, &mut v);\n                    }\n                    Mint {\n                        val: if u < 0 { u + MOD as i32 } else { u } as u32,\n                    }\n                }\n            }\n            impl PartialEq for Mint {\n                fn eq(&self, other: &Mint) -> bool {\n                    self.val == other.val\n                }\n            }\n            impl std::fmt::Display for Mint {\n                fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n                    self.val.fmt(f)\n                }\n            }\n            macro_rules! impl_signed_mint(( $ ( $ t : ty ) * ) => (\n                                      $ (\n                                      impl From < $ t > for Mint {\n                                      # [ inline ] fn from ( x : $ t ) -> Mint\n                                      {\n                                      let t = ( x as i64 ) % ( MOD as i64 ) ;\n                                      if x >= 0 { Mint { val : t as u32 } }\n                                      else {\n                                      Mint { val : ( MOD as i64 + t ) as u32 }\n                                      } } } ) * ));\n            macro_rules! impl_unsigned_mint(( $ ( $ t : ty ) * ) => (\n                                        $ (\n                                        impl From < $ t > for Mint {\n                                        # [ inline ] fn from ( x : $ t ) ->\n                                        Mint {\n                                        let t = x as u64 % MOD as u64 ; Mint {\n                                        val : t as u32 } } } ) * ));\n            impl_signed_mint! (i8 i16 i32 i64 isize);\n            impl_unsigned_mint! (u8 u16 u32 u64 usize);\n            impl<T: Into<Mint>> std::ops::AddAssign<T> for Mint {\n                fn add_assign(&mut self, other: T) {\n                    *self = *self + other.into();\n                }\n            }\n            impl<T: Into<Mint>> std::ops::SubAssign<T> for Mint {\n                fn sub_assign(&mut self, other: T) {\n                    *self = *self - other.into();\n                }\n            }\n            impl<T: Into<Mint>> std::ops::MulAssign<T> for Mint {\n                fn mul_assign(&mut self, other: T) {\n                    *self = *self * other.into();\n                }\n            }\n            impl<T: Into<Mint>> std::ops::DivAssign<T> for Mint {\n                fn div_assign(&mut self, other: T) {\n                    *self = *self / other.into();\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let a: Mint = Mint::from(3);\n                    let b: Mint = Mint::from(1000000000);\n                    assert_eq!(Mint::from(3000000000u64 % MOD as u64), a * b);\n                }\n            }\n        }\n        pub mod prime {\n            #[derive(Copy, Clone, PartialEq, PartialOrd, Ord, Eq, Debug)]\n            struct U128 {\n                hi: u64,\n                lo: u64,\n            }\n        }\n    }\n    pub mod data_structure {\n        pub mod bit {\n            pub struct BIT {\n                tree: Vec<i64>,\n            }\n            pub struct BITRange {\n                bit0: BIT,\n                bit1: BIT,\n            }\n            impl BIT {}\n            impl BITRange {}\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let mut bit = BIT::new(10);\n                    bit.add(2, 1);\n                    bit.add(3, 3);\n                    bit.add(5, 10);\n                    bit.add(0, -4);\n                    bit.add(9, -5);\n                    assert_eq!(5, bit.get(0, 10));\n                    assert_eq!(4, bit.get(2, 4));\n                    assert_eq!(1, bit.get(2, 3));\n                    assert_eq!(0, bit.get(2, 2));\n                    assert_eq!(0, bit.get(2, 0));\n                    assert_eq!(-4, bit.get(0, 1));\n                    assert_eq!(5, bit.get(5, 10));\n                    let mut bit = BITRange::new(10);\n                    bit.add(1, 3, 1);\n                    bit.add(2, 5, 2);\n                    assert_eq!(1, bit.get(1, 2));\n                    assert_eq!(4, bit.get(1, 3));\n                    assert_eq!(6, bit.get(1, 4));\n                    assert_eq!(6, bit.get(0, 4));\n                }\n            }\n        }\n        pub mod union_find {\n            pub struct UnionFind {\n                data: Vec<i32>,\n            }\n            impl UnionFind {}\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let mut uf = UnionFind::new(3);\n                    assert_eq!(1, uf.size(0));\n                    assert_eq!(1, uf.size(1));\n                    assert_eq!(1, uf.size(2));\n                    assert_eq!(0, uf.root(0));\n                    assert_eq!(1, uf.root(1));\n                    assert_eq!(2, uf.root(2));\n                    assert!(!uf.same(1, 2));\n                    uf.unite(1, 2);\n                    assert_ne!(uf.root(0), uf.root(2));\n                    assert_eq!(uf.root(1), uf.root(2));\n                    assert_eq!(1, uf.size(0));\n                    assert_eq!(2, uf.size(1));\n                    assert_eq!(2, uf.size(2));\n                    assert!(uf.same(1, 2));\n                    uf.unite(0, 1);\n                    assert_eq!(uf.root(0), uf.root(2));\n                    assert_eq!(uf.root(1), uf.root(2));\n                    assert_eq!(3, uf.size(0));\n                    assert_eq!(3, uf.size(1));\n                    assert_eq!(3, uf.size(2));\n                    assert!(uf.same(1, 2));\n                    assert!(uf.same(0, 2));\n                }\n            }\n        }\n    }\n    pub mod util {\n        pub mod permutation {\n            pub trait Permutation {\n                fn next_permutation(&mut self) -> bool;\n                fn prev_permutation(&mut self) -> bool;\n            }\n            impl<T> Permutation for [T]\n            where\n                T: Ord,\n            {\n                fn next_permutation(&mut self) -> bool {\n                    if self.len() <= 1 {\n                        return false;\n                    }\n                    let mut i = self.len() - 1;\n                    while i > 0 && self[i - 1] >= self[i] {\n                        i -= 1;\n                    }\n                    if i == 0 {\n                        return false;\n                    }\n                    let mut j = self.len() - 1;\n                    while self[j] <= self[i - 1] {\n                        j -= 1;\n                    }\n                    self.swap(j, i - 1);\n                    self[i..].reverse();\n                    true\n                }\n                fn prev_permutation(&mut self) -> bool {\n                    if self.len() <= 1 {\n                        return false;\n                    }\n                    let mut i = self.len() - 1;\n                    while i > 0 && self[i - 1] <= self[i] {\n                        i -= 1;\n                    }\n                    if i == 0 {\n                        return false;\n                    }\n                    self[i..].reverse();\n                    let mut j = self.len() - 1;\n                    while self[j - 1] < self[i - 1] {\n                        j -= 1;\n                    }\n                    self.swap(i - 1, j);\n                    true\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let mut data = [0, 0, 1, 1, 2];\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 2, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 0, 2, 1, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 1, 2]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 2, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 1, 0, 2]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 2, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 1, 2]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 2, 1, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 2, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 1, 2]);\n                    assert!(!data.prev_permutation());\n                }\n            }\n        }\n        pub mod rand {\n            use std::{marker, mem};\n            use std::io::{self, Read};\n            use std::fs::File;\n            use std::char;\n            #[derive(Debug, Clone, Copy)]\n            pub struct Xoroshiro128Rng {\n                state: [u64; 2],\n            }\n            impl Xoroshiro128Rng {}\n            impl Rng for Xoroshiro128Rng {\n                fn next_u32(&mut self) -> u32 {\n                    self.next_u64() as u32\n                }\n                fn next_u64(&mut self) -> u64 {\n                    let s0: u64 = self.state[0];\n                    let mut s1: u64 = self.state[1];\n                    let result: u64 = s0.wrapping_add(s1);\n                    s1 ^= s0;\n                    self.state[0] = s0.rotate_left(55) ^ s1 ^ (s1 << 14);\n                    self.state[1] = s1.rotate_left(36);\n                    result\n                }\n            }\n            pub trait Rand: Sized {\n                fn rand<R: Rng>(rng: &mut R) -> Self;\n            }\n            pub trait Rng {\n                fn next_u32(&mut self) -> u32;\n                fn next_u64(&mut self) -> u64 {\n                    let x = self.next_u32() as u64;\n                    let y = self.next_u32() as u64;\n                    (y << 32) | x\n                }\n                fn next_f32(&mut self) -> f32 {\n                    const UPPER_MASK: u32 = 1065353216;\n                    const LOWER_MASK: u32 = 8388607;\n                    let tmp = UPPER_MASK | (self.next_u32() & LOWER_MASK);\n                    let result: f32 = unsafe { mem::transmute(tmp) };\n                    result - 1.0\n                }\n                fn next_f64(&mut self) -> f64 {\n                    const UPPER_MASK: u64 = 4607182418800017408;\n                    const LOWER_MASK: u64 = 4503599627370495;\n                    let tmp = UPPER_MASK | (self.next_u64() & LOWER_MASK);\n                    let result: f64 = unsafe { mem::transmute(tmp) };\n                    result - 1.0\n                }\n                #[inline(always)]\n                fn gen<T: Rand>(&mut self) -> T\n                where\n                    Self: Sized,\n                {\n                    Rand::rand(self)\n                }\n                fn gen_iter<'a, T: Rand>(&'a mut self) -> Generator<'a, T, Self>\n                where\n                    Self: Sized,\n                {\n                    Generator {\n                        rng: self,\n                        _marker: marker::PhantomData,\n                    }\n                }\n                fn shuffle<T>(&mut self, values: &mut [T])\n                where\n                    Self: Sized,\n                {\n                    let mut i = values.len();\n                    while i >= 2 {\n                        i -= 1;\n                        values.swap(i, (self.next_u64() as usize) % i);\n                    }\n                }\n            }\n            #[derive(Debug)]\n            pub struct Generator<'a, T, R: 'a> {\n                rng: &'a mut R,\n                _marker: marker::PhantomData<fn() -> T>,\n            }\n            impl<'a, T: Rand, R: Rng> Iterator for Generator<'a, T, R> {\n                type Item = T;\n                fn next(&mut self) -> Option<T> {\n                    Some(self.rng.gen())\n                }\n            }\n            pub struct OsRng {\n                reader: File,\n            }\n            impl OsRng {}\n            impl Rng for OsRng {\n                fn next_u32(&mut self) -> u32 {\n                    let mut dest = [0u8; 4];\n                    self.reader.read_exact(&mut dest).unwrap();\n                    unsafe { mem::transmute::<[u8; 4], u32>(dest) }\n                }\n            }\n            impl Rand for isize {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> isize {\n                    if mem::size_of::<isize>() == 4 {\n                        rng.gen::<i32>() as isize\n                    } else {\n                        rng.gen::<i64>() as isize\n                    }\n                }\n            }\n            impl Rand for i8 {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> i8 {\n                    rng.next_u32() as i8\n                }\n            }\n            impl Rand for i16 {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> i16 {\n                    rng.next_u32() as i16\n                }\n            }\n            impl Rand for i32 {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> i32 {\n                    rng.next_u32() as i32\n                }\n            }\n            impl Rand for i64 {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> i64 {\n                    rng.next_u64() as i64\n                }\n            }\n            #[cfg(feature = \"i128_support\")]\n            impl Rand for i128 {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> i128 {\n                    rng.gen::<u128>() as i128\n                }\n            }\n            impl Rand for usize {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> usize {\n                    if mem::size_of::<usize>() == 4 {\n                        rng.gen::<u32>() as usize\n                    } else {\n                        rng.gen::<u64>() as usize\n                    }\n                }\n            }\n            impl Rand for u8 {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> u8 {\n                    rng.next_u32() as u8\n                }\n            }\n            impl Rand for u16 {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> u16 {\n                    rng.next_u32() as u16\n                }\n            }\n            impl Rand for u32 {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> u32 {\n                    rng.next_u32()\n                }\n            }\n            impl Rand for u64 {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> u64 {\n                    rng.next_u64()\n                }\n            }\n            #[cfg(feature = \"i128_support\")]\n            impl Rand for u128 {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> u128 {\n                    ((rng.next_u64() as u128) << 64) | (rng.next_u64() as u128)\n                }\n            }\n            impl Rand for f64 {\n                fn rand<R: Rng>(rng: &mut R) -> f64 {\n                    rng.next_f64()\n                }\n            }\n            impl Rand for f32 {\n                fn rand<R: Rng>(rng: &mut R) -> f32 {\n                    rng.next_f32()\n                }\n            }\n            impl Rand for char {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> char {\n                    const CHAR_MASK: u32 = 2097151;\n                    loop {\n                        match char::from_u32(rng.next_u32() & CHAR_MASK) {\n                            Some(c) => return c,\n                            None => {}\n                        }\n                    }\n                }\n            }\n            impl Rand for bool {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> bool {\n                    rng.gen::<u8>() & 1 == 1\n                }\n            }\n            macro_rules! tuple_impl(( $ ( $ tyvar : ident ) , * ) => {\n                                impl < $ ( $ tyvar : Rand ) , * > Rand for (\n                                $ ( $ tyvar ) , * , ) {\n                                # [ inline ] fn rand < R : Rng > (\n                                _rng : & mut R ) -> ( $ ( $ tyvar ) , * , ) {\n                                ( $ ( _rng . gen :: < $ tyvar > (  ) ) , * , )\n                                } } });\n            impl Rand for () {\n                #[inline]\n                fn rand<R: Rng>(_: &mut R) -> () {\n                    ()\n                }\n            }\n            tuple_impl!(A);\n            tuple_impl!(A, B);\n            tuple_impl!(A, B, C);\n            tuple_impl!(A, B, C, D);\n            tuple_impl!(A, B, C, D, E);\n            tuple_impl!(A, B, C, D, E, F);\n            tuple_impl!(A, B, C, D, E, F, G);\n            tuple_impl!(A, B, C, D, E, F, G, H);\n            tuple_impl!(A, B, C, D, E, F, G, H, I);\n            tuple_impl!(A, B, C, D, E, F, G, H, I, J);\n            tuple_impl!(A, B, C, D, E, F, G, H, I, J, K);\n            tuple_impl!(A, B, C, D, E, F, G, H, I, J, K, L);\n            macro_rules! array_impl({\n                                $ n : expr , $ t : ident , $ ( $ ts : ident ,\n                                ) * } => {\n                                array_impl ! { ( $ n - 1 ) , $ ( $ ts , ) * }\n                                impl < T > Rand for [ T ; $ n ] where T : Rand\n                                {\n                                # [ inline ] fn rand < R : Rng > (\n                                _rng : & mut R ) -> [ T ; $ n ] {\n                                [\n                                _rng . gen :: < $ t > (  ) , $ (\n                                _rng . gen :: < $ ts > (  ) ) , * ] } } } ; {\n                                $ n : expr , } => {\n                                impl < T > Rand for [ T ; $ n ] {\n                                fn rand < R : Rng > ( _rng : & mut R ) -> [\n                                T ; $ n ] { [  ] } } } ;);\n            array_impl!(\n                32,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n            );\n            impl<T: Rand> Rand for Option<T> {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> Option<T> {\n                    if rng.gen() {\n                        Some(rng.gen())\n                    } else {\n                        None\n                    }\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/agc021/tasks/agc021_d\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::io::Write;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\n// Input macros.\n// Original by tanakh: https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n\n    ($iter:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, switch) => {\n        {\n            let ty = read_value!($iter, i32);\n            if ty == 1 {\n                vec![ty, read_value!($iter, i32), read_value!($iter, i32)]\n            } else if ty == 2 {\n                vec![ty, read_value!($iter, i32)]\n            } else {\n                vec![ty, read_value!($iter, i32)]\n            }\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_line {\n    ($t:tt) => {\n        {\n            let mut s = String::new();\n            std::io::stdin().read_line(&mut s).unwrap();\n            s.trim_right().parse::<$t>().unwrap()\n        }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! join {\n    ($t:expr, $glue:expr) => {\n        $t.into_iter().map(|w| w.to_string()).collect::<Vec<_>>().join($glue)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n// ===\n\nfn main() {\n    input! {\n        s: chars,\n        m: usize\n    };\n    let n = s.len();\n    let mut dp = dvec!(-1; n, n, m+1);\n\n    let mut best = 0;\n\n    dp[0][n-1][0] = 0;\n    for i in 0..n {\n        for j in (0..n).rev() {\n            for k in 0..m+1 {\n                if dp[i][j][k] == -1 {\n                    continue;\n                }\n                let base = dp[i][j][k];\n                best = max(best, base);\n                if i == j {\n                    best = max(best, base+1);\n                    continue;\n                } else if i > j {\n                    continue;\n                }\n\n                if s[i] == s[j] {\n                    dp[i+1][j-1][k] = max(dp[i+1][j-1][k], base+2);\n                }\n                if k+1 <= m {\n                    dp[i+1][j-1][k+1] = max(dp[i+1][j-1][k+1], base+2);\n                }\n                dp[i+1][j][k] = max(dp[i+1][j][k], base);\n                dp[i][j-1][k] = max(dp[i][j-1][k], base);\n            }\n        }\n    }\n    println!(\"{}\", best);\n}\n"
  },
  {
    "language": "Rust",
    "code": "const MAX: usize = 303;\nfn main() {\n    let s: Vec<char> = readln();\n    let max_k: usize = readln();\n    let inf: isize = 10000000;\n    let mut dp = vec![vec![vec![-inf; MAX]; MAX]; MAX];\n    dp[1][s.len()][0] = 0;\n    let n = s.len();\n    for l in (1..n + 1).rev() {\n        for i in 0..n - l + 1 {\n            let j = i + l - 1;\n            for k in 0..max_k + 1 {\n                let i = i + 1;\n                let j = j + 1;\n\n                let cur = dp[i][j][k];\n                if cur > -inf {\n                    // TODO: update max function\n                    if i == j {\n                        dp[i + 1][j - 1][k] = max(dp[i + 1][j - 1][k], cur + 1);\n                    } else if s[i - 1] == s[j - 1] {\n                        dp[i + 1][j - 1][k] = max(dp[i + 1][j - 1][k], cur + 2);\n                    } else {\n                        dp[i + 1][j - 1][k + 1] = max(dp[i + 1][j - 1][k + 1], cur + 2);\n                    }\n                    dp[i + 1][j][k] = max(dp[i + 1][j][k], cur);\n                    if j >= 0 {\n                        dp[i][j - 1][k] = max(dp[i][j - 1][k], cur);\n                    }\n                }\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in 0..n + 1 {\n        for j in 0..n + 1 {\n            for k in 0..max_k + 1 {\n                ans = max(ans, dp[i][j][k]);\n            }\n        }\n    }\n    println!(\"{}\", ans);\n}\n\n#[allow(unused_imports)]\nuse std::cmp::{max, min};\n#[allow(unused_imports)]\nuse std::collections::{HashMap, HashSet, VecDeque};\n\npub trait FromLn {\n    fn fromln(s: &str) -> Self;\n}\npub fn readln<T: FromLn>() -> T {\n    let mut buf = String::new();\n    let _ = ::std::io::stdin().read_line(&mut buf).unwrap();\n    T::fromln(buf.trim())\n}\npub fn readlns<T: FromLn>(n: usize) -> Vec<T> {\n    let mut vs = vec![];\n    for _ in 0..n {\n        vs.push(readln());\n    }\n    vs\n}\nmacro_rules! fromln_primitives {\n    ($($t:ty),*) => { $(\n        impl FromLn for $t {\n            fn fromln(s: &str) -> $t {\n                s.parse().unwrap()\n            }\n        }\n    )* }\n}\nfromln_primitives!(\n    String,\n    bool,\n    f32,\n    f64,\n    isize,\n    i8,\n    i16,\n    i32,\n    i64,\n    usize,\n    u8,\n    u16,\n    u32,\n    u64\n);\nimpl<T> FromLn for Vec<T>\nwhere\n    T: FromLn,\n{\n    fn fromln(s: &str) -> Vec<T> {\n        s.split_whitespace().map(T::fromln).collect()\n    }\n}\nimpl FromLn for Vec<char> {\n    fn fromln(s: &str) -> Vec<char> {\n        s.chars().collect()\n    }\n}\nmacro_rules! fromln_tuple {\n    ($($t:ident),*) => {\n        impl<$($t),*> FromLn for ($($t),*) where $($t: FromLn),* {\n            fn fromln(s: &str) -> ($($t),*) {\n                let mut it = s.split_whitespace();\n                let t = ($($t::fromln(it.next().unwrap())),*);\n                assert_eq!(it.next(), None);\n                t\n            }\n        }\n    }\n}\nfromln_tuple!(A, B);\nfromln_tuple!(A, B, C);\nfromln_tuple!(A, B, C, D);\nfromln_tuple!(A, B, C, D, E);\nfromln_tuple!(A, B, C, D, E, F);\nmod comp {\n    pub mod math {\n        pub mod comb {\n            use super::mint::{Mint, MOD};\n            pub struct Comb {\n                fact: Vec<Mint>,\n                factinv: Vec<Mint>,\n            }\n            impl Comb {}\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let c = Comb::new(100);\n                    assert_eq!(Mint::from(336), c.perm(8, 3));\n                    assert_eq!(Mint::from(56), c.comb(8, 3));\n                    assert_eq!(Mint::from(10), c.multi_comb(3, 3));\n                }\n                #[test]\n                fn test_fact() {\n                    let c = Comb::new(100);\n                    let p = 8721234;\n                    let mut f = Mint::from(1);\n                    for i in 1..(p + 1) {\n                        f *= i;\n                    }\n                    assert_eq!(f, c.fact(p));\n                }\n            }\n        }\n        pub mod mint {\n            use std;\n            pub const MOD: u32 = 1000000007;\n            #[derive(Debug, Copy, Clone, Eq)]\n            pub struct Mint {\n                val: u32,\n            }\n            impl<T: Into<Mint>> std::ops::Add<T> for Mint {\n                type Output = Mint;\n                fn add(self, other: T) -> Mint {\n                    let nval = self.val + other.into().val;\n                    Mint {\n                        val: if nval >= MOD { nval - MOD } else { nval },\n                    }\n                }\n            }\n            impl<T: Into<Mint>> std::ops::Sub<T> for Mint {\n                type Output = Mint;\n                fn sub(self, other: T) -> Mint {\n                    let nval = self.val + MOD - other.into().val;\n                    Mint {\n                        val: if nval >= MOD { nval - MOD } else { nval },\n                    }\n                }\n            }\n            impl<T: Into<Mint>> std::ops::Mul<T> for Mint {\n                type Output = Mint;\n                fn mul(self, other: T) -> Mint {\n                    let nval = self.val as u64 * other.into().val as u64;\n                    Mint {\n                        val: (nval % (MOD as u64)) as u32,\n                    }\n                }\n            }\n            impl<T: Into<Mint>> std::ops::Div<T> for Mint {\n                type Output = Mint;\n                fn div(self, other: T) -> Mint {\n                    self * other.into().inv()\n                }\n            }\n            impl Mint {\n                pub fn inv(self) -> Mint {\n                    let mut a = self.val as i32;\n                    let mut b = MOD as i32;\n                    let mut u = 1 as i32;\n                    let mut v = 0 as i32;\n                    while b != 0 {\n                        let t = a / b;\n                        a -= t * b;\n                        std::mem::swap(&mut a, &mut b);\n                        u -= t * v;\n                        std::mem::swap(&mut u, &mut v);\n                    }\n                    Mint {\n                        val: if u < 0 { u + MOD as i32 } else { u } as u32,\n                    }\n                }\n            }\n            impl PartialEq for Mint {\n                fn eq(&self, other: &Mint) -> bool {\n                    self.val == other.val\n                }\n            }\n            impl std::fmt::Display for Mint {\n                fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n                    self.val.fmt(f)\n                }\n            }\n            macro_rules! impl_signed_mint(( $ ( $ t : ty ) * ) => (\n                                      $ (\n                                      impl From < $ t > for Mint {\n                                      # [ inline ] fn from ( x : $ t ) -> Mint\n                                      {\n                                      let t = ( x as i64 ) % ( MOD as i64 ) ;\n                                      if x >= 0 { Mint { val : t as u32 } }\n                                      else {\n                                      Mint { val : ( MOD as i64 + t ) as u32 }\n                                      } } } ) * ));\n            macro_rules! impl_unsigned_mint(( $ ( $ t : ty ) * ) => (\n                                        $ (\n                                        impl From < $ t > for Mint {\n                                        # [ inline ] fn from ( x : $ t ) ->\n                                        Mint {\n                                        let t = x as u64 % MOD as u64 ; Mint {\n                                        val : t as u32 } } } ) * ));\n            impl_signed_mint! (i8 i16 i32 i64 isize);\n            impl_unsigned_mint! (u8 u16 u32 u64 usize);\n            impl<T: Into<Mint>> std::ops::AddAssign<T> for Mint {\n                fn add_assign(&mut self, other: T) {\n                    *self = *self + other.into();\n                }\n            }\n            impl<T: Into<Mint>> std::ops::SubAssign<T> for Mint {\n                fn sub_assign(&mut self, other: T) {\n                    *self = *self - other.into();\n                }\n            }\n            impl<T: Into<Mint>> std::ops::MulAssign<T> for Mint {\n                fn mul_assign(&mut self, other: T) {\n                    *self = *self * other.into();\n                }\n            }\n            impl<T: Into<Mint>> std::ops::DivAssign<T> for Mint {\n                fn div_assign(&mut self, other: T) {\n                    *self = *self / other.into();\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let a: Mint = Mint::from(3);\n                    let b: Mint = Mint::from(1000000000);\n                    assert_eq!(Mint::from(3000000000u64 % MOD as u64), a * b);\n                }\n            }\n        }\n        pub mod prime {\n            #[derive(Copy, Clone, PartialEq, PartialOrd, Ord, Eq, Debug)]\n            struct U128 {\n                hi: u64,\n                lo: u64,\n            }\n        }\n    }\n    pub mod data_structure {\n        pub mod bit {\n            pub struct BIT {\n                tree: Vec<i64>,\n            }\n            pub struct BITRange {\n                bit0: BIT,\n                bit1: BIT,\n            }\n            impl BIT {}\n            impl BITRange {}\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let mut bit = BIT::new(10);\n                    bit.add(2, 1);\n                    bit.add(3, 3);\n                    bit.add(5, 10);\n                    bit.add(0, -4);\n                    bit.add(9, -5);\n                    assert_eq!(5, bit.get(0, 10));\n                    assert_eq!(4, bit.get(2, 4));\n                    assert_eq!(1, bit.get(2, 3));\n                    assert_eq!(0, bit.get(2, 2));\n                    assert_eq!(0, bit.get(2, 0));\n                    assert_eq!(-4, bit.get(0, 1));\n                    assert_eq!(5, bit.get(5, 10));\n                    let mut bit = BITRange::new(10);\n                    bit.add(1, 3, 1);\n                    bit.add(2, 5, 2);\n                    assert_eq!(1, bit.get(1, 2));\n                    assert_eq!(4, bit.get(1, 3));\n                    assert_eq!(6, bit.get(1, 4));\n                    assert_eq!(6, bit.get(0, 4));\n                }\n            }\n        }\n        pub mod union_find {\n            pub struct UnionFind {\n                data: Vec<i32>,\n            }\n            impl UnionFind {}\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let mut uf = UnionFind::new(3);\n                    assert_eq!(1, uf.size(0));\n                    assert_eq!(1, uf.size(1));\n                    assert_eq!(1, uf.size(2));\n                    assert_eq!(0, uf.root(0));\n                    assert_eq!(1, uf.root(1));\n                    assert_eq!(2, uf.root(2));\n                    assert!(!uf.same(1, 2));\n                    uf.unite(1, 2);\n                    assert_ne!(uf.root(0), uf.root(2));\n                    assert_eq!(uf.root(1), uf.root(2));\n                    assert_eq!(1, uf.size(0));\n                    assert_eq!(2, uf.size(1));\n                    assert_eq!(2, uf.size(2));\n                    assert!(uf.same(1, 2));\n                    uf.unite(0, 1);\n                    assert_eq!(uf.root(0), uf.root(2));\n                    assert_eq!(uf.root(1), uf.root(2));\n                    assert_eq!(3, uf.size(0));\n                    assert_eq!(3, uf.size(1));\n                    assert_eq!(3, uf.size(2));\n                    assert!(uf.same(1, 2));\n                    assert!(uf.same(0, 2));\n                }\n            }\n        }\n    }\n    pub mod util {\n        pub mod permutation {\n            pub trait Permutation {\n                fn next_permutation(&mut self) -> bool;\n                fn prev_permutation(&mut self) -> bool;\n            }\n            impl<T> Permutation for [T]\n            where\n                T: Ord,\n            {\n                fn next_permutation(&mut self) -> bool {\n                    if self.len() <= 1 {\n                        return false;\n                    }\n                    let mut i = self.len() - 1;\n                    while i > 0 && self[i - 1] >= self[i] {\n                        i -= 1;\n                    }\n                    if i == 0 {\n                        return false;\n                    }\n                    let mut j = self.len() - 1;\n                    while self[j] <= self[i - 1] {\n                        j -= 1;\n                    }\n                    self.swap(j, i - 1);\n                    self[i..].reverse();\n                    true\n                }\n                fn prev_permutation(&mut self) -> bool {\n                    if self.len() <= 1 {\n                        return false;\n                    }\n                    let mut i = self.len() - 1;\n                    while i > 0 && self[i - 1] <= self[i] {\n                        i -= 1;\n                    }\n                    if i == 0 {\n                        return false;\n                    }\n                    self[i..].reverse();\n                    let mut j = self.len() - 1;\n                    while self[j - 1] < self[i - 1] {\n                        j -= 1;\n                    }\n                    self.swap(i - 1, j);\n                    true\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let mut data = [0, 0, 1, 1, 2];\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 2, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 0, 2, 1, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 1, 2]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 2, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 1, 0, 2]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 2, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 1, 2]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 2, 1, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 2, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 1, 2]);\n                    assert!(!data.prev_permutation());\n                }\n            }\n        }\n        pub mod rand {\n            use std::{marker, mem};\n            use std::io::{self, Read};\n            use std::fs::File;\n            use std::char;\n            #[derive(Debug, Clone, Copy)]\n            pub struct Xoroshiro128Rng {\n                state: [u64; 2],\n            }\n            impl Xoroshiro128Rng {}\n            impl Rng for Xoroshiro128Rng {\n                fn next_u32(&mut self) -> u32 {\n                    self.next_u64() as u32\n                }\n                fn next_u64(&mut self) -> u64 {\n                    let s0: u64 = self.state[0];\n                    let mut s1: u64 = self.state[1];\n                    let result: u64 = s0.wrapping_add(s1);\n                    s1 ^= s0;\n                    self.state[0] = s0.rotate_left(55) ^ s1 ^ (s1 << 14);\n                    self.state[1] = s1.rotate_left(36);\n                    result\n                }\n            }\n            pub trait Rand: Sized {\n                fn rand<R: Rng>(rng: &mut R) -> Self;\n            }\n            pub trait Rng {\n                fn next_u32(&mut self) -> u32;\n                fn next_u64(&mut self) -> u64 {\n                    let x = self.next_u32() as u64;\n                    let y = self.next_u32() as u64;\n                    (y << 32) | x\n                }\n                fn next_f32(&mut self) -> f32 {\n                    const UPPER_MASK: u32 = 1065353216;\n                    const LOWER_MASK: u32 = 8388607;\n                    let tmp = UPPER_MASK | (self.next_u32() & LOWER_MASK);\n                    let result: f32 = unsafe { mem::transmute(tmp) };\n                    result - 1.0\n                }\n                fn next_f64(&mut self) -> f64 {\n                    const UPPER_MASK: u64 = 4607182418800017408;\n                    const LOWER_MASK: u64 = 4503599627370495;\n                    let tmp = UPPER_MASK | (self.next_u64() & LOWER_MASK);\n                    let result: f64 = unsafe { mem::transmute(tmp) };\n                    result - 1.0\n                }\n                #[inline(always)]\n                fn gen<T: Rand>(&mut self) -> T\n                where\n                    Self: Sized,\n                {\n                    Rand::rand(self)\n                }\n                fn gen_iter<'a, T: Rand>(&'a mut self) -> Generator<'a, T, Self>\n                where\n                    Self: Sized,\n                {\n                    Generator {\n                        rng: self,\n                        _marker: marker::PhantomData,\n                    }\n                }\n                fn shuffle<T>(&mut self, values: &mut [T])\n                where\n                    Self: Sized,\n                {\n                    let mut i = values.len();\n                    while i >= 2 {\n                        i -= 1;\n                        values.swap(i, (self.next_u64() as usize) % i);\n                    }\n                }\n            }\n            #[derive(Debug)]\n            pub struct Generator<'a, T, R: 'a> {\n                rng: &'a mut R,\n                _marker: marker::PhantomData<fn() -> T>,\n            }\n            impl<'a, T: Rand, R: Rng> Iterator for Generator<'a, T, R> {\n                type Item = T;\n                fn next(&mut self) -> Option<T> {\n                    Some(self.rng.gen())\n                }\n            }\n            pub struct OsRng {\n                reader: File,\n            }\n            impl OsRng {}\n            impl Rng for OsRng {\n                fn next_u32(&mut self) -> u32 {\n                    let mut dest = [0u8; 4];\n                    self.reader.read_exact(&mut dest).unwrap();\n                    unsafe { mem::transmute::<[u8; 4], u32>(dest) }\n                }\n            }\n            impl Rand for isize {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> isize {\n                    if mem::size_of::<isize>() == 4 {\n                        rng.gen::<i32>() as isize\n                    } else {\n                        rng.gen::<i64>() as isize\n                    }\n                }\n            }\n            impl Rand for i8 {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> i8 {\n                    rng.next_u32() as i8\n                }\n            }\n            impl Rand for i16 {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> i16 {\n                    rng.next_u32() as i16\n                }\n            }\n            impl Rand for i32 {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> i32 {\n                    rng.next_u32() as i32\n                }\n            }\n            impl Rand for i64 {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> i64 {\n                    rng.next_u64() as i64\n                }\n            }\n            #[cfg(feature = \"i128_support\")]\n            impl Rand for i128 {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> i128 {\n                    rng.gen::<u128>() as i128\n                }\n            }\n            impl Rand for usize {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> usize {\n                    if mem::size_of::<usize>() == 4 {\n                        rng.gen::<u32>() as usize\n                    } else {\n                        rng.gen::<u64>() as usize\n                    }\n                }\n            }\n            impl Rand for u8 {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> u8 {\n                    rng.next_u32() as u8\n                }\n            }\n            impl Rand for u16 {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> u16 {\n                    rng.next_u32() as u16\n                }\n            }\n            impl Rand for u32 {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> u32 {\n                    rng.next_u32()\n                }\n            }\n            impl Rand for u64 {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> u64 {\n                    rng.next_u64()\n                }\n            }\n            #[cfg(feature = \"i128_support\")]\n            impl Rand for u128 {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> u128 {\n                    ((rng.next_u64() as u128) << 64) | (rng.next_u64() as u128)\n                }\n            }\n            impl Rand for f64 {\n                fn rand<R: Rng>(rng: &mut R) -> f64 {\n                    rng.next_f64()\n                }\n            }\n            impl Rand for f32 {\n                fn rand<R: Rng>(rng: &mut R) -> f32 {\n                    rng.next_f32()\n                }\n            }\n            impl Rand for char {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> char {\n                    const CHAR_MASK: u32 = 2097151;\n                    loop {\n                        match char::from_u32(rng.next_u32() & CHAR_MASK) {\n                            Some(c) => return c,\n                            None => {}\n                        }\n                    }\n                }\n            }\n            impl Rand for bool {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> bool {\n                    rng.gen::<u8>() & 1 == 1\n                }\n            }\n            macro_rules! tuple_impl(( $ ( $ tyvar : ident ) , * ) => {\n                                impl < $ ( $ tyvar : Rand ) , * > Rand for (\n                                $ ( $ tyvar ) , * , ) {\n                                # [ inline ] fn rand < R : Rng > (\n                                _rng : & mut R ) -> ( $ ( $ tyvar ) , * , ) {\n                                ( $ ( _rng . gen :: < $ tyvar > (  ) ) , * , )\n                                } } });\n            impl Rand for () {\n                #[inline]\n                fn rand<R: Rng>(_: &mut R) -> () {\n                    ()\n                }\n            }\n            tuple_impl!(A);\n            tuple_impl!(A, B);\n            tuple_impl!(A, B, C);\n            tuple_impl!(A, B, C, D);\n            tuple_impl!(A, B, C, D, E);\n            tuple_impl!(A, B, C, D, E, F);\n            tuple_impl!(A, B, C, D, E, F, G);\n            tuple_impl!(A, B, C, D, E, F, G, H);\n            tuple_impl!(A, B, C, D, E, F, G, H, I);\n            tuple_impl!(A, B, C, D, E, F, G, H, I, J);\n            tuple_impl!(A, B, C, D, E, F, G, H, I, J, K);\n            tuple_impl!(A, B, C, D, E, F, G, H, I, J, K, L);\n            macro_rules! array_impl({\n                                $ n : expr , $ t : ident , $ ( $ ts : ident ,\n                                ) * } => {\n                                array_impl ! { ( $ n - 1 ) , $ ( $ ts , ) * }\n                                impl < T > Rand for [ T ; $ n ] where T : Rand\n                                {\n                                # [ inline ] fn rand < R : Rng > (\n                                _rng : & mut R ) -> [ T ; $ n ] {\n                                [\n                                _rng . gen :: < $ t > (  ) , $ (\n                                _rng . gen :: < $ ts > (  ) ) , * ] } } } ; {\n                                $ n : expr , } => {\n                                impl < T > Rand for [ T ; $ n ] {\n                                fn rand < R : Rng > ( _rng : & mut R ) -> [\n                                T ; $ n ] { [  ] } } } ;);\n            array_impl!(\n                32,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n                T,\n            );\n            impl<T: Rand> Rand for Option<T> {\n                #[inline]\n                fn rand<R: Rng>(rng: &mut R) -> Option<T> {\n                    if rng.gen() {\n                        Some(rng.gen())\n                    } else {\n                        None\n                    }\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nfn main() {\n    let (r, w) = (std::io::stdin(), std::io::stdout());\n    let mut sc = IO::new(r.lock(), w.lock());\n    let s = sc.chars();\n    let k: usize = sc.read();\n    let n = s.len();\n    let ans = solve(\n        0,\n        s.len(),\n        k,\n        &s,\n        &mut vec![vec![vec![-1; k + 1]; n + 1]; n],\n    );\n    println!(\"{}\", ans);\n}\n\nfn solve(l: usize, r: usize, k: usize, s: &Vec<char>, dp: &mut Vec<Vec<Vec<i64>>>) -> i64 {\n    if dp[l][r][k] != -1 {\n        return dp[l][r][k];\n    }\n    if r == l + 1 {\n        return 1;\n    }\n    if r == l {\n        return 1;\n    }\n\n    let mut ans = 0;\n    ans = cmp::max(ans, solve(l, r - 1, k, s, dp));\n    ans = cmp::max(ans, solve(l + 1, r, k, s, dp));\n\n    if s[l] == s[r - 1] {\n        ans = cmp::max(ans, solve(l + 1, r - 1, k, s, dp) + 2);\n    } else if k > 0 {\n        ans = cmp::max(ans, solve(l + 1, r - 1, k - 1, s, dp) + 2);\n    }\n\n    dp[l][r][k] = ans;\n    ans\n}\n\npub struct IO<R, W: std::io::Write>(R, std::io::BufWriter<W>);\n\nimpl<R: std::io::Read, W: std::io::Write> IO<R, W> {\n    pub fn new(r: R, w: W) -> IO<R, W> {\n        IO(r, std::io::BufWriter::new(w))\n    }\n    pub fn write<S: ToString>(&mut self, s: S) {\n        use std::io::Write;\n        self.1.write(s.to_string().as_bytes()).unwrap();\n    }\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .0\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r' || b == b'\\t')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r' && b != b'\\t')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::io::{stdin, Read, StdinLock};\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::str::FromStr;\n#[allow(unused_imports)]\nuse std::collections::{HashSet, HashMap, BinaryHeap, VecDeque};\n#[allow(unused_imports)]\nuse std::vec::Vec;\n\n#[allow(dead_code)]\nconst INF: i32 = 1000_000_000;\n#[allow(dead_code)]\nconst INFLL: i64 = 1000_000_000_000_000_000;\n#[allow(dead_code)]\nconst EPS: f64 = 1.0e-10;\n#[allow(dead_code)]\nconst MOD: i32 = 1000_000_007;\n#[allow(dead_code)]\nconst MODLL: i64 = 1000_000_007;\n\nstruct Scanner<'a> {\n    cin: StdinLock<'a>,\n}\n\n#[allow(dead_code)]\nimpl<'a> Scanner<'a> {\n    fn new(cin: StdinLock<'a>) -> Scanner<'a> {\n        Scanner {cin: cin}\n    }\n    fn read1<T: FromStr>(&mut self) -> Option<T> {\n        let token = self.cin.by_ref().bytes().map(|c| c.unwrap() as char)\n                    .skip_while(|c| c.is_whitespace())\n                    .take_while(|c| !c.is_whitespace())\n                    .collect::<String>();\n        token.parse::<T>().ok()\n    }\n    fn read<T: FromStr>(&mut self) -> T {\n        self.read1().unwrap()\n    }\n}\n\nfn solve(s: &Vec<char>, l: usize, r: usize, k: usize, mut dp: &mut Vec<Vec<Vec<i32>>>) -> i32 {\n    if l > r {\n        return 0\n    }\n    if dp[l][r][k] != -1 {\n        return dp[l][r][k]\n    }\n    if l == r {\n        dp[l][r][k] = 1;\n        return 1\n    }\n\n    dp[l][r][k] = 0;\n    if s[l] == s[r] {\n        dp[l][r][k] = solve(&s, l + 1, r - 1, k, &mut dp) + 2;\n    }\n    if k + 1 < dp[0][0].len() {\n        dp[l][r][k] = max(dp[l][r][k], solve(&s, l + 1, r - 1, k + 1, &mut dp) + 2);\n    }\n    dp[l][r][k] = max(dp[l][r][k], solve(&s, l + 1, r, k, &mut dp));\n    dp[l][r][k] = max(dp[l][r][k], solve(&s, l, r - 1, k, &mut dp));\n\n    dp[l][r][k]\n}\n\nfn main() {\n    let cin = stdin();\n    let cin = cin.lock();\n    let mut sc = Scanner::new(cin);\n\n    let (s, k): (String, usize) = (sc.read(), sc.read());\n    let s: Vec<char> = s.chars().collect();\n    let mut dp: Vec<Vec<Vec<i32>>> = vec![vec![vec![-1; k + 1]; s.len()]; s.len()];\n\n    println!(\"{}\", solve(&s, 0, s.len() - 1, 0, &mut dp));\n}"
  },
  {
    "language": "Rust",
    "code": "fn getline() -> String {\n    let mut res = String::new();\n    std::io::stdin().read_line(&mut res).ok();\n    res\n}\n\n#[allow(unused_macros)]\nmacro_rules! readl {\n    ($t: ty) => {\n        {\n            let s = getline();\n            s.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($( $t: ty),+ ) => {\n        {\n            let s = getline();\n            let mut iter = s.trim().split(' ');\n            ($(iter.next().unwrap().parse::<$t>().unwrap(),)*)\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! readlvec {\n    ($t: ty) => {\n        {\n            let s = getline();\n            let iter = s.trim().split(' ');\n            iter.map(|x| x.parse().unwrap()).collect::<Vec<$t>>()\n        }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($x: expr) => {\n        println!(\"{}: {:?}\", stringify!($x), $x)\n    }\n}\n\nfn printiter<'a, T>(v: &'a T)\nwhere\n    &'a T: std::iter::IntoIterator,\n    <&'a T as std::iter::IntoIterator>::Item: std::fmt::Display,\n{\n    for (i, e) in v.into_iter().enumerate() {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", e);\n    }\n    println!(\"\");\n}\n\n\n#[allow(unused_imports)]\nuse std::cmp::{min, max};\n#[allow(unused_imports)]\nuse std::collections::{BinaryHeap, BTreeMap, HashMap, HashSet};\n#[allow(unused_imports)]\n// use std::collections::btree_map::Entry::*;\n#[allow(unused_imports)]\nuse std::collections::hash_map::Entry::*;\n\nfn main() {\n    use std::io::Write;\n    let out = std::io::stdout();\n    let mut out = std::io::BufWriter::new(out.lock());\n    macro_rules! print { ($($arg:tt)*) => (write!(out, $($arg)*).unwrap()); }\n    macro_rules! println { () => (writeln!(out).unwrap()); ($($arg:tt)*) => (writeln!(out, $($arg)*).unwrap()); }\n\n    let s = readl!(String).into_bytes();\n    let k = readl!(usize);\n    // let mut dp = vec![vec![vec![None; k+1]; s.len()]; s.len()];\n    let mut dp = HashMap::new();\n    struct Env<'a> {dp: &'a mut HashMap<(isize, isize, usize), i32>, s: &'a Vec<u8>, }\n    fn rec(env: &mut Env, l: isize, r: isize, k: usize) -> i32 {\n        if let Some(&v) = env.dp.get(&(l, r, k)) {\n            v\n        } else {\n            if l >= r {\n                if l == r {\n                    1\n                } else {\n                    0\n                }\n            } else {\n                let mut res = 0;\n                res = max(rec(env, l+1, r, k), res);\n                res = max(rec(env, l, r-1, k), res);\n                if env.s[l as usize] == env.s[r as usize] {\n                    res = max(rec(env, l+1, r-1, k)+2, res);\n                } else if k != 0 {\n                    res = max(rec(env, l+1, r-1, k-1)+2, res);\n                }\n                env.dp.insert((l, r, k), res);\n                // env.dp[l as usize][r as usize][k] = Some(res);\n                res\n            }\n        }\n    }\n    println!(\"{}\", rec(&mut Env{dp: &mut dp, s: &s}, 0, s.len() as isize-1, k));\n}\n"
  },
  {
    "language": "Rust",
    "code": "/**\n *  _           _                 __                            _   _ _   _                                 _                    _                  _\n * | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n * | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n * | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n * | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n * |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n *                                                  | |                                                                           | |   | |\n *                                                  |_|                                                                           |_|   |_|\n *\n * https://github.com/hatoo/competitive-rust-snippets\n */\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { println ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n\nfn rec(l: usize, r: usize, k: usize, s: &[char], memo: &mut [Vec<Vec<Option<usize>>>]) -> usize {\n    if l > r {\n        return 0;\n    }\n\n    if l == r {\n        return 1;\n    }\n\n    if let Some(res) = memo[l][r][k] {\n        return res;\n    }\n\n    let mut res = 0;\n    if s[l] == s[r] {\n        res = max(res, 2 + rec(l + 1, r - 1, k, s, memo));\n    }\n    res = max(\n        res,\n        max(rec(l + 1, r, k, s, memo), rec(l, r - 1, k, s, memo)),\n    );\n    if k > 0 {\n        res = max(res, 2 + rec(l + 1, r - 1, k - 1, s, memo));\n    }\n\n    memo[l][r][k] = Some(res);\n\n    res\n}\n\n#[allow(dead_code)]\nfn main() {\n    let s = util::chars();\n    let k = get!(usize);\n    let n = s.len();\n\n    let mut dp = vec![vec![vec![None; k + 1]; n + 1]; n + 1];\n\n    println!(\"{}\", rec(0, n - 1, k, &s, &mut dp));\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn getline() -> String {\n    let mut res = String::new();\n    std::io::stdin().read_line(&mut res).ok();\n    res\n}\n    \n#[allow(unused_macros)]\nmacro_rules! readl {\n    ($t: ty) => {\n        {\n            let s = getline();\n            s.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($( $t: ty),+ ) => {\n        {\n            let s = getline();\n            let mut iter = s.trim().split(' ');\n            ($(iter.next().unwrap().parse::<$t>().unwrap(),)*)\n        }\n    };\n}\n    \n#[allow(unused_macros)]\nmacro_rules! readlvec {\n    ($t: ty) => {\n        {\n            let s = getline();\n            let iter = s.trim().split(' ');\n            iter.map(|x| x.parse().unwrap()).collect::<Vec<$t>>()\n        }\n    }\n}\n    \n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($x: expr) => {\n        println!(\"{}: {:?}\", stringify!($x), $x)\n    }\n}\n    \nfn printiter<'a, T>(v: &'a T)\nwhere\n    &'a T: std::iter::IntoIterator,\n    <&'a T as std::iter::IntoIterator>::Item: std::fmt::Display,\n{\n    for (i, e) in v.into_iter().enumerate() {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", e);\n    }\n    println!(\"\");\n}\n    \n    \n#[allow(unused_imports)]\nuse std::cmp::{min, max};\n#[allow(unused_imports)]\nuse std::collections::{BinaryHeap, BTreeMap, HashMap, HashSet};\n#[allow(unused_imports)]\nuse std::collections::btree_map::Entry::{Occupied, Vacant};\n    \nfn main() {\n    use std::io::Write;\n    let out = std::io::stdout();\n    let mut out = std::io::BufWriter::new(out.lock());\n    macro_rules! print { ($($arg:tt)*) => (write!(out, $($arg)*).unwrap()); }\n    macro_rules! println { () => (writeln!(out).unwrap()); ($($arg:tt)*) => (writeln!(out, $($arg)*).unwrap()); }\n    \n    let s = readl!(String).into_bytes();\n    let k = readl!(usize);\n    let mut dp = vec![vec![vec![-1; k+1]; s.len()]; s.len()];\n    struct Env<'a> {dp: &'a mut Vec<Vec<Vec<i32>>>, s: &'a Vec<u8>, }\n    fn rec(env: &mut Env, l: isize, r: isize, k: usize) -> i32 {\n        // debug!(l); debug!(r); debug!(k);\n        if -1 != env.dp[l as usize][r as usize][k] {\n            env.dp[l as usize][r as usize][k]\n        } else if l >= r {\n            if l == r {\n                1\n            } else {\n                0\n            }\n        } else {\n            let mut res = 0;\n            res = max(rec(env, l+1, r, k), res);\n            res = max(rec(env, l, r-1, k), res);\n            if env.s[l as usize] == env.s[r as usize] {\n                res = max(rec(env, l+1, r-1, k)+2, res);\n            } else if k != 0 {\n                res = max(rec(env, l+1, r-1, k-1)+2, res);\n            }\n            env.dp[l as usize][r as usize][k] = res;\n            res\n        }\n    }\n    println!(\"{}\", rec(&mut Env{dp: &mut dp, s: &s}, 0, s.len() as isize - 1, k));\n}"
  },
  {
    "language": "Rust",
    "code": "fn getline() -> String {\n    let mut res = String::new();\n    std::io::stdin().read_line(&mut res).ok();\n    res\n}\n\n#[allow(unused_macros)]\nmacro_rules! readl {\n    ($t: ty) => {\n        {\n            let s = getline();\n            s.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($( $t: ty),+ ) => {\n        {\n            let s = getline();\n            let mut iter = s.trim().split(' ');\n            ($(iter.next().unwrap().parse::<$t>().unwrap(),)*)\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! readlvec {\n    ($t: ty) => {\n        {\n            let s = getline();\n            let iter = s.trim().split(' ');\n            iter.map(|x| x.parse().unwrap()).collect::<Vec<$t>>()\n        }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($x: expr) => {\n        println!(\"{}: {:?}\", stringify!($x), $x)\n    }\n}\n\nfn printiter<'a, T>(v: &'a T)\nwhere\n    &'a T: std::iter::IntoIterator,\n    <&'a T as std::iter::IntoIterator>::Item: std::fmt::Display,\n{\n    for (i, e) in v.into_iter().enumerate() {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", e);\n    }\n    println!(\"\");\n}\n\n\n#[allow(unused_imports)]\nuse std::cmp::{min, max};\n#[allow(unused_imports)]\nuse std::collections::{BinaryHeap, BTreeMap, HashMap, HashSet};\n#[allow(unused_imports)]\nuse std::collections::btree_map::Entry::{Occupied, Vacant};\n\nfn main() {\n    use std::io::Write;\n    let out = std::io::stdout();\n    let mut out = std::io::BufWriter::new(out.lock());\n    macro_rules! print { ($($arg:tt)*) => (write!(out, $($arg)*).unwrap()); }\n    macro_rules! println { () => (writeln!(out).unwrap()); ($($arg:tt)*) => (writeln!(out, $($arg)*).unwrap()); }\n\n    let s = readl!(String).into_bytes();\n    let k = readl!(usize);\n    let mut dp = vec![vec![vec![None; k+1]; s.len()]; s.len()];\n    struct Env<'a> {dp: &'a mut Vec<Vec<Vec<Option<i32>>>>, s: &'a Vec<u8>, }\n    fn rec(env: &mut Env, l: isize, r: isize, k: usize) -> i32 {\n        // debug!(l); debug!(r); debug!(k);\n        if let Some(v) = env.dp[l as usize][r as usize][k] {\n            v\n        } else if l >= r {\n            if l == r {\n                1\n            } else {\n                0\n            }\n        } else {\n            let mut res = 0;\n            res = max(rec(env, l+1, r, k), res);\n            res = max(rec(env, l, r-1, k), res);\n            if env.s[l as usize] == env.s[r as usize] {\n                res = max(rec(env, l+1, r-1, k)+2, res);\n            } else if k != 0 {\n                res = max(rec(env, l+1, r-1, k-1)+2, res);\n            }\n            env.dp[l as usize][r as usize][k] = Some(res);\n            res\n        }\n    }\n    println!(\"{}\", rec(&mut Env{dp: &mut dp, s: &s}, 0, s.len() as isize-1, k));\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nfn main() {\n    let (r, w) = (std::io::stdin(), std::io::stdout());\n    let mut sc = IO::new(r.lock(), w.lock());\n    let s = sc.chars();\n    let k: usize = sc.read();\n    let n = s.len();\n    let ans = solve(\n        0,\n        s.len(),\n        k,\n        &s,\n        &mut vec![vec![vec![-1; k + 1]; n + 1]; n],\n    );\n    println!(\"{}\", ans);\n}\n\nfn solve(l: usize, r: usize, k: usize, s: &Vec<char>, dp: &mut Vec<Vec<Vec<i64>>>) -> i64 {\n    if dp[l][r][k] != -1 {\n        return dp[l][r][k];\n    }\n    if r == l + 1 {\n        return 1;\n    }\n    if r == l {\n        return 0;\n    }\n\n    let mut ans = 0;\n    ans = cmp::max(ans, solve(l, r - 1, k, s, dp));\n    ans = cmp::max(ans, solve(l + 1, r, k, s, dp));\n\n    if s[l] == s[r - 1] {\n        ans = cmp::max(ans, solve(l + 1, r - 1, k, s, dp) + 2);\n    } else if k > 0 {\n        ans = cmp::max(ans, solve(l + 1, r - 1, k - 1, s, dp) + 2);\n    }\n\n    dp[l][r][k] = ans;\n    ans\n}\n\npub struct IO<R, W: std::io::Write>(R, std::io::BufWriter<W>);\n\nimpl<R: std::io::Read, W: std::io::Write> IO<R, W> {\n    pub fn new(r: R, w: W) -> IO<R, W> {\n        IO(r, std::io::BufWriter::new(w))\n    }\n    pub fn write<S: ToString>(&mut self, s: S) {\n        use std::io::Write;\n        self.1.write(s.to_string().as_bytes()).unwrap();\n    }\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .0\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r' || b == b'\\t')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r' && b != b'\\t')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "/**\n *  _           _                 __                            _   _ _   _                                 _                    _                  _\n * | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n * | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n * | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n * | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n * |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n *                                                  | |                                                                           | |   | |\n *                                                  |_|                                                                           |_|   |_|\n *\n * https://github.com/hatoo/competitive-rust-snippets\n */\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\nmod util {\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    use std::fmt::Debug;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { println ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n\nfn rec(l: usize, r: usize, k: usize, s: &[char], memo: &mut [Vec<Vec<Option<u32>>>]) -> u32 {\n    if l > r {\n        return 0;\n    }\n\n    if l == r {\n        return 1;\n    }\n\n    if let Some(res) = memo[l][r][k] {\n        return res;\n    }\n\n    let mut res = 0;\n    if s[l] == s[r] {\n        res = max(res, 2 + rec(l + 1, r - 1, k, s, memo));\n    }\n    res = max(\n        res,\n        max(rec(l + 1, r, k, s, memo), rec(l, r - 1, k, s, memo)),\n    );\n    if k > 0 {\n        res = max(res, 2 + rec(l + 1, r - 1, k - 1, s, memo));\n    }\n\n    memo[l][r][k] = Some(res);\n\n    res\n}\n\n#[allow(dead_code)]\nfn main() {\n    let s = util::chars();\n    let k = get!(usize);\n    let n = s.len();\n\n    let mut dp = vec![vec![vec![None; k + 1]; n + 1]; n + 1];\n\n    println!(\"{}\", rec(0, n - 1, k, &s, &mut dp));\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp::max;\nuse std::collections::BTreeMap;\n\nfn main() {\n    let (r, w) = (std::io::stdin(), std::io::stdout());\n    let mut sc = IO::new(r.lock(), w.lock());\n    let s = sc.chars();\n    let k: usize = sc.read();\n    let ans = dfs(0, s.len(), k, &mut BTreeMap::new(), &s);\n    println!(\"{}\", ans);\n}\n\nfn dfs(\n    left: usize,\n    right: usize,\n    remain: usize,\n    dp: &mut BTreeMap<(usize, usize, usize), usize>,\n    s: &Vec<char>,\n) -> usize {\n    assert!(left <= right);\n    let segment_size = right - left;\n    if segment_size <= 1 {\n        return segment_size;\n    }\n    if let Some(&v) = dp.get(&(left, right, remain)) {\n        return v;\n    }\n\n    let mut max_length = 0;\n    if s[left] == s[right - 1] {\n        max_length = max(max_length, dfs(left + 1, right - 1, remain, dp, s) + 2);\n    } else if remain > 0 {\n        max_length = max(max_length, dfs(left + 1, right - 1, remain - 1, dp, s) + 2);\n    }\n    max_length = max(max_length, dfs(left + 1, right, remain, dp, s));\n    max_length = max(max_length, dfs(left, right - 1, remain, dp, s));\n    dp.insert((left, right, remain), max_length);\n    max_length\n}\n\npub struct IO<R, W: std::io::Write>(R, std::io::BufWriter<W>);\n\nimpl<R: std::io::Read, W: std::io::Write> IO<R, W> {\n    pub fn new(r: R, w: W) -> Self {\n        IO(r, std::io::BufWriter::new(w))\n    }\n    pub fn write<S: ToString>(&mut self, s: S) {\n        use std::io::Write;\n        self.1.write(s.to_string().as_bytes()).unwrap();\n    }\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .0\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r' || b == b'\\t')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r' && b != b'\\t')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn getline() -> String {\n    let mut res = String::new();\n    std::io::stdin().read_line(&mut res).ok();\n    res\n}\n\n#[allow(unused_macros)]\nmacro_rules! readl {\n    ($t: ty) => {\n        {\n            let s = getline();\n            s.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($( $t: ty),+ ) => {\n        {\n            let s = getline();\n            let mut iter = s.trim().split(' ');\n            ($(iter.next().unwrap().parse::<$t>().unwrap(),)*)\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! readlvec {\n    ($t: ty) => {\n        {\n            let s = getline();\n            let iter = s.trim().split(' ');\n            iter.map(|x| x.parse().unwrap()).collect::<Vec<$t>>()\n        }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($x: expr) => {\n        println!(\"{}: {:?}\", stringify!($x), $x)\n    }\n}\n\nfn printiter<'a, T>(v: &'a T)\nwhere\n    &'a T: std::iter::IntoIterator,\n    <&'a T as std::iter::IntoIterator>::Item: std::fmt::Display,\n{\n    for (i, e) in v.into_iter().enumerate() {\n        if i != 0 {\n            print!(\" \");\n        }\n        print!(\"{}\", e);\n    }\n    println!(\"\");\n}\n\n\n#[allow(unused_imports)]\nuse std::cmp::{min, max};\n#[allow(unused_imports)]\nuse std::collections::{BinaryHeap, BTreeMap, HashMap, HashSet};\n#[allow(unused_imports)]\n// use std::collections::btree_map::Entry::*;\n#[allow(unused_imports)]\nuse std::collections::hash_map::Entry::*;\n\nfn main() {\n    use std::io::Write;\n    let out = std::io::stdout();\n    let mut out = std::io::BufWriter::new(out.lock());\n    macro_rules! print { ($($arg:tt)*) => (write!(out, $($arg)*).unwrap()); }\n    macro_rules! println { () => (writeln!(out).unwrap()); ($($arg:tt)*) => (writeln!(out, $($arg)*).unwrap()); }\n\n    let s = readl!(String).into_bytes();\n    let k = readl!(usize);\n    // let mut dp = vec![vec![vec![None; k+1]; s.len()]; s.len()];\n    let mut dp = HashMap::new();\n    struct Env<'a> {dp: &'a mut HashMap<(isize, isize, usize), i32>, s: &'a Vec<u8>, }\n    fn rec(env: &mut Env, l: isize, r: isize, k: usize) -> i32 {\n        if let Some(v) = env.dp.get(&(l, r, k)) {\n            return *v;\n        }\n        if l >= r {\n            if l == r {\n                1\n            } else {\n                0\n            }\n        } else {\n            let mut res = 0;\n            res = max(rec(env, l+1, r, k), res);\n            res = max(rec(env, l, r-1, k), res);\n            if env.s[l as usize] == env.s[r as usize] {\n                res = max(rec(env, l+1, r-1, k)+2, res);\n            } else if k != 0 {\n                res = max(rec(env, l+1, r-1, k-1)+2, res);\n            }\n            env.dp.insert((l, r, k), res);\n            // env.dp[l as usize][r as usize][k] = Some(res);\n            res\n        }\n    }\n    println!(\"{}\", rec(&mut Env{dp: &mut dp, s: &s}, 0, s.len() as isize-1, k));\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_macros)]\n\nuse kyoproio::*;\nuse std::{\n    collections::*,\n    io::{self, prelude::*},\n    iter,\n    mem::{replace, swap},\n};\n\nfn main() -> io::Result<()> {\n    std::thread::Builder::new()\n        .stack_size(64 * 1024 * 1024)\n        .spawn(|| {\n            let stdin = io::stdin();\n            let stdout = io::stdout();\n            run(KInput::new(stdin.lock()), io::BufWriter::new(stdout.lock()))\n        })?\n        .join()\n        .unwrap();\n    Ok(())\n}\n\nfn run<I: Input, O: Write>(mut kin: I, mut out: O) {\n    macro_rules! output { ($($args:expr),+) => { write!(&mut out, $($args),+).unwrap(); }; }\n    macro_rules! outputln {\n        ($($args:expr),+) => { output!($($args),+); outputln!(); };\n        () => { output!(\"\\n\"); if cfg!(debug_assertions) { out.flush().unwrap(); } }\n    }\n\n    let (s, k): (Vec<u8>, usize) = kin.input();\n    let n = s.len();\n    \n    let mut dp = vec![[[0u16; 301]; 301]; n + 1];\n    for i in 1..=n {\n        for j in 1..=n {\n            for l in 0..=k {\n                if s[i - 1] == s[n - j] {\n                    dp[i][j][l] = dp[i - 1][j - 1][l] + 1;\n                }\n                if l > 0 {\n                    dp[i][j][l] = dp[i][j][l].max(dp[i - 1][j - 1][l - 1] + 1);\n                }\n                dp[i][j][l] = dp[i][j][l].max(dp[i - 1][j][l]).max(dp[i][j - 1][l]);\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in 0..=n {\n        let j = n - i;\n        ans = ans.max(2 * dp[i][j][k]);\n    }\n    for i in 0..n {\n        let j = n - i - 1;\n        ans = ans.max(2 * dp[i][j][k] + 1);\n    }\n\n    outputln!(\"{}\", ans);\n}\n\n// -----------------------------------------------------------------------------\npub mod kyoproio {\n    use std::io::prelude::*;\n    pub trait Input {\n        fn str(&mut self) -> &str;\n        fn input<T: InputParse>(&mut self) -> T {\n            T::input(self)\n        }\n        fn iter<T: InputParse>(&mut self) -> Iter<T, Self> {\n            Iter(self, std::marker::PhantomData)\n        }\n        fn seq<T: InputParse, B: std::iter::FromIterator<T>>(&mut self, n: usize) -> B {\n            self.iter().take(n).collect()\n        }\n    }\n    pub struct KInput<R> {\n        src: R,\n        buf: String,\n        pos: usize,\n    }\n    impl<R: BufRead> KInput<R> {\n        pub fn new(src: R) -> Self {\n            Self {\n                src,\n                buf: String::with_capacity(1024),\n                pos: 0,\n            }\n        }\n    }\n    impl<R: BufRead> Input for KInput<R> {\n        fn str(&mut self) -> &str {\n            loop {\n                if self.pos >= self.buf.len() {\n                    self.pos = 0;\n                    self.buf.clear();\n                    if self.src.read_line(&mut self.buf).expect(\"io error\") == 0 {\n                        return &self.buf;\n                    }\n                }\n                let range = self.pos\n                    ..self.buf[self.pos..]\n                        .find(|c: char| c.is_ascii_whitespace())\n                        .map(|i| i + self.pos)\n                        .unwrap_or_else(|| self.buf.len());\n                self.pos = range.end + 1;\n                if range.end > range.start {\n                    return &self.buf[range];\n                }\n            }\n        }\n    }\n    pub struct Iter<'a, T, I: ?Sized>(&'a mut I, std::marker::PhantomData<*const T>);\n    impl<'a, T: InputParse, I: Input + ?Sized> Iterator for Iter<'a, T, I> {\n        type Item = T;\n        fn next(&mut self) -> Option<T> {\n            Some(self.0.input())\n        }\n    }\n    pub trait InputParse: Sized {\n        fn input<I: Input + ?Sized>(src: &mut I) -> Self;\n    }\n    impl InputParse for Vec<u8> {\n        fn input<I: Input + ?Sized>(src: &mut I) -> Self {\n            src.str().as_bytes().to_owned()\n        }\n    }\n    macro_rules! from_str_impl {\n        { $($T:ty)* } => {\n            $(impl InputParse for $T {\n                fn input<I: Input + ?Sized>(src: &mut I) -> Self {\n                    src.str().parse::<$T>().expect(\"parse error\")\n                }\n            })*\n        }\n    }\n    from_str_impl! {\n        String char bool f32 f64 isize i8 i16 i32 i64 i128 usize u8 u16 u32 u64 u128\n    }\n    macro_rules! tuple_impl {\n        ($H:ident $($T:ident)*) => {\n            impl<$H: InputParse, $($T: InputParse),*> InputParse for ($H, $($T),*) {\n                fn input<I: Input + ?Sized>(src: &mut I) -> Self {\n                    ($H::input(src), $($T::input(src)),*)\n                }\n            }\n            tuple_impl!($($T)*);\n        };\n        () => {}\n    }\n    tuple_impl!(A B C D E F G);\n    #[macro_export]\n    macro_rules! kdbg {\n        ($($v:expr),*) => {\n            if cfg!(debug_assertions) { dbg!($($v),*) } else { ($($v),*) }\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "pub trait IterScan: Sized {\n    type Output;\n    fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output>;\n}\npub trait MarkedIterScan: Sized {\n    type Output;\n    fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output>;\n}\n#[derive(Debug)]\npub struct Scanner<'a> {\n    iter: std::str::SplitAsciiWhitespace<'a>,\n}\nimpl<'a> Scanner<'a> {\n    #[inline]\n    pub fn new(s: &'a str) -> Self {\n        let iter = s.split_ascii_whitespace();\n        Self { iter }\n    }\n    #[inline]\n    pub fn scan<T: IterScan>(&mut self) -> <T as IterScan>::Output {\n        T::scan(&mut self.iter).unwrap()\n    }\n    #[inline]\n    pub fn mscan<T: MarkedIterScan>(&mut self, marker: T) -> <T as MarkedIterScan>::Output {\n        marker.mscan(&mut self.iter).unwrap()\n    }\n    #[inline]\n    pub fn scan_vec<T: IterScan>(&mut self, size: usize) -> Vec<<T as IterScan>::Output> {\n        (0..size)\n            .map(|_| T::scan(&mut self.iter).unwrap())\n            .collect()\n    }\n    #[inline]\n    pub fn scan_chars(&mut self) -> Vec<char> {\n        self.iter.next().unwrap().chars().collect::<Vec<char>>()\n    }\n    #[inline]\n    pub fn scan_chars_with(&mut self, base: char) -> Vec<usize> {\n        self.iter\n            .next()\n            .unwrap()\n            .chars()\n            .map(|c| (c as u8 - base as u8) as usize)\n            .collect::<Vec<usize>>()\n    }\n}\nmod scanner_impls {\n    use super::*;\n    macro_rules !iter_scan_impls {($($t :ty ) *) =>{$(impl IterScan for $t {type Output =Self ;#[inline ] fn scan <'a ,I :Iterator <Item =&'a str >>(iter :&mut I ) ->Option <Self >{iter .next () ?.parse ::<$t >() .ok () } } ) *} ;}\n    iter_scan_impls !(char u8 u16 u32 u64 usize i8 i16 i32 i64 isize f32 f64 u128 i128 String ) ;\n    macro_rules !iter_scan_tuple_impl {($($T :ident ) *) =>{impl <$($T :IterScan ) ,*>IterScan for ($($T ,) *) {type Output =($(<$T as IterScan >::Output ,) *) ;#[inline ] fn scan <'a ,It :Iterator <Item =&'a str >>(_iter :&mut It ) ->Option <Self ::Output >{Some (($($T ::scan (_iter ) ?,) *) ) } } } ;}\n    iter_scan_tuple_impl!();\n    iter_scan_tuple_impl!(A);\n    iter_scan_tuple_impl !(A B ) ;\n    iter_scan_tuple_impl !(A B C ) ;\n    iter_scan_tuple_impl !(A B C D ) ;\n    iter_scan_tuple_impl !(A B C D E ) ;\n    iter_scan_tuple_impl !(A B C D E F ) ;\n    iter_scan_tuple_impl !(A B C D E F G ) ;\n    iter_scan_tuple_impl !(A B C D E F G H ) ;\n    iter_scan_tuple_impl !(A B C D E F G H I ) ;\n    iter_scan_tuple_impl !(A B C D E F G H I J ) ;\n    iter_scan_tuple_impl !(A B C D E F G H I J K ) ;\n    pub struct ScannerIter<'a, 'b, T> {\n        inner: &'b mut Scanner<'a>,\n        _marker: std::marker::PhantomData<fn() -> T>,\n    }\n    impl<'a, 'b, T: IterScan> Iterator for ScannerIter<'a, 'b, T> {\n        type Item = <T as IterScan>::Output;\n        fn next(&mut self) -> Option<Self::Item> {\n            T::scan(&mut self.inner.iter)\n        }\n    }\n    impl<'a> Scanner<'a> {\n        #[inline]\n        pub fn iter<'b, T: IterScan>(&'b mut self) -> ScannerIter<'a, 'b, T> {\n            ScannerIter {\n                inner: self,\n                _marker: std::marker::PhantomData,\n            }\n        }\n    }\n}\npub mod marker {\n    use super::*;\n    pub struct Usize1;\n    impl IterScan for Usize1 {\n        type Output = usize;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            usize::scan(iter).map(|x| x.wrapping_sub(1))\n        }\n    }\n    pub struct Isize1;\n    impl IterScan for Isize1 {\n        type Output = isize;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            isize::scan(iter).map(|x| x.wrapping_sub(1))\n        }\n    }\n}\n#[macro_export]\nmacro_rules !min {($e :expr ) =>{$e } ;($e :expr ,$($es :expr ) ,+) =>{std ::cmp ::min ($e ,min !($($es ) ,+) ) } ;}\n#[macro_export]\nmacro_rules !chmin {($dst :expr ,$($src :expr ) ,+) =>{{let x =std ::cmp ::min ($dst ,min !($($src ) ,+) ) ;$dst =x ;} } ;}\n#[macro_export]\nmacro_rules !max {($e :expr ) =>{$e } ;($e :expr ,$($es :expr ) ,+) =>{std ::cmp ::max ($e ,max !($($es ) ,+) ) } ;}\n#[macro_export]\nmacro_rules !chmax {($dst :expr ,$($src :expr ) ,+) =>{{let x =std ::cmp ::max ($dst ,max !($($src ) ,+) ) ;$dst =x ;} } ;}\nfn main() {\n    #[allow(unused_imports)]\n    use std::io::{Read as _, Write as _};\n    let __out = std::io::stdout();\n    let mut __in_buf = String::new();\n    std::io::stdin().read_to_string(&mut __in_buf).unwrap();\n    let mut scanner = Scanner::new(&__in_buf);\n    #[allow(unused_macros)]\n    macro_rules !scan {() =>{scan !(usize ) } ;(($($t :tt ) ,*) ) =>{($(scan !($t ) ) ,*) } ;([$t :tt ;$len :expr ] ) =>{(0 ..$len ) .map (|_ |scan !($t ) ) .collect ::<Vec <_ >>() } ;({chars :$b :expr } ) =>{scanner .scan_chars_with ($b ) } ;({$t :tt =>$f :expr } ) =>{$f (scan !($t ) ) } ;(chars ) =>{scanner .scan_chars () } ;($t :ty ) =>{scanner .scan ::<$t >() } ;}\n    let mut __out = std::io::BufWriter::new(__out.lock());\n    #[allow(unused_macros)]\n    macro_rules !print {($($arg :tt ) *) =>(::std ::write !(__out ,$($arg ) *) .unwrap () ) }\n    #[allow(unused_macros)]\n    macro_rules !println {($($arg :tt ) *) =>(::std ::writeln !(__out ,$($arg ) *) .unwrap () ) }\n    #[allow(unused_macros)]\n    macro_rules! echo {\n        ($iter :expr ) => {\n            echo!($iter, \"\\n\")\n        };\n        ($iter :expr ,$sep :expr ) => {\n            let mut iter = $iter;\n            if let Some(item) = iter.next() {\n                print!(\"{}\", item);\n            }\n            for item in iter {\n                print!(\"{}{}\", $sep, item);\n            }\n            println!();\n        };\n    }\n    let s = scan!(chars);\n    let l = scan!();\n    let n = s.len();\n    let mut dp = vec![vec![vec![0; l + 1]; n + 1]; n + 1];\n    for i in 0..n {\n        for j in 0..n {\n            if i + j >= n {\n                continue;\n            }\n            for k in 0..=l {\n                let d = dp[i][j][k];\n                chmax!(dp[i + 1][j][k], d);\n                chmax!(dp[i][j + 1][k], d);\n                let c = if i == n - j - 1 { 1 } else { 2 };\n                if s[i] == s[n - j - 1] {\n                    chmax!(dp[i + 1][j + 1][k], d + c);\n                }\n                if k + 1 <= l {\n                    chmax!(dp[i + 1][j + 1][k + 1], d + c);\n                }\n            }\n        }\n    }\n    println!(\n        \"{}\",\n        dp.into_iter()\n            .map(|d| d\n                .into_iter()\n                .map(|d| d.into_iter().max().unwrap())\n                .max()\n                .unwrap())\n            .max()\n            .unwrap()\n    );\n}"
  },
  {
    "language": "Rust",
    "code": "macro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut iter = $ s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; ( iter = $ iter : ident , $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut $ iter = s . split_whitespace ( ) ; input_inner ! { $ iter , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut iter = s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; }\nmacro_rules ! input_inner { ( $ iter : expr ) => { } ; ( $ iter : expr , ) => { } ; ( $ iter : expr , mut $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let mut $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , mut $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , mut $ var : usize $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , $ var : usize $ ( $ r ) * } } ; }\nmacro_rules ! read_value { ( $ iter : expr , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ iter , $ t ) ) ,* ) } ; ( $ iter : expr , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ iter , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ iter : expr , { chars : $ base : expr } ) => { read_value ! ( $ iter , String ) . chars ( ) . map ( | c | ( c as u8 - $ base as u8 ) as usize ) . collect ::< Vec < usize >> ( ) } ; ( $ iter : expr , { char : $ base : expr } ) => { read_value ! ( $ iter , { chars : $ base } ) [ 0 ] } ; ( $ iter : expr , chars ) => { read_value ! ( $ iter , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ iter : expr , char ) => { read_value ! ( $ iter , chars ) [ 0 ] } ; ( $ iter : expr , usize1 ) => { read_value ! ( $ iter , usize ) - 1 } ; ( $ iter : expr , $ t : ty ) => { $ iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) } ; }\nuse std::cmp::max;\nfn main() {\n    input! { s: {chars : 'a'}, m };\n    let n = s.len();\n    let mut dp = vec![vec![vec![0; m + 1]; n + 1]; n + 1];\n    let mut ans = 0;\n    for i in 0..n {\n        for j in 0..n {\n            if i + j >= n {\n                continue;\n            }\n            for k in 0..m + 1 {\n                let ni = i + 1;\n                let nj = j + 1;\n                let nk = k + 1;\n                dp[ni][j][k] = max(dp[ni][j][k], dp[i][j][k]);\n                dp[i][nj][k] = max(dp[i][nj][k], dp[i][j][k]);\n                let d = if i == n - 1 - j { 1 } else { 2 };\n                if s[i] == s[n - 1 - j] {\n                    dp[ni][nj][k] = max(dp[ni][nj][k], dp[i][j][k] + d);\n                } else if nk <= m {\n                    dp[ni][nj][nk] = max(dp[ni][nj][nk], dp[i][j][k] + d);\n                }\n            }\n        }\n    }\n    for i in 0..n + 1 {\n        for j in 0..n + 1 {\n            for k in 0..m + 1 {\n                ans = max(ans, dp[i][j][k]);\n            }\n        }\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::Read;\n\nfn main() {\n    let mut buf = String::new();\n    std::io::stdin().read_to_string(&mut buf).ok();\n    let mut it = buf.split_whitespace();\n    let s = it.next().unwrap().as_bytes();\n    let n = s.len();\n    let k = it.next().unwrap().parse::<usize>().unwrap();\n    let mut dp = vec![vec![vec![0; n]; n]; k+1];\n    for d in (1..n).rev() {\n        for i in 0..k+1 {\n            for j in 0..n-d {\n                dp[i][j+1][j+d] = std::cmp::max(dp[i][j+1][j+d], dp[i][j][j+d]);\n                dp[i][j][j+d-1] = std::cmp::max(dp[i][j][j+d-1], dp[i][j][j+d]);\n                let next_i = i + if s[j] == s[j+d] { 0 } else { 1 };\n                if next_i > k { continue; }\n                dp[next_i][j+1][j+d-1] = std::cmp::max(dp[next_i][j+1][j+d-1], dp[i][j][j+d] + 2);\n            }\n        }\n    }\n    let mut res = 0;\n    for i in 0..k+1 {\n        for j in 0..n {\n            for l in 0..n {\n                res = std::cmp::max(res, dp[i][j][l] + if j == l { 1 } else { 0 });\n            }\n        }\n    }\n    println!(\"{}\", res);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp::max;\nuse std::collections::BTreeMap;\n\nfn main() {\n    let (r, w) = (std::io::stdin(), std::io::stdout());\n    let mut sc = IO::new(r.lock(), w.lock());\n    let s = sc.chars();\n    let k: usize = sc.read();\n    let ans = dfs(0, s.len(), k, &mut BTreeMap::new(), &s);\n    println!(\"{}\", ans);\n}\n\nfn dfs(\n    left: usize,\n    right: usize,\n    remain: usize,\n    dp: &mut BTreeMap<(usize, usize, usize), usize>,\n    s: &Vec<char>,\n) -> usize {\n    assert!(left <= right);\n    let segment_size = right - left;\n    if segment_size <= 1 {\n        return segment_size;\n    }\n    if let Some(&v) = dp.get(&(left, right, remain)) {\n        return v;\n    }\n\n    let mut max_length = 0;\n    if s[left] == s[right - 1] {\n        max_length = max(max_length, dfs(left + 1, right - 1, remain, dp, s) + 2);\n    } else if remain > 0 {\n        max_length = max(max_length, dfs(left + 1, right - 1, remain - 1, dp, s) + 2);\n    }\n    max_length = max(max_length, dfs(left + 1, right, remain, dp, s));\n    max_length = max(max_length, dfs(left, right - 1, remain, dp, s));\n    dp.insert((left, right, remain), max_length);\n    max_length\n}\n\npub struct IO<R, W: std::io::Write>(R, std::io::BufWriter<W>);\n\nimpl<R: std::io::Read, W: std::io::Write> IO<R, W> {\n    pub fn new(r: R, w: W) -> Self {\n        Self(r, std::io::BufWriter::new(w))\n    }\n    pub fn write<S: ToString>(&mut self, s: S) {\n        use std::io::Write;\n        self.1.write(s.to_string().as_bytes()).unwrap();\n    }\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .0\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r' || b == b'\\t')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r' && b != b'\\t')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  }
]