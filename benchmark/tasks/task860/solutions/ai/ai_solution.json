[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_LEN 2001\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint lcs(char* s1, char* s2) {\n    int m = strlen(s1);\n    int n = strlen(s2);\n    int dp[MAX_LEN][MAX_LEN] = {0};\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s1[i-1] == s2[j-1]) {\n                dp[i][j] = dp[i-1][j-1] + 1;\n            } else {\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n            }\n        }\n    }\n    return dp[m][n];\n}\n\nint solve(char* s, int k) {\n    int n = strlen(s);\n    int result = 0;\n\n    for (int mask = 0; mask < (1 << n); mask++) {\n        int changes = 0;\n        char modified[MAX_LEN];\n        strcpy(modified, s);\n\n        for (int i = 0; i < n; i++) {\n            if (mask & (1 << i)) {\n                if (changes < k) {\n                    modified[i] = (modified[i] == '0') ? '1' : '0';\n                    changes++;\n                }\n            }\n        }\n\n        char reversed[MAX_LEN];\n        for (int i = 0; i < n; i++) {\n            reversed[i] = modified[n-1-i];\n        }\n        reversed[n] = '\\0';\n\n        result = max(result, lcs(modified, reversed));\n    }\n\n    return result;\n}\n\nint main() {\n    char s[MAX_LEN];\n    int k;\n    scanf(\"%s %d\", s, &k);\n    printf(\"%d\\n\", solve(s, k));\n    return 0;\n}",
    "timestamp": "2025-08-05 23:08:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_N 300\n\nint dp[MAX_N + 1][MAX_N + 1][MAX_N + 1];\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint main() {\n    int N, K;\n    char S[MAX_N + 1];\n    scanf(\"%d %d\", &N, &K);\n    scanf(\"%s\", S);\n\n    for (int i = 0; i <= N; ++i) {\n        for (int j = 0; j <= N; ++j) {\n            for (int k = 0; k <= K; ++k) {\n                dp[i][j][k] = -1;\n            }\n        }\n    }\n\n    dp[0][0][0] = 0;\n\n    for (int i = 0; i <= N; ++i) {\n        for (int j = 0; j <= N; ++j) {\n            for (int k = 0; k <= K; ++k) {\n                if (dp[i][j][k] == -1) continue;\n                if (i < N && j < N) {\n                    if (S[i] == S[N - 1 - j]) {\n                        if (dp[i + 1][j + 1][k] < dp[i][j][k] + 1) {\n                            dp[i + 1][j + 1][k] = dp[i][j][k] + 1;\n                        }\n                    } else {\n                        if (k < K) {\n                            if (dp[i + 1][j + 1][k + 1] < dp[i][j][k] + 1) {\n                                dp[i + 1][j + 1][k + 1] = dp[i][j][k] + 1;\n                            }\n                        }\n                        if (dp[i + 1][j][k] < dp[i][j][k]) {\n                            dp[i + 1][j][k] = dp[i][j][k];\n                        }\n                        if (dp[i][j + 1][k] < dp[i][j][k]) {\n                            dp[i][j + 1][k] = dp[i][j][k];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    int res = 0;\n    for (int i = 0; i <= N; ++i) {\n        for (int k = 0; k <= K; ++k) {\n            res = max(res, dp[i][N - i][k]);\n        }\n    }\n\n    printf(\"%d\\n\", res);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:09:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nint main() {\n    int N, K;\n    string S;\n    cin >> N >> K >> S;\n    \n    string revS = S;\n    reverse(revS.begin(), revS.end());\n    \n    vector<vector<vector<int>>> dp(N + 1, vector<vector<int>>(N + 1, vector<int>(K + 1, 0)));\n    \n    for (int i = 1; i <= N; ++i) {\n        for (int j = 1; j <= N; ++j) {\n            for (int k = 0; k <= K; ++k) {\n                if (S[i - 1] == revS[j - 1]) {\n                    dp[i][j][k] = dp[i - 1][j - 1][k] + 1;\n                } else {\n                    if (k > 0) {\n                        dp[i][j][k] = max(dp[i - 1][j - 1][k - 1] + 1, max(dp[i - 1][j][k], dp[i][j - 1][k]));\n                    } else {\n                        dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k]);\n                    }\n                }\n            }\n        }\n    }\n    \n    cout << dp[N][N][K] << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:09:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int K = scanner.nextInt();\n        scanner.nextLine();\n        String S = scanner.nextLine();\n        String reversedS = new StringBuilder(S).reverse().toString();\n\n        int[][][] dp = new int[N + 1][N + 1][K + 1];\n\n        for (int i = 0; i <= N; i++) {\n            for (int j = 0; j <= N; j++) {\n                for (int k = 0; k <= K; k++) {\n                    if (i == 0 || j == 0) {\n                        dp[i][j][k] = 0;\n                    } else {\n                        if (S.charAt(i - 1) == reversedS.charAt(j - 1)) {\n                            dp[i][j][k] = dp[i - 1][j - 1][k] + 1;\n                        } else {\n                            if (k > 0) {\n                                dp[i][j][k] = Math.max(dp[i - 1][j - 1][k - 1] + 1, Math.max(dp[i - 1][j][k], dp[i][j - 1][k]));\n                            } else {\n                                dp[i][j][k] = Math.max(dp[i - 1][j][k], dp[i][j - 1][k]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        System.out.println(dp[N][N][K]);\n    }\n}",
    "timestamp": "2025-08-05 23:09:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static int longestCommonSubsequence(String s1, String s2) {\n        int m = s1.length(), n = s2.length();\n        int[][] dp = new int[m + 1][n + 1];\n        \n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        \n        return dp[m][n];\n    }\n    \n    public static int solve(String s, int k) {\n        int n = s.length();\n        int maxValue = 0;\n        \n        for (int mask = 0; mask < (1 << n); mask++) {\n            if (Integer.bitCount(mask) > k) continue;\n            \n            char[] modified = s.toCharArray();\n            for (int i = 0; i < n; i++) {\n                if ((mask & (1 << i)) != 0) {\n                    modified[i] = (modified[i] == 'a') ? 'b' : 'a';\n                }\n            }\n            \n            String newS = new String(modified);\n            String reversedS = new StringBuilder(newS).reverse().toString();\n            \n            maxValue = Math.max(maxValue, longestCommonSubsequence(newS, reversedS));\n        }\n        \n        return maxValue;\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        int n = Integer.parseInt(st.nextToken());\n        int k = Integer.parseInt(st.nextToken());\n        String s = br.readLine();\n        \n        System.out.println(solve(s, k));\n    }\n}",
    "timestamp": "2025-08-05 23:10:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int longestPalindromeSubseq(string& s) {\n        int n = s.length();\n        vector<vector<int>> dp(n, vector<int>(n, 0));\n        \n        for (int i = 0; i < n; i++) \n            dp[i][i] = 1;\n        \n        for (int len = 2; len <= n; len++) {\n            for (int i = 0; i < n - len + 1; i++) {\n                int j = i + len - 1;\n                if (s[i] == s[j] && len == 2)\n                    dp[i][j] = 2;\n                else if (s[i] == s[j])\n                    dp[i][j] = dp[i+1][j-1] + 2;\n                else\n                    dp[i][j] = max(dp[i+1][j], dp[i][j-1]);\n            }\n        }\n        \n        return dp[0][n-1];\n    }\n    \n    int solve(string s, int k) {\n        int n = s.length();\n        int ans = 0;\n        \n        for (int mask = 0; mask < (1 << n); mask++) {\n            int changes = 0;\n            string t = s;\n            \n            for (int i = 0; i < n; i++) {\n                if (mask & (1 << i)) {\n                    if (changes >= k) break;\n                    t[i] = (t[i] == '0') ? '1' : '0';\n                    changes++;\n                }\n            }\n            \n            if (changes <= k) {\n                ans = max(ans, longestPalindromeSubseq(t));\n            }\n        }\n        \n        return ans;\n    }\n};\n\nint main() {\n    string s;\n    int k;\n    cin >> s >> k;\n    \n    Solution sol;\n    cout << sol.solve(s, k) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:10:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def longest_palindromic_subsequence(S):\n    n = len(S)\n    rev_S = S[::-1]\n    \n    # Initialize DP table\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Fill DP table\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if S[i - 1] == rev_S[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    return dp[n][n]\n\ndef max_value_after_k_changes(S, K):\n    n = len(S)\n\n    if n == 0:\n        return 0\n\n    # Longest Palindromic Subsequence (LPS) without any changes\n    lps = longest_palindromic_subsequence(S)\n    \n    return min(n, lps + 2 * K)\n\ndef main():\n    S = input().strip()\n    K = int(input().strip())\n    result = max_value_after_k_changes(S, K)\n    print(result)\n\n# The main function call (to be replaced with actual inputs in local environment):\n# main()",
    "timestamp": "2025-08-13 13:53:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class LongestPalindromeValue {\n    public static int longestPalindromeValue(String S, int K) {\n        int n = S.length();\n        int[][] dp = new int[n + 1][n + 1];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (S.charAt(i) == S.charAt(n - j - 1)) {\n                    dp[i + 1][j + 1] = dp[i][j] + 1;\n                } else {\n                    dp[i + 1][j + 1] = Math.max(dp[i + 1][j], dp[i][j + 1]);\n                }\n            }\n        }\n\n        int initialValue = dp[n][n];\n        int[] cost = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            cost[i] = n - 2 * dp[i + 1][i + 1];\n        }\n\n        Arrays.sort(cost);\n        int maxChanges = Math.min(K, n);\n        int changes = 0;\n\n        for (int i = 0; i < maxChanges; i++) {\n            if (cost[i] > 0) {\n                changes += cost[i];\n            }\n        }\n\n        return initialValue + Math.min(K, changes);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String S = scanner.next();\n        int K = scanner.nextInt();\n        System.out.println(longestPalindromeValue(S, K));\n    }\n}",
    "timestamp": "2025-08-13 13:53:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n\n#define MAXN 1005\n\nusing namespace std;\n\nint dp[MAXN][MAXN];\nint n;\nint k;\nchar S[MAXN];\nchar T[MAXN];\n\nint longestCommonSubsequence(char* a, char* b, int len) {\n    for (int i = 0; i <= len; i++) {\n        for (int j = 0; j <= len; j++) {\n            if (i == 0 || j == 0) {\n                dp[i][j] = 0;\n            } else {\n                if (a[i - 1] == b[j - 1]) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n    }\n    return dp[len][len];\n}\n\nint maxValue(int current_changes, int index) {\n    if (index >= n) {\n        return longestCommonSubsequence(S, T, n);\n    }\n\n    // Save original character\n    char original = S[index];\n    int max_val = 0;\n\n    // Try all possible characters\n    for (char c = 'a'; c <= 'z'; c++) {\n        // Change character\n        S[index] = c;\n        max_val = max(max_val, maxValue(current_changes + (original != c), index + 1));\n    }\n\n    // Don't change character\n    S[index] = original;\n    max_val = max(max_val, maxValue(current_changes, index + 1));\n\n    return max_val;\n}\n\nint main() {\n    scanf(\"%s\", S);\n    scanf(\"%d\", &k);\n\n    n = strlen(S);\n\n    for (int i = 0; i < n; i++) {\n        T[i] = S[n - i - 1];\n    }\n\n    printf(\"%d\\n\", maxValue(0, 0));\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:53:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function longestCommonSubsequence(s1, s2) {\n    const n = s1.length;\n    const dp = Array.from({ length: n + 1 }, () => Array(n + 1).fill(0));\n    \n    for (let i = 1; i <= n; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (s1[i - 1] === s2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[n][n];\n}\n\nfunction maxPossibleValue(S, K) {\n    const n = S.length;\n    const reverseS = S.split('').reverse().join('');\n    const originalLCSLength = longestCommonSubsequence(S, reverseS);\n  \n    let result = originalLCSLength;\n  \n    for (let i = 0; i <= K; i++) {\n        result = Math.min(n, originalLCSLength + i);\n    }\n  \n    return result;\n}\n\n// Example usage:\n// const S = \"abcde\";\n// const K = 2;\n// console.log(maxPossibleValue(S, K)); // Output depends on S and K",
    "timestamp": "2025-08-13 13:53:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(S, K):\n    N = len(S)\n    max_value = 0\n    \n    for center in range(N):\n        for parity in [0, 1]:\n            # Try all possible centers (odd and even length palindromes)\n            left = center\n            right = center + parity\n            changes_left = K\n            \n            while left >= 0 and right < N and changes_left >= 0:\n                if S[left] != S[right]:\n                    changes_left -= 1\n                \n                if changes_left >= 0:\n                    # Current palindrome length\n                    curr_value = right - left + 1\n                    max_value = max(max_value, curr_value)\n                \n                left -= 1\n                right += 1\n    \n    return max_value\n\n# Read input\nN, K = map(int, input().split())\nS = input().strip()\n\n# Print result\nprint(solve(S, K))",
    "timestamp": "2025-08-13 13:53:47"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function longestCommonSubsequence(s1, s2) {\n    const m = s1.length, n = s2.length;\n    const dp = Array.from({ length: m + 1 }, () => new Array(n + 1).fill(0));\n\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (s1[i - 1] === s2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n\nfunction solve(S, K) {\n    const n = S.length;\n    let maxValue = 0;\n\n    for (let mask = 0; mask < (1 << n); mask++) {\n        if (countBits(mask) > K) continue;\n\n        let T = S.split('');\n        for (let i = 0; i < n; i++) {\n            if (mask & (1 << i)) {\n                T[i] = T[i] === '0' ? '1' : '0';\n            }\n        }\n\n        const reversedT = T.slice().reverse();\n        const value = longestCommonSubsequence(T.join(''), reversedT.join(''));\n        maxValue = Math.max(maxValue, value);\n    }\n\n    return maxValue;\n}\n\nfunction countBits(n) {\n    let count = 0;\n    while (n) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}",
    "timestamp": "2025-08-13 13:53:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    N, K = map(int, sys.stdin.readline().split())\n    S = sys.stdin.readline().strip()\n    \n    # The problem reduces to finding the longest palindromic subsequence (LPS) with at most K changes\n    # The value is the length of the LPS, and we can change up to K characters to make the LPS as long as possible\n    \n    # We can model this with dynamic programming\n    # dp[i][j][k] represents the maximum LPS length for S[i..j] with at most k changes\n    # Initialize a 3D DP table\n    dp = [[[0] * (K + 1) for _ in range(N)] for __ in range(N)]\n    \n    for length in range(1, N + 1):\n        for i in range(N - length + 1):\n            j = i + length - 1\n            for k in range(K + 1):\n                if i == j:\n                    dp[i][j][k] = 1\n                else:\n                    if S[i] == S[j]:\n                        if i + 1 <= j - 1:\n                            dp[i][j][k] = dp[i+1][j-1][k] + 2\n                        else:\n                            dp[i][j][k] = 2\n                    else:\n                        if k >= 1:\n                            if i + 1 <= j - 1:\n                                dp[i][j][k] = dp[i+1][j-1][k-1] + 2\n                            else:\n                                dp[i][j][k] = 2\n                        # Compare with other options\n                        option1 = dp[i+1][j][k] if (i+1 <= j) else 0\n                        option2 = dp[i][j-1][k] if (i <= j-1) else 0\n                        dp[i][j][k] = max(dp[i][j][k], option1, option2)\n    print(dp[0][N-1][K])\n\nsolve()",
    "timestamp": "2025-08-13 13:54:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const readline = require('readline');\n    const rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout\n    });\n\n    rl.on('line', (input) => {\n        const [s, kStr] = input.split(' ');\n        const k = parseInt(kStr);\n        const n = s.length;\n        const dp = Array.from({ length: n + 1 }, () => Array.from({ length: n + 1 }, () => Array(k + 1).fill(0)));\n\n        for (let len = 1; len <= n; len++) {\n            for (let i = 0; i + len <= n; i++) {\n                const j = i + len - 1;\n                for (let l = 0; l <= k; l++) {\n                    if (i === j) {\n                        dp[i][j][l] = 1;\n                    } else if (s[i] === s[j]) {\n                        if (i + 1 <= j - 1) {\n                            dp[i][j][l] = 2 + dp[i + 1][j - 1][l];\n                        } else {\n                            dp[i][j][l] = 2;\n                        }\n                    } else {\n                        if (l > 0) {\n                            if (i + 1 <= j - 1) {\n                                dp[i][j][l] = 2 + dp[i + 1][j - 1][l - 1];\n                            } else {\n                                dp[i][j][l] = 2;\n                            }\n                        }\n                        const option1 = dp[i + 1][j][l];\n                        const option2 = dp[i][j - 1][l];\n                        dp[i][j][l] = Math.max(dp[i][j][l], option1, option2);\n                    }\n                }\n            }\n        }\n\n        console.log(dp[0][n - 1][k]);\n        rl.close();\n    });\n}\n\nsolve();",
    "timestamp": "2025-08-13 13:54:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint longestCommonSubsequence(const string& a, const string& b) {\n    int n = a.size();\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            if (a[i - 1] == b[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[n][n];\n}\n\nint maxPossibleValue(string S, int K) {\n    int n = S.size();\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n    string T = S;\n    reverse(T.begin(), T.end());\n\n    for (int len = 1; len <= n; ++len) {\n        for (int start = 0; start + len <= n; ++start) {\n            int end = start + len;\n            for (int k = 0; k <= K; ++k) {\n                if (S[start] == T[n - end]) {\n                    dp[len][k] = dp[len - 1][k] + 1;\n                } else {\n                    dp[len][k] = dp[len - 1][k];\n                    if (k > 0)\n                        dp[len][k] = max(dp[len][k], dp[len - 1][k - 1] + 1);\n                }\n            }\n        }\n    }\n    return dp[n][K];\n}\n\nint main() {\n    string S;\n    int K;\n    cin >> S >> K;\n    cout << maxPossibleValue(S, K) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 14:41:23"
  }
]