[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdlib.h>\n\n#define MAX_N 100005\n\nint tree[4 * MAX_N];\nint arr[MAX_N];\n\nvoid build(int node, int start, int end) {\n    if (start == end) {\n        tree[node] = arr[start];\n        return;\n    }\n    \n    int mid = (start + end) / 2;\n    build(2 * node, start, mid);\n    build(2 * node + 1, mid + 1, end);\n    \n    tree[node] = (tree[2 * node] < tree[2 * node + 1]) ? tree[2 * node] : tree[2 * node + 1];\n}\n\nvoid update(int node, int start, int end, int idx, int val) {\n    if (start == end) {\n        arr[idx] = val;\n        tree[node] = val;\n        return;\n    }\n    \n    int mid = (start + end) / 2;\n    \n    if (idx <= mid)\n        update(2 * node, start, mid, idx, val);\n    else\n        update(2 * node + 1, mid + 1, end, idx, val);\n    \n    tree[node] = (tree[2 * node] < tree[2 * node + 1]) ? tree[2 * node] : tree[2 * node + 1];\n}\n\nint query(int node, int start, int end, int l, int r) {\n    if (r < start || end < l)\n        return INT_MAX;\n    \n    if (l <= start && end <= r)\n        return tree[node];\n    \n    int mid = (start + end) / 2;\n    \n    int left = query(2 * node, start, mid, l, r);\n    int right = query(2 * node + 1, mid + 1, end, l, r);\n    \n    return (left < right) ? left : right;\n}\n\nint main() {\n    int n, q, op, a, b;\n    \n    scanf(\"%d %d\", &n, &q);\n    \n    for (int i = 0; i < n; i++)\n        arr[i] = INT_MAX;\n    \n    build(1, 0, n - 1);\n    \n    while (q--) {\n        scanf(\"%d %d %d\", &op, &a, &b);\n        \n        if (op == 0)\n            update(1, 0, n - 1, a, b);\n        else\n            printf(\"%d\\n\", query(1, 0, n - 1, a, b));\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:18:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n\n#define MAX_N 100000\n#define INF (1 << 31) - 1\n\nint n;\nint tree[2 * MAX_N];\n\nvoid build() {\n    for (int i = n - 1; i > 0; --i) {\n        tree[i] = (tree[i << 1] < tree[i << 1 | 1]) ? tree[i << 1] : tree[i << 1 | 1];\n    }\n}\n\nvoid update(int i, int x) {\n    for (tree[i += n] = x; i > 1; i >>= 1) {\n        tree[i >> 1] = (tree[i] < tree[i ^ 1]) ? tree[i] : tree[i ^ 1];\n    }\n}\n\nint find(int l, int r) {\n    int res = INF;\n    for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n        if (l & 1) {\n            res = (res < tree[l]) ? res : tree[l];\n            l++;\n        }\n        if (r & 1) {\n            r--;\n            res = (res < tree[r]) ? res : tree[r];\n        }\n    }\n    return res;\n}\n\nint main() {\n    int q;\n    scanf(\"%d %d\", &n, &q);\n    \n    for (int i = 0; i < n; ++i) {\n        tree[n + i] = INF;\n    }\n    build();\n    \n    while (q--) {\n        int op, a, b;\n        scanf(\"%d %d %d\", &op, &a, &b);\n        if (op == 0) {\n            update(a, b);\n        } else {\n            printf(\"%d\\n\", find(a, b + 1));\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:19:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\nclass SegmentTree {\nprivate:\n    int n;\n    vector<int> tree;\n\npublic:\n    SegmentTree(int size) {\n        n = 1;\n        while (n < size) n <<= 1;\n        tree.resize(2 * n - 1, INT_MAX);\n    }\n\n    void update(int idx, int val) {\n        idx += n - 1;\n        tree[idx] = val;\n        while (idx > 0) {\n            idx = (idx - 1) / 2;\n            tree[idx] = min(tree[2 * idx + 1], tree[2 * idx + 2]);\n        }\n    }\n\n    int query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return INT_MAX;\n        if (a <= l && r <= b) return tree[k];\n        int vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n        int vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n        return min(vl, vr);\n    }\n\n    int find(int s, int t) {\n        return query(s, t + 1, 0, 0, n);\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, q;\n    cin >> n >> q;\n    SegmentTree st(n);\n\n    for (int i = 0; i < q; ++i) {\n        int com, x, y;\n        cin >> com >> x >> y;\n        if (com == 0) {\n            st.update(x, y);\n        } else {\n            cout << st.find(x, y) << '\\n';\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:19:18"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main {\n    static class SegmentTree {\n        int[] tree;\n        int size;\n        int n;\n\n        SegmentTree(int n) {\n            this.n = n;\n            size = 1;\n            while (size < n) size <<= 1;\n            tree = new int[2 * size - 1];\n            for (int i = 0; i < 2 * size - 1; i++) {\n                tree[i] = Integer.MAX_VALUE;\n            }\n        }\n\n        void update(int i, int x) {\n            i += size - 1;\n            tree[i] = x;\n            while (i > 0) {\n                i = (i - 1) / 2;\n                tree[i] = Math.min(tree[2 * i + 1], tree[2 * i + 2]);\n            }\n        }\n\n        int query(int a, int b, int k, int l, int r) {\n            if (r <= a || b <= l) return Integer.MAX_VALUE;\n            if (a <= l && r <= b) return tree[k];\n            int vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n            int vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n            return Math.min(vl, vr);\n        }\n\n        int find(int s, int t) {\n            return query(s, t + 1, 0, 0, size);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] line = br.readLine().split(\" \");\n        int n = Integer.parseInt(line[0]);\n        int q = Integer.parseInt(line[1]);\n\n        SegmentTree st = new SegmentTree(n);\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < q; i++) {\n            line = br.readLine().split(\" \");\n            int op = Integer.parseInt(line[0]);\n            int a = Integer.parseInt(line[1]);\n            int b = Integer.parseInt(line[2]);\n            if (op == 0) {\n                st.update(a, b);\n            } else {\n                int res = st.find(a, b);\n                sb.append(res).append(\"\\n\");\n            }\n        }\n        System.out.print(sb.toString());\n    }\n}",
    "timestamp": "2025-08-05 22:19:40"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RangeMinimumQuery {\n    static int[] tree;\n    static int n;\n    static final int INF = Integer.MAX_VALUE;\n\n    static void build(int node, int start, int end) {\n        if (start == end) {\n            tree[node] = INF;\n            return;\n        }\n        int mid = (start + end) / 2;\n        build(2 * node, start, mid);\n        build(2 * node + 1, mid + 1, end);\n        tree[node] = Math.min(tree[2 * node], tree[2 * node + 1]);\n    }\n\n    static void update(int node, int start, int end, int index, int val) {\n        if (start == end) {\n            tree[node] = val;\n            return;\n        }\n        int mid = (start + end) / 2;\n        if (index <= mid)\n            update(2 * node, start, mid, index, val);\n        else\n            update(2 * node + 1, mid + 1, end, index, val);\n        tree[node] = Math.min(tree[2 * node], tree[2 * node + 1]);\n    }\n\n    static int query(int node, int start, int end, int l, int r) {\n        if (r < start || end < l)\n            return INF;\n        if (l <= start && end <= r)\n            return tree[node];\n        int mid = (start + end) / 2;\n        int p1 = query(2 * node, start, mid, l, r);\n        int p2 = query(2 * node + 1, mid + 1, end, l, r);\n        return Math.min(p1, p2);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        int q = sc.nextInt();\n        \n        tree = new int[4 * n];\n        build(1, 0, n - 1);\n\n        for (int i = 0; i < q; i++) {\n            int op = sc.nextInt();\n            if (op == 0) {\n                int index = sc.nextInt();\n                int val = sc.nextInt();\n                update(1, 0, n - 1, index, val);\n            } else {\n                int s = sc.nextInt();\n                int t = sc.nextInt();\n                System.out.println(query(1, 0, n - 1, s, t));\n            }\n        }\n        sc.close();\n    }\n}",
    "timestamp": "2025-08-05 22:19:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <cmath>\n\nusing namespace std;\n\nclass SegmentTree {\nprivate:\n    vector<int> tree;\n    int n;\n\n    void buildTree(vector<int>& arr, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = arr[start];\n            return;\n        }\n        int mid = start + (end - start) / 2;\n        buildTree(arr, 2 * node + 1, start, mid);\n        buildTree(arr, 2 * node + 2, mid + 1, end);\n        tree[node] = min(tree[2 * node + 1], tree[2 * node + 2]);\n    }\n\n    void updateTree(int node, int start, int end, int index, int val) {\n        if (start == end) {\n            tree[node] = val;\n            return;\n        }\n        int mid = start + (end - start) / 2;\n        if (index <= mid)\n            updateTree(2 * node + 1, start, mid, index, val);\n        else\n            updateTree(2 * node + 2, mid + 1, end, index, val);\n        tree[node] = min(tree[2 * node + 1], tree[2 * node + 2]);\n    }\n\n    int queryTree(int node, int start, int end, int l, int r) {\n        if (r < start || end < l)\n            return INT_MAX;\n        \n        if (l <= start && end <= r)\n            return tree[node];\n        \n        int mid = start + (end - start) / 2;\n        int leftMin = queryTree(2 * node + 1, start, mid, l, r);\n        int rightMin = queryTree(2 * node + 2, mid + 1, end, l, r);\n        \n        return min(leftMin, rightMin);\n    }\n\npublic:\n    SegmentTree(int size) {\n        n = size;\n        int height = ceil(log2(n));\n        int maxSize = 2 * pow(2, height) - 1;\n        tree.resize(maxSize, INT_MAX);\n        \n        vector<int> initialArr(n, INT_MAX);\n        buildTree(initialArr, 0, 0, n - 1);\n    }\n\n    void update(int index, int value) {\n        updateTree(0, 0, n - 1, index, value);\n    }\n\n    int find(int l, int r) {\n        return queryTree(0, 0, n - 1, l, r);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, q;\n    cin >> n >> q;\n\n    SegmentTree segTree(n);\n\n    while (q--) {\n        int type, a, b;\n        cin >> type >> a >> b;\n\n        if (type == 0) {\n            segTree.update(a, b);\n        } else {\n            cout << segTree.find(a, b) << \"\\n\";\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:19:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class SegmentTree:\n    def __init__(self, size):\n        self.size = size\n        self.INF = (1 << 31) - 1\n        self.data = [self.INF] * (2 * size)\n\n    def update(self, index, value):\n        index += self.size\n        self.data[index] = value\n        while index > 0:\n            index //= 2\n            self.data[index] = min(self.data[2 * index], self.data[2 * index + 1])\n\n    def find_min(self, left, right):\n        left += self.size\n        right += self.size + 1\n        min_value = self.INF\n        while left < right:\n            if left % 2 == 1:\n                min_value = min(min_value, self.data[left])\n                left += 1\n            if right % 2 == 1:\n                right -= 1\n                min_value = min(min_value, self.data[right])\n            left //= 2\n            right //= 2\n        return min_value\n\ndef process_operations(n, q, operations):\n    results = []\n    seg_tree = SegmentTree(n)\n    \n    for operation in operations:\n        if operation[0] == 0:  # Update operation\n            _, i, x = operation\n            seg_tree.update(i, x)\n        elif operation[0] == 1:  # Find operation\n            _, s, t = operation\n            results.append(seg_tree.find_min(s, t))\n    \n    return results\n\n# Example of processing operations\nn = 5\nq = 4\noperations = [\n    [0, 0, 10],\n    [0, 1, 20],\n    [1, 0, 1],\n    [1, 0, 2]\n]\n\nresults = process_operations(n, q, operations)\nfor result in results:\n    print(result)",
    "timestamp": "2025-08-13 09:57:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\nclass SegmentTree {\n    private int[] tree;\n    private int[] arr;\n    private int n;\n    \n    public SegmentTree(int[] arr) {\n        this.arr = arr;\n        this.n = arr.length;\n        this.tree = new int[4 * n];\n        build(0, 0, n - 1);\n    }\n    \n    private void build(int node, int start, int end) {\n        if (start == end) {\n            // Leaf node will have a single element\n            tree[node] = arr[start];\n        } else {\n            int mid = (start + end) / 2;\n            // Recursively build the segment tree\n            build(2 * node + 1, start, mid);\n            build(2 * node + 2, mid + 1, end);\n            // Internal node will have the minimum of the two children\n            tree[node] = Math.min(tree[2 * node + 1], tree[2 * node + 2]);\n        }\n    }\n    \n    public void update(int idx, int val) {\n        update(0, 0, n - 1, idx, val);\n    }\n    \n    private void update(int node, int start, int end, int idx, int val) {\n        if (start == end) {\n            // Leaf node\n            arr[idx] = val;\n            tree[node] = val;\n        } else {\n            int mid = (start + end) / 2;\n            if (start <= idx && idx <= mid) {\n                update(2 * node + 1, start, mid, idx, val);\n            } else {\n                update(2 * node + 2, mid + 1, end, idx, val);\n            }\n            // Internal node will have the minimum of the two children\n            tree[node] = Math.min(tree[2 * node + 1], tree[2 * node + 2]);\n        }\n    }\n    \n    public int query(int L, int R) {\n        return query(0, 0, n - 1, L, R);\n    }\n    \n    private int query(int node, int start, int end, int L, int R) {\n        if (R < start || end < L) {\n            // range represented by a node is completely outside the given range\n            return Integer.MAX_VALUE;\n        }\n        if (L <= start && end <= R) {\n            // range represented by a node is completely inside the given range\n            return tree[node];\n        }\n        // range represented by a node is partially inside and partially outside the given range\n        int mid = (start + end) / 2;\n        int leftChild = query(2 * node + 1, start, mid, L, R);\n        int rightChild = query(2 * node + 2, mid + 1, end, L, R);\n        return Math.min(leftChild, rightChild);\n    }\n}\n\npublic class SequenceManipulator {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int q = scanner.nextInt();\n        int[] arr = new int[n];\n        // Initialize all elements to 2^31 - 1\n        for (int i = 0; i < n; i++) {\n            arr[i] = Integer.MAX_VALUE;\n        }\n        \n        SegmentTree segTree = new SegmentTree(arr);\n        \n        for (int i = 0; i < q; i++) {\n            int operation = scanner.nextInt();\n            if (operation == 0) {\n                int index = scanner.nextInt();\n                int value = scanner.nextInt();\n                segTree.update(index, value);\n            } else if (operation == 1) {\n                int start = scanner.nextInt();\n                int end = scanner.nextInt();\n                System.out.println(segTree.query(start, end));\n            } \n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 09:58:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define INF 231 - 1\n\ntypedef struct {\n    int *data;\n    int size;\n} SegmentTree;\n\nSegmentTree* createSegmentTree(int n);\nvoid update(SegmentTree* st, int pos, int value);\nint find(SegmentTree* st, int l, int r);\nvoid build(SegmentTree* st, int n);\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    SegmentTree* st = createSegmentTree(n);\n    build(st, n);\n\n    for (int i = 0; i < q; i++) {\n        int type, x, y;\n        scanf(\"%d %d %d\", &type, &x, &y);\n        if (type == 0) {\n            update(st, x, y);\n        } else if (type == 1) {\n            printf(\"%d\\n\", find(st, x, y));\n        }\n    }\n\n    free(st->data);\n    free(st);\n    return 0;\n}\n\nSegmentTree* createSegmentTree(int n) {\n    SegmentTree* st = (SegmentTree*)malloc(sizeof(SegmentTree));\n    st->size = 2 * n;\n    st->data = (int*)malloc(sizeof(int) * st->size);\n    return st;\n}\n\nvoid build(SegmentTree* st, int n) {\n    for (int i = 0; i < n; i++) {\n        st->data[n + i] = INF;\n    }\n    for (int i = n - 1; i > 0; i--) {\n        st->data[i] = st->data[i << 1] < st->data[i << 1 | 1] ? st->data[i << 1] : st->data[i << 1 | 1];\n    }\n}\n\nvoid update(SegmentTree* st, int pos, int value) {\n    pos += st->size / 2;\n    st->data[pos] = value;\n    for (pos >>= 1; pos > 0; pos >>= 1) {\n        st->data[pos] = st->data[pos << 1] < st->data[pos << 1 | 1] ? st->data[pos << 1] : st->data[pos << 1 | 1];\n    }\n}\n\nint find(SegmentTree* st, int l, int r) {\n    int res = INF;\n    l += st->size / 2;\n    r += st->size / 2;\n    while (l <= r) {\n        if (l & 1) res = res < st->data[l] ? res : st->data[l++];\n        if (!(r & 1)) res = res < st->data[r] ? res : st->data[r--];\n        l >>= 1;\n        r >>= 1;\n    }\n    return res;\n}",
    "timestamp": "2025-08-13 09:58:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\nclass SegmentTree:\n    def __init__(self, n):\n        self.n = n\n        self.tree = [2**31-1] * (4*n)\n\n    def update(self, node, start, end, index, value):\n        if start == end:\n            self.tree[node] = value\n            return\n        mid = (start + end) // 2\n        if index <= mid:\n            self.update(2*node, start, mid, index, value)\n        else:\n            self.update(2*node+1, mid+1, end, index, value)\n        self.tree[node] = min(self.tree[2*node], self.tree[2*node+1])\n\n    def query(self, node, start, end, left, right):\n        if right < start or end < left:\n            return 2**31-1\n        if left <= start and end <= right:\n            return self.tree[node]\n        mid = (start + end) // 2\n        l = self.query(2*node, start, mid, left, right)\n        r = self.query(2*node+1, mid+1, end, left, right)\n        return min(l, r)\n\ndef main():\n    n, q = map(int, input().split())\n    st = SegmentTree(n)\n\n    for _ in range(q):\n        op, a, b = map(int, input().split())\n        if op == 0:\n            st.update(1, 0, n-1, a, b)\n        else:\n            print(st.query(1, 0, n-1, a, b))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 09:58:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport math\n\nclass SegmentTree:\n    def __init__(self, size):\n        self.n = 1\n        while self.n < size:\n            self.n <<= 1\n        self.size = size\n        self.tree = [2**31 - 1] * (2 * self.n - 1)\n    \n    def update(self, i, x):\n        i += self.n - 1\n        self.tree[i] = x\n        while i > 0:\n            i = (i - 1) // 2\n            self.tree[i] = min(self.tree[2*i+1], self.tree[2*i+2])\n    \n    def query(self, a, b, k=0, l=0, r=None):\n        if r is None:\n            r = self.n\n        if r <= a or b <= l:\n            return 2**31 - 1\n        if a <= l and r <= b:\n            return self.tree[k]\n        vl = self.query(a, b, 2*k+1, l, (l+r)//2)\n        vr = self.query(a, b, 2*k+2, (l+r)//2, r)\n        return min(vl, vr)\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    q = int(input[ptr])\n    ptr += 1\n    \n    st = SegmentTree(n)\n    \n    for _ in range(q):\n        com = int(input[ptr])\n        ptr += 1\n        if com == 0:\n            i = int(input[ptr])\n            ptr += 1\n            x = int(input[ptr])\n            ptr += 1\n            st.update(i, x)\n        else:\n            s = int(input[ptr])\n            ptr += 1\n            t = int(input[ptr])\n            ptr += 1\n            print(st.query(s, t+1))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 09:58:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nclass SegmentTree {\n    vector<int> tree;\n    int size;\n\n    void buildTree(vector<int>& arr, int start, int end, int node) {\n        if (start == end) {\n            tree[node] = arr[start];\n        } else {\n            int mid = (start + end) / 2;\n            buildTree(arr, start, mid, 2 * node + 1);\n            buildTree(arr, mid + 1, end, 2 * node + 2);\n            tree[node] = min(tree[2 * node + 1], tree[2 * node + 2]);\n        }\n    }\n\n    void updateTree(int start, int end, int index, int value, int node) {\n        if (start == end) {\n            tree[node] = value;\n        } else {\n            int mid = (start + end) / 2;\n            if (index <= mid) {\n                updateTree(start, mid, index, value, 2 * node + 1);\n            } else {\n                updateTree(mid + 1, end, index, value, 2 * node + 2);\n            }\n            tree[node] = min(tree[2 * node + 1], tree[2 * node + 2]);\n        }\n    }\n\n    int queryTree(int start, int end, int left, int right, int node) {\n        if (start > right || end < left) {\n            return INT_MAX;\n        }\n        if (start >= left && end <= right) {\n            return tree[node];\n        }\n        int mid = (start + end) / 2;\n        int leftQuery = queryTree(start, mid, left, right, 2 * node + 1);\n        int rightQuery = queryTree(mid + 1, end, left, right, 2 * node + 2);\n        return min(leftQuery, rightQuery);\n    }\n\npublic:\n    SegmentTree(vector<int>& arr) {\n        size = arr.size();\n        tree.resize(4 * size);\n        buildTree(arr, 0, size - 1, 0);\n    }\n\n    void update(int index, int value) {\n        updateTree(0, size - 1, index, value, 0);\n    }\n\n    int find(int left, int right) {\n        return queryTree(0, size - 1, left, right, 0);\n    }\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    vector<int> A(n, INT_MAX);\n    SegmentTree segTree(A);\n\n    for (int i = 0; i < q; ++i) {\n        int type;\n        cin >> type;\n        if (type == 0) {\n            int index, value;\n            cin >> index >> value;\n            segTree.update(index, value);\n        } else if (type == 1) {\n            int start, end;\n            cin >> start >> end;\n            cout << segTree.find(start, end) << endl;\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 11:56:14"
  }
]