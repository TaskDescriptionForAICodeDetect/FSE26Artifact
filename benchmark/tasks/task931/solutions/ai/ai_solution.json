[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_N 100005\n\nint graph[MAX_N][MAX_N];\nint degree[MAX_N];\ndouble expected[MAX_N];\nint visited[MAX_N];\n\nvoid dfs(int node, int parent) {\n    visited[node] = 1;\n    int valid_moves = 0;\n    \n    for (int j = 0; j < degree[node]; j++) {\n        int neighbor = graph[node][j];\n        if (neighbor != parent && !visited[neighbor]) {\n            valid_moves++;\n        }\n    }\n    \n    if (valid_moves == 0) {\n        expected[node] = 0;\n        return;\n    }\n    \n    expected[node] = 1.0;\n    \n    for (int j = 0; j < degree[node]; j++) {\n        int neighbor = graph[node][j];\n        if (neighbor != parent && !visited[neighbor]) {\n            dfs(neighbor, node);\n            expected[node] += expected[neighbor] / valid_moves;\n        }\n    }\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    memset(degree, 0, sizeof(degree));\n    \n    for (int i = 1; i < N; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        graph[u][degree[u]++] = v;\n        graph[v][degree[v]++] = u;\n    }\n    \n    for (int i = 1; i <= N; i++) {\n        memset(visited, 0, sizeof(visited));\n        dfs(i, 0);\n        printf(\"%.6f\\n\", expected[i]);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:23:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100000\n\ntypedef struct Node {\n    int vertex;\n    struct Node* next;\n} Node;\n\nNode* adj[MAX_N + 1];\ndouble dp[MAX_N + 1];\n\nvoid add_edge(int u, int v) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->vertex = v;\n    node->next = adj[u];\n    adj[u] = node;\n}\n\nvoid dfs(int u, int parent) {\n    int count = 0;\n    double sum = 0.0;\n    for (Node* node = adj[u]; node != NULL; node = node->next) {\n        int v = node->vertex;\n        if (v != parent) {\n            dfs(v, u);\n            sum += dp[v];\n            count++;\n        }\n    }\n    if (count > 0) {\n        dp[u] = sum / count + 1;\n    } else {\n        dp[u] = 0.0;\n    }\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    for (int i = 1; i <= N; i++) {\n        adj[i] = NULL;\n    }\n    for (int i = 0; i < N - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        add_edge(u, v);\n        add_edge(v, u);\n    }\n    dfs(1, -1);\n    for (int i = 1; i <= N; i++) {\n        printf(\"%.15f\\n\", dp[i]);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 23:23:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<double> res;\n\nvoid dfs(int u, int parent, double prob, int depth) {\n    int children = 0;\n    for (int v : adj[u]) {\n        if (v != parent) {\n            children++;\n        }\n    }\n    if (children == 0) {\n        res[u] += prob * depth;\n        return;\n    }\n    double p = prob / children;\n    for (int v : adj[u]) {\n        if (v != parent) {\n            dfs(v, u, p, depth + 1);\n        }\n    }\n}\n\nint main() {\n    int N;\n    cin >> N;\n    adj.resize(N + 1);\n    res.resize(N + 1, 0.0);\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    for (int i = 1; i <= N; ++i) {\n        dfs(i, -1, 1.0, 0);\n    }\n    cout << fixed << setprecision(10);\n    for (int i = 1; i <= N; ++i) {\n        cout << res[i] << \"\\n\";\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 23:23:54"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static List<Integer>[] adj;\n    static double[] dp;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int N = Integer.parseInt(br.readLine());\n        adj = new ArrayList[N + 1];\n        for (int i = 1; i <= N; i++) {\n            adj[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < N - 1; i++) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int u = Integer.parseInt(st.nextToken());\n            int v = Integer.parseInt(st.nextToken());\n            adj[u].add(v);\n            adj[v].add(u);\n        }\n\n        dp = new double[N + 1];\n        dfs(1, -1);\n\n        for (int i = 1; i <= N; i++) {\n            System.out.println(dp[i]);\n        }\n    }\n\n    static void dfs(int u, int parent) {\n        int children = 0;\n        double sum = 0;\n        for (int v : adj[u]) {\n            if (v != parent) {\n                children++;\n                dfs(v, u);\n                sum += dp[v];\n            }\n        }\n        if (children > 0) {\n            dp[u] = sum / children + 1;\n        } else {\n            dp[u] = 0;\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:24:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class GraphTraversal {\n    static final int MAX_N = 3005;\n    static List<Integer>[] graph;\n    static int N;\n\n    public static double[] expectedTurns() {\n        double[] result = new double[N + 1];\n        for (int start = 1; start start <= N; start++) {\n            result[start] = solve(start);\n        }\n        return result;\n    }\n\n    static double solve(int start) {\n        double[] dp = new double[N + 1];\n        boolean[] visited = new boolean[N + 1];\n\n        dp[start] = 0;\n        visited[start] = true;\n\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(start);\n\n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            int availableMoves = 0;\n\n            for (int neighbor : graph[current]) {\n                if (!visited[neighbor]) {\n                    availableMoves++;\n                }\n            }\n\n            for (int neighbor : graph[current]) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    dp[neighbor] = dp[current] + 1.0 / availableMoves;\n                    queue.offer(neighbor);\n                }\n            }\n        }\n\n        return Arrays.stream(dp).sum();\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        N = scanner.nextInt();\n        graph = new List[N + 1];\n\n        for (int i = 1; i <= N; i++) {\n            graph[i] = new ArrayList<>();\n        }\n\n        for (int i = 1; i < N; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            graph[u].add(v);\n            graph[v].add(u);\n        }\n\n        double[] ans = expectedTurns();\n        for (int i = 1; i <= N; i++) {\n            System.out.printf(\"%.10f\\n\", ans[i]);\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:24:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\nvector<int> graph[MAXN];\nbool visited[MAXN];\n\ndouble dfs(int u) {\n    visited[u] = true;\n    int unvisited_neighbors = 0;\n    \n    for (int v : graph[u]) {\n        if (!visited[v]) {\n            unvisited_neighbors++;\n        }\n    }\n    \n    if (unvisited_neighbors == 0) return 0;\n    \n    double expected_turns = 1.0;\n    \n    for (int v : graph[u]) {\n        if (!visited[v]) {\n            expected_turns += dfs(v) / unvisited_neighbors;\n        }\n    }\n    \n    return expected_turns;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    \n    for (int i = 1; i < N; i++) {\n        int u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n    \n    for (int i = 1; i <= N; i++) {\n        memset(visited, 0, sizeof(visited));\n        printf(\"%.6f\\n\", dfs(i));\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:24:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def expected_turns(n, edges):\n    from collections import defaultdict\n    import sys\n    sys.setrecursionlimit(3000)\n    \n    # Create adjacency list\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # DP and subtree size\n    dp = [0] * (n + 1)\n    subtree_size = [0] * (n + 1)\n\n    def dfs(node, parent):\n        subtree_size[node] = 1\n        for neighbor in graph[node]:\n            if neighbor == parent:\n                continue\n            dfs(neighbor, node)\n            subtree_size[node] += subtree_size[neighbor]\n            dp[node] += dp[neighbor] + subtree_size[neighbor]\n\n    def calc_expected_value(node, parent, contribution):\n        # Include external subtree contribution\n        dp[node] += contribution\n        total_turns[node] = dp[node]\n        for neighbor in graph[node]:\n            if neighbor == parent:\n                continue\n            # Re-rooting technique\n            calc_expected_value(neighbor, node,\n                                contribution + (dp[node] - dp[neighbor] - subtree_size[neighbor]) + n - subtree_size[neighbor])\n\n    # Calculate dp and subtree_sizes from one root (say 1)\n    dfs(1, -1)\n    \n    # Calculate expected values using results from one root\n    total_turns = [0] * (n + 1)\n    calc_expected_value(1, -1, 0)\n    \n    # Calculate actual expected values\n    expected_values = [0] * (n + 1)\n    for i in range(1, n + 1):\n        expected_values[i] = total_turns[i] / n\n    \n    return expected_values[1:]\n\n# Example Usage\nN = 5\nedges = [(1, 2), (1, 3), (2, 4), (2, 5)]\nprint(expected_turns(N, edges))",
    "timestamp": "2025-08-13 15:05:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class GraphTurns {\n\n    static ArrayList<Integer>[] graph;\n    static double[] expectedValue;\n    static boolean[] visited;\n    static int N;\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        N = Integer.parseInt(br.readLine().trim());\n        graph = new ArrayList[N + 1];\n        expectedValue = new double[N + 1];\n        \n        for (int i = 1; i <= N; i++) {\n            graph[i] = new ArrayList<>();\n        }\n\n        for (int i = 0; i < N - 1; i++) {\n            String[] edges = br.readLine().trim().split(\" \");\n            int u = Integer.parseInt(edges[0]);\n            int v = Integer.parseInt(edges[1]);\n            graph[u].add(v);\n            graph[v].add(u);\n        }\n        \n        for (int i = 1; i <= N; i++) {\n            visited = new boolean[N + 1];\n            expectedValue[i] = dfs(i);\n        }\n\n        // Print the results\n        for (int i = 1; i <= N; i++) {\n            System.out.printf(\"%.10f%n\", expectedValue[i]);\n        }\n    }\n\n    static double dfs(int node) {\n        visited[node] = true;\n        double turns = 0.0;\n        int totalChoices = 0;\n\n        for (int neighbor : graph[node]) {\n            if (!visited[neighbor]) {\n                totalChoices++;\n            }\n        }\n\n        if (totalChoices == 0) {\n            visited[node] = false;\n            return 0.0; \n        }\n\n        for (int neighbor : graph[node]) {\n            if (!visited[neighbor]) {\n                turns += (1.0 / totalChoices) * (1 + dfs(neighbor));\n            }\n        }\n\n        visited[node] = false;\n        return turns;\n    }\n}",
    "timestamp": "2025-08-13 15:05:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 1000\n\ntypedef struct {\n    int head;\n    struct Node *next;\n} Node;\n\nNode *adjList[MAX_N + 1];\ndouble expectedTurns[MAX_N + 1];\n\n// Function to add an edge in the adjacency list\nvoid addEdge(int u, int v) {\n    Node *node = (Node *)malloc(sizeof(Node));\n    node->head = v;\n    node->next = adjList[u];\n    adjList[u] = node;\n}\n\nvoid initializeAdjList(int n) {\n    for (int i = 1; i <= n; i++) {\n        adjList[i] = NULL;\n    }\n}\n\ndouble dfsExpectedTurns(int u, int parent) {\n    double sum = 0.0;\n    int count = 0;\n   \n    for (Node *iter = adjList[u]; iter; iter = iter->next) {\n        int v = iter->head;\n        if (v != parent) {\n            sum += dfsExpectedTurns(v, u);\n            count++;\n        }\n    }\n\n    // If there are no adjacent unvisited vertices\n    if (count == 0) {\n        expectedTurns[u] = 0.0;\n        return expectedTurns[u];\n    }\n\n    expectedTurns[u] = 1.0 + sum / count;\n    return expectedTurns[u];\n}\n\nint main() {\n    int n, u, v;\n    \n    scanf(\"%d\", &n);\n    initializeAdjList(n);\n\n    for (int i = 0; i < n - 1; i++) {\n        scanf(\"%d%d\", &u, &v);\n        addEdge(u, v);\n        addEdge(v, u);\n    }\n\n    for (int i = 1; i <= n; i++) {\n        dfsExpectedTurns(i, -1);\n        printf(\"%.6lf\\n\", expectedTurns[i]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 15:05:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <iomanip>\n\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<double> expected;\n\nvoid bfs(int start, int N) {\n    queue<pair<int, double>> q;\n    vector<bool> visited(N+1, false);\n    q.push({start, 1.0});\n    visited[start] = true;\n    double result = 0.0;\n    while (!q.empty()) {\n        auto [vertex, prob] = q.front();\n        q.pop();\n        int ways = 0;\n        for (int neighbor : adj[vertex]) {\n            if (!visited[neighbor]) ++ways;\n        }\n        if (ways == 0) {\n            result += prob;\n        } else {\n            for (int neighbor : adj[vertex]) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    q.push({neighbor, prob / ways});\n                }\n            }\n        }\n    }\n    expected[start] = result;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    adj.resize(N+1);\n    expected.resize(N+1, 0.0);\n\n    for (int i = 0; i < N-1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    for (int i = 1; i <= N; ++i) {\n        bfs(i, N);\n    }\n\n    cout << fixed << setprecision(6);\n    for (int i = 1; i <= N; ++i) {\n        cout << expected[i] << \"\\n\";\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 15:05:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\n\ndef solve_graph_traversal(N, edges):\n    # Create adjacency list representation of the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def expected_turns(start):\n        # Track visited vertices and expected turns\n        def dfs(node, visited):\n            # Get unvisited neighbors\n            neighbors = [v for v in graph[node] if v not in visited]\n            \n            # If no unvisited neighbors, end recursion\n            if not neighbors:\n                return 0\n            \n            # Probability of choosing each neighbor\n            p = 1 / len(neighbors)\n            \n            # Expected turns is 1 (current turn) + expected turns from next vertices\n            expected = 1 + sum(\n                p * (1 + dfs(next_node, visited | {next_node})) \n                for next_node in neighbors\n            )\n            \n            return expected\n        \n        return dfs(start, {start})\n    \n    # Calculate expected turns for each starting vertex\n    return [expected_turns(i) for i in range(1, N+1)]\n\n# Input parsing and solution\ndef main():\n    N = int(input())\n    edges = []\n    for _ in range(N-1):\n        u, v = map(int, input().split())\n        edges.append((u-1, v-1))  # 0-based indexing\n    \n    results = solve_graph_traversal(N, edges)\n    for result in results:\n        print(f\"{result:.6f}\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 15:05:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    N = int(sys.stdin.readline())\n    adj = [[] for _ in range(N+1)]\n    for _ in range(N-1):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    # We'll compute for each node u, the expected value E[u]\n    E = [0.0] * (N + 1)\n    \n    # We'll perform a post-order traversal to compute E[u]\n    parent = [0] * (N + 1)\n    children = [[] for _ in range(N + 1)]\n    root = 1\n    stack = [(root, None, False)]\n    \n    while stack:\n        u, p, visited = stack.pop()\n        if not visited:\n            parent[u] = p\n            stack.append((u, p, True))\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u, False))\n                    children[u].append(v)\n        else:\n            if not children[u]:\n                E[u] = 0.0\n            else:\n                total = 0.0\n                for v in children[u]:\n                    total += E[v]\n                m = len(children[u])\n                E[u] = (total + m) / m\n    \n    # Now perform BFS to compute E for all nodes using parent information\n    q = deque([root])\n    while q:\n        u = q.popleft()\n        for v in children[u]:\n            q.append(v)\n    \n    # Now, perform a second pass to compute E considering parent contributions\n    q = deque([root])\n    while q:\n        u = q.popleft()\n        p = parent[u]\n        if p is not None:\n            m = len(adj[u]) - 1  # number of children (excluding parent)\n            if m == 0:\n                continue\n            # The parent's contribution is (E[p] - (E[u] + m_prev) / m_prev) * m_prev / (m_prev + 1) + 1\n            # But need to adjust for the parent's siblings\n            m_prev = len(adj[p]) - 1\n            if m_prev == 0:\n                continue\n            # The parent's E[p] was computed as (sum_{v in children[p]} E[v] + m_prev) / m_prev\n            # So, sum_{v in children[p]} E[v] = E[p] * m_prev - m_prev\n            # Now, for u, the parent's contribution is (E[p] * m_prev - m_prev - (E[u] + m_prev - 1)) / (m_prev - 1) + 1\n            # But this is complex, so we need to recompute E[u] considering parent's E\n            # Alternative approach: For each node u, E[u] = (sum_{v in children} E[v] + (E_parent_contribution) + (degree - 1)) / (degree - 1)\n            # But E_parent_contribution is E[p] - (sum_{v in children[p]} E[v] + m_prev) / m_prev\n            pass  # This part is complex and requires careful handling\n    \n    # The above approach is incomplete; here's a better approach using memoization and DP\n    # We'll compute E[u] for each node u considering parent contributions\n    # Re-initialize E\n    E = [0.0] * (N + 1)\n    # We'll use memoization and a post-order followed by a pre-order traversal\n    # First pass: post-order to compute E without parent contributions\n    stack = [(root, None, False)]\n    while stack:\n        u, p, visited = stack.pop()\n        if not visited:\n            stack.append((u, p, True))\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u, False))\n        else:\n            m = len(adj[u]) - (1 if p is not None else 0)\n            if m == 0:\n                E[u] = 0.0\n            else:\n                total = 0.0\n                cnt = 0\n                for v in adj[u]:\n                    if v != p:\n                        total += E[v]\n                        cnt += 1\n                E[u] = (total + cnt) / cnt\n    \n    # Second pass: pre-order to update E with parent contributions\n    stack = [(root, None, -1.0)]\n    while stack:\n        u, p, parent_contribution = stack.pop()\n        if p is not None:\n            m_parent = len(adj[u]) - 1\n            if m_parent == 0:\n                pass\n            else:\n                # The parent_contribution is (E_parent - (sum_{v in children_parent} E[v] + m_parent) / m_parent)\n                # But this is not straightforward, so we need to adjust E[u]\n                # Alternative: For u, E[u] = (sum_{v in adj[u]} E[v] + (deg(u) - 1)) / (deg(u) - 1)\n                # But this includes parent's E, which is not yet computed correctly\n                pass  # This is complex\n    \n    # Given the complexity, here's an alternative approach using memoization and DP with memo[u][parent_used]\n    # But it's O(N^2) which is not feasible for large N\n    # Hence, the correct approach is to realize that E[u] = (sum_{v in children} E[v] + m) / m + (parent_contribution)\n    # But parent_contribution is (E[p] - (sum_{v in children[p]} E[v] + m_p) / m_p) * m_p / (m_p + 1) + 1\n    # This is getting too complex for a simple code, so here's a simplified version that works for trees (since it's a tree, the parent contribution can be handled differently)\n    \n    # Re-defining the approach: For each node u, E[u] is the expected value starting from u, considering parent as a child only if parent is not visited\n    # So, we can model it as E[u] = (sum_{v in children} E[v] + (E_parent if parent is not None) + (number of children + (1 if parent is not None))) / (number of children + (1 if parent is not None))\n    # But E_parent is E[p] excluding the contribution from u\n    # So, E_parent_excluding_u = (E[p] * (deg(p) - 1) - (E[u] + (deg(p) - 1))) / (deg(p) - 2) if deg(p) > 2\n    # This is complex, so we'll use a memoization approach\n    \n    # Re-initialize E\n    E = [0.0] * (N + 1)\n    # We'll perform a post-order followed by a pre-order traversal\n    # First pass: post-order to compute E without parent contributions\n    stack = [(root, None, False)]\n    while stack:\n        u, p, visited = stack.pop()\n        if not visited:\n            stack.append((u, p, True))\n            # Push children in reverse order to process them in order\n            for v in reversed(adj[u]):\n                if v != p:\n                    stack.append((v, u, False))\n        else:\n            m = 0\n            total = 0.0\n            for v in adj[u]:\n                if v != p:\n                    m += 1\n                    total += E[v]\n            if m == 0:\n                E[u] = 0.0\n            else:\n                E[u] = (total + m) / m\n    \n    # Second pass: pre-order to update E with parent contributions\n    stack = [(root, None)]\n    while stack:\n        u, p = stack.pop()\n        if p is not None:\n            m_p = len(adj[p]) - 1\n            if m_p == 1:\n                # Parent has only u as child, so parent's E is (E[u] + 1)/1\n                # So, parent's contribution is 0 (since parent's E is fully dependent on u)\n                pass\n            else:\n                # Parent's E[p] is (sum_{v in children[p]} E[v] + m_p) / m_p\n                # So, sum_{v in children[p]} E[v] = E[p] * m_p - m_p\n                # Excluding u, sum_{v in children[p], v != u} E[v] = E[p] * m_p - m_p - E[u]\n                # The new m_p is m_p - 1\n                new_m_p = m_p - 1\n                if new_m_p == 0:\n                    parent_contribution = 0.0\n                else:\n                    sum_excluding_u = E[p] * m_p - m_p - E[u]\n                    parent_contribution = (sum_excluding_u + new_m_p) / new_m_p\n                # Now, for u, the parent's contribution is parent_contribution\n                m_u = len(adj[u]) - 1\n                if m_u == 0:\n                    pass\n                else:\n                    # E[u] was (sum_{v in children[u]} E[v] + m_u) / m_u\n                    # Now, it should be (sum_{v in children[u]} E[v] + parent_contribution + (m_u + 1 - 1)) / (m_u + 1 - 1 + 1)\n                    # Wait, no. The correct formula is:\n                    # E[u] = (sum_{v in adj[u], v != p} E[v] + parent_contribution + (number of children + 1)) / (number of children + 1)\n                    # But parent_contribution is E_parent_excluding_u\n                    # So, E[u] = (sum_{v in children[u]} E[v] + parent_contribution + (m_u + 1)) / (m_u + 1)\n                    total = 0.0\n                    cnt = 0\n                    for v in adj[u]:\n                        if v != p:\n                            total += E[v]\n                            cnt += 1\n                    E[u] = (total + parent_contribution + cnt + 1) / (cnt + 1)\n        for v in adj[u]:\n            if v != p:\n                stack.append((v, u))\n    \n    for i in range(1, N+1):\n        print(\"{0:.10f}\".format(E[i]))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 15:06:52"
  }
]